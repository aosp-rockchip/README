From 8adf1e2b249a769caa1498bd4a1d70b67795180c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=BC=A0=E6=99=B4?= <zhangqing@rock-chips.com>
Date: Mon, 29 Oct 2012 15:13:17 +0800
Subject: [PATCH] rk3066b:rk2928:pmu voltage initial and pmu_sleep io initial

---
 .../mach-rk2928/board-rk2928-sdk-tps65910.c   |  40 +-
 arch/arm/mach-rk2928/board-rk2928-tb.c        |  19 +-
 ...k3066b-tps65910.c => board-pmu-tps65910.c} |  59 +-
 ...rd-rk3066b-wm8326.c => board-pmu-wm8326.c} |  64 +-
 arch/arm/mach-rk30/board-rk3066b-m701.c       | 178 +++-
 .../mach-rk30/board-rk3066b-sdk-tps65910.c    | 648 ------------
 arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c | 953 ------------------
 arch/arm/mach-rk30/board-rk3066b-sdk.c        |  40 +-
 arch/arm/mach-rk30/pm.c                       |   2 +
 arch/arm/plat-rk/include/plat/sram.h          |  12 +
 arch/arm/plat-rk/sram.c                       |  39 +-
 11 files changed, 319 insertions(+), 1735 deletions(-)
 rename arch/arm/mach-rk30/{board-rk3066b-tps65910.c => board-pmu-tps65910.c} (92%)
 rename arch/arm/mach-rk30/{board-rk3066b-wm8326.c => board-pmu-wm8326.c} (93%)
 delete mode 100755 arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
 delete mode 100755 arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
 mode change 100644 => 100755 arch/arm/mach-rk30/pm.c
 mode change 100644 => 100755 arch/arm/plat-rk/include/plat/sram.h
 mode change 100644 => 100755 arch/arm/plat-rk/sram.c

diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
index b9b0caf420c5..43c24ce64675 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
@@ -9,43 +9,6 @@
 
 #ifdef CONFIG_MFD_TPS65910
 
-#define GPIO_SWPORTA_DR  0x0000
-#define GPIO_SWPORTA_DDR 0x0004
-struct sram_gpio_data {
-       void __iomem *base;
-       uint offset;
-};
-
-static __sramdata struct sram_gpio_data pmic_sleep;
-static void __iomem *gpio_base[] = {RK2928_GPIO0_BASE, RK2928_GPIO1_BASE, RK2928_GPIO2_BASE, RK2928_GPIO3_BASE};
-
-static int sram_gpio_init(int gpio, struct sram_gpio_data *data)
-{
-       unsigned index;
-
-       if(gpio == INVALID_GPIO)
-               return -EINVAL;
-       index = gpio - PIN_BASE;
-       if(index/NUM_GROUP >= ARRAY_SIZE(gpio_base))
-               return -EINVAL;
-
-       data->base = gpio_base[index/NUM_GROUP];
-       data->offset = index%NUM_GROUP;
-
-       return 0;
-}
-
-static __sramfunc void sram_gpio_set_value(struct sram_gpio_data data, uint value)
-{
-       writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DDR)| (1<<data.offset),
-                       data.base + GPIO_SWPORTA_DDR);
-       if(value)
-               writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DR) | (1<<data.offset),
-                               data.base + GPIO_SWPORTA_DR);
-       else
-               writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DR) & ~(1<<data.offset),
-                               data.base + GPIO_SWPORTA_DR);
-}
 extern int platform_device_register(struct platform_device *pdev);
 
 int tps65910_pre_init(struct tps65910 *tps65910){
@@ -565,8 +528,7 @@ void __sramfunc board_pmu_tps65910_suspend(void)
 }
 void __sramfunc board_pmu_tps65910_resume(void)
 {
-	int ret;
-        sram_gpio_set_value(pmic_sleep, GPIO_LOW);  
+       sram_gpio_set_value(pmic_sleep, GPIO_LOW);  
 	sram_udelay(2000);
 }
 static struct tps65910_board tps65910_data = {
diff --git a/arch/arm/mach-rk2928/board-rk2928-tb.c b/arch/arm/mach-rk2928/board-rk2928-tb.c
index 6b006928cbb3..68ae29896633 100755
--- a/arch/arm/mach-rk2928/board-rk2928-tb.c
+++ b/arch/arm/mach-rk2928/board-rk2928-tb.c
@@ -843,7 +843,7 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 #elif defined(CONFIG_MACH_RK2926_TB)
 #define TPS65910_HOST_IRQ        RK2928_PIN1_PB1
 #endif
-#define PMU_POWER_SLEEP RK2928_PIN3_PD2
+#define PMU_POWER_SLEEP RK2928_PIN1_PA1
 
 static struct pmu_info  tps65910_dcdc_info[] = {
 	{
@@ -932,6 +932,23 @@ static struct i2c_board_info __initdata i2c1_info[] = {
 
 };
 #endif
+
+void __sramfunc board_pmu_suspend(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910() )
+        board_pmu_tps65910_suspend(); 
+   	#endif   
+}
+void __sramfunc board_pmu_resume(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910() )
+        board_pmu_tps65910_resume(); 
+	#endif
+}
+
+
 #ifdef CONFIG_I2C2_RK30
 static struct i2c_board_info __initdata i2c2_info[] = {
 #if defined (CONFIG_EETI_EGALAX)
diff --git a/arch/arm/mach-rk30/board-rk3066b-tps65910.c b/arch/arm/mach-rk30/board-pmu-tps65910.c
similarity index 92%
rename from arch/arm/mach-rk30/board-rk3066b-tps65910.c
rename to arch/arm/mach-rk30/board-pmu-tps65910.c
index 14c94fa02ddd..d0b31ba9d317 100755
--- a/arch/arm/mach-rk30/board-rk3066b-tps65910.c
+++ b/arch/arm/mach-rk30/board-pmu-tps65910.c
@@ -7,26 +7,8 @@
 #include <mach/gpio.h>
 #include <mach/iomux.h>
 
-#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
-#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
-
-#define CRU_CLKGATE5_CON_ADDR 0x00e4
-#define GRF_GPIO6L_DIR_ADDR 0x0030
-#define GRF_GPIO6L_DO_ADDR 0x0068
-#define GRF_GPIO6L_EN_ADDR 0x00a0
-#define GPIO6_PB3_DIR_OUT  0x08000800
-#define GPIO6_PB3_DO_LOW  0x08000000
-#define GPIO6_PB3_DO_HIGH  0x08000800
-#define GPIO6_PB3_EN_MASK  0x08000800
-#define GPIO6_PB3_UNEN_MASK  0x08000000
-#define GPIO6_PB1_DIR_OUT  0x02000200
-#define GPIO6_PB1_DO_LOW  0x02000000
-#define GPIO6_PB1_DO_HIGH  0x02000200
-#define GPIO6_PB1_EN_MASK  0x02000200
-#define GPIO6_PB1_UNEN_MASK  0x02000000
-
 #ifdef CONFIG_MFD_TPS65910
-	
+
 extern int platform_device_register(struct platform_device *pdev);
 
 int tps65910_pre_init(struct tps65910 *tps65910){
@@ -36,8 +18,26 @@ int tps65910_pre_init(struct tps65910 *tps65910){
 	int err = -1;
 		
 	printk("%s,line=%d\n", __func__,__LINE__);	
-	//gpio_request(PMU_POWER_SLEEP, "NULL");
-	//gpio_direction_output(PMU_POWER_SLEEP, GPIO_HIGH);
+	
+	#ifdef CONFIG_RK_CONFIG
+	if(sram_gpio_init(get_port_config(pmic_slp).gpio, &pmic_sleep) < 0){
+		printk(KERN_ERR "sram_gpio_init failed\n");
+		return -EINVAL;
+	}
+	if(port_output_init(pmic_slp, 0, "pmic_slp") < 0){
+		printk(KERN_ERR "port_output_init failed\n");
+		return -EINVAL;
+	}
+	#else
+	if(sram_gpio_init(PMU_POWER_SLEEP, &pmic_sleep) < 0){
+		printk(KERN_ERR "sram_gpio_init failed\n");
+		return -EINVAL;
+	}
+
+	gpio_request(PMU_POWER_SLEEP, "NULL");
+	gpio_direction_output(PMU_POWER_SLEEP, GPIO_LOW);
+	#endif
+
 
 	/*************set vdd11 (pll) voltage 1.0v********************/
 	val = tps65910_reg_read(tps65910, TPS65910_VDIG2);
@@ -540,26 +540,13 @@ static struct regulator_init_data tps65910_ldo8 = {
 
 void __sramfunc board_pmu_tps65910_suspend(void)
 {	
-#if 0 
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#endif
+	 sram_gpio_set_value(pmic_sleep, GPIO_HIGH);  
 }
 void __sramfunc board_pmu_tps65910_resume(void)
 {
-#if 0
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-	#ifdef CONFIG_CLK_SWITCH_TO_32K                 //switch clk to 24M
-	sram_32k_udelay(10000);
-	#else
+ 	sram_gpio_set_value(pmic_sleep, GPIO_LOW);  
 	sram_udelay(2000);
-	#endif
-#endif
 }
-
 static struct tps65910_board tps65910_data = {
 	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
 	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
diff --git a/arch/arm/mach-rk30/board-rk3066b-wm8326.c b/arch/arm/mach-rk30/board-pmu-wm8326.c
similarity index 93%
rename from arch/arm/mach-rk30/board-rk3066b-wm8326.c
rename to arch/arm/mach-rk30/board-pmu-wm8326.c
index f606f6b0f8bf..7b47bde55ac5 100755
--- a/arch/arm/mach-rk30/board-rk3066b-wm8326.c
+++ b/arch/arm/mach-rk30/board-pmu-wm8326.c
@@ -7,23 +7,6 @@
 #include <mach/sram.h>
 #include <linux/earlysuspend.h>
 
-#define cru_readl(offset)	readl_relaxed(RK30_CRU_BASE + offset)
-#define cru_writel(v, offset)	do { writel_relaxed(v, RK30_CRU_BASE + offset); dsb(); } while (0)
-
-#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
-#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
-
-#define CRU_CLKGATE5_CON_ADDR 0x00e4
-#define GRF_GPIO6L_DIR_ADDR 0x0030
-#define GRF_GPIO6L_DO_ADDR 0x0068
-#define GRF_GPIO6L_EN_ADDR 0x00a0
-#define CRU_CLKGATE5_GRFCLK_ON 0x00100000
-#define CRU_CLKGATE5_GRFCLK_OFF 0x00100010
-#define GPIO6_PB1_DIR_OUT  0x02000200
-#define GPIO6_PB1_DO_LOW  0x02000000
-#define GPIO6_PB1_DO_HIGH  0x02000200
-#define GPIO6_PB1_EN_MASK  0x02000200
-#define GPIO6_PB1_UNEN_MASK  0x02000000
 
 /* wm8326 pmu*/
 #if defined(CONFIG_GPIO_WM831X)
@@ -97,9 +80,26 @@ static int wm831x_pre_init(struct wm831x *parm)
 {
 	int ret;
 	Wm831x = parm;
-//	printk("%s\n", __func__);
+	printk("%s\n", __func__);
+
+	#ifdef CONFIG_RK_CONFIG
+	if(sram_gpio_init(get_port_config(pmic_slp).gpio, &pmic_sleep) < 0){
+		printk(KERN_ERR "sram_gpio_init failed\n");
+		return -EINVAL;
+	}
+	if(port_output_init(pmic_slp, 0, "pmic_slp") < 0){
+		printk(KERN_ERR "port_output_init failed\n");
+		return -EINVAL;
+	}
+	#else
+	if(sram_gpio_init(PMU_POWER_SLEEP, &pmic_sleep) < 0){
+		printk(KERN_ERR "sram_gpio_init failed\n");
+		return -EINVAL;
+	}
+
 	gpio_request(PMU_POWER_SLEEP, "NULL");
 	gpio_direction_output(PMU_POWER_SLEEP, GPIO_LOW);
+	#endif
 
 	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
 	#ifdef CONFIG_BATTERY_RK30_VOL3V8
@@ -191,7 +191,7 @@ int wm831x_post_init(struct wm831x *Wm831x)
 	{
 	dcdc =regulator_get(NULL, wm8326_dcdc_info[i].name);
 	regulator_set_voltage(dcdc, wm8326_dcdc_info[i].min_uv, wm8326_dcdc_info[i].max_uv);
-	regulator_set_suspend_voltage(dcdc, wm8326_dcdc_info[1].suspend_vol);
+	regulator_set_suspend_voltage(dcdc, wm8326_dcdc_info[i].suspend_vol);
 	regulator_enable(dcdc);
 	printk("%s  %s =%dmV end\n", __func__,wm8326_dcdc_info[i].name, regulator_get_voltage(dcdc));
 	regulator_put(dcdc);
@@ -206,6 +206,7 @@ int wm831x_post_init(struct wm831x *Wm831x)
 	regulator_enable(ldo);
 	//printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(ldo));
 	regulator_put(ldo);
+	udelay(100);
 	}
 	
 	wm831x_mask_interrupt(Wm831x);
@@ -774,25 +775,16 @@ void wm831x_pmu_early_resume(struct regulator_dev *rdev)
 
 void __sramfunc board_pmu_wm8326_suspend(void)
 {	
-#if 0
-	cru_writel(CRU_CLKGATE5_GRFCLK_ON,CRU_CLKGATE5_CON_ADDR); //open grf clk
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#endif
-}
+	#ifdef CONFIG_CLK_SWITCH_TO_32K
+	sram_gpio_set_value(pmic_sleep, GPIO_HIGH);  
+	#endif
+ }
 void __sramfunc board_pmu_wm8326_resume(void)
 {
-#if 0
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);     //set gpio6_b1 output high
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#ifdef CONFIG_CLK_SWITCH_TO_32K
-	sram_32k_udelay(10000);
-#else
-	sram_udelay(10000);
-#endif
-#endif
+	#ifdef CONFIG_CLK_SWITCH_TO_32K
+	sram_gpio_set_value(pmic_sleep, GPIO_LOW);  
+	sram_udelay(2000);
+	#endif
 }
 static struct wm831x_pdata wm831x_platdata = {
 
diff --git a/arch/arm/mach-rk30/board-rk3066b-m701.c b/arch/arm/mach-rk30/board-rk3066b-m701.c
index a07b5df42fec..d192556b1cbb 100755
--- a/arch/arm/mach-rk30/board-rk3066b-m701.c
+++ b/arch/arm/mach-rk30/board-rk3066b-m701.c
@@ -1415,11 +1415,182 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 int __sramdata g_pmic_type =  0;
 #ifdef CONFIG_I2C1_RK30
 #ifdef CONFIG_MFD_WM831X_I2C
-#include "board-rk3066b-sdk-wm8326.c"
+
+#define PMU_POWER_SLEEP 		RK30_PIN0_PA1 
+
+static struct pmu_info  wm8326_dcdc_info[] = {
+	{
+		.name          = "vdd_core",   //logic
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "vdd_cpu",    //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "dcdc3",   //ddr
+		.min_uv          = 1150000,
+		.max_uv         = 1150000,
+		.suspend_vol  =  1150000,
+	},
+	#ifdef CONFIG_MACH_RK3066_SDK
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3000000,
+	},
+	#else
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+		.suspend_vol  =  2800000,
+	},
+	#endif
+};
+
+static struct pmu_info  wm8326_ldo_info[] = {
+	{
+		.name          = "ldo1",   //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo2",    //vccio_wl
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo3",   //
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+		.suspend_vol  =  1100000,
+	},
+	{
+		.name          = "ldo4",   //vdd11
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  1000000,
+	},
+	{
+		.name          = "ldo5",   //vcc25
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo6",   //vcc33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo7",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+		.suspend_vol  =  2800000,
+	},
+	{
+		.name          = "ldo8",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo9",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo10",   //flash_io
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+};
+
+#include "board-pmu-wm8326.c"
 #endif
+
 #ifdef CONFIG_MFD_TPS65910
+#ifdef CONFIG_ARCH_RK3066B
 #define TPS65910_HOST_IRQ        RK30_PIN0_PB3
-#include "board-rk3066b-sdk-tps65910.c"
+#else
+#define TPS65910_HOST_IRQ        RK30_PIN6_PA4
+#endif
+
+#define PMU_POWER_SLEEP RK30_PIN0_PA1
+
+static struct pmu_info  tps65910_dcdc_info[] = {
+	{
+		.name          = "vdd_cpu",   //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "vdd2",    //ddr
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+	},
+	{
+		.name          = "vio",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	
+};
+static  struct pmu_info  tps65910_ldo_info[] = {
+	{
+		.name          = "vpll",   //vcc25
+		.min_uv          = 2500000,
+		.max_uv         = 2500000,
+	},
+	{
+		.name          = "vdig1",    //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "vdig2",   //vdd11
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "vaux1",   //vcc25_hdmi
+		.min_uv          = 2500000,
+		.max_uv         = 2500000,
+	},
+	{
+		.name          = "vaux2",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vaux33",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vmmc",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+	},
+	{
+		.name          = "vdac",   //vccio_wl
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+ };
+
+#include "board-pmu-tps65910.c"
 #endif
 
 static struct i2c_board_info __initdata i2c1_info[] = {
@@ -1470,6 +1641,9 @@ void __sramfunc board_pmu_resume(void)
 
  int __sramdata gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
 
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+
 void __sramfunc rk30_pwm_logic_suspend_voltage(void)
 {
 #ifdef CONFIG_RK30_PWM_REGULATOR
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c b/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
deleted file mode 100755
index b1e4f9e58dcd..000000000000
--- a/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
+++ /dev/null
@@ -1,648 +0,0 @@
-#include <linux/regulator/machine.h>
-#include <linux/i2c/twl.h>
-#include <linux/mfd/tps65910.h>
-#include <mach/sram.h>
-#include <linux/platform_device.h>
-
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-
-#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
-#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
-
-#define CRU_CLKGATE5_CON_ADDR 0x00e4
-#define GRF_GPIO6L_DIR_ADDR 0x0030
-#define GRF_GPIO6L_DO_ADDR 0x0068
-#define GRF_GPIO6L_EN_ADDR 0x00a0
-#define GPIO6_PB3_DIR_OUT  0x08000800
-#define GPIO6_PB3_DO_LOW  0x08000000
-#define GPIO6_PB3_DO_HIGH  0x08000800
-#define GPIO6_PB3_EN_MASK  0x08000800
-#define GPIO6_PB3_UNEN_MASK  0x08000000
-#define GPIO6_PB1_DIR_OUT  0x02000200
-#define GPIO6_PB1_DO_LOW  0x02000000
-#define GPIO6_PB1_DO_HIGH  0x02000200
-#define GPIO6_PB1_EN_MASK  0x02000200
-#define GPIO6_PB1_UNEN_MASK  0x02000000
-
-#ifdef CONFIG_MFD_TPS65910
-#define PMU_POWER_SLEEP RK30_PIN0_PA1	
-extern int platform_device_register(struct platform_device *pdev);
-
-int tps65910_pre_init(struct tps65910 *tps65910){
-
-	int val = 0;
-	int i 	= 0;
-	int err = -1;
-		
-	printk("%s,line=%d\n", __func__,__LINE__);	
-	//gpio_request(PMU_POWER_SLEEP, "NULL");
-	//gpio_direction_output(PMU_POWER_SLEEP, GPIO_HIGH);
-
-	/*************set vdd11 (pll) voltage 1.0v********************/
-	val = tps65910_reg_read(tps65910, TPS65910_VDIG2);
-	if (val<0) {
-		printk(KERN_ERR "Unable to read TPS65910_VDIG2 reg\n");
-		return val;
-	}
-	val &= (~(0x3<<2));
-	err = tps65910_reg_write(tps65910, TPS65910_VDIG2, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_VDIG2 reg\n");
-		return err;
-	}
-	/****************************************/
-	
-	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL2);
-	if (val<0) {
-		printk(KERN_ERR "Unable to read TPS65910_DEVCTRL2 reg\n");
-		return val;
-	}
-	/* Set sleep state active high and allow device turn-off after PWRON long press */
-	val |= (DEVCTRL2_SLEEPSIG_POL_MASK | DEVCTRL2_PWON_LP_OFF_MASK);
-
-	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL2, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL2 reg\n");
-		return err;
-	}
-	
-	 #if 1
-	/* set PSKIP=0 */
-        val = tps65910_reg_read(tps65910, TPS65910_DCDCCTRL);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return val;
-        }
-
-	val &= ~DEVCTRL_DEV_OFF_MASK;
-	val &= ~DEVCTRL_DEV_SLP_MASK;
-        err = tps65910_reg_write(tps65910, TPS65910_DCDCCTRL, val);
-        if (err) {
-                printk(KERN_ERR "Unable to write TPS65910_DCDCCTRL reg\n");
-                return err;
-        }
-	#endif
-	/* Set the maxinum load current */
-	/* VDD1 */
-	val = tps65910_reg_read(tps65910, TPS65910_VDD1);
-	if (val<0) {
-		printk(KERN_ERR "Unable to read TPS65910_VDD1 reg\n");
-		return val;
-	}
-
-	val |= (1<<5);		//when 1: 1.5 A
-	val |= (0x07<<2);	//TSTEP[2:0] = 111 : 2.5 mV/¦Ìs(sampling 3 Mhz/5)
-	err = tps65910_reg_write(tps65910, TPS65910_VDD1, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_VDD1 reg\n");
-		return err;
-	}
-
-	/* VDD2 */
-	val = tps65910_reg_read(tps65910, TPS65910_VDD2);
-	if (val<0) {
-		printk(KERN_ERR "Unable to read TPS65910_VDD2 reg\n");
-		return val;
-	}
-
-	val |= (1<<5);		//when 1: 1.5 A
-	err = tps65910_reg_write(tps65910, TPS65910_VDD2, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_VDD2 reg\n");
-		return err;
-	}
-
-	/* VIO */
-	val = tps65910_reg_read(tps65910, TPS65910_VIO);
-	if (val<0) {
-		printk(KERN_ERR "Unable to read TPS65910_VIO reg\n");
-		return -EIO;
-	}
-
-	val |= (1<<6);	//when 01: 1.0 A
-	err = tps65910_reg_write(tps65910, TPS65910_VIO, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_VIO reg\n");
-		return err;
-	}
-	#if 1
-	/* Mask ALL interrupts */
-	err = tps65910_reg_write(tps65910,TPS65910_INT_MSK, 0xFF);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_INT_MSK reg\n");
-		return err;
-	}
-	
-	err = tps65910_reg_write(tps65910, TPS65910_INT_MSK2, 0x03);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_INT_MSK2 reg\n");
-		return err;
-	}
-
-	/* Set RTC Power, disable Smart Reflex in DEVCTRL_REG */
-	#if 1
-	val = 0;
-	val |= (DEVCTRL_SR_CTL_I2C_SEL_MASK);
-	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
-	if (err) {
-		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL reg\n");
-		return err;
-	}
-	printk(KERN_INFO "TPS65910 Set default voltage.\n");
-	#endif
-	#if 0
-	//read sleep control register  for debug
-	for(i=0; i<6; i++)
-	{
-        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
-        if (err) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return -EIO;
-        }
-		else
-		printk("%s.......is  0x%04x\n",__FUNCTION__,val);
-	}
-	#endif
-
-	#if 1
-	//sleep control register
-	/*set func when in sleep mode */
-	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return val;
-        }
-	
-	val |= (1 << 1);
-	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
-	if (err) {
-		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
-				\n", TPS65910_VDIG1);
-		return err;
-	}
-	
-	/* open ldo when in sleep mode */
-        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_LDO_ON);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return val;
-        }
-	
-	val &= 0;
-	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_LDO_ON, val);
-	if (err) {
-		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
-				\n", TPS65910_VDIG1);
-		return err;
-	}
-		
-	/*set dc mode when in sleep mode */
-        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_RES_ON);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return val;
-        }
-	
-	val  |= 0xff;
-	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_RES_ON, val);
-	if (err) {
-		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
-				\n", TPS65910_VDIG1);
-		return err;
-	}
-	
-	/*close ldo when in sleep mode */
-        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_SET_LDO_OFF);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return val;
-        }
-	
-	val |= 0x0b;
-	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_SET_LDO_OFF, val);
-	if (err) {
-		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
-				\n", TPS65910_VDIG1);
-		return err;
-	}
-	#endif
-	#if 0
-	//read sleep control register  for debug
-	for(i=0; i<6; i++)
-	{
-        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
-        if (err) {
-                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
-                return -EIO;
-        }
-		else
-		printk("%s.......is  0x%4x\n",__FUNCTION__,val);
-	}
-	#endif
-	#endif
-	printk("%s,line=%d\n", __func__,__LINE__);
-	return 0;
-
-}
-int tps65910_post_init(struct tps65910 *tps65910)
-{
-	struct regulator *dcdc;
-	struct regulator *ldo;
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-	g_pmic_type = PMIC_TYPE_TPS65910;
-	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
-
-	#ifdef CONFIG_RK30_PWM_REGULATOR
-	platform_device_register(&pwm_regulator_device[0]);
-	#endif
-	
-	dcdc = regulator_get(NULL, "vio");	//vcc_io
-	regulator_set_voltage(dcdc, 3000000, 3000000);
-	regulator_enable(dcdc);
-	printk("%s set vio vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vpll");	// vcc25
-	regulator_set_voltage(ldo, 2500000, 2500000);
-	regulator_enable(ldo);
-	printk("%s set vpll vdd11=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vdig2");	// vdd11
-	regulator_set_voltage(ldo, 1000000, 1000000);
-	regulator_enable(ldo);
-	printk("%s set vdig2 vdd11=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vaux33");	 //vcc_tp
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_enable(ldo);
-	printk("%s set vaux33 vcc_tp=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "vdd_cpu");	//vdd_cpu
-	regulator_set_voltage(dcdc, 1000000, 1000000);
-	regulator_enable(dcdc);
-	printk("%s set vdd1 vdd_cpu=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "vdd2");	//vcc_ddr 
-	regulator_set_voltage(dcdc, 1200000, 1200000);	// 1.5*4/5 = 1.2 and Vout=1.5v
-	regulator_enable(dcdc);
-	printk("%s set vdd2 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-	
-	ldo = regulator_get(NULL, "vdig1");	//vcc18_cif
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_enable(ldo);
-	printk("%s set vdig1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "vaux1"); //vcc25_hdmi
-	regulator_set_voltage(dcdc,2500000,2500000);
-	regulator_enable(dcdc); 
-	printk("%s set vaux1 vcc25_hdmi=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vaux2");	//vcca33
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_enable(ldo);
-	printk("%s set vaux2 vcca33=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vdac"); // vccio_wl
-	regulator_set_voltage(ldo,1800000,1800000);
-	regulator_enable(ldo); 
-	printk("%s set vdac vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "vmmc");  //vcc28_cif
-	regulator_set_voltage(ldo,2800000,2800000);
-	regulator_enable(ldo); 
-	printk("%s set vmmc vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-	
-	printk("%s,line=%d END\n", __func__,__LINE__);
-	
-	return 0;
-}
-
-static struct regulator_consumer_supply tps65910_smps1_supply[] = {
-	{
-		.supply = "vdd1",
-	},
-	{
-		.supply = "vdd_cpu",
-	},
-};
-static struct regulator_consumer_supply tps65910_smps2_supply[] = {
-	{
-		.supply = "vdd2",
-	},
-	
-};
-static struct regulator_consumer_supply tps65910_smps3_supply[] = {
-	{
-		.supply = "vdd3",
-	},
-};
-static struct regulator_consumer_supply tps65910_smps4_supply[] = {
-	{
-		.supply = "vio",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo1_supply[] = {
-	{
-		.supply = "vdig1",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo2_supply[] = {
-	{
-		.supply = "vdig2",
-	},
-};
-
-static struct regulator_consumer_supply tps65910_ldo3_supply[] = {
-	{
-		.supply = "vaux1",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo4_supply[] = {
-	{
-		.supply = "vaux2",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo5_supply[] = {
-	{
-		.supply = "vaux33",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo6_supply[] = {
-	{
-		.supply = "vmmc",
-	},
-};
-static struct regulator_consumer_supply tps65910_ldo7_supply[] = {
-	{
-		.supply = "vdac",
-	},
-};
-
-static struct regulator_consumer_supply tps65910_ldo8_supply[] = {
-	{
-		.supply = "vpll",
-	},
-};
-
-static struct regulator_init_data tps65910_smps1 = {
-	.constraints = {
-		.name           = "VDD1",
-		.min_uV			= 600000,
-		.max_uV			= 1500000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps1_supply),
-	.consumer_supplies =  tps65910_smps1_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_smps2 = {
-	.constraints = {
-		.name           = "VDD2",
-		.min_uV			= 600000,
-		.max_uV			= 1500000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps2_supply),
-	.consumer_supplies =  tps65910_smps2_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_smps3 = {
-	.constraints = {
-		.name           = "VDD3",
-		.min_uV			= 1000000,
-		.max_uV			= 1400000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps3_supply),
-	.consumer_supplies =  tps65910_smps3_supply,
-};
-
-static struct regulator_init_data tps65910_smps4 = {
-	.constraints = {
-		.name           = "VIO",
-		.min_uV			= 1800000,
-		.max_uV			= 3300000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps4_supply),
-	.consumer_supplies =  tps65910_smps4_supply,
-};
-static struct regulator_init_data tps65910_ldo1 = {
-	.constraints = {
-		.name           = "VDIG1",
-		.min_uV			= 1200000,
-		.max_uV			= 2700000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo1_supply),
-	.consumer_supplies =  tps65910_ldo1_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo2 = {
-	.constraints = {
-		.name           = "VDIG2",
-		.min_uV			= 1000000,
-		.max_uV			= 1800000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo2_supply),
-	.consumer_supplies =  tps65910_ldo2_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo3 = {
-	.constraints = {
-		.name           = "VAUX1",
-		.min_uV			= 1800000,
-		.max_uV			= 3300000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo3_supply),
-	.consumer_supplies =  tps65910_ldo3_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo4 = {
-	.constraints = {
-		.name           = "VAUX2",
-		.min_uV			= 1800000,
-		.max_uV			= 3300000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo4_supply),
-	.consumer_supplies =  tps65910_ldo4_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo5 = {
-	.constraints = {
-		.name           = "VAUX33",
-		.min_uV			= 1800000,
-		.max_uV			= 3300000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo5_supply),
-	.consumer_supplies =  tps65910_ldo5_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo6 = {
-	.constraints = {
-		.name           = "VMMC",
-		.min_uV			= 1800000,
-		.max_uV			= 3300000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo6_supply),
-	.consumer_supplies =  tps65910_ldo6_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo7 = {
-	.constraints = {
-		.name           = "VDAC",
-		.min_uV			= 1800000,
-		.max_uV			= 2850000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo7_supply),
-	.consumer_supplies =  tps65910_ldo7_supply,
-};
-
-/* */
-static struct regulator_init_data tps65910_ldo8 = {
-	.constraints = {
-		.name           = "VPLL",
-		.min_uV			= 1000000,
-		.max_uV			= 2500000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo8_supply),
-	.consumer_supplies =  tps65910_ldo8_supply,
-};
-
-void __sramfunc board_pmu_tps65910_suspend(void)
-{	
-#if 0 
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#endif
-}
-void __sramfunc board_pmu_tps65910_resume(void)
-{
-#if 0
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-	#ifdef CONFIG_CLK_SWITCH_TO_32K                 //switch clk to 24M
-	sram_32k_udelay(10000);
-	#else
-	sram_udelay(2000);
-	#endif
-#endif
-}
-
-static struct tps65910_board tps65910_data = {
-	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
-	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
-	.gpio_base = TPS65910_GPIO_EXPANDER_BASE,
-	
-	.pre_init = tps65910_pre_init,
-	.post_init = tps65910_post_init,
-
-	//TPS65910_NUM_REGS = 13
-	// Regulators
-	.tps65910_pmic_init_data[TPS65910_REG_VRTC] = NULL,		
-	.tps65910_pmic_init_data[TPS65910_REG_VIO] = &tps65910_smps4,
-	.tps65910_pmic_init_data[TPS65910_REG_VDD1] = &tps65910_smps1,
-	.tps65910_pmic_init_data[TPS65910_REG_VDD2] = &tps65910_smps2,
-	.tps65910_pmic_init_data[TPS65910_REG_VDD3] = &tps65910_smps3,
-	.tps65910_pmic_init_data[TPS65910_REG_VDIG1] = &tps65910_ldo1,
-	.tps65910_pmic_init_data[TPS65910_REG_VDIG2] = &tps65910_ldo2,
-	.tps65910_pmic_init_data[TPS65910_REG_VPLL] = &tps65910_ldo8,
-	.tps65910_pmic_init_data[TPS65910_REG_VDAC] = &tps65910_ldo7,
-	.tps65910_pmic_init_data[TPS65910_REG_VAUX1] = &tps65910_ldo3,
-	.tps65910_pmic_init_data[TPS65910_REG_VAUX2] = &tps65910_ldo4,
-	.tps65910_pmic_init_data[TPS65910_REG_VAUX33] = &tps65910_ldo5,
-	.tps65910_pmic_init_data[TPS65910_REG_VMMC] = &tps65910_ldo6,
-
- 
-};
-
-#endif
-
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c b/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
deleted file mode 100755
index afd3d6e56790..000000000000
--- a/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
+++ /dev/null
@@ -1,953 +0,0 @@
-#include <linux/regulator/machine.h>
-#include <linux/mfd/wm831x/pdata.h>
-#include <linux/mfd/wm831x/core.h>
-#include <linux/mfd/wm831x/gpio.h>
-#include <linux/mfd/wm831x/pmu.h>
-
-#include <mach/sram.h>
-#include <linux/earlysuspend.h>
-
-#define cru_readl(offset)	readl_relaxed(RK30_CRU_BASE + offset)
-#define cru_writel(v, offset)	do { writel_relaxed(v, RK30_CRU_BASE + offset); dsb(); } while (0)
-
-#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
-#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
-
-#define CRU_CLKGATE5_CON_ADDR 0x00e4
-#define GRF_GPIO6L_DIR_ADDR 0x0030
-#define GRF_GPIO6L_DO_ADDR 0x0068
-#define GRF_GPIO6L_EN_ADDR 0x00a0
-#define CRU_CLKGATE5_GRFCLK_ON 0x00100000
-#define CRU_CLKGATE5_GRFCLK_OFF 0x00100010
-#define GPIO6_PB1_DIR_OUT  0x02000200
-#define GPIO6_PB1_DO_LOW  0x02000000
-#define GPIO6_PB1_DO_HIGH  0x02000200
-#define GPIO6_PB1_EN_MASK  0x02000200
-#define GPIO6_PB1_UNEN_MASK  0x02000000
-
-/* wm8326 pmu*/
-#if defined(CONFIG_GPIO_WM831X)
-static struct rk29_gpio_expander_info wm831x_gpio_settinginfo[] = {
-	{
-		.gpio_num = WM831X_P01,	// tp3
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_LOW,
-	},
-	{
-		.gpio_num = WM831X_P02,	//tp4
-		.pin_type = GPIO_IN,
-	},
-	{
-		.gpio_num = WM831X_P03,	//tp2
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-	{
-		.gpio_num = WM831X_P04,	//tp1
-		.pin_type = GPIO_IN,
-	},
-	{
-		.gpio_num = WM831X_P05,	//tp1
-		.pin_type = GPIO_IN,
-	},
-	{
-		.gpio_num = WM831X_P06,	//tp1
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-	{
-		.gpio_num = WM831X_P07,	//tp1
-		.pin_type = GPIO_IN,
-	},
-	{
-		.gpio_num = WM831X_P08,	//tp1
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-	{
-		.gpio_num = WM831X_P09,	//tp1
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-	{
-		.gpio_num = WM831X_P10,	//tp1
-		.pin_type = GPIO_IN,
-	},
-	{
-		.gpio_num = WM831X_P11,	//tp1
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-	{
-		.gpio_num = WM831X_P12,
-		.pin_type = GPIO_OUT,
-		.pin_value = GPIO_HIGH,
-	},
-};
-#endif
-
-#if defined(CONFIG_MFD_WM831X)
-
-#define UNLOCK_SECURITY_KEY     ~(0x1<<5)
-#define LOCK_SECURITY_KEY       0x00
-#define PMU_POWER_SLEEP 		RK30_PIN0_PA1 
-static struct wm831x *Wm831x;
-
-static int wm831x_pre_init(struct wm831x *parm)
-{
-	int ret;
-	Wm831x = parm;
-//	printk("%s\n", __func__);
-	gpio_request(PMU_POWER_SLEEP, "NULL");
-	gpio_direction_output(PMU_POWER_SLEEP, GPIO_LOW);
-
-	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
-	#ifdef CONFIG_BATTERY_RK30_VOL3V8
-	wm831x_set_bits(parm,WM831X_SYSVDD_CONTROL ,0xc077,0xc035);	  //pvdd power on dect vbat voltage
-	printk("+++The vbat is too low+++\n");	
-	#endif
-	#endif
-	
-	ret = wm831x_reg_read(parm, WM831X_POWER_STATE) & 0xffff;
-	wm831x_reg_write(parm, WM831X_POWER_STATE, (ret & 0xfff8) | 0x04);
-
-	wm831x_set_bits(parm, WM831X_RTC_CONTROL, WM831X_RTC_ALAM_ENA_MASK, 0x0400);//enable rtc alam
-	//BATT_FET_ENA = 1
-	wm831x_reg_write(parm, WM831X_SECURITY_KEY, 0x9716);	// unlock security key
-	wm831x_set_bits(parm, WM831X_RESET_CONTROL, 0x1003, 0x1001);
-	ret = wm831x_reg_read(parm, WM831X_RESET_CONTROL) & 0xffff & UNLOCK_SECURITY_KEY;	// enternal reset active in sleep
-//	printk("%s:WM831X_RESET_CONTROL=0x%x\n", __func__, ret);
-	wm831x_reg_write(parm, WM831X_RESET_CONTROL, ret);
-
-	wm831x_set_bits(parm,WM831X_DC1_ON_CONFIG ,0x0300,0x0000); //set dcdc mode is FCCM
-	wm831x_set_bits(parm,WM831X_DC2_ON_CONFIG ,0x0300,0x0000);
-	wm831x_set_bits(parm,WM831X_DC3_ON_CONFIG ,0x0300,0x0000);
-	wm831x_set_bits(parm,0x4066,0x0300,0x0000);
-
-#ifndef CONFIG_MACH_RK3066_SDK
-	wm831x_set_bits(parm,WM831X_LDO10_CONTROL ,0x0040,0x0040);// set ldo10 in switch mode
-#endif
-	wm831x_set_bits(parm,WM831X_STATUS_LED_1 ,0xc300,0xc100);// set led1 on(in manual mode)
-	wm831x_set_bits(parm,WM831X_STATUS_LED_2 ,0xc300,0xc000);//set led2 off(in manual mode)
-
-	wm831x_set_bits(parm,WM831X_LDO5_SLEEP_CONTROL ,0xe000,0x2000);// set ldo5 is disable in sleep mode 
-	wm831x_set_bits(parm,WM831X_LDO1_SLEEP_CONTROL ,0xe000,0x2000);// set ldo1 is disable in sleep mode 
-	
-	wm831x_reg_write(parm, WM831X_SECURITY_KEY, LOCK_SECURITY_KEY);	// lock security key
-
-	return 0;
-}
-static int wm831x_mask_interrupt(struct wm831x *Wm831x)
-{
-	/**************************clear interrupt********************/
-	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_1,0xffff);
-	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_2,0xffff);
-	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_3,0xffff);
-	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_4,0xffff);
-	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_5,0xffff);
-	
-	wm831x_reg_write(Wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0xbedc); //mask interrupt which not used
-	return 0;
-	/*****************************************************************/
-}
-
-#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
-static int wm831x_low_power_detection(struct wm831x *wm831x)
-{
-	#ifdef CONFIG_BATTERY_RK30_VOL3V8
-	wm831x_reg_write(wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0xbe5c); 	
-	wm831x_set_bits(wm831x,WM831X_INTERRUPT_STATUS_1_MASK,0x8000,0x0000);	
-	wm831x_set_bits(wm831x,WM831X_SYSVDD_CONTROL ,0xc077,0x0035);		//set pvdd low voltage is 3.1v hi voltage is 3.3v 
-	#else
-	wm831x_reg_write(wm831x,WM831X_AUXADC_CONTROL,0x803f);     //open adc 
-	wm831x_reg_write(wm831x,WM831X_AUXADC_CONTROL,0xd03f);
-	wm831x_reg_write(wm831x,WM831X_AUXADC_SOURCE,0x0001);
-	
-	wm831x_reg_write(wm831x,WM831X_COMPARATOR_CONTROL,0x0001);
-	wm831x_reg_write(wm831x,WM831X_COMPARATOR_1,0x2844);   //set the low power is 3.1v
-	
-	wm831x_reg_write(wm831x,WM831X_INTERRUPT_STATUS_1_MASK,0x99ee);
-	wm831x_set_bits(wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0x0100,0x0000);
-	if (wm831x_reg_read(wm831x,WM831X_AUXADC_DATA)< 0x1844){
-		printk("The vbat is too low.\n");
-		wm831x_device_shutdown(wm831x);
-	}
-	#endif
-	return 0;	
-}
-#endif
-
-#define AVS_BASE 172
-int wm831x_post_init(struct wm831x *Wm831x)
-{
-	struct regulator *dcdc;
-	struct regulator *ldo;
-
-	
-	g_pmic_type = PMIC_TYPE_WM8326;
-	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
-	
-	ldo = regulator_get(NULL, "ldo6");	//vcc_33
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_set_suspend_voltage(ldo, 3300000);
-	regulator_enable(ldo);
-//	printk("%s set ldo6 vcc_33=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-	
-	ldo = regulator_get(NULL, "ldo4");	// vdd_11
-	regulator_set_voltage(ldo, 1000000, 1000000);
-	regulator_set_suspend_voltage(ldo, 900000);
-	regulator_enable(ldo);
-//	printk("%s set ldo4 vdd_11=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo5");	//vcc_25
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_set_suspend_voltage(ldo,1800000);
-	regulator_enable(ldo);
-//	printk("%s set ldo5 vcc_25=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-
-	dcdc = regulator_get(NULL, "dcdc4");	// vcc_io
-#ifdef CONFIG_MACH_RK3066_SDK
-	regulator_set_voltage(dcdc, 3300000, 3300000);
-	regulator_set_suspend_voltage(dcdc, 3100000);
-#else
-	regulator_set_voltage(dcdc, 3000000, 3000000);
-	regulator_set_suspend_voltage(dcdc, 2800000);
-#endif
-	regulator_enable(dcdc);
-//	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	dcdc = regulator_get(NULL, "vdd_cpu");	// vdd_arm
-	regulator_set_voltage(dcdc, 1000000, 1000000);
-	regulator_set_suspend_voltage(dcdc, 1000000);
-	regulator_enable(dcdc);
-	printk("%s set dcdc2 vdd_cpu(vdd_arm)=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	dcdc = regulator_get(NULL, "vdd_core");	// vdd_log
-	
-	/* Read avs value under logic 1.1V*/
-	/*
-	regulator_set_voltage(dcdc, 1100000, 1100000);
-	avs_init_val_get(1,1100000,"wm8326 init");
-	udelay(600);
-	avs_set_scal_val(AVS_BASE);
-	*/
-	regulator_set_voltage(dcdc, 1000000, 1000000);
-	regulator_set_suspend_voltage(dcdc, 1000000);
-	regulator_enable(dcdc);
-	printk("%s set dcdc1 vdd_core(vdd_log)=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	dcdc = regulator_get(NULL, "dcdc3");	// vcc_ddr
-	regulator_set_voltage(dcdc, 1150000, 1150000);
-	regulator_set_suspend_voltage(dcdc, 1150000);
-	regulator_enable(dcdc);
-//	printk("%s set dcdc3 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo7");	// vcc28_cif
-	regulator_set_voltage(ldo, 2800000, 2800000);
-	regulator_set_suspend_voltage(ldo, 2800000);
-	regulator_enable(ldo);
-//	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo1");	// vcc18_cif
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_set_suspend_voltage(ldo, 1800000);
-	regulator_enable(ldo);
-//	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo8");	// vcca_33
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_set_suspend_voltage(ldo, 3300000);
-	regulator_enable(ldo);
-//	printk("%s set ldo8 vcca_33=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo2");	//vccio_wl
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_set_suspend_voltage(ldo, 1800000);
-	regulator_enable(ldo);
-//	printk("%s set ldo2 vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo10");	//flash io
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_set_suspend_voltage(ldo, 1800000);
-	regulator_enable(ldo);
-//	printk("%s set ldo10 vcca_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-#ifdef CONFIG_MACH_RK3066_SDK
-	ldo = regulator_get(NULL, "ldo3");	//vdd11_hdmi
-	regulator_set_voltage(ldo, 1100000, 1100000);
-	regulator_set_suspend_voltage(ldo, 1100000);
-#else
-	ldo = regulator_get(NULL, "ldo3");	//vdd_12
-	regulator_set_voltage(ldo, 1200000, 1200000);
-	regulator_set_suspend_voltage(ldo, 1200000);
-#endif
-	regulator_enable(ldo);
-//	printk("%s set ldo3 vdd_12=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo9");	//vcc_tp
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_set_suspend_voltage(ldo, 3300000);
-	regulator_enable(ldo);
-//	printk("%s set ldo9 vcc_tp=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	wm831x_mask_interrupt(Wm831x);
-
-	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
-	wm831x_low_power_detection(Wm831x);
-	#endif
-	
-	printk("wm831x_post_init end");
-	return 0;
-}
-
-static int wm831x_last_deinit(struct wm831x *Wm831x)
-{
-	struct regulator *ldo;
-
-	printk("%s\n", __func__);
-	ldo = regulator_get(NULL, "ldo1");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo2");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo3");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo4");
-	//regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo5");
-//	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo6");
-//	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo7");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo8");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo9");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo10");
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	return 0;
-}
-
-struct wm831x_status_pdata wm831x_status_platdata[WM831X_MAX_STATUS] = {
-	{
-		.default_src = WM831X_STATUS_OTP,
-		.name = "wm831x_status0",
-		.default_trigger = "wm831x_otp",
-	},
-	{
-		.default_src = WM831X_STATUS_POWER,
-		.name = "wm831x_status1",
-		.default_trigger = "wm831x_power",
-	},
-};
-
-static struct regulator_consumer_supply dcdc1_consumers[] = {
-	{
-		.supply = "vdd_core",
-	}
-};
-
-static struct regulator_consumer_supply dcdc2_consumers[] = {
-	{
-		.supply = "vdd_cpu",
-	}
-	
-};
-
-static struct regulator_consumer_supply dcdc3_consumers[] = {
-	{
-		.supply = "dcdc3",
-	}
-};
-
-static struct regulator_consumer_supply dcdc4_consumers[] = {
-	{
-		.supply = "dcdc4",
-	}
-};
-
-#if 0
-static struct regulator_consumer_supply epe1_consumers[] = {
-	{
-		.supply = "epe1",
-	}
-};
-
-static struct regulator_consumer_supply epe2_consumers[] = {
-	{
-		.supply = "epe2",
-	}
-};
-#endif
-
-static struct regulator_consumer_supply ldo1_consumers[] = {
-	{
-		.supply = "ldo1",
-	}
-};
-
-static struct regulator_consumer_supply ldo2_consumers[] = {
-	{
-		.supply = "ldo2",
-	}
-};
-
-static struct regulator_consumer_supply ldo3_consumers[] = {
-	{
-		.supply = "ldo3",
-	}
-};
-
-static struct regulator_consumer_supply ldo4_consumers[] = {
-	{
-		.supply = "ldo4",
-	}
-};
-
-static struct regulator_consumer_supply ldo5_consumers[] = {
-	{
-		.supply = "ldo5",
-	}
-};
-
-static struct regulator_consumer_supply ldo6_consumers[] = {
-	{
-		.supply = "ldo6",
-	}
-};
-
-static struct regulator_consumer_supply ldo7_consumers[] = {
-	{
-		.supply = "ldo7",
-	}
-};
-
-static struct regulator_consumer_supply ldo8_consumers[] = {
-	{
-		.supply = "ldo8",
-	}
-};
-
-static struct regulator_consumer_supply ldo9_consumers[] = {
-	{
-		.supply = "ldo9",
-	}
-};
-
-static struct regulator_consumer_supply ldo10_consumers[] = {
-	{
-		.supply = "ldo10",
-	}
-};
-
-static struct regulator_consumer_supply ldo11_consumers[] = {
-	{
-		.supply = "ldo11",
-	}
-};
-
-struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
-	{
-		.constraints = {
-			.name = "DCDC1",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(dcdc1_consumers),
-		.consumer_supplies = dcdc1_consumers,
-	},
-	{
-		.constraints = {
-			.name = "DCDC2",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(dcdc2_consumers),
-		.consumer_supplies = dcdc2_consumers,
-	},
-	{
-		.constraints = {
-			.name = "DCDC3",
-			.min_uV = 850000,
-			.max_uV = 3400000,	//0.85-3.4V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(dcdc3_consumers),
-		.consumer_supplies = dcdc3_consumers,
-	},
-	{
-		.constraints = {
-			.name = "DCDC4",
-			.min_uV = 850000,
-			.max_uV = 3400000,	//0.85-3.4V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(dcdc4_consumers),
-		.consumer_supplies = dcdc4_consumers,
-	},
-};
-
-#if 0
-struct regulator_init_data wm831x_regulator_init_epe[WM831X_MAX_EPE] = {
-	{
-		.constraints = {
-			.name = "EPE1",
-			.min_uV = 1200000,
-			.max_uV = 3000000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(epe1_consumers),
-		.consumer_supplies = epe1_consumers,
-	},
-	{
-		.constraints = {
-			.name = "EPE2",
-			.min_uV = 1200000,
-			.max_uV = 3000000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(epe2_consumers),
-		.consumer_supplies = epe2_consumers,
-	},
-};
-#endif
-
-struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
-	{
-		.constraints = {
-			.name = "LDO1",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo1_consumers),
-		.consumer_supplies = ldo1_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO2",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo2_consumers),
-		.consumer_supplies = ldo2_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO3",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo3_consumers),
-		.consumer_supplies = ldo3_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO4",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo4_consumers),
-		.consumer_supplies = ldo4_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO5",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo5_consumers),
-		.consumer_supplies = ldo5_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO6",
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo6_consumers),
-		.consumer_supplies = ldo6_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO7",
-			.min_uV = 1000000,
-			.max_uV = 3500000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo7_consumers),
-		.consumer_supplies = ldo7_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO8",
-			.min_uV = 1000000,
-			.max_uV = 3500000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo8_consumers),
-		.consumer_supplies = ldo8_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO9",
-			.min_uV = 1000000,
-			.max_uV = 3500000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo9_consumers),
-		.consumer_supplies = ldo9_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO10",
-			.min_uV = 1000000,
-			.max_uV = 3500000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo10_consumers),
-		.consumer_supplies = ldo10_consumers,
-	},
-	{
-		.constraints = {
-			.name = "LDO11",
-			.min_uV = 800000,
-			.max_uV = 1550000,
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(ldo11_consumers),
-		.consumer_supplies = ldo11_consumers,
-	},
-};
-
-static int wm831x_init_pin_type(struct wm831x *wm831x)
-{
-	struct wm831x_pdata *pdata;
-	struct rk29_gpio_expander_info *wm831x_gpio_settinginfo;
-	uint16_t wm831x_settingpin_num;
-	int i;
-
-	if (!wm831x || !wm831x->dev)
-		goto out;
-
-	pdata = wm831x->dev->platform_data;
-	if (!pdata)
-		goto out;
-
-	wm831x_gpio_settinginfo = pdata->settinginfo;
-	if (!wm831x_gpio_settinginfo)
-		goto out;
-
-	wm831x_settingpin_num = pdata->settinginfolen;
-	for (i = 0; i < wm831x_settingpin_num; i++) {
-		if (wm831x_gpio_settinginfo[i].pin_type == GPIO_IN) {
-			wm831x_set_bits(wm831x,
-					WM831X_GPIO1_CONTROL + i,
-					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
-					1 << WM831X_GPN_DIR_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
-		if (i == 1) {
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_POL_MASK,
-						0x0400);
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_FN_MASK,
-						0x0003);				
-			}	// set gpio2 sleep/wakeup
-			
-		if (i == 9) {
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_PULL_MASK,
-						0x0000);      //disable pullup/down
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_PWR_DOM_MASK,
-						0x0800); 
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_ENA_MASK,
-						0x0000); 
-			}  //set gpio10 as adc input
-					
-		} else {
-			wm831x_set_bits(wm831x,
-					WM831X_GPIO1_CONTROL + i,
-					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
-					1 << WM831X_GPN_TRI_SHIFT);
-			if (wm831x_gpio_settinginfo[i].pin_value == GPIO_HIGH) {
-				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 1 << i);
-			} else {
-				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 0 << i);
-			}
-			if (i == 2) {
-				wm831x_set_bits(wm831x,
-						WM831X_GPIO1_CONTROL + i,
-						WM831X_GPN_PWR_DOM_MASK | WM831X_GPN_POL_MASK |WM831X_GPN_FN_MASK,
-						1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_PWR_DOM_SHIFT | 1 << 0);
-
-			}	// set gpio3 as clkout output 32.768K
-			
-		}
-	}
-
-#if 0
-	for (i = 0; i < pdata->gpio_pin_num; i++) {
-		wm831x_set_bits(wm831x,
-				WM831X_GPIO1_CONTROL + i,
-				WM831X_GPN_PULL_MASK | WM831X_GPN_POL_MASK | WM831X_GPN_OD_MASK | WM831X_GPN_TRI_MASK,
-				1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
-
-		ret = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + i);
-		printk("Gpio%d Pin Configuration = %x\n", i, ret);
-	}
-#endif
-
-out:
-	return 0;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
-{
-	struct regulator *dcdc;
-	struct regulator *ldo;
-	printk("%s\n", __func__);
-	
-	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
-	regulator_set_voltage(dcdc, 2800000, 2800000);
-	regulator_set_mode(dcdc, REGULATOR_MODE_STANDBY);
-	regulator_enable(dcdc);
-	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo1");	//
-	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-	
-	ldo = regulator_get(NULL, "ldo4");
-	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-	
-	ldo = regulator_get(NULL, "ldo6");
-	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo8");
-	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);	
-		
-}
-void wm831x_pmu_early_resume(struct regulator_dev *rdev)
-{
-	struct regulator *dcdc;
-	struct regulator *ldo;
-	printk("%s\n", __func__);
-	
-	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
-	regulator_set_voltage(dcdc, 3000000, 3000000);
-	regulator_set_mode(dcdc, REGULATOR_MODE_FAST);
-	regulator_enable(dcdc);
-	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo1");	//
-	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo4");
-	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo6");
-	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "ldo8");
-	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
-	regulator_enable(ldo);
-	regulator_put(ldo);
-	udelay(100);	
-}
-#else
-void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
-{
-}
-void wm831x_pmu_early_resume(struct regulator_dev *rdev)
-{
-}
-#endif
-
-void __sramfunc board_pmu_wm8326_suspend(void)
-{	
-#if 0
-	cru_writel(CRU_CLKGATE5_GRFCLK_ON,CRU_CLKGATE5_CON_ADDR); //open grf clk
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#endif
-}
-void __sramfunc board_pmu_wm8326_resume(void)
-{
-#if 0
-	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
-	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);     //set gpio6_b1 output high
-	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
-#ifdef CONFIG_CLK_SWITCH_TO_32K
-	sram_32k_udelay(10000);
-#else
-	sram_udelay(10000);
-#endif
-#endif
-}
-static struct wm831x_pdata wm831x_platdata = {
-
-	/** Called before subdevices are set up */
-	.pre_init = wm831x_pre_init,
-	/** Called after subdevices are set up */
-	.post_init = wm831x_post_init,
-	/** Called before subdevices are power down */
-	.last_deinit = wm831x_last_deinit,
-
-#if defined(CONFIG_GPIO_WM831X)
-	.gpio_base = WM831X_GPIO_EXPANDER_BASE,
-	.gpio_pin_num = WM831X_TOTOL_GPIO_NUM,
-	.settinginfo = wm831x_gpio_settinginfo,
-	.settinginfolen = ARRAY_SIZE(wm831x_gpio_settinginfo),
-	.pin_type_init = wm831x_init_pin_type,
-	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
-#endif
-
-	/** LED1 = 0 and so on */
-	.status = { &wm831x_status_platdata[0], &wm831x_status_platdata[1] },
-
-	/** DCDC1 = 0 and so on */
-	.dcdc = {
-		&wm831x_regulator_init_dcdc[0],
-		&wm831x_regulator_init_dcdc[1],
-		&wm831x_regulator_init_dcdc[2],
-		&wm831x_regulator_init_dcdc[3],
-	},
-
-	/** EPE1 = 0 and so on */
-	//.epe = { &wm831x_regulator_init_epe[0], &wm831x_regulator_init_epe[1] },
-
-	/** LDO1 = 0 and so on */
-	.ldo = {
-		&wm831x_regulator_init_ldo[0],
-		&wm831x_regulator_init_ldo[1],
-		&wm831x_regulator_init_ldo[2],
-		&wm831x_regulator_init_ldo[3],
-		&wm831x_regulator_init_ldo[4],
-		&wm831x_regulator_init_ldo[5],
-		&wm831x_regulator_init_ldo[6],
-		&wm831x_regulator_init_ldo[7],
-		&wm831x_regulator_init_ldo[8],
-		&wm831x_regulator_init_ldo[9],
-		&wm831x_regulator_init_ldo[10],
-	},
-};
-#endif
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk.c b/arch/arm/mach-rk30/board-rk3066b-sdk.c
index 55e1fef9ddb3..f5ccbc0b056f 100755
--- a/arch/arm/mach-rk30/board-rk3066b-sdk.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk.c
@@ -1356,7 +1356,7 @@ static struct pmu_info  wm8326_dcdc_info[] = {
 		.name          = "dcdc4",   //vcc_io
 		.min_uv          = 3300000,
 		.max_uv         = 3300000,
-		.suspend_vol  =  3000000,
+		.suspend_vol  =  3100000,
 	},
 	#else
 	{
@@ -1431,7 +1431,7 @@ static struct pmu_info  wm8326_ldo_info[] = {
 	},
 };
 
-#include "board-rk3066b-wm8326.c"
+#include "board-pmu-wm8326.c"
 #endif
 
 #ifdef CONFIG_MFD_TPS65910
@@ -1504,7 +1504,7 @@ static  struct pmu_info  tps65910_ldo_info[] = {
 	},
  };
 
-#include "board-rk3066b-tps65910.c"
+#include "board-pmu-tps65910.c"
 #endif
 
 static struct i2c_board_info __initdata i2c1_info[] = {
@@ -1553,37 +1553,39 @@ void __sramfunc board_pmu_resume(void)
 	#endif
 }
 
- int __sramdata gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+int __sramdata gpio3d6_iomux,gpio3d6_do,gpio3d6_dir,gpio3d6_en;
 
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+ 
 void __sramfunc rk30_pwm_logic_suspend_voltage(void)
 {
 #ifdef CONFIG_RK30_PWM_REGULATOR
 
 //	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
 	sram_udelay(10000);
-	gpio0d7_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
-	gpio0d7_do = grf_readl(GRF_GPIO0H_DO);
-	gpio0d7_dir = grf_readl(GRF_GPIO0H_DIR);
-	gpio0d7_en = grf_readl(GRF_GPIO0H_EN);
-
-	writel_relaxed((1<<30), GRF_GPIO0D_IOMUX);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DIR);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DO);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_EN);
+	gpio3d6_iomux = readl_relaxed(GRF_GPIO3D_IOMUX);
+	gpio3d6_do = grf_readl(GRF_GPIO3H_DO);
+	gpio3d6_dir = grf_readl(GRF_GPIO3H_DIR);
+	gpio3d6_en = grf_readl(GRF_GPIO3H_EN);
+
+	writel_relaxed((1<<28), GRF_GPIO3D_IOMUX);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_DIR);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_DO);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_EN);
 #endif 
 }
 void __sramfunc rk30_pwm_logic_resume_voltage(void)
 {
 #ifdef CONFIG_RK30_PWM_REGULATOR
-	writel_relaxed((1<<30)|gpio0d7_iomux, GRF_GPIO0D_IOMUX);
-	grf_writel((1<<31)|gpio0d7_en, GRF_GPIO0H_EN);
-	grf_writel((1<<31)|gpio0d7_dir, GRF_GPIO0H_DIR);
-	grf_writel((1<<31)|gpio0d7_do, GRF_GPIO0H_DO);
+	writel_relaxed((1<<28)|gpio3d6_iomux, GRF_GPIO3D_IOMUX);
+	grf_writel((1<<30)|gpio3d6_en, GRF_GPIO3H_EN);
+	grf_writel((1<<30)|gpio3d6_dir, GRF_GPIO3H_DIR);
+	grf_writel((1<<30)|gpio3d6_do, GRF_GPIO3H_DO);
 	sram_udelay(10000);
-
 #endif
-
 }
+
 extern void pwm_suspend_voltage(void);
 extern void pwm_resume_voltage(void);
 void  rk30_pwm_suspend_voltage_set(void)
diff --git a/arch/arm/mach-rk30/pm.c b/arch/arm/mach-rk30/pm.c
old mode 100644
new mode 100755
index cb5b18e9750f..39d39b9ab08c
--- a/arch/arm/mach-rk30/pm.c
+++ b/arch/arm/mach-rk30/pm.c
@@ -278,6 +278,8 @@ static noinline void interface_ctr_reg_pread(void)
 	readl_relaxed(RK30_DDR_PCTL_BASE);
 	readl_relaxed(RK30_DDR_PUBL_BASE);
 	readl_relaxed(RK30_I2C1_BASE+SZ_4K);
+	readl_relaxed(RK30_GPIO0_BASE);
+	readl_relaxed(RK30_GPIO6_BASE);
 }
 
 static inline bool pm_pmu_power_domain_is_on(enum pmu_power_domain pd, u32 pmu_pwrdn_st)
diff --git a/arch/arm/plat-rk/include/plat/sram.h b/arch/arm/plat-rk/include/plat/sram.h
old mode 100644
new mode 100755
index a987f729645a..034508a3661f
--- a/arch/arm/plat-rk/include/plat/sram.h
+++ b/arch/arm/plat-rk/include/plat/sram.h
@@ -14,6 +14,18 @@
 /* Tag function inside SRAM called from inside SRAM  with this */
 #define __sramlocalfunc __section(.sram.text)
 
+#define GPIO_SWPORTA_DR  0x0000
+#define GPIO_SWPORTA_DDR 0x0004
+
+struct sram_gpio_data {
+       void __iomem *base;
+       uint offset;
+};
+
+extern struct sram_gpio_data __sramdata pmic_sleep;
+int sram_gpio_init(int gpio, struct sram_gpio_data *data);
+void __sramfunc sram_gpio_set_value(struct sram_gpio_data data, uint value);
+
 int __init rk29_sram_init(void);
 
 static inline unsigned long ddr_save_sp(unsigned long new_sp)
diff --git a/arch/arm/plat-rk/sram.c b/arch/arm/plat-rk/sram.c
old mode 100644
new mode 100755
index ec667094aa54..c4a3d8e0a5c6
--- a/arch/arm/plat-rk/sram.c
+++ b/arch/arm/plat-rk/sram.c
@@ -15,7 +15,7 @@
 #include <asm/cacheflush.h>
 #include <mach/memory.h>
 #include <plat/sram.h>
-
+#include <mach/gpio.h>
 
 /* SRAM section definitions from the linker */
 extern char __sram_code_start, __ssram_code_text, __esram_code_text;
@@ -103,3 +103,40 @@ void __sramfunc sram_printhex(unsigned int hex)
 		hex <<= 4;
 	}
 }
+
+struct sram_gpio_data __sramdata pmic_sleep;
+#if defined(CONFIG_ARCH_RK2928)
+static void __iomem *gpio_base[] = {RK2928_GPIO0_BASE, RK2928_GPIO1_BASE, RK2928_GPIO2_BASE, RK2928_GPIO3_BASE};
+#else if defined(CONFIG_ARCH_RK30)
+static void __iomem *gpio_base[] = {RK30_GPIO0_BASE, RK30_GPIO1_BASE, RK30_GPIO2_BASE, RK30_GPIO3_BASE,RK30_GPIO4_BASE,RK30_GPIO6_BASE};
+#endif
+
+int sram_gpio_init(int gpio, struct sram_gpio_data *data)
+{
+       unsigned index;
+
+       if(gpio == INVALID_GPIO)
+               return -EINVAL;
+       index = gpio - PIN_BASE;
+       if(index/NUM_GROUP >= ARRAY_SIZE(gpio_base))
+               return -EINVAL;
+
+       data->base = gpio_base[index/NUM_GROUP];
+       data->offset = index%NUM_GROUP;
+
+       return 0;
+}
+
+void __sramfunc sram_gpio_set_value(struct sram_gpio_data data, uint value)
+{
+       writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DDR)| (1<<data.offset),
+                       data.base + GPIO_SWPORTA_DDR);
+       if(value)
+               writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DR) | (1<<data.offset),
+                               data.base + GPIO_SWPORTA_DR);
+       else
+               writel_relaxed(readl_relaxed(data.base + GPIO_SWPORTA_DR) & ~(1<<data.offset),
+                               data.base + GPIO_SWPORTA_DR);
+}
+
+
-- 
2.35.3

