From d96d147740944e53a098ede6bbaa2b4c85931520 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Mon, 9 Sep 2019 17:54:12 +0800
Subject: [PATCH] video: rockchip: remove unused fb driver

Change-Id: I13be9d40d44c2c3ed0bb9abf186410bf39636ec6
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/video/rockchip/bmp_helper.c           |  389 --
 drivers/video/rockchip/bmp_helper.h           |   54 -
 drivers/video/rockchip/display-sys.c          |  793 ---
 drivers/video/rockchip/lcdc/Kconfig           |   66 -
 drivers/video/rockchip/lcdc/Makefile          |   11 -
 drivers/video/rockchip/lcdc/rk2928_lcdc.c     | 1422 -----
 drivers/video/rockchip/lcdc/rk2928_lcdc.h     |  527 --
 drivers/video/rockchip/lcdc/rk3036_lcdc.c     | 1688 ------
 drivers/video/rockchip/lcdc/rk3036_lcdc.h     |  578 --
 drivers/video/rockchip/lcdc/rk3066b_lcdc.c    | 1519 -----
 drivers/video/rockchip/lcdc/rk3066b_lcdc.h    |  558 --
 drivers/video/rockchip/lcdc/rk30_lcdc.c       | 1748 ------
 drivers/video/rockchip/lcdc/rk30_lcdc.h       |  700 ---
 drivers/video/rockchip/lcdc/rk312x_lcdc.c     | 2781 ---------
 drivers/video/rockchip/lcdc/rk312x_lcdc.h     |  768 ---
 drivers/video/rockchip/lcdc/rk3188_lcdc.c     | 1666 -----
 drivers/video/rockchip/lcdc/rk3188_lcdc.h     |  413 --
 drivers/video/rockchip/lcdc/rk322x_lcdc.c     | 5334 -----------------
 drivers/video/rockchip/lcdc/rk322x_lcdc.h     | 1797 ------
 drivers/video/rockchip/lcdc/rk3288_lcdc.c     | 4238 -------------
 drivers/video/rockchip/lcdc/rk3288_lcdc.h     | 1474 -----
 drivers/video/rockchip/lcdc/rk3368_lcdc.c     | 5229 ----------------
 drivers/video/rockchip/lcdc/rk3368_lcdc.h     | 2158 -------
 drivers/video/rockchip/lcdc/rk_vop_lite.c     | 2643 --------
 drivers/video/rockchip/lcdc/rk_vop_lite.h     |  649 --
 drivers/video/rockchip/rk_fb.c                | 4723 ---------------
 drivers/video/rockchip/rkfb_sysfs.c           | 1352 -----
 drivers/video/rockchip/screen/.gitignore      |    4 -
 drivers/video/rockchip/screen/Kconfig         |   14 -
 drivers/video/rockchip/screen/Makefile        |   21 -
 drivers/video/rockchip/screen/lcd_general.c   |    9 -
 drivers/video/rockchip/screen/lcd_mipi.c      |  747 ---
 drivers/video/rockchip/screen/rk_screen.c     |  121 -
 .../screen-timing/lcd-86v-rgb1024x600.dtsi    |   30 -
 .../display/screen-timing/lcd-F402.dtsi       |  124 -
 .../display/screen-timing/lcd-LP097Qx1.dtsi   |   30 -
 .../display/screen-timing/lcd-LP097Qx2.dtsi   |  106 -
 .../screen-timing/lcd-b080xan03.0-mipi.dtsi   |   82 -
 .../display/screen-timing/lcd-b101ew05.dtsi   |   66 -
 .../display/screen-timing/lcd-box.dtsi        |   99 -
 .../screen-timing/lcd-fpga-800x480-rgb.dtsi   |  101 -
 .../lcd-h381dln01-1080x1200-double.dtsi       |  317 -
 .../lcd-h381dln01-1080x1200.dtsi              |  314 -
 .../screen-timing/lcd-h546dlb01-mipi.dtsi     |  174 -
 .../screen-timing/lcd-ld089wu1-mipi.dtsi      |  139 -
 .../screen-timing/lcd-lq070m1sx01-mipi.dtsi   |  129 -
 .../screen-timing/lcd-ls055r1sx04-mipi.dtsi   |  170 -
 .../lcd-mipi-RK055AUWI5003-1440X2560.dtsi     |  288 -
 .../lcd-rk3128-86v-LVDS1024x600.dtsi          |   34 -
 .../display/screen-timing/lcd-td043mgeal.dtsi |   30 -
 .../screen-timing/lcd-tv080wum-mipi.dtsi      |  139 -
 .../screen-timing/lcd-tv080wum-nl0-mipi.dtsi  |  179 -
 .../display/screen-timing/lcd-vga.dtsi        |   74 -
 .../display/screen-timing/lcd-wqxga-mipi.dtsi |  205 -
 .../display/screen-timing/lcd-y81349.dtsi     |   30 -
 include/linux/rk_fb.h                         |  851 ---
 include/linux/rk_screen.h                     |  155 -
 57 files changed, 50060 deletions(-)
 delete mode 100755 drivers/video/rockchip/bmp_helper.c
 delete mode 100644 drivers/video/rockchip/bmp_helper.h
 delete mode 100644 drivers/video/rockchip/display-sys.c
 delete mode 100644 drivers/video/rockchip/lcdc/Kconfig
 delete mode 100644 drivers/video/rockchip/lcdc/Makefile
 delete mode 100755 drivers/video/rockchip/lcdc/rk2928_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk2928_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk3036_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk3036_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk3066b_lcdc.c
 delete mode 100755 drivers/video/rockchip/lcdc/rk3066b_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk30_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk30_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk312x_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk312x_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk3188_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk3188_lcdc.h
 delete mode 100644 drivers/video/rockchip/lcdc/rk322x_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk322x_lcdc.h
 delete mode 100755 drivers/video/rockchip/lcdc/rk3288_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk3288_lcdc.h
 delete mode 100644 drivers/video/rockchip/lcdc/rk3368_lcdc.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk3368_lcdc.h
 delete mode 100644 drivers/video/rockchip/lcdc/rk_vop_lite.c
 delete mode 100644 drivers/video/rockchip/lcdc/rk_vop_lite.h
 delete mode 100644 drivers/video/rockchip/rk_fb.c
 delete mode 100644 drivers/video/rockchip/rkfb_sysfs.c
 delete mode 100644 drivers/video/rockchip/screen/.gitignore
 delete mode 100644 drivers/video/rockchip/screen/Kconfig
 delete mode 100644 drivers/video/rockchip/screen/Makefile
 delete mode 100644 drivers/video/rockchip/screen/lcd_general.c
 delete mode 100644 drivers/video/rockchip/screen/lcd_mipi.c
 delete mode 100644 drivers/video/rockchip/screen/rk_screen.c
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-86v-rgb1024x600.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-F402.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-LP097Qx1.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-LP097Qx2.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-b080xan03.0-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-b101ew05.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-box.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-fpga-800x480-rgb.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200-double.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-h546dlb01-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-ld089wu1-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-lq070m1sx01-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-ls055r1sx04-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-mipi-RK055AUWI5003-1440X2560.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-rk3128-86v-LVDS1024x600.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-td043mgeal.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-tv080wum-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-vga.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-wqxga-mipi.dtsi
 delete mode 100644 include/dt-bindings/display/screen-timing/lcd-y81349.dtsi
 delete mode 100755 include/linux/rk_fb.h
 delete mode 100644 include/linux/rk_screen.h

diff --git a/drivers/video/rockchip/bmp_helper.c b/drivers/video/rockchip/bmp_helper.c
deleted file mode 100755
index e8f74b7da4f4..000000000000
--- a/drivers/video/rockchip/bmp_helper.c
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * linux/drivers/video/rockchip/bmp_helper.c
- *
- * Copyright (C) 2012 Rockchip Corporation
- * Author: Mark Yao <mark.yao@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <linux/sysfs.h>
-#include <linux/uaccess.h>
-#include <linux/kernel.h>
-#include <linux/rk_fb.h>
-
-#include "bmp_helper.h"
-
-static void draw_unencoded_bitmap(uint16_t **dst, uint8_t *bmap, uint16_t *cmap,
-				  uint32_t cnt)
-{
-	while (cnt > 0) {
-		*(*dst)++ = cmap[*bmap++];
-		cnt--;
-	}
-}
-
-static void draw_encoded_bitmap(uint16_t **dst, uint16_t c, uint32_t cnt)
-{
-	uint16_t *fb = *dst;
-	int cnt_8copy = cnt >> 3;
-
-	cnt -= cnt_8copy << 3;
-	while (cnt_8copy > 0) {
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		*fb++ = c;
-		cnt_8copy--;
-	}
-	while (cnt > 0) {
-		*fb++ = c;
-		cnt--;
-	}
-	*dst = fb;
-}
-
-static void yuv_to_rgb(int y, int u, int v, int *r, int *g, int *b)
-{
-	int rdif, invgdif, bdif;
-
-	u -= 128;
-	v -= 128;
-	rdif = v + ((v * 103) >> 8);
-	invgdif = ((u * 88) >> 8) + ((v * 183) >> 8);
-	bdif = u + ((u*198) >> 8);
-	*r = range(y + rdif, 0, 0xff);
-	*g = range(y - invgdif, 0, 0xff);
-	*b = range(y + bdif, 0, 0xff);
-}
-
-int bmpencoder(void *__iomem *vaddr, int width, int height, u8 data_format,
-	       void *data, void (*fn)(void *, void *, int))
-{
-	uint32_t *d = NULL, *d1 = NULL, *d2 = NULL;
-	uint8_t *dst = NULL, *yrgb = NULL, *uv = NULL, *y1 = NULL, *y2 = NULL;
-	int y = 0, u = 0, v = 0, r = 0, g = 0, b = 0;
-
-	int yu = width * 4 % 4;
-	int byteperline;
-	unsigned int size;
-	BITMAPHEADER header;
-	BITMAPINFOHEADER infoheader;
-	void *buf;
-	int i, j;
-
-	yu = yu != 0 ? 4 - yu : yu;
-	byteperline = width * 4 + yu;
-	size = byteperline * height + 54;
-	memset(&header, 0, sizeof(header));
-	memset(&infoheader, 0, sizeof(infoheader));
-	header.type = 'M'<<8|'B';
-	header.size = size;
-	header.offset = 54;
-
-	infoheader.size = 40;
-	infoheader.width = width;
-	infoheader.height = 0 - height;
-	infoheader.bitcount = 4 * 8;
-	infoheader.compression = 0;
-	infoheader.imagesize = byteperline * height;
-	infoheader.xpelspermeter = 0;
-	infoheader.ypelspermeter = 0;
-	infoheader.colors = 0;
-	infoheader.colorsimportant = 0;
-	fn(data, (void *)&header, sizeof(header));
-	fn(data, (void *)&infoheader, sizeof(infoheader));
-
-	/*
-	 * if data_format is ARGB888 or XRGB888, not need convert.
-	 */
-	if (data_format == ARGB888 || data_format == XRGB888) {
-		fn(data, (char *)vaddr, width * height * 4);
-		return 0;
-	}
-	/*
-	 * alloc 2 line buffer.
-	 */
-	buf = kmalloc(width * 2 * 4, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-	yrgb = (uint8_t *)vaddr;
-	uv = yrgb + width * height;
-	for (j = 0; j < height; j++) {
-		if (j % 2 == 0) {
-			dst = buf;
-			y1 = yrgb + j * width;
-			y2 = y1 + width;
-			d1 = buf;
-			d2 = d1 + width;
-		}
-
-		for (i = 0; i < width; i++) {
-			switch (data_format) {
-			case XBGR888:
-			case ABGR888:
-				dst[0] = yrgb[2];
-				dst[1] = yrgb[1];
-				dst[2] = yrgb[0];
-				dst[3] = yrgb[3];
-				dst += 4;
-				yrgb += 4;
-				break;
-			case RGB888:
-				dst[0] = yrgb[0];
-				dst[1] = yrgb[1];
-				dst[2] = yrgb[2];
-				dst[3] = 0xff;
-				dst += 4;
-				yrgb += 3;
-				break;
-			case RGB565:
-				dst[0] = (yrgb[0] & 0x1f) << 3;
-				dst[1] = (yrgb[0] & 0xe0) >> 3 |
-						(yrgb[1] & 0x7) << 5;
-				dst[2] = yrgb[1] & 0xf8;
-				dst[3] = 0xff;
-				dst += 4;
-				yrgb += 2;
-				break;
-			case YUV420:
-			case YUV422:
-			case YUV444:
-				if (data_format == YUV420) {
-					if (i % 2 == 0) {
-						d = d1++;
-						y = *y1++;
-					} else {
-						d = d2++;
-						y = *y2++;
-					}
-					if (i % 4 == 0) {
-						u = *uv++;
-						v = *uv++;
-					}
-				} else if (data_format == YUV422) {
-					if (i % 2 == 0) {
-						u = *uv++;
-						v = *uv++;
-					}
-					d = d1++;
-				} else {
-					u = *uv++;
-					v = *uv++;
-					d = d1++;
-				}
-				yuv_to_rgb(y, u, v, &r, &g, &b);
-				*d = 0xff<<24 | r << 16 | g << 8 | b;
-				break;
-			case YUV422_A:
-			case YUV444_A:
-			default:
-				pr_err("unsupport now\n");
-				return -EINVAL;
-			}
-		}
-		if (j % 2 == 1)
-			fn(data, (char *)buf, 2 * width * 4);
-	}
-
-	return 0;
-}
-
-static void decode_rle8_bitmap(uint8_t *psrc, uint8_t *pdst, uint16_t *cmap,
-			       unsigned int width, unsigned int height,
-			       int bits, int x_off, int y_off, bool flip)
-{
-	uint32_t cnt, runlen;
-	int x = 0, y = 0;
-	int decode = 1;
-	uint8_t *bmap = psrc;
-	uint8_t *dst = pdst;
-	int linesize = width * 2;
-
-	if (flip) {
-		y = height - 1;
-		dst = pdst + y * linesize;
-	}
-
-	while (decode) {
-		if (bmap[0] == BMP_RLE8_ESCAPE) {
-			switch (bmap[1]) {
-			case BMP_RLE8_EOL:
-				/* end of line */
-				bmap += 2;
-				x = 0;
-				if (flip) {
-					y--;
-					dst -= linesize * 2;
-				} else {
-					y++;
-				}
-				break;
-			case BMP_RLE8_EOBMP:
-				/* end of bitmap */
-				decode = 0;
-				break;
-			case BMP_RLE8_DELTA:
-				/* delta run */
-				x += bmap[2];
-				if (flip) {
-					y -= bmap[3];
-					dst -= bmap[3] * linesize;
-					dst += bmap[2] * 2;
-				} else {
-					y += bmap[3];
-					dst += bmap[3] * linesize;
-					dst += bmap[2] * 2;
-				}
-				bmap += 4;
-				break;
-			default:
-				/* unencoded run */
-				runlen = bmap[1];
-				bmap += 2;
-				if (y >= height || x >= width) {
-					decode = 0;
-					break;
-				}
-				if (x + runlen > width)
-					cnt = width - x;
-				else
-					cnt = runlen;
-				draw_unencoded_bitmap((uint16_t **)&dst, bmap,
-						      cmap, cnt);
-				x += runlen;
-				bmap += runlen;
-				if (runlen & 1)
-					bmap++;
-			}
-		} else {
-			/* encoded run */
-			if (y < height) {
-				runlen = bmap[0];
-				if (x < width) {
-					/* aggregate the same code */
-					while (bmap[0] == 0xff &&
-					       bmap[2] != BMP_RLE8_ESCAPE &&
-					       bmap[1] == bmap[3]) {
-						runlen += bmap[2];
-						bmap += 2;
-					}
-					if (x + runlen > width)
-						cnt = width - x;
-					else
-						cnt = runlen;
-					draw_encoded_bitmap((uint16_t **)&dst,
-							    cmap[bmap[1]], cnt);
-				}
-				x += runlen;
-			}
-			bmap += 2;
-		}
-	}
-}
-
-int bmpdecoder(void *bmp_addr, void *pdst, int *width, int *height, int *bits)
-{
-	BITMAPHEADER header;
-	BITMAPINFOHEADER infoheader;
-	uint16_t *bmp_logo_palette;
-	uint32_t size;
-	uint16_t linesize;
-	int stride;
-	char *cmap_base;
-	char *src = bmp_addr;
-	char *dst = pdst;
-	int i;
-	bool flip = false;
-
-	memcpy(&header, src, sizeof(header));
-	src += sizeof(header);
-
-	if (header.type != 0x4d42) {
-		pr_err("not bmp file type[%x], can't support\n", header.type);
-		return -1;
-	}
-	memcpy(&infoheader, src, sizeof(infoheader));
-	*width = infoheader.width;
-	*height = infoheader.height;
-
-	if (*height < 0)
-		*height = 0 - *height;
-	else
-		flip = true;
-
-	size = header.size - header.offset;
-	linesize = *width * infoheader.bitcount >> 3;
-	cmap_base = src + sizeof(infoheader);
-	src = bmp_addr + header.offset;
-
-	switch (infoheader.bitcount) {
-	case 8:
-		bmp_logo_palette = kmalloc(sizeof(bmp_logo_palette) * 256, GFP_KERNEL);
-
-		/* Set color map */
-		for (i = 0; i < 256; i++) {
-			ushort colreg = ((cmap_base[2] << 8) & 0xf800) |
-					((cmap_base[1] << 3) & 0x07e0) |
-					((cmap_base[0] >> 3) & 0x001f) ;
-			cmap_base += 4;
-			bmp_logo_palette[i] = colreg;
-		}
-
-		/*
-		 * only support convert 8bit bmap file to RGB565.
-		 */
-		decode_rle8_bitmap(src, dst, bmp_logo_palette,
-				   infoheader.width, infoheader.height,
-				   infoheader.bitcount,	0, 0, flip);
-		kfree(bmp_logo_palette);
-		*bits = 16;
-		break;
-	case 16:
-		/*
-		 * Todo
-		 */
-		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
-		break;
-	case 24:
-		stride = ALIGN(*width * 3, 4);
-		if (flip)
-			src += stride * (*height - 1);
-
-		for (i = 0; i < *height; i++) {
-			memcpy(dst, src, 3 * (*width));
-			dst += stride;
-			src += stride;
-			if (flip)
-				src -= stride * 2;
-		}
-
-		*bits = 24;
-		break;
-	case 32:
-		/*
-		 * Todo
-		 */
-		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
-		break;
-	default:
-		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
-		break;
-	}
-
-	return 0;
-}
diff --git a/drivers/video/rockchip/bmp_helper.h b/drivers/video/rockchip/bmp_helper.h
deleted file mode 100644
index fd1ad43f6d71..000000000000
--- a/drivers/video/rockchip/bmp_helper.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * drivers/video/rockchip/bmp_helper.h
- *
- * Copyright (C) 2012 Rockchip Corporation
- * Author: Mark Yao <mark.yao@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _BMP_HELPER_H_
-#define _BMP_HELPER_H_
-
-typedef struct bmpheader {
-	unsigned short type;
-	unsigned int size;
-	unsigned int reserved;
-	unsigned int offset;
-}__attribute__((packed)) BITMAPHEADER;
-
-typedef struct bmpinfoheader {
-	unsigned int size;
-	unsigned int width;
-	unsigned int height;
-	unsigned short planes;
-	unsigned short bitcount;
-	unsigned int compression;
-	unsigned int imagesize;
-	unsigned int xpelspermeter;
-	unsigned int ypelspermeter;
-	unsigned int colors;
-	unsigned int colorsimportant;
-}__attribute__((packed)) BITMAPINFOHEADER;
-
-#define BMP_RLE8_ESCAPE		0
-#define BMP_RLE8_EOL		0
-#define BMP_RLE8_EOBMP		1
-#define BMP_RLE8_DELTA		2
-
-#define range(x, min, max) ((x) < (min)) ? (min) : (((x) > (max)) ? (max) : (x))
-
-int bmpencoder(void *__iomem *vaddr,int width, int height, u8 data_format,
-	       void *data, void (*fn)(void *, void *, int));
-int bmpdecoder(void *bmp_addr, void *dst, int *width, int *height, int *bits);
-#endif /* _BMP_HELPER_H_ */
diff --git a/drivers/video/rockchip/display-sys.c b/drivers/video/rockchip/display-sys.c
deleted file mode 100644
index 6c03b2795840..000000000000
--- a/drivers/video/rockchip/display-sys.c
+++ /dev/null
@@ -1,793 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/ctype.h>
-#include <linux/idr.h>
-#include <linux/err.h>
-#include <linux/kdev_t.h>
-#include <linux/display-sys.h>
-
-static struct list_head main_display_device_list;
-static struct list_head aux_display_device_list;
-
-static ssize_t name_show(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->name);
-}
-
-static DEVICE_ATTR_RO(name);
-
-static ssize_t type_show(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->type);
-}
-
-static DEVICE_ATTR_RO(type);
-
-static ssize_t property_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", dsp->property);
-}
-
-static DEVICE_ATTR_RO(property);
-
-static ssize_t enable_show(struct device *dev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int enable;
-
-	if (dsp->ops && dsp->ops->getenable)
-		enable = dsp->ops->getenable(dsp);
-	else
-		return 0;
-	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
-}
-
-static ssize_t enable_store(struct device *dev,
-			    struct device_attribute *attr,
-			    const char *buf, size_t size)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int enable;
-
-	if (kstrtoint(buf, 0, &enable))
-		return size;
-	if (dsp->ops && dsp->ops->setenable)
-		dsp->ops->setenable(dsp, enable);
-	return size;
-}
-
-static DEVICE_ATTR_RW(enable);
-
-static ssize_t connect_show(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int connect;
-
-	if (dsp->ops && dsp->ops->getstatus)
-		connect = dsp->ops->getstatus(dsp);
-	else
-		return 0;
-	return snprintf(buf, PAGE_SIZE, "%d\n", connect);
-}
-
-static DEVICE_ATTR_RO(connect);
-
-static int mode_string(char *buf, unsigned int offset,
-		       const struct fb_videomode *mode)
-{
-	char v = 'p';
-
-	if (!buf || !mode) {
-		pr_err("%s parameter error\n", __func__);
-		return 0;
-	}
-	if (mode->xres == 0 && mode->yres == 0)
-		return snprintf(&buf[offset], PAGE_SIZE - offset, "auto\n");
-	if (mode->vmode & FB_VMODE_INTERLACED)
-		v = 'i';
-	if (mode->vmode & FB_VMODE_DOUBLE)
-		v = 'd';
-	if (mode->flag)
-		return snprintf(&buf[offset], PAGE_SIZE - offset,
-				"%dx%d%c-%d(YCbCr420)\n",
-				mode->xres, mode->yres, v, mode->refresh);
-	else
-		return snprintf(&buf[offset], PAGE_SIZE - offset,
-				"%dx%d%c-%d\n",
-				mode->xres, mode->yres, v, mode->refresh);
-}
-
-static ssize_t modes_show(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	struct list_head *modelist, *pos;
-	struct display_modelist *display_modelist;
-	const struct fb_videomode *mode;
-	int i;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getmodelist) {
-		if (dsp->ops->getmodelist(dsp, &modelist)) {
-			mutex_unlock(&dsp->lock);
-			return -EINVAL;
-		}
-	} else {
-		mutex_unlock(&dsp->lock);
-		return 0;
-	}
-	i = 0;
-	if (dsp->priority == DISPLAY_PRIORITY_HDMI)
-		i += snprintf(buf, PAGE_SIZE, "auto\n");
-
-	list_for_each(pos, modelist) {
-		display_modelist = list_entry(pos,
-					      struct display_modelist,
-					      list);
-		mode = &display_modelist->mode;
-		i += mode_string(buf, i, mode);
-	}
-	mutex_unlock(&dsp->lock);
-	return i;
-}
-
-static DEVICE_ATTR_RO(modes);
-
-static ssize_t mode_show(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	struct fb_videomode mode;
-
-	if (dsp->ops && dsp->ops->getmode)
-		if (dsp->ops->getmode(dsp, &mode) == 0)
-			return mode_string(buf, 0, &mode);
-	return 0;
-}
-
-static ssize_t mode_store(struct device *dev,
-			  struct device_attribute *attr,
-			  const char *buf, size_t count)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	char mstr[100];
-	struct list_head *modelist, *pos;
-	struct display_modelist *display_modelist;
-	struct fb_videomode *mode;
-	size_t i;
-
-	mutex_lock(&dsp->lock);
-	if (!memcmp(buf, "auto", 4)) {
-		if (dsp->ops && dsp->ops->setmode)
-			dsp->ops->setmode(dsp, NULL);
-		mutex_unlock(&dsp->lock);
-		return count;
-	}
-
-	if (dsp->ops && dsp->ops->getmodelist) {
-		if (dsp->ops && dsp->ops->getmodelist) {
-			if (dsp->ops->getmodelist(dsp, &modelist)) {
-				mutex_unlock(&dsp->lock);
-				return -EINVAL;
-			}
-		}
-		list_for_each(pos, modelist) {
-			display_modelist = list_entry(pos,
-						      struct display_modelist,
-						      list);
-			mode = &display_modelist->mode;
-			i = mode_string(mstr, 0, mode);
-			if (strncmp(mstr, buf, max(count, i)) == 0) {
-				if (dsp->ops && dsp->ops->setmode)
-					dsp->ops->setmode(dsp, mode);
-				mutex_unlock(&dsp->lock);
-				return count;
-			}
-		}
-	}
-	mutex_unlock(&dsp->lock);
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RW(mode);
-
-static ssize_t scale_show(struct device *dev,
-			  struct device_attribute *attr,
-			  char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int xscale, yscale;
-
-	if (dsp->ops && dsp->ops->getscale) {
-		xscale = dsp->ops->getscale(dsp, DISPLAY_SCALE_X);
-		yscale = dsp->ops->getscale(dsp, DISPLAY_SCALE_Y);
-		if (xscale && yscale)
-			return snprintf(buf, PAGE_SIZE,
-					"xscale=%d yscale=%d\n",
-					xscale, yscale);
-	}
-	return -EINVAL;
-}
-
-static ssize_t scale_store(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int scale = 100;
-
-	if (dsp->ops && dsp->ops->setscale) {
-		if (!strncmp(buf, "xscale", 6)) {
-			if (!kstrtoint(buf, 0, &scale))
-				dsp->ops->setscale(dsp,
-						   DISPLAY_SCALE_X,
-						   scale);
-		} else if (!strncmp(buf, "yscale", 6)) {
-			if (!kstrtoint(buf, 0, &scale))
-				dsp->ops->setscale(dsp,
-						   DISPLAY_SCALE_Y,
-						   scale);
-		} else {
-			if (!kstrtoint(buf, 0, &scale)) {
-				dsp->ops->setscale(dsp,
-						   DISPLAY_SCALE_X,
-						   scale);
-				dsp->ops->setscale(dsp,
-						   DISPLAY_SCALE_Y,
-						   scale);
-			}
-		}
-		return count;
-	}
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RW(scale);
-
-static ssize_t mode3d_show(struct device *dev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	struct list_head *modelist, *pos;
-	struct display_modelist *display_modelist;
-	struct fb_videomode mode;
-	int i = 0, cur_3d_mode = -1;
-	char mode_str[128];
-	int mode_strlen, format_3d;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getmodelist) {
-		if (dsp->ops->getmodelist(dsp, &modelist)) {
-			mutex_unlock(&dsp->lock);
-			return -EINVAL;
-		}
-	} else {
-		mutex_unlock(&dsp->lock);
-		return 0;
-	}
-
-	if (dsp->ops && dsp->ops->getmode) {
-		if (dsp->ops->getmode(dsp, &mode)) {
-			mutex_unlock(&dsp->lock);
-			return -EINVAL;
-		}
-	} else {
-		mutex_unlock(&dsp->lock);
-		return 0;
-	}
-
-	list_for_each(pos, modelist) {
-		display_modelist = list_entry(pos,
-					      struct display_modelist,
-					      list);
-		if (!fb_mode_is_equal(&mode, &display_modelist->mode))
-			display_modelist = NULL;
-		else
-			break;
-	}
-	if (display_modelist)
-		i = snprintf(buf, PAGE_SIZE, "3dmodes=%d\n",
-			     display_modelist->format_3d);
-	else
-		i = snprintf(buf, PAGE_SIZE, "3dmodes=0\n");
-
-	if (dsp->ops && dsp->ops->get3dmode)
-		cur_3d_mode = dsp->ops->get3dmode(dsp);
-	i += snprintf(buf + i, PAGE_SIZE - i, "cur3dmode=%d\n", cur_3d_mode);
-
-	list_for_each(pos, modelist) {
-		display_modelist = list_entry(pos,
-					      struct display_modelist,
-					      list);
-		mode_strlen = mode_string(mode_str, 0,
-					  &display_modelist->mode);
-		mode_str[mode_strlen - 1] = 0;
-		format_3d = display_modelist->format_3d;
-		i += snprintf(buf + i, PAGE_SIZE, "%s,%d\n",
-			      mode_str, format_3d);
-	}
-	mutex_unlock(&dsp->lock);
-	return i;
-}
-
-static ssize_t mode3d_store(struct device *dev,
-			    struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int mode;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->set3dmode) {
-		if (!kstrtoint(buf, 0, &mode))
-			dsp->ops->set3dmode(dsp, mode);
-		mutex_unlock(&dsp->lock);
-		return count;
-	}
-	mutex_unlock(&dsp->lock);
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RW(mode3d);
-
-static ssize_t color_show(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int ret = 0;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getcolor)
-		ret = dsp->ops->getcolor(dsp, buf);
-	mutex_unlock(&dsp->lock);
-	return ret;
-}
-
-static ssize_t color_store(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->setcolor) {
-		if (!dsp->ops->setcolor(dsp, buf, count)) {
-			mutex_unlock(&dsp->lock);
-			return count;
-		}
-	}
-	mutex_unlock(&dsp->lock);
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RW(color);
-
-static ssize_t audioinfo_show(struct device *dev,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	char audioinfo[200];
-	int ret = 0;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getedidaudioinfo) {
-		ret = dsp->ops->getedidaudioinfo(dsp, audioinfo, 200);
-		if (!ret) {
-			mutex_unlock(&dsp->lock);
-			return snprintf(buf, PAGE_SIZE, "%s\n", audioinfo);
-		}
-	}
-	mutex_unlock(&dsp->lock);
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RO(audioinfo);
-
-static ssize_t monspecs_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	struct fb_monspecs monspecs;
-	int ret = 0;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getmonspecs) {
-		ret = dsp->ops->getmonspecs(dsp, &monspecs);
-		if (!ret) {
-			mutex_unlock(&dsp->lock);
-			memcpy(buf, &monspecs, sizeof(struct fb_monspecs));
-			return sizeof(struct fb_monspecs);
-		}
-	}
-	mutex_unlock(&dsp->lock);
-	return -EINVAL;
-}
-
-static DEVICE_ATTR_RO(monspecs);
-
-static ssize_t debug_show(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int ret = -EINVAL;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getdebug)
-		ret = dsp->ops->getdebug(dsp, buf);
-	mutex_unlock(&dsp->lock);
-	return ret;
-}
-
-static ssize_t debug_store(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	int cmd, ret = -EINVAL;
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->setdebug) {
-		if (kstrtoint(buf, 0, &cmd) == 0)
-			dsp->ops->setdebug(dsp, cmd);
-		ret = count;
-	}
-	mutex_unlock(&dsp->lock);
-	return ret;
-}
-
-static DEVICE_ATTR_RW(debug);
-
-static ssize_t prop_show(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-	int ret = -EINVAL;
-
-	mutex_lock(&dsp->lock);
-	if (dsp->ops && dsp->ops->getvrinfo)
-		ret = dsp->ops->getvrinfo(dsp, buf);
-	mutex_unlock(&dsp->lock);
-
-	return ret;
-}
-
-static DEVICE_ATTR_RO(prop);
-
-static struct attribute *display_device_attrs[] = {
-	&dev_attr_name.attr,
-	&dev_attr_type.attr,
-	&dev_attr_property.attr,
-	&dev_attr_enable.attr,
-	&dev_attr_connect.attr,
-	&dev_attr_modes.attr,
-	&dev_attr_mode.attr,
-	&dev_attr_scale.attr,
-	&dev_attr_mode3d.attr,
-	&dev_attr_color.attr,
-	&dev_attr_audioinfo.attr,
-	&dev_attr_monspecs.attr,
-	&dev_attr_debug.attr,
-	&dev_attr_prop.attr,
-	NULL,
-};
-
-ATTRIBUTE_GROUPS(display_device);
-
-static int display_suspend(struct device *dev, pm_message_t state)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	mutex_lock(&dsp->lock);
-	if (likely(dsp->driver->suspend))
-		dsp->driver->suspend(dsp, state);
-	mutex_unlock(&dsp->lock);
-	return 0;
-};
-
-static int display_resume(struct device *dev)
-{
-	struct rk_display_device *dsp = dev_get_drvdata(dev);
-
-	mutex_lock(&dsp->lock);
-	if (likely(dsp->driver->resume))
-		dsp->driver->resume(dsp);
-	mutex_unlock(&dsp->lock);
-	return 0;
-};
-
-int display_add_videomode(const struct fb_videomode *mode,
-			  struct list_head *head)
-{
-	struct list_head *pos;
-	struct display_modelist *modelist;
-	struct fb_videomode *m;
-	int found = 0;
-
-	list_for_each(pos, head) {
-		modelist = list_entry(pos, struct display_modelist, list);
-		m = &modelist->mode;
-		if (fb_mode_is_equal(m, mode)) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found) {
-		modelist = kmalloc(sizeof(*modelist),
-				   GFP_KERNEL);
-
-		if (!modelist)
-			return -ENOMEM;
-		modelist->mode = *mode;
-		list_add(&modelist->list, head);
-	}
-	return 0;
-}
-
-void rk_display_device_enable(struct rk_display_device *ddev)
-{
-	struct list_head *pos, *head;
-	struct rk_display_device *dev = NULL, *dev_enabled = NULL;
-	struct rk_display_device *dev_enable = NULL;
-	int enable = 0, connect;
-
-	if (ddev->property == DISPLAY_MAIN)
-		head = &main_display_device_list;
-	else
-		head = &aux_display_device_list;
-
-	list_for_each(pos, head) {
-		dev = list_entry(pos, struct rk_display_device, list);
-		enable = dev->ops->getenable(dev);
-		connect = dev->ops->getstatus(dev);
-		if (connect)
-			dev_enable = dev;
-		if (enable == 1)
-			dev_enabled = dev;
-	}
-	/* If no device is connected, enable highest priority device. */
-	if (!dev_enable) {
-		dev->ops->setenable(dev, 1);
-		return;
-	}
-
-	if (dev_enable == dev_enabled) {
-		if (dev_enable != ddev)
-			ddev->ops->setenable(ddev, 0);
-	} else {
-		if (dev_enabled &&
-		    dev_enabled->priority != DISPLAY_PRIORITY_HDMI)
-			dev_enabled->ops->setenable(dev_enabled, 0);
-		dev_enable->ops->setenable(dev_enable, 1);
-	}
-}
-EXPORT_SYMBOL(rk_display_device_enable);
-
-void rk_display_device_enable_other(struct rk_display_device *ddev)
-{
-#ifndef CONFIG_DISPLAY_AUTO_SWITCH
-	return;
-#else
-	struct list_head *pos, *head;
-	struct rk_display_device *dev;
-	int connect = 0;
-
-	if (ddev->property == DISPLAY_MAIN)
-		head = &main_display_device_list;
-	else
-		head = &aux_display_device_list;
-
-	list_for_each_prev(pos, head) {
-		dev = list_entry(pos, struct rk_display_device, list);
-		if (dev != ddev) {
-			connect = dev->ops->getstatus(dev);
-			if (connect) {
-				dev->ops->setenable(dev, 1);
-				return;
-			}
-		}
-	}
-#endif
-}
-EXPORT_SYMBOL(rk_display_device_enable_other);
-
-void rk_display_device_disable_other(struct rk_display_device *ddev)
-{
-#ifndef CONFIG_DISPLAY_AUTO_SWITCH
-	return;
-#else
-	struct list_head *pos, *head;
-	struct rk_display_device *dev;
-	int enable = 0;
-
-	if (ddev->property == DISPLAY_MAIN)
-		head = &main_display_device_list;
-	else
-		head = &aux_display_device_list;
-
-	list_for_each(pos, head) {
-		dev = list_entry(pos, struct rk_display_device, list);
-		if (dev != ddev) {
-			enable = dev->ops->getenable(dev);
-			if (enable)
-				dev->ops->setenable(dev, 0);
-		}
-	}
-	ddev->ops->setenable(ddev, 1);
-#endif
-}
-EXPORT_SYMBOL(rk_display_device_disable_other);
-
-void rk_display_device_select(int property, int priority)
-{
-	struct list_head *pos, *head;
-	struct rk_display_device *dev;
-	int enable, found = 0;
-
-	if (property == DISPLAY_MAIN)
-		head = &main_display_device_list;
-	else
-		head = &aux_display_device_list;
-
-	list_for_each(pos, head) {
-		dev = list_entry(pos, struct rk_display_device, list);
-		if (dev->priority == priority)
-			found = 1;
-	}
-
-	if (!found) {
-		pr_err("[%s] select display interface %d not exist\n",
-		       __func__, priority);
-		return;
-	}
-
-	list_for_each(pos, head) {
-		dev = list_entry(pos, struct rk_display_device, list);
-		enable = dev->ops->getenable(dev);
-		if (dev->priority == priority) {
-			if (!enable)
-				dev->ops->setenable(dev, 1);
-		} else if (enable) {
-			dev->ops->setenable(dev, 0);
-		}
-	}
-}
-EXPORT_SYMBOL(rk_display_device_select);
-static struct mutex allocated_dsp_lock;
-static DEFINE_IDR(allocated_dsp);
-static struct class *display_class;
-
-struct rk_display_device
-	*rk_display_device_register(struct rk_display_driver *driver,
-				    struct device *parent, void *devdata)
-{
-	struct rk_display_device *new_dev = NULL;
-	int ret = -EINVAL;
-
-	if (unlikely(!driver))
-		return ERR_PTR(ret);
-
-	new_dev = kzalloc(sizeof(*new_dev), GFP_KERNEL);
-	if (likely(new_dev) && unlikely(driver->probe(new_dev, devdata))) {
-		/* Reserve the index for this display */
-		mutex_lock(&allocated_dsp_lock);
-		new_dev->idx = idr_alloc(&allocated_dsp, new_dev,
-					 0, 0, GFP_KERNEL);
-		mutex_unlock(&allocated_dsp_lock);
-
-		if (new_dev->idx >= 0) {
-			struct list_head *pos, *head;
-			struct rk_display_device *dev;
-			int i = 0;
-
-			head = &main_display_device_list;
-			list_for_each_entry(dev, head, list) {
-				if (strcmp(dev->type, new_dev->type) == 0)
-					i++;
-			}
-			head = &aux_display_device_list;
-			list_for_each_entry(dev, head, list) {
-				if (strcmp(dev->type, new_dev->type) == 0)
-					i++;
-			}
-			if (i == 0)
-				new_dev->dev =
-				device_create(display_class, parent,
-					      MKDEV(0, 0), new_dev,
-					      "%s", new_dev->type);
-			else
-				new_dev->dev =
-				device_create(display_class, parent,
-					      MKDEV(0, 0), new_dev,
-					      "%s%d", new_dev->type, i);
-
-			if (!IS_ERR(new_dev->dev)) {
-				new_dev->parent = parent;
-				new_dev->driver = driver;
-				if (parent)
-					new_dev->dev->driver = parent->driver;
-				mutex_init(&new_dev->lock);
-				/* Add new device to display device list. */
-				if (new_dev->property == DISPLAY_MAIN)
-					head = &main_display_device_list;
-				else
-					head = &aux_display_device_list;
-
-				list_for_each(pos, head) {
-					dev =
-					list_entry(pos,
-						   struct rk_display_device,
-						   list);
-					if (dev->priority > new_dev->priority)
-						break;
-				}
-				list_add_tail(&new_dev->list, pos);
-				return new_dev;
-			}
-			mutex_lock(&allocated_dsp_lock);
-			idr_remove(&allocated_dsp, new_dev->idx);
-			mutex_unlock(&allocated_dsp_lock);
-			ret = -EINVAL;
-		}
-	}
-	kfree(new_dev);
-	return ERR_PTR(ret);
-}
-EXPORT_SYMBOL(rk_display_device_register);
-
-void rk_display_device_unregister(struct rk_display_device *ddev)
-{
-	if (!ddev)
-		return;
-	/* Free device */
-	mutex_lock(&ddev->lock);
-	device_unregister(ddev->dev);
-	mutex_unlock(&ddev->lock);
-	/* Mark device index as available */
-	mutex_lock(&allocated_dsp_lock);
-	idr_remove(&allocated_dsp, ddev->idx);
-	mutex_unlock(&allocated_dsp_lock);
-	list_del(&ddev->list);
-	kfree(ddev);
-}
-EXPORT_SYMBOL(rk_display_device_unregister);
-
-static int __init rk_display_class_init(void)
-{
-	display_class = class_create(THIS_MODULE, "display");
-	if (IS_ERR(display_class)) {
-		pr_err("Failed to create display class\n");
-		display_class = NULL;
-		return -EINVAL;
-	}
-	display_class->dev_groups = display_device_groups;
-	display_class->suspend = display_suspend;
-	display_class->resume = display_resume;
-	mutex_init(&allocated_dsp_lock);
-	INIT_LIST_HEAD(&main_display_device_list);
-	INIT_LIST_HEAD(&aux_display_device_list);
-	return 0;
-}
-
-static void __exit rk_display_class_exit(void)
-{
-	class_destroy(display_class);
-}
-
-subsys_initcall(rk_display_class_init);
-module_exit(rk_display_class_exit);
-
-MODULE_AUTHOR("zhengyang@rock-chips.com");
-MODULE_DESCRIPTION("Driver for rk display device");
-MODULE_LICENSE("GPL");
diff --git a/drivers/video/rockchip/lcdc/Kconfig b/drivers/video/rockchip/lcdc/Kconfig
deleted file mode 100644
index f57a508bcba5..000000000000
--- a/drivers/video/rockchip/lcdc/Kconfig
+++ /dev/null
@@ -1,66 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config LCDC_RK2928
-        tristate "rk2928 lcdc support"
-        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK2928
-        help
-          Driver for rk2928 lcdc .
-
-config LCDC_RK30
-        tristate "rk30 lcdc support"
-        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK30XX
-        help
-          Driver for rk30 lcdc .There are two lcd controllers on rk30
-
-config LCDC_RK3066B
-        tristate "rk3066b lcdc support"
-        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK3066B
-        help
-          Driver for rk3066b  lcdc.
-
-config LCDC_RK3188
-        bool "rk3188 lcdc support"
-        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
-	depends on ARM
-        help
-          Driver for rk3188/rk302x/rk319x lcdc.There are two lcd controllers on rk3188
-
-config LCDC_RK3288
-        bool "rk3288 lcdc support"
-        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
-	depends on ARM
-        help
-          Driver for rk3288 lcdc.There are two lcd controllers on rk3288
-
-config LCDC_RK3036
-	bool "rk3036 lcdc support"
-	depends on DRM_ROCKCHIP || FB_ROCKCHIP 
-	depends on ARM
-        help
-          Driver for rk3036 lcdc.
-
-config LCDC_RK312X
-        bool "rk312x lcdc support"
-        depends on DRM_ROCKCHIP || FB_ROCKCHIP
-	depends on ARM
-        help
-          Driver for rk312x lcdc.
-
-config LCDC_RK3368
-	bool "rk3368 lcdc support"
-	depends on DRM_ROCKCHIP || FB_ROCKCHIP
-	depends on ARM64
-	help
-	  Driver for rk3368 lcdc.There are one lcd controllers on rk3368
-
-config LCDC_RK322X
-	bool "rk322x lcdc support"
-	depends on FB_ROCKCHIP
-	help
-	  Driver for rk322x lcdc.There are one lcd controllers on rk322x
-
-config LCDC_LITE_RK3X
-	bool "rk lcdc lite support"
-	depends on FB_ROCKCHIP
-	help
-	  Driver for rk lcdc lite.There are one lcd controllers on rk3366 or
-	  on other chips in future
diff --git a/drivers/video/rockchip/lcdc/Makefile b/drivers/video/rockchip/lcdc/Makefile
deleted file mode 100644
index 1c2522c949e0..000000000000
--- a/drivers/video/rockchip/lcdc/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_LCDC_RK30) += rk30_lcdc.o
-obj-$(CONFIG_LCDC_RK2928) += rk2928_lcdc.o
-obj-$(CONFIG_LCDC_RK3066B) += rk3066b_lcdc.o
-obj-$(CONFIG_LCDC_RK3188) += rk3188_lcdc.o
-obj-$(CONFIG_LCDC_RK3288) += rk3288_lcdc.o
-obj-$(CONFIG_LCDC_RK3036) += rk3036_lcdc.o
-obj-$(CONFIG_LCDC_RK312X) += rk312x_lcdc.o
-obj-$(CONFIG_LCDC_RK3368) += rk3368_lcdc.o
-obj-$(CONFIG_LCDC_RK322X) += rk322x_lcdc.o
-obj-$(CONFIG_LCDC_LITE_RK3X) += rk_vop_lite.o
diff --git a/drivers/video/rockchip/lcdc/rk2928_lcdc.c b/drivers/video/rockchip/lcdc/rk2928_lcdc.c
deleted file mode 100755
index 561fa6866a3a..000000000000
--- a/drivers/video/rockchip/lcdc/rk2928_lcdc.c
+++ /dev/null
@@ -1,1422 +0,0 @@
-/*
- * drivers/video/rockchip/chips/rk2928_lcdc.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *Author:yzq<yzq@rock-chips.com>
- *	yxj<yxj@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/earlysuspend.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include "rk2928_lcdc.h"
-#include "../transmitter/rk2928_lvds.h"
-
-
-
-
-
-static int dbg_thresd = 0;
-module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
-#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
-
-
-
-//rk2928 lcdc iomux,mode:0,gpio,1 lcdc io
-static int rk2928_lcdc_iomux(rk_screen *screen,int mode)
-{
-	int ret = 0;
-	int i=0;
-	if((screen->type == SCREEN_RGB)&&(mode)) //iomux for RGB screen
-	{
-		for(i=0;i<8;i++)
-		{
-			gpio_free(RK2928_PIN2_PB0 + i); 
-		}
-		for(i=0;i<4;i++)
-		{
-			gpio_free(RK2928_PIN2_PC0 + i);
-		}
-
-		if(screen->lcdc_id == 0)
-		{
-			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC0_DCLK);
-			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC0_HSYNC);
-			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC0_VSYNC);
-			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC0_DEN);
-			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC0_D10);
-			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC0_D11);
-			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC0_D12);
-			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC0_D13);
-			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC0_D14);
-			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC0_D15);
-			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC0_D16);
-			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC0_D17);
-		}
-		else if(screen->lcdc_id == 1)
-		{
-			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC1_DCLK);
-			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC1_HSYNC);
-			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC1_VSYNC);
-			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC1_DEN);
-			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC1_D10);
-			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC1_D11);
-			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC1_D12);
-			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC1_D13);
-			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC1_D14);
-			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC1_D15);
-			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC1_D16);
-			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC1_D17);
-		}
-		else
-		{
-			printk(KERN_WARNING "%s>>>no such interface:%d\n",__func__,screen->lcdc_id);
-			return -1;
-		}	
-	}
-	else if((screen->type == SCREEN_RGB)&&(!mode))
-	{
-		rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_GPIO2B0 );
-		rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME,GPIO2B_GPIO2B1);
-		rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, 	GPIO2B_GPIO2B2);
-		rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_GPIO2B3);
-		rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_GPIO2B4 );
-		rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_GPIO2B5 );
-		rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_GPIO2B6 );
-		rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_GPIO2B7 );
-		rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_GPIO2C0);
-		rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_GPIO2C1);
-		rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_GPIO2C2);
-		rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_GPIO2C3);
-		for(i=0;i<8;i++)
-		{
-			ret += gpio_request(RK2928_PIN2_PB0 + i, NULL);
-			gpio_direction_output(RK2928_PIN2_PB0 + i, 0); 
-		}
-		for(i=0;i<4;i++)
-		{
-			ret += gpio_request(RK2928_PIN2_PC0 + i, NULL);
-			gpio_direction_output(RK2928_PIN2_PC0 + i, 0); 
-		}
-		if(ret < 0)
-		{
-			printk("%s:some gpio request fail\n",__func__);
-		}
-	}
-	return 0;
-}
-static int init_rk2928_lcdc(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	if(lcdc_dev->id == 0) //lcdc0
-	{
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
-		lcdc_dev->sclk = clk_get(NULL,"sclk_lcdc0");
-	}
-	else
-	{
-		printk(KERN_ERR "invalid lcdc device!\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(lcdc_dev->sclk) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
-    	{
-       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
-   	}
-
-	clk_enable(lcdc_dev->pd);
-	clk_enable(lcdc_dev->hclk);  //enable aclk and hclk for register config
-	clk_enable(lcdc_dev->aclk);  
-	lcdc_dev->clk_on = 1;
-	LcdSetBit(lcdc_dev,SYS_CFG, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
-	LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
-              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
-              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
-	//LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-	return 0;
-}
-
-static int rk2928_lcdc_deinit(struct rk2928_lcdc_device *lcdc_dev)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		LcdMskReg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
-			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
-			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
-		LcdSetBit(lcdc_dev,SYS_CFG,m_LCDC_STANDBY);
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	mdelay(1);
-	
-	return 0;
-}
-
-static int rk2928_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	rk_screen *screen = dev_drv->cur_screen;
-	rk_screen *screen0 = dev_drv->screen0;
-	u64 ft;
-	int fps;
-	u16 face;
-	u16 right_margin = screen->right_margin;
-	u16 lower_margin = screen->lower_margin;
-	u16 x_res = screen->x_res, y_res = screen->y_res;
-	DBG(1,"left_margin:%d>>hsync_len:%d>>xres:%d>>right_margin:%d>>upper_margin:%d>>vsync_len:%d>>yres:%d>>lower_margin:%d\n",
-		screen->left_margin,screen->hsync_len,screen->x_res,screen->right_margin,screen->upper_margin,screen->vsync_len,screen->y_res,
-		screen->lower_margin);
-	// set the rgb or mcu
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(screen->type==SCREEN_MCU)
-		{
-	    		printk(KERN_ERR "MCU Screen is not supported by RK2928\n");
-	
-		}
-
-		switch (screen->face)
-		{
-	        	case OUT_P565:
-	            		face = OUT_P565;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_P666:
-	            		face = OUT_P666;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_D888_P565:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_D888_P666:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_P888:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	default:
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		face = screen->face;
-	            		break;
-		}
-
-		//use default overlay,set vsyn hsync den dclk polarity
-		LcdMskReg(lcdc_dev, DSP_CTRL,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
-	     		m_DEN_POLARITY |m_DCLK_POLARITY | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_BLACK_MODE,
-	     		v_DISPLAY_FORMAT(face) | v_HSYNC_POLARITY(screen->pin_hsync) | 
-	     		v_VSYNC_POLARITY(screen->pin_vsync) | v_DEN_POLARITY(screen->pin_den) |
-	     		v_DCLK_POLARITY(screen->pin_dclk) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
-		 	v_OUTPUT_RG_SWAP(screen->swap_rg) |v_BLACK_MODE(0));
-
-		//set background color to black,set swap according to the screen panel,disable blank mode
-		LcdMskReg(lcdc_dev, BG_COLOR, m_BG_COLOR ,v_BG_COLOR(0x000000));
-
-		
-		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
-	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
-		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
-	             v_HASP(screen->hsync_len + screen->left_margin));
-
-		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
-	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
-		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
-	              v_VASP(screen->vsync_len + screen->upper_margin));
-
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	 if(dev_drv->screen0->lcdc_id == 1)
-	 {
-		//set register for scaller
-		LcdMskReg(lcdc_dev,SCL_REG0,m_SCL_DSP_ZERO | m_SCL_DEN_INVERT |
-			m_SCL_SYNC_INVERT | m_SCL_DCLK_INVERT | m_SCL_EN,v_SCL_DSP_ZERO(0) |
-			v_SCL_DEN_INVERT(screen0->s_den_inv) | v_SCL_SYNC_INVERT(screen0->s_hv_sync_inv) |
-			v_SCL_DCLK_INVERT(screen0->s_clk_inv) | v_SCL_EN(1));
-		LcdWrReg(lcdc_dev,SCL_REG2,v_HASP(screen0->s_vsync_st) | v_HAEP(screen0->s_hsync_st));
-		LcdWrReg(lcdc_dev,SCL_REG3,v_HASP(screen0->s_hsync_len) |
-			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + 
-			 screen0->x_res + screen0->s_right_margin));
-		LcdWrReg(lcdc_dev,SCL_REG4,v_HASP(screen0->s_hsync_len + screen0->s_left_margin) |
-			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + screen0->x_res));
-		LcdWrReg(lcdc_dev,SCL_REG5,v_VASP(screen0->s_vsync_len) |
-			 v_VAEP(screen0->s_vsync_len + screen0->s_upper_margin +
-			 screen0->y_res + screen0->s_lower_margin));
-		LcdWrReg(lcdc_dev,SCL_REG6,v_VASP(screen0->s_vsync_len + 
-			 screen0->s_upper_margin) | v_VAEP(screen0->s_vsync_len +
-			 screen0->s_upper_margin + screen0->y_res ));
-		LcdWrReg(lcdc_dev,SCL_REG8,v_VASP(screen0->s_vsync_len + screen0->s_upper_margin) |
-			 v_VAEP(screen0->s_vsync_len + screen0->s_upper_margin + screen0->y_res));
-		LcdWrReg(lcdc_dev,SCL_REG7,v_HASP(screen0->s_hsync_len + screen0->s_left_margin) |
-			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + screen0->x_res ));
-		LcdWrReg(lcdc_dev,SCL_REG1,v_SCL_V_FACTOR(0x1000)|v_SCL_H_FACTOR(0x1000));
-	 }
-#endif
-		// let above to take effect
-		//LCDC_REG_CFG_DONE();
-	}
- 	spin_unlock(&lcdc_dev->reg_lock);
-
-#ifdef CONFIG_RK2928_LVDS
-	rk_lvds_register(dev_drv->screen0);
-#endif
-	if(dev_drv->screen0->type == SCREEN_RGB) //iomux for RGB screen
-	{
-
-		if(dev_drv->screen0->lcdc_id == 0)
-		{
-			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC0_DCLK);
-			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC0_HSYNC);
-			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC0_VSYNC);
-			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC0_DEN);
-			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC0_D10);
-			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC0_D11);
-			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC0_D12);
-			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC0_D13);
-			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC0_D14);
-			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC0_D15);
-			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC0_D16);
-			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC0_D17);
-		}
-		else if(dev_drv->screen0->lcdc_id == 1)
-		{
-			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC1_DCLK);
-			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC1_HSYNC);
-			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC1_VSYNC);
-			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC1_DEN);
-			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC1_D10);
-			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC1_D11);
-			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC1_D12);
-			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC1_D13);
-			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC1_D14);
-			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC1_D15);
-			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC1_D16);
-			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC1_D17);
-		}
-		else
-		{
-			printk(KERN_WARNING "%s>>>no such interface:%d\n",__func__,dev_drv->cur_screen->lcdc_id);
-			return -1;
-		}
-		
-		//rk30_mux_api_set(GPIO2C4_LCDC0_D18_LCDC1_D18_I2C2_SDA_NAME, GPIO2C_LCDC1_D18);
-		//rk30_mux_api_set(GPIO2C5_LCDC0_D19_LCDC1_D19_I2C2_SCL_NAME, GPIO2C_LCDC1_D19);
-		//rk30_mux_api_set(GPIO2C6_LCDC0_D20_LCDC1_D20_UART2_SIN_NAME, GPIO2C_LCDC1_D20);
-		//rk30_mux_api_set(GPIO2C7_LCDC0_D21_LCDC1_D21_UART2_SOUT_NAME, GPIO2C_LCDC1_D21);
-		//rk30_mux_api_set(GPIO2D0_LCDC0_D22_LCDC1_D22_NAME, GPIO2D_LCDC1_D22);
-		//rk30_mux_api_set(GPIO2D1_LCDC0_D23_LCDC1_D23_NAME, GPIO2D_LCDC1_D23);
-		printk("RGB screen connect to rk2928 lcdc interface%d\n",dev_drv->screen0->lcdc_id);
-
-	}
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-	if(ret)
-	{
-        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-	}
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	clk_enable(lcdc_dev->dclk);
-#if  defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-
-	if(dev_drv->screen0->lcdc_id == 1)  //if connect to output interface 1,need scale
-	{
-		ret = clk_set_rate(lcdc_dev->sclk, screen0->s_pixclock);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d sclk failed\n",lcdc_dev->id);
-		}
-		//lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->sclk));
-		//printk("%s: sclk:%lu>>need:%d",lcdc_dev->driver.name,,screen0->s_pixclock);
-		clk_enable(lcdc_dev->sclk);
-	}
-#endif
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-		(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps;
-    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk), 
-		fps);
-
-    	if(screen->init)
-    	{
-    		screen->init();
-    	}
-	
-	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
-	return 0;
-}
-
-
-//enable layer,open:1,enable;0 disable
-static int win0_open(struct rk2928_lcdc_device *lcdc_dev,bool open)
-{
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				LcdClrBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[0]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_EN, v_W0_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			LcdSetBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
-		}
-		//LCDC_REG_CFG_DONE();	
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-static int win1_open(struct rk2928_lcdc_device *lcdc_dev,bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
-				LcdClrBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CFG, m_W1_EN, v_W1_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
-			LcdSetBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
-		}
-		//LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-
-
-static int rk2928_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
-{
-	struct rk2928_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk2928_lcdc_device ,driver);
-
-	printk(KERN_INFO "%s>>>>>%d\n",__func__, blank_mode);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch(blank_mode)
-	    	{
-	    		case FB_BLANK_UNBLANK:
-	      			LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(0));
-				break;
-	    		case FB_BLANK_NORMAL:
-	         		LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-	    		default:
-				LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-		}
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-    	return 0;
-}
-
-static  int win0_display(struct rk2928_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_YRGB_MST,y_addr);
-	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST,uv_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-	
-}
-
-static  int win1_display(struct rk2928_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN1_RGB_MST, y_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static  int win0_set_par(struct rk2928_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg = 0;
-	
-	xact = par->xact;			    //active (origin) picture window width/height		
-	yact = par->yact;
-	xvir = par->xvir;			   // virtual resolution		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-
-	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
-	ScaleYrgbY = CalScale(yact, par->ysize);
-
-	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-	switch (par->format)
-	{
-		case XBGR888:
-		case ABGR888:
-		case ARGB888:
-			fmt_cfg = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			break;
-		case YUV422:// yuv422
-			fmt_cfg = 5;
-			ScaleCbrX = CalScale((xact/2), par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		case YUV420: // yuv420
-			fmt_cfg = 4;
-			ScaleCbrX = CalScale(xact/2, par->xsize);
-		   	ScaleCbrY = CalScale(yact/2, par->ysize);
-		   	break;
-		case YUV444:// yuv444
-			fmt_cfg = 6;
-			ScaleCbrX = CalScale(xact, par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		default:
-			printk("%s:un supported format\n",__func__);
-		   	break;
-	}
-
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
-		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
-		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
-		LcdMskReg(lcdc_dev,WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
-			v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format) 
-		{
-			case XBGR888:
-				LcdMskReg(lcdc_dev, WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-			case ARGB888:
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-			case ABGR888:
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-			case RGB888:  //rgb888
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_RGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			case RGB565:  //rgb565
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_RGB565_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,DSP_CTRL,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			case YUV422:
-			case YUV420:   
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_YUV_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			default:
-				printk("%s:un supported format\n",__func__);
-				break;
-		}
-		
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-    return 0;
-
-}
-
-static int win1_set_par(struct rk2928_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg = 0;
-	
-	xact = par->xact;			
-	yact = par->yact;
-	xvir = par->xvir;		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-	
-	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
-		// enable win1 color key and set the color to black(rgb=0)
-		LcdMskReg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-
-		
-		switch(par->format)
-	       {	
-			case XBGR888:
-                		fmt_cfg = 0;
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-			case ABGR888:
-                		fmt_cfg = 0;
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-			case ARGB888:
-                		fmt_cfg = 0;
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-			case RGB888:  //rgb888
-                		fmt_cfg = 1;
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_RGB888_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,DSP_CTRL,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-			case RGB565:  //rgb565
-                		fmt_cfg = 2;
-				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_RGB565_VIRWIDTH(xvir));
-				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-			default:
-				printk("%s:un supported format\n",__func__);
-				break;
-	       }
-		
-	    	LcdMskReg(lcdc_dev,SYS_CFG, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
-		//LCDC_REG_CFG_DONE(); 
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-    return 0;
-}
-
-static int rk2928_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-
-	if(open)
-	{
-		rk2928_load_screen(dev_drv,1);
-	}
-	if(layer_id == 0)
-	{
-		win0_open(lcdc_dev,open);	
-	}
-	else if(layer_id == 1)
-	{
-		win1_open(lcdc_dev,open);
-	}
-
-	return 0;
-}
-
-static int rk2928_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	rk_screen *screen0 = dev_drv->screen0;
-	u32 Scl_X = 0x1000;
-	u32 Scl_Y = 0x1000;
-	
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_set_par(lcdc_dev,screen,par);
-	}
-	Scl_X = CalScale(screen->x_res - 1,screen0->x_res - 1);
-	if((screen->y_res-1)/(screen0->x_res -1) < 2)
-	{
-
-		Scl_Y = CalScale(screen->y_res - 1 ,screen0->y_res - 1);
-	}
-	else
-	{	
-		Scl_Y = CalScale(screen->y_res - 2 ,screen0->y_res - 1);
-	}
-	LcdWrReg(lcdc_dev,SCL_REG1,v_SCL_V_FACTOR(Scl_Y)|v_SCL_H_FACTOR(Scl_X));
-	
-	return 0;
-}
-
-int rk2928_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	unsigned long flags;
-	int timeout;
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;	
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_display(lcdc_dev,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_display(lcdc_dev,par);
-	}
-	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
-	{
-		dev_drv->first_frame = 0;
-		LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
-			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
-		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-		 
-	}
-
-	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
-	{
-		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
-		if(!timeout&&(!dev_drv->frame_done.done))
-		{
-			//printk(KERN_ERR "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	
-	return 0;
-}
-
-int rk2928_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	int ret = 0;
-	switch(cmd)
-	{
-		case RK_FBIOGET_PANEL_SIZE:    //get panel size
-                	panel_size[0] = dev_drv->screen0->x_res;
-                	panel_size[1] = dev_drv->screen0->y_res;
-            		if(copy_to_user(argp, panel_size, 8)) 
-				return -EFAULT;
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-static int rk2928_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	struct layer_par *par = dev_drv->layer_par[layer_id];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(layer_id == 0)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W0_EN);
-		}
-		else if( layer_id == 1)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W1_EN);
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return par->state;
-	
-}
-
-/***********************************
-overlay manager
-swap:1 win0 on the top of win1
-        0 win1 on the top of win0
-set  : 1 set overlay 
-        0 get overlay state
-************************************/
-static int rk2928_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(set)  //set overlay
-		{
-			LcdMskReg(lcdc_dev,DSP_CTRL,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
-			LCDC_REG_CFG_DONE();
-			ovl = swap;
-		}
-		else  //get overlay
-		{
-			ovl = LcdReadBit(lcdc_dev,DSP_CTRL,m_W0W1_POSITION_SWAP);
-		}
-	}
-	else
-	{
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static ssize_t dump_win0_disp_info(struct rk2928_lcdc_device *lcdc_dev,char *buf)
-{
-        char format[9] = "NULL";
-        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
-        u32 xvir,act_info,dsp_info,dsp_st,factor;
-        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
-        u16 x_scale,y_scale;
-        switch((fmt_id&m_W0_FORMAT)>>3)
-        {
-                case 0:
-                        strcpy(format,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format,"RGB888");
-                        break;
-                case 2:
-                        strcpy(format,"RGB565");
-                        break;
-                case 4:
-                        strcpy(format,"YCbCr422");
-                        break;
-                case 5:
-                        strcpy(format,"YCbCr420");
-                        break;
-                case 6:
-                        strcpy(format,"YCbCr444");
-                        break;
-                default:
-                        strcpy(format,"inval\n");
-                        break;
-        }
-
-        xvir = LcdRdReg(lcdc_dev,WIN_VIR)&0xffff;
-        act_info = LcdRdReg(lcdc_dev,WIN0_ACT_INFO);
-        dsp_info = LcdRdReg(lcdc_dev,WIN0_DSP_INFO);
-        dsp_st = LcdRdReg(lcdc_dev,WIN0_DSP_ST);
-        factor = LcdRdReg(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
-        x_act =  (act_info&0xffff) + 1;
-        y_act = (act_info>>16) + 1;
-        x_dsp = (dsp_info&0xffff) + 1;
-        y_dsp = (dsp_info>>16) + 1;
-	x_factor = factor&0xffff;
-        y_factor = factor>>16;
-        x_scale = 4096*100/x_factor;
-        y_scale = 4096*100/y_factor;
-        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxact:%d\nyact:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nx_scale:%d.%d\ny_scale:%d.%d\nformat:%s\n",
-                xvir,x_act,y_act,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,x_scale/100,x_scale%100,y_scale/100,y_scale%100,format);
-
-}
-
-static ssize_t dump_win1_disp_info(struct rk2928_lcdc_device *lcdc_dev,char *buf)
-{
-        char format[9] = "NULL";
-        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
-        u32 xvir,act_info,dsp_info,dsp_st,factor;
-        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
-        u16 x_scale,y_scale;
-        switch((fmt_id&m_W1_FORMAT)>>6)
-        {
-                case 0:
-                        strcpy(format,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format,"RGB888");
-                        break;
-                case 2:
-                        strcpy(format,"RGB565");
-                        break;
-                default:
-                        strcpy(format,"inval\n");
-                        break;
-        }
-
-        xvir = (LcdRdReg(lcdc_dev,WIN_VIR)>>16)&0xfff;
-        dsp_info = LcdRdReg(lcdc_dev,WIN1_DSP_INFO);
-        dsp_st = LcdRdReg(lcdc_dev,WIN1_DSP_ST);
-
-        x_dsp = dsp_info&0xffff;
-        y_dsp = dsp_info>>16;
-
-        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nformat:%s\n",
-                xvir,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,format);
-}
-
-static ssize_t  rk2928_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
-{
-        struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-        if(layer_id == 0)
-        {
-                return dump_win0_disp_info(lcdc_dev,buf);
-        }
-        else if(layer_id == 1)
-        {
-                return dump_win1_disp_info(lcdc_dev,buf);
-        }
-       
-        return 0;
-}
-
-
-
-/*******************************************
-lcdc fps manager,set or get lcdc fps
-set:0 get
-     1 set
-********************************************/
-static int rk2928_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-	rk_screen * screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-
-	if(set)
-	{
-		ft = div_u64(1000000000000llu,fps);
-		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
-		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-		}
-	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-			
-	}
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-	(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps ;  //one frame time in ms
-	return fps;
-}
-
-
-static int rk2928_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
-        enum fb_win_map_order order)
-{
-        mutex_lock(&dev_drv->fb_win_id_mutex);
-	if(order == FB_DEFAULT_ORDER)
-	{
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-	}
-        dev_drv->fb2_win_id  = order/100;
-        dev_drv->fb1_win_id = (order/10)%10;
-        dev_drv->fb0_win_id = order%10;
-        mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-        printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
-                dev_drv->fb2_win_id);
-
-        return 0;
-}
-
-static int rk2928_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
-{
-        int layer_id = 0;
-        mutex_lock(&dev_drv->fb_win_id_mutex);
-        if(!strcmp(id,"fb0"))
-        {
-                layer_id = dev_drv->fb0_win_id;
-        }
-        else if(!strcmp(id,"fb1"))
-        {
-                layer_id = dev_drv->fb1_win_id;
-        }
-        else if(!strcmp(id,"fb2"))
-        {
-                layer_id = dev_drv->fb2_win_id;
-        }
-        else
-        {
-                printk(KERN_ERR "%s>>un supported %s\n",__func__,id);
-                layer_id = -1;
-        }
-        mutex_unlock(&dev_drv->fb_win_id_mutex);
-	//printk("%s %s win%d\n",__func__,id,layer_id);
-        return  layer_id;
-}
-
-static int rk2928_lcdc_hdmi_process(struct rk_lcdc_device_driver *dev_drv,int mode)
-{
-#if !defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	printk("%s>>>>>>>>mode:%d\n",__func__,mode);
-	if(mode)
-	{
-		rk2928_lcdc_iomux(dev_drv->screen0,0); //switch to gpio mode,to avoid  current leakage
-		if(dev_drv->screen_ctr_info->io_disable)
-			dev_drv->screen_ctr_info->io_disable();
-	}
-	else
-	{
-		rk2928_lcdc_iomux(dev_drv->screen0,1); //switch to gpio mode,to avoid  current leakage
-		if(dev_drv->screen_ctr_info->io_enable)
-			dev_drv->screen_ctr_info->io_enable();
-	}
-#endif
-	
-	return 0;
-	
-}
-int rk2928_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(1);
-	if(dev_drv->screen_ctr_info->io_disable)
-		dev_drv->screen_ctr_info->io_disable();
-	
-	if(dev_drv->cur_screen->sscreen_set)
-		dev_drv->cur_screen->sscreen_set(dev_drv->cur_screen , 0);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		LcdSetBit(lcdc_dev,DSP_CTRL,m_BLACK_MODE);
-		LcdMskReg(lcdc_dev, SYS_CFG,m_DSP_OUT_ZERO | m_LCDC_STANDBY,
-			v_DSP_OUT_ZERO(1) | v_LCDC_STANDBY(1));
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else  //clk already disabled
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	
-		
-	mdelay(10);
- 	rk2928_lcdc_iomux(dev_drv->screen0,0); //switch to gpio mode,to avoid  current leakage
-	clk_disable(lcdc_dev->dclk);
-	clk_disable(lcdc_dev->hclk);
-	clk_disable(lcdc_dev->aclk);
-	clk_disable(lcdc_dev->pd);
-
-	return 0;
-}
-
-
-
-int rk2928_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
-{  
-	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
-
-	if(dev_drv->screen_ctr_info->io_enable) 		//power on
-		dev_drv->screen_ctr_info->io_enable();
-	
-	if(!lcdc_dev->clk_on)
-	{
-		clk_enable(lcdc_dev->pd);
-		clk_enable(lcdc_dev->hclk);
-		clk_enable(lcdc_dev->dclk);
-		clk_enable(lcdc_dev->aclk);
-	}
-	rk2928_lcdc_iomux(dev_drv->screen0,1); //switch to lcdc io
-	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0xc4);  //resume reg
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->atv_layer_cnt)
-	{
-		LcdMskReg(lcdc_dev, SYS_CFG,m_DSP_OUT_ZERO | m_LCDC_STANDBY,
-			v_DSP_OUT_ZERO(0) | v_LCDC_STANDBY(0));
-		LcdClrBit(lcdc_dev,DSP_CTRL,m_BLACK_MODE);
-		LCDC_REG_CFG_DONE();
-	}
-	lcdc_dev->clk_on = 1;
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	
-	if(dev_drv->cur_screen->sscreen_set)
-		dev_drv->cur_screen->sscreen_set(dev_drv->cur_screen , 1);
-
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(0);	      //screen wake up
-	
-
-    	return 0;
-}
-static irqreturn_t rk2928_lcdc_isr(int irq, void *dev_id)
-{
-	struct rk2928_lcdc_device *lcdc_dev = (struct rk2928_lcdc_device *)dev_id;
-
-	ktime_t timestamp = ktime_get();
-	
-	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-	//LCDC_REG_CFG_DONE();
-	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
- 
-	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
-	{
-		spin_lock(&(lcdc_dev->driver.cpl_lock));
-		complete(&(lcdc_dev->driver.frame_done));
-		spin_unlock(&(lcdc_dev->driver.cpl_lock));
-	}
-	
-	lcdc_dev->driver.vsync_info.timestamp = timestamp;
-	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-	return IRQ_HANDLED;
-}
-
-static struct layer_par lcdc_layer[] = {
-	[0] = {
-		.name  		= "win0",
-		.id		= 0,
-		.support_3d	= true,
-	},
-	[1] = {
-		.name  		= "win1",
-		.id		= 1,
-		.support_3d	= false,
-	},
-};
-
-static struct rk_lcdc_device_driver lcdc_driver = {
-	.name			= "lcdc",
-	.def_layer_par		= lcdc_layer,
-	.num_layer		= ARRAY_SIZE(lcdc_layer),
-	.open			= rk2928_lcdc_open,
-	.init_lcdc		= init_rk2928_lcdc,
-	.ioctl			= rk2928_lcdc_ioctl,
-	.suspend		= rk2928_lcdc_early_suspend,
-	.resume			= rk2928_lcdc_early_resume,
-	.set_par       		= rk2928_lcdc_set_par,
-	.blank         		= rk2928_lcdc_blank,
-	.pan_display            = rk2928_lcdc_pan_display,
-	.load_screen		= rk2928_load_screen,
-	.get_layer_state	= rk2928_lcdc_get_layer_state,
-	.ovl_mgr		= rk2928_lcdc_ovl_mgr,
-	.get_disp_info		= rk2928_lcdc_get_disp_info,
-	.fps_mgr		= rk2928_lcdc_fps_mgr,
-	.fb_get_layer           = rk2928_fb_get_layer,
-	.fb_layer_remap         = rk2928_fb_layer_remap,
-	.lcdc_hdmi_process	= rk2928_lcdc_hdmi_process,
-};
-#ifdef CONFIG_PM
-static int rk2928_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk2928_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#else
-#define rk2928_lcdc_suspend NULL
-#define rk2928_lcdc_resume NULL
-#endif
-
-static int __devinit rk2928_lcdc_probe (struct platform_device *pdev)
-{
-	struct rk2928_lcdc_device *lcdc_dev=NULL;
-	rk_screen *screen0;
-	rk_screen *screen1;
-	struct rk29fb_info *screen_ctr_info;
-	struct resource *res = NULL;
-	struct resource *mem;
-	int ret = 0;
-	
-	/*************Malloc rk2928lcdc_inf and set it to pdev for drvdata**********/
-	lcdc_dev = kzalloc(sizeof(struct rk2928_lcdc_device), GFP_KERNEL);
-    	if(!lcdc_dev)
-    	{
-        	dev_err(&pdev->dev, ">>rk2928 lcdc device kmalloc fail!");
-        	return -ENOMEM;
-    	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->id = pdev->id;
-	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
-	screen0 =  kzalloc(sizeof(rk_screen), GFP_KERNEL); //rk2928 has one lcdc but two outputs
-	if(!screen0)
-	{
-		dev_err(&pdev->dev, ">>rk2928 lcdc screen1 kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	screen0->lcdc_id = 0;  //this id can be changed dynamic
-	screen0->screen_id = 0; //this id is fixed
-	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen1)
-	{
-		dev_err(&pdev->dev, ">>rk2928 lcdc screen1 kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	screen1->lcdc_id = 1;
-	screen1->screen_id = 1;
-	
-	/****************get lcdc0 reg  *************************/
-	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
-	if (res == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-    	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
-    	if (mem == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
-	if (lcdc_dev->reg_vir_base == NULL)
-	{
-		dev_err(&pdev->dev, "cannot map IO\n");
-		ret = -ENXIO;
-		goto err2;
-	}
-	
-    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
-	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
-	lcdc_dev->driver.dev=&pdev->dev;
-	lcdc_dev->driver.screen0 = screen0;  //direct out put
-	lcdc_dev->driver.screen1 = screen1; //out put from scale
-	lcdc_dev->driver.cur_screen = screen0;
-	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
-	spin_lock_init(&lcdc_dev->reg_lock);
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if(lcdc_dev->irq < 0)
-	{
-		dev_err(&pdev->dev, "cannot find IRQ\n");
-		goto err3;
-	}
-	ret = request_irq(lcdc_dev->irq, rk2928_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
-	if (ret)
-	{
-	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
-	       ret = -EBUSY;
-	       goto err3;
-	}
-
-	if(screen_ctr_info->set_screen_info)
-	{
-		screen_ctr_info->set_screen_info(screen0,screen_ctr_info->lcd_info);
-		if(SCREEN_NULL==screen0->type)
-		{
-			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-			ret = -ENODEV;
-		}
-		if(screen_ctr_info->io_init)
-			screen_ctr_info->io_init(NULL);
-	}
-	else
-	{
-		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-		ret =  -ENODEV;
-		goto err4;
-	}
-	
-	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
-		goto err4;
-	}
-	printk("rk2928 lcdc%d probe ok!\n",lcdc_dev->id);
-
-	return 0;
-
-err4:
-	free_irq(lcdc_dev->irq,lcdc_dev);
-err3:	
-	iounmap(lcdc_dev->reg_vir_base);
-err2:
-	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
-err1:
-	kfree(screen0);
-err0:
-	platform_set_drvdata(pdev, NULL);
-	kfree(lcdc_dev);
-	return ret;
-    
-}
-static int __devexit rk2928_lcdc_remove(struct platform_device *pdev)
-{
-	struct rk2928_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk_fb_unregister(&(lcdc_dev->driver));
-	rk2928_lcdc_deinit(lcdc_dev);
-	iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);
-	return 0;
-}
-
-static void rk2928_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct rk2928_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
-		lcdc_dev->driver.cur_screen->standby(1);
-	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
-		lcdc_dev->driver.screen_ctr_info->io_disable();
-	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds
-		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
-	//rk_fb_unregister(&(lcdc_dev->driver));
-	rk2928_lcdc_deinit(lcdc_dev);
-	/*iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);*/
-}
-
-
-static struct platform_driver rk2928lcdc_driver = {
-	.probe		= rk2928_lcdc_probe,
-	.remove		= __devexit_p(rk2928_lcdc_remove),
-	.driver		= {
-		.name	= "rk2928-lcdc",
-		.owner	= THIS_MODULE,
-	},
-	.suspend	= rk2928_lcdc_suspend,
-	.resume		= rk2928_lcdc_resume,
-	.shutdown   = rk2928_lcdc_shutdown,
-};
-
-static int __init rk2928_lcdc_init(void)
-{
-    return platform_driver_register(&rk2928lcdc_driver);
-}
-
-static void __exit rk2928_lcdc_exit(void)
-{
-	platform_driver_unregister(&rk2928lcdc_driver);
-}
-
-
-
-fs_initcall(rk2928_lcdc_init);
-module_exit(rk2928_lcdc_exit);
-
-
-
diff --git a/drivers/video/rockchip/lcdc/rk2928_lcdc.h b/drivers/video/rockchip/lcdc/rk2928_lcdc.h
deleted file mode 100644
index 2339a71259bc..000000000000
--- a/drivers/video/rockchip/lcdc/rk2928_lcdc.h
+++ /dev/null
@@ -1,527 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK2928_LCDC_H_
-#define RK2928_LCDC_H_
-
-#include<linux/rk_fb.h>
-
-#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
-#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
-#define LcdRdReg(inf, addr)             (inf->preg->addr)
-#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
-#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
-#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
-#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
-#define LCDC_REG_CFG_DONE()             LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
-
-/********************************************************************
-**                                                          *
-********************************************************************/
-/* LCDC */
-
-typedef volatile struct tagLCDC_REG
-{
-    /* offset 0x00~0xc0 */
-	unsigned int SYS_CFG;               		//0x00 system config register
-	unsigned int DSP_CTRL;				//0x0c display control register 
-	unsigned int BG_COLOR;				//back ground color register
-	unsigned int ALPHA_CTRL;				//alpha control register
-	unsigned int INT_STATUS;             		//0x10 Interrupt status register
-	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
-	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
-	unsigned int WIN0_YRGB_MST;           //0x28 Win0 active YRGB memory start address0
-	unsigned int WIN0_CBR_MST;            //0x2c Win0 active Cbr memory start address0
-	unsigned int WIN_VIR;                //0x38 WIN0 virtual display width/height
-	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
-	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
-	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
-	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
-	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
-	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
-	unsigned int WIN1_RGB_MST;           //0x54 Win1 active YRGB memory start address
-	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
-	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
-	unsigned int HWC_MST;                 //0x88 HWC memory start address
-	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
-	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2b01 look up table 0
-	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2b10 look up table 1
-	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2b11 look up table 2
-	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
-	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
-	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
-	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
-	unsigned int SCL_REG0;		      //scaler register
-	unsigned int SCL_REG1;
-	unsigned int SCL_REG2;
-	unsigned int SCL_REG3;
-	unsigned int SCL_REG4;
-	unsigned int SCL_REG5;
-	unsigned int SCL_REG6;
-	unsigned int SCL_REG7;
-	unsigned int SCL_REG8;
-	unsigned int reserve[3];
-	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
-  
-} LCDC_REG, *pLCDC_REG;
-
-
-/* SYS_CONFIG */
-
-#define  m_W0_EN              (1<<0)
-#define  m_W1_EN              (1<<1)
-#define  m_HWC_EN             (1<<2)
-#define  m_W0_FORMAT          (7<<3)
-#define  m_W1_FORMAT          (7<<6)
-#define  m_W0_RGB_RB_SWAP     (1<<10)
-#define  m_W1_RGB_RB_SWAP     (1<<14)
-
-#define m_W0_AXI_OUTSTANDING_DISABLE (1<<16) 
-#define m_W1_AXI_OUTSTANDING_DISABLE (1<<17)
-#define m_DMA_BURST_LENGTH	     (3<<18)
-#define m_LCDC_STANDBY		     (1<<22)
-
-#define m_LCDC_AXICLK_AUTO_ENABLE    (1<<24) //eanble for low power
-#define m_DSP_OUT_ZERO		     (1<<25)
-
-#define v_W0_EN(x)          		(((x)&1)<<0)
-#define v_W1_EN(x)          		(((x)&1)<<1)
-#define v_HWC_EN(x)         		(((x)&1)<<2)
-#define v_W0_FORMAT(x)      		(((x)&7)<<3)
-#define v_W1_FORMAT(x)      		(((x)&7)<<6)
-#define v_W0_RGB_RB_SWAP(x)		(((x)&1)<<10)	
-#define v_W1_RGB_RB_SWAP(x)		(((x)&1)<<14)
-
-#define v_LCDC_STANDBY(x)		(((x)&1)<<22)
-#define v_LCDC_AXICLK_AUTO_ENABLE(x)    (((x)&1)<<24)
-#define v_DSP_OUT_ZERO(x)    		(((x)&1)<<25)
-
-
-#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
-#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
-#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
-#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
-#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
-#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
-#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
-#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
-#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
-#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
-#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
-#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
-#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
-#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
-
-
-
-//LCDC_DSP_CTRL_REG
-#define m_DISPLAY_FORMAT             (3<<0)
-#define m_BLANK_MODE                 (1<<2)
-#define m_BLACK_MODE                 (1<<3)
-#define m_HSYNC_POLARITY             (1<<4)
-#define m_VSYNC_POLARITY             (1<<5)
-#define m_DEN_POLARITY               (1<<6)
-#define m_DCLK_POLARITY              (1<<7)
-#define m_W0W1_POSITION_SWAP         (1<<8)
-#define m_OUTPUT_BG_SWAP             (1<<9)
-#define m_OUTPUT_RB_SWAP             (1<<10)
-#define m_OUTPUT_RG_SWAP             (1<<11)
-#define m_DITHER_UP_EN               (1<<12)
-#define m_DITHER_DOWN_MODE           (1<<13)
-#define m_DITHER_DOWN_EN             (1<<14)
-
-
-#define m_W1_INTERLACE_READ_MODE     (1<<15)
-#define m_W2_INTERLACE_READ_MODE     (1<<16)
-#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
-#define m_W0_CBR_DEFLICK_MODE        (1<<18)
-#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
-#define m_W1_CBR_DEFLICK_MODE        (1<<20)
-#define m_W0_ALPHA_MODE              (1<<21)
-#define m_W1_ALPHA_MODE              (1<<22)
-#define m_W2_ALPHA_MODE              (1<<23)
-#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
-#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
-#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
-#define m_YCRCB_CLIP_EN              (1<<29)
-#define m_CBR_FILTER_656             (1<<30)
-
-#define v_DISPLAY_FORMAT(x)           (((x)&0x3)<<0)
-#define v_BLANK_MODE(x)               (((x)&1)<<2)
-#define v_BLACK_MODE(x)               (((x)&1)<<3)
-#define v_HSYNC_POLARITY(x)           (((x)&1)<<4)
-#define v_VSYNC_POLARITY(x)           (((x)&1)<<5)
-#define v_DEN_POLARITY(x)             (((x)&1)<<6)
-#define v_DCLK_POLARITY(x)            (((x)&1)<<7)
-#define v_W0W1_POSITION_SWAP(x)	      (((x)&1)<<8)
-#define v_OUTPUT_BG_SWAP(x)           (((x)&1)<<9)
-#define v_OUTPUT_RB_SWAP(x)           (((x)&1)<<10)
-#define v_OUTPUT_RG_SWAP(x)           (((x)&1)<<11)
-#define v_DITHER_UP_EN(x)               (((x)&1)<<12)
-#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<13)
-#define v_DITHER_DOWN_EN(x)             (((x)&1)<<14)
-
-#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
-#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
-#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
-#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
-#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
-#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
-#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
-#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
-#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
-#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
-#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
-#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
-#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
-#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
-#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
-#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
-#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
-
-//LCDC_BG_COLOR
-#define m_BG_COLOR                    (0xffffff<<0)
-#define m_BG_B                        (0xff<<0)
-#define m_BG_G                        (0xff<<8)
-#define m_BG_R                        (0xff<<16)
-#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
-#define v_BG_B(x)                     (((x)&0xff)<<0)
-#define v_BG_G(x)                     (((x)&0xff)<<8)
-#define v_BG_R(x)                     (((x)&0xff)<<16)
-
-
-
-
-//LCDC_ BLEND_CTRL
-#define m_HWC_BLEND_EN         (1<<0)
-#define m_W2_BLEND_EN          (1<<1)
-#define m_W1_BLEND_EN          (1<<2)
-#define m_W0_BLEND_EN          (1<<3)
-#define m_HWC_BLEND_FACTOR     (15<<4)
-#define m_W2_BLEND_FACTOR     (0xff<<8)
-#define m_W1_BLEND_FACTOR     (0xff<<16)
-#define m_W0_BLEND_FACTOR     (0xff<<24)
-
-#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
-#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
-#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
-#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
-#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
-#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
-#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
-#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
-
-//LCDC_INT_STATUS
-#define v_HOR_START_INT_STA        (1<<0)  //status
-#define v_FRM_START_INT_STA        (1<<1)
-#define v_LINE_FLAG_INT_STA        (1<<2)
-#define v_BUS_ERR_INT_STA	   (1<<3)
-#define m_HOR_START_INT_EN     	   (1<<4)  //enable
-#define m_FRM_START_INT_EN          (1<<5)
-#define m_LINE_FLAG_INT_EN         (1<<6)
-#define m_BUS_ERR_INT_EN	   (1<<7)
-#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
-#define m_FRM_START_INT_CLEAR      (1<<9)
-#define m_LINE_FLAG_INT_CLEAR      (1<<10)
-#define m_BUS_ERR_INT_CLEAR        (1<<11)
-#define m_LINE_FLAG_NUM		   (0xfff<<12)
-#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
-#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
-#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
-#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
-#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
-#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
-#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
-#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
-#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
-
-
-//LCDC_WIN_VIR
-#define m_WIN0_VIR   (0xfff << 0)
-#define m_WIN1_VIR   (0xfff << 16)
-//LCDC_WINx_VIR ,x is number of words of win0 virtual width
-#define v_WIN0_ARGB888_VIRWIDTH(x) (x)
-#define v_WIN0_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
-#define v_WIN0_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
-#define v_WIN0_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
-
-#define v_WIN1_ARGB888_VIRWIDTH(x) (x << 16)
-#define v_WIN1_RGB888_VIRWIDTH(x)  ((((x*3)>>2)+((x)%3)) << 16)
-#define v_WIN1_RGB565_VIRWIDTH(x)  ((((x)>>1) + ((x%2)?1:0)) << 16)
-#define v_WIN1_YUV_VIRWIDTH(x)     ((((x)>>2) +((x%4)?1:0)) << 16 )
-
-
-//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
-#define m_KEYCOLOR          (0xffffff<<0)
-#define m_KEYCOLOR_B          (0xff<<0)
-#define m_KEYCOLOR_G          (0xff<<8)
-#define m_KEYCOLOR_R          (0xff<<16)
-#define m_COLORKEY_EN         (1<<24)
-#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
-#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
-#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
-#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
-#define v_COLORKEY_EN(x)         (((x)&1)<<24)
-
-//LCDC_DEFLICKER_SCL_OFFSET
-#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
-#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
-#define m_W1_VSD_OFFSET           (0xff<<16)
-#define m_W1_VSP_OFFSET           (0xff<<24)
-#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
-#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
-#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
-#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
-
-
-
-
-
-//AXI MS ID
-#define m_W0_YRGB_CH_ID        (0xF<<0)
-#define m_W0_CBR_CH_ID         (0xF<<4)
-#define m_W1_YRGB_CH_ID        (0xF<<8)
-#define m_W2_CH_ID             (0xF<<12)
-#define m_HWC_CH_ID            (0xF<<16)
-#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
-#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
-#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
-#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
-#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
-
-
-/* Low Bits Mask */
-#define m_WORDLO            (0xffff<<0)
-#define m_WORDHI            (0xffff<<16)
-#define v_WORDLO(x)         (((x)&0xffff)<<0)
-#define v_WORDHI(x)         (((x)&0xffff)<<16)
-
-
-//LCDC_WINx_SCL_FACTOR_Y/CBCR
-#define v_X_SCL_FACTOR(x)  ((x)<<0)
-#define v_Y_SCL_FACTOR(x)  ((x)<<16)
-
-//LCDC_DSP_HTOTAL_HS_END
-#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
-#define v_HORPRD(x) ((x)<<16)   //horizontal period
-
-
-//LCDC_DSP_HACT_ST_END
-#define v_HAEP(x) ((x)<<0)  //horizontal active end point
-#define v_HASP(x) ((x)<<16) //horizontal active start point
-
-//LCDC_DSP_VTOTAL_VS_END
-#define v_VSYNC(x) ((x)<<0)
-#define v_VERPRD(x) ((x)<<16)
-
-//LCDC_DSP_VACT_ST_END
-#define v_VAEP(x) ((x)<<0)
-#define v_VASP(x) ((x)<<16)
-
-
-
-#define m_ACTWIDTH       (0xffff<<0)
-#define m_ACTHEIGHT      (0xffff<<16)
-#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
-#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
-
-#define m_VIRST_X      (0xffff<<0)
-#define m_VIRST_Y      (0xffff<<16)
-#define v_VIRST_X(x)      (((x)&0xffff)<<0)
-#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
-
-#define m_PANELST_X      (0x3ff<<0)
-#define m_PANELST_Y      (0x3ff<<16)
-#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
-#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
-
-#define m_PANELWIDTH       (0x3ff<<0)
-#define m_PANELHEIGHT      (0x3ff<<16)
-#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
-#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
-
-#define m_HWC_B                 (0xff<<0)
-#define m_HWC_G                 (0xff<<8)
-#define m_HWC_R                 (0xff<<16)
-#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
-#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
-#define v_HWC_B(x)                 (((x)&0xff)<<0)
-#define v_HWC_G(x)                 (((x)&0xff)<<8)
-#define v_HWC_R(x)                 (((x)&0xff)<<16)
-#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
-#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
-
-//LCDC_WIN0_ACT_INFO
-#define v_ACT_WIDTH(x)     ((x-1)<<0)
-#define v_ACT_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_INFO
-#define v_DSP_WIDTH(x)     ((x-1)<<0)
-#define v_DSP_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
-#define v_DSP_STX(x)      (x<<0)
-#define v_DSP_STY(x)      (x<<16)
-
-//Panel display scanning
-#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
-
-#define m_PANEL_END              (0x3ff<<0)
-#define m_PANEL_START            (0x3ff<<16)
-#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
-#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
-
-#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
-//-----------
-
-#define m_HSCALE_FACTOR        (0xffff<<0)
-#define m_VSCALE_FACTOR        (0xffff<<16)
-#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
-#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
-
-#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
-#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
-#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
-#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
-#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
-#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
-#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
-#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
-
-
-//LCDC_SCL_REG0
-#define m_SCL_DSP_ZERO 		 (1<<4)
-#define m_SCL_DEN_INVERT	 (1<<3)
-#define m_SCL_SYNC_INVERT	 (1<<2)
-#define m_SCL_DCLK_INVERT	 (1<<1)
-#define m_SCL_EN	 	 (1<<0)
-#define v_SCL_DSP_ZERO(x) 	 (((x)&1)<<4)
-#define v_SCL_DEN_INVERT(x)	 (((x)&1)<<3)
-#define v_SCL_SYNC_INVERT(x)	 (((x)&1)<<2)
-#define v_SCL_DCLK_INVERT(x)	 (((x)&1)<<1)
-#define v_SCL_EN(x)	 	 (((x)&1)<<0)
-
-//LCDC_SCL_REG1
-#define m_SCL_V_FACTOR 		 (0x3fff<<16)
-#define m_SCL_H_FACTOR		 (0x3fff<<0)
-#define v_SCL_V_FACTOR(x) 		 (((x)&0x3fff)<<16)
-#define v_SCL_H_FACTOR(x)		 (((x)&0x3fff)<<0)
-
-
-//LCDC_SCL_REG2
-#define m_SCL_DSP_FRAME_VST	(0xfff<<16)
-#define m_SCL_DSP_FRAME_HST	(0xfff<<0)
-#define v_SCL_DSP_FRAME_VST(x)	(((x)&0xfff)<<16)
-#define v_SCL_DSP_FRAME_HST(x)	(((x)&0xfff)<<0)
-
-//LCDC_SCL_REG3
-#define m_SCL_DSP_HS_END	(0xff<<16)
-#define m_SCL_DSP_HTOTAL	(0xfff<<0)
-#define v_SCL_DSP_HS_END(x)	(((x)&0xff)<<16)
-#define v_SCL_DSP_HTOTAL(x)	(((x)&0xfff)<<0)
-
-//LCDC_SCL_REG4
-#define m_SCL_DSP_HACT_ST	(0x3ff<<16)
-#define m_SCL_DSP_HACT_END	(0xfff<<0)
-#define v_SCL_DSP_HACT_ST(x)	(((x)&0x3ff)<<16)
-#define v_SCL_DSP_HACT_END(x)	(((x)&0xfff)<<0)
-
-//LCDC_SCL_REG5
-#define m_SCL_DSP_VS_END	(0xff<<16)
-#define m_SCL_DSP_VTOTAL	(0xfff<<0)
-#define v_SCL_DSP_VS_END(x)	(((x)&0xff)<<16)
-#define v_SCL_DSP_VTOTAL(x)	(((x)&0xfff)<<0)
-
-//LCDC_SCL_REG6
-#define m_SCL_DSP_VACT_ST	(0xff<<16)
-#define m_SCL_DSP_VACT_END	(0xfff<<0)
-#define v_SCL_DSP_VACT_ST(x)	(((x)&0xff)<<16)
-#define v_SCL_DSP_VACT_END(x)	(((x)&0xfff)<<0)
-
-
-//LCDC_SCL_REG7
-#define m_SCL_DSP_HBOR_ST	(0x3ff<<16)
-#define m_SCL_DSP_HBOR_END	(0xfff<<0)
-#define v_SCL_DSP_HBOR_ST(x)	(((x)&0x3ff)<<16)
-#define v_SCL_DSP_HBOR_END(x)	(((x)&0xfff)<<0)
-
-//LCDC_SCL_REG8
-
-#define m_SCL_DSP_VBOR_ST	(0xff<<16)
-#define m_SCL_DSP_VBOR_END	(0xfff<<0)
-#define v_SCL_DSP_VBOR_ST(x)	(((x)&0xff)<<16)
-#define v_SCL_DSP_VBOR_END(x)	(((x)&0xfff)<<0)
-
-
-
-
-
-#define CalScale(x, y)	             (((u32)(x)*0x1000)/(y))
-struct rk2928_lcdc_device{
-	int id;
-	struct rk_lcdc_device_driver driver;
-	rk_screen *screen;
-	
-	LCDC_REG *preg;         // LCDC reg base address and backup reg 
-    	LCDC_REG regbak;
-
-	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
-	u32 reg_phy_base;       	// physical basic address of lcdc register
-	u32 len;               		// physical map length of lcdc register
-	spinlock_t  reg_lock;		//one time only one process allowed to config the register
-	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
-	u8 atv_layer_cnt;               //active layer counter,when  atv_layer_cnt = 0,disable lcdc
-	unsigned int		irq;
-	
-	struct clk              *pd;                            //lcdc power domain	
-	struct clk		*hclk;				//lcdc AHP clk
-	struct clk		*dclk;				//lcdc dclk
-	struct clk		*aclk;				//lcdc share memory frequency
-	struct clk		*sclk;				//scale clk
-	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
-	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
-	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
-	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
-	struct clk		*pd_display;		// display power domain
-	u32	pixclock;
-};
-
-struct lcdc_info{
-/*LCD CLK*/
-	struct rk2928_lcdc_device lcdc0;
-
-};
-
-
-struct win_set {
-	volatile u32 y_offset;
-	volatile u32 c_offset;
-};
-
-struct win0_par {
-    u32 refcount;
-    u32	pseudo_pal[16];
-    u32 y_offset;
-    u32 c_offset;
-    u32 xpos;         //size in panel
-    u32 ypos;
-    u32 xsize;        //start point in panel
-    u32 ysize;
-    enum data_format format;
-
-    wait_queue_head_t wait;
-    struct win_set mirror;
-    struct win_set displ;
-    struct win_set done;
-
-    u8 par_seted;
-    u8 addr_seted;
-};
-
-#endif
-
-
diff --git a/drivers/video/rockchip/lcdc/rk3036_lcdc.c b/drivers/video/rockchip/lcdc/rk3036_lcdc.c
deleted file mode 100755
index dbaf15bfafe4..000000000000
--- a/drivers/video/rockchip/lcdc/rk3036_lcdc.c
+++ /dev/null
@@ -1,1688 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk3036_lcdc.c
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * Author:zhengyang<zhengyang@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/common.h>
-#include <dt-bindings/clock/rk_system_status.h>
-#if defined(CONFIG_ION_ROCKCHIP)
-#include <linux/rockchip-iovmm.h>
-#endif
-#include "rk3036_lcdc.h"
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		dev_info(dev_drv->dev, x);		\
-	} while (0)
-
-#define grf_writel(offset, v)	do { \
-	writel_relaxed(v, RK_GRF_VIRT + offset); \
-	dsb(); \
-	} while (0)
-
-static struct rk_lcdc_win lcdc_win[] = {
-	[0] = {
-	       .name = "win0",
-	       .id = 0,
-	       .support_3d = false,
-	       },
-	[1] = {
-	       .name = "win1",
-	       .id = 1,
-	       .support_3d = false,
-	       },
-	[2] = {
-	       .name = "hwc",
-	       .id = 2,
-	       .support_3d = false,
-	       },
-};
-
-static irqreturn_t rk3036_lcdc_isr(int irq, void *dev_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    (struct lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-
-	if (int_reg & m_FS_INT_STA) {
-		timestamp = ktime_get();
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-		/*if (lcdc_dev->driver.wait_fs) {*/
-		if (0) {
-			spin_lock(&(lcdc_dev->driver.cpl_lock));
-			complete(&(lcdc_dev->driver.frame_done));
-			spin_unlock(&(lcdc_dev->driver.cpl_lock));
-		}
-		lcdc_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-
-	} else if (int_reg & m_LF_INT_STA) {
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
-			     v_LF_INT_CLEAR(1));
-	}
-	return IRQ_HANDLED;
-}
-
-static int rk3036_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 1;
-	return 0;
-#endif
-	if (!lcdc_dev->clk_on) {
-		clk_prepare_enable(lcdc_dev->hclk);
-		clk_prepare_enable(lcdc_dev->dclk);
-		clk_prepare_enable(lcdc_dev->aclk);
-/*		clk_prepare_enable(lcdc_dev->pd);*/
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rk3036_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 0;
-	return 0;
-#endif
-	if (lcdc_dev->clk_on) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		clk_disable_unprepare(lcdc_dev->dclk);
-		clk_disable_unprepare(lcdc_dev->hclk);
-		clk_disable_unprepare(lcdc_dev->aclk);
-/*		clk_disable_unprepare(lcdc_dev->pd);*/
-	}
-
-	return 0;
-}
-
-static int rk3036_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	mask = m_FS_INT_CLEAR | m_FS_INT_EN;
-	val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1);
-	lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-	return 0;
-}
-/*
-static int rk3036_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
-{
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_FS_INT_CLEAR | m_FS_INT_EN;
-		val = v_FS_INT_CLEAR(0) | v_FS_INT_EN(0);
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-	return 0;
-}*/
-
-static void rk_lcdc_read_reg_defalut_cfg(struct lcdc_device
-					     *lcdc_dev)
-{
-	int reg = 0;
-	u32 value = 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	for (reg = 0; reg < 0xe0; reg += 4)
-		value = lcdc_readl(lcdc_dev, reg);
-
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-
-static int rk3036_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
-{
-	int win0_top = 0;
-	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
-
-	int win0_alpha_en = ((win0_format == ARGB888) ||
-				(win0_format == ABGR888)) ? 1 : 0;
-	int win1_alpha_en = ((win1_format == ARGB888) ||
-				(win1_format == ABGR888)) ? 1 : 0;
-	int atv_layer_cnt = lcdc_dev->driver.win[0]->state +
-			lcdc_dev->driver.win[1]->state;
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (DSP_CTRL0 >> 2);
-	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
-
-	if (win0_top && (atv_layer_cnt >= 2) && (win0_alpha_en)) {
-		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN |
-			m_WIN1_PREMUL_SCALE;
-		val = v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0) |
-			v_WIN1_PREMUL_SCALE(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask = m_WIN0_ALPHA_MODE | m_PREMUL_ALPHA_ENABLE |
-			m_ALPHA_MODE_SEL1;
-		val = v_WIN0_ALPHA_MODE(1) | v_PREMUL_ALPHA_ENABLE(1) |
-			v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else if ((!win0_top) && (atv_layer_cnt >= 2) &&
-		   (win1_alpha_en)) {
-		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN |
-			m_WIN1_PREMUL_SCALE;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1) |
-			v_WIN1_PREMUL_SCALE(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask = m_WIN1_ALPHA_MODE | m_PREMUL_ALPHA_ENABLE |
-			m_ALPHA_MODE_SEL1;
-		val = v_WIN1_ALPHA_MODE(1) | v_PREMUL_ALPHA_ENABLE(1) |
-			v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else {
-		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-	}
-
-	if (lcdc_dev->driver.win[2]->state == 1) {
-		mask =  m_HWC_ALPAH_EN;
-		val = v_HWC_ALPAH_EN(1);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask =  m_HWC_ALPHA_MODE;
-		val = v_HWC_ALPHA_MODE(1);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else {
-		mask =  m_HWC_ALPAH_EN;
-		val = v_HWC_ALPAH_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-	}
-
-	return 0;
-}
-
-static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
-				   struct rk_lcdc_win *win)
-{
-	u32 mask, val;
-	int hwc_size;
-
-	if (win->state == 1) {
-		if (win->id == 0) {
-			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP;
-			val = v_WIN0_EN(win->state) |
-			      v_WIN0_FORMAT(win->area[0].fmt_cfg) |
-			      v_WIN0_RB_SWAP(win->area[0].swap_rb);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
-				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
-				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
-			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
-				    v_X_SCL_FACTOR(win->scale_cbcr_x) |
-				    v_Y_SCL_FACTOR(win->scale_cbcr_y));
-			lcdc_msk_reg(lcdc_dev, WIN0_VIR,
-				     m_YRGB_VIR | m_CBBR_VIR,
-				     v_YRGB_VIR(win->area[0].y_vir_stride) |
-				     v_CBBR_VIR(win->area[0].uv_vir_stride));
-			lcdc_writel(lcdc_dev, WIN0_ACT_INFO,
-				    v_ACT_WIDTH(win->area[0].xact) |
-				    v_ACT_HEIGHT(win->area[0].yact));
-			lcdc_writel(lcdc_dev, WIN0_DSP_ST,
-				    v_DSP_STX(win->area[0].dsp_stx) |
-				    v_DSP_STY(win->area[0].dsp_sty));
-			lcdc_writel(lcdc_dev, WIN0_DSP_INFO,
-				    v_DSP_WIDTH(win->post_cfg.xsize) |
-				    v_DSP_HEIGHT(win->post_cfg.ysize));
-
-			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
-				    win->area[0].y_addr);
-			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
-				    win->area[0].uv_addr);
-		} else if (win->id == 1) {
-			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
-			val = v_WIN1_EN(win->state) |
-			      v_WIN1_FORMAT(win->area[0].fmt_cfg) |
-			      v_WIN1_RB_SWAP(win->area[0].swap_rb);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB,
-				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
-				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
-
-			lcdc_msk_reg(lcdc_dev, WIN1_VIR, m_YRGB_VIR,
-				     v_YRGB_VIR(win->area[0].y_vir_stride));
-			lcdc_writel(lcdc_dev, WIN1_ACT_INFO,
-				    v_ACT_WIDTH(win->area[0].xact) |
-				    v_ACT_HEIGHT(win->area[0].yact));
-			lcdc_writel(lcdc_dev, WIN1_DSP_INFO,
-				    v_DSP_WIDTH(win->post_cfg.xsize) |
-				    v_DSP_HEIGHT(win->post_cfg.ysize));
-			lcdc_writel(lcdc_dev, WIN1_DSP_ST,
-				    v_DSP_STX(win->area[0].dsp_stx) |
-				    v_DSP_STY(win->area[0].dsp_sty));
-			lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
-		} else if (win->id == 2) {
-			mask = m_HWC_EN | m_HWC_LODAD_EN;
-			val = v_HWC_EN(win->state) | v_HWC_LODAD_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			if ((win->area[0].xsize == 32) &&
-			    (win->area[0].ysize == 32))
-				hwc_size = 0;
-			else if ((win->area[0].xsize == 64) &&
-				 (win->area[0].ysize == 64))
-				hwc_size = 1;
-			else
-				dev_err(lcdc_dev->dev,
-					"unsupport hwc size:x=%d,y=%d\n",
-					win->area[0].xsize,
-					win->area[0].ysize);
-			lcdc_writel(lcdc_dev, HWC_DSP_ST,
-				    v_DSP_STX(win->area[0].dsp_stx) |
-				    v_DSP_STY(win->area[0].dsp_sty));
-			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
-		}
-	} else {
-		win->area[0].y_addr = 0;
-		win->area[0].uv_addr = 0;
-		if (win->id == 0) {
-			lcdc_msk_reg(lcdc_dev,
-				     SYS_CTRL, m_WIN0_EN, v_WIN0_EN(0));
-			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
-				    win->area[0].y_addr);
-			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
-				    win->area[0].uv_addr);
-		} else if (win->id == 1) {
-			lcdc_msk_reg(lcdc_dev,
-				     SYS_CTRL, m_WIN1_EN, v_WIN1_EN(0));
-			lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
-		} else if (win->id == 2) {
-			lcdc_msk_reg(lcdc_dev,
-				     SYS_CTRL, m_HWC_EN | m_HWC_LODAD_EN,
-				     v_HWC_EN(0) | v_HWC_LODAD_EN(0));
-			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
-		}
-	}
-	rk3036_lcdc_alpha_cfg(lcdc_dev);
-}
-
-static void lcdc_layer_enable(struct lcdc_device *lcdc_dev,
-			      unsigned int win_id, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on) &&
-	    lcdc_dev->driver.win[win_id]->state != open) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev,
-					 "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt |= (1 << win_id);
-		} else if ((lcdc_dev->atv_layer_cnt & (1 << win_id)) && (!open)) {
-			lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
-		}
-		lcdc_dev->driver.win[win_id]->state = open;
-		if (!open) {
-			lcdc_layer_update_regs(lcdc_dev,
-					       lcdc_dev->driver.win[win_id]);
-			lcdc_cfg_done(lcdc_dev);
-		}
-		/*if no layer used,disable lcdc*/
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev,
-				 "no layer is used, go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-/*
-static int rk3036_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-	int timeout;
-	unsigned long flags;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(lcdc_dev->standby));
-		lcdc_layer_update_regs(lcdc_dev, win0);
-		lcdc_layer_update_regs(lcdc_dev, win1);
-		rk3036_lcdc_alpha_cfg(lcdc_dev);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	if (0) {
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-						      msecs_to_jiffies
-						      (dev_drv->cur_screen->ft
-						       + 5));
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_warn(lcdc_dev->dev,
-				 "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
-	return 0;
-}
-*/
-static void rk3036_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
-{
-	memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0xe0);
-}
-
-static void rk3036_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	/*spin_lock(&lcdc_dev->reg_lock);*/
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_MMU_EN | m_AXI_MAX_OUTSTANDING_EN |
-			m_AXI_OUTSTANDING_MAX_NUM;
-		val = v_MMU_EN(1) | v_AXI_OUTSTANDING_MAX_NUM(31) |
-			v_AXI_MAX_OUTSTANDING_EN(1);
-		lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-	}
-	/*spin_unlock(&lcdc_dev->reg_lock);*/
-}
-
-static int rk3036_lcdc_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
-				   int *hwc_lut, int mode)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	int len = 256*4;
-
-	struct lcdc_device *lcdc_dev =
-			container_of(dev_drv, struct lcdc_device, driver);
-	if (dev_drv->hwc_lut == NULL)
-		dev_drv->hwc_lut = devm_kzalloc(lcdc_dev->dev, len, GFP_KERNEL);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 256; i++) {
-		if (mode == 1)
-			dev_drv->hwc_lut[i] = hwc_lut[i];
-		v = dev_drv->hwc_lut[i];
-		c = lcdc_dev->hwc_lut_addr_base + i;
-		writel_relaxed(v, c);
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-#if 0
-static int rk3036_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv)
-{
-#ifdef CONFIG_RK_FPGA
-	return 0;
-#endif
-	int ret, fps;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev,
-			"set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-		 div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	return 0;
-}
-#endif
-/********do basic init*********/
-static int rk3036_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-				struct lcdc_device, driver);
-
-	if (lcdc_dev->pre_init)
-		return 0;
-	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
-	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
-	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
-/*	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc"); */
-
-	if (/*IS_ERR(lcdc_dev->pd) ||*/ (IS_ERR(lcdc_dev->aclk)) ||
-	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
-			lcdc_dev->id);
-	}
-
-	rk_disp_pwr_enable(dev_drv);
-	rk3036_lcdc_clk_enable(lcdc_dev);
-
-	/*backup reg config at uboot*/
-	rk_lcdc_read_reg_defalut_cfg(lcdc_dev);
-	if (lcdc_readl(lcdc_dev, AXI_BUS_CTRL) & m_TVE_DAC_DCLK_EN)
-		dev_drv->cur_screen->type = SCREEN_TVOUT;
-
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN,
-		     v_AUTO_GATING_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	if (dev_drv->iommu_enabled)
-		/*disable win0 to workaround iommu pagefault*/
-		lcdc_layer_enable(lcdc_dev, 0, 0);
-	lcdc_dev->pre_init = true;
-
-	return 0;
-}
-
-static int rk3036_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	int fps;
-	u16 face = 0;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 right_margin = screen->mode.right_margin;
-	u16 left_margin = screen->mode.left_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		switch (screen->type) {
-		case SCREEN_HDMI:
-			mask = m_HDMI_DCLK_EN;
-			val = v_HDMI_DCLK_EN(1);
-			if (screen->pixelrepeat) {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(1);
-			} else {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(0);
-			}
-			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			mask = (1 << 4) | (1 << 5) | (1 << 6);
-			val = (screen->pin_hsync << 4) |
-				(screen->pin_vsync << 5) |
-				(screen->pin_den << 6);
-			grf_writel(RK3036_GRF_SOC_CON2, (mask << 16) | val);
-			break;
-		case SCREEN_TVOUT:
-			mask = m_TVE_DAC_DCLK_EN;
-			val = v_TVE_DAC_DCLK_EN(1);
-			if (screen->pixelrepeat) {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(1);
-			} else {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(0);
-			}
-			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			if ((x_res == 720) && (y_res == 576)) {
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-					     m_TVE_MODE, v_TVE_MODE(TV_PAL));
-			} else if ((x_res == 720) && (y_res == 480)) {
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-					     m_TVE_MODE, v_TVE_MODE(TV_NTSC));
-			} else {
-				dev_err(lcdc_dev->dev,
-					"unsupported video timing!\n");
-				return -1;
-			}
-			break;
-		default:
-			dev_err(lcdc_dev->dev, "un supported interface!\n");
-			break;
-		}
-
-		mask = m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
-		    m_DEN_POL | m_DCLK_POL;
-		val = v_DSP_OUT_FORMAT(face) |
-			v_HSYNC_POL(screen->pin_hsync) |
-			v_VSYNC_POL(screen->pin_vsync) |
-			v_DEN_POL(screen->pin_den) |
-			v_DCLK_POL(screen->pin_dclk);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-
-		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
-		    m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		    m_DSP_DUMMY_SWAP | m_BLANK_EN;
-
-		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
-		    v_DSP_RB_SWAP(screen->swap_rb) |
-		    v_DSP_RG_SWAP(screen->swap_rg) |
-		    v_DSP_DELTA_SWAP(screen->swap_delta) |
-				     v_DSP_DUMMY_SWAP(screen->swap_dumy) |
-						      v_BLANK_EN(0) |
-				     v_BLACK_EN(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-		val =
-		    v_HSYNC(screen->mode.hsync_len) | v_HORPRD(screen->mode.
-							       hsync_len +
-							       left_margin +
-							       x_res +
-							       right_margin);
-		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
-		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
-		    v_HASP(screen->mode.hsync_len + left_margin);
-		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
-
-		if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-			/*First Field Timing*/
-			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END,
-				    v_VSYNC(screen->mode.vsync_len) |
-				    v_VERPRD(2 * (screen->mode.vsync_len +
-						  upper_margin + lower_margin)
-					     + y_res + 1));
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END,
-				    v_VAEP(screen->mode.vsync_len +
-					upper_margin + y_res/2) |
-				    v_VASP(screen->mode.vsync_len +
-					upper_margin));
-			/*Second Field Timing*/
-			lcdc_writel(lcdc_dev, DSP_VS_ST_END_F1,
-				    v_VSYNC_ST_F1(screen->mode.vsync_len +
-						  upper_margin + y_res/2 +
-						  lower_margin) |
-				    v_VSYNC_END_F1(2 * screen->mode.vsync_len
-						   + upper_margin + y_res/2 +
-						   lower_margin));
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END_F1,
-				    v_VAEP(2 * (screen->mode.vsync_len +
-						upper_margin) + y_res +
-						lower_margin + 1) |
-				    v_VASP(2 * (screen->mode.vsync_len +
-						upper_margin) + y_res/2 +
-						lower_margin + 1));
-
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_INTERLACE_DSP_EN |
-				     m_INTERLACE_DSP_POL |
-				     m_WIN1_DIFF_DCLK_EN |
-				     m_WIN0_YRGB_DEFLICK_EN |
-				     m_WIN0_CBR_DEFLICK_EN |
-				     m_WIN0_INTERLACE_EN |
-				     m_WIN1_INTERLACE_EN,
-				     v_INTERLACE_DSP_EN(1) |
-				     v_INTERLACE_DSP_POL(0) |
-				     v_WIN1_DIFF_DCLK_EN(1) |
-				     v_WIN0_YRGB_DEFLICK_EN(1) |
-				     v_WIN0_CBR_DEFLICK_EN(1) |
-				     v_WIN0_INTERLACE_EN(1) |
-				     v_WIN1_INTERLACE_EN(1));
-		} else {
-			val = v_VSYNC(screen->mode.vsync_len) |
-			      v_VERPRD(screen->mode.vsync_len + upper_margin +
-					y_res + lower_margin);
-			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
-
-			val = v_VAEP(screen->mode.vsync_len +
-				     upper_margin + y_res) |
-			    v_VASP(screen->mode.vsync_len +
-				   screen->mode.upper_margin);
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
-
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_INTERLACE_DSP_EN |
-				     m_WIN1_DIFF_DCLK_EN |
-				     m_WIN0_YRGB_DEFLICK_EN |
-				     m_WIN0_CBR_DEFLICK_EN |
-				     m_WIN0_INTERLACE_EN |
-				     m_WIN1_INTERLACE_EN,
-				     v_INTERLACE_DSP_EN(0) |
-				     v_WIN1_DIFF_DCLK_EN(0) |
-				     v_WIN0_YRGB_DEFLICK_EN(0) |
-				     v_WIN0_CBR_DEFLICK_EN(0) |
-				     v_WIN0_INTERLACE_EN(1) |
-				     v_WIN1_INTERLACE_EN(1));
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev,
-			"set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-
-	return 0;
-}
-
-static int rk3036_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
-			    bool open)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-
-	/*enable clk,when first layer open */
-	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
-		rk3036_lcdc_pre_init(dev_drv);
-		rk3036_lcdc_clk_enable(lcdc_dev);
-		if (dev_drv->iommu_enabled) {
-			if (!dev_drv->mmu_dev) {
-				dev_drv->mmu_dev =
-				rk_fb_get_sysmmu_device_by_compatible(
-					dev_drv->mmu_dts_name);
-				if (dev_drv->mmu_dev) {
-					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
-								  dev_drv->dev);
-				} else {
-					dev_err(dev_drv->dev,
-						"failed to get iommu device\n"
-						);
-					return -1;
-				}
-			}
-		}
-		rk3036_lcdc_reg_restore(lcdc_dev);
-		/*if (dev_drv->iommu_enabled)
-			rk3036_lcdc_mmu_en(dev_drv);*/
-		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
-			/*rk3036_lcdc_set_dclk(dev_drv);*/
-			rk3036_lcdc_enable_irq(dev_drv);
-		} else {
-			rk3036_load_screen(dev_drv, 1);
-		}
-	}
-
-	if (win_id < ARRAY_SIZE(lcdc_win))
-		lcdc_layer_enable(lcdc_dev, win_id, open);
-	else
-		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
-
-	/*when all layer closed,disable clk */
-/*
-	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
-		rk3036_lcdc_disable_irq(lcdc_dev);
-		rk3036_lcdc_reg_update(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-		rk3036_lcdc_clk_disable(lcdc_dev);
-	}
-*/
-	return 0;
-}
-
-static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-			container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	struct rk_lcdc_win *win = NULL;
-	char fmt[9] = "NULL";
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-	} else if (win_id == 1) {
-		win = dev_drv->win[1];
-	} else if (win_id == 2) {
-		win = dev_drv->win[2];
-	} else {
-		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
-		return -EINVAL;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	win->post_cfg.xpos = win->area[0].xpos * (dev_drv->overscan.left +
-		dev_drv->overscan.right)/200 + screen->mode.xres *
-			(100 - dev_drv->overscan.left) / 200;
-
-	win->post_cfg.ypos = win->area[0].ypos * (dev_drv->overscan.top +
-		dev_drv->overscan.bottom)/200 +
-		screen->mode.yres *
-			(100 - dev_drv->overscan.top) / 200;
-	win->post_cfg.xsize = win->area[0].xsize *
-				(dev_drv->overscan.left +
-				dev_drv->overscan.right)/200;
-	win->post_cfg.ysize = win->area[0].ysize *
-				(dev_drv->overscan.top +
-				dev_drv->overscan.bottom)/200;
-
-	win->area[0].dsp_stx = win->post_cfg.xpos + screen->mode.left_margin +
-				screen->mode.hsync_len;
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		win->post_cfg.ysize /= 2;
-		win->area[0].dsp_sty = win->post_cfg.ypos/2 +
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-	} else {
-		win->area[0].dsp_sty = win->post_cfg.ypos +
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-	}
-	win->scale_yrgb_x = calscale(win->area[0].xact, win->post_cfg.xsize);
-	win->scale_yrgb_y = calscale(win->area[0].yact, win->post_cfg.ysize);
-
-	switch (win->area[0].format) {
-	case ARGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 0;
-		break;
-	case XBGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 1;
-		break;
-	case ABGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 1;
-		break;
-	case RGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
-		win->area[0].swap_rb = 0;
-		break;
-	case RGB565:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
-		win->area[0].swap_rb = 0;
-		break;
-	case YUV444:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
-			win->scale_cbcr_x = calscale(win->area[0].xact,
-						     win->post_cfg.xsize);
-			win->scale_cbcr_y = calscale(win->area[0].yact,
-						     win->post_cfg.ysize);
-			win->area[0].swap_rb = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n",
-				__func__);
-		}
-		break;
-	case YUV422:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
-			win->scale_cbcr_x = calscale((win->area[0].xact / 2),
-						     win->post_cfg.xsize);
-			win->scale_cbcr_y = calscale(win->area[0].yact,
-						     win->post_cfg.ysize);
-			win->area[0].swap_rb = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n",
-				__func__);
-		}
-		break;
-	case YUV420:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
-			win->scale_cbcr_x = calscale(win->area[0].xact / 2,
-						     win->post_cfg.xsize);
-			win->scale_cbcr_y = calscale(win->area[0].yact / 2,
-						     win->post_cfg.ysize);
-			win->area[0].swap_rb = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n",
-				__func__);
-		}
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-			__func__);
-		break;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(2, "lcdc%d>>%s\n"
-		">>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->area[0].format, fmt),
-		win->area[0].xact, win->area[0].yact, win->post_cfg.xsize,
-		win->post_cfg.ysize, win->area[0].xvir, win->area[0].yvir,
-		win->post_cfg.xpos, win->post_cfg.ypos);
-	return 0;
-}
-
-static int rk3036_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-	} else if (win_id == 1) {
-		win = dev_drv->win[1];
-	} else if (win_id == 2) {
-		win = dev_drv->win[2];
-	} else {
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr = win->area[0].smem_start +
-					win->area[0].y_offset;
-		win->area[0].uv_addr = win->area[0].cbr_start +
-					win->area[0].c_offset;
-		if (win->area[0].y_addr)
-			lcdc_layer_update_regs(lcdc_dev, win);
-		/*lcdc_cfg_done(lcdc_dev);*/
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
-	    lcdc_dev->id, __func__, win->area[0].y_addr,
-	    win->area[0].uv_addr, win->area[0].y_offset);
-	 /* this is the first frame of the system,
-		enable frame start interrupt*/
-	if ((dev_drv->first_frame))  {
-		dev_drv->first_frame = 0;
-		rk3036_lcdc_enable_irq(dev_drv);
-	}
-	return 0;
-}
-
-static int rk3036_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-			     unsigned long arg, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = lcdc_dev->screen->mode.xres;
-		panel_size[1] = lcdc_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
-			    clr_key_cfg.win0_color_key_cfg);
-		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
-			    clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int rk3036_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
-				  const char *id)
-{
-	int win_id = 0;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2"))
-		win_id = dev_drv->fb2_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int rk3036_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
-				     int win_id,
-				     int area_id)
-{
-	return dev_drv->win[win_id]->state;
-}
-
-static int rk3036_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-	int ovl, needswap = 0;
-
-	if (!swap) {
-		if (win0->z_order >= 0 &&
-		    win1->z_order >= 0 &&
-		    win0->z_order > win1->z_order)
-			needswap = 1;
-		else
-			needswap = 0;
-	} else {
-		needswap = swap;
-	}
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (set) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
-				     v_WIN0_TOP(needswap));
-			ovl = swap;
-		} else {
-			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static int rk3036_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	if (dev_drv->suspend_flag)
-		return 0;
-	dev_drv->suspend_flag = 1;
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
-			     v_BLANK_EN(1));
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(1));
-		lcdc_cfg_done(lcdc_dev);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	rk3036_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(dev_drv);
-	return 0;
-}
-
-static int rk3036_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-	dev_drv->suspend_flag = 0;
-
-	if (lcdc_dev->atv_layer_cnt) {
-		rk3036_lcdc_clk_enable(lcdc_dev);
-		rk3036_lcdc_reg_restore(lcdc_dev);
-		/*set hwc lut*/
-		rk3036_lcdc_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
-
-		spin_lock(&lcdc_dev->reg_lock);
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(0));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(0));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
-			     v_BLANK_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_activate(dev_drv->dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	return 0;
-}
-
-
-static int rk3036_lcdc_blank(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		rk3036_lcdc_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		rk3036_lcdc_early_suspend(dev_drv);
-		break;
-	default:
-		rk3036_lcdc_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int rk3036_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int i;
-	struct rk_lcdc_win *win = NULL;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (dev_drv->iommu_enabled) {
-			if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
-				lcdc_dev->iommu_status = 1;
-				if (support_uboot_display() &&
-				    lcdc_dev->prop == PRMRY) {
-					lcdc_msk_reg(lcdc_dev, SYS_CTRL,
-						     m_WIN0_EN,
-						     v_WIN0_EN(0));
-				}
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-					     v_LCDC_STANDBY(1));
-				lcdc_cfg_done(lcdc_dev);
-				mdelay(50);
-				rockchip_iovmm_activate(dev_drv->dev);
-				rk3036_lcdc_mmu_en(dev_drv);
-			}
-		}
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(lcdc_dev->standby));
-		for (i = 0; i < ARRAY_SIZE(lcdc_win); i++) {
-			win = dev_drv->win[i];
-			if ((win->state == 0) && (win->last_state == 1))
-				lcdc_layer_update_regs(lcdc_dev, win);
-			win->last_state = win->state;
-		}
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-/*
-	a:[-30~0]:
-	    sin_hue = sin(a)*256 +0x100;
-	    cos_hue = cos(a)*256;
-	a:[0~30]
-	    sin_hue = sin(a)*256;
-	    cos_hue = cos(a)*256;
-*/
-static int rk3036_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-				    bcsh_hue_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_H);
-		switch (mode) {
-		case H_SIN:
-			val &= m_BCSH_SIN_HUE;
-			break;
-		case H_COS:
-			val &= m_BCSH_COS_HUE;
-			val >>= 8;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return val;
-}
-
-
-static int rk3036_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-				    int sin_hue, int cos_hue)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
-		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
-		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3036_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode, int value)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		switch (mode) {
-		case BRIGHTNESS:
-		/*from 0 to 255,typical is 128*/
-			if (value < 0x20)
-				value += 0x20;
-			else if (value >= 0x20)
-				value = value - 0x20;
-			mask =  m_BCSH_BRIGHTNESS;
-			val = v_BCSH_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-		/*from 0 to 510,typical is 256*/
-			mask =  m_BCSH_CONTRAST;
-			val =  v_BCSH_CONTRAST(value);
-			break;
-		case SAT_CON:
-		/*from 0 to 1015,typical is 256*/
-			mask = m_BCSH_SAT_CON;
-			val = v_BCSH_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk3036_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= m_BCSH_BRIGHTNESS;
-			if (val > 0x20)
-				val -= 0x20;
-			else if (val == 0x20)
-				val = -32;
-			break;
-		case CONTRAST:
-			val &= m_BCSH_CONTRAST;
-			val >>= 8;
-			break;
-		case SAT_CON:
-			val &= m_BCSH_SAT_CON;
-			val >>= 16;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-
-static int rk3036_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (open) {
-			lcdc_writel(lcdc_dev, BCSH_CTRL,
-				    v_BCSH_EN(1) | v_BCSH_OUT_MODE(3));
-			lcdc_writel(lcdc_dev, BCSH_BCS,
-				    v_BCSH_BRIGHTNESS(0x00) |
-				    v_BCSH_CONTRAST(0x80) |
-				    v_BCSH_SAT_CON(0x80));
-			lcdc_writel(lcdc_dev, BCSH_H, v_BCSH_COS_HUE(0x80));
-		} else {
-			mask = m_BCSH_EN;
-			val = v_BCSH_EN(0);
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL, mask, val);
-		}
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3036_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
-				    struct overscan *overscan)
-{
-	int i;
-
-	dev_drv->overscan = *overscan;
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		if (dev_drv->win[i] && dev_drv->win[i]->state) {
-			rk3036_lcdc_set_par(dev_drv, i);
-			rk3036_lcdc_pan_display(dev_drv, i);
-		}
-	}
-	rk3036_lcdc_cfg_done(dev_drv);
-	return 0;
-}
-
-static int rk3036_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	struct rk_lcdc_win_area area;
-	int fb2_win_id, fb1_win_id, fb0_win_id;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-
-	fb2_win_id = order / 100;
-	fb1_win_id = (order / 10) % 10;
-	fb0_win_id = order % 10;
-
-	if (fb0_win_id != dev_drv->fb0_win_id) {
-		area = dev_drv->win[(int)dev_drv->fb0_win_id]->area[0];
-		dev_drv->win[(int)dev_drv->fb0_win_id]->area[0] =
-			dev_drv->win[fb0_win_id]->area[0];
-		dev_drv->win[fb0_win_id]->area[0] = area;
-		dev_drv->fb0_win_id = fb0_win_id;
-	}
-	dev_drv->fb1_win_id = fb1_win_id;
-	dev_drv->fb2_win_id = fb2_win_id;
-
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int rk3036_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-
-	if (set) {
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->pixclock = pixclock;
-	dev_drv->pixclock = pixclock;
-	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(lcdc_dev->dclk), fps);
-
-	return fps;
-}
-
-static int rk3036_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 int_reg;
-	int ret;
-
-	if (lcdc_dev->clk_on) {
-		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-		if (int_reg & m_LF_INT_STA) {
-			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
-				     v_LF_INT_CLEAR(1));
-			ret = RK_LF_STATUS_FC;
-		} else {
-			ret = RK_LF_STATUS_FR;
-		}
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int rk3036_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-				    unsigned int dsp_addr[][4])
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (lcdc_dev->clk_on) {
-		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
-	}
-	return 0;
-}
-
-static ssize_t rk3036_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
-					 char *buf, int win_id)
-{
-	struct rk_lcdc_win *win = NULL;
-	char fmt[9] = "NULL";
-	u32	size;
-
-	if (win_id < ARRAY_SIZE(lcdc_win)) {
-		win = dev_drv->win[win_id];
-	} else {
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return 0;
-	}
-
-	size = snprintf(buf, PAGE_SIZE, "win%d: %s\n", win_id,
-			get_format_string(win->area[0].format, fmt));
-	size += snprintf(buf + size, PAGE_SIZE - size,
-			 "	xact %d yact %d xvir %d yvir %d\n",
-		win->area[0].xact, win->area[0].yact,
-		win->area[0].xvir, win->area[0].yvir);
-	size += snprintf(buf + size, PAGE_SIZE - size,
-			 "	xpos %d ypos %d xsize %d ysize %d\n",
-		win->area[0].xpos, win->area[0].ypos,
-		win->area[0].xsize, win->area[0].ysize);
-	size += snprintf(buf + size, PAGE_SIZE - size,
-			 "	yaddr 0x%x uvaddr 0x%x\n",
-		win->area[0].y_addr, win->area[0].uv_addr);
-	return size;
-}
-
-static int rk3036_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device,
-						driver);
-	int *cbase = (int *)lcdc_dev->regs;
-	int *regsbak = (int *)lcdc_dev->regsbak;
-	int i, j;
-
-	dev_info(dev_drv->dev, "back up reg:\n");
-	for (i = 0; i <= (0xDC >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			dev_info(dev_drv->dev, "%08x  ",
-				 *(regsbak + i * 4 + j));
-		dev_info(dev_drv->dev, "\n");
-	}
-
-	dev_info(dev_drv->dev, "lcdc reg:\n");
-	for (i = 0; i <= (0xDC >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			dev_info(dev_drv->dev, "%08x  ",
-				 readl_relaxed(cbase + i * 4 + j));
-		dev_info(dev_drv->dev, "\n");
-	}
-	return 0;
-}
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open			= rk3036_lcdc_open,
-	.load_screen		= rk3036_load_screen,
-	.set_par		= rk3036_lcdc_set_par,
-	.pan_display		= rk3036_lcdc_pan_display,
-	.blank			= rk3036_lcdc_blank,
-	.ioctl			= rk3036_lcdc_ioctl,
-	.get_win_state		= rk3036_lcdc_get_win_state,
-	.ovl_mgr		= rk3036_lcdc_ovl_mgr,
-	.get_disp_info		= rk3036_lcdc_get_disp_info,
-	.fps_mgr		= rk3036_lcdc_fps_mgr,
-	.fb_get_win_id		= rk3036_lcdc_get_win_id,
-	.fb_win_remap		= rk3036_fb_win_remap,
-	.poll_vblank		= rk3036_lcdc_poll_vblank,
-	.get_dsp_addr		= rk3036_lcdc_get_dsp_addr,
-	.cfg_done		= rk3036_lcdc_cfg_done,
-	.dump_reg		= rk3036_lcdc_reg_dump,
-	.set_dsp_bcsh_hue	= rk3036_lcdc_set_bcsh_hue,
-	.set_dsp_bcsh_bcs	= rk3036_lcdc_set_bcsh_bcs,
-	.get_dsp_bcsh_hue	= rk3036_lcdc_get_bcsh_hue,
-	.get_dsp_bcsh_bcs	= rk3036_lcdc_get_bcsh_bcs,
-	.open_bcsh		= rk3036_lcdc_open_bcsh,
-	.set_overscan		= rk3036_lcdc_set_overscan,
-	.set_hwc_lut		= rk3036_lcdc_set_hwc_lut,
-};
-
-static int rk3036_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
-{
-	struct device_node *np = lcdc_dev->dev->of_node;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		lcdc_dev->driver.iommu_enabled = 0;
-	else
-		lcdc_dev->driver.iommu_enabled = val;
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
-	else
-		lcdc_dev->driver.fb_win_map = val;
-
-	return 0;
-}
-
-static int rk3036_lcdc_probe(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	int ret;
-
-	lcdc_dev = devm_kzalloc(dev,
-				sizeof(struct lcdc_device), GFP_KERNEL);
-	if (!lcdc_dev) {
-		dev_err(&pdev->dev, "rk3036 lcdc device kmalloc fail!");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->dev = dev;
-	rk3036_lcdc_parse_dt(lcdc_dev);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-	lcdc_dev->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(lcdc_dev->regs))
-		return PTR_ERR(lcdc_dev->regs);
-
-	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
-	if (IS_ERR(lcdc_dev->regsbak))
-		return PTR_ERR(lcdc_dev->regsbak);
-
-	lcdc_dev->hwc_lut_addr_base = (lcdc_dev->regs + HWC_LUT_ADDR);
-	lcdc_dev->prop = PRMRY;
-	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
-	dev_drv = &lcdc_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = PRMRY;
-	dev_drv->id = lcdc_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
-	spin_lock_init(&lcdc_dev->reg_lock);
-
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if (lcdc_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			lcdc_dev->id);
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(dev, lcdc_dev->irq, rk3036_lcdc_isr,
-			       IRQF_DISABLED | IRQF_SHARED,
-			       dev_name(dev), lcdc_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			lcdc_dev->irq, ret);
-		return ret;
-	}
-
-	if (dev_drv->iommu_enabled)
-		strcpy(dev_drv->mmu_dts_name, VOP_IOMMU_COMPATIBLE_NAME);
-
-	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
-		return ret;
-	}
-	lcdc_dev->screen = dev_drv->screen0;
-
-	dev_info(dev, "lcdc probe ok, iommu %s\n",
-		 dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	return 0;
-}
-
-#if defined(CONFIG_PM)
-static int rk3036_lcdc_suspend(struct platform_device *pdev,
-			       pm_message_t state)
-{
-	return 0;
-}
-
-static int rk3036_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define rk3036_lcdc_suspend NULL
-#define rk3036_lcdc_resume  NULL
-#endif
-
-static int rk3036_lcdc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void rk3036_lcdc_shutdown(struct platform_device *pdev)
-{
-}
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3036_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3036-lcdc",},
-	{}
-};
-#endif
-
-static struct platform_driver rk3036_lcdc_driver = {
-	.probe = rk3036_lcdc_probe,
-	.remove = rk3036_lcdc_remove,
-	.driver = {
-		.name = "rk3036-lcdc",
-		.owner = THIS_MODULE,
-		.of_match_table = of_match_ptr(rk3036_lcdc_dt_ids),
-	},
-	.suspend = rk3036_lcdc_suspend,
-	.resume = rk3036_lcdc_resume,
-	.shutdown = rk3036_lcdc_shutdown,
-};
-
-static int __init rk3036_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk3036_lcdc_driver);
-}
-
-static void __exit rk3036_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk3036_lcdc_driver);
-}
-
-fs_initcall(rk3036_lcdc_module_init);
-module_exit(rk3036_lcdc_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk3036_lcdc.h b/drivers/video/rockchip/lcdc/rk3036_lcdc.h
deleted file mode 100644
index 330cb0824d51..000000000000
--- a/drivers/video/rockchip/lcdc/rk3036_lcdc.h
+++ /dev/null
@@ -1,578 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _RK3036_LCDC_H_
-#define _RK3036_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-
-/*******************register definition**********************/
-
-#define SYS_CTRL		(0x00)
-	#define m_WIN0_EN		(1<<0)
-	#define m_WIN1_EN		(1<<1)
-	#define m_HWC_EN		(1<<2)
-	#define m_WIN0_FORMAT		(7<<3)
-	#define m_WIN1_FORMAT		(7<<6)
-	#define m_HWC_LUT_EN		(1<<9)
-	#define m_HWC_SIZE		(1<<10)
-	#define m_WIN0_RB_SWAP		(1<<15)
-	#define m_WIN0_ALPHA_SWAP	(1<<16)
-	#define m_WIN0_Y8_SWAP		(1<<17)
-	#define m_WIN0_UV_SWAP		(1<<18)
-	#define m_WIN1_RB_SWAP		(1<<19)
-	#define m_WIN1_ALPHA_SWAP	(1<<20)
-	#define m_WIN0_OTSD_DISABLE	(1<<22)
-	#define m_WIN1_OTSD_DISABLE	(1<<23)
-	#define m_DMA_BURST_LENGTH	(3<<24)
-	#define m_HWC_LODAD_EN		(1<<26)
-	#define m_DMA_STOP		(1<<29)
-	#define m_LCDC_STANDBY		(1<<30)
-	#define m_AUTO_GATING_EN	(1<<31)
-
-	#define v_WIN0_EN(x)		(((x)&1)<<0)
-	#define v_WIN1_EN(x)		(((x)&1)<<1)
-	#define v_HWC_EN(x)		(((x)&1)<<2)
-	#define v_WIN0_FORMAT(x)	(((x)&7)<<3)
-	#define v_WIN1_FORMAT(x)	(((x)&7)<<6)
-	#define v_HWC_LUT_EN(x)		(((x)&1)<<9)
-	#define v_HWC_SIZE(x)		(((x)&1)<<10)
-	#define v_WIN0_RB_SWAP(x)	(((x)&1)<<15)
-	#define v_WIN0_ALPHA_SWAP(x)	(((x)&1)<<16)
-	#define v_WIN0_Y8_SWAP(x)	(((x)&1)<<17)
-	#define v_WIN0_UV_SWAP(x)	(((x)&1)<<18)
-	#define v_WIN1_RB_SWAP(x)	(((x)&1)<<19)
-	#define v_WIN1_ALPHA_SWAP(x)	(((x)&1)<<20)
-	#define v_WIN0_OTSD_DISABLE(x)	(((x)&1)<<22)
-	#define v_WIN1_OTSD_DISABLE(x)	(((x)&1)<<23)
-	#define v_DMA_BURST_LENGTH(x)	(((x)&3)<<24)
-	#define v_HWC_LODAD_EN(x)	(((x)&1)<<26)
-	#define v_WIN1_LUT_EN(x)	(((x)&1)<<27)
-	#define v_DMA_STOP(x)		(((x)&1)<<29)
-	#define v_LCDC_STANDBY(x)	(((x)&1)<<30)
-	#define v_AUTO_GATING_EN(x)	(((x)&1)<<31)
-
-#define DSP_CTRL0		(0x04)
-	#define m_DSP_OUT_FORMAT	(0x0f<<0)
-	#define m_HSYNC_POL		(1<<4)
-	#define m_VSYNC_POL		(1<<5)
-	#define m_DEN_POL		(1<<6)
-	#define m_DCLK_POL		(1<<7)
-	#define m_WIN0_TOP		(1<<8)
-	#define m_DITHER_UP_EN		(1<<9)
-	#define m_INTERLACE_DSP_EN	(1<<12)
-	#define m_INTERLACE_DSP_POL	(1<<13)
-	#define m_WIN0_INTERLACE_EN	(1<<14)
-	#define m_WIN1_INTERLACE_EN	(1<<15)
-	#define m_WIN0_YRGB_DEFLICK_EN	(1<<16)
-	#define m_WIN0_CBR_DEFLICK_EN	(1<<17)
-	#define m_WIN0_ALPHA_MODE	(1<<18)
-	#define m_WIN1_ALPHA_MODE	(1<<19)
-	#define m_WIN0_CSC_MODE		(3<<20)
-	#define m_WIN0_YUV_CLIP		(1<<23)
-	#define m_TVE_MODE		(1<<25)
-	#define m_HWC_ALPHA_MODE	(1<<28)
-	#define m_PREMUL_ALPHA_ENABLE	(1<<29)
-	#define m_ALPHA_MODE_SEL1	(1<<30)
-	#define m_WIN1_DIFF_DCLK_EN	(1<<31)
-
-	#define v_DSP_OUT_FORMAT(x)	(((x)&0x0f)<<0)
-	#define v_HSYNC_POL(x)		(((x)&1)<<4)
-	#define v_VSYNC_POL(x)		(((x)&1)<<5)
-	#define v_DEN_POL(x)		(((x)&1)<<6)
-	#define v_DCLK_POL(x)		(((x)&1)<<7)
-	#define v_WIN0_TOP(x)		(((x)&1)<<8)
-	#define v_DITHER_UP_EN(x)	(((x)&1)<<9)
-	#define v_INTERLACE_DSP_EN(x)	(((x)&1)<<12)
-	#define v_INTERLACE_DSP_POL(x)	(((x)&1)<<13)
-	#define v_WIN0_INTERLACE_EN(x)	(((x)&1)<<14)
-	#define v_WIN1_INTERLACE_EN(x)	(((x)&1)<<15)
-	#define v_WIN0_YRGB_DEFLICK_EN(x)	(((x)&1)<<16)
-	#define v_WIN0_CBR_DEFLICK_EN(x)	(((x)&1)<<17)
-	#define v_WIN0_ALPHA_MODE(x)		(((x)&1)<<18)
-	#define v_WIN1_ALPHA_MODE(x)		(((x)&1)<<19)
-	#define v_WIN0_CSC_MODE(x)		(((x)&3)<<20)
-	#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<23)
-	#define v_TVE_MODE(x)			(((x)&1)<<25)
-	#define v_HWC_ALPHA_MODE(x)		(((x)&1)<<28)
-	#define v_PREMUL_ALPHA_ENABLE(x)	(((x)&1)<<29)
-	#define v_ALPHA_MODE_SEL1(x)		(((x)&1)<<30)
-	#define v_WIN1_DIFF_DCLK_EN(x)		(((x)&1)<<31)
-
-#define DSP_CTRL1		(0x08)
-	#define m_BG_COLOR		(0xffffff<<0)
-	#define m_BG_B			(0xff<<0)
-	#define m_BG_G			(0xff<<8)
-	#define m_BG_R			(0xff<<16)
-	#define m_BLANK_EN		(1<<24)
-	#define m_BLACK_EN		(1<<25)
-	#define m_DSP_BG_SWAP		(1<<26)
-	#define m_DSP_RB_SWAP		(1<<27)
-	#define m_DSP_RG_SWAP		(1<<28)
-	#define m_DSP_DELTA_SWAP	(1<<29)
-	#define m_DSP_DUMMY_SWAP	(1<<30)
-	#define m_DSP_OUT_ZERO		(1<<31)
-
-	#define v_BG_COLOR(x)		(((x)&0xffffff)<<0)
-	#define v_BG_B(x)		(((x)&0xff)<<0)
-	#define v_BG_G(x)		(((x)&0xff)<<8)
-	#define v_BG_R(x)		(((x)&0xff)<<16)
-	#define v_BLANK_EN(x)		(((x)&1)<<24)
-	#define v_BLACK_EN(x)		(((x)&1)<<25)
-	#define v_DSP_BG_SWAP(x)	(((x)&1)<<26)
-	#define v_DSP_RB_SWAP(x)	(((x)&1)<<27)
-	#define v_DSP_RG_SWAP(x)	(((x)&1)<<28)
-	#define v_DSP_DELTA_SWAP(x)	(((x)&1)<<29)
-	#define v_DSP_DUMMY_SWAP(x)	(((x)&1)<<30)
-	#define v_DSP_OUT_ZERO(x)	(((x)&1)<<31)
-
-#define INT_STATUS		(0x10)
-	#define m_HS_INT_STA		(1<<0) /* status */
-	#define m_FS_INT_STA		(1<<1)
-	#define m_LF_INT_STA		(1<<2)
-	#define m_BUS_ERR_INT_STA	(1<<3)
-	#define m_HS_INT_EN		(1<<4) /* enable */
-	#define m_FS_INT_EN		(1<<5)
-	#define m_LF_INT_EN		(1<<6)
-	#define m_BUS_ERR_INT_EN	(1<<7)
-	#define m_HS_INT_CLEAR		(1<<8) /* auto clear*/
-	#define m_FS_INT_CLEAR		(1<<9)
-	#define m_LF_INT_CLEAR		(1<<10)
-	#define m_BUS_ERR_INT_CLEAR	(1<<11)
-	#define m_LF_INT_NUM		(0xfff<<12)
-	#define m_WIN0_EMPTY_INT_EN	(1<<24)
-	#define m_WIN1_EMPTY_INT_EN	(1<<25)
-	#define m_WIN0_EMPTY_INT_CLEAR	(1<<26)
-	#define m_WIN1_EMPTY_INT_CLEAR	(1<<27)
-	#define m_WIN0_EMPTY_INT_STA	(1<<28)
-	#define m_WIN1_EMPTY_INT_STA	(1<<29)
-	#define m_FS_RAW_STA		(1<<30)
-	#define m_LF_RAW_STA		(1<<31)
-
-	#define v_HS_INT_EN(x)			(((x)&1)<<4)
-	#define v_FS_INT_EN(x)			(((x)&1)<<5)
-	#define v_LF_INT_EN(x)			(((x)&1)<<6)
-	#define v_BUS_ERR_INT_EN(x)		(((x)&1)<<7)
-	#define v_HS_INT_CLEAR(x)		(((x)&1)<<8)
-	#define v_FS_INT_CLEAR(x)		(((x)&1)<<9)
-	#define v_LF_INT_CLEAR(x)		(((x)&1)<<10)
-	#define v_BUS_ERR_INT_CLEAR(x)		(((x)&1)<<11)
-	#define v_LF_INT_NUM(x)			(((x)&0xfff)<<12)
-	#define v_WIN0_EMPTY_INT_EN(x)		(((x)&1)<<24)
-	#define v_WIN1_EMPTY_INT_EN(x)		(((x)&1)<<25)
-	#define v_WIN0_EMPTY_INT_CLEAR(x)	(((x)&1)<<26)
-	#define v_WIN1_EMPTY_INT_CLEAR(x)	(((x)&1)<<27)
-
-
-#define ALPHA_CTRL		(0x14)
-	#define m_WIN0_ALPHA_EN		(1<<0)
-	#define m_WIN1_ALPHA_EN		(1<<1)
-	#define m_HWC_ALPAH_EN		(1<<2)
-	#define m_WIN1_PREMUL_SCALE	(1<<3)
-	#define m_WIN0_ALPHA_VAL	(0xff<<4)
-	#define m_WIN1_ALPHA_VAL	(0xff<<12)
-	#define m_HWC_ALPAH_VAL		(0xff<<20)
-
-	#define v_WIN0_ALPHA_EN(x)	(((x)&1)<<0)
-	#define v_WIN1_ALPHA_EN(x)	(((x)&1)<<1)
-	#define v_HWC_ALPAH_EN(x)	(((x)&1)<<2)
-	#define v_WIN1_PREMUL_SCALE(x)	(((x)&1)<<3)
-	#define v_WIN0_ALPHA_VAL(x)	(((x)&0xff)<<4)
-	#define v_WIN1_ALPHA_VAL(x)	(((x)&0xff)<<12)
-	#define v_HWC_ALPAH_VAL(x)	(((x)&0xff)<<20)
-
-#define WIN0_COLOR_KEY		(0x18)
-#define WIN1_COLOR_KEY		(0x1C)
-	#define m_COLOR_KEY_VAL		(0xffffff<<0)
-	#define m_COLOR_KEY_EN		(1<<24)
-	#define v_COLOR_KEY_VAL(x)	(((x)&0xffffff)<<0)
-	#define v_COLOR_KEY_EN(x)	(((x)&1)<<24)
-
-/* Layer Registers */
-#define WIN0_YRGB_MST		(0x20)
-#define WIN0_CBR_MST		(0x24)
-#define WIN1_MST		(0xa0)
-#define HWC_MST			(0x58)
-
-#define WIN1_VIR		(0x28)
-#define WIN0_VIR		(0x30)
-	#define m_YRGB_VIR	(0x1fff << 0)
-	#define m_CBBR_VIR	(0x1fff << 16)
-
-	#define v_YRGB_VIR(x)	((x & 0x1fff) << 0)
-	#define v_CBBR_VIR(x)	((x & 0x1fff) << 16)
-
-	#define v_ARGB888_VIRWIDTH(x)	(((x) & 0x1fff) << 0)
-	#define v_RGB888_VIRWIDTH(x)	(((((x * 3) >> 2)+(x % 3))&0x1fff)<<0)
-	#define v_RGB565_VIRWIDTH(x)	((DIV_ROUND_UP(x, 2)&0x1fff)<<0)
-	#define v_YUV_VIRWIDTH(x)	((DIV_ROUND_UP(x, 4)&0x1fff)<<0)
-	#define v_CBCR_VIR(x)		((x & 0x1fff) << 16)
-
-#define WIN0_ACT_INFO		(0x34)
-#define WIN1_ACT_INFO		(0xB4)
-	#define m_ACT_WIDTH		(0x1fff << 0)
-	#define m_ACT_HEIGHT		(0x1fff << 16)
-	#define v_ACT_WIDTH(x)		(((x-1) & 0x1fff)<<0)
-	#define v_ACT_HEIGHT(x)		(((x-1) & 0x1fff)<<16)
-
-#define WIN0_DSP_INFO		(0x38)
-#define WIN1_DSP_INFO		(0xB8)
-	#define v_DSP_WIDTH(x)		(((x-1)&0x7ff)<<0)
-	#define v_DSP_HEIGHT(x)		(((x-1)&0x7ff)<<16)
-
-#define WIN0_DSP_ST		(0x3C)
-#define WIN1_DSP_ST		(0xBC)
-#define HWC_DSP_ST		(0x5C)
-	#define v_DSP_STX(x)		(((x)&0xfff)<<0)
-	#define v_DSP_STY(x)		(((x)&0xfff)<<16)
-
-#define WIN0_SCL_FACTOR_YRGB	(0x40)
-#define WIN0_SCL_FACTOR_CBR	(0x44)
-#define WIN1_SCL_FACTOR_YRGB	(0xC0)
-	#define v_X_SCL_FACTOR(x)	(((x)&0xffff)<<0)
-	#define v_Y_SCL_FACTOR(x)	(((x)&0xffff)<<16)
-
-#define WIN0_SCL_OFFSET		(0x48)
-#define WIN1_SCL_OFFSET		(0xC8)
-
-/* LUT Registers */
-#define WIN1_LUT_ADDR			(0x0400)
-#define HWC_LUT_ADDR			(0x0800)
-
-/* Display Infomation Registers */
-#define DSP_HTOTAL_HS_END	(0x6C)
-	/*hsync pulse width*/
-	#define v_HSYNC(x)		(((x)&0xfff)<<0)
-	/*horizontal period*/
-	#define v_HORPRD(x)		(((x)&0xfff)<<16)
-
-#define DSP_HACT_ST_END		(0x70)
-	/*horizontal active end point*/
-	#define v_HAEP(x)		(((x)&0xfff)<<0)
-	/*horizontal active start point*/
-	#define v_HASP(x)		(((x)&0xfff)<<16)
-
-#define DSP_VTOTAL_VS_END	(0x74)
-	#define v_VSYNC(x)		(((x)&0xfff)<<0)
-	#define v_VERPRD(x)		(((x)&0xfff)<<16)
-
-#define DSP_VACT_ST_END		(0x78)
-	#define v_VAEP(x)		(((x)&0xfff)<<0)
-	#define v_VASP(x)		(((x)&0xfff)<<16)
-
-#define DSP_VS_ST_END_F1	(0x7C)
-	#define v_VSYNC_END_F1(x)	(((x)&0xfff)<<0)
-	#define v_VSYNC_ST_F1(x)	(((x)&0xfff)<<16)
-#define DSP_VACT_ST_END_F1	(0x80)
-
-/*BCSH Registers*/
-#define BCSH_CTRL			(0xD0)
-	#define m_BCSH_EN		(1 << 0)
-	#define m_BCSH_OUT_MODE		(3 << 2)
-	#define m_BCSH_CSC_MODE		(3 << 4)
-
-	#define v_BCSH_EN(x)		((1 & x) << 0)
-	#define v_BCSH_OUT_MODE(x)	((3 & x) << 2)
-	#define v_BCSH_CSC_MODE(x)	((3 & x) << 4)
-
-#define BCSH_COLOR_BAR			(0xD4)
-	#define v_BCSH_COLOR_BAR_Y(x)		(((x)&0xf) << 0)
-	#define v_BCSH_COLOR_BAR_U(x)		(((x)&0xf) << 8)
-	#define v_BCSH_COLOR_BAR_V(x)		(((x)&0xf) << 16)
-
-	#define m_BCSH_COLOR_BAR_Y		(0xf << 0)
-	#define m_BCSH_COLOR_BAR_U		(0xf << 8)
-	#define m_BCSH_COLOR_BAR_V		(0xf << 16)
-
-#define BCSH_BCS			(0xD8)
-	#define v_BCSH_BRIGHTNESS(x)		(((x)&0x3f) << 0)
-	#define v_BCSH_CONTRAST(x)		(((x)&0xff) << 8)
-	#define v_BCSH_SAT_CON(x)		(((x)&0x1ff) << 16)
-
-	#define m_BCSH_BRIGHTNESS		(0x3f << 0)
-	#define m_BCSH_CONTRAST			(0xff << 8)
-	#define m_BCSH_SAT_CON			(0x1ff << 16)
-
-#define BCSH_H				(0xDC)
-	#define v_BCSH_SIN_HUE(x)		(((x)&0xff) << 0)
-	#define v_BCSH_COS_HUE(x)		(((x)&0xff) << 8)
-
-	#define m_BCSH_SIN_HUE			(0xff << 0)
-	#define m_BCSH_COS_HUE			(0xff << 8)
-
-/* Bus Register */
-#define AXI_BUS_CTRL		(0x2C)
-	#define m_IO_PAD_CLK			(1 << 31)
-	#define m_CORE_CLK_DIV_EN		(1 << 30)
-	#define m_HDMI_DCLK_INVERT		(1 << 23)
-	#define m_HDMI_DCLK_EN			(1 << 22)
-	#define m_TVE_DAC_DCLK_INVERT		(1 << 21)
-	#define m_TVE_DAC_DCLK_EN		(1 << 20)
-	#define m_HDMI_DCLK_DIV_EN		(1 << 19)
-	#define m_AXI_OUTSTANDING_MAX_NUM	(0x1f << 12)
-	#define m_AXI_MAX_OUTSTANDING_EN	(1 << 11)
-	#define m_MMU_EN			(1 << 10)
-	#define m_NOC_HURRY_THRESHOLD		(0xf << 6)
-	#define m_NOC_HURRY_VALUE		(3 << 4)
-	#define m_NOC_HURRY_EN			(1 << 3)
-	#define m_NOC_QOS_VALUE			(3 << 1)
-	#define m_NOC_QOS_EN			(1 << 0)
-
-	#define v_IO_PAD_CLK(x)			((x&1) << 31)
-	#define v_CORE_CLK_DIV_EN(x)		((x&1) << 30)
-	#define v_HDMI_DCLK_INVERT(x)		((x&1) << 23)
-	#define v_HDMI_DCLK_EN(x)		((x&1) << 22)
-	#define v_TVE_DAC_DCLK_INVERT(x)	((x&1) << 21)
-	#define v_TVE_DAC_DCLK_EN(x)		((x&1) << 20)
-	#define v_HDMI_DCLK_DIV_EN(x)		((x&1) << 19)
-	#define v_AXI_OUTSTANDING_MAX_NUM(x)	((x&0x1f) << 12)
-	#define v_AXI_MAX_OUTSTANDING_EN(x)	((x&1) << 11)
-	#define v_MMU_EN(x)			((x&1) << 10)
-	#define v_NOC_HURRY_THRESHOLD(x)	((x&0xf) << 6)
-	#define v_NOC_HURRY_VALUE(x)		((x&3) << 4)
-	#define v_NOC_HURRY_EN(x)		((x&1) << 3)
-	#define v_NOC_QOS_VALUE(x)		((x&3) << 1)
-	#define v_NOC_QOS_EN(x)			((x&1) << 0)
-
-#define GATHER_TRANSFER		(0x84)
-	#define m_WIN1_AXI_GATHER_NUM		(0xf << 12)
-	#define m_WIN0_CBCR_AXI_GATHER_NUM	(0x7 << 8)
-	#define m_WIN0_YRGB_AXI_GATHER_NUM	(0xf << 4)
-	#define m_WIN1_AXI_GAHTER_EN		(1 << 2)
-	#define m_WIN0_CBCR_AXI_GATHER_EN	(1 << 1)
-	#define m_WIN0_YRGB_AXI_GATHER_EN	(1 << 0)
-
-	#define v_WIN1_AXI_GATHER_NUM(x)	((x & 0xf) << 12)
-	#define v_WIN0_CBCR_AXI_GATHER_NUM(x)	((x & 0x7) << 8)
-	#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	((x & 0xf) << 4)
-	#define v_WIN1_AXI_GAHTER_EN(x)		((x & 1) << 2)
-	#define v_WIN0_CBCR_AXI_GATHER_EN(x)	((x & 1) << 1)
-	#define v_WIN0_YRGB_AXI_GATHER_EN(x)	((x & 1) << 0)
-
-#define VERSION_INFO		(0x94)
-	#define m_MAJOR		(0xff << 24)
-	#define m_MINOR		(0xff << 16)
-	#define m_BUILD		(0xffff)
-
-#define REG_CFG_DONE		(0x90)
-
-/* TV Control Registers */
-#define TV_CTRL			(0x200)
-#define TV_SYNC_TIMING		(0x204)
-#define TV_ACT_TIMING		(0x208)
-#define TV_ADJ_TIMING		(0x20c)
-#define TV_FREQ_SC		(0x210)
-#define TV_FILTER0		(0x214)
-#define TV_FILTER1		(0x218)
-#define TV_FILTER2		(0x21C)
-#define TV_ACT_ST		(0x234)
-#define TV_ROUTING		(0x238)
-#define TV_SYNC_ADJUST		(0x250)
-#define TV_STATUS		(0x254)
-#define TV_RESET		(0x268)
-#define TV_SATURATION		(0x278)
-#define TV_BW_CTRL		(0x28C)
-#define TV_BRIGHTNESS_CONTRAST	(0x290)
-
-
-/* MMU registers */
-#define MMU_DTE_ADDR			(0x0300)
-	#define v_MMU_DTE_ADDR(x)		(((x)&0xffffffff)<<0)
-	#define m_MMU_DTE_ADDR			(0xffffffff<<0)
-
-#define MMU_STATUS			(0x0304)
-	#define v_PAGING_ENABLED(x)		(((x)&1)<<0)
-	#define v_PAGE_FAULT_ACTIVE(x)		(((x)&1)<<1)
-	#define v_STAIL_ACTIVE(x)		(((x)&1)<<2)
-	#define v_MMU_IDLE(x)			(((x)&1)<<3)
-	#define v_REPLAY_BUFFER_EMPTY(x)	(((x)&1)<<4)
-	#define v_PAGE_FAULT_IS_WRITE(x)	(((x)&1)<<5)
-	#define v_PAGE_FAULT_BUS_ID(x)		(((x)&0x1f)<<6)
-	#define m_PAGING_ENABLED		(1<<0)
-	#define m_PAGE_FAULT_ACTIVE		(1<<1)
-	#define m_STAIL_ACTIVE			(1<<2)
-	#define m_MMU_IDLE			(1<<3)
-	#define m_REPLAY_BUFFER_EMPTY		(1<<4)
-	#define m_PAGE_FAULT_IS_WRITE		(1<<5)
-	#define m_PAGE_FAULT_BUS_ID		(0x1f<<6)
-
-#define MMU_COMMAND			(0x0308)
-	#define v_MMU_CMD(x)			(((x)&0x3)<<0)
-	#define m_MMU_CMD			(0x3<<0)
-
-#define MMU_PAGE_FAULT_ADDR		(0x030c)
-	#define v_PAGE_FAULT_ADDR(x)		(((x)&0xffffffff)<<0)
-	#define m_PAGE_FAULT_ADDR		(0xffffffff<<0)
-
-#define MMU_ZAP_ONE_LINE		(0x0310)
-	#define v_MMU_ZAP_ONE_LINE(x)		(((x)&0xffffffff)<<0)
-	#define m_MMU_ZAP_ONE_LINE		(0xffffffff<<0)
-
-#define MMU_INT_RAWSTAT			(0x0314)
-	#define v_PAGE_FAULT_RAWSTAT(x)		(((x)&1)<<0)
-	#define v_READ_BUS_ERROR_RAWSTAT(x)	(((x)&1)<<1)
-	#define m_PAGE_FAULT_RAWSTAT		(1<<0)
-	#define m_READ_BUS_ERROR_RAWSTAT	(1<<1)
-
-#define MMU_INT_CLEAR			(0x0318)
-	#define v_PAGE_FAULT_CLEAR(x)		(((x)&1)<<0)
-	#define v_READ_BUS_ERROR_CLEAR(x)	(((x)&1)<<1)
-	#define m_PAGE_FAULT_CLEAR		(1<<0)
-	#define m_READ_BUS_ERROR_CLEAR		(1<<1)
-
-#define MMU_INT_MASK			(0x031c)
-	#define v_PAGE_FAULT_MASK(x)		(((x)&1)<<0)
-	#define v_READ_BUS_ERROR_MASK(x)	(((x)&1)<<1)
-	#define m_PAGE_FAULT_MASK		(1<<0)
-	#define m_READ_BUS_ERROR_MASK		(1<<1)
-
-#define MMU_INT_STATUS			(0x0320)
-	#define v_PAGE_FAULT_STATUS(x)		(((x)&1)<<0)
-	#define v_READ_BUS_ERROR_STATUS(x)	(((x)&1)<<1)
-	#define m_PAGE_FAULT_STATUS		(1<<0)
-	#define m_READ_BUS_ERROR_STATUS		(1<<1)
-
-#define MMU_AUTO_GATING			(0x0324)
-	#define v_MMU_AUTO_GATING(x)		(((x)&1)<<0)
-	#define m_MMU_AUTO_GATING		(1<<0)
-
-enum _vop_dma_burst {
-	DMA_BURST_16 = 0,
-	DMA_BURST_8,
-	DMA_BURST_4
-};
-
-enum _vop_format_e {
-	VOP_FORMAT_ARGB888 = 0,
-	VOP_FORMAT_RGB888,
-	VOP_FORMAT_RGB565,
-	VOP_FORMAT_YCBCR420 = 4,
-	VOP_FORMAT_YCBCR422,
-	VOP_FORMAT_YCBCR444
-};
-
-enum _vop_tv_mode {
-	TV_NTSC,
-	TV_PAL,
-};
-
-enum _vop_csc_mode {
-	VOP_CSC_BT601 = 0,
-	VOP_CSC_JPEG,
-	VOP_CSC_BT709
-};
-
-enum _vop_hwc_size {
-	VOP_HWC_SIZE_32,
-	VOP_HWC_SIZE_64
-};
-
-#define calscale(x, y)		((((u32)(x-1))*0x1000)/(y-1))
-
-struct lcdc_device {
-	int id;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;		/* back up reg */
-	u32 reg_phy_base;	/* physical basic address of lcdc register*/
-	u32 len;		/* physical map length of lcdc register*/
-	spinlock_t  reg_lock;	/* one time only one process allowed to
-				   config the register*/
-
-	int __iomem *hwc_lut_addr_base;
-	int __iomem *dsp_lut_addr_base;
-
-
-	int prop;			/*used for primary or */
-					/*extended display device*/
-	bool pre_init;
-	bool pwr18;			/*if lcdc use 1.8v power supply*/
-	bool clk_on;			/*if aclk or hclk is closed,
-					  acess to register is not allowed*/
-	u8 atv_layer_cnt;		/*active layer counter, when
-					  atv_layer_cnt = 0,disable lcdc*/
-
-	unsigned int		irq;
-
-	struct clk		*pd;	/*lcdc power domain*/
-	struct clk		*hclk;	/*lcdc AHP clk*/
-	struct clk		*dclk;	/*lcdc dclk*/
-	struct clk		*aclk;	/*lcdc share memory frequency*/
-	u32 pixclock;
-
-	u32 standby;			/*1:standby,0:work*/
-	u32 iommu_status;
-};
-
-static inline
-void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	*_pv = v;
-	writel_relaxed(v, lcdc_dev->regs + offset);
-}
-
-static inline
-u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	v = readl_relaxed(lcdc_dev->regs + offset);
-	*_pv = v;
-	return v;
-}
-
-static inline
-u32 lcdc_read_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
-{
-	u32 _v = readl_relaxed(lcdc_dev->regs + offset);
-
-	_v &= msk;
-	return _v ? 1 : 0;
-}
-
-static inline
-void  lcdc_set_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) |= msk;
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-}
-
-static inline
-void lcdc_clr_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~msk);
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-}
-
-static inline
-void  lcdc_msk_reg(struct lcdc_device *lcdc_dev, u32 offset, u32 msk, u32 v)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~msk);
-	(*_pv) |= v;
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-}
-
-static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev)
-{
-	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE);
-	dsb();
-}
-
-#endif /* _RK3036_LCDC_H_ */
diff --git a/drivers/video/rockchip/lcdc/rk3066b_lcdc.c b/drivers/video/rockchip/lcdc/rk3066b_lcdc.c
deleted file mode 100755
index 44fc4279a02c..000000000000
--- a/drivers/video/rockchip/lcdc/rk3066b_lcdc.c
+++ /dev/null
@@ -1,1519 +0,0 @@
-/*
- * drivers/video/rockchip/chips/rk3066b_lcdc.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *Author:yzq<yzq@rock-chips.com>
- *	yxj<yxj@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/earlysuspend.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include <mach/iomux.h>
-
-#include "rk3066b_lcdc.h"
-#include "../hdmi/rk_hdmi.h"
-
-
-
-
-static int dbg_thresd = 0;
-module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
-#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
-
-
-static int  rk3066b_lcdc_clk_enable(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	if(!lcdc_dev->clk_on)
-	{
-		clk_enable(lcdc_dev->hclk);
-		clk_enable(lcdc_dev->dclk);
-		clk_enable(lcdc_dev->aclk);
-		clk_enable(lcdc_dev->pd);
-
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	printk("rk3066b lcdc%d clk enable...\n",lcdc_dev->id);
-	
-	return 0;
-}
-
-static int rk3066b_lcdc_clk_disable(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	if(lcdc_dev->clk_on)
-	{
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		clk_disable(lcdc_dev->dclk);
-		clk_disable(lcdc_dev->hclk);
-		clk_disable(lcdc_dev->aclk);
-		clk_disable(lcdc_dev->pd);
-	}
-	printk("rk3066b lcdc%d clk disable...\n",lcdc_dev->id);
-	
-	return 0;
-}
-
-static int rk3066b_lcdc_reg_resume(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0x9C);
-	return 0;	
-}
-
-static int init_rk3066b_lcdc(struct rk_lcdc_device_driver *dev_drv)
-{
-	int i=0;
-	int __iomem *c;
-	int v;
-
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	
-	if(lcdc_dev->id == 0) //lcdc0
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
-	}
-	else if(lcdc_dev->id == 1)
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
-	}
-	else
-	{
-		printk(KERN_ERR "invalid lcdc device!\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
-    	{
-       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
-   	}
-
-	rk3066b_lcdc_clk_enable(lcdc_dev);
-	
-	if(lcdc_dev->id == 0)
-	{
-		#if defined(CONFIG_RK3066B_LCDC0_IO_18V)
-		v = 0x40004000;               //bit14: 1,1.8v;0,3.3v
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#else
-		v = 0x40000000;              
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#endif
-	}
-
-	if(lcdc_dev->id == 1) //iomux for lcdc1
-	{
-		#if defined(CONFIG_RK3066B_LCDC1_IO_18V)
-		v = 0x80008000;               //bit14: 1,1.8v;0,3.3v
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#else
-		v = 0x80000000;
-		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
-		#endif
-		
-		iomux_set(LCDC1_DCLK);
-		iomux_set(LCDC1_DEN);
-		iomux_set(LCDC1_HSYNC);
-		iomux_set(LCDC1_VSYNC);
-		iomux_set(LCDC1_D0);
-		iomux_set(LCDC1_D1);
-		iomux_set(LCDC1_D2);
-		iomux_set(LCDC1_D3);
-		iomux_set(LCDC1_D4);
-		iomux_set(LCDC1_D5);
-		iomux_set(LCDC1_D6);
-		iomux_set(LCDC1_D7);
-		iomux_set(LCDC1_D8);
-		iomux_set(LCDC1_D9);
-		iomux_set(LCDC1_D10);
-		iomux_set(LCDC1_D11);
-		iomux_set(LCDC1_D12);
-		iomux_set(LCDC1_D13);
-		iomux_set(LCDC1_D14);
-		iomux_set(LCDC1_D15);
-		iomux_set(LCDC1_D16);
-		iomux_set(LCDC1_D17);
-		iomux_set(LCDC1_D18);
-		iomux_set(LCDC1_D19);
-		iomux_set(LCDC1_D20);
-		iomux_set(LCDC1_D21);
-		iomux_set(LCDC1_D22);
-		iomux_set(LCDC1_D23);
-		
-	}
-	LcdMskReg(lcdc_dev,SYS_CFG, m_LCDC_AXICLK_AUTO_ENABLE | m_W0_AXI_OUTSTANDING2 |
-		m_W1_AXI_OUTSTANDING2,v_LCDC_AXICLK_AUTO_ENABLE(1) | v_W0_AXI_OUTSTANDING2(1) |
-		v_W1_AXI_OUTSTANDING2(1));//eanble axi-clk auto gating for low power
-	 LcdWrReg(lcdc_dev,AXI_MS_ID,v_HWC_CHANNEL_ID(5) | v_WIN2_CHANNEL_ID(4) |
-	 	v_WIN1_YRGB_CHANNEL_ID(3) | v_WIN0_CBR_CHANNEL_ID(2) | 
-	 	v_WIN0_YRGB_CHANNEL_ID(1));
-	LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
-    	      m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
-    	      v_SCANNING_MASK(1));  //mask all interrupt in init
-	LcdMskReg(lcdc_dev,FIFO_WATER_MARK,m_WIN1_FIFO_FULL_LEVEL,v_WIN1_FIFO_FULL_LEVEL(0x1e0));
-	//LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-	if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-	{
-		LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
-		LCDC_REG_CFG_DONE();
-
-		mdelay(25); //wait for dsp lut disabled
-		for(i=0;i<256;i++)
-		{
-			v = dev_drv->cur_screen->dsp_lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-		}
-		LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
-	}
-
-	rk3066b_lcdc_clk_disable(lcdc_dev);
-	return 0;
-}
-
-static int rk3066b_lcdc_deinit(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
-		LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
-    	      		  m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
-    	                  v_SCANNING_MASK(1));  //mask all interrupt in init
-		LcdSetBit(lcdc_dev,SYS_CFG,m_LCDC_STANDBY);
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	mdelay(1);
-	
-	return 0;
-}
-
-static int rk3066b_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	rk_screen *screen = dev_drv->cur_screen;
-	u64 ft;
-	int fps;
-	u16 face;
-	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
-	u16 right_margin = screen->right_margin;
-	u16 lower_margin = screen->lower_margin;
-	u16 x_res = screen->x_res, y_res = screen->y_res;
-
-	// set the rgb or mcu
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(screen->type==SCREEN_MCU)
-		{
-	    		LcdMskReg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
-			// set out format and mcu timing
-	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
-	    		if(mcu_total>31)    
-				mcu_total = 31;
-	   		if(mcu_total<3)    
-				mcu_total = 3;
-	    		mcu_rwstart = (mcu_total+1)/4 - 1;
-	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
-	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
-	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
-
-	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
-	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
-
-			// set horizontal & vertical out timing
-		
-		    	right_margin = x_res/6; 
-			screen->pixclock = 150000000; //mcu fix to 150 MHz
-			LcdMskReg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
-	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
-	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
-	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
-	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
-	
-		}
-
-		switch (screen->face)
-		{
-	        	case OUT_P565:
-	            		face = OUT_P565;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_P666:
-	            		face = OUT_P666;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_D888_P565:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_D888_P666:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_P888:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	default:
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		face = screen->face;
-	            		break;
-		}
-
-		//use default overlay,set vsyn hsync den dclk polarity
-		LcdMskReg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
-	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
-	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
-	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
-
-		//set background color to black,set swap according to the screen panel,disable blank mode
-		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE | m_BLACK_MODE | m_BG_COLOR, v_BLANK_MODE(0) | 
-					v_BLACK_MODE(0) | v_BG_COLOR(0x000000));
-		LcdMskReg(lcdc_dev,SWAP_CTRL,m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | m_DUMMY_SWAP, 
-					v_OUTPUT_RB_SWAP(screen->swap_rb) | v_OUTPUT_RG_SWAP(screen->swap_rg) | 
-		 			v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy));
-		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
-	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
-		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
-	             v_HASP(screen->hsync_len + screen->left_margin));
-
-		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
-	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
-		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
-	              v_VASP(screen->vsync_len + screen->upper_margin));
-		// let above to take effect
-		//LCDC_REG_CFG_DONE();
-	}
- 	spin_unlock(&lcdc_dev->reg_lock);
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-	if(ret)
-	{
-        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-	}
-    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-		(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps;
-    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
-
-    	if(screen->init)
-    	{
-    		screen->init();
-    	}
-	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
-	return 0;
-}
-
-static int mcu_refresh(struct rk3066b_lcdc_device *lcdc_dev)
-{
-   
-    return 0;
-}
-
-
-
-//enable layer,open:1,enable;0 disable
-static int win0_open(struct rk3066b_lcdc_device *lcdc_dev,bool open)
-{
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[0]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_EN, v_W0_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		//LCDC_REG_CFG_DONE();	
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-static int win1_open(struct rk3066b_lcdc_device *lcdc_dev,bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
-				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CFG, m_W1_EN, v_W1_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
-			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-
-
-static int rk3066b_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
-{
-	struct rk3066b_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk3066b_lcdc_device ,driver);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch(blank_mode)
-	    	{
-	    		case FB_BLANK_UNBLANK:
-	      			LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
-				break;
-	    		case FB_BLANK_NORMAL:
-	         		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-	    		default:
-				LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-		}
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	dev_info(lcdc_drv->dev,"blank mode:%d\n",blank_mode);
-	
-    	return 0;
-}
-
-static  int win0_display(struct rk3066b_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_YRGB_MST,y_addr);
-	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST,uv_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-	
-}
-
-static  int win1_display(struct rk3066b_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN1_YRGB_MST, y_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static  int win0_set_par(struct rk3066b_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg =0 ; //data format register config value
-	char fmt[9] = "NULL";
-	xact = par->xact;			    //active (origin) picture window width/height		
-	yact = par->yact;
-	xvir = par->xvir;			   // virtual resolution		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-   
-	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-	
-	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
-	ScaleYrgbY = CalScale(yact, par->ysize);
-	switch (par->format)
-	{
-		case XBGR888:
-		case ABGR888:
-		case ARGB888:
-			fmt_cfg = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 1;
-			break;
-		case YUV422:// yuv422
-			fmt_cfg = 2;
-			ScaleCbrX = CalScale((xact/2), par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		case YUV420: // yuv420
-			fmt_cfg = 3;
-			ScaleCbrX = CalScale(xact/2, par->xsize);
-		   	ScaleCbrY = CalScale(yact/2, par->ysize);
-		   	break;
-		case YUV444:// yuv444
-			fmt_cfg = 4;
-			ScaleCbrX = CalScale(xact, par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		default:
-			printk("%s:un supported format\n",__func__);
-		   break;
-	}
-
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
-		LcdMskReg(lcdc_dev,SYS_CFG, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
-		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
-		LcdMskReg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
-			v_COLORKEY_EN(0) | v_KEYCOLOR(0));
-		LcdWrReg(lcdc_dev,WIN0_VIR,v_VIRWIDTH(xvir));
-		//LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-    return 0;
-
-}
-
-static int win1_set_par(struct rk3066b_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u8 fmt_cfg;
-	char fmt[9]="NULL";
-	xact = par->xact;			
-	yact = par->yact;
-	xvir = par->xvir;		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-	
-	
-	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch (par->format)
-	 	{
-	 		case XBGR888:
-			case ABGR888:
-			case ARGB888:
-				fmt_cfg = 0;
-				break;
-			case RGB565:
-				fmt_cfg = 1;
-				break;
-			default:
-				printk("%s:un supported format\n",__func__);
-				break;
-		}
-
-		LcdMskReg(lcdc_dev,SYS_CFG, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
-		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
-		// enable win1 color key and set the color to black(rgb=0)
-		LcdMskReg(lcdc_dev,WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		LcdWrReg(lcdc_dev,WIN1_VIR,v_VIRWIDTH(xvir));
-		
-		//LCDC_REG_CFG_DONE(); 
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-    return 0;
-}
-
-static int rk3066b_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
-{
-	int i=0;
-	int __iomem *c;
-	int v;
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-
-	if((open) && (!lcdc_dev->atv_layer_cnt)) //enable clk,when first layer open
-	{
-		rk3066b_lcdc_clk_enable(lcdc_dev);
-		rk3066b_lcdc_reg_resume(lcdc_dev); //resume reg
-		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-		rk3066b_load_screen(dev_drv,1);
-		spin_lock(&lcdc_dev->reg_lock);
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-		{
-			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
-			LCDC_REG_CFG_DONE();
-
-			mdelay(25); //wait for dsp lut disabled
-			for(i=0;i<256;i++)
-			{
-				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
-			}
-			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	if(layer_id == 0)
-	{
-		win0_open(lcdc_dev,open);	
-	}
-	else if(layer_id == 1)
-	{
-		win1_open(lcdc_dev,open);
-	}
-	
-	if((!open) && (!lcdc_dev->atv_layer_cnt))  //when all layer closed,disable clk
-	{
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
-		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		LCDC_REG_CFG_DONE();
-		rk3066b_lcdc_clk_disable(lcdc_dev);
-	}
-	return 0;
-}
-
-static int rk3066b_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_set_par(lcdc_dev,screen,par);
-	}
-	
-	return 0;
-}
-
-int rk3066b_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	unsigned long flags;
-	int timeout;
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;	
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_display(lcdc_dev,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_display(lcdc_dev,par);
-	}
-	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
-	{
-		dev_drv->first_frame = 0;
-		LcdMskReg(lcdc_dev,INT_STATUS,m_HOR_STARTMASK | m_FRM_STARTMASK | m_SCANNING_MASK | 
-			m_HOR_STARTCLEAR | m_FRM_STARTCLEAR |m_SCANNING_CLEAR | m_SCAN_LINE_NUM,
-			  v_HOR_STARTMASK(1) | v_FRM_STARTMASK(0) | v_SCANNING_MASK(0) |
-			  v_HOR_STARTCLEAR(1) | v_FRM_STARTCLEAR(1) | v_SCANNING_CLEAR(1) |
-			  //v_SCANNING_CLEAR(screen->vsync_len + screen->upper_margin+screen->y_res -1));
-			  v_SCAN_LINE_NUM(screen->vsync_len + screen->upper_margin+screen->y_res -1));
-		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-		 
-	}
-
-#if 0
-	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
-	{
-		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
-		if(!timeout&&(!dev_drv->frame_done.done))
-		{
-			printk(KERN_ERR "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-#endif
-	
-	return 0;
-}
-
-int rk3066b_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	int ret = 0;
-	switch(cmd)
-	{
-		case RK_FBIOGET_PANEL_SIZE:    //get panel size
-                	panel_size[0] = lcdc_dev->screen->x_res;
-                	panel_size[1] = lcdc_dev->screen->y_res;
-            		if(copy_to_user(argp, panel_size, 8)) 
-				return -EFAULT;
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-static int rk3066b_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	struct layer_par *par = dev_drv->layer_par[layer_id];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(layer_id == 0)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W0_EN);
-		}
-		else if( layer_id == 1)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W1_EN);
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return par->state;
-	
-}
-
-/***********************************
-overlay manager
-swap:1 win0 on the top of win1
-        0 win1 on the top of win0
-set  : 1 set overlay 
-        0 get overlay state
-************************************/
-static int rk3066b_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(set)  //set overlay
-		{
-			LcdMskReg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
-			LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
-			LCDC_REG_CFG_DONE();
-			ovl = swap;
-		}
-		else  //get overlay
-		{
-			ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
-		}
-	}
-	else
-	{
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static ssize_t rk3066b_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
-
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	char format_w0[9]= "NULL";
-	char format_w1[9]= "NULL";
-	char status_w0[9]= "NULL";
-	char status_w1[9]= "NULL";
-	u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
-	u32 act_info,dsp_info,dsp_st,factor;
-	u16 xvir_w0,x_act_w0,y_act_w0,x_dsp_w0,y_dsp_w0,x_st_w0,y_st_w0;
-	u16 xvir_w1,x_dsp_w1,y_dsp_w1,x_st_w1,y_st_w1;
-	u16 x_scale,y_scale;
-	int ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
-
-        switch((fmt_id&m_W0_FORMAT)>>3)
-        {
-                case 0:
-                        strcpy(format_w0,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format_w0,"RGB565");
-                        break;
-                case 2:
-                        strcpy(format_w0,"YCbCr422");
-                        break;
-                case 3:
-                        strcpy(format_w0,"YCbCr420");
-                        break;
-                case 5:
-                        strcpy(format_w0,"YCbCr444");
-                        break;
-                default:
-                        strcpy(format_w0,"invalid\n");
-                        break;
-        }
-
-	 switch((fmt_id&m_W1_FORMAT)>>2)
-        {
-                case 0:
-                        strcpy(format_w1,"ARGB888");
-                        break;
-                case 1:
-                        strcpy(format_w1,"RGB565");
-                        break;
-                default:
-                        strcpy(format_w1,"invalid\n");
-                        break;
-        }
-
-	if((fmt_id&m_W0_EN)>>11)
-	{
-		strcpy(status_w0,"enabled");
-	}
-	else
-	{
-		strcpy(status_w0,"disabled");
-	}
-
-	if((fmt_id&m_W1_EN)>>10)
-	{
-		strcpy(status_w1,"enabled");
-	}
-	else
-	{
-		strcpy(status_w1,"disabled");
-	}
-
-	xvir_w0 = LcdRdReg(lcdc_dev,WIN0_VIR)&0xffff;
-	act_info = LcdRdReg(lcdc_dev,WIN0_ACT_INFO);
-	dsp_info = LcdRdReg(lcdc_dev,WIN0_DSP_INFO);
-	dsp_st = LcdRdReg(lcdc_dev,WIN0_DSP_ST);
-	factor = LcdRdReg(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
-	x_act_w0 =  (act_info&0xffff);
-	y_act_w0 = (act_info>>16);
-	x_dsp_w0 = (dsp_info&0x7ff);
-	y_dsp_w0 = (dsp_info>>16);
-	x_scale = 4096*100/(factor&0xffff);
-	y_scale = 4096*100/(factor>>16);
-	x_st_w0 = dsp_st&0xffff;
-	y_st_w0 = dsp_st>>16;
-
-	
-	xvir_w1 = LcdRdReg(lcdc_dev,WIN1_VIR)&0xffff;
-	dsp_info = LcdRdReg(lcdc_dev,WIN1_DSP_INFO);
-	dsp_st = LcdRdReg(lcdc_dev,WIN1_DSP_ST);
-	x_dsp_w1 = dsp_info&0x7ff;
-	y_dsp_w1 = dsp_info>>16;
-	x_st_w1 = dsp_st&0xffff;
-	y_st_w1 = dsp_st>>16;
-
-	return snprintf(buf,PAGE_SIZE,
-		"win0:%s\n"
-		"xvir:%d\n"
-		"xact:%d\n"
-		"yact:%d\n"
-		"xdsp:%d\n"
-		"ydsp:%d\n"
-		"x_st:%d\n"
-		"y_st:%d\n"
-		"x_scale:%d.%d\n"
-		"y_scale:%d.%d\n"
-		"format:%s\n"
-		"YRGB buffer addr:0x%08x\n"
-		"CBR buffer addr:0x%08x\n\n"
-		"win1:%s\n"
-		"xvir:%d\n"
-		"xdsp:%d\n"
-		"ydsp:%d\n"
-		"x_st:%d\n"
-		"y_st:%d\n"
-		"format:%s\n"
-		"YRGB buffer addr:0x%08x\n"
-		"overlay:%s\n",
-		status_w0,
-                xvir_w0,
-                x_act_w0,
-                y_act_w0,
-                x_dsp_w0,
-                y_dsp_w0,
-                x_st_w0,
-                y_st_w0,
-                x_scale/100,
-                x_scale%100,
-                y_scale/100,
-                y_scale%100,
-                format_w0,
-                LcdRdReg(lcdc_dev,WIN0_YRGB_MST),
-                LcdRdReg(lcdc_dev,WIN0_CBR_MST),
-                status_w1,
-                xvir_w1,
-                x_dsp_w1,
-                y_dsp_w1,
-                x_st_w1,
-                y_st_w1,
-                format_w1,
-                LcdRdReg(lcdc_dev,WIN1_YRGB_MST),
-                ovl ? "win0 on the top of win1\n":"win1 on the top of win0\n");
-        return 0;
-}
-
-
-/*******************************************
-lcdc fps manager,set or get lcdc fps
-set:0 get
-     1 set
-********************************************/
-static int rk3066b_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	rk_screen * screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-
-	if(set)
-	{
-		ft = div_u64(1000000000000llu,fps);
-		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
-		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-		}
-	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-			
-	}
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-	(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps ;  //one frame time in ms
-	return fps;
-}
-
-static int rk3066b_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
-        enum fb_win_map_order order)
-{
-        mutex_lock(&dev_drv->fb_win_id_mutex);
-	if(order == FB_DEFAULT_ORDER)
-	{
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-	}
-        dev_drv->fb2_win_id  = order/100;
-        dev_drv->fb1_win_id = (order/10)%10;
-        dev_drv->fb0_win_id = order%10;
-        mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-        printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
-                dev_drv->fb2_win_id);
-
-        return 0;
-}
-
-static int rk3066b_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
-{
-        int layer_id = 0;
-        mutex_lock(&dev_drv->fb_win_id_mutex);
-        if(!strcmp(id,"fb0") || !strcmp(id,"fb2"))
-        {
-                layer_id = dev_drv->fb0_win_id;
-        }
-        else if(!strcmp(id,"fb1") || !strcmp(id,"fb3"))
-        {
-                layer_id = dev_drv->fb1_win_id;
-        }
-        else
-        {
-                printk(KERN_ERR "%s>>un supported %s\n",__func__,id);
-                layer_id = -1;
-        }
-        mutex_unlock(&dev_drv->fb_win_id_mutex);
-	
-        return  layer_id;
-}
-
-
-static void rk3066b_lcdc_reg_dump(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	int *cbase =  (int *)lcdc_dev->reg_vir_base;
-	int i,j;
-	
-	for(i=0; i<=(0xa0>>4);i++)
-	{
-		for(j=0;j<4;j++)
-			printk("%08x  ",readl(cbase+i*4 +j));
-		printk("\n");
-	}
-	
-}
-
-int rk3066b_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(1);
-	if(dev_drv->screen_ctr_info->io_disable)
-		dev_drv->screen_ctr_info->io_disable();
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
-		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else  //clk already disabled
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	
-	rk3066b_lcdc_clk_disable(lcdc_dev);
-
-	return 0;
-}
-
-
-int rk3066b_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
-{  
-	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	int i=0;
-	int __iomem *c;
-	int v;
-
-	if(dev_drv->screen_ctr_info->io_enable) 		//power on
-		dev_drv->screen_ctr_info->io_enable();
-	
-	if(lcdc_dev->atv_layer_cnt) //only resume the lcdc that need to use
-	{
-	
-		rk3066b_lcdc_clk_enable(lcdc_dev);
-		mdelay(5);
-		memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0x24);  //resume reg ,skip INT_STATUS reg
-		memcpy(((u8*)lcdc_dev->preg) + 0x28,((u8*)&lcdc_dev->regbak) + 0x28, 0x74);
-
-		spin_lock(&lcdc_dev->reg_lock);
-
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-		{
-			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
-			LCDC_REG_CFG_DONE();
-
-			mdelay(25); //wait for dsp lut disabled
-			for(i=0;i<256;i++)
-			{
-				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
-			}
-			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
-		}
-		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-		LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR | m_FRM_STARTCLEAR | m_HOR_STARTCLEAR |
-					m_SCANNING_MASK | m_HOR_STARTMASK | m_FRM_STARTMASK , 
-					v_SCANNING_CLEAR(1) | v_FRM_STARTCLEAR(1) | v_HOR_STARTCLEAR(1) | 
-					v_SCANNING_MASK(0) | v_FRM_STARTMASK(0) | v_HOR_STARTMASK(1));
-		LCDC_REG_CFG_DONE();
-		
-		spin_unlock(&lcdc_dev->reg_lock);
-
-	}
-	
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(0);	      //screen wake up
-	
-    	return 0;
-}
-
-static int no_report(struct rk3066b_lcdc_device *lcdc_dev)
-{
-	struct rk_lcdc_device_driver *dev = &(lcdc_dev->driver);
-	static u32 lcdc0_old_addr = 0,cur_addr = 0;
-	static u32 mode = 0,num = 0;
-	static u32 cur_state = 0,old_state = 0;
-	
-	if(dev->screen_ctr_info->prop == PRMRY){
-		cur_addr = LcdRdReg(lcdc_dev,WIN0_YRGB_MST);
-		if(lcdc0_old_addr != cur_addr){
-			if(cur_state++ > 10000)
-				cur_state = 0;
-
-			lcdc0_old_addr = cur_addr;
-		}
-	}
-
-	if(old_state == cur_state){
-		if(num++>10 && mode != 0)
-			mode = 0;
-	}
-	else{
-		mode = 1;
-		num = 0;
-	}
-
-	if(mode == 1 && old_state == cur_state){
-		return -1;
-	}
-
-	old_state = cur_state;
-
-	return 0;
-}
-
-static irqreturn_t rk3066b_lcdc_isr(int irq, void *dev_id)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = (struct rk3066b_lcdc_device *)dev_id;
-
-	u32 int_reg = LcdRdReg(lcdc_dev,INT_STATUS);
-	if(int_reg & m_FRM_START){
-	ktime_t timestamp = ktime_get();
-	
-	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
-	
-#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
-	if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED){
-		if(no_report(lcdc_dev)){
-			return IRQ_HANDLED;
-		}
-	}
-#endif
-	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
-
-#if 0
-	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
-	{
-		spin_lock(&(lcdc_dev->driver.cpl_lock));
-		complete(&(lcdc_dev->driver.frame_done));
-		spin_unlock(&(lcdc_dev->driver.cpl_lock));
-	}
-#endif
-
-	lcdc_dev->driver.vsync_info.timestamp = timestamp;
-	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-	}
-	else if(int_reg & m_SCANNING_FLAG){
-		LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR, v_SCANNING_CLEAR(1));
-	}
-	return IRQ_HANDLED;
-}
-
-
-static int rk3066b_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
-{
-	int i=0;
-	int __iomem *c;
-	int v;
-	int ret = 0;
-
-	struct rk3066b_lcdc_device *lcdc_dev =
-				container_of(dev_drv,struct rk3066b_lcdc_device,driver);
-	LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
-	LCDC_REG_CFG_DONE();
-	msleep(25);
-	if(dev_drv->cur_screen->dsp_lut)
-	{
-		for(i=0;i<256;i++)
-		{
-			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-		}
-	}
-	else
-	{
-		dev_err(dev_drv->dev,"no buffer to backup lut data!\n");
-		ret =  -1;
-	}
-	LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));
-	LCDC_REG_CFG_DONE();
-
-	return ret;
-}
-
-int rk3066b_lcdc_poll_vblank(struct rk_lcdc_device_driver * dev_drv)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = 
-				container_of(dev_drv,struct rk3066b_lcdc_device,driver);    
-        u32 int_reg ;
-	int ret;
-	//spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		int_reg = LcdRdReg(lcdc_dev,INT_STATUS);
-	        if(int_reg & m_SCANNING_FLAG)
-	        {
-	              LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR,v_SCANNING_CLEAR(1));              
-	              ret =  RK_LF_STATUS_FC;
-	        }
-	        else
-	             ret = RK_LF_STATUS_FR;
-	}
-	else
-	{
-		ret = RK_LF_STATUS_NC;
-	}	
-	//spin_unlock(&lcdc_dev->reg_lock);
-
-
-	return ret;
-}
-
-static struct layer_par lcdc_layer[] = {
-	[0] = {
-		.name  		= "win0",
-		.id		= 0,
-		.support_3d	= true,
-	},
-	[1] = {
-		.name  		= "win1",
-		.id		= 1,
-		.support_3d	= false,
-	},
-};
-
-static struct rk_lcdc_device_driver lcdc_driver = {
-	.name			= "lcdc",
-	.def_layer_par		= lcdc_layer,
-	.num_layer		= ARRAY_SIZE(lcdc_layer),
-	.open			= rk3066b_lcdc_open,
-	.init_lcdc		= init_rk3066b_lcdc,
-	.ioctl			= rk3066b_lcdc_ioctl,
-	.suspend		= rk3066b_lcdc_early_suspend,
-	.resume			= rk3066b_lcdc_early_resume,
-	.set_par       		= rk3066b_lcdc_set_par,
-	.blank         		= rk3066b_lcdc_blank,
-	.pan_display            = rk3066b_lcdc_pan_display,
-	.load_screen		= rk3066b_load_screen,
-	.get_layer_state	= rk3066b_lcdc_get_layer_state,
-	.ovl_mgr		= rk3066b_lcdc_ovl_mgr,
-	.get_disp_info		= rk3066b_lcdc_get_disp_info,
-	.fps_mgr		= rk3066b_lcdc_fps_mgr,
-	.fb_get_layer           = rk3066b_fb_get_layer,
-	.fb_layer_remap         = rk3066b_fb_layer_remap,
-	.set_dsp_lut            = rk3066b_set_dsp_lut,
-	.poll_vblank		= rk3066b_lcdc_poll_vblank,
-};
-#ifdef CONFIG_PM
-static int rk3066b_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk3066b_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#else
-#define rk3066b_lcdc_suspend NULL
-#define rk3066b_lcdc_resume NULL
-#endif
-
-static int __devinit rk3066b_lcdc_probe (struct platform_device *pdev)
-{
-	struct rk3066b_lcdc_device *lcdc_dev=NULL;
-	rk_screen *screen;
-	rk_screen *screen1;
-	struct rk29fb_info *screen_ctr_info;
-	struct resource *res = NULL;
-	struct resource *mem;
-	int ret = 0;
-	
-	/*************Malloc rk3066blcdc_inf and set it to pdev for drvdata**********/
-	lcdc_dev = kzalloc(sizeof(struct rk3066b_lcdc_device), GFP_KERNEL);
-    	if(!lcdc_dev)
-    	{
-        	dev_err(&pdev->dev, ">>rk3066b lcdc device kmalloc fail!");
-        	return -ENOMEM;
-    	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->id = pdev->id;
-	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
-	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen)
-	{
-		dev_err(&pdev->dev, ">>rk3066b lcdc screen kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	else
-	{
-		lcdc_dev->screen = screen;
-	}
-	screen->lcdc_id = lcdc_dev->id;
-	screen->screen_id = 0;
-
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen1)
-	{
-		dev_err(&pdev->dev, ">>rk3066b lcdc screen1 kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	screen1->lcdc_id = 1;
-	screen1->screen_id = 1;
-	printk("use lcdc%d and rk610 implemention dual display!\n",lcdc_dev->id);
-	
-#endif
-	/****************get lcdc0 reg  *************************/
-	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
-	if (res == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-    	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
-    	if (mem == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
-	if (lcdc_dev->reg_vir_base == NULL)
-	{
-		dev_err(&pdev->dev, "cannot map IO\n");
-		ret = -ENXIO;
-		goto err2;
-	}
-	
-    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
-	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->reg_vir_base+DSP_LUT_ADDR);
-
-	lcdc_dev->driver.dev=&pdev->dev;
-	lcdc_dev->driver.screen0 = screen;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	lcdc_dev->driver.screen1 = screen1;
-#endif
-	lcdc_dev->driver.cur_screen = screen;
-	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
-	spin_lock_init(&lcdc_dev->reg_lock);
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if(lcdc_dev->irq < 0)
-	{
-		dev_err(&pdev->dev, "cannot find IRQ\n");
-		goto err3;
-	}
-	ret = request_irq(lcdc_dev->irq, rk3066b_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
-	if (ret)
-	{
-	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
-	       ret = -EBUSY;
-	       goto err3;
-	}
-
-	if(screen_ctr_info->set_screen_info)
-	{
-		screen_ctr_info->set_screen_info(screen,screen_ctr_info->lcd_info);
-		if(SCREEN_NULL==screen->type)
-		{
-			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-			ret = -ENODEV;
-		}
-		if(screen_ctr_info->io_init)
-			screen_ctr_info->io_init(NULL);
-	}
-	else
-	{
-		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-		ret =  -ENODEV;
-		goto err4;
-	}
-		
-	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
-		goto err4;
-	}
-	printk("rk3066b lcdc%d probe ok!\n",lcdc_dev->id);
-
-	return 0;
-
-err4:
-	free_irq(lcdc_dev->irq,lcdc_dev);
-err3:	
-	iounmap(lcdc_dev->reg_vir_base);
-err2:
-	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
-err1:
-	kfree(screen);
-err0:
-	platform_set_drvdata(pdev, NULL);
-	kfree(lcdc_dev);
-	return ret;
-    
-}
-static int __devexit rk3066b_lcdc_remove(struct platform_device *pdev)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk_fb_unregister(&(lcdc_dev->driver));
-	rk3066b_lcdc_deinit(lcdc_dev);
-	iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);
-	return 0;
-}
-
-static void rk3066b_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct rk3066b_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
-		lcdc_dev->driver.cur_screen->standby(1);
-	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
-		lcdc_dev->driver.screen_ctr_info->io_disable();
-	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds if necessary
-		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
-
-	rk3066b_lcdc_deinit(lcdc_dev);
-	//rk_fb_unregister(&(lcdc_dev->driver));
-	
-	/*iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);*/
-}
-
-
-static struct platform_driver rk3066b_lcdc_driver = {
-	.probe		= rk3066b_lcdc_probe,
-	.remove		= __devexit_p(rk3066b_lcdc_remove),
-	.driver		= {
-		.name	= "rk30-lcdc",
-		.owner	= THIS_MODULE,
-	},
-	.suspend	= rk3066b_lcdc_suspend,
-	.resume		= rk3066b_lcdc_resume,
-	.shutdown   	= rk3066b_lcdc_shutdown,
-};
-
-static int __init rk3066b_lcdc_init(void)
-{
-	return platform_driver_register(&rk3066b_lcdc_driver);
-}
-
-static void __exit rk3066b_lcdc_exit(void)
-{
-	platform_driver_unregister(&rk3066b_lcdc_driver);
-}
-
-
-
-fs_initcall(rk3066b_lcdc_init);
-module_exit(rk3066b_lcdc_exit);
-
-
-
diff --git a/drivers/video/rockchip/lcdc/rk3066b_lcdc.h b/drivers/video/rockchip/lcdc/rk3066b_lcdc.h
deleted file mode 100755
index 27c92470ad48..000000000000
--- a/drivers/video/rockchip/lcdc/rk3066b_lcdc.h
+++ /dev/null
@@ -1,558 +0,0 @@
-/* drivers/video/rockchip/chips/rk29_fb.h
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __RK3066B_LCDC_H
-#define __RK3066B_LCDC_H
-
-#include<linux/rk_fb.h>
-
-#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
-#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
-#define LcdRdReg(inf, addr)             (inf->preg->addr)
-#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
-#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
-#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
-#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
-#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
-
-
-/********************************************************************
-**                                                            *
-********************************************************************/
-/* SYS_CONFIG */
-#define m_W2_FORMAT          (3<<0)
-#define m_W1_FORMAT          (1<<2)
-#define m_W0_FORMAT          (7<<3)
-#define m_W0_CBR_DEFLICK_EN  (1<<6)
-#define m_W0_YRGB_DEFLICK_EN  (1<<7)
-#define m_INTERIACE_EN       (1<<8)
-#define m_W2_EN              (1<<9)
-#define m_W1_EN              (1<<10)
-#define m_W0_EN              (1<<11)
-#define m_HWC_EN              (1<<12)
-#define m_HWC_RELOAD_EN         (1<<13)
-#define m_W2_INTERLACE_READ    (1<<14)
-#define m_W1_INTERLACE_READ    (1<<15)
-#define m_W0_INTERLACE_READ    (1<<16)
-#define m_LCDC_STANDBY            (1<<17)
-#define m_HWC_BURST          (3<<18)
-#define m_W2_BURST           (3<<20)
-#define m_W1_BURST           (3<<22)
-#define m_W0_BURST           (3<<24)
-#define m_W2_LUT_CTL         (1<<26)
-#define m_DSIP_LUT_CTL       (1<<27)
-#define m_HWC_REVERSED_COLOR   (1<<28)
-#define m_W1_AXI_OUTSTANDING2     (1<<29)
-#define m_W0_AXI_OUTSTANDING2     (1<<30)
-#define m_LCDC_AXICLK_AUTO_ENABLE (1<<31)
-
-#define v_W2_FORMAT(x)         (((x)&3)<<0)
-#define v_W1_FORMAT(x)          (((x)&1)<<2)
-#define v_W0_FORMAT(x)          (((x)&7)<<3)
-#define v_W0_CBR_DEFLICK_EN(x)  (((x)&1)<<6)
-#define v_W0_YRGB_DEFLICK_EN(x)  (((x)&1)<<7)
-#define v_INTERIACE_EN(x)       (((x)&1)<<8)
-#define v_W2_EN(x)          (((x)&)1<<9)
-#define v_W1_EN(x)          (((x)&1)<<10)
-#define v_W0_EN(x)          (((x)&1)<<11)
-#define v_HWC_EN(x)         (((x)&1)<<12)
-#define v_HWC_RELOAD_EN(x)         (((x)&1)<<13)
-#define v_W2_INTERLACE_READ(x)    (((x)&1)<<14)
-#define v_W1_INTERLACE_READ(x)    (((x)&1)<<15)
-#define v_W0_INTERLACE_READ(x)    (((x)&1)<<16)
-#define v_LCDC_STANDBY(x)            (((x)&1)<<17)
-#define v_HWC_BURST(x)          (((x)&3)<<18)
-#define v_W2_BURST(x)           (((x)&3)<<20)
-#define v_W1_BURST(x)           (((x)&3)<<22)
-#define v_W0_BURST(x)           (((x)&3)<<24)
-#define v_W2_LUT_CTL(x)         (((x)&1)<<26)
-#define v_DSIP_LUT_CTL(x)       (((x)&1)<<27)
-#define v_HWC_REVERSED_COLOR(x)   (((x)&1)<<28)
-#define v_W1_AXI_OUTSTANDING2(x)     (((x)&1)<<29)
-#define v_W0_AXI_OUTSTANDING2(x)     (((x)&1)<<30)
-#define v_LCDC_AXICLK_AUTO_ENABLE(x)    (((x)&1)<<31)
-
-//LCDC_SWAP_CTRL
-#define m_W1_565_RB_SWAP        (1<<0)
-#define m_W0_565_RB_SWAP        (1<<1)
-#define m_W0_YRGB_M8_SWAP       (1<<2)
-#define m_W0_YRGB_R_SHIFT_SWAP  (1<<3)
-#define m_W0_CBR_R_SHIFT_SWAP   (1<<4)
-#define m_W0_YRGB_16_SWAP       (1<<5)
-#define m_W0_YRGB_8_SWAP        (1<<6)
-#define m_W0_CBR_16_SWAP        (1<<7)
-#define m_W0_CBR_8_SWAP         (1<<8)
-#define m_W1_16_SWAP            (1<<9)
-#define m_W1_8_SWAP             (1<<10)
-#define m_W1_R_SHIFT_SWAP       (1<<11)
-#define m_OUTPUT_BG_SWAP        (1<<12)
-#define m_OUTPUT_RB_SWAP        (1<<13)
-#define m_OUTPUT_RG_SWAP        (1<<14)
-#define m_DELTA_SWAP            (1<<15)
-#define m_DUMMY_SWAP            (1<<16)
-#define m_W2_BYTE_SWAP          (1<<17)
-#define v_W1_565_RB_SWAP(x)        (((x)&1)<<0)
-#define v_W0_565_RB_SWAP(x)        (((x)&1)<<1)
-#define v_W0_YRGB_M8_SWAP(x)       (((x)&1)<<2)
-#define v_W0_YRGB_R_SHIFT_SWAP(x)  (((x)&1)<<3)
-#define v_W0_CBR_R_SHIFT_SWAP(x)   (((x)&1)<<4)
-#define v_W0_YRGB_16_SWAP(x)       (((x)&1)<<5)
-#define v_W0_YRGB_8_SWAP(x)        (((x)&1)<<6)
-#define v_W0_CBR_16_SWAP(x)        (((x)&1)<<7)
-#define v_W0_CBR_8_SWAP(x)         (((x)&1)<<8)
-#define v_W1_16_SWAP(x)            (((x)&1)<<9)
-#define v_W1_8_SWAP(x)             (((x)&1)<<10)
-#define v_W1_R_SHIFT_SWAP(x)       (((x)&1)<<11)
-#define v_OUTPUT_BG_SWAP(x)        (((x)&1)<<12)
-#define v_OUTPUT_RB_SWAP(x)        (((x)&1)<<13)
-#define v_OUTPUT_RG_SWAP(x)        (((x)&1)<<14)
-#define v_DELTA_SWAP(x)            (((x)&1)<<15)
-#define v_DUMMY_SWAP(x)            (((x)&1)<<16)
-#define v_W2_BYTE_SWAP(x)      (((x)&1)<<17)
-
-//LCDC_MCU_TIMING_CTRL
-#define m_MCU_WRITE_PERIOD      (31<<0)
-#define m_MCU_CS_ST             (31<<5)
-#define m_MCU_CS_END            (31<<10)
-#define m_MCU_RW_ST             (31<<15)
-#define m_MCU_RW_END            (31<<20)
-#define m_MCU_HOLDMODE_SELECT     (1<<27)
-#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
-#define m_MCU_RS_SELECT            (1<<29)
-#define m_MCU_BYPASSMODE_SELECT   (1<<30)
-#define m_MCU_OUTPUT_SELECT        (1<<31)
-#define v_MCU_WRITE_PERIOD(x)      (((x)&31)<<0)
-#define v_MCU_CS_ST(x)          (((x)&31)<<5)
-#define v_MCU_CS_END(x)         (((x)&31)<<10)
-#define v_MCU_RW_ST(x)          (((x)&31)<<15)
-#define v_MCU_RW_END(x)         (((x)&31)<<20)
-#define v_MCU_HOLD_STATUS(x)          (((x)&1)<<26)
-#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
-#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
-#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
-#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
-#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
-
-//LCDC_ BLEND_CTRL
-#define m_HWC_BLEND_EN         (1<<0)
-#define m_W2_BLEND_EN          (1<<1)
-#define m_W1_BLEND_EN          (1<<2)
-#define m_W0_BLEND_EN          (1<<3)
-#define m_HWC_BLEND_FACTOR     (15<<4)
-#define m_W2_BLEND_FACTOR     (0xff<<8)
-#define m_W1_BLEND_FACTOR     (0xff<<16)
-#define m_W0_BLEND_FACTOR     (0xff<<24)
-
-#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
-#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
-#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
-#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
-#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
-#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
-#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
-#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
-
-
-//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
-#define m_KEYCOLOR          (0xffffff<<0)
-#define m_KEYCOLOR_B          (0xff<<0)
-#define m_KEYCOLOR_G          (0xff<<8)
-#define m_KEYCOLOR_R          (0xff<<16)
-#define m_COLORKEY_EN         (1<<24)
-#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
-#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
-#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
-#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
-#define v_COLORKEY_EN(x)         (((x)&1)<<24)
-
-//LCDC_DEFLICKER_SCL_OFFSET
-#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
-#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
-#define m_W1_VSD_OFFSET           (0xff<<16)
-#define m_W1_VSP_OFFSET           (0xff<<24)
-#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
-#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
-#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
-#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
-
-//LCDC_DSP_CTRL_REG0
-#define m_DISPLAY_FORMAT             (0xf<<0)
-#define m_HSYNC_POLARITY             (1<<4)
-#define m_VSYNC_POLARITY             (1<<5)
-#define m_DEN_POLARITY               (1<<6)
-#define m_DCLK_POLARITY              (1<<7)
-#define m_COLOR_SPACE_CONVERSION     (3<<8)
-#define m_DITHER_UP_EN               (1<<10)
-#define m_DITHER_DOWN_MODE           (1<<11)
-#define m_DITHER_DOWN_EN             (1<<12)
-#define m_INTERLACE_FIELD_POLARITY   (1<<13)
-#define m_YUV_CLIP                   (1<<14)
-#define m_W1_TRANSP_FROM             (1<<15)
-#define m_W0_TRANSP_FROM             (1<<16)
-#define m_W0W1_POSITION_SWAP         (1<<17)
-#define m_W1_CLIP_EN                 (1<<18)
-#define m_W0_CLIP_EN                 (1<<19)
-#define m_W0_YCBR_PRIORITY_MODE      (1<<20)
-#define m_CBR_FILTER_656             (1<<21)
-#define m_W2_CHIP_EN                 (1<<22)
-
-#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
-#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
-#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
-#define v_DEN_POLARITY(x)               (((x)&1)<<6)
-#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
-#define v_COLOR_SPACE_CONVERSION(x)     (((x)&3)<<8)
-#define v_DITHER_UP_EN(x)               (((x)&1)<<10)
-#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<11)
-#define v_DITHER_DOWN_EN(x)             (((x)&1)<<12)
-#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
-#define v_YUV_CLIP(x)                   (((x)&1)<<14)
-#define v_W1_TRANSP_FROM(x)             (((x)&1)<<15)
-#define v_W0_TRANSP_FROM(x)             (((x)&1)<<16)
-#define v_W0W1_POSITION_SWAP(x)         (((x)&1)<<17)
-#define v_W1_CLIP_EN(x)                 (((x)&1)<<18)
-#define v_W0_CLIP_EN(x)                 (((x)&1)<<19)
-#define v_W0_YCBR_PRIORITY_MODE(x)      (((x)&1)<<20)
-#define v_CBR_FILTER_656(x)             (((x)&1)<<21)
-#define v_W2_CHIP_EN(x)                 (((x)&1)<<22)
-
-
-//LCDC_DSP_CTRL_REG1
-#define m_BG_COLOR                    (0xffffff<<0)
-#define m_BG_B                        (0xff<<0)
-#define m_BG_G                        (0xff<<8)
-#define m_BG_R                        (0xff<<16)
-#define m_BLANK_MODE                  (1<<24)
-#define m_BLACK_MODE                  (1<<25)
-#define m_DISP_FILTER_FACTOR          (3<<26)
-#define m_DISP_FILTER_MODE            (1<<28)
-#define m_DISP_FILTER_EN              (1<<29)
-#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
-#define v_BG_B(x)                     (((x)&0xff)<<0)
-#define v_BG_G(x)                     (((x)&0xff)<<8)
-#define v_BG_R(x)                     (((x)&0xff)<<16)
-#define v_BLANK_MODE(x)               (((x)&1)<<24)
-#define v_BLACK_MODE(x)               (((x)&1)<<25)
-#define v_DISP_FILTER_FACTOR(x)       (((x)&3)<<26)
-#define v_DISP_FILTER_MODE(x)         (((x)&1)<<28)
-#define v_DISP_FILTER_EN(x)           (((x)&1)<<29)
-
-//LCDC_INT_STATUS
-#define m_HOR_START         (1<<0)
-#define m_FRM_START         (1<<1)
-#define m_SCANNING_FLAG     (1<<2)
-#define m_HOR_STARTMASK     (1<<3)
-#define m_FRM_STARTMASK     (1<<4)
-#define m_SCANNING_MASK     (1<<5)
-#define m_HOR_STARTCLEAR    (1<<6)
-#define m_FRM_STARTCLEAR    (1<<7)
-#define m_SCANNING_CLEAR    (1<<8)
-#define m_SCAN_LINE_NUM     (0x7ff<<9)
-#define v_HOR_START(x)         (((x)&1)<<0)
-#define v_FRM_START(x)         (((x)&1)<<1)
-#define v_SCANNING_FLAG(x)     (((x)&1)<<2)
-#define v_HOR_STARTMASK(x)     (((x)&1)<<3)
-#define v_FRM_STARTMASK(x)     (((x)&1)<<4)
-#define v_SCANNING_MASK(x)     (((x)&1)<<5)
-#define v_HOR_STARTCLEAR(x)    (((x)&1)<<6)
-#define v_FRM_STARTCLEAR(x)    (((x)&1)<<7)
-#define v_SCANNING_CLEAR(x)    (((x)&1)<<8)
-#define v_SCAN_LINE_NUM(x)     (((x)&0x7ff)<<9)
-
-//AXI MS ID
-#define m_W0_YRGB_CH_ID        (0xF<<0)
-#define m_W0_CBR_CH_ID         (0xF<<4)
-#define m_W1_YRGB_CH_ID        (0xF<<8)
-#define m_W2_CH_ID             (0xF<<12)
-#define m_HWC_CH_ID            (0xF<<16)
-#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
-#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
-#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
-#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
-#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
-
-
-/* Low Bits Mask */
-#define m_WORDLO            (0xffff<<0)
-#define m_WORDHI            (0xffff<<16)
-#define v_WORDLO(x)         (((x)&0xffff)<<0)
-#define v_WORDHI(x)         (((x)&0xffff)<<16)
-
-#define m_BIT11LO           (0x7ff<<0)
-#define m_BIT11HI           (0x7ff<<16)
-#define v_BIT11LO(x)        (((x)&0x7ff)<<0)
-#define v_BIT11HI(x)        (((x)&0x7ff)<<16)
-
-#define m_BIT12LO           (0xfff<<0)
-#define m_BIT12HI           (0xfff<<16)
-#define v_BIT12LO(x)        (((x)&0xfff)<<0)
-#define v_BIT12HI(x)        (((x)&0xfff)<<16)
-
-
-#define m_VIRWIDTH       (0xffff<<0)
-#define m_VIRHEIGHT      (0xffff<<16)
-#define v_VIRWIDTH(x)       (((x)&0xffff)<<0)
-#define v_VIRHEIGHT(x)      (((x)&0xffff)<<16)
-
-#define m_ACTWIDTH       (0xffff<<0)
-#define m_ACTHEIGHT      (0xffff<<16)
-#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
-#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
-
-#define m_VIRST_X      (0xffff<<0)
-#define m_VIRST_Y      (0xffff<<16)
-#define v_VIRST_X(x)      (((x)&0xffff)<<0)
-#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
-
-#define m_PANELST_X      (0x3ff<<0)
-#define m_PANELST_Y      (0x3ff<<16)
-#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
-#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
-
-#define m_PANELWIDTH       (0x3ff<<0)
-#define m_PANELHEIGHT      (0x3ff<<16)
-#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
-#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
-
-#define m_HWC_B                 (0xff<<0)
-#define m_HWC_G                 (0xff<<8)
-#define m_HWC_R                 (0xff<<16)
-#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
-#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
-#define v_HWC_B(x)                 (((x)&0xff)<<0)
-#define v_HWC_G(x)                 (((x)&0xff)<<8)
-#define v_HWC_R(x)                 (((x)&0xff)<<16)
-#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
-#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
-
-
-//Panel display scanning
-#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
-
-#define m_PANEL_END              (0x3ff<<0)
-#define m_PANEL_START            (0x3ff<<16)
-#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
-#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
-
-#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
-//-----------
-
-#define m_HSCALE_FACTOR        (0xffff<<0)
-#define m_VSCALE_FACTOR        (0xffff<<16)
-#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
-#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
-
-#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
-#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
-#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
-#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
-#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
-#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
-#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
-#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
-
-
-#define m_WIN1_FIFO_FULL_LEVEL 		(0x7f << 0)
-#define m_WIN2_FIFO_FULL_LEVEL 		(0x1f << 7)
-#define v_WIN1_FIFO_FULL_LEVEL(x)	(((x)&0x7f) << 0)
-#define v_WIN2_FIFO_FULL_LEVEL(x)	(((x)&0x1f) << 7)
-
-
-#define m_WIN0_YRGB_CHANNEL_ID	      	((0x0f)<<0)
-#define m_WIN0_CBR_CHANNEL_ID	      	((0x0f)<<4)
-#define m_WIN1_YRGB_CHANNEL_ID	      	((0x0f)<<8)
-#define m_WIN2_CHANNEL_ID	      	((0x0f)<<12)
-#define m_HWC_CHANNEL_ID	      	((0x0f)<<16)
-#define v_WIN0_YRGB_CHANNEL_ID(x)	(((x)&0x0f)<<0)
-#define v_WIN0_CBR_CHANNEL_ID(x)	(((x)&0x0f)<<4)
-#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&0x0f)<<8)
-#define v_WIN2_CHANNEL_ID(x)	      	(((x)&0x0f)<<12)
-#define v_HWC_CHANNEL_ID(x)	      	(((x)&0x0f)<<16)
-
-
-//LCDC_WINx_SCL_FACTOR_Y/CBCR
-#define v_X_SCL_FACTOR(x)  ((x)<<0)
-#define v_Y_SCL_FACTOR(x)  ((x)<<16)
-
-//LCDC_DSP_HTOTAL_HS_END
-#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
-#define v_HORPRD(x) ((x)<<16)   //horizontal period
-
-
-//LCDC_DSP_HACT_ST_END
-#define v_HAEP(x) ((x)<<0)  //horizontal active end point
-#define v_HASP(x) ((x)<<16) //horizontal active start point
-
-//LCDC_DSP_VTOTAL_VS_END
-#define v_VSYNC(x) ((x)<<0)
-#define v_VERPRD(x) ((x)<<16)
-
-//LCDC_DSP_VACT_ST_END
-#define v_VAEP(x) ((x)<<0)
-#define v_VASP(x) ((x)<<16)
-
-//LCDC_WIN0_ACT_INFO
-#define v_ACT_WIDTH(x)     ((x)<<0)
-#define v_ACT_HEIGHT(x)    ((x)<<16)
-
-//LCDC_WIN0_DSP_INFO
-#define v_DSP_WIDTH(x)     ((x)<<0)
-#define v_DSP_HEIGHT(x)    ((x)<<16)
-
-//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
-#define v_DSP_STX(x)      (x<<0)
-#define v_DSP_STY(x)      (x<<16)
-
-
-/********************************************************************
-**                                                          *
-********************************************************************/
-/* LCDC */
-
-typedef volatile struct tagLCDC_REG
-{
-    /* offset 0x00~0xc0 */
-    unsigned int SYS_CFG;              //0x00 SYSTEM configure register
-    unsigned int SWAP_CTRL;               //0x04 Data SWAP control
-    unsigned int MCU_CTRL;         //0x08 MCU TIMING control register
-    unsigned int BLEND_CTRL;              //0x0c Blending control register
-    unsigned int WIN0_COLOR_KEY_CTRL;     //0x10 Win0 blending control register
-    unsigned int WIN1_COLOR_KEY_CTRL;     //0x14 Win1 blending control register
-    unsigned int WIN2_VIR;                //0x18 WIN2 virtual display width
-    unsigned int DSP_CTRL0;               //0x1c Display control register0
-    unsigned int DSP_CTRL1;               //0x20 Display control register1
-    unsigned int INT_STATUS;              //0x24 Interrupt status register
-    unsigned int WIN0_VIR;                //0x28 WIN0 virtual display width/height
-    unsigned int WIN0_YRGB_MST;           //0x2c Win0 active YRGB memory start address
-    unsigned int WIN0_CBR_MST;            //0x30 Win0 active Cbr memory start address
-    unsigned int WIN0_ACT_INFO;           //0x34 Win0 active window width/height
-    unsigned int WIN0_DSP_ST;             //0x38 Win0 display start point on panel
-    unsigned int WIN0_DSP_INFO;           //0x3c Win0 display width/height on panel
-    unsigned int WIN1_VIR;                //0x40 Win1 virtual display width/height
-    unsigned int WIN1_YRGB_MST;           //0x44 Win1 active  memory start address
-    unsigned int WIN1_DSP_INFO;           //0x48 Win1 display width/height on panel
-    unsigned int WIN1_DSP_ST;             //0x4c Win1 display start point on panel
-    unsigned int WIN2_MST;                //0X50 Win2 memory start address
-    unsigned int WIN2_DSP_INFO;           //0x54 Win1 display width/height on panel
-    unsigned int WIN2_DSP_ST;             //0x58 Win1 display start point on panel
-    unsigned int HWC_MST;                 //0x5C HWC memory start address
-    unsigned int HWC_DSP_ST;              //0x60 HWC display start point on panel
-    unsigned int HWC_COLOR_LUT0;          //0x64 Hardware cursor color 2b01 look up table 0
-    unsigned int HWC_COLOR_LUT1;          //0x68 Hardware cursor color 2b10 look up table 1
-    unsigned int HWC_COLOR_LUT2;          //0x6c Hardware cursor color 2b11 look up table 2
-    unsigned int DSP_HTOTAL_HS_END;       //0x70 Panel scanning horizontal width and hsync pulse end point
-    unsigned int DSP_HACT_ST_END;         //0x74 Panel active horizontal scanning start/end point
-    unsigned int DSP_VTOTAL_VS_END;       //0x78 Panel scanning vertical height and vsync pulse end point
-    unsigned int DSP_VACT_ST_END;         //0x7c Panel active vertical scanning start/end point
-    unsigned int DSP_VS_ST_END_F1;        //0x80 Vertical scanning start point and vsync pulse end point of even filed in interlace mode
-    unsigned int DSP_VACT_ST_END_F1;      //0x84 Vertical scanning active start/end point of even filed in interlace mode
-    unsigned int WIN0_SCL_FACTOR_YRGB;    //0x88 Win0 YRGB scaling down factor setting
-    unsigned int WIN0_SCL_FACTOR_CBR;     //0x8c Win0 YRGB scaling up factor setting
-    unsigned int WIN0_SCL_OFFSET;         //0x90 Win0 Cbr scaling start point offset
-    unsigned int FIFO_WATER_MARK;         //0x94 Fifo water mark
-    unsigned int AXI_MS_ID;               //0x98 Axi master ID
-    unsigned int reserved0;               //0x9c
-    unsigned int REG_CFG_DONE;            //0xa0 REGISTER CONFIG FINISH
-    unsigned int reserved1[(0x100-0xa4)/4];
-    unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
-    unsigned int reserved2[(0x200-0x104)/4];
-    unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port
-} LCDC_REG, *pLCDC_REG;
-
-#define Win2_LUT_ADDR 0x400
-#define DSP_LUT_ADDR  0x800
-
-//roate
-#define 	ROTATE_0		0
-#define 	ROTATE_90		90
-#define 	ROTATE_180		180
-#define 	ROTATE_270		270
-#define 	X_MIRROR		(1<<10)
-#define		Y_MIRROR		(1<<11)
-
-
-
-
-#define CalScale(x, y)	             (((u32)x*0x1000)/y)
-struct rk3066b_lcdc_device{
-	int id;
-	struct rk_lcdc_device_driver driver;
-	rk_screen *screen;
-	
-	LCDC_REG *preg;         // LCDC reg base address and backup reg 
-    	LCDC_REG regbak;
-
-	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
-	u32 reg_phy_base;       	// physical basic address of lcdc register
-	u32 len;               		// physical map length of lcdc register
-	spinlock_t  reg_lock;		//one time only one process allowed to config the register
-	int __iomem *dsp_lut_addr_base;
-	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
-	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
-
-	unsigned int		irq;
-
-	struct clk		*pd;				//lcdc power domain
-	struct clk		*hclk;				//lcdc AHP clk
-	struct clk		*dclk;				//lcdc dclk
-	struct clk		*aclk;				//lcdc share memory frequency
-	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
-	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
-	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
-	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
-	struct clk		*pd_display;		// display power domain
-	u32	pixclock;
-};
-
-struct lcdc_info{
-/*LCD CLK*/
-	struct rk3066b_lcdc_device lcdc0;
-	struct rk3066b_lcdc_device lcdc1;
-
-};
-
-
-struct win_set {
-	volatile u32 y_offset;
-	volatile u32 c_offset;
-};
-
-struct win0_par {
-    u32 refcount;
-    u32	pseudo_pal[16];
-    u32 y_offset;
-    u32 c_offset;
-    u32 xpos;         //size in panel
-    u32 ypos;
-    u32 xsize;        //start point in panel
-    u32 ysize;
-    enum data_format format;
-
-    wait_queue_head_t wait;
-    struct win_set mirror;
-    struct win_set displ;
-    struct win_set done;
-
-    u8 par_seted;
-    u8 addr_seted;
-};
-
-#endif
diff --git a/drivers/video/rockchip/lcdc/rk30_lcdc.c b/drivers/video/rockchip/lcdc/rk30_lcdc.c
deleted file mode 100755
index 7b7b79010d8d..000000000000
--- a/drivers/video/rockchip/lcdc/rk30_lcdc.c
+++ /dev/null
@@ -1,1748 +0,0 @@
-/*
- * drivers/video/rockchip/chips/rk30_lcdc.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *Author:yzq<yzq@rock-chips.com>
- *	yxj<yxj@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/earlysuspend.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include "rk30_lcdc.h"
-
-
-
-static int dbg_thresd = 0;
-module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
-#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
-
-
-static int  rk30_lcdc_clk_enable(struct rk30_lcdc_device *lcdc_dev)
-{
-	if(!lcdc_dev->clk_on)
-	{
-		clk_enable(lcdc_dev->pd);
-		clk_enable(lcdc_dev->hclk);
-		clk_enable(lcdc_dev->dclk);
-		clk_enable(lcdc_dev->aclk);
-	
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	printk("rk30 lcdc%d clk enable...\n",lcdc_dev->id);
-	
-	return 0;
-}
-
-static int rk30_lcdc_clk_disable(struct rk30_lcdc_device *lcdc_dev)
-{
-	if(lcdc_dev->clk_on)
-	{
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(30);
-		clk_disable(lcdc_dev->dclk);
-		clk_disable(lcdc_dev->hclk);
-		clk_disable(lcdc_dev->aclk);
-		clk_disable(lcdc_dev->pd);
-	}
-	printk("rk30 lcdc%d clk disable...\n",lcdc_dev->id);
-	return 0;
-}
-
-static int rk30_lcdc_read_reg_defalut_cfg(struct rk30_lcdc_device *lcdc_dev)
-{
-	int reg = 0;
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		for(reg=SYS_CTRL0;reg<=DSP_VACT_ST_END_F1; reg +=4)
-		{
-			lcdc_readl(lcdc_dev,reg);
-		}
-		
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		
-	}
-
-	return 0;
-}
-static int rk30_lcdc_init(struct rk_lcdc_device_driver *dev_drv)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	if(lcdc_dev->id == 0) //lcdc0
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
-	}
-	else if(lcdc_dev->id == 1)
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
-	}
-	else
-	{
-		printk(KERN_ERR "invalid lcdc device!\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
-    	{
-       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
-   	}
-	
-	rk30_lcdc_clk_enable(lcdc_dev);
-	rk30_lcdc_read_reg_defalut_cfg(lcdc_dev);
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL0,m_HWC_CHANNEL_ID | m_WIN2_CHANNEL_ID | m_WIN1_CBR_CHANNEL_ID |
-		m_WIN1_YRGB_CHANNEL_ID | m_WIN0_CBR_CHANNEL1_ID | m_WIN0_YRGB_CHANNEL1_ID | 
-		m_WIN0_CBR_CHANNEL0_ID | m_WIN0_YRGB_CHANNEL0_ID,v_HWC_CHANNEL_ID(7) | 
-		v_WIN2_CHANNEL_ID(6) | v_WIN1_CBR_CHANNEL_ID(5) | v_WIN1_YRGB_CHANNEL_ID(4) | 
-		v_WIN0_CBR_CHANNEL1_ID(3) | v_WIN0_YRGB_CHANNEL1_ID(2) | v_WIN0_CBR_CHANNEL0_ID(1) |
-		v_WIN0_YRGB_CHANNEL0_ID(0));			//channel id ,just use default value
-	lcdc_writel(lcdc_dev,WIN0_SCL_FACTOR_YRGB,0x10001000);
-	lcdc_writel(lcdc_dev,WIN1_SCL_FACTOR_YRGB,0x10001000);
-	lcdc_set_bit(lcdc_dev,DSP_CTRL0, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
-	lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
-              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
-              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
-              
-        if(dev_drv->cur_screen->dsp_lut)
-        {
-        	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-		msleep(25);
-		for(i=0;i<256;i++)
-		{
-			v = dev_drv->cur_screen->dsp_lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-			
-		}
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
-        }
-	
-	lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
-
-	rk30_lcdc_clk_disable(lcdc_dev);
-	
-	return 0;
-}
-
-static int rk30_lcdc_deinit(struct rk30_lcdc_device *lcdc_dev)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
-			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
-			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
-		lcdc_set_bit(lcdc_dev,SYS_CTRL0,m_LCDC_STANDBY);
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	mdelay(1);
-	
-	return 0;
-}
-
-static int rk30_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	rk_screen *screen = dev_drv->cur_screen;
-	u64 ft;
-	int fps;
-	u16 face;
-	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
-	u16 right_margin = screen->right_margin;
-	u16 lower_margin = screen->lower_margin;
-	u16 x_res = screen->x_res, y_res = screen->y_res;
-
-	
-	// set the rgb or mcu
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(screen->type==SCREEN_MCU)
-		{
-	    		lcdc_msk_reg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
-			// set out format and mcu timing
-	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
-	    		if(mcu_total>31)    
-				mcu_total = 31;
-	   		if(mcu_total<3)    
-				mcu_total = 3;
-	    		mcu_rwstart = (mcu_total+1)/4 - 1;
-	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
-	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
-	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
-
-	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
-	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
-
-			// set horizontal & vertical out timing
-		
-		    	right_margin = x_res/6; 
-			screen->pixclock = 150000000; //mcu fix to 150 MHz
-			lcdc_msk_reg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
-	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
-	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
-	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
-	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
-	
-		}
-
-		switch (screen->face)
-		{
-	        	case OUT_P565:
-	            		face = OUT_P565;
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_P666:
-	            		face = OUT_P666;
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_D888_P565:
-	            		face = OUT_P888;
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_D888_P666:
-	            		face = OUT_P888;
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_P888:
-	            		face = OUT_P888;
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	default:
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
-	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		face = screen->face;
-	            		break;
-		}
-
-		//use default overlay,set vsyn hsync den dclk polarity
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
-	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
-	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
-	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
-
-		//set background color to black,set swap according to the screen panel,disable blank mode
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BG_COLOR | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | 
-		 	m_DUMMY_SWAP | m_BLANK_MODE,v_BG_COLOR(0x000000) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
-		 	v_OUTPUT_RG_SWAP(screen->swap_rg) | v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy) |
-		 	v_BLACK_MODE(0));
-
-		
-		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
-	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
-		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
-	             v_HASP(screen->hsync_len + screen->left_margin));
-
-		lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
-	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
-		lcdc_writel(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
-	              v_VASP(screen->vsync_len + screen->upper_margin));
-		// let above to take effect
-		lcdc_cfg_done(lcdc_dev);
-	}
- 	spin_unlock(&lcdc_dev->reg_lock);
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-	if(ret)
-	{
-        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-	}
-    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-		(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps;
-    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
-
-    	if(screen->init)
-    	{
-    		screen->init();
-    	}
-	
-	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
-	return 0;
-}
-
-static int mcu_refresh(struct rk30_lcdc_device *lcdc_dev)
-{
-   
-    return 0;
-}
-
-
-
-//enable layer,open:1,enable;0 disable
-static int win0_open(struct rk30_lcdc_device *lcdc_dev,bool open)
-{
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[0]->state = open;
-		
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W0_EN, v_W0_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		lcdc_cfg_done(lcdc_dev);	
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	
-	return 0;
-}
-static int win1_open(struct rk30_lcdc_device *lcdc_dev,bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W1_EN, v_W1_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static int win2_open(struct rk30_lcdc_device *lcdc_dev,bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk(KERN_INFO "lcdc%d wakeup from standby!",lcdc_dev->id);
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W2_EN, v_W2_EN(open));
-
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		
-		lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01);
-		lcdc_dev->driver.layer_par[1]->state = open;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static int rk30_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
-{
-	struct rk30_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk30_lcdc_device ,driver);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch(blank_mode)
-	    	{
-	    		case FB_BLANK_UNBLANK:
-	      			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
-				break;
-	    		case FB_BLANK_NORMAL:
-	         		lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-	    		default:
-				lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-		}
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	dev_info(lcdc_drv->dev,"blank mode:%d\n",blank_mode);
-	
-    	return 0;
-}
-
-static  int win0_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, y_addr);
-	    	lcdc_writel(lcdc_dev, WIN0_CBR_MST0, uv_addr);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-	
-}
-
-static  int win1_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_writel(lcdc_dev, WIN1_YRGB_MST, y_addr);
-	    	lcdc_writel(lcdc_dev, WIN1_CBR_MST, uv_addr);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static  int win2_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_writel(lcdc_dev, WIN2_MST, y_addr);
-		lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01); 
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static  int win0_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg = 0;
-	char fmt[9] = "NULL";
-	xact = par->xact;			    //active (origin) picture window width/height		
-	yact = par->yact;
-	xvir = par->xvir;			   // virtual resolution		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-   
-
-	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
-	{
-		dev_err(lcdc_dev->driver.dev,"invalid parameter for win0-->xact:%d yact:%d xsize:%d ysize:%d\n",
-			xact,yact,par->xsize,par->ysize);
-		return -EINVAL;
-	}	
-	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
-	ScaleYrgbY = CalScale(yact, par->ysize);
-	switch (par->format)
-	{
-		case ARGB888:
-		case XBGR888:
-		case ABGR888:
-	     		fmt_cfg = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			break;
-		case YUV422:// yuv422
-			fmt_cfg = 5;
-			ScaleCbrX = CalScale((xact/2), par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		case YUV420: // yuv420
-			fmt_cfg = 4;
-			ScaleCbrX = CalScale(xact/2, par->xsize);
-		   	ScaleCbrY = CalScale(yact/2, par->ysize);
-		   	break;
-		case YUV444:// yuv444
-			fmt_cfg = 6;
-			ScaleCbrX = CalScale(xact, par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		default:
-			printk("%s un supported format\n",__func__);
-		   	break;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
-		lcdc_writel(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		lcdc_writel(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		lcdc_writel(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
-		//lcdc_msk_reg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
-		//	v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format) 
-		{
-			case XBGR888:
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
-				break;
-			case ARGB888:
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			case ABGR888:
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
-				break;
-			case RGB888:  //rgb888
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			case RGB565:  //rgb565
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_RGB565_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			case YUV422:
-			case YUV420:   
-				lcdc_writel(lcdc_dev, WIN0_VIR,v_YUV_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
-				break;
-			default:
-				printk("%s:un supported format\n",__func__);
-				break;
-		}
-
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-    return 0;
-
-}
-
-static int win1_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg = 0;
-	char fmt[9];
-	xact = par->xact;			
-	yact = par->yact;
-	xvir = par->xvir;		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-	
-	ScaleYrgbX = CalScale(xact, par->xsize);
-	ScaleYrgbY = CalScale(yact, par->ysize);
-	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
-	{
-		dev_err(lcdc_dev->driver.dev,"invalid parameter for win1-->xact:%d yact:%d xsize:%d ysize:%d\n",
-			xact,yact,par->xsize,par->ysize);
-		return -EINVAL;
-	}	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch (par->format)
-	 	{
-	 		case ARGB888:
-			case XBGR888:
-			case ABGR888:
-		     		fmt_cfg = 0;
-				break;
-			case RGB888:
-				fmt_cfg = 1;
-				break;
-			case RGB565:
-				fmt_cfg = 2;
-				break;
-			case YUV422:// yuv422
-				fmt_cfg = 5;
-				ScaleCbrX = CalScale((xact/2), par->xsize);
-				ScaleCbrY = CalScale(yact, par->ysize);
-				break;
-			case YUV420: // yuv420
-				fmt_cfg = 4;
-				ScaleCbrX = CalScale(xact/2, par->xsize);
-				ScaleCbrY = CalScale(yact/2, par->ysize);
-				break;
-			case YUV444:// yuv444
-				fmt_cfg = 6;
-				ScaleCbrX = CalScale(xact, par->xsize);
-				ScaleCbrY = CalScale(yact, par->ysize);
-				break;
-			default:
-				printk("%s:un supported format\n",__func__);
-				break;
-		}
-
-		lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_CBR,  v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL1, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
-		lcdc_writel(lcdc_dev, WIN1_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		lcdc_writel(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
-		// enable win1 color key and set the color to black(rgb=0)
-		//lcdc_msk_reg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format)
-	    	{
-	    		case XBGR888:
-				lcdc_writel(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-		        case ARGB888:
-				lcdc_writel(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-		        case RGB888:  //rgb888
-				lcdc_writel(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-		        case RGB565:  //rgb565
-				lcdc_writel(lcdc_dev, WIN1_VIR,v_RGB565_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-		        case YUV422:
-		        case YUV420:   
-				lcdc_writel(lcdc_dev, WIN1_VIR,v_YUV_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
-				break;
-		        default:
-				printk("%s:un supported formate\n",__func__);
-				break;
-	    	}
-		
-		lcdc_cfg_done(lcdc_dev); 
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-    return 0;
-}
-
-static int win2_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u8 fmt_cfg = 0;
-	char fmt[9];
-	
-	xact = par->xact;			
-	yact = par->yact;
-	xvir = par->xvir;		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-	
-	
-	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
-	{
-		dev_err(lcdc_dev->driver.dev,"invalid parameter for win2-->xact:%d yact:%d xsize:%d ysize:%d\n",
-			xact,yact,par->xsize,par->ysize);
-		return -EINVAL;
-	}	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-
-		lcdc_writel(lcdc_dev, WIN2_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		lcdc_writel(lcdc_dev, WIN2_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
-		// enable win1 color key and set the color to black(rgb=0)
-		//lcdc_msk_reg(lcdc_dev, WIN2_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format)
-	    	{
-	    		case XBGR888:
-				fmt_cfg = 0;
-				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(1));
-				break;
-		        case ARGB888:
-				fmt_cfg = 0;
-				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
-				break;
-			case ABGR888:
-				fmt_cfg = 0;
-				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(1));
-				break;
-		        case RGB888:  //rgb888
-		        	fmt_cfg = 1;
-				lcdc_writel(lcdc_dev, WIN2_VIR,v_RGB888_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
-				break;
-		        case RGB565:  //rgb565
-		        	fmt_cfg = 2;
-				lcdc_writel(lcdc_dev, WIN2_VIR,v_RGB565_VIRWIDTH(xvir));
-				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
-				break;
-		        default:
-				printk("%s:un supported format\n",__func__);
-				break;
-	    	}
-		
-		lcdc_msk_reg(lcdc_dev,SYS_CTRL1, m_W2_FORMAT, v_W2_FORMAT(fmt_cfg));
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-    return 0;
-}
-
-static int rk30_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
-{
-	int i=0;
-	int __iomem *c;
-	int v;
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	
-	//printk("%s>>open:%d>>cnt:%d\n",__func__,open,lcdc_dev->atv_layer_cnt);
-	if((open) && (!lcdc_dev->atv_layer_cnt)) //enable clk,when first layer open
-	{
-		rk30_lcdc_clk_enable(lcdc_dev);
-		memcpy((u8*)lcdc_dev->regs, (u8*)lcdc_dev->regsbak, 0xc4);  //resume reg
-		rk30_load_screen(dev_drv,1);
-		spin_lock(&lcdc_dev->reg_lock);
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-		{
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-			mdelay(25);
-			for(i=0;i<256;i++)
-			{
-				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
-				
-			}
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	
-	if(layer_id == 0)
-	{
-		win0_open(lcdc_dev,open);	
-	}
-	else if(layer_id == 1)
-	{
-		win1_open(lcdc_dev,open);
-	}
-	else if(layer_id == 2)
-	{
-		win2_open(lcdc_dev,open);
-	}
-
-	if((!open) && (!lcdc_dev->atv_layer_cnt))  //when all layer closed,disable clk
-	{
-		rk30_lcdc_clk_disable(lcdc_dev);
-	}
-
-	printk(KERN_INFO "lcdc%d win%d %s,atv layer:%d\n",
-		lcdc_dev->id,layer_id,open?"open":"closed",
-		lcdc_dev->atv_layer_cnt);
-	return 0;
-}
-
-static int rk30_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id == 2)
-	{
-		par = dev_drv->layer_par[2];
-        	win2_set_par(lcdc_dev,screen,par);
-	}
-	
-	return 0;
-}
-
-int rk30_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = dev_drv->cur_screen;
-	unsigned long flags;
-	int timeout;
-	
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;	
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_display(lcdc_dev,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_display(lcdc_dev,par);
-	}
-	else if(layer_id == 2)
-	{
-		par = dev_drv->layer_par[2];
-        	win2_display(lcdc_dev,par);
-	}
-	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
-	{
-		dev_drv->first_frame = 0;
-		lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
-			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
-		lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
-		 
-	}
-
-	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
-	{
-		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
-		if(!timeout&&(!dev_drv->frame_done.done))
-		{
-			printk(KERN_ERR "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	
-	return 0;
-}
-
-int rk30_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	int ret = 0;
-	struct color_key_cfg clr_key_cfg;
-	switch(cmd)
-	{
-		case RK_FBIOGET_PANEL_SIZE:    //get panel size
-                	panel_size[0] = dev_drv->screen0->x_res;
-                	panel_size[1] = dev_drv->screen0->y_res;
-            		if(copy_to_user(argp, panel_size, 8)) 
-				return -EFAULT;
-			break;
-		case RK_FBIOPUT_COLOR_KEY_CFG:
-			if(copy_from_user(&clr_key_cfg,argp,sizeof(struct color_key_cfg ))) 
-				return -EFAULT;
-			lcdc_writel(lcdc_dev,WIN0_COLOR_KEY_CTRL,clr_key_cfg.win0_color_key_cfg);
-			lcdc_writel(lcdc_dev,WIN1_COLOR_KEY_CTRL,clr_key_cfg.win1_color_key_cfg);
-			lcdc_writel(lcdc_dev,WIN2_COLOR_KEY_CTRL,clr_key_cfg.win2_color_key_cfg);
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-static int rk30_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = dev_drv->layer_par[layer_id];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(layer_id == 0)
-		{
-			par->state = lcdc_read_bit(lcdc_dev,SYS_CTRL1,m_W0_EN);
-		}
-		else if( layer_id == 1)
-		{
-			par->state = lcdc_read_bit(lcdc_dev,SYS_CTRL1,m_W1_EN);
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return par->state;
-	
-}
-
-/***********************************
-overlay manager
-swap:1 win0 on the top of win1
-        0 win1 on the top of win0
-set  : 1 set overlay 
-        0 get overlay state
-************************************/
-static int rk30_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(set)  //set overlay
-		{
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
-			lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01);
-			lcdc_cfg_done(lcdc_dev);
-			ovl = swap;
-		}
-		else  //get overlay
-		{
-			ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
-		}
-	}
-	else
-	{
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-
-static ssize_t  rk30_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
-{
-        struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	char format_w0[9]= "NULL";
-	char format_w1[9]= "NULL";
-	char format_w2[9]= "NULL";
-	char status_w0[9]= "NULL";
-	char status_w1[9]= "NULL";
-	char status_w2[9]= "NULL";
-	u32 fmt_id = lcdc_readl(lcdc_dev,SYS_CTRL1);
-	u32 act_info,dsp_info,dsp_st,factor;
-	u16 xvir_w0,x_act_w0,y_act_w0,x_dsp_w0,y_dsp_w0,x_st_w0,y_st_w0;
-	u16 xvir_w1,x_act_w1,y_act_w1,x_dsp_w1,y_dsp_w1,x_st_w1,y_st_w1;
-	u16 xvir_w2,x_dsp_w2,y_dsp_w2,x_st_w2,y_st_w2;
-	u16 x_scale_w0,y_scale_w0,x_scale_w1,y_scale_w1;
-	int ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
-
-	switch((fmt_id&m_W0_FORMAT)>>4)
-	{
-	case 0:
-	        strcpy(format_w0,"ARGB888");
-	        break;
-	case 1:
-	        strcpy(format_w0,"RGB888");
-	        break;
-	case 2:
-	        strcpy(format_w0,"RGB565");
-	        break;
-	case 4:
-	        strcpy(format_w0,"YCbCr420");
-	        break;
-	case 5:
-	        strcpy(format_w0,"YCbCr422");
-	        break;
-	case 6:
-	        strcpy(format_w0,"YCbCr444");
-	        break;
-	default:
-	        strcpy(format_w0,"inval\n");
-	        break;
-	}
-
-	
-	switch((fmt_id&m_W1_FORMAT)>>7)
-	{
-	case 0:
-		strcpy(format_w1,"ARGB888");
-		break;
-	case 1:
-		strcpy(format_w1,"RGB888");
-		break;
-	case 2:
-		strcpy(format_w1,"RGB565");
-		break;
-	case 4:
-		strcpy(format_w1,"YCbCr420");
-		break;
-	case 5:
-		strcpy(format_w1,"YCbCr422");
-		break;
-	case 6:
-		strcpy(format_w1,"YCbCr444");
-		break;
-	default:
-		strcpy(format_w1,"inval\n");
-		break;
-	}
-
-	switch((fmt_id&m_W2_FORMAT)>>10)
-	{
-	case 0:
-	        strcpy(format_w2,"ARGB888");
-	        break;
-	case 1:
-	        strcpy(format_w2,"RGB888");
-	        break;
-	case 2:
-	        strcpy(format_w2,"RGB565");
-	        break;
-	case 4:
-	        strcpy(format_w2,"8bpp");
-	        break;
-	        case 5:
-	        strcpy(format_w2,"4bpp");
-	        break;
-	case 6:
-	        strcpy(format_w2,"2bpp");
-	        break;
-	case 7:
-	        strcpy(format_w2,"1bpp");
-	        break;
-	default:
-	        strcpy(format_w2,"inval\n");
-	        break;
-	}
-
-	if(fmt_id&m_W0_EN)
-	{
-		strcpy(status_w0,"enabled");
-	}
-	else
-	{
-		strcpy(status_w0,"disabled");
-	}
-
-	if((fmt_id&m_W1_EN)>>1)
-	{
-		strcpy(status_w1,"enabled");
-	}
-	else
-	{
-		strcpy(status_w1,"disabled");
-	}
-
-	
-	if((fmt_id&m_W2_EN)>>1)
-	{
-		strcpy(status_w2,"enabled");
-	}
-	else
-	{
-		strcpy(status_w2,"disabled");
-	}
-	
-	xvir_w0 = lcdc_readl(lcdc_dev,WIN0_VIR)&0xffff;
-	act_info = lcdc_readl(lcdc_dev,WIN0_ACT_INFO);
-	dsp_info = lcdc_readl(lcdc_dev,WIN0_DSP_INFO);
-	dsp_st = lcdc_readl(lcdc_dev,WIN0_DSP_ST);
-	factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
-	x_act_w0 =  (act_info&0xffff) + 1;
-	y_act_w0 = (act_info>>16) + 1;
-	x_dsp_w0 = (dsp_info&0xffff) + 1;
-	y_dsp_w0 = (dsp_info>>16) + 1;
-	x_st_w0 = (dsp_st&0xfff);
-	y_st_w0 = (dsp_st>>16);
-	x_scale_w0 = 4096*100/(factor&0xffff);
-	y_scale_w0 = 4096*100/(factor>>16);
-	
-	xvir_w1= lcdc_readl(lcdc_dev,WIN1_VIR)&0xffff;
-	act_info = lcdc_readl(lcdc_dev,WIN1_ACT_INFO);
-	dsp_info = lcdc_readl(lcdc_dev,WIN1_DSP_INFO);
-	dsp_st = lcdc_readl(lcdc_dev,WIN1_DSP_ST);
-	factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_YRGB);
-	x_act_w1= (act_info&0xffff) + 1;
-	y_act_w1 = (act_info>>16) + 1;
-	x_dsp_w1 = (dsp_info&0xffff) + 1;
-	y_dsp_w1= (dsp_info>>16) + 1;
-	x_st_w1 = (dsp_st&0xfff);
-	y_st_w1 = (dsp_st>>16);
-	x_scale_w1= 4096*100/(factor&0xffff);
-	y_scale_w1= 4096*100/(factor>>16);
-
-	xvir_w2 = lcdc_readl(lcdc_dev,WIN2_VIR)&0xffff;
-        dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO);
-        dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST);
-
-        x_dsp_w2 = dsp_info&0xffff;
-        y_dsp_w2 = dsp_info>>16;
-	x_st_w2 = dsp_st&0xfff;
-	y_st_w2 = dsp_st>>16;
-
-	
-	return snprintf(buf,PAGE_SIZE,
-			"win0:%s\n"
-			"xvir:%d\n"
-			"xact:%d\n"
-			"yact:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"x_scale:%d.%d\n"
-			"y_scale:%d.%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"CBR buffer addr:0x%08x\n\n"
-			"win1:%s\n"
-			"xvir:%d\n"
-			"xact:%d\n"
-			"yact:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"x_scale:%d.%d\n"
-			"y_scale:%d.%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"CBR buffer addr:0x%08x\n\n"
-			"overlay:%s\n\n"
-			"win2:%s\n"
-			"xvir:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n",
-			status_w0,
-			xvir_w0,
-			x_act_w0,
-			y_act_w0,
-			x_dsp_w0,
-			y_dsp_w0,
-			x_st_w0,
-			y_st_w0,
-			x_scale_w0/100,
-			x_scale_w0%100,
-			y_scale_w0/100,
-			y_scale_w0%100,
-			format_w0,
-			lcdc_readl(lcdc_dev,WIN0_YRGB_MST0),
-			lcdc_readl(lcdc_dev,WIN0_CBR_MST0),
-			status_w1,
-			xvir_w1,
-			x_act_w1,
-			y_act_w1,
-			x_dsp_w1,
-			y_dsp_w1,
-			x_st_w1,
-			y_st_w1,
-			x_scale_w1/100,
-			x_scale_w1%100,
-			y_scale_w1/100,
-			y_scale_w1%100,
-			format_w1,
-			lcdc_readl(lcdc_dev,WIN1_YRGB_MST),
-			lcdc_readl(lcdc_dev,WIN1_CBR_MST),
-			ovl ? "win0 on the top of win1\n":"win1 on the top of win0\n",
-			status_w2,
-			xvir_w2,
-			x_dsp_w2,
-			y_dsp_w2,
-			x_st_w2,
-			y_st_w2,
-			format_w2,
-			lcdc_readl(lcdc_dev,WIN2_MST));
-        return 0;
-}
-
-/*******************************************
-lcdc fps manager,set or get lcdc fps
-
-
-
-set:0 get
-     1 set
-********************************************/
-static int rk30_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	rk_screen * screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-
-	if(set)
-	{
-		ft = div_u64(1000000000000llu,fps);
-		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
-		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-		}
-	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-			
-	}
-
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-	(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps ;  //one frame time in ms
-	return fps;
-}
-
-static int rk30_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
-	enum fb_win_map_order order)
-{
-       mutex_lock(&dev_drv->fb_win_id_mutex);
-       if(order == FB_DEFAULT_ORDER )
-	{
-		order = FB0_WIN1_FB1_WIN0_FB2_WIN2;
-	}
-       dev_drv->fb2_win_id  = order/100;
-       dev_drv->fb1_win_id = (order/10)%10;
-       dev_drv->fb0_win_id = order%10;
-       mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-       printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
-               dev_drv->fb2_win_id);
-
-       return 0;
-}
-
-static int rk30_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
-{
-       int layer_id = 0;
-       mutex_lock(&dev_drv->fb_win_id_mutex);
-       if(!strcmp(id,"fb0")||!strcmp(id,"fb3"))
-       {
-               layer_id = dev_drv->fb0_win_id;
-       }
-       else if(!strcmp(id,"fb1")||!strcmp(id,"fb4"))
-       {
-               layer_id = dev_drv->fb1_win_id;
-       }
-       else if(!strcmp(id,"fb2")||!strcmp(id,"fb5"))
-       {
-               layer_id = dev_drv->fb2_win_id;
-       }
-       mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-       return  layer_id;
-}
-
-static int rk30_read_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
-{
-
-	return 0;
-}
-
-static int rk30_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
-{
-	int i=0;
-	int __iomem *c;
-	int v;
-	int ret = 0;
-
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	msleep(25);
-	if(dev_drv->cur_screen->dsp_lut)
-	{
-		for(i=0;i<256;i++)
-		{
-			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
-			c = lcdc_dev->dsp_lut_addr_base+i;
-			writel_relaxed(v,c);
-			
-		}
-	}
-	else
-	{
-		printk(KERN_WARNING "no buffer to backup lut data!\n");
-		ret =  -1;
-	}
-	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-
-	return ret;
-}
-int rk30_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-
-
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(1);
-	if(dev_drv->screen_ctr_info->io_disable)
-		dev_drv->screen_ctr_info->io_disable();
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else  //clk already disabled
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-		
-	rk30_lcdc_clk_disable(lcdc_dev);
-
-	return 0;
-}
-
-
-int rk30_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
-{  
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	int i=0;
-	int __iomem *c;
-	int v;
-
-	if(dev_drv->screen_ctr_info->io_enable) 		//power on
-		dev_drv->screen_ctr_info->io_enable();
-		
-	if(lcdc_dev->atv_layer_cnt)
-	{
-		rk30_lcdc_clk_enable(lcdc_dev);
-		
-		memcpy((u8*)lcdc_dev->regs, (u8*)lcdc_dev->regsbak, 0xc4);  //resume reg
-
-		spin_lock(&lcdc_dev->reg_lock);
-		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
-		{
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-			mdelay(25);
-			for(i=0;i<256;i++)
-			{
-				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base+i;
-				writel_relaxed(v,c);
-				
-			}
-			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
-		}
-		
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-		lcdc_cfg_done(lcdc_dev);
-		
-		spin_unlock(&lcdc_dev->reg_lock);
-
-	}
-	
-	if(dev_drv->screen0->standby)
-		dev_drv->screen0->standby(0);	      //screen wake up
-		
-    	return 0;
-}
-
-
-static irqreturn_t rk30_lcdc_isr(int irq, void *dev_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = (struct rk30_lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	
-	lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-	//lcdc_cfg_done(lcdc_dev);
-	//lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
- 
-	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
-	{
-		spin_lock(&(lcdc_dev->driver.cpl_lock));
-		complete(&(lcdc_dev->driver.frame_done));
-		spin_unlock(&(lcdc_dev->driver.cpl_lock));
-	}
-
-	lcdc_dev->driver.vsync_info.timestamp = timestamp;
-	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-	
-	return IRQ_HANDLED;
-}
-
-static struct layer_par lcdc_layer[] = {
-	[0] = {
-		.name  		= "win0",
-		.id		= 0,
-		.support_3d	= true,
-	},
-	[1] = {
-		.name  		= "win1",
-		.id		= 1,
-		.support_3d	= false,
-	},
-	[2] = {
-		.name  		= "win2",
-		.id		= 2,
-		.support_3d	= false,
-	},
-};
-
-static struct rk_lcdc_device_driver lcdc_driver = {
-	.name			= "lcdc",
-	.def_layer_par		= lcdc_layer,
-	.num_layer		= ARRAY_SIZE(lcdc_layer),
-	.open			= rk30_lcdc_open,
-	.init_lcdc		= rk30_lcdc_init,
-	.ioctl			= rk30_lcdc_ioctl,
-	.suspend		= rk30_lcdc_early_suspend,
-	.resume			= rk30_lcdc_early_resume,
-	.set_par       		= rk30_lcdc_set_par,
-	.blank         		= rk30_lcdc_blank,
-	.pan_display            = rk30_lcdc_pan_display,
-	.load_screen		= rk30_load_screen,
-	.get_layer_state	= rk30_lcdc_get_layer_state,
-	.ovl_mgr		= rk30_lcdc_ovl_mgr,
-	.get_disp_info		= rk30_lcdc_get_disp_info,
-	.fps_mgr		= rk30_lcdc_fps_mgr,
-	.fb_get_layer           = rk30_fb_get_layer,
-	.fb_layer_remap         = rk30_fb_layer_remap,
-	.set_dsp_lut            = rk30_set_dsp_lut,
-	.read_dsp_lut           = rk30_read_dsp_lut,
-};
-#ifdef CONFIG_PM
-static int rk30_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk30_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#else
-#define rk30_lcdc_suspend NULL
-#define rk30_lcdc_resume NULL
-#endif
-
-static int __devinit rk30_lcdc_probe (struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev=NULL;
-	rk_screen *screen;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
-	rk_screen *screen1;
-#endif
-	struct rk29fb_info *screen_ctr_info;
-	struct resource *res = NULL;
-	struct resource *mem;
-	int ret = 0;
-	
-	/*************Malloc rk30lcdc_inf and set it to pdev for drvdata**********/
-	lcdc_dev = kzalloc(sizeof(struct rk30_lcdc_device), GFP_KERNEL);
-    	if(!lcdc_dev)
-    	{
-        	dev_err(&pdev->dev, ">>rk30 lcdc device kmalloc fail!");
-        	return -ENOMEM;
-    	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->id = pdev->id;
-	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
-	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen)
-	{
-		dev_err(&pdev->dev, ">>rk30 lcdc screen kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	else
-	{
-		lcdc_dev->screen = screen;
-		screen->lcdc_id = lcdc_dev->id;
-		screen->screen_id = 0;
-	}
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&&  (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen1)
-	{
-		dev_err(&pdev->dev, ">>rk30 lcdc screen1 kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	screen1->lcdc_id = 1;
-	screen1->screen_id = 1;
-	printk("use lcdc%d and jetta implemention dual display!\n",lcdc_dev->id);
-	
-#endif
-	/****************get lcdc0 reg  *************************/
-	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
-	if (res == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-    	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
-    	if (mem == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
-	if (lcdc_dev->reg_vir_base == NULL)
-	{
-		dev_err(&pdev->dev, "cannot map IO\n");
-		ret = -ENXIO;
-		goto err2;
-	}
-	
-    	//lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
-    	lcdc_dev->regs = lcdc_dev->reg_vir_base;
-	lcdc_dev->regsbak = kzalloc(lcdc_dev->len,GFP_KERNEL);
-	if(!lcdc_dev->regsbak)
-	{
-		dev_err(&pdev->dev, "failed to map memory for reg backup!\n");
-	}
-	//lcdc_dev->dsp_lut_addr_base = &lcdc_dev->preg->DSP_LUT_ADDR;
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
-	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->regs);
-	lcdc_dev->driver.dev=&pdev->dev;
-	lcdc_dev->driver.screen0 = screen;
-#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
-	lcdc_dev->driver.screen1 = screen1;
-#endif
-	lcdc_dev->driver.cur_screen = screen;
-	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
-	
-	spin_lock_init(&lcdc_dev->reg_lock);
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if(lcdc_dev->irq < 0)
-	{
-		dev_err(&pdev->dev, "cannot find IRQ\n");
-		goto err3;
-	}
-	ret = request_irq(lcdc_dev->irq, rk30_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
-	if (ret)
-	{
-	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
-	       ret = -EBUSY;
-	       goto err3;
-	}
-	
-	if(screen_ctr_info->set_screen_info)
-	{
-		screen_ctr_info->set_screen_info(screen,screen_ctr_info->lcd_info);
-		if(SCREEN_NULL==screen->type)
-		{
-			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-			ret = -ENODEV;
-		}
-		if(screen_ctr_info->io_init)
-			screen_ctr_info->io_init(NULL);
-	}
-	else
-	{
-		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
-		ret =  -ENODEV;
-		goto err4;
-	}
-	
-	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
-		goto err4;
-	}
-	printk("rk30 lcdc%d probe ok!\n",lcdc_dev->id);
-
-	return 0;
-
-err4:
-	free_irq(lcdc_dev->irq,lcdc_dev);
-err3:	
-	iounmap(lcdc_dev->reg_vir_base);
-err2:
-	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
-err1:
-	kfree(screen);
-err0:
-	platform_set_drvdata(pdev, NULL);
-	kfree(lcdc_dev);
-	return ret;
-    
-}
-static int __devexit rk30_lcdc_remove(struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk_fb_unregister(&(lcdc_dev->driver));
-	rk30_lcdc_deinit(lcdc_dev);
-	iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);
-	return 0;
-}
-
-static void rk30_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
-		lcdc_dev->driver.cur_screen->standby(1);
-	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
-		lcdc_dev->driver.screen_ctr_info->io_disable();
-	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds if necessary
-		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
-	rk30_lcdc_deinit(lcdc_dev);
-	//rk_fb_unregister(&(lcdc_dev->driver));
-	
-	/*iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);*/
-}
-
-
-static struct platform_driver rk30lcdc_driver = {
-	.probe		= rk30_lcdc_probe,
-	.remove		= __devexit_p(rk30_lcdc_remove),
-	.driver		= {
-		.name	= "rk30-lcdc",
-		.owner	= THIS_MODULE,
-	},
-	.suspend	= rk30_lcdc_suspend,
-	.resume		= rk30_lcdc_resume,
-	.shutdown   = rk30_lcdc_shutdown,
-};
-
-static int __init rk30_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk30lcdc_driver);
-}
-
-static void __exit rk30_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk30lcdc_driver);
-}
-
-
-
-fs_initcall(rk30_lcdc_module_init);
-module_exit(rk30_lcdc_module_exit);
-
-
-
diff --git a/drivers/video/rockchip/lcdc/rk30_lcdc.h b/drivers/video/rockchip/lcdc/rk30_lcdc.h
deleted file mode 100644
index 9d754971afa5..000000000000
--- a/drivers/video/rockchip/lcdc/rk30_lcdc.h
+++ /dev/null
@@ -1,700 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK30_LCDC_H_
-#define RK30_LCDC_H_
-
-#include<linux/rk_fb.h>
-
-
-#if 0
-#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
-#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
-#define LcdRdReg(inf, addr)             (inf->preg->addr)
-#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
-#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
-#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
-#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
-#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
-
-/********************************************************************
-**                                                          *
-********************************************************************/
-/* LCDC */
-
-typedef volatile struct tagLCDC_REG
-{
-    /* offset 0x00~0xc0 */
-	unsigned int SYS_CTRL0;               //0x00 system control register 0
-	unsigned int SYS_CTRL1;				  //0x04 system control register 1
-	unsigned int DSP_CTRL0;				 //0x08 display control register 0
-	unsigned int DSP_CTRL1;				 //0x0c display control register 1
-	unsigned int INT_STATUS;             //0x10 Interrupt status register
-	unsigned int MCU_CTRL ;				 //0x14 MCU mode contol register
-	unsigned int BLEND_CTRL;             //0x18 Blending control register
-	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
-	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
-	unsigned int WIN2_COLOR_KEY_CTRL;     //0x24 Win2 blending control register
-	unsigned int WIN0_YRGB_MST0;           //0x28 Win0 active YRGB memory start address0
-	unsigned int WIN0_CBR_MST0;            //0x2c Win0 active Cbr memory start address0
-	unsigned int WIN0_YRGB_MST1;           //0x30 Win0 active YRGB memory start address1
-	unsigned int WIN0_CBR_MST1;            //0x34 Win0 active Cbr memory start address1
-	unsigned int WIN0_VIR;                //0x38 WIN0 virtual display width/height
-	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
-	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
-	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
-	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
-	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
-	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
-	unsigned int WIN1_YRGB_MST;           //0x54 Win1 active YRGB memory start address
-	unsigned int WIN1_CBR_MST;            //0x58 Win1 active Cbr memory start address
-	unsigned int WIN1_VIR;                //0x5c WIN1 virtual display width/height
-	unsigned int WIN1_ACT_INFO;           //0x60 Win1 active window width/height
-	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
-	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
-	unsigned int WIN1_SCL_FACTOR_YRGB;    //0x6c Win1 YRGB scaling  factor setting
-	unsigned int WIN1_SCL_FACTOR_CBR;     //0x70 Win1 YRGB scaling factor setting
-	unsigned int WIN1_SCL_OFFSET;         //0x74 Win1 Cbr scaling start point offset
-	unsigned int WIN2_MST;		 		  //0x78 win2 memort start address
-	unsigned int WIN2_VIR;				  //0x7c win2 virtual stride
-	unsigned int WIN2_DSP_INFO;           //0x80 Win2 display width/height on panel
-	unsigned int WIN2_DSP_ST;             //0x84 Win2 display start point on panel
-	unsigned int HWC_MST;                 //0x88 HWC memory start address
-	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
-	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2b01 look up table 0
-	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2b10 look up table 1
-	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2b11 look up table 2
-	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
-	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
-	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
-	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
-	unsigned int DSP_VS_ST_END_F1;        //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
-	unsigned int DSP_VACT_ST_END_F1;      //0xb0 Vertical scanning active start/end point of even filed in interlace mode
-	unsigned int reserved0[(0xc0-0xb4)/4];
-	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
-	unsigned int reserved1[(0x100-0xc4)/4];
-	unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
-	unsigned int reserved2[(0x200-0x104)/4];
-	unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port   
-	unsigned int reserved3[(0x400-0x204)/4];
-	unsigned int WIN2_LUT_ADDR;
-	unsigned int reserved4[(0x800-0x404)/4];
-	unsigned int DSP_LUT_ADDR;
-  
-} LCDC_REG, *pLCDC_REG;
-
-#else
-
-#define SYS_CTRL0  	0x00			//0x00 system control register 0
-#define SYS_CTRL1	0x04			//0x04 system control register 1
-#define DSP_CTRL0	0x08			//0x08 display control register 0
-#define DSP_CTRL1	0x0c			//0x0c display control register 1
-#define INT_STATUS 	0x10            	//0x10 Interrupt status register
-#define MCU_CTRL	0x14			//0x14 MCU mode contol register
-#define BLEND_CTRL 	0x18           		//0x18 Blending control register
-#define WIN0_COLOR_KEY_CTRL	0x1c    	//0x1c Win0 blending control register
-#define WIN1_COLOR_KEY_CTRL 	0x20    	//0x20 Win1 blending control register
-#define WIN2_COLOR_KEY_CTRL 	0x24    	//0x24 Win2 blending control register
-#define WIN0_YRGB_MST0 		0x28          //0x28 Win0 active YRGB memory start address0
-#define WIN0_CBR_MST0 		0x2c           //0x2c Win0 active Cbr memory start address0
-#define WIN0_YRGB_MST1		0x30           //0x30 Win0 active YRGB memory start address1
-#define WIN0_CBR_MST1		0x34            //0x34 Win0 active Cbr memory start address1
-#define WIN0_VIR 		0x38              //0x38 WIN0 virtual display width/height
-#define WIN0_ACT_INFO		0x3c           //0x3C Win0 active window width/height
-#define WIN0_DSP_INFO 		0x40          //0x40 Win0 display width/height on panel
-#define WIN0_DSP_ST  		0x44          //0x44 Win0 display start point on panel
-#define WIN0_SCL_FACTOR_YRGB	0x48    //0x48Win0 YRGB scaling  factor setting
-#define WIN0_SCL_FACTOR_CBR 	0x4c    //0x4c Win0 YRGB scaling factor setting
-#define WIN0_SCL_OFFSET 	0x50        //0x50 Win0 Cbr scaling start point offset
-#define WIN1_YRGB_MST  		0x54       //0x54 Win1 active YRGB memory start address
-#define WIN1_CBR_MST		0x58       //0x58 Win1 active Cbr memory start address
-#define WIN1_VIR 		0x5c       //0x5c WIN1 virtual display width/height
-#define WIN1_ACT_INFO 		0x60          //0x60 Win1 active window width/height
-#define WIN1_DSP_INFO		0x64           //0x64 Win1 display width/height on panel
-#define WIN1_DSP_ST		0x68             //0x68 Win1 display start point on panel
-#define WIN1_SCL_FACTOR_YRGB    0x6c   //0x6c Win1 YRGB scaling  factor setting
-#define WIN1_SCL_FACTOR_CBR	0x70     //0x70 Win1 YRGB scaling factor setting
-#define WIN1_SCL_OFFSET 	0x74        //0x74 Win1 Cbr scaling start point offset
-#define WIN2_MST		0x78	 //0x78 win2 memort start address
-#define WIN2_VIR		0x7c	//0x7c win2 virtual stride
-#define WIN2_DSP_INFO 		0x80    //0x80 Win2 display width/height on panel
-#define WIN2_DSP_ST		0x84    //0x84 Win2 display start point on panel
-#define HWC_MST                 0x88	//0x88 HWC memory start address
-#define HWC_DSP_ST		0x8c    //0x8C HWC display start point on panel
-#define HWC_COLOR_LUT0 		0x90         //0x90 Hardware cursor color 2b01 look up table 0
-#define HWC_COLOR_LUT1		0x94          //0x94 Hardware cursor color 2b10 look up table 1
-#define HWC_COLOR_LUT2          0x98		//0x98 Hardware cursor color 2b11 look up table 2
-#define DSP_HTOTAL_HS_END       0x9c		//0x9c Panel scanning horizontal width and hsync pulse end point
-#define DSP_HACT_ST_END		0xa0         //0xa0 Panel active horizontal scanning start/end point
-#define DSP_VTOTAL_VS_END	0xa4       //0xa4 Panel scanning vertical height and vsync pulse end point
-#define DSP_VACT_ST_END		0xa8         //0xa8 Panel active vertical scanning start/end point
-#define DSP_VS_ST_END_F1 	0xac       //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
-#define DSP_VACT_ST_END_F1     	0xb0		//0xb0 Vertical scanning active start/end point of even filed in interlace mode
-#define REG_CFG_DONE		0xc0            //0xc0 REGISTER CONFIG FINISH
-#define MCU_BYPASS_WPORT 	0x100        //0x100 MCU BYPASS MODE, DATA Write Only Port
-#define MCU_BYPASS_RPORT        0x200		//0x200 MCU BYPASS MODE, DATA Read Only Port   
-#define WIN2_LUT_ADDR		0x400
-#define DSP_LUT_ADDR		0x800
-
-#if 0
-#define lcdc_writel(lcdc_dev,offset,v)  do { \
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	\
-	_pv += (offset >> 2);			\
-	writel_relaxed(v,lcdc_dev->regs+offset);\
-	*_pv = v;	\
-} while(0)
-
-#define lcdc_readl(lcdc_dev,offset)  		\
-	readl_relaxed(lcdc_dev->regs+offset)
-
-#define lcdc_read_bit(lcdc_dev,offset,msk) ( { \
-	u32 _v = readl_relaxed(lcdc_dev->regs+offset); \
-	_v &= msk;_v;	} )
-
-#define lcdc_set_bit(lcdc_dev,offset,msk) do {  \
-	u32* _pv = (u32*)lcdc_dev->regsbak;	\
-	_pv += (offset >> 2);				\
-	(*_pv) |= msk;				\
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); \
-} while(0)
-
-#define lcdc_clr_bit(lcdc_dev,offset,msk) do{	\
-	u32* _pv = (u32*)lcdc_dev->regsbak;	\
-	_pv += (offset >> 2);				\
-	(*_pv) &= ~msk;				\
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); \
-} while (0)
-
-#define lcdc_msk_reg(lcdc_dev,offset,msk,v) do {	\
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	\
-	_pv += (offset >> 2);			\
-	(*_pv) &= (~msk);				\
-	(*_pv) |= v;				\
-	writel_relaxed(*_pv,lcdc_dev->regs+offset);	\
-} while(0)
-
-#define lcdc_cfg_done(lcdc_dev) do{ \
-	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); \
-	dsb();						\
-} while(0)
-#endif
-#endif
-
-/* SYS_CONFIG */
-
-#define m_LCDC_DMA_STOP              (1<<0)
-#define m_LCDC_STANDBY               (1<<1)
-#define m_HWC_RELOAD_EN               (1<<2)
-#define m_W0_AXI_OUTSTANDING_DISABLE (1<<3) 
-#define m_W1_AXI_OUTSTANDING_DISABLE (1<<4)
-#define m_W2_AXI_OUTSTANDING_DISABLE (1<<5)
-#define m_DMA_BURST_LENGTH	      (3<<6)
-#define m_WIN0_YRGB_CHANNEL0_ID	      ((0x07)<<8)
-#define m_WIN0_CBR_CHANNEL0_ID	      ((0x07)<<11)
-#define m_WIN0_YRGB_CHANNEL1_ID	      ((0x07)<<14)
-#define m_WIN0_CBR_CHANNEL1_ID	      ((0x07)<<17)
-#define m_WIN1_YRGB_CHANNEL_ID	      ((0x07)<<20)
-#define m_WIN1_CBR_CHANNEL_ID	      ((0x07)<<23)
-#define m_WIN2_CHANNEL_ID	      ((0x07)<<26)
-#define m_HWC_CHANNEL_ID	      ((0x07)<<29)
-
-
-
-
-
-#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
-#define v_LCDC_STANDBY(x)              (((x)&1)<<1)
-#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
-#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
-#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
-#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
-#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
-#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
-#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
-#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
-#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
-#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
-#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
-#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
-#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
-
-
-
-//LCDC_SYS_CTRL1
-#define m_W0_EN          (1<<0)
-#define m_W1_EN          (1<<1)
-#define m_W2_EN         (1<<2)
-#define m_HWC_EN         (1<<3)
-#define m_W0_FORMAT          (7<<4)
-#define m_W1_FORMAT          (7<<7)
-#define m_W2_FORMAT          (7<<10)
-#define m_HWC_COLOR_MODE     (1<<13)
-#define m_HWC_SIZE_SELET     (1<<14)
-#define m_W0_3D_MODE_EN      (1<<15)
-#define m_W0_3D_MODE_SELET    (7<<16)
-#define m_W0_RGB_RB_SWAP      (1<<19)
-#define m_W0_RGB_ALPHA_SWAP   (1<<20)
-#define m_W0_YRGB_M8_SWAP     (1<<21)
-#define m_W0_CBCR_SWAP        (1<<22)
-#define m_W1_RGB_RB_SWAP      (1<<23)
-#define m_W1_RGB_ALPHA_SWAP   (1<<24)
-#define m_W1_YRGB_M8_SWAP     (1<<25)
-#define m_W1_CBCR_SWAP        (1<<26)
-#define m_W2_RGB_RB_SWAP      (1<<27)
-#define m_W2_RGB_ALPHA_SWAP   (1<<28)
-#define m_W2_8pp_PALETTE_ENDIAN_SELECT (1<<29)
-#define m_W2_LUT_RAM_EN       (1<<30)
-#define m_DSP_LUT_RAM_EN      (1<<31)
-
-#define v_W0_EN(x)          (((x)&1)<<0)
-#define v_W1_EN(x)          (((x)&1)<<1)
-#define v_W2_EN(x)          (((x)&1)<<2)
-#define v_HWC_EN(x)         (((x)&1)<<3)
-#define v_W0_FORMAT(x)      (((x)&7)<<4)
-#define v_W1_FORMAT(x)      (((x)&7)<<7)
-#define v_W2_FORMAT(x)      (((x)&7)<<10)
-#define v_HWC_COLOR_MODE(x)     (((x)&1)<<13)
-#define v_HWC_SIZE_SELET(x)     (((x)&1)<<14)
-#define v_W0_3D_MODE_EN(x)     (((x)&1)<<15)
-#define v_W0_3D_MODE_SELET(x)    (((x)&3)<<16)
-#define v_W0_RGB_RB_SWAP(x)      (((x)&1)<<19)
-#define v_W0_RGB_ALPHA_SWAP(x)   (((x)&1)<<20)
-#define v_W0_YRGB_M8_SWAP(x)     (((x)&1)<<21)
-#define v_W0_CBCR_SWAP(x)       (((x)&1)<<22)
-#define v_W1_RGB_RB_SWAP(x)      (((x)&1)<<23)
-#define v_W1_RGB_ALPHA_SWAP(x)   (((x)&1)<<24)
-#define v_W1_YRGB_M8_SWAP(x)     (((x)&1)<<25)
-#define v_W1_CBCR_SWAP(x)       (((x)&1)<<26)
-#define v_W2_RGB_RB_SWAP(x)      (((x)&1)<<27)
-#define v_W2_RGB_ALPHA_SWAP(x)   (((x)&1)<<28)
-#define v_W2_8pp_PALETTE_ENDIAN_SELECT (((x)&1)<<29)
-#define v_W2_LUT_RAM_EN(x)      (((x)&1)<<30)
-#define v_DSP_LUT_RAM_EN(x)      (((x)&1)<<31)
-
-//LCDC_DSP_CTRL_REG0
-#define m_DISPLAY_FORMAT             (0x0f<<0)
-#define m_HSYNC_POLARITY             (1<<4)
-#define m_VSYNC_POLARITY             (1<<5)
-#define m_DEN_POLARITY               (1<<6)
-#define m_DCLK_POLARITY              (1<<7)
-#define m_W0W1_POSITION_SWAP         (1<<8)
-#define m_DITHER_UP_EN               (1<<9)
-#define m_DITHER_DOWN_MODE           (1<<10)
-#define m_DITHER_DOWN_EN             (1<<11)
-#define m_INTERLACE_DSP_EN           (1<<12)
-#define m_INTERLACE_FIELD_POLARITY   (1<<13)
-#define m_W0_INTERLACE_READ_MODE     (1<<14)
-#define m_W1_INTERLACE_READ_MODE     (1<<15)
-#define m_W2_INTERLACE_READ_MODE     (1<<16)
-#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
-#define m_W0_CBR_DEFLICK_MODE        (1<<18)
-#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
-#define m_W1_CBR_DEFLICK_MODE        (1<<20)
-#define m_W0_ALPHA_MODE              (1<<21)
-#define m_W1_ALPHA_MODE              (1<<22)
-#define m_W2_ALPHA_MODE              (1<<23)
-#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
-#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
-#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
-#define m_YCRCB_CLIP_EN              (1<<29)
-#define m_CBR_FILTER_656             (1<<30)
-#define m_LCDC_AXICLK_AUTO_ENABLE 	(1<<31) //eanble for low power
-
-#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
-#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
-#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
-#define v_DEN_POLARITY(x)               (((x)&1)<<6)
-#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
-#define v_W0W1_POSITION_SWAP(x)			(((x)&1)<<8)		
-#define v_DITHER_UP_EN(x)               (((x)&1)<<9)
-#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<10)
-#define v_DITHER_DOWN_EN(x)             (((x)&1)<<11)
-#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
-#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
-#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
-#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
-#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
-#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
-#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
-#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
-#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
-#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
-#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
-#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
-#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
-#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
-#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
-#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
-#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
-#define v_LCDC_AXICLK_AUTO_ENABLE(x) 	(((x)&1)<<31) //eanble for low power
-
-//LCDC_DSP_CTRL_REG1
-#define m_BG_COLOR                    (0xffffff<<0)
-#define m_BG_B                        (0xff<<0)
-#define m_BG_G                        (0xff<<8)
-#define m_BG_R                        (0xff<<16)
-#define m_BLANK_MODE                  (1<<24)
-#define m_BLACK_MODE                  (1<<25)
-#define m_OUTPUT_BG_SWAP        	  (1<<26)
-#define m_OUTPUT_RB_SWAP        	  (1<<27)
-#define m_OUTPUT_RG_SWAP        	  (1<<28)
-#define m_DELTA_SWAP            	  (1<<29)
-#define m_DUMMY_SWAP            	  (1<<30)
-
-#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
-#define v_BG_B(x)                     (((x)&0xff)<<0)
-#define v_BG_G(x)                     (((x)&0xff)<<8)
-#define v_BG_R(x)                     (((x)&0xff)<<16)
-#define v_BLANK_MODE(x)               (((x)&1)<<24)
-#define v_BLACK_MODE(x)               (((x)&1)<<25)
-#define v_OUTPUT_BG_SWAP(x)        	  (((x)&1)<<26)
-#define v_OUTPUT_RB_SWAP(x)        	  (((x)&1)<<27)
-#define v_OUTPUT_RG_SWAP(x)        	  (((x)&1)<<28)
-#define v_DELTA_SWAP(x)            	  (((x)&1)<<29)
-#define v_DUMMY_SWAP(x)            	  (((x)&1)<<30)
-
-
-//LCDC_INT_STATUS
-#define v_HOR_START_INT_STA        (1<<0)  //status
-#define v_FRM_START_INT_STA        (1<<1)
-#define v_LINE_FLAG_INT_STA        (1<<2)
-#define v_BUS_ERR_INT_STA	   (1<<3)
-#define m_HOR_START_INT_EN     	   (1<<4)  //enable
-#define m_FRM_START_INT_EN          (1<<5)
-#define m_LINE_FLAG_INT_EN         (1<<6)
-#define m_BUS_ERR_INT_EN	   (1<<7)
-#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
-#define m_FRM_START_INT_CLEAR      (1<<9)
-#define m_LINE_FLAG_INT_CLEAR      (1<<10)
-#define m_BUS_ERR_INT_CLEAR        (1<<11)
-#define m_LINE_FLAG_NUM		   (0xfff<<12)
-#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
-#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
-#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
-#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
-#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
-#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
-#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
-#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
-#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
-
-
-
-//LCDC_MCU_TIMING_CTRL
-#define m_MCU_WRITE_PERIOD      (0x3f<<0)
-#define m_MCU_CS_ST             (0xf<<6)
-#define m_MCU_CS_END            (0x3f<<10)
-#define m_MCU_RW_ST             (0xf<<16)
-#define m_MCU_RW_END            (0x3f<<20)
-#define m_MCU_BPS_CLK_SEL		(1<<26)
-#define m_MCU_HOLDMODE_SELECT     (1<<27)
-#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
-#define m_MCU_RS_SELECT            (1<<29)
-#define m_MCU_BYPASSMODE_SELECT   (1<<30)
-#define m_MCU_OUTPUT_SELECT        (1<<31)
-#define v_MCU_WRITE_PERIOD(x)      (((x)&0x3f)<<0)
-#define v_MCU_CS_ST(x)          (((x)&0xf)<<6)
-#define v_MCU_CS_END(x)         (((x)&0x3f)<<10)
-#define v_MCU_RW_ST(x)          (((x)&0xf)<<16)
-#define v_MCU_RW_END(x)         (((x)&0x3f)<<20)
-#define v_MCU_BPS_CLK_SEL	(((x)&1)<<26)
-#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
-#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
-#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
-#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
-#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
-
-//LCDC_ BLEND_CTRL
-#define m_W0_BLEND_EN         (1<<0)
-#define m_W1_BLEND_EN          (1<<1)
-#define m_W2_BLEND_EN          (1<<2)
-#define m_HWC_BLEND_EN          (1<<3)
-#define m_W0_BLEND_FACTOR     (15<<4)
-#define m_W1_BLEND_FACTOR     (0xff<<8)
-#define m_W2_BLEND_FACTOR     (0xff<<16)
-#define m_HWC_BLEND_FACTOR     (0xff<<24)
-
-#define v_W0_BLEND_EN(x)         (((x)&1)<<0)
-#define v_W1_BLEND_EN(x)          (((x)&1)<<1)
-#define v_W2_BLEND_EN(x)          (((x)&1)<<2)
-#define v_HWC_BLEND_EN(x)          (((x)&1)<<3)
-#define v_W0_BLEND_FACTOR(x)    (((x)&15)<<4)
-#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<8)
-#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<16)
-#define v_HWC_BLEND_FACTOR(x)     (((x)&0xff)<<24)
-
-
-//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
-#define m_KEYCOLOR          (0xffffff<<0)
-#define m_KEYCOLOR_B          (0xff<<0)
-#define m_KEYCOLOR_G          (0xff<<8)
-#define m_KEYCOLOR_R          (0xff<<16)
-#define m_COLORKEY_EN         (1<<24)
-#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
-#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
-#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
-#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
-#define v_COLORKEY_EN(x)         (((x)&1)<<24)
-
-//LCDC_DEFLICKER_SCL_OFFSET
-#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
-#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
-#define m_W1_VSD_OFFSET           (0xff<<16)
-#define m_W1_VSP_OFFSET           (0xff<<24)
-#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
-#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
-#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
-#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
-
-
-
-
-
-//AXI MS ID
-#define m_W0_YRGB_CH_ID        (0xF<<0)
-#define m_W0_CBR_CH_ID         (0xF<<4)
-#define m_W1_YRGB_CH_ID        (0xF<<8)
-#define m_W2_CH_ID             (0xF<<12)
-#define m_HWC_CH_ID            (0xF<<16)
-#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
-#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
-#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
-#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
-#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
-
-
-/* Low Bits Mask */
-#define m_WORDLO            (0xffff<<0)
-#define m_WORDHI            (0xffff<<16)
-#define v_WORDLO(x)         (((x)&0xffff)<<0)
-#define v_WORDHI(x)         (((x)&0xffff)<<16)
-
-
-//LCDC_WINx_SCL_FACTOR_Y/CBCR
-#define v_X_SCL_FACTOR(x)  ((x)<<0)
-#define v_Y_SCL_FACTOR(x)  ((x)<<16)
-
-//LCDC_DSP_HTOTAL_HS_END
-#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
-#define v_HORPRD(x) ((x)<<16)   //horizontal period
-
-
-//LCDC_DSP_HACT_ST_END
-#define v_HAEP(x) ((x)<<0)  //horizontal active end point
-#define v_HASP(x) ((x)<<16) //horizontal active start point
-
-//LCDC_DSP_VTOTAL_VS_END
-#define v_VSYNC(x) ((x)<<0)
-#define v_VERPRD(x) ((x)<<16)
-
-//LCDC_DSP_VACT_ST_END
-#define v_VAEP(x) ((x)<<0)
-#define v_VASP(x) ((x)<<16)
-
-
-//LCDC_WINx_VIR ,x is number of words of win0 virtual width
-#define v_ARGB888_VIRWIDTH(x) (x)
-#define v_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
-#define v_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
-#define v_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
-
-#define m_ACTWIDTH       (0xffff<<0)
-#define m_ACTHEIGHT      (0xffff<<16)
-#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
-#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
-
-#define m_VIRST_X      (0xffff<<0)
-#define m_VIRST_Y      (0xffff<<16)
-#define v_VIRST_X(x)      (((x)&0xffff)<<0)
-#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
-
-#define m_PANELST_X      (0x3ff<<0)
-#define m_PANELST_Y      (0x3ff<<16)
-#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
-#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
-
-#define m_PANELWIDTH       (0x3ff<<0)
-#define m_PANELHEIGHT      (0x3ff<<16)
-#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
-#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
-
-#define m_HWC_B                 (0xff<<0)
-#define m_HWC_G                 (0xff<<8)
-#define m_HWC_R                 (0xff<<16)
-#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
-#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
-#define v_HWC_B(x)                 (((x)&0xff)<<0)
-#define v_HWC_G(x)                 (((x)&0xff)<<8)
-#define v_HWC_R(x)                 (((x)&0xff)<<16)
-#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
-#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
-
-//LCDC_WIN0_ACT_INFO
-#define v_ACT_WIDTH(x)     ((x-1)<<0)
-#define v_ACT_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_INFO
-#define v_DSP_WIDTH(x)     ((x-1)<<0)
-#define v_DSP_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
-#define v_DSP_STX(x)      (x<<0)
-#define v_DSP_STY(x)      (x<<16)
-
-//Panel display scanning
-#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
-
-#define m_PANEL_END              (0x3ff<<0)
-#define m_PANEL_START            (0x3ff<<16)
-#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
-#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
-
-#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
-//-----------
-
-#define m_HSCALE_FACTOR        (0xffff<<0)
-#define m_VSCALE_FACTOR        (0xffff<<16)
-#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
-#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
-
-#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
-#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
-#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
-#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
-#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
-#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
-#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
-#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
-
-
-
-#define CalScale(x, y)	             (((u32)x*0x1000)/y)
-struct rk30_lcdc_device{
-	int id;
-	struct rk_lcdc_device_driver driver;
-	rk_screen *screen;
-	
-	//LCDC_REG *preg;         // LCDC reg base address and backup reg 
-    	//LCDC_REG regbak;
-    	void __iomem *regs;
-	void *regsbak;		//back up reg
-	int __iomem *dsp_lut_addr_base;
-
-	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
-	u32 reg_phy_base;       	// physical basic address of lcdc register
-	u32 len;               		// physical map length of lcdc register
-	spinlock_t  reg_lock;		//one time only one process allowed to config the register
-	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
-	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
-	
-	unsigned int		irq;
-
-	struct clk		*pd;				//lcdc power domain
-	struct clk		*hclk;				//lcdc AHP clk
-	struct clk		*dclk;				//lcdc dclk
-	struct clk		*aclk;				//lcdc share memory frequency
-	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
-	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
-	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
-	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
-	struct clk		*pd_display;		// display power domain
-	u32	pixclock;
-};
-
-struct lcdc_info{
-/*LCD CLK*/
-	struct rk30_lcdc_device lcdc0;
-	struct rk30_lcdc_device lcdc1;
-
-};
-
-
-struct win_set {
-	volatile u32 y_offset;
-	volatile u32 c_offset;
-};
-
-struct win0_par {
-    u32 refcount;
-    u32	pseudo_pal[16];
-    u32 y_offset;
-    u32 c_offset;
-    u32 xpos;         //size in panel
-    u32 ypos;
-    u32 xsize;        //start point in panel
-    u32 ysize;
-    enum data_format format;
-
-    wait_queue_head_t wait;
-    struct win_set mirror;
-    struct win_set displ;
-    struct win_set done;
-
-    u8 par_seted;
-    u8 addr_seted;
-};
-
-
-static inline void lcdc_writel(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);	
-	*_pv = v;
-	writel_relaxed(v,lcdc_dev->regs+offset);	
-}
-
-static inline u32 lcdc_readl(struct rk30_lcdc_device *lcdc_dev,u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);
-	v = readl_relaxed(lcdc_dev->regs+offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 lcdc_read_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-       u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
-       _v &= msk;
-       return (_v >> msk);   
-}
-
-static inline void  lcdc_set_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) |= msk;				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void lcdc_clr_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk)
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) &= (~msk);				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void  lcdc_msk_reg(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);			
-	(*_pv) &= (~msk);				
-	(*_pv) |= v;				
-	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
-}
-
-static inline void lcdc_cfg_done(struct rk30_lcdc_device *lcdc_dev) 
-{
-	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
-	dsb();						
-} 
-
-#endif
-
-
diff --git a/drivers/video/rockchip/lcdc/rk312x_lcdc.c b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
deleted file mode 100755
index 2de0ef9fbf57..000000000000
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.c
+++ /dev/null
@@ -1,2781 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk312x_lcdc.c
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * Author:      zhuangwenlong<zwl@rock-chips.com>
- *              zhengyang<zhengyang@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/common.h>
-#include <dt-bindings/clock/rk_system_status.h>
-#include <linux/rockchip-iovmm.h>
-#include "rk312x_lcdc.h"
-#include <linux/rockchip/dvfs.h>
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		pr_info(KERN_INFO x); \
-			} while (0)
-
-#define grf_writel(offset, v)	do { \
-			writel_relaxed(v, RK_GRF_VIRT + offset); \
-			dsb(); \
-			} while (0)
-
-static struct rk_lcdc_win lcdc_win[] = {
-	[0] = {
-	       .name = "win0",
-	       .id = 0,
-	       .support_3d = false,
-	       },
-	[1] = {
-	       .name = "win1",
-	       .id = 1,
-	       .support_3d = false,
-	       },
-	[2] = {
-	       .name = "hwc",
-	       .id = 2,
-	       .support_3d = false,
-	       },
-};
-
-static irqreturn_t rk312x_lcdc_isr(int irq, void *dev_id)
-{
-	struct lcdc_device *lcdc_dev = (struct lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-	u32 irq_active = 0;
-
-	irq_active = int_reg & INT_STA_MSK;
-	if (irq_active)
-		lcdc_writel(lcdc_dev, INT_STATUS,
-			    int_reg | (irq_active << INT_CLR_SHIFT));
-
-	if (int_reg & m_FS_INT_STA) {
-		timestamp = ktime_get();
-
-		/*if (lcdc_dev->driver.wait_fs) {*/
-		if (0) {
-			spin_lock(&(lcdc_dev->driver.cpl_lock));
-			complete(&(lcdc_dev->driver.frame_done));
-			spin_unlock(&(lcdc_dev->driver.cpl_lock));
-		}
-		lcdc_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-	}
-
-	if (int_reg & m_LF_INT_STA) {
-		lcdc_dev->driver.frame_time.last_framedone_t =
-				lcdc_dev->driver.frame_time.framedone_t;
-		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
-	}
-
-	if (int_reg & m_HS_INT_STA) {
-		spin_lock(&lcdc_dev->driver.cpl_lock);
-		complete(&lcdc_dev->driver.frame_done);
-		spin_unlock(&lcdc_dev->driver.cpl_lock);
-	}
-
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-	if (int_reg & m_WIN0_EMPTY_INT_STA) {
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_WIN0_EMPTY_INT_CLEAR,
-			     v_WIN0_EMPTY_INT_CLEAR(1));
-		dev_info(lcdc_dev->dev, "win0 empty irq\n");
-	} else if (int_reg & m_WIN1_EMPTY_INT_STA) {
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_WIN1_EMPTY_INT_CLEAR,
-			     v_WIN1_EMPTY_INT_CLEAR(1));
-		dev_info(lcdc_dev->dev, "win1 empty irq\n");
-	}
-#endif
-
-	return IRQ_HANDLED;
-}
-
-static int rk312x_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 1;
-	return 0;
-#endif
-	if (!lcdc_dev->clk_on) {
-		clk_prepare_enable(lcdc_dev->hclk);
-		clk_prepare_enable(lcdc_dev->dclk);
-		clk_prepare_enable(lcdc_dev->aclk);
-		clk_prepare_enable(lcdc_dev->pd);
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 0;
-	return 0;
-#endif
-	if (lcdc_dev->clk_on) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		clk_disable_unprepare(lcdc_dev->dclk);
-		clk_disable_unprepare(lcdc_dev->hclk);
-		clk_disable_unprepare(lcdc_dev->aclk);
-		clk_disable_unprepare(lcdc_dev->pd);
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	/*struct rk_screen *screen = dev_drv->cur_screen;*/
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-			mask = m_FS_INT_CLEAR | m_FS_INT_EN |
-			m_LF_INT_CLEAR | m_LF_INT_EN |
-			m_HS_INT_CLEAR | m_HS_INT_EN |
-			m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN;
-		val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1) |
-			v_LF_INT_CLEAR(1) | v_LF_INT_EN(1) |
-			v_HS_INT_CLEAR(1) | v_HS_INT_EN(1) |
-			v_BUS_ERR_INT_CLEAR(1) | v_BUS_ERR_INT_EN(0);
-		#if 0
-			mask |= m_LF_INT_NUM;
-			val  |= v_LF_INT_NUM(screen->mode.vsync_len +
-						screen->mode.upper_margin +
-						screen->mode.yres)
-		#endif
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-		mask |= m_WIN0_EMPTY_INT_EN | m_WIN1_EMPTY_INT_EN;
-		val |= v_WIN0_EMPTY_INT_EN(1) | v_WIN1_EMPTY_INT_EN(1);
-#endif
-
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
-{
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_FS_INT_CLEAR | m_FS_INT_EN |
-			m_LF_INT_CLEAR | m_LF_INT_EN |
-			m_HS_INT_CLEAR | m_HS_INT_EN |
-			m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN;
-		val = v_FS_INT_CLEAR(0) | v_FS_INT_EN(0) |
-			v_LF_INT_CLEAR(0) | v_LF_INT_EN(0) |
-			v_HS_INT_CLEAR(0) | v_HS_INT_EN(0) |
-			v_BUS_ERR_INT_CLEAR(0) | v_BUS_ERR_INT_EN(0);
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-		mask |= m_WIN0_EMPTY_INT_EN | m_WIN1_EMPTY_INT_EN;
-		val |= v_WIN0_EMPTY_INT_EN(0) | v_WIN1_EMPTY_INT_EN(0);
-#endif
-
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-	return 0;
-}
-
-
-static int win0_set_addr(struct lcdc_device *lcdc_dev, u32 addr)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, addr);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN, v_WIN0_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win1_set_addr(struct lcdc_device *lcdc_dev, u32 addr)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->soc_type == VOP_RK3036)
-		lcdc_writel(lcdc_dev, WIN1_MST, addr);
-	else
-		lcdc_writel(lcdc_dev, WIN1_MST_RK312X, addr);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN, v_WIN1_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-int rk312x_lcdc_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
-				    int win_id, u32 addr)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-				struct lcdc_device, driver);
-	if (win_id == 0)
-		win0_set_addr(lcdc_dev, addr);
-	else
-		win1_set_addr(lcdc_dev, addr);
-
-	return 0;
-}
-
-static void rk_lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
-{
-	int reg = 0;
-	u32 val = 0;
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	for (reg = 0; reg < 0xe0; reg += 4) {
-		val = lcdc_readl_backup(lcdc_dev, reg);
-		if (reg == WIN0_ACT_INFO) {
-			win0->area[0].xact = (val & m_ACT_WIDTH)+1;
-			win0->area[0].yact = ((val & m_ACT_HEIGHT)>>16)+1;
-		}
-
-		if (lcdc_dev->soc_type == VOP_RK312X) {
-			if (reg == WIN1_DSP_INFO_RK312X) {
-				win1->area[0].xact = (val & m_DSP_WIDTH) + 1;
-				win1->area[0].yact =
-					((val & m_DSP_HEIGHT) >> 16) + 1;
-			}
-		} else {
-			if (reg == WIN1_ACT_INFO) {
-				win1->area[0].xact = (val & m_ACT_WIDTH) + 1;
-				win1->area[0].yact =
-					((val & m_ACT_HEIGHT) >> 16) + 1;
-			}
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-
-static int rk312x_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
-{
-	int win0_top = 0;
-	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
-
-	int win0_alpha_en = ((win0_format == ARGB888) ||
-				(win0_format == ABGR888)) ? 1 : 0;
-	int win1_alpha_en = ((win1_format == ARGB888) ||
-				(win1_format == ABGR888)) ? 1 : 0;
-	int atv_layer_cnt = lcdc_dev->driver.win[0]->state +
-			lcdc_dev->driver.win[1]->state;
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (DSP_CTRL0 >> 2);
-	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
-	if (win0_top && (atv_layer_cnt >= 2) && (win0_alpha_en)) {
-		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask = m_WIN0_ALPHA_MODE |
-				m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
-		val = v_WIN0_ALPHA_MODE(1) |
-				v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-		/*this vop bg layer not support yuv domain overlay,so bg val
-		have to set 0x800a80 equeal to 0x000000 at rgb domian,after
-		android start we recover to 0x00000*/
-		mask = m_BG_COLOR;
-		val = v_BG_COLOR(0x000000);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-	} else if ((!win0_top) && (atv_layer_cnt >= 2) &&
-				(win1_alpha_en)) {
-		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask = m_WIN1_ALPHA_MODE |
-				m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
-		if (lcdc_dev->driver.overlay_mode == VOP_YUV_DOMAIN)
-			val = v_WIN0_ALPHA_MODE(1) |
-			      v_ALPHA_MODE_SEL0(0) |
-			      v_ALPHA_MODE_SEL1(0);
-		else
-			val = v_WIN1_ALPHA_MODE(1) |
-			      v_ALPHA_MODE_SEL0(1) |
-			      v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-		/*this vop bg layer not support yuv domain overlay,so bg val
-		have to set 0x800a80 equeal to 0x000000 at rgb domian,after
-		android start we recover to 0x00000*/
-		mask = m_BG_COLOR;
-		val = v_BG_COLOR(0x000000);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-	} else {
-		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-	}
-
-	if (lcdc_dev->driver.win[2]->state == 1) {
-		mask =  m_HWC_ALPAH_EN;
-		val = v_HWC_ALPAH_EN(1);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask =  m_HWC_ALPHA_MODE;
-		val = v_HWC_ALPHA_MODE(1);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else {
-		mask =  m_HWC_ALPAH_EN;
-		val = v_HWC_ALPAH_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-	}
-
-	return 0;
-}
-
-static void lcdc_layer_csc_mode(struct lcdc_device *lcdc_dev,
-				struct rk_lcdc_win *win)
-{
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		switch (win->area[0].fmt_cfg) {
-		case VOP_FORMAT_ARGB888:
-		case VOP_FORMAT_RGB888:
-		case VOP_FORMAT_RGB565:
-			if ((screen->mode.xres < 1280) &&
-			    (screen->mode.yres < 720)) {
-				win->csc_mode = VOP_R2Y_CSC_BT601;
-			} else {
-				win->csc_mode = VOP_R2Y_CSC_BT709;
-			}
-			break;
-		default:
-			break;
-		}
-		if (win->id  == 0) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_CSC_MODE,
-				     v_WIN0_CSC_MODE(win->csc_mode));
-		} else if (win->id  == 1) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN1_CSC_MODE,
-				     v_WIN1_CSC_MODE(win->csc_mode));
-		}
-	} else if (dev_drv->overlay_mode == VOP_RGB_DOMAIN) {
-		switch (win->area[0].fmt_cfg) {
-		case VOP_FORMAT_YCBCR420:
-			if (win->id  == 0) {
-				win->csc_mode = VOP_Y2R_CSC_MPEG;
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-					     m_WIN0_CSC_MODE,
-					v_WIN0_CSC_MODE(win->csc_mode));
-			}
-			break;
-		default:
-			break;
-		}
-	}
-}
-
-
-static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
-				   struct rk_lcdc_win *win)
-{
-	u32 mask, val;
-	int hwc_size;
-
-	if (win->state == 1) {
-		if (lcdc_dev->soc_type == VOP_RK312X)
-			lcdc_layer_csc_mode(lcdc_dev, win);
-
-		if (win->id == 0) {
-			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP |
-			        m_WIN0_UV_SWAP;
-			val = v_WIN0_EN(win->state) |
-				v_WIN0_FORMAT(win->area[0].fmt_cfg) |
-				v_WIN0_RB_SWAP(win->area[0].swap_rb) |
-				v_WIN0_UV_SWAP(win->area[0].swap_uv);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
-				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
-				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
-			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
-				    v_X_SCL_FACTOR(win->scale_cbcr_x) |
-				    v_Y_SCL_FACTOR(win->scale_cbcr_y));
-
-			lcdc_msk_reg(lcdc_dev, WIN0_VIR,
-				     m_YRGB_VIR | m_CBBR_VIR,
-				     v_YRGB_VIR(win->area[0].y_vir_stride) |
-				     v_CBCR_VIR(win->area[0].uv_vir_stride));
-			lcdc_writel(lcdc_dev, WIN0_ACT_INFO,
-				    v_ACT_WIDTH(win->area[0].xact) |
-				    v_ACT_HEIGHT(win->area[0].yact));
-			lcdc_writel(lcdc_dev, WIN0_DSP_ST,
-				    v_DSP_STX(win->area[0].dsp_stx) |
-				    v_DSP_STY(win->area[0].dsp_sty));
-			lcdc_writel(lcdc_dev, WIN0_DSP_INFO,
-				    v_DSP_WIDTH(win->area[0].xsize) |
-				    v_DSP_HEIGHT(win->area[0].ysize));
-
-			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
-				    win->area[0].y_addr);
-			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
-				    win->area[0].uv_addr);
-		} else if (win->id == 1) {
-			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
-			val = v_WIN1_EN(win->state) |
-					v_WIN1_FORMAT(win->area[0].fmt_cfg) |
-					v_WIN1_RB_SWAP(win->area[0].swap_rb);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			/* rk312x unsupport win1 scale */
-			if (lcdc_dev->soc_type == VOP_RK3036) {
-				lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB,
-					    v_X_SCL_FACTOR(win->scale_yrgb_x) |
-					    v_Y_SCL_FACTOR(win->scale_yrgb_y));
-				lcdc_writel(lcdc_dev, WIN1_ACT_INFO,
-					    v_ACT_WIDTH(win->area[0].xact) |
-					    v_ACT_HEIGHT(win->area[0].yact));
-				lcdc_writel(lcdc_dev, WIN1_DSP_INFO,
-					    v_DSP_WIDTH(win->area[0].xsize) |
-					    v_DSP_HEIGHT(win->area[0].ysize));
-				lcdc_writel(lcdc_dev, WIN1_DSP_ST,
-					    v_DSP_STX(win->area[0].dsp_stx) |
-					    v_DSP_STY(win->area[0].dsp_sty));
-				lcdc_writel(lcdc_dev,
-					    WIN1_MST, win->area[0].y_addr);
-			} else {
-				lcdc_writel(lcdc_dev, WIN1_DSP_INFO_RK312X,
-					    v_DSP_WIDTH(win->area[0].xsize) |
-					    v_DSP_HEIGHT(win->area[0].ysize));
-				lcdc_writel(lcdc_dev, WIN1_DSP_ST_RK312X,
-					    v_DSP_STX(win->area[0].dsp_stx) |
-					    v_DSP_STY(win->area[0].dsp_sty));
-
-				lcdc_writel(lcdc_dev,
-					    WIN1_MST_RK312X,
-					    win->area[0].y_addr);
-			}
-
-			lcdc_msk_reg(lcdc_dev, WIN1_VIR, m_YRGB_VIR,
-				     v_YRGB_VIR(win->area[0].y_vir_stride));
-
-
-		} else if (win->id == 2) {
-			mask = m_HWC_EN | m_HWC_LODAD_EN;
-			val = v_HWC_EN(win->state) | v_HWC_LODAD_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			if ((win->area[0].xsize == 32) &&
-			    (win->area[0].ysize == 32))
-				hwc_size = 0;
-			else if ((win->area[0].xsize == 64) &&
-				 (win->area[0].ysize == 64))
-				hwc_size = 1;
-			else
-				dev_err(lcdc_dev->dev, "unsupport hwc size:x=%d,y=%d\n",
-					win->area[0].xsize, win->area[0].ysize);
-			lcdc_writel(lcdc_dev, HWC_DSP_ST,
-				    v_DSP_STX(win->area[0].dsp_stx) |
-				    v_DSP_STY(win->area[0].dsp_sty));
-
-			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
-		}
-	} else {
-		win->area[0].y_addr = 0;
-		win->area[0].uv_addr = 0;
-		if (win->id == 0) {
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN,
-				     v_WIN0_EN(0));
-			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
-				    win->area[0].y_addr);
-			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
-				    win->area[0].uv_addr);
-		} else if (win->id == 1) {
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN,
-				     v_WIN1_EN(0));
-			 lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
-		} else if (win->id == 2) {
-			lcdc_msk_reg(lcdc_dev,
-			             SYS_CTRL, m_HWC_EN | m_HWC_LODAD_EN,
-			             v_HWC_EN(0) | v_HWC_LODAD_EN(0));
-			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
-		}
-	}
-	rk312x_lcdc_alpha_cfg(lcdc_dev);
-}
-
-static void lcdc_layer_enable(struct lcdc_device *lcdc_dev, unsigned int win_id,
-			      bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on) &&
-	    lcdc_dev->driver.win[win_id]->state != open) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev,
-					 "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt  |= (1 << win_id);
-		} else if ((lcdc_dev->atv_layer_cnt & (1 << win_id)) && (!open)) {
-			 lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
-		}
-		lcdc_dev->driver.win[win_id]->state = open;
-		if (!open) {
-			lcdc_layer_update_regs(lcdc_dev,
-					       lcdc_dev->driver.win[win_id]);
-			lcdc_cfg_done(lcdc_dev);
-		}
-		/*if no layer used,disable lcdc */
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev,
-				 "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-/*
-static int rk312x_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-	int timeout;
-	unsigned long flags;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(lcdc_dev->standby));
-		lcdc_layer_update_regs(lcdc_dev, win0);
-		lcdc_layer_update_regs(lcdc_dev, win1);
-		rk312x_lcdc_alpha_cfg(lcdc_dev);
-		lcdc_cfg_done(lcdc_dev);
-
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	//if (dev_drv->wait_fs) {
-	if (0) {
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-						      msecs_to_jiffies
-						      (dev_drv->cur_screen->ft +
-						       5));
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_warn(lcdc_dev->dev,
-				 "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
-	return 0;
-
-}*/
-
-static void rk312x_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
-{
-	memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0xe0);
-}
-
-static int rk312x_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	/*spin_lock(&lcdc_dev->reg_lock);*/
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_MMU_EN | m_AXI_MAX_OUTSTANDING_EN |
-			m_AXI_OUTSTANDING_MAX_NUM;
-		val = v_MMU_EN(1) | v_AXI_OUTSTANDING_MAX_NUM(31) |
-			v_AXI_MAX_OUTSTANDING_EN(1);
-		lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-	}
-	/*spin_unlock(&lcdc_dev->reg_lock);*/
-	if (dev_drv->iommu_enabled) {
-		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
-			lcdc_dev->iommu_status = 1;
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
-				   int *hwc_lut, int mode)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	int len = 256*4;
-	struct lcdc_device *lcdc_dev =
-			container_of(dev_drv, struct lcdc_device, driver);
-	if (dev_drv->hwc_lut == NULL)
-		dev_drv->hwc_lut = devm_kzalloc(lcdc_dev->dev, len, GFP_KERNEL);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 256; i++) {
-		if (mode == 1)
-			dev_drv->hwc_lut[i] = hwc_lut[i];
-		v = dev_drv->hwc_lut[i];
-		c = lcdc_dev->hwc_lut_addr_base + i;
-		writel_relaxed(v, c);
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk312x_lcdc_set_lut(struct rk_lcdc_driver *dev_drv,
-			       int *dsp_lut)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-
-	if (!dsp_lut)
-		return 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 256; i++) {
-		v = dsp_lut[i];
-		c = lcdc_dev->dsp_lut_addr_base + i;
-		writel_relaxed(v, c);
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk312x_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv,
-				    int reset_rate)
-{
-#ifdef CONFIG_RK_FPGA
-	return 0;
-#endif
-	int ret, fps;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (reset_rate)
-		ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	return 0;
-}
-
-static int rk312x_lcdc_standby(struct rk_lcdc_driver *dev_drv, bool enable)
-{
-	struct lcdc_device *vop_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-	int timeout;
-	unsigned long flags;
-
-	if (unlikely(!vop_dev->clk_on))
-		return 0;
-
-	if (dev_drv->standby && !enable) {
-		dev_drv->standby = 0;
-		lcdc_msk_reg(vop_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(0));
-		return 0;
-	} else if (!dev_drv->standby && enable) {
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-
-		lcdc_msk_reg(vop_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(1));
-		/* wait for standby hold valid */
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-						      msecs_to_jiffies(25));
-
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_info(dev_drv->dev,
-				 "wait for standy hold valid start time out!\n");
-			return -ETIMEDOUT;
-		}
-
-		dev_drv->standby = 1;
-	}
-
-	return 0;
-}
-
-/********do basic init*********/
-static int rk312x_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	if (lcdc_dev->pre_init)
-		return 0;
-
-	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
-	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
-	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
-	lcdc_dev->sclk = devm_clk_get(lcdc_dev->dev, "sclk_lcdc");
-	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
-	lcdc_dev->pll_sclk = devm_clk_get(lcdc_dev->dev, "sclk_pll");
-
-	if (/*IS_ERR(lcdc_dev->pd) || */ (IS_ERR(lcdc_dev->aclk)) ||
-	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
-			lcdc_dev->id);
-	}
-
-	rk_disp_pwr_enable(dev_drv);
-	rk312x_lcdc_clk_enable(lcdc_dev);
-
-	/* backup reg config at uboot */
-	rk_lcdc_read_reg_defalut_cfg(lcdc_dev);
-
-	/* config for the FRC mode of dither down */
-	lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
-	lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
-	lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0x55aaaa55);
-	lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x55aaaa55);
-	lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
-	lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
-
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN, v_AUTO_GATING_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	/*if (dev_drv->iommu_enabled)
-		{// disable all wins to workaround iommu pagefault
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN1_EN,
-			     v_WIN0_EN(0) | v_WIN1_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-		while(lcdc_readl(lcdc_dev, SYS_CTRL) & (m_WIN0_EN | m_WIN1_EN));
-	}*/
-	if ((dev_drv->ops->open_bcsh) && (dev_drv->output_color == COLOR_YCBCR)) {
-		if (support_uboot_display())
-			dev_drv->bcsh_init_status = 1;
-		else
-			dev_drv->ops->open_bcsh(dev_drv, 1);
-	}
-	lcdc_dev->pre_init = true;
-
-	return 0;
-}
-
-static void rk312x_lcdc_deinit(struct lcdc_device *lcdc_dev)
-{
-	rk312x_lcdc_disable_irq(lcdc_dev);
-}
-
-static u32 calc_sclk_freq(struct rk_screen *src_screen,
-			  struct rk_screen *dst_screen)
-{
-	u32 dsp_vtotal;
-	u64 dsp_htotal;
-	u32 dsp_in_vtotal;
-	u64 dsp_in_htotal;
-	u64 sclk_freq;
-
-	if (!src_screen || !dst_screen)
-		return 0;
-
-	dsp_vtotal = dst_screen->mode.yres;
-	dsp_htotal = dst_screen->mode.left_margin + dst_screen->mode.hsync_len +
-			dst_screen->mode.xres + dst_screen->mode.right_margin;
-	dsp_in_vtotal = src_screen->mode.yres;
-	dsp_in_htotal = src_screen->mode.left_margin +
-			src_screen->mode.hsync_len +
-			src_screen->mode.xres + src_screen->mode.right_margin;
-	sclk_freq = dsp_vtotal * dsp_htotal * src_screen->mode.pixclock;
-	do_div(sclk_freq, dsp_in_vtotal * dsp_in_htotal);
-
-	return (u32)sclk_freq;
-}
-
-#define SCLK_PLL_LIMIT		594000000
-#define GPU_FREQ_MAX_LIMIT	297000000
-#define GPU_FREQ_NEED		400000000
-
-static u32 calc_sclk_pll_freq(u32 sclk_freq)
-{
-	u32 multi_num;
-
-	if (sclk_freq < (SCLK_PLL_LIMIT / 10)) {
-		return (sclk_freq * 10);
-	} else {
-		multi_num = GPU_FREQ_NEED / sclk_freq;
-		return (sclk_freq * multi_num);
-	}
-}
-
-static int calc_dsp_frm_vst_hst(struct rk_screen *src,
-				struct rk_screen *dst, u32 sclk_freq)
-{
-	u32 BP_in, BP_out;
-	u32 v_scale_ratio;
-	long long T_frm_st;
-	u64 T_BP_in, T_BP_out, T_Delta, Tin;
-	u32 src_pixclock, dst_pixclock;
-	u64 temp;
-	u32 dsp_htotal, dsp_vtotal, src_htotal, src_vtotal;
-
-	if (unlikely(!src) || unlikely(!dst))
-		return -1;
-
-	src_pixclock = div_u64(1000000000000llu, src->mode.pixclock);
-	dst_pixclock = div_u64(1000000000000llu, sclk_freq);
-	dsp_htotal = dst->mode.left_margin + dst->mode.hsync_len +
-		     dst->mode.xres + dst->mode.right_margin;
-	dsp_vtotal = dst->mode.upper_margin + dst->mode.vsync_len +
-		     dst->mode.yres + dst->mode.lower_margin;
-	src_htotal = src->mode.left_margin + src->mode.hsync_len +
-		     src->mode.xres + src->mode.right_margin;
-	src_vtotal = src->mode.upper_margin + src->mode.vsync_len +
-		     src->mode.yres + src->mode.lower_margin;
-	BP_in  = (src->mode.upper_margin + src->mode.vsync_len) * src_htotal +
-		 src->mode.hsync_len + src->mode.left_margin;
-	BP_out = (dst->mode.upper_margin + dst->mode.vsync_len) * dsp_htotal +
-		 dst->mode.hsync_len + dst->mode.left_margin;
-
-	T_BP_in = BP_in * src_pixclock;
-	T_BP_out = BP_out * dst_pixclock;
-	Tin = src_vtotal * src_htotal * src_pixclock;
-
-	v_scale_ratio = src->mode.yres / dst->mode.yres;
-	if (v_scale_ratio <= 2)
-		T_Delta = 5 * src_htotal * src_pixclock;
-	else
-		T_Delta = 12 * src_htotal * src_pixclock;
-
-	if (T_BP_in + T_Delta > T_BP_out)
-		T_frm_st = (T_BP_in + T_Delta - T_BP_out);
-	else
-		T_frm_st = Tin - (T_BP_out - (T_BP_in + T_Delta));
-
-	/* (T_frm_st = scl_vst * src_htotal * src_pixclock +
-						scl_hst * src_pixclock) */
-	temp = do_div(T_frm_st, src_pixclock);
-	temp = do_div(T_frm_st, src_htotal);
-	dst->scl_hst = temp - 1;
-	dst->scl_vst = T_frm_st;
-
-	return 0;
-}
-
-static int rk312x_lcdc_set_scaler(struct rk_lcdc_driver *dev_drv,
-				  struct rk_screen *dst_screen, bool enable)
-{
-	u32 dsp_htotal, dsp_hs_end, dsp_hact_st, dsp_hact_end;
-	u32 dsp_vtotal, dsp_vs_end, dsp_vact_st, dsp_vact_end;
-	u32 dsp_hbor_end, dsp_hbor_st, dsp_vbor_end, dsp_vbor_st;
-	u32 scl_v_factor, scl_h_factor;
-	u32 dst_frame_hst, dst_frame_vst;
-	u32 src_w, src_h, dst_w, dst_h;
-	u16 bor_right = 0;
-	u16 bor_left = 0;
-	u16 bor_up = 0;
-	u16 bor_down = 0;
-	u32 pll_freq = 0;
-	struct rk_screen *src;
-	struct rk_screen *dst;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct dvfs_node *gpu_clk = clk_get_dvfs_node("clk_gpu");
-
-	if (unlikely(!lcdc_dev->clk_on))
-		return 0;
-
-	if (!enable) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
-			     m_SCALER_EN | m_SCALER_OUT_ZERO |
-					m_SCALER_OUT_EN,
-					v_SCALER_EN(0) | v_SCALER_OUT_ZERO(1) |
-					v_SCALER_OUT_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-		if (lcdc_dev->sclk_on) {
-			clk_disable_unprepare(lcdc_dev->sclk);
-			lcdc_dev->sclk_on = false;
-		}
-
-		/* switch pll freq as default when sclk is no used */
-		if (clk_get_rate(lcdc_dev->pll_sclk) != GPU_FREQ_NEED) {
-			dvfs_clk_enable_limit(gpu_clk, GPU_FREQ_MAX_LIMIT,
-					      GPU_FREQ_MAX_LIMIT);
-			clk_set_rate(lcdc_dev->pll_sclk, GPU_FREQ_NEED);
-			dvfs_clk_enable_limit(gpu_clk, 0, -1);
-		}
-		dev_dbg(lcdc_dev->dev, "%s: disable\n", __func__);
-		return 0;
-	}
-
-	/*
-	 * rk312x used one lcdc to apply dual disp
-	 * hdmi screen is used for scaler src
-	 * prmry screen is used for scaler dst
-	 */
-	dst = dst_screen;
-	src = dev_drv->cur_screen;
-	if (!dst || !src) {
-		dev_err(lcdc_dev->dev, "%s: dst screen is null!\n", __func__);
-		return -EINVAL;
-	}
-
-	if (!lcdc_dev->sclk_on) {
-		clk_prepare_enable(lcdc_dev->sclk);
-		lcdc_dev->s_pixclock = calc_sclk_freq(src, dst);
-		pll_freq = calc_sclk_pll_freq(lcdc_dev->s_pixclock);
-
-		/* limit gpu freq */
-		dvfs_clk_enable_limit(gpu_clk,
-				      GPU_FREQ_MAX_LIMIT,
-				      GPU_FREQ_MAX_LIMIT);
-		/* set pll freq */
-		clk_set_rate(lcdc_dev->pll_sclk, pll_freq);
-		/* cancel limit gpu freq */
-		dvfs_clk_enable_limit(gpu_clk, 0, -1);
-
-		clk_set_rate(lcdc_dev->sclk, lcdc_dev->s_pixclock);
-		lcdc_dev->sclk_on = true;
-		dev_info(lcdc_dev->dev, "%s:sclk=%d\n", __func__,
-			 lcdc_dev->s_pixclock);
-	}
-
-	/* config scale timing */
-	calc_dsp_frm_vst_hst(src, dst, lcdc_dev->s_pixclock);
-	dst_frame_vst = dst->scl_vst;
-	dst_frame_hst = dst->scl_hst;
-
-	dsp_htotal    = dst->mode.hsync_len + dst->mode.left_margin +
-			dst->mode.xres + dst->mode.right_margin;
-	dsp_hs_end    = dst->mode.hsync_len;
-
-	dsp_vtotal    = dst->mode.vsync_len + dst->mode.upper_margin +
-			dst->mode.yres + dst->mode.lower_margin;
-	dsp_vs_end    = dst->mode.vsync_len;
-
-	dsp_hbor_end  = dst->mode.hsync_len + dst->mode.left_margin +
-			dst->mode.xres;
-	dsp_hbor_st   = dst->mode.hsync_len + dst->mode.left_margin;
-	dsp_vbor_end  = dst->mode.vsync_len + dst->mode.upper_margin +
-			dst->mode.yres;
-	dsp_vbor_st   = dst->mode.vsync_len + dst->mode.upper_margin;
-
-	dsp_hact_st   = dsp_hbor_st  + bor_left;
-	dsp_hact_end  = dsp_hbor_end - bor_right;
-	dsp_vact_st   = dsp_vbor_st  + bor_up;
-	dsp_vact_end  = dsp_vbor_end - bor_down;
-
-	src_w = src->mode.xres;
-	src_h = src->mode.yres;
-	dst_w = dsp_hact_end - dsp_hact_st;
-	dst_h = dsp_vact_end - dsp_vact_st;
-
-	/* calc scale factor */
-	scl_h_factor = ((src_w - 1) << 12) / (dst_w - 1);
-	scl_v_factor = ((src_h - 1) << 12) / (dst_h - 1);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (dst->color_mode != src->color_mode) {
-		/*dev_drv->output_color = dst->color_mode;
-		if (dev_drv->output_color == COLOR_YCBCR)
-			dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-		else
-			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_SW_OVERLAY_MODE,
-			     v_SW_OVERLAY_MODE(dev_drv->overlay_mode));*/
-	}
-
-	lcdc_writel(lcdc_dev, SCALER_FACTOR,
-		    v_SCALER_H_FACTOR(scl_h_factor) |
-		    v_SCALER_V_FACTOR(scl_v_factor));
-
-	lcdc_writel(lcdc_dev, SCALER_FRAME_ST,
-		    v_SCALER_FRAME_HST(dst_frame_hst) |
-		    v_SCALER_FRAME_VST(dst_frame_vst));
-	lcdc_writel(lcdc_dev, SCALER_DSP_HOR_TIMING,
-		    v_SCALER_HS_END(dsp_hs_end) |
-		    v_SCALER_HTOTAL(dsp_htotal));
-	lcdc_writel(lcdc_dev, SCALER_DSP_HACT_ST_END,
-		    v_SCALER_HAEP(dsp_hact_end) |
-		    v_SCALER_HASP(dsp_hact_st));
-	lcdc_writel(lcdc_dev, SCALER_DSP_VER_TIMING,
-		    v_SCALER_VS_END(dsp_vs_end) |
-		    v_SCALER_VTOTAL(dsp_vtotal));
-	lcdc_writel(lcdc_dev, SCALER_DSP_VACT_ST_END,
-		    v_SCALER_VAEP(dsp_vact_end) |
-		    v_SCALER_VASP(dsp_vact_st));
-	lcdc_writel(lcdc_dev, SCALER_DSP_HBOR_TIMING,
-		    v_SCALER_HBOR_END(dsp_hbor_end) |
-		    v_SCALER_HBOR_ST(dsp_hbor_st));
-	lcdc_writel(lcdc_dev, SCALER_DSP_VBOR_TIMING,
-		    v_SCALER_VBOR_END(dsp_vbor_end) |
-		    v_SCALER_VBOR_ST(dsp_vbor_st));
-	lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
-		     m_SCALER_VSYNC_VST | m_SCALER_VSYNC_MODE,
-		     v_SCALER_VSYNC_VST(4) | v_SCALER_VSYNC_MODE(2));
-	lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
-		     m_SCALER_EN | m_SCALER_OUT_ZERO |
-		     m_SCALER_OUT_EN,
-		     v_SCALER_EN(1) | v_SCALER_OUT_ZERO(0) |
-		     v_SCALER_OUT_EN(1));
-
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static void rk312x_lcdc_select_bcsh(struct rk_lcdc_driver *dev_drv,
-				    struct lcdc_device *lcdc_dev)
-{
-	u32 bcsh_ctrl;
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		if (IS_YUV_COLOR(dev_drv->output_color))/* bypass */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_Y2R_EN | m_BCSH_R2Y_EN,
-				     v_BCSH_Y2R_EN(0) | v_BCSH_R2Y_EN(0));
-	else	/* YUV2RGB */
-		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-			     m_BCSH_Y2R_EN | m_BCSH_Y2R_CSC_MODE |
-			     m_BCSH_R2Y_EN,
-			     v_BCSH_Y2R_EN(1) |
-			     v_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-			     v_BCSH_R2Y_EN(0));
-	} else {	/* overlay_mode=VOP_RGB_DOMAIN */
-		if (dev_drv->output_color == COLOR_RGB) {
-			/* bypass */
-			bcsh_ctrl = lcdc_readl(lcdc_dev, BCSH_CTRL);
-			if (((bcsh_ctrl&m_BCSH_EN) == 1) ||
-				(dev_drv->bcsh.enable == 1))/*bcsh enabled*/
-				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     	m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-				     	v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(1));
-			else/*bcsh disabled*/
-				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     	m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-				     	v_BCSH_R2Y_EN(0) | v_BCSH_Y2R_EN(0));
-		} else	/* RGB2YUV */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_R2Y_EN |
-					m_BCSH_R2Y_CSC_MODE | m_BCSH_Y2R_EN,
-					v_BCSH_R2Y_EN(1) |
-					v_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-					v_BCSH_Y2R_EN(0));
-		}
-}
-
-static int rk312x_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
-				  u16 *yact, int *format, u32 *dsp_addr,
-				  int *ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-
-	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-	*xact = (val & m_ACT_WIDTH)+1;
-	*yact = ((val & m_ACT_HEIGHT)>>16)+1;
-
-	val = lcdc_readl(lcdc_dev, SYS_CTRL);
-
-	*format = (val & m_WIN0_FORMAT) >> 3;
-	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk312x_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			      int format, u16 xact, u16 yact, u16 xvir,
-			      int ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[0];
-	u32 val, mask;
-
-	mask = m_WIN0_FORMAT;
-	val = v_WIN0_FORMAT(format);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-
-	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_YRGB_VIR,
-			v_YRGB_VIR(xvir));
-	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_ACT_WIDTH(xact) |
-		    v_ACT_HEIGHT(yact));
-
-	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
-
-	lcdc_cfg_done(lcdc_dev);
-	win->state = 1;
-	win->last_state = 1;
-
-	return 0;
-}
-
-static int rk312x_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	u16 face = 0;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 right_margin = screen->mode.right_margin;
-	u16 left_margin = screen->mode.left_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		/* Select output color domain */
-		dev_drv->output_color = screen->color_mode;
-		/*if (lcdc_dev->soc_type == VOP_RK312X) {
-			if (dev_drv->output_color == COLOR_YCBCR)
-				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-			else
-				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-		} else {
-			dev_drv->output_color = COLOR_RGB;
-			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-		}*/
-		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-		/*something wrong at yuv domain*/
-
-		switch (screen->type) {
-		case SCREEN_RGB:
-			if (lcdc_dev->soc_type == VOP_RK312X) {
-				mask = m_RGB_DCLK_EN | m_RGB_DCLK_INVERT;
-				val = v_RGB_DCLK_EN(1) | v_RGB_DCLK_INVERT(0);
-				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			}
-			break;
-		case SCREEN_LVDS:
-			if (lcdc_dev->soc_type == VOP_RK312X) {
-				mask = m_LVDS_DCLK_EN | m_LVDS_DCLK_INVERT;
-				val = v_LVDS_DCLK_EN(1) | v_LVDS_DCLK_INVERT(1);
-				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			}
-			break;
-		case SCREEN_MIPI:
-			if (lcdc_dev->soc_type == VOP_RK312X) {
-				mask = m_MIPI_DCLK_EN | m_MIPI_DCLK_INVERT;
-				val = v_MIPI_DCLK_EN(1) | v_MIPI_DCLK_INVERT(0);
-				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			}
-			break;
-		case SCREEN_HDMI:
-			mask = m_HDMI_DCLK_EN;
-			val = v_HDMI_DCLK_EN(1);
-			if (screen->pixelrepeat) {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(1);
-			} else {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(0);
-			}
-			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			if (lcdc_dev->soc_type == VOP_RK312X) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_SW_UV_OFFSET_EN,
-				     v_SW_UV_OFFSET_EN(0));
-				mask = m_HDMI_HSYNC_POL | m_HDMI_VSYNC_POL |
-				       m_HDMI_DEN_POL;
-				val = v_HDMI_HSYNC_POL(screen->pin_hsync) |
-				      v_HDMI_VSYNC_POL(screen->pin_vsync) |
-				      v_HDMI_DEN_POL(screen->pin_den);
-				lcdc_msk_reg(lcdc_dev, INT_SCALER, mask, val);
-			} else {
-				mask = (1 << 4) | (1 << 5) | (1 << 6);
-				val = (screen->pin_hsync << 4) |
-					(screen->pin_vsync << 5) |
-					(screen->pin_den << 6);
-				grf_writel(RK3036_GRF_SOC_CON2,
-					   (mask << 16) | val);
-			}
-			rk312x_lcdc_select_bcsh(dev_drv,  lcdc_dev);
-			break;
-		case SCREEN_TVOUT:
-		case SCREEN_TVOUT_TEST:
-			mask = m_TVE_DAC_DCLK_EN;
-			val = v_TVE_DAC_DCLK_EN(1);
-			if (screen->pixelrepeat) {
-				mask |= m_CORE_CLK_DIV_EN;
-				val |= v_CORE_CLK_DIV_EN(1);
-			}
-			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
-			if (x_res == 720 && y_res == 576)
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_TVE_MODE,
-					     v_TVE_MODE(TV_PAL));
-			else if (x_res == 720 && y_res == 480)
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_TVE_MODE,
-					     v_TVE_MODE(TV_NTSC));
-			else {
-				dev_err(lcdc_dev->dev,
-					"unsupported video timing!\n");
-				return -1;
-			}
-			if (lcdc_dev->soc_type == VOP_RK312X) {
-				if (screen->type == SCREEN_TVOUT_TEST)
-			/*for TVE index test,vop must ovarlay at yuv domain*/
-					dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-					lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-						     m_SW_UV_OFFSET_EN,
-						     v_SW_UV_OFFSET_EN(1));
-
-			rk312x_lcdc_select_bcsh(dev_drv, lcdc_dev);
-			}
-			break;
-		default:
-			dev_err(lcdc_dev->dev, "un supported interface!\n");
-			break;
-		}
-		if (lcdc_dev->soc_type == VOP_RK312X) {
-			switch (dev_drv->screen0->face) {
-			case OUT_P565:
-				face = OUT_P565;
-				mask = m_DITHER_DOWN_EN |
-				       m_DITHER_DOWN_MODE |
-				       m_DITHER_DOWN_SEL;
-				val = v_DITHER_DOWN_EN(1) |
-				      v_DITHER_DOWN_MODE(0) |
-				      v_DITHER_DOWN_SEL(1);
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-				break;
-			case OUT_P666:
-				face = OUT_P666;
-				mask = m_DITHER_DOWN_EN |
-				       m_DITHER_DOWN_MODE |
-				       m_DITHER_DOWN_SEL;
-				val = v_DITHER_DOWN_EN(1) |
-				      v_DITHER_DOWN_MODE(1) |
-				      v_DITHER_DOWN_SEL(1);
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-				break;
-			case OUT_D888_P565:
-				face = OUT_P888;
-				mask = m_DITHER_DOWN_EN |
-				       m_DITHER_DOWN_MODE |
-				       m_DITHER_DOWN_SEL;
-				val = v_DITHER_DOWN_EN(1) |
-				      v_DITHER_DOWN_MODE(0) |
-				      v_DITHER_DOWN_SEL(1);
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-				break;
-			case OUT_D888_P666:
-				face = OUT_P888;
-				mask = m_DITHER_DOWN_EN |
-				       m_DITHER_DOWN_MODE |
-				       m_DITHER_DOWN_SEL;
-				val = v_DITHER_DOWN_EN(1) |
-				      v_DITHER_DOWN_MODE(1) |
-				      v_DITHER_DOWN_SEL(1);
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-				break;
-			case OUT_P888:
-				face = OUT_P888;
-				mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
-				val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-				break;
-			default:
-				dev_err(lcdc_dev->dev, "un supported interface!\n");
-				break;
-			}
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_SW_OVERLAY_MODE,
-				     v_SW_OVERLAY_MODE(dev_drv->overlay_mode));
-		}
-
-		mask = m_HSYNC_POL | m_VSYNC_POL |
-		       m_DEN_POL | m_DCLK_POL;
-		val = v_HSYNC_POL(screen->pin_hsync) |
-		      v_VSYNC_POL(screen->pin_vsync) |
-		      v_DEN_POL(screen->pin_den) |
-		      v_DCLK_POL(screen->pin_dclk);
-
-		if (screen->type != SCREEN_HDMI) {
-			mask |= m_DSP_OUT_FORMAT;
-			val |= v_DSP_OUT_FORMAT(face);
-		}
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-
-		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
-		       m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		       m_DSP_DUMMY_SWAP | m_BLANK_EN | m_BLACK_EN;
-
-		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
-		      v_DSP_RB_SWAP(screen->swap_rb) |
-		      v_DSP_RG_SWAP(screen->swap_rg) |
-		      v_DSP_DELTA_SWAP(screen->swap_delta) |
-		      v_DSP_DUMMY_SWAP(screen->swap_dumy) |
-		      v_BLANK_EN(0) | v_BLACK_EN(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-
-		/* config timing */
-		val = v_HSYNC(screen->mode.hsync_len) |
-		      v_HORPRD(screen->mode.hsync_len + left_margin + x_res +
-				right_margin);
-		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
-		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
-		      v_HASP(screen->mode.hsync_len + left_margin);
-		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
-
-		if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-			/* First Field Timing */
-			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END,
-				    v_VSYNC(screen->mode.vsync_len) |
-				    v_VERPRD(2 * (screen->mode.vsync_len +
-						  upper_margin +
-						  lower_margin) + y_res + 1));
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END,
-				    v_VAEP(screen->mode.vsync_len +
-					   upper_margin + y_res / 2) |
-				    v_VASP(screen->mode.vsync_len +
-					   upper_margin));
-			/* Second Field Timing */
-			lcdc_writel(lcdc_dev, DSP_VS_ST_END_F1,
-				    v_VSYNC_ST_F1(screen->mode.vsync_len +
-						  upper_margin + y_res / 2 +
-						lower_margin) |
-				    v_VSYNC_END_F1(2 * screen->mode.vsync_len +
-						   upper_margin + y_res / 2 +
-						   lower_margin));
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END_F1,
-				    v_VAEP(2 * (screen->mode.vsync_len +
-						upper_margin) +
-						y_res + lower_margin + 1) |
-				    v_VASP(2 * (screen->mode.vsync_len +
-						upper_margin) +
-						y_res / 2 + lower_margin + 1));
-
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_INTERLACE_DSP_EN |
-				     m_WIN0_YRGB_DEFLICK_EN |
-				     m_WIN0_CBR_DEFLICK_EN |
-				     m_INTERLACE_FIELD_POL |
-				     m_WIN0_INTERLACE_EN |
-				     m_WIN1_INTERLACE_EN,
-				     v_INTERLACE_DSP_EN(1) |
-				     v_WIN0_YRGB_DEFLICK_EN(1) |
-				     v_WIN0_CBR_DEFLICK_EN(1) |
-				     v_INTERLACE_FIELD_POL(0) |
-				     v_WIN0_INTERLACE_EN(1) |
-				     v_WIN1_INTERLACE_EN(1));
-			mask = m_LF_INT_NUM;
-			val = v_LF_INT_NUM(screen->mode.vsync_len +
-					   screen->mode.upper_margin +
-					   screen->mode.yres/2);
-			lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		} else {
-			val = v_VSYNC(screen->mode.vsync_len) |
-			      v_VERPRD(screen->mode.vsync_len + upper_margin +
-				     y_res + lower_margin);
-			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
-
-			val = v_VAEP(screen->mode.vsync_len +
-				     upper_margin + y_res) |
-			      v_VASP(screen->mode.vsync_len + upper_margin);
-			lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
-
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_INTERLACE_DSP_EN |
-				     m_WIN0_YRGB_DEFLICK_EN |
-				     m_WIN0_CBR_DEFLICK_EN |
-				     m_INTERLACE_FIELD_POL |
-				     m_WIN0_INTERLACE_EN |
-				     m_WIN1_INTERLACE_EN,
-				     v_INTERLACE_DSP_EN(0) |
-				     v_WIN0_YRGB_DEFLICK_EN(0) |
-				     v_WIN0_CBR_DEFLICK_EN(0) |
-				     v_INTERLACE_FIELD_POL(0) |
-				     v_WIN0_INTERLACE_EN(0) |
-				     v_WIN1_INTERLACE_EN(0));
-			mask = m_LF_INT_NUM;
-			val = v_LF_INT_NUM(screen->mode.vsync_len +
-					   screen->mode.upper_margin +
-					   screen->mode.yres);
-			lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	rk312x_lcdc_set_dclk(dev_drv, 1);
-	lcdc_cfg_done(lcdc_dev);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-
-	return 0;
-}
-
-static int rk312x_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
-			    bool open)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-
-	/* enable clk,when first layer open */
-	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
-		rockchip_set_system_status(SYS_STATUS_LCDC0);
-		rk312x_lcdc_pre_init(dev_drv);
-		rk312x_lcdc_clk_enable(lcdc_dev);
-		if (dev_drv->iommu_enabled) {
-			if (!dev_drv->mmu_dev) {
-				dev_drv->mmu_dev =
-					rk_fb_get_sysmmu_device_by_compatible(dev_drv->mmu_dts_name);
-				if (dev_drv->mmu_dev) {
-					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
-								  dev_drv->dev);
-				} else {
-					dev_err(dev_drv->dev,
-						"failed to get rockchip iommu device\n");
-					return -1;
-				}
-			}
-			/*if (dev_drv->mmu_dev)
-				rockchip_iovmm_activate(dev_drv->dev);*/
-		}
-		rk312x_lcdc_reg_restore(lcdc_dev);
-		/*if (dev_drv->iommu_enabled)
-			rk312x_lcdc_mmu_en(dev_drv);*/
-		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
-			rk312x_lcdc_set_dclk(dev_drv, 0);
-			rk312x_lcdc_enable_irq(dev_drv);
-		} else {
-			dev_drv->standby = 1;
-			rk312x_load_screen(dev_drv, 1);
-			rk312x_lcdc_standby(dev_drv, false);
-		}
-
-		/* set screen lut */
-		if (dev_drv->cur_screen->dsp_lut)
-			rk312x_lcdc_set_lut(dev_drv,
-					    dev_drv->cur_screen->dsp_lut);
-	}
-
-	if (win_id < ARRAY_SIZE(lcdc_win))
-		lcdc_layer_enable(lcdc_dev, win_id, open);
-	else
-		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
-
-	/* when all layer closed,disable clk */
-/*	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
-		rk312x_lcdc_disable_irq(lcdc_dev);
-		rk312x_lcdc_reg_update(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-		rk312x_lcdc_clk_disable(lcdc_dev);
-		rockchip_clear_system_status(SYS_STATUS_LCDC0);
-	}*/
-	return 0;
-}
-
-static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	struct rk_lcdc_win *win = NULL;
-	char fmt[9] = "NULL";
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-	} else if (win_id == 1) {
-		win = dev_drv->win[1];
-	} else if (win_id == 2) {
-		win = dev_drv->win[2];
-	} else {
-		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
-		return -EINVAL;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
-			       screen->mode.hsync_len;
-	if (win_id == 1) {
-                if ((win->area[0].xact != win->area[0].xsize) ||
-                    (win->area[0].yact != win->area[0].ysize)) {
-                        pr_err("win[1],not support scale\n");
-                        pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
-                                win->area[0].xact,win->area[0].yact,
-                                win->area[0].xsize,win->area[0].ysize);
-                        win->area[0].xsize = win->area[0].xact;
-                        win->area[0].ysize = win->area[0].yact;
-                    }
-	}
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		win->area[0].ysize /= 2;
-		win->area[0].dsp_sty = win->area[0].ypos / 2 +
-				       screen->mode.upper_margin +
-				       screen->mode.vsync_len;
-	} else {
-		win->area[0].dsp_sty = win->area[0].ypos +
-				       screen->mode.upper_margin +
-				       screen->mode.vsync_len;
-	}
-	win->scale_yrgb_x = CalScale(win->area[0].xact, win->area[0].xsize);
-	win->scale_yrgb_y = CalScale(win->area[0].yact, win->area[0].ysize);
-
-	switch (win->area[0].format) {
-	case ARGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 0;
-		win->area[0].swap_uv = 0;
-		break;
-	case XBGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 1;
-		win->area[0].swap_uv = 0;
-		break;
-	case ABGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 1;
-		win->area[0].swap_uv = 0;
-		break;
-	case RGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
-		win->area[0].swap_rb = 0;
-		win->area[0].swap_uv = 0;
-		break;
-	case RGB565:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
-		win->area[0].swap_rb = 0;
-		break;
-	case YUV444:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
-			win->scale_cbcr_x =
-			    CalScale(win->area[0].xact, win->area[0].xsize);
-			win->scale_cbcr_y =
-			    CalScale(win->area[0].yact, win->area[0].ysize);
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n", __func__);
-		}
-		break;
-	case YUV422:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
-			win->scale_cbcr_x = CalScale((win->area[0].xact / 2),
-					    win->area[0].xsize);
-			win->scale_cbcr_y =
-			    CalScale(win->area[0].yact, win->area[0].ysize);
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n", __func__);
-		}
-		break;
-	case YUV420:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
-			win->scale_cbcr_x =
-			    CalScale(win->area[0].xact / 2, win->area[0].xsize);
-			win->scale_cbcr_y =
-			    CalScale(win->area[0].yact / 2, win->area[0].ysize);
-			win->area[0].swap_rb = 0;
-		        win->area[0].swap_uv = 0;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n", __func__);
-		}
-		break;
-	case YUV420_NV21:
-		if (win_id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
-			win->scale_cbcr_x =
-			    CalScale(win->area[0].xact / 2, win->area[0].xsize);
-			win->scale_cbcr_y =
-			    CalScale(win->area[0].yact / 2, win->area[0].ysize);
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 1;
-		} else {
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n", __func__);
-		}
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-			__func__);
-		break;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(1,
-	    "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-	    ">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id, __func__,
-	    get_format_string(win->area[0].format, fmt), win->area[0].xact,
-	    win->area[0].yact, win->area[0].xsize, win->area[0].ysize,
-	    win->area[0].xvir, win->area[0].yvir, win->area[0].xpos,
-	    win->area[0].ypos);
-	return 0;
-}
-
-static int rk312x_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-	} else if (win_id == 1) {
-		win = dev_drv->win[1];
-	} else if (win_id == 2) {
-		win = dev_drv->win[2];
-	} else {
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr =
-		    win->area[0].smem_start + win->area[0].y_offset;
-		win->area[0].uv_addr =
-		    win->area[0].cbr_start + win->area[0].c_offset;
-		if (win->area[0].y_addr)
-			lcdc_layer_update_regs(lcdc_dev, win);
-		/* lcdc_cfg_done(lcdc_dev); */
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
-	    lcdc_dev->id, __func__, win->area[0].y_addr, win->area[0].uv_addr,
-	    win->area[0].y_offset);
-	/* this is the first frame of the system,enable frame start interrupt */
-	if ((dev_drv->first_frame)) {
-		dev_drv->first_frame = 0;
-		rk312x_lcdc_enable_irq(dev_drv);
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-			     unsigned long arg, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = lcdc_dev->screen->mode.xres;
-		panel_size[1] = lcdc_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
-			    clr_key_cfg.win0_color_key_cfg);
-		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
-			    clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int rk312x_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
-				  const char *id)
-{
-	int win_id = 0;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2"))
-		win_id = dev_drv->fb2_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int rk312x_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
-				     int win_id,
-				     int area_id)
-{
-	struct lcdc_device *lcdc_dev =
-	        container_of(dev_drv, struct lcdc_device, driver);
-	int win_status = 0;
-
-	if (win_id == 0)
-	        win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_WIN0_EN);
-	else if (win_id == 1)
-	        win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_WIN1_EN);
-	else if (win_id == 2)
-                win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_HWC_EN);
-	else
-	        pr_err("!!!%s,win_id :%d,unsupport!!!\n",__func__,win_id);
-
-	return win_status;
-}
-
-static int rk312x_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int ovl;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (set) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
-				     v_WIN0_TOP(swap));
-			ovl = swap;
-		} else {
-			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static int rk312x_lcdc_get_backlight_device(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct device_node *backlight;
-
-	if (lcdc_dev->backlight)
-		return 0;
-
-	backlight = of_parse_phandle(lcdc_dev->dev->of_node,
-				     "backlight", 0);
-	if (backlight) {
-		lcdc_dev->backlight = of_find_backlight_by_node(backlight);
-		if (!lcdc_dev->backlight)
-			dev_info(lcdc_dev->dev, "No find backlight device\n");
-	} else {
-		dev_info(lcdc_dev->dev, "No find backlight device node\n");
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	if (dev_drv->suspend_flag)
-		return 0;
-
-	/* close the backlight */
-	rk312x_lcdc_get_backlight_device(dev_drv);
-	if (lcdc_dev->backlight) {
-		lcdc_dev->backlight->props.fb_blank = FB_BLANK_POWERDOWN;
-		backlight_update_status(lcdc_dev->backlight);
-	}
-
-	dev_drv->suspend_flag = 1;
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN, v_BLANK_EN(1));
-		lcdc_msk_reg(lcdc_dev, INT_STATUS,
-			     m_FS_INT_CLEAR | m_LF_INT_CLEAR,
-			     v_FS_INT_CLEAR(1) | v_LF_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(1));
-		lcdc_cfg_done(lcdc_dev);
-
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	rk312x_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(dev_drv);
-	return 0;
-}
-
-static int rk312x_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-
-	rk312x_lcdc_clk_enable(lcdc_dev);
-	rk312x_lcdc_reg_restore(lcdc_dev);
-
-	/* config for the FRC mode of dither down */
-	if (dev_drv->cur_screen &&
-			dev_drv->cur_screen->face != OUT_P888) {
-		lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
-		lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
-		lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0x55aaaa55);
-		lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x55aaaa55);
-		lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
-		lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
-	}
-
-	/* set screen lut */
-	if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
-		rk312x_lcdc_set_lut(dev_drv,
-				    dev_drv->cur_screen->dsp_lut);
-	/*set hwc lut*/
-	rk312x_lcdc_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
-
-	spin_lock(&lcdc_dev->reg_lock);
-
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			v_DSP_OUT_ZERO(0));
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			v_LCDC_STANDBY(0));
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN, v_BLANK_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-
-	if (dev_drv->iommu_enabled) {
-		if (dev_drv->mmu_dev) {
-			/*
-			 * At here, maybe win is enabled and buffer address
-			 * is not a vaild iommu mapped addr, incase crash,
-			 * delay 30ms to ensure H/W switch done.
-			 */
-			mdelay(30);
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-
-	spin_unlock(&lcdc_dev->reg_lock);
-	dev_drv->suspend_flag = 0;
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	mdelay(100);
-
-	return 0;
-}
-
-static int rk312x_lcdc_blank(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		rk312x_lcdc_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		rk312x_lcdc_early_suspend(dev_drv);
-		break;
-	default:
-		rk312x_lcdc_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int rk312x_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	int i;
-	struct rk_lcdc_win *win = NULL;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		for (i = 0; i < ARRAY_SIZE(lcdc_win); i++) {
-			win = dev_drv->win[i];
-			if ((win->state == 0) && (win->last_state == 1))
-				lcdc_layer_update_regs(lcdc_dev, win);
-			win->last_state = win->state;
-		}
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-/*
-	a:[-30~0]:
-	    sin_hue = sin(a)*256 +0x100;
-	    cos_hue = cos(a)*256;
-	a:[0~30]
-	    sin_hue = sin(a)*256;
-	    cos_hue = cos(a)*256;
-*/
-static int rk312x_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-				    bcsh_hue_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_H);
-		switch (mode) {
-		case H_SIN:
-			val &= m_BCSH_SIN_HUE;
-			break;
-		case H_COS:
-			val &= m_BCSH_COS_HUE;
-			val >>= 16;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return val;
-}
-
-static int rk312x_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv, int sin_hue,
-				    int cos_hue)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
-		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
-		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk312x_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode, int value)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		switch (mode) {
-		case BRIGHTNESS:
-			/* from 0 to 255,typical is 128 */
-			if (value < 0x80)
-				value += 0x80;
-			else if (value >= 0x80)
-				value = value - 0x80;
-			mask = m_BCSH_BRIGHTNESS;
-			val = v_BCSH_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-			/* from 0 to 510,typical is 256 */
-			mask = m_BCSH_CONTRAST;
-			val = v_BCSH_CONTRAST(value);
-			break;
-		case SAT_CON:
-			/* from 0 to 1015,typical is 256 */
-			mask = m_BCSH_SAT_CON;
-			val = v_BCSH_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk312x_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= m_BCSH_BRIGHTNESS;
-			if (val > 0x80)
-				val -= 0x80;
-			else
-				val += 0x80;
-			break;
-		case CONTRAST:
-			val &= m_BCSH_CONTRAST;
-			val >>= 8;
-			break;
-		case SAT_CON:
-			val &= m_BCSH_SAT_CON;
-			val >>= 20;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk312x_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-	if (dev_drv->bcsh_init_status && open) {
-		dev_drv->bcsh_init_status = 0;
-		return 0;
-	}
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (open) {
-			lcdc_msk_reg(lcdc_dev,
-				     BCSH_CTRL, m_BCSH_EN | m_BCSH_OUT_MODE,
-				     v_BCSH_EN(1) | v_BCSH_OUT_MODE(3));
-			lcdc_writel(lcdc_dev, BCSH_BCS,
-				    v_BCSH_BRIGHTNESS(0x00) |
-				    v_BCSH_CONTRAST(0x80) |
-				    v_BCSH_SAT_CON(0x80));
-			lcdc_writel(lcdc_dev, BCSH_H, v_BCSH_COS_HUE(0x80));
-			dev_drv->bcsh.enable = 1;
-		} else {
-			mask = m_BCSH_EN;
-			val = v_BCSH_EN(0);
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL, mask, val);
-			dev_drv->bcsh.enable = 0;
-		}
-		rk312x_lcdc_select_bcsh(dev_drv,  lcdc_dev);
-		lcdc_cfg_done(lcdc_dev);
-	}
-
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk312x_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	struct rk_lcdc_win_area area;
-	int fb2_win_id, fb1_win_id, fb0_win_id;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-
-	fb2_win_id = order / 100;
-	fb1_win_id = (order / 10) % 10;
-	fb0_win_id = order % 10;
-
-	if (fb0_win_id != dev_drv->fb0_win_id) {
-		area = dev_drv->win[(int)dev_drv->fb0_win_id]->area[0];
-		dev_drv->win[(int)dev_drv->fb0_win_id]->area[0] =
-			dev_drv->win[fb0_win_id]->area[0];
-		dev_drv->win[fb0_win_id]->area[0] = area;
-		dev_drv->fb0_win_id = fb0_win_id;
-	}
-	dev_drv->fb1_win_id = fb1_win_id;
-	dev_drv->fb2_win_id = fb2_win_id;
-
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int rk312x_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-
-	if (set) {
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
-	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(lcdc_dev->dclk), fps);
-
-	return fps;
-}
-
-static int rk312x_lcdc_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv,
-				      int enable)
-{
-	struct lcdc_device *lcdc_dev =
-				container_of(dev_drv,
-					     struct lcdc_device, driver);
-	if (enable)
-		enable_irq(lcdc_dev->irq);
-	else
-		disable_irq(lcdc_dev->irq);
-	return 0;
-}
-
-static int rk312x_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 int_reg;
-	int ret;
-
-	if (lcdc_dev->clk_on && (!dev_drv->suspend_flag)) {
-		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-		if (int_reg & m_LF_INT_STA) {
-			dev_drv->frame_time.last_framedone_t =
-					dev_drv->frame_time.framedone_t;
-			dev_drv->frame_time.framedone_t = cpu_clock(0);
-			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
-				     v_LF_INT_CLEAR(1));
-			ret = RK_LF_STATUS_FC;
-		} else {
-			ret = RK_LF_STATUS_FR;
-		}
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int rk312x_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-				    unsigned int dsp_addr[][4])
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (lcdc_dev->clk_on) {
-		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-		if (lcdc_dev->soc_type == VOP_RK3036)
-			dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
-		else if (lcdc_dev->soc_type == VOP_RK312X)
-			dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST_RK312X);
-	}
-	return 0;
-}
-
-static ssize_t rk312x_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
-					 char *buf, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv, struct lcdc_device,
-						    driver);
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char status_w0[9] = "NULL";
-	char status_w1[9] = "NULL";
-	u32 fmt_id, act_info, dsp_info, dsp_st, factor;
-	u16 xvir_w0, x_act_w0, y_act_w0, x_dsp_w0, y_dsp_w0, x_st_w0, y_st_w0;
-	u16 xvir_w1, x_act_w1, y_act_w1, x_dsp_w1, y_dsp_w1, x_st_w1, y_st_w1;
-	u16 x_factor, y_factor, x_scale, y_scale;
-	u16 ovl;
-	u32 win1_dsp_yaddr = 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		/* data format */
-		fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
-		get_format_string((fmt_id & m_WIN0_FORMAT) >> 3, format_w0);
-		get_format_string((fmt_id & m_WIN1_FORMAT) >> 6, format_w1);
-
-		/* win status */
-		if (fmt_id & m_WIN0_EN)
-			strcpy(status_w0, "enabled");
-		else
-			strcpy(status_w0, "disabled");
-
-		if ((fmt_id & m_WIN1_EN) >> 1)
-			strcpy(status_w1, "enabled");
-		else
-			strcpy(status_w1, "disabled");
-
-		/* ovl */
-		ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
-
-		/* xvir */
-		xvir_w0 = lcdc_readl(lcdc_dev, WIN0_VIR) & m_YRGB_VIR;
-		xvir_w1 = lcdc_readl(lcdc_dev, WIN1_VIR) & m_YRGB_VIR;
-
-		/* xact/yact */
-		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-		x_act_w0 = (act_info & m_ACT_WIDTH) + 1;
-		y_act_w0 = ((act_info & m_ACT_HEIGHT) >> 16) + 1;
-
-		if (lcdc_dev->soc_type == VOP_RK3036) {
-			act_info = lcdc_readl(lcdc_dev, WIN1_ACT_INFO);
-			x_act_w1 = (act_info & m_ACT_WIDTH) + 1;
-			y_act_w1 = ((act_info & m_ACT_HEIGHT) >> 16) + 1;
-		} else if (lcdc_dev->soc_type == VOP_RK312X) {
-			/* rk312x unsupport win1 scaler,so have no act info */
-			x_act_w1 = 0;
-			y_act_w1 = 0;
-		}
-
-		/* xsize/ysize */
-		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
-		x_dsp_w0 = (dsp_info & m_DSP_WIDTH) + 1;
-		y_dsp_w0 = ((dsp_info & m_DSP_HEIGHT) >> 16) + 1;
-
-		if (lcdc_dev->soc_type == VOP_RK3036)
-			dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
-		else if (lcdc_dev->soc_type == VOP_RK312X)
-			dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO_RK312X);
-		x_dsp_w1 = (dsp_info & m_DSP_WIDTH) + 1;
-		y_dsp_w1 = ((dsp_info & m_DSP_HEIGHT) >> 16) + 1;
-
-		/* xpos/ypos */
-		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
-		x_st_w0 = dsp_st & m_DSP_STX;
-		y_st_w0 = (dsp_st & m_DSP_STY) >> 16;
-
-		if (lcdc_dev->soc_type == VOP_RK3036)
-			dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
-		else if (lcdc_dev->soc_type == VOP_RK312X)
-			dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST_RK312X);
-
-		x_st_w1 = dsp_st & m_DSP_STX;
-		y_st_w1 = (dsp_st & m_DSP_STY) >> 16;
-
-		/* scale factor */
-		factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
-		x_factor = factor & m_X_SCL_FACTOR;
-		y_factor = (factor & m_Y_SCL_FACTOR) >> 16;
-		x_scale = 4096 * 100 / x_factor;
-		y_scale = 4096 * 100 / y_factor;
-
-		/* dsp addr */
-		if (lcdc_dev->soc_type == VOP_RK3036)
-			win1_dsp_yaddr = lcdc_readl(lcdc_dev, WIN1_MST);
-		else if (lcdc_dev->soc_type == VOP_RK312X)
-			win1_dsp_yaddr = lcdc_readl(lcdc_dev, WIN1_MST_RK312X);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return snprintf(buf, PAGE_SIZE,
-			"win0:%s\n"
-			"xvir:%d\n"
-			"xact:%d\n"
-			"yact:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"x_scale:%d.%d\n"
-			"y_scale:%d.%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"CBR buffer addr:0x%08x\n\n"
-			"win1:%s\n"
-			"xvir:%d\n"
-			"xact:%d\n"
-			"yact:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"overlay:%s\n",
-			status_w0,
-			xvir_w0,
-			x_act_w0,
-			y_act_w0,
-			x_dsp_w0,
-			y_dsp_w0,
-			x_st_w0,
-			y_st_w0,
-			x_scale / 100,
-			x_scale % 100,
-			y_scale / 100,
-			y_scale % 100,
-			format_w0,
-			lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
-			lcdc_readl(lcdc_dev, WIN0_CBR_MST),
-			status_w1,
-			xvir_w1,
-			x_act_w1,
-			y_act_w1,
-			x_dsp_w1,
-			y_dsp_w1,
-			x_st_w1,
-			y_st_w1,
-			format_w1,
-			win1_dsp_yaddr,
-			ovl ? "win0 on the top of win1\n" :
-			"win1 on the top of win0\n");
-}
-
-static int rk312x_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device,
-						    driver);
-	int *cbase = (int *)lcdc_dev->regs;
-	int *regsbak = (int *)lcdc_dev->regsbak;
-	int i, j;
-
-	pr_info("back up reg:\n");
-	for (i = 0; i <= (0xDC >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			pr_info("%08x  ", *(regsbak + i * 4 + j));
-		pr_info("\n");
-	}
-
-	pr_info("lcdc reg:\n");
-	for (i = 0; i <= (0xDC >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			pr_info("%08x  ", readl_relaxed(cbase + i * 4 + j));
-		pr_info("\n");
-	}
-	return 0;
-}
-
-static int rk312x_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	if (lcdc_dev->soc_type == VOP_RK312X) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN,
-			     v_DIRECT_PATH_EN(open));
-		lcdc_cfg_done(lcdc_dev);
-	}
-	return 0;
-}
-
-static int rk312x_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-
-	if (lcdc_dev->soc_type == VOP_RK312X) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_LAYER,
-			     v_DIRECT_PATH_LAYER(win_id));
-		lcdc_cfg_done(lcdc_dev);
-	}
-	return 0;
-}
-
-static int rk312x_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	int ovl = 0;
-
-	if (lcdc_dev->soc_type == VOP_RK312X)
-		ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN);
-
-	return ovl;
-}
-
-static int rk312x_lcdc_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-
-	rk312x_lcdc_get_backlight_device(dev_drv);
-
-	if (enable) {
-		/* close the backlight */
-		if (lcdc_dev->backlight) {
-			lcdc_dev->backlight->props.power = FB_BLANK_POWERDOWN;
-			backlight_update_status(lcdc_dev->backlight);
-		}
-
-		spin_lock(&lcdc_dev->reg_lock);
-		if (likely(lcdc_dev->clk_on)) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLACK_EN,
-				     v_BLACK_EN(1));
-			lcdc_cfg_done(lcdc_dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-
-		rk312x_lcdc_standby(dev_drv, true);
-
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-			dev_drv->trsm_ops->disable();
-	} else {
-		spin_lock(&lcdc_dev->reg_lock);
-		if (likely(lcdc_dev->clk_on)) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLACK_EN,
-				     v_BLACK_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-			dev_drv->trsm_ops->enable();
-
-		rk312x_lcdc_standby(dev_drv, false);
-
-		msleep(100);
-		/* open the backlight */
-		if (lcdc_dev->backlight) {
-			lcdc_dev->backlight->props.power = FB_BLANK_UNBLANK;
-			backlight_update_status(lcdc_dev->backlight);
-		}
-	}
-
-	return 0;
-}
-
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open = rk312x_lcdc_open,
-	.load_screen = rk312x_load_screen,
-	.get_dspbuf_info = rk312x_get_dspbuf_info,
-	.post_dspbuf = rk312x_post_dspbuf,
-	.set_par = rk312x_lcdc_set_par,
-	.pan_display = rk312x_lcdc_pan_display,
-	.direct_set_addr = rk312x_lcdc_direct_set_win_addr,
-	.blank = rk312x_lcdc_blank,
-	.ioctl = rk312x_lcdc_ioctl,
-	.get_win_state = rk312x_lcdc_get_win_state,
-	.ovl_mgr = rk312x_lcdc_ovl_mgr,
-	.get_disp_info = rk312x_lcdc_get_disp_info,
-	.fps_mgr = rk312x_lcdc_fps_mgr,
-	.fb_get_win_id = rk312x_lcdc_get_win_id,
-	.fb_win_remap = rk312x_fb_win_remap,
-	.poll_vblank = rk312x_lcdc_poll_vblank,
-	.get_dsp_addr = rk312x_lcdc_get_dsp_addr,
-	.cfg_done = rk312x_lcdc_cfg_done,
-	.dump_reg = rk312x_lcdc_reg_dump,
-	.dpi_open = rk312x_lcdc_dpi_open,
-	.dpi_win_sel = rk312x_lcdc_dpi_win_sel,
-	.dpi_status = rk312x_lcdc_dpi_status,
-	.set_dsp_bcsh_hue = rk312x_lcdc_set_bcsh_hue,
-	.set_dsp_bcsh_bcs = rk312x_lcdc_set_bcsh_bcs,
-	.get_dsp_bcsh_hue = rk312x_lcdc_get_bcsh_hue,
-	.get_dsp_bcsh_bcs = rk312x_lcdc_get_bcsh_bcs,
-	.open_bcsh = rk312x_lcdc_open_bcsh,
-	.set_screen_scaler = rk312x_lcdc_set_scaler,
-	.set_dsp_lut = rk312x_lcdc_set_lut,
-	.set_hwc_lut = rk312x_lcdc_set_hwc_lut,
-	.set_irq_to_cpu = rk312x_lcdc_set_irq_to_cpu,
-	.dsp_black = rk312x_lcdc_dsp_black,
-	.mmu_en = rk312x_lcdc_mmu_en,
-};
-#if 0
-static const struct rk_lcdc_drvdata rk3036_lcdc_drvdata = {
-	.soc_type = VOP_RK3036,
-};
-#endif
-static const struct rk_lcdc_drvdata rk312x_lcdc_drvdata = {
-	.soc_type = VOP_RK312X,
-};
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk312x_lcdc_dt_ids[] = {
-#if 0
-	{
-		.compatible = "rockchip,rk3036-lcdc",
-		.data = (void *)&rk3036_lcdc_drvdata,
-	},
-#endif
-	{
-		.compatible = "rockchip,rk312x-lcdc",
-		.data = (void *)&rk312x_lcdc_drvdata,
-	},
-};
-#endif
-
-static int rk312x_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
-{
-	struct device_node *np = lcdc_dev->dev->of_node;
-	const struct of_device_id *match;
-	const struct rk_lcdc_drvdata *lcdc_drvdata;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		lcdc_dev->driver.iommu_enabled = 0;
-	else
-		lcdc_dev->driver.iommu_enabled = val;
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
-	else
-		lcdc_dev->driver.fb_win_map = val;
-
-	match = of_match_node(rk312x_lcdc_dt_ids, np);
-	if (match) {
-		lcdc_drvdata = (const struct rk_lcdc_drvdata *)match->data;
-		lcdc_dev->soc_type = lcdc_drvdata->soc_type;
-	} else {
-		return PTR_ERR(match);
-	}
-
-	return 0;
-}
-
-static int rk312x_lcdc_probe(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	int ret;
-
-	lcdc_dev = devm_kzalloc(dev, sizeof(struct lcdc_device), GFP_KERNEL);
-	if (!lcdc_dev) {
-		dev_err(&pdev->dev, "rk312x lcdc device kzalloc fail!\n");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->dev = dev;
-	if (rk312x_lcdc_parse_dt(lcdc_dev)) {
-		dev_err(lcdc_dev->dev, "rk312x lcdc parse dt failed!\n");
-		goto err_parse_dt;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-	lcdc_dev->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(lcdc_dev->regs)) {
-		ret = PTR_ERR(lcdc_dev->regs);
-		goto err_remap_reg;
-	}
-
-	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
-	if (IS_ERR(lcdc_dev->regsbak)) {
-		dev_err(&pdev->dev, "rk312x lcdc device kmalloc fail!\n");
-		ret = PTR_ERR(lcdc_dev->regsbak);
-		goto err_remap_reg;
-	}
-	lcdc_dev->hwc_lut_addr_base = (lcdc_dev->regs + HWC_LUT_ADDR);
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
-	lcdc_dev->prop = PRMRY;
-	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
-	dev_drv = &lcdc_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = lcdc_dev->prop;
-	dev_drv->id = lcdc_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
-	spin_lock_init(&lcdc_dev->reg_lock);
-
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if (lcdc_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			lcdc_dev->id);
-		ret = -ENXIO;
-		goto err_request_irq;
-	}
-
-	ret = devm_request_irq(dev, lcdc_dev->irq, rk312x_lcdc_isr,
-			       IRQF_DISABLED | IRQF_SHARED,
-			       dev_name(dev), lcdc_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			lcdc_dev->irq, ret);
-		goto err_request_irq;
-	}
-
-	if (dev_drv->iommu_enabled)
-		strcpy(dev_drv->mmu_dts_name, VOP_IOMMU_COMPATIBLE_NAME);
-
-	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
-		goto err_register_fb;
-	}
-	lcdc_dev->screen = dev_drv->screen0;
-
-	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
-		 lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	return 0;
-err_register_fb:
-err_request_irq:
-	devm_kfree(lcdc_dev->dev, lcdc_dev->regsbak);
-err_remap_reg:
-err_parse_dt:
-	devm_kfree(&pdev->dev, lcdc_dev);
-	return ret;
-}
-
-#if defined(CONFIG_PM)
-static int rk312x_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk312x_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define rk312x_lcdc_suspend NULL
-#define rk312x_lcdc_resume  NULL
-#endif
-
-static int rk312x_lcdc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void rk312x_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	struct rk_lcdc_driver *dev_drv=&lcdc_dev->driver;
-
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-	kthread_stop(dev_drv->update_regs_thread);
-
-	rk312x_lcdc_standby(dev_drv, true);
-	rk312x_lcdc_deinit(lcdc_dev);
-	rk312x_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(&lcdc_dev->driver);
-}
-
-static struct platform_driver rk312x_lcdc_driver = {
-	.probe = rk312x_lcdc_probe,
-	.remove = rk312x_lcdc_remove,
-	.driver = {
-		   .name = "rk312x-lcdc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(rk312x_lcdc_dt_ids),
-		   },
-	.suspend = rk312x_lcdc_suspend,
-	.resume = rk312x_lcdc_resume,
-	.shutdown = rk312x_lcdc_shutdown,
-};
-
-static int __init rk312x_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk312x_lcdc_driver);
-}
-
-static void __exit rk312x_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk312x_lcdc_driver);
-}
-
-fs_initcall(rk312x_lcdc_module_init);
-module_exit(rk312x_lcdc_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk312x_lcdc.h b/drivers/video/rockchip/lcdc/rk312x_lcdc.h
deleted file mode 100644
index 431bd0f97747..000000000000
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.h
+++ /dev/null
@@ -1,768 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _RK312X_LCDC_H_
-#define _RK312X_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-
-enum _VOP_SOC_TYPE {
-        VOP_RK3036 = 0,
-        VOP_RK312X,
-};
-
-
-#define BITS(x, bit)            ((x) << (bit))
-#define BITS_MASK(x, mask, bit) BITS((x) & (mask), bit)
-
-/*******************register definition**********************/
-
-#define SYS_CTRL                (0x00)
-        #define m_WIN0_EN               BITS(1, 0)
-        #define m_WIN1_EN		BITS(1, 1)
-        #define m_HWC_EN		BITS(1, 2)
-        #define m_WIN0_FORMAT		BITS(7, 3)
-        #define m_WIN1_FORMAT		BITS(7, 6)
-        #define m_HWC_LUT_EN		BITS(1, 9)
-        #define m_HWC_SIZE		BITS(1, 10)
-        #define m_DIRECT_PATH_EN        BITS(1, 11)      /* rk312x */
-        #define m_DIRECT_PATH_LAYER     BITS(1, 12)      /* rk312x */
-        #define m_TVE_MODE_SEL          BITS(1, 13)      /* rk312x */
-        #define m_TVE_DAC_EN            BITS(1, 14)      /* rk312x */
-        #define m_WIN0_RB_SWAP		BITS(1, 15)
-        #define m_WIN0_ALPHA_SWAP	BITS(1, 16)
-        #define m_WIN0_Y8_SWAP		BITS(1, 17)
-        #define m_WIN0_UV_SWAP		BITS(1, 18)
-        #define m_WIN1_RB_SWAP		BITS(1, 19)
-        #define m_WIN1_ALPHA_SWAP	BITS(1, 20)
-        #define m_WIN1_ENDIAN_SWAP      BITS(1, 21)      /* rk312x */
-        #define m_WIN0_OTSD_DISABLE	BITS(1, 22)
-        #define m_WIN1_OTSD_DISABLE	BITS(1, 23)
-        #define m_DMA_BURST_LENGTH	BITS(3, 24)
-        #define m_HWC_LODAD_EN		BITS(1, 26)
-        #define m_WIN1_LUT_EN           BITS(1, 27)      /* rk312x */
-        #define m_DSP_LUT_EN            BITS(1, 28)      /* rk312x */
-        #define m_DMA_STOP		BITS(1, 29)
-        #define m_LCDC_STANDBY		BITS(1, 30)
-        #define m_AUTO_GATING_EN	BITS(1, 31)
-	
-        #define v_WIN0_EN(x)		BITS_MASK(x, 1, 0)
-        #define v_WIN1_EN(x)		BITS_MASK(x, 1, 1)
-        #define v_HWC_EN(x)		BITS_MASK(x, 1, 2)
-        #define v_WIN0_FORMAT(x)	BITS_MASK(x, 7, 3)
-        #define v_WIN1_FORMAT(x)	BITS_MASK(x, 7, 6)
-        #define v_HWC_LUT_EN(x)		BITS_MASK(x, 1, 9)
-        #define v_HWC_SIZE(x)		BITS_MASK(x, 1, 10)
-        #define v_DIRECT_PATH_EN(x)     BITS_MASK(x, 1, 11)
-        #define v_DIRECT_PATH_LAYER(x)  BITS_MASK(x, 1, 12)
-        #define v_TVE_MODE_SEL(x)       BITS_MASK(x, 1, 13)
-        #define v_TVE_DAC_EN(x)         BITS_MASK(x, 1, 14)
-        #define v_WIN0_RB_SWAP(x)	BITS_MASK(x, 1, 15)
-        #define v_WIN0_ALPHA_SWAP(x)	BITS_MASK(x, 1, 16)
-        #define v_WIN0_Y8_SWAP(x)	BITS_MASK(x, 1, 17)
-        #define v_WIN0_UV_SWAP(x)	BITS_MASK(x, 1, 18)
-        #define v_WIN1_RB_SWAP(x)	BITS_MASK(x, 1, 19)
-        #define v_WIN1_ALPHA_SWAP(x)	BITS_MASK(x, 1, 20)
-        #define v_WIN1_ENDIAN_SWAP(x)   BITS_MASK(x, 1, 21)
-        #define v_WIN0_OTSD_DISABLE(x)	BITS_MASK(x, 1, 22)
-        #define v_WIN1_OTSD_DISABLE(x)	BITS_MASK(x, 1, 23)
-        #define v_DMA_BURST_LENGTH(x)	BITS_MASK(x, 3, 24)
-        #define v_HWC_LODAD_EN(x)	BITS_MASK(x, 1, 26)
-        #define v_WIN1_LUT_EN(x)	BITS_MASK(x, 1, 27)
-        #define v_DSP_LUT_EN(x)         BITS_MASK(x, 1, 28)
-        #define v_DMA_STOP(x)		BITS_MASK(x, 1, 29)
-        #define v_LCDC_STANDBY(x)	BITS_MASK(x, 1, 30)
-        #define v_AUTO_GATING_EN(x)	BITS_MASK(x, 1, 31)
-
-#define DSP_CTRL0		(0x04)
-        #define m_DSP_OUT_FORMAT	BITS(0x0f, 0)
-        #define m_HSYNC_POL		BITS(1, 4)
-        #define m_VSYNC_POL		BITS(1, 5)
-        #define m_DEN_POL		BITS(1, 6)
-        #define m_DCLK_POL		BITS(1, 7)
-        #define m_WIN0_TOP		BITS(1, 8)
-        #define m_DITHER_UP_EN		BITS(1, 9)
-        #define m_DITHER_DOWN_MODE	BITS(1, 10)	/* use for rk312x */
-        #define m_DITHER_DOWN_EN	BITS(1, 11)	/* use for rk312x */
-        #define m_INTERLACE_DSP_EN	BITS(1, 12)
-        #define m_INTERLACE_FIELD_POL	BITS(1, 13)	/* use for rk312x */
-        #define m_WIN0_INTERLACE_EN	BITS(1, 14)	/* use for rk312x */
-        #define m_WIN1_INTERLACE_EN	BITS(1, 15)
-        #define m_WIN0_YRGB_DEFLICK_EN	BITS(1, 16)
-        #define m_WIN0_CBR_DEFLICK_EN	BITS(1, 17)
-        #define m_WIN0_ALPHA_MODE	BITS(1, 18)
-        #define m_WIN1_ALPHA_MODE	BITS(1, 19)
-        #define m_WIN0_CSC_MODE		BITS(3, 20)
-	#define m_WIN1_CSC_MODE		BITS(1, 22)
-        #define m_WIN0_YUV_CLIP		BITS(1, 23)
-        #define m_TVE_MODE		BITS(1, 25)
-        #define m_SW_UV_OFFSET_EN	BITS(1, 26)	/* use for rk312x */
-        #define m_DITHER_DOWN_SEL	BITS(1, 27)	/* use for rk312x */
-        #define m_HWC_ALPHA_MODE	BITS(1, 28)
-        #define m_ALPHA_MODE_SEL0       BITS(1, 29)
-        #define m_ALPHA_MODE_SEL1	BITS(1, 30)
-        #define m_WIN1_DIFF_DCLK_EN	BITS(1, 31)	/* use for rk3036 */
-        #define m_SW_OVERLAY_MODE	BITS(1, 31)	/* use for rk312x */
-	
-        #define v_DSP_OUT_FORMAT(x)	BITS_MASK(x, 0x0f, 0)
-        #define v_HSYNC_POL(x)		BITS_MASK(x, 1, 4)
-        #define v_VSYNC_POL(x)		BITS_MASK(x, 1, 5)
-        #define v_DEN_POL(x)		BITS_MASK(x, 1, 6)
-        #define v_DCLK_POL(x)		BITS_MASK(x, 1, 7)
-        #define v_WIN0_TOP(x)		BITS_MASK(x, 1, 8)
-        #define v_DITHER_UP_EN(x)	BITS_MASK(x, 1, 9)
-        #define v_DITHER_DOWN_MODE(x)	BITS_MASK(x, 1, 10)	/* rk312x */
-        #define v_DITHER_DOWN_EN(x)	BITS_MASK(x, 1, 11)	/* rk312x */
-        #define v_INTERLACE_DSP_EN(x)	BITS_MASK(x, 1, 12)
-        #define v_INTERLACE_FIELD_POL(x)	BITS_MASK(x, 1, 13)	/* rk312x */
-        #define v_WIN0_INTERLACE_EN(x)		BITS_MASK(x, 1, 14)	/* rk312x */
-        #define v_WIN1_INTERLACE_EN(x)		BITS_MASK(x, 1, 15)
-        #define v_WIN0_YRGB_DEFLICK_EN(x)	BITS_MASK(x, 1, 16)
-        #define v_WIN0_CBR_DEFLICK_EN(x)	BITS_MASK(x, 1, 17)
-        #define v_WIN0_ALPHA_MODE(x)		BITS_MASK(x, 1, 18)
-        #define v_WIN1_ALPHA_MODE(x)		BITS_MASK(x, 1, 19)
-        #define v_WIN0_CSC_MODE(x)		BITS_MASK(x, 3, 20)
-	#define v_WIN1_CSC_MODE(x)		BITS_MASK(x, 1, 22)
-        #define v_WIN0_YUV_CLIP(x)		BITS_MASK(x, 1, 23)
-        #define v_TVE_MODE(x)			BITS_MASK(x, 1, 25)
-        #define v_SW_UV_OFFSET_EN(x)		BITS_MASK(x, 1, 26)      /* rk312x */
-        #define v_DITHER_DOWN_SEL(x)		BITS_MASK(x, 1, 27)      /* rk312x */
-        #define v_HWC_ALPHA_MODE(x)		BITS_MASK(x, 1, 28)
-        #define v_ALPHA_MODE_SEL0(x)            BITS_MASK(x, 1, 29)
-        #define v_ALPHA_MODE_SEL1(x)		BITS_MASK(x, 1, 30)
-        #define v_WIN1_DIFF_DCLK_EN(x)		BITS_MASK(x, 1, 31)	/* rk3036 */
-        #define v_SW_OVERLAY_MODE(x)		BITS_MASK(x, 1, 31)	/* rk312x */
-
-#define DSP_CTRL1		(0x08)
-        #define m_BG_COLOR		BITS(0xffffff, 0)
-        #define m_BG_B			BITS(0xff, 0)
-        #define m_BG_G			BITS(0xff, 8)
-        #define m_BG_R			BITS(0xff, 16)
-        #define m_BLANK_EN		BITS(1, 24)
-        #define m_BLACK_EN		BITS(1, 25)
-        #define m_DSP_BG_SWAP		BITS(1, 26)
-        #define m_DSP_RB_SWAP		BITS(1, 27)
-        #define m_DSP_RG_SWAP		BITS(1, 28)
-        #define m_DSP_DELTA_SWAP	BITS(1, 29)              /* rk3036 */
-        #define m_DSP_DUMMY_SWAP	BITS(1, 30)	        /* rk3036 */
-        #define m_DSP_OUT_ZERO		BITS(1, 31)
-	
-        #define v_BG_COLOR(x)		BITS_MASK(x, 0xffffff, 0)
-        #define v_BG_B(x)		BITS_MASK(x, 0xff, 0)
-        #define v_BG_G(x)		BITS_MASK(x, 0xff, 8)
-        #define v_BG_R(x)		BITS_MASK(x, 0xff, 16)
-        #define v_BLANK_EN(x)		BITS_MASK(x, 1, 24)
-        #define v_BLACK_EN(x)		BITS_MASK(x, 1, 25)
-        #define v_DSP_BG_SWAP(x)	BITS_MASK(x, 1, 26)
-        #define v_DSP_RB_SWAP(x)	BITS_MASK(x, 1, 27)
-        #define v_DSP_RG_SWAP(x)	BITS_MASK(x, 1, 28)
-        #define v_DSP_DELTA_SWAP(x)	BITS_MASK(x, 1, 29)      /* rk3036 */
-        #define v_DSP_DUMMY_SWAP(x)	BITS_MASK(x, 1, 30)      /* rk3036 */
-        #define v_DSP_OUT_ZERO(x)	BITS_MASK(x, 1, 31)
-
-#define INT_SCALER              (0x0c)          /* only use for rk312x */
-        #define m_SCALER_EMPTY_INTR_EN  BITS(1, 0)
-        #define m_SCLAER_EMPTY_INTR_CLR BITS(1, 1)
-        #define m_SCLAER_EMPTY_INTR_STA BITS(1, 2)
-        #define m_FS_MASK_EN            BITS(1, 3)
-        #define m_HDMI_HSYNC_POL        BITS(1, 4)
-        #define m_HDMI_VSYNC_POL        BITS(1, 5)
-        #define m_HDMI_DEN_POL          BITS(1, 6)
-
-        #define v_SCALER_EMPTY_INTR_EN(x)       BITS_MASK(x, 1, 0)
-        #define v_SCLAER_EMPTY_INTR_CLR(x)      BITS_MASK(x, 1, 1)
-        #define v_SCLAER_EMPTY_INTR_STA(x)      BITS_MASK(x, 1, 2)
-        #define v_FS_MASK_EN(x)                 BITS_MASK(x, 1, 3)
-        #define v_HDMI_HSYNC_POL(x)             BITS_MASK(x, 1, 4)
-        #define v_HDMI_VSYNC_POL(x)             BITS_MASK(x, 1, 5)
-        #define v_HDMI_DEN_POL(x)               BITS_MASK(x, 1, 6)
-
-#define INT_STATUS		(0x10)
-        #define m_HS_INT_STA		BITS(1, 0)
-        #define m_FS_INT_STA		BITS(1, 1)
-        #define m_LF_INT_STA		BITS(1, 2)
-        #define m_BUS_ERR_INT_STA	BITS(1, 3)
-        #define m_HS_INT_EN		BITS(1, 4)
-        #define m_FS_INT_EN          	BITS(1, 5)
-        #define m_LF_INT_EN         	BITS(1, 6)
-        #define m_BUS_ERR_INT_EN	BITS(1, 7)
-        #define m_HS_INT_CLEAR		BITS(1, 8)
-        #define m_FS_INT_CLEAR		BITS(1, 9)
-        #define m_LF_INT_CLEAR		BITS(1, 10)
-        #define m_BUS_ERR_INT_CLEAR	BITS(1, 11)
-        #define m_LF_INT_NUM		BITS(0xfff, 12)
-        #define m_WIN0_EMPTY_INT_EN	BITS(1, 24)
-        #define m_WIN1_EMPTY_INT_EN	BITS(1, 25)
-        #define m_WIN0_EMPTY_INT_CLEAR	BITS(1, 26)
-        #define m_WIN1_EMPTY_INT_CLEAR	BITS(1, 27)
-        #define m_WIN0_EMPTY_INT_STA	BITS(1, 28)
-        #define m_WIN1_EMPTY_INT_STA	BITS(1, 29)
-        #define m_FS_RAW_STA		BITS(1, 30)
-        #define m_LF_RAW_STA		BITS(1, 31)
-	
-        #define v_HS_INT_EN(x)		BITS_MASK(x, 1, 4)
-        #define v_FS_INT_EN(x)		BITS_MASK(x, 1, 5)
-        #define v_LF_INT_EN(x)		BITS_MASK(x, 1, 6)
-        #define v_BUS_ERR_INT_EN(x)	BITS_MASK(x, 1, 7)
-        #define v_HS_INT_CLEAR(x)	BITS_MASK(x, 1, 8)
-        #define v_FS_INT_CLEAR(x)	BITS_MASK(x, 1, 9)
-        #define v_LF_INT_CLEAR(x)	BITS_MASK(x, 1, 10)
-        #define v_BUS_ERR_INT_CLEAR(x)	BITS_MASK(x, 1, 11)
-        #define v_LF_INT_NUM(x)		BITS_MASK(x, 0xfff, 12)
-        #define v_WIN0_EMPTY_INT_EN(x)	BITS_MASK(x, 1, 24)
-        #define v_WIN1_EMPTY_INT_EN(x)	BITS_MASK(x, 1, 25)
-        #define v_WIN0_EMPTY_INT_CLEAR(x)	BITS_MASK(x, 1, 26)
-        #define v_WIN1_EMPTY_INT_CLEAR(x)	BITS_MASK(x, 1, 27)
-
-#define ALPHA_CTRL		(0x14)
-        #define m_WIN0_ALPHA_EN		BITS(1, 0)
-        #define m_WIN1_ALPHA_EN		BITS(1, 1)
-        #define m_HWC_ALPAH_EN		BITS(1, 2)
-        #define m_WIN1_PREMUL_SCALE	BITS(1, 3)               /* rk3036 */
-        #define m_WIN0_ALPHA_VAL	BITS(0xff, 4)
-        #define m_WIN1_ALPHA_VAL	BITS(0xff, 12)
-        #define m_HWC_ALPAH_VAL		BITS(0xff, 20)
-	
-        #define v_WIN0_ALPHA_EN(x)	BITS_MASK(x, 1, 0)
-        #define v_WIN1_ALPHA_EN(x)	BITS_MASK(x, 1, 1)
-        #define v_HWC_ALPAH_EN(x)	BITS_MASK(x, 1, 2)
-        #define v_WIN1_PREMUL_SCALE(x)	BITS_MASK(x, 1, 3)       /* rk3036 */
-        #define v_WIN0_ALPHA_VAL(x)	BITS_MASK(x, 0xff, 4)
-        #define v_WIN1_ALPHA_VAL(x)	BITS_MASK(x, 0xff, 12)
-        #define v_HWC_ALPAH_VAL(x)	BITS_MASK(x, 0xff, 20)
-
-#define WIN0_COLOR_KEY		(0x18)
-#define WIN1_COLOR_KEY		(0x1c)
-        #define m_COLOR_KEY_VAL		BITS(0xffffff, 0)
-        #define m_COLOR_KEY_EN		BITS(1, 24)
-
-        #define v_COLOR_KEY_VAL(x)	BITS_MASK(x, 0xffffff, 0)
-        #define v_COLOR_KEY_EN(x)	BITS_MASK(x, 1, 24)
-
-/* Layer Registers */
-#define WIN0_YRGB_MST		(0x20)
-#define WIN0_CBR_MST		(0x24)
-#define WIN1_MST		(0xa0)                  /* rk3036 */
-#define WIN1_MST_RK312X         (0x4c)                  /* rk312x */
-#define HWC_MST			(0x58)
-
-#define WIN1_VIR		(0x28)
-#define WIN0_VIR		(0x30)
-        #define m_YRGB_VIR	        BITS(0x1fff, 0)
-        #define m_CBBR_VIR	        BITS(0x1fff, 16)   
-	
-        #define v_YRGB_VIR(x)           BITS_MASK(x, 0x1fff, 0)
-        #define v_CBBR_VIR(x)           BITS_MASK(x, 0x1fff, 16)
-	
-	#define v_ARGB888_VIRWIDTH(x)	BITS_MASK(x, 0x1fff, 0)
-	#define v_RGB888_VIRWIDTH(x) 	BITS_MASK(((x*3)>>2)+((x)%3), 0x1fff, 0)
-	#define v_RGB565_VIRWIDTH(x)	BITS_MASK(DIV_ROUND_UP(x, 2), 0x1fff, 0)
-	#define v_YUV_VIRWIDTH(x)	BITS_MASK(DIV_ROUND_UP(x, 4), 0x1fff, 0)
-	#define v_CBCR_VIR(x)		BITS_MASK(x, 0x1fff, 16)
-
-#define WIN0_ACT_INFO		(0x34)
-#define WIN1_ACT_INFO		(0xb4)          /* rk3036 */
-	#define m_ACT_WIDTH       	BITS(0x1fff, 0)
-	#define m_ACT_HEIGHT      	BITS(0x1fff, 16)
- 
-	#define v_ACT_WIDTH(x)       	BITS_MASK(x - 1, 0x1fff, 0)
-	#define v_ACT_HEIGHT(x)      	BITS_MASK(x - 1, 0x1fff, 16)
-
-#define WIN0_DSP_INFO		(0x38)
-#define WIN1_DSP_INFO		(0xb8)          /* rk3036 */
-#define WIN1_DSP_INFO_RK312X    (0x50)          /* rk312x */
-        #define m_DSP_WIDTH       	BITS(0x7ff, 0)
-	#define m_DSP_HEIGHT      	BITS(0x7ff, 16)
-
-	#define v_DSP_WIDTH(x)     	BITS_MASK(x - 1, 0x7ff, 0)
-	#define v_DSP_HEIGHT(x)    	BITS_MASK(x - 1, 0x7ff, 16)
-	
-#define WIN0_DSP_ST		(0x3c)
-#define WIN1_DSP_ST		(0xbc)          /* rk3036 */
-#define WIN1_DSP_ST_RK312X      (0x54)          /* rk312x */
-#define HWC_DSP_ST		(0x5c)
-        #define m_DSP_STX               BITS(0xfff, 0)
-	#define m_DSP_STY               BITS(0xfff, 16)
-
-	#define v_DSP_STX(x)      	BITS_MASK(x, 0xfff, 0)
-	#define v_DSP_STY(x)      	BITS_MASK(x, 0xfff, 16)
-	
-#define WIN0_SCL_FACTOR_YRGB	(0x40)
-#define WIN0_SCL_FACTOR_CBR	(0x44)
-#define WIN1_SCL_FACTOR_YRGB	(0xc0)          /* rk3036 */
-        #define m_X_SCL_FACTOR          BITS(0xffff, 0)
-	#define m_Y_SCL_FACTOR          BITS(0xffff, 16)
-
-	#define v_X_SCL_FACTOR(x)  	BITS_MASK(x, 0xffff, 0)
-	#define v_Y_SCL_FACTOR(x)  	BITS_MASK(x, 0xffff, 16)
-	
-#define WIN0_SCL_OFFSET		(0x48)
-#define WIN1_SCL_OFFSET		(0xc8)          /* rk3036 */
-
-/* LUT Registers */
-#define WIN1_LUT_ADDR 		(0x0400)        /* rk3036 */
-#define HWC_LUT_ADDR   		(0x0800)
-#define DSP_LUT_ADDR            (0x0c00)        /* rk312x */
-
-/* Display Infomation Registers */
-#define DSP_HTOTAL_HS_END	(0x6c)
-	#define v_HSYNC(x)  		BITS_MASK(x, 0xfff, 0)   /* hsync pulse width */
-	#define v_HORPRD(x) 		BITS_MASK(x, 0xfff, 16)  /* horizontal period */
-
-#define DSP_HACT_ST_END		(0x70)
-	#define v_HAEP(x) 		BITS_MASK(x, 0xfff, 0)  /* horizontal active end point */
-	#define v_HASP(x) 		BITS_MASK(x, 0xfff, 16) /* horizontal active start point */
-
-#define DSP_VTOTAL_VS_END	(0x74)
-	#define v_VSYNC(x) 		BITS_MASK(x, 0xfff, 0)
-	#define v_VERPRD(x) 		BITS_MASK(x, 0xfff, 16)
-	
-#define DSP_VACT_ST_END		(0x78)
-	#define v_VAEP(x) 		BITS_MASK(x, 0xfff, 0)
-	#define v_VASP(x) 		BITS_MASK(x, 0xfff, 16)
-
-#define DSP_VS_ST_END_F1	(0x7c)
-	#define v_VSYNC_END_F1(x) 	BITS_MASK(x, 0xfff, 0)
-	#define v_VSYNC_ST_F1(x) 	BITS_MASK(x, 0xfff, 16)
-#define DSP_VACT_ST_END_F1	(0x80)
-        #define v_VAEP_F1(x) 		BITS_MASK(x, 0xfff, 0)
-	#define v_VASP_F1(x) 		BITS_MASK(x, 0xfff, 16)
-
-/* Scaler Registers 
- * Only used for rk312x
- */
-#define SCALER_CTRL             (0xa0)
-        #define m_SCALER_EN             BITS(1, 0)
-        #define m_SCALER_SYNC_INVERT    BITS(1, 2)
-        #define m_SCALER_DEN_INVERT     BITS(1, 3)
-        #define m_SCALER_OUT_ZERO       BITS(1, 4)
-        #define m_SCALER_OUT_EN         BITS(1, 5)
-        #define m_SCALER_VSYNC_MODE     BITS(3, 6)
-        #define m_SCALER_VSYNC_VST      BITS(0xff, 8)
-
-        #define v_SCALER_EN(x)          BITS_MASK(x, 1, 0)
-        #define v_SCALER_SYNC_INVERT(x) BITS_MASK(x, 1, 2)
-        #define v_SCALER_DEN_INVERT(x)  BITS_MASK(x, 1, 3)
-        #define v_SCALER_OUT_ZERO(x)    BITS_MASK(x, 1, 4)
-        #define v_SCALER_OUT_EN(x)      BITS_MASK(x, 1, 5)
-        #define v_SCALER_VSYNC_MODE(x)  BITS_MASK(x, 3, 6)
-        #define v_SCALER_VSYNC_VST(x)   BITS_MASK(x, 0xff, 8)
-
-#define SCALER_FACTOR           (0xa4)
-        #define m_SCALER_H_FACTOR       BITS(0x3fff, 0)
-        #define m_SCALER_V_FACTOR       BITS(0x3fff, 16)
-
-        #define v_SCALER_H_FACTOR(x)    BITS_MASK(x, 0x3fff, 0)
-        #define v_SCALER_V_FACTOR(x)    BITS_MASK(x, 0x3fff, 16)
-
-#define SCALER_FRAME_ST         (0xa8)
-        #define m_SCALER_FRAME_HST      BITS(0xfff, 0)
-        #define m_SCALER_FRAME_VST      BITS(0xfff, 16)
-
-        #define v_SCALER_FRAME_HST(x)   BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_FRAME_VST(x)   BITS_MASK(x, 0xfff, 16)
-
-#define SCALER_DSP_HOR_TIMING   (0xac)
-        #define m_SCALER_HTOTAL         BITS(0xfff, 0)
-        #define m_SCALER_HS_END         BITS(0xff, 16)
-
-        #define v_SCALER_HTOTAL(x)      BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_HS_END(x)      BITS_MASK(x, 0xff, 16)
-
-#define SCALER_DSP_HACT_ST_END  (0xb0)
-        #define m_SCALER_HAEP           BITS(0xfff, 0)
-        #define m_SCALER_HASP           BITS(0x3ff, 16)
-
-        #define v_SCALER_HAEP(x)        BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_HASP(x)        BITS_MASK(x, 0x3ff, 16)
-
-#define SCALER_DSP_VER_TIMING   (0xb4)
-        #define m_SCALER_VTOTAL         BITS(0xfff, 0)
-        #define m_SCALER_VS_END         BITS(0xff, 16)
-
-        #define v_SCALER_VTOTAL(x)      BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_VS_END(x)      BITS_MASK(x, 0xff, 16)
-
-#define SCALER_DSP_VACT_ST_END  (0xb8)
-        #define m_SCALER_VAEP           BITS(0xfff, 0)
-        #define m_SCALER_VASP           BITS(0xff, 16)
-
-        #define v_SCALER_VAEP(x)        BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_VASP(x)        BITS_MASK(x, 0xff, 16)
-
-#define SCALER_DSP_HBOR_TIMING  (0xbc)
-        #define m_SCALER_HBOR_END       BITS(0xfff, 0)
-        #define m_SCALER_HBOR_ST        BITS(0x3ff, 16)
-
-        #define v_SCALER_HBOR_END(x)    BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_HBOR_ST(x)     BITS_MASK(x, 0x3ff, 16)
-
-#define SCALER_DSP_VBOR_TIMING  (0xc0)
-        #define m_SCALER_VBOR_END       BITS(0xfff, 0)
-        #define m_SCALER_VBOR_ST        BITS(0xff, 16)
-
-        #define v_SCALER_VBOR_END(x)    BITS_MASK(x, 0xfff, 0)
-        #define v_SCALER_VBOR_ST(x)     BITS_MASK(x, 0xff, 16)        
-
-/* BCSH Registers */
-#define BCSH_CTRL		(0xd0)
-	#define m_BCSH_EN		BITS(1, 0)
-        #define m_BCSH_R2Y_CSC_MODE     BITS(1, 1)       /* rk312x */
-	#define m_BCSH_OUT_MODE		BITS(3, 2)
-	#define m_BCSH_Y2R_CSC_MODE     BITS(3, 4)
-        #define m_BCSH_Y2R_EN           BITS(1, 6)       /* rk312x */
-        #define m_BCSH_R2Y_EN           BITS(1, 7)       /* rk312x */
-	
-	#define v_BCSH_EN(x)		BITS_MASK(x, 1, 0)
-        #define v_BCSH_R2Y_CSC_MODE(x)  BITS_MASK(x, 1, 1)       /* rk312x */
-	#define v_BCSH_OUT_MODE(x)	BITS_MASK(x, 3, 2)
-	#define v_BCSH_Y2R_CSC_MODE(x)	BITS_MASK(x, 3, 4)
-        #define v_BCSH_Y2R_EN(x)        BITS_MASK(x, 1, 6)       /* rk312x */
-        #define v_BCSH_R2Y_EN(x)        BITS_MASK(x, 1, 7)       /* rk312x */
-
-#define BCSH_COLOR_BAR 		(0xd4)
-        #define m_BCSH_COLOR_BAR_Y      BITS(0xff, 0)
-	#define m_BCSH_COLOR_BAR_U	BITS(0xff, 8)
-	#define m_BCSH_COLOR_BAR_V	BITS(0xff, 16)
-
-	#define v_BCSH_COLOR_BAR_Y(x)	BITS_MASK(x, 0xff, 0)
-	#define v_BCSH_COLOR_BAR_U(x)   BITS_MASK(x, 0xff, 8)
-	#define v_BCSH_COLOR_BAR_V(x)   BITS_MASK(x, 0xff, 16)
-
-#define BCSH_BCS 		(0xd8)	
-	#define m_BCSH_BRIGHTNESS	BITS(0x1f, 0)	
-	#define m_BCSH_CONTRAST		BITS(0xff, 8)
-	#define m_BCSH_SAT_CON		BITS(0x1ff, 16)
-
-	#define v_BCSH_BRIGHTNESS(x)	BITS_MASK(x, 0x1f, 0)	
-	#define v_BCSH_CONTRAST(x)	BITS_MASK(x, 0xff, 8)	
-	#define v_BCSH_SAT_CON(x)       BITS_MASK(x, 0x1ff, 16)			
-
-#define BCSH_H 			(0xdc)	
-	#define m_BCSH_SIN_HUE		BITS(0xff, 0)
-	#define m_BCSH_COS_HUE		BITS(0xff, 8)
-
-	#define v_BCSH_SIN_HUE(x)	BITS_MASK(x, 0xff, 0)
-	#define v_BCSH_COS_HUE(x)	BITS_MASK(x, 0xff, 8)
-
-#define FRC_LOWER01_0           (0xe0)
-#define FRC_LOWER01_1           (0xe4)
-#define FRC_LOWER10_0           (0xe8)
-#define FRC_LOWER10_1           (0xec)
-#define FRC_LOWER11_0           (0xf0)
-#define FRC_LOWER11_1           (0xf4)
-
-/* Bus Register */
-#define AXI_BUS_CTRL		(0x2c)
-	#define m_IO_PAD_CLK			BITS(1, 31)
-	#define m_CORE_CLK_DIV_EN		BITS(1, 30)
-        #define m_MIPI_DCLK_INVERT              BITS(1, 29)      /* rk312x */
-        #define m_MIPI_DCLK_EN                  BITS(1, 28)      /* rk312x */
-        #define m_LVDS_DCLK_INVERT              BITS(1, 27)      /* rk312x */
-        #define m_LVDS_DCLK_EN                  BITS(1, 26)      /* rk312x */
-        #define m_RGB_DCLK_INVERT               BITS(1, 25)      /* rk312x */
-        #define m_RGB_DCLK_EN                   BITS(1, 24)      /* rk312x */
-	#define m_HDMI_DCLK_INVERT		BITS(1, 23)
-	#define m_HDMI_DCLK_EN			BITS(1, 22)
-	#define m_TVE_DAC_DCLK_INVERT		BITS(1, 21)
-	#define m_TVE_DAC_DCLK_EN		BITS(1, 20)
-	#define m_HDMI_DCLK_DIV_EN		BITS(1, 19)
-	#define m_AXI_OUTSTANDING_MAX_NUM	BITS(0x1f, 12)
-	#define m_AXI_MAX_OUTSTANDING_EN	BITS(1, 11)
-	#define m_MMU_EN			BITS(1, 10)
-	#define m_NOC_HURRY_THRESHOLD		BITS(0xf, 6)
-	#define m_NOC_HURRY_VALUE		BITS(3, 4)
-	#define m_NOC_HURRY_EN			BITS(1, 3)
-	#define m_NOC_QOS_VALUE			BITS(3, 1)
-	#define m_NOC_QOS_EN			BITS(1, 0)
-	
-	#define v_IO_PAD_CLK(x)			BITS_MASK(x, 1, 31)
-	#define v_CORE_CLK_DIV_EN(x)		BITS_MASK(x, 1, 30)
-        #define v_MIPI_DCLK_INVERT(x)           BITS_MASK(x, 1, 29)
-        #define v_MIPI_DCLK_EN(x)               BITS_MASK(x, 1, 28)
-        #define v_LVDS_DCLK_INVERT(x)           BITS_MASK(x, 1, 27)
-        #define v_LVDS_DCLK_EN(x)               BITS_MASK(x, 1, 26)
-        #define v_RGB_DCLK_INVERT(x)            BITS_MASK(x, 1, 25)
-        #define v_RGB_DCLK_EN(x)                BITS_MASK(x, 1, 24)
-	#define v_HDMI_DCLK_INVERT(x)		BITS_MASK(x, 1, 23)
-	#define v_HDMI_DCLK_EN(x)		BITS_MASK(x, 1, 22)
-	#define v_TVE_DAC_DCLK_INVERT(x)	BITS_MASK(x, 1, 21)
-	#define v_TVE_DAC_DCLK_EN(x)		BITS_MASK(x, 1, 20)
-	#define v_HDMI_DCLK_DIV_EN(x)		BITS_MASK(x, 1, 19)
-	#define v_AXI_OUTSTANDING_MAX_NUM(x)	BITS_MASK(x, 0x1f, 12)
-	#define v_AXI_MAX_OUTSTANDING_EN(x)	BITS_MASK(x, 1, 11)
-	#define v_MMU_EN(x)			BITS_MASK(x, 1, 10)
-	#define v_NOC_HURRY_THRESHOLD(x)	BITS_MASK(x, 0xf, 6)
-	#define v_NOC_HURRY_VALUE(x)		BITS_MASK(x, 3, 4)
-	#define v_NOC_HURRY_EN(x)		BITS_MASK(x, 1, 3)
-	#define v_NOC_QOS_VALUE(x)		BITS_MASK(x, 3, 1)
-	#define v_NOC_QOS_EN(x)			BITS_MASK(x, 1, 0)
-	
-#define GATHER_TRANSFER		(0x84)
-	#define m_WIN1_AXI_GATHER_NUM		BITS(0xf, 12)
-	#define m_WIN0_CBCR_AXI_GATHER_NUM	BITS(0x7, 8)
-	#define m_WIN0_YRGB_AXI_GATHER_NUM	BITS(0xf, 4)
-	#define m_WIN1_AXI_GAHTER_EN		BITS(1, 2)
-	#define m_WIN0_CBCR_AXI_GATHER_EN	BITS(1, 1)
-	#define m_WIN0_YRGB_AXI_GATHER_EN	BITS(1, 0)
-	
-	#define v_WIN1_AXI_GATHER_NUM(x)	BITS_MASK(x, 0xf, 12)
-	#define v_WIN0_CBCR_AXI_GATHER_NUM(x)	BITS_MASK(x, 0x7, 8)
-	#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	BITS_MASK(x, 0xf, 4)
-	#define v_WIN1_AXI_GAHTER_EN(x)		BITS_MASK(x, 1, 2)
-	#define v_WIN0_CBCR_AXI_GATHER_EN(x)	BITS_MASK(x, 1, 1)
-	#define v_WIN0_YRGB_AXI_GATHER_EN(x)	BITS_MASK(x, 1, 0)
-	
-#define VERSION_INFO		(0x94)
-	#define m_MAJOR		                BITS(0xff, 24)
-	#define m_MINOR		                BITS(0xff, 16)
-	#define m_BUILD		                BITS(0xffff)
-		
-#define REG_CFG_DONE		(0x90)
-
-/* TV Control Registers */
-#define TV_CTRL			(0x200)	
-#define TV_SYNC_TIMING		(0x204)
-#define TV_ACT_TIMING		(0x208)
-#define TV_ADJ_TIMING		(0x20c)
-#define TV_FREQ_SC		(0x210)
-#define TV_FILTER0		(0x214)
-#define TV_FILTER1		(0x218)
-#define TV_FILTER2		(0x21C)
-#define TV_ACT_ST		(0x234)
-#define TV_ROUTING		(0x238)
-#define TV_SYNC_ADJUST		(0x250)
-#define TV_STATUS		(0x254)
-#define TV_RESET		(0x268)
-#define TV_SATURATION		(0x278)
-#define TV_BW_CTRL		(0x28C)
-#define TV_BRIGHTNESS_CONTRAST	(0x290)
-
-
-/* MMU registers */
-#define MMU_DTE_ADDR		(0x0300)
-        #define m_MMU_DTE_ADDR			BITS(0xffffffff, 0)
-	#define v_MMU_DTE_ADDR(x)		BITS_MASK(x, 0xffffffff, 0)
-
-#define MMU_STATUS		(0x0304)
-        #define m_PAGING_ENABLED		BITS(1, 0)
-	#define m_PAGE_FAULT_ACTIVE		BITS(1, 1)
-	#define m_STAIL_ACTIVE			BITS(1, 2)
-	#define m_MMU_IDLE			BITS(1, 3)
-	#define m_REPLAY_BUFFER_EMPTY		BITS(1, 4)
-	#define m_PAGE_FAULT_IS_WRITE		BITS(1, 5)
-	#define m_PAGE_FAULT_BUS_ID		BITS(0x1f, 6)
-
-	#define v_PAGING_ENABLED(x)		BITS_MASK(x, 1, 0)
-	#define v_PAGE_FAULT_ACTIVE(x)		BITS_MASK(x, 1, 1)
-	#define v_STAIL_ACTIVE(x)		BITS_MASK(x, 1, 2)
-	#define v_MMU_IDLE(x)			BITS_MASK(x, 1, 3)
-	#define v_REPLAY_BUFFER_EMPTY(x)	BITS_MASK(x, 1, 4)
-	#define v_PAGE_FAULT_IS_WRITE(x)	BITS_MASK(x, 1, 5)
-	#define v_PAGE_FAULT_BUS_ID(x)		BITS_MASK(x, 0x1f, 6)
-	
-#define MMU_COMMAND		(0x0308)
-        #define m_MMU_CMD			BITS(0x7, 0)
-	#define v_MMU_CMD(x)			BITS_MASK(x, 0x7, 0)	
-
-#define MMU_PAGE_FAULT_ADDR	(0x030c)
-        #define m_PAGE_FAULT_ADDR		BITS(0xffffffff, 0)
-	#define v_PAGE_FAULT_ADDR(x)		BITS_MASK(x, 0xffffffff, 0)
-	
-#define MMU_ZAP_ONE_LINE	(0x0310)
-        #define m_MMU_ZAP_ONE_LINE		BITS(0xffffffff, 0)
-	#define v_MMU_ZAP_ONE_LINE(x)		BITS_MASK(x, 0xffffffff, 0)
-
-#define MMU_INT_RAWSTAT		(0x0314)
-        #define m_PAGE_FAULT_RAWSTAT		BITS(1, 0)
-	#define m_READ_BUS_ERROR_RAWSTAT	BITS(1, 1)
- 
-	#define v_PAGE_FAULT_RAWSTAT(x)		BITS(x, 1, 0)
-	#define v_READ_BUS_ERROR_RAWSTAT(x)	BITS(x, 1, 1)
-	
-#define MMU_INT_CLEAR		(0x0318)
-        #define m_PAGE_FAULT_CLEAR		BITS(1, 0)
-	#define m_READ_BUS_ERROR_CLEAR		BITS(1, 1)
-
-	#define v_PAGE_FAULT_CLEAR(x)		BITS(x, 1, 0)
-	#define v_READ_BUS_ERROR_CLEAR(x)	BITS(x, 1, 1)
-	
-#define MMU_INT_MASK		(0x031c)
-        #define m_PAGE_FAULT_MASK		BITS(1, 0)
-	#define m_READ_BUS_ERROR_MASK		BITS(1, 1)
-
-	#define v_PAGE_FAULT_MASK(x)		BITS(x, 1, 0)
-	#define v_READ_BUS_ERROR_MASK(x)	BITS(x, 1, 1)
-	
-#define MMU_INT_STATUS		(0x0320)
-        #define m_PAGE_FAULT_STATUS		BITS(1, 0)
-	#define m_READ_BUS_ERROR_STATUS		BITS(1, 1)
-
-	#define v_PAGE_FAULT_STATUS(x)		BITS(x, 1, 0)
-	#define v_READ_BUS_ERROR_STATUS(x)	BITS(x, 1, 1)
-
-#define MMU_AUTO_GATING		(0x0324)
-        #define m_MMU_AUTO_GATING		BITS(1, 0)
-	#define v_MMU_AUTO_GATING(x)		BITS(x, 1, 0)
-
-
-enum _vop_dma_burst {
-	DMA_BURST_16 = 0,
-	DMA_BURST_8,
-	DMA_BURST_4
-};
-
-enum _vop_format_e {
-	VOP_FORMAT_ARGB888 = 0,
-	VOP_FORMAT_RGB888,
-	VOP_FORMAT_RGB565,
-	VOP_FORMAT_YCBCR420 = 4,
-	VOP_FORMAT_YCBCR422,
-	VOP_FORMAT_YCBCR444
-};
-
-enum _vop_tv_mode {
-	TV_NTSC,
-	TV_PAL,
-};
-
-enum _vop_r2y_csc_mode {
-	VOP_R2Y_CSC_BT601 = 0,
-	VOP_R2Y_CSC_BT709
-};
-
-enum _vop_y2r_csc_mode {
-	VOP_Y2R_CSC_MPEG = 0,
-	VOP_Y2R_CSC_JPEG,
-	VOP_Y2R_CSC_HD,
-	VOP_Y2R_CSC_BYPASS
-};
-
-enum _vop_hwc_size {
-	VOP_HWC_SIZE_32,
-	VOP_HWC_SIZE_64
-};
-
-enum _vop_overlay_mode {
-	VOP_RGB_DOMAIN,
-	VOP_YUV_DOMAIN
-};
-
-
-#define CalScale(x, y)	             ((((u32)(x - 1)) * 0x1000) / (y - 1))
-#define INT_STA_MSK	(m_HS_INT_STA | m_FS_INT_STA |		\
-			 m_LF_INT_STA | m_BUS_ERR_INT_STA)
-#define INT_CLR_SHIFT	8
-
-struct rk_lcdc_drvdata {
-     u8 soc_type;
-     u32 reserve;
-};
-
-struct lcdc_device {
-	int id;
-        u8 soc_type;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;			/* back up reg */
-	u32 reg_phy_base;       	/* physical basic address of lcdc register */
-	u32 len;               		/* physical map length of lcdc register */
-	spinlock_t  reg_lock;		/* one time only one process allowed to config the register */
-
-	int __iomem *hwc_lut_addr_base;
-	int __iomem *dsp_lut_addr_base;
-
-	int prop;			/* used for primary or extended display device */
-	bool pre_init;
-	bool pwr18;			/* if lcdc use 1.8v power supply */
-	bool clk_on;			/* if aclk or hclk is closed ,acess to register is not allowed */
-	bool sclk_on;			/* if sclk is open or closed */
-	u8 atv_layer_cnt;		/* active layer counter,when atv_layer_cnt = 0,lcdc is disable*/
-
-	unsigned int		irq;
-
-	struct clk		*pd;	/* lcdc power domain */
-	struct clk		*hclk;	/* lcdc AHP clk */
-	struct clk		*dclk;	/* lcdc dclk */
-	struct clk		*aclk;	/* lcdc share memory frequency */
-        struct clk              *sclk;  /* scaler clk */
-	struct clk		*pll_sclk;
-	u32 pixclock;
-        u32 s_pixclock;
-
-	u32 standby;			/* 1:standby,0:work */
-	struct backlight_device *backlight;
-	u32 iommu_status;
-};
-
-static inline void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);	
-	*_pv = v;
-	writel_relaxed(v, lcdc_dev->regs + offset);	
-}
-
-static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
-{
-	u32 v;
-	v = readl_relaxed(lcdc_dev->regs + offset);
-	return v;
-}
-
-static inline u32 lcdc_readl_backup(struct lcdc_device *lcdc_dev, u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32*)lcdc_dev->regsbak;
-	_pv += (offset >> 2);
-	v = readl_relaxed(lcdc_dev->regs + offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev, u32 offset,
-                                u32 msk) 
-{
-       u32 _v = readl_relaxed(lcdc_dev->regs + offset); 
-       _v &= msk;
-       return (_v? 1 : 0);   
-}
-
-static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev, u32 offset,
-                                 u32 msk) 
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) |= msk;				
-	writel_relaxed(*_pv, lcdc_dev->regs + offset); 
-} 
-
-static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev, u32 offset,
-                                u32 msk)
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) &= (~msk);				
-	writel_relaxed(*_pv, lcdc_dev->regs + offset); 
-} 
-
-static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev, u32 offset,
-                                 u32 msk, u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);			
-	(*_pv) &= (~msk);				
-	(*_pv) |= v;				
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);	
-}
-
-static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
-{
-	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE); 
-	dsb();	
-} 
-
-#endif /* _RK312X_LCDC_H_ */
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.c b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
deleted file mode 100755
index b689e9c33752..000000000000
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.c
+++ /dev/null
@@ -1,1666 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk3188_lcdc.c
- *
- * Copyright (C) 2013 ROCKCHIP, Inc.
- *Author:yxj<yxj@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/grf.h>
-
-#include "rk3188_lcdc.h"
-
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		printk(KERN_INFO x); } while (0)
-
-//#define WAIT_FOR_SYNC 1
-
-static int rk3188_lcdc_get_id(u32 phy_base)
-{
-	if (cpu_is_rk319x()) {
-		if (phy_base == 0xffc40000)
-			return 0;
-		else if (phy_base == 0xffc50000)
-			return 1;
-		else
-			return -EINVAL;
-	} else if (cpu_is_rk3188()) {
-		if (phy_base == 0x1010c000)
-			return 0;
-		else if (phy_base == 0x1010e000)
-			return 1;
-		else
-			return -EINVAL;
-	} else if (cpu_is_rk3026()) {
-		if (phy_base == 0x1010e000)
-			return 0;
-		else if (phy_base == 0x01110000)
-			return 1;
-		else
-			return -EINVAL;
-	} else {
-		pr_err("un supported platform \n");
-		return -EINVAL;
-	}
-
-}
-
-static int rk3188_lcdc_set_lut(struct rk_lcdc_driver *dev_drv)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 256; i++) {
-		v = dev_drv->cur_screen->dsp_lut[i];
-		c = lcdc_dev->dsp_lut_addr_base + i;
-		writel_relaxed(v, c);
-
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
-
-	return 0;
-
-}
-
-static int rk3188_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
-{
-
-	if (!lcdc_dev->clk_on) {
-		clk_prepare_enable(lcdc_dev->hclk);
-		clk_prepare_enable(lcdc_dev->dclk);
-		clk_prepare_enable(lcdc_dev->aclk);
-		//clk_enable(lcdc_dev->pd);
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	return 0;
-}
-
-static int rk3188_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
-{
-	if (lcdc_dev->clk_on) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		clk_disable_unprepare(lcdc_dev->dclk);
-		clk_disable_unprepare(lcdc_dev->hclk);
-		clk_disable_unprepare(lcdc_dev->aclk);
-		//clk_disable(lcdc_dev->pd);
-	}
-	return 0;
-}
-
-static int rk3188_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device,
-						driver);
-	int *cbase = (int *)lcdc_dev->regs;
-	int *regsbak = (int *)lcdc_dev->regsbak;
-	int i, j;
-
-	printk("back up reg:\n");
-	for (i = 0; i <= (0x90 >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			printk("%08x  ", *(regsbak + i * 4 + j));
-		printk("\n");
-	}
-
-	printk("lcdc reg:\n");
-	for (i = 0; i <= (0x90 >> 4); i++) {
-		for (j = 0; j < 4; j++)
-			printk("%08x  ", readl_relaxed(cbase + i * 4 + j));
-		printk("\n");
-	}
-	return 0;
-}
-
-static void rk3188_lcdc_read_reg_defalut_cfg(struct lcdc_device
-					     *lcdc_dev)
-{
-	int reg = 0;
-	u32 value = 0;
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	for (reg = 0; reg < REG_CFG_DONE; reg += 4) {
-		value = lcdc_readl(lcdc_dev, reg);
-		switch (reg) {
-		case SYS_CTRL:
-			lcdc_dev->standby = (value & m_LCDC_STANDBY) >> 17;
-			win0->state = (value & m_WIN0_EN) >> 0;
-			win1->state = (value & m_WIN1_EN) >> 1;
-			if (lcdc_dev->id == 0)
-				lcdc_dev->atv_layer_cnt = win0->state;
-			else
-				lcdc_dev->atv_layer_cnt = win1->state;
-			win0->area[0].swap_rb = (value & m_WIN0_RB_SWAP) >> 15;
-			win1->area[0].swap_rb = (value & m_WIN1_RB_SWAP) >> 19;
-			win0->area[0].fmt_cfg = (value & m_WIN0_FORMAT) >> 3;
-			win1->area[0].fmt_cfg = (value & m_WIN1_FORMAT) >> 6;
-			break;
-		case WIN0_SCL_FACTOR_YRGB:
-			win0->scale_yrgb_x = (value >> 0) & 0xffff;
-			win0->scale_yrgb_y = (value >> 16) & 0xffff;
-			break;
-		case WIN0_SCL_FACTOR_CBR:
-			win0->scale_cbcr_x = (value >> 0) & 0xffff;
-			win0->scale_cbcr_y = (value >> 16) & 0xffff;
-			break;
-		case WIN0_ACT_INFO:
-			win0->area[0].xact = (((value >> 0) & 0x1fff) + 1);
-			win0->area[0].yact = (((value >> 16) & 0x1fff) + 1);
-			break;
-		case WIN0_DSP_ST:
-			win0->area[0].dsp_stx = (value >> 0) & 0xfff;
-			win0->area[0].dsp_sty = (value >> 16) & 0xfff;
-			break;
-		case WIN0_DSP_INFO:
-			win0->area[0].xsize = (((value >> 0) & 0x7ff) + 1);
-			win0->area[0].ysize = (((value >> 16) & 0x7ff) + 1);
-			break;
-		case WIN_VIR:
-			win0->area[0].y_vir_stride = (value >> 0) & 0x1fff;
-			win1->area[0].y_vir_stride = (value) & 0x1fff0000;
-			break;
-		case WIN0_YRGB_MST0:
-			win0->area[0].y_addr = value >> 0;
-			break;
-		case WIN0_CBR_MST0:
-			win0->area[0].uv_addr = value >> 0;
-			break;
-		case WIN1_DSP_INFO:
-			win1->area[0].xsize = (((value >> 0) & 0x7ff) + 1);
-			win1->area[0].ysize = (((value >> 16) & 0x7ff) + 1);
-			break;
-		case WIN1_DSP_ST:
-			win1->area[0].dsp_stx = (value >> 0) & 0xfff;
-			win1->area[0].dsp_sty = (value >> 16) & 0xfff;
-			break;
-		case WIN1_MST:
-			win1->area[0].y_addr = value >> 0;
-			break;
-		default:
-			DBG(2, "%s:uncare reg\n", __func__);
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-
-/********do basic init*********/
-static int rk3188_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	int v;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-
-	if (lcdc_dev->pre_init)
-		return 0;
-
-	if (lcdc_dev->id == 0) {
-		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc0");
-		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc0");
-		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc0");
-		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc0");
-	} else if (lcdc_dev->id == 1) {
-		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc1");
-		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc1");
-		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc1");
-		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc1");
-	} else {
-		dev_err(lcdc_dev->dev, "invalid lcdc device!\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||
-	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
-			lcdc_dev->id);
-	}
-
-	/*uboot display has enabled lcdc in boot */
-	if (!support_uboot_display()) {
-		rk_disp_pwr_enable(dev_drv);
-		rk3188_lcdc_clk_enable(lcdc_dev);
-	} else {
-		lcdc_dev->clk_on = 1;
-	}
-
-	rk3188_lcdc_read_reg_defalut_cfg(lcdc_dev);
-
-	if (lcdc_dev->id == 0) {
-		if (lcdc_dev->pwr18 == true) {
-			v = 0x40004000;	/*bit14: 1,1.8v;0,3.3v*/
-			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
-		} else {
-			v = 0x40000000;
-			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
-		}
-	}
-
-	if (lcdc_dev->id == 1) {
-		if (lcdc_dev->pwr18 == true) {
-			v = 0x80008000;	/*bit14: 1,1.8v;0,3.3v*/
-			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
-		} else {
-			v = 0x80000000;
-			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
-		}
-		pinctrl_select_state(lcdc_dev->dev->pins->p,
-				     lcdc_dev->dev->pins->default_state);
-	}
-
-	lcdc_set_bit(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN);
-	lcdc_cfg_done(lcdc_dev);
-	lcdc_dev->pre_init = true;
-
-	return 0;
-}
-
-static void rk3188_lcdc_deint(struct lcdc_device *lcdc_dev)
-{
-	u32 mask, val;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_dev->clk_on = 0;
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-		mask = m_HS_INT_EN | m_FS_INT_EN | m_LF_INT_EN |
-			m_BUS_ERR_INT_EN;
-		val = v_HS_INT_EN(0) | v_FS_INT_EN(0) |
-			v_LF_INT_EN(0) | v_BUS_ERR_INT_EN(0);
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
-		lcdc_set_bit(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY);
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-
-}
-
-static int rk3188_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
-{
-	int win0_top = 0;
-	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
-
-	int win0_alpha_en = ((win0_format == ARGB888)
-			     || (win0_format == ABGR888)) ? 1 : 0;
-	int win1_alpha_en = ((win1_format == ARGB888)
-			     || (win1_format == ABGR888)) ? 1 : 0;
-	u32 *_pv = (u32 *) lcdc_dev->regsbak;
-	_pv += (DSP_CTRL0 >> 2);
-	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
-	if (win0_top && (lcdc_dev->atv_layer_cnt >= 2) && (win0_alpha_en)) {
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, m_WIN0_ALPHA_EN |
-			     m_WIN1_ALPHA_EN, v_WIN0_ALPHA_EN(1) |
-			     v_WIN1_ALPHA_EN(0));
-		mask = m_WIN0_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
-		val = v_WIN0_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else if ((!win0_top) && (lcdc_dev->atv_layer_cnt >= 2)
-		   && (win1_alpha_en)) {
-		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-
-		mask = m_WIN1_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
-		val = v_WIN1_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-	} else {
-		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
-		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
-		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
-	}
-
-	return 0;
-}
-
-static int rk3188_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
-	int timeout;
-	unsigned long flags;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(lcdc_dev->standby));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,
-			     m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP |
-			     m_WIN1_RB_SWAP,
-			     v_WIN0_EN(win0->state) | v_WIN1_EN(win1->state) |
-			     v_WIN0_RB_SWAP(win0->area[0].swap_rb) |
-			     v_WIN1_RB_SWAP(win1->area[0].swap_rb));
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
-			    v_X_SCL_FACTOR(win0->scale_yrgb_x) |
-			    v_Y_SCL_FACTOR(win0->scale_yrgb_y));
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
-			    v_X_SCL_FACTOR(win0->scale_cbcr_x) |
-			    v_Y_SCL_FACTOR(win0->scale_cbcr_y));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_FORMAT,
-			     v_WIN0_FORMAT(win0->area[0].fmt_cfg));
-		lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_ACT_WIDTH(win0->area[0].xact) |
-			    v_ACT_HEIGHT(win0->area[0].yact));
-		lcdc_writel(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(win0->area[0].dsp_stx) |
-			    v_DSP_STY(win0->area[0].dsp_sty));
-		lcdc_writel(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(win0->area[0].xsize) |
-			    v_DSP_HEIGHT(win0->area[0].ysize));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR,
-			     v_WIN0_VIR_VAL(win0->area[0].y_vir_stride));
-		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, win0->area[0].y_addr);
-		lcdc_writel(lcdc_dev, WIN0_CBR_MST0, win0->area[0].uv_addr);
-		lcdc_writel(lcdc_dev, WIN1_DSP_INFO, v_DSP_WIDTH(win1->area[0].xsize) |
-			    v_DSP_HEIGHT(win1->area[0].ysize));
-		lcdc_writel(lcdc_dev, WIN1_DSP_ST, v_DSP_STX(win1->area[0].dsp_stx) |
-			    v_DSP_STY(win1->area[0].dsp_sty));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
-			     ((win1->area[0].y_vir_stride)&0x1fff)<<16);
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_FORMAT,
-			     v_WIN1_FORMAT(win1->area[0].fmt_cfg));
-		lcdc_writel(lcdc_dev, WIN1_MST, win1->area[0].y_addr);
-		rk3188_lcdc_alpha_cfg(lcdc_dev);
-		lcdc_cfg_done(lcdc_dev);
-
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	//if (dev_drv->wait_fs) {
-	if (0) {
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-						      msecs_to_jiffies
-						      (dev_drv->cur_screen->ft +
-						       5));
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_warn(lcdc_dev->dev, "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
-	return 0;
-
-}
-
-static int rk3188_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
-{
-	memcpy((u8 *) lcdc_dev->regs, (u8 *) lcdc_dev->regsbak, 0x84);
-	return 0;
-}
-
-
-static int rk3188_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	int fps;
-	u16 face = 0;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 right_margin = screen->mode.right_margin;
-	u16 left_margin = screen->mode.left_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-			break;
-		default:
-			dev_err(lcdc_dev->dev, "un supported interface!\n");
-			break;
-		}
-
-		mask = m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
-		    m_DEN_POL | m_DCLK_POL;
-		val = v_DSP_OUT_FORMAT(face) | v_HSYNC_POL(screen->pin_hsync) |
-		    v_VSYNC_POL(screen->pin_vsync) | v_DEN_POL(screen->pin_den) |
-		    v_DCLK_POL(screen->pin_dclk);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-
-		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
-		    m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		    m_DSP_DUMMY_SWAP | m_BLANK_EN;
-		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
-		    v_DSP_RB_SWAP(screen->swap_rb) | v_DSP_RG_SWAP(screen->
-								   swap_rg) |
-		    v_DSP_DELTA_SWAP(screen->
-				     swap_delta) | v_DSP_DUMMY_SWAP(screen->
-								    swap_dumy) |
-		    v_BLANK_EN(0) | v_BLACK_EN(0);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-		val =
-		    v_HSYNC(screen->mode.hsync_len) | v_HORPRD(screen->mode.
-							       hsync_len +
-							       left_margin +
-							       x_res +
-							       right_margin);
-		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
-		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
-		    v_HASP(screen->mode.hsync_len + left_margin);
-		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
-
-		val =
-		    v_VSYNC(screen->mode.vsync_len) | v_VERPRD(screen->mode.
-							       vsync_len +
-							       upper_margin +
-							       y_res +
-							       lower_margin);
-		lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
-
-		val = v_VAEP(screen->mode.vsync_len + upper_margin + y_res) |
-		    v_VASP(screen->mode.vsync_len + screen->mode.upper_margin);
-		lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-
-	return 0;
-}
-
-/*enable layer,open:1,enable;0 disable*/
-static int win0_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[0]->state = open;
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN, v_WIN0_EN(open));
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win1_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[1]->state = open;
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN, v_WIN1_EN(open));
-		/*if no layer used,disable lcdc*/
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3188_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
-			    bool open)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-
-	/*enable clk,when first layer open */
-	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
-		rk3188_lcdc_pre_init(dev_drv);
-		rk3188_lcdc_clk_enable(lcdc_dev);
-		rk3188_lcdc_reg_restore(lcdc_dev);
-		rk3188_load_screen(dev_drv, 1);
-		spin_lock(&lcdc_dev->reg_lock);
-		if (dev_drv->cur_screen->dsp_lut)
-			rk3188_lcdc_set_lut(dev_drv);
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	if (win_id == 0)
-		win0_open(lcdc_dev, open);
-	else if (win_id == 1)
-		win1_open(lcdc_dev, open);
-	else
-		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
-
-	/*when all layer closed,disable clk */
-	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
-		lcdc_msk_reg(lcdc_dev, INT_STATUS,
-			     m_FS_INT_CLEAR, v_FS_INT_CLEAR(1));
-		rk3188_lcdc_reg_update(dev_drv);
-		rk3188_lcdc_clk_disable(lcdc_dev);
-	}
-
-	return 0;
-}
-
-static int win0_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = win->area[0].smem_start+win->area[0].y_offset;
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",
-	    	lcdc_dev->id, __func__, y_addr, uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, y_addr);
-		lcdc_writel(lcdc_dev, WIN0_CBR_MST0, uv_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-
-}
-
-static int win1_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",
-	    lcdc_dev->id, __func__, y_addr, uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on))
-		lcdc_writel(lcdc_dev,WIN1_MST,y_addr);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-
-static int rk3188_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv, 
-						struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 msk, val;
-#if defined(WAIT_FOR_SYNC)
-	int timeout;
-	unsigned long flags;
-#endif
-
-	if (!screen) {
-		dev_err(dev_drv->dev,"screen is null!\n");
-		return -ENOENT;
-	}
-	
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-		win0_display(lcdc_dev, win);
-	} else if(win_id==1) {
-		win = dev_drv->win[1];
-		win1_display(lcdc_dev, win);
-	} else {
-		dev_err(dev_drv->dev,"invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-	 /*this is the first frame of the system ,enable frame start interrupt*/
-	if ((dev_drv->first_frame))  {
-		dev_drv->first_frame = 0;
-		msk = m_FS_INT_CLEAR |m_FS_INT_EN;
-		val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1);
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, msk, val);
-
-	}
-
-#if defined(WAIT_FOR_SYNC)
-	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-	init_completion(&dev_drv->frame_done);
-	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-	timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-				msecs_to_jiffies(dev_drv->cur_screen->ft +5));
-	if (!timeout && (!dev_drv->frame_done.done)) {
-		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
-		return -ETIMEDOUT;
-	}
-#endif
-
-	return 0;
-}
-
-
-static int win0_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	u8 fmt_cfg = 0;
-	char fmt[9] = "NULL";
-	xact = win->area[0].xact;
-	yact = win->area[0].yact;
-	xvir = win->area[0].xvir;
-	yvir = win->area[0].yvir;
-	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
-
-	ScaleYrgbX = CalScale(xact, win->area[0].xsize);
-	ScaleYrgbY = CalScale(yact, win->area[0].ysize);
-	switch (win->area[0].format) {
-	case ARGB888:
-	case XBGR888:
-	case ABGR888:
-		fmt_cfg = 0;
-		break;
-	case RGB888:
-		fmt_cfg = 1;
-		break;
-	case RGB565:
-		fmt_cfg = 2;
-		break;
-	case YUV422:
-		fmt_cfg = 5;
-		ScaleCbrX = CalScale((xact / 2), win->area[0].xsize);
-		ScaleCbrY = CalScale(yact, win->area[0].ysize);
-		break;
-	case YUV420:
-		fmt_cfg = 4;
-		ScaleCbrX = CalScale(xact / 2, win->area[0].xsize);
-		ScaleCbrY = CalScale(yact / 2, win->area[0].ysize);
-		break;
-	case YUV444:
-		fmt_cfg = 6;
-		ScaleCbrX = CalScale(xact, win->area[0].xsize);
-		ScaleCbrY = CalScale(yact, win->area[0].ysize);
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-			__func__);
-		break;
-	}
-
-	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->area[0].format, fmt), xact,
-		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	
-	win->scale_yrgb_x = ScaleYrgbX;
-	win->scale_yrgb_y = ScaleYrgbY;
-	win->scale_cbcr_x = ScaleCbrX;
-	win->scale_cbcr_y = ScaleCbrY;
-	win->area[0].fmt_cfg = fmt_cfg;
-	win->area[0].dsp_stx = xpos;
-	win->area[0].dsp_sty = ypos;
-	
-	switch (win->area[0].format) {
-	case XBGR888:
-	case ABGR888:
-		win->area[0].swap_rb = 1;
-		break;
-	case ARGB888:
-		win->area[0].swap_rb = 0;
-		break;
-	case RGB888:
-		win->area[0].swap_rb = 0;
-		break;
-	case RGB565:
-		win->area[0].swap_rb = 0;
-		break;
-	case YUV422:
-	case YUV420:
-	case YUV444:
-		win->area[0].swap_rb = 0;
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev,
-			"%s:un supported format!\n", __func__);
-		break;
-	}
-
-	
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_WIN0_FORMAT,v_WIN0_FORMAT(fmt_cfg));         
-		lcdc_writel(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		lcdc_writel(lcdc_dev, WIN0_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		lcdc_writel(lcdc_dev, WIN0_DSP_INFO,v_DSP_WIDTH(win->area[0].xsize) |
-						v_DSP_HEIGHT(win->area[0].ysize));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR, v_WIN0_VIR_VAL(win->area[0].y_vir_stride));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN0_RB_SWAP,
-			     v_WIN0_EN(win->state) |
-			     v_WIN0_RB_SWAP(win->area[0].swap_rb));
-		lcdc_msk_reg(lcdc_dev, WIN0_COLOR_KEY, m_COLOR_KEY_EN, v_COLOR_KEY_EN(0));
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-
-}
-
-static int win1_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u8 fmt_cfg;
-	char fmt[9] = "NULL";
-	xact = win->area[0].xact;
-	yact = win->area[0].yact;
-	xvir = win->area[0].xvir;
-	yvir = win->area[0].yvir;
-	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
-
-	DBG(1, "lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->area[0].format, fmt),
-		xact, yact, win->area[0].xsize, win->area[0].ysize,
-		xvir, yvir, xpos, ypos);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	win->area[0].dsp_stx = xpos;
-	win->area[0].dsp_sty = ypos;
-	switch (win->area[0].format) {
-	case XBGR888:
-	case ABGR888:
-		fmt_cfg = 0;
-		win->area[0].swap_rb = 1;
-		break;
-	case ARGB888:
-		fmt_cfg = 0;
-		win->area[0].swap_rb = 0;
-
-		break;
-	case RGB888:
-		fmt_cfg = 1;
-		win->area[0].swap_rb = 0;
-		break;
-	case RGB565:
-		fmt_cfg = 2;
-		win->area[0].swap_rb = 0;
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev,
-			"%s:un supported format!\n", __func__);
-		break;
-	}
-	win->area[0].fmt_cfg = fmt_cfg;
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(win->area[0].xsize) |
-							v_DSP_HEIGHT(win->area[0].ysize));
-		lcdc_writel(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN | m_WIN1_RB_SWAP,
-			     v_WIN1_EN(win->state) |
-			     v_WIN1_RB_SWAP(win->area[0].swap_rb));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_WIN1_FORMAT, v_WIN1_FORMAT(fmt_cfg));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
-			     ((win->area[0].y_vir_stride)&0x1fff)<<16);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3188_lcdc_set_par(struct rk_lcdc_driver *dev_drv,int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-	
-	if (win_id == 0) {
-		win = dev_drv->win[0];
-		win0_set_par(lcdc_dev, screen, win);
-	} else if (win_id == 1) {
-		win = dev_drv->win[1];
-		win1_set_par(lcdc_dev, screen, win);
-	} else {
-		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
-		return -EINVAL;
-	}
-	
-	if (lcdc_dev->clk_on) {
-		rk3188_lcdc_alpha_cfg(lcdc_dev);
-	}
-
-	return 0;
-}
-
-
-
-static int rk3188_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-			     unsigned long arg, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = lcdc_dev->screen->mode.xres;
-		panel_size[1] = lcdc_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
-			    clr_key_cfg.win0_color_key_cfg);
-		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
-			    clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int rk3188_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	if (dev_drv->suspend_flag) 
-		return 0;
-	dev_drv->suspend_flag = 1;
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
-			     v_BLANK_EN(1));
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(1));
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	rk3188_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(dev_drv);
-	return 0;
-}
-
-static int rk3188_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int i = 0;
-	int __iomem *c;
-	int v;
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-	dev_drv->suspend_flag = 0;
-
-	if (lcdc_dev->atv_layer_cnt) {
-		rk3188_lcdc_clk_enable(lcdc_dev);
-		rk3188_lcdc_reg_restore(lcdc_dev);
-
-		spin_lock(&lcdc_dev->reg_lock);
-		if (dev_drv->cur_screen->dsp_lut) {
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
-				     v_DSP_LUT_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-			mdelay(25);
-			for (i = 0; i < 256; i++) {
-				v = dev_drv->cur_screen->dsp_lut[i];
-				c = lcdc_dev->dsp_lut_addr_base + i;
-				writel_relaxed(v, c);
-			}
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
-				     v_DSP_LUT_EN(1));
-		}
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(0));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
-			     v_LCDC_STANDBY(0));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
-			     v_BLANK_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	return 0;
-}
-
-
-static int rk3188_lcdc_blank(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		rk3188_lcdc_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		rk3188_lcdc_early_suspend(dev_drv);
-		break;
-	default:
-		rk3188_lcdc_early_suspend(dev_drv);
-		break;
-	}
-	
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int rk3188_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
-				     int win_id,
-				     int area_id)
-{
-	return 0;
-}
-
-static int rk3188_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (set) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
-				     v_WIN0_TOP(swap));
-			ovl = swap;
-		} else {
-			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static ssize_t rk3188_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
-					 char *buf, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char status_w0[9] = "NULL";
-	char status_w1[9] = "NULL";
-	u32 fmt_id, act_info, dsp_info, dsp_st, factor;
-	u16 xvir_w0, x_act_w0, y_act_w0, x_dsp_w0, y_dsp_w0;
-	u16 x_st_w0, y_st_w0, x_factor, y_factor;
-	u16 xvir_w1, x_dsp_w1, y_dsp_w1, x_st_w1, y_st_w1;
-	u16 x_scale, y_scale, ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
-		ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
-		switch ((fmt_id & m_WIN0_FORMAT) >> 3) {
-		case 0:
-			strcpy(format_w0, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w0, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w0, "RGB565");
-			break;
-		case 4:
-			strcpy(format_w0, "YCbCr420");
-			break;
-		case 5:
-			strcpy(format_w0, "YCbCr422");
-			break;
-		case 6:
-			strcpy(format_w0, "YCbCr444");
-			break;
-		default:
-			strcpy(format_w0, "invalid\n");
-			break;
-		}
-
-		switch ((fmt_id & m_WIN1_FORMAT) >> 6) {
-		case 0:
-			strcpy(format_w1, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w1, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w1, "RGB565");
-			break;
-		case 4:
-			strcpy(format_w1, "8bpp");
-			break;
-		case 5:
-			strcpy(format_w1, "4bpp");
-			break;
-		case 6:
-			strcpy(format_w1, "2bpp");
-			break;
-		case 7:
-			strcpy(format_w1, "1bpp");
-			break;
-		default:
-			strcpy(format_w1, "invalid\n");
-			break;
-		}
-
-		if (fmt_id & m_WIN0_EN)
-			strcpy(status_w0, "enabled");
-		else
-			strcpy(status_w0, "disabled");
-
-		if ((fmt_id & m_WIN1_EN) >> 1)
-			strcpy(status_w1, "enabled");
-		else
-			strcpy(status_w1, "disabled");
-
-		xvir_w0 = lcdc_readl(lcdc_dev, WIN_VIR) & 0x1fff;
-		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
-		factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
-		x_act_w0 = (act_info & 0x1fff) + 1;
-		y_act_w0 = ((act_info >> 16) & 0x1fff) + 1;
-		x_dsp_w0 = (dsp_info & 0x7ff) + 1;
-		y_dsp_w0 = ((dsp_info >> 16) & 0x7ff) + 1;
-		x_st_w0 = dsp_st & 0xffff;
-		y_st_w0 = dsp_st >> 16;
-		x_factor = factor & 0xffff;
-		y_factor = factor >> 16;
-		x_scale = 4096 * 100 / x_factor;
-		y_scale = 4096 * 100 / y_factor;
-		xvir_w1 = (lcdc_readl(lcdc_dev, WIN_VIR) >> 16) & 0x1fff;
-		dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
-		x_dsp_w1 = (dsp_info & 0x7ff) + 1;
-		y_dsp_w1 = ((dsp_info >> 16) & 0x7ff) + 1;
-		x_st_w1 = dsp_st & 0xffff;
-		y_st_w1 = dsp_st >> 16;
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return snprintf(buf, PAGE_SIZE,
-			"win0:%s\n"
-			"xvir:%d\n"
-			"xact:%d\n"
-			"yact:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"x_scale:%d.%d\n"
-			"y_scale:%d.%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"CBR buffer addr:0x%08x\n\n"
-			"win1:%s\n"
-			"xvir:%d\n"
-			"xdsp:%d\n"
-			"ydsp:%d\n"
-			"x_st:%d\n"
-			"y_st:%d\n"
-			"format:%s\n"
-			"YRGB buffer addr:0x%08x\n"
-			"overlay:%s\n",
-			status_w0,
-			xvir_w0,
-			x_act_w0,
-			y_act_w0,
-			x_dsp_w0,
-			y_dsp_w0,
-			x_st_w0,
-			y_st_w0,
-			x_scale / 100,
-			x_scale % 100,
-			y_scale / 100,
-			y_scale % 100,
-			format_w0,
-			lcdc_readl(lcdc_dev, WIN0_YRGB_MST0),
-			lcdc_readl(lcdc_dev, WIN0_CBR_MST0),
-			status_w1,
-			xvir_w1,
-			x_dsp_w1,
-			y_dsp_w1,
-			x_st_w1,
-			y_st_w1,
-			format_w1,
-			lcdc_readl(lcdc_dev, WIN1_MST),
-			ovl ? "win0 on the top of win1\n" :
-			"win1 on the top of win0\n");
-}
-
-static int rk3188_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-	if (set) {
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
-	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(lcdc_dev->dclk), fps);
-
-	return fps;
-}
-
-static int rk3188_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
-	dev_drv->fb2_win_id = order / 100;
-	dev_drv->fb1_win_id = (order / 10) % 10;
-	dev_drv->fb0_win_id = order % 10;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int rk3188_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
-				  const char *id)
-{
-	int win_id = 0;
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0") || !strcmp(id, "fb2"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1") || !strcmp(id, "fb3"))
-		win_id = dev_drv->fb1_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int rk3188_set_dsp_lut(struct rk_lcdc_driver *dev_drv, int *lut)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	int ret = 0;
-
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	msleep(25);
-	if (dev_drv->cur_screen->dsp_lut) {
-		for (i = 0; i < 256; i++) {
-			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
-			c = lcdc_dev->dsp_lut_addr_base + i;
-			writel_relaxed(v, c);
-
-		}
-	} else {
-		dev_err(dev_drv->dev, "no buffer to backup lut data!\n");
-		ret = -1;
-	}
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
-	lcdc_cfg_done(lcdc_dev);
-
-	return ret;
-}
-
-static int rk3188_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN,
-		     v_DIRECT_PATCH_EN(open));
-	lcdc_cfg_done(lcdc_dev);
-	return 0;
-}
-
-static int rk3188_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_LAY_SEL,
-		     v_DIRECT_PATH_LAY_SEL(win_id));
-	lcdc_cfg_done(lcdc_dev);
-	return 0;
-
-}
-
-static int rk3188_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN);
-	return ovl;
-}
-
-int rk3188_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 int_reg;
-	int ret;
-
-	if (lcdc_dev->clk_on) {
-		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-		if (int_reg & m_LF_INT_STA) {
-			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
-				     v_LF_INT_CLEAR(1));
-			ret = RK_LF_STATUS_FC;
-		} else
-			ret = RK_LF_STATUS_FR;
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-
-static int rk3188_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,unsigned int dsp_addr[][4])
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if(lcdc_dev->clk_on){
-		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST0);
-		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
-	}
-	return 0;
-}
-
-static int rk3188_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv, 
-					struct lcdc_device, driver);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on)
-		lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-
-static struct rk_lcdc_win lcdc_win[] = {
-	[0] = {
-	       .name = "win0",
-	       .id = 0,
-	       .support_3d = true,
-	       },
-	[1] = {
-	       .name = "win1",
-	       .id = 1,
-	       .support_3d = false,
-	       },
-};
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open			= rk3188_lcdc_open,
-	.load_screen 		= rk3188_load_screen,
-	.set_par 		= rk3188_lcdc_set_par,
-	.pan_display 		= rk3188_lcdc_pan_display,
-	.blank 			= rk3188_lcdc_blank,
-	.ioctl 			= rk3188_lcdc_ioctl,
-	.get_win_state 		= rk3188_lcdc_get_win_state,
-	.ovl_mgr 		= rk3188_lcdc_ovl_mgr,
-	.get_disp_info 		= rk3188_lcdc_get_disp_info,
-	.fps_mgr 		= rk3188_lcdc_fps_mgr,
-	.fb_get_win_id 		= rk3188_lcdc_get_win_id,
-	.fb_win_remap 		= rk3188_fb_win_remap,
-	.set_dsp_lut 		= rk3188_set_dsp_lut,
-	.poll_vblank 		= rk3188_lcdc_poll_vblank,
-	.dpi_open 		= rk3188_lcdc_dpi_open,
-	.dpi_win_sel 		= rk3188_lcdc_dpi_win_sel,
-	.dpi_status 		= rk3188_lcdc_dpi_status,
-	.get_dsp_addr 		= rk3188_lcdc_get_dsp_addr,
-	.cfg_done		= rk3188_lcdc_cfg_done,
-	.dump_reg 		= rk3188_lcdc_reg_dump,
-};
-
-static irqreturn_t rk3188_lcdc_isr(int irq, void *dev_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    (struct lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
-
-	if (int_reg & m_FS_INT_STA) {
-		timestamp = ktime_get();
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-		//if (lcdc_dev->driver.wait_fs) {
-		if (0) {	
-			spin_lock(&(lcdc_dev->driver.cpl_lock));
-			complete(&(lcdc_dev->driver.frame_done));
-			spin_unlock(&(lcdc_dev->driver.cpl_lock));
-		}
-		lcdc_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-
-	} else if (int_reg & m_LF_INT_STA) {
-		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
-			     v_LF_INT_CLEAR(1));
-	}
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_PM)
-static int rk3188_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk3188_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define rk3188_lcdc_suspend NULL
-#define rk3188_lcdc_resume  NULL
-#endif
-
-static int rk3188_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
-{
-	struct device_node *np = lcdc_dev->dev->of_node;
-	int val;
-	if (of_property_read_u32(np, "rockchip,prop", &val))
-		lcdc_dev->prop = PRMRY;	/*default set it as primary */
-	else
-		lcdc_dev->prop = val;
-
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-		lcdc_dev->pwr18 = false;	/*default set it as 3.xv power supply */
-	else
-		lcdc_dev->pwr18 = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
-	else
-		lcdc_dev->driver.fb_win_map = val;
-
-	return 0;
-}
-
-static int rk3188_lcdc_probe(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct device_node *np = pdev->dev.of_node;
-	int prop;
-	int ret = 0;
-
-	/*if the primary lcdc has not registered ,the extend
-	   lcdc register later */
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		if (!is_prmry_rk_lcdc_registered())
-			return -EPROBE_DEFER;
-	}
-	lcdc_dev = devm_kzalloc(dev,
-				sizeof(struct lcdc_device), GFP_KERNEL);
-	if (!lcdc_dev) {
-		dev_err(&pdev->dev, "rk3188 lcdc device kmalloc fail!");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->dev = dev;
-	rk3188_lcdc_parse_dt(lcdc_dev);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-	lcdc_dev->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(lcdc_dev->regs))
-		return PTR_ERR(lcdc_dev->regs);
-
-	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
-	if (IS_ERR(lcdc_dev->regsbak))
-		return PTR_ERR(lcdc_dev->regsbak);
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
-	lcdc_dev->id = rk3188_lcdc_get_id(lcdc_dev->reg_phy_base);
-	if (lcdc_dev->id < 0) {
-		dev_err(&pdev->dev, "no such lcdc device!\n");
-		return -ENXIO;
-	}
-	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
-	dev_drv = &lcdc_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = prop;
-	dev_drv->id = lcdc_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
-	spin_lock_init(&lcdc_dev->reg_lock);
-
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if (lcdc_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			lcdc_dev->id);
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(dev, lcdc_dev->irq, rk3188_lcdc_isr,
-			       IRQF_DISABLED, dev_name(dev), lcdc_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			lcdc_dev->irq, ret);
-		return ret;
-	}
-
-	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
-		return ret;
-	}
-	lcdc_dev->screen = dev_drv->screen0;
-	
-	dev_info(dev, "lcdc%d probe ok\n", lcdc_dev->id);
-
-	return 0;
-}
-
-static int rk3188_lcdc_remove(struct platform_device *pdev)
-{
-
-	return 0;
-}
-
-static void rk3188_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-
-	rk3188_lcdc_deint(lcdc_dev);
-	rk_disp_pwr_disable(&lcdc_dev->driver);
-}
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3188_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3188-lcdc",},
-	{}
-};
-#endif
-
-static struct platform_driver rk3188_lcdc_driver = {
-	.probe = rk3188_lcdc_probe,
-	.remove = rk3188_lcdc_remove,
-	.driver = {
-		   .name = "rk3188-lcdc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(rk3188_lcdc_dt_ids),
-		   },
-	.suspend = rk3188_lcdc_suspend,
-	.resume = rk3188_lcdc_resume,
-	.shutdown = rk3188_lcdc_shutdown,
-};
-
-static int __init rk3188_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk3188_lcdc_driver);
-}
-
-static void __exit rk3188_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk3188_lcdc_driver);
-}
-
-fs_initcall(rk3188_lcdc_module_init);
-module_exit(rk3188_lcdc_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.h b/drivers/video/rockchip/lcdc/rk3188_lcdc.h
deleted file mode 100644
index 3e199e5f71ce..000000000000
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.h
+++ /dev/null
@@ -1,413 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK3188_LCDC_H_
-#define RK3188_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-
-
-/*******************register definition**********************/
-
-#define SYS_CTRL 		(0x00)
-#define m_WIN0_EN		(1<<0)
-#define m_WIN1_EN		(1<<1)
-#define m_HWC_EN		(1<<2)
-#define m_WIN0_FORMAT		(7<<3)
-#define m_WIN1_FORMAT		(7<<6)
-#define m_HWC_COLOR_MODE	(1<<9)
-#define m_HWC_SIZE		(1<<10)
-#define m_WIN0_3D_EN		(1<<11)
-#define m_WIN0_3D_MODE		(7<<12)
-#define m_WIN0_RB_SWAP		(1<<15)
-#define m_WIN0_ALPHA_SWAP	(1<<16)
-#define m_WIN0_Y8_SWAP		(1<<17)
-#define m_WIN0_UV_SWAP		(1<<18)
-#define m_WIN1_RB_SWAP		(1<<19)
-#define m_WIN1_ALPHA_SWAP	(1<<20)
-#define m_WIN1_BL_SWAP		(1<<21)
-#define m_WIN0_OTSD_DISABLE	(1<<22)
-#define m_WIN1_OTSD_DISABLE	(1<<23)
-#define m_DMA_BURST_LENGTH	(3<<24)
-#define m_HWC_LODAD_EN		(1<<26)
-#define m_WIN1_LUT_EN		(1<<27)
-#define m_DSP_LUT_EN		(1<<28)
-#define m_DMA_STOP		(1<<29)
-#define m_LCDC_STANDBY		(1<<30)
-#define m_AUTO_GATING_EN	(1<<31)
-#define v_WIN0_EN(x)		(((x)&1)<<0)
-#define v_WIN1_EN(x)		(((x)&1)<<1)
-#define v_HWC_EN(x)		(((x)&1)<<2)
-#define v_WIN0_FORMAT(x)	(((x)&7)<<3)
-#define v_WIN1_FORMAT(x)	(((x)&7)<<6)
-#define v_HWC_COLOR_MODE(x)	(((x)&1)<<9)
-#define v_HWC_SIZE(x)		(((x)&1)<<10)
-#define v_WIN0_3D_EN(x)		(((x)&1)<<11)
-#define v_WIN0_3D_MODE(x)	(((x)&7)<<12)
-#define v_WIN0_RB_SWAP(x)	(((x)&1)<<15)
-#define v_WIN0_ALPHA_SWAP(x)	(((x)&1)<<16)
-#define v_WIN0_Y8_SWAP(x)	(((x)&1)<<17)
-#define v_WIN0_UV_SWAP(x)	(((x)&1)<<18)
-#define v_WIN1_RB_SWAP(x)	(((x)&1)<<19)
-#define v_WIN1_ALPHA_SWAP(x)	(((x)&1)<<20)
-#define v_WIN1_BL_SWAP(x)	(((x)&1)<<21)
-#define v_WIN0_OTSD_DISABLE(x)	(((x)&1)<<22)
-#define v_WIN1_OTSD_DISABLE(x)	(((x)&1)<<23)
-#define v_DMA_BURST_LENGTH(x)	(((x)&3)<<24)
-#define v_HWC_LODAD_EN(x)	(((x)&1)<<26)
-#define v_WIN1_LUT_EN(x)	(((x)&1)<<27)
-#define v_DSP_LUT_EN(x)		(((x)&1)<<28)
-#define v_DMA_STOP(x)		(((x)&1)<<29)
-#define v_LCDC_STANDBY(x)	(((x)&1)<<30)
-#define v_AUTO_GATING_EN(x)	(((x)&1)<<31)
-
-
-#define DSP_CTRL0		(0x04)
-#define m_DSP_OUT_FORMAT	(0x0f<<0)
-#define m_HSYNC_POL		(1<<4)
-#define m_VSYNC_POL		(1<<5)
-#define m_DEN_POL		(1<<6)
-#define m_DCLK_POL		(1<<7)
-#define m_WIN0_TOP		(1<<8)
-#define m_DITHER_UP_EN		(1<<9)
-#define m_DITHER_DOWN_MODE	(1<<10)
-#define m_DITHER_DOWN_EN	(1<<11)
-#define m_INTERLACE_DSP_EN	(1<<12)
-#define m_INTERLACE_POL		(1<<13)
-#define m_WIN0_INTERLACE_EN	(1<<14)
-#define m_WIN1_INTERLACE_EN	(1<<15)
-#define m_WIN0_YRGB_DEFLICK_EN	(1<<16)
-#define m_WIN0_CBR_DEFLICK_EN	(1<<17)
-#define m_WIN0_ALPHA_MODE	(1<<18)
-#define m_WIN1_ALPHA_MODE	(1<<19)
-#define m_WIN0_CSC_MODE		(3<<20)
-#define m_WIN1_CSC_MODE		(1<<22)
-#define m_WIN0_YUV_CLIP		(1<<23)
-#define m_DSP_CCIR656_AVG	(1<<24)
-#define m_DCLK_OUTPUT_MODE	(1<<25)
-#define m_DCLK_PHASE_LOCK	(1<<26)
-#define m_DITHER_DOWN_SEL	(3<<27)
-#define m_ALPHA_MODE_SEL0	(1<<29)
-#define m_ALPHA_MODE_SEL1	(1<<30)
-#define m_DIFF_DCLK_EN		(1<<31)
-#define v_DSP_OUT_FORMAT(x)	(((x)&0x0f)<<0)
-#define v_HSYNC_POL(x)		(((x)&1)<<4)
-#define v_VSYNC_POL(x)		(((x)&1)<<5)
-#define v_DEN_POL(x)		(((x)&1)<<6)
-#define v_DCLK_POL(x)		(((x)&1)<<7)
-#define v_WIN0_TOP(x)		(((x)&1)<<8)
-#define v_DITHER_UP_EN(x)	(((x)&1)<<9)
-#define v_DITHER_DOWN_MODE(x)	(((x)&1)<<10)
-#define v_DITHER_DOWN_EN(x)	(((x)&1)<<11)
-#define v_INTERLACE_DSP_EN(x)	(((x)&1)<<12)
-#define v_INTERLACE_POL(x)	(((x)&1)<<13)
-#define v_WIN0_INTERLACE_EN(x)	(((x)&1)<<14)
-#define v_WIN1_INTERLACE_EN(x)	(((x)&1)<<15)
-#define v_WIN0_YRGB_DEFLICK_EN(x)	(((x)&1)<<16)
-#define v_WIN0_CBR_DEFLICK_EN(x)	(((x)&1)<<17)
-#define v_WIN0_ALPHA_MODE(x)		(((x)&1)<<18)
-#define v_WIN1_ALPHA_MODE(x)		(((x)&1)<<19)
-#define v_WIN0_CSC_MODE(x)		(((x)&3)<<20)
-#define v_WIN1_CSC_MODE(x)		(((x)&1)<<22)
-#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<23)
-#define v_DSP_CCIR656_AVG(x)		(((x)&1)<<24)
-#define v_DCLK_OUTPUT_MODE(x)		(((x)&1)<<25)
-#define v_DCLK_PHASE_LOCK(x)		(((x)&1)<<26)
-#define v_DITHER_DOWN_SEL(x)		(((x)&1)<<27)
-#define v_ALPHA_MODE_SEL0(x)		(((x)&1)<<29)
-#define v_ALPHA_MODE_SEL1(x)		(((x)&1)<<30)
-#define v_DIFF_DCLK_EN(x)		(((x)&1)<<31)
-
-
-#define DSP_CTRL1		(0x08)
-#define m_BG_COLOR		(0xffffff<<0)
-#define m_BG_B			(0xff<<0)
-#define m_BG_G			(0xff<<8)
-#define m_BG_R			(0xff<<16)
-#define m_BLANK_EN		(1<<24)
-#define m_BLACK_EN		(1<<25)
-#define m_DSP_BG_SWAP		(1<<26)
-#define m_DSP_RB_SWAP		(1<<27)
-#define m_DSP_RG_SWAP		(1<<28)
-#define m_DSP_DELTA_SWAP	(1<<29)
-#define m_DSP_DUMMY_SWAP	(1<<30)
-#define m_DSP_OUT_ZERO		(1<<31)
-#define v_BG_COLOR(x)		(((x)&0xffffff)<<0)
-#define v_BG_B(x)		(((x)&0xff)<<0)
-#define v_BG_G(x)		(((x)&0xff)<<8)
-#define v_BG_R(x)		(((x)&0xff)<<16)
-#define v_BLANK_EN(x)		(((x)&1)<<24)
-#define v_BLACK_EN(x)		(((x)&1)<<25)
-#define v_DSP_BG_SWAP(x)	(((x)&1)<<26)
-#define v_DSP_RB_SWAP(x)	(((x)&1)<<27)
-#define v_DSP_RG_SWAP(x)	(((x)&1)<<28)
-#define v_DSP_DELTA_SWAP(x)	(((x)&1)<<29)
-#define v_DSP_DUMMY_SWAP(x)	(((x)&1)<<30)
-#define v_DSP_OUT_ZERO(x)	(((x)&1)<<31)
-
-
-#define MCU_CTRL		(0x0c)
-#define m_MCU_PIX_TOTAL		(0x3f<<0)
-#define m_MCU_CS_ST		(0x0f<<6)
-#define m_MCU_CS_END		(0x3f<<10)
-#define m_MCU_RW_ST		(0x0f<<16)
-#define m_MCU_RW_END		(0x3f<<20)
-#define m_MCU_CLK_SEL		(1<<26)
-#define m_MCU_HOLD_MODE		(1<<27)
-#define m_MCU_FS_HOLD_STA	(1<<28)
-#define m_MCU_RS_SELECT		(1<<29)
-#define m_MCU_BYPASS 		(1<<30)
-#define m_MCU_TYPE		(1<<31)
-
-#define v_MCU_PIX_TOTAL(x)		(((x)&0x3f)<<0)
-#define v_MCU_CS_ST(x)			(((x)&0x0f)<<6)
-#define v_MCU_CS_END(x)			(((x)&0x3f)<<10)
-#define v_MCU_RW_ST(x)			(((x)&0x0f)<<16)
-#define v_MCU_RW_END(x)			(((x)&0x3f)<<20)
-#define v_MCU_CLK_SEL(x)		(((x)&1)<<26)
-#define v_MCU_HOLD_MODE(x)		(((x)&1)<<27)
-#define v_MCU_FS_HOLD_STA(x)		(((x)&1)<<28)
-#define v_MCU_RS_SELECT(x)		(((x)&1)<<29)
-#define v_MCU_BYPASS(x) 		(((x)&1)<<30)
-#define v_MCU_TYPE(x)			(((x)&1)<<31)
-
-#define INT_STATUS		(0x10)
-#define m_HS_INT_STA		(1<<0)  //status
-#define m_FS_INT_STA		(1<<1)
-#define m_LF_INT_STA		(1<<2)
-#define m_BUS_ERR_INT_STA	(1<<3)
-#define m_HS_INT_EN		(1<<4)  //enable
-#define m_FS_INT_EN          	(1<<5)
-#define m_LF_INT_EN         	(1<<6)
-#define m_BUS_ERR_INT_EN	(1<<7)
-#define m_HS_INT_CLEAR		(1<<8) //auto clear
-#define m_FS_INT_CLEAR		(1<<9)
-#define m_LF_INT_CLEAR		(1<<10)
-#define m_BUS_ERR_INT_CLEAR	(1<<11)
-#define m_LF_INT_NUM		(0xfff<<12)
-#define v_HS_INT_EN(x)		(((x)&1)<<4)
-#define v_FS_INT_EN(x)		(((x)&1)<<5)
-#define v_LF_INT_EN(x)		(((x)&1)<<6)
-#define v_BUS_ERR_INT_EN(x)	(((x)&1)<<7)
-#define v_HS_INT_CLEAR(x)	(((x)&1)<<8)
-#define v_FS_INT_CLEAR(x)	(((x)&1)<<9)
-#define v_LF_INT_CLEAR(x)	(((x)&1)<<10)
-#define v_BUS_ERR_INT_CLEAR(x)	(((x)&1)<<11)
-#define v_LF_INT_NUM(x)		(((x)&0xfff)<<12)
-
-
-#define ALPHA_CTRL		(0x14)
-#define m_WIN0_ALPHA_EN		(1<<0)
-#define m_WIN1_ALPHA_EN		(1<<1)
-#define m_HWC_ALPAH_EN		(1<<2)
-#define m_WIN0_ALPHA_VAL	(0xff<<4)
-#define m_WIN1_ALPHA_VAL	(0xff<<12)
-#define m_HWC_ALPAH_VAL		(0x0f<<20)
-#define v_WIN0_ALPHA_EN(x)	(((x)&1)<<0)
-#define v_WIN1_ALPHA_EN(x)	(((x)&1)<<1)
-#define v_HWC_ALPAH_EN(x)	(((x)&1)<<2)
-#define v_WIN0_ALPHA_VAL(x)	(((x)&0xff)<<4)
-#define v_WIN1_ALPHA_VAL(x)	(((x)&0xff)<<12)
-#define v_HWC_ALPAH_VAL(x)	(((x)&0x0f)<<20)
-
-#define WIN0_COLOR_KEY		(0x18)
-#define m_COLOR_KEY_VAL		(0xffffff<<0)
-#define m_COLOR_KEY_EN		(1<<24)
-#define v_COLOR_KEY_VAL(x)	(((x)&0xffffff)<<0)
-#define v_COLOR_KEY_EN(x)	(((x)&1)<<24)
-
-#define WIN1_COLOR_KEY		(0x1C)
-
-
-#define WIN0_YRGB_MST0		(0x20)
-#define WIN0_CBR_MST0		(0x24)
-#define WIN0_YRGB_MST1		(0x28)
-#define WIN0_CBR_MST1		(0x2C)
-#define WIN_VIR			(0x30)
-#define m_WIN0_VIR   		(0x1fff << 0)
-#define m_WIN1_VIR   		(0x1fff << 16)
-#define v_WIN0_VIR_VAL(x)       ((x)<<0)
-#define v_WIN1_VIR_VAL(x)       ((x)<<16)
-#define v_ARGB888_VIRWIDTH(x) 	(((x)&0x1fff)<<0)
-#define v_RGB888_VIRWIDTH(x) 	(((((x*3)>>2)+((x)%3))&0x1fff)<<0)
-#define v_RGB565_VIRWIDTH(x) 	 ((DIV_ROUND_UP(x,2)&0x1fff)<<0)
-#define v_YUV_VIRWIDTH(x)    	 ((DIV_ROUND_UP(x,4)&0x1fff)<<0)
-#define v_WIN1_ARGB888_VIRWIDTH(x) 	(((x)&0x1fff)<<16)
-#define v_WIN1_RGB888_VIRWIDTH(x) 	(((((x*3)>>2)+((x)%3))&0x1fff)<<16)
-#define v_WIN1_RGB565_VIRWIDTH(x) 	 ((DIV_ROUND_UP(x,2)&0x1fff)<<16)
-
-
-
-#define WIN0_ACT_INFO		(0x34)
-#define m_ACT_WIDTH       	(0x1fff<<0)
-#define m_ACT_HEIGHT      	(0x1fff<<16)
-#define v_ACT_WIDTH(x)       	(((x-1)&0x1fff)<<0)
-#define v_ACT_HEIGHT(x)      	(((x-1)&0x1fff)<<16)
-
-#define WIN0_DSP_INFO		(0x38)
-#define v_DSP_WIDTH(x)     	(((x-1)&0x7ff)<<0)
-#define v_DSP_HEIGHT(x)    	(((x-1)&0x7ff)<<16)
-
-#define WIN0_DSP_ST		(0x3C)
-#define v_DSP_STX(x)      	(((x)&0xfff)<<0)
-#define v_DSP_STY(x)      	(((x)&0xfff)<<16)
-
-#define WIN0_SCL_FACTOR_YRGB	(0x40)
-#define v_X_SCL_FACTOR(x)  (((x)&0xffff)<<0)
-#define v_Y_SCL_FACTOR(x)  (((x)&0xffff)<<16)
-
-#define WIN0_SCL_FACTOR_CBR	(0x44)
-#define WIN0_SCL_OFFSET		(0x48)
-#define WIN1_MST		(0x4C)
-#define WIN1_DSP_INFO		(0x50)
-#define WIN1_DSP_ST		(0x54)
-#define HWC_MST			(0x58)
-#define HWC_DSP_ST		(0x5C)
-#define HWC_COLOR_LUT0		(0x60)
-#define HWC_COLOR_LUT1		(0x64)
-#define HWC_COLOR_LUT2		(0x68)
-#define DSP_HTOTAL_HS_END	(0x6C)
-#define v_HSYNC(x)  		(((x)&0xfff)<<0)   //hsync pulse width
-#define v_HORPRD(x) 		(((x)&0xfff)<<16)   //horizontal period
-
-#define DSP_HACT_ST_END		(0x70)
-#define v_HAEP(x) 		(((x)&0xfff)<<0)  //horizontal active end point
-#define v_HASP(x) 		(((x)&0xfff)<<16) //horizontal active start point
-
-#define DSP_VTOTAL_VS_END	(0x74)
-#define v_VSYNC(x) 		(((x)&0xfff)<<0)
-#define v_VERPRD(x) 		(((x)&0xfff)<<16)
-#define DSP_VACT_ST_END		(0x78)
-#define v_VAEP(x) 		(((x)&0xfff)<<0)
-#define v_VASP(x) 		(((x)&0xfff)<<16)
-
-#define DSP_VS_ST_END_F1	(0x7C)
-#define DSP_VACT_ST_END_F1	(0x80)
-#define REG_CFG_DONE		(0x90)
-#define MCU_BYPASS_WPORT	(0x100)
-#define MCU_BYPASS_RPORT	(0x200)
-#define WIN1_LUT_ADDR		(0x400)
-#define DSP_LUT_ADDR		(0x800)
-
-/*
-	RK3026/RK3028A max output  resolution 1920x1080
-	support IEP instead of  3d
-*/
-//#ifdef CONFIG_ARCH_RK3026
-//SYS_CTRL 0x00
-#define m_DIRECT_PATCH_EN         (1<<11)
-#define m_DIRECT_PATH_LAY_SEL     (1<<12)
-
-#define v_DIRECT_PATCH_EN(x)      (((x)&1)<<11)
-#define v_DIRECT_PATH_LAY_SEL(x)  (((x)&1)<<12)
-
-//INT_STATUS 0x10
-#define m_WIN0_EMPTY_INTR_EN      (1<<24)
-#define m_WIN1_EMPTY_INTR_EN      (1<<25)
-#define m_WIN0_EMPTY_INTR_CLR     (1<<26)
-#define m_WIN1_EMPTY_INTR_CLR     (1<<27)
-#define m_WIN0_EMPTY_INTR_STA     (1<<28)
-#define m_WIN1_EMPTY_INTR_STA     (1<<29)
-
-#define v_WIN0_EMPTY_INTR_EN(x)   (((x)&1)<<24)
-#define v_WIN1_EMPTY_INTR_EN(x)   (((x)&1)<<25)
-#define v_WIN0_EMPTY_INTR_CLR(x)  (((x)&1)<<26)
-#define v_WIN1_EMPTY_INTR_CLR(x)  (((x)&1)<<27)
-#define v_WIN0_EMPTY_INTR_STA(x)  (((x)&1)<<28)
-#define v_WIN1_EMPTY_INTR_STA(x)  (((x)&1)<<29)
-//#endif
-
-
-#define CalScale(x, y)	             ((((u32)(x-1))*0x1000)/(y-1))
-
-struct lcdc_device{
-	int id;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;			//back up reg
-	u32 reg_phy_base;       	// physical basic address of lcdc register
-	u32 len;               		// physical map length of lcdc register
-	spinlock_t  reg_lock;		//one time only one process allowed to config the register
-	
-	int __iomem *dsp_lut_addr_base;
-
-	int prop;			/*used for primary or extended display device*/
-	bool pre_init;
-	bool pwr18;			/*if lcdc use 1.8v power supply*/
-	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
-	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
-	
-
-	unsigned int		irq;
-
-	struct clk		*pd;				//lcdc power domain
-	struct clk		*hclk;				//lcdc AHP clk
-	struct clk		*dclk;				//lcdc dclk
-	struct clk		*aclk;				//lcdc share memory frequency
-	u32 pixclock;	
-
-	u32 standby;						//1:standby,0:wrok
-};
-
-
-
-static inline void lcdc_writel(struct lcdc_device *lcdc_dev,u32 offset,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);	
-	*_pv = v;
-	writel_relaxed(v,lcdc_dev->regs+offset);	
-}
-
-static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev,u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32*)lcdc_dev->regsbak;
-	_pv += (offset >> 2);
-	v = readl_relaxed(lcdc_dev->regs+offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-       u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
-       _v &= msk;
-       return (_v?1:0);   
-}
-
-static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) |= msk;				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk)
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) &= (~msk);				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);			
-	(*_pv) &= (~msk);				
-	(*_pv) |= v;				
-	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
-}
-
-static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
-{
-	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
-	dsb();	
-} 
-
-#endif
diff --git a/drivers/video/rockchip/lcdc/rk322x_lcdc.c b/drivers/video/rockchip/lcdc/rk322x_lcdc.c
deleted file mode 100644
index 7e52f5b799f5..000000000000
--- a/drivers/video/rockchip/lcdc/rk322x_lcdc.c
+++ /dev/null
@@ -1,5334 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk322x_lcdc.c
- *
- * Copyright (C) 2015 ROCKCHIP, Inc.
- * Author: Mark Yao <mark.yao@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/devfreq.h>
-#include <linux/devfreq-event.h>
-#include <linux/rockchip-iovmm.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rockchip/grf.h>
-#include <dt-bindings/clock/rk_system_status.h>
-#include <soc/rockchip/rkfb_dmc.h>
-#include <linux/of_gpio.h>
-
-#include "rk322x_lcdc.h"
-
-/*#define CONFIG_RK_FPGA 1*/
-#define VOP_CHIP(dev)	(dev->data->chip_type)
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		pr_info(x);\
-	} while (0)
-
-static struct rk_lcdc_win rk322x_vop_win[] = {
-	{ .name = "win0",
-	  .id = VOP_WIN0,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_SCALE | SUPPORT_YUV |
-				SUPPORT_YUV10BIT,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{ .name = "win1",
-	  .id = VOP_WIN1,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_SCALE | SUPPORT_YUV |
-				SUPPORT_YUV10BIT,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{
-	  .name = "hwc",
-	  .id = VOP_HWC,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_HWC_LAYER,
-	  .property.max_input_x = 128,
-	  .property.max_input_y = 128
-	}
-};
-
-static struct rk_lcdc_win rk3399_vop_win[] = {
-	{ .name = "win0",
-	  .id = VOP_WIN0,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_SCALE | SUPPORT_YUV |
-				SUPPORT_YUV10BIT,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{ .name = "win1",
-	  .id = VOP_WIN1,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_SCALE | SUPPORT_YUV |
-				SUPPORT_YUV10BIT,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{ .name = "win2",
-	  .id = VOP_WIN2,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_MULTI_AREA,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{ .name = "win3",
-	  .id = VOP_WIN3,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_MULTI_AREA,
-	  .property.max_input_x = 4096,
-	  .property.max_input_y = 2304},
-	{
-	  .name = "hwc",
-	  .id = VOP_HWC,
-	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
-				SUPPORT_HWC_LAYER,
-	  .property.max_input_x = 128,
-	  .property.max_input_y = 128
-	}
-};
-
-static const struct vop_data rk322x_data = {
-	.chip_type = VOP_RK322X,
-	.win = rk322x_vop_win,
-	.n_wins = ARRAY_SIZE(rk322x_vop_win),
-};
-
-static const struct vop_data rk3399_data = {
-	.chip_type = VOP_RK3399,
-	.win = rk3399_vop_win,
-	.n_wins = ARRAY_SIZE(rk3399_vop_win),
-};
-
-#if defined(CONFIG_OF)
-static const struct of_device_id vop_dt_ids[] = {
-	{.compatible = "rockchip,rk322x-lcdc",
-	 .data = &rk322x_data, },
-	{.compatible = "rockchip,rk3399-lcdc",
-	 .data = &rk3399_data, },
-	{}
-};
-#endif
-
-static const u32 csc_y2r_bt601_limit[12] = {
-	0x04a8,      0,  0x0662, 0xfffc8654,
-	0x04a8, 0xfe6f,  0xfcbf, 0x00022056,
-	0x04a8, 0x0812,       0, 0xfffbaeac,
-};
-
-static const u32 csc_y2r_bt709_full[12] = {
-	0x04a8,      0,  0x072c, 0xfffc219e,
-	0x04a8, 0xff26,  0xfdde, 0x0001357b,
-	0x04a8, 0x0873,       0, 0xfffb7dee,
-};
-
-static const u32 csc_y2r_bt601_full[12] = {
-	0x0400,      0,  0x059c, 0xfffd342d,
-	0x0400, 0xfea0,  0xfd25, 0x00021fcc,
-	0x0400, 0x0717,       0, 0xfffc76bc,
-};
-
-static const u32 csc_y2r_bt601_limit_10[12] = {
-	0x04a8,      0,  0x0662, 0xfff2134e,
-	0x04a8, 0xfe6f,  0xfcbf, 0x00087b58,
-	0x04a8, 0x0812,       0, 0xffeeb4b0,
-};
-
-static const u32 csc_y2r_bt709_full_10[12] = {
-	0x04a8,      0,  0x072c, 0xfff08077,
-	0x04a8, 0xff26,  0xfdde, 0x0004cfed,
-	0x04a8, 0x0873,       0, 0xffedf1b8,
-};
-
-static const u32 csc_y2r_bt601_full_10[12] = {
-	0x0400,      0,  0x059c, 0xfff4cab4,
-	0x0400, 0xfea0,  0xfd25, 0x00087932,
-	0x0400, 0x0717,       0, 0xfff1d4f2,
-};
-
-static const u32 csc_y2r_bt2020[12] = {
-	0x04a8,      0, 0x06b6, 0xfff16bfc,
-	0x04a8, 0xff40, 0xfd66, 0x58ae9,
-	0x04a8, 0x0890,      0, 0xffedb828,
-};
-
-static const u32 csc_r2y_bt601_limit[12] = {
-	0x0107, 0x0204, 0x0064, 0x04200,
-	0xff68, 0xfed6, 0x01c2, 0x20200,
-	0x01c2, 0xfe87, 0xffb7, 0x20200,
-};
-
-static const u32 csc_r2y_bt709_full[12] = {
-	0x00bb, 0x0275, 0x003f, 0x04200,
-	0xff99, 0xfea5, 0x01c2, 0x20200,
-	0x01c2, 0xfe68, 0xffd7, 0x20200,
-};
-
-static const u32 csc_r2y_bt601_full[12] = {
-	0x0132, 0x0259, 0x0075, 0x200,
-	0xff53, 0xfead, 0x0200, 0x20200,
-	0x0200, 0xfe53, 0xffad, 0x20200,
-};
-
-static const u32 csc_r2y_bt601_limit_10[12] = {
-	0x0107, 0x0204, 0x0064, 0x10200,
-	0xff68, 0xfed6, 0x01c2, 0x80200,
-	0x01c2, 0xfe87, 0xffb7, 0x80200,
-};
-
-static const u32 csc_r2y_bt709_full_10[12] = {
-	0x00bb, 0x0275, 0x003f, 0x10200,
-	0xff99, 0xfea5, 0x01c2, 0x80200,
-	0x01c2, 0xfe68, 0xffd7, 0x80200,
-};
-
-static const u32 csc_r2y_bt601_full_10[12] = {
-	0x0132, 0x0259, 0x0075, 0x200,
-	0xff53, 0xfead, 0x0200, 0x80200,
-	0x0200, 0xfe53, 0xffad, 0x80200,
-};
-
-static const u32 csc_r2y_bt2020[12] = {
-	0x00e6, 0x0253, 0x0034, 0x10200,
-	0xff83, 0xfebd, 0x01c1, 0x80200,
-	0x01c1, 0xfe64, 0xffdc, 0x80200,
-};
-
-static const u32 csc_r2r_bt2020to709[12] = {
-	0x06a4, 0xfda6, 0xffb5, 0x200,
-	0xff80, 0x0488, 0xfff8, 0x200,
-	0xffed, 0xff99, 0x047a, 0x200,
-};
-
-static const u32 csc_r2r_bt709to2020[12] = {
-	0x282, 0x151, 0x02c, 0x200,
-	0x047, 0x3ae, 0x00c, 0x200,
-	0x011, 0x05a, 0x395, 0x200,
-};
-
-static int vop_get_id(struct vop_device *vop_dev, u32 phy_base)
-{
-	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-		if (phy_base == 0xff900000) /* vop big */
-			return 0;
-		else if (phy_base == 0xff8f0000) /* vop lit */
-			return 1;
-		else
-			return -EINVAL;
-	} else {
-		return 0;
-	}
-}
-
-static void vop_load_csc_table(struct vop_device *vop_dev, u32 offset,
-			       const u32 *table)
-{
-	u32 csc_val;
-
-	csc_val = table[1] << 16 | table[0];
-	vop_writel(vop_dev, offset, csc_val);
-	csc_val = table[4] << 16 | table[2];
-	vop_writel(vop_dev, offset + 4, csc_val);
-	csc_val = table[6] << 16 | table[5];
-	vop_writel(vop_dev, offset + 8, csc_val);
-	csc_val = table[9] << 16 | table[8];
-	vop_writel(vop_dev, offset + 0xc, csc_val);
-	csc_val = table[10];
-	vop_writel(vop_dev, offset + 0x10, csc_val);
-	csc_val = table[3];
-	vop_writel(vop_dev, offset + 0x14, csc_val);
-	csc_val = table[7];
-	vop_writel(vop_dev, offset + 0x18, csc_val);
-	csc_val = table[11];
-	vop_writel(vop_dev, offset + 0x1c, csc_val);
-}
-
-#define LOAD_CSC(dev, mode, table, win_id) \
-		vop_load_csc_table(dev, \
-				   WIN0_YUV2YUV_##mode + 0x60 * win_id, \
-				   table)
-
-static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
-
-static int vop_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	int i, j;
-
-	if (!vop_dev->dsp_lut_addr_base) {
-		dev_warn(vop_dev->dev, "not support dsp lut config\n");
-		return 0;
-	}
-
-	if (!dsp_lut) {
-		dev_err(vop_dev->dev, "dsp lut table is null\n");
-		return -EINVAL;
-	}
-
-	spin_lock(&vop_dev->reg_lock);
-	for (i = 0; i < 256; i++) {
-		u32 v, r, g, b;
-		int __iomem *c;
-
-		v = dsp_lut[i];
-		if (dev_drv->id == 0) {
-			c = vop_dev->dsp_lut_addr_base + (i << 2);
-			b = (v & 0xff) << 2;
-			g = (v & 0xff00) << 4;
-			r = (v & 0xff0000) << 6;
-			v = r + g + b;
-			for (j = 0; j < 4; j++) {
-				writel_relaxed(v, c);
-				v += (1 + (1 << 10) + (1 << 20));
-				c++;
-			}
-		} else {
-			c = vop_dev->dsp_lut_addr_base + i;
-			writel_relaxed(v, c);
-		}
-	}
-	vop_msk_reg(vop_dev, DSP_CTRL1, V_DSP_LUT_EN(1));
-	/*
-	 * update_gamma value auto clean to 0 by HW, should not
-	 * bakeup it.
-	 */
-	vop_msk_reg_nobak(vop_dev, DSP_CTRL1, V_UPDATE_GAMMA_LUT(1));
-
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_cabc(struct rk_lcdc_driver *dev_drv, int *cabc_lut)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	int i;
-
-	if (!vop_dev->cabc_lut_addr_base) {
-		dev_warn(vop_dev->dev, "not support cabc config\n");
-		return 0;
-	}
-
-	if (!cabc_lut) {
-		dev_err(vop_dev->dev, "cabc lut table is null\n");
-		return -EINVAL;
-	}
-	spin_lock(&vop_dev->reg_lock);
-	vop_msk_reg(vop_dev, CABC_CTRL1, V_CABC_LUT_EN(0));
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-
-	mdelay(25);
-
-	spin_lock(&vop_dev->reg_lock);
-	for (i = 0; i < 128; i++) {
-		u32 v;
-
-		v = cabc_lut[i];
-
-		writel_relaxed(v, vop_dev->cabc_lut_addr_base + i);
-	}
-	vop_msk_reg(vop_dev, CABC_CTRL1, V_CABC_LUT_EN(1));
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_clk_enable(struct vop_device *vop_dev)
-{
-	if (!vop_dev->clk_on) {
-		clk_prepare_enable(vop_dev->hclk);
-		clk_prepare_enable(vop_dev->dclk);
-		clk_prepare_enable(vop_dev->aclk);
-		if (vop_dev->hclk_noc)
-			clk_prepare_enable(vop_dev->hclk_noc);
-		if (vop_dev->aclk_noc)
-			clk_prepare_enable(vop_dev->aclk_noc);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-		pm_runtime_get_sync(vop_dev->dev);
-#endif
-		spin_lock(&vop_dev->reg_lock);
-		vop_dev->clk_on = 1;
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int vop_clk_disable(struct vop_device *vop_dev)
-{
-	if (vop_dev->clk_on) {
-		spin_lock(&vop_dev->reg_lock);
-		vop_dev->clk_on = 0;
-		spin_unlock(&vop_dev->reg_lock);
-		mdelay(25);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-		pm_runtime_put_sync(vop_dev->dev);
-#endif
-		clk_disable_unprepare(vop_dev->dclk);
-		clk_disable_unprepare(vop_dev->hclk);
-		clk_disable_unprepare(vop_dev->aclk);
-		if (vop_dev->hclk_noc)
-			clk_disable_unprepare(vop_dev->hclk_noc);
-		if (vop_dev->aclk_noc)
-			clk_disable_unprepare(vop_dev->aclk_noc);
-	}
-
-	return 0;
-}
-
-static int __maybe_unused vop_disable_irq(struct vop_device *vop_dev)
-{
-	if (likely(vop_dev->clk_on)) {
-		spin_lock(&vop_dev->reg_lock);
-		vop_writel(vop_dev, INTR_EN0, 0xffff0000);
-		vop_writel(vop_dev, INTR_EN1, 0xffff0000);
-		vop_writel(vop_dev, INTR_CLEAR0, 0xffffffff);
-		vop_writel(vop_dev, INTR_CLEAR1, 0xffffffff);
-		vop_cfg_done(vop_dev);
-		spin_unlock(&vop_dev->reg_lock);
-	};
-
-	return 0;
-}
-
-static int vop_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int *cbase = (int *)vop_dev->regs;
-	int *regsbak = (int *)vop_dev->regsbak;
-	int i, j, val;
-	char dbg_message[30];
-	char buf[10];
-
-	pr_info("lcd back up reg:\n");
-	memset(dbg_message, 0, sizeof(dbg_message));
-	memset(buf, 0, sizeof(buf));
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		val = sprintf(dbg_message, "0x%04x: ", i * 16);
-		for (j = 0; j < 4; j++) {
-			val = sprintf(buf, "%08x  ", *(regsbak + i * 4 + j));
-			strcat(dbg_message, buf);
-		}
-		pr_info("%s\n", dbg_message);
-		memset(dbg_message, 0, sizeof(dbg_message));
-		memset(buf, 0, sizeof(buf));
-	}
-
-	pr_info("lcdc reg:\n");
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		val = sprintf(dbg_message, "0x%04x: ", i * 16);
-		for (j = 0; j < 4; j++) {
-			sprintf(buf, "%08x  ",
-				readl_relaxed(cbase + i * 4 + j));
-			strcat(dbg_message, buf);
-		}
-		pr_info("%s\n", dbg_message);
-		memset(dbg_message, 0, sizeof(dbg_message));
-		memset(buf, 0, sizeof(buf));
-	}
-
-	return 0;
-}
-
-#define WIN_EN(id)		\
-static int win##id##_enable(struct vop_device *vop_dev, int en)	\
-{ \
-	spin_lock(&vop_dev->reg_lock);					\
-	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN((u64)en));	\
-	vop_cfg_done(vop_dev);						\
-	spin_unlock(&vop_dev->reg_lock);				\
-	return 0;							\
-}
-
-WIN_EN(0);
-WIN_EN(1);
-WIN_EN(2);
-WIN_EN(3);
-
-/*enable/disable win directly*/
-static int vop_win_direct_en(struct rk_lcdc_driver *drv,
-			     int win_id, int en)
-{
-	struct vop_device *vop_dev =
-	    container_of(drv, struct vop_device, driver);
-
-	drv->win[win_id]->state = en;
-	if (win_id == 0)
-		win0_enable(vop_dev, en);
-	else if (win_id == 1)
-		win1_enable(vop_dev, en);
-	else if (win_id == 2)
-		win2_enable(vop_dev, en);
-	else if (win_id == 3)
-		win3_enable(vop_dev, en);
-	else
-		dev_err(vop_dev->dev, "invalid win number:%d\n", win_id);
-	return 0;
-}
-
-#define SET_WIN_ADDR(id) \
-static int set_win##id##_addr(struct vop_device *vop_dev, u32 addr) \
-{							\
-	spin_lock(&vop_dev->reg_lock);			\
-	vop_writel(vop_dev, WIN##id##_YRGB_MST, addr);	\
-	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN(1));	\
-	vop_cfg_done(vop_dev);			\
-	spin_unlock(&vop_dev->reg_lock);		\
-	return 0;					\
-}
-
-SET_WIN_ADDR(0);
-SET_WIN_ADDR(1);
-int vop_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
-			    int win_id, u32 addr)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	if (win_id == 0)
-		set_win0_addr(vop_dev, addr);
-	else
-		set_win1_addr(vop_dev, addr);
-
-	return 0;
-}
-
-static void lcdc_read_reg_defalut_cfg(struct vop_device *vop_dev)
-{
-	int reg = 0;
-	u32 val = 0;
-	struct rk_screen *screen = vop_dev->driver.cur_screen;
-	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
-	u32 V_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
-	u32 st_x, st_y;
-	struct rk_lcdc_win *win0 = vop_dev->driver.win[0];
-
-	spin_lock(&vop_dev->reg_lock);
-	for (reg = 0; reg < vop_dev->len; reg += 4) {
-		val = vop_readl_backup(vop_dev, reg);
-		switch (reg) {
-		case WIN0_ACT_INFO:
-			win0->area[0].xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
-			win0->area[0].yact =
-				((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-			break;
-		case WIN0_DSP_INFO:
-			win0->area[0].xsize = (val & MASK(WIN0_DSP_WIDTH)) + 1;
-			win0->area[0].ysize =
-			    ((val & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
-			break;
-		case WIN0_DSP_ST:
-			st_x = val & MASK(WIN0_DSP_XST);
-			st_y = (val & MASK(WIN0_DSP_YST)) >> 16;
-			win0->area[0].xpos = st_x - h_pw_bp;
-			win0->area[0].ypos = st_y - V_pw_bp;
-			break;
-		case WIN0_CTRL0:
-			win0->state = val & MASK(WIN0_EN);
-			win0->area[0].fmt_cfg =
-					(val & MASK(WIN0_DATA_FMT)) >> 1;
-			win0->fmt_10 = (val & MASK(WIN0_FMT_10)) >> 4;
-			win0->area[0].format = win0->area[0].fmt_cfg;
-			break;
-		case WIN0_VIR:
-			win0->area[0].y_vir_stride =
-					val & MASK(WIN0_VIR_STRIDE);
-			win0->area[0].uv_vir_stride =
-			    (val & MASK(WIN0_VIR_STRIDE_UV)) >> 16;
-			if (win0->area[0].format == ARGB888)
-				win0->area[0].xvir = win0->area[0].y_vir_stride;
-			else if (win0->area[0].format == RGB888)
-				win0->area[0].xvir =
-				    win0->area[0].y_vir_stride * 4 / 3;
-			else if (win0->area[0].format == RGB565)
-				win0->area[0].xvir =
-				    2 * win0->area[0].y_vir_stride;
-			else
-				win0->area[0].xvir =
-				    4 * win0->area[0].y_vir_stride;
-			break;
-		case WIN0_YRGB_MST:
-			win0->area[0].smem_start = val;
-			break;
-		case WIN0_CBR_MST:
-			win0->area[0].cbr_start = val;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-}
-
-/********do basic init*********/
-static int vop_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	if (vop_dev->pre_init)
-		return 0;
-	vop_dev->hclk = devm_clk_get(vop_dev->dev, "hclk_lcdc");
-	vop_dev->aclk = devm_clk_get(vop_dev->dev, "aclk_lcdc");
-	vop_dev->dclk = devm_clk_get(vop_dev->dev, "dclk_lcdc");
-	if (IS_ERR(vop_dev->aclk) || IS_ERR(vop_dev->dclk) ||
-	    IS_ERR(vop_dev->hclk)) {
-		dev_err(vop_dev->dev, "failed to get clk source\n");
-		return -1;
-	}
-	vop_dev->hclk_noc = devm_clk_get(vop_dev->dev, "hclk_vop_noc");
-	if (IS_ERR(vop_dev->hclk_noc)) {
-		vop_dev->hclk_noc = NULL;
-		dev_err(vop_dev->dev, "failed to get clk source\n");
-	}
-	vop_dev->aclk_noc = devm_clk_get(vop_dev->dev, "aclk_vop_noc");
-	if (IS_ERR(vop_dev->aclk_noc)) {
-		vop_dev->aclk_noc = NULL;
-		dev_err(vop_dev->dev, "failed to get clk source\n");
-	}
-	if (!support_uboot_display())
-		rk_disp_pwr_enable(dev_drv);
-	vop_clk_enable(vop_dev);
-
-	memcpy(vop_dev->regsbak, vop_dev->regs, vop_dev->len);
-	/*backup reg config at uboot */
-	lcdc_read_reg_defalut_cfg(vop_dev);
-	#ifndef CONFIG_RK_FPGA
-	/*
-	 * Todo, not verified
-	 *
-	if (vop_dev->pwr18 == 1) {
-		v = 0x00200020;
-		vop_grf_writel(vop_dev->pmugrf_base,
-				PMUGRF_SOC_CON0_VOP, v);
-	} else {
-		v = 0x00200000;
-		vop_grf_writel(vop_dev->pmugrf_base,
-				PMUGRF_SOC_CON0_VOP, v);
-	}
-	*/
-	#endif
-	vop_writel(vop_dev, FRC_LOWER01_0, 0x12844821);
-	vop_writel(vop_dev, FRC_LOWER01_1, 0x21488412);
-	vop_writel(vop_dev, FRC_LOWER10_0, 0xa55a9696);
-	vop_writel(vop_dev, FRC_LOWER10_1, 0x5aa56969);
-	vop_writel(vop_dev, FRC_LOWER11_0, 0xdeb77deb);
-	vop_writel(vop_dev, FRC_LOWER11_1, 0xed7bb7de);
-
-	if (!dev_drv->cabc_mode)
-		vop_msk_reg(vop_dev, SYS_CTRL, V_AUTO_GATING_EN(0));
-	vop_msk_reg(vop_dev, DSP_CTRL1, V_DITHER_UP_EN(1));
-	vop_cfg_done(vop_dev);
-	if ((dev_drv->cur_screen->refresh_mode == SCREEN_CMD_MODE) &&
-	    (support_uboot_display() == 0))
-		vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(1));
-	vop_dev->pre_init = true;
-
-	return 0;
-}
-
-static void vop_deint(struct vop_device *vop_dev)
-{
-	if (vop_dev->clk_on) {
-		u64 val;
-
-		vop_disable_irq(vop_dev);
-		spin_lock(&vop_dev->reg_lock);
-		vop_msk_reg(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
-		vop_msk_reg(vop_dev, WIN1_CTRL0, V_WIN0_EN(0));
-
-		val = V_WIN2_EN(0) | V_WIN2_MST0_EN(0) | V_WIN2_MST1_EN(0) |
-			V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
-		vop_msk_reg(vop_dev, WIN2_CTRL0, val);
-		vop_msk_reg(vop_dev, WIN3_CTRL0, val);
-		vop_cfg_done(vop_dev);
-		spin_unlock(&vop_dev->reg_lock);
-		mdelay(50);
-	}
-}
-
-static void vop_win_csc_mode(struct vop_device *vop_dev,
-			     struct rk_lcdc_win *win,
-			     int csc_mode)
-{
-	u64 val;
-
-	if (win->id == VOP_WIN0) {
-		val = V_WIN0_CSC_MODE(csc_mode);
-		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-	} else if (win->id == VOP_WIN1) {
-		val = V_WIN1_CSC_MODE(csc_mode);
-		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
-	} else {
-		val = V_HWC_CSC_MODE(csc_mode);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-	}
-}
-
-static int rk3399_vop_win_csc_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int output_color = dev_drv->output_color;
-	int i;
-
-	for (i = 0; i < dev_drv->lcdc_win_num && i < 4; i++) {
-		struct rk_lcdc_win *win = dev_drv->win[i];
-		int shift = i * 8;
-		u64 val = V_WIN0_YUV2YUV_EN(0) | V_WIN0_YUV2YUV_R2Y_EN(0) |
-				V_WIN0_YUV2YUV_Y2R_EN(0);
-
-		if (!win->state)
-			continue;
-		if (output_color == COLOR_RGB &&
-		    !(IS_YUV(win->area[0].fmt_cfg) || win->area[0].yuyv_fmt))
-			goto post;
-
-		if (output_color == COLOR_RGB) {
-			val |= V_WIN0_YUV2YUV_Y2R_EN(1);
-			if (win->colorspace == CSC_BT601) {
-				/*
-				 * Win Y2Y moudle always use 10bit mode.
-				 */
-				LOAD_CSC(vop_dev, Y2R,
-					 csc_y2r_bt601_full_10, i);
-			} else if (win->colorspace == CSC_BT709) {
-				LOAD_CSC(vop_dev, Y2R,
-					 csc_y2r_bt709_full_10, i);
-			} else if (win->colorspace == CSC_BT2020) {
-				val |= V_WIN0_YUV2YUV_EN(1);
-				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt2020, i);
-				LOAD_CSC(vop_dev, R2R, csc_r2r_bt2020to709, i);
-			}
-		} else if (output_color == COLOR_YCBCR ||
-				output_color == COLOR_YCBCR_BT709) {
-			if (!(IS_YUV(win->area[0].fmt_cfg) ||
-			      win->area[0].yuyv_fmt)) {
-				val |= V_WIN0_YUV2YUV_R2Y_EN(1);
-				if ((win->id == 0) || (win->id == 1))
-					LOAD_CSC(vop_dev, R2Y, csc_r2y_bt709_full_10, i);
-				else
-					val |= V_WIN0_YUV2YUV_R2Y_MODE(VOP_R2Y_CSC_BT709);
-
-			} else if (win->colorspace == CSC_BT2020) {
-				val |= V_WIN0_YUV2YUV_EN(1) |
-					V_WIN0_YUV2YUV_Y2R_EN(1) |
-					V_WIN0_YUV2YUV_R2Y_EN(1);
-				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt2020, i);
-				LOAD_CSC(vop_dev, R2R, csc_r2r_bt2020to709, i);
-				LOAD_CSC(vop_dev, R2Y, csc_r2y_bt709_full_10, i);
-			}
-		} else if (output_color == COLOR_YCBCR_BT2020) {
-			if (!(IS_YUV(win->area[0].fmt_cfg) ||
-			      win->area[0].yuyv_fmt)) {
-				LOAD_CSC(vop_dev, R2R, csc_r2r_bt709to2020, i);
-				val |= V_WIN0_YUV2YUV_R2Y_EN(1) |
-					V_WIN0_YUV2YUV_EN(1);
-				if ((win->id == 0) || (win->id == 1)) {
-					LOAD_CSC(vop_dev, R2Y, csc_r2y_bt2020, i);
-				} else {
-					val |= V_WIN0_YUV2YUV_R2Y_MODE(VOP_R2Y_CSC_BT2020);
-				}
-			} else if (win->colorspace == CSC_BT601 ||
-					win->colorspace == CSC_BT709) {
-				val |= V_WIN0_YUV2YUV_Y2R_EN(1) |
-					V_WIN0_YUV2YUV_R2Y_EN(1) |
-					V_WIN0_YUV2YUV_EN(1);
-				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt709_full_10, i);
-				LOAD_CSC(vop_dev, R2R, csc_r2r_bt709to2020, i);
-				LOAD_CSC(vop_dev, R2Y, csc_r2y_bt2020, i);
-			}
-		}
-post:
-		vop_msk_reg(vop_dev, YUV2YUV_WIN, val << shift);
-	}
-
-	return output_color;
-}
-
-/*
- * colorspace path:
- *      Input        Win csc            Post csc              Output
- * 1. YUV(2020)  --> bypass   ---+ Y2R->2020To709->R2Y --> YUV_OUTPUT(601/709)
- *    RGB        --> R2Y(709) __/
- *
- * 2. YUV(2020)  --> bypass   ---+       bypass        --> YUV_OUTPUT(2020)
- *    RGB        --> R2Y(709) __/
- *
- * 3. YUV(2020)  --> bypass   ---+    Y2R->2020To709   --> RGB_OUTPUT(709)
- *    RGB        --> R2Y(709) __/
- *
- * 4. YUV(601/709)-> bypass   ---+ Y2R->709To2020->R2Y --> YUV_OUTPUT(2020)
- *    RGB        --> R2Y(709) __/
- *
- * 5. YUV(601/709)-> bypass   ---+       bypass        --> YUV_OUTPUT(709)
- *    RGB        --> R2Y(709) __/
- *
- * 6. YUV(601/709)-> bypass   ---+       bypass        --> YUV_OUTPUT(601)
- *    RGB        --> R2Y(601) __/
- *
- * 7. YUV(601)   --> Y2R(601/mpeg)-+     bypass        --> RGB_OUTPUT(709)
- *    RGB        --> bypass   ____/
- *
- * 8. YUV(709)   --> Y2R(709/hd) --+     bypass        --> RGB_OUTPUT(709)
- *    RGB        --> bypass   ____/
- *
- * 9. RGB        --> bypass   --->    709To2020->R2Y   --> YUV_OUTPUT(2020)
- *
- * 10. RGB       --> R2Y(709) --->      bypass        --> YUV_OUTPUT(709)
- *
- * 11. RGB       --> R2Y(601) --->       bypass        --> YUV_OUTPUT(601)
- *
- * 12. RGB       --> bypass   --->       bypass        --> RGB_OUTPUT(709)
- */
-static int rk3228_vop_win_csc_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win;
-	int output_color = dev_drv->output_color;
-	int win_csc = COLOR_RGB;
-	int r2y_mode = VOP_R2Y_CSC_BT709;
-	int i;
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		if (!win->state)
-			continue;
-
-		if (IS_YUV(win->area[0].fmt_cfg)) {
-			if (win->colorspace == CSC_BT2020 &&
-			    win_csc < COLOR_YCBCR_BT2020) {
-				r2y_mode = VOP_R2Y_CSC_BT709;
-				win_csc = COLOR_YCBCR_BT2020;
-			}
-
-			if (win->colorspace == CSC_BT709 &&
-			    win_csc < COLOR_YCBCR_BT709) {
-				r2y_mode = VOP_R2Y_CSC_BT709;
-				win_csc = COLOR_YCBCR_BT709;
-			}
-
-			if (win->colorspace == CSC_BT601 &&
-			    win_csc < COLOR_YCBCR) {
-				r2y_mode = VOP_R2Y_CSC_BT709;
-				win_csc = COLOR_YCBCR;
-			}
-		}
-	}
-
-	if (win_csc == COLOR_RGB) {
-		if (output_color == COLOR_YCBCR_BT709) {
-			r2y_mode = VOP_R2Y_CSC_BT709;
-			win_csc = COLOR_YCBCR_BT709;
-		} else if (output_color == COLOR_YCBCR) {
-			r2y_mode = VOP_R2Y_CSC_BT601;
-			win_csc = COLOR_YCBCR;
-		}
-	}
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		if (!win->state)
-			continue;
-
-		if (win_csc != COLOR_RGB && !IS_YUV(win->area[0].fmt_cfg))
-			vop_win_csc_mode(vop_dev, win, r2y_mode);
-
-		if (IS_YUV(win->area[0].fmt_cfg)) {
-			if (win_csc == COLOR_YCBCR)
-				vop_win_csc_mode(vop_dev, win,
-						 VOP_Y2R_CSC_MPEG);
-			else if (win_csc == COLOR_YCBCR_BT709)
-				vop_win_csc_mode(vop_dev, win, VOP_Y2R_CSC_HD);
-		}
-	}
-
-	return win_csc;
-}
-
-static int vop_post_csc_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int output_color = dev_drv->output_color;
-	int win_csc = 0, overlay_mode = 0;
-	u64 val;
-
-	if (VOP_CHIP(vop_dev) == VOP_RK322X) {
-		win_csc = rk3228_vop_win_csc_cfg(dev_drv);
-	} else if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-		win_csc = rk3399_vop_win_csc_cfg(dev_drv);
-
-		/*
-		 * RK3399 not support post csc config.
-		 */
-		goto done;
-	}
-
-	val = V_YUV2YUV_POST_Y2R_EN(0) | V_YUV2YUV_POST_EN(0) |
-		V_YUV2YUV_POST_R2Y_EN(0);
-	/* Y2R */
-	if (win_csc == COLOR_YCBCR && output_color == COLOR_YCBCR_BT2020) {
-		val |= V_YUV2YUV_POST_Y2R_EN(1);
-		vop_load_csc_table(vop_dev, POST_YUV2YUV_Y2R_COE,
-				   csc_y2r_bt709_full);
-	}
-	if (win_csc == COLOR_YCBCR_BT2020 &&
-	    output_color != COLOR_YCBCR_BT2020) {
-		val |= V_YUV2YUV_POST_Y2R_EN(1);
-		vop_load_csc_table(vop_dev, POST_YUV2YUV_Y2R_COE,
-				   csc_y2r_bt2020);
-	}
-
-	/* R2R */
-	if ((win_csc == COLOR_YCBCR ||
-	     win_csc == COLOR_YCBCR_BT709 ||
-	     win_csc == COLOR_RGB) && output_color == COLOR_YCBCR_BT2020) {
-		val |= V_YUV2YUV_POST_EN(1);
-		vop_load_csc_table(vop_dev, POST_YUV2YUV_3x3_COE,
-				   csc_r2r_bt709to2020);
-	}
-	if (win_csc == COLOR_YCBCR_BT2020 &&
-	    (output_color == COLOR_YCBCR ||
-	     output_color == COLOR_YCBCR_BT709 ||
-	     output_color == COLOR_RGB)) {
-		val |= V_YUV2YUV_POST_EN(1);
-		vop_load_csc_table(vop_dev, POST_YUV2YUV_3x3_COE,
-				   csc_r2r_bt2020to709);
-	}
-
-	/* Y2R */
-	if (output_color != COLOR_RGB) {
-		val |= V_YUV2YUV_POST_R2Y_EN(1);
-
-		if (output_color == COLOR_YCBCR_BT2020)
-			vop_load_csc_table(vop_dev, POST_YUV2YUV_R2Y_COE,
-					   csc_r2y_bt2020);
-		else
-			vop_load_csc_table(vop_dev, POST_YUV2YUV_R2Y_COE,
-					   csc_r2y_bt709_full);
-	}
-
-	DBG(1, "win_csc=%d output_color=%d val=%llx\n",
-	    win_csc, output_color, val);
-	vop_msk_reg(vop_dev, YUV2YUV_POST, val);
-done:
-	overlay_mode = (win_csc != COLOR_RGB) ? VOP_YUV_DOMAIN : VOP_RGB_DOMAIN;
-	vop_msk_reg(vop_dev, SYS_CTRL, V_OVERLAY_MODE(overlay_mode));
-
-	return 0;
-}
-
-static int vop_post_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u64 val;
-	u16 h_total, v_total;
-	u16 post_hsd_en, post_vsd_en;
-	u16 post_dsp_hact_st, post_dsp_hact_end;
-	u16 post_dsp_vact_st, post_dsp_vact_end;
-	u16 post_dsp_vact_st_f1, post_dsp_vact_end_f1;
-	u16 post_h_fac, post_v_fac;
-
-	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
-	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
-	screen->post_xsize = x_res *
-	    (dev_drv->overscan.left + dev_drv->overscan.right) / 200;
-	screen->post_ysize = y_res *
-	    (dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
-
-	h_total = screen->mode.hsync_len + screen->mode.left_margin +
-	    x_res + screen->mode.right_margin;
-	v_total = screen->mode.vsync_len + screen->mode.upper_margin +
-	    y_res + screen->mode.lower_margin;
-
-	if (screen->post_dsp_stx + screen->post_xsize > x_res) {
-		dev_warn(vop_dev->dev, "post:stx[%d]+xsize[%d]>x_res[%d]\n",
-			 screen->post_dsp_stx, screen->post_xsize, x_res);
-		screen->post_dsp_stx = x_res - screen->post_xsize;
-	}
-	if (screen->x_mirror == 0) {
-		post_dsp_hact_st = screen->post_dsp_stx +
-		    screen->mode.hsync_len + screen->mode.left_margin;
-		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
-	} else {
-		post_dsp_hact_end = h_total - screen->mode.right_margin -
-		    screen->post_dsp_stx;
-		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
-	}
-	if ((screen->post_xsize < x_res) && (screen->post_xsize != 0)) {
-		post_hsd_en = 1;
-		post_h_fac =
-		    GET_SCALE_FACTOR_BILI_DN(x_res, screen->post_xsize);
-	} else {
-		post_hsd_en = 0;
-		post_h_fac = 0x1000;
-	}
-
-	if (screen->post_dsp_sty + screen->post_ysize > y_res) {
-		dev_warn(vop_dev->dev, "post:sty[%d]+ysize[%d]> y_res[%d]\n",
-			 screen->post_dsp_sty, screen->post_ysize, y_res);
-		screen->post_dsp_sty = y_res - screen->post_ysize;
-	}
-
-	if ((screen->post_ysize < y_res) && (screen->post_ysize != 0)) {
-		post_vsd_en = 1;
-		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res,
-						      screen->post_ysize);
-	} else {
-		post_vsd_en = 0;
-		post_v_fac = 0x1000;
-	}
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		post_dsp_vact_st = screen->post_dsp_sty / 2 +
-					screen->mode.vsync_len +
-					screen->mode.upper_margin;
-		post_dsp_vact_end = post_dsp_vact_st +
-					screen->post_ysize / 2;
-
-		post_dsp_vact_st_f1 = screen->mode.vsync_len +
-					screen->mode.upper_margin +
-					y_res / 2 +
-					screen->mode.lower_margin +
-					screen->mode.vsync_len +
-					screen->mode.upper_margin +
-					screen->post_dsp_sty / 2 +
-					1;
-		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 +
-					screen->post_ysize / 2;
-	} else {
-		if (screen->y_mirror == 0) {
-			post_dsp_vact_st = screen->post_dsp_sty +
-			    screen->mode.vsync_len +
-			    screen->mode.upper_margin;
-			post_dsp_vact_end = post_dsp_vact_st +
-				screen->post_ysize;
-		} else {
-			post_dsp_vact_end = v_total -
-				screen->mode.lower_margin -
-			    screen->post_dsp_sty;
-			post_dsp_vact_st = post_dsp_vact_end -
-				screen->post_ysize;
-		}
-		post_dsp_vact_st_f1 = 0;
-		post_dsp_vact_end_f1 = 0;
-	}
-	DBG(1, "post:xsize=%d,ysize=%d,xpos=%d",
-	    screen->post_xsize, screen->post_ysize, screen->xpos);
-	DBG(1, ",ypos=%d,hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
-	    screen->ypos, post_hsd_en, post_h_fac, post_vsd_en, post_v_fac);
-	val = V_DSP_HACT_END_POST(post_dsp_hact_end) |
-	    V_DSP_HACT_ST_POST(post_dsp_hact_st);
-	vop_msk_reg(vop_dev, POST_DSP_HACT_INFO, val);
-
-	val = V_DSP_VACT_END_POST(post_dsp_vact_end) |
-	    V_DSP_VACT_ST_POST(post_dsp_vact_st);
-	vop_msk_reg(vop_dev, POST_DSP_VACT_INFO, val);
-
-	val = V_POST_HS_FACTOR_YRGB(post_h_fac) |
-	    V_POST_VS_FACTOR_YRGB(post_v_fac);
-	vop_msk_reg(vop_dev, POST_SCL_FACTOR_YRGB, val);
-	val = V_DSP_VACT_END_POST(post_dsp_vact_end_f1) |
-	    V_DSP_VACT_ST_POST(post_dsp_vact_st_f1);
-	vop_msk_reg(vop_dev, POST_DSP_VACT_INFO_F1, val);
-	val = V_POST_HOR_SD_EN(post_hsd_en) | V_POST_VER_SD_EN(post_vsd_en);
-	vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
-
-	vop_post_csc_cfg(dev_drv);
-
-	return 0;
-}
-
-static int vop_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win;
-	u32 colorkey_r, colorkey_g, colorkey_b;
-	int i, key_val;
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		key_val = win->color_key_val;
-		colorkey_r = (key_val & 0xff) << 2;
-		colorkey_g = ((key_val >> 8) & 0xff) << 12;
-		colorkey_b = ((key_val >> 16) & 0xff) << 22;
-		/* color key dither 565/888->aaa */
-		key_val = colorkey_r | colorkey_g | colorkey_b;
-		switch (i) {
-		case 0:
-			vop_writel(vop_dev, WIN0_COLOR_KEY, key_val);
-			break;
-		case 1:
-			vop_writel(vop_dev, WIN1_COLOR_KEY, key_val);
-			break;
-		case 2:
-			vop_writel(vop_dev, WIN2_COLOR_KEY, key_val);
-			break;
-		case 3:
-			vop_writel(vop_dev, WIN3_COLOR_KEY, key_val);
-			break;
-		default:
-			pr_info("%s:un support win num:%d\n",
-				__func__, i);
-			break;
-		}
-	}
-	return 0;
-}
-
-static int vop_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	struct alpha_config alpha_config;
-	u64 val;
-	int ppixel_alpha = 0, global_alpha = 0, i;
-	u32 src_alpha_ctl = 0, dst_alpha_ctl = 0;
-	int alpha_en = 1;
-
-	memset(&alpha_config, 0, sizeof(struct alpha_config));
-	for (i = 0; i < win->area_num; i++) {
-		ppixel_alpha |= ((win->area[i].format == ARGB888) ||
-				 (win->area[i].format == FBDC_ARGB_888) ||
-				 (win->area[i].format == FBDC_ABGR_888) ||
-				 (win->area[i].format == ABGR888)) ? 1 : 0;
-	}
-
-	global_alpha = (win->g_alpha_val == 0) ? 0 : 1;
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		if (!dev_drv->win[i]->state)
-			continue;
-		if (win->z_order > dev_drv->win[i]->z_order)
-			break;
-	}
-
-	/*
-	 * The bottom layer not support ppixel_alpha mode.
-	 */
-	if (i == dev_drv->lcdc_win_num)
-		ppixel_alpha = 0;
-	alpha_config.src_global_alpha_val = win->g_alpha_val;
-	win->alpha_mode = AB_SRC_OVER;
-
-	switch (win->alpha_mode) {
-	case AB_USER_DEFINE:
-		break;
-	case AB_CLEAR:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_SRC:
-		alpha_config.src_factor_mode = AA_ONE;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_ONE;
-		break;
-	case AB_SRC_OVER:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		if (global_alpha)
-			alpha_config.src_factor_mode = AA_SRC_GLOBAL;
-		else
-			alpha_config.src_factor_mode = AA_ONE;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_DST_OVER:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_ONE;
-		break;
-	case AB_SRC_IN:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST_IN:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_SRC;
-		break;
-	case AB_SRC_OUT:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST_OUT:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_SRC_ATOP:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_DST_ATOP:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_SRC;
-		break;
-	case XOR:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_SRC_OVER_GLOBAL:
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-		alpha_config.src_color_mode = AA_SRC_NO_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_GLOBAL;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	default:
-		pr_err("alpha mode error\n");
-		break;
-	}
-	if ((ppixel_alpha == 1) && (global_alpha == 1))
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-	else if (ppixel_alpha == 1)
-		alpha_config.src_global_alpha_mode = AA_PER_PIX;
-	else if (global_alpha == 1)
-		alpha_config.src_global_alpha_mode = AA_GLOBAL;
-	else
-		alpha_en = 0;
-	alpha_config.src_alpha_mode = AA_STRAIGHT;
-	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
-
-	switch (win_id) {
-	case 0:
-		src_alpha_ctl = 0x60;
-		dst_alpha_ctl = 0x64;
-		break;
-	case 1:
-		src_alpha_ctl = 0xa0;
-		dst_alpha_ctl = 0xa4;
-		break;
-	case 2:
-		src_alpha_ctl = 0xdc;
-		dst_alpha_ctl = 0xec;
-		break;
-	case 3:
-		src_alpha_ctl = 0x12c;
-		dst_alpha_ctl = 0x13c;
-		break;
-	case 4:
-		src_alpha_ctl = 0x160;
-		dst_alpha_ctl = 0x164;
-		break;
-	}
-	val = V_WIN0_DST_FACTOR_MODE(alpha_config.dst_factor_mode);
-	vop_msk_reg(vop_dev, dst_alpha_ctl, val);
-	val = V_WIN0_SRC_ALPHA_EN(alpha_en) |
-	    V_WIN0_SRC_COLOR_MODE(alpha_config.src_color_mode) |
-	    V_WIN0_SRC_ALPHA_MODE(alpha_config.src_alpha_mode) |
-	    V_WIN0_SRC_BLEND_MODE(alpha_config.src_global_alpha_mode) |
-	    V_WIN0_SRC_ALPHA_CAL_MODE(alpha_config.src_alpha_cal_m0) |
-	    V_WIN0_SRC_FACTOR_MODE(alpha_config.src_factor_mode) |
-	    V_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
-
-	vop_msk_reg(vop_dev, src_alpha_ctl, val);
-
-	return 0;
-}
-
-static int vop_axi_gather_cfg(struct vop_device *vop_dev,
-			      struct rk_lcdc_win *win)
-{
-	u64 val;
-	u16 yrgb_gather_num = 3;
-	u16 cbcr_gather_num = 1;
-
-	switch (win->area[0].format) {
-	case XRGB888:
-	case ARGB888:
-	case XBGR888:
-	case ABGR888:
-	case FBDC_ARGB_888:
-	case FBDC_RGBX_888:
-	case FBDC_ABGR_888:
-		yrgb_gather_num = 3;
-		break;
-	case RGB888:
-	case BGR888:
-	case RGB565:
-	case BGR565:
-	case FBDC_RGB_565:
-		yrgb_gather_num = 2;
-		break;
-	case YUV444:
-	case YUV422:
-	case YUV420:
-	case YUV420_A:
-	case YUV422_A:
-	case YUV444_A:
-	case YUV420_NV21:
-	case YUYV420:
-	case UYVY420:
-		yrgb_gather_num = 1;
-		cbcr_gather_num = 2;
-		break;
-	case YUYV422:
-	case UYVY422:
-		yrgb_gather_num = 2;
-		cbcr_gather_num = 2;
-		break;
-	default:
-		dev_err(vop_dev->driver.dev, "%s:un supported format[%d]\n",
-			__func__, win->area[0].format);
-		return -EINVAL;
-	}
-
-	if ((win->id == VOP_WIN0) || (win->id == VOP_WIN1)) {
-		val = V_WIN0_YRGB_AXI_GATHER_EN(1) |
-			V_WIN0_CBR_AXI_GATHER_EN(1) |
-			V_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
-			V_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
-		vop_msk_reg(vop_dev, WIN0_CTRL1 + (win->id * 0x40), val);
-	} else if ((win->id == VOP_WIN2) || (win->id == VOP_WIN3)) {
-		val = V_WIN2_AXI_GATHER_EN(1) |
-			V_WIN2_AXI_GATHER_NUM(yrgb_gather_num);
-		vop_msk_reg(vop_dev, WIN2_CTRL1 + ((win->id - 2) * 0x50), val);
-	} else if (win->id == VOP_HWC) {
-		val = V_HWC_AXI_GATHER_EN(1) |
-			V_HWC_AXI_GATHER_NUM(yrgb_gather_num);
-		vop_msk_reg(vop_dev, HWC_CTRL1, val);
-	}
-	return 0;
-}
-
-static int vop_fbdc_reg_update(struct vop_device *vop_dev, int win_id)
-{
-	struct rk_lcdc_win *win = vop_dev->driver.win[win_id];
-	u64 val;
-
-	val = V_VOP_FBDC_WIN_SEL(win_id) |
-		V_AFBCD_HREG_PIXEL_PACKING_FMT(win->area[0].fbdc_fmt_cfg) |
-		V_AFBCD_HREG_BLOCK_SPLIT(win->area[0].fbdc_cor_en);
-	vop_msk_reg(vop_dev, AFBCD0_CTRL, val);
-
-	val = V_AFBCD_HREG_PIC_WIDTH(win->area[0].fbdc_mb_width - 1) |
-		V_AFBCD_HREG_PIC_HEIGHT(win->area[0].fbdc_mb_height - 1);
-	vop_msk_reg(vop_dev, AFBCD0_PIC_SIZE, val);
-
-	return 0;
-}
-
-static int vop_init_fbdc_config(struct vop_device *vop_dev, int win_id)
-{
-	struct rk_lcdc_driver *vop_drv = &vop_dev->driver;
-	struct rk_lcdc_win *win = vop_drv->win[win_id];
-	struct rk_screen *screen = vop_drv->cur_screen;
-
-	if (screen->mode.flag & FB_VMODE_INTERLACED) {
-		dev_err(vop_dev->dev, "unsupport fbdc+interlace!\n");
-		return 0;
-	}
-
-	if (VOP_CHIP(vop_dev) != VOP_RK3399) {
-		pr_err("soc: 0x%08x not support FBDC\n", VOP_CHIP(vop_dev));
-		return 0;
-	}
-
-	win->area[0].fbdc_mb_width = win->area[0].xvir;
-	win->area[0].fbdc_mb_height = win->area[0].yact;
-	win->area[0].fbdc_cor_en = 0; /* hreg_block_split */
-	win->area[0].fbdc_fmt_cfg |= AFBDC_YUV_COLOR_TRANSFORM << 4;
-
-	return 0;
-}
-
-static int vop_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u64 val;
-	u32 off;
-	int format;
-	struct rk_win_property *win_property =
-				&dev_drv->win[win_id]->property;
-
-	off = win_id * 0x40;
-
-	if (win->state == 1) {
-		if (!(win_property->feature & SUPPORT_HW_EXIST)) {
-			pr_err("vop[%d] win[%d] hardware unsupport\n",
-			       vop_dev->id, win_id);
-			return 0;
-		}
-		vop_axi_gather_cfg(vop_dev, win);
-		if (win->area[0].fbdc_en)
-			vop_fbdc_reg_update(vop_dev, win_id);
-		/*
-		 * rk322x have a bug on windows 0 and 1:
-		 *
-		 * When switch win format from RGB to YUV, would flash
-		 * some green lines on the top of the windows.
-		 *
-		 * Use bg_en show one blank frame to skip the error frame.
-		 */
-		if (IS_YUV(win->area[0].fmt_cfg)) {
-			val = vop_readl(vop_dev, WIN0_CTRL0);
-			format = (val & MASK(WIN0_DATA_FMT)) >> 1;
-
-			if (!IS_YUV(format)) {
-				if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-					val = V_WIN0_DSP_BG_RED(0x200) |
-						V_WIN0_DSP_BG_GREEN(0x40) |
-						V_WIN0_DSP_BG_BLUE(0x200) |
-						V_WIN0_BG_EN(1);
-					vop_msk_reg(vop_dev, WIN0_DSP_BG + off,
-						    val);
-				} else {
-					val = V_WIN0_DSP_BG_RED(0) |
-						V_WIN0_DSP_BG_GREEN(0) |
-						V_WIN0_DSP_BG_BLUE(0) |
-						V_WIN0_BG_EN(1);
-					vop_msk_reg(vop_dev, WIN0_DSP_BG + off,
-						    val);
-				}
-			} else {
-				val = V_WIN0_BG_EN(0);
-				vop_msk_reg(vop_dev, WIN0_DSP_BG + off, val);
-			}
-		} else {
-			val = V_WIN0_BG_EN(0);
-			vop_msk_reg(vop_dev, WIN0_DSP_BG + off, val);
-		}
-
-		val = V_WIN0_EN(win->state) |
-			V_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
-			V_WIN0_FMT_10(win->fmt_10) |
-			V_WIN0_LB_MODE(win->win_lb_mode) |
-			V_WIN0_RB_SWAP(win->area[0].swap_rb) |
-			V_WIN0_X_MIR_EN(win->xmirror) |
-			V_WIN0_Y_MIR_EN(win->ymirror) |
-			V_WIN0_UV_SWAP(win->area[0].swap_uv);
-		if (VOP_CHIP(vop_dev) == VOP_RK3399)
-			val |= V_WIN0_YUYV(win->area[0].yuyv_fmt);
-		vop_msk_reg(vop_dev, WIN0_CTRL0 + off, val);
-		val = V_WIN0_BIC_COE_SEL(win->bic_coe_el) |
-		    V_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
-		    V_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
-		    V_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
-		    V_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
-		    V_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
-		    V_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
-		    V_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
-		    V_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
-		    V_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
-		    V_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
-		    V_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
-		    V_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
-		    V_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
-		    V_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
-		vop_msk_reg(vop_dev, WIN0_CTRL1 + off, val);
-		val = V_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
-		    V_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);
-		vop_writel(vop_dev, WIN0_VIR + off, val);
-		val = V_WIN0_ACT_WIDTH(win->area[0].xact - 1) |
-		    V_WIN0_ACT_HEIGHT(win->area[0].yact - 1);
-		vop_writel(vop_dev, WIN0_ACT_INFO + off, val);
-
-		val = V_WIN0_DSP_WIDTH(win->area[0].xsize - 1) |
-		    V_WIN0_DSP_HEIGHT(win->area[0].ysize - 1);
-		vop_writel(vop_dev, WIN0_DSP_INFO + off, val);
-
-		val = V_WIN0_DSP_XST(win->area[0].dsp_stx) |
-		    V_WIN0_DSP_YST(win->area[0].dsp_sty);
-		vop_writel(vop_dev, WIN0_DSP_ST + off, val);
-
-		val = V_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
-		    V_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
-		vop_writel(vop_dev, WIN0_SCL_FACTOR_YRGB + off, val);
-
-		val = V_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
-		    V_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
-		vop_writel(vop_dev, WIN0_SCL_FACTOR_CBR + off, val);
-	} else {
-		val = V_WIN0_EN(win->state);
-		vop_msk_reg(vop_dev, WIN0_CTRL0 + off, val);
-	}
-
-	return 0;
-}
-
-static int area_xst(struct rk_lcdc_win *win, int area_num)
-{
-	struct rk_lcdc_win_area area_temp;
-	int i, j;
-
-	for (i = 0; i < area_num; i++) {
-		for (j = i + 1; j < area_num; j++) {
-			if (win->area[i].dsp_stx >  win->area[j].dsp_stx) {
-				memcpy(&area_temp, &win->area[i],
-				       sizeof(struct rk_lcdc_win_area));
-				memcpy(&win->area[i], &win->area[j],
-				       sizeof(struct rk_lcdc_win_area));
-				memcpy(&win->area[j], &area_temp,
-				       sizeof(struct rk_lcdc_win_area));
-			}
-		}
-	}
-
-	return 0;
-}
-
-static int vop_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int off;
-	u64 val;
-	struct rk_win_property *win_property =
-				&dev_drv->win[win_id]->property;
-
-	off = (win_id - 2) * 0x50;
-	area_xst(win, win->area_num);
-
-	if (win->state == 1) {
-		if (!(win_property->feature & SUPPORT_HW_EXIST)) {
-			pr_err("vop[%d] win[%d] hardware unsupport\n",
-			       vop_dev->id, win_id);
-			return 0;
-		}
-		vop_axi_gather_cfg(vop_dev, win);
-		if (win->area[0].fbdc_en)
-			vop_fbdc_reg_update(vop_dev, win_id);
-		val = V_WIN2_EN(1) | V_WIN1_CSC_MODE(win->csc_mode);
-		vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-		/* area 0 */
-		if (win->area[0].state == 1) {
-			val = V_WIN2_MST0_EN(win->area[0].state) |
-			    V_WIN2_DATA_FMT0(win->area[0].fmt_cfg) |
-			    V_WIN2_RB_SWAP0(win->area[0].swap_rb);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-
-			val = V_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
-			vop_msk_reg(vop_dev, WIN2_VIR0_1 + off, val);
-
-			val = V_WIN2_DSP_WIDTH0(win->area[0].xsize - 1) |
-			    V_WIN2_DSP_HEIGHT0(win->area[0].ysize - 1);
-			vop_writel(vop_dev, WIN2_DSP_INFO0 + off, val);
-			val = V_WIN2_DSP_XST0(win->area[0].dsp_stx) |
-			    V_WIN2_DSP_YST0(win->area[0].dsp_sty);
-			vop_writel(vop_dev, WIN2_DSP_ST0 + off, val);
-		} else {
-			val = V_WIN2_MST0_EN(0);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-		}
-		/* area 1 */
-		if (win->area[1].state == 1) {
-			val = V_WIN2_MST1_EN(win->area[1].state) |
-			    V_WIN2_DATA_FMT1(win->area[1].fmt_cfg) |
-			    V_WIN2_RB_SWAP1(win->area[1].swap_rb);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-
-			val = V_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
-			vop_msk_reg(vop_dev, WIN2_VIR0_1 + off, val);
-
-			val = V_WIN2_DSP_WIDTH1(win->area[1].xsize - 1) |
-			    V_WIN2_DSP_HEIGHT1(win->area[1].ysize - 1);
-			vop_writel(vop_dev, WIN2_DSP_INFO1 + off, val);
-			val = V_WIN2_DSP_XST1(win->area[1].dsp_stx) |
-			    V_WIN2_DSP_YST1(win->area[1].dsp_sty);
-			vop_writel(vop_dev, WIN2_DSP_ST1 + off, val);
-		} else {
-			val = V_WIN2_MST1_EN(0);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-		}
-		/* area 2 */
-		if (win->area[2].state == 1) {
-			val = V_WIN2_MST2_EN(win->area[2].state) |
-			    V_WIN2_DATA_FMT2(win->area[2].fmt_cfg) |
-			    V_WIN2_RB_SWAP2(win->area[2].swap_rb);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-
-			val = V_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
-			vop_msk_reg(vop_dev, WIN2_VIR2_3 + off, val);
-
-			val = V_WIN2_DSP_WIDTH2(win->area[2].xsize - 1) |
-			    V_WIN2_DSP_HEIGHT2(win->area[2].ysize - 1);
-			vop_writel(vop_dev, WIN2_DSP_INFO2 + off, val);
-			val = V_WIN2_DSP_XST2(win->area[2].dsp_stx) |
-			    V_WIN2_DSP_YST2(win->area[2].dsp_sty);
-			vop_writel(vop_dev, WIN2_DSP_ST2 + off, val);
-		} else {
-			val = V_WIN2_MST2_EN(0);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-		}
-		/* area 3 */
-		if (win->area[3].state == 1) {
-			val = V_WIN2_MST3_EN(win->area[3].state) |
-			    V_WIN2_DATA_FMT3(win->area[3].fmt_cfg) |
-			    V_WIN2_RB_SWAP3(win->area[3].swap_rb);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-
-			val = V_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
-			vop_msk_reg(vop_dev, WIN2_VIR2_3 + off, val);
-
-			val = V_WIN2_DSP_WIDTH3(win->area[3].xsize - 1) |
-			    V_WIN2_DSP_HEIGHT3(win->area[3].ysize - 1);
-			vop_writel(vop_dev, WIN2_DSP_INFO3 + off, val);
-			val = V_WIN2_DSP_XST3(win->area[3].dsp_stx) |
-			    V_WIN2_DSP_YST3(win->area[3].dsp_sty);
-			vop_writel(vop_dev, WIN2_DSP_ST3 + off, val);
-		} else {
-			val = V_WIN2_MST3_EN(0);
-			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-		}
-	} else {
-		val = V_WIN2_EN(win->state) | V_WIN2_MST0_EN(0) |
-		    V_WIN2_MST1_EN(0) | V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
-		vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
-	}
-
-	return 0;
-}
-
-static int vop_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int hwc_size = 0;
-	u64 val;
-
-	if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32)) {
-		hwc_size = 0;
-	} else if ((win->area[0].xsize == 64) && (win->area[0].ysize == 64)) {
-		hwc_size = 1;
-	} else if ((win->area[0].xsize == 96) && (win->area[0].ysize == 96)) {
-		hwc_size = 2;
-	} else if ((win->area[0].xsize == 128) &&
-		   (win->area[0].ysize == 128)) {
-		hwc_size = 3;
-	} else {
-		dev_err(vop_dev->dev, "un supported hwc size[%dx%d]!\n",
-				win->area[0].xsize, win->area[0].ysize);
-		return -EINVAL;
-	}
-
-	if (win->state == 1) {
-		vop_axi_gather_cfg(vop_dev, win);
-		val = V_HWC_EN(1) | V_HWC_DATA_FMT(win->area[0].fmt_cfg) |
-		    V_HWC_RB_SWAP(win->area[0].swap_rb);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-
-		val = V_HWC_SIZE(hwc_size);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-
-		val = V_HWC_DSP_XST(win->area[0].dsp_stx) |
-		    V_HWC_DSP_YST(win->area[0].dsp_sty);
-		vop_msk_reg(vop_dev, HWC_DSP_ST, val);
-	} else {
-		val = V_HWC_EN(win->state);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-	}
-
-	return 0;
-}
-
-static int vop_layer_update_regs(struct vop_device *vop_dev,
-				 struct rk_lcdc_win *win)
-{
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-
-	if (likely(vop_dev->clk_on)) {
-		vop_msk_reg(vop_dev, SYS_CTRL,
-			    V_VOP_STANDBY_EN(vop_dev->standby));
-		if ((win->id == VOP_WIN0) || (win->id == VOP_WIN1))
-			vop_win_0_1_reg_update(dev_drv, win->id);
-		else if ((win->id == VOP_WIN2) || (win->id == VOP_WIN3))
-			vop_win_2_3_reg_update(dev_drv, win->id);
-		else if (win->id == VOP_HWC)
-			vop_hwc_reg_update(dev_drv, win->id);
-		vop_cfg_done(vop_dev);
-	}
-
-	DBG(2, "%s for lcdc%d\n", __func__, vop_dev->id);
-	return 0;
-}
-
-static int __maybe_unused vop_mmu_en(struct rk_lcdc_driver *dev_drv)
-{
-	u64 val;
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	if (dev_drv->iommu_enabled) {
-		if (!vop_dev->iommu_status && dev_drv->mmu_dev) {
-			if (likely(vop_dev->clk_on)) {
-				val = V_VOP_MMU_EN(1);
-				vop_msk_reg(vop_dev, SYS_CTRL, val);
-				val = V_AXI_OUTSTANDING_MAX_NUM(31) |
-					V_AXI_MAX_OUTSTANDING_EN(1);
-				vop_msk_reg(vop_dev, SYS_CTRL1, val);
-			}
-			vop_dev->iommu_status = 1;
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-	return 0;
-}
-
-static int vop_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
-{
-	int ret = 0, fps = 0;
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-#ifdef CONFIG_RK_FPGA
-	return 0;
-#endif
-	if (reset_rate)
-		ret = clk_set_rate(vop_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk[%d] failed\n",
-			vop_dev->id, screen->mode.pixclock);
-	vop_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
-	vop_dev->driver.pixclock = vop_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, vop_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(vop_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 vop_dev->driver.name, clk_get_rate(vop_dev->dclk), fps);
-	return 0;
-}
-
-static int vop_config_timing(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 right_margin = screen->mode.right_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u64 val;
-	u16 h_total, v_total;
-	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
-
-	h_total = hsync_len + left_margin + x_res + right_margin;
-	v_total = vsync_len + upper_margin + y_res + lower_margin;
-
-	val = V_DSP_HS_END(hsync_len) | V_DSP_HTOTAL(h_total);
-	vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
-
-	val = V_DSP_HACT_END(hsync_len + left_margin + x_res) |
-	    V_DSP_HACT_ST(hsync_len + left_margin);
-	vop_msk_reg(vop_dev, DSP_HACT_ST_END, val);
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		/* First Field Timing */
-		val = V_DSP_VS_END(vsync_len) |
-		    V_DSP_VTOTAL(2 * (vsync_len + upper_margin +
-				      lower_margin) + y_res + 1);
-		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
-
-		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
-		    V_DSP_VACT_ST(vsync_len + upper_margin);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
-
-		/* Second Field Timing */
-		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
-		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
-		    lower_margin;
-		val = V_DSP_VS_ST_F1(vs_st_f1) | V_DSP_VS_END_F1(vs_end_f1);
-		vop_msk_reg(vop_dev, DSP_VS_ST_END_F1, val);
-
-		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
-		    lower_margin + 1;
-		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
-		    lower_margin + 1;
-		val = V_DSP_VACT_END_F1(vact_end_f1) |
-			V_DSP_VACT_ST_F1(vact_st_f1);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END_F1, val);
-		vop_msk_reg(vop_dev, DSP_CTRL0,
-			    V_DSP_INTERLACE(1) | V_DSP_FIELD_POL(0));
-
-		val = V_DSP_LINE_FLAG_NUM_0(lower_margin ?
-					    vact_end_f1 : vact_end_f1 - 1);
-
-		val |= V_DSP_LINE_FLAG_NUM_1(lower_margin ?
-					     vact_end_f1 : vact_end_f1 - 1);
-		vop_msk_reg(vop_dev, LINE_FLAG, val);
-	} else {
-		val = V_DSP_VS_END(vsync_len) | V_DSP_VTOTAL(v_total);
-		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
-
-		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res) |
-		    V_DSP_VACT_ST(vsync_len + upper_margin);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
-
-		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_INTERLACE(0) |
-			    V_DSP_FIELD_POL(0));
-
-		val = V_DSP_LINE_FLAG_NUM_0(vsync_len + upper_margin + y_res) |
-			V_DSP_LINE_FLAG_NUM_1(vsync_len + upper_margin + y_res);
-		vop_msk_reg(vop_dev, LINE_FLAG, val);
-	}
-	vop_post_cfg(dev_drv);
-	if ((x_res <= VOP_INPUT_MAX_WIDTH / 2) && (vop_dev->id == 0))
-		vop_msk_reg(vop_dev, SYS_CTRL, V_POST_LB_MODE(1));
-	else
-		vop_msk_reg(vop_dev, SYS_CTRL, V_POST_LB_MODE(0));
-
-	return 0;
-}
-
-static void vop_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u32 bcsh_ctrl;
-
-	vop_msk_reg(vop_dev, SYS_CTRL, V_OVERLAY_MODE(dev_drv->overlay_mode));
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
-			vop_msk_reg(vop_dev, BCSH_CTRL,
-				    V_BCSH_Y2R_EN(0) | V_BCSH_R2Y_EN(0));
-		else		/* YUV2RGB */
-			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_Y2R_EN(1) |
-				    V_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				    V_BCSH_R2Y_EN(0));
-	} else {
-		/* overlay_mode=VOP_RGB_DOMAIN */
-		/* bypass  --need check,if bcsh close? */
-		if (dev_drv->output_color == COLOR_RGB) {
-			bcsh_ctrl = vop_readl(vop_dev, BCSH_CTRL);
-			if (((bcsh_ctrl & MASK(BCSH_EN)) == 1) ||
-			    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
-				vop_msk_reg(vop_dev, BCSH_CTRL,
-					    V_BCSH_R2Y_EN(1) |
-					    V_BCSH_Y2R_EN(1));
-			else
-				vop_msk_reg(vop_dev, BCSH_CTRL,
-					    V_BCSH_R2Y_EN(0) |
-					    V_BCSH_Y2R_EN(0));
-		} else {
-			/* RGB2YUV */
-			vop_msk_reg(vop_dev, BCSH_CTRL,
-				    V_BCSH_R2Y_EN(1) |
-				    V_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				    V_BCSH_Y2R_EN(0));
-		}
-	}
-}
-
-static int vop_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
-			       u16 *yact, int *format, u32 *dsp_addr,
-			       int *ymirror)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	u32 val;
-
-	spin_lock(&vop_dev->reg_lock);
-
-	val = vop_readl(vop_dev, WIN0_ACT_INFO);
-	*xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
-	*yact = ((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-
-	val = vop_readl(vop_dev, WIN0_CTRL0);
-	*format = (val & MASK(WIN0_DATA_FMT)) >> 1;
-	*ymirror = (val & MASK(WIN0_Y_MIR_EN)) >> 22;
-	*dsp_addr = vop_readl(vop_dev, WIN0_YRGB_MST);
-
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			   int format, u16 xact, u16 yact, u16 xvir,
-			   int ymirror)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	int swap = (format == RGB888) ? 1 : 0;
-	struct rk_lcdc_win *win = dev_drv->win[0];
-	u64 val;
-
-	val = V_WIN0_DATA_FMT(format) | V_WIN0_RB_SWAP(swap) |
-		V_WIN0_Y_MIR_EN(ymirror);
-	vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-
-	vop_msk_reg(vop_dev, WIN0_VIR, V_WIN0_VIR_STRIDE(xvir));
-	vop_writel(vop_dev, WIN0_ACT_INFO, V_WIN0_ACT_WIDTH(xact - 1) |
-		   V_WIN0_ACT_HEIGHT(yact - 1));
-
-	vop_writel(vop_dev, WIN0_YRGB_MST, rgb_mst);
-
-	vop_cfg_done(vop_dev);
-
-	if (format == RGB888)
-		win->area[0].format = BGR888;
-	else
-		win->area[0].format = format;
-
-	win->ymirror = ymirror;
-	win->state = 1;
-	win->last_state = 1;
-
-	return 0;
-}
-
-static int vop_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	u16 face = 0;
-	u16 dclk_ddr = 0;
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 val = 0;
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-
-	if (!vop_dev->standby && initscreen && (dev_drv->first_frame != 1))
-		flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(1);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(1);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
-				| V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_S888x:
-			face = OUT_S888x;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
-				| V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_S888:
-			face = OUT_S888;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
-				| V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_YUV_420:
-			face = OUT_YUV_420;
-			dclk_ddr = 1;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(0) |
-				V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_YUV_420_10BIT:
-			face = OUT_YUV_420;
-			dclk_ddr = 1;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(0) |
-				V_DITHER_DOWN_SEL(0) |
-				V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_YUV_422:
-			face = OUT_YUV_422;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(1) |
-				V_DITHER_DOWN_SEL(0) |
-				V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_YUV_422_10BIT:
-			face = OUT_YUV_422;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(0) |
-				V_DITHER_DOWN_SEL(0) |
-				V_DITHER_DOWN_MODE(0);
-			break;
-		case OUT_P101010:
-			face = OUT_P101010;
-			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
-				V_PRE_DITHER_DOWN_EN(0) |
-				V_DITHER_DOWN_SEL(0) |
-				V_DITHER_DOWN_MODE(0);
-			break;
-		default:
-			dev_err(vop_dev->dev, "un supported screen face[%d]!\n",
-				screen->face);
-			break;
-		}
-
-		vop_msk_reg(vop_dev, DSP_CTRL1, val);
-		switch (screen->type) {
-		case SCREEN_TVOUT:
-			val = V_SW_UV_OFFSET_EN(1) | V_SW_IMD_TVE_DCLK_EN(1) |
-				V_SW_IMD_TVE_DCLK_EN(1) |
-				V_SW_IMD_TVE_DCLK_POL(1) |
-				V_SW_GENLOCK(1) | V_SW_DAC_SEL(1);
-			if (screen->mode.xres == 720 &&
-			    screen->mode.yres == 576)
-				val |= V_SW_TVE_MODE(1);
-			else
-				val |= V_SW_TVE_MODE(0);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			break;
-		case SCREEN_HDMI:
-			if ((VOP_CHIP(vop_dev) == VOP_RK3399) &&
-			    ((screen->face == OUT_P888) ||
-			     (screen->face == OUT_P101010))) {
-				if (vop_dev->id == 0)
-					face = OUT_P101010; /*RGB 10bit output*/
-				else
-					face = OUT_P888;
-			}
-			val = V_HDMI_OUT_EN(1) | V_SW_UV_OFFSET_EN(0);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			val = V_HDMI_HSYNC_POL(screen->pin_hsync) |
-				V_HDMI_VSYNC_POL(screen->pin_vsync) |
-				V_HDMI_DEN_POL(screen->pin_den) |
-				V_HDMI_DCLK_POL(screen->pin_dclk);
-			/*hsync vsync den dclk polo,dither */
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-			break;
-		case SCREEN_RGB:
-		case SCREEN_LVDS:
-			val = V_RGB_OUT_EN(1);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			break;
-		case SCREEN_MIPI:
-			val = V_MIPI_OUT_EN(1);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			val = V_MIPI_HSYNC_POL(screen->pin_hsync) |
-				V_MIPI_VSYNC_POL(screen->pin_vsync) |
-				V_MIPI_DEN_POL(screen->pin_den) |
-				V_MIPI_DCLK_POL(screen->pin_dclk);
-			/*hsync vsync den dclk polo,dither */
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-			break;
-		case SCREEN_DUAL_MIPI:
-			val = V_MIPI_OUT_EN(1) | V_MIPI_DUAL_CHANNEL_EN(1);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			val = V_MIPI_HSYNC_POL(screen->pin_hsync) |
-				V_MIPI_VSYNC_POL(screen->pin_vsync) |
-				V_MIPI_DEN_POL(screen->pin_den) |
-				V_MIPI_DCLK_POL(screen->pin_dclk);
-			/*hsync vsync den dclk polo,dither */
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-			break;
-		case SCREEN_EDP:
-			if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-				if (vop_dev->id == 0)
-					face = OUT_P101010;
-				else
-					face = OUT_P888;
-			}
-			val = V_EDP_OUT_EN(1);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			val = V_EDP_HSYNC_POL(screen->pin_hsync) |
-				V_EDP_VSYNC_POL(screen->pin_vsync) |
-				V_EDP_DEN_POL(screen->pin_den) |
-				V_EDP_DCLK_POL(screen->pin_dclk);
-			/*hsync vsync den dclk polo,dither */
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-			break;
-		case SCREEN_DP:
-			dclk_ddr = 0;
-			if ((VOP_CHIP(vop_dev) == VOP_RK3399) &&
-			    ((screen->face == OUT_P888) ||
-			     (screen->face == OUT_P101010))) {
-				if (vop_dev->id == 0)
-					face = OUT_P101010;
-				else
-					face = OUT_P888;
-			}
-			val = V_DP_OUT_EN(1);
-			vop_msk_reg(vop_dev, SYS_CTRL, val);
-			val = V_DP_HSYNC_POL(screen->pin_hsync) |
-				V_DP_VSYNC_POL(screen->pin_vsync) |
-				V_DP_DEN_POL(screen->pin_den) |
-				V_DP_DCLK_POL(screen->pin_dclk);
-			/*hsync vsync den dclk polo,dither */
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-			break;
-		default:
-			dev_err(vop_dev->dev, "un supported interface[%d]!\n",
-				screen->type);
-			break;
-		}
-
-		if (screen->color_mode == COLOR_RGB)
-			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-		else
-			dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-
-#ifndef CONFIG_RK_FPGA
-		/*
-		 * Todo:
-		 * writel_relaxed(v, RK_GRF_VIRT + vop_GRF_SOC_CON7);
-		 *  move to  lvds driver
-		 */
-		/*GRF_SOC_CON7 bit[15]:0->dsi/lvds mode,1->ttl mode */
-#endif
-		val = V_DSP_OUT_MODE(face) | V_DSP_DCLK_DDR(dclk_ddr) |
-		    V_DSP_BG_SWAP(screen->swap_gb) |
-		    V_DSP_RB_SWAP(screen->swap_rb) |
-		    V_DSP_RG_SWAP(screen->swap_rg) |
-		    V_DSP_DELTA_SWAP(screen->swap_delta) |
-		    V_DSP_DUMMY_SWAP(screen->swap_dumy) | V_DSP_OUT_ZERO(0) |
-		    V_DSP_BLANK_EN(0) | V_DSP_BLACK_EN(0) |
-		    V_DSP_X_MIR_EN(screen->x_mirror) |
-		    V_DSP_Y_MIR_EN(screen->y_mirror);
-		val |= V_SW_CORE_DCLK_SEL(!!screen->pixelrepeat);
-		if (screen->mode.vmode & FB_VMODE_INTERLACED)
-			val |= V_SW_HDMI_CLK_I_SEL(1);
-		else
-			val |= V_SW_HDMI_CLK_I_SEL(0);
-		vop_msk_reg(vop_dev, DSP_CTRL0, val);
-
-		if (screen->mode.vmode & FB_VMODE_INTERLACED)
-			vop_msk_reg(vop_dev, SYS_CTRL1, V_REG_DONE_FRM(1));
-		else
-			vop_msk_reg(vop_dev, SYS_CTRL1, V_REG_DONE_FRM(0));
-		/* BG color */
-		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-			val = V_DSP_OUT_RGB_YUV(1);
-			vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
-			val = V_DSP_BG_BLUE(0x200) | V_DSP_BG_GREEN(0x40) |
-				V_DSP_BG_RED(0x200);
-			vop_msk_reg(vop_dev, DSP_BG, val);
-		} else {
-			val = V_DSP_OUT_RGB_YUV(0);
-			vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
-			val = V_DSP_BG_BLUE(0x55) | V_DSP_BG_GREEN(0x55) |
-				V_DSP_BG_RED(0x55);
-			vop_msk_reg(vop_dev, DSP_BG, val);
-		}
-		dev_drv->output_color = screen->color_mode;
-		vop_bcsh_path_sel(dev_drv);
-		vop_config_timing(dev_drv);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	vop_set_dclk(dev_drv, 1);
-	if (screen->type != SCREEN_HDMI && screen->type != SCREEN_TVOUT &&
-	    dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-
-	return 0;
-}
-
-static int vop_early_suspend(struct rk_lcdc_driver *dev_drv);
-static int vop_early_resume(struct rk_lcdc_driver *dev_drv);
-/*enable layer,open:1,enable;0 disable*/
-static void vop_layer_enable(struct vop_device *vop_dev,
-			     unsigned int win_id, bool open)
-{
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on) &&
-	    vop_dev->driver.win[win_id]->state != open) {
-		if (open) {
-			if (!vop_dev->atv_layer_cnt) {
-				dev_info(vop_dev->dev,
-					 "wakeup from standby!\n");
-				vop_dev->standby = 0;
-			}
-			vop_dev->atv_layer_cnt |= (1 << win_id);
-		} else {
-			if (vop_dev->atv_layer_cnt & (1 << win_id))
-				vop_dev->atv_layer_cnt &= ~(1 << win_id);
-		}
-		vop_dev->driver.win[win_id]->state = open;
-		if (!open) {
-			vop_layer_update_regs(vop_dev,
-					      vop_dev->driver.win[win_id]);
-			vop_cfg_done(vop_dev);
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	/* if no layer used,disable lcdc */
-	if (vop_dev->prop == EXTEND) {
-		if (!vop_dev->atv_layer_cnt && !open) {
-			if (!wait_event_timeout(vop_dev->wait_dmc_queue,
-						!vop_dev->dmc_in_process, HZ / 5))
-				dev_warn(vop_dev->dev,
-					 "Timeout waiting for dmc when vop disable\n");
-
-			vop_dev->vop_switch_status = 1;
-			vop_early_suspend(&vop_dev->driver);
-			dev_info(vop_dev->dev,
-				 "no layer is used,go to standby!\n");
-			vop_dev->standby = 1;
-
-			vop_dev->vop_switch_status = 0;
-			wake_up(&vop_dev->wait_vop_switch_queue);
-			/*
-			 * if clsoe enxtend vop need to enable dmc again.
-			 */
-			if (vop_dev->devfreq) {
-				if (vop_dev->devfreq_event_dev)
-					devfreq_event_enable_edev(vop_dev->devfreq_event_dev);
-				devfreq_resume_device(vop_dev->devfreq);
-			}
-		} else if (open) {
-			vop_early_resume(&vop_dev->driver);
-			vop_dev->vop_switch_status = 0;
-			wake_up(&vop_dev->wait_vop_switch_queue);
-			/* if enable two vop, need to disable dmc */
-			if (vop_dev->devfreq) {
-				if (vop_dev->devfreq_event_dev)
-					devfreq_event_disable_edev(vop_dev->devfreq_event_dev);
-				devfreq_suspend_device(vop_dev->devfreq);
-			}
-			dev_info(vop_dev->dev, "wake up from standby!\n");
-		}
-	} else if (vop_dev->prop == PRMRY) {
-		if ((open) && (!vop_dev->atv_layer_cnt)) {
-			vop_dev->vop_switch_status = 0;
-			wake_up(&vop_dev->wait_vop_switch_queue);
-		}
-	}
-}
-
-static int vop_enable_irq(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = container_of(dev_drv,
-						    struct vop_device, driver);
-	u64 val;
-	/* struct rk_screen *screen = dev_drv->cur_screen; */
-
-	vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);
-
-	val = INTR_FS | INTR_LINE_FLAG0 | INTR_BUS_ERROR | INTR_LINE_FLAG1 |
-		INTR_WIN0_EMPTY | INTR_WIN1_EMPTY | INTR_HWC_EMPTY |
-		INTR_POST_BUF_EMPTY;
-	val |= val << 16;
-
-	vop_msk_reg(vop_dev, INTR_EN0, val);
-
-	return 0;
-}
-
-static int dmc_notify(struct notifier_block *nb, unsigned long event,
-		      void *data)
-{
-	struct vop_device *vop = container_of(nb, struct vop_device, dmc_nb);
-
-	if (event == DEVFREQ_PRECHANGE) {
-
-		/*
-		 * check if vop in enable or disable process,
-		 * if yes, wait until it finish, use 200ms as
-		 * timeout.
-		 */
-		if (!wait_event_timeout(vop->wait_vop_switch_queue,
-					!vop->vop_switch_status, HZ / 5))
-			dev_warn(vop->dev,
-				 "Timeout waiting for vop swtich status\n");
-		vop->dmc_in_process = 1;
-	} else if (event == DEVFREQ_POSTCHANGE) {
-		vop->dmc_in_process = 0;
-		wake_up(&vop->wait_dmc_queue);
-	}
-
-	return NOTIFY_OK;
-}
-
-static int vop_open(struct rk_lcdc_driver *dev_drv, int win_id,
-		    bool open)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (dev_drv->shutdown_flag)
-		return 0;
-	/* enable clk,when first layer open */
-	if ((open) && (!vop_dev->atv_layer_cnt)) {
-		/* rockchip_set_system_status(sys_status); */
-		if (!wait_event_timeout(vop_dev->wait_dmc_queue,
-				!vop_dev->dmc_in_process, HZ / 5))
-			dev_warn(vop_dev->dev,
-				 "Timeout waiting for dmc when vop enable\n");
-		vop_dev->vop_switch_status = 1;
-		if (vop_pre_init(dev_drv))
-			return -1;
-		vop_clk_enable(vop_dev);
-		vop_enable_irq(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (!dev_drv->mmu_dev) {
-				dev_drv->mmu_dev =
-				    rk_fb_get_sysmmu_device_by_compatible
-				    (dev_drv->mmu_dts_name);
-				if (dev_drv->mmu_dev) {
-					rk_fb_platform_set_sysmmu
-					    (dev_drv->mmu_dev, dev_drv->dev);
-				} else {
-					dev_err(dev_drv->dev,
-						"fail get rk iommu device\n");
-					return -1;
-				}
-			}
-		}
-		if ((support_uboot_display() && (vop_dev->prop == PRMRY)))
-			vop_set_dclk(dev_drv, 0);
-		else
-			vop_load_screen(dev_drv, 1);
-		if (dev_drv->bcsh.enable)
-			vop_set_bcsh(dev_drv, 1);
-		vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
-		vop_set_cabc(dev_drv, dev_drv->cur_screen->cabc_lut);
-	}
-
-	if (win_id < dev_drv->lcdc_win_num)
-		vop_layer_enable(vop_dev, win_id, open);
-	else
-		dev_err(vop_dev->dev, "invalid win id:%d\n", win_id);
-
-	dev_drv->first_frame = 0;
-	return 0;
-}
-
-static int win_0_1_display(struct vop_device *vop_dev,
-			   struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	unsigned int off;
-
-	off = win->id * 0x40;
-	/*win->smem_start + win->y_offset; */
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
-	    vop_dev->id, win->id, y_addr, uv_addr);
-	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
-	    win->area[0].y_offset, win->area[0].c_offset);
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		win->area[0].uv_addr = uv_addr;
-		vop_writel(vop_dev, WIN0_YRGB_MST + off, win->area[0].y_addr);
-		vop_writel(vop_dev, WIN0_CBR_MST + off, win->area[0].uv_addr);
-		if (win->area[0].fbdc_en == 1)
-			vop_writel(vop_dev, AFBCD0_HDR_PTR,
-				   win->area[0].y_addr);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int win_2_3_display(struct vop_device *vop_dev,
-			   struct rk_lcdc_win *win)
-{
-	u32 i, y_addr;
-	unsigned int off;
-
-	off = (win->id - 2) * 0x50;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc[%d]:win[%d]:", vop_dev->id, win->id);
-
-	if (likely(vop_dev->clk_on)) {
-		for (i = 0; i < win->area_num; i++) {
-			DBG(2, "area[%d]:yaddr:0x%x>>offset:0x%x>>\n",
-			    i, win->area[i].y_addr, win->area[i].y_offset);
-			win->area[i].y_addr =
-			    win->area[i].smem_start + win->area[i].y_offset;
-			}
-		spin_lock(&vop_dev->reg_lock);
-		vop_writel(vop_dev, WIN2_MST0 + off, win->area[0].y_addr);
-		vop_writel(vop_dev, WIN2_MST1 + off, win->area[1].y_addr);
-		vop_writel(vop_dev, WIN2_MST2 + off, win->area[2].y_addr);
-		vop_writel(vop_dev, WIN2_MST3 + off, win->area[3].y_addr);
-		if (win->area[0].fbdc_en == 1)
-			vop_writel(vop_dev, AFBCD0_HDR_PTR,
-				   win->area[0].y_addr);
-		spin_unlock(&vop_dev->reg_lock);
-	}
-	return 0;
-}
-
-static int hwc_display(struct vop_device *vop_dev, struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc[%d]:hwc>>%s>>y_addr:0x%x>>\n",
-	    vop_dev->id, __func__, y_addr);
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		vop_writel(vop_dev, HWC_MST, win->area[0].y_addr);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	win = dev_drv->win[win_id];
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	if (win_id == 0) {
-		win_0_1_display(vop_dev, win);
-	} else if (win_id == 1) {
-		win_0_1_display(vop_dev, win);
-	} else if (win_id == 2) {
-		win_2_3_display(vop_dev, win);
-	} else if (win_id == 3) {
-		win_2_3_display(vop_dev, win);
-	} else if (win_id == 4) {
-		hwc_display(vop_dev, win);
-	} else {
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int vop_cal_scl_fac(struct rk_lcdc_win *win, struct rk_screen *screen)
-{
-	u16 srcW = 0;
-	u16 srcH = 0;
-	u16 dstW = 0;
-	u16 dstH = 0;
-	u16 yrgb_srcW = 0;
-	u16 yrgb_srcH = 0;
-	u16 yrgb_dstW = 0;
-	u16 yrgb_dstH = 0;
-	u32 yrgb_vscalednmult = 0;
-	u32 yrgb_xscl_factor = 0;
-	u32 yrgb_yscl_factor = 0;
-	u8 yrgb_vsd_bil_gt2 = 0;
-	u8 yrgb_vsd_bil_gt4 = 0;
-
-	u16 cbcr_srcW = 0;
-	u16 cbcr_srcH = 0;
-	u16 cbcr_dstW = 0;
-	u16 cbcr_dstH = 0;
-	u32 cbcr_vscalednmult = 0;
-	u32 cbcr_xscl_factor = 0;
-	u32 cbcr_yscl_factor = 0;
-	u8 cbcr_vsd_bil_gt2 = 0;
-	u8 cbcr_vsd_bil_gt4 = 0;
-	u8 yuv_fmt = 0;
-
-	srcW = win->area[0].xact;
-	if ((screen->mode.vmode & FB_VMODE_INTERLACED) &&
-	    (win->area[0].yact == 2 * win->area[0].ysize)) {
-		srcH = win->area[0].yact / 2;
-		yrgb_vsd_bil_gt2 = 1;
-		cbcr_vsd_bil_gt2 = 1;
-	} else {
-		srcH = win->area[0].yact;
-	}
-	dstW = win->area[0].xsize;
-	dstH = win->area[0].ysize;
-
-	/*yrgb scl mode */
-	yrgb_srcW = srcW;
-	yrgb_srcH = srcH;
-	yrgb_dstW = dstW;
-	yrgb_dstH = dstH;
-	if ((yrgb_dstW * 8 <= yrgb_srcW) || (yrgb_dstH * 8 <= yrgb_srcH)) {
-		pr_err("ERROR: yrgb scale exceed 8,");
-		pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
-		       yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH);
-	}
-	if (yrgb_srcW < yrgb_dstW)
-		win->yrgb_hor_scl_mode = SCALE_UP;
-	else if (yrgb_srcW > yrgb_dstW)
-		win->yrgb_hor_scl_mode = SCALE_DOWN;
-	else
-		win->yrgb_hor_scl_mode = SCALE_NONE;
-
-	if (yrgb_srcH < yrgb_dstH)
-		win->yrgb_ver_scl_mode = SCALE_UP;
-	else if (yrgb_srcH > yrgb_dstH)
-		win->yrgb_ver_scl_mode = SCALE_DOWN;
-	else
-		win->yrgb_ver_scl_mode = SCALE_NONE;
-
-	/*cbcr scl mode */
-	switch (win->area[0].format) {
-	case YUV422:
-	case YUYV422:
-	case UYVY422:
-	case YUV422_A:
-		cbcr_srcW = srcW / 2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV420:
-	case YUYV420:
-	case UYVY420:
-	case YUV420_A:
-	case YUV420_NV21:
-		cbcr_srcW = srcW / 2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH / 2;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV444:
-	case YUV444_A:
-		cbcr_srcW = srcW;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	default:
-		cbcr_srcW = 0;
-		cbcr_dstW = 0;
-		cbcr_srcH = 0;
-		cbcr_dstH = 0;
-		yuv_fmt = 0;
-		break;
-	}
-	if (yuv_fmt) {
-		if ((cbcr_dstW * 8 <= cbcr_srcW) ||
-		    (cbcr_dstH * 8 <= cbcr_srcH)) {
-			pr_err("ERROR: cbcr scale exceed 8,");
-			pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n", cbcr_srcW,
-			       cbcr_srcH, cbcr_dstW, cbcr_dstH);
-		}
-	}
-
-	if (cbcr_srcW < cbcr_dstW)
-		win->cbr_hor_scl_mode = SCALE_UP;
-	else if (cbcr_srcW > cbcr_dstW)
-		win->cbr_hor_scl_mode = SCALE_DOWN;
-	else
-		win->cbr_hor_scl_mode = SCALE_NONE;
-
-	if (cbcr_srcH < cbcr_dstH)
-		win->cbr_ver_scl_mode = SCALE_UP;
-	else if (cbcr_srcH > cbcr_dstH)
-		win->cbr_ver_scl_mode = SCALE_DOWN;
-	else
-		win->cbr_ver_scl_mode = SCALE_NONE;
-
-	/* line buffer mode */
-	if ((win->area[0].format == YUV422) ||
-	    (win->area[0].format == YUV420) ||
-	    (win->area[0].format == YUYV422) ||
-	    (win->area[0].format == YUYV420) ||
-	    (win->area[0].format == UYVY422) ||
-	    (win->area[0].format == UYVY420) ||
-	    (win->area[0].format == YUV420_NV21) ||
-	    (win->area[0].format == YUV422_A) ||
-	    (win->area[0].format == YUV420_A)) {
-		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
-			if ((cbcr_dstW > VOP_INPUT_MAX_WIDTH / 2) ||
-			    (cbcr_dstW == 0))
-				pr_err("ERROR cbcr_dstW = %d,exceeds 2048\n",
-				       cbcr_dstW);
-			else if (cbcr_dstW > 1280)
-				win->win_lb_mode = LB_YUV_3840X5;
-			else
-				win->win_lb_mode = LB_YUV_2560X8;
-		} else {	/* SCALE_UP or SCALE_NONE */
-			if ((cbcr_srcW > VOP_INPUT_MAX_WIDTH / 2) ||
-			    (cbcr_srcW == 0))
-				pr_err("ERROR cbcr_srcW = %d,exceeds 2048\n",
-				       cbcr_srcW);
-			else if (cbcr_srcW > 1280)
-				win->win_lb_mode = LB_YUV_3840X5;
-			else
-				win->win_lb_mode = LB_YUV_2560X8;
-		}
-	} else {
-		if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
-			if ((yrgb_dstW > VOP_INPUT_MAX_WIDTH) ||
-			    (yrgb_dstW == 0))
-				pr_err("ERROR yrgb_dstW = %d\n", yrgb_dstW);
-			else if (yrgb_dstW > 2560)
-				win->win_lb_mode = LB_RGB_3840X2;
-			else if (yrgb_dstW > 1920)
-				win->win_lb_mode = LB_RGB_2560X4;
-			else if (yrgb_dstW > 1280)
-				win->win_lb_mode = LB_RGB_1920X5;
-			else
-				win->win_lb_mode = LB_RGB_1280X8;
-		} else {	/* SCALE_UP or SCALE_NONE */
-			if ((yrgb_srcW > VOP_INPUT_MAX_WIDTH) ||
-			    (yrgb_srcW == 0))
-				pr_err("ERROR yrgb_srcW = %d\n", yrgb_srcW);
-			else if (yrgb_srcW > 2560)
-				win->win_lb_mode = LB_RGB_3840X2;
-			else if (yrgb_srcW > 1920)
-				win->win_lb_mode = LB_RGB_2560X4;
-			else if (yrgb_srcW > 1280)
-				win->win_lb_mode = LB_RGB_1920X5;
-			else
-				win->win_lb_mode = LB_RGB_1280X8;
-		}
-	}
-	DBG(1, "win->win_lb_mode = %d;\n", win->win_lb_mode);
-
-	/* vsd/vsu scale ALGORITHM */
-	win->yrgb_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->cbr_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->yrgb_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->cbr_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-
-	/* if (VOP_CHIP(vop_dev) == VOP_RK3399) { */
-	if ((win->area[0].format == YUYV422) ||
-	    (win->area[0].format == YUYV420) ||
-	    (win->area[0].format == UYVY422) ||
-	    (win->area[0].format == UYVY420)) {
-		yrgb_vscalednmult =
-			vop_get_hard_ware_vskiplines(yrgb_srcH, yrgb_dstH);
-		if (yrgb_vscalednmult == 4) {
-			yrgb_vsd_bil_gt4 = 1;
-			yrgb_vsd_bil_gt2 = 0;
-		} else if (yrgb_vscalednmult == 2) {
-			yrgb_vsd_bil_gt4 = 0;
-			yrgb_vsd_bil_gt2 = 1;
-		} else {
-			yrgb_vsd_bil_gt4 = 0;
-			yrgb_vsd_bil_gt2 = 0;
-		}
-		if ((win->area[0].format == YUYV420) ||
-		    (win->area[0].format == UYVY420)) {
-			if ((yrgb_vsd_bil_gt4 == 1) || (yrgb_vsd_bil_gt2 == 1))
-				win->yrgb_vsd_mode = SCALE_DOWN_AVG;
-		}
-
-		cbcr_vscalednmult =
-			vop_get_hard_ware_vskiplines(cbcr_srcH, cbcr_dstH);
-		if (cbcr_vscalednmult == 4) {
-			cbcr_vsd_bil_gt4 = 1;
-			cbcr_vsd_bil_gt2 = 0;
-		} else if (cbcr_vscalednmult == 2) {
-			cbcr_vsd_bil_gt4 = 0;
-			cbcr_vsd_bil_gt2 = 1;
-		} else {
-			cbcr_vsd_bil_gt4 = 0;
-			cbcr_vsd_bil_gt2 = 0;
-		}
-		if ((win->area[0].format == YUYV420) ||
-		    (win->area[0].format == UYVY420)) {
-			if ((cbcr_vsd_bil_gt4 == 1) || (cbcr_vsd_bil_gt2 == 1))
-				win->cbr_vsd_mode = SCALE_DOWN_AVG;
-		}
-		/* CBCR vsd_mode must same to YRGB for YUYV when gt2 or gt4 */
-		if ((cbcr_vsd_bil_gt4 == 1) || (cbcr_vsd_bil_gt2 == 1)) {
-			if (win->yrgb_vsd_mode != win->cbr_vsd_mode)
-				win->cbr_vsd_mode = win->yrgb_vsd_mode;
-		}
-	}
-	/* 3399 yuyv support*/
-	if (win->ymirror == 1) {
-		if (win->yrgb_vsd_mode == SCALE_DOWN_AVG)
-			pr_info("y_mirror enable, y-vsd AVG mode unsupprot\n");
-		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
-	}
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		if (win->yrgb_vsd_mode == SCALE_DOWN_AVG)
-			pr_info("interlace mode, y-vsd AVG mode unsupprot\n");
-		/* interlace mode must bill */
-		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
-		win->cbr_vsd_mode = SCALE_DOWN_BIL;
-	}
-	switch (win->win_lb_mode) {
-	case LB_YUV_3840X5:
-	case LB_YUV_2560X8:
-	case LB_RGB_1920X5:
-	case LB_RGB_1280X8:
-		win->yrgb_vsu_mode = SCALE_UP_BIC;
-		win->cbr_vsu_mode = SCALE_UP_BIC;
-		break;
-	case LB_RGB_3840X2:
-		if (win->yrgb_ver_scl_mode != SCALE_NONE)
-			pr_err("ERROR : not allow yrgb ver scale\n");
-		if (win->cbr_ver_scl_mode != SCALE_NONE)
-			pr_err("ERROR : not allow cbcr ver scale\n");
-		break;
-	case LB_RGB_2560X4:
-		win->yrgb_vsu_mode = SCALE_UP_BIL;
-		win->cbr_vsu_mode = SCALE_UP_BIL;
-		break;
-	default:
-		pr_info("%s:un supported win_lb_mode:%d\n",
-			__func__, win->win_lb_mode);
-		break;
-	}
-
-	if ((win->yrgb_ver_scl_mode == SCALE_DOWN) &&
-	    (win->area[0].fbdc_en == 1)) {
-		/* in this pattern,use bil mode,not support souble scd,
-		 * use avg mode, support double scd, but aclk should be
-		 * bigger than dclk.
-		 */
-		if (yrgb_srcH >= 2 * yrgb_dstH) {
-			pr_err("ERROR : fbdc mode,not support y scale down:");
-			pr_err("srcH[%d] > 2 *dstH[%d]\n",
-			       yrgb_srcH, yrgb_dstH);
-		}
-	}
-	DBG(1, "yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
-	    win->yrgb_hsd_mode, win->yrgb_vsd_mode, win->yrgb_vsu_mode,
-	    win->cbr_hsd_mode, win->cbr_vsd_mode, win->cbr_vsu_mode);
-
-	/* SCALE FACTOR */
-
-	/* (1.1)YRGB HOR SCALE FACTOR */
-	switch (win->yrgb_hor_scl_mode) {
-	case SCALE_NONE:
-		yrgb_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
-		break;
-	case SCALE_DOWN:
-		switch (win->yrgb_hsd_mode) {
-		case SCALE_DOWN_BIL:
-			yrgb_xscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
-			break;
-		case SCALE_DOWN_AVG:
-			yrgb_xscl_factor =
-			    GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
-			break;
-		default:
-			pr_info("%s:un supported yrgb_hsd_mode:%d\n", __func__,
-				win->yrgb_hsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported yrgb_hor_scl_mode:%d\n",
-			__func__, win->yrgb_hor_scl_mode);
-		break;
-	}
-
-	/* (1.2)YRGB VER SCALE FACTOR */
-	switch (win->yrgb_ver_scl_mode) {
-	case SCALE_NONE:
-		yrgb_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		switch (win->yrgb_vsu_mode) {
-		case SCALE_UP_BIL:
-			yrgb_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
-			break;
-		case SCALE_UP_BIC:
-			if (yrgb_srcH < 3) {
-				pr_err("yrgb_srcH should be");
-				pr_err(" greater than 3 !!!\n");
-			}
-			yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH,
-								yrgb_dstH);
-			break;
-		default:
-			pr_info("%s:un support yrgb_vsu_mode:%d\n",
-				__func__, win->yrgb_vsu_mode);
-			break;
-		}
-		break;
-	case SCALE_DOWN:
-		switch (win->yrgb_vsd_mode) {
-		case SCALE_DOWN_BIL:
-			yrgb_vscalednmult =
-			    vop_get_hard_ware_vskiplines(yrgb_srcH, yrgb_dstH);
-			yrgb_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH,
-							   yrgb_vscalednmult);
-			if (yrgb_yscl_factor >= 0x2000) {
-				pr_err("yrgb_yscl_factor should less 0x2000");
-				pr_err("yrgb_yscl_factor=%4x;\n",
-				       yrgb_yscl_factor);
-			}
-			if (yrgb_vscalednmult == 4) {
-				yrgb_vsd_bil_gt4 = 1;
-				yrgb_vsd_bil_gt2 = 0;
-			} else if (yrgb_vscalednmult == 2) {
-				yrgb_vsd_bil_gt4 = 0;
-				yrgb_vsd_bil_gt2 = 1;
-			} else {
-				yrgb_vsd_bil_gt4 = 0;
-				yrgb_vsd_bil_gt2 = 0;
-			}
-			break;
-		case SCALE_DOWN_AVG:
-			yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH,
-								 yrgb_dstH);
-			break;
-		default:
-			pr_info("%s:un support yrgb_vsd_mode:%d\n",
-				__func__, win->yrgb_vsd_mode);
-			break;
-		}		/*win->yrgb_vsd_mode */
-		break;
-	default:
-		pr_info("%s:un supported yrgb_ver_scl_mode:%d\n",
-			__func__, win->yrgb_ver_scl_mode);
-		break;
-	}
-	win->scale_yrgb_x = yrgb_xscl_factor;
-	win->scale_yrgb_y = yrgb_yscl_factor;
-	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
-	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
-	DBG(1, "yrgb:h_fac=%d, V_fac=%d,gt4=%d, gt2=%d\n", yrgb_xscl_factor,
-	    yrgb_yscl_factor, yrgb_vsd_bil_gt4, yrgb_vsd_bil_gt2);
-
-	/*(2.1)CBCR HOR SCALE FACTOR */
-	switch (win->cbr_hor_scl_mode) {
-	case SCALE_NONE:
-		cbcr_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
-		break;
-	case SCALE_DOWN:
-		switch (win->cbr_hsd_mode) {
-		case SCALE_DOWN_BIL:
-			cbcr_xscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
-			break;
-		case SCALE_DOWN_AVG:
-			cbcr_xscl_factor =
-			    GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
-			break;
-		default:
-			pr_info("%s:un support cbr_hsd_mode:%d\n",
-				__func__, win->cbr_hsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported cbr_hor_scl_mode:%d\n",
-			__func__, win->cbr_hor_scl_mode);
-		break;
-	}			/*win->cbr_hor_scl_mode */
-
-	/* (2.2)CBCR VER SCALE FACTOR */
-	switch (win->cbr_ver_scl_mode) {
-	case SCALE_NONE:
-		cbcr_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		switch (win->cbr_vsu_mode) {
-		case SCALE_UP_BIL:
-			cbcr_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
-			break;
-		case SCALE_UP_BIC:
-			if (cbcr_srcH < 3) {
-				pr_err("cbcr_srcH should be ");
-				pr_err("greater than 3 !!!\n");
-			}
-			cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH,
-								cbcr_dstH);
-			break;
-		default:
-			pr_info("%s:un support cbr_vsu_mode:%d\n",
-				__func__, win->cbr_vsu_mode);
-			break;
-		}
-		break;
-	case SCALE_DOWN:
-		switch (win->cbr_vsd_mode) {
-		case SCALE_DOWN_BIL:
-			cbcr_vscalednmult =
-			    vop_get_hard_ware_vskiplines(cbcr_srcH, cbcr_dstH);
-			cbcr_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH,
-							   cbcr_vscalednmult);
-			if (cbcr_yscl_factor >= 0x2000) {
-				pr_err("cbcr_yscl_factor should be less ");
-				pr_err("than 0x2000,cbcr_yscl_factor=%4x;\n",
-				       cbcr_yscl_factor);
-			}
-
-			if (cbcr_vscalednmult == 4) {
-				cbcr_vsd_bil_gt4 = 1;
-				cbcr_vsd_bil_gt2 = 0;
-			} else if (cbcr_vscalednmult == 2) {
-				cbcr_vsd_bil_gt4 = 0;
-				cbcr_vsd_bil_gt2 = 1;
-			} else {
-				cbcr_vsd_bil_gt4 = 0;
-				cbcr_vsd_bil_gt2 = 0;
-			}
-			break;
-		case SCALE_DOWN_AVG:
-			cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH,
-								 cbcr_dstH);
-			break;
-		default:
-			pr_info("%s:un support cbr_vsd_mode:%d\n",
-				__func__, win->cbr_vsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported cbr_ver_scl_mode:%d\n",
-			__func__, win->cbr_ver_scl_mode);
-		break;
-	}
-	win->scale_cbcr_x = cbcr_xscl_factor;
-	win->scale_cbcr_y = cbcr_yscl_factor;
-	win->vsd_cbr_gt4 = cbcr_vsd_bil_gt4;
-	win->vsd_cbr_gt2 = cbcr_vsd_bil_gt2;
-
-	DBG(1, "cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n", cbcr_xscl_factor,
-	    cbcr_yscl_factor, cbcr_vsd_bil_gt4, cbcr_vsd_bil_gt2);
-	return 0;
-}
-
-static int dsp_x_pos(int mirror_en, struct rk_screen *screen,
-		     struct rk_lcdc_win_area *area)
-{
-	int pos;
-
-	if (screen->x_mirror && mirror_en)
-		pr_err("not support both win and global mirror\n");
-
-	if ((!mirror_en) && (!screen->x_mirror))
-		pos = area->xpos + screen->mode.left_margin +
-			screen->mode.hsync_len;
-	else
-		pos = screen->mode.xres - area->xpos -
-			area->xsize + screen->mode.left_margin +
-			screen->mode.hsync_len;
-
-	return pos;
-}
-
-static int dsp_y_pos(int mirror_en, struct rk_screen *screen,
-		     struct rk_lcdc_win_area *area)
-{
-	int pos;
-
-	if (screen->y_mirror && mirror_en)
-		pr_err("not support both win and global mirror\n");
-
-	if ((!mirror_en) && (!screen->y_mirror))
-		pos = area->ypos + screen->mode.upper_margin +
-			screen->mode.vsync_len;
-	else
-		pos = screen->mode.yres - area->ypos -
-			area->ysize + screen->mode.upper_margin +
-			screen->mode.vsync_len;
-
-	return pos;
-}
-
-static int win_0_1_set_par(struct vop_device *vop_dev,
-			   struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
-	u8 fmt_cfg = 0, swap_rb = 0, swap_uv = 0;
-	char fmt[9] = "NULL";
-
-	xpos = dsp_x_pos(win->xmirror, screen, &win->area[0]);
-	ypos = dsp_y_pos(win->ymirror, screen, &win->area[0]);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_cal_scl_fac(win, screen);
-		switch (win->area[0].format) {
-		case FBDC_RGB_565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_RGB565;
-			break;
-		case FBDC_ARGB_888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-			break;
-		case FBDC_ABGR_888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-			break;
-		case FBDC_RGBX_888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-			break;
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case BGR888:
-			fmt_cfg = 1;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420_NV21:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			swap_uv = 1;
-			win->fmt_10 = 0;
-			break;
-		case YUV444:
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422_A:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV420_A:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV444_A:
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUYV422:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].yuyv_fmt = 1;
-			break;
-		case YUYV420:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].yuyv_fmt = 1;
-			break;
-		case UYVY422:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].yuyv_fmt = 1;
-			break;
-		case UYVY420:
-			fmt_cfg = 3;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].yuyv_fmt = 1;
-			break;
-		default:
-			dev_err(vop_dev->dev, "%s:unsupport format[%d]!\n",
-				__func__, win->area[0].format);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].swap_uv = swap_uv;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	if (win->area[0].fbdc_en)
-		vop_init_fbdc_config(vop_dev, win->id);
-	vop_win_0_1_reg_update(&vop_dev->driver, win->id);
-	spin_unlock(&vop_dev->reg_lock);
-
-	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
-	    vop_dev->id, win->id, get_format_string(win->area[0].format, fmt),
-	    xact, yact, win->area[0].xsize);
-	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-	    win->area[0].ysize, xvir, yvir, xpos, ypos);
-
-	return 0;
-}
-
-static int win_2_3_set_par(struct vop_device *vop_dev,
-			   struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	int i;
-	u8 fmt_cfg = 0, swap_rb = 0;
-	char fmt[9] = "NULL";
-
-	if (VOP_CHIP(vop_dev) == VOP_RK322X) {
-		pr_err("rk3228 not support win2/3 set par\n");
-		return -EINVAL;
-	}
-	if (win->ymirror) {
-		pr_err("win[%d] not support y mirror\n", win->id);
-		return -EINVAL;
-	}
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		DBG(2, "lcdc[%d]:win[%d]>>\n>\n", vop_dev->id, win->id);
-		for (i = 0; i < win->area_num; i++) {
-			switch (win->area[i].format) {
-			case FBDC_RGB_565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_RGB565;
-				break;
-			case FBDC_ARGB_888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-				break;
-			case FBDC_ABGR_888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-				break;
-			case FBDC_RGBX_888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
-				break;
-			case ARGB888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				break;
-			case XBGR888:
-			case ABGR888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				break;
-			case RGB888:
-				fmt_cfg = 1;
-				swap_rb = 0;
-				break;
-			case RGB565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				break;
-			default:
-				dev_err(vop_dev->driver.dev,
-					"%s:un supported format!\n", __func__);
-				spin_unlock(&vop_dev->reg_lock);
-				return -EINVAL;
-			}
-			win->area[i].fmt_cfg = fmt_cfg;
-			win->area[i].swap_rb = swap_rb;
-			win->area[i].dsp_stx = dsp_x_pos(win->xmirror, screen,
-							 &win->area[i]);
-			win->area[i].dsp_sty = dsp_y_pos(win->ymirror, screen,
-							 &win->area[i]);
-			if (((win->area[i].xact != win->area[i].xsize) ||
-			     (win->area[i].yact != win->area[i].ysize)) &&
-			    (screen->mode.vmode == FB_VMODE_NONINTERLACED)) {
-				pr_err("win[%d]->area[%d],not support scale\n",
-				       win->id, i);
-				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
-				       win->area[i].xact, win->area[i].yact,
-				       win->area[i].xsize, win->area[i].ysize);
-				win->area[i].xsize = win->area[i].xact;
-				win->area[i].ysize = win->area[i].yact;
-			}
-			DBG(2, "fmt:%s:xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d\n",
-			    get_format_string(win->area[i].format, fmt),
-			    win->area[i].xsize, win->area[i].ysize,
-			    win->area[i].xpos, win->area[i].ypos);
-		}
-	}
-	if (win->area[0].fbdc_en)
-		vop_init_fbdc_config(vop_dev, win->id);
-	vop_win_2_3_reg_update(&vop_dev->driver, win->id);
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-static int hwc_set_par(struct vop_device *vop_dev,
-		       struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
-	u8 fmt_cfg = 0, swap_rb = 0;
-	char fmt[9] = "NULL";
-
-	xpos = win->area[0].xpos + screen->mode.left_margin +
-	    screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin +
-	    screen->mode.vsync_len;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		switch (win->area[0].format) {
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			break;
-		default:
-			dev_err(vop_dev->dev, "%s:un supported format[%d]!\n",
-				__func__, win->area[0].format);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	vop_hwc_reg_update(&vop_dev->driver, 4);
-	spin_unlock(&vop_dev->reg_lock);
-
-	DBG(1, "lcdc[%d]:hwc>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
-	    vop_dev->id, __func__, get_format_string(win->area[0].format, fmt),
-	    xact, yact, win->area[0].xsize);
-	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-	    win->area[0].ysize, xvir, yvir, xpos, ypos);
-	return 0;
-}
-
-static int vop_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	win = dev_drv->win[win_id];
-	if (win)
-	switch (win_id) {
-	case 0:
-		win_0_1_set_par(vop_dev, screen, win);
-		break;
-	case 1:
-		win_0_1_set_par(vop_dev, screen, win);
-		break;
-	case 2:
-		win_2_3_set_par(vop_dev, screen, win);
-		break;
-	case 3:
-		win_2_3_set_par(vop_dev, screen, win);
-		break;
-	case 4:
-		hwc_set_par(vop_dev, screen, win);
-		break;
-	default:
-		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
-		break;
-	}
-	return 0;
-}
-
-static int vop_set_writeback(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int output_color = dev_drv->output_color;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	struct rk_fb_reg_wb_data *wb_data;
-	int xact = screen->mode.xres;
-	int yact = screen->mode.yres;
-	u32 fmt_cfg;
-	int xsize, ysize;
-	u64 v;
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	wb_data = &dev_drv->wb_data;
-	if ((wb_data->xsize == 0) || (wb_data->ysize == 0))
-		return 0;
-
-	xsize = wb_data->xsize;
-	ysize = wb_data->ysize;
-
-	/*
-	 * RGB overlay mode support ARGB888, RGB888, RGB565, NV12,
-	 * but YUV overlay mode only support NV12, it's hard to judge RGB
-	 * or YUV overlay mode by userspace, so here force only support
-	 * NV12 mode.
-	 */
-	if (wb_data->data_format != YUV420 && output_color != COLOR_RGB) {
-		pr_err("writeback only support NV12 when overlay is not RGB\n");
-		return -EINVAL;
-	}
-
-	if (ysize != yact && ysize != (yact / 2)) {
-		pr_err("WriteBack only support yact=%d, ysize=%d\n",
-		       yact, ysize);
-		return -EINVAL;
-	}
-
-	switch (wb_data->data_format) {
-	case ARGB888:
-	case ABGR888:
-	case XRGB888:
-	case XBGR888:
-		fmt_cfg = 0;
-		break;
-	case RGB888:
-	case BGR888:
-		fmt_cfg = 1;
-		break;
-	case RGB565:
-	case BGR565:
-		fmt_cfg = 2;
-		break;
-	case YUV420:
-		fmt_cfg = 8;
-		break;
-	default:
-		pr_info("unsupport fmt: %d\n", wb_data->data_format);
-		return -EINVAL;
-	}
-
-	v = V_WB_EN(wb_data->state) | V_WB_FMT(fmt_cfg) | V_WB_RGB2YUV_MODE(1) |
-		V_WB_XPSD_BIL_EN(xact != xsize) |
-		V_WB_YTHROW_EN(ysize == (yact / 2)) |
-		V_WB_YTHROW_MODE(0);
-
-	v |= V_WB_RGB2YUV_EN((output_color == COLOR_RGB) &&
-			     (wb_data->data_format == YUV420));
-
-	vop_msk_reg(vop_dev, WB_CTRL0, v);
-
-	v = V_WB_WIDTH(xsize) | V_WB_XPSD_BIL_FACTOR((xact << 12) / xsize);
-
-	vop_msk_reg(vop_dev, WB_CTRL1, v);
-
-	vop_writel(vop_dev, WB_YRGB_MST, wb_data->smem_start);
-	if (wb_data->data_format == YUV420)
-		vop_writel(vop_dev, WB_CBR_MST, wb_data->smem_start);
-
-	return 0;
-}
-
-static int vop_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-		     unsigned long arg, int win_id)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = vop_dev->screen->mode.xres;
-		panel_size[1] = vop_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp, sizeof(clr_key_cfg)))
-			return -EFAULT;
-		vop_clr_key_cfg(dev_drv);
-		vop_writel(vop_dev, WIN0_COLOR_KEY,
-			   clr_key_cfg.win0_color_key_cfg);
-		vop_writel(vop_dev, WIN1_COLOR_KEY,
-			   clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int vop_get_backlight_device(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = container_of(dev_drv,
-						    struct vop_device, driver);
-	struct device_node *backlight;
-	struct property *prop;
-	u32 *brightness_levels;
-	u32 length, max, last;
-
-	if (vop_dev->backlight)
-		return 0;
-	backlight = of_parse_phandle(vop_dev->dev->of_node, "backlight", 0);
-	if (backlight) {
-		vop_dev->backlight = of_find_backlight_by_node(backlight);
-		if (!vop_dev->backlight)
-			dev_info(vop_dev->dev, "No find backlight device\n");
-	} else {
-		dev_info(vop_dev->dev, "No find backlight device node\n");
-	}
-	prop = of_find_property(backlight, "brightness-levels", &length);
-	if (!prop)
-		return -EINVAL;
-	max = length / sizeof(u32);
-	last = max - 1;
-	brightness_levels = kmalloc(256, GFP_KERNEL);
-	if (!brightness_levels)
-		return -ENOMEM;
-
-	if (!of_property_read_u32_array(backlight, "brightness-levels",
-					brightness_levels, max)) {
-		if (brightness_levels[0] > brightness_levels[last])
-			dev_drv->cabc_pwm_pol = 1;/*negative*/
-		else
-			dev_drv->cabc_pwm_pol = 0;/*positive*/
-	} else {
-		dev_info(vop_dev->dev,
-			 "Can not read brightness-levels value\n");
-	}
-
-	kfree(brightness_levels);
-
-	return 0;
-}
-
-static int vop_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (dev_drv->suspend_flag)
-		return 0;
-
-	dev_drv->suspend_flag = 1;
-	/* ensure suspend_flag take effect on multi process */
-	smp_wmb();
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-
-	if (likely(vop_dev->clk_on)) {
-		spin_lock(&vop_dev->reg_lock);
-		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLANK_EN(1));
-		vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);
-		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_OUT_ZERO(1));
-		vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(1));
-		if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-			vop_msk_reg(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
-			vop_msk_reg(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
-			vop_msk_reg(vop_dev, WIN2_CTRL0, V_WIN2_EN(0));
-			vop_msk_reg(vop_dev, WIN3_CTRL0, V_WIN3_EN(0));
-			vop_msk_reg(vop_dev, AFBCD0_CTRL, V_VOP_FBDC_EN(0));
-		}
-		vop_cfg_done(vop_dev);
-
-		if (dev_drv->iommu_enabled && dev_drv->mmu_dev) {
-			mdelay(50);
-			rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	vop_clk_disable(vop_dev);
-	rk_disp_pwr_disable(dev_drv);
-
-	return 0;
-}
-
-static int vop_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-
-	vop_clk_enable(vop_dev);
-	spin_lock(&vop_dev->reg_lock);
-	memcpy(vop_dev->regs, vop_dev->regsbak, vop_dev->len);
-	spin_unlock(&vop_dev->reg_lock);
-
-	vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
-	vop_set_cabc(dev_drv, dev_drv->cur_screen->cabc_lut);
-	spin_lock(&vop_dev->reg_lock);
-
-	vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_OUT_ZERO(0));
-	vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLANK_EN(0));
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-
-	if (dev_drv->iommu_enabled && dev_drv->mmu_dev) {
-		/* win address maybe effect after next frame start,
-		 * but mmu maybe effect right now, so we delay 50ms
-		 */
-		mdelay(50);
-		rockchip_iovmm_activate(dev_drv->dev);
-	}
-
-	spin_lock(&vop_dev->reg_lock);
-	vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(0));
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-
-	dev_drv->suspend_flag = 0;
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-
-	return 0;
-}
-
-static int vop_blank(struct rk_lcdc_driver *dev_drv, int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		vop_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		vop_early_suspend(dev_drv);
-		break;
-	default:
-		vop_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int vop_get_win_state(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int area_id)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	u32 area_status = 0, state = 0;
-
-	switch (win_id) {
-	case 0:
-		area_status = vop_read_bit(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
-		break;
-	case 1:
-		area_status = vop_read_bit(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
-		break;
-	case 2:
-		if (area_id == 0)
-			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
-						   V_WIN2_MST0_EN(0));
-		if (area_id == 1)
-			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
-						   V_WIN2_MST1_EN(0));
-		if (area_id == 2)
-			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
-						   V_WIN2_MST2_EN(0));
-		if (area_id == 3)
-			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
-						   V_WIN2_MST3_EN(0));
-		break;
-	case 3:
-		if (area_id == 0)
-			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
-						   V_WIN3_MST0_EN(0));
-		if (area_id == 1)
-			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
-						   V_WIN3_MST1_EN(0));
-		if (area_id == 2)
-			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
-						   V_WIN3_MST2_EN(0));
-		if (area_id == 3)
-			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
-						   V_WIN3_MST3_EN(0));
-		break;
-	case 4:
-		area_status = vop_read_bit(vop_dev, HWC_CTRL0, V_HWC_EN(0));
-		break;
-	default:
-		pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",
-		       __func__, win_id, area_id);
-		break;
-	}
-
-	state = (area_status > 0) ? 1 : 0;
-	return state;
-}
-
-static int vop_get_area_num(struct rk_lcdc_driver *dev_drv,
-			    unsigned int *area_support)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	area_support[0] = 1;
-	area_support[1] = 1;
-
-	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-		area_support[2] = 4;
-		area_support[3] = 4;
-	}
-
-	return 0;
-}
-
-/*overlay will be do at regupdate*/
-static int vop_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap, bool set)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	int i, ovl = 0;
-	u64 val;
-	int z_order_num = 0;
-	int layer0_sel = 0, layer1_sel = 1, layer2_sel = 2, layer3_sel = 3;
-
-	if (swap == 0) {
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			win = dev_drv->win[i];
-			if (win->state == 1)
-				z_order_num++;
-		}
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			win = dev_drv->win[i];
-			if (win->state == 0)
-				win->z_order = z_order_num++;
-			switch (win->z_order) {
-			case 0:
-				layer0_sel = win->id;
-				break;
-			case 1:
-				layer1_sel = win->id;
-				break;
-			case 2:
-				layer2_sel = win->id;
-				break;
-			case 3:
-				layer3_sel = win->id;
-				break;
-			default:
-				break;
-			}
-		}
-	} else {
-		layer0_sel = swap % 10;
-		layer1_sel = swap / 10 % 10;
-		layer2_sel = swap / 100 % 10;
-		layer3_sel = swap / 1000;
-	}
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		if (set) {
-			val = V_DSP_LAYER0_SEL(layer0_sel) |
-			    V_DSP_LAYER1_SEL(layer1_sel) |
-			    V_DSP_LAYER2_SEL(layer2_sel) |
-			    V_DSP_LAYER3_SEL(layer3_sel);
-			vop_msk_reg(vop_dev, DSP_CTRL1, val);
-		} else {
-			layer0_sel = vop_read_bit(vop_dev, DSP_CTRL1,
-						  V_DSP_LAYER0_SEL(0));
-			layer1_sel = vop_read_bit(vop_dev, DSP_CTRL1,
-						  V_DSP_LAYER1_SEL(0));
-			layer2_sel = vop_read_bit(vop_dev, DSP_CTRL1,
-						  V_DSP_LAYER2_SEL(0));
-			layer3_sel = vop_read_bit(vop_dev, DSP_CTRL1,
-						  V_DSP_LAYER3_SEL(0));
-			ovl = layer3_sel * 1000 + layer2_sel * 100 +
-			    layer1_sel * 10 + layer0_sel;
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return ovl;
-}
-
-static char *vop_format_to_string(int format, char *fmt)
-{
-	if (!fmt)
-		return NULL;
-
-	switch (format) {
-	case 0:
-		strcpy(fmt, "ARGB888");
-		break;
-	case 1:
-		strcpy(fmt, "RGB888");
-		break;
-	case 2:
-		strcpy(fmt, "RGB565");
-		break;
-	case 4:
-		strcpy(fmt, "YCbCr420");
-		break;
-	case 5:
-		strcpy(fmt, "YCbCr422");
-		break;
-	case 6:
-		strcpy(fmt, "YCbCr444");
-	case 8:
-		strcpy(fmt, "YUYV422");
-		break;
-	case 9:
-		strcpy(fmt, "YUYV420");
-		break;
-	case 10:
-		strcpy(fmt, "UYVY422");
-		break;
-	case 11:
-		strcpy(fmt, "UYVY420");
-		break;
-	default:
-		strcpy(fmt, "invalid\n");
-		break;
-	}
-	return fmt;
-}
-
-static ssize_t vop_get_disp_info(struct rk_lcdc_driver *dev_drv,
-				 char *buf, int win_id)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u32 h_pw_bp = hsync_len + left_margin;
-	u32 v_pw_bp = vsync_len + upper_margin;
-	u32 fmt_id;
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char format_w2_0[9] = "NULL";
-	char format_w2_1[9] = "NULL";
-	char format_w2_2[9] = "NULL";
-	char format_w2_3[9] = "NULL";
-	char format_w3_0[9] = "NULL";
-	char format_w3_1[9] = "NULL";
-	char format_w3_2[9] = "NULL";
-	char format_w3_3[9] = "NULL";
-	char dsp_buf[100];
-	u32 win_ctrl, zorder, vir_info, act_info, dsp_info, dsp_st;
-	u32 y_factor, uv_factor;
-	u8 layer0_sel, layer1_sel, layer2_sel, layer3_sel;
-	u8 w0_state, w1_state, w2_state, w3_state;
-	u8 w2_0_state, w2_1_state, w2_2_state, w2_3_state;
-	u8 w3_0_state, w3_1_state, w3_2_state, w3_3_state;
-
-	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
-	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
-	u32 w1_vir_y, w1_vir_uv, w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y;
-	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
-	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
-	u32 w1_y_h_fac, w1_y_v_fac, w1_uv_h_fac, w1_uv_v_fac;
-
-	u32 w2_0_vir_y, w2_1_vir_y, w2_2_vir_y, w2_3_vir_y;
-	u32 w2_0_dsp_x, w2_1_dsp_x, w2_2_dsp_x, w2_3_dsp_x;
-	u32 w2_0_dsp_y, w2_1_dsp_y, w2_2_dsp_y, w2_3_dsp_y;
-	u32 w2_0_st_x = h_pw_bp, w2_1_st_x = h_pw_bp;
-	u32 w2_2_st_x = h_pw_bp, w2_3_st_x = h_pw_bp;
-	u32 w2_0_st_y = v_pw_bp, w2_1_st_y = v_pw_bp;
-	u32 w2_2_st_y = v_pw_bp, w2_3_st_y = v_pw_bp;
-
-	u32 w3_0_vir_y, w3_1_vir_y, w3_2_vir_y, w3_3_vir_y;
-	u32 w3_0_dsp_x, w3_1_dsp_x, w3_2_dsp_x, w3_3_dsp_x;
-	u32 w3_0_dsp_y, w3_1_dsp_y, w3_2_dsp_y, w3_3_dsp_y;
-	u32 w3_0_st_x = h_pw_bp, w3_1_st_x = h_pw_bp;
-	u32 w3_2_st_x = h_pw_bp, w3_3_st_x = h_pw_bp;
-	u32 w3_0_st_y = v_pw_bp, w3_1_st_y = v_pw_bp;
-	u32 w3_2_st_y = v_pw_bp, w3_3_st_y = v_pw_bp;
-	u32 dclk_freq;
-	int size = 0;
-
-	dclk_freq = screen->mode.pixclock;
-	/*vop_reg_dump(dev_drv); */
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		zorder = vop_readl(vop_dev, DSP_CTRL1);
-		layer0_sel = (zorder & MASK(DSP_LAYER0_SEL)) >> 8;
-		layer1_sel = (zorder & MASK(DSP_LAYER1_SEL)) >> 10;
-		layer2_sel = (zorder & MASK(DSP_LAYER2_SEL)) >> 12;
-		layer3_sel = (zorder & MASK(DSP_LAYER3_SEL)) >> 14;
-		/* WIN0 */
-		win_ctrl = vop_readl(vop_dev, WIN0_CTRL0);
-		w0_state = win_ctrl & MASK(WIN0_EN);
-		fmt_id = (win_ctrl & MASK(WIN0_DATA_FMT)) >> 1;
-		fmt_id |= (win_ctrl & MASK(WIN0_YUYV)) >> 14; /* yuyv*/
-		vop_format_to_string(fmt_id, format_w0);
-		vir_info = vop_readl(vop_dev, WIN0_VIR);
-		act_info = vop_readl(vop_dev, WIN0_ACT_INFO);
-		dsp_info = vop_readl(vop_dev, WIN0_DSP_INFO);
-		dsp_st = vop_readl(vop_dev, WIN0_DSP_ST);
-		y_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_YRGB);
-		uv_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_CBR);
-		w0_vir_y = vir_info & MASK(WIN0_VIR_STRIDE);
-		w0_vir_uv = (vir_info & MASK(WIN0_VIR_STRIDE_UV)) >> 16;
-		w0_act_x = (act_info & MASK(WIN0_ACT_WIDTH)) + 1;
-		w0_act_y = ((act_info & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-		w0_dsp_x = (dsp_info & MASK(WIN0_DSP_WIDTH)) + 1;
-		w0_dsp_y = ((dsp_info & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
-		if (w0_state) {
-			w0_st_x = dsp_st & MASK(WIN0_DSP_XST);
-			w0_st_y = (dsp_st & MASK(WIN0_DSP_YST)) >> 16;
-		}
-		w0_y_h_fac = y_factor & MASK(WIN0_HS_FACTOR_YRGB);
-		w0_y_v_fac = (y_factor & MASK(WIN0_VS_FACTOR_YRGB)) >> 16;
-		w0_uv_h_fac = uv_factor & MASK(WIN0_HS_FACTOR_CBR);
-		w0_uv_v_fac = (uv_factor & MASK(WIN0_VS_FACTOR_CBR)) >> 16;
-
-		/* WIN1 */
-		win_ctrl = vop_readl(vop_dev, WIN1_CTRL0);
-		w1_state = win_ctrl & MASK(WIN1_EN);
-		fmt_id = (win_ctrl & MASK(WIN1_DATA_FMT)) >> 1;
-		fmt_id |= (win_ctrl & MASK(WIN1_YUYV)) >> 14; /* yuyv*/
-		vop_format_to_string(fmt_id, format_w1);
-		vir_info = vop_readl(vop_dev, WIN1_VIR);
-		act_info = vop_readl(vop_dev, WIN1_ACT_INFO);
-		dsp_info = vop_readl(vop_dev, WIN1_DSP_INFO);
-		dsp_st = vop_readl(vop_dev, WIN1_DSP_ST);
-		y_factor = vop_readl(vop_dev, WIN1_SCL_FACTOR_YRGB);
-		uv_factor = vop_readl(vop_dev, WIN1_SCL_FACTOR_CBR);
-		w1_vir_y = vir_info & MASK(WIN1_VIR_STRIDE);
-		w1_vir_uv = (vir_info & MASK(WIN1_VIR_STRIDE_UV)) >> 16;
-		w1_act_x = (act_info & MASK(WIN1_ACT_WIDTH)) + 1;
-		w1_act_y = ((act_info & MASK(WIN1_ACT_HEIGHT)) >> 16) + 1;
-		w1_dsp_x = (dsp_info & MASK(WIN1_DSP_WIDTH)) + 1;
-		w1_dsp_y = ((dsp_info & MASK(WIN1_DSP_HEIGHT)) >> 16) + 1;
-		if (w1_state) {
-			w1_st_x = dsp_st & MASK(WIN1_DSP_XST);
-			w1_st_y = (dsp_st & MASK(WIN1_DSP_YST)) >> 16;
-		}
-		w1_y_h_fac = y_factor & MASK(WIN1_HS_FACTOR_YRGB);
-		w1_y_v_fac = (y_factor & MASK(WIN1_VS_FACTOR_YRGB)) >> 16;
-		w1_uv_h_fac = uv_factor & MASK(WIN1_HS_FACTOR_CBR);
-		w1_uv_v_fac = (uv_factor & MASK(WIN1_VS_FACTOR_CBR)) >> 16;
-
-		/*WIN2 */
-		win_ctrl = vop_readl(vop_dev, WIN2_CTRL0);
-		w2_state = win_ctrl & MASK(WIN2_EN);
-		w2_0_state = (win_ctrl & 0x10) >> 4;
-		w2_1_state = (win_ctrl & 0x100) >> 8;
-		w2_2_state = (win_ctrl & 0x1000) >> 12;
-		w2_3_state = (win_ctrl & 0x10000) >> 16;
-		vir_info = vop_readl(vop_dev, WIN2_VIR0_1);
-		w2_0_vir_y = vir_info & MASK(WIN2_VIR_STRIDE0);
-		w2_1_vir_y = (vir_info & MASK(WIN2_VIR_STRIDE1)) >> 16;
-		vir_info = vop_readl(vop_dev, WIN2_VIR2_3);
-		w2_2_vir_y = vir_info & MASK(WIN2_VIR_STRIDE2);
-		w2_3_vir_y = (vir_info & MASK(WIN2_VIR_STRIDE3)) >> 16;
-
-		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT0)) >> 5;
-		vop_format_to_string(fmt_id, format_w2_0);
-		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT1)) >> 9;
-		vop_format_to_string(fmt_id, format_w2_1);
-		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT2)) >> 13;
-		vop_format_to_string(fmt_id, format_w2_2);
-		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT3)) >> 17;
-		vop_format_to_string(fmt_id, format_w2_3);
-
-		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO0);
-		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST0);
-		w2_0_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH0)) + 1;
-		w2_0_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT0)) >> 16) + 1;
-		if (w2_0_state) {
-			w2_0_st_x = dsp_st & MASK(WIN2_DSP_XST0);
-			w2_0_st_y = (dsp_st & MASK(WIN2_DSP_YST0)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO1);
-		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST1);
-		w2_1_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH1)) + 1;
-		w2_1_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT1)) >> 16) + 1;
-		if (w2_1_state) {
-			w2_1_st_x = dsp_st & MASK(WIN2_DSP_XST1);
-			w2_1_st_y = (dsp_st & MASK(WIN2_DSP_YST1)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO2);
-		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST2);
-		w2_2_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH2)) + 1;
-		w2_2_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT2)) >> 16) + 1;
-		if (w2_2_state) {
-			w2_2_st_x = dsp_st & MASK(WIN2_DSP_XST2);
-			w2_2_st_y = (dsp_st & MASK(WIN2_DSP_YST2)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO3);
-		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST3);
-		w2_3_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH3)) + 1;
-		w2_3_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT3)) >> 16) + 1;
-		if (w2_3_state) {
-			w2_3_st_x = dsp_st & MASK(WIN2_DSP_XST3);
-			w2_3_st_y = (dsp_st & MASK(WIN2_DSP_YST3)) >> 16;
-		}
-
-		/*WIN3 */
-		win_ctrl = vop_readl(vop_dev, WIN3_CTRL0);
-		w3_state = win_ctrl & MASK(WIN3_EN);
-		w3_0_state = (win_ctrl & 0x10) >> 4;
-		w3_1_state = (win_ctrl & 0x100) >> 8;
-		w3_2_state = (win_ctrl & 0x1000) >> 12;
-		w3_3_state = (win_ctrl & 0x10000) >> 16;
-		vir_info = vop_readl(vop_dev, WIN3_VIR0_1);
-		w3_0_vir_y = vir_info & MASK(WIN3_VIR_STRIDE0);
-		w3_1_vir_y = (vir_info & MASK(WIN3_VIR_STRIDE1)) >> 16;
-		vir_info = vop_readl(vop_dev, WIN3_VIR2_3);
-		w3_2_vir_y = vir_info & MASK(WIN3_VIR_STRIDE2);
-		w3_3_vir_y = (vir_info & MASK(WIN3_VIR_STRIDE3)) >> 16;
-
-		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT0)) >> 5;
-		vop_format_to_string(fmt_id, format_w3_0);
-		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT1)) >> 9;
-		vop_format_to_string(fmt_id, format_w3_1);
-		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT2)) >> 13;
-		vop_format_to_string(fmt_id, format_w3_2);
-		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT3)) >> 17;
-		vop_format_to_string(fmt_id, format_w3_3);
-
-		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO0);
-		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST0);
-		w3_0_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH0)) + 1;
-		w3_0_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT0)) >> 16) + 1;
-		if (w3_0_state) {
-			w3_0_st_x = dsp_st & MASK(WIN3_DSP_XST0);
-			w3_0_st_y = (dsp_st & MASK(WIN3_DSP_YST0)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO1);
-		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST1);
-		w3_1_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH1)) + 1;
-		w3_1_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT1)) >> 16) + 1;
-		if (w3_1_state) {
-			w3_1_st_x = dsp_st & MASK(WIN3_DSP_XST1);
-			w3_1_st_y = (dsp_st & MASK(WIN3_DSP_YST1)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO2);
-		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST2);
-		w3_2_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH2)) + 1;
-		w3_2_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT2)) >> 16) + 1;
-		if (w3_2_state) {
-			w3_2_st_x = dsp_st & MASK(WIN3_DSP_XST2);
-			w3_2_st_y = (dsp_st & MASK(WIN3_DSP_YST2)) >> 16;
-		}
-		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO3);
-		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST3);
-		w3_3_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH3)) + 1;
-		w3_3_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT3)) >> 16) + 1;
-		if (w3_3_state) {
-			w3_3_st_x = dsp_st & MASK(WIN3_DSP_XST3);
-			w3_3_st_y = (dsp_st & MASK(WIN3_DSP_YST3)) >> 16;
-		}
-	} else {
-		spin_unlock(&vop_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	size += snprintf(dsp_buf, 80,
-		"z-order:\n  win[%d]\n  win[%d]\n  win[%d]\n  win[%d]\n",
-		layer3_sel, layer2_sel, layer1_sel, layer0_sel);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/* win0 */
-	size += snprintf(dsp_buf, 80,
-		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
-		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
-		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
-		 w0_st_x - h_pw_bp, w0_st_y - v_pw_bp, w0_y_h_fac, w0_y_v_fac);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
-		 w0_uv_h_fac, w0_uv_v_fac, vop_readl(vop_dev, WIN0_YRGB_MST),
-		 vop_readl(vop_dev, WIN0_CBR_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/* win1 */
-	size += snprintf(dsp_buf, 80,
-		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
-		 w1_state, format_w1, w1_vir_y, w1_vir_uv);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
-		 w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
-		 w1_st_x - h_pw_bp, w1_st_y - v_pw_bp, w1_y_h_fac, w1_y_v_fac);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
-		 w1_uv_h_fac, w1_uv_v_fac, vop_readl(vop_dev, WIN1_YRGB_MST),
-		 vop_readl(vop_dev, WIN1_CBR_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*win2*/
-	size += snprintf(dsp_buf, 80,
-		 "win2:\n  state:%d\n",
-		 w2_state);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/*area 0*/
-	size += snprintf(dsp_buf, 80,
-		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_0_state, format_w2_0, w2_0_dsp_x, w2_0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_0_st_x - h_pw_bp, w2_0_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN2_MST0));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 1*/
-	size += snprintf(dsp_buf, 80,
-		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_1_state, format_w2_1, w2_1_dsp_x, w2_1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_1_st_x - h_pw_bp, w2_1_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN2_MST1));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 2*/
-	size += snprintf(dsp_buf, 80,
-		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_2_state, format_w2_2, w2_2_dsp_x, w2_2_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_2_st_x - h_pw_bp, w2_2_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN2_MST2));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 3*/
-	size += snprintf(dsp_buf, 80,
-		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_3_state, format_w2_3, w2_3_dsp_x, w2_3_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_3_st_x - h_pw_bp, w2_3_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN2_MST3));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*win3*/
-	size += snprintf(dsp_buf, 80,
-		 "win3:\n  state:%d\n",
-		 w3_state);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/*area 0*/
-	size += snprintf(dsp_buf, 80,
-		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_0_state, format_w3_0, w3_0_dsp_x, w3_0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_0_st_x - h_pw_bp, w3_0_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN3_MST0));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 1*/
-	size += snprintf(dsp_buf, 80,
-		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_1_state, format_w3_1, w3_1_dsp_x, w3_1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_1_st_x - h_pw_bp, w3_1_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN3_MST1));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 2*/
-	size += snprintf(dsp_buf, 80,
-		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_2_state, format_w3_2, w3_2_dsp_x, w3_2_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_2_st_x - h_pw_bp, w3_2_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN3_MST2));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 3*/
-	size += snprintf(dsp_buf, 80,
-		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_3_state, format_w3_3, w3_3_dsp_x, w3_3_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_3_st_x - h_pw_bp, w3_3_st_y - v_pw_bp,
-		 vop_readl(vop_dev, WIN3_MST3));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	return size;
-}
-
-static int vop_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps, bool set)
-{
-	struct vop_device *vop_dev =
-		container_of(dev_drv, struct vop_device, driver);
-	struct rk_fb_vsync *vsync = &dev_drv->vsync_info;
-	int step_fps, old_fps;
-	u32 h_total, v_total;
-	unsigned long dclk;
-	u64 val;
-	int ret;
-
-	dclk = clk_get_rate(vop_dev->dclk);
-
-	spin_lock(&vop_dev->reg_lock);
-
-	if (!vop_dev->clk_on) {
-		spin_unlock(&vop_dev->reg_lock);
-		return 0;
-	}
-
-	val = vop_readl(vop_dev, DSP_HTOTAL_HS_END);
-	h_total = (val & MASK(DSP_HTOTAL)) >> 16;
-
-	val = vop_readl(vop_dev, DSP_VTOTAL_VS_END);
-	v_total = (val & MASK(DSP_VTOTAL)) >> 16;
-
-	spin_unlock(&vop_dev->reg_lock);
-
-	old_fps = div_u64(dclk, v_total * h_total);
-
-	if (!set)
-		return old_fps;
-
-	/*
-	 * Direct change fps to dest fps would may screen flash,
-	 * Every frame change one step fps is safe, screen flash
-	 * disappear.
-	 */
-	step_fps = old_fps;
-	while (step_fps != fps) {
-		ktime_t timestamp = vsync->timestamp;
-
-		if (step_fps > fps)
-			step_fps--;
-		else
-			step_fps++;
-		spin_lock(&vop_dev->reg_lock);
-		if (!vop_dev->clk_on) {
-			spin_unlock(&vop_dev->reg_lock);
-			break;
-		}
-		h_total = div_u64(dclk, step_fps * v_total);
-		val = V_DSP_HTOTAL(h_total);
-		vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
-		vop_cfg_done(vop_dev);
-		spin_unlock(&vop_dev->reg_lock);
-
-		ret = wait_event_interruptible_timeout(vsync->wait,
-			!ktime_equal(timestamp, vsync->timestamp) &&
-			(vsync->active > 0 || vsync->irq_stop),
-			msecs_to_jiffies(50));
-	}
-
-	dev_info(dev_drv->dev, "%s:dclk:%lu, htotal=%d, vtatol=%d, fps:%d\n",
-		 __func__, dclk, h_total, v_total, fps);
-
-	return fps;
-}
-
-static int vop_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
-	dev_drv->fb4_win_id = order / 10000;
-	dev_drv->fb3_win_id = (order / 1000) % 10;
-	dev_drv->fb2_win_id = (order / 100) % 10;
-	dev_drv->fb1_win_id = (order / 10) % 10;
-	dev_drv->fb0_win_id = order % 10;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int vop_get_win_id(struct rk_lcdc_driver *dev_drv, const char *id)
-{
-	int win_id = 0;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
-		win_id = dev_drv->fb2_win_id;
-	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
-		win_id = dev_drv->fb3_win_id;
-	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
-		win_id = dev_drv->fb4_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int vop_config_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int i, fbdc_en = 0;
-	u64 val;
-	struct rk_lcdc_win *win = NULL;
-
-	spin_lock(&vop_dev->reg_lock);
-	vop_post_cfg(dev_drv);
-	vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(vop_dev->standby));
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		vop_alpha_cfg(dev_drv, i);
-		fbdc_en |= win->area[0].fbdc_en;
-		vop_dev->atv_layer_cnt &= ~(1 << win->id);
-		vop_dev->atv_layer_cnt |= (win->state << win->id);
-		if ((win->state == 0) && (win->last_state == 1)) {
-			switch (win->id) {
-			case 0:
-				val = V_WIN0_EN(0);
-				vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-				break;
-			case 1:
-				val = V_WIN1_EN(0);
-				vop_msk_reg(vop_dev, WIN1_CTRL0, val);
-				break;
-			case 2:
-				val = V_WIN2_EN(0) | V_WIN2_MST0_EN(0) |
-				    V_WIN2_MST1_EN(0) |
-				    V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
-				vop_msk_reg(vop_dev, WIN2_CTRL0, val);
-				break;
-			case 3:
-				val = V_WIN3_EN(0) | V_WIN3_MST0_EN(0) |
-				    V_WIN3_MST1_EN(0) |
-				    V_WIN3_MST2_EN(0) | V_WIN3_MST3_EN(0);
-				vop_msk_reg(vop_dev, WIN3_CTRL0, val);
-				break;
-			case 4:
-				val = V_HWC_EN(0);
-				vop_msk_reg(vop_dev, HWC_CTRL0, val);
-				break;
-			default:
-				break;
-			}
-		}
-		win->last_state = win->state;
-	}
-	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-		val = V_VOP_FBDC_EN(fbdc_en);
-		vop_msk_reg(vop_dev, AFBCD0_CTRL, val);
-	}
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-static int vop_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	spin_lock(&vop_dev->reg_lock);
-	vop_msk_reg(vop_dev, SYS_CTRL, V_DIRECT_PATH_EN(open));
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-static int vop_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = container_of(dev_drv,
-						    struct vop_device, driver);
-	spin_lock(&vop_dev->reg_lock);
-	vop_msk_reg(vop_dev, SYS_CTRL, V_DIRECT_PATH_LAYER_SEL(win_id));
-	vop_cfg_done(vop_dev);
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-static int vop_dpi_status(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	int ovl;
-
-	spin_lock(&vop_dev->reg_lock);
-	ovl = vop_read_bit(vop_dev, SYS_CTRL, V_DIRECT_PATH_EN(0));
-	spin_unlock(&vop_dev->reg_lock);
-	return ovl;
-}
-
-static int vop_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	if (enable)
-		enable_irq(vop_dev->irq);
-	else
-		disable_irq_nosync(vop_dev->irq);
-	return 0;
-}
-
-int vop_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u32 int_reg;
-	int ret;
-
-	if (vop_dev->clk_on && (!dev_drv->suspend_flag)) {
-		int_reg = vop_readl(vop_dev, INTR_STATUS0);
-		if (int_reg & INTR_LINE_FLAG0) {
-			vop_dev->driver.frame_time.last_framedone_t =
-			    vop_dev->driver.frame_time.framedone_t;
-			vop_dev->driver.frame_time.framedone_t = cpu_clock(0);
-			vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_LINE_FLAG0,
-					INTR_LINE_FLAG0);
-			ret = RK_LF_STATUS_FC;
-		} else {
-			ret = RK_LF_STATUS_FR;
-		}
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int vop_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-			    unsigned int dsp_addr[][4])
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		dsp_addr[0][0] = vop_readl(vop_dev, WIN0_YRGB_MST);
-		dsp_addr[1][0] = vop_readl(vop_dev, WIN1_YRGB_MST);
-		dsp_addr[2][0] = vop_readl(vop_dev, WIN2_MST0);
-		dsp_addr[2][1] = vop_readl(vop_dev, WIN2_MST1);
-		dsp_addr[2][2] = vop_readl(vop_dev, WIN2_MST2);
-		dsp_addr[2][3] = vop_readl(vop_dev, WIN2_MST3);
-		dsp_addr[3][0] = vop_readl(vop_dev, WIN3_MST0);
-		dsp_addr[3][1] = vop_readl(vop_dev, WIN3_MST1);
-		dsp_addr[3][2] = vop_readl(vop_dev, WIN3_MST2);
-		dsp_addr[3][3] = vop_readl(vop_dev, WIN3_MST3);
-		dsp_addr[4][0] = vop_readl(vop_dev, HWC_MST);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-
-int vop_update_pwm(int bl_pwm_period, int bl_pwm_duty)
-{
-	/*
-	 * TODO:
-	 * pwm_period_hpr = bl_pwm_period;
-	 * pwm_duty_lpr = bl_pwm_duty;
-	 * pr_info("bl_pwm_period_hpr = 0x%x, bl_pwm_duty_lpr = 0x%x\n",
-	 * bl_pwm_period, bl_pwm_duty);
-	 */
-
-	return 0;
-}
-
-/*
- *  a:[-30~0]:
- *    sin_hue = sin(a)*256 +0x100;
- *    cos_hue = cos(a)*256;
- *  a:[0~30]
- *    sin_hue = sin(a)*256;
- *    cos_hue = cos(a)*256;
- */
-static int vop_get_bcsh_hue(struct rk_lcdc_driver *dev_drv, bcsh_hue_mode mode)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u32 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		val = vop_readl(vop_dev, BCSH_H);
-		switch (mode) {
-		case H_SIN:
-			val &= MASK(SIN_HUE);
-			break;
-		case H_COS:
-			val &= MASK(COS_HUE);
-			val >>= 16;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return val;
-}
-
-static int vop_set_dsp_cabc(struct rk_lcdc_driver *dev_drv, int mode,
-			    int calc, int up, int down, int global)
-{
-	struct vop_device *vop_dev =
-			container_of(dev_drv, struct vop_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 total_pixel, calc_pixel, stage_up, stage_down;
-	u32 pixel_num, global_dn;
-	u64 val = 0;
-	ktime_t timestamp;
-	int ret = 0;
-
-	if (!vop_dev->cabc_lut_addr_base) {
-		pr_err("vop chip[%d] not supoort cabc\n", VOP_CHIP(vop_dev));
-		return 0;
-	}
-
-	if (!screen->cabc_lut) {
-		pr_err("screen cabc lut not config, so not open cabc\n");
-		return 0;
-	}
-
-	if (!mode) {
-		if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-			calc = 0;
-			up = 256;
-			down = 255;
-			global = 0;
-		} else {
-			spin_lock(&vop_dev->reg_lock);
-			if (vop_dev->clk_on) {
-				vop_msk_reg(vop_dev, CABC_CTRL0,
-					    V_CABC_EN(0) | V_CABC_HANDLE_EN(0));
-				vop_cfg_done(vop_dev);
-			}
-			pr_info("mode = 0, close cabc\n");
-			spin_unlock(&vop_dev->reg_lock);
-			return 0;
-		}
-	}
-
-	total_pixel = screen->mode.xres * screen->mode.yres;
-	pixel_num = 1000 - calc;
-	calc_pixel = (total_pixel * pixel_num) / 1000;
-	stage_up = up;
-	stage_down = down;
-	global_dn = global;
-	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
-		mode, calc, stage_up, stage_down, global_dn);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		val = V_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
-			V_CABC_CALC_PIXEL_NUM(calc_pixel);
-		vop_msk_reg(vop_dev, CABC_CTRL0, val);
-
-		val = V_CABC_LUT_EN(1) | V_CABC_TOTAL_NUM(total_pixel);
-		vop_msk_reg(vop_dev, CABC_CTRL1, val);
-
-		val = V_CABC_STAGE_DOWN(stage_down) |
-			V_CABC_STAGE_UP(stage_up) |
-			V_CABC_STAGE_UP_MODE(0) | V_MAX_SCALE_CFG_VALUE(1) |
-			V_MAX_SCALE_CFG_ENABLE(0);
-		vop_msk_reg(vop_dev, CABC_CTRL2, val);
-
-		val = V_CABC_GLOBAL_DN(global_dn) |
-			V_CABC_GLOBAL_DN_LIMIT_EN(1);
-		vop_msk_reg(vop_dev, CABC_CTRL3, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	timestamp = dev_drv->vsync_info.timestamp;
-	ret = wait_event_interruptible_timeout(dev_drv->vsync_info.wait,
-			!ktime_equal(timestamp, dev_drv->vsync_info.timestamp),
-			msecs_to_jiffies(50));
-	if (ret < 0)
-		return ret;
-	else if (ret == 0)
-		pr_err("%s wait vsync time out\n", __func__);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		val = V_CABC_EN(1) | V_CABC_HANDLE_EN(1);
-		vop_msk_reg(vop_dev, CABC_CTRL0, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-			    int sin_hue, int cos_hue)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u64 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		val = V_SIN_HUE(sin_hue) | V_COS_HUE(cos_hue);
-		vop_msk_reg(vop_dev, BCSH_H, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-			    bcsh_bcs_mode mode, int value)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u64 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		switch (mode) {
-		case BRIGHTNESS:
-			/*from 0 to 255,typical is 128 */
-			if (value < 0x80)
-				value += 0x80;
-			else if (value >= 0x80)
-				value = value - 0x80;
-			val = V_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-			/*from 0 to 510,typical is 256 */
-			val = V_CONTRAST(value);
-			break;
-		case SAT_CON:
-			/*from 0 to 1015,typical is 256 */
-			val = V_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		vop_msk_reg(vop_dev, BCSH_BCS, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return val;
-}
-
-static int vop_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv, bcsh_bcs_mode mode)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u64 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		val = vop_readl(vop_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= MASK(BRIGHTNESS);
-			if (val > 0x80)
-				val -= 0x80;
-			else
-				val += 0x80;
-			break;
-		case CONTRAST:
-			val &= MASK(CONTRAST);
-			val >>= 8;
-			break;
-		case SAT_CON:
-			val &= MASK(SAT_CON);
-			val >>= 20;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	return val;
-}
-
-static int vop_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (vop_dev->clk_on) {
-		if (open) {
-			vop_writel(vop_dev, BCSH_COLOR_BAR, 0x1);
-			vop_writel(vop_dev, BCSH_BCS, 0xd0010000);
-			vop_writel(vop_dev, BCSH_H, 0x01000000);
-			dev_drv->bcsh.enable = 1;
-		} else {
-			vop_msk_reg(vop_dev, BCSH_COLOR_BAR, V_BCSH_EN(0));
-			dev_drv->bcsh.enable = 0;
-		}
-		vop_bcsh_path_sel(dev_drv);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
-{
-	if (!enable || !dev_drv->bcsh.enable) {
-		vop_open_bcsh(dev_drv, false);
-		return 0;
-	}
-
-	if (dev_drv->bcsh.brightness <= 255 ||
-	    dev_drv->bcsh.contrast <= 510 ||
-	    dev_drv->bcsh.sat_con <= 1015 ||
-	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
-		vop_open_bcsh(dev_drv, true);
-		if (dev_drv->bcsh.brightness <= 255)
-			vop_set_bcsh_bcs(dev_drv, BRIGHTNESS,
-					 dev_drv->bcsh.brightness);
-		if (dev_drv->bcsh.contrast <= 510)
-			vop_set_bcsh_bcs(dev_drv, CONTRAST,
-					 dev_drv->bcsh.contrast);
-		if (dev_drv->bcsh.sat_con <= 1015)
-			vop_set_bcsh_bcs(dev_drv, SAT_CON,
-					 dev_drv->bcsh.sat_con);
-		if (dev_drv->bcsh.sin_hue <= 511 &&
-		    dev_drv->bcsh.cos_hue <= 511)
-			vop_set_bcsh_hue(dev_drv, dev_drv->bcsh.sin_hue,
-					 dev_drv->bcsh.cos_hue);
-	}
-
-	return 0;
-}
-
-static int __maybe_unused
-vop_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (enable) {
-		spin_lock(&vop_dev->reg_lock);
-		if (likely(vop_dev->clk_on)) {
-			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(1));
-			vop_cfg_done(vop_dev);
-		}
-		spin_unlock(&vop_dev->reg_lock);
-	} else {
-		spin_lock(&vop_dev->reg_lock);
-		if (likely(vop_dev->clk_on)) {
-			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(0));
-
-			vop_cfg_done(vop_dev);
-		}
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int vop_backlight_close(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	vop_get_backlight_device(dev_drv);
-
-	if (enable) {
-		/* close the backlight */
-		if (vop_dev->backlight) {
-			vop_dev->backlight->props.power = FB_BLANK_POWERDOWN;
-			backlight_update_status(vop_dev->backlight);
-		}
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-			dev_drv->trsm_ops->disable();
-	} else {
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-			dev_drv->trsm_ops->enable();
-		msleep(100);
-		/* open the backlight */
-		if (vop_dev->backlight) {
-			vop_dev->backlight->props.power = FB_BLANK_UNBLANK;
-			backlight_update_status(vop_dev->backlight);
-		}
-	}
-
-	return 0;
-}
-
-static int vop_set_overscan(struct rk_lcdc_driver *dev_drv,
-			    struct overscan *overscan)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-	/*vop_post_cfg(dev_drv);*/
-
-	return 0;
-}
-
-static int vop_extern_func(struct rk_lcdc_driver *dev_drv, int cmd)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-	u64 val;
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-
-	switch (cmd) {
-	case UPDATE_CABC_PWM:
-		vop_cfg_done(vop_dev);
-		break;
-	case SET_DSP_MIRROR:
-		val = V_DSP_X_MIR_EN(dev_drv->cur_screen->x_mirror) |
-			V_DSP_Y_MIR_EN(dev_drv->cur_screen->y_mirror);
-		vop_msk_reg(vop_dev, DSP_CTRL0, val);
-		pr_info("%s: xmirror: %d, ymirror: %d\n",
-			__func__, dev_drv->cur_screen->x_mirror,
-			dev_drv->cur_screen->y_mirror);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open = vop_open,
-	.win_direct_en = vop_win_direct_en,
-	.load_screen = vop_load_screen,
-	.get_dspbuf_info = vop_get_dspbuf_info,
-	.post_dspbuf = vop_post_dspbuf,
-	.set_par = vop_set_par,
-	.pan_display = vop_pan_display,
-	.set_wb = vop_set_writeback,
-	.direct_set_addr = vop_direct_set_win_addr,
-	/*.lcdc_reg_update = vop_reg_update,*/
-	.blank = vop_blank,
-	.ioctl = vop_ioctl,
-	.suspend = vop_early_suspend,
-	.resume = vop_early_resume,
-	.get_win_state = vop_get_win_state,
-	.area_support_num = vop_get_area_num,
-	.ovl_mgr = vop_ovl_mgr,
-	.get_disp_info = vop_get_disp_info,
-	.fps_mgr = vop_fps_mgr,
-	.fb_get_win_id = vop_get_win_id,
-	.fb_win_remap = vop_fb_win_remap,
-	.poll_vblank = vop_poll_vblank,
-	.dpi_open = vop_dpi_open,
-	.dpi_win_sel = vop_dpi_win_sel,
-	.dpi_status = vop_dpi_status,
-	.get_dsp_addr = vop_get_dsp_addr,
-	.set_dsp_lut = vop_set_lut,
-	.set_cabc_lut = vop_set_cabc,
-	.set_dsp_cabc = vop_set_dsp_cabc,
-	.set_dsp_bcsh_hue = vop_set_bcsh_hue,
-	.set_dsp_bcsh_bcs = vop_set_bcsh_bcs,
-	.get_dsp_bcsh_hue = vop_get_bcsh_hue,
-	.get_dsp_bcsh_bcs = vop_get_bcsh_bcs,
-	.open_bcsh = vop_open_bcsh,
-	.dump_reg = vop_reg_dump,
-	.cfg_done = vop_config_done,
-	.set_irq_to_cpu = vop_set_irq_to_cpu,
-	/*.dsp_black = vop_dsp_black,*/
-	.backlight_close = vop_backlight_close,
-	.mmu_en    = vop_mmu_en,
-	.set_overscan   = vop_set_overscan,
-	.extern_func	= vop_extern_func,
-};
-
-static irqreturn_t vop_isr(int irq, void *dev_id)
-{
-	struct vop_device *vop_dev = (struct vop_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 intr_status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&vop_dev->irq_lock, flags);
-
-	intr_status = vop_readl(vop_dev, INTR_STATUS0);
-	vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, intr_status);
-
-	spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
-	/* This is expected for vop iommu irqs, since the irq is shared */
-	if (!intr_status)
-		return IRQ_NONE;
-
-	if (intr_status & INTR_FS) {
-		timestamp = ktime_get();
-		if (vop_dev->driver.wb_data.state) {
-			u32 wb_status;
-
-			spin_lock_irqsave(&vop_dev->irq_lock, flags);
-			wb_status = vop_read_bit(vop_dev, WB_CTRL0, V_WB_EN(0));
-
-			if (wb_status)
-				vop_clr_bit(vop_dev, WB_CTRL0, V_WB_EN(0));
-
-			vop_cfg_done(vop_dev);
-			vop_dev->driver.wb_data.state = 0;
-			spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
-		}
-		vop_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&vop_dev->driver.vsync_info.wait);
-		intr_status &= ~INTR_FS;
-	}
-
-	if (intr_status & INTR_LINE_FLAG0)
-		intr_status &= ~INTR_LINE_FLAG0;
-
-	if (intr_status & INTR_LINE_FLAG1)
-		intr_status &= ~INTR_LINE_FLAG1;
-
-	if (intr_status & INTR_FS_NEW)
-		intr_status &= ~INTR_FS_NEW;
-
-	if (intr_status & INTR_BUS_ERROR) {
-		intr_status &= ~INTR_BUS_ERROR;
-		dev_warn_ratelimited(vop_dev->dev, "bus error!");
-	}
-
-	if (intr_status & INTR_WIN0_EMPTY) {
-		intr_status &= ~INTR_WIN0_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr win0 empty!");
-	}
-
-	if (intr_status & INTR_WIN1_EMPTY) {
-		intr_status &= ~INTR_WIN1_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr win1 empty!");
-	}
-
-	if (intr_status & INTR_HWC_EMPTY) {
-		intr_status &= ~INTR_HWC_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr hwc empty!");
-	}
-
-	if (intr_status & INTR_POST_BUF_EMPTY) {
-		intr_status &= ~INTR_POST_BUF_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr post buf empty!");
-	}
-
-	if (intr_status)
-		dev_err(vop_dev->dev, "Unknown VOP IRQs: %#02x\n", intr_status);
-
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_PM)
-static int vop_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int vop_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define vop_suspend NULL
-#define vop_resume  NULL
-#endif
-
-static int vop_parse_dt(struct vop_device *vop_dev)
-{
-	struct device_node *np = vop_dev->dev->of_node;
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,prop", &val))
-		vop_dev->prop = PRMRY;	/*default set it as primary */
-	else
-		vop_dev->prop = val;
-
-	if (of_property_read_u32(np, "rockchip,mirror", &val))
-		dev_drv->rotate_mode = NO_MIRROR;
-	else
-		dev_drv->rotate_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
-		dev_drv->cabc_mode = 0;	/* default set close cabc */
-	else
-		dev_drv->cabc_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-		/*default set it as 3.xv power supply */
-		vop_dev->pwr18 = false;
-	else
-		vop_dev->pwr18 = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
-	else
-		dev_drv->fb_win_map = val;
-
-	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
-		dev_drv->bcsh.enable = false;
-	else
-		dev_drv->bcsh.enable = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,brightness", &val))
-		dev_drv->bcsh.brightness = 0xffff;
-	else
-		dev_drv->bcsh.brightness = val;
-
-	if (of_property_read_u32(np, "rockchip,contrast", &val))
-		dev_drv->bcsh.contrast = 0xffff;
-	else
-		dev_drv->bcsh.contrast = val;
-
-	if (of_property_read_u32(np, "rockchip,sat-con", &val))
-		dev_drv->bcsh.sat_con = 0xffff;
-	else
-		dev_drv->bcsh.sat_con = val;
-
-	if (of_property_read_u32(np, "rockchip,hue", &val)) {
-		dev_drv->bcsh.sin_hue = 0xffff;
-		dev_drv->bcsh.cos_hue = 0xffff;
-	} else {
-		dev_drv->bcsh.sin_hue = val & 0xff;
-		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
-	}
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		dev_drv->iommu_enabled = 0;
-	else
-		dev_drv->iommu_enabled = val;
-
-	if (of_property_read_u32(np, "rockchip,dsp_mode", &val))
-		dev_drv->dsp_mode = DEFAULT_MODE;
-	else
-		dev_drv->dsp_mode = val;
-
-	return 0;
-}
-
-static struct platform_device *rk322x_pdev;
-
-int vop_register_dmc(void)
-{
-	struct platform_device *pdev = rk322x_pdev;
-	struct vop_device *vop_dev;
-	struct device *dev = &pdev->dev;
-	struct devfreq *devfreq;
-	struct devfreq_event_dev *event_dev;
-
-	if (!pdev)
-		return -ENODEV;
-
-	vop_dev = platform_get_drvdata(pdev);;
-	if (!vop_dev)
-		return -ENODEV;
-
-	dev = &pdev->dev;
-	devfreq = devfreq_get_devfreq_by_phandle(dev, 0);
-	if (IS_ERR(devfreq)) {
-		dev_err(vop_dev->dev, "fail to get devfreq for dmc\n");
-		return -ENODEV;
-	}
-
-	vop_dev->devfreq = devfreq;
-	vop_dev->dmc_nb.notifier_call = dmc_notify;
-	devfreq_register_notifier(vop_dev->devfreq, &vop_dev->dmc_nb,
-				  DEVFREQ_TRANSITION_NOTIFIER);
-
-	event_dev = devfreq_event_get_edev_by_phandle(vop_dev->devfreq->dev.parent,
-						      0);
-	if (IS_ERR(event_dev)) {
-		dev_err(vop_dev->dev, "fail to get edev for dmc\n");
-		return -ENODEV;
-	}
-
-	vop_dev->devfreq_event_dev = event_dev;
-	return 0;
-}
-
-static int vop_wms_refresh(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev =
-	    container_of(dev_drv, struct vop_device, driver);
-
-	if (unlikely(!vop_dev->clk_on)) {
-		dev_info_ratelimited(vop_dev->dev, "%s,clk_on = %d\n",
-				     __func__, vop_dev->clk_on);
-		return 0;
-	}
-	vop_msk_reg_nobak(vop_dev, SYS_CTRL, V_EDPI_WMS_FS(1));
-	vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(0));
-	vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(1));
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->refresh)
-		dev_drv->trsm_ops->refresh(0, 0, dev_drv->cur_screen->mode.xres,
-					   dev_drv->cur_screen->mode.yres);
-
-	return 0;
-}
-
-static irqreturn_t te_irq_handle(int irq, void *dev_id)
-{
-	struct rk_lcdc_driver *dev_drv  = (struct rk_lcdc_driver *)dev_id;
-
-	vop_wms_refresh(dev_drv);
-
-	return IRQ_HANDLED;
-}
-
-static int vop_probe(struct platform_device *pdev)
-{
-	struct vop_device *vop_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	const struct of_device_id *of_id;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct device_node *np = pdev->dev.of_node;
-	int prop;
-	int ret = 0;
-	int te_pin;
-
-	/* if the primary lcdc has not registered ,the extend
-	 * lcdc register later
-	 */
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		if (!is_prmry_rk_lcdc_registered())
-			return -EPROBE_DEFER;
-	}
-	vop_dev = devm_kzalloc(dev, sizeof(struct vop_device), GFP_KERNEL);
-	if (!vop_dev)
-		return -ENOMEM;
-	of_id = of_match_device(vop_dt_ids, dev);
-	vop_dev->data = of_id->data;
-	if (VOP_CHIP(vop_dev) != VOP_RK322X && VOP_CHIP(vop_dev) != VOP_RK3399)
-		return -ENODEV;
-	platform_set_drvdata(pdev, vop_dev);
-	vop_dev->dev = dev;
-	vop_parse_dt(vop_dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-	/* enable power domain */
-	pm_runtime_enable(dev);
-#endif
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	vop_dev->reg_phy_base = res->start;
-	vop_dev->len = resource_size(res);
-	vop_dev->regs = devm_ioremap(&pdev->dev, res->start,
-				     resource_size(res));
-	if (IS_ERR(vop_dev->regs))
-		return PTR_ERR(vop_dev->regs);
-
-	dev_info(dev, "vop_dev->regs=0x%lx\n", (long)vop_dev->regs);
-
-	vop_dev->regsbak = devm_kzalloc(dev, vop_dev->len, GFP_KERNEL);
-	if (IS_ERR(vop_dev->regsbak))
-		return PTR_ERR(vop_dev->regsbak);
-	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
-		vop_dev->dsp_lut_addr_base = vop_dev->regs + GAMMA_LUT_ADDR;
-		vop_dev->cabc_lut_addr_base = vop_dev->regs +
-						CABC_GAMMA_LUT_ADDR;
-	}
-	vop_dev->grf_base =
-		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-	if (IS_ERR(vop_dev->grf_base)) {
-		dev_err(&pdev->dev, "can't find lcdc grf property\n");
-		vop_dev->grf_base = NULL;
-	}
-
-	vop_dev->id = vop_get_id(vop_dev, vop_dev->reg_phy_base);
-	dev_set_name(vop_dev->dev, "vop%d", vop_dev->id);
-	dev_drv = &vop_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = prop;
-	dev_drv->id = vop_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = vop_dev->data->n_wins;
-	dev_drv->reserved_fb = 0;
-	spin_lock_init(&vop_dev->reg_lock);
-	spin_lock_init(&vop_dev->irq_lock);
-	vop_dev->irq = platform_get_irq(pdev, 0);
-	if (vop_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			vop_dev->id);
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(dev, vop_dev->irq, vop_isr,
-			       IRQF_SHARED, dev_name(dev), vop_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			vop_dev->irq, ret);
-		return ret;
-	}
-	if (dev_drv->iommu_enabled) {
-		if (VOP_CHIP(vop_dev) == VOP_RK322X) {
-			strcpy(dev_drv->mmu_dts_name,
-			       VOP_IOMMU_COMPATIBLE_NAME);
-		} else {
-			if (vop_dev->id == 0)
-				strcpy(dev_drv->mmu_dts_name,
-				       VOPB_IOMMU_COMPATIBLE_NAME);
-			else
-				strcpy(dev_drv->mmu_dts_name,
-				       VOPL_IOMMU_COMPATIBLE_NAME);
-		}
-	}
-	if (VOP_CHIP(vop_dev) == VOP_RK3399)
-		dev_drv->property.feature |= SUPPORT_WRITE_BACK | SUPPORT_AFBDC;
-	dev_drv->property.feature |= SUPPORT_VOP_IDENTIFY |
-					SUPPORT_YUV420_OUTPUT;
-	dev_drv->property.max_output_x = 4096;
-	dev_drv->property.max_output_y = 2160;
-
-	init_waitqueue_head(&vop_dev->wait_vop_switch_queue);
-	vop_dev->vop_switch_status = 0;
-	init_waitqueue_head(&vop_dev->wait_dmc_queue);
-	vop_dev->dmc_in_process = 0;
-
-	ret = rk_fb_register(dev_drv, vop_dev->data->win, vop_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", vop_dev->id);
-		return ret;
-	}
-
-	if ((VOP_CHIP(vop_dev) == VOP_RK3399) && (vop_dev->id == 1)) {
-		dev_drv->win[1]->property.feature &= ~SUPPORT_HW_EXIST;
-		dev_drv->win[3]->property.feature &= ~SUPPORT_HW_EXIST;
-	}
-
-	vop_dev->screen = dev_drv->screen0;
-	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
-		 vop_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	rk322x_pdev = pdev;
-
-	if (dev_drv->cur_screen->refresh_mode == SCREEN_CMD_MODE) {
-		te_pin = of_get_named_gpio_flags(np, "te-gpio", 0, NULL);
-		if (IS_ERR_VALUE(te_pin)) {
-			dev_err(dev, "define te pin for cmd mode!\n");
-			return 0;
-		}
-		ret = devm_gpio_request(dev, te_pin, "vop-te-gpio");
-		if (ret) {
-			dev_err(dev, "request gpio %d failed\n", te_pin);
-			return 0;
-		}
-		gpio_direction_input(te_pin);
-		dev_drv->te_irq = gpio_to_irq(te_pin);
-		ret = devm_request_threaded_irq(dev,
-						dev_drv->te_irq,
-						NULL, te_irq_handle,
-						IRQ_TYPE_EDGE_FALLING | IRQF_ONESHOT,
-						"te_irq", dev_drv);
-		if (ret < 0)
-			dev_err(dev, "request te irq failed, ret: %d\n", ret);
-	}
-	return 0;
-}
-
-static int vop_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void vop_shutdown(struct platform_device *pdev)
-{
-	struct vop_device *vop_dev = platform_get_drvdata(pdev);
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-
-	dev_drv->suspend_flag = 1;
-	dev_drv->shutdown_flag = 1;
-	/* ensure suspend_flag take effect on multi process */
-	smp_wmb();
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-	kthread_stop(dev_drv->update_regs_thread);
-	vop_deint(vop_dev);
-
-	vop_clk_disable(vop_dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-	pm_runtime_disable(vop_dev->dev);
-#endif
-	rk_disp_pwr_disable(dev_drv);
-}
-
-static struct platform_driver vop_driver = {
-	.probe = vop_probe,
-	.remove = vop_remove,
-	.driver = {
-		   .name = "rk322x-lcdc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(vop_dt_ids),
-		   },
-	.suspend = vop_suspend,
-	.resume = vop_resume,
-	.shutdown = vop_shutdown,
-};
-
-static int __init vop_module_init(void)
-{
-	return platform_driver_register(&vop_driver);
-}
-
-static void __exit vop_module_exit(void)
-{
-	platform_driver_unregister(&vop_driver);
-}
-
-fs_initcall(vop_module_init);
-module_exit(vop_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk322x_lcdc.h b/drivers/video/rockchip/lcdc/rk322x_lcdc.h
deleted file mode 100644
index 13e573c62ed4..000000000000
--- a/drivers/video/rockchip/lcdc/rk322x_lcdc.h
+++ /dev/null
@@ -1,1797 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK322X_LCDC_H_
-#define RK322X_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-#include<linux/mfd/syscon.h>
-#include<linux/regmap.h>
-
-#define VOP_INPUT_MAX_WIDTH 4096
-/*
- * Registers in this file
- * REG_CFG_DONE: Register config done flag
- * VERSION_INFO: Version for vop
- * SYS_CTRL: System control register0
- * SYS_CTRL1: System control register1
- * DSP_CTRL0: Display control register0
- * DSP_CTRL1: Display control register1
- * DSP_BG: Background color
- * MCU_CTRL: MCU mode control register
- * WB_CTRL0: write back ctrl0
- * WB_CTRL1: write back ctrl1
- * WB_YRGB_MST: write back yrgb mst
- * WB_CBR_MST: write back cbr mst
- * WIN0_CTRL0: Win0 ctrl register0
- * WIN0_CTRL1: Win0 ctrl register1
- * WIN0_COLOR_KEY: Win0 color key register
- * WIN0_VIR: Win0 virtual stride
- * WIN0_YRGB_MST: Win0 YRGB memory start address
- * WIN0_CBR_MST: Win0 Cbr memory start address
- * WIN0_ACT_INFO: Win0 active window width/height
- * WIN0_DSP_INFO: Win0 display width/height on panel
- * WIN0_DSP_ST: Win0 display start point on panel
- * WIN0_SCL_FACTOR_YRGB: Win0 YRGB scaling factor
- * WIN0_SCL_FACTOR_CBR: Win0 Cbr scaling factor
- * WIN0_SCL_OFFSET: Win0 scaling start point offset
- * WIN0_SRC_ALPHA_CTRL: Win0 alpha source control register
- * WIN0_DST_ALPHA_CTRL: Win0 alpha destination control register
- * WIN0_FADING_CTRL: Win0 fading contrl register
- * WIN0_CTRL2: Win0 ctrl register2
- * WIN1_CTRL0: Win1 ctrl register0
- * WIN1_CTRL1: Win1 ctrl register1
- * WIN1_COLOR_KEY: Win1 color key register
- * WIN1_VIR: win1 virtual stride
- * WIN1_YRGB_MST: Win1 YRGB memory start address
- * WIN1_CBR_MST: Win1 Cbr memory start address
- * WIN1_ACT_INFO: Win1 active window width/height
- * WIN1_DSP_INFO: Win1 display width/height on panel
- * WIN1_DSP_ST: Win1 display start point on panel
- * WIN1_SCL_FACTOR_YRGB: Win1 YRGB scaling factor
- * WIN1_SCL_FACTOR_CBR: Win1 Cbr scaling factor
- * WIN1_SCL_OFFSET: Win1 scaling start point offset
- * WIN1_SRC_ALPHA_CTRL: Win1 alpha source control register
- * WIN1_DST_ALPHA_CTRL: Win1 alpha destination control register
- * WIN1_FADING_CTRL: Win1 fading contrl register
- * WIN1_CTRL2: Win1 ctrl register2
- * WIN2_CTRL0: win2 ctrl register0
- * WIN2_CTRL1: win2 ctrl register1
- * WIN2_VIR0_1: Win2 virtual stride0 and virtaul stride1
- * WIN2_VIR2_3: Win2 virtual stride2 and virtaul stride3
- * WIN2_MST0: Win2 memory start address0
- * WIN2_DSP_INFO0: Win2 display width0/height0 on panel
- * WIN2_DSP_ST0: Win2 display start point0 on panel
- * WIN2_COLOR_KEY: Win2 color key register
- * WIN2_MST1: Win2 memory start address1
- * WIN2_DSP_INFO1: Win2 display width1/height1 on panel
- * WIN2_DSP_ST1: Win2 display start point1 on panel
- * WIN2_SRC_ALPHA_CTRL: Win2 alpha source control register
- * WIN2_MST2: Win2 memory start address2
- * WIN2_DSP_INFO2:  Win2 display width2/height2 on panel
- * WIN2_DSP_ST2: Win2 display start point2 on panel
- * WIN2_DST_ALPHA_CTRL: Win2 alpha destination control register
- * WIN2_MST3: Win2 memory start address3
- * WIN2_DSP_INFO3:  Win2 display width3/height3 on panel
- * WIN2_DSP_ST3: Win2 display start point3 on panel
- * WIN2_FADING_CTRL: Win2 fading contrl register
- * WIN3_CTRL0: Win3 ctrl register0
- * WIN3_CTRL1: Win3 ctrl register1
- * WIN3_VIR0_1: Win3 virtual stride0 and virtaul stride1
- * WIN3_VIR2_3: Win3 virtual stride2 and virtaul stride3
- * WIN3_MST0: Win3 memory start address0
- * WIN3_DSP_INFO0: Win3 display width0/height0 on panel
- * WIN3_DSP_ST0: Win3 display start point0 on panel
- * WIN3_COLOR_KEY: Win3 color key register
- * WIN3_MST1: Win3 memory start address1
- * WIN3_DSP_INFO1:  Win3 display width1/height1 on panel
- * WIN3_DSP_ST1: Win3 display start point1 on panel
- * WIN3_SRC_ALPHA_CTRL: Win3 alpha source control register
- * WIN3_MST2: Win3 memory start address2
- * WIN3_DSP_INFO2:  Win3 display width2/height2 on panel
- * WIN3_DSP_ST2: Win3 display start point2 on panel
- * WIN3_DST_ALPHA_CTRL: Win3 alpha destination control register
- * WIN3_MST3: Win3 memory start address3
- * WIN3_DSP_INFO3:  Win3 display width3/height3 on panel
- * WIN3_DSP_ST3: Win3 display start point3 on panel
- * WIN3_FADING_CTRL: Win3 fading contrl register
- * HWC_CTRL0: Hwc ctrl register0
- * HWC_CTRL1: Hwc ctrl register1
- * HWC_MST: Hwc memory start address
- * HWC_DSP_ST: Hwc display start point on panel
- * HWC_SRC_ALPHA_CTRL: Hwc alpha source control register
- * HWC_DST_ALPHA_CTRL: Hwc alpha destination control register
- * HWC_FADING_CTRL: Hwc fading contrl register
- * HWC_RESERVED1: Hwc reserved
- * POST_DSP_HACT_INFO: Post scaler down horizontal start and end
- * POST_DSP_VACT_INFO: Panel active horizontal scanning start point
- *                     and end point
- * POST_SCL_FACTOR_YRGB: Post yrgb scaling factor
- * POST_RESERVED: Post reserved
- * POST_SCL_CTRL: Post scaling start point offset
- * POST_DSP_VACT_INFO_F1: Panel active horizontal scanning start point
- *                        and end point F1
- * DSP_HTOTAL_HS_END: Panel scanning horizontal width and hsync pulse end point
- * DSP_HACT_ST_END: Panel active horizontal scanning start point and end point
- * DSP_VTOTAL_VS_END: Panel scanning vertical height and vsync pulse end point
- * DSP_VACT_ST_END: Panel active vertical scanning start point and end point
- * DSP_VS_ST_END_F1: Vertical scanning start point and vsync pulse end point
- *                   of even filed in interlace mode
- * DSP_VACT_ST_END_F1: Vertical scanning active start point and end point of
- *                     even filed in interlace mode
- * PWM_CTRL: PWM Control Register
- * PWM_PERIOD_HPR: PWM Period Register/High Polarity Capture Register
- * PWM_DUTY_LPR: PWM Duty Register/Low Polarity Capture Register
- * PWM_CNT: PWM Counter Register
- * BCSH_COLOR_BAR: Color bar config register
- * BCSH_BCS: Brightness contrast saturation*contrast config register
- * BCSH_H: Sin hue and cos hue config register
- * BCSH_CTRL: BCSH contrl register
- * CABC_CTRL0: Content Adaptive Backlight Control register0
- * CABC_CTRL1: Content Adaptive Backlight Control register1
- * CABC_CTRL2: Content Adaptive Backlight Control register2
- * CABC_CTRL3: Content Adaptive Backlight Control register3
- * CABC_GAUSS_LINE0_0: CABC gauss line config register00
- * CABC_GAUSS_LINE0_1: CABC gauss line config register01
- * CABC_GAUSS_LINE1_0: CABC gauss line config register10
- * CABC_GAUSS_LINE1_1: CABC gauss line config register11
- * CABC_GAUSS_LINE2_0: CABC gauss line config register20
- * CABC_GAUSS_LINE2_1: CABC gauss line config register21
- * FRC_LOWER01_0: FRC lookup table config register010
- * FRC_LOWER01_1: FRC lookup table config register011
- * FRC_LOWER10_0: FRC lookup table config register100
- * FRC_LOWER10_1: FRC lookup table config register101
- * FRC_LOWER11_0: FRC lookup table config register110
- * FRC_LOWER11_1: FRC lookup table config register111
- * AFBCD0_CTRL:
- * AFBCD0_HDR_PTR:
- * AFBCD0_PIC_SIZE:
- * AFBCD0_STATUS:
- * AFBCD1_CTRL:
- * AFBCD1_HDR_PTR:
- * AFBCD1_PIC_SIZE:
- * AFBCD1_STATUS:
- * AFBCD2_CTRL:
- * AFBCD2_HDR_PTR:
- * AFBCD2_PIC_SIZE:
- * AFBCD2_STATUS:
- * AFBCD3_CTRL:
- * AFBCD3_HDR_PTR:
- * AFBCD3_PIC_SIZE:
- * AFBCD3_STATUS:
- * INTR_EN0: Interrupt enable register
- * INTR_CLEAR0: Interrupt clear register
- * INTR_STATUS0: interrupt  status
- * INTR_RAW_STATUS0: raw interrupt status
- * INTR_EN1: Interrupt enable register
- * INTR_CLEAR1: Interrupt clear register
- * INTR_STATUS1: interrupt  status
- * INTR_RAW_STATUS1: raw interrupt status
- * LINE_FLAG: Line flag config register
- * VOP_STATUS: vop status register
- * BLANKING_VALUE: Register0000 Abstract
- * MCU_BYPASS_PORT: Mcu bypass value
- * WIN0_DSP_BG: Win0 layer background color
- * WIN1_DSP_BG: Win1 layer background color
- * WIN2_DSP_BG: Win2 layer background color
- * WIN3_DSP_BG: Win3 layer background color
- * YUV2YUV_WIN: YUV to YUV win
- * YUV2YUV_POST: Post YUV to YUV
- * AUTO_GATING_EN: Auto gating enable
- * DBG_PERF_LATENCY_CTRL0: Axi performance latency module contrl register0
- * DBG_PERF_RD_MAX_LATENCY_NUM0: Read max latency number
- * DBG_PERF_RD_LATENCY_THR_NUM0: The number of bigger than configed
- *                               threshold value
- * DBG_PERF_RD_LATENCY_SAMP_NUM0: Total sample number
- * DBG_CABC0: CABC debug register0
- * DBG_CABC1: CABC debug register1
- * DBG_CABC2: CABC debug register2
- * DBG_CABC3: CABC debug register3
- * DBG_WIN0_REG0: Vop debug win0 register0
- * DBG_WIN0_REG1: Vop debug win0 register1
- * DBG_WIN0_REG2: Vop debug win0 register2
- * DBG_WIN0_RESERVED: Vop debug win0 register3 reserved
- * DBG_WIN1_REG0: Vop debug win1 register0
- * DBG_WIN1_REG1: Vop debug win1 register1
- * DBG_WIN1_REG2: Vop debug win1 register2
- * DBG_WIN1_RESERVED: Vop debug win1 register3 reserved
- * DBG_WIN2_REG0: Vop debug win2 register0
- * DBG_WIN2_REG1: Vop debug win2 register1
- * DBG_WIN2_REG2: Vop debug win2 register2
- * DBG_WIN2_REG3: Vop debug win2 register3
- * DBG_WIN3_REG0: Vop debug win3 register0
- * DBG_WIN3_REG1: Vop debug win3 register1
- * DBG_WIN3_REG2: Vop debug win3 register2
- * DBG_WIN3_REG3: Vop debug win3 register3
- * DBG_PRE_REG0: Vop debug pre register0
- * DBG_PRE_RESERVED: Vop debug pre register1 reserved
- * DBG_POST_REG0: Vop debug post register0
- * DBG_POST_REG1: Vop debug
- * DBG_DATAO: debug data output path
- * DBG_DATAO_2: debug data output path 2
- * WIN2_LUT_ADDR: Win2 lut base address
- * WIN3_LUT_ADDR: Win3 lut base address
- * HWC_LUT_ADDR: Hwc lut base address
- * GAMMA0_LUT_ADDR: GAMMA lut base address
- * GAMMA1_LUT_ADDR: GAMMA lut base address
- * CABC_GAMMA_LUT_ADDR: CABC GAMMA lut base address
- * MCU_BYPASS_WPORT:
- * MCU_BYPASS_RPORT:
- */
-
-static inline u64 val_mask(int val, u64 msk, int shift)
-{
-	return (msk << (shift + 32)) | ((msk & val) << shift);
-}
-
-#define VAL_MASK(x, width, shift) val_mask(x, (1 << width) - 1, shift)
-
-#define MASK(x) (V_##x(0) >> 32)
-
-#define REG_CFG_DONE			0x00000000
-#define  V_REG_LOAD_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_REG_LOAD_WIN0_EN(x)			VAL_MASK(x, 1, 1)
-#define  V_REG_LOAD_WIN1_EN(x)			VAL_MASK(x, 1, 2)
-#define  V_REG_LOAD_WIN2_EN(x)			VAL_MASK(x, 1, 3)
-#define  V_REG_LOAD_WIN3_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_REG_LOAD_HWC_EN(x)			VAL_MASK(x, 1, 5)
-#define  V_REG_LOAD_IEP_EN(x)			VAL_MASK(x, 1, 6)
-#define  V_REG_LOAD_FBDC_EN(x)			VAL_MASK(x, 1, 7)
-#define  V_REG_LOAD_SYS_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
-#define VERSION_INFO			0x00000004
-#define  V_SVNBUILD(x)				VAL_MASK(x, 16, 0)
-#define  V_MINOR(x)				VAL_MASK(x, 8, 16)
-#define  V_MAJOR(x)				VAL_MASK(x, 8, 24)
-#define SYS_CTRL			0x00000008
-#define  V_DIRECT_PATH_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_DIRECT_PATH_LAYER_SEL(x)		VAL_MASK(x, 2, 1)
-#define  V_MIPI_DUAL_CHANNEL_EN(x)		VAL_MASK(x, 1, 3)
-#define  V_EDPI_HALT_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_EDPI_WMS_MODE(x)			VAL_MASK(x, 1, 9)
-#define  V_EDPI_WMS_FS(x)			VAL_MASK(x, 1, 10)
-#define  V_GLOBAL_REGDONE_EN(x)			VAL_MASK(x, 1, 11)
-#define  V_RGB_OUT_EN(x)			VAL_MASK(x, 1, 12)
-#define  V_HDMI_OUT_EN(x)			VAL_MASK(x, 1, 13)
-#define  V_EDP_OUT_EN(x)			VAL_MASK(x, 1, 14)
-#define  V_MIPI_OUT_EN(x)			VAL_MASK(x, 1, 15)
-#define  V_OVERLAY_MODE(x)			VAL_MASK(x, 1, 16)
-/* rk3399 only*/
-#define  V_DP_OUT_EN(x)				VAL_MASK(x, 1, 11)
-/* rk322x only */
-#define  V_FS_SAME_ADDR_MASK_EN(x)		VAL_MASK(x, 1, 17)
-#define  V_POST_LB_MODE(x)			VAL_MASK(x, 1, 18)
-#define  V_WIN23_PRI_OPT_MODE(x)		VAL_MASK(x, 1, 19)
-/* rk322x only */
-#define  V_VOP_MMU_EN(x)			VAL_MASK(x, 1, 20)
-/* rk3399 only */
-#define  V_VOP_FIELD_TVE_TIMING_POL(x)		VAL_MASK(x, 1, 20)
-#define  V_VOP_DMA_STOP(x)			VAL_MASK(x, 1, 21)
-#define  V_VOP_STANDBY_EN(x)			VAL_MASK(x, 1, 22)
-#define  V_AUTO_GATING_EN(x)			VAL_MASK(x, 1, 23)
-#define  V_SW_IMD_TVE_DCLK_EN(x)		VAL_MASK(x, 1, 24)
-#define  V_SW_IMD_TVE_DCLK_POL(x)		VAL_MASK(x, 1, 25)
-#define  V_SW_TVE_MODE(x)			VAL_MASK(x, 1, 26)
-#define  V_SW_UV_OFFSET_EN(x)			VAL_MASK(x, 1, 27)
-#define  V_SW_GENLOCK(x)			VAL_MASK(x, 1, 28)
-#define  V_SW_DAC_SEL(x)			VAL_MASK(x, 1, 29)
-#define  V_VOP_FIELD_TVE_POL(x)			VAL_MASK(x, 1, 30)
-#define  V_IO_PAD_CLK_SEL(x)			VAL_MASK(x, 1, 31)
-#define SYS_CTRL1			0x0000000c
-#define  V_NOC_HURRY_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_NOC_HURRY_VALUE(x)			VAL_MASK(x, 2, 1)
-#define  V_NOC_HURRY_THRESHOLD(x)		VAL_MASK(x, 6, 3)
-#define  V_NOC_QOS_EN(x)			VAL_MASK(x, 1, 9)
-#define  V_NOC_WIN_QOS(x)			VAL_MASK(x, 2, 10)
-#define  V_AXI_MAX_OUTSTANDING_EN(x)		VAL_MASK(x, 1, 12)
-#define  V_AXI_OUTSTANDING_MAX_NUM(x)		VAL_MASK(x, 5, 13)
-#define  V_NOC_HURRY_W_MODE(x)			VAL_MASK(x, 2, 20)
-#define  V_NOC_HURRY_W_VALUE(x)			VAL_MASK(x, 2, 22)
-#define  V_REG_DONE_FRM(x)			VAL_MASK(x, 1, 24)
-#define  V_DSP_FP_STANDBY(x)			VAL_MASK(x, 1, 31)
-#define DSP_CTRL0			0x00000010
-#define  V_DSP_OUT_MODE(x)			VAL_MASK(x, 4, 0)
-#define  V_SW_CORE_DCLK_SEL(x)			VAL_MASK(x, 1, 4)
-/* rk322x */
-#define  V_SW_HDMI_CLK_I_SEL(x)			VAL_MASK(x, 1, 5)
-/* rk3399 */
-#define  V_P2I_EN(x)				VAL_MASK(x, 1, 5)
-#define  V_DSP_DCLK_DDR(x)			VAL_MASK(x, 1, 8)
-#define  V_DSP_DDR_PHASE(x)			VAL_MASK(x, 1, 9)
-#define  V_DSP_INTERLACE(x)			VAL_MASK(x, 1, 10)
-#define  V_DSP_FIELD_POL(x)			VAL_MASK(x, 1, 11)
-#define  V_DSP_BG_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_DSP_RB_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_DSP_RG_SWAP(x)			VAL_MASK(x, 1, 14)
-#define  V_DSP_DELTA_SWAP(x)			VAL_MASK(x, 1, 15)
-#define  V_DSP_DUMMY_SWAP(x)			VAL_MASK(x, 1, 16)
-#define  V_DSP_OUT_ZERO(x)			VAL_MASK(x, 1, 17)
-#define  V_DSP_BLANK_EN(x)			VAL_MASK(x, 1, 18)
-#define  V_DSP_BLACK_EN(x)			VAL_MASK(x, 1, 19)
-#define  V_DSP_CCIR656_AVG(x)			VAL_MASK(x, 1, 20)
-#define  V_DSP_YUV_CLIP(x)			VAL_MASK(x, 1, 21)
-#define  V_DSP_X_MIR_EN(x)			VAL_MASK(x, 1, 22)
-#define  V_DSP_Y_MIR_EN(x)			VAL_MASK(x, 1, 23)
-/* rk3399 only */
-#define  V_SW_TVE_OUTPUT_SEL(x)			VAL_MASK(x, 1, 25)
-#define  V_DSP_FIELD(x)				VAL_MASK(x, 1, 31)
-#define DSP_CTRL1			0x00000014
-#define  V_DSP_LUT_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_PRE_DITHER_DOWN_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_DITHER_DOWN_EN(x)			VAL_MASK(x, 1, 2)
-#define  V_DITHER_DOWN_MODE(x)			VAL_MASK(x, 1, 3)
-#define  V_DITHER_DOWN_SEL(x)			VAL_MASK(x, 1, 4)
-#define  V_DITHER_UP_EN(x)			VAL_MASK(x, 1, 6)
-#define  V_UPDATE_GAMMA_LUT(x)			VAL_MASK(x, 1, 7)
-#define  V_DSP_LAYER0_SEL(x)			VAL_MASK(x, 2, 8)
-#define  V_DSP_LAYER1_SEL(x)			VAL_MASK(x, 2, 10)
-#define  V_DSP_LAYER2_SEL(x)			VAL_MASK(x, 2, 12)
-#define  V_DSP_LAYER3_SEL(x)			VAL_MASK(x, 2, 14)
-#define  V_RGB_LVDS_HSYNC_POL(x)		VAL_MASK(x, 1, 16)
-#define  V_RGB_LVDS_VSYNC_POL(x)		VAL_MASK(x, 1, 17)
-#define  V_RGB_LVDS_DEN_POL(x)			VAL_MASK(x, 1, 18)
-#define  V_RGB_LVDS_DCLK_POL(x)			VAL_MASK(x, 1, 19)
-#define  V_HDMI_HSYNC_POL(x)			VAL_MASK(x, 1, 20)
-#define  V_HDMI_VSYNC_POL(x)			VAL_MASK(x, 1, 21)
-#define  V_HDMI_DEN_POL(x)			VAL_MASK(x, 1, 22)
-#define  V_HDMI_DCLK_POL(x)			VAL_MASK(x, 1, 23)
-#define  V_EDP_HSYNC_POL(x)			VAL_MASK(x, 1, 24)
-#define  V_EDP_VSYNC_POL(x)			VAL_MASK(x, 1, 25)
-#define  V_EDP_DEN_POL(x)			VAL_MASK(x, 1, 26)
-#define  V_EDP_DCLK_POL(x)			VAL_MASK(x, 1, 27)
-#define  V_MIPI_HSYNC_POL(x)			VAL_MASK(x, 1, 28)
-#define  V_MIPI_VSYNC_POL(x)			VAL_MASK(x, 1, 29)
-#define  V_MIPI_DEN_POL(x)			VAL_MASK(x, 1, 30)
-#define  V_MIPI_DCLK_POL(x)			VAL_MASK(x, 1, 31)
-/* rk3399 only*/
-#define  V_DP_HSYNC_POL(x)			VAL_MASK(x, 1, 16)
-#define  V_DP_VSYNC_POL(x)			VAL_MASK(x, 1, 17)
-#define  V_DP_DEN_POL(x)			VAL_MASK(x, 1, 18)
-#define  V_DP_DCLK_POL(x)			VAL_MASK(x, 1, 19)
-#define DSP_BG				0x00000018
-#define  V_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
-#define  V_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
-#define  V_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
-#define MCU_CTRL			0x0000001c
-#define  V_MCU_PIX_TOTAL(x)			VAL_MASK(x, 6, 0)
-#define  V_MCU_CS_PST(x)			VAL_MASK(x, 4, 6)
-#define  V_MCU_CS_PEND(x)			VAL_MASK(x, 6, 10)
-#define  V_MCU_RW_PST(x)			VAL_MASK(x, 4, 16)
-#define  V_MCU_RW_PEND(x)			VAL_MASK(x, 6, 20)
-#define  V_MCU_CLK_SEL(x)			VAL_MASK(x, 1, 26)
-#define  V_MCU_HOLD_MODE(x)			VAL_MASK(x, 1, 27)
-#define  V_MCU_FRAME_ST(x)			VAL_MASK(x, 1, 28)
-#define  V_MCU_RS(x)				VAL_MASK(x, 1, 29)
-#define  V_MCU_BYPASS(x)			VAL_MASK(x, 1, 30)
-#define  V_MCU_TYPE(x)				VAL_MASK(x, 1, 31)
-#define WB_CTRL0			0x00000020
-#define  V_WB_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WB_FMT(x)				VAL_MASK(x, 3, 1)
-#define  V_WB_DITHER_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_WB_RGB2YUV_EN(x)			VAL_MASK(x, 1, 5)
-#define  V_WB_RGB2YUV_MODE(x)			VAL_MASK(x, 1, 6)
-#define  V_WB_XPSD_BIL_EN(x)			VAL_MASK(x, 1, 7)
-#define  V_WB_YTHROW_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_WB_YTHROW_MODE(x)			VAL_MASK(x, 1, 9)
-#define  V_WB_HANDSHAKE_MODE(x)			VAL_MASK(x, 1, 11)
-#define  V_WB_YRGB_ID(x)			VAL_MASK(x, 4, 24)
-#define  V_WB_UV_ID(x)				VAL_MASK(x, 4, 28)
-#define WB_CTRL1			0x00000024
-#define  V_WB_WIDTH(x)				VAL_MASK(x, 12, 0)
-#define  V_WB_XPSD_BIL_FACTOR(x)		VAL_MASK(x, 14, 16)
-#define WB_YRGB_MST			0x00000028
-#define  V_WB_YRGB_MST(x)			VAL_MASK(x, 32, 0)
-#define WB_CBR_MST			0x0000002c
-#define  V_WB_CBR_MST(x)			VAL_MASK(x, 32, 0)
-#define WIN0_CTRL0			0x00000030
-#define  V_WIN0_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN0_DATA_FMT(x)			VAL_MASK(x, 3, 1)
-#define  V_WIN0_FMT_10(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN0_LB_MODE(x)			VAL_MASK(x, 3, 5)
-#define  V_WIN0_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
-#define  V_WIN0_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
-#define  V_WIN0_CSC_MODE(x)			VAL_MASK(x, 2, 10)
-#define  V_WIN0_RB_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN0_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_WIN0_MID_SWAP(x)			VAL_MASK(x, 1, 14)
-#define  V_WIN0_UV_SWAP(x)			VAL_MASK(x, 1, 15)
-#define  V_WIN0_HW_PRE_MUL_EN(x)		VAL_MASK(x, 1, 16)
-/* rk3399 only */
-#define  V_WIN0_YUYV(x)				VAL_MASK(x, 1, 17)
-#define  V_WIN0_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
-#define  V_WIN0_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
-#define  V_WIN0_YUV_CLIP(x)			VAL_MASK(x, 1, 20)
-#define  V_WIN0_X_MIR_EN(x)			VAL_MASK(x, 1, 21)
-#define  V_WIN0_Y_MIR_EN(x)			VAL_MASK(x, 1, 22)
-#define  V_WIN0_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 24)
-#define  V_WIN0_AXI_OUTSTANDING_MAX_NUM(x)	VAL_MASK(x, 5, 25)
-#define  V_WIN0_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 30)
-#define WIN0_CTRL1			0x00000034
-#define  V_WIN0_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN0_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN0_BIC_COE_SEL(x)			VAL_MASK(x, 2, 2)
-#define  V_WIN0_VSD_YRGB_GT4(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN0_VSD_YRGB_GT2(x)			VAL_MASK(x, 1, 5)
-#define  V_WIN0_VSD_CBR_GT4(x)			VAL_MASK(x, 1, 6)
-#define  V_WIN0_VSD_CBR_GT2(x)			VAL_MASK(x, 1, 7)
-#define  V_WIN0_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 8)
-#define  V_WIN0_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 12)
-#define  V_WIN0_LINE_LOAD_MODE(x)		VAL_MASK(x, 1, 15)
-#define  V_WIN0_YRGB_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 16)
-#define  V_WIN0_YRGB_VER_SCL_MODE(x)		VAL_MASK(x, 2, 18)
-#define  V_WIN0_YRGB_HSD_MODE(x)		VAL_MASK(x, 2, 20)
-#define  V_WIN0_YRGB_VSU_MODE(x)		VAL_MASK(x, 1, 22)
-#define  V_WIN0_YRGB_VSD_MODE(x)		VAL_MASK(x, 1, 23)
-#define  V_WIN0_CBR_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 24)
-#define  V_WIN0_CBR_VER_SCL_MODE(x)		VAL_MASK(x, 2, 26)
-#define  V_WIN0_CBR_HSD_MODE(x)			VAL_MASK(x, 2, 28)
-#define  V_WIN0_CBR_VSU_MODE(x)			VAL_MASK(x, 1, 30)
-#define  V_WIN0_CBR_VSD_MODE(x)			VAL_MASK(x, 1, 31)
-#define WIN0_COLOR_KEY			0x00000038
-#define  V_WIN0_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN0_KEY_EN(x)			VAL_MASK(x, 1, 31)
-#define WIN0_VIR			0x0000003c
-#define  V_WIN0_VIR_STRIDE(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN0_VIR_STRIDE_UV(x)		VAL_MASK(x, 16, 16)
-#define WIN0_YRGB_MST			0x00000040
-#define  V_WIN0_YRGB_MST(x)			VAL_MASK(x, 32, 0)
-#define WIN0_CBR_MST			0x00000044
-#define  V_WIN0_CBR_MST(x)			VAL_MASK(x, 32, 0)
-#define WIN0_ACT_INFO			0x00000048
-#define  V_WIN0_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
-#define  V_FIELD0002(x)				VAL_MASK(x, 1, 13)
-#define  V_FIELD0001(x)				VAL_MASK(x, 1, 14)
-#define  V_FIELD0000(x)				VAL_MASK(x, 1, 15)
-#define  V_WIN0_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
-#define WIN0_DSP_INFO			0x0000004c
-#define  V_WIN0_DSP_WIDTH(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN0_DSP_HEIGHT(x)			VAL_MASK(x, 12, 16)
-#define WIN0_DSP_ST			0x00000050
-#define  V_WIN0_DSP_XST(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN0_DSP_YST(x)			VAL_MASK(x, 13, 16)
-#define WIN0_SCL_FACTOR_YRGB		0x00000054
-#define  V_WIN0_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN0_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
-#define WIN0_SCL_FACTOR_CBR		0x00000058
-#define  V_WIN0_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN0_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
-#define WIN0_SCL_OFFSET			0x0000005c
-#define  V_WIN0_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN0_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN0_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN0_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
-#define WIN0_SRC_ALPHA_CTRL		0x00000060
-#define  V_WIN0_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN0_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN0_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN0_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
-#define  V_WIN0_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN0_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define  V_WIN0_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN0_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
-#define WIN0_DST_ALPHA_CTRL		0x00000064
-#define  V_WIN0_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
-#define  V_WIN0_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define WIN0_FADING_CTRL		0x00000068
-#define  V_LAYER0_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
-#define  V_LAYER0_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
-#define  V_LAYER0_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
-#define  V_LAYER0_FADING_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN0_CTRL2			0x0000006c
-#define  V_WIN_RID_WIN0_YRGB(x)			VAL_MASK(x, 4, 0)
-#define  V_WIN_RID_WIN0_CBR(x)			VAL_MASK(x, 4, 4)
-#define WIN1_CTRL0			0x00000070
-#define  V_WIN1_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN1_DATA_FMT(x)			VAL_MASK(x, 3, 1)
-#define  V_WIN1_FMT_10(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN1_LB_MODE(x)			VAL_MASK(x, 3, 5)
-#define  V_WIN1_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
-#define  V_WIN1_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
-#define  V_WIN1_CSC_MODE(x)			VAL_MASK(x, 2, 10)
-#define  V_WIN1_RB_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN1_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_WIN1_MID_SWAP(x)			VAL_MASK(x, 1, 14)
-#define  V_WIN1_UV_SWAP(x)			VAL_MASK(x, 1, 15)
-#define  V_WIN1_HW_PRE_MUL_EN(x)		VAL_MASK(x, 1, 16)
-/* rk3399 only */
-#define  V_WIN1_YUYV(x)				VAL_MASK(x, 1, 17)
-#define  V_WIN1_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
-#define  V_WIN1_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
-#define  V_WIN1_YUV_CLIP(x)			VAL_MASK(x, 1, 20)
-#define  V_WIN1_X_MIR_EN(x)			VAL_MASK(x, 1, 21)
-#define  V_WIN1_Y_MIR_EN(x)			VAL_MASK(x, 1, 22)
-#define  V_WIN1_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 24)
-#define  V_WIN1_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 25)
-#define  V_WIN1_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 30)
-#define WIN1_CTRL1			0x00000074
-#define  V_WIN1_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN1_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN1_BIC_COE_SEL(x)			VAL_MASK(x, 2, 2)
-#define  V_WIN1_VSD_YRGB_GT4(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN1_VSD_YRGB_GT2(x)			VAL_MASK(x, 1, 5)
-#define  V_WIN1_VSD_CBR_GT4(x)			VAL_MASK(x, 1, 6)
-#define  V_WIN1_VSD_CBR_GT2(x)			VAL_MASK(x, 1, 7)
-#define  V_WIN1_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 8)
-#define  V_WIN1_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 12)
-#define  V_WIN1_LINE_LOAD_MODE(x)		VAL_MASK(x, 1, 15)
-#define  V_WIN1_YRGB_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 16)
-#define  V_WIN1_YRGB_VER_SCL_MODE(x)		VAL_MASK(x, 2, 18)
-#define  V_WIN1_YRGB_HSD_MODE(x)		VAL_MASK(x, 2, 20)
-#define  V_WIN1_YRGB_VSU_MODE(x)		VAL_MASK(x, 1, 22)
-#define  V_WIN1_YRGB_VSD_MODE(x)		VAL_MASK(x, 1, 23)
-#define  V_WIN1_CBR_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 24)
-#define  V_WIN1_CBR_VER_SCL_MODE(x)		VAL_MASK(x, 2, 26)
-#define  V_WIN1_CBR_HSD_MODE(x)			VAL_MASK(x, 2, 28)
-#define  V_WIN1_CBR_VSU_MODE(x)			VAL_MASK(x, 1, 30)
-#define  V_WIN1_CBR_VSD_MODE(x)			VAL_MASK(x, 1, 31)
-#define WIN1_COLOR_KEY			0x00000078
-#define  V_WIN1_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN1_KEY_EN(x)			VAL_MASK(x, 1, 31)
-#define WIN1_VIR			0x0000007c
-#define  V_WIN1_VIR_STRIDE(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN1_VIR_STRIDE_UV(x)		VAL_MASK(x, 16, 16)
-#define WIN1_YRGB_MST			0x00000080
-#define  V_WIN1_YRGB_MST(x)			VAL_MASK(x, 32, 0)
-#define WIN1_CBR_MST			0x00000084
-#define  V_WIN1_CBR_MST(x)			VAL_MASK(x, 32, 0)
-#define WIN1_ACT_INFO			0x00000088
-#define  V_WIN1_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN1_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
-#define WIN1_DSP_INFO			0x0000008c
-#define  V_WIN1_DSP_WIDTH(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN1_DSP_HEIGHT(x)			VAL_MASK(x, 12, 16)
-#define WIN1_DSP_ST			0x00000090
-#define  V_WIN1_DSP_XST(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN1_DSP_YST(x)			VAL_MASK(x, 13, 16)
-#define WIN1_SCL_FACTOR_YRGB		0x00000094
-#define  V_WIN1_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN1_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
-#define WIN1_SCL_FACTOR_CBR		0x00000098
-#define  V_WIN1_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN1_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
-#define WIN1_SCL_OFFSET			0x0000009c
-#define  V_WIN1_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN1_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN1_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN1_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
-#define WIN1_SRC_ALPHA_CTRL		0x000000a0
-#define  V_WIN1_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN1_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN1_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN1_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
-#define  V_WIN1_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN1_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define  V_WIN1_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN1_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
-#define WIN1_DST_ALPHA_CTRL		0x000000a4
-#define  V_WIN1_DSP_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
-#define  V_WIN1_DST_FACTOR_M0(x)		VAL_MASK(x, 3, 6)
-#define WIN1_FADING_CTRL		0x000000a8
-#define  V_WIN1_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN1_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN1_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN1_FADING_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN1_CTRL2			0x000000ac
-#define  V_WIN_RID_WIN1_YRGB(x)			VAL_MASK(x, 4, 0)
-#define  V_WIN_RID_WIN1_CBR(x)			VAL_MASK(x, 4, 4)
-#define WIN2_CTRL0			0x000000b0
-#define  V_WIN2_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN2_INTERLACE_READ(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN2_CSC_MODE(x)			VAL_MASK(x, 2, 2)
-#define  V_WIN2_MST0_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN2_DATA_FMT0(x)			VAL_MASK(x, 2, 5)
-#define  V_WIN2_MST1_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_WIN2_DATA_FMT1(x)			VAL_MASK(x, 2, 9)
-#define  V_WIN2_MST2_EN(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN2_DATA_FMT2(x)			VAL_MASK(x, 2, 13)
-#define  V_WIN2_MST3_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN2_DATA_FMT3(x)			VAL_MASK(x, 2, 17)
-#define  V_WIN2_RB_SWAP0(x)			VAL_MASK(x, 1, 20)
-#define  V_WIN2_ALPHA_SWAP0(x)			VAL_MASK(x, 1, 21)
-#define  V_WIN2_ENDIAN_SWAP0(x)			VAL_MASK(x, 1, 22)
-#define  V_WIN2_RB_SWAP1(x)			VAL_MASK(x, 1, 23)
-#define  V_WIN2_ALPHA_SWAP1(x)			VAL_MASK(x, 1, 24)
-#define  V_WIN2_ENDIAN_SWAP1(x)			VAL_MASK(x, 1, 25)
-#define  V_WIN2_RB_SWAP2(x)			VAL_MASK(x, 1, 26)
-#define  V_WIN2_ALPHA_SWAP2(x)			VAL_MASK(x, 1, 27)
-#define  V_WIN2_ENDIAN_SWAP2(x)			VAL_MASK(x, 1, 28)
-#define  V_WIN2_RB_SWAP3(x)			VAL_MASK(x, 1, 29)
-#define  V_WIN2_ALPHA_SWAP3(x)			VAL_MASK(x, 1, 30)
-#define  V_WIN2_ENDIAN_SWAP3(x)			VAL_MASK(x, 1, 31)
-#define WIN2_CTRL1			0x000000b4
-#define  V_WIN2_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN2_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
-#define  V_WIN2_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
-#define  V_WIN2_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
-#define  V_WIN2_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
-#define  V_WIN2_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
-#define  V_WIN2_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
-#define  V_WIN2_LUT_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN_RID_WIN2(x)			VAL_MASK(x, 4, 20)
-#define WIN2_VIR0_1			0x000000b8
-#define  V_WIN2_VIR_STRIDE0(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN2_VIR_STRIDE1(x)			VAL_MASK(x, 16, 16)
-#define WIN2_VIR2_3			0x000000bc
-#define  V_WIN2_VIR_STRIDE2(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN2_VIR_STRIDE3(x)			VAL_MASK(x, 16, 16)
-#define WIN2_MST0			0x000000c0
-#define  V_WIN2_MST0(x)				VAL_MASK(x, 32, 0)
-#define WIN2_DSP_INFO0			0x000000c4
-#define  V_WIN2_DSP_WIDTH0(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN2_DSP_HEIGHT0(x)			VAL_MASK(x, 12, 16)
-#define WIN2_DSP_ST0			0x000000c8
-#define  V_WIN2_DSP_XST0(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN2_DSP_YST0(x)			VAL_MASK(x, 13, 16)
-#define WIN2_COLOR_KEY			0x000000cc
-#define  V_WIN2_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN2_KEY_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN2_MST1			0x000000d0
-#define  V_WIN2_MST1(x)				VAL_MASK(x, 32, 0)
-#define WIN2_DSP_INFO1			0x000000d4
-#define  V_WIN2_DSP_WIDTH1(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN2_DSP_HEIGHT1(x)			VAL_MASK(x, 12, 16)
-#define WIN2_DSP_ST1			0x000000d8
-#define  V_WIN2_DSP_XST1(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN2_DSP_YST1(x)			VAL_MASK(x, 13, 16)
-#define WIN2_SRC_ALPHA_CTRL		0x000000dc
-#define  V_WIN2_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN2_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN2_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN2_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
-#define  V_WIN2_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN2_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define  V_WIN2_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN2_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
-#define WIN2_MST2			0x000000e0
-#define  V_WIN2_MST2(x)				VAL_MASK(x, 32, 0)
-#define WIN2_DSP_INFO2			0x000000e4
-#define  V_WIN2_DSP_WIDTH2(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN2_DSP_HEIGHT2(x)			VAL_MASK(x, 12, 16)
-#define WIN2_DSP_ST2			0x000000e8
-#define  V_WIN2_DSP_XST2(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN2_DSP_YST2(x)			VAL_MASK(x, 13, 16)
-#define WIN2_DST_ALPHA_CTRL		0x000000ec
-#define  V_WIN2_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
-#define  V_WIN2_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define WIN2_MST3			0x000000f0
-#define  V_WIN2_MST3(x)				VAL_MASK(x, 32, 0)
-#define WIN2_DSP_INFO3			0x000000f4
-#define  V_WIN2_DSP_WIDTH3(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN2_DSP_HEIGHT3(x)			VAL_MASK(x, 12, 16)
-#define WIN2_DSP_ST3			0x000000f8
-#define  V_WIN2_DSP_XST3(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN2_DSP_YST3(x)			VAL_MASK(x, 13, 16)
-#define WIN2_FADING_CTRL		0x000000fc
-#define  V_WIN2_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN2_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN2_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN2_FADING_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN3_CTRL0			0x00000100
-#define  V_WIN3_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN3_INTERLACE_READ(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN3_CSC_MODE(x)			VAL_MASK(x, 2, 2)
-#define  V_WIN3_MST0_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_WIN3_DATA_FMT0(x)			VAL_MASK(x, 2, 5)
-#define  V_WIN3_MST1_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_WIN3_DATA_FMT1(x)			VAL_MASK(x, 2, 9)
-#define  V_WIN3_MST2_EN(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN3_DATA_FMT2(x)			VAL_MASK(x, 2, 13)
-#define  V_WIN3_MST3_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN3_DATA_FMT3(x)			VAL_MASK(x, 2, 17)
-#define  V_WIN3_RB_SWAP0(x)			VAL_MASK(x, 1, 20)
-#define  V_WIN3_ALPHA_SWAP0(x)			VAL_MASK(x, 1, 21)
-#define  V_WIN3_ENDIAN_SWAP0(x)			VAL_MASK(x, 1, 22)
-#define  V_WIN3_RB_SWAP1(x)			VAL_MASK(x, 1, 23)
-#define  V_WIN3_ALPHA_SWAP1(x)			VAL_MASK(x, 1, 24)
-#define  V_WIN3_ENDIAN_SWAP1(x)			VAL_MASK(x, 1, 25)
-#define  V_WIN3_RB_SWAP2(x)			VAL_MASK(x, 1, 26)
-#define  V_WIN3_ALPHA_SWAP2(x)			VAL_MASK(x, 1, 27)
-#define  V_WIN3_ENDIAN_SWAP2(x)			VAL_MASK(x, 1, 28)
-#define  V_WIN3_RB_SWAP3(x)			VAL_MASK(x, 1, 29)
-#define  V_WIN3_ALPHA_SWAP3(x)			VAL_MASK(x, 1, 30)
-#define  V_WIN3_ENDIAN_SWAP3(x)			VAL_MASK(x, 1, 31)
-#define WIN3_CTRL1			0x00000104
-#define  V_WIN3_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN3_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
-#define  V_WIN3_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
-#define  V_WIN3_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
-#define  V_WIN3_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
-#define  V_WIN3_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
-#define  V_WIN3_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
-#define  V_WIN3_LUT_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN_RID_WIN3(x)			VAL_MASK(x, 4, 20)
-#define WIN3_VIR0_1			0x00000108
-#define  V_WIN3_VIR_STRIDE0(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN3_VIR_STRIDE1(x)			VAL_MASK(x, 16, 16)
-#define WIN3_VIR2_3			0x0000010c
-#define  V_WIN3_VIR_STRIDE2(x)			VAL_MASK(x, 16, 0)
-#define  V_WIN3_VIR_STRIDE3(x)			VAL_MASK(x, 16, 16)
-#define WIN3_MST0			0x00000110
-#define  V_WIN3_MST0(x)				VAL_MASK(x, 32, 0)
-#define WIN3_DSP_INFO0			0x00000114
-#define  V_WIN3_DSP_WIDTH0(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN3_DSP_HEIGHT0(x)			VAL_MASK(x, 12, 16)
-#define WIN3_DSP_ST0			0x00000118
-#define  V_WIN3_DSP_XST0(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN3_DSP_YST0(x)			VAL_MASK(x, 13, 16)
-#define WIN3_COLOR_KEY			0x0000011c
-#define  V_WIN3_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN3_KEY_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN3_MST1			0x00000120
-#define  V_WIN3_MST1(x)				VAL_MASK(x, 32, 0)
-#define WIN3_DSP_INFO1			0x00000124
-#define  V_WIN3_DSP_WIDTH1(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN3_DSP_HEIGHT1(x)			VAL_MASK(x, 12, 16)
-#define WIN3_DSP_ST1			0x00000128
-#define  V_WIN3_DSP_XST1(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN3_DSP_YST1(x)			VAL_MASK(x, 13, 16)
-#define WIN3_SRC_ALPHA_CTRL		0x0000012c
-#define  V_WIN3_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN3_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN3_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN3_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
-#define  V_WIN3_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN3_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define  V_WIN3_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN3_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
-#define WIN3_MST2			0x00000130
-#define  V_WIN3_MST2(x)				VAL_MASK(x, 32, 0)
-#define WIN3_DSP_INFO2			0x00000134
-#define  V_WIN3_DSP_WIDTH2(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN3_DSP_HEIGHT2(x)			VAL_MASK(x, 12, 16)
-#define WIN3_DSP_ST2			0x00000138
-#define  V_WIN3_DSP_XST2(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN3_DSP_YST2(x)			VAL_MASK(x, 13, 16)
-#define WIN3_DST_ALPHA_CTRL		0x0000013c
-#define  V_WIN3_DST_FACTOR_RESERVED(x)		VAL_MASK(x, 6, 0)
-#define  V_WIN3_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define WIN3_MST3			0x00000140
-#define  V_WIN3_MST3(x)				VAL_MASK(x, 32, 0)
-#define WIN3_DSP_INFO3			0x00000144
-#define  V_WIN3_DSP_WIDTH3(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN3_DSP_HEIGHT3(x)			VAL_MASK(x, 12, 16)
-#define WIN3_DSP_ST3			0x00000148
-#define  V_WIN3_DSP_XST3(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN3_DSP_YST3(x)			VAL_MASK(x, 13, 16)
-#define WIN3_FADING_CTRL		0x0000014c
-#define  V_WIN3_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN3_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN3_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN3_FADING_EN(x)			VAL_MASK(x, 1, 24)
-#define HWC_CTRL0			0x00000150
-#define  V_HWC_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_HWC_DATA_FMT(x)			VAL_MASK(x, 3, 1)
-#define  V_HWC_MODE(x)				VAL_MASK(x, 1, 4)
-#define  V_HWC_SIZE(x)				VAL_MASK(x, 2, 5)
-#define  V_HWC_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
-#define  V_HWC_CSC_MODE(x)			VAL_MASK(x, 2, 10)
-#define  V_HWC_RB_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_HWC_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_HWC_ENDIAN_SWAP(x)			VAL_MASK(x, 1, 14)
-#define HWC_CTRL1			0x00000154
-#define  V_HWC_AXI_GATHER_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_HWC_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
-#define  V_HWC_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
-#define  V_HWC_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 4)
-#define  V_HWC_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
-#define  V_HWC_RGB2YUV_EN(x)			VAL_MASK(x, 1, 13)
-#define  V_HWC_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
-#define  V_HWC_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
-#define  V_HWC_LUT_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN_RID_HWC(x)			VAL_MASK(x, 4, 20)
-#define HWC_MST				0x00000158
-#define  V_HWC_MST(x)				VAL_MASK(x, 32, 0)
-#define HWC_DSP_ST			0x0000015c
-#define  V_HWC_DSP_XST(x)			VAL_MASK(x, 13, 0)
-#define  V_HWC_DSP_YST(x)			VAL_MASK(x, 13, 16)
-#define HWC_SRC_ALPHA_CTRL		0x00000160
-#define  V_HWC_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_HWC_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_HWC_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
-#define  V_HWC_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
-#define  V_HWC_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
-#define  V_HWC_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define  V_HWC_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
-#define  V_HWC_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
-#define HWC_DST_ALPHA_CTRL		0x00000164
-#define  V_HWC_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
-#define  V_HWC_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
-#define HWC_FADING_CTRL			0x00000168
-#define  V_HWC_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
-#define  V_HWC_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
-#define  V_HWC_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
-#define  V_HWC_FADING_EN(x)			VAL_MASK(x, 1, 24)
-#define HWC_RESERVED1			0x0000016c
-#define POST_DSP_HACT_INFO		0x00000170
-#define  V_DSP_HACT_END_POST(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_HACT_ST_POST(x)			VAL_MASK(x, 13, 16)
-#define POST_DSP_VACT_INFO		0x00000174
-#define  V_DSP_VACT_END_POST(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_VACT_ST_POST(x)			VAL_MASK(x, 13, 16)
-#define POST_SCL_FACTOR_YRGB		0x00000178
-#define  V_POST_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
-#define  V_POST_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
-#define POST_RESERVED			0x0000017c
-#define POST_SCL_CTRL			0x00000180
-#define  V_POST_HOR_SD_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_POST_VER_SD_EN(x)			VAL_MASK(x, 1, 1)
-#define  V_DSP_OUT_RGB_YUV(x)			VAL_MASK(x, 1, 2)
-#define POST_DSP_VACT_INFO_F1		0x00000184
-#define  V_DSP_VACT_END_POST(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_VACT_ST_POST(x)			VAL_MASK(x, 13, 16)
-#define DSP_HTOTAL_HS_END		0x00000188
-#define  V_DSP_HS_END(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_HTOTAL(x)			VAL_MASK(x, 13, 16)
-#define DSP_HACT_ST_END			0x0000018c
-#define  V_DSP_HACT_END(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_HACT_ST(x)			VAL_MASK(x, 13, 16)
-#define DSP_VTOTAL_VS_END		0x00000190
-#define  V_DSP_VS_END(x)			VAL_MASK(x, 13, 0)
-#define  V_SW_DSP_VTOTAL_IMD(x)			VAL_MASK(x, 1, 15)
-#define  V_DSP_VTOTAL(x)			VAL_MASK(x, 13, 16)
-#define DSP_VACT_ST_END			0x00000194
-#define  V_DSP_VACT_END(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_VACT_ST(x)			VAL_MASK(x, 13, 16)
-#define DSP_VS_ST_END_F1		0x00000198
-#define  V_DSP_VS_END_F1(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_VS_ST_F1(x)			VAL_MASK(x, 13, 16)
-#define DSP_VACT_ST_END_F1		0x0000019c
-#define  V_DSP_VACT_END_F1(x)			VAL_MASK(x, 13, 0)
-#define  V_DSP_VACT_ST_F1(x)			VAL_MASK(x, 13, 16)
-#define PWM_CTRL			0x000001a0
-#define  V_PWM_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_PWM_MODE(x)				VAL_MASK(x, 2, 1)
-#define  V_DUTY_POL(x)				VAL_MASK(x, 1, 3)
-#define  V_INACTIVE_POL(x)			VAL_MASK(x, 1, 4)
-#define  V_OUTPUT_MODE(x)			VAL_MASK(x, 1, 5)
-#define  V_LP_EN(x)				VAL_MASK(x, 1, 8)
-#define  V_CLK_SEL(x)				VAL_MASK(x, 1, 9)
-#define  V_PRESCALE(x)				VAL_MASK(x, 3, 12)
-#define  V_SCALE(x)				VAL_MASK(x, 8, 16)
-#define  V_RPT(x)				VAL_MASK(x, 8, 24)
-#define PWM_PERIOD_HPR			0x000001a4
-#define  V_PWM_PERIOD(x)			VAL_MASK(x, 32, 0)
-#define PWM_DUTY_LPR			0x000001a8
-#define  V_PWM_DUTY(x)				VAL_MASK(x, 32, 0)
-#define PWM_CNT				0x000001ac
-#define  V_PWM_CNT(x)				VAL_MASK(x, 32, 0)
-#define BCSH_COLOR_BAR			0x000001b0
-#define  V_BCSH_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_COLOR_BAR_Y(x)			VAL_MASK(x, 8, 8)
-#define  V_COLOR_BAR_U(x)			VAL_MASK(x, 8, 16)
-#define  V_COLOR_BAR_V(x)			VAL_MASK(x, 8, 24)
-#define BCSH_BCS			0x000001b4
-#define  V_BRIGHTNESS(x)			VAL_MASK(x, 8, 0)
-#define  V_CONTRAST(x)				VAL_MASK(x, 9, 8)
-#define  V_SAT_CON(x)				VAL_MASK(x, 10, 20)
-#define  V_OUT_MODE(x)				VAL_MASK(x, 2, 30)
-#define BCSH_H				0x000001b8
-#define  V_SIN_HUE(x)				VAL_MASK(x, 9, 0)
-#define  V_COS_HUE(x)				VAL_MASK(x, 9, 16)
-#define BCSH_CTRL			0x000001bc
-#define  V_BCSH_Y2R_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_BCSH_Y2R_CSC_MODE(x)			VAL_MASK(x, 2, 2)
-#define  V_BCSH_R2Y_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_BCSH_R2Y_CSC_MODE(x)			VAL_MASK(x, 1, 6)
-#define CABC_CTRL0			0x000001c0
-#define  V_CABC_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_CABC_HANDLE_EN(x)			VAL_MASK(x, 1, 1)
-#define  V_PWM_CONFIG_MODE(x)			VAL_MASK(x, 2, 2)
-#define  V_CABC_CALC_PIXEL_NUM(x)		VAL_MASK(x, 23, 4)
-#define CABC_CTRL1			0x000001c4
-#define  V_CABC_LUT_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_CABC_TOTAL_NUM(x)			VAL_MASK(x, 23, 4)
-#define CABC_CTRL2			0x000001c8
-#define  V_CABC_STAGE_DOWN(x)			VAL_MASK(x, 8, 0)
-#define  V_CABC_STAGE_UP(x)			VAL_MASK(x, 9, 8)
-#define  V_CABC_STAGE_UP_MODE(x)		VAL_MASK(x, 1, 19)
-#define  V_MAX_SCALE_CFG_VALUE(x) 		VAL_MASK(x, 9, 20)
-#define  V_MAX_SCALE_CFG_ENABLE(x) 		VAL_MASK(x, 1, 31)
-#define CABC_CTRL3			0x000001cc
-#define  V_CABC_GLOBAL_DN(x)			VAL_MASK(x, 8, 0)
-#define  V_CABC_GLOBAL_DN_LIMIT_EN(x)		VAL_MASK(x, 1, 8)
-#define CABC_GAUSS_LINE0_0		0x000001d0
-#define  V_T_LINE0_0(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE0_1(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE0_2(x)				VAL_MASK(x, 8, 16)
-#define  V_T_LINE0_3(x)				VAL_MASK(x, 8, 24)
-#define CABC_GAUSS_LINE0_1		0x000001d4
-#define  V_T_LINE0_4(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE0_5(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE0_6(x)				VAL_MASK(x, 8, 16)
-#define CABC_GAUSS_LINE1_0		0x000001d8
-#define  V_T_LINE1_0(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE1_1(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE1_2(x)				VAL_MASK(x, 8, 16)
-#define  V_T_LINE1_3(x)				VAL_MASK(x, 8, 24)
-#define CABC_GAUSS_LINE1_1		0x000001dc
-#define  V_T_LINE1_4(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE1_5(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE1_6(x)				VAL_MASK(x, 8, 16)
-#define CABC_GAUSS_LINE2_0		0x000001e0
-#define  V_T_LINE2_0(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE2_1(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE2_2(x)				VAL_MASK(x, 8, 16)
-#define  V_T_LINE2_3(x)				VAL_MASK(x, 8, 24)
-#define CABC_GAUSS_LINE2_1		0x000001e4
-#define  V_T_LINE2_4(x)				VAL_MASK(x, 8, 0)
-#define  V_T_LINE2_5(x)				VAL_MASK(x, 8, 8)
-#define  V_T_LINE2_6(x)				VAL_MASK(x, 8, 16)
-#define FRC_LOWER01_0			0x000001e8
-#define  V_LOWER01_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER01_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER01_1			0x000001ec
-#define  V_LOWER01_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER01_FRM3(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER10_0			0x000001f0
-#define  V_LOWER10_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER10_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER10_1			0x000001f4
-#define  V_LOWER10_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER10_FRM3(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER11_0			0x000001f8
-#define  V_LOWER11_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER11_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER11_1			0x000001fc
-#define  V_LOWER11_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER11_FRM3(x)			VAL_MASK(x, 16, 16)
-#define AFBCD0_CTRL			0x00000200
-#define  V_VOP_FBDC_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_VOP_FBDC_WIN_SEL(x)			VAL_MASK(x, 2, 1)
-#define  V_FBDC_RSTN(x)				VAL_MASK(x, 1, 3)
-#define  V_VOP_FBDC_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
-#define  V_VOP_FBDC_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
-#define  V_FBDC_RID(x)				VAL_MASK(x, 4, 12)
-#define  V_AFBCD_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
-#define  V_AFBCD_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
-#define AFBCD0_HDR_PTR			0x00000204
-#define  V_AFBCD_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
-#define AFBCD0_PIC_SIZE			0x00000208
-#define  V_AFBCD_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
-#define  V_AFBCD_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
-#define AFBCD0_STATUS			0x0000020c
-#define  V_AFBCD_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
-#define  V_AFBCD_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
-#define  V_AFBCD_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
-#define AFBCD1_CTRL			0x00000220
-#define  V_VOP_FBDC1_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_VOP_FBDC1_WIN_SEL(x)			VAL_MASK(x, 2, 1)
-#define  V_FBDC1_RSTN(x)				VAL_MASK(x, 1, 3)
-#define  V_VOP_FBDC1_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
-#define  V_VOP_FBDC1_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
-#define  V_FBDC1_RID(x)				VAL_MASK(x, 4, 12)
-#define  V_AFBCD1_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
-#define  V_AFBCD1_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
-#define AFBCD1_HDR_PTR			0x00000224
-#define  V_AFBCD1_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
-#define AFBCD1_PIC_SIZE			0x00000228
-#define  V_AFBCD1_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
-#define  V_AFBCD1_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
-#define AFBCD1_STATUS			0x0000022c
-#define  V_AFBCD1_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
-#define  V_AFBCD1_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
-#define  V_AFBCD1_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
-#define AFBCD2_CTRL			0x00000240
-#define  V_VOP_FBDC2_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_VOP_FBDC2_WIN_SEL(x)			VAL_MASK(x, 2, 1)
-#define  V_FBDC2_RSTN(x)				VAL_MASK(x, 1, 3)
-#define  V_VOP_FBDC2_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
-#define  V_VOP_FBDC2_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
-#define  V_FBDC2_RID(x)				VAL_MASK(x, 4, 12)
-#define  V_AFBCD2_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
-#define  V_AFBCD2_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
-#define AFBCD2_HDR_PTR			0x00000244
-#define  V_AFBCD2_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
-#define AFBCD2_PIC_SIZE			0x00000248
-#define  V_AFBCD2_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
-#define  V_AFBCD2_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
-#define AFBCD2_STATUS			0x0000024c
-#define  V_AFBCD2_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
-#define  V_AFBCD2_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
-#define  V_AFBCD2_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
-#define AFBCD3_CTRL			0x00000260
-#define  V_VOP_FBDC3_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_VOP_FBDC3_WIN_SEL(x)			VAL_MASK(x, 1, 1)
-#define  V_FBDC3_RSTN(x)				VAL_MASK(x, 1, 2)
-#define  V_VOP_FBDC3_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 3)
-#define  V_VOP_FBDC3_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 8)
-#define  V_FBDC3_RID(x)				VAL_MASK(x, 4, 12)
-#define  V_AFBCD3_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
-#define  V_AFBCD3_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
-#define AFBCD3_HDR_PTR			0x00000264
-#define  V_AFBCD3_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
-#define AFBCD3_PIC_SIZE			0x00000268
-#define  V_AFBCD3_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
-#define  V_AFBCD3_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
-#define AFBCD3_STATUS			0x0000026c
-#define  V_AFBCD3_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
-#define  V_AFBCD3_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
-#define  V_AFBCD3_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
-#define INTR_EN0			0x00000280
-#define  V_INTR_EN_FS(x)			VAL_MASK(x, 1, 0)
-#define  V_INTR_EN_FS_NEW(x)			VAL_MASK(x, 1, 1)
-#define  V_INTR_EN_ADDR_SAME(x)			VAL_MASK(x, 1, 2)
-#define  V_INTR_EN_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
-#define  V_INTR_EN_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
-#define  V_INTR_EN_BUS_ERROR(x)			VAL_MASK(x, 1, 5)
-#define  V_INTR_EN_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
-#define  V_INTR_EN_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
-#define  V_INTR_EN_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
-#define  V_INTR_EN_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
-#define  V_INTR_EN_HWC_EMPTY(x)			VAL_MASK(x, 1, 10)
-#define  V_INTR_EN_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
-/* rk3399 only */
-#define  V_INTR_EN_FS_FIELD(x)			VAL_MASK(x, 1, 12)
-/* rk322x only */
-#define  V_INTR_EN_PWM_GEN(x)			VAL_MASK(x, 1, 12)
-#define  V_INTR_EN_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
-#define  V_INTR_EN_MMU(x)			VAL_MASK(x, 1, 14)
-#define  V_INTR_EN_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
-#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
-#define INTR_CLEAR0			0x00000284
-#define  V_INT_CLR_FS(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_CLR_FS_NEW(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_CLR_ADDR_SAME(x)			VAL_MASK(x, 1, 2)
-#define  V_INT_CLR_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
-#define  V_INT_CLR_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
-#define  V_INT_CLR_BUS_ERROR(x)			VAL_MASK(x, 1, 5)
-#define  V_INT_CLR_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
-#define  V_INT_CLR_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
-#define  V_INT_CLR_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
-#define  V_INT_CLR_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
-#define  V_INT_CLR_HWC_EMPTY(x)			VAL_MASK(x, 1, 10)
-#define  V_INT_CLR_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
-/* rk3399 only */
-#define  V_INT_CLR_FS_FIELD(x)			VAL_MASK(x, 1, 12)
-/* rk322x only */
-#define  V_INT_CLR_PWM_GEN(x)			VAL_MASK(x, 1, 12)
-#define  V_INT_CLR_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
-#define  V_INT_CLR_MMU(x)			VAL_MASK(x, 1, 14)
-#define  V_INT_CLR_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
-#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
-#define INTR_STATUS0			0x00000288
-#define  V_INT_STATUS_FS(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_STATUS_FS_NEW(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_STATUS_ADDR_SAME(x)		VAL_MASK(x, 1, 2)
-#define  V_INT_STATUS_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
-#define  V_INT_STATUS_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
-#define  V_INT_STATUS_BUS_ERROR(x)		VAL_MASK(x, 1, 5)
-#define  V_INT_STATUS_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
-#define  V_INT_STATUS_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
-#define  V_INT_STATUS_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
-#define  V_INT_STATUS_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
-#define  V_INT_STATUS_HWC_EMPTY(x)		VAL_MASK(x, 1, 10)
-#define  V_INT_STATUS_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
-/* rk3399 only */
-#define  V_INT_STATUS_FS_FIELD(x)		VAL_MASK(x, 1, 12)
-/* rk322x only */
-#define  V_INT_STATUS_PWM_GEN(x)		VAL_MASK(x, 1, 12)
-#define  V_INT_STATUS_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
-#define  V_INT_STATUS_MMU(x)			VAL_MASK(x, 1, 14)
-#define  V_INT_STATUS_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
-#define INTR_RAW_STATUS0		0x0000028c
-#define  V_INT_RAW_STATUS_FS(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_RAW_STATUS_FS_NEW(x)		VAL_MASK(x, 1, 1)
-#define  V_INT_RAW_STATUS_ADDR_SAME(x)		VAL_MASK(x, 1, 2)
-#define  V_INT_RAW_STATUS_LINE_FRAG0(x)		VAL_MASK(x, 1, 3)
-#define  V_INT_RAW_STATUS_LINE_FRAG1(x)		VAL_MASK(x, 1, 4)
-#define  V_INT_RAW_STATUS_BUS_ERROR(x)		VAL_MASK(x, 1, 5)
-#define  V_INT_RAW_STATUS_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
-#define  V_INT_RAW_STATUS_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
-#define  V_INT_RAW_STATUS_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
-#define  V_INT_RAW_STATUS_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
-#define  V_INT_RAW_STATUS_HWC_EMPTY(x)		VAL_MASK(x, 1, 10)
-#define  V_INT_RAW_STATUS_POST_BUF_EMPTY(x)	VAL_MASK(x, 1, 11)
-/* rk3399 only */
-#define  V_INT_RAW_STATUS_FS_FIELD(x)		VAL_MASK(x, 1, 12)
-/* rk322x only */
-#define  V_INT_RAW_STATUS_PWM_GEN(x)		VAL_MASK(x, 1, 12)
-#define  V_INT_RAW_STATUS_DSP_HOLD_VALID(x)	VAL_MASK(x, 1, 13)
-#define  V_INT_RAW_STATUS_MMU(x)		VAL_MASK(x, 1, 14)
-#define  V_INT_RAW_STATUS_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
-#define INTR_EN1			0x00000290
-#define  V_INT_EN_FBCD0(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_EN_FBCD1(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_EN_FBCD2(x)			VAL_MASK(x, 1, 2)
-#define  V_INT_EN_FBCD3(x)			VAL_MASK(x, 1, 3)
-#define  V_INT_EN_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
-#define  V_INT_EN_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
-#define  V_INT_EN_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
-#define  V_INT_EN_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
-#define  V_INT_EN_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
-#define  V_INT_EN_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
-#define  V_INT_EN_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
-#define  V_INT_EN_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
-#define  V_INT_EN_WB_YRGB_FIFO_FULL(x)		VAL_MASK(x, 1, 12)
-#define  V_INT_EN_WB_UV_FIFO_FULL(x)		VAL_MASK(x, 1, 13)
-#define  V_INT_EN_WB_FINISH(x)			VAL_MASK(x, 1, 14)
-#define  V_INT_EN_VFP(x)			VAL_MASK(x, 1, 15)
-#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
-#define INTR_CLEAR1			0x00000294
-#define  V_INT_CLR_FBCD0(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_CLR_FBCD1(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_CLR_FBCD2(x)			VAL_MASK(x, 1, 2)
-#define  V_INT_CLR_FBCD3(x)			VAL_MASK(x, 1, 3)
-#define  V_INT_CLR_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
-#define  V_INT_CLR_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
-#define  V_INT_CLR_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
-#define  V_INT_CLR_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
-#define  V_INT_CLR_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
-#define  V_INT_CLR_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
-#define  V_INT_CLR_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
-#define  V_INT_CLR_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
-#define  V_INT_CLR_WB_YRGB_FIFO_FULL(x)		VAL_MASK(x, 1, 12)
-#define  V_INT_CLR_WB_UV_FIFO_FULL(x)		VAL_MASK(x, 1, 13)
-#define  V_INT_CLR_WB_DMA_FINISH(x)		VAL_MASK(x, 1, 14)
-#define  V_INT_CLR_VFP(x)			VAL_MASK(x, 1, 15)
-#define INTR_STATUS1			0x00000298
-#define  V_INT_STATUS_FBCD0(x)			VAL_MASK(x, 1, 0)
-#define  V_INT_STATUS_FBCD1(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_STATUS_FBCD2(x)			VAL_MASK(x, 1, 2)
-#define  V_INT_STATUS_FBCD3(x)			VAL_MASK(x, 1, 3)
-#define  V_INT_STATUS_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
-#define  V_INT_STATUS_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
-#define  V_INT_STATUS_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
-#define  V_INT_STATUS_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
-#define  V_INT_STATUS_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
-#define  V_INT_STATUS_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
-#define  V_INT_STATUS_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
-#define  V_INT_STATUS_AFBCD4_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 11)
-#define  V_INT_STATUS_WB_YRGB_FIFO_FULL(x)	VAL_MASK(x, 1, 12)
-#define  V_INT_STATUS_WB_UV_FIFO_FULL(x)	VAL_MASK(x, 1, 13)
-#define  V_INT_STATUS_WB_DMA_FINISH(x)		VAL_MASK(x, 1, 14)
-#define  V_INT_STATUS_VFP(x)			VAL_MASK(x, 1, 15)
-#define INTR_RAW_STATUS1		0x0000029c
-#define  V_INT_RAW_STATUS_FBCD0(x)		VAL_MASK(x, 1, 0)
-#define  V_INT_RAW_STATUS_FBCD1(x)		VAL_MASK(x, 1, 1)
-#define  V_INT_RAW_STATUS_FBCD2(x)		VAL_MASK(x, 1, 2)
-#define  V_INT_RAW_STATUS_FBCD3(x)		VAL_MASK(x, 1, 3)
-#define  V_INT_RAW_STATUS_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
-#define  V_INT_RAW_STATUS_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
-#define  V_INT_RAW_STATUS_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
-#define  V_INT_RAW_STATUS_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
-#define  V_INT_RAW_STATUS_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
-#define  V_INT_RAW_STATUS_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
-#define  V_INT_RAW_STATUS_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
-#define  V_INT_RAW_STATUS_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
-#define  V_INT_RAW_STATUS_WB_YRGB_FIFO_FULL(x)	VAL_MASK(x, 1, 12)
-#define  V_INT_RAW_STATUS_WB_UV_FIFO_FULL(x)	VAL_MASK(x, 1, 13)
-#define  V_INT_RAW_STATUS_WB_DMA_FINISH(x)	VAL_MASK(x, 1, 14)
-#define  V_INT_RAW_STATUS_VFP(x)		VAL_MASK(x, 1, 15)
-#define LINE_FLAG			0x000002a0
-#define  V_DSP_LINE_FLAG_NUM_0(x)		VAL_MASK(x, 13, 0)
-#define  V_DSP_LINE_FLAG_NUM_1(x)		VAL_MASK(x, 13, 16)
-#define VOP_STATUS			0x000002a4
-#define  V_DSP_VCNT(x)				VAL_MASK(x, 13, 0)
-#define  V_MMU_IDLE(x)				VAL_MASK(x, 1, 16)
-#define  V_DMA_STOP_VALID(x)			VAL_MASK(x, 1, 17)
-#define BLANKING_VALUE			0x000002a8
-#define  V_BLANKING_VALUE(x)			VAL_MASK(x, 24, 0)
-#define  V_BLANKING_VALUE_CONFIG_EN(x)		VAL_MASK(x, 1, 24)
-#define MCU_BYPASS_PORT			0x000002ac
-#define WIN0_DSP_BG			0x000002b0
-#define  V_WIN0_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
-#define  V_WIN0_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
-#define  V_WIN0_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
-#define  V_WIN0_BG_EN(x)			VAL_MASK(x, 1, 31)
-#define WIN1_DSP_BG			0x000002b4
-#define  V_WIN1_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
-#define  V_WIN1_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
-#define  V_WIN1_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
-#define  V_WIN1_BG_EN(x)			VAL_MASK(x, 1, 31)
-#define WIN2_DSP_BG			0x000002b8
-#define  V_WIN2_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
-#define  V_WIN2_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
-#define  V_WIN2_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
-#define  V_WIN2_BG_EN(x)			VAL_MASK(x, 1, 31)
-#define WIN3_DSP_BG			0x000002bc
-#define  V_WIN3_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
-#define  V_WIN3_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
-#define  V_WIN3_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
-#define  V_WIN3_BG_EN(x)			VAL_MASK(x, 1, 31)
-#define YUV2YUV_WIN			0x000002c0
-#define  V_WIN0_YUV2YUV_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN0_YUV2YUV_Y2R_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN0_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN0_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 3)
-#define  V_WIN0_YUV2YUV_Y2R_MODE(x)		VAL_MASK(x, 2, 4)
-#define  V_WIN0_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 6)
-#define  V_WIN1_YUV2YUV_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_WIN1_YUV2YUV_Y2R_EN(x)		VAL_MASK(x, 1, 9)
-#define  V_WIN1_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 10)
-#define  V_WIN1_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 11)
-#define  V_WIN1_YUV2YUV_Y2R_MODE(x)		VAL_MASK(x, 2, 12)
-#define  V_WIN1_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 14)
-#define  V_WIN2_YUV2YUV_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_WIN2_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 18)
-#define  V_WIN2_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 19)
-#define  V_WIN2_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 22)
-#define  V_WIN3_YUV2YUV_EN(x)			VAL_MASK(x, 1, 24)
-#define  V_WIN3_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 26)
-#define  V_WIN3_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 27)
-#define  V_WIN3_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 30)
-#define YUV2YUV_POST			0x000002c4
-#define  V_YUV2YUV_POST_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_YUV2YUV_POST_Y2R_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_YUV2YUV_POST_R2Y_EN(x)		VAL_MASK(x, 1, 2)
-#define  V_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 3)
-#define  V_YUV2YUV_POST_Y2R_MODE(x)		VAL_MASK(x, 2, 4)
-#define  V_YUV2YUV_POST_R2Y_MODE(x)		VAL_MASK(x, 2, 6)
-#define AUTO_GATING_EN			0x000002cc
-#define  V_WIN0_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN1_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN2_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN3_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 3)
-#define  V_HWC_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 4)
-#define  V_OVERLAY_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 5)
-#define  V_GAMMA_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 6)
-#define  V_CABC_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 7)
-#define  V_WB_ACLK_GATING_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_PWM_PWMCLK_GATING_EN(x)		VAL_MASK(x, 1, 9)
-#define  V_DIRECT_PATH_ACLK_GATING_EN(x)	VAL_MASK(x, 1, 10)
-#define  V_FBCD0_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 12)
-#define  V_FBCD1_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 13)
-#define  V_FBCD2_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 14)
-#define  V_FBCD3_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 15)
-#define DBG_PERF_LATENCY_CTRL0		0x00000300
-#define  V_RD_LATENCY_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_HAND_LATENCY_CLR(x)			VAL_MASK(x, 1, 1)
-#define  V_RD_LATENCY_MODE(x)			VAL_MASK(x, 1, 2)
-#define  V_RD_LATENCY_ID0(x)			VAL_MASK(x, 4, 4)
-#define  V_RD_LATENCY_THR(x)			VAL_MASK(x, 12, 8)
-#define  V_RD_LATENCY_ST_NUM(x)			VAL_MASK(x, 5, 20)
-#define DBG_PERF_RD_MAX_LATENCY_NUM0	0x00000304
-#define  V_RD_MAX_LATENCY_NUM_CH0(x)		VAL_MASK(x, 12, 0)
-#define  V_RD_LATENCY_OVERFLOW_CH0(x)		VAL_MASK(x, 1, 16)
-#define DBG_PERF_RD_LATENCY_THR_NUM0	0x00000308
-#define  V_RD_LATENCY_THR_NUM_CH0(x)		VAL_MASK(x, 24, 0)
-#define DBG_PERF_RD_LATENCY_SAMP_NUM0	0x0000030c
-#define  V_RD_LATENCY_SAMP_NUM_CH0(x)		VAL_MASK(x, 24, 0)
-#define DBG_CABC0			0x00000310
-#define DBG_CABC1			0x00000314
-#define DBG_CABC2			0x00000318
-#define  V_PWM_MUL_POST_VALUE(x)		VAL_MASK(x, 8, 8)
-#define DBG_CABC3			0x0000031c
-#define DBG_WIN0_REG0			0x00000320
-#define DBG_WIN0_REG1			0x00000324
-#define DBG_WIN0_REG2			0x00000328
-#define  V_DBG_WIN0_YRGB_CMD_LINE_CNT(x)	VAL_MASK(x, 13, 16)
-#define DBG_WIN0_RESERVED		0x0000032c
-#define DBG_WIN1_REG0			0x00000330
-#define DBG_WIN1_REG1			0x00000334
-#define DBG_WIN1_REG2			0x00000338
-#define DBG_WIN1_RESERVED		0x0000033c
-#define DBG_WIN2_REG0			0x00000340
-#define DBG_WIN2_REG1			0x00000344
-#define DBG_WIN2_REG2			0x00000348
-#define DBG_WIN2_REG3			0x0000034c
-#define DBG_WIN3_REG0			0x00000350
-#define DBG_WIN3_REG1			0x00000354
-#define DBG_WIN3_REG2			0x00000358
-#define DBG_WIN3_REG3			0x0000035c
-#define DBG_PRE_REG0			0x00000360
-#define DBG_PRE_RESERVED		0x00000364
-#define DBG_POST_REG0			0x00000368
-#define DBG_POST_REG1			0x0000036c
-#define  V_GAMMA_A2HCLK_CHANGE_DONE(x)		VAL_MASK(x, 1, 0)
-#define  V_WHICH_GAMMA_LUT_WORKING(x)		VAL_MASK(x, 1, 1)
-#define DBG_DATAO			0x00000370
-#define  V_SW_DATAO_SEL(x)			VAL_MASK(x, 2, 30)
-#define DBG_DATAO_2			0x00000374
-#define  V_VOP_DATA_O_2(x)			VAL_MASK(x, 30, 0)
-#define  V_SW_DATAO_SEL_2(x)			VAL_MASK(x, 2, 30)
-#define WIN0_CSC_COE			0x000003a0
-#define WIN1_CSC_COE			0x000003c0
-#define WIN2_CSC_COE			0x000003e0
-#define WIN3_CSC_COE			0x00000400
-#define HWC_CSC_COE			0x00000420
-#define BCSH_R2Y_CSC_COE		0x00000440
-#define BCSH_Y2R_CSC_COE		0x00000460
-#define POST_YUV2YUV_Y2R_COE		0x00000480
-#define POST_YUV2YUV_3x3_COE		0x000004a0
-#define POST_YUV2YUV_R2Y_COE		0x000004c0
-#define WIN0_YUV2YUV_Y2R		0x000004e0
-#define WIN0_YUV2YUV_R2R		0x00000500
-#define WIN0_YUV2YUV_R2Y		0x00000520
-#define WIN1_YUV2YUV_Y2R		0x00000540
-#define WIN1_YUV2YUV_R2R		0x00000560
-#define WIN1_YUV2YUV_R2Y		0x00000580
-#define WIN2_YUV2YUV_Y2R		0x000005a0
-#define WIN2_YUV2YUV_R2R		0x000005c0
-#define WIN2_YUV2YUV_R2Y		0x000005e0
-#define WIN3_YUV2YUV_Y2R		0x00000600
-#define WIN3_YUV2YUV_R2R		0x00000620
-#define WIN3_YUV2YUV_R2Y		0x00000640
-#define WIN2_LUT_ADDR			0x00001000
-#define  V_WIN2_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
-#define WIN3_LUT_ADDR			0x00001400
-#define  V_WIN3_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
-#define HWC_LUT_ADDR			0x00001800
-#define  V_HWC_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
-#define CABC_GAMMA_LUT_ADDR		0x00001c00
-#define  V_GAMMA_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
-#define GAMMA_LUT_ADDR			0x00002000
-#define  V_GAMMA_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
-#define TVE				0x00003e00
-
-#define  INTR_FS			(1 << 0)
-#define  INTR_FS_NEW			(1 << 1)
-#define  INTR_ADDR_SAME			(1 << 2)
-#define  INTR_LINE_FLAG0		(1 << 3)
-#define  INTR_LINE_FLAG1		(1 << 4)
-#define  INTR_BUS_ERROR			(1 << 5)
-#define  INTR_WIN0_EMPTY		(1 << 6)
-#define  INTR_WIN1_EMPTY		(1 << 7)
-#define  INTR_WIN2_EMPTY		(1 << 8)
-#define  INTR_WIN3_EMPTY		(1 << 9)
-#define  INTR_HWC_EMPTY			(1 << 10)
-#define  INTR_POST_BUF_EMPTY		(1 << 11)
-/* rk322x */
-#define  INTR_PWM_GEN			(1 << 12)
-/* rk3399 */
-#define  INTR_FS_FIELD			(1 << 12)
-#define  INTR_DSP_HOLD_VALID		(1 << 13)
-#define  INTR_MMU			(1 << 14)
-#define  INTR_DMA_FINISH		(1 << 15)
-
-#define INTR_MASK (INTR_FS | INTR_FS_NEW | INTR_ADDR_SAME | INTR_LINE_FLAG0 | \
-			INTR_LINE_FLAG1 | INTR_BUS_ERROR | INTR_WIN0_EMPTY | \
-			INTR_WIN1_EMPTY | INTR_WIN2_EMPTY | INTR_WIN3_EMPTY | \
-			INTR_HWC_EMPTY | INTR_POST_BUF_EMPTY | INTR_PWM_GEN | \
-			INTR_DSP_HOLD_VALID | INTR_MMU | INTR_DMA_FINISH)
-
-#define  INTR1_FBCD0			(1 << 0)
-#define  INTR1_FBCD1			(1 << 1)
-#define  INTR1_FBCD2			(1 << 2)
-#define  INTR1_FBCD3			(1 << 3)
-#define  INTR1_AFBCD0_HREG_DEC_RESP	(1 << 4)
-#define  INTR1_AFBCD0_HREG_AXI_RRESP	(1 << 5)
-#define  INTR1_AFBCD1_HREG_DEC_RESP	(1 << 6)
-#define  INTR1_AFBCD1_HREG_AXI_RRESP	(1 << 7)
-#define  INTR1_AFBCD2_HREG_DEC_RESP	(1 << 8)
-#define  INTR1_AFBCD2_HREG_AXI_RRESP	(1 << 9)
-#define  INTR1_AFBCD3_HREG_DEC_RESP	(1 << 10)
-#define  INTR1_AFBCD3_HREG_AXI_RRESP	(1 << 11)
-#define  INTR1_WB_YRGB_FIFO_FULL	(1 << 12)
-#define  INTR1_WB_UV_FIFO_FULL		(1 << 13)
-#define  INTR1_WB_FINISH		(1 << 14)
-
-#define OUT_CCIR656_MODE_0              5
-#define OUT_CCIR656_MODE_1              6
-#define OUT_CCIR656_MODE_2              7
-
-#define AFBDC_RGB_COLOR_TRANSFORM	0
-#define AFBDC_YUV_COLOR_TRANSFORM	1
-
-enum cabc_stage_mode {
-	LAST_FRAME_PWM_VAL	= 0x0,
-	CUR_FRAME_PWM_VAL	= 0x1,
-	STAGE_BY_STAGE		= 0x2
-};
-
-enum {
-	VOP_RK322X,
-	VOP_RK3399,
-};
-
-enum {
-	VOP_WIN0,
-	VOP_WIN1,
-	VOP_WIN2,
-	VOP_WIN3,
-	VOP_HWC,
-	VOP_WIN_MAX,
-};
-
-struct vop_data {
-	int chip_type;
-	struct rk_lcdc_win *win;
-	int n_wins;
-};
-
-struct vop_device {
-	int id;
-	const struct vop_data *data;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-	struct regmap *grf_base;
-
-	void __iomem *regs;
-	void *regsbak;
-	u32 reg_phy_base;
-	u32 len;
-
-	int __iomem *dsp_lut_addr_base;
-	int __iomem *cabc_lut_addr_base;
-	/* one time only one process allowed to config the register */
-	spinlock_t reg_lock;
-
-	int prop;		/*used for primary or extended display device*/
-	bool pre_init;
-	bool pwr18;		/*if lcdc use 1.8v power supply*/
-	/*if aclk or hclk is closed ,acess to register is not allowed*/
-	bool clk_on;
-	/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
-	u8 atv_layer_cnt;
-	/* point write back status */
-	bool wb_on;
-
-	unsigned int		irq;
-
-	struct clk		*hclk;		/*lcdc AHP clk*/
-	struct clk		*dclk;		/*lcdc dclk*/
-	struct clk		*aclk;		/*lcdc share memory frequency*/
-	struct clk		*hclk_noc;
-	struct clk		*aclk_noc;
-	u32 pixclock;
-
-	u32 standby;				/*1:standby,0:wrok*/
-	u32 iommu_status;
-	struct backlight_device *backlight;
-	struct clk		*pll_sclk;
-
-	/* lock vop irq reg */
-	spinlock_t irq_lock;
-	struct devfreq *devfreq;
-	struct devfreq_event_dev *devfreq_event_dev;
-	struct notifier_block dmc_nb;
-	int dmc_in_process;
-	int vop_switch_status;
-	wait_queue_head_t wait_dmc_queue;
-	wait_queue_head_t wait_vop_switch_queue;
-};
-
-static inline void vop_writel(struct vop_device *vop_dev, u32 offset, u32 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	*_pv = v;
-	writel_relaxed(v, vop_dev->regs + offset);
-}
-
-static inline u32 vop_readl(struct vop_device *vop_dev, u32 offset)
-{
-	u32 v;
-
-	v = readl_relaxed(vop_dev->regs + offset);
-	return v;
-}
-
-static inline u32 vop_readl_backup(struct vop_device *vop_dev, u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	v = readl_relaxed(vop_dev->regs + offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 vop_read_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 _v = readl_relaxed(vop_dev->regs + offset);
-
-	_v &= v >> 32;
-	v = (_v ? 1 : 0);
-	return v;
-}
-
-static inline void vop_set_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) |= v >> 32;
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_clr_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~(v >> 32));
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_msk_reg(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~(v >> 32));
-	(*_pv) |= (u32)v;
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_msk_reg_nobak(struct vop_device *vop_dev,
-				     u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	writel_relaxed((*_pv & (~(v >> 32))) | (u32)v, vop_dev->regs + offset);
-}
-
-static inline void vop_mask_writel(struct vop_device *vop_dev, u32 offset,
-				   u32 mask, u32 v)
-{
-	v = mask << 16 | v;
-	writel_relaxed(v , vop_dev->regs + offset);
-}
-
-static inline void vop_cfg_done(struct vop_device *vop_dev)
-{
-	writel_relaxed(0x001f001f, vop_dev->regs + REG_CFG_DONE);
-	dsb(sy);
-}
-
-static inline int vop_grf_writel(struct regmap *base, u32 offset, u32 val)
-{
-	regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int vop_cru_writel(struct regmap *base, u32 offset, u32 val)
-{
-	regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int vop_cru_readl(struct regmap *base, u32 offset)
-{
-	u32 v;
-
-	regmap_read(base, offset, &v);
-
-	return v;
-}
-
-enum lb_mode {
-	LB_YUV_3840X5 = 0x0,
-	LB_YUV_2560X8 = 0x1,
-	LB_RGB_3840X2 = 0x2,
-	LB_RGB_2560X4 = 0x3,
-	LB_RGB_1920X5 = 0x4,
-	LB_RGB_1280X8 = 0x5
-};
-
-enum sacle_up_mode {
-	SCALE_UP_BIL = 0x0,
-	SCALE_UP_BIC = 0x1
-};
-
-enum scale_down_mode {
-	SCALE_DOWN_BIL = 0x0,
-	SCALE_DOWN_AVG = 0x1
-};
-
-/*ALPHA BLENDING MODE*/
-enum alpha_mode {               /*  Fs       Fd */
-	AB_USER_DEFINE     = 0x0,
-	AB_CLEAR	   = 0x1,/*  0          0*/
-	AB_SRC		   = 0x2,/*  1          0*/
-	AB_DST		   = 0x3,/*  0          1  */
-	AB_SRC_OVER	   = 0x4,/*  1		    1-As''*/
-	AB_DST_OVER	   = 0x5,/*  1-Ad''   1*/
-	AB_SRC_IN	   = 0x6,
-	AB_DST_IN	   = 0x7,
-	AB_SRC_OUT	   = 0x8,
-	AB_DST_OUT	   = 0x9,
-	AB_SRC_ATOP        = 0xa,
-	AB_DST_ATOP	   = 0xb,
-	XOR                = 0xc,
-	AB_SRC_OVER_GLOBAL = 0xd
-}; /*alpha_blending_mode*/
-
-enum src_alpha_mode {
-	AA_STRAIGHT	   = 0x0,
-	AA_INVERSE         = 0x1
-};/*src_alpha_mode*/
-
-enum global_alpha_mode {
-	AA_GLOBAL	  = 0x0,
-	AA_PER_PIX        = 0x1,
-	AA_PER_PIX_GLOBAL = 0x2
-};/*src_global_alpha_mode*/
-
-enum src_alpha_sel {
-	AA_SAT		= 0x0,
-	AA_NO_SAT	= 0x1
-};/*src_alpha_sel*/
-
-enum src_color_mode {
-	AA_SRC_PRE_MUL	       = 0x0,
-	AA_SRC_NO_PRE_MUL      = 0x1
-};/*src_color_mode*/
-
-enum factor_mode {
-	AA_ZERO			= 0x0,
-	AA_ONE			= 0x1,
-	AA_SRC			= 0x2,
-	AA_SRC_INVERSE          = 0x3,
-	AA_SRC_GLOBAL           = 0x4
-};/*src_factor_mode  &&  dst_factor_mode*/
-
-enum _vop_r2y_csc_mode {
-	VOP_R2Y_CSC_BT601 = 0,
-	VOP_R2Y_CSC_BT709,
-	VOP_R2Y_CSC_BT601_F,
-	VOP_R2Y_CSC_BT2020
-};
-
-enum _vop_y2r_csc_mode {
-	VOP_Y2R_CSC_MPEG = 0,
-	VOP_Y2R_CSC_JPEG,
-	VOP_Y2R_CSC_HD,
-	VOP_Y2R_CSC_BYPASS
-};
-enum _vop_format {
-	VOP_FORMAT_ARGB888 = 0,
-	VOP_FORMAT_RGB888,
-	VOP_FORMAT_RGB565,
-	VOP_FORMAT_YCBCR420 = 4,
-	VOP_FORMAT_YCBCR422,
-	VOP_FORMAT_YCBCR444
-};
-
-#define IS_YUV(x) ((x) >= VOP_FORMAT_YCBCR420)
-
-enum _vop_overlay_mode {
-	VOP_RGB_DOMAIN,
-	VOP_YUV_DOMAIN
-};
-
-struct alpha_config {
-	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
-	u32 src_global_alpha_val; /*win0_src_global_alpha*/
-	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
-	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
-	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
-	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
-	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
-};
-
-struct lcdc_cabc_mode {
-	u32 pixel_num;			/* pixel precent number */
-	u16 stage_up;			/* up stride */
-	u16 stage_down;		/* down stride */
-	u16 global_su;
-};
-
-#define CUBIC_PRECISE  0
-#define CUBIC_SPLINE   1
-#define CUBIC_CATROM   2
-#define CUBIC_MITCHELL 3
-
-#define AFBDC_FMT_RGB565	0x0
-#define AFBDC_FMT_U8U8U8U8	0x5 /*ARGB888*/
-#define AFBDC_FMT_U8U8U8	0x4 /*RGBP888*/
-
-#define CUBIC_MODE_SELETION      CUBIC_PRECISE
-
-/*************************************************************/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      \
-	((INT32)((x) * (1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
-
-#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
-#define SCALE_FACTOR_AVRG_FIXPOINT(x)      \
-	((INT32)((x) * (1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
-#define SCALE_FACTOR_BIC_FIXPOINT(x)       \
-	((INT32)((x) * (1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
-#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
-
-/*********************************************************/
-
-/*#define GET_SCALE_FACTOR_BILI(src, dst)  \
-	((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*#define GET_SCALE_FACTOR_BIC(src, dst)   \
-	((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*modified by hpz*/
-#define GET_SCALE_FACTOR_BILI_DN(src, dst)  \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-#define GET_SCALE_FACTOR_BILI_UP(src, dst)  \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-#define GET_SCALE_FACTOR_BIC(src, dst)      \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-
-/*********************************************************/
-/*NOTE: hardware in order to save resource , srch first to get interlace line
-(srch+vscalednmult-1)/vscalednmult; and do scale*/
-#define GET_SCALE_DN_ACT_HEIGHT(srch, vscalednmult) \
-	(((srch) + (vscalednmult) - 1) / (vscalednmult))
-
-/*#define VSKIP_MORE_PRECISE*/
-
-#ifdef VSKIP_MORE_PRECISE
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
-	(GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
-	(vscalednmult)), (dsth)))
-#else
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
-	((GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == (dsth)) \
-	? (GET_SCALE_FACTOR_BILI_DN((srch) , (dsth)) / (vscalednmult)) \
-	: (GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == ((dsth) * 2)) \
-	?  GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT(((srch) - 1),\
-	(vscalednmult)) , (dsth)) : \
-	GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
-	(vscalednmult)) , (dsth)))
-
-#endif
-/*****************************************************************/
-
-/*scalefactor must >= dst/src, or pixels at end of line may be unused*/
-/*scalefactor must < dst/(src-1), or dst buffer may overflow*/
-/*avrg old code: ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))\
-	/((src) - 1)) hxx_chgsrc*/
-/*modified by hpz:*/
-#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << \
-	(SCALE_FACTOR_AVRG_FIXPOINT_SHIFT + 1))) / (2 * (src) - 1))
-
-/*************************************************************************/
-/*Scale Coordinate Accumulate, x.16*/
-#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
-#define SCALE_COOR_ACC_FIXPOINT_ONE (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
-#define SCALE_COOR_ACC_FIXPOINT(x) \
-	((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
-#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) \
-	((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT - 1)) + 1) >> 1)
-
-#define SCALE_GET_COOR_ACC_FIXPOINT(scalefactor, factorfixpointshift)  \
-	((scalefactor) << \
-	(SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorfixpointshift)))
-
-/************************************************************************/
-/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
-#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
-#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       \
-	(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
-#define SCALE_FILTER_FACTOR_FIXPOINT(x)        \
-	((INT32)((x) * (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
-#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) \
-	((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
-
-#define SCALE_GET_FILTER_FACTOR_FIXPOINT(cooraccumulate, \
-	cooraccfixpointshift) \
-	(((cooraccumulate) >> \
-	((cooraccfixpointshift) - SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)) & \
-	(SCALE_FILTER_FACTOR_FIXPOINT_ONE - 1))
-
-#define SCALE_OFFSET_FIXPOINT_SHIFT            8
-#define SCALE_OFFSET_FIXPOINT(x)              \
-	((INT32)((x) * (1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
-
-static inline u32 vop_get_hard_ware_vskiplines(u32 srch, u32 dsth)
-{
-	u32 vscalednmult;
-
-	if (srch >= (u32) (4 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
-		vscalednmult = 4;
-	else if (srch >= (u32) (2 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
-		vscalednmult = 2;
-	else
-		vscalednmult = 1;
-
-	return vscalednmult;
-}
-
-#endif
diff --git a/drivers/video/rockchip/lcdc/rk3288_lcdc.c b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
deleted file mode 100755
index 870d22f678da..000000000000
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.c
+++ /dev/null
@@ -1,4238 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk3288_lcdc.c
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *Author:hjc<hjc@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/rockchip-iovmm.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/common.h>
-#include <dt-bindings/clock/rk_system_status.h>
-
-#include "rk3288_lcdc.h"
-
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-#include <linux/earlysuspend.h>
-#endif
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		printk(KERN_INFO x); } while (0)
-
-static int rk3288_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv,
-				     bool enable);
-
-struct fb_info *rk_get_fb(int fb_id);
-/*#define WAIT_FOR_SYNC 1*/
-
-static int rk3288_lcdc_get_id(u32 phy_base)
-{
-	if (cpu_is_rk3288()) {
-		if (phy_base == 0xff930000)/*vop big*/
-			return 0;
-		else if (phy_base == 0xff940000)/*vop lit*/	
-			return 1;
-		else
-			return -EINVAL;
-	} else {
-		pr_err("un supported platform \n");
-		return -EINVAL;
-	}
-}
-
-static int rk3288_lcdc_set_lut(struct rk_lcdc_driver *dev_drv)
-{
-	int i,j;
-	int __iomem *c;
-	u32 v,r,g,b;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device,driver);
-	if (dev_drv->cur_screen->dsp_lut)
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-			     v_DSP_LUT_EN(0));
-	if ((dev_drv->cur_screen->cabc_lut) &&
-	    (dev_drv->version == VOP_FULL_RK3288_V1_1))
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
-			     v_CABC_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	if (dev_drv->cur_screen->dsp_lut) {
-		for (i = 0; i < 256; i++) {
-			v = dev_drv->cur_screen->dsp_lut[i];
-			c = lcdc_dev->dsp_lut_addr_base + (i << 2);
-			b = (v & 0xff) << 2;
-			g = (v & 0xff00) << 4;
-			r = (v & 0xff0000) << 6;
-			v = r + g + b;
-			for (j = 0; j < 4; j++) {
-				writel_relaxed(v, c);
-				v += (1 + (1 << 10) + (1 << 20));
-				c++;
-			}
-		}
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-			     v_DSP_LUT_EN(1));
-	}
-	if ((dev_drv->cur_screen->cabc_lut) &&
-	    (dev_drv->version == VOP_FULL_RK3288_V1_1)) {
-		for (i = 0; i < 128; i++) {
-			v = dev_drv->cur_screen->cabc_lut[i];
-			lcdc_writel(lcdc_dev, i * 4 + CABC_LUT_ADDR, v);
-		}
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
-			     v_CABC_LUT_EN(1));
-	}
-
-	return 0;
-
-}
-
-static int rk3288_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 1;
-	return 0;
-#endif	
-	if (!lcdc_dev->clk_on) {
-		clk_prepare_enable(lcdc_dev->hclk);
-		clk_prepare_enable(lcdc_dev->dclk);
-		clk_prepare_enable(lcdc_dev->aclk);
-		clk_prepare_enable(lcdc_dev->pd);
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rk3288_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 0;
-	return 0;
-#endif	
-	if (lcdc_dev->clk_on) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		clk_disable_unprepare(lcdc_dev->dclk);
-		clk_disable_unprepare(lcdc_dev->hclk);
-		clk_disable_unprepare(lcdc_dev->aclk);
-		clk_disable_unprepare(lcdc_dev->pd);
-	}
-
-	return 0;
-}
-
-static int rk3288_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
-{	
-	u32 mask, val;
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_DSP_HOLD_VALID_INTR_EN | m_FS_INTR_EN |
-			m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_EN;
-		val = v_DSP_HOLD_VALID_INTR_EN(0) | v_FS_INTR_EN(0) |
-			v_LINE_FLAG_INTR_EN(0) | v_BUS_ERROR_INTR_EN(0);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
-
-		mask = m_DSP_HOLD_VALID_INTR_CLR | m_FS_INTR_CLR |
-			m_LINE_FLAG_INTR_CLR | m_LINE_FLAG_INTR_CLR;
-		val = v_DSP_HOLD_VALID_INTR_CLR(0) | v_FS_INTR_CLR(0) |
-			v_LINE_FLAG_INTR_CLR(0) | v_BUS_ERROR_INTR_CLR(0);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
-
-		mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
-			m_WIN2_EMPTY_INTR_EN | m_WIN3_EMPTY_INTR_EN |
-			m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
-			m_POST_BUF_EMPTY_INTR_EN;
-		val = v_WIN0_EMPTY_INTR_EN(0) | v_WIN1_EMPTY_INTR_EN(0) |
-			v_WIN2_EMPTY_INTR_EN(0) | v_WIN3_EMPTY_INTR_EN(0) |
-			v_HWC_EMPTY_INTR_EN(0) | v_POST_BUF_EMPTY_INTR_EN(0) |
-			v_PWM_GEN_INTR_EN(0);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);
-
-		mask = m_WIN0_EMPTY_INTR_CLR | m_WIN1_EMPTY_INTR_CLR |
-			m_WIN2_EMPTY_INTR_CLR | m_WIN3_EMPTY_INTR_CLR |
-			m_HWC_EMPTY_INTR_CLR | m_POST_BUF_EMPTY_INTR_CLR |
-			m_POST_BUF_EMPTY_INTR_CLR;
-		val = v_WIN0_EMPTY_INTR_CLR(0) | v_WIN1_EMPTY_INTR_CLR(0) |
-			v_WIN2_EMPTY_INTR_CLR(0) | v_WIN3_EMPTY_INTR_CLR(0) |
-			v_HWC_EMPTY_INTR_CLR(0) | v_POST_BUF_EMPTY_INTR_CLR(0) |
-			v_PWM_GEN_INTR_CLR(0);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);		
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-	return 0;
-}
-static int rk3288_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						struct lcdc_device,
-						driver);
-	int *cbase = (int *)lcdc_dev->regs;
-	int *regsbak = (int *)lcdc_dev->regsbak;
-	int i, j;
-
-	printk("back up reg:\n");
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		printk("0x%04x: ",i*16);
-		for (j = 0; j < 4; j++)
-			printk("%08x  ", *(regsbak + i * 4 + j));
-		printk("\n");
-	}
-
-	printk("lcdc reg:\n");
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		printk("0x%04x: ",i*16);
-		for (j = 0; j < 4; j++)
-			printk("%08x  ", readl_relaxed(cbase + i * 4 + j));
-		printk("\n");
-	}
-	return 0;
-
-}
-
-#define WIN_EN(id)		\
-static int win##id##_enable(struct lcdc_device *lcdc_dev, int en)	\
-{ \
-	u32 msk, val;							\
-	spin_lock(&lcdc_dev->reg_lock);					\
-	msk =  m_WIN##id##_EN;						\
-	val  =  v_WIN##id##_EN(en);					\
-	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);		\
-	lcdc_cfg_done(lcdc_dev);					\
-	/*val = lcdc_read_bit(lcdc_dev, WIN##id##_CTRL0, msk);		\
-	while (val !=  (!!en))	{					\
-		val = lcdc_read_bit(lcdc_dev, WIN##id##_CTRL0, msk);	\
-	}*/								\
-	spin_unlock(&lcdc_dev->reg_lock);				\
-	return 0;							\
-}
-
-WIN_EN(0);
-WIN_EN(1);
-WIN_EN(2);
-WIN_EN(3);
-/*enable/disable win directly*/
-static int rk3288_lcdc_win_direct_en
-		(struct rk_lcdc_driver *drv, int win_id , int en)
-{
-	struct lcdc_device *lcdc_dev = container_of(drv,
-					struct lcdc_device, driver);
-	if (win_id == 0)
-		win0_enable(lcdc_dev, en);
-	else if (win_id == 1)
-		win1_enable(lcdc_dev, en);
-	else if (win_id == 2)
-		win2_enable(lcdc_dev, en);
-	else if (win_id == 3)
-		win3_enable(lcdc_dev, en);
-	else
-		dev_err(lcdc_dev->dev, "invalid win number:%d\n", win_id);
-	return 0;
-		
-}
-
-#define SET_WIN_ADDR(id) \
-static int set_win##id##_addr(struct lcdc_device *lcdc_dev, u32 addr) \
-{							\
-	u32 msk, val;					\
-	spin_lock(&lcdc_dev->reg_lock);			\
-	lcdc_writel(lcdc_dev,WIN##id##_YRGB_MST,addr);	\
-	msk =  m_WIN##id##_EN;				\
-	val  =  v_WIN0_EN(1);				\
-	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk,val);	\
-	lcdc_cfg_done(lcdc_dev);			\
-	spin_unlock(&lcdc_dev->reg_lock);		\
-	return 0;					\
-}
-
-SET_WIN_ADDR(0);
-SET_WIN_ADDR(1);
-int rk3288_lcdc_direct_set_win_addr
-		(struct rk_lcdc_driver *dev_drv, int win_id, u32 addr)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-				struct lcdc_device, driver);
-	if (win_id == 0)
-		set_win0_addr(lcdc_dev, addr);
-	else
-		set_win1_addr(lcdc_dev, addr);
-	
-	return 0;
-}
-
-static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
-{
-	int reg = 0;
-	u32 val = 0;
-	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
-	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
-	u32 v_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
-	u32 st_x, st_y;
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	memcpy(lcdc_dev->regsbak, lcdc_dev->regs, FRC_LOWER11_1);
-	for (reg = 0; reg < FRC_LOWER11_1; reg += 4) {
-		val = lcdc_readl(lcdc_dev, reg);
-		switch (reg) {
-		case VERSION_INFO:
-			lcdc_dev->driver.version = val;
-			break;
-			case WIN0_ACT_INFO:
-				win0->area[0].xact =
-					(val & m_WIN0_ACT_WIDTH) + 1;
-				win0->area[0].yact =
-					((val & m_WIN0_ACT_HEIGHT) >> 16) + 1;
-				break;
-			case WIN0_DSP_INFO:
-				win0->area[0].xsize =
-					(val & m_WIN0_DSP_WIDTH) + 1;
-				win0->area[0].ysize =
-					((val & m_WIN0_DSP_HEIGHT) >> 16) + 1;
-				break;
-			case WIN0_DSP_ST:
-				st_x = val & m_WIN0_DSP_XST;
-				st_y = (val & m_WIN0_DSP_YST) >> 16;
-				win0->area[0].xpos = st_x - h_pw_bp;
-				win0->area[0].ypos = st_y - v_pw_bp;
-				break;
-			case WIN0_CTRL0:
-				win0->state = val & m_WIN0_EN;
-				win0->area[0].fmt_cfg =
-					(val & m_WIN0_DATA_FMT) >> 1;
-				win0->fmt_10 = (val & m_WIN0_FMT_10) >> 4;
-				win0->area[0].format = win0->area[0].fmt_cfg;
-				break;
-			case WIN0_VIR:
-				win0->area[0].y_vir_stride =
-					val & m_WIN0_VIR_STRIDE;
-				win0->area[0].uv_vir_stride =
-					(val & m_WIN0_VIR_STRIDE_UV) >> 16;
-				if (win0->area[0].format == ARGB888)
-					win0->area[0].xvir =
-						win0->area[0].y_vir_stride;
-				else if (win0->area[0].format == RGB888)
-					win0->area[0].xvir =
-						win0->area[0].y_vir_stride * 4 / 3;
-				else if (win0->area[0].format == RGB565)
-					win0->area[0].xvir =
-						2 * win0->area[0].y_vir_stride;
-				else /* YUV */
-					win0->area[0].xvir =
-						4 * win0->area[0].y_vir_stride;
-				break;
-			case WIN0_YRGB_MST:
-				win0->area[0].smem_start = val;
-				break;
-			case WIN0_CBR_MST:
-				win0->area[0].cbr_start = val;
-				break;
-			case DSP_VACT_ST_END:
-				if (support_uboot_display()) {
-					screen->mode.yres =
-					(val & 0x1fff) - ((val >> 16) & 0x1fff);
-					win0->area[0].ypos =
-					st_y - ((val >> 16) & 0x1fff);
-				}
-				break;
-			case DSP_HACT_ST_END:
-				if (support_uboot_display()) {
-					screen->mode.xres =
-					(val & 0x1fff) - ((val >> 16) & 0x1fff);
-					win0->area[0].xpos =
-					st_x - ((val >> 16) & 0x1fff);
-				}
-				break;
-			default:
-				break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-}
-
-/********do basic init*********/
-static int rk3288_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	int v;
-	u32 mask,val;
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-						   driver);
-	if (lcdc_dev->pre_init)
-		return 0;
-
-	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
-	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
-	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
-	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
-	
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||
-	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
-			lcdc_dev->id);
-	}
-	if (!support_uboot_display())
-		rk_disp_pwr_enable(dev_drv);
-	rk3288_lcdc_clk_enable(lcdc_dev);
-
-	/*backup reg config at uboot*/
-	lcdc_read_reg_defalut_cfg(lcdc_dev);
-	v = 0;
-#ifndef CONFIG_RK_FPGA
-	if (lcdc_dev->pwr18 == true) {
-		v = 0x00010001;	/*bit14: 1,1.8v;0,3.3v*/
-		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_IO_VSEL);
-	} else {
-		v = 0x00010000;
-		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_IO_VSEL);
-	}
-#endif	
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_0,0x15110903);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_1,0x00030911);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_0,0x1a150b04);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_1,0x00040b15);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_0,0x15110903);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_1,0x00030911);
-
-	lcdc_writel(lcdc_dev,FRC_LOWER01_0,0x12844821);
-	lcdc_writel(lcdc_dev,FRC_LOWER01_1,0x21488412);
-	lcdc_writel(lcdc_dev,FRC_LOWER10_0,0xa55a9696);
-	lcdc_writel(lcdc_dev,FRC_LOWER10_1,0x5aa56969);
-	lcdc_writel(lcdc_dev,FRC_LOWER11_0,0xdeb77deb);
-	lcdc_writel(lcdc_dev,FRC_LOWER11_1,0xed7bb7de);
-
-	mask =  m_AUTO_GATING_EN;
-	val  =  v_AUTO_GATING_EN(0);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask,val);
-	lcdc_cfg_done(lcdc_dev);
-	/*disable win0 to workaround iommu pagefault */
-	/*if (dev_drv->iommu_enabled) */
-	/*      win0_enable(lcdc_dev, 0); */
-	lcdc_dev->pre_init = true;
-
-
-	return 0;
-}
-
-static void rk3288_lcdc_deint(struct lcdc_device *lcdc_dev)
-{
-
-	
-	rk3288_lcdc_disable_irq(lcdc_dev);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_dev->clk_on = 0;
-		lcdc_set_bit(lcdc_dev, SYS_CTRL, m_STANDBY_EN);
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-}
-static int rk3288_lcdc_post_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	u16 h_total,v_total;
-	u16 post_hsd_en,post_vsd_en;
-	u16 post_dsp_hact_st,post_dsp_hact_end;	
-	u16 post_dsp_vact_st,post_dsp_vact_end;
-	u16 post_dsp_vact_st_f1,post_dsp_vact_end_f1;
-	u16 post_h_fac,post_v_fac;
-
-	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
-	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
-	screen->post_xsize = x_res *
-		(dev_drv->overscan.left + dev_drv->overscan.right) / 200;
-	screen->post_ysize = y_res *
-		(dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
-	h_total = screen->mode.hsync_len+screen->mode.left_margin +
-		  x_res + screen->mode.right_margin;
-	v_total = screen->mode.vsync_len+screen->mode.upper_margin +
-		  y_res + screen->mode.lower_margin;
-
-	if(screen->post_dsp_stx + screen->post_xsize > x_res){		
-		dev_warn(lcdc_dev->dev, "post:stx[%d] + xsize[%d] > x_res[%d]\n",
-			screen->post_dsp_stx,screen->post_xsize,x_res);
-		screen->post_dsp_stx = x_res - screen->post_xsize;
-	}
-	if(screen->x_mirror == 0){
-		post_dsp_hact_st=screen->post_dsp_stx + 
-			screen->mode.hsync_len+screen->mode.left_margin;
-		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
-	}else{
-		post_dsp_hact_end = h_total - screen->mode.right_margin -
-					screen->post_dsp_stx;
-		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
-	}	
-	if((screen->post_xsize < x_res)&&(screen->post_xsize != 0)){
-		post_hsd_en = 1;
-		post_h_fac = 
-			GET_SCALE_FACTOR_BILI_DN(x_res , screen->post_xsize); 
-	}else{
-		post_hsd_en = 0;
-		post_h_fac = 0x1000;
-	}
-
-
-	if(screen->post_dsp_sty + screen->post_ysize > y_res){
-		dev_warn(lcdc_dev->dev, "post:sty[%d] + ysize[%d] > y_res[%d]\n",
-			screen->post_dsp_sty,screen->post_ysize,y_res);
-		screen->post_dsp_sty = y_res - screen->post_ysize;	
-	}
-	
-	if(screen->y_mirror == 0){
-		post_dsp_vact_st = screen->post_dsp_sty + 
-			screen->mode.vsync_len+screen->mode.upper_margin;
-		post_dsp_vact_end = post_dsp_vact_st + screen->post_ysize;
-	}else{
-		post_dsp_vact_end = v_total - screen->mode.lower_margin -
-					- screen->post_dsp_sty;
-		post_dsp_vact_st = post_dsp_vact_end - screen->post_ysize;
-	}
-	if((screen->post_ysize < y_res)&&(screen->post_ysize != 0)){
-		post_vsd_en = 1;
-		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res, screen->post_ysize);		
-	}else{
-		post_vsd_en = 0;
-		post_v_fac = 0x1000;
-	}
-
-	if(screen->interlace == 1){
-		post_dsp_vact_st_f1  = v_total + post_dsp_vact_st;
-		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 + screen->post_ysize;
-	}else{
-		post_dsp_vact_st_f1  = 0;
-		post_dsp_vact_end_f1 = 0;
-	}
-	DBG(1,"post:xsize=%d,ysize=%d,xpos=%d,ypos=%d,"
-	      "hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
-		screen->post_xsize,screen->post_ysize,screen->xpos,screen->ypos,
-		post_hsd_en,post_h_fac,post_vsd_en,post_v_fac);
-	mask = m_DSP_HACT_END_POST | m_DSP_HACT_ST_POST;
-	val = v_DSP_HACT_END_POST(post_dsp_hact_end) | 
-	      v_DSP_HACT_ST_POST(post_dsp_hact_st);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_HACT_INFO, mask, val);
-
-	mask = m_DSP_VACT_END_POST | m_DSP_VACT_ST_POST;
-	val = v_DSP_VACT_END_POST(post_dsp_vact_end) | 
-	      v_DSP_VACT_ST_POST(post_dsp_vact_st);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO, mask, val);
-
-	mask = m_POST_HS_FACTOR_YRGB | m_POST_VS_FACTOR_YRGB;
-	val = v_POST_HS_FACTOR_YRGB(post_h_fac) |
-		v_POST_VS_FACTOR_YRGB(post_v_fac);
-	lcdc_msk_reg(lcdc_dev, POST_SCL_FACTOR_YRGB, mask, val);
-
-	mask = m_DSP_VACT_END_POST_F1 | m_DSP_VACT_ST_POST_F1;
-	val = v_DSP_VACT_END_POST_F1(post_dsp_vact_end_f1) |
-		v_DSP_VACT_ST_POST_F1(post_dsp_vact_st_f1);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO_F1, mask, val);
-
-	mask = m_POST_HOR_SD_EN | m_POST_VER_SD_EN;
-	val = v_POST_HOR_SD_EN(post_hsd_en) | v_POST_VER_SD_EN(post_vsd_en);
-	lcdc_msk_reg(lcdc_dev, POST_SCL_CTRL, mask, val);
-	return 0;
-}
-
-static int rk3288_lcdc_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-	struct rk_lcdc_win *win;
-	u32  colorkey_r,colorkey_g,colorkey_b;
-	int i,key_val;
-	for(i=0;i<4;i++){
-		win = dev_drv->win[i];
-		key_val = win->color_key_val;
-		colorkey_r = (key_val & 0xff)<<2;
-		colorkey_g = ((key_val>>8)&0xff)<<12;
-		colorkey_b = ((key_val>>16)&0xff)<<22;
-		/*color key dither 565/888->aaa*/
-		key_val = colorkey_r | colorkey_g | colorkey_b;
-		switch(i){
-		case 0:
-			lcdc_writel(lcdc_dev, WIN0_COLOR_KEY, key_val);
-			break;
-		case 1:
-			lcdc_writel(lcdc_dev, WIN1_COLOR_KEY, key_val);
-			break;
-		case 2:
-			lcdc_writel(lcdc_dev, WIN2_COLOR_KEY, key_val);
-			break;
-		case 3:
-			lcdc_writel(lcdc_dev, WIN3_COLOR_KEY, key_val);
-			break;
-		default:
-			printk(KERN_WARNING "%s:un support win num:%d\n",
-				__func__,i);		
-			break;
-		}
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_alpha_cfg(struct rk_lcdc_driver *dev_drv,int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	struct alpha_config alpha_config;
-
-	u32 mask, val;
-	int ppixel_alpha,global_alpha;
-	u32 src_alpha_ctl,dst_alpha_ctl;
-	ppixel_alpha = ((win->area[0].format == ARGB888) ||
-			(win->area[0].format == ABGR888)) ? 1 : 0;
-	global_alpha = (win->g_alpha_val == 0) ? 0 : 1; 
-	alpha_config.src_global_alpha_val = win->g_alpha_val;
-	win->alpha_mode = AB_SRC_OVER;
-	/*printk("%s,alpha_mode=%d,alpha_en=%d,ppixel_a=%d,gla_a=%d\n",
-		__func__,win->alpha_mode,win->alpha_en,ppixel_alpha,global_alpha);*/
-	switch(win->alpha_mode){
-	case AB_USER_DEFINE:
-		break;
- 	case AB_CLEAR:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_ZERO;		
-		break;
- 	case AB_SRC:
-		alpha_config.src_factor_mode=AA_ONE;
-		alpha_config.dst_factor_mode=AA_ZERO;
-		break;
- 	case AB_DST:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_ONE;
-		break;
- 	case AB_SRC_OVER:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		if(global_alpha)
-			alpha_config.src_factor_mode=AA_SRC_GLOBAL;
-		else
-			alpha_config.src_factor_mode=AA_ONE;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
-		break;
- 	case AB_DST_OVER:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_ONE;
-		break;
- 	case AB_SRC_IN:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC;
-		alpha_config.dst_factor_mode=AA_ZERO;
-		break;
- 	case AB_DST_IN:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_SRC;
-		break;
- 	case AB_SRC_OUT:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_ZERO;		
-		break;
- 	case AB_DST_OUT:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;	
-		break;
- 	case AB_SRC_ATOP:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
-		break;
- 	case AB_DST_ATOP:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_SRC;		
-		break;
- 	case XOR:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;			
-		break;	
- 	case AB_SRC_OVER_GLOBAL:	
-		alpha_config.src_global_alpha_mode=AA_PER_PIX_GLOBAL;
-		alpha_config.src_color_mode=AA_SRC_NO_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_GLOBAL;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;
-		break;
-	default:
-	    	pr_err("alpha mode error\n");
-      		break;		
-	}
-	if((ppixel_alpha == 1)&&(global_alpha == 1)){
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-	}else if(ppixel_alpha == 1){
-		alpha_config.src_global_alpha_mode = AA_PER_PIX;
-	}else if(global_alpha == 1){
-		alpha_config.src_global_alpha_mode = AA_GLOBAL;
-	}else{
-		dev_warn(lcdc_dev->dev,"alpha_en should be 0\n");
-	}
-	alpha_config.src_alpha_mode = AA_STRAIGHT;
-	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
-
-	switch(win_id){
-	case 0:
-		src_alpha_ctl = 0x60;
-		dst_alpha_ctl = 0x64;
-		break;
-	case 1:
-		src_alpha_ctl = 0xa0;
-		dst_alpha_ctl = 0xa4;
-		break;
-	case 2:
-		src_alpha_ctl = 0xdc;
-		dst_alpha_ctl = 0xec;
-		break;
-	case 3:
-		src_alpha_ctl = 0x12c;
-		dst_alpha_ctl = 0x13c;
-		break;
-	}
-	mask = m_WIN0_DST_FACTOR_M0;
-	val  = v_WIN0_DST_FACTOR_M0(alpha_config.dst_factor_mode);
-	lcdc_msk_reg(lcdc_dev, dst_alpha_ctl, mask, val);
-	mask = m_WIN0_SRC_ALPHA_EN | m_WIN0_SRC_COLOR_M0 |
-		m_WIN0_SRC_ALPHA_M0 | m_WIN0_SRC_BLEND_M0 |
-		m_WIN0_SRC_ALPHA_CAL_M0 | m_WIN0_SRC_FACTOR_M0|
-		m_WIN0_SRC_GLOBAL_ALPHA;
-	val = v_WIN0_SRC_ALPHA_EN(1) | 
-		v_WIN0_SRC_COLOR_M0(alpha_config.src_color_mode) |
-		v_WIN0_SRC_ALPHA_M0(alpha_config.src_alpha_mode) |
-		v_WIN0_SRC_BLEND_M0(alpha_config.src_global_alpha_mode) |
-		v_WIN0_SRC_ALPHA_CAL_M0(alpha_config.src_alpha_cal_m0) |
-		v_WIN0_SRC_FACTOR_M0(alpha_config.src_factor_mode) |
-		v_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
-	lcdc_msk_reg(lcdc_dev, src_alpha_ctl, mask, val);
-
-	return 0;
-}
-static int rk3288_lcdc_area_swap(struct rk_lcdc_win *win,int area_num)
-{
-	struct rk_lcdc_win_area area_temp;
-	switch(area_num){
-	case 2:
-		area_temp = win->area[0];
-		win->area[0] = win->area[1];
-		win->area[1] = area_temp;
-		break;
-	case 3:
-		area_temp = win->area[0];
-		win->area[0] = win->area[2];
-		win->area[2] = area_temp;
-		break;
-	case 4:
-		area_temp = win->area[0];
-		win->area[0] = win->area[3];
-		win->area[3] = area_temp;
-		
-		area_temp = win->area[1];
-		win->area[1] = win->area[2];
-		win->area[2] = area_temp;	
-		break;
-	default:
-		printk(KERN_WARNING "un supported area num!\n");
-		break;
-	}
-	return 0;
-}
-
-static int rk3288_win_area_check_var(int win_id,int area_num,struct rk_lcdc_win_area *area_pre,
-			struct rk_lcdc_win_area *area_now)
-{
-	if((area_pre->ypos >= area_now->ypos) ||
-		(area_pre->ypos+area_pre->ysize > area_now->ypos)){
-		area_now->state = 0;
-		pr_err("win[%d]:\n"
-			"area_pre[%d]:ypos[%d],ysize[%d]\n"
-			"area_now[%d]:ypos[%d],ysize[%d]\n",
-			win_id,
-			area_num-1,area_pre->ypos,area_pre->ysize,
-			area_num,  area_now->ypos,area_now->ysize);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int rk3288_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int mask, val, off;
-	off = win_id * 0x40;
-	if((win->win_lb_mode == 5) &&
-	   (dev_drv->version == VOP_FULL_RK3288_V1_0))
-		win->win_lb_mode = 4;
-
-	if(win->state == 1){
-		mask =  m_WIN0_EN | m_WIN0_DATA_FMT | m_WIN0_FMT_10 |
-			m_WIN0_LB_MODE | m_WIN0_RB_SWAP | m_WIN0_UV_SWAP;
-		val  =  v_WIN0_EN(win->state) |
-			v_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
-			v_WIN0_FMT_10(win->fmt_10) | 
-			v_WIN0_LB_MODE(win->win_lb_mode) | 
-			v_WIN0_RB_SWAP(win->area[0].swap_rb) |
-			v_WIN0_UV_SWAP(win->area[0].swap_uv);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0+off, mask,val);	
-	
-		mask =	m_WIN0_BIC_COE_SEL |
-			m_WIN0_VSD_YRGB_GT4 | m_WIN0_VSD_YRGB_GT2 |
-			m_WIN0_VSD_CBR_GT4 | m_WIN0_VSD_CBR_GT2 |
-			m_WIN0_YRGB_HOR_SCL_MODE | m_WIN0_YRGB_VER_SCL_MODE |
-			m_WIN0_YRGB_HSD_MODE | m_WIN0_YRGB_VSU_MODE |
-			m_WIN0_YRGB_VSD_MODE | m_WIN0_CBR_HOR_SCL_MODE |
-			m_WIN0_CBR_VER_SCL_MODE | m_WIN0_CBR_HSD_MODE |
-			m_WIN0_CBR_VSU_MODE | m_WIN0_CBR_VSD_MODE;
-		val =	v_WIN0_BIC_COE_SEL(win->bic_coe_el) |
-			v_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
-			v_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
-			v_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
-			v_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
-			v_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
-			v_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
-			v_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
-			v_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
-			v_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
-			v_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
-			v_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
-			v_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
-			v_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
-			v_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1+off, mask,val);
-	
-		val =	v_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
-			v_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);	
-		lcdc_writel(lcdc_dev, WIN0_VIR+off, val);	
-		/*lcdc_writel(lcdc_dev, WIN0_YRGB_MST+off, win->area[0].y_addr); 
-		lcdc_writel(lcdc_dev, WIN0_CBR_MST+off, win->area[0].uv_addr);*/
-		val =	v_WIN0_ACT_WIDTH(win->area[0].xact) |
-			v_WIN0_ACT_HEIGHT(win->area[0].yact);
-		lcdc_writel(lcdc_dev, WIN0_ACT_INFO+off, val); 
-	
-		val =	v_WIN0_DSP_WIDTH(win->area[0].xsize) |
-			v_WIN0_DSP_HEIGHT(win->area[0].ysize);
-		lcdc_writel(lcdc_dev, WIN0_DSP_INFO+off, val); 
-	
-		val =	v_WIN0_DSP_XST(win->area[0].dsp_stx) |
-			v_WIN0_DSP_YST(win->area[0].dsp_sty);
-		lcdc_writel(lcdc_dev, WIN0_DSP_ST+off, val); 
-	
-		val =	v_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
-			v_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB+off, val); 
-	
-		val =	v_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
-			v_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR+off, val); 
-		if(win->alpha_en == 1)
-			rk3288_lcdc_alpha_cfg(dev_drv,win_id);
-		else{
-			mask = m_WIN0_SRC_ALPHA_EN;
-			val = v_WIN0_SRC_ALPHA_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN0_SRC_ALPHA_CTRL+off,mask,val);				
-		}
-		/*offset*/	
-	}else{
-		mask = m_WIN0_EN;
-		val = v_WIN0_EN(win->state);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0+off, mask,val); 
-	}
-	return 0;
-}
-
-static int rk3288_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	struct rk_screen *screen = dev_drv->cur_screen;
-	unsigned int mask, val, off;
-	struct fb_info *fb0 = rk_get_fb(0);
-
-	off = (win_id-2) * 0x50;
-	if((screen->y_mirror == 1)&&(win->area_num > 1)){
-		rk3288_lcdc_area_swap(win,win->area_num);
-	}
-	
-	if(win->state == 1){
-		mask =  m_WIN2_EN | m_WIN2_DATA_FMT | m_WIN2_RB_SWAP;
-		val  =  v_WIN2_EN(1) |
-			v_WIN2_DATA_FMT(win->area[0].fmt_cfg) |
-			v_WIN2_RB_SWAP(win->area[0].swap_rb);
-		lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-		/*area 0*/
-		if(win->area[0].state == 1){
-			mask = m_WIN2_MST0_EN;
-			val  = v_WIN2_MST0_EN(win->area[0].state);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-
-			mask = m_WIN2_VIR_STRIDE0;
-			val  = v_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev,WIN2_VIR0_1+off,mask,val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST0+off,win->area[0].y_addr);*/
-			val  = 	v_WIN2_DSP_WIDTH0(win->area[0].xsize) | 
-				v_WIN2_DSP_HEIGHT0(win->area[0].ysize);
-			lcdc_writel(lcdc_dev,WIN2_DSP_INFO0+off,val);
-			val  =	v_WIN2_DSP_XST0(win->area[0].dsp_stx) |
-				v_WIN2_DSP_YST0(win->area[0].dsp_sty);
-			lcdc_writel(lcdc_dev,WIN2_DSP_ST0+off,val);	
-		}else{
-			mask = m_WIN2_MST0_EN;
-			val  = v_WIN2_MST0_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-			lcdc_writel(lcdc_dev, WIN2_MST0 + off,
-				    fb0->fix.smem_start);
-		}
-		/*area 1*/
-		if(win->area[1].state == 1){
-			rk3288_win_area_check_var(win_id,1,&win->area[0],&win->area[1]);
-			
-			mask = m_WIN2_MST1_EN;
-			val  = v_WIN2_MST1_EN(win->area[1].state);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-
-			mask = m_WIN2_VIR_STRIDE1;
-			val  = v_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev,WIN2_VIR0_1+off,mask,val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST1+off,win->area[1].y_addr);*/
-			val  = 	v_WIN2_DSP_WIDTH1(win->area[1].xsize) | 
-				v_WIN2_DSP_HEIGHT1(win->area[1].ysize);
-			lcdc_writel(lcdc_dev,WIN2_DSP_INFO1+off,val);
-			val  =	v_WIN2_DSP_XST1(win->area[1].dsp_stx) |
-				v_WIN2_DSP_YST1(win->area[1].dsp_sty);
-			lcdc_writel(lcdc_dev,WIN2_DSP_ST1+off,val);	
-		}else{
-			mask = m_WIN2_MST1_EN;
-			val  = v_WIN2_MST1_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-			lcdc_writel(lcdc_dev, WIN2_MST1 + off,
-				    fb0->fix.smem_start);
-		}
-		/*area 2*/
-		if(win->area[2].state == 1){
-			rk3288_win_area_check_var(win_id,2,&win->area[1],&win->area[2]);
-			
-			mask = m_WIN2_MST2_EN;
-			val  = v_WIN2_MST2_EN(win->area[2].state);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-
-			mask = m_WIN2_VIR_STRIDE2;
-			val  = v_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev,WIN2_VIR2_3+off,mask,val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST2+off,win->area[2].y_addr);*/
-			val  = 	v_WIN2_DSP_WIDTH2(win->area[2].xsize) | 
-				v_WIN2_DSP_HEIGHT2(win->area[2].ysize);
-			lcdc_writel(lcdc_dev,WIN2_DSP_INFO2+off,val);
-			val  =	v_WIN2_DSP_XST2(win->area[2].dsp_stx) |
-				v_WIN2_DSP_YST2(win->area[2].dsp_sty);
-			lcdc_writel(lcdc_dev,WIN2_DSP_ST2+off,val);	
-		}else{
-			mask = m_WIN2_MST2_EN;
-			val  = v_WIN2_MST2_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-			lcdc_writel(lcdc_dev, WIN2_MST2 + off,
-				    fb0->fix.smem_start);
-		}
-		/*area 3*/
-		if(win->area[3].state == 1){
-			rk3288_win_area_check_var(win_id,3,&win->area[2],&win->area[3]);
-			
-			mask = m_WIN2_MST3_EN;
-			val  = v_WIN2_MST3_EN(win->area[3].state);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-
-			mask = m_WIN2_VIR_STRIDE3;
-			val  = v_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev,WIN2_VIR2_3+off,mask,val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST3+off,win->area[3].y_addr);*/
-			val  = 	v_WIN2_DSP_WIDTH3(win->area[3].xsize) | 
-				v_WIN2_DSP_HEIGHT3(win->area[3].ysize);
-			lcdc_writel(lcdc_dev,WIN2_DSP_INFO3+off,val);
-			val  =	v_WIN2_DSP_XST3(win->area[3].dsp_stx) |
-				v_WIN2_DSP_YST3(win->area[3].dsp_sty);
-			lcdc_writel(lcdc_dev,WIN2_DSP_ST3+off,val);	
-		}else{
-			mask = m_WIN2_MST3_EN;
-			val  = v_WIN2_MST3_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
-			lcdc_writel(lcdc_dev, WIN2_MST3 + off,
-				    fb0->fix.smem_start);
-		}	
-
-		if(win->alpha_en == 1)
-			rk3288_lcdc_alpha_cfg(dev_drv,win_id);
-		else{
-			mask = m_WIN2_SRC_ALPHA_EN;
-			val = v_WIN2_SRC_ALPHA_EN(0);
-			lcdc_msk_reg(lcdc_dev,WIN2_SRC_ALPHA_CTRL+off,mask,val);				
-		}
-	}else{
-		mask =  m_WIN2_EN | m_WIN2_MST0_EN |
-			m_WIN2_MST0_EN | m_WIN2_MST2_EN |
-			m_WIN2_MST3_EN;
-		val  =  v_WIN2_EN(win->state) | v_WIN2_MST0_EN(0) |
-			v_WIN2_MST1_EN(0) | v_WIN2_MST2_EN(0) |
-			v_WIN2_MST3_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0+off, mask,val); 
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int timeout;
-	unsigned long flags;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-			     v_STANDBY_EN(lcdc_dev->standby));
-		rk3288_win_0_1_reg_update(dev_drv,0);
-		rk3288_win_0_1_reg_update(dev_drv,1);
-		rk3288_win_2_3_reg_update(dev_drv,2);
-		rk3288_win_2_3_reg_update(dev_drv,3);
-		/*rk3288_lcdc_post_cfg(dev_drv);*/
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	/*if (dev_drv->wait_fs) {*/
-	if (0){
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-						      msecs_to_jiffies
-						      (dev_drv->cur_screen->ft +
-						       5));
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_warn(lcdc_dev->dev, "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
-	return 0;
-
-}
-
-static int rk3288_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
-{
-	memcpy((u8 *) lcdc_dev->regs, (u8 *) lcdc_dev->regsbak, 0x1fc);
-	return 0;
-}
-static int rk3288_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask,val;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	if (dev_drv->iommu_enabled) {
-		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
-
-		if (likely(lcdc_dev->clk_on)) {
-			spin_lock(&lcdc_dev->reg_lock);
-			mask = m_MMU_EN;
-			val = v_MMU_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_AXI_MAX_OUTSTANDING_EN | m_AXI_OUTSTANDING_MAX_NUM;
-			val = v_AXI_OUTSTANDING_MAX_NUM(31) | v_AXI_MAX_OUTSTANDING_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL1, mask, val);
-			spin_unlock(&lcdc_dev->reg_lock);
-	}
-			lcdc_dev->iommu_status = 1;
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
-{
-#ifdef CONFIG_RK_FPGA
-	return 0;
-#endif
-	int ret = 0,fps;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-        if (reset_rate)
-	        ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);/*set pll */
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-		 div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-	
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	return 0;
-
-}
-
-static void rk3288_lcdc_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 bcsh_color_bar;
-
-	if (dev_drv->output_color == COLOR_RGB) {
-		bcsh_color_bar = lcdc_readl(lcdc_dev, BCSH_COLOR_BAR);
-		if (((bcsh_color_bar & m_BCSH_EN) == 1) ||
-		    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-				     v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(1));
-		else
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-				     v_BCSH_R2Y_EN(0) | v_BCSH_Y2R_EN(0));
-	} else {	/* RGB2YUV */
-		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-			     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-			     v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(0));
-	}
-}
-
-static int rk3288_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
-				  u16 *yact, int *format, u32 *dsp_addr,
-				  int *ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-
-	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-	*xact = (val & m_WIN0_ACT_WIDTH) + 1;
-	*yact = ((val & m_WIN0_ACT_HEIGHT)>>16) + 1;
-
-	val = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-	*format = (val & m_WIN0_DATA_FMT) >> 1;
-	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3288_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			      int format, u16 xact, u16 yact, u16 xvir,
-			      int ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 val, mask;
-	struct rk_lcdc_win *win = dev_drv->win[0];
-	int swap = (format == RGB888) ? 1 : 0;
-
-	mask = m_WIN0_DATA_FMT | m_WIN0_RB_SWAP;
-	val = v_WIN0_DATA_FMT(format) | v_WIN0_RB_SWAP(swap);
-	lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-
-	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_WIN0_VIR_STRIDE,
-			v_WIN0_VIR_STRIDE(xvir));
-	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_WIN0_ACT_WIDTH(xact) |
-		    v_WIN0_ACT_HEIGHT(yact));
-
-	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
-
-	lcdc_cfg_done(lcdc_dev);
-	win->state = 1;
-	win->last_state = 1;
-
-	return 0;
-}
-
-static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	u16 face = 0;
-	u16 dclk_ddr = 0;
-	u32 v=0;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 right_margin = screen->mode.right_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	u16 h_total,v_total;
-	int ret = 0;
-	int hdmi_dclk_out_en = 0;
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	
-	h_total = hsync_len + left_margin  + x_res + right_margin;
-	v_total = vsync_len + upper_margin + y_res + lower_margin;
-
-	screen->post_dsp_stx = x_res * (100 - screen->overscan.left) / 200;
-	screen->post_dsp_sty = y_res * (100 - screen->overscan.top) / 200;
-	screen->post_xsize = x_res * (screen->overscan.left + screen->overscan.right) / 200;
-	screen->post_ysize = y_res * (screen->overscan.top + screen->overscan.bottom) / 200;
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
-			    m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
-			    m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
-			    m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
-			    m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
-				m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_YUV_420:
-			hdmi_dclk_out_en = 1;
-			face = OUT_YUV_420;
-			dclk_ddr = 1;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
-				m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_YUV_420_10BIT:
-			hdmi_dclk_out_en = 1;
-			face = OUT_YUV_420;
-			dclk_ddr = 1;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
-				m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P101010:
-			face = OUT_P101010;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
-				m_PRE_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
-			    v_PRE_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		default:
-			dev_err(lcdc_dev->dev,"un supported interface!\n");
-			break;
-		}
-		switch(screen->type){
-		case SCREEN_RGB:
-		case SCREEN_LVDS:
-		case SCREEN_DUAL_LVDS:
-		case SCREEN_LVDS_10BIT:
-		case SCREEN_DUAL_LVDS_10BIT:
-			mask = m_RGB_OUT_EN;
-			val = v_RGB_OUT_EN(1);
-			v = 1 << (3+16);
-			v |= (lcdc_dev->id << 3);
-		        break;
-		case SCREEN_HDMI:
-			if ((screen->face == OUT_P888) ||
-			    (screen->face == OUT_P101010))
-				face = OUT_P101010;/*RGB 101010 output*/
-			mask = m_HDMI_OUT_EN;
-			val = v_HDMI_OUT_EN(1);
-			break;
-		case SCREEN_MIPI:
-			mask = m_MIPI_OUT_EN;
-			val = v_MIPI_OUT_EN(1); 		
-			break;
-		case SCREEN_DUAL_MIPI:
-			mask = m_MIPI_OUT_EN | m_DOUB_CHANNEL_EN;
-			val = v_MIPI_OUT_EN(1) | v_DOUB_CHANNEL_EN(1); 	
-			break;
-		case SCREEN_EDP:
-			face = OUT_P101010;  /*RGB 101010 output*/
-			mask = m_EDP_OUT_EN;
-			val = v_EDP_OUT_EN(1);
-			break;
-		default:
-			mask = 0;
-			val = 0;
-			pr_info("unknow screen type: %d\n", screen->type);
-			break;
-		}
-		if (dev_drv->version == VOP_FULL_RK3288_V1_1) {
-			mask |= m_HDMI_DCLK_OUT_EN;
-			val |= v_HDMI_DCLK_OUT_EN(hdmi_dclk_out_en);
-		}
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-#ifndef CONFIG_RK_FPGA
-		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
-#endif		
-		mask = m_DSP_OUT_MODE | m_DSP_HSYNC_POL | m_DSP_VSYNC_POL |
-		       m_DSP_DEN_POL | m_DSP_DCLK_POL | m_DSP_BG_SWAP | 
-		       m_DSP_RB_SWAP | m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		       m_DSP_DUMMY_SWAP | m_DSP_OUT_ZERO | m_DSP_BLANK_EN | 
-		       m_DSP_BLACK_EN | m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN |
-		       m_DSP_DCLK_DDR;
-		val = v_DSP_OUT_MODE(face) | v_DSP_HSYNC_POL(screen->pin_hsync) |
-		      v_DSP_VSYNC_POL(screen->pin_vsync) | 
-		      v_DSP_DEN_POL(screen->pin_den) | v_DSP_DCLK_POL(screen->pin_dclk) |
-		      v_DSP_BG_SWAP(screen->swap_gb) | v_DSP_RB_SWAP(screen->swap_rb) | 
-		      v_DSP_RG_SWAP(screen->swap_rg) | 
-		      v_DSP_DELTA_SWAP(screen->swap_delta) |
-		      v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_DSP_OUT_ZERO(0) | 
-		      v_DSP_BLANK_EN(0) | v_DSP_BLACK_EN(0) |
-		      v_DSP_X_MIR_EN(screen->x_mirror) |
-		      v_DSP_Y_MIR_EN(screen->y_mirror) |
-		      v_DSP_DCLK_DDR(dclk_ddr);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-
-		mask = m_DSP_BG_BLUE | m_DSP_BG_GREEN | m_DSP_BG_RED;
-		val  = v_DSP_BG_BLUE(0) | v_DSP_BG_GREEN(0) | v_DSP_BG_RED(0);
-		lcdc_msk_reg(lcdc_dev, DSP_BG, mask, val);
-
-		mask = m_DSP_HS_PW | m_DSP_HTOTAL;
-		val = v_DSP_HS_PW(hsync_len) | v_DSP_HTOTAL(h_total);
-		lcdc_msk_reg(lcdc_dev, DSP_HTOTAL_HS_END, mask, val);
-
-		mask = m_DSP_HACT_END | m_DSP_HACT_ST;
-		val = v_DSP_HACT_END(hsync_len + left_margin + x_res) |
-		    v_DSP_HACT_ST(hsync_len + left_margin);
-		lcdc_msk_reg(lcdc_dev, DSP_HACT_ST_END, mask, val);
-
-		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
-		val = v_DSP_VS_PW(vsync_len) | v_DSP_VTOTAL(v_total);
-		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
-
-		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
-		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res) |
-		    v_DSP_VACT_ST(vsync_len + upper_margin);
-		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
-
-		rk3288_lcdc_post_cfg(dev_drv);
-		mask = m_DSP_LINE_FLAG_NUM;
-		val = v_DSP_LINE_FLAG_NUM(vsync_len + upper_margin + y_res);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
-		dev_drv->output_color = screen->color_mode;
-		if (dev_drv->version == VOP_FULL_RK3288_V1_1) {
-			rk3288_lcdc_bcsh_path_sel(dev_drv);
-		} else {
-			if (dev_drv->output_color != COLOR_RGB) {
-				pr_err("vop ver:%x,unsupport output color:%d\n",
-				       dev_drv->version, dev_drv->output_color);
-				ret = -1;
-			}
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	rk3288_lcdc_set_dclk(dev_drv, 1);
-	if (screen->type != SCREEN_HDMI && dev_drv->trsm_ops &&
-	    dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-	
-	return ret;
-}
-
-/*enable layer,open:1,enable;0 disable*/
-static int win0_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[0]->state = open;
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win1_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[1]->state = open;
-
-		/*if no layer used,disable lcdc*/
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win2_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[2]->state = open;
-
-		/*if no layer used,disable lcdc*/
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win3_open(struct lcdc_device *lcdc_dev, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt++;
-		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.win[3]->state = open;
-
-		/*if no layer used,disable lcdc*/
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-static int rk3288_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	u32 mask,val;
-	
-	mask = m_FS_INTR_CLR | m_FS_INTR_EN | m_LINE_FLAG_INTR_CLR |
-			    m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_CLR | 
-			    m_BUS_ERROR_INTR_EN;
-	val = v_FS_INTR_CLR(1) | v_FS_INTR_EN(1) | v_LINE_FLAG_INTR_CLR(1) |
-	    v_LINE_FLAG_INTR_EN(1) | v_BUS_ERROR_INTR_CLR(1) | v_BUS_ERROR_INTR_EN(0);
-	lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);	
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-		 mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN | m_WIN2_EMPTY_INTR_EN |
-			 m_WIN3_EMPTY_INTR_EN |m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
-			 m_PWM_GEN_INTR_EN;
-		 val = v_WIN0_EMPTY_INTR_EN(1) | v_WIN1_EMPTY_INTR_EN(1) | v_WIN2_EMPTY_INTR_EN(1) |
-			 v_WIN3_EMPTY_INTR_EN(1)| v_HWC_EMPTY_INTR_EN(1) | v_POST_BUF_EMPTY_INTR_EN(1) |
-			 v_PWM_GEN_INTR_EN(1);
-		 lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);
-#endif 	
-	return 0;
-}
-
-static int rk3288_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
-			    bool open)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	int sys_status = (dev_drv->id == 0) ?
-			SYS_STATUS_LCDC0 : SYS_STATUS_LCDC1;
-
-	/*enable clk,when first layer open */
-	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
-		rockchip_set_system_status(sys_status);
-		rk3288_lcdc_pre_init(dev_drv);
-		rk3288_lcdc_clk_enable(lcdc_dev);
-		rk3288_lcdc_enable_irq(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (!dev_drv->mmu_dev) {
-				dev_drv->mmu_dev =
-                                        rk_fb_get_sysmmu_device_by_compatible(dev_drv->mmu_dts_name);
-				if (dev_drv->mmu_dev) {
-					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
-					                          dev_drv->dev);
-                                } else {
-					dev_err(dev_drv->dev,
-						"failed to get rockchip iommu device\n");
-					return -1;
-				}
-			}
-		}
-		rk3288_lcdc_reg_restore(lcdc_dev);
-		/*if (dev_drv->iommu_enabled)
-		   rk3368_lcdc_mmu_en(dev_drv); */
-		if ((support_uboot_display()&&(lcdc_dev->prop == PRMRY))) {
-			rk3288_lcdc_set_dclk(dev_drv, 0);
-			/* rk3288_lcdc_enable_irq(dev_drv); */
-		} else {
-			rk3288_load_screen(dev_drv, 1);
-		}
-		if (dev_drv->bcsh.enable)
-			rk3288_lcdc_set_bcsh(dev_drv, 1);
-		spin_lock(&lcdc_dev->reg_lock);
-		rk3288_lcdc_set_lut(dev_drv);
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	if (win_id == 0)
-		win0_open(lcdc_dev, open);
-	else if (win_id == 1)
-		win1_open(lcdc_dev, open);
-	else if (win_id == 2)
-		win2_open(lcdc_dev, open);
-	else if (win_id == 3)
-		win3_open(lcdc_dev, open);
-	else
-		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
-
-	/* when all layer closed,disable clk */
-	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
-		rk3288_lcdc_disable_irq(lcdc_dev);
-		rk3288_lcdc_reg_update(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev) {
-				rockchip_iovmm_deactivate(dev_drv->dev);
-				lcdc_dev->iommu_status = 0;
-			}
-		}
-		rk3288_lcdc_clk_disable(lcdc_dev);
-		rockchip_clear_system_status(sys_status);
-	}
-
-	return 0;
-}
-
-static int win0_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = win->area[0].smem_start+win->area[0].y_offset;/*win->smem_start + win->y_offset;*/
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
-	    lcdc_dev->id, __func__, y_addr, uv_addr,win->area[0].y_offset);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		win->area[0].uv_addr = uv_addr;	
-		lcdc_writel(lcdc_dev, WIN0_YRGB_MST, win->area[0].y_addr); 
-		lcdc_writel(lcdc_dev, WIN0_CBR_MST, win->area[0].uv_addr);
-		/*lcdc_cfg_done(lcdc_dev);*/
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-
-}
-
-static int win1_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",
-	    lcdc_dev->id, __func__, y_addr, uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		win->area[0].uv_addr = uv_addr;	
-		lcdc_writel(lcdc_dev, WIN1_YRGB_MST, win->area[0].y_addr); 
-		lcdc_writel(lcdc_dev, WIN1_CBR_MST, win->area[0].uv_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-
-	return 0;
-}
-
-static int win2_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 i,y_addr;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>\n",
-	    lcdc_dev->id, __func__, y_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)){
-		for(i=0;i<win->area_num;i++)
-			win->area[i].y_addr = 
-				win->area[i].smem_start + win->area[i].y_offset;
-			if (win->area[0].state)
-				lcdc_writel(lcdc_dev, WIN2_MST0,
-					    win->area[0].y_addr);
-			if (win->area[1].state)
-				lcdc_writel(lcdc_dev, WIN2_MST1,
-					    win->area[1].y_addr);
-			if (win->area[2].state)
-				lcdc_writel(lcdc_dev, WIN2_MST2,
-					    win->area[2].y_addr);
-			if (win->area[3].state)
-				lcdc_writel(lcdc_dev, WIN2_MST3,
-					    win->area[3].y_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int win3_display(struct lcdc_device *lcdc_dev,
-			struct rk_lcdc_win *win)
-{
-	u32 i,y_addr;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>\n",
-	    lcdc_dev->id, __func__, y_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)){
-		for(i=0;i<win->area_num;i++)
-			win->area[i].y_addr = 
-				win->area[i].smem_start + win->area[i].y_offset;
-			if (win->area[0].state)
-				lcdc_writel(lcdc_dev, WIN3_MST0,
-					    win->area[0].y_addr);
-			if (win->area[1].state)
-				lcdc_writel(lcdc_dev, WIN3_MST1,
-					    win->area[1].y_addr);
-			if (win->area[2].state)
-				lcdc_writel(lcdc_dev, WIN3_MST2,
-					    win->area[2].y_addr);
-			if (win->area[3].state)
-				lcdc_writel(lcdc_dev, WIN3_MST3,
-					    win->area[3].y_addr);
-		}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3288_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-				struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	
-#if defined(WAIT_FOR_SYNC)
-	int timeout;
-	unsigned long flags;
-#endif
-	win = dev_drv->win[win_id];
- 	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
- 	if(win_id == 0){
-		win0_display(lcdc_dev, win);
-	}else if(win_id == 1){
-		win1_display(lcdc_dev, win);
-	}else if(win_id == 2){
-		win2_display(lcdc_dev, win);
-	}else if(win_id == 3){
-		win3_display(lcdc_dev, win);
-	}else{
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
- 
-	/*this is the first frame of the system ,enable frame start interrupt */
-	if ((dev_drv->first_frame)) {
-		dev_drv->first_frame = 0;
-		rk3288_lcdc_enable_irq(dev_drv);
-	}
-#if defined(WAIT_FOR_SYNC)
-	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-	init_completion(&dev_drv->frame_done);
-	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-	timeout = wait_for_completion_timeout(&dev_drv->frame_done,
-					      msecs_to_jiffies(dev_drv->
-							       cur_screen->ft +
-							       5));
-	if (!timeout && (!dev_drv->frame_done.done)) {
-		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
-		return -ETIMEDOUT;
-	}
-#endif 
-	return 0;
-}
-
-static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
-{
-	u16 srcW;
-	u16 srcH;
-	u16 dstW;
-	u16 dstH;
-	u16 yrgb_srcW;
-	u16 yrgb_srcH;
-	u16 yrgb_dstW;
-	u16 yrgb_dstH;
-	u32 yrgb_vScaleDnMult;
-	u32 yrgb_xscl_factor;
-	u32 yrgb_yscl_factor;
-	u8  yrgb_vsd_bil_gt2=0;
-	u8  yrgb_vsd_bil_gt4=0;
-	
-	u16 cbcr_srcW;
-	u16 cbcr_srcH;
-	u16 cbcr_dstW;
-	u16 cbcr_dstH;	  
-	u32 cbcr_vScaleDnMult;
-	u32 cbcr_xscl_factor;
-	u32 cbcr_yscl_factor;
-	u8  cbcr_vsd_bil_gt2=0;
-	u8  cbcr_vsd_bil_gt4=0;
-	u8  yuv_fmt=0;
-
-
-	srcW = win->area[0].xact;
-	srcH = win->area[0].yact;
-	dstW = win->area[0].xsize;
-	dstH = win->area[0].ysize;
-
-	/*yrgb scl mode*/
-	yrgb_srcW = srcW;
-	yrgb_srcH = srcH;
-	yrgb_dstW = dstW;
-	yrgb_dstH = dstH;
-	if ((yrgb_dstW*8 <= yrgb_srcW) || (yrgb_dstH*8 <= yrgb_srcH)) {
-		pr_err("ERROR: yrgb scale exceed 8,"
-		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
-		       yrgb_srcW,yrgb_srcH,yrgb_dstW,yrgb_dstH);
-	}
-	if(yrgb_srcW < yrgb_dstW){
-		win->yrgb_hor_scl_mode = SCALE_UP;
-    	}else if(yrgb_srcW > yrgb_dstW){
-        	win->yrgb_hor_scl_mode = SCALE_DOWN;
-    	}else{
-        	win->yrgb_hor_scl_mode = SCALE_NONE;
-    	}
-
-    	if(yrgb_srcH < yrgb_dstH){
-        	win->yrgb_ver_scl_mode = SCALE_UP;
-    	}else if (yrgb_srcH  > yrgb_dstH){
-        	win->yrgb_ver_scl_mode = SCALE_DOWN;
-    	}else{
-        	win->yrgb_ver_scl_mode = SCALE_NONE;
-    	}
-
-	/*cbcr scl mode*/
-	switch (win->area[0].format) {
-	case YUV422:
-	case YUV422_A:	
-		cbcr_srcW = srcW/2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV420:
-	case YUV420_A:	
-		cbcr_srcW = srcW/2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH/2;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV444:
-	case YUV444_A:	
-		cbcr_srcW = srcW;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	default:
-		cbcr_srcW = 0;
-	        cbcr_dstW = 0;
-	        cbcr_srcH = 0;
-	        cbcr_dstH = 0;
-		yuv_fmt = 0;
-		break;
-	}		
-	if (yuv_fmt) {
-		if ((cbcr_dstW*8 <= cbcr_srcW) || (cbcr_dstH*8 <= cbcr_srcH)) {
-			pr_err("ERROR: cbcr scale exceed 8,"
-		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
-		       cbcr_srcW,cbcr_srcH,cbcr_dstW,cbcr_dstH);
-		}
-	}
-	
-	if(cbcr_srcW < cbcr_dstW){
-		win->cbr_hor_scl_mode = SCALE_UP;
-	}else if(cbcr_srcW > cbcr_dstW){
-		win->cbr_hor_scl_mode = SCALE_DOWN;
-	}else{
-		win->cbr_hor_scl_mode = SCALE_NONE;
-	}
-	
-	if(cbcr_srcH < cbcr_dstH){
-		win->cbr_ver_scl_mode = SCALE_UP;
-	}else if(cbcr_srcH > cbcr_dstH){
-		win->cbr_ver_scl_mode = SCALE_DOWN;
-	}else{
-		win->cbr_ver_scl_mode = SCALE_NONE;
-	}
-	DBG(1, "srcW:%d>>srcH:%d>>dstW:%d>>dstH:%d>>\n"
-	       "yrgb:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
-	       "cbcr:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
-		,srcW,srcH,dstW,dstH,yrgb_srcW,yrgb_srcH,yrgb_dstW,
-		yrgb_dstH,win->yrgb_hor_scl_mode,win->yrgb_ver_scl_mode,
-		cbcr_srcW,cbcr_srcH,cbcr_dstW,cbcr_dstH,
-		win->cbr_hor_scl_mode,win->cbr_ver_scl_mode);
-
-    /*line buffer mode*/
-	if ((win->area[0].format == YUV422) ||
-	    (win->area[0].format == YUV420) ||
-	    (win->area[0].format == YUV422_A) ||
-	    (win->area[0].format == YUV420_A)) {
-		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
-            		if ((cbcr_dstW > 3840) || (cbcr_dstW == 0)) {
-                		pr_err("ERROR cbcr_dstW = %d\n",cbcr_dstW);                
-			} else if (cbcr_dstW > 2560) {
-                		win->win_lb_mode = LB_RGB_3840X2;
-			} else if (cbcr_dstW > 1920) {
-				if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
-                    			if(yrgb_dstW > 3840){
-                        			pr_err("ERROR yrgb_dst_width exceeds 3840\n");
-		                    	}else if(yrgb_dstW > 2560){
-		                        	win->win_lb_mode = LB_RGB_3840X2;
-		                    	}else if(yrgb_dstW > 1920){
-		                        	win->win_lb_mode = LB_RGB_2560X4;
-		                    	}else{
-		                        	pr_err("ERROR never run here!yrgb_dstW<1920 ==> cbcr_dstW>1920\n");
-		                    	}
-				}
-			} else if (cbcr_dstW > 1280) {
-                		win->win_lb_mode = LB_YUV_3840X5;
-			} else {
-                		win->win_lb_mode = LB_YUV_2560X8;
-            		}            
-		} else { /*SCALE_UP or SCALE_NONE*/
-            		if ((cbcr_srcW > 3840) || (cbcr_srcW == 0)) {
-                		pr_err("ERROR cbcr_srcW = %d\n",cbcr_srcW);
-            		}else if(cbcr_srcW > 2560){                
-                		win->win_lb_mode = LB_RGB_3840X2;
-            		}else if(cbcr_srcW > 1920){
-                		if(win->yrgb_hor_scl_mode == SCALE_DOWN){
-                    			if(yrgb_dstW > 3840){
-                        			pr_err("ERROR yrgb_dst_width exceeds 3840\n");
-                    			}else if(yrgb_dstW > 2560){
-                        			win->win_lb_mode = LB_RGB_3840X2;
-                    			}else if(yrgb_dstW > 1920){
-                        			win->win_lb_mode = LB_RGB_2560X4;
-                    			}else{
-                        			pr_err("ERROR never run here!yrgb_dstW<1920 ==> cbcr_dstW>1920\n");
-                    			}
-                		}  
-            		}else if(cbcr_srcW > 1280){
-               			 win->win_lb_mode = LB_YUV_3840X5;
-            		}else{
-                		win->win_lb_mode = LB_YUV_2560X8;
-            		}            
-        	}
-    	}else {
-        	if(win->yrgb_hor_scl_mode == SCALE_DOWN){
-            		if ((yrgb_dstW > 3840) || (yrgb_dstW == 0)) {
-                		pr_err("ERROR yrgb_dstW = %d\n",yrgb_dstW);
-            		}else if(yrgb_dstW > 2560){
-                		win->win_lb_mode = LB_RGB_3840X2;
-            		}else if(yrgb_dstW > 1920){
-                		win->win_lb_mode = LB_RGB_2560X4;
-            		}else if(yrgb_dstW > 1280){
-                		win->win_lb_mode = LB_RGB_1920X5;
-            		}else{
-                		win->win_lb_mode = LB_RGB_1280X8;
-            		}            
-        	}else{ /*SCALE_UP or SCALE_NONE*/
-            		if ((yrgb_srcW > 3840) || (yrgb_srcW == 0)) {
-                		pr_err("ERROR yrgb_srcW = %d\n",yrgb_srcW);
-            		}else if(yrgb_srcW > 2560){
-                		win->win_lb_mode = LB_RGB_3840X2;
-            		}else if(yrgb_srcW > 1920){
-                		win->win_lb_mode = LB_RGB_2560X4;
-            		}else if(yrgb_srcW > 1280){
-                		win->win_lb_mode = LB_RGB_1920X5;
-            		}else{
-                		win->win_lb_mode = LB_RGB_1280X8;
-            		}            
-        	}
-    	}
-    	DBG(1,"win->win_lb_mode = %d;\n",win->win_lb_mode);
-
-	/*vsd/vsu scale ALGORITHM*/
-	win->yrgb_hsd_mode = SCALE_DOWN_BIL;/*not to specify*/
-	win->cbr_hsd_mode  = SCALE_DOWN_BIL;/*not to specify*/
-	win->yrgb_vsd_mode = SCALE_DOWN_BIL;/*not to specify*/
-	win->cbr_vsd_mode  = SCALE_DOWN_BIL;/*not to specify*/
-	switch(win->win_lb_mode){
-	    case LB_YUV_3840X5:
-	    case LB_YUV_2560X8:
-	    case LB_RGB_1920X5:
-	    case LB_RGB_1280X8: 	
-		win->yrgb_vsu_mode = SCALE_UP_BIC; 
-		win->cbr_vsu_mode  = SCALE_UP_BIC; 
-		break;
-	    case LB_RGB_3840X2:
-		if(win->yrgb_ver_scl_mode != SCALE_NONE) {
-		    pr_err("ERROR : not allow yrgb ver scale\n");
-		}
-		if(win->cbr_ver_scl_mode != SCALE_NONE) {
-		    pr_err("ERROR : not allow cbcr ver scale\n");
-		}	     	  
-		break;
-	    case LB_RGB_2560X4:
-		win->yrgb_vsu_mode = SCALE_UP_BIL; 
-		win->cbr_vsu_mode  = SCALE_UP_BIL; 	    
-		break;
-	    default:
-	    	printk(KERN_WARNING "%s:un supported win_lb_mode:%d\n",
-			__func__,win->win_lb_mode);	
-		break;
-	}
-	DBG(1,"yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
-	       win->yrgb_hsd_mode,win->yrgb_vsd_mode,win->yrgb_vsu_mode,
-	       win->cbr_hsd_mode,win->cbr_vsd_mode,win->cbr_vsu_mode);
-
-    	/*SCALE FACTOR*/
-    
-    	/*(1.1)YRGB HOR SCALE FACTOR*/
-    	switch(win->yrgb_hor_scl_mode){
-        case SCALE_NONE:
-        	yrgb_xscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-            	break;
-        case SCALE_UP  :
-            	yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
-            	break;
-        case SCALE_DOWN:
-            	switch(win->yrgb_hsd_mode)
-            	{
-                case SCALE_DOWN_BIL:
-                	yrgb_xscl_factor = GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
-                    	break;
-                case SCALE_DOWN_AVG:
-                    	yrgb_xscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
-                    	break;
-                default :
-			printk(KERN_WARNING "%s:un supported yrgb_hsd_mode:%d\n",
-				__func__,win->yrgb_hsd_mode);		
-                    	break;
-            	} 
-            	break;
-        default :
-		printk(KERN_WARNING "%s:un supported yrgb_hor_scl_mode:%d\n",
-				__func__,win->yrgb_hor_scl_mode);	
-            break;
-    	} /*win->yrgb_hor_scl_mode*/
-
-    	/*(1.2)YRGB VER SCALE FACTOR*/
-    	switch(win->yrgb_ver_scl_mode)
-    	{
-        case SCALE_NONE:
-            	yrgb_yscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-           	 break;
-        case SCALE_UP  :
-            	switch(win->yrgb_vsu_mode)
-            	{
-                case SCALE_UP_BIL:
-                    	yrgb_yscl_factor = GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
-                    	break;
-                case SCALE_UP_BIC:
-                    	if(yrgb_srcH < 3){
-                        	pr_err("yrgb_srcH should be greater than 3 !!!\n");
-                    	}                    
-                    	yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH, yrgb_dstH);
-                   	break;
-                default :
-			printk(KERN_WARNING "%s:un supported yrgb_vsu_mode:%d\n",
-				__func__,win->yrgb_vsu_mode);			
-                    	break;
-            }
-            break;
-        case SCALE_DOWN:
-            	switch(win->yrgb_vsd_mode)
-            	{
-                case SCALE_DOWN_BIL:
-                    	yrgb_vScaleDnMult = getHardWareVSkipLines(yrgb_srcH, yrgb_dstH);
-                    	yrgb_yscl_factor  = GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH, yrgb_vScaleDnMult);                                 
-                    	if(yrgb_vScaleDnMult == 4){
-                        	yrgb_vsd_bil_gt4 = 1;
-                        	yrgb_vsd_bil_gt2 = 0;
-                    	}else if(yrgb_vScaleDnMult == 2){
-                        	yrgb_vsd_bil_gt4 = 0;
-                        	yrgb_vsd_bil_gt2 = 1;
-                    	}else{
-                        	yrgb_vsd_bil_gt4 = 0;
-                        	yrgb_vsd_bil_gt2 = 0;
-                    	}
-                    	break;
-                case SCALE_DOWN_AVG:
-                    	yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH, yrgb_dstH);
-                    	break;
-                default:
-			printk(KERN_WARNING "%s:un supported yrgb_vsd_mode:%d\n",
-				__func__,win->yrgb_vsd_mode);		
-                    	break;
-            	} /*win->yrgb_vsd_mode*/
-            	break;
-	default :
-		printk(KERN_WARNING "%s:un supported yrgb_ver_scl_mode:%d\n",
-			__func__,win->yrgb_ver_scl_mode);		
-            	break;
-    	}
-    	win->scale_yrgb_x = yrgb_xscl_factor;
-    	win->scale_yrgb_y = yrgb_yscl_factor;
-    	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
-    	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
-	DBG(1,"yrgb:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n",yrgb_xscl_factor,
-		yrgb_yscl_factor,yrgb_vsd_bil_gt4,yrgb_vsd_bil_gt2);
-
-    	/*(2.1)CBCR HOR SCALE FACTOR*/
-    	switch(win->cbr_hor_scl_mode)
-    	{
-        case SCALE_NONE:
-            	cbcr_xscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-            	break;
-        case SCALE_UP  :
-            	cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
-            	break;
-        case SCALE_DOWN:
-            	switch(win->cbr_hsd_mode)
-            	{
-                case SCALE_DOWN_BIL:
-                    	cbcr_xscl_factor = GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
-                    	break;
-                case SCALE_DOWN_AVG:
-                    	cbcr_xscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
-                    	break;
-                default :
-			printk(KERN_WARNING "%s:un supported cbr_hsd_mode:%d\n",
-				__func__,win->cbr_hsd_mode);	
-                    	break;
-            	}
-            	break;
-        default :
-		printk(KERN_WARNING "%s:un supported cbr_hor_scl_mode:%d\n",
-			__func__,win->cbr_hor_scl_mode);	
-            	break;
-    	} /*win->cbr_hor_scl_mode*/
-
-    	/*(2.2)CBCR VER SCALE FACTOR*/
-    	switch(win->cbr_ver_scl_mode)
-    	{
-        case SCALE_NONE:
-            	cbcr_yscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-            	break;
-        case SCALE_UP  :
-            	switch(win->cbr_vsu_mode)
-            	{
-                case SCALE_UP_BIL:
-                    	cbcr_yscl_factor = GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
-                    	break;
-                case SCALE_UP_BIC:
-                    	if(cbcr_srcH < 3) {
-                        	pr_err("cbcr_srcH should be greater than 3 !!!\n");
-                    	}                    
-                    	cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH, cbcr_dstH);
-                    	break;
-                default :
-			printk(KERN_WARNING "%s:un supported cbr_vsu_mode:%d\n",
-				__func__,win->cbr_vsu_mode);		
-                    	break;
-            	}
-            	break;
-        case SCALE_DOWN:
-            	switch(win->cbr_vsd_mode)
-            	{
-                case SCALE_DOWN_BIL:
-                    	cbcr_vScaleDnMult = getHardWareVSkipLines(cbcr_srcH, cbcr_dstH);
-                    	cbcr_yscl_factor  = GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH, cbcr_vScaleDnMult);                    
-                    	if(cbcr_vScaleDnMult == 4){
-                        	cbcr_vsd_bil_gt4 = 1;
-                        	cbcr_vsd_bil_gt2 = 0;
-                    	}else if(cbcr_vScaleDnMult == 2){
-                        	cbcr_vsd_bil_gt4 = 0;
-                        	cbcr_vsd_bil_gt2 = 1;
-                    	}else{
-                        	cbcr_vsd_bil_gt4 = 0;
-                        	cbcr_vsd_bil_gt2 = 0;
-                    	}
-                    	break;
-                case SCALE_DOWN_AVG:
-                    	cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH, cbcr_dstH);
-                    	break;
-                default :
-			printk(KERN_WARNING "%s:un supported cbr_vsd_mode:%d\n",
-				__func__,win->cbr_vsd_mode);		
-                    break;
-            	}
-            	break;
-        default :
-		printk(KERN_WARNING "%s:un supported cbr_ver_scl_mode:%d\n",
-			__func__,win->cbr_ver_scl_mode);			
-            	break;
-    	}
-    	win->scale_cbcr_x = cbcr_xscl_factor;
-    	win->scale_cbcr_y = cbcr_yscl_factor;
-   	win->vsd_cbr_gt4  = cbcr_vsd_bil_gt4;
-    	win->vsd_cbr_gt2  = cbcr_vsd_bil_gt2;	
-
-	DBG(1,"cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n",cbcr_xscl_factor,
-		cbcr_yscl_factor,cbcr_vsd_bil_gt4,cbcr_vsd_bil_gt2);
-	return 0;
-}
-
-
-
-static int win0_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact,yact,xvir, yvir,xpos, ypos;
-	u8 fmt_cfg = 0, swap_rb, swap_uv = 0;
-	char fmt[9] = "NULL";
-
-	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on)){
-		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
-		switch (win->area[0].format) {
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420:	
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420_NV21:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			swap_uv = 1;
-			win->fmt_10 = 0;
-			break;	
-		case YUV444:	
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-		case YUV422_A:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV420_A:	
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV444_A:	
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		default:
-			dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-				__func__);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		win->area[0].swap_uv = swap_uv;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	rk3288_win_0_1_reg_update(&lcdc_dev->driver,0);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->area[0].format, fmt), xact,
-		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
-	return 0;
-
-}
-
-static int win1_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u8 fmt_cfg = 0, swap_rb, swap_uv = 0;
-	char fmt[9] = "NULL";
-
-	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
-		switch (win->area[0].format) {
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420_NV21:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			swap_uv = 1;
-			win->fmt_10 = 0;
-			break;
-		case YUV444:
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422_A:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV420_A:	
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV444_A:	
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;			
-		default:
-			dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-				__func__);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		win->area[0].swap_uv = swap_uv;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	rk3288_win_0_1_reg_update(&lcdc_dev->driver,1);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
-		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->area[0].format, fmt), xact,
-		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
-	return 0;
-
-}
-
-static int win2_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	int i;
-	u8 fmt_cfg, swap_rb;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		for (i = 0; i < win->area_num; i++) {
-			switch (win->area[i].format) {
-			case ARGB888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				break;
-			case XBGR888:
-			case ABGR888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				break;
-			case RGB888:
-				fmt_cfg = 1;
-				swap_rb = 0;
-				break;
-			case RGB565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				break;
-			default:
-				dev_err(lcdc_dev->driver.dev, 
-					"%s:un supported format!\n",
-					__func__);
-				break;
-			}			
-			win->area[i].fmt_cfg = fmt_cfg;
-			win->area[i].swap_rb = swap_rb;
-			win->area[i].dsp_stx = win->area[i].xpos + 
-				screen->mode.left_margin +
-				screen->mode.hsync_len;
-			if (screen->y_mirror == 1) {
-				win->area[i].dsp_sty = screen->mode.yres -
-					win->area[i].ypos -
-					win->area[i].ysize + 
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-			} else {
-				win->area[i].dsp_sty = win->area[i].ypos + 
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-			}
-			if ((win->area[i].xact != win->area[i].xsize) ||
-			    (win->area[i].yact != win->area[i].ysize)) {
-                                pr_err("win[%d]->area[%d],not support scale\n",
-                                        win->id, i);
-                                pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
-                                        win->area[i].xact,win->area[i].yact,
-                                        win->area[i].xsize,win->area[i].ysize);
-                                win->area[i].xsize = win->area[i].xact;
-                                win->area[i].ysize = win->area[i].yact;
-			}
-		}
-	}
-	rk3288_win_2_3_reg_update(&lcdc_dev->driver,2);
-	spin_unlock(&lcdc_dev->reg_lock);	
-	return 0;
-}
-
-static int win3_set_par(struct lcdc_device *lcdc_dev,
-			struct rk_screen *screen, struct rk_lcdc_win *win)
-
-{
-	int i;
-	u8 fmt_cfg, swap_rb;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		for (i = 0; i < win->area_num; i++) {
-			switch (win->area[i].format) {
-			case ARGB888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				break;
-			case XBGR888:
-			case ABGR888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				break;
-			case RGB888:
-				fmt_cfg = 1;
-				swap_rb = 0;
-				break;
-			case RGB565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				break;
-			default:
-				dev_err(lcdc_dev->driver.dev, 
-					"%s:un supported format!\n",
-					__func__);
-				break;
-			}			
-			win->area[i].fmt_cfg = fmt_cfg;
-			win->area[i].swap_rb = swap_rb;
-			win->area[i].dsp_stx = win->area[i].xpos + 
-				screen->mode.left_margin +
-				screen->mode.hsync_len;
-			if (screen->y_mirror == 1) {
-				win->area[i].dsp_sty = screen->mode.yres -
-					win->area[i].ypos -
-					win->area[i].ysize + 
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-			} else {
-				win->area[i].dsp_sty = win->area[i].ypos + 
-					screen->mode.upper_margin +
-					screen->mode.vsync_len;
-			}
-			if ((win->area[i].xact != win->area[i].xsize) ||
-			    (win->area[i].yact != win->area[i].ysize)) {
-				pr_err("win[%d]->area[%d],not support scale\n",
-				       win->id, i);
-				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
-				       win->area[i].xact, win->area[i].yact,
-				       win->area[i].xsize, win->area[i].ysize);
-				win->area[i].xsize = win->area[i].xact;
-				win->area[i].ysize = win->area[i].yact;
-			}
-		}
-	}
-	rk3288_win_2_3_reg_update(&lcdc_dev->driver,3);
-	spin_unlock(&lcdc_dev->reg_lock);	
-	return 0;
-}
-
-static int rk3288_lcdc_set_par(struct rk_lcdc_driver *dev_drv,int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	win = dev_drv->win[win_id];
-
-	switch(win_id)
-	{
-	case 0:
-		win0_set_par(lcdc_dev, screen, win);
-		break;
-	case 1:
-		win1_set_par(lcdc_dev, screen, win);
-		break;	
-	case 2:
-		win2_set_par(lcdc_dev, screen, win);
-		break;
-	case 3:
-		win3_set_par(lcdc_dev, screen, win);
-		break;		
-	default:
-		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
-		break;	
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-			     unsigned long arg, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = lcdc_dev->screen->mode.xres;
-		panel_size[1] = lcdc_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		rk3288_lcdc_clr_key_cfg(dev_drv);
-		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
-			    clr_key_cfg.win0_color_key_cfg);
-		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
-			    clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	u32 reg;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	if (dev_drv->suspend_flag)
-		return 0;
-	
-	dev_drv->suspend_flag = 1;
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-	
-	for (reg = MMU_DTE_ADDR; reg <= MMU_AUTO_GATING; reg +=4)
-			lcdc_readl(lcdc_dev, reg);
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
-					v_DSP_BLANK_EN(1));
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_FS_INTR_CLR | m_LINE_FLAG_INTR_CLR,
-					v_FS_INTR_CLR(1) | v_LINE_FLAG_INTR_CLR(1));	
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
-			     		v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-			    		v_STANDBY_EN(1));
-		lcdc_cfg_done(lcdc_dev);
-
-                if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	rk3288_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(dev_drv);
-	return 0;
-}
-
-static int rk3288_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-	dev_drv->suspend_flag = 0;
-
-	if (lcdc_dev->atv_layer_cnt) {
-		rk3288_lcdc_clk_enable(lcdc_dev);
-		rk3288_lcdc_reg_restore(lcdc_dev);
-
-		spin_lock(&lcdc_dev->reg_lock);
-		rk3288_lcdc_set_lut(dev_drv);
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(0));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-			     v_STANDBY_EN(0));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
-					v_DSP_BLANK_EN(0));	
-		lcdc_cfg_done(lcdc_dev);
-
-                if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_activate(dev_drv->dev);
-		}
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-
-	return 0;
-}
-
-static int rk3288_lcdc_blank(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		rk3288_lcdc_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:	
-		rk3288_lcdc_early_suspend(dev_drv);
-		break;
-	default:
-		rk3288_lcdc_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int rk3288_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
-                                           int win_id, int area_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-        u32 win_ctrl = 0;
-        u32 area_status = 0;
-
-        switch (win_id) {
-        case 0:
-                win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-                area_status = win_ctrl & m_WIN0_EN;
-                break;
-        case 1:
-                win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
-                area_status = win_ctrl & m_WIN1_EN;
-                break;
-        case 2:
-                win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
-                if (area_id == 0)
-                        area_status = win_ctrl & m_WIN2_MST0_EN;
-                if (area_id == 1)
-                        area_status = win_ctrl & m_WIN2_MST1_EN;
-                if (area_id == 2)
-                        area_status = win_ctrl & m_WIN2_MST2_EN;
-                if (area_id == 3)
-                        area_status = win_ctrl & m_WIN2_MST3_EN;
-                break;
-        case 3:
-                win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
-                if (area_id == 0)
-                        area_status = win_ctrl & m_WIN3_MST0_EN;
-                if (area_id == 1)
-                        area_status = win_ctrl & m_WIN3_MST1_EN;
-                if (area_id == 2)
-                        area_status = win_ctrl & m_WIN3_MST2_EN;
-                if (area_id == 3)
-                        area_status = win_ctrl & m_WIN3_MST3_EN;
-                break;
-        case 4:
-                win_ctrl = lcdc_readl(lcdc_dev, HWC_CTRL0);
-                area_status = win_ctrl & m_HWC_EN;
-                break;
-        default:
-                pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",__func__,win_id,area_id);
-                break;
-        }
-	return area_status;
-}
-
-static int rk3288_lcdc_get_area_num(struct rk_lcdc_driver *dev_drv,
-				           unsigned int *area_support)
-{
-        area_support[0] = 1;
-        area_support[1] = 1;
-        area_support[2] = 4;
-        area_support[3] = 4;
-
-        return 0;
-}
-
-/*overlay will be do at regupdate*/
-static int rk3288_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	int i,ovl;
-	unsigned int mask, val;
-	int z_order_num=0;
-	int layer0_sel,layer1_sel,layer2_sel,layer3_sel;
-	if(swap == 0){
-		for(i=0;i<4;i++){
-			win = dev_drv->win[i];
-			if(win->state == 1){
-				z_order_num++;
-			}	
-		}
-		for(i=0;i<4;i++){
-			win = dev_drv->win[i];
-			if(win->state == 0)
-				win->z_order = z_order_num++;
-			switch(win->z_order){
-			case 0:
-				layer0_sel = win->id;
-				break;
-			case 1:
-				layer1_sel = win->id;
-				break;
-			case 2:
-				layer2_sel = win->id;
-				break;
-			case 3:
-				layer3_sel = win->id;
-				break;
-			default:
-				break;
-			}
-		}
-	}else{
-		layer0_sel = swap %10;;
-		layer1_sel = swap /10 % 10;
-		layer2_sel = swap / 100 %10;
-		layer3_sel = swap / 1000;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on){
-		if(set){
-			mask = m_DSP_LAYER0_SEL | m_DSP_LAYER1_SEL |
-				m_DSP_LAYER2_SEL | m_DSP_LAYER3_SEL;
-			val  = v_DSP_LAYER0_SEL(layer0_sel) |
-				v_DSP_LAYER1_SEL(layer1_sel) |
-				v_DSP_LAYER2_SEL(layer2_sel) |
-				v_DSP_LAYER3_SEL(layer3_sel);
-			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,mask,val);
-		}else{
-			layer0_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER0_SEL);
-			layer1_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER1_SEL);
-			layer2_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER2_SEL);
-			layer3_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER3_SEL);
-			ovl = layer3_sel*1000 + layer2_sel*100 + layer1_sel *10 + layer0_sel;
-		}
-	}else{
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static ssize_t rk3288_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
-					 char *buf, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-							   struct
-							   lcdc_device,
-							   driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u32 h_pw_bp = hsync_len + left_margin;
-	u32 v_pw_bp = vsync_len + upper_margin;
-	u32 fmt_id;
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char format_w2[9] = "NULL";
-	char format_w3[9] = "NULL";	
-	u32 win_ctrl,zorder,vir_info,act_info,dsp_info,dsp_st,y_factor,uv_factor;
-	u8 layer0_sel,layer1_sel,layer2_sel,layer3_sel;
-	u8 w0_state,w1_state,w2_state,w3_state;
-	u8 w2_0_state,w2_1_state,w2_2_state,w2_3_state;
-	u8 w3_0_state,w3_1_state,w3_2_state,w3_3_state;
-
-	u32 w0_vir_y,w0_vir_uv,w0_act_x,w0_act_y,w0_dsp_x,w0_dsp_y,w0_st_x=h_pw_bp,w0_st_y=v_pw_bp;
-	u32 w1_vir_y,w1_vir_uv,w1_act_x,w1_act_y,w1_dsp_x,w1_dsp_y,w1_st_x=h_pw_bp,w1_st_y=v_pw_bp;
-	u32 w0_y_h_fac,w0_y_v_fac,w0_uv_h_fac,w0_uv_v_fac;
-	u32 w1_y_h_fac,w1_y_v_fac,w1_uv_h_fac,w1_uv_v_fac;
-
-	u32 w2_0_vir_y,w2_1_vir_y,w2_2_vir_y,w2_3_vir_y;
-	u32 w2_0_dsp_x,w2_1_dsp_x,w2_2_dsp_x,w2_3_dsp_x;
-	u32 w2_0_dsp_y,w2_1_dsp_y,w2_2_dsp_y,w2_3_dsp_y;
-	u32 w2_0_st_x=h_pw_bp,w2_1_st_x=h_pw_bp,w2_2_st_x=h_pw_bp,w2_3_st_x=h_pw_bp;
-	u32 w2_0_st_y=v_pw_bp,w2_1_st_y=v_pw_bp,w2_2_st_y=v_pw_bp,w2_3_st_y=v_pw_bp;
-
-	u32 w3_0_vir_y,w3_1_vir_y,w3_2_vir_y,w3_3_vir_y;
-	u32 w3_0_dsp_x,w3_1_dsp_x,w3_2_dsp_x,w3_3_dsp_x;
-	u32 w3_0_dsp_y,w3_1_dsp_y,w3_2_dsp_y,w3_3_dsp_y;
-	u32 w3_0_st_x=h_pw_bp,w3_1_st_x=h_pw_bp,w3_2_st_x=h_pw_bp,w3_3_st_x=h_pw_bp;
-	u32 w3_0_st_y=v_pw_bp,w3_1_st_y=v_pw_bp,w3_2_st_y=v_pw_bp,w3_3_st_y=v_pw_bp;
-	u32 dclk_freq;
-
-	dclk_freq = screen->mode.pixclock;
-	/*rk3288_lcdc_reg_dump(dev_drv);*/
-
-	spin_lock(&lcdc_dev->reg_lock);		
-	if (lcdc_dev->clk_on) {
-		zorder = lcdc_readl(lcdc_dev, DSP_CTRL1);
-		layer0_sel = (zorder & m_DSP_LAYER0_SEL)>>8;
-		layer1_sel = (zorder & m_DSP_LAYER1_SEL)>>10;
-		layer2_sel = (zorder & m_DSP_LAYER2_SEL)>>12;
-		layer3_sel = (zorder & m_DSP_LAYER3_SEL)>>14;
-		/*WIN0*/
-		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-		w0_state = win_ctrl & m_WIN0_EN;
-		fmt_id = (win_ctrl & m_WIN0_DATA_FMT)>>1;
-		switch (fmt_id) {
-		case 0:
-			strcpy(format_w0, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w0, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w0, "RGB565");
-			break;
-		case 4:
-			strcpy(format_w0, "YCbCr420");
-			break;
-		case 5:
-			strcpy(format_w0, "YCbCr422");
-			break;
-		case 6:
-			strcpy(format_w0, "YCbCr444");
-			break;
-		default:
-			strcpy(format_w0, "invalid\n");
-			break;
-		}
-		vir_info = lcdc_readl(lcdc_dev,WIN0_VIR);
-		act_info = lcdc_readl(lcdc_dev,WIN0_ACT_INFO);
-		dsp_info = lcdc_readl(lcdc_dev,WIN0_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev,WIN0_DSP_ST);
-		y_factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
-		uv_factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_CBR);
-		w0_vir_y = vir_info & m_WIN0_VIR_STRIDE;
-		w0_vir_uv = (vir_info & m_WIN0_VIR_STRIDE_UV)>>16;
-		w0_act_x = (act_info & m_WIN0_ACT_WIDTH)+1;
-		w0_act_y = ((act_info & m_WIN0_ACT_HEIGHT)>>16)+1;
-		w0_dsp_x = (dsp_info & m_WIN0_DSP_WIDTH)+1;
-		w0_dsp_y = ((dsp_info & m_WIN0_DSP_HEIGHT)>>16)+1;
-		if (w0_state) {
-			w0_st_x = dsp_st & m_WIN0_DSP_XST;
-			w0_st_y = (dsp_st & m_WIN0_DSP_YST)>>16;
-		}
-		w0_y_h_fac = y_factor & m_WIN0_HS_FACTOR_YRGB;
-		w0_y_v_fac = (y_factor & m_WIN0_VS_FACTOR_YRGB)>>16;
-		w0_uv_h_fac = uv_factor & m_WIN0_HS_FACTOR_CBR;
-		w0_uv_v_fac = (uv_factor & m_WIN0_VS_FACTOR_CBR)>>16;
-
-		/*WIN1*/
-		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
-		w1_state = win_ctrl & m_WIN1_EN;
-		fmt_id = (win_ctrl & m_WIN1_DATA_FMT)>>1;
-		switch (fmt_id) {
-		case 0:
-			strcpy(format_w1, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w1, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w1, "RGB565");
-			break;
-		case 4:
-			strcpy(format_w1, "YCbCr420");
-			break;
-		case 5:
-			strcpy(format_w1, "YCbCr422");
-			break;
-		case 6:
-			strcpy(format_w1, "YCbCr444");
-			break;
-		default:
-			strcpy(format_w1, "invalid\n");
-			break;
-		}
-		vir_info = lcdc_readl(lcdc_dev,WIN1_VIR);
-		act_info = lcdc_readl(lcdc_dev,WIN1_ACT_INFO);
-		dsp_info = lcdc_readl(lcdc_dev,WIN1_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev,WIN1_DSP_ST);
-		y_factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_YRGB);
-		uv_factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_CBR);
-		w1_vir_y = vir_info & m_WIN1_VIR_STRIDE;
-		w1_vir_uv = (vir_info & m_WIN1_VIR_STRIDE_UV)>>16;
-		w1_act_x = (act_info & m_WIN1_ACT_WIDTH)+1;
-		w1_act_y = ((act_info & m_WIN1_ACT_HEIGHT)>>16)+1;
-		w1_dsp_x = (dsp_info & m_WIN1_DSP_WIDTH)+1;
-		w1_dsp_y =((dsp_info & m_WIN1_DSP_HEIGHT)>>16)+1;
-		if (w1_state) {
-			w1_st_x = dsp_st & m_WIN1_DSP_XST;
-			w1_st_y = (dsp_st & m_WIN1_DSP_YST)>>16;
-		}
-		w1_y_h_fac = y_factor & m_WIN1_HS_FACTOR_YRGB;
-		w1_y_v_fac = (y_factor & m_WIN1_VS_FACTOR_YRGB)>>16;
-		w1_uv_h_fac = uv_factor & m_WIN1_HS_FACTOR_CBR;
-		w1_uv_v_fac = (uv_factor & m_WIN1_VS_FACTOR_CBR)>>16;
-		/*WIN2*/
-		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
-		w2_state = win_ctrl & m_WIN2_EN;
-		w2_0_state = (win_ctrl & m_WIN2_MST0_EN)>>4;
-		w2_1_state = (win_ctrl & m_WIN2_MST1_EN)>>5;
-		w2_2_state = (win_ctrl & m_WIN2_MST2_EN)>>6;
-		w2_3_state = (win_ctrl & m_WIN2_MST3_EN)>>7;	
-		vir_info = lcdc_readl(lcdc_dev,WIN2_VIR0_1);
-		w2_0_vir_y = vir_info & m_WIN2_VIR_STRIDE0;
-		w2_1_vir_y = (vir_info & m_WIN2_VIR_STRIDE1)>>16;
-		vir_info = lcdc_readl(lcdc_dev,WIN2_VIR2_3);
-		w2_2_vir_y = vir_info & m_WIN2_VIR_STRIDE2;
-		w2_3_vir_y = (vir_info & m_WIN2_VIR_STRIDE3)>>16;			
-		fmt_id = (win_ctrl & m_WIN2_DATA_FMT)>>1;
-		switch (fmt_id) {
-		case 0:
-			strcpy(format_w2, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w2, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w2, "RGB565");
-			break;
-                case 4:
-                        strcpy(format_w2,"8bpp");
-                        break;
-                case 5:
-                        strcpy(format_w2,"4bpp");
-                        break;
-                case 6:
-                        strcpy(format_w2,"2bpp");
-                        break;
-                case 7:
-                        strcpy(format_w2,"1bpp");
-                        break;
-		default:
-			strcpy(format_w2, "invalid\n");
-			break;
-		} 
-		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO0);
-		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST0);
-		w2_0_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH0)+1;
-		w2_0_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT0)>>16)+1;
-		if (w2_0_state) {
-			w2_0_st_x = dsp_st & m_WIN2_DSP_XST0;
-			w2_0_st_y = (dsp_st & m_WIN2_DSP_YST0)>>16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO1);
-		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST1);
-		w2_1_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH1)+1;
-		w2_1_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT1)>>16)+1;
-		if (w2_1_state) {
-			w2_1_st_x = dsp_st & m_WIN2_DSP_XST1;
-			w2_1_st_y = (dsp_st & m_WIN2_DSP_YST1)>>16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO2);
-		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST2);
-		w2_2_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH2)+1;
-		w2_2_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT2)>>16)+1;
-		if (w2_2_state) {
-			w2_2_st_x = dsp_st & m_WIN2_DSP_XST2;
-			w2_2_st_y = (dsp_st & m_WIN2_DSP_YST2)>>16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO3);
-		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST3);
-		w2_3_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH3)+1;
-		w2_3_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT3)>>16)+1;
-		if (w2_3_state) {
-			w2_3_st_x = dsp_st & m_WIN2_DSP_XST3;
-			w2_3_st_y = (dsp_st & m_WIN2_DSP_YST3)>>16;
-		}
-
-		/*WIN3*/
-		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
-		w3_state = win_ctrl & m_WIN3_EN;
-		w3_0_state = (win_ctrl & m_WIN3_MST0_EN)>>4;
-		w3_1_state = (win_ctrl & m_WIN3_MST1_EN)>>5;
-		w3_2_state = (win_ctrl & m_WIN3_MST2_EN)>>6;
-		w3_3_state = (win_ctrl & m_WIN3_MST3_EN)>>7; 
-		vir_info = lcdc_readl(lcdc_dev,WIN3_VIR0_1);
-		w3_0_vir_y = vir_info & m_WIN3_VIR_STRIDE0;
-		w3_1_vir_y = (vir_info & m_WIN3_VIR_STRIDE1)>>16;
-		vir_info = lcdc_readl(lcdc_dev,WIN3_VIR2_3);
-		w3_2_vir_y = vir_info & m_WIN3_VIR_STRIDE2;
-		w3_3_vir_y = (vir_info & m_WIN3_VIR_STRIDE3)>>16;			
-		fmt_id = (win_ctrl & m_WIN3_DATA_FMT)>>1;
-		switch (fmt_id) {
-		case 0:
-			strcpy(format_w3, "ARGB888");
-			break;
-		case 1:
-			strcpy(format_w3, "RGB888");
-			break;
-		case 2:
-			strcpy(format_w3, "RGB565");
-			break;
-		case 4:
-			strcpy(format_w3,"8bpp");
-			break;
-		case 5:
-			strcpy(format_w3,"4bpp");
-			break;
-		case 6:
-			strcpy(format_w3,"2bpp");
-			break;
-		case 7:
-			strcpy(format_w3,"1bpp");
-			break;
-		default:
-			strcpy(format_w3, "invalid");
-			break;
-		} 
-		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO0);
-		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST0);
-		w3_0_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH0)+1;
-		w3_0_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT0)>>16)+1;
-		if (w3_0_state) {
-			w3_0_st_x = dsp_st & m_WIN3_DSP_XST0;
-			w3_0_st_y = (dsp_st & m_WIN3_DSP_YST0)>>16;
-		}
-		
-		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO1);
-		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST1);
-		w3_1_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH1)+1;
-		w3_1_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT1)>>16)+1;
-		if (w3_1_state) {
-			w3_1_st_x = dsp_st & m_WIN3_DSP_XST1;
-			w3_1_st_y = (dsp_st & m_WIN3_DSP_YST1)>>16;
-		}
-		
-		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO2);
-		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST2);
-		w3_2_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH2)+1;
-		w3_2_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT2)>>16)+1;
-		if (w3_2_state) {
-			w3_2_st_x = dsp_st & m_WIN3_DSP_XST2;
-			w3_2_st_y = (dsp_st & m_WIN3_DSP_YST2)>>16;
-		}
-		
-		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO3);
-		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST3);
-		w3_3_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH3)+1;
-		w3_3_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT3)>>16)+1;
-		if (w3_3_state) {
-			w3_3_st_x = dsp_st & m_WIN3_DSP_XST3;
-			w3_3_st_y = (dsp_st & m_WIN3_DSP_YST3)>>16;
-		}
-
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return snprintf(buf, PAGE_SIZE,
-			"z-order:\n"
-			"  layer3_sel_win[%d]\n"
-			"  layer2_sel_win[%d]\n"
-			"  layer1_sel_win[%d]\n"
-			"  layer0_sel_win[%d]\n"
-			"win0:\n"
-			"  state:%d, "
-			"  fmt:%s, "
-			"  y_vir:%d, "
-			"  uv_vir:%d\n"
-			"  xact:%4d, "
-			"  yact:%4d, "
-			"  dsp_x:%4d, "
-			"  dsp_y:%4d, "
-			"  x_st:%4d, "
-			"  y_st:%4d\n"
-			"  y_h_fac:%8d, "
-			"  y_v_fac:%8d, "
-			"  uv_h_fac:%8d, "
-			"  uv_v_fac:%8d\n"
-			"  y_addr: 0x%08x, "
-			"  uv_addr:0x%08x\n"
-			"win1:\n"
-			"  state:%d, "
-			"  fmt:%s, "
-			"  y_vir:%d, "
-			"  uv_vir:%d\n"
-			"  xact:%4d, "
-			"  yact:%4d, "
-			"  dsp_x:%4d, "
-			"  dsp_y:%4d, "
-			"  x_st:%4d, "
-			"  y_st:%4d\n"
-			"  y_h_fac:%8d, "
-			"  y_v_fac:%8d, "
-			"  uv_h_fac:%8d, "
-			"  uv_v_fac:%8d\n"
-			"  y_addr: 0x%08x, "
-			"  uv_addr:0x%08x\n"	
-			"win2:\n"
-			"  state:%d\n"
-			"  fmt:%s\n"
-			"  area0:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"  area1:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"  area2:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"  area3:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"win3:\n"
-			"  state:%d\n"
-			"  fmt:%s\n"
-			"  area0:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"  area1:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d "
-			"  addr:0x%08x\n"
-			"  area2:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n"
-			"  area3:"
-			"  state:%d,"
-			"  y_vir:%4d,"
-			"  dsp_x:%4d,"
-			"  dsp_y:%4d,"
-			"  x_st:%4d,"
-			"  y_st:%4d,"
-			"  addr:0x%08x\n",
-			layer3_sel,layer2_sel,layer1_sel,layer0_sel,
-			w0_state,format_w0,w0_vir_y,w0_vir_uv,w0_act_x,w0_act_y,
-			w0_dsp_x,w0_dsp_y,w0_st_x-h_pw_bp,w0_st_y-v_pw_bp,w0_y_h_fac,w0_y_v_fac,w0_uv_h_fac,
-			w0_uv_v_fac,lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
-			lcdc_readl(lcdc_dev, WIN0_CBR_MST),
-
-			w1_state,format_w1,w1_vir_y,w1_vir_uv,w1_act_x,w1_act_y,
-			w1_dsp_x,w1_dsp_y,w1_st_x-h_pw_bp,w1_st_y-v_pw_bp,w1_y_h_fac,w1_y_v_fac,w1_uv_h_fac,
-			w1_uv_v_fac,lcdc_readl(lcdc_dev, WIN1_YRGB_MST),
-			lcdc_readl(lcdc_dev, WIN1_CBR_MST),			
-
-			w2_state,format_w2,
-			w2_0_state,w2_0_vir_y,w2_0_dsp_x,w2_0_dsp_y,
-			w2_0_st_x-h_pw_bp,w2_0_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST0),
-
-			w2_1_state,w2_1_vir_y,w2_1_dsp_x,w2_1_dsp_y,
-			w2_1_st_x-h_pw_bp,w2_1_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST1),
-
-			w2_2_state,w2_2_vir_y,w2_2_dsp_x,w2_2_dsp_y,
-			w2_2_st_x-h_pw_bp,w2_2_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST2),
-
-			w2_3_state,w2_3_vir_y,w2_3_dsp_x,w2_3_dsp_y,
-			w2_3_st_x-h_pw_bp,w2_3_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST3),
-			
-			w3_state,format_w3,
-			w3_0_state,w3_0_vir_y,w3_0_dsp_x,w3_0_dsp_y,
-			w3_0_st_x-h_pw_bp,w3_0_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST0),
-
-			w3_1_state,w3_1_vir_y,w3_1_dsp_x,w3_1_dsp_y,
-			w3_1_st_x-h_pw_bp,w3_1_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST1),
-
-			w3_2_state,w3_2_vir_y,w3_2_dsp_x,w3_2_dsp_y,
-			w3_2_st_x-h_pw_bp,w3_2_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST2),
-
-			w3_3_state,w3_3_vir_y,w3_3_dsp_x,w3_3_dsp_y,
-			w3_3_st_x-h_pw_bp,w3_3_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST3)
-	);
-			
-}
-
-static int rk3288_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-	if (set) {
-		if (fps == 0) {
-			dev_info(dev_drv->dev, "unsupport set fps=0\n");
-			return 0;
-		}
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
-	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(lcdc_dev->dclk), fps);
-
-	return fps;
-}
-
-static int rk3288_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3;
-	dev_drv->fb3_win_id = order / 1000;
-	dev_drv->fb2_win_id = (order / 100) % 10;
-	dev_drv->fb1_win_id = (order / 10) % 10;
-	dev_drv->fb0_win_id = order % 10;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int rk3288_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
-				  const char *id)
-{
-	int win_id = 0;
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0") || !strcmp(id, "fb4"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1") || !strcmp(id, "fb5"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2") || !strcmp(id, "fb6"))
-		win_id = dev_drv->fb2_win_id;
-	else if (!strcmp(id, "fb3") || !strcmp(id, "fb7"))
-		win_id = dev_drv->fb3_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int rk3288_set_dsp_lut(struct rk_lcdc_driver *dev_drv, int *lut)
-{
-	int i,j;
-	int __iomem *c;
-	int v, r, g, b;
-	int ret = 0;
-
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	if (dev_drv->cur_screen->dsp_lut) {
-		for (i = 0; i < 256; i++) {
-			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
-			c = lcdc_dev->dsp_lut_addr_base + (i << 2);
-			b = (v & 0xff) << 2;
-			g = (v & 0xff00) << 4;
-			r = (v & 0xff0000) << 6;
-			v = r + g + b;
-			for (j = 0; j < 4; j++) {
-				writel_relaxed(v, c);
-				v += (1 + (1 << 10) + (1 << 20)) ;
-				c++;
-			}
-		}
-	} else {
-		dev_err(dev_drv->dev, "no buffer to backup lut data!\n");
-		ret = -1;
-	}
-	
-	do{
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
-		lcdc_cfg_done(lcdc_dev);
-	}while(!lcdc_read_bit(lcdc_dev,DSP_CTRL1,m_DSP_LUT_EN));
-	return ret;
-}
-
-static int rk3288_lcdc_config_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int i;
-	unsigned int mask, val;
-	struct rk_lcdc_win *win = NULL;
-	struct fb_info *fb0 = rk_get_fb(0);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-			     v_STANDBY_EN(lcdc_dev->standby));
-	for (i=0;i<4;i++) {
-		win = dev_drv->win[i];
-		if ((win->state == 0)&&(win->last_state == 1)) {
-			switch (win->id) {
-			case 0:
-				if (dev_drv->version == VOP_FULL_RK3288_V1_0)
-					lcdc_writel(lcdc_dev, WIN0_CTRL1, 0x0);
-				mask =  m_WIN0_EN;
-				val  =  v_WIN0_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask,val);	
-				break;
-			case 1:
-				if (dev_drv->version == VOP_FULL_RK3288_V1_0)
-					lcdc_writel(lcdc_dev, WIN1_CTRL1, 0x0);
-				mask =  m_WIN1_EN;
-				val  =  v_WIN1_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask,val);		
-				break;
-			case 2:
-				mask =  m_WIN2_EN | m_WIN2_MST0_EN | m_WIN2_MST1_EN |
-					m_WIN2_MST2_EN | m_WIN2_MST3_EN;
-				val  =  v_WIN2_EN(0) | v_WIN2_MST0_EN(0) | v_WIN2_MST1_EN(0) |
-					v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask,val);			
-				lcdc_writel(lcdc_dev,WIN2_DSP_INFO0,0);
-				lcdc_writel(lcdc_dev,WIN2_DSP_INFO1,0);
-				lcdc_writel(lcdc_dev,WIN2_DSP_INFO2,0);
-				lcdc_writel(lcdc_dev,WIN2_DSP_INFO3,0);
-				lcdc_writel(lcdc_dev,WIN2_MST0, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN2_MST1, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN2_MST2, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN2_MST3, fb0->fix.smem_start);
-				break;
-			case 3:
-				mask =  m_WIN3_EN | m_WIN3_MST0_EN | m_WIN3_MST1_EN |
-					m_WIN3_MST2_EN | m_WIN3_MST3_EN;
-				val  =  v_WIN3_EN(0) | v_WIN3_MST0_EN(0) |  v_WIN3_MST1_EN(0) |
-					v_WIN3_MST2_EN(0) | v_WIN3_MST3_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask,val);
-				lcdc_writel(lcdc_dev,WIN3_DSP_INFO0,0);
-				lcdc_writel(lcdc_dev,WIN3_DSP_INFO1,0);
-				lcdc_writel(lcdc_dev,WIN3_DSP_INFO2,0);
-				lcdc_writel(lcdc_dev,WIN3_DSP_INFO3,0);
-				lcdc_writel(lcdc_dev,WIN3_MST0, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN3_MST1, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN3_MST2, fb0->fix.smem_start);
-				lcdc_writel(lcdc_dev,WIN3_MST3, fb0->fix.smem_start);
-				break;
-			default:
-				break;
-			}
-		}	
-		win->last_state = win->state;
-	}
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-
-static int rk3288_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN,
-		     v_DIRECT_PATH_EN(open));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3288_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-					struct lcdc_device, driver);
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_SEL,
-		     v_DIRECT_PATCH_SEL(win_id));
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-
-}
-
-static int rk3288_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return ovl;
-}
-static int rk3288_lcdc_set_irq_to_cpu(struct rk_lcdc_driver * dev_drv,int enable)
-{
-       struct lcdc_device *lcdc_dev =
-                                container_of(dev_drv,struct lcdc_device,driver);
-       if (enable)
-               enable_irq(lcdc_dev->irq);
-       else
-               disable_irq(lcdc_dev->irq);
-       return 0;
-}
-
-int rk3288_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 int_reg;
-	int ret;
-
-	if (lcdc_dev->clk_on &&(!dev_drv->suspend_flag)){
-		int_reg = lcdc_readl(lcdc_dev, INTR_CTRL0);
-		if (int_reg & m_LINE_FLAG_INTR_STS) {
-			lcdc_dev->driver.frame_time.last_framedone_t =
-					lcdc_dev->driver.frame_time.framedone_t;
-			lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
-			lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_LINE_FLAG_INTR_CLR,
-				     v_LINE_FLAG_INTR_CLR(1));
-			ret = RK_LF_STATUS_FC;
-		} else
-			ret = RK_LF_STATUS_FR;
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int rk3288_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-				    unsigned int dsp_addr[][4])
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_YRGB_MST);
-		dsp_addr[2][0] = lcdc_readl(lcdc_dev, WIN2_MST0);
-		dsp_addr[2][1] = lcdc_readl(lcdc_dev, WIN2_MST1);
-		dsp_addr[2][2] = lcdc_readl(lcdc_dev, WIN2_MST2);
-		dsp_addr[2][3] = lcdc_readl(lcdc_dev, WIN2_MST3);
-		dsp_addr[3][0] = lcdc_readl(lcdc_dev, WIN3_MST0);
-		dsp_addr[3][1] = lcdc_readl(lcdc_dev, WIN3_MST1);
-		dsp_addr[3][2] = lcdc_readl(lcdc_dev, WIN3_MST2);
-		dsp_addr[3][3] = lcdc_readl(lcdc_dev, WIN3_MST3);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3288_lcdc_set_dsp_cabc(struct rk_lcdc_driver *dev_drv,
-				    int mode, int calc, int up,
-				    int down, int global)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 total_pixel, calc_pixel, stage_up, stage_down;
-	u32 pixel_num, global_dn;
-	u32 mask = 0, val = 0;
-
-	if (dev_drv->version != VOP_FULL_RK3288_V1_1) {
-		pr_err("vop version:%x, not supoort cabc\n", dev_drv->version);
-		return 0;
-	}
-	if (!screen->cabc_lut) {
-		pr_err("screen cabc lut not config, so not open cabc\n");
-		return 0;
-	}
-	dev_drv->cabc_mode = mode;
-	if (!dev_drv->cabc_mode) {
-		spin_lock(&lcdc_dev->reg_lock);
-		if (lcdc_dev->clk_on) {
-			lcdc_msk_reg(lcdc_dev, CABC_CTRL0,
-				     m_CABC_HANDLE_EN | m_CABC_EN,
-				     v_CABC_EN(0) | v_CABC_HANDLE_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-		}
-		pr_info("mode = 0, close cabc\n");
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-
-	total_pixel = screen->mode.xres * screen->mode.yres;
-	pixel_num = 1000 - calc;
-	calc_pixel = (total_pixel * pixel_num) / 1000;
-	stage_up = up;
-	stage_down = down;
-	global_dn = global;
-	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
-		mode, calc, stage_up, stage_down, global_dn);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_CABC_EN | m_CABC_HANDLE_EN | m_PWM_CONFIG_MODE |
-			m_CABC_CALC_PIXEL_NUM;
-		val = v_CABC_EN(1) | v_CABC_HANDLE_EN(1) |
-			v_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
-			v_CABC_CALC_PIXEL_NUM(calc_pixel);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL0, mask, val);
-
-		mask = m_CABC_LUT_EN | m_CABC_TOTAL_PIXEL_NUM;
-		val = v_CABC_LUT_EN(1) | v_CABC_TOTAL_PIXEL_NUM(total_pixel);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, mask, val);
-
-		mask = m_CABC_STAGE_DOWN | m_CABC_STAGE_UP |
-			m_CABC_STAGE_MODE | m_MAX_SCALE_CFG_VALUE |
-			m_MAX_SCALE_CFG_ENABLE;
-		val = v_CABC_STAGE_DOWN(stage_down) |
-			v_CABC_STAGE_UP(stage_up) |
-			v_CABC_STAGE_MODE(0) | v_MAX_SCALE_CFG_VALUE(1) |
-			v_MAX_SCALE_CFG_ENABLE(0);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL2, mask, val);
-
-		mask = m_CABC_GLOBAL_DN | m_CABC_GLOBAL_DN_LIMIT_EN;
-		val = v_CABC_GLOBAL_DN(global_dn) |
-			v_CABC_GLOBAL_DN_LIMIT_EN(1);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL3, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-/*
-	a:[-30~0]:
-	    sin_hue = sin(a)*256 +0x100;
-	    cos_hue = cos(a)*256;
-	a:[0~30]
-	    sin_hue = sin(a)*256;
-	    cos_hue = cos(a)*256;
-*/
-static int rk3288_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,bcsh_hue_mode mode)
-{
-
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-			
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_H);
-		switch(mode){
-		case H_SIN:
-			val &= m_BCSH_SIN_HUE;
-			break;
-		case H_COS:
-			val &= m_BCSH_COS_HUE;
-			val >>= 16;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return val;
-}
-
-
-static int rk3288_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,int sin_hue, int cos_hue)
-{
-
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
-		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
-		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}	
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static int rk3288_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode,int value)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on) {
-		switch (mode) {
-		case BRIGHTNESS:
-		/*from 0 to 255,typical is 128*/
-			if (value < 0x80)
-				value += 0x80;
-			else if (value >= 0x80)
-				value = value - 0x80;
-			mask =  m_BCSH_BRIGHTNESS;
-			val = v_BCSH_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-		/*from 0 to 510,typical is 256*/
-			mask =  m_BCSH_CONTRAST;
-			val =  v_BCSH_CONTRAST(value);
-			break;
-		case SAT_CON:
-		/*from 0 to 1015,typical is 256*/
-			mask = m_BCSH_SAT_CON;
-			val = v_BCSH_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk3288_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= m_BCSH_BRIGHTNESS;
-			if(val > 0x80)
-				val -= 0x80;
-			else
-				val += 0x80;
-			break;
-		case CONTRAST:
-			val &= m_BCSH_CONTRAST;
-			val >>= 8;
-			break;
-		case SAT_CON:
-			val &= m_BCSH_SAT_CON;
-			val >>= 20;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-
-static int rk3288_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (open) {
-			lcdc_writel(lcdc_dev,BCSH_COLOR_BAR,0x1);
-			lcdc_writel(lcdc_dev,BCSH_BCS,0xd0010000);
-			lcdc_writel(lcdc_dev,BCSH_H,0x01000000);
-			dev_drv->bcsh.enable = 1;
-		} else {
-			mask = m_BCSH_EN;
-			val = v_BCSH_EN(0);
-			lcdc_msk_reg(lcdc_dev, BCSH_COLOR_BAR, mask, val);
-			dev_drv->bcsh.enable = 0;
-		}
-		if (dev_drv->version == VOP_FULL_RK3288_V1_1)
-			rk3288_lcdc_bcsh_path_sel(dev_drv);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3288_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv,
-				     bool enable)
-{
-	if (!enable || !dev_drv->bcsh.enable) {
-		rk3288_lcdc_open_bcsh(dev_drv, false);
-		return 0;
-	}
-
-	if (dev_drv->bcsh.brightness <= 255 ||
-	    dev_drv->bcsh.contrast <= 510 ||
-	    dev_drv->bcsh.sat_con <= 1015 ||
-	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
-		rk3288_lcdc_open_bcsh(dev_drv, true);
-		if (dev_drv->bcsh.brightness <= 255)
-			rk3288_lcdc_set_bcsh_bcs(dev_drv, BRIGHTNESS,
-						 dev_drv->bcsh.brightness);
-		if (dev_drv->bcsh.contrast <= 510)
-			rk3288_lcdc_set_bcsh_bcs(dev_drv, CONTRAST,
-						 dev_drv->bcsh.contrast);
-		if (dev_drv->bcsh.sat_con <= 1015)
-			rk3288_lcdc_set_bcsh_bcs(dev_drv, SAT_CON,
-						 dev_drv->bcsh.sat_con);
-		if (dev_drv->bcsh.sin_hue <= 511 &&
-		    dev_drv->bcsh.cos_hue <= 511)
-			rk3288_lcdc_set_bcsh_hue(dev_drv,
-						 dev_drv->bcsh.sin_hue,
-						 dev_drv->bcsh.cos_hue);
-	}
-	return 0;
-}
-
-static int rk3288_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
-				    struct overscan *overscan)
-{
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	rk3288_lcdc_post_cfg(dev_drv);
-
-	return 0;
-}
-
-static struct rk_lcdc_win lcdc_win[] = {
-	[0] = {
-	       .name = "win0",
-	       .id = 0,
-	       .support_3d = false,
-	       },
-	[1] = {
-	       .name = "win1",
-	       .id = 1,
-	       .support_3d = false,
-	       },
-	[2] = {
-	       .name = "win2",
-	       .id = 2,
-	       .support_3d = false,
-	       },
-	[3] = {
-	       .name = "win3",
-	       .id = 3,
-	       .support_3d = false,
-	       },	       
-};
-
-static int rk3288_lcdc_extern_func(struct rk_lcdc_driver *dev_drv, int cmd)
-{
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	if (unlikely(!vop_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
-		return 0;
-	}
-
-	switch (cmd) {
-	case SET_DSP_MIRROR:
-		mask = m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN;
-		val = v_DSP_X_MIR_EN(screen->x_mirror) |
-		      v_DSP_Y_MIR_EN(screen->y_mirror);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-		pr_info("%s: xmirror: %d, ymirror: %d\n",
-			__func__, dev_drv->cur_screen->x_mirror,
-			dev_drv->cur_screen->y_mirror);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open 			= rk3288_lcdc_open,
-	.win_direct_en		= rk3288_lcdc_win_direct_en,
-	.load_screen 		= rk3288_load_screen,
-	.get_dspbuf_info	= rk3288_get_dspbuf_info,
-	.post_dspbuf		= rk3288_post_dspbuf,
-	.set_par 		= rk3288_lcdc_set_par,
-	.pan_display 		= rk3288_lcdc_pan_display,
-	.direct_set_addr 	= rk3288_lcdc_direct_set_win_addr,
-	.lcdc_reg_update	= rk3288_lcdc_reg_update,
-	.blank 			= rk3288_lcdc_blank,
-	.ioctl 			= rk3288_lcdc_ioctl,
-	.suspend 		= rk3288_lcdc_early_suspend,
-	.resume 		= rk3288_lcdc_early_resume,
-	.get_win_state 		= rk3288_lcdc_get_win_state,
-	.area_support_num = rk3288_lcdc_get_area_num,
-	.ovl_mgr 		= rk3288_lcdc_ovl_mgr,
-	.get_disp_info 		= rk3288_lcdc_get_disp_info,
-	.fps_mgr 		= rk3288_lcdc_fps_mgr,
-	.fb_get_win_id 		= rk3288_lcdc_get_win_id,
-	.fb_win_remap 		= rk3288_fb_win_remap,
-	.set_dsp_lut 		= rk3288_set_dsp_lut,
-	.poll_vblank 		= rk3288_lcdc_poll_vblank,
-	.dpi_open 		= rk3288_lcdc_dpi_open,
-	.dpi_win_sel 		= rk3288_lcdc_dpi_win_sel,
-	.dpi_status 		= rk3288_lcdc_dpi_status,
-	.get_dsp_addr 		= rk3288_lcdc_get_dsp_addr,
-	.set_dsp_cabc		= rk3288_lcdc_set_dsp_cabc,
-	.set_dsp_bcsh_hue 	= rk3288_lcdc_set_bcsh_hue,
-	.set_dsp_bcsh_bcs 	= rk3288_lcdc_set_bcsh_bcs,
-	.get_dsp_bcsh_hue 	= rk3288_lcdc_get_bcsh_hue,
-	.get_dsp_bcsh_bcs 	= rk3288_lcdc_get_bcsh_bcs,
-	.open_bcsh		= rk3288_lcdc_open_bcsh,
-	.dump_reg 		= rk3288_lcdc_reg_dump,
-	.cfg_done		= rk3288_lcdc_config_done,
-	.set_irq_to_cpu  	= rk3288_lcdc_set_irq_to_cpu,
-	.mmu_en    = rk3288_lcdc_mmu_en,
-	.set_overscan   	= rk3288_lcdc_set_overscan,
-
-};
-
-#ifdef LCDC_IRQ_DEBUG
-static int rk3288_lcdc_parse_irq(struct lcdc_device *lcdc_dev,unsigned int reg_val)
-{
-	if (reg_val & m_WIN0_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN0_EMPTY_INTR_CLR,
-			     v_WIN0_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"win0 empty irq!");
-	}else if (reg_val & m_WIN1_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN1_EMPTY_INTR_CLR,
-			     v_WIN1_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"win1 empty irq!");
-	}else if (reg_val & m_WIN2_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN2_EMPTY_INTR_CLR,
-			     v_WIN2_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"win2 empty irq!");
-	}else if (reg_val & m_WIN3_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN3_EMPTY_INTR_CLR,
-			     v_WIN3_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"win3 empty irq!");
-	}else if (reg_val & m_HWC_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_HWC_EMPTY_INTR_CLR,
-			     v_HWC_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"HWC empty irq!");
-	}else if (reg_val & m_POST_BUF_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_POST_BUF_EMPTY_INTR_CLR,
-			     v_POST_BUF_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"post buf empty irq!");
-	}else if (reg_val & m_PWM_GEN_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_PWM_GEN_INTR_CLR,
-			     v_PWM_GEN_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"PWM gen irq!");
-	}
-
-	return 0;
-}
-#endif
-
-static irqreturn_t rk3288_lcdc_isr(int irq, void *dev_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    (struct lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 intr0_reg;
-
-	intr0_reg = lcdc_readl(lcdc_dev, INTR_CTRL0);
-
-	if(intr0_reg & m_FS_INTR_STS){
-		timestamp = ktime_get();
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_FS_INTR_CLR,
-			     v_FS_INTR_CLR(1));
-		/*if(lcdc_dev->driver.wait_fs){	*/
-		if (0) {
-			spin_lock(&(lcdc_dev->driver.cpl_lock));
-			complete(&(lcdc_dev->driver.frame_done));
-			spin_unlock(&(lcdc_dev->driver.cpl_lock));
-		}
-		lcdc_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-
-	}else if(intr0_reg & m_LINE_FLAG_INTR_STS){
-		lcdc_dev->driver.frame_time.last_framedone_t =
-				lcdc_dev->driver.frame_time.framedone_t;
-		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_LINE_FLAG_INTR_CLR,
-			     v_LINE_FLAG_INTR_CLR(1));
-	}else if(intr0_reg & m_BUS_ERROR_INTR_STS){
-		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_BUS_ERROR_INTR_CLR,
-			     v_BUS_ERROR_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev,"buf_error_int!");
-	}
-
-	/* for win empty debug */
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-	intr1_reg = lcdc_readl(lcdc_dev, INTR_CTRL1);
-	if (intr1_reg != 0) {
-		rk3288_lcdc_parse_irq(lcdc_dev,intr1_reg);
-	}
-#endif
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_PM)
-static int rk3288_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk3288_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define rk3288_lcdc_suspend NULL
-#define rk3288_lcdc_resume  NULL
-#endif
-
-static int rk3288_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
-{
-	struct device_node *np = lcdc_dev->dev->of_node;
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,prop", &val))
-		lcdc_dev->prop = PRMRY;	/*default set it as primary */
-	else
-		lcdc_dev->prop = val;
-
-	if (of_property_read_u32(np, "rockchip,mirror", &val))
-		dev_drv->rotate_mode = NO_MIRROR;
-	else
-		dev_drv->rotate_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
-		dev_drv->cabc_mode = 0;	/* default set close cabc */
-	else
-		dev_drv->cabc_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-		lcdc_dev->pwr18 = false;	/*default set it as 3.xv power supply */
-	else
-		lcdc_dev->pwr18 = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
-	else
-		dev_drv->fb_win_map = val;
-
-	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
-		dev_drv->bcsh.enable = false;
-	else
-		dev_drv->bcsh.enable = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,brightness", &val))
-		dev_drv->bcsh.brightness = 0xffff;
-	else
-		dev_drv->bcsh.brightness = val;
-
-	if (of_property_read_u32(np, "rockchip,contrast", &val))
-		dev_drv->bcsh.contrast = 0xffff;
-	else
-		dev_drv->bcsh.contrast = val;
-
-	if (of_property_read_u32(np, "rockchip,sat-con", &val))
-		dev_drv->bcsh.sat_con = 0xffff;
-	else
-		dev_drv->bcsh.sat_con = val;
-
-	if (of_property_read_u32(np, "rockchip,hue", &val)) {
-		dev_drv->bcsh.sin_hue = 0xffff;
-		dev_drv->bcsh.cos_hue = 0xffff;
-	} else {
-		dev_drv->bcsh.sin_hue = val & 0xff;
-		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
-	}
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		dev_drv->iommu_enabled = 0;
-	else
-		dev_drv->iommu_enabled = val;
-
-	if (of_property_read_u32(np, "rockchip,dsp_mode", &val))
-		dev_drv->dsp_mode = DEFAULT_MODE;
-	else
-		dev_drv->dsp_mode = val;
-
-	return 0;
-}
-
-static int rk3288_lcdc_probe(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct device_node *np = pdev->dev.of_node;
-	int prop;
-	int ret = 0;
-
-	/*if the primary lcdc has not registered ,the extend
-	   lcdc register later */
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		if (!is_prmry_rk_lcdc_registered())
-			return -EPROBE_DEFER;
-	}
-	lcdc_dev = devm_kzalloc(dev,
-				sizeof(struct lcdc_device), GFP_KERNEL);
-	if (!lcdc_dev) {
-		dev_err(&pdev->dev, "rk3288 lcdc device kmalloc fail!");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->dev = dev;
-	rk3288_lcdc_parse_dt(lcdc_dev);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-	lcdc_dev->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(lcdc_dev->regs))
-		return PTR_ERR(lcdc_dev->regs);
-
-	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
-	if (IS_ERR(lcdc_dev->regsbak))
-		return PTR_ERR(lcdc_dev->regsbak);
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + GAMMA_LUT_ADDR);
-	lcdc_dev->id = rk3288_lcdc_get_id(lcdc_dev->reg_phy_base);
-	if (lcdc_dev->id < 0) {
-		dev_err(&pdev->dev, "no such lcdc device!\n");
-		return -ENXIO;
-	}
-	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
-	dev_drv = &lcdc_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = prop;
-	dev_drv->id = lcdc_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
-	spin_lock_init(&lcdc_dev->reg_lock);
-
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if (lcdc_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			lcdc_dev->id);
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(dev, lcdc_dev->irq, rk3288_lcdc_isr,
-			       IRQF_DISABLED | IRQF_SHARED, dev_name(dev), lcdc_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			lcdc_dev->irq, ret);
-		return ret;
-	}
-
-	if (dev_drv->iommu_enabled) {
-		if(lcdc_dev->id == 0){
-			strcpy(dev_drv->mmu_dts_name, VOPB_IOMMU_COMPATIBLE_NAME);
-		}else{
-			strcpy(dev_drv->mmu_dts_name, VOPL_IOMMU_COMPATIBLE_NAME);
-		}
-	}
-
-	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
-		return ret;
-	}
-	lcdc_dev->screen = dev_drv->screen0;
-	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
-		lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	return 0;
-}
-
-static int rk3288_lcdc_remove(struct platform_device *pdev)
-{
-
-	return 0;
-}
-
-static void rk3288_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-
-	rk3288_lcdc_deint(lcdc_dev);
-	rk_disp_pwr_disable(&lcdc_dev->driver);
-}
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3288_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3288-lcdc",},
-	{}
-};
-#endif
-
-static struct platform_driver rk3288_lcdc_driver = {
-	.probe = rk3288_lcdc_probe,
-	.remove = rk3288_lcdc_remove,
-	.driver = {
-		   .name = "rk3288-lcdc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(rk3288_lcdc_dt_ids),
-		   },
-	.suspend = rk3288_lcdc_suspend,
-	.resume = rk3288_lcdc_resume,
-	.shutdown = rk3288_lcdc_shutdown,
-};
-
-static int __init rk3288_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk3288_lcdc_driver);
-}
-
-static void __exit rk3288_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk3288_lcdc_driver);
-}
-
-fs_initcall(rk3288_lcdc_module_init);
-module_exit(rk3288_lcdc_module_exit);
-
-
diff --git a/drivers/video/rockchip/lcdc/rk3288_lcdc.h b/drivers/video/rockchip/lcdc/rk3288_lcdc.h
deleted file mode 100644
index 77218d2a6610..000000000000
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.h
+++ /dev/null
@@ -1,1474 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK3288_LCDC_H_
-#define RK3288_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-
-
-/*******************register definition**********************/
-
-#define REG_CFG_DONE            	(0x0000)
-#define VERSION_INFO            	(0x0004)
-#define m_RTL_VERSION 			(0xffff<<0)
-#define m_FPGA_VERSION			(0xffff<<16)
-#define VOP_FULL_RK3288_V1_0		0x03007236
-#define VOP_FULL_RK3288_V1_1		0x0a050a01
-#define SYS_CTRL                	(0x0008)
-#define v_DIRECT_PATH_EN(x)     	(((x)&1)<<0)
-#define v_DIRECT_PATCH_SEL(x)   	(((x)&3)<<1)
-#define v_DOUB_CHANNEL_EN(x)    	(((x)&1)<<3)
-#define v_DOUB_CH_OVERLAP_NUM(x)        (((x)&0xf)<<4)
-#define v_EDPI_HALT_EN(x)    		(((x)&1)<<8)
-#define v_EDPI_WMS_MODE(x)              (((x)&1)<<9)
-#define v_EDPI_WMS_FS(x)                (((x)&1)<<10)
-#define v_HDMI_DCLK_OUT_EN(x)		(((x)&1)<<11)
-#define v_RGB_OUT_EN(x)                 (((x)&1)<<12)
-#define v_HDMI_OUT_EN(x)                (((x)&1)<<13)
-#define v_EDP_OUT_EN(x)                 (((x)&1)<<14)
-#define v_MIPI_OUT_EN(x)                (((x)&1)<<15)
-#define v_DMA_BURST_LENGTH(x) 		(((x)&3)<<18)
-#define v_MMU_EN(x)    	        	(((x)&1)<<20)
-#define v_DMA_STOP(x)                   (((x)&1)<<21)
-#define v_STANDBY_EN(x)      		(((x)&1)<<22)
-#define v_AUTO_GATING_EN(x)   		(((x)&1)<<23)
-
-#define m_DIRECT_PATH_EN     	        (1<<0)
-#define m_DIRECT_PATCH_SEL  		(3<<1)
-#define m_DOUB_CHANNEL_EN    		(1<<3)
-#define m_DOUB_CH_OVERLAP_NUM           (0xf<<4)
-#define m_EDPI_HALT_EN       		(1<<8)
-#define m_EDPI_WMS_MODE                 (1<<9)
-#define m_EDPI_WMS_FS                   (1<<10)
-#define m_HDMI_DCLK_OUT_EN		(1<<11)
-#define m_RGB_OUT_EN                    (1<<12)
-#define m_HDMI_OUT_EN                   (1<<13)
-#define m_EDP_OUT_EN                    (1<<14)
-#define m_MIPI_OUT_EN                   (1<<15)
-#define m_DMA_BURST_LENGTH    		(3<<18)
-#define m_MMU_EN       	        	(1<<20)
-#define m_DMA_STOP			(1<<21)
-#define m_STANDBY_EN      		(1<<22)
-#define m_AUTO_GATING_EN      		(1<<23)
-#define SYS_CTRL1            		(0x000c)
-#define v_NOC_HURRY_EN(x)               (((x)&0x1 )<<0 ) 
-#define v_NOC_HURRY_VALUE(x)            (((x)&0x3 )<<1 )
-#define v_NOC_HURRY_THRESHOLD(x)        (((x)&0x3f)<<3 )
-#define v_NOC_QOS_EN(x)                 (((x)&0x1 )<<9 )
-#define v_NOC_WIN_QOS(x)                (((x)&0x3 )<<10)
-#define v_AXI_MAX_OUTSTANDING_EN(x)     (((x)&0x1 )<<12)
-#define v_AXI_OUTSTANDING_MAX_NUM(x)    (((x)&0x1f)<<13)
-
-#define m_NOC_HURRY_EN                  (0x1 <<0 )
-#define m_NOC_HURRY_VALUE               (0x3 <<1 )
-#define m_NOC_HURRY_THRESHOLD           (0x3f<<3 )
-#define m_NOC_QOS_EN                    (0x1 <<9 )
-#define m_NOC_WIN_QOS                   (0x3 <<10)
-#define m_AXI_MAX_OUTSTANDING_EN        (0x1 <<12)
-#define m_AXI_OUTSTANDING_MAX_NUM       (0x1f<<13)
-
-#define DSP_CTRL0               	(0x0010)
-#define v_DSP_OUT_MODE(x)       	(((x)&0x0f)<<0)
-#define v_DSP_HSYNC_POL(x)      	(((x)&1)<<4)
-#define v_DSP_VSYNC_POL(x)      	(((x)&1)<<5)
-#define v_DSP_DEN_POL(x)        	(((x)&1)<<6)
-#define v_DSP_DCLK_POL(x)       	(((x)&1)<<7)
-#define v_DSP_DCLK_DDR(x)       	(((x)&1)<<8)
-#define v_DSP_DDR_PHASE(x)      	(((x)&1)<<9)
-#define v_DSP_INTERLACE(x)      	(((x)&1)<<10)
-#define v_DSP_FIELD_POL(x)      	(((x)&1)<<11)
-#define v_DSP_BG_SWAP(x)        	(((x)&1)<<12)
-#define v_DSP_RB_SWAP(x)        	(((x)&1)<<13)
-#define v_DSP_RG_SWAP(x)        	(((x)&1)<<14)
-#define v_DSP_DELTA_SWAP(x)     	(((x)&1)<<15)
-#define v_DSP_DUMMY_SWAP(x)     	(((x)&1)<<16)
-#define v_DSP_OUT_ZERO(x)       	(((x)&1)<<17)
-#define v_DSP_BLANK_EN(x)       	(((x)&1)<<18)
-#define v_DSP_BLACK_EN(x)       	(((x)&1)<<19)
-#define v_DSP_CCIR656_AVG(x)    	(((x)&1)<<20)
-#define v_DSP_YUV_CLIP(x)       	(((x)&1)<<21)
-#define v_DSP_X_MIR_EN(x)       	(((x)&1)<<22)
-#define v_DSP_Y_MIR_EN(x)       	(((x)&1)<<23)
-#define m_DSP_OUT_MODE       		(0x0f<<0)
-#define m_DSP_HSYNC_POL       		(1<<4)
-#define m_DSP_VSYNC_POL       		(1<<5)
-#define m_DSP_DEN_POL       		(1<<6)
-#define m_DSP_DCLK_POL        		(1<<7)
-#define m_DSP_DCLK_DDR      		(1<<8)
-#define m_DSP_DDR_PHASE      		(1<<9)
-#define m_DSP_INTERLACE      		(1<<10)
-#define m_DSP_FIELD_POL      		(1<<11)
-#define m_DSP_BG_SWAP       		(1<<12)
-#define m_DSP_RB_SWAP       		(1<<13)
-#define m_DSP_RG_SWAP        		(1<<14)
-#define m_DSP_DELTA_SWAP      		(1<<15)
-#define m_DSP_DUMMY_SWAP       		(1<<16)
-#define m_DSP_OUT_ZERO       		(1<<17)
-#define m_DSP_BLANK_EN     		(1<<18)
-#define m_DSP_BLACK_EN      		(1<<19)
-#define m_DSP_CCIR656_AVG     		(1<<20)
-#define m_DSP_YUV_CLIP      		(1<<21)
-#define m_DSP_X_MIR_EN      		(1<<22)
-#define m_DSP_Y_MIR_EN      		(1<<23)
-
-#define DSP_CTRL1 			(0x0014)
-#define v_DSP_LUT_EN(x)         	(((x)&1)<<0)
-#define v_PRE_DITHER_DOWN_EN(x) 	(((x)&1)<<1)
-#define v_DITHER_DOWN_EN(x)     	(((x)&1)<<2)
-#define v_DITHER_DOWN_MODE(x)   	(((x)&1)<<3)
-#define v_DITHER_DOWN_SEL(x)    	(((x)&1)<<4)
-#define v_DITHER_UP_EN(x)		(((x)&1)<<6)
-#define v_DSP_LAYER0_SEL(x)		(((x)&3)<<8)
-#define v_DSP_LAYER1_SEL(x)		(((x)&3)<<10)
-#define v_DSP_LAYER2_SEL(x)		(((x)&3)<<12)
-#define v_DSP_LAYER3_SEL(x)		(((x)&3)<<14)
-#define m_DSP_LUT_EN          		(1<<0)
-#define m_PRE_DITHER_DOWN_EN  		(1<<1)
-#define m_DITHER_DOWN_EN      		(1<<2)
-#define m_DITHER_DOWN_MODE   		(1<<3)
-#define m_DITHER_DOWN_SEL    		(1<<4)
-#define m_DITHER_UP_EN			(1<<6)
-#define m_DSP_LAYER0_SEL		(3<<8)
-#define m_DSP_LAYER1_SEL		(3<<10)
-#define m_DSP_LAYER2_SEL		(3<<12)
-#define m_DSP_LAYER3_SEL		(3<<14)
-
-#define DSP_BG 				(0x0018)
-#define v_DSP_BG_BLUE(x)        	(((x<<2)&0x3ff)<<0)
-#define v_DSP_BG_GREEN(x)       	(((x<<2)&0x3ff)<<10)
-#define v_DSP_BG_RED(x)         	(((x<<2)&0x3ff)<<20)
-#define m_DSP_BG_BLUE        		(0x3ff<<0)
-#define m_DSP_BG_GREEN      		(0x3ff<<10)
-#define m_DSP_BG_RED        		(0x3ff<<20)
-
-#define MCU_CTRL 	        	(0x001c)
-#define v_MCU_PIX_TOTAL(x)      	(((x)&0x3f)<<0)
-#define v_MCU_CS_PST(x)         	(((x)&0xf)<<6)
-#define v_MCU_CS_PEND(x)        	(((x)&0x3f)<<10)
-#define v_MCU_RW_PST(x)         	(((x)&0xf)<<16)
-#define v_MCU_RW_PEND(x)        	(((x)&0x3f)<<20)
-#define v_MCU_CLK_SEL(x)        	(((x)&1)<<26)   
-#define v_MCU_HOLD_MODE(x)      	(((x)&1)<<27)
-#define v_MCU_FRAME_ST(x)       	(((x)&1)<<28)
-#define v_MCU_RS(x)         		(((x)&1)<<29)
-#define v_MCU_BYPASS(x)         	(((x)&1)<<30)
-#define v_MCU_TYPE(x)            	(((x)&1)<<31)
-#define m_MCU_PIX_TOTAL       		(0x3f<<0)
-#define m_MCU_CS_PST          		(0xf<<6)
-#define m_MCU_CS_PEND        		(0x3f<<10)
-#define m_MCU_RW_PST          		(0xf<<16)
-#define m_MCU_RW_PEND         		(0x3f<<20)
-#define m_MCU_CLK_SEL         		(1<<26)   
-#define m_MCU_HOLD_MODE       		(1<<27)
-#define m_MCU_FRAME_ST        		(1<<28)
-#define m_MCU_RS          		(1<<29)
-#define m_MCU_BYPASS          		(1<<30)
-#define m_MCU_TYPE           		((u32)1<<31)
-
-#define INTR_CTRL0 			(0x0020)
-#define v_DSP_HOLD_VALID_INTR_STS(x)    (((x)&1)<<0)
-#define v_FS_INTR_STS(x)        	(((x)&1)<<1)
-#define v_LINE_FLAG_INTR_STS(x) 	(((x)&1)<<2)
-#define v_BUS_ERROR_INTR_STS(x) 	(((x)&1)<<3)
-#define v_DSP_HOLD_VALID_INTR_EN(x)  	(((x)&1)<<4)
-#define v_FS_INTR_EN(x)         	(((x)&1)<<5)
-#define v_LINE_FLAG_INTR_EN(x)  	(((x)&1)<<6)
-#define v_BUS_ERROR_INTR_EN(x)        	(((x)&1)<<7)
-#define v_DSP_HOLD_VALID_INTR_CLR(x)    (((x)&1)<<8)
-#define v_FS_INTR_CLR(x)        	(((x)&1)<<9)
-#define v_LINE_FLAG_INTR_CLR(x)        	(((x)&1)<<10)
-#define v_BUS_ERROR_INTR_CLR(x)        	(((x)&1)<<11)
-#define v_DSP_LINE_FLAG_NUM(x)        	(((x)&0xfff)<<12)
-
-#define m_DSP_HOLD_VALID_INTR_STS     	(1<<0)
-#define m_FS_INTR_STS         		(1<<1)
-#define m_LINE_FLAG_INTR_STS  		(1<<2)
-#define m_BUS_ERROR_INTR_STS 		(1<<3)
-#define m_DSP_HOLD_VALID_INTR_EN   	(1<<4)
-#define m_FS_INTR_EN         		(1<<5)
-#define m_LINE_FLAG_INTR_EN 		(1<<6)
-#define m_BUS_ERROR_INTR_EN         	(1<<7)
-#define m_DSP_HOLD_VALID_INTR_CLR     	(1<<8)
-#define m_FS_INTR_CLR       		(1<<9)
-#define m_LINE_FLAG_INTR_CLR         	(1<<10)
-#define m_BUS_ERROR_INTR_CLR         	(1<<11)
-#define m_DSP_LINE_FLAG_NUM         	(0xfff<<12)
-
-#define INTR_CTRL1 			(0x0024)
-#define v_WIN0_EMPTY_INTR_STS(x)	(((x)&1)<<0)
-#define v_WIN1_EMPTY_INTR_STS(x)	(((x)&1)<<1)
-#define v_WIN2_EMPTY_INTR_STS(x)	(((x)&1)<<2)
-#define v_WIN3_EMPTY_INTR_STS(x)	(((x)&1)<<3)
-#define v_HWC_EMPTY_INTR_STS(x)		(((x)&1)<<4)
-#define v_POST_BUF_EMPTY_INTR_STS(x)	(((x)&1)<<5)
-#define v_PWM_GEN_INTR_STS(x)		(((x)&1)<<6)
-#define v_WIN0_EMPTY_INTR_EN(x)		(((x)&1)<<8)
-#define v_WIN1_EMPTY_INTR_EN(x)		(((x)&1)<<9)
-#define v_WIN2_EMPTY_INTR_EN(x)		(((x)&1)<<10)
-#define v_WIN3_EMPTY_INTR_EN(x)		(((x)&1)<<11)
-#define v_HWC_EMPTY_INTR_EN(x)		(((x)&1)<<12)
-#define v_POST_BUF_EMPTY_INTR_EN(x)	(((x)&1)<<13)
-#define v_PWM_GEN_INTR_EN(x)		(((x)&1)<<14)
-#define v_WIN0_EMPTY_INTR_CLR(x)	(((x)&1)<<16)
-#define v_WIN1_EMPTY_INTR_CLR(x)	(((x)&1)<<17)
-#define v_WIN2_EMPTY_INTR_CLR(x)	(((x)&1)<<18)
-#define v_WIN3_EMPTY_INTR_CLR(x)	(((x)&1)<<19)
-#define v_HWC_EMPTY_INTR_CLR(x)		(((x)&1)<<20)
-#define v_POST_BUF_EMPTY_INTR_CLR(x)	(((x)&1)<<21)
-#define v_PWM_GEN_INTR_CLR(x)		(((x)&1)<<22)
-
-#define m_WIN0_EMPTY_INTR_STS 		(1<<0)
-#define m_WIN1_EMPTY_INTR_STS 		(1<<1)
-#define m_WIN2_EMPTY_INTR_STS 		(1<<2)
-#define m_WIN3_EMPTY_INTR_STS 		(1<<3)
-#define m_HWC_EMPTY_INTR_STS 		(1<<4)
-#define m_POST_BUF_EMPTY_INTR_STS 	(1<<5)
-#define m_PWM_GEN_INTR_STS 		(1<<6)
-#define m_WIN0_EMPTY_INTR_EN 		(1<<8)
-#define m_WIN1_EMPTY_INTR_EN 		(1<<9)
-#define m_WIN2_EMPTY_INTR_EN 		(1<<10)
-#define m_WIN3_EMPTY_INTR_EN 		(1<<11)
-#define m_HWC_EMPTY_INTR_EN 		(1<<12)
-#define m_POST_BUF_EMPTY_INTR_EN 	(1<<13)
-#define m_PWM_GEN_INTR_EN 		(1<<14)
-#define m_WIN0_EMPTY_INTR_CLR 		(1<<16)
-#define m_WIN1_EMPTY_INTR_CLR 		(1<<17)
-#define m_WIN2_EMPTY_INTR_CLR 		(1<<18)
-#define m_WIN3_EMPTY_INTR_CLR 		(1<<19)
-#define m_HWC_EMPTY_INTR_CLR 		(1<<20)
-#define m_POST_BUF_EMPTY_INTR_CLR 	(1<<21)
-#define m_PWM_GEN_INTR_CLR 		(1<<22)
-
-/*win0 register*/
-#define WIN0_CTRL0 			(0x0030)
-#define v_WIN0_EN(x)			(((x)&1)<<0)
-#define v_WIN0_DATA_FMT(x)		(((x)&7)<<1)
-#define v_WIN0_FMT_10(x)		(((x)&1)<<4)
-#define v_WIN0_LB_MODE(x)		(((x)&7)<<5)
-#define v_WIN0_INTERLACE_READ(x)	(((x)&1)<<8)
-#define v_WIN0_NO_OUTSTANDING(x)	(((x)&1)<<9)
-#define v_WIN0_CSC_MODE(x)		(((x)&3)<<10)
-#define v_WIN0_RB_SWAP(x)		(((x)&1)<<12)
-#define v_WIN0_ALPHA_SWAP(x)		(((x)&1)<<13)
-#define v_WIN0_MID_SWAP(x)		(((x)&1)<<14)
-#define v_WIN0_UV_SWAP(x)		(((x)&1)<<15)
-#define v_WIN0_PPAS_ZERO_EN(x)		(((x)&1)<<16)
-#define v_WIN0_YRGB_DEFLICK(x)		(((x)&1)<<18)
-#define v_WIN0_CBR_DEFLICK(x)		(((x)&1)<<19)
-#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<20)
-
-#define m_WIN0_EN 			(1<<0)
-#define m_WIN0_DATA_FMT 		(7<<1)
-#define m_WIN0_FMT_10 			(1<<4)
-#define m_WIN0_LB_MODE 			(7<<5)
-#define m_WIN0_INTERLACE_READ		(1<<8)
-#define m_WIN0_NO_OUTSTANDING 		(1<<9)
-#define m_WIN0_CSC_MODE 		(3<<10)
-#define m_WIN0_RB_SWAP 			(1<<12)
-#define m_WIN0_ALPHA_SWAP 		(1<<13)
-#define m_WIN0_MID_SWAP 		(1<<14)
-#define m_WIN0_UV_SWAP 			(1<<15)
-#define m_WIN0_PPAS_ZERO_EN     	(1<<16)
-#define m_WIN0_YRGB_DEFLICK 		(1<<18)
-#define m_WIN0_CBR_DEFLICK 		(1<<19)
-#define m_WIN0_YUV_CLIP 		(1<<20)
-
-#define WIN0_CTRL1 			(0x0034)
-#define v_WIN0_YRGB_AXI_GATHER_EN(x)	(((x)&1)<<0)
-#define v_WIN0_CBR_AXI_GATHER_EN(x)	(((x)&1)<<1)
-#define v_WIN0_BIC_COE_SEL(x)           (((x)&3)<<2)
-#define v_WIN0_VSD_YRGB_GT4(x)          (((x)&1)<<4)
-#define v_WIN0_VSD_YRGB_GT2(x)          (((x)&1)<<5)
-#define v_WIN0_VSD_CBR_GT4(x)           (((x)&1)<<6)
-#define v_WIN0_VSD_CBR_GT2(x)           (((x)&1)<<7)
-#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	(((x)&0xf)<<8)
-#define v_WIN0_CBR_AXI_GATHER_NUM(x)	(((x)&7)<<12)
-#define v_WIN0_LINE_LOAD_MODE(x)	(((x)&1)<<15)
-#define v_WIN0_YRGB_HOR_SCL_MODE(x)	(((x)&3)<<16)
-#define v_WIN0_YRGB_VER_SCL_MODE(x)	(((x)&3)<<18)
-#define v_WIN0_YRGB_HSD_MODE(x)		(((x)&3)<<20)
-#define v_WIN0_YRGB_VSU_MODE(x)		(((x)&1)<<22)
-#define v_WIN0_YRGB_VSD_MODE(x)		(((x)&1)<<23)
-#define v_WIN0_CBR_HOR_SCL_MODE(x)	(((x)&3)<<24)
-#define v_WIN0_CBR_VER_SCL_MODE(x)	(((x)&3)<<26)
-#define v_WIN0_CBR_HSD_MODE(x)		(((x)&3)<<28)
-#define v_WIN0_CBR_VSU_MODE(x)		(((x)&1)<<30)
-#define v_WIN0_CBR_VSD_MODE(x)		(((x)&1)<<31)
-
-#define m_WIN0_YRGB_AXI_GATHER_EN   	(1<<0)
-#define m_WIN0_CBR_AXI_GATHER_EN        (1<<1)
-#define m_WIN0_BIC_COE_SEL              (3<<2)
-#define m_WIN0_VSD_YRGB_GT4             (1<<4)
-#define m_WIN0_VSD_YRGB_GT2             (1<<5)
-#define m_WIN0_VSD_CBR_GT4              (1<<6)
-#define m_WIN0_VSD_CBR_GT2              (1<<7)
-#define m_WIN0_YRGB_AXI_GATHER_NUM	(0xf<<8)
-#define m_WIN0_CBR_AXI_GATHER_NUM	(7<<12)
-#define m_WIN0_LINE_LOAD_MODE		(1<<15)
-#define m_WIN0_YRGB_HOR_SCL_MODE	(3<<16)
-#define m_WIN0_YRGB_VER_SCL_MODE	(3<<18)
-#define m_WIN0_YRGB_HSD_MODE		(3<<20)
-#define m_WIN0_YRGB_VSU_MODE		(1<<22)
-#define m_WIN0_YRGB_VSD_MODE		(1<<23)
-#define m_WIN0_CBR_HOR_SCL_MODE		(3<<24)
-#define m_WIN0_CBR_VER_SCL_MODE		(3<<26)
-#define m_WIN0_CBR_HSD_MODE		(3<<28)
-#define m_WIN0_CBR_VSU_MODE		((u32)1<<30)
-#define m_WIN0_CBR_VSD_MODE		((u32)1<<31)
-
-#define WIN0_COLOR_KEY			(0x0038)
-#define v_WIN0_COLOR_KEY(x)		(((x)&0x3fffffff)<<0)
-#define v_WIN0_COLOR_KEY_EN(x)		(((x)&1)<<31)
-#define m_WIN0_COLOR_KEY		(0x3fffffff<<0)
-#define m_WIN0_COLOR_KEY_EN		((u32)1<<31)
-
-#define WIN0_VIR 			(0x003c)
-#define v_WIN0_VIR_STRIDE(x)		(((x)&0x3fff)<<0)
-#define v_WIN0_VIR_STRIDE_UV(x)		(((x)&0x3fff)<<16)
-#define m_WIN0_VIR_STRIDE		(0x3fff<<0)
-#define m_WIN0_VIR_STRIDE_UV    	(0x3fff<<16)
-
-#define WIN0_YRGB_MST 			(0x0040)
-#define WIN0_CBR_MST 	        	(0x0044)
-#define WIN0_ACT_INFO 			(0x0048)
-#define v_WIN0_ACT_WIDTH(x)		(((x-1)&0x1fff)<<0)
-#define v_WIN0_ACT_HEIGHT(x)		(((x-1)&0x1fff)<<16)
-#define m_WIN0_ACT_WIDTH 		(0x1fff<<0)
-#define m_WIN0_ACT_HEIGHT 		(0x1fff<<16)
-
-#define WIN0_DSP_INFO 			(0x004c)
-#define v_WIN0_DSP_WIDTH(x)		(((x-1)&0xfff)<<0)
-#define v_WIN0_DSP_HEIGHT(x)		(((x-1)&0xfff)<<16)
-#define m_WIN0_DSP_WIDTH 		(0xfff<<0)
-#define m_WIN0_DSP_HEIGHT 		(0xfff<<16)
-
-#define WIN0_DSP_ST 			(0x0050)
-#define v_WIN0_DSP_XST(x)		(((x)&0x1fff)<<0)
-#define v_WIN0_DSP_YST(x)		(((x)&0x1fff)<<16)
-#define m_WIN0_DSP_XST 			(0x1fff<<0)
-#define m_WIN0_DSP_YST 			(0x1fff<<16)
-
-#define WIN0_SCL_FACTOR_YRGB 		(0x0054)
-#define v_WIN0_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
-#define v_WIN0_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
-#define m_WIN0_HS_FACTOR_YRGB		(0xffff<<0)
-#define m_WIN0_VS_FACTOR_YRGB		((u32)0xffff<<16)
-
-#define WIN0_SCL_FACTOR_CBR 		(0x0058)
-#define v_WIN0_HS_FACTOR_CBR(x)		(((x)&0xffff)<<0)
-#define v_WIN0_VS_FACTOR_CBR(x)		(((x)&0xffff)<<16)
-#define m_WIN0_HS_FACTOR_CBR		(0xffff<<0)
-#define m_WIN0_VS_FACTOR_CBR		((u32)0xffff<<16)
-
-#define WIN0_SCL_OFFSET 		(0x005c)
-#define v_WIN0_HS_OFFSET_YRGB(x)	(((x)&0xff)<<0)
-#define v_WIN0_HS_OFFSET_CBR(x)		(((x)&0xff)<<8)
-#define v_WIN0_VS_OFFSET_YRGB(x)	(((x)&0xff)<<16)
-#define v_WIN0_VS_OFFSET_CBR(x)		(((x)&0xff)<<24)
-
-#define m_WIN0_HS_OFFSET_YRGB		(0xff<<0)
-#define m_WIN0_HS_OFFSET_CBR		(0xff<<8)
-#define m_WIN0_VS_OFFSET_YRGB		(0xff<<16)
-#define m_WIN0_VS_OFFSET_CBR		((u32)0xff<<24)
-
-#define WIN0_SRC_ALPHA_CTRL 		(0x0060)
-#define v_WIN0_SRC_ALPHA_EN(x)		(((x)&1)<<0)
-#define v_WIN0_SRC_COLOR_M0(x)		(((x)&1)<<1)
-#define v_WIN0_SRC_ALPHA_M0(x)		(((x)&1)<<2)
-#define v_WIN0_SRC_BLEND_M0(x)		(((x)&3)<<3)
-#define v_WIN0_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
-#define v_WIN0_SRC_FACTOR_M0(x)		(((x)&7)<<6)
-#define v_WIN0_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
-#define v_WIN0_FADING_VALUE(x)          (((x)&0xff)<<24)
-
-#define m_WIN0_SRC_ALPHA_EN 		(1<<0)
-#define m_WIN0_SRC_COLOR_M0 		(1<<1)
-#define m_WIN0_SRC_ALPHA_M0 		(1<<2)
-#define m_WIN0_SRC_BLEND_M0		(3<<3)
-#define m_WIN0_SRC_ALPHA_CAL_M0		(1<<5)
-#define m_WIN0_SRC_FACTOR_M0		(7<<6)
-#define m_WIN0_SRC_GLOBAL_ALPHA		(0xff<<16)
-#define m_WIN0_FADING_VALUE		(0xff<<24)
-
-#define WIN0_DST_ALPHA_CTRL 		(0x0064)
-#define v_WIN0_DST_FACTOR_M0(x)		(((x)&7)<<6)
-#define m_WIN0_DST_FACTOR_M0		(7<<6)
- 
-#define WIN0_FADING_CTRL 		(0x0068)
-#define v_WIN0_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
-#define v_WIN0_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
-#define v_WIN0_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
-#define v_WIN0_FADING_EN(x)		(((x)&1)<<24)
-
-#define m_WIN0_FADING_OFFSET_R 		(0xff<<0)
-#define m_WIN0_FADING_OFFSET_G 		(0xff<<8)
-#define m_WIN0_FADING_OFFSET_B 		(0xff<<16)
-#define m_WIN0_FADING_EN		(1<<24)
-
-/*win1 register*/
-#define WIN1_CTRL0 			(0x0070)
-#define v_WIN1_EN(x)			(((x)&1)<<0)
-#define v_WIN1_DATA_FMT(x)		(((x)&7)<<1)
-#define v_WIN1_FMT_10(x)		(((x)&1)<<4)
-#define v_WIN1_LB_MODE(x)		(((x)&7)<<5)
-#define v_WIN1_INTERLACE_READ_MODE(x)	(((x)&1)<<8)
-#define v_WIN1_NO_OUTSTANDING(x)	(((x)&1)<<9)
-#define v_WIN1_CSC_MODE(x)		(((x)&3)<<10)
-#define v_WIN1_RB_SWAP(x)		(((x)&1)<<12)
-#define v_WIN1_ALPHA_SWAP(x)		(((x)&1)<<13)
-#define v_WIN1_MID_SWAP(x)		(((x)&1)<<14)
-#define v_WIN1_UV_SWAP(x)		(((x)&1)<<15)
-#define v_WIN1_PPAS_ZERO_EN(x)		(((x)&1)<<16)
-#define v_WIN1_YRGB_DEFLICK(x)		(((x)&1)<<18)
-#define v_WIN1_CBR_DEFLICK(x)		(((x)&1)<<19)
-#define v_WIN1_YUV_CLIP(x)		(((x)&1)<<20)
-
-#define m_WIN1_EN			(1<<0)
-#define m_WIN1_DATA_FMT			(7<<1)
-#define m_WIN1_FMT_10			(1<<4)
-#define m_WIN1_LB_MODE			(7<<5)
-#define m_WIN1_INTERLACE_READ_MODE 	(1<<8)
-#define m_WIN1_NO_OUTSTANDING 		(1<<9)
-#define m_WIN1_CSC_MODE 		(3<<10)
-#define m_WIN1_RB_SWAP 			(1<<12)
-#define m_WIN1_ALPHA_SWAP 		(1<<13)
-#define m_WIN1_MID_SWAP 		(1<<14)
-#define m_WIN1_UV_SWAP 			(1<<15)
-#define m_WIN1_PPAS_ZERO_EN             (1<<16)
-#define m_WIN1_YRGB_DEFLICK 		(1<<18)
-#define m_WIN1_CBR_DEFLICK 		(1<<19)
-#define m_WIN1_YUV_CLIP 		(1<<20)
-
-#define WIN1_CTRL1 			(0x0074)
-#define v_WIN1_YRGB_AXI_GATHER_EN(x)	(((x)&1)<<0)
-#define v_WIN1_CBR_AXI_GATHER_EN(x)	(((x)&1)<<1)
-#define v_WIN1_BIC_COE_SEL(x)           (((x)&3)<<2)
-#define v_WIN1_VSD_YRGB_GT4(x)          (((x)&1)<<4)
-#define v_WIN1_VSD_YRGB_GT2(x)          (((x)&1)<<5)
-#define v_WIN1_VSD_CBR_GT4(x)           (((x)&1)<<6)
-#define v_WIN1_VSD_CBR_GT2(x)           (((x)&1)<<7)
-#define v_WIN1_YRGB_AXI_GATHER_NUM(x)	(((x)&0xf)<<8)
-#define v_WIN1_CBR_AXI_GATHER_NUM(x)	(((x)&7)<<12)
-#define v_WIN1_LINE_LOAD_MODE(x)	(((x)&1)<<15)
-#define v_WIN1_YRGB_HOR_SCL_MODE(x)	(((x)&3)<<16)
-#define v_WIN1_YRGB_VER_SCL_MODE(x)	(((x)&3)<<18)
-#define v_WIN1_YRGB_HSD_MODE(x)		(((x)&3)<<20)
-#define v_WIN1_YRGB_VSU_MODE(x)		(((x)&1)<<22)
-#define v_WIN1_YRGB_VSD_MODE(x)		(((x)&1)<<23)
-#define v_WIN1_CBR_HOR_SCL_MODE(x)	(((x)&3)<<24)
-#define v_WIN1_CBR_VER_SCL_MODE(x)	(((x)&3)<<26)
-#define v_WIN1_CBR_HSD_MODE(x)		(((x)&3)<<28)
-#define v_WIN1_CBR_VSU_MODE(x)		(((x)&1)<<30)
-#define v_WIN1_CBR_VSD_MODE(x)		(((x)&1)<<31)
-
-#define m_WIN1_YRGB_AXI_GATHER_EN	(1<<0)
-#define m_WIN1_CBR_AXI_GATHER_EN	(1<<1)
-#define m_WIN1_BIC_COE_SEL              (3<<2)
-#define m_WIN1_VSD_YRGB_GT4             (1<<4)
-#define m_WIN1_VSD_YRGB_GT2             (1<<5)
-#define m_WIN1_VSD_CBR_GT4              (1<<6)
-#define m_WIN1_VSD_CBR_GT2              (1<<7)
-#define m_WIN1_YRGB_AXI_GATHER_NUM	(0xf<<8)
-#define m_WIN1_CBR_AXI_GATHER_NUM	(7<<12)
-#define m_WIN1_LINE_LOAD_MODE		(1<<15)
-#define m_WIN1_YRGB_HOR_SCL_MODE	(3<<16)
-#define m_WIN1_YRGB_VER_SCL_MODE	(3<<18)
-#define m_WIN1_YRGB_HSD_MODE		(3<<20)
-#define m_WIN1_YRGB_VSU_MODE		(1<<22)
-#define m_WIN1_YRGB_VSD_MODE		(1<<23)
-#define m_WIN1_CBR_HOR_SCL_MODE		(3<<24)
-#define m_WIN1_CBR_VER_SCL_MODE		(3<<26)
-#define m_WIN1_CBR_HSD_MODE		(3<<28)
-#define m_WIN1_CBR_VSU_MODE		(1<<30)
-#define m_WIN1_CBR_VSD_MODE		((u32)1<<31)
-
-#define WIN1_COLOR_KEY 			(0x0078)
-#define v_WIN1_COLOR_KEY(x)		(((x)&0x3fffffff)<<0)
-#define v_WIN1_COLOR_KEY_EN(x)		(((x)&1)<<31)
-#define m_WIN1_COLOR_KEY		(0x3fffffff<<0)
-#define m_WIN1_COLOR_KEY_EN		((u32)1<<31)
-
-#define WIN1_VIR 			(0x007c)
-#define v_WIN1_VIR_STRIDE(x)		(((x)&0x3fff)<<0)
-#define v_WIN1_VIR_STRIDE_UV(x)		(((x)&0x3fff)<<16)
-#define m_WIN1_VIR_STRIDE 		(0x3fff<<0)
-#define m_WIN1_VIR_STRIDE_UV 		(0x3fff<<16)
-
-#define WIN1_YRGB_MST 			(0x0080)
-#define WIN1_CBR_MST 			(0x0084)
-#define WIN1_ACT_INFO 			(0x0088)
-#define v_WIN1_ACT_WIDTH(x)		(((x-1)&0x1fff)<<0)
-#define v_WIN1_ACT_HEIGHT(x)		(((x-1)&0x1fff)<<16)
-#define m_WIN1_ACT_WIDTH		(0x1fff<<0)
-#define m_WIN1_ACT_HEIGHT		(0x1fff<<16)
-
-#define WIN1_DSP_INFO 			(0x008c)
-#define v_WIN1_DSP_WIDTH(x)		(((x-1)&0xfff)<<0)
-#define v_WIN1_DSP_HEIGHT(x)		(((x-1)&0xfff)<<16)
-#define m_WIN1_DSP_WIDTH 		(0xfff<<0)
-#define m_WIN1_DSP_HEIGHT 		(0xfff<<16)
-
-#define WIN1_DSP_ST 			(0x0090)
-#define v_WIN1_DSP_XST(x)		(((x)&0x1fff)<<0)
-#define v_WIN1_DSP_YST(x)		(((x)&0x1fff)<<16)
-#define m_WIN1_DSP_XST 			(0x1fff<<0)
-#define m_WIN1_DSP_YST 			(0x1fff<<16)
-
-#define WIN1_SCL_FACTOR_YRGB 		(0x0094)
-#define v_WIN1_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
-#define v_WIN1_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
-#define m_WIN1_HS_FACTOR_YRGB 		(0xffff<<0)
-#define m_WIN1_VS_FACTOR_YRGB 		((u32)0xffff<<16)
-
-#define WIN1_SCL_FACTOR_CBR 		(0x0098)
-#define v_WIN1_HS_FACTOR_CBR(x)		(((x)&0xffff)<<0)
-#define v_WIN1_VS_FACTOR_CBR(x)		(((x)&0xffff)<<16)
-#define m_WIN1_HS_FACTOR_CBR		(0xffff<<0)
-#define m_WIN1_VS_FACTOR_CBR		((u32)0xffff<<16)
-
-#define WIN1_SCL_OFFSET 		(0x009c)
-#define v_WIN1_HS_OFFSET_YRGB(x)	(((x)&0xff)<<0)
-#define v_WIN1_HS_OFFSET_CBR(x)		(((x)&0xff)<<8)
-#define v_WIN1_VS_OFFSET_YRGB(x)	(((x)&0xff)<<16)
-#define v_WIN1_VS_OFFSET_CBR(x)		(((x)&0xff)<<24)
-
-#define m_WIN1_HS_OFFSET_YRGB		(0xff<<0)
-#define m_WIN1_HS_OFFSET_CBR		(0xff<<8)
-#define m_WIN1_VS_OFFSET_YRGB		(0xff<<16)
-#define m_WIN1_VS_OFFSET_CBR		((u32)0xff<<24)
-
-#define WIN1_SRC_ALPHA_CTRL 		(0x00a0)
-#define v_WIN1_SRC_ALPHA_EN(x)		(((x)&1)<<0)
-#define v_WIN1_SRC_COLOR_M0(x)		(((x)&1)<<1)
-#define v_WIN1_SRC_ALPHA_M0(x)		(((x)&1)<<2)
-#define v_WIN1_SRC_BLEND_M0(x)		(((x)&3)<<3)
-#define v_WIN1_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
-#define v_WIN1_SRC_FACTOR_M0(x)		(((x)&7)<<6)
-#define v_WIN1_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
-#define v_WIN1_FADING_VALUE(x)          (((x)&0xff)<<24)
-
-#define m_WIN1_SRC_ALPHA_EN 		(1<<0)
-#define m_WIN1_SRC_COLOR_M0 		(1<<1)
-#define m_WIN1_SRC_ALPHA_M0 		(1<<2)
-#define m_WIN1_SRC_BLEND_M0		(3<<3)
-#define m_WIN1_SRC_ALPHA_CAL_M0		(1<<5)
-#define m_WIN1_SRC_FACTOR_M0		(7<<6)
-#define m_WIN1_SRC_GLOBAL_ALPHA		(0xff<<16)
-#define m_WIN1_FADING_VALUE		(0xff<<24)
-
-#define WIN1_DST_ALPHA_CTRL 		(0x00a4)
-#define v_WIN1_DST_FACTOR_M0(x)		(((x)&7)<<6)
-#define m_WIN1_DST_FACTOR_M0		(7<<6)
-
-#define WIN1_FADING_CTRL 		(0x00a8)
-#define v_WIN1_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
-#define v_WIN1_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
-#define v_WIN1_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
-#define v_WIN1_FADING_EN(x)		(((x)&1)<<24)
-
-#define m_WIN1_FADING_OFFSET_R 		(0xff<<0)
-#define m_WIN1_FADING_OFFSET_G 		(0xff<<8)
-#define m_WIN1_FADING_OFFSET_B 		(0xff<<16)
-#define m_WIN1_FADING_EN		(1<<24)
-
-/*win2 register*/
-#define WIN2_CTRL0 			(0x00b0)
-#define v_WIN2_EN(x)			(((x)&1)<<0)
-#define v_WIN2_DATA_FMT(x)		(((x)&7)<<1)
-#define v_WIN2_MST0_EN(x)		(((x)&1)<<4)
-#define v_WIN2_MST1_EN(x)		(((x)&1)<<5)
-#define v_WIN2_MST2_EN(x)		(((x)&1)<<6)
-#define v_WIN2_MST3_EN(x)		(((x)&1)<<7)
-#define v_WIN2_INTERLACE_READ(x)	(((x)&1)<<8)
-#define v_WIN2_NO_OUTSTANDING(x)	(((x)&1)<<9)
-#define v_WIN2_CSC_MODE(x)		(((x)&1)<<10)
-#define v_WIN2_RB_SWAP(x)		(((x)&1)<<12)
-#define v_WIN2_ALPHA_SWAP(x)		(((x)&1)<<13)
-#define v_WIN2_ENDIAN_MODE(x)		(((x)&1)<<14)
-#define v_WIN2_LUT_EN(x)		(((x)&1)<<18)
-
-#define m_WIN2_EN 			(1<<0)
-#define m_WIN2_DATA_FMT 		(7<<1)
-#define m_WIN2_MST0_EN 			(1<<4)
-#define m_WIN2_MST1_EN 			(1<<5)
-#define m_WIN2_MST2_EN 			(1<<6)
-#define m_WIN2_MST3_EN 			(1<<7)
-#define m_WIN2_INTERLACE_READ 		(1<<8)
-#define m_WIN2_NO_OUTSTANDING 		(1<<9)
-#define m_WIN2_CSC_MODE 		(1<<10)
-#define m_WIN2_RB_SWAP 			(1<<12)
-#define m_WIN2_ALPHA_SWAP 		(1<<13)
-#define m_WIN2_ENDIAN_MODE 		(1<<14)
-#define m_WIN2_LUT_EN 			(1<<18)
-
-#define WIN2_CTRL1 			(0x00b4)
-#define v_WIN2_AXI_GATHER_EN(x)		(((x)&1)<<0)
-#define v_WIN2_AXI_GATHER_NUM(x)	(((x)&0xf)<<4)
-#define m_WIN2_AXI_GATHER_EN		(1<<0)
-#define m_WIN2_AXI_GATHER_NUM		(0xf<<4)
-
-#define WIN2_VIR0_1 			(0x00b8)
-#define v_WIN2_VIR_STRIDE0(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_VIR_STRIDE1(x)		(((x)&0x1fff)<<16)
-#define m_WIN2_VIR_STRIDE0		(0x1fff<<0)
-#define m_WIN2_VIR_STRIDE1		(0x1fff<<16)
-
-#define WIN2_VIR2_3 			(0x00bc)
-#define v_WIN2_VIR_STRIDE2(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_VIR_STRIDE3(x)		(((x)&0x1fff)<<16)
-#define m_WIN2_VIR_STRIDE2		(0x1fff<<0)
-#define m_WIN2_VIR_STRIDE3		(0x1fff<<16)
-
-#define WIN2_MST0 			(0x00c0)
-#define WIN2_DSP_INFO0 			(0x00c4)
-#define v_WIN2_DSP_WIDTH0(x)		(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT0(x)		(((x-1)&0xfff)<<16)
-#define m_WIN2_DSP_WIDTH0		(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT0		(0xfff<<16)
-
-#define WIN2_DSP_ST0 			(0x00c8)
-#define v_WIN2_DSP_XST0(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST0(x)		(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST0			(0x1fff<<0)
-#define m_WIN2_DSP_YST0			(0x1fff<<16)
-
-#define WIN2_COLOR_KEY 			(0x00cc)
-#define v_WIN2_COLOR_KEY(x)		(((x)&0xffffff)<<0)
-#define v_WIN2_KEY_EN(x)		(((x)&1)<<24)
-#define m_WIN2_COLOR_KEY		(0xffffff<<0)
-#define m_WIN2_KEY_EN			((u32)1<<24)
-
-
-#define WIN2_MST1               	(0x00d0) 
-#define WIN2_DSP_INFO1 			(0x00d4)
-#define v_WIN2_DSP_WIDTH1(x)		(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT1(x)		(((x-1)&0xfff)<<16)
-
-#define m_WIN2_DSP_WIDTH1		(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT1		(0xfff<<16)
-
-#define WIN2_DSP_ST1 	        	(0x00d8)
-#define v_WIN2_DSP_XST1(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST1(x)		(((x)&0x1fff)<<16)
-
-#define m_WIN2_DSP_XST1			(0x1fff<<0)
-#define m_WIN2_DSP_YST1			(0x1fff<<16)
-
-#define WIN2_SRC_ALPHA_CTRL 		(0x00dc)
-#define v_WIN2_SRC_ALPHA_EN(x)		(((x)&1)<<0)
-#define v_WIN2_SRC_COLOR_M0(x)		(((x)&1)<<1)
-#define v_WIN2_SRC_ALPHA_M0(x)		(((x)&1)<<2)
-#define v_WIN2_SRC_BLEND_M0(x)		(((x)&3)<<3)
-#define v_WIN2_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
-#define v_WIN2_SRC_FACTOR_M0(x)		(((x)&7)<<6)
-#define v_WIN2_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
-#define v_WIN2_FADING_VALUE(x)          (((x)&0xff)<<24)
-
-
-#define m_WIN2_SRC_ALPHA_EN 		(1<<0)
-#define m_WIN2_SRC_COLOR_M0 		(1<<1)
-#define m_WIN2_SRC_ALPHA_M0 		(1<<2)
-#define m_WIN2_SRC_BLEND_M0		(3<<3)
-#define m_WIN2_SRC_ALPHA_CAL_M0		(1<<5)
-#define m_WIN2_SRC_FACTOR_M0		(7<<6)
-#define m_WIN2_SRC_GLOBAL_ALPHA		(0xff<<16)
-#define m_WIN2_FADING_VALUE		(0xff<<24)
-
-#define WIN2_MST2 			(0x00e0)
-#define WIN2_DSP_INFO2 			(0x00e4)
-#define v_WIN2_DSP_WIDTH2(x)		(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT2(x)		(((x-1)&0xfff)<<16)
-
-#define m_WIN2_DSP_WIDTH2 		(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT2 		(0xfff<<16)
-
-
-#define WIN2_DSP_ST2 			(0x00e8)
-#define v_WIN2_DSP_XST2(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST2(x)		(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST2 		(0x1fff<<0)
-#define m_WIN2_DSP_YST2 		(0x1fff<<16)
-
-#define WIN2_DST_ALPHA_CTRL 		(0x00ec)
-#define v_WIN2_DST_FACTOR_M0(x)		(((x)&7)<<6)
-#define m_WIN2_DST_FACTOR_M0		(7<<6)
-
-#define WIN2_MST3 			(0x00f0)
-#define WIN2_DSP_INFO3 			(0x00f4)
-#define v_WIN2_DSP_WIDTH3(x)		(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT3(x)		(((x-1)&0xfff)<<16)
-#define m_WIN2_DSP_WIDTH3		(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT3		(0xfff<<16)
-
-#define WIN2_DSP_ST3 			(0x00f8)
-#define v_WIN2_DSP_XST3(x)		(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST3(x)		(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST3 		(0x1fff<<0)
-#define m_WIN2_DSP_YST3 		(0x1fff<<16)
-
-#define WIN2_FADING_CTRL 		(0x00fc)
-#define v_WIN2_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
-#define v_WIN2_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
-#define v_WIN2_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
-#define v_WIN2_FADING_EN(x)		(((x)&1)<<24)
-
-#define m_WIN2_FADING_OFFSET_R 		(0xff<<0)
-#define m_WIN2_FADING_OFFSET_G 		(0xff<<8)
-#define m_WIN2_FADING_OFFSET_B 		(0xff<<16)
-#define m_WIN2_FADING_EN		(1<<24)
-
-/*win3 register*/
-#define WIN3_CTRL0 			(0x0100)
-#define v_WIN3_EN(x)			(((x)&1)<<0)
-#define v_WIN3_DATA_FMT(x)		(((x)&7)<<1)
-#define v_WIN3_MST0_EN(x)		(((x)&1)<<4)
-#define v_WIN3_MST1_EN(x)		(((x)&1)<<5)
-#define v_WIN3_MST2_EN(x)		(((x)&1)<<6)
-#define v_WIN3_MST3_EN(x)		(((x)&1)<<7)
-#define v_WIN3_INTERLACE_READ(x)	(((x)&1)<<8)
-#define v_WIN3_NO_OUTSTANDING(x)	(((x)&1)<<9)
-#define v_WIN3_CSC_MODE(x)		(((x)&1)<<10)
-#define v_WIN3_RB_SWAP(x)		(((x)&1)<<12)
-#define v_WIN3_ALPHA_SWAP(x)		(((x)&1)<<13)
-#define v_WIN3_ENDIAN_MODE(x)		(((x)&1)<<14)
-#define v_WIN3_LUT_EN(x)		(((x)&1)<<18)
-
-#define m_WIN3_EN 			(1<<0)
-#define m_WIN3_DATA_FMT 		(7<<1)
-#define m_WIN3_MST0_EN 			(1<<4)
-#define m_WIN3_MST1_EN 			(1<<5)
-#define m_WIN3_MST2_EN 			(1<<6)
-#define m_WIN3_MST3_EN 			(1<<7)
-#define m_WIN3_INTERLACE_READ 		(1<<8)
-#define m_WIN3_NO_OUTSTANDING 		(1<<9)
-#define m_WIN3_CSC_MODE 		(1<<10)
-#define m_WIN3_RB_SWAP 			(1<<12)
-#define m_WIN3_ALPHA_SWAP 		(1<<13)
-#define m_WIN3_ENDIAN_MODE 		(1<<14)
-#define m_WIN3_LUT_EN 			(1<<18)
-
-
-#define WIN3_CTRL1 			(0x0104)
-#define v_WIN3_AXI_GATHER_EN(x)		(((x)&1)<<0)
-#define v_WIN3_AXI_GATHER_NUM(x)	(((x)&0xf)<<4)
-#define m_WIN3_AXI_GATHER_EN 		(1<<0)
-#define m_WIN3_AXI_GATHER_NUM 		(0xf<<4)
-
-#define WIN3_VIR0_1 			(0x0108)
-#define v_WIN3_VIR_STRIDE0(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_VIR_STRIDE1(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_VIR_STRIDE0 		(0x1fff<<0)
-#define m_WIN3_VIR_STRIDE1 		(0x1fff<<16)
-
-#define WIN3_VIR2_3 			(0x010c)
-#define v_WIN3_VIR_STRIDE2(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_VIR_STRIDE3(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_VIR_STRIDE2		(0x1fff<<0)
-#define m_WIN3_VIR_STRIDE3		(0x1fff<<16)
-
-#define WIN3_MST0 	        	(0x0110)
-#define WIN3_DSP_INFO0 			(0x0114)
-#define v_WIN3_DSP_WIDTH0(x)		(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT0(x)		(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH0 		(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT0 		(0xfff<<16)
-
-#define WIN3_DSP_ST0 			(0x0118)
-#define v_WIN3_DSP_XST0(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST0(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST0			(0x1fff<<0)
-#define m_WIN3_DSP_YST0			(0x1fff<<16)
-
-#define WIN3_COLOR_KEY 			(0x011c)
-#define v_WIN3_COLOR_KEY(x)		(((x)&0xffffff)<<0)
-#define v_WIN3_KEY_EN(x)		(((x)&1)<<24)
-#define m_WIN3_COLOR_KEY		(0xffffff<<0)
-#define m_WIN3_KEY_EN			((u32)1<<24)
-
-#define WIN3_MST1 			(0x0120)
-#define WIN3_DSP_INFO1 			(0x0124)
-#define v_WIN3_DSP_WIDTH1(x)		(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT1(x)		(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH1 		(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT1 		(0xfff<<16)
-
-#define WIN3_DSP_ST1 			(0x0128)
-#define v_WIN3_DSP_XST1(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST1(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST1			(0x1fff<<0)
-#define m_WIN3_DSP_YST1			(0x1fff<<16)
-
-#define WIN3_SRC_ALPHA_CTRL 		(0x012c)
-#define v_WIN3_SRC_ALPHA_EN(x)		(((x)&1)<<0)
-#define v_WIN3_SRC_COLOR_M0(x)		(((x)&1)<<1)
-#define v_WIN3_SRC_ALPHA_M0(x)		(((x)&1)<<2)
-#define v_WIN3_SRC_BLEND_M0(x)		(((x)&3)<<3)
-#define v_WIN3_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
-#define v_WIN3_SRC_FACTOR_M0(x)		(((x)&7)<<6)
-#define v_WIN3_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
-#define v_WIN3_FADING_VALUE(x)          (((x)&0xff)<<24)
-
-#define m_WIN3_SRC_ALPHA_EN 		(1<<0)
-#define m_WIN3_SRC_COLOR_M0 		(1<<1)
-#define m_WIN3_SRC_ALPHA_M0 		(1<<2)
-#define m_WIN3_SRC_BLEND_M0		(3<<3)
-#define m_WIN3_SRC_ALPHA_CAL_M0		(1<<5)
-#define m_WIN3_SRC_FACTOR_M0		(7<<6)
-#define m_WIN3_SRC_GLOBAL_ALPHA		(0xff<<16)
-#define m_WIN3_FADING_VALUE		(0xff<<24)
-
-#define WIN3_MST2 			(0x0130)
-#define WIN3_DSP_INFO2 			(0x0134)
-#define v_WIN3_DSP_WIDTH2(x)		(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT2(x)		(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH2		(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT2		(0xfff<<16)
-
-#define WIN3_DSP_ST2 			(0x0138)
-#define v_WIN3_DSP_XST2(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST2(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST2			(0x1fff<<0)
-#define m_WIN3_DSP_YST2			(0x1fff<<16)
-
-#define WIN3_DST_ALPHA_CTRL 		(0x013c)
-#define v_WIN3_DST_FACTOR_M0(x)		(((x)&7)<<6)
-#define m_WIN3_DST_FACTOR_M0		(7<<6)
-
-
-#define WIN3_MST3 			(0x0140)
-#define WIN3_DSP_INFO3 			(0x0144)
-#define v_WIN3_DSP_WIDTH3(x)		(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT3(x)		(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH3		(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT3		(0xfff<<16)
-
-#define WIN3_DSP_ST3 			(0x0148)
-#define v_WIN3_DSP_XST3(x)		(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST3(x)		(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST3			(0x1fff<<0)
-#define m_WIN3_DSP_YST3			(0x1fff<<16)
-
-#define WIN3_FADING_CTRL 		(0x014c)
-#define v_WIN3_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
-#define v_WIN3_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
-#define v_WIN3_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
-#define v_WIN3_FADING_EN(x)		(((x)&1)<<24)
-
-#define m_WIN3_FADING_OFFSET_R 		(0xff<<0)
-#define m_WIN3_FADING_OFFSET_G 		(0xff<<8)
-#define m_WIN3_FADING_OFFSET_B 		(0xff<<16)
-#define m_WIN3_FADING_EN		(1<<24)
-
-
-/*hwc register*/
-#define HWC_CTRL0 			(0x0150)
-#define v_HWC_EN(x)			(((x)&1)<<0)
-#define v_HWC_DATA_FMT(x)		(((x)&7)<<1)
-#define v_HWC_MODE(x)			(((x)&1)<<4)
-#define v_HWC_SIZE(x)			(((x)&3)<<5)
-#define v_HWC_INTERLACE_READ(x)		(((x)&1)<<8)
-#define v_HWC_NO_OUTSTANDING(x)		(((x)&1)<<9)
-#define v_HWC_CSC_MODE(x)		(((x)&1)<<10)
-#define v_HWC_RB_SWAP(x)		(((x)&1)<<12)
-#define v_HWC_ALPHA_SWAP(x)		(((x)&1)<<13)
-#define v_HWC_ENDIAN_MODE(x)		(((x)&1)<<14)
-#define v_HWC_LUT_EN(x)			(((x)&1)<<18)
-
-#define m_HWC_EN			(1<<0)
-#define m_HWC_DATA_FMT			(7<<1)
-#define m_HWC_MODE			(1<<4)
-#define m_HWC_SIZE			(3<<5)
-#define m_HWC_INTERLACE_READ 		(1<<8)
-#define m_HWC_NO_OUTSTANDING		(1<<9)
-#define m_HWC_CSC_MODE			(1<<10)
-#define m_HWC_RB_SWAP			(1<<12)
-#define m_HWC_ALPHA_SWAP		(1<<13)
-#define m_HWC_ENDIAN_MODE		(1<<14)
-#define m_HWC_LUT_EN			(1<<18)
-
-
-#define HWC_CTRL1 			(0x0154)
-#define v_HWC_AXI_GATHER_EN(x)		(((x)&1)<<0)
-#define v_HWC_AXI_GATHER_NUM(x)		(((x)&7)<<4)
-#define m_HWC_AXI_GATHER_EN		(1<<0)
-#define m_HWC_AXI_GATHER_NUM		(7<<4)
-
-#define HWC_MST 			(0x0158)
-#define HWC_DSP_ST 			(0x015c)
-#define v_HWC_DSP_XST(x)		(((x)&0x1fff)<<0)
-#define v_HWC_DSP_YST(x)		(((x)&0x1fff)<<16)
-#define m_HWC_DSP_XST			(0x1fff<<0)
-#define m_HWC_DSP_YST			(0x1fff<<16)
-
-#define HWC_SRC_ALPHA_CTRL		(0x0160)
-#define v_HWC_SRC_ALPHA_EN(x)		(((x)&1)<<0)
-#define v_HWC_SRC_COLOR_M0(x)		(((x)&1)<<1)
-#define v_HWC_SRC_ALPHA_M0(x)		(((x)&1)<<2)
-#define v_HWC_SRC_BLEND_M0(x)		(((x)&3)<<3)
-#define v_HWC_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
-#define v_HWC_SRC_FACTOR_M0(x)		(((x)&7)<<6)
-#define v_HWC_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
-#define v_HWC_FADING_VALUE(x)           (((x)&0xff)<<24)
-
-#define m_HWC_SRC_ALPHA_EN 		(1<<0)
-#define m_HWC_SRC_COLOR_M0 		(1<<1)
-#define m_HWC_SRC_ALPHA_M0 		(1<<2)
-#define m_HWC_SRC_BLEND_M0		(3<<3)
-#define m_HWC_SRC_ALPHA_CAL_M0		(1<<5)
-#define m_HWC_SRC_FACTOR_M0		(7<<6)
-#define m_HWC_SRC_GLOBAL_ALPHA		(0xff<<16)
-#define m_HWC_FADING_VALUE		(0xff<<24)
-
-#define HWC_DST_ALPHA_CTRL 		(0x0164)
-#define v_HWC_DST_FACTOR_M0(x)		(((x)&7)<<6)
-#define m_HWC_DST_FACTOR_M0		(7<<6)
-
-
-#define HWC_FADING_CTRL 		(0x0168)
-#define v_HWC_FADING_OFFSET_R(x)        (((x)&0xff)<<0)
-#define v_HWC_FADING_OFFSET_G(x)        (((x)&0xff)<<8)
-#define v_HWC_FADING_OFFSET_B(x)        (((x)&0xff)<<16)
-#define v_HWC_FADING_EN(x)	        (((x)&1)<<24)
-
-#define m_HWC_FADING_OFFSET_R 	        (0xff<<0)
-#define m_HWC_FADING_OFFSET_G 	        (0xff<<8)
-#define m_HWC_FADING_OFFSET_B 	        (0xff<<16)
-#define m_HWC_FADING_EN                 (1<<24)
-
-/*post process register*/
-#define POST_DSP_HACT_INFO 		(0x0170)
-#define v_DSP_HACT_END_POST(x)		(((x)&0x1fff)<<0)
-#define v_DSP_HACT_ST_POST(x)		(((x)&0x1fff)<<16)
-#define m_DSP_HACT_END_POST		(0x1fff<<0)
-#define m_DSP_HACT_ST_POST		(0x1fff<<16)
-
-#define POST_DSP_VACT_INFO 		(0x0174)
-#define v_DSP_VACT_END_POST(x)		(((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST_POST(x)		(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END_POST		(0x1fff<<0)
-#define m_DSP_VACT_ST_POST		(0x1fff<<16)
-
-#define POST_SCL_FACTOR_YRGB 		(0x0178)
-#define v_POST_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
-#define v_POST_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
-#define m_POST_HS_FACTOR_YRGB		(0xffff<<0)
-#define m_POST_VS_FACTOR_YRGB		(0xffff<<16)
-
-#define POST_SCL_CTRL 			(0x0180)
-#define v_POST_HOR_SD_EN(x)		(((x)&1)<<0)
-#define v_POST_VER_SD_EN(x)		(((x)&1)<<1)
-
-#define m_POST_HOR_SD_EN		(0x1<<0)
-#define m_POST_VER_SD_EN		(0x1<<1)
-
-#define POST_DSP_VACT_INFO_F1 		(0x0184)
-#define v_DSP_VACT_END_POST_F1(x)       (((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST_POST_F1(x)        (((x)&0x1fff)<<16)
-
-#define m_DSP_VACT_END_POST_F1          (0x1fff<<0)
-#define m_DSP_VACT_ST_POST_F1           (0x1fff<<16)
-
-#define DSP_HTOTAL_HS_END 		(0x0188)
-#define v_DSP_HS_PW(x)			(((x)&0x1fff)<<0)
-#define v_DSP_HTOTAL(x)			(((x)&0x1fff)<<16)
-#define m_DSP_HS_PW			(0x1fff<<0)
-#define m_DSP_HTOTAL			(0x1fff<<16)
-
-#define DSP_HACT_ST_END 		(0x018c)
-#define v_DSP_HACT_END(x)		(((x)&0x1fff)<<0)
-#define v_DSP_HACT_ST(x)		(((x)&0x1fff)<<16)
-#define m_DSP_HACT_END			(0x1fff<<0)
-#define m_DSP_HACT_ST			(0x1fff<<16)
-
-#define DSP_VTOTAL_VS_END 		(0x0190)
-#define v_DSP_VS_PW(x)			(((x)&0x1fff)<<0)
-#define v_DSP_VTOTAL(x)			(((x)&0x1fff)<<16)
-#define m_DSP_VS_PW			(0x1fff<<0)
-#define m_DSP_VTOTAL			(0x1fff<<16)
-
-#define DSP_VACT_ST_END 		(0x0194)
-#define v_DSP_VACT_END(x)		(((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST(x)		(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END			(0x1fff<<0)
-#define m_DSP_VACT_ST			(0x1fff<<16)
-
-#define DSP_VS_ST_END_F1 		(0x0198)
-#define v_DSP_VS_END_F1(x)		(((x)&0x1fff)<<0)
-#define v_DSP_VS_ST_F1(x)		(((x)&0x1fff)<<16)
-#define m_DSP_VS_END_F1			(0x1fff<<0)
-#define m_DSP_VS_ST_F1			(0x1fff<<16)
-
-#define DSP_VACT_ST_END_F1 		(0x019c)
-#define v_DSP_VACT_END_F1(x)		(((x)&0x1fff)<<0)
-#define v_DSP_VAC_ST_F1(x)		(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END_F1		(0x1fff<<0)
-#define m_DSP_VAC_ST_F1			(0x1fff<<16)
-
-
-/*pwm register*/
-#define PWM_CTRL 			(0x01a0)
-#define v_PWM_EN(x)			(((x)&1)<<0)
-#define v_PWM_MODE(x)		        (((x)&3)<<1)
-
-#define v_DUTY_POL(x)		        (((x)&1)<<3)
-#define v_INACTIVE_POL(x)		(((x)&1)<<4)
-#define v_OUTPUT_MODE(x)		(((x)&1)<<5)
-#define v_BL_EN(x)			(((x)&1)<<8)
-#define v_CLK_SEL(x)		        (((x)&1)<<9)
-#define v_PRESCALE(x)		        (((x)&7)<<12)
-#define v_SCALE(x)			(((x)&0xff)<<16)
-#define v_RPT(x)			(((x)&0xff)<<24)
-
-#define m_PWM_EN			(1<<0)
-#define m_PWM_MODE			(3<<1)
-
-#define m_DUTY_POL			(1<<3)
-#define m_INACTIVE_POL		        (1<<4)
-#define m_OUTPUT_MODE		        (1<<5)
-#define m_BL_EN			        (1<<8)
-#define m_CLK_SEL			(1<<9)
-#define m_PRESCALE			(7<<12)
-#define m_SCALE		        	(0xff<<16)
-#define m_RPT		           	((u32)0xff<<24)
-
-#define PWM_PERIOD_HPR 			(0x01a4)
-#define PWM_DUTY_LPR  			(0x01a8)
-#define PWM_CNT 			(0x01ac)
-
-/*BCSH register*/
-#define BCSH_COLOR_BAR 			(0x01b0)
-#define v_BCSH_EN(x)			(((x)&1)<<0)
-#define v_BCSH_COLOR_BAR_Y(x)		(((x)&0x3ff)<<2)
-#define v_BCSH_COLOR_BAR_U(x)		(((x)&0x3ff)<<12)
-#define v_BCSH_COLOR_BAR_V(x)		(((x)&0x3ff)<<22)
-
-#define m_BCSH_EN			(1<<0)
-#define m_BCSH_COLOR_BAR_Y		(0x3ff<<2)
-#define m_BCSH_COLOR_BAR_U		(0x3ff<<12)
-#define m_BCSH_COLOR_BAR_V		((u32)0x3ff<<22)
-
-#define BCSH_BCS 			(0x01b4)
-#define v_BCSH_BRIGHTNESS(x)		(((x)&0xff)<<0)	
-#define v_BCSH_CONTRAST(x)		(((x)&0x1ff)<<8)	
-#define v_BCSH_SAT_CON(x)		(((x)&0x3ff)<<20)	
-#define v_BCSH_OUT_MODE(x)		(((x)&0x3)<<30)	
-
-#define m_BCSH_BRIGHTNESS		(0xff<<0)	
-#define m_BCSH_CONTRAST			(0x1ff<<8)
-#define m_BCSH_SAT_CON			(0x3ff<<20)	
-#define m_BCSH_OUT_MODE			((u32)0x3<<30)	
-
-
-#define BCSH_H 				(0x01b8) 
-#define v_BCSH_SIN_HUE(x)		(((x)&0x1ff)<<0)
-#define v_BCSH_COS_HUE(x)		(((x)&0x1ff)<<16)
-
-#define m_BCSH_SIN_HUE			(0x1ff<<0)
-#define m_BCSH_COS_HUE			(0x1ff<<16)
-
-#define BCSH_CTRL			(0x01bc)
-#define v_BCSH_Y2R_EN(x)		(((x)&0x1)<<0)
-#define v_BCSH_R2Y_EN(x)		(((x)&0x1)<<4)
-#define m_BCSH_Y2R_EN			(0x1<<0)
-#define m_BCSH_R2Y_EN			(0x1<<4)
-
-#define CABC_CTRL0			(0x01c0)
-#define v_CABC_EN(x)				(((x)&1)<<0)
-#define v_CABC_HANDLE_EN(x)			(((x)&1)<<1)
-#define v_PWM_CONFIG_MODE(x)			(((x)&3)<<2)
-#define v_CABC_CALC_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
-#define m_CABC_EN				(1<<0)
-#define m_CABC_HANDLE_EN			(1<<1)
-#define m_PWM_CONFIG_MODE			(3<<2)
-#define m_CABC_CALC_PIXEL_NUM			(0x7fffff<<4)
-
-#define CABC_CTRL1			(0x01c4)
-#define v_CABC_LUT_EN(x)			(((x)&1)<<0)
-#define v_CABC_TOTAL_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
-#define m_CABC_LUT_EN				(1<<0)
-#define m_CABC_TOTAL_PIXEL_NUM			(0x7fffff<<4)
-
-#define CABC_GAUSS_LINE0_0 		(0x01c8)
-#define CABC_GAUSS_LINE0_1 		(0x01cc)
-#define CABC_GAUSS_LINE1_0 		(0x01d0)
-#define CABC_GAUSS_LINE1_1 		(0x01d4)
-#define CABC_GAUSS_LINE2_0 		(0x01d8)
-#define CABC_GAUSS_LINE2_1 		(0x01dc)
-
-/*FRC register*/
-#define FRC_LOWER01_0 			(0x01e0)
-#define FRC_LOWER01_1 			(0x01e4)
-#define FRC_LOWER10_0 			(0x01e8)
-#define FRC_LOWER10_1 			(0x01ec)
-#define FRC_LOWER11_0 			(0x01f0)
-#define FRC_LOWER11_1 			(0x01f4)
-
-#define CABC_CTRL2			(0x01f8)
-#define v_CABC_STAGE_DOWN(x)			(((x)&0xff)<<0)
-#define v_CABC_STAGE_UP(x)			(((x)&0x1ff)<<8)
-#define v_CABC_STAGE_MODE(x)			(((x)&1)<<19)
-#define v_MAX_SCALE_CFG_VALUE(x)		(((x)&0x1ff)<<20)
-#define v_MAX_SCALE_CFG_ENABLE(x)		(((x)&1)<<31)
-#define m_CABC_STAGE_DOWN			(0xff<<0)
-#define m_CABC_STAGE_UP				(0x1ff<<8)
-#define m_CABC_STAGE_MODE			(1<<19)
-#define m_MAX_SCALE_CFG_VALUE			(0x1ff<<20)
-#define m_MAX_SCALE_CFG_ENABLE			(1<<31)
-
-#define CABC_CTRL3			(0x01fc)
-#define v_CABC_GLOBAL_DN(x)			(((x)&0xff)<<0)
-#define v_CABC_GLOBAL_DN_LIMIT_EN(x)		(((x)&1)<<8)
-#define m_CABC_GLOBAL_DN			(0xff<<0)
-#define m_CABC_GLOBAL_DN_LIMIT_EN		(1<<8)
-
-#define MMU_DTE_ADDR			(0x0300)
-#define v_MMU_DTE_ADDR(x)		(((x)&0xffffffff)<<0)
-#define m_MMU_DTE_ADDR			(0xffffffff<<0)
-
-#define MMU_STATUS			(0x0304)
-#define v_PAGING_ENABLED(x)		(((x)&1)<<0)
-#define v_PAGE_FAULT_ACTIVE(x)		(((x)&1)<<1)
-#define v_STAIL_ACTIVE(x)		(((x)&1)<<2)
-#define v_MMU_IDLE(x)			(((x)&1)<<3)
-#define v_REPLAY_BUFFER_EMPTY(x)	(((x)&1)<<4)
-#define v_PAGE_FAULT_IS_WRITE(x)	(((x)&1)<<5)
-#define v_PAGE_FAULT_BUS_ID(x)		(((x)&0x1f)<<6)
-#define m_PAGING_ENABLED		(1<<0)
-#define m_PAGE_FAULT_ACTIVE		(1<<1)
-#define m_STAIL_ACTIVE			(1<<2)
-#define m_MMU_IDLE			(1<<3)
-#define m_REPLAY_BUFFER_EMPTY		(1<<4)
-#define m_PAGE_FAULT_IS_WRITE		(1<<5)
-#define m_PAGE_FAULT_BUS_ID		(0x1f<<6)
-
-#define MMU_COMMAND			(0x0308)
-#define v_MMU_CMD(x)			(((x)&0x3)<<0)
-#define m_MMU_CMD			(0x3<<0)
-
-#define MMU_PAGE_FAULT_ADDR		(0x030c)
-#define v_PAGE_FAULT_ADDR(x)		(((x)&0xffffffff)<<0)
-#define m_PAGE_FAULT_ADDR		(0xffffffff<<0)
-
-#define MMU_ZAP_ONE_LINE		(0x0310)
-#define v_MMU_ZAP_ONE_LINE(x)		(((x)&0xffffffff)<<0)
-#define m_MMU_ZAP_ONE_LINE		(0xffffffff<<0)
-
-#define MMU_INT_RAWSTAT			(0x0314)
-#define v_PAGE_FAULT_RAWSTAT(x)		(((x)&1)<<0)
-#define v_READ_BUS_ERROR_RAWSTAT(x)	(((x)&1)<<1)
-#define m_PAGE_FAULT_RAWSTAT		(1<<0)
-#define m_READ_BUS_ERROR_RAWSTAT	(1<<1)
-
-#define MMU_INT_CLEAR			(0x0318)
-#define v_PAGE_FAULT_CLEAR(x)		(((x)&1)<<0)
-#define v_READ_BUS_ERROR_CLEAR(x)	(((x)&1)<<1)
-#define m_PAGE_FAULT_CLEAR		(1<<0)
-#define m_READ_BUS_ERROR_CLEAR		(1<<1)
-
-#define MMU_INT_MASK			(0x031c)
-#define v_PAGE_FAULT_MASK(x)		(((x)&1)<<0)
-#define v_READ_BUS_ERROR_MASK(x)	(((x)&1)<<1)
-#define m_PAGE_FAULT_MASK		(1<<0)
-#define m_READ_BUS_ERROR_MASK		(1<<1)
-
-#define MMU_INT_STATUS			(0x0320)
-#define v_PAGE_FAULT_STATUS(x)		(((x)&1)<<0)
-#define v_READ_BUS_ERROR_STATUS(x)	(((x)&1)<<1)
-#define m_PAGE_FAULT_STATUS		(1<<0)
-#define m_READ_BUS_ERROR_STATUS		(1<<1)
-
-#define MMU_AUTO_GATING			(0x0324)
-#define v_MMU_AUTO_GATING(x)		(((x)&1)<<0)
-#define m_MMU_AUTO_GATING		(1<<0)
-
-#define WIN2_LUT_ADDR 			(0x0400)
-#define WIN3_LUT_ADDR  			(0x0800)
-#define HWC_LUT_ADDR   			(0x0c00)
-#define GAMMA_LUT_ADDR 			(0x1000)
-#define CABC_LUT_ADDR			(0x2000)
-#define MCU_BYPASS_WPORT 		(0x2200) 
-#define MCU_BYPASS_RPORT 		(0x2300)
-
-#define PWM_MODE_ONE_SHOT		(0x0)
-#define PWM_MODE_CONTINUOUS		(0x1)
-#define PWM_MODE_CAPTURE		(0x2)
-enum lb_mode {
-    LB_YUV_3840X5 = 0x0,
-    LB_YUV_2560X8 = 0x1,
-    LB_RGB_3840X2 = 0x2,
-    LB_RGB_2560X4 = 0x3,
-    LB_RGB_1920X5 = 0x4,
-    LB_RGB_1280X8 = 0x5 
-};
-
-enum sacle_up_mode {
-    SCALE_UP_BIL = 0x0,
-    SCALE_UP_BIC = 0x1
-};
-
-enum scale_down_mode {
-    SCALE_DOWN_BIL = 0x0,
-    SCALE_DOWN_AVG = 0x1
-};
-
-/*ALPHA BLENDING MODE*/
-enum alpha_mode {               /*  Fs       Fd */
-	AB_USER_DEFINE     = 0x0,
-	AB_CLEAR    	   = 0x1,/*  0          0*/
-	AB_SRC      	   = 0x2,/*  1          0*/
-	AB_DST    	   = 0x3,/*  0          1  */
-	AB_SRC_OVER   	   = 0x4,/*  1   	    1-As''*/
-	AB_DST_OVER    	   = 0x5,/*  1-Ad''   1*/
-	AB_SRC_IN    	   = 0x6,
-	AB_DST_IN    	   = 0x7,
-	AB_SRC_OUT    	   = 0x8,
-	AB_DST_OUT    	   = 0x9,
-	AB_SRC_ATOP        = 0xa,
-	AB_DST_ATOP    	   = 0xb,
-	XOR                = 0xc,
-	AB_SRC_OVER_GLOBAL = 0xd
-}; /*alpha_blending_mode*/
-
-enum src_alpha_mode {
-	AA_STRAIGHT	   = 0x0,
-	AA_INVERSE         = 0x1
-};/*src_alpha_mode*/
-
-enum global_alpha_mode {
-	AA_GLOBAL 	  = 0x0,
-	AA_PER_PIX        = 0x1,
-	AA_PER_PIX_GLOBAL = 0x2
-};/*src_global_alpha_mode*/
-
-enum src_alpha_sel {
-	AA_SAT		= 0x0,
-	AA_NO_SAT	= 0x1
-};/*src_alpha_sel*/
-
-enum src_color_mode {
-	AA_SRC_PRE_MUL	       = 0x0,
-	AA_SRC_NO_PRE_MUL      = 0x1
-};/*src_color_mode*/
-
-enum factor_mode {
-	AA_ZERO			= 0x0,
-	AA_ONE   	   	= 0x1,
-	AA_SRC			= 0x2,
-	AA_SRC_INVERSE          = 0x3,
-	AA_SRC_GLOBAL           = 0x4
-};/*src_factor_mode  &&  dst_factor_mode*/
-
-enum cabc_stage_mode {
-	LAST_FRAME_PWM_VAL	= 0x0,
-	CUR_FRAME_PWM_VAL	= 0x1,
-	STAGE_BY_STAGE		= 0x2
-};
-
-struct lcdc_device{
-	int id;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;			/*back up reg*/
-	u32 reg_phy_base;       	/* physical basic address of lcdc register*/
-	u32 len;               		/* physical map length of lcdc register*/
-	spinlock_t  reg_lock;		/*one time only one process allowed to config the register*/
-	
-	int __iomem *dsp_lut_addr_base;
-
-
-	int prop;			/*used for primary or extended display device*/
-	bool pre_init;
-	bool pwr18;			/*if lcdc use 1.8v power supply*/
-	bool clk_on;			/*if aclk or hclk is closed ,acess to register is not allowed*/
-	u8 atv_layer_cnt;		/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
-	
-
-	unsigned int		irq;
-
-	struct clk		*pd;				/*lcdc power domain*/
-	struct clk		*hclk;				/*lcdc AHP clk*/
-	struct clk		*dclk;				/*lcdc dclk*/
-	struct clk		*aclk;				/*lcdc share memory frequency*/
-	u32 pixclock;	
-
-	u32 standby;						/*1:standby,0:wrok*/
-	u32 iommu_status;
-};
-
-struct alpha_config{
-	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
-	u32 src_global_alpha_val; /*win0_src_global_alpha*/
-	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
-	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
-	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
-	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
-	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
-};
-
-struct lcdc_cabc_mode {
-	u32 pixel_num;			/* pixel precent number */
-	u16 stage_up;			/* up stride */
-	u16 stage_down;		/* down stride */
-};
-
-static inline void lcdc_writel(struct lcdc_device *lcdc_dev,u32 offset,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);	
-	*_pv = v;
-	writel_relaxed(v,lcdc_dev->regs+offset);	
-}
-
-static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev,u32 offset)
-{
-	u32 v;
-	v = readl_relaxed(lcdc_dev->regs+offset);
-	return v;
-}
-
-static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;
-	u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
-	_pv += (offset >> 2);
-	*_pv = _v;
-       _v &= msk;
-       return (_v?1:0);   
-}
-
-static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) |= msk;				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk)
-{
-	u32* _pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);				
-	(*_pv) &= (~msk);				
-	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
-} 
-
-static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
-{
-	u32 *_pv = (u32*)lcdc_dev->regsbak;	
-	_pv += (offset >> 2);			
-	(*_pv) &= (~msk);				
-	(*_pv) |= v;				
-	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
-}
-
-static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
-{
-	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
-	dsb();	
-} 
-
-#define CUBIC_PRECISE  0
-#define CUBIC_SPLINE   1
-#define CUBIC_CATROM   2
-#define CUBIC_MITCHELL 3
-
-#define CUBIC_MODE_SELETION      CUBIC_PRECISE
-
-/*****************************************************************************************************/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
-
-#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
-#define SCALE_FACTOR_AVRG_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
-#define SCALE_FACTOR_BIC_FIXPOINT(x)       ((INT32)((x)*(1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
-#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
-
-/*****************************************************************************************************/
-
-/*#define GET_SCALE_FACTOR_BILI(src, dst) ((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*#define GET_SCALE_FACTOR_BIC(src, dst)  ((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*modified by hpz*/
-#define GET_SCALE_FACTOR_BILI_DN(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-#define GET_SCALE_FACTOR_BILI_UP(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-#define GET_SCALE_FACTOR_BIC(src, dst)      ((((src)*2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-
-/*****************************************************************/
-/*NOTE: hardware, srcH (srcH+vScaleDnMult-1)/vScaleDnMult; */
-#define GET_SCALE_DN_ACT_HEIGHT(srcH, vScaleDnMult) (((srcH)+(vScaleDnMult)-1)/(vScaleDnMult))
-
-/*#define VSKIP_MORE_PRECISE*/
-
-#ifdef VSKIP_MORE_PRECISE
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srcH, dstH, vScaleDnMult) \
-            (GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)), (dstH)))
-#else
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srcH, dstH, vScaleDnMult) \
-            ((GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)) == (dstH))\
-                            ? (GET_SCALE_FACTOR_BILI_DN((srcH), (dstH))/(vScaleDnMult))\
-                            : GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)), (dstH)))
-#endif
-/*****************************************************************/
-
-
-/*ScaleFactor must >= dst/src, or pixels at end of line may be unused*/
-/*ScaleFactor must < dst/(src-1), or dst buffer may overflow*/
-/*avrg old code:       ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))/((src) - 1)) hxx_chgsrc*/
-/*modified by hpz:*/
-#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << (SCALE_FACTOR_AVRG_FIXPOINT_SHIFT+1)))/(2*(src) - 1))
-
-/*****************************************************************************************************/
-/*Scale Coordinate Accumulate, x.16*/
-#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
-#define SCALE_COOR_ACC_FIXPOINT_ONE       (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
-#define SCALE_COOR_ACC_FIXPOINT(x)        ((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
-#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) ((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT-1)) + 1) >> 1)
-
-#define SCALE_GET_COOR_ACC_FIXPOINT(scaleFactor, factorFixpointShift)  \
-        ((scaleFactor) << (SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorFixpointShift)))
-
-
-/*****************************************************************************************************/
-/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
-#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
-#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
-#define SCALE_FILTER_FACTOR_FIXPOINT(x)        ((INT32)((x)*(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
-#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) ((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
-
-#define SCALE_GET_FILTER_FACTOR_FIXPOINT(coorAccumulate, coorAccFixpointShift) \
-  (((coorAccumulate)>>((coorAccFixpointShift)-SCALE_FILTER_FACTOR_FIXPOINT_SHIFT))&(SCALE_FILTER_FACTOR_FIXPOINT_ONE-1))
-
-#define SCALE_OFFSET_FIXPOINT_SHIFT            8
-#define SCALE_OFFSET_FIXPOINT(x)              ((INT32)((x)*(1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
-
-u32 getHardWareVSkipLines(u32 srcH, u32 dstH)
-{
-    u32 vScaleDnMult;
-
-    if(srcH >= (u32)(4*dstH*MIN_SCALE_FACTOR_AFTER_VSKIP))
-    {
-        vScaleDnMult = 4;
-    }
-    else if(srcH >= (u32)(2*dstH*MIN_SCALE_FACTOR_AFTER_VSKIP))
-    {
-        vScaleDnMult = 2;
-    }
-    else
-    {
-        vScaleDnMult = 1;
-    }
-
-    return vScaleDnMult;
-}
-#endif
diff --git a/drivers/video/rockchip/lcdc/rk3368_lcdc.c b/drivers/video/rockchip/lcdc/rk3368_lcdc.c
deleted file mode 100644
index 7ddd64da896f..000000000000
--- a/drivers/video/rockchip/lcdc/rk3368_lcdc.c
+++ /dev/null
@@ -1,5229 +0,0 @@
-/*
- * drivers/video/rockchip/lcdc/rk3368_lcdc.c
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *Author:hjc<hjc@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/rockchip-iovmm.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/grf.h>
-#include <dt-bindings/clock/rk_system_status.h>
-
-#include "rk3368_lcdc.h"
-
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-#include <linux/earlysuspend.h>
-#endif
-/*#define CONFIG_RK_FPGA 1*/
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		pr_info(x);\
-	} while (0)
-
-#define EARLY_TIME 500 /*us*/
-static struct rk_lcdc_win lcdc_win[] = {
-	[0] = {
-		.name = "win0",
-		.id = 0,
-		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_SCALE |
-					SUPPORT_YUV,
-		.property.max_input_x = 4096,
-		.property.max_input_y = 2304
-		},
-	[1] = {
-		.name = "win1",
-		.id = 1,
-		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_SCALE |
-					SUPPORT_YUV,
-		.property.max_input_x = 4096,
-		.property.max_input_y = 2304
-		},
-	[2] = {
-		.name = "win2",
-		.id = 2,
-		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_MULTI_AREA,
-		.property.max_input_x = 4096,
-		.property.max_input_y = 2304
-		},
-	[3] = {
-		.name = "win3",
-		.id = 3,
-		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_MULTI_AREA,
-		.property.max_input_x = 4096,
-		.property.max_input_y = 2304
-		},
-	[4] = {
-		.name = "hwc",
-		.id = 4,
-		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HWC_LAYER,
-		.property.max_input_x = 128,
-		.property.max_input_y = 128
-		},
-};
-
-static int rk3368_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
-
-/*#define WAIT_FOR_SYNC 1*/
-u32 rk3368_get_hard_ware_vskiplines(u32 srch, u32 dsth)
-{
-	u32 vscalednmult;
-
-	if (srch >= (u32) (4 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
-		vscalednmult = 4;
-	else if (srch >= (u32) (2 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
-		vscalednmult = 2;
-	else
-		vscalednmult = 1;
-
-	return vscalednmult;
-}
-
-
-static int rk3368_set_cabc_lut(struct rk_lcdc_driver *dev_drv, int *cabc_lut)
-{
-	int i;
-	int __iomem *c;
-	u32 v;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
-		     v_CABC_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 128; i++) {
-		v = cabc_lut[i];
-		c = lcdc_dev->cabc_lut_addr_base + i;
-		writel_relaxed(v, c);
-	}
-	lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
-		     v_CABC_LUT_EN(1));
-	return 0;
-}
-
-
-static int rk3368_lcdc_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
-{
-	int i;
-	int __iomem *c;
-	u32 v;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-		     v_DSP_LUT_EN(0));
-	lcdc_cfg_done(lcdc_dev);
-	mdelay(25);
-	for (i = 0; i < 256; i++) {
-		v = dsp_lut[i];
-		c = lcdc_dev->dsp_lut_addr_base + i;
-		writel_relaxed(v, c);
-	}
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-		     v_DSP_LUT_EN(1));
-
-	return 0;
-}
-
-static int rk3368_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 1;
-	return 0;
-#endif
-	if (!lcdc_dev->clk_on) {
-		clk_prepare_enable(lcdc_dev->hclk);
-		clk_prepare_enable(lcdc_dev->dclk);
-		clk_prepare_enable(lcdc_dev->aclk);
-		if (lcdc_dev->pd)
-			clk_prepare_enable(lcdc_dev->pd);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-		pm_runtime_get_sync(lcdc_dev->dev);
-#endif
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 1;
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rk3368_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
-{
-#ifdef CONFIG_RK_FPGA
-	lcdc_dev->clk_on = 0;
-	return 0;
-#endif
-	if (lcdc_dev->clk_on) {
-		spin_lock(&lcdc_dev->reg_lock);
-		lcdc_dev->clk_on = 0;
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(25);
-		if (lcdc_dev->pd)
-			clk_disable_unprepare(lcdc_dev->pd);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-		pm_runtime_put(lcdc_dev->dev);
-#endif
-		clk_disable_unprepare(lcdc_dev->dclk);
-		clk_disable_unprepare(lcdc_dev->hclk);
-		clk_disable_unprepare(lcdc_dev->aclk);
-	}
-
-	return 0;
-}
-
-static int __maybe_unused
-	rk3368_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
-{
-	u32 mask, val;
-	u32 intr_en_reg, intr_clr_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-		intr_clr_reg = INTR_CLEAR_RK3366;
-		intr_en_reg = INTR_EN_RK3366;
-	} else {
-		intr_clr_reg = INTR_CLEAR_RK3368;
-		intr_en_reg = INTR_EN_RK3368;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		mask = m_FS_INTR_EN | m_FS_NEW_INTR_EN |
-		    m_ADDR_SAME_INTR_EN | m_LINE_FLAG0_INTR_EN |
-		    m_LINE_FLAG1_INTR_EN | m_BUS_ERROR_INTR_EN |
-		    m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
-		    m_WIN2_EMPTY_INTR_EN | m_WIN3_EMPTY_INTR_EN |
-		    m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
-		    m_PWM_GEN_INTR_EN | m_DSP_HOLD_VALID_INTR_EN;
-		val = v_FS_INTR_EN(0) | v_FS_NEW_INTR_EN(0) |
-		    v_ADDR_SAME_INTR_EN(0) |
-		    v_LINE_FLAG0_INTR_EN(0) | v_LINE_FLAG1_INTR_EN(0) |
-		    v_BUS_ERROR_INTR_EN(0) | v_WIN0_EMPTY_INTR_EN(0) |
-		    v_WIN1_EMPTY_INTR_EN(0) | v_WIN2_EMPTY_INTR_EN(0) |
-		    v_WIN3_EMPTY_INTR_EN(0) | v_HWC_EMPTY_INTR_EN(0) |
-		    v_POST_BUF_EMPTY_INTR_EN(0) |
-		    v_PWM_GEN_INTR_EN(0) | v_DSP_HOLD_VALID_INTR_EN(0);
-		lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
-
-		mask = m_FS_INTR_CLR | m_FS_NEW_INTR_CLR |
-		    m_ADDR_SAME_INTR_CLR | m_LINE_FLAG0_INTR_CLR |
-		    m_LINE_FLAG1_INTR_CLR | m_BUS_ERROR_INTR_CLR |
-		    m_WIN0_EMPTY_INTR_CLR | m_WIN1_EMPTY_INTR_CLR |
-		    m_WIN2_EMPTY_INTR_CLR | m_WIN3_EMPTY_INTR_CLR |
-		    m_HWC_EMPTY_INTR_CLR | m_POST_BUF_EMPTY_INTR_CLR |
-		    m_PWM_GEN_INTR_CLR | m_DSP_HOLD_VALID_INTR_CLR;
-		val = v_FS_INTR_CLR(1) | v_FS_NEW_INTR_CLR(1) |
-		    v_ADDR_SAME_INTR_CLR(1) |
-		    v_LINE_FLAG0_INTR_CLR(1) | v_LINE_FLAG1_INTR_CLR(1) |
-		    v_BUS_ERROR_INTR_CLR(1) | v_WIN0_EMPTY_INTR_CLR(1) |
-		    v_WIN1_EMPTY_INTR_CLR(1) | v_WIN2_EMPTY_INTR_CLR(1) |
-		    v_WIN3_EMPTY_INTR_CLR(1) | v_HWC_EMPTY_INTR_CLR(1) |
-		    v_POST_BUF_EMPTY_INTR_CLR(1) |
-		    v_PWM_GEN_INTR_CLR(1) | v_DSP_HOLD_VALID_INTR_CLR(1);
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	mdelay(1);
-	return 0;
-}
-
-static int rk3368_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int *cbase = (int *)lcdc_dev->regs;
-	int *regsbak = (int *)lcdc_dev->regsbak;
-	int i, j, val;
-	char dbg_message[30];
-	char buf[10];
-
-	pr_info("lcd back up reg:\n");
-	memset(dbg_message, 0, sizeof(dbg_message));
-	memset(buf, 0, sizeof(buf));
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		val = sprintf(dbg_message, "0x%04x: ", i * 16);
-		for (j = 0; j < 4; j++) {
-			val = sprintf(buf, "%08x  ", *(regsbak + i * 4 + j));
-			strcat(dbg_message, buf);
-		}
-		pr_info("%s\n", dbg_message);
-		memset(dbg_message, 0, sizeof(dbg_message));
-		memset(buf, 0, sizeof(buf));
-	}
-
-	pr_info("lcdc reg:\n");
-	for (i = 0; i <= (0x200 >> 4); i++) {
-		val = sprintf(dbg_message, "0x%04x: ", i * 16);
-		for (j = 0; j < 4; j++) {
-			sprintf(buf, "%08x  ",
-				readl_relaxed(cbase + i * 4 + j));
-			strcat(dbg_message, buf);
-		}
-		pr_info("%s\n", dbg_message);
-		memset(dbg_message, 0, sizeof(dbg_message));
-		memset(buf, 0, sizeof(buf));
-	}
-
-	return 0;
-}
-
-#define WIN_EN(id)		\
-static int win##id##_enable(struct lcdc_device *lcdc_dev, int en)	\
-{ \
-	u32 msk, val;							\
-	spin_lock(&lcdc_dev->reg_lock);					\
-	msk =  m_WIN##id##_EN;						\
-	val  =  v_WIN##id##_EN(en);					\
-	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);		\
-	lcdc_cfg_done(lcdc_dev);					\
-	spin_unlock(&lcdc_dev->reg_lock);				\
-	return 0;							\
-}
-
-WIN_EN(0);
-WIN_EN(1);
-WIN_EN(2);
-WIN_EN(3);
-/*enable/disable win directly*/
-static int rk3368_lcdc_win_direct_en(struct rk_lcdc_driver *drv,
-				     int win_id, int en)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(drv, struct lcdc_device, driver);
-	if (win_id == 0)
-		win0_enable(lcdc_dev, en);
-	else if (win_id == 1)
-		win1_enable(lcdc_dev, en);
-	else if (win_id == 2)
-		win2_enable(lcdc_dev, en);
-	else if (win_id == 3)
-		win3_enable(lcdc_dev, en);
-	else
-		dev_err(lcdc_dev->dev, "invalid win number:%d\n", win_id);
-	return 0;
-}
-
-#define SET_WIN_ADDR(id) \
-static int set_win##id##_addr(struct lcdc_device *lcdc_dev, u32 addr) \
-{							\
-	u32 msk, val;					\
-	spin_lock(&lcdc_dev->reg_lock);			\
-	lcdc_writel(lcdc_dev, WIN##id##_YRGB_MST, addr);	\
-	msk =  m_WIN##id##_EN;				\
-	val  =  v_WIN0_EN(1);				\
-	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);	\
-	lcdc_cfg_done(lcdc_dev);			\
-	spin_unlock(&lcdc_dev->reg_lock);		\
-	return 0;					\
-}
-
-SET_WIN_ADDR(0);
-SET_WIN_ADDR(1);
-int rk3368_lcdc_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
-				    int win_id, u32 addr)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	if (win_id == 0)
-		set_win0_addr(lcdc_dev, addr);
-	else
-		set_win1_addr(lcdc_dev, addr);
-
-	return 0;
-}
-
-static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
-{
-	int reg = 0;
-	u32 val = 0;
-	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
-	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
-	u32 v_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
-	u32 st_x = 0, st_y = 0;
-	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	for (reg = 0; reg < SCAN_LINE_NUM; reg += 4) {
-		val = lcdc_readl_backup(lcdc_dev, reg);
-		switch (reg) {
-		case VERSION_INFO:
-			lcdc_dev->soc_type = val;
-			break;
-		case WIN0_ACT_INFO:
-			win0->area[0].xact = (val & m_WIN0_ACT_WIDTH) + 1;
-			win0->area[0].yact =
-			    ((val & m_WIN0_ACT_HEIGHT) >> 16) + 1;
-			break;
-		case WIN0_DSP_INFO:
-			win0->area[0].xsize = (val & m_WIN0_DSP_WIDTH) + 1;
-			win0->area[0].ysize =
-			    ((val & m_WIN0_DSP_HEIGHT) >> 16) + 1;
-			break;
-		case WIN0_DSP_ST:
-			st_x = val & m_WIN0_DSP_XST;
-			st_y = (val & m_WIN0_DSP_YST) >> 16;
-			win0->area[0].xpos = st_x - h_pw_bp;
-			win0->area[0].ypos = st_y - v_pw_bp;
-			break;
-		case WIN0_CTRL0:
-			win0->state = val & m_WIN0_EN;
-			win0->area[0].fmt_cfg = (val & m_WIN0_DATA_FMT) >> 1;
-			win0->fmt_10 = (val & m_WIN0_FMT_10) >> 4;
-			win0->area[0].format = win0->area[0].fmt_cfg;
-			break;
-		case WIN0_VIR:
-			win0->area[0].y_vir_stride = val & m_WIN0_VIR_STRIDE;
-			win0->area[0].uv_vir_stride =
-			    (val & m_WIN0_VIR_STRIDE_UV) >> 16;
-			if (win0->area[0].format == ARGB888)
-				win0->area[0].xvir = win0->area[0].y_vir_stride;
-			else if (win0->area[0].format == RGB888)
-				win0->area[0].xvir =
-				    win0->area[0].y_vir_stride * 4 / 3;
-			else if (win0->area[0].format == RGB565)
-				win0->area[0].xvir =
-				    2 * win0->area[0].y_vir_stride;
-			else	/* YUV */
-				win0->area[0].xvir =
-				    4 * win0->area[0].y_vir_stride;
-			break;
-		case WIN0_YRGB_MST:
-			win0->area[0].smem_start = val;
-			break;
-		case WIN0_CBR_MST:
-			win0->area[0].cbr_start = val;
-			break;
-		case DSP_VACT_ST_END:
-			if (support_uboot_display()) {
-				screen->mode.yres =
-				(val & 0x1fff) - ((val >> 16) & 0x1fff);
-				win0->area[0].ypos =
-				st_y - ((val >> 16) & 0x1fff);
-			}
-			break;
-		case DSP_HACT_ST_END:
-			if (support_uboot_display()) {
-				screen->mode.xres =
-				(val & 0x1fff) - ((val >> 16) & 0x1fff);
-				win0->area[0].xpos =
-				st_x - ((val >> 16) & 0x1fff);
-			}
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-
-/********do basic init*********/
-static int rk3368_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	if (lcdc_dev->pre_init)
-		return 0;
-
-	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
-	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
-	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
-	if ((IS_ERR(lcdc_dev->aclk)) || (IS_ERR(lcdc_dev->dclk)) ||
-	    (IS_ERR(lcdc_dev->hclk))) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
-			lcdc_dev->id);
-	}
-
-	lcdc_dev->pd = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
-	if (IS_ERR(lcdc_dev->pd)) {
-		dev_err(lcdc_dev->dev, "failed to get lcdc%d pdclk source\n",
-			lcdc_dev->id);
-		lcdc_dev->pd = NULL;
-	}
-
-	if (!support_uboot_display())
-		rk_disp_pwr_enable(dev_drv);
-	rk3368_lcdc_clk_enable(lcdc_dev);
-
-	/*backup reg config at uboot */
-	lcdc_read_reg_defalut_cfg(lcdc_dev);
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		lcdc_grf_writel(lcdc_dev->grf_base, RK3366_GRF_IO_VSEL,
-				RK3366_GRF_VOP_IOVOL_SEL(lcdc_dev->pwr18));
-	else
-		lcdc_grf_writel(lcdc_dev->pmugrf_base,
-				PMUGRF_SOC_CON0_VOP,
-				RK3368_GRF_VOP_IOVOL_SEL(lcdc_dev->pwr18));
-
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_0,0x15110903);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_1,0x00030911);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_0,0x1a150b04);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_1,0x00040b15);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_0,0x15110903);
-	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_1,0x00030911);
-
-	lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
-	lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
-	lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0xa55a9696);
-	lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x5aa56969);
-	lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
-	lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
-
-	mask = m_AUTO_GATING_EN;
-	val = v_AUTO_GATING_EN(0);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-	mask = m_DITHER_UP_EN;
-	val = v_DITHER_UP_EN(1);
-	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-	lcdc_cfg_done(lcdc_dev);
-	/*disable win0 to workaround iommu pagefault */
-	/*if (dev_drv->iommu_enabled) */
-	/*      win0_enable(lcdc_dev, 0); */
-	lcdc_dev->pre_init = true;
-
-	return 0;
-}
-
-static void rk3368_lcdc_deint(struct lcdc_device *lcdc_dev)
-{
-	u32 mask, val;
-
-	if (lcdc_dev->clk_on) {
-		rk3368_lcdc_disable_irq(lcdc_dev);
-		spin_lock(&lcdc_dev->reg_lock);
-		mask = m_WIN0_EN;
-		val = v_WIN0_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
-
-		mask = m_WIN2_EN | m_WIN2_MST0_EN |
-			m_WIN2_MST1_EN |
-			m_WIN2_MST2_EN | m_WIN2_MST3_EN;
-		val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
-			v_WIN2_MST1_EN(0) |
-			v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
-		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-		spin_unlock(&lcdc_dev->reg_lock);
-		mdelay(50);
-	}
-}
-
-static int rk3368_lcdc_post_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	u16 h_total, v_total;
-	u16 post_hsd_en, post_vsd_en;
-	u16 post_dsp_hact_st, post_dsp_hact_end;
-	u16 post_dsp_vact_st, post_dsp_vact_end;
-	u16 post_dsp_vact_st_f1, post_dsp_vact_end_f1;
-	u16 post_h_fac, post_v_fac;
-
-	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
-	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
-	screen->post_xsize = x_res *
-	    (dev_drv->overscan.left + dev_drv->overscan.right) / 200;
-	screen->post_ysize = y_res *
-	    (dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
-
-	h_total = screen->mode.hsync_len + screen->mode.left_margin +
-	    x_res + screen->mode.right_margin;
-	v_total = screen->mode.vsync_len + screen->mode.upper_margin +
-	    y_res + screen->mode.lower_margin;
-
-	if (screen->post_dsp_stx + screen->post_xsize > x_res) {
-		dev_warn(lcdc_dev->dev, "post:stx[%d]+xsize[%d]>x_res[%d]\n",
-			 screen->post_dsp_stx, screen->post_xsize, x_res);
-		screen->post_dsp_stx = x_res - screen->post_xsize;
-	}
-	if (screen->x_mirror == 0) {
-		post_dsp_hact_st = screen->post_dsp_stx +
-		    screen->mode.hsync_len + screen->mode.left_margin;
-		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
-	} else {
-		post_dsp_hact_end = h_total - screen->mode.right_margin -
-		    screen->post_dsp_stx;
-		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
-	}
-	if ((screen->post_xsize < x_res) && (screen->post_xsize != 0)) {
-		post_hsd_en = 1;
-		post_h_fac =
-		    GET_SCALE_FACTOR_BILI_DN(x_res, screen->post_xsize);
-	} else {
-		post_hsd_en = 0;
-		post_h_fac = 0x1000;
-	}
-
-	if (screen->post_dsp_sty + screen->post_ysize > y_res) {
-		dev_warn(lcdc_dev->dev, "post:sty[%d]+ysize[%d]> y_res[%d]\n",
-			 screen->post_dsp_sty, screen->post_ysize, y_res);
-		screen->post_dsp_sty = y_res - screen->post_ysize;
-	}
-
-	if ((screen->post_ysize < y_res) && (screen->post_ysize != 0)) {
-		post_vsd_en = 1;
-		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res,
-						      screen->post_ysize);
-	} else {
-		post_vsd_en = 0;
-		post_v_fac = 0x1000;
-	}
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		post_dsp_vact_st = screen->post_dsp_sty / 2 +
-					screen->mode.vsync_len +
-					screen->mode.upper_margin;
-		post_dsp_vact_end = post_dsp_vact_st +
-					screen->post_ysize / 2;
-
-		post_dsp_vact_st_f1 = screen->mode.vsync_len +
-				      screen->mode.upper_margin +
-				      y_res/2 +
-				      screen->mode.lower_margin +
-				      screen->mode.vsync_len +
-				      screen->mode.upper_margin +
-				      screen->post_dsp_sty / 2 +
-				      1;
-		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 +
-					screen->post_ysize/2;
-	} else {
-		if (screen->y_mirror == 0) {
-			post_dsp_vact_st = screen->post_dsp_sty +
-			    screen->mode.vsync_len +
-			    screen->mode.upper_margin;
-			post_dsp_vact_end = post_dsp_vact_st +
-				screen->post_ysize;
-		} else {
-			post_dsp_vact_end = v_total -
-				screen->mode.lower_margin -
-			    screen->post_dsp_sty;
-			post_dsp_vact_st = post_dsp_vact_end -
-				screen->post_ysize;
-		}
-		post_dsp_vact_st_f1 = 0;
-		post_dsp_vact_end_f1 = 0;
-	}
-	DBG(1, "post:xsize=%d,ysize=%d,xpos=%d",
-	    screen->post_xsize, screen->post_ysize, screen->xpos);
-	DBG(1, ",ypos=%d,hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
-	    screen->ypos, post_hsd_en, post_h_fac, post_vsd_en, post_v_fac);
-	mask = m_DSP_HACT_END_POST | m_DSP_HACT_ST_POST;
-	val = v_DSP_HACT_END_POST(post_dsp_hact_end) |
-	    v_DSP_HACT_ST_POST(post_dsp_hact_st);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_HACT_INFO, mask, val);
-
-	mask = m_DSP_VACT_END_POST | m_DSP_VACT_ST_POST;
-	val = v_DSP_VACT_END_POST(post_dsp_vact_end) |
-	    v_DSP_VACT_ST_POST(post_dsp_vact_st);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO, mask, val);
-
-	mask = m_POST_HS_FACTOR_YRGB | m_POST_VS_FACTOR_YRGB;
-	val = v_POST_HS_FACTOR_YRGB(post_h_fac) |
-	    v_POST_VS_FACTOR_YRGB(post_v_fac);
-	lcdc_msk_reg(lcdc_dev, POST_SCL_FACTOR_YRGB, mask, val);
-
-	mask = m_DSP_VACT_END_POST_F1 | m_DSP_VACT_ST_POST_F1;
-	val = v_DSP_VACT_END_POST_F1(post_dsp_vact_end_f1) |
-	    v_DSP_VACT_ST_POST_F1(post_dsp_vact_st_f1);
-	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO_F1, mask, val);
-
-	mask = m_POST_HOR_SD_EN | m_POST_VER_SD_EN;
-	val = v_POST_HOR_SD_EN(post_hsd_en) | v_POST_VER_SD_EN(post_vsd_en);
-	lcdc_msk_reg(lcdc_dev, POST_SCL_CTRL, mask, val);
-	return 0;
-}
-
-static int rk3368_lcdc_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win;
-	u32 colorkey_r, colorkey_g, colorkey_b;
-	int i, key_val;
-
-	for (i = 0; i < 4; i++) {
-		win = dev_drv->win[i];
-		key_val = win->color_key_val;
-		colorkey_r = (key_val & 0xff) << 2;
-		colorkey_g = ((key_val >> 8) & 0xff) << 12;
-		colorkey_b = ((key_val >> 16) & 0xff) << 22;
-		/*color key dither 565/888->aaa */
-		key_val = colorkey_r | colorkey_g | colorkey_b;
-		switch (i) {
-		case 0:
-			lcdc_writel(lcdc_dev, WIN0_COLOR_KEY, key_val);
-			break;
-		case 1:
-			lcdc_writel(lcdc_dev, WIN1_COLOR_KEY, key_val);
-			break;
-		case 2:
-			lcdc_writel(lcdc_dev, WIN2_COLOR_KEY, key_val);
-			break;
-		case 3:
-			lcdc_writel(lcdc_dev, WIN3_COLOR_KEY, key_val);
-			break;
-		default:
-			pr_info("%s:un support win num:%d\n",
-				__func__, i);
-			break;
-		}
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	struct alpha_config alpha_config;
-	u32 mask, val;
-	int ppixel_alpha = 0, global_alpha = 0, i;
-	u32 src_alpha_ctl = 0, dst_alpha_ctl = 0;
-
-	memset(&alpha_config, 0, sizeof(struct alpha_config));
-	for (i = 0; i < win->area_num; i++) {
-		ppixel_alpha |= ((win->area[i].format == ARGB888) ||
-				 (win->area[i].format == FBDC_ARGB_888) ||
-				 (win->area[i].format == FBDC_ABGR_888) ||
-				 (win->area[i].format == ABGR888)) ? 1 : 0;
-	}
-	global_alpha = (win->g_alpha_val == 0) ? 0 : 1;
-	alpha_config.src_global_alpha_val = win->g_alpha_val;
-	win->alpha_mode = AB_SRC_OVER;
-	switch (win->alpha_mode) {
-	case AB_USER_DEFINE:
-		break;
-	case AB_CLEAR:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_SRC:
-		alpha_config.src_factor_mode = AA_ONE;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_ONE;
-		break;
-	case AB_SRC_OVER:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		if (global_alpha)
-			alpha_config.src_factor_mode = AA_SRC_GLOBAL;
-		else
-			alpha_config.src_factor_mode = AA_ONE;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_DST_OVER:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_ONE;
-		break;
-	case AB_SRC_IN:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST_IN:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_SRC;
-		break;
-	case AB_SRC_OUT:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_ZERO;
-		break;
-	case AB_DST_OUT:
-		alpha_config.src_factor_mode = AA_ZERO;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_SRC_ATOP:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_DST_ATOP:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_SRC;
-		break;
-	case XOR:
-		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	case AB_SRC_OVER_GLOBAL:
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-		alpha_config.src_color_mode = AA_SRC_NO_PRE_MUL;
-		alpha_config.src_factor_mode = AA_SRC_GLOBAL;
-		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
-		break;
-	default:
-		pr_err("alpha mode error\n");
-		break;
-	}
-	if ((ppixel_alpha == 1) && (global_alpha == 1))
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-	else if (ppixel_alpha == 1)
-		alpha_config.src_global_alpha_mode = AA_PER_PIX;
-	else if (global_alpha == 1)
-		alpha_config.src_global_alpha_mode = AA_GLOBAL;
-	else
-		dev_warn(lcdc_dev->dev, "alpha_en should be 0\n");
-	alpha_config.src_alpha_mode = AA_STRAIGHT;
-	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
-
-	switch (win_id) {
-	case 0:
-		src_alpha_ctl = 0x60;
-		dst_alpha_ctl = 0x64;
-		break;
-	case 1:
-		src_alpha_ctl = 0xa0;
-		dst_alpha_ctl = 0xa4;
-		break;
-	case 2:
-		src_alpha_ctl = 0xdc;
-		dst_alpha_ctl = 0xec;
-		break;
-	case 3:
-		src_alpha_ctl = 0x12c;
-		dst_alpha_ctl = 0x13c;
-		break;
-	case 4:
-		src_alpha_ctl = 0x160;
-		dst_alpha_ctl = 0x164;
-		break;
-	}
-	mask = m_WIN0_DST_FACTOR_M0;
-	val = v_WIN0_DST_FACTOR_M0(alpha_config.dst_factor_mode);
-	lcdc_msk_reg(lcdc_dev, dst_alpha_ctl, mask, val);
-	mask = m_WIN0_SRC_ALPHA_EN | m_WIN0_SRC_COLOR_M0 |
-	    m_WIN0_SRC_ALPHA_M0 | m_WIN0_SRC_BLEND_M0 |
-	    m_WIN0_SRC_ALPHA_CAL_M0 | m_WIN0_SRC_FACTOR_M0 |
-	    m_WIN0_SRC_GLOBAL_ALPHA;
-	val = v_WIN0_SRC_ALPHA_EN(1) |
-	    v_WIN0_SRC_COLOR_M0(alpha_config.src_color_mode) |
-	    v_WIN0_SRC_ALPHA_M0(alpha_config.src_alpha_mode) |
-	    v_WIN0_SRC_BLEND_M0(alpha_config.src_global_alpha_mode) |
-	    v_WIN0_SRC_ALPHA_CAL_M0(alpha_config.src_alpha_cal_m0) |
-	    v_WIN0_SRC_FACTOR_M0(alpha_config.src_factor_mode) |
-	    v_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
-	lcdc_msk_reg(lcdc_dev, src_alpha_ctl, mask, val);
-
-	return 0;
-}
-
-static int rk3368_lcdc_area_xst(struct rk_lcdc_win *win, int area_num)
-{
-	struct rk_lcdc_win_area area_temp;
-	int i, j;
-
-	for (i = 0; i < area_num; i++) {
-		for (j = i + 1; j < area_num; j++) {
-			if (win->area[i].dsp_stx >  win->area[j].dsp_stx) {
-				memcpy(&area_temp, &win->area[i],
-				       sizeof(struct rk_lcdc_win_area));
-				memcpy(&win->area[i], &win->area[j],
-				       sizeof(struct rk_lcdc_win_area));
-				memcpy(&win->area[j], &area_temp,
-				       sizeof(struct rk_lcdc_win_area));
-			}
-		}
-	}
-
-	return 0;
-}
-
-static int __maybe_unused
-	rk3368_lcdc_area_swap(struct rk_lcdc_win *win, int area_num)
-{
-	struct rk_lcdc_win_area area_temp;
-
-	switch (area_num) {
-	case 2:
-		area_temp = win->area[0];
-		win->area[0] = win->area[1];
-		win->area[1] = area_temp;
-		break;
-	case 3:
-		area_temp = win->area[0];
-		win->area[0] = win->area[2];
-		win->area[2] = area_temp;
-		break;
-	case 4:
-		area_temp = win->area[0];
-		win->area[0] = win->area[3];
-		win->area[3] = area_temp;
-
-		area_temp = win->area[1];
-		win->area[1] = win->area[2];
-		win->area[2] = area_temp;
-		break;
-	default:
-		pr_info("un supported area num!\n");
-		break;
-	}
-	return 0;
-}
-
-static int __maybe_unused
-rk3368_win_area_check_var(int win_id, int area_num,
-			  struct rk_lcdc_win_area *area_pre,
-			  struct rk_lcdc_win_area *area_now)
-{
-	if ((area_pre->xpos > area_now->xpos) ||
-	    ((area_pre->xpos + area_pre->xsize > area_now->xpos) &&
-	     (area_pre->ypos + area_pre->ysize > area_now->ypos))) {
-		area_now->state = 0;
-		pr_err("win[%d]:\n"
-		       "area_pre[%d]:xpos[%d],xsize[%d],ypos[%d],ysize[%d]\n"
-		       "area_now[%d]:xpos[%d],xsize[%d],ypos[%d],ysize[%d]\n",
-		       win_id,
-		       area_num - 1, area_pre->xpos, area_pre->xsize,
-		       area_pre->ypos, area_pre->ysize,
-		       area_num, area_now->xpos, area_now->xsize,
-		       area_now->ypos, area_now->ysize);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int __maybe_unused rk3368_get_fbdc_idle(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val, i;
-
-	for (i = 0; i < 100; i++) {
-		val = lcdc_readl(lcdc_dev, IFBDC_DEBUG0);
-		val &= m_DBG_IFBDC_IDLE;
-		if (val)
-			continue;
-		else
-			mdelay(10);
-	};
-	return val;
-}
-
-static int rk3368_fbdc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u32 mask, val;
-
-	if (lcdc_dev->soc_type != VOP_FULL_RK3368) {
-		pr_err("soc: 0x%08x not support FBDC\n", lcdc_dev->soc_type);
-		return 0;
-	}
-	mask = m_IFBDC_CTRL_FBDC_COR_EN |
-	    m_IFBDC_CTRL_FBDC_WIN_SEL | m_IFBDC_CTRL_FBDC_ROTATION_MODE |
-	    m_IFBDC_CTRL_FBDC_FMT | m_IFBDC_CTRL_WIDTH_RATIO;
-	val = v_IFBDC_CTRL_FBDC_COR_EN(win->area[0].fbdc_cor_en) |
-	    v_IFBDC_CTRL_FBDC_WIN_SEL(win->id) |
-	    v_IFBDC_CTRL_FBDC_ROTATION_MODE((win->xmirror &&
-					     win->ymirror) << 1) |
-	    v_IFBDC_CTRL_FBDC_FMT(win->area[0].fbdc_fmt_cfg) |
-	    v_IFBDC_CTRL_WIDTH_RATIO(win->area[0].fbdc_dsp_width_ratio);
-	lcdc_msk_reg(lcdc_dev, IFBDC_CTRL, mask, val);
-
-	mask = m_IFBDC_TILES_NUM;
-	val = v_IFBDC_TILES_NUM(win->area[0].fbdc_num_tiles);
-	lcdc_msk_reg(lcdc_dev, IFBDC_TILES_NUM, mask, val);
-
-	mask = m_IFBDC_MB_SIZE_WIDTH | m_IFBDC_MB_SIZE_HEIGHT;
-	val = v_IFBDC_MB_SIZE_WIDTH(win->area[0].fbdc_mb_width) |
-	    v_IFBDC_MB_SIZE_HEIGHT(win->area[0].fbdc_mb_height);
-	lcdc_msk_reg(lcdc_dev, IFBDC_MB_SIZE, mask, val);
-
-	mask = m_IFBDC_CMP_INDEX_INIT;
-	val = v_IFBDC_CMP_INDEX_INIT(win->area[0].fbdc_cmp_index_init);
-	lcdc_msk_reg(lcdc_dev, IFBDC_CMP_INDEX_INIT, mask, val);
-
-	mask = m_IFBDC_MB_VIR_WIDTH;
-	val = v_IFBDC_MB_VIR_WIDTH(win->area[0].fbdc_mb_vir_width);
-	lcdc_msk_reg(lcdc_dev, IFBDC_MB_VIR_WIDTH, mask, val);
-
-	return 0;
-}
-
-static int rk3368_init_fbdc_config(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u8 fbdc_dsp_width_ratio = 0;
-	u16 fbdc_mb_vir_width = 0, fbdc_mb_vir_height = 0;
-	u16 fbdc_mb_width = 0, fbdc_mb_height = 0;
-	u16 fbdc_mb_xst = 0, fbdc_mb_yst = 0, fbdc_num_tiles = 0;
-	u16 fbdc_cmp_index_init = 0;
-	u8 mb_w_size = 0, mb_h_size = 0;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (screen->mode.flag & FB_VMODE_INTERLACED) {
-		dev_err(lcdc_dev->dev, "unsupport fbdc+interlace!\n");
-		return 0;
-	}
-
-	if (lcdc_dev->soc_type != VOP_FULL_RK3368) {
-		pr_err("soc: 0x%08x not support FBDC\n", lcdc_dev->soc_type);
-		return 0;
-	}
-	switch (win->area[0].fmt_cfg) {
-	case VOP_FORMAT_ARGB888:
-		fbdc_dsp_width_ratio = 0;
-		mb_w_size = 16;
-		break;
-	case VOP_FORMAT_RGB888:
-		fbdc_dsp_width_ratio = 0;
-		mb_w_size = 16;
-		break;
-	case VOP_FORMAT_RGB565:
-		fbdc_dsp_width_ratio = 1;
-		mb_w_size = 32;
-		break;
-	default:
-		dev_err(lcdc_dev->dev,
-			"in fbdc mode,unsupport fmt:%d!\n",
-			win->area[0].fmt_cfg);
-		break;
-	}
-	mb_h_size = 4;
-
-	/*macro block xvir and yvir */
-	if ((win->area[0].xvir % mb_w_size == 0) &&
-	    (win->area[0].yvir % mb_h_size == 0)) {
-		fbdc_mb_vir_width = win->area[0].xvir / mb_w_size;
-		fbdc_mb_vir_height = win->area[0].yvir / mb_h_size;
-	} else {
-		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
-		pr_err("xvir[%d]/yvir[%d] should %d/%d pix align!\n",
-		       win->area[0].xvir, win->area[0].yvir,
-		       mb_w_size, mb_h_size);
-	}
-	/*macro block xact and yact */
-	if ((win->area[0].xact % mb_w_size == 0) &&
-	    (win->area[0].yact % mb_h_size == 0)) {
-		fbdc_mb_width = win->area[0].xact / mb_w_size;
-		fbdc_mb_height = win->area[0].yact / mb_h_size;
-	} else {
-		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
-		pr_err("xact[%d]/yact[%d] should %d/%d pix align!\n",
-		       win->area[0].xact, win->area[0].yact,
-		       mb_w_size, mb_h_size);
-	}
-	/*macro block xoff and yoff */
-	if ((win->area[0].xoff % mb_w_size == 0) &&
-	    (win->area[0].yoff % mb_h_size == 0)) {
-		fbdc_mb_xst = win->area[0].xoff / mb_w_size;
-		fbdc_mb_yst = win->area[0].yoff / mb_h_size;
-	} else {
-		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
-		pr_err("xoff[%d]/yoff[%d] should %d/%d pix align!\n",
-		       win->area[0].xoff, win->area[0].yoff,
-		       mb_w_size, mb_h_size);
-	}
-
-	/*FBDC tiles */
-	fbdc_num_tiles = fbdc_mb_vir_width * fbdc_mb_vir_height;
-
-	/*
-	   switch (fbdc_rotation_mode)  {
-	   case FBDC_ROT_NONE:
-	   fbdc_cmp_index_init =
-	   (fbdc_mb_yst*fbdc_mb_vir_width) +  fbdc_mb_xst;
-	   break;
-	   case FBDC_X_MIRROR:
-	   fbdc_cmp_index_init =
-	   (fbdc_mb_yst*fbdc_mb_vir_width) + (fbdc_mb_xst+
-	   (fbdc_mb_width-1));
-	   break;
-	   case FBDC_Y_MIRROR:
-	   fbdc_cmp_index_init =
-	   ((fbdc_mb_yst+(fbdc_mb_height-1))*fbdc_mb_vir_width)  +
-	   fbdc_mb_xst;
-	   break;
-	   case FBDC_ROT_180:
-	   fbdc_cmp_index_init =
-	   ((fbdc_mb_yst+(fbdc_mb_height-1))*fbdc_mb_vir_width) +
-	   (fbdc_mb_xst+(fbdc_mb_width-1));
-	   break;
-	   }
-	 */
-	if (win->xmirror && win->ymirror && ((win_id == 2) || (win_id == 3))) {
-		fbdc_cmp_index_init =
-		    ((fbdc_mb_yst + (fbdc_mb_height - 1)) * fbdc_mb_vir_width) +
-		    (fbdc_mb_xst + (fbdc_mb_width - 1));
-	} else {
-		fbdc_cmp_index_init =
-		    (fbdc_mb_yst * fbdc_mb_vir_width) + fbdc_mb_xst;
-	}
-	/*fbdc fmt maybe need to change*/
-	win->area[0].fbdc_dsp_width_ratio = fbdc_dsp_width_ratio;
-	win->area[0].fbdc_mb_vir_width = fbdc_mb_vir_width;
-	win->area[0].fbdc_mb_vir_height = fbdc_mb_vir_height;
-	win->area[0].fbdc_mb_width = fbdc_mb_width;
-	win->area[0].fbdc_mb_height = fbdc_mb_height;
-	win->area[0].fbdc_mb_xst = fbdc_mb_xst;
-	win->area[0].fbdc_mb_yst = fbdc_mb_yst;
-	win->area[0].fbdc_num_tiles = fbdc_num_tiles;
-	win->area[0].fbdc_cmp_index_init = fbdc_cmp_index_init;
-
-	return 0;
-}
-
-static int rk3368_lcdc_axi_gather_cfg(struct lcdc_device *lcdc_dev,
-				      struct rk_lcdc_win *win)
-{
-	u32 mask, val;
-	u16 yrgb_gather_num = 3;
-	u16 cbcr_gather_num = 1;
-
-	switch (win->area[0].format) {
-	case ARGB888:
-	case XBGR888:
-	case XRGB888:
-	case ABGR888:
-	case FBDC_ARGB_888:
-	case FBDC_RGBX_888:
-	case FBDC_ABGR_888:
-		yrgb_gather_num = 3;
-		break;
-	case RGB888:
-	case RGB565:
-	case BGR888:
-	case BGR565:
-	case FBDC_RGB_565:
-		yrgb_gather_num = 2;
-		break;
-	case YUV444:
-	case YUV422:
-	case YUV420:
-	case YUV420_NV21:
-		yrgb_gather_num = 1;
-		cbcr_gather_num = 2;
-		break;
-	default:
-		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	if ((win->id == 0) || (win->id == 1)) {
-		mask = m_WIN0_YRGB_AXI_GATHER_EN | m_WIN0_CBR_AXI_GATHER_EN |
-			m_WIN0_YRGB_AXI_GATHER_NUM | m_WIN0_CBR_AXI_GATHER_NUM;
-		val = v_WIN0_YRGB_AXI_GATHER_EN(1) |
-			v_WIN0_CBR_AXI_GATHER_EN(1) |
-			v_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
-			v_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1 + (win->id * 0x40),
-			     mask, val);
-	} else if ((win->id == 2) || (win->id == 3)) {
-		mask = m_WIN2_AXI_GATHER_EN | m_WIN2_AXI_GATHER_NUM;
-		val = v_WIN2_AXI_GATHER_EN(1) |
-			v_WIN2_AXI_GATHER_NUM(yrgb_gather_num);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL1 + ((win->id - 2) * 0x50),
-			     mask, val);
-	} else if (win->id == 4) {
-		mask = m_HWC_AXI_GATHER_EN | m_HWC_AXI_GATHER_NUM;
-		val = v_HWC_AXI_GATHER_EN(1) |
-			v_HWC_AXI_GATHER_NUM(yrgb_gather_num);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL1, mask, val);
-	}
-	return 0;
-}
-
-static void rk3368_lcdc_csc_mode(struct lcdc_device *lcdc_dev,
-				 struct rk_lcdc_win *win)
-{
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		switch (win->area[0].fmt_cfg) {
-		case VOP_FORMAT_ARGB888:
-		case VOP_FORMAT_RGB888:
-		case VOP_FORMAT_RGB565:
-			if ((screen->mode.xres < 1280) &&
-			    (screen->mode.yres < 720)) {
-				win->csc_mode = VOP_R2Y_CSC_BT601;
-			} else {
-				win->csc_mode = VOP_R2Y_CSC_BT709;
-			}
-			break;
-		default:
-			break;
-		}
-	} else if (dev_drv->overlay_mode == VOP_RGB_DOMAIN) {
-		switch (win->area[0].fmt_cfg) {
-		case VOP_FORMAT_YCBCR420:
-			if ((win->id == 0) || (win->id == 1))
-				win->csc_mode = VOP_Y2R_CSC_MPEG;
-			break;
-		default:
-			break;
-		}
-	}
-}
-
-static int rk3368_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int mask, val, off;
-
-	off = win_id * 0x40;
-	/*if(win->win_lb_mode == 5)
-	   win->win_lb_mode = 4;
-	   for rk3288 to fix hw bug? */
-
-	if (win->state == 1) {
-		rk3368_lcdc_csc_mode(lcdc_dev, win);
-		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
-		if (win->area[0].fbdc_en)
-			rk3368_fbdc_reg_update(&lcdc_dev->driver, win_id);
-		mask = m_WIN0_EN | m_WIN0_DATA_FMT | m_WIN0_FMT_10 |
-			m_WIN0_LB_MODE | m_WIN0_RB_SWAP | m_WIN0_X_MIRROR |
-			m_WIN0_Y_MIRROR | m_WIN0_CSC_MODE | m_WIN0_UV_SWAP;
-		val = v_WIN0_EN(win->state) |
-			v_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
-			v_WIN0_FMT_10(win->fmt_10) |
-			v_WIN0_LB_MODE(win->win_lb_mode) |
-			v_WIN0_RB_SWAP(win->area[0].swap_rb) |
-			v_WIN0_X_MIRROR(win->xmirror) |
-			v_WIN0_Y_MIRROR(win->ymirror) |
-			v_WIN0_CSC_MODE(win->csc_mode) |
-			v_WIN0_UV_SWAP(win->area[0].swap_uv);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0 + off, mask, val);
-
-		mask = m_WIN0_BIC_COE_SEL |
-		    m_WIN0_VSD_YRGB_GT4 | m_WIN0_VSD_YRGB_GT2 |
-		    m_WIN0_VSD_CBR_GT4 | m_WIN0_VSD_CBR_GT2 |
-		    m_WIN0_YRGB_HOR_SCL_MODE | m_WIN0_YRGB_VER_SCL_MODE |
-		    m_WIN0_YRGB_HSD_MODE | m_WIN0_YRGB_VSU_MODE |
-		    m_WIN0_YRGB_VSD_MODE | m_WIN0_CBR_HOR_SCL_MODE |
-		    m_WIN0_CBR_VER_SCL_MODE | m_WIN0_CBR_HSD_MODE |
-		    m_WIN0_CBR_VSU_MODE | m_WIN0_CBR_VSD_MODE;
-		val = v_WIN0_BIC_COE_SEL(win->bic_coe_el) |
-		    v_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
-		    v_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
-		    v_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
-		    v_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
-		    v_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
-		    v_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
-		    v_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
-		    v_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
-		    v_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
-		    v_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
-		    v_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
-		    v_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
-		    v_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
-		    v_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1 + off, mask, val);
-		val = v_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
-		    v_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);
-		lcdc_writel(lcdc_dev, WIN0_VIR + off, val);
-		/*lcdc_writel(lcdc_dev, WIN0_YRGB_MST+off,
-				win->area[0].y_addr);
-		   lcdc_writel(lcdc_dev, WIN0_CBR_MST+off,
-				win->area[0].uv_addr); */
-		val = v_WIN0_ACT_WIDTH(win->area[0].xact) |
-		    v_WIN0_ACT_HEIGHT(win->area[0].yact);
-		lcdc_writel(lcdc_dev, WIN0_ACT_INFO + off, val);
-
-		val = v_WIN0_DSP_WIDTH(win->area[0].xsize) |
-		    v_WIN0_DSP_HEIGHT(win->area[0].ysize);
-		lcdc_writel(lcdc_dev, WIN0_DSP_INFO + off, val);
-
-		val = v_WIN0_DSP_XST(win->area[0].dsp_stx) |
-		    v_WIN0_DSP_YST(win->area[0].dsp_sty);
-		lcdc_writel(lcdc_dev, WIN0_DSP_ST + off, val);
-
-		val = v_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
-		    v_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB + off, val);
-
-		val = v_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
-		    v_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
-		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR + off, val);
-		if (win->alpha_en == 1) {
-			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
-		} else {
-			mask = m_WIN0_SRC_ALPHA_EN;
-			val = v_WIN0_SRC_ALPHA_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN0_SRC_ALPHA_CTRL + off,
-				     mask, val);
-		}
-
-		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED) {
-			mask = m_WIN0_YRGB_DEFLICK | m_WIN0_CBR_DEFLICK;
-			if (win->area[0].yact == 2 * win->area[0].ysize)
-				val = v_WIN0_YRGB_DEFLICK(0) |
-					v_WIN0_CBR_DEFLICK(0);
-			else
-				val = v_WIN0_YRGB_DEFLICK(1) |
-					v_WIN0_CBR_DEFLICK(1);
-			lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-		}
-	} else {
-		mask = m_WIN0_EN;
-		val = v_WIN0_EN(win->state);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0 + off, mask, val);
-	}
-	return 0;
-}
-
-static int rk3368_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int mask, val, off;
-
-	off = (win_id - 2) * 0x50;
-	rk3368_lcdc_area_xst(win, win->area_num);
-
-	if (win->state == 1) {
-		rk3368_lcdc_csc_mode(lcdc_dev, win);
-		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
-		if (win->area[0].fbdc_en)
-			rk3368_fbdc_reg_update(&lcdc_dev->driver, win_id);
-
-		mask = m_WIN2_EN | m_WIN2_CSC_MODE;
-		val = v_WIN2_EN(1) | v_WIN1_CSC_MODE(win->csc_mode);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-		/*area 0 */
-		if (win->area[0].state == 1) {
-			mask = m_WIN2_MST0_EN | m_WIN2_DATA_FMT0 |
-			    m_WIN2_RB_SWAP0;
-			val = v_WIN2_MST0_EN(win->area[0].state) |
-			    v_WIN2_DATA_FMT0(win->area[0].fmt_cfg) |
-			    v_WIN2_RB_SWAP0(win->area[0].swap_rb);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-
-			mask = m_WIN2_VIR_STRIDE0;
-			val = v_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev, WIN2_VIR0_1 + off, mask, val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST0+off,
-			   win->area[0].y_addr); */
-			val = v_WIN2_DSP_WIDTH0(win->area[0].xsize) |
-			    v_WIN2_DSP_HEIGHT0(win->area[0].ysize);
-			lcdc_writel(lcdc_dev, WIN2_DSP_INFO0 + off, val);
-			val = v_WIN2_DSP_XST0(win->area[0].dsp_stx) |
-			    v_WIN2_DSP_YST0(win->area[0].dsp_sty);
-			lcdc_writel(lcdc_dev, WIN2_DSP_ST0 + off, val);
-		} else {
-			mask = m_WIN2_MST0_EN;
-			val = v_WIN2_MST0_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-		}
-		/*area 1 */
-		if (win->area[1].state == 1) {
-			/*rk3368_win_area_check_var(win_id, 1,
-						  &win->area[0], &win->area[1]);
-			*/
-
-			mask = m_WIN2_MST1_EN | m_WIN2_DATA_FMT1 |
-			    m_WIN2_RB_SWAP1;
-			val = v_WIN2_MST1_EN(win->area[1].state) |
-			    v_WIN2_DATA_FMT1(win->area[1].fmt_cfg) |
-			    v_WIN2_RB_SWAP1(win->area[1].swap_rb);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-
-			mask = m_WIN2_VIR_STRIDE1;
-			val = v_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev, WIN2_VIR0_1 + off, mask, val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST1+off,
-			   win->area[1].y_addr); */
-			val = v_WIN2_DSP_WIDTH1(win->area[1].xsize) |
-			    v_WIN2_DSP_HEIGHT1(win->area[1].ysize);
-			lcdc_writel(lcdc_dev, WIN2_DSP_INFO1 + off, val);
-			val = v_WIN2_DSP_XST1(win->area[1].dsp_stx) |
-			    v_WIN2_DSP_YST1(win->area[1].dsp_sty);
-			lcdc_writel(lcdc_dev, WIN2_DSP_ST1 + off, val);
-		} else {
-			mask = m_WIN2_MST1_EN;
-			val = v_WIN2_MST1_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-		}
-		/*area 2 */
-		if (win->area[2].state == 1) {
-			/*rk3368_win_area_check_var(win_id, 2,
-						  &win->area[1], &win->area[2]);
-			*/
-
-			mask = m_WIN2_MST2_EN | m_WIN2_DATA_FMT2 |
-			    m_WIN2_RB_SWAP2;
-			val = v_WIN2_MST2_EN(win->area[2].state) |
-			    v_WIN2_DATA_FMT2(win->area[2].fmt_cfg) |
-			    v_WIN2_RB_SWAP2(win->area[2].swap_rb);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-
-			mask = m_WIN2_VIR_STRIDE2;
-			val = v_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev, WIN2_VIR2_3 + off, mask, val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST2+off,
-			   win->area[2].y_addr); */
-			val = v_WIN2_DSP_WIDTH2(win->area[2].xsize) |
-			    v_WIN2_DSP_HEIGHT2(win->area[2].ysize);
-			lcdc_writel(lcdc_dev, WIN2_DSP_INFO2 + off, val);
-			val = v_WIN2_DSP_XST2(win->area[2].dsp_stx) |
-			    v_WIN2_DSP_YST2(win->area[2].dsp_sty);
-			lcdc_writel(lcdc_dev, WIN2_DSP_ST2 + off, val);
-		} else {
-			mask = m_WIN2_MST2_EN;
-			val = v_WIN2_MST2_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-		}
-		/*area 3 */
-		if (win->area[3].state == 1) {
-			/*rk3368_win_area_check_var(win_id, 3,
-						  &win->area[2], &win->area[3]);
-			*/
-
-			mask = m_WIN2_MST3_EN | m_WIN2_DATA_FMT3 |
-			    m_WIN2_RB_SWAP3;
-			val = v_WIN2_MST3_EN(win->area[3].state) |
-			    v_WIN2_DATA_FMT3(win->area[3].fmt_cfg) |
-			    v_WIN2_RB_SWAP3(win->area[3].swap_rb);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-
-			mask = m_WIN2_VIR_STRIDE3;
-			val = v_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
-			lcdc_msk_reg(lcdc_dev, WIN2_VIR2_3 + off, mask, val);
-
-			/*lcdc_writel(lcdc_dev,WIN2_MST3+off,
-			   win->area[3].y_addr); */
-			val = v_WIN2_DSP_WIDTH3(win->area[3].xsize) |
-			    v_WIN2_DSP_HEIGHT3(win->area[3].ysize);
-			lcdc_writel(lcdc_dev, WIN2_DSP_INFO3 + off, val);
-			val = v_WIN2_DSP_XST3(win->area[3].dsp_stx) |
-			    v_WIN2_DSP_YST3(win->area[3].dsp_sty);
-			lcdc_writel(lcdc_dev, WIN2_DSP_ST3 + off, val);
-		} else {
-			mask = m_WIN2_MST3_EN;
-			val = v_WIN2_MST3_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-		}
-
-		if (win->alpha_en == 1) {
-			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
-		} else {
-			mask = m_WIN2_SRC_ALPHA_EN;
-			val = v_WIN2_SRC_ALPHA_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_SRC_ALPHA_CTRL + off,
-				     mask, val);
-		}
-	} else {
-		mask = m_WIN2_EN | m_WIN2_MST0_EN |
-		    m_WIN2_MST0_EN | m_WIN2_MST2_EN | m_WIN2_MST3_EN;
-		val = v_WIN2_EN(win->state) | v_WIN2_MST0_EN(0) |
-		    v_WIN2_MST1_EN(0) | v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
-	}
-	return 0;
-}
-
-static int rk3368_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int mask, val, hwc_size = 0;
-
-	if (win->state == 1) {
-		rk3368_lcdc_csc_mode(lcdc_dev, win);
-		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
-		mask = m_HWC_EN | m_HWC_DATA_FMT |
-		    m_HWC_RB_SWAP | m_WIN0_CSC_MODE;
-		val = v_HWC_EN(1) | v_HWC_DATA_FMT(win->area[0].fmt_cfg) |
-		    v_HWC_RB_SWAP(win->area[0].swap_rb) |
-		    v_WIN0_CSC_MODE(win->csc_mode);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-
-		if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32))
-			hwc_size = 0;
-		else if ((win->area[0].xsize == 64) &&
-			 (win->area[0].ysize == 64))
-			hwc_size = 1;
-		else if ((win->area[0].xsize == 96) &&
-			 (win->area[0].ysize == 96))
-			hwc_size = 2;
-		else if ((win->area[0].xsize == 128) &&
-			 (win->area[0].ysize == 128))
-			hwc_size = 3;
-		else
-			dev_err(lcdc_dev->dev, "un supported hwc size!\n");
-
-		mask = m_HWC_SIZE;
-		val = v_HWC_SIZE(hwc_size);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-
-		mask = m_HWC_DSP_XST | m_HWC_DSP_YST;
-		val = v_HWC_DSP_XST(win->area[0].dsp_stx) |
-		    v_HWC_DSP_YST(win->area[0].dsp_sty);
-		lcdc_msk_reg(lcdc_dev, HWC_DSP_ST, mask, val);
-
-		if (win->alpha_en == 1) {
-			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
-		} else {
-			mask = m_WIN2_SRC_ALPHA_EN;
-			val = v_WIN2_SRC_ALPHA_EN(0);
-			lcdc_msk_reg(lcdc_dev, WIN2_SRC_ALPHA_CTRL, mask, val);
-		}
-	} else {
-		mask = m_HWC_EN;
-		val = v_HWC_EN(win->state);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
-					 struct rk_lcdc_win *win)
-{
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-	int timeout;
-	unsigned long flags;
-
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-			     v_STANDBY_EN(lcdc_dev->standby));
-		if ((win->id == 0) || (win->id == 1))
-			rk3368_win_0_1_reg_update(dev_drv, win->id);
-		else if ((win->id == 2) || (win->id == 3))
-			rk3368_win_2_3_reg_update(dev_drv, win->id);
-		else if (win->id == 4)
-			rk3368_hwc_reg_update(dev_drv, win->id);
-		/*rk3368_lcdc_post_cfg(dev_drv); */
-		lcdc_cfg_done(lcdc_dev);
-	}
-
-	/*if (dev_drv->wait_fs) { */
-	if (0) {
-		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-		timeout =
-		    wait_for_completion_timeout(&dev_drv->frame_done,
-						msecs_to_jiffies
-						(dev_drv->cur_screen->ft + 5));
-		if (!timeout && (!dev_drv->frame_done.done)) {
-			dev_warn(lcdc_dev->dev,
-				 "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
-	return 0;
-}
-
-static int rk3368_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
-{
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0x2a4);
-	else
-		memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0x270);
-
-	return 0;
-}
-
-static int __maybe_unused rk3368_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
-{
-	u32 mask, val;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	if (dev_drv->iommu_enabled) {
-		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
-			if (likely(lcdc_dev->clk_on)) {
-				mask = m_MMU_EN;
-				val = v_MMU_EN(1);
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-				mask = m_AXI_MAX_OUTSTANDING_EN |
-					m_AXI_OUTSTANDING_MAX_NUM;
-				val = v_AXI_OUTSTANDING_MAX_NUM(31) |
-					v_AXI_MAX_OUTSTANDING_EN(1);
-				lcdc_msk_reg(lcdc_dev, SYS_CTRL1, mask, val);
-			}
-			lcdc_dev->iommu_status = 1;
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
-{
-	int ret = 0, fps = 0;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-#ifdef CONFIG_RK_FPGA
-	return 0;
-#endif
-	if (reset_rate)
-		ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
-	lcdc_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
-	return 0;
-}
-
-static int rk3368_config_timing(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 right_margin = screen->mode.right_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	u16 h_total, v_total;
-	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
-	u32 frame_time;
-	u32 line_flag_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		line_flag_reg = LINE_FLAG_RK3366;
-	else
-		line_flag_reg = LINE_FLAG_RK3368;
-
-	h_total = hsync_len + left_margin + x_res + right_margin;
-	v_total = vsync_len + upper_margin + y_res + lower_margin;
-	frame_time = 1000 * v_total * h_total / (screen->mode.pixclock / 1000);
-	mask = m_DSP_HS_PW | m_DSP_HTOTAL;
-	val = v_DSP_HS_PW(hsync_len) | v_DSP_HTOTAL(h_total);
-	lcdc_msk_reg(lcdc_dev, DSP_HTOTAL_HS_END, mask, val);
-
-	mask = m_DSP_HACT_END | m_DSP_HACT_ST;
-	val = v_DSP_HACT_END(hsync_len + left_margin + x_res) |
-	    v_DSP_HACT_ST(hsync_len + left_margin);
-	lcdc_msk_reg(lcdc_dev, DSP_HACT_ST_END, mask, val);
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		/* First Field Timing */
-		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
-		val = v_DSP_VS_PW(vsync_len) |
-		    v_DSP_VTOTAL(2 * (vsync_len + upper_margin +
-				      lower_margin) + y_res + 1);
-		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
-
-		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
-		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
-		    v_DSP_VACT_ST(vsync_len + upper_margin);
-		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
-
-		/* Second Field Timing */
-		mask = m_DSP_VS_ST_F1 | m_DSP_VS_END_F1;
-		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
-		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
-		    lower_margin;
-		val = v_DSP_VS_ST_F1(vs_st_f1) | v_DSP_VS_END_F1(vs_end_f1);
-		lcdc_msk_reg(lcdc_dev, DSP_VS_ST_END_F1, mask, val);
-
-		mask = m_DSP_VACT_END_F1 | m_DSP_VAC_ST_F1;
-		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
-		    lower_margin + 1;
-		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
-		    lower_margin + 1;
-		val =
-		    v_DSP_VACT_END_F1(vact_end_f1) |
-		    v_DSP_VAC_ST_F1(vact_st_f1);
-		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END_F1, mask, val);
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-			     m_DSP_INTERLACE | m_DSP_FIELD_POL,
-			     v_DSP_INTERLACE(1) | v_DSP_FIELD_POL(0));
-		if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-			if (y_res <= 576)
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-					     m_SW_CORE_DCLK_SEL,
-					     v_SW_CORE_DCLK_SEL(1));
-			else
-				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-					     m_SW_CORE_DCLK_SEL,
-					     v_SW_CORE_DCLK_SEL(0));
-		}
-		mask =
-		    m_WIN0_INTERLACE_READ | m_WIN0_YRGB_DEFLICK |
-		    m_WIN0_CBR_DEFLICK;
-		val =
-		    v_WIN0_INTERLACE_READ(1) | v_WIN0_YRGB_DEFLICK(0) |
-		    v_WIN0_CBR_DEFLICK(0);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-
-		mask =
-		    m_WIN1_INTERLACE_READ | m_WIN1_YRGB_DEFLICK |
-		    m_WIN1_CBR_DEFLICK;
-		val =
-		    v_WIN1_INTERLACE_READ(1) | v_WIN1_YRGB_DEFLICK(0) |
-		    v_WIN1_CBR_DEFLICK(0);
-		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
-
-		mask = m_WIN2_INTERLACE_READ;
-		val = v_WIN2_INTERLACE_READ(1);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
-
-		mask = m_WIN3_INTERLACE_READ;
-		val = v_WIN3_INTERLACE_READ(1);
-		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
-
-		mask = m_HWC_INTERLACE_READ;
-		val = v_HWC_INTERLACE_READ(1);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-
-		mask = m_DSP_LINE_FLAG0_NUM | m_DSP_LINE_FLAG1_NUM;
-		val =
-		    v_DSP_LINE_FLAG0_NUM(vact_end_f1) |
-		    v_DSP_LINE_FLAG1_NUM(vact_end_f1 -
-					 EARLY_TIME * v_total / frame_time);
-		lcdc_msk_reg(lcdc_dev, line_flag_reg, mask, val);
-	} else {
-		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
-		val = v_DSP_VS_PW(vsync_len) | v_DSP_VTOTAL(v_total);
-		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
-
-		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
-		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res) |
-		    v_DSP_VACT_ST(vsync_len + upper_margin);
-		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-			     m_DSP_INTERLACE | m_DSP_FIELD_POL,
-			     v_DSP_INTERLACE(0) | v_DSP_FIELD_POL(0));
-		if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
-				     m_SW_CORE_DCLK_SEL,
-				     v_SW_CORE_DCLK_SEL(0));
-		}
-		mask =
-		    m_WIN0_INTERLACE_READ | m_WIN0_YRGB_DEFLICK |
-		    m_WIN0_CBR_DEFLICK;
-		val =
-		    v_WIN0_INTERLACE_READ(0) | v_WIN0_YRGB_DEFLICK(0) |
-		    v_WIN0_CBR_DEFLICK(0);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-
-		mask =
-		    m_WIN1_INTERLACE_READ | m_WIN1_YRGB_DEFLICK |
-		    m_WIN1_CBR_DEFLICK;
-		val =
-		    v_WIN1_INTERLACE_READ(0) | v_WIN1_YRGB_DEFLICK(0) |
-		    v_WIN1_CBR_DEFLICK(0);
-		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
-
-		mask = m_WIN2_INTERLACE_READ;
-		val = v_WIN2_INTERLACE_READ(0);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
-
-		mask = m_WIN3_INTERLACE_READ;
-		val = v_WIN3_INTERLACE_READ(0);
-		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
-
-		mask = m_HWC_INTERLACE_READ;
-		val = v_HWC_INTERLACE_READ(0);
-		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-
-		mask = m_DSP_LINE_FLAG0_NUM | m_DSP_LINE_FLAG1_NUM;
-		val = v_DSP_LINE_FLAG0_NUM(vsync_len + upper_margin + y_res) |
-			v_DSP_LINE_FLAG1_NUM(vsync_len + upper_margin + y_res -
-					     EARLY_TIME * v_total / frame_time);
-		lcdc_msk_reg(lcdc_dev, line_flag_reg, mask, val);
-	}
-	rk3368_lcdc_post_cfg(dev_drv);
-	return 0;
-}
-
-static void rk3368_lcdc_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 bcsh_ctrl;
-
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_OVERLAY_MODE,
-		     v_OVERLAY_MODE(dev_drv->overlay_mode));
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_Y2R_EN | m_BCSH_R2Y_EN,
-				     v_BCSH_Y2R_EN(0) | v_BCSH_R2Y_EN(0));
-		else		/* YUV2RGB */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_Y2R_EN | m_BCSH_Y2R_CSC_MODE |
-				     m_BCSH_R2Y_EN,
-				     v_BCSH_Y2R_EN(1) |
-				     v_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				     v_BCSH_R2Y_EN(0));
-	} else {		/* overlay_mode=VOP_RGB_DOMAIN */
-		/* bypass  --need check,if bcsh close? */
-		if (dev_drv->output_color == COLOR_RGB) {
-			bcsh_ctrl = lcdc_readl(lcdc_dev, BCSH_CTRL);
-			if (((bcsh_ctrl & m_BCSH_EN) == 1) ||
-			    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
-				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-					     m_BCSH_R2Y_EN |
-					     m_BCSH_Y2R_EN,
-					     v_BCSH_R2Y_EN(1) |
-					     v_BCSH_Y2R_EN(1));
-			else
-				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-					     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
-					     v_BCSH_R2Y_EN(0) |
-					     v_BCSH_Y2R_EN(0));
-		} else		/* RGB2YUV */
-			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
-				     m_BCSH_R2Y_EN |
-				     m_BCSH_R2Y_CSC_MODE | m_BCSH_Y2R_EN,
-				     v_BCSH_R2Y_EN(1) |
-				     v_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				     v_BCSH_Y2R_EN(0));
-	}
-}
-
-static int rk3368_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
-				  u16 *yact, int *format, u32 *dsp_addr,
-				  int *ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-
-	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-	*xact = (val & m_WIN0_ACT_WIDTH) + 1;
-	*yact = ((val & m_WIN0_ACT_HEIGHT)>>16) + 1;
-
-	val = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-	*format = (val & m_WIN0_DATA_FMT) >> 1;
-	*ymirror = (val & m_WIN0_Y_MIRROR) >> 22;
-	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3368_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			      int format, u16 xact, u16 yact, u16 xvir,
-			      int ymirror)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 val, mask;
-	struct rk_lcdc_win *win = dev_drv->win[0];
-	int swap = (format == RGB888) ? 1 : 0;
-
-	mask = m_WIN0_DATA_FMT | m_WIN0_RB_SWAP | m_WIN0_Y_MIRROR;
-	val = v_WIN0_DATA_FMT(format) | v_WIN0_RB_SWAP(swap) |
-		v_WIN0_Y_MIRROR(ymirror);
-	lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-
-	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_WIN0_VIR_STRIDE,
-		     v_WIN0_VIR_STRIDE(xvir));
-	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_WIN0_ACT_WIDTH(xact) |
-		    v_WIN0_ACT_HEIGHT(yact));
-
-	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
-
-	lcdc_cfg_done(lcdc_dev);
-	if (format == RGB888)
-		win->area[0].format = BGR888;
-	else
-		win->area[0].format = format;
-
-	win->ymirror = ymirror;
-	win->state = 1;
-	win->last_state = 1;
-
-	return 0;
-}
-
-static int lcdc_reset(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-	u32 __maybe_unused v;
-	if (!lcdc_dev->standby && initscreen && (dev_drv->first_frame != 1)) {
-		mdelay(150);
-		mask = m_WIN0_EN;
-		val = v_WIN0_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
-
-		mask = m_WIN2_EN | m_WIN2_MST0_EN |
-			m_WIN2_MST1_EN |
-			m_WIN2_MST2_EN | m_WIN2_MST3_EN;
-		val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
-			v_WIN2_MST1_EN(0) |
-			v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
-		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
-		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
-		mask = m_HDMI_OUT_EN;
-		val = v_HDMI_OUT_EN(0);
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-		mdelay(50);
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(1));
-		writel_relaxed(0, lcdc_dev->regs + REG_CFG_DONE);
-		mdelay(50);
-#ifdef VOP_RESET
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-		lcdc_cru_writel(lcdc_dev->cru_base, 0x0318,
-				(1 << 4)  | (1 << 5)  | (1 << 6) |
-				(1 << 20) | (1 << 21) | (1 << 22));
-		udelay(100);
-		v = lcdc_cru_readl(lcdc_dev->cru_base, 0x0318);
-		pr_info("cru read = 0x%x\n", v);
-		lcdc_cru_writel(lcdc_dev->cru_base, 0x0318,
-				(0 << 4)  | (0 << 5)  | (0 << 6) |
-				(1 << 20) | (1 << 21) | (1 << 22));
-		mdelay(100);
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_activate(dev_drv->dev);
-		}
-		mdelay(50);
-		rk3368_lcdc_reg_restore(lcdc_dev);
-		mdelay(50);
-#endif
-	}
-	return 0;
-}
-
-static int rk3368_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	u16 face = 0;
-	u16 dclk_ddr = 0;
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 mask = 0, val = 0;
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-
-	if (!lcdc_dev->standby && initscreen && (dev_drv->first_frame != 1))
-		flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-#if 0
-		if (!lcdc_dev->standby && !initscreen) {
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-				     v_STANDBY_EN(1));
-			lcdc_cfg_done(lcdc_dev);
-			mdelay(50);
-		}
-#else
-	lcdc_reset(dev_drv, initscreen);
-#endif
-		switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-			    m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-			    v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_YUV_420:
-			/*yuv420 output prefer yuv domain overlay */
-			face = OUT_YUV_420;
-			dclk_ddr = 1;
-			mask = m_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_S888:
-			face = OUT_S888;
-			mask = m_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_S888DUMY:
-			face = OUT_S888DUMY;
-			mask = m_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		case OUT_CCIR656:
-			if (screen->color_mode == COLOR_RGB)
-				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-			else
-				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-			face = OUT_CCIR656_MODE_0;
-			mask = m_DITHER_DOWN_EN;
-			val = v_DITHER_DOWN_EN(0);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-			break;
-		default:
-			dev_err(lcdc_dev->dev, "un supported interface!\n");
-			break;
-		}
-		switch (screen->type) {
-		case SCREEN_RGB:
-			mask = m_RGB_OUT_EN;
-			val = v_RGB_OUT_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_RGB_LVDS_HSYNC_POL | m_RGB_LVDS_VSYNC_POL |
-			    m_RGB_LVDS_DEN_POL | m_RGB_LVDS_DCLK_POL;
-			val = v_RGB_LVDS_HSYNC_POL(screen->pin_hsync) |
-			    v_RGB_LVDS_VSYNC_POL(screen->pin_vsync) |
-			    v_RGB_LVDS_DEN_POL(screen->pin_den) |
-			    v_RGB_LVDS_DCLK_POL(screen->pin_dclk);
-			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-				lcdc_grf_writel(lcdc_dev->grf_base,
-						RK3366_GRF_SOC_CON5,
-						RGB_SOURCE_SEL(dev_drv->id));
-				lcdc_grf_writel(lcdc_dev->grf_base,
-						RK3366_GRF_SOC_CON0,
-						RGB_DATA_PLANA);
-			}
-			break;
-		case SCREEN_LVDS:
-			mask = m_RGB_OUT_EN;
-			val = v_RGB_OUT_EN(1);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_RGB_LVDS_HSYNC_POL | m_RGB_LVDS_VSYNC_POL |
-			    m_RGB_LVDS_DEN_POL | m_RGB_LVDS_DCLK_POL;
-			val = v_RGB_LVDS_HSYNC_POL(screen->pin_hsync) |
-			    v_RGB_LVDS_VSYNC_POL(screen->pin_vsync) |
-			    v_RGB_LVDS_DEN_POL(screen->pin_den) |
-			    v_RGB_LVDS_DCLK_POL(screen->pin_dclk);
-			if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-				lcdc_grf_writel(lcdc_dev->grf_base,
-						RK3366_GRF_SOC_CON0,
-						LVDS_SOURCE_SEL(dev_drv->id));
-			break;
-		case SCREEN_HDMI:
-			if (screen->color_mode == COLOR_RGB)
-				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-			else
-				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-			mask = m_HDMI_OUT_EN  | m_RGB_OUT_EN;
-			val = v_HDMI_OUT_EN(1) | v_RGB_OUT_EN(0);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_HDMI_HSYNC_POL | m_HDMI_VSYNC_POL |
-			    m_HDMI_DEN_POL | m_HDMI_DCLK_POL;
-			val = v_HDMI_HSYNC_POL(screen->pin_hsync) |
-			    v_HDMI_VSYNC_POL(screen->pin_vsync) |
-			    v_HDMI_DEN_POL(screen->pin_den) |
-			    v_HDMI_DCLK_POL(screen->pin_dclk);
-			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-				lcdc_grf_writel(lcdc_dev->grf_base,
-						RK3366_GRF_SOC_CON0,
-						HDMI_SOURCE_SEL(dev_drv->id));
-			}
-			break;
-		case SCREEN_MIPI:
-			mask = m_MIPI_OUT_EN  | m_RGB_OUT_EN;
-			val = v_MIPI_OUT_EN(1) | v_RGB_OUT_EN(0);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_MIPI_HSYNC_POL | m_MIPI_VSYNC_POL |
-			    m_MIPI_DEN_POL | m_MIPI_DCLK_POL;
-			val = v_MIPI_HSYNC_POL(screen->pin_hsync) |
-			    v_MIPI_VSYNC_POL(screen->pin_vsync) |
-			    v_MIPI_DEN_POL(screen->pin_den) |
-			    v_MIPI_DCLK_POL(screen->pin_dclk);
-			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-				lcdc_grf_writel(lcdc_dev->grf_base,
-						RK3366_GRF_SOC_CON0,
-						MIPI_SOURCE_SEL(dev_drv->id));
-			}
-			break;
-		case SCREEN_DUAL_MIPI:
-			mask = m_MIPI_OUT_EN | m_DOUB_CHANNEL_EN  |
-				m_RGB_OUT_EN;
-			val = v_MIPI_OUT_EN(1) | v_DOUB_CHANNEL_EN(1) |
-				v_RGB_OUT_EN(0);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-			mask = m_MIPI_HSYNC_POL | m_MIPI_VSYNC_POL |
-			    m_MIPI_DEN_POL | m_MIPI_DCLK_POL;
-			val = v_MIPI_HSYNC_POL(screen->pin_hsync) |
-			    v_MIPI_VSYNC_POL(screen->pin_vsync) |
-			    v_MIPI_DEN_POL(screen->pin_den) |
-			    v_MIPI_DCLK_POL(screen->pin_dclk);
-			break;
-		case SCREEN_EDP:
-			face = OUT_P888;	/*RGB 888 output */
-
-			mask = m_EDP_OUT_EN | m_RGB_OUT_EN;
-			val = v_EDP_OUT_EN(1) | v_RGB_OUT_EN(0);
-			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
-
-			mask = m_EDP_HSYNC_POL | m_EDP_VSYNC_POL |
-			    m_EDP_DEN_POL | m_EDP_DCLK_POL;
-			val = v_EDP_HSYNC_POL(screen->pin_hsync) |
-			    v_EDP_VSYNC_POL(screen->pin_vsync) |
-			    v_EDP_DEN_POL(screen->pin_den) |
-			    v_EDP_DCLK_POL(screen->pin_dclk);
-			break;
-		}
-		/*hsync vsync den dclk polo,dither */
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-		mask = m_DSP_OUT_MODE | m_DSP_DCLK_DDR | m_DSP_BG_SWAP |
-		    m_DSP_RB_SWAP | m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		    m_DSP_DUMMY_SWAP | m_DSP_OUT_ZERO | m_DSP_BLANK_EN |
-		    m_DSP_BLACK_EN | m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN;
-		val = v_DSP_OUT_MODE(face) | v_DSP_DCLK_DDR(dclk_ddr) |
-		    v_DSP_BG_SWAP(screen->swap_gb) |
-		    v_DSP_RB_SWAP(screen->swap_rb) |
-		    v_DSP_RG_SWAP(screen->swap_rg) |
-		    v_DSP_DELTA_SWAP(screen->swap_delta) |
-		    v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_DSP_OUT_ZERO(0) |
-		    v_DSP_BLANK_EN(0) | v_DSP_BLACK_EN(0) |
-		    v_DSP_X_MIR_EN(screen->x_mirror) |
-		    v_DSP_Y_MIR_EN(screen->y_mirror);
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
-		/*BG color */
-		mask = m_DSP_BG_BLUE | m_DSP_BG_GREEN | m_DSP_BG_RED;
-		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN)
-			val = v_DSP_BG_BLUE(0x80) | v_DSP_BG_GREEN(0x10) |
-				v_DSP_BG_RED(0x80);
-		else
-			val = v_DSP_BG_BLUE(0) | v_DSP_BG_GREEN(0) |
-				v_DSP_BG_RED(0);
-		lcdc_msk_reg(lcdc_dev, DSP_BG, mask, val);
-		dev_drv->output_color = screen->color_mode;
-		if (screen->dsp_lut == NULL)
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-				     v_DSP_LUT_EN(0));
-		else
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
-				     v_DSP_LUT_EN(1));
-		rk3368_lcdc_bcsh_path_sel(dev_drv);
-		rk3368_config_timing(dev_drv);
-		if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-			lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	rk3368_lcdc_set_dclk(dev_drv, 1);
-	if (screen->type != SCREEN_HDMI &&
-	    screen->type != SCREEN_TVOUT &&
-	    dev_drv->trsm_ops &&
-	    dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	if (screen->init)
-		screen->init();
-	/*if (!lcdc_dev->standby)
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL,
-			m_STANDBY_EN, v_STANDBY_EN(0));*/
-	return 0;
-}
-
-
-/*enable layer,open:1,enable;0 disable*/
-static void rk3368_lcdc_layer_enable(struct lcdc_device *lcdc_dev,
-				     unsigned int win_id, bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on) &&
-	    lcdc_dev->driver.win[win_id]->state != open) {
-		if (open) {
-			if (!lcdc_dev->atv_layer_cnt) {
-				dev_info(lcdc_dev->dev,
-					 "wakeup from standby!\n");
-				lcdc_dev->standby = 0;
-			}
-			lcdc_dev->atv_layer_cnt |= (1 << win_id);
-		} else {
-			if (lcdc_dev->atv_layer_cnt & (1 << win_id))
-				lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
-		}
-		lcdc_dev->driver.win[win_id]->state = open;
-		if (!open) {
-			/*rk3368_lcdc_reg_update(dev_drv);*/
-			rk3368_lcdc_layer_update_regs
-			(lcdc_dev, lcdc_dev->driver.win[win_id]);
-			lcdc_cfg_done(lcdc_dev);
-		}
-		/*if no layer used,disable lcdc */
-		if (!lcdc_dev->atv_layer_cnt) {
-			dev_info(lcdc_dev->dev,
-				 "no layer is used,go to standby!\n");
-			lcdc_dev->standby = 1;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-}
-
-static int rk3368_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	u32 mask, val;
-	/*struct rk_screen *screen = dev_drv->cur_screen; */
-	u32 intr_en_reg, intr_clr_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-		intr_clr_reg = INTR_CLEAR_RK3366;
-		intr_en_reg = INTR_EN_RK3366;
-	} else {
-		intr_clr_reg = INTR_CLEAR_RK3368;
-		intr_en_reg = INTR_EN_RK3368;
-	}
-
-	mask = m_FS_INTR_CLR | m_FS_NEW_INTR_CLR | m_LINE_FLAG0_INTR_CLR |
-	    m_LINE_FLAG1_INTR_CLR;
-	val = v_FS_INTR_CLR(1) | v_FS_NEW_INTR_CLR(1) |
-	    v_LINE_FLAG0_INTR_CLR(1) | v_LINE_FLAG1_INTR_CLR(1);
-	lcdc_msk_reg(lcdc_dev, intr_clr_reg, mask, val);
-
-	mask = m_FS_INTR_EN | m_LINE_FLAG0_INTR_EN |
-		m_BUS_ERROR_INTR_EN | m_LINE_FLAG1_INTR_EN;
-	val = v_FS_INTR_EN(1) | v_LINE_FLAG0_INTR_EN(1) |
-	    v_BUS_ERROR_INTR_EN(1) | v_LINE_FLAG1_INTR_EN(0);
-	lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-	mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
-	    m_WIN2_EMPTY_INTR_EN |
-	    m_WIN3_EMPTY_INTR_EN | m_HWC_EMPTY_INTR_EN |
-	    m_POST_BUF_EMPTY_INTR_EN | m_PWM_GEN_INTR_EN;
-	val = v_WIN0_EMPTY_INTR_EN(1) | v_WIN1_EMPTY_INTR_EN(1) |
-	    v_WIN2_EMPTY_INTR_EN(1) |
-	    v_WIN3_EMPTY_INTR_EN(1) | v_HWC_EMPTY_INTR_EN(1) |
-	    v_POST_BUF_EMPTY_INTR_EN(1) | v_PWM_GEN_INTR_EN(1);
-	lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
-#endif
-	return 0;
-}
-
-static int rk3368_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
-			    bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	/*enable clk,when first layer open */
-	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
-		/*rockchip_set_system_status(sys_status);*/
-		rk3368_lcdc_pre_init(dev_drv);
-		rk3368_lcdc_clk_enable(lcdc_dev);
-		rk3368_lcdc_enable_irq(dev_drv);
-		if (dev_drv->iommu_enabled) {
-			if (!dev_drv->mmu_dev) {
-				dev_drv->mmu_dev =
-				    rk_fb_get_sysmmu_device_by_compatible
-				    (dev_drv->mmu_dts_name);
-				if (dev_drv->mmu_dev) {
-					rk_fb_platform_set_sysmmu
-					    (dev_drv->mmu_dev, dev_drv->dev);
-				} else {
-					dev_err(dev_drv->dev,
-						"fail get rk iommu device\n");
-					return -1;
-				}
-			}
-			/*if (dev_drv->mmu_dev)
-			   rockchip_iovmm_activate(dev_drv->dev); */
-		}
-		rk3368_lcdc_reg_restore(lcdc_dev);
-		/*if (dev_drv->iommu_enabled)
-		   rk3368_lcdc_mmu_en(dev_drv); */
-		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
-			rk3368_lcdc_set_dclk(dev_drv, 0);
-			/*rk3368_lcdc_enable_irq(dev_drv);*/
-		} else {
-			rk3368_load_screen(dev_drv, 1);
-		}
-		if (dev_drv->bcsh.enable)
-			rk3368_lcdc_set_bcsh(dev_drv, 1);
-		spin_lock(&lcdc_dev->reg_lock);
-		if (dev_drv->cur_screen->dsp_lut)
-			rk3368_lcdc_set_lut(dev_drv,
-					    dev_drv->cur_screen->dsp_lut);
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	if (win_id < ARRAY_SIZE(lcdc_win))
-		rk3368_lcdc_layer_enable(lcdc_dev, win_id, open);
-	else
-		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
-
-
-	/* when all layer closed,disable clk */
-	/*if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
-	   rk3368_lcdc_disable_irq(lcdc_dev);
-	   rk3368_lcdc_reg_update(dev_drv);
-	   if (dev_drv->iommu_enabled) {
-	   if (dev_drv->mmu_dev)
-	   rockchip_iovmm_deactivate(dev_drv->dev);
-	   }
-	   rk3368_lcdc_clk_disable(lcdc_dev);
-	   #ifndef CONFIG_RK_FPGA
-	   rockchip_clear_system_status(sys_status);
-	   #endif
-	   } */
-	dev_drv->first_frame = 0;
-	return 0;
-}
-
-static int win_0_1_display(struct lcdc_device *lcdc_dev,
-			   struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-	u32 uv_addr;
-	unsigned int off;
-
-	off = win->id * 0x40;
-	/*win->smem_start + win->y_offset; */
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
-	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
-	    lcdc_dev->id, win->id, y_addr, uv_addr);
-	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
-	    win->area[0].y_offset, win->area[0].c_offset);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		win->area[0].uv_addr = uv_addr;
-		lcdc_writel(lcdc_dev, WIN0_YRGB_MST + off, win->area[0].y_addr);
-		lcdc_writel(lcdc_dev, WIN0_CBR_MST + off, win->area[0].uv_addr);
-		if (win->area[0].fbdc_en == 1)
-			lcdc_writel(lcdc_dev, IFBDC_BASE_ADDR,
-				    win->area[0].y_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int win_2_3_display(struct lcdc_device *lcdc_dev,
-			   struct rk_lcdc_win *win)
-{
-	u32 i, y_addr;
-	unsigned int off;
-
-	off = (win->id - 2) * 0x50;
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc[%d]:win[%d]:", lcdc_dev->id, win->id);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		for (i = 0; i < win->area_num; i++) {
-			DBG(2, "area[%d]:yaddr:0x%x>>offset:0x%x>>\n",
-			    i, win->area[i].y_addr, win->area[i].y_offset);
-			win->area[i].y_addr =
-			    win->area[i].smem_start + win->area[i].y_offset;
-			}
-		lcdc_writel(lcdc_dev, WIN2_MST0 + off, win->area[0].y_addr);
-		lcdc_writel(lcdc_dev, WIN2_MST1 + off, win->area[1].y_addr);
-		lcdc_writel(lcdc_dev, WIN2_MST2 + off, win->area[2].y_addr);
-		lcdc_writel(lcdc_dev, WIN2_MST3 + off, win->area[3].y_addr);
-		if (win->area[0].fbdc_en == 1)
-			lcdc_writel(lcdc_dev, IFBDC_BASE_ADDR,
-				    win->area[0].y_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int hwc_display(struct lcdc_device *lcdc_dev, struct rk_lcdc_win *win)
-{
-	u32 y_addr;
-
-	y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	DBG(2, "lcdc[%d]:hwc>>%s>>y_addr:0x%x>>\n",
-	    lcdc_dev->id, __func__, y_addr);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		win->area[0].y_addr = y_addr;
-		lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3368_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-#if defined(WAIT_FOR_SYNC)
-	int timeout;
-	unsigned long flags;
-#endif
-	win = dev_drv->win[win_id];
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	if (win_id == 0) {
-		win_0_1_display(lcdc_dev, win);
-	} else if (win_id == 1) {
-		win_0_1_display(lcdc_dev, win);
-	} else if (win_id == 2) {
-		win_2_3_display(lcdc_dev, win);
-	} else if (win_id == 3) {
-		win_2_3_display(lcdc_dev, win);
-	} else if (win_id == 4) {
-		hwc_display(lcdc_dev, win);
-	} else {
-		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-#if defined(WAIT_FOR_SYNC)
-	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
-	init_completion(&dev_drv->frame_done);
-	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
-	timeout =
-	    wait_for_completion_timeout(&dev_drv->frame_done,
-					msecs_to_jiffies(dev_drv->
-							 cur_screen->ft + 5));
-	if (!timeout && (!dev_drv->frame_done.done)) {
-		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
-		return -ETIMEDOUT;
-	}
-#endif
-	return 0;
-}
-
-static int rk3368_lcdc_cal_scl_fac(struct rk_lcdc_win *win,
-				   struct rk_screen *screen)
-{
-	u16 srcW = 0;
-	u16 srcH = 0;
-	u16 dstW = 0;
-	u16 dstH = 0;
-	u16 yrgb_srcW = 0;
-	u16 yrgb_srcH = 0;
-	u16 yrgb_dstW = 0;
-	u16 yrgb_dstH = 0;
-	u32 yrgb_vscalednmult = 0;
-	u32 yrgb_xscl_factor = 0;
-	u32 yrgb_yscl_factor = 0;
-	u8 yrgb_vsd_bil_gt2 = 0;
-	u8 yrgb_vsd_bil_gt4 = 0;
-
-	u16 cbcr_srcW = 0;
-	u16 cbcr_srcH = 0;
-	u16 cbcr_dstW = 0;
-	u16 cbcr_dstH = 0;
-	u32 cbcr_vscalednmult = 0;
-	u32 cbcr_xscl_factor = 0;
-	u32 cbcr_yscl_factor = 0;
-	u8 cbcr_vsd_bil_gt2 = 0;
-	u8 cbcr_vsd_bil_gt4 = 0;
-	u8 yuv_fmt = 0;
-
-	srcW = win->area[0].xact;
-	if ((screen->mode.vmode & FB_VMODE_INTERLACED) &&
-	    (win->area[0].yact == 2 * win->area[0].ysize)) {
-		srcH = win->area[0].yact / 2;
-		yrgb_vsd_bil_gt2 = 1;
-		cbcr_vsd_bil_gt2 = 1;
-	} else {
-		srcH = win->area[0].yact;
-	}
-	dstW = win->area[0].xsize;
-	dstH = win->area[0].ysize;
-
-	/*yrgb scl mode */
-	yrgb_srcW = srcW;
-	yrgb_srcH = srcH;
-	yrgb_dstW = dstW;
-	yrgb_dstH = dstH;
-	if ((yrgb_dstW * 8 <= yrgb_srcW) || (yrgb_dstH * 8 <= yrgb_srcH)) {
-		pr_err("ERROR: yrgb scale exceed 8,");
-		pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
-		       yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH);
-	}
-	if (yrgb_srcW < yrgb_dstW)
-		win->yrgb_hor_scl_mode = SCALE_UP;
-	else if (yrgb_srcW > yrgb_dstW)
-		win->yrgb_hor_scl_mode = SCALE_DOWN;
-	else
-		win->yrgb_hor_scl_mode = SCALE_NONE;
-
-	if (yrgb_srcH < yrgb_dstH)
-		win->yrgb_ver_scl_mode = SCALE_UP;
-	else if (yrgb_srcH > yrgb_dstH)
-		win->yrgb_ver_scl_mode = SCALE_DOWN;
-	else
-		win->yrgb_ver_scl_mode = SCALE_NONE;
-
-	/*cbcr scl mode */
-	switch (win->area[0].format) {
-	case YUV422:
-	case YUV422_A:
-		cbcr_srcW = srcW / 2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV420:
-	case YUV420_A:
-	case YUV420_NV21:
-		cbcr_srcW = srcW / 2;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH / 2;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	case YUV444:
-	case YUV444_A:
-		cbcr_srcW = srcW;
-		cbcr_dstW = dstW;
-		cbcr_srcH = srcH;
-		cbcr_dstH = dstH;
-		yuv_fmt = 1;
-		break;
-	default:
-		cbcr_srcW = 0;
-		cbcr_dstW = 0;
-		cbcr_srcH = 0;
-		cbcr_dstH = 0;
-		yuv_fmt = 0;
-		break;
-	}
-	if (yuv_fmt) {
-		if ((cbcr_dstW * 8 <= cbcr_srcW) ||
-		    (cbcr_dstH * 8 <= cbcr_srcH)) {
-			pr_err("ERROR: cbcr scale exceed 8,");
-			pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n", cbcr_srcW,
-			       cbcr_srcH, cbcr_dstW, cbcr_dstH);
-		}
-	}
-
-	if (cbcr_srcW < cbcr_dstW)
-		win->cbr_hor_scl_mode = SCALE_UP;
-	else if (cbcr_srcW > cbcr_dstW)
-		win->cbr_hor_scl_mode = SCALE_DOWN;
-	else
-		win->cbr_hor_scl_mode = SCALE_NONE;
-
-	if (cbcr_srcH < cbcr_dstH)
-		win->cbr_ver_scl_mode = SCALE_UP;
-	else if (cbcr_srcH > cbcr_dstH)
-		win->cbr_ver_scl_mode = SCALE_DOWN;
-	else
-		win->cbr_ver_scl_mode = SCALE_NONE;
-
-	/*DBG(1, "srcW:%d>>srcH:%d>>dstW:%d>>dstH:%d>>\n"
-	    "yrgb:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
-	    "cbcr:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n", srcW,
-	    srcH, dstW, dstH, yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH,
-	    win->yrgb_hor_scl_mode, win->yrgb_ver_scl_mode, cbcr_srcW,
-	    cbcr_srcH, cbcr_dstW, cbcr_dstH, win->cbr_hor_scl_mode,
-	    win->cbr_ver_scl_mode);*/
-
-	/*line buffer mode */
-	if ((win->area[0].format == YUV422) ||
-	    (win->area[0].format == YUV420) ||
-	    (win->area[0].format == YUV420_NV21) ||
-	    (win->area[0].format == YUV422_A) ||
-	    (win->area[0].format == YUV420_A)) {
-		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
-			if ((cbcr_dstW > VOP_INPUT_MAX_WIDTH / 2) ||
-			    (cbcr_dstW == 0))
-				pr_err("ERROR cbcr_dstW = %d,exceeds 2048\n",
-				       cbcr_dstW);
-			else if (cbcr_dstW > 1280)
-				win->win_lb_mode = LB_YUV_3840X5;
-			else
-				win->win_lb_mode = LB_YUV_2560X8;
-		} else {	/*SCALE_UP or SCALE_NONE */
-			if ((cbcr_srcW > VOP_INPUT_MAX_WIDTH / 2) ||
-			    (cbcr_srcW == 0))
-				pr_err("ERROR cbcr_srcW = %d,exceeds 2048\n",
-				       cbcr_srcW);
-			else if (cbcr_srcW > 1280)
-				win->win_lb_mode = LB_YUV_3840X5;
-			else
-				win->win_lb_mode = LB_YUV_2560X8;
-		}
-	} else {
-		if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
-			if ((yrgb_dstW > VOP_INPUT_MAX_WIDTH) ||
-			    (yrgb_dstW == 0))
-				pr_err("ERROR yrgb_dstW = %d\n", yrgb_dstW);
-			else if (yrgb_dstW > 2560)
-				win->win_lb_mode = LB_RGB_3840X2;
-			else if (yrgb_dstW > 1920)
-				win->win_lb_mode = LB_RGB_2560X4;
-			else if (yrgb_dstW > 1280)
-				win->win_lb_mode = LB_RGB_1920X5;
-			else
-				win->win_lb_mode = LB_RGB_1280X8;
-		} else {	/*SCALE_UP or SCALE_NONE */
-			if ((yrgb_srcW > VOP_INPUT_MAX_WIDTH) ||
-			    (yrgb_srcW == 0))
-				pr_err("ERROR yrgb_srcW = %d\n", yrgb_srcW);
-			else if (yrgb_srcW > 2560)
-				win->win_lb_mode = LB_RGB_3840X2;
-			else if (yrgb_srcW > 1920)
-				win->win_lb_mode = LB_RGB_2560X4;
-			else if (yrgb_srcW > 1280)
-				win->win_lb_mode = LB_RGB_1920X5;
-			else
-				win->win_lb_mode = LB_RGB_1280X8;
-		}
-	}
-	DBG(1, "win->win_lb_mode = %d;\n", win->win_lb_mode);
-
-	/*vsd/vsu scale ALGORITHM */
-	win->yrgb_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->cbr_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->yrgb_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	win->cbr_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
-	switch (win->win_lb_mode) {
-	case LB_YUV_3840X5:
-	case LB_YUV_2560X8:
-	case LB_RGB_1920X5:
-	case LB_RGB_1280X8:
-		win->yrgb_vsu_mode = SCALE_UP_BIC;
-		win->cbr_vsu_mode = SCALE_UP_BIC;
-		break;
-	case LB_RGB_3840X2:
-		if (win->yrgb_ver_scl_mode != SCALE_NONE)
-			pr_err("ERROR : not allow yrgb ver scale\n");
-		if (win->cbr_ver_scl_mode != SCALE_NONE)
-			pr_err("ERROR : not allow cbcr ver scale\n");
-		break;
-	case LB_RGB_2560X4:
-		win->yrgb_vsu_mode = SCALE_UP_BIL;
-		win->cbr_vsu_mode = SCALE_UP_BIL;
-		break;
-	default:
-		pr_info("%s:un supported win_lb_mode:%d\n",
-			__func__, win->win_lb_mode);
-		break;
-	}
-	if (win->ymirror == 1)
-		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		/*interlace mode must bill */
-		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
-		win->cbr_vsd_mode = SCALE_DOWN_BIL;
-	}
-	if ((win->yrgb_ver_scl_mode == SCALE_DOWN) &&
-	    (win->area[0].fbdc_en == 1)) {
-		/*in this pattern,use bil mode,not support souble scd,
-		use avg mode, support double scd, but aclk should be
-		bigger than dclk,aclk>>dclk */
-		if (yrgb_srcH >= 2 * yrgb_dstH) {
-			pr_err("ERROR : fbdc mode,not support y scale down:");
-			pr_err("srcH[%d] > 2 *dstH[%d]\n",
-			       yrgb_srcH, yrgb_dstH);
-		}
-	}
-	DBG(1, "yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
-	    win->yrgb_hsd_mode, win->yrgb_vsd_mode, win->yrgb_vsu_mode,
-	    win->cbr_hsd_mode, win->cbr_vsd_mode, win->cbr_vsu_mode);
-
-	/*SCALE FACTOR */
-
-	/*(1.1)YRGB HOR SCALE FACTOR */
-	switch (win->yrgb_hor_scl_mode) {
-	case SCALE_NONE:
-		yrgb_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
-		break;
-	case SCALE_DOWN:
-		switch (win->yrgb_hsd_mode) {
-		case SCALE_DOWN_BIL:
-			yrgb_xscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
-			break;
-		case SCALE_DOWN_AVG:
-			yrgb_xscl_factor =
-			    GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
-			break;
-		default:
-			pr_info(
-				"%s:un supported yrgb_hsd_mode:%d\n", __func__,
-			       win->yrgb_hsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported yrgb_hor_scl_mode:%d\n",
-			__func__, win->yrgb_hor_scl_mode);
-		break;
-	}			/*win->yrgb_hor_scl_mode */
-
-	/*(1.2)YRGB VER SCALE FACTOR */
-	switch (win->yrgb_ver_scl_mode) {
-	case SCALE_NONE:
-		yrgb_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		switch (win->yrgb_vsu_mode) {
-		case SCALE_UP_BIL:
-			yrgb_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
-			break;
-		case SCALE_UP_BIC:
-			if (yrgb_srcH < 3) {
-				pr_err("yrgb_srcH should be");
-				pr_err(" greater than 3 !!!\n");
-			}
-			yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH,
-								yrgb_dstH);
-			break;
-		default:
-			pr_info("%s:un support yrgb_vsu_mode:%d\n",
-				__func__, win->yrgb_vsu_mode);
-			break;
-		}
-		break;
-	case SCALE_DOWN:
-		switch (win->yrgb_vsd_mode) {
-		case SCALE_DOWN_BIL:
-			yrgb_vscalednmult =
-			    rk3368_get_hard_ware_vskiplines(yrgb_srcH,
-							    yrgb_dstH);
-			yrgb_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH,
-							   yrgb_vscalednmult);
-			if (yrgb_yscl_factor >= 0x2000) {
-				pr_err("yrgb_yscl_factor should be ");
-				pr_err("less than 0x2000,yrgb_yscl_factor=%4x;\n",
-				       yrgb_yscl_factor);
-			}
-			if (yrgb_vscalednmult == 4) {
-				yrgb_vsd_bil_gt4 = 1;
-				yrgb_vsd_bil_gt2 = 0;
-			} else if (yrgb_vscalednmult == 2) {
-				yrgb_vsd_bil_gt4 = 0;
-				yrgb_vsd_bil_gt2 = 1;
-			} else {
-				yrgb_vsd_bil_gt4 = 0;
-				yrgb_vsd_bil_gt2 = 0;
-			}
-			break;
-		case SCALE_DOWN_AVG:
-			yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH,
-								 yrgb_dstH);
-			break;
-		default:
-			pr_info("%s:un support yrgb_vsd_mode:%d\n",
-				__func__, win->yrgb_vsd_mode);
-			break;
-		}		/*win->yrgb_vsd_mode */
-		break;
-	default:
-		pr_info("%s:un supported yrgb_ver_scl_mode:%d\n",
-			__func__, win->yrgb_ver_scl_mode);
-		break;
-	}
-	win->scale_yrgb_x = yrgb_xscl_factor;
-	win->scale_yrgb_y = yrgb_yscl_factor;
-	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
-	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
-	DBG(1, "yrgb:h_fac=%d, v_fac=%d,gt4=%d, gt2=%d\n", yrgb_xscl_factor,
-	    yrgb_yscl_factor, yrgb_vsd_bil_gt4, yrgb_vsd_bil_gt2);
-
-	/*(2.1)CBCR HOR SCALE FACTOR */
-	switch (win->cbr_hor_scl_mode) {
-	case SCALE_NONE:
-		cbcr_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
-		break;
-	case SCALE_DOWN:
-		switch (win->cbr_hsd_mode) {
-		case SCALE_DOWN_BIL:
-			cbcr_xscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
-			break;
-		case SCALE_DOWN_AVG:
-			cbcr_xscl_factor =
-			    GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
-			break;
-		default:
-			pr_info("%s:un support cbr_hsd_mode:%d\n",
-				__func__, win->cbr_hsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported cbr_hor_scl_mode:%d\n",
-			__func__, win->cbr_hor_scl_mode);
-		break;
-	}			/*win->cbr_hor_scl_mode */
-
-	/*(2.2)CBCR VER SCALE FACTOR */
-	switch (win->cbr_ver_scl_mode) {
-	case SCALE_NONE:
-		cbcr_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
-		break;
-	case SCALE_UP:
-		switch (win->cbr_vsu_mode) {
-		case SCALE_UP_BIL:
-			cbcr_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
-			break;
-		case SCALE_UP_BIC:
-			if (cbcr_srcH < 3) {
-				pr_err("cbcr_srcH should be ");
-				pr_err("greater than 3 !!!\n");
-			}
-			cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH,
-								cbcr_dstH);
-			break;
-		default:
-			pr_info("%s:un support cbr_vsu_mode:%d\n",
-				__func__, win->cbr_vsu_mode);
-			break;
-		}
-		break;
-	case SCALE_DOWN:
-		switch (win->cbr_vsd_mode) {
-		case SCALE_DOWN_BIL:
-			cbcr_vscalednmult =
-			    rk3368_get_hard_ware_vskiplines(cbcr_srcH,
-							    cbcr_dstH);
-			cbcr_yscl_factor =
-			    GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH,
-							   cbcr_vscalednmult);
-			if (cbcr_yscl_factor >= 0x2000) {
-				pr_err("cbcr_yscl_factor should be less ");
-				pr_err("than 0x2000,cbcr_yscl_factor=%4x;\n",
-				       cbcr_yscl_factor);
-			}
-
-			if (cbcr_vscalednmult == 4) {
-				cbcr_vsd_bil_gt4 = 1;
-				cbcr_vsd_bil_gt2 = 0;
-			} else if (cbcr_vscalednmult == 2) {
-				cbcr_vsd_bil_gt4 = 0;
-				cbcr_vsd_bil_gt2 = 1;
-			} else {
-				cbcr_vsd_bil_gt4 = 0;
-				cbcr_vsd_bil_gt2 = 0;
-			}
-			break;
-		case SCALE_DOWN_AVG:
-			cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH,
-								 cbcr_dstH);
-			break;
-		default:
-			pr_info("%s:un support cbr_vsd_mode:%d\n",
-				__func__, win->cbr_vsd_mode);
-			break;
-		}
-		break;
-	default:
-		pr_info("%s:un supported cbr_ver_scl_mode:%d\n",
-			__func__, win->cbr_ver_scl_mode);
-		break;
-	}
-	win->scale_cbcr_x = cbcr_xscl_factor;
-	win->scale_cbcr_y = cbcr_yscl_factor;
-	win->vsd_cbr_gt4 = cbcr_vsd_bil_gt4;
-	win->vsd_cbr_gt2 = cbcr_vsd_bil_gt2;
-
-	DBG(1, "cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n", cbcr_xscl_factor,
-	    cbcr_yscl_factor, cbcr_vsd_bil_gt4, cbcr_vsd_bil_gt2);
-	return 0;
-}
-
-static int dsp_x_pos(int mirror_en, struct rk_screen *screen,
-		     struct rk_lcdc_win_area *area)
-{
-	int pos;
-
-	if (screen->x_mirror && mirror_en)
-		pr_err("not support both win and global mirror\n");
-
-	if ((!mirror_en) && (!screen->x_mirror))
-		pos = area->xpos + screen->mode.left_margin +
-			screen->mode.hsync_len;
-	else
-		pos = screen->mode.xres - area->xpos -
-			area->xsize + screen->mode.left_margin +
-			screen->mode.hsync_len;
-
-	return pos;
-}
-
-static int dsp_y_pos(int mirror_en, struct rk_screen *screen,
-		     struct rk_lcdc_win_area *area)
-{
-	int pos;
-
-	if (screen->y_mirror && mirror_en)
-		pr_err("not support both win and global mirror\n");
-	if (!(screen->mode.vmode & FB_VMODE_INTERLACED)) {
-		if ((!mirror_en) && (!screen->y_mirror))
-			pos = area->ypos + screen->mode.upper_margin +
-				screen->mode.vsync_len;
-		else
-			pos = screen->mode.yres - area->ypos -
-				area->ysize + screen->mode.upper_margin +
-				screen->mode.vsync_len;
-	} else {
-		pos = area->ypos / 2 + screen->mode.upper_margin +
-			screen->mode.vsync_len;
-		area->ysize /= 2;
-	}
-
-	return pos;
-}
-
-static int win_0_1_set_par(struct lcdc_device *lcdc_dev,
-			   struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
-	u8 fmt_cfg = 0, swap_rb = 0, swap_uv = 0;
-	char fmt[9] = "NULL";
-
-	xpos = dsp_x_pos(win->xmirror, screen, &win->area[0]);
-	ypos = dsp_y_pos(win->ymirror, screen, &win->area[0]);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		rk3368_lcdc_cal_scl_fac(win, screen);	/*fac,lb,gt2,gt4 */
-		switch (win->area[0].format) {
-		case FBDC_RGB_565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = 0x05;
-			break;
-		case FBDC_ARGB_888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = 0x0c;
-			break;
-		case FBDC_ABGR_888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = 0x0c;
-			break;
-		case FBDC_RGBX_888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			win->area[0].fbdc_fmt_cfg = 0x3a;
-			break;
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case BGR888:
-			fmt_cfg = 1;
-			swap_rb = 1;
-			win->fmt_10 = 0;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV420_NV21:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			swap_uv = 1;
-			win->fmt_10 = 0;
-			break;
-		case YUV444:
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 0;
-			break;
-		case YUV422_A:
-			fmt_cfg = 5;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV420_A:
-			fmt_cfg = 4;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		case YUV444_A:
-			fmt_cfg = 6;
-			swap_rb = 0;
-			win->fmt_10 = 1;
-			break;
-		default:
-			dev_err(lcdc_dev->driver.dev, "%s:unsupport format!\n",
-				__func__);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].swap_uv = swap_uv;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	if (win->area[0].fbdc_en)
-		rk3368_init_fbdc_config(&lcdc_dev->driver, win->id);
-	rk3368_win_0_1_reg_update(&lcdc_dev->driver, win->id);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
-	    lcdc_dev->id, win->id, get_format_string(win->area[0].format, fmt),
-	    xact, yact, win->area[0].xsize);
-	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-	    win->area[0].ysize, xvir, yvir, xpos, ypos);
-
-	return 0;
-}
-
-
-static int win_2_3_set_par(struct lcdc_device *lcdc_dev,
-			   struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	int i;
-	u8 fmt_cfg = 0, swap_rb = 0;
-	char fmt[9] = "NULL";
-
-	if (win->ymirror)
-		pr_err("win[%d] not support y mirror\n", win->id);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		DBG(2, "lcdc[%d]:win[%d]>>\n>\n", lcdc_dev->id, win->id);
-		for (i = 0; i < win->area_num; i++) {
-			switch (win->area[i].format) {
-			case FBDC_RGB_565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = 0x05;
-				break;
-			case FBDC_ARGB_888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = 0x0c;
-				break;
-			case FBDC_ABGR_888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = 0x0c;
-				break;
-			case FBDC_RGBX_888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				win->fmt_10 = 0;
-				win->area[0].fbdc_fmt_cfg = 0x3a;
-				break;
-			case ARGB888:
-				fmt_cfg = 0;
-				swap_rb = 0;
-				break;
-			case XBGR888:
-			case ABGR888:
-				fmt_cfg = 0;
-				swap_rb = 1;
-				break;
-			case RGB888:
-				fmt_cfg = 1;
-				swap_rb = 0;
-				break;
-			case RGB565:
-				fmt_cfg = 2;
-				swap_rb = 0;
-				break;
-			default:
-				dev_err(lcdc_dev->driver.dev,
-					"%s:un supported format!\n", __func__);
-				break;
-			}
-			win->area[i].fmt_cfg = fmt_cfg;
-			win->area[i].swap_rb = swap_rb;
-			win->area[i].dsp_stx =
-					dsp_x_pos(win->xmirror, screen,
-						  &win->area[i]);
-			win->area[i].dsp_sty =
-					dsp_y_pos(win->ymirror, screen,
-						  &win->area[i]);
-			if (((win->area[i].xact != win->area[i].xsize) ||
-			     (win->area[i].yact != win->area[i].ysize)) &&
-			     !(screen->mode.vmode & FB_VMODE_INTERLACED)) {
-				pr_err("win[%d]->area[%d],not support scale\n",
-				       win->id, i);
-				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
-				       win->area[i].xact, win->area[i].yact,
-				       win->area[i].xsize, win->area[i].ysize);
-				win->area[i].xsize = win->area[i].xact;
-				win->area[i].ysize = win->area[i].yact;
-			}
-			DBG(2, "fmt:%s:xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d\n",
-			    get_format_string(win->area[i].format, fmt),
-			    win->area[i].xsize, win->area[i].ysize,
-			    win->area[i].xpos, win->area[i].ypos);
-		}
-	}
-	if (win->area[0].fbdc_en)
-		rk3368_init_fbdc_config(&lcdc_dev->driver, win->id);
-	rk3368_win_2_3_reg_update(&lcdc_dev->driver, win->id);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int hwc_set_par(struct lcdc_device *lcdc_dev,
-		       struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
-	u8 fmt_cfg = 0, swap_rb = 0;
-	char fmt[9] = "NULL";
-
-	xpos = win->area[0].xpos + screen->mode.left_margin +
-	    screen->mode.hsync_len;
-	ypos = win->area[0].ypos + screen->mode.upper_margin +
-	    screen->mode.vsync_len;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		/*rk3368_lcdc_cal_scl_fac(win); *//*fac,lb,gt2,gt4 */
-		switch (win->area[0].format) {
-		case ARGB888:
-			fmt_cfg = 0;
-			swap_rb = 0;
-			break;
-		case XBGR888:
-		case ABGR888:
-			fmt_cfg = 0;
-			swap_rb = 1;
-			break;
-		case RGB888:
-			fmt_cfg = 1;
-			swap_rb = 0;
-			break;
-		case RGB565:
-			fmt_cfg = 2;
-			swap_rb = 0;
-			break;
-		default:
-			dev_err(lcdc_dev->driver.dev,
-				"%s:un supported format!\n", __func__);
-			break;
-		}
-		win->area[0].fmt_cfg = fmt_cfg;
-		win->area[0].swap_rb = swap_rb;
-		win->area[0].dsp_stx = xpos;
-		win->area[0].dsp_sty = ypos;
-		xact = win->area[0].xact;
-		yact = win->area[0].yact;
-		xvir = win->area[0].xvir;
-		yvir = win->area[0].yvir;
-	}
-	rk3368_hwc_reg_update(&lcdc_dev->driver, 4);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	DBG(1, "lcdc[%d]:hwc>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
-	    lcdc_dev->id, __func__, get_format_string(win->area[0].format, fmt),
-	    xact, yact, win->area[0].xsize);
-	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-	    win->area[0].ysize, xvir, yvir, xpos, ypos);
-	return 0;
-}
-
-static int rk3368_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	win = dev_drv->win[win_id];
-	switch (win_id) {
-	case 0:
-		win_0_1_set_par(lcdc_dev, screen, win);
-		break;
-	case 1:
-		win_0_1_set_par(lcdc_dev, screen, win);
-		break;
-	case 2:
-		win_2_3_set_par(lcdc_dev, screen, win);
-		break;
-	case 3:
-		win_2_3_set_par(lcdc_dev, screen, win);
-		break;
-	case 4:
-		hwc_set_par(lcdc_dev, screen, win);
-		break;
-	default:
-		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
-		break;
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-			     unsigned long arg, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = lcdc_dev->screen->mode.xres;
-		panel_size[1] = lcdc_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		rk3368_lcdc_clr_key_cfg(dev_drv);
-		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
-			    clr_key_cfg.win0_color_key_cfg);
-		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
-			    clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_get_backlight_device(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev = container_of(dev_drv,
-						    struct lcdc_device, driver);
-	struct device_node *backlight;
-	struct property *prop;
-	u32 brightness_levels[256];
-	u32 length, max, last;
-
-	if (lcdc_dev->backlight)
-		return 0;
-	backlight = of_parse_phandle(lcdc_dev->dev->of_node, "backlight", 0);
-	if (backlight) {
-		lcdc_dev->backlight = of_find_backlight_by_node(backlight);
-		if (!lcdc_dev->backlight)
-			dev_info(lcdc_dev->dev, "No find backlight device\n");
-	} else {
-		dev_info(lcdc_dev->dev, "No find backlight device node\n");
-	}
-	prop = of_find_property(backlight, "brightness-levels", &length);
-	if (!prop)
-		return -EINVAL;
-	max = length / sizeof(u32);
-	last = max - 1;
-	if (!of_property_read_u32_array(backlight, "brightness-levels",
-					brightness_levels, max)) {
-		if (brightness_levels[0] > brightness_levels[last])
-			dev_drv->cabc_pwm_pol = 1;/*negative*/
-		else
-			dev_drv->cabc_pwm_pol = 0;/*positive*/
-	} else {
-		dev_info(lcdc_dev->dev, "Can not read brightness-levels value\n");
-	}
-	return 0;
-}
-
-static int rk3368_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 intr_clr_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		intr_clr_reg = INTR_CLEAR_RK3366;
-	else
-		intr_clr_reg = INTR_CLEAR_RK3368;
-
-	if (dev_drv->suspend_flag)
-		return 0;
-	/* close the backlight */
-	/*rk3368_lcdc_get_backlight_device(dev_drv);
-	if (lcdc_dev->backlight) {
-		lcdc_dev->backlight->props.fb_blank = FB_BLANK_POWERDOWN;
-		backlight_update_status(lcdc_dev->backlight);
-	}*/
-
-	dev_drv->suspend_flag = 1;
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (likely(lcdc_dev->clk_on)) {
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
-			     v_DSP_BLANK_EN(1));
-		lcdc_msk_reg(lcdc_dev,
-			     intr_clr_reg, m_FS_INTR_CLR | m_LINE_FLAG0_INTR_CLR,
-			     v_FS_INTR_CLR(1) | v_LINE_FLAG0_INTR_CLR(1));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(1));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(1));
-		lcdc_cfg_done(lcdc_dev);
-
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	rk3368_lcdc_clk_disable(lcdc_dev);
-	rk_disp_pwr_disable(dev_drv);
-	return 0;
-}
-
-static int rk3368_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-	rk_disp_pwr_enable(dev_drv);
-
-	if (1/*lcdc_dev->atv_layer_cnt*/) {
-		rk3368_lcdc_clk_enable(lcdc_dev);
-		rk3368_lcdc_reg_restore(lcdc_dev);
-
-		spin_lock(&lcdc_dev->reg_lock);
-		if (dev_drv->cur_screen->dsp_lut)
-			rk3368_lcdc_set_lut(dev_drv,
-					    dev_drv->cur_screen->dsp_lut);
-		if (dev_drv->cur_screen->cabc_lut && dev_drv->cabc_mode)
-			rk3368_set_cabc_lut(dev_drv,
-					    dev_drv->cur_screen->cabc_lut);
-
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
-			     v_DSP_OUT_ZERO(0));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(0));
-		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
-			     v_DSP_BLANK_EN(0));
-		lcdc_cfg_done(lcdc_dev);
-
-		if (dev_drv->iommu_enabled) {
-			/* win address maybe effect after next frame start,
-			 * but mmu maybe effect right now, so we delay 50ms
-			 */
-			mdelay(50);
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_activate(dev_drv->dev);
-		}
-
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	dev_drv->suspend_flag = 0;
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-	mdelay(100);
-	return 0;
-}
-
-static int rk3368_lcdc_blank(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		rk3368_lcdc_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		rk3368_lcdc_early_suspend(dev_drv);
-		break;
-	default:
-		rk3368_lcdc_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int rk3368_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
-				     int win_id, int area_id)
-{
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-	u32 win_ctrl = 0;
-	u32 area_status = 0, state = 0;
-
-	switch (win_id) {
-	case 0:
-		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-		area_status = win_ctrl & m_WIN0_EN;
-		break;
-	case 1:
-		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
-		area_status = win_ctrl & m_WIN1_EN;
-		break;
-	case 2:
-		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
-		if (area_id == 0)
-			area_status = win_ctrl & (m_WIN2_MST0_EN | m_WIN2_EN);
-		if (area_id == 1)
-			area_status = win_ctrl & m_WIN2_MST1_EN;
-		if (area_id == 2)
-			area_status = win_ctrl & m_WIN2_MST2_EN;
-		if (area_id == 3)
-			area_status = win_ctrl & m_WIN2_MST3_EN;
-		break;
-	case 3:
-		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
-		if (area_id == 0)
-			area_status = win_ctrl & (m_WIN3_MST0_EN | m_WIN3_EN);
-		if (area_id == 1)
-			area_status = win_ctrl & m_WIN3_MST1_EN;
-		if (area_id == 2)
-			area_status = win_ctrl & m_WIN3_MST2_EN;
-		if (area_id == 3)
-			area_status = win_ctrl & m_WIN3_MST3_EN;
-		break;
-	case 4:
-		win_ctrl = lcdc_readl(lcdc_dev, HWC_CTRL0);
-		area_status = win_ctrl & m_HWC_EN;
-		break;
-	default:
-		pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",
-		       __func__, win_id, area_id);
-		break;
-	}
-
-	state = (area_status > 0) ? 1 : 0;
-	return state;
-}
-
-static int rk3368_lcdc_get_area_num(struct rk_lcdc_driver *dev_drv,
-				    unsigned int *area_support)
-{
-	area_support[0] = 1;
-	area_support[1] = 1;
-	area_support[2] = 4;
-	area_support[3] = 4;
-
-	return 0;
-}
-
-/*overlay will be do at regupdate*/
-static int rk3368_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_lcdc_win *win = NULL;
-	int i, ovl = 0;
-	unsigned int mask, val;
-	int z_order_num = 0;
-	int layer0_sel = 0, layer1_sel = 1, layer2_sel = 2, layer3_sel = 3;
-
-	if (swap == 0) {
-		for (i = 0; i < 4; i++) {
-			win = dev_drv->win[i];
-			if (win->state == 1)
-				z_order_num++;
-		}
-		for (i = 0; i < 4; i++) {
-			win = dev_drv->win[i];
-			if (win->state == 0)
-				win->z_order = z_order_num++;
-			switch (win->z_order) {
-			case 0:
-				layer0_sel = win->id;
-				break;
-			case 1:
-				layer1_sel = win->id;
-				break;
-			case 2:
-				layer2_sel = win->id;
-				break;
-			case 3:
-				layer3_sel = win->id;
-				break;
-			default:
-				break;
-			}
-		}
-	} else {
-		layer0_sel = swap % 10;
-		layer1_sel = swap / 10 % 10;
-		layer2_sel = swap / 100 % 10;
-		layer3_sel = swap / 1000;
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (set) {
-			mask = m_DSP_LAYER0_SEL | m_DSP_LAYER1_SEL |
-			    m_DSP_LAYER2_SEL | m_DSP_LAYER3_SEL;
-			val = v_DSP_LAYER0_SEL(layer0_sel) |
-			    v_DSP_LAYER1_SEL(layer1_sel) |
-			    v_DSP_LAYER2_SEL(layer2_sel) |
-			    v_DSP_LAYER3_SEL(layer3_sel);
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
-		} else {
-			layer0_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
-						   m_DSP_LAYER0_SEL);
-			layer1_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
-						   m_DSP_LAYER1_SEL);
-			layer2_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
-						   m_DSP_LAYER2_SEL);
-			layer3_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
-						   m_DSP_LAYER3_SEL);
-			ovl = layer3_sel * 1000 + layer2_sel * 100 +
-			    layer1_sel * 10 + layer0_sel;
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-
-static char *rk3368_lcdc_format_to_string(int format, char *fmt)
-{
-	if (!fmt)
-		return NULL;
-
-	switch (format) {
-	case 0:
-		strcpy(fmt, "ARGB888");
-		break;
-	case 1:
-		strcpy(fmt, "RGB888");
-		break;
-	case 2:
-		strcpy(fmt, "RGB565");
-		break;
-	case 4:
-		strcpy(fmt, "YCbCr420");
-		break;
-	case 5:
-		strcpy(fmt, "YCbCr422");
-		break;
-	case 6:
-		strcpy(fmt, "YCbCr444");
-		break;
-	default:
-		strcpy(fmt, "invalid\n");
-		break;
-	}
-	return fmt;
-}
-static ssize_t rk3368_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
-					 char *buf, int win_id)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u32 h_pw_bp = hsync_len + left_margin;
-	u32 v_pw_bp = vsync_len + upper_margin;
-	u32 fmt_id;
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char format_w2_0[9] = "NULL";
-	char format_w2_1[9] = "NULL";
-	char format_w2_2[9] = "NULL";
-	char format_w2_3[9] = "NULL";
-	char format_w3_0[9] = "NULL";
-	char format_w3_1[9] = "NULL";
-	char format_w3_2[9] = "NULL";
-	char format_w3_3[9] = "NULL";
-	char dsp_buf[100];
-	u32 win_ctrl, zorder, vir_info, act_info, dsp_info, dsp_st;
-	u32 y_factor, uv_factor;
-	u8 layer0_sel, layer1_sel, layer2_sel, layer3_sel;
-	u8 w0_state, w1_state, w2_state, w3_state;
-	u8 w2_0_state, w2_1_state, w2_2_state, w2_3_state;
-	u8 w3_0_state, w3_1_state, w3_2_state, w3_3_state;
-
-	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
-	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
-	u32 w1_vir_y, w1_vir_uv, w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y;
-	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
-	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
-	u32 w1_y_h_fac, w1_y_v_fac, w1_uv_h_fac, w1_uv_v_fac;
-
-	u32 w2_0_vir_y, w2_1_vir_y, w2_2_vir_y, w2_3_vir_y;
-	u32 w2_0_dsp_x, w2_1_dsp_x, w2_2_dsp_x, w2_3_dsp_x;
-	u32 w2_0_dsp_y, w2_1_dsp_y, w2_2_dsp_y, w2_3_dsp_y;
-	u32 w2_0_st_x = h_pw_bp, w2_1_st_x = h_pw_bp;
-	u32 w2_2_st_x = h_pw_bp, w2_3_st_x = h_pw_bp;
-	u32 w2_0_st_y = v_pw_bp, w2_1_st_y = v_pw_bp;
-	u32 w2_2_st_y = v_pw_bp, w2_3_st_y = v_pw_bp;
-
-	u32 w3_0_vir_y, w3_1_vir_y, w3_2_vir_y, w3_3_vir_y;
-	u32 w3_0_dsp_x, w3_1_dsp_x, w3_2_dsp_x, w3_3_dsp_x;
-	u32 w3_0_dsp_y, w3_1_dsp_y, w3_2_dsp_y, w3_3_dsp_y;
-	u32 w3_0_st_x = h_pw_bp, w3_1_st_x = h_pw_bp;
-	u32 w3_2_st_x = h_pw_bp, w3_3_st_x = h_pw_bp;
-	u32 w3_0_st_y = v_pw_bp, w3_1_st_y = v_pw_bp;
-	u32 w3_2_st_y = v_pw_bp, w3_3_st_y = v_pw_bp;
-	u32 dclk_freq;
-	int size = 0;
-
-	dclk_freq = screen->mode.pixclock;
-	/*rk3368_lcdc_reg_dump(dev_drv); */
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		zorder = lcdc_readl(lcdc_dev, DSP_CTRL1);
-		layer0_sel = (zorder & m_DSP_LAYER0_SEL) >> 8;
-		layer1_sel = (zorder & m_DSP_LAYER1_SEL) >> 10;
-		layer2_sel = (zorder & m_DSP_LAYER2_SEL) >> 12;
-		layer3_sel = (zorder & m_DSP_LAYER3_SEL) >> 14;
-		/*WIN0 */
-		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
-		w0_state = win_ctrl & m_WIN0_EN;
-		fmt_id = (win_ctrl & m_WIN0_DATA_FMT) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w0);
-		vir_info = lcdc_readl(lcdc_dev, WIN0_VIR);
-		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
-		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
-		y_factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
-		uv_factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_CBR);
-		w0_vir_y = vir_info & m_WIN0_VIR_STRIDE;
-		w0_vir_uv = (vir_info & m_WIN0_VIR_STRIDE_UV) >> 16;
-		w0_act_x = (act_info & m_WIN0_ACT_WIDTH) + 1;
-		w0_act_y = ((act_info & m_WIN0_ACT_HEIGHT) >> 16) + 1;
-		w0_dsp_x = (dsp_info & m_WIN0_DSP_WIDTH) + 1;
-		w0_dsp_y = ((dsp_info & m_WIN0_DSP_HEIGHT) >> 16) + 1;
-		if (w0_state) {
-			w0_st_x = dsp_st & m_WIN0_DSP_XST;
-			w0_st_y = (dsp_st & m_WIN0_DSP_YST) >> 16;
-		}
-		w0_y_h_fac = y_factor & m_WIN0_HS_FACTOR_YRGB;
-		w0_y_v_fac = (y_factor & m_WIN0_VS_FACTOR_YRGB) >> 16;
-		w0_uv_h_fac = uv_factor & m_WIN0_HS_FACTOR_CBR;
-		w0_uv_v_fac = (uv_factor & m_WIN0_VS_FACTOR_CBR) >> 16;
-
-		/*WIN1 */
-		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
-		w1_state = win_ctrl & m_WIN1_EN;
-		fmt_id = (win_ctrl & m_WIN1_DATA_FMT) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w1);
-		vir_info = lcdc_readl(lcdc_dev, WIN1_VIR);
-		act_info = lcdc_readl(lcdc_dev, WIN1_ACT_INFO);
-		dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
-		dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
-		y_factor = lcdc_readl(lcdc_dev, WIN1_SCL_FACTOR_YRGB);
-		uv_factor = lcdc_readl(lcdc_dev, WIN1_SCL_FACTOR_CBR);
-		w1_vir_y = vir_info & m_WIN1_VIR_STRIDE;
-		w1_vir_uv = (vir_info & m_WIN1_VIR_STRIDE_UV) >> 16;
-		w1_act_x = (act_info & m_WIN1_ACT_WIDTH) + 1;
-		w1_act_y = ((act_info & m_WIN1_ACT_HEIGHT) >> 16) + 1;
-		w1_dsp_x = (dsp_info & m_WIN1_DSP_WIDTH) + 1;
-		w1_dsp_y = ((dsp_info & m_WIN1_DSP_HEIGHT) >> 16) + 1;
-		if (w1_state) {
-			w1_st_x = dsp_st & m_WIN1_DSP_XST;
-			w1_st_y = (dsp_st & m_WIN1_DSP_YST) >> 16;
-		}
-		w1_y_h_fac = y_factor & m_WIN1_HS_FACTOR_YRGB;
-		w1_y_v_fac = (y_factor & m_WIN1_VS_FACTOR_YRGB) >> 16;
-		w1_uv_h_fac = uv_factor & m_WIN1_HS_FACTOR_CBR;
-		w1_uv_v_fac = (uv_factor & m_WIN1_VS_FACTOR_CBR) >> 16;
-		/*WIN2 */
-		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
-		w2_state = win_ctrl & m_WIN2_EN;
-		w2_0_state = (win_ctrl & 0x10) >> 4;
-		w2_1_state = (win_ctrl & 0x100) >> 8;
-		w2_2_state = (win_ctrl & 0x1000) >> 12;
-		w2_3_state = (win_ctrl & 0x10000) >> 16;
-		vir_info = lcdc_readl(lcdc_dev, WIN2_VIR0_1);
-		w2_0_vir_y = vir_info & m_WIN2_VIR_STRIDE0;
-		w2_1_vir_y = (vir_info & m_WIN2_VIR_STRIDE1) >> 16;
-		vir_info = lcdc_readl(lcdc_dev, WIN2_VIR2_3);
-		w2_2_vir_y = vir_info & m_WIN2_VIR_STRIDE2;
-		w2_3_vir_y = (vir_info & m_WIN2_VIR_STRIDE3) >> 16;
-
-		fmt_id = (win_ctrl & m_WIN2_DATA_FMT0) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w2_0);
-		fmt_id = (win_ctrl & m_WIN2_DATA_FMT1) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w2_1);
-		fmt_id = (win_ctrl & m_WIN2_DATA_FMT2) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w2_2);
-		fmt_id = (win_ctrl & m_WIN2_DATA_FMT3) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w2_3);
-
-		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO0);
-		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST0);
-		w2_0_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH0) + 1;
-		w2_0_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT0) >> 16) + 1;
-		if (w2_0_state) {
-			w2_0_st_x = dsp_st & m_WIN2_DSP_XST0;
-			w2_0_st_y = (dsp_st & m_WIN2_DSP_YST0) >> 16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO1);
-		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST1);
-		w2_1_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH1) + 1;
-		w2_1_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT1) >> 16) + 1;
-		if (w2_1_state) {
-			w2_1_st_x = dsp_st & m_WIN2_DSP_XST1;
-			w2_1_st_y = (dsp_st & m_WIN2_DSP_YST1) >> 16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO2);
-		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST2);
-		w2_2_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH2) + 1;
-		w2_2_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT2) >> 16) + 1;
-		if (w2_2_state) {
-			w2_2_st_x = dsp_st & m_WIN2_DSP_XST2;
-			w2_2_st_y = (dsp_st & m_WIN2_DSP_YST2) >> 16;
-		}
-		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO3);
-		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST3);
-		w2_3_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH3) + 1;
-		w2_3_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT3) >> 16) + 1;
-		if (w2_3_state) {
-			w2_3_st_x = dsp_st & m_WIN2_DSP_XST3;
-			w2_3_st_y = (dsp_st & m_WIN2_DSP_YST3) >> 16;
-		}
-
-		/*WIN3 */
-		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
-		w3_state = win_ctrl & m_WIN3_EN;
-		w3_0_state = (win_ctrl & m_WIN3_MST0_EN) >> 4;
-		w3_1_state = (win_ctrl & m_WIN3_MST1_EN) >> 8;
-		w3_2_state = (win_ctrl & m_WIN3_MST2_EN) >> 12;
-		w3_3_state = (win_ctrl & m_WIN3_MST3_EN) >> 16;
-		vir_info = lcdc_readl(lcdc_dev, WIN3_VIR0_1);
-		w3_0_vir_y = vir_info & m_WIN3_VIR_STRIDE0;
-		w3_1_vir_y = (vir_info & m_WIN3_VIR_STRIDE1) >> 16;
-		vir_info = lcdc_readl(lcdc_dev, WIN3_VIR2_3);
-		w3_2_vir_y = vir_info & m_WIN3_VIR_STRIDE2;
-		w3_3_vir_y = (vir_info & m_WIN3_VIR_STRIDE3) >> 16;
-		fmt_id = (win_ctrl & m_WIN3_DATA_FMT0) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w3_0);
-		fmt_id = (win_ctrl & m_WIN3_DATA_FMT1) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w3_1);
-		fmt_id = (win_ctrl & m_WIN3_DATA_FMT2) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w3_2);
-		fmt_id = (win_ctrl & m_WIN3_DATA_FMT3) >> 1;
-		rk3368_lcdc_format_to_string(fmt_id, format_w3_3);
-		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO0);
-		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST0);
-		w3_0_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH0) + 1;
-		w3_0_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT0) >> 16) + 1;
-		if (w3_0_state) {
-			w3_0_st_x = dsp_st & m_WIN3_DSP_XST0;
-			w3_0_st_y = (dsp_st & m_WIN3_DSP_YST0) >> 16;
-		}
-
-		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO1);
-		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST1);
-		w3_1_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH1) + 1;
-		w3_1_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT1) >> 16) + 1;
-		if (w3_1_state) {
-			w3_1_st_x = dsp_st & m_WIN3_DSP_XST1;
-			w3_1_st_y = (dsp_st & m_WIN3_DSP_YST1) >> 16;
-		}
-
-		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO2);
-		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST2);
-		w3_2_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH2) + 1;
-		w3_2_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT2) >> 16) + 1;
-		if (w3_2_state) {
-			w3_2_st_x = dsp_st & m_WIN3_DSP_XST2;
-			w3_2_st_y = (dsp_st & m_WIN3_DSP_YST2) >> 16;
-		}
-
-		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO3);
-		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST3);
-		w3_3_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH3) + 1;
-		w3_3_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT3) >> 16) + 1;
-		if (w3_3_state) {
-			w3_3_st_x = dsp_st & m_WIN3_DSP_XST3;
-			w3_3_st_y = (dsp_st & m_WIN3_DSP_YST3) >> 16;
-		}
-
-	} else {
-		spin_unlock(&lcdc_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	size += snprintf(dsp_buf, 80,
-		"z-order:\n  win[%d]\n  win[%d]\n  win[%d]\n  win[%d]\n",
-		layer3_sel, layer2_sel, layer1_sel, layer0_sel);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/*win0*/
-	size += snprintf(dsp_buf, 80,
-		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
-		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
-		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
-		 w0_st_x-h_pw_bp, w0_st_y-v_pw_bp, w0_y_h_fac, w0_y_v_fac);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
-		 w0_uv_h_fac, w0_uv_v_fac, lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
-		 lcdc_readl(lcdc_dev, WIN0_CBR_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*win1*/
-	size += snprintf(dsp_buf, 80,
-		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
-		 w1_state, format_w1, w1_vir_y, w1_vir_uv);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
-		 w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
-		 w1_st_x-h_pw_bp, w1_st_y-v_pw_bp, w1_y_h_fac, w1_y_v_fac);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
-		 w1_uv_h_fac, w1_uv_v_fac, lcdc_readl(lcdc_dev, WIN1_YRGB_MST),
-		 lcdc_readl(lcdc_dev, WIN1_CBR_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*win2*/
-	size += snprintf(dsp_buf, 80,
-		 "win2:\n  state:%d\n",
-		 w2_state);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/*area 0*/
-	size += snprintf(dsp_buf, 80,
-		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_0_state, format_w2_0, w2_0_dsp_x, w2_0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_0_st_x - h_pw_bp, w2_0_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN2_MST0));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 1*/
-	size += snprintf(dsp_buf, 80,
-		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_1_state, format_w2_1, w2_1_dsp_x, w2_1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_1_st_x - h_pw_bp, w2_1_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN2_MST1));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 2*/
-	size += snprintf(dsp_buf, 80,
-		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_2_state, format_w2_2, w2_2_dsp_x, w2_2_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_2_st_x - h_pw_bp, w2_2_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN2_MST2));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 3*/
-	size += snprintf(dsp_buf, 80,
-		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w2_3_state, format_w2_3, w2_3_dsp_x, w2_3_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w2_3_st_x - h_pw_bp, w2_3_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN2_MST3));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*win3*/
-	size += snprintf(dsp_buf, 80,
-		 "win3:\n  state:%d\n",
-		 w3_state);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	/*area 0*/
-	size += snprintf(dsp_buf, 80,
-		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_0_state, format_w3_0, w3_0_dsp_x, w3_0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_0_st_x - h_pw_bp, w3_0_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN3_MST0));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 1*/
-	size += snprintf(dsp_buf, 80,
-		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_1_state, format_w3_1, w3_1_dsp_x, w3_1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_1_st_x - h_pw_bp, w3_1_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN3_MST1));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 2*/
-	size += snprintf(dsp_buf, 80,
-		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_2_state, format_w3_2, w3_2_dsp_x, w3_2_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_2_st_x - h_pw_bp, w3_2_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN3_MST2));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/*area 3*/
-	size += snprintf(dsp_buf, 80,
-		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
-		 w3_3_state, format_w3_3, w3_3_dsp_x, w3_3_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-	size += snprintf(dsp_buf, 80,
-		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
-		 w3_3_st_x - h_pw_bp, w3_3_st_y - v_pw_bp,
-		 lcdc_readl(lcdc_dev, WIN3_MST3));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	return size;
-}
-
-static int rk3368_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
-			       bool set)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-
-	if (set) {
-		if (fps == 0) {
-			dev_info(dev_drv->dev, "unsupport set fps=0\n");
-			return 0;
-		}
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	lcdc_dev->pixclock = pixclock;
-	dev_drv->pixclock = lcdc_dev->pixclock;
-	fps = rk_fb_calc_fps(screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(lcdc_dev->dclk), fps);
-
-	return fps;
-}
-
-static int rk3368_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
-	dev_drv->fb4_win_id = order / 10000;
-	dev_drv->fb3_win_id = (order / 1000) % 10;
-	dev_drv->fb2_win_id = (order / 100) % 10;
-	dev_drv->fb1_win_id = (order / 10) % 10;
-	dev_drv->fb0_win_id = order % 10;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int rk3368_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
-				  const char *id)
-{
-	int win_id = 0;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
-		win_id = dev_drv->fb2_win_id;
-	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
-		win_id = dev_drv->fb3_win_id;
-	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
-		win_id = dev_drv->fb4_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int rk3368_lcdc_config_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	int i;
-	unsigned int mask, val, fbdc_en = 0;
-	struct rk_lcdc_win *win = NULL;
-	u32 line_scane_num, dsp_vs_st_f1;
-
-	if (lcdc_dev->driver.cur_screen->mode.vmode & FB_VMODE_INTERLACED) {
-		dsp_vs_st_f1 = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) >> 16;
-		for (i = 0; i < 1000; i++) {
-			line_scane_num =
-				lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
-			if (line_scane_num > dsp_vs_st_f1 + 1)
-				udelay(50);
-			else
-				break;
-		}
-	}
-
-	spin_lock(&lcdc_dev->reg_lock);
-	rk3368_lcdc_post_cfg(dev_drv);
-	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
-		     v_STANDBY_EN(lcdc_dev->standby));
-	for (i = 0; i < 4; i++) {
-		win = dev_drv->win[i];
-		fbdc_en |= win->area[0].fbdc_en;
-		if ((win->state == 0) && (win->last_state == 1)) {
-			switch (win->id) {
-			case 0:
-				/*lcdc_writel(lcdc_dev,WIN0_CTRL1,0x0);
-				   for rk3288 to fix hw bug? */
-				mask = m_WIN0_EN;
-				val = v_WIN0_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
-				break;
-			case 1:
-				/*lcdc_writel(lcdc_dev,WIN1_CTRL1,0x0);
-				   for rk3288 to fix hw bug? */
-				mask = m_WIN1_EN;
-				val = v_WIN1_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
-				break;
-			case 2:
-				mask = m_WIN2_EN | m_WIN2_MST0_EN |
-				    m_WIN2_MST1_EN |
-				    m_WIN2_MST2_EN | m_WIN2_MST3_EN;
-				val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
-				    v_WIN2_MST1_EN(0) |
-				    v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
-				break;
-			case 3:
-				mask = m_WIN3_EN | m_WIN3_MST0_EN |
-				    m_WIN3_MST1_EN |
-				    m_WIN3_MST2_EN | m_WIN3_MST3_EN;
-				val = v_WIN3_EN(0) | v_WIN3_MST0_EN(0) |
-				    v_WIN3_MST1_EN(0) |
-				    v_WIN3_MST2_EN(0) | v_WIN3_MST3_EN(0);
-				lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
-				break;
-			case 4:
-				mask = m_HWC_EN;
-				val = v_HWC_EN(0);
-				lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
-				break;
-			default:
-				break;
-			}
-		}
-		win->last_state = win->state;
-	}
-	if (lcdc_dev->soc_type == VOP_FULL_RK3368) {
-		mask = m_IFBDC_CTRL_FBDC_EN;
-		val = v_IFBDC_CTRL_FBDC_EN(fbdc_en);
-		lcdc_msk_reg(lcdc_dev, IFBDC_CTRL, mask, val);
-	}
-	lcdc_cfg_done(lcdc_dev);
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3368_lcdc_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv,
-				      int enable)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	if (enable)
-		enable_irq(lcdc_dev->irq);
-	else
-		disable_irq(lcdc_dev->irq);
-	return 0;
-}
-
-int rk3368_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 int_reg_val;
-	int ret;
-	u32 intr_status_reg, intr_clear_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-		intr_status_reg = INTR_STATUS_RK3366;
-		intr_clear_reg = INTR_CLEAR_RK3366;
-	} else {
-		intr_status_reg = INTR_STATUS_RK3368;
-		intr_clear_reg = INTR_CLEAR_RK3368;
-	}
-
-	if (lcdc_dev->clk_on && (!dev_drv->suspend_flag)) {
-		int_reg_val = lcdc_readl(lcdc_dev, intr_status_reg);
-		if (int_reg_val & m_LINE_FLAG0_INTR_STS) {
-			lcdc_dev->driver.frame_time.last_framedone_t =
-			    lcdc_dev->driver.frame_time.framedone_t;
-			lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
-			lcdc_msk_reg(lcdc_dev, intr_clear_reg,
-				     m_LINE_FLAG0_INTR_CLR,
-				     v_LINE_FLAG0_INTR_CLR(1));
-			ret = RK_LF_STATUS_FC;
-		} else {
-			ret = RK_LF_STATUS_FR;
-		}
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int rk3368_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-				    unsigned int dsp_addr[][4])
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
-		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_YRGB_MST);
-		dsp_addr[2][0] = lcdc_readl(lcdc_dev, WIN2_MST0);
-		dsp_addr[2][1] = lcdc_readl(lcdc_dev, WIN2_MST1);
-		dsp_addr[2][2] = lcdc_readl(lcdc_dev, WIN2_MST2);
-		dsp_addr[2][3] = lcdc_readl(lcdc_dev, WIN2_MST3);
-		dsp_addr[3][0] = lcdc_readl(lcdc_dev, WIN3_MST0);
-		dsp_addr[3][1] = lcdc_readl(lcdc_dev, WIN3_MST1);
-		dsp_addr[3][2] = lcdc_readl(lcdc_dev, WIN3_MST2);
-		dsp_addr[3][3] = lcdc_readl(lcdc_dev, WIN3_MST3);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3368_lcdc_set_dsp_cabc(struct rk_lcdc_driver *dev_drv,
-				    int mode, int calc, int up,
-				    int down, int global)
-{
-	struct lcdc_device *lcdc_dev =
-		container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 total_pixel, calc_pixel, stage_up, stage_down;
-	u32 pixel_num, global_dn;
-	u32 mask = 0, val = 0;
-	int *cabc_lut = NULL;
-
-	if (screen->type == SCREEN_HDMI && screen->type == SCREEN_TVOUT) {
-		pr_err("screen type is %d, not support cabc\n", screen->type);
-		return 0;
-	} else if (!screen->cabc_lut) {
-		pr_err("screen cabc lut not config, so not open cabc\n");
-		return 0;
-	} else {
-		cabc_lut = screen->cabc_lut;
-	}
-
-	if (mode == 0) {
-		spin_lock(&lcdc_dev->reg_lock);
-		if (lcdc_dev->clk_on) {
-			lcdc_msk_reg(lcdc_dev, CABC_CTRL0,
-				     m_CABC_EN, v_CABC_EN(0));
-			lcdc_cfg_done(lcdc_dev);
-		}
-		pr_info("mode = 0, close cabc\n");
-		dev_drv->cabc_mode = mode;
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	if (dev_drv->cabc_mode == 0)
-		rk3368_set_cabc_lut(dev_drv, dev_drv->cur_screen->cabc_lut);
-
-	total_pixel = screen->mode.xres * screen->mode.yres;
-	pixel_num = 1000 - calc;
-	calc_pixel = (total_pixel * pixel_num) / 1000;
-	stage_up = up;
-	stage_down = down;
-	global_dn = global;
-	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
-		mode, calc, stage_up, stage_down, global_dn);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_CABC_EN | m_CABC_HANDLE_EN | m_PWM_CONFIG_MODE |
-			m_CABC_CALC_PIXEL_NUM;
-		val = v_CABC_EN(1) | v_CABC_HANDLE_EN(1) |
-			v_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
-			v_CABC_CALC_PIXEL_NUM(calc_pixel);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL0, mask, val);
-
-		mask = m_CABC_LUT_EN | m_CABC_TOTAL_PIXEL_NUM;
-		val = v_CABC_LUT_EN(1) | v_CABC_TOTAL_PIXEL_NUM(total_pixel);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, mask, val);
-
-		mask = m_CABC_STAGE_DOWN | m_CABC_STAGE_UP |
-			m_CABC_STAGE_MODE | m_MAX_SCALE_CFG_VALUE |
-			m_MAX_SCALE_CFG_ENABLE;
-		val = v_CABC_STAGE_DOWN(stage_down) |
-			v_CABC_STAGE_UP(stage_up) |
-			v_CABC_STAGE_MODE(0) | v_MAX_SCALE_CFG_VALUE(1) |
-			v_MAX_SCALE_CFG_ENABLE(0);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL2, mask, val);
-
-		mask = m_CABC_GLOBAL_DN | m_CABC_GLOBAL_DN_LIMIT_EN;
-		val = v_CABC_GLOBAL_DN(global_dn) |
-			v_CABC_GLOBAL_DN_LIMIT_EN(1);
-		lcdc_msk_reg(lcdc_dev, CABC_CTRL3, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-		dev_drv->cabc_mode = mode;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-/*
-	a:[-30~0]:
-	    sin_hue = sin(a)*256 +0x100;
-	    cos_hue = cos(a)*256;
-	a:[0~30]
-	    sin_hue = sin(a)*256;
-	    cos_hue = cos(a)*256;
-*/
-static int rk3368_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-				    bcsh_hue_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val = 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_H);
-		switch (mode) {
-		case H_SIN:
-			val &= m_BCSH_SIN_HUE;
-			break;
-		case H_COS:
-			val &= m_BCSH_COS_HUE;
-			val >>= 16;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return val;
-}
-
-static int rk3368_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-				    int sin_hue, int cos_hue)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
-		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
-		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static int rk3368_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode, int value)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask = 0, val = 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		switch (mode) {
-		case BRIGHTNESS:
-			/*user: from 0 to 255,typical is 128,
-			 *vop,6bit: from 0 to 64, typical is 32*/
-			value /= 4;
-			if (value < 0x20)
-				value += 0x20;
-			else if (value >= 0x20)
-				value = value - 0x20;
-			mask = m_BCSH_BRIGHTNESS;
-			val = v_BCSH_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-			/*user: from 0 to 510,typical is 256
-			 *vop,9bit, from 0 to 511,typical is 256*/
-			value = 512 - value;
-			mask = m_BCSH_CONTRAST;
-			val = v_BCSH_CONTRAST(value);
-			break;
-		case SAT_CON:
-			/*from 0 to 1024,typical is 512
-			 *vop,9bit, from 0 to 512, typical is 256*/
-			value /= 2;
-			mask = m_BCSH_SAT_CON;
-			val = v_BCSH_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk3368_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-				    bcsh_bcs_mode mode)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val = 0;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		val = lcdc_readl(lcdc_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= m_BCSH_BRIGHTNESS;
-			if (val >= 0x20)
-				val -= 0x20;
-			else
-				val += 0x20;
-			val <<= 2;
-			break;
-		case CONTRAST:
-			val &= m_BCSH_CONTRAST;
-			val >>= 8;
-			break;
-		case SAT_CON:
-			val &= m_BCSH_SAT_CON;
-			val >>= 20;
-			val <<= 1;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return val;
-}
-
-static int rk3368_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 mask, val;
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if (lcdc_dev->clk_on) {
-		if (open) {
-			lcdc_writel(lcdc_dev, BCSH_COLOR_BAR, 0x1);
-			lcdc_writel(lcdc_dev, BCSH_BCS, 0xd0010000);
-			lcdc_writel(lcdc_dev, BCSH_H, 0x01000000);
-			dev_drv->bcsh.enable = 1;
-		} else {
-			mask = m_BCSH_EN;
-			val = v_BCSH_EN(0);
-			lcdc_msk_reg(lcdc_dev, BCSH_COLOR_BAR, mask, val);
-			dev_drv->bcsh.enable = 0;
-		}
-		rk3368_lcdc_bcsh_path_sel(dev_drv);
-		lcdc_cfg_done(lcdc_dev);
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	return 0;
-}
-
-static int rk3368_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
-{
-	if (!enable || !dev_drv->bcsh.enable) {
-		rk3368_lcdc_open_bcsh(dev_drv, false);
-		return 0;
-	}
-
-	if (dev_drv->bcsh.brightness <= 255 ||
-	    dev_drv->bcsh.contrast <= 510 ||
-	    dev_drv->bcsh.sat_con <= 1015 ||
-	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
-		rk3368_lcdc_open_bcsh(dev_drv, true);
-		if (dev_drv->bcsh.brightness <= 255)
-			rk3368_lcdc_set_bcsh_bcs(dev_drv, BRIGHTNESS,
-						 dev_drv->bcsh.brightness);
-		if (dev_drv->bcsh.contrast <= 510)
-			rk3368_lcdc_set_bcsh_bcs(dev_drv, CONTRAST,
-						 dev_drv->bcsh.contrast);
-		if (dev_drv->bcsh.sat_con <= 1015)
-			rk3368_lcdc_set_bcsh_bcs(dev_drv, SAT_CON,
-						 dev_drv->bcsh.sat_con);
-		if (dev_drv->bcsh.sin_hue <= 511 &&
-		    dev_drv->bcsh.cos_hue <= 511)
-			rk3368_lcdc_set_bcsh_hue(dev_drv,
-						 dev_drv->bcsh.sin_hue,
-						 dev_drv->bcsh.cos_hue);
-	}
-	return 0;
-}
-
-static int __maybe_unused
-rk3368_lcdc_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (enable) {
-		spin_lock(&lcdc_dev->reg_lock);
-		if (likely(lcdc_dev->clk_on)) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLACK_EN,
-				     v_DSP_BLACK_EN(1));
-			lcdc_cfg_done(lcdc_dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	} else {
-		spin_lock(&lcdc_dev->reg_lock);
-		if (likely(lcdc_dev->clk_on)) {
-			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLACK_EN,
-				     v_DSP_BLACK_EN(0));
-
-			lcdc_cfg_done(lcdc_dev);
-		}
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-
-static int rk3368_lcdc_wait_frame_start(struct rk_lcdc_driver *dev_drv,
-					int enable)
-{
-	u32 line_scane_num, vsync_end, vact_end;
-	u32 interlace_mode;
-
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	if (0 == enable) {
-		interlace_mode = lcdc_read_bit(lcdc_dev, DSP_CTRL0,
-					       m_DSP_INTERLACE);
-		if (interlace_mode) {
-			vsync_end = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) &
-					m_DSP_VS_END_F1;
-			vact_end = lcdc_readl(lcdc_dev, DSP_VACT_ST_END_F1) &
-					m_DSP_VACT_END_F1;
-		} else {
-			vsync_end = lcdc_readl(lcdc_dev, DSP_VTOTAL_VS_END) &
-					m_DSP_VS_PW;
-			vact_end = lcdc_readl(lcdc_dev, DSP_VACT_ST_END) &
-					m_DSP_VACT_END;
-		}
-		while (1) {
-			line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) &
-					0x1fff;
-			if ((line_scane_num > vsync_end) &&
-			    (line_scane_num <= vact_end - 100))
-				break;
-		}
-		return 0;
-	} else if (1 == enable) {
-		line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
-		return line_scane_num;
-	}
-
-	return 0;
-}
-
-static int rk3368_lcdc_backlight_close(struct rk_lcdc_driver *dev_drv,
-				       int enable)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	rk3368_lcdc_get_backlight_device(dev_drv);
-
-	if (enable) {
-		/* close the backlight */
-		if (lcdc_dev->backlight) {
-			lcdc_dev->backlight->props.power = FB_BLANK_POWERDOWN;
-			backlight_update_status(lcdc_dev->backlight);
-		}
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-			dev_drv->trsm_ops->disable();
-	} else {
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-			dev_drv->trsm_ops->enable();
-		msleep(100);
-		/* open the backlight */
-		if (lcdc_dev->backlight) {
-			lcdc_dev->backlight->props.power = FB_BLANK_UNBLANK;
-			backlight_update_status(lcdc_dev->backlight);
-		}
-	}
-
-	return 0;
-}
-
-static int rk3368_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
-				    struct overscan *overscan)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	/*rk3368_lcdc_post_cfg(dev_drv);*/
-
-	return 0;
-}
-
-static int rk3368_lcdc_extern_func(struct rk_lcdc_driver *dev_drv,
-				   int cmd)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	u32 val;
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-
-	switch (cmd) {
-	case GET_PAGE_FAULT:
-		val = lcdc_readl(lcdc_dev, MMU_INT_RAWSTAT);
-		if ((val & 0x1) == 1) {
-			if ((val & 0x2) == 1)
-				pr_info("val=0x%x,vop iommu bus error\n", val);
-			else
-				return 1;
-		}
-		break;
-	case CLR_PAGE_FAULT:
-		lcdc_writel(lcdc_dev, MMU_INT_CLEAR, 0x3);
-		break;
-	case UNMASK_PAGE_FAULT:
-		lcdc_writel(lcdc_dev, MMU_INT_MASK, 0x2);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int rk3368_lcdc_set_wb(struct rk_lcdc_driver *dev_drv)
-{
-	struct lcdc_device *lcdc_dev =
-	    container_of(dev_drv, struct lcdc_device, driver);
-	struct rk_fb_reg_wb_data *wb_data;
-	u32 src_w, src_h, dst_w, dst_h, fmt_cfg;
-	u32 xscale_en = 0, x_scale_fac = 0, y_throw = 0;
-	u32 csc_mode = 0, rgb2yuv = 0, dither_en = 0;
-
-	if (unlikely(!lcdc_dev->clk_on)) {
-		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
-		return 0;
-	}
-	wb_data = &dev_drv->wb_data;
-	if ((wb_data->xsize == 0) || (wb_data->ysize == 0))
-		return 0;
-
-	src_w = dev_drv->cur_screen->mode.xres;
-	src_h = dev_drv->cur_screen->mode.yres;
-	dst_w = wb_data->xsize;
-	dst_h = wb_data->ysize;
-	if (!IS_ALIGNED(dst_w, RK3366_WB_ALIGN))
-		pr_info("dst_w: %d not align 16 pixel\n", dst_w);
-
-	if (src_w > dst_w)
-		xscale_en = 1;
-	else if (src_w < dst_w)
-		dst_w = src_w;
-	else
-		xscale_en = 0;
-	if (wb_data->state && xscale_en)
-		x_scale_fac = GET_SCALE_FACTOR_BILI_DN(src_w, dst_w);
-	if ((src_h >= 2 * dst_h) && (dst_h != 0))
-		y_throw = 1;
-	else
-		y_throw = 0;
-	switch (wb_data->data_format) {
-	case XRGB888:
-	case XBGR888:
-		fmt_cfg = 0;
-		break;
-	case RGB888:
-	case BGR888:
-		fmt_cfg = 1;
-		break;
-	case RGB565:
-	case BGR565:
-		fmt_cfg = 2;
-		dither_en = 1;
-		break;
-	case YUV420:
-		fmt_cfg = 4;
-		if (dev_drv->overlay_mode == VOP_RGB_DOMAIN)
-			rgb2yuv = 1;
-		if ((src_w < 1280) && (src_h < 720))
-			csc_mode = VOP_R2Y_CSC_BT601;
-		else
-			csc_mode = VOP_R2Y_CSC_BT709;
-		break;
-	default:
-		fmt_cfg = 0;
-		pr_info("unsupport fmt: %d\n", wb_data->data_format);
-		break;
-	}
-	spin_lock(&lcdc_dev->reg_lock);
-	lcdc_msk_reg(lcdc_dev, WB_CTRL0,
-		     m_WB_EN | m_WB_FMT | m_WB_XPSD_BIL_EN |
-		     m_WB_YTHROW_EN | m_WB_RGB2YUV_EN | m_WB_RGB2YUV_MODE |
-		     m_WB_DITHER_EN,
-		     v_WB_EN(wb_data->state) | v_WB_FMT(fmt_cfg) |
-		     v_WB_XPSD_BIL_EN(xscale_en) |
-		     v_WB_YTHROW_EN(y_throw) | v_WB_RGB2YUV_EN(rgb2yuv) |
-		     v_WB_RGB2YUV_MODE(csc_mode) | v_WB_DITHER_EN(dither_en));
-	lcdc_msk_reg(lcdc_dev, WB_CTRL1,
-		     m_WB_WIDTH | m_WB_XPSD_BIL_FACTOR,
-		     v_WB_WIDTH(dst_w) |
-		     v_WB_XPSD_BIL_FACTOR(x_scale_fac));
-	lcdc_writel(lcdc_dev, WB_YRGB_MST, wb_data->smem_start);
-	lcdc_writel(lcdc_dev, WB_CBR_MST, wb_data->cbr_start);
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-}
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open = rk3368_lcdc_open,
-	.win_direct_en = rk3368_lcdc_win_direct_en,
-	.load_screen = rk3368_load_screen,
-	.get_dspbuf_info = rk3368_get_dspbuf_info,
-	.post_dspbuf = rk3368_post_dspbuf,
-	.set_par = rk3368_lcdc_set_par,
-	.pan_display = rk3368_lcdc_pan_display,
-	.direct_set_addr = rk3368_lcdc_direct_set_win_addr,
-	/*.lcdc_reg_update = rk3368_lcdc_reg_update,*/
-	.blank = rk3368_lcdc_blank,
-	.ioctl = rk3368_lcdc_ioctl,
-	.suspend = rk3368_lcdc_early_suspend,
-	.resume = rk3368_lcdc_early_resume,
-	.get_win_state = rk3368_lcdc_get_win_state,
-	.area_support_num = rk3368_lcdc_get_area_num,
-	.ovl_mgr = rk3368_lcdc_ovl_mgr,
-	.get_disp_info = rk3368_lcdc_get_disp_info,
-	.fps_mgr = rk3368_lcdc_fps_mgr,
-	.fb_get_win_id = rk3368_lcdc_get_win_id,
-	.fb_win_remap = rk3368_fb_win_remap,
-	.set_dsp_lut = rk3368_lcdc_set_lut,
-	.set_cabc_lut = rk3368_set_cabc_lut,
-	.poll_vblank = rk3368_lcdc_poll_vblank,
-	.get_dsp_addr = rk3368_lcdc_get_dsp_addr,
-	.set_dsp_cabc = rk3368_lcdc_set_dsp_cabc,
-	.set_dsp_bcsh_hue = rk3368_lcdc_set_bcsh_hue,
-	.set_dsp_bcsh_bcs = rk3368_lcdc_set_bcsh_bcs,
-	.get_dsp_bcsh_hue = rk3368_lcdc_get_bcsh_hue,
-	.get_dsp_bcsh_bcs = rk3368_lcdc_get_bcsh_bcs,
-	.open_bcsh = rk3368_lcdc_open_bcsh,
-	.dump_reg = rk3368_lcdc_reg_dump,
-	.cfg_done = rk3368_lcdc_config_done,
-	.set_irq_to_cpu = rk3368_lcdc_set_irq_to_cpu,
-	/*.dsp_black = rk3368_lcdc_dsp_black,*/
-	.backlight_close = rk3368_lcdc_backlight_close,
-	.mmu_en    = rk3368_lcdc_mmu_en,
-	.set_overscan   = rk3368_lcdc_set_overscan,
-	.extern_func	= rk3368_lcdc_extern_func,
-	.wait_frame_start = rk3368_lcdc_wait_frame_start,
-	.set_wb = rk3368_lcdc_set_wb,
-};
-
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-static int rk3368_lcdc_parse_irq(struct lcdc_device *lcdc_dev,
-				 unsigned int intr_status)
-{
-	u32 intr_clr_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		intr_clr_reg = INTR_CLEAR_RK3366;
-	else
-		intr_clr_reg = INTR_CLEAR_RK3368;
-
-	if (intr_status & m_WIN0_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN0_EMPTY_INTR_CLR,
-			     v_WIN0_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "win0 empty irq!");
-	} else if (intr_status & m_WIN1_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN1_EMPTY_INTR_CLR,
-			     v_WIN1_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "win1 empty irq!");
-	} else if (intr_status & m_WIN2_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN2_EMPTY_INTR_CLR,
-			     v_WIN2_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "win2 empty irq!");
-	} else if (intr_status & m_WIN3_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN3_EMPTY_INTR_CLR,
-			     v_WIN3_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "win3 empty irq!");
-	} else if (intr_status & m_HWC_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_HWC_EMPTY_INTR_CLR,
-			     v_HWC_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "HWC empty irq!");
-	} else if (intr_status & m_POST_BUF_EMPTY_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_POST_BUF_EMPTY_INTR_CLR,
-			     v_POST_BUF_EMPTY_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "post buf empty irq!");
-	} else if (intr_status & m_PWM_GEN_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_PWM_GEN_INTR_CLR,
-			     v_PWM_GEN_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "PWM gen irq!");
-	}
-	return 0;
-}
-#endif
-
-static irqreturn_t rk3368_lcdc_isr(int irq, void *dev_id)
-{
-	struct lcdc_device *lcdc_dev = (struct lcdc_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 intr_status;
-	u32 line_scane_num, dsp_vs_st_f1;
-	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
-	u32 intr_en_reg, intr_clr_reg, intr_status_reg;
-
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
-		intr_status_reg = INTR_STATUS_RK3366;
-		intr_clr_reg = INTR_CLEAR_RK3366;
-		intr_en_reg = INTR_EN_RK3366;
-	} else {
-		intr_status_reg = INTR_STATUS_RK3368;
-		intr_clr_reg = INTR_CLEAR_RK3368;
-		intr_en_reg = INTR_EN_RK3368;
-	}
-
-	intr_status = lcdc_readl(lcdc_dev, intr_status_reg);
-	if (intr_status & m_FS_INTR_STS) {
-		timestamp = ktime_get();
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_FS_INTR_CLR,
-			     v_FS_INTR_CLR(1));
-		line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
-		dsp_vs_st_f1 = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) >> 16;
-		/*if(lcdc_dev->driver.wait_fs){ */
-		if (0) {
-			spin_lock(&(lcdc_dev->driver.cpl_lock));
-			complete(&(lcdc_dev->driver.frame_done));
-			spin_unlock(&(lcdc_dev->driver.cpl_lock));
-		}
-		lcdc_dev->driver.vsync_info.timestamp = timestamp;
-		if ((lcdc_dev->soc_type == VOP_FULL_RK3366) &&
-		    (lcdc_dev->driver.wb_data.state)) {
-			if (lcdc_read_bit(lcdc_dev, WB_CTRL0, m_WB_EN)) {
-				lcdc_msk_reg(lcdc_dev, WB_CTRL0,
-					     m_WB_EN, v_WB_EN(0));
-				lcdc_cfg_done(lcdc_dev);
-				lcdc_dev->driver.wb_data.state = 0;
-			}
-		}
-		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
-		if (!(screen->mode.vmode & FB_VMODE_INTERLACED) ||
-		    (line_scane_num >= dsp_vs_st_f1)) {
-			lcdc_dev->driver.vsync_info.timestamp = timestamp;
-			wake_up_interruptible_all(
-				&lcdc_dev->driver.vsync_info.wait);
-		}
-	} else if (intr_status & m_LINE_FLAG0_INTR_STS) {
-		lcdc_dev->driver.frame_time.last_framedone_t =
-			lcdc_dev->driver.frame_time.framedone_t;
-		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_LINE_FLAG0_INTR_CLR,
-			     v_LINE_FLAG0_INTR_CLR(1));
-	} else if (intr_status & m_LINE_FLAG1_INTR_STS) {
-		/*line flag1 */
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_LINE_FLAG1_INTR_CLR,
-			     v_LINE_FLAG1_INTR_CLR(1));
-	} else if (intr_status & m_FS_NEW_INTR_STS) {
-		/*new frame start */
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_FS_NEW_INTR_CLR,
-			     v_FS_NEW_INTR_CLR(1));
-	} else if (intr_status & m_BUS_ERROR_INTR_STS) {
-		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_BUS_ERROR_INTR_CLR,
-			     v_BUS_ERROR_INTR_CLR(1));
-		dev_warn(lcdc_dev->dev, "bus error!");
-	}
-
-	/* for win empty debug */
-#ifdef LCDC_IRQ_EMPTY_DEBUG
-	rk3368_lcdc_parse_irq(lcdc_dev, intr_status);
-#endif
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_PM)
-static int rk3368_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk3368_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define rk3368_lcdc_suspend NULL
-#define rk3368_lcdc_resume  NULL
-#endif
-
-static int rk3368_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
-{
-	struct device_node *np = lcdc_dev->dev->of_node;
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,prop", &val))
-		lcdc_dev->prop = PRMRY;	/*default set it as primary */
-	else
-		lcdc_dev->prop = val;
-
-	if (of_property_read_u32(np, "rockchip,mirror", &val))
-		dev_drv->rotate_mode = NO_MIRROR;
-	else
-		dev_drv->rotate_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
-		dev_drv->cabc_mode = 0;	/* default set close cabc */
-	else
-		dev_drv->cabc_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-		/*default set it as 3.xv power supply */
-		lcdc_dev->pwr18 = false;
-	else
-		lcdc_dev->pwr18 = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
-	else
-		dev_drv->fb_win_map = val;
-
-	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
-		dev_drv->bcsh.enable = false;
-	else
-		dev_drv->bcsh.enable = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,brightness", &val))
-		dev_drv->bcsh.brightness = 0xffff;
-	else
-		dev_drv->bcsh.brightness = val;
-
-	if (of_property_read_u32(np, "rockchip,contrast", &val))
-		dev_drv->bcsh.contrast = 0xffff;
-	else
-		dev_drv->bcsh.contrast = val;
-
-	if (of_property_read_u32(np, "rockchip,sat-con", &val))
-		dev_drv->bcsh.sat_con = 0xffff;
-	else
-		dev_drv->bcsh.sat_con = val;
-
-	if (of_property_read_u32(np, "rockchip,hue", &val)) {
-		dev_drv->bcsh.sin_hue = 0xffff;
-		dev_drv->bcsh.cos_hue = 0xffff;
-	} else {
-		dev_drv->bcsh.sin_hue = val & 0xff;
-		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
-	}
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		dev_drv->iommu_enabled = 0;
-	else
-		dev_drv->iommu_enabled = val;
-	return 0;
-}
-
-static int rk3368_lcdc_probe(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct device_node *np = pdev->dev.of_node;
-	int prop;
-	int ret = 0;
-
-	/*if the primary lcdc has not registered ,the extend
-	   lcdc register later */
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		if (!is_prmry_rk_lcdc_registered())
-			return -EPROBE_DEFER;
-	}
-	lcdc_dev = devm_kzalloc(dev, sizeof(struct lcdc_device), GFP_KERNEL);
-	if (!lcdc_dev) {
-		dev_err(&pdev->dev, "rk3368 lcdc device kmalloc fail!");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->dev = dev;
-	rk3368_lcdc_parse_dt(lcdc_dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-	/* enable power domain */
-	pm_runtime_enable(dev);
-#endif
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-
-	lcdc_dev->regs = devm_ioremap(&pdev->dev, res->start,
-				      resource_size(res));
-	if (IS_ERR(lcdc_dev->regs))
-		return PTR_ERR(lcdc_dev->regs);
-	else
-		dev_info(dev, "lcdc_dev->regs=0x%lx\n", (long)lcdc_dev->regs);
-
-	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
-	if (IS_ERR(lcdc_dev->regsbak))
-		return PTR_ERR(lcdc_dev->regsbak);
-	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + GAMMA_LUT_ADDR);
-	lcdc_dev->cabc_lut_addr_base = (lcdc_dev->regs + CABC_GAMMA_LUT_ADDR);
-	lcdc_dev->grf_base =
-		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-	if (IS_ERR(lcdc_dev->grf_base)) {
-		dev_err(&pdev->dev, "can't find lcdc grf property\n");
-		lcdc_dev->grf_base = NULL;
-	}
-	lcdc_dev->pmugrf_base =
-		syscon_regmap_lookup_by_phandle(np, "rockchip,pmugrf");
-	if (IS_ERR(lcdc_dev->pmugrf_base)) {
-		dev_err(&pdev->dev, "can't find lcdc pmu grf property\n");
-		lcdc_dev->pmugrf_base = NULL;
-	}
-
-	lcdc_dev->cru_base =
-		syscon_regmap_lookup_by_phandle(np, "rockchip,cru");
-	if (IS_ERR(lcdc_dev->cru_base)) {
-		dev_err(&pdev->dev, "can't find lcdc cru_base property\n");
-		lcdc_dev->cru_base = NULL;
-	}
-
-	lcdc_dev->id = 0;
-	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
-	dev_drv = &lcdc_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = prop;
-	dev_drv->id = lcdc_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
-	dev_drv->reserved_fb = 1;/*only need reserved 1 buffer*/
-	spin_lock_init(&lcdc_dev->reg_lock);
-
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if (lcdc_dev->irq < 0) {
-		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
-			lcdc_dev->id);
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(dev, lcdc_dev->irq, rk3368_lcdc_isr,
-			       IRQF_SHARED,
-			       dev_name(dev), lcdc_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
-			lcdc_dev->irq, ret);
-		return ret;
-	}
-
-	if (dev_drv->iommu_enabled) {
-		if (lcdc_dev->id == 0) {
-			strcpy(dev_drv->mmu_dts_name,
-			       VOPB_IOMMU_COMPATIBLE_NAME);
-		} else {
-			strcpy(dev_drv->mmu_dts_name,
-			       VOPL_IOMMU_COMPATIBLE_NAME);
-		}
-	}
-
-	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
-		return ret;
-	}
-	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
-		dev_drv->property.feature |= SUPPORT_WRITE_BACK;
-	else if (lcdc_dev->soc_type == VOP_FULL_RK3368)
-		dev_drv->property.feature |= SUPPORT_IFBDC;
-	dev_drv->property.feature |= SUPPORT_VOP_IDENTIFY |
-				SUPPORT_YUV420_OUTPUT;
-	dev_drv->property.max_output_x = 4096;
-	dev_drv->property.max_output_y = 2160;
-	lcdc_dev->screen = dev_drv->screen0;
-	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
-		 lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	return 0;
-}
-
-static int rk3368_lcdc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void rk3368_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
-#if 1
-	dev_drv->suspend_flag = 1;
-	mdelay(100);
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-	kthread_stop(dev_drv->update_regs_thread);
-	rk3368_lcdc_deint(lcdc_dev);
-	/*if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();*/
-
-	rk3368_lcdc_clk_disable(lcdc_dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-	pm_runtime_disable(lcdc_dev->dev);
-#endif
-	rk_disp_pwr_disable(dev_drv);
-#else
-	rk3368_lcdc_early_suspend(&lcdc_dev->driver);
-	rk3368_lcdc_deint(lcdc_dev);
-#endif
-}
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3368_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3368-lcdc",},
-	{.compatible = "rockchip,rk3366-lcdc-big",},
-	{}
-};
-#endif
-
-static struct platform_driver rk3368_lcdc_driver = {
-	.probe = rk3368_lcdc_probe,
-	.remove = rk3368_lcdc_remove,
-	.driver = {
-		   .name = "rk3368-lcdc",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(rk3368_lcdc_dt_ids),
-		   },
-	.suspend = rk3368_lcdc_suspend,
-	.resume = rk3368_lcdc_resume,
-	.shutdown = rk3368_lcdc_shutdown,
-};
-
-static int __init rk3368_lcdc_module_init(void)
-{
-	return platform_driver_register(&rk3368_lcdc_driver);
-}
-
-static void __exit rk3368_lcdc_module_exit(void)
-{
-	platform_driver_unregister(&rk3368_lcdc_driver);
-}
-
-fs_initcall(rk3368_lcdc_module_init);
-module_exit(rk3368_lcdc_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk3368_lcdc.h b/drivers/video/rockchip/lcdc/rk3368_lcdc.h
deleted file mode 100644
index bcab60348233..000000000000
--- a/drivers/video/rockchip/lcdc/rk3368_lcdc.h
+++ /dev/null
@@ -1,2158 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK3368_LCDC_H_
-#define RK3368_LCDC_H_
-
-#include<linux/rk_fb.h>
-#include<linux/io.h>
-#include<linux/clk.h>
-#include<linux/mfd/syscon.h>
-#include<linux/regmap.h>
-
-#define VOP_INPUT_MAX_WIDTH 4096 /*3840 for LINCOLN*/
-
-#define REG_CFG_DONE			(0x0000)
-#define VOP_CFG_DONE(x)				(((x)&1)<<0)
-#define WIN0_CFG_DONE(x)			(((x)&1)<<1)
-#define WIN1_CFG_DONE(x)			(((x)&1)<<2)
-#define WIN2_CFG_DONE(x)			(((x)&1)<<3)
-#define WIN3_CFG_DONE(x)			(((x)&1)<<4)
-#define HWC_CFG_DONE(x)				(((x)&1)<<5)
-#define IEP_CFG_DONE(x)				(((x)&1)<<6)
-#define FBDC_CFG_DONE(x)			(((x)&1)<<7)
-#define SYS_CFG_DONE(x)				(((x)&1)<<8)
-
-#define VOP_CFG_DONE_WMSK(x)			(((x)&1)<<(0+16))
-#define WIN0_CFG_DONE_WMSK(x)			(((x)&1)<<(1+16))
-#define WIN1_CFG_DONE_WMSK(x)			(((x)&1)<<(2+16))
-#define WIN2_CFG_DONE_WMSK(x)			(((x)&1)<<(3+16))
-#define WIN3_CFG_DONE_WMSK(x)			(((x)&1)<<(4+16))
-#define HWC_CFG_DONE_WMSK(x)			(((x)&1)<<(5+16))
-#define IEP_CFG_DONE_WMSK(x)			(((x)&1)<<(6+16))
-#define FBDC_CFG_DONE_WMSK(x)			(((x)&1)<<(7+16))
-#define SYS_CFG_DONE_WMSK(x)			(((x)&1)<<(8+16))
-
-#define VOP_REG_DONE		(VOP_CFG_DONE(1)  | VOP_CFG_DONE_WMSK(1))
-#define WIN0_REG_DONE		(WIN0_CFG_DONE(1) | WIN0_CFG_DONE_WMSK(1))
-#define WIN1_REG_DONE		(WIN1_CFG_DONE(1) | WIN1_CFG_DONE_WMSK(1))
-#define WIN2_REG_DONE		(WIN2_CFG_DONE(1) | WIN2_CFG_DONE_WMSK(1))
-#define WIN3_REG_DONE		(WIN3_CFG_DONE(1) | WIN3_CFG_DONE_WMSK(1))
-#define HWC_REG_DONE		(HWC_CFG_DONE(1)  | HWC_CFG_DONE_WMSK(1))
-#define IEP_REG_DONE		(IEP_CFG_DONE(1)  | IEP_CFG_DONE_WMSK(1))
-#define FBDC_REG_DONE		(FBDC_CFG_DONE(1) | FBDC_CFG_DONE_WMSK(1))
-#define SYS_REG_DONE		(SYS_CFG_DONE(1)  | SYS_CFG_DONE_WMSK(1))
-
-#define VERSION_INFO			(0x0004)
-#define m_RTL_VERSION			(0xffff<<0)
-#define m_FPGA_VERSION			(0xffff<<16)
-#define VOP_FULL_RK3368			0x03021223
-#define VOP_FULL_RK3366			0x03045635
-
-#define SYS_CTRL			(0x0008)
-#define v_DIRECT_PATH_EN(x)			(((x)&1)<<0)
-#define v_DIRECT_PATCH_SEL(x)			(((x)&3)<<1)
-#define v_DOUB_CHANNEL_EN(x)			(((x)&1)<<3)
-#define v_DOUB_CH_OVERLAP_NUM(x)		(((x)&0xf)<<4)
-#define v_EDPI_HALT_EN(x)			(((x)&1)<<8)
-#define v_EDPI_WMS_MODE(x)			(((x)&1)<<9)
-#define v_EDPI_WMS_FS(x)			(((x)&1)<<10)
-#define v_GLOBAL_REGDONE_EN(x)			(((x)&1)<<11)
-#define v_RGB_OUT_EN(x)				(((x)&1)<<12)
-#define v_HDMI_OUT_EN(x)			(((x)&1)<<13)
-#define v_EDP_OUT_EN(x)				(((x)&1)<<14)
-#define v_MIPI_OUT_EN(x)			(((x)&1)<<15)
-#define v_OVERLAY_MODE(x)			(((x)&1)<<16)
-#define v_FS_SAME_ADDR_MASK_EN(x)		(((x)&1)<<17)
-#define v_POST_LB_MODE(x)			(((x)&1)<<18)
-#define v_WIN23_PRI_OPT_MODE(x)			(((x)&1)<<19)
-#define v_MMU_EN(x)				(((x)&1)<<20)
-#define v_DMA_STOP(x)				(((x)&1)<<21)
-#define v_STANDBY_EN(x)				(((x)&1)<<22)
-#define v_AUTO_GATING_EN(x)			(((x)&1)<<23)
-
-#define m_DIRECT_PATH_EN			(1<<0)
-#define m_DIRECT_PATCH_SEL			(3<<1)
-#define m_DOUB_CHANNEL_EN			(1<<3)
-#define m_DOUB_CH_OVERLAP_NUM			(0xf<<4)
-#define m_EDPI_HALT_EN				(1<<8)
-#define m_EDPI_WMS_MODE				(1<<9)
-#define m_EDPI_WMS_FS				(1<<10)
-#define m_GLOBAL_REGDONE_EN			(1<<11)
-#define m_RGB_OUT_EN				(1<<12)
-#define m_HDMI_OUT_EN				(1<<13)
-#define m_EDP_OUT_EN				(1<<14)
-#define m_MIPI_OUT_EN				(1<<15)
-#define m_OVERLAY_MODE				(1<<16)
-#define m_FS_SAME_ADDR_MASK_EN			(1<<17)
-#define m_POST_LB_MODE				(1<<18)
-#define m_WIN23_PRI_OPT_MODE			(1<<19)
-#define m_MMU_EN				(1<<20)
-#define m_DMA_STOP				(1<<21)
-#define m_STANDBY_EN				(1<<22)
-#define m_AUTO_GATING_EN			(1<<23)
-
-#define SYS_CTRL1			(0x000c)
-#define v_NOC_HURRY_EN(x)			(((x)&0x1)<<0)
-#define v_NOC_HURRY_VALUE(x)			(((x)&0x3)<<1)
-#define v_NOC_HURRY_THRESHOLD(x)		(((x)&0x3f)<<3)
-#define v_NOC_QOS_EN(x)				(((x)&0x1)<<9)
-#define v_NOC_WIN_QOS(x)			(((x)&0x3)<<10)
-#define v_AXI_MAX_OUTSTANDING_EN(x)		(((x)&0x1)<<12)
-#define v_AXI_OUTSTANDING_MAX_NUM(x)		(((x)&0x1f)<<13)
-#define v_NOC_HURRY_W_MODE(x)			(((x)&0x3)<<20)
-
-#define m_NOC_HURRY_EN				(0x1<<0)
-#define m_NOC_HURRY_VALUE			(0x3<<1)
-#define m_NOC_HURRY_THRESHOLD			(0x3f<<3)
-#define m_NOC_QOS_EN				(0x1<<9)
-#define m_NOC_WIN_QOS				(0x3<<10)
-#define m_AXI_MAX_OUTSTANDING_EN		(0x1<<12)
-#define m_AXI_OUTSTANDING_MAX_NUM		(0x1f<<13)
-#define m_NOC_HURRY_W_MODE			(0x3<<20)
-
-#define DSP_CTRL0			(0x0010)
-#define v_DSP_OUT_MODE(x)			(((x)&0x0f)<<0)
-#define v_SW_CORE_DCLK_SEL(x)			(((x)&1)<<4)
-#define v_DSP_DCLK_DDR(x)			(((x)&1)<<8)
-#define v_DSP_DDR_PHASE(x)			(((x)&1)<<9)
-#define v_DSP_INTERLACE(x)			(((x)&1)<<10)
-#define v_DSP_FIELD_POL(x)			(((x)&1)<<11)
-#define v_DSP_BG_SWAP(x)			(((x)&1)<<12)
-#define v_DSP_RB_SWAP(x)			(((x)&1)<<13)
-#define v_DSP_RG_SWAP(x)			(((x)&1)<<14)
-#define v_DSP_DELTA_SWAP(x)			(((x)&1)<<15)
-#define v_DSP_DUMMY_SWAP(x)			(((x)&1)<<16)
-#define v_DSP_OUT_ZERO(x)			(((x)&1)<<17)
-#define v_DSP_BLANK_EN(x)			(((x)&1)<<18)
-#define v_DSP_BLACK_EN(x)			(((x)&1)<<19)
-#define v_DSP_CCIR656_AVG(x)			(((x)&1)<<20)
-#define v_DSP_YUV_CLIP(x)			(((x)&1)<<21)
-#define v_DSP_X_MIR_EN(x)			(((x)&1)<<22)
-#define v_DSP_Y_MIR_EN(x)			(((x)&1)<<23)
-#define m_DSP_OUT_MODE				(0x0f<<0)
-#define m_SW_CORE_DCLK_SEL			(1<<4)
-#define m_DSP_DCLK_DDR				(1<<8)
-#define m_DSP_DDR_PHASE				(1<<9)
-#define m_DSP_INTERLACE				(1<<10)
-#define m_DSP_FIELD_POL				(1<<11)
-#define m_DSP_BG_SWAP				(1<<12)
-#define m_DSP_RB_SWAP				(1<<13)
-#define m_DSP_RG_SWAP				(1<<14)
-#define m_DSP_DELTA_SWAP			(1<<15)
-#define m_DSP_DUMMY_SWAP			(1<<16)
-#define m_DSP_OUT_ZERO				(1<<17)
-#define m_DSP_BLANK_EN				(1<<18)
-#define m_DSP_BLACK_EN				(1<<19)
-#define m_DSP_CCIR656_AVG			(1<<20)
-#define m_DSP_YUV_CLIP				(1<<21)
-#define m_DSP_X_MIR_EN				(1<<22)
-#define m_DSP_Y_MIR_EN				(1<<23)
-
-#define DSP_CTRL1			(0x0014)
-#define v_DSP_LUT_EN(x)				(((x)&1)<<0)
-#define v_PRE_DITHER_DOWN_EN(x)			(((x)&1)<<1)
-#define v_DITHER_DOWN_EN(x)			(((x)&1)<<2)
-#define v_DITHER_DOWN_MODE(x)			(((x)&1)<<3)
-#define v_DITHER_DOWN_SEL(x)			(((x)&1)<<4)
-#define v_DITHER_UP_EN(x)			(((x)&1)<<6)
-#define v_DSP_LAYER0_SEL(x)			(((x)&3)<<8)
-#define v_DSP_LAYER1_SEL(x)			(((x)&3)<<10)
-#define v_DSP_LAYER2_SEL(x)			(((x)&3)<<12)
-#define v_DSP_LAYER3_SEL(x)			(((x)&3)<<14)
-
-#define v_RGB_LVDS_HSYNC_POL(x)			(((x)&1)<<16)
-#define v_RGB_LVDS_VSYNC_POL(x)			(((x)&1)<<17)
-#define v_RGB_LVDS_DEN_POL(x)			(((x)&1)<<18)
-#define v_RGB_LVDS_DCLK_POL(x)			(((x)&1)<<19)
-
-#define v_HDMI_HSYNC_POL(x)			(((x)&1)<<20)
-#define v_HDMI_VSYNC_POL(x)			(((x)&1)<<21)
-#define v_HDMI_DEN_POL(x)			(((x)&1)<<22)
-#define v_HDMI_DCLK_POL(x)			(((x)&1)<<23)
-
-#define v_EDP_HSYNC_POL(x)			(((x)&1)<<24)
-#define v_EDP_VSYNC_POL(x)			(((x)&1)<<25)
-#define v_EDP_DEN_POL(x)			(((x)&1)<<26)
-#define v_EDP_DCLK_POL(x)			(((x)&1)<<27)
-
-#define v_MIPI_HSYNC_POL(x)			(((x)&1)<<28)
-#define v_MIPI_VSYNC_POL(x)			(((x)&1)<<29)
-#define v_MIPI_DEN_POL(x)			(((x)&1)<<30)
-#define v_MIPI_DCLK_POL(x)			(((x)&1)<<31)
-
-#define m_DSP_LUT_EN				(1<<0)
-#define m_PRE_DITHER_DOWN_EN			(1<<1)
-#define m_DITHER_DOWN_EN			(1<<2)
-#define m_DITHER_DOWN_MODE			(1<<3)
-#define m_DITHER_DOWN_SEL			(1<<4)
-#define m_DITHER_UP_EN				(1<<6)
-#define m_DSP_LAYER0_SEL			(3<<8)
-#define m_DSP_LAYER1_SEL			(3<<10)
-#define m_DSP_LAYER2_SEL			(3<<12)
-#define m_DSP_LAYER3_SEL			(3<<14)
-
-#define m_RGB_LVDS_HSYNC_POL			(1<<16)
-#define m_RGB_LVDS_VSYNC_POL			(1<<17)
-#define m_RGB_LVDS_DEN_POL			(1<<18)
-#define m_RGB_LVDS_DCLK_POL			(1<<19)
-
-#define m_HDMI_HSYNC_POL			(1<<20)
-#define m_HDMI_VSYNC_POL			(1<<21)
-#define m_HDMI_DEN_POL				(1<<22)
-#define m_HDMI_DCLK_POL				(1<<23)
-
-#define m_EDP_HSYNC_POL				(1<<24)
-#define m_EDP_VSYNC_POL				(1<<25)
-#define m_EDP_DEN_POL				(1<<26)
-#define m_EDP_DCLK_POL				(1<<27)
-
-#define m_MIPI_HSYNC_POL			(1<<28)
-#define m_MIPI_VSYNC_POL			(1<<29)
-#define m_MIPI_DEN_POL				(1<<30)
-#define m_MIPI_DCLK_POL				(1<<31)
-
-#define DSP_BG				(0x0018)
-#define v_DSP_BG_BLUE(x)			(((x)&0xff) << 0)
-#define v_DSP_BG_GREEN(x)			(((x)&0xff) << 8)
-#define v_DSP_BG_RED(x)				(((x)&0xff) << 16)
-#define m_DSP_BG_BLUE				(0xff << 0)
-#define m_DSP_BG_GREEN				(0xff << 8)
-#define m_DSP_BG_RED				(0xff << 16)
-
-#define MCU_CTRL			(0x001c)
-#define v_MCU_PIX_TOTAL(x)			(((x)&0x3f)<<0)
-#define v_MCU_CS_PST(x)				(((x)&0xf)<<6)
-#define v_MCU_CS_PEND(x)			(((x)&0x3f)<<10)
-#define v_MCU_RW_PST(x)				(((x)&0xf)<<16)
-#define v_MCU_RW_PEND(x)			(((x)&0x3f)<<20)
-#define v_MCU_CLK_SEL(x)			(((x)&1)<<26)
-#define v_MCU_HOLD_MODE(x)			(((x)&1)<<27)
-#define v_MCU_FRAME_ST(x)			(((x)&1)<<28)
-#define v_MCU_RS(x)				(((x)&1)<<29)
-#define v_MCU_BYPASS(x)				(((x)&1)<<30)
-#define v_MCU_TYPE(x)				(((x)&1)<<31)
-#define m_MCU_PIX_TOTAL				(0x3f<<0)
-#define m_MCU_CS_PST				(0xf<<6)
-#define m_MCU_CS_PEND				(0x3f<<10)
-#define m_MCU_RW_PST				(0xf<<16)
-#define m_MCU_RW_PEND				(0x3f<<20)
-#define m_MCU_CLK_SEL				(1<<26)
-#define m_MCU_HOLD_MODE				(1<<27)
-#define m_MCU_FRAME_ST				(1<<28)
-#define m_MCU_RS				(1<<29)
-#define m_MCU_BYPASS				(1<<30)
-#define m_MCU_TYPE				((u32)1<<31)
-
-#define LINE_FLAG_RK3368		(0x0020)/*rk3368*/
-#define LINE_FLAG_RK3366		(0x02a0)/*rk3366*/
-#define m_DSP_LINE_FLAG0_NUM			(0x1fff<<0)
-#define m_DSP_LINE_FLAG1_NUM			(0x1fff<<16)
-#define v_DSP_LINE_FLAG0_NUM(x)			(((x)&0x1fff)<<0)
-#define v_DSP_LINE_FLAG1_NUM(x)			(((x)&0x1fff)<<16)
-
-#define INTR_EN_RK3368			(0x0024)/*for rk3368*/
-#define INTR_EN_RK3366			(0x0280)/*for rk3366*/
-#define v_FS_INTR_EN(x)				((((x)&1)<<0) | ((1<<(0+16))))
-#define v_FS_NEW_INTR_EN(x)			((((x)&1)<<1) | ((1<<(1+16))))
-#define v_ADDR_SAME_INTR_EN(x)			((((x)&1)<<2) | ((1<<(2+16))))
-#define v_LINE_FLAG0_INTR_EN(x)			((((x)&1)<<3) | ((1<<(3+16))))
-#define v_LINE_FLAG1_INTR_EN(x)			((((x)&1)<<4) | ((1<<(4+16))))
-#define v_BUS_ERROR_INTR_EN(x)			((((x)&1)<<5) | ((1<<(5+16))))
-#define v_WIN0_EMPTY_INTR_EN(x)			((((x)&1)<<6) | ((1<<(6+16))))
-#define v_WIN1_EMPTY_INTR_EN(x)			((((x)&1)<<7) | ((1<<(7+16))))
-#define v_WIN2_EMPTY_INTR_EN(x)			((((x)&1)<<8) | ((1<<(8+16))))
-#define v_WIN3_EMPTY_INTR_EN(x)			((((x)&1)<<9) | ((1<<(9+16))))
-#define v_HWC_EMPTY_INTR_EN(x)		((((x)&1)<<10) | ((1<<(10+16))))
-#define v_POST_BUF_EMPTY_INTR_EN(x)	((((x)&1)<<11) | ((1<<(11+16))))
-#define v_PWM_GEN_INTR_EN(x)		((((x)&1)<<12) | ((1<<(12+16))))
-#define v_DSP_HOLD_VALID_INTR_EN(x)	((((x)&1)<<13) | ((1<<(13+16))))
-#define v_INTR_MMU_EN(x)		((((x)&1)<<14) | ((1<<(14+16))))/*rk3366*/
-#define v_INTR_DMA_FINISH_EN(x)		((((x)&1)<<15) | ((1<<(15+16))))/*rk3366*/
-
-#define m_FS_INTR_EN				((1<<0) | ((1<<(0+16))))
-#define m_FS_NEW_INTR_EN			((1<<1) | ((1<<(1+16))))
-#define m_ADDR_SAME_INTR_EN			((1<<2) | ((1<<(2+16))))
-#define m_LINE_FLAG0_INTR_EN			((1<<3) | ((1<<(3+16))))
-#define m_LINE_FLAG1_INTR_EN			((1<<4) | ((1<<(4+16))))
-#define m_BUS_ERROR_INTR_EN			((1<<5) | ((1<<(5+16))))
-#define m_WIN0_EMPTY_INTR_EN			((1<<6) | ((1<<(6+16))))
-#define m_WIN1_EMPTY_INTR_EN			((1<<7) | ((1<<(7+16))))
-#define m_WIN2_EMPTY_INTR_EN			((1<<8) | ((1<<(8+16))))
-#define m_WIN3_EMPTY_INTR_EN			((1<<9) | ((1<<(9+16))))
-#define m_HWC_EMPTY_INTR_EN			((1<<10) | ((1<<(10+16))))
-#define m_POST_BUF_EMPTY_INTR_EN		((1<<11) | ((1<<(11+16))))
-#define m_PWM_GEN_INTR_EN			((1<<12) | ((1<<(12+16))))
-#define m_DSP_HOLD_VALID_INTR_EN		((1<<13) | ((1<<(13+16))))
-#define m_INTR_MMU_EN			((1<<14) | ((1<<(14+16))))/*rk3366*/
-#define m_INTR_DMA_FINISH_EN		((1<<15) | ((1<<(15+16))))/*rk3366*/
-
-#define INTR_CLEAR_RK3368		(0x0028)/*rk3368*/
-#define INTR_CLEAR_RK3366		(0x0284)/*rk3366*/
-#define v_FS_INTR_CLR(x)			((((x)&1)<<0) | (1<<(0+16)))
-#define v_FS_NEW_INTR_CLR(x)			((((x)&1)<<1) | (1<<(1+16)))
-#define v_ADDR_SAME_INTR_CLR(x)			((((x)&1)<<2) | (1<<(2+16)))
-#define v_LINE_FLAG0_INTR_CLR(x)		((((x)&1)<<3) | (1<<(3+16)))
-#define v_LINE_FLAG1_INTR_CLR(x)		((((x)&1)<<4) | (1<<(4+16)))
-#define v_BUS_ERROR_INTR_CLR(x)			((((x)&1)<<5) | (1<<(5+16)))
-#define v_WIN0_EMPTY_INTR_CLR(x)		((((x)&1)<<6) | (1<<(6+16)))
-#define v_WIN1_EMPTY_INTR_CLR(x)		((((x)&1)<<7) | (1<<(7+16)))
-#define v_WIN2_EMPTY_INTR_CLR(x)		((((x)&1)<<8) | (1<<(8+16)))
-#define v_WIN3_EMPTY_INTR_CLR(x)		((((x)&1)<<9) | (1<<(9+16)))
-#define v_HWC_EMPTY_INTR_CLR(x)			((((x)&1)<<10) | (1<<(10+16)))
-#define v_POST_BUF_EMPTY_INTR_CLR(x)		((((x)&1)<<11) | (1<<(11+16)))
-#define v_PWM_GEN_INTR_CLR(x)			((((x)&1)<<12) | (1<<(12+16)))
-#define v_DSP_HOLD_VALID_INTR_CLR(x)		((((x)&1)<<13) | (1<<(13+16)))
-#define v_INTR_MMU_CLR(x)			((((x)&1)<<14) | ((1<<(14+16))))/*rk3366*/
-#define v_INTR_DMA_FINISH_CLR(x)		((((x)&1)<<15) | ((1<<(15+16))))/*rk3366*/
-
-#define m_FS_INTR_CLR				((1<<0) | ((1<<(0+16))))
-#define m_FS_NEW_INTR_CLR			((1<<1) | ((1<<(1+16))))
-#define m_ADDR_SAME_INTR_CLR			((1<<2) | ((1<<(2+16))))
-#define m_LINE_FLAG0_INTR_CLR			((1<<3) | ((1<<(3+16))))
-#define m_LINE_FLAG1_INTR_CLR			((1<<4) | ((1<<(4+16))))
-#define m_BUS_ERROR_INTR_CLR			((1<<5) | ((1<<(5+16))))
-#define m_WIN0_EMPTY_INTR_CLR			((1<<6) | ((1<<(5+16))))
-#define m_WIN1_EMPTY_INTR_CLR			((1<<7) | ((1<<(7+16))))
-#define m_WIN2_EMPTY_INTR_CLR			((1<<8) | ((1<<(8+16))))
-#define m_WIN3_EMPTY_INTR_CLR			((1<<9) | ((1<<(9+16))))
-#define m_HWC_EMPTY_INTR_CLR			((1<<10) | ((1<<(10+16))))
-#define m_POST_BUF_EMPTY_INTR_CLR		((1<<11) | ((1<<(11+16))))
-#define m_PWM_GEN_INTR_CLR			((1<<12) | ((1<<(12+16))))
-#define m_DSP_HOLD_VALID_INTR_CLR		((1<<13) | ((1<<(13+16))))
-#define m_INTR_MMU_CLEAR			((1<<14) | ((1<<(14+16))))/*rk3366*/
-#define m_INTR_DMA_FINISH_CLEAR			((1<<15) | ((1<<(15+16))))/*rk3366*/
-
-#define INTR_STATUS_RK3368		(0x002c)/*rk3366*/
-#define INTR_STATUS_RK3366		(0x0288)/*rk3366*/
-#define m_FS_INTR_STS				(1<<0)
-#define m_FS_NEW_INTR_STS			(1<<1)
-#define m_ADDR_SAME_INTR_STS			(1<<2)
-#define m_LINE_FLAG0_INTR_STS			(1<<3)
-#define m_LINE_FLAG1_INTR_STS			(1<<4)
-#define m_BUS_ERROR_INTR_STS			(1<<5)
-#define m_WIN0_EMPTY_INTR_STS			(1<<6)
-#define m_WIN1_EMPTY_INTR_STS			(1<<7)
-#define m_WIN2_EMPTY_INTR_STS			(1<<8)
-#define m_WIN3_EMPTY_INTR_STS			(1<<9)
-#define m_HWC_EMPTY_INTR_STS			(1<<10)
-#define m_POST_BUF_EMPTY_INTR_STS		(1<<11)
-#define m_PWM_GEN_INTR_STS			(1<<12)
-#define m_DSP_HOLD_VALID_INTR_STS		(1<<13)
-#define m_INTR_MMU_STS				(1<<14)/*rk3366*/
-#define m_INTR_DMA_FINISH_STS			(1<<15)/*rk3366*/
-
-#define m_FS_INTR_RAWSTS			(1<<(0+16))
-#define m_FS_NEW_INTR_RAWSTS			(1<<(1+16))
-#define m_ADDR_SAME_INTR_RAWSTS			(1<<(2+16))
-#define m_LINE_FLAG0_INTR_RAWSTS		(1<<(3+16))
-#define m_LINE_FLAG1_INTR_RAWSTS		(1<<(4+16))
-#define m_BUS_ERROR_INTR_RAWSTS			(1<<(5+16))
-#define m_WIN0_EMPTY_INTR_RAWSTS		(1<<(6+16))
-#define m_WIN1_EMPTY_INTR_RAWSTS		(1<<(7+16))
-#define m_WIN2_EMPTY_INTR_RAWSTS		(1<<(8+16))
-#define m_WIN3_EMPTY_INTR_RAWSTS		(1<<(9+16))
-#define m_HWC_EMPTY_INTR_RAWSTS			(1<<(10+16))
-#define m_POST_BUF_EMPTY_INTR_RAWSTS		(1<<(11+16))
-#define m_PWM_GEN_INTR_RAWSTS			(1<<(12+16))
-#define m_DSP_HOLD_VALID_INTR_RAWSTS		(1<<(13+16))
-
-#define INTR_RAW_STATUS_RK3366		(0x028c)/*rk3366*/
-#define m_FS_INTR_RAWSTS_RK3366			(1<<0)/*rk3366*/
-#define m_FS_NEW_INTR_RAWSTS_RK3366		(1<<1)/*rk3366*/
-#define m_ADDR_SAME_INTR_RAWSTS_RK3366		(1<<2)/*rk3366*/
-#define m_LINE_FLAG0_INTR_RAWSTS_RK3366		(1<<3)/*rk3366*/
-#define m_LINE_FLAG1_INTR_RAWSTS_RK3366		(1<<4)/*rk3366*/
-#define m_BUS_ERROR_INTR_RAWSTS_RK3366		(1<<5)/*rk3366*/
-#define m_WIN0_EMPTY_INTR_RAWSTS_RK3366		(1<<6)/*rk3366*/
-#define m_WIN1_EMPTY_INTR_RAWSTS_RK3366		(1<<7)/*rk3366*/
-#define m_WIN2_EMPTY_INTR_RAWSTS_RK3366		(1<<8)/*rk3366*/
-#define m_WIN3_EMPTY_INTR_RAWSTS_RK3366		(1<<9)/*rk3366*/
-#define m_HWC_EMPTY_INTR_RAWSTS_RK3366		(1<<10)/*rk3366*/
-#define m_POST_BUF_EMPTY_INTR_RAWSTS_RK3366	(1<<11)/*rk3366*/
-#define m_PWM_GEN_INTR_RAWSTS_RK3366		(1<<12)/*rk3366*/
-#define m_DSP_HOLD_VALID_INTR_RAWSTS_RK3366	(1<<13)/*rk3366*/
-#define m_INTR_MMU_RAWSTS_RK3366		(1<<14)/*rk3366*/
-#define m_INTR_DMA_FINISH_RAWSTS_RK3366		(1<<15)/*rk3366*/
-
-/********************rk3366 write back register************************/
-#define WB_CTRL0			(0x0020)
-#define v_WB_EN(x)				(((x)&0x1)<<0)
-#define v_WB_FMT(x)				(((x)&0x7)<<1)
-#define v_WB_DITHER_EN(x)			(((x)&0x1)<<4)
-#define v_WB_RGB2YUV_EN(x)			(((x)&0x1)<<5)
-#define v_WB_RGB2YUV_MODE(x)			(((x)&0x1)<<6)
-#define v_WB_XPSD_BIL_EN(x)			(((x)&0x1)<<7)
-#define v_WB_YTHROW_EN(x)			(((x)&0x1)<<8)
-#define v_WB_YTHROW_MODE(x)			(((x)&0x1)<<9)
-#define v_WB_HANDSHAKE_MODE(x)			(((x)&0x1)<<11)
-#define v_WB_YRGB_ID(x)				(((x)&0xf)<<24)
-#define v_WB_UI_ID(x)				(((x)&0xf)<<28)
-#define m_WB_EN					(0x1<<0)
-#define m_WB_FMT				(0x7<<1)
-#define m_WB_DITHER_EN				(0x1<<4)
-#define m_WB_RGB2YUV_EN				(0x1<<5)
-#define m_WB_RGB2YUV_MODE			(0x1<<6)
-#define m_WB_XPSD_BIL_EN			(0x1<<7)
-#define m_WB_YTHROW_EN				(0x1<<8)
-#define m_WB_YTHROW_MODE			(0x1<<9)
-#define m_WB_HANDSHAKE_MODE			(0x1<<11)
-#define m_WB_YRGB_ID				(0xf<<24)
-#define m_WB_UI_ID				(0xf<<28)
-#define WB_CTRL1			(0x0024)
-#define v_WB_WIDTH(x)				(((x)&0xfff)<<0)
-#define v_WB_XPSD_BIL_FACTOR(x)			(((x)&0x3fff)<<16)
-#define m_WB_WIDTH				(0xfff<<0)
-#define m_WB_XPSD_BIL_FACTOR			(0x3fff<<16)
-#define WB_YRGB_MST                     (0x0028)
-#define WB_CBR_MST                      (0x002c)
-/********************rk3366 write back register************************/
-
-/*win0 register*/
-#define WIN0_CTRL0			(0x0030)
-#define v_WIN0_EN(x)				(((x)&1)<<0)
-#define v_WIN0_DATA_FMT(x)			(((x)&7)<<1)
-#define v_WIN0_FMT_10(x)			(((x)&1)<<4)
-#define v_WIN0_LB_MODE(x)			(((x)&7)<<5)
-#define v_WIN0_INTERLACE_READ(x)		(((x)&1)<<8)
-#define v_WIN0_NO_OUTSTANDING(x)		(((x)&1)<<9)
-#define v_WIN0_CSC_MODE(x)			(((x)&3)<<10)
-#define v_WIN0_RB_SWAP(x)			(((x)&1)<<12)
-#define v_WIN0_ALPHA_SWAP(x)			(((x)&1)<<13)
-#define v_WIN0_MID_SWAP(x)			(((x)&1)<<14)
-#define v_WIN0_UV_SWAP(x)			(((x)&1)<<15)
-#define v_WIN0_HW_PRE_MUL_EN(x)			(((x)&1)<<16)
-#define v_WIN0_YRGB_DEFLICK(x)			(((x)&1)<<18)
-#define v_WIN0_CBR_DEFLICK(x)			(((x)&1)<<19)
-#define v_WIN0_YUV_CLIP(x)			(((x)&1)<<20)
-#define v_WIN0_X_MIRROR(x)			(((x)&1)<<21)
-#define v_WIN0_Y_MIRROR(x)			(((x)&1)<<22)
-#define v_WIN0_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<24)
-#define v_WIN0_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<25)
-#define v_WIN0_DMA_BURST_LENGTH(x)		(((x)&0x3)<<30)
-
-#define m_WIN0_EN				(1<<0)
-#define m_WIN0_DATA_FMT				(7<<1)
-#define m_WIN0_FMT_10				(1<<4)
-#define m_WIN0_LB_MODE				(7<<5)
-#define m_WIN0_INTERLACE_READ			(1<<8)
-#define m_WIN0_NO_OUTSTANDING			(1<<9)
-#define m_WIN0_CSC_MODE				(3<<10)
-#define m_WIN0_RB_SWAP				(1<<12)
-#define m_WIN0_ALPHA_SWAP			(1<<13)
-#define m_WIN0_MID_SWAP				(1<<14)
-#define m_WIN0_UV_SWAP				(1<<15)
-#define m_WIN0_HW_PRE_MUL_EN			(1<<16)
-#define m_WIN0_YRGB_DEFLICK			(1<<18)
-#define m_WIN0_CBR_DEFLICK			(1<<19)
-#define m_WIN0_YUV_CLIP				(1<<20)
-#define m_WIN0_X_MIRROR				(1<<21)
-#define m_WIN0_Y_MIRROR				(1<<22)
-#define m_WIN0_AXI_MAX_OUTSTANDING_EN		(1<<24)
-#define m_WIN0_AXI_OUTSTANDING_MAX_NUM		(0x1f<<25)
-#define m_WIN0_DMA_BURST_LENGTH			(0x3<<30)
-
-#define WIN0_CTRL1			(0x0034)
-#define v_WIN0_YRGB_AXI_GATHER_EN(x)		(((x)&1)<<0)
-#define v_WIN0_CBR_AXI_GATHER_EN(x)		(((x)&1)<<1)
-#define v_WIN0_BIC_COE_SEL(x)			(((x)&3)<<2)
-#define v_WIN0_VSD_YRGB_GT4(x)			(((x)&1)<<4)
-#define v_WIN0_VSD_YRGB_GT2(x)			(((x)&1)<<5)
-#define v_WIN0_VSD_CBR_GT4(x)			(((x)&1)<<6)
-#define v_WIN0_VSD_CBR_GT2(x)			(((x)&1)<<7)
-#define v_WIN0_YRGB_AXI_GATHER_NUM(x)		(((x)&0xf)<<8)
-#define v_WIN0_CBR_AXI_GATHER_NUM(x)		(((x)&7)<<12)
-#define v_WIN0_LINE_LOAD_MODE(x)		(((x)&1)<<15)
-#define v_WIN0_YRGB_HOR_SCL_MODE(x)		(((x)&3)<<16)
-#define v_WIN0_YRGB_VER_SCL_MODE(x)		(((x)&3)<<18)
-#define v_WIN0_YRGB_HSD_MODE(x)			(((x)&3)<<20)
-#define v_WIN0_YRGB_VSU_MODE(x)			(((x)&1)<<22)
-#define v_WIN0_YRGB_VSD_MODE(x)			(((x)&1)<<23)
-#define v_WIN0_CBR_HOR_SCL_MODE(x)		(((x)&3)<<24)
-#define v_WIN0_CBR_VER_SCL_MODE(x)		(((x)&3)<<26)
-#define v_WIN0_CBR_HSD_MODE(x)			(((x)&3)<<28)
-#define v_WIN0_CBR_VSU_MODE(x)			(((x)&1)<<30)
-#define v_WIN0_CBR_VSD_MODE(x)			(((x)&1)<<31)
-
-#define m_WIN0_YRGB_AXI_GATHER_EN		(1<<0)
-#define m_WIN0_CBR_AXI_GATHER_EN		(1<<1)
-#define m_WIN0_BIC_COE_SEL			(3<<2)
-#define m_WIN0_VSD_YRGB_GT4			(1<<4)
-#define m_WIN0_VSD_YRGB_GT2			(1<<5)
-#define m_WIN0_VSD_CBR_GT4			(1<<6)
-#define m_WIN0_VSD_CBR_GT2			(1<<7)
-#define m_WIN0_YRGB_AXI_GATHER_NUM		(0xf<<8)
-#define m_WIN0_CBR_AXI_GATHER_NUM		(7<<12)
-#define m_WIN0_LINE_LOAD_MODE			(1<<15)
-#define m_WIN0_YRGB_HOR_SCL_MODE		(3<<16)
-#define m_WIN0_YRGB_VER_SCL_MODE		(3<<18)
-#define m_WIN0_YRGB_HSD_MODE			(3<<20)
-#define m_WIN0_YRGB_VSU_MODE			(1<<22)
-#define m_WIN0_YRGB_VSD_MODE			(1<<23)
-#define m_WIN0_CBR_HOR_SCL_MODE			(3<<24)
-#define m_WIN0_CBR_VER_SCL_MODE			(3<<26)
-#define m_WIN0_CBR_HSD_MODE			(3<<28)
-#define m_WIN0_CBR_VSU_MODE			((u32)1<<30)
-#define m_WIN0_CBR_VSD_MODE			((u32)1<<31)
-
-#define WIN0_COLOR_KEY			(0x0038)
-#define v_WIN0_COLOR_KEY(x)			(((x)&0x3fffffff)<<0)
-#define v_WIN0_COLOR_KEY_EN(x)			(((x)&1)<<31)
-#define m_WIN0_COLOR_KEY			(0x3fffffff<<0)
-#define m_WIN0_COLOR_KEY_EN			((u32)1<<31)
-
-#define WIN0_VIR			(0x003c)
-#define v_WIN0_VIR_STRIDE(x)			(((x)&0xffff)<<0)
-#define v_WIN0_VIR_STRIDE_UV(x)			(((x)&0xffff)<<16)
-#define m_WIN0_VIR_STRIDE			(0xffff<<0)
-#define m_WIN0_VIR_STRIDE_UV			(0xffff<<16)
-
-#define WIN0_YRGB_MST			(0x0040)
-#define WIN0_CBR_MST			(0x0044)
-#define WIN0_ACT_INFO			(0x0048)
-#define v_WIN0_ACT_WIDTH(x)			(((x-1)&0x1fff)<<0)
-#define v_WIN0_ACT_HEIGHT(x)			(((x-1)&0x1fff)<<16)
-#define m_WIN0_ACT_WIDTH			(0x1fff<<0)
-#define m_WIN0_ACT_HEIGHT			(0x1fff<<16)
-
-#define WIN0_DSP_INFO			(0x004c)
-#define v_WIN0_DSP_WIDTH(x)			(((x-1)&0xfff)<<0)
-#define v_WIN0_DSP_HEIGHT(x)			(((x-1)&0xfff)<<16)
-#define m_WIN0_DSP_WIDTH			(0xfff<<0)
-#define m_WIN0_DSP_HEIGHT			(0xfff<<16)
-
-#define WIN0_DSP_ST			(0x0050)
-#define v_WIN0_DSP_XST(x)			(((x)&0x1fff)<<0)
-#define v_WIN0_DSP_YST(x)			(((x)&0x1fff)<<16)
-#define m_WIN0_DSP_XST				(0x1fff<<0)
-#define m_WIN0_DSP_YST				(0x1fff<<16)
-
-#define WIN0_SCL_FACTOR_YRGB		(0x0054)
-#define v_WIN0_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
-#define v_WIN0_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
-#define m_WIN0_HS_FACTOR_YRGB			(0xffff<<0)
-#define m_WIN0_VS_FACTOR_YRGB			((u32)0xffff<<16)
-
-#define WIN0_SCL_FACTOR_CBR		(0x0058)
-#define v_WIN0_HS_FACTOR_CBR(x)			(((x)&0xffff)<<0)
-#define v_WIN0_VS_FACTOR_CBR(x)			(((x)&0xffff)<<16)
-#define m_WIN0_HS_FACTOR_CBR			(0xffff<<0)
-#define m_WIN0_VS_FACTOR_CBR			((u32)0xffff<<16)
-
-#define WIN0_SCL_OFFSET			(0x005c)
-#define v_WIN0_HS_OFFSET_YRGB(x)		(((x)&0xff)<<0)
-#define v_WIN0_HS_OFFSET_CBR(x)			(((x)&0xff)<<8)
-#define v_WIN0_VS_OFFSET_YRGB(x)		(((x)&0xff)<<16)
-#define v_WIN0_VS_OFFSET_CBR(x)			(((x)&0xff)<<24)
-
-#define m_WIN0_HS_OFFSET_YRGB			(0xff<<0)
-#define m_WIN0_HS_OFFSET_CBR			(0xff<<8)
-#define m_WIN0_VS_OFFSET_YRGB			(0xff<<16)
-#define m_WIN0_VS_OFFSET_CBR			((u32)0xff<<24)
-
-#define WIN0_SRC_ALPHA_CTRL		(0x0060)
-#define v_WIN0_SRC_ALPHA_EN(x)			(((x)&1)<<0)
-#define v_WIN0_SRC_COLOR_M0(x)			(((x)&1)<<1)
-#define v_WIN0_SRC_ALPHA_M0(x)			(((x)&1)<<2)
-#define v_WIN0_SRC_BLEND_M0(x)			(((x)&3)<<3)
-#define v_WIN0_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
-#define v_WIN0_SRC_FACTOR_M0(x)			(((x)&7)<<6)
-#define v_WIN0_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
-#define v_WIN0_FADING_VALUE(x)			(((x)&0xff)<<24)
-
-#define m_WIN0_SRC_ALPHA_EN			(1<<0)
-#define m_WIN0_SRC_COLOR_M0			(1<<1)
-#define m_WIN0_SRC_ALPHA_M0			(1<<2)
-#define m_WIN0_SRC_BLEND_M0			(3<<3)
-#define m_WIN0_SRC_ALPHA_CAL_M0			(1<<5)
-#define m_WIN0_SRC_FACTOR_M0			(7<<6)
-#define m_WIN0_SRC_GLOBAL_ALPHA			(0xff<<16)
-#define m_WIN0_FADING_VALUE			(0xff<<24)
-
-#define WIN0_DST_ALPHA_CTRL		(0x0064)
-#define v_WIN0_DST_FACTOR_M0(x)			(((x)&7)<<6)
-#define m_WIN0_DST_FACTOR_M0			(7<<6)
-
-#define WIN0_FADING_CTRL		(0x0068)
-#define v_WIN0_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
-#define v_WIN0_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
-#define v_WIN0_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
-#define v_WIN0_FADING_EN(x)			(((x)&1)<<24)
-
-#define m_WIN0_FADING_OFFSET_R			(0xff<<0)
-#define m_WIN0_FADING_OFFSET_G			(0xff<<8)
-#define m_WIN0_FADING_OFFSET_B			(0xff<<16)
-#define m_WIN0_FADING_EN			(1<<24)
-
-#define WIN0_CTRL2                     (0x006c)
-#define v_WIN_RID_WIN0_YRGB(x)			(((x)&0xf)<<0)
-#define v_WIN_RID_WIN0_CBR(x)			(((x)&0xf)<<4)
-#define m_WIN_RID_WIN0_YRGB			((0xf)<<0)
-#define m_WIN_RID_WIN0_CBR			((0xf)<<4)
-/*win1 register*/
-#define WIN1_CTRL0			(0x0070)
-#define v_WIN1_EN(x)				(((x)&1)<<0)
-#define v_WIN1_DATA_FMT(x)			(((x)&7)<<1)
-#define v_WIN1_FMT_10(x)			(((x)&1)<<4)
-#define v_WIN1_LB_MODE(x)			(((x)&7)<<5)
-#define v_WIN1_INTERLACE_READ(x)		(((x)&1)<<8)
-#define v_WIN1_NO_OUTSTANDING(x)		(((x)&1)<<9)
-#define v_WIN1_CSC_MODE(x)			(((x)&3)<<10)
-#define v_WIN1_RB_SWAP(x)			(((x)&1)<<12)
-#define v_WIN1_ALPHA_SWAP(x)			(((x)&1)<<13)
-#define v_WIN1_MID_SWAP(x)			(((x)&1)<<14)
-#define v_WIN1_UV_SWAP(x)			(((x)&1)<<15)
-#define v_WIN1_HW_PRE_MUL_EN(x)			(((x)&1)<<16)
-#define v_WIN1_YRGB_DEFLICK(x)			(((x)&1)<<18)
-#define v_WIN1_CBR_DEFLICK(x)			(((x)&1)<<19)
-#define v_WIN1_YUV_CLIP(x)			(((x)&1)<<20)
-#define v_WIN1_X_MIRROR(x)			(((x)&1)<<21)
-#define v_WIN1_Y_MIRROR(x)			(((x)&1)<<22)
-#define v_WIN1_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<24)
-#define v_WIN1_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<25)
-#define v_WIN1_DMA_BURST_LENGTH(x)		(((x)&0x3)<<30)
-#define m_WIN1_EN				(1<<0)
-#define m_WIN1_DATA_FMT				(7<<1)
-#define m_WIN1_FMT_10				(1<<4)
-#define m_WIN1_LB_MODE				(7<<5)
-#define m_WIN1_INTERLACE_READ			(1<<8)
-#define m_WIN1_NO_OUTSTANDING			(1<<9)
-#define m_WIN1_CSC_MODE				(3<<10)
-#define m_WIN1_RB_SWAP				(1<<12)
-#define m_WIN1_ALPHA_SWAP			(1<<13)
-#define m_WIN1_MID_SWAP				(1<<14)
-#define m_WIN1_UV_SWAP				(1<<15)
-#define m_WIN1_HW_PRE_MUL_EN			(1<<16)
-#define m_WIN1_YRGB_DEFLICK			(1<<18)
-#define m_WIN1_CBR_DEFLICK			(1<<19)
-#define m_WIN1_YUV_CLIP				(1<<20)
-#define m_WIN1_X_MIRROR				(1<<21)
-#define m_WIN1_Y_MIRROR				(1<<22)
-#define m_WIN1_AXI_MAX_OUTSTANDING_EN		(1<<24)
-#define m_WIN1_AXI_OUTSTANDING_MAX_NUM		(0x1f<<25)
-#define m_WIN1_DMA_BURST_LENGTH			(0x3<<30)
-
-#define WIN1_CTRL1			(0x0074)
-#define v_WIN1_YRGB_AXI_GATHER_EN(x)		(((x)&1)<<0)
-#define v_WIN1_CBR_AXI_GATHER_EN(x)		(((x)&1)<<1)
-#define v_WIN1_BIC_COE_SEL(x)			(((x)&3)<<2)
-#define v_WIN1_VSD_YRGB_GT4(x)			(((x)&1)<<4)
-#define v_WIN1_VSD_YRGB_GT2(x)			(((x)&1)<<5)
-#define v_WIN1_VSD_CBR_GT4(x)			(((x)&1)<<6)
-#define v_WIN1_VSD_CBR_GT2(x)			(((x)&1)<<7)
-#define v_WIN1_YRGB_AXI_GATHER_NUM(x)		(((x)&0xf)<<8)
-#define v_WIN1_CBR_AXI_GATHER_NUM(x)		(((x)&7)<<12)
-#define v_WIN1_LINE_LOAD_MODE(x)		(((x)&1)<<15)
-#define v_WIN1_YRGB_HOR_SCL_MODE(x)		(((x)&3)<<16)
-#define v_WIN1_YRGB_VER_SCL_MODE(x)		(((x)&3)<<18)
-#define v_WIN1_YRGB_HSD_MODE(x)			(((x)&3)<<20)
-#define v_WIN1_YRGB_VSU_MODE(x)			(((x)&1)<<22)
-#define v_WIN1_YRGB_VSD_MODE(x)			(((x)&1)<<23)
-#define v_WIN1_CBR_HOR_SCL_MODE(x)		(((x)&3)<<24)
-#define v_WIN1_CBR_VER_SCL_MODE(x)		(((x)&3)<<26)
-#define v_WIN1_CBR_HSD_MODE(x)			(((x)&3)<<28)
-#define v_WIN1_CBR_VSU_MODE(x)			(((x)&1)<<30)
-#define v_WIN1_CBR_VSD_MODE(x)			(((x)&1)<<31)
-
-#define m_WIN1_YRGB_AXI_GATHER_EN		(1<<0)
-#define m_WIN1_CBR_AXI_GATHER_EN		(1<<1)
-#define m_WIN1_BIC_COE_SEL			(3<<2)
-#define m_WIN1_VSD_YRGB_GT4			(1<<4)
-#define m_WIN1_VSD_YRGB_GT2			(1<<5)
-#define m_WIN1_VSD_CBR_GT4			(1<<6)
-#define m_WIN1_VSD_CBR_GT2			(1<<7)
-#define m_WIN1_YRGB_AXI_GATHER_NUM		(0xf<<8)
-#define m_WIN1_CBR_AXI_GATHER_NUM		(7<<12)
-#define m_WIN1_LINE_LOAD_MODE			(1<<15)
-#define m_WIN1_YRGB_HOR_SCL_MODE		(3<<16)
-#define m_WIN1_YRGB_VER_SCL_MODE		(3<<18)
-#define m_WIN1_YRGB_HSD_MODE			(3<<20)
-#define m_WIN1_YRGB_VSU_MODE			(1<<22)
-#define m_WIN1_YRGB_VSD_MODE			(1<<23)
-#define m_WIN1_CBR_HOR_SCL_MODE			(3<<24)
-#define m_WIN1_CBR_VER_SCL_MODE			(3<<26)
-#define m_WIN1_CBR_HSD_MODE			(3<<28)
-#define m_WIN1_CBR_VSU_MODE			(1<<30)
-#define m_WIN1_CBR_VSD_MODE			((u32)1<<31)
-
-#define WIN1_COLOR_KEY			(0x0078)
-#define v_WIN1_COLOR_KEY(x)			(((x)&0x3fffffff)<<0)
-#define v_WIN1_COLOR_KEY_EN(x)			(((x)&1)<<31)
-#define m_WIN1_COLOR_KEY			(0x3fffffff<<0)
-#define m_WIN1_COLOR_KEY_EN			((u32)1<<31)
-
-#define WIN1_VIR			(0x007c)
-#define v_WIN1_VIR_STRIDE(x)			(((x)&0xffff)<<0)
-#define v_WIN1_VIR_STRIDE_UV(x)			(((x)&0xffff)<<16)
-#define m_WIN1_VIR_STRIDE			(0xffff<<0)
-#define m_WIN1_VIR_STRIDE_UV			(0xffff<<16)
-
-#define WIN1_YRGB_MST			(0x0080)
-#define WIN1_CBR_MST			(0x0084)
-#define WIN1_ACT_INFO			(0x0088)
-#define v_WIN1_ACT_WIDTH(x)			(((x-1)&0x1fff)<<0)
-#define v_WIN1_ACT_HEIGHT(x)			(((x-1)&0x1fff)<<16)
-#define m_WIN1_ACT_WIDTH			(0x1fff<<0)
-#define m_WIN1_ACT_HEIGHT			(0x1fff<<16)
-
-#define WIN1_DSP_INFO			(0x008c)
-#define v_WIN1_DSP_WIDTH(x)			(((x-1)&0xfff)<<0)
-#define v_WIN1_DSP_HEIGHT(x)			(((x-1)&0xfff)<<16)
-#define m_WIN1_DSP_WIDTH			(0xfff<<0)
-#define m_WIN1_DSP_HEIGHT			(0xfff<<16)
-
-#define WIN1_DSP_ST			(0x0090)
-#define v_WIN1_DSP_XST(x)			(((x)&0x1fff)<<0)
-#define v_WIN1_DSP_YST(x)			(((x)&0x1fff)<<16)
-#define m_WIN1_DSP_XST				(0x1fff<<0)
-#define m_WIN1_DSP_YST				(0x1fff<<16)
-
-#define WIN1_SCL_FACTOR_YRGB		(0x0094)
-#define v_WIN1_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
-#define v_WIN1_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
-#define m_WIN1_HS_FACTOR_YRGB			(0xffff<<0)
-#define m_WIN1_VS_FACTOR_YRGB			((u32)0xffff<<16)
-
-#define WIN1_SCL_FACTOR_CBR		(0x0098)
-#define v_WIN1_HS_FACTOR_CBR(x)			(((x)&0xffff)<<0)
-#define v_WIN1_VS_FACTOR_CBR(x)			(((x)&0xffff)<<16)
-#define m_WIN1_HS_FACTOR_CBR			(0xffff<<0)
-#define m_WIN1_VS_FACTOR_CBR			((u32)0xffff<<16)
-
-#define WIN1_SCL_OFFSET			(0x009c)
-#define v_WIN1_HS_OFFSET_YRGB(x)		(((x)&0xff)<<0)
-#define v_WIN1_HS_OFFSET_CBR(x)			(((x)&0xff)<<8)
-#define v_WIN1_VS_OFFSET_YRGB(x)		(((x)&0xff)<<16)
-#define v_WIN1_VS_OFFSET_CBR(x)			(((x)&0xff)<<24)
-
-#define m_WIN1_HS_OFFSET_YRGB			(0xff<<0)
-#define m_WIN1_HS_OFFSET_CBR			(0xff<<8)
-#define m_WIN1_VS_OFFSET_YRGB			(0xff<<16)
-#define m_WIN1_VS_OFFSET_CBR			((u32)0xff<<24)
-
-#define WIN1_SRC_ALPHA_CTRL		(0x00a0)
-#define v_WIN1_SRC_ALPHA_EN(x)			(((x)&1)<<0)
-#define v_WIN1_SRC_COLOR_M0(x)			(((x)&1)<<1)
-#define v_WIN1_SRC_ALPHA_M0(x)			(((x)&1)<<2)
-#define v_WIN1_SRC_BLEND_M0(x)			(((x)&3)<<3)
-#define v_WIN1_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
-#define v_WIN1_SRC_FACTOR_M0(x)			(((x)&7)<<6)
-#define v_WIN1_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
-#define v_WIN1_FADING_VALUE(x)			(((x)&0xff)<<24)
-
-#define m_WIN1_SRC_ALPHA_EN			(1<<0)
-#define m_WIN1_SRC_COLOR_M0			(1<<1)
-#define m_WIN1_SRC_ALPHA_M0			(1<<2)
-#define m_WIN1_SRC_BLEND_M0			(3<<3)
-#define m_WIN1_SRC_ALPHA_CAL_M0			(1<<5)
-#define m_WIN1_SRC_FACTOR_M0			(7<<6)
-#define m_WIN1_SRC_GLOBAL_ALPHA			(0xff<<16)
-#define m_WIN1_FADING_VALUE			(0xff<<24)
-
-#define WIN1_DST_ALPHA_CTRL			(0x00a4)
-#define v_WIN1_DST_FACTOR_M0(x)			(((x)&7)<<6)
-#define m_WIN1_DST_FACTOR_M0			(7<<6)
-
-#define WIN1_FADING_CTRL		(0x00a8)
-#define v_WIN1_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
-#define v_WIN1_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
-#define v_WIN1_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
-#define v_WIN1_FADING_EN(x)			(((x)&1)<<24)
-
-#define m_WIN1_FADING_OFFSET_R			(0xff<<0)
-#define m_WIN1_FADING_OFFSET_G			(0xff<<8)
-#define m_WIN1_FADING_OFFSET_B			(0xff<<16)
-#define m_WIN1_FADING_EN			(1<<24)
-
-#define WIN1_CTRL2			(0xac)
-#define v_WIN_RID_WIN1_YRGB(x)			(((x)&0xf)<<0)
-#define v_WIN_RID_WIN1_CBR(x)			(((x)&0xf)<<4)
-#define m_WIN_RID_WIN1_YRGB			((0xf)<<0)
-#define m_WIN_RID_WIN1_CBR			((0xf)<<4)
-/*win2 register*/
-#define WIN2_CTRL0			(0x00b0)
-#define v_WIN2_EN(x)				(((x)&1)<<0)
-#define v_WIN2_INTERLACE_READ(x)		(((x)&1)<<1)
-#define v_WIN2_CSC_MODE(x)			(((x)&1)<<2)
-#define v_WIN2_MST0_EN(x)			(((x)&1)<<4)
-#define v_WIN2_DATA_FMT0(x)			(((x)&3)<<5)
-#define v_WIN2_MST1_EN(x)			(((x)&1)<<8)
-#define v_WIN2_DATA_FMT1(x)			(((x)&3)<<9)
-#define v_WIN2_MST2_EN(x)			(((x)&1)<<12)
-#define v_WIN2_DATA_FMT2(x)			(((x)&3)<<13)
-#define v_WIN2_MST3_EN(x)			(((x)&1)<<16)
-#define v_WIN2_DATA_FMT3(x)			(((x)&3)<<17)
-#define v_WIN2_RB_SWAP0(x)			(((x)&1)<<20)
-#define v_WIN2_ALPHA_SWAP0(x)			(((x)&1)<<21)
-#define v_WIN2_ENDIAN_SWAP0(x)			(((x)&1)<<22)
-#define v_WIN2_RB_SWAP1(x)			(((x)&1)<<23)
-#define v_WIN2_ALPHA_SWAP1(x)			(((x)&1)<<24)
-#define v_WIN2_ENDIAN_SWAP1(x)			(((x)&1)<<25)
-#define v_WIN2_RB_SWAP2(x)			(((x)&1)<<26)
-#define v_WIN2_ALPHA_SWAP2(x)			(((x)&1)<<27)
-#define v_WIN2_ENDIAN_SWAP2(x)			(((x)&1)<<28)
-#define v_WIN2_RB_SWAP3(x)			(((x)&1)<<29)
-#define v_WIN2_ALPHA_SWAP3(x)			(((x)&1)<<30)
-#define v_WIN2_ENDIAN_SWAP3(x)			(((x)&1)<<31)
-
-#define m_WIN2_EN				(1<<0)
-#define m_WIN2_INTERLACE_READ			(1<<1)
-#define m_WIN2_CSC_MODE				(1<<2)
-#define m_WIN2_MST0_EN				(1<<4)
-#define m_WIN2_DATA_FMT0			(3<<5)
-#define m_WIN2_MST1_EN				(1<<8)
-#define m_WIN2_DATA_FMT1			(3<<9)
-#define m_WIN2_MST2_EN				(1<<12)
-#define m_WIN2_DATA_FMT2			(3<<13)
-#define m_WIN2_MST3_EN				(1<<16)
-#define m_WIN2_DATA_FMT3			(3<<17)
-#define m_WIN2_RB_SWAP0				(1<<20)
-#define m_WIN2_ALPHA_SWAP0			(1<<21)
-#define m_WIN2_ENDIAN_SWAP0			(1<<22)
-#define m_WIN2_RB_SWAP1				(1<<23)
-#define m_WIN2_ALPHA_SWAP1			(1<<24)
-#define m_WIN2_ENDIAN_SWAP1			(1<<25)
-#define m_WIN2_RB_SWAP2				(1<<26)
-#define m_WIN2_ALPHA_SWAP2			(1<<27)
-#define m_WIN2_ENDIAN_SWAP2			(1<<28)
-#define m_WIN2_RB_SWAP3				(1<<29)
-#define m_WIN2_ALPHA_SWAP3			(1<<30)
-#define m_WIN2_ENDIAN_SWAP3			(1<<31)
-
-#define WIN2_CTRL1			(0x00b4)
-#define v_WIN2_AXI_GATHER_EN(x)			(((x)&1)<<0)
-#define v_WIN2_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<1)
-#define v_WIN2_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
-#define v_WIN2_AXI_GATHER_NUM(x)	        (((x)&0xf)<<4)
-#define v_WIN2_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
-#define v_WIN2_RGB2YUV_EN(x)			(((x)&1)<<13)
-#define v_WIN2_NO_OUTSTANDING(x)		(((x)&1)<<14)
-#define v_WIN2_Y_MIR(x)			        (((x)&1)<<15)
-#define v_WIN2_LUT_EN(x)		        (((x)&1)<<16)
-#define v_WIN_RID_WIN2(x)	                (((x)&0xf)<<20)
-
-#define m_WIN2_AXI_GATHER_EN			(1<<0)
-#define m_WIN2_AXI_MAX_OUTSTANDING_EN		(1<<1)
-#define m_WIN2_DMA_BURST_LENGTH			(0x3<<2)
-#define m_WIN2_AXI_GATHER_NUM			(0xf<<4)
-#define m_WIN2_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
-#define m_WIN2_RGB2YUV_EN			(1<<13)
-#define m_WIN2_NO_OUTSTANDING			(1<<14)
-#define m_WIN2_Y_MIR				(1<<15)
-#define m_WIN2_LUT_EN				(1<<16)
-#define m_WIN_RID_WIN2				(0xf<<20)
-
-#define WIN2_VIR0_1			(0x00b8)
-#define v_WIN2_VIR_STRIDE0(x)			(((x)&0xffff)<<0)
-#define v_WIN2_VIR_STRIDE1(x)			(((x)&0xffff)<<16)
-#define m_WIN2_VIR_STRIDE0			(((u32)0xffff)<<0)
-#define m_WIN2_VIR_STRIDE1			(((u32)0xffff)<<16)
-
-#define WIN2_VIR2_3			(0x00bc)
-#define v_WIN2_VIR_STRIDE2(x)			(((x)&0xffff)<<0)
-#define v_WIN2_VIR_STRIDE3(x)			(((x)&0xffff)<<16)
-#define m_WIN2_VIR_STRIDE2			(((u32)0xffff)<<0)
-#define m_WIN2_VIR_STRIDE3			(((u32)0xffff)<<16)
-
-#define WIN2_MST0			(0x00c0)
-#define WIN2_DSP_INFO0			(0x00c4)
-#define v_WIN2_DSP_WIDTH0(x)			(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT0(x)			(((x-1)&0xfff)<<16)
-#define m_WIN2_DSP_WIDTH0			(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT0			(0xfff<<16)
-
-#define WIN2_DSP_ST0			(0x00c8)
-#define v_WIN2_DSP_XST0(x)			(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST0(x)			(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST0				(0x1fff<<0)
-#define m_WIN2_DSP_YST0				(0x1fff<<16)
-
-#define WIN2_COLOR_KEY			(0x00cc)
-#define v_WIN2_COLOR_KEY(x)			(((x)&0xffffff)<<0)
-#define v_WIN2_KEY_EN(x)			(((x)&1)<<24)
-#define m_WIN2_COLOR_KEY			(0xffffff<<0)
-#define m_WIN2_KEY_EN				((u32)1<<24)
-
-
-#define WIN2_MST1			(0x00d0)
-#define WIN2_DSP_INFO1			(0x00d4)
-#define v_WIN2_DSP_WIDTH1(x)			(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT1(x)			(((x-1)&0xfff)<<16)
-
-#define m_WIN2_DSP_WIDTH1			(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT1			(0xfff<<16)
-
-#define WIN2_DSP_ST1			(0x00d8)
-#define v_WIN2_DSP_XST1(x)			(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST1(x)			(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST1				(0x1fff<<0)
-#define m_WIN2_DSP_YST1				(0x1fff<<16)
-
-#define WIN2_SRC_ALPHA_CTRL		(0x00dc)
-#define v_WIN2_SRC_ALPHA_EN(x)			(((x)&1)<<0)
-#define v_WIN2_SRC_COLOR_M0(x)			(((x)&1)<<1)
-#define v_WIN2_SRC_ALPHA_M0(x)			(((x)&1)<<2)
-#define v_WIN2_SRC_BLEND_M0(x)			(((x)&3)<<3)
-#define v_WIN2_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
-#define v_WIN2_SRC_FACTOR_M0(x)			(((x)&7)<<6)
-#define v_WIN2_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
-#define v_WIN2_FADING_VALUE(x)			(((x)&0xff)<<24)
-#define m_WIN2_SRC_ALPHA_EN			(1<<0)
-#define m_WIN2_SRC_COLOR_M0			(1<<1)
-#define m_WIN2_SRC_ALPHA_M0			(1<<2)
-#define m_WIN2_SRC_BLEND_M0			(3<<3)
-#define m_WIN2_SRC_ALPHA_CAL_M0			(1<<5)
-#define m_WIN2_SRC_FACTOR_M0			(7<<6)
-#define m_WIN2_SRC_GLOBAL_ALPHA			(0xff<<16)
-#define m_WIN2_FADING_VALUE			(0xff<<24)
-
-#define WIN2_MST2			(0x00e0)
-#define WIN2_DSP_INFO2			(0x00e4)
-#define v_WIN2_DSP_WIDTH2(x)			(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT2(x)			(((x-1)&0xfff)<<16)
-#define m_WIN2_DSP_WIDTH2			(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT2			(0xfff<<16)
-
-#define WIN2_DSP_ST2			(0x00e8)
-#define v_WIN2_DSP_XST2(x)			(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST2(x)			(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST2				(0x1fff<<0)
-#define m_WIN2_DSP_YST2				(0x1fff<<16)
-
-#define WIN2_DST_ALPHA_CTRL		(0x00ec)
-#define v_WIN2_DST_FACTOR_M0(x)			(((x)&7)<<6)
-#define m_WIN2_DST_FACTOR_M0			(7<<6)
-
-#define WIN2_MST3			(0x00f0)
-#define WIN2_DSP_INFO3			(0x00f4)
-#define v_WIN2_DSP_WIDTH3(x)			(((x-1)&0xfff)<<0)
-#define v_WIN2_DSP_HEIGHT3(x)			(((x-1)&0xfff)<<16)
-#define m_WIN2_DSP_WIDTH3			(0xfff<<0)
-#define m_WIN2_DSP_HEIGHT3			(0xfff<<16)
-
-#define WIN2_DSP_ST3			(0x00f8)
-#define v_WIN2_DSP_XST3(x)			(((x)&0x1fff)<<0)
-#define v_WIN2_DSP_YST3(x)			(((x)&0x1fff)<<16)
-#define m_WIN2_DSP_XST3				(0x1fff<<0)
-#define m_WIN2_DSP_YST3				(0x1fff<<16)
-
-#define WIN2_FADING_CTRL		(0x00fc)
-#define v_WIN2_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
-#define v_WIN2_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
-#define v_WIN2_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
-#define v_WIN2_FADING_EN(x)			(((x)&1)<<24)
-
-#define m_WIN2_FADING_OFFSET_R			(0xff<<0)
-#define m_WIN2_FADING_OFFSET_G			(0xff<<8)
-#define m_WIN2_FADING_OFFSET_B			(0xff<<16)
-#define m_WIN2_FADING_EN			(1<<24)
-
-/*win3 register*/
-#define WIN3_CTRL0			(0x0100)
-#define v_WIN3_EN(x)				(((x)&1)<<0)
-#define v_WIN3_INTERLACE_READ(x)		(((x)&1)<<1)
-#define v_WIN3_CSC_MODE(x)			(((x)&1)<<2)
-#define v_WIN3_MST0_EN(x)			(((x)&1)<<4)
-#define v_WIN3_DATA_FMT0(x)			(((x)&3)<<5)
-#define v_WIN3_MST1_EN(x)			(((x)&1)<<8)
-#define v_WIN3_DATA_FMT1(x)			(((x)&3)<<9)
-#define v_WIN3_MST2_EN(x)			(((x)&1)<<12)
-#define v_WIN3_DATA_FMT2(x)			(((x)&3)<<13)
-#define v_WIN3_MST3_EN(x)			(((x)&1)<<16)
-#define v_WIN3_DATA_FMT3(x)			(((x)&3)<<17)
-#define v_WIN3_RB_SWAP0(x)			(((x)&1)<<20)
-#define v_WIN3_ALPHA_SWAP0(x)			(((x)&1)<<21)
-#define v_WIN3_ENDIAN_SWAP0(x)			(((x)&1)<<22)
-#define v_WIN3_RB_SWAP1(x)			(((x)&1)<<23)
-#define v_WIN3_ALPHA_SWAP1(x)			(((x)&1)<<24)
-#define v_WIN3_ENDIAN_SWAP1(x)			(((x)&1)<<25)
-#define v_WIN3_RB_SWAP2(x)			(((x)&1)<<26)
-#define v_WIN3_ALPHA_SWAP2(x)			(((x)&1)<<27)
-#define v_WIN3_ENDIAN_SWAP2(x)			(((x)&1)<<28)
-#define v_WIN3_RB_SWAP3(x)			(((x)&1)<<29)
-#define v_WIN3_ALPHA_SWAP3(x)			(((x)&1)<<30)
-#define v_WIN3_ENDIAN_SWAP3(x)			(((x)&1)<<31)
-
-#define m_WIN3_EN				(1<<0)
-#define m_WIN3_INTERLACE_READ			(1<<1)
-#define m_WIN3_CSC_MODE				(1<<2)
-#define m_WIN3_MST0_EN				(1<<4)
-#define m_WIN3_DATA_FMT0			(3<<5)
-#define m_WIN3_MST1_EN				(1<<8)
-#define m_WIN3_DATA_FMT1			(3<<9)
-#define m_WIN3_MST2_EN				(1<<12)
-#define m_WIN3_DATA_FMT2			(3<<13)
-#define m_WIN3_MST3_EN				(1<<16)
-#define m_WIN3_DATA_FMT3			(3<<17)
-#define m_WIN3_RB_SWAP0				(1<<20)
-#define m_WIN3_ALPHA_SWAP0			(1<<21)
-#define m_WIN3_ENDIAN_SWAP0			(1<<22)
-#define m_WIN3_RB_SWAP1				(1<<23)
-#define m_WIN3_ALPHA_SWAP1			(1<<24)
-#define m_WIN3_ENDIAN_SWAP1			(1<<25)
-#define m_WIN3_RB_SWAP2				(1<<26)
-#define m_WIN3_ALPHA_SWAP2			(1<<27)
-#define m_WIN3_ENDIAN_SWAP2			(1<<28)
-#define m_WIN3_RB_SWAP3				(1<<29)
-#define m_WIN3_ALPHA_SWAP3			(1<<30)
-#define m_WIN3_ENDIAN_SWAP3			(1<<31)
-
-#define WIN3_CTRL1			(0x0104)
-#define v_WIN3_AXI_GATHER_EN(x)		        (((x)&1)<<0)
-#define v_WIN3_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<1)
-#define v_WIN3_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
-#define v_WIN3_AXI_GATHER_NUM(x)	        (((x)&0xf)<<4)
-#define v_WIN3_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
-#define v_WIN3_NO_OUTSTANDING(x)		(((x)&1)<<14)
-#define v_WIN3_Y_MIR(x)			        (((x)&1)<<15)
-#define v_WIN3_LUT_EN(x)		        (((x)&1)<<16)
-#define v_WIN_RID_WIN3(x)	                (((x)&0xf)<<20)
-
-#define m_WIN3_AXI_GATHER_EN			(1<<0)
-#define m_WIN3_AXI_MAX_OUTSTANDING_EN		(1<<1)
-#define m_WIN3_DMA_BURST_LENGTH			(0x3<<2)
-#define m_WIN3_AXI_GATHER_NUM			(0xf<<4)
-#define m_WIN3_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
-#define m_WIN3_NO_OUTSTANDING			(1<<14)
-#define m_WIN3_Y_MIR				(1<<15)
-#define m_WIN3_LUT_EN				(1<<16)
-#define m_WIN_RID_WIN3				(0xf<<20)
-
-#define WIN3_VIR0_1			(0x0108)
-#define v_WIN3_VIR_STRIDE0(x)			(((x)&0xffff)<<0)
-#define v_WIN3_VIR_STRIDE1(x)			(((x)&0xffff)<<16)
-#define m_WIN3_VIR_STRIDE0			(0xffff<<0)
-#define m_WIN3_VIR_STRIDE1			(0xffff<<16)
-
-#define WIN3_VIR2_3			(0x010c)
-#define v_WIN3_VIR_STRIDE2(x)			(((x)&0xffff)<<0)
-#define v_WIN3_VIR_STRIDE3(x)			(((x)&0xffff)<<16)
-#define m_WIN3_VIR_STRIDE2			(0xffff<<0)
-#define m_WIN3_VIR_STRIDE3			(0xffff<<16)
-
-#define WIN3_MST0			(0x0110)
-#define WIN3_DSP_INFO0			(0x0114)
-#define v_WIN3_DSP_WIDTH0(x)			(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT0(x)			(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH0			(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT0			(0xfff<<16)
-
-#define WIN3_DSP_ST0			(0x0118)
-#define v_WIN3_DSP_XST0(x)			(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST0(x)			(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST0				(0x1fff<<0)
-#define m_WIN3_DSP_YST0				(0x1fff<<16)
-
-#define WIN3_COLOR_KEY			(0x011c)
-#define v_WIN3_COLOR_KEY(x)			(((x)&0xffffff)<<0)
-#define v_WIN3_KEY_EN(x)			(((x)&1)<<24)
-#define m_WIN3_COLOR_KEY			(0xffffff<<0)
-#define m_WIN3_KEY_EN				((u32)1<<24)
-
-#define WIN3_MST1			(0x0120)
-#define WIN3_DSP_INFO1			(0x0124)
-#define v_WIN3_DSP_WIDTH1(x)			(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT1(x)			(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH1			(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT1			(0xfff<<16)
-
-#define WIN3_DSP_ST1			(0x0128)
-#define v_WIN3_DSP_XST1(x)			(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST1(x)			(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST1				(0x1fff<<0)
-#define m_WIN3_DSP_YST1				(0x1fff<<16)
-
-#define WIN3_SRC_ALPHA_CTRL		(0x012c)
-#define v_WIN3_SRC_ALPHA_EN(x)			(((x)&1)<<0)
-#define v_WIN3_SRC_COLOR_M0(x)			(((x)&1)<<1)
-#define v_WIN3_SRC_ALPHA_M0(x)			(((x)&1)<<2)
-#define v_WIN3_SRC_BLEND_M0(x)			(((x)&3)<<3)
-#define v_WIN3_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
-#define v_WIN3_SRC_FACTOR_M0(x)			(((x)&7)<<6)
-#define v_WIN3_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
-#define v_WIN3_FADING_VALUE(x)			(((x)&0xff)<<24)
-
-#define m_WIN3_SRC_ALPHA_EN			(1<<0)
-#define m_WIN3_SRC_COLOR_M0			(1<<1)
-#define m_WIN3_SRC_ALPHA_M0			(1<<2)
-#define m_WIN3_SRC_BLEND_M0			(3<<3)
-#define m_WIN3_SRC_ALPHA_CAL_M0			(1<<5)
-#define m_WIN3_SRC_FACTOR_M0			(7<<6)
-#define m_WIN3_SRC_GLOBAL_ALPHA			(0xff<<16)
-#define m_WIN3_FADING_VALUE			(0xff<<24)
-
-#define WIN3_MST2			(0x0130)
-#define WIN3_DSP_INFO2			(0x0134)
-#define v_WIN3_DSP_WIDTH2(x)			(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT2(x)			(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH2			(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT2			(0xfff<<16)
-
-#define WIN3_DSP_ST2			(0x0138)
-#define v_WIN3_DSP_XST2(x)			(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST2(x)			(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST2				(0x1fff<<0)
-#define m_WIN3_DSP_YST2				(0x1fff<<16)
-
-#define WIN3_DST_ALPHA_CTRL		(0x013c)
-#define v_WIN3_DST_FACTOR_M0(x)			(((x)&7)<<6)
-#define m_WIN3_DST_FACTOR_M0			(7<<6)
-
-
-#define WIN3_MST3			(0x0140)
-#define WIN3_DSP_INFO3			(0x0144)
-#define v_WIN3_DSP_WIDTH3(x)			(((x-1)&0xfff)<<0)
-#define v_WIN3_DSP_HEIGHT3(x)			(((x-1)&0xfff)<<16)
-#define m_WIN3_DSP_WIDTH3		(0xfff<<0)
-#define m_WIN3_DSP_HEIGHT3		(0xfff<<16)
-
-#define WIN3_DSP_ST3			(0x0148)
-#define v_WIN3_DSP_XST3(x)			(((x)&0x1fff)<<0)
-#define v_WIN3_DSP_YST3(x)			(((x)&0x1fff)<<16)
-#define m_WIN3_DSP_XST3			(0x1fff<<0)
-#define m_WIN3_DSP_YST3			(0x1fff<<16)
-
-#define WIN3_FADING_CTRL		(0x014c)
-#define v_WIN3_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
-#define v_WIN3_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
-#define v_WIN3_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
-#define v_WIN3_FADING_EN(x)			(((x)&1)<<24)
-
-#define m_WIN3_FADING_OFFSET_R			(0xff<<0)
-#define m_WIN3_FADING_OFFSET_G			(0xff<<8)
-#define m_WIN3_FADING_OFFSET_B			(0xff<<16)
-#define m_WIN3_FADING_EN			(1<<24)
-
-
-/*hwc register*/
-#define HWC_CTRL0			(0x0150)
-#define v_HWC_EN(x)				(((x)&1)<<0)
-#define v_HWC_DATA_FMT(x)			(((x)&7)<<1)
-#define v_HWC_MODE(x)				(((x)&1)<<4)
-#define v_HWC_SIZE(x)				(((x)&3)<<5)
-#define v_HWC_INTERLACE_READ(x)			(((x)&1)<<8)
-#define v_HWC_CSC_MODE(x)			(((x)&1)<<10)
-#define v_HWC_RB_SWAP(x)			(((x)&1)<<12)
-#define v_HWC_ALPHA_SWAP(x)			(((x)&1)<<13)
-#define v_HWC_ENDIAN_SWAP(x)			(((x)&1)<<14)
-
-#define m_HWC_EN				(1<<0)
-#define m_HWC_DATA_FMT				(7<<1)
-#define m_HWC_MODE				(1<<4)
-#define m_HWC_SIZE				(3<<5)
-#define m_HWC_INTERLACE_READ			(1<<8)
-#define m_HWC_CSC_MODE				(1<<10)
-#define m_HWC_RB_SWAP				(1<<12)
-#define m_HWC_ALPHA_SWAP			(1<<13)
-#define m_HWC_ENDIAN_SWAP			(1<<14)
-
-
-#define HWC_CTRL1			(0x0154)
-#define v_HWC_AXI_GATHER_EN(x)		        (((x)&1)<<0)
-#define v_HWC_AXI_MAX_OUTSTANDING_EN(x)		(((x)&1)<<1)
-#define v_HWC_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
-#define v_HWC_AXI_GATHER_NUM(x)			(((x)&0x7)<<4)
-#define v_HWC_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
-#define v_HWC_RGB2YUV_EN(x)			(((x)&1)<<13)
-#define v_HWC_NO_OUTSTANDING(x)			(((x)&1)<<14)
-#define v_HWC_Y_MIR(x)			        (((x)&1)<<15)
-#define v_HWC_LUT_EN(x)				(((x)&1)<<16)
-#define v_WIN_RID_HWC(x)	                (((x)&0xf)<<20)
-
-#define m_HWC_AXI_GATHER_EN			(1<<0)
-#define m_HWC_AXI_MAX_OUTSTANDING_EN		(1<<1)
-#define m_HWC_DMA_BURST_LENGTH			(0x3<<2)
-#define m_HWC_AXI_GATHER_NUM			(0x7<<4)
-#define m_HWC_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
-#define m_HWC_RGB2YUV_EN			(1<<13)
-#define m_HWC_NO_OUTSTANDING			(1<<14)
-#define m_HWC_Y_MIR				(1<<15)
-#define m_HWC_LUT_EN				(1<<16)
-#define m_WIN_RID_HWC				(0xf<<20)
-
-#define HWC_MST				(0x0158)
-#define HWC_DSP_ST			(0x015c)
-#define v_HWC_DSP_XST(x)			(((x)&0x1fff)<<0)
-#define v_HWC_DSP_YST(x)			(((x)&0x1fff)<<16)
-#define m_HWC_DSP_XST				(0x1fff<<0)
-#define m_HWC_DSP_YST				(0x1fff<<16)
-
-#define HWC_SRC_ALPHA_CTRL		(0x0160)
-#define v_HWC_SRC_ALPHA_EN(x)			(((x)&1)<<0)
-#define v_HWC_SRC_COLOR_M0(x)			(((x)&1)<<1)
-#define v_HWC_SRC_ALPHA_M0(x)			(((x)&1)<<2)
-#define v_HWC_SRC_BLEND_M0(x)			(((x)&3)<<3)
-#define v_HWC_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
-#define v_HWC_SRC_FACTOR_M0(x)			(((x)&7)<<6)
-#define v_HWC_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
-#define v_HWC_FADING_VALUE(x)			(((x)&0xff)<<24)
-
-#define m_HWC_SRC_ALPHA_EN			(1<<0)
-#define m_HWC_SRC_COLOR_M0			(1<<1)
-#define m_HWC_SRC_ALPHA_M0			(1<<2)
-#define m_HWC_SRC_BLEND_M0			(3<<3)
-#define m_HWC_SRC_ALPHA_CAL_M0			(1<<5)
-#define m_HWC_SRC_FACTOR_M0			(7<<6)
-#define m_HWC_SRC_GLOBAL_ALPHA			(0xff<<16)
-#define m_HWC_FADING_VALUE			(0xff<<24)
-
-#define HWC_DST_ALPHA_CTRL		(0x0164)
-#define v_HWC_DST_FACTOR_M0(x)			(((x)&7)<<6)
-#define m_HWC_DST_FACTOR_M0			(7<<6)
-
-
-#define HWC_FADING_CTRL			(0x0168)
-#define v_HWC_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
-#define v_HWC_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
-#define v_HWC_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
-#define v_HWC_FADING_EN(x)			(((x)&1)<<24)
-
-#define m_HWC_FADING_OFFSET_R			(0xff<<0)
-#define m_HWC_FADING_OFFSET_G			(0xff<<8)
-#define m_HWC_FADING_OFFSET_B			(0xff<<16)
-#define m_HWC_FADING_EN				(1<<24)
-
-/*post process register*/
-#define POST_DSP_HACT_INFO		(0x0170)
-#define v_DSP_HACT_END_POST(x)			(((x)&0x1fff)<<0)
-#define v_DSP_HACT_ST_POST(x)			(((x)&0x1fff)<<16)
-#define m_DSP_HACT_END_POST			(0x1fff<<0)
-#define m_DSP_HACT_ST_POST			(0x1fff<<16)
-
-#define POST_DSP_VACT_INFO		(0x0174)
-#define v_DSP_VACT_END_POST(x)			(((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST_POST(x)			(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END_POST			(0x1fff<<0)
-#define m_DSP_VACT_ST_POST			(0x1fff<<16)
-
-#define POST_SCL_FACTOR_YRGB		(0x0178)
-#define v_POST_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
-#define v_POST_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
-#define m_POST_HS_FACTOR_YRGB			(0xffff<<0)
-#define m_POST_VS_FACTOR_YRGB			(0xffff<<16)
-
-#define POST_SCL_CTRL			(0x0180)
-#define v_POST_HOR_SD_EN(x)			(((x)&1)<<0)
-#define v_POST_VER_SD_EN(x)			(((x)&1)<<1)
-
-#define m_POST_HOR_SD_EN			(0x1<<0)
-#define m_POST_VER_SD_EN			(0x1<<1)
-
-#define POST_DSP_VACT_INFO_F1		(0x0184)
-#define v_DSP_VACT_END_POST_F1(x)		(((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST_POST_F1(x)		(((x)&0x1fff)<<16)
-
-#define m_DSP_VACT_END_POST_F1			(0x1fff<<0)
-#define m_DSP_VACT_ST_POST_F1			(0x1fff<<16)
-
-#define DSP_HTOTAL_HS_END		(0x0188)
-#define v_DSP_HS_PW(x)				(((x)&0x1fff)<<0)
-#define v_DSP_HTOTAL(x)				(((x)&0x1fff)<<16)
-#define m_DSP_HS_PW				(0x1fff<<0)
-#define m_DSP_HTOTAL				(0x1fff<<16)
-
-#define DSP_HACT_ST_END			(0x018c)
-#define v_DSP_HACT_END(x)			(((x)&0x1fff)<<0)
-#define v_DSP_HACT_ST(x)			(((x)&0x1fff)<<16)
-#define m_DSP_HACT_END				(0x1fff<<0)
-#define m_DSP_HACT_ST				(0x1fff<<16)
-
-#define DSP_VTOTAL_VS_END		(0x0190)
-#define v_DSP_VS_PW(x)				(((x)&0x1fff)<<0)
-#define v_DSP_VTOTAL(x)				(((x)&0x1fff)<<16)
-#define m_DSP_VS_PW				(0x1fff<<0)
-#define m_DSP_VTOTAL				(0x1fff<<16)
-
-#define DSP_VACT_ST_END			(0x0194)
-#define v_DSP_VACT_END(x)			(((x)&0x1fff)<<0)
-#define v_DSP_VACT_ST(x)			(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END				(0x1fff<<0)
-#define m_DSP_VACT_ST				(0x1fff<<16)
-
-#define DSP_VS_ST_END_F1		(0x0198)
-#define v_DSP_VS_END_F1(x)			(((x)&0x1fff)<<0)
-#define v_DSP_VS_ST_F1(x)			(((x)&0x1fff)<<16)
-#define m_DSP_VS_END_F1				(0x1fff<<0)
-#define m_DSP_VS_ST_F1				(0x1fff<<16)
-
-#define DSP_VACT_ST_END_F1		(0x019c)
-#define v_DSP_VACT_END_F1(x)			(((x)&0x1fff)<<0)
-#define v_DSP_VAC_ST_F1(x)			(((x)&0x1fff)<<16)
-#define m_DSP_VACT_END_F1			(0x1fff<<0)
-#define m_DSP_VAC_ST_F1				(0x1fff<<16)
-
-
-/*pwm register*/
-#define PWM_CTRL			(0x01a0)
-#define v_PWM_EN(x)				(((x)&1)<<0)
-#define v_PWM_MODE(x)				(((x)&3)<<1)
-
-#define v_DUTY_POL(x)				(((x)&1)<<3)
-#define v_INACTIVE_POL(x)			(((x)&1)<<4)
-#define v_OUTPUT_MODE(x)			(((x)&1)<<5)
-#define v_BL_EN(x)				(((x)&1)<<8)
-#define v_CLK_SEL(x)				(((x)&1)<<9)
-#define v_PRESCALE(x)				(((x)&7)<<12)
-#define v_CABC_PWM_OUT_POL(x)			(((x)&1)<<15)
-#define v_SCALE(x)				(((x)&0xff)<<16)
-#define v_RPT(x)				(((x)&0xff)<<24)
-
-#define m_PWM_EN				(1<<0)
-#define m_PWM_MODE				(3<<1)
-
-#define m_DUTY_POL				(1<<3)
-#define m_INACTIVE_POL				(1<<4)
-#define m_OUTPUT_MODE				(1<<5)
-#define m_BL_EN					(1<<8)
-#define m_CLK_SEL				(1<<9)
-#define m_CABC_PWM_OUT_POL			(1<<15)
-
-#define m_PRESCALE				(7<<12)
-#define m_SCALE					(0xff<<16)
-#define m_RPT					((u32)0xff<<24)
-
-#define PWM_PERIOD_HPR				(0x01a4)
-#define PWM_DUTY_LPR				(0x01a8)
-#define PWM_CNT					(0x01ac)
-
-/*BCSH register*/
-#define BCSH_COLOR_BAR			(0x01b0)
-#define v_BCSH_EN(x)				(((x)&1)<<0)
-#define v_BCSH_COLOR_BAR_Y(x)			(((x)&0xff)<<8)
-#define v_BCSH_COLOR_BAR_U(x)			(((x)&0xff)<<16)
-#define v_BCSH_COLOR_BAR_V(x)			(((x)&0xff)<<24)
-#define m_BCSH_EN				(1<<0)
-#define m_BCSH_COLOR_BAR_Y			(0xff<<8)
-#define m_BCSH_COLOR_BAR_U			(0xff<<16)
-#define m_BCSH_COLOR_BAR_V			(0xff<<24)
-
-#define BCSH_BCS			(0x01b4)
-#define v_BCSH_BRIGHTNESS(x)			(((x)&0x3f)<<0)
-#define v_BCSH_CONTRAST(x)			(((x)&0x1ff)<<8)
-#define v_BCSH_SAT_CON(x)			(((x)&0x3ff)<<20)
-#define v_BCSH_OUT_MODE(x)			(((x)&0x3)<<30)
-#define m_BCSH_BRIGHTNESS			(0x3f<<0)
-#define m_BCSH_CONTRAST				(0x1ff<<8)
-#define m_BCSH_SAT_CON				(0x3ff<<20)
-#define m_BCSH_OUT_MODE				((u32)0x3<<30)
-
-#define BCSH_H				(0x01b8)
-#define v_BCSH_SIN_HUE(x)			(((x)&0x1ff)<<0)
-#define v_BCSH_COS_HUE(x)			(((x)&0x1ff)<<16)
-
-#define m_BCSH_SIN_HUE				(0x1ff<<0)
-#define m_BCSH_COS_HUE				(0x1ff<<16)
-
-#define BCSH_CTRL			(0x01bc)
-#define   m_BCSH_Y2R_EN				(0x1<<0)
-#define   m_BCSH_Y2R_CSC_MODE			(0x3<<2)
-#define   m_BCSH_R2Y_EN				(0x1<<4)
-#define   m_BCSH_R2Y_CSC_MODE			(0x1<<6)
-#define   v_BCSH_Y2R_EN(x)			(((x)&0x1)<<0)
-#define   v_BCSH_Y2R_CSC_MODE(x)		(((x)&0x3)<<2)
-#define   v_BCSH_R2Y_EN(x)			(((x)&0x1)<<4)
-#define   v_BCSH_R2Y_CSC_MODE(x)		(((x)&0x1)<<6)
-
-#define CABC_CTRL0			(0x01c0)
-#define v_CABC_EN(x)				(((x)&1)<<0)
-#define v_CABC_HANDLE_EN(x)			(((x)&1)<<1)
-#define v_PWM_CONFIG_MODE(x)			(((x)&3)<<2)
-#define v_CABC_CALC_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
-#define m_CABC_EN				(1<<0)
-#define m_CABC_HANDLE_EN			(1<<1)
-#define m_PWM_CONFIG_MODE			(3<<2)
-#define m_CABC_CALC_PIXEL_NUM			(0x7fffff<<4)
-
-#define CABC_CTRL1			(0x01c4)
-#define v_CABC_LUT_EN(x)			(((x)&1)<<0)
-#define v_CABC_TOTAL_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
-#define m_CABC_LUT_EN				(1<<0)
-#define m_CABC_TOTAL_PIXEL_NUM			(0x7fffff<<4)
-
-#define CABC_CTRL2			(0x01c8)
-#define v_CABC_STAGE_DOWN(x)			(((x)&0xff)<<0)
-#define v_CABC_STAGE_UP(x)			(((x)&0x1ff)<<8)
-#define v_CABC_STAGE_MODE(x)			(((x)&1)<<19)
-#define v_MAX_SCALE_CFG_VALUE(x)		(((x)&0x1ff)<<20)
-#define v_MAX_SCALE_CFG_ENABLE(x)		(((x)&1)<<31)
-#define m_CABC_STAGE_DOWN			(0xff<<0)
-#define m_CABC_STAGE_UP				(0x1ff<<8)
-#define m_CABC_STAGE_MODE			(1<<19)
-#define m_MAX_SCALE_CFG_VALUE			(0x1ff<<20)
-#define m_MAX_SCALE_CFG_ENABLE			(1<<31)
-
-#define CABC_CTRL3			(0x01cc)
-#define v_CABC_GLOBAL_DN(x)			(((x)&0xff)<<0)
-#define v_CABC_GLOBAL_DN_LIMIT_EN(x)		(((x)&1)<<8)
-#define m_CABC_GLOBAL_DN			(0xff<<0)
-#define m_CABC_GLOBAL_DN_LIMIT_EN		(1<<8)
-
-#define CABC_GAUSS_LINE0_0		(0x01d0)
-#define v_CABC_T_LINE0_0(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE0_1(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE0_2(x)			(((x)&0xff)<<16)
-#define v_CABC_T_LINE0_3(x)			(((x)&0xff)<<24)
-#define m_CABC_T_LINE0_0			(0xff<<0)
-#define m_CABC_T_LINE0_1			(0xff<<8)
-#define m_CABC_T_LINE0_2			(0xff<<16)
-#define m_CABC_T_LINE0_3			((u32)0xff<<24)
-
-#define CABC_GAUSS_LINE0_1		(0x01d4)
-#define v_CABC_T_LINE0_4(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE0_5(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE0_6(x)			(((x)&0xff)<<16)
-#define m_CABC_T_LINE0_4			(0xff<<0)
-#define m_CABC_T_LINE0_5			(0xff<<8)
-#define m_CABC_T_LINE0_6			(0xff<<16)
-
-
-#define CABC_GAUSS_LINE1_0		(0x01d8)
-#define v_CABC_T_LINE1_0(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE1_1(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE1_2(x)			(((x)&0xff)<<16)
-#define v_CABC_T_LINE1_3(x)			(((x)&0xff)<<24)
-#define m_CABC_T_LINE1_0			(0xff<<0)
-#define m_CABC_T_LINE1_1			(0xff<<8)
-#define m_CABC_T_LINE1_2			(0xff<<16)
-#define m_CABC_T_LINE1_3			((u32)0xff<<24)
-
-
-#define CABC_GAUSS_LINE1_1		(0x01dc)
-#define v_CABC_T_LINE1_4(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE1_5(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE1_6(x)			(((x)&0xff)<<16)
-#define m_CABC_T_LINE1_4			(0xff<<0)
-#define m_CABC_T_LINE1_5			(0xff<<8)
-#define m_CABC_T_LINE1_6			(0xff<<16)
-
-
-#define CABC_GAUSS_LINE2_0		(0x01e0)
-#define v_CABC_T_LINE2_0(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE2_1(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE2_2(x)			(((x)&0xff)<<16)
-#define v_CABC_T_LINE2_3(x)			(((x)&0xff)<<24)
-#define m_CABC_T_LINE2_0			(0xff<<0)
-#define m_CABC_T_LINE2_1			(0xff<<8)
-#define m_CABC_T_LINE2_2			(0xff<<16)
-#define m_CABC_T_LINE2_3			((u32)0xff<<24)
-
-
-#define CABC_GAUSS_LINE2_1		(0x01e4)
-#define v_CABC_T_LINE2_4(x)			(((x)&0xff)<<0)
-#define v_CABC_T_LINE2_5(x)			(((x)&0xff)<<8)
-#define v_CABC_T_LINE2_6(x)			(((x)&0xff)<<16)
-#define m_CABC_T_LINE2_4			(0xff<<0)
-#define m_CABC_T_LINE2_5			(0xff<<8)
-#define m_CABC_T_LINE2_6			(0xff<<16)
-
-/*FRC register*/
-#define FRC_LOWER01_0			(0x01e8)
-#define v_FRC_LOWER01_FRM0(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER01_FRM1(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER01_FRM0			(0xffff<<0)
-#define m_FRC_LOWER01_FRM1			((u32)0xffff<<16)
-
-#define FRC_LOWER01_1			(0x01ec)
-#define v_FRC_LOWER01_FRM2(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER01_FRM3(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER01_FRM2			(0xffff<<0)
-#define m_FRC_LOWER01_FRM3			((u32)0xffff<<16)
-
-
-#define FRC_LOWER10_0			(0x01f0)
-#define v_FRC_LOWER10_FRM0(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER10_FRM1(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER10_FRM0			(0xffff<<0)
-#define m_FRC_LOWER10_FRM1			((u32)0xffff<<16)
-
-
-#define FRC_LOWER10_1			(0x01f4)
-#define v_FRC_LOWER10_FRM2(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER10_FRM3(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER10_FRM2			(0xffff<<0)
-#define m_FRC_LOWER10_FRM3			((u32)0xffff<<16)
-
-
-#define FRC_LOWER11_0			(0x01f8)
-#define v_FRC_LOWER11_FRM0(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER11_FRM1(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER11_FRM0			(0xffff<<0)
-#define m_FRC_LOWER11_FRM1			((u32)0xffff<<16)
-
-
-#define FRC_LOWER11_1			(0x01fc)
-#define v_FRC_LOWER11_FRM2(x)			(((x)&0xffff)<<0)
-#define v_FRC_LOWER11_FRM3(x)			(((x)&0xffff)<<16)
-#define m_FRC_LOWER11_FRM2			(0xffff<<0)
-#define m_FRC_LOWER11_FRM3			((u32)0xffff<<16)
-
-#define IFBDC_CTRL			(0x0200)
-#define v_IFBDC_CTRL_FBDC_EN(x)		(((x)&0x1)<<0)
-#define v_IFBDC_CTRL_FBDC_COR_EN(x)		(((x)&0x1)<<1)
-#define v_IFBDC_CTRL_FBDC_WIN_SEL(x)		(((x)&0x3)<<2)
-#define v_IFBDC_CTRL_FBDC_ROTATION_MODE(x)	(((x)&0x7)<<4)
-#define v_IFBDC_CTRL_FBDC_FMT(x)		(((x)&0x7f)<<7)
-#define v_IFBDC_AXI_MAX_OUTSTANDING_EN(x)	(((x)&0x1)<<14)
-#define v_IFBDC_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<15)
-#define v_IFBDC_CTRL_WIDTH_RATIO(x)		(((x)&0x1)<<20)
-#define v_IFBDC_FRAME_RST_EN(x)			(((x)&0x1)<<21)
-#define v_IFBDC_ICTRL_NOTIFY(x)			(((x)&0x1)<<22)
-#define v_IFBDC_INVALIDATE_PENDING_O(x)		(((x)&0x1)<<23)
-#define v_IFBDC_RID(x)				(((x)&0xf)<<24)
-#define v_IFBDC_RSTN(x)				(((x)&0x1)<<28)
-
-#define m_IFBDC_CTRL_FBDC_EN			(0x1<<0)
-#define m_IFBDC_CTRL_FBDC_COR_EN		(0x1<<1)
-#define m_IFBDC_CTRL_FBDC_WIN_SEL		(0x3<<2)
-#define m_IFBDC_CTRL_FBDC_ROTATION_MODE		(0x7<<4)
-#define m_IFBDC_CTRL_FBDC_FMT			(0x7f<<7)
-#define m_IFBDC_AXI_MAX_OUTSTANDING_EN		(0x1<<14)
-#define m_IFBDC_AXI_OUTSTANDING_MAX_NUM		(0x1f<<15)
-#define m_IFBDC_CTRL_WIDTH_RATIO		(0x1<<20)
-#define m_IFBDC_FRAME_RST_EN			(0x1<<21)
-#define m_IFBDC_ICTRL_NOTIFY			(0x1<<22)
-#define m_IFBDC_INVALIDATE_PENDING_O		(0x1<<23)
-#define m_IFBDC_RID				(0xf<<24)
-#define m_IFBDC_RSTN				(0x1<<28)
-
-#define IFBDC_TILES_NUM			(0x0204)
-#define v_IFBDC_TILES_NUM(x)			(((x-1)&0x7fffff)<<0)
-#define m_IFBDC_TILES_NUM			(0x7fffff<<0)
-
-#define IFBDC_FRAME_RST_CYCLE		(0x0208)
-#define v_IFBDC_FRAME_RST_CYCLE(x)		(((x)&0x3ff)<<0)
-#define v_DMA_IFBDC_FRAME_RST_CYCLE(x)		(((x)&0x3ff)<<16)
-#define m_IFBDC_FRAME_RST_CYCLE			((0x3ff)<<0)
-#define m_DMA_IFBDC_FRAME_RST_CYCLE		((0x3ff)<<16)
-
-
-
-#define IFBDC_BASE_ADDR			(0x20c)
-#define v_IFBDC_BASE_ADDR(x)			(((x)&0xffffffff)<<0)
-#define m_IFBDC_BASE_ADDR			((0xffffffff)<<0)
-
-#define IFBDC_MB_SIZE			(0x210)
-#define  v_IFBDC_MB_SIZE_WIDTH(x)		(((x-1)&0x7f)<<0)
-#define  v_IFBDC_MB_SIZE_HEIGHT(x)		(((x-1)&0x1ff)<<16)
-#define  m_IFBDC_MB_SIZE_WIDTH			((0x7f)<<0)
-#define  m_IFBDC_MB_SIZE_HEIGHT			((0x1ff)<<16)
-
-
-#define IFBDC_CMP_INDEX_INIT		(0x0214)
-#define v_IFBDC_CMP_INDEX_INIT(x)               (((x)&0x7fffff) << 0)
-#define m_IFBDC_CMP_INDEX_INIT                  (0x7fffff<<0)
-
-#define IFBDC_MB_VIR_WIDTH		(0x220)
-#define  v_IFBDC_MB_VIR_WIDTH(x)		(((x)&0xff)<<0)
-#define  m_IFBDC_MB_VIR_WIDTH			((0xff)<<0)
-
-#define IFBDC_DEBUG0			(0x230)
-#define v_DBG_IFBDC_MB_Y_WCNT(x)		(((x)&0x1ff)<<0)
-#define v_DBG_IFBDC_IDLE(x)			(((x)&0x1)<<12)
-#define v_DBG_IFBDC_LB_RCNT(x)			(((x)&0x7FF)<<16)
-#define v_DBG_IFBDC_INVALIDATE_PENDING_I(x)	(((x)&0x1)<<28)
-
-#define m_DBG_IFBDC_MB_Y_WCNT			(0x1ff<<0)
-#define m_DBG_IFBDC_IDLE			(0x1<<12)
-#define m_DBG_IFBDC_LB_RCNT			(0x7FF<<16)
-#define m_DBG_IFBDC_INVALIDATE_PENDING_I	(0x1<<28)
-
-#define IFBDC_DEBUG1			(0x234)
-#define V_DBG_FBDC_CMP_TILE_INDEX(x)		(((x)&0x7fffff)<<0)
-#define m_DBG_FBDC_CMP_TILE_INDEX		(0x7fffff<<0)
-
-#define LATENCY_CTRL0			(0x250)
-#define  v_RD_LATENCY_EN(x)			(((x)&0x1)<<0)
-#define  v_HAND_LATENCY_CLR(x)			(((x)&0x1)<<1)
-#define  v_RD_LATENCY_MODE(x)			(((x)&0x1)<<2)
-#define  v_RD_LATENCY_ID0(x)			(((x)&0xf)<<4)
-#define  v_RD_LATENCY_THR(x)			(((x)&0xfff)<<8)
-#define  v_RD_LATENCY_ST_NUM(x)			(((x)&0x1f)<<20)
-#define  m_RD_LATENCY_EN			(0x1<<0)
-#define  m_HAND_LATENCY_CLR			(0x1<<1)
-#define  m_RD_LATENCY_MODE			(0x1<<2)
-#define  m_RD_LATENCY_ID0			(0xf<<4)
-#define  m_RD_LATENCY_THR			(0xfff<<8)
-#define  m_RD_LATENCY_ST_NUM			(0x1f<<20)
-
-#define RD_MAX_LATENCY_NUM0		(0x254)
-#define v_RD_MAX_LATENCY_NUM_CH0(x)		(((x)&0xFFF)<<0)
-#define v_RD_LATENCY_OVERFLOW_CH0(x)		(((x)&0x1)<<16)
-#define m_RD_MAX_LATENCY_NUM_CH0		(0xFFF<<0)
-#define m_RD_LATENCY_OVERFLOW_CH0		(0x1<<16)
-
-#define RD_LATENCY_THR_NUM0		(0x258)
-#define v_RD_LATENCY_THR_NUM_CH0(x)		(((x)&0xFFFFFF)<<0)
-#define m_RD_LATENCY_THR_NUM_CH0		(0xFFFFFF<<0)
-
-#define RD_LATENCY_SWAP_NUM0		(0x25c)
-#define v_RD_LATENCY_SAMP_NUM_CH0(x)		(((x)&0xFFFFFF)<<0)
-#define m_RD_LATENCY_SAMP_NUM_CH0		(0xFFFFFF<<0)
-
-#define VOP_STATUS                      0x000002a4
-#define v_VOP_DSP_VCNT(x)			(((x)&0x1FFF)<<0)
-#define v_VOP_MMU_IDLE(x)			(((x)&0x1)<<16)
-#define v_DMA_STOP_VALID(x)			(((x)&0x1)<<17)
-#define m_VOP_DSP_VCNT				(0x1FFF<<0)
-#define m_VOP_MMU_IDLE				(0x1<<16)
-#define m_DMA_STOP_VALID			(0x1<<17)
-
-#define BLANKING_VALUE                  0x02a8
-#define v_BLANKING_VALUE(x)			(((x)&0xFFFFFF)<<0)
-#define v_BLANKING_VALUE_CONFIG_EN(x)		(((x)&0x1)<<24)
-#define m_BLANKING_VALUE			(0xFFFFFF<<0)
-#define m_BLANKING_VALUE_CONFIG_EN		(0x1<<24)
-
-#define WIN0_DSP_BG_RK3368		(0x260)
-#define WIN0_DSP_BG_RK3366		(0x2b0)/*rk3366*/
-#define v_WIN0_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
-#define v_WIN0_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
-#define v_WIN0_DSP_BG_RED(x)			(((x)&0xff)<<16)
-#define v_WIN0_DSP_BG_EN(x)			(((x)&1)<<31)
-#define m_WIN0_DSP_BG_BLUE			(0xff<<0)
-#define m_WIN0_DSP_BG_GREEN			(0xff<<8)
-#define m_WIN0_DSP_BG_RED			(0xff<<16)
-#define m_WIN0_DSP_BG_EN			(0x1<<31)
-
-#define WIN1_DSP_BG_RK3368		(0x264)
-#define WIN1_DSP_BG_RK3366		(0x2b4)/*rk3366*/
-#define v_WIN1_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
-#define v_WIN1_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
-#define v_WIN1_DSP_BG_RED(x)			(((x)&0xff)<<16)
-#define v_WIN1_DSP_BG_EN(x)			(((x)&1)<<31)
-#define m_WIN1_DSP_BG_BLUE			(0xff<<0)
-#define m_WIN1_DSP_BG_GREEN			(0xff<<8)
-#define m_WIN1_DSP_BG_RED			(0xff<<16)
-#define m_WIN1_DSP_BG_EN			(0x1<<31)
-
-#define WIN2_DSP_BG_RK3368		(0x268)
-#define WIN2_DSP_BG_RK3366		(0x2b8)/*rk3366*/
-#define v_WIN2_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
-#define v_WIN2_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
-#define v_WIN2_DSP_BG_RED(x)			(((x)&0xff)<<16)
-#define v_WIN2_DSP_BG_EN(x)			(((x)&1)<<31)
-#define m_WIN2_DSP_BG_BLUE			(0xff<<0)
-#define m_WIN2_DSP_BG_GREEN			(0xff<<8)
-#define m_WIN2_DSP_BG_RED			(0xff<<16)
-#define m_WIN2_DSP_BG_EN			(0x1<<31)
-
-#define WIN3_DSP_BG_RK3368		(0x26c)
-#define WIN3_DSP_BG_RK3366		(0x2bC)/*rk3366*/
-#define v_WIN3_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
-#define v_WIN3_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
-#define v_WIN3_DSP_BG_RED(x)			(((x)&0xff)<<16)
-#define v_WIN3_DSP_BG_EN(x)			(((x)&1)<<31)
-#define m_WIN3_DSP_BG_BLUE			(0xff<<0)
-#define m_WIN3_DSP_BG_GREEN			(0xff<<8)
-#define m_WIN3_DSP_BG_RED			(0xff<<16)
-#define m_WIN3_DSP_BG_EN			(0x1<<31)
-
-#define SCAN_LINE_NUM			(0x270)
-#define CABC_DEBUG0			(0x274)
-#define CABC_DEBUG1			(0x278)
-#define CABC_DEBUG2			(0x27c)
-#define DBG_REG_000			(0x280)
-#define DBG_REG_001			(0x284)
-#define DBG_REG_002			(0x288)
-#define DBG_REG_003			(0x28c)
-#define DBG_REG_004			(0x290)
-#define DBG_REG_005			(0x294)
-#define DBG_REG_006			(0x298)
-#define DBG_REG_007			(0x29c)
-#define DBG_REG_008			(0x2a0)
-#define DBG_REG_016			(0x2c0)
-#define DBG_REG_017			(0x2c4)
-#define DBG_REG_018			(0x2c8)
-#define DBG_REG_019			(0x2cc)
-#define DBG_REG_020			(0x2d0)
-#define DBG_REG_021			(0x2d4)
-#define DBG_REG_022			(0x2d8)
-#define DBG_REG_023			(0x2dc)
-#define DBG_REG_028			(0x2f0)
-
-#define MMU_DTE_ADDR			(0x0300)
-#define v_MMU_DTE_ADDR(x)			(((x)&0xffffffff)<<0)
-#define m_MMU_DTE_ADDR				(0xffffffff<<0)
-
-#define MMU_STATUS			(0x0304)
-#define v_PAGING_ENABLED(x)			(((x)&1)<<0)
-#define v_PAGE_FAULT_ACTIVE(x)			(((x)&1)<<1)
-#define v_STAIL_ACTIVE(x)			(((x)&1)<<2)
-#define v_MMU_IDLE(x)				(((x)&1)<<3)
-#define v_REPLAY_BUFFER_EMPTY(x)		(((x)&1)<<4)
-#define v_PAGE_FAULT_IS_WRITE(x)		(((x)&1)<<5)
-#define v_PAGE_FAULT_BUS_ID(x)			(((x)&0x1f)<<6)
-#define m_PAGING_ENABLED			(1<<0)
-#define m_PAGE_FAULT_ACTIVE			(1<<1)
-#define m_STAIL_ACTIVE				(1<<2)
-#define m_MMU_IDLE				(1<<3)
-#define m_REPLAY_BUFFER_EMPTY			(1<<4)
-#define m_PAGE_FAULT_IS_WRITE			(1<<5)
-#define m_PAGE_FAULT_BUS_ID			(0x1f<<6)
-
-#define MMU_COMMAND			(0x0308)
-#define v_MMU_CMD(x)				(((x)&0x3)<<0)
-#define m_MMU_CMD			(0x3<<0)
-
-#define MMU_PAGE_FAULT_ADDR		(0x030c)
-#define v_PAGE_FAULT_ADDR(x)			(((x)&0xffffffff)<<0)
-#define m_PAGE_FAULT_ADDR			(0xffffffff<<0)
-
-#define MMU_ZAP_ONE_LINE		(0x0310)
-#define v_MMU_ZAP_ONE_LINE(x)			(((x)&0xffffffff)<<0)
-#define m_MMU_ZAP_ONE_LINE			(0xffffffff<<0)
-
-#define MMU_INT_RAWSTAT			(0x0314)
-#define v_PAGE_FAULT_RAWSTAT(x)			(((x)&1)<<0)
-#define v_READ_BUS_ERROR_RAWSTAT(x)		(((x)&1)<<1)
-#define m_PAGE_FAULT_RAWSTAT			(1<<0)
-#define m_READ_BUS_ERROR_RAWSTAT		(1<<1)
-
-#define MMU_INT_CLEAR			(0x0318)
-#define v_PAGE_FAULT_CLEAR(x)			(((x)&1)<<0)
-#define v_READ_BUS_ERROR_CLEAR(x)		(((x)&1)<<1)
-#define m_PAGE_FAULT_CLEAR			(1<<0)
-#define m_READ_BUS_ERROR_CLEAR			(1<<1)
-
-#define MMU_INT_MASK			(0x031c)
-#define v_PAGE_FAULT_MASK(x)			(((x)&1)<<0)
-#define v_READ_BUS_ERROR_MASK(x)		(((x)&1)<<1)
-#define m_PAGE_FAULT_MASK			(1<<0)
-#define m_READ_BUS_ERROR_MASK			(1<<1)
-
-#define MMU_INT_STATUS			(0x0320)
-#define v_PAGE_FAULT_STATUS(x)			(((x)&1)<<0)
-#define v_READ_BUS_ERROR_STATUS(x)		(((x)&1)<<1)
-#define m_PAGE_FAULT_STATUS			(1<<0)
-#define m_READ_BUS_ERROR_STATUS			(1<<1)
-
-#define MMU_AUTO_GATING			(0x0324)
-#define v_MMU_AUTO_GATING(x)			(((x)&1)<<0)
-#define m_MMU_AUTO_GATING			(1<<0)
-
-#define WIN2_LUT_ADDR			(0x0400)
-#define WIN3_LUT_ADDR			(0x0800)
-#define HWC_LUT_ADDR			(0x0c00)
-#define GAMMA_LUT_ADDR			(0x1000)
-#define CABC_GAMMA_LUT_ADDR		(0x1800)
-#define MCU_BYPASS_WPORT		(0x2200)
-#define MCU_BYPASS_RPORT		(0x2300)
-
-#define PMUGRF_SOC_CON0_VOP		(0x0100)
-
-#define RK3366_GRF_SOC_CON0		(0x0400)
-#define RK3366_GRF_SOC_CON5		(0x0414)
-
-#define OUT_CCIR656_MODE_0              5
-#define OUT_CCIR656_MODE_1              6
-#define OUT_CCIR656_MODE_2              7
-
-#define VOP_SOURCE_SEL(id, shift)	((id << shift) | 1 << (shift + 16))
-#define RGB_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 3)
-#define LVDS_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 0)
-#define MIPI_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 2)
-#define HDMI_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 1)
-
-#define RGB_DATA_PLANA			((2 << 6) | (3 << (6 + 16)))
-#define RGB_DATA_PLANB			((3 << 6) | (3 << (6 + 16)))
-
-#define RK3366_GRF_IO_VSEL		0x0900
-#define RK3366_GRF_VOP_IOVOL_SEL(x)	(((x) << 0) | (1 << (0 + 16)))
-#define RK3368_GRF_VOP_IOVOL_SEL(x)	(((x) << 5) | (1 << (5 + 16)))
-
-#define RK3366_WB_ALIGN			16
-
-enum lb_mode {
-	LB_YUV_3840X5 = 0x0,
-	LB_YUV_2560X8 = 0x1,
-	LB_RGB_3840X2 = 0x2,
-	LB_RGB_2560X4 = 0x3,
-	LB_RGB_1920X5 = 0x4,
-	LB_RGB_1280X8 = 0x5
-};
-
-enum sacle_up_mode {
-	SCALE_UP_BIL = 0x0,
-	SCALE_UP_BIC = 0x1
-};
-
-enum scale_down_mode {
-	SCALE_DOWN_BIL = 0x0,
-	SCALE_DOWN_AVG = 0x1
-};
-
-/*ALPHA BLENDING MODE*/
-enum alpha_mode {               /*  Fs       Fd */
-	AB_USER_DEFINE     = 0x0,
-	AB_CLEAR	   = 0x1,/*  0          0*/
-	AB_SRC		   = 0x2,/*  1          0*/
-	AB_DST		   = 0x3,/*  0          1  */
-	AB_SRC_OVER	   = 0x4,/*  1		    1-As''*/
-	AB_DST_OVER	   = 0x5,/*  1-Ad''   1*/
-	AB_SRC_IN	   = 0x6,
-	AB_DST_IN	   = 0x7,
-	AB_SRC_OUT	   = 0x8,
-	AB_DST_OUT	   = 0x9,
-	AB_SRC_ATOP        = 0xa,
-	AB_DST_ATOP	   = 0xb,
-	XOR                = 0xc,
-	AB_SRC_OVER_GLOBAL = 0xd
-}; /*alpha_blending_mode*/
-
-enum src_alpha_mode {
-	AA_STRAIGHT	   = 0x0,
-	AA_INVERSE         = 0x1
-};/*src_alpha_mode*/
-
-enum global_alpha_mode {
-	AA_GLOBAL	  = 0x0,
-	AA_PER_PIX        = 0x1,
-	AA_PER_PIX_GLOBAL = 0x2
-};/*src_global_alpha_mode*/
-
-enum src_alpha_sel {
-	AA_SAT		= 0x0,
-	AA_NO_SAT	= 0x1
-};/*src_alpha_sel*/
-
-enum src_color_mode {
-	AA_SRC_PRE_MUL	       = 0x0,
-	AA_SRC_NO_PRE_MUL      = 0x1
-};/*src_color_mode*/
-
-enum factor_mode {
-	AA_ZERO			= 0x0,
-	AA_ONE			= 0x1,
-	AA_SRC			= 0x2,
-	AA_SRC_INVERSE          = 0x3,
-	AA_SRC_GLOBAL           = 0x4
-};/*src_factor_mode  &&  dst_factor_mode*/
-
-enum _vop_r2y_csc_mode {
-	VOP_R2Y_CSC_BT601 = 0,
-	VOP_R2Y_CSC_BT709
-};
-
-enum _vop_y2r_csc_mode {
-	VOP_Y2R_CSC_MPEG = 0,
-	VOP_Y2R_CSC_JPEG,
-	VOP_Y2R_CSC_HD,
-	VOP_Y2R_CSC_BYPASS
-};
-enum _vop_format {
-	VOP_FORMAT_ARGB888 = 0,
-	VOP_FORMAT_RGB888,
-	VOP_FORMAT_RGB565,
-	VOP_FORMAT_YCBCR420 = 4,
-	VOP_FORMAT_YCBCR422,
-	VOP_FORMAT_YCBCR444
-};
-
-enum _vop_overlay_mode {
-	VOP_RGB_DOMAIN,
-	VOP_YUV_DOMAIN
-};
-
-enum cabc_stage_mode {
-	LAST_FRAME_PWM_VAL	= 0x0,
-	CUR_FRAME_PWM_VAL	= 0x1,
-	STAGE_BY_STAGE		= 0x2
-};
-
-struct lcdc_device {
-	int id;
-	u32 soc_type;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;		/*back up reg*/
-	u32 reg_phy_base;	/* physical basic address of lcdc register*/
-	struct regmap *grf_base;
-	struct regmap *pmugrf_base;
-	struct regmap *cru_base;
-	u32 len;		/* physical map length of lcdc register*/
-	/*one time only one process allowed to config the register*/
-	spinlock_t reg_lock;
-
-	int __iomem *dsp_lut_addr_base;
-	int __iomem *cabc_lut_addr_base;
-
-
-	int prop;		/*used for primary or extended display device*/
-	bool pre_init;
-	bool pwr18;		/*if lcdc use 1.8v power supply*/
-	/*if aclk or hclk is closed ,acess to register is not allowed*/
-	bool clk_on;
-	/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
-	u8 atv_layer_cnt;
-
-
-	unsigned int		irq;
-
-	struct clk		*pd;		/*lcdc power domain*/
-	struct clk		*hclk;		/*lcdc AHP clk*/
-	struct clk		*dclk;		/*lcdc dclk*/
-	struct clk		*aclk;		/*lcdc share memory frequency*/
-	u32 pixclock;
-
-	u32 standby;				/*1:standby,0:wrok*/
-	u32 iommu_status;
-	struct backlight_device *backlight;
-	struct clk		*pll_sclk;
-};
-
-struct alpha_config {
-	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
-	u32 src_global_alpha_val; /*win0_src_global_alpha*/
-	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
-	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
-	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
-	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
-	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
-};
-
-struct lcdc_cabc_mode {
-	u32 pixel_num;			/* pixel precent number */
-	u16 stage_up;			/* up stride */
-	u16 stage_down;		/* down stride */
-	u16 global_su;
-};
-
-static inline void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	*_pv = v;
-	writel_relaxed(v, lcdc_dev->regs + offset);
-}
-
-static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
-{
-	u32 v;
-
-	v = readl_relaxed(lcdc_dev->regs + offset);
-	return v;
-}
-
-static inline u32 lcdc_readl_backup(struct lcdc_device *lcdc_dev, u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	v = readl_relaxed(lcdc_dev->regs + offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,
-				u32 offset, u32 msk)
-{
-	u32 v;
-	u32 _v = readl_relaxed(lcdc_dev->regs + offset);
-
-	_v &= msk;
-	v = (_v ? 1 : 0);
-	return v;
-}
-
-static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,
-				 u32 offset, u32 msk)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) |= msk;
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-}
-
-static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,
-				u32 offset, u32 msk)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~msk);
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-}
-
-static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,
-				 u32 offset, u32 msk, u32 v)
-{
-	u32 *_pv = (u32 *)lcdc_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~msk);
-	(*_pv) |= v;
-	writel_relaxed(*_pv, lcdc_dev->regs + offset);
-        if (((lcdc_dev->soc_type == VOP_FULL_RK3366) && (offset == INTR_CLEAR_RK3366)) ||
-	    ((lcdc_dev->soc_type == VOP_FULL_RK3368) && (offset == INTR_CLEAR_RK3368)))
-                (*_pv) &= 0;
-}
-
-static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev)
-{
-	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE);
-	dsb(sy);
-}
-
-static inline int lcdc_grf_writel(struct regmap *base,
-				  u32 offset, u32 val)
-{
-	if (base)
-		regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int lcdc_cru_writel(struct regmap *base,
-				  u32 offset, u32 val)
-{
-	if (base)
-		regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int lcdc_cru_readl(struct regmap *base,
-				  u32 offset)
-{
-	u32 v;
-	regmap_read(base, offset, &v);
-
-	return v;
-}
-
-#define CUBIC_PRECISE  0
-#define CUBIC_SPLINE   1
-#define CUBIC_CATROM   2
-#define CUBIC_MITCHELL 3
-
-#define FBDC_FMT_RGB565		0x5
-#define FBDC_FMT_U8U8U8U8	0xc /*ARGB888*/
-#define FBDC_FMT_U8U8U8		0x3a /*RGBP888*/
-
-#define CUBIC_MODE_SELETION      CUBIC_PRECISE
-
-/*************************************************************/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      \
-	((INT32)((x) * (1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
-
-#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
-#define SCALE_FACTOR_AVRG_FIXPOINT(x)      \
-	((INT32)((x) * (1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
-#define SCALE_FACTOR_BIC_FIXPOINT(x)       \
-	((INT32)((x) * (1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
-#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
-
-/*********************************************************/
-
-/*#define GET_SCALE_FACTOR_BILI(src, dst)  \
-	((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*#define GET_SCALE_FACTOR_BIC(src, dst)   \
-	((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*modified by hpz*/
-#define GET_SCALE_FACTOR_BILI_DN(src, dst)  \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-#define GET_SCALE_FACTOR_BILI_UP(src, dst)  \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-#define GET_SCALE_FACTOR_BIC(src, dst)      \
-	((((src) * 2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT - 1)) \
-	/ ((dst) - 1))
-
-/*********************************************************/
-/*NOTE: hardware in order to save resource , srch first to get interlace line
-(srch+vscalednmult-1)/vscalednmult; and do scale*/
-#define GET_SCALE_DN_ACT_HEIGHT(srch, vscalednmult) \
-	(((srch) + (vscalednmult) - 1) / (vscalednmult))
-
-/*#define VSKIP_MORE_PRECISE*/
-
-#ifdef VSKIP_MORE_PRECISE
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
-	(GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
-	(vscalednmult)), (dsth)))
-#else
-#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
-#if 0/*rk3288*/
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
-	((GET_SCALE_DN_ACT_HEIGHT((srch), (vscalednmult)) == (dsth))\
-		? (GET_SCALE_FACTOR_BILI_DN((srch),\
-		(dsth))/(vscalednmult))\
-		: GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
-		(vscalednmult)), (dsth)))
-#else/*rk3368*/
-#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
-	((GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == (dsth)) \
-	? (GET_SCALE_FACTOR_BILI_DN((srch) , (dsth)) / (vscalednmult)) \
-	: (GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == ((dsth) * 2)) \
-	?  GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT(((srch) - 1),\
-	(vscalednmult)) , (dsth)) : \
-	GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
-	(vscalednmult)) , (dsth)))
-#endif
-
-
-#endif
-/*****************************************************************/
-
-
-/*scalefactor must >= dst/src, or pixels at end of line may be unused*/
-/*scalefactor must < dst/(src-1), or dst buffer may overflow*/
-/*avrg old code: ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))\
-	/((src) - 1)) hxx_chgsrc*/
-/*modified by hpz:*/
-#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << \
-	(SCALE_FACTOR_AVRG_FIXPOINT_SHIFT + 1))) / (2 * (src) - 1))
-
-/*************************************************************************/
-/*Scale Coordinate Accumulate, x.16*/
-#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
-#define SCALE_COOR_ACC_FIXPOINT_ONE (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
-#define SCALE_COOR_ACC_FIXPOINT(x) \
-	((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
-#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) \
-	((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT - 1)) + 1) >> 1)
-
-#define SCALE_GET_COOR_ACC_FIXPOINT(scalefactor, factorfixpointshift)  \
-	((scalefactor) << \
-	(SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorfixpointshift)))
-
-
-/************************************************************************/
-/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
-#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
-#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       \
-	(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
-#define SCALE_FILTER_FACTOR_FIXPOINT(x)        \
-	((INT32)((x) * (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
-#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) \
-	((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
-
-#define SCALE_GET_FILTER_FACTOR_FIXPOINT(cooraccumulate, \
-	cooraccfixpointshift) \
-	(((cooraccumulate) >> \
-	((cooraccfixpointshift) - SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)) & \
-	(SCALE_FILTER_FACTOR_FIXPOINT_ONE - 1))
-
-#define SCALE_OFFSET_FIXPOINT_SHIFT            8
-#define SCALE_OFFSET_FIXPOINT(x)              \
-	((INT32)((x) * (1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
-
-
-extern void rk_pwm_set(int bl_pwm_period, int bl_pwm_duty);
-extern void rk_pwm_get(int *bl_pwm_period, int *bl_pwm_duty);
-#endif
diff --git a/drivers/video/rockchip/lcdc/rk_vop_lite.c b/drivers/video/rockchip/lcdc/rk_vop_lite.c
deleted file mode 100644
index 7c1521ef64fc..000000000000
--- a/drivers/video/rockchip/lcdc/rk_vop_lite.c
+++ /dev/null
@@ -1,2643 +0,0 @@
-/*
- * rockchip VOP(Video Output Processer) hardware driver.
- *
- * Copyright (C) 2016 Rockchip Electronics Co., Ltd.
- * Author: WenLong Zhuang <daisen.zhuang@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/pm_runtime.h>
-#include <linux/rockchip-iovmm.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/grf.h>
-#include <dt-bindings/clock/rk_system_status.h>
-
-#include "rk_vop_lite.h"
-
-static int dbg_thresd;
-module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
-
-#define DBG(level, x...) do {			\
-	if (unlikely(dbg_thresd >= level))	\
-		pr_info(x);\
-	} while (0)
-
-#define to_vop_dev(drv) container_of(drv, struct vop_device, driver)
-
-static struct rk_lcdc_win vop_win[] = {
-	{ .name = "win0", .id = 0},
-	{ .name = "win1", .id = 1},
-	{ .name = "hwc",  .id = 2}
-};
-
-static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
-
-static int vop_clk_enable(struct vop_device *vop_dev)
-{
-	if (!vop_dev->clk_on) {
-		pm_runtime_get_sync(vop_dev->dev);
-
-		clk_enable(vop_dev->hclk);
-		clk_enable(vop_dev->aclk);
-		clk_enable(vop_dev->dclk);
-		spin_lock(&vop_dev->reg_lock);
-		vop_dev->clk_on = 1;
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int vop_clk_disable(struct vop_device *vop_dev)
-{
-	if (vop_dev->clk_on) {
-		spin_lock(&vop_dev->reg_lock);
-		vop_dev->clk_on = 0;
-		spin_unlock(&vop_dev->reg_lock);
-		clk_disable(vop_dev->dclk);
-		clk_disable(vop_dev->aclk);
-		clk_disable(vop_dev->hclk);
-
-		pm_runtime_put(vop_dev->dev);
-	}
-
-	return 0;
-}
-
-static int vop_irq_enable(struct vop_device *vop_dev)
-{
-	u64 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_mask_writel(vop_dev, INTR_CLEAR, INTR_MASK, INTR_MASK);
-
-		val = INTR_FS0 | INTR_FS1 | INTR_LINE_FLAG0 | INTR_LINE_FLAG1 |
-			INTR_BUS_ERROR | INTR_WIN0_EMPTY | INTR_WIN1_EMPTY |
-			INTR_DSP_HOLD_VALID;
-		vop_mask_writel(vop_dev, INTR_EN, INTR_MASK, val);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_irq_disable(struct vop_device *vop_dev)
-{
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_writel(vop_dev, INTR_EN, 0xffff0000);
-		vop_writel(vop_dev, INTR_CLEAR, 0xffffffff);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_standby_enable(struct vop_device *vop_dev)
-{
-	u64 val;
-	int ret;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_dev->sync.stdbyfin.done = 0;
-
-		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_BLANK_EN(1));
-		/*vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);*/
-		val = V_IMD_VOP_STANDBY_EN(1) | V_IMD_VOP_DMA_STOP(1) |
-			V_IMD_DSP_OUT_ZERO(1);
-		vop_msk_reg(vop_dev, SYS_CTRL2, val);
-		vop_cfg_done(vop_dev);
-		spin_unlock(&vop_dev->reg_lock);
-
-		/* wait for standby hold valid */
-		ret = vop_completion_timeout_ms(&vop_dev->sync.stdbyfin,
-						vop_dev->sync.stdbyfin_to);
-		if (!ret) {
-			dev_err(vop_dev->dev,
-				"wait standby hold valid timeout %dms\n",
-				vop_dev->sync.stdbyfin_to);
-			return -ETIMEDOUT;
-		}
-	} else {
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int vop_standby_disable(struct vop_device *vop_dev)
-{
-	u64 val;
-	int ret;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_dev->sync.frmst.done = 0;
-		val = V_IMD_VOP_STANDBY_EN(0) | V_IMD_VOP_DMA_STOP(0) |
-			V_IMD_DSP_OUT_ZERO(0);
-		vop_msk_reg(vop_dev, SYS_CTRL2, val);
-		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_BLANK_EN(0));
-		vop_cfg_done(vop_dev);
-		spin_unlock(&vop_dev->reg_lock);
-
-		/* win address maybe effect after next frame start,
-		 * but mmu maybe effect right now, so need wait frame start
-		 */
-		ret = vop_completion_timeout_ms(&vop_dev->sync.frmst,
-						vop_dev->sync.frmst_to);
-		if (!ret) {
-			dev_err(vop_dev->dev, "wait frame start timeout %dms\n",
-				vop_dev->sync.frmst_to);
-			return -ETIMEDOUT;
-		}
-	} else {
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int vop_mmu_enable(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (!dev_drv->iommu_enabled || !dev_drv->mmu_dev) {
-		pr_debug("%s: VOP iommu is disabled or not find mmu dev\n",
-			 __func__);
-		return -ENODEV;
-	}
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		if (!vop_dev->iommu_status) {
-			vop_dev->iommu_status = 1;
-			rockchip_iovmm_activate(dev_drv->dev);
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_mmu_disable(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (!dev_drv->iommu_enabled || !dev_drv->mmu_dev) {
-		pr_debug("%s: VOP iommu is disabled or not find mmu dev\n",
-			 __func__);
-		return -ENODEV;
-	}
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		if (vop_dev->iommu_status) {
-			vop_dev->iommu_status = 0;
-			rockchip_iovmm_deactivate(dev_drv->dev);
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_reg_dump(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int *cbase = (int *)vop_dev->regs;
-	int *regsbak = (int *)vop_dev->regsbak;
-	int i, j, val;
-	char dbg_message[30];
-	char buf[10];
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		pr_info("vop back up reg:\n");
-		memset(dbg_message, 0, sizeof(dbg_message));
-		memset(buf, 0, sizeof(buf));
-		for (i = 0; i <= (0x200 >> 4); i++) {
-			val = sprintf(dbg_message, "0x%04x: ", i * 16);
-			for (j = 0; j < 4; j++) {
-				val = sprintf(buf, "%08x  ",
-					      *(regsbak + i * 4 + j));
-				strcat(dbg_message, buf);
-			}
-			pr_info("%s\n", dbg_message);
-			memset(dbg_message, 0, sizeof(dbg_message));
-			memset(buf, 0, sizeof(buf));
-		}
-
-		pr_info("vop reg:\n");
-		for (i = 0; i <= (0x200 >> 4); i++) {
-			val = sprintf(dbg_message, "0x%04x: ", i * 16);
-			for (j = 0; j < 4; j++) {
-				sprintf(buf, "%08x  ",
-					readl_relaxed(cbase + i * 4 + j));
-				strcat(dbg_message, buf);
-			}
-			pr_info("%s\n", dbg_message);
-			memset(dbg_message, 0, sizeof(dbg_message));
-			memset(buf, 0, sizeof(buf));
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-#define WIN_EN(id)		\
-static int win##id##_enable(struct vop_device *vop_dev, int en)	\
-{ \
-	spin_lock(&vop_dev->reg_lock);					\
-	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN((u64)en));	\
-	vop_cfg_done(vop_dev);						\
-	spin_unlock(&vop_dev->reg_lock);				\
-	return 0;							\
-}
-
-WIN_EN(0);
-WIN_EN(1);
-
-/*
- * enable/disable win directly
- */
-static int vop_win_direct_en(struct rk_lcdc_driver *drv,
-			     int win_id, int en)
-{
-	struct vop_device *vop_dev = to_vop_dev(drv);
-
-	if (win_id == 0)
-		win0_enable(vop_dev, en);
-	else if (win_id == 1)
-		win1_enable(vop_dev, en);
-	else
-		dev_err(vop_dev->dev, "invalid win number:%d\n", win_id);
-	return 0;
-}
-
-#define SET_WIN_ADDR(id) \
-static int set_win##id##_addr(struct vop_device *vop_dev, u32 addr) \
-{							\
-	spin_lock(&vop_dev->reg_lock);			\
-	vop_writel(vop_dev, WIN##id##_YRGB_MST, addr);	\
-	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN(1));	\
-	vop_cfg_done(vop_dev);			\
-	spin_unlock(&vop_dev->reg_lock);		\
-	return 0;					\
-}
-
-SET_WIN_ADDR(0);
-SET_WIN_ADDR(1);
-
-static int vop_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
-				   int win_id, u32 addr)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (win_id == 0)
-		set_win0_addr(vop_dev, addr);
-	else
-		set_win1_addr(vop_dev, addr);
-
-	return 0;
-}
-
-static void vop_read_reg_default_cfg(struct vop_device *vop_dev)
-{
-	int reg = 0;
-	u32 val = 0;
-	struct rk_screen *screen = vop_dev->driver.cur_screen;
-	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
-	u32 V_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
-	u32 st_x, st_y;
-	struct rk_lcdc_win *win0 = vop_dev->driver.win[0];
-
-	spin_lock(&vop_dev->reg_lock);
-	for (reg = 0; reg < vop_dev->len; reg += 4) {
-		val = vop_readl_backup(vop_dev, reg);
-		switch (reg) {
-		case WIN0_ACT_INFO:
-			win0->area[0].xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
-			win0->area[0].yact =
-				((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-			break;
-		case WIN0_DSP_INFO:
-			win0->area[0].xsize = (val & MASK(WIN0_DSP_WIDTH)) + 1;
-			win0->area[0].ysize =
-			    ((val & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
-			break;
-		case WIN0_DSP_ST:
-			st_x = val & MASK(WIN0_DSP_XST);
-			st_y = (val & MASK(WIN0_DSP_YST)) >> 16;
-			win0->area[0].xpos = st_x - h_pw_bp;
-			win0->area[0].ypos = st_y - V_pw_bp;
-			break;
-		case WIN0_CTRL0:
-			win0->state = val & MASK(WIN0_EN);
-			win0->area[0].fmt_cfg =
-					(val & MASK(WIN0_DATA_FMT)) >> 1;
-			win0->area[0].format = win0->area[0].fmt_cfg;
-			break;
-		case WIN0_VIR:
-			win0->area[0].y_vir_stride =
-					val & MASK(WIN0_YRGB_VIR_STRIDE);
-			win0->area[0].uv_vir_stride =
-			    (val & MASK(WIN0_CBR_VIR_STRIDE)) >> 16;
-			if (win0->area[0].format == ARGB888)
-				win0->area[0].xvir = win0->area[0].y_vir_stride;
-			else if (win0->area[0].format == RGB888)
-				win0->area[0].xvir =
-				    win0->area[0].y_vir_stride * 4 / 3;
-			else if ((win0->area[0].format == RGB565) ||
-				 (win0->area[0].format == BGR565))
-				win0->area[0].xvir =
-				    2 * win0->area[0].y_vir_stride;
-			else
-				win0->area[0].xvir =
-				    4 * win0->area[0].y_vir_stride;
-			break;
-		case WIN0_YRGB_MST:
-			win0->area[0].smem_start = val;
-			break;
-		case WIN0_CBR_MST:
-			win0->area[0].cbr_start = val;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-}
-
-static int vop_pre_init(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (vop_dev->pre_init)
-		return 0;
-
-	if (dev_drv->iommu_enabled) {
-		dev_drv->mmu_dev = rk_fb_get_sysmmu_device_by_compatible(
-							dev_drv->mmu_dts_name);
-		if (dev_drv->mmu_dev)
-			rk_fb_platform_set_sysmmu(
-				dev_drv->mmu_dev, dev_drv->dev);
-		else
-			dev_err(dev_drv->dev, "fail get rk iommu device\n");
-	}
-
-	if (!support_uboot_display())
-		rk_disp_pwr_enable(dev_drv);
-
-	vop_clk_enable(vop_dev);
-
-	/* backup reg config at uboot */
-	vop_read_reg_default_cfg(vop_dev);
-
-	/* vop io voltage select-->0: 3.3v; 1: 1.8v */
-	if (vop_dev->pwr18 == 1)
-		vop_grf_writel(vop_dev->grf_base, GRF_IO_VSEL,
-			       V_VOP_IOVOL_SEL(1));
-	else
-		vop_grf_writel(vop_dev->grf_base, GRF_IO_VSEL,
-			       V_VOP_IOVOL_SEL(0));
-
-	vop_msk_reg(vop_dev, SYS_CTRL1, V_SW_AXI_MAX_OUTSTAND_EN(1) |
-		    V_SW_AXI_MAX_OUTSTAND_NUM(31));
-	vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_AUTO_GATING_EN(0));
-	vop_cfg_done(vop_dev);
-	vop_dev->pre_init = true;
-
-	return 0;
-}
-
-static void vop_deinit(struct vop_device *vop_dev)
-{
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-
-	vop_standby_enable(vop_dev);
-	vop_irq_disable(vop_dev);
-	vop_mmu_disable(dev_drv);
-	vop_clk_disable(vop_dev);
-	clk_unprepare(vop_dev->dclk);
-	clk_unprepare(vop_dev->aclk);
-	clk_unprepare(vop_dev->hclk);
-	pm_runtime_disable(vop_dev->dev);
-}
-
-static void __maybe_unused
-vop_win_csc_mode(struct vop_device *vop_dev, struct rk_lcdc_win *win,
-		 int csc_mode)
-{
-	u64 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		if (win->id == 0) {
-			val = V_WIN0_CSC_MODE(csc_mode);
-			vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-		} else if (win->id == 1) {
-			val = V_WIN1_CSC_MODE(csc_mode);
-			vop_msk_reg(vop_dev, WIN1_CTRL0, val);
-		} else {
-			dev_err(vop_dev->dev, "%s win%d unsupport csc mode",
-				__func__, win->id);
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-}
-
-static int vop_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win;
-	int i;
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		switch (i) {
-		case 0:
-			vop_writel(vop_dev, WIN0_COLOR_KEY, win->color_key_val);
-			break;
-		case 1:
-			vop_writel(vop_dev, WIN1_COLOR_KEY, win->color_key_val);
-			break;
-		default:
-			pr_info("%s:un support win num:%d\n",
-				__func__, i);
-			break;
-		}
-	}
-	return 0;
-}
-
-static int vop_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u64 val;
-	int ppixel_alpha = 0;
-	int alpha_en = win->alpha_en;
-	int i;
-
-	if (!alpha_en) {
-		if (win_id == 0) {
-			val = V_WIN0_ALPHA_EN(0);
-			vop_msk_reg(vop_dev, WIN0_ALPHA_CTRL, val);
-		} else {
-			val = V_WIN1_ALPHA_EN(0);
-			vop_msk_reg(vop_dev, WIN1_ALPHA_CTRL, val);
-		}
-		return 0;
-	}
-
-	ppixel_alpha = ((win->area[0].format == ARGB888) ||
-			(win->area[0].format == ABGR888)) ? 1 : 0;
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		if (!dev_drv->win[i]->state)
-			continue;
-		if (win->z_order > dev_drv->win[i]->z_order)
-			break;
-	}
-
-	/*
-	 * The bottom layer not support ppixel_alpha mode.
-	 */
-	if (i == dev_drv->lcdc_win_num) {
-		ppixel_alpha = 0;
-		alpha_en = 0;
-	}
-
-	if (win_id == 0) {
-		val = V_WIN0_ALPHA_EN(alpha_en) |
-			V_WIN0_ALPHA_MODE(ppixel_alpha) |
-			V_WIN0_ALPHA_PRE_MUL(ppixel_alpha) |
-			V_WIN0_ALPHA_SAT_MODE(0);
-		vop_msk_reg(vop_dev, WIN0_ALPHA_CTRL, val);
-	} else if (win_id == 1) {
-		val = V_WIN1_ALPHA_EN(alpha_en) |
-			V_WIN1_ALPHA_MODE(ppixel_alpha) |
-			V_WIN1_ALPHA_PRE_MUL(ppixel_alpha) |
-			V_WIN1_ALPHA_SAT_MODE(0);
-		vop_msk_reg(vop_dev, WIN1_ALPHA_CTRL, val);
-	} else {
-		dev_err(vop_dev->dev, "%s: invalid win id=%d or unsupport\n",
-			__func__, win_id);
-	}
-
-	return 0;
-}
-
-static int vop_axi_gather_cfg(struct vop_device *vop_dev,
-			      struct rk_lcdc_win *win)
-{
-	u64 val;
-	u16 yrgb_gather_num = 3;
-	u16 cbcr_gather_num = 1;
-
-	switch (win->area[0].format) {
-	case ARGB888:
-	case XBGR888:
-	case ABGR888:
-	case XRGB888:
-		yrgb_gather_num = 3;
-		break;
-	case RGB888:
-	case RGB565:
-	case BGR888:
-	case BGR565:
-		yrgb_gather_num = 2;
-		break;
-	case YUV444:
-	case YUV422:
-	case YUV420:
-	case YUV420_A:
-	case YUV422_A:
-	case YUV444_A:
-	case YUV420_NV21:
-		yrgb_gather_num = 1;
-		cbcr_gather_num = 2;
-		break;
-	default:
-		dev_err(vop_dev->driver.dev, "%s:un supported format[%d]\n",
-			__func__, win->area[0].format);
-		return -EINVAL;
-	}
-
-	if (win->id == 0) {
-		val = V_WIN0_YRGB_AXI_GATHER_EN(1) |
-			V_WIN0_CBR_AXI_GATHER_EN(1) |
-			V_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
-			V_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
-		vop_msk_reg(vop_dev, WIN0_CTRL1, val);
-	} else if (win->id == 1) {
-		val = V_WIN1_AXI_GATHER_EN(1) |
-			V_WIN1_AXI_GATHER_NUM(yrgb_gather_num);
-		vop_msk_reg(vop_dev, WIN1_CTRL1, val);
-	}
-	return 0;
-}
-
-static int vop_win0_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u64 val;
-
-	if (win->state == 1) {
-		vop_axi_gather_cfg(vop_dev, win);
-		val = V_WIN0_EN(win->state) |
-			V_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
-			V_WIN0_RB_SWAP(win->area[0].swap_rb) |
-			V_WIN0_UV_SWAP(win->area[0].swap_uv);
-		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED)
-			val |= V_WIN0_INTERLACE_READ(1);
-		else
-			val |= V_WIN0_INTERLACE_READ(0);
-		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-
-		val = V_WIN0_YRGB_VIR_STRIDE(win->area[0].y_vir_stride) |
-		    V_WIN0_CBR_VIR_STRIDE(win->area[0].uv_vir_stride);
-		vop_writel(vop_dev, WIN0_VIR, val);
-
-		val = V_WIN0_DSP_WIDTH(win->area[0].xsize - 1) |
-		    V_WIN0_DSP_HEIGHT(win->area[0].ysize - 1);
-		vop_writel(vop_dev, WIN0_DSP_INFO, val);
-
-		val = V_WIN0_DSP_XST(win->area[0].dsp_stx) |
-		    V_WIN0_DSP_YST(win->area[0].dsp_sty);
-		vop_writel(vop_dev, WIN0_DSP_ST, val);
-
-		/* only win0 support scale and yuv */
-		val = V_WIN0_ACT_WIDTH(win->area[0].xact - 1) |
-			V_WIN0_ACT_HEIGHT(win->area[0].yact - 1);
-		vop_writel(vop_dev, WIN0_ACT_INFO, val);
-
-		val = V_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
-			V_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
-		vop_writel(vop_dev, WIN0_SCL_FACTOR_YRGB, val);
-
-		val = V_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
-			V_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
-		vop_writel(vop_dev, WIN0_SCL_FACTOR_CBR, val);
-
-		if (win->area[0].y_addr > 0)
-			vop_writel(vop_dev, WIN0_YRGB_MST, win->area[0].y_addr);
-		if (win->area[0].uv_addr > 0)
-			vop_writel(vop_dev, WIN0_CBR_MST, win->area[0].uv_addr);
-
-		vop_alpha_cfg(dev_drv, win_id);
-	} else {
-		val = V_WIN0_EN(win->state);
-		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-	}
-
-	return 0;
-}
-
-static int vop_win1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	u64 val;
-
-	if (win->state == 1) {
-		vop_axi_gather_cfg(vop_dev, win);
-		val = V_WIN1_EN(win->state) |
-			V_WIN1_DATA_FMT(win->area[0].fmt_cfg) |
-			V_WIN1_RB_SWAP(win->area[0].swap_rb);
-		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED)
-			val |= V_WIN1_INTERLACE_READ(1);
-		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
-
-		val = V_WIN1_VIR_STRIDE(win->area[0].y_vir_stride);
-		vop_writel(vop_dev, WIN1_VIR, val);
-
-		val = V_WIN1_DSP_WIDTH(win->area[0].xsize - 1) |
-		    V_WIN1_DSP_HEIGHT(win->area[0].ysize - 1);
-		vop_writel(vop_dev, WIN1_DSP_INFO, val);
-
-		val = V_WIN1_DSP_XST(win->area[0].dsp_stx) |
-		    V_WIN1_DSP_YST(win->area[0].dsp_sty);
-		vop_writel(vop_dev, WIN1_DSP_ST, val);
-
-		if (win->area[0].y_addr > 0)
-			vop_writel(vop_dev, WIN1_YRGB_MST, win->area[0].y_addr);
-
-		vop_alpha_cfg(dev_drv, win_id);
-	} else {
-		val = V_WIN1_EN(win->state);
-		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
-	}
-
-	return 0;
-}
-
-static int vop_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win = dev_drv->win[win_id];
-	unsigned int hwc_size = 0;
-	u64 val;
-
-	if (win->state == 1) {
-		vop_axi_gather_cfg(vop_dev, win);
-
-		if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32))
-			hwc_size = 0;
-		else if ((win->area[0].xsize == 64) &&
-			 (win->area[0].ysize == 64))
-			hwc_size = 1;
-		else
-			dev_err(vop_dev->dev, "unsupported hwc size[%dx%d]!\n",
-				win->area[0].xsize, win->area[0].ysize);
-
-		val = V_HWC_EN(1) | V_HWC_SIZE(hwc_size);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-
-		val = V_HWC_DSP_XST(win->area[0].dsp_stx) |
-		    V_HWC_DSP_YST(win->area[0].dsp_sty);
-		vop_msk_reg(vop_dev, HWC_DSP_ST, val);
-
-		if (win->area[0].y_addr > 0)
-			vop_writel(vop_dev, HWC_MST, win->area[0].y_addr);
-	} else {
-		val = V_HWC_EN(win->state);
-		vop_msk_reg(vop_dev, HWC_CTRL0, val);
-	}
-
-	return 0;
-}
-
-static int vop_layer_update_regs(struct vop_device *vop_dev,
-				 struct rk_lcdc_win *win)
-{
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-
-	vop_msk_reg(vop_dev, SYS_CTRL2,
-		    V_IMD_VOP_STANDBY_EN(vop_dev->standby));
-	if (win->id == 0)
-		vop_win0_reg_update(dev_drv, win->id);
-	else if (win->id == 1)
-		vop_win1_reg_update(dev_drv, win->id);
-	else if (win->id == 2)
-		vop_hwc_reg_update(dev_drv, win->id);
-	vop_cfg_done(vop_dev);
-
-	DBG(2, "%s for vop%d\n", __func__, vop_dev->id);
-	return 0;
-}
-
-static int vop_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
-			   int *hwc_lut, int mode)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	int len = 256 * sizeof(u32);
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (!dev_drv->hwc_lut)
-		dev_drv->hwc_lut = devm_kzalloc(vop_dev->dev, len, GFP_KERNEL);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_msk_reg(vop_dev, HWC_CTRL0, V_HWC_LUT_EN(0));
-		vop_cfg_done(vop_dev);
-		mdelay(25);
-		for (i = 0; i < 256; i++) {
-			if (mode == 1)
-				dev_drv->hwc_lut[i] = hwc_lut[i];
-
-			v = dev_drv->hwc_lut[i];
-			c = vop_dev->hwc_lut_addr_base + (i << 2);
-			writel_relaxed(v, c);
-		}
-		vop_msk_reg(vop_dev, HWC_CTRL0, V_HWC_LUT_EN(1));
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
-{
-	int i = 0;
-	int __iomem *c;
-	int v;
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (!dsp_lut)
-		return 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_LUT_EN(0));
-		vop_cfg_done(vop_dev);
-		mdelay(25);
-		for (i = 0; i < 256; i++) {
-			v = dsp_lut[i];
-			c = vop_dev->dsp_lut_addr_base + (i << 2);
-			writel_relaxed(v, c);
-		}
-		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_LUT_EN(1));
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
-{
-	int ret = 0, fps = 0;
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (reset_rate)
-		ret = clk_set_rate(vop_dev->dclk, screen->mode.pixclock);
-	if (ret)
-		dev_err(dev_drv->dev, "set lcdc%d dclk[%d] failed\n",
-			vop_dev->id, screen->mode.pixclock);
-	vop_dev->pixclock =
-	    div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
-	vop_dev->driver.pixclock = vop_dev->pixclock;
-
-	fps = rk_fb_calc_fps(screen, vop_dev->pixclock);
-	screen->ft = 1000 / fps;
-	dev_info(vop_dev->dev, "%s: dclk:%lu>>fps:%d ",
-		 vop_dev->driver.name, clk_get_rate(vop_dev->dclk), fps);
-	return 0;
-}
-
-static int vop_config_timing(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 right_margin = screen->mode.right_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u64 val;
-	u16 h_total, v_total;
-	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
-
-	/* config timing reg valid immediately or after frame start */
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) /* after frame start */
-		vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_DSP_TIMING_IMD(1));
-	else /* timing reg valid immediately */
-		vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_DSP_TIMING_IMD(0));
-
-	h_total = hsync_len + left_margin + x_res + right_margin;
-	v_total = vsync_len + upper_margin + y_res + lower_margin;
-
-	val = V_DSP_HS_END(hsync_len) | V_DSP_HTOTAL(h_total);
-	vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
-
-	val = V_DSP_HACT_END(hsync_len + left_margin + x_res) |
-	    V_DSP_HACT_ST(hsync_len + left_margin);
-	vop_msk_reg(vop_dev, DSP_HACT_ST_END, val);
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		/* First Field Timing */
-		val = V_DSP_VS_END(vsync_len) |
-		    V_DSP_VTOTAL(2 * (vsync_len + upper_margin +
-				      lower_margin) + y_res + 1);
-		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
-
-		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
-		    V_DSP_VACT_ST(vsync_len + upper_margin);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
-
-		/* Second Field Timing */
-		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
-		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
-		    lower_margin;
-		val = V_DSP_VS_ST_F1(vs_st_f1) | V_DSP_VS_END_F1(vs_end_f1);
-		vop_msk_reg(vop_dev, DSP_VS_ST_END_F1, val);
-
-		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
-		    lower_margin + 1;
-		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
-		    lower_margin + 1;
-		val = V_DSP_VACT_END_F1(vact_end_f1) |
-			V_DSP_VACT_ST_F1(vact_st_f1);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END_F1, val);
-
-		val = V_DSP_LINE_FLAG0_NUM(lower_margin ?
-					   vact_end_f1 : vact_end_f1 - 1);
-
-		val |= V_DSP_LINE_FLAG1_NUM(lower_margin ?
-					    vact_end_f1 : vact_end_f1 - 1);
-		vop_msk_reg(vop_dev, LINE_FLAG, val);
-	} else {
-		val = V_DSP_VS_END(vsync_len) | V_DSP_VTOTAL(v_total);
-		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
-
-		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res) |
-		    V_DSP_VACT_ST(vsync_len + upper_margin);
-		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
-
-		val = V_DSP_LINE_FLAG0_NUM(vsync_len + upper_margin + y_res) |
-			V_DSP_LINE_FLAG1_NUM(vsync_len + upper_margin + y_res);
-		vop_msk_reg(vop_dev, LINE_FLAG, val);
-	}
-
-	return 0;
-}
-
-static int vop_config_source(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 val = 0;
-
-	switch (screen->type) {
-	case SCREEN_RGB:
-		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON5,
-			       V_RGB_VOP_SEL(dev_drv->id));
-		val = V_RGB_DCLK_EN(1) | V_RGB_DCLK_POL(screen->pin_dclk) |
-			V_RGB_HSYNC_POL(screen->pin_hsync) |
-			V_RGB_VSYNC_POL(screen->pin_vsync) |
-			V_RGB_DEN_POL(screen->pin_den);
-		break;
-	case SCREEN_HDMI:
-		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
-			       V_HDMI_VOP_SEL(dev_drv->id));
-		val = V_HDMI_DCLK_EN(1) | V_HDMI_DCLK_POL(screen->pin_dclk) |
-			V_HDMI_HSYNC_POL(screen->pin_hsync) |
-			V_HDMI_VSYNC_POL(screen->pin_vsync) |
-			V_HDMI_DEN_POL(screen->pin_den);
-		break;
-	case SCREEN_LVDS:
-		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
-			       V_LVDS_VOP_SEL(dev_drv->id));
-		val = V_LVDS_DCLK_EN(1) | V_LVDS_DCLK_POL(screen->pin_dclk) |
-			V_LVDS_HSYNC_POL(screen->pin_hsync) |
-			V_LVDS_VSYNC_POL(screen->pin_vsync) |
-			V_LVDS_DEN_POL(screen->pin_den);
-		break;
-	case SCREEN_MIPI:
-		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
-			       V_DSI0_VOP_SEL(dev_drv->id));
-		val = V_MIPI_DCLK_EN(1) | V_MIPI_DCLK_POL(screen->pin_dclk) |
-			V_MIPI_HSYNC_POL(screen->pin_hsync) |
-			V_MIPI_VSYNC_POL(screen->pin_vsync) |
-			V_MIPI_DEN_POL(screen->pin_den);
-		break;
-	default:
-		dev_err(vop_dev->dev, "un supported interface[%d]!\n",
-			screen->type);
-		break;
-	}
-
-	val |= V_SW_CORE_CLK_SEL(!!screen->pixelrepeat);
-	if (screen->mode.vmode & FB_VMODE_INTERLACED)
-		val |= V_SW_HDMI_CLK_I_SEL(1);
-	else
-		val |= V_SW_HDMI_CLK_I_SEL(0);
-	vop_msk_reg(vop_dev, DSP_CTRL0, val);
-
-	return 0;
-}
-
-static int vop_config_interface(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 val = 0;
-
-	/* FRC dither down init */
-	if (screen->face != OUT_P888) {
-		vop_writel(vop_dev, FRC_LOWER01_0, 0x12844821);
-		vop_writel(vop_dev, FRC_LOWER01_1, 0x21488412);
-		vop_writel(vop_dev, FRC_LOWER10_0, 0xa55a9696);
-		vop_writel(vop_dev, FRC_LOWER10_1, 0x5aa56969);
-		vop_writel(vop_dev, FRC_LOWER11_0, 0xdeb77deb);
-		vop_writel(vop_dev, FRC_LOWER11_1, 0xed7bb7de);
-	}
-
-	switch (screen->face) {
-	case OUT_P888:
-		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(0);
-		break;
-	case OUT_P565:
-		val = V_DSP_OUT_MODE(OUT_P565) | V_DITHER_DOWN(1) |
-			V_DITHER_DOWN_MODE(DITHER_888_565) |
-			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
-		break;
-	case OUT_P666:
-		val = V_DSP_OUT_MODE(OUT_P666) | V_DITHER_DOWN(1) |
-			V_DITHER_DOWN_MODE(DITHER_888_666) |
-			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
-		break;
-	case OUT_D888_P565:
-		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(1) |
-			V_DITHER_DOWN_MODE(DITHER_888_565) |
-			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
-		break;
-	case OUT_D888_P666:
-		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(1) |
-			V_DITHER_DOWN_MODE(DITHER_888_666) |
-			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
-		break;
-	default:
-		dev_err(vop_dev->dev, "un supported screen face[%d]!\n",
-			screen->face);
-		break;
-	}
-
-	if (screen->mode.vmode & FB_VMODE_INTERLACED)
-		val |= V_DSP_INTERLACE(1) | V_INTERLACE_FIELD_POL(0);
-	else
-		val |= V_DSP_INTERLACE(0) | V_INTERLACE_FIELD_POL(0);
-
-	dev_drv->output_color = screen->color_mode;
-	if (screen->color_mode == COLOR_RGB)
-		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
-	else
-		dev_drv->overlay_mode = VOP_YUV_DOMAIN;
-
-	val |= V_SW_OVERLAY_MODE(dev_drv->overlay_mode) |
-		V_DSP_BG_SWAP(screen->swap_gb) |
-		V_DSP_RB_SWAP(screen->swap_rb) |
-		V_DSP_RG_SWAP(screen->swap_rg) |
-		V_DSP_DELTA_SWAP(screen->swap_delta) |
-		V_DSP_DUMMY_SWAP(screen->swap_dumy) |
-		V_DSP_BLANK_EN(0) | V_DSP_BLACK_EN(0);
-	vop_msk_reg(vop_dev, DSP_CTRL2, val);
-
-	return 0;
-}
-
-static void vop_config_background(struct rk_lcdc_driver *dev_drv, int rgb)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u64 val;
-	int b = rgb & 0xff;
-	int g = (rgb >> 8) & 0xff;
-	int r = (rgb >> 16) & 0xff;
-
-	val = V_DSP_BG_BLUE(b) | V_DSP_BG_GREEN(g) | V_DSP_BG_RED(r);
-	vop_msk_reg(vop_dev, DSP_BG, val);
-}
-
-static void vop_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
-			vop_msk_reg(vop_dev, BCSH_CTRL,
-				    V_SW_BCSH_Y2R_EN(0) | V_SW_BCSH_R2Y_EN(0));
-		else		/* YUV2RGB */
-			vop_msk_reg(vop_dev, BCSH_CTRL, V_SW_BCSH_Y2R_EN(1) |
-				    V_SW_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				    V_SW_BCSH_R2Y_EN(0));
-	} else {
-		/* overlay_mode=VOP_RGB_DOMAIN */
-		/* bypass  --need check,if bcsh close? */
-		if (dev_drv->output_color == COLOR_RGB) {
-			if (dev_drv->bcsh.enable == 1)
-				vop_msk_reg(vop_dev, BCSH_CTRL,
-					    V_SW_BCSH_R2Y_EN(1) |
-					    V_SW_BCSH_Y2R_EN(1));
-			else
-				vop_msk_reg(vop_dev, BCSH_CTRL,
-					    V_SW_BCSH_R2Y_EN(0) |
-					    V_SW_BCSH_Y2R_EN(0));
-		} else {
-			/* RGB2YUV */
-			vop_msk_reg(vop_dev, BCSH_CTRL,
-				    V_SW_BCSH_R2Y_EN(1) |
-				    V_SW_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
-				    V_SW_BCSH_Y2R_EN(0));
-		}
-	}
-}
-
-static int vop_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
-			       u16 *yact, int *format, u32 *dsp_addr,
-			       int *ymirror)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u32 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		val = vop_readl(vop_dev, WIN0_ACT_INFO);
-		*xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
-		*yact = ((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-
-		val = vop_readl(vop_dev, WIN0_CTRL0);
-		*format = (val & MASK(WIN0_DATA_FMT)) >> 1;
-		*dsp_addr = vop_readl(vop_dev, WIN0_YRGB_MST);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			   int format, u16 xact, u16 yact, u16 xvir,
-			   int ymirror)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int swap = (format == RGB888) ? 1 : 0;
-	u64 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		val = V_WIN0_DATA_FMT(format) | V_WIN0_RB_SWAP(swap);
-		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
-
-		vop_msk_reg(vop_dev, WIN0_VIR, V_WIN0_YRGB_VIR_STRIDE(xvir));
-		vop_writel(vop_dev, WIN0_ACT_INFO, V_WIN0_ACT_WIDTH(xact - 1) |
-			   V_WIN0_ACT_HEIGHT(yact - 1));
-
-		vop_writel(vop_dev, WIN0_YRGB_MST, rgb_mst);
-
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static void vop_reg_restore(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int len = FLAG_REG;
-
-	spin_lock(&vop_dev->reg_lock);
-
-	if (likely(vop_dev->clk_on))
-		memcpy(vop_dev->regs, vop_dev->regsbak, len);
-
-	spin_unlock(&vop_dev->reg_lock);
-
-	/* set screen GAMMA lut */
-	if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
-		vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
-
-	/* set hwc lut */
-	vop_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
-}
-
-static int vop_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	/*if (!vop_dev->standby && initscreen && (dev_drv->first_frame != 1))*/
-	/*	flush_kthread_worker(&dev_drv->update_regs_worker);*/
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_config_interface(dev_drv);
-		vop_config_source(dev_drv);
-		vop_config_timing(dev_drv);
-		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN)
-			vop_config_background(dev_drv, 0x801080);
-		else
-			vop_config_background(dev_drv, 0x000000);
-
-		vop_bcsh_path_sel(dev_drv);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	vop_set_dclk(dev_drv, 1);
-	if (screen->init)
-		screen->init();
-
-	return 0;
-}
-
-/*
- * enable or disable layer according to win id
- * @open: 1 enable; 0 disable
- */
-static void vop_layer_enable(struct vop_device *vop_dev,
-			     unsigned int win_id, bool open)
-{
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on) &&
-	    vop_dev->driver.win[win_id]->state != open) {
-		if (open) {
-			if (!vop_dev->atv_layer_cnt) {
-				dev_info(vop_dev->dev,
-					 "wakeup from standby!\n");
-				vop_dev->standby = 0;
-			}
-			vop_dev->atv_layer_cnt |= (1 << win_id);
-		} else {
-			if (vop_dev->atv_layer_cnt & (1 << win_id))
-				vop_dev->atv_layer_cnt &= ~(1 << win_id);
-		}
-		vop_dev->driver.win[win_id]->state = open;
-		if (!open) {
-			vop_layer_update_regs(vop_dev,
-					      vop_dev->driver.win[win_id]);
-			vop_cfg_done(vop_dev);
-		}
-		/* if no layer used,disable lcdc */
-		if (!vop_dev->atv_layer_cnt) {
-			dev_info(vop_dev->dev,
-				 "no layer is used,go to standby!\n");
-			vop_dev->standby = 1;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-}
-
-static int vop_open(struct rk_lcdc_driver *dev_drv, int win_id,
-		    bool open)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	/* enable clk,when first layer open */
-	if ((open) && (!vop_dev->atv_layer_cnt)) {
-		/* rockchip_set_system_status(sys_status); */
-		vop_pre_init(dev_drv);
-		vop_clk_enable(vop_dev);
-		vop_irq_enable(vop_dev);
-
-		if (support_uboot_display() && (vop_dev->prop == PRMRY)) {
-			vop_set_dclk(dev_drv, 0);
-		} else {
-			vop_load_screen(dev_drv, 1);
-			if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-				dev_drv->trsm_ops->enable();
-		}
-		if (dev_drv->bcsh.enable)
-			vop_set_bcsh(dev_drv, 1);
-
-		/* set screen GAMMA lut */
-		if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
-			vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
-	}
-
-	if (win_id < ARRAY_SIZE(vop_win))
-		vop_layer_enable(vop_dev, win_id, open);
-	else
-		dev_err(vop_dev->dev, "invalid win id:%d\n", win_id);
-
-	dev_drv->first_frame = 0;
-	return 0;
-}
-
-static int vop_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	if (win_id >= dev_drv->lcdc_win_num) {
-		dev_err(dev_drv->dev, "invalid win id:%d!\n", win_id);
-		return -EINVAL;
-	}
-
-	win = dev_drv->win[win_id];
-	win->area[0].y_addr = win->area[0].smem_start + win->area[0].y_offset;
-	/* only win0 support yuv format */
-	if (win_id == 0)
-		win->area[0].uv_addr =
-			win->area[0].cbr_start + win->area[0].c_offset;
-	else
-		win->area[0].uv_addr = 0;
-
-	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
-	    vop_dev->id, win->id, win->area[0].y_addr, win->area[0].uv_addr);
-	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
-	    win->area[0].y_offset, win->area[0].c_offset);
-	return 0;
-}
-
-static int win_0_1_set_par(struct vop_device *vop_dev,
-			   struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	char fmt[9] = "NULL";
-
-	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
-				screen->mode.hsync_len;
-	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
-		win->area[0].ysize /= 2;
-		win->area[0].dsp_sty = win->area[0].ypos / 2 +
-			screen->mode.upper_margin + screen->mode.vsync_len;
-	} else {
-		win->area[0].dsp_sty = win->area[0].ypos +
-			screen->mode.upper_margin + screen->mode.vsync_len;
-	}
-
-	win->scale_yrgb_x = CALSCALE(win->area[0].xact, win->area[0].xsize);
-	win->scale_yrgb_y = CALSCALE(win->area[0].yact, win->area[0].ysize);
-
-	switch (win->area[0].format) {
-	case ARGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 0;
-		break;
-	case XBGR888:
-	case ABGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 1;
-		break;
-	case RGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
-		win->area[0].swap_rb = 0;
-		break;
-	case RGB565:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
-		win->area[0].swap_rb = 0;
-		break;
-	case XRGB888:
-		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
-		win->area[0].swap_rb = 0;
-		break;
-	case BGR888:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
-		win->area[0].swap_rb = 1;
-		break;
-	case BGR565:
-		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
-		win->area[0].swap_rb = 1;
-		break;
-	case YUV422:
-		if (win->id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 0;
-			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
-						     win->area[0].xsize);
-			win->scale_cbcr_y = CALSCALE(win->area[0].yact,
-						     win->area[0].ysize);
-		} else {
-			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
-				__func__, win->id);
-		}
-		break;
-	case YUV420:
-		if (win->id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 0;
-			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
-						     win->area[0].xsize);
-			win->scale_cbcr_y = CALSCALE(win->area[0].yact / 2,
-						     win->area[0].ysize);
-		} else {
-			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
-				__func__, win->id);
-		}
-
-		break;
-	case YUV420_NV21:
-		if (win->id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 1;
-			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
-						     win->area[0].xsize);
-			win->scale_cbcr_y = CALSCALE(win->area[0].yact / 2,
-						     win->area[0].ysize);
-		} else {
-			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
-				__func__, win->id);
-		}
-		break;
-	case YUV444:
-		if (win->id == 0) {
-			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
-			win->area[0].swap_rb = 0;
-			win->area[0].swap_uv = 0;
-			win->scale_cbcr_x =
-				CALSCALE(win->area[0].xact, win->area[0].xsize);
-			win->scale_cbcr_y =
-				CALSCALE(win->area[0].yact, win->area[0].ysize);
-		} else {
-			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
-				__func__, win->id);
-		}
-		break;
-	default:
-		dev_err(vop_dev->dev, "%s:unsupport format[%d]!\n",
-			__func__, win->area[0].format);
-		break;
-	}
-
-	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
-	    vop_dev->id, win->id, get_format_string(win->area[0].format, fmt),
-	    win->area[0].xact, win->area[0].yact, win->area[0].xsize);
-	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-	    win->area[0].ysize, win->area[0].xvir, win->area[0].yvir,
-	    win->area[0].xpos, win->area[0].ypos);
-
-	return 0;
-}
-
-static int hwc_set_par(struct vop_device *vop_dev,
-		       struct rk_screen *screen, struct rk_lcdc_win *win)
-{
-	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
-				screen->mode.hsync_len;
-	win->area[0].dsp_sty = win->area[0].ypos + screen->mode.upper_margin +
-				screen->mode.vsync_len;
-
-	DBG(1, "lcdc[%d]:hwc>>%s\n>>xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d",
-	    vop_dev->id, __func__, win->area[0].xsize, win->area[0].ysize,
-	    win->area[0].xpos, win->area[0].ypos);
-	return 0;
-}
-
-static int vop_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "screen is null!\n");
-		return -ENOENT;
-	}
-
-	switch (win_id) {
-	case 0:
-		win_0_1_set_par(vop_dev, screen, dev_drv->win[0]);
-		break;
-	case 1:
-		win_0_1_set_par(vop_dev, screen, dev_drv->win[1]);
-		break;
-	case 2:
-		hwc_set_par(vop_dev, screen, dev_drv->win[2]);
-		break;
-	default:
-		dev_err(dev_drv->dev, "%s: unsupported win id:%d\n",
-			__func__, win_id);
-		break;
-	}
-	return 0;
-}
-
-static int vop_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-		     unsigned long arg, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	struct color_key_cfg clr_key_cfg;
-
-	switch (cmd) {
-	case RK_FBIOGET_PANEL_SIZE:
-		panel_size[0] = vop_dev->screen->mode.xres;
-		panel_size[1] = vop_dev->screen->mode.yres;
-		if (copy_to_user(argp, panel_size, 8))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_COLOR_KEY_CFG:
-		if (copy_from_user(&clr_key_cfg, argp,
-				   sizeof(struct color_key_cfg)))
-			return -EFAULT;
-		vop_clr_key_cfg(dev_drv);
-		vop_writel(vop_dev, WIN0_COLOR_KEY,
-			   clr_key_cfg.win0_color_key_cfg);
-		vop_writel(vop_dev, WIN1_COLOR_KEY,
-			   clr_key_cfg.win1_color_key_cfg);
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static int vop_get_backlight_device(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct device_node *backlight;
-	struct property *prop;
-	u32 *brightness_levels;
-	u32 length, max, last;
-
-	if (vop_dev->backlight)
-		return 0;
-	backlight = of_parse_phandle(vop_dev->dev->of_node, "backlight", 0);
-	if (backlight) {
-		vop_dev->backlight = of_find_backlight_by_node(backlight);
-		if (!vop_dev->backlight)
-			dev_info(vop_dev->dev, "No find backlight device\n");
-	} else {
-		dev_info(vop_dev->dev, "No find backlight device node\n");
-	}
-	prop = of_find_property(backlight, "brightness-levels", &length);
-	if (!prop)
-		return -EINVAL;
-	max = length / sizeof(u32);
-	last = max - 1;
-	brightness_levels = kmalloc(256, GFP_KERNEL);
-	if (brightness_levels)
-		return -ENOMEM;
-
-	if (!of_property_read_u32_array(backlight, "brightness-levels",
-					brightness_levels, max)) {
-		if (brightness_levels[0] > brightness_levels[last])
-			dev_drv->cabc_pwm_pol = 1;/*negative*/
-		else
-			dev_drv->cabc_pwm_pol = 0;/*positive*/
-	} else {
-		dev_info(vop_dev->dev,
-			 "Can not read brightness-levels value\n");
-	}
-
-	kfree(brightness_levels);
-
-	return 0;
-}
-
-static int vop_backlight_close(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (dev_drv->suspend_flag)
-		return 0;
-
-	vop_get_backlight_device(dev_drv);
-
-	if (enable) {
-		/* close the backlight */
-		if (vop_dev->backlight) {
-			vop_dev->backlight->props.power = FB_BLANK_POWERDOWN;
-			backlight_update_status(vop_dev->backlight);
-		}
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-			dev_drv->trsm_ops->disable();
-	} else {
-		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-			dev_drv->trsm_ops->enable();
-		msleep(100);
-		/* open the backlight */
-		if (vop_dev->backlight) {
-			vop_dev->backlight->props.power = FB_BLANK_UNBLANK;
-			backlight_update_status(vop_dev->backlight);
-		}
-	}
-
-	return 0;
-}
-
-static int vop_early_suspend(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (dev_drv->suspend_flag)
-		return 0;
-
-	dev_drv->suspend_flag = 1;
-	smp_wmb();
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-
-	vop_standby_enable(vop_dev);
-	vop_mmu_disable(dev_drv);
-	vop_clk_disable(vop_dev);
-	rk_disp_pwr_disable(dev_drv);
-
-	return 0;
-}
-
-static int vop_early_resume(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (!dev_drv->suspend_flag)
-		return 0;
-
-	rk_disp_pwr_enable(dev_drv);
-	vop_clk_enable(vop_dev);
-	vop_reg_restore(dev_drv);
-	vop_standby_disable(vop_dev);
-	vop_mmu_enable(dev_drv);
-	dev_drv->suspend_flag = 0;
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
-		dev_drv->trsm_ops->enable();
-
-	return 0;
-}
-
-static int vop_blank(struct rk_lcdc_driver *dev_drv, int win_id, int blank_mode)
-{
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK:
-		vop_early_resume(dev_drv);
-		break;
-	case FB_BLANK_NORMAL:
-		vop_early_suspend(dev_drv);
-		break;
-	default:
-		vop_early_suspend(dev_drv);
-		break;
-	}
-
-	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
-
-	return 0;
-}
-
-static int vop_get_win_state(struct rk_lcdc_driver *dev_drv,
-			     int win_id, int area_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u32 area_status = 0, state = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		switch (win_id) {
-		case 0:
-			area_status =
-				vop_read_bit(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
-			break;
-		case 1:
-			area_status =
-				vop_read_bit(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
-			break;
-		case 2:
-			area_status =
-				vop_read_bit(vop_dev, HWC_CTRL0, V_HWC_EN(0));
-			break;
-		default:
-			pr_err("%s: win[%d]area[%d],unsupport!!!\n",
-			       __func__, win_id, area_id);
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	state = (area_status > 0) ? 1 : 0;
-	return state;
-}
-
-static int vop_get_area_num(struct rk_lcdc_driver *dev_drv,
-			    unsigned int *area_support)
-{
-	area_support[0] = 1;
-	area_support[1] = 1;
-
-	return 0;
-}
-
-static int vop_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap, bool set)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int ovl;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		if (set) {
-			vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(swap));
-			ovl = swap;
-		} else {
-			ovl =
-			    vop_read_bit(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(0));
-		}
-	} else {
-		ovl = -EPERM;
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return ovl;
-}
-
-static char *vop_format_to_string(int format, char *fmt)
-{
-	if (!fmt)
-		return NULL;
-
-	switch (format) {
-	case 0:
-		strcpy(fmt, "ARGB888");
-		break;
-	case 1:
-		strcpy(fmt, "RGB888");
-		break;
-	case 2:
-		strcpy(fmt, "RGB565");
-		break;
-	case 4:
-		strcpy(fmt, "YCbCr420");
-		break;
-	case 5:
-		strcpy(fmt, "YCbCr422");
-		break;
-	case 6:
-		strcpy(fmt, "YCbCr444");
-		break;
-	default:
-		strcpy(fmt, "invalid\n");
-		break;
-	}
-	return fmt;
-}
-
-static ssize_t vop_get_disp_info(struct rk_lcdc_driver *dev_drv,
-				 char *buf, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u32 h_pw_bp = hsync_len + left_margin;
-	u32 v_pw_bp = vsync_len + upper_margin;
-	u32 fmt_id;
-	char format_w0[9] = "NULL";
-	char format_w1[9] = "NULL";
-	char dsp_buf[100];
-	u32 win_ctrl, ovl, vir_info, act_info, dsp_info, dsp_st;
-	u32 y_factor, uv_factor;
-	u8 w0_state, w1_state;
-
-	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
-	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
-	u32 w1_vir_y, w1_dsp_x, w1_dsp_y;
-	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
-	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
-
-	u32 dclk_freq;
-	int size = 0;
-
-	dclk_freq = screen->mode.pixclock;
-	/*vop_reg_dump(dev_drv); */
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		ovl = vop_read_bit(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(0));
-		/* WIN0 */
-		win_ctrl = vop_readl(vop_dev, WIN0_CTRL0);
-		w0_state = win_ctrl & MASK(WIN0_EN);
-		fmt_id = (win_ctrl & MASK(WIN0_DATA_FMT)) >> 1;
-		vop_format_to_string(fmt_id, format_w0);
-		vir_info = vop_readl(vop_dev, WIN0_VIR);
-		act_info = vop_readl(vop_dev, WIN0_ACT_INFO);
-		dsp_info = vop_readl(vop_dev, WIN0_DSP_INFO);
-		dsp_st = vop_readl(vop_dev, WIN0_DSP_ST);
-		y_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_YRGB);
-		uv_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_CBR);
-		w0_vir_y = vir_info & MASK(WIN0_YRGB_VIR_STRIDE);
-		w0_vir_uv = (vir_info & MASK(WIN0_CBR_VIR_STRIDE)) >> 16;
-		w0_act_x = (act_info & MASK(WIN0_ACT_WIDTH)) + 1;
-		w0_act_y = ((act_info & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
-		w0_dsp_x = (dsp_info & MASK(WIN0_DSP_WIDTH)) + 1;
-		w0_dsp_y = ((dsp_info & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
-		if (w0_state) {
-			w0_st_x = dsp_st & MASK(WIN0_DSP_XST);
-			w0_st_y = (dsp_st & MASK(WIN0_DSP_YST)) >> 16;
-		}
-		w0_y_h_fac = y_factor & MASK(WIN0_HS_FACTOR_YRGB);
-		w0_y_v_fac = (y_factor & MASK(WIN0_VS_FACTOR_YRGB)) >> 16;
-		w0_uv_h_fac = uv_factor & MASK(WIN0_HS_FACTOR_CBR);
-		w0_uv_v_fac = (uv_factor & MASK(WIN0_VS_FACTOR_CBR)) >> 16;
-
-		/* WIN1 */
-		win_ctrl = vop_readl(vop_dev, WIN1_CTRL0);
-		w1_state = win_ctrl & MASK(WIN1_EN);
-		fmt_id = (win_ctrl & MASK(WIN1_DATA_FMT)) >> 1;
-		vop_format_to_string(fmt_id, format_w1);
-		vir_info = vop_readl(vop_dev, WIN1_VIR);
-		dsp_info = vop_readl(vop_dev, WIN1_DSP_INFO);
-		dsp_st = vop_readl(vop_dev, WIN1_DSP_ST);
-		w1_vir_y = vir_info & MASK(WIN1_VIR_STRIDE);
-		w1_dsp_x = (dsp_info & MASK(WIN1_DSP_WIDTH)) + 1;
-		w1_dsp_y = ((dsp_info & MASK(WIN1_DSP_HEIGHT)) >> 16) + 1;
-		if (w1_state) {
-			w1_st_x = dsp_st & MASK(WIN1_DSP_XST);
-			w1_st_y = (dsp_st & MASK(WIN1_DSP_YST)) >> 16;
-		}
-	} else {
-		spin_unlock(&vop_dev->reg_lock);
-		return -EPERM;
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	/* win0 */
-	size += snprintf(dsp_buf, 80,
-		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
-		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
-		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
-		 w0_st_x - h_pw_bp, w0_st_y - v_pw_bp, w0_y_h_fac, w0_y_v_fac);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
-		 w0_uv_h_fac, w0_uv_v_fac, vop_readl(vop_dev, WIN0_YRGB_MST),
-		 vop_readl(vop_dev, WIN0_CBR_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/* win1 */
-	size += snprintf(dsp_buf, 80,
-		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d,",
-		 w1_state, format_w1, w1_vir_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 " dsp_x   :%5d, dsp_y   :%5d\n",
-		 w1_dsp_x, w1_dsp_y);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "  x_st :%4d, y_st  :%4d, ",
-		 w1_st_x - h_pw_bp, w1_st_y - v_pw_bp);
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	size += snprintf(dsp_buf, 80,
-		 "y_addr:0x%08x\n",
-		 vop_readl(vop_dev, WIN1_YRGB_MST));
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	/* zorder */
-	size += snprintf(dsp_buf, 80,
-			 ovl ? "win0 on the top of win1\n" :
-				"win1 on the top of win0\n");
-	strcat(buf, dsp_buf);
-	memset(dsp_buf, 0, sizeof(dsp_buf));
-
-	return size;
-}
-
-static int vop_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps, bool set)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-	u32 pixclock;
-	u32 x_total, y_total;
-
-	if (set) {
-		if (fps == 0) {
-			dev_info(dev_drv->dev, "unsupport set fps=0\n");
-			return 0;
-		}
-		ft = div_u64(1000000000000llu, fps);
-		x_total =
-		    screen->mode.upper_margin + screen->mode.lower_margin +
-		    screen->mode.yres + screen->mode.vsync_len;
-		y_total =
-		    screen->mode.left_margin + screen->mode.right_margin +
-		    screen->mode.xres + screen->mode.hsync_len;
-		dev_drv->pixclock = div_u64(ft, x_total * y_total);
-		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
-		ret = clk_set_rate(vop_dev->dclk, dotclk);
-	}
-
-	pixclock = div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
-	vop_dev->pixclock = pixclock;
-	dev_drv->pixclock = vop_dev->pixclock;
-	fps = rk_fb_calc_fps(screen, pixclock);
-	screen->ft = 1000 / fps;	/*one frame time in ms */
-
-	if (set)
-		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
-			 clk_get_rate(vop_dev->dclk), fps);
-
-	return fps;
-}
-
-static int vop_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
-{
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (order == FB_DEFAULT_ORDER)
-		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
-	dev_drv->fb4_win_id = order / 10000;
-	dev_drv->fb3_win_id = (order / 1000) % 10;
-	dev_drv->fb2_win_id = (order / 100) % 10;
-	dev_drv->fb1_win_id = (order / 10) % 10;
-	dev_drv->fb0_win_id = order % 10;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return 0;
-}
-
-static int vop_get_win_id(struct rk_lcdc_driver *dev_drv, const char *id)
-{
-	int win_id = 0;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
-		win_id = dev_drv->fb0_win_id;
-	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
-		win_id = dev_drv->fb1_win_id;
-	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
-		win_id = dev_drv->fb2_win_id;
-	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
-		win_id = dev_drv->fb3_win_id;
-	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
-		win_id = dev_drv->fb4_win_id;
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return win_id;
-}
-
-static int vop_config_done(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int i;
-	struct rk_lcdc_win *win = NULL;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			win = dev_drv->win[i];
-			vop_layer_update_regs(vop_dev, win);
-		}
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_msk_reg(vop_dev, SYS_CTRL0, V_DIRECT_PATH_EN(open));
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		vop_msk_reg(vop_dev, SYS_CTRL0,
-			    V_DIRECT_PATH_LAYER_SEL(win_id));
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-static int vop_dpi_status(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	int status = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-
-	if (likely(vop_dev->clk_on))
-		status = vop_read_bit(vop_dev, SYS_CTRL0, V_DIRECT_PATH_EN(0));
-
-	spin_unlock(&vop_dev->reg_lock);
-
-	return status;
-}
-
-static int vop_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (enable)
-		enable_irq(vop_dev->irq);
-	else
-		disable_irq(vop_dev->irq);
-	return 0;
-}
-
-static int vop_poll_vblank(struct rk_lcdc_driver *dev_drv)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u32 int_reg;
-	int ret;
-
-	if (vop_dev->clk_on && (!dev_drv->suspend_flag)) {
-		int_reg = vop_readl(vop_dev, INTR_STATUS);
-		if (int_reg & INTR_LINE_FLAG0) {
-			vop_dev->driver.frame_time.last_framedone_t =
-			    vop_dev->driver.frame_time.framedone_t;
-			vop_dev->driver.frame_time.framedone_t = cpu_clock(0);
-			vop_mask_writel(vop_dev, INTR_CLEAR, INTR_LINE_FLAG0,
-					INTR_LINE_FLAG0);
-			ret = RK_LF_STATUS_FC;
-		} else {
-			ret = RK_LF_STATUS_FR;
-		}
-	} else {
-		ret = RK_LF_STATUS_NC;
-	}
-
-	return ret;
-}
-
-static int vop_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
-			    unsigned int dsp_addr[][4])
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		dsp_addr[0][0] = vop_readl(vop_dev, WIN0_YRGB_MST);
-		dsp_addr[1][0] = vop_readl(vop_dev, WIN1_YRGB_MST);
-		dsp_addr[2][0] = vop_readl(vop_dev, HWC_MST);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	return 0;
-}
-
-/*
- * a:[-30~0]:
- *	sin_hue = sin(a)*256 +0x100;
- *	cos_hue = cos(a)*256;
- * a:[0~30]
- *	sin_hue = sin(a)*256;
- *	cos_hue = cos(a)*256;
- */
-static int vop_get_bcsh_hue(struct rk_lcdc_driver *dev_drv, bcsh_hue_mode mode)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u32 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		val = vop_readl(vop_dev, BCSH_H);
-		switch (mode) {
-		case H_SIN:
-			val &= MASK(SIN_HUE);
-			val <<= 1;
-			break;
-		case H_COS:
-			val &= MASK(COS_HUE);
-			val >>= 8;
-			val <<= 1;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return val;
-}
-
-static int vop_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
-			    int sin_hue, int cos_hue)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u64 val;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		/*
-		 * config range is [0, 510), typical value is 256
-		 * register range is [0, 255], cos_hue typical value is 128
-		 * sin_hue typical value is 0
-		 */
-		val = V_SIN_HUE(sin_hue >> 1) | V_COS_HUE(cos_hue >> 1);
-		vop_msk_reg(vop_dev, BCSH_H, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
-			    bcsh_bcs_mode mode, int value)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u64 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		switch (mode) {
-		case BRIGHTNESS:
-			/*
-			 * user range is [0, 255], typical value is 128
-			 * register range is [-32, 31], typical value is 0
-			 */
-			value >>= 2; /* 0-->32-->63 for user, typical is 32 */
-			if (value < 0x20)
-				value += 0x20;
-			else if (value >= 0x20)
-				value = value - 0x20;
-			val = V_BRIGHTNESS(value);
-			break;
-		case CONTRAST:
-			/*
-			 * config range is [0, 510), typical value is 256
-			 * register range is [0, 255], typical value is 128
-			 */
-			value >>= 1;
-			val = V_CONTRAST(value);
-			break;
-		case SAT_CON:
-			/*
-			 * config range is [0, 1015], typical value is 512
-			 * register range is [0, 255], typical value is 128
-			 */
-			value >>= 2;
-			val = V_SAT_CON(value);
-			break;
-		default:
-			break;
-		}
-		vop_msk_reg(vop_dev, BCSH_BCS, val);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return val;
-}
-
-static int vop_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv, bcsh_bcs_mode mode)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-	u64 val = 0;
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		val = vop_readl(vop_dev, BCSH_BCS);
-		switch (mode) {
-		case BRIGHTNESS:
-			val &= MASK(BRIGHTNESS);
-			if (val >= 0x20)
-				val -= 0x20;
-			else
-				val += 0x20;
-			val <<= 2;
-			break;
-		case CONTRAST:
-			val &= MASK(CONTRAST);
-			val >>= 8;
-			val <<= 1;
-			break;
-		case SAT_CON:
-			val &= MASK(SAT_CON);
-			val >>= 16;
-			val <<= 2;
-			break;
-		default:
-			break;
-		}
-	}
-	spin_unlock(&vop_dev->reg_lock);
-	return val;
-}
-
-static int vop_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	spin_lock(&vop_dev->reg_lock);
-	if (likely(vop_dev->clk_on)) {
-		if (open) {
-			vop_writel(vop_dev, BCSH_BCS,
-				   V_BRIGHTNESS(0x00) | V_CONTRAST(0x80) |
-				   V_SAT_CON(0x80));
-			vop_writel(vop_dev, BCSH_H,
-				   V_SIN_HUE(0x00) | V_COS_HUE(0x80));
-			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_EN(1) |
-				    V_VIDEO_MODE(BCSH_MODE_VIDEO));
-			dev_drv->bcsh.enable = 1;
-		} else {
-			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_EN(0));
-			dev_drv->bcsh.enable = 0;
-		}
-		vop_bcsh_path_sel(dev_drv);
-		vop_cfg_done(vop_dev);
-	}
-	spin_unlock(&vop_dev->reg_lock);
-
-	return 0;
-}
-
-static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
-{
-	if (!enable || !dev_drv->bcsh.enable) {
-		vop_open_bcsh(dev_drv, false);
-		return 0;
-	}
-
-	if (dev_drv->bcsh.brightness <= 255 ||
-	    dev_drv->bcsh.contrast < 510 ||
-	    dev_drv->bcsh.sat_con <= 1015 ||
-	    (dev_drv->bcsh.sin_hue < 510 && dev_drv->bcsh.cos_hue < 510)) {
-		vop_open_bcsh(dev_drv, true);
-		if (dev_drv->bcsh.brightness <= 255)
-			vop_set_bcsh_bcs(dev_drv, BRIGHTNESS,
-					 dev_drv->bcsh.brightness);
-		if (dev_drv->bcsh.contrast < 510)
-			vop_set_bcsh_bcs(dev_drv, CONTRAST,
-					 dev_drv->bcsh.contrast);
-		if (dev_drv->bcsh.sat_con <= 1015)
-			vop_set_bcsh_bcs(dev_drv, SAT_CON,
-					 dev_drv->bcsh.sat_con);
-		if (dev_drv->bcsh.sin_hue < 510 &&
-		    dev_drv->bcsh.cos_hue < 510)
-			vop_set_bcsh_hue(dev_drv, dev_drv->bcsh.sin_hue,
-					 dev_drv->bcsh.cos_hue);
-	}
-
-	return 0;
-}
-
-static int __maybe_unused
-vop_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
-{
-	struct vop_device *vop_dev = to_vop_dev(dev_drv);
-
-	if (enable) {
-		spin_lock(&vop_dev->reg_lock);
-		if (likely(vop_dev->clk_on)) {
-			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(1));
-			vop_cfg_done(vop_dev);
-		}
-		spin_unlock(&vop_dev->reg_lock);
-	} else {
-		spin_lock(&vop_dev->reg_lock);
-		if (likely(vop_dev->clk_on)) {
-			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(0));
-			vop_cfg_done(vop_dev);
-		}
-		spin_unlock(&vop_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static struct rk_lcdc_drv_ops lcdc_drv_ops = {
-	.open = vop_open,
-	.win_direct_en = vop_win_direct_en,
-	.load_screen = vop_load_screen,
-	.get_dspbuf_info = vop_get_dspbuf_info,
-	.post_dspbuf = vop_post_dspbuf,
-	.set_par = vop_set_par,
-	.pan_display = vop_pan_display,
-	.direct_set_addr = vop_direct_set_win_addr,
-	.blank = vop_blank,
-	.ioctl = vop_ioctl,
-	.suspend = vop_early_suspend,
-	.resume = vop_early_resume,
-	.get_win_state = vop_get_win_state,
-	.area_support_num = vop_get_area_num,
-	.ovl_mgr = vop_ovl_mgr,
-	.get_disp_info = vop_get_disp_info,
-	.fps_mgr = vop_fps_mgr,
-	.fb_get_win_id = vop_get_win_id,
-	.fb_win_remap = vop_fb_win_remap,
-	.poll_vblank = vop_poll_vblank,
-	.dpi_open = vop_dpi_open,
-	.dpi_win_sel = vop_dpi_win_sel,
-	.dpi_status = vop_dpi_status,
-	.get_dsp_addr = vop_get_dsp_addr,
-	.set_dsp_bcsh_hue = vop_set_bcsh_hue,
-	.set_dsp_bcsh_bcs = vop_set_bcsh_bcs,
-	.get_dsp_bcsh_hue = vop_get_bcsh_hue,
-	.get_dsp_bcsh_bcs = vop_get_bcsh_bcs,
-	.open_bcsh = vop_open_bcsh,
-	.set_dsp_lut = vop_set_lut,
-	.set_hwc_lut = vop_set_hwc_lut,
-	.dump_reg = vop_reg_dump,
-	.cfg_done = vop_config_done,
-	.set_irq_to_cpu = vop_set_irq_to_cpu,
-	/*.dsp_black = vop_dsp_black,*/
-	.backlight_close = vop_backlight_close,
-	.mmu_en = vop_mmu_enable,
-};
-
-static irqreturn_t vop_isr(int irq, void *dev_id)
-{
-	struct vop_device *vop_dev = (struct vop_device *)dev_id;
-	ktime_t timestamp = ktime_get();
-	u32 intr_status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&vop_dev->irq_lock, flags);
-
-	intr_status = vop_readl(vop_dev, INTR_STATUS);
-	vop_mask_writel(vop_dev, INTR_CLEAR, INTR_MASK, intr_status);
-
-	spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
-
-	intr_status &= 0xffff;	/* ignore raw status at 16~32bit */
-	/* This is expected for vop iommu irqs, since the irq is shared */
-	if (!intr_status)
-		return IRQ_NONE;
-
-	if (intr_status & INTR_FS0) {
-		timestamp = ktime_get();
-		vop_dev->driver.vsync_info.timestamp = timestamp;
-		wake_up_interruptible_all(&vop_dev->driver.vsync_info.wait);
-		complete(&vop_dev->sync.frmst);
-		intr_status &= ~INTR_FS0;
-	}
-
-	/* fs1 interrupt occur only when the address is different */
-	if (intr_status & INTR_FS1)
-		intr_status &= ~INTR_FS1;
-
-	if (intr_status & INTR_ADDR_SAME)
-		intr_status &= ~INTR_ADDR_SAME;
-
-	if (intr_status & INTR_DSP_HOLD_VALID) {
-		complete(&vop_dev->sync.stdbyfin);
-		intr_status &= ~INTR_DSP_HOLD_VALID;
-	}
-
-	if (intr_status & INTR_LINE_FLAG0)
-		intr_status &= ~INTR_LINE_FLAG0;
-
-	if (intr_status & INTR_LINE_FLAG1)
-		intr_status &= ~INTR_LINE_FLAG1;
-
-	if (intr_status & INTR_BUS_ERROR) {
-		intr_status &= ~INTR_BUS_ERROR;
-		dev_warn_ratelimited(vop_dev->dev, "bus error!");
-	}
-
-	if (intr_status & INTR_WIN0_EMPTY) {
-		intr_status &= ~INTR_WIN0_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr win0 empty!");
-	}
-
-	if (intr_status & INTR_WIN1_EMPTY) {
-		intr_status &= ~INTR_WIN1_EMPTY;
-		dev_warn_ratelimited(vop_dev->dev, "intr win1 empty!");
-	}
-
-	if (intr_status & INTR_DMA_FINISH)
-		intr_status &= ~INTR_DMA_FINISH;
-
-	if (intr_status & INTR_MMU_STATUS)
-		intr_status &= ~INTR_MMU_STATUS;
-
-	if (intr_status)
-		dev_err(vop_dev->dev, "Unknown VOP IRQs: %#02x\n", intr_status);
-
-	return IRQ_HANDLED;
-}
-
-#if defined(CONFIG_PM)
-static int vop_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int vop_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-#else
-#define vop_suspend NULL
-#define vop_resume  NULL
-#endif
-
-static int vop_parse_dt(struct vop_device *vop_dev)
-{
-	struct device_node *np = vop_dev->dev->of_node;
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-	int val;
-
-	if (of_property_read_u32(np, "rockchip,prop", &val))
-		vop_dev->prop = PRMRY;	/*default set it as primary */
-	else
-		vop_dev->prop = val;
-
-	if (of_property_read_u32(np, "rockchip,mirror", &val))
-		dev_drv->rotate_mode = NO_MIRROR;
-	else
-		dev_drv->rotate_mode = val;
-
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-		/*default set it as 3.xv power supply */
-		vop_dev->pwr18 = false;
-	else
-		vop_dev->pwr18 = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
-		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
-	else
-		dev_drv->fb_win_map = val;
-
-	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
-		dev_drv->bcsh.enable = false;
-	else
-		dev_drv->bcsh.enable = (val ? true : false);
-
-	if (of_property_read_u32(np, "rockchip,brightness", &val))
-		dev_drv->bcsh.brightness = 0xffff;
-	else
-		dev_drv->bcsh.brightness = val;
-
-	if (of_property_read_u32(np, "rockchip,contrast", &val))
-		dev_drv->bcsh.contrast = 0xffff;
-	else
-		dev_drv->bcsh.contrast = val;
-
-	if (of_property_read_u32(np, "rockchip,sat-con", &val))
-		dev_drv->bcsh.sat_con = 0xffff;
-	else
-		dev_drv->bcsh.sat_con = val;
-
-	if (of_property_read_u32(np, "rockchip,hue", &val)) {
-		dev_drv->bcsh.sin_hue = 0xffff;
-		dev_drv->bcsh.cos_hue = 0xffff;
-	} else {
-		dev_drv->bcsh.sin_hue = val & 0xff;
-		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
-	}
-
-	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
-		dev_drv->iommu_enabled = 0;
-	else
-		dev_drv->iommu_enabled = val;
-
-	return 0;
-}
-
-static int vop_probe(struct platform_device *pdev)
-{
-	struct vop_device *vop_dev = NULL;
-	struct rk_lcdc_driver *dev_drv;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	struct device_node *np = pdev->dev.of_node;
-	int prop;
-	int ret = 0;
-
-	/*
-	 * if the primary lcdc has not registered ,the extend
-	 * lcdc register later
-	 */
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		if (!is_prmry_rk_lcdc_registered())
-			return -EPROBE_DEFER;
-	}
-
-	vop_dev = devm_kzalloc(dev, sizeof(struct vop_device), GFP_KERNEL);
-	if (!vop_dev)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, vop_dev);
-	vop_dev->dev = dev;
-	vop_parse_dt(vop_dev);
-
-	/* enable power domain */
-	pm_runtime_enable(dev);
-
-	vop_dev->hclk = devm_clk_get(vop_dev->dev, "hclk_lcdc");
-	if (IS_ERR(vop_dev->hclk)) {
-		dev_err(vop_dev->dev, "failed to get hclk source\n");
-		return PTR_ERR(vop_dev->hclk);
-	}
-
-	vop_dev->aclk = devm_clk_get(vop_dev->dev, "aclk_lcdc");
-	if (IS_ERR(vop_dev->aclk)) {
-		dev_err(vop_dev->dev, "failed to get aclk source\n");
-		return PTR_ERR(vop_dev->aclk);
-	}
-	vop_dev->dclk = devm_clk_get(vop_dev->dev, "dclk_lcdc");
-	if (IS_ERR(vop_dev->dclk)) {
-		dev_err(vop_dev->dev, "failed to get dclk source\n");
-		return PTR_ERR(vop_dev->dclk);
-	}
-
-	clk_prepare(vop_dev->hclk);
-	clk_prepare(vop_dev->aclk);
-	clk_prepare(vop_dev->dclk);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	vop_dev->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(vop_dev->regs)) {
-		ret = PTR_ERR(vop_dev->regs);
-		goto err_exit;
-	}
-
-	vop_dev->reg_phy_base = res->start;
-	vop_dev->len = resource_size(res);
-	vop_dev->regsbak = devm_kzalloc(dev, vop_dev->len, GFP_KERNEL);
-	if (!vop_dev->regsbak) {
-		ret = -ENOMEM;
-		goto err_exit;
-	}
-
-	vop_dev->hwc_lut_addr_base = (vop_dev->regs + HWC_LUT_ADDR);
-	vop_dev->dsp_lut_addr_base = (vop_dev->regs + GAMMA_LUT_ADDR);
-	vop_dev->grf_base = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-	if (IS_ERR(vop_dev->grf_base)) {
-		dev_err(vop_dev->dev, "ERROR!! can't find grf reg property\n");
-		vop_dev->grf_base = NULL;
-	}
-
-	vop_dev->id = 1;
-	dev_set_name(vop_dev->dev, "vop%d", vop_dev->id);
-	dev_drv = &vop_dev->driver;
-	dev_drv->dev = dev;
-	dev_drv->prop = prop;
-	dev_drv->id = vop_dev->id;
-	dev_drv->ops = &lcdc_drv_ops;
-	dev_drv->lcdc_win_num = ARRAY_SIZE(vop_win);
-	dev_drv->reserved_fb = 0;
-	spin_lock_init(&vop_dev->reg_lock);
-	spin_lock_init(&vop_dev->irq_lock);
-	init_completion(&vop_dev->sync.stdbyfin);
-	init_completion(&vop_dev->sync.frmst);
-	vop_dev->sync.stdbyfin_to = 50;	/* timeout 50 ms */
-	vop_dev->sync.frmst_to = 50;
-
-	vop_dev->irq = platform_get_irq(pdev, 0);
-	if (vop_dev->irq < 0) {
-		dev_err(dev, "cannot find IRQ for lcdc%d\n", vop_dev->id);
-		ret = vop_dev->irq;
-		goto err_exit;
-	}
-
-	ret = devm_request_irq(dev, vop_dev->irq, vop_isr,
-			       IRQF_SHARED,
-			       dev_name(dev), vop_dev);
-	if (ret) {
-		dev_err(dev, "cannot requeset irq %d - err %d\n",
-			vop_dev->irq, ret);
-		goto err_exit;
-	}
-
-	if (dev_drv->iommu_enabled)
-		strcpy(dev_drv->mmu_dts_name, VOPL_IOMMU_COMPATIBLE_NAME);
-
-	ret = rk_fb_register(dev_drv, vop_win, vop_dev->id);
-	if (ret < 0) {
-		dev_err(dev, "register fb for failed!\n");
-		goto err_exit;
-	}
-	vop_dev->screen = dev_drv->screen0;
-	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
-		 vop_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
-
-	return 0;
-
-err_exit:
-	clk_unprepare(vop_dev->dclk);
-	clk_unprepare(vop_dev->aclk);
-	clk_unprepare(vop_dev->hclk);
-	pm_runtime_disable(dev);
-
-	return ret;
-}
-
-static int vop_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void vop_shutdown(struct platform_device *pdev)
-{
-	struct vop_device *vop_dev = platform_get_drvdata(pdev);
-	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
-
-	dev_drv->suspend_flag = 1;
-	smp_wmb();
-	flush_kthread_worker(&dev_drv->update_regs_worker);
-	kthread_stop(dev_drv->update_regs_thread);
-
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
-		dev_drv->trsm_ops->disable();
-
-	vop_deinit(vop_dev);
-	rk_disp_pwr_disable(dev_drv);
-}
-
-#if defined(CONFIG_OF)
-static const struct of_device_id vop_dt_ids[] = {
-	{.compatible = "rockchip,rk3366-lcdc-lite",},
-	{}
-};
-#endif
-
-static struct platform_driver vop_driver = {
-	.probe = vop_probe,
-	.remove = vop_remove,
-	.driver = {
-		   .name = "rk-vop-lite",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(vop_dt_ids),
-		   },
-	.suspend = vop_suspend,
-	.resume = vop_resume,
-	.shutdown = vop_shutdown,
-};
-
-static int __init vop_module_init(void)
-{
-	return platform_driver_register(&vop_driver);
-}
-
-static void __exit vop_module_exit(void)
-{
-	platform_driver_unregister(&vop_driver);
-}
-
-fs_initcall(vop_module_init);
-module_exit(vop_module_exit);
diff --git a/drivers/video/rockchip/lcdc/rk_vop_lite.h b/drivers/video/rockchip/lcdc/rk_vop_lite.h
deleted file mode 100644
index 4f8c096b2d4e..000000000000
--- a/drivers/video/rockchip/lcdc/rk_vop_lite.h
+++ /dev/null
@@ -1,649 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef RK_VOPLITE_H_
-#define RK_VOPLITE_H_
-
-#include <linux/rk_fb.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/regmap.h>
-#include <linux/mfd/syscon.h>
-
-#define VOP_INPUT_MAX_WIDTH 2048
-
-/*
- * Registers in this file
- * REG_CFG_DONE: Register config done flag
- * VERSION_INFO: Version for vop
- * DSP_BG: Background color
- * MCU_RESERVED: Reversed
- * SYS_CTRL0: System control register0
- * SYS_CTRL1: Axi Bus interface control register
- * SYS_CTRL2: System control register for immediate reg
- * DSP_CTRL0: Display control register0
- * DSP_CTRL2: Display control register2
- * VOP_STATUS: Some vop module status
- * LINE_FLAG: Line flag config register
- * INTR_EN: Interrupt enable register
- * INTR_CLEAR: Interrupt clear register
- * INTR_STATUS: Interrupt raw status and interrupt status
- * WIN0_CTRL0: Win0 ctrl register0
- * WIN0_CTRL1: Win0 ctrl register1
- * WIN0_COLOR_KEY: Win0 color key register
- * WIN0_VIR: Win0 virtual stride
- * WIN0_YRGB_MST: Win0 YRGB memory start address
- * WIN0_CBR_MST: Win0 Cbr memory start address
- * WIN0_ACT_INFO: Win0 active window width/height
- * WIN0_DSP_INFO: Win0 display width/height on panel
- * WIN0_DSP_ST: Win0 display start point on panel
- * WIN0_SCL_FACTOR_YRGB: Win0 YRGB scaling factor
- * WIN0_SCL_FACTOR_CBR: Win0 Cbr scaling factor
- * WIN0_SCL_OFFSET: Win0 scaling start point offset
- * WIN0_ALPHA_CTRL: Win0 Blending control register
- * WIN1_CTRL0: Win1 ctrl register0
- * WIN1_CTRL1: Win1 ctrl register1
- * WIN1_VIR: win1 virtual stride
- * WIN1_YRGB_MST: Win1 frame buffer memory start address
- * WIN1_DSP_INFO: Win1 display width/height on panel
- * WIN1_DSP_ST: Win1 display start point on panel
- * WIN1_COLOR_KEY: Win1 color key register
- * WIN1_ALPHA_CTRL: Win1 Blending control register
- * HWC_CTRL0: Hwc ctrl register0
- * HWC_CTRL1: Hwc ctrl register1
- * HWC_MST: Hwc memory start address
- * HWC_DSP_ST: Hwc display start point on panel
- * HWC_ALPHA_CTRL: Hwc blending control register
- * DSP_HTOTAL_HS_END: Panel scanning horizontal width and hsync pulse end point
- * DSP_HACT_ST_END: Panel active horizontal scanning start point and end point
- * DSP_VTOTAL_VS_END: Panel scanning vertical height and vsync pulse end point
- * DSP_VACT_ST_END: Panel active vertical scanning start point and end point
- * DSP_VS_ST_END_F1: Vertical scanning start point and vsync pulse end point
- *                   of even filed in interlace mode
- * DSP_VACT_ST_END_F1: Vertical scanning active start point and end point of
- *                     even filed in interlace mode
- * BCSH_CTRL: BCSH contrl register
- * BCSH_COLOR_BAR: Color bar config register
- * BCSH_BCS: Brightness contrast saturation*contrast config register
- * BCSH_H: Sin hue and cos hue config register
- * FRC_LOWER01_0: FRC lookup table config register010
- * FRC_LOWER01_1: FRC lookup table config register011
- * FRC_LOWER10_0: FRC lookup table config register100
- * FRC_LOWER10_1: FRC lookup table config register101
- * FRC_LOWER11_0: FRC lookup table config register110
- * FRC_LOWER11_1: FRC lookup table config register111
- * DBG_REG_00:	Current line number of dsp timing
- * BLANKING_VALUE: The value of vsync blanking
- * FLAG_REG_FRM_VALID: Flag reg value after frame valid
- * FLAG_REG: Flag reg value before frame valid
- * HWC_LUT_ADDR: Hwc lut base address
- * GAMMA_LUT_ADDR: GAMMA lut base address
- */
-
-static inline u64 val_mask(int val, u64 msk, int shift)
-{
-	return (msk << (shift + 32)) | ((msk & val) << shift);
-}
-
-#define VAL_MASK(x, width, shift) val_mask(x, (1 << width) - 1, shift)
-
-#define MASK(x) (V_##x(0) >> 32)
-
-#define REG_CFG_DONE			0x00000000
-#define  V_REG_LOAD_GLOBAL_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_REG_LOAD_WIN0_EN(x)			VAL_MASK(x, 1, 1)
-#define  V_REG_LOAD_WIN1_EN(x)			VAL_MASK(x, 1, 2)
-#define  V_REG_LOAD_HWC_EN(x)			VAL_MASK(x, 1, 3)
-#define  V_REG_LOAD_IEP_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_REG_LOAD_SYS_EN(x)			VAL_MASK(x, 1, 5)
-#define VERSION				0x00000004
-#define  V_BUILD(x)				VAL_MASK(x, 16, 0)
-#define  V_MINOR(x)				VAL_MASK(x, 8, 16)
-#define  V_MAJOR(x)				VAL_MASK(x, 8, 24)
-#define DSP_BG				0x00000008
-#define  V_DSP_BG_BLUE(x)			VAL_MASK(x, 8, 0)
-#define  V_DSP_BG_GREEN(x)			VAL_MASK(x, 8, 8)
-#define  V_DSP_BG_RED(x)			VAL_MASK(x, 8, 16)
-#define MCU_RESERVED			0x0000000c
-#define SYS_CTRL0			0x00000010
-#define  V_DIRECT_PATH_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_DIRECT_PATH_LAYER_SEL(x)		VAL_MASK(x, 1, 1)
-#define SYS_CTRL1			0x00000014
-#define  V_SW_NOC_QOS_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_SW_NOC_QOS_VALUE(x)			VAL_MASK(x, 2, 1)
-#define  V_SW_NOC_HURRY_EN(x)			VAL_MASK(x, 1, 4)
-#define  V_SW_NOC_HURRY_VALUE(x)		VAL_MASK(x, 2, 5)
-#define  V_SW_NOC_HURRY_THRESHOLD(x)		VAL_MASK(x, 4, 8)
-#define  V_SW_AXI_MAX_OUTSTAND_EN(x)		VAL_MASK(x, 1, 12)
-#define  V_SW_AXI_MAX_OUTSTAND_NUM(x)		VAL_MASK(x, 5, 16)
-#define SYS_CTRL2			0x00000018
-#define  V_IMD_AUTO_GATING_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_IMD_VOP_STANDBY_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_IMD_VOP_DMA_STOP(x)			VAL_MASK(x, 1, 2)
-#define  V_IMD_DSP_OUT_ZERO(x)			VAL_MASK(x, 1, 3)
-#define  V_IMD_YUV_CLIP(x)			VAL_MASK(x, 1, 4)
-#define  V_IMD_DSP_DATA_OUT_MODE(x)		VAL_MASK(x, 1, 6)
-#define  V_SW_IO_PAD_CLK_SEL(x)			VAL_MASK(x, 1, 7)
-#define  V_IMD_DSP_TIMING_IMD(x)		VAL_MASK(x, 1, 12)
-#define  V_IMD_GLOBAL_REGDONE_EN(x)		VAL_MASK(x, 1, 13)
-#define  V_FS_ADDR_MASK_EN(x)			VAL_MASK(x, 1, 14)
-#define DSP_CTRL0			0x00000020
-#define  V_RGB_DCLK_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_RGB_DCLK_POL(x)			VAL_MASK(x, 1, 1)
-#define  V_RGB_HSYNC_POL(x)			VAL_MASK(x, 1, 2)
-#define  V_RGB_VSYNC_POL(x)			VAL_MASK(x, 1, 3)
-#define  V_RGB_DEN_POL(x)			VAL_MASK(x, 1, 4)
-#define  V_HDMI_DCLK_EN(x)			VAL_MASK(x, 1, 8)
-#define  V_HDMI_DCLK_POL(x)			VAL_MASK(x, 1, 9)
-#define  V_HDMI_HSYNC_POL(x)			VAL_MASK(x, 1, 10)
-#define  V_HDMI_VSYNC_POL(x)			VAL_MASK(x, 1, 11)
-#define  V_HDMI_DEN_POL(x)			VAL_MASK(x, 1, 12)
-#define  V_SW_CORE_CLK_SEL(x)			VAL_MASK(x, 1, 13)
-#define  V_SW_HDMI_CLK_I_SEL(x)			VAL_MASK(x, 1, 14)
-#define  V_LVDS_DCLK_EN(x)			VAL_MASK(x, 1, 16)
-#define  V_LVDS_DCLK_POL(x)			VAL_MASK(x, 1, 17)
-#define  V_LVDS_HSYNC_POL(x)			VAL_MASK(x, 1, 18)
-#define  V_LVDS_VSYNC_POL(x)			VAL_MASK(x, 1, 19)
-#define  V_LVDS_DEN_POL(x)			VAL_MASK(x, 1, 20)
-#define  V_MIPI_DCLK_EN(x)			VAL_MASK(x, 1, 24)
-#define  V_MIPI_DCLK_POL(x)			VAL_MASK(x, 1, 25)
-#define  V_MIPI_HSYNC_POL(x)			VAL_MASK(x, 1, 26)
-#define  V_MIPI_VSYNC_POL(x)			VAL_MASK(x, 1, 27)
-#define  V_MIPI_DEN_POL(x)			VAL_MASK(x, 1, 28)
-#define DSP_CTRL2			0x00000028
-#define  V_DSP_INTERLACE(x)			VAL_MASK(x, 1, 0)
-#define  V_INTERLACE_FIELD_POL(x)		VAL_MASK(x, 1, 1)
-#define  V_DITHER_UP(x)				VAL_MASK(x, 1, 2)
-#define  V_DSP_WIN0_TOP(x)			VAL_MASK(x, 1, 3)
-#define  V_SW_OVERLAY_MODE(x)			VAL_MASK(x, 1, 4)
-#define  V_DSP_LUT_EN(x)			VAL_MASK(x, 1, 5)
-#define  V_DITHER_DOWN_MODE(x)			VAL_MASK(x, 1, 6)
-#define  V_DITHER_DOWN_SEL(x)			VAL_MASK(x, 1, 7)
-#define  V_DITHER_DOWN(x)			VAL_MASK(x, 1, 8)
-#define  V_DSP_BG_SWAP(x)			VAL_MASK(x, 1, 9)
-#define  V_DSP_DELTA_SWAP(x)			VAL_MASK(x, 1, 10)
-#define  V_DSP_RB_SWAP(x)			VAL_MASK(x, 1, 11)
-#define  V_DSP_RG_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_DSP_DUMMY_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_DSP_BLANK_EN(x)			VAL_MASK(x, 1, 14)
-#define  V_DSP_BLACK_EN(x)			VAL_MASK(x, 1, 15)
-#define  V_DSP_OUT_MODE(x)			VAL_MASK(x, 4, 16)
-#define VOP_STATUS			0x0000002c
-#define  V_DSP_BLANKING_EN_ASYNC_AFF2(x)	VAL_MASK(x, 1, 0)
-#define  V_IDLE_MMU_FF1(x)			VAL_MASK(x, 1, 1)
-#define  V_INT_RAW_DMA_FINISH(x)		VAL_MASK(x, 1, 2)
-#define  V_DMA_STOP_VALID(x)			VAL_MASK(x, 1, 4)
-#define LINE_FLAG			0x00000030
-#define  V_DSP_LINE_FLAG0_NUM(x)		VAL_MASK(x, 12, 0)
-#define  V_DSP_LINE_FLAG1_NUM(x)		VAL_MASK(x, 12, 16)
-#define INTR_EN				0x00000034
-#define  V_FS0_INTR_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_FS1_INTR_EN(x)			VAL_MASK(x, 1, 1)
-#define  V_ADDR_SAME_INTR_EN(x)			VAL_MASK(x, 1, 2)
-#define  V_LINE_FLAG0_INTR_EN(x)		VAL_MASK(x, 1, 3)
-#define  V_LINE_FLAG1_INTR_EN(x)		VAL_MASK(x, 1, 4)
-#define  V_BUS_ERROR_INTR_EN(x)			VAL_MASK(x, 1, 5)
-#define  V_WIN0_EMPTY_INTR_EN(x)		VAL_MASK(x, 1, 6)
-#define  V_WIN1_EMPTY_INTR_EN(x)		VAL_MASK(x, 1, 7)
-#define  V_DSP_HOLD_VALID_INTR_EN(x)		VAL_MASK(x, 1, 8)
-#define  V_DMA_FRM_FSH_INTR_EN(x)		VAL_MASK(x, 1, 9)
-#define INTR_CLEAR			0x00000038
-#define  V_FS0_INTR_CLR(x)			VAL_MASK(x, 1, 0)
-#define  V_FS1_INTR_CLR(x)			VAL_MASK(x, 1, 1)
-#define  V_ADDR_SAME_INTR_CLR(x)		VAL_MASK(x, 1, 2)
-#define  V_LINE_FLAG0_INTR_CLR(x)		VAL_MASK(x, 1, 3)
-#define  V_LINE_FLAG1_INTR_CLR(x)		VAL_MASK(x, 1, 4)
-#define  V_BUS_ERROR_INTR_CLR(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN0_EMPTY_INTR_CLR(x)		VAL_MASK(x, 1, 6)
-#define  V_WIN1_EMPTY_INTR_CLR(x)		VAL_MASK(x, 1, 7)
-#define  V_DSP_HOLD_VALID_INTR_CLR(x)		VAL_MASK(x, 1, 8)
-#define  V_DMA_FRM_FSH_INTR_CLR(x)		VAL_MASK(x, 1, 9)
-#define INTR_STATUS			0x0000003c
-#define  V_FS0_INTR_STS(x)			VAL_MASK(x, 1, 0)
-#define  V_FS1_INTR_STS(x)			VAL_MASK(x, 1, 1)
-#define  V_ADDR_SAME_INTR_STS(x)		VAL_MASK(x, 1, 2)
-#define  V_LINE_FLAG0_INTR_STS(x)		VAL_MASK(x, 1, 3)
-#define  V_LINE_FLAG1_INTR_STS(x)		VAL_MASK(x, 1, 4)
-#define  V_BUS_ERROR_INTR_STS(x)		VAL_MASK(x, 1, 5)
-#define  V_WIN0_EMPTY_INTR_STS(x)		VAL_MASK(x, 1, 6)
-#define  V_WIN1_EMPTY_INTR_STS(x)		VAL_MASK(x, 1, 7)
-#define  V_DSP_HOLD_VALID_INTR_STS(x)		VAL_MASK(x, 1, 8)
-#define  V_DMA_FRM_FSH_INTR_STS(x)		VAL_MASK(x, 1, 9)
-#define  V_MMU_INTR_STATUS(x)			VAL_MASK(x, 1, 15)
-#define  V_FS0_INTR_RAW_STS(x)			VAL_MASK(x, 1, 16)
-#define  V_FS1_INTR_RAW_STS(x)			VAL_MASK(x, 1, 17)
-#define  V_ADDR_SAME_INTR_RAW_STS(x)		VAL_MASK(x, 1, 18)
-#define  V_LINE_FLAG0_INTR_RAW_STS(x)		VAL_MASK(x, 1, 19)
-#define  V_LINE_FLAG1_INTR_RAW_STS(x)		VAL_MASK(x, 1, 20)
-#define  V_BUS_ERROR_INTR_RAW_STS(x)		VAL_MASK(x, 1, 21)
-#define  V_WIN0_EMPTY_INTR_RAW_STS(x)		VAL_MASK(x, 1, 22)
-#define  V_WIN1_EMPTY_INTR_RAW_STS(x)		VAL_MASK(x, 1, 23)
-#define  V_DSP_HOLD_VALID_INTR_RAW_STS(x)	VAL_MASK(x, 1, 24)
-#define  V_DMA_FRM_FSH_INTR_RAW_STS(x)		VAL_MASK(x, 1, 25)
-#define WIN0_CTRL0			0x00000050
-#define  V_WIN0_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN0_DATA_FMT(x)			VAL_MASK(x, 3, 1)
-#define  V_WIN0_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
-#define  V_WIN0_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
-#define  V_WIN0_CSC_MODE(x)			VAL_MASK(x, 2, 10)
-#define  V_WIN0_RB_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN0_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_WIN0_MID_SWAP(x)			VAL_MASK(x, 1, 14)
-#define  V_WIN0_UV_SWAP(x)			VAL_MASK(x, 1, 15)
-#define  V_WIN0_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
-#define  V_WIN0_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
-#define WIN0_CTRL1			0x00000054
-#define  V_WIN0_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN0_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
-#define  V_WIN0_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
-#define  V_WIN0_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
-#define  V_WIN0_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 8)
-#define  V_SW_WIN0_YRGB0_RID(x)			VAL_MASK(x, 4, 12)
-#define  V_SW_WIN0_CBR0_RID(x)			VAL_MASK(x, 4, 16)
-#define WIN0_COLOR_KEY			0x00000058
-#define  V_WIN0_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN0_KEY_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN0_VIR			0x0000005c
-#define  V_WIN0_YRGB_VIR_STRIDE(x)		VAL_MASK(x, 13, 0)
-#define  V_WIN0_CBR_VIR_STRIDE(x)		VAL_MASK(x, 13, 16)
-#define WIN0_YRGB_MST			0x00000060
-#define WIN0_CBR_MST			0x00000064
-#define WIN0_ACT_INFO			0x00000068
-#define  V_WIN0_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
-#define  V_WIN0_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
-#define WIN0_DSP_INFO			0x0000006c
-#define  V_WIN0_DSP_WIDTH(x)			VAL_MASK(x, 11, 0)
-#define  V_WIN0_DSP_HEIGHT(x)			VAL_MASK(x, 11, 16)
-#define WIN0_DSP_ST			0x00000070
-#define  V_WIN0_DSP_XST(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN0_DSP_YST(x)			VAL_MASK(x, 12, 16)
-#define WIN0_SCL_FACTOR_YRGB		0x00000074
-#define  V_WIN0_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN0_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
-#define WIN0_SCL_FACTOR_CBR		0x00000078
-#define  V_WIN0_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
-#define  V_WIN0_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
-#define WIN0_SCL_OFFSET			0x0000007c
-#define  V_WIN0_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
-#define  V_WIN0_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
-#define  V_WIN0_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
-#define  V_WIN0_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
-#define WIN0_ALPHA_CTRL			0x00000080
-#define  V_WIN0_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN0_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
-#define  V_WIN0_ALPHA_PRE_MUL(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN0_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
-#define  V_WIN0_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
-#define WIN1_CTRL0			0x00000090
-#define  V_WIN1_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_WIN1_CSC_MODE(x)			VAL_MASK(x, 1, 2)
-#define  V_WIN1_DATA_FMT(x)			VAL_MASK(x, 3, 4)
-#define  V_WIN1_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
-#define  V_WIN1_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
-#define  V_WIN1_RB_SWAP(x)			VAL_MASK(x, 1, 12)
-#define  V_WIN1_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
-#define  V_WIN1_ENDIAN_SWAP(x)			VAL_MASK(x, 1, 14)
-#define WIN1_CTRL1			0x00000094
-#define  V_WIN1_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
-#define  V_WIN1_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
-#define  V_WIN1_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
-#define  V_SW_WIN1_RID(x)			VAL_MASK(x, 4, 8)
-#define WIN1_VIR			0x00000098
-#define  V_WIN1_VIR_STRIDE(x)			VAL_MASK(x, 13, 0)
-#define WIN1_YRGB_MST			0x000000a0
-#define WIN1_DSP_INFO			0x000000a4
-#define  V_WIN1_DSP_WIDTH(x)			VAL_MASK(x, 11, 0)
-#define  V_WIN1_DSP_HEIGHT(x)			VAL_MASK(x, 11, 16)
-#define WIN1_DSP_ST			0x000000a8
-#define  V_WIN1_DSP_XST(x)			VAL_MASK(x, 12, 0)
-#define  V_WIN1_DSP_YST(x)			VAL_MASK(x, 12, 16)
-#define WIN1_COLOR_KEY			0x000000ac
-#define  V_WIN1_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
-#define  V_WIN1_KEY_EN(x)			VAL_MASK(x, 1, 24)
-#define WIN1_ALPHA_CTRL			0x000000bc
-#define  V_WIN1_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_WIN1_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
-#define  V_WIN1_ALPHA_PRE_MUL(x)		VAL_MASK(x, 1, 2)
-#define  V_WIN1_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
-#define  V_WIN1_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
-#define HWC_CTRL0			0x000000e0
-#define  V_HWC_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_HWC_SIZE(x)				VAL_MASK(x, 1, 1)
-#define  V_HWC_LOAD_EN(x)			VAL_MASK(x, 1, 2)
-#define  V_HWC_LUT_EN(x)			VAL_MASK(x, 1, 3)
-#define  V_SW_HWC_RID(x)			VAL_MASK(x, 4, 4)
-#define HWC_CTRL1			0x000000e4
-#define HWC_MST				0x000000e8
-#define HWC_DSP_ST			0x000000ec
-#define  V_HWC_DSP_XST(x)			VAL_MASK(x, 12, 0)
-#define  V_HWC_DSP_YST(x)			VAL_MASK(x, 12, 16)
-#define HWC_ALPHA_CTRL			0x000000f0
-#define  V_HWC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
-#define  V_HWC_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
-#define  V_HWC_ALPHA_PRE_MUL(x)			VAL_MASK(x, 1, 2)
-#define  V_HWC_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
-#define  V_HWC_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
-#define DSP_HTOTAL_HS_END		0x00000100
-#define  V_DSP_HS_END(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_HTOTAL(x)			VAL_MASK(x, 12, 16)
-#define DSP_HACT_ST_END			0x00000104
-#define  V_DSP_HACT_END(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_HACT_ST(x)			VAL_MASK(x, 12, 16)
-#define DSP_VTOTAL_VS_END		0x00000108
-#define  V_DSP_VS_END(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_VTOTAL(x)			VAL_MASK(x, 12, 16)
-#define DSP_VACT_ST_END			0x0000010c
-#define  V_DSP_VACT_END(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_VACT_ST(x)			VAL_MASK(x, 12, 16)
-#define DSP_VS_ST_END_F1		0x00000110
-#define  V_DSP_VS_END_F1(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_VS_ST_F1(x)			VAL_MASK(x, 12, 16)
-#define DSP_VACT_ST_END_F1		0x00000114
-#define  V_DSP_VACT_END_F1(x)			VAL_MASK(x, 12, 0)
-#define  V_DSP_VACT_ST_F1(x)			VAL_MASK(x, 12, 16)
-#define BCSH_CTRL			0x00000160
-#define  V_BCSH_EN(x)				VAL_MASK(x, 1, 0)
-#define  V_SW_BCSH_R2Y_CSC_MODE(x)		VAL_MASK(x, 1, 1)
-#define  V_VIDEO_MODE(x)			VAL_MASK(x, 2, 2)
-#define  V_SW_BCSH_Y2R_CSC_MODE(x)		VAL_MASK(x, 2, 4)
-#define  V_SW_BCSH_Y2R_EN(x)			VAL_MASK(x, 1, 6)
-#define  V_SW_BCSH_R2Y_EN(x)			VAL_MASK(x, 1, 7)
-#define BCSH_COL_BAR			0x00000164
-#define  V_COLOR_BAR_Y(x)			VAL_MASK(x, 8, 0)
-#define  V_COLOR_BAR_U(x)			VAL_MASK(x, 8, 8)
-#define  V_COLOR_BAR_V(x)			VAL_MASK(x, 8, 16)
-#define BCSH_BCS			0x00000168
-#define  V_BRIGHTNESS(x)			VAL_MASK(x, 6, 0)
-#define  V_CONTRAST(x)				VAL_MASK(x, 8, 8)
-#define  V_SAT_CON(x)				VAL_MASK(x, 9, 16)
-#define BCSH_H				0x0000016c
-#define  V_SIN_HUE(x)				VAL_MASK(x, 8, 0)
-#define  V_COS_HUE(x)				VAL_MASK(x, 8, 8)
-#define FRC_LOWER01_0			0x00000170
-#define  V_LOWER01_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER01_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER01_1			0x00000174
-#define  V_LOWER01_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER01_FRM3(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER10_0			0x00000178
-#define  V_LOWER10_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER10_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER10_1			0x0000017c
-#define  V_LOWER10_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER10_FRM3(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER11_0			0x00000180
-#define  V_LOWER11_FRM0(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER11_FRM1(x)			VAL_MASK(x, 16, 16)
-#define FRC_LOWER11_1			0x00000184
-#define  V_LOWER11_FRM2(x)			VAL_MASK(x, 16, 0)
-#define  V_LOWER11_FRM3(x)			VAL_MASK(x, 16, 16)
-#define DBG_REG_000			0x00000190
-#define BLANKING_VALUE			0x000001f4
-#define  V_SW_BLANKING_VALUE(x)			VAL_MASK(x, 24, 0)
-#define  V_BLANKING_VALUE_CONFIG_EN(x)		VAL_MASK(x, 1, 24)
-#define FLAG_REG_FRM_VALID		0x000001f8
-#define FLAG_REG			0x000001fc
-#define HWC_LUT_ADDR			0x00000600
-#define GAMMA_LUT_ADDR			0x00000a00
-#define MMU_DTE_ADDR			0x00000f00
-#define MMU_STATUS			0x00000f04
-#define  V_PAGING_ENABLED(x)			VAL_MASK(x, 1, 0)
-#define  V_PAGE_FAULT_ACTIVE(x)			VAL_MASK(x, 1, 1)
-#define  V_STAIL_ACTIVE(x)			VAL_MASK(x, 1, 2)
-#define  V_MMU_IDLE(x)				VAL_MASK(x, 1, 3)
-#define  V_REPLAY_BUFFER_EMPTY(x)		VAL_MASK(x, 1, 4)
-#define  V_PAGE_FAULT_IS_WRITE(x)		VAL_MASK(x, 1, 5)
-#define MMU_COMMAND			0x00000f08
-#define MMU_PAGE_FAULT_ADDR		0x00000f0c
-#define MMU_ZAP_ONE_LINE		0x00000f10
-#define MMU_INT_RAWSTAT			0x00000f14
-#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
-#define MMU_INT_CLEAR			0x00000f18
-#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
-#define MMU_INT_MASK			0x00000f1c
-#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
-#define MMU_INT_STATUS			0x00000f20
-#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
-#define MMU_AUTO_GATING			0x00000f24
-#define  V_MMU_AUTO_GATING(x)			VAL_MASK(x, 1, 0)
-#define MMU_CFG_DONE			0x00000f28
-
-#define INTR_FS0		BIT(0)
-#define INTR_FS1		BIT(1)
-#define INTR_ADDR_SAME		BIT(2)
-#define INTR_LINE_FLAG0		BIT(3)
-#define INTR_LINE_FLAG1		BIT(4)
-#define INTR_BUS_ERROR		BIT(5)
-#define INTR_WIN0_EMPTY		BIT(6)
-#define INTR_WIN1_EMPTY		BIT(7)
-#define INTR_DSP_HOLD_VALID	BIT(8)
-#define INTR_DMA_FINISH		BIT(9)
-#define INTR_MMU_STATUS		BIT(15)
-
-#define INTR_MASK (INTR_FS0 | INTR_FS1 | INTR_ADDR_SAME | INTR_LINE_FLAG0 | \
-			INTR_LINE_FLAG1 | INTR_BUS_ERROR | INTR_WIN0_EMPTY | \
-			INTR_WIN1_EMPTY | INTR_DSP_HOLD_VALID | INTR_DMA_FINISH)
-
-/* GRF register for VOP source select */
-#define GRF_WEN_SHIFT(x)	(BIT(x) << 16)
-
-#define GRF_SOC_CON0		0x0400
-#define V_LVDS_VOP_SEL(x)		(((x) << 0) | GRF_WEN_SHIFT(0))
-#define V_HDMI_VOP_SEL(x)		(((x) << 1) | GRF_WEN_SHIFT(1))
-#define V_DSI0_VOP_SEL(x)		(((x) << 2) | GRF_WEN_SHIFT(2))
-
-#define GRF_SOC_CON5		0x0414
-#define V_RGB_VOP_SEL(x)		(((x) << 4) | GRF_WEN_SHIFT(4))
-
-#define GRF_IO_VSEL		0x0900
-#define V_VOP_IOVOL_SEL(x)		(((x) << 0) | GRF_WEN_SHIFT(0))
-
-struct vop_sync_obj_s {
-	struct completion stdbyfin;	/* standby finish */
-	int stdbyfin_to;
-	struct completion frmst;	/* frame start */
-	int frmst_to;
-};
-
-struct vop_device {
-	int id;
-	struct rk_lcdc_driver driver;
-	struct device *dev;
-	struct rk_screen *screen;
-
-	void __iomem *regs;
-	void *regsbak;
-	u32 reg_phy_base;
-	u32 len;
-	void __iomem *hwc_lut_addr_base;
-	void __iomem *dsp_lut_addr_base;
-	struct regmap *grf_base;
-
-	/* one time only one process allowed to config the register */
-	spinlock_t reg_lock;
-
-	int prop;	/* used for primary or extended display device */
-	bool pre_init;
-	bool pwr18;	/* if lcdc use 1.8v power supply */
-	/* if aclk or hclk is closed, access to register is not allowed */
-	bool clk_on;
-	/* active layer counter,when atv_layer_cnt = 0,disable lcdc */
-	u8 atv_layer_cnt;
-
-	unsigned int		irq;
-
-	struct clk		*hclk;	/* lcdc AHP clk */
-	struct clk		*dclk;	/* lcdc dclk */
-	struct clk		*aclk;	/* lcdc share memory frequency */
-	u32 pixclock;
-
-	u32 standby;		/* 1:standby,0:wrok */
-	u32 iommu_status;
-	struct backlight_device *backlight;
-
-	/* lock vop irq reg */
-	spinlock_t irq_lock;
-	struct vop_sync_obj_s sync;
-};
-
-static inline int vop_completion_timeout_ms(struct completion *comp, int to)
-{
-	long jiffies = msecs_to_jiffies(to);
-
-	return wait_for_completion_timeout(comp, jiffies);
-}
-
-static inline void vop_writel(struct vop_device *vop_dev, u32 offset, u32 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	*_pv = v;
-	writel_relaxed(v, vop_dev->regs + offset);
-}
-
-static inline u32 vop_readl(struct vop_device *vop_dev, u32 offset)
-{
-	u32 v;
-
-	v = readl_relaxed(vop_dev->regs + offset);
-	return v;
-}
-
-static inline u32 vop_readl_backup(struct vop_device *vop_dev, u32 offset)
-{
-	u32 v;
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	v = readl_relaxed(vop_dev->regs + offset);
-	*_pv = v;
-	return v;
-}
-
-static inline u32 vop_read_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 _v = readl_relaxed(vop_dev->regs + offset);
-
-	_v &= v >> 32;
-	v = (_v ? 1 : 0);
-	return v;
-}
-
-static inline void vop_set_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) |= v >> 32;
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_clr_bit(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~(v >> 32));
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_msk_reg(struct vop_device *vop_dev, u32 offset, u64 v)
-{
-	u32 *_pv = (u32 *)vop_dev->regsbak;
-
-	_pv += (offset >> 2);
-	(*_pv) &= (~(v >> 32));
-	(*_pv) |= (u32)v;
-	writel_relaxed(*_pv, vop_dev->regs + offset);
-}
-
-static inline void vop_mask_writel(struct vop_device *vop_dev, u32 offset,
-				   u32 mask, u32 v)
-{
-	v = mask << 16 | v;
-	writel_relaxed(v, vop_dev->regs + offset);
-}
-
-static inline void vop_cfg_done(struct vop_device *vop_dev)
-{
-	writel_relaxed(0x001f001f, vop_dev->regs + REG_CFG_DONE);
-	dsb(sy);
-}
-
-static inline int vop_grf_writel(struct regmap *base, u32 offset, u32 val)
-{
-	if (base)
-		regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int vop_cru_writel(struct regmap *base, u32 offset, u32 val)
-{
-	if (base)
-		regmap_write(base, offset, val);
-	dsb(sy);
-
-	return 0;
-}
-
-static inline int vop_cru_readl(struct regmap *base, u32 offset)
-{
-	u32 v;
-
-	if (base)
-		regmap_read(base, offset, &v);
-
-	return v;
-}
-
-enum dither_down_mode {
-	DITHER_888_565 = 0x0,
-	DITHER_888_666 = 0x1,
-};
-
-enum dither_down_sel {
-	DITHER_SEL_ALLEGRO = 0x0,
-	DITHER_SEL_FRC = 0x1,
-};
-
-enum _vop_r2y_csc_mode {
-	VOP_R2Y_CSC_BT601 = 0,
-	VOP_R2Y_CSC_BT709
-};
-
-enum _vop_y2r_csc_mode {
-	VOP_Y2R_CSC_MPEG = 0,
-	VOP_Y2R_CSC_HD,
-	VOP_Y2R_CSC_JPEG,
-	VOP_Y2R_CSC_BYPASS
-};
-
-enum _vop_format {
-	VOP_FORMAT_ARGB888 = 0,
-	VOP_FORMAT_RGB888,
-	VOP_FORMAT_RGB565,
-	VOP_FORMAT_YCBCR420 = 4,
-	VOP_FORMAT_YCBCR422,
-	VOP_FORMAT_YCBCR444
-};
-
-enum _bcsh_video_mode {
-	BCSH_MODE_BLACK = 0,
-	BCSH_MODE_BLUE,
-	BCSH_MODE_COLORBAR,
-	BCSH_MODE_VIDEO,
-};
-
-#define IS_YUV(x) ((x) >= VOP_FORMAT_YCBCR420)
-
-enum _vop_overlay_mode {
-	VOP_RGB_DOMAIN,
-	VOP_YUV_DOMAIN
-};
-
-/*************************************************************/
-#define CALSCALE(x, y)  \
-	(1 == (y) ? 0x1000 : ((((u32)((x) - 1)) * 0x1000) / ((y) - 1)))
-
-#endif
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
deleted file mode 100644
index 45b9569d7ed7..000000000000
--- a/drivers/video/rockchip/rk_fb.c
+++ /dev/null
@@ -1,4723 +0,0 @@
-/*
- * drivers/video/rockchip/rk_fb.c
- *
- * Copyright (C) ROCKCHIP, Inc.
- * Author:yxj<yxj@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/kthread.h>
-#include <linux/fb.h>
-#include <linux/init.h>
-#include <linux/vmalloc.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rk_fb.h>
-#include <linux/linux_logo.h>
-#include <linux/dma-mapping.h>
-#include <linux/regulator/consumer.h>
-#include <linux/of_address.h>
-#include <linux/memblock.h>
-
-#include "bmp_helper.h"
-
-#if defined(CONFIG_RK_HDMI)
-#include "hdmi/rockchip-hdmi.h"
-#endif
-
-#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
-#include "rga/rga.h"
-#endif
-
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#include <linux/of_platform.h>
-#include <linux/of_gpio.h>
-#include <video/of_display_timing.h>
-#include <video/display_timing.h>
-#endif
-
-#if defined(CONFIG_ION_ROCKCHIP)
-#include <linux/rockchip_ion.h>
-#include <linux/rockchip-iovmm.h>
-#include <linux/dma-buf.h>
-#include <linux/highmem.h>
-#endif
-
-#define H_USE_FENCE 1
-/* #define FB_ROATE_BY_KERNEL 1 */
-
-static int hdmi_switch_state;
-static struct platform_device *fb_pdev;
-
-#if defined(CONFIG_FB_MIRRORING)
-int (*video_data_to_mirroring)(struct fb_info *info, u32 yuv_phy[2]);
-EXPORT_SYMBOL(video_data_to_mirroring);
-#endif
-
-extern phys_addr_t uboot_logo_base;
-extern phys_addr_t uboot_logo_size;
-extern phys_addr_t uboot_logo_offset;
-static struct rk_fb_trsm_ops *trsm_lvds_ops;
-static struct rk_fb_trsm_ops *trsm_edp_ops;
-static struct rk_fb_trsm_ops *trsm_mipi_ops;
-static int uboot_logo_on;
-
-static int rk_fb_debug_lvl;
-static int rk_fb_iommu_debug;
-module_param(rk_fb_debug_lvl, int, S_IRUGO | S_IWUSR);
-module_param(rk_fb_iommu_debug, int, S_IRUGO | S_IWUSR);
-
-#define rk_fb_dbg(level, x...) do {		\
-	if (unlikely(rk_fb_debug_lvl >= level))	\
-		pr_info(x);			\
-	} while (0)
-static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
-			      struct rk_fb_win_cfg_data *win_data,
-			      struct rk_fb_reg_data *regs, u32 cmd);
-static int car_reversing;
-
-static int is_car_camcap(void) {
-	return car_reversing && strcmp("camcap", current->comm);
-}
-
-int support_uboot_display(void)
-{
-	return uboot_logo_on;
-}
-
-int rk_fb_get_display_policy(void)
-{
-	struct rk_fb *rk_fb;
-
-	if (fb_pdev) {
-		rk_fb = platform_get_drvdata(fb_pdev);
-		return rk_fb->disp_policy;
-	} else {
-		return DISPLAY_POLICY_SDK;
-	}
-}
-
-int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)
-{
-	switch (type) {
-	case SCREEN_RGB:
-	case SCREEN_LVDS:
-	case SCREEN_DUAL_LVDS:
-	case SCREEN_LVDS_10BIT:
-	case SCREEN_DUAL_LVDS_10BIT:
-		trsm_lvds_ops = ops;
-		break;
-	case SCREEN_EDP:
-		trsm_edp_ops = ops;
-		break;
-	case SCREEN_MIPI:
-	case SCREEN_DUAL_MIPI:
-		trsm_mipi_ops = ops;
-		break;
-	default:
-		pr_warn("%s: unsupported transmitter: %d!\n",
-			__func__, type);
-		break;
-	}
-	return 0;
-}
-
-struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type)
-{
-	struct rk_fb_trsm_ops *ops;
-
-	switch (type) {
-	case SCREEN_RGB:
-	case SCREEN_LVDS:
-	case SCREEN_DUAL_LVDS:
-	case SCREEN_LVDS_10BIT:
-	case SCREEN_DUAL_LVDS_10BIT:
-		ops = trsm_lvds_ops;
-		break;
-	case SCREEN_EDP:
-		ops = trsm_edp_ops;
-		break;
-	case SCREEN_MIPI:
-	case SCREEN_DUAL_MIPI:
-		ops = trsm_mipi_ops;
-		break;
-	default:
-		ops = NULL;
-		pr_warn("%s: unsupported transmitter: %d!\n",
-			__func__, type);
-		break;
-	}
-	return ops;
-}
-
-int rk_fb_pixel_width(int data_format)
-{
-	int pixel_width;
-
-	switch (data_format) {
-	case XBGR888:
-	case XRGB888:
-	case ABGR888:
-	case ARGB888:
-	case FBDC_ARGB_888:
-	case FBDC_ABGR_888:
-	case FBDC_RGBX_888:
-		pixel_width = 4 * 8;
-		break;
-	case RGB888:
-	case BGR888:
-		pixel_width = 3 * 8;
-		break;
-	case RGB565:
-	case BGR565:
-	case FBDC_RGB_565:
-		pixel_width = 2 * 8;
-		break;
-	case YUV422:
-	case YUV420:
-	case YUV420_NV21:
-	case YUV444:
-		pixel_width = 1 * 8;
-		break;
-	case YUV422_A:
-	case YUV420_A:
-	case YUV444_A:
-		pixel_width = 8;
-		break;
-	case YUYV422:
-	case UYVY422:
-	case YUYV420:
-	case UYVY420:
-		pixel_width = 16;
-		break;
-	default:
-		pr_warn("%s: unsupported format: 0x%x\n",
-			__func__, data_format);
-		return -EINVAL;
-	}
-	return pixel_width;
-}
-
-static int rk_fb_data_fmt(int data_format, int bits_per_pixel)
-{
-	int fb_data_fmt = 0;
-
-	if (data_format) {
-		switch (data_format) {
-		case HAL_PIXEL_FORMAT_RGBX_8888:
-			fb_data_fmt = XBGR888;
-			break;
-		case HAL_PIXEL_FORMAT_BGRX_8888:
-			fb_data_fmt = XRGB888;
-			break;
-		case HAL_PIXEL_FORMAT_RGBA_8888:
-			fb_data_fmt = ABGR888;
-			break;
-		case HAL_PIXEL_FORMAT_BGRA_8888:
-			fb_data_fmt = ARGB888;
-			break;
-		case HAL_PIXEL_FORMAT_RGB_888:
-			fb_data_fmt = RGB888;
-			break;
-		case HAL_PIXEL_FORMAT_BGR_888:
-			fb_data_fmt = BGR888;
-			break;
-		case HAL_PIXEL_FORMAT_RGB_565:
-			fb_data_fmt = RGB565;
-			break;
-		case HAL_PIXEL_FORMAT_BGR_565:
-			fb_data_fmt = BGR565;
-			break;
-		case HAL_PIXEL_FORMAT_YCbCr_422_SP:	/* yuv422 */
-			fb_data_fmt = YUV422;
-			break;
-		case HAL_PIXEL_FORMAT_YCrCb_420_SP:	/* YUV420---vuvuvu */
-			fb_data_fmt = YUV420_NV21;
-			break;
-		case HAL_PIXEL_FORMAT_YCrCb_NV12:	/* YUV420---uvuvuv */
-			fb_data_fmt = YUV420;
-			break;
-		case HAL_PIXEL_FORMAT_YCrCb_444:	/* yuv444 */
-			fb_data_fmt = YUV444;
-			break;
-		case HAL_PIXEL_FORMAT_YCrCb_NV12_10:	/* yuv444 */
-			fb_data_fmt = YUV420_A;
-			break;
-		case HAL_PIXEL_FORMAT_YCbCr_422_SP_10:	/* yuv444 */
-			fb_data_fmt = YUV422_A;
-			break;
-		case HAL_PIXEL_FORMAT_YCrCb_444_SP_10:	/* yuv444 */
-			fb_data_fmt = YUV444_A;
-			break;
-		case HAL_PIXEL_FORMAT_FBDC_RGB565:	/* fbdc rgb565*/
-			fb_data_fmt = FBDC_RGB_565;
-			break;
-		case HAL_PIXEL_FORMAT_FBDC_U8U8U8U8:	/* fbdc argb888 */
-			fb_data_fmt = FBDC_ARGB_888;
-			break;
-		case HAL_PIXEL_FORMAT_FBDC_RGBA888:	/* fbdc abgr888 */
-			fb_data_fmt = FBDC_ABGR_888;
-			break;
-		case HAL_PIXEL_FORMAT_FBDC_U8U8U8:	/* fbdc rgb888 */
-			fb_data_fmt = FBDC_RGBX_888;
-			break;
-		case HAL_PIXEL_FORMAT_YUYV422:		/* yuyv422 */
-			fb_data_fmt = YUYV422;
-			break;
-		case HAL_PIXEL_FORMAT_YUYV420:		/* yuyv420 */
-			fb_data_fmt = YUYV420;
-			break;
-		case HAL_PIXEL_FORMAT_UYVY422:		/* uyvy422 */
-			fb_data_fmt = UYVY422;
-			break;
-		case HAL_PIXEL_FORMAT_UYVY420:		/* uyvy420 */
-			fb_data_fmt = UYVY420;
-			break;
-		default:
-			pr_warn("%s: unsupported format: 0x%x\n",
-				__func__, data_format);
-			return -EINVAL;
-		}
-	} else {
-		switch (bits_per_pixel) {
-		case 32:
-			fb_data_fmt = ARGB888;
-			break;
-		case 24:
-			fb_data_fmt = RGB888;
-			break;
-		case 16:
-			fb_data_fmt = RGB565;
-			break;
-		default:
-			pr_warn("%s: unsupported bits_per_pixel: %d\n",
-				__func__, bits_per_pixel);
-			break;
-		}
-	}
-	return fb_data_fmt;
-}
-
-/*
- * rk display power control parse from dts
- */
-int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)
-{
-	struct device_node *root = of_get_child_by_name(dev_drv->dev->of_node,
-							"power_ctr");
-	struct device_node *child;
-	struct rk_disp_pwr_ctr_list *pwr_ctr;
-	struct list_head *pos;
-	enum of_gpio_flags flags;
-	u32 val = 0;
-	u32 debug = 0;
-	int ret;
-
-	INIT_LIST_HEAD(&dev_drv->pwrlist_head);
-	if (!root) {
-		dev_err(dev_drv->dev, "can't find power_ctr node for lcdc%d\n",
-			dev_drv->id);
-		return -ENODEV;
-	}
-
-	for_each_child_of_node(root, child) {
-		pwr_ctr = kmalloc(sizeof(struct rk_disp_pwr_ctr_list),
-				  GFP_KERNEL);
-		if (!pwr_ctr)
-			return -ENOMEM;
-		strcpy(pwr_ctr->pwr_ctr.name, child->name);
-		if (!of_property_read_u32(child, "rockchip,power_type", &val)) {
-			if (val == GPIO) {
-				pwr_ctr->pwr_ctr.type = GPIO;
-				pwr_ctr->pwr_ctr.gpio = of_get_gpio_flags(child, 0, &flags);
-				if (!gpio_is_valid(pwr_ctr->pwr_ctr.gpio)) {
-					dev_err(dev_drv->dev, "%s ivalid gpio\n",
-						child->name);
-					return -EINVAL;
-				}
-				pwr_ctr->pwr_ctr.atv_val = !(flags & OF_GPIO_ACTIVE_LOW);
-				ret = gpio_request(pwr_ctr->pwr_ctr.gpio,
-						   child->name);
-				if (ret) {
-					dev_err(dev_drv->dev,
-						"request %s gpio fail:%d\n",
-						child->name, ret);
-				}
-
-			} else {
-				pwr_ctr->pwr_ctr.type = REGULATOR;
-				pwr_ctr->pwr_ctr.rgl_name = NULL;
-				ret = of_property_read_string(child, "rockchip,regulator_name",
-							      &(pwr_ctr->pwr_ctr.rgl_name));
-				if (ret || IS_ERR_OR_NULL(pwr_ctr->pwr_ctr.rgl_name))
-					dev_err(dev_drv->dev, "get regulator name failed!\n");
-				if (!of_property_read_u32(child, "rockchip,regulator_voltage", &val))
-					pwr_ctr->pwr_ctr.volt = val;
-				else
-					pwr_ctr->pwr_ctr.volt = 0;
-			}
-		};
-
-		if (!of_property_read_u32(child, "rockchip,delay", &val))
-			pwr_ctr->pwr_ctr.delay = val;
-		else
-			pwr_ctr->pwr_ctr.delay = 0;
-		list_add_tail(&pwr_ctr->list, &dev_drv->pwrlist_head);
-	}
-
-	of_property_read_u32(root, "rockchip,debug", &debug);
-
-	if (debug) {
-		list_for_each(pos, &dev_drv->pwrlist_head) {
-			pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list,
-					     list);
-			pr_info("pwr_ctr_name:%s\n"
-				"pwr_type:%s\n"
-				"gpio:%d\n"
-				"atv_val:%d\n"
-				"delay:%d\n\n",
-				pwr_ctr->pwr_ctr.name,
-				(pwr_ctr->pwr_ctr.type == GPIO) ? "gpio" : "regulator",
-				pwr_ctr->pwr_ctr.gpio,
-				pwr_ctr->pwr_ctr.atv_val,
-				pwr_ctr->pwr_ctr.delay);
-		}
-	}
-
-	return 0;
-}
-
-int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)
-{
-	struct list_head *pos;
-	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
-	struct pwr_ctr *pwr_ctr;
-	struct regulator *regulator_lcd = NULL;
-	int count = 10;
-
-	if (list_empty(&dev_drv->pwrlist_head))
-		return 0;
-	list_for_each(pos, &dev_drv->pwrlist_head) {
-		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,
-					  list);
-		pwr_ctr = &pwr_ctr_list->pwr_ctr;
-		if (pwr_ctr->type == GPIO) {
-			gpio_direction_output(pwr_ctr->gpio, pwr_ctr->atv_val);
-			mdelay(pwr_ctr->delay);
-		} else if (pwr_ctr->type == REGULATOR) {
-			if (pwr_ctr->rgl_name)
-				regulator_lcd =
-					regulator_get(NULL, pwr_ctr->rgl_name);
-			if (regulator_lcd == NULL) {
-				dev_err(dev_drv->dev,
-					"%s: regulator get failed,regulator name:%s\n",
-					__func__, pwr_ctr->rgl_name);
-				continue;
-			}
-			regulator_set_voltage(regulator_lcd, pwr_ctr->volt, pwr_ctr->volt);
-			while (!regulator_is_enabled(regulator_lcd)) {
-				if (regulator_enable(regulator_lcd) == 0 || count == 0)
-					break;
-				else
-					dev_err(dev_drv->dev,
-						"regulator_enable failed,count=%d\n",
-						count);
-				count--;
-			}
-			regulator_put(regulator_lcd);
-			msleep(pwr_ctr->delay);
-		}
-	}
-
-	return 0;
-}
-
-int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)
-{
-	struct list_head *pos;
-	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
-	struct pwr_ctr *pwr_ctr;
-	struct regulator *regulator_lcd = NULL;
-	int count = 10;
-
-	if (list_empty(&dev_drv->pwrlist_head))
-		return 0;
-	list_for_each(pos, &dev_drv->pwrlist_head) {
-		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,
-					  list);
-		pwr_ctr = &pwr_ctr_list->pwr_ctr;
-		if (pwr_ctr->type == GPIO) {
-			gpio_set_value(pwr_ctr->gpio, !pwr_ctr->atv_val);
-		} else if (pwr_ctr->type == REGULATOR) {
-			if (pwr_ctr->rgl_name)
-				regulator_lcd = regulator_get(NULL, pwr_ctr->rgl_name);
-			if (regulator_lcd == NULL) {
-				dev_err(dev_drv->dev,
-					"%s: regulator get failed,regulator name:%s\n",
-					__func__, pwr_ctr->rgl_name);
-				continue;
-			}
-			while (regulator_is_enabled(regulator_lcd) > 0) {
-				if (regulator_disable(regulator_lcd) == 0 ||
-				    count == 0)
-					break;
-				else
-					dev_err(dev_drv->dev,
-						"regulator_disable failed,count=%d\n",
-						count);
-				count--;
-			}
-			regulator_put(regulator_lcd);
-		}
-	}
-	return 0;
-}
-
-int rk_fb_video_mode_from_timing(const struct display_timing *dt,
-				 struct rk_screen *screen)
-{
-	screen->mode.pixclock = dt->pixelclock.typ;
-	screen->mode.left_margin = dt->hback_porch.typ;
-	screen->mode.right_margin = dt->hfront_porch.typ;
-	screen->mode.xres = dt->hactive.typ;
-	screen->mode.hsync_len = dt->hsync_len.typ;
-	screen->mode.upper_margin = dt->vback_porch.typ;
-	screen->mode.lower_margin = dt->vfront_porch.typ;
-	screen->mode.yres = dt->vactive.typ;
-	screen->mode.vsync_len = dt->vsync_len.typ;
-	screen->type = dt->screen_type;
-	screen->refresh_mode = dt->refresh_mode;
-	screen->lvds_format = dt->lvds_format;
-	screen->face = dt->face;
-	screen->color_mode = dt->color_mode;
-	screen->width = dt->screen_widt;
-	screen->height = dt->screen_hight;
-	screen->dsp_lut = dt->dsp_lut;
-	screen->cabc_lut = dt->cabc_lut;
-	screen->cabc_gamma_base = dt->cabc_gamma_base;
-
-	if (dt->flags & DISPLAY_FLAGS_INTERLACED)
-		screen->mode.vmode |= FB_VMODE_INTERLACED;
-	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
-		screen->pin_dclk = 1;
-	else
-		screen->pin_dclk = 0;
-	if (dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if (dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-	if (dt->flags & DISPLAY_FLAGS_DE_HIGH)
-		screen->pin_den = 1;
-	else
-		screen->pin_den = 0;
-
-	return 0;
-}
-
-int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
-{
-	struct display_timings *disp_timing;
-	struct display_timing *dt;
-
-	disp_timing = of_get_display_timings(np);
-	if (!disp_timing) {
-		pr_err("parse display timing err\n");
-		return -EINVAL;
-	}
-	dt = display_timings_get(disp_timing, disp_timing->native_mode);
-	rk_fb_video_mode_from_timing(dt, screen);
-
-	return 0;
-}
-
-int rk_fb_calc_fps(struct rk_screen *screen, u32 pixclock)
-{
-	int x, y;
-	unsigned long long hz;
-
-	if (!screen) {
-		pr_err("%s:null screen!\n", __func__);
-		return 0;
-	}
-	x = screen->mode.xres + screen->mode.left_margin +
-	    screen->mode.right_margin + screen->mode.hsync_len;
-	y = screen->mode.yres + screen->mode.upper_margin +
-	    screen->mode.lower_margin + screen->mode.vsync_len;
-
-	hz = 1000000000000ULL;	/* 1e12 picoseconds per second */
-
-	hz += (x * y) / 2;
-	do_div(hz, x * y);	/* divide by x * y with rounding */
-
-	hz += pixclock / 2;
-	do_div(hz, pixclock);	/* divide by pixclock with rounding */
-
-	return hz;
-}
-
-char *get_format_string(enum data_format format, char *fmt)
-{
-	if (!fmt)
-		return NULL;
-	switch (format) {
-	case ARGB888:
-		strcpy(fmt, "ARGB888");
-		break;
-	case RGB888:
-		strcpy(fmt, "RGB888");
-		break;
-	case BGR888:
-		strcpy(fmt, "BGR888");
-		break;
-	case RGB565:
-		strcpy(fmt, "RGB565");
-		break;
-	case BGR565:
-		strcpy(fmt, "BGR565");
-		break;
-	case YUV420:
-	case YUV420_NV21:
-		strcpy(fmt, "YUV420");
-		break;
-	case YUV422:
-		strcpy(fmt, "YUV422");
-		break;
-	case YUV444:
-		strcpy(fmt, "YUV444");
-		break;
-	case YUV420_A:
-		strcpy(fmt, "YUV420_A");
-		break;
-	case YUV422_A:
-		strcpy(fmt, "YUV422_A");
-		break;
-	case YUV444_A:
-		strcpy(fmt, "YUV444_A");
-		break;
-	case XRGB888:
-		strcpy(fmt, "XRGB888");
-		break;
-	case XBGR888:
-		strcpy(fmt, "XBGR888");
-		break;
-	case ABGR888:
-		strcpy(fmt, "ABGR888");
-		break;
-	case FBDC_RGB_565:
-		strcpy(fmt, "FBDC_RGB_565");
-		break;
-	case FBDC_ARGB_888:
-	case FBDC_ABGR_888:
-		strcpy(fmt, "FBDC_ARGB_888");
-		break;
-	case FBDC_RGBX_888:
-		strcpy(fmt, "FBDC_RGBX_888");
-		break;
-	case YUYV422:
-		strcpy(fmt, "YUYV422");
-		break;
-	case YUYV420:
-		strcpy(fmt, "YUYV420");
-		break;
-	case UYVY422:
-		strcpy(fmt, "UYVY422");
-		break;
-	case UYVY420:
-		strcpy(fmt, "UYVY420");
-		break;
-	default:
-		strcpy(fmt, "invalid");
-		break;
-	}
-
-	return fmt;
-}
-
-int rk_fb_set_vop_pwm(void)
-{
-	int i = 0;
-	struct rk_fb *inf = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-
-	if (likely(fb_pdev))
-		inf = platform_get_drvdata(fb_pdev);
-	else
-		return -1;
-
-	for (i = 0; i < inf->num_lcdc; i++) {
-		if (inf->lcdc_dev_drv[i]->cabc_mode == 1) {
-			dev_drv = inf->lcdc_dev_drv[i];
-			break;
-		}
-	}
-
-	if (!dev_drv)
-		return -1;
-
-	mutex_lock(&dev_drv->win_config);
-	if (dev_drv->ops->extern_func)
-		dev_drv->ops->extern_func(dev_drv, UPDATE_CABC_PWM);
-	mutex_unlock(&dev_drv->win_config);
-
-	return 0;
-}
-
-/*
- * this is for hdmi
- * name: lcdc device name ,lcdc0 , lcdc1
- */
-struct rk_lcdc_driver *rk_get_lcdc_drv(char *name)
-{
-	struct rk_fb *inf = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-	int i = 0;
-
-	if (likely(fb_pdev))
-		inf = platform_get_drvdata(fb_pdev);
-	else
-		return NULL;
-
-	for (i = 0; i < inf->num_lcdc; i++) {
-		if (!strcmp(inf->lcdc_dev_drv[i]->name, name)) {
-			dev_drv = inf->lcdc_dev_drv[i];
-			break;
-		}
-	}
-
-	return dev_drv;
-}
-
-static struct rk_lcdc_driver *rk_get_prmry_lcdc_drv(void)
-{
-	struct rk_fb *inf = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-	int i = 0;
-
-	if (likely(fb_pdev))
-		inf = platform_get_drvdata(fb_pdev);
-	else
-		return NULL;
-
-	for (i = 0; i < inf->num_lcdc; i++) {
-		if (inf->lcdc_dev_drv[i]->prop == PRMRY) {
-			dev_drv = inf->lcdc_dev_drv[i];
-			break;
-		}
-	}
-
-	return dev_drv;
-}
-
-static __maybe_unused struct rk_lcdc_driver *rk_get_extend_lcdc_drv(void)
-{
-	struct rk_fb *inf = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-	int i = 0;
-
-	if (likely(fb_pdev))
-		inf = platform_get_drvdata(fb_pdev);
-	else
-		return NULL;
-
-	for (i = 0; i < inf->num_lcdc; i++) {
-		if (inf->lcdc_dev_drv[i]->prop == EXTEND) {
-			dev_drv = inf->lcdc_dev_drv[i];
-			break;
-		}
-	}
-
-	return dev_drv;
-}
-
-/*
- * get one frame time of the prmry screen, unit: us
- */
-u32 rk_fb_get_prmry_screen_ft(void)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-	u32 htotal, vtotal, pixclock_ps;
-	u64 pix_total, ft_us;
-
-	if (unlikely(!dev_drv))
-		return 0;
-
-	pixclock_ps = dev_drv->pixclock;
-
-	vtotal = dev_drv->cur_screen->mode.upper_margin +
-		 dev_drv->cur_screen->mode.lower_margin +
-		 dev_drv->cur_screen->mode.yres +
-		 dev_drv->cur_screen->mode.vsync_len;
-	htotal = dev_drv->cur_screen->mode.left_margin +
-		 dev_drv->cur_screen->mode.right_margin +
-		 dev_drv->cur_screen->mode.xres +
-		 dev_drv->cur_screen->mode.hsync_len;
-	pix_total = htotal * vtotal;
-	ft_us = pix_total * pixclock_ps;
-	do_div(ft_us, 1000000);
-	if (dev_drv->frame_time.ft == 0)
-		dev_drv->frame_time.ft = ft_us;
-
-	ft_us = dev_drv->frame_time.framedone_t - dev_drv->frame_time.last_framedone_t;
-	do_div(ft_us, 1000);
-	ft_us = min(dev_drv->frame_time.ft, (u32)ft_us);
-	if (ft_us != 0)
-		dev_drv->frame_time.ft = ft_us;
-
-	return dev_drv->frame_time.ft;
-}
-
-/*
- * get the vblanking time of the prmry screen, unit: us
- */
-u32 rk_fb_get_prmry_screen_vbt(void)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-	u32 htotal, vblank, pixclock_ps;
-	u64 pix_blank, vbt_us;
-
-	if (unlikely(!dev_drv))
-		return 0;
-
-	pixclock_ps = dev_drv->pixclock;
-
-	htotal = (dev_drv->cur_screen->mode.left_margin +
-		  dev_drv->cur_screen->mode.right_margin +
-		  dev_drv->cur_screen->mode.xres +
-		  dev_drv->cur_screen->mode.hsync_len);
-	vblank = (dev_drv->cur_screen->mode.upper_margin +
-		  dev_drv->cur_screen->mode.lower_margin +
-		  dev_drv->cur_screen->mode.vsync_len);
-	pix_blank = htotal * vblank;
-	vbt_us = pix_blank * pixclock_ps;
-	do_div(vbt_us, 1000000);
-	return (u32)vbt_us;
-}
-
-/*
- * get the frame done time of the prmry screen, unit: us
- */
-u64 rk_fb_get_prmry_screen_framedone_t(void)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-
-	if (unlikely(!dev_drv))
-		return 0;
-	else
-		return dev_drv->frame_time.framedone_t;
-}
-
-/*
- * set prmry screen status
- */
-int rk_fb_set_prmry_screen_status(int status)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-	struct rk_screen *screen;
-
-	if (unlikely(!dev_drv))
-		return 0;
-
-	screen = dev_drv->cur_screen;
-	switch (status) {
-	case SCREEN_PREPARE_DDR_CHANGE:
-		if (screen->type == SCREEN_MIPI ||
-		    screen->type == SCREEN_DUAL_MIPI) {
-			if (dev_drv->trsm_ops->dsp_pwr_off)
-				dev_drv->trsm_ops->dsp_pwr_off();
-		}
-		break;
-	case SCREEN_UNPREPARE_DDR_CHANGE:
-		if (screen->type == SCREEN_MIPI ||
-		    screen->type == SCREEN_DUAL_MIPI) {
-			if (dev_drv->trsm_ops->dsp_pwr_on)
-				dev_drv->trsm_ops->dsp_pwr_on();
-		}
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-u32 rk_fb_get_prmry_screen_pixclock(void)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-
-	if (unlikely(!dev_drv))
-		return 0;
-	else
-		return dev_drv->pixclock;
-}
-
-int rk_fb_poll_prmry_screen_vblank(void)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-
-	if (likely(dev_drv)) {
-		if (dev_drv->ops->poll_vblank)
-			return dev_drv->ops->poll_vblank(dev_drv);
-		else
-			return RK_LF_STATUS_NC;
-	} else {
-		return RK_LF_STATUS_NC;
-	}
-}
-
-bool rk_fb_poll_wait_frame_complete(void)
-{
-	uint32_t timeout = RK_LF_MAX_TIMEOUT;
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-
-	if (likely(dev_drv)) {
-		if (dev_drv->ops->set_irq_to_cpu)
-			dev_drv->ops->set_irq_to_cpu(dev_drv, 0);
-	}
-
-	if (rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_NC) {
-		if (likely(dev_drv)) {
-			if (dev_drv->ops->set_irq_to_cpu)
-				dev_drv->ops->set_irq_to_cpu(dev_drv, 1);
-		}
-		return false;
-	}
-	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FR) && --timeout)
-		;
-	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FC) && --timeout)
-		;
-	if (likely(dev_drv)) {
-		if (dev_drv->ops->set_irq_to_cpu)
-			dev_drv->ops->set_irq_to_cpu(dev_drv, 1);
-	}
-
-	return true;
-}
-
-/* rk_fb_get_sysmmu_device_by_compatible()
- * @compt: dts device compatible name
- * return value: success: pointer to the device inside of platform device
- *               fail: NULL
- */
-struct device *rk_fb_get_sysmmu_device_by_compatible(const char *compt)
-{
-	struct device_node *dn = NULL;
-	struct platform_device *pd = NULL;
-	struct device *ret = NULL ;
-
-	dn = of_find_compatible_node(NULL, NULL, compt);
-	if (!dn) {
-		pr_info("can't find device node %s \r\n", compt);
-		return NULL;
-	}
-
-	pd = of_find_device_by_node(dn);
-	if (!pd) {
-		pr_info("can't find platform device node %s \r\n", compt);
-		return  NULL;
-	}
-	ret = &pd->dev;
-
-	return ret;
-}
-
-#ifdef CONFIG_IOMMU_API
-void rk_fb_platform_set_sysmmu(struct device *sysmmu, struct device *dev)
-{
-	dev->archdata.iommu = sysmmu;
-}
-#else
-void rk_fb_platform_set_sysmmu(struct device *sysmmu, struct device *dev)
-{
-}
-#endif
-
-static int rk_fb_open(struct fb_info *info, int user)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int win_id;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	fb_par->state++;
-	/* if this win aready opened ,no need to reopen */
-	if (dev_drv->win[win_id]->state)
-		return 0;
-	else
-		dev_drv->ops->open(dev_drv, win_id, 1);
-	return 0;
-}
-
-static int rk_fb_close(struct fb_info *info, int user)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_lcdc_win *win = NULL;
-	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-
-	if (win_id >= 0) {
-		win = dev_drv->win[win_id];
-		if (fb_par->state)
-			fb_par->state--;
-		if (!fb_par->state) {
-			if (fb_par->fb_phy_base > 0)
-				info->fix.smem_start = fb_par->fb_phy_base;
-			info->var.xres = dev_drv->screen0->mode.xres;
-			info->var.yres = dev_drv->screen0->mode.yres;
-			/*
-			 *info->var.grayscale |=
-			 *   (info->var.xres << 8) + (info->var.yres << 20);
-			 */
-			info->var.xres_virtual = info->var.xres;
-			info->var.yres_virtual = info->var.yres;
-#if defined(CONFIG_LOGO_LINUX_BMP)
-			info->var.bits_per_pixel = 32;
-#else
-			info->var.bits_per_pixel = 16;
-#endif
-			info->fix.line_length =
-			    (info->var.xres_virtual) *
-			    (info->var.bits_per_pixel >> 3);
-			info->var.width = dev_drv->screen0->width;
-			info->var.height = dev_drv->screen0->height;
-			info->var.pixclock = dev_drv->pixclock;
-			info->var.left_margin =
-				dev_drv->screen0->mode.left_margin;
-			info->var.right_margin =
-				dev_drv->screen0->mode.right_margin;
-			info->var.upper_margin =
-				dev_drv->screen0->mode.upper_margin;
-			info->var.lower_margin =
-				dev_drv->screen0->mode.lower_margin;
-			info->var.vsync_len = dev_drv->screen0->mode.vsync_len;
-			info->var.hsync_len = dev_drv->screen0->mode.hsync_len;
-		}
-	}
-
-	return 0;
-}
-
-#if defined(FB_ROATE_BY_KERNEL)
-
-#if defined(CONFIG_RK29_IPP)
-static int get_ipp_format(int fmt)
-{
-	int ipp_fmt = IPP_XRGB_8888;
-
-	switch (fmt) {
-	case HAL_PIXEL_FORMAT_RGBX_8888:
-	case HAL_PIXEL_FORMAT_BGRX_8888:
-	case HAL_PIXEL_FORMAT_RGBA_8888:
-	case HAL_PIXEL_FORMAT_BGRA_8888:
-	case HAL_PIXEL_FORMAT_RGB_888:
-	case HAL_PIXEL_FORMAT_BGR_888:
-		ipp_fmt = IPP_XRGB_8888;
-		break;
-	case HAL_PIXEL_FORMAT_RGB_565:
-	case HAL_PIXEL_FORMAT_BGR_565:
-		ipp_fmt = IPP_RGB_565;
-		break;
-	case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-		ipp_fmt = IPP_Y_CBCR_H2V1;
-		break;
-	case HAL_PIXEL_FORMAT_YCrCb_NV12:
-		ipp_fmt = IPP_Y_CBCR_H2V2;
-		break;
-	case HAL_PIXEL_FORMAT_YCrCb_444:
-		ipp_fmt = IPP_Y_CBCR_H1V1;
-		break;
-	default:
-		ipp_fmt = IPP_IMGTYPE_LIMIT;
-		break;
-	}
-
-	return ipp_fmt;
-}
-
-static void ipp_win_check(int *dst_w, int *dst_h, int *dst_vir_w,
-			  int rotation, int fmt)
-{
-	int align16 = 2;
-	int align64 = 8;
-
-	if (fmt == IPP_XRGB_8888) {
-		align16 = 1;
-		align64 = 2;
-	} else if (fmt == IPP_RGB_565) {
-		align16 = 1;
-		align64 = 4;
-	} else {
-		align16 = 2;
-		align64 = 8;
-	}
-	align16 -= 1;		/*for YUV, 1 */
-	align64 -= 1;		/*for YUV, 7 */
-
-	if (rotation == IPP_ROT_0) {
-		if (fmt > IPP_RGB_565) {
-			if ((*dst_w & 1) != 0)
-				*dst_w = *dst_w + 1;
-			if ((*dst_h & 1) != 0)
-				*dst_h = *dst_h + 1;
-			if (*dst_vir_w < *dst_w)
-				*dst_vir_w = *dst_w;
-		}
-	} else {
-		if ((*dst_w & align64) != 0)
-			*dst_w = (*dst_w + align64) & (~align64);
-		if ((fmt > IPP_RGB_565) && ((*dst_h & 1) == 1))
-			*dst_h = *dst_h + 1;
-		if (*dst_vir_w < *dst_w)
-			*dst_vir_w = *dst_w;
-	}
-}
-
-static void fb_copy_by_ipp(struct fb_info *dst_info,
-			   struct fb_info *src_info)
-{
-	struct rk29_ipp_req ipp_req;
-	uint32_t rotation = 0;
-	int dst_w, dst_h, dst_vir_w;
-	int ipp_fmt;
-	u8 data_format = (dst_info->var.nonstd) & 0xff;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)dst_info->par;
-	struct rk_lcdc_driver *ext_dev_drv = fb_par->lcdc_drv;
-	u16 orientation = ext_dev_drv->rotate_mode;
-
-	memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
-
-	switch (orientation) {
-	case 0:
-		rotation = IPP_ROT_0;
-		break;
-	case ROTATE_90:
-		rotation = IPP_ROT_90;
-		break;
-	case ROTATE_180:
-		rotation = IPP_ROT_180;
-		break;
-	case ROTATE_270:
-		rotation = IPP_ROT_270;
-		break;
-	default:
-		rotation = IPP_ROT_270;
-		break;
-	}
-
-	dst_w = dst_info->var.xres;
-	dst_h = dst_info->var.yres;
-	dst_vir_w = dst_info->var.xres_virtual;
-	ipp_fmt = get_ipp_format(data_format);
-	ipp_win_check(&dst_w, &dst_h, &dst_vir_w, rotation, ipp_fmt);
-	ipp_req.src0.YrgbMst = src_info->fix.smem_start + offset;
-	ipp_req.src0.w = src_info->var.xres;
-	ipp_req.src0.h = src_info->var.yres;
-	ipp_req.src_vir_w = src_info->var.xres_virtual;
-	ipp_req.src0.fmt = ipp_fmt;
-
-	ipp_req.dst0.YrgbMst = dst_info->fix.smem_start + offset;
-	ipp_req.dst0.w = dst_w;
-	ipp_req.dst0.h = dst_h;
-	ipp_req.dst_vir_w = dst_vir_w;
-	ipp_req.dst0.fmt = ipp_fmt;
-
-	ipp_req.timeout = 100;
-	ipp_req.flag = rotation;
-	ipp_blit_sync(&ipp_req);
-}
-
-#endif
-
-#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
-static int get_rga_format(int fmt)
-{
-	int rga_fmt = 0;
-
-	switch (fmt) {
-	case XBGR888:
-		rga_fmt = RK_FORMAT_RGBX_8888;
-		break;
-	case ABGR888:
-		rga_fmt = RK_FORMAT_RGBA_8888;
-		break;
-	case ARGB888:
-		rga_fmt = RK_FORMAT_BGRA_8888;
-		break;
-	case RGB888:
-		rga_fmt = RK_FORMAT_RGB_888;
-		break;
-	case RGB565:
-		rga_fmt = RK_FORMAT_RGB_565;
-		break;
-	case YUV422:
-		rga_fmt = RK_FORMAT_YCbCr_422_SP;
-		break;
-	case YUV420:
-		rga_fmt = RK_FORMAT_YCbCr_420_SP;
-		break;
-	default:
-		rga_fmt = RK_FORMAT_RGBA_8888;
-		break;
-	}
-
-	return rga_fmt;
-}
-
-static void rga_win_check(struct rk_lcdc_win *dst_win,
-			  struct rk_lcdc_win *src_win)
-{
-	int format = 0;
-
-	format = get_rga_format(src_win->area[0].format);
-	/* width and height must be even number */
-	if (format >= RK_FORMAT_YCbCr_422_SP &&
-	    format <= RK_FORMAT_YCrCb_420_P) {
-		if ((src_win->area[0].xact % 2) != 0)
-			src_win->area[0].xact += 1;
-		if ((src_win->area[0].yact % 2) != 0)
-			src_win->area[0].yact += 1;
-	}
-	if (src_win->area[0].xvir < src_win->area[0].xact)
-		src_win->area[0].xvir = src_win->area[0].xact;
-	if (src_win->area[0].yvir < src_win->area[0].yact)
-		src_win->area[0].yvir = src_win->area[0].yact;
-
-	format = get_rga_format(dst_win->area[0].format);
-	if (format >= RK_FORMAT_YCbCr_422_SP &&
-	    format <= RK_FORMAT_YCrCb_420_P) {
-		if ((dst_win->area[0].xact % 2) != 0)
-			dst_win->area[0].xact += 1;
-		if ((dst_win->area[0].yact % 2) != 0)
-			dst_win->area[0].yact += 1;
-	}
-	if (dst_win->area[0].xvir < dst_win->area[0].xact)
-		dst_win->area[0].xvir = dst_win->area[0].xact;
-	if (dst_win->area[0].yvir < dst_win->area[0].yact)
-		dst_win->area[0].yvir = dst_win->area[0].yact;
-}
-
-static void win_copy_by_rga(struct rk_lcdc_win *dst_win,
-			    struct rk_lcdc_win *src_win,
-			    u16 orientation, int iommu_en)
-{
-	struct rga_req rga_request;
-	long ret = 0;
-	/* int fd = 0; */
-
-	memset(&rga_request, 0, sizeof(rga_request));
-	rga_win_check(dst_win, src_win);
-
-	switch (orientation) {
-	case ROTATE_90:
-		rga_request.rotate_mode = 1;
-		rga_request.sina = 65536;
-		rga_request.cosa = 0;
-		rga_request.dst.act_w = dst_win->area[0].yact;
-		rga_request.dst.act_h = dst_win->area[0].xact;
-		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
-		rga_request.dst.y_offset = 0;
-		break;
-	case ROTATE_180:
-		rga_request.rotate_mode = 1;
-		rga_request.sina = 0;
-		rga_request.cosa = -65536;
-		rga_request.dst.act_w = dst_win->area[0].xact;
-		rga_request.dst.act_h = dst_win->area[0].yact;
-		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
-		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
-		break;
-	case ROTATE_270:
-		rga_request.rotate_mode = 1;
-		rga_request.sina = -65536;
-		rga_request.cosa = 0;
-		rga_request.dst.act_w = dst_win->area[0].yact;
-		rga_request.dst.act_h = dst_win->area[0].xact;
-		rga_request.dst.x_offset = 0;
-		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
-		break;
-	default:
-		rga_request.rotate_mode = 0;
-		rga_request.dst.act_w = dst_win->area[0].xact;
-		rga_request.dst.act_h = dst_win->area[0].yact;
-		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
-		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
-		break;
-	}
-
-	/*
-	 * fd =
-	 *    ion_share_dma_buf_fd(rk_fb->ion_client, src_win->area[0].ion_hdl);
-	 * rga_request.src.yrgb_addr = fd;
-	 * fd =
-	 *    ion_share_dma_buf_fd(rk_fb->ion_client, dst_win->area[0].ion_hdl);
-	 * rga_request.dst.yrgb_addr = fd;
-	 */
-	rga_request.src.yrgb_addr = 0;
-	rga_request.src.uv_addr =
-	    src_win->area[0].smem_start + src_win->area[0].y_offset;
-	rga_request.src.v_addr = 0;
-
-	rga_request.dst.yrgb_addr = 0;
-	rga_request.dst.uv_addr =
-	    dst_win->area[0].smem_start + dst_win->area[0].y_offset;
-	rga_request.dst.v_addr = 0;
-
-	rga_request.src.vir_w = src_win->area[0].xvir;
-	rga_request.src.vir_h = src_win->area[0].yvir;
-	rga_request.src.format = get_rga_format(src_win->area[0].format);
-	rga_request.src.act_w = src_win->area[0].xact;
-	rga_request.src.act_h = src_win->area[0].yact;
-	rga_request.src.x_offset = 0;
-	rga_request.src.y_offset = 0;
-
-	rga_request.dst.vir_w = dst_win->area[0].xvir;
-	rga_request.dst.vir_h = dst_win->area[0].yvir;
-	rga_request.dst.format = get_rga_format(dst_win->area[0].format);
-
-	rga_request.clip.xmin = 0;
-	rga_request.clip.xmax = dst_win->area[0].xact - 1;
-	rga_request.clip.ymin = 0;
-	rga_request.clip.ymax = dst_win->area[0].yact - 1;
-	rga_request.scale_mode = 0;
-
-	if (iommu_en) {
-		rga_request.mmu_info.mmu_en = 1;
-		rga_request.mmu_info.mmu_flag = 1;
-	} else {
-		rga_request.mmu_info.mmu_en = 0;
-		rga_request.mmu_info.mmu_flag = 0;
-	}
-
-	ret = rga_ioctl_kernel(&rga_request);
-}
-
-/*
- * This function is used for copying fb by RGA Module
- * RGA only support copy RGB to RGB
- * RGA2 support copy RGB to RGB and YUV to YUV
- */
-static void fb_copy_by_rga(struct fb_info *dst_info,
-			   struct fb_info *src_info)
-{
-	struct rk_fb_par *src_fb_par = (struct rk_fb_par *)src_info->par;
-	struct rk_fb_par *dst_fb_par = (struct rk_fb_par *)dst_info->par;
-	struct rk_lcdc_driver *dev_drv = src_fb_par->lcdc_drv;
-	struct rk_lcdc_driver *ext_dev_drv = dst_fb_par->lcdc_drv;
-	int win_id = 0, ext_win_id;
-	struct rk_lcdc_win *src_win, *dst_win;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, src_info->fix.id);
-	src_win = dev_drv->win[win_id];
-
-	ext_win_id =
-	    ext_dev_drv->ops->fb_get_win_id(ext_dev_drv, dst_info->fix.id);
-	dst_win = ext_dev_drv->win[ext_win_id];
-
-	win_copy_by_rga(dst_win, src_win, ext_dev_drv->rotate_mode,
-			ext_dev_drv->iommu_enabled);
-}
-#endif
-
-static int rk_fb_rotate(struct fb_info *dst_info,
-			struct fb_info *src_info)
-{
-#if defined(CONFIG_RK29_IPP)
-	fb_copy_by_ipp(dst_info, src_info);
-#elif defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
-	fb_copy_by_rga(dst_info, src_info);
-#else
-	return -1;
-#endif
-	return 0;
-}
-
-static int __maybe_unused rk_fb_win_rotate(struct rk_lcdc_win *dst_win,
-					   struct rk_lcdc_win *src_win,
-					   u16 rotate, int iommu_en)
-{
-#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
-	win_copy_by_rga(dst_win, src_win, rotate, iommu_en);
-#else
-	return -1;
-#endif
-	return 0;
-}
-
-#endif
-
-static int rk_fb_pan_display(struct fb_var_screeninfo *var,
-			     struct fb_info *info)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct fb_fix_screeninfo *fix = &info->fix;
-	int win_id = 0;
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 xoffset = var->xoffset;
-	u32 yoffset = var->yoffset;
-	u32 xvir = var->xres_virtual;
-	u8 pixel_width;
-	u32 vir_width_bit;
-	u32 stride, uv_stride;
-	u32 stride_32bit_1;
-	u32 stride_32bit_2;
-	u16 uv_x_off, uv_y_off, uv_y_act;
-	u8 is_pic_yuv = 0;
-
-	if (dev_drv->suspend_flag || is_car_camcap())
-		return 0;
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	if (win_id < 0)
-		return -ENODEV;
-	else
-		win = dev_drv->win[win_id];
-
-	pixel_width = rk_fb_pixel_width(win->area[0].format);
-	vir_width_bit = pixel_width * xvir;
-	stride_32bit_1 = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
-	stride_32bit_2 = ALIGN_N_TIMES(vir_width_bit * 2, 32) / 8;
-
-	switch (win->area[0].format) {
-	case YUV422:
-	case YUV422_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset;
-		fix->line_length = stride;
-		uv_y_act = win->area[0].yact >> 1;
-		break;
-	case YUV420:		/* nv12 */
-	case YUV420_NV21:	/* nv21 */
-	case YUV420_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset >> 1;
-		fix->line_length = stride;
-		uv_y_act = win->area[0].yact >> 1;
-		break;
-	case YUV444:
-	case YUV444_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_2;
-		uv_x_off = xoffset * 2;
-		uv_y_off = yoffset;
-		fix->line_length = stride << 2;
-		uv_y_act = win->area[0].yact;
-		break;
-	default:
-		stride = stride_32bit_1;	/* default rgb */
-		fix->line_length = stride;
-		break;
-	}
-
-	/* x y mirror ,jump line */
-	if ((screen->y_mirror == 1) ||
-	    (win->xmirror && win->ymirror)) {
-		if (screen->interlace == 1) {
-			win->area[0].y_offset = yoffset * stride * 2 +
-			    ((win->area[0].yact - 1) * 2 + 1) * stride +
-			    xoffset * pixel_width / 8;
-		} else {
-			win->area[0].y_offset = yoffset * stride +
-			    (win->area[0].yact - 1) * stride +
-			    xoffset * pixel_width / 8;
-		}
-	} else {
-		if (screen->interlace == 1) {
-			win->area[0].y_offset =
-			    yoffset * stride * 2 + xoffset * pixel_width / 8;
-		} else {
-			win->area[0].y_offset =
-			    yoffset * stride + xoffset * pixel_width / 8;
-		}
-	}
-	if (is_pic_yuv == 1) {
-		if ((screen->y_mirror == 1) ||
-		    (win->xmirror && win->ymirror)) {
-			if (screen->interlace == 1) {
-				win->area[0].c_offset =
-				    uv_y_off * uv_stride * 2 +
-				    ((uv_y_act - 1) * 2 + 1) * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			} else {
-				win->area[0].c_offset = uv_y_off * uv_stride +
-				    (uv_y_act - 1) * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			}
-		} else {
-			if (screen->interlace == 1) {
-				win->area[0].c_offset =
-				    uv_y_off * uv_stride * 2 +
-				    uv_x_off * pixel_width / 8;
-			} else {
-				win->area[0].c_offset =
-				    uv_y_off * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			}
-		}
-	}
-
-	win->area[0].smem_start = fix->smem_start;
-	win->area[0].cbr_start = fix->mmio_start;
-	win->area[0].state = 1;
-	win->area_num = 1;
-
-	dev_drv->ops->pan_display(dev_drv, win_id);
-
-#ifdef	CONFIG_FB_MIRRORING
-	if (video_data_to_mirroring)
-		video_data_to_mirroring(info, NULL);
-#endif
-	/* if not want the config effect,set reserved[3] bit[0] 1 */
-	if (likely((var->reserved[3] & 0x1) == 0))
-		dev_drv->ops->cfg_done(dev_drv);
-	if (dev_drv->hdmi_switch)
-		mdelay(100);
-	return 0;
-}
-
-static int rk_fb_get_list_stat(struct rk_lcdc_driver *dev_drv)
-{
-	int i, j;
-
-	i = list_empty(&dev_drv->update_regs_list);
-	j = list_empty(&dev_drv->saved_list);
-	return i == j ? 0 : 1;
-}
-
-void rk_fd_fence_wait(struct rk_lcdc_driver *dev_drv, struct sync_fence *fence)
-{
-	int err = sync_fence_wait(fence, 1000);
-
-	if (err >= 0)
-		return;
-
-	if (err == -ETIME)
-		err = sync_fence_wait(fence, 10 * MSEC_PER_SEC);
-
-	if (err < 0)
-		pr_info("error waiting on fence\n");
-}
-#if 0
-static int rk_fb_copy_from_loader(struct fb_info *info)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	void *dst = info->screen_base;
-	u32 dsp_addr[4];
-	u32 src;
-	u32 i, size;
-	int win_id;
-	struct rk_lcdc_win *win;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	win = dev_drv->win[win_id];
-	size = (win->area[0].xact) * (win->area[0].yact) << 2;
-	dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
-	src = dsp_addr[win_id];
-	dev_info(info->dev, "copy fb data %d x %d  from  dst_addr:%08x\n",
-		 win->area[0].xact, win->area[0].yact, src);
-	for (i = 0; i < size; i += PAGE_SIZE) {
-		void *page = phys_to_page(i + src);
-		void *from_virt = kmap(page);
-		void *to_virt = dst + i;
-
-		memcpy(to_virt, from_virt, PAGE_SIZE);
-	}
-	dev_drv->ops->direct_set_addr(dev_drv, win_id,
-				      info->fix.smem_start);
-	return 0;
-}
-#endif
-static int g_last_addr[5][4];
-static int g_now_config_addr[5][4];
-static int g_last_state[5][4];
-static int g_now_config_state[5][4];
-int g_last_timeout;
-u32 freed_addr[10];
-u32 freed_index;
-
-#define DUMP_CHUNK 256
-char buf[PAGE_SIZE];
-
-int rk_fb_sysmmu_fault_handler(struct device *dev,
-			       enum rk_iommu_inttype itype,
-			       unsigned long pgtable_base,
-			       unsigned long fault_addr, unsigned int status)
-{
-	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
-	int i = 0, j = 0;
-	static int page_fault_cnt;
-
-	if ((page_fault_cnt++) >= 10)
-		return 0;
-	pr_err
-	    ("PAGE FAULT occurred at 0x%lx (Page table base: 0x%lx),status=%d\n",
-	     fault_addr, pgtable_base, status);
-	pr_info("last config addr:\n");
-	for (i = 0; i < 4; i++) {
-		for (j = 0; j < 4; j++)
-			pr_info("win[%d],area[%d] = 0x%08x\n",
-				i, j, g_last_addr[i][j]);
-	}
-	pr_info("last freed buffer:\n");
-	for (i = 0; (freed_addr[i] != 0xfefefefe) && freed_addr[i]; i++)
-		pr_info("%d:0x%08x\n", i, freed_addr[i]);
-	pr_info("last timeout:%d\n", g_last_timeout);
-	dev_drv->ops->get_disp_info(dev_drv, buf, 0);
-	for (i = 0; i < PAGE_SIZE; i += DUMP_CHUNK) {
-		if ((PAGE_SIZE - i) > DUMP_CHUNK) {
-			char c = buf[i + DUMP_CHUNK];
-
-			buf[i + DUMP_CHUNK] = 0;
-			pr_cont("%s", buf + i);
-			buf[i + DUMP_CHUNK] = c;
-		} else {
-			buf[PAGE_SIZE - 1] = 0;
-			pr_cont("%s", buf + i);
-		}
-	}
-
-	return 0;
-}
-
-void rk_fb_free_wb_buf(struct rk_lcdc_driver *dev_drv,
-		       struct rk_fb_reg_wb_data *wb_data)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-
-	if (dev_drv->iommu_enabled && wb_data->ion_handle)
-		ion_unmap_iommu(dev_drv->dev, rk_fb->ion_client,
-				wb_data->ion_handle);
-	if (wb_data->ion_handle)
-		ion_free(rk_fb->ion_client, wb_data->ion_handle);
-}
-
-void rk_fb_free_dma_buf(struct rk_lcdc_driver *dev_drv,
-			struct rk_fb_reg_win_data *reg_win_data)
-{
-	int i, index_buf;
-	struct rk_fb_reg_area_data *area_data;
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-
-	for (i = 0; i < reg_win_data->area_num; i++) {
-		area_data = &reg_win_data->reg_area_data[i];
-		index_buf = area_data->index_buf;
-		if (dev_drv->iommu_enabled) {
-			if (area_data->ion_handle != NULL &&
-			    !IS_YUV_FMT(area_data->data_format))
-				ion_unmap_iommu(dev_drv->dev, rk_fb->ion_client,
-						area_data->ion_handle);
-			freed_addr[freed_index++] = area_data->smem_start;
-		}
-		if (area_data->ion_handle != NULL)
-			ion_free(rk_fb->ion_client, area_data->ion_handle);
-
-		if (area_data->acq_fence)
-			sync_fence_put(area_data->acq_fence);
-	}
-}
-
-static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
-			     struct rk_lcdc_win *win,
-			     struct rk_fb_reg_win_data *reg_win_data)
-{
-	int i = 0;
-	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
-	struct rk_screen *cur_screen;
-	struct rk_screen primary_screen;
-
-	if (unlikely(!inf) || unlikely(!dev_drv) ||
-	    unlikely(!win) || unlikely(!reg_win_data))
-		return;
-
-	cur_screen = dev_drv->cur_screen;
-	rk_fb_get_prmry_screen(&primary_screen);
-
-	win->area_num = reg_win_data->area_num;
-	win->id = reg_win_data->win_id;
-	win->z_order = reg_win_data->z_order;
-
-	if (reg_win_data->reg_area_data[0].smem_start > 0) {
-		win->state = 1;
-		win->area_num = reg_win_data->area_num;
-		win->id = reg_win_data->win_id;
-		win->z_order = reg_win_data->z_order;
-		win->area[0].uv_vir_stride =
-		    reg_win_data->reg_area_data[0].uv_vir_stride;
-		win->area[0].cbr_start =
-		    reg_win_data->reg_area_data[0].cbr_start;
-		win->area[0].c_offset = reg_win_data->reg_area_data[0].c_offset;
-		win->alpha_en = reg_win_data->alpha_en;
-		win->alpha_mode = reg_win_data->alpha_mode;
-		win->g_alpha_val = reg_win_data->g_alpha_val;
-		/*
-		 * reg_win_data mirror_en means that xmirror ymirror all
-		 * enabled.
-		 */
-		win->xmirror = reg_win_data->mirror_en ? 1 : 0;
-		win->ymirror = reg_win_data->mirror_en ? 1 : 0;
-		win->colorspace = reg_win_data->colorspace;
-		win->area[0].fbdc_en =
-			reg_win_data->reg_area_data[0].fbdc_en;
-		win->area[0].fbdc_cor_en =
-			reg_win_data->reg_area_data[0].fbdc_cor_en;
-		win->area[0].fbdc_data_format =
-			reg_win_data->reg_area_data[0].fbdc_data_format;
-		for (i = 0; i < RK_WIN_MAX_AREA; i++) {
-			if (reg_win_data->reg_area_data[i].smem_start > 0) {
-				win->area[i].format =
-					reg_win_data->reg_area_data[i].data_format;
-				win->area[i].data_space =
-					reg_win_data->reg_area_data[i].data_space;
-				win->area[i].ion_hdl =
-					reg_win_data->reg_area_data[i].ion_handle;
-				win->area[i].smem_start =
-					reg_win_data->reg_area_data[i].smem_start;
-				if (inf->disp_mode == DUAL ||
-				    inf->disp_mode == DUAL_LCD ||
-				    inf->disp_mode == NO_DUAL) {
-					win->area[i].xpos =
-						reg_win_data->reg_area_data[i].xpos;
-					win->area[i].ypos =
-						reg_win_data->reg_area_data[i].ypos;
-					win->area[i].xsize =
-						reg_win_data->reg_area_data[i].xsize;
-					win->area[i].ysize =
-						reg_win_data->reg_area_data[i].ysize;
-				} else {
-					win->area[i].xpos =
-						reg_win_data->reg_area_data[i].xpos *
-						cur_screen->mode.xres /
-						primary_screen.mode.xres;
-					win->area[i].ypos =
-						reg_win_data->reg_area_data[i].ypos *
-						cur_screen->mode.yres /
-						primary_screen.mode.yres;
-					win->area[i].xsize =
-						reg_win_data->reg_area_data[i].xsize *
-						cur_screen->mode.xres /
-						primary_screen.mode.xres;
-					win->area[i].ysize =
-						reg_win_data->reg_area_data[i].ysize *
-						cur_screen->mode.yres /
-						primary_screen.mode.yres;
-
-					/* recalc display size if set hdmi scaler when at ONE_DUAL mode */
-					if (inf->disp_mode == ONE_DUAL && hdmi_switch_state) {
-						if (cur_screen->xsize > 0 &&
-						    cur_screen->xsize <= cur_screen->mode.xres) {
-							win->area[i].xpos =
-								((cur_screen->mode.xres - cur_screen->xsize) >> 1) +
-								cur_screen->xsize * win->area[i].xpos / cur_screen->mode.xres;
-							win->area[i].xsize =
-								win->area[i].xsize * cur_screen->xsize / cur_screen->mode.xres;
-						}
-						if (cur_screen->ysize > 0 && cur_screen->ysize <= cur_screen->mode.yres) {
-							win->area[i].ypos =
-								((cur_screen->mode.yres - cur_screen->ysize) >> 1) +
-								cur_screen->ysize * win->area[i].ypos / cur_screen->mode.yres;
-							win->area[i].ysize =
-								win->area[i].ysize * cur_screen->ysize / cur_screen->mode.yres;
-						}
-					}
-				}
-				win->area[i].xact =
-				    reg_win_data->reg_area_data[i].xact;
-				win->area[i].yact =
-				    reg_win_data->reg_area_data[i].yact;
-				win->area[i].xvir =
-				    reg_win_data->reg_area_data[i].xvir;
-				win->area[i].yvir =
-				    reg_win_data->reg_area_data[i].yvir;
-				win->area[i].xoff =
-				    reg_win_data->reg_area_data[i].xoff;
-				win->area[i].yoff =
-				    reg_win_data->reg_area_data[i].yoff;
-				win->area[i].y_offset =
-				    reg_win_data->reg_area_data[i].y_offset;
-				win->area[i].y_vir_stride =
-				    reg_win_data->reg_area_data[i].y_vir_stride;
-				win->area[i].state = 1;
-				if (dev_drv->iommu_enabled) {
-					g_now_config_addr[win->id][i] =
-						win->area[i].smem_start +
-						win->area[i].y_offset;
-					g_now_config_state[win->id][i] = 1;
-				}
-			} else {
-				win->area[i].state = 0;
-				win->area[i].fbdc_en = 0;
-				if (dev_drv->iommu_enabled) {
-					g_now_config_addr[win->id][i] = 0;
-					g_now_config_state[win->id][i] = 0;
-				}
-			}
-		}
-	}
-}
-
-static struct rk_fb_reg_win_data *rk_fb_get_win_data(struct rk_fb_reg_data
-						     *regs, int win_id)
-{
-	int i;
-	struct rk_fb_reg_win_data *win_data = NULL;
-
-	for (i = 0; i < regs->win_num; i++) {
-		if (regs->reg_win_data[i].win_id == win_id) {
-			win_data = &(regs->reg_win_data[i]);
-			break;
-		}
-	}
-
-	return win_data;
-}
-
-static int rk_fb_reg_effect(struct rk_lcdc_driver *dev_drv,
-			    struct rk_fb_reg_data *regs,
-			    int count)
-{
-	int i, j, wait_for_vsync = false;
-	unsigned int dsp_addr[5][4];
-	int win_status = 0;
-
-	if (dev_drv->ops->get_dsp_addr)
-		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			if ((j > 0) && (dev_drv->area_support[i] == 1))
-				continue;
-			if (dev_drv->win[i]->area[j].state == 1) {
-				u32 new_start =
-					dev_drv->win[i]->area[j].smem_start +
-					dev_drv->win[i]->area[j].y_offset;
-				u32 reg_start = dsp_addr[i][j];
-
-				if (unlikely(new_start != reg_start)) {
-					wait_for_vsync = true;
-					dev_info(dev_drv->dev,
-						 "win%d:new_addr:0x%08x cur_addr:0x%08x--%d\n",
-						 i, new_start, reg_start,
-						 101 - count);
-					break;
-				}
-			} else if (dev_drv->win[i]->area[j].state == 0) {
-				if (dev_drv->ops->get_win_state) {
-					win_status =
-					dev_drv->ops->get_win_state(dev_drv, i, j);
-					if (win_status) {
-						wait_for_vsync = true;
-						dev_info(dev_drv->dev,
-							 "win[%d]area[%d]: "
-							 "state: %d, "
-							 "cur state: %d,"
-							 "count: %d\n",
-							 i, j,
-							 dev_drv->win[i]->area[j].state,
-							 win_status,
-							 101 - count);
-					}
-				}
-			} else {
-				pr_err("!!!win[%d]state:%d,error!!!\n",
-				       i, dev_drv->win[i]->state);
-			}
-		}
-	}
-
-	return wait_for_vsync;
-}
-
-static int rk_fb_iommu_page_fault_dump(struct rk_lcdc_driver *dev_drv)
-{
-	int i, j, state, page_fault = 0;
-	unsigned int dsp_addr[5][4];
-
-	if (dev_drv->ops->extern_func) {
-		dev_drv->ops->extern_func(dev_drv, UNMASK_PAGE_FAULT);
-		page_fault = dev_drv->ops->extern_func(dev_drv, GET_PAGE_FAULT);
-	}
-	if (page_fault) {
-		pr_info("last config:\n");
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-				if ((j > 0) && (dev_drv->area_support[i] == 1))
-					continue;
-				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
-					i, j, g_last_state[i][j], g_last_addr[i][j]);
-			}
-		}
-
-		pr_info("last freed buffer:\n");
-		for (i = 0; (freed_addr[i] != 0xfefefefe) && freed_addr[i]; i++)
-			pr_info("%d:0x%08x\n", i, freed_addr[i]);
-
-		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
-		pr_info("vop now state:\n");
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-				if ((j > 0) && (dev_drv->area_support[i] == 1))
-					continue;
-				state = dev_drv->ops->get_win_state(dev_drv, i, j);
-				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
-					i, j, state, dsp_addr[i][j]);
-			}
-		}
-		pr_info("now config:\n");
-		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-				if ((j > 0) && (dev_drv->area_support[i] == 1))
-					continue;
-				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
-					i, j, g_now_config_state[i][j],
-					g_now_config_addr[i][j]);
-			}
-		}
-		for (i = 0; i < DUMP_FRAME_NUM; i++)
-			rk_fb_config_debug(dev_drv, &dev_drv->tmp_win_cfg[i],
-					   &dev_drv->tmp_regs[i], 0);
-	}
-
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			if ((j > 0) && (dev_drv->area_support[i] == 1))
-				continue;
-			g_last_addr[i][j] = g_now_config_addr[i][j];
-			g_last_state[i][j] = g_now_config_state[i][j];
-		}
-	}
-
-	return page_fault;
-}
-static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
-			     struct rk_fb_reg_data *regs)
-{
-	int i, j;
-	struct rk_lcdc_win *win;
-	ktime_t timestamp = dev_drv->vsync_info.timestamp;
-	struct rk_fb_reg_win_data *win_data;
-	bool wait_for_vsync;
-	int count = 100;
-	long timeout;
-	int pagefault = 0;
-
-	if (dev_drv->suspend_flag == 1) {
-#ifdef H_USE_FENCE
-		sw_sync_timeline_inc(dev_drv->timeline, 1);
-#endif
-		for (i = 0; i < regs->win_num; i++) {
-			win_data = &regs->reg_win_data[i];
-			rk_fb_free_dma_buf(dev_drv, win_data);
-		}
-		if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
-			rk_fb_free_wb_buf(dev_drv, &regs->reg_wb_data);
-		kfree(regs);
-		return;
-	}
-	/* acq_fence wait */
-	for (i = 0; i < regs->win_num; i++) {
-		win_data = &regs->reg_win_data[i];
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			if (win_data->reg_area_data[j].acq_fence)
-				rk_fd_fence_wait(dev_drv, win_data->reg_area_data[j].acq_fence);
-		}
-	}
-
-	mutex_lock(&dev_drv->win_config);
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win = dev_drv->win[i];
-		win_data = rk_fb_get_win_data(regs, i);
-		if (win_data) {
-			rk_fb_update_win(dev_drv, win, win_data);
-			win->state = 1;
-			dev_drv->ops->set_par(dev_drv, i);
-			dev_drv->ops->pan_display(dev_drv, i);
-		} else {
-			win->z_order = -1;
-			win->state = 0;
-			for (j = 0; j < 4; j++) {
-				win->area[j].state = 0;
-				win->area[j].fbdc_en = 0;
-			}
-			if (dev_drv->iommu_enabled) {
-				for (j = 0; j < 4; j++) {
-					g_now_config_addr[i][j] = 0;
-					g_now_config_state[i][j] = 0;
-				}
-			}
-		}
-	}
-	dev_drv->ops->ovl_mgr(dev_drv, 0, 1);
-
-	if (dev_drv->property.feature & SUPPORT_WRITE_BACK) {
-		memcpy(&dev_drv->wb_data, &regs->reg_wb_data,
-		       sizeof(struct rk_fb_reg_wb_data));
-		if (dev_drv->ops->set_wb)
-			dev_drv->ops->set_wb(dev_drv);
-	}
-
-	if (rk_fb_iommu_debug > 0)
-		pagefault = rk_fb_iommu_page_fault_dump(dev_drv);
-
-	if (pagefault == 0)
-		dev_drv->ops->cfg_done(dev_drv);
-	else
-		sw_sync_timeline_inc(dev_drv->timeline, 1);
-	mutex_unlock(&dev_drv->win_config);
-
-	do {
-		timestamp = dev_drv->vsync_info.timestamp;
-		timeout = wait_event_interruptible_timeout(dev_drv->vsync_info.wait,
-				ktime_compare(dev_drv->vsync_info.timestamp, timestamp) > 0,
-				msecs_to_jiffies(50));
-		if (timeout <= 0)
-			dev_info(dev_drv->dev, "timeout: %ld\n", timeout);
-		wait_for_vsync = rk_fb_reg_effect(dev_drv, regs, count);
-	} while (wait_for_vsync && count--);
-#ifdef H_USE_FENCE
-	sw_sync_timeline_inc(dev_drv->timeline, 1);
-#endif
-
-	if (dev_drv->front_regs) {
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->ops->mmu_en)
-				dev_drv->ops->mmu_en(dev_drv);
-			freed_index = 0;
-			g_last_timeout = timeout;
-		}
-
-		mutex_lock(&dev_drv->front_lock);
-
-		for (i = 0; i < dev_drv->front_regs->win_num; i++) {
-			win_data = &dev_drv->front_regs->reg_win_data[i];
-			rk_fb_free_dma_buf(dev_drv, win_data);
-		}
-		if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
-			rk_fb_free_wb_buf(dev_drv,
-					  &dev_drv->front_regs->reg_wb_data);
-		kfree(dev_drv->front_regs);
-
-		mutex_unlock(&dev_drv->front_lock);
-
-		if (dev_drv->iommu_enabled)
-			freed_addr[freed_index] = 0xfefefefe;
-	}
-
-	mutex_lock(&dev_drv->front_lock);
-
-	dev_drv->front_regs = regs;
-
-	mutex_unlock(&dev_drv->front_lock);
-
-	trace_buffer_dump(&fb_pdev->dev, dev_drv);
-}
-
-static void rk_fb_update_regs_handler(struct kthread_work *work)
-{
-	struct rk_lcdc_driver *dev_drv =
-	    container_of(work, struct rk_lcdc_driver, update_regs_work);
-	struct rk_fb_reg_data *data, *next;
-
-	mutex_lock(&dev_drv->update_regs_list_lock);
-	dev_drv->saved_list = dev_drv->update_regs_list;
-	list_replace_init(&dev_drv->update_regs_list, &dev_drv->saved_list);
-	mutex_unlock(&dev_drv->update_regs_list_lock);
-
-	list_for_each_entry_safe(data, next, &dev_drv->saved_list, list) {
-		list_del(&data->list);
-		rk_fb_update_reg(dev_drv, data);
-	}
-
-	if (dev_drv->wait_fs && list_empty(&dev_drv->update_regs_list))
-		wake_up(&dev_drv->update_regs_wait);
-}
-
-static int rk_fb_check_config_var(struct rk_fb_area_par *area_par,
-				  struct rk_screen *screen)
-{
-	if (area_par->phy_addr > 0)
-		pr_err("%s[%d], phy_addr = 0x%x\n",
-		       __func__, __LINE__, area_par->phy_addr);
-	if ((area_par->x_offset + area_par->xact > area_par->xvir) ||
-	    (area_par->xact <= 0) || (area_par->yact <= 0) ||
-	    (area_par->xvir <= 0) || (area_par->yvir <= 0)) {
-		pr_err("check config var fail 0:\n"
-		       "x_offset=%d,xact=%d,xvir=%d\n",
-		       area_par->x_offset, area_par->xact, area_par->xvir);
-		return -EINVAL;
-	}
-
-	if ((area_par->xpos >= screen->mode.xres) ||
-	    (area_par->ypos >= screen->mode.yres) ||
-	    ((area_par->xsize <= 0) || (area_par->ysize <= 0))) {
-		pr_warn("check config var fail 1:\n"
-			"xpos=%d,xsize=%d,xres=%d\n"
-			"ypos=%d,ysize=%d,yres=%d\n",
-			area_par->xpos, area_par->xsize, screen->mode.xres,
-			area_par->ypos, area_par->ysize, screen->mode.yres);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
-			      struct rk_fb_win_cfg_data *win_data,
-			      struct rk_fb_reg_data *regs, u32 cmd)
-{
-	int i, j;
-	struct rk_fb_win_par *win_par;
-	struct rk_fb_area_par *area_par;
-	struct rk_fb_reg_win_data *reg_win_data;
-	struct rk_fb_reg_area_data *area_data;
-
-	rk_fb_dbg(cmd, "-------------frame start-------------\n");
-	rk_fb_dbg(cmd, "user config:\n");
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		win_par = &(win_data->win_par[i]);
-		if ((win_par->area_par[0].ion_fd <= 0) &&
-		    (win_par->area_par[0].phy_addr <= 0))
-			continue;
-		rk_fb_dbg(cmd, "win[%d]:z_order=%d,galhpa_v=%d\n",
-			  win_par->win_id, win_par->z_order,
-			  win_par->g_alpha_val);
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			area_par = &(win_par->area_par[j]);
-			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
-			    ((win_par->area_par[j].ion_fd <= 0) &&
-			     (win_par->area_par[j].phy_addr <= 0)))
-				continue;
-			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion_fd=%d,phy_add=0x%x,xoff=%d,yoff=%d\n",
-				  j, area_par->data_format, area_par->ion_fd,
-				  area_par->phy_addr, area_par->x_offset,
-				  area_par->y_offset);
-			rk_fb_dbg(cmd, "	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
-				  area_par->xpos, area_par->ypos,
-				  area_par->xsize, area_par->ysize);
-			rk_fb_dbg(cmd, "	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
-				  area_par->xact, area_par->yact,
-				  area_par->xvir, area_par->yvir);
-			rk_fb_dbg(cmd, "	   data_space%d\n",
-				  area_par->data_space);
-		}
-	}
-
-	rk_fb_dbg(cmd, "regs data:\n");
-	rk_fb_dbg(cmd, "win_num=%d,buf_num=%d\n",
-		  regs->win_num, regs->buf_num);
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		reg_win_data = &(regs->reg_win_data[i]);
-		if (reg_win_data->reg_area_data[0].smem_start <= 0)
-			continue;
-		rk_fb_dbg(cmd, "win[%d]:z_order=%d,area_num=%d,area_buf_num=%d\n",
-			  reg_win_data->win_id, reg_win_data->z_order,
-			  reg_win_data->area_num, reg_win_data->area_buf_num);
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			area_data = &(reg_win_data->reg_area_data[j]);
-			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
-			    (area_data->smem_start <= 0))
-				continue;
-			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion=%p,smem_star=0x%lx,cbr_star=0x%lx\n",
-				  j, area_data->data_format, area_data->ion_handle,
-				  area_data->smem_start, area_data->cbr_start);
-			rk_fb_dbg(cmd, "	   yoff=0x%x,coff=0x%x,area_data->buff_len=%x\n",
-				  area_data->y_offset, area_data->c_offset, area_data->buff_len);
-			rk_fb_dbg(cmd, "	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
-				  area_data->xpos, area_data->ypos,
-				  area_data->xsize, area_data->ysize);
-			rk_fb_dbg(cmd, "	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
-				  area_data->xact, area_data->yact,
-				  area_data->xvir, area_data->yvir);
-		}
-	}
-	rk_fb_dbg(cmd, "-------------frame end---------------\n");
-
-	return 0;
-}
-static int rk_fb_config_backup(struct rk_lcdc_driver *dev_drv,
-			       struct rk_fb_win_cfg_data *win_cfg,
-			       struct rk_fb_reg_data *regs)
-{
-	int i;
-
-	/*2->1->0: 0 is newest*/
-	for (i = 0; i < DUMP_FRAME_NUM - 1; i++) {
-		memcpy(&dev_drv->tmp_win_cfg[DUMP_FRAME_NUM - 1 - i],
-		       &dev_drv->tmp_win_cfg[DUMP_FRAME_NUM - 2 - i],
-		       sizeof(struct rk_fb_win_cfg_data));
-		memcpy(&dev_drv->tmp_regs[DUMP_FRAME_NUM - 1 - i],
-		       &dev_drv->tmp_regs[DUMP_FRAME_NUM - 2 - i],
-		       sizeof(struct rk_fb_reg_data));
-	}
-
-	memcpy(&dev_drv->tmp_win_cfg[0], win_cfg,
-	       sizeof(struct rk_fb_win_cfg_data));
-	memcpy(&dev_drv->tmp_regs[0], regs,
-	       sizeof(struct rk_fb_reg_data));
-
-	return 0;
-}
-
-static int rk_fb_set_wb_buffer(struct fb_info *info,
-			       struct rk_fb_wb_cfg *wb_cfg,
-			       struct rk_fb_reg_wb_data *wb_data)
-{
-	int ret = 0;
-	ion_phys_addr_t phy_addr;
-	size_t len;
-	u8 fb_data_fmt;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
-
-	if ((wb_cfg->phy_addr == 0) && (wb_cfg->ion_fd == 0)) {
-		wb_data->state = 0;
-		return 0;
-	}
-	if (wb_cfg->phy_addr == 0) {
-		wb_data->ion_handle =
-		    ion_import_dma_buf(rk_fb->ion_client,
-				       wb_cfg->ion_fd);
-		if (IS_ERR(wb_data->ion_handle)) {
-			pr_info("Could not import handle: %ld\n",
-				(long)wb_data->ion_handle);
-			return -EINVAL;
-		}
-		if (dev_drv->iommu_enabled)
-			ret = ion_map_iommu(dev_drv->dev,
-					    rk_fb->ion_client,
-					    wb_data->ion_handle,
-					    (unsigned long *)&phy_addr,
-					    (unsigned long *)&len);
-		else
-			ret = ion_phys(rk_fb->ion_client, wb_data->ion_handle,
-				       &phy_addr, &len);
-		if (ret < 0) {
-			pr_err("ion map to get phy addr failed\n");
-			ion_free(rk_fb->ion_client, wb_data->ion_handle);
-			return -ENOMEM;
-		}
-		wb_data->smem_start = phy_addr;
-	} else {
-		wb_data->smem_start = wb_cfg->phy_addr;
-	}
-
-	fb_data_fmt = rk_fb_data_fmt(wb_cfg->data_format, 0);
-	if (IS_YUV_FMT(fb_data_fmt))
-		wb_data->cbr_start = wb_data->smem_start +
-					wb_cfg->xsize * wb_cfg->ysize;
-	wb_data->xsize = wb_cfg->xsize;
-	wb_data->ysize = wb_cfg->ysize;
-	wb_data->data_format = fb_data_fmt;
-	wb_data->state = 1;
-
-	return 0;
-}
-
-static int rk_fb_set_win_buffer(struct fb_info *info,
-				struct rk_fb_win_par *win_par,
-				struct rk_fb_reg_win_data *reg_win_data)
-{
-	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
-	struct fb_fix_screeninfo *fix = &info->fix;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	/*if hdmi size move to hwc,screen should point to cur_screen
-	 *otherwise point to screen0[main screen]*/
-	struct rk_screen *screen = dev_drv->cur_screen;/*screen0;*/
-	struct fb_info *fbi;
-	int i, ion_fd, acq_fence_fd;
-	u32 xvir = 0, yvir = 0;
-	u32 xoffset = 0, yoffset = 0;
-
-	struct ion_handle *hdl;
-	size_t len;
-	int index_buf = 0;
-	u8 fb_data_fmt = 0;
-	u8 pixel_width = 0;
-	u32 vir_width_bit = 0;
-	u32 stride = 0, uv_stride = 0;
-	u32 stride_32bit_1 = 0;
-	u32 stride_32bit_2 = 0;
-	u16 uv_x_off = 0, uv_y_off = 0, uv_y_act = 0;
-	u8 is_pic_yuv = 0;
-	u8 ppixel_a = 0, global_a = 0;
-	ion_phys_addr_t phy_addr;
-	int ret = 0;
-	int buff_len = 0;
-
-	reg_win_data->reg_area_data[0].smem_start = -1;
-	reg_win_data->area_num = 0;
-	fbi = rk_fb->fb[win_par->win_id + dev_drv->fb_index_base];
-	if (win_par->area_par[0].phy_addr == 0) {
-		for (i = 0; i < RK_WIN_MAX_AREA; i++) {
-			ion_fd = win_par->area_par[i].ion_fd;
-			if (ion_fd > 0) {
-				hdl =
-				    ion_import_dma_buf(rk_fb->ion_client,
-						       ion_fd);
-				if (IS_ERR(hdl)) {
-					pr_info("%s: win[%d]area[%d] can't import handle\n",
-						__func__, win_par->win_id, i);
-					pr_info("fd: %d, hdl: 0x%p, ion_client: 0x%p\n",
-						ion_fd, hdl, rk_fb->ion_client);
-					return -EINVAL;
-					break;
-				}
-				reg_win_data->reg_area_data[i].ion_handle = hdl;
-				if (dev_drv->iommu_enabled)
-					ret = ion_map_iommu(dev_drv->dev,
-							    rk_fb->ion_client,
-							    hdl,
-							    (unsigned long *)&phy_addr,
-							    (unsigned long *)&len);
-				else
-					ret = ion_phys(rk_fb->ion_client, hdl,
-						       &phy_addr, &len);
-				if (ret < 0) {
-					dev_err(fbi->dev, "ion map to get phy addr failed\n");
-					ion_free(rk_fb->ion_client, hdl);
-					return -ENOMEM;
-				}
-				reg_win_data->reg_area_data[i].smem_start = phy_addr;
-				reg_win_data->area_num++;
-				reg_win_data->area_buf_num++;
-				reg_win_data->reg_area_data[i].index_buf = 1;
-				reg_win_data->reg_area_data[i].buff_len = len;
-			}
-		}
-	} else {
-		reg_win_data->reg_area_data[0].smem_start =
-		    win_par->area_par[0].phy_addr;
-		reg_win_data->area_num = 1;
-		reg_win_data->area_buf_num++;
-		fbi->screen_base = phys_to_virt(win_par->area_par[0].phy_addr);
-	}
-
-	if (reg_win_data->area_num == 0) {
-		for (i = 0; i < RK_WIN_MAX_AREA; i++)
-			reg_win_data->reg_area_data[i].smem_start = 0;
-		reg_win_data->z_order = -1;
-		reg_win_data->win_id = -1;
-		return 0;
-	}
-
-	for (i = 0; i < reg_win_data->area_num; i++) {
-		acq_fence_fd = win_par->area_par[i].acq_fence_fd;
-		index_buf = reg_win_data->reg_area_data[i].index_buf;
-		if ((acq_fence_fd > 0) && (index_buf == 1)) {
-			reg_win_data->reg_area_data[i].acq_fence =
-			    sync_fence_fdget(win_par->area_par[i].acq_fence_fd);
-		}
-	}
-	if (reg_win_data->reg_area_data[0].smem_start > 0) {
-		reg_win_data->z_order = win_par->z_order;
-		reg_win_data->win_id = win_par->win_id;
-	} else {
-		reg_win_data->z_order = -1;
-		reg_win_data->win_id = -1;
-	}
-
-	reg_win_data->mirror_en = win_par->mirror_en;
-	for (i = 0; i < reg_win_data->area_num; i++) {
-		u8 data_format = win_par->area_par[i].data_format;
-		/*rk_fb_check_config_var(&win_par->area_par[i], screen);*/
-		reg_win_data->colorspace = CSC_FORMAT(data_format);
-		data_format &= ~CSC_MASK;
-		fb_data_fmt = rk_fb_data_fmt(data_format, 0);
-		reg_win_data->reg_area_data[i].data_format = fb_data_fmt;
-		reg_win_data->reg_area_data[i].data_space =
-					win_par->area_par[i].data_space;
-		if (IS_FBDC_FMT(fb_data_fmt)) {
-			reg_win_data->reg_area_data[i].fbdc_en = 1;
-			reg_win_data->reg_area_data[i].fbdc_cor_en = 1;
-		} else {
-			reg_win_data->reg_area_data[i].fbdc_en = 0;
-			reg_win_data->reg_area_data[i].fbdc_cor_en = 0;
-		}
-		pixel_width = rk_fb_pixel_width(fb_data_fmt);
-
-		ppixel_a |= ((fb_data_fmt == ARGB888) ||
-			     (fb_data_fmt == FBDC_ARGB_888) ||
-			     (fb_data_fmt == FBDC_ABGR_888) ||
-			     (fb_data_fmt == ABGR888)) ? 1 : 0;
-		/*act_height should be 2 pix align for interlace output*/
-		if (win_par->area_par[i].yact % 2 == 1) {
-			win_par->area_par[i].yact  -= 1;
-			win_par->area_par[i].ysize -= 1;
-		}
-
-		/* buf offset should be 2 pix align*/
-		if ((win_par->area_par[i].x_offset % 2 == 1) &&
-		    IS_YUV_FMT(fb_data_fmt)) {
-			win_par->area_par[i].x_offset += 1;
-			win_par->area_par[i].xact -= 1;
-		}
-
-		/* visiable pos in panel */
-		reg_win_data->reg_area_data[i].xpos = win_par->area_par[i].xpos;
-		reg_win_data->reg_area_data[i].ypos = win_par->area_par[i].ypos;
-
-		/* realy size in panel */
-		reg_win_data->reg_area_data[i].xsize = win_par->area_par[i].xsize;
-		reg_win_data->reg_area_data[i].ysize = win_par->area_par[i].ysize;
-
-		/* realy size in panel */
-		reg_win_data->reg_area_data[i].xact = win_par->area_par[i].xact;
-		reg_win_data->reg_area_data[i].yact = win_par->area_par[i].yact;
-
-		xoffset = win_par->area_par[i].x_offset;	/* buf offset */
-		yoffset = win_par->area_par[i].y_offset;
-		reg_win_data->reg_area_data[i].xoff = xoffset;
-		reg_win_data->reg_area_data[i].yoff = yoffset;
-
-		xvir = win_par->area_par[i].xvir;
-		reg_win_data->reg_area_data[i].xvir = xvir;
-		yvir = win_par->area_par[i].yvir;
-		reg_win_data->reg_area_data[i].yvir = yvir;
-
-		vir_width_bit = pixel_width * xvir;
-		/* pixel_width = byte_num*8 */
-		stride_32bit_1 = ((vir_width_bit + 31) & (~31)) / 8;
-		stride_32bit_2 = ((vir_width_bit * 2 + 31) & (~31)) / 8;
-
-		stride = stride_32bit_1;	/* default rgb */
-		fix->line_length = stride;
-		reg_win_data->reg_area_data[i].y_vir_stride = stride >> 2;
-
-		/* x y mirror ,jump line
-		 * reg_win_data->reg_area_data[i].y_offset =
-		 *		yoffset*stride+xoffset*pixel_width/8;
-		 */
-		if (screen->y_mirror || reg_win_data->mirror_en) {
-			if (screen->interlace == 1) {
-				reg_win_data->reg_area_data[i].y_offset =
-				    yoffset * stride * 2 +
-				    ((reg_win_data->reg_area_data[i].yact - 1) * 2 + 1) * stride +
-				    xoffset * pixel_width / 8;
-			} else {
-				reg_win_data->reg_area_data[i].y_offset =
-				    yoffset * stride +
-				    (reg_win_data->reg_area_data[i].yact - 1) * stride +
-				    xoffset * pixel_width / 8;
-			}
-		} else {
-			if (screen->interlace == 1) {
-				reg_win_data->reg_area_data[i].y_offset =
-				    yoffset * stride * 2 +
-				    xoffset * pixel_width / 8;
-			} else {
-				reg_win_data->reg_area_data[i].y_offset =
-				    yoffset * stride +
-				    xoffset * pixel_width / 8;
-			}
-		}
-		if (IS_RGB_FMT(fb_data_fmt) && dev_drv->iommu_enabled) {
-			buff_len = yoffset * stride +
-				xoffset * pixel_width / 8 +
-				reg_win_data->reg_area_data[i].xvir *
-				reg_win_data->reg_area_data[i].yact *
-				pixel_width / 8 -
-				reg_win_data->reg_area_data[i].xoff*
-				pixel_width / 8;
-			if (buff_len > reg_win_data->reg_area_data[i].buff_len)
-				pr_err("\n!!!!!!error: fmt=%d,xvir[%d]*"
-				       "yact[%d]*bpp[%d]"
-				       "=buff_len[0x%x]>>mmu len=0x%x\n",
-				       fb_data_fmt,
-				       reg_win_data->reg_area_data[i].xvir,
-				       reg_win_data->reg_area_data[i].yact,
-				       pixel_width, buff_len,
-				       reg_win_data->reg_area_data[i].buff_len);
-		}
-	}
-
-	global_a = (win_par->g_alpha_val == 0) ? 0 : 1;
-	reg_win_data->alpha_en = ppixel_a | global_a;
-	reg_win_data->g_alpha_val = win_par->g_alpha_val;
-	reg_win_data->alpha_mode = win_par->alpha_mode;
-
-	switch (fb_data_fmt) {
-	case YUV422:
-	case YUV422_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset;
-		fix->line_length = stride;
-		uv_y_act = win_par->area_par[0].yact >> 1;
-		break;
-	case YUV420:		/* nv12 */
-	case YUV420_NV21:	/* nv21 */
-	case YUV420_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset >> 1;
-		fix->line_length = stride;
-		uv_y_act = win_par->area_par[0].yact >> 1;
-		break;
-	case YUV444:
-	case YUV444_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_2;
-		uv_x_off = xoffset * 2;
-		uv_y_off = yoffset;
-		fix->line_length = stride << 2;
-		uv_y_act = win_par->area_par[0].yact;
-		break;
-	default:
-		break;
-	}
-	if (is_pic_yuv == 1) {
-		reg_win_data->reg_area_data[0].cbr_start =
-		    reg_win_data->reg_area_data[0].smem_start + xvir * yvir;
-		reg_win_data->reg_area_data[0].uv_vir_stride = uv_stride >> 2;
-		if ((screen->y_mirror == 1) || (reg_win_data->mirror_en)) {
-			if (screen->interlace == 1) {
-				reg_win_data->reg_area_data[0].c_offset =
-				    uv_y_off * uv_stride * 2 +
-				    ((uv_y_act - 1) * 2 + 1) * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			} else {
-				reg_win_data->reg_area_data[0].c_offset =
-				    uv_y_off * uv_stride +
-				    (uv_y_act - 1) * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			}
-		} else {
-			if (screen->interlace == 1) {
-				reg_win_data->reg_area_data[0].c_offset =
-				    uv_y_off * uv_stride * 2 +
-				    uv_x_off * pixel_width / 8;
-			} else {
-				reg_win_data->reg_area_data[0].c_offset =
-				    uv_y_off * uv_stride +
-				    uv_x_off * pixel_width / 8;
-			}
-		}
-		buff_len = reg_win_data->reg_area_data[0].cbr_start +
-			uv_y_off * uv_stride + uv_x_off * pixel_width / 8 +
-			reg_win_data->reg_area_data[0].xvir *
-			reg_win_data->reg_area_data[0].yact *
-			pixel_width / 16 -
-			reg_win_data->reg_area_data[0].smem_start -
-			reg_win_data->reg_area_data[0].xoff*
-			pixel_width / 16;
-		if ((buff_len > reg_win_data->reg_area_data[0].buff_len) &&
-		     dev_drv->iommu_enabled)
-			pr_err("\n!!!!!!error: fmt=%d,xvir[%d]*"
-			       "yact[%d]*bpp[%d]"
-			       "=buff_len[0x%x]>>mmu len=0x%x\n",
-			       fb_data_fmt,
-			       reg_win_data->reg_area_data[0].xvir,
-			       reg_win_data->reg_area_data[0].yact,
-			       pixel_width, buff_len,
-			       reg_win_data->reg_area_data[0].buff_len);
-	}
-
-	/* record buffer information for rk_fb_disp_scale to prevent fence
-	 * timeout because rk_fb_disp_scale will call function
-	 * info->fbops->fb_set_par(info);
-	 * delete by hjc for new hdmi overscan framework.
-	 */
-	/* info->var.yoffset = yoffset;
-	 * info->var.xoffset = xoffset;
-	 */
-	return 0;
-}
-
-static int rk_fb_set_win_config(struct fb_info *info,
-				struct rk_fb_win_cfg_data *win_data)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_fb_reg_data *regs;
-#ifdef H_USE_FENCE
-	struct sync_fence *release_fence[RK_MAX_BUF_NUM];
-	struct sync_fence *retire_fence;
-	struct sync_pt *release_sync_pt[RK_MAX_BUF_NUM];
-	struct sync_pt *retire_sync_pt;
-	char fence_name[20];
-#endif
-	int ret = 0, i, j = 0;
-	int list_is_empty = 0;
-	struct rk_screen *screen = dev_drv->cur_screen;
-
-	mutex_lock(&dev_drv->output_lock);
-
-	for (i = 0; i < 4; i++) {
-		for (j = 0; j < 4; j++) {
-			if ((win_data->win_par[i].area_par[j].ion_fd > 0) ||
-			    (win_data->win_par[i].area_par[j].phy_addr > 0))
-				ret += rk_fb_check_config_var(
-					&win_data->win_par[i].area_par[j],
-					screen);
-		}
-	}
-	if ((dev_drv->suspend_flag) || (dev_drv->hdmi_switch) || (ret < 0)) {
-		dev_drv->timeline_max++;
-		sw_sync_timeline_inc(dev_drv->timeline, 1);
-		if (dev_drv->suspend_flag)
-			pr_err("suspend_flag=%d\n", dev_drv->suspend_flag);
-		else if (dev_drv->hdmi_switch)
-			pr_err("hdmi switch = %d\n", dev_drv->hdmi_switch);
-		else
-			pr_err("error config ,ignore\n");
-		for (j = 0; j < RK_MAX_BUF_NUM; j++)
-			win_data->rel_fence_fd[j] = -1;
-		win_data->ret_fence_fd = -1;
-		goto err;
-	}
-
-	regs = kzalloc(sizeof(struct rk_fb_reg_data), GFP_KERNEL);
-	if (!regs) {
-		pr_info("could not allocate rk_fb_reg_data\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	for (i = 0, j = 0; i < dev_drv->lcdc_win_num; i++) {
-		if (win_data->win_par[i].win_id < dev_drv->lcdc_win_num) {
-			if (rk_fb_set_win_buffer(info, &win_data->win_par[i],
-						 &regs->reg_win_data[j])) {
-				ret = -ENOMEM;
-				pr_info("error:%s[%d]\n", __func__, __LINE__);
-				goto err2;
-			}
-			if (regs->reg_win_data[j].area_num > 0) {
-				regs->win_num++;
-				regs->buf_num +=
-				    regs->reg_win_data[j].area_buf_num;
-			}
-			j++;
-		} else {
-			pr_info("error:win_id bigger than lcdc_win_num\n");
-			pr_info("i=%d,win_id=%d\n", i,
-				win_data->win_par[i].win_id);
-		}
-	}
-	if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
-		rk_fb_set_wb_buffer(info, &win_data->wb_cfg,
-				    &regs->reg_wb_data);
-	if (regs->win_num <= 0)
-		goto err_null_frame;
-
-	dev_drv->timeline_max++;
-#ifdef H_USE_FENCE
-	win_data->ret_fence_fd = get_unused_fd_flags(0);
-	if (win_data->ret_fence_fd < 0) {
-		pr_err("ret_fence_fd=%d\n", win_data->ret_fence_fd);
-		win_data->ret_fence_fd = -1;
-		ret = -EFAULT;
-		goto err2;
-	}
-	for (i = 0; i < RK_MAX_BUF_NUM; i++) {
-		if (i < regs->buf_num) {
-			sprintf(fence_name, "fence%d", i);
-			win_data->rel_fence_fd[i] = get_unused_fd_flags(0);
-			if (win_data->rel_fence_fd[i] < 0) {
-				pr_info("rel_fence_fd=%d\n",
-					win_data->rel_fence_fd[i]);
-				ret = -EFAULT;
-				goto err2;
-			}
-			release_sync_pt[i] =
-			    sw_sync_pt_create(dev_drv->timeline,
-					      dev_drv->timeline_max);
-			release_fence[i] =
-			    sync_fence_create(fence_name, release_sync_pt[i]);
-			sync_fence_install(release_fence[i],
-					   win_data->rel_fence_fd[i]);
-		} else {
-			win_data->rel_fence_fd[i] = -1;
-		}
-	}
-
-	retire_sync_pt =
-	    sw_sync_pt_create(dev_drv->timeline, dev_drv->timeline_max);
-	retire_fence = sync_fence_create("ret_fence", retire_sync_pt);
-	sync_fence_install(retire_fence, win_data->ret_fence_fd);
-#else
-	for (i = 0; i < RK_MAX_BUF_NUM; i++)
-		win_data->rel_fence_fd[i] = -1;
-
-	win_data->ret_fence_fd = -1;
-#endif
-	if (dev_drv->wait_fs == 0) {
-		mutex_lock(&dev_drv->update_regs_list_lock);
-		list_add_tail(&regs->list, &dev_drv->update_regs_list);
-		mutex_unlock(&dev_drv->update_regs_list_lock);
-		queue_kthread_work(&dev_drv->update_regs_worker,
-				   &dev_drv->update_regs_work);
-	} else {
-		mutex_lock(&dev_drv->update_regs_list_lock);
-		list_is_empty = list_empty(&dev_drv->update_regs_list) &&
-					list_empty(&dev_drv->saved_list);
-		mutex_unlock(&dev_drv->update_regs_list_lock);
-		if (!list_is_empty) {
-			ret = wait_event_timeout(dev_drv->update_regs_wait,
-				list_empty(&dev_drv->update_regs_list) && list_empty(&dev_drv->saved_list),
-				msecs_to_jiffies(60));
-			if (ret > 0)
-				rk_fb_update_reg(dev_drv, regs);
-			else
-				pr_info("%s: wait update_regs_wait timeout\n", __func__);
-		} else if (ret == 0) {
-			rk_fb_update_reg(dev_drv, regs);
-		}
-	}
-	if (rk_fb_debug_lvl > 0)
-		rk_fb_config_debug(dev_drv, win_data, regs, rk_fb_debug_lvl);
-	if (rk_fb_iommu_debug > 0)
-		rk_fb_config_backup(dev_drv, win_data, regs);
-err:
-	mutex_unlock(&dev_drv->output_lock);
-	return ret;
-err_null_frame:
-	for (j = 0; j < RK_MAX_BUF_NUM; j++)
-		win_data->rel_fence_fd[j] = -1;
-	win_data->ret_fence_fd = -1;
-	pr_info("win num = %d,null frame\n", regs->win_num);
-err2:
-	rk_fb_config_debug(dev_drv, win_data, regs, 0);
-	kfree(regs);
-	mutex_unlock(&dev_drv->output_lock);
-
-	return ret;
-}
-
-#if 1
-static int cfgdone_distlist[10] = { 0 };
-
-static int cfgdone_index;
-static int cfgdone_lasttime;
-
-int rk_get_real_fps(int before)
-{
-	struct timespec now;
-	int dist_curr;
-	int dist_total = 0;
-	int dist_count = 0;
-	int dist_first = 0;
-
-	int index = cfgdone_index;
-	int i = 0, fps = 0;
-	int total;
-
-	if (before > 100)
-		before = 100;
-	if (before < 0)
-		before = 0;
-
-	getnstimeofday(&now);
-	dist_curr = (now.tv_sec * 1000000 + now.tv_nsec / 1000) -
-			cfgdone_lasttime;
-	total = dist_curr;
-	for (i = 0; i < 10; i++) {
-		if (--index < 0)
-			index = 9;
-		total += cfgdone_distlist[index];
-		if (i == 0)
-			dist_first = cfgdone_distlist[index];
-		if (total < (before * 1000)) {
-			dist_total += cfgdone_distlist[index];
-			dist_count++;
-		} else {
-			break;
-		}
-	}
-
-	dist_curr = (dist_curr > dist_first) ? dist_curr : dist_first;
-	dist_total += dist_curr;
-	dist_count++;
-
-	if (dist_total > 0)
-		fps = (1000000 * dist_count) / dist_total;
-	else
-		fps = 60;
-
-	return fps;
-}
-EXPORT_SYMBOL(rk_get_real_fps);
-
-#endif
-#define ION_MAX 10
-static struct ion_handle *ion_hanle[ION_MAX];
-static struct ion_handle *ion_hwc[1];
-static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,
-		       unsigned long arg)
-{
-	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct fb_fix_screeninfo *fix = &info->fix;
-	struct rk_lcdc_win *win;
-	int enable;	/* enable fb:1 enable;0 disable */
-	int ovl;	/* overlay:0 win1 on the top of win0;1,win0 on the top of win1 */
-	int num_buf;	/* buffer_number */
-	int ret = 0;
-	struct rk_fb_win_cfg_data win_data;
-	unsigned int dsp_addr[4][4];
-	int list_stat;
-
-	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	void __user *argp = (void __user *)arg;
-
-	win = dev_drv->win[win_id];
-	switch (cmd) {
-	case RK_FBIOSET_HWC_ADDR:
-	{
-		u32 hwc_phy[1];
-
-		if (copy_from_user(hwc_phy, argp, 4))
-			return -EFAULT;
-		if (!dev_drv->iommu_enabled) {
-			fix->smem_start = hwc_phy[0];
-		} else {
-			int usr_fd;
-			struct ion_handle *hdl;
-			ion_phys_addr_t phy_addr;
-			size_t len;
-
-			usr_fd = hwc_phy[0];
-			if (!usr_fd) {
-				fix->smem_start = 0;
-				fix->mmio_start = 0;
-				dev_drv->ops->open(dev_drv, win_id, 0);
-				break;
-			}
-
-			if (ion_hwc[0] != 0) {
-				ion_free(rk_fb->ion_client, ion_hwc[0]);
-				ion_hwc[0] = 0;
-			}
-
-			hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
-			if (IS_ERR(hdl)) {
-				dev_err(info->dev, "failed to get hwc ion handle:%ld\n",
-					PTR_ERR(hdl));
-				return -EFAULT;
-			}
-
-			ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, hdl,
-					    (unsigned long *)&phy_addr,
-					    (unsigned long *)&len);
-			if (ret < 0) {
-				dev_err(info->dev, "ion map to get hwc phy addr failed");
-				ion_free(rk_fb->ion_client, hdl);
-				return -ENOMEM;
-			}
-			fix->smem_start = phy_addr;
-			ion_hwc[0] = hdl;
-		}
-		break;
-	}
-	case RK_FBIOSET_YUV_ADDR:
-		{
-			u32 yuv_phy[2];
-
-			if (copy_from_user(yuv_phy, argp, 8))
-				return -EFAULT;
-			if (!dev_drv->iommu_enabled || !strcmp(info->fix.id, "fb0")) {
-				fix->smem_start = yuv_phy[0];
-				fix->mmio_start = yuv_phy[1];
-			} else {
-				int usr_fd, offset, tmp;
-				struct ion_handle *hdl;
-				ion_phys_addr_t phy_addr;
-				size_t len;
-
-				usr_fd = yuv_phy[0];
-				offset = yuv_phy[1] - yuv_phy[0];
-				if (!usr_fd) {
-					fix->smem_start = 0;
-					fix->mmio_start = 0;
-					break;
-				}
-
-				if (ion_hanle[ION_MAX - 1] != 0) {
-					/*ion_unmap_kernel(rk_fb->ion_client,
-					 *	ion_hanle[ION_MAX - 1]);
-					 *ion_unmap_iommu(dev_drv->dev,
-					 *	rk_fb->ion_client,
-					 *	ion_hanle[ION_MAX - 1]);
-					 */
-					ion_free(rk_fb->ion_client, ion_hanle[ION_MAX - 1]);
-					ion_hanle[ION_MAX - 1] = 0;
-				}
-
-				hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
-				if (IS_ERR(hdl)) {
-					dev_err(info->dev, "failed to get ion handle:%ld\n",
-						PTR_ERR(hdl));
-					return -EFAULT;
-				}
-
-				ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, hdl,
-						    (unsigned long *)&phy_addr,
-						    (unsigned long *)&len);
-				if (ret < 0) {
-					dev_err(info->dev, "ion map to get phy addr failed");
-					ion_free(rk_fb->ion_client, hdl);
-					return -ENOMEM;
-				}
-				fix->smem_start = phy_addr;
-				fix->mmio_start = phy_addr + offset;
-				fix->smem_len = len;
-				/*info->screen_base =
-				 *	ion_map_kernel(rk_fb->ion_client, hdl);
-				 */
-				ion_hanle[0] = hdl;
-				for (tmp = ION_MAX - 1; tmp > 0; tmp--)
-					ion_hanle[tmp] = ion_hanle[tmp - 1];
-				ion_hanle[0] = 0;
-			}
-			break;
-		}
-	case RK_FBIOSET_ENABLE:
-		if (copy_from_user(&enable, argp, sizeof(enable)))
-			return -EFAULT;
-				if (enable && fb_par->state)
-					fb_par->state++;
-				else
-					fb_par->state--;
-		dev_drv->ops->open(dev_drv, win_id, enable);
-		break;
-	case RK_FBIOGET_ENABLE:
-		enable = dev_drv->ops->get_win_state(dev_drv, win_id, 0);
-		if (copy_to_user(argp, &enable, sizeof(enable)))
-			return -EFAULT;
-		break;
-	case RK_FBIOSET_OVERLAY_STA:
-		if (copy_from_user(&ovl, argp, sizeof(ovl)))
-			return -EFAULT;
-		dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
-		break;
-	case RK_FBIOGET_OVERLAY_STA:
-		ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
-		if (copy_to_user(argp, &ovl, sizeof(ovl)))
-			return -EFAULT;
-		break;
-	case RK_FBIOPUT_NUM_BUFFERS:
-		if (copy_from_user(&num_buf, argp, sizeof(num_buf)))
-			return -EFAULT;
-		dev_drv->num_buf = num_buf;
-		break;
-	case RK_FBIOSET_VSYNC_ENABLE:
-		if (copy_from_user(&enable, argp, sizeof(enable)))
-			return -EFAULT;
-		if (enable)
-			dev_drv->vsync_info.active++;
-		else
-			dev_drv->vsync_info.active--;
-		break;
-	case RK_FBIOGET_DSP_ADDR:
-		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
-		if (copy_to_user(argp, &dsp_addr, sizeof(dsp_addr)))
-			return -EFAULT;
-		break;
-	case RK_FBIOGET_LIST_STA:
-		list_stat = rk_fb_get_list_stat(dev_drv);
-		if (copy_to_user(argp, &list_stat, sizeof(list_stat)))
-			return -EFAULT;
-
-		break;
-	case RK_FBIOGET_IOMMU_STA:
-		if (copy_to_user(argp, &dev_drv->iommu_enabled,
-				 sizeof(dev_drv->iommu_enabled)))
-			return -EFAULT;
-		break;
-#if defined(CONFIG_ION_ROCKCHIP)
-	case RK_FBIOSET_DMABUF_FD:
-		{
-			int usr_fd;
-			struct ion_handle *hdl;
-			ion_phys_addr_t phy_addr;
-			size_t len;
-
-			if (copy_from_user(&usr_fd, argp, sizeof(usr_fd)))
-				return -EFAULT;
-
-			hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
-			ion_phys(rk_fb->ion_client, hdl, &phy_addr, &len);
-			fix->smem_start = phy_addr;
-			break;
-		}
-	case RK_FBIOGET_DMABUF_FD:
-		{
-			int fd = -1;
-
-			if (IS_ERR_OR_NULL(fb_par->ion_hdl)) {
-				dev_err(info->dev,
-					"get dma_buf fd failed,ion handle is err\n");
-				return PTR_ERR(fb_par->ion_hdl);
-			}
-			fd = ion_share_dma_buf_fd(rk_fb->ion_client,
-						  fb_par->ion_hdl);
-			if (fd < 0) {
-				dev_err(info->dev,
-					"ion_share_dma_buf_fd failed\n");
-				return fd;
-			}
-			if (copy_to_user(argp, &fd, sizeof(fd)))
-				return -EFAULT;
-			break;
-		}
-#endif
-	case RK_FBIOSET_CLEAR_FB:
-		memset(fb_par->fb_virt_base, 0, fb_par->fb_size);
-		break;
-	case RK_FBIOSET_CONFIG_DONE:
-		{
-			int curr = 0;
-			struct timespec now;
-
-			getnstimeofday(&now);
-			curr = now.tv_sec * 1000000 + now.tv_nsec / 1000;
-			cfgdone_distlist[cfgdone_index++] =
-				curr - cfgdone_lasttime;
-			cfgdone_lasttime = curr;
-			if (cfgdone_index >= 10)
-				cfgdone_index = 0;
-		}
-		if (is_car_camcap()) {
-			int i = 0;
-
-			for (i = 0; i < RK_MAX_BUF_NUM; i++)
-				win_data.rel_fence_fd[i] = -1;
-
-			win_data.ret_fence_fd = -1;
-			goto cam_exit;
-		}
-		if (copy_from_user(&win_data,
-				   (struct rk_fb_win_cfg_data __user *)argp,
-				   sizeof(win_data))) {
-			ret = -EFAULT;
-			break;
-		};
-
-		dev_drv->wait_fs = win_data.wait_fs;
-		ret = rk_fb_set_win_config(info, &win_data);
-
-cam_exit:
-		if (copy_to_user((struct rk_fb_win_cfg_data __user *)arg,
-				 &win_data, sizeof(win_data))) {
-			ret = -EFAULT;
-			break;
-		}
-		memset(&win_data, 0, sizeof(struct rk_fb_win_cfg_data));
-
-		if (dev_drv->uboot_logo)
-			dev_drv->uboot_logo = 0;
-
-		break;
-	default:
-		dev_drv->ops->ioctl(dev_drv, cmd, arg, win_id);
-		break;
-	}
-
-	return ret;
-}
-
-static int rk_fb_blank(int blank_mode, struct fb_info *info)
-{
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct fb_fix_screeninfo *fix = &info->fix;
-	int win_id;
-#if defined(CONFIG_RK_HDMI)
-	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
-#endif
-
-	if (is_car_camcap())
-		return 0;
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fix->id);
-	if (win_id < 0)
-		return -ENODEV;
-	mutex_lock(&dev_drv->switch_screen);
-#if defined(CONFIG_RK_HDMI)
-	if ((rk_fb->disp_mode == ONE_DUAL) &&
-	    (hdmi_get_hotplug() == HDMI_HPD_ACTIVATED)) {
-		pr_info("hdmi is connect , not blank lcdc\n");
-	} else
-#endif
-	{
-		dev_drv->ops->blank(dev_drv, win_id, blank_mode);
-	}
-	mutex_unlock(&dev_drv->switch_screen);
-	return 0;
-}
-
-static int rk_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
-{
-	if ((0 == var->xres_virtual) || (0 == var->yres_virtual) ||
-	    (0 == var->xres) || (0 == var->yres) || (var->xres < 16) ||
-	    ((16 != var->bits_per_pixel) &&
-	    (32 != var->bits_per_pixel) &&
-	    (24 != var->bits_per_pixel))) {
-		dev_err(info->dev, "%s check var fail 1:\n"
-			"xres_vir:%d>>yres_vir:%d\n"
-			"xres:%d>>yres:%d\n"
-			"bits_per_pixel:%d\n",
-			info->fix.id,
-			var->xres_virtual,
-			var->yres_virtual,
-			var->xres, var->yres, var->bits_per_pixel);
-		return -EINVAL;
-	}
-
-	if (((var->xoffset + var->xres) > var->xres_virtual) ||
-	    ((var->yoffset + var->yres) > (var->yres_virtual))) {
-		dev_err(info->dev, "%s check_var fail 2:\n"
-			"xoffset:%d>>xres:%d>>xres_vir:%d\n"
-			"yoffset:%d>>yres:%d>>yres_vir:%d\n",
-			info->fix.id,
-			var->xoffset,
-			var->xres,
-			var->xres_virtual,
-			var->yoffset, var->yres, var->yres_virtual);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
-			  size_t count, loff_t *ppos)
-{
-	unsigned long p = *ppos;
-	u8 *buffer, *dst;
-	u8 __iomem *src;
-	int c, cnt = 0, err = 0;
-	unsigned long total_size;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_lcdc_win *win = NULL;
-	int win_id = 0;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	if (win_id < 0)
-		return -ENODEV;
-	else
-		win = dev_drv->win[win_id];
-
-	/* only read the current frame buffer */
-	if (win->area[0].format == RGB565) {
-		total_size = win->area[0].y_vir_stride * win->area[0].yact << 1;
-	} else if ((win->area[0].format == YUV420) ||
-		   (win->area[0].format == YUV420_NV21)) {
-		total_size =
-		    (win->area[0].y_vir_stride * win->area[0].yact * 6);
-	} else {
-		total_size = win->area[0].y_vir_stride * win->area[0].yact << 2;
-	}
-	if (p >= total_size)
-		return 0;
-
-	if (count >= total_size)
-		count = total_size;
-
-	if (count + p > total_size)
-		count = total_size - p;
-
-	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
-	if (!buffer)
-		return -ENOMEM;
-
-	src = (u8 __iomem *)(info->screen_base + p + win->area[0].y_offset);
-
-	while (count) {
-		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
-		dst = buffer;
-		fb_memcpy_fromfb(dst, src, c);
-		dst += c;
-		src += c;
-
-		if (copy_to_user(buf, buffer, c)) {
-			err = -EFAULT;
-			break;
-		}
-		*ppos += c;
-		buf += c;
-		cnt += c;
-		count -= c;
-	}
-
-	kfree(buffer);
-
-	return (err) ? err : cnt;
-}
-
-static ssize_t rk_fb_write(struct fb_info *info, const char __user *buf,
-			   size_t count, loff_t *ppos)
-{
-	unsigned long p = *ppos;
-	u8 *buffer, *src;
-	u8 __iomem *dst;
-	int c, cnt = 0, err = 0;
-	unsigned long total_size;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_lcdc_win *win = NULL;
-	int win_id = 0;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	if (win_id < 0)
-		return -ENODEV;
-	else
-		win = dev_drv->win[win_id];
-
-	/* write the current frame buffer */
-	if (win->area[0].format == RGB565)
-		total_size = win->area[0].xact * win->area[0].yact << 1;
-	else
-		total_size = win->area[0].xact * win->area[0].yact << 2;
-
-	if (p > total_size)
-		return -EFBIG;
-
-	if (count > total_size) {
-		err = -EFBIG;
-		count = total_size;
-	}
-
-	if (count + p > total_size) {
-		if (!err)
-			err = -ENOSPC;
-
-		count = total_size - p;
-	}
-
-	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
-	if (!buffer)
-		return -ENOMEM;
-
-	dst = (u8 __iomem *)(info->screen_base + p + win->area[0].y_offset);
-
-	while (count) {
-		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
-		src = buffer;
-
-		if (copy_from_user(src, buf, c)) {
-			err = -EFAULT;
-			break;
-		}
-
-		fb_memcpy_tofb(dst, src, c);
-		dst += c;
-		src += c;
-		*ppos += c;
-		buf += c;
-		cnt += c;
-		count -= c;
-	}
-
-	kfree(buffer);
-
-	return (cnt) ? cnt : err;
-}
-
-static int rk_fb_set_par(struct fb_info *info)
-{
-	struct fb_var_screeninfo *var = &info->var;
-	struct fb_fix_screeninfo *fix = &info->fix;
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_lcdc_win *win = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	int win_id = 0;
-	u16 xsize = 0, ysize = 0;	/* winx display window height/width --->LCDC_WINx_DSP_INFO */
-	u32 xoffset = var->xoffset;	/* offset from virtual to visible */
-	u32 yoffset = var->yoffset;
-	u16 xpos = (var->nonstd >> 8) & 0xfff;	/*visiable pos in panel */
-	u16 ypos = (var->nonstd >> 20) & 0xfff;
-	u32 xvir = var->xres_virtual;
-	u8 data_format = var->nonstd & 0xff;
-	u8 fb_data_fmt;
-	u8 pixel_width = 0;
-	u32 vir_width_bit;
-	u32 stride, uv_stride = 0;
-	u32 stride_32bit_1;
-	u32 stride_32bit_2;
-	u16 uv_x_off, uv_y_off, uv_y_act;
-	u8 is_pic_yuv = 0;
-	/*var->pixclock = dev_drv->pixclock;*/
-	if (dev_drv->suspend_flag || is_car_camcap())
-		return 0;
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
-	if (win_id < 0)
-		return -ENODEV;
-	else
-		win = dev_drv->win[win_id];
-
-	/* if the application has specific the hor and ver display size */
-	if (var->grayscale >> 8) {
-		xsize = (var->grayscale >> 8) & 0xfff;
-		ysize = (var->grayscale >> 20) & 0xfff;
-		xsize |= (var->reserved[0] << 12);
-		var->reserved[0] = 0;
-		if (xsize > screen->mode.xres)
-			xsize = screen->mode.xres;
-		if (ysize > screen->mode.yres)
-			ysize = screen->mode.yres;
-	} else {		/*ohterwise  full  screen display */
-		xsize = screen->mode.xres;
-		ysize = screen->mode.yres;
-	}
-
-	win->colorspace = CSC_FORMAT(data_format);
-	data_format &= ~CSC_MASK;
-	fb_data_fmt = rk_fb_data_fmt(data_format, var->bits_per_pixel);
-	if (IS_FBDC_FMT(fb_data_fmt)) {
-		win->area[0].fbdc_en = 1;
-		win->area[0].fbdc_cor_en = 1;
-	} else {
-		win->area[0].fbdc_en = 0;
-		win->area[0].fbdc_cor_en = 0;
-	}
-	pixel_width = rk_fb_pixel_width(fb_data_fmt);
-	vir_width_bit = pixel_width * xvir;
-	/* pixel_width = byte_num * 8 */
-	stride_32bit_1 = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
-	stride_32bit_2 = ALIGN_N_TIMES(vir_width_bit * 2, 32) / 8;
-
-	switch (fb_data_fmt) {
-	case YUV422:
-	case YUV422_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset;
-		fix->line_length = stride;
-		uv_y_act = win->area[0].yact >> 1;
-		break;
-	case YUV420:		/* nv12 */
-	case YUV420_NV21:	/* nv21 */
-	case YUV420_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_1;
-		uv_x_off = xoffset;
-		uv_y_off = yoffset >> 1;
-		fix->line_length = stride;
-		uv_y_act = win->area[0].yact >> 1;
-		break;
-	case YUV444:
-	case YUV444_A:
-		is_pic_yuv = 1;
-		stride = stride_32bit_1;
-		uv_stride = stride_32bit_2;
-		uv_x_off = xoffset * 2;
-		uv_y_off = yoffset;
-		fix->line_length = stride << 2;
-		uv_y_act = win->area[0].yact;
-		break;
-	default:
-		stride = stride_32bit_1;	/* default rgb */
-		fix->line_length = stride;
-		break;
-	}
-
-	win->area[0].format = fb_data_fmt;
-	win->area[0].y_vir_stride = stride >> 2;
-	win->area[0].uv_vir_stride = uv_stride >> 2;
-	win->area[0].xpos = xpos;
-	win->area[0].ypos = ypos;
-	win->area[0].xsize = xsize;
-	win->area[0].ysize = ysize;
-	win->area[0].xact = var->xres;	/* winx active window height,is a wint of vir */
-	win->area[0].yact = var->yres;
-	win->area[0].xvir = var->xres_virtual;	/* virtual resolution  stride --->LCDC_WINx_VIR */
-	win->area[0].yvir = var->yres_virtual;
-	win->area[0].xoff = xoffset;
-	win->area[0].yoff = yoffset;
-	win->ymirror = 0;
-	win->state = 1;
-	win->last_state = 1;
-
-	win->area_num = 1;
-	win->alpha_mode = 4;	/* AB_SRC_OVER; */
-	win->alpha_en = ((win->area[0].format == ARGB888) ||
-			 (win->area[0].format == FBDC_ARGB_888) ||
-			 (win->area[0].format == FBDC_ABGR_888) ||
-			 (win->area[0].format == ABGR888)) ? 1 : 0;
-	win->g_alpha_val = 0;
-
-	dev_drv->ops->set_par(dev_drv, win_id);
-
-	return 0;
-}
-
-static inline unsigned int chan_to_field(unsigned int chan,
-					 struct fb_bitfield *bf)
-{
-	chan &= 0xffff;
-	chan >>= 16 - bf->length;
-	return chan << bf->offset;
-}
-
-static int fb_setcolreg(unsigned regno,
-			unsigned red, unsigned green, unsigned blue,
-			unsigned transp, struct fb_info *info)
-{
-	unsigned int val;
-
-	switch (info->fix.visual) {
-	case FB_VISUAL_TRUECOLOR:
-		/* true-colour, use pseudo-palette */
-		if (regno < 16) {
-			u32 *pal = info->pseudo_palette;
-
-			val = chan_to_field(red, &info->var.red);
-			val |= chan_to_field(green, &info->var.green);
-			val |= chan_to_field(blue, &info->var.blue);
-			pal[regno] = val;
-		}
-		break;
-	default:
-		return -1;	/* unknown type */
-	}
-
-	return 0;
-}
-
-static int rk_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
-	struct ion_handle *handle = fb_par->ion_hdl;
-	struct dma_buf *dma_buf = NULL;
-
-	if (IS_ERR_OR_NULL(handle)) {
-		dev_err(info->dev, "failed to get ion handle:%ld\n",
-			PTR_ERR(handle));
-		return -ENOMEM;
-	}
-	dma_buf = ion_share_dma_buf(rk_fb->ion_client, handle);
-	if (IS_ERR_OR_NULL(dma_buf)) {
-		pr_info("get ion share dma buf failed\n");
-		return -ENOMEM;
-	}
-
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-
-	return dma_buf_mmap(dma_buf, vma, 0);
-}
-
-static struct fb_ops fb_ops = {
-	.owner = THIS_MODULE,
-	.fb_open = rk_fb_open,
-	.fb_release = rk_fb_close,
-	.fb_check_var = rk_fb_check_var,
-	.fb_set_par = rk_fb_set_par,
-	.fb_blank = rk_fb_blank,
-	.fb_ioctl = rk_fb_ioctl,
-	.fb_compat_ioctl = rk_fb_ioctl,
-	.fb_pan_display = rk_fb_pan_display,
-	.fb_read = rk_fb_read,
-	.fb_write = rk_fb_write,
-	.fb_setcolreg = fb_setcolreg,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-};
-
-static struct fb_var_screeninfo def_var = {
-#if defined(CONFIG_LOGO_LINUX_BMP)
-	.red = {16, 8, 0},
-	.green = {8, 8, 0},
-	.blue = {0, 8, 0},
-	.transp = {0, 0, 0},
-	.nonstd = HAL_PIXEL_FORMAT_BGRA_8888,
-#else
-	.red = {11, 5, 0},
-	.green = {5, 6, 0},
-	.blue = {0, 5, 0},
-	.transp = {0, 0, 0},
-	.nonstd = HAL_PIXEL_FORMAT_RGB_565,	/* (ypos<<20+xpos<<8+format) format */
-#endif
-	.grayscale = 0,		/* (ysize<<20+xsize<<8) */
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.vmode = FB_VMODE_NONINTERLACED,
-};
-
-static struct fb_fix_screeninfo def_fix = {
-	.type = FB_TYPE_PACKED_PIXELS,
-	.type_aux = 0,
-	.xpanstep = 1,
-	.ypanstep = 1,
-	.ywrapstep = 0,
-	.accel = FB_ACCEL_NONE,
-	.visual = FB_VISUAL_TRUECOLOR,
-
-};
-
-static int rk_fb_wait_for_vsync_thread(void *data)
-{
-	struct rk_lcdc_driver *dev_drv = data;
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-	struct fb_info *fbi = rk_fb->fb[dev_drv->fb_index_base];
-
-	while (!kthread_should_stop()) {
-		ktime_t timestamp = dev_drv->vsync_info.timestamp;
-		int ret = wait_event_interruptible(dev_drv->vsync_info.wait,
-				!ktime_equal(timestamp, dev_drv->vsync_info.timestamp) &&
-				(dev_drv->vsync_info.active > 0 || dev_drv->vsync_info.irq_stop));
-
-		if (!ret)
-			sysfs_notify(&fbi->dev->kobj, NULL, "vsync");
-	}
-
-	return 0;
-}
-
-static ssize_t rk_fb_vsync_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return scnprintf(buf, PAGE_SIZE, "%llu\n",
-			 ktime_to_ns(dev_drv->vsync_info.timestamp));
-}
-
-static DEVICE_ATTR(vsync, S_IRUGO, rk_fb_vsync_show, NULL);
-
-/*
- * this two function is for other module that in the kernel which
- * need show image directly through fb
- * fb_id:we have 4 fb here,default we use fb0 for ui display
- */
-struct fb_info *rk_get_fb(int fb_id)
-{
-	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
-	struct fb_info *fb = inf->fb[fb_id];
-	return fb;
-}
-EXPORT_SYMBOL(rk_get_fb);
-
-void rk_direct_fb_show(struct fb_info *fbi)
-{
-	rk_fb_set_par(fbi);
-	rk_fb_pan_display(&fbi->var, fbi);
-}
-EXPORT_SYMBOL(rk_direct_fb_show);
-
-int rk_fb_dpi_open(bool open)
-{
-	struct rk_lcdc_driver *dev_drv = NULL;
-
-	dev_drv = rk_get_prmry_lcdc_drv();
-	if (dev_drv->ops->dpi_open)
-		dev_drv->ops->dpi_open(dev_drv, open);
-	return 0;
-}
-
-int rk_fb_dpi_win_sel(int win_id)
-{
-	struct rk_lcdc_driver *dev_drv = NULL;
-
-	dev_drv = rk_get_prmry_lcdc_drv();
-	if (dev_drv->ops->dpi_win_sel)
-		dev_drv->ops->dpi_win_sel(dev_drv, win_id);
-	return 0;
-}
-
-int rk_fb_dpi_status(void)
-{
-	int ret = 0;
-	struct rk_lcdc_driver *dev_drv = NULL;
-
-	dev_drv = rk_get_prmry_lcdc_drv();
-	if (dev_drv->ops->dpi_status)
-		ret = dev_drv->ops->dpi_status(dev_drv);
-
-	return ret;
-}
-
-/*
- * function: this function will be called by display device, enable/disable lcdc
- * @screen: screen timing to be set to lcdc
- * @enable: 0 disable lcdc; 1 enable change lcdc timing; 2 just enable dclk
- * @lcdc_id: the lcdc id the display device attached ,0 or 1
- */
-int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id)
-{
-	struct rk_fb *rk_fb =  platform_get_drvdata(fb_pdev);
-	struct fb_info *info = NULL;
-	struct rk_fb_par *fb_par = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-	struct rk_lcdc_win *win;
-	char name[6] = {0};
-	int i, win_id;
-	static bool load_screen;
-	char *envp[4];
-	char envplcdc[32];
-	char envpfbdev[32];
-	int ret, list_is_empty = 0;
-
-	if (unlikely(!rk_fb) || unlikely(!screen))
-		return -ENODEV;
-
-	/* get lcdc driver */
-	sprintf(name, "lcdc%d", lcdc_id);
-	dev_drv = rk_get_lcdc_drv(name);
-
-	if (dev_drv == NULL) {
-		pr_err("%s driver not found!", name);
-		return -ENODEV;
-	}
-	if (screen->type == SCREEN_HDMI)
-		pr_info("hdmi %s lcdc%d\n",
-			enable ? "connect to" : "remove from",
-			dev_drv->id);
-	else if (screen->type == SCREEN_TVOUT ||
-		 screen->type == SCREEN_TVOUT_TEST)
-		pr_info("cvbs %s lcdc%d\n",
-			enable ? "connect to" : "remove from",
-			dev_drv->id);
-	if (enable == 2 /*&& dev_drv->enable*/)
-		return 0;
-	pr_info("switch:en=%d,lcdc_id=%d,screen type=%d,cur type=%d",
-		enable, lcdc_id, screen->type, dev_drv->cur_screen->type);
-	pr_info("data space: %d, color mode: %d\n",
-		screen->data_space, screen->color_mode);
-
-	mutex_lock(&dev_drv->switch_screen);
-	dev_drv->hot_plug_state = enable;
-	hdmi_switch_state = 0;
-	dev_drv->hdmi_switch = 1;
-	if (!dev_drv->uboot_logo) {
-		mdelay(200);
-		list_is_empty = list_empty(&dev_drv->update_regs_list) &&
-					   list_empty(&dev_drv->saved_list);
-		if (!list_is_empty) {
-			ret = wait_event_timeout(dev_drv->update_regs_wait,
-						 list_empty(&dev_drv->update_regs_list) &&
-						 list_empty(&dev_drv->saved_list),
-						 msecs_to_jiffies(60));
-			if (ret <= 0)
-				pr_info("%s: wait update_regs_wait timeout\n",
-					__func__);
-		}
-	}
-
-	envp[0] = "switch vop screen";
-	memset(envplcdc, 0, sizeof(envplcdc));
-	memset(envpfbdev, 0, sizeof(envpfbdev));
-	sprintf(envplcdc, "SCREEN=%d,ENABLE=%d,VOPID=%d", screen->type, enable, dev_drv->id);
-	sprintf(envpfbdev, "FBDEV=%d", dev_drv->fb_index_base);
-	envp[1] = envplcdc;
-	envp[2] = envpfbdev;
-	envp[3] = NULL;
-
-	if ((rk_fb->disp_mode == ONE_DUAL) ||
-	    (rk_fb->disp_mode == NO_DUAL)) {
-		if ((dev_drv->ops->backlight_close) &&
-		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))
-			dev_drv->ops->backlight_close(dev_drv, 1);
-		if (!dev_drv->uboot_logo || load_screen ||
-		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
-			if (dev_drv->ops->dsp_black)
-				dev_drv->ops->dsp_black(dev_drv, 0);
-		}
-		if ((dev_drv->ops->set_screen_scaler) &&
-		    (rk_fb->disp_mode == ONE_DUAL))
-			dev_drv->ops->set_screen_scaler(dev_drv,
-							dev_drv->screen0, 0);
-	}
-	if (!enable) {
-		/* if screen type is different, we do not disable lcdc. */
-		if (dev_drv->cur_screen->type != screen->type) {
-			dev_drv->hdmi_switch = 0;
-			mutex_unlock(&dev_drv->switch_screen);
-			return 0;
-		}
-
-		/* if used one lcdc to dual disp, no need to close win */
-		if ((rk_fb->disp_mode == ONE_DUAL) ||
-		    ((rk_fb->disp_mode == NO_DUAL) &&
-		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))) {
-			dev_drv->cur_screen = dev_drv->screen0;
-			dev_drv->ops->load_screen(dev_drv, 1);
-			/* force modify dsp size */
-			info = rk_fb->fb[dev_drv->fb_index_base];
-			info->var.grayscale &= 0xff;
-			info->var.grayscale |=
-				((dev_drv->cur_screen->mode.xres & 0xfff) << 8) +
-				(dev_drv->cur_screen->mode.yres << 20);
-			info->var.reserved[0] |= (dev_drv->cur_screen->mode.xres >> 12);
-			mutex_lock(&dev_drv->win_config);
-			info->var.xoffset = 0;
-			info->var.yoffset = 0;
-			info->fbops->fb_set_par(info);
-			info->fbops->fb_pan_display(&info->var, info);
-			mutex_unlock(&dev_drv->win_config);
-
-			/*
-			 * if currently is loader display, black until new
-			 * display job.
-			 */
-			if (dev_drv->uboot_logo) {
-				for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-					if (dev_drv->win[i] && dev_drv->win[i]->state &&
-					    dev_drv->ops->win_direct_en)
-						dev_drv->ops->win_direct_en(dev_drv, i, 0);
-				}
-			}
-
-			/*if (dev_drv->ops->dsp_black)
-			 *	dev_drv->ops->dsp_black(dev_drv, 0);
-			 */
-			if ((dev_drv->ops->backlight_close) &&
-			    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))
-				dev_drv->ops->backlight_close(dev_drv, 0);
-		} else if (rk_fb->num_lcdc > 1) {
-			/* If there is more than one lcdc device, we disable
-			 *  the layer which attached to this device
-			 */
-			flush_kthread_worker(&dev_drv->update_regs_worker);
-			for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-				if (dev_drv->win[i] && dev_drv->win[i]->state)
-					dev_drv->ops->open(dev_drv, i, 0);
-			}
-		}
-		kobject_uevent_env(&dev_drv->dev->kobj, KOBJ_CHANGE, envp);
-
-		hdmi_switch_state = 0;
-		dev_drv->hdmi_switch = 0;
-		mutex_unlock(&dev_drv->switch_screen);
-		return 0;
-	} else {
-		if (load_screen || (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
-			for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-				if (dev_drv->win[i] && dev_drv->win[i]->state &&
-					dev_drv->ops->win_direct_en)
-					dev_drv->ops->win_direct_en(dev_drv, i, 0);
-			}
-		}
-		if (dev_drv->screen1)
-			dev_drv->cur_screen = dev_drv->screen1;
-
-		memcpy(dev_drv->cur_screen, screen, sizeof(struct rk_screen));
-		dev_drv->cur_screen->xsize = dev_drv->cur_screen->mode.xres;
-		dev_drv->cur_screen->ysize = dev_drv->cur_screen->mode.yres;
-		dev_drv->cur_screen->x_mirror =
-					!!(dev_drv->rotate_mode & X_MIRROR);
-		dev_drv->cur_screen->y_mirror =
-					!!(dev_drv->rotate_mode & Y_MIRROR);
-	}
-
-	if (!dev_drv->uboot_logo || load_screen ||
-	    (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
-		info = rk_fb->fb[dev_drv->fb_index_base];
-		fb_par = (struct rk_fb_par *)info->par;
-		win_id = 0;
-		win = dev_drv->win[win_id];
-		if (win && fb_par->state) {
-			dev_drv->ops->load_screen(dev_drv, 1);
-			info->var.activate |= FB_ACTIVATE_FORCE;
-			if (rk_fb->disp_mode == ONE_DUAL) {
-				info->var.grayscale &= 0xff;
-				info->var.grayscale |=
-					((dev_drv->cur_screen->mode.xres & 0xfff) << 8) +
-					(dev_drv->cur_screen->ysize << 20);
-				info->var.reserved[0] |= (dev_drv->cur_screen->mode.xres >> 12);
-			}
-			if (dev_drv->uboot_logo && win->state) {
-				if (win->area[0].xpos ||
-				    win->area[0].ypos) {
-					win->area[0].xpos =
-						(screen->mode.xres -
-						 win->area[0].xsize) / 2;
-					win->area[0].ypos =
-						(screen->mode.yres -
-						 win->area[0].ysize) / 2;
-				} else {
-					win->area[0].xsize = screen->mode.xres;
-					win->area[0].ysize = screen->mode.yres;
-				}
-				dev_drv->ops->set_par(dev_drv, i);
-				dev_drv->ops->cfg_done(dev_drv);
-			} else if (!dev_drv->win[win_id]->state) {
-				dev_drv->ops->open(dev_drv, win_id, 1);
-				info->fbops->fb_pan_display(&info->var, info);
-			}
-		}
-	} else {
-		dev_drv->ops->load_screen(dev_drv, 0);
-	}
-	kobject_uevent_env(&dev_drv->dev->kobj, KOBJ_CHANGE, envp);
-
-	if (dev_drv->cur_screen->width && dev_drv->cur_screen->height) {
-		/* for vr auto dp support */
-		info = rk_fb->fb[dev_drv->fb_index_base];
-		info->var.width = dev_drv->cur_screen->width;
-		info->var.height = dev_drv->cur_screen->height;
-		pr_info("%s:info->var.width=%d, info->var.height=%d\n",
-			__func__, info->var.width, info->var.height);
-	}
-
-	hdmi_switch_state = 1;
-	load_screen = true;
-	dev_drv->hdmi_switch = 0;
-	if ((rk_fb->disp_mode == ONE_DUAL) || (rk_fb->disp_mode == NO_DUAL)) {
-		if ((dev_drv->ops->set_screen_scaler) &&
-		    (rk_fb->disp_mode == ONE_DUAL))
-			dev_drv->ops->set_screen_scaler(dev_drv,
-							dev_drv->screen0, 1);
-		/*if (dev_drv->ops->dsp_black)
-		 *	dev_drv->ops->dsp_black(dev_drv, 0);*/
-		if ((dev_drv->ops->backlight_close) &&
-		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX) &&
-		    (rk_fb->disp_mode == ONE_DUAL))
-			dev_drv->ops->backlight_close(dev_drv, 0);
-	}
-	mutex_unlock(&dev_drv->switch_screen);
-	return 0;
-}
-
-/*
- * function:this function current only called by hdmi for
- *	scale the display
- * scale_x: scale rate of x resolution
- * scale_y: scale rate of y resolution
- * lcdc_id: the lcdc id the hdmi attached ,0 or 1
- */
-int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id)
-{
-	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
-	struct fb_info *info = NULL;
-	struct fb_info *pmy_info = NULL;
-	struct fb_var_screeninfo *var = NULL;
-	struct rk_lcdc_driver *dev_drv = NULL;
-	u16 screen_x, screen_y;
-	u16 xpos, ypos;
-	char name[6];
-	struct rk_screen primary_screen;
-
-	rk_fb_get_prmry_screen(&primary_screen);
-	if (primary_screen.type == SCREEN_HDMI)
-		return 0;
-
-	pr_err("should not be here--%s\n", __func__);
-
-	return 0;
-	sprintf(name, "lcdc%d", lcdc_id);
-
-	if (inf->disp_mode == DUAL) {
-		dev_drv = rk_get_lcdc_drv(name);
-		if (!dev_drv) {
-			pr_err("%s driver not found!", name);
-			return -ENODEV;
-		}
-	} else {
-		dev_drv = inf->lcdc_dev_drv[0];
-	}
-
-	if (inf->num_lcdc == 1) {
-		info = inf->fb[0];
-	} else if (inf->num_lcdc == 2) {
-		info = inf->fb[dev_drv->lcdc_win_num];
-		pmy_info = inf->fb[0];
-	}
-
-	var = &info->var;
-	screen_x = dev_drv->cur_screen->mode.xres;
-	screen_y = dev_drv->cur_screen->mode.yres;
-
-	if (inf->disp_mode != DUAL && dev_drv->screen1) {
-		dev_drv->cur_screen->xpos =
-		    (screen_x - screen_x * scale_x / 100) >> 1;
-		dev_drv->cur_screen->ypos =
-		    (screen_y - screen_y * scale_y / 100) >> 1;
-		dev_drv->cur_screen->xsize = screen_x * scale_x / 100;
-		dev_drv->cur_screen->ysize = screen_y * scale_y / 100;
-	} else {
-		xpos = (screen_x - screen_x * scale_x / 100) >> 1;
-		ypos = (screen_y - screen_y * scale_y / 100) >> 1;
-		dev_drv->cur_screen->xsize = screen_x * scale_x / 100;
-		dev_drv->cur_screen->ysize = screen_y * scale_y / 100;
-		if (inf->disp_mode == ONE_DUAL) {
-			var->nonstd &= 0xff;
-			var->nonstd |= (xpos << 8) + (ypos << 20);
-			var->grayscale &= 0xff;
-			var->grayscale |=
-				(dev_drv->cur_screen->xsize << 8) +
-				(dev_drv->cur_screen->ysize << 20);
-		}
-	}
-
-	mutex_lock(&dev_drv->win_config);
-	info->fbops->fb_set_par(info);
-	dev_drv->ops->cfg_done(dev_drv);
-	mutex_unlock(&dev_drv->win_config);
-
-	return 0;
-}
-
-#if defined(CONFIG_ION_ROCKCHIP)
-static int rk_fb_alloc_buffer_by_ion(struct fb_info *fbi,
-				     struct rk_lcdc_win *win,
-				     unsigned long fb_mem_size)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct ion_handle *handle;
-	ion_phys_addr_t phy_addr;
-	size_t len;
-	int ret = 0;
-
-	if (dev_drv->iommu_enabled)
-		handle = ion_alloc(rk_fb->ion_client, (size_t)fb_mem_size, 0,
-				   ION_HEAP_SYSTEM_MASK, 0);
-	else
-		handle = ion_alloc(rk_fb->ion_client, (size_t)fb_mem_size, 0,
-				   ION_HEAP_TYPE_DMA_MASK, 0);
-
-	if (IS_ERR(handle)) {
-		dev_err(fbi->device, "failed to ion_alloc:%ld\n",
-			PTR_ERR(handle));
-		return -ENOMEM;
-	}
-
-	fb_par->ion_hdl = handle;
-	win->area[0].dma_buf = ion_share_dma_buf(rk_fb->ion_client, handle);
-	if (IS_ERR_OR_NULL(win->area[0].dma_buf)) {
-		pr_info("ion_share_dma_buf() failed\n");
-		goto err_share_dma_buf;
-	}
-	win->area[0].ion_hdl = handle;
-	if (dev_drv->prop == PRMRY)
-		fbi->screen_base = ion_map_kernel(rk_fb->ion_client, handle);
-	if (dev_drv->iommu_enabled && dev_drv->mmu_dev)
-		ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, handle,
-				    (unsigned long *)&phy_addr,
-				    (unsigned long *)&len);
-	else
-		ret = ion_phys(rk_fb->ion_client, handle, &phy_addr, &len);
-	if (ret < 0) {
-		dev_err(fbi->dev, "ion map to get phy addr failed\n");
-		goto err_share_dma_buf;
-	}
-	fbi->fix.smem_start = phy_addr;
-	fbi->fix.smem_len = len;
-	pr_info("alloc_buffer:ion_phy_addr=0x%lx\n", phy_addr);
-	return 0;
-
-err_share_dma_buf:
-	ion_free(rk_fb->ion_client, handle);
-	return -ENOMEM;
-}
-#endif
-
-static int rk_fb_alloc_buffer(struct fb_info *fbi)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_lcdc_win *win = NULL;
-	int win_id;
-	int ret = 0;
-	unsigned long fb_mem_size;
-#if !defined(CONFIG_ION_ROCKCHIP)
-	dma_addr_t fb_mem_phys;
-	void *fb_mem_virt;
-#endif
-	ion_phys_addr_t phy_addr;
-	size_t len;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
-	if (win_id < 0)
-		return -ENODEV;
-	else
-		win = dev_drv->win[win_id];
-
-	if (!strcmp(fbi->fix.id, "fb0")) {
-		fb_mem_size = get_fb_size(dev_drv->reserved_fb);
-#if defined(CONFIG_ION_ROCKCHIP)
-		if (rk_fb_alloc_buffer_by_ion(fbi, win, fb_mem_size) < 0)
-			return -ENOMEM;
-#else
-		fb_mem_virt = dma_alloc_writecombine(fbi->dev, fb_mem_size,
-						     &fb_mem_phys, GFP_KERNEL);
-		if (!fb_mem_virt) {
-			pr_err("%s: Failed to allocate framebuffer\n",
-			       __func__);
-			return -ENOMEM;
-		}
-		fbi->fix.smem_len = fb_mem_size;
-		fbi->fix.smem_start = fb_mem_phys;
-		fbi->screen_base = fb_mem_virt;
-#endif
-		memset(fbi->screen_base, 0, fbi->fix.smem_len);
-	} else {
-		if (dev_drv->prop == EXTEND && dev_drv->iommu_enabled) {
-			struct rk_lcdc_driver *dev_drv_prmry;
-			int win_id_prmry;
-
-			fb_mem_size = get_fb_size(dev_drv->reserved_fb);
-#if defined(CONFIG_ION_ROCKCHIP)
-			dev_drv_prmry = rk_get_prmry_lcdc_drv();
-			if (dev_drv_prmry == NULL)
-				return -ENODEV;
-			win_id_prmry =
-				dev_drv_prmry->ops->fb_get_win_id(dev_drv_prmry,
-								 fbi->fix.id);
-			if (win_id_prmry < 0)
-				return -ENODEV;
-			else
-				fb_par->ion_hdl =
-				dev_drv_prmry->win[win_id_prmry]->area[0].ion_hdl;
-			fbi->screen_base =
-				ion_map_kernel(rk_fb->ion_client,
-					       fb_par->ion_hdl);
-			dev_drv->win[win_id]->area[0].ion_hdl =
-				fb_par->ion_hdl;
-			if (dev_drv->mmu_dev)
-				ret = ion_map_iommu(dev_drv->dev,
-						    rk_fb->ion_client,
-						    fb_par->ion_hdl,
-						    (unsigned long *)&phy_addr,
-						    (unsigned long *)&len);
-			else
-				ret = ion_phys(rk_fb->ion_client,
-					       fb_par->ion_hdl,
-					       &phy_addr, &len);
-			if (ret < 0) {
-				dev_err(fbi->dev, "ion map to get phy addr failed\n");
-				return -ENOMEM;
-			}
-			fbi->fix.smem_start = phy_addr;
-			fbi->fix.smem_len = len;
-#else
-			fb_mem_virt = dma_alloc_writecombine(fbi->dev,
-							     fb_mem_size,
-							     &fb_mem_phys,
-							     GFP_KERNEL);
-			if (!fb_mem_virt) {
-				pr_err("%s: Failed to allocate framebuffer\n",
-				       __func__);
-				return -ENOMEM;
-			}
-			fbi->fix.smem_len = fb_mem_size;
-			fbi->fix.smem_start = fb_mem_phys;
-			fbi->screen_base = fb_mem_virt;
-#endif
-		} else {
-			fbi->fix.smem_start = rk_fb->fb[0]->fix.smem_start;
-			fbi->fix.smem_len = rk_fb->fb[0]->fix.smem_len;
-			fbi->screen_base = rk_fb->fb[0]->screen_base;
-		}
-	}
-
-	fbi->screen_size = fbi->fix.smem_len;
-	fb_par->fb_phy_base = fbi->fix.smem_start;
-	fb_par->fb_virt_base = fbi->screen_base;
-	fb_par->fb_size = fbi->fix.smem_len;
-
-	pr_info("%s:phy:%lx>>vir:%p>>len:0x%x\n", fbi->fix.id,
-		fbi->fix.smem_start, fbi->screen_base,
-		fbi->fix.smem_len);
-	return ret;
-}
-
-#if 0
-static int rk_release_fb_buffer(struct fb_info *fbi)
-{
-	/* buffer for fb1 and fb3 are alloc by android */
-	if (!strcmp(fbi->fix.id, "fb1") || !strcmp(fbi->fix.id, "fb3"))
-		return 0;
-	iounmap(fbi->screen_base);
-	release_mem_region(fbi->fix.smem_start, fbi->fix.smem_len);
-	return 0;
-}
-#endif
-
-static int init_lcdc_win(struct rk_lcdc_driver *dev_drv,
-			 struct rk_lcdc_win *def_win)
-{
-	int i;
-	int lcdc_win_num = dev_drv->lcdc_win_num;
-
-	for (i = 0; i < lcdc_win_num; i++) {
-		struct rk_lcdc_win *win = NULL;
-
-		win = kzalloc(sizeof(struct rk_lcdc_win), GFP_KERNEL);
-		if (!win) {
-			dev_err(dev_drv->dev, "kzmalloc for win fail!");
-			return -ENOMEM;
-		}
-
-		strcpy(win->name, def_win[i].name);
-		win->id = def_win[i].id;
-		win->support_3d = def_win[i].support_3d;
-		win->property.feature = def_win[i].property.feature;
-		win->property.max_input_x = def_win[i].property.max_input_x;
-		win->property.max_input_y = def_win[i].property.max_input_y;
-		dev_drv->win[i] = win;
-	}
-
-	return 0;
-}
-
-static int init_lcdc_device_driver(struct rk_fb *rk_fb,
-				   struct rk_lcdc_win *def_win, int index)
-{
-	struct rk_lcdc_driver *dev_drv = rk_fb->lcdc_dev_drv[index];
-	struct rk_screen *screen = devm_kzalloc(dev_drv->dev,
-						sizeof(struct rk_screen),
-						GFP_KERNEL);
-	int i = 0;
-
-	if (!screen) {
-		dev_err(dev_drv->dev, "malloc screen for lcdc%d fail!",
-			dev_drv->id);
-		return -ENOMEM;
-	}
-
-	screen->screen_id = 0;
-	screen->lcdc_id = dev_drv->id;
-	screen->overscan.left = 100;
-	screen->overscan.top = 100;
-	screen->overscan.right = 100;
-	screen->overscan.bottom = 100;
-
-	screen->x_mirror = !!(dev_drv->rotate_mode & X_MIRROR);
-	screen->y_mirror = !!(dev_drv->rotate_mode & Y_MIRROR);
-
-	dev_drv->screen0 = screen;
-	dev_drv->cur_screen = screen;
-	/* devie use one lcdc + rk61x scaler for dual display */
-	if ((rk_fb->disp_mode == ONE_DUAL) || (rk_fb->disp_mode == NO_DUAL)) {
-		struct rk_screen *screen1 =
-				devm_kzalloc(dev_drv->dev,
-					     sizeof(struct rk_screen),
-					     GFP_KERNEL);
-		if (!screen1) {
-			dev_err(dev_drv->dev, "malloc screen1 for lcdc%d fail!",
-				dev_drv->id);
-			return -ENOMEM;
-		}
-		screen1->screen_id = 1;
-		screen1->lcdc_id = 1;
-		dev_drv->screen1 = screen1;
-	}
-	sprintf(dev_drv->name, "lcdc%d", dev_drv->id);
-	init_lcdc_win(dev_drv, def_win);
-	init_completion(&dev_drv->frame_done);
-	spin_lock_init(&dev_drv->cpl_lock);
-	mutex_init(&dev_drv->fb_win_id_mutex);
-	mutex_init(&dev_drv->win_config);
-	mutex_init(&dev_drv->front_lock);
-	mutex_init(&dev_drv->switch_screen);
-	dev_drv->ops->fb_win_remap(dev_drv, dev_drv->fb_win_map);
-	dev_drv->first_frame = 1;
-	dev_drv->overscan.left = 100;
-	dev_drv->overscan.top = 100;
-	dev_drv->overscan.right = 100;
-	dev_drv->overscan.bottom = 100;
-	for (i = 0; i < RK30_MAX_LAYER_SUPPORT; i++)
-		dev_drv->area_support[i] = 1;
-	if (dev_drv->ops->area_support_num)
-		dev_drv->ops->area_support_num(dev_drv, dev_drv->area_support);
-	rk_disp_pwr_ctr_parse_dt(dev_drv);
-	if (dev_drv->prop == PRMRY) {
-		rk_fb_set_prmry_screen(screen);
-		rk_fb_get_prmry_screen(screen);
-	}
-	dev_drv->trsm_ops = rk_fb_trsm_ops_get(screen->type);
-	if (dev_drv->prop != PRMRY)
-		rk_fb_get_extern_screen(screen);
-	dev_drv->output_color = screen->color_mode;
-
-	return 0;
-}
-
-#ifdef CONFIG_LOGO_LINUX_BMP
-static struct linux_logo *bmp_logo;
-static int fb_prewine_bmp_logo(struct fb_info *info, int rotate)
-{
-	bmp_logo = fb_find_logo(24);
-	if (bmp_logo == NULL) {
-		pr_info("%s error\n", __func__);
-		return 0;
-	}
-	return 1;
-}
-
-static void fb_show_bmp_logo(struct fb_info *info, int rotate)
-{
-	unsigned char *src = bmp_logo->data;
-	unsigned char *dst = info->screen_base;
-	int i;
-	unsigned int needwidth = (*(src - 24) << 8) | (*(src - 23));
-	unsigned int needheight = (*(src - 22) << 8) | (*(src - 21));
-
-	for (i = 0; i < needheight; i++)
-		memcpy(dst + info->var.xres * i * 4,
-		       src + bmp_logo->width * i * 4, needwidth * 4);
-}
-#endif
-
-/*
- * check if the primary lcdc has registered,
- * the primary lcdc mas register first
- */
-bool is_prmry_rk_lcdc_registered(void)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-
-	if (rk_fb->lcdc_dev_drv[0])
-		return true;
-	else
-		return false;
-}
-
-phys_addr_t uboot_logo_base;
-phys_addr_t uboot_logo_size;
-phys_addr_t uboot_logo_offset;
-
-static int __init rockchip_uboot_mem_late_init(void)
-{
-	int err;
-
-	if (uboot_logo_size) {
-		void *start = phys_to_virt(uboot_logo_base);
-		void *end = phys_to_virt(uboot_logo_base + uboot_logo_size);
-
-		err = memblock_free(uboot_logo_base, uboot_logo_size);
-		if (err < 0)
-			pr_err("%s: freeing memblock failed: %d\n",
-			       __func__, err);
-		free_reserved_area(start, end, -1, "logo");
-	}
-	return 0;
-}
-
-late_initcall(rockchip_uboot_mem_late_init);
-
-int rk_fb_register(struct rk_lcdc_driver *dev_drv,
-		   struct rk_lcdc_win *win, int id)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
-	struct fb_info *fbi;
-	struct rk_fb_par *fb_par = NULL;
-	int i = 0, ret = 0, index = 0;
-	unsigned long flags;
-	char time_line_name[16];
-	int mirror = 0;
-
-	if (rk_fb->num_lcdc == RK30_MAX_LCDC_SUPPORT)
-		return -ENXIO;
-
-	for (i = 0; i < RK30_MAX_LCDC_SUPPORT; i++) {
-		if (!rk_fb->lcdc_dev_drv[i]) {
-			rk_fb->lcdc_dev_drv[i] = dev_drv;
-			rk_fb->lcdc_dev_drv[i]->id = id;
-			rk_fb->num_lcdc++;
-			break;
-		}
-	}
-
-	index = i;
-	init_lcdc_device_driver(rk_fb, win, index);
-	dev_drv->fb_index_base = rk_fb->num_fb;
-	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
-		fbi = framebuffer_alloc(0, &fb_pdev->dev);
-		if (!fbi) {
-			dev_err(&fb_pdev->dev, "fb framebuffer_alloc fail!");
-			return -ENOMEM;
-		}
-		fb_par = devm_kzalloc(&fb_pdev->dev, sizeof(struct rk_fb_par),
-				      GFP_KERNEL);
-		if (!fb_par) {
-			dev_err(&fb_pdev->dev, "malloc fb_par for fb%d fail!",
-				rk_fb->num_fb);
-			return -ENOMEM;
-		}
-		fb_par->id = rk_fb->num_fb;
-		fb_par->lcdc_drv = dev_drv;
-		fbi->par = (void *)fb_par;
-		fbi->var = def_var;
-		fbi->fix = def_fix;
-		sprintf(fbi->fix.id, "fb%d", rk_fb->num_fb);
-		fb_videomode_to_var(&fbi->var, &dev_drv->cur_screen->mode);
-		if (dev_drv->dsp_mode == ONE_VOP_DUAL_MIPI_VER_SCAN) {
-			fbi->var.xres /= 2;
-			fbi->var.yres *= 2;
-			fbi->var.xres_virtual /= 2;
-			fbi->var.yres_virtual *= 2;
-		}
-		fbi->var.width = dev_drv->cur_screen->width;
-		fbi->var.height = dev_drv->cur_screen->height;
-		fbi->var.grayscale |=
-		    ((fbi->var.xres & 0xfff) << 8) + (fbi->var.yres << 20);
-		fbi->var.reserved[0] |= (fbi->var.xres >> 12);
-#if defined(CONFIG_LOGO_LINUX_BMP)
-		fbi->var.bits_per_pixel = 32;
-#else
-		fbi->var.bits_per_pixel = 16;
-#endif
-		fbi->fix.line_length =
-		    (fbi->var.xres_virtual) * (fbi->var.bits_per_pixel >> 3);
-		if (dev_drv->iommu_enabled)
-			fb_ops.fb_mmap = rk_fb_mmap;
-		fbi->fbops = &fb_ops;
-		fbi->flags = FBINFO_FLAG_DEFAULT;
-		fbi->pseudo_palette = dev_drv->win[i]->pseudo_pal;
-		ret = register_framebuffer(fbi);
-		if (ret < 0) {
-			dev_err(&fb_pdev->dev,
-				"%s fb%d register_framebuffer fail!\n",
-				__func__, rk_fb->num_fb);
-			return ret;
-		}
-		rkfb_create_sysfs(fbi);
-		rk_fb->fb[rk_fb->num_fb] = fbi;
-		dev_info(fbi->dev, "rockchip framebuffer registerd:%s\n",
-			 fbi->fix.id);
-		rk_fb->num_fb++;
-
-		if (i == 0) {
-			init_waitqueue_head(&dev_drv->vsync_info.wait);
-			init_waitqueue_head(&dev_drv->update_regs_wait);
-			ret = device_create_file(fbi->dev, &dev_attr_vsync);
-			if (ret)
-				dev_err(fbi->dev,
-					"failed to create vsync file\n");
-			dev_drv->vsync_info.thread =
-			    kthread_run(rk_fb_wait_for_vsync_thread, dev_drv,
-					"fb-vsync");
-			if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) {
-				dev_err(fbi->dev,
-					"failed to run vsync thread\n");
-				dev_drv->vsync_info.thread = NULL;
-			}
-			dev_drv->vsync_info.active = 1;
-
-			mutex_init(&dev_drv->output_lock);
-
-			INIT_LIST_HEAD(&dev_drv->update_regs_list);
-			INIT_LIST_HEAD(&dev_drv->saved_list);
-			mutex_init(&dev_drv->update_regs_list_lock);
-			init_kthread_worker(&dev_drv->update_regs_worker);
-
-			dev_drv->update_regs_thread =
-			    kthread_run(kthread_worker_fn,
-					&dev_drv->update_regs_worker, "rk-fb");
-			if (IS_ERR(dev_drv->update_regs_thread)) {
-				int err = PTR_ERR(dev_drv->update_regs_thread);
-
-				dev_drv->update_regs_thread = NULL;
-				pr_info("failed to run update_regs thread\n");
-				return err;
-			}
-			init_kthread_work(&dev_drv->update_regs_work,
-					  rk_fb_update_regs_handler);
-
-			snprintf(time_line_name, sizeof(time_line_name),
-				 "vop%d-timeline", id);
-			dev_drv->timeline =
-			    sw_sync_timeline_create(time_line_name);
-			dev_drv->timeline_max = 1;
-		}
-	}
-
-	/* show logo for primary display device */
-#if !defined(CONFIG_FRAMEBUFFER_CONSOLE)
-	if (dev_drv->prop == PRMRY) {
-		u16 xact, yact;
-		int format;
-		u32 dsp_addr;
-		struct fb_info *main_fbi = rk_fb->fb[0];
-
-		main_fbi->fbops->fb_open(main_fbi, 1);
-		main_fbi->var.pixclock = dev_drv->pixclock;
-		if (dev_drv->iommu_enabled) {
-			if (dev_drv->mmu_dev)
-				rockchip_iovmm_set_fault_handler(dev_drv->dev,
-						rk_fb_sysmmu_fault_handler);
-		}
-
-		rk_fb_alloc_buffer(main_fbi);	/* only alloc memory for main fb */
-		dev_drv->uboot_logo = support_uboot_display();
-
-		if (dev_drv->uboot_logo &&
-		    uboot_logo_offset && uboot_logo_base) {
-			int width, height, bits, xvir;
-			phys_addr_t start = uboot_logo_base + uboot_logo_offset;
-			unsigned int size = uboot_logo_size - uboot_logo_offset;
-			unsigned int nr_pages;
-			int ymirror = 0;
-			struct page **pages;
-			char *vaddr;
-			int logo_len, i = 0;
-
-			if (dev_drv->ops->get_dspbuf_info)
-				dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
-					&yact, &format,	&dsp_addr, &ymirror);
-			logo_len = rk_fb_pixel_width(format) * xact * yact >> 3;
-			nr_pages = size >> PAGE_SHIFT;
-			pages = kzalloc(sizeof(struct page) * nr_pages,
-					GFP_KERNEL);
-			if (!pages)
-				return -ENOMEM;
-			while (i < nr_pages) {
-				pages[i] = phys_to_page(start);
-				start += PAGE_SIZE;
-				i++;
-			}
-			vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);
-			if (!vaddr) {
-				pr_err("failed to vmap phy addr 0x%lx\n",
-				       (long)(uboot_logo_base +
-				       uboot_logo_offset));
-				kfree(pages);
-				return -1;
-			}
-
-			if (bmpdecoder(vaddr, main_fbi->screen_base, &width,
-				       &height, &bits)) {
-				kfree(pages);
-				vunmap(vaddr);
-				return 0;
-			}
-			kfree(pages);
-			vunmap(vaddr);
-			if (width != xact || height != yact) {
-				pr_err("can't support uboot kernel logo use different size [%dx%d] != [%dx%d]\n",
-				       xact, yact, width, height);
-				return 0;
-			}
-			xvir = ALIGN(width * bits, 1 << 5) >> 5;
-			ymirror = 0;
-			local_irq_save(flags);
-			if (dev_drv->ops->wait_frame_start)
-				dev_drv->ops->wait_frame_start(dev_drv, 0);
-			mirror = ymirror || dev_drv->cur_screen->y_mirror;
-			if (dev_drv->ops->post_dspbuf) {
-				dev_drv->ops->post_dspbuf(dev_drv,
-					main_fbi->fix.smem_start +
-					(mirror ? logo_len : 0),
-					rk_fb_data_fmt(0, bits),
-					width, height, xvir,
-					ymirror);
-			}
-			if (dev_drv->iommu_enabled) {
-				rk_fb_poll_wait_frame_complete();
-				if (dev_drv->ops->mmu_en)
-					dev_drv->ops->mmu_en(dev_drv);
-				freed_index = 0;
-			}
-			local_irq_restore(flags);
-			return 0;
-		} else if (dev_drv->uboot_logo && uboot_logo_base) {
-			u32 start = uboot_logo_base;
-			int logo_len, i = 0;
-			int y_mirror = 0;
-			unsigned int nr_pages;
-			struct page **pages;
-			char *vaddr;
-			int align = 0, xvir;
-
-			dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
-						      &yact, &format,
-						      &start,
-						      &y_mirror);
-			logo_len = rk_fb_pixel_width(format) * xact * yact >> 3;
-			if (logo_len > uboot_logo_size ||
-			    logo_len > main_fbi->fix.smem_len) {
-				pr_err("logo size > uboot reserve buffer size\n");
-				return -1;
-			}
-			if (y_mirror)
-				start -= logo_len;
-
-			align = start % PAGE_SIZE;
-			start -= align;
-			nr_pages = PAGE_ALIGN(logo_len + align) >> PAGE_SHIFT;
-			pages = kzalloc(sizeof(struct page) * nr_pages,
-					GFP_KERNEL);
-			if (!pages)
-				return -ENOMEM;
-			while (i < nr_pages) {
-				pages[i] = phys_to_page(start);
-				start += PAGE_SIZE;
-				i++;
-			}
-			vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);
-			if (!vaddr) {
-				pr_err("failed to vmap phy addr 0x%x\n",
-				       start);
-				kfree(pages);
-				return -1;
-			}
-
-			memcpy(main_fbi->screen_base, vaddr + align, logo_len);
-
-			kfree(pages);
-			vunmap(vaddr);
-			xvir = ALIGN(xact * rk_fb_pixel_width(format),
-				     1 << 5) >> 5;
-			local_irq_save(flags);
-			if (dev_drv->ops->wait_frame_start)
-				dev_drv->ops->wait_frame_start(dev_drv, 0);
-			mirror = y_mirror || dev_drv->cur_screen->y_mirror;
-			dev_drv->ops->post_dspbuf(dev_drv,
-					main_fbi->fix.smem_start +
-					(mirror ? logo_len : 0),
-					format,	xact, yact,
-					xvir,
-					y_mirror);
-			if (dev_drv->iommu_enabled) {
-				rk_fb_poll_wait_frame_complete();
-				if (dev_drv->ops->mmu_en)
-					dev_drv->ops->mmu_en(dev_drv);
-				freed_index = 0;
-			}
-			local_irq_restore(flags);
-			return 0;
-		} else {
-			if (dev_drv->iommu_enabled) {
-				if (dev_drv->ops->mmu_en)
-					dev_drv->ops->mmu_en(dev_drv);
-				freed_index = 0;
-			}
-		}
-#if defined(CONFIG_LOGO)
-		main_fbi->fbops->fb_set_par(main_fbi);
-#if  defined(CONFIG_LOGO_LINUX_BMP)
-		if (fb_prewine_bmp_logo(main_fbi, FB_ROTATE_UR)) {
-			fb_set_cmap(&main_fbi->cmap, main_fbi);
-			fb_show_bmp_logo(main_fbi, FB_ROTATE_UR);
-		}
-#else
-		if (fb_prepare_logo(main_fbi, FB_ROTATE_UR)) {
-			fb_set_cmap(&main_fbi->cmap, main_fbi);
-			fb_show_logo(main_fbi, FB_ROTATE_UR);
-		}
-#endif
-		main_fbi->fbops->fb_pan_display(&main_fbi->var, main_fbi);
-#endif
-	} else {
-		struct fb_info *extend_fbi = rk_fb->fb[dev_drv->fb_index_base];
-
-		extend_fbi->var.pixclock = rk_fb->fb[0]->var.pixclock;
-		if (rk_fb->disp_mode == DUAL_LCD) {
-			extend_fbi->fbops->fb_open(extend_fbi, 1);
-			if (dev_drv->iommu_enabled) {
-				if (dev_drv->mmu_dev)
-					rockchip_iovmm_set_fault_handler(dev_drv->dev,
-									 rk_fb_sysmmu_fault_handler);
-			}
-			rk_fb_alloc_buffer(extend_fbi);
-		}
-	}
-#endif
-	return 0;
-}
-
-int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
-{
-	struct rk_fb *fb_inf = platform_get_drvdata(fb_pdev);
-	struct fb_info *fbi;
-	int fb_index_base = dev_drv->fb_index_base;
-	int fb_num = dev_drv->lcdc_win_num;
-	int i = 0;
-
-	if (fb_inf->lcdc_dev_drv[i]->vsync_info.thread) {
-		fb_inf->lcdc_dev_drv[i]->vsync_info.irq_stop = 1;
-		kthread_stop(fb_inf->lcdc_dev_drv[i]->vsync_info.thread);
-	}
-
-	for (i = 0; i < fb_num; i++)
-		kfree(dev_drv->win[i]);
-
-	for (i = fb_index_base; i < (fb_index_base + fb_num); i++) {
-		fbi = fb_inf->fb[i];
-		unregister_framebuffer(fbi);
-		/* rk_release_fb_buffer(fbi); */
-		framebuffer_release(fbi);
-	}
-	fb_inf->lcdc_dev_drv[dev_drv->id] = NULL;
-	fb_inf->num_lcdc--;
-
-	return 0;
-}
-
-int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
-				 int status)
-{
-	char *envp[3] = {"Request", "FORCE UPDATE", NULL};
-
-	if (status) {
-		car_reversing = 1;
-		flush_kthread_worker(&dev_drv->update_regs_worker);
-		dev_drv->timeline_max++;
-#ifdef H_USE_FENCE
-		sw_sync_timeline_inc(dev_drv->timeline, 1);
-#endif
-		pr_debug("%s: camcap reverse start...\n", __func__);
-	} else {
-		car_reversing = 0;
-		kobject_uevent_env(&dev_drv->dev->kobj,
-				   KOBJ_CHANGE, envp);
-		pr_debug("%s: camcap reverse finish...\n", __func__);
-	}
-
-	return 0;
-}
-
-static int rk_fb_probe(struct platform_device *pdev)
-{
-	struct rk_fb *rk_fb = NULL;
-	struct device_node *np = pdev->dev.of_node;
-	u32 mode, ret;
-	struct device_node *node;
-
-	if (!np) {
-		dev_err(&pdev->dev, "Missing device tree node.\n");
-		return -EINVAL;
-	}
-
-	rk_fb = devm_kzalloc(&pdev->dev, sizeof(struct rk_fb), GFP_KERNEL);
-	if (!rk_fb) {
-		dev_err(&pdev->dev, "kmalloc for rk fb fail!");
-		return -ENOMEM;
-	}
-	platform_set_drvdata(pdev, rk_fb);
-
-	if (!of_property_read_u32(np, "rockchip,disp-mode", &mode)) {
-		rk_fb->disp_mode = mode;
-
-	} else {
-		dev_err(&pdev->dev, "no disp-mode node found!");
-		return -ENODEV;
-	}
-
-	if (!of_property_read_u32(np, "rockchip,disp-policy", &mode)) {
-		rk_fb->disp_policy = mode;
-		pr_info("fb disp policy is %s\n",
-			rk_fb->disp_policy ? "box" : "sdk");
-	}
-
-	if (!of_property_read_u32(np, "rockchip,uboot-logo-on", &uboot_logo_on))
-		pr_info("uboot-logo-on:%d\n", uboot_logo_on);
-
-	dev_set_name(&pdev->dev, "rockchip-fb");
-#if defined(CONFIG_ION_ROCKCHIP)
-	rk_fb->ion_client = rockchip_ion_client_create("rk_fb");
-	if (IS_ERR(rk_fb->ion_client)) {
-		dev_err(&pdev->dev, "failed to create ion client for rk fb");
-		return PTR_ERR(rk_fb->ion_client);
-	} else {
-		dev_info(&pdev->dev, "rk fb ion client create success!\n");
-	}
-#endif
-
-	node = of_parse_phandle(np, "memory-region", 0);
-	if (node) {
-		struct resource r;
-
-		ret = of_address_to_resource(node, 0, &r);
-		if (ret)
-			return ret;
-
-		if (uboot_logo_on) {
-			uboot_logo_base = r.start;
-			uboot_logo_size = resource_size(&r);
-
-			if (uboot_logo_size > SZ_16M)
-				uboot_logo_offset = SZ_16M;
-			else
-				uboot_logo_offset = 0;
-		}
-		pr_info("logo: base=0x%llx, size=0x%llx, offset=0x%llx\n",
-			uboot_logo_base, uboot_logo_size, uboot_logo_offset);
-	}
-
-	fb_pdev = pdev;
-	dev_info(&pdev->dev, "rockchip framebuffer driver probe\n");
-	return 0;
-}
-
-static int rk_fb_remove(struct platform_device *pdev)
-{
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-static void rk_fb_shutdown(struct platform_device *pdev)
-{
-	struct rk_fb *rk_fb = platform_get_drvdata(pdev);
-	int i;
-
-	for (i = 0; i < rk_fb->num_lcdc; i++) {
-		if (!rk_fb->lcdc_dev_drv[i])
-			continue;
-		sw_sync_timeline_inc(rk_fb->lcdc_dev_drv[i]->timeline, 1);
-	}
-}
-
-static const struct of_device_id rkfb_dt_ids[] = {
-	{.compatible = "rockchip,rk-fb",},
-	{}
-};
-
-static struct platform_driver rk_fb_driver = {
-	.probe = rk_fb_probe,
-	.remove = rk_fb_remove,
-	.driver = {
-		   .name = "rk-fb",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(rkfb_dt_ids),
-		   },
-	.shutdown = rk_fb_shutdown,
-};
-
-static int __init rk_fb_init(void)
-{
-	return platform_driver_register(&rk_fb_driver);
-}
-
-static void __exit rk_fb_exit(void)
-{
-	platform_driver_unregister(&rk_fb_driver);
-}
-
-fs_initcall(rk_fb_init);
-module_exit(rk_fb_exit);
diff --git a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
deleted file mode 100644
index de8acc5d2df3..000000000000
--- a/drivers/video/rockchip/rkfb_sysfs.c
+++ /dev/null
@@ -1,1352 +0,0 @@
-/*
- * linux/drivers/video/rockchip/rkfb-sysfs.c
- *
- * Copyright (C) 2012 Rockchip Corporation
- * Author: yxj<yxj@rock-chips.com>
- *
- * Some code and ideas taken from
- *drivers/video/omap2/omapfb/omapfb-sys.c
- *driver by Tomi Valkeinen.
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <linux/fb.h>
-#include <linux/namei.h>
-#include <linux/sysfs.h>
-#include <linux/device.h>
-#include <linux/uaccess.h>
-#include <linux/platform_device.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <asm/div64.h>
-#include <linux/rk_screen.h>
-#include <linux/rk_fb.h>
-#if defined(CONFIG_ION_ROCKCHIP)
-#include <linux/rockchip_ion.h>
-#endif
-#include "bmp_helper.h"
-#include <linux/delay.h>
-struct rkfb_sys_trace {
-	int num_frames;
-	int count_frame;
-	int mask_win;
-	int mask_area;
-	bool is_bmp;
-	bool is_append;
-};
-#define DUMP_BUF_PATH		"/data/dmp_buf"
-
-static char *get_format_str(enum data_format format)
-{
-	switch (format) {
-	case ARGB888:
-		return "ARGB888";
-	case RGB888:
-		return "RGB888";
-	case RGB565:
-		return "RGB565";
-	case YUV420:
-	case YUV420_NV21:
-		return "YUV420";
-	case YUV422:
-		return "YUV422";
-	case YUV444:
-		return "YUV444";
-	case YUV420_A:
-		return "YUV420_A";
-	case YUV422_A:
-		return "YUV422_A";
-	case YUV444_A:
-		return "YUV444_A";
-	case XRGB888:
-		return "XRGB888";
-	case XBGR888:
-		return "XBGR888";
-	case ABGR888:
-		return "ABGR888";
-	case FBDC_RGB_565:
-		return "FBDC_RGB_565";
-	case FBDC_ARGB_888:
-		return "FBDC_ARGB_888";
-	case FBDC_RGBX_888:
-		return "FBDC_RGBX_888";
-	default:
-		return "invalid";
-	}
-}
-
-static ssize_t show_screen_info(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	int fps = 0;
-	u32 x = screen->mode.left_margin + screen->mode.right_margin +
-		screen->mode.xres + screen->mode.hsync_len;
-	u32 y = screen->mode.upper_margin + screen->mode.lower_margin +
-		screen->mode.yres + screen->mode.vsync_len;
-	u64 ft = (u64)x * y * (dev_drv->pixclock);
-
-	if (ft > 0)
-		fps = div64_u64(1000000000000llu, ft);
-	return snprintf(buf, PAGE_SIZE,
-			"xres:%d\nyres:%d\nfps:%d\ntype:%d\ninterlace:%d\n",
-			screen->mode.xres, screen->mode.yres,
-			fps, screen->type, screen->mode.vmode);
-}
-
-static ssize_t set_screen_info(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int xmirror = 0, ymirror = 0, ret = 0, rotate = 0;
-
-	ret = kstrtoint(buf, 0, &rotate);
-	if (ret)
-		return ret;
-	xmirror = !!(rotate & X_MIRROR);
-	ymirror = !!(rotate & Y_MIRROR);
-	dev_drv->cur_screen->x_mirror = xmirror;
-	dev_drv->cur_screen->y_mirror = ymirror;
-	dev_drv->rotate_mode = rotate;
-	mutex_lock(&dev_drv->output_lock);
-	mutex_lock(&dev_drv->win_config);
-	if (dev_drv->ops->extern_func)
-		dev_drv->ops->extern_func(dev_drv, SET_DSP_MIRROR);
-	mutex_unlock(&dev_drv->win_config);
-	mutex_unlock(&dev_drv->output_lock);
-
-	return count;
-}
-
-static ssize_t show_disp_info(struct device *dev,
-			      struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
-
-	if (dev_drv->ops->get_disp_info)
-		return dev_drv->ops->get_disp_info(dev_drv, buf, win_id);
-
-	return 0;
-}
-
-static void fill_buffer(void *handle, void *vaddr, int size)
-{
-	struct file *filp = handle;
-
-	if (filp)
-		vfs_write(filp, vaddr, size, &filp->f_pos);
-}
-
-static void read_buffer(void *handle, void *vaddr, int size, loff_t pos)
-{
-	struct file *filp = handle;
-
-	if (filp)
-		vfs_read(filp, vaddr, size, &pos);
-}
-
-static int dump_win(struct ion_client *ion_client,
-		    struct ion_handle *ion_handle, phys_addr_t phys_addr,
-		    int width, int height, u8 data_format, uint32_t frameid,
-		    int win_id, int area_id, bool is_bmp, bool is_append)
-{
-	void __iomem *vaddr = NULL;
-	struct file *filp;
-	mm_segment_t old_fs;
-	char name[100];
-	int flags;
-	int bits;
-
-	switch (data_format) {
-	case XRGB888:
-	case XBGR888:
-	case ARGB888:
-	case ABGR888:
-	case FBDC_RGBX_888:
-		bits = 32;
-		break;
-	case YUV444_A:
-	case YUV444:
-	case RGB888:
-	case FBDC_ARGB_888:
-		bits = 24;
-		break;
-	case RGB565:
-	case FBDC_RGB_565:
-	case YUV422:
-	case YUV422_A:
-		bits = 16;
-		break;
-	case YUV420_A:
-	case YUV420:
-	case YUV420_NV21:
-		bits = 12;
-		break;
-	default:
-		return 0;
-	}
-
-	if (ion_handle) {
-		vaddr = ion_map_kernel(ion_client, ion_handle);
-	} else if (phys_addr) {
-		unsigned long start;
-		unsigned int nr_pages;
-		struct page **pages;
-		int i = 0;
-
-		start = phys_addr;
-		nr_pages = roundup(width * height * (bits >> 3), PAGE_SIZE);
-		nr_pages /= PAGE_SIZE;
-		pages = kzalloc(sizeof(struct page) * nr_pages, GFP_KERNEL);
-		if (!pages)
-			return -ENOMEM;
-		while (i < nr_pages) {
-			pages[i] = phys_to_page(start);
-			start += PAGE_SIZE;
-			i++;
-		}
-		vaddr = vmap(pages, nr_pages, VM_MAP,
-			     pgprot_writecombine(PAGE_KERNEL));
-		if (!vaddr) {
-			pr_err("failed to vmap phy addr %lx\n",
-			       start);
-			return -1;
-		}
-	} else {
-		return 0;
-	}
-
-	flags = O_RDWR | O_CREAT | O_NONBLOCK;
-	if (is_append) {
-		snprintf(name, 100, "%s/append_win%d_%d_%dx%d_%s.%s",
-			 DUMP_BUF_PATH, win_id, area_id, width, height,
-			 get_format_str(data_format), is_bmp ? "bmp" : "bin");
-		flags |= O_APPEND;
-	} else {
-		snprintf(name, 100, "%s/frame%d_win%d_%d_%dx%d_%s.%s",
-			 DUMP_BUF_PATH, frameid, win_id, area_id, width, height,
-			 get_format_str(data_format), is_bmp ? "bmp" : "bin");
-	}
-
-	pr_info("dump win == > %s\n", name);
-	filp = filp_open(name, flags, 0x600);
-	if (!filp)
-		pr_err("fail to create %s\n", name);
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	if (is_bmp)
-		bmpencoder(vaddr, width, height,
-			   data_format, filp, fill_buffer);
-	else
-		fill_buffer(filp, vaddr, width * height * bits >> 3);
-
-	set_fs(old_fs);
-
-	if (ion_handle)
-		ion_unmap_kernel(ion_client, ion_handle);
-	else if (vaddr)
-		vunmap(vaddr);
-
-	filp_close(filp, NULL);
-
-	return 0;
-}
-
-static ssize_t show_dump_buffer(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	ssize_t size;
-
-	size = snprintf(buf, PAGE_SIZE,
-			"bmp       -- dump buffer to bmp image\n"
-			"             can't support dump to single file\n"
-			"bin       -- dump buffer to bin image\n"
-			"multi     -- each dump will create new file\n"
-			"             only works on trace context\n"
-			"win=num   -- mask win to dump, default mask all\n"
-			"             win=1, will dump win1 buffer\n"
-			"             win=23, will dump win2 area3 buffer\n"
-			"trace=num -- trace num frames buffer dump\n"
-			"             this option will block buffer switch\n"
-			"             so recommend use with bin and win=xx\n"
-			"\nExample:\n"
-			"echo bmp > dump_buf; -- dump current buf to bmp file\n"
-			"echo bin > dump_buf; -- dump current buf to bin file\n"
-			"echo trace=50:win=1:win=23 > dump_buf\n"
-			"         -- dump 50 frames, dump win1 and win2 area3\n"
-			"         -- dump all buffer to single file\n"
-			"You can found dump files at %s\n"
-			, DUMP_BUF_PATH);
-
-	return size;
-}
-
-void trace_buffer_dump(struct device *dev, struct rk_lcdc_driver *dev_drv)
-{
-	struct rk_fb *rk_fb = dev_get_drvdata(dev);
-	struct rk_fb_reg_data *front_regs;
-	struct rk_fb_reg_win_data *win_data;
-	struct rk_fb_reg_area_data *area_data;
-	struct rkfb_sys_trace *trace = dev_drv->trace_buf;
-	int i, j;
-
-	if (!trace)
-		return;
-	if (trace->num_frames <= trace->count_frame)
-		return;
-
-	if (!dev_drv->front_regs)
-		return;
-	front_regs = dev_drv->front_regs;
-
-	for (i = 0; i < front_regs->win_num; i++) {
-		if (trace->mask_win && !(trace->mask_win & (1 << i)))
-			continue;
-		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-			win_data = &front_regs->reg_win_data[i];
-			area_data = &win_data->reg_area_data[j];
-			if (trace->mask_area && !(trace->mask_area & (1 << j)))
-				continue;
-
-			dump_win(rk_fb->ion_client, area_data->ion_handle,
-				 area_data->smem_start,
-				 area_data->xvir, area_data->yvir,
-				 area_data->data_format, trace->count_frame,
-				 i, j, trace->is_bmp, trace->is_append);
-		}
-	}
-	trace->count_frame++;
-}
-
-static ssize_t set_dump_buffer(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
-	struct rk_fb_reg_data *front_regs;
-	struct rk_fb_reg_win_data *win_data;
-	struct rk_fb_reg_area_data *area_data;
-	struct rkfb_sys_trace *trace;
-	struct dentry *dentry;
-	struct path path;
-	int err = 0;
-	int num_frames = 0;
-	int mask_win = 0;
-	int mask_area = 0;
-	bool is_bmp = false;
-	bool is_append = true;
-	char *p;
-	int i, j;
-
-	if (!rk_fb->ion_client)
-		return 0;
-
-	if (!dev_drv->trace_buf) {
-		dev_drv->trace_buf = devm_kmalloc(dev_drv->dev,
-						  sizeof(struct rkfb_sys_trace),
-						  GFP_KERNEL);
-		if (!dev_drv->trace_buf)
-			return -ENOMEM;
-	}
-	trace = dev_drv->trace_buf;
-	/*
-	 * Stop buffer trace.
-	 */
-	trace->num_frames = 0;
-
-	while ((p = strsep((char **)&buf, ":")) != NULL) {
-		if (!*p)
-			continue;
-		if (!strncmp(p, "trace=", 6)) {
-			if (kstrtoint(p + 6, 0, &num_frames))
-				dev_err(dev, "can't found trace frames\n");
-			continue;
-		}
-		if (!strncmp(p, "win=", 4)) {
-			int win;
-
-			if (kstrtoint(p + 4, 0, &win))
-				dev_err(dev, "can't found trace frames\n");
-			if (win < 10) {
-			       mask_win |= 1 << win;
-			} else {
-				mask_win |= 1 << (win / 10);
-				mask_area |= 1 << (win % 10);
-			}
-
-			continue;
-		}
-		if (!strncmp(p, "bmp", 3)) {
-			is_bmp = true;
-			is_append = false;
-			continue;
-		}
-		if (!strncmp(p, "bin", 3)) {
-			is_bmp = false;
-			continue;
-		}
-		if (!strncmp(p, "multi", 5)) {
-			is_append = false;
-			continue;
-		}
-
-		dev_err(dev, "unknown option %s\n", p);
-	}
-
-	dentry = kern_path_create(AT_FDCWD, DUMP_BUF_PATH, &path,
-				  LOOKUP_DIRECTORY);
-	if (!IS_ERR(dentry)) {
-		err = vfs_mkdir(path.dentry->d_inode, dentry, 700);
-		if (err)
-			dev_err(dev, "can't create %s err%d\n",
-				DUMP_BUF_PATH, err);
-		done_path_create(&path, dentry);
-	} else if (PTR_ERR(dentry) != -EEXIST) {
-		dev_err(dev, "can't create PATH %s err%d\n",
-				DUMP_BUF_PATH, err);
-		return PTR_ERR(dentry);
-	}
-
-	mutex_lock(&dev_drv->front_lock);
-	if (!num_frames) {
-		if (!dev_drv->front_regs) {
-			u16 xact, yact;
-			int data_format;
-			u32 dsp_addr;
-			int ymirror;
-
-			if (dev_drv->ops->get_dspbuf_info)
-				dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
-						&yact, &data_format, &dsp_addr,
-						&ymirror);
-
-			dump_win(NULL, NULL, dsp_addr, xact, yact, data_format,
-				 0, 0, 0, is_bmp, false);
-			goto out;
-		}
-		front_regs = kmalloc(sizeof(*front_regs), GFP_KERNEL);
-		if (!front_regs) {
-			mutex_unlock(&dev_drv->front_lock);
-			return -ENOMEM;
-		}
-		memcpy(front_regs, dev_drv->front_regs, sizeof(*front_regs));
-
-		for (i = 0; i < front_regs->win_num; i++) {
-			if (mask_win && !(mask_win & (1 << i)))
-				continue;
-			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-				if (mask_area && !(mask_area & (1 << j)))
-					continue;
-				win_data = &front_regs->reg_win_data[i];
-				area_data = &win_data->reg_area_data[j];
-				if (area_data->ion_handle)
-					ion_handle_get(area_data->ion_handle);
-			}
-		}
-
-		for (i = 0; i < front_regs->win_num; i++) {
-			if (mask_win && !(mask_win & (1 << i)))
-				continue;
-			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
-				if (mask_area && !(mask_area & (1 << j)))
-					continue;
-
-				win_data = &front_regs->reg_win_data[i];
-				area_data = &win_data->reg_area_data[j];
-
-				dump_win(rk_fb->ion_client,
-					 area_data->ion_handle,
-					 area_data->smem_start,
-					 area_data->xvir, area_data->yvir,
-					 area_data->data_format,
-					 0, i, j, is_bmp, false);
-				if (area_data->ion_handle)
-					ion_handle_put(area_data->ion_handle);
-			}
-		}
-
-		kfree(front_regs);
-	} else {
-		trace->num_frames = num_frames;
-		trace->count_frame = 0;
-		trace->is_bmp = is_bmp;
-		trace->is_append = is_append;
-		trace->mask_win = mask_win;
-		trace->mask_area = mask_area;
-	}
-out:
-	mutex_unlock(&dev_drv->front_lock);
-	return count;
-}
-
-static ssize_t show_dsp_buffer(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	ssize_t size;
-
-	size = snprintf(buf, PAGE_SIZE,
-			"you can display a picture store in "
-			"/data/fb0.bin use the following cmd:\n"
-			"echo n xsize ysize format > dsp_buf\n"
-			"n: picture number"
-			"xsize: picture horizontal size\n"
-			"ysize: picture vertical size\n"
-			"format:\n"
-			"    RGBA=1,RGBX=2,RGB=3,YUV420SP=17");
-
-	return size;
-}
-extern int __close_fd(struct files_struct *files, unsigned fd);
-
-static ssize_t set_dsp_buffer(struct device *dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
-	struct file *filp;
-	mm_segment_t old_fs;
-	int width, height, frame_num;
-	int i, j, flags, fd;
-	const char *start = buf;
-	struct ion_handle *handle = NULL;
-	char __iomem *screen_base;
-	struct rk_fb_win_cfg_data *win_config = NULL;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	int space_max = 10;
-	int format;
-	size_t mem_size = 0;
-	char *name = "/data/fb0.bin";
-	struct sync_fence *acq_fence;
-	struct files_struct *files = current->files;
-
-	frame_num = simple_strtoul(start, NULL, 10);
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	width = simple_strtoul(start, NULL, 10);
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	height = simple_strtoul(start, NULL, 10);
-
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	format = simple_strtoul(start, NULL, 10);
-
-	pr_info("frame_num=%d,w=%d,h=%d,file=%s,format=%d\n",
-		frame_num, width, height, name, format);
-	flags = O_RDWR | O_CREAT | O_NONBLOCK;
-	filp = filp_open(name, flags, 0x600);
-	if (!filp)
-		pr_err("fail to create %s\n", name);
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	mem_size = width * height * 4 * frame_num;
-	if (dev_drv->iommu_enabled)
-		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
-				   ION_HEAP_SYSTEM_MASK, 0);
-	else
-		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
-				   ION_HEAP_TYPE_DMA_MASK, 0);
-	if (IS_ERR(handle)) {
-		pr_err("failed to ion_alloc:%ld\n", PTR_ERR(handle));
-		return -ENOMEM;
-	}
-	fd = ion_share_dma_buf_fd(rk_fb->ion_client, handle);
-	if (fd < 0) {
-		pr_err("ion_share_dma_buf_fd failed, fd=%d\n", fd);
-		return fd;
-	}
-	screen_base = ion_map_kernel(rk_fb->ion_client, handle);
-	read_buffer(filp, screen_base, mem_size, 0);
-	win_config =
-		kzalloc(sizeof(*win_config), GFP_KERNEL);
-	if (!win_config)
-		return -ENOMEM;
-
-	memset(win_config, 0, sizeof(struct rk_fb_win_cfg_data));
-	win_config->wait_fs = 0;
-	win_config->win_par[0].win_id = 0;
-	win_config->win_par[0].z_order = 0;
-	win_config->win_par[0].area_par[0].data_format = format;
-	win_config->win_par[0].area_par[0].ion_fd = fd;
-	win_config->win_par[0].area_par[0].x_offset = 0;
-	win_config->win_par[0].area_par[0].y_offset = 0;
-	win_config->win_par[0].area_par[0].xpos = 0;
-	win_config->win_par[0].area_par[0].ypos = 0;
-	win_config->win_par[0].area_par[0].xsize = screen->mode.xres;
-	win_config->win_par[0].area_par[0].ysize = screen->mode.yres;
-	win_config->win_par[0].area_par[0].xact = width;
-	win_config->win_par[0].area_par[0].yact = height;
-	win_config->win_par[0].area_par[0].xvir = width;
-	win_config->win_par[0].area_par[0].yvir = height;
-
-	for (i = 0; i < frame_num; i++) {
-		win_config->win_par[0].area_par[0].y_offset = height * i;
-		fbi->fbops->fb_ioctl(fbi, RK_FBIOSET_CONFIG_DONE,
-				     (unsigned long)(win_config));
-		for (j = 0; j < RK_MAX_BUF_NUM; j++) {
-			if (win_config->rel_fence_fd[j] > 0) {
-				acq_fence =
-				sync_fence_fdget(win_config->rel_fence_fd[j]);
-				sync_fence_put(acq_fence);
-			}
-		}
-
-		if (win_config->ret_fence_fd > 0) {
-			acq_fence =
-			sync_fence_fdget(win_config->ret_fence_fd);
-			sync_fence_put(acq_fence);
-		}
-	}
-
-	ion_unmap_kernel(rk_fb->ion_client, handle);
-	ion_free(rk_fb->ion_client, handle);
-	__close_fd(files, fd);
-
-	set_fs(old_fs);
-	filp_close(filp, NULL);
-	kfree(win_config);
-	return count;
-}
-
-static ssize_t show_phys(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "0x%lx-----0x%x\n",
-			fbi->fix.smem_start, fbi->fix.smem_len);
-}
-
-static ssize_t show_virt(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "0x%p-----0x%x\n",
-			fbi->screen_base, fbi->fix.smem_len);
-}
-
-static ssize_t show_fb_state(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
-	int state = dev_drv->ops->get_win_state(dev_drv, win_id, 0);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", state ? "enabled" : "disabled");
-}
-
-static ssize_t show_dual_mode(struct device *dev,
-			      struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
-	int mode = rk_fb->disp_mode;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", mode);
-}
-
-static ssize_t set_fb_state(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
-	int state;
-	int ret;
-
-	ret = kstrtoint(buf, 0, &state);
-	if (ret)
-		return ret;
-	dev_drv->ops->open(dev_drv, win_id, state);
-	if (state) {
-		dev_drv->ops->set_par(dev_drv, win_id);
-		dev_drv->ops->pan_display(dev_drv, win_id);
-		dev_drv->ops->cfg_done(dev_drv);
-	}
-	return count;
-}
-
-static ssize_t show_overlay(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int ovl = 0;
-
-	if (dev_drv->ops->ovl_mgr)
-		ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
-
-	if (ovl < 0)
-		return ovl;
-
-	return snprintf(buf, PAGE_SIZE, "%s\n",
-			ovl ? "win0 on the top of win1" :
-			"win1 on the top of win0");
-}
-
-static ssize_t set_overlay(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	u32 ovl;
-	int ret;
-
-	ret = kstrtou32(buf, 0, &ovl);
-	if (ret)
-		return ret;
-	if (dev_drv->ops->ovl_mgr)
-		ret = dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
-	if (ret < 0)
-		return ret;
-
-	return count;
-}
-
-static ssize_t show_fps(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int fps = 0;
-
-	if (dev_drv->ops->fps_mgr)
-		fps = dev_drv->ops->fps_mgr(dev_drv, 0, 0);
-	if (fps < 0)
-		return fps;
-
-	return snprintf(buf, PAGE_SIZE, "fps:%d\n", fps);
-}
-
-static ssize_t set_fps(struct device *dev, struct device_attribute *attr,
-		       const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	struct rk_screen *screen = dev_drv->cur_screen;
-	u32 fps, origin_fps;
-	int ret;
-
-	ret = kstrtou32(buf, 0, &fps);
-	if (ret)
-		return ret;
-
-	origin_fps = rk_fb_calc_fps(screen, dev_drv->pixclock);
-
-	/*
-	 * use too low or too high fps would make screen abnormal,
-	 * and maybe can't recovery, so limit the fps.
-	 */
-	if (fps <= 40 || fps > origin_fps)
-		fps = origin_fps;
-
-	if (dev_drv->ops->fps_mgr)
-		ret = dev_drv->ops->fps_mgr(dev_drv, fps, 1);
-	if (ret < 0)
-		return ret;
-
-	return count;
-}
-
-static ssize_t show_fb_win_map(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	int ret;
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	mutex_lock(&dev_drv->fb_win_id_mutex);
-	ret =
-	    snprintf(buf, PAGE_SIZE, "fb0:win%d\nfb1:win%d\nfb2:win%d\n",
-		     dev_drv->fb0_win_id, dev_drv->fb1_win_id,
-		     dev_drv->fb2_win_id);
-	mutex_unlock(&dev_drv->fb_win_id_mutex);
-
-	return ret;
-}
-
-static ssize_t set_fb_win_map(struct device *dev, struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	u32 order;
-	int ret;
-
-	ret = kstrtou32(buf, 0, &order);
-	if ((order != FB0_WIN2_FB1_WIN1_FB2_WIN0) &&
-	    (order != FB0_WIN1_FB1_WIN2_FB2_WIN0) &&
-	    (order != FB0_WIN2_FB1_WIN0_FB2_WIN1) &&
-	    (order != FB0_WIN0_FB1_WIN2_FB2_WIN1) &&
-	    (order != FB0_WIN0_FB1_WIN1_FB2_WIN2) &&
-	    (order != FB0_WIN1_FB1_WIN0_FB2_WIN2)) {
-		dev_info(dev, "un supported map\n"
-		       "you can use the following order:\n" "201:\n"
-		       "fb0-win1\n" "fb1-win0\n" "fb2-win2\n" "210:\n"
-		       "fb0-win0\n" "fb1-win1\n" "fb2-win2\n" "120:\n"
-		       "fb0-win0\n" "fb1-win2\n" "fb2-win1\n" "102:\n"
-		       "fb0-win2\n" "fb1-win0\n" "fb2-win1\n" "021:\n"
-		       "fb0-win1\n" "fb1-win2\n" "fb2-win0\n" "012:\n"
-		       "fb0-win2\n" "fb1-win1\n" "fb2-win0\n");
-		return count;
-	} else {
-		if (dev_drv->ops->fb_win_remap)
-			dev_drv->ops->fb_win_remap(dev_drv, order);
-	}
-
-	return count;
-}
-
-static ssize_t show_hwc_lut(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t set_hwc_lut(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	int *hwc_lut = NULL;
-	const char *start = buf;
-	int i = 256, temp;
-	int space_max;
-
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	hwc_lut = kzalloc(256 * 4, GFP_KERNEL);
-	if (!hwc_lut)
-		return -ENOMEM;
-	/*printk("count:%d\n>>%s\n\n",count,start);*/
-	for (i = 0; i < 256; i++) {
-		space_max = 15;	/*max space number 15*/
-		temp = simple_strtoul(start, NULL, 16);
-		hwc_lut[i] = temp;
-		do {
-			start++;
-			space_max--;
-		} while ((*start != ' ') && space_max);
-
-		if (!space_max)
-			break;
-		else
-			start++;
-	}
-	if (dev_drv->ops->set_hwc_lut)
-		dev_drv->ops->set_hwc_lut(dev_drv, hwc_lut, 1);
-	kfree(hwc_lut);
-
-	return count;
-}
-
-static ssize_t show_cabc_lut(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t set_cabc_lut(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	int *cabc_lut = NULL;
-	const char *start = buf;
-	int i = 256, temp;
-	int space_max = 10;
-
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	cabc_lut = kzalloc(256 * 4, GFP_KERNEL);
-	if (!cabc_lut)
-		return -ENOMEM;
-	for (i = 0; i < 256; i++) {
-		temp = i;
-		/*init by default value*/
-		cabc_lut[i] = temp + (temp << 8) + (temp << 16);
-	}
-	for (i = 0; i < 256; i++) {
-		space_max = 10;	/*max space number 10*/
-		temp = simple_strtoul(start, NULL, 10);
-		cabc_lut[i] = temp;
-		do {
-			start++;
-			space_max--;
-		} while ((*start != ' ') && space_max);
-
-		if (!space_max)
-			break;
-		else
-			start++;
-	}
-	if (dev_drv->ops->set_cabc_lut)
-		dev_drv->ops->set_cabc_lut(dev_drv, cabc_lut);
-
-	kfree(cabc_lut);
-	return count;
-}
-
-static ssize_t show_dsp_lut(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t set_dsp_lut(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	int *dsp_lut = NULL;
-	const char *start = buf;
-	int i = 256, temp;
-	int space_max = 10;
-
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	dsp_lut = kzalloc(256 * 4, GFP_KERNEL);
-	if (!dsp_lut)
-		return -ENOMEM;
-	for (i = 0; i < 256; i++) {
-		temp = i;
-		/*init by default value*/
-		dsp_lut[i] = temp + (temp << 8) + (temp << 16);
-	}
-	/*printk("count:%d\n>>%s\n\n",count,start);*/
-	for (i = 0; i < 256; i++) {
-		space_max = 10;	/*max space number 10*/
-		temp = simple_strtoul(start, NULL, 10);
-		dsp_lut[i] = temp;
-		do {
-			start++;
-			space_max--;
-		} while ((*start != ' ') && space_max);
-
-		if (!space_max)
-			break;
-		else
-			start++;
-	}
-	if (dev_drv->ops->set_dsp_lut)
-		dev_drv->ops->set_dsp_lut(dev_drv, dsp_lut);
-
-	kfree(dsp_lut);
-	return count;
-}
-
-static ssize_t show_dsp_cabc(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return snprintf(buf, PAGE_SIZE, "cabc mode=%d\n",
-		dev_drv->cabc_mode);
-	return 0;
-}
-
-static ssize_t set_dsp_cabc(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int space_max, ret = 0;
-	int mode = 0, calc = 0, up = 0, down = 0, global = 0;
-	const char *start = buf;
-
-	space_max = 10;	/*max space number 10*/
-	mode = simple_strtoul(start, NULL, 10);
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	calc = simple_strtoul(start, NULL, 10);
-
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	up  = simple_strtoul(start, NULL, 10);
-
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	down = simple_strtoul(start, NULL, 10);
-
-	do {
-		start++;
-		space_max--;
-	} while ((*start != ' ') && space_max);
-	start++;
-	global = simple_strtoul(start, NULL, 10);
-
-	if (dev_drv->ops->set_dsp_cabc)
-		ret = dev_drv->ops->set_dsp_cabc(dev_drv, mode,
-						 calc, up, down, global);
-	if (ret < 0)
-		return ret;
-
-	return count;
-}
-
-static ssize_t show_dsp_bcsh(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int brightness = 0, contrast = 0, sat_con = 0, sin_hue = 0, cos_hue = 0;
-
-	if (dev_drv->ops->get_dsp_bcsh_bcs) {
-		brightness = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv,
-							    BRIGHTNESS);
-		contrast = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv, CONTRAST);
-		sat_con = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv, SAT_CON);
-	}
-	if (dev_drv->ops->get_dsp_bcsh_hue) {
-		sin_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv, H_SIN);
-		cos_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv, H_COS);
-	}
-	return snprintf(buf, PAGE_SIZE,
-			"brightness:%4d,contrast:%4d,sat_con:%4d,"
-			"sin_hue:%4d,cos_hue:%4d\n",
-			brightness, contrast, sat_con, sin_hue, cos_hue);
-}
-
-static ssize_t set_dsp_bcsh(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int brightness, contrast, sat_con, ret = 0, sin_hue, cos_hue;
-
-	if (!strncmp(buf, "open", 4)) {
-		if (dev_drv->ops->open_bcsh)
-			ret = dev_drv->ops->open_bcsh(dev_drv, 1);
-		else
-			ret = -1;
-	} else if (!strncmp(buf, "close", 5)) {
-		if (dev_drv->ops->open_bcsh)
-			ret = dev_drv->ops->open_bcsh(dev_drv, 0);
-		else
-			ret = -1;
-	} else if (!strncmp(buf, "brightness", 10)) {
-		sscanf(buf, "brightness %d", &brightness);
-		if (unlikely(brightness > 255)) {
-			dev_err(fbi->dev,
-				"brightness should be [0:255],now=%d\n\n",
-				brightness);
-			brightness = 255;
-		}
-		if (dev_drv->ops->set_dsp_bcsh_bcs)
-			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
-							     BRIGHTNESS,
-							     brightness);
-		else
-			ret = -1;
-	} else if (!strncmp(buf, "contrast", 8)) {
-		sscanf(buf, "contrast %d", &contrast);
-		if (unlikely(contrast > 510)) {
-			dev_err(fbi->dev,
-				"contrast should be [0:510],now=%d\n",
-				contrast);
-			contrast = 510;
-		}
-		if (dev_drv->ops->set_dsp_bcsh_bcs)
-			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
-							     CONTRAST,
-							     contrast);
-		else
-			ret = -1;
-	} else if (!strncmp(buf, "sat_con", 7)) {
-		sscanf(buf, "sat_con %d", &sat_con);
-		if (unlikely(sat_con > 1015)) {
-			dev_err(fbi->dev,
-				"sat_con should be [0:1015],now=%d\n",
-				sat_con);
-			sat_con = 1015;
-		}
-		if (dev_drv->ops->set_dsp_bcsh_bcs)
-			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
-							     SAT_CON,
-							     sat_con);
-		else
-			ret = -1;
-	} else if (!strncmp(buf, "hue", 3)) {
-		sscanf(buf, "hue %d %d", &sin_hue, &cos_hue);
-		if (unlikely(sin_hue > 511 || cos_hue > 511)) {
-			dev_err(fbi->dev, "sin_hue=%d,cos_hue=%d\n",
-				sin_hue, cos_hue);
-		}
-		if (dev_drv->ops->set_dsp_bcsh_hue)
-			ret = dev_drv->ops->set_dsp_bcsh_hue(dev_drv,
-							     sin_hue,
-							     cos_hue);
-		else
-			ret = -1;
-	} else {
-		dev_info(dev, "format error\n");
-	}
-
-	if (ret < 0)
-		return ret;
-
-	return count;
-}
-
-static ssize_t show_scale(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return snprintf(buf, PAGE_SIZE,
-		"xscale=%d yscale=%d\nleft=%d top=%d right=%d bottom=%d\n",
-		(dev_drv->overscan.left + dev_drv->overscan.right) / 2,
-		(dev_drv->overscan.top + dev_drv->overscan.bottom) / 2,
-		dev_drv->overscan.left, dev_drv->overscan.top,
-		dev_drv->overscan.right, dev_drv->overscan.bottom);
-}
-
-static ssize_t set_scale(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	u32 left, top, right, bottom;
-
-	if (!strncmp(buf, "overscan", 8)) {
-		sscanf(buf,
-		       "overscan %d,%d,%d,%d", &left, &top, &right, &bottom);
-		if (left > 0 && left <= 100)
-			dev_drv->overscan.left = left;
-		if (top > 0 && top <= 100)
-			dev_drv->overscan.top = top;
-		if (right > 0 && right <= 100)
-			dev_drv->overscan.right = right;
-		if (bottom > 0 && bottom <= 100)
-			dev_drv->overscan.bottom = bottom;
-	} else if (!strncmp(buf, "left", 4)) {
-		sscanf(buf, "left=%d", &left);
-		if (left > 0 && left <= 100)
-			dev_drv->overscan.left = left;
-	} else if (!strncmp(buf, "top", 3)) {
-		sscanf(buf, "top=%d", &top);
-		if (top > 0 && top <= 100)
-			dev_drv->overscan.top = top;
-	} else if (!strncmp(buf, "right", 5)) {
-		sscanf(buf, "right=%d", &right);
-		if (right > 0 && right <= 100)
-			dev_drv->overscan.right = right;
-	} else if (!strncmp(buf, "bottom", 6)) {
-		sscanf(buf, "bottom=%d", &bottom);
-		if (bottom > 0 && bottom <= 100)
-			dev_drv->overscan.bottom = bottom;
-	} else if (!strncmp(buf, "xscale", 6)) {
-		sscanf(buf, "xscale=%d", &left);
-		if (left > 0 && left <= 100) {
-			dev_drv->overscan.left = left;
-			dev_drv->overscan.right = left;
-		}
-	} else if (!strncmp(buf, "yscale", 6)) {
-		sscanf(buf, "yscale=%d", &left);
-		if (left > 0 && left <= 100) {
-			dev_drv->overscan.top = left;
-			dev_drv->overscan.bottom = left;
-		}
-	} else {
-		sscanf(buf, "%d", &left);
-		if (left > 0 && left <= 100) {
-			dev_drv->overscan.left = left;
-			dev_drv->overscan.right = left;
-			dev_drv->overscan.top = left;
-			dev_drv->overscan.bottom = left;
-		}
-	}
-
-	if (dev_drv->ops->set_overscan)
-		dev_drv->ops->set_overscan(dev_drv, &dev_drv->overscan);
-
-	return count;
-}
-
-static ssize_t show_lcdc_id(struct device *dev,
-			    struct device_attribute *attr,
-			    char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->id);
-}
-
-static ssize_t show_dsp_mode(struct device *dev,
-			    struct device_attribute *attr,
-			    char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->dsp_mode);
-}
-
-static ssize_t show_hot_plug_state(struct device *dev,
-			    struct device_attribute *attr,
-			    char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->hot_plug_state);
-}
-
-static ssize_t show_win_property(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	int win_id = 0;
-
-	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
-	return snprintf(buf, PAGE_SIZE,
-			"feature: %d, max_input_x: %d, max_input_y: %d\n",
-			dev_drv->win[win_id]->property.feature,
-			dev_drv->win[win_id]->property.max_input_x,
-			dev_drv->win[win_id]->property.max_input_y);
-}
-
-static ssize_t set_car_reverse(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	struct fb_info *fbi = dev_get_drvdata(dev);
-	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
-	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
-	u32 status;
-	int ret;
-
-	ret = kstrtou32(buf, 0, &status);
-	if (ret)
-		return ret;
-	rk_fb_set_car_reverse_status(dev_drv, status);
-
-	return count;
-}
-
-static struct device_attribute rkfb_attrs[] = {
-	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
-	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
-	__ATTR(disp_info, S_IRUGO, show_disp_info, NULL),
-	__ATTR(dump_buf, S_IRUGO | S_IWUSR, show_dump_buffer, set_dump_buffer),
-	__ATTR(dsp_buf, S_IRUGO | S_IWUSR, show_dsp_buffer, set_dsp_buffer),
-	__ATTR(screen_info, S_IRUGO | S_IWUSR,
-	       show_screen_info, set_screen_info),
-	__ATTR(dual_mode, S_IRUGO, show_dual_mode, NULL),
-	__ATTR(enable, S_IRUGO | S_IWUSR, show_fb_state, set_fb_state),
-	__ATTR(overlay, S_IRUGO | S_IWUSR, show_overlay, set_overlay),
-	__ATTR(fps, S_IRUGO | S_IWUSR, show_fps, set_fps),
-	__ATTR(map, S_IRUGO | S_IWUSR, show_fb_win_map, set_fb_win_map),
-	__ATTR(dsp_lut, S_IRUGO | S_IWUSR, show_dsp_lut, set_dsp_lut),
-	__ATTR(cabc_lut, S_IRUGO | S_IWUSR, show_cabc_lut, set_cabc_lut),
-	__ATTR(hwc_lut, S_IRUGO | S_IWUSR, show_hwc_lut, set_hwc_lut),
-	__ATTR(cabc, S_IRUGO | S_IWUSR, show_dsp_cabc, set_dsp_cabc),
-	__ATTR(bcsh, S_IRUGO | S_IWUSR, show_dsp_bcsh, set_dsp_bcsh),
-	__ATTR(scale, S_IRUGO | S_IWUSR, show_scale, set_scale),
-	__ATTR(lcdcid, S_IRUGO, show_lcdc_id, NULL),
-	__ATTR(win_property, S_IRUGO, show_win_property, NULL),
-	__ATTR(car_reverse, S_IWUSR, NULL, set_car_reverse),
-	__ATTR(dsp_mode, S_IRUGO, show_dsp_mode, NULL),
-	__ATTR(hot_plug_state, S_IRUGO, show_hot_plug_state, NULL),
-};
-
-int rkfb_create_sysfs(struct fb_info *fbi)
-{
-	int r, t;
-
-	for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++) {
-		r = device_create_file(fbi->dev, &rkfb_attrs[t]);
-		if (r) {
-			dev_err(fbi->dev, "failed to create sysfs " "file\n");
-			return r;
-		}
-	}
-
-	return 0;
-}
-
-void rkfb_remove_sysfs(struct rk_fb *rk_fb)
-{
-	int i, t;
-
-	for (i = 0; i < rk_fb->num_fb; i++) {
-		for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++)
-			device_remove_file(rk_fb->fb[i]->dev, &rkfb_attrs[t]);
-	}
-}
diff --git a/drivers/video/rockchip/screen/.gitignore b/drivers/video/rockchip/screen/.gitignore
deleted file mode 100644
index 262e546db00b..000000000000
--- a/drivers/video/rockchip/screen/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-*lcd.h
diff --git a/drivers/video/rockchip/screen/Kconfig b/drivers/video/rockchip/screen/Kconfig
deleted file mode 100644
index 0292045dbff5..000000000000
--- a/drivers/video/rockchip/screen/Kconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-choice
-	depends on FB_ROCKCHIP || DRM_ROCKCHIP
-	prompt  "LCD Panel Select"
-
-config LCD_GENERAL
-	bool "General lcd panel"
-	help 
-	  select if the panel do not need initialization
-config LCD_MIPI
-	bool "rk mipi dsi lcd"	
-endchoice
-
-
diff --git a/drivers/video/rockchip/screen/Makefile b/drivers/video/rockchip/screen/Makefile
deleted file mode 100644
index 50df4d986cac..000000000000
--- a/drivers/video/rockchip/screen/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_LCD_GENERAL)			+= lcd_general.o
-obj-$(CONFIG_LCD_MIPI)	+= lcd_mipi.o
-
-
-quiet_cmd_gen = GEN     $@
-      cmd_gen = cmp -s $< $@ || cp $< $@
-
-lcd-obj := $(filter lcd_%.o,$(obj-y))
-lcd-cfile := $(patsubst %.o,%.c,$(lcd-obj))
-lcd-cpath := $(src)/$(lcd-cfile)
-
-obj-y := $(filter-out $(lcd-obj),$(obj-y))
-
-$(obj)/lcd.h: $(lcd-cpath)  FORCE
-	$(call if_changed,gen)
-
-$(obj)/rk_screen.o: $(obj)/lcd.h
-obj-y += rk_screen.o
-
-clean-files := lcd.h
diff --git a/drivers/video/rockchip/screen/lcd_general.c b/drivers/video/rockchip/screen/lcd_general.c
deleted file mode 100644
index 86e394fa822b..000000000000
--- a/drivers/video/rockchip/screen/lcd_general.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef __LCD_NULL__
-#define __LCD_NULL__
-
-
-
-#endif
-
diff --git a/drivers/video/rockchip/screen/lcd_mipi.c b/drivers/video/rockchip/screen/lcd_mipi.c
deleted file mode 100644
index 2514c71a960c..000000000000
--- a/drivers/video/rockchip/screen/lcd_mipi.c
+++ /dev/null
@@ -1,747 +0,0 @@
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * drivers/video/rockchip/screen/lcd_mipi.c
- * author: libing@rock-chips.com
- * create date: 2014-04-10
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef CONFIG_LCD_MIPI
-#include <common.h>
-#endif
-#ifdef CONFIG_LCD_MIPI
-#include "../transmitter/mipi_dsi.h"
-#include <linux/delay.h>
-#endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-#include <common.h>
-#include <asm/io.h>
-#include <errno.h>
-#include <malloc.h>
-#include <fdtdec.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/rkplat.h>
-#include <lcd.h>
-#include "../transmitter/mipi_dsi.h"
-#endif
-
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-#define	MIPI_SCREEN_DBG(x...)	/* printf(x) */
-#elif defined CONFIG_LCD_MIPI
-#define	MIPI_SCREEN_DBG(x...)	/* printk(KERN_ERR x) */
-#else
-#define	MIPI_SCREEN_DBG(x...)
-#endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-DECLARE_GLOBAL_DATA_PTR;
-#define	printk(x...)	/* printf(x) */
-#endif
-static struct mipi_screen *gmipi_screen;
-
-static inline void mipidelay(unsigned int msecs)
-{
-	usleep_range(msecs * 1000, msecs * 1000 + 200);
-}
-
-static void rk_mipi_screen_pwr_disable(struct mipi_screen *screen)
-{
-	if (screen->lcd_en_gpio != INVALID_GPIO) {
-		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
-		mipidelay(screen->lcd_en_delay);
-	} else{
-		MIPI_SCREEN_DBG("lcd_en_gpio is null");
-	}
-
-	if (screen->lcd_rst_gpio != INVALID_GPIO) {
-
-		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
-		mipidelay(screen->lcd_rst_delay);
-	} else {
-		MIPI_SCREEN_DBG("lcd_rst_gpio is null");
-	}
-}
-
-static void rk_mipi_screen_pwr_enable(struct mipi_screen *screen)
-{
-	if (screen->lcd_en_gpio != INVALID_GPIO) {
-		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
-		mipidelay(screen->lcd_en_delay);
-		gpio_direction_output(screen->lcd_en_gpio, screen->lcd_en_atv_val);
-		mipidelay(screen->lcd_en_delay);
-	} else
-		MIPI_SCREEN_DBG("lcd_en_gpio is null\n");
-
-	if (screen->lcd_rst_gpio != INVALID_GPIO) {
-		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
-		mipidelay(screen->lcd_rst_delay);
-		gpio_direction_output(screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
-		mipidelay(screen->lcd_rst_delay);
-	} else
-		MIPI_SCREEN_DBG("lcd_rst_gpio is null\n");
-}
-
-static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
-{
-	u8 len, i;
-	u8 *cmds;
-	struct list_head *screen_pos;
-	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-	cmds = calloc(1, 0x400);
-	if (!cmds) {
-		printf("request cmds fail!\n");
-		return;
-	}
-#endif
-
-#ifdef CONFIG_LCD_MIPI
-	cmds = kmalloc(0x400, GFP_KERNEL);
-	if (!cmds) {
-		printk("request cmds fail!\n");
-		return ;
-	}
-#endif
-	list_for_each(screen_pos, &screen->cmdlist_head) {
-		dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list);
-		len = dcs_cmd->dcs_cmd.cmd_len + 1;
-		for (i = 1; i < len ; i++) {
-			cmds[i] = dcs_cmd->dcs_cmd.cmds[i-1];
-		}
-		MIPI_SCREEN_DBG("dcs_cmd.name:%s\n", dcs_cmd->dcs_cmd.name);
-		if (dcs_cmd->dcs_cmd.type == LPDT) {
-			cmds[0] = LPDT;
-			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
-				dsi_send_packet(0, cmds, len);
-			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
-				dsi_send_packet(1, cmds, len);
-			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
-				dsi_send_packet(0, cmds, len);
-				dsi_send_packet(1, cmds, len);
-			} else {
-				MIPI_SCREEN_DBG("dsi is err.\n");
-			}
-			if (dcs_cmd->dcs_cmd.delay)
-				mipidelay(dcs_cmd->dcs_cmd.delay);
-		} else if (dcs_cmd->dcs_cmd.type == HSDT) {
-			cmds[0] = HSDT;
-			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
-				dsi_send_packet(0, cmds, len);
-			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
-				dsi_send_packet(1, cmds, len);
-			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
-				dsi_send_packet(0, cmds, len);
-				dsi_send_packet(1, cmds, len);
-			} else {
-				MIPI_SCREEN_DBG("dsi is err.");
-			}
-			if (dcs_cmd->dcs_cmd.delay)
-				mipidelay(dcs_cmd->dcs_cmd.delay);
-		} else
-			MIPI_SCREEN_DBG("cmd type err.\n");
-	}
-
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-	free(cmds);
-#endif
-#ifdef CONFIG_LCD_MIPI
-	kfree(cmds);
-#endif
-}
-
-int rk_mipi_screen(void)
-{
-	u8 dcs[16] = {0}, rk_dsi_num;
-	rk_dsi_num = gmipi_screen->mipi_dsi_num;
-	if (gmipi_screen->screen_init == 0) {
-		rk_mipi_screen_pwr_enable(gmipi_screen);
-		dsi_enable_hs_clk(0, 1);
-		if (rk_dsi_num == 2) {
-			dsi_enable_hs_clk(1, 1);
-		}
-
-		dsi_enable_command_mode(0, 1);
-		if (rk_dsi_num == 2) {
-			dsi_enable_command_mode(1, 1);
-		}
-
-		dcs[0] = LPDT;
-		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_exit_sleep_mode;
-		dsi_send_packet(0, dcs, 3);
-		if (rk_dsi_num == 2)
-			dsi_send_packet(1, dcs, 3);
-
-		mipidelay(20);
-
-		dcs[0] = LPDT;
-		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_set_display_on;
-		dsi_send_packet(0, dcs, 3);
-		if (rk_dsi_num == 2)
-			dsi_send_packet(1, dcs, 3);
-
-		mipidelay(20);
-	} else {
-		rk_mipi_screen_pwr_enable(gmipi_screen);
-
-		dsi_enable_hs_clk(0, 1);
-		if (rk_dsi_num == 2) {
-			dsi_enable_hs_clk(1, 1);
-		}
-
-		dsi_enable_command_mode(0, 1);
-		if (rk_dsi_num == 2) {
-			dsi_enable_command_mode(1, 1);
-		}
-
-		rk_mipi_screen_cmd_init(gmipi_screen);
-	}
-
-	MIPI_SCREEN_DBG("++++++++++++++++%s:%d\n", __func__, __LINE__);
-	return 0;
-}
-
-int rk_mipi_screen_standby(u8 enable)
-{
-	u8 dcs[16] = {0}, rk_dsi_num;
-	rk_dsi_num = gmipi_screen->mipi_dsi_num;
-
-	if (dsi_is_active(0) != 1)
-		return -1;
-
-	if (rk_dsi_num == 2)
-		if ((dsi_is_active(0) != 1) || (dsi_is_active(1) != 1))
-			return -1;
-
-	if (enable) {
-		/* below is changeable */
-		dcs[0] = LPDT;
-		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_set_display_off;
-		dsi_send_packet(0, dcs, 3);
-		if (rk_dsi_num == 2)
-			dsi_send_packet(1, dcs, 3);
-
-		mipidelay(30);
-
-		dcs[0] = LPDT;
-		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_enter_sleep_mode;
-		dsi_send_packet(0, dcs, 3);
-		if (rk_dsi_num == 2)
-			dsi_send_packet(1, dcs, 3);
-
-		mipidelay(100);
-		rk_mipi_screen_pwr_disable(gmipi_screen);
-		MIPI_SCREEN_DBG("++++enable++++++++++++%s:%d\n", __func__, __LINE__);
-	} else {
-		rk_mipi_screen();
-	}
-	return 0;
-}
-#ifdef CONFIG_LCD_MIPI
-static int rk_mipi_screen_init_dt(struct device *dev,
-				  struct mipi_screen *screen)
-{
-	struct device_node *childnode, *grandchildnode, *root;
-	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
-	struct list_head *pos;
-	struct property *prop;
-	enum of_gpio_flags flags;
-	u32 value, i, debug, gpio, ret, length;
-
-	memset(screen, 0, sizeof(*screen));
-
-	INIT_LIST_HEAD(&screen->cmdlist_head);
-
-	childnode = of_find_node_by_name(NULL, "mipi_dsi_init");
-	if (!childnode) {
-		MIPI_SCREEN_DBG("%s: Can not get child => mipi_init.\n", __func__);
-	} else {
-		ret = of_property_read_u32(childnode, "rockchip,screen_init", &value);
-		if (ret) {
-			MIPI_SCREEN_DBG("%s: Can not read property: screen_init.\n", __func__);
-		} else {
-			if ((value != 0) && (value != 1)) {
-				printk("err: rockchip,mipi_dsi_init not match.\n");
-				return -1;
-			} else
-				screen->screen_init = value ;
-
-			MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init);
-		}
-
-		ret = of_property_read_u32(childnode, "rockchip,dsi_lane", &value);
-		if (ret) {
-			MIPI_SCREEN_DBG("%s: Can not read property: dsi_lane.\n", __func__);
-		} else {
-			screen->dsi_lane = value;
-			MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane);
-		}
-
-		ret = of_property_read_u32(childnode, "rockchip,dsi_hs_clk", &value);
-		if (ret) {
-			MIPI_SCREEN_DBG("%s: Can not read property: dsi_hs_clk.\n", __func__);
-		} else {
-			if ((value <= 90) || (value >= 1500)) {
-				printk("err: rockchip,hs_tx_clk not match.");
-				return -1;
-			} else {
-				screen->hs_tx_clk = value*MHz;
-			}
-
-			MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk);
-		}
-
-		ret = of_property_read_u32(childnode, "rockchip,mipi_dsi_num", &value);
-		if (ret) {
-			MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
-		} else {
-			if ((value != 1) && (value != 2)) {
-				printk("err: rockchip,mipi_dsi_num not match.\n");
-				return -1;
-			} else {
-				screen->mipi_dsi_num = value ;
-			}
-
-			MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num);
-		}
-	}
-
-	childnode = of_find_node_by_name(NULL, "mipi_power_ctr");
-	if (!childnode) {
-		screen->lcd_rst_gpio = INVALID_GPIO;
-		screen->lcd_en_gpio = INVALID_GPIO;
-		MIPI_SCREEN_DBG("%s: Can not get child => mipi_power_ctr.\n", __func__);
-	} else {
-		grandchildnode = of_find_node_by_name(childnode, "mipi_lcd_rst");
-		if (!grandchildnode) {
-			screen->lcd_rst_gpio = INVALID_GPIO;
-			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_rst.\n", __func__);
-		} else {
-			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-			if (ret) {
-				MIPI_SCREEN_DBG("%s: Can not read property: delay.\n", __func__);
-			} else {
-				screen->lcd_rst_delay = value;
-				MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay);
-			}
-
-			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-			if (!gpio_is_valid(gpio)) {
-				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
-			}
-
-			ret = gpio_request(gpio, "mipi_lcd_rst");
-			if (ret) {
-				screen->lcd_rst_gpio = INVALID_GPIO;
-				MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n", gpio);
-				return -1;
-			}
-
-			screen->lcd_rst_gpio = gpio;
-			screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
-
-			MIPI_SCREEN_DBG("lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n", screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
-		}
-
-		grandchildnode = of_find_node_by_name(childnode, "mipi_lcd_en");
-		if (!grandchildnode) {
-			screen->lcd_en_gpio = INVALID_GPIO;
-			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en.\n", __func__);
-		} else {
-			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-			if (ret) {
-				MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en-delay.\n", __func__);
-			} else {
-				screen->lcd_en_delay = value;
-				MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay);
-			}
-
-			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-			if (!gpio_is_valid(gpio)) {
-				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
-			}
-
-			ret = gpio_request(gpio, "mipi_lcd_en");
-			if (ret) {
-				screen->lcd_en_gpio = INVALID_GPIO;
-				MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n", gpio);
-				return -1;
-			}
-			screen->lcd_en_gpio = gpio;
-			screen->lcd_en_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
-			MIPI_SCREEN_DBG("dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n", screen->lcd_en_gpio, screen->lcd_en_atv_val);
-		}
-	}
-
-	root = of_find_node_by_name(NULL, "screen-on-cmds");
-	if (!root) {
-		MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
-	} else {
-		for_each_child_of_node(root, childnode) {
-			dcs_cmd = kmalloc(sizeof(struct mipi_dcs_cmd_ctr_list), GFP_KERNEL);
-			strcpy(dcs_cmd->dcs_cmd.name, childnode->name);
-
-			prop = of_find_property(childnode, "rockchip,cmd", &length);
-			if (!prop) {
-				MIPI_SCREEN_DBG("Can not read property: cmds\n");
-				return -EINVAL;
-			}
-
-			MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n", childnode->name, (length / sizeof(u32)));
-
-			dcs_cmd->dcs_cmd.cmds =
-				devm_kzalloc(dev, length, GFP_KERNEL);
-			if (!dcs_cmd->dcs_cmd.cmds) {
-				pr_err("malloc cmds fail!\n");
-				return -ENOMEM;
-			}
-
-			ret = of_property_read_u32_array(childnode,
-							 "rockchip,cmd",
-							 dcs_cmd->dcs_cmd.cmds,
-							 length / sizeof(u32));
-			if (ret < 0) {
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__, childnode->name);
-				kfree(dcs_cmd->dcs_cmd.cmds);
-				dcs_cmd->dcs_cmd.cmds = NULL;
-				return ret;
-			} else {
-				dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32);
-			}
-			ret = of_property_read_u32(childnode, "rockchip,dsi_id", &value);
-			if (ret) {
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
-			} else {
-				if (screen->mipi_dsi_num == 1) {
-					if (value != 0) {
-						printk("err: rockchip,dsi_id not match.\n");
-					} else {
-						dcs_cmd->dcs_cmd.dsi_id = value;
-					}
-				} else {
-					if ((value < 0) || (value > 2))
-						printk("err: rockchip,dsi_id not match.\n");
-					else
-						dcs_cmd->dcs_cmd.dsi_id = value;
-				}
-			}
-
-			ret = of_property_read_u32(childnode, "rockchip,cmd_type", &value);
-			if (ret) {
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
-			} else {
-				if ((value != 0) && (value != 1)) {
-					printk("err: rockchip, cmd_type not match.\n");
-				} else {
-					dcs_cmd->dcs_cmd.type = value;
-				}
-			}
-
-			ret = of_property_read_u32(childnode, "rockchip,cmd_delay", &value);
-			if (ret)
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__, childnode->name);
-			else
-				dcs_cmd->dcs_cmd.delay = value;
-
-			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
-		}
-	}
-	ret = of_property_read_u32(root, "rockchip,cmd_debug", &debug);
-	if (ret) {
-		MIPI_SCREEN_DBG("%s: Can not read property: rockchip,cmd_debug.\n", __func__);
-	} else {
-		if (debug) {
-			list_for_each(pos, &screen->cmdlist_head) {
-				dcs_cmd = list_entry(pos, struct mipi_dcs_cmd_ctr_list, list);
-				printk("\n dcs_name:%s,dcs_type:%d,side_id:%d,cmd_len:%d,delay:%d\n\n",
-					dcs_cmd->dcs_cmd.name,
-					dcs_cmd->dcs_cmd.type,
-					dcs_cmd->dcs_cmd.dsi_id,
-					dcs_cmd->dcs_cmd.cmd_len,
-					dcs_cmd->dcs_cmd.delay);
-				for (i = 0; i < (dcs_cmd->dcs_cmd.cmd_len); i++) {
-					printk("[%d]=%02x,", i+1, dcs_cmd->dcs_cmd.cmds[i]);
-				}
-			}
-		} else {
-			MIPI_SCREEN_DBG("---close cmd debug---\n");
-		}
-	}
-	return 0;
-}
-#endif
-int rk_mipi_get_dsi_num(void)
-{
-	return gmipi_screen->mipi_dsi_num;
-}
-#ifdef CONFIG_LCD_MIPI
-EXPORT_SYMBOL(rk_mipi_get_dsi_num);
-#endif
-
-int rk_mipi_get_dsi_lane(void)
-{
-	return gmipi_screen->dsi_lane;
-}
-#ifdef CONFIG_LCD_MIPI
-EXPORT_SYMBOL(rk_mipi_get_dsi_lane);
-#endif
-
-int rk_mipi_get_dsi_clk(void)
-{
-	return gmipi_screen->hs_tx_clk;
-}
-#ifdef CONFIG_LCD_MIPI
-EXPORT_SYMBOL(rk_mipi_get_dsi_clk);
-#endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-#ifdef CONFIG_OF_LIBFDT
-static int rk_mipi_screen_init_dt(struct mipi_screen *screen)
-{
-	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
-	u32 i;
-	int length;
-	int err;
-	int node;
-	const void *blob;
-	struct fdt_gpio_state gpio_val;
-	int noffset;
-
-	INIT_LIST_HEAD(&screen->cmdlist_head);
-
-	blob = gd->fdt_blob; /* getenv_hex("fdtaddr", 0); */
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_INIT);
-	if (node < 0) {
-		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_INIT\n");
-	}
-	screen->screen_init = fdtdec_get_int(blob, node, "rockchip,screen_init", -1);
-	if (screen->screen_init < 0) {
-		MIPI_SCREEN_DBG("Can not get screen_init\n");
-	}
-	screen->dsi_lane = fdtdec_get_int(blob, node, "rockchip,dsi_lane", -1);
-	if (screen->dsi_lane < 0) {
-		MIPI_SCREEN_DBG("Can not get dsi_lane\n");
-	}
-	screen->hs_tx_clk = fdtdec_get_int(blob, node, "rockchip,dsi_hs_clk", -1);
-	if (screen->hs_tx_clk < 0) {
-		MIPI_SCREEN_DBG("Can not get dsi_hs_clk\n");
-	} else {
-		screen->hs_tx_clk = screen->hs_tx_clk*MHZ;
-	}
-	screen->mipi_dsi_num = fdtdec_get_int(blob, node, "rockchip,mipi_dsi_num", -1);
-	if (screen->mipi_dsi_num < 0) {
-		MIPI_SCREEN_DBG("Can't get mipi_dsi_num\n");
-	}
-#if 0
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-	if (node < 0) {
-		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-	}
-#endif
-
-#if 0
-/*get the lcd rst status
-	handle = fdt_getprop_u32_default(blob, "/mipi_power_ctr", "mipi_lcd_rst", -1);
-	node = fdt_node_offset_by_phandle(blob, handle);
-*/
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-	if (node < 0) {
-		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-	} else {
-		subnode = fdtdec_next_compatible_subnode(blob, node,
-				COMPAT_ROCKCHIP_MIPI_LCD_RST, &depth);
-		if (subnode <= 0) {
-			screen->lcd_rst_gpio = INVALID_GPIO;
-			printf("Can't get pin of mipi_lcd_rst\n");
-		} else {
-			err = fdtdec_decode_gpio(blob, subnode, "rockchip,gpios", &gpio_val);
-			gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-			if (err < 0) {
-				screen->lcd_rst_gpio = INVALID_GPIO;
-				printf("Can't find GPIO rst\n");
-			} else {
-				screen->lcd_rst_gpio = gpio_val.gpio;
-				screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-			}
-			screen->lcd_rst_delay = fdtdec_get_int(blob, subnode, "rockchip,delay", -1);
-			if (screen->lcd_rst_delay < 0) {
-				printf("Can't get delay of rst delay\n");
-			}
-			printf("Get lcd rst gpio and delay successfully!\n");
-		}
-	}
-#endif
-	/* get the lcd rst & en status */
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-	if (node < 0) {
-		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-	} else {
-#if 0
-		noffset = fdt_first_subnode(blob, node);
-		const char *name = fdt_get_name(blob, noffset, NULL);
-		printf("XJH_DEBUG1:%s\n", name);
-		noffset = fdt_next_subnode(blob, noffset);
-		const char *name1 = fdt_get_name(blob, noffset, NULL);
-		printf("XJH_DEBUG2:%s\n", name1);
-#endif
-		for (noffset = fdt_first_subnode(blob, node);
-		noffset >= 0;
-		noffset = fdt_next_subnode(blob, noffset)) {
-			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_rst")) {
-				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
-				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-				if (err < 0) {
-					screen->lcd_rst_gpio = INVALID_GPIO;
-					MIPI_SCREEN_DBG("Can't find GPIO rst\n");
-				} else {
-					screen->lcd_rst_gpio = gpio_val.gpio;
-					screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-				}
-				screen->lcd_rst_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
-				if (screen->lcd_rst_delay < 0) {
-					MIPI_SCREEN_DBG("Can't get delay of rst delay\n");
-				}
-				MIPI_SCREEN_DBG("Get lcd rst gpio and delay successfully!\n");
-			}
-			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_en")) {
-				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
-				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-				if (err < 0) {
-					screen->lcd_en_gpio = INVALID_GPIO;
-					MIPI_SCREEN_DBG("Can't find GPIO en\n");
-				} else {
-					screen->lcd_en_gpio = gpio_val.gpio;
-					screen->lcd_en_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-				}
-				screen->lcd_en_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
-				if (screen->lcd_en_delay < 0) {
-					MIPI_SCREEN_DBG("Can't get delay of lcd_en delay\n");
-				}
-				MIPI_SCREEN_DBG("Get lcd en gpio and delay successfully:delay %d!\n", screen->lcd_en_delay);
-			}
-		}
-	}
-
-	/*get the initial command list*/
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_SONCMDS);
-	if (node < 0) {
-		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_SONCMDS\n");
-	} else {
-		for (noffset = fdt_first_subnode(blob, node);
-		noffset >= 0;
-		noffset = fdt_next_subnode(blob, noffset)) {
-
-			MIPI_SCREEN_DBG("build MIPI LCD init cmd tables\n");
-			/*
-			subnode = fdtdec_next_compatible_subnode(blob, node,
-					COMPAT_ROCKCHIP_MIPI_ONCMDS, &depth);
-			if (noffset < 0)
-				break;
-			*/
-			dcs_cmd = calloc(1, sizeof(struct mipi_dcs_cmd_ctr_list));
-			/* node = fdt_node_offset_by_phandle(blob, handle); */
-			strcpy(dcs_cmd->dcs_cmd.name, fdt_get_name(blob, noffset, NULL));
-			MIPI_SCREEN_DBG("%s\n", dcs_cmd->dcs_cmd.name);
-			dcs_cmd->dcs_cmd.type = fdtdec_get_int(blob, noffset, "rockchip,cmd_type", -1);
-			MIPI_SCREEN_DBG("dcs_cmd.type=%02x\n", dcs_cmd->dcs_cmd.type);
-			dcs_cmd->dcs_cmd.dsi_id = fdtdec_get_int(blob, noffset, "rockchip,dsi_id", -1);
-			MIPI_SCREEN_DBG("dcs_cmd.dsi_id=%02x\n", dcs_cmd->dcs_cmd.dsi_id);
-			fdt_getprop(blob, noffset, "rockchip,cmd", &length);
-			dcs_cmd->dcs_cmd.cmd_len = length / sizeof(u32) ;
-
-			dcs_cmd->dcs_cmd.cmds = calloc(1, length);
-			if (!dcs_cmd->dcs_cmd.cmds) {
-				pr_err("calloc cmds fail!\n");
-				return -1;
-			}
-
-			err = fdtdec_get_int_array(blob, noffset,
-						   "rockchip,cmd",
-						   dcs_cmd->dcs_cmd.cmds,
-						   dcs_cmd->dcs_cmd.cmd_len);
-			dcs_cmd->dcs_cmd.delay = fdtdec_get_int(blob, noffset, "rockchip,cmd_delay", -1);
-			MIPI_SCREEN_DBG("dcs_cmd.delay=%d\n", dcs_cmd->dcs_cmd.delay);
-			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
-		}
-	}
-	return 0;
-}
-#endif /* CONFIG_OF_LIBFDT */
-
-int rk_mipi_screen_probe(void)
-{
-	int ret = 0;
-	gmipi_screen = calloc(1, sizeof(struct mipi_screen));
-	if (!gmipi_screen) {
-		printf("request struct screen fail!\n");
-		return -ENOMEM;
-	}
-#ifdef CONFIG_OF_LIBFDT
-	ret = rk_mipi_screen_init_dt(gmipi_screen);
-	if (ret < 0) {
-		printf(" rk_mipi_screen_init_dt fail!\n");
-		return -1;
-	}
-#endif /* CONFIG_OF_LIBFDT */
-
-	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
-	return 0;
-}
-
-#endif /* CONFIG_RK_3288_DSI_UBOOT */
-#ifdef CONFIG_LCD_MIPI
-static int __init rk_mipi_screen_probe(struct platform_device *pdev)
-{
-	static int ret;
-
-	gmipi_screen = devm_kzalloc(&pdev->dev, sizeof(struct mipi_screen), GFP_KERNEL);
-	if (!gmipi_screen) {
-		dev_err(&pdev->dev, "request struct screen fail!\n");
-		return -ENOMEM;
-	}
-
-	ret = rk_mipi_screen_init_dt(&pdev->dev, gmipi_screen);
-	if (ret < 0) {
-		dev_err(&pdev->dev, " rk_mipi_screen_init_dt fail!\n");
-		return -1;
-	}
-
-	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
-	return 0;
-}
-
-static struct platform_driver mipi_screen_platform_driver = {
-	.driver = {
-		.name = "rk_mipi_screen",
-	},
-};
-
-static int __init rk_mipi_screen_init(void)
-{
-	platform_device_register_simple("rk_mipi_screen", -1, NULL, 0);
-	return platform_driver_probe(&mipi_screen_platform_driver, rk_mipi_screen_probe);
-}
-
-static void __exit rk_mipi_screen_exit(void)
-{
-	platform_driver_unregister(&mipi_screen_platform_driver);
-}
-
-subsys_initcall_sync(rk_mipi_screen_init);
-module_exit(rk_mipi_screen_exit);
-#endif
diff --git a/drivers/video/rockchip/screen/rk_screen.c b/drivers/video/rockchip/screen/rk_screen.c
deleted file mode 100644
index 76676f55d9d4..000000000000
--- a/drivers/video/rockchip/screen/rk_screen.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/rk_fb.h>
-#include <linux/device.h>
-#include "lcd.h"
-#include "../hdmi/rockchip-hdmi.h"
-
-static struct rk_screen *rk_screen;
-
-int rk_fb_get_extern_screen(struct rk_screen *screen)
-{
-	if (unlikely(!rk_screen) || unlikely(!screen))
-		return -1;
-
-	memcpy(screen, rk_screen, sizeof(struct rk_screen));
-	screen->dsp_lut = NULL;
-	screen->cabc_lut = NULL;
-	screen->type = SCREEN_NULL;
-
-	return 0;
-}
-
-int  rk_fb_get_prmry_screen(struct rk_screen *screen)
-{
-	if (unlikely(!rk_screen) || unlikely(!screen))
-		return -1;
-
-	memcpy(screen, rk_screen, sizeof(struct rk_screen));
-	return 0;
-}
-
-int rk_fb_set_prmry_screen(struct rk_screen *screen)
-{
-	if (unlikely(!rk_screen) || unlikely(!screen))
-		return -1;
-
-	rk_screen->lcdc_id = screen->lcdc_id;
-	rk_screen->screen_id = screen->screen_id;
-	rk_screen->x_mirror = screen->x_mirror;
-	rk_screen->y_mirror = screen->y_mirror;
-	rk_screen->overscan.left = screen->overscan.left;
-	rk_screen->overscan.top = screen->overscan.left;
-	rk_screen->overscan.right = screen->overscan.left;
-	rk_screen->overscan.bottom = screen->overscan.left;
-	return 0;
-}
-
-size_t get_fb_size(u8 reserved_fb)
-{
-	size_t size = 0;
-	u32 xres = 0;
-	u32 yres = 0;
-
-	if (unlikely(!rk_screen))
-		return 0;
-
-	xres = rk_screen->mode.xres;
-	yres = rk_screen->mode.yres;
-
-	/* align as 64 bytes(16*4) in an odd number of times */
-	xres = ALIGN_64BYTE_ODD_TIMES(xres, ALIGN_PIXEL_64BYTE_RGB8888);
-        if (reserved_fb == 1) {
-                size = (xres * yres << 2) << 1;/*two buffer*/
-        } else {
-#if defined(CONFIG_THREE_FB_BUFFER)
-		size = (xres * yres << 2) * 3;	/* three buffer */
-#else
-		size = (xres * yres << 2) << 1; /* two buffer */
-#endif
-	}
-	return ALIGN(size, SZ_1M);
-}
-
-static int rk_screen_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	int ret;
-
-	if (!np) {
-		dev_err(&pdev->dev, "Missing device tree node.\n");
-		return -EINVAL;
-	}
-	rk_screen = devm_kzalloc(&pdev->dev,
-			sizeof(struct rk_screen), GFP_KERNEL);
-	if (!rk_screen) {
-		dev_err(&pdev->dev, "kmalloc for rk screen fail!");
-		return  -ENOMEM;
-	}
-	ret = rk_fb_prase_timing_dt(np, rk_screen);
-	dev_info(&pdev->dev, "rockchip screen probe %s\n",
-				ret ? "failed" : "success");
-	return ret;
-}
-
-static const struct of_device_id rk_screen_dt_ids[] = {
-	{ .compatible = "rockchip,screen", },
-	{}
-};
-
-static struct platform_driver rk_screen_driver = {
-	.probe		= rk_screen_probe,
-	.driver		= {
-		.name	= "rk-screen",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(rk_screen_dt_ids),
-	},
-};
-
-static int __init rk_screen_init(void)
-{
-	return platform_driver_register(&rk_screen_driver);
-}
-
-static void __exit rk_screen_exit(void)
-{
-	platform_driver_unregister(&rk_screen_driver);
-}
-
-fs_initcall(rk_screen_init);
-module_exit(rk_screen_exit);
-
diff --git a/include/dt-bindings/display/screen-timing/lcd-86v-rgb1024x600.dtsi b/include/dt-bindings/display/screen-timing/lcd-86v-rgb1024x600.dtsi
deleted file mode 100644
index dcca65671ffb..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-86v-rgb1024x600.dtsi
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_RGB1024x600 FOR 86V
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P666>;
-		clock-frequency = <60000000>;
-		hactive = <1024>;
-		vactive = <600>;
-		hback-porch = <100>;
-		hfront-porch = <120>;
-		vback-porch = <10>;
-		vfront-porch = <15>;
-		hsync-len = <100>;
-		vsync-len = <10>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-F402.dtsi b/include/dt-bindings/display/screen-timing/lcd-F402.dtsi
deleted file mode 100644
index 0a7a45ad935e..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-F402.dtsi
+++ /dev/null
@@ -1,124 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. DisplayPort screen LP097QX1
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_EDP>;
-		out-face    = <OUT_P666>;
-		clock-frequency = <205000000>;
-		hactive = <1536>;
-		vactive = <2048>;
-		hback-porch = <48>;
-		hfront-porch = <12>;
-		vback-porch = <8>;
-		vfront-porch = <8>;
-		hsync-len = <16>;
-		vsync-len = <4>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		dsp-lut = <0x00000000 0x00010101 0x00020202 0x00030303 0x00040404 0x00050505 0x00060606 0x00070707 0x00080808 0x00090909
-				0x000a0a0a 0x000b0b0b 0x000c0c0c 0x000d0d0d 0x000e0e0e 0x000f0f0f 0x00101010 0x00111111 0x00121212 0x00131313
-				0x00141414 0x00151515 0x00161616 0x00171717 0x00181818 0x00191919 0x001a1a1a 0x001b1b1b 0x001c1c1c 0x001d1d1d
-				0x001e1e1e 0x001f1f1f 0x00202020 0x00212121 0x00222222 0x00232323 0x00242424 0x00252525 0x00262626 0x00272727
-				0x00282828 0x00292929 0x002a2a2a 0x002b2b2b 0x002c2c2c 0x002d2d2d 0x002e2e2e 0x002f2f2f 0x00303030 0x00313131
-				0x00323232 0x00333333 0x00343434 0x00353535 0x00363636 0x00373737 0x00383838 0x00393939 0x003a3a3a 0x003b3b3b
-				0x003c3c3c 0x003d3d3d 0x003e3e3e 0x003f3f3f 0x00404040 0x00414141 0x00424242 0x00434343 0x00444444 0x00454545
-				0x00464646 0x00474747 0x00484848 0x00494949 0x004a4a4a 0x004b4b4b 0x004c4c4c 0x004d4d4d 0x004e4e4e 0x004f4f4f
-				0x00505050 0x00515151 0x00525252 0x00535353 0x00545454 0x00555555 0x00565656 0x00575757 0x00585858 0x00595959
-				0x005a5a5a 0x005b5b5b 0x005c5c5c 0x005d5d5d 0x005e5e5e 0x005f5f5f 0x00606060 0x00616161 0x00626262 0x00636363
-				0x00646464 0x00656565 0x00666666 0x00676767 0x00686868 0x00696969 0x006a6a6a 0x006b6b6b 0x006c6c6c 0x006d6d6d
-				0x006e6e6e 0x006f6f6f 0x00707070 0x00717171 0x00727272 0x00737373 0x00747474 0x00757575 0x00767676 0x00777777
-				0x00787878 0x00797979 0x007a7a7a 0x007b7b7b 0x007c7c7c 0x007d7d7d 0x007e7e7e 0x007f7f7f 0x00808080 0x00818181
-				0x00828282 0x00838383 0x00848484 0x00858585 0x00868686 0x00878787 0x00888888 0x00898989 0x008a8a8a 0x008b8b8b
-				0x008c8c8c 0x008d8d8d 0x008e8e8e 0x008f8f8f 0x00909090 0x00919191 0x00929292 0x00939393 0x00949494 0x00959595
-				0x00969696 0x00979797 0x00989898 0x00999999 0x009a9a9a 0x009b9b9b 0x009c9c9c 0x009d9d9d 0x009e9e9e 0x009f9f9f
-				0x00a0a0a0 0x00a1a1a1 0x00a2a2a2 0x00a3a3a3 0x00a4a4a4 0x00a5a5a5 0x00a6a6a6 0x00a7a7a7 0x00a8a8a8 0x00a9a9a9
-				0x00aaaaaa 0x00ababab 0x00acacac 0x00adadad 0x00aeaeae 0x00afafaf 0x00b0b0b0 0x00b1b1b1 0x00b2b2b2 0x00b3b3b3
-				0x00b4b4b4 0x00b5b5b5 0x00b6b6b6 0x00b7b7b7 0x00b8b8b8 0x00b9b9b9 0x00bababa 0x00bbbbbb 0x00bcbcbc 0x00bdbdbd
-				0x00bebebe 0x00bfbfbf 0x00c0c0c0 0x00c1c1c1 0x00c2c2c2 0x00c3c3c3 0x00c4c4c4 0x00c5c5c5 0x00c6c6c6 0x00c7c7c7
-				0x00c8c8c8 0x00c9c9c9 0x00cacaca 0x00cbcbcb 0x00cccccc 0x00cdcdcd 0x00cecece 0x00cfcfcf 0x00d0d0d0 0x00d1d1d1
-				0x00d2d2d2 0x00d3d3d3 0x00d4d4d4 0x00d5d5d5 0x00d6d6d6 0x00d7d7d7 0x00d8d8d8 0x00d9d9d9 0x00dadada 0x00dbdbdb
-				0x00dcdcdc 0x00dddddd 0x00dedede 0x00dfdfdf 0x00e0e0e0 0x00e1e1e1 0x00e2e2e2 0x00e3e3e3 0x00e4e4e4 0x00e5e5e5
-				0x00e6e6e6 0x00e7e7e7 0x00e8e8e8 0x00e9e9e9 0x00eaeaea 0x00ebebeb 0x00ececec 0x00ededed 0x00eeeeee 0x00efefef
-				0x00f0f0f0 0x00f1f1f1 0x00f2f2f2 0x00f3f3f3 0x00f4f4f4 0x00f5f5f5 0x00f6f6f6 0x00f7f7f7 0x00f8f8f8 0x00f9f9f9
-				0x00fafafa 0x00fbfbfb 0x00fcfcfc 0x00fdfdfd 0x00fefefe 0x00ffffff>;
-		cabc-lut = <
-			/*gamma = 2.2*/
-				0x00000383 0x00000392 0x000003a2 0x000003b2 0x000003c2 0x000003d2 0x000003e2 0x000003f3
-				0x00000403 0x00000414 0x00000425 0x00000436 0x00000447 0x00000458 0x0000046a 0x0000047b
-				0x0000048d 0x0000049f 0x000004b1 0x000004c3 0x000004d5 0x000004e8 0x000004fa 0x0000050d
-				0x00000520 0x00000533 0x00000546 0x0000055a 0x0000056d 0x00000581 0x00000595 0x000005a9
-				0x000005bd 0x000005d1 0x000005e5 0x000005fa 0x0000060f 0x00000624 0x00000639 0x0000064e
-				0x00000663 0x00000679 0x0000068e 0x000006a4 0x000006ba 0x000006d0 0x000006e6 0x000006fd
-				0x00000713 0x0000072a 0x00000741 0x00000758 0x0000076f 0x00000786 0x0000079e 0x000007b6
-				0x000007cd 0x000007e5 0x000007fd 0x00000816 0x0000082e 0x00000847 0x0000085f 0x00000878
-				0x00000891 0x000008ab 0x000008c4 0x000008de 0x000008f7 0x00000911 0x0000092b 0x00000945
-				0x00000960 0x0000097a 0x00000995 0x000009af 0x000009ca 0x000009e6 0x00000a01 0x00000a1c
-				0x00000a38 0x00000a54 0x00000a6f 0x00000a8c 0x00000aa8 0x00000ac4 0x00000ae1 0x00000afd
-				0x00000b1a 0x00000b37 0x00000b54 0x00000b72 0x00000b8f 0x00000bad 0x00000bcb 0x00000be9
-				0x00000c07 0x00000c25 0x00000c44 0x00000c62 0x00000c81 0x00000ca0 0x00000cbf 0x00000cdf
-				0x00000cfe 0x00000d1e 0x00000d3e 0x00000d5d 0x00000d7e 0x00000d9e 0x00000dbe 0x00000ddf
-				0x00000e00 0x00000e21 0x00000e42 0x00000e63 0x00000e84 0x00000ea6 0x00000ec8 0x00000eea
-				0x00000f0c 0x00000f2e 0x00000f50 0x00000f73 0x00000f96 0x00000fb9 0x00000fdc 0x00000fff
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-				0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000>;
-		cabc-gamma-base = <
-			/*gamma = 2.2*/
-			0x00010000 0x0000fdd0 0x0000fba8 0x0000f986 0x0000f76a 0x0000f556 0x0000f347 0x0000f140
-			0x0000ef3e 0x0000ed43 0x0000eb4e 0x0000e95e 0x0000e775 0x0000e592 0x0000e3b4 0x0000e1dc
-			0x0000e009 0x0000de3c 0x0000dc74 0x0000dab2 0x0000d8f4 0x0000d73c 0x0000d589 0x0000d3db
-			0x0000d232 0x0000d08d 0x0000ceee 0x0000cd53 0x0000cbbc 0x0000ca2b 0x0000c89d 0x0000c714
-			0x0000c590 0x0000c410 0x0000c294 0x0000c11c 0x0000bfa8 0x0000be39 0x0000bccd 0x0000bb65
-			0x0000ba01 0x0000b8a1 0x0000b745 0x0000b5ed 0x0000b498 0x0000b347 0x0000b1f9 0x0000b0af
-			0x0000af68 0x0000ae25 0x0000ace5 0x0000aba8 0x0000aa6f 0x0000a939 0x0000a806 0x0000a6d7
-			0x0000a5aa 0x0000a480 0x0000a35a 0x0000a236 0x0000a116 0x00009ff8 0x00009edd 0x00009dc5
-			0x00009cb0 0x00009b9e 0x00009a8e 0x00009981 0x00009877 0x0000976f 0x0000966a 0x00009567
-			0x00009467 0x0000936a 0x0000926f 0x00009176 0x00009080 0x00008f8c 0x00008e9a 0x00008dab
-			0x00008cbe 0x00008bd3 0x00008aea 0x00008a04 0x00008920 0x0000883e 0x0000875e 0x00008680
-			0x000085a4 0x000084ca 0x000083f3 0x0000831d 0x00008249 0x00008177 0x000080a7 0x00007fd9
-			0x00007f0d 0x00007e42 0x00007d7a 0x00007cb3 0x00007bee 0x00007b2b 0x00007a6a 0x000079aa
-			0x000078ec 0x0000782f 0x00007775 0x000076bc 0x00007604 0x0000754f 0x0000749a 0x000073e8
-			0x00007337 0x00007287 0x000071d9 0x0000712c 0x00007081 0x00006fd8 0x00006f30 0x00006e89
-			0x00006de4 0x00006d40 0x00006c9d 0x00006bfc 0x00006b5c 0x00006abe 0x00006a21 0x00006985
-			0x000068ea 0x00006851 0x000067b9 0x00006722 0x0000668d 0x000065f9 0x00006566 0x000064d4
-			0x00006443 0x000063b4 0x00006325 0x00006298 0x0000620c 0x00006181 0x000060f8 0x0000606f
-			0x00005fe7 0x00005f61 0x00005edb 0x00005e57 0x00005dd4 0x00005d51 0x00005cd0 0x00005c50
-			0x00005bd1 0x00005b52 0x00005ad5 0x00005a59 0x000059de 0x00005963 0x000058ea 0x00005871
-			0x000057fa 0x00005783 0x0000570d 0x00005699 0x00005625 0x000055b2 0x0000553f 0x000054ce
-			0x0000545d 0x000053ee 0x0000537f 0x00005311 0x000052a4 0x00005238 0x000051cc 0x00005161
-			0x000050f7 0x0000508e 0x00005026 0x00004fbe 0x00004f57 0x00004ef1 0x00004e8c 0x00004e27
-			0x00004dc3 0x00004d60 0x00004cfe 0x00004c9c 0x00004c3b 0x00004bdb 0x00004b7b 0x00004b1c
-			0x00004abe 0x00004a60 0x00004a03 0x000049a7 0x0000494b 0x000048f0 0x00004896 0x0000483c
-			0x000047e3 0x0000478a 0x00004733 0x000046db 0x00004685 0x0000462f 0x000045d9 0x00004584
-			0x00004530 0x000044dc 0x00004489 0x00004437 0x000043e5 0x00004393 0x00004342 0x000042f2
-			0x000042a2 0x00004253 0x00004204 0x000041b6 0x00004169 0x0000411b 0x000040cf 0x00004083
-			0x00004037 0x00003fec 0x00003fa1 0x00003f57 0x00003f0e 0x00003ec5 0x00003e7c 0x00003e34
-			0x00003dec 0x00003da5 0x00003d5e 0x00003d18 0x00003cd2 0x00003c8c 0x00003c48 0x00003c03
-			0x00003bbf 0x00003b7b 0x00003b38 0x00003af5 0x00003ab3 0x00003a71 0x00003a30 0x000039ef
-			0x000039ae 0x0000396e 0x0000392e 0x000038ee 0x000038af 0x00003871 0x00003832 0x000037f5>;
-			};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-LP097Qx1.dtsi b/include/dt-bindings/display/screen-timing/lcd-LP097Qx1.dtsi
deleted file mode 100644
index 9a11edbdd84e..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-LP097Qx1.dtsi
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. DisplayPort screen LP097QX1
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_EDP>;
-		out-face    = <OUT_P666>;
-		clock-frequency = <205000000>;
-		hactive = <2048>;
-		vactive = <1536>;
-		hback-porch = <5>;
-		hfront-porch = <150>;
-		vback-porch = <9>;
-		vfront-porch = <3>;
-		hsync-len = <5>;
-		vsync-len = <1>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-LP097Qx2.dtsi b/include/dt-bindings/display/screen-timing/lcd-LP097Qx2.dtsi
deleted file mode 100644
index 64f99e8f308f..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-LP097Qx2.dtsi
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- *
- * include/dt-bindings/display/screen-timing/lcd-LP097QX2.dtsi
- * author: xbl@rock-chips.com
- * create date: 2016-05-16
- * screen type: edp
- * lcd model: lp097qx2
- * resolution: 1536 * 2048
- */
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	timing0: timing0 {
-		screen-type = <SCREEN_EDP>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <200000000>;
-		hactive = <1536>;
-		vactive = <2048>;
-		hback-porch = <52>;
-		hfront-porch = <16>;
-		vback-porch = <3>;
-		vfront-porch = <7>;
-		hsync-len = <15>;
-		vsync-len = <1>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.2*/
-			0x00000383 0x00000392 0x000003a2 0x000003b2 0x000003c2 0x000003d2 0x000003e2 0x000003f3
-			0x00000403 0x00000414 0x00000425 0x00000436 0x00000447 0x00000458 0x0000046a 0x0000047b
-			0x0000048d 0x0000049f 0x000004b1 0x000004c3 0x000004d5 0x000004e8 0x000004fa 0x0000050d
-			0x00000520 0x00000533 0x00000546 0x0000055a 0x0000056d 0x00000581 0x00000595 0x000005a9
-			0x000005bd 0x000005d1 0x000005e5 0x000005fa 0x0000060f 0x00000624 0x00000639 0x0000064e
-			0x00000663 0x00000679 0x0000068e 0x000006a4 0x000006ba 0x000006d0 0x000006e6 0x000006fd
-			0x00000713 0x0000072a 0x00000741 0x00000758 0x0000076f 0x00000786 0x0000079e 0x000007b6
-			0x000007cd 0x000007e5 0x000007fd 0x00000816 0x0000082e 0x00000847 0x0000085f 0x00000878
-			0x00000891 0x000008ab 0x000008c4 0x000008de 0x000008f7 0x00000911 0x0000092b 0x00000945
-			0x00000960 0x0000097a 0x00000995 0x000009af 0x000009ca 0x000009e6 0x00000a01 0x00000a1c
-			0x00000a38 0x00000a54 0x00000a6f 0x00000a8c 0x00000aa8 0x00000ac4 0x00000ae1 0x00000afd
-			0x00000b1a 0x00000b37 0x00000b54 0x00000b72 0x00000b8f 0x00000bad 0x00000bcb 0x00000be9
-			0x00000c07 0x00000c25 0x00000c44 0x00000c62 0x00000c81 0x00000ca0 0x00000cbf 0x00000cdf
-			0x00000cfe 0x00000d1e 0x00000d3e 0x00000d5d 0x00000d7e 0x00000d9e 0x00000dbe 0x00000ddf
-			0x00000e00 0x00000e21 0x00000e42 0x00000e63 0x00000e84 0x00000ea6 0x00000ec8 0x00000eea
-			0x00000f0c 0x00000f2e 0x00000f50 0x00000f73 0x00000f96 0x00000fb9 0x00000fdc 0x00000fff
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-b080xan03.0-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-b080xan03.0-mipi.dtsi
deleted file mode 100644
index 2d3010ae3c89..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-b080xan03.0-mipi.dtsi
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * Licensed under GPLv2 or later.
- * arch/arm/boot/dts/lcd-b080xan03.0-mipi.dtsi
- * author: chenyf@rock-chips.com
- * create date: 2014-09-11
- * lcd model: b080xan03.0
- * resolution: 768 X 1024
- * mipi channel: single
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-			compatible = "rockchip,mipi_dsi_init";
-			rockchip,screen_init	= <0>;
-			rockchip,dsi_lane		= <4>;
-			rockchip,dsi_hs_clk		= <528>;
-			rockchip,mipi_dsi_num	= <1>;
-};
-disp_mipi_power_ctr: mipi_power_ctr {
-			compatible = "rockchip,mipi_power_ctr";
-			mipi_lcd_rst:mipi_lcd_rst{
-					compatible = "rockchip,lcd_rst";
-					rockchip,gpios = <&gpio2 GPIO_C2 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <20>;
-			};
-		/*	mipi_lcd_en:mipi_lcd_en {
-					compatible = "rockchip,lcd_en";
-					rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <100>;
-			};*/
-};
-disp_mipi_init_cmds: screen-on-cmds {
-			compatible = "rockchip,screen-on-cmds";
-			/*rockchip,cmd_debug = <1>;
-			rockchip,on-cmds1 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <HSDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0xb0 0x02>;
-					rockchip,cmd_delay = <0>;
-			};
-			*/
-};
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        compatible = "rockchip,display-timings";
-        timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P666>;
-		clock-frequency = <67000000>;
-		hactive = <768>;
-		vactive = <1024>;
-		hback-porch = <56>;
-		hfront-porch = <60>;
-		vback-porch = <30>;
-		vfront-porch = <36>;
-		hsync-len = <64>;
-		vsync-len = <14>;
-
-		/*
-		hactive = <1024>;
-		vactive = <768>;
-		hback-porch = <56>;
-		hfront-porch = <60>;
-		vback-porch = <30>;
-		vfront-porch = <36>;
-		hsync-len = <64>;
-		vsync-len = <14>;
-		*/
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-b101ew05.dtsi b/include/dt-bindings/display/screen-timing/lcd-b101ew05.dtsi
deleted file mode 100644
index ff15d837e166..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-b101ew05.dtsi
+++ /dev/null
@@ -1,66 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_B101ew05
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_LVDS>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_D888_P666>;
-		color-mode = <COLOR_RGB>;
-		clock-frequency = <71000000>;
-		hactive = <1280>;
-		vactive = <800>;
-		hback-porch = <100>;
-		hfront-porch = <18>;
-		vback-porch = <8>;
-		vfront-porch = <6>;
-		hsync-len = <10>;
-		vsync-len = <2>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.0*/
-			 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000002
-			 0x00000002 0x00000002 0x00000002 0x00000002 0x00000003 0x00000003 0x00000003 0x00000003
-			 0x00000004 0x00000004 0x00000004 0x00000004 0x00000005 0x00000005 0x00000005 0x00000005
-			 0x00000006 0x00000006 0x00000006 0x00000007 0x00000007 0x00000007 0x00000008 0x00000008
-			 0x00000009 0x00000009 0x00000009 0x0000000a 0x0000000a 0x0000000b 0x0000000b 0x0000000b
-			 0x0000000c 0x0000000c 0x0000000d 0x0000000d 0x0000000e 0x0000000e 0x0000000f 0x0000000f
-			 0x00000010 0x00000010 0x00000011 0x00000011 0x00000012 0x00000012 0x00000013 0x00000013
-			 0x00000014 0x00000014 0x00000015 0x00000016 0x00000016 0x00000017 0x00000017 0x00000018
-			 0x00000019 0x00000019 0x0000001a 0x0000001b 0x0000001b 0x0000001c 0x0000001d 0x0000001d
-			 0x0000001e 0x0000001f 0x0000001f 0x00000020 0x00000021 0x00000021 0x00000022 0x00000023
-			 0x00000024 0x00000024 0x00000025 0x00000026 0x00000027 0x00000028 0x00000028 0x00000029
-			 0x0000002a 0x0000002b 0x0000002c 0x0000002c 0x0000002d 0x0000002e 0x0000002f 0x00000030
-			 0x00000031 0x00000032 0x00000032 0x00000033 0x00000034 0x00000035 0x00000036 0x00000037
-			 0x00000038 0x00000039 0x0000003a 0x0000003b 0x0000003c 0x0000003d 0x0000003e 0x0000003f
-			 0x00000040 0x00000041 0x00000042 0x00000043 0x00000044 0x00000045 0x00000046 0x00000047
-			 0x00000048 0x00000049 0x0000004a 0x0000004b 0x0000004c 0x0000004d 0x0000004f 0x00000050
-			 0x00000051 0x00000052 0x00000053 0x00000054 0x00000055 0x00000057 0x00000058 0x00000059
-			 0x0000005a 0x0000005b 0x0000005d 0x0000005e 0x0000005f 0x00000060 0x00000061 0x00000063
-			 0x00000064 0x00000065 0x00000066 0x00000068 0x00000069 0x0000006a 0x0000006c 0x0000006d
-			 0x0000006e 0x00000070 0x00000071 0x00000072 0x00000074 0x00000075 0x00000076 0x00000078
-			 0x00000079 0x0000007a 0x0000007c 0x0000007d 0x0000007f 0x00000080 0x00000081 0x00000083
-			 0x00000084 0x00000086 0x00000087 0x00000089 0x0000008a 0x0000008c 0x0000008d 0x0000008f
-			 0x00000090 0x00000092 0x00000093 0x00000095 0x00000096 0x00000098 0x00000099 0x0000009b
-			 0x0000009c 0x0000009e 0x000000a0 0x000000a1 0x000000a3 0x000000a4 0x000000a6 0x000000a8
-			 0x000000a9 0x000000ab 0x000000ac 0x000000ae 0x000000b0 0x000000b1 0x000000b3 0x000000b5
-			 0x000000b6 0x000000b8 0x000000ba 0x000000bc 0x000000bd 0x000000bf 0x000000c1 0x000000c3
-			 0x000000c4 0x000000c6 0x000000c8 0x000000ca 0x000000cb 0x000000cd 0x000000cf 0x000000d1
-			 0x000000d3 0x000000d4 0x000000d6 0x000000d8 0x000000da 0x000000dc 0x000000de 0x000000e0
-			 0x000000e1 0x000000e3 0x000000e5 0x000000e7 0x000000e9 0x000000eb 0x000000ed 0x000000ef
-			 0x000000f1 0x000000f3 0x000000f5 0x000000f7 0x000000f9 0x000000fb 0x000000fd 0x000000ff>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-box.dtsi b/include/dt-bindings/display/screen-timing/lcd-box.dtsi
deleted file mode 100644
index 25368db39d29..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-box.dtsi
+++ /dev/null
@@ -1,99 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_BOX
- *
- */
-
-	disp_power_ctr: power_ctr {
-     /*                        rockchip,debug = <0>;
-        lcd_en:lcd_en {
-                rockchip,power_type = <GPIO>;
-                gpios = <&gpio0 GPIO_B0 GPIO_ACTIVE_HIGH>;
-                rockchip,delay = <10>;
-        };
-
-        bl_en:bl_en {
-                rockchip,power_type = <GPIO>;
-                gpios = <&gpio0 GPIO_A2 GPIO_ACTIVE_HIGH>;
-                rockchip,delay = <10>;
-        };
-
-        bl_ctr:bl_ctr {
-                rockchip,power_type = <GPIO>;
-                gpios = <&gpio3 GPIO_D6 GPIO_ACTIVE_HIGH>;
-                rockchip,delay = <10>;
-        };
-
-        lcd_rst:lcd_rst {
-                rockchip,power_type = <REGULATOR>;
-                rockchip,delay = <5>;
-        };*/
-
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P888>;
-		color-mode = <COLOR_YCBCR>;
-		clock-frequency = <74250000>;
-		hactive = <1280>;
-		vactive = <720>;
-		hback-porch = <220>;
-		hfront-porch = <110>;
-		vback-porch = <20>;
-		vfront-porch = <5>;
-		hsync-len = <40>;
-		vsync-len = <5>;
-		hsync-active = <1>;
-		vsync-active = <1>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-	timing1: timing1 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P888>;
-		color-mode = <COLOR_YCBCR>;
-		clock-frequency = <148500000>;
-		hactive = <1920>;
-		vactive = <1080>;
-		hback-porch = <148>;
-		hfront-porch = <88>;
-		vback-porch = <36>;
-		vfront-porch = <4>;
-		hsync-len = <44>;
-		vsync-len = <5>;
-		hsync-active = <1>;
-		vsync-active = <1>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-	timing2: timing2 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P888>;
-		color-mode = <COLOR_YCBCR>;
-		clock-frequency = <297000000>;
-		hactive = <3840>;
-		vactive = <2160>;
-		hback-porch = <296>;
-		hfront-porch = <176>;
-		vback-porch = <72>;
-		vfront-porch = <8>;
-		hsync-len = <88>;
-		vsync-len = <10>;
-		hsync-active = <1>;
-		vsync-active = <1>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-fpga-800x480-rgb.dtsi b/include/dt-bindings/display/screen-timing/lcd-fpga-800x480-rgb.dtsi
deleted file mode 100644
index 798262d3654f..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-fpga-800x480-rgb.dtsi
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_D888_P666>;
-		color-mode = <COLOR_RGB>;
-		clock-frequency = <71000000>;
-		hactive = <800>;
-		vactive = <480>;
-		hback-porch = <206>;
-		hfront-porch = <1>;
-		vback-porch = <25>;
-		vfront-porch = <10>;
-		hsync-len = <10>;
-		vsync-len = <10>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.0*/
-			 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000002
-			 0x00000002 0x00000002 0x00000002 0x00000002 0x00000003 0x00000003 0x00000003 0x00000003
-			 0x00000004 0x00000004 0x00000004 0x00000004 0x00000005 0x00000005 0x00000005 0x00000005
-			 0x00000006 0x00000006 0x00000006 0x00000007 0x00000007 0x00000007 0x00000008 0x00000008
-			 0x00000009 0x00000009 0x00000009 0x0000000a 0x0000000a 0x0000000b 0x0000000b 0x0000000b
-			 0x0000000c 0x0000000c 0x0000000d 0x0000000d 0x0000000e 0x0000000e 0x0000000f 0x0000000f
-			 0x00000010 0x00000010 0x00000011 0x00000011 0x00000012 0x00000012 0x00000013 0x00000013
-			 0x00000014 0x00000014 0x00000015 0x00000016 0x00000016 0x00000017 0x00000017 0x00000018
-			 0x00000019 0x00000019 0x0000001a 0x0000001b 0x0000001b 0x0000001c 0x0000001d 0x0000001d
-			 0x0000001e 0x0000001f 0x0000001f 0x00000020 0x00000021 0x00000021 0x00000022 0x00000023
-			 0x00000024 0x00000024 0x00000025 0x00000026 0x00000027 0x00000028 0x00000028 0x00000029
-			 0x0000002a 0x0000002b 0x0000002c 0x0000002c 0x0000002d 0x0000002e 0x0000002f 0x00000030
-			 0x00000031 0x00000032 0x00000032 0x00000033 0x00000034 0x00000035 0x00000036 0x00000037
-			 0x00000038 0x00000039 0x0000003a 0x0000003b 0x0000003c 0x0000003d 0x0000003e 0x0000003f
-			 0x00000040 0x00000041 0x00000042 0x00000043 0x00000044 0x00000045 0x00000046 0x00000047
-			 0x00000048 0x00000049 0x0000004a 0x0000004b 0x0000004c 0x0000004d 0x0000004f 0x00000050
-			 0x00000051 0x00000052 0x00000053 0x00000054 0x00000055 0x00000057 0x00000058 0x00000059
-			 0x0000005a 0x0000005b 0x0000005d 0x0000005e 0x0000005f 0x00000060 0x00000061 0x00000063
-			 0x00000064 0x00000065 0x00000066 0x00000068 0x00000069 0x0000006a 0x0000006c 0x0000006d
-			 0x0000006e 0x00000070 0x00000071 0x00000072 0x00000074 0x00000075 0x00000076 0x00000078
-			 0x00000079 0x0000007a 0x0000007c 0x0000007d 0x0000007f 0x00000080 0x00000081 0x00000083
-			 0x00000084 0x00000086 0x00000087 0x00000089 0x0000008a 0x0000008c 0x0000008d 0x0000008f
-			 0x00000090 0x00000092 0x00000093 0x00000095 0x00000096 0x00000098 0x00000099 0x0000009b
-			 0x0000009c 0x0000009e 0x000000a0 0x000000a1 0x000000a3 0x000000a4 0x000000a6 0x000000a8
-			 0x000000a9 0x000000ab 0x000000ac 0x000000ae 0x000000b0 0x000000b1 0x000000b3 0x000000b5
-			 0x000000b6 0x000000b8 0x000000ba 0x000000bc 0x000000bd 0x000000bf 0x000000c1 0x000000c3
-			 0x000000c4 0x000000c6 0x000000c8 0x000000ca 0x000000cb 0x000000cd 0x000000cf 0x000000d1
-			 0x000000d3 0x000000d4 0x000000d6 0x000000d8 0x000000da 0x000000dc 0x000000de 0x000000e0
-			 0x000000e1 0x000000e3 0x000000e5 0x000000e7 0x000000e9 0x000000eb 0x000000ed 0x000000ef
-			 0x000000f1 0x000000f3 0x000000f5 0x000000f7 0x000000f9 0x000000fb 0x000000fd 0x000000ff>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200-double.dtsi b/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200-double.dtsi
deleted file mode 100644
index 6fe841cdf720..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200-double.dtsi
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- *
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- * author: xubilv <xbl@rock-chips.com>
- * create date: 2016-08-11
- * resolution: 1080 X 1200
- * mipi channel: double
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init {
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init	= <1>;
-	rockchip,dsi_lane	= <4>;
-	rockchip,dsi_hs_clk	= <970>;
-	rockchip,mipi_dsi_num	= <2>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-
-	/*mipi_lcd_rst:mipi_lcd_rst {
-			compatible = "rockchip,lcd_rst";
-			rockchip,gpios = <&gpio7 GPIO_A1 GPIO_ACTIVE_LOW>;
-			rockchip,delay = <0>;
-	};
-
-	mipi_lcd_avdd:mipi_lcd_avdd {
-			compatible = "rockchip,lcd_avdd";
-			rockchip,gpios = <&gpio7 GPIO_A2 GPIO_ACTIVE_HIGH>;
-			rockchip,delay = <0>;
-	};
-
-	mipi_lcd_ovdd:mipi_lcd_ovdd {
-			compatible = "rockchip,lcd_ovdd";
-			rockchip,gpios = <&gpio7 GPIO_A3 GPIO_ACTIVE_HIGH>;
-			rockchip,delay = <0>;
-	};
-
-	mipi_lcd_ovss:mipi_lcd_ovss {
-		compatible = "rockchip,lcd_ovss";
-		rockchip,gpios = <&gpio7 GPIO_B0 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <0>;
-	};
-	mipi_lcd_rst:mipi_lcd_rst{
-			compatible = "rockchip,lcd_rst";
-			rockchip,gpios = <&gpio7 GPIO_A1 GPIO_ACTIVE_LOW>;
-			rockchip,delay = <100>;
-	};
-	mipi_lcd_en:mipi_lcd_en {
-			compatible = "rockchip,lcd_en";
-			rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-			rockchip,delay = <100>;
-	};*/
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	compatible = "rockchip,screen-on-cmds";
-	rockchip,cmd_debug = <0>;
-	rockchip,on-cmds1 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xFE 0x07>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds2 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x00 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds3 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x0B 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds4 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x16 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds5 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x21 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds6 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x2D 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds7 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xA9 0xBA>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds8 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xAB 0x06>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds9 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xBB 0x84>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds10 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xBC 0x1C>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds11 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xFE 0x08>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds12 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x07 0x1A>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds13 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xFE 0x0A>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds14 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x2A 0x1B>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds15 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xFE 0x0D>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds16 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x02 0x65>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds17 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x4D 0x41>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds18 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x4B 0x0F>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds19 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x53 0xFE>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds20 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xFE 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds21 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0xC2 0x03>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds22 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x15 0x51 0xFF>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds23 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x05 0x11>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds24 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x05 0x29>;
-		rockchip,cmd_delay = <10>;
-	};
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-	timing0: timing0 {
-		screen-type = <SCREEN_DUAL_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <231795000>; /* 185436000 60fps, 231795000 75fps, 278154000  90fps */
-		hactive = <2160>; //1080
-		vactive = <1200>;
-		hback-porch = <180>;
-		hfront-porch = <200>;
-		vback-porch = <3>;
-		vfront-porch = <6>;
-		hsync-len = <10>;
-		vsync-len = <3>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		screen-width = <130>;
-		screen-hight = <72>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200.dtsi b/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200.dtsi
deleted file mode 100644
index 994809469890..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-h381dln01-1080x1200.dtsi
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- * author: xubilv <xbl@rock-chips.com>
- * create date: 2016-08-11
- * resolution: 1080 X 1200
- * mipi channel: single
- */
-
-disp_mipi_init: mipi_dsi_init {
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init	= <1>;
-	rockchip,dsi_lane	= <4>;
-	rockchip,dsi_hs_clk	= <970>;
-	rockchip,mipi_dsi_num	= <1>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-
-	/*mipi_lcd_rst:mipi_lcd_rst {
-		compatible = "rockchip,lcd_rst";
-		rockchip,gpios = <&gpio7 GPIO_A1 GPIO_ACTIVE_LOW>;
-		rockchip,delay = <0>;
-	};
-
-	mipi_lcd_avdd:mipi_lcd_avdd {
-		compatible = "rockchip,lcd_avdd";
-		rockchip,gpios = <&gpio7 GPIO_A2 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <0>;
-	};
-
-	mipi_lcd_ovdd:mipi_lcd_ovdd {
-		compatible = "rockchip,lcd_ovdd";
-		rockchip,gpios = <&gpio7 GPIO_A3 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <0>;
-	};
-
-	mipi_lcd_ovss:mipi_lcd_ovss {
-		compatible = "rockchip,lcd_ovss";
-		rockchip,gpios = <&gpio7 GPIO_B0 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <0>;
-	};
-
-	mipi_lcd_rst:mipi_lcd_rst {
-		compatible = "rockchip,lcd_rst";
-		rockchip,gpios = <&gpio7 GPIO_A1 GPIO_ACTIVE_LOW>;
-		rockchip,delay = <100>;
-	};
-
-	mipi_lcd_en:mipi_lcd_en {
-		compatible = "rockchip,lcd_en";
-		rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <100>;
-	};*/
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	compatible = "rockchip,screen-on-cmds";
-	rockchip,cmd_debug = <0>;
-	rockchip,on-cmds1 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xFE 0x07>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds2 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x00 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds3 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x0B 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds4 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x16 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds5 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x21 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds6 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x2D 0xEC>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds7 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xA9 0xBA>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds8 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xAB 0x06>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds9 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xBB 0x84>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds10 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xBC 0x1C>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds11 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xFE 0x08>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds12 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x07 0x1A>;
-		rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds13 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xFE 0x0A>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds14 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x2A 0x1B>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds15 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xFE 0x0D>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds16 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x02 0x65>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds17 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x4D 0x41>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds18 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x4B 0x0F>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds19 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x53 0xFE>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds20 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xFE 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds21 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0xC2 0x03>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds22 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x15 0x51 0xFF>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds23 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x05 0x11>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds24 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x05 0x29>;
-		rockchip,cmd_delay = <10>;
-	};
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-	timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <139000000>;//139
-		hactive = <1080>;
-		vactive = <1200>;
-		hback-porch = <90>;
-		hfront-porch = <100>;
-		vback-porch = <3>;
-		vfront-porch = <6>;
-		hsync-len = <5>;
-		vsync-len = <3>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-h546dlb01-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-h546dlb01-mipi.dtsi
deleted file mode 100644
index 19d427c71e5f..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-h546dlb01-mipi.dtsi
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- *
- * include/dt-bindings/display/screen-timing/lcd-h546dlb01-mipi.dtsi
- * author: bivvy.bi@rock-chips.com
- * create date: 2016-09-02
- * lcd Model: AUO h546dlb01
- * resolution: 1080 X 1920
- * mipi channel: single
- */
-
-disp_mipi_init: mipi_dsi_init {
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init = <1>;
-	rockchip,dsi_lane = <4>;
-	rockchip,dsi_hs_clk = <1050>;
-	rockchip,mipi_dsi_num = <1>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	compatible = "rockchip,screen-on-cmds";
-	rockchip,cmd_debug = <1>;
-
-	rockchip,on-cmds1 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0xFE 0x08>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds2 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0x03 0x40>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds3 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0x07 0x1a>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds4 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0xfe 0x0d>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds5 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0x53 0xfe>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds6 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0xfe 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds7 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0x51 0xff>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds8 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x23 0xc2 0x03>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds9 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x05 dcs_exit_sleep_mode>;
-		rockchip,cmd_delay = <120>;
-	};
-
-	rockchip,on-cmds10 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <0>;
-		rockchip,cmd = <0x05 dcs_set_display_on>;
-		rockchip,cmd_delay = <0>;
-	};
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-
-	timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face = <OUT_P888>;
-		clock-frequency = <153000000>;
-		hactive = <1080>;
-		vactive = <1920>;
-		hback-porch = <24>;
-		hfront-porch = <8>;
-		vback-porch = <7>;
-		vfront-porch = <12>;
-		hsync-len = <5>;
-		vsync-len = <5>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		screen-width = <68>;
-		screen-hight = <120>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-ld089wu1-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-ld089wu1-mipi.dtsi
deleted file mode 100644
index a20e51a37d69..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-ld089wu1-mipi.dtsi
+++ /dev/null
@@ -1,139 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * arch/arm/boot/dts/lcd-lq070m1sx01-mipi.dtsi
- * author: libing@rock-chips.com
- * create date: 2014-04-15
- * lcd model: ld089wu1
- * resolution: 1920 X 1200
- * mipi channel: single
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-			compatible = "rockchip,mipi_dsi_init";
-			rockchip,screen_init	= <0>;
-			rockchip,dsi_lane		= <4>;
-			rockchip,dsi_hs_clk		= <1000>;
-			rockchip,mipi_dsi_num	= <1>;
-};
-disp_mipi_power_ctr: mipi_power_ctr {
-			compatible = "rockchip,mipi_power_ctr";
-			/*mipi_lcd_rst:mipi_lcd_rst{
-					compatible = "rockchip,lcd_rst";
-					rockchip,gpios = <&gpio2 GPIO_B7 GPIO_ACTIVE_LOW>;
-					rockchip,delay = <100>;
-			};
-			mipi_lcd_en:mipi_lcd_en {
-					compatible = "rockchip,lcd_en";
-					rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <100>;
-			};*/
-};
-disp_mipi_init_cmds: screen-on-cmds {
-			compatible = "rockchip,screen-on-cmds";
-			/*rockchip,cmd_debug = <1>;
-			rockchip,on-cmds1 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <HSDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0xb0 0x02>;
-					rockchip,cmd_delay = <0>;
-			};
-			*/
-};
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        compatible = "rockchip,display-timings";
-        timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <145000000>;
-		hactive = <1920>;
-		vactive = <1200>;
-		hback-porch = <16>;
-		hfront-porch = <24>;
-		vback-porch = <10>;
-		vfront-porch = <16>;
-		hsync-len = <10>;
-		vsync-len = <3>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.2*/
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000001
-			0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001 0x00000001
-			0x00000001 0x00000002 0x00000002 0x00000002 0x00000002 0x00000002 0x00000002 0x00000002
-			0x00000003 0x00000003 0x00000003 0x00000003 0x00000003 0x00000004 0x00000004 0x00000004
-			0x00000004 0x00000005 0x00000005 0x00000005 0x00000005 0x00000006 0x00000006 0x00000006
-			0x00000006 0x00000007 0x00000007 0x00000007 0x00000008 0x00000008 0x00000008 0x00000009
-			0x00000009 0x00000009 0x0000000a 0x0000000a 0x0000000b 0x0000000b 0x0000000b 0x0000000c
-			0x0000000c 0x0000000d 0x0000000d 0x0000000d 0x0000000e 0x0000000e 0x0000000f 0x0000000f
-			0x00000010 0x00000010 0x00000011 0x00000011 0x00000012 0x00000012 0x00000013 0x00000013
-			0x00000014 0x00000014 0x00000015 0x00000016 0x00000016 0x00000017 0x00000017 0x00000018
-			0x00000019 0x00000019 0x0000001a 0x0000001a 0x0000001b 0x0000001c 0x0000001c 0x0000001d
-			0x0000001e 0x0000001e 0x0000001f 0x00000020 0x00000021 0x00000021 0x00000022 0x00000023
-			0x00000023 0x00000024 0x00000025 0x00000026 0x00000027 0x00000027 0x00000028 0x00000029
-			0x0000002a 0x0000002b 0x0000002b 0x0000002c 0x0000002d 0x0000002e 0x0000002f 0x00000030
-			0x00000031 0x00000031 0x00000032 0x00000033 0x00000034 0x00000035 0x00000036 0x00000037
-			0x00000038 0x00000039 0x0000003a 0x0000003b 0x0000003c 0x0000003d 0x0000003e 0x0000003f
-			0x00000040 0x00000041 0x00000042 0x00000043 0x00000044 0x00000045 0x00000046 0x00000047
-			0x00000049 0x0000004a 0x0000004b 0x0000004c 0x0000004d 0x0000004e 0x0000004f 0x00000051
-			0x00000052 0x00000053 0x00000054 0x00000055 0x00000057 0x00000058 0x00000059 0x0000005a
-			0x0000005b 0x0000005d 0x0000005e 0x0000005f 0x00000061 0x00000062 0x00000063 0x00000064
-			0x00000066 0x00000067 0x00000069 0x0000006a 0x0000006b 0x0000006d 0x0000006e 0x0000006f
-			0x00000071 0x00000072 0x00000074 0x00000075 0x00000077 0x00000078 0x00000079 0x0000007b
-			0x0000007c 0x0000007e 0x0000007f 0x00000081 0x00000082 0x00000084 0x00000085 0x00000087
-			0x00000089 0x0000008a 0x0000008c 0x0000008d 0x0000008f 0x00000091 0x00000092 0x00000094
-			0x00000095 0x00000097 0x00000099 0x0000009a 0x0000009c 0x0000009e 0x0000009f 0x000000a1
-			0x000000a3 0x000000a5 0x000000a6 0x000000a8 0x000000aa 0x000000ac 0x000000ad 0x000000af
-			0x000000b1 0x000000b3 0x000000b5 0x000000b6 0x000000b8 0x000000ba 0x000000bc 0x000000be
-			0x000000c0 0x000000c2 0x000000c4 0x000000c5 0x000000c7 0x000000c9 0x000000cb 0x000000cd
-			0x000000cf 0x000000d1 0x000000d3 0x000000d5 0x000000d7 0x000000d9 0x000000db 0x000000dd
-			0x000000df 0x000000e1 0x000000e3 0x000000e5 0x000000e7 0x000000ea 0x000000ec 0x000000ee
-			0x000000f0 0x000000f2 0x000000f4 0x000000f6 0x000000f8 0x000000fb 0x000000fd 0x000000ff>;
-		cabc-gamma-base = <
-			/*gamma = 2.2*/
-			0x00010000 0x0000fdd0 0x0000fba8 0x0000f986 0x0000f76a 0x0000f556 0x0000f347 0x0000f140
-			0x0000ef3e 0x0000ed43 0x0000eb4e 0x0000e95e 0x0000e775 0x0000e592 0x0000e3b4 0x0000e1dc
-			0x0000e009 0x0000de3c 0x0000dc74 0x0000dab2 0x0000d8f4 0x0000d73c 0x0000d589 0x0000d3db
-			0x0000d232 0x0000d08d 0x0000ceee 0x0000cd53 0x0000cbbc 0x0000ca2b 0x0000c89d 0x0000c714
-			0x0000c590 0x0000c410 0x0000c294 0x0000c11c 0x0000bfa8 0x0000be39 0x0000bccd 0x0000bb65
-			0x0000ba01 0x0000b8a1 0x0000b745 0x0000b5ed 0x0000b498 0x0000b347 0x0000b1f9 0x0000b0af
-			0x0000af68 0x0000ae25 0x0000ace5 0x0000aba8 0x0000aa6f 0x0000a939 0x0000a806 0x0000a6d7
-			0x0000a5aa 0x0000a480 0x0000a35a 0x0000a236 0x0000a116 0x00009ff8 0x00009edd 0x00009dc5
-			0x00009cb0 0x00009b9e 0x00009a8e 0x00009981 0x00009877 0x0000976f 0x0000966a 0x00009567
-			0x00009467 0x0000936a 0x0000926f 0x00009176 0x00009080 0x00008f8c 0x00008e9a 0x00008dab
-			0x00008cbe 0x00008bd3 0x00008aea 0x00008a04 0x00008920 0x0000883e 0x0000875e 0x00008680
-			0x000085a4 0x000084ca 0x000083f3 0x0000831d 0x00008249 0x00008177 0x000080a7 0x00007fd9
-			0x00007f0d 0x00007e42 0x00007d7a 0x00007cb3 0x00007bee 0x00007b2b 0x00007a6a 0x000079aa
-			0x000078ec 0x0000782f 0x00007775 0x000076bc 0x00007604 0x0000754f 0x0000749a 0x000073e8
-			0x00007337 0x00007287 0x000071d9 0x0000712c 0x00007081 0x00006fd8 0x00006f30 0x00006e89
-			0x00006de4 0x00006d40 0x00006c9d 0x00006bfc 0x00006b5c 0x00006abe 0x00006a21 0x00006985
-			0x000068ea 0x00006851 0x000067b9 0x00006722 0x0000668d 0x000065f9 0x00006566 0x000064d4
-			0x00006443 0x000063b4 0x00006325 0x00006298 0x0000620c 0x00006181 0x000060f8 0x0000606f
-			0x00005fe7 0x00005f61 0x00005edb 0x00005e57 0x00005dd4 0x00005d51 0x00005cd0 0x00005c50
-			0x00005bd1 0x00005b52 0x00005ad5 0x00005a59 0x000059de 0x00005963 0x000058ea 0x00005871
-			0x000057fa 0x00005783 0x0000570d 0x00005699 0x00005625 0x000055b2 0x0000553f 0x000054ce
-			0x0000545d 0x000053ee 0x0000537f 0x00005311 0x000052a4 0x00005238 0x000051cc 0x00005161
-			0x000050f7 0x0000508e 0x00005026 0x00004fbe 0x00004f57 0x00004ef1 0x00004e8c 0x00004e27
-			0x00004dc3 0x00004d60 0x00004cfe 0x00004c9c 0x00004c3b 0x00004bdb 0x00004b7b 0x00004b1c
-			0x00004abe 0x00004a60 0x00004a03 0x000049a7 0x0000494b 0x000048f0 0x00004896 0x0000483c
-			0x000047e3 0x0000478a 0x00004733 0x000046db 0x00004685 0x0000462f 0x000045d9 0x00004584
-			0x00004530 0x000044dc 0x00004489 0x00004437 0x000043e5 0x00004393 0x00004342 0x000042f2
-			0x000042a2 0x00004253 0x00004204 0x000041b6 0x00004169 0x0000411b 0x000040cf 0x00004083
-			0x00004037 0x00003fec 0x00003fa1 0x00003f57 0x00003f0e 0x00003ec5 0x00003e7c 0x00003e34
-			0x00003dec 0x00003da5 0x00003d5e 0x00003d18 0x00003cd2 0x00003c8c 0x00003c48 0x00003c03
-			0x00003bbf 0x00003b7b 0x00003b38 0x00003af5 0x00003ab3 0x00003a71 0x00003a30 0x000039ef
-			0x000039ae 0x0000396e 0x0000392e 0x000038ee 0x000038af 0x00003871 0x00003832 0x000037f5>;
-			};
-	};
diff --git a/include/dt-bindings/display/screen-timing/lcd-lq070m1sx01-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-lq070m1sx01-mipi.dtsi
deleted file mode 100644
index 5f83e3b0d407..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-lq070m1sx01-mipi.dtsi
+++ /dev/null
@@ -1,129 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * arch/arm/boot/dts/lcd-lq070m1sx01-mipi.dtsi
- * author: libing@rock-chips.com
- * create date: 2014-04-15
- * lcd model: lq070m1sx01
- * resolution: 1920 X 1200
- * mipi channel: dual
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-			compatible = "rockchip,mipi_dsi_init";
-			rockchip,screen_init	= <1>;
-			rockchip,dsi_lane		= <2>;
-			rockchip,dsi_hs_clk		= <1000>;
-			rockchip,mipi_dsi_num	= <2>;
-};
-disp_mipi_power_ctr: mipi_power_ctr {
-			compatible = "rockchip,mipi_power_ctr";
-			mipi_lcd_rst:mipi_lcd_rst{
-					compatible = "rockchip,lcd_rst";
-					rockchip,gpios = <&gpio2 GPIO_B7 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <10>;
-			};
-			mipi_lcd_en:mipi_lcd_en {
-					compatible = "rockchip,lcd_en";
-					rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <10>;
-			};
-};
-disp_mipi_init_cmds: screen-on-cmds {
-			rockchip,cmd_debug = <0>;
-			compatible = "rockchip,screen-on-cmds";
-			rockchip,on-cmds1 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb0 0x02>;
-					rockchip,cmd_delay = <0>;
-			};
-
-			rockchip,on-cmds2 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb1 0x21>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds3 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb0 0x06>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds4 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb1 0x21>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds5 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb4 0x15>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds6 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb9 0x40>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds7 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0xb0 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds8 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 dcs_set_display_on>;
-					rockchip,cmd_delay = <10>;
-			};
-			rockchip,on-cmds9 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,data_type = <DATA_TYPE_DCS>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 dcs_exit_sleep_mode>;
-					rockchip,cmd_delay = <10>;
-			};
-};
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        compatible = "rockchip,display-timings";
-        timing0: timing0 {
-		screen-type = <SCREEN_DUAL_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <150000000>;
-		hactive = <1200>;
-		vactive = <1920>;
-		hsync-len = <8>;
-		hback-porch = <32>;
-		hfront-porch = <156>;
-
-		vsync-len = <2>;
-		vback-porch = <6>;
-		vfront-porch = <12>;
-
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-ls055r1sx04-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-ls055r1sx04-mipi.dtsi
deleted file mode 100644
index 7e93e7e1c300..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-ls055r1sx04-mipi.dtsi
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- *
- * include/dt-bindings/display/screen-timing/lcd-ls055r1sx04-mipi.dtsi
- * author: xbl@rock-chips.com
- * create date: 2016-05-16
- * lcd model: sharp ls055r1sx04
- * resolution: 1440 * 2560
- * mipi channel: double
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init	= <1>;
-	rockchip,dsi_lane	= <4>;
-	rockchip,dsi_hs_clk	= <850>;
-	rockchip,mipi_dsi_num	= <2>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-	/* mipi_lcd_rst:mipi_lcd_rst{
-			compatible = "rockchip,lcd_rst";
-			rockchip,gpios = <&gpio2 GPIO_B7 GPIO_ACTIVE_LOW>;
-			rockchip,delay = <100>;
-	};
-	mipi_lcd_en:mipi_lcd_en {
-			compatible = "rockchip,lcd_en";
-			rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-			rockchip,delay = <100>;
-	};
-	*/
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	compatible = "rockchip,screen-on-cmds";
-	rockchip,cmd_debug = <1>;
-	rockchip,on-cmds1 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x29 0xb0 0x00>;
-			rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds2 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x29 0xd6 0x01>;
-			rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds3 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x29 0xb3 0x18>;
-			rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds4 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x39 0x51 0xff>;
-			rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds5 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x39 0x53 0x0c>;
-			rockchip,cmd_delay = <0>;
-	};
-	rockchip,on-cmds6 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x39 0x35 0x00>;
-			rockchip,cmd_delay = <0>;
-	};
-/*
-	rockchip,on-cmds7 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x29 0xb0 0x03>;
-			rockchip,cmd_delay = <0>;
-	};
-*/
-	rockchip,on-cmds7 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x05 dcs_set_display_on>;
-			rockchip,cmd_delay = <10>;
-	};
-	rockchip,on-cmds8 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <LPDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0x05 dcs_exit_sleep_mode>;
-			rockchip,cmd_delay = <10>;
-	};
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-	timing0: timing0 {
-		screen-type = <SCREEN_DUAL_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <245000000>;
-		hactive = <1440>;
-		vactive = <2560>;
-		hback-porch = <40>;
-		hfront-porch = <100>;
-		vback-porch = <3>;
-		vfront-porch = <4>;
-		hsync-len = <6>;
-		vsync-len = <1>;
-		screen-width = <68>;
-		screen-hight = <120>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-mipi-RK055AUWI5003-1440X2560.dtsi b/include/dt-bindings/display/screen-timing/lcd-mipi-RK055AUWI5003-1440X2560.dtsi
deleted file mode 100644
index 5d021df56366..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-mipi-RK055AUWI5003-1440X2560.dtsi
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- *
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- * author: lyx@rock-chips.com
- * create date: 2016-04-05
- * resolution: 1440 X 2560
- * mipi channel: single
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init	= <1>;
-	rockchip,dsi_lane	= <4>;
-	rockchip,dsi_hs_clk	= <1000>;
-	rockchip,mipi_dsi_num	= <2>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-	/*
-	mipi_lcd_rst:mipi_lcd_rst {
-		compatible = "rockchip,lcd_rst";
-		rockchip,gpios = <&gpio3 4 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <100>;
-	};
-
-	mipi_lcd_en:mipi_lcd_en {
-		compatible = "rockchip,lcd_en";
-		rockchip,gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
-		rockchip,delay = <20>;
-	};
-	*/
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	rockchip,cmd_debug = <0>;
-	compatible = "rockchip,screen-on-cmds";
-	rockchip,on-cmds1 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xb0 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds2 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xd6 0x01>;
-		rockchip,cmd_delay = <120>;
-	};
-
-	rockchip,on-cmds3 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xb3 0x18 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds4 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xb4 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds5 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xb6 0x3a 0xd3>;
-		rockchip,cmd_delay = <20>;
-	};
-
-	rockchip,on-cmds6 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xbe 0x04>;
-		rockchip,cmd_delay = <120>;
-	};
-
-	rockchip,on-cmds7 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc3 0x00 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds8 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xc5 0x00>;
-		rockchip,cmd_delay = <20>;
-	};
-
-	rockchip,on-cmds9 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc0 0x00 0x00 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds10 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc1 0x00 0x61 0x00 0x30 0x29 0x10 0x19 0x63 0x61 0xb4 0xe6 0xdc 0x7b 0xef 0x39 0xd7 0xda 0x08 0x8c 0xb1  0x08 0x54 0x82 0x00 0x00 0x00 0x00 0x00 0x02 0x63 0x27 0x03 0x00 0xff 0x11>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds11 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc2 0x08 0x0a 0x00 0x04 0x04 0xf0 0x00 0x04>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds12 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc4 0x70 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x05 0x01>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds13 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc6 0x5a 0x00 0x2d 0x03 0x01 0x02 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x06 0x15 0x08 0x5a>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds14 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xcb 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x54 0xe0 0x07 0x2a 0xe0 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds15 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x23 0xcc 0x32>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds16 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xd7 0x82 0xff 0x21 0x8e 0x8c 0xf1 0x87 0x3f 0x7e 0x10 0x00 0x00 0x8f>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds17 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xd9 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds18 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xd0 0x11 0x17 0x14 0xfd>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds19 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xd2 0xcd 0x2b 0x2b 0x33 0x12 0x33 0x33 0x33 0x77 0x77 0x33 0x33 0x33 0x00 0x00 0x00>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds20 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xd5 0x06 0x00 0x00 0x01 0x40 0x01 0x40>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds21 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x29 0xc7 0x00 0x10 0x17 0x21 0x2f 0x3d 0x48 0x58 0x3c 0x44 0x50 0x5d 0x66 0x6c 0x75 0x00 0x10 0x17 0x21 0x2f 0x3d 0x48 0x58 0x3c 0x44 0x50 0x5d 0x66 0x6c 0x75>;
-		rockchip,cmd_delay = <0>;
-	};
-
-	rockchip,on-cmds22 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x05 0x29>;
-		rockchip,cmd_delay = <120>;
-	};
-
-	rockchip,on-cmds23 {
-		compatible = "rockchip,on-cmds";
-		rockchip,cmd_type = <LPDT>;
-		rockchip,dsi_id = <2>;
-		rockchip,cmd = <0x05 0x11>;
-		rockchip,cmd_delay = <100>;
-	};
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-	timing0: timing0 {
-		screen-type = <SCREEN_DUAL_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <245000000>;
-		hactive = <1440>;
-		vactive = <2560>;
-		hback-porch = <16>;
-		hfront-porch = <50>;
-		vback-porch = <20>;
-		vfront-porch = <20>;
-		hsync-len = <20>;
-		vsync-len = <10>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		screen-width = <68>;
-		screen-hight = <120>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-rk3128-86v-LVDS1024x600.dtsi b/include/dt-bindings/display/screen-timing/lcd-rk3128-86v-LVDS1024x600.dtsi
deleted file mode 100644
index c4cbc6d9c058..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-rk3128-86v-LVDS1024x600.dtsi
+++ /dev/null
@@ -1,34 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_LVDS1024x600 FOR rk3128-86V
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_LVDS>;
-		lvds-format = <LVDS_8BIT_1>;
-		out-face    = <OUT_P888>;
-		/* Min   Typ   Max Unit
-		 * Clock Frequency fclk  44.9  51.2  63 MHz
-		 */
-		clock-frequency = <60000000>;
-		hactive = <1024>;			  /* Horizontal display area thd 1024       DCLK			*/
-		vactive = <600>;			  /* Vertical display area tvd   600		H				*/
-		hback-porch = <90>;			  /* HS Width +Back Porch   160  160   160  DCLK (Thw+ thbp)*/
-		hfront-porch = <160>;		  /* HS front porch thfp    16   160   216  DCLK			*/
-		vback-porch = <13>;			  /* VS front porch tvfp	1	 12    127  H				*/
-		vfront-porch = <12>;		  /* VS Width+Back Porch    23   23    23   H (Tvw+ tvbp)	*/
-		hsync-len = <70>;			  /* HS Pulse Width thw		1	  -    140  DCLK			*/
-		vsync-len = <10>;			  /* VS Pulse Width tvw		1	  -	20  H				*/
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-td043mgeal.dtsi b/include/dt-bindings/display/screen-timing/lcd-td043mgeal.dtsi
deleted file mode 100644
index 32583775b084..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-td043mgeal.dtsi
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_TD043MGEA1 FOR FPGA
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <27000000>;
-		hactive = <800>;
-		vactive = <480>;
-		hback-porch = <206>;
-		hfront-porch = <40>;
-		vback-porch = <25>;
-		vfront-porch = <10>;
-		hsync-len = <10>;
-		vsync-len = <10>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-tv080wum-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-tv080wum-mipi.dtsi
deleted file mode 100644
index 2bf4ef99b506..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-tv080wum-mipi.dtsi
+++ /dev/null
@@ -1,139 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * arch/arm/boot/dts/lcd-lq070m1sx01-mipi.dtsi
- * author: libing@rock-chips.com
- * create date: 2014-04-15
- * lcd model: ld089wu1
- * resolution: 1920 X 1200
- * mipi channel: single
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-			compatible = "rockchip,mipi_dsi_init";
-			rockchip,screen_init	= <0>;
-			rockchip,dsi_lane		= <4>;
-			rockchip,dsi_hs_clk		= <1000>;
-			rockchip,mipi_dsi_num	= <1>;
-};
-disp_mipi_power_ctr: mipi_power_ctr {
-			compatible = "rockchip,mipi_power_ctr";
-			/*mipi_lcd_rst:mipi_lcd_rst{
-					compatible = "rockchip,lcd_rst";
-					rockchip,gpios = <&gpio2 GPIO_B7 GPIO_ACTIVE_LOW>;
-					rockchip,delay = <100>;
-			};
-			mipi_lcd_en:mipi_lcd_en {
-					compatible = "rockchip,lcd_en";
-					rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <100>;
-			};*/
-};
-disp_mipi_init_cmds: screen-on-cmds {
-			compatible = "rockchip,screen-on-cmds";
-			/*rockchip,cmd_debug = <1>;
-			rockchip,on-cmds1 {
-					compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <HSDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0xb0 0x02>;
-					rockchip,cmd_delay = <0>;
-			};
-			*/
-};
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        compatible = "rockchip,display-timings";
-        timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <150000000>;
-		hactive = <1200>;
-		vactive = <1920>;
-		hback-porch = <80>;
-		hfront-porch = <81>;
-		vback-porch = <21>;
-		vfront-porch = <21>;
-		hsync-len = <10>;
-		vsync-len = <3>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.2*/
-			0x00000383 0x00000392 0x000003a2 0x000003b2 0x000003c2 0x000003d2 0x000003e2 0x000003f3
-			0x00000403 0x00000414 0x00000425 0x00000436 0x00000447 0x00000458 0x0000046a 0x0000047b
-			0x0000048d 0x0000049f 0x000004b1 0x000004c3 0x000004d5 0x000004e8 0x000004fa 0x0000050d
-			0x00000520 0x00000533 0x00000546 0x0000055a 0x0000056d 0x00000581 0x00000595 0x000005a9
-			0x000005bd 0x000005d1 0x000005e5 0x000005fa 0x0000060f 0x00000624 0x00000639 0x0000064e
-			0x00000663 0x00000679 0x0000068e 0x000006a4 0x000006ba 0x000006d0 0x000006e6 0x000006fd
-			0x00000713 0x0000072a 0x00000741 0x00000758 0x0000076f 0x00000786 0x0000079e 0x000007b6
-			0x000007cd 0x000007e5 0x000007fd 0x00000816 0x0000082e 0x00000847 0x0000085f 0x00000878
-			0x00000891 0x000008ab 0x000008c4 0x000008de 0x000008f7 0x00000911 0x0000092b 0x00000945
-			0x00000960 0x0000097a 0x00000995 0x000009af 0x000009ca 0x000009e6 0x00000a01 0x00000a1c
-			0x00000a38 0x00000a54 0x00000a6f 0x00000a8c 0x00000aa8 0x00000ac4 0x00000ae1 0x00000afd
-			0x00000b1a 0x00000b37 0x00000b54 0x00000b72 0x00000b8f 0x00000bad 0x00000bcb 0x00000be9
-			0x00000c07 0x00000c25 0x00000c44 0x00000c62 0x00000c81 0x00000ca0 0x00000cbf 0x00000cdf
-			0x00000cfe 0x00000d1e 0x00000d3e 0x00000d5d 0x00000d7e 0x00000d9e 0x00000dbe 0x00000ddf
-			0x00000e00 0x00000e21 0x00000e42 0x00000e63 0x00000e84 0x00000ea6 0x00000ec8 0x00000eea
-			0x00000f0c 0x00000f2e 0x00000f50 0x00000f73 0x00000f96 0x00000fb9 0x00000fdc 0x00000fff
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000>;
-		cabc-gamma-base = <
-			/*gamma = 2.2*/
-			0x00010000 0x0000fdd0 0x0000fba8 0x0000f986 0x0000f76a 0x0000f556 0x0000f347 0x0000f140
-			0x0000ef3e 0x0000ed43 0x0000eb4e 0x0000e95e 0x0000e775 0x0000e592 0x0000e3b4 0x0000e1dc
-			0x0000e009 0x0000de3c 0x0000dc74 0x0000dab2 0x0000d8f4 0x0000d73c 0x0000d589 0x0000d3db
-			0x0000d232 0x0000d08d 0x0000ceee 0x0000cd53 0x0000cbbc 0x0000ca2b 0x0000c89d 0x0000c714
-			0x0000c590 0x0000c410 0x0000c294 0x0000c11c 0x0000bfa8 0x0000be39 0x0000bccd 0x0000bb65
-			0x0000ba01 0x0000b8a1 0x0000b745 0x0000b5ed 0x0000b498 0x0000b347 0x0000b1f9 0x0000b0af
-			0x0000af68 0x0000ae25 0x0000ace5 0x0000aba8 0x0000aa6f 0x0000a939 0x0000a806 0x0000a6d7
-			0x0000a5aa 0x0000a480 0x0000a35a 0x0000a236 0x0000a116 0x00009ff8 0x00009edd 0x00009dc5
-			0x00009cb0 0x00009b9e 0x00009a8e 0x00009981 0x00009877 0x0000976f 0x0000966a 0x00009567
-			0x00009467 0x0000936a 0x0000926f 0x00009176 0x00009080 0x00008f8c 0x00008e9a 0x00008dab
-			0x00008cbe 0x00008bd3 0x00008aea 0x00008a04 0x00008920 0x0000883e 0x0000875e 0x00008680
-			0x000085a4 0x000084ca 0x000083f3 0x0000831d 0x00008249 0x00008177 0x000080a7 0x00007fd9
-			0x00007f0d 0x00007e42 0x00007d7a 0x00007cb3 0x00007bee 0x00007b2b 0x00007a6a 0x000079aa
-			0x000078ec 0x0000782f 0x00007775 0x000076bc 0x00007604 0x0000754f 0x0000749a 0x000073e8
-			0x00007337 0x00007287 0x000071d9 0x0000712c 0x00007081 0x00006fd8 0x00006f30 0x00006e89
-			0x00006de4 0x00006d40 0x00006c9d 0x00006bfc 0x00006b5c 0x00006abe 0x00006a21 0x00006985
-			0x000068ea 0x00006851 0x000067b9 0x00006722 0x0000668d 0x000065f9 0x00006566 0x000064d4
-			0x00006443 0x000063b4 0x00006325 0x00006298 0x0000620c 0x00006181 0x000060f8 0x0000606f
-			0x00005fe7 0x00005f61 0x00005edb 0x00005e57 0x00005dd4 0x00005d51 0x00005cd0 0x00005c50
-			0x00005bd1 0x00005b52 0x00005ad5 0x00005a59 0x000059de 0x00005963 0x000058ea 0x00005871
-			0x000057fa 0x00005783 0x0000570d 0x00005699 0x00005625 0x000055b2 0x0000553f 0x000054ce
-			0x0000545d 0x000053ee 0x0000537f 0x00005311 0x000052a4 0x00005238 0x000051cc 0x00005161
-			0x000050f7 0x0000508e 0x00005026 0x00004fbe 0x00004f57 0x00004ef1 0x00004e8c 0x00004e27
-			0x00004dc3 0x00004d60 0x00004cfe 0x00004c9c 0x00004c3b 0x00004bdb 0x00004b7b 0x00004b1c
-			0x00004abe 0x00004a60 0x00004a03 0x000049a7 0x0000494b 0x000048f0 0x00004896 0x0000483c
-			0x000047e3 0x0000478a 0x00004733 0x000046db 0x00004685 0x0000462f 0x000045d9 0x00004584
-			0x00004530 0x000044dc 0x00004489 0x00004437 0x000043e5 0x00004393 0x00004342 0x000042f2
-			0x000042a2 0x00004253 0x00004204 0x000041b6 0x00004169 0x0000411b 0x000040cf 0x00004083
-			0x00004037 0x00003fec 0x00003fa1 0x00003f57 0x00003f0e 0x00003ec5 0x00003e7c 0x00003e34
-			0x00003dec 0x00003da5 0x00003d5e 0x00003d18 0x00003cd2 0x00003c8c 0x00003c48 0x00003c03
-			0x00003bbf 0x00003b7b 0x00003b38 0x00003af5 0x00003ab3 0x00003a71 0x00003a30 0x000039ef
-			0x000039ae 0x0000396e 0x0000392e 0x000038ee 0x000038af 0x00003871 0x00003832 0x000037f5>;
-			};
-	};
diff --git a/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi
deleted file mode 100644
index b408d6555de8..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- *
- * include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi
- * author: hjc@rock-chips.com
- * create date: 2016-03-28
- * lcd model: tv080wum-n10
- * resolution: 1200 * 1920
- * mipi channel: single
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-	compatible = "rockchip,mipi_dsi_init";
-	rockchip,screen_init	= <0>;
-	rockchip,dsi_lane	= <4>;
-	rockchip,dsi_hs_clk	= <1200>;
-	rockchip,mipi_dsi_num	= <1>;
-};
-
-disp_mipi_power_ctr: mipi_power_ctr {
-	compatible = "rockchip,mipi_power_ctr";
-	/* mipi_lcd_rst:mipi_lcd_rst{
-			compatible = "rockchip,lcd_rst";
-			rockchip,gpios = <&gpio2 GPIO_B7 GPIO_ACTIVE_LOW>;
-			rockchip,delay = <100>;
-	};
-	mipi_lcd_en:mipi_lcd_en {
-			compatible = "rockchip,lcd_en";
-			rockchip,gpios = <&gpio0 GPIO_C1 GPIO_ACTIVE_HIGH>;
-			rockchip,delay = <100>;
-	};
-	*/
-};
-
-disp_mipi_init_cmds: screen-on-cmds {
-	compatible = "rockchip,screen-on-cmds";
-	/* rockchip,cmd_debug = <1>;
-	rockchip,on-cmds1 {
-			compatible = "rockchip,on-cmds";
-			rockchip,cmd_type = <HSDT>;
-			rockchip,dsi_id = <2>;
-			rockchip,cmd = <0xb0 0x02>;
-			rockchip,cmd_delay = <0>;
-	};
-	*/
-};
-
-disp_timings: display-timings {
-	native-mode = <&timing0>;
-	compatible = "rockchip,display-timings";
-	timing0: timing0 {
-		screen-type = <SCREEN_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <160000000>;
-		hactive = <1200>;
-		vactive = <1920>;
-		hback-porch = <21>;
-		hfront-porch = <120>;
-		vback-porch = <18>;
-		vfront-porch = <21>;
-		hsync-len = <20>;
-		vsync-len = <3>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-		cabc-lut = <
-			/*gamma = 2.2*/
-			0x00000383 0x00000392 0x000003a2 0x000003b2 0x000003c2 0x000003d2 0x000003e2 0x000003f3
-			0x00000403 0x00000414 0x00000425 0x00000436 0x00000447 0x00000458 0x0000046a 0x0000047b
-			0x0000048d 0x0000049f 0x000004b1 0x000004c3 0x000004d5 0x000004e8 0x000004fa 0x0000050d
-			0x00000520 0x00000533 0x00000546 0x0000055a 0x0000056d 0x00000581 0x00000595 0x000005a9
-			0x000005bd 0x000005d1 0x000005e5 0x000005fa 0x0000060f 0x00000624 0x00000639 0x0000064e
-			0x00000663 0x00000679 0x0000068e 0x000006a4 0x000006ba 0x000006d0 0x000006e6 0x000006fd
-			0x00000713 0x0000072a 0x00000741 0x00000758 0x0000076f 0x00000786 0x0000079e 0x000007b6
-			0x000007cd 0x000007e5 0x000007fd 0x00000816 0x0000082e 0x00000847 0x0000085f 0x00000878
-			0x00000891 0x000008ab 0x000008c4 0x000008de 0x000008f7 0x00000911 0x0000092b 0x00000945
-			0x00000960 0x0000097a 0x00000995 0x000009af 0x000009ca 0x000009e6 0x00000a01 0x00000a1c
-			0x00000a38 0x00000a54 0x00000a6f 0x00000a8c 0x00000aa8 0x00000ac4 0x00000ae1 0x00000afd
-			0x00000b1a 0x00000b37 0x00000b54 0x00000b72 0x00000b8f 0x00000bad 0x00000bcb 0x00000be9
-			0x00000c07 0x00000c25 0x00000c44 0x00000c62 0x00000c81 0x00000ca0 0x00000cbf 0x00000cdf
-			0x00000cfe 0x00000d1e 0x00000d3e 0x00000d5d 0x00000d7e 0x00000d9e 0x00000dbe 0x00000ddf
-			0x00000e00 0x00000e21 0x00000e42 0x00000e63 0x00000e84 0x00000ea6 0x00000ec8 0x00000eea
-			0x00000f0c 0x00000f2e 0x00000f50 0x00000f73 0x00000f96 0x00000fb9 0x00000fdc 0x00000fff
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000
-			0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000>;
-		cabc-gamma-base = <
-			/*gamma = 2.2*/
-			0x00010000 0x0000fdd0 0x0000fba8 0x0000f986 0x0000f76a 0x0000f556 0x0000f347 0x0000f140
-			0x0000ef3e 0x0000ed43 0x0000eb4e 0x0000e95e 0x0000e775 0x0000e592 0x0000e3b4 0x0000e1dc
-			0x0000e009 0x0000de3c 0x0000dc74 0x0000dab2 0x0000d8f4 0x0000d73c 0x0000d589 0x0000d3db
-			0x0000d232 0x0000d08d 0x0000ceee 0x0000cd53 0x0000cbbc 0x0000ca2b 0x0000c89d 0x0000c714
-			0x0000c590 0x0000c410 0x0000c294 0x0000c11c 0x0000bfa8 0x0000be39 0x0000bccd 0x0000bb65
-			0x0000ba01 0x0000b8a1 0x0000b745 0x0000b5ed 0x0000b498 0x0000b347 0x0000b1f9 0x0000b0af
-			0x0000af68 0x0000ae25 0x0000ace5 0x0000aba8 0x0000aa6f 0x0000a939 0x0000a806 0x0000a6d7
-			0x0000a5aa 0x0000a480 0x0000a35a 0x0000a236 0x0000a116 0x00009ff8 0x00009edd 0x00009dc5
-			0x00009cb0 0x00009b9e 0x00009a8e 0x00009981 0x00009877 0x0000976f 0x0000966a 0x00009567
-			0x00009467 0x0000936a 0x0000926f 0x00009176 0x00009080 0x00008f8c 0x00008e9a 0x00008dab
-			0x00008cbe 0x00008bd3 0x00008aea 0x00008a04 0x00008920 0x0000883e 0x0000875e 0x00008680
-			0x000085a4 0x000084ca 0x000083f3 0x0000831d 0x00008249 0x00008177 0x000080a7 0x00007fd9
-			0x00007f0d 0x00007e42 0x00007d7a 0x00007cb3 0x00007bee 0x00007b2b 0x00007a6a 0x000079aa
-			0x000078ec 0x0000782f 0x00007775 0x000076bc 0x00007604 0x0000754f 0x0000749a 0x000073e8
-			0x00007337 0x00007287 0x000071d9 0x0000712c 0x00007081 0x00006fd8 0x00006f30 0x00006e89
-			0x00006de4 0x00006d40 0x00006c9d 0x00006bfc 0x00006b5c 0x00006abe 0x00006a21 0x00006985
-			0x000068ea 0x00006851 0x000067b9 0x00006722 0x0000668d 0x000065f9 0x00006566 0x000064d4
-			0x00006443 0x000063b4 0x00006325 0x00006298 0x0000620c 0x00006181 0x000060f8 0x0000606f
-			0x00005fe7 0x00005f61 0x00005edb 0x00005e57 0x00005dd4 0x00005d51 0x00005cd0 0x00005c50
-			0x00005bd1 0x00005b52 0x00005ad5 0x00005a59 0x000059de 0x00005963 0x000058ea 0x00005871
-			0x000057fa 0x00005783 0x0000570d 0x00005699 0x00005625 0x000055b2 0x0000553f 0x000054ce
-			0x0000545d 0x000053ee 0x0000537f 0x00005311 0x000052a4 0x00005238 0x000051cc 0x00005161
-			0x000050f7 0x0000508e 0x00005026 0x00004fbe 0x00004f57 0x00004ef1 0x00004e8c 0x00004e27
-			0x00004dc3 0x00004d60 0x00004cfe 0x00004c9c 0x00004c3b 0x00004bdb 0x00004b7b 0x00004b1c
-			0x00004abe 0x00004a60 0x00004a03 0x000049a7 0x0000494b 0x000048f0 0x00004896 0x0000483c
-			0x000047e3 0x0000478a 0x00004733 0x000046db 0x00004685 0x0000462f 0x000045d9 0x00004584
-			0x00004530 0x000044dc 0x00004489 0x00004437 0x000043e5 0x00004393 0x00004342 0x000042f2
-			0x000042a2 0x00004253 0x00004204 0x000041b6 0x00004169 0x0000411b 0x000040cf 0x00004083
-			0x00004037 0x00003fec 0x00003fa1 0x00003f57 0x00003f0e 0x00003ec5 0x00003e7c 0x00003e34
-			0x00003dec 0x00003da5 0x00003d5e 0x00003d18 0x00003cd2 0x00003c8c 0x00003c48 0x00003c03
-			0x00003bbf 0x00003b7b 0x00003b38 0x00003af5 0x00003ab3 0x00003a71 0x00003a30 0x000039ef
-			0x000039ae 0x0000396e 0x0000392e 0x000038ee 0x000038af 0x00003871 0x00003832 0x000037f5>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-vga.dtsi b/include/dt-bindings/display/screen-timing/lcd-vga.dtsi
deleted file mode 100644
index 13d214b2e8c8..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-vga.dtsi
+++ /dev/null
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. VGA timing
- *
- */
-
-disp_timings: display-timings {
-	native-mode = <&timing1>;
-	timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face = <OUT_D888_P666>;
-		clock-frequency = <65000000>;
-		hactive = <1024>;
-		vactive = <768>;
-		hback-porch = <160>;
-		hfront-porch = <24>;
-		vback-porch = <29>;
-		vfront-porch = <3>;
-		hsync-len = <136>;
-		vsync-len = <6>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-
-	timing1: timing1 {
-		screen-type = <SCREEN_RGB>;
-		out-face = <OUT_D888_P666>;
-		lvds-format = <LVDS_8BIT_2>;
-		clock-frequency = <88750000>;
-		hactive = <1440>;
-		vactive = <900>;
-		hback-porch = <80>;
-		hfront-porch = <48>;
-		vback-porch = <17>;
-		vfront-porch = <3>;
-		hsync-len = <32>;
-		vsync-len = <6>;
-		hsync-active = <1>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-
-	timing2: timing2 {
-		screen-type = <SCREEN_RGB>;
-		out-face = <OUT_D888_P666>;
-		lvds-format = <LVDS_8BIT_2>;
-		clock-frequency = <106500000>;
-		hactive = <1440>;
-		vactive = <900>;
-		hback-porch = <232>;
-		hfront-porch = <80>;
-		vback-porch = <25>;
-		vfront-porch = <3>;
-		hsync-len = <152>;
-		vsync-len = <6>;
-		hsync-active = <0>;
-		vsync-active = <1>;
-		de-active = <0>;
-		pixelclk-active = <1>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-wqxga-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-wqxga-mipi.dtsi
deleted file mode 100644
index e41c7d147747..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-wqxga-mipi.dtsi
+++ /dev/null
@@ -1,205 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- * arch/arm/boot/dts/lcd-lq070m1sx01-mipi.dtsi
- * author: libing@rock-chips.com
- * create date: 2014-04-15
- * lcd model: wqxga
- * resolution: 2560 X 1600
- * mipi channel: dual
- */
-
-/* about mipi */
-disp_mipi_init: mipi_dsi_init{
-			compatible = "rockchip,mipi_dsi_init";
-			rockchip,screen_init	= <1>;
-			rockchip,dsi_lane		= <4>;
-			rockchip,dsi_hs_clk		= <940>;
-			rockchip,mipi_dsi_num	= <2>;
-};
-disp_mipi_power_ctr: mipi_power_ctr {
-                        compatible = "rockchip,mipi_power_ctr";
-			mipi_lcd_rst:mipi_lcd_rst{
-			        compatible = "rockchip,lcd_rst";
-					rockchip,gpios = <&gpio7 GPIO_B2 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <10>;
-			};
-			mipi_lcd_en:mipi_lcd_en {
-			        compatible = "rockchip,lcd_en";
-					rockchip,gpios = <&gpio6 GPIO_A7 GPIO_ACTIVE_HIGH>;
-					rockchip,delay = <10>;
-			};
-};
-disp_mipi_init_cmds: screen-on-cmds {
-			rockchip,cmd_debug = <0>;
-			compatible = "rockchip,screen-on-cmds";
-	                rockchip,on-cmds1 {
-                                        compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 0x01>; //set soft reset
-					rockchip,cmd_delay = <10>;
-			};
-
-	                rockchip,on-cmds2 {
-                                        compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 0x01>; //set soft reset
-					rockchip,cmd_delay = <10>;
-			};
-			rockchip,on-cmds3 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x3a 0x77>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds4 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x39 0x2a 0x00 0x00 0x04 0xff>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds5 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x39 0x2b 0x00 0x00 0x06 0x3f>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds6 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <0>;
-					rockchip,cmd = <0x15 0x35 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds7 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <0>;
-					rockchip,cmd = <0x39 0x44 0x00 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds8 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x51 0xff>; //0xff
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds9 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x53 0x04>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds10 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x51 0xff>; //0xff
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds11 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x53 0x04>;
-					rockchip,cmd_delay = <0>;
-			};
-
-			rockchip,on-cmds12 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x15 0x55 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds13 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 dcs_exit_sleep_mode>;
-					rockchip,cmd_delay = <120>;
-			};
-
-			rockchip,on-cmds14 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x23 0xb0 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-
-			rockchip,on-cmds15 { //video
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x29 0xb3 0x1c>;
-					rockchip,cmd_delay = <0>;
-			};
-
-			rockchip,on-cmds16 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x29 0xce 0x7d 0x40 0x48 0x56 0x67 0x78 0x88 0x98 0xa7 0xb5 0xc3 0xd1 0xde 0xe9 0xf2 0xfa 0xff 0x04 0x00>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds17 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x23 0xb0 0x03>;
-					rockchip,cmd_delay = <0>;
-			};
-			rockchip,on-cmds18 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x39 0x2c >;
-					rockchip,cmd_delay = <0>;
-			};
-
-			rockchip,on-cmds19 {
-			                compatible = "rockchip,on-cmds";
-					rockchip,cmd_type = <LPDT>;
-					rockchip,dsi_id = <2>;
-					rockchip,cmd = <0x05 dcs_set_display_on>;
-					rockchip,cmd_delay = <10>;
-			};
-
-};
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        compatible = "rockchip,display-timings";
-        timing0: timing0 {
-		screen-type = <SCREEN_DUAL_MIPI>;
-		lvds-format = <LVDS_8BIT_2>;
-		out-face    = <OUT_P888>;
-		clock-frequency = <265000000>;
-		hactive = <2560>;
-		vactive = <1600>;
-
-		hsync-len = <38>;//19
-		hback-porch = <40>;//40
-		hfront-porch = <108>;//123
-
-		vsync-len = <4>;
-		vback-porch = <4>;
-		vfront-porch = <12>;
-
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/dt-bindings/display/screen-timing/lcd-y81349.dtsi b/include/dt-bindings/display/screen-timing/lcd-y81349.dtsi
deleted file mode 100644
index f0db3a36b142..000000000000
--- a/include/dt-bindings/display/screen-timing/lcd-y81349.dtsi
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * RockChip. LCD_Y81349 FOR 86V
- *
- */
-
-
-disp_timings: display-timings {
-        native-mode = <&timing0>;
-        timing0: timing0 {
-		screen-type = <SCREEN_RGB>;
-		out-face    = <OUT_P666>;
-		clock-frequency = <33000000>;
-		hactive = <800>;
-		vactive = <480>;
-		hback-porch = <10>;
-		hfront-porch = <210>;
-		vback-porch = <10>;
-		vfront-porch = <22>;
-		hsync-len = <30>;
-		vsync-len = <13>;
-		hsync-active = <0>;
-		vsync-active = <0>;
-		de-active = <0>;
-		pixelclk-active = <0>;
-		swap-rb = <0>;
-		swap-rg = <0>;
-		swap-gb = <0>;
-	};
-};
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
deleted file mode 100755
index 944d997b38ec..000000000000
--- a/include/linux/rk_fb.h
+++ /dev/null
@@ -1,851 +0,0 @@
-/* drivers/video/rk_fb.h
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __ARCH_ARM_MACH_RK30_FB_H
-#define __ARCH_ARM_MACH_RK30_FB_H
-
-#include <linux/fb.h>
-#include <linux/platform_device.h>
-#include <linux/completion.h>
-#include <linux/spinlock.h>
-#include <asm/atomic.h>
-#include <linux/rk_screen.h>
-#if defined(CONFIG_OF)
-#include <dt-bindings/display/rk_fb.h>
-#endif
-#include "../../drivers/staging/android/sw_sync.h"
-#include <linux/file.h>
-#include <linux/kthread.h>
-#include <linux/pm_runtime.h>
-#include <linux/version.h>
-
-
-#define RK30_MAX_LCDC_SUPPORT	2
-#define RK30_MAX_LAYER_SUPPORT	5
-#define RK_MAX_FB_SUPPORT       5
-#define RK_WIN_MAX_AREA		4
-#define RK_MAX_BUF_NUM		11
-
-#define FB0_IOCTL_STOP_TIMER_FLUSH		0x6001
-#define FB0_IOCTL_SET_PANEL				0x6002
-
-#ifdef CONFIG_FB_WIMO
-#define FB_WIMO_FLAG
-#endif
-#ifdef FB_WIMO_FLAG
-#define FB0_IOCTL_SET_BUF				0x6017
-#define FB0_IOCTL_COPY_CURBUF				0x6018
-#define FB0_IOCTL_CLOSE_BUF				0x6019
-#endif
-
-#define RK_FBIOGET_PANEL_SIZE				0x5001
-#define RK_FBIOSET_YUV_ADDR				0x5002
-#define RK_FBIOGET_SCREEN_STATE    			0X4620
-#define RK_FBIOGET_16OR32    				0X4621
-#define RK_FBIOGET_IDLEFBUff_16OR32			0X4622
-#define RK_FBIOSET_COMPOSE_LAYER_COUNTS    		0X4623
-#define RK_FBIOSET_HWC_ADDR				0x4624
-
-#define RK_FBIOGET_DMABUF_FD            		0x5003
-#define RK_FBIOSET_DMABUF_FD				0x5004
-#define RK_FB_IOCTL_SET_I2P_ODD_ADDR       		0x5005
-#define RK_FB_IOCTL_SET_I2P_EVEN_ADDR      		0x5006
-#define RK_FBIOSET_OVERLAY_STA    			0x5018
-#define RK_FBIOGET_OVERLAY_STA   			0X4619
-#define RK_FBIOSET_ENABLE				0x5019
-#define RK_FBIOGET_ENABLE				0x5020
-#define RK_FBIOSET_CONFIG_DONE				0x4628
-#define RK_FBIOSET_VSYNC_ENABLE				0x4629
-#define RK_FBIOPUT_NUM_BUFFERS				0x4625
-#define RK_FBIOPUT_COLOR_KEY_CFG			0x4626
-#define RK_FBIOGET_DSP_ADDR     			0x4630
-#define RK_FBIOGET_LIST_STA  				0X4631
-#define RK_FBIOGET_IOMMU_STA				0x4632
-#define RK_FBIOSET_CLEAR_FB				0x4633
-
-
-/**rk fb events**/
-#define RK_LF_STATUS_FC                  0xef
-#define RK_LF_STATUS_FR                  0xee
-#define RK_LF_STATUS_NC                  0xfe
-#define RK_LF_MAX_TIMEOUT 			 (1600000UL << 6)	//>0.64s
-
-/**
-* pixel align value for gpu,align as 64 bytes in an odd number of times
-*/
-#define ALIGN_PIXEL_64BYTE_RGB565		32	/* 64/2*/
-#define ALIGN_PIXEL_64BYTE_RGB8888		16	/* 64/4*/
-#define ALIGN_N_TIMES(x, align)			(((x) % (align) == 0) ? (x) : (((x) + ((align) - 1)) & (~((align) - 1))))
-#define ALIGN_ODD_TIMES(x, align)		(((x) % ((align) * 2) == 0) ? ((x) + (align)) : (x))
-#define ALIGN_64BYTE_ODD_TIMES(x, align)	ALIGN_ODD_TIMES(ALIGN_N_TIMES(x, align), align)
-
-#define DUMP_FRAME_NUM 3
-
-//#define USE_ION_MMU 1
-#if defined(CONFIG_ION_ROCKCHIP)
-extern struct ion_client *rockchip_ion_client_create(const char *name);
-#endif
-
-extern int rk_fb_poll_prmry_screen_vblank(void);
-extern u32 rk_fb_get_prmry_screen_ft(void);
-extern u32 rk_fb_get_prmry_screen_vbt(void);
-extern u64 rk_fb_get_prmry_screen_framedone_t(void);
-extern int rk_fb_set_prmry_screen_status(int status);
-extern bool rk_fb_poll_wait_frame_complete(void);
-
-enum {
-	CSC_BT601,
-	CSC_BT709,
-	CSC_BT2020,
-};
-#define CSC_SHIFT	6
-#define CSC_MASK	(0x3 << CSC_SHIFT)
-#define CSC_FORMAT(x)	(((x) & CSC_MASK) >> CSC_SHIFT)
-
-#define BT601(x)	((CSC_BT601 << CSC_SHIFT) | ((x) & ~CSC_MASK))
-#define BT709(x)	((CSC_BT709 << CSC_SHIFT) | ((x) & ~CSC_MASK))
-#define BT2020(x)	((CSC_BT2020 << CSC_SHIFT) | ((x) & ~CSC_MASK))
-
-enum {
-	SDR_DATA,
-	HDR_DATA,
-};
-
-/**
- * pixel format definitions,this is copy from android/system/core/include/system/graphics.h
- */
-enum {
-	HAL_PIXEL_FORMAT_RGBA_8888 = 1,
-	HAL_PIXEL_FORMAT_RGBX_8888 = 2,
-	HAL_PIXEL_FORMAT_RGB_888 = 3,
-	HAL_PIXEL_FORMAT_RGB_565 = 4,
-	HAL_PIXEL_FORMAT_BGRA_8888 = 5,
-	HAL_PIXEL_FORMAT_RGBA_5551 = 6,
-	HAL_PIXEL_FORMAT_RGBA_4444 = 7,
-
-	/* 0x8 - 0xFF range unavailable */
-
-	/*
-	 * 0x100 - 0x1FF
-	 *
-	 * This range is reserved for pixel formats that are specific to the HAL
-	 * implementation.  Implementations can use any value in this range to
-	 * communicate video pixel formats between their HAL modules.  These formats
-	 * must not have an alpha channel.  Additionally, an EGLimage created from a
-	 * gralloc buffer of one of these formats must be supported for use with the
-	 * GL_OES_EGL_image_external OpenGL ES extension.
-	 */
-
-	/*
-	 * Android YUV format:
-	 *
-	 * This format is exposed outside of the HAL to software decoders and
-	 * applications.  EGLImageKHR must support it in conjunction with the
-	 * OES_EGL_image_external extension.
-	 *
-	 * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
-	 * by (W/2) x (H/2) Cr and Cb planes.
-	 *
-	 * This format assumes
-	 * - an even width
-	 * - an even height
-	 * - a horizontal stride multiple of 16 pixels
-	 * - a vertical stride equal to the height
-	 *
-	 *   y_size = stride * height
-	 *   c_size = ALIGN(stride/2, 16) * height/2
-	 *   size = y_size + c_size * 2
-	 *   cr_offset = y_size
-	 *   cb_offset = y_size + c_size
-	 *
-	 */
-	HAL_PIXEL_FORMAT_YV12 = 0x32315659,	// YCrCb 4:2:0 Planar
-
-	/* Legacy formats (deprecated), used by ImageFormat.java */
-
-	/*
-	 * YCbCr format default is BT601.
-	 */
-	HAL_PIXEL_FORMAT_YCbCr_422_SP = 0x10,	// NV16
-	HAL_PIXEL_FORMAT_YCrCb_420_SP = 0x11,	// NV21
-	HAL_PIXEL_FORMAT_YCbCr_422_I = 0x14,	// YUY2
-	HAL_PIXEL_FORMAT_YCrCb_NV12 = 0x20,	// YUY2
-	HAL_PIXEL_FORMAT_YCrCb_NV12_VIDEO = 0x21,	// YUY2
-	
-	HAL_PIXEL_FORMAT_YCrCb_NV12_10	    = 0x22, // YUV420_1obit
-	HAL_PIXEL_FORMAT_YCbCr_422_SP_10	= 0x23, // YUV422_1obit
-	HAL_PIXEL_FORMAT_YCrCb_444_SP_10	= 0x24, //YUV444_1obit
-
-	HAL_PIXEL_FORMAT_YCrCb_444 = 0x25,	//yuv444
-	HAL_PIXEL_FORMAT_FBDC_RGB565	= 0x26,
-	HAL_PIXEL_FORMAT_FBDC_U8U8U8U8	= 0x27, /*ARGB888*/
-	HAL_PIXEL_FORMAT_FBDC_U8U8U8	= 0x28, /*RGBP888*/
-	HAL_PIXEL_FORMAT_FBDC_RGBA888	= 0x29, /*ABGR888*/
-	HAL_PIXEL_FORMAT_BGRX_8888 = 0x30,
-	HAL_PIXEL_FORMAT_BGR_888 = 0x31,
-	HAL_PIXEL_FORMAT_BGR_565 = 0x32,
-
-	HAL_PIXEL_FORMAT_YUYV422 = 0x33,
-	HAL_PIXEL_FORMAT_YUYV420 = 0x34,
-	HAL_PIXEL_FORMAT_UYVY422 = 0x35,
-	HAL_PIXEL_FORMAT_UYVY420 = 0x36,
-
-	HAL_PIXEL_FORMAT_YCrCb_NV12_BT709 =
-			BT709(HAL_PIXEL_FORMAT_YCrCb_NV12),
-	HAL_PIXEL_FORMAT_YCrCb_NV12_VIDEO_BT709 =
-			BT709(HAL_PIXEL_FORMAT_YCrCb_NV12_VIDEO),
-	HAL_PIXEL_FORMAT_YCbCr_422_SP_BT709 =
-			BT709(HAL_PIXEL_FORMAT_YCbCr_422_SP),
-	HAL_PIXEL_FORMAT_YCrCb_444_BT709 =
-			BT709(HAL_PIXEL_FORMAT_YCrCb_444),
-
-	HAL_PIXEL_FORMAT_YCrCb_NV12_10_BT709 =
-			BT709(HAL_PIXEL_FORMAT_YCrCb_NV12_10),
-	HAL_PIXEL_FORMAT_YCbCr_422_SP_10_BT709	=
-			BT709(HAL_PIXEL_FORMAT_YCbCr_422_SP_10),
-	HAL_PIXEL_FORMAT_YCrCb_420_SP_10_BT709	=
-			BT709(HAL_PIXEL_FORMAT_YCrCb_444_SP_10),
-
-	HAL_PIXEL_FORMAT_YCrCb_NV12_10_BT2020 =
-			BT2020(HAL_PIXEL_FORMAT_YCrCb_NV12_10),
-	HAL_PIXEL_FORMAT_YCbCr_422_SP_10_BT2020	=
-			BT2020(HAL_PIXEL_FORMAT_YCbCr_422_SP_10),
-	HAL_PIXEL_FORMAT_YCrCb_420_SP_10_BT2020	=
-			BT2020(HAL_PIXEL_FORMAT_YCrCb_444_SP_10),
-};
-
-//display data format
-enum data_format {
-	ARGB888,/*don't update and insert other format*/
-	RGB888, /*don't update and insert other format*/
-	RGB565, /*don't update and insert other format*/
-	BGR888,
-	XRGB888,
-	XBGR888,
-	ABGR888,
-	BGR565,
-	FBDC_RGB_565,
-	FBDC_ARGB_888,
-	FBDC_RGBX_888,
-	FBDC_ABGR_888,
-	YUV420,
-	YUV422,
-	YUV444,
-	YUV420_A,
-	YUV422_A,
-	YUV444_A,
-	YUV420_NV21,
-	YUYV422,
-	YUYV420,
-	UYVY422,
-	UYVY420
-};
-#define IS_YUV_FMT(fmt) ((fmt >= YUV420) ? 1 : 0)
-#define IS_RGB_FMT(fmt) ((fmt < YUV420) ? 1 : 0)
-#define IS_FBDC_FMT(fmt) \
-	(((fmt >= FBDC_RGB_565) && (fmt <= FBDC_ABGR_888)) ? 1 : 0)
-
-enum
-{
-	SCALE_NONE = 0x0,
-	SCALE_UP   = 0x1,
-	SCALE_DOWN = 0x2
-};
-
-typedef enum {
-	BRIGHTNESS	= 0x0,
-	CONTRAST        = 0x1,
-	SAT_CON		= 0x2
-} bcsh_bcs_mode;
-
-typedef enum {
-	H_SIN		= 0x0,
-	H_COS       	= 0x1
-} bcsh_hue_mode;
-
-typedef enum {
-	SCREEN_PREPARE_DDR_CHANGE = 0x0,
-	SCREEN_UNPREPARE_DDR_CHANGE,
-} screen_status;
-
-typedef enum {
-	GET_PAGE_FAULT	= 0x0,
-	CLR_PAGE_FAULT  = 0x1,
-	UNMASK_PAGE_FAULT = 0x2,
-	UPDATE_CABC_PWM = 0x3,
-	SET_DSP_MIRROR = 0x4
-} extern_func;
-
-enum rk_vop_feature {
-	SUPPORT_VOP_IDENTIFY	= BIT(0),
-	SUPPORT_IFBDC		= BIT(1),
-	SUPPORT_AFBDC		= BIT(2),
-	SUPPORT_WRITE_BACK	= BIT(3),
-	SUPPORT_YUV420_OUTPUT	= BIT(4)
-};
-
-struct rk_vop_property {
-	u32 feature;
-	u32 max_output_x;
-	u32 max_output_y;
-};
-
-enum rk_win_feature {
-	SUPPORT_WIN_IDENTIFY	= BIT(0),
-	SUPPORT_HW_EXIST	= BIT(1),
-	SUPPORT_SCALE		= BIT(2),
-	SUPPORT_YUV		= BIT(3),
-	SUPPORT_YUV10BIT	= BIT(4),
-	SUPPORT_MULTI_AREA	= BIT(5),
-	SUPPORT_HWC_LAYER	= BIT(6)
-};
-
-struct rk_win_property {
-	u32 feature;
-	u32 max_input_x;
-	u32 max_input_y;
-};
-
-struct rk_fb_rgb {
-	struct fb_bitfield red;
-	struct fb_bitfield green;
-	struct fb_bitfield blue;
-	struct fb_bitfield transp;
-};
-
-struct rk_fb_frame_time {
-	u64 last_framedone_t;
-	u64 framedone_t;
-	u32 ft;
-};
-
-struct rk_fb_vsync {
-	wait_queue_head_t wait;
-	ktime_t timestamp;
-	int active;
-	bool irq_stop;
-	int irq_refcount;
-	struct mutex irq_lock;
-	struct task_struct *thread;
-};
-
-struct color_key_cfg {
-	u32 win0_color_key_cfg;
-	u32 win1_color_key_cfg;
-	u32 win2_color_key_cfg;
-};
-
-struct pwr_ctr {
-	char name[32];
-	int type;
-	int is_rst;
-	int gpio;
-	int atv_val;
-	const char *rgl_name;
-	int volt;
-	int delay;
-};
-
-struct rk_disp_pwr_ctr_list {
-	struct list_head list;
-	struct pwr_ctr pwr_ctr;
-};
-
-typedef enum _TRSP_MODE {
-	TRSP_CLOSE = 0,
-	TRSP_FMREG,
-	TRSP_FMREGEX,
-	TRSP_FMRAM,
-	TRSP_FMRAMEX,
-	TRSP_MASK,
-	TRSP_INVAL
-} TRSP_MODE;
-
-struct rk_lcdc_post_cfg {
-	u32 xpos;
-	u32 ypos;
-	u32 xsize;
-	u32 ysize;
-};
-
-struct rk_fb_wb_cfg {
-	u8  data_format;
-	short ion_fd;
-	u32 phy_addr;
-	u16 xsize;
-	u16 ysize;
-	u8 reserved0;
-	u32 reversed1;
-};
-
-struct rk_lcdc_bcsh {
-	bool enable;
-	u16 brightness;
-	u16 contrast;
-	u16 sat_con;
-	u16 sin_hue;
-	u16 cos_hue;
-};
-
-struct rk_lcdc_win_area {
-	bool state;
-	enum data_format format;
-	u8 data_space;		/* SDR or HDR */
-	u8 fmt_cfg;
-	u8 yuyv_fmt;
-	u8 swap_rb;
-	u8 swap_uv;
-	u32 y_offset;		/*yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx*/
-	u32 c_offset;		/*cb cr offset--->LCDC_WINx_CBR_MSTx*/
-	u16 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u16 ypos;
-	u16 xsize;		/* display window width/height  -->LCDC_WINx_DSP_INFO*/
-	u16 ysize;
-	u16 xact;		/*origin display window size -->LCDC_WINx_ACT_INFO*/
-	u16 yact;
-	u16 xvir;		/*virtual width/height     -->LCDC_WINx_VIR*/
-	u16 yvir;
-	u16 xoff;		/*mem offset*/
-	u16 yoff;
-	unsigned long smem_start;
-	unsigned long cbr_start;	/*Cbr memory start address*/
-#if defined(CONFIG_ION_ROCKCHIP)
-		struct ion_handle *ion_hdl;
-		int dma_buf_fd;
-		struct dma_buf *dma_buf;
-#endif
-	u16 dsp_stx;
-	u16 dsp_sty;
-	u16 y_vir_stride;
-	u16 uv_vir_stride;
-	u32 y_addr;
-	u32 uv_addr;
-
-	u8  fbdc_en;
-	u8  fbdc_cor_en;
-	u8  fbdc_data_format;
-	u8  fbdc_dsp_width_ratio;
-	u8  fbdc_fmt_cfg;
-	u16 fbdc_mb_vir_width;
-	u16 fbdc_mb_vir_height;
-	u16 fbdc_mb_width;
-	u16 fbdc_mb_height;
-	u16 fbdc_mb_xst;
-	u16 fbdc_mb_yst;
-	u16 fbdc_num_tiles;
-	u16 fbdc_cmp_index_init;
-};
-
-
-struct rk_lcdc_win {
-	char name[5];
-	int id;
-	struct rk_win_property property;
-	bool state;		/*on or off*/
-	bool last_state;		/*on or off*/
-	u32 pseudo_pal[16];
-	int z_order;		/*win sel layer*/
-	u8 fmt_10;
-	u8 colorspace;
-	u32 reserved;
-	u32 area_num;
-	u32 scale_yrgb_x;
-	u32 scale_yrgb_y;
-	u32 scale_cbcr_x;
-	u32 scale_cbcr_y;
-	bool support_3d;
-
-	u8 win_lb_mode;
-
-	u8 bic_coe_el;
-	u8 yrgb_hor_scl_mode;//h 01:scale up ;10:down
-	u8 yrgb_ver_scl_mode;//v 01:scale up ;10:down
-	u8 yrgb_hsd_mode;//h scale down mode
-	u8 yrgb_vsu_mode;//v scale up mode
-	u8 yrgb_vsd_mode;//v scale down mode
-	u8 cbr_hor_scl_mode;
-	u8 cbr_ver_scl_mode;
-	u8 cbr_hsd_mode;
-	u8 cbr_vsu_mode;
-	u8 cbr_vsd_mode;
-	u8 vsd_yrgb_gt4;
-	u8 vsd_yrgb_gt2;
-	u8 vsd_cbr_gt4;
-	u8 vsd_cbr_gt2;
-
-	u8 alpha_en;
-	u8 alpha_mode;
-	u16 g_alpha_val;
-	u32 color_key_val;
-	u8 csc_mode;
-	u8 xmirror;
-	u8 ymirror;
-
-	struct rk_lcdc_win_area area[RK_WIN_MAX_AREA];
-	struct rk_lcdc_post_cfg post_cfg;
-};
-
-struct rk_lcdc_driver;
-
-struct rk_fb_trsm_ops {
-	int (*enable)(void);
-	int (*disable)(void);
-	int (*dsp_pwr_on) (void);
-	int (*dsp_pwr_off) (void);
-	void (*refresh)(unsigned int xpos, unsigned int ypos,
-		       unsigned int xsize, unsigned int ysize);
-};
-
-struct rk_lcdc_drv_ops {
-	int (*open) (struct rk_lcdc_driver *dev_drv, int layer_id, bool open);
-	int (*win_direct_en)(struct rk_lcdc_driver *dev_drv, int win_id, int en);
-	int (*init_lcdc) (struct rk_lcdc_driver *dev_drv);
-	int (*ioctl) (struct rk_lcdc_driver *dev_drv, unsigned int cmd,
-		      unsigned long arg, int layer_id);
-	int (*suspend) (struct rk_lcdc_driver *dev_drv);
-	int (*resume) (struct rk_lcdc_driver *dev_drv);
-	int (*blank) (struct rk_lcdc_driver *dev_drv, int layer_id,
-		      int blank_mode);
-	int (*set_par) (struct rk_lcdc_driver *dev_drv, int layer_id);
-	int (*pan_display) (struct rk_lcdc_driver *dev_drv, int layer_id);
-	int (*direct_set_addr)(struct rk_lcdc_driver *drv, int win_id, u32 addr);
-	int (*lcdc_reg_update) (struct rk_lcdc_driver *dev_drv);
-	ssize_t(*get_disp_info) (struct rk_lcdc_driver *dev_drv, char *buf,
-				  int layer_id);
-	int (*load_screen) (struct rk_lcdc_driver *dev_drv, bool initscreen);
-	int (*get_dspbuf_info) (struct rk_lcdc_driver *dev_drv,
-				u16 *xact, u16 *yact, int *format,
-				u32 *dsp_addr, int *ymirror);
-	int (*post_dspbuf)(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
-			   int format, u16 xact, u16 yact, u16 xvir,
-			   int ymirror);
-
-	int (*get_win_state) (struct rk_lcdc_driver *dev_drv, int layer_id, int area_id);
-	int (*ovl_mgr) (struct rk_lcdc_driver *dev_drv, int swap, bool set);	/*overlay manager*/
-	int (*fps_mgr) (struct rk_lcdc_driver *dev_drv, int fps, bool set);
-	int (*fb_get_win_id) (struct rk_lcdc_driver *dev_drv, const char *id);	/*find layer for fb*/
-	int (*fb_win_remap) (struct rk_lcdc_driver *dev_drv,
-			     u16 fb_win_map_order);
-	int (*set_dsp_lut) (struct rk_lcdc_driver *dev_drv, int *lut);
-	int (*set_cabc_lut)(struct rk_lcdc_driver *dev_drv, int *lut);
-	int (*set_hwc_lut) (struct rk_lcdc_driver *dev_drv, int *hwc_lut, int mode);
-	int (*read_dsp_lut) (struct rk_lcdc_driver *dev_drv, int *lut);
-	int (*lcdc_hdmi_process) (struct rk_lcdc_driver *dev_drv, int mode);	/*some lcdc need to some process in hdmi mode*/
-	int (*set_irq_to_cpu)(struct rk_lcdc_driver *dev_drv,int enable);
-	int (*poll_vblank) (struct rk_lcdc_driver *dev_drv);
-	int (*lcdc_rst) (struct rk_lcdc_driver *dev_drv);
-	int (*dpi_open) (struct rk_lcdc_driver *dev_drv, bool open);
-	int (*dpi_win_sel) (struct rk_lcdc_driver *dev_drv, int layer_id);
-	int (*dpi_status) (struct rk_lcdc_driver *dev_drv);
-	int (*get_dsp_addr)(struct rk_lcdc_driver *dev_drv, unsigned int dsp_addr[][4]);
-	int (*set_dsp_cabc) (struct rk_lcdc_driver *dev_drv, int mode, int calc, int up, int down, int global);
-	int (*set_dsp_bcsh_hue) (struct rk_lcdc_driver *dev_drv,int sin_hue, int cos_hue);
-	int (*set_dsp_bcsh_bcs)(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode,int value);
-	int (*get_dsp_bcsh_hue) (struct rk_lcdc_driver *dev_drv,bcsh_hue_mode mode);
-	int (*get_dsp_bcsh_bcs)(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode);
-	int (*open_bcsh)(struct rk_lcdc_driver *dev_drv, bool open);
-        int (*set_screen_scaler) (struct rk_lcdc_driver *dev_drv, struct rk_screen *screen, bool enable);
-	int (*dump_reg) (struct rk_lcdc_driver *dev_drv);
-	int (*mmu_en) (struct rk_lcdc_driver *dev_drv);
-	int (*cfg_done) (struct rk_lcdc_driver *dev_drv);
-	int (*set_overscan) (struct rk_lcdc_driver *dev_drv,
-			     struct overscan *overscan);
-	int (*dsp_black) (struct rk_lcdc_driver *dev_drv, int enable);
-	int (*backlight_close)(struct rk_lcdc_driver *dev_drv, int enable);
-	int (*area_support_num)(struct rk_lcdc_driver *dev_drv, unsigned int *area_support);
-	int (*extern_func)(struct rk_lcdc_driver *dev_drv, int cmd);
-	int (*wait_frame_start)(struct rk_lcdc_driver *dev_drv, int enable);
-	int (*set_wb)(struct rk_lcdc_driver *dev_drv);
-};
-
-struct rk_fb_area_par {
-	u8  data_format;        /*layer data fmt*/
-	short ion_fd;
-	u32 phy_addr;
-	short acq_fence_fd;
-	u16  x_offset;
-	u16  y_offset;
-	u16 xpos;	/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u16 ypos;
-	u16 xsize;	/* display window width/height  -->LCDC_WINx_DSP_INFO*/
-	u16 ysize;
-	u16 xact;	/*origin display window size -->LCDC_WINx_ACT_INFO*/
-	u16 yact;
-	u16 xvir;	/*virtual width/height     -->LCDC_WINx_VIR*/
-	u16 yvir;
-	u8  fbdc_en;
-	u8  fbdc_cor_en;
-	u8  fbdc_data_format;
-	u16 data_space;	/* SDR or HDR */
-	u32 reserved0;
-};
-
-
-struct rk_fb_win_par {
-	u8  win_id;
-	u8  z_order;		/*win sel layer*/
-	u8  alpha_mode;
-	u16 g_alpha_val;
-	u8  mirror_en;
-	struct rk_fb_area_par area_par[RK_WIN_MAX_AREA];
-	u32 reserved0;
-};
-
-struct rk_fb_win_cfg_data {
-	u8  wait_fs;
-	short ret_fence_fd;
-	short rel_fence_fd[RK_MAX_BUF_NUM];
-	struct  rk_fb_win_par win_par[RK30_MAX_LAYER_SUPPORT];
-	struct  rk_fb_wb_cfg wb_cfg;
-};
-
-struct rk_fb_reg_wb_data {
-	bool state;
-	u8 data_format;
-	struct ion_handle *ion_handle;
-	unsigned long smem_start;
-	unsigned long cbr_start;	/*Cbr memory start address*/
-	u16 xsize;
-	u16 ysize;
-};
-
-struct rk_fb_reg_area_data {
-	struct sync_fence *acq_fence;
-	u8 data_format;        /*layer data fmt*/
-	u8 data_space;		/* indicate SDR or HDR */
-	u8  index_buf;          /*judge if the buffer is index*/
-	u32 y_offset;		/*yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx*/
-	u32 c_offset;		/*cb cr offset--->LCDC_WINx_CBR_MSTx*/
-	u32 y_vir_stride;
-	u32 uv_vir_stride;
-	u32 buff_len;
-	u16 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u16 ypos;
-	u16 xsize;		/* display window width/height  -->LCDC_WINx_DSP_INFO*/
-	u16 ysize;
-	u16 xact;		/*origin display window size -->LCDC_WINx_ACT_INFO*/
-	u16 yact;
-	u16 xvir;		/*virtual width/height     -->LCDC_WINx_VIR*/
-	u16 yvir;
-	u16 xoff;		/*mem offset*/
-	u16 yoff;
-	unsigned long smem_start;
-	unsigned long cbr_start;	/*Cbr memory start address*/
-	u32 line_length;	
-	struct ion_handle *ion_handle;
-#ifdef 	USE_ION_MMU
-	struct dma_buf *dma_buf;
-	struct dma_buf_attachment *attachment;
-	struct sg_table *sg_table;
-	dma_addr_t dma_addr;
-#endif
-	u8  fbdc_en;
-	u8  fbdc_cor_en;
-	u8  fbdc_data_format;
-};
-
-struct rk_fb_reg_win_data {
-	int win_id;
-	int z_order;		/*win sel layer*/
-	u32 area_num;		/*maybe two region have the same dma buff,*/
-	u32 area_buf_num;     /*so area_num  maybe not equal to area_buf_num*/
-	u8 alpha_en;
-	u8 alpha_mode;
-	u16 g_alpha_val;
-	u8  mirror_en;
-	u8 colorspace;
-
-	struct rk_fb_reg_area_data reg_area_data[RK_WIN_MAX_AREA];
-};
-
-struct rk_fb_reg_data {
-	struct list_head list;
-	int    win_num;
-	int    buf_num;
-	int    acq_num;
-	struct rk_fb_reg_win_data reg_win_data[RK30_MAX_LAYER_SUPPORT];
-	struct rk_fb_reg_wb_data reg_wb_data;
-};
-
-struct rk_lcdc_driver {
-	char name[6];
-	int  te_irq;
-	int  id;
-	int  prop;
-	struct device *dev;
-	u32 version;
-	struct rk_vop_property property;
-
-	struct rk_lcdc_win *win[RK_MAX_FB_SUPPORT];
-	struct rk_fb_reg_wb_data wb_data;
-	int lcdc_win_num;
-	int num_buf;		//the num_of buffer
-	int atv_layer_cnt;
-	int fb_index_base;	//the first fb index of the lcdc device
-	struct rk_screen *screen0;	//some platform have only one lcdc,but extend
-	struct rk_screen *screen1;	//two display devices for dual display,such as rk2918,rk2928
-	struct rk_screen *cur_screen;	//screen0 is primary screen ,like lcd panel,screen1 is  extend screen,like hdmi
-	u32 pixclock;
-	u16 rotate_mode;
-	u16 cabc_mode;
-	u16 overlay_mode;
-	u16 pre_overlay;
-	u16 output_color;
-
-	u16  fb_win_map;
-	char fb0_win_id;
-	char fb1_win_id;
-	char fb2_win_id;
-	char fb3_win_id;
-	char fb4_win_id;
-	
-	char mmu_dts_name[40];
-	struct device *mmu_dev;
-	int iommu_enabled;
-	int dsp_mode;
-	bool hot_plug_state;
-
-	struct rk_fb_reg_area_data reg_area_data;
-	/*
-	 * front_regs means this config is scaning on the devices.
-	 */
-	struct rk_fb_reg_data *front_regs;
-	struct mutex front_lock;
-
-	struct mutex fb_win_id_mutex;
-	struct mutex win_config;
-
-	struct mutex switch_screen; /*for switch screen*/
-	struct completion frame_done;	/*sync for pan_display,whe we set a new
-					  frame address to lcdc register,we must
-					  make sure the frame begain to display*/
-	spinlock_t cpl_lock;	/*lock for completion  frame done */
-	int first_frame;
-	struct rk_fb_vsync vsync_info;
-	struct rk_fb_frame_time frame_time;
-	int wait_fs;		/*wait for new frame start in kernel */
-	struct sw_sync_timeline *timeline;
-	int			timeline_max;
-	int			suspend_flag;
-	int			shutdown_flag;
-	int standby;
-	struct list_head	update_regs_list;
-	struct list_head	saved_list;
-	struct mutex		update_regs_list_lock;
-	struct kthread_worker	update_regs_worker;
-	struct task_struct	*update_regs_thread;
-	struct kthread_work	update_regs_work;
-	wait_queue_head_t 	update_regs_wait;
-
-	struct mutex		output_lock;
-	struct rk29fb_info *screen_ctr_info;
-	struct list_head pwrlist_head;
-	struct rk_lcdc_drv_ops *ops;
-	struct rk_fb_trsm_ops *trsm_ops;
-#ifdef CONFIG_DRM_ROCKCHIP
-	void (*irq_call_back)(struct rk_lcdc_driver *driver);
-#endif
-	struct overscan overscan;
-	struct rk_lcdc_bcsh bcsh;
-	int *hwc_lut;
-	int uboot_logo;
-	int bcsh_init_status;
-	bool cabc_pwm_pol;
-	u8  reserved_fb;
-	/*1:hdmi switch uncomplete,0:complete*/
-	bool hdmi_switch;
-	void *trace_buf;
-	struct rk_fb_win_cfg_data tmp_win_cfg[DUMP_FRAME_NUM];
-	struct rk_fb_reg_data tmp_regs[DUMP_FRAME_NUM];
-	unsigned int area_support[RK30_MAX_LAYER_SUPPORT];
-};
-
-struct rk_fb_par {
-	int id;
-	u32 state;
-
-	unsigned long fb_phy_base;	/* Start of fb address (physical address) */
-	char __iomem *fb_virt_base;	/* Start of fb address (virt address) */
-	u32 fb_size;
-	struct rk_lcdc_driver *lcdc_drv;
-
-#if defined(CONFIG_ION_ROCKCHIP)
-	struct ion_handle *ion_hdl;
-#endif
-	u32 reserved[2];
-};
-
-/*disp_mode: dual display mode
-*	        NO_DUAL,no dual display,
-	        ONE_DUAL,use one lcdc + rk61x for dual display
-	        DUAL,use 2 lcdcs for dual display
-  num_fb:       the total number of fb
-  num_lcdc:    the total number of lcdc
-*/
-
-struct rk_fb {
-	int disp_mode;
-	int disp_policy;
-	struct rk29fb_info *mach_info;
-	struct fb_info *fb[RK_MAX_FB_SUPPORT*2];
-	int num_fb;
-	struct rk_lcdc_driver *lcdc_dev_drv[RK30_MAX_LCDC_SUPPORT];
-	int num_lcdc;
-
-#if defined(CONFIG_ION_ROCKCHIP)
-       struct ion_client *ion_client;
-#endif
-};
-
-extern int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type);
-extern struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type);
-extern int rk_fb_register(struct rk_lcdc_driver *dev_drv,
-				struct rk_lcdc_win *win, int id);
-extern int rk_fb_unregister(struct rk_lcdc_driver *dev_drv);
-extern struct rk_lcdc_driver *rk_get_lcdc_drv(char *name);
-extern int rk_fb_get_extern_screen(struct rk_screen *screen);
-extern int rk_fb_set_vop_pwm(void);
-extern int rk_fb_get_prmry_screen( struct rk_screen *screen);
-extern int rk_fb_set_prmry_screen(struct rk_screen *screen);
-extern u32 rk_fb_get_prmry_screen_pixclock(void);
-extern int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv);
-extern int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv);
-extern int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv);
-extern bool is_prmry_rk_lcdc_registered(void);
-extern int rk_fb_prase_timing_dt(struct device_node *np,
-		struct rk_screen *screen);
-extern int rk_disp_prase_timing_dt(struct rk_lcdc_driver *dev_drv);
-
-extern int rk_fb_dpi_open(bool open);
-extern int rk_fb_dpi_layer_sel(int layer_id);
-extern int rk_fb_dpi_status(void);
-
-extern int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id);
-extern int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id);
-extern int rkfb_create_sysfs(struct fb_info *fbi);
-extern char *get_format_string(enum data_format, char *fmt);
-extern int support_uboot_display(void);
-extern int  rk_fb_calc_fps(struct rk_screen *screen, u32 pixclock);
-extern int rk_get_real_fps(int time);
-extern struct device *rk_fb_get_sysmmu_device_by_compatible(const char *compt);
-extern void rk_fb_platform_set_sysmmu(struct device *sysmmu,
-                                      struct device *dev);
-int rk_fb_get_display_policy(void);
-int rk_fb_pixel_width(int data_format);
-void trace_buffer_dump(struct device *dev,
-			      struct rk_lcdc_driver *dev_drv);
-int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv, int status);
-extern int rockchip_get_screen_type(void);
-#endif
diff --git a/include/linux/rk_screen.h b/include/linux/rk_screen.h
deleted file mode 100644
index 9800bb378a1e..000000000000
--- a/include/linux/rk_screen.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _SCREEN_H
-#define _SCREEN_H
-
-typedef enum _REFRESH_STAGE {
-    REFRESH_PRE = 0,
-    REFRESH_END,
-
-} REFRESH_STAGE;
-
-
-typedef enum _MCU_IOCTL {
-    MCU_WRCMD = 0,
-    MCU_WRDATA,
-    MCU_SETBYPASS,
-
-} MCU_IOCTL;
-
-
-typedef enum _MCU_STATUS {
-    MS_IDLE = 0,
-    MS_MCU,
-    MS_EBOOK,
-    MS_EWAITSTART,
-    MS_EWAITEND,
-    MS_EEND,
-
-} MCU_STATUS;
-
-struct rk29_fb_setting_info {
-	u8 data_num;
-	u8 vsync_en;
-	u8 den_en;
-	u8 mcu_fmk_en;
-	u8 disp_on_en;
-	u8 standby_en;
-};
-
-struct rk29lcd_info {
-	u32 lcd_id;
-	u32 txd_pin;
-	u32 clk_pin;
-	u32 cs_pin;
-	u32	reset_pin;
-	int (*io_init)(void);
-	int (*io_deinit)(void);
-	int (*io_enable)(void);
-	int (*io_disable)(void);
-};
-
-struct overscan {
-	unsigned char left;
-	unsigned char top;
-	unsigned char right;
-	unsigned char bottom;
-};
-
-/* Screen description
-*type:LVDS,RGB,MIPI,MCU
-*lvds_fromat:lvds data format,set it if the screen is lvds
-*face:thi display output face,18bit,24bit,etc
-*ft: the time need to display one frame time
-*/
-struct rk_screen {
-	u16 type;
-	u16 refresh_mode;
-	u16 lvds_format;
-	u16 face;
-	u16 color_mode;
-	u8 data_space;
-	u8 lcdc_id;
-	u8 screen_id;
-	struct fb_videomode mode;
-	u32 post_dsp_stx;
-	u32 post_dsp_sty;
-	u32 post_xsize;
-	u32 post_ysize;
-	u16 x_mirror;
-	u16 y_mirror;
-	int interlace;
-	int pixelrepeat; //For 480i/576i format, pixel is repeated twice.
-	u16 width;
-	u16 height;
-	u8  ft;
-	int *dsp_lut;
-	int *cabc_lut;
-	int *cabc_gamma_base;
-
-#if defined(CONFIG_MFD_RK616) || defined(CONFIG_LCDC_RK312X)
-	u32 pll_cfg_val;  //bellow are for jettaB
-	u32 frac;
-	u16 scl_vst;
-	u16 scl_hst;
-	u16 vif_vst;
-	u16 vif_hst;
-#endif
-	u8 hdmi_resolution;
-	u8 mcu_wrperiod;
-	u8 mcu_usefmk;
-	u8 mcu_frmrate;
-
-	u8 pin_hsync;
-	u8 pin_vsync;
-	u8 pin_den;
-	u8 pin_dclk;
-
-	/* Swap rule */
-	u8 swap_gb;
-	u8 swap_rg;
-	u8 swap_rb;
-	u8 swap_delta;
-	u8 swap_dumy;
-	
-#if defined(CONFIG_MIPI_DSI)
-	/* MIPI DSI */
-	u8 dsi_lane;
-	u8 dsi_video_mode;
-	u32 hs_tx_clk;
-#endif
-
-	int xpos;  //horizontal display start position on the sceen ,then can be changed by application
-	int ypos;
-	int xsize; //horizontal and vertical display size on he screen,they can be changed by application
-	int ysize;
-	struct overscan overscan;
-	struct rk_screen *ext_screen;
-	/* Operation function*/
-	int (*init)(void);
-	int (*standby)(u8 enable);
-	int (*refresh)(u8 arg);
-	int (*scandir)(u16 dir);
-	int (*disparea)(u8 area);
-	int (*sscreen_get)(struct rk_screen *screen, u8 resolution);
-	int (*sscreen_set)(struct rk_screen *screen, bool type);// 1: use scaler 0:bypass
-};
-
-struct rk29fb_info {
-	u32 fb_id;
-	int prop;		//display device property,like PRMRY,EXTEND
-	u32 mcu_fmk_pin;
-	struct rk29lcd_info *lcd_info;
-	int (*io_init)(struct rk29_fb_setting_info *fb_setting);
-	int (*io_deinit)(void);
-	int (*io_enable)(void);
-	int (*io_disable)(void);
-	void (*set_screen_info)(struct rk_screen *screen, struct rk29lcd_info *lcd_info );
-};
-
-extern void set_lcd_info(struct rk_screen *screen, struct rk29lcd_info *lcd_info);
-extern size_t get_fb_size(u8 reserved_fb);
-
-extern void set_tv_info(struct rk_screen *screen);
-extern void set_hdmi_info(struct rk_screen *screen);
-
-#endif
-- 
2.35.3

