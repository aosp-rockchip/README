From 9d44f5ccfcc589aa9961042cdce577aca829fdea Mon Sep 17 00:00:00 2001
From: Zhou weixin <zwx@rock-chips.com>
Date: Tue, 16 Jan 2018 16:07:44 +0800
Subject: [PATCH] input: touchscreen: add gt1x driver

Change-Id: Ic4c5abf51c3dd5383bdc91029afbc7c903c2093a
Signed-off-by: Weixin Zhou <zwx@rock-chips.com>
---
 drivers/input/touchscreen/Kconfig             |    3 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/gt1x/Makefile       |    7 +
 drivers/input/touchscreen/gt1x/gt1x.c         |  792 ++++++
 drivers/input/touchscreen/gt1x/gt1x.h         |   62 +
 drivers/input/touchscreen/gt1x/gt1x_extents.c |  927 +++++++
 .../input/touchscreen/gt1x/gt1x_firmware.h    |  548 ++++
 drivers/input/touchscreen/gt1x/gt1x_generic.c | 2468 +++++++++++++++++
 drivers/input/touchscreen/gt1x/gt1x_generic.h |  599 ++++
 drivers/input/touchscreen/gt1x/gt1x_tools.c   |  434 +++
 drivers/input/touchscreen/gt1x/gt1x_update.c  | 1456 ++++++++++
 11 files changed, 7297 insertions(+)
 create mode 100644 drivers/input/touchscreen/gt1x/Makefile
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x.c
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x.h
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_extents.c
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_firmware.h
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_generic.c
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_generic.h
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_tools.c
 create mode 100644 drivers/input/touchscreen/gt1x/gt1x_update.c

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index f74024ada3da..4f569b311042 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1157,4 +1157,7 @@ config TOUCHSCREEN_ROHM_BU21023
 config TOUCHSCREEN_VTL_CT36X
 	tristate "VTL touchscreens support"
 
+config TOUCHSCREEN_GT1X
+	tristate "GT1X touchscreens support"
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index d3dc76996543..a56eba48c63f 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -100,3 +100,4 @@ obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_VTL_CT36X)	+= vtl_ts/
+obj-$(CONFIG_TOUCHSCREEN_GT1X)		+= gt1x/
diff --git a/drivers/input/touchscreen/gt1x/Makefile b/drivers/input/touchscreen/gt1x/Makefile
new file mode 100644
index 000000000000..77a20c4aa940
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-y	+=  gt1x_extents.o
+obj-y	+=  gt1x_generic.o
+obj-y	+=  gt1x_tools.o
+obj-y	+=  gt1x.o
+obj-y	+=  gt1x_update.o
+
diff --git a/drivers/input/touchscreen/gt1x/gt1x.c b/drivers/input/touchscreen/gt1x/gt1x.c
new file mode 100644
index 000000000000..ecb2b1c29438
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x.c
@@ -0,0 +1,792 @@
+/* drivers/input/touchscreen/gt1x.c
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#include <linux/irq.h>
+#include "gt1x.h"
+#if GTP_ICS_SLOT_REPORT
+#include <linux/input/mt.h>
+#endif
+
+static struct work_struct gt1x_work;
+static struct input_dev *input_dev;
+static struct workqueue_struct *gt1x_wq;
+static const char *gt1x_ts_name = "goodix-ts";
+static const char *input_dev_phys = "input/ts";
+#ifdef GTP_CONFIG_OF
+int gt1x_rst_gpio;
+int gt1x_int_gpio;
+#endif
+
+static int gt1x_register_powermanger(void);
+static int gt1x_unregister_powermanger(void);
+
+/**
+ * gt1x_i2c_write - i2c write.
+ * @addr: register address.
+ * @buffer: data buffer.
+ * @len: the bytes of data to write.
+ *Return: 0: success, otherwise: failed
+ */
+s32 gt1x_i2c_write(u16 addr, u8 *buffer, s32 len)
+{
+	struct i2c_msg msg = {
+		.flags = 0,
+		.addr = gt1x_i2c_client->addr,
+	};
+	return _do_i2c_write(&msg, addr, buffer, len);
+}
+
+/**
+ * gt1x_i2c_read - i2c read.
+ * @addr: register address.
+ * @buffer: data buffer.
+ * @len: the bytes of data to write.
+ *Return: 0: success, otherwise: failed
+ */
+s32 gt1x_i2c_read(u16 addr, u8 *buffer, s32 len)
+{
+	u8 addr_buf[GTP_ADDR_LENGTH] = { (addr >> 8) & 0xFF, addr & 0xFF };
+	struct i2c_msg msgs[2] = {
+		{
+		 .addr = gt1x_i2c_client->addr,
+		 .flags = 0,
+		 .buf = addr_buf,
+		 .len = GTP_ADDR_LENGTH},
+		{
+		 .addr = gt1x_i2c_client->addr,
+		 .flags = I2C_M_RD}
+	};
+	return _do_i2c_read(msgs, addr, buffer, len);
+}
+
+static spinlock_t irq_lock;
+static s32 irq_is_disable;
+
+/**
+ * gt1x_irq_enable - enable irq function.
+ *
+ */
+void gt1x_irq_enable(void)
+{
+	unsigned long irqflags = 0;
+
+	GTP_DEBUG_FUNC();
+
+	spin_lock_irqsave(&irq_lock, irqflags);
+	if (irq_is_disable) {
+		enable_irq(gt1x_i2c_client->irq);
+		irq_is_disable = 0;
+	}
+	spin_unlock_irqrestore(&irq_lock, irqflags);
+}
+
+/**
+ * gt1x_irq_enable - disable irq function.
+ *
+ */
+void gt1x_irq_disable(void)
+{
+	unsigned long irqflags;
+
+	GTP_DEBUG_FUNC();
+
+	spin_lock_irqsave(&irq_lock, irqflags);
+	if (!irq_is_disable) {
+		irq_is_disable = 1;
+		disable_irq_nosync(gt1x_i2c_client->irq);
+	}
+	spin_unlock_irqrestore(&irq_lock, irqflags);
+}
+
+#ifndef GTP_CONFIG_OF
+int gt1x_power_switch(s32 state)
+{
+    return 0;
+}
+#endif
+
+int gt1x_debug_proc(u8 *buf, int count)
+{
+	return -1;
+}
+
+#if GTP_CHARGER_SWITCH
+u32 gt1x_get_charger_status(void)
+{
+#error Need to get charger status of your platform.
+}
+#endif
+
+/**
+ * gt1x_ts_irq_handler - External interrupt service routine for interrupt mode.
+ * @irq:  interrupt number.
+ * @dev_id: private data pointer.
+ * Return: Handle Result.
+ *  		IRQ_HANDLED: interrupt handled successfully
+ */
+static irqreturn_t gt1x_ts_irq_handler(int irq, void *dev_id)
+{
+	GTP_DEBUG_FUNC();
+	gt1x_irq_disable();
+	queue_work(gt1x_wq, &gt1x_work);
+	return IRQ_HANDLED;
+}
+
+/**
+ * gt1x_touch_down - Report touch point event .
+ * @id: trackId
+ * @x:  input x coordinate
+ * @y:  input y coordinate
+ * @w:  input pressure
+ * Return: none.
+ */
+void gt1x_touch_down(s32 x, s32 y, s32 size, s32 id)
+{
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
+
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(input_dev, id);
+	input_report_abs(input_dev, ABS_MT_PRESSURE, size);
+	input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, size);
+	input_report_abs(input_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
+#else
+	input_report_key(input_dev, BTN_TOUCH, 1);
+	if ((!size) && (!id)) {
+		/* for virtual button */
+		input_report_abs(input_dev, ABS_MT_PRESSURE, 100);
+		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, 100);
+	} else {
+		input_report_abs(input_dev, ABS_MT_PRESSURE, size);
+		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, size);
+		input_report_abs(input_dev, ABS_MT_TRACKING_ID, id);
+	}
+	input_report_abs(input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
+	input_mt_sync(input_dev);
+#endif
+}
+
+/**
+ * gt1x_touch_up -  Report touch release event.
+ * @id: trackId
+ * Return: none.
+ */
+void gt1x_touch_up(s32 id)
+{
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(input_dev, id);
+	input_report_abs(input_dev, ABS_MT_TRACKING_ID, -1);
+#else
+	input_report_key(input_dev, BTN_TOUCH, 0);
+	input_mt_sync(input_dev);
+#endif
+}
+
+/**
+ * gt1x_ts_work_func - Goodix touchscreen work function.
+ * @iwork: work struct of gt1x_workqueue.
+ * Return: none.
+ */
+static void gt1x_ts_work_func(struct work_struct *work)
+{
+	u8 end_cmd = 0;
+	u8 finger = 0;
+	s32 ret = 0;
+	u8 point_data[11] = { 0 };
+
+	if (update_info.status) {
+		GTP_DEBUG("Ignore interrupts during fw update.");
+		return;
+	}
+
+#if GTP_GESTURE_WAKEUP
+	ret = gesture_event_handler(input_dev);
+	if (ret >= 0) {
+		goto exit_work_func;
+	}
+#endif
+
+	if (gt1x_halt) {
+		GTP_DEBUG("Ignore interrupts after suspend...");
+		return;
+	}
+
+	ret = gt1x_i2c_read(GTP_READ_COOR_ADDR, point_data, sizeof(point_data));
+	if (ret < 0) {
+		GTP_ERROR("I2C transfer error!");
+#if !GTP_ESD_PROTECT
+		gt1x_power_reset();
+#endif
+		goto exit_work_func;
+	}
+
+	finger = point_data[0];
+	if (finger == 0x00) {
+		gt1x_request_event_handler();
+	}
+
+	if ((finger & 0x80) == 0) {
+#if HOTKNOT_BLOCK_RW
+		if (!hotknot_paired_flag)
+#endif
+		{
+			/*GTP_ERROR("buffer not ready:0x%02x", finger);*/
+			goto exit_eint;
+		}
+	}
+#if HOTKNOT_BLOCK_RW
+	ret = hotknot_event_handler(point_data);
+	if (!ret) {
+		goto exit_work_func;
+	}
+#endif
+
+#if GTP_PROXIMITY
+	ret = gt1x_prox_event_handler(point_data);
+	if (ret > 0) {
+		goto exit_work_func;
+	}
+#endif
+
+#if GTP_WITH_STYLUS
+	ret = gt1x_touch_event_handler(point_data, input_dev, pen_dev);
+#else
+	ret = gt1x_touch_event_handler(point_data, input_dev, NULL);
+#endif
+
+exit_work_func:
+	if (!gt1x_rawdiff_mode && (ret >= 0 || ret == ERROR_VALUE)) {
+		ret = gt1x_i2c_write(GTP_READ_COOR_ADDR, &end_cmd, 1);
+		if (ret < 0) {
+			GTP_ERROR("I2C write end_cmd  error!");
+		}
+	}
+exit_eint:
+	gt1x_irq_enable();
+
+}
+
+/*
+ * Devices Tree support,
+ */
+#ifdef GTP_CONFIG_OF
+
+static struct regulator *vdd_ana;
+static struct regulator *vcc_i2c;
+
+/**
+ * gt1x_parse_dt - parse platform infomation form devices tree.
+ */
+static int gt1x_parse_dt(struct device *dev)
+{
+	struct device_node *np;
+	int ret;
+
+	if (!dev)
+		return -ENODEV;
+
+	np = dev->of_node;
+	gt1x_int_gpio = of_get_named_gpio(np, "goodix,irq-gpio", 0);
+	gt1x_rst_gpio = of_get_named_gpio(np, "goodix,rst-gpio", 0);
+
+	if (!gpio_is_valid(gt1x_int_gpio) || !gpio_is_valid(gt1x_rst_gpio)) {
+		GTP_ERROR("Invalid GPIO, irq-gpio:%d, rst-gpio:%d",
+				gt1x_int_gpio, gt1x_rst_gpio);
+		return -EINVAL;
+	}
+
+	vdd_ana = regulator_get(dev, "vdd_ana");
+	if (IS_ERR(vdd_ana)) {
+		GTP_ERROR("regulator get of vdd_ana failed");
+		ret = PTR_ERR(vdd_ana);
+		vdd_ana = NULL;
+		return ret;
+	}
+
+	vcc_i2c = regulator_get(dev, "vcc_i2c");
+	if (IS_ERR(vcc_i2c)) {
+		GTP_ERROR("regulator get of vcc_i2c failed");
+		ret = PTR_ERR(vcc_i2c);
+		vcc_i2c = NULL;
+		goto ERR_GET_VCC;
+	}
+	return 0;
+ERR_GET_VCC:
+	regulator_put(vdd_ana);
+	vdd_ana = NULL;
+	return ret;
+	return 0;
+}
+
+/**
+ * gt1x_power_switch - power switch .
+ * @on: 1-switch on, 0-switch off.
+ * return: 0-succeed, -1-faileds
+ */
+int gt1x_power_switch(int on)
+{
+	int ret;
+	struct i2c_client *client = gt1x_i2c_client;
+
+	if (!client || !vdd_ana || !vcc_i2c)
+		return -1;
+
+	if (on) {
+		GTP_DEBUG("GTP power on.");
+		ret = regulator_enable(vdd_ana);
+		udelay(2);
+		ret = regulator_enable(vcc_i2c);
+	} else {
+		GTP_DEBUG("GTP power off.");
+		ret = regulator_disable(vcc_i2c);
+		udelay(2);
+		ret = regulator_disable(vdd_ana);
+	}
+	return ret;
+}
+#endif
+
+static void gt1x_remove_gpio_and_power(void)
+{
+	if (gpio_is_valid(gt1x_int_gpio))
+		gpio_free(gt1x_int_gpio);
+
+	if (gpio_is_valid(gt1x_rst_gpio))
+		gpio_free(gt1x_rst_gpio);
+
+#ifdef GTP_CONFIG_OF
+	if (vcc_i2c)
+		regulator_put(vcc_i2c);
+
+	if (vdd_ana)
+		regulator_put(vdd_ana);
+#endif
+
+	if (gt1x_i2c_client && gt1x_i2c_client->irq)
+		free_irq(gt1x_i2c_client->irq, gt1x_i2c_client);
+}
+
+
+/**
+ * gt1x_request_io_port - Request gpio(INT & RST) ports.
+ */
+static s32 gt1x_request_io_port(void)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG_FUNC();
+	ret = gpio_request(GTP_INT_PORT, "GTP_INT_IRQ");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d", (s32) GTP_INT_PORT, ret);
+		ret = -ENODEV;
+	} else {
+		GTP_GPIO_AS_INT(GTP_INT_PORT);
+		gt1x_i2c_client->irq = GTP_INT_IRQ;
+	}
+
+	ret = gpio_request(GTP_RST_PORT, "GTP_RST_PORT");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d", (s32) GTP_RST_PORT, ret);
+		ret = -ENODEV;
+	}
+
+	GTP_GPIO_AS_INPUT(GTP_RST_PORT);
+	if (ret < 0) {
+		gpio_free(GTP_RST_PORT);
+		gpio_free(GTP_INT_PORT);
+	}
+
+	return ret;
+}
+
+/**
+ * gt1x_request_irq - Request interrupt.
+ * Return
+ *      0: succeed, -1: failed.
+ */
+static s32 gt1x_request_irq(void)
+{
+	s32 ret = -1;
+	const u8 irq_table[] = GTP_IRQ_TAB;
+
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("INT trigger type:%x", gt1x_int_type);
+
+	ret = request_irq(gt1x_i2c_client->irq, gt1x_ts_irq_handler, irq_table[gt1x_int_type], gt1x_i2c_client->name, gt1x_i2c_client);
+	if (ret) {
+		GTP_ERROR("Request IRQ failed!ERRNO:%d.", ret);
+		GTP_GPIO_AS_INPUT(GTP_INT_PORT);
+		gpio_free(GTP_INT_PORT);
+
+		return -1;
+	} else {
+		gt1x_irq_disable();
+		return 0;
+	}
+}
+
+/**
+ * gt1x_request_input_dev -  Request input device Function.
+ * Return
+ *      0: succeed, -1: failed.
+ */
+static s8 gt1x_request_input_dev(void)
+{
+	s8 ret = -1;
+#if GTP_HAVE_TOUCH_KEY
+	u8 index = 0;
+#endif
+
+	GTP_DEBUG_FUNC();
+
+	input_dev = input_allocate_device();
+	if (input_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device.");
+		return -ENOMEM;
+	}
+
+	input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+#if GTP_ICS_SLOT_REPORT
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 0))
+	input_mt_init_slots(input_dev, 16, INPUT_MT_DIRECT);
+#else
+	input_mt_init_slots(input_dev, 16);
+#endif
+#else
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+	set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+
+#if GTP_HAVE_TOUCH_KEY
+	for (index = 0; index < GTP_MAX_KEY_NUM; index++) {
+		input_set_capability(input_dev, EV_KEY, gt1x_touch_key_array[index]);
+	}
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	input_set_capability(input_dev, EV_KEY, KEY_GES_REGULAR);
+	input_set_capability(input_dev, EV_KEY, KEY_GES_CUSTOM);
+#endif
+
+#if GTP_CHANGE_X2Y
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, gt1x_abs_y_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, gt1x_abs_x_max, 0, 0);
+#else
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, gt1x_abs_x_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, gt1x_abs_y_max, 0, 0);
+#endif
+	input_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	input_dev->name = gt1x_ts_name;
+	input_dev->phys = input_dev_phys;
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->id.vendor = 0xDEAD;
+	input_dev->id.product = 0xBEEF;
+	input_dev->id.version = 10427;
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		GTP_ERROR("Register %s input device failed", input_dev->name);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/**
+ * gt1x_ts_probe -   I2c probe.
+ * @client: i2c device struct.
+ * @id: device id.
+ * Return  0: succeed, -1: failed.
+ */
+static int gt1x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	s32 ret = -1;
+#if GTP_AUTO_UPDATE
+	struct task_struct *thread = NULL;
+#endif
+	/*do NOT remove these logs*/
+	GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
+	GTP_INFO("GTP I2C Address: 0x%02x", client->addr);
+
+	gt1x_i2c_client = client;
+	spin_lock_init(&irq_lock);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		GTP_ERROR("I2C check functionality failed.");
+		return -ENODEV;
+	}
+
+#ifdef GTP_CONFIG_OF	/* device tree support */
+	if (client->dev.of_node) {
+		gt1x_parse_dt(&client->dev);
+	}
+#endif
+
+	ret = gt1x_request_io_port();
+	if (ret < 0) {
+		GTP_ERROR("GTP request IO port failed.");
+		return ret;
+	}
+
+	ret = gt1x_init();
+	if (ret != 0) {
+		GTP_ERROR("GTP init failed!!!");
+		return ret;
+	}
+
+	gt1x_wq = create_singlethread_workqueue("gt1x_wq");
+	if (!gt1x_wq) {
+		GTP_ERROR("Creat workqueue failed.");
+		return -ENOMEM;
+	}
+
+	INIT_WORK(&gt1x_work, gt1x_ts_work_func);
+
+	ret = gt1x_request_input_dev();
+	if (ret < 0) {
+		GTP_ERROR("GTP request input dev failed");
+	}
+
+	ret = gt1x_request_irq();
+	if (ret < 0) {
+		GTP_DEBUG("GTP works in polling mode.");
+	} else {
+		GTP_DEBUG("GTP works in interrupt mode.");
+	}
+
+#if GTP_GESTURE_WAKEUP
+	enable_irq_wake(client->irq);
+#endif
+
+	gt1x_irq_enable();
+
+#if GTP_ESD_PROTECT
+	/*must before auto update*/
+	gt1x_init_esd_protect();
+	gt1x_esd_switch(SWITCH_ON);
+#endif
+
+#if GTP_AUTO_UPDATE
+	thread = kthread_run(gt1x_auto_update_proc, (void *)NULL, "gt1x_auto_update");
+	if (IS_ERR(thread)) {
+		ret = PTR_ERR(thread);
+		GTP_ERROR("Failed to create auto-update thread: %d.", ret);
+	}
+#endif
+	gt1x_register_powermanger();
+	return 0;
+}
+
+/**
+ * gt1x_ts_remove -  Goodix touchscreen driver release function.
+ * @client: i2c device struct.
+ * Return  0: succeed, -1: failed.
+ */
+static int gt1x_ts_remove(struct i2c_client *client)
+{
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("GTP driver removing...");
+	gt1x_unregister_powermanger();
+
+#if GTP_GESTURE_WAKEUP
+	disable_irq_wake(client->irq);
+#endif
+	gt1x_deinit();
+	input_unregister_device(input_dev);
+	gt1x_remove_gpio_and_power();
+	if (gt1x_wq) {
+		destroy_workqueue(gt1x_wq);
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_FB)
+/* frame buffer notifier block control the suspend/resume procedure */
+static struct notifier_block gt1x_fb_notifier;
+
+static int gtp_fb_notifier_callback(struct notifier_block *noti, unsigned long event, void *data)
+{
+	struct fb_event *ev_data = data;
+	int *blank;
+
+#if GTP_INCELL_PANEL
+#ifndef FB_EARLY_EVENT_BLANK
+#error Need add FB_EARLY_EVENT_BLANK to fbmem.c
+#endif
+
+	if (ev_data && ev_data->data && event == FB_EARLY_EVENT_BLANK) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			GTP_DEBUG("Resume by fb notifier.");
+			gt1x_resume();
+		}
+	}
+#else
+	if (ev_data && ev_data->data && event == FB_EVENT_BLANK) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			GTP_DEBUG("Resume by fb notifier.");
+			gt1x_resume();
+		}
+	}
+#endif
+
+	if (ev_data && ev_data->data && event == FB_EVENT_BLANK) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_POWERDOWN) {
+			GTP_DEBUG("Suspend by fb notifier.");
+			gt1x_suspend();
+		}
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_PM)
+/**
+ * gt1x_ts_suspend - i2c suspend callback function.
+ * @dev: i2c device.
+ * Return  0: succeed, -1: failed.
+ */
+static int gt1x_pm_suspend(struct device *dev)
+{
+    return gt1x_suspend();
+}
+
+/**
+ * gt1x_ts_resume - i2c resume callback function.
+ * @dev: i2c device.
+ * Return  0: succeed, -1: failed.
+ */
+static int gt1x_pm_resume(struct device *dev)
+{
+	return gt1x_resume();
+}
+
+/* bus control the suspend/resume procedure */
+static const struct dev_pm_ops gt1x_ts_pm_ops = {
+	.suspend = gt1x_pm_suspend,
+	.resume = gt1x_pm_resume,
+};
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/* earlysuspend module the suspend/resume procedure */
+static void gt1x_ts_early_suspend(struct early_suspend *h)
+{
+	gt1x_suspend();
+}
+
+static void gt1x_ts_late_resume(struct early_suspend *h)
+{
+	gt1x_resume();
+}
+
+static struct early_suspend gt1x_early_suspend = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1,
+	.suspend = gt1x_ts_early_suspend,
+	.resume = gt1x_ts_late_resume,
+};
+#endif
+
+
+static int gt1x_register_powermanger(void)
+{
+#if   defined(CONFIG_FB)
+	gt1x_fb_notifier.notifier_call = gtp_fb_notifier_callback;
+	fb_register_client(&gt1x_fb_notifier);
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	register_early_suspend(&gt1x_early_suspend);
+#endif
+	return 0;
+}
+
+static int gt1x_unregister_powermanger(void)
+{
+#if   defined(CONFIG_FB)
+	fb_unregister_client(&gt1x_fb_notifier);
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&gt1x_early_suspend);
+#endif
+	return 0;
+}
+
+#ifdef GTP_CONFIG_OF
+static const struct of_device_id gt1x_match_table[] = {
+		{.compatible = "goodix,gt1x",},
+		{ },
+};
+#endif
+
+static const struct i2c_device_id gt1x_ts_id[] = {
+	{GTP_I2C_NAME, 0},
+	{}
+};
+
+static struct i2c_driver gt1x_ts_driver = {
+	.probe = gt1x_ts_probe,
+	.remove = gt1x_ts_remove,
+	.id_table = gt1x_ts_id,
+	.driver = {
+		   .name = GTP_I2C_NAME,
+#ifdef GTP_CONFIG_OF
+		   .of_match_table = gt1x_match_table,
+#endif
+#if !defined(CONFIG_FB) && defined(CONFIG_PM)
+		   .pm = &gt1x_ts_pm_ops,
+#endif
+		   },
+};
+
+/**
+ * gt1x_ts_init - Driver Install function.
+ * Return   0---succeed.
+ */
+static int __init gt1x_ts_init(void)
+{
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("GTP driver installing...");
+
+	return i2c_add_driver(&gt1x_ts_driver);
+}
+
+/**
+ * gt1x_ts_exit - Driver uninstall function.
+ * Return   0---succeed.
+ */
+static void __exit gt1x_ts_exit(void)
+{
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("GTP driver exited.");
+	i2c_del_driver(&gt1x_ts_driver);
+}
+
+module_init(gt1x_ts_init);
+module_exit(gt1x_ts_exit);
+
+MODULE_DESCRIPTION("GTP Series Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/gt1x/gt1x.h b/drivers/input/touchscreen/gt1x/gt1x.h
new file mode 100644
index 000000000000..343fdc0cf0c5
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x.h
@@ -0,0 +1,62 @@
+/* drivers/input/touchscreen/gt1x.h
+ *
+ * 2010 - 2013 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#ifndef _GOODIX_GT1X_H_
+#define _GOODIX_GT1X_H_
+#include "gt1x_generic.h"
+#include <linux/gpio.h>
+#ifdef GTP_CONFIG_OF
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#endif
+#ifdef CONFIG_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#define IIC_MAX_TRANSFER_SIZE       250
+
+/* Customize your I/O ports & I/O operations */
+#ifdef GTP_CONFIG_OF
+extern int gt1x_rst_gpio;
+extern int gt1x_int_gpio;
+#define GTP_RST_PORT gt1x_rst_gpio
+#define GTP_INT_PORT gt1x_int_gpio
+#else
+#define GTP_RST_PORT    102
+#define GTP_INT_PORT    52
+#endif
+
+#define GTP_INT_IRQ     gpio_to_irq(GTP_INT_PORT)
+/*#define GTP_INT_CFG     S3C_GPIO_SFN(0xF)*/
+
+#define GTP_GPIO_AS_INPUT(pin)          do {\
+	gpio_direction_input(pin);\
+} while (0)
+#define GTP_GPIO_AS_INT(pin)            do {\
+	GTP_GPIO_AS_INPUT(pin);\
+} while (0)
+#define GTP_GPIO_GET_VALUE(pin)         gpio_get_value(pin)
+#define GTP_GPIO_OUTPUT(pin, level)      gpio_direction_output(pin, level)
+#define GTP_IRQ_TAB                     {IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH}
+
+#endif /* _GOODIX_GT1X_H_ */
diff --git a/drivers/input/touchscreen/gt1x/gt1x_extents.c b/drivers/input/touchscreen/gt1x/gt1x_extents.c
new file mode 100644
index 000000000000..aeb5f2e5649d
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_extents.c
@@ -0,0 +1,927 @@
+/* drivers/input/touchscreen/gt1x_extents.c
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/input.h>
+
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>	/*proc */
+
+#include <asm/ioctl.h>
+#include "gt1x_generic.h"
+
+#if GTP_GESTURE_WAKEUP
+
+#define GESTURE_NODE "goodix_gesture"
+#define GESTURE_MAX_POINT_COUNT    64
+
+#pragma pack(1)
+typedef struct {
+	u8 ic_msg[6];		/*from the first byte */
+	u8 gestures[4];
+	u8 data[3 + GESTURE_MAX_POINT_COUNT * 4 + 80];	/*80 bytes for extra data */
+} st_gesture_data;
+#pragma pack()
+
+#define SETBIT(longlong, bit)   (longlong[bit/8] |=  (1 << bit%8))
+#define CLEARBIT(longlong, bit) (longlong[bit/8] &= (~(1 << bit%8)))
+#define QUERYBIT(longlong, bit) (!!(longlong[bit/8] & (1 << bit%8)))
+
+#define CHKBITS_32          32
+#define CHKBITS_16          16
+#define CHKBITS_8           8
+
+int gesture_enabled;    /* module switch */
+DOZE_T gesture_doze_status = DOZE_DISABLED; /* doze status */
+
+static u8 gestures_flag[32]; /* gesture flag, every bit stands for a gesture */
+static st_gesture_data gesture_data; /* gesture data buffer */
+static struct mutex gesture_data_mutex; /* lock for gesture data */
+
+static ssize_t gt1x_gesture_data_read(struct file *file, char __user *page, size_t size, loff_t *ppos)
+{
+	s32 ret = -1;
+	GTP_DEBUG("visit gt1x_gesture_data_read. ppos:%d", (int)*ppos);
+	if (*ppos) {
+		return 0;
+	}
+	if (size == 4) {
+		ret = copy_to_user(((u8 __user *) page), "GT1X", 4);
+		return 4;
+	}
+	ret = simple_read_from_buffer(page, size, ppos, &gesture_data, sizeof(gesture_data));
+
+	GTP_DEBUG("Got the gesture data.");
+	return ret;
+}
+
+static ssize_t gt1x_gesture_data_write(struct file *filp, const char __user *buff, size_t len, loff_t *off)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG_FUNC();
+
+	ret = copy_from_user(&gesture_enabled, buff, 1);
+	if (ret) {
+		GTP_ERROR("copy_from_user failed.");
+		return -EPERM;
+	}
+
+	GTP_DEBUG("gesture enabled:%x, ret:%d", gesture_enabled, ret);
+
+	return len;
+}
+
+/**
+ * calc_checksum - Calc checksum.
+ * @buf: data to be calc
+ * @len: length of buf.
+ * @bits: checkbits
+ * Return true-pass, false:not pass.
+ */
+static bool calc_checksum(u8 *buf, int len, int bits)
+{
+	int i;
+
+	if (bits == CHKBITS_16) {
+		u16 chksum, *b = (u16 *)buf;
+
+		if (len % 2) {
+			return false;
+		}
+
+		len /= 2;
+		for (i = 0, chksum = 0; i < len; i++) {
+			if (i == len - 1)
+				chksum += le16_to_cpu(b[i]);
+			else
+				chksum += be16_to_cpu(b[i]);
+		}
+		return chksum == 0 ? true : false;
+	} else if (bits == CHKBITS_8) {
+		u8 chksum;
+
+		for (i = 0, chksum = 0; i < len; i++) {
+			chksum += buf[i];
+		}
+		return chksum == 0 ? true : false;
+	}
+	return false;
+}
+
+int gesture_enter_doze(void)
+{
+	int retry = 0;
+
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("Entering doze mode...");
+	while (retry++ < 5) {
+		if (!gt1x_send_cmd(0x08, 0)) {
+			gesture_doze_status = DOZE_ENABLED;
+			GTP_DEBUG("Working in doze mode!");
+			return 0;
+		}
+		msleep(10);
+	}
+	GTP_ERROR("Send doze cmd failed.");
+	return -1;
+}
+
+s32 gesture_event_handler(struct input_dev *dev)
+{
+	u8 doze_buf[4] = { 0 }, ges_type;
+	static int err_flag1, err_flag2;
+	int len, extra_len, need_chk;
+	unsigned int key_code;
+	s32 ret = 0;
+
+	if (DOZE_ENABLED != gesture_doze_status) {
+		return -1;
+	}
+
+	/** package: -head 4B + track points + extra info-
+	 * - head -
+	 *  doze_buf[0]: gesture type,
+	 *  doze_buf[1]: number of gesture points ,
+	 *  doze_buf[2]: protocol type,
+	 *  doze_buf[3]: gesture extra data length.
+	 */
+	ret = gt1x_i2c_read(GTP_REG_WAKEUP_GESTURE, doze_buf, 4);
+	if (ret < 0) {
+		return 0;
+	}
+
+	ges_type = doze_buf[0];
+	len = doze_buf[1];
+	need_chk = doze_buf[2] & 0x80;
+	extra_len = doze_buf[3];
+
+	GTP_DEBUG("0x%x = 0x%02X,0x%02X,0x%02X,0x%02X", GTP_REG_WAKEUP_GESTURE,
+			doze_buf[0], doze_buf[1], doze_buf[2], doze_buf[3]);
+
+	if (len > GESTURE_MAX_POINT_COUNT) {
+		GTP_ERROR("Gesture contain too many points!(%d)", len);
+		len = GESTURE_MAX_POINT_COUNT;
+	}
+
+	if (extra_len > 32) {
+		GTP_ERROR("Gesture contain too many extra data!(%d)", extra_len);
+		extra_len = 32;
+	}
+
+	/* get gesture extra info */
+	if (extra_len >= 0) {
+		u8 ges_data[extra_len + 1];
+
+		/* head 4 + extra data * 4 + chksum 1 */
+		ret = gt1x_i2c_read(GTP_REG_WAKEUP_GESTURE + 4,
+				ges_data, extra_len + 1);
+		if (ret < 0) {
+			GTP_ERROR("Read extra gesture data failed.");
+			return 0;
+		}
+
+		if (likely(need_chk)) { /* calc checksum */
+			bool val;
+
+			ges_data[extra_len] += doze_buf[0] + doze_buf[1]
+				+ doze_buf[2] + doze_buf[3];
+
+			val = calc_checksum(ges_data, extra_len + 1, CHKBITS_8);
+			if (unlikely(!val)) { /* check failed */
+				GTP_ERROR("Gesture checksum error.");
+				if (err_flag1) {
+					err_flag1 = 0;
+					ret = 0;
+					goto clear_reg;
+				} else {
+					/* just return 0 without clear reg,
+					   this will receive another int, we
+					   check the data in the next frame */
+					err_flag1 = 1;
+					return 0;
+				}
+			}
+
+			err_flag1 = 0;
+		}
+
+		mutex_lock(&gesture_data_mutex);
+		memcpy(&gesture_data.data[4 + len * 4], ges_data, extra_len);
+		mutex_unlock(&gesture_data_mutex);
+	}
+
+	/* check gesture type (if available?) */
+	if (ges_type == 0 || !QUERYBIT(gestures_flag, ges_type)) {
+		GTP_INFO("Gesture[0x%02X] has been disabled.", doze_buf[0]);
+		doze_buf[0] = 0x00;
+		gt1x_i2c_write(GTP_REG_WAKEUP_GESTURE, doze_buf, 1);
+		gesture_enter_doze();
+		return 0;
+	}
+
+	/* get gesture point data */
+	if (len > 0) { /* coor num * 4 + chksum 2*/
+		u8 ges_data[len * 4 + 2];
+
+		ret = gt1x_i2c_read(GES_BUFFER_ADDR, ges_data, len * 4);
+		if (ret < 0) {
+			GTP_ERROR("Read gesture data failed.");
+			return 0;
+		}
+
+		/* checksum reg for gesture point data */
+		ret = gt1x_i2c_read(0x819F, &ges_data[len * 4], 2);
+		if (ret < 0) {
+			GTP_ERROR("Read gesture data failed.");
+			return 0;
+		}
+
+		if (likely(need_chk)) {
+			bool val = calc_checksum(ges_data,
+					len * 4 + 2, CHKBITS_16);
+			if (unlikely(!val)) { /* check failed */
+				GTP_ERROR("Gesture checksum error.");
+				if (err_flag2) {
+					err_flag2 = 0;
+					ret = 0;
+					goto clear_reg;
+				} else {
+					err_flag2 = 1;
+					return 0;
+				}
+			}
+
+			err_flag2 = 0;
+		}
+
+		mutex_lock(&gesture_data_mutex);
+		memcpy(&gesture_data.data[4], ges_data, len * 4);
+		mutex_unlock(&gesture_data_mutex);
+	}
+
+	mutex_lock(&gesture_data_mutex);
+	gesture_data.data[0] = ges_type;	/*gesture type*/
+	gesture_data.data[1] = len;	        /*gesture points number*/
+	gesture_data.data[2] = doze_buf[2] & 0x7F; /*protocol type*/
+	gesture_data.data[3] = extra_len;   /*gesture date length*/
+	mutex_unlock(&gesture_data_mutex);
+
+	/* get key code */
+	key_code = ges_type < 16 ? KEY_GES_CUSTOM : KEY_GES_REGULAR;
+	GTP_DEBUG("Gesture: 0x%02X, points: %d", doze_buf[0], doze_buf[1]);
+
+	input_report_key(dev, key_code, 1);
+	input_sync(dev);
+	input_report_key(dev, key_code, 0);
+	input_sync(dev);
+
+clear_reg:
+	doze_buf[0] = 0; /*clear ges flag*/
+	gt1x_i2c_write(GTP_REG_WAKEUP_GESTURE, doze_buf, 1);
+	return ret;
+}
+
+void gesture_clear_wakeup_data(void)
+{
+	mutex_lock(&gesture_data_mutex);
+	memset(gesture_data.data, 0, 4);
+	mutex_unlock(&gesture_data_mutex);
+}
+
+void gt1x_gesture_debug(int on)
+{
+	if (on) {
+		gesture_enabled = 1;
+		memset(gestures_flag, 0xFF, sizeof(gestures_flag));
+	} else {
+		gesture_enabled = 0;
+		memset(gestures_flag, 0x00, sizeof(gestures_flag));
+		gesture_doze_status = DOZE_DISABLED;
+	}
+	GTP_DEBUG("Gesture debug %s", on ? "on":"off");
+}
+
+#endif /* GTP_GESTURE_WAKEUP */
+
+/*HotKnot module*/
+#if GTP_HOTKNOT
+#define HOTKNOT_NODE "hotknot"
+#define HOTKNOT_VERSION  "GOODIX,GT1X"
+u8 hotknot_enabled;
+u8 hotknot_transfer_mode;
+
+static int hotknot_open(struct inode *node, struct file *flip)
+{
+	GTP_DEBUG("Hotknot is enabled.");
+	hotknot_enabled = 1;
+	return 0;
+}
+
+static int hotknot_release(struct inode *node, struct file *filp)
+{
+	GTP_DEBUG("Hotknot is disabled.");
+	hotknot_enabled = 0;
+	return 0;
+}
+
+static s32 hotknot_enter_transfer_mode(void)
+{
+	int ret = 0;
+	u8 buffer[5] = { 0 };
+
+	hotknot_transfer_mode = 1;
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_OFF);
+#endif
+
+	gt1x_irq_disable();
+	gt1x_send_cmd(GTP_CMD_HN_TRANSFER, 0);
+	msleep(100);
+	gt1x_irq_enable();
+
+	ret = gt1x_i2c_read(0x8140, buffer, sizeof(buffer));
+	if (ret) {
+		hotknot_transfer_mode = 0;
+		return ret;
+	}
+
+	buffer[4] = 0;
+	GTP_DEBUG("enter transfer mode: %s ", buffer);
+	if (strcmp(buffer, "GHot")) {
+		hotknot_transfer_mode = 0;
+		return ERROR_HN_VER;
+	}
+
+	return 0;
+}
+
+static s32 hotknot_load_hotknot_subsystem(void)
+{
+	return hotknot_enter_transfer_mode();
+}
+
+static s32 hotknot_load_authentication_subsystem(void)
+{
+	s32 ret = 0;
+	u8 buffer[5] = { 0 };
+	ret = gt1x_hold_ss51_dsp_no_reset();
+	if (ret < 0) {
+		GTP_ERROR("Hold ss51 fail!");
+		return ERROR;
+	}
+
+	if (gt1x_chip_type == CHIP_TYPE_GT1X) {
+		GTP_INFO("hotknot load jump code.");
+		ret = gt1x_load_patch(gt1x_patch_jump_fw, 4096, 0, 1024 * 8);
+		if (ret < 0) {
+			GTP_ERROR("Load jump code fail!");
+			return ret;
+		}
+		GTP_INFO("hotknot load auth code.");
+		ret = gt1x_load_patch(hotknot_auth_fw, 4096, 4096, 1024 * 8);
+		if (ret < 0) {
+			GTP_ERROR("Load auth system fail!");
+			return ret;
+		}
+	} else { /* GT2X */
+		GTP_INFO("hotknot load auth code.");
+		ret = gt1x_load_patch(hotknot_auth_fw, 4096, 0, 1024 * 6);
+		if (ret < 0) {
+			GTP_ERROR("load auth system fail!");
+			return ret;
+		}
+	}
+
+	ret = gt1x_startup_patch();
+	if (ret < 0) {
+		GTP_ERROR("Startup auth system fail!");
+		return ret;
+	}
+	ret = gt1x_i2c_read(GTP_REG_VERSION, buffer, 4);
+	if (ret < 0) {
+		GTP_ERROR("i2c read error!");
+		return ERROR_IIC;
+	}
+	buffer[4] = 0;
+	GTP_INFO("Current System version: %s", buffer);
+	return 0;
+}
+
+static s32 hotknot_recovery_main_system(void)
+{
+	gt1x_irq_disable();
+	gt1x_reset_guitar();
+	gt1x_irq_enable();
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_ON);
+#endif
+	hotknot_transfer_mode = 0;
+	return 0;
+}
+
+#if HOTKNOT_BLOCK_RW
+DECLARE_WAIT_QUEUE_HEAD(bp_waiter);
+static u8 got_hotknot_state;
+static u8 got_hotknot_extra_state;
+static u8 wait_hotknot_state;
+static u8 force_wake_flag;
+static u8 block_enable;
+s32 hotknot_paired_flag;
+
+static s32 hotknot_block_rw(u8 rqst_hotknot_state, s32 wait_hotknot_timeout)
+{
+	s32 ret = 0;
+
+	wait_hotknot_state |= rqst_hotknot_state;
+	GTP_DEBUG("Goodix tool received wait polling state:0x%x,timeout:%d, all wait state:0x%x", rqst_hotknot_state, wait_hotknot_timeout, wait_hotknot_state);
+	got_hotknot_state &= (~rqst_hotknot_state);
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	if (wait_hotknot_timeout <= 0) {
+		wait_event_interruptible(bp_waiter, force_wake_flag || rqst_hotknot_state == (got_hotknot_state & rqst_hotknot_state));
+	} else {
+		wait_event_interruptible_timeout(bp_waiter, force_wake_flag || rqst_hotknot_state == (got_hotknot_state & rqst_hotknot_state), wait_hotknot_timeout);
+	}
+
+	wait_hotknot_state &= (~rqst_hotknot_state);
+
+	if (rqst_hotknot_state != (got_hotknot_state & rqst_hotknot_state)) {
+		GTP_ERROR("Wait 0x%x block polling waiter failed.", rqst_hotknot_state);
+		ret = -1;
+	}
+
+	force_wake_flag = 0;
+	return ret;
+}
+
+static void hotknot_wakeup_block(void)
+{
+	GTP_DEBUG("Manual wakeup all block polling waiter!");
+	got_hotknot_state = 0;
+	wait_hotknot_state = 0;
+	force_wake_flag = 1;
+	wake_up_interruptible(&bp_waiter);
+}
+
+s32 hotknot_event_handler(u8 *data)
+{
+	u8 hn_pxy_state = 0;
+	u8 hn_pxy_state_bak = 0;
+	static u8 hn_paired_cnt;
+	u8 hn_state_buf[10] = { 0 };
+	u8 finger = data[0];
+	u8 id = 0;
+
+	if (block_enable && !hotknot_paired_flag && (finger & 0x0F)) {
+		id = data[1];
+		hn_pxy_state = data[2] & 0x80;
+		hn_pxy_state_bak = data[3] & 0x80;
+		if ((32 == id) && (0x80 == hn_pxy_state) && (0x80 == hn_pxy_state_bak)) {
+#ifdef HN_DBLCFM_PAIRED
+			if (hn_paired_cnt++ < 2) {
+				return 0;
+			}
+#endif
+			GTP_DEBUG("HotKnot paired!");
+			if (wait_hotknot_state & HN_DEVICE_PAIRED) {
+				GTP_DEBUG("INT wakeup HN_DEVICE_PAIRED block polling waiter");
+				got_hotknot_state |= HN_DEVICE_PAIRED;
+				wake_up_interruptible(&bp_waiter);
+			}
+			block_enable = 0;
+			hotknot_paired_flag = 1;
+			return 0;
+		} else {
+			got_hotknot_state &= (~HN_DEVICE_PAIRED);
+			hn_paired_cnt = 0;
+		}
+	}
+
+	if (hotknot_paired_flag) {
+		s32 ret = -1;
+		ret = gt1x_i2c_read(GTP_REG_HN_STATE, hn_state_buf, 6);
+		if (ret < 0) {
+			GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
+			return 0;
+		}
+
+		got_hotknot_state = 0;
+
+		GTP_DEBUG("wait_hotknot_state:%x", wait_hotknot_state);
+		GTP_DEBUG("[0x8800~0x8803]=0x%x,0x%x,0x%x,0x%x", hn_state_buf[0], hn_state_buf[1], hn_state_buf[2], hn_state_buf[3]);
+
+		if (wait_hotknot_state & HN_MASTER_SEND) {
+			if ((0x03 == hn_state_buf[0]) || (0x04 == hn_state_buf[0])
+			    || (0x07 == hn_state_buf[0])) {
+				GTP_DEBUG("Wakeup HN_MASTER_SEND block polling waiter");
+				got_hotknot_state |= HN_MASTER_SEND;
+				got_hotknot_extra_state = hn_state_buf[0];
+				wake_up_interruptible(&bp_waiter);
+			}
+		} else if (wait_hotknot_state & HN_SLAVE_RECEIVED) {
+			if ((0x03 == hn_state_buf[1]) || (0x04 == hn_state_buf[1])
+			    || (0x07 == hn_state_buf[1])) {
+				GTP_DEBUG("Wakeup HN_SLAVE_RECEIVED block polling waiter:0x%x", hn_state_buf[1]);
+				got_hotknot_state |= HN_SLAVE_RECEIVED;
+				got_hotknot_extra_state = hn_state_buf[1];
+				wake_up_interruptible(&bp_waiter);
+			}
+		} else if (wait_hotknot_state & HN_MASTER_DEPARTED) {
+			if (0x07 == hn_state_buf[0]) {
+				GTP_DEBUG("Wakeup HN_MASTER_DEPARTED block polling waiter");
+				got_hotknot_state |= HN_MASTER_DEPARTED;
+				wake_up_interruptible(&bp_waiter);
+			}
+		} else if (wait_hotknot_state & HN_SLAVE_DEPARTED) {
+			if (0x07 == hn_state_buf[1]) {
+				GTP_DEBUG("Wakeup HN_SLAVE_DEPARTED block polling waiter");
+				got_hotknot_state |= HN_SLAVE_DEPARTED;
+				wake_up_interruptible(&bp_waiter);
+			}
+		}
+		return 0;
+	}
+
+	return -1;
+}
+#endif /*HOTKNOT_BLOCK_RW*/
+#endif /*GTP_HOTKNOT*/
+
+#define GOODIX_MAGIC_NUMBER        'G'
+#define NEGLECT_SIZE_MASK           (~(_IOC_SIZEMASK << _IOC_SIZESHIFT))
+
+#define GESTURE_ENABLE              _IO(GOODIX_MAGIC_NUMBER, 1)
+#define GESTURE_DISABLE             _IO(GOODIX_MAGIC_NUMBER, 2)
+#define GESTURE_FLAG_SET            _IO(GOODIX_MAGIC_NUMBER, 3)
+#define GESTURE_FLAG_CLEAR          _IO(GOODIX_MAGIC_NUMBER, 4)
+/*#define SET_ENABLED_GESTURE         (_IOW(GOODIX_MAGIC_NUMBER, 5, u8) & NEGLECT_SIZE_MASK)*/
+#define GESTURE_DATA_OBTAIN         (_IOR(GOODIX_MAGIC_NUMBER, 6, u8) & NEGLECT_SIZE_MASK)
+#define GESTURE_DATA_ERASE          _IO(GOODIX_MAGIC_NUMBER, 7)
+
+/*#define HOTKNOT_LOAD_SUBSYSTEM      (_IOW(GOODIX_MAGIC_NUMBER, 6, u8) & NEGLECT_SIZE_MASK)*/
+#define HOTKNOT_LOAD_HOTKNOT        _IO(GOODIX_MAGIC_NUMBER, 20)
+#define HOTKNOT_LOAD_AUTHENTICATION _IO(GOODIX_MAGIC_NUMBER, 21)
+#define HOTKNOT_RECOVERY_MAIN       _IO(GOODIX_MAGIC_NUMBER, 22)
+/*#define HOTKNOT_BLOCK_RW            (_IOW(GOODIX_MAGIC_NUMBER, 6, u8) & NEGLECT_SIZE_MASK)*/
+#define HOTKNOT_DEVICES_PAIRED      _IO(GOODIX_MAGIC_NUMBER, 23)
+#define HOTKNOT_MASTER_SEND         _IO(GOODIX_MAGIC_NUMBER, 24)
+#define HOTKNOT_SLAVE_RECEIVE       _IO(GOODIX_MAGIC_NUMBER, 25)
+/*#define HOTKNOT_DEVICES_COMMUNICATION*/
+#define HOTKNOT_MASTER_DEPARTED     _IO(GOODIX_MAGIC_NUMBER, 26)
+#define HOTKNOT_SLAVE_DEPARTED      _IO(GOODIX_MAGIC_NUMBER, 27)
+#define HOTKNOT_VENDOR_VERSION      (_IOR(GOODIX_MAGIC_NUMBER, 28, u8) & NEGLECT_SIZE_MASK)
+#define HOTKNOT_WAKEUP_BLOCK        _IO(GOODIX_MAGIC_NUMBER, 29)
+
+#define IO_IIC_READ                  (_IOR(GOODIX_MAGIC_NUMBER, 100, u8) & NEGLECT_SIZE_MASK)
+#define IO_IIC_WRITE                 (_IOW(GOODIX_MAGIC_NUMBER, 101, u8) & NEGLECT_SIZE_MASK)
+#define IO_RESET_GUITAR              _IO(GOODIX_MAGIC_NUMBER, 102)
+#define IO_DISABLE_IRQ               _IO(GOODIX_MAGIC_NUMBER, 103)
+#define IO_ENABLE_IRQ                _IO(GOODIX_MAGIC_NUMBER, 104)
+#define IO_GET_VERISON               (_IOR(GOODIX_MAGIC_NUMBER, 110, u8) & NEGLECT_SIZE_MASK)
+#define IO_PRINT                     (_IOW(GOODIX_MAGIC_NUMBER, 111, u8) & NEGLECT_SIZE_MASK)
+#define IO_VERSION                   "V1.3-20150420"
+
+#define CMD_HEAD_LENGTH             20
+static s32 io_iic_read(u8 *data, void __user *arg)
+{
+	s32 err = ERROR;
+	s32 data_length = 0;
+	u16 addr = 0;
+
+	err = copy_from_user(data, arg, CMD_HEAD_LENGTH);
+	if (err) {
+		GTP_ERROR("Can't access the memory.");
+		return ERROR_MEM;
+	}
+
+	addr = data[0] << 8 | data[1];
+	data_length = data[2] << 8 | data[3];
+
+	err = gt1x_i2c_read(addr, &data[CMD_HEAD_LENGTH], data_length);
+	if (!err) {
+		err = copy_to_user(&((u8 __user *) arg)[CMD_HEAD_LENGTH], &data[CMD_HEAD_LENGTH], data_length);
+		if (err) {
+			GTP_ERROR("ERROR when copy to user.[addr: %04x], [read length:%d]", addr, data_length);
+			return ERROR_MEM;
+		}
+		err = CMD_HEAD_LENGTH + data_length;
+	}
+	/*GTP_DEBUG("IIC_READ.addr:0x%4x, length:%d, ret:%d", addr, data_length, err);*/
+	/*GTP_DEBUG_ARRAY((&data[CMD_HEAD_LENGTH]), data_length);*/
+
+	return err;
+}
+
+static s32 io_iic_write(u8 *data)
+{
+	s32 err = ERROR;
+	s32 data_length = 0;
+	u16 addr = 0;
+
+	addr = data[0] << 8 | data[1];
+	data_length = data[2] << 8 | data[3];
+
+	err = gt1x_i2c_write(addr, &data[CMD_HEAD_LENGTH], data_length);
+	if (!err) {
+		err = CMD_HEAD_LENGTH + data_length;
+	}
+
+	return err;
+}
+
+/*
+ *@return, 0:operate successfully
+ *        > 0: the length of memory size ioctl has accessed,
+ *        error otherwise.
+ */
+static long gt1x_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	u32 value = 0;
+	s32 ret = 0;
+	u8 *data = NULL;
+	int cnt = 30;
+
+	/* Blocking when firmwaer updating */
+	while (cnt-- && update_info.status) {
+		ssleep(1);
+	}
+	/*GTP_DEBUG("IOCTL CMD:%x", cmd);*/
+	/* GTP_DEBUG("command:%d, length:%d, rw:%s",
+	   _IOC_NR(cmd),
+	   _IOC_SIZE(cmd),
+	   (_IOC_DIR(cmd) & _IOC_READ) ? "read" : (_IOC_DIR(cmd) & _IOC_WRITE) ? "write" : "-");
+	   */
+	if (_IOC_DIR(cmd)) {
+		s32 err = -1;
+		s32 data_length = _IOC_SIZE(cmd);
+		data = kzalloc(data_length, GFP_KERNEL);
+		memset(data, 0, data_length);
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE) {
+			err = copy_from_user(data, (void __user *)arg, data_length);
+			if (err) {
+				GTP_ERROR("Can't access the memory.");
+				kfree(data);
+				return -1;
+			}
+		}
+	} else {
+		value = (u32) arg;
+	}
+
+	switch (cmd & NEGLECT_SIZE_MASK) {
+	case IO_GET_VERISON:
+		if ((u8 __user *) arg) {
+			ret = copy_to_user(((u8 __user *) arg), IO_VERSION, sizeof(IO_VERSION));
+			if (!ret) {
+				ret = sizeof(IO_VERSION);
+			}
+			GTP_INFO("%s", IO_VERSION);
+		}
+		break;
+	case IO_IIC_READ:
+		ret = io_iic_read(data, (void __user *)arg);
+		break;
+
+	case IO_IIC_WRITE:
+		ret = io_iic_write(data);
+		break;
+
+	case IO_RESET_GUITAR:
+		gt1x_irq_disable();
+		gt1x_reset_guitar();
+		gt1x_irq_enable();
+		break;
+
+	case IO_DISABLE_IRQ:
+		gt1x_irq_disable();
+#if GTP_ESD_PROTECT
+		gt1x_esd_switch(SWITCH_OFF);
+#endif
+		break;
+
+	case IO_ENABLE_IRQ:
+		gt1x_irq_enable();
+#if GTP_ESD_PROTECT
+		gt1x_esd_switch(SWITCH_ON);
+#endif
+		break;
+
+		/*print a string to syc log messages between application and kernel.*/
+	case IO_PRINT:
+		if (data)
+			GTP_INFO("%s", (char *)data);
+		break;
+
+#if GTP_GESTURE_WAKEUP
+	case GESTURE_ENABLE:
+		GTP_DEBUG("Gesture switch ON.");
+		gesture_enabled = 1;
+		break;
+
+	case GESTURE_DISABLE:
+		GTP_DEBUG("Gesture switch OFF.");
+		gesture_enabled = 0;
+		break;
+
+	case GESTURE_FLAG_SET:
+		SETBIT(gestures_flag, (u8) value);
+		GTP_DEBUG("Gesture flag: 0x%02X enabled.", value);
+		break;
+
+	case GESTURE_FLAG_CLEAR:
+		CLEARBIT(gestures_flag, (u8) value);
+		GTP_DEBUG("Gesture flag: 0x%02X disabled.", value);
+		break;
+
+	case GESTURE_DATA_OBTAIN:
+		GTP_DEBUG("Obtain gesture data.");
+		mutex_lock(&gesture_data_mutex);
+		ret = copy_to_user(((u8 __user *) arg), &gesture_data.data, 4 + gesture_data.data[1] * 4 + gesture_data.data[3]);
+		if (ret) {
+			GTP_ERROR("ERROR when copy gesture data to user.");
+			ret = ERROR_MEM;
+		} else {
+			ret = 4 + gesture_data.data[1] * 4 + gesture_data.data[3];
+		}
+		mutex_unlock(&gesture_data_mutex);
+		break;
+
+	case GESTURE_DATA_ERASE:
+		GTP_DEBUG("ERASE_GESTURE_DATA");
+		gesture_clear_wakeup_data();
+		break;
+#endif /*GTP_GESTURE_WAKEUP*/
+
+#if GTP_HOTKNOT
+	case HOTKNOT_VENDOR_VERSION:
+		ret =  copy_to_user(((u8 __user *) arg), HOTKNOT_VERSION, sizeof(HOTKNOT_VERSION));
+		if (!ret) {
+			ret = sizeof(HOTKNOT_VERSION);
+		}
+		break;
+	case HOTKNOT_LOAD_HOTKNOT:
+		ret = hotknot_load_hotknot_subsystem();
+		break;
+
+	case HOTKNOT_LOAD_AUTHENTICATION:
+#if GTP_ESD_PROTECT
+		gt1x_esd_switch(SWITCH_OFF);
+#endif
+		ret = hotknot_load_authentication_subsystem();
+		break;
+
+	case HOTKNOT_RECOVERY_MAIN:
+		ret = hotknot_recovery_main_system();
+		break;
+#if HOTKNOT_BLOCK_RW
+	case HOTKNOT_DEVICES_PAIRED:
+		hotknot_paired_flag = 0;
+		force_wake_flag = 0;
+		block_enable = 1;
+		ret = hotknot_block_rw(HN_DEVICE_PAIRED, (s32) value);
+		break;
+
+	case HOTKNOT_MASTER_SEND:
+		ret = hotknot_block_rw(HN_MASTER_SEND, (s32) value);
+		if (!ret)
+			ret = got_hotknot_extra_state;
+		break;
+
+	case HOTKNOT_SLAVE_RECEIVE:
+		ret = hotknot_block_rw(HN_SLAVE_RECEIVED, (s32) value);
+		if (!ret)
+			ret = got_hotknot_extra_state;
+		break;
+
+	case HOTKNOT_MASTER_DEPARTED:
+		ret = hotknot_block_rw(HN_MASTER_DEPARTED, (s32) value);
+		break;
+
+	case HOTKNOT_SLAVE_DEPARTED:
+		ret = hotknot_block_rw(HN_SLAVE_DEPARTED, (s32) value);
+		break;
+
+	case HOTKNOT_WAKEUP_BLOCK:
+		hotknot_wakeup_block();
+		break;
+#endif /*HOTKNOT_BLOCK_RW*/
+#endif /*GTP_HOTKNOT*/
+
+	default:
+		GTP_INFO("Unknown cmd.");
+		ret = -1;
+		break;
+	}
+
+	if (data != NULL) {
+		kfree(data);
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long gt1x_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *arg32 = compat_ptr(arg);
+
+	if (!file->f_op || !file->f_op->unlocked_ioctl)
+		return -ENOTTY;
+
+	return file->f_op->unlocked_ioctl(file, cmd, (unsigned long)arg32);
+}
+#endif
+
+static const struct file_operations gt1x_fops = {
+	.owner = THIS_MODULE,
+#if GTP_GESTURE_WAKEUP
+	.read = gt1x_gesture_data_read,
+	.write = gt1x_gesture_data_write,
+#endif
+	.unlocked_ioctl = gt1x_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl = gt1x_compat_ioctl,
+#endif
+};
+
+#if GTP_HOTKNOT
+static const struct file_operations hotknot_fops = {
+	.open = hotknot_open,
+	.release = hotknot_release,
+	.unlocked_ioctl = gt1x_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl = gt1x_compat_ioctl,
+#endif
+};
+
+static struct miscdevice hotknot_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = HOTKNOT_NODE,
+	.fops = &hotknot_fops,
+};
+#endif
+
+s32 gt1x_init_node(void)
+{
+#if GTP_GESTURE_WAKEUP
+	struct proc_dir_entry *proc_entry = NULL;
+	mutex_init(&gesture_data_mutex);
+	memset(gestures_flag, 0, sizeof(gestures_flag));
+	memset((u8 *) &gesture_data, 0, sizeof(st_gesture_data));
+
+	proc_entry = proc_create(GESTURE_NODE, 0755, NULL, &gt1x_fops);
+	if (proc_entry == NULL) {
+		GTP_ERROR("CAN't create proc entry /proc/%s.", GESTURE_NODE);
+		return -1;
+	} else {
+		GTP_INFO("Created proc entry /proc/%s.", GESTURE_NODE);
+	}
+#endif
+
+#if GTP_HOTKNOT
+	if (misc_register(&hotknot_misc_device)) {
+		GTP_ERROR("CAN't create misc device in /dev/hotknot.");
+		return -1;
+	} else {
+		GTP_INFO("Created misc device in /dev/hotknot.");
+	}
+#endif
+	return 0;
+}
+
+void gt1x_deinit_node(void)
+{
+#if GTP_GESTURE_WAKEUP
+	remove_proc_entry(GESTURE_NODE, NULL);
+#endif
+
+#if GTP_HOTKNOT
+	misc_deregister(&hotknot_misc_device);
+#endif
+}
diff --git a/drivers/input/touchscreen/gt1x/gt1x_firmware.h b/drivers/input/touchscreen/gt1x/gt1x_firmware.h
new file mode 100644
index 000000000000..7588633397f5
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_firmware.h
@@ -0,0 +1,548 @@
+/* drivers/input/touchscreen/gt1x_firmware.h
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#ifndef _GT1X_FIRMWARE_H_
+#define _GT1X_FIRMWARE_H_
+
+unsigned char gt1x_default_FW[] = {
+};
+
+#if GTP_HOTKNOT
+unsigned char gt1x_patch_jump_fw[] = {
+    0xa8, 0x3f, 0x06, 0xec, 0xd9, 0x50, 0xf5, 0xbf, 0xb9, 0xc2, 0xec, 0x5c, 0x94, 0x2c, 0xd0, 0xc0,
+    0x56, 0x1b, 0x01, 0xaa, 0xea, 0x04, 0xe0, 0xa8, 0x36, 0x37, 0xd4, 0xbf, 0x33, 0xfe, 0xea, 0x9e,
+    0x7b, 0xf0, 0x20, 0x46, 0x80, 0x73, 0x6b, 0x4e, 0x3f, 0x27, 0x51, 0x1e, 0x3d, 0x80, 0x05, 0x01,
+    0x2d, 0xee, 0x85, 0x0f, 0xa9, 0x87, 0x11, 0x29, 0x24, 0xef, 0x2c, 0x47, 0xc0, 0x75, 0x24, 0xac,
+    0x41, 0xb6, 0x31, 0x8c, 0x3f, 0xa3, 0x95, 0x98, 0x50, 0xe2, 0x51, 0x2d, 0x9a, 0xcb, 0x14, 0x6e,
+    0xb7, 0x17, 0xc1, 0x85, 0x2e, 0x04, 0x5d, 0xa9, 0xc5, 0x0d, 0x8a, 0x46, 0x59, 0x69, 0x13, 0x55,
+    0xfb, 0xbf, 0x92, 0xcb, 0xc2, 0xc0, 0x63, 0xdc, 0x0a, 0x94, 0xfd, 0x09, 0x76, 0x5c, 0xd2, 0xc6,
+    0xf2, 0x21, 0x03, 0x81, 0x7f, 0xa9, 0xe9, 0xae, 0x5d, 0x04, 0xff, 0x98, 0x5a, 0x70, 0xc3, 0xd7,
+    0x09, 0x0c, 0xd1, 0x7b, 0xc4, 0x88, 0x81, 0x2a, 0xe1, 0x36, 0x78, 0xbc, 0x93, 0x53, 0xbf, 0x04,
+    0x30, 0x9f, 0xa5, 0x01, 0xa2, 0x98, 0x80, 0x58, 0xe0, 0x30, 0xb0, 0x86, 0xbe, 0x7c, 0x70, 0x7b,
+    0x39, 0x8e, 0x24, 0x15, 0xbb, 0xf6, 0x7d, 0xab, 0x06, 0xc1, 0xba, 0xd7, 0x28, 0x5d, 0x58, 0xec,
+    0x8f, 0xef, 0x09, 0x2b, 0xb4, 0xff, 0xdd, 0xe6, 0x42, 0x79, 0xae, 0x4b, 0x21, 0x4d, 0xd1, 0xa4,
+    0x62, 0x88, 0x0b, 0x17, 0x8d, 0xc5, 0x35, 0x25, 0xbc, 0x47, 0x2d, 0x10, 0x52, 0x79, 0x0a, 0x4c,
+    0x0b, 0x2e, 0x7d, 0xd2, 0x5b, 0xde, 0x8b, 0xe5, 0x17, 0x2d, 0xe8, 0xf8, 0xf5, 0x90, 0xd9, 0x65,
+    0xcf, 0x3f, 0xf6, 0xf1, 0xe7, 0x10, 0x49, 0x6f, 0xf3, 0x22, 0xb1, 0x11, 0x51, 0x60, 0xda, 0x2c,
+    0xe7, 0x26, 0xb8, 0xbc, 0x70, 0xf7, 0xd9, 0xf1, 0x31, 0x5f, 0x37, 0xd9, 0x1b, 0x1f, 0x98, 0x80,
+    0xeb, 0xf2, 0xa0, 0x60, 0x7b, 0x06, 0xb8, 0x1c, 0x15, 0x54, 0xe3, 0x54, 0x8e, 0x24, 0x21, 0x7b,
+    0x4c, 0xb0, 0x20, 0x15, 0xec, 0x97, 0xf0, 0x73, 0x1c, 0xb8, 0x06, 0x5e, 0x5c, 0xfe, 0xc0, 0x77,
+    0x01, 0x85, 0xe0, 0x02, 0x45, 0xcf, 0x01, 0xcb, 0x93, 0x49, 0x96, 0x99, 0x43, 0x27, 0x78, 0x7e,
+    0x6d, 0xd7, 0xcc, 0x9e, 0xa4, 0xe7, 0x33, 0x17, 0x44, 0x09, 0x04, 0xac, 0xb9, 0xe7, 0x52, 0x75,
+    0x51, 0xfd, 0xc9, 0x50, 0x1d, 0xfa, 0x22, 0x63, 0xc2, 0x46, 0x09, 0x64, 0xab, 0x06, 0xf0, 0x3c,
+    0xe8, 0xab, 0x80, 0xd5, 0x7e, 0x66, 0xf6, 0x28, 0xc7, 0x3c, 0xc3, 0x1f, 0xa4, 0x76, 0x72, 0x10,
+    0x7b, 0xe9, 0xd4, 0xb9, 0x9c, 0xf4, 0xc6, 0xa4, 0xf1, 0xd9, 0xf4, 0x24, 0xc7, 0x97, 0x51, 0x13,
+    0xf7, 0x59, 0x80, 0x50, 0xa2, 0x25, 0xed, 0x4f, 0x88, 0x27, 0x4d, 0x66, 0xdf, 0x17, 0x71, 0x7f,
+    0xdd, 0x89, 0xa6, 0x11, 0xa8, 0x6e, 0xba, 0x1c, 0x17, 0xde, 0x5b, 0x10, 0xb2, 0xef, 0x7e, 0x64,
+    0xd9, 0x38, 0xc0, 0x29, 0xee, 0x9f, 0xfc, 0x36, 0xe4, 0x3c, 0xf0, 0x7d, 0x5e, 0xf6, 0x98, 0x7f,
+    0x74, 0xae, 0x57, 0x90, 0x2b, 0x09, 0x29, 0x27, 0xb8, 0x5f, 0xf8, 0xa7, 0xae, 0x2f, 0x70, 0xd6,
+    0x45, 0x04, 0x5e, 0x96, 0xef, 0x9e, 0x38, 0x79, 0xb3, 0x51, 0x97, 0x9d, 0xbb, 0xeb, 0x5a, 0x7d,
+    0xc4, 0xca, 0xd6, 0x07, 0xb1, 0xc3, 0xae, 0x37, 0xea, 0xd5, 0xaa, 0x36, 0x42, 0x8e, 0x3b, 0x6c,
+    0xb4, 0x50, 0xca, 0xde, 0x4a, 0x2a, 0x6f, 0x14, 0x25, 0x5b, 0x74, 0x04, 0xa6, 0x7e, 0x7e, 0x06,
+    0xcb, 0x39, 0xea, 0xdf, 0x14, 0x7e, 0xdf, 0x26, 0x3b, 0xe9, 0x13, 0x5f, 0xaf, 0x8f, 0xb9, 0x91,
+    0xb5, 0xd8, 0x30, 0x04, 0x99, 0x08, 0x01, 0xfb, 0xf2, 0x47, 0xd1, 0x07, 0x85, 0xfc, 0x58, 0x79,
+    0xd8, 0x0a, 0xdb, 0x0f, 0xe1, 0xe6, 0xcf, 0x60, 0x31, 0xd6, 0x4c, 0x5d, 0xb1, 0x50, 0x35, 0x92,
+    0x9c, 0xf8, 0x46, 0x61, 0x12, 0xf8, 0x05, 0x6c, 0x01, 0x52, 0x4f, 0x40, 0x05, 0xa4, 0x47, 0xbc,
+    0x01, 0x2a, 0x65, 0xe4, 0x81, 0xc9, 0xa7, 0x31, 0x69, 0x17, 0x3d, 0x43, 0x4b, 0x06, 0x27, 0x8c,
+    0x3b, 0x0b, 0x14, 0xef, 0x54, 0x93, 0x0c, 0x87, 0x40, 0x53, 0x83, 0x42, 0xa3, 0x35, 0x17, 0xe7,
+    0x82, 0xb9, 0xf3, 0x96, 0x2b, 0x4b, 0x89, 0xa9, 0x42, 0x86, 0xc7, 0x23, 0x88, 0x04, 0x15, 0x9b,
+    0x7f, 0xa1, 0x83, 0x28, 0x6a, 0x66, 0x44, 0xe9, 0xaf, 0x85, 0x96, 0x46, 0x80, 0x51, 0xf6, 0x6f,
+    0x83, 0xb9, 0x6f, 0xb7, 0x31, 0xeb, 0x82, 0x9e, 0x0e, 0xe4, 0xa2, 0x05, 0x89, 0x05, 0x95, 0x59,
+    0x78, 0xeb, 0x6c, 0xe3, 0x05, 0x6d, 0xb2, 0x81, 0x4f, 0x00, 0x6c, 0xec, 0x0e, 0x95, 0x76, 0x6d,
+    0xf6, 0x58, 0x4f, 0x78, 0x8d, 0x61, 0xc5, 0x34, 0x72, 0xca, 0x56, 0xd3, 0xba, 0x62, 0x6f, 0x7b,
+    0x22, 0x0a, 0xee, 0x43, 0xfb, 0x65, 0x4c, 0xa2, 0xe0, 0x98, 0xcd, 0xcb, 0xc5, 0xba, 0xc4, 0xcd,
+    0x29, 0x2b, 0x1d, 0xee, 0x1a, 0x55, 0x9a, 0x46, 0xe0, 0xdf, 0xcc, 0xda, 0x09, 0xd5, 0xcc, 0x27,
+    0x0b, 0x1a, 0xc8, 0x44, 0x32, 0xf7, 0x94, 0x66, 0x62, 0x87, 0xaa, 0xcb, 0x7b, 0x68, 0xef, 0x56,
+    0x5a, 0xb1, 0x3d, 0x24, 0x84, 0x3c, 0x25, 0x41, 0x1b, 0xcb, 0x04, 0x4c, 0x1d, 0x8c, 0xdc, 0xe4,
+    0x47, 0x77, 0xae, 0x12, 0x84, 0x02, 0xa7, 0x34, 0x98, 0x6b, 0xd9, 0x2d, 0x82, 0x59, 0xfe, 0x67,
+    0xd9, 0x7b, 0x0f, 0xcc, 0xca, 0xfa, 0xe7, 0x1a, 0xdd, 0x4e, 0x43, 0xdc, 0x33, 0x0d, 0x9d, 0x31,
+    0x54, 0x23, 0x74, 0x22, 0x21, 0xad, 0x2a, 0x06, 0xbb, 0x79, 0x6a, 0xb2, 0x06, 0x9d, 0x7e, 0x65,
+    0xc0, 0xa5, 0x05, 0xb0, 0x8d, 0xec, 0x32, 0x8c, 0x75, 0xd4, 0x05, 0xd4, 0x90, 0xe1, 0x72, 0xec,
+    0x3a, 0xf0, 0x04, 0x84, 0x17, 0x74, 0x71, 0x7c, 0x5d, 0xf2, 0x61, 0xf9, 0x7c, 0xfd, 0x6f, 0x2c,
+    0xa6, 0xdc, 0xe7, 0x9e, 0x28, 0x03, 0x2d, 0x80, 0x4c, 0xdd, 0x85, 0xd6, 0x8c, 0x23, 0x6d, 0x8a,
+    0x25, 0x39, 0x44, 0xf5, 0xec, 0x77, 0xbd, 0x73, 0xf2, 0xcc, 0x85, 0x4c, 0xc5, 0xa3, 0x10, 0xe1,
+    0xb7, 0xb4, 0xd1, 0x84, 0xc8, 0x5f, 0xe0, 0x99, 0x7f, 0x2a, 0xbb, 0xda, 0xf8, 0x88, 0xd7, 0x7e,
+    0x69, 0x91, 0x69, 0xb9, 0x81, 0xc8, 0xf5, 0xc3, 0x73, 0x57, 0xaf, 0x7d, 0xc1, 0x94, 0x34, 0x2a,
+    0xdf, 0x3c, 0x82, 0xba, 0x9c, 0x4d, 0xbc, 0x8f, 0xca, 0xcd, 0x59, 0xbe, 0x8a, 0x05, 0x74, 0xde,
+    0x2b, 0xd0, 0xfb, 0x97, 0x2e, 0xc0, 0x0e, 0x6b, 0x00, 0xf7, 0x98, 0xdd, 0x85, 0x95, 0xb4, 0x48,
+    0x92, 0x64, 0xcd, 0xfe, 0xff, 0xdb, 0xd9, 0x31, 0xc9, 0xd4, 0x0e, 0x27, 0xee, 0xaf, 0x38, 0xe3,
+    0x9a, 0xd0, 0xe4, 0xdd, 0x95, 0x77, 0x3c, 0x54, 0xc1, 0xc4, 0x07, 0xc8, 0xff, 0xea, 0x5e, 0x64,
+    0x93, 0x61, 0x4d, 0xfc, 0xa5, 0x07, 0xf9, 0xb1, 0xcc, 0xd4, 0x84, 0xeb, 0x39, 0xd9, 0x9d, 0x7a,
+    0x06, 0xd5, 0x64, 0xff, 0x54, 0x96, 0x50, 0xa0, 0xc4, 0x3f, 0x74, 0x23, 0x85, 0x57, 0xbc, 0x34,
+    0x4a, 0xce, 0xa6, 0x4d, 0xa8, 0xe6, 0xe1, 0x28, 0x25, 0x75, 0xde, 0xf6, 0x8e, 0x6c, 0x7b, 0xbc,
+    0x7a, 0x99, 0x43, 0xb1, 0x54, 0x9a, 0x0e, 0x95, 0x19, 0x52, 0x84, 0x4a, 0x9e, 0xba, 0x3b, 0xf0,
+    0x67, 0x88, 0xce, 0xb2, 0xd3, 0xc4, 0xe6, 0x49, 0xc3, 0xab, 0x32, 0x98, 0xcf, 0x3f, 0x05, 0xf1,
+    0xaa, 0x98, 0xd3, 0xb6, 0x8a, 0xe6, 0xe3, 0xb8, 0x8d, 0x35, 0xc7, 0xdd, 0xb5, 0x04, 0x5c, 0xf9,
+    0x88, 0x0c, 0xa1, 0x8a, 0xb8, 0xff, 0xf9, 0x23, 0xd4, 0x80, 0xe1, 0x30, 0xe8, 0x27, 0x9e, 0x21,
+    0x8b, 0x72, 0x42, 0xbe, 0xe5, 0x65, 0x73, 0xbe, 0x52, 0xcb, 0xe2, 0x4c, 0xa2, 0xc7, 0x77, 0xce,
+    0x7e, 0xe3, 0x02, 0x4a, 0x9f, 0xa4, 0x96, 0x3e, 0x71, 0x65, 0x98, 0x4f, 0x32, 0x85, 0x0c, 0x41,
+    0x71, 0x93, 0x84, 0x23, 0xb6, 0x6d, 0x12, 0x67, 0x13, 0x30, 0x62, 0x02, 0x4d, 0x72, 0x38, 0x00,
+    0x28, 0x47, 0xa1, 0x46, 0x38, 0xac, 0xc2, 0x69, 0x09, 0x7a, 0xe5, 0x5f, 0x10, 0x33, 0x9a, 0xe9,
+    0x60, 0x56, 0xa2, 0xfa, 0x80, 0x58, 0x15, 0x19, 0x77, 0x16, 0xcd, 0x9a, 0xf6, 0x73, 0x9a, 0x6a,
+    0x68, 0xb3, 0x03, 0x62, 0x3e, 0x02, 0x50, 0x27, 0x72, 0x07, 0x3d, 0x40, 0x0d, 0x17, 0x5c, 0x03,
+    0x77, 0xe0, 0xea, 0xc4, 0xec, 0x27, 0x30, 0x6a, 0x99, 0x3a, 0x5b, 0x9a, 0xf7, 0x72, 0x42, 0xcb,
+    0x3a, 0xd8, 0xff, 0x07, 0xea, 0x0b, 0xbb, 0x2e, 0x28, 0xaa, 0xc0, 0x44, 0xf0, 0xac, 0xb1, 0x2b,
+    0x6a, 0x5c, 0x41, 0x04, 0x8e, 0x98, 0x80, 0x39, 0x7a, 0x3b, 0xc0, 0x44, 0x92, 0x38, 0xd0, 0xa0,
+    0x3b, 0x59, 0x8c, 0x05, 0xa7, 0x4e, 0x39, 0xab, 0x6b, 0x0e, 0x6b, 0x26, 0x89, 0x2f, 0x1a, 0x6e,
+    0x41, 0xe7, 0x2a, 0x06, 0xa3, 0x1a, 0x18, 0x6f, 0x79, 0xb9, 0x4b, 0x6f, 0x5b, 0x76, 0x9e, 0x66,
+    0x82, 0x02, 0x91, 0xa5, 0xc0, 0xaa, 0x9a, 0x91, 0x2a, 0x0e, 0x0a, 0x03, 0x72, 0x26, 0xf9, 0x09,
+    0x22, 0x5e, 0x88, 0x69, 0x7b, 0xbe, 0xb7, 0x22, 0x05, 0x58, 0x38, 0x4d, 0xf4, 0x7b, 0xca, 0xc1,
+    0x96, 0xb7, 0x77, 0xd7, 0xa3, 0x47, 0xba, 0xa5, 0xeb, 0xdb, 0xea, 0x33, 0xfd, 0x6a, 0x13, 0x61,
+    0x33, 0x2a, 0xa5, 0x8e, 0xf1, 0xb5, 0xdd, 0xe0, 0x84, 0xb9, 0xbc, 0x3b, 0x7b, 0x37, 0xff, 0xf8,
+    0xc2, 0xe2, 0xdf, 0x9c, 0xbc, 0x7f, 0xd9, 0x73, 0x6a, 0x01, 0xe2, 0x74, 0x8a, 0x10, 0x19, 0x93,
+    0x5c, 0xf2, 0x3d, 0x17, 0xe1, 0xe5, 0x53, 0xae, 0x24, 0x4b, 0x01, 0x11, 0xf1, 0x47, 0x4b, 0xd8,
+    0xc1, 0x04, 0xe3, 0x72, 0x9b, 0x20, 0xb6, 0x2e, 0x3d, 0xc3, 0x13, 0x37, 0xeb, 0x0d, 0xf6, 0x6e,
+    0x85, 0x90, 0x00, 0x99, 0xb2, 0xed, 0x32, 0x77, 0xe0, 0xc3, 0x93, 0x0c, 0xcf, 0x4a, 0x86, 0x73,
+    0x6d, 0x2a, 0xa3, 0x70, 0xfe, 0x83, 0xe8, 0x8b, 0x6e, 0x50, 0xf2, 0xfb, 0xdc, 0xf5, 0x81, 0xa9,
+    0x72, 0x65, 0x4a, 0x96, 0x9c, 0xa3, 0x79, 0x72, 0x55, 0xcc, 0x88, 0x11, 0xa4, 0x9f, 0x92, 0xa9,
+    0x6d, 0xc7, 0x03, 0xe9, 0xff, 0x5f, 0x41, 0xeb, 0xf1, 0x83, 0x19, 0xdd, 0xb2, 0x1b, 0xae, 0xd8,
+    0x8d, 0x9b, 0x38, 0xbe, 0xa3, 0xa7, 0x3e, 0xc1, 0x67, 0x41, 0x69, 0xf8, 0xa2, 0xd1, 0x0a, 0x68,
+    0x79, 0x6a, 0x89, 0x90, 0xee, 0x8b, 0x9b, 0x3e, 0xa9, 0x85, 0x83, 0x1c, 0x29, 0xdd, 0x1e, 0x3a,
+    0xca, 0x1d, 0x27, 0x93, 0x0a, 0x18, 0xa0, 0x29, 0x26, 0x4b, 0x4f, 0xe4, 0xe0, 0x10, 0x90, 0x4a,
+    0x03, 0x6b, 0x55, 0x96, 0xa3, 0xce, 0x19, 0xbb, 0xac, 0x05, 0x03, 0x3e, 0xbe, 0xf2, 0x91, 0x69,
+    0x0b, 0x39, 0x08, 0x6b, 0xa7, 0x9a, 0x38, 0x7f, 0x0d, 0xbc, 0x12, 0xd6, 0x81, 0x0c, 0x06, 0x86,
+    0x93, 0x36, 0xd7, 0xc5, 0x39, 0xbe, 0xec, 0xe3, 0xf2, 0x8a, 0x9d, 0xe1, 0xa8, 0x0e, 0x8f, 0xf8,
+    0x36, 0x28, 0x6b, 0xbc, 0xf4, 0x47, 0xc0, 0xb0, 0xc9, 0x0b, 0xef, 0xd0, 0xe9, 0x1e, 0x10, 0x72,
+    0x2f, 0xcf, 0x29, 0x7a, 0x07, 0x9a, 0x64, 0x52, 0xcc, 0x17, 0x89, 0x1f, 0xc7, 0x2b, 0xa8, 0xa1,
+    0x9b, 0x2a, 0x85, 0x92, 0xac, 0x27, 0x3b, 0x5f, 0x0d, 0xf3, 0x00, 0x3b, 0xde, 0x82, 0x87, 0x80,
+    0x2a, 0x06, 0xa7, 0x86, 0x98, 0xfd, 0xfd, 0x83, 0x18, 0x40, 0x25, 0xc4, 0xce, 0x96, 0x52, 0xfc,
+    0xd3, 0xf0, 0xa4, 0x09, 0xc5, 0x67, 0x77, 0x3e, 0x0c, 0x35, 0xe4, 0x5e, 0x86, 0x93, 0x35, 0xa1,
+    0xa9, 0x0a, 0x25, 0x08, 0xbf, 0xa3, 0x92, 0xbe, 0x53, 0x21, 0xc5, 0x82, 0xcb, 0x45, 0x3f, 0x41,
+    0xa9, 0xf1, 0x07, 0xcb, 0x96, 0x6f, 0x16, 0xe7, 0x8d, 0x51, 0x3e, 0x32, 0x79, 0x7d, 0x66, 0xee,
+    0xe0, 0xc6, 0x97, 0x9b, 0x80, 0x4c, 0x36, 0xa9, 0xb0, 0x20, 0xcc, 0x10, 0xf0, 0x6b, 0xa0, 0xe4,
+    0x50, 0xad, 0xee, 0x46, 0x5c, 0x34, 0xf5, 0xf0, 0x55, 0x17, 0x41, 0x99, 0xda, 0x89, 0xaf, 0xea,
+    0x49, 0x44, 0x07, 0xc2, 0xfb, 0x69, 0xb7, 0x06, 0xe3, 0x7c, 0xaa, 0x84, 0xe4, 0x18, 0x0e, 0xe9,
+    0x77, 0xe6, 0x81, 0x9b, 0x68, 0xd3, 0x42, 0x7b, 0xaf, 0x01, 0xf4, 0x53, 0x69, 0x05, 0x06, 0xf8,
+    0x25, 0x68, 0x4f, 0x57, 0xca, 0x09, 0xbf, 0xae, 0xf2, 0x61, 0x4a, 0xc5, 0xcc, 0x9a, 0xb5, 0x8b,
+    0x52, 0xe7, 0x6c, 0xcb, 0x2a, 0x9a, 0x84, 0xb9, 0x3e, 0xc1, 0xac, 0x5a, 0xc3, 0x5c, 0xb6, 0x0a,
+    0x5b, 0x69, 0xcd, 0xca, 0x87, 0x4c, 0x3d, 0x2b, 0x4d, 0x8b, 0x35, 0x4b, 0xa1, 0x2a, 0xda, 0xf6,
+    0x80, 0x0d, 0x0f, 0xc3, 0x83, 0x18, 0x1c, 0xef, 0xfb, 0x70, 0x91, 0xc6, 0x85, 0x8f, 0xb4, 0x48,
+    0x0f, 0x3b, 0x38, 0x53, 0x3d, 0x42, 0x18, 0x70, 0x8a, 0x82, 0x9e, 0x81, 0xac, 0x8c, 0x4e, 0x11,
+    0x02, 0x5d, 0xac, 0x20, 0x42, 0x8d, 0xee, 0xae, 0x32, 0x43, 0xea, 0x12, 0x01, 0x04, 0x71, 0x72,
+    0xdc, 0x37, 0x0d, 0xca, 0x41, 0x4d, 0x27, 0xef, 0x8c, 0x2c, 0x0c, 0xcc, 0x64, 0x90, 0x2b, 0x8d,
+    0xbf, 0x6b, 0x83, 0xcd, 0x55, 0x56, 0x39, 0x01, 0x69, 0x5f, 0x24, 0x8b, 0x40, 0xe4, 0x2e, 0xf9,
+    0x44, 0xc6, 0x6c, 0x9d, 0x9c, 0x7d, 0xdd, 0xd3, 0x67, 0x26, 0xfd, 0x20, 0xaa, 0x13, 0x72, 0xec,
+    0x26, 0x93, 0x86, 0x97, 0xc1, 0xe7, 0x57, 0x2e, 0x6c, 0xc3, 0x4f, 0x78, 0x69, 0x32, 0xec, 0x3b,
+    0x6f, 0x78, 0x07, 0x9f, 0xbb, 0x27, 0xb2, 0xae, 0x0d, 0x50, 0xca, 0x7f, 0x1a, 0xd6, 0xc6, 0x5d,
+    0xa5, 0x07, 0x04, 0x6c, 0x92, 0xef, 0x36, 0xf7, 0xed, 0xc2, 0xcb, 0x7c, 0x95, 0xb0, 0x74, 0xb7,
+    0x32, 0x66, 0xcd, 0xd7, 0x24, 0x91, 0xe8, 0xb7, 0xcf, 0x00, 0xc3, 0x54, 0xcb, 0x43, 0x8d, 0xfc,
+    0x4d, 0xf2, 0x86, 0x1c, 0x0b, 0x29, 0xd6, 0x63, 0x51, 0x97, 0x61, 0xa9, 0x92, 0x14, 0xd0, 0xb4,
+    0x51, 0xd8, 0x82, 0x90, 0x8b, 0xd2, 0x3b, 0x3b, 0x8d, 0xe1, 0x73, 0x94, 0x73, 0x6d, 0xf5, 0x36,
+    0x23, 0xb3, 0xa3, 0xba, 0x16, 0xf3, 0x07, 0xf3, 0x2c, 0x0a, 0xe5, 0x2c, 0x51, 0x7d, 0x0c, 0x07,
+    0x76, 0xe8, 0x30, 0x9e, 0xce, 0x89, 0x9f, 0xbe, 0x64, 0x28, 0xe4, 0xd4, 0x8e, 0x51, 0x95, 0x7b,
+    0x51, 0x78, 0x8c, 0x11, 0xac, 0x7c, 0xbf, 0x9d, 0xa9, 0x3e, 0xf4, 0x9b, 0xd3, 0xcf, 0x4b, 0x26,
+    0xaf, 0x82, 0x0d, 0x10, 0x83, 0xcc, 0x1d, 0x3b, 0x0f, 0x51, 0x40, 0xd7, 0xa9, 0x1e, 0xfa, 0xe6,
+    0x2b, 0x79, 0x50, 0xf7, 0x87, 0xfd, 0xdf, 0xbb, 0x17, 0xbc, 0x6c, 0x9f, 0x00, 0xc3, 0x7e, 0xbf,
+    0xb0, 0xed, 0x8f, 0x15, 0xc0, 0xc9, 0x9d, 0xb2, 0xe6, 0x16, 0xfe, 0x9e, 0x98, 0x0c, 0xcb, 0xbd,
+    0xb8, 0x5e, 0xb6, 0xeb, 0x40, 0xcd, 0x39, 0x51, 0xc1, 0x1c, 0xed, 0xc9, 0xf8, 0x1c, 0xfd, 0xf5,
+    0x29, 0xab, 0xaa, 0xb3, 0x43, 0x0d, 0x3a, 0xfc, 0xdc, 0x4d, 0xdd, 0x6a, 0x97, 0xaf, 0xe3, 0x75,
+    0x55, 0x33, 0xe9, 0x50, 0xc9, 0x5b, 0x72, 0x1b, 0xaf, 0x19, 0x0e, 0xcd, 0x76, 0x8d, 0x5c, 0xbe,
+    0xc0, 0x5b, 0x37, 0x06, 0xfe, 0x02, 0xf9, 0x23, 0x36, 0xc2, 0xc2, 0x43, 0x00, 0xcc, 0x55, 0xad,
+    0x0a, 0xf2, 0x83, 0x62, 0xf7, 0x96, 0x99, 0x2d, 0x78, 0x90, 0xd9, 0x4e, 0x08, 0xc4, 0x52, 0x90,
+    0x51, 0x14, 0x21, 0x8a, 0x52, 0xf6, 0x1c, 0x63, 0xb0, 0xc3, 0x6c, 0x4d, 0x6a, 0x2d, 0x35, 0x9d,
+    0xd9, 0x73, 0xc2, 0xdc, 0xb1, 0xa5, 0x91, 0xbc, 0x79, 0x91, 0x45, 0x4c, 0xe7, 0x33, 0x30, 0xe0,
+    0x7b, 0x30, 0x82, 0x82, 0xb8, 0xc6, 0x82, 0x24, 0x06, 0x5c, 0xb1, 0xb1, 0x43, 0x66, 0xc7, 0x26,
+    0x6c, 0x12, 0xa2, 0x5a, 0x7c, 0xb6, 0xbf, 0x2a, 0xf5, 0x57, 0xbf, 0x74, 0x8b, 0x70, 0xce, 0x00,
+    0x61, 0x81, 0xfe, 0x00, 0xfb, 0xa7, 0x3e, 0x29, 0x44, 0x5f, 0xf2, 0x04, 0x7c, 0x7f, 0xd4, 0x5a,
+    0xfd, 0x33, 0x3c, 0xa6, 0x96, 0x45, 0x6c, 0xfc, 0xea, 0x59, 0xc5, 0xeb, 0x82, 0xf7, 0xa8, 0x7d,
+    0x7a, 0x8a, 0x0d, 0xf1, 0x3d, 0x35, 0xf3, 0x6c, 0xa6, 0xca, 0xca, 0x4b, 0x37, 0xdf, 0xd4, 0x29,
+    0x82, 0x64, 0xaa, 0x0f, 0x1a, 0xf4, 0x54, 0xe4, 0x90, 0xda, 0xcb, 0x4a, 0x98, 0xde, 0x7d, 0x2b,
+    0x59, 0x08, 0x2b, 0x0c, 0x38, 0xb5, 0x73, 0x4e, 0x37, 0xcb, 0x4a, 0x49, 0xf3, 0x2e, 0x59, 0x67,
+    0x83, 0x61, 0x68, 0x04, 0x74, 0x2d, 0x58, 0x84, 0x93, 0x5b, 0x8a, 0x94, 0xb6, 0xd4, 0x5b, 0x4f,
+    0x7a, 0xb7, 0x69, 0x06, 0xe3, 0xc8, 0xcf, 0x6b, 0x70, 0xec, 0xdf, 0x4b, 0x65, 0x45, 0xae, 0x7d,
+    0x6f, 0xf4, 0x0d, 0x31, 0xb2, 0x7b, 0x78, 0x78, 0x22, 0x49, 0x37, 0xe2, 0x7d, 0x85, 0x23, 0x98,
+    0xd6, 0xba, 0x0e, 0x85, 0xa3, 0x47, 0xda, 0xd3, 0x93, 0x33, 0x3f, 0xc5, 0x13, 0x37, 0x2f, 0xf5,
+    0x9f, 0x68, 0x2a, 0x86, 0xb3, 0x7a, 0x38, 0xd4, 0xcc, 0x89, 0x34, 0xec, 0xce, 0x43, 0xeb, 0x2d,
+    0x9f, 0x7f, 0xdf, 0xef, 0xfb, 0xf7, 0x04, 0x93, 0x14, 0xa0, 0xe2, 0x33, 0xe6, 0xa4, 0xef, 0x32,
+    0xcc, 0xc7, 0x54, 0xee, 0x3f, 0xbc, 0x15, 0x37, 0x1c, 0xb0, 0x61, 0x51, 0xb0, 0xd6, 0x8e, 0xf0,
+    0xfa, 0x03, 0x8e, 0x01, 0x16, 0x7f, 0x4c, 0x03, 0x04, 0x25, 0x2d, 0x8b, 0xb8, 0x4c, 0x72, 0x56,
+    0xf2, 0x6e, 0x5e, 0x15, 0xa9, 0xc2, 0x12, 0xbe, 0x9d, 0xef, 0x64, 0xd2, 0x8a, 0x46, 0x75, 0xfe,
+    0x57, 0xcf, 0x5a, 0xb9, 0x65, 0xfc, 0xae, 0x85, 0x41, 0xde, 0x52, 0x15, 0xb6, 0xe6, 0x71, 0x47,
+    0x72, 0xe8, 0x41, 0xea, 0x5f, 0xd4, 0x58, 0xc4, 0xd2, 0x12, 0xcf, 0xd5, 0x7c, 0x87, 0x51, 0xa6,
+    0x52, 0xf1, 0x01, 0xe9, 0x05, 0x8a, 0x1e, 0x9d, 0x35, 0xe2, 0xe3, 0xdd, 0xeb, 0x44, 0x8e, 0xd9,
+    0xb6, 0xae, 0xdb, 0xa8, 0x8d, 0xa6, 0xcb, 0xb6, 0x25, 0xd6, 0x80, 0xae, 0xa3, 0xf2, 0x72, 0x13,
+    0xd2, 0xc8, 0x2e, 0xf4, 0xdf, 0xd8, 0xdf, 0x28, 0x5e, 0x5b, 0xec, 0x85, 0xc4, 0xb3, 0x93, 0x1c,
+    0xf1, 0x1a, 0x07, 0x91, 0x98, 0x39, 0xd2, 0x7d, 0x26, 0x88, 0x6a, 0xf6, 0x3e, 0xce, 0x1b, 0x4d,
+    0x9c, 0x76, 0x57, 0xe5, 0x7d, 0xa9, 0x51, 0x19, 0x45, 0xa2, 0x03, 0x3e, 0xaf, 0x9d, 0xf9, 0xd5,
+    0xcf, 0xce, 0xdc, 0xe4, 0xb1, 0x3d, 0xd3, 0x78, 0xbf, 0xcb, 0x8b, 0x6f, 0x5f, 0xf6, 0xd7, 0xfb,
+    0xfd, 0x70, 0xd9, 0xe9, 0xbe, 0x33, 0xd3, 0xad, 0x2e, 0xcf, 0x09, 0xd7, 0xfe, 0xea, 0xdb, 0x83,
+    0xe3, 0xff, 0x2d, 0x41, 0xf0, 0xe1, 0xe5, 0xe0, 0x26, 0x8a, 0xc7, 0x52, 0xa5, 0xdb, 0xda, 0xdc,
+    0x52, 0xf7, 0x9a, 0x5c, 0x95, 0x32, 0x4d, 0x52, 0x2f, 0xce, 0x89, 0x7e, 0xb7, 0xee, 0x7b, 0x73,
+    0x3f, 0x5d, 0x7a, 0xc2, 0xd5, 0xdf, 0x08, 0x92, 0xeb, 0xe9, 0x48, 0x59, 0x0b, 0x0e, 0x7f, 0xd2,
+    0x40, 0xa2, 0x26, 0x00, 0x00, 0x74, 0x76, 0x84, 0x48, 0xa0, 0x6a, 0xa0, 0x9c, 0x44, 0xab, 0xa2,
+    0x10, 0x42, 0x0d, 0x8e, 0xf2, 0x54, 0x69, 0x0e, 0x32, 0x3a, 0xe6, 0xc7, 0xc6, 0x30, 0xb4, 0x62,
+    0x59, 0x81, 0xa6, 0x8a, 0xdf, 0x00, 0x35, 0x7d, 0xf1, 0x7d, 0x2c, 0xcf, 0x98, 0x4c, 0xb4, 0xea,
+    0xf6, 0xfd, 0x83, 0x5f, 0x09, 0x65, 0xf7, 0x87, 0x69, 0x73, 0x64, 0x49, 0x98, 0xb3, 0x4c, 0x80,
+    0xa5, 0xbd, 0x65, 0x8a, 0x3a, 0xba, 0x12, 0xe6, 0xe3, 0x91, 0x32, 0xc0, 0xdb, 0xf9, 0x72, 0x30,
+    0x4d, 0xea, 0x01, 0xb9, 0x1e, 0xa6, 0x1f, 0xaa, 0xed, 0x4d, 0x7f, 0x10, 0x28, 0x6d, 0x79, 0x68,
+    0x76, 0xb0, 0x02, 0x0d, 0x4a, 0xeb, 0x14, 0xae, 0xdf, 0x59, 0xf2, 0x73, 0xa1, 0x78, 0xfc, 0x72,
+    0xbd, 0x43, 0x24, 0x8c, 0xd3, 0xbf, 0xd1, 0x68, 0x68, 0x77, 0x5a, 0xa2, 0x99, 0x74, 0x56, 0xe8,
+    0x80, 0x88, 0x2e, 0xc4, 0xdc, 0x09, 0x38, 0x07, 0xed, 0xc8, 0xce, 0x80, 0xb0, 0xcc, 0x7f, 0x88,
+    0x23, 0x0a, 0xae, 0x8f, 0x8e, 0x5d, 0xbc, 0xe8, 0x5a, 0x9f, 0x2d, 0x8b, 0x9e, 0x7c, 0xfc, 0x6e,
+    0x19, 0xe9, 0x0e, 0x82, 0x07, 0x70, 0x3f, 0xac, 0xfc, 0xaf, 0x19, 0x6f, 0x73, 0x64, 0x1e, 0xec,
+    0xff, 0xab, 0x8b, 0x67, 0x95, 0x32, 0xf5, 0x5a, 0x95, 0x47, 0xcd, 0xcb, 0xbf, 0x5d, 0x71, 0xe6,
+    0x48, 0xce, 0x97, 0x0a, 0x22, 0x10, 0xcb, 0xee, 0x2d, 0x2a, 0x3d, 0xf8, 0x46, 0x8c, 0xdc, 0xc8,
+    0x7b, 0x45, 0x37, 0x19, 0x49, 0x76, 0xc3, 0x9c, 0xba, 0x20, 0x91, 0x76, 0xc2, 0x81, 0xd2, 0x6b,
+    0x43, 0xf4, 0xaa, 0x5a, 0x49, 0x3a, 0x1e, 0xb1, 0xc4, 0x42, 0x3a, 0xdf, 0xdb, 0x0d, 0x29, 0x8b,
+    0xfa, 0x40, 0xb3, 0xdb, 0xc8, 0x73, 0x47, 0xde, 0x73, 0x83, 0x5f, 0x3a, 0xbb, 0x01, 0xbe, 0xeb,
+    0xdb, 0x7d, 0xdb, 0x96, 0xda, 0x81, 0x10, 0xc5, 0x4a, 0xa5, 0xc5, 0x91, 0xcc, 0x46, 0x78, 0xb2,
+    0xb7, 0x6d, 0xda, 0x6e, 0xe4, 0x6e, 0xa9, 0x4a, 0x04, 0x82, 0x76, 0x7e, 0x94, 0xd4, 0x56, 0x71,
+    0xf1, 0xdb, 0xa2, 0x7e, 0x33, 0xa9, 0xd0, 0x09, 0x4d, 0x21, 0x6c, 0x9e, 0x98, 0x35, 0x76, 0xd6,
+    0xd2, 0x11, 0x8b, 0x99, 0x3d, 0x6b, 0x25, 0xf2, 0x9d, 0xc1, 0x87, 0xd5, 0x09, 0xd5, 0x94, 0xf1,
+    0x5a, 0xfb, 0x46, 0x99, 0x77, 0xb6, 0xb6, 0xa2, 0x78, 0x99, 0xc7, 0x5e, 0x24, 0x5e, 0x9d, 0x90,
+    0x3e, 0x2d, 0xcc, 0x44, 0xcf, 0xe9, 0x0f, 0x60, 0x72, 0x90, 0x26, 0x95, 0x94, 0xf0, 0xf4, 0x91,
+    0x1b, 0xfe, 0x4f, 0x07, 0xad, 0x5e, 0xb0, 0xca, 0x0a, 0x01, 0x64, 0xd2, 0xcd, 0x19, 0x0b, 0x2f,
+    0xc1, 0xa0, 0xdb, 0x11, 0xfc, 0x53, 0x76, 0xb1, 0x05, 0xb5, 0xed, 0x99, 0x85, 0x75, 0x7f, 0xdb,
+    0xe6, 0xdd, 0x59, 0x67, 0x19, 0xb7, 0xd7, 0xfc, 0x48, 0xad, 0xcd, 0x99, 0xee, 0x7c, 0x7a, 0xc4,
+    0x7e, 0x8c, 0xcc, 0x96, 0x3e, 0xec, 0xbf, 0x9d, 0xc1, 0xc8, 0x07, 0x9a, 0x86, 0x44, 0xd1, 0xf4,
+    0xd8, 0x74, 0x53, 0x9c, 0x9d, 0x33, 0x57, 0xde, 0x09, 0x0e, 0x8c, 0xfa, 0xea, 0x2d, 0x74, 0xf6,
+    0x9b, 0x79, 0x2f, 0x98, 0x87, 0x7d, 0x11, 0xb4, 0xc4, 0xc8, 0xc7, 0x2a, 0xc0, 0xf8, 0x3f, 0xff,
+    0x26, 0xb9, 0x5a, 0x15, 0x26, 0x85, 0x4c, 0xfe, 0xc1, 0x6e, 0xbb, 0x76, 0xce, 0xfe, 0xdd, 0xf7,
+    0x7d, 0xa9, 0x13, 0x3c, 0xf8, 0xe3, 0xd4, 0x4c, 0xbe, 0xa4, 0x31, 0xdb, 0xc6, 0xee, 0xdc, 0xf9,
+    0x47, 0x59, 0x2e, 0x96, 0x4a, 0xe8, 0xdd, 0xbc, 0xa8, 0xeb, 0x99, 0x5e, 0x80, 0x6d, 0x76, 0xf2,
+    0xf8, 0x20, 0x46, 0xce, 0xd5, 0x6e, 0xcb, 0x10, 0x77, 0x5c, 0x8c, 0xff, 0x89, 0xdb, 0x7d, 0xb7,
+    0xcc, 0x62, 0x43, 0xdf, 0xff, 0x43, 0xd2, 0x22, 0xd0, 0x7e, 0x44, 0xbb, 0xe8, 0x46, 0x13, 0x1f,
+    0x70, 0x72, 0x42, 0x7e, 0xa8, 0xd4, 0x6d, 0x63, 0x78, 0x70, 0x6f, 0xca, 0x58, 0x6a, 0x83, 0x6c,
+    0x79, 0x63, 0xc3, 0xbd, 0xba, 0x75, 0x10, 0xa4, 0x38, 0xa5, 0x15, 0x86, 0xe9, 0xa7, 0xd5, 0x08,
+    0x71, 0x73, 0xc2, 0xec, 0xa4, 0x95, 0x30, 0x82, 0x1d, 0xd3, 0x43, 0x4b, 0xd3, 0xda, 0x72, 0x6e,
+    0x45, 0xdd, 0xdb, 0xf9, 0x3f, 0xbb, 0xed, 0xdb, 0x5a, 0x61, 0xe1, 0x4a, 0x2f, 0x9b, 0xad, 0x9b,
+    0x73, 0x80, 0x0f, 0x89, 0x37, 0xab, 0xec, 0xda, 0xee, 0x12, 0xb4, 0x43, 0x27, 0x8b, 0xac, 0x9a,
+    0x6e, 0x1b, 0x77, 0x9a, 0x3e, 0xba, 0x6d, 0xd9, 0x39, 0x45, 0x40, 0x4e, 0x2e, 0x9a, 0x2d, 0x99,
+    0x9d, 0xf4, 0xc0, 0x0b, 0x36, 0xaa, 0x6c, 0xd8, 0x51, 0x46, 0x62, 0x2b, 0x26, 0x8a, 0x2c, 0x98,
+    0x7a, 0x8a, 0x0d, 0x42, 0xd6, 0xff, 0x9c, 0xa5, 0xa6, 0x5a, 0xeb, 0xb3, 0xd8, 0xdb, 0xfb, 0x6e,
+    0x32, 0xc8, 0xf2, 0x06, 0xb2, 0xe7, 0x9b, 0x0d, 0x7a, 0x78, 0xe5, 0xc2, 0xf9, 0x5e, 0x1a, 0x16,
+    0x3b, 0xd9, 0x7f, 0x05, 0xd5, 0xad, 0x73, 0x4e, 0xc4, 0xad, 0x1d, 0x67, 0x1b, 0xe9, 0xde, 0xb6,
+    0x33, 0xc9, 0x36, 0x04, 0xa3, 0x7f, 0x2e, 0x4e, 0x1f, 0xdb, 0xed, 0xdf, 0xe3, 0x5f, 0x9a, 0x84,
+    0xbd, 0xca, 0x0f, 0xe7, 0x3d, 0xb3, 0xe5, 0xd3, 0xb1, 0x2f, 0x94, 0x44, 0x2d, 0x93, 0xa5, 0x93,
+    0x32, 0x23, 0x89, 0x45, 0x35, 0xa3, 0xe4, 0xd2, 0xf6, 0xb8, 0xe8, 0x0c, 0x25, 0x83, 0xa4, 0x92,
+    0x7b, 0x99, 0xf4, 0xf6, 0x3c, 0xb2, 0x65, 0xd1, 0xd7, 0xae, 0x4a, 0x6e, 0x2c, 0x92, 0x25, 0x91,
+    0xd7, 0xbb, 0xaf, 0x09, 0x34, 0xa2, 0x64, 0xd0, 0x63, 0xa9, 0x3c, 0x40, 0x24, 0x82, 0x24, 0x90,
+    0x05, 0x62, 0xa2, 0x13, 0xfc, 0xa3, 0xd1, 0x3f, 0xac, 0x12, 0x62, 0x3d, 0xce, 0xde, 0xd3, 0x76,
+    0x04, 0xb5, 0x80, 0x9b, 0x27, 0x5e, 0xb4, 0xc4, 0x45, 0xae, 0xc4, 0xee, 0xe4, 0x93, 0x12, 0x2c,
+    0x82, 0xf3, 0x03, 0x14, 0x45, 0x47, 0xb0, 0x70, 0x2f, 0x49, 0x34, 0x1d, 0x36, 0xfb, 0x93, 0xae,
+    0xf3, 0x73, 0x85, 0xee, 0x4d, 0xce, 0x0b, 0x71, 0x0b, 0x10, 0x0a, 0x17, 0xe5, 0x37, 0x25, 0xbd,
+    0x4c, 0x76, 0x83, 0x9e, 0x3b, 0x3b, 0xcd, 0xcb, 0xfb, 0xc4, 0xe0, 0x57, 0x2b, 0x1b, 0x8d, 0x8b,
+    0xcb, 0x80, 0x22, 0x1a, 0x33, 0x2b, 0xcc, 0xca, 0x24, 0x92, 0x20, 0x8a, 0x23, 0x0b, 0x8c, 0x8a,
+    0xbe, 0x23, 0x03, 0x9c, 0x3a, 0x3a, 0x4d, 0xc9, 0xa1, 0x83, 0xa3, 0x76, 0x2a, 0x1a, 0x0d, 0x89,
+    0x2d, 0x91, 0x41, 0xca, 0x32, 0x2a, 0x4c, 0xc8, 0x25, 0xd5, 0x61, 0x5f, 0x22, 0x0a, 0x0c, 0x88,
+    0x44, 0xe8, 0x2a, 0x98, 0x2a, 0x1b, 0x3e, 0x44, 0x2c, 0x19, 0x4a, 0xf7, 0xcc, 0xf2, 0xdb, 0x1d,
+    0xda, 0xea, 0x8a, 0x1f, 0xee, 0xd8, 0x0f, 0xb4, 0x60, 0xbe, 0x88, 0xda, 0x3d, 0x7c, 0x1a, 0xa5,
+    0x5f, 0xc1, 0x2a, 0x12, 0x7c, 0x09, 0x75, 0xb5, 0xb3, 0xcb, 0x88, 0x50, 0xcd, 0xc2, 0x5b, 0x7c,
+    0x07, 0xbe, 0x0a, 0xe0, 0xf7, 0xba, 0xf9, 0x34, 0xbe, 0x4a, 0x65, 0x56, 0xe7, 0x9a, 0x9a, 0x82,
+    0x3e, 0xef, 0xd7, 0x13, 0x39, 0x33, 0xc5, 0xc3, 0xa2, 0x8a, 0x95, 0xd1, 0x29, 0x13, 0x85, 0x83,
+    0x76, 0x26, 0xa9, 0x39, 0x31, 0x23, 0xc4, 0xc2, 0x64, 0x03, 0x98, 0xa6, 0x21, 0x03, 0x84, 0x82,
+    0xd7, 0x4b, 0x22, 0x69, 0x38, 0x32, 0x45, 0xc1, 0x2f, 0x96, 0x49, 0x1f, 0x28, 0x12, 0x05, 0x81,
+    0xbe, 0xbb, 0x50, 0xa2, 0x30, 0x22, 0x44, 0xc0, 0x5b, 0x7d, 0x3a, 0xa7, 0x20, 0x02, 0x04, 0x80,
+    0x18, 0xd2, 0xeb, 0x8f, 0x98, 0x3b, 0xff, 0xe4, 0x60, 0x39, 0x6e, 0x4d, 0xc8, 0xa4, 0x51, 0xd9,
+    0x62, 0xe9, 0xa6, 0x8c, 0x97, 0xf4, 0x97, 0x85, 0x9b, 0x54, 0xbe, 0x30, 0x72, 0xb2, 0x80, 0x77,
+    0x41, 0x43, 0x8a, 0x8f, 0x1a, 0xab, 0x7f, 0xc6, 0x68, 0x3d, 0x63, 0xd9, 0x8b, 0xc5, 0x56, 0xaa,
+    0x63, 0xfc, 0x26, 0x85, 0x85, 0x75, 0xd5, 0xac, 0xf9, 0x78, 0xe2, 0xce, 0x0d, 0xb3, 0x00, 0x75,
+    0x68, 0xe5, 0xe7, 0x8b, 0x1f, 0xb9, 0xe9, 0x5b, 0x48, 0xb2, 0xbd, 0xcb, 0x0f, 0x99, 0xa9, 0x1b,
+    0x62, 0x53, 0xa4, 0x88, 0x17, 0xa9, 0xe8, 0x5a, 0x00, 0x10, 0x06, 0x85, 0x07, 0x89, 0xa8, 0x1a,
+    0x01, 0x03, 0x20, 0x8b, 0x1e, 0xb8, 0x69, 0x59, 0xe1, 0x01, 0x87, 0xe6, 0x0e, 0x98, 0x29, 0x19,
+    0x23, 0x4e, 0xc6, 0x82, 0x16, 0xa8, 0x68, 0x58, 0x01, 0x11, 0x86, 0x47, 0x06, 0x88, 0x28, 0x18,
+    0x72, 0x17, 0x6f, 0xa8, 0xfa, 0x59, 0x9e, 0x8c, 0x49, 0xda, 0x4f, 0x79, 0x06, 0xaa, 0x91, 0x31,
+    0xdd, 0x16, 0xfe, 0x8f, 0x8a, 0xa1, 0x39, 0xaf, 0x9b, 0xc9, 0xc1, 0x54, 0x2a, 0xbc, 0x89, 0xa3,
+    0x5b, 0x79, 0x73, 0x7a, 0x8b, 0x6d, 0xdc, 0xa5, 0x4d, 0x2d, 0x2d, 0x49, 0xb3, 0x2f, 0xdc, 0xea,
+    0x23, 0x3e, 0x2c, 0x03, 0x0b, 0x8c, 0xfe, 0xa5, 0x43, 0x5d, 0x8d, 0x84, 0xe1, 0x61, 0x7e, 0x8e,
+    0x1a, 0xc8, 0x0f, 0x8b, 0x1d, 0xb1, 0xe1, 0x53, 0x0a, 0x4e, 0xaf, 0x53, 0x0d, 0x91, 0xa1, 0x13,
+    0x12, 0x7e, 0x8d, 0x85, 0x15, 0xa1, 0xe0, 0x52, 0x42, 0x42, 0xbc, 0x70, 0x05, 0x81, 0xa0, 0x12,
+    0xd8, 0xa9, 0x22, 0x73, 0x1c, 0xb0, 0x61, 0x51, 0x34, 0xef, 0x57, 0xc5, 0x0c, 0x90, 0x21, 0x11,
+    0x9d, 0x29, 0x2c, 0x89, 0x14, 0xa0, 0x60, 0x50, 0x23, 0x8d, 0x12, 0x52, 0x04, 0x80, 0x20, 0x10,
+    0xa7, 0x80, 0x02, 0x96, 0x64, 0xd8, 0xd9, 0x1b, 0x4f, 0x26, 0xfd, 0xdb, 0xcc, 0x82, 0xdf, 0xf7,
+    0x4c, 0xd6, 0x18, 0x11, 0xcc, 0xd6, 0x92, 0x3a, 0xc4, 0xd4, 0x87, 0xd3, 0x04, 0xfb, 0xdf, 0x54,
+    0xad, 0x42, 0x45, 0x9d, 0xd4, 0x9e, 0x31, 0xa7, 0x0e, 0x41, 0x41, 0x52, 0x7b, 0x59, 0x1b, 0x4f,
+    0x55, 0x11, 0xa0, 0x1a, 0xa9, 0x75, 0x19, 0xbc, 0xd0, 0x97, 0x35, 0xd0, 0xb6, 0x8b, 0x35, 0xb6,
+    0x9b, 0x40, 0xa2, 0xa9, 0x1b, 0x39, 0xc9, 0x4b, 0xe4, 0x60, 0x67, 0xb9, 0x0b, 0x19, 0x89, 0x0b,
+    0xd3, 0x30, 0x58, 0xb5, 0x13, 0x29, 0xc8, 0x4a, 0x55, 0xf2, 0x43, 0x94, 0x03, 0x09, 0x88, 0x0a,
+    0xde, 0x21, 0x55, 0xf3, 0x1a, 0x38, 0x49, 0x49, 0xca, 0x01, 0xc2, 0x96, 0x0a, 0x18, 0x09, 0x09,
+    0xed, 0x89, 0xfa, 0x9b, 0x12, 0x28, 0x48, 0x48, 0xed, 0x0c, 0x18, 0x28, 0x02, 0x08, 0x08, 0x08,
+    0x1c, 0x68, 0xae, 0xd0, 0x0e, 0xb0, 0xbb, 0xcd, 0x11, 0x0b, 0x8d, 0xde, 0x61, 0x4c, 0x2f, 0x5a,
+    0x32, 0x78, 0xf0, 0x24, 0x84, 0xba, 0xbf, 0xb1, 0x46, 0x38, 0xe5, 0xd5, 0x34, 0xf2, 0x9c, 0x54,
+    0xec, 0x69, 0x2e, 0xd2, 0x4f, 0xb5, 0xba, 0xe6, 0x13, 0xe9, 0x4f, 0xbf, 0xe6, 0xc8, 0x8a, 0xc2,
+    0x80, 0xc5, 0x5c, 0x47, 0x6b, 0xfd, 0xfe, 0x04, 0x07, 0x41, 0x41, 0xd6, 0xac, 0x09, 0x7c, 0x65,
+    0x0e, 0x3b, 0xad, 0x8e, 0x19, 0x31, 0xc1, 0x43, 0x89, 0x15, 0x91, 0x23, 0x09, 0x11, 0x81, 0x03,
+    0x66, 0x7d, 0xce, 0x92, 0x11, 0x21, 0xc0, 0x42, 0x81, 0x05, 0x90, 0x22, 0x01, 0x01, 0x80, 0x02,
+    0xa7, 0x95, 0x7b, 0x98, 0x18, 0x30, 0x41, 0x41, 0x88, 0x14, 0x11, 0x21, 0x08, 0x10, 0x01, 0x01,
+    0x0f, 0x9a, 0x23, 0x92, 0x10, 0x20, 0x40, 0x40, 0x80, 0x04, 0x10, 0x20, 0x00, 0x00, 0x54, 0x3c,
+};
+
+unsigned char hotknot_transfer_fw[] = {
+};
+
+unsigned char hotknot_auth_fw[] = {
+    0xa8, 0x3f, 0x06, 0xee, 0xd9, 0x50, 0xf5, 0xbf, 0xb9, 0xc2, 0xec, 0x5c, 0x94, 0x2c, 0xd0, 0xc0,
+    0x56, 0x1b, 0x01, 0xaa, 0xea, 0x04, 0xe0, 0xa8, 0x36, 0x37, 0xd4, 0xbf, 0x33, 0xfe, 0xea, 0x9e,
+    0x7b, 0xf0, 0x20, 0x46, 0x80, 0x73, 0x6b, 0x4e, 0x3f, 0x27, 0x51, 0x1e, 0x3d, 0x80, 0x05, 0x01,
+    0x2d, 0xee, 0x85, 0x0d, 0xa9, 0x87, 0x11, 0x29, 0x24, 0xef, 0x2c, 0x47, 0xc0, 0x75, 0x24, 0xac,
+    0x41, 0xb6, 0x31, 0x8c, 0x3f, 0xa3, 0x95, 0x98, 0x50, 0xe2, 0x51, 0x2d, 0x9a, 0xcb, 0x14, 0x6e,
+    0xb7, 0x17, 0xc1, 0x85, 0x2e, 0x04, 0x5d, 0xa9, 0xc5, 0x0d, 0x8a, 0x46, 0x59, 0x69, 0x13, 0x55,
+    0xfb, 0xbf, 0x92, 0xcb, 0xc2, 0xc0, 0x63, 0xdc, 0x0a, 0x94, 0xfd, 0x09, 0x76, 0x5c, 0xd2, 0xc6,
+    0xf2, 0x21, 0x03, 0x81, 0x7f, 0xa9, 0xe9, 0xae, 0x5d, 0x04, 0xff, 0x98, 0x5a, 0x70, 0xc3, 0xd7,
+    0x09, 0x0c, 0xd3, 0x53, 0xc4, 0x88, 0x83, 0x2a, 0xe1, 0x36, 0x78, 0xbc, 0x93, 0x53, 0xbf, 0x04,
+    0x30, 0x9f, 0xa5, 0x01, 0xa2, 0x98, 0x82, 0x58, 0xe0, 0x30, 0xb0, 0x86, 0xbe, 0x7c, 0x70, 0x7b,
+    0x39, 0x8e, 0x24, 0x15, 0xbb, 0xf6, 0x7d, 0xab, 0x06, 0xc1, 0xba, 0xd7, 0x28, 0x5d, 0x58, 0xec,
+    0x8f, 0xef, 0x09, 0x2b, 0xb4, 0xff, 0xdd, 0xe6, 0x42, 0x79, 0xae, 0x4b, 0x21, 0x4d, 0xd1, 0xa4,
+    0x62, 0x88, 0x0b, 0x17, 0x8d, 0xc5, 0x35, 0x25, 0xbc, 0x47, 0x2d, 0x10, 0x52, 0x79, 0x0a, 0x4c,
+    0x0b, 0x2e, 0x7d, 0xd2, 0x5b, 0xde, 0x8b, 0xe5, 0x17, 0x2d, 0xe8, 0xf8, 0xb5, 0xd1, 0xd9, 0x65,
+    0xcf, 0x3f, 0xf6, 0xf1, 0xe7, 0x10, 0x49, 0x6f, 0xf3, 0x22, 0xb1, 0x11, 0x51, 0x60, 0xda, 0x2c,
+    0xe7, 0x26, 0xb8, 0xbc, 0x70, 0xf7, 0xd9, 0xf1, 0x31, 0x5f, 0x37, 0xd9, 0x1b, 0x1f, 0x98, 0x80,
+    0xeb, 0xf2, 0xa0, 0x60, 0x7b, 0x06, 0xb8, 0x1c, 0x15, 0x54, 0xe3, 0x54, 0x8e, 0x24, 0x21, 0x7b,
+    0x4c, 0xb0, 0x20, 0x15, 0xec, 0x97, 0xf0, 0x73, 0x1c, 0xb8, 0x06, 0x5e, 0x5c, 0x7e, 0xc0, 0x77,
+    0x01, 0x85, 0xe0, 0x02, 0x45, 0x4f, 0x01, 0xcb, 0x93, 0x49, 0x96, 0x99, 0x43, 0x27, 0x78, 0x7e,
+    0x6d, 0x57, 0xcc, 0x9e, 0xe4, 0xe7, 0x33, 0x17, 0x44, 0x09, 0x04, 0xac, 0xb9, 0xe7, 0x52, 0x75,
+    0x51, 0xfd, 0xc9, 0x50, 0x1d, 0xfa, 0x22, 0x63, 0xc2, 0x46, 0x09, 0x64, 0xab, 0x06, 0xf0, 0x3c,
+    0xe8, 0xab, 0x80, 0xd5, 0x7e, 0x66, 0xf6, 0x28, 0xc7, 0x3c, 0xc3, 0x1f, 0xa4, 0x76, 0x72, 0x10,
+    0x7b, 0xe9, 0xd4, 0xb9, 0x9c, 0xf4, 0xc6, 0xa4, 0xf1, 0xd9, 0xf4, 0x24, 0xc7, 0x97, 0x51, 0x13,
+    0xf7, 0x59, 0x80, 0x50, 0xa2, 0x25, 0xed, 0x4f, 0x88, 0x27, 0x4d, 0x66, 0xdf, 0x17, 0x71, 0x7f,
+    0xdd, 0x89, 0xa6, 0x11, 0xa8, 0x6e, 0xba, 0x1c, 0x17, 0xde, 0x5b, 0x10, 0xb2, 0xef, 0x7e, 0x66,
+    0xd9, 0x38, 0xc0, 0x29, 0xee, 0x9f, 0xfc, 0x36, 0xe4, 0x3c, 0xf2, 0x7d, 0x5e, 0x76, 0x98, 0x7f,
+    0x74, 0xae, 0x57, 0x90, 0x2b, 0x09, 0x2b, 0x27, 0xb8, 0x5f, 0xf8, 0xa7, 0xae, 0x2f, 0x70, 0xd6,
+    0x45, 0x04, 0x5e, 0x96, 0xef, 0x9e, 0x38, 0x79, 0xb3, 0x51, 0x97, 0x9d, 0xbb, 0xeb, 0x5a, 0x7d,
+    0xc4, 0xca, 0xd6, 0x07, 0xb1, 0xc3, 0xae, 0x37, 0xea, 0xd5, 0xaa, 0x36, 0x42, 0x8e, 0x3b, 0x6c,
+    0xb4, 0x50, 0xca, 0xde, 0x4a, 0x2a, 0x6f, 0x14, 0x25, 0x5b, 0x74, 0x04, 0xa6, 0x7e, 0x7e, 0x06,
+    0xcb, 0x39, 0xea, 0xdf, 0x14, 0x7e, 0xdf, 0x26, 0x3b, 0xe9, 0x13, 0x5f, 0xaf, 0x8f, 0xb9, 0x91,
+    0xb5, 0xd8, 0x30, 0x04, 0x99, 0x08, 0x01, 0xfb, 0xf2, 0x47, 0xd1, 0x07, 0x85, 0xfc, 0x58, 0x79,
+    0xd8, 0x0a, 0xdb, 0x0f, 0xe1, 0xe6, 0xcf, 0x60, 0x31, 0xd6, 0x4c, 0x5d, 0xb1, 0x50, 0x35, 0x92,
+    0x9c, 0xf8, 0x46, 0x61, 0x12, 0xf8, 0x05, 0x6c, 0x01, 0x52, 0x4f, 0x40, 0x05, 0xa4, 0x47, 0xbc,
+    0x01, 0x2a, 0x65, 0xe4, 0x81, 0xc9, 0xa7, 0x31, 0x69, 0x17, 0x3d, 0x43, 0x4b, 0x06, 0x27, 0x8c,
+    0x3b, 0x0b, 0x14, 0xef, 0x54, 0x93, 0x0e, 0x87, 0x40, 0x53, 0x83, 0x42, 0xa3, 0x35, 0x17, 0xe7,
+    0x82, 0xb9, 0xf3, 0x96, 0x2b, 0x4b, 0x89, 0xa9, 0x42, 0x86, 0xc7, 0x23, 0x88, 0x04, 0x15, 0x9b,
+    0x7f, 0xa1, 0x83, 0x28, 0x6a, 0x66, 0x44, 0xe9, 0xaf, 0x85, 0x96, 0x46, 0x80, 0x51, 0xf6, 0x6f,
+    0x83, 0xb9, 0x6f, 0xb7, 0x31, 0xeb, 0x82, 0x9e, 0x0e, 0xe4, 0xa2, 0x05, 0x89, 0x05, 0x95, 0x59,
+    0x78, 0xeb, 0x6c, 0xe3, 0x05, 0x6d, 0xb2, 0x81, 0x4f, 0x00, 0x6c, 0xec, 0x0e, 0x95, 0x76, 0x6d,
+    0xf6, 0x58, 0x4f, 0x78, 0x8d, 0x61, 0xc5, 0x34, 0x72, 0xca, 0x56, 0xd3, 0xba, 0x62, 0x6f, 0x7b,
+    0x22, 0x0a, 0xee, 0x43, 0xfb, 0x65, 0x4c, 0xa2, 0xe0, 0x98, 0xcd, 0xcb, 0xc5, 0xba, 0xc6, 0xcd,
+    0x29, 0x2b, 0x1d, 0xee, 0x1a, 0x55, 0x9a, 0x44, 0xe0, 0xdf, 0xcc, 0xda, 0x09, 0xd5, 0xcc, 0x27,
+    0x0b, 0x1a, 0xc8, 0x44, 0x32, 0xf7, 0x94, 0x66, 0x62, 0x87, 0xaa, 0xcb, 0x7b, 0xe8, 0xef, 0x56,
+    0x5a, 0xb1, 0x3d, 0x24, 0x84, 0x3c, 0x25, 0x41, 0x1b, 0xcb, 0x04, 0x4c, 0x1d, 0x8c, 0xdc, 0xe4,
+    0x07, 0x77, 0xae, 0x12, 0x84, 0x02, 0xa7, 0x34, 0x98, 0x6b, 0xd9, 0x2d, 0x82, 0x59, 0xfe, 0x67,
+    0xd9, 0x7b, 0x0f, 0xcc, 0xca, 0xfa, 0xe7, 0x1a, 0xdd, 0x4e, 0x43, 0xdc, 0x33, 0x0d, 0x9d, 0x31,
+    0x54, 0x23, 0x74, 0x22, 0x21, 0xad, 0x2a, 0x06, 0xbb, 0x79, 0x6a, 0xb2, 0x06, 0x9d, 0x7e, 0x65,
+    0xc0, 0xa5, 0x05, 0xb0, 0xcd, 0xec, 0x32, 0x8e, 0x75, 0xd4, 0x05, 0xd4, 0x90, 0xe1, 0x72, 0xee,
+    0x3a, 0xf0, 0x04, 0x84, 0x17, 0x74, 0x71, 0x7c, 0x5d, 0xf2, 0x61, 0xf9, 0x7c, 0x7d, 0x6f, 0x2c,
+    0xa6, 0xdc, 0xe7, 0x9e, 0x28, 0x03, 0x2f, 0x80, 0x4c, 0xdd, 0x85, 0xd6, 0x8c, 0x23, 0x6f, 0x8a,
+    0x25, 0x39, 0x44, 0xf5, 0xec, 0x77, 0xbd, 0x73, 0xf2, 0xcc, 0x85, 0x4c, 0xc5, 0xa3, 0x10, 0xe1,
+    0xb7, 0xb4, 0xd1, 0x84, 0xc8, 0x5f, 0xe0, 0x99, 0x7f, 0x2a, 0xbb, 0xda, 0xf8, 0x88, 0xd7, 0x7e,
+    0x69, 0x91, 0x69, 0xb9, 0x81, 0xc8, 0xf5, 0xc3, 0x73, 0x57, 0xaf, 0x7d, 0xc1, 0x94, 0x34, 0x2a,
+    0xdf, 0x3c, 0x82, 0xba, 0x9c, 0x4d, 0xbc, 0x8f, 0xca, 0xcd, 0x59, 0xbe, 0x8a, 0x05, 0x74, 0xde,
+    0x2b, 0xd0, 0xfb, 0x97, 0x2e, 0xc0, 0x0e, 0x6b, 0x00, 0xf7, 0x98, 0xdd, 0x85, 0x95, 0xb4, 0x48,
+    0x92, 0x64, 0xcd, 0xfe, 0xff, 0xdb, 0xd9, 0x31, 0xc9, 0xd4, 0x0e, 0x27, 0xee, 0xaf, 0x38, 0xe3,
+    0x9a, 0xd0, 0xe4, 0xdd, 0x95, 0x77, 0x3c, 0x54, 0xc1, 0xc4, 0x07, 0xc8, 0xff, 0xea, 0x5e, 0x64,
+    0x93, 0x61, 0x4d, 0xfc, 0xa5, 0x07, 0xf9, 0xb1, 0xcc, 0xd4, 0x84, 0xeb, 0x39, 0xd9, 0x9d, 0x7a,
+    0x06, 0xd5, 0x64, 0xff, 0x54, 0x96, 0x50, 0xa0, 0xc4, 0x3f, 0x76, 0x23, 0x85, 0x57, 0xbc, 0x34,
+    0x4a, 0xce, 0xa6, 0x4d, 0xa8, 0xe6, 0xe1, 0x28, 0x25, 0x75, 0xde, 0xf6, 0x8e, 0x6c, 0x7b, 0xbc,
+    0x7a, 0x99, 0x43, 0xb1, 0x54, 0x9a, 0x0e, 0x95, 0x19, 0x52, 0x84, 0x4a, 0x9e, 0xba, 0x3b, 0xf0,
+    0x67, 0x88, 0xce, 0xb2, 0xd3, 0xc4, 0xe6, 0x49, 0xc3, 0xab, 0x32, 0x98, 0xcf, 0x3f, 0x05, 0xf1,
+    0xaa, 0x98, 0xd3, 0xb6, 0x8a, 0xe6, 0xe3, 0xb8, 0x8d, 0x35, 0xc7, 0xdd, 0xb5, 0x04, 0x5c, 0xf9,
+    0x88, 0x0c, 0xa1, 0x8a, 0xb8, 0xff, 0xf9, 0x23, 0xd4, 0x80, 0xe1, 0x30, 0xe8, 0x27, 0x9e, 0x21,
+    0x8b, 0x72, 0x42, 0xbe, 0xe5, 0x65, 0x73, 0xbe, 0x52, 0xcb, 0xe2, 0x4c, 0xa2, 0xc7, 0x77, 0xce,
+    0x7e, 0xe3, 0x02, 0x4a, 0x9f, 0xa4, 0x96, 0x3c, 0x71, 0x65, 0x98, 0x4f, 0x32, 0x85, 0x0c, 0x41,
+    0x71, 0x93, 0x84, 0x23, 0xb6, 0x6d, 0x12, 0x67, 0x13, 0x30, 0x62, 0x02, 0x4d, 0x72, 0x38, 0x00,
+    0x28, 0x47, 0xa1, 0x46, 0x38, 0xac, 0xc2, 0x69, 0x09, 0x7a, 0xe5, 0x5f, 0x10, 0xb3, 0x9a, 0xe9,
+    0x60, 0x56, 0xa2, 0xfa, 0x80, 0x58, 0x15, 0x1b, 0x37, 0xa6, 0xcd, 0x9a, 0xf6, 0x73, 0x9a, 0x6a,
+    0x28, 0xb3, 0x03, 0x62, 0x3e, 0x02, 0x50, 0x27, 0x72, 0x07, 0x3d, 0x40, 0x0d, 0x17, 0x5c, 0x03,
+    0x77, 0xe0, 0xea, 0xc4, 0xec, 0x27, 0x30, 0x6a, 0x99, 0xba, 0x5b, 0x9a, 0xf7, 0x72, 0x42, 0xcb,
+    0x3a, 0xd8, 0xff, 0x07, 0xea, 0x0b, 0xbb, 0x2e, 0x28, 0xaa, 0xc0, 0x44, 0xf0, 0xac, 0xb1, 0x2b,
+    0x6a, 0x5c, 0x41, 0x04, 0x8e, 0x98, 0x82, 0x39, 0x7a, 0x3b, 0xc0, 0x44, 0x92, 0x38, 0xd0, 0xa0,
+    0x3b, 0x59, 0x8c, 0x05, 0xa7, 0x4e, 0x39, 0xab, 0x6b, 0x0e, 0x6b, 0x26, 0x89, 0x2f, 0x1a, 0x6e,
+    0x41, 0xe7, 0x2a, 0x06, 0xa3, 0x1a, 0x18, 0x6f, 0x79, 0xb9, 0x4b, 0x6f, 0x5b, 0xf6, 0x9e, 0x66,
+    0x82, 0x82, 0x91, 0xa5, 0xc0, 0xaa, 0x9a, 0x91, 0x2a, 0x0e, 0x0a, 0x03, 0x72, 0x26, 0xf9, 0x09,
+    0x22, 0x5e, 0x88, 0x69, 0x7b, 0xbe, 0xb7, 0x22, 0x05, 0x58, 0x38, 0x4d, 0xf4, 0x7b, 0xca, 0xc1,
+    0x96, 0xb7, 0x77, 0xd7, 0xa3, 0x47, 0xba, 0xa5, 0xeb, 0xdb, 0xea, 0x33, 0xfd, 0x6a, 0x13, 0x61,
+    0x33, 0x2a, 0xa5, 0x8e, 0xf1, 0xb5, 0xdd, 0xe0, 0x84, 0xb9, 0xbc, 0x3b, 0x7b, 0x37, 0xff, 0xf8,
+    0xc2, 0xe2, 0xdf, 0x9c, 0xbc, 0x7f, 0xd9, 0x73, 0x6a, 0x01, 0xe2, 0x74, 0x8a, 0x10, 0x19, 0x93,
+    0x5c, 0xf2, 0x3d, 0x17, 0xe1, 0xe5, 0x53, 0xae, 0x24, 0x4b, 0x01, 0x11, 0xf1, 0x47, 0x4b, 0xd8,
+    0xc1, 0x04, 0xe3, 0x72, 0x9b, 0x20, 0xb6, 0x2c, 0x3d, 0xc3, 0x13, 0x37, 0xeb, 0x0d, 0xf6, 0x6c,
+    0x85, 0x90, 0x00, 0x99, 0xb2, 0xed, 0x32, 0x77, 0xe0, 0xc3, 0x93, 0x0c, 0xcf, 0x4a, 0x86, 0x73,
+    0x2d, 0x2a, 0xa3, 0x70, 0xfe, 0x83, 0xe8, 0x8b, 0x6e, 0x50, 0xf2, 0xfb, 0xdc, 0xf5, 0x81, 0xa9,
+    0x72, 0x65, 0x4a, 0x96, 0x9c, 0xa3, 0x79, 0x72, 0x55, 0xcc, 0x88, 0x11, 0xa4, 0x9f, 0x92, 0xa9,
+    0x6d, 0xc7, 0x03, 0xe9, 0xff, 0x5f, 0x41, 0xeb, 0xf1, 0x83, 0x19, 0xdd, 0xb2, 0x1b, 0xae, 0xd8,
+    0x8d, 0x1b, 0x38, 0xbe, 0xa3, 0xa7, 0x3e, 0xc1, 0x67, 0x41, 0x69, 0xf8, 0xa2, 0xd1, 0x0a, 0x68,
+    0x79, 0x6a, 0x89, 0x90, 0xee, 0x8b, 0x9b, 0x3e, 0xa9, 0x85, 0x83, 0x1c, 0x29, 0xdd, 0x1e, 0x3a,
+    0xca, 0x1d, 0x27, 0x93, 0x0a, 0x18, 0xa2, 0x29, 0x26, 0x4b, 0x4f, 0xe4, 0xe0, 0x10, 0x90, 0x4a,
+    0x03, 0x6b, 0x55, 0x96, 0xa3, 0xce, 0x19, 0xbb, 0xac, 0x05, 0x03, 0x3e, 0xfe, 0xf2, 0x91, 0x69,
+    0x0b, 0x39, 0x08, 0x6b, 0xa7, 0x9a, 0x38, 0x7f, 0x0d, 0xbc, 0x12, 0xd6, 0x81, 0x0c, 0x06, 0x86,
+    0x93, 0x36, 0xd7, 0xc5, 0x39, 0xbe, 0xec, 0xe3, 0xf2, 0x8a, 0x9d, 0xe1, 0xa8, 0x0e, 0x8f, 0xf8,
+    0x36, 0x28, 0x6b, 0xbc, 0xf4, 0x47, 0xc0, 0xb0, 0xc9, 0x0b, 0xef, 0xd0, 0xe9, 0x1e, 0x10, 0x72,
+    0x2f, 0xcf, 0x29, 0x7a, 0x07, 0x1a, 0x64, 0x52, 0xcc, 0x17, 0x89, 0x1f, 0xc7, 0x2b, 0xa8, 0xa1,
+    0x9b, 0x2a, 0x85, 0x92, 0xac, 0x27, 0x3b, 0x5f, 0x0d, 0xf3, 0x00, 0x3b, 0xde, 0x82, 0x87, 0x80,
+    0x2a, 0x06, 0xa7, 0x86, 0x98, 0xfd, 0xfd, 0x83, 0x18, 0x40, 0x25, 0xc4, 0xce, 0x96, 0x52, 0xfe,
+    0xd3, 0xf0, 0xa4, 0x09, 0xc5, 0x67, 0x77, 0x3e, 0x0c, 0x35, 0xe4, 0x5e, 0x86, 0x93, 0x35, 0xa1,
+    0xa9, 0x0a, 0x25, 0x08, 0xbf, 0xa3, 0x92, 0xbc, 0x53, 0x21, 0xc5, 0x82, 0xcb, 0x45, 0x3f, 0x41,
+    0xa9, 0xf1, 0x07, 0xcb, 0x96, 0x6f, 0x16, 0xe7, 0x8d, 0x51, 0x3e, 0x32, 0x79, 0xfd, 0x66, 0xee,
+    0xe0, 0xc6, 0x95, 0x9b, 0x80, 0x4c, 0x36, 0xa9, 0xb0, 0xa0, 0xcc, 0x10, 0xf0, 0x6b, 0xa0, 0xe4,
+    0x50, 0xad, 0xee, 0x46, 0x5c, 0x34, 0xf5, 0xf0, 0x15, 0x17, 0x41, 0x9b, 0xda, 0x89, 0xaf, 0xea,
+    0x49, 0x44, 0x07, 0xc2, 0xfb, 0x69, 0xb7, 0x06, 0xe3, 0x7c, 0xaa, 0x84, 0xe4, 0x18, 0x0e, 0xe9,
+    0x77, 0xe6, 0x81, 0x99, 0x68, 0xd3, 0x40, 0xeb, 0xaf, 0x01, 0xf4, 0x53, 0x69, 0x05, 0x06, 0xf8,
+    0x25, 0x68, 0x4f, 0x57, 0xca, 0x09, 0xbf, 0xae, 0xf2, 0xe1, 0x4a, 0xc5, 0xcc, 0x9a, 0xb5, 0x8b,
+    0x52, 0xe7, 0x6c, 0xcb, 0x2a, 0x9a, 0x86, 0xb9, 0x3e, 0xc1, 0xac, 0x5a, 0xc3, 0x5c, 0xb6, 0x0a,
+    0x5b, 0x69, 0xcd, 0xca, 0x87, 0x4c, 0x3d, 0x2b, 0x4d, 0x8b, 0x35, 0x4b, 0xa1, 0x2a, 0xda, 0xf4,
+    0xc0, 0xf7, 0x0f, 0xc3, 0x83, 0x18, 0x1c, 0xef, 0xfb, 0xf0, 0x91, 0xc6, 0x85, 0x8f, 0xb4, 0x48,
+    0x0f, 0x3b, 0x38, 0x53, 0x3d, 0x42, 0x18, 0x72, 0x8a, 0x82, 0x9e, 0x81, 0xac, 0x8c, 0x4e, 0x11,
+    0x02, 0x5d, 0xac, 0x20, 0x42, 0x8d, 0xee, 0xae, 0x32, 0x43, 0xea, 0x12, 0x01, 0x04, 0x71, 0x72,
+    0xdc, 0x37, 0x0d, 0xca, 0x3a, 0x4d, 0x27, 0xef, 0x8c, 0x2c, 0x0c, 0xcc, 0x64, 0x90, 0x2b, 0x8d,
+    0xbf, 0x6b, 0x83, 0xcd, 0x55, 0x56, 0x39, 0x01, 0x69, 0x5f, 0x24, 0x8b, 0x40, 0xe4, 0x2e, 0xf9,
+    0x44, 0xc6, 0x6c, 0x9d, 0x9c, 0x7d, 0xdd, 0xd3, 0x67, 0x26, 0xff, 0x20, 0xaa, 0x13, 0x72, 0xee,
+    0x26, 0x93, 0x86, 0x97, 0xc1, 0xe7, 0x57, 0x2e, 0x6c, 0xc3, 0x4f, 0x78, 0x69, 0x32, 0xee, 0x3b,
+    0x6f, 0x78, 0x07, 0x9f, 0xbb, 0x27, 0xb2, 0xac, 0x0d, 0x50, 0xca, 0x7f, 0x1a, 0xd6, 0xc6, 0x5d,
+    0xa5, 0x07, 0x04, 0x6c, 0x92, 0xef, 0x36, 0xf7, 0xed, 0xc2, 0xcb, 0x7c, 0x95, 0xb0, 0x74, 0xb7,
+    0x32, 0x66, 0xcd, 0xd7, 0x24, 0x11, 0xe8, 0xb7, 0xcf, 0x00, 0xc3, 0x54, 0xcb, 0x43, 0x8d, 0xfc,
+    0x4d, 0xf2, 0x86, 0x1c, 0x0b, 0x29, 0xd6, 0x63, 0x11, 0x97, 0x61, 0xab, 0x92, 0x14, 0xd0, 0xb4,
+    0x51, 0xd8, 0x82, 0x90, 0x8b, 0xd2, 0x3b, 0x3b, 0x8d, 0xe1, 0x73, 0x94, 0x73, 0x6d, 0xf5, 0x36,
+    0x23, 0xb3, 0xa3, 0xba, 0x16, 0xf3, 0x07, 0xf3, 0x2c, 0x0a, 0xe5, 0x2c, 0x51, 0x7d, 0x0c, 0x07,
+    0x76, 0xe8, 0x30, 0x9e, 0xce, 0x89, 0x9f, 0xbe, 0x64, 0x28, 0xe4, 0xd4, 0x8e, 0x51, 0x95, 0x7b,
+    0x51, 0x78, 0x8c, 0x11, 0xac, 0x7c, 0xbf, 0x9d, 0xa9, 0x3e, 0xf6, 0x9b, 0xd3, 0xcf, 0x4b, 0x26,
+    0xaf, 0x82, 0x0d, 0x10, 0x83, 0xcc, 0x1d, 0x3b, 0x0f, 0x51, 0x40, 0xd7, 0xa9, 0x1e, 0xfa, 0xe4,
+    0x2b, 0x79, 0x50, 0xf7, 0x87, 0xfd, 0xdf, 0xbb, 0x17, 0xbc, 0x6c, 0x9f, 0x00, 0xc3, 0x7e, 0xbf,
+    0xb0, 0xed, 0x8f, 0x15, 0xc0, 0xc9, 0x9d, 0xb2, 0xe6, 0x16, 0xfe, 0x9e, 0x98, 0x0c, 0xcb, 0xbd,
+    0xb8, 0x5e, 0xb4, 0xeb, 0x00, 0xcd, 0x39, 0x53, 0xc1, 0x1c, 0xed, 0xc9, 0xf8, 0x1c, 0xfd, 0xf5,
+    0x29, 0xab, 0xaa, 0xb3, 0x43, 0x0d, 0x3a, 0xfc, 0x9c, 0xdd, 0xdd, 0x6a, 0x97, 0xaf, 0xe3, 0x75,
+    0x55, 0x33, 0xe9, 0x50, 0xc9, 0x5b, 0x70, 0x1b, 0xaf, 0x19, 0x0e, 0xcd, 0x76, 0x8d, 0x5c, 0xbe,
+    0xc0, 0xdb, 0x3e, 0x06, 0xfe, 0x02, 0xf9, 0x23, 0x36, 0xc2, 0xc2, 0x43, 0x00, 0xcc, 0x55, 0xad,
+    0x0a, 0xf2, 0x83, 0x62, 0xf7, 0x96, 0x99, 0x2d, 0x78, 0x90, 0xd9, 0x4e, 0x08, 0xc4, 0x52, 0x90,
+    0x51, 0x14, 0x21, 0x8a, 0x52, 0xf6, 0x1c, 0x63, 0xb0, 0xc3, 0x6c, 0x4d, 0x6a, 0x2d, 0x35, 0x9d,
+    0xd9, 0x73, 0xc2, 0xdc, 0xb1, 0xa5, 0x91, 0xbc, 0x79, 0x91, 0x45, 0x4c, 0xe7, 0x33, 0x30, 0xe0,
+    0x7b, 0x30, 0x82, 0x82, 0xb8, 0xc6, 0x82, 0x24, 0x06, 0x5c, 0xb1, 0xb1, 0x43, 0x66, 0xc7, 0x26,
+    0x6c, 0x12, 0xa2, 0x5a, 0x7c, 0xb6, 0xbf, 0x2a, 0xb5, 0x57, 0xbf, 0x74, 0x8b, 0x70, 0xcc, 0x00,
+    0x61, 0x81, 0xfe, 0x00, 0xfb, 0xa7, 0x3e, 0x29, 0x44, 0x5f, 0xf2, 0x04, 0x3c, 0x7f, 0xd4, 0x58,
+    0xfd, 0x33, 0x3c, 0xa6, 0x96, 0x45, 0x6c, 0xfc, 0xea, 0x59, 0xc5, 0xe9, 0x82, 0xf7, 0xa8, 0x7d,
+    0x7a, 0x8a, 0x0d, 0xf1, 0x3d, 0x35, 0xf3, 0x6c, 0xa6, 0xca, 0xca, 0x4b, 0x37, 0xdf, 0xd4, 0x29,
+    0x82, 0x64, 0xaa, 0x0f, 0x1a, 0xf4, 0x54, 0xe4, 0x90, 0xda, 0xcb, 0x4a, 0x98, 0xde, 0x7d, 0x2b,
+    0x59, 0x08, 0x2b, 0x0c, 0x38, 0xb5, 0x73, 0x4e, 0x37, 0xcb, 0x4a, 0x49, 0xf3, 0x2e, 0x59, 0x67,
+    0x83, 0x61, 0x68, 0x04, 0x74, 0x2d, 0x58, 0x84, 0x93, 0x5b, 0x8a, 0x94, 0xf6, 0xd4, 0x5b, 0x4f,
+    0x7a, 0xb7, 0x69, 0x06, 0xe3, 0xc8, 0xcd, 0xe9, 0x70, 0xec, 0xdd, 0x4b, 0x65, 0x45, 0xae, 0x7d,
+    0x6f, 0xf4, 0x0d, 0x33, 0xb2, 0x7b, 0x78, 0x78, 0x22, 0x49, 0x37, 0xe2, 0x7d, 0x85, 0x23, 0x98,
+    0xd6, 0xba, 0x0e, 0x85, 0xa3, 0x47, 0xda, 0xd3, 0x93, 0xb3, 0x3f, 0xc5, 0x13, 0xb7, 0x2f, 0xf5,
+    0x9f, 0x68, 0x2a, 0x86, 0xb3, 0x7a, 0x38, 0xd4, 0xcc, 0x89, 0x34, 0xec, 0xce, 0x43, 0xeb, 0x2d,
+    0x9f, 0x7f, 0xdf, 0xef, 0xfb, 0xf7, 0x04, 0x93, 0x14, 0xa0, 0xe2, 0x33, 0xe6, 0xa4, 0xef, 0x32,
+    0xcc, 0x47, 0x54, 0xee, 0x3f, 0xbc, 0x15, 0x37, 0x1c, 0xb0, 0x61, 0x51, 0xb0, 0xd6, 0x8e, 0xf0,
+    0xfa, 0x03, 0x8e, 0x01, 0x16, 0x7f, 0x4c, 0x03, 0x04, 0x25, 0x2f, 0x8b, 0xf8, 0x4c, 0x72, 0x56,
+    0xf2, 0x6e, 0x5e, 0x15, 0xa9, 0xc2, 0x12, 0xbe, 0x9d, 0x6f, 0x07, 0xd2, 0x8a, 0x46, 0x75, 0xfe,
+    0x57, 0xcf, 0x5a, 0xb9, 0x65, 0xfc, 0xae, 0x85, 0x41, 0xde, 0x52, 0x15, 0xb6, 0xe6, 0x71, 0x47,
+    0x72, 0xe8, 0x41, 0xea, 0x5f, 0xd4, 0x58, 0xc4, 0xd2, 0x12, 0xcf, 0xd5, 0x7c, 0x87, 0x51, 0xa6,
+    0x52, 0xf1, 0x01, 0xe9, 0x05, 0x0a, 0x1e, 0x9d, 0x35, 0xe2, 0xe3, 0xdd, 0xeb, 0x44, 0x8e, 0xd9,
+    0xb6, 0xae, 0xdb, 0xa8, 0x8d, 0xa6, 0xcb, 0xb6, 0x25, 0xd6, 0x80, 0x7f, 0xa3, 0xf2, 0x72, 0x13,
+    0xd2, 0xc8, 0x2e, 0xf6, 0xdf, 0xd8, 0xdf, 0x28, 0x5e, 0x5b, 0xec, 0x85, 0xc4, 0xb3, 0x93, 0x1c,
+    0xf1, 0x1a, 0x07, 0x91, 0x98, 0x39, 0xd2, 0x7d, 0x26, 0x88, 0x6a, 0xf6, 0x3e, 0xce, 0x1b, 0x4d,
+    0x9c, 0x76, 0x57, 0xe5, 0x7d, 0xa9, 0x51, 0x19, 0x45, 0xa2, 0x03, 0x3e, 0xaf, 0x9d, 0xf9, 0xd5,
+    0xcf, 0x4e, 0xdc, 0xe4, 0xb1, 0x3d, 0xd3, 0x78, 0xbf, 0xcb, 0x8b, 0x6f, 0x5f, 0x76, 0xd7, 0xfb,
+    0xfd, 0x70, 0xd9, 0xe9, 0xbe, 0x33, 0xd3, 0xad, 0x2e, 0xcf, 0x09, 0xf6, 0xfe, 0xea, 0xdb, 0x83,
+    0xa3, 0xff, 0x2d, 0x43, 0xf0, 0xe1, 0xe5, 0xe0, 0x26, 0x8a, 0xc7, 0x52, 0xa5, 0xdb, 0xda, 0xdc,
+    0x52, 0xf7, 0x9a, 0x5c, 0x95, 0x32, 0x4d, 0x52, 0x2f, 0xce, 0x89, 0x7e, 0xb7, 0xee, 0x7b, 0x73,
+    0x3f, 0x5d, 0x78, 0xc2, 0xd5, 0xdf, 0x08, 0x92, 0xeb, 0xe9, 0x48, 0x59, 0x0b, 0x0e, 0x7f, 0xd2,
+    0x40, 0xa2, 0x26, 0x00, 0x00, 0x74, 0x76, 0x84, 0x48, 0xa0, 0x6a, 0xa0, 0x9c, 0x44, 0xab, 0xa2,
+    0x10, 0x42, 0x0d, 0x8e, 0xf2, 0x54, 0x69, 0x0e, 0x32, 0x3a, 0xe6, 0xc7, 0xc6, 0x30, 0xb4, 0x62,
+    0x59, 0x81, 0xa6, 0x8a, 0xdf, 0x00, 0x35, 0x7d, 0xf1, 0xfd, 0x5e, 0xcf, 0xd8, 0x4c, 0xb4, 0xea,
+    0xf6, 0xfd, 0x83, 0x5d, 0x09, 0x65, 0xf7, 0x87, 0x69, 0x73, 0x64, 0x49, 0x98, 0xb3, 0x4e, 0x80,
+    0xa5, 0xbd, 0x65, 0x8a, 0x3a, 0xba, 0x12, 0xe6, 0xe3, 0x91, 0x32, 0xc0, 0x9b, 0xf9, 0x72, 0x30,
+    0x4d, 0xea, 0x01, 0xbb, 0x1e, 0xa6, 0x1f, 0xaa, 0xed, 0x4d, 0x7f, 0x10, 0x28, 0x6d, 0x79, 0x68,
+    0x76, 0xb0, 0x02, 0x0d, 0x0a, 0x7b, 0x14, 0xae, 0xdf, 0x59, 0xf2, 0x73, 0xa1, 0x78, 0xfc, 0x72,
+    0xbd, 0x43, 0x24, 0x8c, 0xd3, 0xbf, 0xd1, 0x68, 0x68, 0x77, 0x58, 0xa2, 0x99, 0x74, 0x56, 0xe8,
+    0xfb, 0x88, 0x2e, 0xc4, 0xdc, 0x09, 0x38, 0x07, 0xed, 0xc8, 0xce, 0x80, 0xb0, 0xcc, 0x7f, 0x88,
+    0x23, 0x0a, 0xae, 0x8f, 0x8e, 0x5d, 0xbc, 0xe8, 0x5a, 0x9f, 0x2d, 0x8b, 0x9e, 0x7c, 0xfc, 0x6e,
+    0x19, 0xe9, 0x0e, 0x82, 0x07, 0x70, 0x3f, 0xac, 0xfc, 0xaf, 0x1b, 0xfc, 0x73, 0xe4, 0x1e, 0xec,
+    0xff, 0xab, 0x8b, 0x65, 0x95, 0x32, 0xf5, 0x5a, 0xd5, 0x47, 0xcd, 0xcb, 0xbf, 0x5d, 0x71, 0xe6,
+    0x48, 0xce, 0x95, 0x0a, 0x22, 0x90, 0x9b, 0xee, 0x2d, 0x2a, 0x3d, 0xf8, 0x46, 0x8c, 0xdc, 0xc8,
+    0x7b, 0x45, 0x37, 0x19, 0x49, 0x76, 0xc3, 0x9c, 0xba, 0xa0, 0x91, 0x76, 0xc2, 0x81, 0xd2, 0x6b,
+    0x43, 0xf4, 0xaa, 0x5a, 0x09, 0x3a, 0x1e, 0xb1, 0xc4, 0x42, 0x3a, 0xdf, 0xdb, 0x0d, 0x29, 0x8b,
+    0xfa, 0x40, 0xb3, 0xdb, 0xc8, 0x73, 0x47, 0xde, 0x73, 0x83, 0x5f, 0x3a, 0xbb, 0x01, 0xbe, 0xeb,
+    0xdb, 0x7d, 0xdb, 0x96, 0xda, 0x81, 0x10, 0xc5, 0x4a, 0xa5, 0xc5, 0x91, 0xcc, 0x46, 0x78, 0xb2,
+    0xb7, 0x6d, 0xda, 0x6e, 0xe4, 0x6e, 0xa9, 0x4a, 0x04, 0x82, 0x76, 0x7e, 0x94, 0xd4, 0x56, 0x71,
+    0xf1, 0xdb, 0xa2, 0x7c, 0x33, 0xa9, 0xd0, 0x09, 0x4d, 0x21, 0x6c, 0x9e, 0xd8, 0x35, 0x76, 0xd6,
+    0xd2, 0x11, 0x8b, 0x99, 0x3d, 0x6b, 0x25, 0xf2, 0x9d, 0xc1, 0x87, 0xd5, 0x09, 0xd5, 0x94, 0xf1,
+    0x5a, 0xfb, 0x46, 0x99, 0x77, 0xb6, 0xb6, 0xa2, 0x78, 0x99, 0xc7, 0x5e, 0x24, 0x5e, 0x9d, 0x90,
+    0x3e, 0x2d, 0xcc, 0x44, 0xcf, 0xe9, 0x0f, 0x60, 0x72, 0x90, 0x26, 0x95, 0x94, 0xf0, 0xf4, 0x91,
+    0x1b, 0xfe, 0x4f, 0x07, 0xad, 0x5e, 0xb0, 0xc8, 0x0a, 0x01, 0x64, 0xd2, 0xcd, 0x19, 0x0b, 0x2f,
+    0xc1, 0xa0, 0xdb, 0x11, 0xfc, 0x53, 0x74, 0xb1, 0x05, 0xb5, 0xed, 0x99, 0x85, 0x75, 0x7f, 0xdb,
+    0xe6, 0x5d, 0x59, 0x67, 0x19, 0xb7, 0xd7, 0xfc, 0x48, 0xad, 0xcd, 0x99, 0xee, 0x7c, 0x7a, 0xc6,
+    0x7e, 0x8c, 0xcc, 0x96, 0x3e, 0xec, 0xbf, 0x9d, 0xc1, 0xc8, 0x07, 0x9a, 0x86, 0x44, 0xd1, 0xf4,
+    0xd8, 0x74, 0x53, 0x9c, 0x9d, 0x33, 0x57, 0xde, 0x09, 0x0e, 0x8c, 0xfa, 0xea, 0x2d, 0x74, 0xf6,
+    0x9b, 0x79, 0x2f, 0x98, 0x87, 0x7d, 0x11, 0xb4, 0xc4, 0xc8, 0xc7, 0x2a, 0xc0, 0xf8, 0x3f, 0xff,
+    0x26, 0xb9, 0x5a, 0x15, 0x26, 0x05, 0x4c, 0xfe, 0xc1, 0x6e, 0xb9, 0xe4, 0xce, 0xfe, 0xdd, 0xf7,
+    0x7d, 0xa9, 0x13, 0x3c, 0xf8, 0xe3, 0xd4, 0x4c, 0xbe, 0x24, 0x61, 0xdb, 0xc6, 0xee, 0xdc, 0xf9,
+    0x47, 0x59, 0x2e, 0x96, 0x0a, 0xe8, 0xdd, 0xbc, 0xa8, 0xeb, 0x99, 0x5e, 0x80, 0x6d, 0x76, 0xf2,
+    0xf8, 0x20, 0x46, 0xce, 0xd5, 0x6e, 0xcb, 0x10, 0x77, 0x5c, 0x8c, 0xff, 0x89, 0xdb, 0x7d, 0xb7,
+    0xcc, 0x62, 0x43, 0xdf, 0xff, 0x43, 0xd2, 0x22, 0xd0, 0xfb, 0xa7, 0xbb, 0xff, 0x1f, 0x56, 0x0e,
+    0x70, 0x72, 0x42, 0x7e, 0xa8, 0xd4, 0x6d, 0x63, 0x78, 0x70, 0x6f, 0xca, 0x58, 0xe3, 0xb2, 0x67,
+    0x79, 0x63, 0xc3, 0xbd, 0xba, 0x75, 0x10, 0xa4, 0x38, 0xa5, 0x17, 0x19, 0x77, 0xa1, 0x4f, 0xbd,
+    0x71, 0x73, 0xc2, 0xec, 0xe4, 0x95, 0x30, 0x82, 0x1d, 0xd3, 0x43, 0x4b, 0x11, 0x99, 0x30, 0x6c,
+    0x94, 0xe5, 0x41, 0x08, 0x3f, 0xbb, 0xed, 0xdb, 0x58, 0x57, 0xe3, 0x28, 0x2f, 0x9b, 0xad, 0x9b,
+    0x70, 0x80, 0x7d, 0xfd, 0x37, 0xab, 0xec, 0xda, 0xdc, 0xb7, 0xc3, 0x65, 0x27, 0x8b, 0xac, 0x9a,
+    0xbe, 0xc3, 0x87, 0xed, 0x3e, 0xba, 0x6d, 0xd9, 0xb2, 0x26, 0x1c, 0x4e, 0x2e, 0x9a, 0x2d, 0x99,
+    0x31, 0x2a, 0x01, 0x4f, 0x36, 0xaa, 0x6c, 0xd8, 0xf5, 0xb1, 0x60, 0x06, 0x26, 0x8a, 0x2c, 0x98,
+    0x7a, 0x8a, 0x0d, 0x42, 0xd6, 0xff, 0x9c, 0xa5, 0xa6, 0x5a, 0xeb, 0xb3, 0x26, 0x3c, 0xfb, 0x2a,
+    0x32, 0xc8, 0xf2, 0x06, 0xb2, 0xe7, 0x9b, 0x0d, 0x7a, 0x78, 0xe5, 0xc2, 0x9d, 0x7a, 0xe9, 0x6f,
+    0x3b, 0xd9, 0x7f, 0x05, 0xd5, 0xad, 0x73, 0x4e, 0xc4, 0xad, 0x1f, 0xe4, 0x78, 0xe2, 0xb3, 0x7d,
+    0x33, 0xc9, 0x36, 0x04, 0xa3, 0x7f, 0x2e, 0x4e, 0x1f, 0xdb, 0xed, 0xdf, 0x93, 0xdb, 0xba, 0x4b,
+    0xde, 0xaa, 0x2e, 0x0a, 0x3d, 0xb3, 0xe5, 0xd3, 0x6a, 0xb8, 0xbd, 0x43, 0x2d, 0x93, 0xa5, 0x93,
+    0x2a, 0x18, 0xad, 0x00, 0x35, 0xa3, 0xe4, 0xd2, 0xca, 0x1a, 0x0a, 0x6d, 0x25, 0x83, 0xa4, 0x92,
+    0x4b, 0xee, 0x6b, 0x01, 0x3c, 0xb2, 0x65, 0xd1, 0x6b, 0xb9, 0x31, 0x41, 0x2c, 0x92, 0x25, 0x91,
+    0x41, 0x58, 0x28, 0x02, 0x34, 0xa2, 0x64, 0xd0, 0x23, 0x1b, 0x8a, 0x0f, 0x24, 0x82, 0x24, 0x90,
+    0x05, 0x62, 0xa2, 0x13, 0xfb, 0x66, 0x91, 0xba, 0xac, 0x12, 0x62, 0x3d, 0xec, 0x26, 0xa4, 0xbe,
+    0x04, 0xb5, 0x80, 0x9b, 0x40, 0x10, 0xe6, 0x37, 0x45, 0xae, 0xc4, 0xee, 0xc6, 0x6b, 0xd2, 0x77,
+    0x82, 0xf3, 0x03, 0x14, 0x78, 0x67, 0x32, 0x7a, 0x2f, 0x49, 0x34, 0x1d, 0xcf, 0x7b, 0x53, 0x17,
+    0xf3, 0x73, 0x85, 0xee, 0xb5, 0x45, 0x0e, 0x3c, 0x0b, 0x10, 0x0a, 0x17, 0x3e, 0x75, 0x92, 0xad,
+    0x24, 0x80, 0xc0, 0xc9, 0x3b, 0x3b, 0xcd, 0xcb, 0x2c, 0xc4, 0xe0, 0x5c, 0x2b, 0x1b, 0x8d, 0x8b,
+    0xdc, 0x52, 0xab, 0x62, 0x33, 0x2b, 0xcc, 0xca, 0x24, 0x8f, 0xc0, 0x14, 0x23, 0x0b, 0x8c, 0x8a,
+    0x3d, 0xe6, 0x5f, 0x19, 0x3a, 0x3a, 0x4d, 0xc9, 0xa1, 0x83, 0x1d, 0xdb, 0x2a, 0x1a, 0x0d, 0x89,
+    0x75, 0x2f, 0x21, 0x33, 0x32, 0x2a, 0x4c, 0xc8, 0x67, 0x0a, 0x10, 0xac, 0x22, 0x0a, 0x0c, 0x88,
+    0x44, 0xe8, 0x2a, 0x98, 0xbe, 0x5c, 0xd7, 0x37, 0x2c, 0x19, 0x4a, 0xf7, 0xee, 0x8b, 0x1b, 0x11,
+    0xda, 0xea, 0x8a, 0x1f, 0x65, 0x1e, 0x98, 0xb3, 0x60, 0xbe, 0x88, 0xda, 0x50, 0x42, 0x96, 0xc4,
+    0x5f, 0xc1, 0x2a, 0x12, 0xe7, 0xc9, 0xbf, 0x78, 0xb3, 0xcb, 0x88, 0x50, 0xef, 0x89, 0x53, 0x7d,
+    0x07, 0xbe, 0x0a, 0xe0, 0x72, 0x7f, 0x18, 0xb1, 0xbe, 0x4a, 0x65, 0x56, 0x27, 0xf0, 0x53, 0xde,
+    0xb7, 0xaa, 0xd1, 0xa1, 0x39, 0x33, 0xc5, 0xc3, 0x52, 0x6c, 0xb9, 0xa4, 0x29, 0x13, 0x85, 0x83,
+    0xf5, 0x3a, 0xd8, 0x78, 0x31, 0x23, 0xc4, 0xc2, 0xe1, 0x1a, 0x4f, 0x1d, 0x21, 0x03, 0x84, 0x82,
+    0xb8, 0x4b, 0x2e, 0xf3, 0x38, 0x32, 0x45, 0xc1, 0xc7, 0x6b, 0xeb, 0x33, 0x28, 0x12, 0x05, 0x81,
+    0xf0, 0x3b, 0xd4, 0x3f, 0x30, 0x22, 0x44, 0xc0, 0x36, 0xf9, 0xcf, 0x1e, 0x20, 0x02, 0x04, 0x80,
+    0x18, 0xd2, 0xeb, 0x8f, 0x98, 0x3b, 0xff, 0xe4, 0x60, 0x39, 0x6e, 0x4d, 0xc8, 0x01, 0xf7, 0xac,
+    0x62, 0xe9, 0xa6, 0x8c, 0x97, 0xf4, 0x97, 0x85, 0x9b, 0x54, 0xbe, 0x30, 0x8b, 0xb2, 0xc2, 0x6d,
+    0x41, 0x43, 0x8a, 0x8f, 0x1a, 0xab, 0x7f, 0xc6, 0x68, 0x3d, 0x63, 0xd9, 0x02, 0xe1, 0x68, 0xac,
+    0x63, 0xfc, 0x26, 0x85, 0x85, 0x75, 0xd5, 0xac, 0xf9, 0xf8, 0xe2, 0xce, 0x29, 0xb5, 0x01, 0xa9,
+    0x2a, 0x5f, 0x47, 0x81, 0x1f, 0xb9, 0xe9, 0x5b, 0x08, 0x00, 0x07, 0x44, 0x0f, 0x99, 0xa9, 0x1b,
+    0xd3, 0xb0, 0xab, 0x78, 0x17, 0xa9, 0xe8, 0x5a, 0x3f, 0xf6, 0xdc, 0xce, 0x07, 0x89, 0xa8, 0x1a,
+    0x19, 0xc1, 0x87, 0x81, 0x1e, 0xb8, 0x69, 0x59, 0x09, 0x47, 0x27, 0x59, 0x0e, 0x98, 0x29, 0x19,
+    0x11, 0x77, 0x05, 0x8f, 0x16, 0xa8, 0x68, 0x58, 0x41, 0x4b, 0x34, 0x7a, 0x06, 0x88, 0x28, 0x18,
+    0x72, 0x17, 0x6f, 0xa8, 0xfa, 0x59, 0x9e, 0x8c, 0x49, 0xda, 0x4f, 0x79, 0xe8, 0xf0, 0xff, 0x8d,
+    0xdd, 0x16, 0xfe, 0x8f, 0x8a, 0xa1, 0x39, 0xaf, 0x9b, 0xc9, 0xc1, 0x54, 0x19, 0x60, 0x3e, 0x37,
+    0x5b, 0x79, 0x73, 0x7a, 0x8b, 0x6d, 0xdc, 0xa5, 0x4d, 0x2d, 0x2d, 0x49, 0xe9, 0x4d, 0x7f, 0xec,
+    0x23, 0x3e, 0x2c, 0x03, 0xa3, 0x9a, 0x3c, 0x21, 0x43, 0x5d, 0x8d, 0x84, 0xc3, 0x18, 0xbe, 0x35,
+    0x94, 0x38, 0xad, 0x8a, 0x1d, 0xb1, 0xe1, 0x53, 0x2a, 0x9c, 0x93, 0x51, 0x0d, 0x91, 0xa1, 0x13,
+    0x91, 0xb8, 0xae, 0x07, 0x15, 0xa1, 0xe0, 0x52, 0x8e, 0x18, 0x0e, 0xed, 0x05, 0x81, 0xa0, 0x12,
+    0x6b, 0xfd, 0x2f, 0x04, 0x1c, 0xb0, 0x61, 0x51, 0xdc, 0x4f, 0x4c, 0xcd, 0x0c, 0x90, 0x21, 0x11,
+    0xec, 0x0b, 0x8e, 0x80, 0x14, 0xa0, 0x60, 0x50, 0x03, 0x19, 0x8c, 0x10, 0x04, 0x80, 0x20, 0x10,
+    0xa7, 0x80, 0x02, 0x96, 0x5a, 0x64, 0xb6, 0xf8, 0x4f, 0x26, 0xff, 0xdb, 0xbf, 0x9a, 0xb4, 0xb5,
+    0x4c, 0xd6, 0x18, 0x11, 0x24, 0x42, 0x33, 0x6f, 0xc4, 0xd4, 0x87, 0xd3, 0xed, 0xd1, 0x03, 0xc9,
+    0xad, 0x42, 0x45, 0x9d, 0xb8, 0xf5, 0x17, 0xb4, 0x0e, 0x41, 0x41, 0x52, 0x62, 0x45, 0xa7, 0x50,
+    0x55, 0x11, 0xa0, 0x1a, 0xcd, 0xb0, 0xb3, 0x6d, 0xd0, 0x97, 0x35, 0xd0, 0x37, 0xfb, 0x14, 0x5e,
+    0xe4, 0x18, 0x7b, 0x98, 0x1b, 0x39, 0xc9, 0x4b, 0xe4, 0x1d, 0x99, 0x2b, 0x0b, 0x19, 0x89, 0x0b,
+    0xac, 0x0c, 0xa2, 0x93, 0x13, 0x29, 0xc8, 0x4a, 0x83, 0x0d, 0x98, 0x2a, 0x03, 0x09, 0x88, 0x0a,
+    0x0d, 0x32, 0x25, 0x84, 0x1a, 0x38, 0x49, 0x49, 0x8a, 0x1c, 0x19, 0x29, 0x0a, 0x18, 0x09, 0x09,
+    0x65, 0x74, 0x46, 0x98, 0x12, 0x28, 0x48, 0x48, 0x82, 0x0c, 0x18, 0x28, 0x02, 0x08, 0x08, 0x08,
+    0x1c, 0x68, 0xae, 0xd0, 0xc6, 0xa9, 0x3a, 0x56, 0x11, 0x0b, 0x8d, 0xde, 0xa5, 0x18, 0xfd, 0x66,
+    0x32, 0x78, 0xf0, 0x24, 0xae, 0xba, 0x3b, 0x67, 0x46, 0x38, 0xe5, 0xd5, 0x91, 0xe4, 0x88, 0x65,
+    0xec, 0x69, 0x2e, 0xd2, 0x3c, 0x8f, 0xbc, 0xba, 0x13, 0xe9, 0x4f, 0xbf, 0xb2, 0x32, 0x25, 0x07,
+    0x80, 0xc5, 0x5c, 0x47, 0x84, 0xd9, 0x41, 0xf9, 0x07, 0x41, 0x41, 0xd6, 0x84, 0x6f, 0xf1, 0x77,
+    0x06, 0x8b, 0xa2, 0x91, 0x19, 0x31, 0xc1, 0x43, 0x89, 0x15, 0x91, 0x23, 0x09, 0x11, 0x81, 0x03,
+    0x06, 0xfe, 0xad, 0x95, 0x11, 0x21, 0xc0, 0x42, 0x81, 0x05, 0x90, 0x22, 0x01, 0x01, 0x80, 0x02,
+    0x6d, 0xca, 0x0d, 0x90, 0x18, 0x30, 0x41, 0x41, 0x88, 0x14, 0x11, 0x21, 0x08, 0x10, 0x01, 0x01,
+    0xd9, 0xb9, 0x58, 0x99, 0x10, 0x20, 0x40, 0x40, 0x80, 0x04, 0x10, 0x20, 0x00, 0x00, 0x4e, 0x0e,
+};
+#endif
+#endif
diff --git a/drivers/input/touchscreen/gt1x/gt1x_generic.c b/drivers/input/touchscreen/gt1x/gt1x_generic.c
new file mode 100644
index 000000000000..a2d61bcb9b81
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_generic.c
@@ -0,0 +1,2468 @@
+/* drivers/input/touchscreen/gt1x_generic.c
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+/*#include "gt1x_tpd_custom.h"*/
+#include "gt1x.h"
+#include "gt1x_generic.h"
+#if GTP_PROXIMITY && defined(PLATFORM_MTK)
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/sensors_io.h>
+#endif
+#if GTP_ICS_SLOT_REPORT
+#include <linux/input/mt.h>
+#endif
+
+/*******************GLOBAL VARIABLE*********************/
+struct i2c_client *gt1x_i2c_client;
+static struct workqueue_struct *gt1x_workqueue;
+
+u8 gt1x_config[GTP_CONFIG_MAX_LENGTH] = { 0 };
+u32 gt1x_cfg_length = GTP_CONFIG_MAX_LENGTH;
+
+CHIP_TYPE_T gt1x_chip_type = CHIP_TYPE_NONE;
+struct gt1x_version_info gt1x_version = {
+	.product_id = {0},
+	.patch_id = 0,
+	.mask_id = 0,
+	.sensor_id = 0,
+	.match_opt = 0
+};
+
+#ifndef TPD_HAVE_BUTTON
+#define TPD_HAVE_BUTTON  0
+#endif
+
+#if GTP_HAVE_TOUCH_KEY
+const u16 gt1x_touch_key_array[] = GTP_KEY_TAB;
+#elif TPD_HAVE_BUTTON
+struct key_map_t {
+	int x;
+	int y;
+};
+static struct key_map_t tpd_virtual_key_array[] = TPD_KEY_MAP_ARRAY;
+#endif
+
+#if GTP_WITH_STYLUS && GTP_HAVE_STYLUS_KEY
+static const u16 gt1x_stylus_key_array[] = GTP_STYLUS_KEY_TAB;
+#endif
+
+#define GOODIX_SYSFS_DIR      "goodix"
+static struct kobject *sysfs_rootdir;
+
+volatile int gt1x_rawdiff_mode;
+u8 gt1x_wakeup_level;
+u8 gt1x_init_failed;
+u8 gt1x_int_type;
+u32 gt1x_abs_x_max;
+u32 gt1x_abs_y_max;
+int gt1x_halt;
+
+#if GTP_DEBUG_NODE
+static ssize_t gt1x_debug_read_proc(struct file *, char __user *, size_t, loff_t *);
+static ssize_t gt1x_debug_write_proc(struct file *, const char __user *, size_t, loff_t *);
+
+static struct proc_dir_entry *gt1x_debug_proc_entry;
+static const struct file_operations gt1x_debug_fops = {
+	.owner = THIS_MODULE,
+	.read = gt1x_debug_read_proc,
+	.write = gt1x_debug_write_proc,
+};
+
+static s32 gt1x_init_debug_node(void)
+{
+	gt1x_debug_proc_entry = proc_create(GT1X_DEBUG_PROC_FILE, 0660, NULL, &gt1x_debug_fops);
+	if (gt1x_debug_proc_entry == NULL) {
+		GTP_ERROR("Create proc entry /proc/%s FAILED!", GT1X_DEBUG_PROC_FILE);
+		return -1;
+	}
+	GTP_INFO("Created proc entry /proc/%s.", GT1X_DEBUG_PROC_FILE);
+	return 0;
+}
+
+static void gt1x_deinit_debug_node(void)
+{
+	if (gt1x_debug_proc_entry != NULL) {
+		remove_proc_entry(GT1X_DEBUG_PROC_FILE, NULL);
+	}
+}
+
+static ssize_t gt1x_debug_read_proc(struct file *file, char __user *page, size_t size, loff_t *ppos)
+{
+	char *ptr = page;
+	char temp_data[GTP_CONFIG_MAX_LENGTH] = { 0 };
+	int i;
+
+	if (*ppos) {
+		return 0;
+	}
+
+	ptr += sprintf(ptr, "==== GT1X default config setting in driver====\n");
+
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += sprintf(ptr, "0x%02X,", gt1x_config[i]);
+		if (i % 10 == 9)
+			ptr += sprintf(ptr, "\n");
+	}
+
+	ptr += sprintf(ptr, "\n");
+
+	ptr += sprintf(ptr, "==== GT1X config read from chip====\n");
+	i = gt1x_i2c_read(GTP_REG_CONFIG_DATA, temp_data, GTP_CONFIG_MAX_LENGTH);
+	GTP_INFO("I2C TRANSFER: %d", i);
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += sprintf(ptr, "0x%02X,", temp_data[i]);
+
+		if (i % 10 == 9)
+			ptr += sprintf(ptr, "\n");
+	}
+
+	ptr += sprintf(ptr, "\n");
+	/* Touch PID & VID */
+	ptr += sprintf(ptr, "==== GT1X Version Info ====\n");
+
+	gt1x_i2c_read(GTP_REG_VERSION, temp_data, 12);
+	ptr += sprintf(ptr, "ProductID: GT%c%c%c%c\n", temp_data[0], temp_data[1], temp_data[2], temp_data[3]);
+	ptr += sprintf(ptr, "PatchID: %02X%02X\n", temp_data[4], temp_data[5]);
+	ptr += sprintf(ptr, "MaskID: %02X%02X\n", temp_data[7], temp_data[8]);
+	ptr += sprintf(ptr, "SensorID: %02X\n", temp_data[10] & 0x0F);
+
+	*ppos += ptr - page;
+	return (ptr - page);
+}
+
+static ssize_t gt1x_debug_write_proc(struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+	s32 ret = 0;
+	u8 buf[GTP_CONFIG_MAX_LENGTH] = { 0 };
+	char mode_str[50] = { 0 };
+	int mode;
+	int cfg_len;
+	char arg1[50] = { 0 };
+	u8 temp_config[GTP_CONFIG_MAX_LENGTH] = { 0 };
+
+	GTP_DEBUG("write count %ld\n", (unsigned long)count);
+
+	if (count > GTP_CONFIG_MAX_LENGTH) {
+		GTP_ERROR("Too much data, buffer size: %d, data:%ld", GTP_CONFIG_MAX_LENGTH, (unsigned long)count);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, buffer, count)) {
+		GTP_ERROR("copy from user fail!");
+		return -EFAULT;
+	}
+	/*send config*/
+	if (count == gt1x_cfg_length) {
+		memcpy(gt1x_config, buf, count);
+		ret = gt1x_send_cfg(gt1x_config, gt1x_cfg_length);
+		if (ret < 0) {
+			GTP_ERROR("send gt1x_config failed.");
+			return -EFAULT;
+		}
+		gt1x_abs_x_max = (gt1x_config[RESOLUTION_LOC + 1] << 8) + gt1x_config[RESOLUTION_LOC];
+		gt1x_abs_y_max = (gt1x_config[RESOLUTION_LOC + 3] << 8) + gt1x_config[RESOLUTION_LOC + 2];
+
+		return count;
+	}
+
+	sscanf(buf, "%s %d", (char *)&mode_str, &mode);
+
+	/*force clear gt1x_config*/
+	if (strcmp(mode_str, "clear_config") == 0) {
+		GTP_INFO("Force clear gt1x_config");
+		gt1x_send_cmd(GTP_CMD_CLEAR_CFG, 0);
+		return count;
+	}
+	if (strcmp(mode_str, "init") == 0) {
+		GTP_INFO("Init panel");
+		gt1x_init_panel();
+		return count;
+	}
+	if (strcmp(mode_str, "chip") == 0) {
+		GTP_INFO("Get chip type:");
+		gt1x_get_chip_type();
+		return count;
+	}
+	if (strcmp(mode_str, "int") == 0) {
+		if (mode == 0) {
+			GTP_INFO("Disable irq.");
+			gt1x_irq_disable();
+		} else {
+			GTP_INFO("Enable irq.");
+			gt1x_irq_enable();
+		}
+		return count;
+	}
+
+	if (strcmp(mode_str, "poweron") == 0) {
+		gt1x_power_switch(1);
+		return count;
+	}
+
+	if (strcmp(mode_str, "poweroff") == 0) {
+		gt1x_power_switch(0);
+		return count;
+	}
+
+	if (strcmp(mode_str, "version") == 0) {
+		gt1x_read_version(NULL);
+		return count;
+	}
+
+	if (strcmp(mode_str, "reset") == 0) {
+		gt1x_irq_disable();
+		gt1x_reset_guitar();
+		gt1x_irq_enable();
+		return count;
+	}
+#if GTP_CHARGER_SWITCH
+	if (strcmp(mode_str, "charger") == 0) {
+		gt1x_charger_config(mode);
+		return count;
+	}
+#endif
+	sscanf(buf, "%s %s", (char *)&mode_str, (char *)&arg1);
+	if (strcmp(mode_str, "update") == 0) {
+		gt1x_update_firmware(arg1);
+		return count;
+	}
+
+	if (strcmp(mode_str, "sendconfig") == 0) {
+		cfg_len = gt1x_parse_config(arg1, temp_config);
+		if (cfg_len < 0) {
+			return -1;
+		}
+		gt1x_send_cfg(temp_config, gt1x_cfg_length);
+		return count;
+	}
+
+	if (strcmp(mode_str, "debug_gesture") == 0) {
+#if GTP_GESTURE_WAKEUP
+		gt1x_gesture_debug(!!mode);
+#endif
+	}
+
+	if (strcmp(mode_str, "force_update") == 0) {
+		update_info.force_update = !!mode;
+	}
+	return gt1x_debug_proc(buf, count);
+}
+#endif
+
+static u8 ascii2hex(u8 a)
+{
+	s8 value = 0;
+	if (a >= '0' && a <= '9') {
+		value = a - '0';
+	} else if (a >= 'A' && a <= 'F') {
+		value = a - 'A' + 0x0A;
+	} else if (a >= 'a' && a <= 'f') {
+		value = a - 'a' + 0x0A;
+	} else {
+		value = 0xff;
+	}
+	return value;
+}
+
+int gt1x_parse_config(char *filename, u8 *config)
+{
+	mm_segment_t old_fs;
+	struct file *fp = NULL;
+	u8 *buf;
+	int i;
+	int len;
+	int cur_len = -1;
+	u8 high, low;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	fp = filp_open(filename, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		GTP_ERROR("Open config file error!(file: %s)", filename);
+		goto parse_cfg_fail1;
+	}
+	len = fp->f_op->llseek(fp, 0, SEEK_END);
+	if (len > GTP_CONFIG_MAX_LENGTH * 6 || len < GTP_CONFIG_MAX_LENGTH) {
+		GTP_ERROR("Config is invalid!(length: %d)", len);
+		goto parse_cfg_fail2;
+	}
+	buf = kzalloc(len, GFP_KERNEL);
+	if (buf == NULL) {
+		GTP_ERROR("Allocate memory failed!(size: %d)", len);
+		goto parse_cfg_fail2;
+	}
+	fp->f_op->llseek(fp, 0, SEEK_SET);
+	if (fp->f_op->read(fp, (char *)buf, len, &fp->f_pos) != len) {
+		GTP_ERROR("Read %d bytes from file failed!", len);
+	}
+
+	GTP_INFO("Parse config file: %s (%d bytes)", filename, len);
+
+	for (i = 0, cur_len = 0; i < len && cur_len < GTP_CONFIG_MAX_LENGTH;) {
+		if (buf[i] == ' ' || buf[i] == '\r' || buf[i] == '\n' || buf[i] == ',') {
+			i++;
+			continue;
+		}
+		if (buf[i] == '0' && (buf[i + 1] == 'x' || buf[i + 1] == 'X')) {
+
+			high = ascii2hex(buf[i + 2]);
+			low = ascii2hex(buf[i + 3]);
+
+			if (high != 0xFF && low != 0xFF) {
+				config[cur_len++] = (high << 4) + low;
+				i += 4;
+				continue;
+			}
+		}
+		GTP_ERROR("Illegal config file!");
+		cur_len = -1;
+		break;
+	}
+
+	if (cur_len < GTP_CONFIG_MIN_LENGTH || config[cur_len - 1] != 0x01) {
+		cur_len = -1;
+	} else {
+		for (i = 0; i < cur_len; i++) {
+			if (i % 10 == 0) {
+				printk("\n<<GTP-DBG>>:");
+			}
+			printk("0x%02x,", config[i]);
+		}
+		printk("\n");
+	}
+
+	kfree(buf);
+parse_cfg_fail2:
+	filp_close(fp, NULL);
+parse_cfg_fail1:
+	set_fs(old_fs);
+
+	return cur_len;
+}
+
+s32 _do_i2c_read(struct i2c_msg *msgs, u16 addr, u8 *buffer, s32 len)
+{
+	s32 ret = -1;
+	s32 pos = 0;
+	s32 data_length = len;
+	s32 transfer_length = 0;
+	u8 *data = NULL;
+	u16 address = addr;
+
+	data = kmalloc(IIC_MAX_TRANSFER_SIZE < (len + GTP_ADDR_LENGTH) ? IIC_MAX_TRANSFER_SIZE : (len + GTP_ADDR_LENGTH), GFP_KERNEL);
+	if (data == NULL) {
+		return ERROR_MEM;
+	}
+	msgs[1].buf = data;
+
+	while (pos != data_length) {
+		if ((data_length - pos) > IIC_MAX_TRANSFER_SIZE) {
+			transfer_length = IIC_MAX_TRANSFER_SIZE;
+		} else {
+			transfer_length = data_length - pos;
+		}
+		msgs[0].buf[0] = (address >> 8) & 0xFF;
+		msgs[0].buf[1] = address & 0xFF;
+		msgs[1].len = transfer_length;
+
+		ret = i2c_transfer(gt1x_i2c_client->adapter, msgs, 2);
+		if (ret != 2) {
+			GTP_ERROR("I2c Transfer error! (%d)", ret);
+			kfree(data);
+			return ERROR_IIC;
+		}
+		memcpy(&buffer[pos], msgs[1].buf, transfer_length);
+		pos += transfer_length;
+		address += transfer_length;
+	}
+
+	kfree(data);
+	return 0;
+}
+
+s32 _do_i2c_write(struct i2c_msg *msg, u16 addr, u8 *buffer, s32 len)
+{
+	s32 ret = -1;
+	s32 pos = 0;
+	s32 data_length = len;
+	s32 transfer_length = 0;
+	u8 *data = NULL;
+	u16 address = addr;
+
+	data = kmalloc(IIC_MAX_TRANSFER_SIZE < (len + GTP_ADDR_LENGTH) ? IIC_MAX_TRANSFER_SIZE : (len + GTP_ADDR_LENGTH), GFP_KERNEL);
+	if (data == NULL) {
+		return ERROR_MEM;
+	}
+	msg->buf = data;
+
+	while (pos != data_length) {
+		if ((data_length - pos) > (IIC_MAX_TRANSFER_SIZE - GTP_ADDR_LENGTH)) {
+			transfer_length = IIC_MAX_TRANSFER_SIZE - GTP_ADDR_LENGTH;
+		} else {
+			transfer_length = data_length - pos;
+		}
+
+		msg->buf[0] = (address >> 8) & 0xFF;
+		msg->buf[1] = address & 0xFF;
+		msg->len = transfer_length + GTP_ADDR_LENGTH;
+		memcpy(&msg->buf[GTP_ADDR_LENGTH], &buffer[pos], transfer_length);
+
+		ret = i2c_transfer(gt1x_i2c_client->adapter, msg, 1);
+		if (ret != 1) {
+			GTP_ERROR("I2c transfer error! (%d)", ret);
+			kfree(data);
+			return ERROR_IIC;
+		}
+		pos += transfer_length;
+		address += transfer_length;
+	}
+
+	kfree(data);
+	return 0;
+}
+
+#if !GTP_ESD_PROTECT
+static s32 gt1x_i2c_test(void)
+{
+	u8 retry = 0;
+	s32 ret = -1;
+	u32 hw_info = 0;
+	GTP_DEBUG_FUNC();
+
+	while (retry++ < 3) {
+		ret = gt1x_i2c_read(GTP_REG_HW_INFO, (u8 *) &hw_info, sizeof(hw_info));
+		if (!ret) {
+			GTP_INFO("Hardware Info:%08X", hw_info);
+			return ret;
+		}
+
+		msleep(10);
+		GTP_ERROR("Hardware Info:%08X", hw_info);
+		GTP_ERROR("I2c failed%d.", retry);
+	}
+
+	return ERROR_RETRY;
+}
+#endif
+
+/**
+ * gt1x_i2c_read_dbl_check - read twice and double check
+ * @addr: register address
+ * @buffer: data buffer
+ * @len: bytes to read
+ * Return    <0: i2c error, 0: ok, 1:fail
+ */
+s32 gt1x_i2c_read_dbl_check(u16 addr, u8 *buffer, s32 len)
+{
+	u8 buf[16] = { 0 };
+	u8 confirm_buf[16] = { 0 };
+	int ret;
+
+	if (len > 16) {
+		GTP_ERROR("i2c_read_dbl_check length %d is too long, exceed %zu", len, sizeof(buf));
+		return ERROR;
+	}
+
+	memset(buf, 0xAA, sizeof(buf));
+	ret = gt1x_i2c_read(addr, buf, len);
+	if (ret < 0) {
+		return ret;
+	}
+
+	msleep(5);
+	memset(confirm_buf, 0, sizeof(confirm_buf));
+	ret = gt1x_i2c_read(addr, confirm_buf, len);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (!memcmp(buf, confirm_buf, len)) {
+		memcpy(buffer, confirm_buf, len);
+		return 0;
+	}
+	GTP_ERROR("i2c read 0x%04X, %d bytes, double check failed!", addr, len);
+	return 1;
+}
+
+/**
+ * gt1x_get_info - Get information from ic, such as resolution and
+ * int trigger type
+ * Return    <0: i2c failed, 0: i2c ok
+ */
+s32 gt1x_get_info(void)
+{
+	u8 opr_buf[4] = { 0 };
+	s32 ret = 0;
+
+	ret = gt1x_i2c_read(GTP_REG_CONFIG_DATA + 1, opr_buf, 4);
+	if (ret < 0) {
+		return ret;
+	}
+
+	gt1x_abs_x_max = (opr_buf[1] << 8) + opr_buf[0];
+	gt1x_abs_y_max = (opr_buf[3] << 8) + opr_buf[2];
+
+	ret = gt1x_i2c_read(GTP_REG_CONFIG_DATA + 6, opr_buf, 1);
+	if (ret < 0) {
+		return ret;
+	}
+	gt1x_int_type = opr_buf[0] & 0x03;
+
+	GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x", gt1x_abs_x_max, gt1x_abs_y_max, gt1x_int_type);
+
+	return 0;
+}
+
+/**
+ * gt1x_send_cfg - Send gt1x_config Function.
+ * @config: pointer of the configuration array.
+ * @cfg_len: length of configuration array.
+ * Return 0--success,non-0--fail.
+ */
+s32 gt1x_send_cfg(u8 *config, int cfg_len)
+{
+#if GTP_DRIVER_SEND_CFG
+	static DEFINE_MUTEX(mutex_cfg);
+	int i;
+	s32 ret = 0;
+	s32 retry = 0;
+	u16 checksum = 0;
+
+	if (update_info.status) {
+		GTP_DEBUG("Ignore cfg during fw update.");
+		return -1;
+	}
+	mutex_lock(&mutex_cfg);
+	GTP_DEBUG("Driver send config, length:%d", cfg_len);
+	for (i = 0; i < cfg_len - 3; i += 2) {
+		checksum += (config[i] << 8) + config[i + 1];
+	}
+	if (!checksum) {
+		GTP_ERROR("Invalid config, all of the bytes is zero!");
+		mutex_unlock(&mutex_cfg);
+		return -1;
+	}
+	checksum = 0 - checksum;
+	GTP_DEBUG("Config checksum: 0x%04X", checksum);
+	config[cfg_len - 3] = (checksum >> 8) & 0xFF;
+	config[cfg_len - 2] = checksum & 0xFF;
+	config[cfg_len - 1] = 0x01;
+
+	while (retry++ < 5) {
+		ret = gt1x_i2c_write(GTP_REG_CONFIG_DATA, config, cfg_len);
+		if (!ret) {
+			msleep(200);	/* at least 200ms, wait for storing config into flash. */
+			mutex_unlock(&mutex_cfg);
+			GTP_DEBUG("Send config successfully!");
+			return 0;
+		}
+	}
+	GTP_ERROR("Send config failed!");
+	mutex_unlock(&mutex_cfg);
+	return ret;
+#endif
+	return 0;
+}
+
+/**
+ * gt1x_init_panel - Prepare config data for touch ic, don't call this function
+ * after initialization.
+ *
+ * Return 0--success,<0 --fail.
+ */
+s32 gt1x_init_panel(void)
+{
+	s32 ret = 0;
+	u8 cfg_len = 0;
+
+#if GTP_DRIVER_SEND_CFG
+	u8 sensor_id = 0;
+
+	const u8 cfg_grp0[] = GTP_CFG_GROUP0;
+	const u8 cfg_grp1[] = GTP_CFG_GROUP1;
+	const u8 cfg_grp2[] = GTP_CFG_GROUP2;
+	const u8 cfg_grp3[] = GTP_CFG_GROUP3;
+	const u8 cfg_grp4[] = GTP_CFG_GROUP4;
+	const u8 cfg_grp5[] = GTP_CFG_GROUP5;
+	const u8 *cfgs[] = {
+		cfg_grp0, cfg_grp1, cfg_grp2,
+		cfg_grp3, cfg_grp4, cfg_grp5
+	};
+	u8 cfg_lens[] = {
+		CFG_GROUP_LEN(cfg_grp0),
+		CFG_GROUP_LEN(cfg_grp1),
+		CFG_GROUP_LEN(cfg_grp2),
+		CFG_GROUP_LEN(cfg_grp3),
+		CFG_GROUP_LEN(cfg_grp4),
+		CFG_GROUP_LEN(cfg_grp5)
+	};
+
+	GTP_DEBUG("Config groups length:%d,%d,%d,%d,%d,%d", cfg_lens[0], cfg_lens[1], cfg_lens[2], cfg_lens[3], cfg_lens[4], cfg_lens[5]);
+
+	sensor_id = gt1x_version.sensor_id;
+	if (sensor_id >= 6 || cfg_lens[sensor_id] < GTP_CONFIG_MIN_LENGTH || cfg_lens[sensor_id] > GTP_CONFIG_MAX_LENGTH) {
+		sensor_id = 0;
+		gt1x_version.sensor_id = 0;
+	}
+
+	cfg_len = cfg_lens[sensor_id];
+
+	GTP_INFO("Config group%d used, length:%d", sensor_id, cfg_len);
+
+	if (cfg_len < GTP_CONFIG_MIN_LENGTH || cfg_len > GTP_CONFIG_MAX_LENGTH) {
+		GTP_ERROR("Config group%d is INVALID! You need to check you header file CFG_GROUP section!", sensor_id + 1);
+		return -1;
+	}
+
+	memset(gt1x_config, 0, sizeof(gt1x_config));
+	memcpy(gt1x_config, cfgs[sensor_id], cfg_len);
+
+	/* clear the flag, avoid failure when send the_config of driver. */
+	gt1x_config[0] &= 0x7F;
+
+#if GTP_CUSTOM_CFG
+	gt1x_config[RESOLUTION_LOC] = (u8) GTP_MAX_WIDTH;
+	gt1x_config[RESOLUTION_LOC + 1] = (u8) (GTP_MAX_WIDTH >> 8);
+	gt1x_config[RESOLUTION_LOC + 2] = (u8) GTP_MAX_HEIGHT;
+	gt1x_config[RESOLUTION_LOC + 3] = (u8) (GTP_MAX_HEIGHT >> 8);
+
+	if (GTP_INT_TRIGGER == 0) {	/* RISING  */
+		gt1x_config[TRIGGER_LOC] &= 0xfe;
+	} else if (GTP_INT_TRIGGER == 1) {	/* FALLING */
+		gt1x_config[TRIGGER_LOC] |= 0x01;
+	}
+	set_reg_bit(gt1x_config[MODULE_SWITCH3_LOC], 5, !gt1x_wakeup_level);
+#endif /* END GTP_CUSTOM_CFG */
+
+#else /* DRIVER NOT SEND CONFIG */
+	cfg_len = GTP_CONFIG_MAX_LENGTH;
+	ret = gt1x_i2c_read(GTP_REG_CONFIG_DATA, gt1x_config, cfg_len);
+	if (ret < 0) {
+		return ret;
+	}
+#endif /* END GTP_DRIVER_SEND_CFG */
+
+	GTP_DEBUG_FUNC();
+	/* match resolution when gt1x_abs_x_max & gt1x_abs_y_max have been set already */
+	if ((gt1x_abs_x_max == 0) && (gt1x_abs_y_max == 0)) {
+		gt1x_abs_x_max = (gt1x_config[RESOLUTION_LOC + 1] << 8) + gt1x_config[RESOLUTION_LOC];
+		gt1x_abs_y_max = (gt1x_config[RESOLUTION_LOC + 3] << 8) + gt1x_config[RESOLUTION_LOC + 2];
+		gt1x_int_type = (gt1x_config[TRIGGER_LOC]) & 0x03;
+		gt1x_wakeup_level = !(gt1x_config[MODULE_SWITCH3_LOC] & 0x20);
+	} else {
+		gt1x_config[RESOLUTION_LOC] = (u8) gt1x_abs_x_max;
+		gt1x_config[RESOLUTION_LOC + 1] = (u8) (gt1x_abs_x_max >> 8);
+		gt1x_config[RESOLUTION_LOC + 2] = (u8) gt1x_abs_y_max;
+		gt1x_config[RESOLUTION_LOC + 3] = (u8) (gt1x_abs_y_max >> 8);
+		set_reg_bit(gt1x_config[MODULE_SWITCH3_LOC], 5, !gt1x_wakeup_level);
+		gt1x_config[TRIGGER_LOC] = (gt1x_config[TRIGGER_LOC] & 0xFC) | gt1x_int_type;
+	}
+
+	GTP_INFO("X_MAX=%d,Y_MAX=%d,TRIGGER=0x%02x,WAKEUP_LEVEL=%d", gt1x_abs_x_max, gt1x_abs_y_max, gt1x_int_type, gt1x_wakeup_level);
+
+	gt1x_cfg_length = cfg_len;
+	ret = gt1x_send_cfg(gt1x_config, gt1x_cfg_length);
+	return ret;
+}
+
+void gt1x_select_addr(void)
+{
+	GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
+	GTP_GPIO_OUTPUT(GTP_INT_PORT, gt1x_i2c_client->addr == 0x14);
+	msleep(2);
+	GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
+	msleep(2);
+}
+
+static s32 gt1x_set_reset_status(void)
+{
+	/* 0x8040 ~ 0x8043 */
+	u8 value[] = {0xAA, 0x00, 0x56, 0xAA};
+	int ret;
+
+	GTP_DEBUG("Set reset status.");
+	ret = gt1x_i2c_write(GTP_REG_CMD + 1, &value[1], 3);
+	if (ret < 0)
+		return ret;
+
+	return gt1x_i2c_write(GTP_REG_CMD, value, 1);
+}
+
+#if GTP_INCELL_PANEL
+int gt1x_write_and_readback(u16 addr, u8 *buffer, s32 len)
+{
+	int ret;
+	u8 d[len];
+
+	ret = gt1x_i2c_write(addr, buffer, len);
+	if (ret < 0)
+		return -1;
+
+	ret = gt1x_i2c_read(addr, d, len);
+	if (ret < 0 || memcmp(buffer, d, len))
+		return -1;
+
+	return 0;
+}
+
+int gt1x_incell_reset(void)
+{
+#define RST_RETRY       5
+	int ret, retry = RST_RETRY;
+	u8 d[2];
+
+	do {
+		/* select i2c address */
+		gt1x_select_addr();
+
+		/* test i2c */
+		ret = gt1x_i2c_read(0x4220, d, 1);
+
+	} while (--retry && ret < 0);
+
+	if (ret < 0) {
+		return -1;
+	}
+
+	/* Stop cpu of the touch ic */
+	retry = RST_RETRY;
+	do {
+		d[0] = 0x0C;
+		ret = gt1x_write_and_readback(0x4180, d, 1);
+
+	} while (--retry && ret < 0);
+
+	if (ret < 0) {
+		GTP_ERROR("Hold error.");
+		return -1;
+	}
+
+	/* skip sensor id check. [start] */
+	retry = RST_RETRY;
+	do {
+		d[0] = 0x00;
+		ret = gt1x_write_and_readback(0x4305, d, 1);
+		if (ret < 0)
+			continue;
+
+		d[0] = 0x2B;
+		d[1] = 0x24;
+		ret = gt1x_write_and_readback(0x42c4, d, 2);
+		if (ret < 0)
+			continue;
+
+		d[0] = 0xE1;
+		d[1] = 0xD3;
+		ret = gt1x_write_and_readback(0x42e4, d, 2);
+		if (ret < 0)
+			continue;
+		d[0] = 0x01;
+		ret = gt1x_write_and_readback(0x4305, d, 1);
+		if (ret < 0)
+			continue;
+		else
+			break;
+	} while (--retry);
+
+	if (!retry)
+		return -1;
+	/* skip sensor id check. [end] */
+
+	/* release hold of cpu */
+	retry = RST_RETRY;
+	do {
+		d[0] = 0x00;
+		ret = gt1x_write_and_readback(0x4180, d, 1);
+
+	} while (--retry && ret < 0);
+
+	if (ret < 0)
+		return -1;
+
+	return 0;
+}
+#endif
+
+s32 gt1x_reset_guitar(void)
+{
+	int ret;
+
+	GTP_INFO("GTP RESET!");
+
+#if GTP_INCELL_PANEL
+	ret = gt1x_incell_reset();
+	if (ret < 0)
+		return ret;
+#else
+	gt1x_select_addr();
+	msleep(8);     /* must >= 6ms */
+#endif
+
+	/* int synchronization */
+	GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+	msleep(50);
+	GTP_GPIO_AS_INT(GTP_INT_PORT);
+
+	/* this operation is necessary even when the esd check
+	   fucntion dose not turn on */
+	ret = gt1x_set_reset_status();
+	return ret;
+}
+
+/**
+ * gt1x_read_version - Read gt1x version info.
+ * @ver_info: address to store version info
+ * Return 0-succeed.
+ */
+s32 gt1x_read_version(struct gt1x_version_info *ver_info)
+{
+	s32 ret = -1;
+	u8 buf[12] = { 0 };
+	u32 mask_id = 0;
+	u32 patch_id = 0;
+	u8 product_id[5] = { 0 };
+	u8 sensor_id = 0;
+	u8 match_opt = 0;
+	int i, retry = 3;
+	u8 checksum = 0;
+
+	GTP_DEBUG_FUNC();
+
+	while (retry--) {
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_VERSION, buf, sizeof(buf));
+		if (!ret) {
+			checksum = 0;
+
+			for (i = 0; i < sizeof(buf); i++) {
+				checksum += buf[i];
+			}
+
+			if (checksum == 0 &&	/* first 3 bytes must be number or char */
+			    IS_NUM_OR_CHAR(buf[0]) && IS_NUM_OR_CHAR(buf[1]) && IS_NUM_OR_CHAR(buf[2]) && buf[10] != 0xFF) {	/*sensor id == 0xFF, retry */
+				break;
+			} else {
+				GTP_ERROR("Read version failed!(checksum error)");
+			}
+		} else {
+			GTP_ERROR("Read version failed!");
+		}
+		GTP_DEBUG("Read version : %d", retry);
+		msleep(100);
+	}
+
+	if (retry <= 0) {
+		if (ver_info)
+			ver_info->sensor_id = 0;
+		return -1;
+	}
+
+	mask_id = (u32) ((buf[7] << 16) | (buf[8] << 8) | buf[9]);
+	patch_id = (u32) ((buf[4] << 16) | (buf[5] << 8) | buf[6]);
+	memcpy(product_id, buf, 4);
+	sensor_id = buf[10] & 0x0F;
+	match_opt = (buf[10] >> 4) & 0x0F;
+
+	GTP_INFO("IC VERSION:GT%s_%06X(Patch)_%04X(Mask)_%02X(SensorID)", product_id, patch_id, mask_id >> 8, sensor_id);
+
+	if (ver_info != NULL) {
+		ver_info->mask_id = mask_id;
+		ver_info->patch_id = patch_id;
+		memcpy(ver_info->product_id, product_id, 5);
+		ver_info->sensor_id = sensor_id;
+		ver_info->match_opt = match_opt;
+	}
+	return 0;
+}
+
+/**
+ * gt1x_get_chip_type - get chip type .
+ *
+ * different chip synchronize in different way,
+ */
+s32 gt1x_get_chip_type(void)
+{
+	u8 opr_buf[4] = { 0x00 };
+	u8 gt1x_data[] = { 0x02, 0x08, 0x90, 0x00 };
+	u8 gt9l_data[] = { 0x03, 0x10, 0x90, 0x00 };
+	s32 ret = -1;
+
+	/* chip type already exist */
+	if (gt1x_chip_type != CHIP_TYPE_NONE) {
+		return 0;
+	}
+
+	/* read hardware */
+	ret = gt1x_i2c_read_dbl_check(GTP_REG_HW_INFO, opr_buf, sizeof(opr_buf));
+	if (ret) {
+		GTP_ERROR("I2c communication error.");
+		return -1;
+	}
+
+	/* find chip type */
+	if (!memcmp(opr_buf, gt1x_data, sizeof(gt1x_data))) {
+		gt1x_chip_type = CHIP_TYPE_GT1X;
+	} else if (!memcmp(opr_buf, gt9l_data, sizeof(gt9l_data))) {
+		gt1x_chip_type = CHIP_TYPE_GT2X;
+	}
+
+	if (gt1x_chip_type != CHIP_TYPE_NONE) {
+		GTP_INFO("Chip Type: %s", (gt1x_chip_type == CHIP_TYPE_GT1X) ? "GT1X" : "GT2X");
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+/**
+ * gt1x_enter_sleep - Eter sleep function.
+ *
+ * Returns  0--success,non-0--fail.
+ */
+static s32 gt1x_enter_sleep(void)
+{
+#if GTP_POWER_CTRL_SLEEP
+	gt1x_power_switch(SWITCH_OFF);
+	return 0;
+#else
+	{
+		s32 retry = 0;
+		if (gt1x_wakeup_level == 1) {	/* high level wakeup */
+			GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+		}
+		msleep(5);
+
+		while (retry++ < 3) {
+			if (!gt1x_send_cmd(GTP_CMD_SLEEP, 0)) {
+				GTP_INFO("Enter sleep mode!");
+				return 0;
+			}
+			msleep(10);
+		}
+
+		GTP_ERROR("Enter sleep mode failed.");
+		return -1;
+	}
+#endif
+}
+
+/**
+ * gt1x_wakeup_sleep - wakeup from sleep mode Function.
+ *
+ * Return: 0--success,non-0--fail.
+ */
+static s32 gt1x_wakeup_sleep(void)
+{
+#if !GTP_POWER_CTRL_SLEEP
+	u8 retry = 0;
+	s32 ret = -1;
+	int flag = 0;
+#endif
+
+	GTP_DEBUG("Wake up begin.");
+	gt1x_irq_disable();
+
+#if GTP_POWER_CTRL_SLEEP	/* power manager unit control the procedure */
+	gt1x_power_reset();
+	GTP_INFO("Wakeup by poweron");
+	return 0;
+#else /* gesture wakeup & int port wakeup */
+	while (retry++ < 2) {
+#if GTP_GESTURE_WAKEUP
+		if (gesture_enabled) {
+			gesture_doze_status = DOZE_DISABLED;
+			ret = gt1x_reset_guitar();
+			if (!ret) {
+				break;
+			}
+		} else
+#endif
+		{
+			/* wake up through int port */
+			GTP_GPIO_OUTPUT(GTP_INT_PORT, gt1x_wakeup_level);
+			msleep(5);
+
+			/* Synchronize int IO */
+			GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+			msleep(50);
+			GTP_GPIO_AS_INT(GTP_INT_PORT);
+			flag = 1;
+
+#if GTP_ESD_PROTECT
+			ret = gt1x_set_reset_status();
+#else
+			ret = gt1x_i2c_test();
+#endif
+			if (!ret)
+				break;
+		} /* end int wakeup */
+	}
+
+	if (ret < 0 && flag) {		/* int  wakeup failed , try waking up by reset */
+		while (retry--) {
+			ret = gt1x_reset_guitar();
+			if (!ret)
+				break;
+		}
+	}
+
+	if (ret) {
+		GTP_ERROR("Wake up sleep failed.");
+		return -1;
+	} else {
+		GTP_INFO("Wake up end.");
+		return 0;
+	}
+#endif /* END GTP_POWER_CTRL_SLEEP */
+}
+
+/**
+ * gt1x_send_cmd - seng cmd
+ * must write data & checksum first
+ * byte    content
+ * 0       cmd
+ * 1       data
+ * 2       checksum
+ * Returns 0 - succeed,non-0 - failed
+ */
+s32 gt1x_send_cmd(u8 cmd, u8 data)
+{
+	s32 ret;
+	static DEFINE_MUTEX(cmd_mutex);
+	u8 buffer[3] = { cmd, data, 0 };
+
+	mutex_lock(&cmd_mutex);
+	buffer[2] = (u8) ((0 - cmd - data) & 0xFF);
+	ret = gt1x_i2c_write(GTP_REG_CMD + 1, &buffer[1], 2);
+	ret |= gt1x_i2c_write(GTP_REG_CMD, &buffer[0], 1);
+	msleep(50);
+	mutex_unlock(&cmd_mutex);
+
+	return ret;
+}
+
+void gt1x_power_reset(void)
+{
+	static int rst_flag;
+	s32 i = 0;
+
+	if (rst_flag || update_info.status) {
+		return;
+	}
+	GTP_INFO("force_reset_guitar");
+	rst_flag = 1;
+	gt1x_irq_disable();
+	gt1x_power_switch(SWITCH_OFF);
+	msleep(30);
+	gt1x_power_switch(SWITCH_ON);
+	msleep(30);
+
+	for (i = 0; i < 5; i++) {
+		if (gt1x_reset_guitar()) {
+			continue;
+		}
+		if (gt1x_send_cfg(gt1x_config, gt1x_cfg_length)) {
+			msleep(500);
+			continue;
+		}
+		break;
+	}
+	gt1x_irq_enable();
+	rst_flag = 0;
+}
+
+s32 gt1x_request_event_handler(void)
+{
+	s32 ret = -1;
+	u8 rqst_data = 0;
+
+	ret = gt1x_i2c_read(GTP_REG_RQST, &rqst_data, 1);
+	if (ret) {
+		GTP_ERROR("I2C transfer error. errno:%d", ret);
+		return -1;
+	}
+	GTP_DEBUG("Request state:0x%02x.", rqst_data);
+	switch (rqst_data & 0x0F) {
+	case GTP_RQST_CONFIG:
+		GTP_INFO("Request Config.");
+		ret = gt1x_send_cfg(gt1x_config, gt1x_cfg_length);
+		if (ret) {
+			GTP_ERROR("Send gt1x_config error.");
+		} else {
+			GTP_INFO("Send gt1x_config success.");
+			rqst_data = GTP_RQST_RESPONDED;
+			gt1x_i2c_write(GTP_REG_RQST, &rqst_data, 1);
+		}
+		break;
+	case GTP_RQST_RESET:
+		GTP_INFO("Request Reset.");
+		gt1x_reset_guitar();
+		rqst_data = GTP_RQST_RESPONDED;
+		gt1x_i2c_write(GTP_REG_RQST, &rqst_data, 1);
+		break;
+	case GTP_RQST_BAK_REF:
+		GTP_INFO("Request Ref.");
+		break;
+	case GTP_RQST_MAIN_CLOCK:
+		GTP_INFO("Request main clock.");
+		break;
+#if GTP_HOTKNOT
+	case GTP_RQST_HOTKNOT_CODE:
+		GTP_INFO("Request HotKnot Code.");
+		break;
+#endif
+	default:
+		break;
+	}
+	return 0;
+}
+
+/**
+ * gt1x_touch_event_handler - handle touch event
+ * (pen event, key event, finger touch envent)
+ * @data:
+ * Return    <0: failed, 0: succeed
+ */
+s32 gt1x_touch_event_handler(u8 *data, struct input_dev *dev, struct input_dev *pen_dev)
+{
+	u8 touch_data[1 + 8 * GTP_MAX_TOUCH + 2] = { 0 };
+	static u16 pre_event;
+	static u16 pre_index;
+	u8 touch_num = 0;
+	u8 key_value = 0;
+	u16 cur_event = 0;
+	u8 *coor_data = NULL;
+	u8 check_sum = 0;
+	s32 input_x = 0;
+	s32 input_y = 0;
+	s32 input_w = 0;
+	s32 id = 0;
+	s32 i = 0;
+	s32 ret = -1;
+
+	GTP_DEBUG_FUNC();
+	touch_num = data[0] & 0x0f;
+	if (touch_num > GTP_MAX_TOUCH) {
+		GTP_ERROR("Illegal finger number!");
+		return ERROR_VALUE;
+	}
+
+	memcpy(touch_data, data, 11);
+
+	/* read the remaining coor data
+	 * 0x814E(touch status) + 8(every coordinate consist of 8 bytes data) * touch num +
+	 * keycode + checksum
+	 */
+	if (touch_num > 1) {
+		ret = gt1x_i2c_read((GTP_READ_COOR_ADDR + 11), &touch_data[11], 1 + 8 * touch_num + 2 - 11);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	/* cacl checksum */
+	for (i = 0; i < 1 + 8 * touch_num + 2; i++) {
+		check_sum += touch_data[i];
+	}
+	if (check_sum) { /* checksum error*/
+		ret = gt1x_i2c_read(GTP_READ_COOR_ADDR, touch_data, 3 + 8 * touch_num);
+		if (ret) {
+			return ret;
+		}
+
+		for (i = 0, check_sum = 0; i < 3 + 8 * touch_num; i++) {
+			check_sum += touch_data[i];
+		}
+		if (check_sum) {
+			GTP_ERROR("Checksum error[%x]", check_sum);
+			return ERROR_VALUE;
+		}
+	}
+	/*
+	 * cur_event , pre_event bit defination
+	 * bits:     bit4	bit3		    bit2	 bit1	   bit0
+	 * event:  hover  stylus_key  stylus    key    touch
+	 */
+	key_value = touch_data[1 + 8 * touch_num];
+	/*  start check current event */
+	if ((touch_data[0] & 0x10) && key_value) {
+#if (GTP_HAVE_STYLUS_KEY || GTP_HAVE_TOUCH_KEY || TPD_HAVE_BUTTON)
+		/* get current key states */
+		if (key_value & 0xF0) {
+			SET_BIT(cur_event, BIT_STYLUS_KEY);
+		} else if (key_value & 0x0F) {
+			SET_BIT(cur_event, BIT_TOUCH_KEY);
+		}
+#endif
+	}
+#if GTP_WITH_STYLUS
+	else if (touch_data[1] & 0x80) {
+		SET_BIT(cur_event, BIT_STYLUS);
+	}
+#endif
+	else if (touch_num) {
+		SET_BIT(cur_event, BIT_TOUCH);
+	}
+
+	/* start handle current event and pre-event */
+#if GTP_HAVE_STYLUS_KEY
+	if (CHK_BIT(cur_event, BIT_STYLUS_KEY) || CHK_BIT(pre_event, BIT_STYLUS_KEY)) {
+		/*
+		 * 0x10 -- stylus key0 down
+		 * 0x20 -- stylus key1 down
+		 * 0x40 -- stylus key0 & stylus key1 both down
+		 */
+		u8 temp = (key_value & 0x40) ? 0x30 : key_value;
+		for (i = 4; i < 6; i++) {
+			input_report_key(pen_dev, gt1x_stylus_key_array[i - 4], temp & (0x01 << i));
+		}
+		GTP_DEBUG("Stulus key event.");
+	}
+#endif
+
+#if GTP_WITH_STYLUS
+	if (CHK_BIT(cur_event, BIT_STYLUS)) {
+		coor_data = &touch_data[1];
+		id = coor_data[0] & 0x7F;
+		input_x = coor_data[1] | (coor_data[2] << 8);
+		input_y = coor_data[3] | (coor_data[4] << 8);
+		input_w = coor_data[5] | (coor_data[6] << 8);
+
+		input_x = GTP_WARP_X(gt1x_abs_x_max, input_x);
+		input_y = GTP_WARP_Y(gt1x_abs_y_max, input_y);
+
+		GTP_DEBUG("Pen touch DOWN.");
+		gt1x_pen_down(input_x, input_y, input_w, 0);
+	} else if (CHK_BIT(pre_event, BIT_STYLUS)) {
+		GTP_DEBUG("Pen touch UP.");
+		gt1x_pen_up(0);
+	}
+#endif
+
+#if GTP_HAVE_TOUCH_KEY
+	if (CHK_BIT(cur_event, BIT_TOUCH_KEY) || CHK_BIT(pre_event, BIT_TOUCH_KEY)) {
+		for (i = 0; i < GTP_MAX_KEY_NUM; i++) {
+			input_report_key(dev, gt1x_touch_key_array[i], key_value & (0x01 << i));
+		}
+		if (CHK_BIT(cur_event, BIT_TOUCH_KEY)) {
+			GTP_DEBUG("Key Down.");
+		} else {
+			GTP_DEBUG("Key Up.");
+		}
+	}
+#elif TPD_HAVE_BUTTON
+	if (CHK_BIT(cur_event, BIT_TOUCH_KEY) || CHK_BIT(pre_event, BIT_TOUCH_KEY)) {
+		for (i = 0; i < TPD_KEY_COUNT; i++) {
+			if (key_value & (0x01 << i)) {
+				gt1x_touch_down(tpd_virtual_key_array[i].x, tpd_virtual_key_array[i].y, 0, 0);
+				GTP_DEBUG("Key Down.");
+				break;
+			}
+		}
+		if (i == TPD_KEY_COUNT) {
+			gt1x_touch_up(0);
+			GTP_DEBUG("Key Up.");
+		}
+	}
+#endif
+
+	/* finger touch event*/
+	if (CHK_BIT(cur_event, BIT_TOUCH)) {
+		u8 report_num = 0;
+		coor_data = &touch_data[1];
+		id = coor_data[0] & 0x0F;
+		for (i = 0; i < GTP_MAX_TOUCH; i++) {
+			if (i == id) {
+				input_x = coor_data[1] | (coor_data[2] << 8);
+				input_y = coor_data[3] | (coor_data[4] << 8);
+				input_w = coor_data[5] | (coor_data[6] << 8);
+
+				input_x = GTP_WARP_X(gt1x_abs_x_max, input_x);
+				input_y = GTP_WARP_Y(gt1x_abs_y_max, input_y);
+
+				GTP_DEBUG("(%d)(%d,%d)[%d]", id, input_x, input_y, input_w);
+				gt1x_touch_down(input_x, input_y, input_w, i);
+				if (report_num++ < touch_num) {
+					coor_data += 8;
+					id = coor_data[0] & 0x0F;
+				}
+				pre_index |= 0x01 << i;
+			} else if (pre_index & (0x01 << i)) {
+#if GTP_ICS_SLOT_REPORT
+				gt1x_touch_up(i);
+#endif
+				pre_index &= ~(0x01 << i);
+			}
+		}
+	} else if (CHK_BIT(pre_event, BIT_TOUCH)) {
+#if GTP_ICS_SLOT_REPORT
+		int cycles = pre_index < 3 ? 3 : GTP_MAX_TOUCH;
+		for (i = 0; i < cycles; i++) {
+			if (pre_index >> i & 0x01) {
+				gt1x_touch_up(i);
+			}
+		}
+#else
+		gt1x_touch_up(0);
+#endif
+		GTP_DEBUG("Released Touch.");
+		pre_index = 0;
+	}
+
+	/* start sync input report */
+	if (CHK_BIT(cur_event, BIT_STYLUS_KEY | BIT_STYLUS)
+			|| CHK_BIT(pre_event, BIT_STYLUS_KEY | BIT_STYLUS)) {
+		input_sync(pen_dev);
+	}
+
+	if (CHK_BIT(cur_event, BIT_TOUCH_KEY | BIT_TOUCH)
+			|| CHK_BIT(pre_event, BIT_TOUCH_KEY | BIT_TOUCH)) {
+		input_sync(dev);
+	}
+
+	if (unlikely(!pre_event && !cur_event)) {
+		GTP_DEBUG("Additional Int Pulse.");
+	} else {
+		pre_event = cur_event;
+	}
+
+	return 0;
+}
+
+#if GTP_WITH_STYLUS
+struct input_dev *pen_dev;
+
+static void gt1x_pen_init(void)
+{
+	s32 ret = 0;
+
+	pen_dev = input_allocate_device();
+	if (pen_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device for pen/stylus.");
+		return;
+	}
+
+	pen_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	set_bit(BTN_TOOL_PEN, pen_dev->keybit);
+	set_bit(INPUT_PROP_DIRECT, pen_dev->propbit);
+
+#if GTP_HAVE_STYLUS_KEY
+	input_set_capability(pen_dev, EV_KEY, BTN_STYLUS);
+	input_set_capability(pen_dev, EV_KEY, BTN_STYLUS2);
+#endif
+
+	input_set_abs_params(pen_dev, ABS_MT_POSITION_X, 0, gt1x_abs_x_max, 0, 0);
+	input_set_abs_params(pen_dev, ABS_MT_POSITION_Y, 0, gt1x_abs_y_max, 0, 0);
+	input_set_abs_params(pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	pen_dev->name = "goodix-pen";
+	pen_dev->phys = "input/ts";
+	pen_dev->id.bustype = BUS_I2C;
+
+	ret = input_register_device(pen_dev);
+	if (ret) {
+		GTP_ERROR("Register %s input device failed", pen_dev->name);
+		return;
+	}
+}
+
+void gt1x_pen_down(s32 x, s32 y, s32 size, s32 id)
+{
+	input_report_key(pen_dev, BTN_TOOL_PEN, 1);
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
+
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(pen_dev, id);
+	input_report_abs(pen_dev, ABS_MT_PRESSURE, size);
+	input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, size);
+	input_report_abs(pen_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(pen_dev, ABS_MT_POSITION_Y, y);
+#else
+	input_report_key(pen_dev, BTN_TOUCH, 1);
+	if ((!size) && (!id)) {
+		/* for virtual button */
+		input_report_abs(pen_dev, ABS_MT_PRESSURE, 100);
+		input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, 100);
+	} else {
+		input_report_abs(pen_dev, ABS_MT_PRESSURE, size);
+		input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, size);
+		input_report_abs(pen_dev, ABS_MT_TRACKING_ID, id);
+	}
+	input_report_abs(pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(pen_dev, ABS_MT_POSITION_Y, y);
+	input_mt_sync(pen_dev);
+#endif
+}
+
+void gt1x_pen_up(s32 id)
+{
+	input_report_key(pen_dev, BTN_TOOL_PEN, 0);
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(pen_dev, id);
+	input_report_abs(pen_dev, ABS_MT_TRACKING_ID, -1);
+#else
+	input_report_key(pen_dev, BTN_TOUCH, 0);
+	input_mt_sync(pen_dev);
+#endif
+}
+#endif
+
+/**
+ * Proximity Module
+ */
+#if GTP_PROXIMITY
+#define GTP_PS_DEV_NAME             "goodix_proximity"
+#define GTP_REG_PROXIMITY_ENABLE    0x8049
+#define PS_FARAWAY                  1
+#define PS_NEAR                     0
+struct gt1x_ps_device{
+    int enabled; /* module enabled/disabled */
+    int state;   /* Faraway or Near */
+#ifdef PLATFORM_MTK
+    struct hwmsen_object obj_ps;
+#else
+    struct input_dev *input_dev;
+    struct kobject *kobj;
+#endif
+};
+static struct gt1x_ps_device *gt1x_ps_dev;
+
+static void gt1x_ps_report(int state)
+{
+#ifdef PLATFORM_MTK
+	s32 ret = -1;
+
+	hwm_sensor_data sensor_data;
+	/*map and store data to hwm_sensor_data*/
+	sensor_data.values[0] = !!state;
+	sensor_data.value_divide = 1;
+	sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+	/*report to the up-layer*/
+	ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
+	if (ret) {
+		GTP_ERROR("Call hwmsen_get_interrupt_data fail = %d\n", ret);
+	}
+#else
+	input_report_abs(gt1x_ps_dev->input_dev, ABS_DISTANCE, !!state);
+	input_sync(gt1x_ps_dev->input_dev);
+#endif /* End PLATFROM_MTK */
+
+	GTP_INFO("Report proximity state: %s", state == PS_FARAWAY ? "FARAWAY":"NEAR");
+}
+
+static s32 gt1x_ps_enable(s32 enable)
+{
+	u8 state;
+	s32 ret = -1;
+
+	GTP_INFO("Proximity function to be %s.", enable ? "on" : "off");
+	state = enable ? 1 : 0;
+	if (gt1x_chip_type == CHIP_TYPE_GT1X)
+		ret = gt1x_i2c_write(GTP_REG_PROXIMITY_ENABLE, &state, 1);
+	else if (gt1x_chip_type == CHIP_TYPE_GT2X)
+		ret = gt1x_send_cmd(state ? 0x12 : 0x13, 0);
+	if (ret) {
+		GTP_ERROR("GTP %s proximity cmd failed.", state ? "enable" : "disable");
+	}
+
+	if (!ret && enable) {
+		gt1x_ps_dev->enabled = 1;
+	} else {
+		gt1x_ps_dev->enabled = 0;
+	}
+	gt1x_ps_dev->state = PS_FARAWAY;
+	GTP_INFO("Proximity function %s %s.", state ? "enable" : "disable", ret ? "fail" : "success");
+	return ret;
+}
+
+int gt1x_prox_event_handler(u8 *data)
+{
+	u8 ps = 0;
+
+	if (gt1x_ps_dev && gt1x_ps_dev->enabled) {
+		ps = (data[0] & 0x60) ? 0 : 1;
+		if (ps != gt1x_ps_dev->state) {
+			gt1x_ps_report(ps);
+			gt1x_ps_dev->state = ps;
+			GTP_DEBUG("REG INDEX[0x814E]:0x%02X\n", data[0]);
+		}
+
+		return (ps == PS_NEAR ? 1 : 0);
+	}
+	return -1;
+}
+
+#ifdef PLATFORM_MTK
+static inline s32 gt1x_get_ps_value(void)
+{
+	return gt1x_ps_dev->state;
+}
+
+static s32 gt1x_ps_operate(void *self, u32 command, void *buff_in, s32 size_in, void *buff_out, s32 size_out, s32 *actualout)
+{
+	s32 err = 0;
+	s32 value;
+	hwm_sensor_data *sensor_data;
+
+	GTP_INFO("psensor operator cmd:%d", command);
+	switch (command) {
+	case SENSOR_DELAY:
+		if ((buff_in == NULL) || (size_in < sizeof(int))) {
+			GTP_ERROR("Set delay parameter error!");
+			err = -EINVAL;
+		}
+		/*Do nothing*/
+		break;
+
+	case SENSOR_ENABLE:
+		if ((buff_in == NULL) || (size_in < sizeof(int))) {
+			GTP_ERROR("Enable sensor parameter error!");
+			err = -EINVAL;
+		} else {
+			value = *(int *)buff_in;
+			err = gt1x_ps_enable(value);
+		}
+
+		break;
+
+	case SENSOR_GET_DATA:
+		if ((buff_out == NULL) || (size_out < sizeof(hwm_sensor_data))) {
+			GTP_ERROR("Get sensor data parameter error!");
+			err = -EINVAL;
+		} else {
+			sensor_data = (hwm_sensor_data *) buff_out;
+			sensor_data->values[0] = gt1x_get_ps_value();
+			sensor_data->value_divide = 1;
+			sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
+		}
+
+		break;
+
+	default:
+		GTP_ERROR("proxmy sensor operate function no this parameter %d!\n", command);
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+#endif
+
+#ifndef PLATFORM_MTK
+static ssize_t gt1x_ps_enable_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d", gt1x_ps_dev->enabled);
+}
+
+static ssize_t gt1x_ps_enable_store(struct kobject *kobj, struct kobj_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	if (sscanf(buf, "%u", &input) != 1) {
+		return -EINVAL;
+	}
+	if (input == 1) {
+		gt1x_ps_enable(1);
+		gt1x_ps_report(PS_FARAWAY);
+	} else if (input == 0) {
+		gt1x_ps_report(PS_FARAWAY);
+		gt1x_ps_enable(0);
+	} else {
+		return -EINVAL;
+	}
+	return count;
+}
+
+static ssize_t gt1x_ps_state_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d", gt1x_ps_dev->state);
+}
+
+static ssize_t gt1x_ps_state_store(struct kobject *kobj, struct kobj_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1) {
+		return -EINVAL;
+	}
+
+	if (!gt1x_ps_dev->enabled) {
+		return -EINVAL;
+	}
+
+	if (input == 1) {
+		gt1x_ps_dev->state = PS_FARAWAY;
+	} else if (input == 0) {
+		gt1x_ps_dev->state = PS_NEAR;
+	} else {
+		return -EINVAL;
+	}
+
+	gt1x_ps_report(gt1x_ps_dev->state);
+	return count;
+}
+
+static struct kobj_attribute ps_attrs[] = {
+	__ATTR(enable, S_IWUGO | S_IRUGO, gt1x_ps_enable_show, gt1x_ps_enable_store),
+	__ATTR(state, S_IWUGO | S_IRUGO, gt1x_ps_state_show, gt1x_ps_state_store)
+};
+
+#endif /* End PLATFORM_MTK */
+
+static int gt1x_ps_init(void)
+{
+	int err;
+
+	gt1x_ps_dev = kzalloc(sizeof(struct gt1x_ps_device), GFP_KERNEL);
+	if (!gt1x_ps_dev) {
+		return  -ENOMEM;
+	}
+
+	gt1x_ps_dev->state = PS_FARAWAY;
+
+#ifdef PLATFORM_MTK
+	gt1x_ps_dev->obj_ps.polling = 0;	/* 0--interrupt mode;1--polling mode; */
+	gt1x_ps_dev->obj_ps.sensor_operate = gt1x_ps_operate;
+
+	if (hwmsen_attach(ID_PROXIMITY, &gt1x_ps_dev->obj_ps)) {
+		GTP_ERROR("hwmsen attach fail, return:%d.", err);
+		goto err_exit;
+	}
+
+	GTP_INFO("hwmsen attach OK.");
+	return 0;
+#else
+	gt1x_ps_dev->input_dev = input_allocate_device();
+	if (!gt1x_ps_dev->input_dev) {
+		GTP_ERROR("Failed to alloc inpput device for proximity!");
+		err = -ENOMEM;
+		goto err_exit;
+	}
+
+	gt1x_ps_dev->input_dev->name = GTP_PS_DEV_NAME;
+	gt1x_ps_dev->input_dev->phys = "goodix/proximity";
+	gt1x_ps_dev->input_dev->id.bustype = BUS_I2C;
+	gt1x_ps_dev->input_dev->id.vendor = 0xDEED;
+	gt1x_ps_dev->input_dev->id.product = 0xBEEF;
+	gt1x_ps_dev->input_dev->id.version = 1;
+	set_bit(EV_ABS, gt1x_ps_dev->input_dev->evbit);
+	input_set_abs_params(gt1x_ps_dev->input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	err = input_register_device(gt1x_ps_dev->input_dev);
+	if (err) {
+		GTP_ERROR("Failed to register proximity input device: %s!", gt1x_ps_dev->input_dev->name);
+		goto err_register_dev;
+	}
+	/* register sysfs interface  */
+	if (!sysfs_rootdir) {
+		sysfs_rootdir = kobject_create_and_add("goodix", NULL);
+		if (!sysfs_rootdir) {
+			GTP_ERROR("Failed to create and add sysfs interface: goodix.");
+			err = -ENOMEM;
+			goto err_register_dev;
+		}
+	}
+
+	gt1x_ps_dev->kobj = kobject_create_and_add("proximity", sysfs_rootdir);
+	if (!gt1x_ps_dev->kobj) {
+		GTP_ERROR("Failed to create and add sysfs interface: proximity.");
+		err = -ENOMEM;
+		goto err_register_dev;
+	}
+	/*create sysfs files*/
+	{
+		int i;
+		for (i = 0; i < sizeof(ps_attrs)/sizeof(ps_attrs[0]); i++) {
+			if (sysfs_create_file(gt1x_ps_dev->kobj, &ps_attrs[i].attr)) {
+				goto err_create_file;
+			}
+		}
+	}
+
+	GTP_INFO("Proximity sensor init OK.");
+	return 0;
+err_create_file:
+	kobject_put(gt1x_ps_dev->kobj);
+err_register_dev:
+	input_free_device(gt1x_ps_dev->input_dev);
+#endif  /* End PLATFROM_MTK */
+
+err_exit:
+	kfree(gt1x_ps_dev);
+	gt1x_ps_dev = NULL;
+	return err;
+}
+
+static void gt1x_ps_deinit(void)
+{
+	if (gt1x_ps_dev) {
+#ifndef PLATFORM_MTK
+		int i = 0;
+		for (; i < sizeof(ps_attrs) / sizeof(ps_attrs[0]); i++) {
+			sysfs_remove_file(gt1x_ps_dev->kobj, &ps_attrs[i].attr);
+		}
+		kobject_del(gt1x_ps_dev->kobj);
+		input_free_device(gt1x_ps_dev->input_dev);
+#endif
+		kfree(gt1x_ps_dev);
+	}
+}
+
+#endif /*GTP_PROXIMITY */
+
+/**
+ *			ESD Protect Module
+ */
+#if GTP_ESD_PROTECT
+static int esd_work_cycle = 200;
+static struct delayed_work esd_check_work;
+static int esd_running;
+static struct mutex esd_lock;
+static void gt1x_esd_check_func(struct work_struct *);
+
+void gt1x_init_esd_protect(void)
+{
+	esd_work_cycle = 2 * HZ;	/* HZ: clock ticks in 1 second generated by system */
+	GTP_DEBUG("Clock ticks for an esd cycle: %d", esd_work_cycle);
+	INIT_DELAYED_WORK(&esd_check_work, gt1x_esd_check_func);
+	mutex_init(&esd_lock);
+}
+
+static void gt1x_deinit_esd_protect(void)
+{
+	gt1x_esd_switch(SWITCH_OFF);
+}
+
+void gt1x_esd_switch(s32 on)
+{
+	mutex_lock(&esd_lock);
+	if (SWITCH_ON == on) {	/* switch on esd check */
+		if (!esd_running) {
+			esd_running = 1;
+			GTP_INFO("Esd protector started!");
+			queue_delayed_work(gt1x_workqueue, &esd_check_work, esd_work_cycle);
+		}
+	} else {		/* switch off esd check */
+		if (esd_running) {
+			esd_running = 0;
+			GTP_INFO("Esd protector stoped!");
+			cancel_delayed_work(&esd_check_work);
+		}
+	}
+	mutex_unlock(&esd_lock);
+}
+
+static void gt1x_esd_check_func(struct work_struct *work)
+{
+	s32 i = 0;
+	s32 ret = -1;
+	u8 esd_buf[4] = { 0 };
+
+	if (!esd_running) {
+		GTP_INFO("Esd protector suspended!");
+		return;
+	}
+
+	for (i = 0; i < 3; i++) {
+		ret = gt1x_i2c_read(GTP_REG_CMD, esd_buf, 4);
+		GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8043 = 0x%02X", esd_buf[0], esd_buf[3]);
+		if (!ret && esd_buf[0] != 0xAA && esd_buf[3] == 0xAA) {
+			break;
+		}
+		msleep(50);
+	}
+
+	if (likely(i < 3)) {
+		/* IC works normally, Write 0x8040 0xAA, feed the watchdog */
+		gt1x_send_cmd(GTP_CMD_ESD, 0);
+	} else {
+		if (esd_running) {
+			GTP_ERROR("IC works abnormally! Process reset guitar.");
+			memset(esd_buf, 0x01, sizeof(esd_buf));
+			gt1x_i2c_write(0x4226, esd_buf, sizeof(esd_buf));
+			msleep(50);
+
+			gt1x_power_reset();
+		} else {
+			GTP_INFO("Esd protector suspended, no need reset!");
+		}
+	}
+
+	mutex_lock(&esd_lock);
+	if (esd_running) {
+		queue_delayed_work(gt1x_workqueue, &esd_check_work, esd_work_cycle);
+	} else {
+		GTP_INFO("Esd protector suspended!");
+	}
+	mutex_unlock(&esd_lock);
+}
+#endif
+
+/**
+ *              Smart Cover Module
+ */
+#if GTP_SMART_COVER
+struct smart_cover_device{
+    int enabled;
+    int state; /* 0:cover faraway 1:near */
+    int suspended;  /* suspended or woring */
+    struct kobject *kobj;
+    u8 config[GTP_CONFIG_MAX_LENGTH];
+    int cfg_len;
+};
+static struct smart_cover_device *gt1x_sc_dev;
+
+/**
+ * gt1x_smart_cover_update_state - update smart cover config
+ */
+static int gt1x_smart_cover_update_state(void)
+{
+	int ret = 0;
+	struct smart_cover_device *dev = gt1x_sc_dev;
+
+	if (!dev) {
+		return -ENODEV;
+	}
+
+	if (!dev->suspended) {
+		if (dev->state) {  /* near */
+			ret = gt1x_send_cfg(dev->config, dev->cfg_len);
+		} else {
+#if GTP_CHARGER_SWITCH
+			gt1x_charger_config(1);  /*charger detector module check and*/
+			/*send a config*/
+#else
+			ret = gt1x_send_cfg(gt1x_config, gt1x_cfg_length);
+#endif
+		}
+		GTP_DEBUG("Update cover state %s.", dev->state ? "Nearby" : "Far away");
+	} else {
+		GTP_DEBUG("TP is suspended, do nothing.");
+	}
+	return ret;
+}
+
+static ssize_t smart_cover_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct smart_cover_device *dev = gt1x_sc_dev;
+
+	if (!dev) {
+		return -ENODEV;
+	}
+
+	return scnprintf(buf, PAGE_SIZE, "%d", dev->state);
+}
+
+static ssize_t smart_cover_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	struct smart_cover_device *dev = gt1x_sc_dev;
+	int s = (buf[0] - '0');
+
+	if (!dev || !dev->enabled || s > 1 || s == dev->state) {
+		return count;
+	}
+
+	dev->state = s;
+	gt1x_smart_cover_update_state();
+
+	return count;
+}
+
+/**
+ * gt1x_parse_sc_cfg - parse smart cover config
+ * @sensor_id: sensor id of the hardware
+ */
+int gt1x_parse_sc_cfg(int sensor_id)
+{
+#undef _cfg_array_
+#define _cfg_array_(n)   GTP_SMART_COVER_CFG_GROUP##n
+	u8 *cfg;
+	int *len;
+
+	if (!gt1x_sc_dev)
+		return -ENODEV;
+	cfg = gt1x_sc_dev->config;
+	len = &gt1x_sc_dev->cfg_len;
+
+#if GTP_DRIVER_SEND_CFG
+	do {
+		u8 cfg_grp0[] = _cfg_array_(0);
+		u8 cfg_grp1[] = _cfg_array_(1);
+		u8 cfg_grp2[] = _cfg_array_(2);
+		u8 cfg_grp3[] = _cfg_array_(3);
+		u8 cfg_grp4[] = _cfg_array_(4);
+		u8 cfg_grp5[] = _cfg_array_(5);
+		u8 *cfgs[] = {
+			cfg_grp0, cfg_grp1, cfg_grp2,
+			cfg_grp3, cfg_grp4, cfg_grp5
+		};
+		u8 cfg_lens[] = {
+			CFG_GROUP_LEN(cfg_grp0), CFG_GROUP_LEN(cfg_grp1),
+			CFG_GROUP_LEN(cfg_grp2), CFG_GROUP_LEN(cfg_grp3),
+			CFG_GROUP_LEN(cfg_grp4), CFG_GROUP_LEN(cfg_grp5)
+		};
+
+		if (sensor_id >= sizeof(cfgs) / sizeof(cfgs[0])) {
+			GTP_ERROR("Invalid sensor id.");
+			return -1;
+		}
+
+		*len = cfg_lens[sensor_id];
+		if (*len == 0 || *len != gt1x_cfg_length) {
+			memset(cfg, 0, GTP_CONFIG_MAX_LENGTH);
+			*len = 0;
+			GTP_ERROR("Length of config is incorrect.");
+			return -1;
+		}
+
+		memcpy(cfg, cfgs[sensor_id], cfg_lens[sensor_id]);
+
+		cfg[0] &= 0x7F;
+		set_reg_bit(cfg[TRIGGER_LOC], 0, gt1x_int_type);
+		set_reg_bit(cfg[MODULE_SWITCH3_LOC], 5, !gt1x_wakeup_level);
+	} while (0);
+#endif
+	return 0;
+}
+
+
+static struct kobj_attribute sc_attr =
+    __ATTR(state, S_IWUGO | S_IRUGO, smart_cover_show, smart_cover_store);
+static int gt1x_smart_cover_init(void)
+{
+	int err = 0;
+
+	gt1x_sc_dev = kzalloc(sizeof(struct smart_cover_device), GFP_KERNEL);
+	if (!gt1x_sc_dev) {
+		GTP_ERROR("SmartCover init failed in step: 1.");
+		return -ENOMEM;
+	}
+
+	gt1x_sc_dev->enabled = 1;
+	gt1x_parse_sc_cfg(gt1x_version.sensor_id);
+
+	if (!sysfs_rootdir) {
+		/*this kobject is shared between modules, do not free it when error occur*/
+		sysfs_rootdir = kobject_create_and_add(GOODIX_SYSFS_DIR, NULL);
+		if (!sysfs_rootdir) {
+			err = -2;
+			goto exit_free_mem;
+		}
+	}
+
+	if (!gt1x_sc_dev->kobj)
+		gt1x_sc_dev->kobj = kobject_create_and_add("smartcover", sysfs_rootdir);
+	if (!gt1x_sc_dev->kobj) {
+		err = -3;
+		goto exit_free_mem;
+	}
+
+	if (sysfs_create_file(gt1x_sc_dev->kobj, &sc_attr.attr)) {
+		err = -4;
+		goto exit_put_kobj;
+	}
+	GTP_INFO("SmartCover module init OK.");
+	return 0;
+exit_put_kobj:
+	kobject_put(gt1x_sc_dev->kobj);
+exit_free_mem:
+	kfree(gt1x_sc_dev);
+	gt1x_sc_dev = NULL;
+	GTP_ERROR("SmartCover init failed in step:%d", -err);
+	return err;
+}
+
+static void gt1x_smart_cover_deinit(void)
+{
+	if (!gt1x_sc_dev) {
+		return;
+	}
+
+	kobject_del(gt1x_sc_dev->kobj);
+	kfree(gt1x_sc_dev);
+	gt1x_sc_dev = NULL;
+}
+#endif
+
+/**
+ * Charger Detect & Switch Module
+ */
+#if GTP_CHARGER_SWITCH
+static u8 gt1x_config_charger[GTP_CONFIG_MAX_LENGTH] = { 0 };
+static struct delayed_work charger_switch_work;
+static int charger_work_cycle = 200;
+static spinlock_t charger_lock;
+static int charger_running;
+static void gt1x_charger_work_func(struct work_struct *);
+
+/**
+ * gt1x_parse_chr_cfg - parse  charger config
+ * @sensor_id: sensor id of the hardware
+ * Return:  0: succeed, <0 error
+ */
+int gt1x_parse_chr_cfg(int sensor_id)
+{
+#undef _cfg_array_
+#define _cfg_array_(n)   GTP_CHARGER_CFG_GROUP##n
+	u8 *cfg;
+	int len;
+	cfg = gt1x_config_charger;
+
+#if GTP_DRIVER_SEND_CFG
+	do {
+		u8 cfg_grp0[] = _cfg_array_(0);
+		u8 cfg_grp1[] = _cfg_array_(1);
+		u8 cfg_grp2[] = _cfg_array_(2);
+		u8 cfg_grp3[] = _cfg_array_(3);
+		u8 cfg_grp4[] = _cfg_array_(4);
+		u8 cfg_grp5[] = _cfg_array_(5);
+		u8 *cfgs[] = {
+			cfg_grp0, cfg_grp1, cfg_grp2,
+			cfg_grp3, cfg_grp4, cfg_grp5
+		};
+		u8 cfg_lens[] = {
+			CFG_GROUP_LEN(cfg_grp0), CFG_GROUP_LEN(cfg_grp1),
+			CFG_GROUP_LEN(cfg_grp2), CFG_GROUP_LEN(cfg_grp3),
+			CFG_GROUP_LEN(cfg_grp4), CFG_GROUP_LEN(cfg_grp5)
+		};
+
+		if (sensor_id >= sizeof(cfgs) / sizeof(cfgs[0])) {
+			return -1;
+		}
+
+		len = cfg_lens[sensor_id];
+		if (len == 0 || len != gt1x_cfg_length) {
+			memset(cfg, 0, GTP_CONFIG_MAX_LENGTH);
+			GTP_ERROR("Length of config is incorrect.");
+			return -1;
+		}
+
+		memcpy(cfg, cfgs[sensor_id], cfg_lens[sensor_id]);
+
+		cfg[0] &= 0x7F;
+		cfg[RESOLUTION_LOC] = (u8) gt1x_abs_x_max;
+		cfg[RESOLUTION_LOC + 1] = (u8) (gt1x_abs_x_max >> 8);
+		cfg[RESOLUTION_LOC + 2] = (u8) gt1x_abs_y_max;
+		cfg[RESOLUTION_LOC + 3] = (u8) (gt1x_abs_y_max >> 8);
+
+		set_reg_bit(cfg[TRIGGER_LOC], 0, gt1x_int_type);
+		set_reg_bit(cfg[MODULE_SWITCH3_LOC], 5, !gt1x_wakeup_level);
+	} while (0);
+#endif
+	return 0;
+}
+
+
+static void gt1x_init_charger(void)
+{
+	charger_work_cycle = 2 * HZ;	/* HZ: clock ticks in 1 second generated by system */
+	GTP_DEBUG("Clock ticks for an charger cycle: %d", charger_work_cycle);
+	INIT_DELAYED_WORK(&charger_switch_work, gt1x_charger_work_func);
+	spin_lock_init(&charger_lock);
+
+	if (gt1x_parse_chr_cfg(gt1x_version.sensor_id) < 0) {
+		GTP_ERROR("Error occured when parse charger config.");
+	}
+}
+
+/**
+ * gt1x_charger_switch - switch states of charging work thread
+ *
+ * @on: SWITCH_ON - start work thread, SWITCH_OFF: stop .
+ */
+void gt1x_charger_switch(s32 on)
+{
+	spin_lock(&charger_lock);
+	if (SWITCH_ON == on) {
+		if (!charger_running) {
+			charger_running = 1;
+			spin_unlock(&charger_lock);
+			GTP_INFO("Charger checker started!");
+			queue_delayed_work(gt1x_workqueue, &charger_switch_work, charger_work_cycle);
+		} else {
+			spin_unlock(&charger_lock);
+		}
+	} else {
+		if (charger_running) {
+			charger_running = 0;
+			spin_unlock(&charger_lock);
+			cancel_delayed_work(&charger_switch_work);
+			GTP_INFO("Charger checker stoped!");
+		} else {
+			spin_unlock(&charger_lock);
+		}
+	}
+}
+
+/**
+ * gt1x_charger_config - check and update charging status configuration
+ * @dir_update
+ * 	 0: check before send charging status configuration
+ *  	 1: directly send charging status configuration
+ *
+ */
+void gt1x_charger_config(s32 dir_update)
+{
+	static u8 chr_pluggedin;
+
+#if GTP_SMART_COVER
+	if (gt1x_sc_dev && gt1x_sc_dev->enabled
+			&& gt1x_sc_dev->state) {
+		return;
+	}
+#endif
+
+	if (gt1x_get_charger_status()) {
+		if (!chr_pluggedin || dir_update) {
+			GTP_INFO("Charger Plugin.");
+			if (gt1x_send_cfg(gt1x_config_charger, gt1x_cfg_length)) {
+				GTP_ERROR("Send config for Charger Plugin failed!");
+			}
+			if (gt1x_send_cmd(GTP_CMD_CHARGER_ON, 0)) {
+				GTP_ERROR("Update status for Charger Plugin failed!");
+			}
+			chr_pluggedin = 1;
+		}
+	} else {
+		if (chr_pluggedin || dir_update) {
+			GTP_INFO("Charger Plugout.");
+			if (gt1x_send_cfg(gt1x_config, gt1x_cfg_length)) {
+				GTP_ERROR("Send config for Charger Plugout failed!");
+			}
+			if (gt1x_send_cmd(GTP_CMD_CHARGER_OFF, 0)) {
+				GTP_ERROR("Update status for Charger Plugout failed!");
+			}
+			chr_pluggedin = 0;
+		}
+	}
+}
+
+static void gt1x_charger_work_func(struct work_struct *work)
+{
+	if (!charger_running) {
+		GTP_INFO("Charger checker suspended!");
+		return;
+	}
+
+	gt1x_charger_config(0);
+
+	GTP_DEBUG("Charger check done!");
+	if (charger_running) {
+		queue_delayed_work(gt1x_workqueue, &charger_switch_work, charger_work_cycle);
+	}
+}
+#endif
+
+int gt1x_suspend(void)
+{
+	s32 ret = -1;
+#if GTP_HOTKNOT && !HOTKNOT_BLOCK_RW
+	u8 buf[1] = { 0 };
+#endif
+
+	if (update_info.status) {
+		return 0;
+	}
+#if GTP_SMART_COVER
+	if (gt1x_sc_dev) {
+		gt1x_sc_dev->suspended = 1;
+	}
+#endif
+	GTP_INFO("Suspend start...");
+#if GTP_PROXIMITY
+	if (gt1x_ps_dev && gt1x_ps_dev->enabled) {
+		GTP_INFO("proximity is detected!");
+		return 0;
+	}
+#endif
+
+#if GTP_HOTKNOT
+	if (hotknot_enabled) {
+#if HOTKNOT_BLOCK_RW
+		if (hotknot_paired_flag) {
+			GTP_INFO("hotknot is paired!");
+			return 0;
+		}
+#else
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_HN_PAIRED, buf, sizeof(buf));
+		if ((!ret && buf[0] == 0x55) || hotknot_transfer_mode) {
+			GTP_DEBUG("0x81AA: 0x%02X", buf[0]);
+			GTP_INFO("hotknot is paired!");
+			return 0;
+		}
+#endif
+	}
+#endif
+
+	gt1x_halt = 1;
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_OFF);
+#endif
+#if GTP_CHARGER_SWITCH
+	gt1x_charger_switch(SWITCH_OFF);
+#endif
+	gt1x_irq_disable();
+
+#if GTP_GESTURE_WAKEUP
+	gesture_clear_wakeup_data();
+	if (gesture_enabled) {
+		gesture_enter_doze();
+		gt1x_irq_enable();
+		gt1x_halt = 0;
+	} else
+#endif
+	{
+		ret = gt1x_enter_sleep();
+		if (ret < 0) {
+			GTP_ERROR("Suspend failed.");
+		}
+	}
+
+	/* to avoid waking up while not sleeping
+	   delay 48 + 10ms to ensure reliability */
+	msleep(58);
+	GTP_INFO("Suspend end...");
+	return 0;
+}
+
+int gt1x_resume(void)
+{
+	s32 ret = -1;
+
+	if (update_info.status) {
+		return 0;
+	}
+
+#if GTP_SMART_COVER
+	if (gt1x_sc_dev) {
+		gt1x_sc_dev->suspended = 0;
+	}
+#endif
+	GTP_DEBUG("Resume start...");
+
+#if GTP_PROXIMITY
+	if (gt1x_ps_dev && gt1x_ps_dev->enabled) {
+		GTP_INFO("Proximity is on!");
+		return 0;
+	}
+#endif
+
+#if GTP_HOTKNOT
+	if (hotknot_enabled) {
+#if HOTKNOT_BLOCK_RW
+		if (hotknot_paired_flag) {
+			hotknot_paired_flag = 0;
+			GTP_INFO("Hotknot is paired!");
+			return 0;
+		}
+#endif
+	}
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	/* just return 0 if IC does not suspend */
+	if (!gesture_enabled && !gt1x_halt)
+		return 0;
+#else
+	if (!gt1x_halt)
+		return 0;
+#endif
+
+	ret = gt1x_wakeup_sleep();
+	if (ret < 0) {
+		GTP_ERROR("Resume failed.");
+	}
+#if GTP_HOTKNOT
+	if (!hotknot_enabled) {
+		gt1x_send_cmd(GTP_CMD_HN_EXIT_SLAVE, 0);
+	}
+#endif
+
+#if GTP_CHARGER_SWITCH
+	gt1x_charger_config(0);
+	gt1x_charger_switch(SWITCH_ON);
+#endif
+
+	gt1x_halt = 0;
+	gt1x_irq_enable();
+
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_ON);
+#endif
+
+	GTP_DEBUG("Resume end.");
+	return 0;
+}
+
+s32 gt1x_init(void)
+{
+	s32 ret = -1;
+	s32 retry = 0;
+	u8 reg_val[1];
+
+	/* power on */
+	gt1x_power_switch(SWITCH_ON);
+
+	while (retry++ < 5) {
+		gt1x_init_failed = 0;
+		/* reset ic */
+		ret = gt1x_reset_guitar();
+		if (ret != 0) {
+			GTP_ERROR("Reset guitar failed!");
+			continue;
+		}
+
+		/* check main system firmware */
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_MAINSYS, reg_val, 1);
+		if (ret != 0) {
+			continue;
+		} else if (reg_val[0] != 0xBE) {
+			GTP_ERROR("Check main system not pass[0x%2X].", reg_val[0]);
+			gt1x_init_failed = 1;
+		}
+
+#if !GTP_AUTO_UPDATE
+		/* debug info  */
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_SUBSYS, reg_val, 1);
+		if (!ret && reg_val[0] == 0xAA) {
+			GTP_ERROR("Check subsystem not pass[0x%2X].", reg_val[0]);
+		}
+#endif
+		break;
+	}
+
+	/* if the initialization fails, set default setting */
+	ret |= gt1x_init_failed;
+	if (ret) {
+		GTP_ERROR("Init failed, use default setting");
+		gt1x_abs_x_max = GTP_MAX_WIDTH;
+		gt1x_abs_y_max = GTP_MAX_HEIGHT;
+		gt1x_int_type = GTP_INT_TRIGGER;
+		gt1x_wakeup_level = GTP_WAKEUP_LEVEL;
+	}
+
+	/* get chip type */
+	ret = gt1x_get_chip_type();
+	if (ret != 0) {
+		GTP_ERROR("Get chip type failed!");
+	}
+
+	/* read version information */
+	ret = gt1x_read_version(&gt1x_version);
+	if (ret != 0) {
+		GTP_ERROR("Get verision failed!");
+	}
+
+	/* init and send configs */
+	ret = gt1x_init_panel();
+	if (ret != 0) {
+		GTP_ERROR("Init panel failed.");
+	}
+
+	gt1x_workqueue = create_singlethread_workqueue("gt1x_workthread");
+	if (gt1x_workqueue == NULL) {
+		GTP_ERROR("Create workqueue failed!");
+	}
+
+	/* init auxiliary  node and functions */
+#if GTP_DEBUG_NODE
+	gt1x_init_debug_node();
+#endif
+
+#if GTP_CREATE_WR_NODE
+	gt1x_init_tool_node();
+#endif
+
+#if GTP_GESTURE_WAKEUP || GTP_HOTKNOT
+	gt1x_init_node();
+#endif
+
+#if GTP_PROXIMITY
+	gt1x_ps_init();
+#endif
+
+#if GTP_CHARGER_SWITCH
+	gt1x_init_charger();
+	gt1x_charger_config(1);
+	gt1x_charger_switch(SWITCH_ON);
+#endif
+
+#if GTP_SMART_COVER
+	gt1x_smart_cover_init();
+#endif
+
+#if GTP_WITH_STYLUS
+	gt1x_pen_init();
+#endif
+
+	return ret;
+}
+
+void gt1x_deinit(void)
+{
+#if GTP_DEBUG_NODE
+	gt1x_deinit_debug_node();
+#endif
+
+#if GTP_GESTURE_WAKEUP || GTP_HOTKNOT
+	gt1x_deinit_node();
+#endif
+
+#if GTP_CREATE_WR_NODE
+	gt1x_deinit_tool_node();
+#endif
+
+#if GTP_ESD_PROTECT
+	gt1x_deinit_esd_protect();
+#endif
+
+#if GTP_CHARGER_SWITCH
+	gt1x_charger_switch(SWITCH_OFF);
+#endif
+
+#if GTP_PROXIMITY
+	gt1x_ps_deinit();
+#endif
+
+#if GTP_SMART_COVER
+	gt1x_smart_cover_deinit();
+#endif
+
+	if (sysfs_rootdir) {
+		kobject_del(sysfs_rootdir);
+		sysfs_rootdir = NULL;
+	}
+
+	if (gt1x_workqueue) {
+		destroy_workqueue(gt1x_workqueue);
+	}
+
+}
+
diff --git a/drivers/input/touchscreen/gt1x/gt1x_generic.h b/drivers/input/touchscreen/gt1x/gt1x_generic.h
new file mode 100644
index 000000000000..d0039022a24a
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_generic.h
@@ -0,0 +1,599 @@
+/* drivers/input/touchscreen/gt1x_generic.h
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#ifndef _GT1X_GENERIC_H_
+#define _GT1X_GENERIC_H_
+
+#include <linux/hrtimer.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+#include <linux/jiffies.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/byteorder/generic.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+/********* Device Tree Support *********/
+#ifdef CONFIG_OF
+#define GTP_CONFIG_OF
+#endif
+/***************************PART1:ON/OFF define*******************************/
+#define GTP_INCELL_PANEL      0
+#define GTP_DRIVER_SEND_CFG   1	/* send config to TP while initializing (for no config built in TP's flash) */
+#define GTP_CUSTOM_CFG        0	/* customize resolution & interrupt trigger mode */
+
+#define GTP_CHANGE_X2Y        0	/* exchange xy */
+#define GTP_WARP_X_ON         0
+#define GTP_WARP_Y_ON         0
+
+#define GTP_GESTURE_WAKEUP    0	/* gesture wakeup module */
+/* buffer used to store ges track points coor. */
+#define GES_BUFFER_ADDR       0xA2A0    /* GT1151 */
+/*#define GES_BUFFER_ADDR       0x8A40    // GT9L*/
+/*#define GES_BUFFER_ADDR       0x9734     // GT1152*/
+/*#define GES_BUFFER_ADDR       0xBDA8    // GT9286*/
+#ifndef GES_BUFFER_ADDR
+#warning  [GOODIX] need define GES_BUFFER_ADDR .
+#endif
+#define KEY_GES_REGULAR       KEY_F2	/* regular gesture-key */
+#define KEY_GES_CUSTOM        KEY_F3    /* customize gesture-key */
+
+#define GTP_HOTKNOT           0	/* hotknot module */
+#define HOTKNOT_TYPE          0	/* 0: hotknot in flash; 1: hotknot in driver */
+#define HOTKNOT_BLOCK_RW      0
+
+#define GTP_AUTO_UPDATE       0	/* auto update FW to TP FLASH while initializing */
+#define GTP_HEADER_FW_UPDATE  0	/* firmware in gt1x_firmware.h */
+#define GTP_FW_UPDATE_VERIFY  0 /* verify fw when updating */
+
+#define GTP_HAVE_TOUCH_KEY    1 /* touch key support */
+#define GTP_WITH_STYLUS       0 /* pen support */
+#define GTP_HAVE_STYLUS_KEY   0
+
+#define GTP_POWER_CTRL_SLEEP  0	/* turn off power on suspend */
+#define GTP_ICS_SLOT_REPORT   0
+#define GTP_CREATE_WR_NODE    0	/* create the interface to support gtp_tools */
+#define GTP_DEBUG_NODE        0
+
+#define GTP_PROXIMITY         0	/* proximity module (function as the p-sensor) */
+#define GTP_SMART_COVER       0
+
+#define GTP_ESD_PROTECT       0	/* esd-protection module (with a cycle of 2 seconds) */
+#define GTP_CHARGER_SWITCH    0
+
+#define GTP_DEBUG_ON          0
+#define GTP_DEBUG_ARRAY_ON    0
+#define GTP_DEBUG_FUNC_ON     0
+
+/***************************PART2:TODO define**********************************/
+/* Normal Configs
+ *  TODO: puts the config info corresponded to your TP here, the following is just
+ *         a sample config, send this config should cause the chip cannot work normally
+ */
+#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
+/* TODO define your config for Sensor_ID == 0 here, if needed */
+#define GTP_CFG_GROUP0 {\
+    0x44, 0xD0, 0x02, 0x00, 0x05, 0x05, 0x3D, 0x10, 0x00, 0x08, \
+    0x00, 0x05, 0x3C, 0x28, 0x5E, 0x00, 0x11, 0x00, 0x00, 0x00, \
+    0x28, 0x82, 0x96, 0xFC, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x26, 0x17, 0x64, \
+    0x66, 0xDF, 0x07, 0x91, 0x31, 0x18, 0x0C, 0x43, 0x24, 0x00, \
+    0x06, 0x28, 0x6E, 0x80, 0x94, 0x02, 0x05, 0x08, 0x04, 0xDA, \
+    0x33, 0xAF, 0x3F, 0x92, 0x4A, 0x7F, 0x56, 0x71, 0x62, 0x66, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x19, 0x04, \
+    0x0F, 0x10, 0x42, 0xD8, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x70, 0x17, 0x50, 0x1E, \
+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0F, 0x0E, 0x10, 0x0D, 0x12, \
+    0x13, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, \
+    0x16, 0x15, 0x14, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, \
+    0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \
+    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, \
+    0x00, 0x00, 0x24, 0x1E, 0x6D, 0x00, 0x14, 0x28, 0x00, 0x00, \
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x99, 0x01\
+}
+/* TODO define your config for Sensor_ID == 1 here,  if needed */
+#define GTP_CFG_GROUP1 {\
+	0x41, 0xD0, 0x02, 0x00, 0x05, 0x05, 0x04, 0x13, 0x00, 0x41, \
+	0x00, 0x0F, 0x50, 0x37, 0x43, 0x01, 0x00, 0x00, 0x00, 0x00, \
+	0x14, 0x17, 0x19, 0x1C, 0x0A, 0x08, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x0A, 0x0A, 0x64, 0x1E, 0x28, 0x8B, 0x2B, 0x0C, 0x50, \
+	0x52, 0xDF, 0x07, 0x20, 0x3A, 0x60, 0x1A, 0x02, 0x24, 0x00, \
+	0x00, 0x3B, 0x96, 0xC0, 0x14, 0x52, 0x1E, 0x00, 0x00, 0x87, \
+	0x4A, 0x76, 0x59, 0x6B, 0x68, 0x62, 0x77, 0x5C, 0x86, 0x5C, \
+	0x00, 0x00, 0x00, 0x10, 0x38, 0x58, 0x00, 0xF0, 0x50, 0x3C, \
+	0xAA, 0xAA, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0xFF, 0xE4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x32, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x01, 0x08, 0x02, 0x09, 0x03, 0x0A, 0x04, 0x0B, 0x05, 0x0C, \
+	0x06, 0x0D, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, \
+	0x11, 0x12, 0x13, 0x14, 0x15, 0x0A, 0x09, 0x08, 0x07, 0x06, \
+	0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE4, 0x84, \
+	0x22, 0x02, 0x00, 0x00, 0x1A, 0x01, 0x0F, 0x1E, 0x00, 0x28, \
+	0x46, 0x28, 0x01, 0x00, 0x00, 0x05, 0x6A, 0x0D, 0x01\
+    }
+/* TODO define your config for Sensor_ID == 2 here, if needed */
+#define GTP_CFG_GROUP2 {\
+    }
+/* TODO define your config for Sensor_ID == 3 here, if needed */
+#define GTP_CFG_GROUP3 {\
+    }
+/* TODO define your config for Sensor_ID == 4 here, if needed */
+#define GTP_CFG_GROUP4 {\
+    }
+/* TODO define your config for Sensor_ID == 5 here, if needed */
+#define GTP_CFG_GROUP5 {\
+    }
+
+/*
+*         Charger Configs
+*/
+/* TODO define your config for Sensor_ID == 0 here, if needed */
+#define GTP_CHARGER_CFG_GROUP0 {\
+    0x45, 0x1C, 0x02, 0xC0, 0x03, 0x05, 0x3D, 0x10, 0x00, 0x08, \
+    0x00, 0x05, 0x50, 0x28, 0x5E, 0x00, 0x11, 0x00, 0x00, 0x00, \
+    0x28, 0x80, 0x87, 0xFE, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x26, 0x17, 0x64, \
+    0x66, 0xDF, 0x07, 0x91, 0x31, 0x18, 0x0C, 0x43, 0x24, 0x00, \
+    0x06, 0x3C, 0x8C, 0x80, 0x94, 0x02, 0x05, 0x08, 0x04, 0xC2, \
+    0x49, 0xA4, 0x56, 0x8E, 0x63, 0x80, 0x71, 0x75, 0x7E, 0x6E, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x23, 0x04, \
+    0x0F, 0x10, 0x42, 0xD8, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x70, 0x17, 0x50, 0x1E, \
+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0F, 0x0E, 0x10, 0x0D, 0x12, \
+    0x13, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, \
+    0x16, 0x15, 0x14, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, \
+    0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \
+    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, \
+    0x00, 0xD0, 0x24, 0x1E, 0x6D, 0x00, 0x14, 0x28, 0x00, 0x00, \
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A, 0xC3, 0x01\
+}
+/* TODO define your config for Sensor_ID == 1 here, if needed */
+#define GTP_CHARGER_CFG_GROUP1 {\
+}
+/* TODO define your config for Sensor_ID == 2 here, if needed */
+#define GTP_CHARGER_CFG_GROUP2 {\
+}
+/* TODO define your config for Sensor_ID == 3 here, if needed */
+#define GTP_CHARGER_CFG_GROUP3 {\
+}
+/* TODO define your config for Sensor_ID == 4 here, if needed */
+#define GTP_CHARGER_CFG_GROUP4 {\
+}
+/* TODO define your config for Sensor_ID == 5 here, if needed */
+#define GTP_CHARGER_CFG_GROUP5 {\
+}
+
+/*
+ *         Smart Cover Configs
+ */
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP0 {\
+    0x46, 0xD0, 0x02, 0x64, 0x02, 0x05, 0xBD, 0x10, 0x00, 0x08, 0x00, 0x0F, 0x50, 0x28, 0x5E, \
+    0x02, 0x11, 0x00, 0x00, 0x00, 0x28, 0x82, 0x96, 0xFC, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x87, 0x26, 0x0B, 0x64, 0x66, 0xDF, 0x07, 0x91, 0x31, 0x18, 0x0E, 0x43, 0x24, 0x00, \
+    0x04, 0x28, 0x6E, 0x80, 0x94, 0x02, 0x05, 0x08, 0x04, 0xDA, 0x33, 0xAF, 0x3F, 0x92, 0x4A, \
+    0x7F, 0x56, 0x71, 0x62, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x19, 0x04, 0x0F, 0x10, 0x42, 0xD8, 0x0F, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x1E, \
+    0x00, 0x70, 0x17, 0x50, 0x1E, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0F, 0x0E, 0x10, 0x0D, 0x12, \
+    0x13, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 0x14, 0xFF, 0xFF, \
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \
+    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x24, 0x1E, 0x6D, \
+    0x00, 0x14, 0x28, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x29, 0x01\
+}
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP1 {\
+}
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP2 {\
+}
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP3 {\
+}
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP4 {\
+}
+/* TODO define your config for Sendor_ID == 0 here, if needed */
+#define GTP_SMART_COVER_CFG_GROUP5 {\
+}
+
+#if GTP_CUSTOM_CFG
+#define GTP_MAX_HEIGHT   1280
+#define GTP_MAX_WIDTH    720
+#define GTP_INT_TRIGGER  1	/* 0:Rising 1:Falling */
+#define GTP_WAKEUP_LEVEL 1
+#else
+#define GTP_MAX_HEIGHT   4096
+#define GTP_MAX_WIDTH    4096
+#define GTP_INT_TRIGGER  1
+#define GTP_WAKEUP_LEVEL 1
+#endif
+
+#define GTP_MAX_TOUCH    10
+
+#if GTP_WITH_STYLUS
+#define GTP_STYLUS_KEY_TAB {BTN_STYLUS, BTN_STYLUS2}
+#endif
+
+#if GTP_HAVE_TOUCH_KEY
+#define GTP_KEY_TAB	 {KEY_BACK, KEY_HOMEPAGE, KEY_MENU, KEY_SEARCH}
+#define GTP_MAX_KEY_NUM  4
+#endif
+
+/****************************PART3:OTHER define*********************************/
+#define GTP_DRIVER_VERSION          "V1.4<2015/07/10>"
+#define GTP_I2C_NAME                "Goodix-TS-GT1X"
+#define GT1X_DEBUG_PROC_FILE        "gt1x_debug"
+#define GTP_POLL_TIME               10
+#define GTP_ADDR_LENGTH             2
+#define GTP_CONFIG_MIN_LENGTH       186
+#define GTP_CONFIG_MAX_LENGTH       240
+#define GTP_MAX_I2C_XFER_LEN        250
+#define SWITCH_OFF                  0
+#define SWITCH_ON                   1
+
+#define GTP_REG_MATRIX_DRVNUM           0x8069
+#define GTP_REG_MATRIX_SENNUM           0x806A
+#define GTP_REG_RQST                    0x8044
+#define GTP_REG_BAK_REF                 0x90EC
+#define GTP_REG_MAIN_CLK                0x8020
+#define GTP_REG_HAVE_KEY                0x8057
+#define GTP_REG_HN_STATE                0x8800
+
+#define GTP_REG_WAKEUP_GESTURE         0x814C
+#define GTP_REG_WAKEUP_GESTURE_DETAIL  0xA2A0	/* need change */
+
+#define GTP_BAK_REF_PATH                "/data/gt1x_ref.bin"
+#define GTP_MAIN_CLK_PATH               "/data/gt1x_clk.bin"
+
+/* request type */
+#define GTP_RQST_CONFIG                 0x01
+#define GTP_RQST_BAK_REF                0x02
+#define GTP_RQST_RESET                  0x03
+#define GTP_RQST_MAIN_CLOCK             0x04
+#define GTP_RQST_HOTKNOT_CODE           0x20
+#define GTP_RQST_RESPONDED              0x00
+#define GTP_RQST_IDLE                   0xFF
+
+#define HN_DEVICE_PAIRED                0x80
+#define HN_MASTER_DEPARTED              0x40
+#define HN_SLAVE_DEPARTED               0x20
+#define HN_MASTER_SEND                  0x10
+#define HN_SLAVE_RECEIVED               0x08
+
+/*Register define */
+#define GTP_READ_COOR_ADDR          0x814E
+#define GTP_REG_CMD                 0x8040
+#define GTP_REG_SENSOR_ID           0x814A
+#define GTP_REG_CONFIG_DATA         0x8050
+#define GTP_REG_CONFIG_RESOLUTION   0x8051
+#define GTP_REG_CONFIG_TRIGGER      0x8056
+#define GTP_REG_CONFIG_CHECKSUM     0x813C
+#define GTP_REG_CONFIG_UPDATE       0x813E
+#define GTP_REG_VERSION             0x8140
+#define GTP_REG_HW_INFO             0x4220
+#define GTP_REG_REFRESH_RATE	    0x8056
+#define GTP_REG_ESD_CHECK           0x8043
+#define GTP_REG_FLASH_PASSBY        0x8006
+#define GTP_REG_HN_PAIRED           0x81AA
+#define GTP_REG_HN_MODE             0x81A8
+#define GTP_REG_MODULE_SWITCH3      0x8058
+#define GTP_REG_FW_CHK_MAINSYS      0x41E4
+#define GTP_REG_FW_CHK_SUBSYS       0x5095
+
+#define set_reg_bit(reg, pos, val)   ((reg) = ((reg) & (~(1<<(pos))))|(!!(val)<<(pos)))
+
+/* cmd define */
+#define GTP_CMD_SLEEP               0x05
+#define GTP_CMD_CHARGER_ON          0x06
+#define GTP_CMD_CHARGER_OFF         0x07
+#define GTP_CMD_GESTURE_WAKEUP      0x08
+#define GTP_CMD_CLEAR_CFG           0x10
+#define GTP_CMD_ESD                 0xAA
+#define GTP_CMD_HN_TRANSFER         0x22
+#define GTP_CMD_HN_EXIT_SLAVE       0x28
+
+/* define offset in the config*/
+#define RESOLUTION_LOC              (GTP_REG_CONFIG_RESOLUTION - GTP_REG_CONFIG_DATA)
+#define TRIGGER_LOC                 (GTP_REG_CONFIG_TRIGGER - GTP_REG_CONFIG_DATA)
+#define MODULE_SWITCH3_LOC	     	(GTP_REG_MODULE_SWITCH3 - GTP_REG_CONFIG_DATA)
+
+#define GTP_I2C_ADDRESS       		0xBA
+
+#if GTP_WARP_X_ON
+#define GTP_WARP_X(x_max, x) (x_max - 1 - x)
+#else
+#define GTP_WARP_X(x_max, x) x
+#endif
+
+#if GTP_WARP_Y_ON
+#define GTP_WARP_Y(y_max, y) (y_max - 1 - y)
+#else
+#define GTP_WARP_Y(y_max, y) y
+#endif
+
+#define IS_NUM_OR_CHAR(x)    (((x) >= 'A' && (x) <= 'Z') || ((x) >= '0' && (x) <= '9'))
+
+/*Log define*/
+#define GTP_INFO(fmt, arg...)           printk("<<GTP-INF>>[%s:%d] "fmt"\n", __func__, __LINE__, ##arg)
+#define GTP_ERROR(fmt, arg...)          printk("<<GTP-ERR>>[%s:%d] "fmt"\n", __func__, __LINE__, ##arg)
+#define GTP_DEBUG(fmt, arg...)          do {\
+	if (GTP_DEBUG_ON)\
+	printk("<<GTP-DBG>>[%s:%d]"fmt"\n", __func__, __LINE__, ##arg);\
+} while (0)
+#define GTP_DEBUG_ARRAY(array, num)    do {\
+	s32 i;\
+	u8 *a = array;\
+	if (GTP_DEBUG_ARRAY_ON) {\
+		printk("<<GTP-DBG>>");\
+		for (i = 0; i < (num); i++) {\
+			printk("%02x ", (a)[i]);\
+			if ((i + 1) % 10 == 0) {\
+				printk("\n<<GTP-DBG>>");\
+			} \
+		} \
+		printk("\n");\
+	} \
+} while (0)
+#define GTP_DEBUG_FUNC()               do {\
+	if (GTP_DEBUG_FUNC_ON)\
+	printk("<<GTP-FUNC>> Func:%s@Line:%d\n", __func__, __LINE__);\
+} while (0)
+
+#define GTP_SWAP(x, y)                 do {\
+						typeof(x) z = x;\
+						x = y;\
+						y = z;\
+					} while (0)
+
+#pragma pack(1)
+struct gt1x_version_info {
+	u8 product_id[5];
+	u32 patch_id;
+	u32 mask_id;
+	u8 sensor_id;
+	u8 match_opt;
+};
+#pragma pack()
+
+typedef enum {
+	DOZE_DISABLED = 0,
+	DOZE_ENABLED = 1,
+	DOZE_WAKEUP = 2,
+} DOZE_T;
+
+typedef enum {
+	CHIP_TYPE_GT1X = 0,
+	CHIP_TYPE_GT2X = 1,
+	CHIP_TYPE_NONE = 0xFF
+} CHIP_TYPE_T;
+
+#define _ERROR(e)      ((0x01 << e) | (0x01 << (sizeof(s32) * 8 - 1)))
+#define ERROR          _ERROR(1)	/* for common use */
+/*system relevant*/
+#define ERROR_IIC      _ERROR(2)	/* IIC communication error. */
+#define ERROR_MEM      _ERROR(3)	/* memory error.*/
+
+/*system irrelevant*/
+#define ERROR_HN_VER   _ERROR(10)	/* HotKnot version error. */
+#define ERROR_CHECK    _ERROR(11)	/* Compare src and dst error. */
+#define ERROR_RETRY    _ERROR(12)	/* Too many retries.i */
+#define ERROR_PATH     _ERROR(13)	/* Mount path error */
+#define ERROR_FW       _ERROR(14)
+#define ERROR_FILE     _ERROR(15)
+#define ERROR_VALUE    _ERROR(16)	/* Illegal value of variables */
+
+/* bit operation */
+#define SET_BIT(data, flag)	((data) |= (flag))
+#define CLR_BIT(data, flag)	((data) &= ~(flag))
+#define CHK_BIT(data, flag)	((data) & (flag))
+
+/* touch states */
+#define BIT_TOUCH			0x01
+#define BIT_TOUCH_KEY		0x02
+#define BIT_STYLUS			0x04
+#define BIT_STYLUS_KEY		0x08
+#define BIT_HOVER			0x10
+
+#include <linux/input.h>
+struct i2c_msg;
+
+/*          Export global variables and functions          */
+
+/* Export from gt1x_extents.c and gt1x_firmware.h */
+#if GTP_HOTKNOT
+extern u8 hotknot_enabled;
+extern u8 hotknot_transfer_mode;
+extern u8 gt1x_patch_jump_fw[];
+extern u8 hotknot_auth_fw[];
+extern u8 hotknot_transfer_fw[];
+#if HOTKNOT_BLOCK_RW
+extern s32 hotknot_paired_flag;
+extern s32 hotknot_event_handler(u8 *data);
+#endif
+#endif
+
+extern s32 gt1x_init_node(void);
+extern void gt1x_deinit_node(void);
+
+#if GTP_GESTURE_WAKEUP
+extern DOZE_T gesture_doze_status;
+extern int gesture_enabled;
+extern void gt1x_gesture_debug(int on) ;
+extern s32 gesture_event_handler(struct input_dev *dev);
+extern s32 gesture_enter_doze(void);
+extern void gesture_clear_wakeup_data(void);
+#endif
+
+/* Export from gt1x_tpd.c */
+extern void gt1x_touch_down(s32 x, s32 y, s32 size, s32 id);
+extern void gt1x_touch_up(s32 id);
+extern int gt1x_power_switch(s32 state);
+extern void gt1x_irq_enable(void);
+extern void gt1x_irq_disable(void);
+extern int gt1x_debug_proc(u8 *buf, int count);
+
+struct fw_update_info {
+	int update_type;
+	int status;
+	int progress;
+	int max_progress;
+    int force_update;
+	struct fw_info *firmware;
+	u32 fw_length;
+	/*file update*/
+	char *fw_name;
+	u8 *buffer;
+	mm_segment_t old_fs;
+	struct file *fw_file;
+	/*header update*/
+	u8 *fw_data;
+};
+
+/* Export form gt1x_update.c */
+extern struct fw_update_info update_info;
+
+extern u8 gt1x_default_FW[];
+extern int gt1x_hold_ss51_dsp(void);
+extern int gt1x_auto_update_proc(void *data);
+extern int gt1x_update_firmware(void *filename);
+extern void gt1x_enter_update_mode(void);
+extern void gt1x_leave_update_mode(void);
+extern int gt1x_hold_ss51_dsp_no_reset(void);
+extern int gt1x_load_patch(u8 *patch, u32 patch_size, int offset, int bank_size);
+extern int gt1x_startup_patch(void);
+
+/* Export from gt1x_tool.c */
+#if GTP_CREATE_WR_NODE
+extern int gt1x_init_tool_node(void);
+extern void gt1x_deinit_tool_node(void);
+#endif
+
+/* Export from gt1x_generic.c */
+extern struct i2c_client *gt1x_i2c_client;
+
+extern CHIP_TYPE_T gt1x_chip_type;
+extern struct gt1x_version_info gt1x_version;
+
+extern s32 _do_i2c_read(struct i2c_msg *msgs, u16 addr, u8 *buffer, s32 len);
+extern s32 _do_i2c_write(struct i2c_msg *msg, u16 addr, u8 *buffer, s32 len);
+extern s32 gt1x_i2c_write(u16 addr, u8 *buffer, s32 len);
+extern s32 gt1x_i2c_read(u16 addr, u8 *buffer, s32 len);
+extern s32 gt1x_i2c_read_dbl_check(u16 addr, u8 *buffer, s32 len);
+
+extern u8 gt1x_config[];
+extern u32 gt1x_cfg_length;
+extern u8 gt1x_int_type;
+extern u8 gt1x_wakeup_level;
+extern u32 gt1x_abs_x_max;
+extern u32 gt1x_abs_y_max;
+extern u8 gt1x_init_failed;
+extern int gt1x_halt;
+extern volatile int gt1x_rawdiff_mode;
+
+extern s32 gt1x_init(void);
+extern void gt1x_deinit(void);
+extern s32 gt1x_read_version(struct gt1x_version_info *ver_info);
+extern s32 gt1x_init_panel(void);
+extern s32 gt1x_get_chip_type(void);
+extern s32 gt1x_request_event_handler(void);
+extern int gt1x_send_cmd(u8 cmd, u8 data);
+extern s32 gt1x_send_cfg(u8 *config, int cfg_len);
+extern void gt1x_select_addr(void);
+extern s32 gt1x_reset_guitar(void);
+extern void gt1x_power_reset(void);
+extern int gt1x_parse_config(char *filename, u8 *gt1x_config);
+extern s32 gt1x_touch_event_handler(u8 *data, struct input_dev *dev, struct input_dev *pen_dev);
+extern int gt1x_suspend(void);
+extern int gt1x_resume(void);
+
+#if GTP_HAVE_TOUCH_KEY
+extern const u16 gt1x_touch_key_array[];
+#endif
+
+#if GTP_WITH_STYLUS
+extern struct input_dev *pen_dev;
+extern void gt1x_pen_up(s32 id);
+extern void gt1x_pen_down(s32 x, s32 y, s32 size, s32 id);
+#endif
+
+#if GTP_PROXIMITY
+extern u8 gt1x_proximity_flag;
+extern int gt1x_prox_event_handler(u8 *data);
+#endif
+
+#if GTP_SMART_COVER
+extern int gt1x_parse_sc_cfg(int sensor_id);
+#endif
+
+#if GTP_ESD_PROTECT
+extern void gt1x_init_esd_protect(void);
+extern void gt1x_esd_switch(s32 on);
+#endif
+
+#if GTP_CHARGER_SWITCH
+extern u32 gt1x_get_charger_status(void);
+extern void gt1x_charger_switch(s32 on);
+extern void gt1x_charger_config(s32 dir_update);
+extern int gt1x_parse_chr_cfg(int sensor_id);
+#endif
+
+#endif
+
diff --git a/drivers/input/touchscreen/gt1x/gt1x_tools.c b/drivers/input/touchscreen/gt1x/gt1x_tools.c
new file mode 100644
index 000000000000..c6d376be7c9f
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_tools.c
@@ -0,0 +1,434 @@
+/* drivers/input/touchscreen/goodix_tool.c
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <generated/utsrelease.h>
+#include "gt1x_generic.h"
+
+static ssize_t gt1x_tool_read(struct file *filp, char __user *buffer, size_t count, loff_t *ppos);
+static ssize_t gt1x_tool_write(struct file *filp, const char *buffer, size_t count, loff_t *ppos);
+
+
+static int gt1x_tool_release(struct inode *inode, struct file *filp);
+static int gt1x_tool_open(struct inode *inode, struct file *file);
+
+#pragma pack(1)
+typedef struct {
+	u8 wr;
+	u8 flag;
+	u8 flag_addr[2];
+	u8 flag_val;
+	u8 flag_relation;
+	u16 circle;
+	u8 times;
+	u8 retry;
+	u16 delay;
+	u16 data_len;
+	u8 addr_len;
+	u8 addr[2];
+	u8 res[3];
+	u8 *data;
+} st_cmd_head;
+#pragma pack()
+st_cmd_head cmd_head;
+
+s32 DATA_LENGTH;
+s8 IC_TYPE[16] = "GT1X";
+
+#define UPDATE_FUNCTIONS
+#define DATA_LENGTH_UINT    512
+#define CMD_HEAD_LENGTH     (sizeof(st_cmd_head) - sizeof(u8 *))
+
+static char procname[20] = { 0 };
+
+static struct proc_dir_entry *gt1x_tool_proc_entry;
+static struct file_operations gt1x_tool_fops = {
+	.read = gt1x_tool_read,
+	.write = gt1x_tool_write,
+  .open = gt1x_tool_open,
+  .release = gt1x_tool_release,
+  .owner = THIS_MODULE,
+};
+
+static void set_tool_node_name(char *procname)
+{
+
+	int v0 = 0, v1 = 0, v2 = 0;
+
+	sscanf(UTS_RELEASE, "%d.%d.%d", &v0, &v1, &v2);
+	sprintf(procname, "gmnode%02d%02d%02d", v0, v1, v2);
+}
+
+int gt1x_init_tool_node(void)
+{
+	memset(&cmd_head, 0, sizeof(cmd_head));
+	/*if the first operation is read, will return fail.*/
+	cmd_head.wr = 1;
+	cmd_head.data = kzalloc(DATA_LENGTH_UINT, GFP_KERNEL);
+	if (NULL == cmd_head.data) {
+		GTP_ERROR("Apply for memory failed.");
+		return -1;
+	}
+	GTP_INFO("Alloc memory size:%d.", DATA_LENGTH_UINT);
+	DATA_LENGTH = DATA_LENGTH_UINT - GTP_ADDR_LENGTH;
+
+	set_tool_node_name(procname);
+
+	gt1x_tool_proc_entry = proc_create(procname, 0755, NULL, &gt1x_tool_fops);
+	if (gt1x_tool_proc_entry == NULL) {
+		GTP_ERROR("CAN't create proc entry /proc/%s.", procname);
+		return -1;
+	} else {
+		GTP_INFO("Created proc entry /proc/%s.", procname);
+	}
+	return 0;
+}
+
+void gt1x_deinit_tool_node(void)
+{
+	remove_proc_entry(procname, NULL);
+	kfree(cmd_head.data);
+	cmd_head.data = NULL;
+}
+
+static s32 tool_i2c_read(u8 *buf, u16 len)
+{
+	u16 addr = (buf[0] << 8) + buf[1];
+	if (!gt1x_i2c_read(addr, &buf[2], len)) {
+		return 1;
+	}
+	return -1;
+}
+
+static s32 tool_i2c_write(u8 *buf, u16 len)
+{
+	u16 addr = (buf[0] << 8) + buf[1];
+	if (!gt1x_i2c_write(addr, &buf[2], len - 2)) {
+		return 1;
+	}
+	return -1;
+}
+
+static u8 relation(u8 src, u8 dst, u8 rlt)
+{
+	u8 ret = 0;
+
+	switch (rlt) {
+	case 0:
+		ret = (src != dst) ? true : false;
+		break;
+
+	case 1:
+		ret = (src == dst) ? true : false;
+		GTP_DEBUG("equal:src:0x%02x   dst:0x%02x   ret:%d.", src, dst, (s32) ret);
+		break;
+
+	case 2:
+		ret = (src > dst) ? true : false;
+		break;
+
+	case 3:
+		ret = (src < dst) ? true : false;
+		break;
+
+	case 4:
+		ret = (src & dst) ? true : false;
+		break;
+
+	case 5:
+		ret = (!(src | dst)) ? true : false;
+		break;
+
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Function:
+    Comfirm function.
+Input:
+  None.
+Output:
+    Return write length.
+********************************************************/
+static u8 comfirm(void)
+{
+	s32 i = 0;
+	u8 buf[32];
+
+	memcpy(buf, cmd_head.flag_addr, cmd_head.addr_len);
+
+	for (i = 0; i < cmd_head.times; i++) {
+		if (tool_i2c_read(buf, 1) <= 0) {
+			GTP_ERROR("Read flag data failed!");
+			return -1;
+		}
+
+		if (true == relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val, cmd_head.flag_relation)) {
+			GTP_DEBUG("value at flag addr:0x%02x.", buf[GTP_ADDR_LENGTH]);
+			GTP_DEBUG("flag value:0x%02x.", cmd_head.flag_val);
+			break;
+		}
+
+		msleep(cmd_head.circle);
+	}
+
+	if (i >= cmd_head.times) {
+		GTP_ERROR("Didn't get the flag to continue!");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*******************************************************
+Function:
+    Goodix tool write function.
+Input:
+  standard proc write function param.
+Output:
+    Return write length.
+********************************************************/
+static ssize_t gt1x_tool_write(struct file *filp, const char __user *buff, size_t len, loff_t *data)
+{
+	u64 ret = 0;
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG_ARRAY((u8 *) buff, len);
+
+	ret = copy_from_user(&cmd_head, buff, CMD_HEAD_LENGTH);
+	if (ret) {
+		GTP_ERROR("copy_from_user failed.");
+	}
+
+	GTP_DEBUG("wr  :0x%02x.", cmd_head.wr);
+	/*
+	   GTP_DEBUG("flag:0x%02x.", cmd_head.flag);
+	   GTP_DEBUG("flag addr:0x%02x%02x.", cmd_head.flag_addr[0], cmd_head.flag_addr[1]);
+	   GTP_DEBUG("flag val:0x%02x.", cmd_head.flag_val);
+	   GTP_DEBUG("flag rel:0x%02x.", cmd_head.flag_relation);
+	   GTP_DEBUG("circle  :%d.", (s32)cmd_head.circle);
+	   GTP_DEBUG("times   :%d.", (s32)cmd_head.times);
+	   GTP_DEBUG("retry   :%d.", (s32)cmd_head.retry);
+	   GTP_DEBUG("delay   :%d.", (s32)cmd_head.delay);
+	   GTP_DEBUG("data len:%d.", (s32)cmd_head.data_len);
+	   GTP_DEBUG("addr len:%d.", (s32)cmd_head.addr_len);
+	   GTP_DEBUG("addr:0x%02x%02x.", cmd_head.addr[0], cmd_head.addr[1]);
+	   GTP_DEBUG("len:%d.", (s32)len);
+	   GTP_DEBUG("buf[20]:0x%02x.", buff[CMD_HEAD_LENGTH]);
+	   */
+
+	if (1 == cmd_head.wr) {
+		u16 addr, data_len, pos;
+
+		if (1 == cmd_head.flag) {
+			if (comfirm()) {
+				GTP_ERROR("[WRITE]Comfirm fail!");
+				return -1;
+			}
+		} else if (2 == cmd_head.flag) {
+			/*Need interrupt!*/
+		}
+
+		addr = (cmd_head.addr[0] << 8) + cmd_head.addr[1];
+		data_len = cmd_head.data_len;
+		pos = 0;
+		while (data_len > 0) {
+			len = data_len > DATA_LENGTH ? DATA_LENGTH : data_len;
+			ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH], &buff[CMD_HEAD_LENGTH + pos], len);
+			if (ret) {
+				GTP_ERROR("[WRITE]copy_from_user failed.");
+				return -1;
+			}
+			cmd_head.data[0] = ((addr >> 8) & 0xFF);
+			cmd_head.data[1] = (addr & 0xFF);
+
+			GTP_DEBUG_ARRAY(cmd_head.data, len + GTP_ADDR_LENGTH);
+
+			if (tool_i2c_write(cmd_head.data, len + GTP_ADDR_LENGTH) <= 0) {
+				GTP_ERROR("[WRITE]Write data failed!");
+				return -1;
+			}
+			addr += len;
+			pos += len;
+			data_len -= len;
+		}
+
+		if (cmd_head.delay) {
+			msleep(cmd_head.delay);
+		}
+		return cmd_head.data_len + CMD_HEAD_LENGTH;
+	} else if (3 == cmd_head.wr) {	/* gt1x unused */
+		memcpy(IC_TYPE, cmd_head.data, min((u16)sizeof(IC_TYPE), cmd_head.data_len));
+		return cmd_head.data_len + CMD_HEAD_LENGTH;
+	} else if (5 == cmd_head.wr) {	/* ? */
+		/*memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);*/
+		return cmd_head.data_len + CMD_HEAD_LENGTH;
+	} else if (7 == cmd_head.wr) {	/* disable irq! */
+		gt1x_irq_disable();
+#if GTP_ESD_PROTECT
+		gt1x_esd_switch(SWITCH_OFF);
+#endif
+		return CMD_HEAD_LENGTH;
+	} else if (9 == cmd_head.wr) {	/* enable irq! */
+		gt1x_irq_enable();
+#if GTP_ESD_PROTECT
+		gt1x_esd_switch(SWITCH_ON);
+#endif
+		return CMD_HEAD_LENGTH;
+	} else if (17 == cmd_head.wr) {
+		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH], &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+		if (ret) {
+			GTP_ERROR("copy_from_user failed.");
+			return -1;
+		}
+
+		if (cmd_head.data[GTP_ADDR_LENGTH]) {
+			GTP_DEBUG("gtp enter rawdiff.");
+			gt1x_rawdiff_mode = true;
+		} else {
+			gt1x_rawdiff_mode = false;
+			GTP_DEBUG("gtp leave rawdiff.");
+		}
+
+		return CMD_HEAD_LENGTH;
+	} else if (11 == cmd_head.wr) {
+		gt1x_enter_update_mode();
+	} else if (13 == cmd_head.wr) {
+		gt1x_leave_update_mode();
+	} else if (15 == cmd_head.wr) {
+		struct task_struct *thrd = NULL;
+		memset(cmd_head.data, 0, cmd_head.data_len + 1);
+		memcpy(cmd_head.data, &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+		GTP_DEBUG("update firmware, filename: %s", cmd_head.data);
+		thrd = kthread_run(gt1x_update_firmware, (void *)cmd_head.data, "GT1x FW Update");
+		if (IS_ERR(thrd)) {
+			return PTR_ERR(thrd);
+		}
+	}
+	return CMD_HEAD_LENGTH;
+}
+
+static u8 devicecount;
+static int gt1x_tool_open(struct inode *inode, struct file *file)
+{
+	if (devicecount > 0) {
+		return -ERESTARTSYS;
+		GTP_ERROR("tools open failed!");
+	}
+	devicecount++;
+	return 0;
+}
+
+static int gt1x_tool_release(struct inode *inode, struct file *filp)
+{
+	devicecount--;
+	return 0;
+}
+/*******************************************************
+Function:
+    Goodix tool read function.
+Input:
+  standard proc read function param.
+Output:
+    Return read length.
+********************************************************/
+static ssize_t gt1x_tool_read(struct file *filp, char __user *buffer, size_t count, loff_t *ppos)
+{
+	GTP_DEBUG_FUNC();
+	if (*ppos) {
+		GTP_DEBUG("[PARAM]size: %zd, *ppos: %d", count, (int)*ppos);
+		*ppos = 0;
+		return 0;
+	}
+
+	if (cmd_head.wr % 2) {
+		GTP_ERROR("[READ] invaild operator fail!");
+		return -1;
+	} else if (!cmd_head.wr) {
+	    /* general  i2c read  */
+		u16 addr, data_len, len, loc;
+
+		if (1 == cmd_head.flag) {
+			if (comfirm()) {
+				GTP_ERROR("[READ]Comfirm fail!");
+				return -1;
+			}
+		} else if (2 == cmd_head.flag) {
+			/*Need interrupt!*/
+		}
+
+		addr = (cmd_head.addr[0] << 8) + cmd_head.addr[1];
+		data_len = cmd_head.data_len;
+		loc = 0;
+
+		GTP_DEBUG("[READ] ADDR:0x%04X.", addr);
+		GTP_DEBUG("[READ] Length: %d", data_len);
+
+		if (cmd_head.delay) {
+			msleep(cmd_head.delay);
+		}
+
+		while (data_len > 0) {
+			len = data_len > DATA_LENGTH ? DATA_LENGTH : data_len;
+			cmd_head.data[0] = (addr >> 8) & 0xFF;
+			cmd_head.data[1] = (addr & 0xFF);
+			if (tool_i2c_read(cmd_head.data, len) <= 0) {
+				GTP_ERROR("[READ]Read data failed!");
+				return -1;
+			}
+			memcpy(&buffer[loc], &cmd_head.data[GTP_ADDR_LENGTH], len);
+			data_len -= len;
+			addr += len;
+			loc += len;
+			GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH], len);
+		}
+		 *ppos += cmd_head.data_len;
+		return cmd_head.data_len;
+	} else if (2 == cmd_head.wr) {
+		GTP_DEBUG("Return ic type:%s len:%d.", buffer, (s32) cmd_head.data_len);
+		return -1;
+	} else if (4 == cmd_head.wr) {
+	    /* read fw update progress */
+		buffer[0] = update_info.progress >> 8;
+		buffer[1] = update_info.progress & 0xff;
+		buffer[2] = update_info.max_progress >> 8;
+		buffer[3] = update_info.max_progress & 0xff;
+		*ppos += 4;
+		return 4;
+	} else if (6 == cmd_head.wr) {
+		/*Read error code!*/
+		return -1;
+	} else if (8 == cmd_head.wr) {
+	    /* Read driver version */
+		s32 tmp_len;
+		tmp_len = strlen(GTP_DRIVER_VERSION);
+		memcpy(buffer, GTP_DRIVER_VERSION, tmp_len);
+		buffer[tmp_len] = 0;
+		*ppos += tmp_len + 1;
+		return (tmp_len + 1);
+	}
+	*ppos += cmd_head.data_len;
+	return cmd_head.data_len;
+}
diff --git a/drivers/input/touchscreen/gt1x/gt1x_update.c b/drivers/input/touchscreen/gt1x/gt1x_update.c
new file mode 100644
index 000000000000..50ba3c208cdc
--- /dev/null
+++ b/drivers/input/touchscreen/gt1x/gt1x_update.c
@@ -0,0 +1,1456 @@
+/* drivers/input/touchscreen/gt1x_update.c
+ *
+ * 2010 - 2014 Goodix Technology.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 1.4
+ * Release Date:  2015/07/10
+ */
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <asm/uaccess.h>
+
+#include "gt1x_generic.h"
+#if (GTP_HOTKNOT || GTP_HEADER_FW_UPDATE)
+#include "gt1x_firmware.h"
+#endif
+
+#define UPDATE_FILE_PATH_1          "/data/_goodix_update_.bin"
+#define UPDATE_FILE_PATH_2          "/sdcard/_goodix_update_.bin"
+
+#define CONFIG_FILE_PATH_1          "/data/_gt1x_config_.cfg"
+#define CONFIG_FILE_PATH_2          "/sdcard/_gt1x_config_.cfg"
+
+#define FOUND_FW_PATH_1              0x01
+#define FOUND_FW_PATH_2              0x02
+#define FOUND_CFG_PATH_1             0x04
+#define FOUND_CFG_PATH_2             0x08
+
+#define PACK_SIZE                    256
+
+/*hardware register define*/
+#define _bRW_MISCTL__SRAM_BANK       0x4048
+#define _bRW_MISCTL__MEM_CD_EN       0x4049
+#define _bRW_MISCTL__CACHE_EN        0x404B
+#define _bRW_MISCTL__TMR0_EN         0x40B0
+#define _rRW_MISCTL__SWRST_B0_       0x4180
+#define _bWO_MISCTL__CPU_SWRST_PULSE 0x4184
+#define _rRW_MISCTL__BOOTCTL_B0_     0x4190
+#define _rRW_MISCTL__BOOT_OPT_B0_    0x4218
+#define _rRW_MISCTL__BOOT_CTL_       0x5094
+#define _bRW_MISCTL__DSP_MCU_PWR_    0x4010
+#define _bRW_MISCTL__PATCH_AREA_EN_  0x404D
+
+/*
+ 1.  firmware structure
+    header: 128b
+    offset           size          content
+    0                 4              firmware length
+    4                 2              checksum
+    6                 6              target MASK name
+    12               3              target MASK version
+    15               6              TP subsystem PID
+    21               3              TP subsystem version
+    24               1              subsystem count
+    25               1              chip type                             0x91: GT1X,   0x92: GT2X
+    26               6              reserved
+    32               8              subsystem info[0]
+    32               8              subsystem info[1]
+    .....
+    120             8              subsystem info[11]
+    body: followed header
+    128             N0              subsystem[0]
+    128+N0       N1              subsystem[1]
+    ....
+ 2. subsystem info structure
+    offset           size          content
+    0                 1              subsystem type
+    1                 2              subsystem length
+    3                 2              stored address in flash           addr = value * 256
+    5                 3              reserved
+
+*/
+
+#define FW_HEAD_SIZE                         128
+#define FW_HEAD_SUBSYSTEM_INFO_SIZE          8
+#define FW_HEAD_OFFSET_SUBSYSTEM_INFO_BASE   32
+
+#define FW_SECTION_TYPE_SS51_ISP               0x01
+#define FW_SECTION_TYPE_SS51_PATCH             0x02
+#define FW_SECTION_TYPE_SS51_PATCH_OVERLAY     0x03
+#define FW_SECTION_TYPE_DSP                    0x04
+#define FW_SECTION_TYPE_HOTKNOT                0x05
+#define FW_SECTION_TYPE_GESTURE                0x06
+#define FW_SECTION_TYPE_GESTURE_OVERLAY        0x07
+#define FW_SECTION_TYPE_FLASHLESS_FAST_POWER   0x08
+
+#define UPDATE_TYPE_HEADER 0
+#define UPDATE_TYPE_FILE   1
+
+#define UPDATE_STATUS_IDLE     0
+#define UPDATE_STATUS_RUNNING  1
+#define UPDATE_STATUS_ABORT    2
+
+struct fw_subsystem_info {
+	int type;
+	int length;
+	u32 address;
+	int offset;
+};
+
+#pragma pack(1)
+struct fw_info {
+	u32 length;
+	u16 checksum;
+	u8 target_mask[6];
+	u8 target_mask_version[3];
+	u8 pid[6];
+	u8 version[3];
+	u8 subsystem_count;
+	u8 chip_type;
+	u8 reserved[6];
+	struct fw_subsystem_info subsystem[12];
+};
+#pragma pack()
+
+struct fw_update_info update_info = {
+	.status = UPDATE_STATUS_IDLE,
+	.progress = 0,
+	.max_progress = 9,
+	.force_update = 0
+};
+
+int gt1x_update_prepare(char *filename);
+int gt1x_check_firmware(void);
+u8 *gt1x_get_fw_data(u32 offset, int length);
+int gt1x_update_judge(void);
+int gt1x_run_ss51_isp(u8 *ss51_isp, int length);
+int gt1x_burn_subsystem(struct fw_subsystem_info *subsystem);
+u16 gt1x_calc_checksum(u8 *fw, u32 length);
+int gt1x_recall_check(u8 *chk_src, u16 start_rd_addr, u16 chk_length);
+void gt1x_update_cleanup(void);
+int gt1x_check_subsystem_in_flash(struct fw_subsystem_info *subsystem);
+int gt1x_read_flash(u32 addr, int length);
+int gt1x_error_erase(void);
+void dump_to_file(u16 addr, int length, char *filepath);
+
+int gt1x_update_firmware(void *filename);
+int gt1x_auto_update_proc(void *data);
+
+#if !GTP_HEADER_FW_UPDATE
+static int gt1x_search_update_files(void);
+#endif
+
+int gt1x_hold_ss51_dsp(void);
+void gt1x_leave_update_mode(void);
+
+/**
+ * @return: return 0 if success, otherwise return a negative number
+ *          which contains the error code.
+ */
+s32 gt1x_check_fs_mounted(char *path_name)
+{
+	struct path root_path;
+	struct path path;
+	s32 err;
+
+	err = kern_path("/", LOOKUP_FOLLOW, &root_path);
+	if (err)
+		return ERROR_PATH;
+
+	err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+	if (err) {
+		err = ERROR_PATH;
+		goto check_fs_fail;
+	}
+
+	if (path.mnt->mnt_sb == root_path.mnt->mnt_sb) {
+		/*not mounted*/
+		err = ERROR_PATH;
+	} else {
+		err = 0;
+	}
+
+	path_put(&path);
+check_fs_fail:
+	path_put(&root_path);
+	return err;
+}
+
+int gt1x_i2c_write_with_readback(u16 addr, u8 *buffer, int length)
+{
+	u8 buf[100];
+	int ret = gt1x_i2c_write(addr, buffer, length);
+	if (ret) {
+		return ret;
+	}
+	ret = gt1x_i2c_read(addr, buf, length);
+	if (ret) {
+		return ret;
+	}
+	if (memcmp(buf, buffer, length)) {
+		return ERROR_CHECK;
+	}
+	return 0;
+}
+
+#define getU32(a) ((u32)getUint((u8 *)(a), 4))
+#define getU16(a) ((u16)getUint((u8 *)(a), 2))
+u32 getUint(u8 *buffer, int len)
+{
+	u32 num = 0;
+	int i;
+	for (i = 0; i < len; i++) {
+		num <<= 8;
+		num += buffer[i];
+	}
+	return num;
+}
+
+int gt1x_auto_update_proc(void *data)
+{
+
+#if GTP_HEADER_FW_UPDATE
+	GTP_INFO("Start auto update thread...");
+	gt1x_update_firmware(NULL);
+#else
+	int ret;
+	char *filename;
+	u8 config[GTP_CONFIG_MAX_LENGTH] = { 0 };
+
+	GTP_INFO("Start auto update thread...");
+	ret = gt1x_search_update_files();
+	if (ret & (FOUND_FW_PATH_1 | FOUND_FW_PATH_2)) {
+		if (ret & FOUND_FW_PATH_1) {
+			filename = UPDATE_FILE_PATH_1;
+		} else {
+			filename = UPDATE_FILE_PATH_2;
+		}
+		gt1x_update_firmware(filename);
+	}
+
+	if (ret & (FOUND_CFG_PATH_1 | FOUND_CFG_PATH_2)) {
+		if (ret & FOUND_CFG_PATH_1) {
+			filename = CONFIG_FILE_PATH_1;
+		} else {
+			filename = CONFIG_FILE_PATH_2;
+		}
+
+		if (gt1x_parse_config(filename, config) > 0) {
+			if (gt1x_i2c_write(GTP_REG_CONFIG_DATA, config, GTP_CONFIG_MAX_LENGTH)) {
+				GTP_ERROR("Update config failed!");
+			} else {
+				GTP_INFO("Update config successfully!");
+			}
+		}
+	}
+#endif
+	return 0;
+}
+#if !GTP_HEADER_FW_UPDATE
+static int gt1x_search_update_files(void)
+{
+	/*wait 10s(max) if fs is not ready*/
+	int retry = 20 * 2;
+	struct file *pfile = NULL;
+	mm_segment_t old_fs;
+	int found = 0;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	GTP_INFO("Search firmware file...");
+	while (retry-- > 0) {
+		msleep(500);
+		/*check if rootfs is ready*/
+		if (gt1x_check_fs_mounted("/data")) {
+			GTP_DEBUG("filesystem is not ready");
+			continue;
+		}
+		/*search firmware*/
+		pfile = filp_open(UPDATE_FILE_PATH_1, O_RDONLY, 0);
+		if (IS_ERR(pfile)) {
+			pfile = filp_open(UPDATE_FILE_PATH_2, O_RDONLY, 0);
+			if (!IS_ERR(pfile)) {
+				found |= FOUND_FW_PATH_2;
+			}
+		} else {
+			found |= FOUND_FW_PATH_1;
+		}
+
+		if (!IS_ERR(pfile)) {
+			filp_close(pfile, NULL);
+		}
+		/*search config file*/
+		pfile = filp_open(CONFIG_FILE_PATH_1, O_RDONLY, 0);
+		if (IS_ERR(pfile)) {
+			pfile = filp_open(CONFIG_FILE_PATH_2, O_RDONLY, 0);
+			if (!IS_ERR(pfile)) {
+				found |= FOUND_CFG_PATH_2;
+			}
+		} else {
+			found |= FOUND_CFG_PATH_1;
+		}
+		if (!IS_ERR(pfile)) {
+			filp_close(pfile, NULL);
+		}
+
+		if (found) {
+			break;
+		}
+
+		GTP_INFO("Not found firmware or config file, retry.");
+	}
+	set_fs(old_fs);
+
+	return found;
+}
+#endif
+
+void gt1x_enter_update_mode(void)
+{
+	GTP_DEBUG("Enter FW update mode.");
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_OFF);
+#endif
+#if GTP_CHARGER_SWITCH
+	gt1x_charger_switch(SWITCH_OFF);
+#endif
+	gt1x_irq_disable();
+}
+
+int gt1x_update_firmware(void *filename)
+{
+	int i = 0;
+	int ret = 0;
+	u8 *p;
+
+	if (update_info.status != UPDATE_STATUS_IDLE) {
+		GTP_ERROR("Update process is running!");
+		return ERROR;
+	}
+	update_info.status = UPDATE_STATUS_RUNNING;
+	update_info.progress = 0;
+
+	gt1x_enter_update_mode();
+
+	ret = gt1x_update_prepare(filename);
+	if (ret) {
+		update_info.status = UPDATE_STATUS_IDLE;
+		return ret;
+	}
+
+	ret = gt1x_check_firmware();
+	if (ret) {
+		update_info.status = UPDATE_STATUS_ABORT;
+		goto gt1x_update_exit;
+	}
+#if GTP_FW_UPDATE_VERIFY
+	update_info.max_progress =
+		6 + update_info.firmware->subsystem_count;
+#else
+	update_info.max_progress =
+		3 + update_info.firmware->subsystem_count;
+#endif
+	update_info.progress++;
+
+	ret = gt1x_update_judge();
+	if (ret) {
+		update_info.status = UPDATE_STATUS_ABORT;
+		goto gt1x_update_exit;
+	}
+	update_info.progress++;
+
+	p = gt1x_get_fw_data(update_info.firmware->subsystem[0].offset, update_info.firmware->subsystem[0].length);
+	if (p == NULL) {
+		GTP_ERROR("get isp fail");
+		ret = ERROR_FW;
+		update_info.status = UPDATE_STATUS_ABORT;
+		goto gt1x_update_exit;
+	}
+	update_info.progress++;
+
+	ret = gt1x_run_ss51_isp(p, update_info.firmware->subsystem[0].length);
+	if (ret) {
+		GTP_ERROR("run isp fail");
+		goto gt1x_update_exit;
+	}
+	update_info.progress++;
+	msleep(800);
+
+	for (i = 1; i < update_info.firmware->subsystem_count; i++) {
+		GTP_INFO("subsystem: %d", update_info.firmware->subsystem[i].type);
+		GTP_INFO("Length: %d", update_info.firmware->subsystem[i].length);
+		GTP_INFO("Address: %d", update_info.firmware->subsystem[i].address);
+
+		ret = gt1x_burn_subsystem(&(update_info.firmware->subsystem[i]));
+		if (ret) {
+			GTP_ERROR("burn subsystem fail!");
+			goto gt1x_update_exit;
+		}
+		update_info.progress++;
+	}
+
+#if GTP_FW_UPDATE_VERIFY
+	gt1x_reset_guitar();
+
+	p = gt1x_get_fw_data(update_info.firmware->subsystem[0].offset, update_info.firmware->subsystem[0].length);
+	if (p == NULL) {
+		GTP_ERROR("get isp fail");
+		ret = ERROR_FW;
+		goto gt1x_update_exit;
+	}
+	update_info.progress++;
+
+	ret = gt1x_run_ss51_isp(p, update_info.firmware->subsystem[0].length);
+	if (ret) {
+		GTP_ERROR("run isp fail");
+		goto gt1x_update_exit;
+	}
+	update_info.progress++;
+
+	GTP_INFO("Reset guitar & check firmware in flash.");
+	for (i = 1; i < update_info.firmware->subsystem_count; i++) {
+		GTP_INFO("subsystem: %d", update_info.firmware->subsystem[i].type);
+		GTP_INFO("Length: %d", update_info.firmware->subsystem[i].length);
+		GTP_INFO("Address: %d", update_info.firmware->subsystem[i].address);
+
+		ret = gt1x_check_subsystem_in_flash(&(update_info.firmware->subsystem[i]));
+		if (ret) {
+			gt1x_error_erase();
+			break;
+		}
+	}
+	update_info.progress++;
+#endif
+
+gt1x_update_exit:
+	gt1x_update_cleanup();
+	gt1x_leave_update_mode();
+	gt1x_read_version(NULL);
+	if (ret) {
+		update_info.progress = 2 * update_info.max_progress;
+		GTP_ERROR("Update firmware failed!");
+		return ret;
+	} else if (gt1x_init_failed) {
+		gt1x_read_version(&gt1x_version);
+		gt1x_init_panel();
+#if GTP_CHARGER_SWITCH
+		gt1x_parse_chr_cfg(gt1x_version.sensor_id);
+#endif
+#if GTP_SMART_COVER
+		gt1x_parse_sc_cfg(gt1x_version.sensor_id);
+#endif
+	}
+	GTP_INFO("Update firmware succeefully!");
+	return ret;
+}
+
+int gt1x_update_prepare(char *filename)
+{
+	int ret = 0;
+	int retry = 5;
+	if (filename == NULL) {
+#if GTP_HEADER_FW_UPDATE
+		update_info.fw_name = NULL;
+		update_info.update_type = UPDATE_TYPE_HEADER;
+		update_info.fw_data = gt1x_default_FW;
+		update_info.fw_length = sizeof(gt1x_default_FW);
+#else
+		GTP_ERROR("No Fw in .h file!");
+		return ERROR_FW;
+#endif
+	} else {
+		GTP_INFO("Firmware: %s", filename);
+		update_info.old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		update_info.fw_name = filename;
+		update_info.update_type = UPDATE_TYPE_FILE;
+		update_info.fw_file = filp_open(update_info.fw_name, O_RDONLY, 0);
+		if (IS_ERR(update_info.fw_file)) {
+			GTP_ERROR("Open update file(%s) error!", update_info.fw_name);
+			set_fs(update_info.old_fs);
+			return ERROR_FILE;
+		}
+		update_info.fw_file->f_op->llseek(update_info.fw_file, 0, SEEK_SET);
+		update_info.fw_length = update_info.fw_file->f_op->llseek(update_info.fw_file, 0, SEEK_END);
+	}
+
+	while (retry > 0) {
+		retry--;
+		update_info.firmware = kzalloc(sizeof(struct fw_info), GFP_KERNEL);
+		if (update_info.firmware == NULL) {
+			GTP_INFO("Alloc %zu bytes memory fail.", sizeof(struct fw_info));
+			continue;
+		} else {
+			GTP_INFO("Alloc %zu bytes memory success.", sizeof(struct fw_info));
+			break;
+		}
+	}
+	if (retry <= 0) {
+		ret = ERROR_RETRY;
+		goto gt1x_update_pre_fail1;
+	}
+
+	retry = 5;
+	while (retry > 0) {
+		update_info.buffer = kzalloc(1024 * 4, GFP_KERNEL);
+		if (update_info.buffer == NULL) {
+			GTP_ERROR("Alloc %d bytes memory fail.", 1024 * 4);
+			continue;
+		} else {
+			GTP_INFO("Alloc %d bytes memory success.", 1024 * 4);
+			break;
+		}
+	}
+	if (retry <= 0) {
+		ret = ERROR_RETRY;
+		goto gt1x_update_pre_fail0;
+	}
+
+	return 0;
+
+gt1x_update_pre_fail0:
+	kfree(update_info.firmware);
+gt1x_update_pre_fail1:
+	filp_close(update_info.fw_file, NULL);
+	return ret;
+}
+
+void gt1x_update_cleanup(void)
+{
+	if (update_info.update_type == UPDATE_TYPE_FILE) {
+		if (update_info.fw_file != NULL) {
+			filp_close(update_info.fw_file, NULL);
+			update_info.fw_file = NULL;
+		}
+		set_fs(update_info.old_fs);
+	}
+
+	if (update_info.buffer != NULL) {
+		kfree(update_info.buffer);
+		update_info.buffer = NULL;
+	}
+	if (update_info.firmware != NULL) {
+		kfree(update_info.firmware);
+		update_info.firmware = NULL;
+	}
+}
+
+int gt1x_check_firmware(void)
+{
+	u16 checksum;
+	u16 checksum_in_header;
+	u8 *p;
+	struct fw_info *firmware;
+	int i;
+	int offset;
+
+	/*compare file length with the length field in the firmware header*/
+	if (update_info.fw_length < FW_HEAD_SIZE) {
+		GTP_ERROR("Bad firmware!(file length: %d)", update_info.fw_length);
+		return ERROR_CHECK;
+	}
+	p = gt1x_get_fw_data(0, 6);
+	if (p == NULL) {
+		return ERROR_FW;
+	}
+
+	if (getU32(p) + 6 != update_info.fw_length) {
+		GTP_ERROR("Bad firmware!(file length: %d, header define: %d)", update_info.fw_length, getU32(p));
+		return ERROR_CHECK;
+	}
+	/*check firmware's checksum*/
+	checksum_in_header = getU16(&p[4]);
+	checksum = 0;
+	for (i = 6; i < update_info.fw_length; i++) {
+		p = gt1x_get_fw_data(i, 1);
+		if (p == NULL) {
+			return ERROR_FW;
+		}
+		checksum += p[0];
+	}
+
+	if (checksum != checksum_in_header) {
+		GTP_ERROR("Bad firmware!(checksum: 0x%04X, header define: 0x%04X)", checksum, checksum_in_header);
+		return ERROR_CHECK;
+	}
+	/*parse firmware*/
+	p = gt1x_get_fw_data(0, FW_HEAD_SIZE);
+	if (p == NULL) {
+		return ERROR_FW;
+	}
+	memcpy((u8 *) update_info.firmware, p, FW_HEAD_SIZE - 8 * 12);
+	update_info.firmware->pid[5] = 0;
+
+	p = &p[FW_HEAD_OFFSET_SUBSYSTEM_INFO_BASE];
+	firmware = update_info.firmware;
+	offset = FW_HEAD_SIZE;
+	for (i = 0; i < firmware->subsystem_count; i++) {
+		firmware->subsystem[i].type = p[i * FW_HEAD_SUBSYSTEM_INFO_SIZE];
+		firmware->subsystem[i].length = getU16(&p[i * FW_HEAD_SUBSYSTEM_INFO_SIZE + 1]);
+		firmware->subsystem[i].address = getU16(&p[i * FW_HEAD_SUBSYSTEM_INFO_SIZE + 3]) * 256;
+		firmware->subsystem[i].offset = offset;
+		offset += firmware->subsystem[i].length;
+	}
+
+	/*print update information*/
+	GTP_INFO("Update type: %s", update_info.update_type == UPDATE_TYPE_HEADER ? "Header" : "File");
+	GTP_INFO("Firmware length: %d", update_info.fw_length);
+	GTP_INFO("Firmware product: GT%s", update_info.firmware->pid);
+	GTP_INFO("Firmware patch: %02X%02X%02X", update_info.firmware->version[0], update_info.firmware->version[1], update_info.firmware->version[2]);
+	GTP_INFO("Firmware chip: 0x%02X", update_info.firmware->chip_type);
+	GTP_INFO("Subsystem count: %d", update_info.firmware->subsystem_count);
+	for (i = 0; i < update_info.firmware->subsystem_count; i++) {
+		GTP_DEBUG("------------------------------------------");
+		GTP_DEBUG("Subsystem: %d", i);
+		GTP_DEBUG("Type: %d", update_info.firmware->subsystem[i].type);
+		GTP_DEBUG("Length: %d", update_info.firmware->subsystem[i].length);
+		GTP_DEBUG("Address: 0x%08X", update_info.firmware->subsystem[i].address);
+		GTP_DEBUG("Offset: %d", update_info.firmware->subsystem[i].offset);
+	}
+
+	return 0;
+}
+
+/**
+ * @return: return a pointer pointed at the content of firmware
+ *          if success, otherwise return NULL.
+ */
+u8 *gt1x_get_fw_data(u32 offset, int length)
+{
+	int ret;
+	if (update_info.update_type == UPDATE_TYPE_FILE) {
+		update_info.fw_file->f_op->llseek(update_info.fw_file, offset, SEEK_SET);
+		ret = update_info.fw_file->f_op->read(update_info.fw_file, (char *)update_info.buffer, length, &update_info.fw_file->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("Read data error!");
+			return NULL;
+		}
+		return update_info.buffer;
+	} else {
+		return &update_info.fw_data[offset];
+	}
+}
+
+int gt1x_update_judge(void)
+{
+	int ret;
+	u8 reg_val[2] = {0};
+	u8 retry = 2;
+	struct gt1x_version_info ver_info;
+	struct gt1x_version_info fw_ver_info;
+
+	fw_ver_info.mask_id = (update_info.firmware->target_mask_version[0] << 16)
+		| (update_info.firmware->target_mask_version[1] << 8)
+		| (update_info.firmware->target_mask_version[2]);
+	fw_ver_info.patch_id = (update_info.firmware->version[0] << 16)
+		| (update_info.firmware->version[1] << 8)
+		| (update_info.firmware->version[2]);
+	memcpy(fw_ver_info.product_id, update_info.firmware->pid, 4);
+	fw_ver_info.product_id[4] = 0;
+
+	/* check fw status reg */
+	do {
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_MAINSYS, reg_val, 1);
+		if (ret < 0) {	/* read reg failed */
+			goto _reset;
+		} else if (ret > 0) {
+			continue;
+		}
+
+		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_SUBSYS, &reg_val[1], 1);
+		if (ret < 0) {
+			goto _reset;
+		} else if (ret > 0) {
+			continue;
+		}
+
+		break;
+_reset:
+		gt1x_reset_guitar();
+	} while (--retry);
+
+	if (!retry) {
+		GTP_INFO("Update abort because of i2c error.");
+		return ERROR_CHECK;
+	}
+	if (reg_val[0] != 0xBE || reg_val[1] == 0xAA) {
+		GTP_INFO("Check fw status reg not pass,reg[0x814E]=0x%2X,reg[0x5095]=0x%2X!",
+				reg_val[0], reg_val[1]);
+		return 0;
+	}
+
+	ret = gt1x_read_version(&ver_info);
+	if (ret < 0) {
+		GTP_INFO("Get IC's version info failed, force update!");
+		return 0;
+	}
+
+	if (memcmp(fw_ver_info.product_id, ver_info.product_id, 4)) {
+		GTP_INFO("Product id is not match!");
+		return ERROR_CHECK;
+	}
+	if ((fw_ver_info.mask_id & 0xFFFFFF00) != (ver_info.mask_id & 0xFFFFFF00)) {
+		GTP_INFO("Mask id is not match!");
+		return ERROR_CHECK;
+	}
+	if ((fw_ver_info.patch_id & 0xFF0000) != (ver_info.patch_id & 0xFF0000)) {
+		GTP_INFO("CID is not equal, need update!");
+		return 0;
+	}
+#if GTP_DEBUG_ON
+	if (update_info.force_update) {
+		GTP_DEBUG("Debug mode, force update fw.");
+		return 0;
+	}
+#endif
+	if ((fw_ver_info.patch_id & 0xFFFF) <= (ver_info.patch_id & 0xFFFF)) {
+		GTP_INFO("The version of the fw is not high than the IC's!");
+		return ERROR_CHECK;
+	}
+	return 0;
+}
+
+int __gt1x_hold_ss51_dsp_20(void)
+{
+	int ret = -1;
+	int retry = 0;
+	u8 buf[1];
+	int hold_times = 0;
+
+	while (retry++ < 30) {
+		/*Hold ss51 & dsp*/
+		buf[0] = 0x0C;
+		ret = gt1x_i2c_write(_rRW_MISCTL__SWRST_B0_, buf, 1);
+		if (ret) {
+			GTP_ERROR("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		/*Confirm hold*/
+		buf[0] = 0x00;
+		ret = gt1x_i2c_read(_rRW_MISCTL__SWRST_B0_, buf, 1);
+		if (ret) {
+			GTP_ERROR("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		if (0x0C == buf[0]) {
+			if (hold_times++ < 20) {
+				continue;
+			} else {
+				break;
+			}
+		}
+		GTP_ERROR("Hold ss51 & dsp confirm 0x4180 failed,value:%d", buf[0]);
+	}
+	if (retry >= 30) {
+		GTP_ERROR("Hold ss51&dsp failed!");
+		return ERROR_RETRY;
+	}
+
+	GTP_INFO("Hold ss51&dsp successfully.");
+	return 0;
+}
+
+int gt1x_hold_ss51_dsp(void)
+{
+	int ret = ERROR, retry = 5;
+	u8 buffer[2];
+
+	do {
+		gt1x_select_addr();
+		ret =  gt1x_i2c_read(0x4220, buffer, 1);
+
+	} while (retry-- && ret < 0);
+
+	if (ret < 0)
+		return ERROR;
+
+	/*hold ss51_dsp*/
+	ret = __gt1x_hold_ss51_dsp_20();
+	if (ret) {
+		return ret;
+	}
+	/*enable dsp & mcu power*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__DSP_MCU_PWR_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("enabel dsp & mcu power fail!");
+		return ret;
+	}
+	/*disable watchdog*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__TMR0_EN, buffer, 1);
+	if (ret) {
+		GTP_ERROR("disable wdt fail!");
+		return ret;
+	}
+	/*clear cache*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__CACHE_EN, buffer, 1);
+	if (ret) {
+		GTP_ERROR("clear cache fail!");
+		return ret;
+	}
+	/*soft reset*/
+	buffer[0] = 0x01;
+	ret = gt1x_i2c_write(_bWO_MISCTL__CPU_SWRST_PULSE, buffer, 1);
+	if (ret) {
+		GTP_ERROR("software reset fail!");
+		return ret;
+	}
+	/*set scramble*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_rRW_MISCTL__BOOT_OPT_B0_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("set scramble fail!");
+		return ret;
+	}
+
+	return 0;
+}
+
+int gt1x_run_ss51_isp(u8 *ss51_isp, int length)
+{
+	int ret;
+	u8 buffer[10];
+
+	ret = gt1x_hold_ss51_dsp();
+	if (ret) {
+		return ret;
+	}
+	/*select bank4*/
+	buffer[0] = 0x04;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__SRAM_BANK, buffer, 1);
+	if (ret) {
+		GTP_ERROR("select bank4 fail.");
+		return ret;
+	}
+	/*enable patch area access*/
+	buffer[0] = 0x01;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__PATCH_AREA_EN_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("enable patch area access fail!");
+		return ret;
+	}
+
+	GTP_INFO("ss51_isp length: %d, checksum: 0x%04X", length, gt1x_calc_checksum(ss51_isp, length));
+	/*load ss51 isp*/
+	ret = gt1x_i2c_write(0xC000, ss51_isp, length);
+	if (ret) {
+		GTP_ERROR("load ss51 isp fail!");
+		return ret;
+	}
+	/*recall compare*/
+	ret = gt1x_recall_check(ss51_isp, 0xC000, length);
+	if (ret) {
+		GTP_ERROR("recall check ss51 isp fail!");
+		return ret;
+	}
+
+	memset(buffer, 0xAA, 10);
+	ret = gt1x_i2c_write_with_readback(0x8140, buffer, 10);
+
+	/*disable patch area access*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__PATCH_AREA_EN_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("disable patch area access fail!");
+		return ret;
+	}
+	/*set 0x8006*/
+	memset(buffer, 0x55, 8);
+	ret = gt1x_i2c_write_with_readback(0x8006, buffer, 8);
+	if (ret) {
+		GTP_ERROR("set 0x8006[0~7] 0x55 fail!");
+		return ret;
+	}
+	/*release ss51*/
+	buffer[0] = 0x08;
+	ret = gt1x_i2c_write_with_readback(_rRW_MISCTL__SWRST_B0_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("release ss51 fail!");
+		return ret;
+	}
+
+	msleep(100);
+	/*check run state*/
+	ret = gt1x_i2c_read(0x8006, buffer, 2);
+	if (ret) {
+		GTP_ERROR("read 0x8006 fail!");
+		return ret;
+	}
+	if (!(buffer[0] == 0xAA && buffer[1] == 0xBB)) {
+		GTP_ERROR("ERROR: isp is not running! 0x8006: %02X %02X", buffer[0], buffer[1]);
+		return ERROR_CHECK;
+	}
+
+	return 0;
+}
+
+u16 gt1x_calc_checksum(u8 *fw, u32 length)
+{
+	u32 i = 0;
+	u32 checksum = 0;
+
+	for (i = 0; i < length; i += 2) {
+		checksum += (((int)fw[i]) << 8);
+		checksum += fw[i + 1];
+	}
+	return (checksum & 0xFFFF);
+}
+
+int gt1x_recall_check(u8 *chk_src, u16 start_addr, u16 chk_length)
+{
+	u8 rd_buf[PACK_SIZE];
+	s32 ret = 0;
+	u16 len = 0;
+	u32 compared_length = 0;
+
+	while (chk_length > 0) {
+		len = (chk_length > PACK_SIZE ? PACK_SIZE : chk_length);
+
+		ret = gt1x_i2c_read(start_addr + compared_length, rd_buf, len);
+		if (ret) {
+			GTP_ERROR("recall i2c error,exit!");
+			return ret;
+		}
+
+		if (memcmp(rd_buf, &chk_src[compared_length], len)) {
+			GTP_ERROR("Recall frame not equal(addr: 0x%04X)", start_addr + compared_length);
+			GTP_DEBUG("chk_src array:");
+			GTP_DEBUG_ARRAY(&chk_src[compared_length], len);
+			GTP_DEBUG("recall array:");
+			GTP_DEBUG_ARRAY(rd_buf, len);
+			return ERROR_CHECK;
+		}
+
+		chk_length -= len;
+		compared_length += len;
+	}
+
+	GTP_DEBUG("Recall check %d bytes(address: 0x%04X) success.", compared_length, start_addr);
+	return 0;
+}
+
+int gt1x_burn_subsystem(struct fw_subsystem_info *subsystem)
+{
+	int block_len;
+	u16 checksum;
+	int burn_len = 0;
+	u16 cur_addr;
+	u32 length = subsystem->length;
+	u8 buffer[10];
+	int ret;
+	int wait_time;
+	int burn_state;
+	int retry = 5;
+	u8 *fw;
+
+	GTP_INFO("Subsystem: %d", subsystem->type);
+	GTP_INFO("Length: %d", subsystem->length);
+	GTP_INFO("Address: 0x%08X", subsystem->address);
+
+	while (length > 0 && retry > 0) {
+		retry--;
+
+		block_len = length > 1024 * 4 ? 1024 * 4 : length;
+
+		GTP_INFO("Burn block ==> length: %d, address: 0x%08X", block_len, subsystem->address + burn_len);
+		fw = gt1x_get_fw_data(subsystem->offset + burn_len, block_len);
+		if (!fw)
+			return ERROR_FW;
+		cur_addr = ((subsystem->address + burn_len) >> 8);
+
+		checksum = 0;
+		checksum += block_len;
+		checksum += cur_addr;
+		checksum += gt1x_calc_checksum(fw, block_len);
+		checksum = (0 - checksum);
+
+		buffer[0] = ((block_len >> 8) & 0xFF);
+		buffer[1] = (block_len & 0xFF);
+		buffer[2] = ((cur_addr >> 8) & 0xFF);
+		buffer[3] = (cur_addr & 0xFF);
+
+		ret = gt1x_i2c_write_with_readback(0x8100, buffer, 4);
+		if (ret) {
+			GTP_ERROR("write length & address fail!");
+			continue;
+		}
+
+		ret = gt1x_i2c_write(0x8100 + 4, fw, block_len);
+		if (ret) {
+			GTP_ERROR("write fw data fail!");
+			continue;
+		}
+
+		buffer[0] = ((checksum >> 8) & 0xFF);
+		buffer[1] = (checksum & 0xFF);
+		ret = gt1x_i2c_write_with_readback(0x8100 + 4 + block_len, buffer, 2);
+		if (ret) {
+			GTP_ERROR("write checksum fail!");
+			continue;
+		}
+
+		buffer[0] = 0;
+		ret = gt1x_i2c_write_with_readback(0x8022, buffer, 1);
+		if (ret) {
+			GTP_ERROR("clear control flag fail!");
+			continue;
+		}
+
+		buffer[0] = subsystem->type;
+		buffer[1] = subsystem->type;
+		ret = gt1x_i2c_write_with_readback(0x8020, buffer, 2);
+		if (ret) {
+			GTP_ERROR("write subsystem type fail!");
+			continue;
+		}
+		burn_state = ERROR;
+		wait_time = 200;
+		msleep(5);
+
+		while (wait_time-- > 0) {
+			u8 confirm = 0x55;
+
+			ret = gt1x_i2c_read(0x8022, buffer, 1);
+			if (ret < 0) {
+				continue;
+			}
+			msleep(5);
+			ret = gt1x_i2c_read(0x8022, &confirm, 1);
+			if (ret < 0) {
+				continue;
+			}
+			if (buffer[0] != confirm)
+				continue;
+
+			if (buffer[0] == 0xAA) {
+				GTP_DEBUG("burning.....");
+				continue;
+			} else if (buffer[0] == 0xDD) {
+				GTP_ERROR("checksum error!");
+				break;
+			} else if (buffer[0] == 0xBB) {
+				GTP_INFO("burning success.");
+				burn_state = 0;
+				break;
+			} else if (buffer[0] == 0xCC) {
+				GTP_ERROR("burning failed!");
+				break;
+			} else {
+				GTP_DEBUG("unknown state!(0x8022: 0x%02X)", buffer[0]);
+			}
+		}
+
+		if (!burn_state) {
+			length -= block_len;
+			burn_len += block_len;
+			retry = 5;
+		}
+	}
+	if (length == 0) {
+		return 0;
+	} else {
+		return ERROR_RETRY;
+	}
+}
+
+int gt1x_check_subsystem_in_flash(struct fw_subsystem_info *subsystem)
+{
+	int block_len;
+	int checked_len = 0;
+	u32 length = subsystem->length;
+	int ret;
+	int check_state = 0;
+	int retry = 5;
+	u8 *fw;
+
+	GTP_INFO("Subsystem: %d", subsystem->type);
+	GTP_INFO("Length: %d", subsystem->length);
+	GTP_INFO("Address: 0x%08X", subsystem->address);
+
+	while (length > 0) {
+		block_len = length > 1024 * 4 ? 1024 * 4 : length;
+
+		GTP_INFO("Check block ==> length: %d, address: 0x%08X", block_len, subsystem->address + checked_len);
+		fw = gt1x_get_fw_data(subsystem->offset + checked_len, block_len);
+		if (fw == NULL) {
+			return ERROR_FW;
+		}
+		ret = gt1x_read_flash(subsystem->address + checked_len, block_len);
+		if (ret) {
+			check_state |= ret;
+		}
+
+		ret = gt1x_recall_check(fw, 0x8100, block_len);
+		if (ret) {
+			GTP_ERROR("Block in flash is broken!");
+			check_state |= ret;
+		}
+
+		length -= block_len;
+		checked_len += block_len;
+		retry = 5;
+	}
+	if (check_state) {
+		GTP_ERROR("Subsystem in flash is broken!");
+	} else {
+		GTP_INFO("Subsystem in flash is correct!");
+	}
+	return check_state;
+}
+
+int gt1x_read_flash(u32 addr, int length)
+{
+	int wait_time;
+	int ret = 0;
+	u8 buffer[4];
+	u16 read_addr = (addr >> 8);
+
+	GTP_INFO("Read flash: 0x%04X, length: %d", addr, length);
+
+	buffer[0] = 0;
+	ret = gt1x_i2c_write_with_readback(0x8022, buffer, 1);
+
+	buffer[0] = ((length >> 8) & 0xFF);
+	buffer[1] = (length & 0xFF);
+	buffer[2] = ((read_addr >> 8) & 0xFF);
+	buffer[3] = (read_addr & 0xFF);
+	ret |= gt1x_i2c_write_with_readback(0x8100, buffer, 4);
+
+	buffer[0] = 0xAA;
+	buffer[1] = 0xAA;
+	ret |= gt1x_i2c_write(0x8020, buffer, 2);
+	if (ret) {
+		GTP_ERROR("Error occured.");
+		return ret;
+	}
+
+	wait_time = 200;
+	while (wait_time > 0) {
+		wait_time--;
+		msleep(5);
+		ret = gt1x_i2c_read_dbl_check(0x8022, buffer, 1);
+		if (ret) {
+			continue;
+		}
+		if (buffer[0] == 0xBB) {
+			GTP_INFO("Read success(addr: 0x%04X, length: %d)", addr, length);
+			break;
+		}
+	}
+	if (wait_time == 0) {
+		GTP_ERROR("Read Flash FAIL!");
+		return ERROR_RETRY;
+	}
+	return 0;
+}
+
+int gt1x_error_erase(void)
+{
+	int block_len;
+	u16 checksum;
+	u16 erase_addr;
+	u8 buffer[10];
+	int ret;
+	int wait_time;
+	int burn_state = ERROR;
+	int retry = 5;
+	u8 *fw = NULL;
+
+	GTP_INFO("Erase flash area of ss51.");
+
+	gt1x_reset_guitar();
+
+	fw = gt1x_get_fw_data(update_info.firmware->subsystem[0].offset,
+			update_info.firmware->subsystem[0].length);
+	if (!fw) {
+		GTP_ERROR("get isp fail");
+		return ERROR_FW;
+	}
+	ret = gt1x_run_ss51_isp(fw, update_info.firmware->subsystem[0].length);
+	if (ret) {
+		GTP_ERROR("run isp fail");
+		return ERROR_PATH;
+	}
+
+	fw = kmalloc(1024 * 4, GFP_KERNEL);
+	if (!fw) {
+		GTP_ERROR("error when alloc mem.");
+		return ERROR_MEM;
+	}
+
+	memset(fw, 0xFF, 1024 * 4);
+	erase_addr = 0x00;
+	block_len = 1024 * 4;
+
+	while (retry-- > 0) {
+		checksum = 0;
+		checksum += block_len;
+	    checksum += erase_addr;
+	    checksum += gt1x_calc_checksum(fw, block_len);
+	    checksum = (0 - checksum);
+
+	    buffer[0] = ((block_len >> 8) & 0xFF);
+	    buffer[1] = (block_len & 0xFF);
+	    buffer[2] = ((erase_addr >> 8) & 0xFF);
+	    buffer[3] = (erase_addr & 0xFF);
+
+	    ret = gt1x_i2c_write_with_readback(0x8100, buffer, 4);
+	    if (ret) {
+		    GTP_ERROR("write length & address fail!");
+		    continue;
+	    }
+
+	    ret = gt1x_i2c_write(0x8100 + 4, fw, block_len);
+	    if (ret) {
+		    GTP_ERROR("write fw data fail!");
+		    continue;
+	    }
+
+	    ret = gt1x_recall_check(fw, 0x8100 + 4, block_len);
+	    if (ret)
+		    continue;
+
+	    buffer[0] = ((checksum >> 8) & 0xFF);
+	    buffer[1] = (checksum & 0xFF);
+	    ret = gt1x_i2c_write_with_readback(0x8100 + 4 + block_len, buffer, 2);
+	    if (ret) {
+		    GTP_ERROR("write checksum fail!");
+		    continue;
+	    }
+
+	    buffer[0] = 0;
+	    ret = gt1x_i2c_write_with_readback(0x8022, buffer, 1);
+	    if (ret) {
+		    GTP_ERROR("clear control flag fail!");
+		    continue;
+	    }
+
+	    buffer[0] = FW_SECTION_TYPE_SS51_PATCH;
+	    buffer[1] = FW_SECTION_TYPE_SS51_PATCH;
+	    ret = gt1x_i2c_write_with_readback(0x8020, buffer, 2);
+	    if (ret) {
+		    GTP_ERROR("write subsystem type fail!");
+		    continue;
+	    }
+	    burn_state = ERROR;
+	    wait_time = 200;
+	    while (wait_time > 0) {
+		    wait_time--;
+		    msleep(5);
+		    ret = gt1x_i2c_read_dbl_check(0x8022, buffer, 1);
+		    if (ret)
+			    continue;
+
+		    if (buffer[0] == 0xAA) {
+			    GTP_DEBUG("burning.....");
+			    continue;
+		    } else if (buffer[0] == 0xDD) {
+			    GTP_ERROR("checksum error!");
+			    break;
+		    } else if (buffer[0] == 0xBB) {
+			    GTP_INFO("burning success.");
+			    burn_state = 0;
+			    break;
+		    } else if (buffer[0] == 0xCC) {
+			    GTP_ERROR("burning failed!");
+			    break;
+		    } else {
+			    GTP_DEBUG("unknown state!(0x8022: 0x%02X)", buffer[0]);
+		    }
+	    }
+    }
+
+    kfree(fw);
+    if (burn_state == 0)
+	    return 0;
+    else
+	    return ERROR_RETRY;
+}
+
+void gt1x_leave_update_mode(void)
+{
+	GTP_DEBUG("Leave FW update mode.");
+	if (update_info.status != UPDATE_STATUS_ABORT)
+		gt1x_reset_guitar();
+#if GTP_CHARGER_SWITCH
+	gt1x_charger_switch(SWITCH_ON);
+#endif
+#if GTP_ESD_PROTECT
+	gt1x_esd_switch(SWITCH_ON);
+#endif
+	update_info.status = UPDATE_STATUS_IDLE;
+	gt1x_irq_enable();
+}
+
+void dump_to_file(u16 addr, int length, char *filepath)
+{
+	struct file *flp = NULL;
+	u8 buf[128];
+	const int READ_BLOCK_SIZE = 128;
+	int read_length = 0;
+	int len = 0;
+
+	GTP_INFO("Dump(0x%04X, %d bytes) to file: %s\n", addr, length, filepath);
+	flp = filp_open(filepath, O_RDWR | O_CREAT, 0666);
+	if (IS_ERR(flp)) {
+		GTP_ERROR("can not open file: %s\n", filepath);
+		return;
+	}
+	flp->f_op->llseek(flp, 0, SEEK_SET);
+
+	while (length > 0) {
+		len = (length > READ_BLOCK_SIZE ? READ_BLOCK_SIZE : length);
+		memset(buf, 0x33, len);
+		if (gt1x_i2c_read(addr + read_length, buf, len))
+			memset(buf, 0x33, len);
+		flp->f_op->write(flp, (char *)buf, len, &flp->f_pos);
+		read_length += len;
+		length -= len;
+	}
+	filp_close(flp, NULL);
+}
+
+int gt1x_hold_ss51_dsp_no_reset(void)
+{
+	int ret = ERROR;
+	u8 buffer[2];
+
+	/*hold ss51_dsp*/
+	ret = __gt1x_hold_ss51_dsp_20();
+	if (ret)
+		return ret;
+	/*enable dsp & mcu power*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__DSP_MCU_PWR_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("enabel dsp & mcu power fail!");
+		return ret;
+	}
+	/*disable watchdog*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__TMR0_EN, buffer, 1);
+	if (ret) {
+		GTP_ERROR("disable wdt fail!");
+		return ret;
+	}
+	/*clear cache*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__CACHE_EN, buffer, 1);
+	if (ret) {
+		GTP_ERROR("clear cache fail!");
+		return ret;
+	}
+	/*soft reset*/
+	buffer[0] = 0x01;
+	ret = gt1x_i2c_write(_bWO_MISCTL__CPU_SWRST_PULSE, buffer, 1);
+	if (ret) {
+		GTP_ERROR("software reset fail!");
+		return ret;
+	}
+	/*set scramble*/
+	buffer[0] = 0x00;
+	ret = gt1x_i2c_write_with_readback(_rRW_MISCTL__BOOT_OPT_B0_, buffer, 1);
+	if (ret) {
+		GTP_ERROR("set scramble fail!");
+		return ret;
+	}
+
+	return 0;
+}
+
+#define GT1X_LOAD_PACKET_SIZE (1024 * 2)
+
+int gt1x_load_patch(u8 *patch, u32 patch_size, int offset, int bank_size)
+{
+	s32 loaded_length = 0;
+	s32 len = 0;
+	s32 ret = 0;
+	u8 bank = 0, tmp;
+	u16 address;
+
+	GTP_INFO("Load patch code(size: %d, checksum: 0x%04X, position: 0x%04X, bank-size: %d", patch_size, gt1x_calc_checksum(patch, patch_size), 0xC000 + offset, bank_size);
+	while (loaded_length != patch_size) {
+		if (loaded_length == 0 || (loaded_length + offset) % bank_size == 0) {
+			/*select bank*/
+			bank = 0x04 + (loaded_length + offset) / bank_size;
+			ret = gt1x_i2c_write(_bRW_MISCTL__SRAM_BANK, &bank, 1);
+			if (ret) {
+				GTP_ERROR("select bank%d fail!", bank);
+				return ret;
+			}
+			GTP_INFO("Select bank%d success.", bank);
+			/*enable patch area access*/
+			tmp = 0x01;
+			ret = gt1x_i2c_write_with_readback(_bRW_MISCTL__PATCH_AREA_EN_ + bank - 4, &tmp, 1);
+			if (ret) {
+				GTP_ERROR("enable patch area access fail!");
+				return ret;
+			}
+		}
+
+		len = patch_size - loaded_length > GT1X_LOAD_PACKET_SIZE ? GT1X_LOAD_PACKET_SIZE : patch_size - loaded_length;
+		address = 0xC000 + (loaded_length + offset) % bank_size;
+
+		ret = gt1x_i2c_write(address, &patch[loaded_length], len);
+		if (ret) {
+			GTP_ERROR("load 0x%04X, %dbytes fail!", address, len);
+			return ret;
+		}
+		ret = gt1x_recall_check(&patch[loaded_length], address, len);
+		if (ret) {
+			GTP_ERROR("Recall check 0x%04X, %dbytes fail!", address, len);
+			return ret;
+		}
+		GTP_INFO("load code 0x%04X, %dbytes success.", address, len);
+
+		loaded_length += len;
+	}
+
+	return 0;
+}
+
+int gt1x_startup_patch(void)
+{
+	s32 ret = 0;
+	u8 buffer[8] = { 0x55 };
+
+	buffer[0] = 0x00;
+	buffer[1] = 0x00;
+	ret |= gt1x_i2c_write(_bRW_MISCTL__PATCH_AREA_EN_, buffer, 2);
+
+	memset(buffer, 0x55, 8);
+	ret |= gt1x_i2c_write(GTP_REG_FLASH_PASSBY, buffer, 8);
+	ret |= gt1x_i2c_write(GTP_REG_VERSION, buffer, 5);
+
+	buffer[0] = 0xAA;
+	ret |= gt1x_i2c_write(GTP_REG_CMD, buffer, 1);
+	ret |= gt1x_i2c_write(GTP_REG_ESD_CHECK, buffer, 1);
+
+	buffer[0] = 0x00;
+	ret |= gt1x_i2c_write(_rRW_MISCTL__SWRST_B0_, buffer, 1);
+
+	msleep(200);
+
+	return ret;
+}
-- 
2.35.3

