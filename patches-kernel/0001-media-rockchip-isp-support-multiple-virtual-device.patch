From cad9d8d4a4fc9b872e4b084252214ab287dabb1f Mon Sep 17 00:00:00 2001
From: Cai YiWei <cyw@rock-chips.com>
Date: Fri, 31 Jul 2020 16:53:18 +0800
Subject: [PATCH] media: rockchip: isp: support multiple virtual device

Change-Id: Ib17b6a657b7f91a17ba1df4d87875cdd158df867
Signed-off-by: Cai YiWei <cyw@rock-chips.com>
---
 drivers/media/platform/rockchip/isp/Makefile  |   2 +
 drivers/media/platform/rockchip/isp/bridge.c  | 432 ++++++-----
 drivers/media/platform/rockchip/isp/bridge.h  |  11 +-
 drivers/media/platform/rockchip/isp/capture.c | 105 +--
 drivers/media/platform/rockchip/isp/common.c  | 156 ++++
 drivers/media/platform/rockchip/isp/common.h  |  77 +-
 drivers/media/platform/rockchip/isp/csi.c     | 301 +++++---
 drivers/media/platform/rockchip/isp/csi.h     |   9 +-
 drivers/media/platform/rockchip/isp/dev.c     | 576 ++------------
 drivers/media/platform/rockchip/isp/dev.h     |  31 +-
 drivers/media/platform/rockchip/isp/dmarx.c   |  46 +-
 drivers/media/platform/rockchip/isp/hw.c      | 729 ++++++++++++++++++
 drivers/media/platform/rockchip/isp/hw.h      |  48 ++
 .../media/platform/rockchip/isp/isp_ispp.h    |  25 +-
 .../platform/rockchip/isp/isp_params_v2x.c    |  19 +-
 .../platform/rockchip/isp/isp_stats_v2x.c     |   4 +-
 drivers/media/platform/rockchip/isp/regs.h    |   5 +-
 .../media/platform/rockchip/isp/regs_v2x.h    |  11 +-
 drivers/media/platform/rockchip/isp/rkisp.c   | 193 ++---
 19 files changed, 1605 insertions(+), 1175 deletions(-)
 create mode 100644 drivers/media/platform/rockchip/isp/common.c
 create mode 100644 drivers/media/platform/rockchip/isp/hw.c
 create mode 100644 drivers/media/platform/rockchip/isp/hw.h

diff --git a/drivers/media/platform/rockchip/isp/Makefile b/drivers/media/platform/rockchip/isp/Makefile
index 2bff454b3848..c92e79ffcf47 100644
--- a/drivers/media/platform/rockchip/isp/Makefile
+++ b/drivers/media/platform/rockchip/isp/Makefile
@@ -2,8 +2,10 @@
 obj-$(CONFIG_VIDEO_ROCKCHIP_ISP) += video_rkisp.o
 
 video_rkisp-objs += rkisp.o \
+			hw.o \
 			dev.o \
 			regs.o \
+			common.o \
 			isp_stats.o \
 			isp_stats_v1x.o \
 			isp_stats_v2x.o \
diff --git a/drivers/media/platform/rockchip/isp/bridge.c b/drivers/media/platform/rockchip/isp/bridge.c
index 3f52820e3803..3774ea497fcd 100644
--- a/drivers/media/platform/rockchip/isp/bridge.c
+++ b/drivers/media/platform/rockchip/isp/bridge.c
@@ -22,58 +22,69 @@ struct rkisp_bridge_buf *to_bridge_buf(struct rkisp_ispp_buf *dbufs)
 
 static void update_mi(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct rkisp_bridge_buf *buf;
 	u32 val;
 
-	if (dev->nxt_buf) {
-		buf = to_bridge_buf(dev->nxt_buf);
+	if (hw->nxt_buf) {
+		buf = to_bridge_buf(hw->nxt_buf);
 		val = buf->dummy[GROUP_BUF_PIC].dma_addr;
-		writel(val, base + dev->cfg->reg.y0_base);
+		rkisp_write(dev->ispdev,
+			    dev->cfg->reg.y0_base, val, true);
 		val += dev->cfg->offset;
-		writel(val, base + dev->cfg->reg.uv0_base);
+		rkisp_write(dev->ispdev,
+			    dev->cfg->reg.uv0_base, val, true);
 		val = buf->dummy[GROUP_BUF_GAIN].dma_addr;
-		writel(val, base + dev->cfg->reg.g0_base);
+		rkisp_write(dev->ispdev,
+			    dev->cfg->reg.g0_base, val, true);
 	}
 
 	v4l2_dbg(3, rkisp_debug, &dev->sd,
 		 "%s pic(shd:0x%x base:0x%x) gain(shd:0x%x base:0x%x)\n",
 		 __func__,
-		 readl(base + dev->cfg->reg.y0_base_shd),
-		 readl(base + dev->cfg->reg.y0_base),
-		 readl(base + dev->cfg->reg.g0_base_shd),
-		 readl(base + dev->cfg->reg.g0_base));
+		 rkisp_read(dev->ispdev, dev->cfg->reg.y0_base_shd, true),
+		 rkisp_read(dev->ispdev, dev->cfg->reg.y0_base, true),
+		 rkisp_read(dev->ispdev, dev->cfg->reg.g0_base_shd, true),
+		 rkisp_read(dev->ispdev, dev->cfg->reg.g0_base, true));
 }
 
-static int frame_end(struct rkisp_bridge_device *dev)
+static int frame_end(struct rkisp_bridge_device *dev, bool en)
 {
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct v4l2_subdev *sd = v4l2_get_subdev_hostdata(&dev->sd);
 	unsigned long lock_flags = 0;
 	u64 ns = 0;
 
-	if (dev->cur_buf && dev->nxt_buf) {
-		rkisp_dmarx_get_frame(dev->ispdev,
-				      &dev->cur_buf->frame_id, &ns, false);
-		dev->cur_buf->frame_id++;
-		if (!ns)
-			ns = ktime_get_ns();
-		dev->cur_buf->frame_timestamp = ns;
-		v4l2_subdev_call(sd, video, s_rx_buffer, dev->cur_buf, NULL);
-		dev->cur_buf = NULL;
+	if (hw->cur_buf && hw->nxt_buf) {
+		if (!en) {
+			spin_lock_irqsave(&hw->buf_lock, lock_flags);
+			list_add_tail(&hw->cur_buf->list, &hw->list);
+			spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
+		} else {
+			rkisp_dmarx_get_frame(dev->ispdev,
+				&hw->cur_buf->frame_id, &ns, true);
+			hw->cur_buf->frame_id++;
+			if (!ns)
+				ns = ktime_get_ns();
+			hw->cur_buf->frame_timestamp = ns;
+			hw->cur_buf->index = dev->ispdev->dev_id;
+			v4l2_subdev_call(sd, video, s_rx_buffer, hw->cur_buf, NULL);
+		}
+		hw->cur_buf = NULL;
 	}
 
-	if (dev->nxt_buf) {
-		dev->cur_buf = dev->nxt_buf;
-		dev->nxt_buf = NULL;
+	if (hw->nxt_buf) {
+		hw->cur_buf = hw->nxt_buf;
+		hw->nxt_buf = NULL;
 	}
 
-	spin_lock_irqsave(&dev->buf_lock, lock_flags);
-	if (!list_empty(&dev->list)) {
-		dev->nxt_buf = list_first_entry(&dev->list,
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (!list_empty(&hw->list)) {
+		hw->nxt_buf = list_first_entry(&hw->list,
 				struct rkisp_ispp_buf, list);
-		list_del(&dev->nxt_buf->list);
+		list_del(&hw->nxt_buf->list);
 	}
-	spin_unlock_irqrestore(&dev->buf_lock, lock_flags);
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
 
 	update_mi(dev);
 
@@ -82,90 +93,61 @@ static int frame_end(struct rkisp_bridge_device *dev)
 
 static int config_gain(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
-	struct rkisp_bridge_buf *buf;
+	u32 w = dev->crop.width;
+	u32 h = dev->crop.height;
 	u32 val;
 
-	dev->cur_buf = list_first_entry(&dev->list,
-			struct rkisp_ispp_buf, list);
-	list_del(&dev->cur_buf->list);
-	if (!list_empty(&dev->list)) {
-		dev->nxt_buf = list_first_entry(&dev->list,
-				struct rkisp_ispp_buf, list);
-		list_del(&dev->nxt_buf->list);
-	}
-
-	if (dev->nxt_buf && (dev->work_mode & ISP_ISPP_QUICK)) {
-		buf = to_bridge_buf(dev->nxt_buf);
-		val = buf->dummy[GROUP_BUF_GAIN].dma_addr;
-		writel(val, base + dev->cfg->reg.g1_base);
-		mi_wr_ctrl2(base, SW_GAIN_WR_PINGPONG);
-	}
-
-	buf = to_bridge_buf(dev->cur_buf);
-	val = buf->dummy[GROUP_BUF_GAIN].dma_addr;
-	writel(val, base + dev->cfg->reg.g0_base);
-
-	val = dev->cur_buf->dbuf[GROUP_BUF_GAIN]->size;
-	writel(val, base + MI_GAIN_WR_SIZE);
-	val = ALIGN((dev->crop.width + 3) >> 2, 16);
-	writel(val, base + MI_GAIN_WR_LENGTH);
-	mi_wr_ctrl2(base, SW_GAIN_WR_AUTOUPD);
-
+	val = ALIGN(w, 64) * ALIGN(h, 128) >> 4;
+	rkisp_write(dev->ispdev, MI_GAIN_WR_SIZE, val, false);
+	val = ALIGN((w + 3) >> 2, 16);
+	rkisp_write(dev->ispdev, MI_GAIN_WR_LENGTH, val, false);
+	rkisp_set_bits(dev->ispdev, MI_WR_CTRL2,
+		       0, SW_GAIN_WR_AUTOUPD, true);
 	return 0;
 }
 
 static int config_mpfbc(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
-	struct rkisp_bridge_buf *buf;
-	u32 h = ALIGN(dev->crop.height, 16);
-	u32 val, ctrl = 0;
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
+	u32 h = hw->max_in.h ? hw->max_in.h : dev->crop.height;
+	u32 ctrl = 0;
 
 	if (dev->work_mode & ISP_ISPP_QUICK) {
-		isp_set_bits(base + CTRL_SWS_CFG,
-			     0, SW_ISP2PP_PIPE_EN);
+		rkisp_set_bits(dev->ispdev, CTRL_SWS_CFG,
+			       0, SW_ISP2PP_PIPE_EN, true);
 		ctrl = SW_MPFBC_MAINISP_MODE;
-		if (dev->nxt_buf) {
+		if (dev->ispdev->hw_dev->nxt_buf)
 			ctrl |= SW_MPFBC_PINGPONG_EN;
-			buf = to_bridge_buf(dev->nxt_buf);
-			val = buf->dummy[GROUP_BUF_PIC].dma_addr;
-			writel(val, base + dev->cfg->reg.y1_base);
-			val += dev->cfg->offset;
-			writel(val, base + dev->cfg->reg.uv1_base);
-		}
 	}
 
-	buf = to_bridge_buf(dev->cur_buf);
-	val = buf->dummy[GROUP_BUF_PIC].dma_addr;
-	writel(val, base + dev->cfg->reg.y0_base);
-	val += dev->cfg->offset;
-	writel(val, base + dev->cfg->reg.uv0_base);
-
-	writel(0, base + ISP_MPFBC_VIR_WIDTH);
-	writel(h, base + ISP_MPFBC_VIR_HEIGHT);
-
-	mp_set_data_path(base);
-	isp_set_bits(base + MI_WR_CTRL, 0,
-		     CIF_MI_CTRL_INIT_BASE_EN |
-		     CIF_MI_CTRL_INIT_OFFSET_EN);
-	isp_set_bits(base + MI_IMSC, 0,
-		     dev->cfg->frame_end_id);
+	rkisp_write(dev->ispdev, ISP_MPFBC_VIR_WIDTH, 0, true);
+	rkisp_write(dev->ispdev, ISP_MPFBC_VIR_HEIGHT, ALIGN(h, 16), true);
 
 	ctrl |= (dev->work_mode & ISP_ISPP_422) | SW_MPFBC_EN;
-	writel(ctrl, base + ISP_MPFBC_BASE);
+	rkisp_write(dev->ispdev, ISP_MPFBC_BASE, ctrl, true);
 	return 0;
 }
 
-static void disable_mpfbc(void __iomem *base)
+static void disable_mpfbc(struct rkisp_bridge_device *dev)
 {
-	isp_clear_bits(base + ISP_MPFBC_BASE, SW_MPFBC_EN);
+	if (dev->ispdev->hw_dev->is_single)
+		rkisp_clear_bits(dev->ispdev, ISP_MPFBC_BASE,
+				 SW_MPFBC_EN, true);
+}
+
+static bool is_stopped_mpfbc(struct rkisp_bridge_device *dev)
+{
+	bool en = true;
+
+	if (dev->ispdev->hw_dev->is_single)
+		en = is_mpfbc_stopped(dev->ispdev->base_addr);
+	return en;
 }
 
 static struct rkisp_bridge_ops mpfbc_ops = {
 	.config = config_mpfbc,
 	.disable = disable_mpfbc,
-	.is_stopped = is_mpfbc_stopped,
+	.is_stopped = is_stopped_mpfbc,
 };
 
 static struct rkisp_bridge_config mpfbc_cfg = {
@@ -186,59 +168,56 @@ static struct rkisp_bridge_config mpfbc_cfg = {
 
 static int config_mp(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
-	struct rkisp_bridge_buf *buf;
+	u32 w = dev->crop.width;
+	u32 h = dev->crop.height;
 	u32 val;
 
 	if (dev->work_mode & ISP_ISPP_QUICK) {
-		isp_set_bits(base + CTRL_SWS_CFG, 0,
-			     SW_ISP2PP_PIPE_EN);
-		if (dev->nxt_buf) {
-			buf = to_bridge_buf(dev->nxt_buf);
-			val = buf->dummy[GROUP_BUF_PIC].dma_addr;
-			writel(val, base + dev->cfg->reg.y1_base);
-			val += dev->cfg->offset;
-			writel(val, base + dev->cfg->reg.uv1_base);
-			isp_set_bits(base + CIF_MI_CTRL, 0,
-				     CIF_MI_MP_PINGPONG_ENABLE);
-		}
+		rkisp_set_bits(dev->ispdev, CTRL_SWS_CFG, 0,
+			       SW_ISP2PP_PIPE_EN, true);
+		if (dev->ispdev->hw_dev->nxt_buf)
+			rkisp_set_bits(dev->ispdev, CIF_MI_CTRL, 0,
+				       CIF_MI_MP_PINGPONG_ENABLE, true);
 	}
 
-	buf = to_bridge_buf(dev->cur_buf);
-	val = buf->dummy[GROUP_BUF_PIC].dma_addr;
-	writel(val, base + dev->cfg->reg.y0_base);
-	val += dev->cfg->offset;
-	writel(val, base + dev->cfg->reg.uv0_base);
-	writel(dev->cfg->offset, base + CIF_MI_MP_Y_SIZE_INIT);
-	val = dev->cur_buf->dbuf[GROUP_BUF_PIC]->size - dev->cfg->offset;
-	writel(val, base + CIF_MI_MP_CB_SIZE_INIT);
-	writel(0, base + CIF_MI_MP_CR_SIZE_INIT);
-	writel(0, base + CIF_MI_MP_Y_OFFS_CNT_INIT);
-	writel(0, base + CIF_MI_MP_CB_OFFS_CNT_INIT);
-	writel(0, base + CIF_MI_MP_CR_OFFS_CNT_INIT);
-
-	mp_set_data_path(base);
-	mp_mi_ctrl_set_format(base, MI_CTRL_MP_WRITE_YUV_SPLA);
-	writel(dev->work_mode & ISP_ISPP_422, base + ISP_MPFBC_BASE);
-	isp_set_bits(base + MI_WR_CTRL, 0,
-		     CIF_MI_CTRL_INIT_BASE_EN |
-		     CIF_MI_CTRL_INIT_OFFSET_EN);
-	isp_set_bits(base + MI_IMSC, 0,
-		     dev->cfg->frame_end_id);
-	mi_ctrl_mpyuv_enable(base);
-	mp_mi_ctrl_autoupdate_en(base);
+	val = w * h;
+	rkisp_write(dev->ispdev, CIF_MI_MP_Y_SIZE_INIT, val, false);
+	val = (dev->work_mode & ISP_ISPP_422) ? val : val / 2;
+	rkisp_write(dev->ispdev, CIF_MI_MP_CB_SIZE_INIT, val, false);
+	rkisp_write(dev->ispdev, CIF_MI_MP_CR_SIZE_INIT, 0, false);
+	rkisp_write(dev->ispdev, CIF_MI_MP_Y_OFFS_CNT_INIT, 0, false);
+	rkisp_write(dev->ispdev, CIF_MI_MP_CB_OFFS_CNT_INIT, 0, false);
+	rkisp_write(dev->ispdev, CIF_MI_MP_CR_OFFS_CNT_INIT, 0, false);
+
+	rkisp_write(dev->ispdev, ISP_MPFBC_BASE,
+		    dev->work_mode & ISP_ISPP_422, true);
+	rkisp_set_bits(dev->ispdev, CIF_MI_CTRL, MI_CTRL_MP_FMT_MASK,
+		       MI_CTRL_MP_WRITE_YUV_SPLA | CIF_MI_CTRL_MP_ENABLE |
+		       CIF_MI_MP_AUTOUPDATE_ENABLE, true);
 	return 0;
 }
 
-static void disable_mp(void __iomem *base)
+static void disable_mp(struct rkisp_bridge_device *dev)
 {
-	mi_ctrl_mp_disable(base);
+	if (dev->ispdev->hw_dev->is_single)
+		rkisp_clear_bits(dev->ispdev, CIF_MI_CTRL,
+				 CIF_MI_CTRL_MP_ENABLE |
+				 CIF_MI_CTRL_RAW_ENABLE, true);
+}
+
+static bool is_stopped_mp(struct rkisp_bridge_device *dev)
+{
+	bool en = true;
+
+	if (dev->ispdev->hw_dev->is_single)
+		en = mp_is_stream_stopped(dev->ispdev->base_addr);
+	return en;
 }
 
 static struct rkisp_bridge_ops mp_ops = {
 	.config = config_mp,
 	.disable = disable_mp,
-	.is_stopped = mp_is_stream_stopped,
+	.is_stopped = is_stopped_mp,
 };
 
 static struct rkisp_bridge_config mp_cfg = {
@@ -259,76 +238,110 @@ static struct rkisp_bridge_config mp_cfg = {
 
 static void free_bridge_buf(struct rkisp_bridge_device *dev)
 {
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct rkisp_bridge_buf *buf;
 	struct rkisp_ispp_buf *dbufs;
+	unsigned long lock_flags = 0;
 	int i, j;
 
-	if (dev->cur_buf) {
-		list_add_tail(&dev->cur_buf->list, &dev->list);
-		if (dev->cur_buf == dev->nxt_buf)
-			dev->nxt_buf = NULL;
-		dev->cur_buf = NULL;
+	if (atomic_dec_return(&hw->refcnt))
+		return;
+
+	v4l2_dbg(1, rkisp_debug, &dev->ispdev->v4l2_dev,
+		 "%s\n", __func__);
+
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	if (hw->cur_buf) {
+		list_add_tail(&hw->cur_buf->list, &hw->list);
+		if (hw->cur_buf == hw->nxt_buf)
+			hw->nxt_buf = NULL;
+		hw->cur_buf = NULL;
 	}
 
-	if (dev->nxt_buf) {
-		list_add_tail(&dev->nxt_buf->list, &dev->list);
-		dev->nxt_buf = NULL;
+	if (hw->nxt_buf) {
+		list_add_tail(&hw->nxt_buf->list, &hw->list);
+		hw->nxt_buf = NULL;
 	}
 
-	while (!list_empty(&dev->list)) {
-		dbufs = list_first_entry(&dev->list,
+	while (!list_empty(&hw->list)) {
+		dbufs = list_first_entry(&hw->list,
 				struct rkisp_ispp_buf, list);
 		list_del(&dbufs->list);
 	}
-
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
 	for (i = 0; i < BRIDGE_BUF_MAX; i++) {
-		buf = &dev->bufs[i];
+		buf = &hw->bufs[i];
 		for (j = 0; j < GROUP_BUF_MAX; j++)
-			rkisp_free_buffer(dev->ispdev->dev, &buf->dummy[j]);
+			rkisp_free_buffer(dev->ispdev, &buf->dummy[j]);
 	}
 }
 
-static int init_buf(struct rkisp_bridge_device *dev)
+static int init_buf(struct rkisp_bridge_device *dev, u32 pic_size, u32 gain_size)
 {
 	struct v4l2_subdev *sd = v4l2_get_subdev_hostdata(&dev->sd);
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct rkisp_bridge_buf *buf;
 	struct rkisp_dummy_buffer *dummy;
-	u32 width = dev->crop.width;
-	u32 height = dev->crop.height;
-	u32 offset = width * height;
-	u32 pic_size = 0, gain_size;
-	int i, j, ret = 0;
+	int i, j, val, ret = 0;
 
-	gain_size = ALIGN(width, 64) * ALIGN(height, 128) >> 4;
-	if (dev->work_mode & ISP_ISPP_FBC) {
-		width = ALIGN(width, 16);
-		height = ALIGN(height, 16);
-		offset = width * height >> 4;
-		pic_size = offset;
-	}
-	if (dev->work_mode & ISP_ISPP_422)
-		pic_size += width * height * 2;
-	else
-		pic_size += width * height * 3 >> 1;
-	dev->cfg->offset = offset;
+	if (atomic_inc_return(&hw->refcnt) > 1)
+		return 0;
 
+	v4l2_dbg(1, rkisp_debug, &dev->ispdev->v4l2_dev,
+		 "%s pic size:%d gain size:%d\n",
+		 __func__, pic_size, gain_size);
 	for (i = 0; i < dev->buf_num; i++) {
-		buf = &dev->bufs[i];
+		buf = &hw->bufs[i];
 		for (j = 0; j < GROUP_BUF_MAX; j++) {
 			dummy = &buf->dummy[j];
 			dummy->is_need_dbuf = true;
 			dummy->size = !j ? pic_size : gain_size;
-			ret = rkisp_alloc_buffer(dev->ispdev->dev, dummy);
+			ret = rkisp_alloc_buffer(dev->ispdev, dummy);
 			if (ret)
 				goto err;
 			buf->dbufs.dbuf[j] = dummy->dbuf;
 		}
-		list_add_tail(&buf->dbufs.list, &dev->list);
+		list_add_tail(&buf->dbufs.list, &hw->list);
 		ret = v4l2_subdev_call(sd, video, s_rx_buffer, &buf->dbufs, NULL);
 		if (ret)
 			goto err;
 	}
 
+	hw->cur_buf = list_first_entry(&hw->list, struct rkisp_ispp_buf, list);
+	list_del(&hw->cur_buf->list);
+	buf = to_bridge_buf(hw->cur_buf);
+	val = buf->dummy[GROUP_BUF_PIC].dma_addr;
+	rkisp_write(dev->ispdev, dev->cfg->reg.y0_base, val, true);
+	val += dev->cfg->offset;
+	rkisp_write(dev->ispdev, dev->cfg->reg.uv0_base, val, true);
+	val = buf->dummy[GROUP_BUF_GAIN].dma_addr;
+	rkisp_write(dev->ispdev, dev->cfg->reg.g0_base, val, true);
+
+	if (!list_empty(&hw->list)) {
+		hw->nxt_buf = list_first_entry(&hw->list,
+				struct rkisp_ispp_buf, list);
+		list_del(&hw->nxt_buf->list);
+	}
+	if (hw->nxt_buf && (dev->work_mode & ISP_ISPP_QUICK)) {
+		buf = to_bridge_buf(hw->nxt_buf);
+		val = buf->dummy[GROUP_BUF_PIC].dma_addr;
+		rkisp_write(dev->ispdev, dev->cfg->reg.y1_base, val, true);
+		val += dev->cfg->offset;
+		rkisp_write(dev->ispdev, dev->cfg->reg.uv1_base, val, true);
+		val = buf->dummy[GROUP_BUF_GAIN].dma_addr;
+		rkisp_write(dev->ispdev, dev->cfg->reg.g1_base, val, true);
+		rkisp_set_bits(dev->ispdev, MI_WR_CTRL2,
+			       0, SW_GAIN_WR_PINGPONG, true);
+	}
+
+	rkisp_set_bits(dev->ispdev, CIF_VI_DPCL, 0,
+		       CIF_VI_DPCL_CHAN_MODE_MP |
+		       CIF_VI_DPCL_MP_MUX_MRSZ_MI, true);
+	rkisp_set_bits(dev->ispdev, MI_WR_CTRL, 0,
+		       CIF_MI_CTRL_INIT_BASE_EN |
+		       CIF_MI_CTRL_INIT_OFFSET_EN, true);
+	rkisp_set_bits(dev->ispdev, MI_IMSC, 0,
+		       dev->cfg->frame_end_id, true);
 	return 0;
 err:
 	free_bridge_buf(dev);
@@ -338,6 +351,12 @@ static int init_buf(struct rkisp_bridge_device *dev)
 
 static int config_mode(struct rkisp_bridge_device *dev)
 {
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
+	u32 w = hw->max_in.w ? hw->max_in.w : dev->crop.width;
+	u32 h = hw->max_in.h ? hw->max_in.h : dev->crop.height;
+	u32 offs = w * h;
+	u32 pic_size = 0, gain_size;
+
 	if (dev->work_mode == ISP_ISPP_INIT_FAIL) {
 		free_bridge_buf(dev);
 		return 0;
@@ -363,13 +382,24 @@ static int config_mode(struct rkisp_bridge_device *dev)
 		dev->cfg = &mp_cfg;
 	}
 
-	return init_buf(dev);
+	gain_size = ALIGN(w, 64) * ALIGN(h, 128) >> 4;
+	if (dev->work_mode & ISP_ISPP_FBC) {
+		w = ALIGN(w, 16);
+		h = ALIGN(h, 16);
+		offs = w * h >> 4;
+		pic_size = offs;
+	}
+	if (dev->work_mode & ISP_ISPP_422)
+		pic_size += w * h * 2;
+	else
+		pic_size += w * h * 3 >> 1;
+	dev->cfg->offset = offs;
+	return init_buf(dev, pic_size, gain_size);
 }
 
 static void crop_on(struct rkisp_bridge_device *dev)
 {
 	struct rkisp_device *ispdev = dev->ispdev;
-	void __iomem *base = ispdev->base_addr;
 	u32 src_w = ispdev->isp_sdev.out_crop.width;
 	u32 src_h = ispdev->isp_sdev.out_crop.height;
 	u32 dest_w = dev->crop.width;
@@ -381,19 +411,18 @@ static void crop_on(struct rkisp_bridge_device *dev)
 	if (src_w == dest_w && src_h == dest_h)
 		return;
 
-	writel(left, base + CIF_DUAL_CROP_M_H_OFFS);
-	writel(top, base + CIF_DUAL_CROP_M_V_OFFS);
-	writel(dest_w, base + CIF_DUAL_CROP_M_H_SIZE);
-	writel(dest_h, base + CIF_DUAL_CROP_M_V_SIZE);
-	ctrl = readl(base + CIF_DUAL_CROP_CTRL);
+	rkisp_write(ispdev, CIF_DUAL_CROP_M_H_OFFS, left, true);
+	rkisp_write(ispdev, CIF_DUAL_CROP_M_V_OFFS, top, true);
+	rkisp_write(ispdev, CIF_DUAL_CROP_M_H_SIZE, dest_w, true);
+	rkisp_write(ispdev, CIF_DUAL_CROP_M_V_SIZE, dest_h, true);
+	ctrl = rkisp_read(ispdev, CIF_DUAL_CROP_CTRL, true);
 	ctrl |= CIF_DUAL_CROP_MP_MODE_YUV | CIF_DUAL_CROP_CFG_UPD;
-	writel(ctrl, base + CIF_DUAL_CROP_CTRL);
+	rkisp_write(ispdev, CIF_DUAL_CROP_CTRL, ctrl, true);
 }
 
 static void crop_off(struct rkisp_bridge_device *dev)
 {
 	struct rkisp_device *ispdev = dev->ispdev;
-	void __iomem *base = ispdev->base_addr;
 	u32 src_w = ispdev->isp_sdev.out_crop.width;
 	u32 src_h = ispdev->isp_sdev.out_crop.height;
 	u32 dest_w = dev->crop.width;
@@ -403,37 +432,35 @@ static void crop_off(struct rkisp_bridge_device *dev)
 	if (src_w == dest_w && src_h == dest_h)
 		return;
 
-	ctrl = readl(base + CIF_DUAL_CROP_CTRL);
+	ctrl = rkisp_read(ispdev, CIF_DUAL_CROP_CTRL, true);
 	ctrl &= ~(CIF_DUAL_CROP_MP_MODE_YUV |
 		  CIF_DUAL_CROP_MP_MODE_RAW);
 	ctrl |= CIF_DUAL_CROP_GEN_CFG_UPD;
-	writel(ctrl, base + CIF_DUAL_CROP_CTRL);
+	rkisp_write(ispdev, CIF_DUAL_CROP_CTRL, ctrl, true);
 }
 
 static int bridge_start(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
-
 	crop_on(dev);
 	config_gain(dev);
 	dev->ops->config(dev);
 
-	force_cfg_update(base);
-
-	if (!(dev->work_mode & ISP_ISPP_QUICK))
-		update_mi(dev);
+	if (!dev->ispdev->hw_dev->is_mi_update) {
+		force_cfg_update(dev->ispdev);
 
+		if (!(dev->work_mode & ISP_ISPP_QUICK))
+			update_mi(dev);
+	}
 	dev->en = true;
 	return 0;
 }
 
 static int bridge_stop(struct rkisp_bridge_device *dev)
 {
-	void __iomem *base = dev->ispdev->base_addr;
 	int ret;
 
 	dev->stopping = true;
-	dev->ops->disable(base);
+	dev->ops->disable(dev);
 	hdr_stop_dmatx(dev->ispdev);
 	ret = wait_event_timeout(dev->done, !dev->en,
 				 msecs_to_jiffies(1000));
@@ -441,13 +468,15 @@ static int bridge_stop(struct rkisp_bridge_device *dev)
 		v4l2_warn(&dev->sd,
 			  "%s timeout ret:%d\n", __func__, ret);
 	crop_off(dev);
-	isp_clear_bits(base + MI_IMSC, dev->cfg->frame_end_id);
 	dev->stopping = false;
 	dev->en = false;
 
 	/* make sure ispp last frame done */
-	if (dev->work_mode & ISP_ISPP_QUICK)
+	if (dev->work_mode & ISP_ISPP_QUICK) {
+		rkisp_clear_bits(dev->ispdev, MI_IMSC,
+				 dev->cfg->frame_end_id, true);
 		usleep_range(20000, 25000);
+	}
 	return 0;
 }
 
@@ -460,7 +489,8 @@ static int bridge_start_stream(struct v4l2_subdev *sd)
 		return -EBUSY;
 
 	if (dev->ispdev->isp_inp & INP_CSI ||
-	    dev->ispdev->isp_inp & INP_DVP) {
+	    dev->ispdev->isp_inp & INP_DVP ||
+	    dev->ispdev->isp_inp & INP_LVDS) {
 		/* Always update sensor info in case media topology changed */
 		ret = rkisp_update_sensor_info(dev->ispdev);
 		if (ret < 0) {
@@ -594,16 +624,17 @@ static int bridge_s_rx_buffer(struct v4l2_subdev *sd,
 			      void *buf, unsigned int *size)
 {
 	struct rkisp_bridge_device *dev = v4l2_get_subdevdata(sd);
+	struct rkisp_hw_dev *hw = dev->ispdev->hw_dev;
 	struct rkisp_ispp_buf *dbufs = buf;
 	unsigned long lock_flags = 0;
 
 	/* size isn't using now */
-	if (!dbufs)
+	if (!dbufs || !atomic_read(&hw->refcnt))
 		return -EINVAL;
 
-	spin_lock_irqsave(&dev->buf_lock, lock_flags);
-	list_add_tail(&dbufs->list, &dev->list);
-	spin_unlock_irqrestore(&dev->buf_lock, lock_flags);
+	spin_lock_irqsave(&hw->buf_lock, lock_flags);
+	list_add_tail(&dbufs->list, &hw->list);
+	spin_unlock_irqrestore(&hw->buf_lock, lock_flags);
 	return 0;
 }
 
@@ -618,12 +649,12 @@ static int bridge_s_stream(struct v4l2_subdev *sd, int on)
 	if (on) {
 		atomic_inc(&dev->ispdev->cap_dev.refcnt);
 		ret = bridge_start_stream(sd);
-	} else if (dev->en) {
-		ret = bridge_stop_stream(sd);
+	} else {
+		if (dev->en)
+			ret = bridge_stop_stream(sd);
+		atomic_dec(&dev->ispdev->cap_dev.refcnt);
 	}
 
-	if (!on)
-		atomic_dec(&dev->ispdev->cap_dev.refcnt);
 	return ret;
 }
 
@@ -651,6 +682,7 @@ static long bridge_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	switch (cmd) {
 	case RKISP_ISPP_CMD_SET_MODE:
 		mode = arg;
+		dev->ispdev->hw_dev->max_in = mode->max_in;
 		dev->work_mode = mode->work_mode;
 		dev->buf_num = mode->buf_num;
 		ret = config_mode(dev);
@@ -707,11 +739,9 @@ void rkisp_bridge_isr(u32 *mis_val, struct rkisp_device *dev)
 			/* FALLTHROUGH */
 		}
 		rkisp2_rawrd_isr(val, dev);
-		if (dev->dmarx_dev.trigger == T_MANUAL)
-			rkisp_csi_trigger_event(&dev->csi_dev, NULL);
 	}
 
-	if (!bridge->en || !bridge->cfg ||
+	if (!bridge->cfg ||
 	    (bridge->cfg &&
 	     !(*mis_val & bridge->cfg->frame_end_id)))
 		return;
@@ -720,14 +750,20 @@ void rkisp_bridge_isr(u32 *mis_val, struct rkisp_device *dev)
 	writel(bridge->cfg->frame_end_id, base + CIF_MI_ICR);
 
 	if (bridge->stopping) {
-		if (bridge->ops->is_stopped(base)) {
+		if (bridge->ops->is_stopped(bridge)) {
 			bridge->en = false;
 			bridge->stopping = false;
 			wake_up(&bridge->done);
 		}
-	} else if (!(bridge->work_mode & ISP_ISPP_QUICK)) {
-		frame_end(bridge);
 	}
+
+	if (!(bridge->work_mode & ISP_ISPP_QUICK)) {
+		frame_end(bridge, bridge->en);
+		if (!bridge->en)
+			dev->isp_state = ISP_STOP;
+	}
+	if (dev->dmarx_dev.trigger == T_MANUAL)
+		rkisp_csi_trigger_event(dev, T_CMD_END, NULL);
 }
 
 int rkisp_register_bridge_subdev(struct rkisp_device *dev,
@@ -768,8 +804,6 @@ int rkisp_register_bridge_subdev(struct rkisp_device *dev,
 	ret = media_create_pad_link(source, RKISP_ISP_PAD_SOURCE_PATH,
 				    sink, 0, bridge->linked);
 	init_waitqueue_head(&bridge->done);
-	spin_lock_init(&bridge->buf_lock);
-	INIT_LIST_HEAD(&bridge->list);
 	return ret;
 
 free_media:
diff --git a/drivers/media/platform/rockchip/isp/bridge.h b/drivers/media/platform/rockchip/isp/bridge.h
index a5e1681da05e..0835527e8d67 100644
--- a/drivers/media/platform/rockchip/isp/bridge.h
+++ b/drivers/media/platform/rockchip/isp/bridge.h
@@ -8,14 +8,14 @@
 #include "isp_ispp.h"
 
 #define BRIDGE_DEV_NAME DRIVER_NAME "-bridge-ispp"
-#define BRIDGE_BUF_MAX	(RKISP_ISPP_BUF_MAX + 1)
+#define BRIDGE_BUF_MAX	RKISP_ISPP_BUF_MAX
 
 struct rkisp_bridge_device;
 
 struct rkisp_bridge_ops {
 	int (*config)(struct rkisp_bridge_device *dev);
-	void (*disable)(void __iomem *base);
-	bool (*is_stopped)(void __iomem *base);
+	void (*disable)(struct rkisp_bridge_device *dev);
+	bool (*is_stopped)(struct rkisp_bridge_device *dev);
 };
 
 struct rkisp_bridge_config {
@@ -46,11 +46,6 @@ struct rkisp_bridge_device {
 	struct v4l2_rect crop;
 	struct media_pad pad;
 	wait_queue_head_t done;
-	spinlock_t buf_lock;
-	struct list_head list;
-	struct rkisp_bridge_buf bufs[BRIDGE_BUF_MAX];
-	struct rkisp_ispp_buf *cur_buf;
-	struct rkisp_ispp_buf *nxt_buf;
 	struct rkisp_bridge_ops *ops;
 	struct rkisp_bridge_config *cfg;
 	u8 work_mode;
diff --git a/drivers/media/platform/rockchip/isp/capture.c b/drivers/media/platform/rockchip/isp/capture.c
index 266faf640304..fa73239863cf 100644
--- a/drivers/media/platform/rockchip/isp/capture.c
+++ b/drivers/media/platform/rockchip/isp/capture.c
@@ -713,6 +713,24 @@ static struct stream_config rkisp2_dmatx3_stream_config = {
 	},
 };
 
+static bool is_rdbk_stream(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	bool en = false;
+
+	if ((dev->hdr.op_mode == HDR_RDBK_FRAME1 &&
+	     stream->id == RKISP_STREAM_DMATX2) ||
+	    (dev->hdr.op_mode == HDR_RDBK_FRAME2 &&
+	     (stream->id == RKISP_STREAM_DMATX2 ||
+	      stream->id == RKISP_STREAM_DMATX0)) ||
+	    (dev->hdr.op_mode == HDR_RDBK_FRAME3 &&
+	     (stream->id == RKISP_STREAM_DMATX2 ||
+	      stream->id == RKISP_STREAM_DMATX1 ||
+	      stream->id == RKISP_STREAM_DMATX0)))
+		en = true;
+	return en;
+}
+
 static int hdr_dma_frame(struct rkisp_device *dev)
 {
 	int max_dma;
@@ -736,8 +754,6 @@ static int hdr_dma_frame(struct rkisp_device *dev)
 	default:
 		max_dma = 0;
 	}
-	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
-		 "%s %d\n", __func__, max_dma);
 	return max_dma;
 }
 
@@ -1566,41 +1582,37 @@ static void rdbk_frame_end(struct rkisp_stream *stream)
  */
 static int mi_frame_end(struct rkisp_stream *stream)
 {
-	struct rkisp_device *isp_dev = stream->ispdev;
-	struct rkisp_capture_device *cap = &isp_dev->cap_dev;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_capture_device *cap = &dev->cap_dev;
 	struct capture_fmt *isp_fmt = &stream->out_isp_fmt;
 	bool interlaced = stream->interlaced;
 	unsigned long lock_flags = 0;
 	int i = 0;
 
 	if (!stream->next_buf && stream->streaming &&
-	    IS_HDR_RDBK(isp_dev->hdr.op_mode) &&
-	    isp_dev->dmarx_dev.trigger == T_MANUAL &&
-	    (stream->id == RKISP_STREAM_DMATX0 ||
-	     stream->id == RKISP_STREAM_DMATX1 ||
-	     stream->id == RKISP_STREAM_DMATX2))
-		v4l2_info(&isp_dev->v4l2_dev,
+	    dev->dmarx_dev.trigger == T_MANUAL &&
+	    is_rdbk_stream(stream))
+		v4l2_info(&dev->v4l2_dev,
 			  "tx stream:%d lose frame:%d, isp state:0x%x frame:%d\n",
 			  stream->id, atomic_read(&stream->sequence) - 1,
-			  isp_dev->isp_state, isp_dev->dmarx_dev.cur_frame.id);
+			  dev->isp_state, dev->dmarx_dev.cur_frame.id);
 
 	if (stream->curr_buf &&
-		(!interlaced ||
-		(stream->u.sp.field_rec == RKISP_FIELD_ODD &&
-		stream->u.sp.field == RKISP_FIELD_EVEN))) {
+	    (!interlaced ||
+	     (stream->u.sp.field_rec == RKISP_FIELD_ODD &&
+	      stream->u.sp.field == RKISP_FIELD_EVEN))) {
+		struct vb2_buffer *vb2_buf = &stream->curr_buf->vb.vb2_buf;
 		u64 ns = 0;
 
 		/* Dequeue a filled buffer */
 		for (i = 0; i < isp_fmt->mplanes; i++) {
 			u32 payload_size =
 				stream->out_fmt.plane_fmt[i].sizeimage;
-			vb2_set_plane_payload(
-				&stream->curr_buf->vb.vb2_buf, i,
-				payload_size);
+			vb2_set_plane_payload(vb2_buf, i, payload_size);
 		}
 		if (stream->id == RKISP_STREAM_MP ||
 		    stream->id == RKISP_STREAM_SP)
-			rkisp_dmarx_get_frame(isp_dev,
+			rkisp_dmarx_get_frame(dev,
 					      &stream->curr_buf->vb.sequence,
 					      &ns, false);
 		else
@@ -1608,38 +1620,37 @@ static int mi_frame_end(struct rkisp_stream *stream)
 				atomic_read(&stream->sequence) - 1;
 		if (!ns)
 			ns = ktime_get_ns();
-		stream->curr_buf->vb.vb2_buf.timestamp = ns;
+		vb2_buf->timestamp = ns;
 
-		if (!IS_HDR_RDBK(isp_dev->hdr.op_mode)) {
-			vb2_buffer_done(&stream->curr_buf->vb.vb2_buf,
-					VB2_BUF_STATE_DONE);
-		} else {
+		if (is_rdbk_stream(stream) &&
+		    dev->dmarx_dev.trigger == T_MANUAL) {
 			if (stream->id == RKISP_STREAM_DMATX0) {
 				if (cap->rdbk_buf[RDBK_L]) {
-					v4l2_err(&isp_dev->v4l2_dev,
-						"multiple long data in hdr frame\n");
+					v4l2_err(&dev->v4l2_dev,
+						 "multiple long data in hdr frame\n");
 					rkisp_buf_queue(&cap->rdbk_buf[RDBK_L]->vb.vb2_buf);
 				}
 				cap->rdbk_buf[RDBK_L] = stream->curr_buf;
 			} else if (stream->id == RKISP_STREAM_DMATX1) {
 				if (cap->rdbk_buf[RDBK_M]) {
-					v4l2_err(&isp_dev->v4l2_dev,
-						"multiple middle data in hdr frame\n");
+					v4l2_err(&dev->v4l2_dev,
+						 "multiple middle data in hdr frame\n");
 					rkisp_buf_queue(&cap->rdbk_buf[RDBK_M]->vb.vb2_buf);
 				}
 				cap->rdbk_buf[RDBK_M] = stream->curr_buf;
 			} else if (stream->id == RKISP_STREAM_DMATX2) {
 				if (cap->rdbk_buf[RDBK_S]) {
-					v4l2_err(&isp_dev->v4l2_dev,
-						"multiple short data in hdr frame\n");
+					v4l2_err(&dev->v4l2_dev,
+						 "multiple short data in hdr frame\n");
 					rkisp_buf_queue(&cap->rdbk_buf[RDBK_S]->vb.vb2_buf);
 				}
 				cap->rdbk_buf[RDBK_S] = stream->curr_buf;
 				rdbk_frame_end(stream);
 			} else {
-				vb2_buffer_done(&stream->curr_buf->vb.vb2_buf,
-						VB2_BUF_STATE_DONE);
+				vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
 			}
+		} else {
+			vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
 		}
 
 		stream->curr_buf = NULL;
@@ -1711,7 +1722,7 @@ static int rkisp_create_hdr_buf(struct rkisp_device *dev)
 		for (j = 0; j < max_buf; j++) {
 			buf = &dev->hdr.dummy_buf[i][j];
 			buf->size = size;
-			if (rkisp_alloc_buffer(dev->dev, buf) < 0) {
+			if (rkisp_alloc_buffer(dev, buf) < 0) {
 				v4l2_err(&dev->v4l2_dev,
 					"Failed to allocate the memory for hdr buffer\n");
 				return -ENOMEM;
@@ -1747,7 +1758,8 @@ static int rkisp_create_hdr_buf(struct rkisp_device *dev)
 	}
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
-		 "hdr buf index dma0:%d dma1:%d dma2:%d\n",
+		 "hdr:%d buf index dma0:%d dma1:%d dma2:%d\n",
+		 max_dma,
 		 dev->hdr.index[HDR_DMA0],
 		 dev->hdr.index[HDR_DMA1],
 		 dev->hdr.index[HDR_DMA2]);
@@ -1776,17 +1788,17 @@ void hdr_destroy_buf(struct rkisp_device *dev)
 	for (i = 0; i < max_dma; i++) {
 		buf = dev->hdr.rx_cur_buf[i];
 		if (buf) {
-			rkisp_free_buffer(dev->dev, buf);
+			rkisp_free_buffer(dev, buf);
 			dev->hdr.rx_cur_buf[i] = NULL;
 		}
 
 		for (j = 0; j < max_buf; j++) {
 			buf = hdr_dqbuf(&dev->hdr.q_tx[i]);
 			if (buf)
-				rkisp_free_buffer(dev->dev, buf);
+				rkisp_free_buffer(dev, buf);
 			buf = hdr_dqbuf(&dev->hdr.q_rx[i]);
 			if (buf)
-				rkisp_free_buffer(dev->dev, buf);
+				rkisp_free_buffer(dev, buf);
 		}
 	}
 }
@@ -1937,17 +1949,8 @@ static void rkisp_stream_stop(struct rkisp_stream *stream)
 	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
 	int ret = 0;
 
-	if (dev->isp_ver == ISP_V20 &&
-	    !dev->dmarx_dev.trigger &&
-	    ((dev->hdr.op_mode == HDR_RDBK_FRAME1 &&
-	      stream->id == RKISP_STREAM_DMATX2) ||
-	     (dev->hdr.op_mode == HDR_RDBK_FRAME2 &&
-	      (stream->id == RKISP_STREAM_DMATX2 ||
-	       stream->id == RKISP_STREAM_DMATX0)) ||
-	     (dev->hdr.op_mode == HDR_RDBK_FRAME3 &&
-	      (stream->id == RKISP_STREAM_DMATX2 ||
-	       stream->id == RKISP_STREAM_DMATX1 ||
-	       stream->id == RKISP_STREAM_DMATX0)))) {
+	if (!dev->dmarx_dev.trigger &&
+	    is_rdbk_stream(stream)) {
 		stream->streaming = false;
 		return;
 	}
@@ -2037,7 +2040,7 @@ static int rkisp_start(struct rkisp_stream *stream)
 	 */
 	if (is_update && !dev->br_dev.en) {
 		rkisp_stats_first_ddr_config(&dev->stats_vdev);
-		force_cfg_update(base);
+		force_cfg_update(dev);
 		mi_frame_end(stream);
 		if (dev->isp_ver == ISP_V20)
 			hdr_update_dmatx_buf(dev);
@@ -2175,7 +2178,7 @@ static int rkisp_create_dummy_buf(struct rkisp_stream *stream)
 		dummy_buf->size = max(dummy_buf->size, in_size);
 	}
 
-	if (rkisp_alloc_buffer(dev->dev, dummy_buf) < 0) {
+	if (rkisp_alloc_buffer(dev, dummy_buf) < 0) {
 		v4l2_err(&dev->v4l2_dev,
 			 "Failed to allocate the memory for dummy buffer\n");
 		return -ENOMEM;
@@ -2192,7 +2195,7 @@ static void rkisp_destroy_dummy_buf(struct rkisp_stream *stream)
 	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
 	struct rkisp_device *dev = stream->ispdev;
 
-	rkisp_free_buffer(dev->dev, dummy_buf);
+	rkisp_free_buffer(dev, dummy_buf);
 	if (dev->isp_ver == ISP_V20)
 		hdr_destroy_buf(dev);
 }
@@ -2444,7 +2447,7 @@ static int rkisp_init_vb2_queue(struct vb2_queue *q,
 	q->min_buffers_needed = CIF_ISP_REQ_BUFS_MIN;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 	q->lock = &stream->ispdev->apilock;
-	q->dev = stream->ispdev->dev;
+	q->dev = stream->ispdev->hw_dev->dev;
 
 	return vb2_queue_init(q);
 }
diff --git a/drivers/media/platform/rockchip/isp/common.c b/drivers/media/platform/rockchip/isp/common.c
new file mode 100644
index 000000000000..e3fb05399821
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/common.c
@@ -0,0 +1,156 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2019 Rockchip Electronics Co., Ltd */
+
+#include <media/videobuf2-dma-contig.h>
+#include <linux/of_platform.h>
+#include "dev.h"
+#include "isp_ispp.h"
+#include "regs.h"
+
+static const struct vb2_mem_ops *g_ops = &vb2_dma_contig_memops;
+
+void rkisp_write(struct rkisp_device *dev, u32 reg, u32 val, bool is_direct)
+{
+	u32 *mem = dev->sw_base_addr + reg;
+	u32 *flag = dev->sw_base_addr + reg + ISP_SW_REG_SIZE;
+
+	*mem = val;
+	*flag = SW_REG_CACHE;
+	if (dev->hw_dev->is_single || is_direct) {
+		*flag = SW_REG_CACHE_SYNC;
+		writel(val, dev->hw_dev->base_addr + reg);
+	}
+}
+
+u32 rkisp_read(struct rkisp_device *dev, u32 reg, bool is_direct)
+{
+	u32 val;
+
+	if (dev->hw_dev->is_single || is_direct)
+		val = readl(dev->hw_dev->base_addr + reg);
+	else
+		val = *(u32 *)(dev->sw_base_addr + reg);
+	return val;
+}
+
+void rkisp_set_bits(struct rkisp_device *dev, u32 reg, u32 mask, u32 val, bool is_direct)
+{
+	u32 tmp = rkisp_read(dev, reg, is_direct) & ~mask;
+
+	rkisp_write(dev, reg, val | tmp, is_direct);
+}
+
+void rkisp_clear_bits(struct rkisp_device *dev, u32 reg, u32 mask, bool is_direct)
+{
+	u32 tmp = rkisp_read(dev, reg, is_direct);
+
+	rkisp_write(dev, reg, tmp & ~mask, is_direct);
+}
+
+void rkisp_update_regs(struct rkisp_device *dev, u32 start, u32 end)
+{
+	void __iomem *base = dev->hw_dev->base_addr;
+	u32 i;
+
+	if (end > ISP_SW_REG_SIZE - 4) {
+		dev_err(dev->dev, "%s out of range\n", __func__);
+		return;
+	}
+	for (i = start; i <= end; i += 4) {
+		u32 *val = dev->sw_base_addr + i;
+		u32 *flag = dev->sw_base_addr + i + ISP_SW_REG_SIZE;
+
+		if (*flag == SW_REG_CACHE)
+			writel(*val, base + i);
+	}
+}
+
+int rkisp_alloc_buffer(struct rkisp_device *dev,
+		       struct rkisp_dummy_buffer *buf)
+{
+	unsigned long attrs = buf->is_need_vaddr ? 0 : DMA_ATTR_NO_KERNEL_MAPPING;
+	void *mem_priv;
+	int ret = 0;
+
+	if (!buf->size) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	mem_priv = g_ops->alloc(dev->hw_dev->dev, attrs, buf->size,
+				DMA_BIDIRECTIONAL, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(mem_priv)) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	buf->mem_priv = mem_priv;
+	buf->dma_addr = *((dma_addr_t *)g_ops->cookie(mem_priv));
+	if (!attrs)
+		buf->vaddr = g_ops->vaddr(mem_priv);
+	if (buf->is_need_dbuf)
+		buf->dbuf = g_ops->get_dmabuf(mem_priv, O_RDWR);
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s buf:0x%x~0x%x size:%d\n", __func__,
+		 (u32)buf->dma_addr, (u32)buf->dma_addr + buf->size, buf->size);
+	return ret;
+err:
+	dev_err(dev->dev, "%s failed ret:%d\n", __func__, ret);
+	return ret;
+}
+
+void rkisp_free_buffer(struct rkisp_device *dev,
+		       struct rkisp_dummy_buffer *buf)
+{
+	if (buf && buf->mem_priv) {
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "%s buf:0x%x~0x%x\n", __func__,
+			 (u32)buf->dma_addr, (u32)buf->dma_addr + buf->size);
+		if (buf->dbuf)
+			dma_buf_put(buf->dbuf);
+		g_ops->put(buf->mem_priv);
+		buf->size = 0;
+		buf->dbuf = NULL;
+		buf->vaddr = NULL;
+		buf->mem_priv = NULL;
+		buf->is_need_dbuf = false;
+		buf->is_need_vaddr = false;
+	}
+}
+
+int rkisp_attach_hw(struct rkisp_device *isp)
+{
+	struct device_node *np;
+	struct platform_device *pdev;
+	struct rkisp_hw_dev *hw;
+
+	np = of_parse_phandle(isp->dev->of_node, "rockchip,hw", 0);
+	if (!np || !of_device_is_available(np)) {
+		dev_err(isp->dev, "failed to get isp hw node\n");
+		return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(np);
+	of_node_put(np);
+	if (!pdev) {
+		dev_err(isp->dev, "failed to get isp hw from node\n");
+		return -ENODEV;
+	}
+
+	hw = platform_get_drvdata(pdev);
+	if (!hw) {
+		dev_err(isp->dev, "failed attach isp hw\n");
+		return -EINVAL;
+	}
+
+	if (hw->dev_num)
+		hw->is_single = false;
+	isp->dev_id = hw->dev_num;
+	hw->isp[hw->dev_num] = isp;
+	hw->dev_num++;
+	isp->hw_dev = hw;
+	isp->isp_ver = hw->isp_ver;
+	isp->base_addr = hw->base_addr;
+
+	return 0;
+}
diff --git a/drivers/media/platform/rockchip/isp/common.h b/drivers/media/platform/rockchip/isp/common.h
index a181c9c83955..08bad85a69a2 100644
--- a/drivers/media/platform/rockchip/isp/common.h
+++ b/drivers/media/platform/rockchip/isp/common.h
@@ -63,6 +63,18 @@
 #define RKISP_EMDDATA_FIFO_MAX		4
 #define RKISP_DMATX_CHECK              0xA5A5A5A5
 
+struct rkisp_device;
+
+/* ISP_V10_1 for only support MP */
+enum rkisp_isp_ver {
+	ISP_V10 = 0x00,
+	ISP_V10_1 = 0x01,
+	ISP_V11 = 0x10,
+	ISP_V12 = 0x20,
+	ISP_V13 = 0x30,
+	ISP_V20 = 0x40,
+};
+
 enum rkisp_sd_type {
 	RKISP_SD_SENSOR,
 	RKISP_SD_PHY_CSI,
@@ -114,6 +126,7 @@ struct rkisp_dummy_buffer {
 };
 
 extern int rkisp_debug;
+extern struct platform_driver rkisp_plat_drv;
 
 static inline
 struct rkisp_vdev_node *vdev_to_node(struct video_device *vdev)
@@ -138,61 +151,13 @@ static inline struct vb2_queue *to_vb2_queue(struct file *file)
 	return &vnode->buf_queue;
 }
 
-static inline int rkisp_alloc_buffer(struct device *dev,
-				     struct rkisp_dummy_buffer *buf)
-{
-	const struct vb2_mem_ops *ops = &vb2_dma_contig_memops;
-	unsigned long attrs = buf->is_need_vaddr ? 0 : DMA_ATTR_NO_KERNEL_MAPPING;
-	void *mem_priv;
-	int ret = 0;
-
-	if (!buf->size) {
-		ret = -EINVAL;
-		goto err;
-	}
-
-	mem_priv = ops->alloc(dev, attrs, buf->size,
-			      DMA_BIDIRECTIONAL, GFP_KERNEL);
-	if (IS_ERR_OR_NULL(mem_priv)) {
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	buf->mem_priv = mem_priv;
-	buf->dma_addr = *((dma_addr_t *)ops->cookie(mem_priv));
-	if (!attrs)
-		buf->vaddr = ops->vaddr(mem_priv);
-	if (buf->is_need_dbuf)
-		buf->dbuf = ops->get_dmabuf(mem_priv, O_RDWR);
-	if (rkisp_debug)
-		dev_info(dev, "%s buf:0x%x~0x%x size:%d\n", __func__,
-			 (u32)buf->dma_addr, (u32)buf->dma_addr + buf->size, buf->size);
-
-	return ret;
-err:
-	dev_err(dev, "%s failed ret:%d\n", __func__, ret);
-	return ret;
-}
-
-static inline void rkisp_free_buffer(struct device *dev,
-				     struct rkisp_dummy_buffer *buf)
-{
-	const struct vb2_mem_ops *ops = &vb2_dma_contig_memops;
-
-	if (buf && buf->mem_priv) {
-		if (rkisp_debug)
-			dev_info(dev, "%s buf:0x%x~0x%x\n", __func__,
-				 (u32)buf->dma_addr, (u32)buf->dma_addr + buf->size);
-		if (buf->dbuf)
-			dma_buf_put(buf->dbuf);
-		ops->put(buf->mem_priv);
-		buf->size = 0;
-		buf->dbuf = NULL;
-		buf->vaddr = NULL;
-		buf->mem_priv = NULL;
-		buf->is_need_dbuf = false;
-		buf->is_need_vaddr = false;
-	}
-}
+void rkisp_write(struct rkisp_device *dev, u32 reg, u32 val, bool is_direct);
+u32 rkisp_read(struct rkisp_device *dev, u32 reg, bool is_direct);
+void rkisp_set_bits(struct rkisp_device *dev, u32 reg, u32 mask, u32 val, bool is_direct);
+void rkisp_clear_bits(struct rkisp_device *dev, u32 reg, u32 mask, bool is_direct);
+void rkisp_update_regs(struct rkisp_device *dev, u32 start, u32 end);
 
+int rkisp_alloc_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
+void rkisp_free_buffer(struct rkisp_device *dev, struct rkisp_dummy_buffer *buf);
+int rkisp_attach_hw(struct rkisp_device *isp);
 #endif /* _RKISP_COMMON_H */
diff --git a/drivers/media/platform/rockchip/isp/csi.c b/drivers/media/platform/rockchip/isp/csi.c
index c2cc8aaa289c..17cbb359f64d 100644
--- a/drivers/media/platform/rockchip/isp/csi.c
+++ b/drivers/media/platform/rockchip/isp/csi.c
@@ -131,14 +131,16 @@ static int rkisp_csi_s_stream(struct v4l2_subdev *sd, int on)
 {
 	struct rkisp_csi_device *csi = v4l2_get_subdevdata(sd);
 	struct rkisp_device *dev = csi->ispdev;
-	void __iomem *base = dev->base_addr;
 
 	memset(csi->tx_first, 0, sizeof(csi->tx_first));
 	memset(csi->filt_state, 0, sizeof(csi->filt_state));
+
+	if (!IS_HDR_RDBK(dev->hdr.op_mode))
+		return 0;
 	if (on)
-		writel(SW_Y_STAT_EN, base + CSI2RX_Y_STAT_CTRL);
+		rkisp_write(dev, CSI2RX_Y_STAT_CTRL, SW_Y_STAT_EN, true);
 	else
-		writel(0, base + CSI2RX_Y_STAT_CTRL);
+		rkisp_write(dev, CSI2RX_Y_STAT_CTRL, 0, true);
 	return 0;
 }
 
@@ -175,7 +177,6 @@ static struct v4l2_subdev_ops rkisp_csi_ops = {
 static int csi_config(struct rkisp_csi_device *csi)
 {
 	struct rkisp_device *dev = csi->ispdev;
-	void __iomem *base = dev->base_addr;
 	struct rkisp_sensor_info *sensor = dev->active_sensor;
 	struct v4l2_subdev *mipi_sensor;
 	struct v4l2_ctrl *ctrl;
@@ -239,35 +240,35 @@ static int csi_config(struct rkisp_csi_device *csi)
 	if (dev->isp_ver == ISP_V13 ||
 	    dev->isp_ver == ISP_V12) {
 		/* lanes */
-		writel(lanes - 1, base + CIF_ISP_CSI0_CTRL1);
+		rkisp_write(dev, CIF_ISP_CSI0_CTRL1, lanes - 1, true);
 
 		/* linecnt */
-		writel(0x3FFF, base + CIF_ISP_CSI0_CTRL2);
+		rkisp_write(dev, CIF_ISP_CSI0_CTRL2, 0x3FFF, true);
 
 		/* Configure Data Type and Virtual Channel */
-		writel(csi->mipi_di[0] | csi->mipi_di[1] << 8,
-		       base + CIF_ISP_CSI0_DATA_IDS_1);
+		rkisp_write(dev, CIF_ISP_CSI0_DATA_IDS_1,
+			    csi->mipi_di[0] | csi->mipi_di[1] << 8, true);
 
 		/* clear interrupts state */
-		readl(base + CIF_ISP_CSI0_ERR1);
-		readl(base + CIF_ISP_CSI0_ERR2);
-		readl(base + CIF_ISP_CSI0_ERR3);
+		rkisp_read(dev, CIF_ISP_CSI0_ERR1, true);
+		rkisp_read(dev, CIF_ISP_CSI0_ERR2, true);
+		rkisp_read(dev, CIF_ISP_CSI0_ERR3, true);
 		/* set interrupts mask */
-		writel(0x1FFFFFF0, base + CIF_ISP_CSI0_MASK1);
-		writel(0x03FFFFFF, base + CIF_ISP_CSI0_MASK2);
-		writel(CIF_ISP_CSI0_IMASK_FRAME_END(0x3F) |
-		       CIF_ISP_CSI0_IMASK_RAW0_OUT_V_END |
-		       CIF_ISP_CSI0_IMASK_RAW1_OUT_V_END |
-		       CIF_ISP_CSI0_IMASK_LINECNT,
-		       base + CIF_ISP_CSI0_MASK3);
+		rkisp_write(dev, CIF_ISP_CSI0_MASK1, 0x1FFFFFF0, true);
+		rkisp_write(dev, CIF_ISP_CSI0_MASK2, 0x03FFFFFF, true);
+		rkisp_write(dev, CIF_ISP_CSI0_MASK3,
+			    CIF_ISP_CSI0_IMASK_FRAME_END(0x3F) |
+			    CIF_ISP_CSI0_IMASK_RAW0_OUT_V_END |
+			    CIF_ISP_CSI0_IMASK_RAW1_OUT_V_END |
+			    CIF_ISP_CSI0_IMASK_LINECNT, true);
 
 		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 			 "CSI0_CTRL1 0x%08x\n"
 			 "CSI0_IDS 0x%08x\n"
 			 "CSI0_MASK3 0x%08x\n",
-			 readl(base + CIF_ISP_CSI0_CTRL1),
-			 readl(base + CIF_ISP_CSI0_DATA_IDS_1),
-			 readl(base + CIF_ISP_CSI0_MASK3));
+			 rkisp_read(dev, CIF_ISP_CSI0_CTRL1, true),
+			 rkisp_read(dev, CIF_ISP_CSI0_DATA_IDS_1, true),
+			 rkisp_read(dev, CIF_ISP_CSI0_MASK3, true));
 	} else if (dev->isp_ver == ISP_V20) {
 		struct rkmodule_hdr_cfg hdr_cfg;
 		u32 val;
@@ -287,28 +288,38 @@ static int csi_config(struct rkisp_csi_device *csi)
 
 		/* normal read back mode */
 		if (dev->hdr.op_mode == HDR_NORMAL &&
-		    (dev->isp_inp & 0x7) == INP_RAWRD2)
+		    (dev->isp_inp & INP_RAWRD2 || !dev->hw_dev->is_single))
 			dev->hdr.op_mode = HDR_RDBK_FRAME1;
 
-		writel(SW_IBUF_OP_MODE(dev->hdr.op_mode) |
-		       SW_HDR_ESP_MODE(dev->hdr.esp_mode),
-		       base + CSI2RX_CTRL0);
-		writel(lanes - 1, base + CSI2RX_CTRL1);
-		writel(0x3FFF, base + CSI2RX_CTRL2);
-		val = SW_CSI_ID0(csi->mipi_di[0]) |
-		      SW_CSI_ID1(csi->mipi_di[1]) |
+		/* op_mode update by mi_cfg_upd */
+		if (!dev->hw_dev->is_mi_update)
+			rkisp_write(dev, CSI2RX_CTRL0,
+				    SW_IBUF_OP_MODE(dev->hdr.op_mode) |
+				    SW_HDR_ESP_MODE(dev->hdr.esp_mode), true);
+		rkisp_write(dev, CSI2RX_CTRL1, lanes - 1, true);
+		rkisp_write(dev, CSI2RX_CTRL2, 0x3FFF, true);
+		val = SW_CSI_ID1(csi->mipi_di[1]) |
 		      SW_CSI_ID2(csi->mipi_di[2]) |
 		      SW_CSI_ID3(csi->mipi_di[3]);
-		writel(val, base + CSI2RX_DATA_IDS_1);
+		/* CSI_ID0 is for dmarx when read back mode */
+		if (dev->hw_dev->is_single) {
+			val |= SW_CSI_ID0(csi->mipi_di[0]);
+			rkisp_write(dev, CSI2RX_DATA_IDS_1, val, true);
+		} else {
+			rkisp_set_bits(dev, CSI2RX_DATA_IDS_1, 0, val, true);
+			for (i = 0; i < dev->hw_dev->dev_num; i++)
+				rkisp_set_bits(dev->hw_dev->isp[i],
+					CSI2RX_DATA_IDS_1, 0, val, false);
+		}
 		val = SW_CSI_ID4(csi->mipi_di[4]);
-		writel(val, base + CSI2RX_DATA_IDS_2);
+		rkisp_write(dev, CSI2RX_DATA_IDS_2, val, true);
 		/* clear interrupts state */
-		readl(base + CSI2RX_ERR_PHY);
+		rkisp_read(dev, CSI2RX_ERR_PHY, true);
 		/* set interrupts mask */
-		writel(0xF0FFFF, base + CSI2RX_MASK_PHY);
-		writel(0xF1FFFFF, base + CSI2RX_MASK_PACKET);
-		writel(0x7F7FF1, base + CSI2RX_MASK_OVERFLOW);
-		writel(0x7FFFFF7F, base + CSI2RX_MASK_STAT);
+		rkisp_write(dev, CSI2RX_MASK_PHY, 0xF0FFFF, true);
+		rkisp_write(dev, CSI2RX_MASK_PACKET, 0xF1FFFFF, true);
+		rkisp_write(dev, CSI2RX_MASK_OVERFLOW, 0x7F7FF1, true);
+		rkisp_write(dev, CSI2RX_MASK_STAT, 0x7FFFFF7F, true);
 
 		/* hdr merge */
 		switch (dev->hdr.op_mode) {
@@ -328,57 +339,58 @@ static int csi_config(struct rkisp_csi_device *csi)
 		default:
 			val = 0;
 		}
-		writel(val, base + ISP_HDRMGE_BASE);
-		writel(val & SW_HDRMGE_EN, base + ISP_HDRTMO_BASE);
+		rkisp_write(dev, ISP_HDRMGE_BASE, val, false);
+		rkisp_write(dev, ISP_HDRTMO_BASE, val, false);
 
 		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 			 "CSI2RX_IDS 0x%08x 0x%08x\n",
-			 readl(base + CSI2RX_DATA_IDS_1),
-			 readl(base + CSI2RX_DATA_IDS_2));
+			 rkisp_read(dev, CSI2RX_DATA_IDS_1, true),
+			 rkisp_read(dev, CSI2RX_DATA_IDS_2, true));
 	} else {
 		mipi_ctrl = CIF_MIPI_CTRL_NUM_LANES(lanes - 1) |
 			    CIF_MIPI_CTRL_SHUTDOWNLANES(0xf) |
 			    CIF_MIPI_CTRL_ERR_SOT_SYNC_HS_SKIP |
 			    CIF_MIPI_CTRL_CLOCKLANE_ENA;
 
-		writel(mipi_ctrl, base + CIF_MIPI_CTRL);
+		rkisp_write(dev, CIF_MIPI_CTRL, mipi_ctrl, true);
 
 		/* Configure Data Type and Virtual Channel */
-		writel(csi->mipi_di[0],
-		       base + CIF_MIPI_IMG_DATA_SEL);
-
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
-		       CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_1);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
-		       CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_2);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
-		       CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_3);
-		writel(CIF_MIPI_DATA_SEL_DT(emd_dt) |
-		       CIF_MIPI_DATA_SEL_VC(emd_vc),
-		       base + CIF_MIPI_ADD_DATA_SEL_4);
+		rkisp_write(dev, CIF_MIPI_IMG_DATA_SEL,
+			    csi->mipi_di[0], true);
+
+		rkisp_write(dev, CIF_MIPI_ADD_DATA_SEL_1,
+			    CIF_MIPI_DATA_SEL_DT(emd_dt) |
+			    CIF_MIPI_DATA_SEL_VC(emd_vc), true);
+		rkisp_write(dev, CIF_MIPI_ADD_DATA_SEL_2,
+			    CIF_MIPI_DATA_SEL_DT(emd_dt) |
+			    CIF_MIPI_DATA_SEL_VC(emd_vc), true);
+		rkisp_write(dev, CIF_MIPI_ADD_DATA_SEL_3,
+			    CIF_MIPI_DATA_SEL_DT(emd_dt) |
+			    CIF_MIPI_DATA_SEL_VC(emd_vc), true);
+		rkisp_write(dev, CIF_MIPI_ADD_DATA_SEL_4,
+			    CIF_MIPI_DATA_SEL_DT(emd_dt) |
+			    CIF_MIPI_DATA_SEL_VC(emd_vc), true);
 
 		/* Clear MIPI interrupts */
-		writel(~0, base + CIF_MIPI_ICR);
+		rkisp_write(dev, CIF_MIPI_ICR, ~0, true);
 		/*
 		 * Disable CIF_MIPI_ERR_DPHY interrupt here temporary for
 		 * isp bus may be dead when switch isp.
 		 */
-		writel(CIF_MIPI_FRAME_END | CIF_MIPI_ERR_CSI |
-		       CIF_MIPI_ERR_DPHY | CIF_MIPI_SYNC_FIFO_OVFLW(0x0F) |
-		       CIF_MIPI_ADD_DATA_OVFLW, base + CIF_MIPI_IMSC);
+		rkisp_write(dev, CIF_MIPI_IMSC,
+			    CIF_MIPI_FRAME_END | CIF_MIPI_ERR_CSI |
+			    CIF_MIPI_ERR_DPHY | CIF_MIPI_SYNC_FIFO_OVFLW(0x0F) |
+			    CIF_MIPI_ADD_DATA_OVFLW, true);
 
 		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 			 "\n  MIPI_CTRL 0x%08x\n"
 			 "  MIPI_IMG_DATA_SEL 0x%08x\n"
 			 "  MIPI_STATUS 0x%08x\n"
 			 "  MIPI_IMSC 0x%08x\n",
-			 readl(base + CIF_MIPI_CTRL),
-			 readl(base + CIF_MIPI_IMG_DATA_SEL),
-			 readl(base + CIF_MIPI_STATUS),
-			 readl(base + CIF_MIPI_IMSC));
+			 rkisp_read(dev, CIF_MIPI_CTRL, true),
+			 rkisp_read(dev, CIF_MIPI_IMG_DATA_SEL, true),
+			 rkisp_read(dev, CIF_MIPI_STATUS, true),
+			 rkisp_read(dev, CIF_MIPI_IMSC, true));
 	}
 
 	return 0;
@@ -389,6 +401,7 @@ int rkisp_csi_config_patch(struct rkisp_device *dev)
 	int val = 0, ret = 0;
 
 	if (dev->isp_inp & INP_CSI) {
+		dev->hw_dev->mipi_dev_id = dev->dev_id;
 		ret = csi_config(&dev->csi_dev);
 	} else {
 		switch (dev->isp_inp & 0x7) {
@@ -405,18 +418,17 @@ int rkisp_csi_config_patch(struct rkisp_device *dev)
 		default: //INP_RAWRD2
 			dev->hdr.op_mode = HDR_RDBK_FRAME1;
 		}
-		writel(SW_IBUF_OP_MODE(dev->hdr.op_mode),
-		       dev->base_addr + CSI2RX_CTRL0);
-		writel(val, dev->base_addr + ISP_HDRMGE_BASE);
-		writel(val & SW_HDRMGE_EN, dev->base_addr + ISP_HDRTMO_BASE);
-		writel(0x7FFFFF7F, dev->base_addr + CSI2RX_MASK_STAT);
-		writel(0, dev->base_addr + CSI2RX_MASK_PACKET);
-		writel(0, dev->base_addr + CSI2RX_MASK_PHY);
+		if (!dev->hw_dev->is_mi_update)
+			rkisp_write(dev, CSI2RX_CTRL0,
+				    SW_IBUF_OP_MODE(dev->hdr.op_mode), true);
+		rkisp_write(dev, ISP_HDRMGE_BASE, val, false);
+		rkisp_write(dev, ISP_HDRTMO_BASE, val & SW_HDRMGE_EN, false);
+		rkisp_write(dev, CSI2RX_MASK_STAT, 0x7FFFFF7F, true);
 	}
 
 	if (IS_HDR_RDBK(dev->hdr.op_mode))
-		isp_set_bits(dev->base_addr + CTRL_SWS_CFG,
-			     0, SW_MPIP_DROP_FRM_DIS);
+		rkisp_set_bits(dev, CTRL_SWS_CFG,
+			       0, SW_MPIP_DROP_FRM_DIS, true);
 	dev->csi_dev.is_isp_end = true;
 	return ret;
 }
@@ -428,9 +440,9 @@ int rkisp_csi_config_patch(struct rkisp_device *dev)
 void rkisp_trigger_read_back(struct rkisp_csi_device *csi, u8 dma2frm)
 {
 	struct rkisp_device *dev = csi->ispdev;
-	void __iomem *addr = dev->base_addr + CSI2RX_CTRL0;
+	struct rkisp_hw_dev *hw = dev->hw_dev;
 	struct rkisp_isp_params_vdev *params_vdev = &dev->params_vdev;
-	u32 cur_frame_id;
+	u32 val, cur_frame_id;
 
 	rkisp_dmarx_get_frame(dev, &cur_frame_id, NULL, true);
 	if (dma2frm > 2)
@@ -451,79 +463,112 @@ void rkisp_trigger_read_back(struct rkisp_csi_device *csi, u8 dma2frm)
 	/* configure hdr params in rdbk mode */
 	rkisp_params_cfg(params_vdev, cur_frame_id, dma2frm + 1);
 
+	if (!hw->is_single) {
+		rkisp_update_regs(dev, CTRL_VI_ISP_PATH, SUPER_IMP_COLOR_CR);
+		rkisp_update_regs(dev, ISP_ACQ_PROP, ISP_RAWAWB_RAM_DATA);
+
+		val = rkisp_read(dev, ISP_CTRL, false);
+		val |= CIF_ISP_CTRL_ISP_CFG_UPD;
+		rkisp_write(dev, ISP_CTRL, val, true);
+	}
 	/* not using isp V_START irq to generate sof event */
 	csi->filt_state[CSI_F_VS] = dma2frm + 1;
 	v4l2_dbg(2, rkisp_debug, &dev->v4l2_dev,
-		 "isp readback frame:%d time:%d\n",
+		 "readback frame:%d time:%d\n",
 		 cur_frame_id, dma2frm + 1);
-	writel(SW_DMA_2FRM_MODE(dma2frm) | SW_IBUF_OP_MODE(dev->hdr.op_mode) |
-		   SW_CSI2RX_EN | readl(addr), addr);
+	val = rkisp_read(dev, CSI2RX_CTRL0, true);
+	val &= ~SW_IBUF_OP_MODE(0xf);
+	val |= SW_CSI2RX_EN | SW_DMA_2FRM_MODE(dma2frm) |
+		SW_IBUF_OP_MODE(dev->hdr.op_mode);
+	rkisp_write(dev, CSI2RX_CTRL0, val, true);
+}
+
+static void rkisp_dev_trigger_handle(struct rkisp_device *dev, u32 cmd)
+{
+	struct rkisp_hw_dev *hw = dev->hw_dev;
+	struct rkisp_device *isp = NULL;
+	struct isp2x_csi_trigger t = { 0 };
+	unsigned long lock_flags = 0;
+	int i, times = -1, max = 0, id = 0;
+	int len[DEV_MAX] = { 0 };
+
+	spin_lock_irqsave(&hw->rdbk_lock, lock_flags);
+	if (cmd == T_CMD_END)
+		hw->is_idle = true;
+	if (!hw->is_idle)
+		goto end;
+	for (i = 0; i < hw->dev_num; i++) {
+		isp = hw->isp[i];
+		if (!(isp->isp_state & ISP_START))
+			continue;
+		rkisp_csi_trigger_event(isp, T_CMD_LEN, &len[i]);
+		if (max < len[i]) {
+			max = len[i];
+			id = i;
+		}
+	}
+
+	if (max) {
+		v4l2_dbg(2, rkisp_debug, &dev->v4l2_dev,
+			 "handle isp%d, trigger fifo len:%d\n",
+			 id, max);
+		isp = hw->isp[id];
+		rkisp_csi_trigger_event(isp, T_CMD_DEQUEUE, &t);
+		isp->dmarx_dev.pre_frame = isp->dmarx_dev.cur_frame;
+		isp->dmarx_dev.cur_frame.id = t.frame_id;
+		isp->dmarx_dev.cur_frame.timestamp = t.frame_timestamp;
+		times = t.times;
+		hw->cur_dev_id = id;
+		hw->is_idle = false;
+	}
+end:
+	spin_unlock_irqrestore(&hw->rdbk_lock, lock_flags);
+	if (times >= 0)
+		rkisp_trigger_read_back(&isp->csi_dev, times);
 }
 
 /* handle read back event from user or isp idle isr */
-int rkisp_csi_trigger_event(struct rkisp_csi_device *csi, void *arg)
+int rkisp_csi_trigger_event(struct rkisp_device *dev, u32 cmd, void *arg)
 {
-	struct rkisp_device *dev = csi->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
 	struct kfifo *fifo = &csi->rdbk_kfifo;
-	struct isp2x_csi_trigger *trigger =
-		(struct isp2x_csi_trigger *)arg;
-	struct isp2x_csi_trigger t;
+	struct isp2x_csi_trigger *trigger = NULL;
 	unsigned long lock_flags = 0;
-	int times = -1;
+	int val, ret = 0;
 
-	if (!IS_HDR_RDBK(dev->hdr.op_mode))
+	if (dev->dmarx_dev.trigger != T_MANUAL)
 		return 0;
 
 	spin_lock_irqsave(&csi->rdbk_lock, lock_flags);
-	if (!trigger)
-		csi->is_isp_end = true;
-
-	/* isp doesn't ready to read back */
-	if (!(dev->isp_state & ISP_START)) {
-		if (trigger)
-			kfifo_in(fifo, trigger, sizeof(*trigger));
-		csi->is_isp_end = true;
-		goto end;
-	}
-
-	if (trigger &&
-	    (csi->is_isp_end && kfifo_is_empty(fifo))) {
-		/* isp idle and no event in queue
-		 * start read back direct
-		 */
-		dev->dmarx_dev.pre_frame = dev->dmarx_dev.cur_frame;
-		dev->dmarx_dev.cur_frame.id = trigger->frame_id;
-		dev->dmarx_dev.cur_frame.timestamp = trigger->frame_timestamp;
-		times = trigger->times;
-		csi->is_isp_end = false;
-	} else if (csi->is_isp_end && !kfifo_is_empty(fifo)) {
-		/* isp idle and events in queue
-		 * out fifo then start read back
-		 * new event in fifo
-		 */
-		if (kfifo_out(fifo, &t, sizeof(t))) {
-			dev->dmarx_dev.pre_frame = dev->dmarx_dev.cur_frame;
-			dev->dmarx_dev.cur_frame.id = t.frame_id;
-			dev->dmarx_dev.cur_frame.timestamp = t.frame_timestamp;
-			times = t.times;
-		}
-		if (trigger)
-			kfifo_in(fifo, trigger, sizeof(*trigger));
-		csi->is_isp_end = false;
-	} else if (!csi->is_isp_end && trigger) {
-		/* isp on idle, new event in fifo */
+	switch (cmd) {
+	case T_CMD_QUEUE:
+		trigger = arg;
+		if (!trigger)
+			break;
 		if (!kfifo_is_full(fifo))
 			kfifo_in(fifo, trigger, sizeof(*trigger));
 		else
-			v4l2_err(&dev->v4l2_dev,
-				 "csi trigger fifo is full\n");
+			v4l2_err(&dev->v4l2_dev, "csi fifo is full\n");
+		break;
+	case T_CMD_DEQUEUE:
+		if (!kfifo_is_empty(fifo))
+			ret = kfifo_out(fifo, arg,
+					sizeof(struct isp2x_csi_trigger));
+		if (!ret)
+			ret = -EINVAL;
+		break;
+	case T_CMD_LEN:
+		val = kfifo_len(fifo) / sizeof(struct isp2x_csi_trigger);
+		*(u32 *)arg = val;
+		break;
+	default:
+		break;
 	}
-end:
 	spin_unlock_irqrestore(&csi->rdbk_lock, lock_flags);
 
-	if (times >= 0)
-		rkisp_trigger_read_back(csi, times);
-	return 0;
+	if (cmd == T_CMD_QUEUE || cmd == T_CMD_END)
+		rkisp_dev_trigger_handle(dev, cmd);
+	return ret;
 }
 
 void rkisp_csi_sof(struct rkisp_device *dev, u8 id)
diff --git a/drivers/media/platform/rockchip/isp/csi.h b/drivers/media/platform/rockchip/isp/csi.h
index e2497ac99f3e..490c93a79a3a 100644
--- a/drivers/media/platform/rockchip/isp/csi.h
+++ b/drivers/media/platform/rockchip/isp/csi.h
@@ -22,6 +22,13 @@
 	 __x == HDR_RDBK_FRAME3); \
 })
 
+enum {
+	T_CMD_QUEUE,
+	T_CMD_DEQUEUE,
+	T_CMD_LEN,
+	T_CMD_END,
+};
+
 enum hdr_op_mode {
 	HDR_NORMAL = 0,
 	HDR_RDBK_FRAME1 = 4,
@@ -89,6 +96,6 @@ void rkisp_unregister_csi_subdev(struct rkisp_device *dev);
 
 int rkisp_csi_config_patch(struct rkisp_device *dev);
 void rkisp_trigger_read_back(struct rkisp_csi_device *csi, u8 dma2frm);
-int rkisp_csi_trigger_event(struct rkisp_csi_device *csi, void *arg);
+int rkisp_csi_trigger_event(struct rkisp_device *dev, u32 cmd, void *arg);
 void rkisp_csi_sof(struct rkisp_device *dev, u8 id);
 #endif
diff --git a/drivers/media/platform/rockchip/isp/dev.c b/drivers/media/platform/rockchip/isp/dev.c
index bc3a9bfad825..c64bf682fe5d 100644
--- a/drivers/media/platform/rockchip/isp/dev.c
+++ b/drivers/media/platform/rockchip/isp/dev.c
@@ -35,7 +35,6 @@
 #include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -56,21 +55,6 @@
 
 #define RKISP_VERNO_LEN		10
 
-struct isp_irqs_data {
-	const char *name;
-	irqreturn_t (*irq_hdl)(int irq, void *ctx);
-};
-
-struct isp_match_data {
-	const char * const *clks;
-	int num_clks;
-	enum rkisp_isp_ver isp_ver;
-	const unsigned int *clk_rate_tbl;
-	int num_clk_rate_tbl;
-	struct isp_irqs_data *irqs;
-	int num_irqs;
-};
-
 int rkisp_debug;
 module_param_named(debug, rkisp_debug, int, 0644);
 MODULE_PARM_DESC(debug, "Debug level (0-1)");
@@ -160,9 +144,12 @@ static int __isp_pipeline_s_isp_clk(struct rkisp_pipeline *p)
 	u64 data_rate;
 	int i;
 
+	if (!dev->hw_dev->is_single)
+		return 0;
+
 	if (!(dev->isp_inp & (INP_CSI | INP_DVP | INP_LVDS))) {
-		if (dev->clks[0])
-			clk_set_rate(dev->clks[0], 400 * 1000000UL);
+		if (dev->hw_dev->clks[0])
+			clk_set_rate(dev->hw_dev->clks[0], 500 * 1000000UL);
 		return 0;
 	}
 
@@ -195,16 +182,16 @@ static int __isp_pipeline_s_isp_clk(struct rkisp_pipeline *p)
 	data_rate += data_rate >> 2;
 
 	/* compare with isp clock adjustment table */
-	for (i = 0; i < dev->num_clk_rate_tbl; i++)
-		if (data_rate <= dev->clk_rate_tbl[i])
+	for (i = 0; i < dev->hw_dev->num_clk_rate_tbl; i++)
+		if (data_rate <= dev->hw_dev->clk_rate_tbl[i])
 			break;
-	if (i == dev->num_clk_rate_tbl)
+	if (i == dev->hw_dev->num_clk_rate_tbl)
 		i--;
 
 	/* set isp clock rate */
-	clk_set_rate(dev->clks[0], dev->clk_rate_tbl[i] * 1000000UL);
+	clk_set_rate(dev->hw_dev->clks[0], dev->hw_dev->clk_rate_tbl[i] * 1000000UL);
 	v4l2_dbg(1, rkisp_debug, sd, "set isp clk = %luHz\n",
-		 clk_get_rate(dev->clks[0]));
+		 clk_get_rate(dev->hw_dev->clks[0]));
 
 	return 0;
 }
@@ -587,342 +574,12 @@ static int rkisp_register_platform_subdevs(struct rkisp_device *dev)
 	return ret;
 }
 
-static irqreturn_t rkisp_irq_handler(int irq, void *ctx)
-{
-	struct device *dev = ctx;
-	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
-	unsigned int mis_val, mis_3a = 0;
-
-	mis_val = readl(rkisp_dev->base_addr + CIF_ISP_MIS);
-	if (rkisp_dev->isp_ver == ISP_V20)
-		mis_3a = readl(rkisp_dev->base_addr + ISP_ISP3A_MIS);
-	if (mis_val || mis_3a)
-		rkisp_isp_isr(mis_val, mis_3a, rkisp_dev);
-
-	mis_val = readl(rkisp_dev->base_addr + CIF_MIPI_MIS);
-	if (mis_val)
-		rkisp_mipi_isr(mis_val, rkisp_dev);
-
-	mis_val = readl(rkisp_dev->base_addr + CIF_MI_MIS);
-	if (mis_val)
-		rkisp_mi_isr(mis_val, rkisp_dev);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rkisp_isp_irq_hdl(int irq, void *ctx)
-{
-	struct device *dev = ctx;
-	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
-	unsigned int mis_val, mis_3a = 0;
-
-	if (rkisp_dev->is_thunderboot)
-		return IRQ_HANDLED;
-
-	mis_val = readl(rkisp_dev->base_addr + CIF_ISP_MIS);
-	if (rkisp_dev->isp_ver == ISP_V20)
-		mis_3a = readl(rkisp_dev->base_addr + ISP_ISP3A_MIS);
-	if (mis_val || mis_3a)
-		rkisp_isp_isr(mis_val, mis_3a, rkisp_dev);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rkisp_mi_irq_hdl(int irq, void *ctx)
-{
-	struct device *dev = ctx;
-	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
-	unsigned int mis_val;
-
-	if (rkisp_dev->is_thunderboot)
-		return IRQ_HANDLED;
-
-	mis_val = readl(rkisp_dev->base_addr + CIF_MI_MIS);
-	if (mis_val)
-		rkisp_mi_isr(mis_val, rkisp_dev);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rkisp_mipi_irq_hdl(int irq, void *ctx)
-{
-	struct device *dev = ctx;
-	struct rkisp_device *rkisp_dev = dev_get_drvdata(dev);
-
-	if (rkisp_dev->is_thunderboot)
-		return IRQ_HANDLED;
-
-	if (rkisp_dev->isp_ver == ISP_V13 ||
-		rkisp_dev->isp_ver == ISP_V12) {
-		u32 err1, err2, err3;
-
-		err1 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR1);
-		err2 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR2);
-		err3 = readl(rkisp_dev->base_addr + CIF_ISP_CSI0_ERR3);
-
-		if (err3 & 0xf)
-			rkisp_mipi_dmatx0_end(err3, rkisp_dev);
-		if (err1 || err2 || err3)
-			rkisp_mipi_v13_isr(err1, err2, err3, rkisp_dev);
-	} else if (rkisp_dev->isp_ver == ISP_V20) {
-		u32 phy, packet, overflow, state;
-
-		state = readl(rkisp_dev->base_addr + CSI2RX_ERR_STAT);
-		phy = readl(rkisp_dev->base_addr + CSI2RX_ERR_PHY);
-		packet = readl(rkisp_dev->base_addr + CSI2RX_ERR_PACKET);
-		overflow = readl(rkisp_dev->base_addr + CSI2RX_ERR_OVERFLOW);
-		if (phy | packet | overflow | state)
-			rkisp_mipi_v20_isr(phy, packet, overflow,
-					    state, rkisp_dev);
-	} else {
-		u32 mis_val = readl(rkisp_dev->base_addr + CIF_MIPI_MIS);
-
-		if (mis_val)
-			rkisp_mipi_isr(mis_val, rkisp_dev);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static const char * const rk1808_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-	"pclk_isp",
-};
-
-static const char * const rk3288_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-	"pclk_isp_in",
-	"sclk_isp_jpe",
-};
-
-static const char * const rk3326_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-	"pclk_isp",
-};
-
-static const char * const rk3368_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-	"pclk_isp",
-};
-
-static const char * const rk3399_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-	"aclk_isp_wrap",
-	"hclk_isp_wrap",
-	"pclk_isp_wrap"
-};
-
-static const char * const rv1126_isp_clks[] = {
-	"clk_isp",
-	"aclk_isp",
-	"hclk_isp",
-};
-
-/* isp clock adjustment table (MHz) */
-static const unsigned int rk1808_isp_clk_rate[] = {
-	300, 400, 500, 600
-};
-
-/* isp clock adjustment table (MHz) */
-static const unsigned int rk3288_isp_clk_rate[] = {
-	150, 384, 500, 594
-};
-
-/* isp clock adjustment table (MHz) */
-static const unsigned int rk3326_isp_clk_rate[] = {
-	300, 347, 400, 520, 600
-};
-
-/* isp clock adjustment table (MHz) */
-static const unsigned int rk3368_isp_clk_rate[] = {
-	300, 400, 600
-};
-
-/* isp clock adjustment table (MHz) */
-static const unsigned int rk3399_isp_clk_rate[] = {
-	300, 400, 600
-};
-
-static const unsigned int rv1126_isp_clk_rate[] = {
-	400, 500
-};
-
-static struct isp_irqs_data rk1808_isp_irqs[] = {
-	{"isp_irq", rkisp_isp_irq_hdl},
-	{"mi_irq", rkisp_mi_irq_hdl},
-	{"mipi_irq", rkisp_mipi_irq_hdl}
-};
-
-static struct isp_irqs_data rk3288_isp_irqs[] = {
-	{"isp_irq", rkisp_irq_handler}
-};
-
-static struct isp_irqs_data rk3326_isp_irqs[] = {
-	{"isp_irq", rkisp_isp_irq_hdl},
-	{"mi_irq", rkisp_mi_irq_hdl},
-	{"mipi_irq", rkisp_mipi_irq_hdl}
-};
-
-static struct isp_irqs_data rk3368_isp_irqs[] = {
-	{"isp_irq", rkisp_irq_handler}
-};
-
-static struct isp_irqs_data rk3399_isp_irqs[] = {
-	{"isp_irq", rkisp_irq_handler}
-};
-
-static struct isp_irqs_data rv1126_isp_irqs[] = {
-	{"isp_irq", rkisp_isp_irq_hdl},
-	{"mi_irq", rkisp_mi_irq_hdl},
-	{"mipi_irq", rkisp_mipi_irq_hdl}
-};
-
-static const struct isp_match_data rv1126_isp_match_data = {
-	.clks = rv1126_isp_clks,
-	.num_clks = ARRAY_SIZE(rv1126_isp_clks),
-	.isp_ver = ISP_V20,
-	.clk_rate_tbl = rv1126_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rv1126_isp_clk_rate),
-	.irqs = rv1126_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rv1126_isp_irqs)
-};
-
-static const struct isp_match_data rk1808_isp_match_data = {
-	.clks = rk1808_isp_clks,
-	.num_clks = ARRAY_SIZE(rk1808_isp_clks),
-	.isp_ver = ISP_V13,
-	.clk_rate_tbl = rk1808_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rk1808_isp_clk_rate),
-	.irqs = rk1808_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rk1808_isp_irqs)
-};
-
-static const struct isp_match_data rk3288_isp_match_data = {
-	.clks = rk3288_isp_clks,
-	.num_clks = ARRAY_SIZE(rk3288_isp_clks),
-	.isp_ver = ISP_V10,
-	.clk_rate_tbl = rk3288_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rk3288_isp_clk_rate),
-	.irqs = rk3288_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rk3288_isp_irqs)
-};
-
-static const struct isp_match_data rk3326_isp_match_data = {
-	.clks = rk3326_isp_clks,
-	.num_clks = ARRAY_SIZE(rk3326_isp_clks),
-	.isp_ver = ISP_V12,
-	.clk_rate_tbl = rk3326_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rk3326_isp_clk_rate),
-	.irqs = rk3326_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rk3326_isp_irqs)
-};
-
-static const struct isp_match_data rk3368_isp_match_data = {
-	.clks = rk3368_isp_clks,
-	.num_clks = ARRAY_SIZE(rk3368_isp_clks),
-	.isp_ver = ISP_V10_1,
-	.clk_rate_tbl = rk3368_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rk3368_isp_clk_rate),
-	.irqs = rk3368_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rk3368_isp_irqs)
-};
-
-static const struct isp_match_data rk3399_isp_match_data = {
-	.clks = rk3399_isp_clks,
-	.num_clks = ARRAY_SIZE(rk3399_isp_clks),
-	.isp_ver = ISP_V10,
-	.clk_rate_tbl = rk3399_isp_clk_rate,
-	.num_clk_rate_tbl = ARRAY_SIZE(rk3399_isp_clk_rate),
-	.irqs = rk3399_isp_irqs,
-	.num_irqs = ARRAY_SIZE(rk3399_isp_irqs)
-};
-
-static const struct of_device_id rkisp_plat_of_match[] = {
-	{
-		.compatible = "rockchip,rk1808-rkisp1",
-		.data = &rk1808_isp_match_data,
-	}, {
-		.compatible = "rockchip,rk3288-rkisp1",
-		.data = &rk3288_isp_match_data,
-	}, {
-		.compatible = "rockchip,rk3326-rkisp1",
-		.data = &rk3326_isp_match_data,
-	}, {
-		.compatible = "rockchip,rk3368-rkisp1",
-		.data = &rk3368_isp_match_data,
-	}, {
-		.compatible = "rockchip,rk3399-rkisp1",
-		.data = &rk3399_isp_match_data,
-	}, {
-		.compatible = "rockchip,rv1126-rkisp",
-		.data = &rv1126_isp_match_data,
-	},
-	{},
-};
-
-static void rkisp_disable_sys_clk(struct rkisp_device *rkisp_dev)
-{
-	int i;
-
-	for (i = rkisp_dev->num_clks - 1; i >= 0; i--)
-		if (!IS_ERR(rkisp_dev->clks[i]))
-			clk_disable_unprepare(rkisp_dev->clks[i]);
-}
-
-static int rkisp_enable_sys_clk(struct rkisp_device *rkisp_dev)
-{
-	int i, ret = -EINVAL;
-
-	for (i = 0; i < rkisp_dev->num_clks; i++) {
-		if (!IS_ERR(rkisp_dev->clks[i])) {
-			ret = clk_prepare_enable(rkisp_dev->clks[i]);
-			if (ret < 0)
-				goto err;
-		}
-	}
-	return 0;
-err:
-	for (--i; i >= 0; --i)
-		if (!IS_ERR(rkisp_dev->clks[i]))
-			clk_disable_unprepare(rkisp_dev->clks[i]);
-	return ret;
-}
-
-static inline bool is_iommu_enable(struct device *dev)
-{
-	struct device_node *iommu;
-
-	iommu = of_parse_phandle(dev->of_node, "iommus", 0);
-	if (!iommu) {
-		dev_info(dev, "no iommu attached, using non-iommu buffers\n");
-		return false;
-	} else if (!of_device_is_available(iommu)) {
-		dev_info(dev, "iommu is disabled, using non-iommu buffers\n");
-		of_node_put(iommu);
-		return false;
-	}
-	of_node_put(iommu);
-
-	return true;
-}
-
-static int rkisp_vs_irq_parse(struct platform_device *pdev)
+static int rkisp_vs_irq_parse(struct device *dev)
 {
 	int ret;
 	int vs_irq;
 	unsigned long vs_irq_flags;
 	struct gpio_desc *vs_irq_gpio;
-	struct device *dev = &pdev->dev;
 	struct rkisp_device *isp_dev = dev_get_drvdata(dev);
 
 	/* this irq recevice the message of sensor vs from preisp */
@@ -991,78 +648,11 @@ static int rkisp_get_reserved_mem(struct rkisp_device *isp_dev)
 	return 0;
 }
 
-int rkisp_register_irq(struct rkisp_device *isp_dev)
-{
-	const struct isp_match_data *match_data = isp_dev->match_data;
-	struct platform_device *pdev = isp_dev->pdev;
-	struct device *dev = &pdev->dev;
-	struct resource *res;
-	int i, ret, irq;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,
-					   match_data->irqs[0].name);
-	if (res) {
-		/* there are irq names in dts */
-		for (i = 0; i < match_data->num_irqs; i++) {
-			irq = platform_get_irq_byname(pdev,
-						      match_data->irqs[i].name);
-			if (irq < 0) {
-				dev_err(dev, "no irq %s in dts\n",
-					match_data->irqs[i].name);
-				return irq;
-			}
-
-			if (!strcmp(match_data->irqs[i].name, "mipi_irq"))
-				isp_dev->mipi_irq = irq;
-
-			ret = devm_request_irq(dev, irq,
-					       match_data->irqs[i].irq_hdl,
-					       IRQF_SHARED,
-					       dev_driver_string(dev),
-					       dev);
-			if (ret < 0) {
-				dev_err(dev, "request %s failed: %d\n",
-					match_data->irqs[i].name,
-					ret);
-				return ret;
-			}
-
-			if (isp_dev->mipi_irq == irq &&
-			    (isp_dev->isp_ver == ISP_V12 ||
-			     isp_dev->isp_ver == ISP_V13))
-				disable_irq(isp_dev->mipi_irq);
-		}
-	} else {
-		/* no irq names in dts */
-		irq = platform_get_irq(pdev, 0);
-		if (irq < 0) {
-			dev_err(dev, "no isp irq in dts\n");
-			return irq;
-		}
-
-		ret = devm_request_irq(dev, irq,
-				       rkisp_irq_handler,
-				       IRQF_SHARED,
-				       dev_driver_string(dev),
-				       dev);
-		if (ret < 0) {
-			dev_err(dev, "request irq failed: %d\n", ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int rkisp_plat_probe(struct platform_device *pdev)
 {
-	const struct of_device_id *match;
-	struct device_node *node = pdev->dev.of_node;
 	struct device *dev = &pdev->dev;
 	struct v4l2_device *v4l2_dev;
 	struct rkisp_device *isp_dev;
-	const struct isp_match_data *match_data;
-	struct resource *res;
 	int i, ret;
 
 	sprintf(rkisp_version, "v%02x.%02x.%02x",
@@ -1072,59 +662,28 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 
 	dev_info(dev, "rkisp driver version: %s\n", rkisp_version);
 
-	match = of_match_node(rkisp_plat_of_match, node);
 	isp_dev = devm_kzalloc(dev, sizeof(*isp_dev), GFP_KERNEL);
 	if (!isp_dev)
 		return -ENOMEM;
+	isp_dev->sw_base_addr = devm_kzalloc(dev, ISP_SW_MAX_SIZE, GFP_KERNEL);
+	if (!isp_dev->sw_base_addr)
+		return -ENOMEM;
 
 	dev_set_drvdata(dev, isp_dev);
 	isp_dev->dev = dev;
-	isp_dev->is_thunderboot = IS_ENABLED(CONFIG_VIDEO_ROCKCHIP_THUNDER_BOOT_ISP);
-	dev_info(dev, "is_thunderboot: %d\n", isp_dev->is_thunderboot);
-
-	isp_dev->grf = syscon_regmap_lookup_by_phandle(dev->of_node,
-		"rockchip,grf");
-	if (IS_ERR(isp_dev->grf))
-		dev_warn(dev, "Missing rockchip,grf property\n");
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(dev, "get resource failed\n");
-		return -EINVAL;
-	}
-	isp_dev->base_addr = devm_ioremap_resource(dev, res);
-	if (PTR_ERR(isp_dev->base_addr) == -EBUSY) {
-		resource_size_t offset = res->start;
-		resource_size_t size = resource_size(res);
 
-		isp_dev->base_addr = devm_ioremap(dev, offset, size);
-	}
-	if (IS_ERR(isp_dev->base_addr)) {
-		dev_err(dev, "ioremap failed\n");
-		return PTR_ERR(isp_dev->base_addr);
-	}
-	rkisp_get_reserved_mem(isp_dev);
-
-	match_data = match->data;
-	isp_dev->mipi_irq = -1;
-	isp_dev->isp_ver = match_data->isp_ver;
-
-	isp_dev->pdev = pdev;
-	isp_dev->match_data = match_data;
-	if (!isp_dev->is_thunderboot)
-		rkisp_register_irq(isp_dev);
+	ret = rkisp_vs_irq_parse(dev);
+	if (ret)
+		return ret;
 
-	for (i = 0; i < match_data->num_clks; i++) {
-		struct clk *clk = devm_clk_get(dev, match_data->clks[i]);
+	ret = rkisp_attach_hw(isp_dev);
+	if (ret)
+		return ret;
 
-		if (IS_ERR(clk))
-			dev_dbg(dev, "failed to get %s\n", match_data->clks[i]);
-		isp_dev->clks[i] = clk;
-	}
-	isp_dev->num_clks = match_data->num_clks;
-	isp_dev->clk_rate_tbl = match_data->clk_rate_tbl;
-	isp_dev->num_clk_rate_tbl = match_data->num_clk_rate_tbl;
+	sprintf(isp_dev->name, "%s%d",
+		DRIVER_NAME, isp_dev->dev_id);
 
+	rkisp_get_reserved_mem(isp_dev);
 	mutex_init(&isp_dev->apilock);
 	mutex_init(&isp_dev->iqlock);
 	atomic_set(&isp_dev->pipe.power_cnt, 0);
@@ -1142,37 +701,27 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 		}
 	}
 
-	strlcpy(isp_dev->media_dev.model, DRIVER_NAME,
+	strlcpy(isp_dev->media_dev.model, isp_dev->name,
 		sizeof(isp_dev->media_dev.model));
-	isp_dev->media_dev.dev = &pdev->dev;
+	isp_dev->media_dev.dev = dev;
 	isp_dev->media_dev.ops = &rkisp_media_ops;
 
-	if (!is_iommu_enable(dev)) {
-		ret = of_reserved_mem_device_init(dev);
-		if (ret) {
-			dev_err(dev, "No reserved memory region\n");
-			return ret;
-		}
-	}
-
 	v4l2_dev = &isp_dev->v4l2_dev;
 	v4l2_dev->mdev = &isp_dev->media_dev;
-	strlcpy(v4l2_dev->name, DRIVER_NAME, sizeof(v4l2_dev->name));
+	strlcpy(v4l2_dev->name, isp_dev->name, sizeof(v4l2_dev->name));
 	v4l2_ctrl_handler_init(&isp_dev->ctrl_handler, 5);
 	v4l2_dev->ctrl_handler = &isp_dev->ctrl_handler;
 
 	ret = v4l2_device_register(isp_dev->dev, &isp_dev->v4l2_dev);
 	if (ret < 0) {
-		v4l2_err(v4l2_dev, "Failed to register v4l2 device: %d\n",
-			 ret);
+		v4l2_err(v4l2_dev, "Failed to register v4l2 device:%d\n", ret);
 		return ret;
 	}
 
 	media_device_init(&isp_dev->media_dev);
 	ret = media_device_register(&isp_dev->media_dev);
 	if (ret < 0) {
-		v4l2_err(v4l2_dev, "Failed to register media device: %d\n",
-			 ret);
+		v4l2_err(v4l2_dev, "Failed to register media device:%d\n", ret);
 		goto err_unreg_v4l2_dev;
 	}
 
@@ -1181,26 +730,17 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto err_unreg_media_dev;
 
-	pm_runtime_enable(&pdev->dev);
-	if (isp_dev->is_thunderboot)
-		pm_runtime_get_sync(&pdev->dev);
-
-	ret = rkisp_vs_irq_parse(pdev);
-	if (ret)
-		goto err_runtime_disable;
-
 	mutex_lock(&rkisp_dev_mutex);
 	list_add_tail(&isp_dev->list, &rkisp_device_list);
 	mutex_unlock(&rkisp_dev_mutex);
+
+	pm_runtime_enable(dev);
 	return 0;
 
-err_runtime_disable:
-	pm_runtime_disable(&pdev->dev);
 err_unreg_media_dev:
 	media_device_unregister(&isp_dev->media_dev);
 err_unreg_v4l2_dev:
 	v4l2_device_unregister(&isp_dev->v4l2_dev);
-
 	return ret;
 }
 
@@ -1220,45 +760,25 @@ static int rkisp_plat_remove(struct platform_device *pdev)
 	rkisp_unregister_csi_subdev(isp_dev);
 	rkisp_unregister_isp_subdev(isp_dev);
 	media_device_cleanup(&isp_dev->media_dev);
-
 	return 0;
 }
 
 static int __maybe_unused rkisp_runtime_suspend(struct device *dev)
 {
 	struct rkisp_device *isp_dev = dev_get_drvdata(dev);
-	int ret = 0;
-
-	if (isp_dev->isp_ver == ISP_V12 || isp_dev->isp_ver == ISP_V13) {
-		if (isp_dev->mipi_irq >= 0)
-			disable_irq(isp_dev->mipi_irq);
-	}
 
-	rkisp_disable_sys_clk(isp_dev);
-	ret = pinctrl_pm_select_sleep_state(dev);
-
-	return ret;
+	if (atomic_dec_return(&isp_dev->hw_dev->power_cnt))
+		return 0;
+	return pm_runtime_put(isp_dev->hw_dev->dev);
 }
 
 static int __maybe_unused rkisp_runtime_resume(struct device *dev)
 {
 	struct rkisp_device *isp_dev = dev_get_drvdata(dev);
-	int ret;
-
-	ret = pinctrl_pm_select_default_state(dev);
-	if (ret < 0)
-		return ret;
-	rkisp_enable_sys_clk(isp_dev);
-
-	if (isp_dev->isp_ver == ISP_V12 || isp_dev->isp_ver == ISP_V13) {
-		writel(0, isp_dev->base_addr + CIF_ISP_CSI0_MASK1);
-		writel(0, isp_dev->base_addr + CIF_ISP_CSI0_MASK2);
-		writel(0, isp_dev->base_addr + CIF_ISP_CSI0_MASK3);
-		if (isp_dev->mipi_irq >= 0)
-			enable_irq(isp_dev->mipi_irq);
-	}
 
-	return 0;
+	if (atomic_inc_return(&isp_dev->hw_dev->power_cnt) > 1)
+		return 0;
+	return pm_runtime_get_sync(isp_dev->hw_dev->dev);
 }
 
 #ifndef MODULE
@@ -1277,7 +797,14 @@ static const struct dev_pm_ops rkisp_plat_pm_ops = {
 	SET_RUNTIME_PM_OPS(rkisp_runtime_suspend, rkisp_runtime_resume, NULL)
 };
 
-static struct platform_driver rkisp_plat_drv = {
+static const struct of_device_id rkisp_plat_of_match[] = {
+	{
+		.compatible = "rockchip,rv1126-rkisp-vir",
+	},
+	{},
+};
+
+struct platform_driver rkisp_plat_drv = {
 	.driver = {
 		   .name = DRIVER_NAME,
 		   .of_match_table = of_match_ptr(rkisp_plat_of_match),
@@ -1287,21 +814,6 @@ static struct platform_driver rkisp_plat_drv = {
 	.remove = rkisp_plat_remove,
 };
 
-#if IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISP) && IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISPP)
-static int __init rkisp_plat_drv_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&rkisp_plat_drv);
-	if (ret)
-		return ret;
-	return rkispp_plat_drv_init();
-}
-
-module_init(rkisp_plat_drv_init);
-#else
-module_platform_driver(rkisp_plat_drv);
-#endif
 MODULE_AUTHOR("Rockchip Camera/ISP team");
 MODULE_DESCRIPTION("Rockchip ISP platform driver");
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/media/platform/rockchip/isp/dev.h b/drivers/media/platform/rockchip/isp/dev.h
index 59d99d8f1203..72c8e1946e93 100644
--- a/drivers/media/platform/rockchip/isp/dev.h
+++ b/drivers/media/platform/rockchip/isp/dev.h
@@ -39,6 +39,7 @@
 #include "csi.h"
 #include "dmarx.h"
 #include "bridge.h"
+#include "hw.h"
 #include "rkisp.h"
 #include "isp_params.h"
 #include "isp_stats.h"
@@ -67,7 +68,6 @@
 #define GRP_ID_ISP_BRIDGE		BIT(6)
 #define GRP_ID_CSI			BIT(7)
 
-#define RKISP_MAX_BUS_CLK		8
 #define RKISP_MAX_SENSOR		2
 #define RKISP_MAX_PIPELINE		4
 
@@ -76,16 +76,6 @@
 
 #define RKISP_CONTI_ERR_MAX		50
 
-/* ISP_V10_1 for only support MP */
-enum rkisp_isp_ver {
-	ISP_V10 = 0x00,
-	ISP_V10_1 = 0x01,
-	ISP_V11 = 0x10,
-	ISP_V12 = 0x20,
-	ISP_V13 = 0x30,
-	ISP_V20 = 0x40,
-};
-
 enum rkisp_isp_state {
 	ISP_FRAME_END = BIT(0),
 	ISP_FRAME_IN = BIT(1),
@@ -176,12 +166,11 @@ struct rkisp_hdr {
  */
 struct rkisp_device {
 	struct list_head list;
-	struct regmap *grf;
 	void __iomem *base_addr;
-	int irq;
 	struct device *dev;
-	struct clk *clks[RKISP_MAX_BUS_CLK];
-	int num_clks;
+	char name[128];
+	void *sw_base_addr;
+	struct rkisp_hw_dev *hw_dev;
 	struct v4l2_device v4l2_dev;
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct media_device media_dev;
@@ -199,16 +188,12 @@ struct rkisp_device {
 	struct rkisp_bridge_device br_dev;
 	struct rkisp_luma_vdev luma_vdev;
 	struct rkisp_pipeline pipe;
-	struct iommu_domain *domain;
 	enum rkisp_isp_ver isp_ver;
-	const unsigned int *clk_rate_tbl;
-	int num_clk_rate_tbl;
 	struct rkisp_emd_data emd_data_fifo[RKISP_EMDDATA_FIFO_MAX];
 	unsigned int emd_data_idx;
 	unsigned int emd_vc;
 	unsigned int emd_dt;
 	int vs_irq;
-	int mipi_irq;
 	struct gpio_desc *vs_irq_gpio;
 	struct rkisp_hdr hdr;
 	enum rkisp_isp_state isp_state;
@@ -217,14 +202,8 @@ struct rkisp_device {
 	struct mutex apilock; /* mutex to serialize the calls of stream */
 	struct mutex iqlock; /* mutex to serialize the calls of iq */
 	wait_queue_head_t sync_onoff;
-
-	const struct isp_match_data *match_data;
-	struct platform_device *pdev;
 	phys_addr_t resmem_pa;
 	size_t resmem_size;
-	bool is_thunderboot;
+	int dev_id;
 };
-
-int rkisp_register_irq(struct rkisp_device *isp_dev);
-
 #endif
diff --git a/drivers/media/platform/rockchip/isp/dmarx.c b/drivers/media/platform/rockchip/isp/dmarx.c
index 37aa744f8420..1db095d00fb4 100644
--- a/drivers/media/platform/rockchip/isp/dmarx.c
+++ b/drivers/media/platform/rockchip/isp/dmarx.c
@@ -294,39 +294,39 @@ static struct streams_ops rkisp_dmarx_streams_ops = {
 static int rawrd_config_mi(struct rkisp_stream *stream)
 {
 	struct rkisp_device *dev = stream->ispdev;
-	void __iomem *base = dev->base_addr;
 	u32 val;
 
-	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
-		 "%s id:%d %dx%d\n", __func__,
-		 stream->id,
-		 stream->out_fmt.width,
-		 stream->out_fmt.height);
-
+	val = rkisp_read(dev, CSI2RX_DATA_IDS_1, true);
+	val &= ~SW_CSI_ID0(0xff);
 	switch (stream->out_isp_fmt.fourcc) {
 	case V4L2_PIX_FMT_SRGGB8:
 	case V4L2_PIX_FMT_SBGGR8:
 	case V4L2_PIX_FMT_SGRBG8:
 	case V4L2_PIX_FMT_SGBRG8:
 	case V4L2_PIX_FMT_GREY:
-		val = CIF_CSI2_DT_RAW8;
+		val |= CIF_CSI2_DT_RAW8;
 		break;
 	case V4L2_PIX_FMT_SRGGB10:
 	case V4L2_PIX_FMT_SBGGR10:
 	case V4L2_PIX_FMT_SGRBG10:
 	case V4L2_PIX_FMT_SGBRG10:
 	case V4L2_PIX_FMT_Y10:
-		val = CIF_CSI2_DT_RAW10;
+		val |= CIF_CSI2_DT_RAW10;
 		break;
 	default:
-		val = CIF_CSI2_DT_RAW12;
+		val |= CIF_CSI2_DT_RAW12;
 	}
-	isp_set_bits(base + CSI2RX_DATA_IDS_1,
-		     SW_CSI_ID0(0xff), SW_CSI_ID0(val));
+	rkisp_write(dev, CSI2RX_DATA_IDS_1, val, false);
 	raw_rd_set_pic_size(stream);
-	isp_set_bits(base + CSI2RX_RAW_RD_CTRL, 0,
-		     dev->csi_dev.memory << 2 |
-		     1 << (stream->id - 1));
+	rkisp_set_bits(dev, CSI2RX_RAW_RD_CTRL, 0,
+		       dev->csi_dev.memory << 2 |
+		       1 << (stream->id - 1), true);
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s id:%d 0x%x %dx%d\n", __func__,
+		 stream->id, val,
+		 stream->out_fmt.width,
+		 stream->out_fmt.height);
 	return 0;
 }
 
@@ -336,8 +336,9 @@ static void update_rawrd(struct rkisp_stream *stream)
 	void __iomem *base = dev->base_addr;
 
 	if (stream->curr_buf) {
-		mi_set_y_addr(stream,
-			stream->curr_buf->buff_addr[RKISP_PLANE_Y]);
+		rkisp_write(dev, stream->config->mi.y_base_ad_init,
+			    stream->curr_buf->buff_addr[RKISP_PLANE_Y],
+			    false);
 		stream->frame_end = false;
 	} else if (dev->dmarx_dev.trigger == T_AUTO) {
 		/* internal raw wr/rd buf rotate */
@@ -373,17 +374,8 @@ static void update_rawrd(struct rkisp_stream *stream)
 	}
 }
 
-static void rawrd_stop_mi(struct rkisp_stream *stream)
-{
-	void __iomem *base = &stream->ispdev->base_addr;
-
-	isp_clear_bits(base + CSI2RX_RAW_RD_CTRL,
-		       1 << (stream->id - 1));
-}
-
 static struct streams_ops rkisp2_dmarx_streams_ops = {
 	.config_mi = rawrd_config_mi,
-	.stop_mi = rawrd_stop_mi,
 	.update_mi = update_rawrd,
 };
 
@@ -613,7 +605,7 @@ static int rkisp_init_vb2_queue(struct vb2_queue *q,
 	q->min_buffers_needed = CIF_ISP_REQ_BUFS_MIN;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 	q->lock = &stream->ispdev->apilock;
-	q->dev = stream->ispdev->dev;
+	q->dev = stream->ispdev->hw_dev->dev;
 
 	return vb2_queue_init(q);
 }
diff --git a/drivers/media/platform/rockchip/isp/hw.c b/drivers/media/platform/rockchip/isp/hw.c
new file mode 100644
index 000000000000..4566b64f73ae
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/hw.c
@@ -0,0 +1,729 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2020 Rockchip Electronics Co., Ltd */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pm_runtime.h>
+
+#include "common.h"
+#include "dev.h"
+#include "hw.h"
+#include "regs.h"
+
+/*
+ * rkisp_hw share hardware resource with rkisp virtual device
+ * rkisp_device rkisp_device rkisp_device rkisp_device
+ *      |            |            |            |
+ *      \            |            |            /
+ *       --------------------------------------
+ *                         |
+ *                     rkisp_hw
+ */
+
+struct isp_irqs_data {
+	const char *name;
+	irqreturn_t (*irq_hdl)(int irq, void *ctx);
+};
+
+struct isp_match_data {
+	const char * const *clks;
+	int num_clks;
+	enum rkisp_isp_ver isp_ver;
+	const unsigned int *clk_rate_tbl;
+	int num_clk_rate_tbl;
+	struct isp_irqs_data *irqs;
+	int num_irqs;
+};
+
+/* using default value if reg no write for multi device */
+static void default_sw_reg_flag(struct rkisp_device *dev)
+{
+	u32 reg[] = {
+		CTRL_VI_ISP_PATH,
+		IMG_EFF_CTRL,
+		SUPER_IMP_CTRL,
+		ISP_FLASH_CMD,
+		ISP_SHUTTER_CTRL,
+		ISP_CCM_CTRL,
+		CPROC_CTRL,
+		DUAL_CROP_CTRL,
+		ISP_GAMMA_OUT_CTRL,
+		ISP_GAMMA_OUT_CTRL,
+		ISP_LSC_CTRL,
+		ISP_DEBAYER_CONTROL,
+		ISP_WDR_CTRL,
+		ISP_GIC_CONTROL,
+		ISP_BLS_CTRL,
+		ISP_DPCC0_MODE,
+		ISP_DPCC1_MODE,
+		ISP_DPCC2_MODE,
+		ISP_HDRMGE_CTRL,
+		ISP_HDRTMO_CTRL,
+		ISP_RAWNR_CTRL,
+		ISP_LDCH_STS,
+		ISP_DHAZ_CTRL,
+		ISP_3DLUT_CTRL,
+		ISP_GAIN_CTRL,
+		ISP_AFM_CTRL,
+		ISP_HIST_HIST_CTRL,
+		RAWAE_BIG1_BASE,
+		RAWAE_BIG2_BASE,
+		RAWAE_BIG3_BASE,
+		ISP_RAWAE_LITE_CTRL,
+		ISP_RAWHIST_LITE_CTRL,
+		ISP_RAWHIST_BIG1_BASE,
+		ISP_RAWHIST_BIG2_BASE,
+		ISP_RAWHIST_BIG3_BASE,
+		ISP_YUVAE_CTRL,
+		ISP_RAWAF_CTRL,
+		ISP_RAWAWB_CTRL,
+	};
+	u32 i, *flag;
+
+	for (i = 0; i < ARRAY_SIZE(reg); i++) {
+		flag = dev->sw_base_addr + reg[i] + ISP_SW_REG_SIZE;
+		*flag = SW_REG_CACHE;
+	}
+}
+
+static irqreturn_t mipi_irq_hdl(int irq, void *ctx)
+{
+	struct device *dev = ctx;
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+	struct rkisp_device *isp = hw_dev->isp[hw_dev->mipi_dev_id];
+
+	if (hw_dev->is_thunderboot)
+		return IRQ_HANDLED;
+
+	if (hw_dev->isp_ver == ISP_V13 || hw_dev->isp_ver == ISP_V12) {
+		u32 err1, err2, err3;
+
+		err1 = readl(hw_dev->base_addr + CIF_ISP_CSI0_ERR1);
+		err2 = readl(hw_dev->base_addr + CIF_ISP_CSI0_ERR2);
+		err3 = readl(hw_dev->base_addr + CIF_ISP_CSI0_ERR3);
+
+		if (err3 & 0xf)
+			rkisp_mipi_dmatx0_end(err3, isp);
+		if (err1 || err2 || err3)
+			rkisp_mipi_v13_isr(err1, err2, err3, isp);
+	} else if (hw_dev->isp_ver == ISP_V20) {
+		u32 phy, packet, overflow, state;
+
+		state = readl(hw_dev->base_addr + CSI2RX_ERR_STAT);
+		phy = readl(hw_dev->base_addr + CSI2RX_ERR_PHY);
+		packet = readl(hw_dev->base_addr + CSI2RX_ERR_PACKET);
+		overflow = readl(hw_dev->base_addr + CSI2RX_ERR_OVERFLOW);
+		if (phy | packet | overflow | state)
+			rkisp_mipi_v20_isr(phy, packet, overflow, state, isp);
+	} else {
+		u32 mis_val = readl(hw_dev->base_addr + CIF_MIPI_MIS);
+
+		if (mis_val)
+			rkisp_mipi_isr(mis_val, isp);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mi_irq_hdl(int irq, void *ctx)
+{
+	struct device *dev = ctx;
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+	struct rkisp_device *isp = hw_dev->isp[hw_dev->cur_dev_id];
+	u32 mis_val, tx_isr = MI_RAW0_WR_FRAME | MI_RAW1_WR_FRAME |
+		MI_RAW2_WR_FRAME | MI_RAW3_WR_FRAME;
+
+	if (hw_dev->is_thunderboot)
+		return IRQ_HANDLED;
+
+	mis_val = readl(hw_dev->base_addr + CIF_MI_MIS);
+	if (mis_val) {
+		if (mis_val & ~tx_isr)
+			rkisp_mi_isr(mis_val & ~tx_isr, isp);
+		if (mis_val & tx_isr) {
+			isp = hw_dev->isp[hw_dev->mipi_dev_id];
+			rkisp_mi_isr(mis_val & tx_isr, isp);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t isp_irq_hdl(int irq, void *ctx)
+{
+	struct device *dev = ctx;
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+	struct rkisp_device *isp = hw_dev->isp[hw_dev->cur_dev_id];
+	unsigned int mis_val, mis_3a = 0;
+
+	if (hw_dev->is_thunderboot)
+		return IRQ_HANDLED;
+
+	mis_val = readl(hw_dev->base_addr + CIF_ISP_MIS);
+	if (hw_dev->isp_ver == ISP_V20)
+		mis_3a = readl(hw_dev->base_addr + ISP_ISP3A_MIS);
+	if (mis_val || mis_3a)
+		rkisp_isp_isr(mis_val, mis_3a, isp);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_handler(int irq, void *ctx)
+{
+	struct device *dev = ctx;
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+	struct rkisp_device *isp = hw_dev->isp[hw_dev->cur_dev_id];
+	unsigned int mis_val, mis_3a = 0;
+
+	mis_val = readl(hw_dev->base_addr + CIF_ISP_MIS);
+	if (hw_dev->isp_ver == ISP_V20)
+		mis_3a = readl(hw_dev->base_addr + ISP_ISP3A_MIS);
+	if (mis_val || mis_3a)
+		rkisp_isp_isr(mis_val, mis_3a, isp);
+
+	mis_val = readl(hw_dev->base_addr + CIF_MIPI_MIS);
+	if (mis_val)
+		rkisp_mipi_isr(mis_val, isp);
+
+	mis_val = readl(hw_dev->base_addr + CIF_MI_MIS);
+	if (mis_val)
+		rkisp_mi_isr(mis_val, isp);
+
+	return IRQ_HANDLED;
+}
+
+int rkisp_register_irq(struct rkisp_hw_dev *hw_dev)
+{
+	const struct isp_match_data *match_data = hw_dev->match_data;
+	struct platform_device *pdev = hw_dev->pdev;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int i, ret, irq;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,
+					   match_data->irqs[0].name);
+	if (res) {
+		/* there are irq names in dts */
+		for (i = 0; i < match_data->num_irqs; i++) {
+			irq = platform_get_irq_byname(pdev, match_data->irqs[i].name);
+			if (irq < 0) {
+				dev_err(dev, "no irq %s in dts\n",
+					match_data->irqs[i].name);
+				return irq;
+			}
+
+			if (!strcmp(match_data->irqs[i].name, "mipi_irq"))
+				hw_dev->mipi_irq = irq;
+
+			ret = devm_request_irq(dev, irq,
+					       match_data->irqs[i].irq_hdl,
+					       IRQF_SHARED,
+					       dev_driver_string(dev),
+					       dev);
+			if (ret < 0) {
+				dev_err(dev, "request %s failed: %d\n",
+					match_data->irqs[i].name, ret);
+				return ret;
+			}
+
+			if (hw_dev->mipi_irq == irq &&
+			    (hw_dev->isp_ver == ISP_V12 ||
+			     hw_dev->isp_ver == ISP_V13))
+				disable_irq(hw_dev->mipi_irq);
+		}
+	} else {
+		/* no irq names in dts */
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0) {
+			dev_err(dev, "no isp irq in dts\n");
+			return irq;
+		}
+
+		ret = devm_request_irq(dev, irq,
+				       irq_handler,
+				       IRQF_SHARED,
+				       dev_driver_string(dev),
+				       dev);
+		if (ret < 0) {
+			dev_err(dev, "request irq failed: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static const char * const rk1808_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+	"pclk_isp",
+};
+
+static const char * const rk3288_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+	"pclk_isp_in",
+	"sclk_isp_jpe",
+};
+
+static const char * const rk3326_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+	"pclk_isp",
+};
+
+static const char * const rk3368_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+	"pclk_isp",
+};
+
+static const char * const rk3399_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+	"aclk_isp_wrap",
+	"hclk_isp_wrap",
+	"pclk_isp_wrap"
+};
+
+static const char * const rv1126_isp_clks[] = {
+	"clk_isp",
+	"aclk_isp",
+	"hclk_isp",
+};
+
+/* isp clock adjustment table (MHz) */
+static const unsigned int rk1808_isp_clk_rate[] = {
+	300, 400, 500, 600
+};
+
+/* isp clock adjustment table (MHz) */
+static const unsigned int rk3288_isp_clk_rate[] = {
+	150, 384, 500, 594
+};
+
+/* isp clock adjustment table (MHz) */
+static const unsigned int rk3326_isp_clk_rate[] = {
+	300, 347, 400, 520, 600
+};
+
+/* isp clock adjustment table (MHz) */
+static const unsigned int rk3368_isp_clk_rate[] = {
+	300, 400, 600
+};
+
+/* isp clock adjustment table (MHz) */
+static const unsigned int rk3399_isp_clk_rate[] = {
+	300, 400, 600
+};
+
+static const unsigned int rv1126_isp_clk_rate[] = {
+	400, 500
+};
+
+static struct isp_irqs_data rk1808_isp_irqs[] = {
+	{"isp_irq", isp_irq_hdl},
+	{"mi_irq", mi_irq_hdl},
+	{"mipi_irq", mipi_irq_hdl}
+};
+
+static struct isp_irqs_data rk3288_isp_irqs[] = {
+	{"isp_irq", irq_handler}
+};
+
+static struct isp_irqs_data rk3326_isp_irqs[] = {
+	{"isp_irq", isp_irq_hdl},
+	{"mi_irq", mi_irq_hdl},
+	{"mipi_irq", mipi_irq_hdl}
+};
+
+static struct isp_irqs_data rk3368_isp_irqs[] = {
+	{"isp_irq", irq_handler}
+};
+
+static struct isp_irqs_data rk3399_isp_irqs[] = {
+	{"isp_irq", irq_handler}
+};
+
+static struct isp_irqs_data rv1126_isp_irqs[] = {
+	{"isp_irq", isp_irq_hdl},
+	{"mi_irq", mi_irq_hdl},
+	{"mipi_irq", mipi_irq_hdl}
+};
+
+static const struct isp_match_data rv1126_isp_match_data = {
+	.clks = rv1126_isp_clks,
+	.num_clks = ARRAY_SIZE(rv1126_isp_clks),
+	.isp_ver = ISP_V20,
+	.clk_rate_tbl = rv1126_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rv1126_isp_clk_rate),
+	.irqs = rv1126_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rv1126_isp_irqs)
+};
+
+static const struct isp_match_data rk1808_isp_match_data = {
+	.clks = rk1808_isp_clks,
+	.num_clks = ARRAY_SIZE(rk1808_isp_clks),
+	.isp_ver = ISP_V13,
+	.clk_rate_tbl = rk1808_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rk1808_isp_clk_rate),
+	.irqs = rk1808_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rk1808_isp_irqs)
+};
+
+static const struct isp_match_data rk3288_isp_match_data = {
+	.clks = rk3288_isp_clks,
+	.num_clks = ARRAY_SIZE(rk3288_isp_clks),
+	.isp_ver = ISP_V10,
+	.clk_rate_tbl = rk3288_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rk3288_isp_clk_rate),
+	.irqs = rk3288_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rk3288_isp_irqs)
+};
+
+static const struct isp_match_data rk3326_isp_match_data = {
+	.clks = rk3326_isp_clks,
+	.num_clks = ARRAY_SIZE(rk3326_isp_clks),
+	.isp_ver = ISP_V12,
+	.clk_rate_tbl = rk3326_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rk3326_isp_clk_rate),
+	.irqs = rk3326_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rk3326_isp_irqs)
+};
+
+static const struct isp_match_data rk3368_isp_match_data = {
+	.clks = rk3368_isp_clks,
+	.num_clks = ARRAY_SIZE(rk3368_isp_clks),
+	.isp_ver = ISP_V10_1,
+	.clk_rate_tbl = rk3368_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rk3368_isp_clk_rate),
+	.irqs = rk3368_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rk3368_isp_irqs)
+};
+
+static const struct isp_match_data rk3399_isp_match_data = {
+	.clks = rk3399_isp_clks,
+	.num_clks = ARRAY_SIZE(rk3399_isp_clks),
+	.isp_ver = ISP_V10,
+	.clk_rate_tbl = rk3399_isp_clk_rate,
+	.num_clk_rate_tbl = ARRAY_SIZE(rk3399_isp_clk_rate),
+	.irqs = rk3399_isp_irqs,
+	.num_irqs = ARRAY_SIZE(rk3399_isp_irqs)
+};
+
+static const struct of_device_id rkisp_hw_of_match[] = {
+	{
+		.compatible = "rockchip,rk1808-rkisp1",
+		.data = &rk1808_isp_match_data,
+	}, {
+		.compatible = "rockchip,rk3288-rkisp1",
+		.data = &rk3288_isp_match_data,
+	}, {
+		.compatible = "rockchip,rk3326-rkisp1",
+		.data = &rk3326_isp_match_data,
+	}, {
+		.compatible = "rockchip,rk3368-rkisp1",
+		.data = &rk3368_isp_match_data,
+	}, {
+		.compatible = "rockchip,rk3399-rkisp1",
+		.data = &rk3399_isp_match_data,
+	}, {
+		.compatible = "rockchip,rv1126-rkisp",
+		.data = &rv1126_isp_match_data,
+	},
+	{},
+};
+
+static inline bool is_iommu_enable(struct device *dev)
+{
+	struct device_node *iommu;
+
+	iommu = of_parse_phandle(dev->of_node, "iommus", 0);
+	if (!iommu) {
+		dev_info(dev, "no iommu attached, using non-iommu buffers\n");
+		return false;
+	} else if (!of_device_is_available(iommu)) {
+		dev_info(dev, "iommu is disabled, using non-iommu buffers\n");
+		of_node_put(iommu);
+		return false;
+	}
+	of_node_put(iommu);
+
+	return true;
+}
+
+static void isp_soft_reset(struct rkisp_hw_dev *dev)
+{
+	void __iomem *base = dev->base_addr;
+	struct iommu_domain *domain = iommu_get_domain_for_dev(dev->dev);
+
+	writel(CIF_ISP_CTRL_ISP_MODE_BAYER_ITU601, base + CIF_ISP_CTRL);
+	writel(0xffff, base + CIF_IRCL);
+	usleep_range(100, 200);
+	if (domain) {
+#ifdef CONFIG_IOMMU_API
+		domain->ops->detach_dev(domain, dev->dev);
+		domain->ops->attach_dev(domain, dev->dev);
+#endif
+	}
+}
+
+static void isp_config_clk(struct rkisp_hw_dev *dev, int on)
+{
+	u32 val = !on ? 0 :
+		CIF_ICCL_ISP_CLK | CIF_ICCL_CP_CLK | CIF_ICCL_MRSZ_CLK |
+		CIF_ICCL_SRSZ_CLK | CIF_ICCL_JPEG_CLK | CIF_ICCL_MI_CLK |
+		CIF_ICCL_IE_CLK | CIF_ICCL_MIPI_CLK | CIF_ICCL_DCROP_CLK;
+
+	if (dev->isp_ver == ISP_V20 && on)
+		val |= ICCL_MPFBC_CLK;
+
+	writel(val, dev->base_addr + CIF_ICCL);
+
+	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
+		val = !on ? 0 :
+		      CIF_CLK_CTRL_MI_Y12 | CIF_CLK_CTRL_MI_SP |
+		      CIF_CLK_CTRL_MI_RAW0 | CIF_CLK_CTRL_MI_RAW1 |
+		      CIF_CLK_CTRL_MI_READ | CIF_CLK_CTRL_MI_RAWRD |
+		      CIF_CLK_CTRL_CP | CIF_CLK_CTRL_IE;
+
+		writel(val, dev->base_addr + CIF_VI_ISP_CLK_CTRL_V12);
+	} else if (dev->isp_ver == ISP_V20) {
+		val = !on ? 0 :
+		      CLK_CTRL_MI_LDC | CLK_CTRL_MI_MP |
+		      CLK_CTRL_MI_JPEG | CLK_CTRL_MI_DP |
+		      CLK_CTRL_MI_Y12 | CLK_CTRL_MI_SP |
+		      CLK_CTRL_MI_RAW0 | CLK_CTRL_MI_RAW1 |
+		      CLK_CTRL_MI_READ | CLK_CTRL_MI_RAWRD |
+		      CLK_CTRL_ISP_3A | CLK_CTRL_ISP_RAW;
+		writel(val, dev->base_addr + CTRL_VI_ISP_CLK_CTRL);
+	}
+}
+
+static void disable_sys_clk(struct rkisp_hw_dev *dev)
+{
+	int i;
+
+	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
+		if (dev->mipi_irq >= 0)
+			disable_irq(dev->mipi_irq);
+	}
+
+	if (!dev->is_thunderboot)
+		isp_config_clk(dev, false);
+
+	for (i = dev->num_clks - 1; i >= 0; i--)
+		if (!IS_ERR(dev->clks[i]))
+			clk_disable_unprepare(dev->clks[i]);
+}
+
+static int enable_sys_clk(struct rkisp_hw_dev *dev)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < dev->num_clks; i++) {
+		if (!IS_ERR(dev->clks[i])) {
+			ret = clk_prepare_enable(dev->clks[i]);
+			if (ret < 0)
+				goto err;
+		}
+	}
+
+	if (!dev->is_single)
+		clk_set_rate(dev->clks[0], 500 * 1000000UL);
+
+	if (!dev->is_thunderboot) {
+		isp_soft_reset(dev);
+		isp_config_clk(dev, true);
+	}
+
+	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
+		/* disable csi_rx interrupt */
+		writel(0, dev->base_addr + CIF_ISP_CSI0_CTRL0);
+		writel(0, dev->base_addr + CIF_ISP_CSI0_MASK1);
+		writel(0, dev->base_addr + CIF_ISP_CSI0_MASK2);
+		writel(0, dev->base_addr + CIF_ISP_CSI0_MASK3);
+	}
+
+	return 0;
+err:
+	for (--i; i >= 0; --i)
+		if (!IS_ERR(dev->clks[i]))
+			clk_disable_unprepare(dev->clks[i]);
+	return ret;
+}
+
+static int rkisp_hw_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	const struct isp_match_data *match_data;
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct rkisp_hw_dev *hw_dev;
+	struct resource *res;
+	int i, ret;
+
+	match = of_match_node(rkisp_hw_of_match, node);
+	if (IS_ERR(match))
+		return PTR_ERR(match);
+
+	hw_dev = devm_kzalloc(dev, sizeof(*hw_dev), GFP_KERNEL);
+	if (!hw_dev)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, hw_dev);
+	hw_dev->dev = dev;
+	hw_dev->is_thunderboot = IS_ENABLED(CONFIG_VIDEO_ROCKCHIP_THUNDER_BOOT_ISP);
+	dev_info(dev, "is_thunderboot: %d\n", hw_dev->is_thunderboot);
+
+	hw_dev->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+	if (IS_ERR(hw_dev->grf))
+		dev_warn(dev, "Missing rockchip,grf property\n");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "get resource failed\n");
+		ret = -EINVAL;
+		goto err;
+	}
+	hw_dev->base_addr = devm_ioremap_resource(dev, res);
+	if (PTR_ERR(hw_dev->base_addr) == -EBUSY) {
+		resource_size_t offset = res->start;
+		resource_size_t size = resource_size(res);
+
+		hw_dev->base_addr = devm_ioremap(dev, offset, size);
+	}
+	if (IS_ERR(hw_dev->base_addr)) {
+		dev_err(dev, "ioremap failed\n");
+		ret = PTR_ERR(hw_dev->base_addr);
+		goto err;
+	}
+
+	match_data = match->data;
+	hw_dev->mipi_irq = -1;
+
+	hw_dev->pdev = pdev;
+	hw_dev->match_data = match_data;
+	if (!hw_dev->is_thunderboot)
+		rkisp_register_irq(hw_dev);
+
+	for (i = 0; i < match_data->num_clks; i++) {
+		struct clk *clk = devm_clk_get(dev, match_data->clks[i]);
+
+		if (IS_ERR(clk))
+			dev_dbg(dev, "failed to get %s\n", match_data->clks[i]);
+		hw_dev->clks[i] = clk;
+	}
+	hw_dev->num_clks = match_data->num_clks;
+	hw_dev->clk_rate_tbl = match_data->clk_rate_tbl;
+	hw_dev->num_clk_rate_tbl = match_data->num_clk_rate_tbl;
+
+	hw_dev->dev_num = 0;
+	hw_dev->cur_dev_id = 0;
+	hw_dev->mipi_dev_id = 0;
+	hw_dev->isp_ver = match_data->isp_ver;
+	spin_lock_init(&hw_dev->rdbk_lock);
+	atomic_set(&hw_dev->refcnt, 0);
+	atomic_set(&hw_dev->power_cnt, 0);
+	spin_lock_init(&hw_dev->buf_lock);
+	INIT_LIST_HEAD(&hw_dev->list);
+	hw_dev->is_idle = true;
+	hw_dev->is_single = true;
+	hw_dev->is_mi_update = false;
+	if (!is_iommu_enable(dev)) {
+		ret = of_reserved_mem_device_init(dev);
+		if (ret) {
+			dev_err(dev, "No reserved memory region\n");
+			goto err;
+		}
+	}
+
+	pm_runtime_enable(dev);
+
+	return platform_driver_register(&rkisp_plat_drv);
+err:
+	return ret;
+}
+
+static int rkisp_hw_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+static int __maybe_unused rkisp_runtime_suspend(struct device *dev)
+{
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+
+	disable_sys_clk(hw_dev);
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused rkisp_runtime_resume(struct device *dev)
+{
+	struct rkisp_hw_dev *hw_dev = dev_get_drvdata(dev);
+	void __iomem *base = hw_dev->base_addr;
+	int ret, i;
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret < 0)
+		return ret;
+
+	enable_sys_clk(hw_dev);
+
+	for (i = 0; i < hw_dev->dev_num; i++) {
+		void *buf = hw_dev->isp[i]->sw_base_addr;
+
+		memset(buf, 0, ISP_SW_MAX_SIZE);
+		memcpy_fromio(buf, base, ISP_SW_REG_SIZE);
+		default_sw_reg_flag(hw_dev->isp[i]);
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops rkisp_hw_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(rkisp_runtime_suspend,
+			   rkisp_runtime_resume, NULL)
+};
+
+static struct platform_driver rkisp_hw_drv = {
+	.driver = {
+		.name = "rkisp_hw",
+		.of_match_table = of_match_ptr(rkisp_hw_of_match),
+		.pm = &rkisp_hw_pm_ops,
+	},
+	.probe = rkisp_hw_probe,
+	.remove = rkisp_hw_remove,
+};
+
+#if IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISP) && IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISPP)
+static int __init rkisp_hw_drv_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&rkisp_hw_drv);
+	if (ret)
+		return ret;
+	return rkispp_plat_drv_init();
+}
+
+module_init(rkisp_hw_drv_init);
+#else
+module_platform_driver(rkisp_hw_drv);
+#endif
diff --git a/drivers/media/platform/rockchip/isp/hw.h b/drivers/media/platform/rockchip/isp/hw.h
new file mode 100644
index 000000000000..e37654ecea1b
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/hw.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Rockchip Electronics Co., Ltd. */
+
+#ifndef _RKISP_HW_H
+#define _RKISP_HW_H
+
+#include "bridge.h"
+
+#define RKISP_MAX_BUS_CLK 8
+
+struct rkisp_hw_dev {
+	const struct isp_match_data *match_data;
+	struct platform_device *pdev;
+	struct device *dev;
+	struct regmap *grf;
+	void __iomem *base_addr;
+	struct clk *clks[RKISP_MAX_BUS_CLK];
+	int num_clks;
+	const unsigned int *clk_rate_tbl;
+	int num_clk_rate_tbl;
+	int mipi_irq;
+	enum rkisp_isp_ver isp_ver;
+	struct rkisp_device *isp[DEV_MAX];
+	int dev_num;
+	int cur_dev_id;
+	int mipi_dev_id;
+	struct max_input max_in;
+	/* lock for multi dev */
+	struct mutex dev_lock;
+	spinlock_t rdbk_lock;
+	atomic_t power_cnt;
+	atomic_t refcnt;
+
+	/* share buf for multi dev */
+	spinlock_t buf_lock;
+	struct rkisp_bridge_buf bufs[BRIDGE_BUF_MAX];
+	struct rkisp_ispp_buf *cur_buf;
+	struct rkisp_ispp_buf *nxt_buf;
+	struct list_head list;
+
+	bool is_idle;
+	bool is_single;
+	bool is_mi_update;
+	bool is_thunderboot;
+};
+
+int rkisp_register_irq(struct rkisp_hw_dev *dev);
+#endif
diff --git a/drivers/media/platform/rockchip/isp/isp_ispp.h b/drivers/media/platform/rockchip/isp/isp_ispp.h
index 0b24acc228ab..65740787ce5b 100644
--- a/drivers/media/platform/rockchip/isp/isp_ispp.h
+++ b/drivers/media/platform/rockchip/isp/isp_ispp.h
@@ -7,10 +7,25 @@
 #include <linux/platform_device.h>
 #include <media/v4l2-subdev.h>
 
-#define RKISP_ISPP_BUF_MAX 4
+#define RKISPP_BUF_MAX 3
+#define RKISP_ISPP_BUF_MAX (RKISPP_BUF_MAX + (2 * DEV_MAX))
+
 #define RKISP_ISPP_CMD_SET_MODE \
 	_IOW('V', BASE_VIDIOC_PRIVATE + 0, struct rkisp_ispp_mode)
 
+enum rkisp_ispp_dev {
+	DEV_ID0 = 0,
+	DEV_ID1,
+	DEV_ID2,
+	DEV_ID3,
+	DEV_MAX,
+};
+
+enum rkisp_ispp_sw_reg {
+	SW_REG_CACHE = 0xffffffff,
+	SW_REG_CACHE_SYNC = 0xeeeeeeee,
+};
+
 enum rkisp_ispp_buf_group {
 	GROUP_BUF_PIC = 0,
 	GROUP_BUF_GAIN,
@@ -24,7 +39,14 @@ enum rkisp_ispp_work_mode {
 	ISP_ISPP_INIT_FAIL = BIT(7),
 };
 
+struct max_input {
+	u32 w;
+	u32 h;
+	u32 fps;
+};
+
 struct rkisp_ispp_mode {
+	struct max_input max_in;
 	u8 work_mode;
 	u8 buf_num;
 };
@@ -35,6 +57,7 @@ struct rkisp_ispp_buf {
 	/* timestamp in ns */
 	u64 frame_timestamp;
 	u32 frame_id;
+	u32 index;
 };
 
 #if IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISP) && IS_BUILTIN(CONFIG_VIDEO_ROCKCHIP_ISPP)
diff --git a/drivers/media/platform/rockchip/isp/isp_params_v2x.c b/drivers/media/platform/rockchip/isp/isp_params_v2x.c
index a78c3b2e83fc..744dd506b9f1 100644
--- a/drivers/media/platform/rockchip/isp/isp_params_v2x.c
+++ b/drivers/media/platform/rockchip/isp/isp_params_v2x.c
@@ -4286,7 +4286,7 @@ int rkisp_init_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 	for (i = 0; i < RKISP_PARAM_3DLUT_BUF_NUM; i++) {
 		priv_val->buf_3dlut[i].is_need_vaddr = true;
 		priv_val->buf_3dlut[i].size = RKISP_PARAM_3DLUT_BUF_SIZE;
-		ret = rkisp_alloc_buffer(dev, &priv_val->buf_3dlut[i]);
+		ret = rkisp_alloc_buffer(params_vdev->dev, &priv_val->buf_3dlut[i]);
 		if (ret) {
 			dev_err(dev, "can not alloc buffer\n");
 			goto err;
@@ -4297,7 +4297,7 @@ int rkisp_init_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 	for (i = 0; i < RKISP_PARAM_LSC_LUT_BUF_NUM; i++) {
 		priv_val->buf_lsclut[i].is_need_vaddr = true;
 		priv_val->buf_lsclut[i].size = RKISP_PARAM_LSC_LUT_BUF_SIZE;
-		ret = rkisp_alloc_buffer(dev, &priv_val->buf_lsclut[i]);
+		ret = rkisp_alloc_buffer(params_vdev->dev, &priv_val->buf_lsclut[i]);
 		if (ret) {
 			dev_err(dev, "can not alloc buffer\n");
 			goto err;
@@ -4308,7 +4308,7 @@ int rkisp_init_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 	for (i = 0; i < RKISP_PARAM_LDCH_BUF_NUM; i++) {
 		priv_val->buf_ldch[i].is_need_vaddr = true;
 		priv_val->buf_ldch[i].size = ISP2X_LDCH_MESH_XY_NUM * sizeof(u16);
-		ret = rkisp_alloc_buffer(dev, &priv_val->buf_ldch[i]);
+		ret = rkisp_alloc_buffer(params_vdev->dev, &priv_val->buf_ldch[i]);
 		if (ret) {
 			dev_err(dev, "can not alloc buffer\n");
 			goto err;
@@ -4328,13 +4328,13 @@ int rkisp_init_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 
 err:
 	for (i = 0; i < RKISP_PARAM_3DLUT_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_3dlut[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_3dlut[i]);
 
 	for (i = 0; i < RKISP_PARAM_LSC_LUT_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_lsclut[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_lsclut[i]);
 
 	for (i = 0; i < RKISP_PARAM_LDCH_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_ldch[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_ldch[i]);
 
 	vfree(params_vdev->isp2x_params);
 
@@ -4344,7 +4344,6 @@ int rkisp_init_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 void rkisp_uninit_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 {
 	struct rkisp_isp_params_val_v2x *priv_val;
-	struct device *dev = params_vdev->dev->dev;
 	int i;
 
 	priv_val = params_vdev->priv_val;
@@ -4352,13 +4351,13 @@ void rkisp_uninit_params_vdev_v2x(struct rkisp_isp_params_vdev *params_vdev)
 		return;
 
 	for (i = 0; i < RKISP_PARAM_3DLUT_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_3dlut[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_3dlut[i]);
 
 	for (i = 0; i < RKISP_PARAM_LSC_LUT_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_lsclut[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_lsclut[i]);
 
 	for (i = 0; i < RKISP_PARAM_LDCH_BUF_NUM; i++)
-		rkisp_free_buffer(dev, &priv_val->buf_ldch[i]);
+		rkisp_free_buffer(params_vdev->dev, &priv_val->buf_ldch[i]);
 
 	vfree(params_vdev->isp2x_params);
 
diff --git a/drivers/media/platform/rockchip/isp/isp_stats_v2x.c b/drivers/media/platform/rockchip/isp/isp_stats_v2x.c
index b2da1803448c..993e5e9a9b71 100644
--- a/drivers/media/platform/rockchip/isp/isp_stats_v2x.c
+++ b/drivers/media/platform/rockchip/isp/isp_stats_v2x.c
@@ -1502,7 +1502,7 @@ void rkisp_init_stats_vdev_v2x(struct rkisp_isp_stats_vdev *stats_vdev)
 		for (i = 0; i < RKISP_STATS_DDR_BUF_NUM; i++) {
 			stats_vdev->stats_buf[i].is_need_vaddr = true;
 			stats_vdev->stats_buf[i].size = RKISP_RD_STATS_BUF_SIZE;
-			rkisp_alloc_buffer(stats_vdev->dev->dev, &stats_vdev->stats_buf[i]);
+			rkisp_alloc_buffer(stats_vdev->dev, &stats_vdev->stats_buf[i]);
 		}
 	}
 #endif
@@ -1513,6 +1513,6 @@ void rkisp_uninit_stats_vdev_v2x(struct rkisp_isp_stats_vdev *stats_vdev)
 	int i;
 
 	for (i = 0; i < RKISP_STATS_DDR_BUF_NUM; i++)
-		rkisp_free_buffer(stats_vdev->dev->dev, &stats_vdev->stats_buf[i]);
+		rkisp_free_buffer(stats_vdev->dev, &stats_vdev->stats_buf[i]);
 }
 
diff --git a/drivers/media/platform/rockchip/isp/regs.h b/drivers/media/platform/rockchip/isp/regs.h
index 16f14eba7cbb..5c8a1b089615 100644
--- a/drivers/media/platform/rockchip/isp/regs.h
+++ b/drivers/media/platform/rockchip/isp/regs.h
@@ -1886,8 +1886,11 @@ static inline void sp_mi_ctrl_autoupdate_en(void __iomem *base)
 	writel(readl(addr) | CIF_MI_SP_AUTOUPDATE_ENABLE, addr);
 }
 
-static inline void force_cfg_update(void __iomem *base)
+static inline void force_cfg_update(struct rkisp_device *dev)
 {
+	void __iomem *base = dev->base_addr;
+
+	dev->hw_dev->is_mi_update = true;
 	writel(CIF_MI_INIT_SOFT_UPD, base + CIF_MI_INIT);
 }
 
diff --git a/drivers/media/platform/rockchip/isp/regs_v2x.h b/drivers/media/platform/rockchip/isp/regs_v2x.h
index c5c49a5a460b..b0d5e97022f9 100644
--- a/drivers/media/platform/rockchip/isp/regs_v2x.h
+++ b/drivers/media/platform/rockchip/isp/regs_v2x.h
@@ -3,8 +3,11 @@
  * Copyright (C) 2019 Rockchip Electronics Co., Ltd.
  */
 
-#ifndef _RKISP1_REGS_V2X_H
-#define _RKISP1_REGS_V2X_H
+#ifndef _RKISP_REGS_V2X_H
+#define _RKISP_REGS_V2X_H
+
+#define ISP_SW_REG_SIZE					0x6000
+#define ISP_SW_MAX_SIZE					(ISP_SW_REG_SIZE * 2)
 
 #define CTRL_BASE					0x00000000
 #define CTRL_VI_ISP_EN					(CTRL_BASE + 0x00000)
@@ -2114,7 +2117,7 @@ static inline void raw_rd_set_pic_size(struct rkisp_stream *stream)
 	u32 h = dev->isp_sdev.in_crop.top + dev->isp_sdev.in_crop.height;
 
 	/* rx height should equal to isp height + offset */
-	writel(h << 16 | w, dev->base_addr + CSI2RX_RAW_RD_PIC_SIZE);
+	rkisp_write(dev, CSI2RX_RAW_RD_PIC_SIZE, h << 16 | w, false);
 }
 
 static inline void raw_rd_ctrl(void __iomem *base, u32 val)
@@ -2122,4 +2125,4 @@ static inline void raw_rd_ctrl(void __iomem *base, u32 val)
 	writel(val, base + CSI2RX_RAW_RD_CTRL);
 }
 
-#endif /* _RKISP1_REGS_V2X_H */
+#endif /* _RKISP_REGS_V2X_H */
diff --git a/drivers/media/platform/rockchip/isp/rkisp.c b/drivers/media/platform/rockchip/isp/rkisp.c
index bbcdd47ca487..22d512cc5291 100644
--- a/drivers/media/platform/rockchip/isp/rkisp.c
+++ b/drivers/media/platform/rockchip/isp/rkisp.c
@@ -454,37 +454,6 @@ static void rkisp_set_state(struct rkisp_device *dev, u32 state)
 	dev->isp_state |= state;
 }
 
-static void rkisp_config_clk(struct rkisp_device *dev, int on)
-{
-	u32 val = !on ? 0 :
-		CIF_ICCL_ISP_CLK | CIF_ICCL_CP_CLK | CIF_ICCL_MRSZ_CLK |
-		CIF_ICCL_SRSZ_CLK | CIF_ICCL_JPEG_CLK | CIF_ICCL_MI_CLK |
-		CIF_ICCL_IE_CLK | CIF_ICCL_MIPI_CLK | CIF_ICCL_DCROP_CLK;
-
-	if (dev->isp_ver == ISP_V20 && on)
-		val |= ICCL_MPFBC_CLK;
-
-	writel(val, dev->base_addr + CIF_ICCL);
-
-	if (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13) {
-		val = !on ? 0 :
-		      CIF_CLK_CTRL_MI_Y12 | CIF_CLK_CTRL_MI_SP |
-		      CIF_CLK_CTRL_MI_RAW0 | CIF_CLK_CTRL_MI_RAW1 |
-		      CIF_CLK_CTRL_MI_READ | CIF_CLK_CTRL_MI_RAWRD |
-		      CIF_CLK_CTRL_CP | CIF_CLK_CTRL_IE;
-
-		writel(val, dev->base_addr + CIF_VI_ISP_CLK_CTRL_V12);
-	} else if (dev->isp_ver == ISP_V20) {
-		val = !on ? 0 :
-		      CLK_CTRL_MI_LDC | CLK_CTRL_MI_MP |
-		      CLK_CTRL_MI_JPEG | CLK_CTRL_MI_DP |
-		      CLK_CTRL_MI_Y12 | CLK_CTRL_MI_SP |
-		      CLK_CTRL_MI_RAW0 | CLK_CTRL_MI_RAW1 |
-		      CLK_CTRL_MI_READ | CLK_CTRL_MI_RAWRD |
-		      CLK_CTRL_ISP_3A;
-		writel(val, dev->base_addr + CTRL_VI_ISP_CLK_CTRL);
-	}
-}
 
 /*
  * Image Stabilization.
@@ -529,7 +498,6 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 	struct ispsd_out_fmt *out_fmt;
 	struct v4l2_rect *in_crop;
 	struct rkisp_sensor_info *sensor;
-	void __iomem *base = dev->base_addr;
 	u32 isp_ctrl = 0;
 	u32 irq_mask = 0;
 	u32 signal = 0;
@@ -556,20 +524,20 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y10_1X10 ||
 			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y12_1X12) {
 				if (dev->isp_ver == ISP_V20)
-					writel(0, base + ISP_DEBAYER_CONTROL);
+					rkisp_write(dev, ISP_DEBAYER_CONTROL, 0, false);
 				else
-					writel(CIF_ISP_DEMOSAIC_BYPASS |
-					       CIF_ISP_DEMOSAIC_TH(0xc),
-					       base + CIF_ISP_DEMOSAIC);
+					rkisp_write(dev, CIF_ISP_DEMOSAIC,
+						CIF_ISP_DEMOSAIC_BYPASS |
+						CIF_ISP_DEMOSAIC_TH(0xc), false);
 			} else {
 				if (dev->isp_ver == ISP_V20)
-					writel(SW_DEBAYER_EN |
-					       SW_DEBAYER_FILTER_G_EN |
-					       SW_DEBAYER_FILTER_C_EN,
-					       base + ISP_DEBAYER_CONTROL);
+					rkisp_write(dev, ISP_DEBAYER_CONTROL,
+						SW_DEBAYER_EN |
+						SW_DEBAYER_FILTER_G_EN |
+						SW_DEBAYER_FILTER_C_EN, false);
 				else
-					writel(CIF_ISP_DEMOSAIC_TH(0xc),
-					       base + CIF_ISP_DEMOSAIC);
+					rkisp_write(dev, CIF_ISP_DEMOSAIC,
+						CIF_ISP_DEMOSAIC_TH(0xc), false);
 			}
 
 			if (sensor && sensor->mbus.type == V4L2_MBUS_BT656)
@@ -615,29 +583,29 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 			signal |= CIF_ISP_ACQ_PROP_HSYNC_LOW;
 	}
 
-	writel(isp_ctrl, base + CIF_ISP_CTRL);
+	rkisp_write(dev, CIF_ISP_CTRL, isp_ctrl, false);
 	acq_prop |= signal | in_fmt->yuv_seq |
 		CIF_ISP_ACQ_PROP_BAYER_PAT(in_fmt->bayer_pat) |
 		CIF_ISP_ACQ_PROP_FIELD_SEL_ALL;
-	writel(acq_prop, base + CIF_ISP_ACQ_PROP);
-	writel(0, base + CIF_ISP_ACQ_NR_FRAMES);
+	rkisp_write(dev, CIF_ISP_ACQ_PROP, acq_prop, false);
+	rkisp_write(dev, CIF_ISP_ACQ_NR_FRAMES, 0, true);
 
 	/* Acquisition Size */
-	writel(acq_mult * in_crop->left, base + CIF_ISP_ACQ_H_OFFS);
-	writel(in_crop->top, base + CIF_ISP_ACQ_V_OFFS);
-	writel(acq_mult * in_crop->width, base + CIF_ISP_ACQ_H_SIZE);
+	rkisp_write(dev, CIF_ISP_ACQ_H_OFFS, acq_mult * in_crop->left, false);
+	rkisp_write(dev, CIF_ISP_ACQ_V_OFFS, in_crop->top, false);
+	rkisp_write(dev, CIF_ISP_ACQ_H_SIZE, acq_mult * in_crop->width, false);
 
 	/* ISP Out Area differ with ACQ is only FIFO, so don't crop in this */
-	writel(0, base + CIF_ISP_OUT_H_OFFS);
-	writel(0, base + CIF_ISP_OUT_V_OFFS);
-	writel(in_crop->width, base + CIF_ISP_OUT_H_SIZE);
+	rkisp_write(dev, CIF_ISP_OUT_H_OFFS, 0, true);
+	rkisp_write(dev, CIF_ISP_OUT_V_OFFS, 0, true);
+	rkisp_write(dev, CIF_ISP_OUT_H_SIZE, in_crop->width, false);
 
 	if (dev->cap_dev.stream[RKISP_STREAM_SP].interlaced) {
-		writel(in_crop->height / 2, base + CIF_ISP_ACQ_V_SIZE);
-		writel(in_crop->height / 2, base + CIF_ISP_OUT_V_SIZE);
+		rkisp_write(dev, CIF_ISP_ACQ_V_SIZE, in_crop->height / 2, false);
+		rkisp_write(dev, CIF_ISP_OUT_V_SIZE, in_crop->height / 2, false);
 	} else {
-		writel(in_crop->height, base + CIF_ISP_ACQ_V_SIZE);
-		writel(in_crop->height, base + CIF_ISP_OUT_V_SIZE);
+		rkisp_write(dev, CIF_ISP_ACQ_V_SIZE, in_crop->height, false);
+		rkisp_write(dev, CIF_ISP_OUT_V_SIZE, in_crop->height, false);
 	}
 
 	/* interrupt mask */
@@ -645,11 +613,11 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 		    CIF_ISP_FRAME_IN;
 	if (dev->isp_ver == ISP_V20)
 		irq_mask |= ISP2X_LSC_LUT_ERR;
-	writel(irq_mask, base + CIF_ISP_IMSC);
+	rkisp_write(dev, CIF_ISP_IMSC, irq_mask, true);
 
 	if (dev->isp_ver == ISP_V20 && IS_HDR_RDBK(dev->hdr.op_mode)) {
 		irq_mask = ISP2X_3A_RAWAE_BIG;
-		writel(irq_mask, base + ISP_ISP3A_IMSC);
+		rkisp_write(dev, ISP_ISP3A_IMSC, irq_mask, true);
 	}
 
 	if (out_fmt->fmt_type == FMT_BAYER)
@@ -688,14 +656,10 @@ static int rkisp_config_dvp(struct rkisp_device *dev)
 	val = readl(base + CIF_ISP_ACQ_PROP);
 	writel(val | input_sel, base + CIF_ISP_ACQ_PROP);
 
-	if (!IS_ERR(dev->grf) &&
-		(dev->isp_ver == ISP_V12 ||
-		dev->isp_ver == ISP_V13))
-		regmap_update_bits(dev->grf,
-			GRF_VI_CON0,
-			ISP_CIF_DATA_WIDTH_MASK,
-			data_width);
-
+	if (!IS_ERR(dev->hw_dev->grf) &&
+	    (dev->isp_ver == ISP_V12 || dev->isp_ver == ISP_V13))
+		regmap_update_bits(dev->hw_dev->grf, GRF_VI_CON0,
+			ISP_CIF_DATA_WIDTH_MASK, data_width);
 	return 0;
 }
 
@@ -885,6 +849,8 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		 dev->cap_dev.stream[RKISP_STREAM_SP].streaming,
 		 dev->cap_dev.stream[RKISP_STREAM_MP].streaming);
 
+	if (atomic_read(&dev->hw_dev->refcnt) > 1)
+		goto end;
 	/*
 	 * ISP(mi) stop in mi frame end -> Stop ISP(mipi) ->
 	 * Stop ISP(isp) ->wait for ISP isp off
@@ -950,16 +916,16 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 	if (!in_interrupt()) {
 		/* normal case */
 		/* check the isp_clk before isp reset operation */
-		old_rate = clk_get_rate(dev->clks[0]);
-		safe_rate = dev->clk_rate_tbl[0] * 1000000UL;
+		old_rate = clk_get_rate(dev->hw_dev->clks[0]);
+		safe_rate = dev->hw_dev->clk_rate_tbl[0] * 1000000UL;
 		if (old_rate > safe_rate) {
-			clk_set_rate(dev->clks[0], safe_rate);
+			clk_set_rate(dev->hw_dev->clks[0], safe_rate);
 			udelay(100);
 		}
 		writel(CIF_IRCL_CIF_SW_RST, base + CIF_IRCL);
 		/* restore the old ispclk after reset */
 		if (old_rate != safe_rate)
-			clk_set_rate(dev->clks[0], old_rate);
+			clk_set_rate(dev->hw_dev->clks[0], old_rate);
 	} else {
 		/* abnormal case, in irq function */
 		writel(CIF_IRCL_CIF_SW_RST, base + CIF_IRCL);
@@ -974,7 +940,6 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		writel(0, base + CSI2RX_CSI2_RESETN);
 	}
 
-	rkisp_config_clk(dev, true);
 	if (!in_interrupt()) {
 		struct iommu_domain *domain;
 
@@ -986,6 +951,10 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 #endif
 		}
 	}
+
+	dev->hw_dev->is_idle = true;
+	dev->hw_dev->is_mi_update = false;
+end:
 	rkisp_set_state(dev, ISP_STOP);
 
 	if (dev->isp_ver == ISP_V20)
@@ -1008,6 +977,7 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 	struct rkisp_sensor_info *sensor = dev->active_sensor;
 	void __iomem *base = dev->base_addr;
 	u32 val;
+	bool is_direct = true;
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d\n",
@@ -1030,12 +1000,14 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 		}
 	}
 	/* Activate ISP */
-	val = readl(base + CIF_ISP_CTRL);
+	val = rkisp_read(dev, CIF_ISP_CTRL, false);
 	val |= CIF_ISP_CTRL_ISP_CFG_UPD | CIF_ISP_CTRL_ISP_ENABLE |
 	       CIF_ISP_CTRL_ISP_INFORM_ENABLE | CIF_ISP_CTRL_ISP_CFG_UPD_PERMANENT;
 	if (dev->isp_ver == ISP_V20)
 		val |= NOC_HURRY_W_HIGH | NOC_HURRY_W_MODE(3);
-	writel(val, base + CIF_ISP_CTRL);
+	if (atomic_read(&dev->hw_dev->refcnt) > 1)
+		is_direct = false;
+	rkisp_write(dev, CIF_ISP_CTRL, val, is_direct);
 
 	dev->isp_err_cnt = 0;
 	dev->isp_state = ISP_START;
@@ -1044,7 +1016,8 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 	 * CIF spec says to wait for sufficient time after enabling
 	 * the MIPI interface and before starting the sensor output.
 	 */
-	usleep_range(1000, 1200);
+	if (dev->hw_dev->is_single)
+		usleep_range(1000, 1200);
 
 	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
 		 "SP streaming = %d, MP streaming = %d MI_CTRL 0x%08x\n"
@@ -1055,6 +1028,7 @@ static int rkisp_isp_start(struct rkisp_device *dev)
 		 readl(base + CIF_ISP_CTRL),
 		 readl(base + CIF_MIPI_CTRL));
 
+	rkisp_csi_trigger_event(dev, T_CMD_QUEUE, NULL);
 	return 0;
 }
 
@@ -1616,62 +1590,20 @@ static int rkisp_isp_sd_s_stream(struct v4l2_subdev *sd, int on)
 	return rkisp_isp_start(isp_dev);
 }
 
-static void rkisp_isp_soft_reset(struct rkisp_device *isp_dev)
-{
-	void __iomem *base = isp_dev->base_addr;
-
-	if (isp_dev->isp_ver == ISP_V20) {
-		struct iommu_domain *domain =
-			iommu_get_domain_for_dev(isp_dev->dev);
-
-		writel(CIF_ISP_CTRL_ISP_MODE_BAYER_ITU601,
-		       base + CIF_ISP_CTRL);
-		writel(0xffff, base + CIF_IRCL);
-		usleep_range(100, 200);
-		if (domain) {
-#ifdef CONFIG_IOMMU_API
-			domain->ops->detach_dev(domain, isp_dev->dev);
-			domain->ops->attach_dev(domain, isp_dev->dev);
-#endif
-		}
-	}
-}
-
 static int rkisp_isp_sd_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct rkisp_device *isp_dev = sd_to_isp_dev(sd);
-	void __iomem *base = isp_dev->base_addr;
 	int ret;
 
-	v4l2_dbg(1, rkisp_debug, &isp_dev->v4l2_dev, "s_power: %d\n", on);
+	v4l2_dbg(1, rkisp_debug, &isp_dev->v4l2_dev,
+		 "%s on:%d\n", __func__, on);
 
-	if (on) {
+	if (on)
 		ret = pm_runtime_get_sync(isp_dev->dev);
-		if (ret < 0)
-			return ret;
-
-		if (!isp_dev->is_thunderboot) {
-			rkisp_isp_soft_reset(isp_dev);
-			rkisp_config_clk(isp_dev, on);
-		}
-
-		if (isp_dev->isp_ver == ISP_V12 ||
-		    isp_dev->isp_ver == ISP_V13) {
-			/* disable csi_rx interrupt */
-			writel(0, base + CIF_ISP_CSI0_CTRL0);
-			writel(0, base + CIF_ISP_CSI0_MASK1);
-			writel(0, base + CIF_ISP_CSI0_MASK2);
-			writel(0, base + CIF_ISP_CSI0_MASK3);
-		}
-	} else {
-		if (!isp_dev->is_thunderboot)
-			rkisp_config_clk(isp_dev, on);
+	else
 		ret = pm_runtime_put(isp_dev->dev);
-		if (ret < 0)
-			return ret;
-	}
 
-	return 0;
+	return ret;
 }
 
 static int rkisp_subdev_link_setup(struct media_entity *entity,
@@ -1697,10 +1629,10 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 		if (flags & MEDIA_LNK_FL_ENABLED) {
 			if (dev->isp_inp & ~INP_DMARX_ISP)
 				goto err;
-			if (dev->active_sensor)
-				dev->active_sensor = NULL;
 			dev->isp_inp = INP_DMARX_ISP;
 		} else {
+			if (dev->active_sensor)
+				dev->active_sensor = NULL;
 			dev->isp_inp = INP_INVAL;
 		}
 	} else if (!strcmp(remote->entity->name, CSI_DEV_NAME)) {
@@ -1709,6 +1641,8 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 				goto err;
 			dev->isp_inp |= INP_CSI;
 		} else {
+			if (dev->active_sensor)
+				dev->active_sensor = NULL;
 			dev->isp_inp &= ~INP_CSI;
 		}
 	} else if (!strcmp(remote->entity->name, DMARX0_VDEV_NAME)) {
@@ -1760,6 +1694,8 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 				goto err;
 			dev->isp_inp |= INP_LVDS;
 		} else {
+			if (dev->active_sensor)
+				dev->active_sensor = NULL;
 			dev->isp_inp &= ~INP_LVDS;
 		}
 	} else {
@@ -1768,6 +1704,8 @@ static int rkisp_subdev_link_setup(struct media_entity *entity,
 				goto err;
 			dev->isp_inp |= INP_DVP;
 		} else {
+			if (dev->active_sensor)
+				dev->active_sensor = NULL;
 			dev->isp_inp &= ~INP_INVAL;
 		}
 	}
@@ -1854,7 +1792,7 @@ static long rkisp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 
 	switch (cmd) {
 	case RKISP_CMD_TRIGGER_READ_BACK:
-		rkisp_csi_trigger_event(&isp_dev->csi_dev, arg);
+		rkisp_csi_trigger_event(isp_dev, T_CMD_QUEUE, arg);
 		break;
 	case RKISP_CMD_CSI_MEMORY_MODE:
 		if (*((int *)arg) == CSI_MEM_BYTE_BE)
@@ -2069,7 +2007,7 @@ void rkisp_chk_tb_over(struct rkisp_device *isp_dev)
 
 	resmem_va = phys_to_virt(isp_dev->resmem_pa);
 	head = (struct rkisp_thunderboot_resmem_head *)resmem_va;
-	if (isp_dev->is_thunderboot) {
+	if (isp_dev->hw_dev->is_thunderboot) {
 		if ((!head->complete)) {
 			for (i = 0; i < 100; i++) {
 				usleep_range(5000, 6000);
@@ -2100,11 +2038,8 @@ void rkisp_chk_tb_over(struct rkisp_device *isp_dev)
 
 		rkisp_tb_set_state(tb_state);
 		rkisp_tb_unprotect_clk();
-		rkisp_register_irq(isp_dev);
-		isp_dev->is_thunderboot = false;
-		rkisp_isp_soft_reset(isp_dev);
-		rkisp_config_clk(isp_dev, 1);
-		pm_runtime_put(isp_dev->dev);
+		rkisp_register_irq(isp_dev->hw_dev);
+		isp_dev->hw_dev->is_thunderboot = false;
 	}
 }
 #endif
-- 
2.35.3

