From ceea23ef8692d916b5f2df09adb32b95d619e60f Mon Sep 17 00:00:00 2001
From: Sugar Zhang <sugar.zhang@rock-chips.com>
Date: Thu, 21 Nov 2019 18:09:48 +0800
Subject: [PATCH] ASoC: codecs: Adds support for es8396

Change-Id: I45b01dfa336e88b9eb74e65739fa0ed863c2da90
Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
---
 sound/soc/codecs/Kconfig  |    5 +
 sound/soc/codecs/Makefile |    2 +
 sound/soc/codecs/es8396.c | 1365 ++++++++++++++++---------------------
 sound/soc/codecs/es8396.h |   15 +-
 4 files changed, 612 insertions(+), 775 deletions(-)

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 17af6e6dd87e..3b52ba1c8ba5 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -80,6 +80,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ES8323 if I2C
 	select SND_SOC_ES8328_SPI if SPI_MASTER
 	select SND_SOC_ES8328_I2C if I2C
+	select SND_SOC_ES8396 if I2C
 	select SND_SOC_ES7134
 	select SND_SOC_ES7241
 	select SND_SOC_GTM601
@@ -621,6 +622,10 @@ config SND_SOC_ES8328_SPI
 	depends on SPI_MASTER
 	select SND_SOC_ES8328
 
+config SND_SOC_ES8396
+	tristate "Everest Semi ES8396 CODEC"
+	depends on I2C
+
 config SND_SOC_GTM601
 	tristate 'GTM601 UMTS modem audio codec'
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index b7adf7f41954..0dbd3d84497b 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -78,6 +78,7 @@ snd-soc-es8323-objs := es8323.o
 snd-soc-es8328-objs := es8328.o
 snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
+snd-soc-es8396-objs := es8396.o
 snd-soc-gtm601-objs := gtm601.o
 snd-soc-hdac-hdmi-objs := hdac_hdmi.o
 snd-soc-ics43432-objs := ics43432.o
@@ -346,6 +347,7 @@ obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
+obj-$(CONFIG_SND_SOC_ES8396)	+= snd-soc-es8396.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
 obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
diff --git a/sound/soc/codecs/es8396.c b/sound/soc/codecs/es8396.c
index afb48d7c2516..6f5cb6ec1286 100644
--- a/sound/soc/codecs/es8396.c
+++ b/sound/soc/codecs/es8396.c
@@ -1,17 +1,11 @@
-/*
- * es8396.c  --  ES8396 ALSA SoC Audio Codec
- *
- * Copyright (C) 2014 Everest Semiconductor Co., Ltd
- *
- * Authors:  David Yang(yangxiaohua@everest-semi.com)
- *
- *
- * Based on alc5632.c by David Yang(yangxiaohua@everest-semi.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// es8396.c  --  ES8396 ALSA SoC Audio Codec
+//
+// Copyright (C) 2014 Everest Semiconductor Co., Ltd
+//
+// Authors:  David Yang(yangxiaohua@everest-semi.com)
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -33,10 +27,7 @@
 #include <linux/clk.h>
 #include "es8396.h"
 
-#define INVALID_GPIO -1
-
-static struct snd_soc_codec *tron_codec;
-static int es8396_set_bias_level(struct snd_soc_codec *codec,
+static int es8396_set_bias_level(struct snd_soc_component *component,
 				 enum snd_soc_bias_level level);
 
 /*
@@ -192,29 +183,30 @@ struct sp_config {
 
 /* codec private data */
 struct es8396_private {
+	struct snd_soc_component *component;
 	struct sp_config config[3];
 	struct regmap *regmap;
 	u8 sysclk[3];
 	u32 mclk[3];
 	struct clk *mclk_clock;
 
-	/* platform dependant DVDD voltage configuration */
+	/* platform dependent DVDD voltage configuration */
 	u8 dvdd_pwr_vol;
 
-	/* platform dependant CLASS D Mono mode configuration */
+	/* platform dependent CLASS D Mono mode configuration */
 	bool spkmono;
-	/* platform dependant earpiece mode configuration */
+	/* platform dependent earpiece mode configuration */
 	bool earpiece;
-	/* platform dependant monon/p differential mode configuration */
+	/* platform dependent monon/p differential mode configuration */
 	bool monoin_differential;
-	/* platform dependant lout/rout differential mode configuration */
+	/* platform dependent lout/rout differential mode configuration */
 	bool lno_differential;
 
-	/* platform dependant analog ldo level configuration */
+	/* platform dependent analog ldo level configuration */
 	u8 ana_ldo_lvl;
-	/* platform dependant speaker ldo level configuration */
+	/* platform dependent speaker ldo level configuration */
 	u8 spk_ldo_lvl;
-	/* platform dependant mic bias voltage configuration */
+	/* platform dependent mic bias voltage configuration */
 	u8 mic_bias_lvl;
 	u8 dmic_amic;
 
@@ -224,10 +216,8 @@ struct es8396_private {
 
 	int shutdwn_delay;
 	int pon_delay;
-	int spk_ctl_gpio;
-	bool spk_gpio_level;
-	int lineout_ctl_gpio;
-	bool lineout_gpio_level;
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *lineout_ctl_gpio;
 
 	bool calibrate;
 	u8 output_device_selected;
@@ -311,92 +301,72 @@ static bool es8396_valid_spkldo(u8 ldolvl)
 	return false;
 }
 
-/*
-static int es8396_volatile_register(struct snd_soc_codec *codec,
-				    unsigned int reg)
-{
-	switch (reg) {
-	case ES8396_SHARED_ADDR_REG1D:
-	case ES8396_SHARED_DATA_REG1E:
-	case ES8396_GPIO_STA_REG17:
-	case ES8396_CPHP_HPL_ICAL_REG3E:
-	case ES8396_CPHP_HPR_ICAL_REG3F:
-	case ES8396_RESET_REG00:
-	case ES8396_PLL_CTRL_1_REG02:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static int es8396_readable_register(struct snd_soc_codec *codec,
-				    unsigned int reg)
-{
-	if (reg < 0x80)
-		return true;
-
-	return false;
-}
-*/
-
 static void pcm_shutdown_depop_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     pcm_shutdown_depop_work.work);
+	struct snd_soc_component *component = es8396->component;
 
 	mutex_lock(&es8396->pcm_shutdown_depop_mlock);
-	snd_soc_update_bits(tron_codec, ES8396_SDP1_IN_FMT_REG1F, 0x40,
-			    0x40);
+	snd_soc_component_update_bits(component, ES8396_SDP1_IN_FMT_REG1F,
+				      0x40, 0x40);
 	es8396->aif1_select &= 0xfe;
 	mutex_unlock(&es8396->pcm_shutdown_depop_mlock);
 }
 
 static void voice_shutdown_depop_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     voice_shutdown_depop_work.work);
+	struct snd_soc_component *component = es8396->component;
 
 	mutex_lock(&es8396->voice_shutdown_depop_mlock);
-	snd_soc_update_bits(tron_codec, ES8396_SDP2_IN_FMT_REG22,
-			    0x7F, 0x53);
+	snd_soc_component_update_bits(component, ES8396_SDP2_IN_FMT_REG22,
+				      0x7F, 0x53);
 	es8396->aif2_select &= 0xfe;
-	if ((es8396->aif1_select) != 0) {
-		snd_soc_write(tron_codec, 0x1A, 0x00);
-		snd_soc_write(tron_codec, 0x67, 0x00);
-		snd_soc_write(tron_codec, 0x69, 0x00);
-		snd_soc_write(tron_codec, 0x66, 0x00);
+	if (es8396->aif1_select != 0) {
+		snd_soc_component_write(component, 0x1A, 0x00);
+		snd_soc_component_write(component, 0x67, 0x00);
+		snd_soc_component_write(component, 0x69, 0x00);
+		snd_soc_component_write(component, 0x66, 0x00);
 	}
 	mutex_unlock(&es8396->voice_shutdown_depop_mlock);
 }
 
 static void init_cali_work_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     init_cali_work.work);
+	struct snd_soc_component *component = es8396->component;
 
 	mutex_lock(&es8396->init_cali_mlock);
 	pr_debug("init_cali_work_events\n");
-	if ((es8396->pcm_pop_work_retry) > 0) {
+	if (es8396->pcm_pop_work_retry > 0) {
 		es8396->pcm_pop_work_retry--;
 		pr_debug("Enter into %s  %d\n", __func__, __LINE__);
-		snd_soc_write(tron_codec, ES8396_DAC_OFFSET_CALI_REG6F, 0x83);
+		snd_soc_component_write(component, ES8396_DAC_OFFSET_CALI_REG6F, 0x83);
 		if (es8396->pcm_pop_work_retry) {
 			schedule_delayed_work(&es8396->init_cali_work,
 					      msecs_to_jiffies(100));
 		}
 	}
-	snd_soc_write(tron_codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x3C);
+	snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x3C);
 
 	/* use line  out */
 	msleep(100);
-	snd_soc_write(tron_codec, 0x4E, 0x80);
-	snd_soc_write(tron_codec, 0x4F, 0x81);
-	snd_soc_write(tron_codec, 0x4A, 0x60);
-	snd_soc_write(tron_codec, 0x4B, 0x60);
+	snd_soc_component_write(component, 0x4E, 0x80);
+	snd_soc_component_write(component, 0x4F, 0x81);
+	snd_soc_component_write(component, 0x4A, 0x60);
+	snd_soc_component_write(component, 0x4B, 0x60);
 
 	mutex_unlock(&es8396->init_cali_mlock);
 }
 
 static void voice_pop_work_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     voice_pop_work.work);
+	struct snd_soc_component *component = es8396->component;
 	int i;
 
 	mutex_lock(&es8396->voice_depop_mlock);
@@ -407,23 +377,23 @@ static void voice_pop_work_events(struct work_struct *work)
 	 * set Equalizer
 	 * set DAC source from equalizer
 	 */
-	snd_soc_update_bits(tron_codec, ES8396_SDP2_IN_FMT_REG22,
-			    0x3F, 0x13);
-	snd_soc_update_bits(tron_codec, ES8396_SDP2_OUT_FMT_REG23,
-			    0x7F, 0x33);
+	snd_soc_component_update_bits(component, ES8396_SDP2_IN_FMT_REG22,
+				      0x3F, 0x13);
+	snd_soc_component_update_bits(component, ES8396_SDP2_OUT_FMT_REG23,
+				      0x7F, 0x33);
 	/* use line out */
-	snd_soc_write(tron_codec, 0x4E, 0x80);
-	snd_soc_write(tron_codec, 0x4F, 0x81);
-	snd_soc_write(tron_codec, 0x4A, 0x60);
-	snd_soc_write(tron_codec, 0x4B, 0x60);
-	snd_soc_write(tron_codec, 0x1A, 0x40);	/* Enable HPOUT */
+	snd_soc_component_write(component, 0x4E, 0x80);
+	snd_soc_component_write(component, 0x4F, 0x81);
+	snd_soc_component_write(component, 0x4A, 0x60);
+	snd_soc_component_write(component, 0x4B, 0x60);
+	snd_soc_component_write(component, 0x1A, 0x40);	/* Enable HPOUT */
 
 	/* unmute dac */
-	snd_soc_write(tron_codec, 0x66, 0x00);
+	snd_soc_component_write(component, 0x66, 0x00);
 
 	for (i = 0; i < 120; i = i + 2) {
-		snd_soc_write(tron_codec, 0x6A, 120 - i);
-		snd_soc_write(tron_codec, 0x6B, 120 - i);
+		snd_soc_component_write(component, 0x6A, 120 - i);
+		snd_soc_component_write(component, 0x6B, 120 - i);
 		usleep_range(100, 200);
 	}
 
@@ -432,26 +402,26 @@ static void voice_pop_work_events(struct work_struct *work)
 
 static void pcm_pop_work_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     pcm_pop_work.work);
+	struct snd_soc_component *component = es8396->component;
 	int i;
+
 	mutex_lock(&es8396->pcm_depop_mlock);
 	pr_debug("pcm_pop_work_events\n");
 
-	snd_soc_write(tron_codec, ES8396_SYS_VMID_REF_REG71,
-					      0xFC);
+	snd_soc_component_write(component, ES8396_SYS_VMID_REF_REG71, 0xFC);
 
 	/* use line out */
-	snd_soc_write(tron_codec, 0x4E, 0x80);
-	snd_soc_write(tron_codec, 0x4F, 0x81);
-	snd_soc_write(tron_codec, 0x4A, 0x60);
-	snd_soc_write(tron_codec, 0x4B, 0x60);
-	snd_soc_update_bits(tron_codec, ES8396_DAC_CSM_REG66,
-			    0x03, 0x00);
-	snd_soc_update_bits(tron_codec, ES8396_SDP1_IN_FMT_REG1F, 0x40,
-			    0x00);
+	snd_soc_component_write(component, 0x4E, 0x80);
+	snd_soc_component_write(component, 0x4F, 0x81);
+	snd_soc_component_write(component, 0x4A, 0x60);
+	snd_soc_component_write(component, 0x4B, 0x60);
+	snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0x03, 0x00);
+	snd_soc_component_update_bits(component, ES8396_SDP1_IN_FMT_REG1F, 0x40, 0x00);
 	for (i = 0; i < 120; i = i + 2) {
-		snd_soc_write(tron_codec, 0x6A, 120 - i);
-		snd_soc_write(tron_codec, 0x6B, 120 - i);
+		snd_soc_component_write(component, 0x6A, 120 - i);
+		snd_soc_component_write(component, 0x6B, 120 - i);
 		usleep_range(100, 200);
 	}
 	mutex_unlock(&es8396->pcm_depop_mlock);
@@ -464,72 +434,71 @@ static int classd_event(struct snd_soc_dapm_widget *w,
 			struct snd_kcontrol *kcontrol, int event)
 {
 	unsigned int regv1, regv2, lvl;
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct es8396_private *priv = snd_soc_codec_get_drvdata(codec);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:	/* prepare power up */
 		/* power up class d */
 		pr_debug("SND_SOC_DAPM_PRE_PMU = 0x%x\n", event);
 		/* read the clock configure */
-		regv1 = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		regv1 = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		regv1 &= 0xcf;
 		/* enable class d clock */
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, regv1);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, regv1);
 		/* dac csm startup, dac digital still on */
-		snd_soc_update_bits(codec, ES8396_DAC_CSM_REG66, 0xFE, 0x00);
+		snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0xFE, 0x00);
 		/* dac analog power on */
-		snd_soc_update_bits(codec, ES8396_DAC_REF_PWR_CTRL_REG6E,
-				    0xff, 0x34);
+		snd_soc_component_update_bits(component, ES8396_DAC_REF_PWR_CTRL_REG6E,
+					      0xff, 0x34);
 
-		regv2 = snd_soc_read(codec, ES8396_SPK_CTRL_1_REG3C);
+		regv2 = snd_soc_component_read32(component, ES8396_SPK_CTRL_1_REG3C);
 		/* set speaker ldo level */
-		if (es8396_valid_spkldo(priv->spk_ldo_lvl) == false) {
+		if (es8396_valid_spkldo(es8396->spk_ldo_lvl) == false) {
 			pr_err("speaker LDO Level error.\n");
 			return -EINVAL;
 		} else {
 			regv1 = regv2 & 0xD8;
-			lvl = priv->spk_ldo_lvl;
+			lvl = es8396->spk_ldo_lvl;
 			lvl &= 0x07;
 			regv1 |= lvl;
 			regv1 |= 0x10;
 		}
-		if (priv->spkmono == 1) {	/* speaker in mono mode */
+		if (es8396->spkmono == 1) {	/* speaker in mono mode */
 			regv1 = regv1 | 0x40;
 		} else {
 			regv1 = regv1 & 0xbf;
 		}
-		snd_soc_write(codec, ES8396_SPK_CTRL_1_REG3C, regv1);
+		snd_soc_component_write(component, ES8396_SPK_CTRL_1_REG3C, regv1);
 
-		snd_soc_write(codec, ES8396_SPK_CTRL_2_REG3D, 0x10);
+		snd_soc_component_write(component, ES8396_SPK_CTRL_2_REG3D, 0x10);
 
-		regv1 = snd_soc_read(codec, ES8396_SPK_MIXER_REG26);
+		regv1 = snd_soc_component_read32(component, ES8396_SPK_MIXER_REG26);
 		/* clear pdnspkl_biasgen, clear pdnspkr_biasgen */
 		regv1 &= 0xee;
-		snd_soc_write(codec, ES8396_SPK_MIXER_REG26, regv1);
-		snd_soc_write(codec, ES8396_SPK_MIXER_VOL_REG28, 0x33);
+		snd_soc_component_write(component, ES8396_SPK_MIXER_REG26, regv1);
+		snd_soc_component_write(component, ES8396_SPK_MIXER_VOL_REG28, 0x33);
 
-		snd_soc_write(codec, ES8396_SPK_CTRL_SRC_REG3A, 0xA9);
+		snd_soc_component_write(component, ES8396_SPK_CTRL_SRC_REG3A, 0xA9);
 		/* L&R DAC Vol=-6db */
-		snd_soc_write(codec, ES8396_DAC_LDAC_VOL_REG6A, 0x00);
-		snd_soc_write(codec, ES8396_DAC_RDAC_VOL_REG6B, 0x00);
+		snd_soc_component_write(component, ES8396_DAC_LDAC_VOL_REG6A, 0x00);
+		snd_soc_component_write(component, ES8396_DAC_RDAC_VOL_REG6B, 0x00);
 
-		regv1 = snd_soc_read(codec, ES8396_HP_MIXER_BOOST_REG2B);
+		regv1 = snd_soc_component_read32(component, ES8396_HP_MIXER_BOOST_REG2B);
 		regv1 &= 0xcc;
-		snd_soc_write(codec, ES8396_HP_MIXER_BOOST_REG2B, regv1);
+		snd_soc_component_write(component, ES8396_HP_MIXER_BOOST_REG2B, regv1);
 
-		regv1 = snd_soc_read(codec, ES8396_CPHP_CTRL_3_REG44);
+		regv1 = snd_soc_component_read32(component, ES8396_CPHP_CTRL_3_REG44);
 		regv1 &= 0xcc;
-		snd_soc_write(codec, ES8396_CPHP_CTRL_3_REG44, regv1);
+		snd_soc_component_write(component, ES8396_CPHP_CTRL_3_REG44, regv1);
 
-		regv1 = snd_soc_read(codec, ES8396_CPHP_CTRL_1_REG42);
+		regv1 = snd_soc_component_read32(component, ES8396_CPHP_CTRL_1_REG42);
 		regv1 &= 0xdf;
-		snd_soc_write(codec, ES8396_CPHP_CTRL_1_REG42, regv1);
+		snd_soc_component_write(component, ES8396_CPHP_CTRL_1_REG42, regv1);
 
-		regv1 = snd_soc_read(codec, ES8396_CPHP_CTRL_2_REG43);
+		regv1 = snd_soc_component_read32(component, ES8396_CPHP_CTRL_2_REG43);
 		regv1 &= 0x7f;
-		snd_soc_write(codec, ES8396_CPHP_CTRL_2_REG43, regv1);
+		snd_soc_component_write(component, ES8396_CPHP_CTRL_2_REG43, regv1);
 		es8396->output_device_selected = 0;
 		break;
 	case SND_SOC_DAPM_POST_PMU:	/* after power up */
@@ -540,27 +509,27 @@ static int classd_event(struct snd_soc_dapm_widget *w,
 	case SND_SOC_DAPM_PRE_PMD:	/* prepare power down */
 		pr_debug("SND_SOC_DAPM_PRE_PMD = 0x%x\n", event);
 		/* read the clock configure */
-		regv1 = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		regv1 = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		regv1 |= 0x10;
 		/* stop class d clock */
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, regv1);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, regv1);
 		/* dac csm startup, dac digital still on */
-		/* snd_soc_update_bits(w->codec, ES8396_DAC_CSM_REG66,
+		/* snd_soc_component_update_bits(w->component, ES8396_DAC_CSM_REG66,
 				       0x01, 0x01); */
-		regv1 = snd_soc_read(codec, ES8396_SPK_EN_VOL_REG3B);
+		regv1 = snd_soc_component_read32(component, ES8396_SPK_EN_VOL_REG3B);
 		regv1 &= 0x77;
 		/* clear enspk_l,enspk_r */
-		snd_soc_write(codec, ES8396_SPK_EN_VOL_REG3B, regv1);
+		snd_soc_component_write(component, ES8396_SPK_EN_VOL_REG3B, regv1);
 
-		regv1 = snd_soc_read(codec, ES8396_SPK_CTRL_SRC_REG3A);
+		regv1 = snd_soc_component_read32(component, ES8396_SPK_CTRL_SRC_REG3A);
 		regv1 |= 0x44;	/* set pdnspkl_biasgen, set pdnspkr_biasgen */
-		snd_soc_write(codec, ES8396_SPK_CTRL_SRC_REG3A, regv1);
-		regv1 = snd_soc_read(codec, ES8396_SPK_MIXER_REG26);
+		snd_soc_component_write(component, ES8396_SPK_CTRL_SRC_REG3A, regv1);
+		regv1 = snd_soc_component_read32(component, ES8396_SPK_MIXER_REG26);
 		/* clear pdnspkl_biasgen, clear pdnspkr_biasgen */
 		regv1 |= 0x11;
-		snd_soc_write(codec, ES8396_SPK_MIXER_REG26, regv1);
-		snd_soc_update_bits(codec, ES8396_SPK_CTRL_1_REG3C, 0x20,
-				    0x20);
+		snd_soc_component_write(component, ES8396_SPK_MIXER_REG26, regv1);
+		snd_soc_component_update_bits(component, ES8396_SPK_CTRL_1_REG3C, 0x20,
+					      0x20);
 		break;
 	case SND_SOC_DAPM_POST_PMD:	/* after power down */
 		pr_debug("SND_SOC_DAPM_POST_PMD = 0x%x\n", event);
@@ -574,8 +543,8 @@ static int classd_event(struct snd_soc_dapm_widget *w,
 static int micbias_event(struct snd_soc_dapm_widget *w,
 			 struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 	unsigned int regv;
 
 	switch (event) {
@@ -588,22 +557,22 @@ static int micbias_event(struct snd_soc_dapm_widget *w,
 			regv &= 0x07;
 			regv = (regv << 4) | 0x08;
 			/* enable micbias1 */
-			snd_soc_write(codec, ES8396_SYS_MICBIAS_CTRL_REG74,
-				      regv);
+			snd_soc_component_write(component, ES8396_SYS_MICBIAS_CTRL_REG74,
+						regv);
 		}
-		regv = snd_soc_read(codec, ES8396_ALRCK_GPIO_SEL_REG15);
+		regv = snd_soc_component_read32(component, ES8396_ALRCK_GPIO_SEL_REG15);
 		if (es8396->dmic_amic == MIC_DMIC) {
 			regv &= 0xf0;	/* enable DMIC CLK */
 			regv |= 0x0A;
 		} else {
 			regv &= 0xf0;	/* disable DMIC CLK */
 		}
-		snd_soc_write(codec, ES8396_ALRCK_GPIO_SEL_REG15, regv);
+		snd_soc_component_write(component, ES8396_ALRCK_GPIO_SEL_REG15, regv);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
-		regv = snd_soc_read(codec, ES8396_ALRCK_GPIO_SEL_REG15);
+		regv = snd_soc_component_read32(component, ES8396_ALRCK_GPIO_SEL_REG15);
 		regv &= 0xf0;	/* disable DMIC CLK */
-		snd_soc_write(codec, ES8396_ALRCK_GPIO_SEL_REG15, regv);
+		snd_soc_component_write(component, ES8396_ALRCK_GPIO_SEL_REG15, regv);
 		break;
 	default:
 		break;
@@ -614,11 +583,13 @@ static int micbias_event(struct snd_soc_dapm_widget *w,
 
 static void adc_depop_work_events(struct work_struct *work)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct es8396_private *es8396 = container_of(work, struct es8396_private,
+						     adc_depop_work.work);
+	struct snd_soc_component *component = es8396->component;
 
 	pr_debug("adc_depop_work_events\n");
 	mutex_lock(&es8396->adc_depop_mlock);
-	snd_soc_update_bits(tron_codec, ES8396_SDP1_OUT_FMT_REG20, 0x40, 0x00);
+	snd_soc_component_update_bits(component, ES8396_SDP1_OUT_FMT_REG20, 0x40, 0x00);
 	mutex_unlock(&es8396->adc_depop_mlock);
 }
 
@@ -626,54 +597,54 @@ static int adc_event(struct snd_soc_dapm_widget *w,
 		     struct snd_kcontrol *kcontrol, int event)
 {
 	unsigned int regv;
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	pr_debug("Enter into %s  %d\n", __func__, __LINE__);
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		pr_debug("Enter into SND_SOC_DAPM_PRE_PMU %s  %d\n", __func__,
 			 __LINE__);
-		snd_soc_update_bits(codec, ES8396_SDP1_OUT_FMT_REG20, 0x40,
-				    0x40);
+		snd_soc_component_update_bits(component, ES8396_SDP1_OUT_FMT_REG20, 0x40,
+					      0x40);
 		/* set adc alc */
-		snd_soc_write(codec, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
-		snd_soc_write(codec, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
-		snd_soc_write(codec, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
-		snd_soc_write(codec, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
-		snd_soc_write(codec, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
-		snd_soc_write(codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
+		snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
 		/* Enable MIC BOOST */
-		snd_soc_write(codec, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
+		snd_soc_component_write(component, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
 
 		/* axMixer Gain boost */
-		regv = snd_soc_read(codec, ES8396_AX_MIXER_BOOST_REG2F);
+		regv = snd_soc_component_read32(component, ES8396_AX_MIXER_BOOST_REG2F);
 		regv |= 0x88;
-		snd_soc_write(codec, ES8396_AX_MIXER_BOOST_REG2F, regv);
+		snd_soc_component_write(component, ES8396_AX_MIXER_BOOST_REG2F, regv);
 		/* axmixer vol = +12db */
-		snd_soc_write(codec, ES8396_AX_MIXER_VOL_REG30, 0xaa);
+		snd_soc_component_write(component, ES8396_AX_MIXER_VOL_REG30, 0xaa);
 		/* axmixer high driver capacility */
-		snd_soc_write(codec, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
+		snd_soc_component_write(component, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
 
 		/* MNMixer Gain boost */
-		regv = snd_soc_read(codec, ES8396_MN_MIXER_BOOST_REG37);
+		regv = snd_soc_component_read32(component, ES8396_MN_MIXER_BOOST_REG37);
 		regv |= 0x88;
-		snd_soc_write(codec, ES8396_MN_MIXER_BOOST_REG37, regv);
+		snd_soc_component_write(component, ES8396_MN_MIXER_BOOST_REG37, regv);
 		/* mnmixer vol = +12db */
-		snd_soc_write(codec, ES8396_MN_MIXER_VOL_REG38, 0x44);
+		snd_soc_component_write(component, ES8396_MN_MIXER_VOL_REG38, 0x44);
 		/* mnmixer high driver capacility */
-		snd_soc_write(codec, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
+		snd_soc_component_write(component, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
 
 		msleep(200);
 		/* ADC STM and Digital Startup, ADC DS Mode */
-		snd_soc_write(codec, ES8396_ADC_CSM_REG53, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x00);
 		/* force adc stm to normal */
-		snd_soc_write(codec, ES8396_ADC_FORCE_REG77, 0x40);
-		snd_soc_write(codec, ES8396_ADC_FORCE_REG77, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x40);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x0);
 		/* ADC Volume =0db */
-		snd_soc_write(codec, ES8396_ADC_LADC_VOL_REG56, 0x0);
-		snd_soc_write(codec, ES8396_ADC_RADC_VOL_REG57, 0x0);
-		snd_soc_write(codec, ES8396_ADC_CLK_DIV_REG09, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_LADC_VOL_REG56, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_RADC_VOL_REG57, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_CLK_DIV_REG09, 0x04);
 
 		schedule_delayed_work(&es8396->adc_depop_work,
 				      msecs_to_jiffies(150));
@@ -681,8 +652,8 @@ static int adc_event(struct snd_soc_dapm_widget *w,
 	case SND_SOC_DAPM_PRE_PMD:
 		pr_debug("Enter into SND_SOC_DAPM_PRE_PMD %s  %d\n", __func__,
 			 __LINE__);
-		snd_soc_write(codec, ES8396_ADC_CSM_REG53, 0x20);
-		snd_soc_write(codec, ES8396_ADC_CLK_DIV_REG09, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x20);
+		snd_soc_component_write(component, ES8396_ADC_CLK_DIV_REG09, 0x04);
 		break;
 	default:
 		break;
@@ -698,8 +669,8 @@ static int hpamp_event(struct snd_soc_dapm_widget *w,
 		       struct snd_kcontrol *kcontrol, int event)
 {
 	unsigned int regv;
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	pr_debug("Enter into %s  %d\n", __func__, __LINE__);
 	switch (event) {
@@ -718,25 +689,25 @@ static int hpamp_event(struct snd_soc_dapm_widget *w,
 		pr_debug("Enter into %s  %d, event = SND_SOC_DAPM_PRE_PMD\n",
 			 __func__, __LINE__);
 		/* dac analog power down */
-		snd_soc_update_bits(codec, ES8396_DAC_CSM_REG66, 0x42, 0x00);
+		snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0x42, 0x00);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
 		pr_debug("Enter into %s  %d, event = SND_SOC_DAPM_POST_PMD\n",
 			 __func__, __LINE__);
 		/* dac analog power down */
-		snd_soc_update_bits(codec, ES8396_DAC_CSM_REG66, 0x40, 0x40);
+		snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0x40, 0x40);
 		/* dac analog power down */
-		snd_soc_update_bits(codec, ES8396_DAC_REF_PWR_CTRL_REG6E,
-				    0xC0, 0xC0);
+		snd_soc_component_update_bits(component, ES8396_DAC_REF_PWR_CTRL_REG6E,
+					      0xC0, 0xC0);
 		/* read the clock configure */
-		regv = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		regv = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		regv |= 0x20;
 		/* stop charge pump clock */
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, regv);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, regv);
 
-		regv = snd_soc_read(codec, ES8396_HP_MIXER_BOOST_REG2B);
+		regv = snd_soc_component_read32(component, ES8396_HP_MIXER_BOOST_REG2B);
 		regv |= 0x11;
-		snd_soc_write(codec, ES8396_HP_MIXER_BOOST_REG2B, regv);
+		snd_soc_component_write(component, ES8396_HP_MIXER_BOOST_REG2B, regv);
 		break;
 	default:
 		break;
@@ -744,6 +715,7 @@ static int hpamp_event(struct snd_soc_dapm_widget *w,
 
 	return 0;
 }
+
 /*
  * ES8396 Controls
  */
@@ -849,7 +821,7 @@ static const struct snd_kcontrol_new es8396_hpr_mixer_controls[] = {
 /*
  * Only used mono out p mixer for differential output
  */
-static const struct snd_kcontrol_new es8396_monoP_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_mono_p_mixer_controls[] = {
 	SOC_DAPM_SINGLE("LHPMIX2MNMIXP Switch", ES8396_MONOHP_P_MIXER_REG47, 7,
 			1, 0),
 	SOC_DAPM_SINGLE("RHPMIX2MNOMIXP Switch", ES8396_MONOHP_P_MIXER_REG47, 6,
@@ -862,7 +834,7 @@ static const struct snd_kcontrol_new es8396_monoP_mixer_controls[] = {
 			ES8396_MONOHP_P_MIXER_REG47, 3, 1, 0),
 };
 
-static const struct snd_kcontrol_new es8396_monoN_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_mono_n_mixer_controls[] = {
 	SOC_DAPM_SINGLE("LMNMIX2MNMIXN Switch", ES8396_MONOHP_N_MIXER_REG46, 7,
 			1, 0),
 	SOC_DAPM_SINGLE("RHPMIX2MNOMIXN Switch", ES8396_MONOHP_N_MIXER_REG46, 6,
@@ -926,51 +898,47 @@ static const struct snd_kcontrol_new es8396_rout1_mixer_controls[] = {
 /*
  *left LNMIX mixer
  */
-static const struct snd_kcontrol_new es8396_lnmixL_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_lnmix_l_mixer_controls[] = {
 	SOC_DAPM_SINGLE("AINL2LLNMIX Switch", ES8396_LN_MIXER_REG32, 7, 1, 0),
 	SOC_DAPM_SINGLE("LLNMUX2LLNMIX Switch", ES8396_LN_MIXER_REG32, 6, 1, 0),
 	SOC_DAPM_SINGLE("MIC1P2LLNMIX Switch", ES8396_LN_MIXER_REG32, 5, 1, 0),
-	SOC_DAPM_SINGLE("PMICDSE2LLNMIX Switch", ES8396_LN_MIXER_REG32, 4, 1,
-			0),
+	SOC_DAPM_SINGLE("PMICDSE2LLNMIX Switch", ES8396_LN_MIXER_REG32, 4, 1, 0),
 };
 
 /*
  *right LNMIX mixer
  */
-static const struct snd_kcontrol_new es8396_lnmixR_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_lnmix_r_mixer_controls[] = {
 	SOC_DAPM_SINGLE("AINR2RLNMIX Switch", ES8396_LN_MIXER_REG32, 3, 1, 0),
 	SOC_DAPM_SINGLE("RLNMUX2RLNMIX Switch", ES8396_LN_MIXER_REG32, 2, 1, 0),
 	SOC_DAPM_SINGLE("MIC1N2LLNMIX Switch", ES8396_LN_MIXER_REG32, 1, 1, 0),
-	SOC_DAPM_SINGLE("NMICDSE2RLNMIX Switch", ES8396_LN_MIXER_REG32, 0, 1,
-			0),
+	SOC_DAPM_SINGLE("NMICDSE2RLNMIX Switch", ES8396_LN_MIXER_REG32, 0, 1, 0),
 };
 
 /*
  *left AXMIX mixer
  */
-static const struct snd_kcontrol_new es8396_axmixL_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_axmix_l_mixer_controls[] = {
 	SOC_DAPM_SINGLE("LAXMUX2LAXMIX Switch", ES8396_AX_MIXER_REG2E, 7, 1, 0),
 	SOC_DAPM_SINGLE("MONOP2LAXMIX Switch", ES8396_AX_MIXER_REG2E, 6, 1, 0),
 	SOC_DAPM_SINGLE("MIC2P2LAXMIX Switch", ES8396_AX_MIXER_REG2E, 5, 1, 0),
-	SOC_DAPM_SINGLE("PMICDSE2LAXMIX Switch", ES8396_AX_MIXER_REG2E, 4, 1,
-			0),
+	SOC_DAPM_SINGLE("PMICDSE2LAXMIX Switch", ES8396_AX_MIXER_REG2E, 4, 1, 0),
 };
 
 /*
  *right AXMIX mixer
  */
-static const struct snd_kcontrol_new es8396_axmixR_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_axmix_r_mixer_controls[] = {
 	SOC_DAPM_SINGLE("RAXMUX2RAXMIX Switch", ES8396_AX_MIXER_REG2E, 3, 1, 0),
 	SOC_DAPM_SINGLE("MONON2RAXMIX Switch", ES8396_AX_MIXER_REG2E, 2, 1, 0),
 	SOC_DAPM_SINGLE("MIC2N2RAXMIX Switch", ES8396_AX_MIXER_REG2E, 1, 1, 0),
-	SOC_DAPM_SINGLE("NMICDSE2RAXMIX Switch", ES8396_AX_MIXER_REG2E, 0, 1,
-			0),
+	SOC_DAPM_SINGLE("NMICDSE2RAXMIX Switch", ES8396_AX_MIXER_REG2E, 0, 1, 0),
 };
 
 /*
  *left MNMIX mixer
  */
-static const struct snd_kcontrol_new es8396_mnmixL_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_mnmix_l_mixer_controls[] = {
 	SOC_DAPM_SINGLE("LDAC2LMNMIX Switch", ES8396_MN_MIXER_REG36, 7, 1, 0),
 	SOC_DAPM_SINGLE("MONOP2LMNMIX Switch", ES8396_MN_MIXER_REG36, 6, 1, 0),
 	SOC_DAPM_SINGLE("AINL2LMNMIX Switch", ES8396_MN_MIXER_REG36, 5, 1, 0),
@@ -979,7 +947,7 @@ static const struct snd_kcontrol_new es8396_mnmixL_mixer_controls[] = {
 /*
  *right MNMIX mixer
  */
-static const struct snd_kcontrol_new es8396_mnmixR_mixer_controls[] = {
+static const struct snd_kcontrol_new es8396_mnmix_r_mixer_controls[] = {
 	SOC_DAPM_SINGLE("RDAC2RMNMIX Switch", ES8396_MN_MIXER_REG36, 3, 1, 0),
 	SOC_DAPM_SINGLE("MONON2RMNMIX Switch", ES8396_MN_MIXER_REG36, 2, 1, 0),
 	SOC_DAPM_SINGLE("AINR2RMNMIX Switch", ES8396_MN_MIXER_REG36, 1, 1, 0),
@@ -988,34 +956,24 @@ static const struct snd_kcontrol_new es8396_mnmixR_mixer_controls[] = {
 /*
  * Left Record Mixer
  */
-static const struct snd_kcontrol_new es8396_captureL_mixer_controls[] = {
-	SOC_DAPM_SINGLE("RLNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 7, 1,
-			0),
-	SOC_DAPM_SINGLE("RAXMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 6, 1,
-			0),
-	SOC_DAPM_SINGLE("RMNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 5, 1,
-			0),
-	SOC_DAPM_SINGLE("LMNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 4, 1,
-			0),
-	SOC_DAPM_SINGLE("LLNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 3, 1,
-			0),
+static const struct snd_kcontrol_new es8396_capture_l_mixer_controls[] = {
+	SOC_DAPM_SINGLE("RLNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 7, 1, 0),
+	SOC_DAPM_SINGLE("RAXMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 6, 1, 0),
+	SOC_DAPM_SINGLE("RMNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 5, 1, 0),
+	SOC_DAPM_SINGLE("LMNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 4, 1, 0),
+	SOC_DAPM_SINGLE("LLNMIX2LPGA Switch", ES8396_ADC_LPGA_MIXER_REG62, 3, 1, 0),
 
 };
 
 /*
  * Right Record Mixer
  */
-static const struct snd_kcontrol_new es8396_captureR_mixer_controls[] = {
-	SOC_DAPM_SINGLE("RLNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 7, 1,
-			0),
-	SOC_DAPM_SINGLE("RAXMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 6, 1,
-			0),
-	SOC_DAPM_SINGLE("RMNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 5, 1,
-			0),
-	SOC_DAPM_SINGLE("LMNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 4, 1,
-			0),
-	SOC_DAPM_SINGLE("LAXMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 3, 1,
-			0),
+static const struct snd_kcontrol_new es8396_capture_r_mixer_controls[] = {
+	SOC_DAPM_SINGLE("RLNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 7, 1, 0),
+	SOC_DAPM_SINGLE("RAXMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 6, 1, 0),
+	SOC_DAPM_SINGLE("RMNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 5, 1, 0),
+	SOC_DAPM_SINGLE("LMNMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 4, 1, 0),
+	SOC_DAPM_SINGLE("LAXMIX2RPGA Switch", ES8396_ADC_RPGA_MIXER_REG63, 3, 1, 0),
 };
 
 static const struct snd_kcontrol_new es8396_adc_controls =
@@ -1380,14 +1338,14 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	SND_SOC_DAPM_AIF_OUT("MASTERSDPOR", "SDP2 Capture", 0,
 			     ES8396_SDP2_OUT_FMT_REG23, 6, 1),
 	SND_SOC_DAPM_MUX("MASTERSDPO Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_i2s2_out_mux_controls),
+			 &es8396_i2s2_out_mux_controls),
 
 	SND_SOC_DAPM_AIF_OUT("AUXSDPOL", "SDP3 Capture", 0,
 			     ES8396_SDP3_OUT_FMT_REG25, 6, 1),
 	SND_SOC_DAPM_AIF_OUT("AUXSDPOR", "SDP3 Capture", 0,
 			     ES8396_SDP3_OUT_FMT_REG25, 6, 1),
 	SND_SOC_DAPM_MUX("AUXSDPO Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_i2s3_out_mux_controls),
+			 &es8396_i2s3_out_mux_controls),
 
 	SND_SOC_DAPM_MIXER("VOICEOUT AIF Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("MASTEROUT AIF Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
@@ -1399,13 +1357,13 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	 *left and right mixer
 	 */
 	SND_SOC_DAPM_MIXER_NAMED_CTL("PGA Left Mix", SND_SOC_NOPM, 0, 0,
-				     &es8396_captureL_mixer_controls[0],
+				     &es8396_capture_l_mixer_controls[0],
 				     ARRAY_SIZE
-				     (es8396_captureL_mixer_controls)),
+				     (es8396_capture_l_mixer_controls)),
 	SND_SOC_DAPM_MIXER_NAMED_CTL("PGA Right Mix", SND_SOC_NOPM, 0, 0,
-				     &es8396_captureR_mixer_controls[0],
+				     &es8396_capture_r_mixer_controls[0],
 				     ARRAY_SIZE
-				     (es8396_captureR_mixer_controls)),
+				     (es8396_capture_r_mixer_controls)),
 
 	SND_SOC_DAPM_PGA("LPGA P", ES8396_ADC_ANALOG_CTRL_REG5E, 4, 1, NULL, 0),
 	SND_SOC_DAPM_PGA("RPGA P", ES8396_ADC_ANALOG_CTRL_REG5E, 5, 1, NULL, 0),
@@ -1428,16 +1386,16 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	 * LN MUX
 	 */
 	SND_SOC_DAPM_MUX("LLN Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_left_lnmux_controls),
+			 &es8396_left_lnmux_controls),
 	SND_SOC_DAPM_MUX("RLN Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_right_lnmux_controls),
+			 &es8396_right_lnmux_controls),
 	/*
 	 * AX MUX
 	 */
 	SND_SOC_DAPM_MUX("LAX Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_left_axmux_controls),
+			 &es8396_left_axmux_controls),
 	SND_SOC_DAPM_MUX("RAX Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_right_axmux_controls),
+			 &es8396_right_axmux_controls),
 	/*
 	 * AIF IN
 	 */
@@ -1460,20 +1418,20 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	 * Digital mixer1,2
 	 */
 	SND_SOC_DAPM_MUX("LDMIX1 Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_left_digital_mixer_controls),
+			 &es8396_left_digital_mixer_controls),
 	SND_SOC_DAPM_MUX("RDMIX1 Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_right_digital_mixer_controls),
+			 &es8396_right_digital_mixer_controls),
 	SND_SOC_DAPM_MUX("LDMIX2 Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_left_digital2_mixer_controls),
+			 &es8396_left_digital2_mixer_controls),
 	SND_SOC_DAPM_MUX("RDMIX2 Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_right_digital2_mixer_controls),
+			 &es8396_right_digital2_mixer_controls),
 
 	SND_SOC_DAPM_MIXER("Digital Left Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("Digital Right Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("Equalizer", SND_SOC_NOPM, 0, 0, NULL, 0),
 
 	SND_SOC_DAPM_MUX("DACSRC Mux", SND_SOC_NOPM, 0, 0,
-			       &es8396_dac_src_mux_controls),
+			 &es8396_dac_src_mux_controls),
 	/*
 	 * DAC
 	 */
@@ -1487,34 +1445,34 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	 * mixerMono
 	 */
 	SND_SOC_DAPM_MIXER("LMONIN Mix", ES8396_MN_MIXER_BOOST_REG37, 4, 1,
-			   &es8396_mnmixL_mixer_controls[0],
-			   ARRAY_SIZE(es8396_mnmixL_mixer_controls)),
+			   &es8396_mnmix_l_mixer_controls[0],
+			   ARRAY_SIZE(es8396_mnmix_l_mixer_controls)),
 	SND_SOC_DAPM_PGA("LMONINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("RMONIN Mix", ES8396_MN_MIXER_BOOST_REG37, 0, 1,
-			   &es8396_mnmixR_mixer_controls[0],
-			   ARRAY_SIZE(es8396_mnmixR_mixer_controls)),
+			   &es8396_mnmix_r_mixer_controls[0],
+			   ARRAY_SIZE(es8396_mnmix_r_mixer_controls)),
 	SND_SOC_DAPM_PGA("RMONINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	/*
 	 * mixerLN
 	 */
 	SND_SOC_DAPM_MIXER("LLNIN Mix", ES8396_LN_MIXER_BOOST_REG33, 4, 1,
-			   &es8396_lnmixL_mixer_controls[0],
-			   ARRAY_SIZE(es8396_lnmixL_mixer_controls)),
+			   &es8396_lnmix_l_mixer_controls[0],
+			   ARRAY_SIZE(es8396_lnmix_l_mixer_controls)),
 	SND_SOC_DAPM_PGA("LLNINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("RLNIN Mix", ES8396_LN_MIXER_BOOST_REG33, 0, 1,
-			   &es8396_lnmixR_mixer_controls[0],
-			   ARRAY_SIZE(es8396_lnmixR_mixer_controls)),
+			   &es8396_lnmix_r_mixer_controls[0],
+			   ARRAY_SIZE(es8396_lnmix_r_mixer_controls)),
 	SND_SOC_DAPM_PGA("RLNINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	/*
 	 * mixerAX
 	 */
 	SND_SOC_DAPM_MIXER("LAXIN Mix", ES8396_AX_MIXER_BOOST_REG2F, 4, 1,
-			   &es8396_axmixL_mixer_controls[0],
-			   ARRAY_SIZE(es8396_axmixL_mixer_controls)),
+			   &es8396_axmix_l_mixer_controls[0],
+			   ARRAY_SIZE(es8396_axmix_l_mixer_controls)),
 	SND_SOC_DAPM_PGA("LAXINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	SND_SOC_DAPM_MIXER("RAXIN Mix", ES8396_AX_MIXER_BOOST_REG2F, 0, 1,
-			   &es8396_axmixR_mixer_controls[0],
-			   ARRAY_SIZE(es8396_axmixR_mixer_controls)),
+			   &es8396_axmix_r_mixer_controls[0],
+			   ARRAY_SIZE(es8396_axmix_r_mixer_controls)),
 	SND_SOC_DAPM_PGA("RAXINMIX PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
 	/*
 	 * mixerLNOUT
@@ -1534,13 +1492,13 @@ static const struct snd_soc_dapm_widget es8396_dapm_widgets[] = {
 	 * mixerMNOUT
 	 */
 	SND_SOC_DAPM_MIXER("MNOUTP Mix", SND_SOC_NOPM, 0, 0,
-			   &es8396_monoP_mixer_controls[0],
-			   ARRAY_SIZE(es8396_monoP_mixer_controls)),
+			   &es8396_mono_p_mixer_controls[0],
+			   ARRAY_SIZE(es8396_mono_p_mixer_controls)),
 	SND_SOC_DAPM_PGA("MNOUTP PGA", ES8396_MONOHP_P_BOOST_MUTE_REG48, 7, 0,
 			 NULL, 0),
 	SND_SOC_DAPM_MIXER("MNOUTN Mix", SND_SOC_NOPM, 0, 0,
-			   &es8396_monoN_mixer_controls[0],
-			   ARRAY_SIZE(es8396_monoN_mixer_controls)),
+			   &es8396_mono_n_mixer_controls[0],
+			   ARRAY_SIZE(es8396_mono_n_mixer_controls)),
 	SND_SOC_DAPM_PGA("MNOUTN PGA", ES8396_MONOHP_N_BOOST_MUTE_REG49, 7, 0,
 			 NULL, 0),
 
@@ -1987,8 +1945,8 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 			  unsigned int freq_out)
 {
 	int i;
-	struct snd_soc_codec *codec = dai->codec;
-	struct es8396_private *priv = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *priv = snd_soc_component_get_drvdata(component);
 	u16 reg;
 	u8 N, K1, K2, K3, mclk_div, pll_div, tmp;
 
@@ -1999,7 +1957,7 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 		return -EINVAL;
 	}
 	/* Disable PLL, power down and hold in reset state */
-	snd_soc_write(codec, ES8396_PLL_CTRL_1_REG02, 0x81);
+	snd_soc_component_write(component, ES8396_PLL_CTRL_1_REG02, 0x81);
 
 	if (!freq_in || !freq_out)
 		return 0;
@@ -2009,39 +1967,39 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 		/* Allow no source specification when stopping */
 		if (freq_out)
 			return -EINVAL;
-		reg = snd_soc_read(codec, ES8396_CLK_SRC_SEL_REG01);
+		reg = snd_soc_component_read32(component, ES8396_CLK_SRC_SEL_REG01);
 		reg &= 0xF0;
 		if (source == 0)
 			reg |= 0x01;	/* clksrc2= 0, clksrc1 = 1 */
 		else
 			reg |= 0x09;	/* clksrc2= 1, clksrc1 = 1 */
 
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, reg);
-		reg = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, reg);
+		reg = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		reg |= 0x0F;
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, reg);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, reg);
 		pr_debug("ES8396 PLL No Clock source\n");
 		break;
 	case ES8396_PLL_SRC_FRM_MCLK:
-		reg = snd_soc_read(codec, ES8396_CLK_SRC_SEL_REG01);
+		reg = snd_soc_component_read32(component, ES8396_CLK_SRC_SEL_REG01);
 		reg &= 0xF3;
 		reg |= 0x04;	/* clksrc2= mclk */
 		/* use clk2 for pll clk source */
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, reg);
-		reg = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, reg);
+		reg = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		reg |= 0x0F;
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, reg);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, reg);
 		pr_debug("ES8396 PLL Clock Source from MCLK pin\n");
 		break;
 	case ES8396_PLL_SRC_FRM_BCLK:
-		reg = snd_soc_read(codec, ES8396_CLK_SRC_SEL_REG01);
+		reg = snd_soc_component_read32(component, ES8396_CLK_SRC_SEL_REG01);
 		reg &= 0xF3;
 		reg |= 0x0c;	/* clksrc2= bclk, */
 		/* use clk2 for pll clk source */
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, reg);
-		reg = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, reg);
+		reg = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		reg |= 0x0F;
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, reg);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, reg);
 		pr_debug("ES8396 PLL Clock Source from BCLK signal\n");
 		break;
 	default:
@@ -2049,8 +2007,8 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 	}
 	/* get N & K */
 	tmp = 0;
-	if ((source == ES8396_PLL_SRC_FRM_MCLK) ||
-	    (source == ES8396_PLL_SRC_FRM_BCLK)) {
+	if (source == ES8396_PLL_SRC_FRM_MCLK ||
+	    source == ES8396_PLL_SRC_FRM_BCLK) {
 		for (i = 0; i < ARRAY_SIZE(codec_pll_div); i++) {
 			if (codec_pll_div[i].pll_in == freq_in &&
 			    codec_pll_div[i].pll_out == freq_out) {
@@ -2072,63 +2030,63 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 			pr_debug("N=%d, K3=%d, K2=%d, K1=%d\n", N, K3, K2, K1);
 
 			/* set N & K */
-			snd_soc_write(codec, ES8396_PLL_N_REG04, N);
-			snd_soc_write(codec, ES8396_PLL_K2_REG05, K3);
-			snd_soc_write(codec, ES8396_PLL_K1_REG06, K2);
-			snd_soc_write(codec, ES8396_PLL_K0_REG07, K1);
+			snd_soc_component_write(component, ES8396_PLL_N_REG04, N);
+			snd_soc_component_write(component, ES8396_PLL_K2_REG05, K3);
+			snd_soc_component_write(component, ES8396_PLL_K1_REG06, K2);
+			snd_soc_component_write(component, ES8396_PLL_K0_REG07, K1);
 			if (mclk_div == 1)
 				/* mclk div2 = 0 */
-				snd_soc_update_bits(codec,
-						    ES8396_CLK_SRC_SEL_REG01,
+				snd_soc_component_update_bits(component,
+							      ES8396_CLK_SRC_SEL_REG01,
 						    0x10, 0x00);
 			else
 				/* mclk div2 = 1 */
-				snd_soc_update_bits(codec,
-						    ES8396_CLK_SRC_SEL_REG01,
+				snd_soc_component_update_bits(component,
+							      ES8396_CLK_SRC_SEL_REG01,
 						    0x10, 0x10);
 
 			/* pll div 8 */
-			snd_soc_update_bits(codec, ES8396_PLL_CTRL_1_REG02,
-					    0x3, 0x01);
+			snd_soc_component_update_bits(component, ES8396_PLL_CTRL_1_REG02,
+						      0x3, 0x01);
 
 			/* configure the pll power voltage  */
 			switch (priv->dvdd_pwr_vol) {
 			case 0x18:
 				/* dvdd=1.8v */
-				snd_soc_update_bits(codec,
-						    ES8396_PLL_CTRL_2_REG03,
+				snd_soc_component_update_bits(component,
+							      ES8396_PLL_CTRL_2_REG03,
 						    0x0c, 0x00);
 				break;
 			case 0x25:
 				/* dvdd=2.5v */
-				snd_soc_update_bits(codec,
-						    ES8396_PLL_CTRL_2_REG03,
+				snd_soc_component_update_bits(component,
+							      ES8396_PLL_CTRL_2_REG03,
 						    0x0c, 0x04);
 				break;
 			case 0x33:
 				/* dvdd=3.3v */
-				snd_soc_update_bits(codec,
-						    ES8396_PLL_CTRL_2_REG03,
+				snd_soc_component_update_bits(component,
+							      ES8396_PLL_CTRL_2_REG03,
 						    0x0c, 0x08);
 				break;
 			default:
 				/* dvdd=1.8v */
-				snd_soc_update_bits(codec,
-						    ES8396_PLL_CTRL_2_REG03,
+				snd_soc_component_update_bits(component,
+							      ES8396_PLL_CTRL_2_REG03,
 						    0x0c, 0x00);
 				break;
 			}
 			/* enable PLL analog power up  */
-			snd_soc_update_bits(codec, ES8396_PLL_CTRL_1_REG02,
-					    0x80, 0x00);
+			snd_soc_component_update_bits(component, ES8396_PLL_CTRL_1_REG02,
+						      0x80, 0x00);
 			/* pll digital on */
-			snd_soc_update_bits(codec, ES8396_PLL_CTRL_1_REG02,
-					    0x40, 0x40);
+			snd_soc_component_update_bits(component, ES8396_PLL_CTRL_1_REG02,
+						      0x40, 0x40);
 			priv->mclk[dai->id - 1] = freq_out;
-			snd_soc_write(codec, ES8396_PLL_N_REG04, 0x08);
-			snd_soc_write(codec, ES8396_PLL_K2_REG05, 0X1D);
-			snd_soc_write(codec, ES8396_PLL_K1_REG06, 0XC3);
-			snd_soc_write(codec, ES8396_PLL_K0_REG07, 0XB8);
+			snd_soc_component_write(component, ES8396_PLL_N_REG04, 0x08);
+			snd_soc_component_write(component, ES8396_PLL_K2_REG05, 0X1D);
+			snd_soc_component_write(component, ES8396_PLL_K1_REG06, 0XC3);
+			snd_soc_component_write(component, ES8396_PLL_K0_REG07, 0XB8);
 		} else {
 			pr_debug("Can not find the correct clock frequency!!!!!\n");
 		}
@@ -2143,8 +2101,8 @@ static int es8396_set_pll(struct snd_soc_dai *dai, int pll_id,
 static int es8396_set_dai_sysclk(struct snd_soc_dai *dai,
 				 int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct es8396_private *priv = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *priv = snd_soc_component_get_drvdata(component);
 	u8 reg;
 
 	switch (dai->id) {
@@ -2154,45 +2112,44 @@ static int es8396_set_dai_sysclk(struct snd_soc_dai *dai,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	switch (clk_id) {
 	/* the clock source form MCLK pin, don't use PLL */
 	case ES8396_CLKID_MCLK:
-		reg = snd_soc_read(codec, ES8396_CLK_SRC_SEL_REG01);
+		reg = snd_soc_component_read32(component, ES8396_CLK_SRC_SEL_REG01);
 		reg &= 0xFC;
 		reg |= 0x00;	/* clksrc1= mclk */
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, reg);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, reg);
 
 		/* always use clk1 */
-		reg = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		reg = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		reg &= 0xf0;
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, reg);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, reg);
 
 		priv->sysclk[dai->id] = clk_id;
 		priv->mclk[dai->id] = freq;
 		if (freq > 19600000) {
 			/* mclk div2 */
-			snd_soc_update_bits(codec, ES8396_CLK_SRC_SEL_REG01,
-					    0x10, 0x10);
+			snd_soc_component_update_bits(component, ES8396_CLK_SRC_SEL_REG01,
+						      0x10, 0x10);
 		}
 		switch (dai->id) {
 		case ES8396_SDP1:
 			/* bclkdiv m1 use clk1 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M1_REG0E,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M1_REG0E,
+						      0x20, 0x00);
 			/* lrckdiv m3 use clk1 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M3_REG10,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M3_REG10,
+						      0x20, 0x00);
 			break;
 		case ES8396_SDP2:
 		case ES8396_SDP3:
 			/* bclkdiv m1 use clk1 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M2_REG0F,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M2_REG0F,
+						      0x20, 0x00);
 			/* lrckdiv m4 use clk1 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M4_REG11,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M4_REG11,
+						      0x20, 0x00);
 			break;
 		default:
 			break;
@@ -2201,39 +2158,39 @@ static int es8396_set_dai_sysclk(struct snd_soc_dai *dai,
 		break;
 	/* the clock source form internal BCLK signal, don't use PLL */
 	case ES8396_CLKID_BCLK:
-		reg = snd_soc_read(codec, ES8396_CLK_SRC_SEL_REG01);
+		reg = snd_soc_component_read32(component, ES8396_CLK_SRC_SEL_REG01);
 		reg &= 0xFC;
 		reg |= 0x03;	/* clksrc1= bclk */
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, reg);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, reg);
 		/* always use clk1 */
-		reg = snd_soc_read(codec, ES8396_CLK_CTRL_REG08);
+		reg = snd_soc_component_read32(component, ES8396_CLK_CTRL_REG08);
 		reg &= 0xf0;
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, reg);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, reg);
 
 		priv->sysclk[dai->id] = clk_id;
 		priv->mclk[dai->id] = freq;
 		if (freq > 19600000) {
 			/* mclk div2 */
-			snd_soc_update_bits(codec, ES8396_CLK_SRC_SEL_REG01,
-					    0x10, 0x10);
+			snd_soc_component_update_bits(component, ES8396_CLK_SRC_SEL_REG01,
+						      0x10, 0x10);
 		}
 		switch (dai->id) {
 		case ES8396_SDP1:
 			/* bclkdiv m1 use clk1 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M1_REG0E,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M1_REG0E,
+						      0x20, 0x00);
 			/* lrckdiv m3 use clk1 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M3_REG10,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M3_REG10,
+						      0x20, 0x00);
 			break;
 		case ES8396_SDP2:
 		case ES8396_SDP3:
 			/* bclkdiv m1 use clk1 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M2_REG0F,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M2_REG0F,
+						      0x20, 0x00);
 			/* lrckdiv m4 use clk1 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M4_REG11,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M4_REG11,
+						      0x20, 0x00);
 			break;
 		default:
 			break;
@@ -2245,27 +2202,27 @@ static int es8396_set_dai_sysclk(struct snd_soc_dai *dai,
 		switch (dai->id) {
 		case ES8396_SDP1:
 			/* bclkdiv m1 use clk1 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M1_REG0E,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M1_REG0E,
+						      0x20, 0x00);
 			/* lrckdiv m3 use clk1 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M3_REG10,
-					    0x20, 0x00);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M3_REG10,
+						      0x20, 0x00);
 			break;
 		case ES8396_SDP2:
 			/* bclkdiv m1 use clk2 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M1_REG0E,
-					    0x20, 0x20);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M1_REG0E,
+						      0x20, 0x20);
 			/* lrckdiv m3 use clk2 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M3_REG10,
-					    0x20, 0x20);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M3_REG10,
+						      0x20, 0x20);
 			break;
 		case ES8396_SDP3:
 			/* bclkdiv m1 use clk2 */
-			snd_soc_update_bits(codec, ES8396_BCLK_DIV_M2_REG0F,
-					    0x20, 0x20);
+			snd_soc_component_update_bits(component, ES8396_BCLK_DIV_M2_REG0F,
+						      0x20, 0x20);
 			/* lrckdiv m4 use clk2 */
-			snd_soc_update_bits(codec, ES8396_LRCK_DIV_M4_REG11,
-					    0x20, 0x20);
+			snd_soc_component_update_bits(component, ES8396_LRCK_DIV_M4_REG11,
+						      0x20, 0x20);
 			break;
 		default:
 			break;
@@ -2336,24 +2293,24 @@ static struct es8396_mclk_div es8396_mclk_coeffs[] = {
 
 static int es8396_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct es8396_private *priv = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8396_private *priv = snd_soc_component_get_drvdata(component);
 	u8 id = codec_dai->id;
 	unsigned int inv, format;
 	u8 spc, mmcc;
 
 	switch (id) {
 	case ES8396_SDP1:
-		spc = snd_soc_read(codec, ES8396_SDP1_IN_FMT_REG1F) & 0x3f;
-		mmcc = snd_soc_read(codec, ES8396_SDP_1_MS_REG12);
+		spc = snd_soc_component_read32(component, ES8396_SDP1_IN_FMT_REG1F) & 0x3f;
+		mmcc = snd_soc_component_read32(component, ES8396_SDP_1_MS_REG12);
 		break;
 	case ES8396_SDP2:
-		spc = snd_soc_read(codec, ES8396_SDP2_IN_FMT_REG22) & 0x3f;
-		mmcc = snd_soc_read(codec, ES8396_SDP_2_MS_REG13);
+		spc = snd_soc_component_read32(component, ES8396_SDP2_IN_FMT_REG22) & 0x3f;
+		mmcc = snd_soc_component_read32(component, ES8396_SDP_2_MS_REG13);
 		break;
 	case ES8396_SDP3:
-		spc = snd_soc_read(codec, ES8396_SDP3_IN_FMT_REG24) & 0x3f;
-		mmcc = snd_soc_read(codec, ES8396_SDP_3_MS_REG14);
+		spc = snd_soc_component_read32(component, ES8396_SDP3_IN_FMT_REG24) & 0x3f;
+		mmcc = snd_soc_component_read32(component, ES8396_SDP_3_MS_REG14);
 		break;
 	default:
 		return -EINVAL;
@@ -2414,7 +2371,7 @@ static int es8396_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 		return -EINVAL;
 	}
 
-	snd_soc_write(codec, ES8396_SDP1_IN_FMT_REG1F, 00);
+	snd_soc_component_write(component, ES8396_SDP1_IN_FMT_REG1F, 00);
 	pr_debug("es8396_set_dai_fmt-->\n");
 
 	priv->config[id].spc = spc;
@@ -2427,8 +2384,8 @@ static int es8396_pcm_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params,
 				struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct es8396_private *priv = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *priv = snd_soc_component_get_drvdata(component);
 	int id = dai->id;
 	int mclk_coeff = 0;
 	int srate = params_rate(params);
@@ -2441,28 +2398,28 @@ static int es8396_pcm_hw_params(struct snd_pcm_substream *substream,
 
 	switch (id) {
 	case ES8396_SDP1:
-		bdiv = snd_soc_read(codec, ES8396_BCLK_DIV_M2_REG0F);
+		bdiv = snd_soc_component_read32(component, ES8396_BCLK_DIV_M2_REG0F);
 		bdiv &= 0xe0;
 		bdiv |= es8396_mclk_coeffs[mclk_coeff].bclkdiv;
-		lrdiv = snd_soc_read(codec, ES8396_LRCK_DIV_M4_REG11);
+		lrdiv = snd_soc_component_read32(component, ES8396_LRCK_DIV_M4_REG11);
 		lrdiv &= 0xe0;
 		lrdiv |= 0x22;	/* es8396_mclk_coeffs[mclk_coeff].lrcdiv; */
-		snd_soc_write(codec, ES8396_BCLK_DIV_M2_REG0F, bdiv);
-		snd_soc_write(codec, ES8396_LRCK_DIV_M4_REG11, lrdiv);
+		snd_soc_component_write(component, ES8396_BCLK_DIV_M2_REG0F, bdiv);
+		snd_soc_component_write(component, ES8396_LRCK_DIV_M4_REG11, lrdiv);
 		priv->config[id].srate = srate;
 		priv->config[id].lrcdiv = lrdiv;
 		priv->config[id].sclkdiv = bdiv;
 		break;
 	case ES8396_SDP2:
 	case ES8396_SDP3:
-		bdiv = snd_soc_read(codec, ES8396_BCLK_DIV_M1_REG0E);
+		bdiv = snd_soc_component_read32(component, ES8396_BCLK_DIV_M1_REG0E);
 		bdiv &= 0xe0;
 		bdiv |= es8396_mclk_coeffs[mclk_coeff].bclkdiv;
-		lrdiv = snd_soc_read(codec, ES8396_LRCK_DIV_M3_REG10);
+		lrdiv = snd_soc_component_read32(component, ES8396_LRCK_DIV_M3_REG10);
 		lrdiv &= 0xe0;
 		lrdiv |= es8396_mclk_coeffs[mclk_coeff].lrcdiv;
-		snd_soc_write(codec, ES8396_BCLK_DIV_M1_REG0E, bdiv);
-		snd_soc_write(codec, ES8396_LRCK_DIV_M3_REG10, lrdiv);
+		snd_soc_component_write(component, ES8396_BCLK_DIV_M1_REG0E, bdiv);
+		snd_soc_component_write(component, ES8396_LRCK_DIV_M3_REG10, lrdiv);
 		priv->config[id].srate = srate;
 		priv->config[id].lrcdiv = lrdiv;
 		priv->config[id].sclkdiv = bdiv;
@@ -2474,27 +2431,23 @@ static int es8396_pcm_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int es8396_set_bias_level(struct snd_soc_codec *codec,
+static int es8396_set_bias_level(struct snd_soc_component *component,
 				 enum snd_soc_bias_level level)
 {
 	u8 value;
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
-
-	printk("es8396_set_bias_level = 0x%x\n",
-                 snd_soc_codec_get_bias_level(codec));
-	printk("bias_level = %d\n", level);
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		/*
-		 * dac csm startup, dac digital still oN
-		 * snd_soc_update_bits(codec, ES8396_DAC_CSM_REG66, 0xFF, 0x00);
+		 * dac csm startup, dac digital still on
+		 * snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0xFF, 0x00);
 		 * dac analog power on
-		 * snd_soc_update_bits(codec, ES8396_DAC_REF_PWR_CTRL_REG6E,
+		 * snd_soc_component_update_bits(component, ES8396_DAC_REF_PWR_CTRL_REG6E,
 		 * 0xff, 0x00);
 		 */
-		snd_soc_write(codec, 0x4E, 0x80);
-		snd_soc_write(codec, 0x4F, 0x81);
+		snd_soc_component_write(component, 0x4E, 0x80);
+		snd_soc_component_write(component, 0x4F, 0x81);
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
@@ -2502,21 +2455,21 @@ static int es8396_set_bias_level(struct snd_soc_codec *codec,
 
 	case SND_SOC_BIAS_STANDBY:
 		if (es8396->aif1_select == 0 && es8396->aif2_select == 0) {
-			if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
-				snd_soc_write(codec, ES8396_SYS_VMID_REF_REG71,
-					      0xFF);
+			if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
+				snd_soc_component_write(component, ES8396_SYS_VMID_REF_REG71,
+							0xFF);
 				if (es8396_valid_analdo(es8396->ana_ldo_lvl)) {
 					value = es8396->ana_ldo_lvl;
 					value &= 0x07;
-					snd_soc_write(codec, 0x70, value);
+					snd_soc_component_write(component, 0x70, value);
 				}
 			}
 		}
 		/*
 		 * dac csm startup, dac digital still stop
-		 * snd_soc_update_bits(codec, ES8396_DAC_CSM_REG66, 0xFF, 0x04);
+		 * snd_soc_component_update_bits(component, ES8396_DAC_CSM_REG66, 0xFF, 0x04);
 		 * adc csm startup, adc digital still stop
-		 * snd_soc_update_bits(codec, ES8396_ADC_CSM_REG53, 0xFF, 0x00);
+		 * snd_soc_component_update_bits(component, ES8396_ADC_CSM_REG53, 0xFF, 0x00);
 		 */
 		break;
 
@@ -2529,15 +2482,15 @@ static int es8396_set_bias_level(struct snd_soc_codec *codec,
 
 static int es8396_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	struct snd_soc_codec *codec = dai->codec;
+	struct snd_soc_component *component = dai->component;
 	int id = dai->id;
 
 	pr_debug("es8396_set_tristate\n");
 	pr_debug("ES8396 SDP NUM = %d\n", id);
 	switch (id) {
 	case ES8396_SDP1:
-		return snd_soc_update_bits(codec, ES8396_SDP1_DGAIN_TDM_REG21,
-					   0x0a, 0x0a);
+		return snd_soc_component_update_bits(component, ES8396_SDP1_DGAIN_TDM_REG21,
+						     0x0a, 0x0a);
 	case ES8396_SDP2:
 	case ES8396_SDP3:
 		pr_err("SDP NUM = %d, Can not support tristate\n", id);
@@ -2551,12 +2504,14 @@ static int es8396_pcm_startup(struct snd_pcm_substream *substream,
 			      struct snd_soc_dai *dai)
 {
 	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 	int ret;
 	int regv;
 	int i;
+
 	pr_debug(">>>>>>>>es8396_pcm_startup\n");
-	ret = snd_soc_read(tron_codec, ES8396_ADC_CSM_REG53);
+	ret = snd_soc_component_read32(component, ES8396_ADC_CSM_REG53);
 	pr_debug("ES8396_ADC_CSM_REG53===0x%x\n", ret);
 	/*
 	 * set the clock source to MCLK pin
@@ -2566,32 +2521,32 @@ static int es8396_pcm_startup(struct snd_pcm_substream *substream,
 	if ((es8396->aif2_select & 0x01) == 0) {
 		pr_debug(">>>>>>>>es8396_pcm_startup, only power on sdp1 for music\n");
 		/* if don't have voice requirement */
-		snd_soc_write(tron_codec, 0x1A, 0x00);
-		snd_soc_write(tron_codec, 0x8, 0x10);
-		snd_soc_write(tron_codec, 0xd, 0x00);
-		snd_soc_write(tron_codec, 0x9, 0x04);
-		snd_soc_write(tron_codec, 0x69, 0x00);
-		snd_soc_write(tron_codec, 0x67, 0x00);
+		snd_soc_component_write(component, 0x1A, 0x00);
+		snd_soc_component_write(component, 0x8, 0x10);
+		snd_soc_component_write(component, 0xd, 0x00);
+		snd_soc_component_write(component, 0x9, 0x04);
+		snd_soc_component_write(component, 0x69, 0x00);
+		snd_soc_component_write(component, 0x67, 0x00);
 	} else {
 		pr_debug(">>>>>>>>es8396_pcm_startup, already power on sdp2 for voice\n");
-		snd_soc_write(tron_codec, 0x18, 0x00);	/* set eq source */
-		snd_soc_write(tron_codec, 0x19, 0x51);	/* set eq source */
+		snd_soc_component_write(component, 0x18, 0x00);	/* set eq source */
+		snd_soc_component_write(component, 0x19, 0x51);	/* set eq source */
 		/* if have voice requirement */
-		snd_soc_write(tron_codec, 0x1A, 0x40);
-		snd_soc_write(tron_codec, 0x8, 0x10);
-		snd_soc_write(tron_codec, 0xd, 0x00);
-		snd_soc_write(tron_codec, 0x9, 0x04);
-		snd_soc_write(tron_codec, 0x67, 0x0c);
-		snd_soc_write(tron_codec, 0x69, 0x04);
+		snd_soc_component_write(component, 0x1A, 0x40);
+		snd_soc_component_write(component, 0x8, 0x10);
+		snd_soc_component_write(component, 0xd, 0x00);
+		snd_soc_component_write(component, 0x9, 0x04);
+		snd_soc_component_write(component, 0x67, 0x0c);
+		snd_soc_component_write(component, 0x69, 0x04);
 	}
 
 	if (playback) {
 		pr_debug(">>>>>>>>>>>es8396_pcm_startup playback\n");
 		es8396->aif1_select |= 0x01;
-		snd_soc_write(tron_codec, 0x66, 0x01);
+		snd_soc_component_write(component, 0x66, 0x01);
 		for (i = 0; i < 120; i = i + 2) {
-			snd_soc_write(tron_codec, 0x6A, i + 1);
-			snd_soc_write(tron_codec, 0x6B, i + 1);
+			snd_soc_component_write(component, 0x6A, i + 1);
+			snd_soc_component_write(component, 0x6B, i + 1);
 			usleep_range(100, 200);
 		}
 		if (es8396->calibrate == 0) {
@@ -2603,45 +2558,45 @@ static int es8396_pcm_startup(struct snd_pcm_substream *substream,
 
 	} else {
 		pr_debug(">>>>>>>>>>>es8396_pcm_startup capture\n");
-		snd_soc_update_bits(tron_codec, ES8396_SDP1_OUT_FMT_REG20, 0x40,
-				    0x40);
+		snd_soc_component_update_bits(component, ES8396_SDP1_OUT_FMT_REG20, 0x40,
+					      0x40);
 		/* set adc alc */
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
-		snd_soc_write(tron_codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
+		snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
 		/* Enable MIC BOOST */
-		snd_soc_write(tron_codec, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
+		snd_soc_component_write(component, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
 
 		/* axMixer Gain boost */
-		regv = snd_soc_read(tron_codec, ES8396_AX_MIXER_BOOST_REG2F);
+		regv = snd_soc_component_read32(component, ES8396_AX_MIXER_BOOST_REG2F);
 		regv |= 0x88;
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_BOOST_REG2F, regv);
+		snd_soc_component_write(component, ES8396_AX_MIXER_BOOST_REG2F, regv);
 		/* axmixer vol = +12db */
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_VOL_REG30, 0xaa);
+		snd_soc_component_write(component, ES8396_AX_MIXER_VOL_REG30, 0xaa);
 		/* axmixer high driver capacility */
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
-		snd_soc_write(tron_codec, 0x33, 0);
+		snd_soc_component_write(component, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
+		snd_soc_component_write(component, 0x33, 0);
 		/* MNMixer Gain boost */
-		regv = snd_soc_read(tron_codec, ES8396_MN_MIXER_BOOST_REG37);
+		regv = snd_soc_component_read32(component, ES8396_MN_MIXER_BOOST_REG37);
 		regv |= 0x88;
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_BOOST_REG37, regv);
+		snd_soc_component_write(component, ES8396_MN_MIXER_BOOST_REG37, regv);
 		/* mnmixer vol = +12db */
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_VOL_REG38, 0x44);
+		snd_soc_component_write(component, ES8396_MN_MIXER_VOL_REG38, 0x44);
 		/* mnmixer high driver capacility */
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
+		snd_soc_component_write(component, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
 
 		/* ADC STM and Digital Startup, ADC DS Mode */
-		snd_soc_write(tron_codec, ES8396_ADC_CSM_REG53, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x00);
 		/* force adc stm to normal */
-		snd_soc_write(tron_codec, ES8396_ADC_FORCE_REG77, 0x40);
-		snd_soc_write(tron_codec, ES8396_ADC_FORCE_REG77, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x40);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x0);
 		/* ADC Volume =0db */
-		snd_soc_write(tron_codec, ES8396_ADC_LADC_VOL_REG56, 0x0);
-		snd_soc_write(tron_codec, ES8396_ADC_RADC_VOL_REG57, 0x0);
-		snd_soc_write(tron_codec, ES8396_ADC_CLK_DIV_REG09, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_LADC_VOL_REG56, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_RADC_VOL_REG57, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_CLK_DIV_REG09, 0x04);
 		es8396->aif1_select |= 0x02;
 		schedule_delayed_work(&es8396->adc_depop_work,
 				      msecs_to_jiffies(150));
@@ -2653,7 +2608,8 @@ static void es8396_pcm_shutdown(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	pr_debug(">>>>>>>>es8396_pcm_shutdown\n");
 
@@ -2666,8 +2622,8 @@ static void es8396_pcm_shutdown(struct snd_pcm_substream *substream,
 				      msecs_to_jiffies(20));
 	} else {
 		pr_debug(">>>>>>>>es8396_pcm_shutdown, capture\n");
-		snd_soc_update_bits(tron_codec, ES8396_SDP1_OUT_FMT_REG20, 0x40,
-				    0x40);
+		snd_soc_component_update_bits(component, ES8396_SDP1_OUT_FMT_REG20, 0x40,
+					      0x40);
 		es8396->aif1_select &= 0xfd;
 	}
 }
@@ -2677,7 +2633,8 @@ static int es8396_voice_startup(struct snd_pcm_substream *substream,
 {
 	unsigned int index;
 	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 	int regv;
 	int i;
 
@@ -2686,44 +2643,44 @@ static int es8396_voice_startup(struct snd_pcm_substream *substream,
 	if (playback) {
 		pr_debug("****************es8396_voice_startup, playback\n");
 		es8396->aif2_select |= 0x01;
-		snd_soc_write(tron_codec, 0x4e, 0x84);
-		snd_soc_write(tron_codec, 0x4f, 0x85);
+		snd_soc_component_write(component, 0x4e, 0x84);
+		snd_soc_component_write(component, 0x4f, 0x85);
 
 		for (i = 0; i < 120; i = i + 2) {
-			snd_soc_write(tron_codec, 0x6A, i + 1);
-			snd_soc_write(tron_codec, 0x6B, i + 1);
+			snd_soc_component_write(component, 0x6A, i + 1);
+			snd_soc_component_write(component, 0x6B, i + 1);
 			usleep_range(100, 200);
 		}
 
 		/* mute dac */
-		snd_soc_write(tron_codec, 0x66, 0x01);
+		snd_soc_component_write(component, 0x66, 0x01);
 		/* DSP-B, 1st SCLK after LRCK edge, I2S2 SDPIN */
-		snd_soc_update_bits(tron_codec, ES8396_SDP2_IN_FMT_REG22,
-				    0x7F, 0x13);
-		snd_soc_write(tron_codec, 0x18, 0x51);	/* set eq source */
-		snd_soc_write(tron_codec, 0x19, 0x51);	/* set eq source */
-		snd_soc_write(tron_codec, 0x8, 0x10);
-		snd_soc_write(tron_codec, 0xd, 0x00);
-		snd_soc_write(tron_codec, 0x9, 0x04);
+		snd_soc_component_update_bits(component, ES8396_SDP2_IN_FMT_REG22,
+					      0x7F, 0x13);
+		snd_soc_component_write(component, 0x18, 0x51);	/* set eq source */
+		snd_soc_component_write(component, 0x19, 0x51);	/* set eq source */
+		snd_soc_component_write(component, 0x8, 0x10);
+		snd_soc_component_write(component, 0xd, 0x00);
+		snd_soc_component_write(component, 0x9, 0x04);
 		if ((es8396->aif1_select & 0x01) == 0) {
 			/* if only voice */
-			snd_soc_write(tron_codec, 0x67, 0x0c);
-			snd_soc_write(tron_codec, 0x69, 0x04);
+			snd_soc_component_write(component, 0x67, 0x0c);
+			snd_soc_component_write(component, 0x69, 0x04);
 		} else {
-			snd_soc_write(tron_codec, 0x67, 0x0c);
-			snd_soc_write(tron_codec, 0x69, 0x04);
+			snd_soc_component_write(component, 0x67, 0x0c);
+			snd_soc_component_write(component, 0x69, 0x04);
 		}
 		/* clk2 used as EQ clk, OSR = 6xFs for 8k resampling to 48k */
-		snd_soc_write(tron_codec, ES8396_EQ_CLK_OSR_SEL_REG1C, 0x35);
-		snd_soc_write(tron_codec, ES8396_SHARED_ADDR_REG1D, 0x00);
+		snd_soc_component_write(component, ES8396_EQ_CLK_OSR_SEL_REG1C, 0x35);
+		snd_soc_component_write(component, ES8396_SHARED_ADDR_REG1D, 0x00);
 
 		for (index = 0; index < 59; index++) {
-			snd_soc_write(tron_codec, ES8396_SHARED_DATA_REG1E,
-				      es8396_equalizer_lpf_bt_incall[index]);
+			snd_soc_component_write(component, ES8396_SHARED_DATA_REG1E,
+						es8396_equalizer_lpf_bt_incall[index]);
 		}
-		snd_soc_write(tron_codec, ES8396_SHARED_ADDR_REG1D, 0xbb);
-		snd_soc_write(tron_codec, ES8396_SHARED_DATA_REG1E,
-			      es8396_equalizer_lpf_bt_incall[59]);
+		snd_soc_component_write(component, ES8396_SHARED_ADDR_REG1D, 0xbb);
+		snd_soc_component_write(component, ES8396_SHARED_DATA_REG1E,
+					es8396_equalizer_lpf_bt_incall[59]);
 
 		schedule_delayed_work(&es8396->voice_pop_work,
 				      msecs_to_jiffies(50));
@@ -2731,44 +2688,44 @@ static int es8396_voice_startup(struct snd_pcm_substream *substream,
 		pr_debug("****************es8396_voice_startup, capture\n");
 		es8396->aif2_select |= 0x02;
 		/* set adc alc */
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
-		snd_soc_write(tron_codec, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
-		snd_soc_write(tron_codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
-		snd_soc_write(tron_codec, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_1_REG58, 0xC6);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_2_REG59, 0x12);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_4_REG5B, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_5_REG5C, 0xC8);
+		snd_soc_component_write(component, ES8396_ADC_ALC_CTRL_6_REG5D, 0x11);
+		snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x0);
+		snd_soc_component_write(component, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x02);
 
 		/* axMixer Gain boost */
-		regv = snd_soc_read(tron_codec, ES8396_AX_MIXER_BOOST_REG2F);
+		regv = snd_soc_component_read32(component, ES8396_AX_MIXER_BOOST_REG2F);
 		regv |= 0x88;
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_BOOST_REG2F, regv);
+		snd_soc_component_write(component, ES8396_AX_MIXER_BOOST_REG2F, regv);
 		/* axmixer vol = +12db */
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_VOL_REG30, 0xaa);
+		snd_soc_component_write(component, ES8396_AX_MIXER_VOL_REG30, 0xaa);
 		/* axmixer high driver capacility */
-		snd_soc_write(tron_codec, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
-		snd_soc_write(tron_codec, 0x33, 0);
+		snd_soc_component_write(component, ES8396_AX_MIXER_REF_LP_REG31, 0x02);
+		snd_soc_component_write(component, 0x33, 0);
 		/* MNMixer Gain boost */
-		regv = snd_soc_read(tron_codec, ES8396_MN_MIXER_BOOST_REG37);
+		regv = snd_soc_component_read32(component, ES8396_MN_MIXER_BOOST_REG37);
 		regv |= 0x88;
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_BOOST_REG37, regv);
+		snd_soc_component_write(component, ES8396_MN_MIXER_BOOST_REG37, regv);
 		/* mnmixer vol = +12db */
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_VOL_REG38, 0x44);
+		snd_soc_component_write(component, ES8396_MN_MIXER_VOL_REG38, 0x44);
 		/* mnmixer high driver capacility */
-		snd_soc_write(tron_codec, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
+		snd_soc_component_write(component, ES8396_MN_MIXER_REF_LP_REG39, 0x02);
 
 		/* ADC STM and Digital Startup, ADC DS Mode */
-		snd_soc_write(tron_codec, ES8396_ADC_CSM_REG53, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x00);
 		/* force adc stm to normal */
-		snd_soc_write(tron_codec, ES8396_ADC_FORCE_REG77, 0x40);
-		snd_soc_write(tron_codec, ES8396_ADC_FORCE_REG77, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x40);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x0);
 		/* ADC Volume =0db */
-		snd_soc_write(tron_codec, ES8396_ADC_LADC_VOL_REG56, 0x0);
-		snd_soc_write(tron_codec, ES8396_ADC_RADC_VOL_REG57, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_LADC_VOL_REG56, 0x0);
+		snd_soc_component_write(component, ES8396_ADC_RADC_VOL_REG57, 0x0);
 
 		/* clk2 used as EQ clk, OSR = 6xFs for 8k resampling to 48k */
-		snd_soc_update_bits(tron_codec, ES8396_SDP2_OUT_FMT_REG23,
-				    0x7F, 0x33);
+		snd_soc_component_update_bits(component, ES8396_SDP2_OUT_FMT_REG23,
+					      0x7F, 0x33);
 	}
 	return 0;
 }
@@ -2776,22 +2733,23 @@ static int es8396_voice_startup(struct snd_pcm_substream *substream,
 static void es8396_voice_shutdown(struct snd_pcm_substream *substream,
 				  struct snd_soc_dai *dai)
 {
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(tron_codec);
+	struct snd_soc_component *component = dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
 
 	pr_debug("****************es8396_voice_shutdown\n");
 
 	/* DSP-B, 1st SCLK after LRCK edge, I2S2 SDPIN */
 	if (playback) {
-		snd_soc_write(tron_codec, 0x66, 0x01);
+		snd_soc_component_write(component, 0x66, 0x01);
 		pr_debug("****************es8396_voice_shutdown, playback\n");
 		schedule_delayed_work(&es8396->voice_shutdown_depop_work,
 				      msecs_to_jiffies(10));
 	} else {
 		pr_debug("****************es8396_voice_shutdown, captuer\n");
 		/* //DSP-B, 1st SCLK after LRCK edge, I2S2 SDPO */
-		snd_soc_update_bits(tron_codec, ES8396_SDP2_OUT_FMT_REG23,
-				    0x7F, 0x73);
+		snd_soc_component_update_bits(component, ES8396_SDP2_OUT_FMT_REG23,
+					      0x7F, 0x73);
 		es8396->aif2_select &= 0xfd;
 	}
 }
@@ -2801,32 +2759,21 @@ static void es8396_voice_shutdown(struct snd_pcm_substream *substream,
  */
 static int es8396_aif1_mute(struct snd_soc_dai *codec_dai, int mute)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
+
 	pr_debug("es8396_aif1_mute id = %d, mute = %d", codec_dai->id, mute);
 	if (mute) {
-		if (es8396->spk_ctl_gpio != INVALID_GPIO &&
-		    es8396->aif2_select == 0) {
-			pr_debug("spk_ctl_gpio set %d\n", es8396->spk_ctl_gpio);
-			gpio_set_value(es8396->spk_ctl_gpio, 0);
-		}
-		if (es8396->lineout_ctl_gpio != INVALID_GPIO &&
-		    es8396->aif2_select == 0) {
-			pr_debug("lineout_ctl_gpio set %d\n",
-				 es8396->lineout_ctl_gpio);
-			gpio_set_value(es8396->lineout_ctl_gpio, 0);
-		}
+		if (es8396->spk_ctl_gpio && es8396->aif2_select == 0)
+			gpiod_set_value(es8396->spk_ctl_gpio, 0);
+		if (es8396->lineout_ctl_gpio && es8396->aif2_select == 0)
+			gpiod_set_value(es8396->lineout_ctl_gpio, 0);
 		msleep(100);
 	} else {
-		if (es8396->spk_ctl_gpio != INVALID_GPIO) {
-			pr_debug("spk_ctl_gpio set %d\n", es8396->spk_ctl_gpio);
-			gpio_set_value(es8396->spk_ctl_gpio, 1);
-		}
-		if (es8396->lineout_ctl_gpio != INVALID_GPIO) {
-			pr_debug("lineout_ctl_gpio set %d\n",
-				 es8396->lineout_ctl_gpio);
-			gpio_set_value(es8396->lineout_ctl_gpio, 1);
-		}
+		if (es8396->spk_ctl_gpio)
+			gpiod_set_value(es8396->spk_ctl_gpio, 1);
+		if (es8396->lineout_ctl_gpio)
+			gpiod_set_value(es8396->lineout_ctl_gpio, 1);
 	}
 
 	return 0;
@@ -2834,34 +2781,22 @@ static int es8396_aif1_mute(struct snd_soc_dai *codec_dai, int mute)
 
 static int es8396_aif2_mute(struct snd_soc_dai *codec_dai, int mute)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 
 	pr_debug("es8396_aif2_mute id = %d, mute = %d", codec_dai->id, mute);
 
 	if (mute) {
-		if (es8396->spk_ctl_gpio != INVALID_GPIO &&
-		    es8396->aif1_select == 0) {
-			pr_debug("spk_ctl_gpio set %d\n", es8396->spk_ctl_gpio);
-			gpio_set_value(es8396->spk_ctl_gpio, 0);
-		}
-		if (es8396->lineout_ctl_gpio != INVALID_GPIO &&
-		    es8396->aif1_select == 0) {
-			pr_debug("lineout_ctl_gpio set %d\n",
-				 es8396->lineout_ctl_gpio);
-			gpio_set_value(es8396->lineout_ctl_gpio, 0);
-		}
+		if (es8396->spk_ctl_gpio && es8396->aif1_select == 0)
+			gpiod_set_value(es8396->spk_ctl_gpio, 0);
+		if (es8396->lineout_ctl_gpio && es8396->aif1_select == 0)
+			gpiod_set_value(es8396->lineout_ctl_gpio, 0);
 		msleep(100);
 	} else {
-		if (es8396->spk_ctl_gpio != INVALID_GPIO) {
-			pr_debug("spk_ctl_gpio set %d\n", es8396->spk_ctl_gpio);
-			gpio_set_value(es8396->spk_ctl_gpio, 1);
-		}
-		if (es8396->lineout_ctl_gpio != INVALID_GPIO) {
-			pr_debug("lineout_ctl_gpio set %d\n",
-				 es8396->lineout_ctl_gpio);
-			gpio_set_value(es8396->lineout_ctl_gpio, 1);
-		}
+		if (es8396->spk_ctl_gpio)
+			gpiod_set_value(es8396->spk_ctl_gpio, 1);
+		if (es8396->lineout_ctl_gpio)
+			gpiod_set_value(es8396->lineout_ctl_gpio, 1);
 	}
 	return 0;
 }
@@ -2911,198 +2846,168 @@ static struct snd_soc_dai_driver es8396_dai[] = {
 		},
 		.ops = &es8396_aif1_dai_ops,
 	},
-/*
-	{
-		.name = "es8396-aif2",
-		.playback = {
-			.stream_name = "SDP2 Playback",
-			.channels_min = 1,
-			.channels_max = 2,
-			.rates = ES8396_RATES,
-			.formats = ES8396_FORMATS,
-		},
-		.capture = {
-			.stream_name = "SDP2 Capture",
-			.channels_min = 1,
-			.channels_max = 2,
-			.rates = ES8396_RATES,
-			.formats = ES8396_FORMATS,
-		},
-		.ops = &es8396_aif2_dai_ops,
-	},
-*/
 };
 
 static int es8396_suspend(struct device *dev)
 {
-	pr_debug("CODEC going into suspend mode\n");
+	struct es8396_private *es8396 = dev_get_drvdata(dev);
+	struct snd_soc_component *component = es8396->component;
 
-	snd_soc_write(tron_codec, 0x4e, 0x84);
-	snd_soc_write(tron_codec, 0x4f, 0x85);
-	snd_soc_write(tron_codec, 0x66, 0x01);
-	snd_soc_write(tron_codec, 0x6e, 0x00);
+	snd_soc_component_write(component, 0x4e, 0x84);
+	snd_soc_component_write(component, 0x4f, 0x85);
+	snd_soc_component_write(component, 0x66, 0x01);
+	snd_soc_component_write(component, 0x6e, 0x00);
 
 	return 0;
 }
 
 static int es8396_resume(struct device *dev)
 {
-	pr_debug("CODEC going into es8396_resume mode\n");
+	struct es8396_private *es8396 = dev_get_drvdata(dev);
+	struct snd_soc_component *component = es8396->component;
 
 	usleep_range(20000, 21000);
 
-	snd_soc_write(tron_codec, 0x6e, 0x00);
-	snd_soc_write(tron_codec, 0x66, 0x00);
-	snd_soc_write(tron_codec, 0x4e, 0x80);
-	snd_soc_write(tron_codec, 0x4f, 0x81);
+	snd_soc_component_write(component, 0x6e, 0x00);
+	snd_soc_component_write(component, 0x66, 0x00);
+	snd_soc_component_write(component, 0x4e, 0x80);
+	snd_soc_component_write(component, 0x4f, 0x81);
 	return 0;
 }
 
-static int es8396_probe(struct snd_soc_codec *codec)
+static int es8396_probe(struct snd_soc_component *component)
 {
+	struct es8396_private *es8396 = snd_soc_component_get_drvdata(component);
 	int ret = 0, regv;
 	u8 value;
 
-	struct es8396_private *es8396 = snd_soc_codec_get_drvdata(codec);
-
-	es8396->mclk_clock = devm_clk_get(codec->dev, "mclk");
-        if (PTR_ERR(es8396->mclk_clock) == -EPROBE_DEFER)
-                return -EPROBE_DEFER;
+	es8396->component = component;
+	es8396->mclk_clock = devm_clk_get(component->dev, "mclk");
+	if (PTR_ERR(es8396->mclk_clock) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
 
-        ret = clk_prepare_enable(es8396->mclk_clock);
-        if (ret)
-                return ret;
-/*
-	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);
-	if (ret < 0) {
-		pr_err("Failed to set cache I/O: %d\n", ret);
+	ret = clk_prepare_enable(es8396->mclk_clock);
+	if (ret)
 		return ret;
-	}
-*/
-	tron_codec = codec;
-	regv = snd_soc_read(codec, ES8396_PLL_K2_REG05);
+	regv = snd_soc_component_read32(component, ES8396_PLL_K2_REG05);
 
 	if (regv == 0x00) {
 		/*
 		 * setup system analog control
 		 */
-		snd_soc_write(codec, ES8396_DLL_CTRL_REG0D, 0x20);
-		snd_soc_write(codec, ES8396_CLK_SRC_SEL_REG01, 0x04);
-		snd_soc_write(codec, ES8396_PLL_CTRL_1_REG02, 0xc1);
-		snd_soc_write(codec, ES8396_PLL_CTRL_2_REG03, 0x00);
-		snd_soc_write(codec, ES8396_PLL_N_REG04, 0x08);
-		snd_soc_write(codec, ES8396_PLL_K2_REG05, 0X1d);
-		snd_soc_write(codec, ES8396_PLL_K1_REG06, 0Xc3);
-		snd_soc_write(codec, ES8396_PLL_K0_REG07, 0Xb8);
-		snd_soc_write(codec, ES8396_PLL_CTRL_1_REG02, 0x41);
+		snd_soc_component_write(component, ES8396_DLL_CTRL_REG0D, 0x20);
+		snd_soc_component_write(component, ES8396_CLK_SRC_SEL_REG01, 0x04);
+		snd_soc_component_write(component, ES8396_PLL_CTRL_1_REG02, 0xc1);
+		snd_soc_component_write(component, ES8396_PLL_CTRL_2_REG03, 0x00);
+		snd_soc_component_write(component, ES8396_PLL_N_REG04, 0x08);
+		snd_soc_component_write(component, ES8396_PLL_K2_REG05, 0X1d);
+		snd_soc_component_write(component, ES8396_PLL_K1_REG06, 0Xc3);
+		snd_soc_component_write(component, ES8396_PLL_K0_REG07, 0Xb8);
+		snd_soc_component_write(component, ES8396_PLL_CTRL_1_REG02, 0x41);
 
 		/* adc,dac,cphp,class d clk enable,from clk2 */
-		snd_soc_write(codec, ES8396_CLK_CTRL_REG08, 0x00);
+		snd_soc_component_write(component, ES8396_CLK_CTRL_REG08, 0x00);
 		/* adc clk ratio=1 */
-		snd_soc_write(codec, ES8396_ADC_CLK_DIV_REG09, 0x04);
+		snd_soc_component_write(component, ES8396_ADC_CLK_DIV_REG09, 0x04);
 		/* dac clk ratio=1 */
-		snd_soc_write(codec, ES8396_DAC_CLK_DIV_REG0A, 0x01);
-		snd_soc_write(codec, ES8396_BCLK_DIV_M2_REG0F, 0x24);
-		snd_soc_write(codec, ES8396_LRCK_DIV_M4_REG11, 0x22);
+		snd_soc_component_write(component, ES8396_DAC_CLK_DIV_REG0A, 0x01);
+		snd_soc_component_write(component, ES8396_BCLK_DIV_M2_REG0F, 0x24);
+		snd_soc_component_write(component, ES8396_LRCK_DIV_M4_REG11, 0x22);
 
 		msleep(50);
-		snd_soc_write(codec, ES8396_SYS_VMID_REF_REG71, 0xFC);
-		snd_soc_write(codec, 0x72, 0xFF);
-		snd_soc_write(codec, 0x73, 0xFF);
+		snd_soc_component_write(component, ES8396_SYS_VMID_REF_REG71, 0xFC);
+		snd_soc_component_write(component, 0x72, 0xFF);
+		snd_soc_component_write(component, 0x73, 0xFF);
 		if (es8396_valid_analdo(es8396->ana_ldo_lvl) == false) {
 			pr_err("Analog LDO Level error.\n");
 			return -EINVAL;
-		} else {
-			value = es8396->ana_ldo_lvl;
-			value &= 0x07;
-			snd_soc_write(codec, ES8396_SYS_CHIP_ANA_CTL_REG70,
-				      value);
 		}
+		value = es8396->ana_ldo_lvl;
+		value &= 0x07;
+		snd_soc_component_write(component, ES8396_SYS_CHIP_ANA_CTL_REG70, value);
 		/* mic enable, mic d2se enable */
-		snd_soc_write(codec, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x01);
+		snd_soc_component_write(component, ES8396_SYS_MIC_IBIAS_EN_REG75, 0x01);
 		msleep(50);
-		snd_soc_write(codec, ES8396_TEST_MODE_REG76, 0xA0);
-		snd_soc_write(codec, ES8396_NGTH_REG7A, 0x20);
+		snd_soc_component_write(component, ES8396_TEST_MODE_REG76, 0xA0);
+		snd_soc_component_write(component, ES8396_NGTH_REG7A, 0x20);
 		msleep(50);
 
 		/* power up adc and dac analog */
-		snd_soc_write(codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x00);
-		snd_soc_write(codec, ES8396_DAC_REF_PWR_CTRL_REG6E, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x00);
+		snd_soc_component_write(component, ES8396_DAC_REF_PWR_CTRL_REG6E, 0x00);
 		/* set L,R DAC volume */
-		snd_soc_write(codec, ES8396_DAC_LDAC_VOL_REG6A, 0x01);
-		snd_soc_write(codec, ES8396_DAC_RDAC_VOL_REG6B, 0x01);
+		snd_soc_component_write(component, ES8396_DAC_LDAC_VOL_REG6A, 0x01);
+		snd_soc_component_write(component, ES8396_DAC_RDAC_VOL_REG6B, 0x01);
 		/* setup charge current for calibrate */
-		snd_soc_write(codec, ES8396_ADC_LADC_VOL_REG56, 0x84);
-		snd_soc_write(codec, ES8396_ADC_RADC_VOL_REG57, 0xdc);
-		snd_soc_write(codec, ES8396_DAC_OFFSET_CALI_REG6F, 0x06);
-		snd_soc_write(codec, ES8396_DAC_RAMP_RATE_REG67, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_LADC_VOL_REG56, 0x84);
+		snd_soc_component_write(component, ES8396_ADC_RADC_VOL_REG57, 0xdc);
+		snd_soc_component_write(component, ES8396_DAC_OFFSET_CALI_REG6F, 0x06);
+		snd_soc_component_write(component, ES8396_DAC_RAMP_RATE_REG67, 0x00);
 		/* enable adc and dac stm for calibrate */
-		snd_soc_write(codec, ES8396_DAC_CSM_REG66, 0x00);
-		snd_soc_write(codec, ES8396_ADC_CSM_REG53, 0x00);
-		snd_soc_write(codec, ES8396_ADC_FORCE_REG77, 0x40);
-		snd_soc_write(codec, ES8396_ADC_FORCE_REG77, 0x00);
-		snd_soc_write(codec, ES8396_DLL_CTRL_REG0D, 0x00);
+		snd_soc_component_write(component, ES8396_DAC_CSM_REG66, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x40);
+		snd_soc_component_write(component, ES8396_ADC_FORCE_REG77, 0x00);
+		snd_soc_component_write(component, ES8396_DLL_CTRL_REG0D, 0x00);
 		msleep(100);
-		snd_soc_write(codec, ES8396_DAC_CSM_REG66, 0x00);
-		snd_soc_write(codec, ES8396_ADC_ANALOG_CTRL_REG5E, 0x00);
-		snd_soc_write(codec, 0x5f, 0xf2);
-		snd_soc_write(tron_codec, 0x1f, 0x00);
-		snd_soc_write(tron_codec, 0x20, 0x40);
+		snd_soc_component_write(component, ES8396_DAC_CSM_REG66, 0x00);
+		snd_soc_component_write(component, ES8396_ADC_ANALOG_CTRL_REG5E, 0x00);
+		snd_soc_component_write(component, 0x5f, 0xf2);
+		snd_soc_component_write(component, 0x1f, 0x00);
+		snd_soc_component_write(component, 0x20, 0x40);
 		/* FM */
 		msleep(100);
-		snd_soc_write(tron_codec, 0x65, 0x88);
-		snd_soc_write(tron_codec, 0x2E, 0x88);
-		snd_soc_write(tron_codec, 0x2F, 0x00);
-		snd_soc_write(tron_codec, 0x30, 0xBB);
+		snd_soc_component_write(component, 0x65, 0x88);
+		snd_soc_component_write(component, 0x2E, 0x88);
+		snd_soc_component_write(component, 0x2F, 0x00);
+		snd_soc_component_write(component, 0x30, 0xBB);
 
 		if (es8396_valid_micbias(es8396->mic_bias_lvl) == false) {
 			pr_err("MIC BIAS Level error.\n");
 			return -EINVAL;
-		} else {
-			value = es8396->mic_bias_lvl;
-			value &= 0x07;
-			value = (value << 4) | 0x08;
-			/* enable micbias1 */
-			snd_soc_write(codec, ES8396_SYS_MICBIAS_CTRL_REG74,
-				      value);
 		}
-
-		snd_soc_write(codec, ES8396_ADC_CSM_REG53, 0x20);
-		snd_soc_write(codec, ES8396_ADC_PGA_GAIN_REG61, 0x33);
-		snd_soc_write(codec, ES8396_ADC_MICBOOST_REG60, 0x22);
+		value = es8396->mic_bias_lvl;
+		value &= 0x07;
+		value = (value << 4) | 0x08;
+		/* enable micbias1 */
+		snd_soc_component_write(component, ES8396_SYS_MICBIAS_CTRL_REG74, value);
+
+		snd_soc_component_write(component, ES8396_ADC_CSM_REG53, 0x20);
+		snd_soc_component_write(component, ES8396_ADC_PGA_GAIN_REG61, 0x33);
+		snd_soc_component_write(component, ES8396_ADC_MICBOOST_REG60, 0x22);
 		if (es8396->dmic_amic == MIC_AMIC)
 			/*use analog mic */
-			snd_soc_write(codec, ES8396_ADC_DMIC_RAMPRATE_REG54,
-				      0x00);
+			snd_soc_component_write(component, ES8396_ADC_DMIC_RAMPRATE_REG54,
+						0x00);
 		else
 			/*use digital mic */
-			snd_soc_write(codec, ES8396_ADC_DMIC_RAMPRATE_REG54,
-				      0xf0);
+			snd_soc_component_write(component, ES8396_ADC_DMIC_RAMPRATE_REG54,
+						0xf0);
 
 		/*Enable HPF, LDATA= LADC, RDATA = LADC */
-		snd_soc_write(codec, ES8396_ADC_HPF_COMP_DASEL_REG55, 0x31);
+		snd_soc_component_write(component, ES8396_ADC_HPF_COMP_DASEL_REG55, 0x31);
 
 		/*
 		 * setup hp detection
 		 */
 
 		/* gpio 2 for irq, AINL as irq src, gpio1 for dmic clk */
-		snd_soc_write(codec, ES8396_ALRCK_GPIO_SEL_REG15, 0xfa);
-		snd_soc_write(codec, ES8396_DAC_JACK_DET_COMP_REG69, 0x00);
+		snd_soc_component_write(component, ES8396_ALRCK_GPIO_SEL_REG15, 0xfa);
+		snd_soc_component_write(component, ES8396_DAC_JACK_DET_COMP_REG69, 0x00);
 		if (es8396->jackdet_enable == 1) {
 			/* jack detection from AINL pin, AINL=0, HP Insert */
-			snd_soc_write(codec, ES8396_DAC_JACK_DET_COMP_REG69,
-				      0x04);
+			snd_soc_component_write(component, ES8396_DAC_JACK_DET_COMP_REG69,
+						0x04);
 			if (es8396->gpio_int_pol == 0)
 				/* if HP insert, GPIO2=Low */
-				snd_soc_write(codec, ES8396_GPIO_IRQ_REG16,
-					      0x80);
+				snd_soc_component_write(component, ES8396_GPIO_IRQ_REG16,
+							0x80);
 			else
 				/* if HP insert, GPIO2=High */
-				snd_soc_write(codec, ES8396_GPIO_IRQ_REG16,
-					      0xc0);
+				snd_soc_component_write(component, ES8396_GPIO_IRQ_REG16,
+							0xc0);
 		} else {
-			snd_soc_write(codec, ES8396_GPIO_IRQ_REG16, 0x00);
+			snd_soc_component_write(component, ES8396_GPIO_IRQ_REG16, 0x00);
 		}
 
 		/*
@@ -3111,16 +3016,16 @@ static int es8396_probe(struct snd_soc_codec *codec)
 
 		/* monoin in differential mode */
 		if (es8396->monoin_differential == 1)
-			snd_soc_update_bits(codec, ES8396_MN_MIXER_REF_LP_REG39,
-					    0x08, 0x08);
+			snd_soc_component_update_bits(component, ES8396_MN_MIXER_REF_LP_REG39,
+						      0x08, 0x08);
 		else
-			snd_soc_update_bits(codec, ES8396_MN_MIXER_REF_LP_REG39,
-					    0x08, 0x00);
+			snd_soc_component_update_bits(component, ES8396_MN_MIXER_REF_LP_REG39,
+						      0x08, 0x00);
 
-		snd_soc_write(codec, ES8396_DAC_JACK_DET_COMP_REG69, 0x00);
-		snd_soc_write(codec, ES8396_BCLK_DIV_M1_REG0E, 0x24);
-		snd_soc_write(codec, ES8396_LRCK_DIV_M3_REG10, 0x22);
-		snd_soc_write(codec, ES8396_SDP_2_MS_REG13, 0x00);
+		snd_soc_component_write(component, ES8396_DAC_JACK_DET_COMP_REG69, 0x00);
+		snd_soc_component_write(component, ES8396_BCLK_DIV_M1_REG0E, 0x24);
+		snd_soc_component_write(component, ES8396_LRCK_DIV_M3_REG10, 0x22);
+		snd_soc_component_write(component, ES8396_SDP_2_MS_REG13, 0x00);
 		//codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
 	}
 
@@ -3143,13 +3048,13 @@ static int es8396_probe(struct snd_soc_codec *codec)
 			  voice_shutdown_depop_events);
 	mutex_init(&es8396->voice_shutdown_depop_mlock);
 
-	snd_soc_write(codec, 0x6f, 0x83);
-	snd_soc_write(codec, ES8396_SYS_VMID_REF_REG71, 0xFC);
+	snd_soc_component_write(component, 0x6f, 0x83);
+	snd_soc_component_write(component, ES8396_SYS_VMID_REF_REG71, 0xFC);
 	msleep(100);
-	snd_soc_write(codec, 0x4E, 0x84);
-	snd_soc_write(codec, 0x4F, 0x85);
-	snd_soc_write(codec, 0x4A, 0x60);
-	snd_soc_write(codec, 0x4B, 0x60);
+	snd_soc_component_write(component, 0x4E, 0x84);
+	snd_soc_component_write(component, 0x4F, 0x85);
+	snd_soc_component_write(component, 0x4A, 0x60);
+	snd_soc_component_write(component, 0x4B, 0x60);
 	/*
 	 * TODO: pop noise occur when HS calibration during probe
 	 * increase the delay of a period of time if necessary
@@ -3158,30 +3063,25 @@ static int es8396_probe(struct snd_soc_codec *codec)
 	return ret;
 }
 
-static int es8396_remove(struct snd_soc_codec *codec)
+static void es8396_remove(struct snd_soc_component *component)
 {
-	pr_debug("!!!!!!CODEC going into es8396_remove!!!!!!\n");
-
-	snd_soc_write(codec, 0X4E, 0x84);
-	snd_soc_write(codec, 0X4F, 0x85);
-	snd_soc_write(codec, 0X4A, 0x80);
-	snd_soc_write(codec, 0X4B, 0x80);
-	snd_soc_write(codec, 0x70, 0xd4);
-	msleep(300);
-
-	return 0;
+	snd_soc_component_write(component, 0X4E, 0x84);
+	snd_soc_component_write(component, 0X4F, 0x85);
+	snd_soc_component_write(component, 0X4A, 0x80);
+	snd_soc_component_write(component, 0X4B, 0x80);
+	snd_soc_component_write(component, 0x70, 0xd4);
 }
 
 const struct regmap_config es8396_regmap_config = {
-        .reg_bits       = 8,
-        .val_bits       = 8,
-        .max_register   = ES8396_MAX_REGISTER,
-        .cache_type     = REGCACHE_RBTREE,
-        .reg_defaults = es8396_reg_defaults,
-        .num_reg_defaults = ARRAY_SIZE(es8396_reg_defaults),
+	.reg_bits       = 8,
+	.val_bits       = 8,
+	.max_register   = ES8396_MAX_REGISTER,
+	.cache_type     = REGCACHE_RBTREE,
+	.reg_defaults = es8396_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(es8396_reg_defaults),
 };
 
-static struct snd_soc_codec_driver soc_codec_dev_es8396 = {
+static const struct snd_soc_component_driver soc_codec_dev_es8396 = {
 	.probe = es8396_probe,
 	.remove = es8396_remove,
 	.set_bias_level = es8396_set_bias_level,
@@ -3193,18 +3093,11 @@ static struct snd_soc_codec_driver soc_codec_dev_es8396 = {
 
 	.controls = es8396_snd_controls,
 	.num_controls = ARRAY_SIZE(es8396_snd_controls),
-/*
-	.reg_cache_size = ARRAY_SIZE(es8396_reg_defaults),
-	.reg_word_size = sizeof(u8),
-	.reg_cache_default = es8396_reg_defaults,
-	.volatile_register = es8396_volatile_register,
-	.readable_register = es8396_readable_register,
-*/
 };
 
 static int init_es8396_prv(struct es8396_private *es8396)
 {
-	if (es8396 == NULL)
+	if (!es8396)
 		return -EINVAL;
 
 	es8396->dvdd_pwr_vol = 0x18;
@@ -3231,115 +3124,59 @@ static int es8396_i2c_probe(struct i2c_client *i2c_client,
 {
 	struct es8396_private *es8396;
 	int ret;
-	enum of_gpio_flags flags;
-	struct device_node *np = i2c_client->dev.of_node;
 
-	pr_debug("%s %d\n", __func__, __LINE__);
 	es8396 = devm_kzalloc(&i2c_client->dev, sizeof(struct es8396_private),
 			      GFP_KERNEL);
-	if (!es8396) {
-		dev_err(&i2c_client->dev, "could not allocate codec\n");
-
+	if (!es8396)
 		return -ENOMEM;
-	}
-	/*
-	 * INIT ES8396 private here
-	 * TODO
-	 * id->driver_data
-	 */
+
 	ret = init_es8396_prv(es8396);
 	if (ret < 0)
 		return -EINVAL;
 
 	es8396->regmap = devm_regmap_init_i2c(i2c_client, &es8396_regmap_config);
-        if (IS_ERR(es8396->regmap)) {
-                ret = PTR_ERR(es8396->regmap);
-                dev_err(&i2c_client->dev, "Failed to init regmap: %d\n", ret);
-                return ret;
-        }
+	if (IS_ERR(es8396->regmap))
+		return PTR_ERR(es8396->regmap);
 
 	/* initialize codec */
 	i2c_set_clientdata(i2c_client, es8396);
 
 	/* external speaker amp controller */
-	es8396->spk_ctl_gpio = of_get_named_gpio_flags(np,
-						       "spk-con-gpio", 0,
-						       &flags);
-	if (es8396->spk_ctl_gpio < 0) {
-		pr_err("%s() Can not read property spk codec-en-gpio\n",
-		       __func__);
-		es8396->spk_ctl_gpio = INVALID_GPIO;
-	} else {
-		pr_debug("%d() spk codec-en-gpio\n", es8396->spk_ctl_gpio);
-		es8396->spk_gpio_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
-		ret = devm_gpio_request(&i2c_client->dev, es8396->spk_ctl_gpio,
-					"spk_ctl");
-		if (!ret) {
-			pr_debug("requset codec-en-gpio success!:%d\n", ret);
-			gpio_direction_output(es8396->spk_ctl_gpio,
-					      !es8396->spk_gpio_level);
-		} else {
-			pr_err("requset codec-en-gpio failed:%d\n", ret);
-			return ret;
-		}
-	}
+	es8396->spk_ctl_gpio = devm_gpiod_get_optional(&i2c_client->dev,
+						       "spk-con-gpio",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(es8396->spk_ctl_gpio))
+		return PTR_ERR(es8396->spk_ctl_gpio);
 
 	/* lineout output  controller*/
-	es8396->lineout_ctl_gpio = of_get_named_gpio_flags(np,
+	es8396->lineout_ctl_gpio = devm_gpiod_get_optional(&i2c_client->dev,
 							   "lineout-con-gpio",
-							   0, &flags);
-	if (es8396->lineout_ctl_gpio < 0) {
-		pr_err("%s() Can not read property lineout en-gpio\n",
-		       __func__);
-		es8396->lineout_ctl_gpio = INVALID_GPIO;
-	} else {
-		pr_debug("%d() lineout en-gpio\n", es8396->lineout_ctl_gpio);
-		es8396->lineout_gpio_level = (flags & OF_GPIO_ACTIVE_LOW) ?
-					      0 : 1;
-		ret = devm_gpio_request(&i2c_client->dev,
-					es8396->lineout_ctl_gpio,
-					"lineout_ctl");
-		if (!ret) {
-			pr_debug("requset lineout en-gpio success!:%d\n", ret);
-			gpio_direction_output(es8396->lineout_ctl_gpio,
-					      !es8396->lineout_gpio_level);
-		} else {
-			pr_err("requset lineout en-gpio failed:%d\n", ret);
-			return ret;
-		}
-	}
-
-	ret = snd_soc_register_codec(&i2c_client->dev,
-				     &soc_codec_dev_es8396, es8396_dai,
-				     ARRAY_SIZE(es8396_dai));
+							   GPIOD_OUT_LOW);
+	if (IS_ERR(es8396->lineout_ctl_gpio))
+		return PTR_ERR(es8396->lineout_ctl_gpio);
 
-	return ret;
+	return devm_snd_soc_register_component(&i2c_client->dev,
+					       &soc_codec_dev_es8396, es8396_dai,
+					       ARRAY_SIZE(es8396_dai));
 }
 
 static void es8396_i2c_shutdown(struct i2c_client *client)
 {
 	struct es8396_private *es8396 = i2c_get_clientdata(client);
-	pr_debug("Enter into %s\n", __func__);
+	struct snd_soc_component *component = es8396->component;
 
-	if (es8396->spk_ctl_gpio != INVALID_GPIO)
-		gpio_set_value(es8396->spk_ctl_gpio, 0);
+	if (es8396->spk_ctl_gpio)
+		gpiod_set_value(es8396->spk_ctl_gpio, 0);
 
 	usleep_range(20000, 21000);
-	snd_soc_write(tron_codec, 0X4E, 0x84);
-	snd_soc_write(tron_codec, 0X4F, 0x85);
-	snd_soc_write(tron_codec, 0X4a, 0x80);
-	snd_soc_write(tron_codec, 0X4b, 0x80);
-	snd_soc_write(tron_codec, 0x70, 0xd4);
+	snd_soc_component_write(component, 0X4E, 0x84);
+	snd_soc_component_write(component, 0X4F, 0x85);
+	snd_soc_component_write(component, 0X4a, 0x80);
+	snd_soc_component_write(component, 0X4b, 0x80);
+	snd_soc_component_write(component, 0x70, 0xd4);
 	msleep(300);
 }
 
-static int es8396_i2c_remove(struct i2c_client *client)
-{
-	snd_soc_unregister_codec(&client->dev);
-	i2c_set_clientdata(client, NULL);
-	return 0;
-}
-
 static const struct i2c_device_id es8396_id[] = {
 	{"es8396", 0},
 	{}
@@ -3354,13 +3191,11 @@ static const struct dev_pm_ops es8396_pm_ops = {
 static struct i2c_driver es8396_i2c_driver = {
 	.driver = {
 		   .name = "es8396",
-		   .owner = THIS_MODULE,
 		   .pm = &es8396_pm_ops,
 		   },
 	.id_table = es8396_id,
 	.probe = es8396_i2c_probe,
 	.shutdown = es8396_i2c_shutdown,
-	.remove = es8396_i2c_remove,
 };
 
 module_i2c_driver(es8396_i2c_driver);
diff --git a/sound/soc/codecs/es8396.h b/sound/soc/codecs/es8396.h
index 927517e842cc..e6f2f390707d 100644
--- a/sound/soc/codecs/es8396.h
+++ b/sound/soc/codecs/es8396.h
@@ -1,14 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
-* ES8396.h  --  ES8396 ALSA SoC Audio Codec
-**
-* Authors:
-*
-* Based on alc5632.h by Arnaud Patard
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*/
+ * ES8396.h  --  ES8396 ALSA SoC Audio Codec
+ *
+ * Based on alc5632.h by Arnaud Patard
+ */
 
 #ifndef _ES8396_H
 #define _ES8396_H
-- 
2.35.3

