From 97632dedc75302ef5cfc6723e0fcf3d1bf037b88 Mon Sep 17 00:00:00 2001
From: ljf <ljf@rock-chips.com>
Date: Thu, 6 Mar 2014 20:14:38 +0800
Subject: [PATCH] upload iep driver for linux kernel 3.10

---
 drivers/video/rockchip/Kconfig                |    1 +
 drivers/video/rockchip/Makefile               |    1 +
 drivers/video/rockchip/iep/Kconfig            |   17 +
 drivers/video/rockchip/iep/Makefile           |    2 +
 .../video/rockchip/iep/hw_iep_config_addr.h   |  111 ++
 drivers/video/rockchip/iep/hw_iep_reg.c       | 1186 +++++++++++++++++
 drivers/video/rockchip/iep/hw_iep_reg.h       |  677 ++++++++++
 drivers/video/rockchip/iep/iep.h              |  234 ++++
 drivers/video/rockchip/iep/iep_api.c          |  143 ++
 drivers/video/rockchip/iep/iep_api.h          |   56 +
 drivers/video/rockchip/iep/iep_drv.c          | 1139 ++++++++++++++++
 drivers/video/rockchip/iep/iep_drv.h          |  153 +++
 drivers/video/rockchip/iep/iep_mmu.c          |  233 ++++
 drivers/video/rockchip/iep/iep_mmu.h          |   18 +
 14 files changed, 3971 insertions(+)
 create mode 100755 drivers/video/rockchip/iep/Kconfig
 create mode 100755 drivers/video/rockchip/iep/Makefile
 create mode 100755 drivers/video/rockchip/iep/hw_iep_config_addr.h
 create mode 100755 drivers/video/rockchip/iep/hw_iep_reg.c
 create mode 100755 drivers/video/rockchip/iep/hw_iep_reg.h
 create mode 100755 drivers/video/rockchip/iep/iep.h
 create mode 100755 drivers/video/rockchip/iep/iep_api.c
 create mode 100755 drivers/video/rockchip/iep/iep_api.h
 create mode 100755 drivers/video/rockchip/iep/iep_drv.c
 create mode 100755 drivers/video/rockchip/iep/iep_drv.h
 create mode 100755 drivers/video/rockchip/iep/iep_mmu.c
 create mode 100755 drivers/video/rockchip/iep/iep_mmu.h

diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index 303df7edbb09..cd5db950da19 100755
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -66,4 +66,5 @@ source "drivers/video/rockchip/hdmi/Kconfig"
 source "drivers/video/rockchip/tve/Kconfig"
 source "drivers/video/rockchip/rga/Kconfig"
 source "drivers/video/rockchip/rga2/Kconfig"
+source "drivers/video/rockchip/iep/Kconfig"
 
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 37d55ed42ada..9595aff9370d 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_RK_TRSM) += transmitter/
 obj-$(CONFIG_ROCKCHIP_RGA) += rga/
 obj-$(CONFIG_ROCKCHIP_RGA2) += rga2/
 obj-$(CONFIG_RK_HDMI) += display-sys.o hdmi/
+obj-$(CONFIG_IEP) += iep/
diff --git a/drivers/video/rockchip/iep/Kconfig b/drivers/video/rockchip/iep/Kconfig
new file mode 100755
index 000000000000..f72a1871480a
--- /dev/null
+++ b/drivers/video/rockchip/iep/Kconfig
@@ -0,0 +1,17 @@
+menu "IEP"
+	depends on ARCH_ROCKCHIP
+
+config IEP
+	tristate "ROCKCHIP IEP driver"
+        default y
+	help
+	  rockchip iep module.
+
+config IEP_MMU
+        tristate "ROCKCHIP IEP MMU driver"
+        depends on ARCH_ROCKCHIP
+        default n
+        help
+          rockchip iep mmu
+
+endmenu
diff --git a/drivers/video/rockchip/iep/Makefile b/drivers/video/rockchip/iep/Makefile
new file mode 100755
index 000000000000..b16da1019b78
--- /dev/null
+++ b/drivers/video/rockchip/iep/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_IEP) += hw_iep_reg.o iep_drv.o 
+obj-$(CONFIG_IEP_MMU) += iep_mmu.o
diff --git a/drivers/video/rockchip/iep/hw_iep_config_addr.h b/drivers/video/rockchip/iep/hw_iep_config_addr.h
new file mode 100755
index 000000000000..06e3ff3ceae9
--- /dev/null
+++ b/drivers/video/rockchip/iep/hw_iep_config_addr.h
@@ -0,0 +1,111 @@
+#ifndef HW_IEP_CONFIG_ADDR_H_
+#define HW_IEP_CONFIG_ADDR_H_
+
+#include <asm/io.h>
+
+#define      IEP_BASE                      0x0 //ignore the IEP_BASE when program running in linux kernel //0x10108000
+
+#define      IEP_CONFIG0      		       0x0000
+#define      IEP_CONFIG1      		       0x0004
+
+#define      IEP_STATUS              	   0x0008
+#define      IEP_INT                 	   0x000C
+#define      IEP_FRM_START         		   0x0010
+#define      IEP_SOFT_RST           	   0x0014
+#define      IEP_CONF_DONE                 0x0018
+
+#define      IEP_VIR_IMG_WIDTH        	   0x0020
+
+#define      IEP_IMG_SCL_FCT         	   0x0024
+
+#define      IEP_SRC_IMG_SIZE         	   0x0028
+#define      IEP_DST_IMG_SIZE         	   0x002C
+
+#define      IEP_DST_IMG_WIDTH_TILE0  	   0x0030
+#define      IEP_DST_IMG_WIDTH_TILE1  	   0x0034
+#define      IEP_DST_IMG_WIDTH_TILE2  	   0x0038
+#define      IEP_DST_IMG_WIDTH_TILE3  	   0x003C
+
+#define      IEP_ENH_YUV_CNFG_0       	   0x0040
+#define      IEP_ENH_YUV_CNFG_1       	   0x0044
+#define      IEP_ENH_YUV_CNFG_2       	   0x0048
+#define      IEP_ENH_RGB_CNFG        	   0x004C
+#define      IEP_ENH_C_COE            	   0x0050
+
+#define      IEP_SRC_ADDR_YRGB        	   0x0080
+#define      IEP_SRC_ADDR_CBCR             0x0084
+#define      IEP_SRC_ADDR_CR               0x0088
+#define      IEP_SRC_ADDR_Y1               0x008C
+#define      IEP_SRC_ADDR_CBCR1            0x0090
+#define      IEP_SRC_ADDR_CR1              0x0094
+#define      IEP_SRC_ADDR_Y_ITEMP          0x0098
+#define      IEP_SRC_ADDR_CBCR_ITEMP       0x009C
+#define      IEP_SRC_ADDR_CR_ITEMP         0x00A0
+#define      IEP_SRC_ADDR_Y_FTEMP          0x00A4
+#define      IEP_SRC_ADDR_CBCR_FTEMP       0x00A8
+#define      IEP_SRC_ADDR_CR_FTEMP         0x00AC
+
+#define      IEP_DST_ADDR_YRGB        	   0x00B0
+#define      IEP_DST_ADDR_CBCR             0x00B4
+#define      IEP_DST_ADDR_CR               0x00B8
+#define      IEP_DST_ADDR_Y1               0x00BC
+#define      IEP_DST_ADDR_CBCR1            0x00C0
+#define      IEP_DST_ADDR_CR1              0x00C4
+#define      IEP_DST_ADDR_Y_ITEMP          0x00C8
+#define      IEP_DST_ADDR_CBCR_ITEMP       0x00CC
+#define      IEP_DST_ADDR_CR_ITEMP         0x00D0
+#define      IEP_DST_ADDR_Y_FTEMP          0x00D4
+#define      IEP_DST_ADDR_CBCR_FTEMP       0x00D8
+#define      IEP_DST_ADDR_CR_FTEMP         0x00DC
+
+#define      IEP_DIL_MTN_TAB0              0x00E0
+#define      IEP_DIL_MTN_TAB1              0x00E4
+#define      IEP_DIL_MTN_TAB2              0x00E8
+#define      IEP_DIL_MTN_TAB3              0x00EC
+#define      IEP_DIL_MTN_TAB4              0x00F0
+#define      IEP_DIL_MTN_TAB5              0x00F4
+#define      IEP_DIL_MTN_TAB6              0x00F8
+#define      IEP_DIL_MTN_TAB7              0x00FC
+
+#define      IEP_ENH_CG_TAB                0x0100
+
+#define      IEP_YUV_DNS_CRCT_TEMP         0x0400
+#define      IEP_YUV_DNS_CRCT_SPAT         0x0800
+
+#define      IEP_ENH_DDE_COE0              0x0C00
+#define      IEP_ENH_DDE_COE1              0x0E00
+
+#define      RAW_IEP_CONFIG0               0x0058
+#define      RAW_IEP_CONFIG1      		   0x005C
+#define      RAW_IEP_VIR_IMG_WIDTH         0x0060
+
+#define      RAW_IEP_IMG_SCL_FCT      	   0x0064
+
+#define      RAW_IEP_SRC_IMG_SIZE      	   0x0068
+#define      RAW_IEP_DST_IMG_SIZE      	   0x006C
+
+#define      RAW_IEP_ENH_YUV_CNFG_0        0x0070
+#define      RAW_IEP_ENH_YUV_CNFG_1        0x0074
+#define      RAW_IEP_ENH_YUV_CNFG_2        0x0078
+#define      RAW_IEP_ENH_RGB_CNFG          0x007C
+
+#if defined(CONFIG_IEP_MMU)
+#define      IEP_MMU_BASE                  0x0800
+#define      IEP_MMU_DTE_ADDR              (IEP_MMU_BASE+0x00)
+#define      IEP_MMU_STATUS                (IEP_MMU_BASE+0x04)
+#define      IEP_MMU_CMD                   (IEP_MMU_BASE+0x08)
+#define      IEP_MMU_PAGE_FAULT_ADDR       (IEP_MMU_BASE+0x0c)
+#define      IEP_MMU_ZAP_ONE_LINE          (IEP_MMU_BASE+0x10)
+#define      IEP_MMU_INT_RAWSTAT           (IEP_MMU_BASE+0x14)
+#define      IEP_MMU_INT_CLEAR             (IEP_MMU_BASE+0x18)
+#define      IEP_MMU_INT_MASK              (IEP_MMU_BASE+0x1c)
+#define      IEP_MMU_INT_STATUS            (IEP_MMU_BASE+0x20)
+#define      IEP_MMU_AUTO_GATING           (IEP_MMU_BASE+0x24)
+#endif
+
+#define ReadReg32(base, raddr)	        (__raw_readl(base + raddr))
+#define WriteReg32(base, waddr, value)	(__raw_writel(value, base + waddr))
+#define ConfRegBits32(base, raddr, waddr, position, value)           WriteReg32(base, waddr, (ReadReg32(base, waddr)&~(position))|(value))
+#define MaskRegBits32(base, waddr, position, value)                  WriteReg32(base, waddr, (ReadReg32(base, waddr)&~(position))|(value))
+
+#endif
diff --git a/drivers/video/rockchip/iep/hw_iep_reg.c b/drivers/video/rockchip/iep/hw_iep_reg.c
new file mode 100755
index 000000000000..b52210f9fb01
--- /dev/null
+++ b/drivers/video/rockchip/iep/hw_iep_reg.c
@@ -0,0 +1,1186 @@
+/* 
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include "hw_iep_reg.h"
+#include "iep_api.h"
+#include "iep.h"
+#include "hw_iep_config_addr.h"
+
+static void iep_config_src_size(IEP_MSG *iep_msg)
+{
+    IEP_REGB_SRC_IMG_WIDTH(iep_msg->base, iep_msg->src.act_w - 1);
+    IEP_REGB_SRC_IMG_HEIGHT(iep_msg->base, iep_msg->src.act_h - 1);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==source image size config===================//\n\n");
+    IEP_DBG("sw_src_img_height          = %d;//source image height \n", iep_msg->src.act_h - 1);
+    IEP_DBG("sw_src_img_width           = %d;//source image width \n\n", iep_msg->src.act_w - 1);
+#endif
+}
+
+static void iep_config_dst_size(IEP_MSG *iep_msg)
+{
+    IEP_REGB_DST_IMG_WIDTH(iep_msg->base, iep_msg->dst.act_w - 1);
+    IEP_REGB_DST_IMG_HEIGHT(iep_msg->base, iep_msg->dst.act_h - 1);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==destination image size config===================//\n\n");
+    IEP_DBG("sw_dst_img_height          = %d;//source image height \n", iep_msg->dst.act_h - 1);
+    IEP_DBG("sw_dst_img_width           = %d;//source image width \n", iep_msg->dst.act_w - 1);
+#endif
+}
+
+static void iep_config_dst_width_tile(IEP_MSG *iep_msg)
+{
+//	IEP_REGB_DST_IMG_WIDTH_TILE0();
+//	IEP_REGB_DST_IMG_WIDTH_TILE1();
+//	IEP_REGB_DST_IMG_WIDTH_TILE2();
+//	IEP_REGB_DST_IMG_WIDTH_TILE3();
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_dst_width_tile0         = 0;\n");
+    IEP_DBG("sw_dst_width_tile1         = 0;\n");
+    IEP_DBG("sw_dst_width_tile2         = 0;\n");
+    IEP_DBG("sw_dst_width_tile3         = 0;\n\n");
+#endif
+}
+
+static void iep_config_dst_fmt(IEP_MSG *iep_msg)
+{
+    unsigned int dst_fmt = 0;
+    unsigned int dst_rgb_swap = 0;
+    unsigned int dst_yuv_swap = 0;
+    switch (iep_msg->dst.format) {
+    case IEP_FORMAT_ARGB_8888 :
+        IEP_REGB_DST_FMT(iep_msg->base, 0);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 0);
+        dst_fmt = 0;
+        dst_rgb_swap = 0;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_ABGR_8888 :
+        IEP_REGB_DST_FMT(iep_msg->base, 0);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 1);
+        dst_fmt = 0;
+        dst_rgb_swap = 1;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_RGBA_8888 :
+        IEP_REGB_DST_FMT(iep_msg->base, 0);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 2);
+        dst_fmt = 0;
+        dst_rgb_swap = 2;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_BGRA_8888 :
+        IEP_REGB_DST_FMT(iep_msg->base, 0);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 3);
+        dst_fmt = 0;
+        dst_rgb_swap = 3;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_RGB_565 :
+        IEP_REGB_DST_FMT(iep_msg->base, 1);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 0);
+        dst_fmt = 1;
+        dst_rgb_swap = 0;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_BGR_565 :
+        IEP_REGB_DST_FMT(iep_msg->base, 1);
+        IEP_REGB_DST_RGB_SWAP(iep_msg->base, 1);
+        dst_fmt = 1;
+        dst_rgb_swap = 1;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_YCbCr_422_SP :
+        IEP_REGB_DST_FMT(iep_msg->base, 2);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 0);
+        dst_fmt = 2;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_YCbCr_422_P :
+        IEP_REGB_DST_FMT(iep_msg->base, 2);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+        dst_fmt = 2;
+        dst_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP :
+        IEP_REGB_DST_FMT(iep_msg->base, 3);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 0);
+        dst_fmt = 3;
+        dst_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_YCbCr_420_P :
+        IEP_REGB_DST_FMT(iep_msg->base, 3);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+        dst_fmt = 3;
+        dst_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCrCb_422_SP :
+        IEP_REGB_DST_FMT(iep_msg->base, 2);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 1);
+        dst_fmt = 2;
+        dst_yuv_swap = 1;
+        break;
+    case IEP_FORMAT_YCrCb_422_P :
+        IEP_REGB_DST_FMT(iep_msg->base, 2);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+        dst_fmt = 2;
+        dst_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCrCb_420_SP :
+        IEP_REGB_DST_FMT(iep_msg->base, 3);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 1);
+        dst_fmt = 3;
+        dst_yuv_swap = 1;
+        break;
+    case IEP_FORMAT_YCrCb_420_P :
+        IEP_REGB_DST_FMT(iep_msg->base, 3);
+        IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+        dst_fmt = 3;
+        dst_yuv_swap = 2;
+        break;
+    default:
+        break;
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==destination data format config============//\n\n");
+    IEP_DBG("sw_dst_yuv_swap            = %d;//0:sp uv; 1:sp vu; 2:p ; 3:p;\n", dst_yuv_swap);
+    IEP_DBG("sw_dst_rgb_swap            = %d;//if ARGB 0:argb; 1,abgr; 2:rgba; 3:bgra; if rgb565: 0,2:rgb; 1,3:bgr;\n", dst_rgb_swap);
+    IEP_DBG("sw_dst_fmt                 = %d;//0:argb; 1:rgb565; 2:yuv422; 3:yuv420;\n\n", dst_fmt);
+#endif
+}
+
+static void iep_config_src_fmt(IEP_MSG *iep_msg)
+{
+    unsigned int src_fmt = 0;
+    unsigned int src_rgb_swap = 0;
+    unsigned int src_yuv_swap = 0;
+    switch (iep_msg->src.format) {
+    case IEP_FORMAT_ARGB_8888 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 0);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 0);
+        src_fmt = 0;
+        src_rgb_swap = 0;
+        break;
+    case IEP_FORMAT_ABGR_8888 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 0);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 1);
+        src_fmt = 0;
+        src_rgb_swap = 1;
+        break;
+    case IEP_FORMAT_RGBA_8888 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 0);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 2);
+        src_fmt = 0;
+        src_rgb_swap = 2;
+        break;
+    case IEP_FORMAT_BGRA_8888 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 0);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 3);
+        src_fmt = 0;
+        src_rgb_swap = 3;
+        break;
+    case IEP_FORMAT_RGB_565 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 1);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 0);
+        src_fmt = 1;
+        src_rgb_swap = 0;
+        break;
+    case IEP_FORMAT_BGR_565 :
+        IEP_REGB_SRC_FMT(iep_msg->base, 1);
+        IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 1);
+        src_fmt = 1;
+        src_rgb_swap = 1;
+        break;
+    case IEP_FORMAT_YCbCr_422_SP :
+        IEP_REGB_SRC_FMT(iep_msg->base, 2);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 0);
+        src_fmt = 2;
+        src_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_YCbCr_422_P :
+        IEP_REGB_SRC_FMT(iep_msg->base, 2);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+        src_fmt = 2;
+        src_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP :
+        IEP_REGB_SRC_FMT(iep_msg->base, 3);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 0);
+        src_fmt = 3;
+        src_yuv_swap = 0;
+        break;
+    case IEP_FORMAT_YCbCr_420_P :
+        IEP_REGB_SRC_FMT(iep_msg->base, 3);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+        src_fmt = 3;
+        src_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCrCb_422_SP :
+        IEP_REGB_SRC_FMT(iep_msg->base, 2);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 1);
+        src_fmt = 2;
+        src_yuv_swap = 1;
+        break;
+    case IEP_FORMAT_YCrCb_422_P :
+        IEP_REGB_SRC_FMT(iep_msg->base, 2);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+        src_fmt = 2;
+        src_yuv_swap = 2;
+        break;
+    case IEP_FORMAT_YCrCb_420_SP :
+        IEP_REGB_SRC_FMT(iep_msg->base, 3);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 1);
+        src_fmt = 3;
+        src_yuv_swap = 1;
+        break;
+    case IEP_FORMAT_YCrCb_420_P :
+        IEP_REGB_SRC_FMT(iep_msg->base, 3);
+        IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+        src_fmt = 3;
+        src_yuv_swap = 2;
+        break;
+    default:
+        break;
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==source data format config=================//\n\n");
+    IEP_DBG("sw_src_yuv_swap            = %d;//0:sp uv; 1:sp vu; 2:p ; 3:p;\n", src_yuv_swap);
+    IEP_DBG("sw_src_rgb_swap            = %d;//if ARGB 0:argb; 1,abgr; 2:rgba; 3:bgra; if rgb565: 0,2:rgb; 1,3:bgr;\n", src_rgb_swap);
+    IEP_DBG("sw_src_fmt                 = %d;//0:argb; 1:rgb565; 2:yuv422; 3:yuv420;\n\n", src_fmt);
+#endif
+}
+
+static void iep_config_scl(IEP_MSG *iep_msg)
+{
+    int scl_en;
+    int scl_sel;
+    //int vrt_fct;
+    //int hrz_fct;
+
+    unsigned int src_height, src_width, dst_height, dst_width;
+
+    int div_height_dst_src;
+    int div_width_dst_src;
+
+    src_height = iep_msg->src.act_h - 1;
+    src_width = iep_msg->src.act_w - 1;
+    dst_height = iep_msg->dst.act_h - 1;
+    dst_width = iep_msg->dst.act_w - 1;
+
+    if ((iep_msg->src.act_w == iep_msg->dst.act_w) && (iep_msg->src.act_h == iep_msg->dst.act_h)) scl_en = 0;
+    else scl_en = 1;
+
+    if      ((iep_msg->src.act_w >= iep_msg->dst.act_w) && (iep_msg->src.act_h >= iep_msg->dst.act_h))		scl_sel = 0;
+    else if ((iep_msg->src.act_w >= iep_msg->dst.act_w) && (iep_msg->src.act_h <= iep_msg->dst.act_h))		scl_sel = 1;
+    else if ((iep_msg->src.act_w <= iep_msg->dst.act_w) && (iep_msg->src.act_h >= iep_msg->dst.act_h))		scl_sel = 2;
+    else	scl_sel = 3;
+
+    //for vrt_fct
+    if ((scl_sel == 1) || (scl_sel == 3)) {
+        div_height_dst_src = src_height * 65536 / dst_height;
+    } else {
+        div_height_dst_src = (dst_height + 1) * 65536 / (src_height + 1);
+        if ((div_height_dst_src * (src_height + 1)) < ((dst_height + 1) * 65536)) div_height_dst_src = div_height_dst_src + 1;
+    }
+
+    if (div_height_dst_src == 65536) div_height_dst_src = 0;
+
+    //for hrz_fct
+    if ((scl_sel == 2) || (scl_sel == 3)) {
+        div_width_dst_src = src_width * 65536 / dst_width;
+    } else {
+        div_width_dst_src = (dst_width + 1) * 65536 / (src_width + 1);
+        if ((div_width_dst_src * (src_width + 1)) < ((dst_width + 1) * 65536)) div_width_dst_src = div_width_dst_src + 1;
+    }
+
+    if (div_width_dst_src == 65536) div_width_dst_src = 0;
+
+
+    IEP_REGB_SCL_EN(iep_msg->base, scl_en);
+
+    if (scl_en == 1) {
+        IEP_REGB_SCL_SEL(iep_msg->base, scl_sel);
+        IEP_REGB_SCL_UP_COE_SEL(iep_msg->base, iep_msg->scale_up_mode);
+        IEP_REGB_SCL_VRT_FCT(iep_msg->base, div_height_dst_src);
+        IEP_REGB_SCL_HRZ_FCT(iep_msg->base, div_width_dst_src);
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==scaling config============================//\n\n");
+    IEP_DBG("sw_scl_en                  = %d;//0:disable; 1:enable;\n", scl_en);
+    IEP_DBG("sw_scl_sel                 = %d;//0:hrz down & vrt down;  1:hrz down & vrt up; 2:hrz up & vrt down;  3:hrz up & vrt up;\n", scl_sel);
+    IEP_DBG("sw_scl_up_coe_sel          = %d;//select four groups of up scaling coefficient\n", iep_msg->scale_up_mode);
+    IEP_DBG("sw_scl_vrt_fct             = %d;//if up-scaling,equal to floor(src_img_height/dst_image_height)*2^16; if down-scaling,equal to ceiling(dst_image_height/src_image_height)*2^16;\n", div_height_dst_src);
+    IEP_DBG("sw_scl_hrz_fct             = %d;//if up-scaling,equal to floor(src_img_widht/dst_image_width)*2^16;   if down-scaling,equal to ceiling(dst_image_width/src_image_width)*2^16  ; \n\n", div_width_dst_src);
+#endif
+}
+
+static void iep_config_cg_order(IEP_MSG *iep_msg)
+{
+    IEP_REGB_CON_GAM_ORDER(iep_msg->base, iep_msg->rgb_contrast_enhance_mode);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==rgb enhancement & denoise config==========//\n\n");
+    IEP_DBG("sw_con_gam_order           = %d;//0:CG(contrast/gamma operation)prior to DDE(de-noise/detail/edge enhance);  1:DDE prior to CG;\n", iep_msg->rgb_contrast_enhance_mode);
+#endif
+}
+
+static void iep_config_cg(IEP_MSG *iep_msg)
+{
+    unsigned i;
+    unsigned int cg_conf_addr;
+
+    IEP_REGB_RGB_CON_GAM_EN(iep_msg->base, iep_msg->rgb_cg_en);
+
+    if (iep_msg->rgb_cg_en) {
+        cg_conf_addr = rIEP_CG_TAB_ADDR;
+
+        for (i=0; i<192; i++) {
+            WriteReg32(iep_msg->base, cg_conf_addr, iep_msg->cg_tab[i]);
+            cg_conf_addr += 0x04;
+        }
+    }
+
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_rgb_con_gam_en          = 0;//0:contrast & gamma disable; 1:enable;\n", iep_msg->rgb_cg_en);
+#endif
+}
+
+static void iep_config_dde(IEP_MSG *iep_msg)
+{
+    IEP_REGB_RGB_ENH_SEL(iep_msg->base, iep_msg->rgb_enhance_mode);
+    IEP_REGB_ENH_THRESHOLD(iep_msg->base, iep_msg->enh_threshold);
+	IEP_REGB_ENH_ALPHA(iep_msg->base, iep_msg->enh_alpha);
+	IEP_REGB_ENH_RADIUS(iep_msg->base, iep_msg->enh_radius);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_rgb_enh_sel             = %d;//0:no operation; 1:de-noise; 2:detail enhance; 3:edge enhance;\n", iep_msg->rgb_enhance_mode);
+#endif
+
+}
+
+static void iep_config_color_enh(IEP_MSG *iep_msg)
+{
+    IEP_REGB_RGB_COLOR_ENH_EN(iep_msg->base, iep_msg->rgb_color_enhance_en);
+    IEP_REGB_ENH_C_COE(iep_msg->base, iep_msg->rgb_enh_coe);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_rgb_color_enh_en        = %d;//0:color enhance disable; 1:enable;\n\n", iep_msg->rgb_color_enhance_en);
+#endif
+}
+
+static void iep_config_yuv_dns(IEP_MSG *iep_msg)
+{
+    IEP_REGB_YUV_DNS_EN(iep_msg->base, iep_msg->yuv_3D_denoise_en);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==yuv denoise config========================// \n\n");
+    IEP_DBG("sw_yuv_dns_en              = %d;//0:yuv 3d denoise disable; 1:enable\n\n", iep_msg->yuv_3D_denoise_en);
+#endif
+}
+
+
+static void iep_config_dil(IEP_MSG *iep_msg)
+{
+    //unsigned int value_tab0, value_tab1, value_tab2, value_tab3, value_tab4, value_tab5, value_tab6, value_tab7;
+    int dein_mode;
+    //double tab[256] =
+    //{
+    //	1.0,1.0,1.0,1.0,
+    //  1.000000,0.996856,0.987464,0.971942,
+    //  0.950484,0.923362,0.890916,0.853553,
+    //  0.811745,0.766016,0.716942,0.665140,
+    //  0.611260,0.555982,0.500000,0.444018,
+    //  0.388740,0.334860,0.283058,0.233984,
+    //  0.188255,0.146447,0.109084,0.076638,
+    //  0.049516,0.028058,0.012536,0.003144
+    //};
+    switch (iep_msg->dein_mode) {
+    case IEP_DEINTERLACE_MODE_DISABLE:
+        dein_mode = dein_mode_bypass_dis;
+        break;
+    case IEP_DEINTERLACE_MODE_I2O1:
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I2O1T : dein_mode_I2O1B;
+        break;
+    case IEP_DEINTERLACE_MODE_I4O1:
+#if 1
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I4O1B : dein_mode_I4O1T;
+#else
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I4O1T : dein_mode_I4O1B;
+#endif
+        break;
+    case IEP_DEINTERLACE_MODE_I4O2:
+        dein_mode = dein_mode_I4O2;
+        break;
+    case IEP_DEINTERLACE_MODE_BYPASS:
+        dein_mode = dein_mode_bypass;
+        break;
+    default:
+        IEP_ERR("unknown deinterlace mode, set deinterlace mode (bypass)\n");
+        dein_mode = dein_mode_bypass;
+    }
+
+    IEP_REGB_DIL_MODE(iep_msg->base, dein_mode);
+    //hf
+    IEP_REGB_DIL_HF_EN(iep_msg->base, iep_msg->dein_high_fre_en);
+    if (iep_msg->dein_high_fre_en == 1) IEP_REGB_DIL_HF_FCT(iep_msg->base, iep_msg->dein_high_fre_fct);
+    //ei
+    IEP_REGB_DIL_EI_MODE(iep_msg->base, iep_msg->dein_ei_mode);
+    IEP_REGB_DIL_EI_SMOOTH(iep_msg->base, iep_msg->dein_ei_smooth);
+    IEP_REGB_DIL_EI_SEL(iep_msg->base, iep_msg->dein_ei_sel);
+    if (iep_msg->dein_ei_sel == 0) IEP_REGB_DIL_EI_RADIUS(iep_msg->base, iep_msg->dein_ei_radius);
+
+    /*
+    value_tab0=(64<<24)+(64<<16)+(64<<8)+64;
+    IEP_REGB_DIL_MTN_TAB0(value_tab0);
+    
+    value_tab1=(62<<24)+(63<<16)+(63<<8)+64;
+    IEP_REGB_DIL_MTN_TAB1(value_tab1);
+    
+    value_tab2=(54<<24)+(57<<16)+(59<<8)+60;
+    IEP_REGB_DIL_MTN_TAB2(value_tab2);
+    
+    value_tab3=(42<<24)+(45<<16)+(49<<8)+51;
+    IEP_REGB_DIL_MTN_TAB3(value_tab3);
+    
+    value_tab4=(28<<24)+(32<<16)+(35<<8)+39;
+    IEP_REGB_DIL_MTN_TAB4(value_tab4);
+    
+    value_tab5=(14<<24)+(18<<16)+(21<<8)+24;
+    IEP_REGB_DIL_MTN_TAB5(value_tab5);
+    
+    value_tab6=(4<<24)+(6<<16)+(9<<8)+12;
+    IEP_REGB_DIL_MTN_TAB6(value_tab6);
+    
+    value_tab6=(1<<8)+3;
+    IEP_REGB_DIL_MTN_TAB7(value_tab6);	
+    */
+    IEP_REGB_DIL_MTN_TAB0(iep_msg->base, 0x40404040);
+    IEP_REGB_DIL_MTN_TAB1(iep_msg->base, 0x3c3e3f3f);
+    IEP_REGB_DIL_MTN_TAB2(iep_msg->base, 0x3336393b);
+    IEP_REGB_DIL_MTN_TAB3(iep_msg->base, 0x272a2d31);
+    IEP_REGB_DIL_MTN_TAB4(iep_msg->base, 0x181c2023);
+    IEP_REGB_DIL_MTN_TAB5(iep_msg->base, 0x0c0e1215);
+    IEP_REGB_DIL_MTN_TAB6(iep_msg->base, 0x03040609);
+    IEP_REGB_DIL_MTN_TAB7(iep_msg->base, 0x00000001);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG(" //==deinterlace config========================//\n\n");
+    IEP_DBG("sw_dil_hf_en               = %d;//0:disable  high-frequency deinterlace; 1:enahble\n", iep_msg->dein_high_fre_en);
+    IEP_DBG("sw_dil_mode                = %d;//0:deinterlace disable; 1:I4O2; 2:I4O1B; 3:I4O1T; 4:I201B; 5:I201T 6:bypass\n", iep_msg->dein_mode);
+    IEP_DBG("sw_dil_ei_mode             = %d;//edge interpolation\n", iep_msg->dein_ei_mode);
+    IEP_DBG("sw_dil_mtn_tab0            = 63,64,64,64;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab1            = 52,57,60,62;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab2            = 0,0,0,0,46;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab3            = 0;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab4            = 0;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab5            = 0;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab6            = 0;//motion table  0~ 3,7bit\n");
+    IEP_DBG("sw_dil_mtn_tab7            = 0;//motion table  0~ 3,7bit\n\n");
+#endif
+}
+
+static void iep_config_yuv_enh(IEP_MSG *iep_msg)
+{
+    IEP_REGB_YUV_ENH_EN(iep_msg->base, iep_msg->yuv_enhance_en);
+    if (iep_msg->yuv_enhance_en == 1) {
+        IEP_REGB_VIDEO_MODE(iep_msg->base, iep_msg->video_mode);
+        if (iep_msg->video_mode == normal_mode) {
+            IEP_REGB_SAT_CON(iep_msg->base, iep_msg->sat_con_int);
+            IEP_REGB_CONTRAST(iep_msg->base, iep_msg->contrast_int);
+            IEP_REGB_BRIGHTNESS(iep_msg->base, iep_msg->yuv_enh_brightness);
+            IEP_REGB_COS_HUE(iep_msg->base, iep_msg->cos_hue_int);
+            IEP_REGB_SIN_HUE(iep_msg->base, iep_msg->sin_hue_int);
+        } else if (iep_msg->video_mode == color_bar) { //color bar
+            IEP_REGB_COLOR_BAR_Y(iep_msg->base, iep_msg->color_bar_y);
+            IEP_REGB_COLOR_BAR_U(iep_msg->base, iep_msg->color_bar_u);
+            IEP_REGB_COLOR_BAR_V(iep_msg->base, iep_msg->color_bar_v);
+        }
+
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==yuv contrast,saturation,hue,bright cofing==//\n\n");
+    IEP_DBG("sw_yuv_enh_en              = %d;//yuv enhance enable\n", iep_msg->yuv_enhance_en);
+    IEP_DBG("sw_sat_con                 = %d;//saturation*contrast*128 (0<saturation<1.992,0<contrast<1.992)\n", iep_msg->sat_con_int);
+    IEP_DBG("sw_contrast                = %d;//contrast*128 (0<contrast<1.992)\n", iep_msg->contrast_int);
+    IEP_DBG("sw_brightness              = %d;//brightness (-32<brightness<31)\n", iep_msg->yuv_enh_brightness);
+    IEP_DBG("sw_cos_hue                 = %d;//cos(hue) (0<hue<30,triangle)\n", iep_msg->cos_hue_int);
+    IEP_DBG("sw_sin_hue                 = %d;//sin(hue) (0<hue<30,triangle)\n", iep_msg->sin_hue_int);
+    IEP_DBG("sw_color_bar_y             = %d;\n", iep_msg->color_bar_y);
+    IEP_DBG("sw_color_bar_u             = %d;\n", iep_msg->color_bar_u);
+    IEP_DBG("sw_color_bar_v             = %d;\n", iep_msg->color_bar_v);
+    IEP_DBG("sw_video_mode              = %d;\n\n", iep_msg->video_mode);
+#endif
+
+}
+
+static void iep_config_rgb2yuv(IEP_MSG *iep_msg)
+{
+    unsigned char cond1, cond2;
+    unsigned int rgb2yuv_en = 0;
+
+    //rgb in,yuv out
+    cond1 = ((iep_msg->src.format <= 5) && (iep_msg->dst.format > 5)) ? 1 : 0;
+
+    //rgb process,yuv out
+    cond2 = (((iep_msg->rgb_color_enhance_en == 1) || (iep_msg->rgb_cg_en == 1) 
+              || (iep_msg->rgb_enhance_mode != rgb_enhance_bypass)) && (iep_msg->dst.format > 5)) ? 1 : 0;
+
+
+    if ((cond1 == 1) || (cond2 == 1)) {
+        IEP_REGB_RGB_TO_YUV_EN(iep_msg->base, 1);
+        rgb2yuv_en = 1;
+        IEP_REGB_RGB2YUV_COE_SEL(iep_msg->base, iep_msg->rgb2yuv_mode);
+        IEP_REGB_RGB2YUV_INPUT_CLIP(iep_msg->base, iep_msg->rgb2yuv_clip_en);
+    } else IEP_REGB_RGB_TO_YUV_EN(iep_msg->base, 0);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==color space conversion config============//\n\n");
+    IEP_DBG("sw_rgb_to_yuv_en           = %d;\n", rgb2yuv_en);
+    IEP_DBG("sw_rgb2yuv_coe_sel         = %d;\n", iep_msg->rgb2yuv_mode);
+    IEP_DBG("sw_rgb2yuv_input_clip      = %d;\n\n", iep_msg->rgb2yuv_clip_en);
+#endif
+
+}
+
+static void iep_config_yuv2rgb(IEP_MSG *iep_msg)
+{
+    unsigned char cond1, cond2;
+    unsigned int yuv2rgb_en = 0;
+
+    //yuv in,rgb out
+    cond1 = ((iep_msg->src.format > 5) && (iep_msg->dst.format <= 5)) ? 1 : 0;
+
+    //yuv in,rgb process
+    cond2 = (((iep_msg->rgb_color_enhance_en == 1) || (iep_msg->rgb_cg_en == 1) 
+              || (iep_msg->rgb_enhance_mode != rgb_enhance_bypass)) && (iep_msg->src.format > 5)) ? 1 : 0;
+
+    if ((cond1 == 1) || (cond2 == 1)) {
+        IEP_REGB_YUV_TO_RGB_EN(iep_msg->base, 1);
+        yuv2rgb_en = 1;
+        IEP_REGB_YUV2RGB_COE_SEL(iep_msg->base, iep_msg->yuv2rgb_mode);
+        IEP_REGB_YUV2RGB_INPUT_CLIP(iep_msg->base, iep_msg->yuv2rgb_clip_en);
+    } else IEP_REGB_YUV_TO_RGB_EN(iep_msg->base, 0);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_yuv_to_rgb_en           = %d;\n", yuv2rgb_en);
+    IEP_DBG("sw_yuv2rgb_coe_sel         = %d;\n", iep_msg->yuv2rgb_mode);
+    IEP_DBG("sw_yuv2rgb_input_clip      = %d;\n\n", iep_msg->yuv2rgb_clip_en);
+#endif
+}
+
+static void iep_config_dither_up(IEP_MSG *iep_msg)
+{
+    unsigned int dither_up = 0;
+    if ((iep_msg->src.format == IEP_FORMAT_RGB_565) || (iep_msg->src.format == IEP_FORMAT_BGR_565)) {
+        IEP_REGB_DITHER_UP_EN(iep_msg->base, iep_msg->dither_up_en);
+        dither_up = iep_msg->dither_up_en;
+    }	    else IEP_REGB_DITHER_UP_EN(iep_msg->base, 0);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==dither config=============================//\n\n");
+    IEP_DBG("sw_dither_up_en            = %d;\n", dither_up);
+#endif
+}
+
+static void iep_config_dither_down(IEP_MSG *iep_msg)
+{
+    unsigned int dither_down = 0;
+    if ((iep_msg->dst.format == IEP_FORMAT_RGB_565) || (iep_msg->dst.format == IEP_FORMAT_BGR_565)) {
+        IEP_REGB_DITHER_DOWN_EN(iep_msg->base, 1);
+        dither_down = 1;
+    } else IEP_REGB_DITHER_DOWN_EN(iep_msg->base, 0);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("sw_dither_down_en            = %d;\n\n", dither_down);
+#endif
+}
+
+static void iep_config_glb_alpha(IEP_MSG *iep_msg)
+{
+    IEP_REGB_GLB_ALPHA(iep_msg->base, iep_msg->global_alpha_value);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==global alpha for ARGB config=============//\n\n");
+    IEP_DBG("sw_glb_alpha               = %d;//global alpha value for output ARGB\n\n", iep_msg->global_alpha_value);
+#endif
+}
+
+static void iep_config_vir_line(IEP_MSG *iep_msg)
+{
+    unsigned int src_vir_w;
+    unsigned int dst_vir_w;
+
+    switch (iep_msg->src.format) {
+    case IEP_FORMAT_ARGB_8888 :
+        src_vir_w = iep_msg->src.vir_w;
+        break;
+    case IEP_FORMAT_ABGR_8888 :
+        src_vir_w = iep_msg->src.vir_w;
+        break;
+    case IEP_FORMAT_RGBA_8888 :
+        src_vir_w = iep_msg->src.vir_w;
+        break;
+    case IEP_FORMAT_BGRA_8888 :
+        src_vir_w = iep_msg->src.vir_w;
+        break;
+    case IEP_FORMAT_RGB_565 :
+        if (iep_msg->src.vir_w % 2 == 1) src_vir_w = (iep_msg->src.vir_w + 1) / 2;
+        else src_vir_w = iep_msg->src.vir_w / 2;
+        break;
+    case IEP_FORMAT_BGR_565 :
+        if (iep_msg->src.vir_w % 2 == 1) src_vir_w = iep_msg->src.vir_w / 2 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 2;
+        break;
+    case IEP_FORMAT_YCbCr_422_SP :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_422_P :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_420_P :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_422_SP :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_422_P :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_420_SP :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_420_P :
+        if (iep_msg->src.vir_w % 4 != 0) src_vir_w = iep_msg->src.vir_w / 4 + 1;
+        else src_vir_w = iep_msg->src.vir_w / 4;
+        break;
+    default:
+        IEP_ERR("Unkown format, set the source image virtual width 0\n");
+        src_vir_w = 0;
+        break;
+    }
+
+    switch (iep_msg->dst.format) {
+    case IEP_FORMAT_ARGB_8888 :
+        dst_vir_w = iep_msg->dst.vir_w;
+        break;
+    case IEP_FORMAT_ABGR_8888 :
+        dst_vir_w = iep_msg->dst.vir_w;
+        break;
+    case IEP_FORMAT_RGBA_8888 :
+        dst_vir_w = iep_msg->dst.vir_w;
+        break;
+    case IEP_FORMAT_BGRA_8888 :
+        dst_vir_w = iep_msg->dst.vir_w;
+        break;
+    case IEP_FORMAT_RGB_565 :
+        if (iep_msg->dst.vir_w % 2 == 1) dst_vir_w = (iep_msg->dst.vir_w + 1) / 2;
+        else dst_vir_w = iep_msg->dst.vir_w / 2;
+        break;
+    case IEP_FORMAT_BGR_565 :
+        if (iep_msg->dst.vir_w % 2 == 1) dst_vir_w = iep_msg->dst.vir_w / 2 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 2;
+        break;
+    case IEP_FORMAT_YCbCr_422_SP :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_422_P :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCbCr_420_P :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_422_SP :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_422_P :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_420_SP :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    case IEP_FORMAT_YCrCb_420_P :
+        if (iep_msg->dst.vir_w % 4 != 0) dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+        else dst_vir_w = iep_msg->dst.vir_w / 4;
+        break;
+    default:
+        IEP_ERR("Unkown format, set the destination image virtual width 0\n");
+        dst_vir_w = 0;
+        break;
+    }
+    IEP_REGB_DST_VIR_LINE_WIDTH(iep_msg->base, dst_vir_w);
+    IEP_REGB_SRC_VIR_LINE_WIDTH(iep_msg->base, src_vir_w);
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("/==virtual line width config==================//\n\n");
+    IEP_DBG("sw_dst_vir_line_width      = %d;//destination virtual line width \n", dst_vir_w);
+    IEP_DBG("sw_src_vir_line_width      = %d;//source virtual line width \n\n", src_vir_w);
+#endif
+}
+
+static void iep_config_src_addr(IEP_MSG *iep_msg)
+{
+    u32 src_addr_yrgb;
+    u32 src_addr_cbcr;
+    u32 src_addr_cr;
+    u32 src_addr_y1;
+    u32 src_addr_cbcr1;
+    u32 src_addr_cr1;
+    u32 src_addr_y_itemp;
+    u32 src_addr_cbcr_itemp;
+    u32 src_addr_cr_itemp;
+    u32 src_addr_y_ftemp;
+    u32 src_addr_cbcr_ftemp;
+    u32 src_addr_cr_ftemp;
+    unsigned int offset_addr_y = 0;
+    unsigned int offset_addr_uv = 0;
+    unsigned int offset_addr_v = 0;
+    //unsigned int offset_addr_y_w = 0;
+    unsigned int offset_addr_uv_w = 0;
+    unsigned int offset_addr_v_w = 0;
+    //unsigned int offset_addr_y_h = 0;
+    unsigned int offset_addr_uv_h = 0;
+    unsigned int offset_addr_v_h = 0;
+
+    unsigned int offset_x_equ_uv;
+    unsigned int offset_x_u_byte;
+    unsigned int offset_x_v_byte;
+    unsigned int vir_w_euq_uv;
+    unsigned int line_u_byte;
+    unsigned int line_v_byte;
+    unsigned int offset_y_equ_420_uv = 0;
+
+    //**********************************************//
+    //***********y addr offset**********************//
+    //**********************************************//
+    if (iep_msg->src.format <= 3) {
+        offset_addr_y = iep_msg->src.y_off * 4 * iep_msg->src.vir_w + iep_msg->src.x_off * 4;
+    } else if (iep_msg->src.format <= 5) {
+        offset_addr_y = iep_msg->src.y_off * 2 * iep_msg->src.vir_w + iep_msg->src.x_off * 2;
+    } else {
+        offset_addr_y = iep_msg->src.y_off * iep_msg->src.vir_w + iep_msg->src.x_off;
+    }
+
+    //**********************************************//
+    //***********uv addr offset*********************//
+    //**********************************************//
+    // note: image size align to even when image format is yuv
+
+    //----------offset_w--------//
+    if (iep_msg->src.x_off % 2 == 1) offset_x_equ_uv = iep_msg->src.x_off + 1;
+    else offset_x_equ_uv = iep_msg->src.x_off;
+
+    offset_x_u_byte = offset_x_equ_uv / 2;
+    offset_x_v_byte = offset_x_equ_uv / 2;
+
+    if ((iep_msg->src.format == IEP_FORMAT_YCbCr_422_SP) || (iep_msg->src.format == IEP_FORMAT_YCbCr_420_SP) 
+        || (iep_msg->src.format == IEP_FORMAT_YCrCb_422_SP) || (iep_msg->src.format == IEP_FORMAT_YCrCb_420_SP)) offset_addr_uv_w = offset_x_u_byte + offset_x_v_byte;
+    else {
+        offset_addr_uv_w = offset_x_u_byte;
+        offset_addr_v_w = offset_x_v_byte;
+    }
+
+    //----------offset_h--------//
+    if (iep_msg->src.vir_w % 2 == 1) vir_w_euq_uv = iep_msg->src.vir_w + 1;
+    else vir_w_euq_uv = iep_msg->src.vir_w;
+
+    line_u_byte = vir_w_euq_uv / 2;
+    line_v_byte = vir_w_euq_uv / 2;
+
+    if (iep_msg->src.y_off % 2 == 1) offset_y_equ_420_uv = iep_msg->src.y_off + 1;
+    else offset_y_equ_420_uv = iep_msg->src.y_off;
+
+    switch (iep_msg->src.format) {
+    case IEP_FORMAT_YCbCr_422_SP :
+        offset_addr_uv_h = (line_u_byte + line_v_byte) * iep_msg->src.y_off;
+        break;
+    case IEP_FORMAT_YCbCr_422_P :
+        offset_addr_uv_h = line_u_byte * iep_msg->src.y_off;
+        offset_addr_v_h = line_v_byte * iep_msg->src.y_off;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP :
+        offset_addr_uv_h = (line_u_byte + line_v_byte) * offset_y_equ_420_uv / 2;
+        break;
+    case IEP_FORMAT_YCbCr_420_P :
+        offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+        offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+        break;
+    case IEP_FORMAT_YCrCb_422_SP :
+        offset_addr_uv_h = (line_u_byte + line_v_byte) * iep_msg->src.y_off;
+        break;
+    case IEP_FORMAT_YCrCb_422_P :
+        offset_addr_uv_h = line_u_byte * iep_msg->src.y_off;
+        offset_addr_v_h = line_v_byte * iep_msg->src.y_off;
+        break;
+    case IEP_FORMAT_YCrCb_420_SP :
+        offset_addr_uv_h = (line_u_byte + line_v_byte) * offset_y_equ_420_uv / 2;
+        break;
+    case IEP_FORMAT_YCrCb_420_P :
+        offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+        offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+        break;
+    default:
+        break;
+    }
+    //----------offset u/v addr--------//
+
+    offset_addr_uv = offset_addr_uv_w + offset_addr_uv_h;
+    offset_addr_v  = offset_addr_v_w + offset_addr_v_h;
+    //**********************************************//
+    //***********yuv address   *********************//
+    //**********************************************//
+    src_addr_yrgb = ((u32)iep_msg->src.mem_addr) + offset_addr_y;
+    src_addr_cbcr = ((u32)iep_msg->src.uv_addr) + offset_addr_uv;
+    src_addr_cr = ((u32)iep_msg->src.v_addr) + offset_addr_v;
+
+    // former frame when processing deinterlace
+    src_addr_y1 = ((u32)iep_msg->src1.mem_addr) + offset_addr_y;
+    src_addr_cbcr1 = ((u32)iep_msg->src1.uv_addr) + offset_addr_uv;
+    src_addr_cr1 = ((u32)iep_msg->src1.v_addr) + offset_addr_v;
+
+    src_addr_y_itemp = ((u32)iep_msg->src_itemp.mem_addr) + offset_addr_y;
+    src_addr_cbcr_itemp = ((u32)iep_msg->src_itemp.uv_addr) + offset_addr_uv;
+    src_addr_cr_itemp = ((u32)iep_msg->src_itemp.v_addr) + offset_addr_v;
+
+    src_addr_y_ftemp = ((u32)iep_msg->src_ftemp.mem_addr) + offset_addr_y;
+    src_addr_cbcr_ftemp = ((u32)iep_msg->src_ftemp.uv_addr) + offset_addr_uv;
+    src_addr_cr_ftemp = ((u32)iep_msg->src_ftemp.v_addr) + offset_addr_v;
+
+    if ((iep_msg->dein_mode == IEP_DEINTERLACE_MODE_I4O1 || iep_msg->dein_mode == IEP_DEINTERLACE_MODE_I4O2) &&
+#if 1
+           iep_msg->field_order == FIELD_ORDER_BOTTOM_FIRST
+#else
+           iep_msg->field_order == FIELD_ORDER_TOP_FIRST
+#endif
+          ) {
+        IEP_REGB_SRC_ADDR_YRGB(iep_msg->base, src_addr_y1);
+        IEP_REGB_SRC_ADDR_CBCR(iep_msg->base, src_addr_cbcr1);
+        IEP_REGB_SRC_ADDR_CR(iep_msg->base, src_addr_cr1);
+        IEP_REGB_SRC_ADDR_Y1(iep_msg->base, src_addr_yrgb);
+        IEP_REGB_SRC_ADDR_CBCR1(iep_msg->base, src_addr_cbcr);
+        IEP_REGB_SRC_ADDR_CR1(iep_msg->base, src_addr_cr);
+    } else {
+        IEP_REGB_SRC_ADDR_YRGB(iep_msg->base, src_addr_yrgb);
+        IEP_REGB_SRC_ADDR_CBCR(iep_msg->base, src_addr_cbcr);
+        IEP_REGB_SRC_ADDR_CR(iep_msg->base, src_addr_cr);
+        IEP_REGB_SRC_ADDR_Y1(iep_msg->base, src_addr_y1);
+        IEP_REGB_SRC_ADDR_CBCR1(iep_msg->base, src_addr_cbcr1);
+        IEP_REGB_SRC_ADDR_CR1(iep_msg->base, src_addr_cr1);
+    }
+
+    if (iep_msg->yuv_3D_denoise_en) {
+        IEP_REGB_SRC_ADDR_Y_ITEMP(iep_msg->base, src_addr_y_itemp);
+        IEP_REGB_SRC_ADDR_CBCR_ITEMP(iep_msg->base, src_addr_cbcr_itemp);
+        IEP_REGB_SRC_ADDR_Y_FTEMP(iep_msg->base, src_addr_y_ftemp);
+        IEP_REGB_SRC_ADDR_CBCR_FTEMP(iep_msg->base, src_addr_cbcr_ftemp);
+        if ((iep_msg->src.format == IEP_FORMAT_YCbCr_422_P) || (iep_msg->src.format == IEP_FORMAT_YCbCr_420_P) 
+            || (iep_msg->src.format == IEP_FORMAT_YCrCb_422_P) || (iep_msg->src.format == IEP_FORMAT_YCrCb_420_P)) {
+            IEP_REGB_SRC_ADDR_CR_ITEMP(iep_msg->base, src_addr_cr_itemp);
+            IEP_REGB_SRC_ADDR_CR_FTEMP(iep_msg->base, src_addr_cr_ftemp);
+        }
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//-------source address for image-------// \n\n");
+    IEP_DBG("sw_src_addr_yrgb           = 32'h%x;\n", src_addr_yrgb);
+    IEP_DBG("sw_src_addr_cbcr           = 32'h%x;\n", src_addr_cbcr);
+    IEP_DBG("sw_src_addr_cr             = 32'h%x;\n", src_addr_cr);
+    IEP_DBG("sw_src_addr_y1             = 32'h%x;\n", src_addr_y1);
+    IEP_DBG("sw_src_addr_cbcr0          = 32'h%x;\n", src_addr_cbcr1);
+    IEP_DBG("sw_src_addr_cr0            = 32'h%x;\n", src_addr_cr1);
+    IEP_DBG("sw_src_addr_y_itemp        = 32'h%x;\n", src_addr_y_itemp);
+    IEP_DBG("sw_src_addr_cbcr_itemp     = 32'h%x;\n", src_addr_cbcr_itemp);
+    IEP_DBG("sw_src_addr_cr_itemp       = 32'h%x;\n", src_addr_cr_itemp);
+    IEP_DBG("sw_src_addr_y_ftemp        = 32'h%x;\n", src_addr_y_ftemp);
+    IEP_DBG("sw_src_addr_cbcr_ftemp     = 32'h%x;\n", src_addr_cbcr_ftemp);
+    IEP_DBG("sw_src_addr_cr_ftemp       = 32'h%x;\n\n", src_addr_cr_ftemp);
+#endif
+}
+
+static void iep_config_dst_addr(IEP_MSG *iep_msg)
+{
+    IEP_REGB_DST_ADDR_YRGB(iep_msg->base, (u32)iep_msg->dst.mem_addr);
+    IEP_REGB_DST_ADDR_CBCR(iep_msg->base, (u32)iep_msg->dst.uv_addr);
+    IEP_REGB_DST_ADDR_Y1(iep_msg->base, (u32)iep_msg->dst1.mem_addr);
+    IEP_REGB_DST_ADDR_CBCR1(iep_msg->base, (u32)iep_msg->dst1.uv_addr);
+    IEP_REGB_DST_ADDR_CR(iep_msg->base, (u32)iep_msg->dst.v_addr);
+    IEP_REGB_DST_ADDR_CR1(iep_msg->base, (u32)iep_msg->dst1.v_addr);
+
+    if (iep_msg->yuv_3D_denoise_en) {
+        IEP_REGB_DST_ADDR_Y_ITEMP(iep_msg->base, (u32)iep_msg->dst_itemp.mem_addr);
+        IEP_REGB_DST_ADDR_CBCR_ITEMP(iep_msg->base, (u32)iep_msg->dst_itemp.uv_addr);
+        IEP_REGB_DST_ADDR_Y_FTEMP(iep_msg->base, (u32)iep_msg->dst_ftemp.mem_addr);
+        IEP_REGB_DST_ADDR_CBCR_FTEMP(iep_msg->base, (u32)iep_msg->dst_ftemp.uv_addr);
+        if ((iep_msg->dst.format == IEP_FORMAT_YCbCr_422_P) || (iep_msg->dst.format == IEP_FORMAT_YCbCr_420_P) 
+            || (iep_msg->dst.format == IEP_FORMAT_YCrCb_422_P) || (iep_msg->dst.format == IEP_FORMAT_YCrCb_420_P)) {
+            IEP_REGB_DST_ADDR_CR_ITEMP(iep_msg->base, (u32)iep_msg->dst_itemp.v_addr);
+            IEP_REGB_DST_ADDR_CR_FTEMP(iep_msg->base, (u32)iep_msg->dst_ftemp.v_addr);
+        }
+    }
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//-------destination address for image-------// \n\n");
+    IEP_DBG("sw_dst_addr_yrgb           = 32'h%x;\n", (u32)iep_msg->dst.mem_addr);
+    IEP_DBG("sw_dst_addr_cbcr           = 32'h%x;\n", (u32)iep_msg->dst.uv_addr);
+    IEP_DBG("sw_dst_addr_cr             = 32'h%x;\n", (u32)iep_msg->dst.v_addr);
+    IEP_DBG("sw_dst_addr_y1             = 32'h%x;\n", (u32)iep_msg->dst1.mem_addr);
+    IEP_DBG("sw_dst_addr_cbcr0          = 32'h%x;\n", (u32)iep_msg->dst1.uv_addr);
+    IEP_DBG("sw_dst_addr_cr0            = 32'h%x;\n", (u32)iep_msg->dst1.v_addr);
+    IEP_DBG("sw_dst_addr_y_itemp        = 32'h%x;\n", (u32)iep_msg->dst_itemp.mem_addr);
+    IEP_DBG("sw_dst_addr_cbcr_itemp     = 32'h%x;\n", (u32)iep_msg->dst_itemp.uv_addr);
+    IEP_DBG("sw_dst_addr_cr_itemp       = 32'h%x;\n", (u32)iep_msg->dst_itemp.v_addr);
+    IEP_DBG("sw_dst_addr_y_ftemp        = 32'h%x;\n", (u32)iep_msg->dst_ftemp.mem_addr);
+    IEP_DBG("sw_dst_addr_cbcr_ftemp     = 32'h%x;\n", (u32)iep_msg->dst_ftemp.uv_addr);
+    IEP_DBG("sw_dst_addr_cr_ftemp       = 32'h%x;\n\n", (u32)iep_msg->dst_ftemp.v_addr);
+#endif
+}
+
+void iep_config_lcdc_path(IEP_MSG *iep_msg)
+{
+    IEP_REGB_LCDC_PATH_EN(iep_msg->base, iep_msg->lcdc_path_en);
+
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==write back or lcdc direct path config=====// \n\n");
+    IEP_DBG("sw_lcdc_path_en            = %d;//lcdc direct path enable,c model don't care this value\n\n", iep_msg->lcdc_path_en);
+#endif
+}
+
+int iep_probe_int(void *base)
+{
+    return ReadReg32(base, rIEP_INT) & 1;
+}
+
+void iep_config_frame_end_int_clr(void *base)
+{
+    IEP_REGB_FRAME_END_INT_CLR(base, 1);
+}
+
+void iep_config_frame_end_int_en(void *base)
+{
+    IEP_REGB_FRAME_END_INT_CLR(base, 1);
+    IEP_REGB_FRAME_END_INT_EN(base, 1);
+}
+
+#if defined(CONFIG_IEP_MMU)
+struct iep_mmu_int_status iep_probe_mmu_int_status(void *base)
+{
+    uint32_t mmu_int_sts = IEP_REGB_MMU_INT_STATUS(base);
+    struct iep_mmu_int_status sts;
+
+    memcpy(&sts, &mmu_int_sts, 4);
+
+    return sts;
+}
+
+void iep_config_mmu_page_fault_int_en(void *base, bool en)
+{
+    IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN(base, en);
+}
+
+void iep_config_mmu_page_fault_int_clr(void *base)
+{
+    IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR(base, 1);
+}
+
+void iep_config_mmu_read_bus_error_int_clr(void *base)
+{
+    IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR(base, 1);
+}
+
+uint32_t iep_probe_mmu_page_fault_addr(void *base)
+{
+    return IEP_REGB_MMU_PAGE_FAULT_ADDR(base);
+}
+
+void iep_config_mmu_cmd(void *base, enum iep_mmu_cmd cmd)
+{
+    IEP_REGB_MMU_CMD(base, cmd);
+}
+
+void iep_config_mmu_dte_addr(void *base, uint32_t addr) {
+    IEP_REGB_MMU_DTE_ADDR(base, addr);
+}
+#endif
+
+void iep_config_misc(IEP_MSG *iep_msg)
+{
+//	IEP_REGB_V_REVERSE_DISP();
+//	IEP_REGB_H_REVERSE_DISP();
+#ifdef IEP_PRINT_INFO
+    IEP_DBG("//==misc config==========================//\n\n");
+    IEP_DBG("sw_v_reverse_disp          = 0;\n");
+    IEP_DBG("sw_u_reverse_disp          = 0;\n\n");
+#endif
+}
+
+#define IEP_RESET_TIMEOUT   1000
+void iep_soft_rst(void *base)
+{
+    unsigned int rst_state = 0;
+    int i = 0;
+    WriteReg32(base, rIEP_SOFT_RST, 2);
+    WriteReg32(base, rIEP_SOFT_RST, 1);
+    while (i++ < IEP_RESET_TIMEOUT) {
+        rst_state = ReadReg32(base, IEP_STATUS);
+        if ((rst_state & 0x200) == 0x200) {
+            break;
+        }
+
+        udelay(1);
+    }
+    WriteReg32(base, IEP_SOFT_RST, 2);
+
+    if (i == IEP_RESET_TIMEOUT) IEP_DBG("soft reset timeout.\n");
+}
+
+void iep_config_done(void *base)
+{
+    WriteReg32(base, rIEP_CONF_DONE, 1);
+}
+
+void iep_config_frm_start(void *base)
+{
+    IEP_REGB_FRM_START(base, 1);
+}
+
+struct iep_status iep_get_status(void *base)
+{
+    uint32_t sts_int = IEP_REGB_STATUS(base);
+    struct iep_status sts;
+
+    memcpy(&sts, &sts_int, 4);
+
+    return sts;
+}
+
+int iep_get_deinterlace_mode(void *base)
+{
+    int cfg = ReadReg32(base, IEP_CONFIG0);
+    return (cfg >> 8) & 0x7;
+}
+
+void iep_set_deinterlace_mode(int mode, void *base)
+{
+    int cfg;
+
+    if (mode > dein_mode_bypass) {
+        IEP_ERR("invalid deinterlace mode\n");
+        return;
+    }
+
+    cfg = ReadReg32(base, RAW_IEP_CONFIG0);
+    cfg = (cfg & (~(7<<8))) | (mode << 8);
+    WriteReg32(base, IEP_CONFIG0, cfg);
+
+    //IEP_REGB_DIL_MODE(base, mode);
+}
+
+void iep_switch_input_address(void *base) {
+    u32 src_addr_yrgb  = ReadReg32(base, IEP_SRC_ADDR_YRGB);
+    u32 src_addr_cbcr  = ReadReg32(base, IEP_SRC_ADDR_CBCR);
+    u32 src_addr_cr    = ReadReg32(base, IEP_SRC_ADDR_CR);
+
+    u32 src_addr_y1    = ReadReg32(base, IEP_SRC_ADDR_Y1);
+    u32 src_addr_cbcr1 = ReadReg32(base, IEP_SRC_ADDR_CBCR1);
+    u32 src_addr_cr1   = ReadReg32(base, IEP_SRC_ADDR_CR1);
+
+    IEP_REGB_SRC_ADDR_YRGB (base, src_addr_y1);
+    IEP_REGB_SRC_ADDR_CBCR (base, src_addr_cbcr1);
+    IEP_REGB_SRC_ADDR_CR   (base, src_addr_cr1);
+    IEP_REGB_SRC_ADDR_Y1   (base, src_addr_yrgb);
+    IEP_REGB_SRC_ADDR_CBCR1(base, src_addr_cbcr);
+    IEP_REGB_SRC_ADDR_CR1  (base, src_addr_cr);
+}
+
+/**
+ * generating a series of registers copy from iep message
+ */
+extern iep_service_info iep_service;
+void iep_config(iep_session *session, IEP_MSG *iep_msg)
+{
+    struct iep_reg *reg = kzalloc(sizeof(struct iep_reg), GFP_KERNEL);
+
+    reg->session = session;
+    iep_msg->base = reg->reg;
+    atomic_set(&reg->session->done, 0);
+
+    INIT_LIST_HEAD(&reg->session_link);
+    INIT_LIST_HEAD(&reg->status_link);
+
+    //write config
+    iep_config_src_size(iep_msg);
+    iep_config_dst_size(iep_msg);
+    iep_config_dst_width_tile(iep_msg); //not implement
+    iep_config_dst_fmt(iep_msg);
+    iep_config_src_fmt(iep_msg);
+    iep_config_scl(iep_msg);
+    iep_config_cg_order(iep_msg);
+
+    iep_config_cg(iep_msg);
+    iep_config_dde(iep_msg);            //not implement
+    iep_config_color_enh(iep_msg);      //not implement
+    iep_config_yuv_dns(iep_msg);
+    iep_config_dil(iep_msg);
+    iep_config_yuv_enh(iep_msg);
+    iep_config_rgb2yuv(iep_msg);
+    iep_config_yuv2rgb(iep_msg);
+    iep_config_dither_up(iep_msg);
+    iep_config_dither_down(iep_msg);
+    iep_config_glb_alpha(iep_msg);
+    iep_config_vir_line(iep_msg);
+    iep_config_src_addr(iep_msg);
+    iep_config_dst_addr(iep_msg);
+    iep_config_lcdc_path(iep_msg);
+    iep_config_misc(iep_msg);           //not implement
+
+    if (iep_msg->lcdc_path_en) {
+        reg->dpi_en     = true;
+        reg->act_width  = iep_msg->dst.act_w;
+        reg->act_height = iep_msg->dst.act_h;
+        reg->off_x      = iep_msg->off_x;
+        reg->off_y      = iep_msg->off_y;
+        reg->vir_width  = iep_msg->width;
+        reg->vir_height = iep_msg->height;
+        reg->layer      = iep_msg->layer;
+        reg->format     = iep_msg->dst.format;
+    } else {
+        reg->dpi_en     = false;
+    }
+
+#if defined(CONFIG_IEP_MMU)
+    if (iep_msg->vir_addr_enable) {
+        iep_config_mmu_cmd(iep_msg->base, MMU_ENABLE_PAGING);
+        iep_config_mmu_page_fault_int_en(iep_msg->base, 1);
+    } else {
+        iep_config_mmu_cmd(iep_msg->base, MMU_DISABLE_PAGING);
+        iep_config_mmu_page_fault_int_en(iep_msg->base, 0);
+    }
+    iep_config_mmu_dte_addr(iep_msg->base, (uint32_t)virt_to_phys((uint32_t*)session->dte_table));
+#endif
+
+    mutex_lock(&iep_service.lock);
+
+    list_add_tail(&reg->status_link, &iep_service.waiting);
+    list_add_tail(&reg->session_link, &session->waiting);
+    mutex_unlock(&iep_service.lock);
+}
+
diff --git a/drivers/video/rockchip/iep/hw_iep_reg.h b/drivers/video/rockchip/iep/hw_iep_reg.h
new file mode 100755
index 000000000000..3f66966f9986
--- /dev/null
+++ b/drivers/video/rockchip/iep/hw_iep_reg.h
@@ -0,0 +1,677 @@
+#ifndef IEP_REGS_H
+#define IEP_REGS_H
+#include "hw_iep_config_addr.h"
+#include "iep_api.h"
+#include "iep.h"
+#include "iep_drv.h"
+//#include "typedef.h"
+
+struct iep_status {
+    uint32_t reserved0   : 1; 
+    uint32_t scl_sts     : 1;
+    uint32_t dil_sts     : 1;
+    uint32_t reserved1   : 1;
+    uint32_t wyuv_sts    : 1;
+    uint32_t ryuv_sts    : 1;
+    uint32_t wrgb_sts    : 1;
+    uint32_t rrgb_sts    : 1;
+    uint32_t voi_sts     : 1;
+};
+
+#if defined(CONFIG_IEP_MMU)
+struct iep_mmu_status {
+    uint32_t paging_enabled         : 1;
+    uint32_t page_fault_active      : 1;
+    uint32_t stall_active           : 1;
+    uint32_t idle                   : 1;
+    uint32_t replay_buffer_empty    : 1;
+    uint32_t page_fault_is_write    : 1;
+    uint32_t page_fault_bus_id      : 5;
+};
+
+struct iep_mmu_int_status {
+    uint32_t page_fault     : 1;
+    uint32_t read_bus_error : 1;
+};
+
+enum iep_mmu_cmd {
+    MMU_ENABLE_PAGING,
+    MMU_DISABLE_PAGING,
+    MMU_ENABLE_STALL,
+    MMU_DISABLE_STALL,
+    MMU_ZAP_CACHE,
+    MMU_PAGE_FAULT_DONE,
+    MMU_FORCE_RESET
+};
+#endif
+
+//
+#define      rIEP_CONFIG0      		         (IEP_BASE+IEP_CONFIG0)
+#define      rIEP_CONFIG1      		         (IEP_BASE+IEP_CONFIG1)
+
+#define      rIEP_STATUS              	     (IEP_BASE+IEP_STATUS)
+#define      rIEP_INT                 	     (IEP_BASE+IEP_INT)
+#define      rIEP_FRM_START         	     (IEP_BASE+IEP_FRM_START)
+#define      rIEP_SOFT_RST           	     (IEP_BASE+IEP_SOFT_RST)
+#define      rIEP_CONF_DONE                  (IEP_BASE+IEP_CONF_DONE)
+
+#define      rIEP_VIR_IMG_WIDTH        	     (IEP_BASE+IEP_VIR_IMG_WIDTH)
+
+#define      rIEP_IMG_SCL_FCT         	     (IEP_BASE+IEP_IMG_SCL_FCT)
+
+#define      rIEP_SRC_IMG_SIZE         	     (IEP_BASE+IEP_SRC_IMG_SIZE)
+#define      rIEP_DST_IMG_SIZE         	     (IEP_BASE+IEP_DST_IMG_SIZE)
+
+#define      rIEP_DST_IMG_WIDTH_TILE0  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE0)
+#define      rIEP_DST_IMG_WIDTH_TILE1  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE1)
+#define      rIEP_DST_IMG_WIDTH_TILE2  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE2)
+#define      rIEP_DST_IMG_WIDTH_TILE3  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE3)
+
+#define      rIEP_ENH_YUV_CNFG_0       	     (IEP_BASE+IEP_ENH_YUV_CNFG_0)
+#define      rIEP_ENH_YUV_CNFG_1       	     (IEP_BASE+IEP_ENH_YUV_CNFG_1)
+#define      rIEP_ENH_YUV_CNFG_2       	     (IEP_BASE+IEP_ENH_YUV_CNFG_2)
+#define      rIEP_ENH_RGB_CNFG        	     (IEP_BASE+IEP_ENH_RGB_CNFG)  
+#define      rIEP_ENH_C_COE            	     (IEP_BASE+IEP_ENH_C_COE)
+
+#define      rIEP_SRC_ADDR_YRGB        	     (IEP_BASE+IEP_SRC_ADDR_YRGB)
+#define      rIEP_SRC_ADDR_CBCR              (IEP_BASE+IEP_SRC_ADDR_CBCR)
+#define      rIEP_SRC_ADDR_CR                (IEP_BASE+IEP_SRC_ADDR_CR)
+#define      rIEP_SRC_ADDR_Y1                (IEP_BASE+IEP_SRC_ADDR_Y1)
+#define      rIEP_SRC_ADDR_CBCR1             (IEP_BASE+IEP_SRC_ADDR_CBCR1)
+#define      rIEP_SRC_ADDR_CR1               (IEP_BASE+IEP_SRC_ADDR_CR1)
+#define      rIEP_SRC_ADDR_Y_ITEMP           (IEP_BASE+IEP_SRC_ADDR_Y_ITEMP)
+#define      rIEP_SRC_ADDR_CBCR_ITEMP        (IEP_BASE+IEP_SRC_ADDR_CBCR_ITEMP)
+#define      rIEP_SRC_ADDR_CR_ITEMP          (IEP_BASE+IEP_SRC_ADDR_CR_ITEMP)
+#define      rIEP_SRC_ADDR_Y_FTEMP           (IEP_BASE+IEP_SRC_ADDR_Y_FTEMP)
+#define      rIEP_SRC_ADDR_CBCR_FTEMP        (IEP_BASE+IEP_SRC_ADDR_CBCR_FTEMP)
+#define      rIEP_SRC_ADDR_CR_FTEMP          (IEP_BASE+IEP_SRC_ADDR_CR_FTEMP)
+
+#define      rIEP_DST_ADDR_YRGB        	     (IEP_BASE+IEP_DST_ADDR_YRGB)
+#define      rIEP_DST_ADDR_CBCR              (IEP_BASE+IEP_DST_ADDR_CBCR)
+#define      rIEP_DST_ADDR_CR                (IEP_BASE+IEP_DST_ADDR_CR)
+#define      rIEP_DST_ADDR_Y1                (IEP_BASE+IEP_DST_ADDR_Y1)
+#define      rIEP_DST_ADDR_CBCR1             (IEP_BASE+IEP_DST_ADDR_CBCR1)
+#define      rIEP_DST_ADDR_CR1               (IEP_BASE+IEP_DST_ADDR_CR1)
+#define      rIEP_DST_ADDR_Y_ITEMP           (IEP_BASE+IEP_DST_ADDR_Y_ITEMP)
+#define      rIEP_DST_ADDR_CBCR_ITEMP        (IEP_BASE+IEP_DST_ADDR_CBCR_ITEMP)
+#define      rIEP_DST_ADDR_CR_ITEMP          (IEP_BASE+IEP_DST_ADDR_CR_ITEMP)
+#define      rIEP_DST_ADDR_Y_FTEMP           (IEP_BASE+IEP_DST_ADDR_Y_FTEMP)
+#define      rIEP_DST_ADDR_CBCR_FTEMP        (IEP_BASE+IEP_DST_ADDR_CBCR_FTEMP)
+#define      rIEP_DST_ADDR_CR_FTEMP          (IEP_BASE+IEP_DST_ADDR_CR_FTEMP)
+
+#define      rIEP_DIL_MTN_TAB0               (IEP_BASE+IEP_DIL_MTN_TAB0)
+#define      rIEP_DIL_MTN_TAB1               (IEP_BASE+IEP_DIL_MTN_TAB1)
+#define      rIEP_DIL_MTN_TAB2               (IEP_BASE+IEP_DIL_MTN_TAB2)
+#define      rIEP_DIL_MTN_TAB3               (IEP_BASE+IEP_DIL_MTN_TAB3)
+#define      rIEP_DIL_MTN_TAB4               (IEP_BASE+IEP_DIL_MTN_TAB4)
+#define      rIEP_DIL_MTN_TAB5               (IEP_BASE+IEP_DIL_MTN_TAB5)
+#define      rIEP_DIL_MTN_TAB6               (IEP_BASE+IEP_DIL_MTN_TAB6)
+#define      rIEP_DIL_MTN_TAB7               (IEP_BASE+IEP_DIL_MTN_TAB7)
+
+#define      rIEP_ENH_CG_TAB                 (IEP_BASE+IEP_ENH_CG_TAB)
+
+#define      rIEP_YUV_DNS_CRCT_TEMP          (IEP_BASE+IEP_YUV_DNS_CRCT_TEMP)
+#define      rIEP_YUV_DNS_CRCT_SPAT          (IEP_BASE+IEP_YUV_DNS_CRCT_SPAT)
+
+#define      rIEP_ENH_DDE_COE0               (IEP_BASE+IEP_ENH_DDE_COE0)
+#define      rIEP_ENH_DDE_COE1               (IEP_BASE+IEP_ENH_DDE_COE1)
+
+#define      RAW_rIEP_CONFIG0                (IEP_BASE+RAW_IEP_CONFIG0)
+#define      RAW_rIEP_CONFIG1      		     (IEP_BASE+RAW_IEP_CONFIG1)
+#define      RAW_rIEP_VIR_IMG_WIDTH          (IEP_BASE+RAW_IEP_VIR_IMG_WIDTH)
+
+#define      RAW_rIEP_IMG_SCL_FCT      	     (IEP_BASE+RAW_IEP_IMG_SCL_FCT)
+
+#define      RAW_rIEP_SRC_IMG_SIZE      	 (IEP_BASE+RAW_IEP_SRC_IMG_SIZE)
+#define      RAW_rIEP_DST_IMG_SIZE      	 (IEP_BASE+RAW_IEP_DST_IMG_SIZE)
+
+#define      RAW_rIEP_ENH_YUV_CNFG_0         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_0)
+#define      RAW_rIEP_ENH_YUV_CNFG_1         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_1)
+#define      RAW_rIEP_ENH_YUV_CNFG_2         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_2)
+#define      RAW_rIEP_ENH_RGB_CNFG           (IEP_BASE+RAW_IEP_ENH_RGB_CNFG)
+
+#define      rIEP_CG_TAB_ADDR                 (IEP_BASE+0x0100) 
+
+#if defined(CONFIG_IEP_MMU)
+#define      rIEP_MMU_BASE                    0x0800
+#define      rIEP_MMU_DTE_ADDR                (IEP_MMU_BASE+0x00)
+#define      rIEP_MMU_STATUS                  (IEP_MMU_BASE+0x04)
+#define      rIEP_MMU_CMD                     (IEP_MMU_BASE+0x08)
+#define      rIEP_MMU_PAGE_FAULT_ADDR         (IEP_MMU_BASE+0x0c)
+#define      rIEP_MMU_ZAP_ONE_LINE            (IEP_MMU_BASE+0x10)
+#define      rIEP_MMU_INT_RAWSTAT             (IEP_MMU_BASE+0x14)
+#define      rIEP_MMU_INT_CLEAR               (IEP_MMU_BASE+0x18)
+#define      rIEP_MMU_INT_MASK                (IEP_MMU_BASE+0x1c)
+#define      rIEP_MMU_INT_STATUS              (IEP_MMU_BASE+0x20)
+#define      rIEP_MMU_AUTO_GATING             (IEP_MMU_BASE+0x24)
+#endif
+
+/*-----------------------------------------------------------------
+//reg bit operation definition
+-----------------------------------------------------------------*/
+/*-----------------------------------------------------------------
+//MaskRegBits32(addr, y, z),get z
+-----------------------------------------------------------------*/
+//iep_config0
+#define     IEP_REGB_V_REVERSE_DISP_Z(x)      (((x)&0x1 ) << 31 )
+#define     IEP_REGB_H_REVERSE_DISP_Z(x)      (((x)&0x1 ) << 30 )
+#define     IEP_REGB_SCL_EN_Z(x)              (((x)&0x1 ) << 28 )
+#define     IEP_REGB_SCL_SEL_Z(x)             (((x)&0x3 ) << 26 )
+#define     IEP_REGB_SCL_UP_COE_SEL_Z(x)      (((x)&0x3 ) << 24 )
+#define     IEP_REGB_DIL_EI_SEL_Z(x)          (((x)&0x1 ) << 23 )
+#define     IEP_REGB_DIL_EI_RADIUS_Z(x)       (((x)&0x3 ) << 21 )
+#define     IEP_REGB_CON_GAM_ORDER_Z(x)       (((x)&0x1 ) << 20 )
+#define     IEP_REGB_RGB_ENH_SEL_Z(x)         (((x)&0x3 ) << 18 )
+#define     IEP_REGB_RGB_CON_GAM_EN_Z(x)      (((x)&0x1 ) << 17 )
+#define     IEP_REGB_RGB_COLOR_ENH_EN_Z(x)    (((x)&0x1 ) << 16 )
+#define     IEP_REGB_DIL_EI_SMOOTH_Z(x)       (((x)&0x1 ) << 15 )
+#define     IEP_REGB_YUV_ENH_EN_Z(x)          (((x)&0x1 ) << 14 )
+#define     IEP_REGB_YUV_DNS_EN_Z(x)          (((x)&0x1 ) << 13 )
+#define     IEP_REGB_DIL_EI_MODE_Z(x)         (((x)&0x1 ) << 12 )
+#define     IEP_REGB_DIL_HF_EN_Z(x)           (((x)&0x1 ) << 11 )
+#define     IEP_REGB_DIL_MODE_Z(x)            (((x)&0x7 ) << 8  )
+#define     IEP_REGB_DIL_HF_FCT_Z(x)          (((x)&0x7F) << 1  )
+#define     IEP_REGB_LCDC_PATH_EN_Z(x)        (((x)&0x1 ) << 0  )
+
+//iep_conig1
+#define     IEP_REGB_GLB_ALPHA_Z(x)           (((x)&0xff) << 24 )
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP_Z(x)  (((x)&0x1 ) << 23 )
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP_Z(x)  (((x)&0x1 ) << 22 )
+#define     IEP_REGB_RGB_TO_YUV_EN_Z(x)       (((x)&0x1 ) << 21 )
+#define     IEP_REGB_YUV_TO_RGB_EN_Z(x)       (((x)&0x1 ) << 20 )
+#define     IEP_REGB_RGB2YUV_COE_SEL_Z(x)     (((x)&0x3 ) << 18 )
+#define     IEP_REGB_YUV2RGB_COE_SEL_Z(x)     (((x)&0x3 ) << 16 )
+#define     IEP_REGB_DITHER_DOWN_EN_Z(x)      (((x)&0x1 ) << 15 )
+#define     IEP_REGB_DITHER_UP_EN_Z(x)        (((x)&0x1 ) << 14 )
+#define     IEP_REGB_DST_YUV_SWAP_Z(x)        (((x)&0x3 ) << 12 )
+#define     IEP_REGB_DST_RGB_SWAP_Z(x)        (((x)&0x3 ) << 10 )
+#define     IEP_REGB_DST_FMT_Z(x)             (((x)&0x3 ) << 8  )
+#define     IEP_REGB_SRC_YUV_SWAP_Z(x)        (((x)&0x3 ) << 4  )
+#define     IEP_REGB_SRC_RGB_SWAP_Z(x)        (((x)&0x3 ) << 2  )
+#define     IEP_REGB_SRC_FMT_Z(x)             (((x)&0x3 ) << 0  )
+
+//iep_int
+#define     IEP_REGB_FRAME_END_INT_CLR_Z(x)   (((x)&0x1 ) << 16 )
+#define     IEP_REGB_FRAME_END_INT_EN_Z(x)    (((x)&0x1 ) << 8  )
+
+//frm_start
+#define     IEP_REGB_FRM_START_Z(x)           (((x)&0x01 ) << 0 )
+
+//soft_rst
+#define     IEP_REGB_SOFT_RST_Z(x)            (((x)&0x01 ) << 0 )
+
+//iep_vir_img_width
+#define     IEP_REGB_DST_VIR_LINE_WIDTH_Z(x)  (((x)&0xffff) << 16 )
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH_Z(x)  (((x)&0xffff) << 0  )
+
+//iep_img_scl_fct
+#define     IEP_REGB_SCL_VRT_FCT_Z(x)         (((x)&0xffff) << 16 )
+#define     IEP_REGB_SCL_HRZ_FCT_Z(x)         (((x)&0xffff) << 0  )
+
+//iep_src_img_size
+#define     IEP_REGB_SRC_IMG_HEIGHT_Z(x)      (((x)&0x1fff) << 16 )
+#define     IEP_REGB_SRC_IMG_WIDTH_Z(x)       (((x)&0x1fff) << 0  )
+//iep_dst_img_size
+#define     IEP_REGB_DST_IMG_HEIGHT_Z(x)      (((x)&0x1fff) << 16 )
+#define     IEP_REGB_DST_IMG_WIDTH_Z(x)       (((x)&0x1fff) << 0  )
+
+//dst_img_width_tile0/1/2/3
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3_Z(x) (((x)&0x3ff ) << 0  )
+
+//iep_enh_yuv_cnfg0
+#define     IEP_REGB_SAT_CON_Z(x)             (((x)&0x1ff ) << 16 )
+#define     IEP_REGB_CONTRAST_Z(x)            (((x)&0xff ) <<  8  )
+#define     IEP_REGB_BRIGHTNESS_Z(x)          (((x)&0x3f ) <<  0  )
+//iep_enh_yuv_cnfg1
+#define     IEP_REGB_COS_HUE_Z(x)             (((x)&0xff ) <<  8  )
+#define     IEP_REGB_SIN_HUE_Z(x)             (((x)&0xff ) <<  0  )
+//iep_enh_yuv_cnfg2
+#define     IEP_REGB_VIDEO_MODE_Z(x)          (((x)&0x3  ) <<  24 )
+#define     IEP_REGB_COLOR_BAR_V_Z(x)         (((x)&0xff ) <<  16 )
+#define     IEP_REGB_COLOR_BAR_U_Z(x)         (((x)&0xff ) <<  8  )
+#define     IEP_REGB_COLOR_BAR_Y_Z(x)         (((x)&0xff ) <<  0  )
+//iep_enh_rgb_cnfg
+#define     IEP_REGB_ENH_THRESHOLD_Z(x)       (((x)&0xff ) <<  16 )
+#define     IEP_REGB_ENH_ALPHA_Z(x)           (((x)&0x3f ) <<  8  )
+#define     IEP_REGB_ENH_RADIUS_Z(x)          (((x)&0x3  ) <<  0  )
+//iep_enh_c_coe
+#define     IEP_REGB_ENH_C_COE_Z(x)           (((x)&0x7f ) <<  0  )
+//dil_mtn_tab
+#define     IEP_REGB_DIL_MTN_TAB0_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB0_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB0_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB0_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB1_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB1_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB1_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB1_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB2_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB2_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB2_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB2_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB3_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB3_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB3_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB3_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB4_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB4_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB4_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB4_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB5_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB5_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB5_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB5_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB6_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB6_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB6_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB6_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB7_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB7_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB7_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB7_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#if defined(CONFIG_IEP_MMU)
+// mmu
+#define     IEP_REGB_MMU_STATUS_PAGING_ENABLE_Z(x)              (((x)&0x01) << 0)       
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_ACTIVE_Z(x)          (((x)&0x01) << 1)
+#define     IEP_REGB_MMU_STATUS_STALL_ACTIVE_Z(x)               (((x)&0x01) << 2)
+#define     IEP_REGB_MMU_STATUS_IDLE_Z(x)                       (((x)&0x01) << 3)
+#define     IEP_REGB_MMU_STATUS_REPLAY_BUFFER_EMPTY_Z(x)        (((x)&0x01) << 4)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_IS_WRITE_Z(x)        (((x)&0x01) << 5)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_BUS_ID_Z(x)          (((x)&0x1F) << 6)
+                                                               
+#define     IEP_REGB_MMU_CMD_Z(x)                               (((x)&0x07) << 0)
+                                                               
+#define     IEP_REGB_MMU_ZAP_ONE_LINE_Z(x)                      (((x)&0x01) << 0)
+                                                               
+#define     IEP_REGB_MMU_INT_RAWSTAT_PAGE_FAULT_Z(x)            (((x)&0x01) << 0)
+#define     IEP_REGB_MMU_INT_RAWSTAT_READ_BUS_ERROR_Z(x)        (((x)&0x01) << 1)
+
+#define     IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR_Z(x)        (((x)&0x01) << 0)
+#define     IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR_Z(x)    (((x)&0x01) << 1)
+
+#define     IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN_Z(x)        (((x)&0x01) << 0)
+#define     IEP_REGB_MMU_INT_MASK_READ_BUS_ERROR_INT_EN_Z(x)    (((x)&0x01) << 1)
+
+#define     IEP_REGB_MMU_INT_STATUS_PAGE_FAULT_Z(x)             (((x)&0x01) << 0)
+#define     IEP_REGB_MMU_INT_STATUS_READ_BUS_ERROR_Z(x)         (((x)&0x01) << 1)
+
+#define     IEP_REGB_MMU_AUTO_GATING_Z(x)                       (((x)&0x01) << 0)
+#endif
+
+/*-----------------------------------------------------------------
+//MaskRegBits32(addr, y, z),get y
+-----------------------------------------------------------------*/
+//iep_config0
+#define     IEP_REGB_V_REVERSE_DISP_Y      (0x1  << 31 )
+#define     IEP_REGB_H_REVERSE_DISP_Y      (0x1  << 30 )
+#define     IEP_REGB_SCL_EN_Y              (0x1  << 28 )
+#define     IEP_REGB_SCL_SEL_Y             (0x3  << 26 )
+#define     IEP_REGB_SCL_UP_COE_SEL_Y      (0x3  << 24 )
+#define     IEP_REGB_DIL_EI_SEL_Y          (0x1  << 23 )
+#define     IEP_REGB_DIL_EI_RADIUS_Y       (0x3  << 21 )
+#define     IEP_REGB_CON_GAM_ORDER_Y       (0x1  << 20 )
+#define     IEP_REGB_RGB_ENH_SEL_Y         (0x3  << 18 )
+#define     IEP_REGB_RGB_CON_GAM_EN_Y      (0x1  << 17 )
+#define     IEP_REGB_RGB_COLOR_ENH_EN_Y    (0x1  << 16 )
+#define     IEP_REGB_DIL_EI_SMOOTH_Y       (0x1  << 15 )
+#define     IEP_REGB_YUV_ENH_EN_Y          (0x1  << 14 )
+#define     IEP_REGB_YUV_DNS_EN_Y          (0x1  << 13 )
+#define     IEP_REGB_DIL_EI_MODE_Y         (0x1  << 12 )
+#define     IEP_REGB_DIL_HF_EN_Y           (0x1  << 11 )
+#define     IEP_REGB_DIL_MODE_Y            (0x7  << 8  )
+#define     IEP_REGB_DIL_HF_FCT_Y          (0x7F << 1  )
+#define     IEP_REGB_LCDC_PATH_EN_Y        (0x1  << 0  )
+
+//iep_conig1
+#define     IEP_REGB_GLB_ALPHA_Y           (0xff << 24 )
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP_Y  (0x1  << 23 )
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP_Y  (0x1  << 22 )
+#define     IEP_REGB_RGB_TO_YUV_EN_Y       (0x1  << 21 )
+#define     IEP_REGB_YUV_TO_RGB_EN_Y       (0x1  << 20 )
+#define     IEP_REGB_RGB2YUV_COE_SEL_Y     (0x3  << 18 )
+#define     IEP_REGB_YUV2RGB_COE_SEL_Y     (0x3  << 16 )
+#define     IEP_REGB_DITHER_DOWN_EN_Y      (0x1  << 15 )
+#define     IEP_REGB_DITHER_UP_EN_Y        (0x1  << 14 )
+#define     IEP_REGB_DST_YUV_SWAP_Y        (0x3  << 12 )
+#define     IEP_REGB_DST_RGB_SWAP_Y        (0x3  << 10 )
+#define     IEP_REGB_DST_FMT_Y             (0x3  << 8  )
+#define     IEP_REGB_SRC_YUV_SWAP_Y        (0x3  << 4  )
+#define     IEP_REGB_SRC_RGB_SWAP_Y        (0x3  << 2  )
+#define     IEP_REGB_SRC_FMT_Y             (0x3  << 0  )
+
+//iep_int
+#define     IEP_REGB_FRAME_END_INT_CLR_Y   (0x1  << 16 )
+#define     IEP_REGB_FRAME_END_INT_EN_Y    (0x1  << 8  )
+
+//frm_start
+#define     IEP_REGB_FRM_START_Y           (0x1  << 0  )
+
+//soft_rst
+#define     IEP_REGB_SOFT_RST_Y            (0x1  << 0  )
+
+//iep_vir_img_width
+#define     IEP_REGB_DST_VIR_LINE_WIDTH_Y  (0xffff << 16 )
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH_Y  (0xffff << 0  )
+
+//iep_img_scl_fct
+#define     IEP_REGB_SCL_VRT_FCT_Y         (0xffff << 16 )
+#define     IEP_REGB_SCL_HRZ_FCT_Y         (0xffff << 0  )
+
+//iep_src_img_size
+#define     IEP_REGB_SRC_IMG_HEIGHT_Y      (0x1fff << 16 )
+#define     IEP_REGB_SRC_IMG_WIDTH_Y       (0x1fff << 0  )
+//iep_dst_img_size
+#define     IEP_REGB_DST_IMG_HEIGHT_Y      (0x1fff << 16 )
+#define     IEP_REGB_DST_IMG_WIDTH_Y       (0x1fff << 0  )
+
+//dst_img_width_tile0/1/2/3
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3_Y (0x3ff  << 0  )
+
+//iep_enh_yuv_cnfg0
+#define     IEP_REGB_SAT_CON_Y             (0x1ff  <<  16)
+#define     IEP_REGB_CONTRAST_Y            (0xff  <<  8 )
+#define     IEP_REGB_BRIGHTNESS_Y          (0x3f  <<  0 )
+//iep_enh_yuv_cnfg1
+#define     IEP_REGB_COS_HUE_Y             (0xff  <<  8 )
+#define     IEP_REGB_SIN_HUE_Y             (0xff  <<  0 )
+//iep_enh_yuv_cnfg2
+#define     IEP_REGB_VIDEO_MODE_Y          (0x3   <<  24)
+#define     IEP_REGB_COLOR_BAR_V_Y         (0xff  <<  16)
+#define     IEP_REGB_COLOR_BAR_U_Y         (0xff  <<  8 )
+#define     IEP_REGB_COLOR_BAR_Y_Y         (0xff  <<  0 )
+//iep_enh_rgb_cnfg
+#define     IEP_REGB_ENH_THRESHOLD_Y       (0xff  <<  16)
+#define     IEP_REGB_ENH_ALPHA_Y           (0x3f  <<  8 )
+#define     IEP_REGB_ENH_RADIUS_Y          (0x3   <<  0 )
+//iep_enh_c_coe
+#define     IEP_REGB_ENH_C_COE_Y           (0x7f  <<  0 )
+//dil_mtn_tab
+#define     IEP_REGB_DIL_MTN_TAB0_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB0_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB0_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB0_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB1_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB1_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB1_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB1_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB2_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB2_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB2_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB2_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB3_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB3_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB3_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB3_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB4_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB4_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB4_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB4_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB5_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB5_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB5_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB5_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB6_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB6_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB6_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB6_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB7_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB7_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB7_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB7_3_Y      (0x7f  <<  24 )
+
+#if defined(CONFIG_IEP_MMU)
+// mmu
+#define     IEP_REGB_MMU_STATUS_PAGING_ENABLE_Y              (0x01 << 0)       
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_ACTIVE_Y          (0x01 << 1)
+#define     IEP_REGB_MMU_STATUS_STALL_ACTIVE_Y               (0x01 << 2)
+#define     IEP_REGB_MMU_STATUS_IDLE_Y                       (0x01 << 3)
+#define     IEP_REGB_MMU_STATUS_REPLAY_BUFFER_EMPTY_Y        (0x01 << 4)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_IS_WRITE_Y        (0x01 << 5)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_BUS_ID_Y          (0x1F << 6)
+                                                              
+#define     IEP_REGB_MMU_CMD_Y                               (0x07 << 0)
+                                                              
+#define     IEP_REGB_MMU_ZAP_ONE_LINE_Y                      (0x01 << 0)
+                                                              
+#define     IEP_REGB_MMU_INT_RAWSTAT_PAGE_FAULT_Y            (0x01 << 0)
+#define     IEP_REGB_MMU_INT_RAWSTAT_READ_BUS_ERROR_Y        (0x01 << 1)
+
+#define     IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR_Y        (0x01 << 0)
+#define     IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR_Y    (0x01 << 1)
+
+#define     IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN_Y        (0x01 << 0)
+#define     IEP_REGB_MMU_INT_MASK_READ_BUS_ERROR_INT_EN_Y    (0x01 << 1)
+
+#define     IEP_REGB_MMU_INT_STATUS_PAGE_FAULT_Y             (0x01 << 0)
+#define     IEP_REGB_MMU_INT_STATUS_READ_BUS_ERROR_Y         (0x01 << 1)
+
+#define     IEP_REGB_MMU_AUTO_GATING_Y                       (0x01 << 0)
+
+// offset
+#define     IEP_REGB_MMU_STATUS_PAGING_ENABLE_F              (0)       
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_ACTIVE_F          (1)
+#define     IEP_REGB_MMU_STATUS_STALL_ACTIVE_F               (2)
+#define     IEP_REGB_MMU_STATUS_IDLE_F                       (3)
+#define     IEP_REGB_MMU_STATUS_REPLAY_BUFFER_EMPTY_F        (4)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_IS_WRITE_F        (5)
+#define     IEP_REGB_MMU_STATUS_PAGE_FAULT_BUS_ID_F          (6)
+#endif
+
+/*-----------------------------------------------------------------
+//MaskRegBits32(addr, y, z),
+-----------------------------------------------------------------*/
+//iep_config0
+#define     IEP_REGB_V_REVERSE_DISP(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_V_REVERSE_DISP_Y,IEP_REGB_V_REVERSE_DISP_Z(x))
+#define     IEP_REGB_H_REVERSE_DISP(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_H_REVERSE_DISP_Y,IEP_REGB_H_REVERSE_DISP_Z(x))
+#define     IEP_REGB_SCL_EN(base, x)              ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_EN_Y,IEP_REGB_SCL_EN_Z(x))
+#define     IEP_REGB_SCL_SEL(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_SEL_Y,IEP_REGB_SCL_SEL_Z(x))
+#define     IEP_REGB_SCL_UP_COE_SEL(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_UP_COE_SEL_Y,IEP_REGB_SCL_UP_COE_SEL_Z(x))
+#define     IEP_REGB_DIL_EI_SEL(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_SEL_Y,IEP_REGB_DIL_EI_SEL_Z(x))
+#define     IEP_REGB_DIL_EI_RADIUS(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_RADIUS_Y,IEP_REGB_DIL_EI_RADIUS_Z(x))
+#define     IEP_REGB_CON_GAM_ORDER(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_CON_GAM_ORDER_Y,IEP_REGB_CON_GAM_ORDER_Z(x))
+#define     IEP_REGB_RGB_ENH_SEL(base, x)         ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_ENH_SEL_Y,IEP_REGB_RGB_ENH_SEL_Z(x))
+#define     IEP_REGB_RGB_CON_GAM_EN(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_CON_GAM_EN_Y,IEP_REGB_RGB_CON_GAM_EN_Z(x))
+#define     IEP_REGB_RGB_COLOR_ENH_EN(base, x)    ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_COLOR_ENH_EN_Y,IEP_REGB_RGB_COLOR_ENH_EN_Z(x))
+#define     IEP_REGB_DIL_EI_SMOOTH(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_SMOOTH_Y,IEP_REGB_DIL_EI_SMOOTH_Z(x))
+#define     IEP_REGB_YUV_ENH_EN(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_YUV_ENH_EN_Y,IEP_REGB_YUV_ENH_EN_Z(x))
+#define     IEP_REGB_YUV_DNS_EN(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_YUV_DNS_EN_Y,IEP_REGB_YUV_DNS_EN_Z(x))
+#define     IEP_REGB_DIL_EI_MODE(base, x)         ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_MODE_Y,IEP_REGB_DIL_EI_MODE_Z(x))
+#define     IEP_REGB_DIL_HF_EN(base, x)           ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_HF_EN_Y,IEP_REGB_DIL_HF_EN_Z(x))
+#define     IEP_REGB_DIL_MODE(base, x)            ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_MODE_Y,IEP_REGB_DIL_MODE_Z(x))
+#define     IEP_REGB_DIL_HF_FCT(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_HF_FCT_Y,IEP_REGB_DIL_HF_FCT_Z(x))
+#define     IEP_REGB_LCDC_PATH_EN(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_LCDC_PATH_EN_Y,IEP_REGB_LCDC_PATH_EN_Z(x))
+
+//iep_conig1
+#define     IEP_REGB_GLB_ALPHA(base, x)           ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_GLB_ALPHA_Y,IEP_REGB_GLB_ALPHA_Z(x))
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP(base, x)  ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB2YUV_INPUT_CLIP_Y,IEP_REGB_RGB2YUV_INPUT_CLIP_Z(x))
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP(base, x)  ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV2RGB_INPUT_CLIP_Y,IEP_REGB_YUV2RGB_INPUT_CLIP_Z(x))
+#define     IEP_REGB_RGB_TO_YUV_EN(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB_TO_YUV_EN_Y,IEP_REGB_RGB_TO_YUV_EN_Z(x))
+#define     IEP_REGB_YUV_TO_RGB_EN(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV_TO_RGB_EN_Y,IEP_REGB_YUV_TO_RGB_EN_Z(x))
+#define     IEP_REGB_RGB2YUV_COE_SEL(base, x)     ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB2YUV_COE_SEL_Y,IEP_REGB_RGB2YUV_COE_SEL_Z(x))
+#define     IEP_REGB_YUV2RGB_COE_SEL(base, x)     ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV2RGB_COE_SEL_Y,IEP_REGB_YUV2RGB_COE_SEL_Z(x))
+#define     IEP_REGB_DITHER_DOWN_EN(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DITHER_DOWN_EN_Y,IEP_REGB_DITHER_DOWN_EN_Z(x))
+#define     IEP_REGB_DITHER_UP_EN(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DITHER_UP_EN_Y,IEP_REGB_DITHER_UP_EN_Z(x))
+#define     IEP_REGB_DST_YUV_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_YUV_SWAP_Y,IEP_REGB_DST_YUV_SWAP_Z(x))
+#define     IEP_REGB_DST_RGB_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_RGB_SWAP_Y,IEP_REGB_DST_RGB_SWAP_Z(x))
+#define     IEP_REGB_DST_FMT(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_FMT_Y,IEP_REGB_DST_FMT_Z(x))
+#define     IEP_REGB_SRC_YUV_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_YUV_SWAP_Y,IEP_REGB_SRC_YUV_SWAP_Z(x))
+#define     IEP_REGB_SRC_RGB_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_RGB_SWAP_Y,IEP_REGB_SRC_RGB_SWAP_Z(x))
+#define     IEP_REGB_SRC_FMT(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_FMT_Y,IEP_REGB_SRC_FMT_Z(x))
+
+//iep_int
+#define     IEP_REGB_FRAME_END_INT_CLR(base, x)   MaskRegBits32(base, rIEP_INT,IEP_REGB_FRAME_END_INT_CLR_Y,IEP_REGB_FRAME_END_INT_CLR_Z(x))
+#define     IEP_REGB_FRAME_END_INT_EN(base, x)    MaskRegBits32(base, rIEP_INT,IEP_REGB_FRAME_END_INT_EN_Y,IEP_REGB_FRAME_END_INT_EN_Z(x))
+
+//frm_start
+#define     IEP_REGB_FRM_START(base, x)           WriteReg32(base, rIEP_FRM_START,x)
+
+//soft_rst
+#define     IEP_REGB_SOFT_RST(base, x)            WriteReg32(base, rIEP_SOFT_RST,x)
+
+//iep_vir_img_width
+#define     IEP_REGB_DST_VIR_LINE_WIDTH(base, x)  ConfRegBits32(base, RAW_rIEP_VIR_IMG_WIDTH,rIEP_VIR_IMG_WIDTH,IEP_REGB_DST_VIR_LINE_WIDTH_Y,IEP_REGB_DST_VIR_LINE_WIDTH_Z(x))
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH(base, x)  ConfRegBits32(base, RAW_rIEP_VIR_IMG_WIDTH,rIEP_VIR_IMG_WIDTH,IEP_REGB_SRC_VIR_LINE_WIDTH_Y,IEP_REGB_SRC_VIR_LINE_WIDTH_Z(x))
+
+//iep_img_scl_fct
+#define     IEP_REGB_SCL_VRT_FCT(base, x)         ConfRegBits32(base, RAW_rIEP_IMG_SCL_FCT,rIEP_IMG_SCL_FCT,IEP_REGB_SCL_VRT_FCT_Y,IEP_REGB_SCL_VRT_FCT_Z(x))
+#define     IEP_REGB_SCL_HRZ_FCT(base, x)         ConfRegBits32(base, RAW_rIEP_IMG_SCL_FCT,rIEP_IMG_SCL_FCT,IEP_REGB_SCL_HRZ_FCT_Y,IEP_REGB_SCL_HRZ_FCT_Z(x))
+
+//iep_src_img_size
+#define     IEP_REGB_SRC_IMG_HEIGHT(base, x)      ConfRegBits32(base, RAW_rIEP_SRC_IMG_SIZE,rIEP_SRC_IMG_SIZE,IEP_REGB_SRC_IMG_HEIGHT_Y,IEP_REGB_SRC_IMG_HEIGHT_Z(x))
+#define     IEP_REGB_SRC_IMG_WIDTH(base, x)       ConfRegBits32(base, RAW_rIEP_SRC_IMG_SIZE,rIEP_SRC_IMG_SIZE,IEP_REGB_SRC_IMG_WIDTH_Y,IEP_REGB_SRC_IMG_WIDTH_Z(x))
+//iep_dst_img_size
+#define     IEP_REGB_DST_IMG_HEIGHT(base, x)      ConfRegBits32(base, RAW_rIEP_DST_IMG_SIZE,rIEP_DST_IMG_SIZE,IEP_REGB_DST_IMG_HEIGHT_Y,IEP_REGB_DST_IMG_HEIGHT_Z(x))
+#define     IEP_REGB_DST_IMG_WIDTH(base, x)       ConfRegBits32(base, RAW_rIEP_DST_IMG_SIZE,rIEP_DST_IMG_SIZE,IEP_REGB_DST_IMG_WIDTH_Y,IEP_REGB_DST_IMG_WIDTH_Z(x))
+
+//dst_img_width_tile0/1/2/3
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE0,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE1,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE2,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE3,x)
+
+//iep_enh_yuv_cnfg0
+#define     IEP_REGB_SAT_CON(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_SAT_CON_Y,IEP_REGB_SAT_CON_Z(x))
+#define     IEP_REGB_CONTRAST(base, x)            ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_CONTRAST_Y,IEP_REGB_CONTRAST_Z(x))
+#define     IEP_REGB_BRIGHTNESS(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_BRIGHTNESS_Y,IEP_REGB_BRIGHTNESS_Z(x))
+//iep_enh_yuv_cnfg1
+#define     IEP_REGB_COS_HUE(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_1,rIEP_ENH_YUV_CNFG_1,IEP_REGB_COS_HUE_Y,IEP_REGB_COS_HUE_Z(x))
+#define     IEP_REGB_SIN_HUE(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_1,rIEP_ENH_YUV_CNFG_1,IEP_REGB_SIN_HUE_Y,IEP_REGB_SIN_HUE_Z(x))
+//iep_enh_yuv_cnfg2
+#define     IEP_REGB_VIDEO_MODE(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_VIDEO_MODE_Y,IEP_REGB_VIDEO_MODE_Z(x))
+#define     IEP_REGB_COLOR_BAR_V(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_V_Y,IEP_REGB_COLOR_BAR_V_Z(x))
+#define     IEP_REGB_COLOR_BAR_U(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_U_Y,IEP_REGB_COLOR_BAR_U_Z(x))
+#define     IEP_REGB_COLOR_BAR_Y(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_Y_Y,IEP_REGB_COLOR_BAR_Y_Z(x))
+//iep_enh_rgb_cnfg
+#define     IEP_REGB_ENH_THRESHOLD(base, x)       ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_THRESHOLD_Y,IEP_REGB_ENH_THRESHOLD_Z(x))
+#define     IEP_REGB_ENH_ALPHA(base, x)           ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_ALPHA_Y,IEP_REGB_ENH_ALPHA_Z(x))
+#define     IEP_REGB_ENH_RADIUS(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_RADIUS_Y,IEP_REGB_ENH_RADIUS_Z(x))
+//iep_enh_c_coe
+#define     IEP_REGB_ENH_C_COE(base, x)           WriteReg32(base, rIEP_ENH_C_COE,x)           
+//src_addr
+#define     IEP_REGB_SRC_ADDR_YRGB(base, x)       WriteReg32(base, rIEP_SRC_ADDR_YRGB, x)
+#define     IEP_REGB_SRC_ADDR_CBCR(base, x)       WriteReg32(base, rIEP_SRC_ADDR_CBCR, x)
+#define     IEP_REGB_SRC_ADDR_CR(base, x)         WriteReg32(base, rIEP_SRC_ADDR_CR, x)
+#define     IEP_REGB_SRC_ADDR_Y1(base, x)         WriteReg32(base, rIEP_SRC_ADDR_Y1, x)
+#define     IEP_REGB_SRC_ADDR_CBCR1(base, x)      WriteReg32(base, rIEP_SRC_ADDR_CBCR1, x)
+#define     IEP_REGB_SRC_ADDR_CR1(base, x)        WriteReg32(base, rIEP_SRC_ADDR_CR1, x)
+#define     IEP_REGB_SRC_ADDR_Y_ITEMP(base, x)    WriteReg32(base, rIEP_SRC_ADDR_Y_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_CBCR_ITEMP(base, x) WriteReg32(base, rIEP_SRC_ADDR_CBCR_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_CR_ITEMP(base, x)   WriteReg32(base, rIEP_SRC_ADDR_CR_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_Y_FTEMP(base, x)    WriteReg32(base, rIEP_SRC_ADDR_Y_FTEMP, x)
+#define     IEP_REGB_SRC_ADDR_CBCR_FTEMP(base, x) WriteReg32(base, rIEP_SRC_ADDR_CBCR_FTEMP, x)
+#define     IEP_REGB_SRC_ADDR_CR_FTEMP(base, x)   WriteReg32(base, rIEP_SRC_ADDR_CR_FTEMP, x)
+//dst_addr
+#define     IEP_REGB_DST_ADDR_YRGB(base, x)       WriteReg32(base, rIEP_DST_ADDR_YRGB,x)
+#define     IEP_REGB_DST_ADDR_CBCR(base, x)       WriteReg32(base, rIEP_DST_ADDR_CBCR, x)
+#define     IEP_REGB_DST_ADDR_CR(base, x)         WriteReg32(base, rIEP_DST_ADDR_CR, x)
+#define     IEP_REGB_DST_ADDR_Y1(base, x)         WriteReg32(base, rIEP_DST_ADDR_Y1, x)
+#define     IEP_REGB_DST_ADDR_CBCR1(base, x)      WriteReg32(base, rIEP_DST_ADDR_CBCR1, x)
+#define     IEP_REGB_DST_ADDR_CR1(base, x)        WriteReg32(base, rIEP_DST_ADDR_CR1, x)
+#define     IEP_REGB_DST_ADDR_Y_ITEMP(base, x)    WriteReg32(base, rIEP_DST_ADDR_Y_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_CBCR_ITEMP(base, x) WriteReg32(base, rIEP_DST_ADDR_CBCR_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_CR_ITEMP(base, x)   WriteReg32(base, rIEP_DST_ADDR_CR_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_Y_FTEMP(base, x)    WriteReg32(base, rIEP_DST_ADDR_Y_FTEMP, x)
+#define     IEP_REGB_DST_ADDR_CBCR_FTEMP(base, x) WriteReg32(base, rIEP_DST_ADDR_CBCR_FTEMP, x)
+#define     IEP_REGB_DST_ADDR_CR_FTEMP(base, x)   WriteReg32(base, rIEP_DST_ADDR_CR_FTEMP, x)
+
+//dil_mtn_tab
+#define     IEP_REGB_DIL_MTN_TAB0(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB0,x)
+#define     IEP_REGB_DIL_MTN_TAB1(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB1,x)
+#define     IEP_REGB_DIL_MTN_TAB2(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB2,x)
+#define     IEP_REGB_DIL_MTN_TAB3(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB3,x)
+#define     IEP_REGB_DIL_MTN_TAB4(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB4,x)
+#define     IEP_REGB_DIL_MTN_TAB5(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB5,x)
+#define     IEP_REGB_DIL_MTN_TAB6(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB6,x)
+#define     IEP_REGB_DIL_MTN_TAB7(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB7,x)
+
+#define     IEP_REGB_STATUS(base)               ReadReg32(base, rIEP_STATUS)
+
+#if defined(CONFIG_IEP_MMU)
+// mmu
+#define     IEP_REGB_MMU_DTE_ADDR(base, x)                          WriteReg32(base, rIEP_MMU_DTE_ADDR, x)
+#define     IEP_REGB_MMU_STATUS(base)                               ReadReg32(base, rIEP_MMU_STATUS)
+                                                               
+#define     IEP_REGB_MMU_CMD(base, x)                               MaskRegBits32(base, rIEP_MMU_CMD, IEP_REGB_MMU_CMD_Y, IEP_REGB_MMU_CMD_Z(x))
+                                                               
+#define     IEP_REGB_MMU_PAGE_FAULT_ADDR(base)                      ReadReg32(base, rIEP_MMU_PAGE_FAULT_ADDR)
+                                                               
+#define     IEP_REGB_MMU_ZAP_ONE_LINE(base, x)                      MaskRegBits32(base, rIEP_MMU_ZAP_ONE_LINE, \
+                                                                    IEP_REGB_MMU_ZAP_ONE_LINE_Y, \
+                                                                    IEP_REGB_MMU_ZAP_ONE_LINE_Z(x))
+                                                               
+#define     IEP_REGB_MMU_INT_RAWSTAT(base)                          ReadReg32(base, rIEP_MMU_INT_RAWSTAT)
+
+#define     IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR(base, x)        MaskRegBits32(base, rIEP_MMU_INT_CLEAR, \
+                                                                    IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR_Y, \
+                                                                    IEP_REGB_MMU_INT_CLEAR_PAGE_FAULT_CLEAR_Z(x))
+#define     IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR(base, x)    MaskRegBits32(base, rIEP_MMU_INT_CLEAR, \
+                                                                    IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR_Y, \
+                                                                    IEP_REGB_MMU_INT_CLEAR_READ_BUS_ERROR_CLEAR_Z(x))
+
+#define     IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN(base, x)        MaskRegBits32(base, rIEP_MMU_INT_MASK, \
+                                                                    IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN_Y, \
+                                                                    IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN_Z(x))
+#define     IEP_REGB_MMU_INT_MASK_READ_BUS_ERROR_INT_EN(base, x)    MaskRegBits32(base, rIEP_MMU_INT_MASK, \
+                                                                    IEP_REGB_MMU_INT_MASK_READ_BUS_ERROR_INT_EN_Y, \
+                                                                    IEP_REGB_MMU_INT_MASK_PAGE_FAULT_INT_EN_Z(x))
+
+#define     IEP_REGB_MMU_INT_STATUS(base)                           ReadReg32(base, rIEP_MMU_INT_STATUS)
+
+#define     IEP_REGB_MMU_AUTO_GATING(base, x)                       MaskRegBits32(base, rIEP_MMU_AUTO_GATING, \
+                                                                    IEP_REGB_MMU_AUTO_GATING_Y, \
+                                                                    IEP_REGB_MMU_AUTO_GATING_Z(x))
+#endif
+
+///function define
+void iep_config_lcdc_path(IEP_MSG *iep_msg);
+
+/// system control, directly operating the device registers. 
+/// parameter @base need to be set to device base address.
+void iep_soft_rst(void *base);
+void iep_config_done(void *base);
+void iep_config_frm_start(void *base);
+int iep_probe_int(void *base);
+void iep_config_frame_end_int_clr(void *base);
+void iep_config_frame_end_int_en(void *base); 
+struct iep_status iep_get_status(void *base);
+#if defined(CONFIG_IEP_MMU)
+struct iep_mmu_int_status iep_probe_mmu_int_status(void *base);
+void iep_config_mmu_page_fault_int_en(void *base, bool en);
+void iep_config_mmu_page_fault_int_clr(void *base);
+void iep_config_mmu_read_bus_error_int_clr(void *base);
+uint32_t iep_probe_mmu_page_fault_addr(void *base);
+void iep_config_mmu_cmd(void *base, enum iep_mmu_cmd cmd);
+void iep_config_mmu_dte_addr(void *base, uint32_t addr);
+#endif
+int iep_get_deinterlace_mode(void *base);
+void iep_set_deinterlace_mode(int mode, void *base);
+void iep_switch_input_address(void *base);
+
+/// generating a series of iep registers copy to the session private buffer
+void iep_config(iep_session *session, IEP_MSG *iep_msg); 
+
+//#define IEP_PRINT_INFO
+#endif
+
+
diff --git a/drivers/video/rockchip/iep/iep.h b/drivers/video/rockchip/iep/iep.h
new file mode 100755
index 000000000000..145766d607a0
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep.h
@@ -0,0 +1,234 @@
+#ifndef _IEP_H_
+#define _IEP_H_
+
+#define IEP_IOC_MAGIC 'i'
+
+#define IEP_SET_PARAMETER_REQ				_IOW(IEP_IOC_MAGIC, 1, unsigned long)
+#define IEP_SET_PARAMETER_DEINTERLACE		_IOW(IEP_IOC_MAGIC, 2, unsigned long)
+#define IEP_SET_PARAMETER_ENHANCE			_IOW(IEP_IOC_MAGIC, 3, unsigned long)
+#define IEP_SET_PARAMETER_CONVERT			_IOW(IEP_IOC_MAGIC, 4, unsigned long)
+#define IEP_SET_PARAMETER_SCALE				_IOW(IEP_IOC_MAGIC, 5, unsigned long)
+#define IEP_GET_RESULT_SYNC					_IOW(IEP_IOC_MAGIC, 6, unsigned long)
+#define IEP_GET_RESULT_ASYNC				_IOW(IEP_IOC_MAGIC, 7, unsigned long)
+#define IEP_SET_PARAMETER					_IOW(IEP_IOC_MAGIC, 8, unsigned long)
+#define IEP_RELEASE_CURRENT_TASK            _IOW(IEP_IOC_MAGIC, 9, unsigned long)
+
+/* Driver information */
+#define DRIVER_DESC		"IEP Device Driver"
+#define DRIVER_NAME		"iep"
+
+/* Logging */
+#define IEP_DEBUG 0
+#if IEP_DEBUG
+#define IEP_DBG(format, args...)        printk("%s: " format, DRIVER_NAME, ## args)
+#else
+#define IEP_DBG(format, args...)
+#endif
+
+#define IEP_INFORMATION 1
+#if IEP_INFORMATION
+#define IEP_INFO(format, args...)       printk(format, ## args)
+#else
+#define IEP_INFO(format, args...)
+#endif
+
+#define IEP_ERR(format, args...)        printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
+#define IEP_WARNING(format, args...)    printk(KERN_WARNING "%s: " format, DRIVER_NAME, ## args)
+
+enum
+{
+    yuv2rgb_BT_601_l            = 0x0,     /* BT.601_1 */
+    yuv2rgb_BT_601_f            = 0x1,     /* BT.601_f */
+    yuv2rgb_BT_709_l            = 0x2,     /* BT.709_1 */
+    yuv2rgb_BT_709_f            = 0x3,     /* BT.709_f */
+};
+
+enum
+{
+    rgb2yuv_BT_601_l            = 0x0,     /* BT.601_1 */
+    rgb2yuv_BT_601_f            = 0x1,     /* BT.601_f */
+    rgb2yuv_BT_709_l            = 0x2,     /* BT.709_1 */
+    rgb2yuv_BT_709_f            = 0x3,     /* BT.709_f */
+};
+
+enum
+{
+    dein_mode_bypass_dis         = 0x0,
+    dein_mode_I4O2               = 0x1,
+    dein_mode_I4O1B              = 0x2,
+    dein_mode_I4O1T              = 0x3,
+    dein_mode_I2O1B              = 0x4,
+    dein_mode_I2O1T              = 0x5,
+    dein_mode_bypass             = 0x6,    
+};
+
+typedef enum IEP_FIELD_ORDER
+{
+    FIELD_ORDER_TOP_FIRST,
+    FIELD_ORDER_BOTTOM_FIRST
+} IEP_FIELD_ORDER_t;
+
+typedef enum IEP_YUV_DEINTERLACE_MODE {
+    IEP_DEINTERLACE_MODE_DISABLE,
+    IEP_DEINTERLACE_MODE_I2O1,
+    IEP_DEINTERLACE_MODE_I4O1,
+    IEP_DEINTERLACE_MODE_I4O2,
+    IEP_DEINTERLACE_MODE_BYPASS
+} IEP_YUV_DEINTERLACE_MODE_t;
+
+enum
+{
+    rgb_enhance_bypass          = 0x0, 
+    rgb_enhance_denoise         = 0x1,
+    rgb_enhance_detail          = 0x2,
+    rgb_enhance_edge            = 0x3,
+};//for rgb_enhance_mode
+
+enum
+{
+    rgb_contrast_CC_P_DDE          = 0x0, //cg prior to dde 
+    rgb_contrast_DDE_P_CC          = 0x1, //dde prior to cg
+}; //for rgb_contrast_enhance_mode
+
+enum
+{
+	black_screen                   = 0x0,
+	blue_screen                    = 0x1,
+	color_bar                      = 0x2,
+	normal_mode                    = 0x3,
+}; //for video mode
+
+/*
+//          Alpha    Red     Green   Blue  
+{  4, 32, {{32,24,   24,16,  16, 8,  8, 0 }}, GGL_RGBA },   // IEP_FORMAT_ARGB_8888    
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // IEP_FORMAT_ABGR_8888    
+{  4, 32, {{ 8, 0,  32,24,  24,16,  16, 8 }}, GGL_RGB  },   // IEP_FORMAT_RGBA_8888
+{  4, 32, {{ 8, 0,  16, 8,  24,16,  32,24 }}, GGL_BGRA },   // IEP_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // IEP_FORMAT_RGB_565        
+{  2, 16, {{ 0, 0,   5, 0,  11, 5,  16,11 }}, GGL_RGB  },   // IEP_FORMAT_RGB_565        
+*/
+enum
+{
+    IEP_FORMAT_ARGB_8888    = 0x0,    
+    IEP_FORMAT_ABGR_8888    = 0x1,    
+    IEP_FORMAT_RGBA_8888    = 0x2,    
+    IEP_FORMAT_BGRA_8888    = 0x3,
+    IEP_FORMAT_RGB_565      = 0x4,
+    IEP_FORMAT_BGR_565      = 0x5,
+           
+    IEP_FORMAT_YCbCr_422_SP = 0x10,
+    IEP_FORMAT_YCbCr_422_P  = 0x11,
+    IEP_FORMAT_YCbCr_420_SP = 0x12,
+    IEP_FORMAT_YCbCr_420_P  = 0x13,
+    IEP_FORMAT_YCrCb_422_SP = 0x14,
+    IEP_FORMAT_YCrCb_422_P  = 0x15,//same as IEP_FORMAT_YCbCr_422_P
+    IEP_FORMAT_YCrCb_420_SP = 0x16,
+    IEP_FORMAT_YCrCb_420_P  = 0x17,//same as IEP_FORMAT_YCbCr_420_P
+       
+}; //for format
+
+typedef struct iep_img
+{
+    unsigned short act_w;         // act_width
+    unsigned short act_h;         // act_height
+    signed short   x_off;         // x offset for the vir,word unit
+    signed short   y_off;         // y offset for the vir,word unit
+
+    unsigned short vir_w;         //unit :pix 
+    unsigned short vir_h;         //unit :pix
+    unsigned int   format;
+    unsigned int  *mem_addr;
+    unsigned int  *uv_addr;
+    unsigned int  *v_addr;
+    
+    unsigned char   rb_swap;//not be used
+    unsigned char   uv_swap;//not be used
+	
+    unsigned char   alpha_swap;//not be used
+}
+iep_img;
+
+
+typedef struct IEP_MSG
+{
+    iep_img src;    // src active window 
+    iep_img dst;    // src virtual window
+
+    iep_img src1;   
+    iep_img dst1;
+
+    iep_img src_itemp;
+    iep_img src_ftemp;
+
+    iep_img dst_itemp;
+    iep_img dst_ftemp;
+
+    unsigned char dither_up_en;
+    unsigned char dither_down_en;//not to be used
+
+    unsigned char yuv2rgb_mode;
+    unsigned char rgb2yuv_mode;
+
+    unsigned char global_alpha_value;
+
+    unsigned char rgb2yuv_clip_en;
+    unsigned char yuv2rgb_clip_en;
+
+    unsigned char lcdc_path_en;
+    int off_x;
+    int off_y;
+    int width;
+    int height;
+    int layer;
+
+    unsigned char yuv_3D_denoise_en;
+    
+    /// yuv color enhance
+    unsigned char yuv_enhance_en;
+    int sat_con_int;
+    int contrast_int;
+    int cos_hue_int;
+    int sin_hue_int;
+    signed char   yuv_enh_brightness;//-32<brightness<31
+    unsigned char  video_mode;//0-3  
+    unsigned char  color_bar_y;//0-127
+    unsigned char  color_bar_u;//0-127   
+    unsigned char  color_bar_v;//0-127   
+
+    
+    unsigned char rgb_enhance_en;//i don't konw what is used
+    
+    unsigned char rgb_color_enhance_en;//sw_rgb_color_enh_en
+    unsigned int rgb_enh_coe;
+    
+    unsigned char rgb_enhance_mode;//sw_rgb_enh_sel,dde sel
+    
+    unsigned char rgb_cg_en;//sw_rgb_con_gam_en
+    unsigned int cg_tab[192];
+    
+    unsigned char rgb_contrast_enhance_mode;//sw_con_gam_order;0 cg prior to dde,1 dde prior to cg
+
+    int enh_threshold; 
+    int enh_alpha;
+    int enh_radius;
+    
+    unsigned char scale_up_mode;
+
+    unsigned char field_order;
+    unsigned char dein_mode;
+    //DIL HF
+    unsigned char dein_high_fre_en;
+    unsigned char dein_high_fre_fct;
+    //DIL EI
+    unsigned char dein_ei_mode;
+    unsigned char dein_ei_smooth;
+    unsigned char dein_ei_sel;
+    unsigned char dein_ei_radius;//when dein_ei_sel=0 will be used
+
+    bool vir_addr_enable;
+    
+    void *base;
+}
+IEP_MSG;
+
+#endif
diff --git a/drivers/video/rockchip/iep/iep_api.c b/drivers/video/rockchip/iep/iep_api.c
new file mode 100755
index 000000000000..557f666a3bec
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_api.c
@@ -0,0 +1,143 @@
+#include "iep_api.h"
+
+
+
+void
+iep_set_act_info(iep_img *img, unsigned int w, unsigned int h, unsigned int x_off, unsigned int y_off)
+{
+    img->act_w = w;
+    img->act_h = h;
+    img->x_off = x_off;
+    img->y_off = y_off;
+}
+
+void
+iep_set_vir_info(iep_img *img, unsigned int w, unsigned int h, unsigned int *yrgb, unsigned int *uv, unsigned int *v, unsigned int format )
+{
+    img->vir_w = w;
+    img->vir_h = h;
+    img->mem_addr = yrgb;
+    img->uv_addr = uv;
+    img->v_addr = v;
+    img->format = format;
+}
+
+void 
+iep_set_scl_up_mode(IEP_MSG *msg, unsigned char mode)
+{
+    msg->scale_up_mode = mode;
+}
+
+void
+iep_set_color_enhance(IEP_MSG *msg, unsigned char color_enh_en,float color_enh_coe)
+{
+    msg->rgb_color_enhance_en = color_enh_en;
+    msg->rgb_enh_coe = color_enh_coe;
+
+}
+
+void
+iep_rgb_cg(IEP_MSG *msg,unsigned char cg_en,double cg_rr,double cg_rg,double cg_rb)
+{
+    msg->rgb_cg_en=cg_en;
+    msg->cg_rr=cg_rr;
+    msg->cg_rg=cg_rg;
+    msg->cg_rb=cg_rb;
+}
+
+void
+iep_set_deinterlace(IEP_MSG *msg, unsigned char mode, unsigned char dein_high_fre_en, unsigned char dein_edge_interp_en)
+{
+    msg->dein_mode = mode;
+    msg->dein_high_fre_en = dein_high_fre_en;
+    msg->dein_ei_mode = dein_edge_interp_en;    
+}
+void
+iep_set_dil_ei_smooth(IEP_MSG *msg,unsigned int en)
+{
+	msg->dein_ei_smooth = en;
+}
+void
+iep_set_dil_ei(IEP_MSG *msg,unsigned char ei_sel,unsigned char ei_radius,unsigned char ei_smooth_en,unsigned char ei_mode)
+{
+	msg->dein_ei_sel=ei_sel;
+	msg->dein_ei_radius=ei_radius;
+	msg->dein_ei_smooth=ei_smooth_en;
+	msg->dein_ei_mode=ei_mode;
+}
+void
+iep_set_dil_hf(IEP_MSG *msg,unsigned char dil_hf_en,unsigned char dil_hf_fct)
+{
+	msg->dein_high_fre_en=dil_hf_en;
+	msg->dein_high_fre_fct=dil_hf_fct;
+}
+
+void
+iep_set_rgb2yuv(IEP_MSG *msg, unsigned char rgb2yuv_mode, unsigned char rgb2yuv_clip_en)
+{
+    msg->rgb2yuv_mode = rgb2yuv_mode;
+    msg->rgb2yuv_clip_en = rgb2yuv_clip_en; 
+}
+
+void
+iep_set_yuv2rgb(IEP_MSG *msg, unsigned char yuv2rgb_mode, unsigned char yuv2rgb_clip_en)
+{
+    msg->yuv2rgb_mode = yuv2rgb_mode;
+    msg->yuv2rgb_clip_en = yuv2rgb_clip_en; 
+}
+
+void
+iep_set_dither_up(IEP_MSG *msg,unsigned int en)
+{
+	msg->dither_up_en = en;
+}
+
+void
+iep_set_lcdc_path(IEP_MSG *msg)
+{
+	msg->lcdc_path_en = 1;
+}
+
+void
+iep_set_3D_denoise(IEP_MSG *msg)
+{
+	msg->yuv_3D_denoise_en = 1;
+}
+
+void
+iep_set_yuv_normal_mode_enh(IEP_MSG *msg,float saturation,float contrast,signed char brightness,signed char angle)
+{
+	msg->yuv_enhance_en = 1;
+	msg->video_mode = normal_mode;
+	msg->yuv_enh_saturation = saturation;
+	msg->yuv_enh_contrast = contrast;
+	msg->yuv_enh_brightness = brightness;
+	msg->yuv_enh_hue_angle = angle;
+}
+
+void
+iep_set_yuv_black_screen(IEP_MSG *msg)
+{
+	msg->yuv_enhance_en = 1;
+	msg->video_mode = black_screen;
+}
+
+void
+iep_set_yuv_blue_screen(IEP_MSG *msg)
+{
+	msg->yuv_enhance_en = 1;
+	msg->video_mode = blue_screen;
+}
+
+void
+iep_set_yuv_color_bar(IEP_MSG *msg,unsigned char color_bar_y,unsigned char color_bar_u,unsigned char color_bar_v)
+{
+	msg->yuv_enhance_en = 1;
+	msg->video_mode = color_bar;
+	msg->color_bar_y = color_bar_y;
+	msg->color_bar_u = color_bar_u;
+	msg->color_bar_v = color_bar_v;
+}
+
+
+
diff --git a/drivers/video/rockchip/iep/iep_api.h b/drivers/video/rockchip/iep/iep_api.h
new file mode 100755
index 000000000000..97edabb47dcc
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_api.h
@@ -0,0 +1,56 @@
+#ifndef __IEP_API_H__
+#define __IEP_API_H__
+
+
+#include "iep.h"
+//#include "../lcdc/hwapi_lcdc.h"
+
+void
+iep_set_act_info(iep_img *img, unsigned int w, unsigned int h, unsigned int x_off, unsigned int y_off);
+
+void
+iep_set_vir_info(iep_img *img, unsigned int w, unsigned int h, unsigned int *yrgb, unsigned int *uv, unsigned int *v, unsigned int format );
+
+void 
+iep_set_scl_up_mode(IEP_MSG *msg, unsigned char mode);
+
+void
+iep_set_color_enhance(IEP_MSG *msg, unsigned char color_enh_en,float color_enh_coe);
+
+void
+iep_rgb_cg(IEP_MSG *msg,unsigned char cg_en,double cg_rr,double cg_rg,double cg_rb);
+
+void
+iep_set_deinterlace(IEP_MSG *msg, unsigned char mode, unsigned char dein_high_fre_en, unsigned char dein_edge_interp_en);
+
+void
+iep_set_dil_ei_smooth(IEP_MSG *msg,unsigned int en);
+
+void
+iep_set_rgb2yuv(IEP_MSG *msg, unsigned char rgb2yuv_mode, unsigned char rgb2yuv_clip_en);
+
+void
+iep_set_yuv2rgb(IEP_MSG *msg, unsigned char yuv2rgb_mode, unsigned char yuv2rgb_clip_en);
+
+void
+iep_set_dither_up(IEP_MSG *msg,unsigned int en);
+
+void
+iep_set_lcdc_path(IEP_MSG *msg);
+
+void
+iep_set_3D_denoise(IEP_MSG *msg);
+
+void
+iep_set_yuv_normal_mode_enh(IEP_MSG *msg,float saturation,float contrast,signed char brightness,signed char angle);
+
+void
+iep_set_yuv_black_screen(IEP_MSG *msg);
+
+void
+iep_set_yuv_blue_screen(IEP_MSG *msg);
+
+void
+iep_set_yuv_color_bar(IEP_MSG *msg,unsigned char color_bar_y,unsigned char color_bar_u,unsigned char color_bar_v);
+
+#endif
diff --git a/drivers/video/rockchip/iep/iep_drv.c b/drivers/video/rockchip/iep/iep_drv.c
new file mode 100755
index 000000000000..3faa4a9634a4
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_drv.c
@@ -0,0 +1,1139 @@
+/* 
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/wakelock.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+#include "iep_drv.h"
+#if defined(CONFIG_IEP_MMU)
+#include "iep_mmu.h"
+#endif
+#include "hw_iep_reg.h"
+
+#define IEP_MAJOR		255
+//#define IEP_CLK_ENABLE
+//#define IEP_TEST_CASE
+
+//#undef dmac_flush_range
+//#define dmac_flush_range dma_cache_wback_inv
+
+#define RK_IEP_SIZE         0x1000
+#define IEP_TIMEOUT_DELAY   2*HZ
+#define IEP_POWER_OFF_DELAY	4*HZ
+
+struct iep_drvdata {
+    struct miscdevice miscdev;
+    struct device dev;
+    void *iep_base;
+    int irq0;
+
+    struct clk *aclk_iep;
+    struct clk *hclk_iep;
+    struct clk *pd_iep;
+    struct clk *aclk_vio1;
+
+    struct mutex mutex;                     // task list mutex
+
+    bool dpi_mode;                          // direct path interface mode. true: enable, false: disable
+
+    struct delayed_work power_off_work;
+    bool enable;                            // clk enable or disable
+    struct wake_lock wake_lock;
+
+    atomic_t iep_int;
+    atomic_t mmu_page_fault;
+    atomic_t mmu_bus_error;
+};
+
+struct iep_drvdata *iep_drvdata1 = NULL;
+iep_service_info iep_service;
+
+static void iep_reg_deinit(struct iep_reg *reg)
+{
+    list_del_init(&reg->session_link);
+    list_del_init(&reg->status_link);
+    kfree(reg);
+}
+
+static void iep_reg_from_wait_to_ready(struct iep_reg *reg)
+{
+    list_del_init(&reg->status_link);
+    list_add_tail(&reg->status_link, &iep_service.ready);
+
+    list_del_init(&reg->session_link);
+    list_add_tail(&reg->session_link, &reg->session->ready);
+}
+
+static void iep_reg_from_ready_to_running(struct iep_reg *reg)
+{
+    list_del_init(&reg->status_link);
+    list_add_tail(&reg->status_link, &iep_service.running);
+
+    list_del_init(&reg->session_link);
+    list_add_tail(&reg->session_link, &reg->session->running);
+}
+
+static void iep_del_running_list(void)
+{
+    struct iep_reg *reg;
+    int cnt = 0;
+
+    mutex_lock(&iep_service.lock);
+
+    while (!list_empty(&iep_service.running)) {
+        BUG_ON(cnt != 0);
+        reg = list_entry(iep_service.running.next, struct iep_reg, status_link);
+
+        atomic_dec(&reg->session->task_running);
+        atomic_dec(&iep_service.total_running);
+
+        if (list_empty(&reg->session->waiting)) {
+            atomic_set(&reg->session->done, 1);
+            atomic_inc(&reg->session->num_done);
+            wake_up(&reg->session->wait);
+        }
+
+        iep_reg_deinit(reg);
+        cnt++;
+    }
+
+    mutex_unlock(&iep_service.lock);
+}
+
+static void iep_dump(void)
+{
+    struct iep_status sts;
+
+    sts = iep_get_status(iep_drvdata1->iep_base);
+
+    IEP_INFO("scl_sts: %u, dil_sts %u, wyuv_sts %u, ryuv_sts %u, wrgb_sts %u, rrgb_sts %u, voi_sts %u\n", 
+           sts.scl_sts, sts.dil_sts, sts.wyuv_sts, sts.ryuv_sts, sts.wrgb_sts, sts.rrgb_sts, sts.voi_sts);
+
+    {
+        int *reg = (int*)iep_drvdata1->iep_base;
+        int i;
+
+        /* could not read validate data from address after base+0x40 */
+        for (i=0; i<0x40; i++) {
+            IEP_INFO("%08x ", reg[i]);
+
+            if ((i+1) % 4 == 0) {
+                IEP_INFO("\n");
+            }
+        }
+
+        IEP_INFO("\n");
+    }
+}
+
+/* Caller must hold iep_service.lock */
+static void iep_del_running_list_timeout(void)
+{
+    struct iep_reg *reg;
+
+    mutex_lock(&iep_service.lock);
+
+    while (!list_empty(&iep_service.running)) {
+        reg = list_entry(iep_service.running.next, struct iep_reg, status_link);
+
+        atomic_dec(&reg->session->task_running);
+        atomic_dec(&iep_service.total_running);
+
+        //iep_soft_rst(iep_drvdata1->iep_base);
+
+        iep_dump();
+
+        if (list_empty(&reg->session->waiting)) {
+            atomic_set(&reg->session->done, 1);
+            wake_up(&reg->session->wait);
+        }
+
+        iep_reg_deinit(reg);
+    }
+
+    mutex_unlock(&iep_service.lock);
+}
+
+static inline void iep_queue_power_off_work(void)
+{
+    queue_delayed_work(system_nrt_wq, &iep_drvdata1->power_off_work, IEP_POWER_OFF_DELAY);
+}
+
+static void iep_power_on(void)
+{
+    static ktime_t last;
+    ktime_t now = ktime_get();
+    if (ktime_to_ns(ktime_sub(now, last)) > NSEC_PER_SEC) {
+        cancel_delayed_work_sync(&iep_drvdata1->power_off_work);
+        iep_queue_power_off_work();
+        last = now;
+    }
+
+    if (iep_service.enable) return;
+
+    IEP_INFO("IEP Power ON\n");
+
+    //iep_soft_rst(iep_drvdata1->iep_base);
+
+#ifdef IEP_CLK_ENABLE
+    //clk_prepare_enable(iep_drvdata1->pd_iep);
+    clk_prepare_enable(iep_drvdata1->aclk_iep);
+    clk_prepare_enable(iep_drvdata1->hclk_iep);
+    //clk_prepare_enable(iep_drvdata1->aclk_vio1);
+#endif
+
+    wake_lock(&iep_drvdata1->wake_lock);
+    iep_service.enable = true;
+}
+
+static void iep_power_off(void)
+{
+    int total_running;
+
+    if (!iep_service.enable) {
+        return;
+    }
+
+    IEP_INFO("IEP Power OFF\n");
+
+    total_running = atomic_read(&iep_service.total_running);
+    if (total_running) {
+        IEP_WARNING("power off when %d task running!!\n", total_running);
+        mdelay(50);
+        IEP_WARNING("delay 50 ms for running task\n");
+        iep_dump();
+    }
+
+#ifdef IEP_CLK_ENABLE
+    clk_disable_unprepare(iep_drvdata1->aclk_iep);
+    clk_disable_unprepare(iep_drvdata1->hclk_iep);
+    //clk_disable(iep_drvdata1->pd_iep);
+#endif
+
+    wake_unlock(&iep_drvdata1->wake_lock);
+    iep_service.enable = false;
+}
+
+static void iep_power_off_work(struct work_struct *work)
+{
+    if (mutex_trylock(&iep_service.lock) && !iep_drvdata1->dpi_mode) {
+        IEP_INFO("iep dpi mode inactivity\n");
+        iep_power_off();
+        mutex_unlock(&iep_service.lock);
+    } else {
+        /* Come back later if the device is busy... */
+        iep_queue_power_off_work();
+    }
+}
+
+extern void rk_direct_fb_show(struct fb_info * fbi);
+extern struct fb_info * rk_get_fb(int fb_id);
+extern bool rk_fb_poll_wait_frame_complete(void);
+extern int rk_fb_dpi_open(bool open);
+extern int rk_fb_dpi_win_sel(int layer_id);
+
+static void iep_config_lcdc(struct iep_reg *reg)
+{
+    struct fb_info *fb;
+    int fbi = 0;
+    int fmt = 0;
+
+    fbi = reg->layer == 0 ? 0 : 1;
+
+    rk_fb_dpi_win_sel(fbi);
+
+    fb = rk_get_fb(fbi);
+#if 1
+    switch (reg->format) {
+    case IEP_FORMAT_ARGB_8888:
+    case IEP_FORMAT_ABGR_8888:
+        fmt = HAL_PIXEL_FORMAT_RGBA_8888;
+        fb->var.bits_per_pixel = 32;
+
+        fb->var.red.length = 8;
+        fb->var.red.offset = 16;
+        fb->var.red.msb_right = 0;
+
+        fb->var.green.length = 8;
+        fb->var.green.offset = 8;
+        fb->var.green.msb_right = 0;
+
+        fb->var.blue.length = 8;
+        fb->var.blue.offset = 0;
+        fb->var.blue.msb_right = 0;
+
+        fb->var.transp.length = 8;
+        fb->var.transp.offset = 24;
+        fb->var.transp.msb_right = 0;
+
+        break;
+    case IEP_FORMAT_BGRA_8888:
+        fmt = HAL_PIXEL_FORMAT_BGRA_8888;
+        fb->var.bits_per_pixel = 32;
+        break;
+    case IEP_FORMAT_RGB_565:
+        fmt = HAL_PIXEL_FORMAT_RGB_565;
+        fb->var.bits_per_pixel = 16;
+
+        fb->var.red.length = 5;
+        fb->var.red.offset = 11;
+        fb->var.red.msb_right = 0;
+
+        fb->var.green.length = 6;
+        fb->var.green.offset = 5;
+        fb->var.green.msb_right = 0;
+
+        fb->var.blue.length = 5;
+        fb->var.blue.offset = 0;
+        fb->var.blue.msb_right = 0;
+
+        break;
+    case IEP_FORMAT_YCbCr_422_SP:
+        fmt = HAL_PIXEL_FORMAT_YCbCr_422_SP;
+        fb->var.bits_per_pixel = 16;
+        break;
+    case IEP_FORMAT_YCbCr_420_SP:
+        fmt = HAL_PIXEL_FORMAT_YCrCb_NV12;
+        fb->var.bits_per_pixel = 16;
+        break;
+    case IEP_FORMAT_YCbCr_422_P:
+    case IEP_FORMAT_YCrCb_422_SP:
+    case IEP_FORMAT_YCrCb_422_P:
+    case IEP_FORMAT_YCrCb_420_SP:
+    case IEP_FORMAT_YCbCr_420_P:
+    case IEP_FORMAT_YCrCb_420_P:
+    case IEP_FORMAT_RGBA_8888:
+    case IEP_FORMAT_BGR_565:
+        // unsupported format
+        IEP_ERR("unsupported format %d\n", reg->format);
+        break;
+    default:
+        ;
+    }
+
+    fb->var.xoffset         = 0;
+    fb->var.yoffset         = 0;
+    fb->var.xres            = reg->act_width;
+    fb->var.yres            = reg->act_height;
+    fb->var.xres_virtual    = reg->act_width;
+    fb->var.yres_virtual    = reg->act_height;
+    fb->var.nonstd          = ((reg->off_y&0xFFF)<<20) + ((reg->off_x&0xFFF)<<8) + (fmt&0xFF);
+    fb->var.grayscale       = ((reg->vir_height&0xFFF)<<20) + ((reg->vir_width&0xFFF)<<8) + 0;   //win0 xsize & ysize
+#endif
+    rk_direct_fb_show(fb);
+}
+
+static int iep_switch_dpi(struct iep_reg *reg) 
+{
+    if (reg->dpi_en) {
+        if (!iep_drvdata1->dpi_mode) {
+            /// Turn on dpi
+            rk_fb_dpi_open(true);
+            iep_drvdata1->dpi_mode = true;
+        }
+        iep_config_lcdc(reg);
+    } else {
+        if (iep_drvdata1->dpi_mode) {
+            /// Turn off dpi
+            //wait_lcdc_dpi_close();
+            bool status;
+            rk_fb_dpi_open(false);
+            status = rk_fb_poll_wait_frame_complete();
+
+            iep_drvdata1->dpi_mode = false;
+            IEP_INFO("%s %d, iep dpi inactivated\n", __func__, __LINE__);
+        }
+    }
+
+    return 0;
+}
+
+static void iep_reg_copy_to_hw(struct iep_reg *reg)
+{
+    int i;
+
+    uint32_t *pbase = (uint32_t *)iep_drvdata1->iep_base;
+
+    // config registers
+    for (i=0; i<IEP_CNF_REG_LEN; i++) {
+        pbase[IEP_CNF_REG_BASE + i] = reg->reg[IEP_CNF_REG_BASE + i];
+    }
+
+    // command registers
+    for (i = 0; i < IEP_CMD_REG_LEN; i++) {
+        pbase[IEP_CMD_REG_BASE + i] = reg->reg[IEP_CMD_REG_BASE + i];
+    }
+
+    // address registers
+    for (i=0; i<IEP_ADD_REG_LEN; i++) {
+        pbase[IEP_ADD_REG_BASE + i] = reg->reg[IEP_ADD_REG_BASE + i];
+    }
+
+#if defined(CONFIG_IEP_MMU)
+    // mmu registers
+    for (i=0; i<IEP_MMU_REG_LEN; i++) {
+        pbase[IEP_MMU_REG_BASE + i] = reg->reg[IEP_MMU_REG_BASE + i];
+    }
+#endif
+
+    //dmac_flush_range(&pbase[0], &pbase[IEP_REG_LEN]);
+    //outer_flush_range(virt_to_phys(&pbase[0]),virt_to_phys(&pbase[IEP_REG_LEN]));
+
+    dsb();
+}
+
+/** switch fields order before the next lcdc frame start
+ *  coming */
+static void iep_switch_fields_order(void) 
+{
+    void *pbase = (void*)iep_drvdata1->iep_base;
+    int mode = iep_get_deinterlace_mode(pbase);
+    struct fb_info *fb;
+
+    switch (mode) {
+    case dein_mode_I4O1B:
+        iep_set_deinterlace_mode(dein_mode_I4O1T, pbase);
+        break;
+    case dein_mode_I4O1T:
+        iep_set_deinterlace_mode(dein_mode_I4O1B, pbase);
+        break;
+    case dein_mode_I2O1B:
+        iep_set_deinterlace_mode(dein_mode_I2O1T, pbase);
+        break;
+    case dein_mode_I2O1T:
+        iep_set_deinterlace_mode(dein_mode_I2O1B, pbase);
+        break;
+    default:
+        ;
+    }
+
+    fb = rk_get_fb(1);
+    rk_direct_fb_show(fb);
+
+    //iep_switch_input_address(pbase);
+}
+
+/* Caller must hold iep_service.lock */
+static void iep_try_set_reg(void)
+{
+    struct iep_reg *reg;
+
+    mutex_lock(&iep_service.lock);
+
+    if (list_empty(&iep_service.ready)) {
+        if (!list_empty(&iep_service.waiting)) {
+            reg = list_entry(iep_service.waiting.next, struct iep_reg, status_link);
+
+            iep_power_on();
+            udelay(1);
+
+            iep_reg_from_wait_to_ready(reg);
+            atomic_dec(&iep_service.waitcnt);
+
+            //iep_soft_rst(iep_drvdata1->iep_base);
+
+            iep_reg_copy_to_hw(reg);
+        }
+    } else {
+        if (iep_drvdata1->dpi_mode) {
+            iep_switch_fields_order();
+        }
+    }
+
+    mutex_unlock(&iep_service.lock);
+}
+
+static void iep_try_start_frm(void)
+{
+    struct iep_reg *reg;
+
+    mutex_lock(&iep_service.lock);
+
+    if (list_empty(&iep_service.running)) {
+        if (!list_empty(&iep_service.ready)) {
+            reg = list_entry(iep_service.ready.next, struct iep_reg, status_link);
+
+            iep_switch_dpi(reg);
+
+            iep_reg_from_ready_to_running(reg);
+            iep_config_frame_end_int_en(iep_drvdata1->iep_base);
+            iep_config_done(iep_drvdata1->iep_base);
+
+            /* Start proc */
+            atomic_inc(&reg->session->task_running);
+            atomic_inc(&iep_service.total_running);
+            iep_config_frm_start(iep_drvdata1->iep_base);
+        }
+    }
+
+    mutex_unlock(&iep_service.lock);
+}
+
+static irqreturn_t iep_isr(int irq, void *dev_id)
+{
+    if (atomic_read(&iep_drvdata1->iep_int) > 0) {
+        if (iep_service.enable) {
+            if (list_empty(&iep_service.waiting)) {
+                if (iep_drvdata1->dpi_mode) {
+                    iep_switch_fields_order();
+                }
+            }
+            iep_del_running_list();
+        }
+
+        iep_try_set_reg();
+        iep_try_start_frm();
+
+        atomic_dec(&iep_drvdata1->iep_int);
+    }
+
+#if defined(CONFIG_IEP_MMU)
+    if (atomic_read(&iep_drvdata1->mmu_page_fault) > 0) {
+
+        if (!list_empty(&iep_service.running)) {
+            uint32_t va = iep_probe_mmu_page_fault_addr(iep_drvdata1->iep_base);
+            struct iep_reg *reg = list_entry(iep_service.running.next, struct iep_reg, status_link);
+            if (0 > rk_mmu_generate_pte_from_va(reg->session, va)) {
+                IEP_ERR("Generate PTE from Virtual Address 0x%08x failed\n", va);
+            } else {
+                iep_config_mmu_cmd(iep_drvdata1->iep_base, MMU_ZAP_CACHE);
+                iep_config_mmu_cmd(iep_drvdata1->iep_base, MMU_PAGE_FAULT_DONE);
+            }
+        } else {
+            IEP_ERR("Page Fault occur when IEP IDLE\n");
+        }
+
+        atomic_dec(&iep_drvdata1->mmu_page_fault);
+    }
+
+    if (atomic_read(&iep_drvdata1->mmu_bus_error) > 0) {
+        // reset iep mmu module
+        IEP_ERR("Bus Error!!!\n");
+        iep_config_mmu_cmd(iep_drvdata1->iep_base, MMU_FORCE_RESET);
+        atomic_dec(&iep_drvdata1->mmu_bus_error);
+    }
+#endif
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t iep_irq(int irq,  void *dev_id)
+{
+    /*clear INT */
+    void *pbase = (void*)iep_drvdata1->iep_base;
+
+#if defined(CONFIG_IEP_MMU)
+    struct iep_mmu_int_status mmu_int_status;
+
+    mmu_int_status = iep_probe_mmu_int_status(pbase);
+    if (mmu_int_status.page_fault) {
+        iep_config_mmu_page_fault_int_clr(pbase);
+        atomic_inc(&iep_drvdata1->mmu_page_fault);
+    }
+
+    if (mmu_int_status.read_bus_error) {
+        iep_config_mmu_read_bus_error_int_clr(pbase);
+        atomic_inc(&iep_drvdata1->mmu_bus_error);
+    }
+#endif
+    
+    if (iep_probe_int(pbase)) {
+        iep_config_frame_end_int_clr(pbase);
+        atomic_inc(&iep_drvdata1->iep_int);
+    }
+
+    return IRQ_WAKE_THREAD;
+}
+
+static void iep_service_session_clear(iep_session *session)
+{
+    struct iep_reg *reg, *n;
+
+    list_for_each_entry_safe(reg, n, &session->waiting, session_link) {
+        iep_reg_deinit(reg);
+    }
+
+    list_for_each_entry_safe(reg, n, &session->ready, 	session_link) {
+        iep_reg_deinit(reg);
+    }
+
+    list_for_each_entry_safe(reg, n, &session->running, session_link) {
+        iep_reg_deinit(reg);
+    }
+}
+
+static int iep_open(struct inode *inode, struct file *filp)
+{
+    //DECLARE_WAITQUEUE(wait, current);
+    iep_session *session = (iep_session *)kzalloc(sizeof(iep_session), GFP_KERNEL);
+    if (NULL == session) {
+        IEP_ERR("unable to allocate memory for iep_session.\n");
+        return -ENOMEM;
+    }
+
+    session->pid = current->pid;
+    INIT_LIST_HEAD(&session->waiting);
+    INIT_LIST_HEAD(&session->ready);
+    INIT_LIST_HEAD(&session->running);
+    INIT_LIST_HEAD(&session->list_session);
+    init_waitqueue_head(&session->wait);
+    //add_wait_queue(&session->wait, wait);
+    /* no need to protect */
+    mutex_lock(&iep_service.lock);
+    list_add_tail(&session->list_session, &iep_service.session);
+    mutex_unlock(&iep_service.lock);
+    atomic_set(&session->task_running, 0);
+    atomic_set(&session->num_done, 0);
+
+#if defined(CONFIG_IEP_MMU)
+    rk_mmu_init_dte_table(session);
+    INIT_LIST_HEAD(&session->pte_list);
+#endif
+
+    filp->private_data = (void *)session;
+
+    return nonseekable_open(inode, filp);
+}
+
+static int iep_release(struct inode *inode, struct file *filp)
+{
+    int task_running;
+    iep_session *session = (iep_session *)filp->private_data;
+
+    if (NULL == session) return -EINVAL;
+
+    task_running = atomic_read(&session->task_running);
+
+    if (task_running) {
+        IEP_ERR("iep_service session %d still has %d task running when closing\n", session->pid, task_running);
+        msleep(100);
+        /*synchronization*/
+    }
+
+    wake_up(&session->wait);
+    mutex_lock(&iep_service.lock);
+    list_del(&session->list_session);
+    iep_service_session_clear(session);
+    kfree(session);
+    mutex_unlock(&iep_service.lock);
+
+    return 0;
+}
+
+static unsigned int iep_poll(struct file *filp, poll_table *wait)
+{
+    int mask = 0;
+    iep_session *session = (iep_session *)filp->private_data;
+    if (NULL == session) return POLL_ERR;
+    poll_wait(filp, &session->wait, wait);
+    if (atomic_read(&session->done)) mask |= POLL_IN | POLLRDNORM;
+
+    return mask;
+}
+
+static int iep_get_result_sync(iep_session *session)
+{
+    int ret = 0;
+
+    iep_try_start_frm();
+
+    ret = wait_event_timeout(session->wait, atomic_read(&session->done), IEP_TIMEOUT_DELAY);
+
+    if (unlikely(ret < 0)) {
+        IEP_ERR("sync pid %d wait task ret %d\n", session->pid, ret);
+        iep_del_running_list();
+        ret = ret;
+    } else if (0 == ret) {
+        IEP_ERR("sync pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+        iep_del_running_list_timeout();
+        iep_try_set_reg();
+        iep_try_start_frm();
+        ret = -ETIMEDOUT;
+    }
+
+    return ret;
+}
+
+static void iep_get_result_async(iep_session *session)
+{
+    iep_try_start_frm();
+    return;
+}
+
+static long iep_ioctl(struct file *filp, uint32_t cmd, unsigned long arg)
+{
+    int ret = 0;
+    iep_session *session = (iep_session *)filp->private_data;
+
+    if (NULL == session) {
+        IEP_ERR("%s [%d] iep thread session is null\n", __FUNCTION__, __LINE__);
+        return -EINVAL;
+    }
+
+    mutex_lock(&iep_service.mutex);
+
+    switch (cmd) {
+    case IEP_SET_PARAMETER:
+        {
+            IEP_MSG *msg = (IEP_MSG *)kzalloc(sizeof(IEP_MSG), GFP_KERNEL);
+            if (msg) {
+                if (copy_from_user(msg, (IEP_MSG *)arg, sizeof(IEP_MSG))) {
+                    IEP_ERR("copy_from_user failure\n");
+                    ret = -EFAULT;
+                }
+            }
+            
+            if (ret == 0) {
+                if (atomic_read(&iep_service.waitcnt) < 10) {
+                    iep_config(session, msg);
+                    atomic_inc(&iep_service.waitcnt);
+                } else {
+                    IEP_ERR("iep task queue full\n");
+                    ret = -EFAULT;
+                }
+            }
+
+            /** REGISTER CONFIG must accord to Timing When DPI mode
+             *  enable */
+            if (!iep_drvdata1->dpi_mode) {
+                iep_try_set_reg();
+            }
+            kfree(msg);
+        }
+        break;
+    case IEP_GET_RESULT_SYNC:
+        if (0 > iep_get_result_sync(session)) {
+            ret = -ETIMEDOUT;
+        }
+        break;
+    case IEP_GET_RESULT_ASYNC:
+        iep_get_result_async(session);
+        break;
+    case IEP_RELEASE_CURRENT_TASK:
+        iep_del_running_list_timeout();
+        iep_try_set_reg();
+        iep_try_start_frm();
+        break;
+    default:
+        IEP_ERR("unknown ioctl cmd!\n");
+        ret = -EINVAL;
+    }
+    mutex_unlock(&iep_service.mutex);
+
+    return ret;
+}
+
+struct file_operations iep_fops = {
+    .owner		    = THIS_MODULE,
+    .open		    = iep_open,
+    .release	    = iep_release,
+    .poll           = iep_poll,
+    .unlocked_ioctl = iep_ioctl,
+};
+
+static struct miscdevice iep_dev = {
+    .minor = IEP_MAJOR,
+    .name  = "iep",
+    .fops  = &iep_fops,
+};
+
+static int iep_drv_probe(struct platform_device *pdev)
+{
+    struct iep_drvdata *data;
+    int ret = 0;
+    struct resource *res = NULL;
+
+    data = (struct iep_drvdata*)devm_kzalloc(&pdev->dev, sizeof(struct iep_drvdata), GFP_KERNEL);
+    if (NULL == data) {
+        IEP_ERR("failed to allocate driver data.\n");
+        return  -ENOMEM;
+    }
+
+    iep_drvdata1 = data;
+
+    INIT_LIST_HEAD(&iep_service.waiting);
+    INIT_LIST_HEAD(&iep_service.ready);
+    INIT_LIST_HEAD(&iep_service.running);
+    INIT_LIST_HEAD(&iep_service.done);
+    INIT_LIST_HEAD(&iep_service.session);
+    atomic_set(&iep_service.waitcnt, 0);
+    mutex_init(&iep_service.lock);
+    atomic_set(&iep_service.total_running, 0);
+    iep_service.enable = false;
+
+#ifdef IEP_CLK_ENABLE
+    /*data->pd_iep = clk_get(NULL, "pd_display");
+    if (IS_ERR(data->pd_iep)) {
+        IEP_ERR("failed to find iep power down clock source.\n");
+        goto err_clock;
+    }*/
+
+    data->aclk_iep = devm_clk_get(&pdev->dev, "aclk_iep");
+    if (IS_ERR(data->aclk_iep)) {
+        IEP_ERR("failed to find iep axi clock source.\n");
+        ret = -ENOENT;
+        goto err_clock;
+    }
+
+    data->hclk_iep = devm_clk_get(&pdev->dev, "hclk_iep");
+    if (IS_ERR(data->hclk_iep)) {
+        IEP_ERR("failed to find iep ahb clock source.\n");
+        ret = -ENOENT;
+        goto err_clock;
+    }
+
+    /*data->aclk_vio1 = clk_get(NULL, "aclk_lcdc1_pre");
+    if (IS_ERR(data->aclk_vio1)) {
+        IEP_ERR("failed to find vio1 axi clock source.\n");
+        ret = -ENOENT;
+        goto err_clock;
+    }*/
+#endif
+
+    iep_service.enable = false;
+    INIT_DELAYED_WORK(&data->power_off_work, iep_power_off_work);
+    wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "iep");
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+    data->iep_base = (void *)devm_ioremap_resource(&pdev->dev, res);
+    if (data->iep_base == NULL) {
+        IEP_ERR("iep ioremap failed\n");
+        ret = -ENOENT;
+        goto err_ioremap;
+    }
+
+    atomic_set(&data->iep_int, 0);
+    atomic_set(&data->mmu_page_fault, 0);
+    atomic_set(&data->mmu_bus_error, 0);
+
+    /* get the IRQ */
+    data->irq0 = platform_get_irq(pdev, 0);
+    if (data->irq0 <= 0) {
+        IEP_ERR("failed to get iep irq resource (%d).\n", data->irq0);
+        ret = data->irq0;
+        goto err_irq;
+    }
+
+    /* request the IRQ */
+    ret = devm_request_threaded_irq(&pdev->dev, data->irq0, iep_irq, iep_isr, 0, dev_name(&pdev->dev), pdev);
+    if (ret) {
+        IEP_ERR("iep request_irq failed (%d).\n", ret);
+        goto err_irq;
+    }
+
+    mutex_init(&iep_service.mutex);
+
+    platform_set_drvdata(pdev, data);
+
+    ret = misc_register(&iep_dev);
+    if (ret) {
+        IEP_ERR("cannot register miscdev (%d)\n", ret);
+        goto err_misc_register;
+    }
+
+    IEP_INFO("IEP Driver loaded succesfully\n");
+
+    return 0;
+
+err_misc_register:
+    free_irq(data->irq0, pdev);
+err_irq:
+    if (res) {
+        if (data->iep_base) {
+            devm_ioremap_release(&pdev->dev, res);
+        }
+        devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
+    }
+err_ioremap:
+err_clock:
+    wake_lock_destroy(&data->wake_lock);
+    kfree(data);
+
+    return ret;
+}
+
+static int iep_drv_remove(struct platform_device *pdev)
+{
+    struct iep_drvdata *data = platform_get_drvdata(pdev);
+    struct resource *res;
+
+    wake_lock_destroy(&data->wake_lock);
+
+    misc_deregister(&(data->miscdev));
+    free_irq(data->irq0, &data->miscdev);
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    devm_ioremap_release(&pdev->dev, res);
+    devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
+
+#ifdef IEP_CLK_ENABLE
+    if (data->aclk_iep) {
+        devm_clk_put(&pdev->dev, data->aclk_iep);
+    }
+
+    if (data->hclk_iep) {
+        devm_clk_put(&pdev->dev, data->hclk_iep);
+    }
+
+    /*if (data->aclk_vio1) {
+        clk_put(data->aclk_vio1);
+    }
+
+    if (data->pd_iep) {
+        clk_put(data->pd_iep);
+    }*/
+#endif
+
+    //devm_kfree(data);
+    return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id iep_dt_ids[] = {
+	{.compatible = "rockchip,iep",},
+    {},
+};
+#endif
+
+static struct platform_driver iep_driver = {
+    .probe		= iep_drv_probe,
+    .remove		= iep_drv_remove,
+    .driver		= {
+        .owner  = THIS_MODULE,
+        .name	= "iep",
+#if defined(CONFIG_OF)
+        .of_match_table = of_match_ptr(iep_dt_ids),
+#endif
+    },
+};
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int proc_iep_show(struct seq_file *s, void *v)
+{
+    struct iep_status sts;
+	//mutex_lock(&iep_service.mutex);
+	iep_power_on();
+	seq_printf(s, "\nIEP Modules Status:\n");
+    sts = iep_get_status(iep_drvdata1->iep_base);
+    seq_printf(s, "scl_sts: %u, dil_sts %u, wyuv_sts %u, ryuv_sts %u, wrgb_sts %u, rrgb_sts %u, voi_sts %u\n", 
+           sts.scl_sts, sts.dil_sts, sts.wyuv_sts, sts.ryuv_sts, sts.wrgb_sts, sts.rrgb_sts, sts.voi_sts);
+    {
+        int *reg = (int*)iep_drvdata1->iep_base;
+        int i;
+
+        /* could not read validate data from address after base+0x40 */
+        for (i=0; i<0x40; i++) {
+            seq_printf(s, "%08x ", reg[i]);
+
+            if ((i+1) % 4 == 0) {
+                seq_printf(s, "\n");
+            }
+        }
+
+        seq_printf(s, "\n");
+    }
+
+	//mutex_unlock(&iep_service.mutex);
+
+	return 0;
+}
+
+static int proc_iep_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_iep_show, NULL);
+}
+
+static const struct file_operations proc_iep_fops = {
+	.open		= proc_iep_open,
+	.read		= seq_read,
+	.llseek 	= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init iep_proc_init(void)
+{
+	proc_create("iep", 0, NULL, &proc_iep_fops);
+	return 0;
+}
+
+static void __exit iep_proc_release(void)
+{
+	remove_proc_entry("iep", NULL);
+}
+#endif
+
+#ifdef IEP_TEST_CASE
+void iep_test_case0(void);
+#endif
+
+static int __init iep_init(void)
+{
+    int ret;
+
+    if ((ret = platform_driver_register(&iep_driver)) != 0) {
+        IEP_ERR("Platform device register failed (%d).\n", ret);
+        return ret;
+    }
+
+#ifdef CONFIG_PROC_FS
+    iep_proc_init();
+#endif
+
+    IEP_INFO("Module initialized.\n");
+
+#ifdef IEP_TEST_CASE
+    iep_test_case0();
+#endif
+
+    return 0;
+}
+
+static void __exit iep_exit(void)
+{
+    IEP_ERR("%s IN\n", __func__);
+#ifdef CONFIG_PROC_FS
+    iep_proc_release();
+#endif
+
+    iep_power_off();
+    platform_driver_unregister(&iep_driver);
+}
+
+module_init(iep_init);
+module_exit(iep_exit);
+
+/* Module information */
+MODULE_AUTHOR("ljf@rock-chips.com");
+MODULE_DESCRIPTION("Driver for iep device");
+MODULE_LICENSE("GPL");
+
+#ifdef IEP_TEST_CASE
+
+#include "yuv420sp_480x480_interlaced.h"
+#include "yuv420sp_480x480_deinterlaced_i2o1.h"
+
+//unsigned char tmp_buf[480*480*3/2];
+
+void iep_test_case0(void)
+{
+    struct IEP_MSG msg;
+    iep_session session;
+    unsigned int phy_src, phy_dst, phy_tmp;
+    int i;
+    int ret = 0;
+    unsigned char *tmp_buf;
+
+    tmp_buf = kmalloc(480*480*3/2, GFP_KERNEL);
+    
+    session.pid	= current->pid;
+	INIT_LIST_HEAD(&session.waiting);
+    INIT_LIST_HEAD(&session.ready);
+	INIT_LIST_HEAD(&session.running);
+	INIT_LIST_HEAD(&session.list_session);
+	init_waitqueue_head(&session.wait);
+	list_add_tail(&session.list_session, &iep_service.session);
+	atomic_set(&session.task_running, 0);
+    atomic_set(&session.num_done, 0);
+
+    memset(&msg, 0, sizeof(struct IEP_MSG));
+    memset(tmp_buf, 0xCC, 480*480*3/2);
+
+    dmac_flush_range(&tmp_buf[0], &tmp_buf[480*480*3/2]);
+    outer_flush_range(virt_to_phys(&tmp_buf[0]),virt_to_phys(&tmp_buf[480*480*3/2]));
+
+    phy_src = virt_to_phys(&yuv420sp_480x480_interlaced[0]);
+    phy_tmp = virt_to_phys(&tmp_buf[0]);
+    phy_dst = virt_to_phys(&yuv420sp_480x480_deinterlaced_i2o1[0]);
+
+    dmac_flush_range(&yuv420sp_480x480_interlaced[0], &yuv420sp_480x480_interlaced[480*480*3/2]);
+    outer_flush_range(virt_to_phys(&yuv420sp_480x480_interlaced[0]),virt_to_phys(&yuv420sp_480x480_interlaced[480*480*3/2]));
+
+    IEP_INFO("*********** IEP MSG GENARATE ************\n");
+
+    msg.src.act_w = 480;
+    msg.src.act_h = 480;
+    msg.src.x_off = 0;
+    msg.src.y_off = 0;
+    msg.src.vir_w = 480;
+    msg.src.vir_h = 480;
+    msg.src.format = IEP_FORMAT_YCbCr_420_SP;
+    msg.src.mem_addr = (uint32_t*)phy_src;
+    msg.src.uv_addr  = (uint32_t*)(phy_src + 480 * 480);
+    msg.src.v_addr = 0;
+    
+    msg.dst.act_w = 480;
+    msg.dst.act_h = 480;
+    msg.dst.x_off = 0;
+    msg.dst.y_off = 0;
+    msg.dst.vir_w = 480;
+    msg.dst.vir_h = 480;
+    msg.dst.format = IEP_FORMAT_YCbCr_420_SP;
+    msg.dst.mem_addr = (uint32_t*)phy_tmp;
+    msg.dst.uv_addr = (uint32_t*)(phy_tmp + 480 * 480);
+    msg.dst.v_addr = 0;
+
+    msg.dein_mode = IEP_DEINTERLACE_MODE_I2O1;
+    msg.field_order = FIELD_ORDER_BOTTOM_FIRST;
+    
+    IEP_INFO("*********** IEP TEST CASE 0  ************\n");
+
+    iep_config(&session, &msg);
+    iep_try_set_reg();
+    if (0 > iep_get_result_sync(&session)) {
+        IEP_INFO("%s failed, timeout\n", __func__);
+        ret = -ETIMEDOUT;
+    }
+
+    mdelay(10);
+
+    dmac_flush_range(&tmp_buf[0], &tmp_buf[480*480*3/2]);
+    outer_flush_range(virt_to_phys(&tmp_buf[0]),virt_to_phys(&tmp_buf[480*480*3/2]));
+
+    IEP_INFO("*********** RESULT CHECKING  ************\n");
+
+    for (i=0; i<480*480*3/2; i++) {
+        if (tmp_buf[i] != yuv420sp_480x480_deinterlaced_i2o1[i]) {
+            IEP_INFO("diff occur position %d, 0x%02x 0x%02x\n", i, tmp_buf[i], yuv420sp_480x480_deinterlaced_i2o1[i]);
+
+            if (i > 10) {
+                iep_dump();
+                break;
+            }
+        }
+    }
+
+    if (i == 480*480*3/2) {
+        IEP_INFO("IEP pass the checking\n");
+    }
+}
+
+#endif
diff --git a/drivers/video/rockchip/iep/iep_drv.h b/drivers/video/rockchip/iep/iep_drv.h
new file mode 100755
index 000000000000..5ebbe3fec9a5
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_drv.h
@@ -0,0 +1,153 @@
+#ifndef IEP_DRV_H_
+#define IEP_DRV_H_
+
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include "iep.h"
+
+#define IEP_REG_LEN         0x100
+#define IEP_CMD_REG_LEN     0xE
+#define IEP_ADD_REG_LEN     0xE0
+#define IEP_RAW_REG_LEN     0xA
+#define IEP_SYS_REG_LEN     0x6
+#define IEP_CNF_REG_LEN     0x2
+
+#define IEP_CNF_REG_BASE    0x0
+#define IEP_SYS_REG_BASE    0x2
+#define IEP_CMD_REG_BASE    0x8
+#define IEP_ADD_REG_BASE    0x20
+#define IEP_RAW_REG_BASE    0x16
+
+#if defined(CONFIG_IEP_MMU)
+#define IEP_MMU_REG_BASE    0x200
+#define IEP_MMU_REG_LEN     0xA
+#endif
+
+struct iep_parameter_req {
+    iep_img src;
+    iep_img dst;
+};
+
+struct iep_parameter_deinterlace {
+    iep_img src1;
+    iep_img dst1;
+
+    iep_img src_itemp;
+    iep_img src_ftemp;
+
+    iep_img dst_itemp;
+    iep_img dst_ftemp;
+
+    u8 dein_mode;
+
+    // deinterlace high frequency
+    u8 dein_high_fre_en;
+    u8 dein_high_fre_fct;
+
+    // deinterlace edge interpolation
+    u8 dein_ei_mode;
+    u8 dein_ei_smooth;
+    u8 dein_ei_sel;
+    u8 dein_ei_radius;
+};
+
+struct iep_parameter_enhance {
+    u8 yuv_3D_denoise_en;
+
+    u8 yuv_enhance_en;
+    float yuv_enh_saturation; //0-1.992
+    float yuv_enh_contrast; //0-1.992
+    s8 yuv_enh_brightness; //-32<brightness<31
+    s8 yuv_enh_hue_angle; //0-30value is 0 - 30
+
+    u8 video_mode; //0-3
+    u8 color_bar_y; //0-127
+    u8 color_bar_u; //0-127
+    u8 color_bar_v; //0-127
+
+    u8 rgb_enhance_en;
+
+    u8 rgb_cg_en; //sw_rgb_con_gam_en
+    double cg_rr;
+    double cg_rg;
+    double cg_rb;
+    u8 rgb_color_enhance_en; //sw_rgb_color_enh_en
+    float rgb_enh_coe; //0-3.96875
+};
+
+struct iep_parameter_scale {
+    u8 scale_up_mode;
+};
+
+struct iep_parameter_convert {
+    u8 dither_up_en;
+    u8 dither_down_en; //not to be used
+
+    u8 yuv2rgb_mode;
+    u8 rgb2yuv_mode;
+
+    u8 global_alpha_value;
+
+    u8 rgb2yuv_clip_en;
+    u8 yuv2rgb_clip_en;
+};
+
+typedef struct iep_session {
+    /* a linked list of data so we can access them for debugging */
+    struct list_head    list_session;
+    /* a linked list of register data waiting for process */
+    struct list_head    waiting;
+    /* a linked list of register data in ready */
+    struct list_head    ready;
+    /* a linked list of register data in processing */
+    struct list_head    running;
+    /* all coommand this thread done */
+    atomic_t            done;
+    wait_queue_head_t   wait;
+    pid_t               pid;
+    atomic_t            task_running;
+    atomic_t            num_done;
+
+#if defined(CONFIG_IEP_MMU)
+    uint32_t*           dte_table;
+    struct list_head    pte_list;
+    struct task_struct *tsk;
+#endif
+} iep_session;
+
+typedef struct iep_service_info {
+    struct mutex        lock;
+    struct timer_list	timer;          /* timer for power off */
+    struct list_head	waiting;        /* link to link_reg in struct iep_reg */
+    atomic_t            waitcnt;
+    struct list_head    ready;          /* link to link_reg in struct iep_reg */
+    struct list_head	running;        /* link to link_reg in struct iep_reg */
+    struct list_head	done;           /* link to link_reg in struct iep_reg */
+    struct list_head	session;        /* link to list_session in struct vpu_session */
+    atomic_t		    total_running;
+
+    struct iep_reg      *reg;
+    bool                enable;
+
+    struct mutex	    mutex;  // mutex
+} iep_service_info;
+
+struct iep_reg {
+    iep_session *session;
+    struct list_head 	session_link;      /* link to rga service session */
+    struct list_head 	status_link;       /* link to register set list */
+    uint32_t 			reg[0x300];
+    bool                dpi_en;
+    int                 off_x;
+    int                 off_y;
+    int                 act_width;
+    int                 act_height;
+    int                 vir_width;
+    int                 vir_height;
+    int                 layer;
+    unsigned int        format;
+};
+
+#endif
+
diff --git a/drivers/video/rockchip/iep/iep_mmu.c b/drivers/video/rockchip/iep/iep_mmu.c
new file mode 100755
index 000000000000..26b7675dd352
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_mmu.c
@@ -0,0 +1,233 @@
+/* 
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ */
+
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <asm/cacheflush.h>
+#include "iep_mmu.h"
+
+#define RK_MMU_DTE_SHIFT    22
+#define RK_MMU_DTE_MASK     (~0xFFFL)
+#define RK_MMU_PTE_SHIFT    12
+#define RK_MMU_PTE_MASK     (~0xFFFL)
+#define RK_MMU_DTE_ENTRY_CNT    ((1) << (32-RK_MMU_DTE_SHIFT))
+#define RK_MMU_PTE_ENTRY_CNT    ((1) << (RK_MMU_DTE_SHIFT - RK_MMU_PTE_SHIFT))
+
+#define RK_MMU_PAGE_PRESENT                 (1<<0)
+#define RK_MMU_READ_PERMISSION              (1<<1)
+#define RK_MMU_WRITE_PERMISSION             (1<<2)
+#define RK_MMU_OVERRIDE_CACHE_ATTRIBUTES    (0<<3)
+#define RK_MMU_WRITE_CACHE_ABLE             (0<<4)
+#define RK_MMU_WRITE_ALLOCABLE              (0<<5)
+#define RK_MMU_WRITE_BUFFERABLE             (0<<6)
+#define RK_MMU_READ_CACHE_ABLE              (0<<7)
+#define RK_MMU_READ_ALLOCABLE               (0<<8)
+
+#define RK_MMU_PTE_CTRL     (RK_MMU_PAGE_PRESENT | RK_MMU_READ_PERMISSION | \
+                            RK_MMU_WRITE_PERMISSION | RK_MMU_OVERRIDE_CACHE_ATTRIBUTES | \
+                            RK_MMU_WRITE_CACHE_ABLE | RK_MMU_WRITE_ALLOCABLE | \
+                            RK_MMU_WRITE_BUFFERABLE | RK_MMU_READ_CACHE_ABLE | \
+                            RK_MMU_READ_ALLOCABLE)
+
+#define RK_MMU_DTE_CTRL     RK_MMU_PAGE_PRESENT
+
+//#define RK_MMU_DEBUG
+
+static int map_user_space_addr(struct task_struct *tsk,
+                               uint32_t *pte_table,
+                               uint32_t page_index,
+                               uint32_t page_count)
+{
+    int result;
+    int i;
+    int status = 0;
+    uint32_t phy_addr = 0;
+    struct page **pages;
+
+    pages = kzalloc((page_count + 1) * sizeof(struct page*), GFP_KERNEL);
+
+    down_read(&tsk->mm->mmap_sem);
+    result = get_user_pages(tsk, 
+                            tsk->mm, 
+                            page_index << PAGE_SHIFT, 
+                            page_count,
+                            1, 0, pages, NULL
+                            );
+    up_read(&tsk->mm->mmap_sem);
+
+    if (result <= 0 || result < page_count) {
+        struct vm_area_struct *vma;
+
+        for(i=0; i<page_count; i++) {
+            vma = find_vma(tsk->mm, (page_index + i) << PAGE_SHIFT);
+
+            if (vma) {
+                pte_t *pte;
+                spinlock_t *ptl;
+                unsigned long pfn;
+                pgd_t *pgd;
+                pud_t *pud;
+                pmd_t *pmd;
+
+                pgd = pgd_offset(tsk->mm, (page_index + i) << PAGE_SHIFT);
+
+                if (pgd_none(*pgd) || pgd_bad(*pgd)) {
+                    IEP_ERR("iep, invalid pgd\n");
+                    status = -EIO;
+                    break;
+                }
+
+                pud = pud_offset(pgd, (page_index + i) << PAGE_SHIFT);
+                if (pud_none(*pud) || pud_bad(*pud)) {
+                    IEP_ERR("iep, invalid pud\n");
+                    status = -EIO;
+                    break;
+                }
+
+                pmd = pmd_offset(pud, (page_index + i) << PAGE_SHIFT);
+                if (pmd_none(*pmd) || pmd_bad(*pmd)) {
+                    status = -EIO;
+                    continue;
+                }
+
+                pte = pte_offset_map_lock(tsk->mm, pmd, (page_index + i) << PAGE_SHIFT, &ptl);
+                if (pte_none(*pte)) {
+                    pte_unmap_unlock(pte, ptl);
+                    status = -EIO;
+                    continue;
+                }
+
+                pfn = pte_pfn(*pte);
+                phy_addr = ((pfn << PAGE_SHIFT) | (((unsigned long)((page_index + i) << PAGE_SHIFT)) & ~PAGE_MASK));
+                pte_unmap_unlock(pte, ptl);
+
+                pte_table[i] = (phy_addr & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+            } else {
+                status = -EIO;
+                break;
+            }
+        }
+
+    } else {
+        /* fill the page table. */
+        for(i=0; i<page_count; i++) {
+            /* get the physical address from page struct. */
+            pte_table[i] = (page_to_phys(pages[i]) & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+        }
+    }
+
+    kfree(pages);
+
+    return status;
+}
+
+int rk_mmu_generate_pte_from_va(iep_session *session, uint32_t va) 
+{
+    int i;
+    int dte_index = va >> RK_MMU_DTE_SHIFT;
+    struct rk_mmu_pte *pte_node = NULL, *n;
+
+
+    if (session->dte_table[dte_index] != 0) {
+        list_for_each_entry_safe(pte_node, n, &session->pte_list, session_link) {
+            if (pte_node->index == dte_index) {
+                // a incomplete pte.
+#ifdef RK_MMU_DEBUG
+                uint32_t phy_addr;
+                uint32_t dte_addr;
+                uint32_t *pte_table;
+                uint32_t pte_addr;
+
+                int pte_index = (va >> PAGE_SHIFT) & 0x3FF;
+                int page_index = va & 0xFFF;
+
+                dte_addr = session->dte_table[dte_index];
+                IEP_DBG("dte_addr = %08x\n", dte_addr);
+
+                pte_table = phys_to_virt(dte_addr & RK_MMU_DTE_MASK);
+
+                pte_addr = pte_table[pte_index];
+
+                IEP_DBG("pte_addr = %08x\n", pte_addr);
+
+                phy_addr = (pte_addr & RK_MMU_PTE_MASK) | page_index;
+
+                IEP_DBG("phy %08x\n", phy_addr);
+#endif
+                IEP_DBG("Incomplete pte\n");
+                break;
+            }
+        }
+    }
+
+    if (pte_node == NULL || pte_node->index != dte_index) {
+        // pte node is absence
+        pte_node = (struct rk_mmu_pte*)kzalloc(sizeof(struct rk_mmu_pte), GFP_KERNEL);
+        pte_node->pte = (uint32_t*)kzalloc(sizeof(uint32_t) * RK_MMU_PTE_ENTRY_CNT, GFP_KERNEL);
+        pte_node->index = dte_index;
+    }
+    
+    IEP_DBG("va = %08x\n", va);
+
+    if (va < PAGE_OFFSET) {
+        map_user_space_addr(session->tsk, pte_node->pte, (va >> PAGE_SHIFT) & (~0x3FFL), RK_MMU_PTE_ENTRY_CNT);
+    } else {
+        for (i=0; i<RK_MMU_PTE_ENTRY_CNT; i++) {
+            pte_node->pte[i] = (uint32_t)(virt_to_phys((uint32_t*)((va + i) << PAGE_SHIFT)) & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+        }
+    }
+
+    IEP_DBG("pa = %08x\n", (uint32_t)((pte_node->pte[(va>>PAGE_SHIFT) & 0x3FFL] & RK_MMU_PTE_MASK) | (va & 0xFFFL)));
+
+    INIT_LIST_HEAD(&pte_node->session_link);
+    list_add_tail(&pte_node->session_link, &session->pte_list);
+
+    dmac_flush_range(&pte_node->pte[0], &pte_node->pte[RK_MMU_PTE_ENTRY_CNT-1]);
+    outer_flush_range(virt_to_phys(&pte_node->pte[0]),virt_to_phys(&pte_node->pte[RK_MMU_PTE_ENTRY_CNT-1]));
+
+    session->dte_table[pte_node->index] = (uint32_t)(virt_to_phys((uint32_t*)pte_node->pte) & RK_MMU_DTE_MASK) | RK_MMU_DTE_CTRL;
+
+    dmac_flush_range(&session->dte_table[pte_node->index], &session->dte_table[pte_node->index+1]);
+    outer_flush_range(virt_to_phys(&session->dte_table[pte_node->index]),virt_to_phys(&session->dte_table[pte_node->index+1]));
+
+    return 0;
+}
+
+void rk_mmu_reclaim_pte_list(iep_session *session)
+{
+    struct rk_mmu_pte *pte_node, *n;
+
+    list_for_each_entry_safe(pte_node, n, &session->pte_list, session_link) {
+        list_del_init(&pte_node->session_link);
+        kfree(pte_node->pte);
+        kfree(pte_node);
+    }
+}
+
+/// don't call this function in interupt service.
+int rk_mmu_init_dte_table(iep_session *session)
+{
+    session->tsk = current;
+    session->dte_table = (uint32_t*)kzalloc(sizeof(uint32_t) * RK_MMU_DTE_ENTRY_CNT, GFP_KERNEL);
+
+    return 0;
+}
+
+void rk_mmu_deinit_dte_table(iep_session *session)
+{
+    rk_mmu_reclaim_pte_list(session);
+    kfree(session->dte_table);
+}
+
diff --git a/drivers/video/rockchip/iep/iep_mmu.h b/drivers/video/rockchip/iep/iep_mmu.h
new file mode 100755
index 000000000000..0f9591e926fe
--- /dev/null
+++ b/drivers/video/rockchip/iep/iep_mmu.h
@@ -0,0 +1,18 @@
+#ifndef _IEP_MMU_H_
+#define _IEP_MMU_H_
+
+#include <linux/types.h>
+#include "iep_drv.h"
+
+struct rk_mmu_pte {
+    int index;                      // dte entry index [0, 1023]
+    uint32_t *pte;                  // point to pte table
+    struct list_head session_link;  // link to session
+};
+
+int rk_mmu_generate_pte_from_va(iep_session *session, uint32_t va);
+void rk_mmu_reclaim_pte_list(iep_session *session);
+int rk_mmu_init_dte_table(iep_session *session);
+void rk_mmu_deinit_dte_table(iep_session *session);
+
+#endif
-- 
2.35.3

