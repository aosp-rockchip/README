From aa932b765305b1cee6bfe648e19a0c1a7cd3f0c8 Mon Sep 17 00:00:00 2001
From: hjc <hjc@rock-chips.com>
Date: Mon, 28 Jan 2013 16:53:42 +0800
Subject: [PATCH] rk3168_86v: Basic functions is ok

---
 Makefile                                      |    4 +-
 arch/arm/configs/rk3168_86v_defconfig         | 3087 +++++++++++++++++
 arch/arm/mach-rk30/Kconfig                    |    4 +
 arch/arm/mach-rk30/Makefile                   |    2 +
 arch/arm/mach-rk30/board-rk3168-86v-camera.c  |  486 +++
 arch/arm/mach-rk30/board-rk3168-86v.c         | 1878 ++++++++++
 drivers/input/touchscreen/86v_gt811_ts.c      | 2017 +++++++++++
 drivers/input/touchscreen/86v_gt811_ts.h      |  277 ++
 drivers/input/touchscreen/Kconfig             |    6 +-
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/video/display/screen/Kconfig          |    3 +
 drivers/video/display/screen/Makefile         |    1 +
 .../screen/lcd_YQ70CPT9160_rk3168_86v.c       |  195 ++
 13 files changed, 7958 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/configs/rk3168_86v_defconfig
 create mode 100644 arch/arm/mach-rk30/board-rk3168-86v-camera.c
 create mode 100644 arch/arm/mach-rk30/board-rk3168-86v.c
 create mode 100644 drivers/input/touchscreen/86v_gt811_ts.c
 create mode 100644 drivers/input/touchscreen/86v_gt811_ts.h
 create mode 100644 drivers/video/display/screen/lcd_YQ70CPT9160_rk3168_86v.c

diff --git a/Makefile b/Makefile
index b22d80e944c8..0ec77bf9bd30 100644
--- a/Makefile
+++ b/Makefile
@@ -194,8 +194,8 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 export KBUILD_BUILDHOST := $(SUBARCH)
 #ARCH		?= $(SUBARCH)
 ARCH		?= arm
-ifneq ($(wildcard ../toolchain/arm-eabi-4.4.3),)
-CROSS_COMPILE	?= ../toolchain/arm-eabi-4.4.3/bin/arm-eabi-
+ifneq ($(wildcard ../../../toolchain/arm-eabi-4.4.3),)
+CROSS_COMPILE	?= ../../../toolchain/arm-eabi-4.4.3/bin/arm-eabi-
 endif
 ifneq ($(wildcard ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3),)
 CROSS_COMPILE	?= ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
diff --git a/arch/arm/configs/rk3168_86v_defconfig b/arch/arm/configs/rk3168_86v_defconfig
new file mode 100644
index 000000000000..0937ec7f9358
--- /dev/null
+++ b/arch/arm/configs/rk3168_86v_defconfig
@@ -0,0 +1,3087 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.36 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_FIQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_RK29 is not set
+# CONFIG_ARCH_RK2928 is not set
+CONFIG_ARCH_RK30=y
+# CONFIG_ARCH_RK3188 is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_DDR_TYPE_DDRII is not set
+# CONFIG_DDR_TYPE_LPDDR is not set
+# CONFIG_DDR_TYPE_DDR3_800D is not set
+# CONFIG_DDR_TYPE_DDR3_800E is not set
+# CONFIG_DDR_TYPE_DDR3_1066E is not set
+# CONFIG_DDR_TYPE_DDR3_1066F is not set
+# CONFIG_DDR_TYPE_DDR3_1066G is not set
+# CONFIG_DDR_TYPE_DDR3_1333F is not set
+# CONFIG_DDR_TYPE_DDR3_1333G is not set
+# CONFIG_DDR_TYPE_DDR3_1333H is not set
+# CONFIG_DDR_TYPE_DDR3_1333J is not set
+# CONFIG_DDR_TYPE_DDR3_1600G is not set
+# CONFIG_DDR_TYPE_DDR3_1600H is not set
+# CONFIG_DDR_TYPE_DDR3_1600J is not set
+# CONFIG_DDR_TYPE_DDR3_1600K is not set
+# CONFIG_DDR_TYPE_DDR3_1866J is not set
+# CONFIG_DDR_TYPE_DDR3_1866K is not set
+# CONFIG_DDR_TYPE_DDR3_1866L is not set
+# CONFIG_DDR_TYPE_DDR3_1866M is not set
+# CONFIG_DDR_TYPE_DDR3_2133K is not set
+# CONFIG_DDR_TYPE_DDR3_2133L is not set
+# CONFIG_DDR_TYPE_DDR3_2133M is not set
+# CONFIG_DDR_TYPE_DDR3_2133N is not set
+CONFIG_DDR_TYPE_DDR3_DEFAULT=y
+CONFIG_DDR_INIT_CHANGE_FREQ=y
+CONFIG_DDR_SDRAM_FREQ=400
+# CONFIG_DDR_FREQ is not set
+# CONFIG_DDR_TEST is not set
+CONFIG_DVFS=y
+CONFIG_RK_CLOCK_PROC=y
+
+#
+# Support for RK power manage
+#
+CONFIG_CLK_SWITCH_TO_32K=y
+# CONFIG_RK30_I2C_INSRAM is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC is not set
+CONFIG_RK29_VPU=m
+CONFIG_RK29_LAST_LOG=y
+CONFIG_RK_EARLY_PRINTK=y
+CONFIG_RK_DEBUG_UART=2
+CONFIG_RK_CONSOLE_THREAD=y
+# CONFIG_RK_SRAM_DMA is not set
+CONFIG_RK_PL330_DMA=y
+# CONFIG_RK_PL330_DMA_TEST is not set
+CONFIG_ARCH_RK3066B=y
+# CONFIG_SOC_RK3000 is not set
+# CONFIG_SOC_RK3066 is not set
+# CONFIG_SOC_RK3068 is not set
+# CONFIG_SOC_RK3066B is not set
+# CONFIG_SOC_RK3108 is not set
+CONFIG_SOC_RK3168=y
+# CONFIG_MACH_RK3168_TB is not set
+# CONFIG_MACH_RK3168_LR097 is not set
+# CONFIG_MACH_RK3168_DS1006H is not set
+CONFIG_MACH_RK3168_86V=y
+CONFIG_SOC_RK3188=y
+CONFIG_MACH_RK3188_TB=y
+# CONFIG_MACH_RK3188_FPGA is not set
+# CONFIG_MACH_RK3188_LR097 is not set
+# CONFIG_MACH_RK3188_DS1006H is not set
+
+#
+# System MMU
+#
+CONFIG_PLAT_RK=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_ARM_ERRATA_775420=y
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+CONFIG_FIQ_GLUE=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+# CONFIG_FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON is not set
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_RUNTIME_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_SUSPEND_SYNC_WORKQUEUE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_HCIBCM4325=y
+CONFIG_IDBLOCK=y
+# CONFIG_WIFI_MAC is not set
+CONFIG_BT_AUTOSLEEP=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_RFKILL_RESET is not set
+CONFIG_RFKILL_RK=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_SYNC is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND is not set
+CONFIG_MTD_RKNAND=y
+CONFIG_MTD_NAND_RK29XX=y
+CONFIG_MTD_RKNAND_BUFFER=y
+# CONFIG_MTD_EMMC_CLK_POWER_SAVE is not set
+# CONFIG_MTD_NAND_RK29XX_DEBUG is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_WL127X_RFKILL is not set
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_MTK23D is not set
+# CONFIG_FM580X is not set
+# CONFIG_RK29_SC8800 is not set
+# CONFIG_TDSC8800 is not set
+# CONFIG_MODEM_SOUND is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_RK29_SUPPORT_MODEM is not set
+# CONFIG_GPS_DEVICES is not set
+# CONFIG_MPU_SENSORS_TIMERIRQ is not set
+# CONFIG_INV_SENSORS is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_3G_MODULE is not set
+# CONFIG_BP_AUTO is not set
+# CONFIG_RK2928_CALLPAD_MISC is not set
+# CONFIG_AUDIO_SWITCH is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_80211=y
+# CONFIG_WIFI_NONE is not set
+# CONFIG_BCM4329 is not set
+# CONFIG_BCM4319 is not set
+# CONFIG_RDA5990 is not set
+# CONFIG_MV8686 is not set
+# CONFIG_MT5931 is not set
+# CONFIG_MT5931_MT6622 is not set
+# CONFIG_RTL8192CU is not set
+CONFIG_RTL8188EU=y
+# CONFIG_RT5370 is not set
+# CONFIG_AR6003 is not set
+# CONFIG_RKWIFI is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_DM9620=y
+CONFIG_USB_NET_SR9700=y
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=y
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_CDC_PHONET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYS_RK29=y
+# CONFIG_SYNAPTICS_SO340010 is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_WM831X_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_CT36X_TS=y
+# CONFIG_TOUCHSCREEN_ILI2102_IIC is not set
+# CONFIG_TOUCHSCREEN_GT8XX is not set
+# CONFIG_TOUCHSCREEN_CT36X is not set
+# CONFIG_TOUCHSCREEN_IT7250 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_EETI_EGALAX is not set
+# CONFIG_TOUCHSCREEN_GT811_IIC is not set
+CONFIG_TOUCHSCREEN_86V_GT811_IIC=y
+# CONFIG_TOUCHSCREEN_GT82X_IIC is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK is not set
+# CONFIG_TOUCHSCREEN_GT8110 is not set
+# CONFIG_TOUCHSCREEN_CT360_IIC is not set
+# CONFIG_TOUCHSCREEN_FT5306 is not set
+# CONFIG_TOUCHSCREEN_I30 is not set
+# CONFIG_TOUCHSCREEN_BYD693X is not set
+# CONFIG_TOUCHSCREEN_SITRONIX_A720 is not set
+# CONFIG_TOUCHSCREEN_FT5306_WPX2 is not set
+# CONFIG_TOUCHSCREEN_FT5306_AV is not set
+# CONFIG_TOUCHSCREEN_FT5X0X is not set
+# CONFIG_ATMEL_MXT1386 is not set
+# CONFIG_TS_AUTO is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_LPSENSOR_ISL29028 is not set
+# CONFIG_INPUT_LPSENSOR_CM3602 is not set
+# CONFIG_INPUT_LPSENSOR_AL3006 is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_RK_BOARD_ID is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_MAG_SENSORS is not set
+# CONFIG_G_SENSOR_DEVICE is not set
+CONFIG_GS_MMA7660=y
+# CONFIG_GS_MMA8452 is not set
+# CONFIG_GS_LIS3DH is not set
+# CONFIG_GS_BMA023 is not set
+# CONFIG_GYRO_SENSOR_DEVICE is not set
+# CONFIG_INPUT_JOGBALL is not set
+# CONFIG_LIGHT_SENSOR_DEVICE is not set
+
+#
+# handle all sensors
+#
+CONFIG_SENSOR_DEVICE=y
+CONFIG_GSENSOR_DEVICE=y
+# CONFIG_GS_KXTIK is not set
+# CONFIG_GS_MXC6225 is not set
+# CONFIG_COMPASS_DEVICE is not set
+# CONFIG_GYROSCOPE_DEVICE is not set
+# CONFIG_LIGHT_DEVICE is not set
+# CONFIG_PROXIMITY_DEVICE is not set
+# CONFIG_TEMPERATURE_DEVICE is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+# CONFIG_UART0_CTS_RTS_RK29 is not set
+CONFIG_UART0_DMA_RK29=2
+# CONFIG_UART1_RK29 is not set
+# CONFIG_UART2_RK29 is not set
+CONFIG_UART3_RK29=y
+CONFIG_UART3_CTS_RTS_RK29=y
+CONFIG_UART3_DMA_RK29=0
+# CONFIG_SERIAL_RK29_CONSOLE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_RK30=y
+
+#
+# Now, there are five selectable I2C channels.
+#
+CONFIG_I2C0_RK30=y
+# CONFIG_I2C0_CONTROLLER_RK29 is not set
+CONFIG_I2C0_CONTROLLER_RK30=y
+CONFIG_I2C1_RK30=y
+# CONFIG_I2C1_CONTROLLER_RK29 is not set
+CONFIG_I2C1_CONTROLLER_RK30=y
+CONFIG_I2C2_RK30=y
+# CONFIG_I2C2_CONTROLLER_RK29 is not set
+CONFIG_I2C2_CONTROLLER_RK30=y
+CONFIG_I2C3_RK30=y
+# CONFIG_I2C3_CONTROLLER_RK29 is not set
+CONFIG_I2C3_CONTROLLER_RK30=y
+CONFIG_I2C4_RK30=y
+# CONFIG_I2C4_CONTROLLER_RK29 is not set
+CONFIG_I2C4_CONTROLLER_RK30=y
+# CONFIG_I2C_GPIO_RK30 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+CONFIG_ADC=y
+# CONFIG_ADC_NULL is not set
+CONFIG_ADC_RK30=y
+
+#
+# Headset device support
+#
+# CONFIG_RK_HEADSET_DET is not set
+# CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_GPIO_PCA9554 is not set
+# CONFIG_IOEXTEND_TCA6424 is not set
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+# CONFIG_EXPAND_GPIO_SOFT_INTERRUPT is not set
+CONFIG_SPI_FPGA_GPIO_NUM=0
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_GPIO_TPS65910=y
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_RK30_ADC is not set
+CONFIG_BATTERY_RK30_ADC_FAC=y
+CONFIG_BATTERY_RK30_AC_CHARGE=y
+# CONFIG_BATTERY_RK30_USB_CHARGE is not set
+CONFIG_BATTERY_RK30_VOL3V8=y
+# CONFIG_POWER_ON_CHARGER_DISPLAY is not set
+# CONFIG_WM8326_VBAT_LOW_DETECTION is not set
+# CONFIG_TWL60xx_VBAT_LOW_DETECTION is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+CONFIG_MFD_TPS65910=y
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_AIC3262_CODEC is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+CONFIG_MFD_RK610=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_TPS65910=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_RK2818_REGULATOR_CHARGE is not set
+# CONFIG_RK2818_REGULATOR_LP8725 is not set
+# CONFIG_REGULATOR_ACT8891 is not set
+# CONFIG_REGULATOR_ACT8931 is not set
+CONFIG_REGULATOR_ACT8846=y
+# CONFIG_ACT8846_SUPPORT_RESET is not set
+# CONFIG_RK29_PWM_REGULATOR is not set
+# CONFIG_RK30_PWM_REGULATOR is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_IMX074 is not set
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9M112 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9T111 is not set
+# CONFIG_SOC_CAMERA_MT9P111 is not set
+# CONFIG_SOC_CAMERA_MT9D112 is not set
+# CONFIG_SOC_CAMERA_MT9D113 is not set
+# CONFIG_SOC_CAMERA_MT9T112 is not set
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+# CONFIG_SOC_CAMERA_RJ54N1 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+# CONFIG_SOC_CAMERA_OV2640 is not set
+# CONFIG_SOC_CAMERA_OV6650 is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV7675 is not set
+# CONFIG_SOC_CAMERA_OV2655 is not set
+# CONFIG_SOC_CAMERA_OV2659 is not set
+# CONFIG_SOC_CAMERA_OV7690 is not set
+# CONFIG_SOC_CAMERA_OV9650 is not set
+# CONFIG_SOC_CAMERA_OV2640_RK is not set
+# CONFIG_SOC_CAMERA_OV3640 is not set
+# CONFIG_SOC_CAMERA_OV3660 is not set
+# CONFIG_SOC_CAMERA_OV5642 is not set
+# CONFIG_SOC_CAMERA_OV5640 is not set
+# CONFIG_SOC_CAMERA_OV5640_FOR_TD8801 is not set
+# CONFIG_SOC_CAMERA_S5K6AA is not set
+# CONFIG_SOC_CAMERA_GT2005 is not set
+# CONFIG_SOC_CAMERA_GC0307 is not set
+CONFIG_SOC_CAMERA_GC0308=y
+# CONFIG_GC0308_USER_DEFINED_SERIES is not set
+# CONFIG_SOC_CAMERA_GC0308_INTERPOLATION is not set
+# CONFIG_SOC_CAMERA_GC0309 is not set
+# CONFIG_SOC_CAMERA_GC0309_FOR_TD8801 is not set
+# CONFIG_SOC_CAMERA_GC2015 is not set
+# CONFIG_SOC_CAMERA_GC2035 is not set
+# CONFIG_SOC_CAMERA_HI253 is not set
+# CONFIG_SOC_CAMERA_HI704 is not set
+# CONFIG_SOC_CAMERA_SIV120B is not set
+# CONFIG_SOC_CAMERA_SIV121D is not set
+# CONFIG_SOC_CAMERA_SID130B is not set
+# CONFIG_SOC_CAMERA_NT99250 is not set
+# CONFIG_SOC_CAMERA_GC0329 is not set
+# CONFIG_SOC_CAMERA_S5K5CA is not set
+# CONFIG_SOC_CAMERA_SP0838 is not set
+# CONFIG_SOC_CAMERA_SP2518 is not set
+# CONFIG_SOC_CAMERA_OV9640 is not set
+# CONFIG_SOC_CAMERA_OV9740 is not set
+# CONFIG_SOC_CAMERA_MV9335 is not set
+# CONFIG_VIDEO_SH_MOBILE_CSI2 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RKCIF_WORK_ONEFRAME=y
+# CONFIG_VIDEO_RKCIF_WORK_PINGPONG is not set
+CONFIG_VIDEO_RK29_WORK_IPP=y
+# CONFIG_VIDEO_RK29_WORK_NOT_IPP is not set
+CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON=y
+# CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF is not set
+# CONFIG_VIDEO_RK29_CAMMEM_PMEM is not set
+CONFIG_VIDEO_RK29_CAMMEM_ION=y
+# CONFIG_VIDEO_RKCIF_WORK_SIMUL_ON is not set
+CONFIG_VIDEO_RKCIF_WORK_SIMUL_OFF=y
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+CONFIG_ION=y
+CONFIG_ION_ROCKCHIP=y
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_RK29 is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_RK29_BL=y
+# CONFIG_BACKLIGHT_AW9364 is not set
+# CONFIG_BUTTON_LIGHT is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=y
+
+#
+# Display hardware drivers
+#
+# CONFIG_LCD_NULL is not set
+# CONFIG_LCD_LG_LP097X02 is not set
+# CONFIG_LCD_TD043MGEA1 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_TJ048NC01CA is not set
+# CONFIG_LCD_HL070VM4AU is not set
+# CONFIG_LCD_HSD070IDW1 is not set
+# CONFIG_LCD_RGB_TFT480800_25_E is not set
+# CONFIG_LCD_HSD100PXN is not set
+# CONFIG_LCD_HSD07PFW1 is not set
+# CONFIG_LCD_BYD8688FTGF is not set
+# CONFIG_LCD_B101AW06 is not set
+# CONFIG_LCD_LS035Y8DX02A is not set
+# CONFIG_LCD_LS035Y8DX04A is not set
+# CONFIG_LCD_HSD100PXN_FOR_TDW851 is not set
+# CONFIG_LCD_CPTCLAA038LA31XE is not set
+# CONFIG_LCD_A060SE02 is not set
+# CONFIG_LCD_S1D13521 is not set
+# CONFIG_LCD_NT35582 is not set
+# CONFIG_LCD_NT35580 is not set
+# CONFIG_LCD_IPS1P5680_V1_E is not set
+# CONFIG_LCD_MCU_TFT480800_25_E is not set
+# CONFIG_LCD_NT35510 is not set
+# CONFIG_LCD_ILI9803_CPT4_3 is not set
+# CONFIG_LCD_AT070TNA2 is not set
+# CONFIG_LCD_AT070TN93 is not set
+# CONFIG_LCD_TX23D88VM is not set
+# CONFIG_LCD_A050VL01 is not set
+# CONFIG_LCD_B101EW05 is not set
+# CONFIG_LCD_HJ050NA_06A is not set
+# CONFIG_LCD_HDMI_1280x800 is not set
+# CONFIG_LCD_HDMI_1024x768 is not set
+# CONFIG_LCD_HDMI_800x480 is not set
+# CONFIG_LCD_HV070WSA100 is not set
+# CONFIG_LCD_COMMON is not set
+# CONFIG_LCD_RK2928_A720 is not set
+# CONFIG_LCD_RK2926_V86 is not set
+CONFIG_LCD_RK3168_86V=y
+# CONFIG_LCD_HJ080NA is not set
+# CONFIG_LCD_HJ101NA is not set
+# CONFIG_LCD_AUTO is not set
+# CONFIG_LCD_I30_800X480 is not set
+# CONFIG_LCD_TL5001_MIPI is not set
+# CONFIG_LCD_LP097QX1 is not set
+# CONFIG_LCD_DS1006H is not set
+# CONFIG_NO_TRSM is not set
+CONFIG_RK610_LVDS=y
+# CONFIG_TC358768_RGB2MIPI is not set
+# CONFIG_DP_ANX6345 is not set
+# CONFIG_DP501 is not set
+CONFIG_RK610_TVOUT=y
+# CONFIG_RK610_TVOUT_YPbPr is not set
+# CONFIG_RK610_TVOUT_CVBS is not set
+
+#
+# HDMI
+#
+# CONFIG_HDMI is not set
+CONFIG_FB_ROCKCHIP=y
+# CONFIG_FB_MIRRORING is not set
+# CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL is not set
+CONFIG_ONE_LCDC_DUAL_OUTPUT_INF=y
+# CONFIG_NO_DUAL_DISP is not set
+# CONFIG_FB_ROTATE is not set
+CONFIG_THREE_FB_BUFFER=y
+# CONFIG_LCDC_RK30 is not set
+CONFIG_LCDC_RK3066B=y
+# CONFIG_LCDC0_RK3066B is not set
+CONFIG_LCDC1_RK3066B=y
+CONFIG_RK_HDMI=y
+# CONFIG_HDMI_CAT66121 is not set
+CONFIG_HDMI_RK610=y
+# CONFIG_HDCP_RK610 is not set
+# CONFIG_HDMI_SOURCE_LCDC0 is not set
+CONFIG_HDMI_SOURCE_LCDC1=y
+# CONFIG_RK_HDMI_DEBUG is not set
+CONFIG_RK_HDMI_CTL_CODEC=y
+
+#
+# RGA
+#
+CONFIG_RGA_RK30=y
+# CONFIG_RK_LVDS is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_LOGO_PIPO_CLUT224 is not set
+# CONFIG_LOGO_CHARGER_CLUT224 is not set
+# CONFIG_LOGO_G3_CLUT224 is not set
+# CONFIG_LOGO_LINUX_800x480_CLUT224 is not set
+# CONFIG_LOGO_LINUX_BMP is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_RK29_SOC_I2S=y
+CONFIG_SND_RK29_SOC_I2S_2CH=y
+# CONFIG_SND_I2S_DMA_EVENT_DYNAMIC is not set
+CONFIG_SND_I2S_DMA_EVENT_STATIC=y
+# CONFIG_SND_RK29_SOC_SPDIF is not set
+# CONFIG_SND_RK29_SOC_WM8988 is not set
+# CONFIG_SND_RK29_SOC_WM8900 is not set
+# CONFIG_SND_RK29_SOC_RT5621 is not set
+# CONFIG_SND_RK29_SOC_RT5623 is not set
+# CONFIG_SND_RK29_SOC_RT5631 is not set
+# CONFIG_SND_RK29_SOC_RT5631_PHONE is not set
+# CONFIG_SND_RK29_SOC_RT5625 is not set
+# CONFIG_SND_RK29_SOC_RT3224 is not set
+# CONFIG_SND_RK29_SOC_RT3261 is not set
+# CONFIG_SND_RK29_SOC_CS42L52 is not set
+# CONFIG_SND_RK29_SOC_AIC3111 is not set
+# CONFIG_SND_RK29_SOC_AIC3262 is not set
+# CONFIG_SND_RK29_SOC_RK1000 is not set
+CONFIG_SND_RK29_SOC_RK610=y
+# CONFIG_SND_RK29_CODEC_SOC_MASTER is not set
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+# CONFIG_ADJUST_VOL_BY_CODEC is not set
+# CONFIG_PHONE_INCALL_IS_SUSPEND is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_RK610=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+# CONFIG_USB_SERIAL_USI is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+CONFIG_USB_GADGET_DWC_OTG=y
+CONFIG_USB_DWC_OTG=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB11_HOST is not set
+CONFIG_USB20_HOST=y
+CONFIG_USB20_HOST_EN=y
+CONFIG_USB20_OTG=y
+# CONFIG_DWC_OTG_HOST_ONLY is not set
+CONFIG_DWC_OTG_DEVICE_ONLY=y
+# CONFIG_DWC_OTG_BOTH_HOST_SLAVE is not set
+CONFIG_DWC_CONN_EN=y
+# CONFIG_DWC_OTG_DEBUG is not set
+# CONFIG_DWC_REMOTE_WAKEUP is not set
+CONFIG_DWC_OTG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_SDMMC_RK29=y
+
+#
+# Now, there are two SDMMC controllers selected, SDMMC0 and SDMMC1.
+#
+# CONFIG_SDMMC_RK29_OLD is not set
+CONFIG_SDMMC0_RK29=y
+# CONFIG_SDMMC0_RK29_WRITE_PROTECT is not set
+# CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO is not set
+CONFIG_SDMMC1_RK29=y
+# CONFIG_SDMMC1_RK29_WRITE_PROTECT is not set
+# CONFIG_RK29_SDIO_IRQ_FROM_GPIO is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_ATT1272 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_AUTO_WAKE_UP is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_HYM8563 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_S35392A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_TPS65910_RTC=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+
+#
+# IPP
+#
+CONFIG_RK29_IPP=m
+CONFIG_DEINTERLACE=y
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# CMMB
+#
+# CONFIG_CMMB is not set
+# CONFIG_TEST_CODE is not set
+# CONFIG_RK29_SMC is not set
+
+#
+# CIR support
+#
+# CONFIG_RK_CIR is not set
+
+#
+# MediaTek Connectivity Combo Chip Config
+#
+# CONFIG_MTK_COMBO is not set
+# CONFIG_MTK_GPS is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/mach-rk30/Kconfig b/arch/arm/mach-rk30/Kconfig
index feaa091c3625..dc7b6ec59ebf 100755
--- a/arch/arm/mach-rk30/Kconfig
+++ b/arch/arm/mach-rk30/Kconfig
@@ -124,6 +124,10 @@ config MACH_RK3168_LR097
 config MACH_RK3168_DS1006H
 	bool "RK3168 DS1006h Board"
 
+config MACH_RK3168_86V
+	bool "RK3168 86V Board"
+
+
 endchoice
 endif
 
diff --git a/arch/arm/mach-rk30/Makefile b/arch/arm/mach-rk30/Makefile
index 63728a1a7e22..9835756a1a1a 100755
--- a/arch/arm/mach-rk30/Makefile
+++ b/arch/arm/mach-rk30/Makefile
@@ -42,3 +42,5 @@ obj-$(CONFIG_MACH_RK3108_TB) += board-rk3108-tb.o
 obj-$(CONFIG_MACH_RK3168_TB) += board-rk3168-tb.o
 obj-$(CONFIG_MACH_RK3168_LR097) += board-rk3168-LR097.o
 obj-$(CONFIG_MACH_RK3168_DS1006H) += board-rk3168-ds1006h.o
+obj-$(CONFIG_MACH_RK3168_86V) += board-rk3168-86v.o
+
diff --git a/arch/arm/mach-rk30/board-rk3168-86v-camera.c b/arch/arm/mach-rk30/board-rk3168-86v-camera.c
new file mode 100644
index 000000000000..501242c9b1d6
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk3168-86v-camera.c
@@ -0,0 +1,486 @@
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5640						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  3
+#define CONFIG_SENSOR_ORIENTATION_0 	  90
+#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK30_PIN3_PB5
+#define CONFIG_SENSOR_FALSH_PIN_0		  RK30_PIN0_PD5 //INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_H
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       RK30_PIN1_PD6
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_02                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_GC0308                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	    0x42
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
+#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK30_PIN3_PB4
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
+#define CONFIG_SENSOR_ORIENTATION_11       270
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       INVALID_GPIO//RK30_PIN1_PB7
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2659//RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	   0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       INVALID_GPIO//RK30_PIN1_PB7
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk30_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   0 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   1
+
+static void rk_cif_power(int on)
+{
+    struct regulator *ldo_18,*ldo_28;
+	ldo_28 = regulator_get(NULL, "ldo7");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "ldo1");	// vcc18_cif
+	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
+        printk("get cif ldo failed!\n");
+		return;
+	    }
+    if(on == 0){	
+    	regulator_disable(ldo_28);
+    	regulator_put(ldo_28);
+    	regulator_disable(ldo_18);
+    	regulator_put(ldo_18);
+    	mdelay(500);
+        }
+    else{
+    	regulator_set_voltage(ldo_28, 2800000, 2800000);
+    	regulator_enable(ldo_28);
+   // 	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
+    	regulator_put(ldo_28);
+
+    	regulator_set_voltage(ldo_18, 1800000, 1800000);
+    //	regulator_set_suspend_voltage(ldo, 1800000);
+    	regulator_enable(ldo_18);
+    //	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
+    	regulator_put(ldo_18);
+        }
+}
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+    rk_cif_power(on);
+	return 0;
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+
+#define CONFIG_SENSOR_FALSH_EN_PIN_0		  RK30_PIN0_PD5   //high:enable
+#define CONFIG_SENSOR_FALSH_EN_MUX_0		  GPIO0D5_SPI1TXD_NAME
+#define CONFIG_SENSOR_FALSH_MODE_PIN_0		  RK30_PIN0_PD4   //high:FLASH, low:torch
+#define CONFIG_SENSOR_FALSH_MODE_MUX_0		  GPIO0D4_SPI1RXD_NAME
+
+static int sensor_init_flags = 0;
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+        if(sensor_init_flags == 0){
+                rk30_mux_api_set(CONFIG_SENSOR_FALSH_MODE_MUX_0, 0);
+                int ret = gpio_request(CONFIG_SENSOR_FALSH_MODE_PIN_0, "camera_flash_mode");
+                if (ret != 0) {
+                    printk(">>>>gpio request camera_flash_mode faile !!\n");
+                }
+                
+                gpio_direction_output(CONFIG_SENSOR_FALSH_MODE_PIN_0, 0);
+                sensor_init_flags = 1 ;
+        }
+        switch (on) {
+		case Flash_Off: {
+			gpio_set_value(CONFIG_SENSOR_FALSH_EN_PIN_0, 0);
+			gpio_set_value(CONFIG_SENSOR_FALSH_MODE_PIN_0, 0);
+			break;
+		}
+
+		case Flash_On: {
+			gpio_set_value(CONFIG_SENSOR_FALSH_EN_PIN_0, 1);
+			gpio_set_value(CONFIG_SENSOR_FALSH_MODE_PIN_0, 1);
+			break;
+		}
+
+		case Flash_Torch: {
+			gpio_set_value(CONFIG_SENSOR_FALSH_EN_PIN_0, 1);
+			gpio_set_value(CONFIG_SENSOR_FALSH_MODE_PIN_0, 0);
+			break;
+		}
+
+		default: {
+			printk("%s..Flash command(%d) is invalidate \n",__FUNCTION__, on);
+			gpio_set_value(CONFIG_SENSOR_FALSH_EN_PIN_0, 0);
+			break;
+		}
+	}
+	return 0;
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+
+ };
+#include "../../../drivers/media/video/rk30_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
diff --git a/arch/arm/mach-rk30/board-rk3168-86v.c b/arch/arm/mach-rk30/board-rk3168-86v.c
new file mode 100644
index 000000000000..25c0ab8cb69b
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk3168-86v.c
@@ -0,0 +1,1878 @@
+/*
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ion.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <mach/dvfs.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <linux/rk_fb.h>
+#include <linux/regulator/machine.h>
+#include <linux/rfkill-rk.h>
+#include <linux/sensor-dev.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/regulator/act8846.h>
+#include <linux/regulator/rk29-pwm-regulator.h>
+#if defined(CONFIG_CT36X_TS)
+#include <linux/ct36x.h>
+#endif
+#if defined(CONFIG_MFD_RK610)
+#include <linux/mfd/rk610_core.h>
+#endif
+
+#if defined(CONFIG_RK_HDMI)
+	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
+#endif
+
+#if defined(CONFIG_SPIM_RK29)
+#include "../../../drivers/spi/rk29_spim.h"
+#endif
+#if defined(CONFIG_GPS_RK)
+#include "../../../drivers/misc/gps/rk_gps/rk_gps.h"
+#endif
+
+#if defined(CONFIG_MT6620)
+#include <linux/gps.h>
+#endif
+
+#include "board-rk3168-86v-camera.c"
+#include <plat/key.h>
+
+static struct rk29_keys_button key_button[] = {
+	{
+		.desc	= "play",
+		.code	= KEY_POWER,
+		.gpio	= RK30_PIN0_PA4, 
+		.active_low = PRESS_LEV_LOW,
+		.wakeup	= 1,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_BACK,
+		.adc_value	= 1,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+};
+struct rk29_keys_platform_data rk29_keys_pdata = {
+	.buttons	= key_button,
+	.nbuttons	= ARRAY_SIZE(key_button),
+	.chn	= 1,  //chn: 0-7, if do not use ADC,set 'chn' -1
+};
+
+#if defined(CONFIG_CT36X_TS)
+
+#define TOUCH_MODEL		363
+#define TOUCH_MAX_X		1280
+#define TOUCH_MAX_y		800
+#define TOUCH_RESET_PIN		RK30_PIN0_PB6
+#define TOUCH_INT_PIN		RK30_PIN1_PB7
+
+static struct ct36x_platform_data ct36x_info = {
+	.model   = TOUCH_MODEL,
+	.x_max   = TOUCH_MAX_X,
+	.y_max   = TOUCH_MAX_y,
+
+	.rst_io = {
+		.gpio = TOUCH_RESET_PIN,
+		.active_low = 1,
+	},
+	.irq_io = {
+		.gpio = TOUCH_INT_PIN,
+		.active_low = 1,
+	},
+	.orientation = {1, 0, 1, 0},
+};
+#endif
+#if defined (CONFIG_TOUCHSCREEN_86V_GT811_IIC)
+#define TOUCH_RESET_PIN  RK30_PIN0_PB6
+#define TOUCH_INT_PIN    RK30_PIN1_PB7
+int gt811_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("gt811_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("gt811_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    //gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+       mdelay(100);
+
+    return 0;
+}
+
+
+static struct goodix_platform_data gt811_info = {
+  .model= 811,
+  .init_platform_hw= gt811_init_platform_hw,
+
+};
+#endif
+static struct spi_board_info board_spi_devices[] = {
+};
+
+/***********************************************************
+*	rk30  backlight
+************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+#define PWM_ID            3
+#define PWM_MODE	  PWM3
+#define PWM_EFFECT_VALUE 0// 1
+
+#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+#define BL_EN_PIN         RK30_PIN0_PA2
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+	int ret = 0;
+
+	iomux_set(PWM_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	ret = gpio_request(BL_EN_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(BL_EN_PIN);
+	}
+
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+
+	return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+	int ret = 0, pwm_gpio;
+
+#ifdef  LCD_DISP_ON_PIN
+	gpio_free(BL_EN_PIN);
+#endif
+
+	pwm_gpio = iomux_mode_to_gpio(PWM_MODE);
+	gpio_request(pwm_gpio, NULL);
+	gpio_direction_output(pwm_gpio, GPIO_LOW);
+	return ret;
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret = 0, pwm_gpio;
+
+	pwm_gpio = iomux_mode_to_gpio(PWM_MODE);
+	if (gpio_request(pwm_gpio, NULL)) {
+		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	gpio_direction_output(pwm_gpio, GPIO_LOW);
+#ifdef  LCD_DISP_ON_PIN
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	int pwm_gpio = iomux_mode_to_gpio(PWM_MODE);
+
+	gpio_free(pwm_gpio);
+	iomux_set(PWM_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	msleep(30);
+	gpio_direction_output(BL_EN_PIN, 1);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return 0;
+}
+
+static struct rk29_bl_info rk29_bl_info = {
+        .min_brightness = 30,
+	.pre_div = 20 * 1000,  // pwm output clk: 20k;
+	.pwm_id = PWM_ID,
+	.bl_ref = PWM_EFFECT_VALUE,
+	.io_init = rk29_backlight_io_init,
+	.io_deinit = rk29_backlight_io_deinit,
+	.pwm_suspend = rk29_backlight_pwm_suspend,
+	.pwm_resume = rk29_backlight_pwm_resume,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+
+#endif
+
+/*MMA8452 gsensor*/
+#if defined (CONFIG_GS_MMA8452)
+#define MMA8452_INT_PIN   RK30_PIN0_PB7
+
+static int mma8452_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data mma8452_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma8452_init_platform_hw,
+        .orientation = {-1, 0, 0, 0, 0, 1, 0, 1, 0},
+};
+#endif
+
+/*MMA7660 gsensor*/
+#if defined (CONFIG_GS_MMA7660)
+#define MMA7660_INT_PIN   RK30_PIN0_PB7
+
+static int mma7660_init_platform_hw(void)
+{
+	//rk30_mux_api_set(GPIO1B2_SPI_RXD_UART1_SIN_NAME, GPIO1B_GPIO1B2);
+
+	return 0;
+}
+
+static struct sensor_platform_data mma7660_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+    .init_platform_hw = mma7660_init_platform_hw,
+    .orientation = {0, -1, 0, 0, 0, -1, -1, 0, 0},
+      
+};
+#endif
+
+#if defined (CONFIG_GS_LIS3DH)
+#define LIS3DH_INT_PIN   RK30_PIN0_PB7
+
+static int lis3dh_init_platform_hw(void)
+{
+
+        return 0;
+}
+
+static struct sensor_platform_data lis3dh_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = lis3dh_init_platform_hw,
+	.orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
+};
+#endif
+#if defined (CONFIG_COMPASS_AK8975)
+static struct sensor_platform_data akm8975_info =
+{
+	.type = SENSOR_TYPE_COMPASS,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+	.m_layout = 
+	{
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+	}
+};
+
+#endif
+
+#if defined(CONFIG_GYRO_L3G4200D)
+
+#include <linux/l3g4200d.h>
+#define L3G4200D_INT_PIN  RK30_PIN0_PB4
+
+static int l3g4200d_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data l3g4200d_info = {
+	.type = SENSOR_TYPE_GYROSCOPE,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
+	.init_platform_hw = l3g4200d_init_platform_hw,
+	.x_min = 40,//x_min,y_min,z_min = (0-100) according to hardware
+	.y_min = 40,
+	.z_min = 20,
+};
+
+#endif
+
+#ifdef CONFIG_LS_CM3217
+static struct sensor_platform_data cm3217_info = {
+	.type = SENSOR_TYPE_LIGHT,
+	.irq_enable = 0,
+	.poll_delay_ms = 500,
+};
+
+#endif
+
+#ifdef CONFIG_FB_ROCKCHIP
+
+#define LCD_CS_PIN         INVALID_GPIO
+#define LCD_CS_VALUE       GPIO_HIGH
+
+#define LCD_EN_PIN         RK30_PIN0_PB0
+#define LCD_EN_VALUE       GPIO_LOW
+
+#define  LCD_STBYB_RXD_MODE        SPI1_RXD
+
+
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+	int ret = 0;
+	int stbyb_gpio;
+
+	if(LCD_CS_PIN !=INVALID_GPIO)
+	{
+		ret = gpio_request(LCD_CS_PIN, NULL);
+		if (ret != 0)
+		{
+			gpio_free(LCD_CS_PIN);
+			printk(KERN_ERR "request lcd cs pin fail!\n");
+			return -1;
+		}
+		else
+		{
+			gpio_direction_output(LCD_CS_PIN, LCD_CS_VALUE);
+		}
+	}
+
+	if(LCD_EN_PIN !=INVALID_GPIO)
+	{
+		ret = gpio_request(LCD_EN_PIN, NULL);
+		if (ret != 0)
+		{
+			gpio_free(LCD_EN_PIN);
+			printk(KERN_ERR "request lcd en pin fail!\n");
+			return -1;
+		}
+		else
+		{
+			gpio_direction_output(LCD_EN_PIN, LCD_EN_VALUE);
+		}
+	}
+
+	stbyb_gpio = iomux_mode_to_gpio(LCD_STBYB_RXD_MODE);
+	gpio_request(stbyb_gpio, "stbyb");
+	gpio_direction_output(stbyb_gpio, GPIO_HIGH);
+	gpio_set_value(stbyb_gpio,GPIO_HIGH);
+	
+	return 0;
+}
+static int rk_fb_io_disable(void)
+{
+	if(LCD_CS_PIN !=INVALID_GPIO)
+	{
+		gpio_set_value(LCD_CS_PIN, !LCD_CS_VALUE);
+	}
+	if(LCD_EN_PIN !=INVALID_GPIO)
+	{
+		gpio_set_value(LCD_EN_PIN, !LCD_EN_VALUE);
+	}
+	return 0;
+}
+static int rk_fb_io_enable(void)
+{
+	if(LCD_CS_PIN !=INVALID_GPIO)
+	{
+		gpio_set_value(LCD_CS_PIN, LCD_CS_VALUE);
+	}
+	if(LCD_EN_PIN !=INVALID_GPIO)
+	{
+		gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+	}
+	return 0;
+}
+
+#if defined(CONFIG_LCDC0_RK3066B)
+struct rk29fb_info lcdc0_screen_info = {
+	.prop	   = EXTEND,		//primary display device
+	.io_init   = NULL,
+	.io_disable = NULL,
+	.io_enable = NULL,
+	.set_screen_info = NULL,
+};
+#endif
+
+#if defined(CONFIG_LCDC1_RK3066B)
+struct rk29fb_info lcdc1_screen_info = {
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+	
+};
+#endif
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+};
+#endif
+
+#if defined(CONFIG_LCDC0_RK3066B)
+static struct resource resource_lcdc0[] = {
+	[0] = {
+		.name  = "lcdc0 reg",
+		.start = RK30_LCDC0_PHYS,
+		.end   = RK30_LCDC0_PHYS + RK30_LCDC0_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	
+	[1] = {
+		.name  = "lcdc0 irq",
+		.start = IRQ_LCDC0,
+		.end   = IRQ_LCDC0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc0 = {
+	.name		  = "rk30-lcdc",
+	.id		  = 0,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc0),
+	.resource	  = resource_lcdc0,
+	.dev 		= {
+		.platform_data = &lcdc0_screen_info,
+	},
+};
+#endif
+#if defined(CONFIG_LCDC1_RK3066B) 
+static struct resource resource_lcdc1[] = {
+	[0] = {
+		.name  = "lcdc1 reg",
+		.start = RK30_LCDC1_PHYS,
+		.end   = RK30_LCDC1_PHYS + RK30_LCDC1_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "lcdc1 irq",
+		.start = IRQ_LCDC1,
+		.end   = IRQ_LCDC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc1 = {
+	.name		  = "rk30-lcdc",
+	.id		  = 1,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc1),
+	.resource	  = resource_lcdc1,
+	.dev 		= {
+		.platform_data = &lcdc1_screen_info,
+	},
+};
+#endif
+
+#if defined(CONFIG_MFD_RK610)
+#define RK610_RST_PIN 			RK30_PIN3_PB2
+static int rk610_power_on_init(void)
+{
+	int ret;
+	if(RK610_RST_PIN != INVALID_GPIO)
+	{
+		ret = gpio_request(RK610_RST_PIN, "rk610 reset");
+		if (ret)
+		{
+			printk(KERN_ERR "rk610_control_probe request gpio fail\n");
+		}
+		else 
+		{
+			gpio_direction_output(RK610_RST_PIN, GPIO_HIGH);
+			msleep(100);
+			gpio_direction_output(RK610_RST_PIN, GPIO_LOW);
+			msleep(100);
+	    		gpio_set_value(RK610_RST_PIN, GPIO_HIGH);
+		}
+	}
+
+	return 0;
+	
+}
+
+
+static struct rk610_ctl_platform_data rk610_ctl_pdata = {
+	.rk610_power_on_init = rk610_power_on_init,
+};
+#endif
+
+#ifdef CONFIG_SND_SOC_RK610
+static int rk610_codec_io_init(void)
+{
+//if need iomux.
+//Must not gpio_request
+	return 0;
+}
+
+static struct rk610_codec_platform_data rk610_codec_pdata = {
+	.spk_ctl_io = RK30_PIN2_PD7,
+	.io_init = rk610_codec_io_init,
+	.boot_depop = 1,
+};
+#endif
+
+#ifdef CONFIG_ION
+#define ION_RESERVE_SIZE        (80 * SZ_1M)
+static struct ion_platform_data rk30_ion_pdata = {
+	.nr = 1,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = ION_NOR_HEAP_ID,
+			.name = "norheap",
+			.size = ION_RESERVE_SIZE,
+		}
+	},
+};
+
+static struct platform_device device_ion = {
+	.name = "ion-rockchip",
+	.id = 0,
+	.dev = {
+		.platform_data = &rk30_ion_pdata,
+	},
+};
+#endif
+
+/**************************************************************************************************
+ * SDMMC devices,  include the module of SD,MMC,and sdio.noted by xbw at 2012-03-05
+**************************************************************************************************/
+#ifdef CONFIG_SDMMC_RK29
+#include "board-rk3168-ds1006h-sdmmc-config.c"
+#include "../plat-rk/rk-sdmmc-ops.c"
+#include "../plat-rk/rk-sdmmc-wifi.c"
+#endif //endif ---#ifdef CONFIG_SDMMC_RK29
+
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+#ifdef CONFIG_SDMMC_RK29_OLD
+	iomux_set(MMC0_CMD);
+	iomux_set(MMC0_CLKOUT);
+	iomux_set(MMC0_D0);
+	iomux_set(MMC0_D1);
+	iomux_set(MMC0_D2);
+	iomux_set(MMC0_D3);
+
+	iomux_set_gpio_mode(iomux_mode_to_gpio(MMC0_DETN));
+
+	gpio_request(RK30_PIN3_PA7, "sdmmc-power");
+	gpio_direction_output(RK30_PIN3_PA7, GPIO_LOW);
+
+#else
+	rk29_sdmmc_set_iomux(0, 0xFFFF);
+
+    #if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+        #if SDMMC_USE_NEW_IOMUX_API
+        iomux_set_gpio_mode(iomux_gpio_to_mode(RK29SDK_SD_CARD_DETECT_N));
+        #else
+        rk30_mux_api_set(RK29SDK_SD_CARD_DETECT_PIN_NAME, RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO);
+        #endif
+    #else
+        #if SDMMC_USE_NEW_IOMUX_API       
+        iomux_set(MMC0_DETN);
+        #else
+        rk30_mux_api_set(RK29SDK_SD_CARD_DETECT_PIN_NAME, RK29SDK_SD_CARD_DETECT_IOMUX_FMUX);
+        #endif
+    #endif	
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
+	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC) && defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+    .status = rk29sdk_wifi_mmc0_status,
+    .register_status_notify = rk29sdk_wifi_mmc0_status_register,
+#endif
+
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+    .power_en = RK29SDK_SD_CARD_PWR_EN,
+    .power_en_level = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+#else
+    .power_en = INVALID_GPIO,
+    .power_en_level = GPIO_LOW,
+#endif    
+	.enable_sd_wakeup = 0,
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
+	.write_prt_enalbe_level = SDMMC0_WRITE_PROTECT_ENABLE_VALUE;
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+    .det_pin_info = {    
+    #if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N, //INVALID_GPIO,
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+    #else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+    #endif    
+    }, 
+
+};
+#endif // CONFIG_SDMMC0_RK29
+
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+#if defined(CONFIG_SDMMC_RK29_OLD)
+	iomux_set(MMC1_CMD);
+	iomux_set(MMC1_CLKOUT);
+	iomux_set(MMC1_D0);
+	iomux_set(MMC1_D1);
+	iomux_set(MMC1_D2);
+	iomux_set(MMC1_D3);
+#else
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
+	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34),
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
+		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#else
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#endif
+
+	.io_init = rk29_sdmmc1_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC) || defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+    .status = rk29sdk_wifi_status,
+    .register_status_notify = rk29sdk_wifi_status_register,
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
+	    .write_prt_enalbe_level = SDMMC1_WRITE_PROTECT_ENABLE_VALUE;
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+    #if defined(CONFIG_RK29_SDIO_IRQ_FROM_GPIO)
+        .sdio_INT_gpio = RK29SDK_WIFI_SDIO_CARD_INT,
+    #endif
+
+    .det_pin_info = {    
+#if defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+     #if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        .io             = RK29SDK_SD_CARD_DETECT_N,
+     #else
+         .io             = INVALID_GPIO,
+     #endif   
+
+        .enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+        #ifdef RK29SDK_SD_CARD_DETECT_PIN_NAME
+        .iomux          = {
+            .name       = RK29SDK_SD_CARD_DETECT_PIN_NAME,
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO
+            .fgpio      = RK29SDK_SD_CARD_DETECT_IOMUX_FGPIO,
+            #endif
+            #ifdef RK29SDK_SD_CARD_DETECT_IOMUX_FMUX
+            .fmux       = RK29SDK_SD_CARD_DETECT_IOMUX_FMUX,
+            #endif
+        },
+        #endif
+ #else
+        .io             = INVALID_GPIO,
+        .enable         = GPIO_LOW,
+#endif
+    },
+   
+	.enable_sd_wakeup = 0,
+};
+#endif //endif--#ifdef CONFIG_SDMMC1_RK29
+
+/**************************************************************************************************
+ * the end of setting for SDMMC devices
+**************************************************************************************************/
+
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
+        .dc_det_pin      = RK30_PIN0_PB2,
+        .batt_low_pin    = INVALID_GPIO, 
+        .charge_set_pin  = INVALID_GPIO,
+        .charge_ok_pin   = RK30_PIN0_PA6,
+	 .usb_det_pin = INVALID_GPIO,
+        .dc_det_level    = GPIO_LOW,
+        .charge_ok_level = GPIO_HIGH,
+
+	.reference_voltage = 1800, // the rK2928 is 3300;RK3066 and rk29 are 2500;rk3066B is 1800;
+       .pull_up_res = 200,     //divider resistance ,  pull-up resistor
+       .pull_down_res = 120, //divider resistance , pull-down resistor
+
+	.is_reboot_charging = 1,
+        .save_capacity   = 1 ,
+        .low_voltage_protection = 3600,    
+};
+
+static struct platform_device rk30_device_adc_battery = {
+        .name   = "rk30-battery",
+        .id     = -1,
+        .dev = {
+                .platform_data = &rk30_adc_battery_platdata,
+        },
+};
+#endif
+#ifdef CONFIG_RK30_PWM_REGULATOR
+static int pwm_voltage_map[] = {
+	950000, 975000,1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
+};
+
+static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
+	{
+		.supply = "vdd_cpu",
+	}
+};
+
+struct regulator_init_data pwm_regulator_init_dcdc[1] =
+{
+	{
+		.constraints = {
+			.name = "PWM_DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
+		.consumer_supplies = pwm_dcdc1_consumers,
+	},
+};
+
+static struct pwm_platform_data pwm_regulator_info[1] = {
+	{
+		.pwm_id = 1,
+		.pwm_gpio = RK30_PIN3_PD4,
+		.pwm_iomux_pwm = PWM1,
+		.pwm_iomux_gpio = GPIO3_D4,
+		.pwm_voltage = 1100000,
+		.suspend_voltage = 1050000,
+		.min_uV = 950000,
+		.max_uV	= 1400000,
+		.coefficient = 455,	//45.5%
+		.pwm_voltage_map = pwm_voltage_map,
+		.init_data	= &pwm_regulator_init_dcdc[0],
+	},
+};
+
+struct platform_device pwm_regulator_device[1] = {
+	{
+		.name = "pwm-voltage-regulator",
+		.id = 0,
+		.dev		= {
+			.platform_data = &pwm_regulator_info[0],
+		}
+	},
+};
+#endif
+
+#ifdef CONFIG_RFKILL_RK
+// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
+static struct rfkill_rk_platform_data rfkill_rk_platdata = {
+    .type               = RFKILL_TYPE_BLUETOOTH,
+
+    .poweron_gpio       = { // BT_REG_ON
+        .io             = INVALID_GPIO, //RK30_PIN3_PC7,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = "bt_poweron",
+            .fgpio      = GPIO3_C7,
+        },
+    },
+
+    .reset_gpio         = { // BT_RST
+        .io             = RK30_PIN3_PD1, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name       = "bt_reset",
+            .fgpio      = GPIO3_D1,
+       },
+   }, 
+
+    .wake_gpio          = { // BT_WAKE, use to control bt's sleep and wakeup
+        .io             = RK30_PIN3_PC6, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = "bt_wake",
+            .fgpio      = GPIO3_C6,
+        },
+    },
+
+    .wake_host_irq      = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
+        .gpio           = {
+            .io         = RK30_PIN0_PA5, // set io to INVALID_GPIO for disable it
+            .enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
+            .iomux      = {
+                .name   = NULL,
+            },
+        },
+    },
+
+    .rts_gpio           = { // UART_RTS, enable or disable BT's data coming
+        .io             = RK30_PIN1_PA3, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name       = "bt_rts",
+            .fgpio      = GPIO1_A3,
+            .fmux       = UART0_RTSN,
+        },
+    },
+};
+
+static struct platform_device device_rfkill_rk = {
+    .name   = "rfkill_rk",
+    .id     = -1,
+    .dev    = {
+        .platform_data = &rfkill_rk_platdata,
+    },
+};
+#endif
+
+#if defined(CONFIG_GPS_RK)
+int rk_gps_io_init(void)
+{
+	printk("%s \n", __FUNCTION__);
+	
+	rk30_mux_api_set(GPIO1B5_UART3RTSN_NAME, GPIO1B_GPIO1B5);//VCC_EN
+	gpio_request(RK30_PIN1_PB5, NULL);
+	gpio_direction_output(RK30_PIN1_PB5, GPIO_LOW);
+
+	rk30_mux_api_set(GPIO1B4_UART3CTSN_GPSRFCLK_NAME, GPIO1B_GPSRFCLK);//GPS_CLK
+	rk30_mux_api_set(GPIO1B2_UART3SIN_GPSMAG_NAME, GPIO1B_GPSMAG);//GPS_MAG
+	rk30_mux_api_set(GPIO1B3_UART3SOUT_GPSSIG_NAME, GPIO1B_GPSSIG);//GPS_SIGN
+
+	rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0CLK_NAME, GPIO1A_GPIO1A6);//SPI_CLK
+	gpio_request(RK30_PIN1_PA6, NULL);
+	gpio_direction_output(RK30_PIN1_PA6, GPIO_LOW);
+
+	rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0TXD_NAME, GPIO1A_GPIO1A5);//SPI_MOSI
+	gpio_request(RK30_PIN1_PA5, NULL);
+	gpio_direction_output(RK30_PIN1_PA5, GPIO_LOW);	
+
+	rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0CSN0_NAME, GPIO1A_GPIO1A7);//SPI_CS
+	gpio_request(RK30_PIN1_PA7, NULL);
+	gpio_direction_output(RK30_PIN1_PA7, GPIO_LOW);		
+	return 0;
+}
+int rk_gps_power_up(void)
+{
+	printk("%s \n", __FUNCTION__);
+
+	return 0;
+}
+
+int rk_gps_power_down(void)
+{
+	printk("%s \n", __FUNCTION__);
+
+	return 0;
+}
+
+int rk_gps_reset_set(int level)
+{
+	return 0;
+}
+int rk_enable_hclk_gps(void)
+{
+	printk("%s \n", __FUNCTION__);
+	clk_enable(clk_get(NULL, "hclk_gps"));
+	return 0;
+}
+int rk_disable_hclk_gps(void)
+{
+	printk("%s \n", __FUNCTION__);
+	clk_disable(clk_get(NULL, "hclk_gps"));
+	return 0;
+}
+struct rk_gps_data rk_gps_info = {
+	.io_init = rk_gps_io_init,
+	.power_up = rk_gps_power_up,
+	.power_down = rk_gps_power_down,
+	.reset = rk_gps_reset_set,
+	.enable_hclk_gps = rk_enable_hclk_gps,
+	.disable_hclk_gps = rk_disable_hclk_gps,
+	.GpsSign = RK30_PIN1_PB3,
+	.GpsMag = RK30_PIN1_PB2,        //GPIO index
+	.GpsClk = RK30_PIN1_PB4,        //GPIO index
+	.GpsVCCEn = RK30_PIN1_PB5,     //GPIO index
+	.GpsSpi_CSO = RK30_PIN1_PA4,    //GPIO index
+	.GpsSpiClk = RK30_PIN1_PA5,     //GPIO index
+	.GpsSpiMOSI = RK30_PIN1_PA7,	  //GPIO index
+	.GpsIrq = IRQ_GPS,
+	.GpsSpiEn = 0,
+	.GpsAdcCh = 2,
+	.u32GpsPhyAddr = RK30_GPS_PHYS,
+	.u32GpsPhySize = RK30_GPS_SIZE,
+};
+
+struct platform_device rk_device_gps = {
+	.name = "gps_hv5820b",
+	.id = -1,
+	.dev		= {
+	.platform_data = &rk_gps_info,
+		}
+	};
+#endif
+
+#if defined(CONFIG_MT5931_MT6622)
+static struct mt6622_platform_data mt6622_platdata = {
+		    .power_gpio         = { // BT_REG_ON
+		    	.io             = RK30_PIN3_PD5, // set io to INVALID_GPIO for disable it
+			    .enable         = GPIO_HIGH,
+			    .iomux          = {
+				    .name       = NULL,
+				},
+		    },
+
+		    .reset_gpio         = { // BT_RST
+		        .io             = RK30_PIN0_PD7,
+		        .enable         = GPIO_HIGH,
+		        .iomux          = {
+		            .name       = NULL,
+		        },
+		    },
+
+		    .irq_gpio           = {
+			    .io             = RK30_PIN3_PD2,
+			    .enable         = GPIO_HIGH,
+			    .iomux          = {
+				    .name       = NULL,
+				},
+		    }
+};
+
+static struct platform_device device_mt6622 = {
+		    .name   = "mt6622",
+			.id     = -1,
+			.dev    = {
+			       .platform_data = &mt6622_platdata,
+			},
+};	
+#endif
+
+static struct platform_device *devices[] __initdata = {
+
+#ifdef CONFIG_ION
+	&device_ion,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	&rk29sdk_wifi_device,
+#endif
+
+#if defined(CONFIG_MT6620)
+	    &mt3326_device_gps,
+#endif
+
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+ 	&rk30_device_adc_battery,
+#endif
+#ifdef CONFIG_RFKILL_RK
+	&device_rfkill_rk,
+#endif
+#ifdef CONFIG_GPS_RK
+	&rk_device_gps,
+#endif
+#ifdef CONFIG_MT5931_MT6622
+	&device_mt6622,
+#endif
+};
+
+
+static int rk_platform_add_display_devices(void)
+{
+	struct platform_device *fb = NULL;  //fb
+	struct platform_device *lcdc0 = NULL; //lcdc0
+	struct platform_device *lcdc1 = NULL; //lcdc1
+	struct platform_device *bl = NULL; //backlight
+#ifdef CONFIG_FB_ROCKCHIP
+	fb = &device_fb;
+#endif
+
+#if defined(CONFIG_LCDC0_RK3066B)
+	lcdc0 = &device_lcdc0,
+#endif
+
+#if defined(CONFIG_LCDC1_RK3066B)
+	lcdc1 = &device_lcdc1,
+#endif
+
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	bl = &rk29_device_backlight,
+#endif
+	__rk_platform_add_display_devices(fb,lcdc0,lcdc1,bl);
+
+	return 0;
+	
+}
+
+// i2c
+#ifdef CONFIG_I2C0_RK30
+static struct i2c_board_info __initdata i2c0_info[] = {
+#if defined (CONFIG_GS_MMA7660)
+	{
+		.type	        = "gs_mma7660",//gs_mma7660
+		.addr	        = 0x4c,
+		.flags	        = 0,
+		.irq	        = MMA7660_INT_PIN,
+		.platform_data = &mma7660_info,
+	},
+#endif
+#if defined (CONFIG_GS_MMA8452)
+	{
+		.type	        = "gs_mma8452",
+		.addr	        = 0x1d,
+		.flags	        = 0,
+		.irq	        = MMA8452_INT_PIN,
+		.platform_data = &mma8452_info,
+	},
+#endif
+#if defined (CONFIG_GS_LIS3DH)
+	{
+		.type	        = "gs_lis3dh",
+		.addr	        = 0x19,   //0x19(SA0-->VCC), 0x18(SA0-->GND)
+		.flags	        = 0,
+		.irq	        = LIS3DH_INT_PIN,
+		.platform_data = &lis3dh_info,
+	},
+#endif
+#if defined (CONFIG_COMPASS_AK8975)
+	{
+		.type          = "ak8975",
+		.addr          = 0x0d,
+		.flags         = 0,
+		.irq           = RK30_PIN3_PD7,	
+		.platform_data = &akm8975_info,
+		.irq           = RK30_PIN3_PD7,	
+		.platform_data = &akm8975_info,
+	},
+#endif
+#if defined (CONFIG_GYRO_L3G4200D)
+	{
+		.type          = "l3g4200d_gryo",
+		.addr          = 0x69,
+		.flags         = 0,
+		.irq           = L3G4200D_INT_PIN,
+		.platform_data = &l3g4200d_info,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_RK1000)
+	{
+		.type          = "rk1000_i2c_codec",
+		.addr          = 0x60,
+		.flags         = 0,
+	},
+	{
+		.type          = "rk1000_control",
+		.addr          = 0x40,
+		.flags         = 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_RT5631)
+        {
+                .type                   = "rt5631",
+                .addr                   = 0x1a,
+                .flags                  = 0,
+        },
+#endif
+};
+#endif
+
+int __sramdata g_pmic_type =  0;
+#ifdef CONFIG_I2C1_RK30
+#ifdef CONFIG_REGULATOR_ACT8846
+#define PMU_POWER_SLEEP RK30_PIN0_PA1
+#define ACT8846_HOST_IRQ                RK30_PIN0_PB3
+
+static struct pmu_info  act8846_dcdc_info[] = {
+	{
+		.name          = "act_dcdc1",   //ddr
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+		.suspend_vol  =   1200000,
+	},
+	{
+		.name          = "vdd_core",    //logic
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  900000,
+	},
+	{
+		.name          = "vdd_cpu",   //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  900000,
+	},
+	{
+		.name          = "act_dcdc4",   //vccio
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+		.suspend_vol  =  2800000,
+	},
+	
+};
+static  struct pmu_info  act8846_ldo_info[] = {
+	{
+		.name          = "act_ldo1",   //vdd10
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "act_ldo2",    //vdd12
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+	},
+	{
+		.name          = "act_ldo3",   //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "act_ldo4",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "act_ldo5",   //vcctp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "act_ldo6",   //vcc_jetta
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "act_ldo7",   //vcc18
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "act_ldo8",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+	},
+ };
+
+#include "board-pmu-act8846.c"
+#endif
+
+#ifdef CONFIG_MFD_WM831X_I2C
+#define PMU_POWER_SLEEP 		RK30_PIN0_PA1 
+
+static struct pmu_info  wm8326_dcdc_info[] = {
+	{
+		.name          = "vdd_core",   //logic
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "vdd_cpu",    //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "dcdc3",   //ddr
+		.min_uv          = 1150000,
+		.max_uv         = 1150000,
+		.suspend_vol  =  1150000,
+	},
+	#ifdef CONFIG_MACH_RK3066_SDK
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3000000,
+	},
+	#else
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+		.suspend_vol  =  2800000,
+	},
+	#endif
+};
+
+static struct pmu_info  wm8326_ldo_info[] = {
+	{
+		.name          = "ldo1",   //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo2",    //vccio_wl
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo3",   //
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+		.suspend_vol  =  1100000,
+	},
+	{
+		.name          = "ldo4",   //vdd11
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  1000000,
+	},
+	{
+		.name          = "ldo5",   //vcc25
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo6",   //vcc33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo7",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+		.suspend_vol  =  2800000,
+	},
+	{
+		.name          = "ldo8",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo9",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo10",   //flash_io
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+};
+
+#include "board-pmu-wm8326.c"
+#endif
+
+#ifdef CONFIG_MFD_TPS65910
+#ifdef CONFIG_ARCH_RK3066B
+#define TPS65910_HOST_IRQ        RK30_PIN0_PB3
+#else
+#define TPS65910_HOST_IRQ        RK30_PIN6_PA4
+#endif
+
+#define PMU_POWER_SLEEP RK30_PIN0_PA1
+
+static struct pmu_info  tps65910_dcdc_info[] = {
+	{
+		.name          = "vdd_core",   //logic
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+	},
+	{
+		.name          = "vdd2",    //ddr
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+	},
+	{
+		.name          = "vio",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	
+};
+static  struct pmu_info  tps65910_ldo_info[] = {
+	{
+		.name          = "vpll",   //vdd10
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "vdig1",    //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "vdig2",   //vdd_jetta
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+	},
+	{
+		.name          = "vaux1",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+	},
+	{
+		.name          = "vaux2",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vaux33",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vmmc",   //vcc30
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	{
+		.name          = "vdac",   //vcc18
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+ };
+
+#include "board-pmu-tps65910.c"
+#endif
+
+static struct i2c_board_info __initdata i2c1_info[] = {
+#if defined (CONFIG_REGULATOR_ACT8846)
+	{
+		.type    		= "act8846",
+		.addr           = 0x5a, 
+		.flags			= 0,
+		.irq            = ACT8846_HOST_IRQ,
+		.platform_data=&act8846_data,
+	},
+#endif
+#if defined (CONFIG_RTC_HYM8563)
+	{
+		.type                   = "rtc_hym8563",
+		.addr           = 0x51,
+		.flags                  = 0,
+		.irq            = RK30_PIN0_PB5,
+	},
+#endif
+#if defined (CONFIG_MFD_WM831X_I2C)
+	{
+		.type          = "wm8326",
+		.addr          = 0x34,
+		.flags         = 0,
+		.irq           = RK30_PIN0_PB3,
+		.platform_data = &wm831x_platdata,
+	},
+#endif
+#if defined (CONFIG_MFD_TPS65910)
+	{
+        .type           = "tps65910",
+        .addr           = TPS65910_I2C_ID0,
+        .flags          = 0,
+        .irq            = TPS65910_HOST_IRQ,
+    	.platform_data = &tps65910_data,
+	},
+#endif
+};
+#endif
+
+void __sramfunc board_pmu_suspend(void)
+{      
+        #if defined (CONFIG_REGULATOR_ACT8846)
+       if(pmic_is_act8846())
+       board_pmu_act8846_suspend(); 
+       #endif
+	#if defined (CONFIG_MFD_WM831X_I2C)
+       if(pmic_is_wm8326())
+       board_pmu_wm8326_suspend();
+	#endif
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910())
+       board_pmu_tps65910_suspend(); 
+    #endif   
+}
+
+void __sramfunc board_pmu_resume(void)
+{      
+        #if defined (CONFIG_REGULATOR_ACT8846)
+       if(pmic_is_act8846())
+       board_pmu_act8846_resume(); 
+       #endif
+	#if defined (CONFIG_MFD_WM831X_I2C)
+       if(pmic_is_wm8326())
+       board_pmu_wm8326_resume();
+	#endif
+	#if defined (CONFIG_MFD_TPS65910)
+       if(pmic_is_tps65910())
+       board_pmu_tps65910_resume(); 
+	#endif
+}
+
+ int __sramdata gpio3d6_iomux,gpio3d6_do,gpio3d6_dir,gpio3d6_en;
+
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+ 
+void __sramfunc rk30_pwm_logic_suspend_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+
+//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+	sram_udelay(10000);
+	gpio3d6_iomux = grf_readl(GRF_GPIO3D_IOMUX);
+	gpio3d6_do = grf_readl(GRF_GPIO3H_DO);
+	gpio3d6_dir = grf_readl(GRF_GPIO3H_DIR);
+	gpio3d6_en = grf_readl(GRF_GPIO3H_EN);
+
+	grf_writel((1<<28), GRF_GPIO3D_IOMUX);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_DIR);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_DO);
+	grf_writel((1<<30)|(1<<14), GRF_GPIO3H_EN);
+#endif 
+}
+void __sramfunc rk30_pwm_logic_resume_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	grf_writel((1<<28)|gpio3d6_iomux, GRF_GPIO3D_IOMUX);
+	grf_writel((1<<30)|gpio3d6_en, GRF_GPIO3H_EN);
+	grf_writel((1<<30)|gpio3d6_dir, GRF_GPIO3H_DIR);
+	grf_writel((1<<30)|gpio3d6_do, GRF_GPIO3H_DO);
+	sram_udelay(10000);
+
+#endif
+
+}
+extern void pwm_suspend_voltage(void);
+extern void pwm_resume_voltage(void);
+void  rk30_pwm_suspend_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_suspend_voltage();
+#endif
+}
+void  rk30_pwm_resume_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_resume_voltage();
+#endif
+}
+
+
+#ifdef CONFIG_I2C2_RK30
+static struct i2c_board_info __initdata i2c2_info[] = {
+#if defined (CONFIG_CT36X_TS)
+	{
+		.type	       = CT36X_NAME,
+		.addr          = 0x01,
+		.flags         = 0,
+		.platform_data = &ct36x_info,
+	},
+#endif
+#if defined (CONFIG_LS_CM3217)
+	{
+		.type          = "lightsensor",
+		.addr          = 0x10,
+		.flags         = 0,
+		.platform_data = &cm3217_info,
+	},
+#endif
+#if defined (CONFIG_TOUCHSCREEN_86V_GT811_IIC)	
+{		
+	.type          = "gt811_ts",		
+	.addr          = 0x5d,		
+	.flags         = 0,		
+	.irq           = TOUCH_INT_PIN,		
+	.platform_data = &gt811_info,	
+},
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C3_RK30
+static struct i2c_board_info __initdata i2c3_info[] = {
+};
+#endif
+
+#ifdef CONFIG_I2C4_RK30
+static struct i2c_board_info __initdata i2c4_info[] = {
+#ifdef CONFIG_MFD_RK610
+		{
+			.type			= "rk610_ctl",
+			.addr			= 0x40,
+			.flags			= 0,
+			.platform_data		= &rk610_ctl_pdata,
+		},
+#ifdef CONFIG_RK610_TVOUT
+		{
+			.type			= "rk610_tvout",
+			.addr			= 0x42,
+			.flags			= 0,
+		},
+#endif
+#ifdef CONFIG_HDMI_RK610
+		{
+			.type			= "rk610_hdmi",
+			.addr			= 0x46,
+			.flags			= 0,
+			.irq			= INVALID_GPIO,
+		},
+#endif
+#ifdef CONFIG_SND_SOC_RK610
+		{//RK610_CODEC addr  from 0x60 to 0x80 (0x60~0x80)
+			.type			= "rk610_i2c_codec",
+			.addr			= 0x60,
+			.flags			= 0,
+			.platform_data		= &rk610_codec_pdata,			
+		},
+#endif
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C_GPIO_RK30
+#define I2C_SDA_PIN     INVALID_GPIO// RK30_PIN2_PD6   //set sda_pin here
+#define I2C_SCL_PIN     INVALID_GPIO//RK30_PIN2_PD7   //set scl_pin here
+static int rk30_i2c_io_init(void)
+{
+        //set iomux (gpio) here
+        //rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME, GPIO2D_GPIO2D7);
+        //rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME, GPIO2D_GPIO2D6);
+
+        return 0;
+}
+struct i2c_gpio_platform_data default_i2c_gpio_data = {
+       .sda_pin = I2C_SDA_PIN,
+       .scl_pin = I2C_SCL_PIN,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(100),
+       .bus_num    = 5,
+       .io_init = rk30_i2c_io_init,
+};
+static struct i2c_board_info __initdata i2c_gpio_info[] = {
+};
+#endif
+
+static void __init rk30_i2c_register_board_info(void)
+{
+#ifdef CONFIG_I2C0_RK30
+	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
+#endif
+#ifdef CONFIG_I2C1_RK30
+	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
+#endif
+#ifdef CONFIG_I2C2_RK30
+	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
+#endif
+#ifdef CONFIG_I2C3_RK30
+	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
+#endif
+#ifdef CONFIG_I2C4_RK30
+	i2c_register_board_info(4, i2c4_info, ARRAY_SIZE(i2c4_info));
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+	i2c_register_board_info(5, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
+#endif
+}
+//end of i2c
+
+#define POWER_ON_PIN RK30_PIN0_PA0   //power_hold
+static void rk30_pm_power_off(void)
+{
+	printk(KERN_ERR "rk30_pm_power_off start...\n");
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+#if defined(CONFIG_MFD_WM831X)
+	wm831x_set_bits(Wm831x,WM831X_GPIO_LEVEL,0x0001,0x0000);  //set sys_pwr 0
+	wm831x_device_shutdown(Wm831x);//wm8326 shutdown
+#endif
+#if defined(CONFIG_REGULATOR_ACT8846)
+       if (pmic_is_act8846()) {
+               printk("enter dcdet===========\n");
+               if(gpio_get_value (RK30_PIN0_PB2) == GPIO_LOW)
+               {
+                       printk("enter restart===========\n");
+                       arm_pm_restart(0, NULL);
+               }
+               //act8931_device_shutdown();
+       }
+#endif
+	while (1);
+}
+
+static void __init machine_rk30_board_init(void)
+{
+	//avs_init();
+	gpio_request(POWER_ON_PIN, "poweronpin");
+	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+	
+	pm_power_off = rk30_pm_power_off;
+	
+        gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+
+
+	rk30_i2c_register_board_info();
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	rk_platform_add_display_devices();
+	board_usb_detect_init(RK30_PIN0_PA7);
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	rk29sdk_wifi_bt_gpio_control_init();
+#endif
+
+#if defined(CONFIG_MT6620)
+	    clk_set_rate(clk_get_sys("rk_serial.1", "uart"), 48*1000000);
+#endif
+
+#if defined(CONFIG_MT5931_MT6622)
+		clk_set_rate(clk_get_sys("rk_serial.0", "uart"), 24*1000000);
+#endif		
+}
+
+static void __init rk30_reserve(void)
+{
+#ifdef CONFIG_ION
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+#endif
+
+#ifdef CONFIG_FB_ROCKCHIP
+	resource_fb[0].start = board_mem_reserve_add("fb0 buf", get_fb_size());
+	resource_fb[0].end = resource_fb[0].start + get_fb_size()- 1;
+#if 0
+	resource_fb[1].start = board_mem_reserve_add("ipp buf", RK30_FB0_MEM_SIZE);
+	resource_fb[1].end = resource_fb[1].start + RK30_FB0_MEM_SIZE - 1;
+#endif
+
+#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
+	resource_fb[2].start = board_mem_reserve_add("fb2 buf",get_fb_size());
+	resource_fb[2].end = resource_fb[2].start + get_fb_size() - 1;
+#endif
+#endif
+
+
+#ifdef CONFIG_VIDEO_RK29
+	rk30_camera_request_reserve_mem();
+#endif
+	
+#ifdef CONFIG_GPS_RK
+	//it must be more than 8MB
+	rk_gps_info.u32MemoryPhyAddr = board_mem_reserve_add("gps", SZ_8M);
+#endif
+	board_mem_reserved();
+}
+
+/**
+ * dvfs_cpu_logic_table: table for arm and logic dvfs 
+ * @frequency	: arm frequency
+ * @cpu_volt	: arm voltage depend on frequency
+ * @logic_volt	: logic voltage arm requests depend on frequency
+ * comments	: min arm/logic voltage
+ */
+static struct cpufreq_frequency_table dvfs_arm_table[] = {
+	{.frequency = 312 * 1000,       .index = 850 * 1000},
+	{.frequency = 504 * 1000,       .index = 900 * 1000},
+	{.frequency = 816 * 1000,       .index = 950 * 1000},
+	{.frequency = 1008 * 1000,      .index = 1025 * 1000},
+	{.frequency = 1200 * 1000,      .index = 1100 * 1000},
+	{.frequency = 1416 * 1000,      .index = 1200 * 1000},
+	//{.frequency = 1608 * 1000,      .index = 1300 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{.frequency = 100 * 1000,	.index = 950 * 1000},
+	{.frequency = 200 * 1000,	.index = 975 * 1000},
+	{.frequency = 266 * 1000,	.index = 1000 * 1000},
+	{.frequency = 300 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1100 * 1000},
+	//{.frequency = 600 * 1000,	.index = 1200 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 200 * 1000 + DDR_FREQ_SUSPEND,    .index = 950 * 1000},
+	{.frequency = 300 * 1000 + DDR_FREQ_VIDEO,      .index = 1000 * 1000},
+	{.frequency = 400 * 1000 + DDR_FREQ_NORMAL,     .index = 1100 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+//#define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
+//static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
+//static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
+
+void __init board_clock_init(void)
+{
+	rk30_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
+	//dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "cpu"), dvfs_arm_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
+}
+
+MACHINE_START(RK30, "RK30board")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
+	.fixup		= rk30_fixup,
+	.reserve	= &rk30_reserve,
+	.map_io		= rk30_map_io,
+	.init_irq	= rk30_init_irq,
+	.timer		= &rk30_timer,
+	.init_machine	= machine_rk30_board_init,
+MACHINE_END
diff --git a/drivers/input/touchscreen/86v_gt811_ts.c b/drivers/input/touchscreen/86v_gt811_ts.c
new file mode 100644
index 000000000000..3be338fd29ef
--- /dev/null
+++ b/drivers/input/touchscreen/86v_gt811_ts.c
@@ -0,0 +1,2017 @@
+/* drivers/input/touchscreen/gt811.c
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <mach/gpio.h>
+//#include <plat/gpio-cfg.h>
+//#include <plat/gpio-bank-l.h>
+//#include <plat/gpio-bank-f.h>
+#include <linux/irq.h>
+#include <linux/syscalls.h>
+#include <linux/reboot.h>
+#include <linux/proc_fs.h>
+#include "86v_gt811_ts.h"
+#include "gt811_firmware.h"
+
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/input/mt.h>
+#include <mach/iomux.h>
+
+static struct workqueue_struct *goodix_wq;
+static const char *s3c_ts_name = "gt811_ts";
+//static struct point_queue finger_list;
+struct i2c_client * i2c_connect_client = NULL;
+//EXPORT_SYMBOL(i2c_connect_client);
+static struct proc_dir_entry *goodix_proc_entry;
+static short  goodix_read_version(struct gt811_ts_data *ts);	
+//static int tpd_button(struct gt811_ts_data *ts, unsigned int x, unsigned int y, unsigned int down);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+int  gt811_downloader( struct gt811_ts_data *ts, unsigned char * data);
+#endif
+//used by firmware update CRC
+unsigned int oldcrc32 = 0xFFFFFFFF;
+unsigned int crc32_table[256];
+unsigned int ulPolynomial = 0x04c11db7;
+
+unsigned int raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+#ifdef DEBUG
+int sum = 0;
+int access_count = 0;
+int int_count = 0;
+#endif
+#define HAVE_TOUCH_KEY
+ //#define READ_KEY_VALUE
+ //#define READ_KEY_COOR
+
+#ifdef HAVE_TOUCH_KEY
+    const uint16_t touch_key_array[]={
+                                       KEY_MENU,             //MENU
+                                       KEY_HOMEPAGE,                                    
+                                       KEY_BACK,
+                                       KEY_SEARCH
+                                      };
+#define MAX_KEY_NUM  (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
+#endif
+
+/*******************************************************	
+Function:
+	Read data from the slave
+	Each read operation with two i2c_msg composition, for the first message sent from the machine address,
+	Article 2 reads the address used to send and retrieve data; each message sent before the start signal
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte to read Address
+	buf [1] ~ buf [len]: data buffer
+	len: the length of read data
+return:
+	Execution messages
+*********************************************************/
+/*Function as i2c_master_send */
+static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	int ret=-1;
+	
+	msgs[0].flags=!I2C_M_RD;
+	msgs[0].addr=client->addr;
+	msgs[0].len=2;
+	msgs[0].buf=&buf[0];
+	msgs[0].scl_rate=200000;
+
+	msgs[1].flags=I2C_M_RD;
+	msgs[1].addr=client->addr;
+	msgs[1].len=len-2;
+	msgs[1].buf=&buf[2];
+	msgs[1].scl_rate=200000;
+	
+	ret=i2c_transfer(client->adapter,msgs, 2);
+	return ret;
+}
+
+/*******************************************************	
+Function:
+	Write data to a slave
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte of the write address
+	buf [1] ~ buf [len]: data buffer
+	len: data length
+return:
+	Execution messages
+*******************************************************/
+/*Function as i2c_master_send */
+static int i2c_write_bytes(struct i2c_client *client,uint8_t *data,int len)
+{
+	struct i2c_msg msg;
+	int ret=-1;
+	//
+	msg.flags=!I2C_M_RD;//?	msg.addr=client->addr;
+	msg.len=len;
+	msg.buf=data;	
+	msg.scl_rate=200000;
+    msg.addr=client->addr;
+	
+	ret=i2c_transfer(client->adapter,&msg, 1);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a prefix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_pre_cmd(struct gt811_ts_data *ts)
+{
+	int ret;
+	uint8_t pre_cmd_data[2]={0};	
+	pre_cmd_data[0]=0x0f;
+	pre_cmd_data[1]=0xff;
+	ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a suffix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_end_cmd(struct gt811_ts_data *ts)
+{
+	int ret;
+	uint8_t end_cmd_data[2]={0};	
+	end_cmd_data[0]=0x80;
+	end_cmd_data[1]=0x00;
+	ret=i2c_write_bytes(ts->client,end_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/********************************************************************
+
+*********************************************************************/
+#ifdef COOR_TO_KEY
+static int list_key(s32 x_value, s32 y_value, u8* key)
+{
+	s32 i;
+
+#ifdef AREA_Y
+	if (y_value <= AREA_Y)
+#else
+	if (x_value <= AREA_X)
+#endif
+	{
+		return 0;
+	}
+
+	for (i = 0; i < MAX_KEY_NUM; i++)
+	{
+		if (abs(key_center[i][x] - x_value) < KEY_X 
+		&& abs(key_center[i][y] - y_value) < KEY_Y)
+		{
+			(*key) |= (0x01<<i);
+        	}
+   	 }
+
+    return 1;
+}
+#endif 
+
+/*******************************************************
+Function:
+	Guitar initialization function, used to send configuration information, access to version information
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int goodix_init_panel(struct gt811_ts_data *ts)
+{
+	short ret=-1;
+	uint8_t config_info[] = {
+	0x06,0xA2,
+/*
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x60,0x00,0x50,0x00,0x40,0x00,
+	0x30,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x70,0x00,0x80,0x00,0x90,0x00,0xA0,0x00,
+	0xB0,0x00,0xC0,0x00,0xD0,0x00,0xE0,0x00,0xF0,0x00,0x05,0x03,0x90,0x90,0x90,0x30,
+	0x30,0x30,0x0F,0x0F,0x0A,0x50,0x3C,0x08,0x03,0x3C,0x05,0x00,0x14,0x00,0x20,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x03,0x19,0x00,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/
+/*	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x13,0x33,0x23,0x33,0x33,0x33,
+	0x43,0x33,0x53,0x33,0x63,0x33,0x73,0x33,0x83,0x33,0x93,0x33,0xA3,0x33,0xB3,0x33,
+	0xC3,0x33,0xD3,0x33,0xE3,0x33,0xF3,0x33,0x03,0x33,0x3B,0x03,0x88,0x88,0x88,0x1B,
+	0x1B,0x1B,0x0F,0x0F,0x0A,0x40,0x30,0x0F,0x03,0x00,0x05,0x00,0x14,0x00,0x1E,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x05,0x19,0x05,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/	
+
+   /* 0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+    0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,0x42,0x22,
+    0x52,0x22,0x62,0x22,0x72,0x22,0x82,0x22,0x92,0x22,
+    0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+    0xF2,0x22,0x1B,0x03,0x88,0x88,0x88,0x1D,0x1D,0x1D,
+    0x10,0x0F,0x0A,0x47,0x2A,0x0D,0x03,0x00,0x05,0x00,
+    0x03,0x00,0x04,0x00,0x00,0x38,0x33,0x35,0x30,0x00,
+    0x00,0x07,0x20,0x05,0x05,0x00,0x00,0x00,0x00,0x00,
+    0x32,0x16,0x80,0x03,0x00,0x40,0x17,0x88,0x1B,0x00,
+    0x71,0x80,0x90,0xA0,0x0A,0x45,0x30,0x20,0x14,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x01*/
+     
+	/* 0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+	 0x52,0x22,0x62,0x22,0x72,0x22,0x82,0x22,0x92,0x22,
+	 0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+	 0xF2,0x22,0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,
+	 0x42,0x22,0x07,0x03,0x88,0x88,0x88,0x27,0x27,0x27,
+	 0x0B,0x0A,0x09,0x40,0x30,0x01,0x03,0x00,0x05,0xE0,
+	 0x01,0x20,0x03,0x00,0x00,0xFF,0xFF,0x42,0x2B,0x00,
+	 0x00,0x23,0x14,0x05,0x06,0x00,0x00,0x00,0x00,0x00,
+	 0x14,0x10,0xC6,0x02,0x00,0x40,0x17,0x88,0x20,0x00,
+	 0x60,0x70,0x80,0x90,0x0D,0x40,0x30,0x25,0x20,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x01*/
+	   0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+	   0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,0x42,0x22,
+	   0x52,0x22,0x62,0x22,0x72,0x22,0x83,0x22,0x92,0x22,
+	   0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+	   0xF2,0x22,0x1B,0x03,0x28,0x28,0x28,0x20,0x20,0x20,
+	   0x0F,0x0F,0x0A,0x45,0x30,0x04,0x03,0x00,0x05,0xE0,
+	   0x01,0x20,0x03,0x00,0x00,0x38,0x33,0x35,0x30,0x00,
+	   0x00,0x26,0x14,0x02,0x0A,0x00,0x00,0x00,0x00,0x00,
+	   0x14,0x10,0x30,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0x00,0x01
+    
+    };
+
+	config_info[62] = TOUCH_MAX_WIDTH >> 8;
+    	config_info[61] = TOUCH_MAX_WIDTH & 0xff;
+    	config_info[64] = TOUCH_MAX_HEIGHT >> 8;
+    	config_info[63] = TOUCH_MAX_HEIGHT & 0xff;
+	
+	ret = i2c_write_bytes(ts->client, config_info, sizeof(config_info)/sizeof(config_info[0]));
+	if(ret < 0)
+	{
+		dev_info(&ts->client->dev, "GT811 Send config failed!\n");
+		return ret;
+	}
+	ts->abs_y_max = (config_info[62]<<8) + config_info[61];
+	ts->abs_x_max = (config_info[64]<<8) + config_info[63];
+	ts->max_touch_num = config_info[60];
+	ts->int_trigger_type = ((config_info[57]>>3)&0x01);
+	dev_info(&ts->client->dev, "GT811 init info:X_MAX=%d,Y_MAX=%d,TRIG_MODE=%s\n",
+	ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type?"RISING EDGE":"FALLING EDGE");
+
+	return 0;
+}
+
+/*******************************************************
+FUNCTION:
+	Read gt811 IC Version
+Argument:
+	ts:	client
+return:
+	0:success
+       -1:error
+*******************************************************/
+static short  goodix_read_version(struct gt811_ts_data *ts)
+{
+	short ret;
+	uint8_t version_data[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+	uint8_t version_data2[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+
+	char i = 0;
+	char cpf = 0;
+	memset(version_data, 0, 5);
+	version_data[0]=0x07;
+	version_data[1]=0x17;	
+
+      	ret=i2c_read_bytes(ts->client, version_data, 4);
+	if (ret < 0) 
+		return ret;
+	
+	for(i = 0;i < 10;i++)
+	{
+		i2c_read_bytes(ts->client, version_data2, 4);
+		if((version_data[2] !=version_data2[2])||(version_data[3] != version_data2[3]))
+		{
+			version_data[2] = version_data2[2];
+			version_data[3] = version_data2[3];
+			msleep(5);
+			break;
+		}
+		msleep(5);
+		cpf++;
+	}
+
+	if(cpf == 10)
+	{
+		ts->version = (version_data[2]<<8)+version_data[3];
+		dev_info(&ts->client->dev, "GT811 Verion:0x%04x\n", ts->version);
+		ret = 0;
+	}
+	else
+	{
+		dev_info(&ts->client->dev," Guitar Version Read Error: %d.%d\n",version_data[3],version_data[2]);
+		ts->version = 0xffff;
+		ret = -1;
+	}
+	
+	return ret;
+	
+}
+/******************start add by kuuga*******************/
+static void gt811_irq_enable(struct gt811_ts_data *ts)
+{	
+	unsigned long irqflags;	
+	spin_lock_irqsave(&ts->irq_lock, irqflags);
+	if (ts->irq_is_disable) 
+	{		
+		enable_irq(ts->irq);		
+		ts->irq_is_disable = 0;	
+	}	
+	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+static void gt811_irq_disable(struct gt811_ts_data *ts)
+{	
+	unsigned long irqflags;
+	spin_lock_irqsave(&ts->irq_lock, irqflags);
+	if (!ts->irq_is_disable) 
+	{		
+		disable_irq_nosync(ts->irq);		
+		ts->irq_is_disable = 1;	
+	}	
+	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+/*****************end add by kuuga****************/
+
+/*******************************************************	
+Function:
+	Touch-screen work function
+	Triggered by the interruption, to accept a set of coordinate data,
+	and then analyze the output parity
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{	
+	uint8_t  point_data[READ_BYTES_NUM] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0};//point_data[8*MAX_FINGER_NUM+2]={ 0 };  
+	uint8_t  check_sum = 0;
+	uint8_t  read_position = 0;
+	uint8_t  track_id[MAX_FINGER_NUM];
+	uint8_t  point_index = 0;
+	uint8_t  point_tmp = 0;
+	uint8_t  point_count = 0;
+	uint16_t input_x = 0;
+	uint16_t input_y = 0;
+	uint8_t  input_w = 0;
+	static uint8_t  last_key = 0;
+	uint8_t  finger = 0;
+	uint8_t  key = 0;
+	unsigned int  count = 0;
+	unsigned int position = 0;	
+	int ret=-1;
+	int tmp = 0;
+	
+	struct gt811_ts_data *ts = container_of(work, struct gt811_ts_data, work);
+#ifdef DEBUG
+    	printk("int count :%d\n", ++int_count);
+   	printk("ready?:%d\n", raw_data_ready);
+#endif     
+    	if (RAW_DATA_ACTIVE == raw_data_ready)
+	{
+	    raw_data_ready = RAW_DATA_READY;
+#ifdef DEBUG	    
+	    printk("ready!\n");
+#endif
+	}
+	
+#ifndef INT_PORT
+COORDINATE_POLL:
+#endif
+	if( tmp > 9) 
+	{
+		dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
+		goto XFER_ERROR ;
+	}
+	
+	ret=i2c_read_bytes(ts->client, point_data, sizeof(point_data)/sizeof(point_data[0]));
+	if(ret <= 0) 
+	{
+       dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
+       ts->bad_data = 1;
+       tmp ++;
+       ts->retry++;
+#ifndef INT_PORT
+       goto COORDINATE_POLL;
+#else   
+       goto XFER_ERROR;
+#endif  
+   }
+#if 0
+	for(count=0;count<(sizeof(point_data)/sizeof(point_data[0])); count++)
+	{
+		printk("[%2d]:0x%2x", count, point_data[count]);
+		if((count+1)%10==0)printk("\n");
+	}
+	printk("\n");
+#endif	
+	if(point_data[2]&0x20)
+	{
+		if(point_data[3]==0xF0)
+		{
+			gpio_direction_output(SHUTDOWN_PORT, 0);
+			msleep(1);
+		//	gpio_direction_input(SHUTDOWN_PORT);
+            gpio_set_value(SHUTDOWN_PORT,0);
+            msleep(100);
+            gpio_set_value(SHUTDOWN_PORT,1);
+            msleep(100);
+
+			goodix_init_panel(ts);
+			goto WORK_FUNC_END;
+		}
+	}
+	switch(point_data[2]& 0x1f)
+	{
+		case 0:
+		case 1:
+			for(count=2; count<9; count++)
+				check_sum += (int)point_data[count];
+			read_position = 9;
+			break;
+		case 2:
+		case 3:
+			for(count=2; count<14;count++)
+				check_sum += (int)point_data[count];
+			read_position = 14;
+			break;	
+		default:		//touch finger larger than 3
+			for(count=2; count<35;count++)
+				check_sum += (int)point_data[count];
+			read_position = 35;
+	}
+	if(check_sum != point_data[read_position])
+	{
+		dev_info(&ts->client->dev, "coor chksum error!\n");
+		goto XFER_ERROR;
+	}
+    
+	point_index = point_data[2]&0x1f;
+	point_tmp = point_index;
+	for(position=0; (position<MAX_FINGER_NUM)&&point_tmp; position++)
+	{
+		if(point_tmp&0x01)
+		{
+			track_id[point_count++] = position;
+		}	
+		point_tmp >>= 1;
+	}	
+	finger = point_count;
+	if(finger)
+	{
+		for(count=0; count<finger; count++)
+		{
+			if(track_id[count]!=3)
+			{
+				if(track_id[count]<3)
+					position = 4+track_id[count]*5;
+				else
+					position = 30;
+				input_x = (uint16_t)(point_data[position]<<8)+(uint16_t)point_data[position+1];
+				input_y = (uint16_t)(point_data[position+2]<<8)+(uint16_t)point_data[position+3];
+				input_w = point_data[position+4];
+			}
+			else
+			{
+				input_x = (uint16_t)(point_data[19]<<8)+(uint16_t)point_data[26];
+        input_y = (uint16_t)(point_data[27]<<8)+(uint16_t)point_data[28];
+        input_w = point_data[29];	
+			}
+			
+		//printk("real_input_y = %d,real_input_y = %d,TOUCH_MAX_HEIGHT=%d,TOUCH_MAX_WIDTH=%d,input_x=%d,input_y=%d,input_w=%d\n",input_x,input_y, TOUCH_MAX_HEIGHT,TOUCH_MAX_WIDTH,input_y,TOUCH_MAX_WIDTH-input_x,  input_w);
+			//if((input_y > ts->abs_x_max)||(TOUCH_MAX_WIDTH-input_x > ts->abs_y_max))continue;
+			input_mt_slot(ts->input_dev, track_id[count]);	
+			//input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+			//printk("DOWN\n")
+; ;
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_y);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, TOUCH_MAX_WIDTH-input_x);			
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+			//input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);
+			//input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, track_id[count]);
+			//input_mt_sync(ts->input_dev);	
+		}
+	}
+	else
+	{
+		for(tmp=0; tmp< MAX_FINGER_NUM; tmp++)
+		{
+		//printk("tmp=%d\n", tmp);
+		input_mt_slot(ts->input_dev, tmp);//?		//input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+		}
+		//input_mt_sync(ts->input_dev);
+	}
+	
+	//input_report_key(ts->input_dev, BTN_TOUCH, finger > 0);
+	input_sync(ts->input_dev);
+
+#ifdef HAVE_TOUCH_KEY
+	key = point_data[3]&0x0F;
+	if((last_key != 0)||(key != 0))
+	{
+		for(count = 0; count < MAX_KEY_NUM; count++)
+		{
+      //printk("####################input_report_key++++++++++++%d\n",key);
+			input_report_key(ts->input_dev, touch_key_array[count], !!(key&(0x01<<count)));	
+		}
+	}		
+	last_key = key;	
+#endif
+
+XFER_ERROR:
+WORK_FUNC_END:
+#ifndef STOP_IRQ_TYPE
+	if(ts->use_irq)
+		gt811_irq_enable(ts);     //KT ADD 1202
+#endif
+}
+
+/*******************************************************	
+Function:
+	Response function timer
+	Triggered by a timer, scheduling the work function of the touch screen operation; after re-timing
+Parameters:
+	timer: the timer function is associated
+return:
+	Timer mode, HRTIMER_NORESTART that do not automatically restart
+********************************************************/
+static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
+{
+	struct gt811_ts_data *ts = container_of(timer, struct gt811_ts_data, timer);
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+/*******************************************************	
+Function:
+	Interrupt response function
+	Triggered by an interrupt, the scheduler runs the touch screen handler
+********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct gt811_ts_data *ts = dev_id;
+	//printk("hjc:%s>>>>>>>>>>>>>>>>>>\n",__func__);
+#ifndef STOP_IRQ_TYPE
+	gt811_irq_disable(ts);     //KT ADD 1202
+#endif
+	//disable_irq_nosync(ts->client->irq);
+	queue_work(goodix_wq, &ts->work);
+	
+	return IRQ_HANDLED;
+}
+
+/*******************************************************	
+Function:
+	Power management gt811, gt811 allowed to sleep or to wake up
+Parameters:
+	on: 0 that enable sleep, wake up 1
+return:
+	Is set successfully, 0 for success
+	Error code: -1 for the i2c error, -2 for the GPIO error;-EINVAL on error as a parameter
+********************************************************/
+static int goodix_ts_power(struct gt811_ts_data * ts, int on)
+{
+	int ret = -1;
+
+	unsigned char i2c_control_buf[3] = {0x06,0x92,0x01};		//suspend cmd
+	
+#ifdef INT_PORT	
+	if(ts != NULL && !ts->use_irq)
+		return -2;
+#endif		
+	switch(on)
+	{
+		case 0:
+			ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
+            printk("ret++++++++++++++++= %d=\n",ret);
+			dev_info(&ts->client->dev, "Send suspend cmd\n");
+			if(ret < 0)						//failed
+				ret = 0;
+			return ret;
+			
+		case 1:
+			gpio_direction_output(SHUTDOWN_PORT,0);
+			msleep(1);
+	    gpio_set_value(SHUTDOWN_PORT,0);
+	    msleep(100);
+	    gpio_set_value(SHUTDOWN_PORT,1);
+	    msleep(100);
+			ret = 0;
+			return ret;
+				
+		default:
+			dev_info(&ts->client->dev, "%s: Cant't support this command.", s3c_ts_name);
+			return -EINVAL;
+	}
+
+}
+/*******************************************************	
+Function:
+	Touch-screen detection function
+	Called when the registration drive (required for a corresponding client);
+	For IO, interrupts and other resources to apply; equipment registration; touch screen initialization, etc.
+Parameters:
+	client: the device structure to be driven
+	id: device ID
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+	int retry=0;
+        char test_data = 1;
+		char buf[2]={0};   //w++
+	unsigned char read_data[2] = {0,0 };        
+	const char irq_table[2] = {IRQF_TRIGGER_FALLING,IRQF_TRIGGER_RISING};
+	struct gt811_ts_data *ts;
+ //   struct gt811_platform_data *811data = client->dev.platform_data;
+	struct gt811_platform_data *pdata;
+	dev_info(&client->dev,"Install gt811 driver.\n");
+	dev_info(&client->dev,"Driver Release Date:2012-02-08\n");	
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+#if 0	
+	ret=i2c_read_bytes(client, read_data, sizeof(read_data)/sizeof(read_data[0]));
+	if(ret <= 0)  
+		{
+	dev_err(&client->dev, "Must have GT811.\n");
+	goto err_check_functionality_failed;	
+		}
+#endif	
+	
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	i2c_connect_client = client;
+	
+	gpio_free(SHUTDOWN_PORT);
+	ret = gpio_request(SHUTDOWN_PORT, "RESET_INT");
+	if (ret < 0)
+        {
+		dev_err(&client->dev, "Failed to request RESET GPIO:%d, ERRNO:%d\n",(int)SHUTDOWN_PORT,ret);
+		goto err_gpio_request;
+	}
+	
+	//rk29_mux_api_set(GPIO0D3_PWM_1_NAME,GPIO0D_GPIO0D3);
+	 gpio_pull_updown(SHUTDOWN_PORT, 1);		//set GPIO pull-up
+	
+	for(retry=0;retry <= 10; retry++)
+	{
+	gpio_direction_output(SHUTDOWN_PORT,0);
+	msleep(1);
+	//		gpio_direction_input(SHUTDOWN_PORT);//setinput means not ack so set the reset high
+	//		msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,1);
+	msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,0);
+	msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,1);
+	msleep(100);
+	int val_ret = 1;
+	val_ret = gpio_get_value(SHUTDOWN_PORT);
+    ret = i2c_write_bytes(client, &test_data, 1);
+	//ret =i2c_master_reg8_recv(client, 0x00, buf, 2, 200*1000);//i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+	if (ret == 1)
+	break;
+	dev_info(&client->dev, "GT811 I2C TEST FAILED!Please check the HARDWARE connect\n");
+	}
+
+	if(ret <= 0)
+	{
+		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
+		goto err_i2c_failed;
+	}	
+
+	INIT_WORK(&ts->work, goodix_ts_work_func);		//init work_struct
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+/////////////////////////////// UPDATE STEP 1 START/////////////////////////////////////////////////////////////////
+#ifdef AUTO_UPDATE_GT811		//modify by andrew
+	msleep(20);
+  goodix_read_version(ts);
+      
+  ret = gt811_downloader( ts, goodix_gt811_firmware);
+  if(ret < 0)
+  {
+          dev_err(&client->dev, "Warnning: gt811 update might be ERROR!\n");
+          //goto err_input_dev_alloc_failed;
+  }
+#endif
+///////////////////////////////UPDATE STEP 1 END////////////////////////////////////////////////////////////////      
+#ifdef INT_PORT	
+	client->irq=TS_INT;		//If not defined in client
+	if (client->irq)
+	{
+		gpio_free(INT_PORT);
+		ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
+        if (ret < 0) 
+		{
+			dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+			goto err_gpio_request_failed;
+		}
+		
+		 gpio_pull_updown(INT_PORT, NULL);	//ret > 0 ?
+		
+	
+	#ifndef STOP_IRQ_TYPE
+		ts->irq = TS_INT;     //KT ADD 1202
+		ts->irq_is_disable = 0;           // enable irq
+	#endif	
+	}
+#endif	
+
+err_gpio_request_failed:
+	for(retry=0; retry<3; retry++)
+	{
+		ret=goodix_init_panel(ts);
+		msleep(2);
+		if(ret != 0)	//Initiall failed
+			continue;
+		else
+			break;
+	}
+	if(ret != 0) 
+	{
+		ts->bad_data=1;
+		goto err_init_godix_ts;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) 
+	{
+		ret = -ENOMEM;
+		dev_dbg(&client->dev,"goodix_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	
+	//ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+	//ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	//////ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+#ifdef HAVE_TOUCH_KEY
+	for(retry = 0; retry < MAX_KEY_NUM; retry++)
+	{
+		input_set_capability(ts->input_dev,EV_KEY,touch_key_array[retry]);	
+	}
+#endif
+/*
+	input_set_abs_params(ts->input_dev, ABS_X, 0,  ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, ts->abs_y_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+*/	
+#ifdef GOODIX_MULTI_TOUCH
+
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	
+	input_mt_init_slots(ts->input_dev, ts->max_touch_num);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, 415, 0, 0);	
+	//printk("\n\nhjc:%s,x_max=%d,y_max=%d\n",__func__,ts->abs_x_max,ts->abs_y_max);
+	
+	
+#endif	
+
+	sprintf(ts->phys, "input/ts");
+	ts->input_dev->name = s3c_ts_name;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;	//screen firmware version
+	
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	ts->bad_data = 0;
+
+#ifdef INT_PORT		
+	ret  = request_irq(TS_INT, goodix_ts_irq_handler ,irq_table[ts->int_trigger_type],
+			client->name, ts);
+	if (ret != 0)
+	{
+		dev_err(&client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+		goto err_init_godix_ts;
+	}
+	else 
+	{	
+	#ifndef STOP_IRQ_TYPE
+		gt811_irq_disable(ts);     //KT ADD 1202
+	//#define
+	//	disable_irq(client->irq);
+	#endif
+		ts->use_irq = 1;
+		dev_dbg(&client->dev,"Reques EIRQ %d succesd on GPIO:%d\n",TS_INT,INT_PORT);
+	}	
+#endif	
+
+	
+	if (!ts->use_irq) 
+	{
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+	
+	if(ts->use_irq)
+	#ifndef STOP_IRQ_TYPE
+		gt811_irq_enable(ts);     //KT ADD 1202
+	//#elif
+	//	enable_irq(client->irq);
+	#endif
+		
+	ts->power = goodix_ts_power;
+
+	goodix_read_version(ts);
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;//EARLY_SUSPEND_LEVEL_BLANK_SCREEN +1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+/////////////////////////////// UPDATE STEP 2 START /////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	goodix_proc_entry = create_proc_entry("goodix-update", 0666, NULL);
+	if(goodix_proc_entry == NULL)
+	{
+		dev_info(&client->dev, "Couldn't create proc entry!\n");
+		ret = -ENOMEM;
+		goto err_create_proc_entry;
+	}
+	else
+	{
+		dev_info(&client->dev, "Create proc entry success!\n");
+		goodix_proc_entry->write_proc = goodix_update_write;
+		goodix_proc_entry->read_proc = goodix_update_read;
+	}
+#endif
+///////////////////////////////UPDATE STEP 2 END /////////////////////////////////////////////////////////////////
+	dev_info(&client->dev,"Start %s in %s mode,Driver Modify Date:2012-01-05\n", 
+		ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+	return 0;
+
+err_init_godix_ts:
+	i2c_end_cmd(ts);
+	if(ts->use_irq)
+	{
+		ts->use_irq = 0;
+		free_irq(client->irq,ts);
+	#ifdef INT_PORT	
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+	#endif	
+	}
+	else 
+		hrtimer_cancel(&ts->timer);
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+	i2c_set_clientdata(client, NULL);
+err_gpio_request:
+	gpio_free(SHUTDOWN_PORT);
+err_i2c_failed:	
+	kfree(ts);	
+err_alloc_data_failed:
+err_check_functionality_failed:
+err_create_proc_entry:
+	return ret;
+}
+
+
+/*******************************************************	
+Function:
+	Drive the release of resources
+Parameters:
+	client: the device structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+/////////////////////////////// UPDATE STEP 3 START/////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	remove_proc_entry("goodix-update", NULL);
+#endif
+/////////////////////////////////UPDATE STEP 3 END///////////////////////////////////////////////////////////////
+
+	if (ts && ts->use_irq) 
+	{
+	#ifdef INT_PORT
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+	#endif	
+		free_irq(client->irq, ts);
+	}	
+	else if(ts)
+		hrtimer_cancel(&ts->timer);
+	
+	dev_notice(&client->dev,"The driver is removing...\n");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+//
+static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+	disable_irq(client->irq);
+	if (ts->power) 
+	{	
+	}
+}
+static int goodix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(ts, 1);
+		printk("resume >>>>>>>>>ret=%d",ret);
+		if (ret < 0)
+		printk(KERN_ERR "goodix_ts_resume power on failed\n");
+	}
+ 	enable_irq(client->irq);
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+	struct gt811_ts_data *ts;
+	ts = container_of(h, struct gt811_ts_data, early_suspend);
+	goodix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+	struct gt811_ts_data *ts;
+	ts = container_of(h, struct gt811_ts_data, early_suspend);
+	goodix_ts_resume(ts->client);
+}
+#endif
+/////////////////////////////// UPDATE STEP 4 START/////////////////////////////////////////////////////////////////
+//******************************Begin of firmware update surpport*******************************
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static struct file * update_file_open(char * path, mm_segment_t * old_fs_p)
+{
+	struct file * filp = NULL;
+	int errno = -1;
+		
+	filp = filp_open(path, O_RDONLY, 0644);
+	
+	if(!filp || IS_ERR(filp))
+	{
+		if(!filp)
+			errno = -ENOENT;
+		else 
+			errno = PTR_ERR(filp);					
+		printk(KERN_ERR "The update file for Guitar open error.\n");
+		return NULL;
+	}
+	*old_fs_p = get_fs();
+	set_fs(get_ds());
+
+	filp->f_op->llseek(filp,0,0);
+	return filp ;
+}
+
+static void update_file_close(struct file * filp, mm_segment_t old_fs)
+{
+	set_fs(old_fs);
+	if(filp)
+		filp_close(filp, NULL);
+}
+static int update_get_flen(char * path)
+{
+	struct file * file_ck = NULL;
+	mm_segment_t old_fs;
+	int length ;
+	
+	file_ck = update_file_open(path, &old_fs);
+	if(file_ck == NULL)
+		return 0;
+
+	length = file_ck->f_op->llseek(file_ck, 0, SEEK_END);
+	//printk("File length: %d\n", length);
+	if(length < 0)
+		length = 0;
+	update_file_close(file_ck, old_fs);
+	return length;	
+}
+
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data)
+{
+	unsigned char cmd[120];
+	int ret = -1;
+        int retry = 0;
+	static unsigned char update_path[60];
+	struct gt811_ts_data *ts;
+	struct file * file_data = NULL;
+    	mm_segment_t old_fs;
+	unsigned char *file_ptr = NULL;
+	unsigned int file_len;
+	
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return 0;
+	}
+	
+	//printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+	if(copy_from_user(&cmd, buff, len))
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return -EFAULT;
+	}
+	//printk(KERN_INFO"Write cmd is:%d,write len is:%ld\n",cmd[0], len);
+	switch(cmd[0])
+	{
+            case APK_UPDATE_TP:
+            printk(KERN_INFO"Write cmd is:%d,cmd arg is:%s,write len is:%ld\n",cmd[0], &cmd[1], len);
+            memset(update_path, 0, 60);
+            strncpy(update_path, cmd+1, 60);
+			
+#ifndef STOP_IRQ_TYPE
+		gt811_irq_disable(ts);     //KT ADD 1202
+//#elif
+//		disable_irq(ts->client->irq);
+#endif
+	file_data = update_file_open(update_path, &old_fs);
+        if(file_data == NULL)   //file_data has been opened at the last time
+        {
+		dev_info(&ts->client->dev, "cannot open update file\n");
+		return 0;
+        }
+
+        file_len = update_get_flen(update_path);
+	dev_info(&ts->client->dev, "Update file length:%d\n", file_len);
+	file_ptr = (unsigned char*)vmalloc(file_len);
+	if(file_ptr==NULL)
+	{
+		dev_info(&ts->client->dev, "cannot malloc memory!\n");
+		return 0;
+	}	
+
+        ret = file_data->f_op->read(file_data, file_ptr, file_len, &file_data->f_pos);
+        if(ret <= 0)
+        {
+		dev_info(&ts->client->dev, "read file data failed\n");
+		return 0;
+        }
+        update_file_close(file_data, old_fs);	
+
+        ret = gt811_downloader(ts, file_ptr);
+        vfree(file_ptr);
+	if(ret < 0)
+        {
+                printk(KERN_INFO"Warnning: GT811 update might be ERROR!\n");
+                return 0;
+        }
+             
+ //       i2c_pre_cmd(ts);
+	
+	gpio_direction_output(SHUTDOWN_PORT, 0);
+        msleep(5);
+        gpio_direction_input(SHUTDOWN_PORT);
+	msleep(20);
+	for(retry=0; retry<3; retry++)
+	{
+		ret=goodix_init_panel(ts);
+		msleep(2);
+		if(ret != 0)	//Initiall failed
+		{
+			dev_info(&ts->client->dev, "Init panel failed!\n");
+			continue;
+		}
+		else
+			break;
+		
+	}
+
+   //     s3c_gpio_cfgpin(INT_PORT, INT_CFG);     //Set IO port function 
+	//gpio_direction_input(INT_PORT);
+//	s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_UP); 
+//        s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port	
+	//s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+//	while(1);		
+#ifndef STOP_IRQ_TYPE
+	gt811_irq_enable(ts);     //KT ADD 1202
+//#elif
+//	enable_irq(ts->client->irq);
+#endif   
+//        i2c_end_cmd(ts);
+        return 1;
+    
+    case APK_READ_FUN:							//functional command
+		if(cmd[1] == CMD_READ_VER)
+		{
+			printk(KERN_INFO"Read version!\n");
+			ts->read_mode = MODE_RD_VER;
+		}
+        else if(cmd[1] == CMD_READ_CFG)
+		{
+			printk(KERN_INFO"Read config info!\n");
+
+			ts->read_mode = MODE_RD_CFG;
+		}
+		else if (cmd[1] == CMD_READ_RAW)
+		{
+		    printk(KERN_INFO"Read raw data!\n");
+
+			ts->read_mode = MODE_RD_RAW;
+		}
+        else if (cmd[1] == CMD_READ_CHIP_TYPE)
+		{
+		    printk(KERN_INFO"Read chip type!\n");
+
+			ts->read_mode = MODE_RD_CHIP_TYPE;
+		}
+        return 1;
+        
+    case APK_WRITE_CFG:			
+		printk(KERN_INFO"Begin write config info!Config length:%d\n",cmd[1]);
+		i2c_pre_cmd(ts);
+        ret = i2c_write_bytes(ts->client, cmd+2, cmd[1]+2); 
+        i2c_end_cmd(ts);
+        if(ret != 1)
+        {
+            printk("Write Config failed!return:%d\n",ret);
+            return -1;
+        }
+        return 1;
+            
+    default:
+	    return 0;
+	}
+	return 0;
+}
+
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int ret = -1;
+    	int len = 0;
+    	int read_times = 0;
+	struct gt811_ts_data *ts;
+
+	unsigned char read_data[360] = {80, };
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+		return 0;
+    
+       	printk("___READ__\n");
+	if(ts->read_mode == MODE_RD_VER)		//read version data
+	{
+		i2c_pre_cmd(ts);
+		ret = goodix_read_version(ts);
+             	i2c_end_cmd(ts);
+		if(ret < 0)
+		{
+			printk(KERN_INFO"Read version data failed!\n");
+			return 0;
+		}
+        
+             	read_data[1] = (char)(ts->version&0xff);
+             	read_data[0] = (char)((ts->version>>8)&0xff);
+
+		memcpy(page, read_data, 2);
+		//*eof = 1;
+		return 2;
+	}
+    else if (ts->read_mode == MODE_RD_CHIP_TYPE)
+    {
+        page[0] = GT811;
+        return 1;
+    }
+    else if(ts->read_mode == MODE_RD_CFG)
+	{
+
+            read_data[0] = 0x06;
+            read_data[1] = 0xa2;       // cfg start address
+            printk("read config addr is:%x,%x\n", read_data[0],read_data[1]);
+
+	     len = 106;
+           i2c_pre_cmd(ts);
+	     ret = i2c_read_bytes(ts->client, read_data, len+2);
+            i2c_end_cmd(ts);
+            if(ret <= 0)
+		{
+			printk(KERN_INFO"Read config info failed!\n");
+			return 0;
+		}
+              
+		memcpy(page, read_data+2, len);
+		return len;
+	}
+	else if (ts->read_mode == MODE_RD_RAW)
+	{
+#define TIMEOUT (-100)
+	    int retry = 0;
+        if (raw_data_ready != RAW_DATA_READY)
+        {
+            raw_data_ready = RAW_DATA_ACTIVE;
+        }
+
+RETRY:
+        read_data[0] = 0x07;
+        read_data[1] = 0x11;
+        read_data[2] = 0x01;
+        
+        ret = i2c_write_bytes(ts->client, read_data, 3);
+        
+#ifdef DEBUG
+        sum += read_times;
+        printk("count :%d\n", ++access_count);
+        printk("A total of try times:%d\n", sum);
+#endif
+               
+        read_times = 0;
+	    while (RAW_DATA_READY != raw_data_ready)
+	    {
+	        msleep(4);
+
+	        if (read_times++ > 10)
+	        {
+    	        if (retry++ > 5)
+    	        {
+    	            return TIMEOUT;
+    	        }
+                goto RETRY;
+	        }
+	    }
+#ifdef DEBUG	    
+        printk("read times:%d\n", read_times);
+#endif	    
+        read_data[0] = 0x08;
+        read_data[1] = 0x80;       // raw data address
+        
+	    len = 160;
+
+	   // msleep(4);
+
+        i2c_pre_cmd(ts);
+	    ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+  //      i2c_end_cmd(ts);
+        
+        if(ret <= 0)
+		{
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+		memcpy(page, read_data+2, len);
+
+		read_data[0] = 0x09;
+        read_data[1] = 0xC0;
+	//	i2c_pre_cmd(ts);
+	    ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+        i2c_end_cmd(ts);
+        
+        if(ret <= 0)
+		{
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+		memcpy(&page[160], read_data+2, len);
+
+#ifdef DEBUG
+//**************
+        for (i = 0; i < 300; i++)
+        {
+            printk("%6x", page[i]);
+
+            if ((i+1) % 10 == 0)
+            {
+                printk("\n");
+            }
+        }
+//********************/  
+#endif
+        raw_data_ready = RAW_DATA_NON_ACTIVE;
+    
+		return (2*len);   
+		
+    }
+	return 0;
+#endif
+}             
+//********************************************************************************************
+static u8  is_equal( u8 *src , u8 *dst , int len )
+{
+    int i;
+
+#if 0    
+    for( i = 0 ; i < len ; i++ )
+    {
+        printk(KERN_INFO"[%02X:%02X]", src[i], dst[i]);
+       if((i+1)%10==0)printk("\n");
+    }
+#endif
+
+    for( i = 0 ; i < len ; i++ )
+    {
+        if ( src[i] != dst[i] )
+        {
+            return 0;
+        }
+    }
+    
+    return 1;
+}
+
+static  u8 gt811_nvram_store( struct gt811_ts_data *ts )
+{
+    int ret;
+    int i;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    //u8 outbuf[3] = {};
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+    
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+    
+    if ( ( inbuf[2] & BIT_NVRAM_LOCK ) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+    
+    inbuf[2] = (1<<BIT_NVRAM_STROE);		//store command
+	    
+    for ( i = 0 ; i < 300 ; i++ )
+    {
+        ret = i2c_write_bytes( ts->client, inbuf, 3 );
+        
+        if ( ret < 0 )
+            break;
+    }
+    
+    return ret;
+}
+
+static u8  gt811_nvram_recall( struct gt811_ts_data *ts )
+{
+    int ret;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+    
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+    
+    if ( ( inbuf[2]&BIT_NVRAM_LOCK) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+    
+    inbuf[2] = ( 1 << BIT_NVRAM_RECALL );		//recall command
+    ret = i2c_write_bytes( ts->client , inbuf, 3);
+    return ret;
+}
+
+static  int gt811_reset( struct gt811_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+    
+    unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    gpio_direction_output(SHUTDOWN_PORT,0);
+    msleep(20);
+    gpio_direction_input(SHUTDOWN_PORT);
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+                if(inbuf[2] == 0x55)
+                {
+			ret =i2c_write_bytes(ts->client, outbuf, 3);
+			msleep(10);
+			break;						
+		}
+	    }			
+	}
+	else
+	{
+		gpio_direction_output(SHUTDOWN_PORT,0);
+		msleep(20);
+		gpio_direction_input(SHUTDOWN_PORT);
+		msleep(20);
+		dev_info(&ts->client->dev, "i2c address failed\n");
+	}	
+		
+    }
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+
+static  int gt811_reset2( struct gt811_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+    
+    //unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    gpio_direction_output(SHUTDOWN_PORT,0);
+    msleep(20);
+    gpio_direction_input(SHUTDOWN_PORT);
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+             //   if(inbuf[2] == 0x55)
+             //       {
+		//	    ret =i2c_write_bytes(ts->client, outbuf, 3);
+		//	    msleep(10);
+			    break;						
+	//		}
+				}			
+			}	
+		
+		}
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+static  int gt811_set_address_2( struct gt811_ts_data *ts )
+{
+    unsigned char inbuf[3] = {0,0,0};
+    int i;
+
+    for ( i = 0 ; i < 12 ; i++ )
+    {
+        if ( i2c_read_bytes( ts->client, inbuf, 3) )
+        {
+            dev_info(&ts->client->dev, "Got response\n");
+            return 1;
+        }
+        dev_info(&ts->client->dev, "wait for retry\n");
+        msleep(50);
+    } 
+    return 0;
+}
+static u8  gt811_update_firmware( u8 *nvram, u16 start_addr, u16 length, struct gt811_ts_data *ts)
+{
+    u8 ret,err,retry_time,i;
+    u16 cur_code_addr;
+    u16 cur_frame_num, total_frame_num, cur_frame_len;
+    u32 gt80x_update_rate;
+
+    unsigned char i2c_data_buf[PACK_SIZE+2] = {0,};
+    unsigned char i2c_chk_data_buf[PACK_SIZE+2] = {0,};
+    
+    if( length > NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN )
+    {
+        dev_info(&ts->client->dev, "Fw length %d is bigger than limited length %d\n", length, NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN );
+        return 0;
+    }
+    	
+    total_frame_num = ( length + PACK_SIZE - 1) / PACK_SIZE;  
+
+    //gt80x_update_sta = _UPDATING;
+    gt80x_update_rate = 0;
+
+    for( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )	  
+    {
+        retry_time = 5;
+       
+	dev_info(&ts->client->dev, "PACK[%d]\n",cur_frame_num); 
+        cur_code_addr = /*NVRAM_UPDATE_START_ADDR*/start_addr + cur_frame_num * PACK_SIZE; 	
+        i2c_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_data_buf[1] = cur_code_addr&0xff;
+        
+        i2c_chk_data_buf[0] = i2c_data_buf[0];
+        i2c_chk_data_buf[1] = i2c_data_buf[1];
+        
+        if( cur_frame_num == total_frame_num - 1 )
+        {
+            cur_frame_len = length - cur_frame_num * PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        //strncpy(&i2c_data_buf[2], &nvram[cur_frame_num*PACK_SIZE], cur_frame_len);
+        for(i=0;i<cur_frame_len;i++)
+        {
+            i2c_data_buf[2+i] = nvram[cur_frame_num*PACK_SIZE+i];
+        }
+        do
+        {
+            err = 0;
+
+            //ret = gt811_i2c_write( guitar_i2c_address, cur_code_addr, &nvram[cur_frame_num*I2C_FRAME_MAX_LENGTH], cur_frame_len );		
+	    ret = i2c_write_bytes(ts->client, i2c_data_buf, (cur_frame_len+2));
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "write fail\n");
+                err = 1;
+            }
+            
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+            // ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "read fail\n");
+                err = 1;
+            }
+	    
+            if( is_equal( &i2c_data_buf[2], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                dev_info(&ts->client->dev, "not equal\n");
+                err = 1;
+            }
+			
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+		
+        gt80x_update_rate = ( cur_frame_num + 1 )*128/total_frame_num;
+    
+    }
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "write nvram fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_store(ts);
+    
+    msleep( 20 );
+
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram store fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_recall(ts);
+
+    msleep( 20 );
+    
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram recall fail\n");
+        return 0;
+    }
+
+    for ( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )		 //	read out all the code
+    {
+
+        cur_code_addr = NVRAM_UPDATE_START_ADDR + cur_frame_num*PACK_SIZE;
+        retry_time=5;
+        i2c_chk_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_chk_data_buf[1] = cur_code_addr&0xff;
+        
+        
+        if ( cur_frame_num == total_frame_num-1 )
+        {
+            cur_frame_len = length - cur_frame_num*PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        do
+        {
+            err = 0;
+            //ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+
+            if ( ret == 0 )
+            {
+                err = 1;
+            }
+            
+            if( is_equal( &nvram[cur_frame_num*PACK_SIZE], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                err = 1;
+            }
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+        
+        gt80x_update_rate = 127 + ( cur_frame_num + 1 )*128/total_frame_num;
+    }
+    
+    gt80x_update_rate = 255;
+    //gt80x_update_sta = _UPDATECHKCODE;
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "nvram validate fail\n");
+        return 0;
+    }
+    
+    return 1;
+}
+
+static u8  gt811_update_proc( u8 *nvram, u16 start_addr , u16 length, struct gt811_ts_data *ts )
+{
+    u8 ret;
+    u8 error = 0;
+    //struct tpd_info_t tpd_info;
+    GT811_SET_INT_PIN( 0 );
+    msleep( 20 );
+    ret = gt811_reset(ts);
+    if ( ret < 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "reset fail\n");
+        goto end;
+    }
+
+    ret = gt811_set_address_2( ts );
+    if ( ret == 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "set address fail\n");
+        goto end;
+    }
+
+    ret = gt811_update_firmware( nvram, start_addr, length, ts);
+    if ( ret == 0 )
+    {
+        error=1;
+       	dev_info(&ts->client->dev, "firmware update fail\n");
+        goto end;
+    }
+
+end:
+    GT811_SET_INT_PIN( 1 );
+//    gpio_free(INT_PORT);
+    gpio_pull_updown(INT_PORT, NULL);
+    
+    msleep( 500 );
+    ret = gt811_reset2(ts);
+    if ( ret < 0 )
+    {
+        error=1;
+        dev_info(&ts->client->dev, "final reset fail\n");
+        goto end;
+    }
+    if ( error == 1 )
+    {
+        return 0; 
+    }
+	
+//    i2c_pre_cmd(ts);
+    while(goodix_read_version(ts)<0);
+    
+//    i2c_end_cmd(ts);
+    return 1;
+}
+
+u16 Little2BigEndian(u16 little_endian)
+{
+	u16 temp = 0;
+	temp = little_endian&0xff;
+	return (temp<<8)+((little_endian>>8)&0xff);
+}
+
+int  gt811_downloader( struct gt811_ts_data *ts,  unsigned char * data)
+{
+    struct tpd_firmware_info_t *fw_info = (struct tpd_firmware_info_t *)data;
+    //int i;
+    //unsigned short checksum = 0;
+    //unsigned int  checksum = 0;
+    unsigned int  fw_checksum = 0;
+    //unsigned char fw_chip_type;
+    unsigned short fw_version;
+    unsigned short fw_start_addr;
+    unsigned short fw_length;
+    unsigned char *data_ptr;
+    //unsigned char *file_ptr = &(fw_info->chip_type);
+    int retry = 0,ret;
+    int err = 0;
+    unsigned char rd_buf[4] = {0};
+    unsigned char *mandatory_base = "GOODIX";
+    unsigned char rd_rom_version;
+    unsigned char rd_chip_type;
+    unsigned char rd_nvram_flag;
+
+    //struct file * file_data = NULL;
+    //mm_segment_t old_fs;
+    //unsigned int rd_len;
+    //unsigned int file_len = 0;
+    //unsigned char i2c_data_buf[PACK_SIZE] = {0,};
+    
+    rd_buf[0]=0x14;
+    rd_buf[1]=0x00;
+    rd_buf[2]=0x80;
+    ret = i2c_write_bytes(ts->client, rd_buf, 3);
+    if(ret<0)
+    {
+            dev_info(&ts->client->dev, "i2c write failed\n");
+            goto exit_downloader;
+    }
+    rd_buf[0]=0x40;
+    rd_buf[1]=0x11;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c request failed!\n");
+            goto exit_downloader;
+    }
+    rd_chip_type = rd_buf[2];
+    rd_buf[0]=0xFB;
+    rd_buf[1]=0xED;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c read failed!\n");
+            goto exit_downloader;
+    }
+    rd_rom_version = rd_buf[2];
+    rd_buf[0]=0x06;
+    rd_buf[1]=0x94;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c read failed!\n");
+            goto exit_downloader;
+    }
+    rd_nvram_flag = rd_buf[2];
+
+    fw_version = Little2BigEndian(fw_info->version);
+    fw_start_addr = Little2BigEndian(fw_info->start_addr);
+    fw_length = Little2BigEndian(fw_info->length);	
+    data_ptr = &(fw_info->data);	
+
+    dev_info(&ts->client->dev,"chip_type=0x%02x\n", fw_info->chip_type);
+    dev_info(&ts->client->dev,"version=0x%04x\n", fw_version);
+    dev_info(&ts->client->dev,"rom_version=0x%02x\n",fw_info->rom_version);
+    dev_info(&ts->client->dev,"start_addr=0x%04x\n",fw_start_addr);
+    dev_info(&ts->client->dev,"file_size=0x%04x\n",fw_length);
+    fw_checksum = ((u32)fw_info->checksum[0]<<16) + ((u32)fw_info->checksum[1]<<8) + ((u32)fw_info->checksum[2]);
+    dev_info(&ts->client->dev,"fw_checksum=0x%06x\n",fw_checksum);
+    dev_info(&ts->client->dev,"%s\n", __func__ );
+    dev_info(&ts->client->dev,"current version 0x%04X, target verion 0x%04X\n", ts->version, fw_version );
+
+//chk_chip_type:
+    if(rd_chip_type!=fw_info->chip_type)
+    {
+	dev_info(&ts->client->dev, "Chip type not match,exit downloader\n");
+	goto exit_downloader;
+    }
+	
+//chk_mask_version:	
+    if(!rd_rom_version)
+    {
+ 	if(fw_info->rom_version!=0x45)
+	{
+		dev_info(&ts->client->dev, "Rom version not match,exit downloader\n");
+		goto exit_downloader;
+	}
+	dev_info(&ts->client->dev, "Rom version E.\n");
+	goto chk_fw_version;
+    }
+    else if(rd_rom_version!=fw_info->rom_version);
+    {
+	dev_info(&ts->client->dev, "Rom version not match,exidownloader\n");
+	goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Rom version %c\n",rd_rom_version);
+
+//chk_nvram:	
+    if(rd_nvram_flag==0x55)
+    {
+	dev_info(&ts->client->dev, "NVRAM correct!\n");
+	goto chk_fw_version;
+    }
+    else if(rd_nvram_flag==0xAA)
+    {
+	dev_info(&ts->client->dev, "NVRAM incorrect!Need update.\n");
+	goto begin_upgrade;
+    }
+    else
+    {
+	dev_info(&ts->client->dev, "NVRAM other error![0x694]=0x%02x\n", rd_nvram_flag);
+	goto begin_upgrade;
+    }
+chk_fw_version:
+//	ts->version -= 1;               //test by andrew        
+    if( ts->version >= fw_version )   // current low byte higher than back-up low byte
+    {
+            dev_info(&ts->client->dev, "Fw verison not match.\n");
+            goto chk_mandatory_upgrade;
+    }
+    dev_info(&ts->client->dev,"Need to upgrade\n");
+    goto begin_upgrade;
+chk_mandatory_upgrade:
+//	dev_info(&ts->client->dev, "%s\n", mandatory_base);
+//	dev_info(&ts->client->dev, "%s\n", fw_info->mandatory_flag);
+    ret = memcmp(mandatory_base, fw_info->mandatory_flag, 6);
+    if(ret)
+    {
+ 	dev_info(&ts->client->dev,"Not meet mandatory upgrade,exit downloader!ret:%d\n", ret);
+	goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Mandatory upgrade!\n");
+begin_upgrade:
+    dev_info(&ts->client->dev, "Begin upgrade!\n");
+ //   goto exit_downloader;
+    dev_info(&ts->client->dev,"STEP_0:\n");
+
+   
+    dev_info(&ts->client->dev, "STEP_1:\n");
+    err = -1;
+    while( retry < 3 ) 
+    {
+//        ret = gt811_update_proc( data_ptr,fw_start_addr, fw_length, ts);
+        if(ret == 1)
+        {
+            err = 1;
+            break;
+        }
+        retry++;
+    }
+    
+exit_downloader:
+    //mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+   // mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
+       // gpio_direction_output(INT_PORT,1);
+       // msleep(1);
+    gpio_free(INT_PORT);
+    gpio_pull_updown(INT_PORT, NULL);
+    return err;
+
+}
+//******************************End of firmware update surpport*******************************
+/////////////////////////////// UPDATE STEP 4 END /////////////////////////////////////////////////////////////////
+
+//?ID 
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+	{ GOODIX_I2C_NAME, 0 },
+	{ }
+};
+
+//?
+static struct i2c_driver goodix_ts_driver = {
+	.probe		= goodix_ts_probe,
+	.remove		= goodix_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= goodix_ts_suspend,
+	.resume		= goodix_ts_resume,
+#endif
+	.id_table	= goodix_ts_id,
+	.driver = {
+		.name	= GOODIX_I2C_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+/*******************************************************	
+?	
+return?	0
+********************************************************/
+static int __devinit goodix_ts_init(void)
+{
+	int ret;
+	
+	goodix_wq = create_workqueue("goodix_wq");		//create a work queue and worker thread
+	if (!goodix_wq) {
+		printk(KERN_ALERT "creat workqueue faiked\n");
+		return -ENOMEM;
+		
+	}
+	ret=i2c_add_driver(&goodix_ts_driver);
+	return ret; 
+}
+
+/*******************************************************	
+?	
+?	client
+********************************************************/
+static void __exit goodix_ts_exit(void)
+{
+	printk(KERN_ALERT "Touchscreen driver of guitar exited.\n");
+	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);		//release our work queue
+}
+
+late_initcall_sync(goodix_ts_init); 				//felix
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL");
+               
diff --git a/drivers/input/touchscreen/86v_gt811_ts.h b/drivers/input/touchscreen/86v_gt811_ts.h
new file mode 100644
index 000000000000..a6e27f71781c
--- /dev/null
+++ b/drivers/input/touchscreen/86v_gt811_ts.h
@@ -0,0 +1,277 @@
+/* drivers/input/touchscreen/gt811.h
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+
+#ifndef 	_LINUX_GT811_H
+#define		_LINUX_GT811_H
+
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+//*************************TouchScreen Work Part*****************************
+#define GOODIX_I2C_NAME "gt811_ts"
+#define GT801_PLUS
+#define GT801_NUVOTON
+#define GUITAR_UPDATE_STATE 0x02
+
+//define resolution of the touchscreen
+#define TOUCH_MAX_HEIGHT 	800			
+#define TOUCH_MAX_WIDTH		480
+//#define STOP_IRQ_TYPE                     // if define then   no stop irq in irq_handle   kuuga add 1202S
+#define REFRESH 0     //0~0x64   Scan rate = 10000/(100+REFRESH)//define resolution of the LCD
+
+#define SHUTDOWN_PORT 	    RK30_PIN0_PB6// RK2928_PIN0_PD3 
+#define INT_PORT 	        iomux_mode_to_gpio(SPI0_CS1)// RK30_PIN1_PB7//RK2928_PIN1_PB0  
+
+
+#ifdef INT_PORT
+	#define TS_INT 		        gpio_to_irq(INT_PORT)			//Interrupt Number,EINT18(119)
+//	#define INT_CFG    	      S3C_GPIO_SFN(3) 					//IO configer as EINT
+#else
+	#define TS_INT	0
+#endif	
+
+/////////////////////////////// UPDATE STEP 5 START /////////////////////////////////////////////////////////////////
+#define TPD_CHIP_VERSION_C_FIRMWARE_BASE 0x5A
+#define TPD_CHIP_VERSION_D1_FIRMWARE_BASE 0x7A
+#define TPD_CHIP_VERSION_E_FIRMWARE_BASE 0x9A
+#define TPD_CHIP_VERSION_D2_FIRMWARE_BASE 0xBA
+
+
+/////////////////////////////// UPDATE STEP 5 END /////////////////////////////////////////////////////////////////
+
+#define FLAG_UP		0
+#define FLAG_DOWN		1
+//set GT801 PLUS trigger mode,01 
+//#define INT_TRIGGER		1	   // 1=rising 0=falling
+#define POLL_TIME		10	//actual query spacing interval:POLL_TIME+6
+
+#define GOODIX_MULTI_TOUCH
+#ifdef GOODIX_MULTI_TOUCH
+	#define MAX_FINGER_NUM	5	
+#else
+	#define MAX_FINGER_NUM	1	
+#endif
+
+#if defined(INT_PORT)
+	#if MAX_FINGER_NUM <= 3
+	#define READ_BYTES_NUM 2+2+MAX_FINGER_NUM*5
+	#elif MAX_FINGER_NUM == 4
+	#define READ_BYTES_NUM 2+28
+	#elif MAX_FINGER_NUM == 5
+	#define READ_BYTES_NUM 2+34
+	#endif
+#else	
+	#define READ_BYTES_NUM 2+34
+#endif
+
+#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+
+#define READ_TOUCH_ADDR_H 0x07
+#define READ_TOUCH_ADDR_L 0x21				//GT811 0x721
+#define READ_KEY_ADDR_H 0x07
+#define READ_KEY_ADDR_L 0x21
+#define READ_COOR_ADDR_H 0x07
+#define READ_COOR_ADDR_L 0x22
+#define READ_ID_ADDR_H 0x00
+#define READ_ID_ADDR_L 0xff
+//**********************************************************************
+
+//******************************************************************************
+struct gt811_ts_data {
+	uint16_t addr;
+	uint8_t bad_data;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_reset;		//use RESET flag
+	int use_irq;		//use EINT flag
+	int read_mode;		//read moudle mode,20110221 by andrew
+	struct hrtimer timer;
+	struct work_struct  work;
+	char phys[32];
+	int retry;
+	int irq;
+	spinlock_t				irq_lock;      //add by kuuga
+	int 				 irq_is_disable; /* 0: irq enable */ //add by kuuga
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+	uint8_t int_trigger_type;
+	uint8_t btn_state;                    // key states
+/////////////////////////////// UPDATE STEP 6 START /////////////////////////////////////////////////////////////////
+       unsigned int version;
+/////////////////////////////// UPDATE STEP 6 END /////////////////////////////////////////////////////////////////
+
+	struct early_suspend early_suspend;
+	int (*power)(struct gt811_ts_data * ts, int on);
+};
+
+//*****************************End of Part I *********************************
+
+//*************************Touchkey Surpport Part*****************************
+/*#define HAVE_TOUCH_KEY
+//#define READ_KEY_VALUE
+//#define READ_KEY_COOR
+
+#ifdef HAVE_TOUCH_KEY
+	const uint16_t toucher_key_array[]={
+									  KEY_MENU,				//MENU
+									  KEY_HOME,
+									  KEY_BACK,				
+									  KEY_SEARCH		
+									 }; 
+	#define MAX_KEY_NUM	 (sizeof(toucher_key_array)/sizeof(toucher_key_array[0]))
+#endif
+*/
+//#define COOR_TO_KEY
+    #ifdef COOR_TO_KEY
+
+    #define KEY_X       40
+    #define KEY_Y       20
+    #if 0
+    #define AREA_X      0
+    #else
+    #define AREA_Y      800
+    #endif
+
+    enum {x, y};
+    s32 key_center[MAX_KEY_NUM][2] = {
+		
+	{48,840},{124,840},{208,840},{282,840}
+	
+                           };
+
+    #endif 
+
+//*****************************End of Part II*********************************
+
+/////////////////////////////// UPDATE STEP 7 START /////////////////////////////////////////////////////////////////
+//*************************Firmware Update part*******************************
+//#define AUTO_UPDATE_GT811
+
+#define CONFIG_TOUCHSCREEN_GOODIX_IAP        
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data);
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+
+#define PACK_SIZE 					64					//update file package size
+//#define MAX_TIMEOUT					30000				//update time out conut
+//#define MAX_I2C_RETRIES				10					//i2c retry times
+
+//write cmd
+#define APK_UPDATE_TP               1
+#define APK_READ_FUN                 10
+#define APK_WRITE_CFG               11
+
+//fun cmd
+//#define CMD_DISABLE_TP             0
+//#define CMD_ENABLE_TP              1
+#define CMD_READ_VER               2
+#define CMD_READ_RAW               3
+#define CMD_READ_DIF               4
+#define CMD_READ_CFG               5
+#define CMD_READ_CHIP_TYPE         6
+//#define CMD_SYS_REBOOT             101
+
+//read mode
+#define MODE_RD_VER                1
+#define MODE_RD_RAW                2
+#define MODE_RD_DIF                3
+#define MODE_RD_CFG                4
+#define MODE_RD_CHIP_TYPE          5
+
+#if 0
+struct tpd_firmware_info_t
+{
+    int magic_number_1;
+    int magic_number_2;
+    unsigned short version;
+    unsigned short length;    
+    unsigned short checksum;
+    unsigned char data;
+};
+#else
+#pragma pack(1)
+struct tpd_firmware_info_t
+{
+	unsigned char  chip_type;
+	unsigned short version;
+	unsigned char  rom_version;
+	unsigned char  reserved[3];
+	unsigned short start_addr;
+	unsigned short length;
+	unsigned char  checksum[3];
+	unsigned char  mandatory_flag[6];
+	unsigned char  data;	
+};
+#pragma pack()
+#endif
+
+#define  NVRAM_LEN               0x0FF0   //	nvram total space
+#define  NVRAM_BOOT_SECTOR_LEN	 0x0100	// boot sector 
+#define  NVRAM_UPDATE_START_ADDR 0x4100
+
+#define  BIT_NVRAM_STROE	    0
+#define  BIT_NVRAM_RECALL	    1
+#define BIT_NVRAM_LOCK 2
+#define  REG_NVRCS_H 0X12
+#define  REG_NVRCS_L 0X01
+#define GT811_SET_INT_PIN( level ) gpio_direction_output(INT_PORT, level) //null macro now
+#endif
+//*****************************End of Part III********************************
+/////////////////////////////// UPDATE STEP 7 END /////////////////////////////////////////////////////////////////
+
+struct gt811_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+    u16     model;          /* 801. */
+    bool    swap_xy;        /* swap x and y axes */
+    u16     x_min, x_max;
+    u16     y_min, y_max;
+    bool    x_reverse, y_reverse;
+    int     (*get_pendown_state)(void);
+    int     (*init_platform_hw)(void);
+    int     (*platform_sleep)(void);
+    int     (*platform_wakeup)(void);
+    void    (*exit_platform_hw)(void);
+    int     gpio_reset;
+    bool    gpio_reset_active_low;
+    
+
+    //reservation
+};
+
+#define RAW_DATA_READY          1
+#define RAW_DATA_NON_ACTIVE     0xffffffff
+#define RAW_DATA_ACTIVE         0
+
+
+enum CHIP_TYPE
+{
+    GT800 = 1,
+    GT800PLUS,
+    GT800PLUS3,
+    GT816,
+    GT811,
+    GT8105,
+    GT8110,
+    GT818PLUS
+};
+
+
+#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 4d456d27e2e2..30d2b895c927 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -979,7 +979,11 @@ config TOUCHSCREEN_GT801_IIC
 config TOUCHSCREEN_GT811_IIC
 	tristate "GT811_IIC based touchscreens"
 	depends on I2C2_RK29 || I2C2_RK30
-	
+
+config TOUCHSCREEN_86V_GT811_IIC
+	tristate "RK3168_86V GT811_IIC based touchscreens"
+	depends on I2C2_RK29 || I2C2_RK30
+		
 config TOUCHSCREEN_GT82X_IIC
 	tristate "GT82x_IIC based touchscreens"
 	depends on I2C2_RK30
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 67b0729ed3cb..eea3165db7d1 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -76,6 +76,7 @@ obj-$(CONFIG_ATMEL_MXT224)		+= atmel_maxtouch.o
 obj-$(CONFIG_ATMEL_MXT1386)		+= atmel_mxt1386.o
 obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT811_IIC)	+= gt811_ts.o
+obj-$(CONFIG_TOUCHSCREEN_86V_GT811_IIC)	+= 86v_gt811_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC)	+= goodix_touch_82x.o
 obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT8110)        += gt8110_ts.o
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index e374f36d5588..e8dc1c762e14 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -99,6 +99,9 @@ config LCD_RK2928_A720
        bool "RK2928 A720 panel 800x480"
 config LCD_RK2926_V86
 	bool "RK2926 v86 panel 800x480"
+config LCD_RK3168_86V
+	bool "RK3168 86v panel 800x480"
+config LCD_HJ080NA
 config LCD_HJ080NA
 	bool "HJ080NA_4J 1024X768"
 
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index 37ef475d20a4..afac9e0896b7 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -44,6 +44,7 @@ obj-$(CONFIG_LCD_HV070WSA100)    += lcd_hv070wsa.o
 obj-$(CONFIG_LCD_COMMON)    += lcd_common.o
 obj-$(CONFIG_LCD_RK2928_A720) += lcd_YQ70CPT9160.o
 obj-$(CONFIG_LCD_RK2926_V86) += lcd_YQ70CPT9160_v86.o
+obj-$(CONFIG_LCD_RK3168_86V) += lcd_YQ70CPT9160_rk3168_86v.o
 obj-$(CONFIG_LCD_HSD07PFW1) += lcd_hsd07pfw1.o
 obj-$(CONFIG_LCD_HJ080NA)    += lcd_hj080na.o
 obj-$(CONFIG_LCD_HJ101NA)   += lcd_hj101na.o
diff --git a/drivers/video/display/screen/lcd_YQ70CPT9160_rk3168_86v.c b/drivers/video/display/screen/lcd_YQ70CPT9160_rk3168_86v.c
new file mode 100644
index 000000000000..3bcb2a1ca5b7
--- /dev/null
+++ b/drivers/video/display/screen/lcd_YQ70CPT9160_rk3168_86v.c
@@ -0,0 +1,195 @@
+/* This Lcd Driver is HSD070IDW1 write by cst 2009.10.27 */
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/delay.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+#include <linux/hdmi.h>
+//#include "../../rk29_fb.h"
+#include "../transmitter/rk610_lcd.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			 33000000
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			30//48 //10
+#define H_BP			10//40 //100
+#define H_VD			800 //1024
+#define H_FP			210// //210
+
+#define V_PW			13//10
+#define V_BP			10// //10
+#define V_VD			480 //768
+#define V_FP			22 //18
+
+#define LCD_WIDTH       154
+#define LCD_HEIGHT      85
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			0 
+#ifdef  CONFIG_HDMI_DUAL_DISP
+static int set_scaler_info(struct rk29fb_screen *screen, u8 hdmi_resolution)
+{
+    screen->s_clk_inv = S_DCLK_POL;
+    screen->s_den_inv = 0;
+    screen->s_hv_sync_inv = 0;
+    switch(hdmi_resolution){
+    case HDMI_1920x1080p_60Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S_OUT_CLK;
+	        screen->s_hsync_len = S_H_PW;
+	        screen->s_left_margin = S_H_BP;
+	        screen->s_right_margin = S_H_FP;
+	        screen->s_hsync_len = S_H_PW;
+	        screen->s_upper_margin = S_V_BP;
+	        screen->s_lower_margin = S_V_FP;
+	        screen->s_vsync_len = S_V_PW;
+	        screen->s_hsync_st = S_H_ST;
+	        screen->s_vsync_st = S_V_ST;
+	        break;
+	case HDMI_1920x1080p_50Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S1_OUT_CLK;
+	        screen->s_hsync_len = S1_H_PW;
+	        screen->s_left_margin = S1_H_BP;
+	        screen->s_right_margin = S1_H_FP;
+	        screen->s_hsync_len = S1_H_PW;
+	        screen->s_upper_margin = S1_V_BP;
+	        screen->s_lower_margin = S1_V_FP;
+	        screen->s_vsync_len = S1_V_PW;
+	        screen->s_hsync_st = S1_H_ST;
+	        screen->s_vsync_st = S1_V_ST;
+	        break;
+    case HDMI_1280x720p_60Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S2_OUT_CLK;
+	        screen->s_hsync_len = S2_H_PW;
+	        screen->s_left_margin = S2_H_BP;
+	        screen->s_right_margin = S2_H_FP;
+	        screen->s_hsync_len = S2_H_PW;
+	        screen->s_upper_margin = S2_V_BP;
+	        screen->s_lower_margin = S2_V_FP;
+	        screen->s_vsync_len = S2_V_PW;
+	        screen->s_hsync_st = S2_H_ST;
+	        screen->s_vsync_st = S2_V_ST;
+	        break;
+    case HDMI_1280x720p_50Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S3_OUT_CLK;
+	        screen->s_hsync_len = S3_H_PW;
+	        screen->s_left_margin = S3_H_BP;
+	        screen->s_right_margin = S3_H_FP;
+	        screen->s_hsync_len = S3_H_PW;
+	        screen->s_upper_margin = S3_V_BP;
+	        screen->s_lower_margin = S3_V_FP;
+	        screen->s_vsync_len = S3_V_PW;
+	        screen->s_hsync_st = S3_H_ST;
+	        screen->s_vsync_st = S3_V_ST;
+	        break;
+    case HDMI_720x576p_50Hz_4x3:
+    case HDMI_720x576p_50Hz_16x9:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S4_OUT_CLK;
+	        screen->s_hsync_len = S4_H_PW;
+	        screen->s_left_margin = S4_H_BP;
+	        screen->s_right_margin = S4_H_FP;
+	        screen->s_hsync_len = S4_H_PW;
+	        screen->s_upper_margin = S4_V_BP;
+	        screen->s_lower_margin = S4_V_FP;
+	        screen->s_vsync_len = S4_V_PW;
+	        screen->s_hsync_st = S4_H_ST;
+	        screen->s_vsync_st = S4_V_ST;
+	        break;
+    case HDMI_720x480p_60Hz_16x9:
+    case HDMI_720x480p_60Hz_4x3:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S5_OUT_CLK;
+	        screen->s_hsync_len = S5_H_PW;
+	        screen->s_left_margin = S5_H_BP;
+	        screen->s_right_margin = S5_H_FP;
+	        screen->s_hsync_len = S5_H_PW;
+	        screen->s_upper_margin = S5_V_BP;
+	        screen->s_lower_margin = S5_V_FP;
+	        screen->s_vsync_len = S5_V_PW;
+	        screen->s_hsync_st = S5_H_ST;
+	        screen->s_vsync_st = S5_V_ST;
+	        break;
+    default :
+            printk("%s lcd not support dual display at this hdmi resolution %d \n",__func__,hdmi_resolution);
+            return -1;
+	        break;
+	}
+	
+	return 0;
+}
+#else
+static int set_scaler_info(struct rk29fb_screen *screen, u8 hdmi_resolution){}
+#endif
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    /*screen->init = init;*/
+    screen->init = NULL;
+    screen->standby = NULL;
+    screen->sscreen_get = set_scaler_info;
+#ifdef CONFIG_RK610_LVDS
+    screen->sscreen_set = rk610_lcd_scaler_set_param;
+#endif
+}
+size_t get_fb_size(void)
+{
+	size_t size = 0;
+	#if defined(CONFIG_THREE_FB_BUFFER)
+		size = ((H_VD)*(V_VD)<<2)* 3; //three buffer
+	#else
+		size = ((H_VD)*(V_VD)<<2)<<1; //two buffer
+	#endif
+	return ALIGN(size,SZ_1M);
+}
-- 
2.35.3

