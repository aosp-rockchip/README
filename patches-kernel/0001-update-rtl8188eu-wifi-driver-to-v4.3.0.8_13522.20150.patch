From 7c86f128d462fdb45a60d0902888e57287254ded Mon Sep 17 00:00:00 2001
From: hwg <hwg@rock-chips.com>
Date: Wed, 11 Mar 2015 14:00:13 +0800
Subject: [PATCH] update rtl8188eu wifi driver to v4.3.0.8_13522.20150213_beta 
 solve android 5.0 ctsverify wifi direct test fail problem

---
 .../wireless/rockchip_wlan/rtl8188eu/Kconfig  |   9 +-
 .../wireless/rockchip_wlan/rtl8188eu/Makefile |  56 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_ap.c     |  16 +-
 .../rtl8188eu/core/rtw_ieee80211.c            | 105 ++-
 .../rockchip_wlan/rtl8188eu/core/rtw_mlme.c   |  61 +-
 .../rtl8188eu/core/rtw_mlme_ext.c             | 226 +++--
 .../rtl8188eu/core/rtw_mp_ioctl.c             |   4 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_odm.c    | 160 +++-
 .../rockchip_wlan/rtl8188eu/core/rtw_p2p.c    |   8 +-
 .../rtl8188eu/core/rtw_sta_mgt.c              |  33 +-
 .../rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c   | 874 ++++++++++++++++++
 .../rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h   | 157 ++++
 .../rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.c  | 421 +++------
 .../rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.h  |  77 +-
 .../rtl8188eu/hal/OUTSRC/odm_HWConfig.c       |   6 +-
 .../rtl8188eu/hal/OUTSRC/odm_RegDefine11AC.h  |  26 +-
 .../rtl8188eu/hal/OUTSRC/odm_RegDefine11N.h   |  27 +-
 .../rtl8188eu/hal/OUTSRC/odm_debug.h          |  28 +-
 .../rtl8188eu/hal/rtl8188e/rtl8188e_dm.c      |   6 +-
 .../rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c  |  26 +-
 .../hal/rtl8188e/usb/usb_ops_linux.c          |  30 +-
 .../rtl8188eu/include/autoconf.h              |  18 +-
 .../rtl8188eu/include/drv_conf.h              |  19 +
 .../rtl8188eu/include/drv_types.h             |   7 +
 .../rtl8188eu/include/ioctl_cfg80211.h        |   1 +
 .../rtl8188eu/include/osdep_service.h         |   2 +
 .../rtl8188eu/include/rtw_android.h           |   4 +
 .../rtl8188eu/include/rtw_mlme.h              |  19 +-
 .../rtl8188eu/include/rtw_mlme_ext.h          |   1 +
 .../rockchip_wlan/rtl8188eu/include/rtw_odm.h |   4 +-
 .../rtl8188eu/include/rtw_version.h           |   2 +-
 .../rtl8188eu/os_dep/linux/ioctl_cfg80211.c   |  97 +-
 .../rtl8188eu/os_dep/linux/ioctl_linux.c      |   4 +-
 .../rtl8188eu/os_dep/linux/os_intfs.c         |  22 +
 .../rtl8188eu/os_dep/linux/rtw_android.c      |  51 +-
 .../rtl8188eu/os_dep/linux/rtw_proc.c         |  11 +-
 .../rtl8188eu/os_dep/linux/wifi_version.h     |   2 +-
 37 files changed, 1998 insertions(+), 622 deletions(-)
 create mode 100755 drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
 create mode 100755 drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h

diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig
index c8148ed9fc43..013175c374b2 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig
@@ -1,9 +1,6 @@
 config RTL8188EU
-	tristate "Realtek 8188EU USB WiFi Support"
-    select WIRELESS_EXT
-    select WEXT_PRIV
-    select IEEE80211
-    default y
+	tristate "Realtek 8188E USB WiFi"
+	depends on USB
 	---help---
-	  Help message of RTL8188EU & RTL8189ES
+	  Help message of RTL8188EU
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
index 5551eea01f80..1ee2464ce3c6 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
@@ -53,7 +53,8 @@ CONFIG_TRAFFIC_PROTECT = y
 CONFIG_LOAD_PHY_PARA_FROM_FILE = y
 CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY = n
 CONFIG_CALIBRATE_TX_POWER_TO_MAX = n
-CONFIG_ODM_ADAPTIVITY = n
+CONFIG_RTW_ADAPTIVITY_EN = disable
+CONFIG_RTW_ADAPTIVITY_MODE = normal
 ######################## Wake On Lan ##########################
 CONFIG_WOWLAN = n
 CONFIG_GPIO_WAKEUP = n
@@ -84,9 +85,9 @@ CONFIG_PLATFORM_TEGRA4_DALMORE = n
 CONFIG_PLATFORM_ARM_TCC8900 = n
 CONFIG_PLATFORM_ARM_TCC8920 = n
 CONFIG_PLATFORM_ARM_TCC8920_JB42 = n
-CONFIG_PLATFORM_ARM_RK2818 = y
+CONFIG_PLATFORM_ARM_RK2818 = n
 CONFIG_PLATFORM_ARM_RK3066 = n
-CONFIG_PLATFORM_ARM_RK3188 = n
+CONFIG_PLATFORM_ARM_RK3188 = y
 CONFIG_PLATFORM_ARM_URBETTER = n
 CONFIG_PLATFORM_ARM_TI_PANDA = n
 CONFIG_PLATFORM_MIPS_JZ4760 = n
@@ -100,6 +101,7 @@ CONFIG_PLATFORM_ARM_SUN6I = n
 CONFIG_PLATFORM_ARM_SUN7I = n
 CONFIG_PLATFORM_ARM_SUN8I = n
 CONFIG_PLATFORM_ACTIONS_ATM702X = n
+CONFIG_PLATFORM_ACTIONS_ATM705X = n
 CONFIG_PLATFORM_ACTIONS_ATV5201 = n
 CONFIG_PLATFORM_ARM_RTD299X = n
 CONFIG_PLATFORM_ARM_SPREADTRUM_6820 = n
@@ -165,7 +167,8 @@ _OUTSRC_FILES := hal/OUTSRC/odm_debug.o	\
 		hal/OUTSRC/odm_interface.o\
 		hal/OUTSRC/odm_HWConfig.o\
 		hal/OUTSRC/odm.o\
-		hal/OUTSRC/HalPhyRf.o
+		hal/OUTSRC/HalPhyRf.o\
+		hal/OUTSRC/PhyDM_Adaptivity.o
 
 EXTRA_CFLAGS += -I$(src)/platform
 _PLATFORM_FILES := platform/platform_ops.o
@@ -711,8 +714,16 @@ ifeq ($(CONFIG_CALIBRATE_TX_POWER_TO_MAX), y)
 EXTRA_CFLAGS += -DCONFIG_CALIBRATE_TX_POWER_TO_MAX
 endif
 
-ifeq ($(CONFIG_ODM_ADAPTIVITY), y)
-EXTRA_CFLAGS += -DCONFIG_ODM_ADAPTIVITY
+ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), disable)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=0
+else ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), enable)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=1
+endif
+
+ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), normal)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=0
+else ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), carrier_sense)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=1
 endif
 
 ifeq ($(CONFIG_WOWLAN), y)
@@ -769,6 +780,27 @@ KSRC := $(KERNEL_BUILD_PATH)
 MODULE_NAME :=wlan
 endif
 
+ifeq ($(CONFIG_PLATFORM_ACTIONS_ATM705X), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+# default setting for Android 4.1, 4.2, 4.3, 4.4
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_ACTIONS_ATM705X
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS
+
+# Enable this for Android 5.0
+EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
+_PLATFORM_FILES += platform/platform_arm_act_sdio.o
+endif
+
+ARCH := arm
+CROSS_COMPILE := /opt/arm-2011.09/bin/arm-none-linux-gnueabi-
+KSRC := /home/android_sdk/Action-semi/705a_android_L/android/kernel
+endif
+
 ifeq ($(CONFIG_PLATFORM_TI_AM3517), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_SHUTTLE
 CROSS_COMPILE := arm-eabi-
@@ -1000,10 +1032,14 @@ MODULE_NAME := wlan
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3188), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS -DCONFIG_MINIMAL_MEMORY_USAGE
-EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
-EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
-EXTRA_CFLAGS += -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_MINIMAL_MEMORY_USAGE
+# default setting for Android 4.1, 4.2, 4.3, 4.4
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS
+
+# Enable this for Android 5.0
+EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
 ARCH := arm
 CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3188/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
 KSRC := /home/android_sdk/Rockchip/Rk3188/kernel
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
index 9e6e8aebba82..ce46a12e6360 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
@@ -71,9 +71,9 @@ void free_mlme_ap_info(_adapter *padapter)
 
 	//free bc/mc sta_info
 	psta = rtw_get_bcmc_stainfo(padapter);	
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 
 	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
@@ -405,9 +405,9 @@ void	expire_timeout_chk(_adapter *padapter)
 				
 				_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
 				
-				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 				rtw_free_stainfo(padapter, psta);
-				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 				
 				_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
 			}	
@@ -2912,9 +2912,9 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
 
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);					
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 
 	return beacon_updated;
@@ -3244,9 +3244,9 @@ void stop_ap_mode(_adapter *padapter)
 	rtw_free_all_stainfo(padapter);
 	
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 	rtw_init_bcmc_stainfo(padapter);	
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ieee80211.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ieee80211.c
index 7316cdcac13e..08902f2ebf6d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ieee80211.c
@@ -932,41 +932,45 @@ u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps
 u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
 {
 	uint cnt;
-	u8 *wpsie_ptr=NULL;
-	u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+	u8 *wpsie_ptr = NULL;
+	u8 eid, wps_oui[4] = {0x00, 0x50, 0xf2, 0x04};
 
-	if(wps_ielen)
+	if (wps_ielen)
 		*wps_ielen = 0;
 
-	if(!in_ie || in_len<=0)
+	if (!in_ie) {
+		rtw_warn_on(1);
+		return wpsie_ptr;
+	}
+
+	if (in_len <= 0)
 		return wpsie_ptr;
 
 	cnt = 0;
 
-	while(cnt<in_len)
-	{
+	while (cnt + 1 + 4 < in_len) {
 		eid = in_ie[cnt];
 
-		if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4)==_TRUE))
-		{
-			wpsie_ptr = &in_ie[cnt];
+		if (cnt + 1 + 4 >= MAX_IE_SZ) {
+			rtw_warn_on(1);
+			return NULL;
+		}
 
-			if(wps_ie)
-				_rtw_memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
-			
-			if(wps_ielen)
-				*wps_ielen = in_ie[cnt+1]+2;
-			
-			cnt+=in_ie[cnt+1]+2;
+		if (eid == WLAN_EID_VENDOR_SPECIFIC && _rtw_memcmp(&in_ie[cnt + 2], wps_oui, 4) == _TRUE) {
+			wpsie_ptr = in_ie + cnt;
+
+			if (wps_ie)
+				_rtw_memcpy(wps_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
+
+			if (wps_ielen)
+				*wps_ielen = in_ie[cnt + 1] + 2;
 
 			break;
+		} else {
+			cnt += in_ie[cnt + 1] + 2;
 		}
-		else
-		{
-			cnt+=in_ie[cnt+1]+2; //goto next	
-		}		
 
-	}	
+	}
 
 	return wpsie_ptr;
 }
@@ -1572,47 +1576,48 @@ u8 *rtw_get_p2p_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_
  */
 u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen)
 {
-	uint cnt = 0;
-	u8 *p2p_ie_ptr;
-	u8 eid, p2p_oui[4]={0x50,0x6F,0x9A,0x09};
+	uint cnt;
+	u8 *p2p_ie_ptr = NULL;
+	u8 eid, p2p_oui[4] = {0x50, 0x6F, 0x9A, 0x09};
 
-	if ( p2p_ielen != NULL )
+	if (p2p_ielen)
 		*p2p_ielen = 0;
 
-	while(cnt<in_len)
-	{
+	if (!in_ie || in_len < 0) {
+		rtw_warn_on(1);
+		return p2p_ie_ptr;
+	}
+
+	if (in_len <= 0)
+		return p2p_ie_ptr;
+
+	cnt = 0;
+
+	while (cnt + 1 + 4 < in_len) {
 		eid = in_ie[cnt];
-		if ((in_len < 0) || (cnt > MAX_IE_SZ)) {
-			rtw_dump_stack();
+
+		if (cnt + 1 + 4 >= MAX_IE_SZ) {
+			rtw_warn_on(1);
 			return NULL;
-		}		
-		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], p2p_oui, 4) == _TRUE ) )
-		{
+		}
+
+		if (eid == WLAN_EID_VENDOR_SPECIFIC && _rtw_memcmp(&in_ie[cnt + 2], p2p_oui, 4) == _TRUE) {
 			p2p_ie_ptr = in_ie + cnt;
-		
-			if ( p2p_ie != NULL )
-			{
-				_rtw_memcpy( p2p_ie, &in_ie[ cnt ], in_ie[ cnt + 1 ] + 2 );
-			}
 
-			if ( p2p_ielen != NULL )
-			{
-				*p2p_ielen = in_ie[ cnt + 1 ] + 2;
-			}
-			
-			return p2p_ie_ptr;
+			if (p2p_ie)
+				_rtw_memcpy(p2p_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
+
+			if (p2p_ielen)
+				*p2p_ielen = in_ie[cnt + 1] + 2;
 
 			break;
+		} else {
+			cnt += in_ie[cnt + 1] + 2;
 		}
-		else
-		{
-			cnt += in_ie[ cnt + 1 ] +2; //goto next	
-		}		
-		
-	}	
 
-	return NULL;
+	}
 
+	return p2p_ie_ptr;
 }
 
 /**
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
index fde65664c36a..17346eaa97da 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
@@ -1471,16 +1471,16 @@ _func_enter_;
 			rtw_tdls_cmd(adapter, myid(&(adapter->eeprompriv)), TDLS_RS_RCR);
 			rtw_reset_tdls_info(adapter);
 			rtw_free_all_stainfo(adapter);
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		}
 		else
 #endif //CONFIG_TDLS
 		{
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 			rtw_free_stainfo(adapter,  psta);
 		}
 
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		
 	}
 
@@ -1491,9 +1491,9 @@ _func_enter_;
 		rtw_free_all_stainfo(adapter);
 
 		psta = rtw_get_bcmc_stainfo(adapter);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		rtw_free_stainfo(adapter, psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 
 		rtw_init_bcmc_stainfo(adapter);	
 	}
@@ -1721,17 +1721,17 @@ inline void rtw_indicate_scan_done( _adapter *padapter, bool aborted)
 #endif // CONFIG_IPS
 }
 
-void rtw_scan_abort(_adapter *adapter)
+u32 rtw_scan_abort_timeout(_adapter *adapter, u32 timeout_ms)
 {
-	u32 cnt=0;
 	u32 start;
-	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
+	u32 pass_ms;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
 
 	start = rtw_get_current_time();
 	pmlmeext->scan_abort = _TRUE;
 	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)
-		&& rtw_get_passing_time_ms(start) <= 200) {
+		&& rtw_get_passing_time_ms(start) <= timeout_ms) {
 
 		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
 			break;
@@ -1751,6 +1751,23 @@ void rtw_scan_abort(_adapter *adapter)
 		rtw_indicate_scan_done(adapter, _TRUE);
 	}
 	pmlmeext->scan_abort = _FALSE;
+	pass_ms = rtw_get_passing_time_ms(start);
+
+	return pass_ms;
+}
+
+void rtw_scan_abort_no_wait(_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		pmlmeext->scan_abort = _TRUE;
+}
+
+void rtw_scan_abort(_adapter *adapter)
+{
+	rtw_scan_abort_timeout(adapter, 200);
 }
 
 static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wlan_network *pnetwork)
@@ -2036,9 +2053,9 @@ _func_enter_;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 					if(pcur_sta){
-						_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
 						rtw_free_stainfo(adapter,  pcur_sta);
-						_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
@@ -2502,9 +2519,9 @@ _func_enter_;
 	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 	{
 		
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		rtw_free_stainfo(adapter,  psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		
 		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
 		{ 
@@ -4495,3 +4512,19 @@ u8 rtw_get_buddy_bBusyTraffic(_adapter *padapter)
 }
 
 #endif //CONFIG_CONCURRENT_MODE
+
+static const char *miracast_mode_str[] = {
+	"DISABLED",
+	"SOURCE",
+	"SINK",
+	"INVALID",
+};
+
+const char *get_miracast_mode_str(int mode)
+{
+	if (mode < MIRACAST_DISABLED || mode >= MIRACAST_INVALID)
+		mode = MIRACAST_INVALID;
+
+	return miracast_mode_str[mode];
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
index 3fcef9eabbf1..85c89c729697 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
@@ -2574,8 +2574,6 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 
 	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
 
-	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
-
 	rtw_lock_rx_suspend_timeout(8000);
 
 #ifdef CONFIG_AP_MODE
@@ -2589,8 +2587,8 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 		//rtw_free_stainfo(padapter, psta);
 		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
-		DBG_871X_LEVEL(_drv_always_, "ap recv deauth reason code(%d) sta:%pM\n",
-			       	reason, GetAddr2Ptr(pframe));
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" reason=%u, ta=%pM\n"
+			, FUNC_ADPT_ARG(padapter), reason, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));	
 		if(psta)
@@ -2635,12 +2633,12 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 			}
 		}
 
-		DBG_871X_LEVEL(_drv_always_, "sta recv deauth reason code(%d) sta:%pM, ignore = %d\n",
-			       	reason, GetAddr3Ptr(pframe), ignore_received_deauth);
-		
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" reason=%u, ta=%pM, ignore=%d\n"
+			, FUNC_ADPT_ARG(padapter), reason, GetAddr2Ptr(pframe), ignore_received_deauth);
+
 		if ( 0 == ignore_received_deauth )
 		{
-			receive_disconnect(padapter, GetAddr3Ptr(pframe) ,reason);
+			receive_disconnect(padapter, GetAddr2Ptr(pframe), reason);
 		}
 	}	
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
@@ -2673,8 +2671,6 @@ unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
 
 	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
 
-        DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
-
 	rtw_lock_rx_suspend_timeout(8000);
 	
 #ifdef CONFIG_AP_MODE
@@ -2688,8 +2684,8 @@ unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
 		//rtw_free_stainfo(padapter, psta);
 		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
-		DBG_871X_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",
-				reason, GetAddr2Ptr(pframe));
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" reason=%u, ta=%pM\n"
+			, FUNC_ADPT_ARG(padapter), reason, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));	
 		if(psta)
@@ -2714,10 +2710,10 @@ unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
 	else
 #endif
 	{
-		DBG_871X_LEVEL(_drv_always_, "sta recv disassoc reason code(%d) sta:%pM\n",
-				reason, GetAddr3Ptr(pframe));
-		
-		receive_disconnect(padapter, GetAddr3Ptr(pframe), reason);
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" reason=%u, ta=%pM\n"
+			, FUNC_ADPT_ARG(padapter), reason, GetAddr2Ptr(pframe));
+
+		receive_disconnect(padapter, GetAddr2Ptr(pframe), reason);
 	}	
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
 	return _SUCCESS;
@@ -9431,18 +9427,25 @@ void site_survey(_adapter *padapter)
 		//val8 |= 0x0f;
 		//rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 *)(&val8));
 #if defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE) || defined(CONFIG_ATMEL_RC_PATCH)
-		if((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
-		{
-			if( pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH )
-			{
-				pmlmeinfo->scan_cnt = 0;
-				survey_channel = pbuddy_mlmeext->cur_channel;
-				stay_buddy_ch = 1;
-			}
-			else 
-			{
-				if( pmlmeinfo->scan_cnt == 0 )
+		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE) {
+			if (pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH) {
+				if (pmlmeinfo->backop_cnt == 0)
+					stay_buddy_ch = 1;
+				else if (pmlmeinfo->backop_cnt == RTW_STAY_AP_CH_MILLISECOND)
 					stay_buddy_ch = 2;
+
+				if (stay_buddy_ch == 2) {
+					pmlmeinfo->scan_cnt = 1;
+					pmlmeinfo->backop_cnt = 0;
+				} else if (stay_buddy_ch == 1) {
+					pmlmeinfo->backop_cnt++;
+					survey_channel = pbuddy_mlmeext->cur_channel;
+				} else {
+					pmlmeinfo->backop_cnt++;
+					set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+					return;	
+				}
+			} else {
 				pmlmeinfo->scan_cnt++;
 			}
 		}
@@ -9527,21 +9530,12 @@ void site_survey(_adapter *padapter)
 		//	1,2-6-3,4-6-5,6-6-7,8-6-9,10-6-11,12-6-13,14
 		//if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)==_TRUE)
 
-		if( stay_buddy_ch == 1 )
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
-		else {
-			if( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-				set_survey_timer(pmlmeext, 20);
-			else
-				set_survey_timer(pmlmeext, 40);
-		}
-#elif defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE)
-		if( stay_buddy_ch == 1 )
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+			set_survey_timer(pmlmeext, 20);
 		else
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+			set_survey_timer(pmlmeext, 40);
 #else
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+		set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
 #endif
 	}
 	else
@@ -9616,6 +9610,7 @@ void site_survey(_adapter *padapter)
 
 #if defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE) || defined(CONFIG_ATMEL_RC_PATCH) 
 			pmlmeinfo->scan_cnt = 0;
+			pmlmeinfo->backop_cnt = 0;
 #endif
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
@@ -10208,7 +10203,6 @@ unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr, unsi
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//check A3
 	if (!(_rtw_memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
 		return _SUCCESS;
 
@@ -11645,7 +11639,8 @@ void survey_timer_hdl(_adapter *padapter)
 		if(pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
 		{
 #if defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE) || defined(CONFIG_ATMEL_RC_PATCH) 
-			if( padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH )
+			if (padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH
+				|| padapter->mlmeextpriv.mlmext_info.backop_cnt == RTW_STAY_AP_CH_MILLISECOND)
 #endif
 				pmlmeext->sitesurvey_res.channel_idx++;
 		}
@@ -12421,7 +12416,107 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 	return 	H2C_SUCCESS;
 }
 
-int rtw_scan_ch_decision(_adapter *padapter, struct rtw_ieee80211_channel *out,
+u8 rtw_scan_sparse(_adapter *adapter, struct rtw_ieee80211_channel *ch, u8 ch_num)
+{
+/* interval larger than this is treated as backgroud scan */
+#ifndef RTW_SCAN_SPARSE_BG_INTERVAL_MS
+#define RTW_SCAN_SPARSE_BG_INTERVAL_MS 12000
+#endif
+
+#ifndef RTW_SCAN_SPARSE_CH_NUM_MIRACAST
+#define RTW_SCAN_SPARSE_CH_NUM_MIRACAST 1
+#endif
+#ifndef RTW_SCAN_SPARSE_CH_NUM_BG
+#define RTW_SCAN_SPARSE_CH_NUM_BG 4
+#endif
+
+#define SCAN_SPARSE_CH_NUM_INVALID 255
+
+	static u8 token = 255;
+	u32 interval;
+	bool busy_traffic = _FALSE;
+	bool miracast_enabled = _FALSE;
+	bool bg_scan = _FALSE;
+	u8 max_allow_ch = SCAN_SPARSE_CH_NUM_INVALID;
+	u8 scan_division_num;
+	u8 ret_num = ch_num;
+	struct registry_priv *regsty = dvobj_to_regsty(adapter_to_dvobj(adapter));
+	struct mlme_ext_priv *mlmeext = &adapter->mlmeextpriv;
+
+	if (regsty->wifi_spec)
+		goto exit;
+
+	/* assume ch_num > 6 is normal scan */
+	if (ch_num <= 6)
+		goto exit;
+
+	if (mlmeext->last_scan_time == 0)
+		mlmeext->last_scan_time = rtw_get_current_time();
+
+	interval = rtw_get_passing_time_ms(mlmeext->last_scan_time);
+
+	if (adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE
+		#ifdef CONFIG_CONCURRENT_MODE
+		|| (adapter->pbuddy_adapter && adapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE)
+		#endif
+	)
+			busy_traffic = _TRUE;
+
+	#ifdef CONFIG_WFD
+	if (is_miracast_enabled(adapter->wfd_info.stack_wfd_mode)
+		#ifdef CONFIG_CONCURRENT_MODE
+		|| (adapter->pbuddy_adapter && is_miracast_enabled(adapter->pbuddy_adapter->wfd_info.stack_wfd_mode))
+		#endif
+	)
+		miracast_enabled = _TRUE;
+	#endif
+
+	if (interval > RTW_SCAN_SPARSE_BG_INTERVAL_MS)
+		bg_scan = _TRUE;
+
+	/* max_allow_ch by conditions*/
+
+	#if RTW_SCAN_SPARSE_MIRACAST
+	if (miracast_enabled == _TRUE && busy_traffic == _TRUE)
+		max_allow_ch = rtw_min(max_allow_ch, RTW_SCAN_SPARSE_CH_NUM_MIRACAST);
+	#endif
+
+	#if RTW_SCAN_SPARSE_BG
+	if (bg_scan == _TRUE)
+		max_allow_ch = rtw_min(max_allow_ch, RTW_SCAN_SPARSE_CH_NUM_BG);
+	#endif
+
+
+	if (max_allow_ch != SCAN_SPARSE_CH_NUM_INVALID) {
+		int i;
+		int k = 0;
+
+		scan_division_num = (ch_num / max_allow_ch) + ((ch_num % max_allow_ch)?1:0);
+		token = (token + 1) % scan_division_num;
+		
+		if (0)
+			DBG_871X("scan_division_num:%u, token:%u\n", scan_division_num, token);
+		
+		for (i = 0; i < ch_num; i++) {
+			if (ch[i].hw_value && (i % scan_division_num) == token
+			) {
+				if (i != k)
+					_rtw_memcpy(&ch[k], &ch[i], sizeof(struct rtw_ieee80211_channel));
+				k++;
+			}
+		}
+
+		_rtw_memset(&ch[k], 0, sizeof(struct rtw_ieee80211_channel));
+
+		ret_num = k;
+		mlmeext->last_scan_time = rtw_get_current_time();
+	}
+
+exit:
+	return ret_num;
+}
+
+static int rtw_scan_ch_decision(_adapter *padapter, struct rtw_ieee80211_channel *out,
 	u32 out_num, struct rtw_ieee80211_channel *in, u32 in_num)
 {
 	int i, j;
@@ -12486,49 +12581,8 @@ int rtw_scan_ch_decision(_adapter *padapter, struct rtw_ieee80211_channel *out,
 		}
 	}
 
-#ifdef CONFIG_SCAN_SPARSE //partial scan, ASUS RK3188 use the feature
-	/* assume j>6 is normal scan */
-	if ((j > 6) && (padapter->registrypriv.wifi_spec != 1))
-	{
-		static u8 token = 0;
-		u32 interval;
-
-		if (pmlmeext->last_scan_time == 0)
-			pmlmeext->last_scan_time = rtw_get_current_time();
-
-		interval = rtw_get_passing_time_ms(pmlmeext->last_scan_time);
-		if ((interval > ALLOW_SCAN_INTERVAL)
-#if 0 // Miracast can't do AP scan
-			|| (padapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE)
-#ifdef CONFIG_CONCURRENT_MODE
-			|| (padapter->pbuddy_adapter
-				&& (padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE))
-#endif // CONFIG_CONCURRENT_MODE
-#endif
-			)
-		{
-			// modify scan plan
-			int k = 0;
-			_rtw_memset(in, 0, sizeof(struct rtw_ieee80211_channel)*in_num);
-			_rtw_memcpy(in, out, sizeof(struct rtw_ieee80211_channel)*j);
-			_rtw_memset(out, 0, sizeof(struct rtw_ieee80211_channel)*j);
-
-			for (i=0;i<j;i++) {
-				if (in[i].hw_value && (i%SCAN_DIVISION_NUM) == token) {
-					_rtw_memcpy(&out[k], &in[i], sizeof(struct rtw_ieee80211_channel));
-					k++;
-				}
-				if(k>=out_num)
-					break;
-			}
-
-			j = k;
-			token  = (token+1)%SCAN_DIVISION_NUM;
-		}
-
-		pmlmeext->last_scan_time = rtw_get_current_time();
-	}
-#endif //CONFIG_SCAN_SPARSE
+	/* scan_sparse */
+	j = rtw_scan_sparse(padapter, out, j);
 
 	return j;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mp_ioctl.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mp_ioctl.c
index b2c5a28aeb1c..32b7c7387609 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mp_ioctl.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mp_ioctl.c
@@ -1990,9 +1990,9 @@ NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
 
 	psta = rtw_get_stainfo(&Adapter->stapriv, macaddr);
 	if (psta != NULL) {
-		_enter_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		//_enter_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
 		rtw_free_stainfo(Adapter, psta);
-		_exit_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		//_exit_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
 	}
 
 	return status;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_odm.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_odm.c
index 75beea8a2178..0bfafd9d1402 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_odm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_odm.c
@@ -38,20 +38,20 @@ const char *odm_comp_str[] = {
 	/* BIT13 */"ODM_COMP_RXHP",
 	/* BIT14 */"ODM_COMP_MP",
 	/* BIT15 */"ODM_COMP_DYNAMIC_ATC",
-	/* BIT16 */"ODM_COMP_EDCA_TURBO",
-	/* BIT17 */"ODM_COMP_EARLY_MODE",
-	/* BIT18 */NULL,
-	/* BIT19 */NULL,
-	/* BIT20 */NULL,
-	/* BIT21 */NULL,
-	/* BIT22 */NULL,
+	/* BIT16 */"ODM_COMP_ACS",
+	/* BIT17 */"PHYDM_COMP_ADAPTIVITY",
+	/* BIT18 */"PHYDM_COMP_RA_DBG",
+	/* BIT19 */"PHYDM_COMP_TXBF",
+	/* BIT20 */"ODM_COMP_EDCA_TURBO",
+	/* BIT21 */"ODM_COMP_EARLY_MODE",
+	/* BIT22 */"ODM_FW_DEBUG_TRACE",
 	/* BIT23 */NULL,
 	/* BIT24 */"ODM_COMP_TX_PWR_TRACK",
 	/* BIT25 */"ODM_COMP_RX_GAIN_TRACK",
 	/* BIT26 */"ODM_COMP_CALIBRATION",
 	/* BIT27 */NULL,
 	/* BIT28 */NULL,
-	/* BIT29 */NULL,
+	/* BIT29 */"BEAMFORMING_DEBUG",
 	/* BIT30 */"ODM_COMP_COMMON",
 	/* BIT31 */"ODM_COMP_INIT",
 };
@@ -74,13 +74,13 @@ const char *odm_ability_str[] = {
 	/* BIT12 */"ODM_BB_RXHP",
 	/* BIT13 */"ODM_BB_ADAPTIVITY",
 	/* BIT14 */"ODM_BB_DYNAMIC_ATC",
-	/* BIT15 */NULL,
-	/* BIT16 */"ODM_MAC_EDCA_TURBO",
-	/* BIT17 */"ODM_MAC_EARLY_MODE",
+	/* BIT15 */"ODM_BB_NHM_CNT",
+	/* BIT16 */"ODM_BB_PRIMARY_CCA",
+	/* BIT17 */"ODM_BB_TXBF",
 	/* BIT18 */NULL,
 	/* BIT19 */NULL,
-	/* BIT20 */NULL,
-	/* BIT21 */NULL,
+	/* BIT20 */"ODM_MAC_EDCA_TURBO",
+	/* BIT21 */"ODM_MAC_EARLY_MODE",
 	/* BIT22 */NULL,
 	/* BIT23 */NULL,
 	/* BIT24 */"ODM_RF_TX_PWR_TRACK",
@@ -106,15 +106,15 @@ void rtw_odm_dbg_comp_msg(void *sel, _adapter *adapter)
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	DM_ODM_T *odm = &pHalData->odmpriv;
 	int cnt = 0;
-	u64 dbg_comp;
+	u64 dbg_comp = 0;
 	int i;
 
 	rtw_hal_get_def_var(adapter, HW_DEF_ODM_DBG_FLAG, &dbg_comp);
 	DBG_871X_SEL_NL(sel, "odm.DebugComponents = 0x%016llx \n", dbg_comp);
 	for (i=0;i<RTW_ODM_COMP_MAX;i++) {
 		if (odm_comp_str[i])
-		DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
-			(BIT0 << i) & dbg_comp ? '+' : ' ', i, odm_comp_str[i]);
+			DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
+				(BIT0 << i) & dbg_comp ? '+' : ' ', i, odm_comp_str[i]);
 	}
 }
 
@@ -128,11 +128,11 @@ void rtw_odm_dbg_level_msg(void *sel, _adapter *adapter)
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	DM_ODM_T *odm = &pHalData->odmpriv;
 	int cnt = 0;
-	u32 dbg_level;
+	u32 dbg_level = 0;
 	int i;
 
 	rtw_hal_get_def_var(adapter, HW_DEF_ODM_DBG_LEVEL, &dbg_level);
-	DBG_871X_SEL_NL(sel, "odm.DebugDebugLevel = %u\n", dbg_level);
+	DBG_871X_SEL_NL(sel, "odm.DebugLevel = %u\n", dbg_level);
 	for (i=0;i<RTW_ODM_DBG_LEVEL_NUM;i++) {
 		if (odm_dbg_level_str[i])
 			DBG_871X_SEL_NL(sel, "%u %s\n", i, odm_dbg_level_str[i]);
@@ -156,8 +156,8 @@ void rtw_odm_ability_msg(void *sel, _adapter *adapter)
 	DBG_871X_SEL_NL(sel, "odm.SupportAbility = 0x%08x\n", ability);
 	for (i=0;i<RTW_ODM_ABILITY_MAX;i++) {
 		if (odm_ability_str[i])
-		DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
-			(BIT0 << i) & ability ? '+' : ' ', i, odm_ability_str[i]);
+			DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
+				(BIT0 << i) & ability ? '+' : ' ', i, odm_ability_str[i]);
 	}
 }
 
@@ -166,35 +166,129 @@ inline void rtw_odm_ability_set(_adapter *adapter, u32 ability)
 	rtw_hal_set_hwreg(adapter, HW_VAR_DM_FLAG, (u8*)&ability);
 }
 
+void rtw_odm_adaptivity_ver_msg(void *sel, _adapter *adapter)
+{
+	DBG_871X_SEL_NL(sel, "ADAPTIVITY_VERSION "ADAPTIVITY_VERSION"\n");
+}
+
+#define RTW_ADAPTIVITY_EN_DISABLE 0
+#define RTW_ADAPTIVITY_EN_ENABLE 1
+
+void rtw_odm_adaptivity_en_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &hal_data->odmpriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_EN_");
+
+	if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_DISABLE) {
+		DBG_871X_SEL(sel, "DISABLE\n");
+	} else if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_ENABLE) {
+		DBG_871X_SEL(sel, "ENABLE\n");
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+#define RTW_ADAPTIVITY_MODE_NORMAL 0
+#define RTW_ADAPTIVITY_MODE_CARRIER_SENSE 1
+
+void rtw_odm_adaptivity_mode_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_MODE_");
+
+	if (regsty->adaptivity_mode == RTW_ADAPTIVITY_MODE_NORMAL) {
+		DBG_871X_SEL(sel, "NORMAL\n");
+	} else if (regsty->adaptivity_mode == RTW_ADAPTIVITY_MODE_CARRIER_SENSE) {
+		DBG_871X_SEL(sel, "CARRIER_SENSE\n");
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+#define RTW_ADAPTIVITY_DML_DISABLE 0
+#define RTW_ADAPTIVITY_DML_ENABLE 1
+
+void rtw_odm_adaptivity_dml_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_DML_");
+
+	if (regsty->adaptivity_dml == RTW_ADAPTIVITY_DML_DISABLE) {
+		DBG_871X_SEL(sel, "DISABLE\n");
+	} else if (regsty->adaptivity_dml == RTW_ADAPTIVITY_DML_ENABLE) {
+		DBG_871X_SEL(sel, "ENABLE\n");
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+void rtw_odm_adaptivity_dc_backoff_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_DC_BACKOFF:%u\n", regsty->adaptivity_dc_backoff);
+}
+
+bool rtw_odm_adaptivity_needed(_adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+	bool ret = _FALSE;
+
+	if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_ENABLE)
+		ret = _TRUE;
+
+	if (ret == _TRUE) {
+		rtw_odm_adaptivity_ver_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_en_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_mode_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_dml_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_dc_backoff_msg(RTW_DBGDUMP, adapter);
+	}
+
+	return ret;
+}
+
 void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter)
 {
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	DM_ODM_T *odm = &pHalData->odmpriv;
 
-	DBG_871X_SEL_NL(sel, "%10s %16s %8s %10s %11s %14s\n"
-		, "TH_L2H_ini", "TH_EDCCA_HL_diff", "IGI_Base", "ForceEDCCA", "AdapEn_RSSI", "IGI_LowerBound");
-	DBG_871X_SEL_NL(sel, "0x%-8x %-16d 0x%-6x %-10d %-11u %-14u\n"
+	rtw_odm_adaptivity_ver_msg(sel, adapter);
+	rtw_odm_adaptivity_en_msg(sel, adapter);
+	rtw_odm_adaptivity_mode_msg(sel, adapter);
+	rtw_odm_adaptivity_dml_msg(sel, adapter);
+	rtw_odm_adaptivity_dc_backoff_msg(sel, adapter);
+
+	DBG_871X_SEL_NL(sel, "%10s %16s\n"
+		, "TH_L2H_ini", "TH_EDCCA_HL_diff");
+	DBG_871X_SEL_NL(sel, "0x%-8x %-16d\n"
 		, (u8)odm->TH_L2H_ini
 		, odm->TH_EDCCA_HL_diff
-		, odm->IGI_Base
-		, odm->ForceEDCCA
-		, odm->AdapEn_RSSI
-		, odm->IGI_LowerBound
 	);
+
+	DBG_871X_SEL_NL(sel, "%15s %9s\n", "AdapEnableState","Adap_Flag");
+	DBG_871X_SEL_NL(sel, "%-15x %-9x \n"
+		, odm->Adaptivity_enable
+		, odm->adaptivity_flag
+	);
+	
+	
 }
 
-void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
-	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound)
+void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff)
 {
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	DM_ODM_T *odm = &pHalData->odmpriv;
 
 	odm->TH_L2H_ini = TH_L2H_ini;
 	odm->TH_EDCCA_HL_diff = TH_EDCCA_HL_diff;
-	odm->IGI_Base = IGI_Base;
-	odm->ForceEDCCA = ForceEDCCA;
-	odm->AdapEn_RSSI = AdapEn_RSSI;
-	odm->IGI_LowerBound = IGI_LowerBound;
 }
 
 void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_p2p.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_p2p.c
index eaa3ea266e48..d729c84e183f 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_p2p.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_p2p.c
@@ -3613,11 +3613,9 @@ _func_enter_;
 	pcfg80211_wdinfo->is_ro_ch = _FALSE;
 	pcfg80211_wdinfo->last_ro_ch_time = rtw_get_current_time();
 
-	if (pcfg80211_wdinfo->not_indic_ro_ch_exp == _TRUE)
-		return;
-
-	DBG_871X("cfg80211_remain_on_channel_expired, ch=%d, bw=%d, offset=%d\n", 
-		rtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));
+	DBG_871X("cfg80211_remain_on_channel_expired cookie:0x%llx, ch=%d, bw=%d, offset=%d\n"
+		, pcfg80211_wdinfo->remain_on_ch_cookie
+		, rtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));
 
 	rtw_cfg80211_remain_on_channel_expired(padapter, 
 		pcfg80211_wdinfo->remain_on_ch_cookie, 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
index 2d266a2b24c5..f25fa5421203 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
@@ -463,6 +463,11 @@ _func_enter_;
 	if (psta == NULL)
 		goto exit;
 
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
+	rtw_list_delete(&psta->hash_list);
+	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
+	pstapriv->asoc_sta_count --;
+	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
 
 	_enter_critical_bh(&psta->lock, &irqL0);
 	psta->state &= ~_FW_LINKED;
@@ -526,11 +531,6 @@ _func_enter_;
 
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 	
-	rtw_list_delete(&psta->hash_list);
-	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
-	pstapriv->asoc_sta_count --;
-	
-	
 	// re-init sta_info; 20061114 // will be init in alloc_stainfo
 	//_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
 	//_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
@@ -637,7 +637,9 @@ _func_enter_;
 	 _rtw_spinlock_free(&psta->lock);
 
 	//_enter_critical_bh(&(pfree_sta_queue->lock), &irqL0);
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
 	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
 	//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL0);
 
 exit:
@@ -657,6 +659,9 @@ void rtw_free_all_stainfo(_adapter *padapter)
 	struct sta_info *psta = NULL;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( padapter);
+	u8 free_sta_num = 0;
+	char free_sta_list[NUM_STA];
+	int stainfo_offset;
 	
 _func_enter_;	
 
@@ -676,13 +681,25 @@ _func_enter_;
 
 			plist = get_next(plist);
 
-			if(pbcmc_stainfo!=psta)					
-				rtw_free_stainfo(padapter , psta);
-			
+			if(pbcmc_stainfo!=psta)
+			{
+				rtw_list_delete(&psta->hash_list);
+				//rtw_free_stainfo(padapter , psta);
+				stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+				if (stainfo_offset_valid(stainfo_offset)) {
+					free_sta_list[free_sta_num++] = stainfo_offset;
+				}
+			}
 		}
 	}
 	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	for (index = 0; index < free_sta_num; free_sta_num++) 
+	{
+		psta = rtw_get_stainfo_by_offset(pstapriv, free_sta_list[index]);
+		rtw_free_stainfo(padapter , psta);
+	}
 	
 exit:	
 	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
new file mode 100755
index 000000000000..3395559149ec
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
@@ -0,0 +1,874 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+//#include "Mp_Precomp.h"
+#include "odm_precomp.h"
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if WPP_SOFTWARE_TRACE
+#include "PhyDM_Adaptivity.tmh"
+#endif
+#endif
+
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	
+	if (pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY) {
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if (pDM_Odm->APTotalNum > Adaptivity->APNumTH) {
+			pDM_Odm->Adaptivity_enable = FALSE;
+			pDM_Odm->adaptivity_flag = FALSE;
+			Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);
+			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("AP total num > %d!!, disable adaptivity\n", Adaptivity->APNumTH));
+		} else
+#endif
+		{
+			if (Adaptivity->DynamicLinkAdaptivity == TRUE) {
+				if (pDM_Odm->bLinked && Adaptivity->bCheck == FALSE) {
+					Phydm_NHMCounterStatistics(pDM_Odm);
+					Phydm_CheckEnvironment(pDM_Odm);
+				} else if (!pDM_Odm->bLinked)
+					Adaptivity->bCheck = FALSE;
+			} else {
+				pDM_Odm->Adaptivity_enable = TRUE;
+
+				if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8195A))
+					pDM_Odm->adaptivity_flag = FALSE;
+				else
+					pDM_Odm->adaptivity_flag = TRUE;
+			}
+		}
+	} else {
+		pDM_Odm->Adaptivity_enable = FALSE;
+		pDM_Odm->adaptivity_flag = FALSE;
+	}
+
+	
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+BOOLEAN
+Phydm_CheckChannelPlan(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	
+	if (pMgntInfo->RegEnableAdaptivity == 2) {
+		if (pDM_Odm->Carrier_Sense_enable == FALSE) {		/*check domain Code for Adaptivity or CarrierSense*/
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) &&
+			    !(pDM_Odm->odm_Regulation5G == REGULATION_ETSI || pDM_Odm->odm_Regulation5G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 5G domain code : %d\n", pDM_Odm->odm_Regulation5G));
+				return TRUE;
+			} else if ((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				   !(pDM_Odm->odm_Regulation2_4G == REGULATION_ETSI || pDM_Odm->odm_Regulation2_4G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 2.4G domain code : %d\n", pDM_Odm->odm_Regulation2_4G));
+				return TRUE;
+
+			} else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity neither 2G nor 5G band, return\n"));
+				return TRUE;
+			}
+		} else {
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) &&
+			    !(pDM_Odm->odm_Regulation5G == REGULATION_MKK || pDM_Odm->odm_Regulation5G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 5G domain code : %d\n", pDM_Odm->odm_Regulation5G));
+				return TRUE;
+			}
+
+			else if ((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				   !(pDM_Odm->odm_Regulation2_4G == REGULATION_MKK  || pDM_Odm->odm_Regulation2_4G == REGULATION_WW)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 2.4G domain code : %d\n", pDM_Odm->odm_Regulation2_4G));
+				return TRUE;
+
+			} else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G)) {
+				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense neither 2G nor 5G band, return\n"));
+				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+
+}
+#endif
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		/*PHY parameters initialize for n series*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N + 2, 0xC350);			/*0x894[31:16]=0x0xC350	Time duration for NHM unit: us, 0xc350=200ms*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N + 2, 0xffff);		/*0x890[31:16]=0xffff		th_9, th_10*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff50);		/*0x898=0xffffff52			th_3, th_2, th_1, th_0*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);		/*0x89c=0xffffffff			th_7, th_6, th_5, th_4*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		/*0xe28[7:0]=0xff			th_8*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10 | BIT9 | BIT8, 0x1);	/*0x890[10:8]=1			ignoreCCA ignore PHYTXON enable CCX*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);			/*0xc0c[7]=1				max power among all RX ants*/
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		/*PHY parameters initialize for ac series*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC + 2, 0xC350);			/*0x990[31:16]=0xC350	Time duration for NHM unit: us, 0xc350=200ms*/
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC + 2, 0xffff);		/*0x994[31:16]=0xffff		th_9, th_10*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff50);	/*0x998=0xffffff52			th_3, th_2, th_1, th_0*/
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffffff);	/*0x99c=0xffffffff			th_7, th_6, th_5, th_4*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH8_11AC, bMaskByte0, 0xff);		/*0x9a0[7:0]=0xff			th_8*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8 | BIT9 | BIT10, 0x1); /*0x994[10:8]=1			ignoreCCA ignore PHYTXON	enable CCX*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_9E8_11AC, BIT0, 0x1);				/*0x9e8[7]=1				max power among all RX ants*/
+
+	}
+#endif
+}
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	/*Get NHM report*/
+	Phydm_GetNHMCounterStatistics(pDM_Odm);
+
+	/*Reset NHM counter*/
+	Phydm_NHMCounterStatisticsReset(pDM_Odm);
+}
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte		value32 = 0;
+#if (RTL8195A_SUPPORT == 0)
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11AC, bMaskDWord);
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+#endif
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11N, bMaskDWord);
+
+	pDM_Odm->NHM_cnt_0 = (u1Byte)(value32 & bMaskByte0);
+	pDM_Odm->NHM_cnt_1 = (u1Byte)((value32 & bMaskByte1) >> 8);
+
+}
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 1);
+	}
+
+#endif
+
+}
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN	PVOID	pDM_VOID,
+	IN	s1Byte	H2L,
+	IN	s1Byte	L2H
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)L2H);
+		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)H2L);
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, bMaskByte0, (u1Byte)L2H);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, bMaskByte1, (u1Byte)H2L);
+	}
+#endif
+
+}
+
+VOID
+Phydm_SetTRxMux(
+	IN	PVOID				pDM_VOID,
+	IN	PhyDM_Trx_MUX_Type	txMode,
+	IN	PhyDM_Trx_MUX_Type	rxMode
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT3 | BIT2 | BIT1, txMode);			/*set TXmod to standby mode to remove outside noise affect*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT22 | BIT21 | BIT20, rxMode);		/*set RXmod to standby mode to remove outside noise affect*/
+		if (pDM_Odm->RFType > ODM_1T1R) {
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT3 | BIT2 | BIT1, txMode);		/*set TXmod to standby mode to remove outside noise affect*/
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT22 | BIT21 | BIT20, rxMode);	/*set RXmod to standby mode to remove outside noise affect*/
+		}
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT11 | BIT10 | BIT9 | BIT8, txMode);				/*set TXmod to standby mode to remove outside noise affect*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT7 | BIT6 | BIT5 | BIT4, rxMode);				/*set RXmod to standby mode to remove outside noise affect*/
+		if (pDM_Odm->RFType > ODM_1T1R) {
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT11 | BIT10 | BIT9 | BIT8, txMode);		/*set TXmod to standby mode to remove outside noise affect*/
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT7 | BIT6 | BIT5 | BIT4, rxMode);			/*set RXmod to standby mode to remove outside noise affect*/
+		}
+	}
+#endif
+
+}
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (State == PhyDM_IGNORE_EDCCA) {
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	/*ignore EDCCA	reg520[15]=1*/
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);			/*reg524[11]=0*/
+	} else {	/*don't set MAC ignore EDCCA signal*/
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	/*don't ignore EDCCA	 reg520[15]=0*/
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);			/*reg524[11]=1	*/
+	}
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("EDCCA enable State = %d\n", State));
+
+}
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte			Base = 0;
+
+	Base = pDM_Odm->NHM_cnt_0 + pDM_Odm->NHM_cnt_1;
+
+	if (Base != 0) {
+		pDM_Odm->NHM_cnt_0 = ((pDM_Odm->NHM_cnt_0) << 8) / Base;
+		pDM_Odm->NHM_cnt_1 = ((pDM_Odm->NHM_cnt_1) << 8) / Base;
+	}
+	if ((pDM_Odm->NHM_cnt_0 - pDM_Odm->NHM_cnt_1) >= 100)
+		return TRUE;			/*clean environment*/
+	else
+		return FALSE;		/*noisy environment*/
+
+}
+
+
+VOID
+Phydm_CheckEnvironment(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	BOOLEAN 	isCleanEnvironment = FALSE;
+
+	if (Adaptivity->bFirstLink == TRUE) {
+		if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8195A))
+			pDM_Odm->adaptivity_flag = FALSE;
+		else
+			pDM_Odm->adaptivity_flag = TRUE;
+
+		Adaptivity->bFirstLink = FALSE;
+		return;
+	} else {
+		if (Adaptivity->NHMWait < 3) {		/*Start enter NHM after 4 NHMWait*/
+			Adaptivity->NHMWait++;
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			return;
+		} else {
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			isCleanEnvironment = Phydm_CalNHMcnt(pDM_Odm);
+			if (isCleanEnvironment == TRUE) {
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+				pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;			/*mode 1*/
+				pDM_Odm->TH_EDCCA_HL_diff = Adaptivity->TH_EDCCA_HL_diff_backup;
+#endif
+				pDM_Odm->Adaptivity_enable = TRUE;
+
+				if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8195A))
+					pDM_Odm->adaptivity_flag = FALSE;
+				else
+					pDM_Odm->adaptivity_flag = TRUE;
+			} else {
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+				Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);
+#else
+				pDM_Odm->TH_L2H_ini = Adaptivity->TH_L2H_ini_mode2;			/*for AP mode 2*/
+				pDM_Odm->TH_EDCCA_HL_diff = Adaptivity->TH_EDCCA_HL_diff_mode2;
+#endif
+				pDM_Odm->adaptivity_flag = FALSE;
+				pDM_Odm->Adaptivity_enable = FALSE;
+			}
+			Adaptivity->NHMWait = 0;
+			Adaptivity->bFirstLink = TRUE;
+			Adaptivity->bCheck = TRUE;
+		}
+
+	}
+
+
+}
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+	u4Byte			value32 = 0;
+	u1Byte			cnt, IGI_Pause = 0x7f, IGI_Resume = 0x20, IGI = 0x50;		/*IGI = 0x50 for cal EDCCA lower bound*/
+	u1Byte			txEdcca1 = 0, txEdcca0 = 0;
+	BOOLEAN			bAdjust = TRUE;
+	s1Byte 			TH_L2H_dmc, TH_H2L_dmc, IGI_target = 0x32;
+	s1Byte 			Diff;
+
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+	ODM_Write_DIG(pDM_Odm, IGI_Pause);
+
+	Diff = IGI_target - (s1Byte)IGI;
+	TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+	if (TH_L2H_dmc > 10)
+		TH_L2H_dmc = 10;
+	TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	ODM_delay_ms(5);
+
+	while (bAdjust) {
+		for (cnt = 0; cnt < 250; cnt++) {
+			if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+				value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11N, bMaskDWord);
+#if (RTL8195A_SUPPORT == 0)
+			else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+				value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11AC, bMaskDWord);
+#endif
+			if (value32 & BIT30 && (pDM_Odm->SupportICType & (ODM_RTL8723A | ODM_RTL8723B | ODM_RTL8188E)))
+				txEdcca1 = txEdcca1 + 1;
+			else if (value32 & BIT29)
+				txEdcca1 = txEdcca1 + 1;
+			else
+				txEdcca0 = txEdcca0 + 1;
+		}
+
+		if (txEdcca1 > 1) {
+			IGI = IGI - 1;
+			TH_L2H_dmc = TH_L2H_dmc + 1;
+			if (TH_L2H_dmc > 10)
+				TH_L2H_dmc = 10;
+			TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+			Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+			if (TH_L2H_dmc == 10) {
+				bAdjust = FALSE;
+				Adaptivity->H2L_lb = TH_H2L_dmc;
+				Adaptivity->L2H_lb = TH_L2H_dmc;
+				pDM_Odm->Adaptivity_IGI_upper = IGI;
+			}
+
+			txEdcca1 = 0;
+			txEdcca0 = 0;
+
+		} else {
+			bAdjust = FALSE;
+			Adaptivity->H2L_lb = TH_H2L_dmc;
+			Adaptivity->L2H_lb = TH_L2H_dmc;
+			pDM_Odm->Adaptivity_IGI_upper = IGI;
+			txEdcca1 = 0;
+			txEdcca0 = 0;
+		}
+	}
+
+	pDM_Odm->Adaptivity_IGI_upper = pDM_Odm->Adaptivity_IGI_upper - pDM_Odm->DCbackoff;
+	Adaptivity->H2L_lb = Adaptivity->H2L_lb + pDM_Odm->DCbackoff;
+	Adaptivity->L2H_lb = Adaptivity->L2H_lb + pDM_Odm->DCbackoff;
+
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_TX_MODE, PhyDM_RX_MODE);
+	ODM_Write_DIG(pDM_Odm, IGI_Resume);
+	Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);				/*resume to no link state*/
+}
+
+VOID
+Phydm_AdaptivityInit(
+	IN 	PVOID	 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	pDM_Odm->Carrier_Sense_enable = (BOOLEAN)pMgntInfo->RegEnableCarrierSense;
+	pDM_Odm->DCbackoff = (u1Byte)pMgntInfo->RegDCbackoff;
+	Adaptivity->DynamicLinkAdaptivity = (BOOLEAN)pMgntInfo->RegDmLinkAdaptivity;
+	Adaptivity->APNumTH = (u1Byte)pMgntInfo->RegAPNumTH;
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pDM_Odm->Carrier_Sense_enable = (pDM_Odm->Adapter->registrypriv.adaptivity_mode != 0) ? TRUE : FALSE;
+	pDM_Odm->DCbackoff = pDM_Odm->Adapter->registrypriv.adaptivity_dc_backoff;
+	Adaptivity->DynamicLinkAdaptivity = (pDM_Odm->Adapter->registrypriv.adaptivity_dml != 0) ? TRUE : FALSE;
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+
+	if (pDM_Odm->Carrier_Sense_enable == FALSE) {
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if (pMgntInfo->RegL2HForAdaptivity != 0)
+			pDM_Odm->TH_L2H_ini = pMgntInfo->RegL2HForAdaptivity;
+		else
+#endif
+		{
+			pDM_Odm->TH_L2H_ini = 0xf5;
+		}
+	} else {
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if (pMgntInfo->RegL2HForAdaptivity != 0)
+			pDM_Odm->TH_L2H_ini = pMgntInfo->RegL2HForAdaptivity;
+		else
+#endif
+			pDM_Odm->TH_L2H_ini = 0xa;
+	}
+
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (pMgntInfo->RegHLDiffForAdaptivity != 0)
+		pDM_Odm->TH_EDCCA_HL_diff = pMgntInfo->RegHLDiffForAdaptivity;
+	else
+#endif
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("TH_L2H_ini = 0x%x, TH_EDCCA_HL_diff = 0x%x\n", pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff));
+
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+
+	if (pDM_Odm->Carrier_Sense_enable) {
+		pDM_Odm->TH_L2H_ini = 0xa;
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+	} else {
+		pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;	/*set by mib*/
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+	}
+
+	Adaptivity->TH_L2H_ini_mode2 = 20;
+	Adaptivity->TH_EDCCA_HL_diff_mode2 = 8;
+	Adaptivity->TH_EDCCA_HL_diff_backup = pDM_Odm->TH_EDCCA_HL_diff;
+	if (priv->pshare->rf_ft_var.adaptivity_enable == 2)
+		Adaptivity->DynamicLinkAdaptivity = TRUE;
+	else
+		Adaptivity->DynamicLinkAdaptivity = FALSE;
+
+#endif
+
+	pDM_Odm->Adaptivity_IGI_upper = 0;
+	pDM_Odm->Adaptivity_enable = FALSE;	/*use this flag to decide enable or disable*/
+	
+	Adaptivity->IGI_Base = 0x32;
+	Adaptivity->IGI_target = 0x1c;
+	Adaptivity->H2L_lb = 0;
+	Adaptivity->L2H_lb = 0;
+	Adaptivity->NHMWait = 0;
+	Adaptivity->bCheck = FALSE;
+	Adaptivity->bFirstLink = TRUE;
+
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+
+	/*Search pwdB lower bound*/
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
+#if (RTL8195A_SUPPORT == 0)
+	else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_DBG_RPT_11AC, bMaskDWord, 0x209);
+#endif
+
+#if (RTL8195A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType & ODM_RTL8195A) {
+		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DOWN_OPT_11N, BIT12 | BIT11 | BIT10, 0x7);		/*interfernce need > 2^x us, and then EDCCA will be 1*/
+		ODM_SetBBReg(pDM_Odm, DOM_REG_EDCCA_DCNF_11N, BIT21 | BIT20, 0x1);		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+	}
+#else
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {		/*8814a no need to find pwdB lower bound, maybe*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DOWN_OPT, BIT30 | BIT29 | BIT28, 0x7);		/*interfernce need > 2^x us, and then EDCCA will be 1*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_POWER_CAL, BIT5, 1);						/*0:mean, 1:max pwdB*/
+		ODM_SetBBReg(pDM_Odm, ODM_REG_ACBB_EDCCA_ENHANCE, BIT29 | BIT28, 0x1);		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+	} else
+		Phydm_SearchPwdBLowerBound(pDM_Odm);
+#endif
+
+}
+
+
+VOID
+Phydm_Adaptivity(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			IGI
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	s1Byte			TH_L2H_dmc, TH_H2L_dmc;
+	s1Byte			Diff, IGI_target;
+	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	BOOLEAN			bFwCurrentInPSMode = FALSE;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));
+
+	/*Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.*/
+	if (bFwCurrentInPSMode)
+		return;
+#endif
+
+	if (!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Go to odm_DynamicEDCCA()\n"));
+		/*Add by Neil Chen to enable edcca to MP Platform */
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		/*Adjust EDCCA.*/
+		if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			Phydm_DynamicEDCCA(pDM_Odm);
+#endif
+		return;
+	}
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (Phydm_CheckChannelPlan(pDM_Odm))
+		return;
+	if (pDM_Odm->APTotalNum > Adaptivity->APNumTH)
+		return;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("odm_Adaptivity() =====>\n"));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d\n",
+			 Adaptivity->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff));
+#if (RTL8195A_SUPPORT == 0)
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
+		/*fix AC series when enable EDCCA hang issue*/
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 1);	/*ADC_mask disable*/
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0);	/*ADC_mask enable*/
+	}
+#endif
+	if (*pDM_Odm->pBandWidth == ODM_BW20M)		/*CHANNEL_WIDTH_20*/
+		IGI_target = Adaptivity->IGI_Base;
+	else if (*pDM_Odm->pBandWidth == ODM_BW40M)
+		IGI_target = Adaptivity->IGI_Base + 2;
+#if (RTL8195A_SUPPORT == 0)
+	else if (*pDM_Odm->pBandWidth == ODM_BW80M)
+		IGI_target = Adaptivity->IGI_Base + 2;
+#endif
+	else
+		IGI_target = Adaptivity->IGI_Base;
+	Adaptivity->IGI_target = (u1Byte) IGI_target;
+
+	if (*pDM_Odm->pChannel >= 149) {			/*Band4 -> for AP : mode2*/
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+	s1Byte	L2H_nolink_Band4 = 0x7f, H2L_nolink_Band4 = 0x7f;
+		if (pDM_Odm->bLinked) {
+			if (pDM_Odm->SupportICType & ODM_RTL8814A) {
+				L2H_nolink_Band4 = (s1Byte)Adaptivity->TH_L2H_ini_mode2 + IGI_target;
+				H2L_nolink_Band4 = L2H_nolink_Band4 - Adaptivity->TH_EDCCA_HL_diff_mode2;
+			} else {
+				Diff = IGI_target - (s1Byte)IGI;
+				L2H_nolink_Band4 = Adaptivity->TH_L2H_ini_mode2 + Diff;
+				if (L2H_nolink_Band4 > 10)
+					L2H_nolink_Band4 = 10;
+				H2L_nolink_Band4 = L2H_nolink_Band4 - Adaptivity->TH_EDCCA_HL_diff_mode2;
+			}
+		} else {
+			L2H_nolink_Band4 = 0x7f;
+			H2L_nolink_Band4 = 0x7f;
+		}
+		Phydm_SetEDCCAThreshold(pDM_Odm, H2L_nolink_Band4, L2H_nolink_Band4);
+		return;
+#endif
+	}
+
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, DynamicLinkAdaptivity = %d\n",
+			 (*pDM_Odm->pBandWidth == ODM_BW80M) ? "80M" : ((*pDM_Odm->pBandWidth == ODM_BW40M) ? "40M" : "20M"), IGI_target, Adaptivity->DynamicLinkAdaptivity));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("RSSI_min = %d, AdapIGIUpper= 0x%x, adaptivity_flag = %d, Adaptivity_enable = %d\n",
+			 pDM_Odm->RSSI_Min, pDM_Odm->Adaptivity_IGI_upper, pDM_Odm->adaptivity_flag, pDM_Odm->Adaptivity_enable));
+
+	if ((Adaptivity->DynamicLinkAdaptivity == TRUE) && (!pDM_Odm->bLinked) && (pDM_Odm->Adaptivity_enable == FALSE)) {
+		Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("In DynamicLink mode(noisy) and No link, Turn off EDCCA!!\n"));
+		return;
+	}
+#if (!(DM_ODM_SUPPORT_TYPE & ODM_AP))
+	else if ((Adaptivity->DynamicLinkAdaptivity == TRUE) && (pDM_Odm->Adaptivity_enable == FALSE)) {
+		Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f);
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("In DynamicLink mode(noisy) disable EDCCA, return!!\n"));
+		return;
+	}
+#endif
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_RTL8195A)) {
+		TH_L2H_dmc = (s1Byte)pDM_Odm->TH_L2H_ini + IGI_target;
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+	}
+#if (RTL8195A_SUPPORT == 0)
+	else	{
+		Diff = IGI_target - (s1Byte)IGI;
+		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+		if (TH_L2H_dmc > 10)
+			TH_L2H_dmc = 10;
+
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+		/*replace lower bound to prevent EDCCA always equal 1*/
+		if (TH_H2L_dmc < Adaptivity->H2L_lb)
+			TH_H2L_dmc = Adaptivity->H2L_lb;
+		if (TH_L2H_dmc < Adaptivity->L2H_lb)
+			TH_L2H_dmc = Adaptivity->L2H_lb;
+	}
+#endif
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", IGI, TH_L2H_dmc, TH_H2L_dmc));
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity_IGI_upper=0x%x, H2L_lb = 0x%x, L2H_lb = 0x%x\n", pDM_Odm->Adaptivity_IGI_upper, Adaptivity->H2L_lb, Adaptivity->L2H_lb));
+
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	return;
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+Phydm_AdaptivityBSOD(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter = pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	u1Byte			count = 0;
+	u4Byte			u4Value;
+
+	/*
+	1. turn off RF (TRX Mux in standby mode)
+	2. H2C mac id drop
+	3. ignore EDCCA
+	4. wait for clear FIFO
+	5. don't ignore EDCCA
+	6. turn on RF (TRX Mux in TRx mdoe)
+	7. H2C mac id resume
+	*/
+
+	RT_TRACE(COMP_MLME, DBG_WARNING, ("MAC id drop packet!!!!!\n"));
+
+	pAdapter->dropPktByMacIdCnt++;
+	pMgntInfo->bDropPktInProgress = TRUE;
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_MAX_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Queue Reserved Page Number = 0x%08x\n", u4Value));
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_AVBL_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Available Queue Page Number = 0x%08x\n", u4Value));
+
+#if 1
+
+	/*Standby mode*/
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+	ODM_Write_DIG(pDM_Odm, 0x20);
+
+	/*H2C mac id drop*/
+	MacIdIndicateDisconnect(pAdapter);
+
+	/*Ignore EDCCA*/
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+
+	delay_ms(50);
+	count = 5;
+
+#else
+
+	do {
+
+		u8Byte 		diffTime, curTime, oldestTime;
+		u1Byte		queueIdx
+
+		//3 Standby mode
+		Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+		ODM_Write_DIG(pDM_Odm, 0x20);
+
+		//3 H2C mac id drop
+		MacIdIndicateDisconnect(pAdapter);
+
+		//3 Ignore EDCCA
+		Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+
+		count++;
+		delay_ms(10);
+
+		// Check latest packet
+		curTime = PlatformGetCurrentTime();
+		oldestTime = 0xFFFFFFFFFFFFFFFF;
+
+		for (queueIdx = 0; queueIdx < MAX_TX_QUEUE; queueIdx++) {
+			if (!IS_DATA_QUEUE(queueIdx))
+				continue;
+
+			if (!pAdapter->bTcbBusyQEmpty[queueIdx]) {
+				RT_TRACE(COMP_MLME, DBG_WARNING, ("oldestTime = %llu\n", oldestTime));
+				RT_TRACE(COMP_MLME, DBG_WARNING, ("Q[%d] = %llu\n", queueIdx, pAdapter->firstTcbSysTime[queueIdx]));
+				if (pAdapter->firstTcbSysTime[queueIdx] < oldestTime)
+					oldestTime = pAdapter->firstTcbSysTime[queueIdx];
+			}
+		}
+
+		diffTime = curTime - oldestTime;
+
+		RT_TRACE(COMP_MLME, DBG_WARNING, ("diff s = %llu\n", (diffTime / 1000000)));
+
+	} while (((diffTime / 1000000) >= 4) && (oldestTime != 0xFFFFFFFFFFFFFFFF));
+#endif
+
+	/*Resume EDCCA*/
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+
+	/*Turn on TRx mode*/
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_TX_MODE, PhyDM_RX_MODE);
+	ODM_Write_DIG(pDM_Odm, 0x20);
+
+	/*Resume H2C macid*/
+	MacIdRecoverMediaStatus(pAdapter);
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_AVBL_Q_PAGE_NUM, (pu1Byte)(&u4Value));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("Available Queue Page Number = 0x%08x\n", u4Value));
+
+	pMgntInfo->bDropPktInProgress = FALSE;
+	RT_TRACE(COMP_MLME, DBG_WARNING, ("End of MAC id drop packet, spent %dms\n", count * 10));
+
+}
+
+VOID
+Phydm_EnableEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{
+
+	/*This should be moved out of OUTSRC*/
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	/*Enable EDCCA. The value is suggested by SD3 Wilson.*/
+
+	/*Revised for ASUS 11b/g performance issues, suggested by BB Neil, 2012.04.13.*/
+	if ((pDM_Odm->SupportICType == ODM_RTL8723A) && (IS_WIRELESS_MODE_G(pAdapter))) {
+		ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x00);
+		ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold + 2, 0xFD);
+	} else {
+		ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x03);
+		ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold + 2, 0x00);
+	}
+}
+
+VOID
+Phydm_DisableEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x7f);
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold + 2, 0x7f);
+}
+
+VOID
+Phydm_DynamicEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u1Byte			RegC50, RegC58;
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	BOOLEAN			bFwCurrentInPSMode = FALSE;
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));
+
+	/*Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.*/
+	if (bFwCurrentInPSMode)
+		return;
+#endif
+
+	/*2013/11/14 Ken According to BB team Jame's suggestion, we need to disable soft AP mode EDCCA.*/
+	/*2014/01/08 MH For Miracst AP mode test. We need to disable EDCCA. Otherwise, we may stop*/
+	/*to send beacon in noisy environment or platform.*/
+
+	if (ACTING_AS_AP(pAdapter) || ACTING_AS_AP(GetFirstAPAdapter(pAdapter))) {
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("At least One Port as AP disable EDCCA\n"));
+		Phydm_DisableEDCCA(pDM_Odm);
+		if (pHalData->bPreEdccaEnable)
+			Phydm_DisableEDCCA(pDM_Odm);
+		pHalData->bPreEdccaEnable = FALSE;
+		return;
+	}
+
+	RegC50 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
+	RegC58 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0);
+
+
+	if ((RegC50 > 0x28 && RegC58 > 0x28) ||
+	    ((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50 > 0x26)) ||
+	    (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28)) {
+		if (!pHalData->bPreEdccaEnable) {
+			Phydm_EnableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = TRUE;
+		}
+
+	} else if ((RegC50 < 0x25 && RegC58 < 0x25) || (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25)) {
+		if (pHalData->bPreEdccaEnable) {
+			Phydm_DisableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = FALSE;
+		}
+	}
+}
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h
new file mode 100755
index 000000000000..136c5dca79ef
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMADAPTIVITY_H__
+#define    __PHYDMADAPTIVITY_H__
+
+#define ADAPTIVITY_VERSION	"8.5"
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+typedef enum _tag_PhyDM_REGULATION_Type {
+	REGULATION_FCC = 0,
+	REGULATION_MKK = 1,
+	REGULATION_ETSI = 2,
+	REGULATION_WW = 3,	
+	
+	MAX_REGULATION_NUM = 4
+} PhyDM_REGULATION_TYPE;
+#endif
+
+
+typedef enum tag_PhyDM_TRx_MUX_Type
+{
+	PhyDM_SHUTDOWN			= 0,
+	PhyDM_STANDBY_MODE		= 1,
+	PhyDM_TX_MODE			= 2,
+	PhyDM_RX_MODE			= 3
+}PhyDM_Trx_MUX_Type;
+
+typedef enum tag_PhyDM_MACEDCCA_Type
+{
+	PhyDM_IGNORE_EDCCA			= 0,
+	PhyDM_DONT_IGNORE_EDCCA	= 1
+}PhyDM_MACEDCCA_Type;
+
+typedef struct _ADAPTIVITY_STATISTICS {
+	s1Byte			TH_L2H_ini_mode2;
+	s1Byte			TH_EDCCA_HL_diff_mode2;
+	s1Byte			TH_EDCCA_HL_diff_backup;
+	s1Byte			IGI_Base;
+	u1Byte			IGI_target;
+	u1Byte			NHMWait;
+	s1Byte			H2L_lb;
+	s1Byte			L2H_lb;
+	BOOLEAN			bFirstLink;
+	BOOLEAN			bCheck;
+	BOOLEAN			DynamicLinkAdaptivity;
+	u1Byte			APNumTH;
+} ADAPTIVITY_STATISTICS, *PADAPTIVITY_STATISTICS;
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+	);
+
+VOID
+Phydm_CheckEnvironment(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+);
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN		PVOID		pDM_VOID,
+	IN		s1Byte		H2L,
+	IN		s1Byte		L2H
+);
+
+VOID
+Phydm_SetTRxMux(
+	IN		PVOID			pDM_VOID,
+	IN		PhyDM_Trx_MUX_Type			txMode,
+	IN		PhyDM_Trx_MUX_Type			rxMode
+);	
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID					pDM_VOID
+);
+
+VOID 
+Phydm_AdaptivityInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_Adaptivity(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					IGI
+	);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Phydm_DisableEDCCA(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_DynamicEDCCA(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_AdaptivityBSOD(
+	IN		PVOID					pDM_VOID
+);
+
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.c
index fd6474e8aa21..dc0964bc8f6d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.c
@@ -465,16 +465,6 @@ odm_CCKPacketDetectionThresh(
 	IN		PDM_ODM_T		pDM_Odm
 	);
 
-VOID
-odm_AdaptivityInit(
-	IN		PDM_ODM_T		pDM_Odm
-);
-
-VOID
-odm_Adaptivity(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			IGI
-);
 //END---------------DIG---------------------------//
 
 //START-------BB POWER SAVE-----------------------//
@@ -923,7 +913,7 @@ ODM_DMInit(
 	odm_CommonInfoSelfInit(pDM_Odm);
 	odm_CmnInfoInit_Debug(pDM_Odm);
 	odm_DIGInit(pDM_Odm);	
-	odm_AdaptivityInit(pDM_Odm);
+	Phydm_AdaptivityInit(pDM_Odm);
 	odm_RateAdaptiveMaskInit(pDM_Odm);
 	odm_RSSIMonitorInit(pDM_Odm);
 	
@@ -1046,17 +1036,25 @@ ODM_DMWatchdog(
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("----Step1: odm_DIG is in LPS mode\n"));				
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("---Step2: 8723AS is in LPS mode\n"));
 			odm_DIGbyRSSI_LPS(pDM_Odm);
+			{
+				pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+				Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
+			}
+
 	}		
 	else				
 //#endif
 #endif
+
+	Phydm_CheckAdaptivity(pDM_Odm);
+
 	{
 		odm_DIG(pDM_Odm);
 	}
 
 	{
 		pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-		odm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
+		Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
 	}
 	odm_CCKPacketDetectionThresh(pDM_Odm);
 
@@ -2027,36 +2025,6 @@ int getIGIForDiff(int value_IGI)
 	}
 }
 
-
-VOID
-odm_AdaptivityInit(
-IN PDM_ODM_T pDM_Odm
-)
-{
-	if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-		pDM_Odm->TH_L2H_ini = 0xf8; // -8
-	}
-	if((pDM_Odm->SupportICType == ODM_RTL8192E)&&(pDM_Odm->SupportInterface == ODM_ITRF_PCIE))
-	{
-		pDM_Odm->TH_L2H_ini = 0xf0; // -16
-	}
-	else
-	{
-		pDM_Odm->TH_L2H_ini = 0xf9; // -7
-	}
-	
-	pDM_Odm->TH_EDCCA_HL_diff = 7;
-	pDM_Odm->IGI_Base = 0x32;
-	pDM_Odm->IGI_target = 0x1c;
-	pDM_Odm->ForceEDCCA = 0;
-	pDM_Odm->AdapEn_RSSI = 20;
-
-	//Reg524[11]=0 is easily to transmit packets during adaptivity test
-
-	//ODM_SetBBReg(pDM_Odm, 0x524, BIT11, 1);// stop counting if EDCCA is asserted
-}
-
 // Add by Neil Chen to enable edcca to MP Platform 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 
@@ -2149,119 +2117,6 @@ odm_DynamicEDCCA(
 
 #endif    // end MP platform support
 
-VOID
-odm_Adaptivity(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			IGI
-)
-{
-	s1Byte TH_L2H_dmc, TH_H2L_dmc;
-	s1Byte Diff, IGI_target;
-	BOOLEAN EDCCA_State = 0;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	BOOLEAN		bFwCurrentInPSMode=FALSE;	
-	PMGNT_INFO				pMgntInfo = &(pAdapter->MgntInfo);
-		
-	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
-
-	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
-	if(bFwCurrentInPSMode)
-		return;
-#endif
-
-	if(!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Go to odm_DynamicEDCCA() \n"));
-		// Add by Neil Chen to enable edcca to MP Platform 
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-		// Adjust EDCCA.
-		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-			odm_DynamicEDCCA(pDM_Odm);
-#endif
-		return;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_Adaptivity() =====> \n"));
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
-		pDM_Odm->ForceEDCCA, pDM_Odm->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff, pDM_Odm->AdapEn_RSSI));
-
-	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0); //ADC_mask enable
-	
-	if((!pDM_Odm->bLinked)||(*pDM_Odm->pChannel > 149)) // Band4 doesn't need adaptivity
-	{
-		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-		{
-			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
-			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
-		}
-		else
-			ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, (0x7f<<8) | 0x7f);
-		return;
-	}
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)	
-		if(pMgntInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0a); 
-		else
-			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0e);
-#endif
-	if(!pDM_Odm->ForceEDCCA)
-	{
-		if(pDM_Odm->RSSI_Min > pDM_Odm->AdapEn_RSSI)
-			EDCCA_State = 1;
-		else if(pDM_Odm->RSSI_Min < (pDM_Odm->AdapEn_RSSI - 5))
-			EDCCA_State = 0;
-	}
-	else
-		EDCCA_State = 1;
-	//if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (*pDM_Odm->pBandType == BAND_ON_5G))
-		//IGI_target = pDM_Odm->IGI_Base;
-	//else
-	{
-
-		if(*pDM_Odm->pBandWidth == ODM_BW20M) //CHANNEL_WIDTH_20
-			IGI_target = pDM_Odm->IGI_Base;
-		else if(*pDM_Odm->pBandWidth == ODM_BW40M)
-			IGI_target = pDM_Odm->IGI_Base + 2;
-		else if(*pDM_Odm->pBandWidth == ODM_BW80M)
-			IGI_target = pDM_Odm->IGI_Base + 6;
-		else
-			IGI_target = pDM_Odm->IGI_Base;
-	}
-
-	pDM_Odm->IGI_target = (u1Byte) IGI_target;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d\n",
-		(*pDM_Odm->pBandWidth==ODM_BW80M)?"80M":((*pDM_Odm->pBandWidth==ODM_BW40M)?"40M":"20M"), IGI_target, EDCCA_State));
-
-	if(EDCCA_State == 1)
-	{
-		Diff = IGI_target -(s1Byte)IGI;
-		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
-		if(TH_L2H_dmc > 10) 	TH_L2H_dmc = 10;
-		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
-	}
-	else
-	{
-		TH_L2H_dmc = 0x7f;
-		TH_H2L_dmc = 0x7f;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
-		IGI, TH_L2H_dmc, TH_H2L_dmc));
-
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
-	}
-	else
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u1Byte)TH_H2L_dmc<<8) | (u1Byte)TH_L2H_dmc);
-}
-
 VOID
 ODM_DynamicATCSwitch_init(
 	IN 		PDM_ODM_T 		pDM_Odm
@@ -2518,41 +2373,71 @@ ODM_Write_DIG(
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_REG(IGI_A,pDM_Odm)=0x%x, ODM_BIT(IGI,pDM_Odm)=0x%x \n",
 		ODM_REG(IGI_A,pDM_Odm),ODM_BIT(IGI,pDM_Odm)));
 
-	if(pDM_DigTable->CurIGValue != CurrentIGI)//if(pDM_DigTable->PreIGValue != CurrentIGI)
+	//1 Check initial gain by upper bound		
+	//if(!pDM_DigTable->bPSDInProgress)
 	{
-		if(pDM_Odm->SupportPlatform & (ODM_CE|ODM_WIN))
+		if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_TRACE, ("CurrentIGI(0x%02x) is larger than upper bound !!\n",CurrentIGI));
+			CurrentIGI = pDM_DigTable->rx_gain_range_max;
+		}
+		if(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY && pDM_Odm->adaptivity_flag == TRUE)
+		{
+			if(CurrentIGI > pDM_Odm->Adaptivity_IGI_upper)
+				CurrentIGI = pDM_Odm->Adaptivity_IGI_upper;
+	
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_write_DIG(): Adaptivity case: Force upper bound to 0x%x !!!!!!\n", CurrentIGI));
+		}
+	}
+
+	if(pDM_DigTable->CurIGValue != CurrentIGI)
+	{
+		//1 Set IGI value
+		if(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE))
 		{ 
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-			if(pDM_Odm->RFType != ODM_1T1R)
+			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if(pDM_Odm->RFType > ODM_1T1R)
 				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+			{
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
 			}
+		}
 		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
 		{
 			switch(*(pDM_Odm->pOnePathCCA))
 			{
-			case ODM_CCA_2R:
-			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-				break;
-			case ODM_CCA_1R_A:
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+				case ODM_CCA_2R:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+					if(pDM_Odm->RFType > ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					
+					if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+					{
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					}
+					break;
+				case ODM_CCA_1R_A:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
 					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
-				break;
-			case ODM_CCA_1R_B:
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+					break;
+				case ODM_CCA_1R_B:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
 					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
 					break;
-				}
+			}
 		}
-		
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("CurrentIGI(0x%02x). \n",CurrentIGI));
-		//pDM_DigTable->PreIGValue = pDM_DigTable->CurIGValue;
 		pDM_DigTable->CurIGValue = CurrentIGI;
-	}	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_Write_DIG():CurrentIGI=0x%x \n",CurrentIGI));
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("CurrentIGI(0x%02x). \n",CurrentIGI));
 	
 }
 
@@ -2710,7 +2595,6 @@ odm_DIG(
 	BOOLEAN						FirstConnect, FirstDisConnect;
 	u1Byte						dm_dig_max, dm_dig_min, offset;
 	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
-	u1Byte						Adap_IGI_Upper = pDM_Odm->IGI_target + 30 + (u1Byte) pDM_Odm->TH_L2H_ini -(u1Byte) pDM_Odm->TH_EDCCA_HL_diff;
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 // This should be moved out of OUTSRC
@@ -2722,10 +2606,6 @@ odm_DIG(
 		return;
 	}
 #endif
-/*
-	if (pDM_Odm->SupportICType==ODM_RTL8723B)
-		return;
-*/
 
 	if(pDM_Odm->bBtHsOperation)
 	{
@@ -2793,7 +2673,9 @@ odm_DIG(
 		        return;
 	        }
 	}
-		
+
+	//1 Update status
+#if (RTL8192D_SUPPORT==1) 
 	if(pDM_Odm->SupportICType == ODM_RTL8192D)
 	{
 		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
@@ -2801,13 +2683,13 @@ odm_DIG(
 			if(*(pDM_Odm->pbMasterOfDMSP))
 			{
 				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);	
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
 				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
 			}
 			else
 			{
 				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);	
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
 				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
 			}
 		}
@@ -2828,6 +2710,7 @@ odm_DIG(
 		}
 	}
 	else
+#endif
 	{	
 		DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
 		FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
@@ -2835,11 +2718,12 @@ odm_DIG(
 	}
 	
 	//1 Boundary Decision
-	if(pDM_Odm->SupportICType & (ODM_RTL8192C) &&(pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA)))
+#if (RTL8192C_SUPPORT==1) 
+	if((pDM_Odm->SupportICType & ODM_RTL8192C) && (pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA)))
 	{
+		//2 High power case
 		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
 		{
-
 			dm_dig_max = DM_DIG_MAX_AP_HP;
 			dm_dig_min = DM_DIG_MIN_AP_HP;
 		}
@@ -2851,6 +2735,7 @@ odm_DIG(
 		DIG_MaxOfMin = DM_DIG_MAX_AP_HP;
 	}
 	else
+#endif
 	{
 		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
 		{
@@ -3185,49 +3070,21 @@ odm_DIG(
 		}
 	}
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG End Adjust IGI\n"));
-	//1 Check initial gain by upper/lower bound
 
-	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
-		CurrentIGI = pDM_DigTable->rx_gain_range_max;
+	//1 Check initial gain by upper/lower bound
 	if(CurrentIGI < pDM_DigTable->rx_gain_range_min)
 		CurrentIGI = pDM_DigTable->rx_gain_range_min;
-
-	if(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)
-	{
-		if(CurrentIGI > Adap_IGI_Upper)
-			CurrentIGI = Adap_IGI_Upper;
-
-		if(pDM_Odm->IGI_LowerBound != 0)
-		{
-			if(CurrentIGI < pDM_Odm->IGI_LowerBound)
-				CurrentIGI = pDM_Odm->IGI_LowerBound;
-		}
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): pDM_Odm->IGI_LowerBound = %d\n", pDM_Odm->IGI_LowerBound));
-	}
 	
+	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
+		CurrentIGI = pDM_DigTable->rx_gain_range_max;
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): rx_gain_range_max=0x%x, rx_gain_range_min=0x%x\n", 
 		pDM_DigTable->rx_gain_range_max, pDM_DigTable->rx_gain_range_min));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TotalFA=%d\n", pFalseAlmCnt->Cnt_all));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x\n", CurrentIGI));
 
-	//2 High power RSSI threshold
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)	
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
-	//PMGNT_INFO			pMgntInfo	= &(pAdapter->MgntInfo);	
-	// for LC issue to dymanic modify DIG lower bound----------LC Mocca Issue
-	u8Byte			curTxOkCnt=0, curRxOkCnt=0;
-	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x, TotalFA=%d\n\n", CurrentIGI, pFalseAlmCnt->Cnt_all));	
 
-	//u8Byte			OKCntAll=0;
-	//static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
-	//u8Byte			CurByteCnt=0, PreByteCnt=0;
-	
-	curTxOkCnt = pAdapter->TxStats.NumTxBytesUnicast - lastTxOkCnt;
-	curRxOkCnt =pAdapter->RxStats.NumRxBytesUnicast - lastRxOkCnt;
-	lastTxOkCnt = pAdapter->TxStats.NumTxBytesUnicast;
-	lastRxOkCnt = pAdapter->RxStats.NumRxBytesUnicast;
-	//----------------------------------------------------------end for LC Mocca issue
+	//1 High power RSSI threshold
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
 	if((pDM_Odm->SupportICType == ODM_RTL8723A)&& (pHalData->UndecoratedSmoothedPWDB > DM_DIG_HIGH_PWR_THRESHOLD))
 	{
 		// High power IGI lower bound
@@ -3239,60 +3096,27 @@ odm_DIG(
 			CurrentIGI=DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
 		}
 	}
-	if((pDM_Odm->SupportICType & ODM_RTL8723A) && 
-			IS_WIRELESS_MODE_G(pAdapter))
-		{
-			if(pHalData->UndecoratedSmoothedPWDB > 0x28)
-			{
-				if(CurrentIGI < DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND)
-				{
-			 		//pDM_DigTable->CurIGValue = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
-					CurrentIGI = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
-				}	
-			} 
-		}	
-#if 0
-	if((pDM_Odm->SupportICType & ODM_RTL8723A)&&(pMgntInfo->CustomerID = RT_CID_LENOVO_CHINA))
+	if((pDM_Odm->SupportICType & ODM_RTL8723A) && IS_WIRELESS_MODE_G(pAdapter))
 	{
-		OKCntAll = (curTxOkCnt+curRxOkCnt);
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue(%#x)\n", CurrentIGI));
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): UndecoratedSmoothedPWDB(%#x)\n", pHalData->UndecoratedSmoothedPWDB));
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): OKCntAll(%#x)\n", OKCntAll));
-		//8723AS_VAU
-		if(pDM_Odm->SupportInterface==ODM_ITRF_USB)
+		if(pHalData->UndecoratedSmoothedPWDB > 0x28)
 		{
-			if(pHalData->UndecoratedSmoothedPWDB < 12)
+			if(CurrentIGI < DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND)
 			{
-				if(CurrentIGI > DM_DIG_MIN_NIC)
-				{
-					if(OKCntAll >= 1500000) 		 // >=6Mbps
-						CurrentIGI=0x1B;
-					else if(OKCntAll >= 1000000) 	 //4Mbps
-						CurrentIGI=0x1A;
-					else if(OKCntAll >= 500000)		 //2Mbps
-						CurrentIGI=0x19;
-					else if(OKCntAll >= 250000)		//1Mbps
-						CurrentIGI=0x18;
-					else
-					{
-						CurrentIGI=0x17;		//SCAN mode
-					}
-				}
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("Modify---->CurIGValue(%#x)\n", CurrentIGI));	
-			}
-		}
-	}	
-#endif	
-}
+			 	//pDM_DigTable->CurIGValue = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+				CurrentIGI = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+			}	
+		} 
+	}
 #endif
-		
+
+	//1 Update status
 #if (RTL8192D_SUPPORT==1) 
 	if(pDM_Odm->SupportICType == ODM_RTL8192D)
 	{
 		//sherry  delete DualMacSmartConncurrent 20110517
 		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
 		{
-			ODM_Write_DIG_DMSP(pDM_Odm, (u1Byte)CurrentIGI);//ODM_Write_DIG_DMSP(pDM_Odm, pDM_DigTable->CurIGValue);
+			ODM_Write_DIG_DMSP(pDM_Odm, CurrentIGI);//ODM_Write_DIG_DMSP(pDM_Odm, pDM_DigTable->CurIGValue);
 			if(*(pDM_Odm->pbMasterOfDMSP))
 			{
 				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
@@ -3322,39 +3146,31 @@ odm_DIG(
 	else
 #endif
 	{
+#if ((DM_ODM_SUPPORT_TYPE & ODM_WIN) || ((DM_ODM_SUPPORT_TYPE & ODM_CE) && (ODM_CONFIG_BT_COEXIST == 1)))
 		if(pDM_Odm->bBtHsOperation)
 		{
 			if(pDM_Odm->bLinked)
 			{
 				if(pDM_DigTable->BT30_CurIGI > (CurrentIGI))
-				{
 					ODM_Write_DIG(pDM_Odm, CurrentIGI);
-					
-				}	
 				else
-				{
 					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);
-				}
+					
 				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
 				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
 			}
 			else
 			{
 				if(pDM_Odm->bLinkInProcess)
-				{
 					ODM_Write_DIG(pDM_Odm, 0x1c);
-				}
 				else if(pDM_Odm->bBtConnectProcess)
-				{
 					ODM_Write_DIG(pDM_Odm, 0x28);
-				}
 				else
-				{
 					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);	
-				}
 			}
-		}	
+		}
 		else		// BT is not using
+#endif
 		{
 			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
 			pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
@@ -3363,7 +3179,6 @@ odm_DIG(
 	}
 }
 
-
 BOOLEAN 
 odm_DigAbort(
 	IN		PDM_ODM_T		pDM_Odm
@@ -14192,3 +14007,51 @@ void odm_dtc(PDM_ODM_T pDM_Odm)
 
 #endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
 
+PVOID
+PhyDM_Get_Structure(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Structure_Type
+)
+
+{
+	PVOID	pStruct = NULL;
+#if RTL8195A_SUPPORT
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &FalseAlmCnt;
+		break;
+		
+		case	PHYDM_CFOTRACK:
+			pStruct = &DM_CfoTrack;
+		break;
+
+		case	PHYDM_ADAPTIVITY:
+			pStruct = &(pDM_Odm->Adaptivity);
+		break;
+		
+		default:
+		break;
+	}
+
+#else
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &(pDM_Odm->FalseAlmCnt);
+		break;
+		
+		//case	PHYDM_CFOTRACK:
+		//	pStruct = &(pDM_Odm->DM_CfoTrack);
+		//break;
+
+		case	PHYDM_ADAPTIVITY:
+			pStruct = &(pDM_Odm->Adaptivity);
+		break;
+		
+		default:
+		break;
+	}
+
+#endif
+	return	pStruct;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.h
index d5983d21a19d..7b9664f0e95b 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm.h
@@ -22,6 +22,8 @@
 #ifndef	__HALDMOUTSRC_H__
 #define __HALDMOUTSRC_H__
 
+#include "PhyDM_Adaptivity.h"
+
 //============================================================
 // Definition 
 //============================================================
@@ -748,12 +750,15 @@ typedef enum _ODM_Support_Ability_Definition
 	ODM_BB_RXHP					= BIT12,
 	ODM_BB_ADAPTIVITY				= BIT13,
 	ODM_BB_DYNAMIC_ATC			= BIT14,
+	ODM_BB_NHM_CNT				= BIT15,
+	ODM_BB_PRIMARY_CCA			= BIT16,
+	ODM_BB_TXBF				= BIT17,
 	
 	//
-	// MAC DM section BIT 16-23
+	// MAC DM section BIT 20-23
 	//
-	ODM_MAC_EDCA_TURBO			= BIT16,
-	ODM_MAC_EARLY_MODE			= BIT17,
+	ODM_MAC_EDCA_TURBO			= BIT20,
+	ODM_MAC_EARLY_MODE			= BIT21,
 	
 	//
 	// RF ODM section BIT 24-31
@@ -776,21 +781,26 @@ typedef enum tag_ODM_Support_Interface_Definition
 // ODM_CMNINFO_IC_TYPE
 typedef enum tag_ODM_Support_IC_Type_Definition
 {
-	ODM_RTL8192S 	=	BIT0,
-	ODM_RTL8192C 	=	BIT1,
-	ODM_RTL8192D 	=	BIT2,
-	ODM_RTL8723A 	=	BIT3,
-	ODM_RTL8188E 	=	BIT4,
+	ODM_RTL8192S	=	BIT0,
+	ODM_RTL8192C	=	BIT1,
+	ODM_RTL8192D	=	BIT2,
+	ODM_RTL8723A	=	BIT3,
+	ODM_RTL8188E	=	BIT4,
 	ODM_RTL8812 	=	BIT5,
 	ODM_RTL8821 	=	BIT6,
-	ODM_RTL8192E 	=	BIT7,	
+	ODM_RTL8192E	=	BIT7,	
 	ODM_RTL8723B	=	BIT8,
-	ODM_RTL8813A	=	BIT9,	
-	ODM_RTL8881A 	=	BIT10
+	ODM_RTL8814A	=	BIT9,	
+	ODM_RTL8881A	=	BIT10,
+	ODM_RTL8821B	=	BIT11,
+	ODM_RTL8822B	=	BIT12,
+	ODM_RTL8703B	=	BIT13,
+	ODM_RTL8195A	=	BIT14,
+	ODM_RTL8188F	=	BIT15
 }ODM_IC_TYPE_E;
 
 #define ODM_IC_11N_SERIES		(ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B)
-#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8813A|ODM_RTL8881A)
+#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8814A|ODM_RTL8881A)
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 #ifdef RTK_AC_SUPPORT
@@ -802,6 +812,14 @@ typedef enum tag_ODM_Support_IC_Type_Definition
 #define ODM_IC_11AC_SERIES_SUPPORT		1
 #endif
 
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#ifdef CONFIG_BT_COEXIST
+#define ODM_CONFIG_BT_COEXIST				1
+#else
+#define ODM_CONFIG_BT_COEXIST				0
+#endif
+#endif
+
 //ODM_CMNINFO_CUT_VER
 typedef enum tag_ODM_Cut_Version_Definition
 {
@@ -1464,15 +1482,22 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	BOOLEAN			IsBbSwingOffsetPositiveA;
 	u4Byte			BbSwingOffsetB;
 	BOOLEAN			IsBbSwingOffsetPositiveB;
+
+	//For Adaptivtiy
+	u2Byte			NHM_cnt_0;
+	u2Byte			NHM_cnt_1;
 	s1Byte			TH_L2H_ini;
 	s1Byte			TH_EDCCA_HL_diff;
-	s1Byte			IGI_Base;
-	u1Byte			IGI_target;
-	BOOLEAN			ForceEDCCA;
-	u1Byte			AdapEn_RSSI;
-	s1Byte			Force_TH_H;
-	s1Byte			Force_TH_L;
-	u1Byte			IGI_LowerBound;
+	s1Byte			TH_L2H_ini_backup;
+	BOOLEAN			Carrier_Sense_enable;
+	u1Byte			Adaptivity_IGI_upper;
+	BOOLEAN			adaptivity_flag;
+	u1Byte			DCbackoff;
+	BOOLEAN			Adaptivity_enable;
+	u1Byte			APTotalNum;
+	ADAPTIVITY_STATISTICS	Adaptivity;
+	//For Adaptivtiy
+	
 	u1Byte	                antdiv_rssi;
 	u1Byte			AntType;
 	u1Byte			pre_AntType;
@@ -2366,5 +2391,19 @@ ODM_DynamicARFBSelect(
 void odm_dtc(PDM_ODM_T pDM_Odm);
 #endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
 
+typedef enum _PHYDM_STRUCTURE_TYPE{
+	PHYDM_FALSEALMCNT,
+	PHYDM_CFOTRACK,
+	PHYDM_ADAPTIVITY,
+	PHYDM_ROMINFO,
+	
+}PHYDM_STRUCTURE_TYPE;
+
+PVOID
+PhyDM_Get_Structure(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Structure_Type
+);
+
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
index a5955ad059d7..bbe652377427 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
@@ -1490,7 +1490,7 @@ odm_Process_RSSIForDM(
 	PSTA_INFO_T           	pEntry;
 
 
-	if(pPktinfo->StationID == 0xFF)
+	if (pPktinfo->StationID >= ODM_ASSOCIATE_ENTRY_NUM)
 		return;
 
 	//
@@ -1905,7 +1905,7 @@ ODM_ConfigRFWithHeaderFile(
 #endif
 
 #if (RTL8813A_SUPPORT == 1)
-	if (pDM_Odm->SupportICType == ODM_RTL8813A)
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
 	{
 		/*
 		if(ConfigType == CONFIG_RF_TXPWR_LMT) {
@@ -2137,7 +2137,7 @@ ODM_ConfigBBWithHeaderFile(
 	}
 #endif
 #if (RTL8813A_SUPPORT == 1)
-    if(pDM_Odm->SupportICType == ODM_RTL8813A)
+    if(pDM_Odm->SupportICType == ODM_RTL8814A)
 	{
 
 		if(ConfigType == CONFIG_BB_PHY_REG)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11AC.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11AC.h
index 1193653a5272..ad680c88457e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11AC.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11AC.h
@@ -29,19 +29,41 @@
 //PAGE 8
 #define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
 #define	ODM_REG_BB_RX_PATH_11AC			0x808
+#define	ODM_REG_BB_TX_PATH_11AC			0x80c
+#define	ODM_REG_BB_ATC_11AC				0x860
+#define	ODM_REG_EDCCA_POWER_CAL		0x8dc
+#define	ODM_REG_DBG_RPT_11AC			0x8fc
 //PAGE 9
+#define	ODM_REG_EDCCA_DOWN_OPT			0x900
+#define	ODM_REG_ACBB_EDCCA_ENHANCE		0x944
 #define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+#define	ODM_REG_NHM_TIMER_11AC			0x990
+#define	ODM_REG_NHM_TH9_TH10_11AC		0x994
+#define	ODM_REG_NHM_TH3_TO_TH0_11AC	0x998
+#define	ODM_REG_NHM_TH7_TO_TH4_11AC	0x99c
+#define	ODM_REG_NHM_TH8_11AC			0x9a0
+#define	ODM_REG_NHM_9E8_11AC			0x9e8
 //PAGE A
 #define	ODM_REG_CCK_CCA_11AC			0xA0A
 #define	ODM_REG_CCK_FA_RST_11AC			0xA2C
 #define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE B
+#define	ODM_REG_RST_RPT_11AC				0xB58
 //PAGE C
+#define	ODM_REG_TRMUX_11AC				0xC08
 #define	ODM_REG_IGI_A_11AC				0xC50
 //PAGE E
 #define	ODM_REG_IGI_B_11AC				0xE50
+#define	ODM_REG_TRMUX_11AC_B			0xE08
 //PAGE F
+#define	ODM_REG_CCK_CCA_CNT_11AC		0xF08
 #define	ODM_REG_OFDM_FA_11AC			0xF48
-
+#define	ODM_REG_RPT_11AC					0xfa0
+#define	ODM_REG_NHM_CNT_11AC			0xfa8
+//PAGE 18
+#define	ODM_REG_IGI_C_11AC				0x1850
+//PAGE 1A
+#define	ODM_REG_IGI_D_11AC				0x1A50
 
 //2 MAC REG LIST
 #define	ODM_REG_RESP_TX_11AC				0x6D8
@@ -52,6 +74,8 @@
 #define	ODM_BIT_IGI_11AC					0xFFFFFFFF
 #define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT16
 #define	ODM_BIT_BB_RX_PATH_11AC			0xF
+#define	ODM_BIT_BB_TX_PATH_11AC			0xF
+#define	ODM_BIT_BB_ATC_11AC				BIT14
 
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11N.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11N.h
index b6236092fb5a..7ed8879c3449 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11N.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_RegDefine11N.h
@@ -46,6 +46,7 @@
 #define	ODM_REG_TX_ANT_CTRL_11N			0x80C
 #define	ODM_REG_BB_PWR_SAV5_11N			0x818
 #define	ODM_REG_CCK_RPT_FORMAT_11N		0x824
+#define	ODM_REG_CCK_RPT_FORMAT_11N_B	0x82C
 #define	ODM_REG_RX_DEFUALT_A_11N		0x858
 #define	ODM_REG_RX_DEFUALT_B_11N		0x85A
 #define	ODM_REG_BB_PWR_SAV3_11N			0x85C
@@ -56,10 +57,20 @@
 #define	ODM_REG_ANTSEL_PATH_11N			0x878
 #define	ODM_REG_BB_3WIRE_11N			0x88C
 #define	ODM_REG_SC_CNT_11N				0x8C4
-#define	ODM_REG_PSD_DATA_11N			0x8B4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_NHM_TIMER_11N			0x894
+#define	ODM_REG_NHM_TH9_TH10_11N		0x890
+#define	ODM_REG_NHM_TH3_TO_TH0_11N		0x898
+#define	ODM_REG_NHM_TH7_TO_TH4_11N		0x89c
+#define	ODM_REG_NHM_CNT_11N				0x8d8
 //PAGE 9
+#define	ODM_REG_DBG_RPT_11N				0x908
+#define	ODM_REG_BB_TX_PATH_11N			0x90c
 #define	ODM_REG_ANT_MAPPING1_11N		0x914
 #define	ODM_REG_ANT_MAPPING2_11N		0x918
+#define	ODM_REG_EDCCA_DOWN_OPT_11N	0x948
+
 //PAGE A
 #define	ODM_REG_CCK_ANTDIV_PARA1_11N	0xA00
 #define	ODM_REG_CCK_CCA_11N				0xA0A
@@ -108,9 +119,11 @@
 #define	ODM_REG_OFDM_FA_TYPE1_11N		0xCF0
 //PAGE D
 #define	ODM_REG_OFDM_FA_RSTD_11N		0xD00
+#define	ODM_REG_BB_ATC_11N				0xD2C
 #define	ODM_REG_OFDM_FA_TYPE2_11N		0xDA0
 #define	ODM_REG_OFDM_FA_TYPE3_11N		0xDA4
 #define	ODM_REG_OFDM_FA_TYPE4_11N		0xDA8
+#define	ODM_REG_RPT_11N					0xDF4
 //PAGE E
 #define	ODM_REG_TXAGC_A_6_18_11N		0xE00
 #define	ODM_REG_TXAGC_A_24_54_11N		0xE04
@@ -119,6 +132,7 @@
 #define	ODM_REG_TXAGC_A_MCS4_7_11N		0xE14
 #define	ODM_REG_TXAGC_A_MCS8_11_11N	0xE18
 #define	ODM_REG_TXAGC_A_MCS12_15_11N	0xE1C
+#define	DOM_REG_EDCCA_DCNF_11N			0xE24
 #define	ODM_REG_FPGA0_IQK_11N			0xE28
 #define	ODM_REG_TXIQK_TONE_A_11N		0xE30
 #define	ODM_REG_RXIQK_TONE_A_11N		0xE34
@@ -143,12 +157,8 @@
 #define	ODM_REG_STANDBY_11N				0xEDC
 #define	ODM_REG_SLEEP_11N				0xEE0
 #define	ODM_REG_PMPD_ANAEN_11N			0xEEC
-
-
-
-
-
-
+#define	ODM_REG_IGI_C_11N					0xF84
+#define	ODM_REG_IGI_D_11N					0xF88
 
 //2 MAC REG LIST
 #define	ODM_REG_BB_RST_11N				0x02
@@ -169,6 +179,9 @@
 #define	ODM_BIT_IGI_11N					0x0000007F
 #define	ODM_BIT_CCK_RPT_FORMAT_11N		BIT9
 #define	ODM_BIT_BB_RX_PATH_11N			0xF
+#define	ODM_BIT_BB_TX_PATH_11N			0xF
+#define	ODM_BIT_BB_ATC_11N				BIT11
+
 
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_debug.h
index 0a32f85ef34d..73c0d6fb30f7 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_debug.h
@@ -70,32 +70,38 @@
 //
 //-----------------------------------------------------------------------------
 //BB Functions
-#define ODM_COMP_DIG				BIT0	
-#define ODM_COMP_RA_MASK			BIT1	
+#define ODM_COMP_DIG					BIT0	
+#define ODM_COMP_RA_MASK				BIT1	
 #define ODM_COMP_DYNAMIC_TXPWR		BIT2
 #define ODM_COMP_FA_CNT				BIT3
 #define ODM_COMP_RSSI_MONITOR		BIT4
 #define ODM_COMP_CCK_PD				BIT5
-#define ODM_COMP_ANT_DIV			BIT6
+#define ODM_COMP_ANT_DIV				BIT6
 #define ODM_COMP_PWR_SAVE			BIT7
 #define ODM_COMP_PWR_TRAIN			BIT8
 #define ODM_COMP_RATE_ADAPTIVE		BIT9
-#define ODM_COMP_PATH_DIV			BIT10
-#define ODM_COMP_PSD				BIT11
+#define ODM_COMP_PATH_DIV				BIT10
+#define ODM_COMP_PSD					BIT11
 #define ODM_COMP_DYNAMIC_PRICCA		BIT12
-#define ODM_COMP_RXHP				BIT13			
+#define ODM_COMP_RXHP					BIT13
 #define ODM_COMP_MP					BIT14
-#define ODM_COMP_DYNAMIC_ATC			BIT15
+#define ODM_COMP_DYNAMIC_ATC		BIT15
+#define ODM_COMP_ACS					BIT16
+#define PHYDM_COMP_ADAPTIVITY			BIT17
+#define PHYDM_COMP_RA_DBG				BIT18
+#define PHYDM_COMP_TXBF				BIT19
 //MAC Functions
-#define ODM_COMP_EDCA_TURBO			BIT16
-#define ODM_COMP_EARLY_MODE			BIT17
+#define ODM_COMP_EDCA_TURBO			BIT20
+#define ODM_COMP_EARLY_MODE			BIT21
+#define ODM_FW_DEBUG_TRACE			BIT22
 //RF Functions
 #define ODM_COMP_TX_PWR_TRACK		BIT24
 #define ODM_COMP_RX_GAIN_TRACK		BIT25
-#define ODM_COMP_CALIBRATION		BIT26
+#define ODM_COMP_CALIBRATION			BIT26
 //Common Functions
+#define	BEAMFORMING_DEBUG			BIT29
 #define ODM_COMP_COMMON				BIT30
-#define ODM_COMP_INIT				BIT31
+#define ODM_COMP_INIT					BIT31
 
 /*------------------------Export Marco Definition---------------------------*/
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_dm.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_dm.c
index dc966775a17f..3f57dfe56b54 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_dm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_dm.c
@@ -347,11 +347,11 @@ static void Update_ODM_ComInfo_88E(PADAPTER	Adapter)
 		| ODM_BB_PWR_SAVE		
 		| ODM_RF_CALIBRATION
 		| ODM_RF_TX_PWR_TRACK
-#ifdef CONFIG_ODM_ADAPTIVITY
-		| ODM_BB_ADAPTIVITY
-#endif
 		;
 
+	if (rtw_odm_adaptivity_needed(Adapter) == _TRUE)
+		pdmpriv->InitODMFlag |= ODM_BB_ADAPTIVITY;
+
 	if (!Adapter->registrypriv.qos_opt_enable) {
 		pdmpriv->InitODMFlag |= ODM_MAC_EDCA_TURBO;
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
index 0039b76730f1..db0f41d741d7 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
@@ -276,7 +276,7 @@ void update_recvframe_phyinfo_88e(
 	ODM_PACKET_INFO_T	pkt_info;
 	u8 *sa = NULL;
 	struct sta_priv *pstapriv;
-	struct sta_info *psta;
+	struct sta_info *psta = NULL;
 	//_irqL		irqL;
 	
 	pkt_info.bPacketMatchBSSID =_FALSE;
@@ -315,15 +315,23 @@ void update_recvframe_phyinfo_88e(
 	}	
 */	
 	sa = get_ta(wlanhdr);	
-	
-	pstapriv = &padapter->stapriv;
+
 	pkt_info.StationID = 0xFF;
-	psta = rtw_get_stainfo(pstapriv, sa);
-	if (psta)
-	{
-		pkt_info.StationID = psta->mac_id;		
-		//DBG_8192C("%s ==> StationID(%d)\n",__FUNCTION__,pkt_info.StationID);
-	}			
+
+	if (_rtw_memcmp(myid(&padapter->eeprompriv), sa, ETH_ALEN) == _TRUE) {
+		static u32 start_time = 0;
+
+		if ((start_time == 0) || (rtw_get_passing_time_ms(start_time) > 5000)) {
+			DBG_871X_LEVEL(_drv_always_, "Warning!!! %s: Confilc mac addr!!\n", __func__);
+			start_time = rtw_get_current_time();
+		}
+	} else {
+		pstapriv = &padapter->stapriv;
+		psta = rtw_get_stainfo(pstapriv, sa);
+		if (psta)
+			pkt_info.StationID = psta->mac_id;
+	}
+
 	pkt_info.DataRate = pattrib->data_rate;	
 	//rtl8188e_query_rx_phy_status(precvframe, pphy_status);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_ops_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_ops_linux.c
index 51d33c058041..bdc468bce1e4 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_ops_linux.c
@@ -950,31 +950,19 @@ void rtl8188eu_recv_tasklet(void *priv)
 			rtw_skb_free(pskb);
 			break;
 		}
-	
-		recvbuf2recvframe(padapter, pskb);
-
-#ifdef CONFIG_PREALLOC_RECV_SKB
 
+		recvbuf2recvframe(padapter, pskb);
 		skb_reset_tail_pointer(pskb);
-
 		pskb->len = 0;
 		
 		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
-		
-#else
-		rtw_skb_free(pskb);
-#endif
-				
-	}
 
-	while (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue)))
-	{
-		DBG_871X("dequeue_recvbuf %p\n", precvbuf);
-		precvbuf->pskb = NULL;
-		precvbuf->reuse = _FALSE;
-		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		if (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue))) {
+			precvbuf->pskb = NULL;
+			precvbuf->reuse = _FALSE;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		}
 	}
-	
 }
 
 
@@ -1133,12 +1121,14 @@ _func_enter_;
 	//re-assign for linux based on skb
 	if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
 	{
+		#ifndef CONFIG_FIX_NR_BULKIN_BUFFER
 		precvbuf->pskb = rtw_skb_alloc(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+		#endif
 
 		if(precvbuf->pskb == NULL)		
 		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
-			DBG_8192C("#### usb_read_port() alloc_skb fail!  precvbuf=%p #####\n", precvbuf);
+			if (0)
+				DBG_871X("usb_read_port() enqueue precvbuf=%p \n", precvbuf);
 			//enqueue precvbuf and wait for free skb
 			rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);
 			return _FAIL;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
index cd868dff3c9b..384fe534913a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
@@ -36,7 +36,7 @@
 
 #define PLATFORM_LINUX	
 
-#define CONFIG_IOCTL_CFG80211 
+//#define CONFIG_IOCTL_CFG80211 
 //#define CONFIG_IEEE80211W
 
 #if defined(CONFIG_PLATFORM_ACTIONS_ATM702X)
@@ -46,7 +46,7 @@
 #endif
 
 #ifdef CONFIG_IOCTL_CFG80211
-	#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
+	//#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
 	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
 	//#define CONFIG_DEBUG_CFG80211 
 	//#define CONFIG_DRV_ISSUE_PROV_REQ // IOT FOR S2
@@ -107,7 +107,7 @@
 	#endif
 
 
-	#define CONFIG_CONCURRENT_MODE 
+	//#define CONFIG_CONCURRENT_MODE 
 	#ifdef CONFIG_CONCURRENT_MODE
 		//#define CONFIG_HWPORT_SWAP				//Port0->Sec , Port1 -> Pri
 		#define CONFIG_RUNTIME_PORT_SWITCH
@@ -151,7 +151,7 @@
 	//#define CONFIG_DBG_P2P
 
 	#define CONFIG_P2P_PS
-	#define CONFIG_P2P_IPS
+	//#define CONFIG_P2P_IPS
 	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
 	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  //replace CONFIG_P2P_CHK_INVITE_CH_LIST flag
 	#define CONFIG_P2P_INVITE_IOT
@@ -220,7 +220,6 @@
 	#define CONFIG_USB_RX_AGGREGATION	
 #endif
 
-#define CONFIG_PREALLOC_RECV_SKB	
 //#define CONFIG_REDUCE_USB_TX_INT		// Trade-off: Improve performance, but may cause TX URBs blocked by USB Host/Bus driver on few platforms.
 //#define CONFIG_EASY_REPLACEMENT	
 
@@ -230,7 +229,12 @@
 //#define CONFIG_USE_USB_BUFFER_ALLOC_TX 	// Trade-off: For TX path, improve stability on some platforms, but may cause performance degrade on other platforms.
 //#define CONFIG_USE_USB_BUFFER_ALLOC_RX 	// For RX path
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-#undef CONFIG_PREALLOC_RECV_SKB
+
+#else
+	#define CONFIG_PREALLOC_RECV_SKB
+	#ifdef CONFIG_PREALLOC_RECV_SKB
+		//#define CONFIG_FIX_NR_BULKIN_BUFFER /* only use PREALLOC_RECV_SKB buffer, don't alloc skb at runtime */
+	#endif
 #endif
 
 /* 
@@ -352,6 +356,8 @@
 #define RTL8192E_SUPPORT				0
 
 #define RTL8813A_SUPPORT				0
+#define RTL8195A_SUPPORT				0
+
 
 //#if (RTL8188E_SUPPORT==1)
 #define RATE_ADAPTIVE_SUPPORT 			1
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
index 5b0c3ca1fab7..a8f219d2fbec 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
@@ -75,10 +75,29 @@
 
 #define DYNAMIC_CAMID_ALLOC
 
+#define RTW_SCAN_SPARSE_MIRACAST 1
+#define RTW_SCAN_SPARSE_BG 0
+
 #ifndef CONFIG_RTW_HIQ_FILTER
 	#define CONFIG_RTW_HIQ_FILTER 1
 #endif
 
+#ifndef CONFIG_RTW_ADAPTIVITY_EN
+	#define CONFIG_RTW_ADAPTIVITY_EN 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_MODE
+	#define CONFIG_RTW_ADAPTIVITY_MODE 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DML
+	#define CONFIG_RTW_ADAPTIVITY_DML 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DC_BACKOFF
+	#define CONFIG_RTW_ADAPTIVITY_DC_BACKOFF 2
+#endif
+
 //#include <rtl871x_byteorder.h>
 
 #endif // __DRV_CONF_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_types.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_types.h
index b2294c39fdb5..7573a97fb3dc 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_types.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_types.h
@@ -322,6 +322,12 @@ struct registry_priv
 	u8 qos_opt_enable;
 
 	u8 hiq_filter;
+
+	u8 adaptivity_en;
+	u8 adaptivity_mode;
+	u8 adaptivity_dml;
+	u8 adaptivity_dc_backoff;
+
 };
 
 
@@ -595,6 +601,7 @@ struct dvobj_priv
 
 #define dvobj_to_pwrctl(dvobj) (&(dvobj->pwrctl_priv))
 #define pwrctl_to_dvobj(pwrctl) container_of(pwrctl, struct dvobj_priv, pwrctl_priv)
+#define dvobj_to_regsty(dvobj) (&(dvobj->if1->registrypriv))
 
 #ifdef PLATFORM_LINUX
 static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
index d21341d65385..e8e933133084 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
@@ -98,6 +98,7 @@ struct rtw_wdev_priv
 
 	u8 bandroid_scan;
 	bool block;
+	bool block_scan;
 	bool power_mgmt;
 
 #ifdef CONFIG_CONCURRENT_MODE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service.h
index 76026b9723ef..b262938ee10f 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service.h
@@ -474,6 +474,8 @@ __inline static u32 bitshift(u32 bitmask)
 	return i;
 }
 
+#define rtw_min(a, b) ((a>b)?b:a)
+
 #ifndef MAC_FMT
 #define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_android.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_android.h
index 5f3892ca555a..9cae3eb2f210 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_android.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_android.h
@@ -45,6 +45,9 @@ enum ANDROID_WIFI_CMD {
 	ANDROID_WIFI_CMD_P2P_GET_NOA,	
 	ANDROID_WIFI_CMD_P2P_SET_PS,	
 	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+
+	ANDROID_WIFI_CMD_MIRACAST,
+	
 #ifdef CONFIG_PNO_SUPPORT
 	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
 	ANDROID_WIFI_CMD_PNOSETUP_SET,
@@ -54,6 +57,7 @@ enum ANDROID_WIFI_CMD {
 
 	ANDROID_WIFI_CMD_MACADDR,
 
+	ANDROID_WIFI_CMD_BLOCK_SCAN,
 	ANDROID_WIFI_CMD_BLOCK,
 
 	ANDROID_WIFI_CMD_WFD_ENABLE,
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
index 4e0642a2778d..79eeb00fdf2d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
@@ -191,6 +191,16 @@ struct tx_invite_resp_info{
 	u8					token;	//	Used to record the dialog token of p2p invitation request frame.
 };
 
+#define MIRACAST_DISABLED 0
+#define MIRACAST_SOURCE 1
+#define MIRACAST_SINK 2
+#define MIRACAST_INVALID 3
+
+#define is_miracast_enabled(mode) \
+	(mode == MIRACAST_SOURCE || mode == MIRACAST_SINK)
+
+const char *get_miracast_mode_str(int mode);
+
 #ifdef CONFIG_WFD
 
 struct wifi_display_info{
@@ -212,7 +222,7 @@ struct wifi_display_info{
 													//	0 -> WFD Source Device
 													//	1 -> WFD Primary Sink Device
 	enum	SCAN_RESULT_TYPE	scan_result_type;	//	Used when P2P is enable. This parameter will impact the scan result.
-
+	u8 stack_wfd_mode;
 };
 #endif //CONFIG_WFD
 
@@ -257,8 +267,8 @@ struct cfg80211_wifidirect_info{
 	u8						restore_channel;
 	struct ieee80211_channel	remain_on_ch_channel;
 	enum nl80211_channel_type	remain_on_ch_type;
-	u64						remain_on_ch_cookie;
-	bool not_indic_ro_ch_exp;
+	ATOMIC_T ro_ch_cookie_gen;
+	u64 remain_on_ch_cookie;
 	bool is_ro_ch;
 	u32 last_ro_ch_time; /* this will be updated at the beginning and end of ro_ch */
 };
@@ -796,6 +806,9 @@ extern void rtw_free_assoc_resources(_adapter* adapter, int lock_scanned_queue);
 extern void rtw_indicate_disconnect(_adapter* adapter);
 extern void rtw_indicate_connect(_adapter* adapter);
 void rtw_indicate_scan_done( _adapter *padapter, bool aborted);
+
+u32 rtw_scan_abort_timeout(_adapter *adapter, u32 timeout_ms);
+void rtw_scan_abort_no_wait(_adapter *adapter);
 void rtw_scan_abort(_adapter *adapter);
 
 extern int rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie,u8 *out_ie,uint in_len);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
index 82d20cf3c2a8..3bb9c5287e1d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
@@ -478,6 +478,7 @@ struct mlme_ext_info
 
 #if defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE) || defined(CONFIG_ATMEL_RC_PATCH)
 	u8 scan_cnt;
+	u8 backop_cnt;
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 };
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_odm.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_odm.h
index 50edd0124aee..95f6ac11fae9 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_odm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_odm.h
@@ -34,9 +34,9 @@ void rtw_odm_dbg_level_set(_adapter *adapter, u32 level);
 void rtw_odm_ability_msg(void *sel, _adapter *adapter);
 void rtw_odm_ability_set(_adapter *adapter, u32 ability);
 
+bool rtw_odm_adaptivity_needed(_adapter *adapter);
 void rtw_odm_adaptivity_parm_msg(void *sel,_adapter *adapter);
-void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
-	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound);
+void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff);
 void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter);
 #endif // __RTW_ODM_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
index 2d5046f64e45..a0e3beb5b83f 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
@@ -1 +1 @@
-#define DRIVERVERSION	"v4.3.0.7_12758.20141114"
+#define DRIVERVERSION	"v4.3.0.8_13522.20150213_beta"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
index 1a01894444c9..37029ddfa093 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
@@ -26,6 +26,7 @@
 #include <rtw_wifi_regd.h>
 
 #define RTW_MAX_MGMT_TX_CNT (8)
+#define RTW_MAX_MGMT_TX_MS_GAS (500)
 
 #define RTW_SCAN_IE_LEN_MAX      2304
 #define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 5000 //ms
@@ -2139,6 +2140,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 	struct cfg80211_ssid *ssids = request->ssids;
 	int social_channel = 0, j = 0;
 	bool need_indicate_scan_done = _FALSE;
+	bool ps_denied = _FALSE;
 
 	_adapter *padapter;
 	struct rtw_wdev_priv *pwdev_priv;
@@ -2197,6 +2199,12 @@ if (padapter->registrypriv.mp_mode == 1)
 	pwdev_priv->scan_request = request;
 	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
 
+	if (adapter_wdev_data(padapter)->block_scan == _TRUE) {
+		DBG_871X(FUNC_ADPT_FMT" wdev_priv.block_scan is set\n", FUNC_ADPT_ARG(padapter));
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	}
+
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
 #ifdef CONFIG_DEBUG_CFG80211
@@ -2218,6 +2226,7 @@ if (padapter->registrypriv.mp_mode == 1)
 	}
 
 	rtw_ps_deny(padapter, PS_DENY_SCAN);
+	ps_denied = _TRUE;
 	if(_FAIL == rtw_pwr_wakeup(padapter)) {
 		need_indicate_scan_done = _TRUE;
 		goto check_need_indicate_scan_done;
@@ -2411,7 +2420,8 @@ if (padapter->registrypriv.mp_mode == 1)
 	}
 
 cancel_ps_deny:
-	rtw_ps_deny_cancel(padapter, PS_DENY_SCAN);
+	if (ps_denied == _TRUE)
+		rtw_ps_deny_cancel(padapter, PS_DENY_SCAN);
 
 exit:
 	return ret;
@@ -4204,7 +4214,10 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 				pstapriv->asoc_list_cnt--;
 
 				//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-				updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+				if (check_fwstate(pmlmepriv, (WIFI_AP_STATE)) == _TRUE)
+					updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_PREV_AUTH_NOT_VALID);
+				else
+					updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
 				//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
 				psta = NULL;
@@ -4386,11 +4399,14 @@ void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const
 
 	rtw_action_frame_parse(frame, frame_len, &category, &action);
 
-	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
-	if (msg)
-		DBG_871X("RTW_Rx:%s\n", msg);
-	else
-		DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
+	if (action == ACT_PUBLIC_GAS_INITIAL_REQ) {
+		rtw_set_scan_deny(adapter, 200);
+		rtw_scan_abort_no_wait(adapter);
+		#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(adapter))
+			rtw_scan_abort_no_wait(adapter->pbuddy_adapter);
+		#endif
+	}
 
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
@@ -4403,6 +4419,11 @@ void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const
 	cfg80211_rx_action(adapter->pnetdev, freq, frame, frame_len, GFP_ATOMIC);
 #endif
 
+	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
+	if (msg)
+		DBG_871X("RTW_Rx:%s\n", msg);
+	else
+		DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
 }
 
 #ifdef CONFIG_P2P
@@ -4655,6 +4676,11 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	struct wifidirect_info *pwdinfo;
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
 
+#ifndef CONFIG_RADIO_WORK
+	#define RTW_ROCH_DURATION_ENLARGE
+	#define RTW_ROCH_BACK_OP
+#endif
+
 	if (ndev == NULL) {
 		return  -EINVAL;
 	}
@@ -4665,18 +4691,18 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	pwdinfo = &padapter->wdinfo;
 	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
-	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
+	*cookie = ATOMIC_INC_RETURN(&pcfg80211_wdinfo->ro_ch_cookie_gen);
+
+	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d, cookie:0x%llx\n", FUNC_ADPT_ARG(padapter), remain_ch, duration, *cookie);
 
 	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
 	{
-		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		#ifdef CONFIG_CONCURRENT_MODE
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 		#endif //CONFIG_CONCURRENT_MODE
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
-		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	pcfg80211_wdinfo->is_ro_ch = _TRUE;
@@ -4729,12 +4755,13 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 
 
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-	
-	
-	if(duration < 400)
-		duration = duration*3;//extend from exper.
 
+	#ifdef RTW_ROCH_DURATION_ENLARGE
+	if (duration < 400)
+		duration = duration * 3; /* extend from exper */
+	#endif
 
+#ifdef RTW_ROCH_BACK_OP
 #ifdef	CONFIG_CONCURRENT_MODE
 	if(check_buddy_fwstate(padapter, _FW_LINKED) &&
 		(duration<pwdinfo->ext_listen_interval)) 
@@ -4742,6 +4769,7 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 		duration = duration + 	pwdinfo->ext_listen_interval;
 	}
 #endif
+#endif /* RTW_ROCH_BACK_OP */
 
 	pcfg80211_wdinfo->restore_channel = rtw_get_oper_ch(padapter);
 
@@ -4763,9 +4791,11 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 					}
 
 					ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
-			
+
+					#ifdef RTW_ROCH_BACK_OP
 					DBG_8192C("%s, set switch ch timer, duration=%d\n", __func__, duration-pwdinfo->ext_listen_interval);
-					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);	
+					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);
+					#endif
 				}			
 			}
 		
@@ -4856,17 +4886,15 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 	pwdinfo = &padapter->wdinfo;
 	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
-	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+	DBG_871X(FUNC_ADPT_FMT" cookie:0x%llx\n", FUNC_ADPT_ARG(padapter), cookie);
 
 	if (pcfg80211_wdinfo->is_ro_ch == _TRUE) {
-		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		#ifdef CONFIG_CONCURRENT_MODE
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 		#endif
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
-		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	#if 0
@@ -5177,10 +5205,27 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 		goto cancel_ps_deny;
 	}
 
-	do {
+	while (1) {
+		u32 sleep_ms = 0;
+		u32 retry_guarantee_ms = 0;
+
 		dump_cnt++;
 		tx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);
-	} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);
+
+		switch (action) {
+		case ACT_PUBLIC_GAS_INITIAL_REQ:
+		case ACT_PUBLIC_GAS_INITIAL_RSP:
+			sleep_ms = 50;
+			retry_guarantee_ms = RTW_MAX_MGMT_TX_MS_GAS;
+		}
+
+		if (tx_ret == _SUCCESS
+			|| (dump_cnt >= dump_limit && rtw_get_passing_time_ms(start) >= retry_guarantee_ms))
+				break;
+
+		if (sleep_ms > 0)
+			rtw_msleep_os(sleep_ms);
+	}
 
 	if (tx_ret != _SUCCESS || dump_cnt > 1) {
 		DBG_871X(FUNC_ADPT_FMT" %s (%d/%d) in %d ms\n", FUNC_ADPT_ARG(padapter),
@@ -5819,14 +5864,14 @@ void rtw_cfg80211_init_wiphy(_adapter *padapter)
 
 	DBG_8192C("%s:rf_type=%d\n", __func__, rf_type);
 
-	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
+	if (padapter->registrypriv.wireless_mode & WIRELESS_11G)
 	{
 		bands = wiphy->bands[IEEE80211_BAND_2GHZ];
 		if(bands)
 			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, rf_type);
 	}
 
-	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
+	if (padapter->registrypriv.wireless_mode & WIRELESS_11A)
 	{
 		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
 		if(bands)
@@ -5881,7 +5926,9 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 								| BIT(NL80211_IFTYPE_ADHOC)
 #ifdef CONFIG_AP_MODE
 								| BIT(NL80211_IFTYPE_AP)
+								#ifndef CONFIG_RADIO_WORK
 								| BIT(NL80211_IFTYPE_MONITOR)
+								#endif
 #endif
 #if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
 								| BIT(NL80211_IFTYPE_P2P_CLIENT)
@@ -5896,7 +5943,9 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 #endif		
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+	#ifndef CONFIG_RADIO_WORK
 	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
+	#endif
 #endif
 
 	/*
@@ -5909,8 +5958,10 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
 		wiphy->bands[IEEE80211_BAND_2GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_2GHZ);
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
 		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
+#endif
 	
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38) && LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
 	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
index d9507337e815..bb005df69465 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
@@ -8053,9 +8053,9 @@ static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 	if(psta)
 	{
 		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		rtw_free_stainfo(padapter,  psta);		
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 
 		psta = NULL;
 	}	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/os_intfs.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/os_intfs.c
index c5d387919fca..fd7d6a9ae0e9 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/os_intfs.c
@@ -320,6 +320,22 @@ uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;
 module_param(rtw_hiq_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_hiq_filter, "0:allow all, 1:allow special, 2:deny all");
 
+uint rtw_adaptivity_en = CONFIG_RTW_ADAPTIVITY_EN;
+module_param(rtw_adaptivity_en, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_en, "0:disable, 1:enable");
+
+uint rtw_adaptivity_mode = CONFIG_RTW_ADAPTIVITY_MODE;
+module_param(rtw_adaptivity_mode, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_mode, "0:normal, 1:carrier sense");
+
+uint rtw_adaptivity_dml = CONFIG_RTW_ADAPTIVITY_DML;
+module_param(rtw_adaptivity_dml, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_dml, "0:disable, 1:enable");
+
+uint rtw_adaptivity_dc_backoff = CONFIG_RTW_ADAPTIVITY_DC_BACKOFF;
+module_param(rtw_adaptivity_dc_backoff, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_dc_backoff, "DC backoff for Adaptivity");
+
 #if defined(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY) //eFuse: Regulatory selection=1
 int rtw_tx_pwr_lmt_enable = 1;
 int rtw_tx_pwr_by_rate = 1;
@@ -533,6 +549,12 @@ _func_enter_;
 	registry_par->qos_opt_enable = (u8)rtw_qos_opt_enable;
 
 	registry_par->hiq_filter = (u8)rtw_hiq_filter;
+
+	registry_par->adaptivity_en = (u8)rtw_adaptivity_en;
+	registry_par->adaptivity_mode = (u8)rtw_adaptivity_mode;
+	registry_par->adaptivity_dml = (u8)rtw_adaptivity_dml;
+	registry_par->adaptivity_dc_backoff = (u8)rtw_adaptivity_dc_backoff;
+
 _func_exit_;
 
 	return status;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
index 59ce0dc418e8..62ad6da683e7 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
@@ -64,6 +64,9 @@ const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
 	"P2P_GET_NOA",
 	"P2P_SET_PS",
 	"SET_AP_WPS_P2P_IE",
+
+	"MIRACAST",
+
 #ifdef CONFIG_PNO_SUPPORT
 	"PNOSSIDCLR",
 	"PNOSETUP",
@@ -73,6 +76,7 @@ const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
 
 	"MACADDR",
 
+	"BLOCK_SCAN",
 	"BLOCK",
 	"WFD-ENABLE",
 	"WFD-DISABLE",
@@ -346,6 +350,18 @@ int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int tota
 	return bytes_written;
 }
 
+int rtw_android_set_block_scan(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK_SCAN]) + 1;
+
+	#ifdef CONFIG_IOCTL_CFG80211
+	adapter_wdev_data(adapter)->block_scan = (*block_value == '0')?_FALSE:_TRUE;
+	#endif
+
+	return 0;
+}
+
 int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -381,6 +397,28 @@ int rtw_android_getband(struct net_device *net, char *command, int total_len)
 	return bytes_written;
 }
 
+#ifdef CONFIG_WFD
+int rtw_android_set_miracast_mode(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	struct wifi_display_info *wfd_info = &adapter->wfd_info;
+	char *arg = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_MIRACAST]) + 1;
+	u8 mode;
+	int num;
+	int ret = _FAIL;
+
+	num = sscanf(arg, "%hhu", &mode);
+
+	if (num >= 1) {
+		wfd_info->stack_wfd_mode = mode;
+		DBG_871X("Miracast mode: %s(%u)\n", get_miracast_mode_str(wfd_info->stack_wfd_mode), wfd_info->stack_wfd_mode);
+		ret = _SUCCESS;
+	}
+
+	return (ret == _SUCCESS)?0:-1;
+}
+#endif /* CONFIG_WFD */
+
 int get_int_from_command( char* pcmd )
 {
 	int i = 0;
@@ -545,7 +583,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_MACADDR:
 		bytes_written = rtw_android_get_macaddr(net, command, priv_cmd.total_len);
 		break;
-		
+
+	case ANDROID_WIFI_CMD_BLOCK_SCAN:
+		bytes_written = rtw_android_set_block_scan(net, command, priv_cmd.total_len);
+		break;
+
 	case ANDROID_WIFI_CMD_BLOCK:
 		bytes_written = rtw_android_set_block(net, command, priv_cmd.total_len);
 		break;
@@ -595,7 +637,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_GETBAND:
 		bytes_written = rtw_android_getband(net, command, priv_cmd.total_len);
 		break;
-		
+
 	case ANDROID_WIFI_CMD_COUNTRY:
 		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
 		break;
@@ -639,6 +681,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 #endif //CONFIG_IOCTL_CFG80211
 
 #ifdef CONFIG_WFD
+
+	case ANDROID_WIFI_CMD_MIRACAST:
+		bytes_written = rtw_android_set_miracast_mode(net, command, priv_cmd.total_len);
+		break;
+
 	case ANDROID_WIFI_CMD_WFD_ENABLE:
 	{
 		//	Commented by Albert 2012/07/24
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
index dd0947613929..37435041d1ae 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
@@ -648,23 +648,18 @@ ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, si
 	char tmp[32];
 	u32 TH_L2H_ini;
 	s8 TH_EDCCA_HL_diff;
-	u32 IGI_Base;
-	int ForceEDCCA;
-	u8 AdapEn_RSSI;
-	u8 IGI_LowerBound;
 
 	if (count < 1)
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
 
-		int num = sscanf(tmp, "%x %hhd %x %d %hhu %hhu",
-			&TH_L2H_ini, &TH_EDCCA_HL_diff, &IGI_Base, &ForceEDCCA, &AdapEn_RSSI, &IGI_LowerBound);
+		int num = sscanf(tmp, "%x %hhd",	&TH_L2H_ini, &TH_EDCCA_HL_diff);
 
-		if (num != 6)
+		if (num != 2)
 			return count;
 
-		rtw_odm_adaptivity_parm_set(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff, (s8)IGI_Base, (bool)ForceEDCCA, AdapEn_RSSI, IGI_LowerBound);
+		rtw_odm_adaptivity_parm_set(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff);
 	}
 	
 	return count;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
index 0cc47c18d6b3..0de8f110bd9c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
@@ -7,7 +7,7 @@
 /*
  * Broadcom BCM4319 driver version.
  */
-#define RTL8192_DRV_VERSION "3.80.WFD"
+#define RTL8192_DRV_VERSION "3.80.WFD.beta"
 
 #endif /* WIFI_VERSION_H */
 
-- 
2.35.3

