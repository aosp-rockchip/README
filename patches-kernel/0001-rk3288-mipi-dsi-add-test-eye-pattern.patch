From 6acc7a6e983f8a3a7c6d36c10aaeecdc2adec47e Mon Sep 17 00:00:00 2001
From: libing <libing@rock-chips.com>
Date: Wed, 7 May 2014 16:54:03 +0800
Subject: [PATCH] rk3288-mipi-dsi: add test eye pattern.

---
 drivers/video/rockchip/screen/lcd_mipi.c      | 777 ++++++++-------
 .../rockchip/transmitter/rk32_mipi_dsi.c      | 929 +++++++++---------
 .../rockchip/transmitter/rk32_mipi_dsi.h      |  28 +-
 3 files changed, 855 insertions(+), 879 deletions(-)

diff --git a/drivers/video/rockchip/screen/lcd_mipi.c b/drivers/video/rockchip/screen/lcd_mipi.c
index 2635134e6697..023a873ea508 100755
--- a/drivers/video/rockchip/screen/lcd_mipi.c
+++ b/drivers/video/rockchip/screen/lcd_mipi.c
@@ -22,123 +22,114 @@
 #define	MIPI_SCREEN_DBG(x...)  
 #endif
 
-struct mipi_screen *gmipi_screen;
+static struct mipi_screen *gmipi_screen;
 
 static void rk_mipi_screen_pwr_disable(struct mipi_screen *screen)
 {   
-    if(screen->lcd_en_gpio != INVALID_GPIO){
-        gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
-        mdelay(screen->lcd_en_delay);
-    }
-    else{
-        MIPI_SCREEN_DBG("lcd_en_gpio is null");
-    }
-    
-    if(screen->lcd_rst_gpio != INVALID_GPIO){     
-
-        gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
-        mdelay(screen->lcd_rst_delay);
-    }
-    else{
-        MIPI_SCREEN_DBG("lcd_rst_gpio is null");
-    }    
-}
+	if(screen->lcd_en_gpio != INVALID_GPIO){
+		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
+		msleep(screen->lcd_en_delay);
+	}
+	else{
+		MIPI_SCREEN_DBG("lcd_en_gpio is null");
+	}
+	
+	if(screen->lcd_rst_gpio != INVALID_GPIO){
 
+		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
+		msleep(screen->lcd_rst_delay);
+	}
+	else{
+		MIPI_SCREEN_DBG("lcd_rst_gpio is null");
+	}    
+}
 
 static void rk_mipi_screen_pwr_enable(struct mipi_screen *screen)
 {   
-    if(screen->lcd_en_gpio != INVALID_GPIO){
-        gpio_direction_output(screen->lcd_en_gpio, screen->lcd_en_atv_val);
-        mdelay(screen->lcd_en_delay);
-    }
-    else{
-        MIPI_SCREEN_DBG("lcd_en_gpio is null\n");
-    }
-    
-    if(screen->lcd_rst_gpio != INVALID_GPIO){     
-
-        mdelay (screen->lcd_rst_delay);
-        gpio_direction_output(screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
-        mdelay(screen->lcd_rst_delay);
-    }
-    else{
-        MIPI_SCREEN_DBG("lcd_rst_gpio is null\n");
-    }    
+	if(screen->lcd_en_gpio != INVALID_GPIO){
+		gpio_direction_output(screen->lcd_en_gpio, screen->lcd_en_atv_val);
+		msleep(screen->lcd_en_delay);
+	}
+	else
+		MIPI_SCREEN_DBG("lcd_en_gpio is null\n");
+	
+	if(screen->lcd_rst_gpio != INVALID_GPIO){
+		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
+		msleep (screen->lcd_rst_delay);
+		gpio_direction_output(screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
+		msleep(screen->lcd_rst_delay);
+	}
+	else
+		MIPI_SCREEN_DBG("lcd_rst_gpio is null\n");
 }
 
 static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
 {
-    u8 len, i; 
-    u8 cmds[25] = {0}, tempcmds[25] = {0};
-    struct list_head *screen_pos;
-    struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
-    
-    list_for_each(screen_pos, &screen->cmdlist_head){
-    
-        dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list);
-        len = dcs_cmd->dcs_cmd.cmd_len + 1;
-        
-        for( i = 1; i < len ; i++){
-            cmds[i] = dcs_cmd->dcs_cmd.cmds[i-1];
-            tempcmds[i] = cmds[i]; 
-            }
-            printk("dcs_cmd.name:%s\n",dcs_cmd->dcs_cmd.name);
-        if(dcs_cmd->dcs_cmd.type == LPDT){
-            cmds[0] = LPDT;
-            tempcmds[0] = LPDT;
-            if(dcs_cmd->dcs_cmd.dsi_id == 0){
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__);                
-                dsi_send_packet(0, cmds, len);
-            }
-            else if (dcs_cmd->dcs_cmd.dsi_id == 1){
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
-                dsi_send_packet(1, cmds, len);
-            }
-            else if (dcs_cmd->dcs_cmd.dsi_id == 2){
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__);
-                dsi_send_packet(0, cmds, len);
-                dsi_send_packet(1, tempcmds, len);
-
-            }
-            else{
-                MIPI_SCREEN_DBG("dsi is err.\n");
-            }
-            mdelay(dcs_cmd->dcs_cmd.delay);
-            
-        }
-        else if(dcs_cmd->dcs_cmd.type == HSDT){
-            cmds[0] = HSDT;
-            tempcmds[0] = HSDT;
-            if(dcs_cmd->dcs_cmd.dsi_id == 0){
-            
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__); 
-                dsi_send_packet(0, cmds, len);
-            }
-            else if (dcs_cmd->dcs_cmd.dsi_id == 1){
-            
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
-                dsi_send_packet(1, cmds, len);
-            }
-            else if (dcs_cmd->dcs_cmd.dsi_id == 2){
-                MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__); 
-                dsi_send_packet(0, cmds, len);
-                dsi_send_packet(1, tempcmds, len);
-            }
-            else{
-                MIPI_SCREEN_DBG("dsi is err.");
-            }
-            mdelay(dcs_cmd->dcs_cmd.delay);
-            
-        }
-        else
-            MIPI_SCREEN_DBG("cmd type err.\n");
-    }
+	u8 len, i, cmds[25] = {0}; 
+	struct list_head *screen_pos;
+	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
+	
+	list_for_each(screen_pos, &screen->cmdlist_head){
+	
+		dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list);
+		len = dcs_cmd->dcs_cmd.cmd_len + 1;
+		
+		for( i = 1; i < len ; i++){
+			cmds[i] = dcs_cmd->dcs_cmd.cmds[i-1];
+		}
+		MIPI_SCREEN_DBG("dcs_cmd.name:%s\n",dcs_cmd->dcs_cmd.name);
+		if(dcs_cmd->dcs_cmd.type == LPDT){
+			cmds[0] = LPDT;
+			if(dcs_cmd->dcs_cmd.dsi_id == 0){
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__);                
+				dsi_send_packet(0, cmds, len);
+			}
+			else if (dcs_cmd->dcs_cmd.dsi_id == 1){
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
+				dsi_send_packet(1, cmds, len);
+			}
+			else if (dcs_cmd->dcs_cmd.dsi_id == 2){
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__);
+				dsi_send_packet(0, cmds, len);
+				dsi_send_packet(1, cmds, len);
+			}
+			else{
+			    MIPI_SCREEN_DBG("dsi is err.\n");
+			}
+			msleep(dcs_cmd->dcs_cmd.delay);
+			
+		}
+		else if(dcs_cmd->dcs_cmd.type == HSDT){
+			cmds[0] = HSDT;
+			if(dcs_cmd->dcs_cmd.dsi_id == 0){
+			
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__); 
+				dsi_send_packet(0, cmds, len);
+			}
+			else if (dcs_cmd->dcs_cmd.dsi_id == 1){
+			
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
+				dsi_send_packet(1, cmds, len);
+			}
+			else if (dcs_cmd->dcs_cmd.dsi_id == 2){
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__); 
+				dsi_send_packet(0, cmds, len);
+			}
+			else{
+				MIPI_SCREEN_DBG("dsi is err.");
+			}
+			msleep(dcs_cmd->dcs_cmd.delay);
+			
+		}
+		else
+		    MIPI_SCREEN_DBG("cmd type err.\n");
+	}
 }
 
 int rk_mipi_screen(void) 
 {
-    u8 dcs[16] = {0};
-	u8 rk_dsi_num = gmipi_screen->mipi_dsi_num;
+	u8 dcs[16] = {0}, rk_dsi_num;
+	rk_dsi_num = gmipi_screen->mipi_dsi_num;
 	
 	if(gmipi_screen->screen_init == 0){
 	
@@ -147,38 +138,51 @@ int rk_mipi_screen(void)
 			dsi_enable_hs_clk(1, 1);
 		}
 		
+		dsi_enable_video_mode(0,0);
+		if(rk_dsi_num == 2){
+			dsi_enable_video_mode(1,0);
+		} 
+		
+		dsi_enable_command_mode(0, 1);
+		if(rk_dsi_num == 2){
+			dsi_enable_command_mode(1, 1);
+		} 
+		
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
 		dcs[2] = dcs_exit_sleep_mode; 
 		dsi_send_packet(0, dcs, 3);
 		if(rk_dsi_num ==2)   
-            dsi_send_packet(1, dcs, 3);
-			
-		msleep(10);
+			dsi_send_packet(1, dcs, 3);
+		
+		msleep(20);
 		
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
 		dcs[2] = dcs_set_display_on; 
 		dsi_send_packet(0, dcs, 3);
 		if(rk_dsi_num ==2)
-            dsi_send_packet(1, dcs, 3);   
+	        dsi_send_packet(1, dcs, 3); 
 
-		msleep(10);
+		msleep(20);
 		
+		dsi_enable_command_mode(0,0);
+		if(rk_dsi_num == 2){
+			dsi_enable_command_mode(1,0);
+		} 
+
 		dsi_enable_video_mode(0,1);
 		if(rk_dsi_num == 2){
 			dsi_enable_video_mode(1,1);
 		} 
-
 	}
 	else{
+		rk_mipi_screen_pwr_enable(gmipi_screen);
 
-        rk_mipi_screen_pwr_enable(gmipi_screen);
-
-        dsi_enable_hs_clk(0,1);
-        if(rk_dsi_num == 2){
-            dsi_enable_hs_clk(1, 1);
-        }
+		dsi_enable_hs_clk(0,1);
+		if(rk_dsi_num == 2){
+			dsi_enable_hs_clk(1, 1);
+		}
 
 		dsi_enable_video_mode(0,0);
 		if(rk_dsi_num == 2){
@@ -190,37 +194,35 @@ int rk_mipi_screen(void)
 			dsi_enable_command_mode(1, 1);
 		} 
 
-        rk_mipi_screen_cmd_init(gmipi_screen);
+		rk_mipi_screen_cmd_init(gmipi_screen);
 
-        dsi_enable_command_mode(0,0);
+		dsi_enable_command_mode(0,0);
 		if(rk_dsi_num == 2){
 			dsi_enable_command_mode(1,0);
 		} 
 
-        dsi_enable_video_mode(0,1);
-        if(rk_dsi_num == 2){
-            dsi_enable_video_mode(1,1);
-        } 
-	
+		dsi_enable_video_mode(0,1);
+		if(rk_dsi_num == 2){
+			dsi_enable_video_mode(1,1);
+		} 
 	}
-		
+	
 	MIPI_SCREEN_DBG("++++++++++++++++%s:%d\n", __func__, __LINE__);
-    return 0;
+	return 0;
 }
 
 int rk_mipi_screen_standby(u8 enable) 
 {
-	u8 dcs[16] = {0};
-	u8 rk_dsi_num = 0;
-    rk_dsi_num = gmipi_screen->mipi_dsi_num;
-
-    if(dsi_is_active(0) != 1) 
-        return -1;
-  
-    if(rk_dsi_num ==2)
-        if((dsi_is_active(0) != 1) ||(dsi_is_active(1) != 1))
-            return -1;
-  
+	u8 dcs[16] = {0}, rk_dsi_num;
+	rk_dsi_num = gmipi_screen->mipi_dsi_num;
+
+	if(dsi_is_active(0) != 1) 
+		return -1;
+	
+	if(rk_dsi_num ==2)
+		if((dsi_is_active(0) != 1) ||(dsi_is_active(1) != 1))
+			return -1;
+	
 	if(enable) {
 		/*below is changeable*/
 		dcs[0] = LPDT;
@@ -228,7 +230,7 @@ int rk_mipi_screen_standby(u8 enable)
 		dcs[2] = dcs_set_display_off; 
 		dsi_send_packet(0, dcs, 3);
 		if(rk_dsi_num ==2)   
-            dsi_send_packet(1, dcs, 3);
+			dsi_send_packet(1, dcs, 3);
 		
 		msleep(30);
 		
@@ -237,12 +239,11 @@ int rk_mipi_screen_standby(u8 enable)
 		dcs[2] = dcs_enter_sleep_mode; 
 		dsi_send_packet(0, dcs, 3);
 		if(rk_dsi_num ==2)
-            dsi_send_packet(1, dcs, 3);   
+			dsi_send_packet(1, dcs, 3);   
 
 		msleep(100);
-        rk_mipi_screen_pwr_disable(gmipi_screen);
+		rk_mipi_screen_pwr_disable(gmipi_screen);
 		MIPI_SCREEN_DBG("++++enable++++++++++++%s:%d\n", __func__, __LINE__);
-	
 	}
 	else {
 		rk_mipi_screen();
@@ -252,255 +253,251 @@ int rk_mipi_screen_standby(u8 enable)
 
 static int rk_mipi_screen_init_dt(struct mipi_screen *screen)
 {
-    struct device_node *childnode, *grandchildnode,*root;
-    struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
-    struct list_head *pos;
-    struct property *prop;
-    enum of_gpio_flags flags;
-    u32 value,i,debug,gpio,ret,cmds[25],length;
-
-    memset(screen, 0, sizeof(*screen));
-    
-    INIT_LIST_HEAD(&screen->cmdlist_head);
-
-    childnode = of_find_node_by_name(NULL, "mipi_dsi_init");
-    if(!childnode ){
-        MIPI_SCREEN_DBG("%s: Can not get child => mipi_init.\n", __func__);
-    }
-    else{
-        ret = of_property_read_u32(childnode, "rockchip,screen_init", &value);
-        if (ret) {
-            MIPI_SCREEN_DBG("%s: Can not read property: screen_init.\n", __func__);
-        } 
-        else {
-            if((value != 0) && (value != 1) ){
-                printk("err: rockchip,mipi_dsi_init not match.\n");
-                return -1;
-            }else
-                screen->screen_init = value ;
-
-            MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init ); 
-        }
-        
-        ret = of_property_read_u32(childnode, "rockchip,dsi_lane", &value);
-        if (ret) {
-            MIPI_SCREEN_DBG("%s: Can not read property: dsi_lane.\n", __func__);
-        } else {
-            screen->dsi_lane = value;
-            MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane ); 
-        } 
-            
-        ret = of_property_read_u32(childnode, "rockchip,dsi_hs_clk", &value);
-        if (ret) {
-            MIPI_SCREEN_DBG("%s: Can not read property: dsi_hs_clk.\n", __func__);
-        } else {
-            if((value <= 90) || (value >= 1500)){
-                printk("err: rockchip,hs_tx_clk not match.");
-                return -1;
-            }else
-                screen->hs_tx_clk = value*MHz;
-                
-            MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk ); 
-        } 
-        
-        ret = of_property_read_u32(childnode, "rockchip,mipi_dsi_num", &value);
-        if (ret) {
-            MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
-        } else {
-            if((value != 1) && (value != 2) ){
-                printk("err: rockchip,mipi_dsi_num not match.\n");
-                return -1;
-            }
-            else
-                screen->mipi_dsi_num = value ;
-                
-            MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num ); 
-        }  
-    }
-
-    childnode = of_find_node_by_name(NULL, "mipi_power_ctr");
-    if(!childnode ){
-        screen->lcd_rst_gpio = INVALID_GPIO;
-        screen->lcd_en_gpio = INVALID_GPIO;
-        MIPI_SCREEN_DBG("%s: Can not get child => mipi_power_ctr.\n", __func__);
-    }
-    else{
-        grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_rst");
-        if (!grandchildnode){
-            screen->lcd_rst_gpio = INVALID_GPIO;
-            MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_rst.\n", __func__);
-        }
-        else{
-            ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-            if (ret){
-                MIPI_SCREEN_DBG("%s: Can not read property: delay.\n", __func__);
-            } 
-            else {
-                screen->lcd_rst_delay = value;
-                MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay );     
-            } 
-            
-            gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-            if (!gpio_is_valid(gpio)){
-                MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
-            } 
-            
-            ret = gpio_request(gpio,"mipi_lcd_rst");
-            if (ret) {
-                screen->lcd_rst_gpio = INVALID_GPIO;
-                MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n",gpio);
-                return -1;
-            }
-            
-            screen->lcd_rst_gpio = gpio;
-            screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH)? 1:0; 
-            
-            MIPI_SCREEN_DBG(
-            "lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n",screen->lcd_rst_gpio,screen->lcd_rst_atv_val);
-        } 
-
-        grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_en");
-        if (!grandchildnode){
-            screen->lcd_en_gpio = INVALID_GPIO;
-            MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en.\n", __func__);
-        } 
-        else {
-            ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-            if (ret){
-                MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en-delay.\n", __func__);
-            } 
-            else {
-                screen->lcd_en_delay = value;
-                MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay ); 
-            } 
-            
-            gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-            if (!gpio_is_valid(gpio)){
-                MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
-            }
-
-            ret = gpio_request(gpio,"mipi_lcd_en");
-            if (ret) {
-                screen->lcd_en_gpio = INVALID_GPIO;
-                MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n",gpio);
-                return -1;
-            }
-            screen->lcd_en_gpio = gpio;
-            screen->lcd_en_atv_val= (flags == GPIO_ACTIVE_HIGH)? 1:0; 
-            MIPI_SCREEN_DBG(
-                    "dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n",screen->lcd_en_gpio,screen->lcd_en_atv_val);
-        }
-    }
-
-    root= of_find_node_by_name(NULL,"screen-on-cmds");
-    if (!root) {
-        MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
-    }
-    else{
-        for_each_child_of_node(root, childnode){
-            dcs_cmd = kmalloc(sizeof(struct mipi_dcs_cmd_ctr_list), GFP_KERNEL);
-            strcpy(dcs_cmd->dcs_cmd.name, childnode->name);
-            prop = of_find_property(childnode, "rockchip,cmd", &length);
-            if (!prop){
-                MIPI_SCREEN_DBG("Can not read property: cmds\n");
-                return -EINVAL;
-            }
-
-            MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n",childnode->name,(length / sizeof(u32)));
-            
-            ret = of_property_read_u32_array(childnode,  "rockchip,cmd", cmds, (length / sizeof(u32)));
-            if(ret < 0) {
-                MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__,childnode->name);
-                return ret;
-            }
-            else{
-                dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32) ;
-                
-                for(i = 0; i < (length / sizeof(u32)); i++){   
-                   MIPI_SCREEN_DBG("cmd[%d]=%02x£¬",i+1,cmds[i]);
-                   dcs_cmd->dcs_cmd.cmds[i] = cmds[i];
-                }
-                
-                MIPI_SCREEN_DBG("dcs_cmd->dcs_cmd.cmd_len=%d\n",dcs_cmd->dcs_cmd.cmd_len);
-            }
-            ret = of_property_read_u32(childnode, "rockchip,dsi_id", &value);
-            if(ret){
-                MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
-            }
-            else{
-                if(screen->mipi_dsi_num ==1 ){
-                    if(value != 0) {
-                        printk("err: rockchip,dsi_id not match.\n");
-                    }
-                    else
-                        dcs_cmd->dcs_cmd.dsi_id = value;
-                }
-                else {
-                    if((value < 0) || ( value > 2)) {
-                        printk("err: rockchip,dsi_id not match.\n");
-                    }
-                    else
-                        dcs_cmd->dcs_cmd.dsi_id = value;
-                }                      
-            }
-             
-            ret = of_property_read_u32(childnode, "rockchip,cmd_type", &value);
-            if(ret){
-                MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
-            }
-            else{
-                if((value != 0) && (value != 1)){
-                    printk("err: rockchip, cmd_type not match.\n");
-                }
-                else
-                    dcs_cmd->dcs_cmd.type = value;
-            }
-
-            ret = of_property_read_u32(childnode, "rockchip,cmd_delay", &value);
-            if(ret) {
-                MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__,childnode->name);
-            }
-            else{
-                dcs_cmd->dcs_cmd.delay = value;
-            }
-
-            list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
-        }
-    }
-    ret = of_property_read_u32(root, "rockchip,cmd_debug", &debug);
-    if(ret){
-        MIPI_SCREEN_DBG("%s: Can not read property: rockchip,cmd_debug.\n", __func__);
-    }
-    else{
-        if (debug) {
-            list_for_each(pos, &screen->cmdlist_head) {
-                dcs_cmd = list_entry(pos, struct mipi_dcs_cmd_ctr_list, list);
-                printk("\n dcs_name:%s,dcs_type:%d,side_id:%d,cmd_len:%d,delay:%d\n\n",
-                        dcs_cmd->dcs_cmd.name,
-                        dcs_cmd->dcs_cmd.type, 
-                        dcs_cmd->dcs_cmd.dsi_id,
-                        dcs_cmd->dcs_cmd.cmd_len,
-                        dcs_cmd->dcs_cmd.delay);
-                for(i=0; i < (dcs_cmd->dcs_cmd.cmd_len) ;i++){
-                    printk("[%d]=%02x,",i+1,dcs_cmd->dcs_cmd.cmds[i]);
-                }
-            }
-        }
-        else
-            MIPI_SCREEN_DBG("---close cmd debug---\n");
-   }
-    return 0; 
+	struct device_node *childnode, *grandchildnode, *root;
+	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
+	struct list_head *pos;
+	struct property *prop;
+	enum of_gpio_flags flags;
+	u32 value, i, debug, gpio, ret, cmds[25], length;
+
+	memset(screen, 0, sizeof(*screen));
+	
+	INIT_LIST_HEAD(&screen->cmdlist_head);
+
+	childnode = of_find_node_by_name(NULL, "mipi_dsi_init");
+	if(!childnode ){
+		MIPI_SCREEN_DBG("%s: Can not get child => mipi_init.\n", __func__);
+	}
+	else{
+		ret = of_property_read_u32(childnode, "rockchip,screen_init", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: screen_init.\n", __func__);
+		} 
+		else {
+			if((value != 0) && (value != 1) ){
+				printk("err: rockchip,mipi_dsi_init not match.\n");
+				return -1;
+			}else
+				screen->screen_init = value ;
+			
+			MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init ); 
+		}
+		
+		ret = of_property_read_u32(childnode, "rockchip,dsi_lane", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: dsi_lane.\n", __func__);
+		} else {
+			screen->dsi_lane = value;
+			MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane ); 
+		} 
+	
+		ret = of_property_read_u32(childnode, "rockchip,dsi_hs_clk", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: dsi_hs_clk.\n", __func__);
+		} else {
+			if((value <= 90) || (value >= 1500)){
+				printk("err: rockchip,hs_tx_clk not match.");
+				return -1;
+			}else
+				screen->hs_tx_clk = value*MHz;
+		
+			MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk ); 
+		} 
+		
+		ret = of_property_read_u32(childnode, "rockchip,mipi_dsi_num", &value);
+		if (ret) {
+		    MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
+		} else {
+			if((value != 1) && (value != 2) ){
+				printk("err: rockchip,mipi_dsi_num not match.\n");
+				return -1;
+			}
+			else
+				screen->mipi_dsi_num = value ;
+	
+			MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num ); 
+		}  
+	}
+
+	childnode = of_find_node_by_name(NULL, "mipi_power_ctr");
+	if(!childnode ){
+		screen->lcd_rst_gpio = INVALID_GPIO;
+		screen->lcd_en_gpio = INVALID_GPIO;
+		MIPI_SCREEN_DBG("%s: Can not get child => mipi_power_ctr.\n", __func__);
+	}
+	else{
+		grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_rst");
+		if (!grandchildnode){
+			screen->lcd_rst_gpio = INVALID_GPIO;
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_rst.\n", __func__);
+		}
+		else{
+			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
+			if (ret){
+				MIPI_SCREEN_DBG("%s: Can not read property: delay.\n", __func__);
+			} 
+			else {
+				screen->lcd_rst_delay = value;
+				MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay );     
+			} 
+			
+			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
+			if (!gpio_is_valid(gpio)){
+				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
+			} 
+			
+			ret = gpio_request(gpio,"mipi_lcd_rst");
+			if (ret) {
+				screen->lcd_rst_gpio = INVALID_GPIO;
+				MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n",gpio);
+				return -1;
+			}
+			
+			screen->lcd_rst_gpio = gpio;
+			screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH)? 1:0; 
+			
+			MIPI_SCREEN_DBG("lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n",screen->lcd_rst_gpio,screen->lcd_rst_atv_val);
+		} 
+
+		grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_en");
+		if (!grandchildnode){
+			screen->lcd_en_gpio = INVALID_GPIO;
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en.\n", __func__);
+		} 
+		else {
+			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
+			if (ret){
+				MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en-delay.\n", __func__);
+			} 
+			else {
+				screen->lcd_en_delay = value;
+				MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay ); 
+			} 
+			
+			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
+			if (!gpio_is_valid(gpio)){
+				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
+			}
+
+			ret = gpio_request(gpio,"mipi_lcd_en");
+			if (ret) {
+				screen->lcd_en_gpio = INVALID_GPIO;
+				MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n",gpio);
+				return -1;
+			}
+			screen->lcd_en_gpio = gpio;
+			screen->lcd_en_atv_val= (flags == GPIO_ACTIVE_HIGH)? 1:0; 
+			MIPI_SCREEN_DBG("dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n",screen->lcd_en_gpio,screen->lcd_en_atv_val);
+		}
+	}
+
+	root= of_find_node_by_name(NULL,"screen-on-cmds");
+	if (!root) {
+	    MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
+	}
+	else{
+		for_each_child_of_node(root, childnode){
+			dcs_cmd = kmalloc(sizeof(struct mipi_dcs_cmd_ctr_list), GFP_KERNEL);
+			strcpy(dcs_cmd->dcs_cmd.name, childnode->name);
+			
+			prop = of_find_property(childnode, "rockchip,cmd", &length);
+			if (!prop){
+				MIPI_SCREEN_DBG("Can not read property: cmds\n");
+				return -EINVAL;
+			}
+
+			MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n",childnode->name,(length / sizeof(u32)));
+			
+			ret = of_property_read_u32_array(childnode,  "rockchip,cmd", cmds, (length / sizeof(u32)));
+			if(ret < 0) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__,childnode->name);
+				return ret;
+			}
+			else{
+				dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32) ;
+				
+				for(i = 0; i < (length / sizeof(u32)); i++){   
+					MIPI_SCREEN_DBG("cmd[%d]=%02x£¬",i+1,cmds[i]);
+					dcs_cmd->dcs_cmd.cmds[i] = cmds[i];
+				}
+				
+				MIPI_SCREEN_DBG("dcs_cmd->dcs_cmd.cmd_len=%d\n",dcs_cmd->dcs_cmd.cmd_len);
+			}
+			ret = of_property_read_u32(childnode, "rockchip,dsi_id", &value);
+			if(ret){
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
+			}
+			else{
+				if(screen->mipi_dsi_num ==1 ){
+					if(value != 0) {
+						printk("err: rockchip,dsi_id not match.\n");
+					}
+					else
+						dcs_cmd->dcs_cmd.dsi_id = value;
+				}
+				else {
+					if((value < 0) || ( value > 2)) 
+						printk("err: rockchip,dsi_id not match.\n");
+					else
+						dcs_cmd->dcs_cmd.dsi_id = value;
+				}
+			}
+			 
+			ret = of_property_read_u32(childnode, "rockchip,cmd_type", &value);
+			if(ret){
+			    MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
+			}
+			else{
+			    if((value != 0) && (value != 1)){
+			        printk("err: rockchip, cmd_type not match.\n");
+			    }
+			    else
+			        dcs_cmd->dcs_cmd.type = value;
+			}
+
+			ret = of_property_read_u32(childnode, "rockchip,cmd_delay", &value);
+			if(ret)
+			    MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__,childnode->name);
+			else
+			    dcs_cmd->dcs_cmd.delay = value;
+
+			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
+		}
+	}
+	ret = of_property_read_u32(root, "rockchip,cmd_debug", &debug);
+	if(ret){
+		MIPI_SCREEN_DBG("%s: Can not read property: rockchip,cmd_debug.\n", __func__);
+	}
+	else{
+		if (debug) {
+			list_for_each(pos, &screen->cmdlist_head) {
+				dcs_cmd = list_entry(pos, struct mipi_dcs_cmd_ctr_list, list);
+				printk("\n dcs_name:%s,dcs_type:%d,side_id:%d,cmd_len:%d,delay:%d\n\n",
+					dcs_cmd->dcs_cmd.name,
+					dcs_cmd->dcs_cmd.type, 
+					dcs_cmd->dcs_cmd.dsi_id,
+					dcs_cmd->dcs_cmd.cmd_len,
+					dcs_cmd->dcs_cmd.delay);
+				for(i=0; i < (dcs_cmd->dcs_cmd.cmd_len) ;i++){
+					printk("[%d]=%02x,",i+1,dcs_cmd->dcs_cmd.cmds[i]);
+				}
+			}
+		}
+		else
+			MIPI_SCREEN_DBG("---close cmd debug---\n");
+	}
+	return 0; 
 }
 
 int rk_mipi_get_dsi_num(void)
 {
-    return gmipi_screen->mipi_dsi_num;
+	return gmipi_screen->mipi_dsi_num;
 }
 EXPORT_SYMBOL(rk_mipi_get_dsi_num);
 
 int rk_mipi_get_dsi_lane(void)
 {
-    return gmipi_screen->dsi_lane;
+	return gmipi_screen->dsi_lane;
 }
 EXPORT_SYMBOL(rk_mipi_get_dsi_lane);
 
@@ -513,21 +510,21 @@ EXPORT_SYMBOL(rk_mipi_get_dsi_clk);
 
 static int __init rk_mipi_screen_probe(struct platform_device *pdev)
 {
-    int ret = 0;
+	static int ret = 0;
 
-    gmipi_screen = devm_kzalloc(&pdev->dev, sizeof(struct mipi_screen), GFP_KERNEL);
+	gmipi_screen = devm_kzalloc(&pdev->dev, sizeof(struct mipi_screen), GFP_KERNEL);
 	if(!gmipi_screen) {
 		dev_err(&pdev->dev,"request struct screen fail!\n");
 		return -ENOMEM;
 	}
-    
-    ret = rk_mipi_screen_init_dt(gmipi_screen);
-    if(ret < 0){
-        dev_err(&pdev->dev," rk_mipi_screen_init_dt fail!\n");
-        return -1;
-    }
-    
-    MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
+	
+	ret = rk_mipi_screen_init_dt(gmipi_screen);
+	if(ret < 0){
+		dev_err(&pdev->dev," rk_mipi_screen_init_dt fail!\n");
+		return -1;
+	}
+	
+	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
 
 	return 0;
 }
@@ -540,13 +537,13 @@ static struct platform_driver mipi_screen_platform_driver = {
 
 static int __init rk_mipi_screen_init(void)
 {
-    platform_device_register_simple("rk_mipi_screen", -1, NULL, 0);
+	platform_device_register_simple("rk_mipi_screen", -1, NULL, 0);
 	return platform_driver_probe(&mipi_screen_platform_driver, rk_mipi_screen_probe);
 }
 
 static void __exit rk_mipi_screen_exit(void)
 {
-    platform_driver_unregister(&mipi_screen_platform_driver);
+	platform_driver_unregister(&mipi_screen_platform_driver);
 }
 
 subsys_initcall_sync(rk_mipi_screen_init);
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
index d1a965c31360..14ef6b787a4e 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
@@ -16,14 +16,13 @@
 
 //config
 #define MIPI_DSI_REGISTER_IO	0
-#define CONFIG_MIPI_DSI_LINUX   0
-#define DWC_DSI_VERSION		0x3133302A
+#define CONFIG_MIPI_DSI_LINUX	0
+#define DWC_DSI_VERSION			0x3133302A
 
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/mfd/rk616.h>
 #include <linux/rk_fb.h>
 #include <linux/rk_screen.h>
 #include <linux/delay.h>
@@ -41,7 +40,7 @@
 #include "rk32_mipi_dsi.h"
 #include <linux/rockchip/iomap.h>
 
-#if 1
+#if 0
 #define	MIPI_DBG(x...)	printk(KERN_INFO x)
 #else
 #define	MIPI_DBG(x...)  
@@ -51,21 +50,23 @@
 #define	MIPI_TRACE(x...)	printk(KERN_INFO x)
 #else
 #define	MIPI_TRACE(...)    \
-    do\
-    {\
-        printf(__VA_ARGS__);\
-        printf("\n");\
-    }while(0);
-    
+	do\
+	{\
+		printf(__VA_ARGS__);\
+		printf("\n");\
+	}while(0);
+	
 #endif
 
 /*
 *			 Driver Version Note
 *
 *v1.0 : this driver is rk32 mipi dsi driver of rockchip;
-
+*v1.1 : add test eye pattern;
+*
 */
-#define RK_MIPI_DSI_VERSION_AND_TIME  "rockchip mipi_dsi v1.0 2014-04-17"
+
+#define RK_MIPI_DSI_VERSION_AND_TIME  "rockchip mipi_dsi v1.0 2014-05-07"
 
 static struct dsi *dsi0;
 static struct dsi *dsi1;
@@ -100,7 +101,7 @@ static int rk32_dsi_get_bits(struct dsi *dsi, u32 reg)
 		bits = (1 << bits) - 1;
 	else
 		bits = 0xffffffff;
-		
+	
 	rk32_dsi_read_reg(dsi, reg_addr, &val);
 	val >>= offset;
 	val &= bits;
@@ -110,7 +111,7 @@ static int rk32_dsi_get_bits(struct dsi *dsi, u32 reg)
 
 static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg) 
 {
-	u32 val = 0;
+	static u32 val = 0;
 	u32 bits = (reg >> 8) & 0xff;
 	u16 reg_addr = (reg >> 16) & 0xffff;
 	u8 offset = reg & 0xff;
@@ -120,12 +121,9 @@ static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg)
 	else
 		bits = 0xffffffff;
 
-	if(bits != 0xffffffff) {
-
+	if(bits != 0xffffffff)
 		rk32_dsi_read_reg(dsi, reg_addr, &val);
 
-	}
-
 	val &= ~(bits << offset);
 	val |= (data & bits) << offset;
 	rk32_dsi_write_reg(dsi, reg_addr, &val);
@@ -140,46 +138,46 @@ static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg)
 
 static int rk32_dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 {
-    int val = 0;
-    rk32_dsi_set_bits(dsi, 1, phy_testclk);
-    rk32_dsi_set_bits(dsi, test_code, phy_testdin);
-    rk32_dsi_set_bits(dsi, 1, phy_testen);
+	int val = 0;
+	rk32_dsi_set_bits(dsi, 1, phy_testclk);
+	rk32_dsi_set_bits(dsi, test_code, phy_testdin);
+	rk32_dsi_set_bits(dsi, 1, phy_testen);
 	rk32_dsi_set_bits(dsi, 0, phy_testclk);
 	rk32_dsi_set_bits(dsi, 0, phy_testen);;
 
-    rk32_dsi_set_bits(dsi, 0, phy_testen);
-    val = rk32_dsi_get_bits(dsi,phy_testdout);
-    rk32_dsi_set_bits(dsi, 1, phy_testclk);
-    rk32_dsi_set_bits(dsi, 0, phy_testclk);
+	rk32_dsi_set_bits(dsi, 0, phy_testen);
+	val = rk32_dsi_get_bits(dsi,phy_testdout);
+	rk32_dsi_set_bits(dsi, 1, phy_testclk);
+	rk32_dsi_set_bits(dsi, 0, phy_testclk);
 
-    return val;
+	return val;
 }
 
-
 static int rk32_dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsigned char *test_data, unsigned char size)
 {
 	int i = 0;
- 
-    rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
-    rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
-    rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+	
+	MIPI_DBG("test_code=0x%x,test_data=0x%x\n", test_code,test_data[0]);
+	rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
+	rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+	rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
 
 	for(i = 0; i < size; i++) {
-    	rk32_dsi_set_bits(dsi, test_data[i], PHY_TEST_CTRL1);
-        rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
-        rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
-        MIPI_DBG("rk32_dwc_phy_test_wr:%08x\n", rk32_dsi_get_bits(dsi, PHY_TEST_CTRL1));
+		rk32_dsi_set_bits(dsi, test_data[i], PHY_TEST_CTRL1);
+		rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+		rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+		MIPI_DBG("rk32_dwc_phy_test_wr:%08x\n", rk32_dsi_get_bits(dsi, PHY_TEST_CTRL1));
 	}
 	return 0;
 }
 
 static int rk32_phy_power_up(struct dsi *dsi)
 {
-    //enable ref clock
-    clk_prepare_enable(dsi->phy.refclk); 
-    clk_prepare_enable(dsi->dsi_pclk);
-    clk_prepare_enable(dsi->dsi_pd);
-    udelay(10);
+	//enable ref clock
+	clk_prepare_enable(dsi->phy.refclk); 
+	clk_prepare_enable(dsi->dsi_pclk);
+	clk_prepare_enable(dsi->dsi_pd);
+	udelay(10);
 
 	switch(dsi->host.lane) {
 		case 4:
@@ -194,180 +192,189 @@ static int rk32_phy_power_up(struct dsi *dsi)
 		default:
 			break;	
 	}
-    rk32_dsi_set_bits(dsi, 1, phy_shutdownz);
-    rk32_dsi_set_bits(dsi, 1, phy_rstz);  
-    rk32_dsi_set_bits(dsi, 1, phy_enableclk);
-    rk32_dsi_set_bits(dsi, 1, phy_forcepll);
-    
-    return 0;
+	rk32_dsi_set_bits(dsi, 1, phy_shutdownz);
+	rk32_dsi_set_bits(dsi, 1, phy_rstz);  
+	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
+	rk32_dsi_set_bits(dsi, 1, phy_forcepll);
+	
+	return 0;
 }
 
 static int rk32_phy_power_down(struct dsi *dsi)
 {
-    rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
-    clk_disable_unprepare(dsi->phy.refclk); 
-    clk_disable_unprepare(dsi->dsi_pclk);
-    clk_disable_unprepare(dsi->dsi_pd);
-    
-    return 0;
+	rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
+	clk_disable_unprepare(dsi->phy.refclk); 
+	clk_disable_unprepare(dsi->dsi_pclk);
+	clk_disable_unprepare(dsi->dsi_pd);
+	
+	return 0;
 }
 
 static int rk32_phy_init(struct dsi *dsi)
 {
-    u32 val = 0;
-    u32 ddr_clk = dsi->phy.ddr_clk;
-    u16 prediv = dsi->phy.prediv;
-    u16 fbdiv = dsi->phy.fbdiv;
-    
-    unsigned char test_data[2] = {0};
+	u32 val = 0 , ddr_clk = 0, fbdiv = 0, prediv = 0;
+	unsigned char test_data[2] = {0};
+	
+	ddr_clk	= dsi->phy.ddr_clk;
+	prediv	= dsi->phy.prediv;
+	fbdiv	= dsi->phy.fbdiv;
 
-    if(ddr_clk < 90 * MHz)
-        val = 0x01;
+	if(ddr_clk < 200 * MHz)
+		val = 0x0;
+	else if(ddr_clk < 300 * MHz)
+		val = 0x1;
+	else if(ddr_clk < 500 * MHz)
+		val = 0x2;
+	else if(ddr_clk < 700 * MHz)
+		val = 0x3;
+	else if(ddr_clk < 900 * MHz)
+		val = 0x4;
+	else if(ddr_clk < 1100 * MHz)
+		val = 0x5; 
+	else if(ddr_clk < 1300 * MHz)
+		val = 0x6;
+	else if(ddr_clk <= 1500 * MHz)
+		val = 0x7;
+	
+	test_data[0] = 0x80 | val << 3 | 0x3;
+	rk32_dwc_phy_test_wr(dsi, 0x10, test_data, 1);
+	
+	test_data[0] = 0xf;
+	rk32_dwc_phy_test_wr(dsi, 0x11, test_data, 1); 
+	
+	test_data[0] = 0x80 | 0x40;
+	rk32_dwc_phy_test_wr(dsi, 0x12, test_data, 1); 
+	
+	if(ddr_clk < 90 * MHz)
+		val = 0x01;
 	else if(ddr_clk < 100 * MHz)
-        val = 0x10;
+		val = 0x10;
 	else if(ddr_clk < 110 * MHz)
-        val = 0x20;
+		val = 0x20;
 	else if(ddr_clk < 130 * MHz)
-        val = 0x01;
+		val = 0x01;
 	else if(ddr_clk < 140 * MHz)
-        val = 0x11;
+		val = 0x11;
 	else if(ddr_clk < 150 * MHz)
-        val = 0x21; 
+		val = 0x21; 
 	else if(ddr_clk < 170 * MHz)
-        val = 0x02;
+		val = 0x02;
 	else if(ddr_clk < 180 * MHz)
-        val = 0x12;
+		val = 0x12;
 	else if(ddr_clk < 200 * MHz)
-        val = 0x22;
+		val = 0x22;
 	else if(ddr_clk < 220 * MHz)
-        val = 0x03;
+		val = 0x03;
 	else if(ddr_clk < 240 * MHz)
-        val = 0x13;
+		val = 0x13;
 	else if(ddr_clk < 250 * MHz)
-        val = 0x23;
+		val = 0x23;
 	else if(ddr_clk < 270 * MHz)
-        val = 0x04; 
+		val = 0x04; 
 	else if(ddr_clk < 300 * MHz)
-        val = 0x14;
+		val = 0x14;
 	else if(ddr_clk < 330 * MHz)
-        val = 0x05;
+		val = 0x05;
 	else if(ddr_clk < 360 * MHz)
-        val = 0x15; 
+		val = 0x15; 
 	else if(ddr_clk < 400 * MHz)
-        val = 0x25;
+		val = 0x25;
 	else if(ddr_clk < 450 * MHz)
-        val = 0x06; 
+		val = 0x06; 
 	else if(ddr_clk < 500 * MHz)
-        val = 0x16;
+		val = 0x16;
 	else if(ddr_clk < 550 * MHz)
-        val = 0x07;
+		val = 0x07;
 	else if(ddr_clk < 600 * MHz)
-        val = 0x17;
+		val = 0x17;
 	else if(ddr_clk < 650 * MHz)
-        val = 0x08;
+		val = 0x08;
 	else if(ddr_clk < 700 * MHz)
-        val = 0x18;
+		val = 0x18;
 	else if(ddr_clk < 750 * MHz)
-        val = 0x09;
+		val = 0x09;
 	else if(ddr_clk < 800 * MHz)
-        val = 0x19;
-    else if(ddr_clk < 850 * MHz)
-        val = 0x29;
-    else if(ddr_clk < 900 * MHz)
-        val = 0x39;
-    else if(ddr_clk < 950 * MHz)
-        val = 0x0a;
-    else if(ddr_clk < 1000 * MHz)
-        val = 0x1a;
-    else if(ddr_clk < 1050 * MHz)
-        val = 0x2a;
-    else if(ddr_clk < 1100* MHz)
-        val = 0x3a;
-    else if(ddr_clk < 1150* MHz)
-        val = 0x0b;
-    else if(ddr_clk < 1200 * MHz)
-        val = 0x1b;
-    else if(ddr_clk < 1250 * MHz)
-        val = 0x2b;
-    else if(ddr_clk < 1300 * MHz)
-        val = 0x3b;
-    else if(ddr_clk < 1350 * MHz)
-        val = 0x0c;
-    else if(ddr_clk < 1400* MHz)
-        val = 0x1c;
-    else if(ddr_clk < 1450* MHz)
-        val = 0x2c;
-    else if(ddr_clk <= 1500* MHz)
-        val = 0x3c;
-
-    //N=2,M=84
-    test_data[0] = val << 1;
-    rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
-
-    test_data[0] = prediv- 1;
-    rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
-    
-    test_data[0] = (fbdiv - 1) & 0x1f; //0x14; 
-    rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
-    
-    test_data[0] = (fbdiv - 1) >> 5 | 0x80;  //0x82
-    rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
-    
-    test_data[0] = 0x30;
-    rk32_dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
-    mdelay(100);
-
-    test_data[0] = 0x00;
-    // rk32_dwc_phy_test_wr(dsi, 0x60, test_data, 1);
-
-    test_data[0] = 0x81;
-    // rk32_dwc_phy_test_wr(dsi, 0x61, test_data, 1);
-
-    test_data[0] = 0x0;
-    // rk32_dwc_phy_test_wr(dsi, 0x62, test_data, 1);
-
-    test_data[0] = 0x80 | 15;
-    rk32_dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
-
-    test_data[0] = 0x80 | 85;
-    rk32_dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
+		val = 0x19;
+	else if(ddr_clk < 850 * MHz)
+		val = 0x29;
+	else if(ddr_clk < 900 * MHz)
+		val = 0x39;
+	else if(ddr_clk < 950 * MHz)
+		val = 0x0a;
+	else if(ddr_clk < 1000 * MHz)
+		val = 0x1a;
+	else if(ddr_clk < 1050 * MHz)
+		val = 0x2a;
+	else if(ddr_clk < 1100* MHz)
+		val = 0x3a;
+	else if(ddr_clk < 1150* MHz)
+		val = 0x0b;
+	else if(ddr_clk < 1200 * MHz)
+		val = 0x1b;
+	else if(ddr_clk < 1250 * MHz)
+		val = 0x2b;
+	else if(ddr_clk < 1300 * MHz)
+		val = 0x3b;
+	else if(ddr_clk < 1350 * MHz)
+		val = 0x0c;
+	else if(ddr_clk < 1400* MHz)
+		val = 0x1c;
+	else if(ddr_clk < 1450* MHz)
+		val = 0x2c;
+	else if(ddr_clk <= 1500* MHz)
+		val = 0x3c;
+
+	test_data[0] = val << 1;
+	rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
+
+	test_data[0] = prediv- 1;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) & 0x1f; 
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) >> 5 | 0x80; 
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = 0x30;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
+	mdelay(2);
+
+	test_data[0] = 0x4d;
+	rk32_dwc_phy_test_wr(dsi, 0x20, test_data, 1);
+	
+	test_data[0] = 0x3d;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
+	
+	test_data[0] = 0xdf;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1); 	
+	
+	test_data[0] =  0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
 
-    test_data[0] = 0x40 | 10;
-    rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
+	test_data[0] = 0x80 | 0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
 
+	test_data[0] = 0x80 | 15;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
 
-    // test_data[0] = 0x80 | 127;
-    // rk32_dwc_phy_test_wr(dsi, 0x71, test_data, 1);
+	test_data[0] = 0x80 | 85;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
 
-    // test_data[0] = 0x3;
-    // rk32_dwc_phy_test_wr(dsi, 0x57, test_data, 1);
+	test_data[0] = 0x40 | 10;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
 
     return 0;
 }
 
-static int rk32_mipi_dsi_phy_power_up(struct dsi *dsi)
-{
-	return rk32_phy_power_up(dsi);
-}
-
-static int rk32_mipi_dsi_phy_power_down(struct dsi *dsi) 
-{
-	return rk32_phy_power_down(dsi);
-}
-
-static int rk32_mipi_dsi_phy_init(struct dsi *dsi) 
-{
-	return rk32_phy_init(dsi);
-}
-
 static int rk32_mipi_dsi_host_power_up(struct dsi *dsi) 
 {
 	int ret = 0;
-	u32 val = 0;
-	
+	u32 val;
+
 	//disable all interrupt            
 	rk32_dsi_set_bits(dsi, 0x1fffff, INT_MKS0);
-	rk32_dsi_set_bits(dsi, 0x1ffff, INT_MKS1);
+	rk32_dsi_set_bits(dsi, 0x3ffff, INT_MKS1);
 
 	rk32_mipi_dsi_is_enable(dsi, 1);
 	
@@ -378,7 +385,7 @@ static int rk32_mipi_dsi_host_power_up(struct dsi *dsi)
 	
 	if(val == 0) {
 		ret = -1;
-		MIPI_TRACE("%s:phylock fail\n", __func__);	
+		MIPI_TRACE("%s:phylock fail.\n", __func__);	
 	}
 	
 	val = 10;
@@ -413,15 +420,19 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 			rk32_dsi_set_bits(dsi, 5, dpi_color_coding);
 			bytes_px = 3;
 			break;
+		
 		case OUT_D888_P666:
+		
 		case OUT_P666:
 			rk32_dsi_set_bits(dsi, 3, dpi_color_coding);
 			rk32_dsi_set_bits(dsi, 1, en18_loosely);
 			bytes_px = 3;
 			break;
+		
 		case OUT_P565:
 			rk32_dsi_set_bits(dsi, 0, dpi_color_coding);
 			bytes_px = 2;
+		
 		default:
 			break;
 	}
@@ -461,10 +472,10 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 			rk32_dsi_set_bits(dsi, m, vid_pkt_size);
 			temp = m * lane * Tpclk / Ttxbyte_clk - m * bytes_px;
 			MIPI_DBG("%s:%d, %d\n", __func__, m, temp);
-			if(temp >= 12) {
-
+		
+			if(temp >= 12) 
 				rk32_dsi_set_bits(dsi, temp - 12, null_pkt_size);
-			}
+				
 			break;
 			
 		default:
@@ -508,10 +519,9 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 		
 	rk32_dsi_set_bits(dsi, 20, phy_hs2lp_time);
 	rk32_dsi_set_bits(dsi, 16, phy_lp2hs_time);	
-    
-   // rk32_dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane); //no sure
-  //  rk32_dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane); //no sure
 
+	// rk32_dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane); //no sure
+	//  rk32_dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane); //no sure
 
 	rk32_dsi_set_bits(dsi, 10000, max_rd_time);
 
@@ -531,8 +541,8 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 }
 
 /*
-	mipi protocol layer definition
-*/
+ *	mipi protocol layer definition
+ */
 static int rk_mipi_dsi_init(void *arg, u32 n)
 {
 	u32 decimals = 1000, i = 0, pre = 0;
@@ -548,28 +558,26 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 	}
 
 	if(((screen->type == SCREEN_DUAL_MIPI) && (rk_mipi_get_dsi_num() == 1)) ||  ((screen->type == SCREEN_MIPI) && (rk_mipi_get_dsi_num() == 2))){
-        MIPI_TRACE("dsi number and mipi type not match!\n");
+		MIPI_TRACE("dsi number and mipi type not match!\n");
 	    return -1;
-    }
+	}
 	    
 	dsi->phy.Tpclk = rk_fb_get_prmry_screen_pixclock();
 
-    if(dsi->phy.refclk)
+	if(dsi->phy.refclk)
 		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) ;
 
 	dsi->phy.sys_clk = dsi->phy.ref_clk;
 
 	printk("dsi->phy.sys_clk =%d\n",dsi->phy.sys_clk );
 
-    if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
-        dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
-    else
-        dsi->phy.ddr_clk = screen->hs_tx_clk;   
+	if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
+		dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
+	else
+		dsi->phy.ddr_clk = screen->hs_tx_clk;   
 
-/*	if(n != 0) {
+	if(n != 0) 
 		dsi->phy.ddr_clk = n;
-	}
-    */
 
 	decimals = dsi->phy.ref_clk;
 	for(i = 1; i < 6; i++) {
@@ -617,11 +625,11 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 				dsi->phy.Ttxbyte_clk);
 	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
 	
-	rk32_mipi_dsi_phy_power_up(dsi);
+	rk32_phy_power_up(dsi);
 	rk32_mipi_dsi_host_power_up(dsi);
-	rk32_mipi_dsi_phy_init(dsi);
+	rk32_phy_init(dsi);
 	rk32_mipi_dsi_host_init(dsi);
-		
+	
 	return 0;
 }
 
@@ -655,6 +663,7 @@ static int rk32_mipi_dsi_enable_command_mode(void *arg, u32 enable)
 static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
 {
 	struct dsi *dsi = arg;
+	
 	rk32_dsi_set_bits(dsi, enable, phy_txrequestclkhs);
 	return 0;
 }
@@ -662,136 +671,143 @@ static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
 static int rk32_mipi_dsi_is_active(void *arg)
 {
 	struct dsi *dsi = arg;
+	
 	return rk32_dsi_get_bits(dsi, shutdownz);
 }
 
-static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 n)
+static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length)
 {
 	struct dsi *dsi = arg;
-	u32 type = cmds[1];
-	unsigned char *regs = cmds;
-	u32 data = 0, i = 0, j = 0;
-	n -= 2;
+	unsigned char regs[25] = {0}; 
+	u32 type, liTmp = 0, i = 0, j = 0, data = 0;
 
 	if(rk32_dsi_get_bits(dsi, gen_cmd_full) == 1) {
 		MIPI_TRACE("gen_cmd_full\n");
 		return -1;
 	}
-  
-    switch(type)
-    {
-        case DTYPE_DCS_SWRITE_0P:
-            rk32_dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
-            data = regs[2] << 8 | type;
-            break;
-            
-        case DTYPE_DCS_SWRITE_1P:
-            rk32_dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
-            data = regs[2] << 8 | type;
-            data |= regs[3] << 16;
-            break;
-            
-        case DTYPE_DCS_LWRITE: 
-            rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx);
-            for(i = 0; i < n; i++)
-            {
-                regs[i] = regs[i+2];
-            }
-        	for(i = 0; i < n; i++) {
-        		j = i % 4;
-        		data |= regs[i] << (j * 8);
-        		if(j == 3 || ((i + 1) == n)) {
-        			#ifndef CONFIG_MFD_RK616
-        			if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-        				MIPI_TRACE("gen_pld_w_full :%d\n", i);
-        				break;
-        			}
-        			#endif
-        			rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-        			MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-        			data = 0;
-        		}
-        	}
-        	
-        	data = type;	
-        	data |= (n & 0xffff) << 8;
-        	
-            break;
-            
-        case DTYPE_GEN_LWRITE:
-            rk32_dsi_set_bits(dsi, regs[0], gen_lw_tx);
-            
-            for(i = 0; i < n; i++)
-            {
-                regs[i] = regs[i+2];
-            }
-            
-    		for(i = 0; i < n; i++) {
-    			j = i % 4;
-    			data |= regs[i] << (j * 8);
-    			if(j == 3 || ((i + 1) == n)) {
-    				#ifndef CONFIG_MFD_RK616
-    				if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-    					MIPI_TRACE("gen_pld_w_full :%d\n", i);
-    					break;
-    				}
-    				#endif
-    				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-    				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-    				data = 0;
-    			}
-    		}
-    		data = (dsi->vid << 6) | type;		
-    		data |= (n & 0xffff) << 8;
-            break;
-            
-        case DTYPE_GEN_SWRITE_2P:
-        
-            rk32_dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
-            for(i = 0; i < n; i++)
-            {
-                regs[i] = regs[i+2];
-            }
-            
-            for(i = 0; i < n; i++) {
-            	j = i % 4;
-            	data |= regs[i] << (j * 8);
-            	if(j == 3 || ((i + 1) == n)) {
-                    #ifndef CONFIG_MFD_RK616
-            		if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-            			MIPI_TRACE("gen_pld_w_full :%d\n", i);
-            			break;
-            		}
-                    #endif
-            		rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-            		MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-            		data = 0;
-            	}
-            }
-            data = type;		
-            data |= (n & 0xffff) << 8;
-
-            break;
-            
-        case DTYPE_GEN_SWRITE_1P:
-            rk32_dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
-            data = type;
-            data |= regs[2] << 8;
-            data |= regs[3] << 16;
-            break;
-            
-        case DTYPE_GEN_SWRITE_0P:
-            rk32_dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);
-            data =  type;
-            data |= regs[2] << 8;
-            
-            break;
-            
-    }
-
-    MIPI_DBG(":%d command sent in %s size:%d\n", __LINE__, regs[0] ? "LP mode" : "HS mode", n);
-    
-    MIPI_DBG("write GEN_HDR:%08x\n", data);
+	
+	for(i = 0; i < length; i++){
+		regs[i] = cmds[i];
+	}
+	
+	liTmp	= length - 2;
+	type	= regs[1];
+	
+	switch(type)
+	{
+		case DTYPE_DCS_SWRITE_0P:
+			rk32_dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
+			data = regs[2] << 8 | type;
+			break;
+		
+		case DTYPE_DCS_SWRITE_1P:
+			rk32_dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
+			data = regs[2] << 8 | type;
+			data |= regs[3] << 16;
+			break;
+		    
+		case DTYPE_DCS_LWRITE: 
+			rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx);
+		
+			for(i = 0; i < liTmp; i++){
+			    regs[i] = regs[i+2];
+		    }
+		
+			for(i = 0; i < liTmp; i++) {
+				j = i % 4;
+				
+				data |= regs[i] << (j * 8);
+				if(j == 3 || ((i + 1) == liTmp)) {
+					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+						MIPI_TRACE("gen_pld_w_full :%d\n", i);
+						break;
+					}
+					
+					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+					data = 0;
+				}
+			}
+			
+			data = type;	
+			data |= (liTmp & 0xffff) << 8;
+			
+			break;
+			
+		case DTYPE_GEN_LWRITE:
+			rk32_dsi_set_bits(dsi, regs[0], gen_lw_tx);
+			
+			for(i = 0; i < liTmp; i++){
+				regs[i] = regs[i+2];
+			}
+			
+			for(i = 0; i < liTmp; i++) {
+				j = i % 4;
+				
+				data |= regs[i] << (j * 8);
+				if(j == 3 || ((i + 1) == liTmp)) {
+					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+						MIPI_TRACE("gen_pld_w_full :%d\n", i);
+						break;
+					}
+					
+					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+					data = 0;
+				}
+			}
+		
+			data = (dsi->vid << 6) | type;		
+			data |= (liTmp & 0xffff) << 8;
+			break;
+	
+		case DTYPE_GEN_SWRITE_2P:
+			
+			rk32_dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
+			for(i = 0; i < liTmp; i++){
+			    regs[i] = regs[i+2];
+			}
+			
+			for(i = 0; i < liTmp; i++) {
+				j = i % 4;
+				data |= regs[i] << (j * 8);
+				if(j == 3 || ((i + 1) == liTmp)) {
+					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+						MIPI_TRACE("gen_pld_w_full :%d\n", i);
+						break;
+					}
+					
+					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+					data = 0;
+				}
+			}
+			data = type;		
+			data |= (liTmp & 0xffff) << 8;
+
+			break;
+			
+		case DTYPE_GEN_SWRITE_1P:
+			rk32_dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
+			data = type;
+			data |= regs[2] << 8;
+			data |= regs[3] << 16;
+			break;
+			
+		case DTYPE_GEN_SWRITE_0P:
+			rk32_dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);
+			data =  type;
+			data |= regs[2] << 8;
+			break;
+
+		default:
+		   printk("0x%x:this type not suppport!\n",type);
+			
+	}
+
+	MIPI_DBG("%d command sent in %s size:%d\n", __LINE__, regs[0] ? "LP mode" : "HS mode", liTmp);
+	
+	MIPI_DBG("write GEN_HDR:%08x\n", data);
 	rk32_dsi_set_bits(dsi, data, GEN_HDR);
 	
 	i = 10;
@@ -801,12 +817,12 @@ static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 n)
 	}
 	udelay(10);
 
-    return 0;
+	return 0;
 }
 
 static int rk32_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
 {
-    struct dsi *dsi = arg;
+	struct dsi *dsi = arg;
 	//DCS READ 
 	//unsigned char *regs = data;
 	unsigned char regs[2];
@@ -814,43 +830,43 @@ static int rk32_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
 	int type = 0x06;
 	regs[0] = LPDT;
 	regs[1] = 0x0a;
-	 n = n - 1;
-	
-	
+	n = n - 1;
+
+				
 	rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
 	
+	/* if(type == DTYPE_GEN_SWRITE_0P)
+		data = (dsi->vid << 6) | (n << 4) | type;
+	else 
+		data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
 
-   /* if(type == DTYPE_GEN_SWRITE_0P)
-        data = (dsi->vid << 6) | (n << 4) | type;
-    else 
-        data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
-        
-    data |= regs[1] << 8 | type;
-   // if(n == 2)
-    //    data |= regs[1] << 16;
+	data |= regs[1] << 8 | type;
+	// if(n == 2)
+	//    data |= regs[1] << 16;
 
-    MIPI_DBG("write GEN_HDR:%08x\n", data);
+	MIPI_DBG("write GEN_HDR:%08x\n", data);
 	rk32_dsi_set_bits(dsi, data, GEN_HDR);
-    msleep(100);
+	msleep(100);
     
-   // rk32_dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
+	// rk32_dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
 
-    printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
-    msleep(100);
+	printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	msleep(100);
 
-  //  rk32_dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
-    
-    msleep(100);
-    // printk("_____rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	//  rk32_dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
+	
+	msleep(100);
+	// printk("_____rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
 	
-    msleep(100);
+	msleep(100);
 	return 0;
 }
 
 static int rk32_mipi_dsi_power_up(void *arg)
 {
 	struct dsi *dsi = arg;
-	rk32_mipi_dsi_phy_power_up(dsi);
+	
+	rk32_phy_power_up(dsi);
 	rk32_mipi_dsi_host_power_up(dsi);
 	return 0;
 }
@@ -859,16 +875,13 @@ static int rk32_mipi_dsi_power_down(void *arg)
 {
 	struct dsi *dsi = arg;
 	struct mipi_dsi_screen *screen = &dsi->screen;
-	
+
 	if(!screen)
 		return -1;
-		
+
 	rk32_mipi_dsi_host_power_down(dsi);
-	rk32_mipi_dsi_phy_power_down(dsi);
-#if defined(CONFIG_ARCH_RK319X)
-	clk_disable(dsi->dsi_pd);
-	clk_disable(dsi->dsi_pclk);
-#endif
+	rk32_phy_power_down(dsi);
+
 	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
 	return 0;
 }
@@ -877,7 +890,9 @@ static int rk32_mipi_dsi_get_id(void *arg)
 {
 	u32 id = 0;
 	struct dsi *dsi = arg;
-	id = rk32_dsi_get_bits(dsi, VERSION);
+	
+	id	= rk32_dsi_get_bits(dsi, VERSION);
+	
 	return id;
 }
 
@@ -994,7 +1009,7 @@ int reg_proc_write(struct file *file, const char __user *buff, size_t count, lof
 					msleep(1000);
 				}
 			break;
-	
+
 		default:
 			break;
 	}
@@ -1011,7 +1026,6 @@ int reg_proc_read(struct file *file, char __user *buff, size_t count,
 	int i = 0;
 	u32 val = 0;
 
-
     for(i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
 		val = rk32_dsi_get_bits(dsi0, i);
 		MIPI_TRACE("%04x: %08x\n", i>>16, val);
@@ -1030,11 +1044,11 @@ int reg_proc_open(struct inode *inode, struct file *file)
 
 int reg_proc_close(struct inode *inode, struct file *file)
 {
-	return 0;   
+	return 0; 
 }
 
 struct file_operations reg_proc_fops = {
-    .owner  = THIS_MODULE,
+	.owner  = THIS_MODULE,
 	.open   = reg_proc_open,
 	.release= reg_proc_close,
 	.write  = reg_proc_write,
@@ -1169,11 +1183,11 @@ int reg_proc_open1(struct inode *inode, struct file *file)
 
 int reg_proc_close1(struct inode *inode, struct file *file)
 {
-	return 0;   
+	return 0;
 }
 
 struct file_operations reg_proc_fops1 = {
-    .owner  = THIS_MODULE,
+	.owner  = THIS_MODULE,
 	.open   = reg_proc_open1,
 	.release= reg_proc_close1,
 	.write  = reg_proc_write1,
@@ -1183,98 +1197,94 @@ struct file_operations reg_proc_fops1 = {
 
 static irqreturn_t rk32_mipi_dsi_irq_handler(int irq, void *data)
 {
+	printk("-------rk32_mipi_dsi_irq_handler-------\n");
 	return IRQ_HANDLED;
-	//return IRQ_NONE;
 }
 
-
 static int rk32_dsi_enable(void)
-{   
-    MIPI_DBG("rk32_dsi_enable-------\n");
-    dsi_init(0, 0);
-    if (rk_mipi_get_dsi_num() ==2)
-        dsi_init(1, 0);
-		
-    rk_mipi_screen_standby(0);    
+{
+	MIPI_DBG("rk32_dsi_enable-------\n");
+	dsi_init(0, 0);
+	if (rk_mipi_get_dsi_num() ==2)
+		dsi_init(1, 0);
+
+	rk_mipi_screen_standby(0);
 
 	/*
 		After the core reset, DPI waits for the first VSYNC active transition to start signal sampling, including
 		pixel data, and preventing image transmission in the middle of a frame.
 	*/
-    dsi_is_enable(0, 0);
-    if (rk_mipi_get_dsi_num() ==2)
-        dsi_is_enable(1, 0);     
-
-    dsi_enable_video_mode(0, 1);
-    dsi_enable_video_mode(1, 1);
+	dsi_is_enable(0, 0);
+	if (rk_mipi_get_dsi_num() ==2)
+		dsi_is_enable(1, 0);  
 
+	dsi_enable_video_mode(0, 1);
+	dsi_enable_video_mode(1, 1);
 
-    dsi_is_enable(0, 1);
-    if (rk_mipi_get_dsi_num() ==2)
-        dsi_is_enable(1, 1);
+	dsi_is_enable(0, 1);
+	if (rk_mipi_get_dsi_num() ==2)
+		dsi_is_enable(1, 1);
 
-    return 0;
+	return 0;
 }
 
 static int rk32_dsi_disable(void)
 {
-    MIPI_DBG("rk32_dsi_disable-------\n");
-    
+	MIPI_DBG("rk32_dsi_disable-------\n");
+	
 	rk_mipi_screen_standby(1); 
-    dsi_power_off(0);
-    if (rk_mipi_get_dsi_num() ==2)
-        dsi_power_off(1);
-    
-    return 0;
+	dsi_power_off(0);
+	if (rk_mipi_get_dsi_num() ==2)
+		dsi_power_off(1);
+
+	return 0;
 }
 
 static struct rk_fb_trsm_ops trsm_dsi_ops = 
 {
-    .enable = rk32_dsi_enable,
-    .disable = rk32_dsi_disable,
+	.enable = rk32_dsi_enable,
+	.disable = rk32_dsi_disable,
 };
 
 static void rk32_init_phy_mode(int lcdc_id)
 { 
-    int val0 = 0, val1 = 0;
+	int val0 = 0, val1 = 0;
 
-    MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n",lcdc_id);
-    //D-PHY mode select
-    if( rk_mipi_get_dsi_num() ==1 ){
-    
-        if(lcdc_id == 1)
-        //val0 =0x1 << 25 | 0x1 << 9;
-           val0 = 0x1 << 22 | 0x1 << 6;  //1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0
-        else
-           val0 = 0x1 << 22 | 0x0 << 6; 
-
-        writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
-    }
-    else{
-        if(lcdc_id == 1){
-            val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6; 
-            val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
-         }
-         else{
-            val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14; 
-            val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;        
-         }
-         
-         writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
-         writel_relaxed(val1, RK_GRF_VIRT + RK3288_GRF_SOC_CON14);    
-    }
+	MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n",lcdc_id);
+	//D-PHY mode select
+	if( rk_mipi_get_dsi_num() ==1 ){
+	
+		if(lcdc_id == 1)
+			//val0 =0x1 << 25 | 0x1 << 9;
+			val0 = 0x1 << 22 | 0x1 << 6;  //1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0
+		else
+			val0 = 0x1 << 22 | 0x0 << 6; 
 
+		writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+	}
+	else{
+		if(lcdc_id == 1){
+			val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6; 
+			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
+		}
+		else{
+			val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14; 
+			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
+		}
+
+		writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+		writel_relaxed(val1, RK_GRF_VIRT + RK3288_GRF_SOC_CON14);
+	}
 }
 
 static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 {
-	int ret = 0;
+	int ret = 0; 
+	static id = 0;
 	struct dsi *dsi;
 	struct mipi_dsi_ops *ops;
 	struct rk_screen *screen;
 	struct mipi_dsi_screen *dsi_screen;
-	static int id = 0;
-	
 	struct resource *res_host;
 
 	dsi = devm_kzalloc(&pdev->dev, sizeof(struct dsi), GFP_KERNEL);
@@ -1285,30 +1295,28 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 
 	res_host = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
-	if (!dsi->host.membase)
+	if (!dsi->host.membase){
+		dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
 		return -ENOMEM;
-
-    dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m"); 
+	}
+	
+	dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m"); 
 	if (unlikely(IS_ERR(dsi->phy.refclk))) {
 		dev_err(&pdev->dev, "get clk_mipi_24m clock fail\n");
-		ret = PTR_ERR(dsi->phy.refclk);
-		//goto probe_err6;
+		return PTR_ERR(dsi->phy.refclk);
 	}
 
-   dsi->dsi_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi");
-   if (unlikely(IS_ERR(dsi->dsi_pclk))) {
-       dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
-       ret = PTR_ERR(dsi->dsi_pclk);
-       //goto probe_err7;
-   }
-
-    dsi->dsi_pd = devm_clk_get(&pdev->dev, "pd_mipi_dsi");
-    if (unlikely(IS_ERR(dsi->dsi_pd))) {
-        dev_err(&pdev->dev, "get pd_mipi_dsi clock fail\n");
-        ret = PTR_ERR(dsi->dsi_pd);
-        //goto probe_err7;
-    }
+	dsi->dsi_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pclk))) {
+		dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
+		return PTR_ERR(dsi->dsi_pclk);
+	}
 
+	dsi->dsi_pd = devm_clk_get(&pdev->dev, "pd_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pd))) {
+		dev_err(&pdev->dev, "get pd_mipi_dsi clock fail\n");
+		return PTR_ERR(dsi->dsi_pd);
+	}
 
 	dsi->host.irq = platform_get_irq(pdev, 0);
 	if (dsi->host.irq < 0) {
@@ -1319,17 +1327,16 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	ret = request_irq(dsi->host.irq, rk32_mipi_dsi_irq_handler, 0,dev_name(&pdev->dev), dsi);
 	if(ret) {
 		dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
-		ret = -EINVAL;
-		goto probe_err1;
+		return -EINVAL;
 	}
-    printk("dsi->host.irq =%d\n",dsi->host.irq); 
+	printk("dsi->host.irq =%d\n",dsi->host.irq); 
 
-    disable_irq(dsi->host.irq);
+	disable_irq(dsi->host.irq);
 
 	screen = devm_kzalloc(&pdev->dev, sizeof(struct rk_screen), GFP_KERNEL);
 	if(!screen) {
 		dev_err(&pdev->dev,"request struct rk_screen fail!\n");
-		goto probe_err9;
+		return -1;
 	}
 	rk_fb_get_prmry_screen(screen);
 
@@ -1364,16 +1371,16 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	dsi_screen->x_res = screen->mode.xres;
 	dsi_screen->y_res = screen->mode.yres;
 	dsi_screen->pin_hsync = screen->pin_hsync;
-    dsi_screen->pin_vsync = screen->pin_vsync;
+	dsi_screen->pin_vsync = screen->pin_vsync;
 	dsi_screen->pin_den = screen->pin_den;
 	dsi_screen->pin_dclk = screen->pin_dclk;
-    dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
+	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
 //  dsi_screen->dsi_video_mode = screen->dsi_video_mode; //no sure
 	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
 	dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();  
 	dsi_screen->lcdc_id = 1;
-    
-	dsi->dsi_id = id++;//of_alias_get_id(pdev->dev.of_node, "dsi");
+
+	dsi->dsi_id = id++;
 
 	sprintf(ops->name, "rk_mipi_dsi.%d", dsi->dsi_id);
 	platform_set_drvdata(pdev, dsi);
@@ -1382,62 +1389,34 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	if(ret) {
 		dev_err(&pdev->dev,"rk mipi_dsi probe fail!\n");
 		dev_err(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
-		goto probe_err11;
+		return -1;
 	}	
-    
-    if(id == 1){
-        rk32_init_phy_mode(dsi_screen->lcdc_id);
-        rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
-        
+
+	if(id == 1){
+		rk32_init_phy_mode(dsi_screen->lcdc_id);
+		rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
+	
 #ifdef MIPI_DSI_REGISTER_IO        
 		debugfs_create_file("mipidsi0", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
 							&reg_proc_fops);
 #endif
-        dsi0 = dsi;
-        
-    }else{   
-        dsi1 = dsi;
-        
+		dsi0 = dsi;
+	}else{   
+		dsi1 = dsi;
+
 #ifdef MIPI_DSI_REGISTER_IO  
         debugfs_create_file("mipidsi1", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
 							&reg_proc_fops1);
 #endif
 
-    }
-    
+	}
+
 	dev_info(&pdev->dev,"rk mipi_dsi probe success!\n");
 	dev_info(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
-	return 0;
-
-probe_err11:
-
-
-probe_err9:
-#if defined(CONFIG_ARCH_RK319X)
-	clk_put(dsi->dsi_pd);
-probe_err8:
-	clk_put(dsi->dsi_pclk);
-probe_err7:
-	clk_put(dsi->phy.refclk);
-probe_err6:
-	free_irq(dsi->host.irq, dsi);
-probe_err5:
-	iounmap(dsi->phy.membase);
-probe_err4:
-	release_mem_region(res_phy->start, resource_size(res_phy));
-probe_err3:
-	iounmap(dsi->host.membase);
-probe_err2:
-	release_mem_region(res_host->start, resource_size(res_host));
-#endif
-
-probe_err1:
-
-	return ret;
 	
+	return ret;
 }
 
-
 #ifdef CONFIG_OF
 static const struct of_device_id of_rk_mipi_dsi_match[] = {
 	{ .compatible = "rockchip,rk32-dsi" }, 
@@ -1446,7 +1425,7 @@ static const struct of_device_id of_rk_mipi_dsi_match[] = {
 #endif
 
 static struct platform_driver rk32_mipi_dsi_driver = {
-    .probe		= rk32_mipi_dsi_probe,
+	.probe		= rk32_mipi_dsi_probe,
 	.driver		= {
 		.name	= "rk32-mipi",
 		.owner	= THIS_MODULE,
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
index d9a2e8dbfd2a..38568285a749 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
@@ -2,8 +2,8 @@
 drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 */
 #include <linux/rockchip/grf.h>
-#ifndef RK616_MIPI_DSI_H
-#define RK616_MIPI_DSI_H
+#ifndef RK32_MIPI_DSI_H
+#define RK32_MIPI_DSI_H
 
 #define MIPI_DSI_HOST_OFFSET	0x1000
 
@@ -35,11 +35,11 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define bta_en 						DSI_HOST_BITS(0x02c, 1, 2)
 #define eotp_rx_en 					DSI_HOST_BITS(0x02c, 1, 1)
 #define eotp_tx_en 					DSI_HOST_BITS(0x02c, 1, 0)
-#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0) //libing (0x030, 2, 5)-> (0x030, 2, 0)
+#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0) 
 #define cmd_video_mode 				DSI_HOST_BITS(0x034, 1, 0)
-#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24) //libing 
-#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20) //libing 
-#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16) //libing 
+#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24) 
+#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20) 
+#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16) 
 #define lp_cmd_en  					DSI_HOST_BITS(0x038, 1, 15)
 #define frame_bta_ack_en 			DSI_HOST_BITS(0x038, 1, 14)
 #define lp_hfp_en 					DSI_HOST_BITS(0x038, 1, 13)
@@ -97,15 +97,15 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 //#define mode_3d		 				DSI_HOST_BITS(0x090, 2, 0)		//new
 #define auto_clklane_ctrl 			DSI_HOST_BITS(0x094, 1, 1)		//new
 #define phy_txrequestclkhs 			DSI_HOST_BITS(0x094, 1, 0)
-#define phy_hs2lp_time_clk_lane     DSI_HOST_BITS(0x098, 10, 16) //libing
-#define phy_hs2hs_time_clk_lane     DSI_HOST_BITS(0x098, 10, 0) //libing
+#define phy_hs2lp_time_clk_lane     DSI_HOST_BITS(0x098, 10, 16) 
+#define phy_hs2hs_time_clk_lane     DSI_HOST_BITS(0x098, 10, 0) 
 #define phy_hs2lp_time 				DSI_HOST_BITS(0x09c, 8, 24)
 #define phy_lp2hs_time 				DSI_HOST_BITS(0x09c, 8, 16)
 #define max_rd_time 				DSI_HOST_BITS(0x09c, 15, 0)
 #define phy_forcepll 				DSI_HOST_BITS(0x0a0, 1, 3)		//new Dependency: DSI_HOST_FPGA = 0. Otherwise, this bit is reserved.
 #define phy_enableclk 				DSI_HOST_BITS(0x0a0, 1, 2)
-#define phy_rstz 					DSI_HOST_BITS(0x0a0, 1, 1)  //libing
-#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0) //libing 
+#define phy_rstz 					DSI_HOST_BITS(0x0a0, 1, 1) 
+#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0) 
 #define phy_stop_wait_time 			DSI_HOST_BITS(0x0a4, 8, 8)
 #define n_lanes 					DSI_HOST_BITS(0x0a4, 2, 0)
 #define phy_txexitulpslan 			DSI_HOST_BITS(0x0a8, 1, 3)
@@ -128,9 +128,9 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define INT_ST0 					DSI_HOST_BITS(0x0bc, 21, 0)
 #define INT_ST1 					DSI_HOST_BITS(0x0c0, 18, 0)
 #define INT_MKS0 					DSI_HOST_BITS(0x0c4, 21, 0)
-#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0) //libing
-#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0) //libing
-#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0) //libing
+#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0) 
+#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0) 
+#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0) 
 
 #define code_hs_rx_clock            0x34
 #define code_hs_rx_lane0            0x44
@@ -242,4 +242,4 @@ int rk_mipi_get_dsi_clk(void);
 int rk_mipi_get_dsi_num(void);
 int rk_mipi_get_dsi_lane(void);
 
-#endif /* end of RK616_MIPI_DSI_H */
+#endif /* end of RK32_MIPI_DSI_H */
-- 
2.35.3

