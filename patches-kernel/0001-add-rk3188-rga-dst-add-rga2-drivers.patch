From d801335b2ff2139aa95059458d343511ef60e87a Mon Sep 17 00:00:00 2001
From: zsq <zsq@rock-chips.com>
Date: Sat, 1 Mar 2014 16:17:04 +0800
Subject: [PATCH] add rk3188 rga dst / add rga2 drivers

---
 arch/arm/boot/dts/rk3188.dtsi               |    8 +
 arch/arm/configs/rockchip_defconfig         |    2 +
 drivers/video/rockchip/Kconfig              |    1 +
 drivers/video/rockchip/Makefile             |    3 +-
 drivers/video/rockchip/rga/Kconfig          |    6 +-
 drivers/video/rockchip/rga/Makefile         |    2 +-
 drivers/video/rockchip/rga/rga_drv.c        |   62 +-
 drivers/video/rockchip/rga/rga_reg_info.c   |  646 ++++-----
 drivers/video/rockchip/rga2/Kconfig         |    9 +
 drivers/video/rockchip/rga2/Makefile        |    3 +
 drivers/video/rockchip/rga2/RGA2_API.c      |   22 +
 drivers/video/rockchip/rga2/RGA2_API.h      |   12 +
 drivers/video/rockchip/rga2/rga2.h          |  636 +++++++++
 drivers/video/rockchip/rga2/rga2_drv.c      | 1325 +++++++++++++++++++
 drivers/video/rockchip/rga2/rga2_mmu_info.c | 1001 ++++++++++++++
 drivers/video/rockchip/rga2/rga2_mmu_info.h |   20 +
 drivers/video/rockchip/rga2/rga2_reg_info.c | 1145 ++++++++++++++++
 drivers/video/rockchip/rga2/rga2_reg_info.h |  295 +++++
 drivers/video/rockchip/rga2/rga2_rop.h      |   57 +
 drivers/video/rockchip/rga2/rga2_type.h     |   48 +
 20 files changed, 4948 insertions(+), 355 deletions(-)
 create mode 100644 drivers/video/rockchip/rga2/Kconfig
 create mode 100644 drivers/video/rockchip/rga2/Makefile
 create mode 100644 drivers/video/rockchip/rga2/RGA2_API.c
 create mode 100644 drivers/video/rockchip/rga2/RGA2_API.h
 create mode 100644 drivers/video/rockchip/rga2/rga2.h
 create mode 100644 drivers/video/rockchip/rga2/rga2_drv.c
 create mode 100644 drivers/video/rockchip/rga2/rga2_mmu_info.c
 create mode 100644 drivers/video/rockchip/rga2/rga2_mmu_info.h
 create mode 100644 drivers/video/rockchip/rga2/rga2_reg_info.c
 create mode 100644 drivers/video/rockchip/rga2/rga2_reg_info.h
 create mode 100644 drivers/video/rockchip/rga2/rga2_rop.h
 create mode 100644 drivers/video/rockchip/rga2/rga2_type.h

diff --git a/arch/arm/boot/dts/rk3188.dtsi b/arch/arm/boot/dts/rk3188.dtsi
index 448a6305b330..0ece710ca1ad 100755
--- a/arch/arm/boot/dts/rk3188.dtsi
+++ b/arch/arm/boot/dts/rk3188.dtsi
@@ -407,6 +407,14 @@
 		pinctrl-0 = <&lcdc1_lcdc>;
 		pinctrl-1 = <&lcdc1_gpio>;
 		status = "disabled";
+  };
+  rga@10114000 {
+		compatible = "rockchip,rga";
+		reg = <0x10114000 0x1000>;
+		interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk_gates6 10>, <&clk_gates6 11>;
+    clock-names = "hclk_rga", "aclk_rga"; 
+		status = "disabled";
         };
 
     adc: adc@2006c000 {
diff --git a/arch/arm/configs/rockchip_defconfig b/arch/arm/configs/rockchip_defconfig
index 028d138b4c6d..2be2dad1f88d 100755
--- a/arch/arm/configs/rockchip_defconfig
+++ b/arch/arm/configs/rockchip_defconfig
@@ -497,4 +497,6 @@ CONFIG_LSM_MMAP_MIN_ADDR=4096
 CONFIG_SECURITY_SELINUX=y
 CONFIG_CRYPTO_NULL=y
 CONFIG_CRYPTO_TWOFISH=y
+CONFIG_ROCKCHIP_RGA=y
+# CONFIG_ROCKCHIP_RGA2=y
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index dfebf74759f1..303df7edbb09 100755
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -65,4 +65,5 @@ source "drivers/video/rockchip/transmitter/Kconfig"
 source "drivers/video/rockchip/hdmi/Kconfig"
 source "drivers/video/rockchip/tve/Kconfig"
 source "drivers/video/rockchip/rga/Kconfig"
+source "drivers/video/rockchip/rga2/Kconfig"
 
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 6db75ea4eca1..37d55ed42ada 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -1,4 +1,5 @@
 obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o lcdc/ 
 obj-$(CONFIG_RK_TRSM) += transmitter/
-obj-$(CONFIG_RGA_RK30) += rga/
+obj-$(CONFIG_ROCKCHIP_RGA) += rga/
+obj-$(CONFIG_ROCKCHIP_RGA2) += rga2/
 obj-$(CONFIG_RK_HDMI) += display-sys.o hdmi/
diff --git a/drivers/video/rockchip/rga/Kconfig b/drivers/video/rockchip/rga/Kconfig
index 0444c203bc87..6eb482848ba2 100755
--- a/drivers/video/rockchip/rga/Kconfig
+++ b/drivers/video/rockchip/rga/Kconfig
@@ -1,8 +1,8 @@
 menu "RGA"
-	depends on ARCH_RK30 || ARCH_RK2928 || ARCH_RK3188 || ARCH_RK3026
+	depends on ARCH_ROCKCHIP
 
-config RGA_RK30
-	tristate "ROCKCHIP RK30 || RK2928 RGA"
+config ROCKCHIP_RGA
+	tristate "ROCKCHIP_RGA"
 	help
 	  rk30 rga module.
 
diff --git a/drivers/video/rockchip/rga/Makefile b/drivers/video/rockchip/rga/Makefile
index 228838c635b2..1a476f0c7be9 100755
--- a/drivers/video/rockchip/rga/Makefile
+++ b/drivers/video/rockchip/rga/Makefile
@@ -1,3 +1,3 @@
 rga-y	:= rga_drv.o rga_mmu_info.o rga_reg_info.o RGA_API.o
 
-obj-$(CONFIG_RGA_RK30)	+= rga.o
+obj-$(CONFIG_ROCKCHIP_RGA)	+= rga.o
diff --git a/drivers/video/rockchip/rga/rga_drv.c b/drivers/video/rockchip/rga/rga_drv.c
index 29de27af6979..15d20b64511f 100755
--- a/drivers/video/rockchip/rga/rga_drv.c
+++ b/drivers/video/rockchip/rga/rga_drv.c
@@ -27,8 +27,8 @@
 #include <asm/io.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
-#include <mach/io.h>
-#include <mach/irqs.h>
+//#include <mach/io.h>
+//#include <mach/irqs.h>
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 #include <linux/miscdevice.h>
@@ -89,9 +89,9 @@ struct rga_drvdata {
 	void (*rga_irq_callback)(int rga_retval);   //callback function used by aync call
 	struct wake_lock wake_lock;
 
+    struct clk *pd_rga;
 	struct clk *aclk_rga;
-	struct clk *hclk_rga;
-	struct clk *pd_rga;
+    struct clk *hclk_rga;
 };
 
 static struct rga_drvdata *drvdata;
@@ -1122,9 +1122,18 @@ static struct miscdevice rga_dev ={
     .fops  = &rga_fops,
 };
 
-static int __devinit rga_drv_probe(struct platform_device *pdev)
+
+
+static const struct of_device_id rockchip_rga_of_match[] = {
+	{ .compatible = "rockchip,rga", .data = NULL, },
+	{},
+};
+
+static int rga_drv_probe(struct platform_device *pdev)
 {
 	struct rga_drvdata *data;
+    struct resource *res;
+    struct device_node *np = pdev->dev.of_node;
 	int ret = 0;
 
 	INIT_LIST_HEAD(&rga_service.waiting);
@@ -1138,9 +1147,8 @@ static int __devinit rga_drv_probe(struct platform_device *pdev)
 	rga_service.last_prc_src_format = 1; /* default is yuv first*/
 	rga_service.enable = false;
 
-	data = kzalloc(sizeof(struct rga_drvdata), GFP_KERNEL);
-	if(NULL == data)
-	{
+	data = devm_kzalloc(&pdev->dev, sizeof(struct rga_drvdata), GFP_KERNEL);
+	if(! data) {
 		ERR("failed to allocate driver data.\n");
 		return -ENOMEM;
 	}
@@ -1148,36 +1156,33 @@ static int __devinit rga_drv_probe(struct platform_device *pdev)
 	INIT_DELAYED_WORK(&data->power_off_work, rga_power_off_work);
 	wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "rga");
 
-	data->pd_rga = clk_get(NULL, "pd_rga");
-	data->aclk_rga = clk_get(NULL, "aclk_rga");
-	data->hclk_rga = clk_get(NULL, "hclk_rga");
+	//data->pd_rga = devm_clk_get(&pdev->dev, "pd_rga");
+    data->aclk_rga = devm_clk_get(&pdev->dev, "aclk_rga");
+    data->hclk_rga = devm_clk_get(&pdev->dev, "hclk_rga");
 
-	/* map the memory */
-	if (!request_mem_region(RK30_RGA_PHYS, RK30_RGA_SIZE, "rga_io"))
-	{
-		pr_info("failed to reserve rga HW regs\n");
-		return -EBUSY;
-	}
+    clk_prepare_enable(data->aclk_rga);
+    clk_prepare_enable(data->hclk_rga);
 
-	data->rga_base = (void*)ioremap_nocache(RK30_RGA_PHYS, RK30_RGA_SIZE);
-	if (data->rga_base == NULL)
-	{
+    /* map the registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->rga_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!data->rga_base) {
 		ERR("rga ioremap failed\n");
 		ret = -ENOENT;
 		goto err_ioremap;
 	}
 
 	/* get the IRQ */
-	data->irq = platform_get_irq(pdev, 0);
-	if (data->irq <= 0)
-	{
+	data->irq = ret = platform_get_irq(pdev, 0);
+	if (ret <= 0) {
 		ERR("failed to get rga irq resource (%d).\n", data->irq);
 		ret = data->irq;
 		goto err_irq;
 	}
 
 	/* request the IRQ */
-	ret = request_threaded_irq(data->irq, rga_irq, rga_irq_thread, 0, "rga", pdev);
+	//ret = request_threaded_irq(data->irq, rga_irq, rga_irq_thread, 0, "rga", pdev);
+    ret = devm_request_threaded_irq(&pdev->dev, data->irq, rga_irq, rga_irq_thread, 0, "rga", data);
 	if (ret)
 	{
 		ERR("rga request_irq failed (%d).\n", ret);
@@ -1219,17 +1224,20 @@ static int rga_drv_remove(struct platform_device *pdev)
 	free_irq(data->irq, &data->miscdev);
 	iounmap((void __iomem *)(data->rga_base));
 
-	clk_put(data->pd_rga);
+    clk_disable_unprepare(data->aclk_rga);
+    clk_disable_unprepare(data->hclk_rga);
+
+	//clk_put(data->pd_rga);
 	clk_put(data->aclk_rga);
 	clk_put(data->hclk_rga);
 
-	kfree(data);
+	//kfree(data);
 	return 0;
 }
 
 static struct platform_driver rga_driver = {
 	.probe		= rga_drv_probe,
-	.remove		= __devexit_p(rga_drv_remove),
+	.remove		= rga_drv_remove,
 	.driver		= {
 		.owner  = THIS_MODULE,
 		.name	= "rga",
diff --git a/drivers/video/rockchip/rga/rga_reg_info.c b/drivers/video/rockchip/rga/rga_reg_info.c
index 1d431f019492..cfb9465194f3 100755
--- a/drivers/video/rockchip/rga/rga_reg_info.c
+++ b/drivers/video/rockchip/rga/rga_reg_info.c
@@ -15,8 +15,8 @@
 #include <asm/io.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
-#include <mach/io.h>
-#include <mach/irqs.h>
+//#include <mach/io.h>
+//#include <mach/irqs.h>
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 #include <linux/miscdevice.h>
@@ -36,15 +36,15 @@
 #include "rga.h"
 
 
-/*************************************************************    
-Func:        
-    RGA_pixel_width_init    
-Description:        
-    select pixel_width form data format    
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_pixel_width_init
+Description:
+    select pixel_width form data format
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 unsigned char
 RGA_pixel_width_init(unsigned int format)
@@ -65,7 +65,7 @@ RGA_pixel_width_init(unsigned int format)
         case RK_FORMAT_RGBA_4444 :   pixel_width = 2;   break;
         case RK_FORMAT_BGR_888   :   pixel_width = 3;   break;
 
-        /* YUV FORMAT */    
+        /* YUV FORMAT */
         case RK_FORMAT_YCbCr_422_SP :   pixel_width = 1;  break;
         case RK_FORMAT_YCbCr_422_P  :   pixel_width = 1;  break;
         case RK_FORMAT_YCbCr_420_SP :   pixel_width = 1;  break;
@@ -80,16 +80,16 @@ RGA_pixel_width_init(unsigned int format)
     return pixel_width;
 }
 
-/*************************************************************    
-Func:        
-    dst_ctrl_cal    
-Description:        
-    calculate dst act window position / width / height 
-    and set the tile struct 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    dst_ctrl_cal
+Description:
+    calculate dst act window position / width / height
+    and set the tile struct
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 void
 dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
@@ -115,10 +115,10 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
     {
         pos[0] = xoff;
         pos[1] = yoff;
-           
+
         pos[2] = xoff;
         pos[3] = yoff + height - 1;
-            
+
         pos[4] = xoff + width - 1;
         pos[5] = yoff + height - 1;
 
@@ -127,16 +127,16 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
 
         xmax = MIN(MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmax);
         xmin = MAX(MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmin);
-        
+
         ymax = MIN(MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymax);
         ymin = MAX(MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymin);
-        
+
         //printk("xmax = %d, xmin = %d, ymin = %d, ymax = %d\n", xmax, xmin, ymin, ymax);
     }
     else if(msg->rotate_mode == 1)
     {
         if((sina == 0) || (cosa == 0))
-        {        
+        {
             if((sina == 0) && (cosa == -65536))
             {
                 /* 180 */
@@ -180,7 +180,7 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
                 pos[5] = yoff;
 
                 pos[6] = xoff + height - 1;
-                pos[7] = yoff - width + 1;        
+                pos[7] = yoff - width + 1;
             }
             else
             {
@@ -200,10 +200,10 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
 
             xmax = MIN(MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmax);
             xmin = MAX(MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmin);
-            
+
             ymax = MIN(MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymax);
             ymin = MAX(MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymin);
-        }               
+        }
         else
         {
             xx = msg->cosa;
@@ -219,7 +219,7 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
 
             x2 = width + xoff;
             y2 = height + yoff;
-            
+
             pos[0] = xoff;
             pos[1] = yoff;
 
@@ -246,19 +246,19 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
 
             //printk("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n", xmin, xmax, ymin, ymax);
         }
-    }    
-   
-    if ((xmax < xmin) || (ymax < ymin)) {    
+    }
+
+    if ((xmax < xmin) || (ymax < ymin)) {
         xmin = xmax;
         ymin = ymax;
-    }    
-    
-    if ((xmin >= msg->dst.vir_w)||(xmax < 0)||(ymin >= msg->dst.vir_h)||(ymax < 0)) {       
+    }
+
+    if ((xmin >= msg->dst.vir_w)||(xmax < 0)||(ymin >= msg->dst.vir_h)||(ymax < 0)) {
         xmin = xmax = ymin = ymax = 0;
     }
 
     //printk("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n", xmin, xmax, ymin, ymax);
-    
+
     tile->dst_ctrl.w = (xmax - xmin);
     tile->dst_ctrl.h = (ymax - ymin);
     tile->dst_ctrl.x_off = xmin;
@@ -273,23 +273,23 @@ dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
     tile->dst_y_tmp = ymin - msg->dst.y_offset;
 }
 
-/*************************************************************    
-Func:        
-    src_tile_info_cal    
-Description:        
-    calculate src remap window position / width / height 
-    and set the tile struct 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    src_tile_info_cal
+Description:
+    calculate src remap window position / width / height
+    and set the tile struct
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 void
 src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
 {
-    s32 x0, x1, x2, x3, y0, y1, y2, y3; 
-    
+    s32 x0, x1, x2, x3, y0, y1, y2, y3;
+
     int64_t xx, xy, yx, yy;
 
     int64_t pos[8];
@@ -307,10 +307,10 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
     yy = tile->matrix[3]; /* 32.32 */
 
     if(msg->rotate_mode == 1)
-    {    
+    {
         x0 = tile->dst_x_tmp;
         y0 = tile->dst_y_tmp;
-     
+
         x1 = x0;
         y1 = y0 + 8;
 
@@ -319,8 +319,8 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
 
         x3 = x0 + 8;
         y3 = y0;
-       
-        pos[0] = (x0*xx + y0*yx); 
+
+        pos[0] = (x0*xx + y0*yx);
         pos[1] = (x0*xy + y0*yy);
 
         pos[2] = (x1*xx + y1*yx);
@@ -355,31 +355,31 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
         y_dx = pos[2] - pos[0];
         y_dy = pos[3] - pos[1];
 
-        tile->x_dx = (s32)(x_dx >> 22 ); 
-        tile->x_dy = (s32)(x_dy >> 22 ); 
-        tile->y_dx = (s32)(y_dx >> 22 ); 
-        tile->y_dy = (s32)(y_dy >> 22 ); 
-        
+        tile->x_dx = (s32)(x_dx >> 22 );
+        tile->x_dy = (s32)(x_dy >> 22 );
+        tile->y_dx = (s32)(y_dx >> 22 );
+        tile->y_dy = (s32)(y_dy >> 22 );
+
         x_temp_start = x0*xx + y0*yx;
         y_temp_start = x0*xy + y0*yy;
-        
-        xmax = (MAX(MAX(MAX(epos[0], epos[2]), epos[4]), epos[6]));   
-        xmin = (MIN(MIN(MIN(epos[0], epos[2]), epos[4]), epos[6]));   
+
+        xmax = (MAX(MAX(MAX(epos[0], epos[2]), epos[4]), epos[6]));
+        xmin = (MIN(MIN(MIN(epos[0], epos[2]), epos[4]), epos[6]));
 
         ymax = (MAX(MAX(MAX(epos[1], epos[3]), epos[5]), epos[7]));
         ymin = (MIN(MIN(MIN(epos[1], epos[3]), epos[5]), epos[7]));
 
         t_xoff = (x_temp_start - xmin)>>18;
         t_yoff = (y_temp_start - ymin)>>18;
-        
+
         tile->tile_xoff = (s32)t_xoff;
         tile->tile_yoff = (s32)t_yoff;
-       
+
         tile->tile_w = (u16)((xmax - xmin)>>21); //.11
         tile->tile_h = (u16)((ymax - ymin)>>21); //.11
 
         tile->tile_start_x_coor = (s16)(xmin>>29); //.3
-        tile->tile_start_y_coor = (s16)(ymin>>29); //.3                    
+        tile->tile_start_y_coor = (s16)(ymin>>29); //.3
     }
     else if (msg->rotate_mode == 2)
     {
@@ -387,7 +387,7 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
         tile->x_dy = 0;
         tile->y_dx = 0;
         tile->y_dy = (s32)((8*yy)>>22);
-               
+
         tile->tile_w = ABS((s32)((7*xx)>>21));
         tile->tile_h = ABS((s32)((7*yy)>>21));
 
@@ -395,7 +395,7 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
         tile->tile_yoff = 0;
 
         tile->tile_start_x_coor = (((msg->src.act_w - 1)<<11) - (tile->tile_w))>>8;
-        tile->tile_start_y_coor = 0;                    
+        tile->tile_start_y_coor = 0;
     }
     else if (msg->rotate_mode == 3)
     {
@@ -403,7 +403,7 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
         tile->x_dy = 0;
         tile->y_dx = 0;
         tile->y_dy = (s32)((8*yy)>>22);
-        
+
         tile->tile_w = ABS((s32)((7*xx)>>21));
         tile->tile_h = ABS((s32)((7*yy)>>21));
 
@@ -412,7 +412,7 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
 
         tile->tile_start_x_coor = 0;
         tile->tile_start_y_coor = (((msg->src.act_h - 1)<<11) - (tile->tile_h))>>8;
-    }        
+    }
 
     if ((msg->scale_mode == 2)||(msg->alpha_rop_flag >> 7))
     {
@@ -426,23 +426,23 @@ src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_mode_ctrl    
-Description:        
-    fill mode ctrl reg info 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_set_mode_ctrl
+Description:
+    fill mode ctrl reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
-void    
+void
 RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
 {
     u32 *bRGA_MODE_CTL;
     u32 reg = 0;
-    
+
     u8 src_rgb_pack = 0;
     u8 src_format = 0;
     u8 src_rb_swp = 0;
@@ -453,13 +453,13 @@ RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
     u8 dst_format = 0;
     u8 dst_rb_swp = 0;
     u8 dst_a_swp = 0;
-            
+
     bRGA_MODE_CTL = (u32 *)(base + RGA_MODE_CTRL_OFFSET);
-    
-    reg = ((reg & (~m_RGA_MODE_CTRL_2D_RENDER_MODE)) | (s_RGA_MODE_CTRL_2D_RENDER_MODE(msg->render_mode)));   
+
+    reg = ((reg & (~m_RGA_MODE_CTRL_2D_RENDER_MODE)) | (s_RGA_MODE_CTRL_2D_RENDER_MODE(msg->render_mode)));
 
     /* src info set */
-    
+
     if (msg->render_mode == color_palette_mode || msg->render_mode == update_palette_table_mode)
     {
         src_format = 0x10 | (msg->palette_mode & 3);
@@ -468,37 +468,37 @@ RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
     {
         switch (msg->src.format)
         {
-            case RK_FORMAT_RGBA_8888    : src_format = 0x0; break;            
-            case RK_FORMAT_RGBA_4444    : src_format = 0x3; break;                         
-            case RK_FORMAT_RGBA_5551    : src_format = 0x2; break;            
-            case RK_FORMAT_BGRA_8888    : src_format = 0x0; src_rb_swp = 0x1; break;           
-            case RK_FORMAT_RGBX_8888    : src_format = 0x0; break;            
+            case RK_FORMAT_RGBA_8888    : src_format = 0x0; break;
+            case RK_FORMAT_RGBA_4444    : src_format = 0x3; break;
+            case RK_FORMAT_RGBA_5551    : src_format = 0x2; break;
+            case RK_FORMAT_BGRA_8888    : src_format = 0x0; src_rb_swp = 0x1; break;
+            case RK_FORMAT_RGBX_8888    : src_format = 0x0; break;
             case RK_FORMAT_RGB_565      : src_format = 0x1; break;
             case RK_FORMAT_RGB_888      : src_format = 0x0; src_rgb_pack = 1; break;
             case RK_FORMAT_BGR_888      : src_format = 0x0; src_rgb_pack = 1; src_rb_swp = 1; break;
-            
-            case RK_FORMAT_YCbCr_422_SP : src_format = 0x4; break;            
-            case RK_FORMAT_YCbCr_422_P  : src_format = 0x5; break;                
-            case RK_FORMAT_YCbCr_420_SP : src_format = 0x6; break;                                
+
+            case RK_FORMAT_YCbCr_422_SP : src_format = 0x4; break;
+            case RK_FORMAT_YCbCr_422_P  : src_format = 0x5; break;
+            case RK_FORMAT_YCbCr_420_SP : src_format = 0x6; break;
             case RK_FORMAT_YCbCr_420_P  : src_format = 0x7; break;
 
-            case RK_FORMAT_YCrCb_422_SP : src_format = 0x4; src_cbcr_swp = 1; break;            
-            case RK_FORMAT_YCrCb_422_P  : src_format = 0x5; src_cbcr_swp = 1; break;                
-            case RK_FORMAT_YCrCb_420_SP : src_format = 0x6; src_cbcr_swp = 1; break;                                
+            case RK_FORMAT_YCrCb_422_SP : src_format = 0x4; src_cbcr_swp = 1; break;
+            case RK_FORMAT_YCrCb_422_P  : src_format = 0x5; src_cbcr_swp = 1; break;
+            case RK_FORMAT_YCrCb_420_SP : src_format = 0x6; src_cbcr_swp = 1; break;
             case RK_FORMAT_YCrCb_420_P  : src_format = 0x7; src_cbcr_swp = 1; break;
-        }                   
+        }
     }
 
     src_a_swp = msg->src.alpha_swap & 1;
 
-    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_RGB_PACK))      | (s_RGA_MODE_CTRL_SRC_RGB_PACK(src_rgb_pack))); 
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_RGB_PACK))      | (s_RGA_MODE_CTRL_SRC_RGB_PACK(src_rgb_pack)));
     reg = ((reg & (~m_RGA_MODE_CTRL_SRC_FORMAT))        | (s_RGA_MODE_CTRL_SRC_FORMAT(src_format)));
     reg = ((reg & (~m_RGA_MODE_CTRL_SRC_RB_SWAP))       | (s_RGA_MODE_CTRL_SRC_RB_SWAP(src_rb_swp)));
     reg = ((reg & (~m_RGA_MODE_CTRL_SRC_ALPHA_SWAP))    | (s_RGA_MODE_CTRL_SRC_ALPHA_SWAP(src_a_swp)));
     reg = ((reg & (~m_RGA_MODE_CTRL_SRC_UV_SWAP_MODE )) | (s_RGA_MODE_CTRL_SRC_UV_SWAP_MODE (src_cbcr_swp)));
-    
-    
-    /* YUV2RGB MODE */    
+
+
+    /* YUV2RGB MODE */
     reg = ((reg & (~m_RGA_MODE_CTRL_YUV2RGB_CON_MODE)) | (s_RGA_MODE_CTRL_YUV2RGB_CON_MODE(msg->yuv2rgb_mode)));
 
     /* ROTATE MODE */
@@ -510,7 +510,7 @@ RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
     /* COLOR FILL MODE */
     reg = ((reg & (~m_RGA_MODE_CTRL_PAT_SEL)) | (s_RGA_MODE_CTRL_PAT_SEL(msg->color_fill_mode)));
 
-    
+
     if ((msg->render_mode == update_palette_table_mode)||(msg->render_mode == update_patten_buff_mode))
     {
         dst_format = msg->pat.format;
@@ -519,8 +519,8 @@ RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
     {
         dst_format = (u8)msg->dst.format;
     }
-    
-    /* dst info set */        
+
+    /* dst info set */
     switch (dst_format)
     {
         case RK_FORMAT_BGRA_8888 : dst_format = 0x0; dst_rb_swp = 0x1; break;
@@ -534,36 +534,36 @@ RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
     }
 
     dst_a_swp = msg->dst.alpha_swap & 1;
-    
-    reg = ((reg & (~m_RGA_MODE_CTRL_DST_FORMAT))       | (s_RGA_MODE_CTRL_DST_FORMAT(dst_format))); 
+
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_FORMAT))       | (s_RGA_MODE_CTRL_DST_FORMAT(dst_format)));
     reg = ((reg & (~m_RGA_MODE_CTRL_DST_RGB_PACK))     | (s_RGA_MODE_CTRL_DST_RGB_PACK(dst_rgb_pack)));
     reg = ((reg & (~m_RGA_MODE_CTRL_DST_RB_SWAP))      | (s_RGA_MODE_CTRL_DST_RB_SWAP(dst_rb_swp)));
     reg = ((reg & (~m_RGA_MODE_CTRL_DST_ALPHA_SWAP))   | (s_RGA_MODE_CTRL_DST_ALPHA_SWAP(dst_a_swp)));
-    reg = ((reg & (~m_RGA_MODE_CTRL_LUT_ENDIAN_MODE))  | (s_RGA_MODE_CTRL_LUT_ENDIAN_MODE(msg->endian_mode & 1)));       
+    reg = ((reg & (~m_RGA_MODE_CTRL_LUT_ENDIAN_MODE))  | (s_RGA_MODE_CTRL_LUT_ENDIAN_MODE(msg->endian_mode & 1)));
     reg = ((reg & (~m_RGA_MODE_CTRL_SRC_TRANS_MODE))   | (s_RGA_MODE_CTRL_SRC_TRANS_MODE(msg->src_trans_mode)));
     reg = ((reg & (~m_RGA_MODE_CTRL_ZERO_MODE_ENABLE)) | (s_RGA_MODE_CTRL_ZERO_MODE_ENABLE(msg->alpha_rop_mode >> 4)));
     reg = ((reg & (~m_RGA_MODE_CTRL_DST_ALPHA_ENABLE)) | (s_RGA_MODE_CTRL_DST_ALPHA_ENABLE(msg->alpha_rop_mode >> 5)));
 
     *bRGA_MODE_CTL = reg;
-       
+
 }
 
 
 
-/*************************************************************    
-Func:        
-    RGA_set_src    
-Description:        
-    fill src relate reg info 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_set_src
+Description:
+    fill src relate reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 void
 RGA_set_src(u8 *base, const struct rga_req *msg)
-{  
+{
     u32 *bRGA_SRC_VIR_INFO;
     u32 *bRGA_SRC_ACT_INFO;
     u32 *bRGA_SRC_Y_MST;
@@ -575,7 +575,7 @@ RGA_set_src(u8 *base, const struct rga_req *msg)
     u32 pixel_width;
 
     uv_x_off = uv_y_off = uv_stride = 0;
-  	
+
     bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET);
     bRGA_SRC_CB_MST = (u32 *)(base + RGA_SRC_CB_MST_OFFSET);
     bRGA_SRC_CR_MST = (u32 *)(base + RGA_SRC_CR_MST_OFFSET);
@@ -586,15 +586,15 @@ RGA_set_src(u8 *base, const struct rga_req *msg)
     y_off  = msg->src.y_offset;
 
     pixel_width = RGA_pixel_width_init(msg->src.format);
-    
+
     stride = ((msg->src.vir_w * pixel_width) + 3) & (~3);
 
     switch(msg->src.format)
     {
-        case RK_FORMAT_YCbCr_422_SP : 
-            uv_stride = stride; 
-            uv_x_off = x_off; 
-            uv_y_off = y_off; 
+        case RK_FORMAT_YCbCr_422_SP :
+            uv_stride = stride;
+            uv_x_off = x_off;
+            uv_y_off = y_off;
             break;
         case RK_FORMAT_YCbCr_422_P  :
             uv_stride = stride >> 1;
@@ -630,11 +630,11 @@ RGA_set_src(u8 *base, const struct rga_req *msg)
             uv_stride = stride >> 1;
             uv_x_off = x_off >> 1;
             uv_y_off = y_off >> 1;
-            break;            
-    }        
+            break;
+    }
 
 
-    /* src addr set */          
+    /* src addr set */
     *bRGA_SRC_Y_MST = msg->src.yrgb_addr + (y_off * stride) + (x_off * pixel_width);
     *bRGA_SRC_CB_MST = msg->src.uv_addr + uv_y_off * uv_stride + uv_x_off;
     *bRGA_SRC_CR_MST = msg->src.v_addr + uv_y_off * uv_stride + uv_x_off;
@@ -651,23 +651,23 @@ RGA_set_src(u8 *base, const struct rga_req *msg)
 
         byte_num = sw >> shift;
         stride = (byte_num + 3) & (~3);
-    }    
+    }
 
-    /* src act window / vir window set */ 
+    /* src act window / vir window set */
     *bRGA_SRC_VIR_INFO = ((stride >> 2) | (msg->src.vir_h)<<16);
     *bRGA_SRC_ACT_INFO = ((msg->src.act_w-1) | (msg->src.act_h-1)<<16);
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_dst    
-Description:        
-    fill dst relate reg info 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_set_dst
+Description:
+    fill dst relate reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 s32 RGA_set_dst(u8 *base, const struct rga_req *msg)
@@ -700,7 +700,7 @@ s32 RGA_set_dst(u8 *base, const struct rga_req *msg)
     {
         switch(msg->dst.format)
         {
-            case RK_FORMAT_YCbCr_422_SP : 
+            case RK_FORMAT_YCbCr_422_SP :
                 *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off) * stride) + ((x_off) * pw);
                 break;
             case RK_FORMAT_YCbCr_422_P  :
@@ -727,12 +727,12 @@ s32 RGA_set_dst(u8 *base, const struct rga_req *msg)
             case RK_FORMAT_YCrCb_420_P :
                 *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + ((x_off>>1) * pw);
                 *bRGA_PRESCL_CR_MST = (u32)msg->dst.v_addr  + ((y_off>>1) * stride) + ((x_off>>1) * pw);
-                break;            
-        }             
+                break;
+        }
     }
 
     rop_mask_stride = (((msg->src.vir_w + 7)>>3) + 3) & (~3);//not dst_vir.w,hxx,2011.7.21
-    
+
     reg = (stride >> 2) & 0xffff;
     reg = reg | ((rop_mask_stride>>2) << 16);
 
@@ -744,25 +744,25 @@ s32 RGA_set_dst(u8 *base, const struct rga_req *msg)
     if (msg->render_mode == line_point_drawing_mode)
     {
         reg &= 0xffff;
-        reg = reg | (msg->dst.vir_h << 16);        
+        reg = reg | (msg->dst.vir_h << 16);
     }
 
     *bRGA_DST_VIR_INFO = reg;
     *bRGA_DST_CTR_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
 
-    return 0;    
+    return 0;
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_alpha_rop    
-Description:        
-    fill alpha rop some relate reg bit 
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_set_alpha_rop
+Description:
+    fill alpha rop some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 void
 RGA_set_alpha_rop(u8 *base, const struct rga_req *msg)
@@ -772,12 +772,12 @@ RGA_set_alpha_rop(u8 *base, const struct rga_req *msg)
     u32 *bRGA_ROP_CON1;
     u32 reg = 0;
     u32 rop_con0, rop_con1;
-    
+
     u8 rop_mode = (msg->alpha_rop_mode) & 3;
     u8 alpha_mode = msg->alpha_rop_mode & 3;
 
     rop_con0 = rop_con1 = 0;
-    
+
     bRGA_ALPHA_CON = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
 
     reg = ((reg & (~m_RGA_ALPHA_CON_ENABLE) )| (s_RGA_ALPHA_CON_ENABLE(msg->alpha_rop_flag & 1)));
@@ -792,10 +792,10 @@ RGA_set_alpha_rop(u8 *base, const struct rga_req *msg)
     reg = ((reg & (~m_RGA_ALPHA_CON_DITHER_ENABLE)) | (s_RGA_ALPHA_CON_DITHER_ENABLE(msg->alpha_rop_flag >> 5)));
     reg = ((reg & (~m_RGA_ALPHA_CON_GRADIENT_CAL_MODE)) | (s_RGA_ALPHA_CON_GRADIENT_CAL_MODE(msg->alpha_rop_flag >> 6)));
     reg = ((reg & (~m_RGA_ALPHA_CON_AA_SEL)) | (s_RGA_ALPHA_CON_AA_SEL(msg->alpha_rop_flag >> 7)));
-    
+
     *bRGA_ALPHA_CON = reg;
 
-    if(rop_mode == 0) {  
+    if(rop_mode == 0) {
         rop_con0 =  ROP3_code[(msg->rop_code & 0xff)];
     }
     else if(rop_mode == 1) {
@@ -805,25 +805,25 @@ RGA_set_alpha_rop(u8 *base, const struct rga_req *msg)
         rop_con0 =  ROP3_code[(msg->rop_code & 0xff)];
         rop_con1 =  ROP3_code[(msg->rop_code & 0xff00)>>8];
     }
-        
+
     bRGA_ROP_CON0 = (u32 *)(base + RGA_ROP_CON0_OFFSET);
     bRGA_ROP_CON1 = (u32 *)(base + RGA_ROP_CON1_OFFSET);
 
     *bRGA_ROP_CON0 = (u32)rop_con0;
-    *bRGA_ROP_CON1 = (u32)rop_con1;            
+    *bRGA_ROP_CON1 = (u32)rop_con1;
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_color    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_color
+Description:
     fill color some relate reg bit
     bg_color/fg_color
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 void
@@ -833,15 +833,15 @@ RGA_set_color(u8 *base, const struct rga_req *msg)
     u32 *bRGA_SRC_TR_COLOR1;
     u32 *bRGA_SRC_BG_COLOR;
     u32 *bRGA_SRC_FG_COLOR;
-    
-        
+
+
     bRGA_SRC_BG_COLOR  = (u32 *)(base + RGA_SRC_BG_COLOR_OFFSET);
     bRGA_SRC_FG_COLOR  = (u32 *)(base + RGA_SRC_FG_COLOR_OFFSET);
-    
+
     *bRGA_SRC_BG_COLOR = msg->bg_color;    /* 1bpp 0 */
     *bRGA_SRC_FG_COLOR = msg->fg_color;    /* 1bpp 1 */
-    
-    bRGA_SRC_TR_COLOR0 = (u32 *)(base + RGA_SRC_TR_COLOR0_OFFSET);    
+
+    bRGA_SRC_TR_COLOR0 = (u32 *)(base + RGA_SRC_TR_COLOR0_OFFSET);
     bRGA_SRC_TR_COLOR1 = (u32 *)(base + RGA_SRC_TR_COLOR1_OFFSET);
 
     *bRGA_SRC_TR_COLOR0 = msg->color_key_min;
@@ -849,15 +849,15 @@ RGA_set_color(u8 *base, const struct rga_req *msg)
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_fading    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_fading
+Description:
     fill fading some relate reg bit
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 s32
@@ -875,21 +875,21 @@ RGA_set_fading(u8 *base, const struct rga_req *msg)
 
     reg = (r<<8) | (g<<16) | (b<<24) | reg;
 
-    *bRGA_FADING_CON = reg; 
-    
+    *bRGA_FADING_CON = reg;
+
     return 0;
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_pat    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_pat
+Description:
     fill patten some relate reg bit
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 s32
@@ -902,7 +902,7 @@ RGA_set_pat(u8 *base, const struct rga_req *msg)
     bRGA_PAT_START_POINT = (u32 *)(base + RGA_PAT_START_POINT_OFFSET);
 
     bRGA_PAT_CON = (u32 *)(base + RGA_PAT_CON_OFFSET);
-    
+
     *bRGA_PAT_START_POINT = (msg->pat.act_w * msg->pat.y_offset) + msg->pat.x_offset;
 
     reg = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8) | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
@@ -914,18 +914,18 @@ RGA_set_pat(u8 *base, const struct rga_req *msg)
 
 
 
-/*************************************************************    
-Func:        
-    RGA_set_bitblt_reg_info    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_bitblt_reg_info
+Description:
     fill bitblt mode relate ren info
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
-void   
+void
 RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
 {
     u32 *bRGA_SRC_Y_MST;
@@ -961,18 +961,18 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
 
     bRGA_SRC_X_PARA = (u32 *)(base + RGA_SRC_X_PARA_OFFSET);
     bRGA_SRC_Y_PARA = (u32 *)(base + RGA_SRC_Y_PARA_OFFSET);
-        
+
     bRGA_SRC_TILE_XINFO = (u32 *)(base + RGA_SRC_TILE_XINFO_OFFSET);
     bRGA_SRC_TILE_YINFO = (u32 *)(base + RGA_SRC_TILE_YINFO_OFFSET);
     bRGA_SRC_TILE_H_INCR = (u32 *)(base + RGA_SRC_TILE_H_INCR_OFFSET);
-    bRGA_SRC_TILE_V_INCR = (u32 *)(base + RGA_SRC_TILE_V_INCR_OFFSET);    
+    bRGA_SRC_TILE_V_INCR = (u32 *)(base + RGA_SRC_TILE_V_INCR_OFFSET);
     bRGA_SRC_TILE_OFFSETX = (u32 *)(base + RGA_SRC_TILE_OFFSETX_OFFSET);
     bRGA_SRC_TILE_OFFSETY = (u32 *)(base + RGA_SRC_TILE_OFFSETY_OFFSET);
 
     bRGA_DST_MST = (u32 *)(base + RGA_DST_MST_OFFSET);
     bRGA_DST_CTR_INFO = (u32 *)(base + RGA_DST_CTR_INFO_OFFSET);
 
-    /* Matrix reg fill */   
+    /* Matrix reg fill */
     m0 = (s32)(tile->matrix[0] >> 18);
     m1 = (s32)(tile->matrix[1] >> 18);
     m2 = (s32)(tile->matrix[2] >> 18);
@@ -980,8 +980,8 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
 
     *bRGA_SRC_X_PARA = (m0 & 0xffff) | (m2 << 16);
     *bRGA_SRC_Y_PARA = (m1 & 0xffff) | (m3 << 16);
-    
-    /* src tile information setting */    
+
+    /* src tile information setting */
     if(msg->rotate_mode != 0)//add by hxx,2011.7.12,for rtl0707,when line scanning ,do not calc src tile info
     {
         *bRGA_SRC_TILE_XINFO = (tile->tile_start_x_coor & 0xffff) | (tile->tile_w << 16);
@@ -995,7 +995,7 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
     }
 
     pixel_width = RGA_pixel_width_init(msg->src.format);
-    
+
     stride = ((msg->src.vir_w * pixel_width) + 3) & (~3);
 
     if ((msg->rotate_mode == 1)||(msg->rotate_mode == 2)||(msg->rotate_mode == 3))
@@ -1024,11 +1024,11 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
         pos[6] >>= 11;
         pos[7] >>= 11;
 
-        xmax = (MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]) + 1);        
-        xmin = (MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]));        
+        xmax = (MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]) + 1);
+        xmin = (MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]));
 
-        ymax = (MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]) + 1);        
-        ymin = (MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7])); 
+        ymax = (MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]) + 1);
+        ymin = (MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]));
 
         xp = xmin + msg->src.x_offset;
         yp = ymin + msg->src.y_offset;
@@ -1038,9 +1038,9 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
             xp = CLIP(xp, msg->src.x_offset, msg->src.x_offset + msg->src.act_w - 1);
             yp = CLIP(yp, msg->src.y_offset, msg->src.y_offset + msg->src.act_h - 1);
         }
-        
+
         switch(msg->src.format)
-        {        
+        {
             case RK_FORMAT_YCbCr_420_P :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
                 u_addr = msg->src.uv_addr + (yp>>1)*(stride>>1) + (xp>>1);
@@ -1048,9 +1048,9 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
                 break;
             case RK_FORMAT_YCbCr_420_SP :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
-                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);                        
+                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);
                 break;
-            case RK_FORMAT_YCbCr_422_P : 
+            case RK_FORMAT_YCbCr_422_P :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
                 u_addr = msg->src.uv_addr + (yp)*(stride>>1) + (xp>>1);
                 v_addr = msg->src.v_addr  + (yp)*(stride>>1) + (xp>>1);
@@ -1066,9 +1066,9 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
                 break;
             case RK_FORMAT_YCrCb_420_SP :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
-                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);                        
+                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);
                 break;
-            case RK_FORMAT_YCrCb_422_P : 
+            case RK_FORMAT_YCrCb_422_P :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
                 u_addr = msg->src.uv_addr + (yp)*(stride>>1) + (xp>>1);
                 v_addr = msg->src.v_addr  + (yp)*(stride>>1) + (xp>>1);
@@ -1076,7 +1076,7 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
             case RK_FORMAT_YCrCb_422_SP:
                 y_addr = msg->src.yrgb_addr + yp*stride + xp;
                 u_addr = msg->src.uv_addr  + yp*stride + ((xp>>1)<<1);
-                break;                    
+                break;
             default :
                 y_addr = msg->src.yrgb_addr + yp*stride + xp*pixel_width;
                 break;
@@ -1086,28 +1086,28 @@ RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
         *bRGA_SRC_CB_MST = u_addr;
         *bRGA_SRC_CR_MST = v_addr;
     }
-    
+
     /*dst info*/
     pixel_width = RGA_pixel_width_init(msg->dst.format);
     stride = (msg->dst.vir_w * pixel_width + 3) & (~3);
     *bRGA_DST_MST = (u32)msg->dst.yrgb_addr + (tile->dst_ctrl.y_off * stride) + (tile->dst_ctrl.x_off * pixel_width);
     *bRGA_DST_CTR_INFO = (tile->dst_ctrl.w) | ((tile->dst_ctrl.h) << 16);
-    
+
     *bRGA_DST_CTR_INFO |= ((1<<29) | (1<<28));
 }
 
 
 
 
-/*************************************************************    
-Func:        
-    RGA_set_color_palette_reg_info    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_color_palette_reg_info
+Description:
     fill color palette process some relate reg bit
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 void
@@ -1124,27 +1124,27 @@ RGA_set_color_palette_reg_info(u8 *base, const struct rga_req *msg)
     y_off = msg->src.y_offset;
 
     sw = msg->src.vir_w;
-    shift = 3 - (msg->palette_mode & 3);    
+    shift = 3 - (msg->palette_mode & 3);
     byte_num = sw >> shift;
     src_stride = (byte_num + 3) & (~3);
-   
-    p = msg->src.yrgb_addr;        
+
+    p = msg->src.yrgb_addr;
     p = p + (x_off>>shift) + y_off*src_stride;
 
-    bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET); 
-    *bRGA_SRC_Y_MST = (u32)p;        
+    bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET);
+    *bRGA_SRC_Y_MST = (u32)p;
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_color_fill_reg_info    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_color_fill_reg_info
+Description:
     fill color fill process some relate reg bit
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 void
 RGA_set_color_fill_reg_info(u8 *base, const struct rga_req *msg)
@@ -1170,19 +1170,19 @@ RGA_set_color_fill_reg_info(u8 *base, const struct rga_req *msg)
     *bRGA_CP_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
 
     *bRGA_PAT_CON = (msg->pat.vir_w-1) | ((msg->pat.vir_h-1) << 8) | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
-    
+
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_line_drawing_reg_info    
-Description:        
+/*************************************************************
+Func:
+    RGA_set_line_drawing_reg_info
+Description:
     fill line drawing process some relate reg bit
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
@@ -1191,9 +1191,9 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
     u32 *bRGA_DST_VIR_INFO;
     u32 *bRGA_LINE_DRAW_XY_INFO;
     u32 *bRGA_LINE_DRAW_WIDTH;
-    u32 *bRGA_LINE_DRAWING_COLOR;    
+    u32 *bRGA_LINE_DRAWING_COLOR;
     u32 *bRGA_LINE_DRAWING_MST;
-    
+
     u32  reg = 0;
 
     s16 x_width, y_width;
@@ -1203,7 +1203,7 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
     u32 start_addr;
     u8 line_dir, dir_major, dir_semi_major;
     u16 major_width;
-    
+
     bRGA_LINE_DRAW = (u32 *)(base + RGA_LINE_DRAW_OFFSET);
     bRGA_DST_VIR_INFO = (u32 *)(base + RGA_DST_VIR_INFO_OFFSET);
     bRGA_LINE_DRAW_XY_INFO = (u32 *)(base + RGA_LINE_DRAW_XY_INFO_OFFSET);
@@ -1215,16 +1215,16 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
 
     stride = (msg->dst.vir_w * pw + 3) & (~3);
 
-    start_addr = msg->dst.yrgb_addr 
-                + (msg->line_draw_info.start_point.y * stride) 
+    start_addr = msg->dst.yrgb_addr
+                + (msg->line_draw_info.start_point.y * stride)
                 + (msg->line_draw_info.start_point.x * pw);
 
     x_width = msg->line_draw_info.start_point.x - msg->line_draw_info.end_point.x;
     y_width = msg->line_draw_info.start_point.y - msg->line_draw_info.end_point.y;
 
     abs_x = abs(x_width);
-    abs_y = abs(y_width); 
-    
+    abs_y = abs(y_width);
+
     if (abs_x >= abs_y)
     {
         if (y_width > 0)
@@ -1232,20 +1232,20 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
         else
             dir_semi_major = 0;
 
-        if (x_width > 0)        
-            dir_major = 1;        
+        if (x_width > 0)
+            dir_major = 1;
         else
             dir_major = 0;
 
-        if((abs_x == 0)||(abs_y == 0))        
-            delta = 0;        
-        else        
+        if((abs_x == 0)||(abs_y == 0))
+            delta = 0;
+        else
             delta = (abs_y<<12)/abs_x;
 
         if (delta >> 12)
             delta -= 1;
-                        
-        major_width = abs_x;        
+
+        major_width = abs_x;
         line_dir = 0;
     }
     else
@@ -1259,32 +1259,32 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
             dir_major = 1;
         else
             dir_major = 0;
-        
-        delta = (abs_x<<12)/abs_y;        
+
+        delta = (abs_x<<12)/abs_y;
         major_width = abs_y;
         line_dir = 1;
     }
- 
+
     reg = (reg & (~m_RGA_LINE_DRAW_MAJOR_WIDTH))     | (s_RGA_LINE_DRAW_MAJOR_WIDTH(major_width));
     reg = (reg & (~m_RGA_LINE_DRAW_LINE_DIRECTION))  | (s_RGA_LINE_DRAW_LINE_DIRECTION(line_dir));
     reg = (reg & (~m_RGA_LINE_DRAW_LINE_WIDTH))      | (s_RGA_LINE_DRAW_LINE_WIDTH(msg->line_draw_info.line_width - 1));
-    reg = (reg & (~m_RGA_LINE_DRAW_INCR_VALUE))      | (s_RGA_LINE_DRAW_INCR_VALUE(delta));    
+    reg = (reg & (~m_RGA_LINE_DRAW_INCR_VALUE))      | (s_RGA_LINE_DRAW_INCR_VALUE(delta));
     reg = (reg & (~m_RGA_LINE_DRAW_DIR_SEMI_MAJOR))  | (s_RGA_LINE_DRAW_DIR_SEMI_MAJOR(dir_semi_major));
     reg = (reg & (~m_RGA_LINE_DRAW_DIR_MAJOR))       | (s_RGA_LINE_DRAW_DIR_MAJOR(dir_major));
     reg = (reg & (~m_RGA_LINE_DRAW_LAST_POINT))      | (s_RGA_LINE_DRAW_LAST_POINT(msg->line_draw_info.flag >> 1));
-    reg = (reg & (~m_RGA_LINE_DRAW_ANTI_ALISING))    | (s_RGA_LINE_DRAW_ANTI_ALISING(msg->line_draw_info.flag));    
+    reg = (reg & (~m_RGA_LINE_DRAW_ANTI_ALISING))    | (s_RGA_LINE_DRAW_ANTI_ALISING(msg->line_draw_info.flag));
 
     *bRGA_LINE_DRAW = reg;
-    
+
     reg = (msg->line_draw_info.start_point.x & 0xfff) | ((msg->line_draw_info.start_point.y & 0xfff) << 16);
     *bRGA_LINE_DRAW_XY_INFO = reg;
-    
+
     *bRGA_LINE_DRAW_WIDTH = msg->dst.vir_w;
 
     *bRGA_LINE_DRAWING_COLOR = msg->line_draw_info.color;
 
     *bRGA_LINE_DRAWING_MST = (u32)start_addr;
-           
+
     return 0;
 }
 
@@ -1292,10 +1292,10 @@ s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
 /*full*/
 s32
 RGA_set_filter_reg_info(u8 *base, const struct rga_req *msg)
-{    
+{
     u32 *bRGA_BLUR_SHARP_INFO;
     u32  reg = 0;
-    
+
     bRGA_BLUR_SHARP_INFO = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
 
     reg = *bRGA_BLUR_SHARP_INFO;
@@ -1304,8 +1304,8 @@ RGA_set_filter_reg_info(u8 *base, const struct rga_req *msg)
     reg = ((reg & (~m_RGA_BLUR_SHARP_FILTER_MODE)) | (s_RGA_BLUR_SHARP_FILTER_MODE(msg->bsfilter_flag >>2)));
 
     *bRGA_BLUR_SHARP_INFO = reg;
-       
-    return 0; 
+
+    return 0;
 }
 
 
@@ -1313,7 +1313,7 @@ RGA_set_filter_reg_info(u8 *base, const struct rga_req *msg)
 s32
 RGA_set_pre_scale_reg_info(u8 *base, const struct rga_req *msg)
 {
-   u32 *bRGA_PRE_SCALE_INFO; 
+   u32 *bRGA_PRE_SCALE_INFO;
    u32 reg = 0;
    u32 h_ratio = 0;
    u32 v_ratio = 0;
@@ -1330,13 +1330,13 @@ RGA_set_pre_scale_reg_info(u8 *base, const struct rga_req *msg)
    if((dst_width == 0) || (dst_height == 0))
    {
         printk("pre scale reg info error ratio is divide zero\n");
-        return -EINVAL;    
+        return -EINVAL;
    }
 
    h_ratio = (src_width <<16) / dst_width;
    v_ratio = (src_height<<16) / dst_height;
 
-   if (h_ratio <= (1<<16))    
+   if (h_ratio <= (1<<16))
        h_ratio = 0;
    else if (h_ratio <= (2<<16))
        h_ratio = 1;
@@ -1345,7 +1345,7 @@ RGA_set_pre_scale_reg_info(u8 *base, const struct rga_req *msg)
    else if (h_ratio <= (8<<16))
        h_ratio = 3;
 
-   if (v_ratio <= (1<<16))    
+   if (v_ratio <= (1<<16))
        v_ratio = 0;
    else if (v_ratio <= (2<<16))
        v_ratio = 1;
@@ -1355,37 +1355,37 @@ RGA_set_pre_scale_reg_info(u8 *base, const struct rga_req *msg)
        v_ratio = 3;
 
    if(msg->src.format == msg->dst.format)
-        ps_yuv_flag = 0;    
-    else    
-        ps_yuv_flag = 1;   
+        ps_yuv_flag = 0;
+    else
+        ps_yuv_flag = 1;
 
    bRGA_PRE_SCALE_INFO = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
-   
+
    reg = *bRGA_PRE_SCALE_INFO;
    reg = ((reg & (~m_RGA_PRE_SCALE_HOR_RATIO)) | (s_RGA_PRE_SCALE_HOR_RATIO((u8)h_ratio)));
    reg = ((reg & (~m_RGA_PRE_SCALE_VER_RATIO)) | (s_RGA_PRE_SCALE_VER_RATIO((u8)v_ratio)));
    reg = ((reg & (~m_RGA_PRE_SCALE_OUTPUT_FORMAT)) | (s_RGA_PRE_SCALE_OUTPUT_FORMAT(ps_yuv_flag)));
 
    *bRGA_PRE_SCALE_INFO = reg;
-       
-   return 0; 
+
+   return 0;
 }
 
 
 
 /*full*/
-int 
+int
 RGA_set_update_palette_table_reg_info(u8 *base, const struct rga_req *msg)
 {
     u32 *bRGA_LUT_MST;
 
-    if (!msg->LUT_addr) {        
+    if (!msg->LUT_addr) {
         return -1;
-    }        
+    }
 
     bRGA_LUT_MST  = (u32 *)(base + RGA_LUT_MST_OFFSET);
-    
-    *bRGA_LUT_MST = (u32)msg->LUT_addr;    
+
+    *bRGA_LUT_MST = (u32)msg->LUT_addr;
 
     return 0;
 }
@@ -1410,7 +1410,7 @@ RGA_set_update_patten_buff_reg_info(u8 *base, const struct rga_req *msg)
 
     if ( !pat->yrgb_addr ) {
         return -1;
-    }    
+    }
     *bRGA_PAT_MST = (u32)pat->yrgb_addr;
 
     if ((pat->vir_w > 256)||(pat->x_offset > 256)||(pat->y_offset > 256)) {
@@ -1419,21 +1419,21 @@ RGA_set_update_patten_buff_reg_info(u8 *base, const struct rga_req *msg)
     *bRGA_PAT_START_POINT = (pat->vir_w * pat->y_offset) + pat->x_offset;
 
     reg = (pat->vir_w-1) | ((pat->vir_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
-    *bRGA_PAT_CON = reg;    
-    
+    *bRGA_PAT_CON = reg;
+
     return 0;
 }
 
 
-/*************************************************************    
-Func:        
-    RGA_set_mmu_ctrl_reg_info    
-Description:        
-    fill mmu relate some reg info    
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_set_mmu_ctrl_reg_info
+Description:
+    fill mmu relate some reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 
 s32
@@ -1447,7 +1447,7 @@ RGA_set_mmu_ctrl_reg_info(u8 *base, const struct rga_req *msg)
     mmu_addr = (u32)msg->mmu_info.base_addr;
     TLB_size = (msg->mmu_info.mmu_flag >> 4) & 0x3;
     mmu_enable = msg->mmu_info.mmu_flag & 0x1;
-    
+
     src_flag = (msg->mmu_info.mmu_flag >> 1) & 0x1;
     dst_flag = (msg->mmu_info.mmu_flag >> 2) & 0x1;
     CMD_flag = (msg->mmu_info.mmu_flag >> 3) & 0x1;
@@ -1458,7 +1458,7 @@ RGA_set_mmu_ctrl_reg_info(u8 *base, const struct rga_req *msg)
     reg = ((reg & (~m_RGA_MMU_CTRL_TLB_ADDR)) | s_RGA_MMU_CTRL_TLB_ADDR(mmu_addr));
     *RGA_MMU_TLB = reg;
 
-    reg = *RGA_MMU_CTRL_ADDR;    
+    reg = *RGA_MMU_CTRL_ADDR;
     reg = ((reg & (~m_RGA_MMU_CTRL_PAGE_TABLE_SIZE)) | s_RGA_MMU_CTRL_PAGE_TABLE_SIZE(TLB_size));
     reg = ((reg & (~m_RGA_MMU_CTRL_MMU_ENABLE)) | s_RGA_MMU_CTRL_MMU_ENABLE(mmu_enable));
     reg = ((reg & (~m_RGA_MMU_CTRL_SRC_FLUSH)) | s_RGA_MMU_CTRL_SRC_FLUSH(1));
@@ -1471,47 +1471,47 @@ RGA_set_mmu_ctrl_reg_info(u8 *base, const struct rga_req *msg)
 
 
 
-/*************************************************************    
-Func:        
-    RGA_gen_reg_info    
-Description:        
-    Generate RGA command reg list from rga_req struct.    
-Author:        
-    ZhangShengqin    
-Date:        
-    20012-2-2 10:59:25 
+/*************************************************************
+Func:
+    RGA_gen_reg_info
+Description:
+    Generate RGA command reg list from rga_req struct.
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
 **************************************************************/
 int
 RGA_gen_reg_info(const struct rga_req *msg, unsigned char *base)
 {
     TILE_INFO tile;
 
-    memset(base, 0x0, 28*4);    
+    memset(base, 0x0, 28*4);
     RGA_set_mode_ctrl(base, msg);
-    
+
     switch(msg->render_mode)
     {
         case bitblt_mode :
             RGA_set_alpha_rop(base, msg);
             RGA_set_src(base, msg);
-            RGA_set_dst(base, msg);    
+            RGA_set_dst(base, msg);
             RGA_set_color(base, msg);
             RGA_set_fading(base, msg);
-            RGA_set_pat(base, msg);            
+            RGA_set_pat(base, msg);
             matrix_cal(msg, &tile);
             dst_ctrl_cal(msg, &tile);
             src_tile_info_cal(msg, &tile);
-            RGA_set_bitblt_reg_info(base, msg, &tile); 
+            RGA_set_bitblt_reg_info(base, msg, &tile);
             break;
         case color_palette_mode :
             RGA_set_src(base, msg);
-            RGA_set_dst(base, msg);    
+            RGA_set_dst(base, msg);
             RGA_set_color(base, msg);
             RGA_set_color_palette_reg_info(base, msg);
             break;
         case color_fill_mode :
             RGA_set_alpha_rop(base, msg);
-            RGA_set_dst(base, msg);    
+            RGA_set_dst(base, msg);
             RGA_set_color(base, msg);
             RGA_set_pat(base, msg);
             RGA_set_color_fill_reg_info(base, msg);
@@ -1529,7 +1529,7 @@ RGA_gen_reg_info(const struct rga_req *msg, unsigned char *base)
             break;
         case pre_scaling_mode :
             RGA_set_src(base, msg);
-            RGA_set_dst(base, msg); 
+            RGA_set_dst(base, msg);
             if(RGA_set_pre_scale_reg_info(base, msg) == -EINVAL)
                 return -1;
             break;
@@ -1539,10 +1539,10 @@ RGA_gen_reg_info(const struct rga_req *msg, unsigned char *base)
             }
 			break;
         case update_patten_buff_mode:
-            if (RGA_set_update_patten_buff_reg_info(base, msg)){                
+            if (RGA_set_update_patten_buff_reg_info(base, msg)){
                 return -1;
             }
-                
+
             break;
     }
 
diff --git a/drivers/video/rockchip/rga2/Kconfig b/drivers/video/rockchip/rga2/Kconfig
new file mode 100644
index 000000000000..e5258c66315a
--- /dev/null
+++ b/drivers/video/rockchip/rga2/Kconfig
@@ -0,0 +1,9 @@
+menu "RGA2"
+	depends on ARCH_ROCKCHIP
+
+config ROCKCHIP_RGA2
+	tristate "ROCKCHIP_RGA2"
+	help
+	  rk32 rga2 module.
+
+endmenu
diff --git a/drivers/video/rockchip/rga2/Makefile b/drivers/video/rockchip/rga2/Makefile
new file mode 100644
index 000000000000..6cc0cfc366a4
--- /dev/null
+++ b/drivers/video/rockchip/rga2/Makefile
@@ -0,0 +1,3 @@
+rga2-y	:= rga2_drv.o rga2_mmu_info.o rga2_reg_info.o RGA2_API.o
+
+obj-$(CONFIG_ROCKCHIP_RGA2)	+= rga2.o
diff --git a/drivers/video/rockchip/rga2/RGA2_API.c b/drivers/video/rockchip/rga2/RGA2_API.c
new file mode 100644
index 000000000000..402020affa4a
--- /dev/null
+++ b/drivers/video/rockchip/rga2/RGA2_API.c
@@ -0,0 +1,22 @@
+
+#include <linux/memory.h>
+#include "RGA2_API.h"
+#include "rga2.h"
+//#include "rga_angle.h"
+
+#define IS_YUV_420(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP))
+
+#define IS_YUV_422(format) \
+     ((format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+#define IS_YUV(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP) | \
+      (format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+
+
diff --git a/drivers/video/rockchip/rga2/RGA2_API.h b/drivers/video/rockchip/rga2/RGA2_API.h
new file mode 100644
index 000000000000..a8873bd5e0ff
--- /dev/null
+++ b/drivers/video/rockchip/rga2/RGA2_API.h
@@ -0,0 +1,12 @@
+#ifndef __RGA_API_H__
+#define __RGA_API_H__
+
+#include "rga2_reg_info.h"
+#include "rga2.h"
+
+#define ENABLE      1
+#define DISABLE     0
+
+
+
+#endif
diff --git a/drivers/video/rockchip/rga2/rga2.h b/drivers/video/rockchip/rga2/rga2.h
new file mode 100644
index 000000000000..3a05e885b2bb
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2.h
@@ -0,0 +1,636 @@
+#ifndef _RGA_DRIVER_H_
+#define _RGA_DRIVER_H_
+
+#include <linux/mutex.h>
+
+#define RGA_BLIT_SYNC	0x5017
+#define RGA_BLIT_ASYNC  0x5018
+#define RGA_FLUSH       0x5019
+#define RGA_GET_RESULT  0x501a
+#define RGA_GET_VERSION 0x501b
+
+#define RGA2_BLIT_SYNC	 0x6017
+#define RGA2_BLIT_ASYNC  0x6018
+#define RGA2_FLUSH       0x6019
+#define RGA2_GET_RESULT  0x601a
+#define RGA2_GET_VERSION 0x601b
+
+
+#define RGA2_REG_CTRL_LEN    0x8    /* 8  */
+#define RGA2_REG_CMD_LEN     0x20   /* 32 */
+#define RGA2_CMD_BUF_SIZE    0x700  /* 16*28*4 */
+
+#define RGA2_OUT_OF_RESOURCES    -10
+#define RGA2_MALLOC_ERROR        -11
+
+#define SCALE_DOWN_LARGE 1
+
+#define rgaIS_ERROR(status)			(status < 0)
+#define rgaNO_ERROR(status)			(status >= 0)
+#define rgaIS_SUCCESS(status)		(status == 0)
+
+/* RGA2 process mode enum */
+enum
+{
+    bitblt_mode               = 0x0,
+    color_palette_mode        = 0x1,
+    color_fill_mode           = 0x2,
+    update_palette_table_mode = 0x3,
+    update_patten_buff_mode   = 0x4,
+};  /*render mode*/
+
+enum
+{
+    A_B_B =0x0,
+    A_B_C =0x1,
+};  //bitblt_mode select
+
+enum
+{
+    rop_enable_mask          = 0x2,
+    dither_enable_mask       = 0x8,
+    fading_enable_mask       = 0x10,
+    PD_enbale_mask           = 0x20,
+};
+
+
+
+/*
+//          Alpha    Red     Green   Blue
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGBA },   // RK_FORMAT_RGBA_8888
+{  4, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGBX_8888
+{  3, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGB_888
+{  4, 32, {{32,24,  24,16,  16, 8,   8, 0 }}, GGL_BGRA },   // RK_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // RK_FORMAT_RGB_565
+{  2, 16, {{ 1, 0,  16,11,  11, 6,   6, 1 }}, GGL_RGBA },   // RK_FORMAT_RGBA_5551
+{  2, 16, {{ 4, 0,  16,12,  12, 8,   8, 4 }}, GGL_RGBA },   // RK_FORMAT_RGBA_4444
+{  2, 16, {{ 0, 0,   5, 0   11, 5,   16,11}}, GGL_BGR  },   // RK_FORMAT_BGR_565
+{  2, 16, {{ 1, 0,   6, 1,  11, 6,   16,11}}, GGL_BGRA },   // RK_FORMAT_BGRA_5551
+{  2, 16, {{ 4, 0,   8, 4,  12, 8,   16,12}}, GGL_BGRA },   // RK_FORMAT_BGRA_4444
+
+*/
+enum
+{
+	RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,
+};
+
+typedef struct mdp_img
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+}
+mdp_img;
+
+typedef struct mdp_img_act
+{
+    u16 width;     // width
+    u16 height;    // height
+    s16 x_off;     // x offset for the vir
+    s16 y_off;     // y offset for the vir
+    s16 uv_x_off;
+    s16 uv_y_off;
+}
+mdp_img_act;
+
+typedef struct mdp_img_vir
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+    u32 uv_addr;
+    u32 v_addr;
+}
+mdp_img_vir;
+
+
+typedef struct MMU_INFO
+{
+    u32 src0_base_addr;
+    u32 src1_base_addr;
+    u32 dst_base_addr;
+    u32 els_base_addr;
+
+    u8 src0_mmu_flag;     /* [0] src0 mmu enable [1] src0_flush [2] src0_prefetch_en [3] src0_prefetch dir */
+    u8 src1_mmu_flag;     /* [0] src1 mmu enable [1] src1_flush [2] src1_prefetch_en [3] src1_prefetch dir */
+    u8 dst_mmu_flag;      /* [0] dst  mmu enable [1] dst_flush  [2] dst_prefetch_en  [3] dst_prefetch dir  */
+    u8 els_mmu_flag;      /* [0] els  mmu enable [1] els_flush  [2] els_prefetch_en  [3] els_prefetch dir  */
+} MMU_INFO;
+
+
+enum
+{
+	MMU_DIS = 0x0,
+	MMU_EN  = 0x1
+};
+enum
+{
+	MMU_FLUSH_DIS = 0x0,
+	MMU_FLUSH_EN  = 0x2
+};
+enum
+{
+	MMU_PRE_DIS = 0x0,
+	MMU_PRE_EN  = 0x4
+};
+enum
+{
+	MMU_PRE_DIR_FORW  = 0x0,
+	MMU_PRE_DIR_BACK  = 0x8
+};
+typedef struct COLOR_FILL
+{
+    s16 gr_x_a;
+    s16 gr_y_a;
+    s16 gr_x_b;
+    s16 gr_y_b;
+    s16 gr_x_g;
+    s16 gr_y_g;
+    s16 gr_x_r;
+    s16 gr_y_r;
+}
+COLOR_FILL;
+
+enum
+{
+	ALPHA_ORIGINAL = 0x0,
+	ALPHA_NO_128   = 0x1
+};
+
+enum
+{
+	R2_BLACK       = 0x00,
+	R2_COPYPEN     = 0xf0,
+	R2_MASKNOTPEN  = 0x0a,
+	R2_MASKPEN     = 0xa0,
+	R2_MASKPENNOT  = 0x50,
+	R2_MERGENOTPEN = 0xaf,
+	R2_MERGEPEN    = 0xfa,
+	R2_MERGEPENNOT = 0xf5,
+	R2_NOP         = 0xaa,
+	R2_NOT         = 0x55,
+	R2_NOTCOPYPEN  = 0x0f,
+	R2_NOTMASKPEN  = 0x5f,
+	R2_NOTMERGEPEN = 0x05,
+	R2_NOTXORPEN   = 0xa5,
+	R2_WHITE       = 0xff,
+	R2_XORPEN      = 0x5a
+};
+
+
+/***************************************/
+/* porting from rga.h for msg convert  */
+/***************************************/
+
+typedef struct FADING
+{
+    uint8_t b;
+    uint8_t g;
+    uint8_t r;
+    uint8_t res;
+}
+FADING;
+
+typedef struct MMU
+{
+    unsigned char mmu_en;
+    uint32_t base_addr;
+    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
+} MMU;
+
+
+typedef struct RECT
+{
+    unsigned short xmin;
+    unsigned short xmax; // width - 1
+    unsigned short ymin;
+    unsigned short ymax; // height - 1
+} RECT;
+
+typedef struct POINT
+{
+    unsigned short x;
+    unsigned short y;
+}
+POINT;
+
+typedef struct line_draw_t
+{
+    POINT start_point;              /* LineDraw_start_point                */
+    POINT end_point;                /* LineDraw_end_point                  */
+    uint32_t   color;               /* LineDraw_color                      */
+    uint32_t   flag;                /* (enum) LineDrawing mode sel         */
+    uint32_t   line_width;          /* range 1~16 */
+}
+line_draw_t;
+
+typedef struct rga_img_info_t
+{
+    unsigned int yrgb_addr;      /* yrgb    mem addr         */
+    unsigned int uv_addr;        /* cb/cr   mem addr         */
+    unsigned int v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+
+    unsigned short vir_w;
+    unsigned short vir_h;
+
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+
+    //unsigned short uv_x_off;
+    //unsigned short uv_y_off;
+}
+rga_img_info_t;
+
+struct rga_req {
+    uint8_t render_mode;            /* (enum) process mode sel */
+
+    rga_img_info_t src;             /* src image info */
+    rga_img_info_t dst;             /* dst image info */
+    rga_img_info_t pat;             /* patten image info */
+
+    uint32_t rop_mask_addr;         /* rop4 mask addr */
+    uint32_t LUT_addr;              /* LUT addr */
+
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+
+    COLOR_FILL gr_color;            /* color fill use gradient */
+
+    line_draw_t line_draw_info;
+
+    FADING fading;
+
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+
+    uint8_t alpha_global_value;     /* global alpha value */
+
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+
+    MMU mmu_info;                   /* mmu information */
+
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
+                                    /* ([2~3] rop   mode)            */
+                                    /* ([4]   zero  mode en)         */
+                                    /* ([5]   dst   alpha mode)      */
+                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
+
+    uint8_t  src_trans_mode;
+};
+
+
+
+struct rga2_req
+{
+    u8 render_mode;          /* (enum) process mode sel */
+
+    rga_img_info_t src;    // src  active window
+    rga_img_info_t src1;   // src1 active window
+    rga_img_info_t dst;    // dst  active window
+    rga_img_info_t pat;    // patten active window
+
+    u32 rop_mask_addr;       // rop4 mask addr
+    u32 LUT_addr;            // LUT addr
+
+    u32 rop_mask_stride;
+
+    u8 bitblt_mode;          /* 0: SRC + DST  => DST     */
+                             /* 1: SRC + SRC1 => DST     */
+
+    u8 rotate_mode;          /* [1:0]                           */
+                             /* 0   degree 0x0                  */
+                             /* 90  degree 0x1                  */
+                             /* 180 degree 0x2                  */
+                             /* 270 degree 0x3                  */
+                             /* [5:4]                           */
+                             /* none                0x0         */
+                             /* x_mirror            0x1         */
+                             /* y_mirror            0x2         */
+                             /* x_mirror + y_mirror 0x3         */
+
+    u16 alpha_rop_flag;         /* alpha rop process flag           */
+                                /* ([0] = 1 alpha_rop_enable)       */
+                                /* ([1] = 1 rop enable)             */
+                                /* ([2] = 1 fading_enable)          */
+                                /* ([3] = 1 alpha cal_mode_sel)     */
+                                /* ([4] = 1 src_dither_up_enable)   */
+                                /* ([5] = 1 dst_dither_up_enable)   */
+                                /* ([6] = 1 dither_down_enable)     */
+                                /* ([7] = 1 gradient fill mode sel) */
+
+
+    u16 alpha_mode_0;           /* [0]     SrcAlphaMode0          */
+                                /* [2:1]   SrcGlobalAlphaMode0    */
+                                /* [3]     SrcAlphaSelectMode0    */
+                                /* [6:4]   SrcFactorMode0         */
+                                /* [7]     SrcColorMode           */
+
+                                /* [8]     DstAlphaMode0          */
+                                /* [10:9]  DstGlobalAlphaMode0    */
+                                /* [11]    DstAlphaSelectMode0    */
+                                /* [14:12] DstFactorMode0         */
+                                /* [15]    DstColorMode0          */
+
+    u16 alpha_mode_1;           /* [0]     SrcAlphaMode1          */
+                                /* [2:1]   SrcGlobalAlphaMode1    */
+                                /* [3]     SrcAlphaSelectMode1    */
+                                /* [6:4]   SrcFactorMode1         */
+
+                                /* [8]     DstAlphaMode1          */
+                                /* [10:9]  DstGlobalAlphaMode1    */
+                                /* [11]    DstAlphaSelectMode1    */
+                                /* [14:12] DstFactorMode1         */
+
+    u8  scale_bicu_mode;    /* 0   1   2  3 */
+
+    u32 color_key_max;      /* color key max */
+    u32 color_key_min;      /* color key min */
+
+    u32 fg_color;           /* foreground color */
+    u32 bg_color;           /* background color */
+
+    u8 color_fill_mode;
+    COLOR_FILL gr_color;    /* color fill use gradient */
+
+    u8 fading_alpha_value;  /* Fading value */
+    u8 fading_r_value;
+    u8 fading_g_value;
+    u8 fading_b_value;
+
+    u8 src_a_global_val;    /* src global alpha value        */
+    u8 dst_a_global_val;    /* dst global alpha value        */
+
+
+    u8  rop_mode;
+    u16 rop_code;           /* rop2/3/4 code */
+
+    u8 palette_mode;        /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    u8 yuv2rgb_mode;        /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    u8 endian_mode;         /* 0/little endian 1/big endian */
+
+    u8 CMD_fin_int_enable;
+
+    MMU_INFO mmu_info;               /* mmu infomation */
+
+    u8 alpha_zero_key;
+    u8 src_trans_mode;
+
+    u8 alpha_swp;
+    u8 dither_mode;
+
+    u8 rgb2yuv_mode;
+};
+
+struct rga2_mmu_buf_t {
+    int32_t front;
+    int32_t back;
+    int32_t size;
+    int32_t curr;
+    unsigned int *buf;
+    unsigned int *buf_virtual;
+};
+
+//add for FPGA test ,by hxx & luj
+
+enum
+{
+    BB_ROTATE_OFF   = 0x0,     /* no rotate  */
+    BB_ROTATE_90    = 0x1,     /* rotate 90  */
+    BB_ROTATE_180   = 0x2,     /* rotate 180 */
+    BB_ROTATE_270   = 0x3,     /* rotate 270 */
+};  /*rotate mode*/
+
+enum
+{
+    BB_MIRROR_OFF   = (0x0 << 4),     /* no mirror  */
+    BB_MIRROR_X     = (0x1 << 4),     /* x  mirror  */
+    BB_MIRROR_Y     = (0x2 << 4),     /* y  mirror  */
+    BB_MIRROR_XY    = (0x3 << 4),     /* xy mirror  */
+};  /*mirror mode*/
+
+enum
+{
+    BB_COPY_USE_TILE = (0x1 << 6),    /* bitblt mode copy but use Tile mode */
+};
+
+enum
+{
+	//BYPASS        = 0x0,
+    BT_601_RANGE0   = 0x1,
+    BT_601_RANGE1   = 0x2,
+    BT_709_RANGE0   = 0x3,
+}; /*yuv2rgb_mode*/
+
+enum
+{
+    BPP1        = 0x0,     /* BPP1 */
+    BPP2        = 0x1,     /* BPP2 */
+    BPP4        = 0x2,     /* BPP4 */
+    BPP8        = 0x3      /* BPP8 */
+}; /*palette_mode*/
+
+enum
+{
+	SOLID_COLOR   = 0x0, //color fill mode; ROP4: SOLID_rop4_mask_addr COLOR
+	PATTERN_COLOR = 0x1  //pattern_fill_mode;ROP4:PATTERN_COLOR
+};  /*color fill mode*/
+
+enum
+{
+	COLOR_FILL_CLIP     = 0x0,
+	COLOR_FILL_NOT_CLIP = 0x1
+};
+
+enum
+{
+    CATROM    = 0x0,
+    MITCHELL  = 0x1,
+    HERMITE   = 0x2,
+    B_SPLINE  = 0x3,
+};  /*bicubic coefficient*/
+
+enum
+{
+	ROP2 = 0x0,
+	ROP3 = 0x1,
+	ROP4 = 0x2
+};  /*ROP mode*/
+
+enum
+{
+	BIG_ENDIAN    = 0x0,
+	LITTLE_ENDIAN = 0x1
+};  /*endian mode*/
+
+enum
+{
+	MMU_TABLE_4KB  = 0x0,
+	MMU_TABLE_64KB = 0x1,
+};  /*MMU table size*/
+
+enum
+{
+    RGB_2_666 = 0x0,
+    RGB_2_565 = 0x1,
+    RGB_2_555 = 0x2,
+    RGB_2_444 = 0x3,
+};  /*dither down mode*/
+
+
+
+/**
+ * struct for process session which connect to rga
+ *
+ * @author ZhangShengqin (2012-2-15)
+ */
+typedef struct rga2_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head    list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head    waiting;
+	/* a linked list of register data in processing */
+	struct list_head    running;
+	/* all coommand this thread done */
+    atomic_t            done;
+	wait_queue_head_t   wait;
+	pid_t           pid;
+	atomic_t        task_running;
+    atomic_t        num_done;
+} rga2_session;
+
+struct rga2_reg {
+    rga2_session 		*session;
+	struct list_head	session_link;		/* link to rga service session */
+	struct list_head	status_link;		/* link to register set list */
+	uint32_t  sys_reg[8];
+    uint32_t  cmd_reg[32];
+
+    uint32_t *MMU_base;
+    uint32_t MMU_len;
+    //atomic_t int_enable;
+
+    //struct rga_req      req;
+};
+
+
+
+struct rga2_service_info {
+    struct mutex	lock;
+    struct timer_list	timer;			/* timer for power off */
+    struct list_head	waiting;		/* link to link_reg in struct vpu_reg */
+    struct list_head	running;		/* link to link_reg in struct vpu_reg */
+    struct list_head	done;			/* link to link_reg in struct vpu_reg */
+    struct list_head	session;		/* link to list_session in struct vpu_session */
+    atomic_t		total_running;
+
+    struct rga2_reg        *reg;
+
+    uint32_t            cmd_buff[32*8];/* cmd_buff for rga */
+    uint32_t            *pre_scale_buf;
+    atomic_t            int_disable;     /* 0 int enable 1 int disable  */
+    atomic_t            cmd_num;
+    atomic_t            src_format_swt;
+    int                 last_prc_src_format;
+    atomic_t            rga_working;
+    bool                enable;
+
+    //struct rga_req      req[10];
+
+    struct mutex	mutex;	// mutex
+};
+
+#define RGA2_TEST_CASE 0
+#define RGA2_TEST      0
+#define RGA2_TEST_MSG  0
+#define RGA2_TEST_TIME 0
+
+
+#if defined(CONFIG_ARCH_RK3190)
+#define RGA2_BASE                 0x1010c000
+#elif defined(CONFIG_ARCH_RK32)
+#define RGA2_BASE                 0x10114000
+#endif
+
+//General Registers
+#define RGA2_SYS_CTRL             0x000
+#define RGA2_CMD_CTRL             0x004
+#define RGA2_CMD_BASE             0x008
+#define RGA2_STATUS               0x00c
+#define RGA2_INT                  0x010
+#define RGA2_MMU_CTRL0            0x018
+#define RGA2_MMU_CMD_BASE         0x01c
+
+//Command code start
+#define RGA2_MODE_CTRL            0x100
+#define RGA_BLIT_COMPLETE_EVENT 1
+
+long rga2_ioctl_kernel(struct rga2_req *req);
+
+
+#endif /*_RK29_IPP_DRIVER_H_*/
diff --git a/drivers/video/rockchip/rga2/rga2_drv.c b/drivers/video/rockchip/rga2/rga2_drv.c
new file mode 100644
index 000000000000..2dce2f46a7d2
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_drv.c
@@ -0,0 +1,1325 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) "rga: " fmt
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <mach/io.h>
+#include <mach/irqs.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+
+#include "rga2.h"
+#include "rga2_reg_info.h"
+#include "rga2_mmu_info.h"
+#include "RGA2_API.h"
+
+
+#define RGA2_TEST_FLUSH_TIME 0
+#define RGA2_INFO_BUS_ERROR 1
+
+#define RGA2_POWER_OFF_DELAY	4*HZ /* 4s */
+#define RGA2_TIMEOUT_DELAY	2*HZ /* 2s */
+
+#define RGA2_MAJOR		255
+
+#if defined(CONFIG_ROCKCHIP_RGA2)
+#define RK32_RGA2_PHYS		0xFFC70000
+#define RK32_RGA2_SIZE		0x00001000
+#endif
+#define RGA2_RESET_TIMEOUT	1000
+
+/* Driver information */
+#define DRIVER_DESC		"RGA2 Device Driver"
+#define DRIVER_NAME		"rga2"
+
+#define RGA2_VERSION   "2.000"
+
+ktime_t rga_start;
+ktime_t rga_end;
+
+int rga2_flag = 0;
+
+rga2_session rga2_session_global;
+
+struct rga2_drvdata_t {
+  	struct miscdevice miscdev;
+  	struct device dev;
+	void *rga_base;
+	int irq;
+
+	struct delayed_work power_off_work;
+	void (*rga_irq_callback)(int rga_retval);   //callback function used by aync call
+	struct wake_lock wake_lock;
+
+	struct clk *aclk_rga2;
+	struct clk *hclk_rga2;
+	struct clk *pd_rga2;
+    struct clk *rga2;
+};
+
+struct rga2_drvdata_t *rga2_drvdata;
+
+struct rga2_service_info rga2_service;
+struct rga2_mmu_buf_t rga2_mmu_buf;
+
+static int rga2_blit_async(rga2_session *session, struct rga2_req *req);
+static void rga2_del_running_list(void);
+static void rga2_del_running_list_timeout(void);
+static void rga2_try_set_reg(void);
+
+
+/* Logging */
+#define RGA_DEBUG 0
+#if RGA_DEBUG
+#define DBG(format, args...) printk(KERN_DEBUG "%s: " format, DRIVER_NAME, ## args)
+#define ERR(format, args...) printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
+#define WARNING(format, args...) printk(KERN_WARN "%s: " format, DRIVER_NAME, ## args)
+#define INFO(format, args...) printk(KERN_INFO "%s: " format, DRIVER_NAME, ## args)
+#else
+#define DBG(format, args...)
+#define ERR(format, args...)
+#define WARNING(format, args...)
+#define INFO(format, args...)
+#endif
+
+#if RGA2_TEST_MSG
+static void print_info(struct rga2_req *req)
+{
+    printk("render_mode=%d bitblt_mode=%d rotate_mode=%.8x\n",
+            req->render_mode, req->bitblt_mode, req->rotate_mode);
+    printk("src : y=%.8x uv=%.8x v=%.8x format=%d aw=%d ah=%d vw=%d vh=%d xoff=%d yoff=%d \n",
+            req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr, req->src.format,
+            req->src.act_w, req->src.act_h, req->src.vir_w, req->src.vir_h,
+            req->src.x_offset, req->src.y_offset);
+    printk("dst : y=%.8x uv=%.8x v=%.8x format=%d aw=%d ah=%d vw=%d vh=%d xoff=%d yoff=%d \n",
+            req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr, req->dst.format,
+            req->dst.act_w, req->dst.act_h, req->dst.vir_w, req->dst.vir_h,
+            req->dst.x_offset, req->dst.y_offset);
+    printk("mmu : src=%.2x src1=%.2x dst=%.2x els=%.2x\n",
+            req->mmu_info.src0_mmu_flag, req->mmu_info.src1_mmu_flag,
+            req->mmu_info.dst_mmu_flag,  req->mmu_info.els_mmu_flag);
+    printk("alpha : flag %.8x mode0=%.8x mode1=%.8x\n",
+            req->alpha_rop_flag, req->alpha_mode_0, req->alpha_mode_1);
+}
+#endif
+
+
+static inline void rga2_write(u32 b, u32 r)
+{
+	__raw_writel(b, rga2_drvdata->rga_base + r);
+}
+
+static inline u32 rga2_read(u32 r)
+{
+	return __raw_readl(rga2_drvdata->rga_base + r);
+}
+
+static void rga2_soft_reset(void)
+{
+	u32 i;
+	u32 reg;
+
+	rga2_write(1, RGA2_SYS_CTRL); //RGA_SYS_CTRL
+
+	for(i = 0; i < RGA2_RESET_TIMEOUT; i++)
+	{
+		reg = rga2_read(RGA2_SYS_CTRL) & 1; //RGA_SYS_CTRL
+
+		if(reg == 0)
+			break;
+
+		udelay(1);
+	}
+
+	if(i == RGA2_RESET_TIMEOUT)
+		ERR("soft reset timeout.\n");
+}
+
+static void rga2_dump(void)
+{
+	int running;
+    struct rga2_reg *reg, *reg_tmp;
+    rga2_session *session, *session_tmp;
+
+	running = atomic_read(&rga2_service.total_running);
+	printk("rga total_running %d\n", running);
+
+    #if 0
+
+    /* Dump waiting list info */
+    if (!list_empty(&rga_service.waiting))
+    {
+        list_head	*next;
+
+        next = &rga_service.waiting;
+
+        printk("rga_service dump waiting list\n");
+
+        do
+        {
+            reg = list_entry(next->next, struct rga_reg, status_link);
+            running = atomic_read(&reg->session->task_running);
+            num_done = atomic_read(&reg->session->num_done);
+            printk("rga session pid %d, done %d, running %d\n", reg->session->pid, num_done, running);
+            next = next->next;
+        }
+        while(!list_empty(next));
+    }
+
+    /* Dump running list info */
+    if (!list_empty(&rga_service.running))
+    {
+        printk("rga_service dump running list\n");
+
+        list_head	*next;
+
+        next = &rga_service.running;
+        do
+        {
+            reg = list_entry(next->next, struct rga_reg, status_link);
+            running = atomic_read(&reg->session->task_running);
+            num_done = atomic_read(&reg->session->num_done);
+            printk("rga session pid %d, done %d, running %d:\n", reg->session->pid, num_done, running);
+            next = next->next;
+        }
+        while(!list_empty(next));
+    }
+    #endif
+
+	list_for_each_entry_safe(session, session_tmp, &rga2_service.session, list_session)
+    {
+		printk("session pid %d:\n", session->pid);
+		running = atomic_read(&session->task_running);
+		printk("task_running %d\n", running);
+		list_for_each_entry_safe(reg, reg_tmp, &session->waiting, session_link)
+        {
+			printk("waiting register set 0x%.8x\n", (unsigned int)reg);
+		}
+		list_for_each_entry_safe(reg, reg_tmp, &session->running, session_link)
+        {
+			printk("running register set 0x%.8x\n", (unsigned int)reg);
+		}
+	}
+}
+
+static inline void rga2_queue_power_off_work(void)
+{
+	queue_delayed_work(system_nrt_wq, &rga2_drvdata->power_off_work, RGA2_POWER_OFF_DELAY);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_power_on(void)
+{
+	static ktime_t last;
+	ktime_t now = ktime_get();
+
+	if (ktime_to_ns(ktime_sub(now, last)) > NSEC_PER_SEC) {
+		cancel_delayed_work_sync(&rga2_drvdata->power_off_work);
+		rga2_queue_power_off_work();
+		last = now;
+	}
+	if (rga2_service.enable)
+		return;
+
+    clk_enable(rga2_drvdata->rga2);
+	clk_enable(rga2_drvdata->aclk_rga2);
+	clk_enable(rga2_drvdata->hclk_rga2);
+	clk_enable(rga2_drvdata->pd_rga2);
+	wake_lock(&rga2_drvdata->wake_lock);
+	rga2_service.enable = true;
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_power_off(void)
+{
+	int total_running;
+
+	if (!rga2_service.enable) {
+		return;
+	}
+
+	total_running = atomic_read(&rga2_service.total_running);
+	if (total_running) {
+		pr_err("power off when %d task running!!\n", total_running);
+		mdelay(50);
+		pr_err("delay 50 ms for running task\n");
+		rga2_dump();
+	}
+
+	clk_disable(rga2_drvdata->pd_rga2);
+    clk_disable(rga2_drvdata->rga2);
+	clk_disable(rga2_drvdata->aclk_rga2);
+	clk_disable(rga2_drvdata->hclk_rga2);
+	wake_unlock(&rga2_drvdata->wake_lock);
+	rga2_service.enable = false;
+}
+
+static void rga2_power_off_work(struct work_struct *work)
+{
+	if (mutex_trylock(&rga2_service.lock)) {
+		rga2_power_off();
+		mutex_unlock(&rga2_service.lock);
+	} else {
+		/* Come back later if the device is busy... */
+		rga2_queue_power_off_work();
+	}
+}
+
+static int rga2_flush(rga2_session *session, unsigned long arg)
+{
+    int ret = 0;
+    int ret_timeout;
+
+    #if RGA2_TEST_FLUSH_TIME
+    ktime_t start;
+    ktime_t end;
+    start = ktime_get();
+    #endif
+
+    ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA2_TIMEOUT_DELAY);
+
+	if (unlikely(ret_timeout < 0)) {
+		//pr_err("flush pid %d wait task ret %d\n", session->pid, ret);
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list();
+        mutex_unlock(&rga2_service.lock);
+        ret = ret_timeout;
+	} else if (0 == ret_timeout) {
+		//pr_err("flush pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+        //printk("bus  = %.8x\n", rga_read(RGA_INT));
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list_timeout();
+        rga2_try_set_reg();
+        mutex_unlock(&rga2_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+    #if RGA2_TEST_FLUSH_TIME
+    end = ktime_get();
+    end = ktime_sub(end, start);
+    printk("one flush wait time %d\n", (int)ktime_to_us(end));
+    #endif
+
+	return ret;
+}
+
+
+static int rga2_get_result(rga2_session *session, unsigned long arg)
+{
+	//printk("rga_get_result %d\n",drvdata->rga_result);
+
+    int ret = 0;
+
+    int num_done;
+
+    num_done = atomic_read(&session->num_done);
+
+	if (unlikely(copy_to_user((void __user *)arg, &num_done, sizeof(int)))) {
+			printk("copy_to_user failed\n");
+			ret =  -EFAULT;
+		}
+	return ret;
+}
+
+
+static int rga2_check_param(const struct rga2_req *req)
+{
+    /*RGA2 can support up to 8192*8192 resolution in RGB format,but we limit the image size to 8191*8191 here*/
+	//check src width and height
+
+    if(!((req->render_mode == color_fill_mode)))
+    {
+    	if (unlikely((req->src.act_w <= 0) || (req->src.act_w > 8191) || (req->src.act_h <= 0) || (req->src.act_h > 8191)))
+        {
+    		printk("invalid source resolution act_w = %d, act_h = %d\n", req->src.act_w, req->src.act_h);
+    		return  -EINVAL;
+    	}
+    }
+
+    if(!((req->render_mode == color_fill_mode)))
+    {
+    	if (unlikely((req->src.vir_w <= 0) || (req->src.vir_w > 8191) || (req->src.vir_h <= 0) || (req->src.vir_h > 8191)))
+        {
+    		printk("invalid source resolution vir_w = %d, vir_h = %d\n", req->src.vir_w, req->src.vir_h);
+    		return  -EINVAL;
+    	}
+    }
+
+	//check dst width and height
+	if (unlikely((req->dst.act_w <= 0) || (req->dst.act_w > 4096) || (req->dst.act_h <= 0) || (req->dst.act_h > 4096)))
+    {
+		printk("invalid destination resolution act_w = %d, act_h = %d\n", req->dst.act_w, req->dst.act_h);
+		return	-EINVAL;
+	}
+
+    if (unlikely((req->dst.vir_w <= 0) || (req->dst.vir_w > 4096) || (req->dst.vir_h <= 0) || (req->dst.vir_h > 4096)))
+    {
+		printk("invalid destination resolution vir_w = %d, vir_h = %d\n", req->dst.vir_w, req->dst.vir_h);
+		return	-EINVAL;
+	}
+
+	//check src_vir_w
+	if(unlikely(req->src.vir_w < req->src.act_w)){
+		printk("invalid src_vir_w act_w = %d, vir_w = %d\n", req->src.act_w, req->src.vir_w);
+		return	-EINVAL;
+	}
+
+	//check dst_vir_w
+	if(unlikely(req->dst.vir_w < req->dst.act_w)){
+        if(req->rotate_mode != 1)
+        {
+		    printk("invalid dst_vir_w act_h = %d, vir_h = %d\n", req->dst.act_w, req->dst.vir_w);
+		    return	-EINVAL;
+        }
+	}
+
+	return 0;
+}
+
+static void rga2_copy_reg(struct rga2_reg *reg, uint32_t offset)
+{
+    uint32_t i;
+    uint32_t *cmd_buf;
+    uint32_t *reg_p;
+
+    if(atomic_read(&reg->session->task_running) != 0)
+    {
+        printk(KERN_ERR "task_running is no zero\n");
+    }
+
+    atomic_add(1, &rga2_service.cmd_num);
+	atomic_add(1, &reg->session->task_running);
+
+    cmd_buf = (uint32_t *)rga2_service.cmd_buff + offset*32;
+    reg_p = (uint32_t *)reg->cmd_reg;
+
+    for(i=0; i<32; i++)
+    {
+        cmd_buf[i] = reg_p[i];
+    }
+
+    dsb();
+}
+
+
+static struct rga2_reg * rga2_reg_init(rga2_session *session, struct rga2_req *req)
+{
+    uint32_t ret;
+	struct rga2_reg *reg = kzalloc(sizeof(struct rga2_reg), GFP_KERNEL);
+	if (NULL == reg) {
+		pr_err("kmalloc fail in rga_reg_init\n");
+		return NULL;
+	}
+
+    reg->session = session;
+	INIT_LIST_HEAD(&reg->session_link);
+	INIT_LIST_HEAD(&reg->status_link);
+
+    reg->MMU_base = NULL;
+
+    if ((req->mmu_info.src0_mmu_flag & 1) || (req->mmu_info.src1_mmu_flag & 1)
+        || (req->mmu_info.dst_mmu_flag & 1) || (req->mmu_info.els_mmu_flag & 1))
+    {
+        ret = rga2_set_mmu_info(reg, req);
+        if(ret < 0)
+        {
+            printk("%s, [%d] set mmu info error \n", __FUNCTION__, __LINE__);
+            if(reg != NULL)
+            {
+                kfree(reg);
+            }
+            return NULL;
+        }
+    }
+
+    if(RGA2_gen_reg_info((uint8_t *)reg->cmd_reg, req) == -1)
+    {
+        printk("gen reg info error\n");
+        if(reg != NULL)
+        {
+            kfree(reg);
+        }
+        return NULL;
+    }
+
+    mutex_lock(&rga2_service.lock);
+	list_add_tail(&reg->status_link, &rga2_service.waiting);
+	list_add_tail(&reg->session_link, &session->waiting);
+	mutex_unlock(&rga2_service.lock);
+
+    return reg;
+}
+
+
+/* Caller must hold rga_service.lock */
+static void rga2_reg_deinit(struct rga2_reg *reg)
+{
+	list_del_init(&reg->session_link);
+	list_del_init(&reg->status_link);
+	kfree(reg);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_reg_from_wait_to_run(struct rga2_reg *reg)
+{
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &rga2_service.running);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->running);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_service_session_clear(rga2_session *session)
+{
+	struct rga2_reg *reg, *n;
+
+    list_for_each_entry_safe(reg, n, &session->waiting, session_link)
+    {
+		rga2_reg_deinit(reg);
+	}
+
+    list_for_each_entry_safe(reg, n, &session->running, session_link)
+    {
+		rga2_reg_deinit(reg);
+	}
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_try_set_reg(void)
+{
+    struct rga2_reg *reg ;
+
+    if (list_empty(&rga2_service.running))
+    {
+        if (!list_empty(&rga2_service.waiting))
+        {
+            /* RGA is idle */
+            reg = list_entry(rga2_service.waiting.next, struct rga2_reg, status_link);
+
+            rga2_power_on();
+            udelay(1);
+
+            rga2_copy_reg(reg, 0);
+            rga2_reg_from_wait_to_run(reg);
+
+            dmac_flush_range(&rga2_service.cmd_buff[0], &rga2_service.cmd_buff[32]);
+            outer_flush_range(virt_to_phys(&rga2_service.cmd_buff[0]),virt_to_phys(&rga2_service.cmd_buff[32]));
+
+            #if defined(CONFIG_ARCH_RK30)
+            rga2_soft_reset();
+            #endif
+
+            rga2_write(0x0, RGA2_SYS_CTRL);
+            //rga2_write(0, RGA_MMU_CTRL);
+
+            /* CMD buff */
+            rga2_write(virt_to_phys(rga2_service.cmd_buff), RGA2_CMD_BASE);
+
+#if RGA2_TEST
+            if(rga2_flag)
+            {
+                //printk(KERN_DEBUG "cmd_addr = %.8x\n", rga_read(RGA_CMD_ADDR));
+                uint32_t i, *p;
+                p = rga2_service.cmd_buff;
+                printk("CMD_REG\n");
+                for (i=0; i<8; i++)
+                    printk("%.8x %.8x %.8x %.8x\n", p[0 + i*4], p[1+i*4], p[2 + i*4], p[3 + i*4]);
+            }
+#endif
+
+            /* master mode */
+            rga2_write((0x1<<1)|(0x1<<2)|(0x1<<5)|(0x1<<6), RGA2_SYS_CTRL);
+
+            /* All CMD finish int */
+            rga2_write(rga2_read(RGA2_INT)|(0x1<<10)|(0x1<<8), RGA2_INT);
+
+            #if RGA2_TEST_TIME
+            rga_start = ktime_get();
+            #endif
+
+            /* Start proc */
+            atomic_set(&reg->session->done, 0);
+            rga2_write(0x1, RGA2_CMD_CTRL);
+#if RGA2_TEST
+            if(rga2_flag)
+            {
+                uint32_t i;
+                printk("CMD_READ_BACK_REG\n");
+                for (i=0; i<8; i++)
+                    printk("%.8x %.8x %.8x %.8x\n", rga2_read(0x100 + i*16 + 0),
+                            rga2_read(0x100 + i*16 + 4), rga2_read(0x100 + i*16 + 8), rga2_read(0x100 + i*16 + 12));
+            }
+#endif
+        }
+    }
+}
+
+
+
+
+/* Caller must hold rga_service.lock */
+static void rga2_del_running_list(void)
+{
+    struct rga2_reg *reg;
+
+    while(!list_empty(&rga2_service.running))
+    {
+        reg = list_entry(rga2_service.running.next, struct rga2_reg, status_link);
+
+        if(reg->MMU_len != 0)
+        {
+            if (rga2_mmu_buf.back + reg->MMU_len > 2*rga2_mmu_buf.size)
+                rga2_mmu_buf.back = reg->MMU_len + rga2_mmu_buf.size;
+            else
+                rga2_mmu_buf.back += reg->MMU_len;
+        }
+        atomic_sub(1, &reg->session->task_running);
+        atomic_sub(1, &rga2_service.total_running);
+
+        if(list_empty(&reg->session->waiting))
+        {
+            atomic_set(&reg->session->done, 1);
+            wake_up(&reg->session->wait);
+        }
+
+        rga2_reg_deinit(reg);
+    }
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_del_running_list_timeout(void)
+{
+    struct rga2_reg *reg;
+
+    while(!list_empty(&rga2_service.running))
+    {
+        reg = list_entry(rga2_service.running.next, struct rga2_reg, status_link);
+
+        if(reg->MMU_base != NULL)
+        {
+            kfree(reg->MMU_base);
+        }
+
+        atomic_sub(1, &reg->session->task_running);
+        atomic_sub(1, &rga2_service.total_running);
+
+        //printk("RGA soft reset for timeout process\n");
+        rga2_soft_reset();
+
+
+        #if 0
+        printk("RGA_INT is %.8x\n", rga_read(RGA_INT));
+        printk("reg->session->task_running = %d\n", atomic_read(&reg->session->task_running));
+        printk("rga_service.total_running  = %d\n", atomic_read(&rga_service.total_running));
+
+        print_info(&reg->req);
+
+        {
+            uint32_t *p, i;
+            p = reg->cmd_reg;
+            for (i=0; i<7; i++)
+                printk("%.8x %.8x %.8x %.8x\n", p[0 + i*4], p[1+i*4], p[2 + i*4], p[3 + i*4]);
+
+        }
+        #endif
+
+        if(list_empty(&reg->session->waiting))
+        {
+            atomic_set(&reg->session->done, 1);
+            wake_up(&reg->session->wait);
+        }
+
+        rga2_reg_deinit(reg);
+    }
+}
+
+
+static void rga2_mem_addr_sel(struct rga2_req *req)
+{
+}
+
+
+static int rga2_blit(rga2_session *session, struct rga2_req *req)
+{
+    int ret = -1;
+    int num = 0;
+    struct rga2_reg *reg;
+
+    do
+    {
+        /* check value if legal */
+        ret = rga2_check_param(req);
+    	if(ret == -EINVAL) {
+            printk("req argument is inval\n");
+            break;
+    	}
+
+        reg = rga2_reg_init(session, req);
+        if(reg == NULL) {
+            break;
+        }
+        num = 1;
+
+        mutex_lock(&rga2_service.lock);
+        atomic_add(num, &rga2_service.total_running);
+        rga2_try_set_reg();
+        mutex_unlock(&rga2_service.lock);
+
+        return 0;
+    }
+    while(0);
+
+    return -EFAULT;
+}
+
+static int rga2_blit_async(rga2_session *session, struct rga2_req *req)
+{
+	int ret = -1;
+
+    #if RGA2_TEST_MSG
+    //printk("*** rga_blit_async proc ***\n");
+    if (req->src.format >= 0x10) {
+        print_info(req);
+        rga2_flag = 1;
+        printk("*** rga_blit_async proc ***\n");
+    }
+    else
+        rga2_flag = 0;
+    #endif
+    atomic_set(&session->done, 0);
+    ret = rga2_blit(session, req);
+
+    return ret;
+}
+
+static int rga2_blit_sync(rga2_session *session, struct rga2_req *req)
+{
+    int ret = -1;
+    int ret_timeout = 0;
+
+    #if RGA2_TEST_MSG
+    if (req->src.format >= 0x10) {
+        print_info(req);
+        rga2_flag = 1;
+        printk("*** rga2_blit_sync proc ***\n");
+    }
+    else
+        rga2_flag = 0;
+    #endif
+
+    atomic_set(&session->done, 0);
+
+    ret = rga2_blit(session, req);
+    if(ret < 0)
+    {
+        return ret;
+    }
+
+    ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA2_TIMEOUT_DELAY);
+
+    if (unlikely(ret_timeout< 0))
+    {
+		//pr_err("sync pid %d wait task ret %d\n", session->pid, ret_timeout);
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list();
+        mutex_unlock(&rga2_service.lock);
+        ret = ret_timeout;
+	}
+    else if (0 == ret_timeout)
+    {
+		//pr_err("sync pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list_timeout();
+        rga2_try_set_reg();
+        mutex_unlock(&rga2_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+    #if RGA2_TEST_TIME
+    rga_end = ktime_get();
+    rga_end = ktime_sub(rga_end, rga_start);
+    printk("sync one cmd end time %d\n", (int)ktime_to_us(rga_end));
+    #endif
+
+    return ret;
+}
+
+
+static long rga_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
+{
+    struct rga2_req req;
+    struct rga_req req_rga;
+	int ret = 0;
+    rga2_session *session;
+
+    mutex_lock(&rga2_service.mutex);
+
+    session = (rga2_session *)file->private_data;
+
+	if (NULL == session)
+    {
+        printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+        mutex_unlock(&rga2_service.mutex);
+		return -EINVAL;
+	}
+
+    memset(&req, 0x0, sizeof(req));
+
+	switch (cmd)
+	{
+        case RGA_BLIT_SYNC:
+
+    		if (unlikely(copy_from_user(&req_rga, (struct rga_req*)arg, sizeof(struct rga_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+            RGA_MSG_2_RGA2_MSG(&req_rga, &req);
+
+            ret = rga2_blit_sync(session, &req);
+            break;
+		case RGA_BLIT_ASYNC:
+    		if (unlikely(copy_from_user(&req_rga, (struct rga_req*)arg, sizeof(struct rga_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+
+            RGA_MSG_2_RGA2_MSG(&req_rga, &req);
+
+            if((atomic_read(&rga2_service.total_running) > 8))
+            {
+			    ret = rga2_blit_sync(session, &req);
+            }
+            else
+            {
+                ret = rga2_blit_async(session, &req);
+            }
+			break;
+		case RGA2_BLIT_SYNC:
+    		if (unlikely(copy_from_user(&req, (struct rga2_req*)arg, sizeof(struct rga2_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+            ret = rga2_blit_sync(session, &req);
+            break;
+		case RGA2_BLIT_ASYNC:
+    		if (unlikely(copy_from_user(&req, (struct rga2_req*)arg, sizeof(struct rga2_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+
+            if((atomic_read(&rga2_service.total_running) > 16))
+            {
+			    ret = rga2_blit_sync(session, &req);
+            }
+            else
+            {
+                ret = rga2_blit_async(session, &req);
+            }
+			break;
+        case RGA_FLUSH:
+		case RGA2_FLUSH:
+			ret = rga2_flush(session, arg);
+			break;
+        case RGA_GET_RESULT:
+        case RGA2_GET_RESULT:
+            ret = rga2_get_result(session, arg);
+            break;
+        case RGA_GET_VERSION:
+        case RGA2_GET_VERSION:
+            ret = copy_to_user((void *)arg, RGA2_VERSION, sizeof(RGA2_VERSION));
+            //ret = 0;
+            break;
+		default:
+			ERR("unknown ioctl cmd!\n");
+			ret = -EINVAL;
+			break;
+	}
+
+	mutex_unlock(&rga2_service.mutex);
+
+	return ret;
+}
+
+
+long rga_ioctl_kernel(struct rga_req *req)
+{
+	int ret = 0;
+    rga2_session *session;
+    struct rga2_req req_rga2;
+
+    mutex_lock(&rga2_service.mutex);
+
+    session = &rga2_session_global;
+
+	if (NULL == session)
+    {
+        printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+        mutex_unlock(&rga2_service.mutex);
+		return -EINVAL;
+	}
+
+    RGA_MSG_2_RGA2_MSG(req, &req_rga2);
+    ret = rga2_blit_sync(session, &req_rga2);
+
+	mutex_unlock(&rga2_service.mutex);
+
+	return ret;
+}
+
+
+static int rga2_open(struct inode *inode, struct file *file)
+{
+    rga2_session *session = kzalloc(sizeof(rga2_session), GFP_KERNEL);
+	if (NULL == session) {
+		pr_err("unable to allocate memory for rga_session.");
+		return -ENOMEM;
+	}
+
+	session->pid = current->pid;
+    //printk(KERN_DEBUG  "+");
+
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	mutex_lock(&rga2_service.lock);
+	list_add_tail(&session->list_session, &rga2_service.session);
+	mutex_unlock(&rga2_service.lock);
+	atomic_set(&session->task_running, 0);
+    atomic_set(&session->num_done, 0);
+
+	file->private_data = (void *)session;
+
+    //DBG("*** rga dev opened by pid %d *** \n", session->pid);
+	return nonseekable_open(inode, file);
+
+}
+
+static int rga2_release(struct inode *inode, struct file *file)
+{
+    int task_running;
+	rga2_session *session = (rga2_session *)file->private_data;
+	if (NULL == session)
+		return -EINVAL;
+    //printk(KERN_DEBUG  "-");
+	task_running = atomic_read(&session->task_running);
+
+    if (task_running)
+    {
+		pr_err("rga2_service session %d still has %d task running when closing\n", session->pid, task_running);
+		msleep(100);
+        /**/
+	}
+
+	wake_up(&session->wait);
+	mutex_lock(&rga2_service.lock);
+	list_del(&session->list_session);
+	rga2_service_session_clear(session);
+	kfree(session);
+	mutex_unlock(&rga2_service.lock);
+
+    //DBG("*** rga dev close ***\n");
+	return 0;
+}
+
+static irqreturn_t rga2_irq_thread(int irq, void *dev_id)
+{
+	mutex_lock(&rga2_service.lock);
+	if (rga2_service.enable) {
+		rga2_del_running_list();
+		rga2_try_set_reg();
+	}
+	mutex_unlock(&rga2_service.lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rga2_irq(int irq,  void *dev_id)
+{
+	/*clear INT */
+	rga2_write(rga2_read(RGA2_INT) | (0x1<<4) | (0x1<<5) | (0x1<<6) | (0x1<<7), RGA2_INT);
+
+	return IRQ_WAKE_THREAD;
+}
+
+struct file_operations rga2_fops = {
+	.owner		= THIS_MODULE,
+	.open		= rga2_open,
+	.release	= rga2_release,
+	.unlocked_ioctl		= rga_ioctl,
+};
+
+static struct miscdevice rga2_dev ={
+    .minor = RGA2_MAJOR,
+    .name  = "rga",
+    .fops  = &rga2_fops,
+};
+
+static int __devinit rga2_drv_probe(struct platform_device *pdev)
+{
+	struct rga2_drvdata_t *data;
+	int ret = 0;
+
+	INIT_LIST_HEAD(&rga2_service.waiting);
+	INIT_LIST_HEAD(&rga2_service.running);
+	INIT_LIST_HEAD(&rga2_service.done);
+	INIT_LIST_HEAD(&rga2_service.session);
+	mutex_init(&rga2_service.lock);
+	mutex_init(&rga2_service.mutex);
+	atomic_set(&rga2_service.total_running, 0);
+	atomic_set(&rga2_service.src_format_swt, 0);
+	rga2_service.last_prc_src_format = 1; /* default is yuv first*/
+	rga2_service.enable = false;
+
+	data = kzalloc(sizeof(struct rga2_drvdata_t), GFP_KERNEL);
+	if(NULL == data)
+	{
+		ERR("failed to allocate driver data.\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&data->power_off_work, rga2_power_off_work);
+	wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "rga");
+
+	data->pd_rga2 = clk_get(NULL, "pd_rga");
+    data->rga2 = clk_get(NULL, "rga");
+	data->aclk_rga2 = clk_get(NULL, "aclk_rga");
+	data->hclk_rga2 = clk_get(NULL, "hclk_rga");
+
+	/* map the memory */
+	if (!request_mem_region(RK32_RGA2_PHYS, RK32_RGA2_SIZE, "rga_io"))
+	{
+		pr_info("failed to reserve rga HW regs\n");
+		return -EBUSY;
+	}
+
+	data->rga_base = (void*)ioremap_nocache(RK32_RGA2_PHYS, RK32_RGA2_SIZE);
+	if (data->rga_base == NULL)
+	{
+		ERR("rga ioremap failed\n");
+		ret = -ENOENT;
+		goto err_ioremap;
+	}
+
+	/* get the IRQ */
+	data->irq = platform_get_irq(pdev, 0);
+	if (data->irq <= 0)
+	{
+		ERR("failed to get rga irq resource (%d).\n", data->irq);
+		ret = data->irq;
+		goto err_irq;
+	}
+
+	/* request the IRQ */
+	ret = request_threaded_irq(data->irq, rga2_irq, rga2_irq_thread, 0, "rga", pdev);
+	if (ret)
+	{
+		ERR("rga request_irq failed (%d).\n", ret);
+		goto err_irq;
+	}
+
+	platform_set_drvdata(pdev, data);
+	rga2_drvdata = data;
+
+	ret = misc_register(&rga2_dev);
+	if(ret)
+	{
+		ERR("cannot register miscdev (%d)\n", ret);
+		goto err_misc_register;
+	}
+
+	pr_info("Driver loaded succesfully\n");
+
+	return 0;
+
+err_misc_register:
+	free_irq(data->irq, pdev);
+err_irq:
+	iounmap(data->rga_base);
+err_ioremap:
+	wake_lock_destroy(&data->wake_lock);
+	kfree(data);
+
+	return ret;
+}
+
+static int rga2_drv_remove(struct platform_device *pdev)
+{
+	struct rga2_drvdata_t *data = platform_get_drvdata(pdev);
+	DBG("%s [%d]\n",__FUNCTION__,__LINE__);
+
+	wake_lock_destroy(&data->wake_lock);
+	misc_deregister(&(data->miscdev));
+	free_irq(data->irq, &data->miscdev);
+	iounmap((void __iomem *)(data->rga_base));
+
+	clk_put(data->pd_rga2);
+    clk_put(data->rga2);
+	clk_put(data->aclk_rga2);
+	clk_put(data->hclk_rga2);
+
+
+	kfree(data);
+	return 0;
+}
+
+static struct platform_driver rga2_driver = {
+	.probe		= rga2_drv_probe,
+	.remove		= __devexit_p(rga2_drv_remove),
+	.driver		= {
+		.owner  = THIS_MODULE,
+		.name	= "rga",
+	},
+};
+
+
+void rga2_test_0(void);
+
+static int __init rga2_init(void)
+{
+	int ret;
+    uint32_t *buf_p;
+
+    /* malloc pre scale mid buf mmu table */
+    buf_p = kmalloc(1024*256, GFP_KERNEL);
+    rga2_mmu_buf.buf_virtual = buf_p;
+    rga2_mmu_buf.buf = (uint32_t *)virt_to_phys((void *)((uint32_t)buf_p));
+    rga2_mmu_buf.front = 0;
+    rga2_mmu_buf.back = 64*1024;
+    rga2_mmu_buf.size = 64*1024;
+
+	if ((ret = platform_driver_register(&rga2_driver)) != 0)
+	{
+        printk(KERN_ERR "Platform device register failed (%d).\n", ret);
+			return ret;
+	}
+
+    {
+        rga2_session_global.pid = 0x0000ffff;
+        INIT_LIST_HEAD(&rga2_session_global.waiting);
+        INIT_LIST_HEAD(&rga2_session_global.running);
+        INIT_LIST_HEAD(&rga2_session_global.list_session);
+        init_waitqueue_head(&rga2_session_global.wait);
+        //mutex_lock(&rga_service.lock);
+        list_add_tail(&rga2_session_global.list_session, &rga2_service.session);
+        //mutex_unlock(&rga_service.lock);
+        atomic_set(&rga2_session_global.task_running, 0);
+        atomic_set(&rga2_session_global.num_done, 0);
+    }
+
+    #if RGA2_TEST_CASE
+    rga2_test_0();
+    #endif
+
+	INFO("Module initialized.\n");
+
+	return 0;
+}
+
+static void __exit rga2_exit(void)
+{
+    rga2_power_off();
+
+    if (rga2_mmu_buf.buf_virtual)
+        kfree(rga2_mmu_buf.buf_virtual);
+
+	platform_driver_unregister(&rga2_driver);
+}
+
+
+#if RGA2_TEST_CASE
+
+extern struct fb_info * rk_get_fb(int fb_id);
+EXPORT_SYMBOL(rk_get_fb);
+
+extern void rk_direct_fb_show(struct fb_info * fbi);
+EXPORT_SYMBOL(rk_direct_fb_show);
+
+//unsigned int src_buf[1920*1080];
+//unsigned int dst_buf[1920*1080];
+//unsigned int tmp_buf[1920*1080 * 2];
+
+void rga2_test_0(void)
+{
+    struct rga2_req req;
+    rga2_session session;
+    unsigned int *src, *dst;
+    uint32_t i, j;
+    uint8_t *p;
+    uint8_t t;
+    uint32_t *dst0, *dst1, *dst2;
+
+    struct fb_info *fb;
+
+    session.pid	= current->pid;
+	INIT_LIST_HEAD(&session.waiting);
+	INIT_LIST_HEAD(&session.running);
+	INIT_LIST_HEAD(&session.list_session);
+	init_waitqueue_head(&session.wait);
+	/* no need to protect */
+	list_add_tail(&session.list_session, &rga2_service.session);
+	atomic_set(&session.task_running, 0);
+    atomic_set(&session.num_done, 0);
+	//file->private_data = (void *)session;
+
+    fb = rk_get_fb(0);
+
+    memset(&req, 0, sizeof(struct rga2_req));
+    src = kmalloc(800*480*4, GFP_KERNEL);
+    dst = kmalloc(800*480*4, GFP_KERNEL);
+
+    memset(src, 0x80, 800*480*4);
+
+    dmac_flush_range(&src, &src[800*480*4]);
+    outer_flush_range(virt_to_phys(&src),virt_to_phys(&src[800*480*4]));
+
+
+    #if 0
+    memset(src_buf, 0x80, 800*480*4);
+    memset(dst_buf, 0xcc, 800*480*4);
+
+    dmac_flush_range(&dst_buf[0], &dst_buf[800*480]);
+    outer_flush_range(virt_to_phys(&dst_buf[0]),virt_to_phys(&dst_buf[800*480]));
+    #endif
+
+    dst0 = &dst;
+
+    i = j = 0;
+
+    printk("\n********************************\n");
+    printk("************ RGA2_TEST ************\n");
+    printk("********************************\n\n");
+
+    req.src.act_w  = 320;
+    req.src.act_h = 240;
+
+    req.src.vir_w  = 320;
+    req.src.vir_h = 240;
+    req.src.yrgb_addr = (uint32_t)virt_to_phys(src);
+    req.src.uv_addr = (uint32_t)(req.src.yrgb_addr + 800*480);
+    req.src.v_addr = (uint32_t)virt_to_phys(src);
+    req.src.format = RGA2_FORMAT_RGBA_8888;
+
+    req.dst.act_w  = 320;
+    req.dst.act_h = 240;
+    req.dst.x_offset = 0;
+    req.dst.y_offset = 0;
+
+    req.dst.vir_w = 320;
+    req.dst.vir_h = 240;
+
+    req.dst.yrgb_addr = ((uint32_t)virt_to_phys(dst));
+    req.dst.format = RGA2_FORMAT_RGBA_8888;
+
+    //dst = dst0;
+
+    //req.render_mode = color_fill_mode;
+    //req.fg_color = 0x80ffffff;
+
+    req.rotate_mode = 1;
+    req.scale_bicu_mode = 2;
+
+    //req.alpha_rop_flag = 0;
+    //req.alpha_rop_mode = 0x19;
+    //req.PD_mode = 3;
+
+    req.rotate_mode = 0;
+
+    //req.mmu_info.mmu_flag = 0x21;
+    //req.mmu_info.mmu_en = 1;
+
+    //printk("src = %.8x\n", req.src.yrgb_addr);
+    //printk("src = %.8x\n", req.src.uv_addr);
+    //printk("dst = %.8x\n", req.dst.yrgb_addr);
+
+    rga2_blit_sync(&session, &req);
+
+    #if 0
+    fb->var.bits_per_pixel = 32;
+
+    fb->var.xres = 1280;
+    fb->var.yres = 800;
+
+    fb->var.red.length = 8;
+    fb->var.red.offset = 0;
+    fb->var.red.msb_right = 0;
+
+    fb->var.green.length = 8;
+    fb->var.green.offset = 8;
+    fb->var.green.msb_right = 0;
+
+    fb->var.blue.length = 8;
+
+    fb->var.blue.offset = 16;
+    fb->var.blue.msb_right = 0;
+
+    fb->var.transp.length = 8;
+    fb->var.transp.offset = 24;
+    fb->var.transp.msb_right = 0;
+
+    fb->var.nonstd &= (~0xff);
+    fb->var.nonstd |= 1;
+
+    fb->fix.smem_start = virt_to_phys(dst);
+
+    rk_direct_fb_show(fb);
+    #endif
+
+    if(src)
+        kfree(src);
+    if(dst)
+        kfree(dst);
+}
+
+#endif
+module_init(rga2_init);
+module_exit(rga2_exit);
+
+/* Module information */
+MODULE_AUTHOR("zsq@rock-chips.com");
+MODULE_DESCRIPTION("Driver for rga device");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/rockchip/rga2/rga2_mmu_info.c b/drivers/video/rockchip/rga2/rga2_mmu_info.c
new file mode 100644
index 000000000000..f29353e8543c
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.c
@@ -0,0 +1,1001 @@
+
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/memory.h>
+#include <linux/dma-mapping.h>
+#include <asm/memory.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include "rga2_mmu_info.h"
+
+extern struct rga2_service_info rga2_service;
+extern struct rga2_mmu_buf_t rga2_mmu_buf;
+
+//extern int mmu_buff_temp[1024];
+
+#define KERNEL_SPACE_VALID    0xc0000000
+
+#define V7_VATOPA_SUCESS_MASK	(0x1)
+#define V7_VATOPA_GET_PADDR(X)	(X & 0xFFFFF000)
+#define V7_VATOPA_GET_INER(X)		((X>>4) & 7)
+#define V7_VATOPA_GET_OUTER(X)		((X>>2) & 3)
+#define V7_VATOPA_GET_SH(X)		((X>>7) & 1)
+#define V7_VATOPA_GET_NS(X)		((X>>9) & 1)
+#define V7_VATOPA_GET_SS(X)		((X>>1) & 1)
+
+#if 0
+static unsigned int armv7_va_to_pa(unsigned int v_addr)
+{
+	unsigned int p_addr;
+	__asm__ volatile (	"mcr p15, 0, %1, c7, c8, 0\n"
+						"isb\n"
+						"dsb\n"
+						"mrc p15, 0, %0, c7, c4, 0\n"
+						: "=r" (p_addr)
+						: "r" (v_addr)
+						: "cc");
+
+	if (p_addr & V7_VATOPA_SUCESS_MASK)
+		return 0xFFFFFFFF;
+	else
+		return (V7_VATOPA_GET_SS(p_addr) ? 0xFFFFFFFF : V7_VATOPA_GET_PADDR(p_addr));
+}
+#endif
+
+static int rga2_mmu_buf_get(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+    mutex_lock(&rga2_service.lock);
+    t->front += size;
+    mutex_unlock(&rga2_service.lock);
+
+    return 0;
+}
+
+static int rga2_mmu_buf_get_try(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+    mutex_lock(&rga2_service.lock);
+    if((t->back - t->front) > t->size) {
+        if(t->front + size > t->back - t->size)
+            return -1;
+    }
+    else {
+        if((t->front + size) > t->back)
+            return -1;
+
+        if(t->front + size > t->size) {
+            if (size > (t->back - t->size)) {
+                return -1;
+            }
+            t->front = 0;
+        }
+    }
+    mutex_unlock(&rga2_service.lock);
+
+    return 0;
+}
+
+
+static int rga2_mmu_buf_cal(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+    if((t->front + size) > t->back) {
+        return -1;
+    }
+    else {
+        return 0;
+    }
+}
+
+
+
+static int rga2_mem_size_cal(uint32_t Mem, uint32_t MemSize, uint32_t *StartAddr)
+{
+    uint32_t start, end;
+    uint32_t pageCount;
+
+    end = (Mem + (MemSize + PAGE_SIZE - 1)) >> PAGE_SHIFT;
+    start = Mem >> PAGE_SHIFT;
+    pageCount = end - start;
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga2_buf_size_cal(uint32_t yrgb_addr, uint32_t uv_addr, uint32_t v_addr,
+                                        int format, uint32_t w, uint32_t h, uint32_t *StartAddr )
+{
+    uint32_t size_yrgb = 0;
+    uint32_t size_uv = 0;
+    uint32_t size_v = 0;
+    uint32_t stride = 0;
+    uint32_t start, end;
+    uint32_t pageCount;
+
+    switch(format)
+    {
+        case RGA2_FORMAT_RGBA_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBX_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_888 :
+            stride = (w * 3 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_BGRA_8888 :
+            size_yrgb = w*h*4;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_565 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_5551 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_4444 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_BGR_888 :
+            stride = (w*3 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+
+        /* YUV FORMAT */
+        case RGA2_FORMAT_YCbCr_422_SP :
+        case RGA2_FORMAT_YCrCb_422_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = stride * h;
+            start = MIN(yrgb_addr, uv_addr);
+
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_422_P :
+        case RGA2_FORMAT_YCrCb_422_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * h);
+            size_v = ((stride >> 1) * h);
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start = start >> PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_SP :
+        case RGA2_FORMAT_YCrCb_420_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_P :
+        case RGA2_FORMAT_YCrCb_420_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * (h >> 1));
+            size_v = ((stride >> 1) * (h >> 1));
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        #if 0
+        case RK_FORMAT_BPP1 :
+            break;
+        case RK_FORMAT_BPP2 :
+            break;
+        case RK_FORMAT_BPP4 :
+            break;
+        case RK_FORMAT_BPP8 :
+            break;
+        #endif
+        default :
+            pageCount = 0;
+            start = 0;
+            break;
+    }
+
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga2_MapUserMemory(struct page **pages,
+                                            uint32_t *pageTable,
+                                            uint32_t Memory,
+                                            uint32_t pageCount)
+{
+    int32_t result;
+    uint32_t i;
+    uint32_t status;
+    uint32_t Address;
+    //uint32_t temp;
+
+    status = 0;
+    Address = 0;
+
+    do
+    {
+        down_read(&current->mm->mmap_sem);
+        result = get_user_pages(current,
+                current->mm,
+                Memory << PAGE_SHIFT,
+                pageCount,
+                1,
+                0,
+                pages,
+                NULL
+                );
+        up_read(&current->mm->mmap_sem);
+
+        #if 0
+        if(result <= 0 || result < pageCount)
+        {
+            status = 0;
+
+            for(i=0; i<pageCount; i++)
+            {
+                temp = armv7_va_to_pa((Memory + i) << PAGE_SHIFT);
+                if (temp == 0xffffffff)
+                {
+                    printk("rga find mmu phy ddr error\n ");
+                    status = RGA_OUT_OF_RESOURCES;
+                    break;
+                }
+
+                pageTable[i] = temp;
+            }
+
+            return status;
+        }
+        #else
+        if(result <= 0 || result < pageCount)
+        {
+            struct vm_area_struct *vma;
+
+            for(i=0; i<pageCount; i++)
+            {
+                vma = find_vma(current->mm, (Memory + i) << PAGE_SHIFT);
+
+                if (vma)//&& (vma->vm_flags & VM_PFNMAP) )
+                {
+                    #if 1
+                    do
+                    {
+                        pte_t       * pte;
+                        spinlock_t  * ptl;
+                        unsigned long pfn;
+                        pgd_t * pgd;
+                        pud_t * pud;
+
+                        pgd = pgd_offset(current->mm, (Memory + i) << PAGE_SHIFT);
+
+                        if(pgd_val(*pgd) == 0)
+                        {
+                            //printk("rga pgd value is zero \n");
+                            break;
+                        }
+
+                        pud = pud_offset(pgd, (Memory + i) << PAGE_SHIFT);
+                        if (pud)
+                        {
+                            pmd_t * pmd = pmd_offset(pud, (Memory + i) << PAGE_SHIFT);
+                            if (pmd)
+                            {
+                                pte = pte_offset_map_lock(current->mm, pmd, (Memory + i) << PAGE_SHIFT, &ptl);
+                                if (!pte)
+                                {
+                                    pte_unmap_unlock(pte, ptl);
+                                    break;
+                                }
+                            }
+                            else
+                            {
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            break;
+                        }
+
+                        pfn = pte_pfn(*pte);
+                        Address = ((pfn << PAGE_SHIFT) | (((unsigned long)((Memory + i) << PAGE_SHIFT)) & ~PAGE_MASK));
+                        pte_unmap_unlock(pte, ptl);
+                    }
+                    while (0);
+
+                    #else
+                    do
+                    {
+                        pte_t       * pte;
+                        spinlock_t  * ptl;
+                        unsigned long pfn;
+                        pgd_t * pgd;
+                        pud_t * pud;
+                        pmd_t * pmd;
+
+                        pgd = pgd_offset(current->mm, (Memory + i) << PAGE_SHIFT);
+                        pud = pud_offset(pgd, (Memory + i) << PAGE_SHIFT);
+                        pmd = pmd_offset(pud, (Memory + i) << PAGE_SHIFT);
+                        pte = pte_offset_map_lock(current->mm, pmd, (Memory + i) << PAGE_SHIFT, &ptl);
+
+                        pfn = pte_pfn(*pte);
+                        Address = ((pfn << PAGE_SHIFT) | (((unsigned long)((Memory + i) << PAGE_SHIFT)) & ~PAGE_MASK));
+                        pte_unmap_unlock(pte, ptl);
+                    }
+                    while (0);
+                    #endif
+
+                    pageTable[i] = Address;
+                }
+                else
+                {
+                    status = RGA2_OUT_OF_RESOURCES;
+                    break;
+                }
+            }
+
+            return status;
+        }
+        #endif
+
+        /* Fill the page table. */
+        for(i=0; i<pageCount; i++)
+        {
+            /* Get the physical address from page struct. */
+            pageTable[i] = page_to_phys(pages[i]);
+        }
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+static int rga2_mmu_info_BitBlt_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int Src0MemSize, DstMemSize, Src1MemSize;
+    uint32_t Src0Start, Src1Start, DstStart;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret;
+    int status;
+    uint32_t uv_size, v_size;
+
+    struct page **pages = NULL;
+
+    MMU_Base = NULL;
+
+    Src0MemSize = 0;
+    Src1MemSize = 0;
+    DstMemSize  = 0;
+
+    do
+    {
+        /* cal src0 buf mmu info */
+        if(req->mmu_info.src0_mmu_flag & 1) {
+            Src0MemSize = rga2_buf_size_cal(req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr,
+                                        req->src.format, req->src.vir_w,
+                                        (req->src.vir_h),
+                                        &Src0Start);
+            if (Src0MemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        /* cal src1 buf mmu info */
+        if(req->mmu_info.src1_mmu_flag & 1) {
+            Src1MemSize = rga2_buf_size_cal(req->src1.yrgb_addr, req->src1.uv_addr, req->src1.v_addr,
+                                        req->src1.format, req->src1.vir_w,
+                                        (req->src1.vir_h),
+                                        &Src1Start);
+            Src0MemSize = (Src0MemSize + 3) & (~3);
+            if (Src1MemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+
+        /* cal dst buf mmu info */
+        if(req->mmu_info.dst_mmu_flag & 1) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                            req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                            &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        /* Cal out the needed mem size */
+        AllSize = ((Src0MemSize+3)&(~3)) + ((Src1MemSize+3)&(~3)) + ((DstMemSize+3)&(~3));
+
+        pages = kzalloc((AllSize)* sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+            pr_err("RGA2 Get MMU mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if(Src0MemSize) {
+            ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0], Src0Start, Src0MemSize);
+            if (ret < 0) {
+                pr_err("rga2 map src0 memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((uint32_t)MMU_Base_phys));
+            uv_size = (req->src.uv_addr - (Src0Start << PAGE_SHIFT)) >> PAGE_SHIFT;
+            v_size = (req->src.v_addr - (Src0Start << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+            req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+            req->src.uv_addr = (req->src.uv_addr & (~PAGE_MASK)) | (uv_size << PAGE_SHIFT);
+            req->src.v_addr = (req->src.v_addr & (~PAGE_MASK)) | (v_size << PAGE_SHIFT);
+        }
+
+        Src0MemSize = (Src0MemSize + 3) & (~3);
+
+        if(Src1MemSize) {
+            ret = rga2_MapUserMemory(&pages[0], MMU_Base + Src0MemSize, Src1Start, Src1MemSize);
+            if (ret < 0) {
+                pr_err("rga2 map src1 memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src1_base_addr = ((uint32_t)(MMU_Base_phys + Src0MemSize));
+            req->src1.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (Src1MemSize << PAGE_SHIFT);
+        }
+
+        Src1MemSize = (Src1MemSize + 3) & (~3);
+
+        if(DstMemSize) {
+            ret = rga2_MapUserMemory(&pages[0], MMU_Base + Src0MemSize + Src1MemSize, DstStart, DstMemSize);
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.dst_base_addr  = ((uint32_t)(MMU_Base_phys + Src0MemSize + Src1MemSize));
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK)) | ((Src0MemSize + Src1MemSize) << PAGE_SHIFT);
+            uv_size = (req->dst.uv_addr - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+            v_size = (req->dst.v_addr - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+            req->dst.uv_addr = (req->dst.uv_addr & (~PAGE_MASK)) | ((Src0MemSize + Src1MemSize + uv_size) << PAGE_SHIFT);
+            req->dst.v_addr = (req->dst.v_addr & (~PAGE_MASK)) | ((Src0MemSize + Src1MemSize + v_size) << PAGE_SHIFT);
+        }
+
+        /* flush data to DDR */
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize));
+
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+        reg->MMU_len = AllSize;
+
+        status = 0;
+
+        /* Free the page table */
+        if (pages != NULL) {
+            kfree(pages);
+        }
+
+        return status;
+    }
+    while(0);
+
+
+    /* Free the page table */
+    if (pages != NULL) {
+        kfree(pages);
+    }
+
+    /* Free MMU table */
+    if(MMU_Base != NULL) {
+        kfree(MMU_Base);
+    }
+
+    return status;
+}
+
+static int rga2_mmu_info_color_palette_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, DstMemSize, CMDMemSize;
+    uint32_t SrcStart, DstStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base = NULL;
+    uint32_t *MMU_p;
+    int ret, status;
+    uint32_t stride;
+
+    uint8_t shift;
+    uint16_t sw, byte_num;
+
+    shift = 3 - (req->palette_mode & 3);
+    sw = req->src.vir_w;
+    byte_num = sw >> shift;
+    stride = (byte_num + 3) & (~3);
+
+    do
+    {
+
+        SrcMemSize = rga2_mem_size_cal(req->src.yrgb_addr, stride, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+        if(DstMemSize == 0) {
+            return -EINVAL;
+        }
+
+        CMDMemSize = rga2_mem_size_cal((uint32_t)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + DstMemSize + CMDMemSize;
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            return -EINVAL;
+        }
+
+        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
+        if(MMU_Base == NULL) {
+            pr_err("RGA MMU malloc MMU_Base point failed\n");
+            break;
+        }
+
+        /* map CMD addr */
+        for(i=0; i<CMDMemSize; i++)
+        {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i)<<PAGE_SHIFT));
+        }
+
+        /* map src addr */
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga2_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0)
+            {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* map dst addr */
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga2_MapUserMemory(&pages[CMDMemSize + SrcMemSize], &MMU_Base[CMDMemSize + SrcMemSize], DstStart, DstMemSize);
+            if (ret < 0)
+            {
+                pr_err("rga map dst memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize + SrcMemSize;
+
+            for(i=0; i<DstMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((DstStart + i) << PAGE_SHIFT));
+            }
+        }
+
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base)>>2);
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+        req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK)) | ((CMDMemSize + SrcMemSize) << PAGE_SHIFT);
+
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize + 1));
+
+        /* Free the page table */
+        if (pages != NULL) {
+            kfree(pages);
+        }
+
+        return status;
+
+    }
+    while(0);
+
+    /* Free the page table */
+    if (pages != NULL) {
+        kfree(pages);
+    }
+
+    /* Free mmu table */
+    if (MMU_Base != NULL) {
+        kfree(MMU_Base);
+    }
+
+    return 0;
+}
+
+static int rga2_mmu_info_color_fill_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int DstMemSize;
+    uint32_t DstStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret;
+    int status;
+
+    MMU_Base = NULL;
+
+    do
+    {
+        if(req->mmu_info.dst_mmu_flag & 1) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        AllSize = (DstMemSize + 3) & (~3);
+
+        pages = kzalloc((AllSize)* sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA2 MMU malloc pages mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        if(rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+           pr_err("RGA2 Get MMU mem failed\n");
+           status = RGA2_MALLOC_ERROR;
+           break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if (DstMemSize)
+        {
+            ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0], DstStart, DstMemSize);
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((uint32_t)MMU_Base_phys)>>4);
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize + 1));
+
+        rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize);
+
+        /* Free the page table */
+        if (pages != NULL)
+            kfree(pages);
+
+        return 0;
+    }
+    while(0);
+
+    if (pages != NULL)
+        kfree(pages);
+
+    if (MMU_Base != NULL)
+        kfree(MMU_Base);
+
+    return status;
+}
+
+
+static int rga2_mmu_info_update_palette_table_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    uint32_t SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = NULL;
+
+    do
+    {
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->src.yrgb_addr, req->src.vir_w * req->src.vir_h, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga2_mem_size_cal((uint32_t)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        MMU_Base = kzalloc((AllSize + 1)* sizeof(uint32_t), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc MMU_Base point failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga2_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                return -EINVAL;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+                for(i=0; i<SrcMemSize; i++)
+                {
+                    MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+                }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize));
+
+        if (pages != NULL) {
+            /* Free the page table */
+            kfree(pages);
+        }
+
+        return 0;
+    }
+    while(0);
+
+    if (pages != NULL)
+        kfree(pages);
+
+    if (MMU_Base != NULL)
+        kfree(MMU_Base);
+
+    return status;
+}
+
+static int rga2_mmu_info_update_patten_buff_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    uint32_t SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = MMU_p = 0;
+
+    do
+    {
+
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.act_w * req->pat.act_h * 4, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga2_mem_size_cal((uint32_t)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc MMU_Base point failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga2_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize));
+
+        if (pages != NULL) {
+            /* Free the page table */
+            kfree(pages);
+        }
+
+        return 0;
+
+    }
+    while(0);
+
+    if (pages != NULL)
+        kfree(pages);
+
+    if (MMU_Base != NULL)
+        kfree(MMU_Base);
+
+    return status;
+}
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int ret;
+
+    switch (req->render_mode) {
+        case bitblt_mode :
+            ret = rga2_mmu_info_BitBlt_mode(reg, req);
+            break;
+        case color_palette_mode :
+            ret = rga2_mmu_info_color_palette_mode(reg, req);
+            break;
+        case color_fill_mode :
+            ret = rga2_mmu_info_color_fill_mode(reg, req);
+            break;
+        case update_palette_table_mode :
+            ret = rga2_mmu_info_update_palette_table_mode(reg, req);
+            break;
+        case update_patten_buff_mode :
+            ret = rga2_mmu_info_update_patten_buff_mode(reg, req);
+            break;
+        default :
+            ret = -1;
+            break;
+    }
+
+    return ret;
+}
+
diff --git a/drivers/video/rockchip/rga2/rga2_mmu_info.h b/drivers/video/rockchip/rga2/rga2_mmu_info.h
new file mode 100644
index 000000000000..79b8c2a73f2b
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.h
@@ -0,0 +1,20 @@
+#ifndef __RGA_MMU_INFO_H__
+#define __RGA_MMU_INFO_H__
+
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req);
+
+
+#endif
+
+
diff --git a/drivers/video/rockchip/rga2/rga2_reg_info.c b/drivers/video/rockchip/rga2/rga2_reg_info.c
new file mode 100644
index 000000000000..bc38091e9a4e
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.c
@@ -0,0 +1,1145 @@
+
+//#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <mach/io.h>
+#include <mach/irqs.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+
+#include "rga2_reg_info.h"
+#include "rga2_rop.h"
+#include "rga2.h"
+
+
+void
+RGA2_reg_get_param(unsigned char *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_X_FACTOR;
+    RK_U32 *bRGA_SRC_Y_FACTOR;
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U32 param_x, param_y;
+    RK_U8 x_flag, y_flag;
+
+    RK_U32 reg;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    reg = *bRGA_SRC_INFO;
+
+    bRGA_SRC_X_FACTOR = (RK_U32 *)(base + RGA2_SRC_X_FACTOR_OFFSET);
+    bRGA_SRC_Y_FACTOR = (RK_U32 *)(base + RGA2_SRC_Y_FACTOR_OFFSET);
+
+    x_flag = y_flag = 0;
+
+    if(((msg->rotate_mode & 0x3) == 1) || ((msg->rotate_mode & 0x3) == 3))
+    {
+        dw = msg->dst.act_h;
+        dh = msg->dst.act_w;
+    }
+    else
+    {
+        dw = msg->dst.act_w;
+        dh = msg->dst.act_h;
+    }
+
+    sw = msg->src.act_w;
+    sh = msg->src.act_h;
+
+    if (sw > dw)
+    {
+        x_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_x = ((dw) << 16) / (sw);
+		#else
+        param_x = ((dw) << 16) / (sw);
+        #endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 0 );
+    }
+    else if (sw < dw)
+    {
+        x_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_x = ((sw - 1) << 16) / (dw - 1);
+        #else
+        param_x = ((sw) << 16) / (dw);
+		#endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_X_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    if (sh > dh)
+    {
+        y_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_y = ((dh) << 16) / (sh);
+		#else
+        param_y = ((dh) << 16) / (sh);
+        #endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 0 );
+    }
+    else if (sh < dh)
+    {
+        y_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_y = ((sh - 1) << 16) / (dh - 1);
+        #else
+        param_y = ((sh) << 16) / (dh);
+		#endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_Y_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x_flag)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(y_flag)));
+}
+
+void
+RGA2_set_mode_ctrl(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MODE_CTL;
+    RK_U32 reg = 0;
+    RK_U32 render_mode = msg->render_mode;
+
+    bRGA_MODE_CTL = (u32 *)(base + RGA2_MODE_CTRL_OFFSET);
+
+    if(msg->render_mode == 4)
+    {
+        render_mode = 3;
+    }
+
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_RENDER_MODE)) | (s_RGA2_MODE_CTRL_SW_RENDER_MODE(render_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_BITBLT_MODE)) | (s_RGA2_MODE_CTRL_SW_BITBLT_MODE(msg->bitblt_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT)) | (s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(msg->color_fill_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET)) | (s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(msg->alpha_zero_key)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_GRADIENT_SAT)) | (s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(msg->alpha_rop_flag >> 7)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_INTR_CF_E)) | (s_RGA2_MODE_CTRL_SW_INTR_CF_E(msg->CMD_fin_int_enable)));
+
+    *bRGA_MODE_CTL = reg;
+}
+
+void
+RGA2_set_reg_src_info(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_BASE1, *bRGA_SRC_BASE2;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+    RK_U32 *bRGA_SRC_ACT_INFO;
+    RK_U32 *bRGA_MASK_ADDR;
+	RK_U32 *bRGA_SRC_TR_COLOR0, *bRGA_SRC_TR_COLOR1;
+
+    RK_U32 reg = 0;
+    RK_U8 src0_format = 0;
+
+    RK_U8 src0_rb_swp = 0;
+    RK_U8 src0_rgb_pack = 0;
+
+    RK_U8 src0_cbcr_swp = 0;
+    RK_U8 pixel_width = 1;
+    RK_U32 stride = 0;
+    RK_U32 uv_stride = 0;
+    RK_U32 mask_stride = 0;
+    RK_U32 ydiv = 1, xdiv = 2;
+
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U8 rotate_mode;
+    RK_U8 scale_w_flag, scale_h_flag;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+    bRGA_SRC_BASE1 = (RK_U32 *)(base + RGA2_SRC_BASE1_OFFSET);
+    bRGA_SRC_BASE2 = (RK_U32 *)(base + RGA2_SRC_BASE2_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+
+    bRGA_SRC_TR_COLOR0 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR0_OFFSET);
+    bRGA_SRC_TR_COLOR1 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR1_OFFSET);
+
+    {
+        rotate_mode = msg->rotate_mode & 0x3;
+
+        sw = msg->src.act_w;
+        sh = msg->src.act_h;
+
+        if((rotate_mode == 1) | (rotate_mode == 3))
+        {
+            dw = msg->dst.act_h;
+            dh = msg->dst.act_w;
+        }
+        else
+        {
+            dw = msg->dst.act_w;
+            dh = msg->dst.act_h;
+        }
+
+        if(sw > dw)
+            scale_w_flag = 1;
+        else if (sw < dw)
+            scale_w_flag = 2;
+        else {
+            scale_w_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_w_flag = 3;
+        }
+
+        if(sh > dh)
+            scale_h_flag = 1;
+        else if (sh < dh)
+            scale_h_flag = 2;
+        else
+        {
+            scale_h_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_h_flag = 3;
+        }
+    }
+
+    switch (msg->src.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src0_format = 0x0; pixel_width = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src0_format = 0x0; src0_rb_swp = 0x1; pixel_width = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src0_format = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRX_8888    : src0_format = 0x1; src0_rb_swp = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_888      : src0_format = 0x2; src0_rgb_pack = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGR_888      : src0_format = 0x2; src0_rgb_pack = 1; src0_rb_swp = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src0_format = 0x5; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src0_format = 0x6; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRA_5551    : src0_format = 0x5; pixel_width = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src0_format = 0x6; pixel_width = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; src0_cbcr_swp = 1; break;
+    };
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT(src0_format)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(src0_rb_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(msg->alpha_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(src0_cbcr_swp)));
+    if(msg->src.format <= RGA2_FORMAT_BGRA_4444)
+    	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+    else
+        if(msg->dst.format >= RGA2_FORMAT_YCbCr_422_SP)
+            reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+        else
+    	    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(msg->yuv2rgb_mode)));
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(msg->rotate_mode & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE((msg->rotate_mode >> 4) & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE((scale_w_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE((scale_h_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER)) | (s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER((msg->scale_bicu_mode))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(msg->src_trans_mode)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(msg->src_trans_mode >> 1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E((msg->alpha_rop_flag >> 4) & 0x1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL)) | (s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL((msg->scale_bicu_mode>>4))));
+    RGA2_reg_get_param(base, msg);
+
+    stride = (((msg->src.vir_w * pixel_width) + 3) & ~3) >> 2;
+
+    uv_stride = ((msg->src.vir_w / xdiv + 3) & ~3);
+
+    *bRGA_SRC_BASE0 = (RK_U32)(msg->src.yrgb_addr + msg->src.y_offset * (stride<<2) + msg->src.x_offset * pixel_width);
+    *bRGA_SRC_BASE1 = (RK_U32)(msg->src.uv_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+    *bRGA_SRC_BASE2 = (RK_U32)(msg->src.v_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+
+    //mask_stride = ((msg->src0_act.width + 31) & ~31) >> 5;
+    mask_stride = msg->rop_mask_stride;
+
+    *bRGA_SRC_VIR_INFO = stride | (mask_stride << 16);
+
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+
+    *bRGA_SRC_INFO = reg;
+
+	*bRGA_SRC_TR_COLOR0 = msg->color_key_min;
+    *bRGA_SRC_TR_COLOR1 = msg->color_key_max;
+}
+
+
+void
+RGA2_set_reg_dst_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_DST_INFO;
+    RK_U32 *bRGA_DST_BASE0, *bRGA_DST_BASE1, *bRGA_DST_BASE2, *bRGA_SRC_BASE3;
+    RK_U32 *bRGA_DST_VIR_INFO;
+    RK_U32 *bRGA_DST_ACT_INFO;
+
+    RK_U8 src1_format = 0;
+    RK_U8 src1_rb_swp = 0;
+    RK_U8 src1_rgb_pack = 0;
+    RK_U8 dst_format = 0;
+    RK_U8 dst_rb_swp = 0;
+    RK_U8 dst_rgb_pack = 0;
+    RK_U8 dst_cbcr_swp = 0;
+    RK_U32 reg = 0;
+    RK_U8 spw, dpw;
+    RK_U32 s_stride, d_stride;
+    RK_U32 x_mirr, y_mirr, rot_90_flag;
+    RK_U32 yrgb_addr, u_addr, v_addr, s_yrgb_addr;
+    RK_U32 d_uv_stride, x_div, y_div;
+    RK_U32 y_lt_addr, y_ld_addr, y_rt_addr, y_rd_addr;
+    RK_U32 u_lt_addr, u_ld_addr, u_rt_addr, u_rd_addr;
+    RK_U32 v_lt_addr, v_ld_addr, v_rt_addr, v_rd_addr;
+
+    RK_U32 s_y_lt_addr, s_y_ld_addr, s_y_rt_addr, s_y_rd_addr;
+
+    dpw = 1;
+    x_div = y_div = 1;
+
+    bRGA_DST_INFO = (RK_U32 *)(base + RGA2_DST_INFO_OFFSET);
+    bRGA_DST_BASE0 = (RK_U32 *)(base + RGA2_DST_BASE0_OFFSET);
+    bRGA_DST_BASE1 = (RK_U32 *)(base + RGA2_DST_BASE1_OFFSET);
+    bRGA_DST_BASE2 = (RK_U32 *)(base + RGA2_DST_BASE2_OFFSET);
+
+    bRGA_SRC_BASE3 = (RK_U32 *)(base + RGA2_SRC_BASE3_OFFSET);
+
+    bRGA_DST_VIR_INFO = (RK_U32 *)(base + RGA2_DST_VIR_INFO_OFFSET);
+    bRGA_DST_ACT_INFO = (RK_U32 *)(base + RGA2_DST_ACT_INFO_OFFSET);
+
+    switch (msg->src1.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src1_format = 0x0; spw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src1_format = 0x0; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src1_format = 0x1; spw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : src1_format = 0x1; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGB_888      : src1_format = 0x2; src1_rgb_pack = 1; spw = 3; break;
+        case RGA2_FORMAT_BGR_888      : src1_format = 0x2; src1_rgb_pack = 1; src1_rb_swp = 1; spw = 3; break;
+        case RGA2_FORMAT_RGB_565      : src1_format = 0x4; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src1_format = 0x5; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src1_format = 0x6; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src1_format = 0x4; spw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : src1_format = 0x5; spw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src1_format = 0x6; spw = 2; break;
+        default                       : spw = 4; break;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_FMT)) | (s_RGA2_DST_INFO_SW_SRC1_FMT(src1_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_RB_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_RB_SWP(src1_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(msg->alpha_swp >> 1)));
+
+
+    switch (msg->dst.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : dst_format = 0x0; dpw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : dst_format = 0x0; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : dst_format = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : dst_format = 0x1; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGB_888      : dst_format = 0x2; dst_rgb_pack = 1; dpw = 3; break;
+        case RGA2_FORMAT_BGR_888      : dst_format = 0x2; dst_rgb_pack = 1; dst_rb_swp = 1; dpw = 3; break;
+        case RGA2_FORMAT_RGB_565      : dst_format = 0x4; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : dst_format = 0x5; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : dst_format = 0x6; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : dst_format = 0x4; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : dst_format = 0x5; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : dst_format = 0x6; dpw = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : dst_format = 0x8; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : dst_format = 0x9; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : dst_format = 0xa; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : dst_format = 0xb; x_div = 2; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : dst_format = 0x8; dst_cbcr_swp = 1; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : dst_format = 0x9; dst_cbcr_swp = 1; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : dst_format = 0xa; dst_cbcr_swp = 1; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_420_P  : dst_format = 0xb; dst_cbcr_swp = 1; x_div = 2; y_div = 2; break;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_FMT)) | (s_RGA2_DST_INFO_SW_DST_FMT(dst_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_RB_SWAP)) | (s_RGA2_DST_INFO_SW_DST_RB_SWAP(dst_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_ALPHA_SWAP)) | (s_RGA2_DST_INFO_SW_ALPHA_SWAP(msg->alpha_swp >> 2)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_UV_SWAP)) | (s_RGA2_DST_INFO_SW_DST_UV_SWAP(dst_cbcr_swp)));
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_UP_E)) | (s_RGA2_DST_INFO_SW_DITHER_UP_E(msg->alpha_rop_flag >> 5)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_DOWN_E)) | (s_RGA2_DST_INFO_SW_DITHER_DOWN_E(msg->alpha_rop_flag >> 6)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_MODE)) | (s_RGA2_DST_INFO_SW_DITHER_MODE(msg->dither_mode)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_CSC_MODE)) | (s_RGA2_DST_INFO_SW_DST_CSC_MODE(msg->yuv2rgb_mode >> 4)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_CSC_CLIP_MODE)) | (s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(msg->yuv2rgb_mode >> 6)));
+
+
+    *bRGA_DST_INFO = reg;
+
+    s_stride = ((msg->src1.vir_w * spw + 3) & ~3) >> 2;
+    d_stride = ((msg->dst.vir_w * dpw + 3) & ~3) >> 2;
+    d_uv_stride = (d_stride << 2) / x_div;
+
+    *bRGA_DST_VIR_INFO = d_stride | (s_stride << 16);
+    *bRGA_DST_ACT_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
+    s_stride <<= 2;
+	d_stride <<= 2;
+
+    if(((msg->rotate_mode & 0xf) == 0) || ((msg->rotate_mode & 0xf) == 1))
+    {
+        x_mirr = 0;
+        y_mirr = 0;
+    }
+    else
+    {
+        x_mirr = 1;
+        y_mirr = 1;
+    }
+
+    rot_90_flag = msg->rotate_mode & 1;
+    x_mirr = (x_mirr + ((msg->rotate_mode >> 4) & 1)) & 1;
+    y_mirr = (y_mirr + ((msg->rotate_mode >> 5) & 1)) & 1;
+
+    yrgb_addr = (RK_U32)msg->src1.yrgb_addr + (msg->src1.y_offset * s_stride) + (msg->src1.x_offset * spw);
+
+    s_y_lt_addr = yrgb_addr;
+    s_y_ld_addr = yrgb_addr + (msg->src1.act_h - 1) * s_stride;
+    s_y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * spw;
+    s_y_rd_addr = s_y_ld_addr + (msg->dst.act_w - 1) * spw;
+
+    yrgb_addr = (RK_U32)msg->dst.yrgb_addr + (msg->dst.y_offset * d_stride) + (msg->dst.x_offset * dpw);
+    u_addr = (RK_U32)msg->dst.uv_addr + msg->dst.y_offset * d_uv_stride + msg->dst.x_offset / x_div;
+    v_addr = (RK_U32)msg->dst.v_addr + msg->dst.y_offset * d_uv_stride + msg->dst.x_offset / x_div;
+
+    y_lt_addr = yrgb_addr;
+    u_lt_addr = u_addr;
+    v_lt_addr = v_addr;
+
+    y_ld_addr = yrgb_addr + (msg->dst.act_h - 1) * (d_stride);
+    u_ld_addr = u_addr + ((msg->dst.act_h / y_div) - 1) * (d_uv_stride);
+    v_ld_addr = v_addr + ((msg->dst.act_h / y_div) - 1) * (d_uv_stride);
+
+    y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * dpw;
+    u_rt_addr = u_addr + (msg->dst.act_w / x_div) - 1;
+    v_rt_addr = v_addr + (msg->dst.act_w / x_div) - 1;
+
+    y_rd_addr = y_ld_addr + (msg->dst.act_w - 1) * dpw;
+    u_rd_addr = u_ld_addr + (msg->dst.act_w / x_div) - 1;
+    v_rd_addr = v_ld_addr + (msg->dst.act_w / x_div) - 1;
+
+    if(rot_90_flag == 0)
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+            else
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+        }
+    }
+    else
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+        }
+    }
+
+    *bRGA_DST_BASE0 = (RK_U32)yrgb_addr;
+    *bRGA_DST_BASE1 = (RK_U32)u_addr;
+    *bRGA_DST_BASE2 = (RK_U32)v_addr;
+    *bRGA_SRC_BASE3 = (RK_U32)s_y_lt_addr;
+}
+
+void
+RGA2_set_reg_alpha_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ALPHA_CTRL1;
+    RK_U32 *bRGA_FADING_CTRL;
+    RK_U32 reg0 = 0;
+    RK_U32 reg1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ALPHA_CTRL1 = (RK_U32 *)(base + RGA2_ALPHA_CTRL1_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(msg->alpha_rop_flag)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(msg->alpha_rop_flag >> 1)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ROP_MODE)) | (s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(msg->rop_mode)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(msg->src_a_global_val)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(msg->dst_a_global_val)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(msg->alpha_mode_0 >> 15)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(msg->alpha_mode_0 >> 7)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(msg->alpha_mode_0 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(msg->alpha_mode_0 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(msg->alpha_mode_0 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(msg->alpha_mode_0 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(msg->alpha_mode_0 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(msg->alpha_mode_0 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(msg->alpha_mode_0 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(msg->alpha_mode_0 >> 0)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(msg->alpha_mode_1 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(msg->alpha_mode_1 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(msg->alpha_mode_1 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(msg->alpha_mode_1 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(msg->alpha_mode_1 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(msg->alpha_mode_1 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(msg->alpha_mode_1 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(msg->alpha_mode_1 >> 0)));
+
+    *bRGA_ALPHA_CTRL0 = reg0;
+    *bRGA_ALPHA_CTRL1 = reg1;
+
+    if((msg->alpha_rop_flag>>2)&1)
+    {
+        *bRGA_FADING_CTRL = (1<<24) | (msg->fading_b_value<<16) | (msg->fading_g_value<<8) | (msg->fading_r_value);
+    }
+}
+
+void
+RGA2_set_reg_rop_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL1;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_FG_COLOR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 rop_code0 = 0;
+    RK_U32 rop_code1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ROP_CTRL0 = (RK_U32 *)(base + RGA2_ROP_CTRL0_OFFSET);
+    bRGA_ROP_CTRL1 = (RK_U32 *)(base + RGA2_ROP_CTRL1_OFFSET);
+	bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FG_COLOR  = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_PAT_CON   = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    if(msg->rop_mode == 0) {
+        rop_code0 =  ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(msg->rop_mode == 1) {
+        rop_code0 =  ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(msg->rop_mode == 2) {
+        rop_code0 =  ROP3_code[(msg->rop_code & 0xff)];
+        rop_code1 =  ROP3_code[(msg->rop_code & 0xff00)>>8];
+    }
+
+    *bRGA_ROP_CTRL0 = rop_code0;
+    *bRGA_ROP_CTRL1 = rop_code1;
+    *bRGA_FG_COLOR = msg->fg_color;
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+    *bRGA_PAT_CON = (msg->pat.act_w-1) | ((msg->pat.act_h-1) << 8)
+                     | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    *bRGA_ALPHA_CTRL0 = *bRGA_ALPHA_CTRL0 | (((msg->endian_mode >> 1) & 1) << 20);
+
+}
+
+
+
+void
+RGA2_set_reg_color_palette(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_INFO, *bRGA_SRC_VIR_INFO, *bRGA_SRC_ACT_INFO, *bRGA_SRC_FG_COLOR, *bRGA_SRC_BG_COLOR;
+    RK_U32  *p;
+    RK_S16  x_off, y_off;
+    RK_U16  src_stride;
+    RK_U8   shift;
+    RK_U32  sw;
+    RK_U32  byte_num;
+    RK_U32 reg;
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+	bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_SRC_BG_COLOR = (RK_U32 *)(base + RGA2_SRC_BG_COLOR_OFFSET);
+
+    reg = 0;
+
+    shift = 3 - msg->palette_mode;
+
+    x_off = msg->src.x_offset;
+    y_off = msg->src.y_offset;
+
+    sw = msg->src.vir_w;
+    byte_num = sw >> shift;
+
+    src_stride = (byte_num + 3) & (~3);
+
+    p = (RK_U32 *)msg->src.yrgb_addr;
+
+    #if 0
+    if(endian_mode)
+    {
+        p = p + (x_off>>shift) + y_off*src_stride;
+    }
+    else
+    {
+        p = p + (((x_off>>shift)>>2)<<2) + (3 - ((x_off>>shift) & 3)) + y_off*src_stride;
+    }
+    #endif
+
+    p = p + (x_off>>shift) + y_off*src_stride;
+
+
+    *bRGA_SRC_BASE0 = (RK_U32)p;
+
+	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT((msg->palette_mode | 0xc))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN)) | (s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(msg->endian_mode & 1)));
+    *bRGA_SRC_VIR_INFO = src_stride >> 2;
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+    *bRGA_SRC_INFO = reg;
+
+    *bRGA_SRC_FG_COLOR = msg->fg_color;
+    *bRGA_SRC_BG_COLOR = msg->bg_color;
+
+}
+
+void
+RGA2_set_reg_color_fill(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_CF_GR_A;
+    RK_U32 *bRGA_CF_GR_B;
+    RK_U32 *bRGA_CF_GR_G;
+    RK_U32 *bRGA_CF_GR_R;
+    RK_U32 *bRGA_SRC_FG_COLOR;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 mask_stride;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+
+    bRGA_CF_GR_A = (RK_U32 *)(base + RGA2_CF_GR_A_OFFSET);
+    bRGA_CF_GR_B = (RK_U32 *)(base + RGA2_CF_GR_B_OFFSET);
+    bRGA_CF_GR_G = (RK_U32 *)(base + RGA2_CF_GR_G_OFFSET);
+    bRGA_CF_GR_R = (RK_U32 *)(base + RGA2_CF_GR_R_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+
+    mask_stride = msg->rop_mask_stride;
+
+    if(msg->color_fill_mode == 0)
+    {
+        /* solid color */
+        *bRGA_CF_GR_A = (msg->gr_color.gr_x_a & 0xffff) | (msg->gr_color.gr_y_a << 16);
+        *bRGA_CF_GR_B = (msg->gr_color.gr_x_b & 0xffff) | (msg->gr_color.gr_y_b << 16);
+        *bRGA_CF_GR_G = (msg->gr_color.gr_x_g & 0xffff) | (msg->gr_color.gr_y_g << 16);
+        *bRGA_CF_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
+
+        *bRGA_SRC_FG_COLOR = msg->fg_color;
+    }
+    else
+    {
+        /* patten color */
+        *bRGA_MASK_ADDR = (RK_U32)msg->pat.yrgb_addr;
+        *bRGA_PAT_CON = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8)
+                       | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    }
+	*bRGA_SRC_VIR_INFO = mask_stride << 16;
+}
+
+
+void
+RGA2_set_reg_update_palette_table(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MASK_BASE;
+    RK_U32 *bRGA_FADING_CTRL;
+
+    bRGA_MASK_BASE  = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_FADING_CTRL = msg->fading_g_value << 8;
+   // *bRGA_MASK_BASE = (RK_U32)msg->LUT_addr;
+    *bRGA_MASK_BASE = (RK_U32)msg->pat.yrgb_addr;
+}
+
+
+void
+RGA2_set_reg_update_patten_buff(RK_U8 *base, struct rga2_req *msg)
+{
+    u32 *bRGA_PAT_MST;
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_PAT_START_POINT;
+    RK_U32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = (pat->act_w * pat->act_h) - 1;
+
+    offset = pat->act_w * pat->y_offset + pat->x_offset;
+
+    bRGA_PAT_START_POINT = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+    bRGA_PAT_MST = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_PAT_MST = (RK_U32)msg->pat.yrgb_addr;
+    *bRGA_PAT_START_POINT = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    *bRGA_FADING_CTRL = (num << 8) | offset;
+}
+
+
+void
+RGA2_set_pat_info(RK_U8 *base, struct rga2_req *msg)
+{
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = ((pat->act_w * pat->act_h) - 1) & 0xff;
+
+    offset = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    bRGA_PAT_CON     = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    *bRGA_FADING_CTRL = (num << 8) | offset;  //???pat_addr???
+}
+
+
+void
+RGA2_set_mmu_info(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MMU_CTRL1;
+    RK_U32 *bRGA_MMU_SRC_BASE;
+    RK_U32 *bRGA_MMU_SRC1_BASE;
+    RK_U32 *bRGA_MMU_DST_BASE;
+    RK_U32 *bRGA_MMU_ELS_BASE;
+
+    RK_U32 reg;
+
+    bRGA_MMU_CTRL1 = (RK_U32 *)(base + RGA2_MMU_CTRL1_OFFSET);
+    bRGA_MMU_SRC_BASE = (RK_U32 *)(base + RGA2_MMU_SRC_BASE_OFFSET);
+    bRGA_MMU_SRC1_BASE = (RK_U32 *)(base + RGA2_MMU_SRC1_BASE_OFFSET);
+    bRGA_MMU_DST_BASE = (RK_U32 *)(base + RGA2_MMU_DST_BASE_OFFSET);
+    bRGA_MMU_ELS_BASE = (RK_U32 *)(base + RGA2_MMU_ELS_BASE_OFFSET);
+
+    reg = (msg->mmu_info.src0_mmu_flag & 0xf) | ((msg->mmu_info.src1_mmu_flag & 0xf) << 4)
+         | ((msg->mmu_info.dst_mmu_flag & 0xf) << 8) | ((msg->mmu_info.els_mmu_flag & 0x3) << 12);
+
+    *bRGA_MMU_CTRL1 = reg;
+    *bRGA_MMU_SRC_BASE  = (RK_U32)(msg->mmu_info.src0_base_addr) >> 4;
+    *bRGA_MMU_SRC1_BASE = (RK_U32)(msg->mmu_info.src1_base_addr) >> 4;
+    *bRGA_MMU_DST_BASE  = (RK_U32)(msg->mmu_info.dst_base_addr)  >> 4;
+    *bRGA_MMU_ELS_BASE  = (RK_U32)(msg->mmu_info.els_base_addr)  >> 4;
+}
+
+
+int
+RGA2_gen_reg_info(RK_U8 *base , struct rga2_req *msg)
+{
+
+    RGA2_set_mode_ctrl(base, msg);
+
+    RGA2_set_pat_info(base, msg);
+
+    switch(msg->render_mode)
+    {
+        case bitblt_mode:
+            RGA2_set_reg_src_info(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            RGA2_set_reg_rop_info(base, msg);
+            break;
+        case color_fill_mode :
+            RGA2_set_reg_color_fill(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            break;
+        case color_palette_mode :
+            RGA2_set_reg_color_palette(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            break;
+        case update_palette_table_mode :
+            RGA2_set_reg_update_palette_table(base, msg);
+            break;
+        case update_patten_buff_mode :
+            RGA2_set_reg_update_patten_buff(base, msg);
+            break;
+        default :
+            printk("RGA2 ERROR msg render mode %d \n", msg->render_mode);
+            break;
+
+    }
+
+    RGA2_set_mmu_info(base, msg);
+
+    return 0;
+
+}
+
+void format_name_convert(uint32_t *df, uint32_t sf)
+{
+    /*
+    RK_FORMAT_RGBA_8888    = 0x0,
+    RK_FORMAT_RGBX_8888    = 0x1,
+    RK_FORMAT_RGB_888      = 0x2,
+    RK_FORMAT_BGRA_8888    = 0x3,
+    RK_FORMAT_RGB_565      = 0x4,
+    RK_FORMAT_RGBA_5551    = 0x5,
+    RK_FORMAT_RGBA_4444    = 0x6,
+    RK_FORMAT_BGR_888      = 0x7,
+
+    RK_FORMAT_YCbCr_422_SP = 0x8,
+    RK_FORMAT_YCbCr_422_P  = 0x9,
+    RK_FORMAT_YCbCr_420_SP = 0xa,
+    RK_FORMAT_YCbCr_420_P  = 0xb,
+
+    RK_FORMAT_YCrCb_422_SP = 0xc,
+    RK_FORMAT_YCrCb_422_P  = 0xd,
+    RK_FORMAT_YCrCb_420_SP = 0xe,
+    RK_FORMAT_YCrCb_420_P  = 0xf,
+
+    RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,*/
+    switch(sf)
+    {
+        case 0x0: *df = RGA2_FORMAT_RGBA_8888; break;
+        case 0x1: *df = RGA2_FORMAT_RGBX_8888; break;
+        case 0x2: *df = RGA2_FORMAT_RGB_888; break;
+        case 0x3: *df = RGA2_FORMAT_BGRA_8888; break;
+        case 0x4: *df = RGA2_FORMAT_RGB_565; break;
+        case 0x5: *df = RGA2_FORMAT_RGBA_5551; break;
+        case 0x6: *df = RGA2_FORMAT_RGBA_4444; break;
+        case 0x7: *df = RGA2_FORMAT_BGR_888; break;
+        case 0x8: *df = RGA2_FORMAT_YCbCr_422_SP; break;
+        case 0x9: *df = RGA2_FORMAT_YCbCr_422_P; break;
+        case 0xa: *df = RGA2_FORMAT_YCbCr_420_SP; break;
+        case 0xb: *df = RGA2_FORMAT_YCbCr_420_P; break;
+        case 0xc: *df = RGA2_FORMAT_YCrCb_422_SP; break;
+        case 0xd: *df = RGA2_FORMAT_YCrCb_422_P; break;
+        case 0xe: *df = RGA2_FORMAT_YCrCb_420_SP; break;
+        case 0xf: *df = RGA2_FORMAT_YCrCb_420_P; break;
+    }
+}
+
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req)
+{
+    u16 alpha_mode_0, alpha_mode_1;
+
+    if (req_rga->render_mode == 6)
+        req->render_mode = update_palette_table_mode;
+    else if (req_rga->render_mode == 7)
+        req->render_mode = update_patten_buff_mode;
+    else if (req_rga->render_mode == 5)
+        req->render_mode = bitblt_mode;
+
+    memcpy(&req->src, &req_rga->src, sizeof(req_rga->src));
+    memcpy(&req->dst, &req_rga->dst, sizeof(req_rga->dst));
+    memcpy(&req->pat, &req_rga->pat, sizeof(req_rga->pat));
+    memcpy(&req->src1,&req_rga->pat, sizeof(req_rga->pat));
+
+    format_name_convert(&req->src.format, req_rga->src.format);
+    format_name_convert(&req->dst.format, req_rga->dst.format);
+
+    if(req_rga->rotate_mode == 1) {
+        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
+            /* rotate 0 */
+            req->rotate_mode = 0;
+        }
+        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
+            /* rotate 90 */
+            req->rotate_mode = 1;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
+            /* rotate 180 */
+            req->rotate_mode = 2;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
+        }
+        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
+            /* totate 270 */
+            req->rotate_mode = 3;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+    }
+    else if (req_rga->rotate_mode == 2)
+    {
+        //x_mirror
+    }
+    else if (req_rga->rotate_mode == 3)
+    {
+        //y_mirror
+    }
+    else {
+        req->rotate_mode = 0;
+    }
+
+    req->LUT_addr = req_rga->LUT_addr;
+    req->rop_mask_addr = req_rga->rop_mask_addr;
+
+    req->bitblt_mode = req_rga->bsfilter_flag;
+
+    req->src_a_global_val = req_rga->alpha_global_value;
+    req->dst_a_global_val = 0;
+    req->rop_code = req_rga->rop_code;
+    req->rop_mode = 0;
+
+    req->color_fill_mode = req_rga->color_fill_mode;
+    req->color_key_min = req_rga->color_key_min;
+    req->color_key_max = req_rga->color_key_max;
+
+    req->fg_color = req_rga->fg_color;
+    req->bg_color = req_rga->bg_color;
+    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
+
+    req->palette_mode = req_rga->palette_mode;
+    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
+    req->endian_mode = req_rga->endian_mode;
+    req->rgb2yuv_mode = 0;
+
+    req->fading_alpha_value = 0;
+    req->fading_r_value = req_rga->fading.r;
+    req->fading_g_value = req_rga->fading.g;
+    req->fading_b_value = req_rga->fading.b;
+
+    /* alpha mode set */
+    req->alpha_rop_flag = 0;
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
+
+    if(((req_rga->alpha_rop_flag) & 1)) {
+        if((req_rga->alpha_rop_flag >> 3) & 1) {
+            /* porter duff alpha enable */
+            switch(req_rga->PD_mode)
+            {
+                case 0: //dst = 0
+                    break;
+                case 1: //dst = src
+                    break;
+                case 2: //dst = dst
+                    break;
+                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
+                    if((req_rga->alpha_rop_mode & 3) == 0) {
+                        alpha_mode_0 = 0x3818;
+                        alpha_mode_1 = 0x3818;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                        alpha_mode_0 = 0x381C;
+                        alpha_mode_1 = 0x381C;
+                    }
+                    else {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    req->alpha_mode_0 = alpha_mode_0;
+                    req->alpha_mode_1 = alpha_mode_1;
+                    break;
+                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
+                    break;
+                case 5: //dst = (da*sc) >> 8
+                    break;
+                case 6: //dst = (sa*dc) >> 8
+                    break;
+                case 7: //dst = ((256-da)*sc) >> 8
+                    break;
+                case 8: //dst = ((256-sa)*dc) >> 8
+                    break;
+                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
+                    req->alpha_mode_0 = 0x3848;
+                    req->alpha_mode_1 = 0x3848;
+                    break;
+                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
+                    break;
+                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
+                    break;
+                default:
+                    break;
+            }
+        }
+        else {
+            if((req_rga->alpha_rop_mode & 3) == 0) {
+                req->alpha_mode_0 = 0x3848;
+                req->alpha_mode_1 = 0x3848;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                req->alpha_mode_0 = 0x384A;
+                req->alpha_mode_1 = 0x384A;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                req->alpha_mode_0 = 0x384C;
+                req->alpha_mode_1 = 0x384C;
+            }
+        }
+    }
+
+    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
+        req->mmu_info.src0_mmu_flag = 1;
+        req->mmu_info.dst_mmu_flag = 1;
+
+        if (req_rga->mmu_info.mmu_flag >> 31) {
+            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
+            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
+            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
+            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
+        }
+        else {
+            if (req_rga->src.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.src0_mmu_flag = 0;
+               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
+               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
+               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
+            }
+
+            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.dst_mmu_flag = 0;
+               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
+            }
+        }
+    }
+}
+
+
+
diff --git a/drivers/video/rockchip/rga2/rga2_reg_info.h b/drivers/video/rockchip/rga2/rga2_reg_info.h
new file mode 100644
index 000000000000..4751cde66d1e
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.h
@@ -0,0 +1,295 @@
+#ifndef __REG2_INFO_H__
+#define __REG2_INFO_H__
+
+
+//#include "chip_register.h"
+
+//#include "rga_struct.h"
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+#ifndef ABS
+#define ABS(X)              (((X) < 0) ? (-(X)) : (X))
+#endif
+
+#ifndef CLIP
+#define CLIP(x, a,  b)				((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x))
+#endif
+
+#define rRGA_SYS_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_SYS_CTRL_OFFSET    ))
+#define rRGA_CMD_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_CTRL_OFFSET    ))
+#define rRGA_CMD_BASE             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_BASE_OFFSET    ))
+#define rRGA_STATUS               (*(volatile u32 *)(RGA2_BASE + RGA2_STATUS_OFFSET      ))
+#define rRGA_INT                  (*(volatile u32 *)(RGA2_BASE + RGA2_INT_OFFSET         ))
+#define rRGA_MMU_CTRL0            (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CTRL0_OFFSET   ))
+#define rRGA_MMU_CMD_BASE         (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CMD_BASE_OFFSET))
+#define rRGA_CMD_ADDR             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_ADDR))
+
+/*RGA_INT*/
+#define m_RGA2_INT_ALL_CMD_DONE_INT_EN             ( 1<<10 )
+#define m_RGA2_INT_MMU_INT_EN                      ( 1<<9  )
+#define m_RGA2_INT_ERROR_INT_EN                    ( 1<<8  )
+#define m_RGA2_INT_NOW_CMD_DONE_INT_CLEAR          ( 1<<7  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_CLEAR          ( 1<<6  )
+#define m_RGA2_INT_MMU_INT_CLEAR                   ( 1<<5  )
+#define m_RGA2_INT_ERROR_INT_CLEAR                 ( 1<<4  )
+#define m_RGA2_INT_CUR_CMD_DONE_INT_FLAG           ( 1<<3  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_FLAG           ( 1<<2  )
+#define m_RGA2_INT_MMU_INT_FLAG                    ( 1<<1  )
+#define m_RGA2_INT_ERROR_INT_FLAG                  ( 1<<0  )
+
+#define s_RGA2_INT_ALL_CMD_DONE_INT_EN(x)          ( (x&0x1)<<10 )
+#define s_RGA2_INT_MMU_INT_EN(x)                   ( (x&0x1)<<9  )
+#define s_RGA2_INT_ERROR_INT_EN(x)                 ( (x&0x1)<<8  )
+#define s_RGA2_INT_NOW_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<7  )
+#define s_RGA2_INT_ALL_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<6  )
+#define s_RGA2_INT_MMU_INT_CLEAR(x)                ( (x&0x1)<<5  )
+#define s_RGA2_INT_ERROR_INT_CLEAR(x)              ( (x&0x1)<<4  )
+
+
+
+/* RGA_MODE_CTRL */
+#define m_RGA2_MODE_CTRL_SW_RENDER_MODE         (  0x7<<0  )
+#define m_RGA2_MODE_CTRL_SW_BITBLT_MODE         (  0x1<<3  )
+#define m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT         (  0x1<<4  )
+#define m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET      (  0x1<<5  )
+#define m_RGA2_MODE_CTRL_SW_GRADIENT_SAT        (  0x1<<6  )
+#define m_RGA2_MODE_CTRL_SW_INTR_CF_E           (  0x1<<7  )
+
+#define s_RGA2_MODE_CTRL_SW_RENDER_MODE(x)      (  (x&0x7)<<0  )
+#define s_RGA2_MODE_CTRL_SW_BITBLT_MODE(x)      (  (x&0x1)<<3  )
+#define s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(x)      (  (x&0x1)<<4  )
+#define s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(x)   (  (x&0x1)<<5  )
+#define s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(x)     (  (x&0x1)<<6  )
+#define s_RGA2_MODE_CTRL_SW_INTR_CF_E(x)        (  (x&0x1)<<7  )
+
+/* RGA_SRC_INFO */
+#define m_RGA2_SRC_INFO_SW_SRC_FMT                (   0xf<<0   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP         (   0x1<<4   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP      (   0x1<<5   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP         (   0x1<<6   )
+#define m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN           (   0x1<<7   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE        (   0x3<<8   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE        (   0x3<<10  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE        (   0x3<<12  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE       (   0x3<<14  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE       (   0x3<<16  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE      (   0x1<<18  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E         (   0xf<<19  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E     (   0x1<<23  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER      (   0x3<<24  )
+#define m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL        (   0x1<<26  )
+
+
+
+#define s_RGA2_SRC_INFO_SW_SRC_FMT(x)                (   (x&0xf)<<0   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(x)         (   (x&0x1)<<4   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(x)      (   (x&0x1)<<5   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(x)         (   (x&0x1)<<6   )
+#define s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(x)           (   (x&0x1)<<7   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(x)        (   (x&0x3)<<8   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(x)        (   (x&0x3)<<10  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE(x)        (   (x&0x3)<<12  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x)       (   (x&0x3)<<14  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(x)       (   (x&0x3)<<16  )
+
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(x)      (   (x&0x1)<<18  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(x)         (   (x&0xf)<<19  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E(x)     (   (x&0x1)<<23  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER(x)      (   (x&0x3)<<24  )
+#define s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL(x)        (   (x&0x1)<<26  )
+
+
+/* RGA_SRC_VIR_INFO */
+#define m_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE        (  0x7fff<<0  )         //modify
+#define m_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE       (   0x3ff<<16 )         //modify
+
+#define s_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE(x)        ( (x&0x7fff)<<0  )   //modify
+#define s_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE(x)       (   (x&0x3ff)<<16 )  //modify
+
+
+/* RGA_SRC_ACT_INFO */
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH        (  0x1fff<<0  )
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT       (  0x1fff<<16  )
+
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH(x)        (  (x&0x1fff)<<0  )
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT(x)       (  (x&0x1fff<)<16  )
+
+
+/* RGA_DST_INFO */
+#define m_RGA2_DST_INFO_SW_DST_FMT                   (  0xf<<0 )
+#define m_RGA2_DST_INFO_SW_DST_RB_SWAP               (  0x1<<4 )
+#define m_RGA2_DST_INFO_SW_ALPHA_SWAP                (  0x1<<5 )
+#define m_RGA2_DST_INFO_SW_DST_UV_SWAP               (  0x1<<6 )
+#define m_RGA2_DST_INFO_SW_SRC1_FMT                  (  0x7<<7 )
+#define m_RGA2_DST_INFO_SW_SRC1_RB_SWP               (  0x1<<10)
+#define m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP            (  0x1<<11)
+#define m_RGA2_DST_INFO_SW_DITHER_UP_E               (  0x1<<12)
+#define m_RGA2_DST_INFO_SW_DITHER_DOWN_E             (  0x1<<13)
+#define m_RGA2_DST_INFO_SW_DITHER_MODE               (  0x3<<14)
+#define m_RGA2_DST_INFO_SW_DST_CSC_MODE              (  0x3<<16)    //add
+#define m_RGA2_DST_INFO_SW_CSC_CLIP_MODE             (  0x1<<18)
+
+#define s_RGA2_DST_INFO_SW_DST_FMT(x)                   (  (x&0xf)<<0 )
+#define s_RGA2_DST_INFO_SW_DST_RB_SWAP(x)               (  (x&0x1)<<4 )
+#define s_RGA2_DST_INFO_SW_ALPHA_SWAP(x)                (  (x&0x1)<<5 )
+#define s_RGA2_DST_INFO_SW_DST_UV_SWAP(x)               (  (x&0x1)<<6 )
+#define s_RGA2_DST_INFO_SW_SRC1_FMT(x)                  (  (x&0x7)<<7 )
+#define s_RGA2_DST_INFO_SW_SRC1_RB_SWP(x)               (  (x&0x1)<<10)
+#define s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(x)            (  (x&0x1)<<11)
+#define s_RGA2_DST_INFO_SW_DITHER_UP_E(x)               (  (x&0x1)<<12)
+#define s_RGA2_DST_INFO_SW_DITHER_DOWN_E(x)             (  (x&0x1)<<13)
+#define s_RGA2_DST_INFO_SW_DITHER_MODE(x)               (  (x&0x3)<<14)
+#define s_RGA2_DST_INFO_SW_DST_CSC_MODE(x)              (  (x&0x3)<<16)    //add
+#define s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(x)             (  (x&0x1)<<18)
+
+
+/* RGA_ALPHA_CTRL0 */
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0             (  0x1<<0  )
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL           (  0x1<<1  )
+#define m_RGA2_ALPHA_CTRL0_SW_ROP_MODE                (  0x3<<2  )
+#define m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA        ( 0xff<<4  )
+#define m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA        ( 0xff<<12 )
+#define m_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN             (  0x1<<20 )         //add
+
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(x)             (  (x&0x1)<<0  )
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(x)           (  (x&0x1)<<1  )
+#define s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(x)                (  (x&0x3)<<2  )
+#define s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(x)        ( (x&0xff)<<4  )
+#define s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(x)        ( (x&0xff)<<12 )
+#define s_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN(x)             (  (x&0x1)<<20 )  //add
+
+
+
+/* RGA_ALPHA_CTRL1 */
+#define m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0            ( 0x1<<0 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0            ( 0x1<<1 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0           ( 0x7<<2 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0           ( 0x7<<5 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0        ( 0x1<<8 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0        ( 0x1<<9 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0            ( 0x3<<10)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0            ( 0x3<<12)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0            ( 0x1<<14)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0            ( 0x1<<15)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1           ( 0x7<<16)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1           ( 0x7<<19)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1        ( 0x1<<22)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1        ( 0x1<<23)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1            ( 0x3<<24)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1            ( 0x3<<26)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1            ( 0x1<<28)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1            ( 0x1<<29)
+
+#define s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(x)            ( (x&0x1)<<0 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(x)            ( (x&0x1)<<1 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(x)           ( (x&0x7)<<2 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(x)           ( (x&0x7)<<5 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(x)        ( (x&0x1)<<8 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(x)        ( (x&0x1)<<9 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(x)            ( (x&0x3)<<10)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(x)            ( (x&0x3)<<12)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(x)            ( (x&0x1)<<14)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(x)            ( (x&0x1)<<15)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(x)           ( (x&0x7)<<16)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(x)           ( (x&0x7)<<19)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(x)        ( (x&0x1)<<22)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(x)        ( (x&0x1)<<23)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(x)            ( (x&0x3)<<24)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(x)            ( (x&0x3)<<26)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(x)            ( (x&0x1)<<28)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(x)            ( (x&0x1)<<29)
+
+
+
+/* RGA_MMU_CTRL1 */
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_EN                  (  0x1<<0 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH               (  0x1<<1 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN         (  0x1<<2 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR        (  0x1<<3 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN                 (  0x1<<4 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH              (  0x1<<5 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN        (  0x1<<6 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR       (  0x1<<7 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_EN                  (  0x1<<8 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH               (  0x1<<9 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN         (  0x1<<10 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR        (  0x1<<11 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_EN                  (  0x1<<12 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH               (  0x1<<13 )
+
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_EN(x)                  (  (x&0x1)<<0 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH(x)               (  (x&0x1)<<1 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN(x)         (  (x&0x1)<<2 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<3 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN(x)                 (  (x&0x1)<<4 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH(x)              (  (x&0x1)<<5 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN(x)        (  (x&0x1)<<6 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR(x)       (  (x&0x1)<<7 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_EN(x)                  (  (x&0x1)<<8 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH(x)               (  (x&0x1)<<9 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN(x)         (  (x&0x1)<<10 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<11 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_EN(x)                  (  (x&0x1)<<12 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH(x)               (  (x&0x1)<<13 )
+
+
+#define RGA2_SYS_CTRL_OFFSET             0x0
+#define RGA2_CMD_CTRL_OFFSET             0x4
+#define RGA2_CMD_BASE_OFFSET             0x8
+#define RGA2_STATUS_OFFSET               0xc
+#define RGA2_INT_OFFSET                  0x10
+#define RGA2_MMU_CTRL0_OFFSET            0x14
+#define RGA2_MMU_CMD_BASE_OFFSET         0x18
+
+#define RGA2_MODE_CTRL_OFFSET                   0x00
+#define RGA2_SRC_INFO_OFFSET                    0x04
+#define RGA2_SRC_BASE0_OFFSET                   0x08
+#define RGA2_SRC_BASE1_OFFSET                   0x0c
+#define RGA2_SRC_BASE2_OFFSET                   0x10
+#define RGA2_SRC_BASE3_OFFSET                   0x14
+#define RGA2_SRC_VIR_INFO_OFFSET                0x18
+#define RGA2_SRC_ACT_INFO_OFFSET                0x1c
+#define RGA2_SRC_X_FACTOR_OFFSET                0x20
+#define RGA2_SRC_Y_FACTOR_OFFSET                0x24
+#define RGA2_SRC_BG_COLOR_OFFSET                0x28
+#define RGA2_SRC_FG_COLOR_OFFSET                0x2c
+#define RGA2_SRC_TR_COLOR0_OFFSET               0x30
+#define RGA2_CF_GR_A_OFFSET                     0x30 // repeat
+#define RGA2_SRC_TR_COLOR1_OFFSET               0x34
+#define RGA2_CF_GR_B_OFFSET                     0x34 // repeat
+#define RGA2_DST_INFO_OFFSET                    0x38
+#define RGA2_DST_BASE0_OFFSET                   0x3c
+#define RGA2_DST_BASE1_OFFSET                   0x40
+#define RGA2_DST_BASE2_OFFSET                   0x44
+#define RGA2_DST_VIR_INFO_OFFSET                0x48
+#define RGA2_DST_ACT_INFO_OFFSET                0x4c
+#define RGA2_ALPHA_CTRL0_OFFSET                 0x50
+#define RGA2_ALPHA_CTRL1_OFFSET                 0x54
+#define RGA2_FADING_CTRL_OFFSET                 0x58
+#define RGA2_PAT_CON_OFFSET                     0x5c
+#define RGA2_ROP_CTRL0_OFFSET                   0x60
+#define RGA2_CF_GR_G_OFFSET                     0x60 // repeat
+#define RGA2_ROP_CTRL1_OFFSET                   0x64
+#define RGA2_CF_GR_R_OFFSET                     0x64 // repeat
+#define RGA2_MASK_BASE_OFFSET                   0x68
+#define RGA2_MMU_CTRL1_OFFSET                   0x6c
+#define RGA2_MMU_SRC_BASE_OFFSET                0x70
+#define RGA2_MMU_SRC1_BASE_OFFSET               0x74
+#define RGA2_MMU_DST_BASE_OFFSET                0x78
+#define RGA2_MMU_ELS_BASE_OFFSET                0x7c
+
+int RGA2_gen_reg_info(unsigned char *base, struct rga2_req *msg);
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req);
+
+
+
+#endif
+
diff --git a/drivers/video/rockchip/rga2/rga2_rop.h b/drivers/video/rockchip/rga2/rga2_rop.h
new file mode 100644
index 000000000000..60d90b8304de
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_rop.h
@@ -0,0 +1,57 @@
+#ifndef __RGA_ROP_H__
+#define __RGA_ROP_H__
+
+#include "rga2_type.h"
+
+UWORD32 ROP3_code[256] =
+{
+    0x00000007, 0x00000451, 0x00006051, 0x00800051, 0x00007041, 0x00800041, 0x00804830, 0x000004f0,//0
+    0x00800765, 0x000004b0, 0x00000065, 0x000004f4, 0x00000075, 0x000004e6, 0x00804850, 0x00800005,
+
+    0x00006850, 0x00800050, 0x00805028, 0x00000568, 0x00804031, 0x00000471, 0x002b6071, 0x018037aa,//1
+    0x008007aa, 0x00036071, 0x00002c6a, 0x00803631, 0x00002d68, 0x00802721, 0x008002d0, 0x000006d0,
+
+    0x0080066e, 0x00000528, 0x00000066, 0x0000056c, 0x018007aa, 0x0002e06a, 0x00003471, 0x00834031,//2
+    0x00800631, 0x0002b471, 0x00006071, 0x008037aa, 0x000036d0, 0x008002d4, 0x00002d28, 0x000006d4,
+
+    0x0000006e, 0x00000565, 0x00003451, 0x00800006, 0x000034f0, 0x00834830, 0x00800348, 0x00000748,//3
+    0x00002f48, 0x0080034c, 0x000034b0, 0x0000074c, 0x00000031, 0x00834850, 0x000034e6, 0x00800071,
+
+    0x008006f4, 0x00000431, 0x018007a1, 0x00b6e870, 0x00000074, 0x0000046e, 0x00002561, 0x00802f28,//4
+    0x00800728, 0x0002a561, 0x000026c2, 0x008002c6, 0x00007068, 0x018035aa, 0x00002c2a, 0x000006c6,
+
+    0x0000006c, 0x00000475, 0x000024e2, 0x008036b0, 0x00804051, 0x00800004, 0x00800251, 0x00000651,
+    0x00002e4a, 0x0080024e, 0x00000028, 0x00824842, 0x000024a2, 0x0000064e, 0x000024f4, 0x00800068,//5
+
+    0x008006b0, 0x000234f0, 0x00002741, 0x00800345, 0x00003651, 0x00800255, 0x00000030, 0x00834051,
+    0x00a34842, 0x000002b0, 0x00800271, 0x0002b651, 0x00800368, 0x0002a741, 0x0000364e, 0x00806830,//6
+
+    0x00006870, 0x008037a2, 0x00003431, 0x00000745, 0x00002521, 0x00000655, 0x0000346e, 0x00800062,
+    0x008002f0, 0x000236d0, 0x000026d4, 0x00807028, 0x000036c6, 0x00806031, 0x008005aa, 0x00000671,//7
+
+    0x00800671, 0x000005aa, 0x00006031, 0x008036c6, 0x00007028, 0x00802e55, 0x008236d0, 0x000002f0,
+    0x00000070, 0x0080346e, 0x00800655, 0x00802521, 0x00800745, 0x00803431, 0x000037a2, 0x00806870,//8
+
+    0x00006830, 0x0080364e, 0x00822f48, 0x00000361, 0x0082b651, 0x00000271, 0x00800231, 0x002b4051,
+    0x00034051, 0x00800030, 0x0080026e, 0x00803651, 0x0080036c, 0x00802741, 0x008234f0, 0x000006b0,//9
+
+    0x00000068, 0x00802c75, 0x0080064e, 0x008024a2, 0x0002c04a, 0x00800021, 0x00800275, 0x00802e51,
+    0x00800651, 0x00000251, 0x00800000, 0x00004051, 0x000036b0, 0x008024e2, 0x00800475, 0x00000045,//a
+
+    0x008006c6, 0x00802c2a, 0x000035aa, 0x00807068, 0x008002f4, 0x008026c2, 0x00822d68, 0x00000728,
+    0x00002f28, 0x00802561, 0x0080046e, 0x00000046, 0x00836870, 0x000007a2, 0x00800431, 0x00004071,//b
+
+    0x00000071, 0x008034e6, 0x00034850, 0x00800031, 0x0080074c, 0x008034b0, 0x00800365, 0x00802f48,
+    0x00800748, 0x00000341, 0x000026a2, 0x008034f0, 0x00800002, 0x00005048, 0x00800565, 0x00000055,//c
+
+    0x008006d4, 0x00802d28, 0x008002e6, 0x008036d0, 0x000037aa, 0x00806071, 0x0082b471, 0x00000631,
+    0x00002e2a, 0x00803471, 0x00826862, 0x010007aa, 0x0080056c, 0x00000054, 0x00800528, 0x00005068,//d
+
+    0x008006d0, 0x000002d0, 0x00002721, 0x00802d68, 0x00003631, 0x00802c6a, 0x00836071, 0x000007aa,
+    0x010037aa, 0x00a36870, 0x00800471, 0x00004031, 0x00800568, 0x00005028, 0x00000050, 0x00800545,//e
+
+    0x00800001, 0x00004850, 0x008004e6, 0x0000004e, 0x008004f4, 0x0000004c, 0x008004b0, 0x00004870,
+    0x008004f0, 0x00004830, 0x00000048, 0x0080044e, 0x00000051, 0x008004d4, 0x00800451, 0x00800007,//f
+};
+
+#endif
diff --git a/drivers/video/rockchip/rga2/rga2_type.h b/drivers/video/rockchip/rga2/rga2_type.h
new file mode 100644
index 000000000000..38a872034da1
--- /dev/null
+++ b/drivers/video/rockchip/rga2/rga2_type.h
@@ -0,0 +1,48 @@
+#ifndef __RGA_TYPE_H__
+#define __RGA_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+typedef  unsigned int     UWORD32;
+typedef  unsigned int     uint32;
+typedef  unsigned int     RK_U32;
+
+typedef  unsigned short   UWORD16;
+typedef  unsigned short   RK_U16;
+
+typedef  unsigned char    UBYTE;
+typedef  unsigned char    RK_U8;
+
+typedef  int              WORD32;
+typedef  int              RK_S32;
+
+typedef  short            WORD16;
+typedef  short            RK_S16;
+
+typedef  char             BYTE;
+typedef  char             RK_S8;
+
+
+#ifndef NULL
+#define NULL              0L
+#endif
+
+#ifndef TRUE
+#define TRUE              1L
+#endif
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __RGA_TYPR_H__ */
+
-- 
2.35.3

