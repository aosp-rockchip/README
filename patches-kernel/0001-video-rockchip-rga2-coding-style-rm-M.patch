From a5d2c44af3ad774f05d97528bd6d825c7698cdec Mon Sep 17 00:00:00 2001
From: Li Huang <putin.li@rock-chips.com>
Date: Fri, 25 Oct 2019 14:41:35 +0800
Subject: [PATCH] video/rockchip: rga2: coding style rm ^M

Change-Id: I3ecaa907c606c6316505fe7ba524c2feba5f2621
Signed-off-by: Li Huang <putin.li@rock-chips.com>
---
 drivers/video/rockchip/rga2/RGA2_API.c      |   44 +-
 drivers/video/rockchip/rga2/RGA2_API.h      |   24 +-
 drivers/video/rockchip/rga2/rga2.h          | 1370 +++++-----
 drivers/video/rockchip/rga2/rga2_mmu_info.c | 1127 ++++----
 drivers/video/rockchip/rga2/rga2_mmu_info.h |   37 +-
 drivers/video/rockchip/rga2/rga2_reg_info.c | 2614 +++++++++----------
 drivers/video/rockchip/rga2/rga2_reg_info.h |  602 ++---
 drivers/video/rockchip/rga2/rga2_type.h     |   96 +-
 8 files changed, 2957 insertions(+), 2957 deletions(-)

diff --git a/drivers/video/rockchip/rga2/RGA2_API.c b/drivers/video/rockchip/rga2/RGA2_API.c
index 177bad648b0b..0be2c1ae64b6 100644
--- a/drivers/video/rockchip/rga2/RGA2_API.c
+++ b/drivers/video/rockchip/rga2/RGA2_API.c
@@ -1,23 +1,23 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-
-#include <linux/memory.h>
-#include "RGA2_API.h"
-#include "rga2.h"
-//#include "rga_angle.h"
-
-#define IS_YUV_420(format) \
-     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
-      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP))
-
-#define IS_YUV_422(format) \
-     ((format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
-      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
-
-#define IS_YUV(format) \
-     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
-      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP) | \
-      (format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
-      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
-
-
-
+
+#include <linux/memory.h>
+#include "RGA2_API.h"
+#include "rga2.h"
+//#include "rga_angle.h"
+
+#define IS_YUV_420(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP))
+
+#define IS_YUV_422(format) \
+     ((format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+#define IS_YUV(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP) | \
+      (format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+
+
diff --git a/drivers/video/rockchip/rga2/RGA2_API.h b/drivers/video/rockchip/rga2/RGA2_API.h
index 2f15e08e5d51..e180b40ac457 100644
--- a/drivers/video/rockchip/rga2/RGA2_API.h
+++ b/drivers/video/rockchip/rga2/RGA2_API.h
@@ -1,13 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __RGA_API_H__
-#define __RGA_API_H__
-
-#include "rga2_reg_info.h"
-#include "rga2.h"
-
-#define ENABLE      1
-#define DISABLE     0
-
-
-
-#endif
+#ifndef __RGA_API_H__
+#define __RGA_API_H__
+
+#include "rga2_reg_info.h"
+#include "rga2.h"
+
+#define ENABLE      1
+#define DISABLE     0
+
+
+
+#endif
diff --git a/drivers/video/rockchip/rga2/rga2.h b/drivers/video/rockchip/rga2/rga2.h
index dfd5d76023e5..6b553903ef2f 100644
--- a/drivers/video/rockchip/rga2/rga2.h
+++ b/drivers/video/rockchip/rga2/rga2.h
@@ -1,107 +1,107 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _RGA_DRIVER_H_
-#define _RGA_DRIVER_H_
-
-#include <linux/mutex.h>
-#include <linux/scatterlist.h>
+#ifndef _RGA_DRIVER_H_
+#define _RGA_DRIVER_H_
+
+#include <linux/mutex.h>
+#include <linux/scatterlist.h>
 #include <linux/dma-buf.h>
-
-
-#define RGA_BLIT_SYNC	0x5017
-#define RGA_BLIT_ASYNC  0x5018
-#define RGA_FLUSH       0x5019
-#define RGA_GET_RESULT  0x501a
-#define RGA_GET_VERSION 0x501b
+
+
+#define RGA_BLIT_SYNC	0x5017
+#define RGA_BLIT_ASYNC  0x5018
+#define RGA_FLUSH       0x5019
+#define RGA_GET_RESULT  0x501a
+#define RGA_GET_VERSION 0x501b
 #define RGA_CACHE_FLUSH 0x501c
-
-#define RGA2_BLIT_SYNC	 0x6017
-#define RGA2_BLIT_ASYNC  0x6018
-#define RGA2_FLUSH       0x6019
-#define RGA2_GET_RESULT  0x601a
-#define RGA2_GET_VERSION 0x601b
-
-
-#define RGA2_REG_CTRL_LEN    0x8    /* 8  */
-#define RGA2_REG_CMD_LEN     0x20   /* 32 */
-#define RGA2_CMD_BUF_SIZE    0x700  /* 16*28*4 */
-
-#define RGA2_OUT_OF_RESOURCES    -10
-#define RGA2_MALLOC_ERROR        -11
-
-#define SCALE_DOWN_LARGE 1
-
-#define rgaIS_ERROR(status)			(status < 0)
-#define rgaNO_ERROR(status)			(status >= 0)
-#define rgaIS_SUCCESS(status)		(status == 0)
-
+
+#define RGA2_BLIT_SYNC	 0x6017
+#define RGA2_BLIT_ASYNC  0x6018
+#define RGA2_FLUSH       0x6019
+#define RGA2_GET_RESULT  0x601a
+#define RGA2_GET_VERSION 0x601b
+
+
+#define RGA2_REG_CTRL_LEN    0x8    /* 8  */
+#define RGA2_REG_CMD_LEN     0x20   /* 32 */
+#define RGA2_CMD_BUF_SIZE    0x700  /* 16*28*4 */
+
+#define RGA2_OUT_OF_RESOURCES    -10
+#define RGA2_MALLOC_ERROR        -11
+
+#define SCALE_DOWN_LARGE 1
+
+#define rgaIS_ERROR(status)			(status < 0)
+#define rgaNO_ERROR(status)			(status >= 0)
+#define rgaIS_SUCCESS(status)		(status == 0)
+
 #define RGA_BUF_GEM_TYPE_MASK      0xC0
 #define RGA_BUF_GEM_TYPE_DMA       0x80
 #define RGA2_MAJOR_VERSION_MASK     (0xFF000000)
 #define RGA2_MINOR_VERSION_MASK     (0x00F00000)
 
-/* RGA2 process mode enum */
-enum
-{
-    bitblt_mode               = 0x0,
-    color_palette_mode        = 0x1,
-    color_fill_mode           = 0x2,
-    update_palette_table_mode = 0x3,
-    update_patten_buff_mode   = 0x4,
-};  /*render mode*/
-
-enum
-{
-    A_B_B =0x0,
-    A_B_C =0x1,
-};  //bitblt_mode select
-
-enum
-{
-    rop_enable_mask          = 0x2,
-    dither_enable_mask       = 0x8,
-    fading_enable_mask       = 0x10,
-    PD_enbale_mask           = 0x20,
-};
-
-
-
-/*
-//          Alpha    Red     Green   Blue
-{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGBA },   // RK_FORMAT_RGBA_8888
-{  4, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGBX_8888
-{  3, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGB_888
-{  4, 32, {{32,24,  24,16,  16, 8,   8, 0 }}, GGL_BGRA },   // RK_FORMAT_BGRA_8888
-{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // RK_FORMAT_RGB_565
-{  2, 16, {{ 1, 0,  16,11,  11, 6,   6, 1 }}, GGL_RGBA },   // RK_FORMAT_RGBA_5551
-{  2, 16, {{ 4, 0,  16,12,  12, 8,   8, 4 }}, GGL_RGBA },   // RK_FORMAT_RGBA_4444
-{  2, 16, {{ 0, 0,   5, 0   11, 5,   16,11}}, GGL_BGR  },   // RK_FORMAT_BGR_565
-{  2, 16, {{ 1, 0,   6, 1,  11, 6,   16,11}}, GGL_BGRA },   // RK_FORMAT_BGRA_5551
-{  2, 16, {{ 4, 0,   8, 4,  12, 8,   16,12}}, GGL_BGRA },   // RK_FORMAT_BGRA_4444
-
-*/
-enum
-{
-	RGA2_FORMAT_RGBA_8888    = 0x0,
-    RGA2_FORMAT_RGBX_8888    = 0x1,
-    RGA2_FORMAT_RGB_888      = 0x2,
-    RGA2_FORMAT_BGRA_8888    = 0x3,
-    RGA2_FORMAT_BGRX_8888    = 0x4,
-    RGA2_FORMAT_BGR_888      = 0x5,
-    RGA2_FORMAT_RGB_565      = 0x6,
-    RGA2_FORMAT_RGBA_5551    = 0x7,
-    RGA2_FORMAT_RGBA_4444    = 0x8,
-    RGA2_FORMAT_BGR_565      = 0x9,
-    RGA2_FORMAT_BGRA_5551    = 0xa,
-    RGA2_FORMAT_BGRA_4444    = 0xb,
-
-    RGA2_FORMAT_YCbCr_422_SP = 0x10,
-    RGA2_FORMAT_YCbCr_422_P  = 0x11,
-    RGA2_FORMAT_YCbCr_420_SP = 0x12,
-    RGA2_FORMAT_YCbCr_420_P  = 0x13,
-    RGA2_FORMAT_YCrCb_422_SP = 0x14,
-    RGA2_FORMAT_YCrCb_422_P  = 0x15,
-    RGA2_FORMAT_YCrCb_420_SP = 0x16,
-    RGA2_FORMAT_YCrCb_420_P  = 0x17,
+/* RGA2 process mode enum */
+enum
+{
+    bitblt_mode               = 0x0,
+    color_palette_mode        = 0x1,
+    color_fill_mode           = 0x2,
+    update_palette_table_mode = 0x3,
+    update_patten_buff_mode   = 0x4,
+};  /*render mode*/
+
+enum
+{
+    A_B_B =0x0,
+    A_B_C =0x1,
+};  //bitblt_mode select
+
+enum
+{
+    rop_enable_mask          = 0x2,
+    dither_enable_mask       = 0x8,
+    fading_enable_mask       = 0x10,
+    PD_enbale_mask           = 0x20,
+};
+
+
+
+/*
+//          Alpha    Red     Green   Blue
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGBA },   // RK_FORMAT_RGBA_8888
+{  4, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGBX_8888
+{  3, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGB_888
+{  4, 32, {{32,24,  24,16,  16, 8,   8, 0 }}, GGL_BGRA },   // RK_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // RK_FORMAT_RGB_565
+{  2, 16, {{ 1, 0,  16,11,  11, 6,   6, 1 }}, GGL_RGBA },   // RK_FORMAT_RGBA_5551
+{  2, 16, {{ 4, 0,  16,12,  12, 8,   8, 4 }}, GGL_RGBA },   // RK_FORMAT_RGBA_4444
+{  2, 16, {{ 0, 0,   5, 0   11, 5,   16,11}}, GGL_BGR  },   // RK_FORMAT_BGR_565
+{  2, 16, {{ 1, 0,   6, 1,  11, 6,   16,11}}, GGL_BGRA },   // RK_FORMAT_BGRA_5551
+{  2, 16, {{ 4, 0,   8, 4,  12, 8,   16,12}}, GGL_BGRA },   // RK_FORMAT_BGRA_4444
+
+*/
+enum
+{
+	RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,
 
 	RGA2_FORMAT_YVYU_422 = 0x18,
 	RGA2_FORMAT_YVYU_420 = 0x19,
@@ -112,434 +112,434 @@ enum
 	RGA2_FORMAT_UYVY_422 = 0x1e,
 	RGA2_FORMAT_UYVY_420 = 0x1f,
 
-    RGA2_FORMAT_YCbCr_420_SP_10B = 0x20,
-    RGA2_FORMAT_YCrCb_420_SP_10B = 0x21,
-    RGA2_FORMAT_YCbCr_422_SP_10B = 0x22,
-    RGA2_FORMAT_YCrCb_422_SP_10B = 0x23,
-};
-
-typedef struct mdp_img
-{
-    u16 width;
-    u16 height;
-    u32 format;
-    u32 mem_addr;
-}
-mdp_img;
-
-typedef struct mdp_img_act
-{
-    u16 width;     // width
-    u16 height;    // height
-    s16 x_off;     // x offset for the vir
-    s16 y_off;     // y offset for the vir
-    s16 uv_x_off;
-    s16 uv_y_off;
-}
-mdp_img_act;
-
-typedef struct mdp_img_vir
-{
-    u16 width;
-    u16 height;
-    u32 format;
-    u32 mem_addr;
-    u32 uv_addr;
-    u32 v_addr;
-}
-mdp_img_vir;
-
-
-typedef struct MMU_INFO
-{
-    unsigned long src0_base_addr;
-    unsigned long src1_base_addr;
-    unsigned long dst_base_addr;
-    unsigned long els_base_addr;
-
-    u8 src0_mmu_flag;     /* [0] src0 mmu enable [1] src0_flush [2] src0_prefetch_en [3] src0_prefetch dir */
-    u8 src1_mmu_flag;     /* [0] src1 mmu enable [1] src1_flush [2] src1_prefetch_en [3] src1_prefetch dir */
-    u8 dst_mmu_flag;      /* [0] dst  mmu enable [1] dst_flush  [2] dst_prefetch_en  [3] dst_prefetch dir  */
-    u8 els_mmu_flag;      /* [0] els  mmu enable [1] els_flush  [2] els_prefetch_en  [3] els_prefetch dir  */
-} MMU_INFO;
-
-
-enum
-{
-	MMU_DIS = 0x0,
-	MMU_EN  = 0x1
-};
-enum
-{
-	MMU_FLUSH_DIS = 0x0,
-	MMU_FLUSH_EN  = 0x2
-};
-enum
-{
-	MMU_PRE_DIS = 0x0,
-	MMU_PRE_EN  = 0x4
-};
-enum
-{
-	MMU_PRE_DIR_FORW  = 0x0,
-	MMU_PRE_DIR_BACK  = 0x8
-};
-typedef struct COLOR_FILL
-{
-    s16 gr_x_a;
-    s16 gr_y_a;
-    s16 gr_x_b;
-    s16 gr_y_b;
-    s16 gr_x_g;
-    s16 gr_y_g;
-    s16 gr_x_r;
-    s16 gr_y_r;
-}
-COLOR_FILL;
-
-enum
-{
-	ALPHA_ORIGINAL = 0x0,
-	ALPHA_NO_128   = 0x1
-};
-
-enum
-{
-	R2_BLACK       = 0x00,
-	R2_COPYPEN     = 0xf0,
-	R2_MASKNOTPEN  = 0x0a,
-	R2_MASKPEN     = 0xa0,
-	R2_MASKPENNOT  = 0x50,
-	R2_MERGENOTPEN = 0xaf,
-	R2_MERGEPEN    = 0xfa,
-	R2_MERGEPENNOT = 0xf5,
-	R2_NOP         = 0xaa,
-	R2_NOT         = 0x55,
-	R2_NOTCOPYPEN  = 0x0f,
-	R2_NOTMASKPEN  = 0x5f,
-	R2_NOTMERGEPEN = 0x05,
-	R2_NOTXORPEN   = 0xa5,
-	R2_WHITE       = 0xff,
-	R2_XORPEN      = 0x5a
-};
-
-
-/***************************************/
-/* porting from rga.h for msg convert  */
-/***************************************/
-
-typedef struct FADING
-{
-    uint8_t b;
-    uint8_t g;
-    uint8_t r;
-    uint8_t res;
-}
-FADING;
-
-typedef struct MMU
-{
-    unsigned char mmu_en;
-    unsigned long base_addr;
-    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
-} MMU;
-
-typedef struct MMU_32
-{
-    unsigned char mmu_en;
-    uint32_t base_addr;
-    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
-} MMU_32;
-
-typedef struct RECT
-{
-    unsigned short xmin;
-    unsigned short xmax; // width - 1
-    unsigned short ymin;
-    unsigned short ymax; // height - 1
-} RECT;
-
-typedef struct POINT
-{
-    unsigned short x;
-    unsigned short y;
-}
-POINT;
-
-typedef struct line_draw_t
-{
-    POINT start_point;              /* LineDraw_start_point                */
-    POINT end_point;                /* LineDraw_end_point                  */
-    uint32_t   color;               /* LineDraw_color                      */
-    uint32_t   flag;                /* (enum) LineDrawing mode sel         */
-    uint32_t   line_width;          /* range 1~16 */
-}
-line_draw_t;
-
-typedef struct rga_img_info_t
-{
-    unsigned long yrgb_addr;      /* yrgb    mem addr         */
-    unsigned long uv_addr;        /* cb/cr   mem addr         */
-    unsigned long v_addr;         /* cr      mem addr         */
-    unsigned int format;         //definition by RK_FORMAT
-
-    unsigned short act_w;
-    unsigned short act_h;
-    unsigned short x_offset;
-    unsigned short y_offset;
-
-    unsigned short vir_w;
-    unsigned short vir_h;
-
-    unsigned short endian_mode; //for BPP
-    unsigned short alpha_swap;
-}
-rga_img_info_t;
-
-typedef struct rga_img_info_32_t
-{
-    uint32_t yrgb_addr;      /* yrgb    mem addr         */
-    uint32_t uv_addr;        /* cb/cr   mem addr         */
-    uint32_t v_addr;         /* cr      mem addr         */
-    unsigned int format;         //definition by RK_FORMAT
-    unsigned short act_w;
-    unsigned short act_h;
-    unsigned short x_offset;
-    unsigned short y_offset;
-    unsigned short vir_w;
-    unsigned short vir_h;
-    unsigned short endian_mode; //for BPP
-    unsigned short alpha_swap;
-}
-rga_img_info_32_t;
-
-struct rga_req {
-    uint8_t render_mode;            /* (enum) process mode sel */
-
-    rga_img_info_t src;             /* src image info */
-    rga_img_info_t dst;             /* dst image info */
-    rga_img_info_t pat;             /* patten image info */
-
-    unsigned long rop_mask_addr;         /* rop4 mask addr */
-    unsigned long LUT_addr;              /* LUT addr */
-
-    RECT clip;                      /* dst clip window default value is dst_vir */
-                                    /* value from [0, w-1] / [0, h-1]*/
-
-    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
-    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
-
-    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
-                                    /* ([0] = 1 alpha_rop_enable)       */
-                                    /* ([1] = 1 rop enable)             */
-                                    /* ([2] = 1 fading_enable)          */
-                                    /* ([3] = 1 PD_enable)              */
-                                    /* ([4] = 1 alpha cal_mode_sel)     */
-                                    /* ([5] = 1 dither_enable)          */
-                                    /* ([6] = 1 gradient fill mode sel) */
-                                    /* ([7] = 1 AA_enable)              */
-
-    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
-
-    uint32_t color_key_max;         /* color key max */
-    uint32_t color_key_min;         /* color key min */
-
-    uint32_t fg_color;              /* foreground color */
-    uint32_t bg_color;              /* background color */
-
-    COLOR_FILL gr_color;            /* color fill use gradient */
-
-    line_draw_t line_draw_info;
-
-    FADING fading;
-
-    uint8_t PD_mode;                /* porter duff alpha mode sel */
-
-    uint8_t alpha_global_value;     /* global alpha value */
-
-    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
-
-    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
-
-    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
-
-    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
-
-    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
-
-    uint8_t rotate_mode;            /* (enum) rotate mode  */
-                                    /* 0x0,     no rotate  */
-                                    /* 0x1,     rotate     */
-                                    /* 0x2,     x_mirror   */
-                                    /* 0x3,     y_mirror   */
-
-    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
-
-    MMU mmu_info;                   /* mmu information */
-
-    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
-                                    /* ([2~3] rop   mode)            */
-                                    /* ([4]   zero  mode en)         */
-                                    /* ([5]   dst   alpha mode)      */
-                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
-
-    uint8_t  src_trans_mode;
-};
-struct rga_req_32
-{
-    uint8_t render_mode;            /* (enum) process mode sel */
-    rga_img_info_32_t src;             /* src image info */
-    rga_img_info_32_t dst;             /* dst image info */
-    rga_img_info_32_t pat;             /* patten image info */
-    uint32_t rop_mask_addr;         /* rop4 mask addr */
-    uint32_t LUT_addr;              /* LUT addr */
-    RECT clip;                      /* dst clip window default value is dst_vir */
-                                    /* value from [0, w-1] / [0, h-1]*/
-    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
-    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
-    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
-                                    /* ([0] = 1 alpha_rop_enable)       */
-                                    /* ([1] = 1 rop enable)             */
-                                    /* ([2] = 1 fading_enable)          */
-                                    /* ([3] = 1 PD_enable)              */
-                                    /* ([4] = 1 alpha cal_mode_sel)     */
-                                    /* ([5] = 1 dither_enable)          */
-                                    /* ([6] = 1 gradient fill mode sel) */
-                                    /* ([7] = 1 AA_enable)              */
-    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
-    uint32_t color_key_max;         /* color key max */
-    uint32_t color_key_min;         /* color key min */
-    uint32_t fg_color;              /* foreground color */
-    uint32_t bg_color;              /* background color */
-    COLOR_FILL gr_color;            /* color fill use gradient */
-    line_draw_t line_draw_info;
-    FADING fading;
-    uint8_t PD_mode;                /* porter duff alpha mode sel */
-    uint8_t alpha_global_value;     /* global alpha value */
-    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
-    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
-    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
-    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
-    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
-    uint8_t rotate_mode;            /* (enum) rotate mode  */
-                                    /* 0x0,     no rotate  */
-                                    /* 0x1,     rotate     */
-                                    /* 0x2,     x_mirror   */
-                                    /* 0x3,     y_mirror   */
-    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
-    MMU_32 mmu_info;                   /* mmu information */
-    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
-                                    /* ([2~3] rop   mode)            */
-                                    /* ([4]   zero  mode en)         */
-                                    /* ([5]   dst   alpha mode)      */
-                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
-    uint8_t  src_trans_mode;
-};
-
-
-
-struct rga2_req
-{
-    u8 render_mode;          /* (enum) process mode sel */
-
-    rga_img_info_t src;    // src  active window
-    rga_img_info_t src1;   // src1 active window
-    rga_img_info_t dst;    // dst  active window
-    rga_img_info_t pat;    // patten active window
-
-    unsigned long rop_mask_addr;       // rop4 mask addr
-    unsigned long LUT_addr;            // LUT addr
-
-    u32 rop_mask_stride;
-
-    u8 bitblt_mode;          /* 0: SRC + DST  => DST     */
-                             /* 1: SRC + SRC1 => DST     */
-
-    u8 rotate_mode;          /* [1:0]                           */
-                             /* 0   degree 0x0                  */
-                             /* 90  degree 0x1                  */
-                             /* 180 degree 0x2                  */
-                             /* 270 degree 0x3                  */
-                             /* [5:4]                           */
-                             /* none                0x0         */
-                             /* x_mirror            0x1         */
-                             /* y_mirror            0x2         */
-                             /* x_mirror + y_mirror 0x3         */
-
-    u16 alpha_rop_flag;         /* alpha rop process flag           */
-                                /* ([0] = 1 alpha_rop_enable)       */
-                                /* ([1] = 1 rop enable)             */
-                                /* ([2] = 1 fading_enable)          */
-                                /* ([3] = 1 alpha cal_mode_sel)     */
-                                /* ([4] = 1 src_dither_up_enable)   */
-                                /* ([5] = 1 dst_dither_up_enable)   */
-                                /* ([6] = 1 dither_down_enable)     */
-                                /* ([7] = 1 gradient fill mode sel) */
-
-
-    u16 alpha_mode_0;           /* [0]     SrcAlphaMode0          */
-                                /* [2:1]   SrcGlobalAlphaMode0    */
-                                /* [3]     SrcAlphaSelectMode0    */
-                                /* [6:4]   SrcFactorMode0         */
-                                /* [7]     SrcColorMode           */
-
-                                /* [8]     DstAlphaMode0          */
-                                /* [10:9]  DstGlobalAlphaMode0    */
-                                /* [11]    DstAlphaSelectMode0    */
-                                /* [14:12] DstFactorMode0         */
-                                /* [15]    DstColorMode0          */
-
-    u16 alpha_mode_1;           /* [0]     SrcAlphaMode1          */
-                                /* [2:1]   SrcGlobalAlphaMode1    */
-                                /* [3]     SrcAlphaSelectMode1    */
-                                /* [6:4]   SrcFactorMode1         */
-
-                                /* [8]     DstAlphaMode1          */
-                                /* [10:9]  DstGlobalAlphaMode1    */
-                                /* [11]    DstAlphaSelectMode1    */
-                                /* [14:12] DstFactorMode1         */
-
-    u8  scale_bicu_mode;    /* 0   1   2  3 */
-
-    u32 color_key_max;      /* color key max */
-    u32 color_key_min;      /* color key min */
-
-    u32 fg_color;           /* foreground color */
-    u32 bg_color;           /* background color */
-
-    u8 color_fill_mode;
-    COLOR_FILL gr_color;    /* color fill use gradient */
-
-    u8 fading_alpha_value;  /* Fading value */
-    u8 fading_r_value;
-    u8 fading_g_value;
-    u8 fading_b_value;
-
-    u8 src_a_global_val;    /* src global alpha value        */
-    u8 dst_a_global_val;    /* dst global alpha value        */
-
-
-    u8  rop_mode;
-    u16 rop_code;           /* rop2/3/4 code */
-
-    u8 palette_mode;        /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
-
-    u8 yuv2rgb_mode;        /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
-
-    u8 endian_mode;         /* 0/little endian 1/big endian */
-
-    u8 CMD_fin_int_enable;
-
-    MMU_INFO mmu_info;               /* mmu infomation */
-
-    u8 alpha_zero_key;
-    u8 src_trans_mode;
-
-    u8 alpha_swp;
-    u8 dither_mode;
-
-    u8 rgb2yuv_mode;
-
+    RGA2_FORMAT_YCbCr_420_SP_10B = 0x20,
+    RGA2_FORMAT_YCrCb_420_SP_10B = 0x21,
+    RGA2_FORMAT_YCbCr_422_SP_10B = 0x22,
+    RGA2_FORMAT_YCrCb_422_SP_10B = 0x23,
+};
+
+typedef struct mdp_img
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+}
+mdp_img;
+
+typedef struct mdp_img_act
+{
+    u16 width;     // width
+    u16 height;    // height
+    s16 x_off;     // x offset for the vir
+    s16 y_off;     // y offset for the vir
+    s16 uv_x_off;
+    s16 uv_y_off;
+}
+mdp_img_act;
+
+typedef struct mdp_img_vir
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+    u32 uv_addr;
+    u32 v_addr;
+}
+mdp_img_vir;
+
+
+typedef struct MMU_INFO
+{
+    unsigned long src0_base_addr;
+    unsigned long src1_base_addr;
+    unsigned long dst_base_addr;
+    unsigned long els_base_addr;
+
+    u8 src0_mmu_flag;     /* [0] src0 mmu enable [1] src0_flush [2] src0_prefetch_en [3] src0_prefetch dir */
+    u8 src1_mmu_flag;     /* [0] src1 mmu enable [1] src1_flush [2] src1_prefetch_en [3] src1_prefetch dir */
+    u8 dst_mmu_flag;      /* [0] dst  mmu enable [1] dst_flush  [2] dst_prefetch_en  [3] dst_prefetch dir  */
+    u8 els_mmu_flag;      /* [0] els  mmu enable [1] els_flush  [2] els_prefetch_en  [3] els_prefetch dir  */
+} MMU_INFO;
+
+
+enum
+{
+	MMU_DIS = 0x0,
+	MMU_EN  = 0x1
+};
+enum
+{
+	MMU_FLUSH_DIS = 0x0,
+	MMU_FLUSH_EN  = 0x2
+};
+enum
+{
+	MMU_PRE_DIS = 0x0,
+	MMU_PRE_EN  = 0x4
+};
+enum
+{
+	MMU_PRE_DIR_FORW  = 0x0,
+	MMU_PRE_DIR_BACK  = 0x8
+};
+typedef struct COLOR_FILL
+{
+    s16 gr_x_a;
+    s16 gr_y_a;
+    s16 gr_x_b;
+    s16 gr_y_b;
+    s16 gr_x_g;
+    s16 gr_y_g;
+    s16 gr_x_r;
+    s16 gr_y_r;
+}
+COLOR_FILL;
+
+enum
+{
+	ALPHA_ORIGINAL = 0x0,
+	ALPHA_NO_128   = 0x1
+};
+
+enum
+{
+	R2_BLACK       = 0x00,
+	R2_COPYPEN     = 0xf0,
+	R2_MASKNOTPEN  = 0x0a,
+	R2_MASKPEN     = 0xa0,
+	R2_MASKPENNOT  = 0x50,
+	R2_MERGENOTPEN = 0xaf,
+	R2_MERGEPEN    = 0xfa,
+	R2_MERGEPENNOT = 0xf5,
+	R2_NOP         = 0xaa,
+	R2_NOT         = 0x55,
+	R2_NOTCOPYPEN  = 0x0f,
+	R2_NOTMASKPEN  = 0x5f,
+	R2_NOTMERGEPEN = 0x05,
+	R2_NOTXORPEN   = 0xa5,
+	R2_WHITE       = 0xff,
+	R2_XORPEN      = 0x5a
+};
+
+
+/***************************************/
+/* porting from rga.h for msg convert  */
+/***************************************/
+
+typedef struct FADING
+{
+    uint8_t b;
+    uint8_t g;
+    uint8_t r;
+    uint8_t res;
+}
+FADING;
+
+typedef struct MMU
+{
+    unsigned char mmu_en;
+    unsigned long base_addr;
+    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
+} MMU;
+
+typedef struct MMU_32
+{
+    unsigned char mmu_en;
+    uint32_t base_addr;
+    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
+} MMU_32;
+
+typedef struct RECT
+{
+    unsigned short xmin;
+    unsigned short xmax; // width - 1
+    unsigned short ymin;
+    unsigned short ymax; // height - 1
+} RECT;
+
+typedef struct POINT
+{
+    unsigned short x;
+    unsigned short y;
+}
+POINT;
+
+typedef struct line_draw_t
+{
+    POINT start_point;              /* LineDraw_start_point                */
+    POINT end_point;                /* LineDraw_end_point                  */
+    uint32_t   color;               /* LineDraw_color                      */
+    uint32_t   flag;                /* (enum) LineDrawing mode sel         */
+    uint32_t   line_width;          /* range 1~16 */
+}
+line_draw_t;
+
+typedef struct rga_img_info_t
+{
+    unsigned long yrgb_addr;      /* yrgb    mem addr         */
+    unsigned long uv_addr;        /* cb/cr   mem addr         */
+    unsigned long v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+
+    unsigned short vir_w;
+    unsigned short vir_h;
+
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+}
+rga_img_info_t;
+
+typedef struct rga_img_info_32_t
+{
+    uint32_t yrgb_addr;      /* yrgb    mem addr         */
+    uint32_t uv_addr;        /* cb/cr   mem addr         */
+    uint32_t v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+    unsigned short vir_w;
+    unsigned short vir_h;
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+}
+rga_img_info_32_t;
+
+struct rga_req {
+    uint8_t render_mode;            /* (enum) process mode sel */
+
+    rga_img_info_t src;             /* src image info */
+    rga_img_info_t dst;             /* dst image info */
+    rga_img_info_t pat;             /* patten image info */
+
+    unsigned long rop_mask_addr;         /* rop4 mask addr */
+    unsigned long LUT_addr;              /* LUT addr */
+
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+
+    COLOR_FILL gr_color;            /* color fill use gradient */
+
+    line_draw_t line_draw_info;
+
+    FADING fading;
+
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+
+    uint8_t alpha_global_value;     /* global alpha value */
+
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+
+    MMU mmu_info;                   /* mmu information */
+
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
+                                    /* ([2~3] rop   mode)            */
+                                    /* ([4]   zero  mode en)         */
+                                    /* ([5]   dst   alpha mode)      */
+                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
+
+    uint8_t  src_trans_mode;
+};
+struct rga_req_32
+{
+    uint8_t render_mode;            /* (enum) process mode sel */
+    rga_img_info_32_t src;             /* src image info */
+    rga_img_info_32_t dst;             /* dst image info */
+    rga_img_info_32_t pat;             /* patten image info */
+    uint32_t rop_mask_addr;         /* rop4 mask addr */
+    uint32_t LUT_addr;              /* LUT addr */
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+    COLOR_FILL gr_color;            /* color fill use gradient */
+    line_draw_t line_draw_info;
+    FADING fading;
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+    uint8_t alpha_global_value;     /* global alpha value */
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+    MMU_32 mmu_info;                   /* mmu information */
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
+                                    /* ([2~3] rop   mode)            */
+                                    /* ([4]   zero  mode en)         */
+                                    /* ([5]   dst   alpha mode)      */
+                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
+    uint8_t  src_trans_mode;
+};
+
+
+
+struct rga2_req
+{
+    u8 render_mode;          /* (enum) process mode sel */
+
+    rga_img_info_t src;    // src  active window
+    rga_img_info_t src1;   // src1 active window
+    rga_img_info_t dst;    // dst  active window
+    rga_img_info_t pat;    // patten active window
+
+    unsigned long rop_mask_addr;       // rop4 mask addr
+    unsigned long LUT_addr;            // LUT addr
+
+    u32 rop_mask_stride;
+
+    u8 bitblt_mode;          /* 0: SRC + DST  => DST     */
+                             /* 1: SRC + SRC1 => DST     */
+
+    u8 rotate_mode;          /* [1:0]                           */
+                             /* 0   degree 0x0                  */
+                             /* 90  degree 0x1                  */
+                             /* 180 degree 0x2                  */
+                             /* 270 degree 0x3                  */
+                             /* [5:4]                           */
+                             /* none                0x0         */
+                             /* x_mirror            0x1         */
+                             /* y_mirror            0x2         */
+                             /* x_mirror + y_mirror 0x3         */
+
+    u16 alpha_rop_flag;         /* alpha rop process flag           */
+                                /* ([0] = 1 alpha_rop_enable)       */
+                                /* ([1] = 1 rop enable)             */
+                                /* ([2] = 1 fading_enable)          */
+                                /* ([3] = 1 alpha cal_mode_sel)     */
+                                /* ([4] = 1 src_dither_up_enable)   */
+                                /* ([5] = 1 dst_dither_up_enable)   */
+                                /* ([6] = 1 dither_down_enable)     */
+                                /* ([7] = 1 gradient fill mode sel) */
+
+
+    u16 alpha_mode_0;           /* [0]     SrcAlphaMode0          */
+                                /* [2:1]   SrcGlobalAlphaMode0    */
+                                /* [3]     SrcAlphaSelectMode0    */
+                                /* [6:4]   SrcFactorMode0         */
+                                /* [7]     SrcColorMode           */
+
+                                /* [8]     DstAlphaMode0          */
+                                /* [10:9]  DstGlobalAlphaMode0    */
+                                /* [11]    DstAlphaSelectMode0    */
+                                /* [14:12] DstFactorMode0         */
+                                /* [15]    DstColorMode0          */
+
+    u16 alpha_mode_1;           /* [0]     SrcAlphaMode1          */
+                                /* [2:1]   SrcGlobalAlphaMode1    */
+                                /* [3]     SrcAlphaSelectMode1    */
+                                /* [6:4]   SrcFactorMode1         */
+
+                                /* [8]     DstAlphaMode1          */
+                                /* [10:9]  DstGlobalAlphaMode1    */
+                                /* [11]    DstAlphaSelectMode1    */
+                                /* [14:12] DstFactorMode1         */
+
+    u8  scale_bicu_mode;    /* 0   1   2  3 */
+
+    u32 color_key_max;      /* color key max */
+    u32 color_key_min;      /* color key min */
+
+    u32 fg_color;           /* foreground color */
+    u32 bg_color;           /* background color */
+
+    u8 color_fill_mode;
+    COLOR_FILL gr_color;    /* color fill use gradient */
+
+    u8 fading_alpha_value;  /* Fading value */
+    u8 fading_r_value;
+    u8 fading_g_value;
+    u8 fading_b_value;
+
+    u8 src_a_global_val;    /* src global alpha value        */
+    u8 dst_a_global_val;    /* dst global alpha value        */
+
+
+    u8  rop_mode;
+    u16 rop_code;           /* rop2/3/4 code */
+
+    u8 palette_mode;        /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    u8 yuv2rgb_mode;        /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    u8 endian_mode;         /* 0/little endian 1/big endian */
+
+    u8 CMD_fin_int_enable;
+
+    MMU_INFO mmu_info;               /* mmu infomation */
+
+    u8 alpha_zero_key;
+    u8 src_trans_mode;
+
+    u8 alpha_swp;
+    u8 dither_mode;
+
+    u8 rgb2yuv_mode;
+
 	u8 buf_type;
 	struct sg_table *sg_src0;
 	struct sg_table *sg_src1;
@@ -548,125 +548,125 @@ struct rga2_req
 	struct dma_buf_attachment *attach_src0;
 	struct dma_buf_attachment *attach_src1;
 	struct dma_buf_attachment *attach_dst;
-};
-
-struct rga2_mmu_buf_t {
-    int32_t front;
-    int32_t back;
-    int32_t size;
-    int32_t curr;
-    unsigned int *buf;
-    unsigned int *buf_virtual;
-
-    struct page **pages;
-};
-
-enum
-{
-    BB_ROTATE_OFF   = 0x0,     /* no rotate  */
-    BB_ROTATE_90    = 0x1,     /* rotate 90  */
-    BB_ROTATE_180   = 0x2,     /* rotate 180 */
-    BB_ROTATE_270   = 0x3,     /* rotate 270 */
-};  /*rotate mode*/
-
-enum
-{
-    BB_MIRROR_OFF   = (0x0 << 4),     /* no mirror  */
-    BB_MIRROR_X     = (0x1 << 4),     /* x  mirror  */
-    BB_MIRROR_Y     = (0x2 << 4),     /* y  mirror  */
-    BB_MIRROR_XY    = (0x3 << 4),     /* xy mirror  */
-};  /*mirror mode*/
-
-enum
-{
-    BB_COPY_USE_TILE = (0x1 << 6),    /* bitblt mode copy but use Tile mode */
-};
-
-enum
-{
-	//BYPASS        = 0x0,
-    BT_601_RANGE0   = 0x1,
-    BT_601_RANGE1   = 0x2,
-    BT_709_RANGE0   = 0x3,
-}; /*yuv2rgb_mode*/
-
-enum
-{
-    BPP1        = 0x0,     /* BPP1 */
-    BPP2        = 0x1,     /* BPP2 */
-    BPP4        = 0x2,     /* BPP4 */
-    BPP8        = 0x3      /* BPP8 */
-}; /*palette_mode*/
-
-enum
-{
-	SOLID_COLOR   = 0x0, //color fill mode; ROP4: SOLID_rop4_mask_addr COLOR
-	PATTERN_COLOR = 0x1  //pattern_fill_mode;ROP4:PATTERN_COLOR
-};  /*color fill mode*/
-
-enum
-{
-	COLOR_FILL_CLIP     = 0x0,
-	COLOR_FILL_NOT_CLIP = 0x1
-};
-
-enum
-{
-    CATROM    = 0x0,
-    MITCHELL  = 0x1,
-    HERMITE   = 0x2,
-    B_SPLINE  = 0x3,
-};  /*bicubic coefficient*/
-
-enum
-{
-	ROP2 = 0x0,
-	ROP3 = 0x1,
-	ROP4 = 0x2
-};  /*ROP mode*/
-
-enum
-{
-	BIG_ENDIAN    = 0x0,
-	LITTLE_ENDIAN = 0x1
-};  /*endian mode*/
-
-enum
-{
-	MMU_TABLE_4KB  = 0x0,
-	MMU_TABLE_64KB = 0x1,
-};  /*MMU table size*/
-
-enum
-{
-    RGB_2_666 = 0x0,
-    RGB_2_565 = 0x1,
-    RGB_2_555 = 0x2,
-    RGB_2_444 = 0x3,
-};  /*dither down mode*/
-
-
-
-/**
- * struct for process session which connect to rga
- *
- * @author ZhangShengqin (2012-2-15)
- */
-typedef struct rga2_session {
-	/* a linked list of data so we can access them for debugging */
-	struct list_head    list_session;
-	/* a linked list of register data waiting for process */
-	struct list_head    waiting;
-	/* a linked list of register data in processing */
-	struct list_head    running;
-	/* all coommand this thread done */
-    atomic_t            done;
-	wait_queue_head_t   wait;
-	pid_t           pid;
-	atomic_t        task_running;
-    atomic_t        num_done;
-} rga2_session;
-
+};
+
+struct rga2_mmu_buf_t {
+    int32_t front;
+    int32_t back;
+    int32_t size;
+    int32_t curr;
+    unsigned int *buf;
+    unsigned int *buf_virtual;
+
+    struct page **pages;
+};
+
+enum
+{
+    BB_ROTATE_OFF   = 0x0,     /* no rotate  */
+    BB_ROTATE_90    = 0x1,     /* rotate 90  */
+    BB_ROTATE_180   = 0x2,     /* rotate 180 */
+    BB_ROTATE_270   = 0x3,     /* rotate 270 */
+};  /*rotate mode*/
+
+enum
+{
+    BB_MIRROR_OFF   = (0x0 << 4),     /* no mirror  */
+    BB_MIRROR_X     = (0x1 << 4),     /* x  mirror  */
+    BB_MIRROR_Y     = (0x2 << 4),     /* y  mirror  */
+    BB_MIRROR_XY    = (0x3 << 4),     /* xy mirror  */
+};  /*mirror mode*/
+
+enum
+{
+    BB_COPY_USE_TILE = (0x1 << 6),    /* bitblt mode copy but use Tile mode */
+};
+
+enum
+{
+	//BYPASS        = 0x0,
+    BT_601_RANGE0   = 0x1,
+    BT_601_RANGE1   = 0x2,
+    BT_709_RANGE0   = 0x3,
+}; /*yuv2rgb_mode*/
+
+enum
+{
+    BPP1        = 0x0,     /* BPP1 */
+    BPP2        = 0x1,     /* BPP2 */
+    BPP4        = 0x2,     /* BPP4 */
+    BPP8        = 0x3      /* BPP8 */
+}; /*palette_mode*/
+
+enum
+{
+	SOLID_COLOR   = 0x0, //color fill mode; ROP4: SOLID_rop4_mask_addr COLOR
+	PATTERN_COLOR = 0x1  //pattern_fill_mode;ROP4:PATTERN_COLOR
+};  /*color fill mode*/
+
+enum
+{
+	COLOR_FILL_CLIP     = 0x0,
+	COLOR_FILL_NOT_CLIP = 0x1
+};
+
+enum
+{
+    CATROM    = 0x0,
+    MITCHELL  = 0x1,
+    HERMITE   = 0x2,
+    B_SPLINE  = 0x3,
+};  /*bicubic coefficient*/
+
+enum
+{
+	ROP2 = 0x0,
+	ROP3 = 0x1,
+	ROP4 = 0x2
+};  /*ROP mode*/
+
+enum
+{
+	BIG_ENDIAN    = 0x0,
+	LITTLE_ENDIAN = 0x1
+};  /*endian mode*/
+
+enum
+{
+	MMU_TABLE_4KB  = 0x0,
+	MMU_TABLE_64KB = 0x1,
+};  /*MMU table size*/
+
+enum
+{
+    RGB_2_666 = 0x0,
+    RGB_2_565 = 0x1,
+    RGB_2_555 = 0x2,
+    RGB_2_444 = 0x3,
+};  /*dither down mode*/
+
+
+
+/**
+ * struct for process session which connect to rga
+ *
+ * @author ZhangShengqin (2012-2-15)
+ */
+typedef struct rga2_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head    list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head    waiting;
+	/* a linked list of register data in processing */
+	struct list_head    running;
+	/* all coommand this thread done */
+    atomic_t            done;
+	wait_queue_head_t   wait;
+	pid_t           pid;
+	atomic_t        task_running;
+    atomic_t        num_done;
+} rga2_session;
+
 struct rga2_reg {
 	rga2_session		*session;
 	struct list_head	session_link;
@@ -686,46 +686,46 @@ struct rga2_reg {
 	struct dma_buf_attachment *attach_dst;
 };
 
-struct rga2_service_info {
-    struct mutex	lock;
-    struct timer_list	timer;			/* timer for power off */
-    struct list_head	waiting;		/* link to link_reg in struct vpu_reg */
-    struct list_head	running;		/* link to link_reg in struct vpu_reg */
-    struct list_head	done;			/* link to link_reg in struct vpu_reg */
-    struct list_head	session;		/* link to list_session in struct vpu_session */
-    atomic_t		total_running;
-
-    struct rga2_reg        *reg;
-
-    uint32_t            cmd_buff[32*8];/* cmd_buff for rga */
-    uint32_t            *pre_scale_buf;
-    atomic_t            int_disable;     /* 0 int enable 1 int disable  */
-    atomic_t            cmd_num;
-    atomic_t            src_format_swt;
-    int                 last_prc_src_format;
-    atomic_t            rga_working;
-    bool                enable;
-    uint32_t            dev_mode;
-
-    //struct rga_req      req[10];
-
-    struct mutex	mutex;	// mutex
-};
-
-#define RGA2_TEST_CASE 0
+struct rga2_service_info {
+    struct mutex	lock;
+    struct timer_list	timer;			/* timer for power off */
+    struct list_head	waiting;		/* link to link_reg in struct vpu_reg */
+    struct list_head	running;		/* link to link_reg in struct vpu_reg */
+    struct list_head	done;			/* link to link_reg in struct vpu_reg */
+    struct list_head	session;		/* link to list_session in struct vpu_session */
+    atomic_t		total_running;
+
+    struct rga2_reg        *reg;
+
+    uint32_t            cmd_buff[32*8];/* cmd_buff for rga */
+    uint32_t            *pre_scale_buf;
+    atomic_t            int_disable;     /* 0 int enable 1 int disable  */
+    atomic_t            cmd_num;
+    atomic_t            src_format_swt;
+    int                 last_prc_src_format;
+    atomic_t            rga_working;
+    bool                enable;
+    uint32_t            dev_mode;
+
+    //struct rga_req      req[10];
+
+    struct mutex	mutex;	// mutex
+};
+
+#define RGA2_TEST_CASE 0
 #define RGA2_DEBUGFS 1
-
-//General Registers
-#define RGA2_SYS_CTRL             0x000
-#define RGA2_CMD_CTRL             0x004
-#define RGA2_CMD_BASE             0x008
-#define RGA2_STATUS               0x00c
-#define RGA2_INT                  0x010
-#define RGA2_MMU_CTRL0            0x018
-#define RGA2_MMU_CMD_BASE         0x01c
-
-//Command code start
-#define RGA2_MODE_CTRL            0x100
-#define RGA_BLIT_COMPLETE_EVENT 1
-
-#endif /*_RK29_IPP_DRIVER_H_*/
+
+//General Registers
+#define RGA2_SYS_CTRL             0x000
+#define RGA2_CMD_CTRL             0x004
+#define RGA2_CMD_BASE             0x008
+#define RGA2_STATUS               0x00c
+#define RGA2_INT                  0x010
+#define RGA2_MMU_CTRL0            0x018
+#define RGA2_MMU_CMD_BASE         0x01c
+
+//Command code start
+#define RGA2_MODE_CTRL            0x100
+#define RGA_BLIT_COMPLETE_EVENT 1
+
+#endif /*_RK29_IPP_DRIVER_H_*/
diff --git a/drivers/video/rockchip/rga2/rga2_mmu_info.c b/drivers/video/rockchip/rga2/rga2_mmu_info.c
index 0bcc1157eaf1..f082ec56c307 100644
--- a/drivers/video/rockchip/rga2/rga2_mmu_info.c
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.c
@@ -1,43 +1,43 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-
-
-#include <linux/version.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
-#include <linux/pagemap.h>
-#include <linux/seq_file.h>
-#include <linux/mm.h>
-#include <linux/mman.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/memory.h>
-#include <linux/dma-mapping.h>
-#include <linux/scatterlist.h>
-#include <asm/memory.h>
-#include <asm/atomic.h>
-#include <asm/cacheflush.h>
-#include "rga2_mmu_info.h"
+
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/memory.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <asm/memory.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include "rga2_mmu_info.h"
 #if RGA2_DEBUGFS
 extern int RGA2_CHECK_MODE;
 #endif
-extern struct rga2_service_info rga2_service;
-extern struct rga2_mmu_buf_t rga2_mmu_buf;
-
-//extern int mmu_buff_temp[1024];
-
-#define KERNEL_SPACE_VALID    0xc0000000
-
-#define V7_VATOPA_SUCESS_MASK	(0x1)
-#define V7_VATOPA_GET_PADDR(X)	(X & 0xFFFFF000)
-#define V7_VATOPA_GET_INER(X)		((X>>4) & 7)
-#define V7_VATOPA_GET_OUTER(X)		((X>>2) & 3)
-#define V7_VATOPA_GET_SH(X)		((X>>7) & 1)
-#define V7_VATOPA_GET_NS(X)		((X>>9) & 1)
-#define V7_VATOPA_GET_SS(X)		((X>>1) & 1)
-
+extern struct rga2_service_info rga2_service;
+extern struct rga2_mmu_buf_t rga2_mmu_buf;
+
+//extern int mmu_buff_temp[1024];
+
+#define KERNEL_SPACE_VALID    0xc0000000
+
+#define V7_VATOPA_SUCESS_MASK	(0x1)
+#define V7_VATOPA_GET_PADDR(X)	(X & 0xFFFFF000)
+#define V7_VATOPA_GET_INER(X)		((X>>4) & 7)
+#define V7_VATOPA_GET_OUTER(X)		((X>>2) & 3)
+#define V7_VATOPA_GET_SH(X)		((X>>7) & 1)
+#define V7_VATOPA_GET_NS(X)		((X>>9) & 1)
+#define V7_VATOPA_GET_SS(X)		((X>>1) & 1)
+
 void rga2_dma_flush_range(void *pstart, void *pend)
 {
 #ifdef CONFIG_ARM
@@ -85,34 +85,34 @@ static void rga2_dma_flush_page(struct page *page)
 #endif
 }
 
-#if 0
-static unsigned int armv7_va_to_pa(unsigned int v_addr)
-{
-	unsigned int p_addr;
-	__asm__ volatile (	"mcr p15, 0, %1, c7, c8, 0\n"
-						"isb\n"
-						"dsb\n"
-						"mrc p15, 0, %0, c7, c4, 0\n"
-						: "=r" (p_addr)
-						: "r" (v_addr)
-						: "cc");
-
-	if (p_addr & V7_VATOPA_SUCESS_MASK)
-		return 0xFFFFFFFF;
-	else
-		return (V7_VATOPA_GET_SS(p_addr) ? 0xFFFFFFFF : V7_VATOPA_GET_PADDR(p_addr));
-}
-#endif
-
-static int rga2_mmu_buf_get(struct rga2_mmu_buf_t *t, uint32_t size)
-{
-    mutex_lock(&rga2_service.lock);
-    t->front += size;
-    mutex_unlock(&rga2_service.lock);
-
-    return 0;
-}
-
+#if 0
+static unsigned int armv7_va_to_pa(unsigned int v_addr)
+{
+	unsigned int p_addr;
+	__asm__ volatile (	"mcr p15, 0, %1, c7, c8, 0\n"
+						"isb\n"
+						"dsb\n"
+						"mrc p15, 0, %0, c7, c4, 0\n"
+						: "=r" (p_addr)
+						: "r" (v_addr)
+						: "cc");
+
+	if (p_addr & V7_VATOPA_SUCESS_MASK)
+		return 0xFFFFFFFF;
+	else
+		return (V7_VATOPA_GET_SS(p_addr) ? 0xFFFFFFFF : V7_VATOPA_GET_PADDR(p_addr));
+}
+#endif
+
+static int rga2_mmu_buf_get(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+    mutex_lock(&rga2_service.lock);
+    t->front += size;
+    mutex_unlock(&rga2_service.lock);
+
+    return 0;
+}
+
 static int rga2_mmu_buf_get_try(struct rga2_mmu_buf_t *t, uint32_t size)
 {
 	int ret = 0;
@@ -148,142 +148,142 @@ static int rga2_mmu_buf_get_try(struct rga2_mmu_buf_t *t, uint32_t size)
 	return ret;
 }
 
-static int rga2_mem_size_cal(unsigned long Mem, uint32_t MemSize, unsigned long *StartAddr)
-{
-    unsigned long start, end;
-    uint32_t pageCount;
-
-    end = (Mem + (MemSize + PAGE_SIZE - 1)) >> PAGE_SHIFT;
-    start = Mem >> PAGE_SHIFT;
-    pageCount = end - start;
-    *StartAddr = start;
-    return pageCount;
-}
-
-static int rga2_buf_size_cal(unsigned long yrgb_addr, unsigned long uv_addr, unsigned long v_addr,
-                                        int format, uint32_t w, uint32_t h, unsigned long *StartAddr )
-{
-    uint32_t size_yrgb = 0;
-    uint32_t size_uv = 0;
-    uint32_t size_v = 0;
-    uint32_t stride = 0;
-    unsigned long start, end;
-    uint32_t pageCount;
-
-    switch(format)
-    {
-        case RGA2_FORMAT_RGBA_8888 :
-            stride = (w * 4 + 3) & (~3);
-            size_yrgb = stride*h;
-            start = yrgb_addr >> PAGE_SHIFT;
+static int rga2_mem_size_cal(unsigned long Mem, uint32_t MemSize, unsigned long *StartAddr)
+{
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    end = (Mem + (MemSize + PAGE_SIZE - 1)) >> PAGE_SHIFT;
+    start = Mem >> PAGE_SHIFT;
+    pageCount = end - start;
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga2_buf_size_cal(unsigned long yrgb_addr, unsigned long uv_addr, unsigned long v_addr,
+                                        int format, uint32_t w, uint32_t h, unsigned long *StartAddr )
+{
+    uint32_t size_yrgb = 0;
+    uint32_t size_uv = 0;
+    uint32_t size_v = 0;
+    uint32_t stride = 0;
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    switch(format)
+    {
+        case RGA2_FORMAT_RGBA_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_RGBX_8888 :
-            stride = (w * 4 + 3) & (~3);
-            size_yrgb = stride*h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBX_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_RGB_888 :
-            stride = (w * 3 + 3) & (~3);
-            size_yrgb = stride*h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_888 :
+            stride = (w * 3 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_BGRA_8888 :
+            break;
+        case RGA2_FORMAT_BGRA_8888 :
             stride = (w * 4 + 3) & (~3);
             size_yrgb = stride * h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_RGB_565 :
-            stride = (w*2 + 3) & (~3);
-            size_yrgb = stride * h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_565 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_RGBA_5551 :
-            stride = (w*2 + 3) & (~3);
-            size_yrgb = stride * h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_5551 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_RGBA_4444 :
-            stride = (w*2 + 3) & (~3);
-            size_yrgb = stride * h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_4444 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-        case RGA2_FORMAT_BGR_888 :
-            stride = (w*3 + 3) & (~3);
-            size_yrgb = stride * h;
-            start = yrgb_addr >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_BGR_888 :
+            stride = (w*3 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
 	    end = yrgb_addr + size_yrgb;
 	    end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	    pageCount = end - start;
-            break;
-
-        /* YUV FORMAT */
-        case RGA2_FORMAT_YCbCr_422_SP :
-        case RGA2_FORMAT_YCrCb_422_SP :
-            stride = (w + 3) & (~3);
-            size_yrgb = stride * h;
-            size_uv = stride * h;
-            start = MIN(yrgb_addr, uv_addr);
-            start >>= PAGE_SHIFT;
-            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
-            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-            pageCount = end - start;
-            break;
-        case RGA2_FORMAT_YCbCr_422_P :
-        case RGA2_FORMAT_YCrCb_422_P :
-            stride = (w + 3) & (~3);
-            size_yrgb = stride * h;
-            size_uv = ((stride >> 1) * h);
-            size_v = ((stride >> 1) * h);
-            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
-            start = start >> PAGE_SHIFT;
-            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
-            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-            pageCount = end - start;
-            break;
-        case RGA2_FORMAT_YCbCr_420_SP :
-        case RGA2_FORMAT_YCrCb_420_SP :
-            stride = (w + 3) & (~3);
-            size_yrgb = stride * h;
-            size_uv = (stride * (h >> 1));
-            start = MIN(yrgb_addr, uv_addr);
-            start >>= PAGE_SHIFT;
-            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
-            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-            pageCount = end - start;
-            break;
-        case RGA2_FORMAT_YCbCr_420_P :
-        case RGA2_FORMAT_YCrCb_420_P :
-            stride = (w + 3) & (~3);
-            size_yrgb = stride * h;
-            size_uv = ((stride >> 1) * (h >> 1));
-            size_v = ((stride >> 1) * (h >> 1));
-            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
-            start >>= PAGE_SHIFT;
-            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
-            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-            pageCount = end - start;
-            break;
+            break;
+
+        /* YUV FORMAT */
+        case RGA2_FORMAT_YCbCr_422_SP :
+        case RGA2_FORMAT_YCrCb_422_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = stride * h;
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_422_P :
+        case RGA2_FORMAT_YCrCb_422_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * h);
+            size_v = ((stride >> 1) * h);
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start = start >> PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_SP :
+        case RGA2_FORMAT_YCrCb_420_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_P :
+        case RGA2_FORMAT_YCrCb_420_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * (h >> 1));
+            size_v = ((stride >> 1) * (h >> 1));
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
 	case RGA2_FORMAT_YVYU_422:
 	case RGA2_FORMAT_VYUY_422:
 	case RGA2_FORMAT_YUYV_422:
@@ -310,37 +310,38 @@ static int rga2_buf_size_cal(unsigned long yrgb_addr, unsigned long uv_addr, uns
 		end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		pageCount = end - start;
 		break;
-        #if 0
-        case RK_FORMAT_BPP1 :
-            break;
-        case RK_FORMAT_BPP2 :
-            break;
-        case RK_FORMAT_BPP4 :
-            break;
-        case RK_FORMAT_BPP8 :
-            break;
-        #endif
-        case RGA2_FORMAT_YCbCr_420_SP_10B:
-        case RGA2_FORMAT_YCrCb_420_SP_10B:
-            stride = (w + 3) & (~3);
-            size_yrgb = stride * h;
-            size_uv = (stride * (h >> 1));
-            start = MIN(yrgb_addr, uv_addr);
-            start >>= PAGE_SHIFT;
-            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
-            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-            pageCount = end - start;
-            break;
-        default :
-            pageCount = 0;
-            start = 0;
-            break;
-    }
-
-    *StartAddr = start;
-    return pageCount;
-}
-
+        #if 0
+        case RK_FORMAT_BPP1 :
+            break;
+        case RK_FORMAT_BPP2 :
+            break;
+        case RK_FORMAT_BPP4 :
+            break;
+        case RK_FORMAT_BPP8 :
+            break;
+        #endif
+        case RGA2_FORMAT_YCbCr_420_SP_10B:
+        case RGA2_FORMAT_YCrCb_420_SP_10B:
+            stride = (w + 3) & (~3);
+            stride = stride;
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        default :
+            pageCount = 0;
+            start = 0;
+            break;
+    }
+
+    *StartAddr = start;
+    return pageCount;
+}
+
 #if RGA2_DEBUGFS
 static int rga2_UserMemory_cheeck(struct page **pages, u32 w, u32 h, u32 format, int flag)
 {
@@ -505,43 +506,43 @@ static int rga2_MapUserMemory(struct page **pages, uint32_t *pageTable,
 	return status;
 }
 
-static int rga2_MapION(struct sg_table *sg,
-                               uint32_t *Memory,
-                               int32_t  pageCount)
-{
-    uint32_t i;
-    uint32_t status;
-    unsigned long Address;
-    uint32_t mapped_size = 0;
-    uint32_t len;
-    struct scatterlist *sgl = sg->sgl;
-    uint32_t sg_num = 0;
-    uint32_t break_flag = 0;
-
-    status = 0;
-    Address = 0;
-    do {
-        len = sg_dma_len(sgl) >> PAGE_SHIFT;
-        Address = sg_phys(sgl);
-
-        for(i=0; i<len; i++) {
-            if (mapped_size + i >= pageCount) {
-                break_flag = 1;
-                break;
-            }
-            Memory[mapped_size + i] = (uint32_t)(Address + (i << PAGE_SHIFT));
-        }
-        if (break_flag)
-            break;
-        mapped_size += len;
-        sg_num += 1;
-    }
-    while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
-
-    return 0;
-}
-
-
+static int rga2_MapION(struct sg_table *sg,
+                               uint32_t *Memory,
+                               int32_t  pageCount)
+{
+    uint32_t i;
+    uint32_t status;
+    unsigned long Address;
+    uint32_t mapped_size = 0;
+    uint32_t len;
+    struct scatterlist *sgl = sg->sgl;
+    uint32_t sg_num = 0;
+    uint32_t break_flag = 0;
+
+    status = 0;
+    Address = 0;
+    do {
+        len = sg_dma_len(sgl) >> PAGE_SHIFT;
+        Address = sg_phys(sgl);
+
+        for(i=0; i<len; i++) {
+            if (mapped_size + i >= pageCount) {
+                break_flag = 1;
+                break;
+            }
+            Memory[mapped_size + i] = (uint32_t)(Address + (i << PAGE_SHIFT));
+        }
+        if (break_flag)
+            break;
+        mapped_size += len;
+        sg_num += 1;
+    }
+    while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
+
+    return 0;
+}
+
+
 static int rga2_mmu_info_BitBlt_mode(struct rga2_reg *reg, struct rga2_req *req)
 {
 	int Src0MemSize, DstMemSize, Src1MemSize;
@@ -717,340 +718,340 @@ static int rga2_mmu_info_BitBlt_mode(struct rga2_reg *reg, struct rga2_req *req)
 	return status;
 }
 
-static int rga2_mmu_info_color_palette_mode(struct rga2_reg *reg, struct rga2_req *req)
-{
-    int SrcMemSize, DstMemSize;
-    unsigned long SrcStart, DstStart;
-    struct page **pages = NULL;
-    uint32_t AllSize;
-    uint32_t *MMU_Base = NULL, *MMU_Base_phys;
-    int ret, status;
-    uint32_t stride;
-
-    uint8_t shift;
-    uint16_t sw, byte_num;
-
-    shift = 3 - (req->palette_mode & 3);
-    sw = req->src.vir_w*req->src.vir_h;
-    byte_num = sw >> shift;
-    stride = (byte_num + 3) & (~3);
-
+static int rga2_mmu_info_color_palette_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, DstMemSize;
+    unsigned long SrcStart, DstStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base = NULL, *MMU_Base_phys;
+    int ret, status;
+    uint32_t stride;
+
+    uint8_t shift;
+    uint16_t sw, byte_num;
+
+    shift = 3 - (req->palette_mode & 3);
+    sw = req->src.vir_w*req->src.vir_h;
+    byte_num = sw >> shift;
+    stride = (byte_num + 3) & (~3);
+
     SrcStart = 0;
     DstStart = 0;
-    SrcMemSize = 0;
-    DstMemSize = 0;
-
-    do {
-        if (req->mmu_info.src0_mmu_flag) {
-            SrcMemSize = rga2_mem_size_cal(req->src.yrgb_addr, stride, &SrcStart);
-            if(SrcMemSize == 0) {
-                return -EINVAL;
-            }
-        }
-
-        if (req->mmu_info.dst_mmu_flag) {
-            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
-                                            req->dst.format, req->dst.vir_w, req->dst.vir_h,
-                                            &DstStart);
-            if(DstMemSize == 0) {
-                return -EINVAL;
-            }
-        }
-
-        SrcMemSize = (SrcMemSize + 15) & (~15);
-        DstMemSize = (DstMemSize + 15) & (~15);
-
-        AllSize = SrcMemSize + DstMemSize;
-
-        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
-            pr_err("RGA2 Get MMU mem failed\n");
-            status = RGA2_MALLOC_ERROR;
-            break;
-        }
-
-        pages = rga2_mmu_buf.pages;
-        if(pages == NULL) {
-            pr_err("RGA MMU malloc pages mem failed\n");
-            return -EINVAL;
-        }
-
-        mutex_lock(&rga2_service.lock);
-        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        mutex_unlock(&rga2_service.lock);
-
-        if(SrcMemSize) {
+    SrcMemSize = 0;
+    DstMemSize = 0;
+
+    do {
+        if (req->mmu_info.src0_mmu_flag) {
+            SrcMemSize = rga2_mem_size_cal(req->src.yrgb_addr, stride, &SrcStart);
+            if(SrcMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        if (req->mmu_info.dst_mmu_flag) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                            req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                            &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        DstMemSize = (DstMemSize + 15) & (~15);
+
+        AllSize = SrcMemSize + DstMemSize;
+
+        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+            pr_err("RGA2 Get MMU mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        pages = rga2_mmu_buf.pages;
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            return -EINVAL;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if(SrcMemSize) {
 		ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
 					 SrcStart, SrcMemSize, 0);
-            if (ret < 0) {
-                pr_err("rga2 map src0 memory failed\n");
-                status = ret;
-                break;
-            }
-
-            /* change the buf address in req struct */
-            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
-            req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
-        }
-
-        if(DstMemSize) {
+            if (ret < 0) {
+                pr_err("rga2 map src0 memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
+            req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+        }
+
+        if(DstMemSize) {
 		ret = rga2_MapUserMemory(&pages[0], MMU_Base + SrcMemSize,
 					 DstStart, DstMemSize, 1);
-            if (ret < 0) {
-                pr_err("rga2 map dst memory failed\n");
-                status = ret;
-                break;
-            }
-
-            /* change the buf address in req struct */
-            req->mmu_info.dst_base_addr  = ((unsigned long)(MMU_Base_phys + SrcMemSize));
-            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
-        }
-
-        /* flush data to DDR */
-	rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
-        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
-        reg->MMU_len = AllSize;
-
-        return 0;
-    }
-    while(0);
-
-    return 0;
-}
-
-static int rga2_mmu_info_color_fill_mode(struct rga2_reg *reg, struct rga2_req *req)
-{
-    int DstMemSize;
-    unsigned long DstStart;
-    struct page **pages = NULL;
-    uint32_t AllSize;
-    uint32_t *MMU_Base, *MMU_Base_phys;
-    int ret;
-    int status;
-
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.dst_base_addr  = ((unsigned long)(MMU_Base_phys + SrcMemSize));
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+        reg->MMU_len = AllSize;
+
+        return 0;
+    }
+    while(0);
+
+    return 0;
+}
+
+static int rga2_mmu_info_color_fill_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int DstMemSize;
+    unsigned long DstStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret;
+    int status;
+
     DstMemSize = 0;
-    MMU_Base = NULL;
-
-    do {
-        if(req->mmu_info.dst_mmu_flag & 1) {
-            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
-                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
-                                        &DstStart);
-            if(DstMemSize == 0) {
-                return -EINVAL;
-            }
-        }
-
-        AllSize = (DstMemSize + 15) & (~15);
-
-        pages = rga2_mmu_buf.pages;
-
-        if(rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
-           pr_err("RGA2 Get MMU mem failed\n");
-           status = RGA2_MALLOC_ERROR;
-           break;
-        }
-
-        mutex_lock(&rga2_service.lock);
-        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        mutex_unlock(&rga2_service.lock);
-
-        if (DstMemSize) {
-            if (req->sg_dst) {
-                ret = rga2_MapION(req->sg_dst, &MMU_Base[0], DstMemSize);
-            }
-            else {
+    MMU_Base = NULL;
+
+    do {
+        if(req->mmu_info.dst_mmu_flag & 1) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        AllSize = (DstMemSize + 15) & (~15);
+
+        pages = rga2_mmu_buf.pages;
+
+        if(rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+           pr_err("RGA2 Get MMU mem failed\n");
+           status = RGA2_MALLOC_ERROR;
+           break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if (DstMemSize) {
+            if (req->sg_dst) {
+                ret = rga2_MapION(req->sg_dst, &MMU_Base[0], DstMemSize);
+            }
+            else {
 		    ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
 					     DstStart, DstMemSize, 1);
-            }
-            if (ret < 0) {
-                pr_err("rga2 map dst memory failed\n");
-                status = ret;
-                break;
-            }
-
-            /* change the buf address in req struct */
-            req->mmu_info.dst_base_addr = ((unsigned long)MMU_Base_phys);
-            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
-        }
-
-        /* flush data to DDR */
-	rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
-        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+            }
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.dst_base_addr = ((unsigned long)MMU_Base_phys);
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
 	reg->MMU_len = AllSize;
 
-        return 0;
-    }
-    while(0);
-
-    return status;
-}
-
-
-static int rga2_mmu_info_update_palette_table_mode(struct rga2_reg *reg, struct rga2_req *req)
-{
-    int SrcMemSize;
-    unsigned long SrcStart;
-    struct page **pages = NULL;
-    uint32_t AllSize;
-    uint32_t *MMU_Base, *MMU_Base_phys;
-    int ret, status;
-
-    MMU_Base = NULL;
-
-    do {
-        /* cal src buf mmu info */
-        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.vir_w * req->pat.vir_h, &SrcStart);
-        if(SrcMemSize == 0) {
-            return -EINVAL;
-        }
-
-        SrcMemSize = (SrcMemSize + 15) & (~15);
-        AllSize = SrcMemSize;
-
-        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
-            pr_err("RGA2 Get MMU mem failed\n");
-            status = RGA2_MALLOC_ERROR;
-            break;
-        }
-
-        mutex_lock(&rga2_service.lock);
-        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
-        mutex_unlock(&rga2_service.lock);
-
-        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
-
-        if(SrcMemSize) {
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+
+static int rga2_mmu_info_update_palette_table_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize;
+    unsigned long SrcStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret, status;
+
+    MMU_Base = NULL;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.vir_w * req->pat.vir_h, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        AllSize = SrcMemSize;
+
+        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+            pr_err("RGA2 Get MMU mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+
+        if(SrcMemSize) {
 		ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
 					 SrcStart, SrcMemSize, 0);
-            if (ret < 0) {
-                pr_err("rga2 map palette memory failed\n");
-                status = ret;
-                break;
-            }
-
-            /* change the buf address in req struct */
-            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
-            req->pat.yrgb_addr = (req->pat.yrgb_addr & (~PAGE_MASK));
-        }
-
-        /* flush data to DDR */
-	rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
-        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
-        reg->MMU_len = AllSize;
-
-        return 0;
-    }
-    while(0);
-
-    return status;
-}
-
-static int rga2_mmu_info_update_patten_buff_mode(struct rga2_reg *reg, struct rga2_req *req)
-{
-    int SrcMemSize, CMDMemSize;
-    unsigned long SrcStart, CMDStart;
-    struct page **pages = NULL;
-    uint32_t i;
-    uint32_t AllSize;
-    uint32_t *MMU_Base, *MMU_p;
-    int ret, status;
-
-    MMU_Base = MMU_p = 0;
-
-    do {
-        /* cal src buf mmu info */
-        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.act_w * req->pat.act_h * 4, &SrcStart);
-        if(SrcMemSize == 0) {
-            return -EINVAL;
-        }
-
-        /* cal cmd buf mmu info */
-        CMDMemSize = rga2_mem_size_cal((unsigned long)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
-        if(CMDMemSize == 0) {
-            return -EINVAL;
-        }
-
-        AllSize = SrcMemSize + CMDMemSize;
-
-        pages = rga2_mmu_buf.pages;
-
-        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
-
-        for(i=0; i<CMDMemSize; i++) {
-            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
-        }
-
-        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
-        {
+            if (ret < 0) {
+                pr_err("rga2 map palette memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
+            req->pat.yrgb_addr = (req->pat.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+        reg->MMU_len = AllSize;
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+static int rga2_mmu_info_update_patten_buff_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    unsigned long SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = MMU_p = 0;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.act_w * req->pat.act_h * 4, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga2_mem_size_cal((unsigned long)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = rga2_mmu_buf.pages;
+
+        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
 		ret = rga2_MapUserMemory(&pages[CMDMemSize],
 					 &MMU_Base[CMDMemSize],
 					 SrcStart, SrcMemSize, 1);
-            if (ret < 0) {
-                pr_err("rga map src memory failed\n");
-                status = ret;
-                break;
-            }
-        }
-        else
-        {
-            MMU_p = MMU_Base + CMDMemSize;
-
-            for(i=0; i<SrcMemSize; i++)
-            {
-                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
-            }
-        }
-
-        /* zsq
-         * change the buf address in req struct
-         * for the reason of lie to MMU
-         */
-        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base) >> 2);
-
-        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
-
-        /*record the malloc buf for the cmd end to release*/
-        reg->MMU_base = MMU_Base;
-
-        /* flush data to DDR */
-	rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
-        return 0;
-
-    }
-    while(0);
-
-    return status;
-}
-
-int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req)
-{
-    int ret;
-
-    switch (req->render_mode) {
-        case bitblt_mode :
-            ret = rga2_mmu_info_BitBlt_mode(reg, req);
-            break;
-        case color_palette_mode :
-            ret = rga2_mmu_info_color_palette_mode(reg, req);
-            break;
-        case color_fill_mode :
-            ret = rga2_mmu_info_color_fill_mode(reg, req);
-            break;
-        case update_palette_table_mode :
-            ret = rga2_mmu_info_update_palette_table_mode(reg, req);
-            break;
-        case update_patten_buff_mode :
-            ret = rga2_mmu_info_update_patten_buff_mode(reg, req);
-            break;
-        default :
-            ret = -1;
-            break;
-    }
-
-    return ret;
-}
-
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        rga2_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        return 0;
+
+    }
+    while(0);
+
+    return status;
+}
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int ret;
+
+    switch (req->render_mode) {
+        case bitblt_mode :
+            ret = rga2_mmu_info_BitBlt_mode(reg, req);
+            break;
+        case color_palette_mode :
+            ret = rga2_mmu_info_color_palette_mode(reg, req);
+            break;
+        case color_fill_mode :
+            ret = rga2_mmu_info_color_fill_mode(reg, req);
+            break;
+        case update_palette_table_mode :
+            ret = rga2_mmu_info_update_palette_table_mode(reg, req);
+            break;
+        case update_patten_buff_mode :
+            ret = rga2_mmu_info_update_patten_buff_mode(reg, req);
+            break;
+        default :
+            ret = -1;
+            break;
+    }
+
+    return ret;
+}
+
diff --git a/drivers/video/rockchip/rga2/rga2_mmu_info.h b/drivers/video/rockchip/rga2/rga2_mmu_info.h
index 9037462d72b0..fd856df2d0ad 100644
--- a/drivers/video/rockchip/rga2/rga2_mmu_info.h
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.h
@@ -1,21 +1,20 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __RGA_MMU_INFO_H__
-#define __RGA_MMU_INFO_H__
-
-#include "rga2.h"
-
-#ifndef MIN
-#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
-#endif
-
-#ifndef MAX
-#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
-#endif
-
-
-int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req);
+#ifndef __RGA_MMU_INFO_H__
+#define __RGA_MMU_INFO_H__
+
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req);
 void rga2_dma_flush_range(void *pstart, void *pend);
-
-#endif
-
-
+
+#endif
+
diff --git a/drivers/video/rockchip/rga2/rga2_reg_info.c b/drivers/video/rockchip/rga2/rga2_reg_info.c
index cefd2a32c224..60ca765d5092 100644
--- a/drivers/video/rockchip/rga2/rga2_reg_info.c
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.c
@@ -1,398 +1,398 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-
-//#include <linux/kernel.h>
-#include <linux/memory.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/sched.h>
-#include <linux/mutex.h>
-#include <linux/err.h>
-#include <linux/clk.h>
-#include <asm/delay.h>
-#include <linux/dma-mapping.h>
-#include <linux/delay.h>
-#include <asm/io.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <asm/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/poll.h>
-#include <linux/delay.h>
-#include <linux/wait.h>
-#include <linux/syscalls.h>
-#include <linux/timer.h>
-#include <linux/time.h>
-#include <asm/cacheflush.h>
-#include <linux/slab.h>
-#include <linux/fb.h>
-#include <linux/wakelock.h>
+
+//#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
 #include <linux/version.h>
-
-#include "rga2_reg_info.h"
+
+#include "rga2_reg_info.h"
 #include "rga2_type.h"
 #include "rga2_rop.h"
-#include "rga2.h"
-
+#include "rga2.h"
+
 static void RGA2_reg_get_param(unsigned char *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_SRC_INFO;
-    RK_U32 *bRGA_SRC_X_FACTOR;
-    RK_U32 *bRGA_SRC_Y_FACTOR;
-    RK_U32 sw, sh;
-    RK_U32 dw, dh;
-    RK_U32 param_x, param_y;
-    RK_U8 x_flag, y_flag;
-
-    RK_U32 reg;
-
-    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
-    reg = *bRGA_SRC_INFO;
-
-    bRGA_SRC_X_FACTOR = (RK_U32 *)(base + RGA2_SRC_X_FACTOR_OFFSET);
-    bRGA_SRC_Y_FACTOR = (RK_U32 *)(base + RGA2_SRC_Y_FACTOR_OFFSET);
-
-    x_flag = y_flag = 0;
-
-    if(((msg->rotate_mode & 0x3) == 1) || ((msg->rotate_mode & 0x3) == 3))
-    {
-        dw = msg->dst.act_h;
-        dh = msg->dst.act_w;
-    }
-    else
-    {
-        dw = msg->dst.act_w;
-        dh = msg->dst.act_h;
-    }
-
-    sw = msg->src.act_w;
-    sh = msg->src.act_h;
-
-    if (sw > dw)
-    {
-        x_flag = 1;
-        #if SCALE_DOWN_LARGE
-        param_x = ((dw) << 16) / (sw) + 1;
-		#else
-        param_x = ((dw) << 16) / (sw);
-        #endif
-        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 0 );
-    }
-    else if (sw < dw)
-    {
-        x_flag = 2;
-        #if 1//SCALE_MINUS1
-        param_x = ((sw - 1) << 16) / (dw - 1);
-        #else
-        param_x = ((sw) << 16) / (dw);
-		#endif
-        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 16);
-    }
-    else
-    {
-        *bRGA_SRC_X_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
-    }
-
-    if (sh > dh)
-    {
-        y_flag = 1;
-        #if SCALE_DOWN_LARGE
-        param_y = ((dh) << 16) / (sh) + 1;
-		#else
-        param_y = ((dh) << 16) / (sh);
-        #endif
-        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 0 );
-    }
-    else if (sh < dh)
-    {
-        y_flag = 2;
-        #if 1//SCALE_MINUS1
-        param_y = ((sh - 1) << 16) / (dh - 1);
-        #else
-        param_y = ((sh) << 16) / (dh);
-		#endif
-        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 16);
-    }
-    else
-    {
-        *bRGA_SRC_Y_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
-    }
-
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x_flag)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(y_flag)));
-}
-
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_X_FACTOR;
+    RK_U32 *bRGA_SRC_Y_FACTOR;
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U32 param_x, param_y;
+    RK_U8 x_flag, y_flag;
+
+    RK_U32 reg;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    reg = *bRGA_SRC_INFO;
+
+    bRGA_SRC_X_FACTOR = (RK_U32 *)(base + RGA2_SRC_X_FACTOR_OFFSET);
+    bRGA_SRC_Y_FACTOR = (RK_U32 *)(base + RGA2_SRC_Y_FACTOR_OFFSET);
+
+    x_flag = y_flag = 0;
+
+    if(((msg->rotate_mode & 0x3) == 1) || ((msg->rotate_mode & 0x3) == 3))
+    {
+        dw = msg->dst.act_h;
+        dh = msg->dst.act_w;
+    }
+    else
+    {
+        dw = msg->dst.act_w;
+        dh = msg->dst.act_h;
+    }
+
+    sw = msg->src.act_w;
+    sh = msg->src.act_h;
+
+    if (sw > dw)
+    {
+        x_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_x = ((dw) << 16) / (sw) + 1;
+		#else
+        param_x = ((dw) << 16) / (sw);
+        #endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 0 );
+    }
+    else if (sw < dw)
+    {
+        x_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_x = ((sw - 1) << 16) / (dw - 1);
+        #else
+        param_x = ((sw) << 16) / (dw);
+		#endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_X_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    if (sh > dh)
+    {
+        y_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_y = ((dh) << 16) / (sh) + 1;
+		#else
+        param_y = ((dh) << 16) / (sh);
+        #endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 0 );
+    }
+    else if (sh < dh)
+    {
+        y_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_y = ((sh - 1) << 16) / (dh - 1);
+        #else
+        param_y = ((sh) << 16) / (dh);
+		#endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_Y_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x_flag)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(y_flag)));
+}
+
 static void RGA2_set_mode_ctrl(u8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_MODE_CTL;
-    RK_U32 reg = 0;
-    RK_U32 render_mode = msg->render_mode;
-
-    bRGA_MODE_CTL = (u32 *)(base + RGA2_MODE_CTRL_OFFSET);
-
-    if(msg->render_mode == 4)
-    {
-        render_mode = 3;
-    }
-
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_RENDER_MODE)) | (s_RGA2_MODE_CTRL_SW_RENDER_MODE(render_mode)));
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_BITBLT_MODE)) | (s_RGA2_MODE_CTRL_SW_BITBLT_MODE(msg->bitblt_mode)));
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT)) | (s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(msg->color_fill_mode)));
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET)) | (s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(msg->alpha_zero_key)));
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_GRADIENT_SAT)) | (s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(msg->alpha_rop_flag >> 7)));
-    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_INTR_CF_E)) | (s_RGA2_MODE_CTRL_SW_INTR_CF_E(msg->CMD_fin_int_enable)));
-
-    *bRGA_MODE_CTL = reg;
-}
-
+{
+    RK_U32 *bRGA_MODE_CTL;
+    RK_U32 reg = 0;
+    RK_U32 render_mode = msg->render_mode;
+
+    bRGA_MODE_CTL = (u32 *)(base + RGA2_MODE_CTRL_OFFSET);
+
+    if(msg->render_mode == 4)
+    {
+        render_mode = 3;
+    }
+
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_RENDER_MODE)) | (s_RGA2_MODE_CTRL_SW_RENDER_MODE(render_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_BITBLT_MODE)) | (s_RGA2_MODE_CTRL_SW_BITBLT_MODE(msg->bitblt_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT)) | (s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(msg->color_fill_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET)) | (s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(msg->alpha_zero_key)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_GRADIENT_SAT)) | (s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(msg->alpha_rop_flag >> 7)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_INTR_CF_E)) | (s_RGA2_MODE_CTRL_SW_INTR_CF_E(msg->CMD_fin_int_enable)));
+
+    *bRGA_MODE_CTL = reg;
+}
+
 static void RGA2_set_reg_src_info(RK_U8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_SRC_INFO;
-    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_BASE1, *bRGA_SRC_BASE2;
-    RK_U32 *bRGA_SRC_VIR_INFO;
-    RK_U32 *bRGA_SRC_ACT_INFO;
-    RK_U32 *bRGA_MASK_ADDR;
-	RK_U32 *bRGA_SRC_TR_COLOR0, *bRGA_SRC_TR_COLOR1;
-
-    RK_U32 reg = 0;
-    RK_U8 src0_format = 0;
-
-    RK_U8 src0_rb_swp = 0;
-    RK_U8 src0_rgb_pack = 0;
-
-    RK_U8 src0_cbcr_swp = 0;
-    RK_U8 pixel_width = 1;
-    RK_U32 stride = 0;
-    RK_U32 uv_stride = 0;
-    RK_U32 mask_stride = 0;
-    RK_U32 ydiv = 1, xdiv = 2;
-    RK_U8  yuv10 = 0;
-
-    RK_U32 sw, sh;
-    RK_U32 dw, dh;
-    RK_U8 rotate_mode;
-    RK_U8 scale_w_flag, scale_h_flag;
-
-    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
-
-    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
-    bRGA_SRC_BASE1 = (RK_U32 *)(base + RGA2_SRC_BASE1_OFFSET);
-    bRGA_SRC_BASE2 = (RK_U32 *)(base + RGA2_SRC_BASE2_OFFSET);
-
-    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
-    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
-
-    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
-
-    bRGA_SRC_TR_COLOR0 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR0_OFFSET);
-    bRGA_SRC_TR_COLOR1 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR1_OFFSET);
-
-    if (msg->src.format == RGA2_FORMAT_YCbCr_420_SP_10B ||
-        msg->src.format == RGA2_FORMAT_YCrCb_420_SP_10B) {
-       if ((msg->src.act_w == msg->dst.act_w) &&
-           (msg->src.act_h == msg->dst.act_h) &&
-           (msg->rotate_mode == 0))
-           msg->rotate_mode = 1 << 6;
-    }
-
-    {
-        rotate_mode = msg->rotate_mode & 0x3;
-
-        sw = msg->src.act_w;
-        sh = msg->src.act_h;
-
-        if((rotate_mode == 1) | (rotate_mode == 3))
-        {
-            dw = msg->dst.act_h;
-            dh = msg->dst.act_w;
-        }
-        else
-        {
-            dw = msg->dst.act_w;
-            dh = msg->dst.act_h;
-        }
-
-        if(sw > dw)
-            scale_w_flag = 1;
-        else if (sw < dw)
-            scale_w_flag = 2;
-        else {
-            scale_w_flag = 0;
-            if(msg->rotate_mode >> 6)
-                scale_w_flag = 3;
-        }
-
-        if(sh > dh)
-            scale_h_flag = 1;
-        else if (sh < dh)
-            scale_h_flag = 2;
-        else {
-            scale_h_flag = 0;
-            if(msg->rotate_mode >> 6)
-                scale_h_flag = 3;
-        }
-    }
-
-    switch (msg->src.format)
-    {
-        case RGA2_FORMAT_RGBA_8888    : src0_format = 0x0; pixel_width = 4; break;
-        case RGA2_FORMAT_BGRA_8888    : src0_format = 0x0; src0_rb_swp = 0x1; pixel_width = 4; break;
-        case RGA2_FORMAT_RGBX_8888    : src0_format = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
-        case RGA2_FORMAT_BGRX_8888    : src0_format = 0x1; src0_rb_swp = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
-        case RGA2_FORMAT_RGB_888      : src0_format = 0x2; src0_rgb_pack = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
-        case RGA2_FORMAT_BGR_888      : src0_format = 0x2; src0_rgb_pack = 1; src0_rb_swp = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
-        case RGA2_FORMAT_RGB_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; src0_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_5551    : src0_format = 0x5; pixel_width = 2; src0_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_4444    : src0_format = 0x6; pixel_width = 2; src0_rb_swp = 0x1; break;
-        case RGA2_FORMAT_BGR_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; break;
-        case RGA2_FORMAT_BGRA_5551    : src0_format = 0x5; pixel_width = 2; break;
-        case RGA2_FORMAT_BGRA_4444    : src0_format = 0x6; pixel_width = 2; break;
-
-        case RGA2_FORMAT_YCbCr_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; break;
-        case RGA2_FORMAT_YCbCr_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; break;
-        case RGA2_FORMAT_YCbCr_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; break;
-        case RGA2_FORMAT_YCbCr_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; break;
-        case RGA2_FORMAT_YCrCb_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; src0_cbcr_swp = 1; break;
-        case RGA2_FORMAT_YCrCb_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; src0_cbcr_swp = 1; break;
-        case RGA2_FORMAT_YCrCb_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; break;
-        case RGA2_FORMAT_YCrCb_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; src0_cbcr_swp = 1; break;
-        case RGA2_FORMAT_YCbCr_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; yuv10 = 1; break;
-        case RGA2_FORMAT_YCrCb_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; yuv10 = 1; break;
-    };
-
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT(src0_format)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(src0_rb_swp)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(msg->alpha_swp)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(src0_cbcr_swp)));
-    if(msg->src.format <= RGA2_FORMAT_BGRA_4444)
-    	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
-    else
-        if(msg->dst.format >= RGA2_FORMAT_YCbCr_422_SP)
-            reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
-        else
-    	    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(msg->yuv2rgb_mode)));
-
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(msg->rotate_mode & 0x3)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE((msg->rotate_mode >> 4) & 0x3)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE((scale_w_flag))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE((scale_h_flag))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER)) | (s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER((msg->scale_bicu_mode))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(msg->src_trans_mode)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(msg->src_trans_mode >> 1)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E((msg->alpha_rop_flag >> 4) & 0x1)));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL)) | (s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL((msg->scale_bicu_mode>>4))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_E((yuv10))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E((yuv10))));
-    RGA2_reg_get_param(base, msg);
-
-    stride = (((msg->src.vir_w * pixel_width) + 3) & ~3) >> 2;
-    uv_stride = ((msg->src.vir_w / xdiv + 3) & ~3);
-
-    *bRGA_SRC_BASE0 = (RK_U32)(msg->src.yrgb_addr + msg->src.y_offset * (stride<<2) + msg->src.x_offset * pixel_width);
-    *bRGA_SRC_BASE1 = (RK_U32)(msg->src.uv_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
-    *bRGA_SRC_BASE2 = (RK_U32)(msg->src.v_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
-
-    //mask_stride = ((msg->src0_act.width + 31) & ~31) >> 5;
-    mask_stride = msg->rop_mask_stride;
-
-    *bRGA_SRC_VIR_INFO = stride | (mask_stride << 16);
-
-    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
-
-    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
-
-    *bRGA_SRC_INFO = reg;
-
-	*bRGA_SRC_TR_COLOR0 = msg->color_key_min;
-    *bRGA_SRC_TR_COLOR1 = msg->color_key_max;
-}
-
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_BASE1, *bRGA_SRC_BASE2;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+    RK_U32 *bRGA_SRC_ACT_INFO;
+    RK_U32 *bRGA_MASK_ADDR;
+	RK_U32 *bRGA_SRC_TR_COLOR0, *bRGA_SRC_TR_COLOR1;
+
+    RK_U32 reg = 0;
+    RK_U8 src0_format = 0;
+
+    RK_U8 src0_rb_swp = 0;
+    RK_U8 src0_rgb_pack = 0;
+
+    RK_U8 src0_cbcr_swp = 0;
+    RK_U8 pixel_width = 1;
+    RK_U32 stride = 0;
+    RK_U32 uv_stride = 0;
+    RK_U32 mask_stride = 0;
+    RK_U32 ydiv = 1, xdiv = 2;
+    RK_U8  yuv10 = 0;
+
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U8 rotate_mode;
+    RK_U8 scale_w_flag, scale_h_flag;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+    bRGA_SRC_BASE1 = (RK_U32 *)(base + RGA2_SRC_BASE1_OFFSET);
+    bRGA_SRC_BASE2 = (RK_U32 *)(base + RGA2_SRC_BASE2_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+
+    bRGA_SRC_TR_COLOR0 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR0_OFFSET);
+    bRGA_SRC_TR_COLOR1 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR1_OFFSET);
+
+    if (msg->src.format == RGA2_FORMAT_YCbCr_420_SP_10B ||
+        msg->src.format == RGA2_FORMAT_YCrCb_420_SP_10B) {
+       if ((msg->src.act_w == msg->dst.act_w) &&
+           (msg->src.act_h == msg->dst.act_h) &&
+           (msg->rotate_mode == 0))
+           msg->rotate_mode = 1 << 6;
+    }
+
+    {
+        rotate_mode = msg->rotate_mode & 0x3;
+
+        sw = msg->src.act_w;
+        sh = msg->src.act_h;
+
+        if((rotate_mode == 1) | (rotate_mode == 3))
+        {
+            dw = msg->dst.act_h;
+            dh = msg->dst.act_w;
+        }
+        else
+        {
+            dw = msg->dst.act_w;
+            dh = msg->dst.act_h;
+        }
+
+        if(sw > dw)
+            scale_w_flag = 1;
+        else if (sw < dw)
+            scale_w_flag = 2;
+        else {
+            scale_w_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_w_flag = 3;
+        }
+
+        if(sh > dh)
+            scale_h_flag = 1;
+        else if (sh < dh)
+            scale_h_flag = 2;
+        else {
+            scale_h_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_h_flag = 3;
+        }
+    }
+
+    switch (msg->src.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src0_format = 0x0; pixel_width = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src0_format = 0x0; src0_rb_swp = 0x1; pixel_width = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src0_format = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRX_8888    : src0_format = 0x1; src0_rb_swp = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_888      : src0_format = 0x2; src0_rgb_pack = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGR_888      : src0_format = 0x2; src0_rgb_pack = 1; src0_rb_swp = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src0_format = 0x5; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src0_format = 0x6; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRA_5551    : src0_format = 0x5; pixel_width = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src0_format = 0x6; pixel_width = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; yuv10 = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; yuv10 = 1; break;
+    };
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT(src0_format)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(src0_rb_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(msg->alpha_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(src0_cbcr_swp)));
+    if(msg->src.format <= RGA2_FORMAT_BGRA_4444)
+    	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+    else
+        if(msg->dst.format >= RGA2_FORMAT_YCbCr_422_SP)
+            reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+        else
+    	    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(msg->yuv2rgb_mode)));
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(msg->rotate_mode & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE((msg->rotate_mode >> 4) & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE((scale_w_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE((scale_h_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER)) | (s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER((msg->scale_bicu_mode))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(msg->src_trans_mode)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(msg->src_trans_mode >> 1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E((msg->alpha_rop_flag >> 4) & 0x1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL)) | (s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL((msg->scale_bicu_mode>>4))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_E((yuv10))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E((yuv10))));
+    RGA2_reg_get_param(base, msg);
+
+    stride = (((msg->src.vir_w * pixel_width) + 3) & ~3) >> 2;
+    uv_stride = ((msg->src.vir_w / xdiv + 3) & ~3);
+
+    *bRGA_SRC_BASE0 = (RK_U32)(msg->src.yrgb_addr + msg->src.y_offset * (stride<<2) + msg->src.x_offset * pixel_width);
+    *bRGA_SRC_BASE1 = (RK_U32)(msg->src.uv_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+    *bRGA_SRC_BASE2 = (RK_U32)(msg->src.v_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+
+    //mask_stride = ((msg->src0_act.width + 31) & ~31) >> 5;
+    mask_stride = msg->rop_mask_stride;
+
+    *bRGA_SRC_VIR_INFO = stride | (mask_stride << 16);
+
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+
+    *bRGA_SRC_INFO = reg;
+
+	*bRGA_SRC_TR_COLOR0 = msg->color_key_min;
+    *bRGA_SRC_TR_COLOR1 = msg->color_key_max;
+}
+
 static void RGA2_set_reg_dst_info(u8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_DST_INFO;
-    RK_U32 *bRGA_DST_BASE0, *bRGA_DST_BASE1, *bRGA_DST_BASE2, *bRGA_SRC_BASE3;
-    RK_U32 *bRGA_DST_VIR_INFO;
-    RK_U32 *bRGA_DST_ACT_INFO;
-
-    RK_U8 src1_format = 0;
-    RK_U8 src1_rb_swp = 0;
-    RK_U8 src1_rgb_pack = 0;
-    RK_U8 dst_format = 0;
-    RK_U8 dst_rb_swp = 0;
-    RK_U8 dst_rgb_pack = 0;
-    RK_U8 dst_cbcr_swp = 0;
-    RK_U32 reg = 0;
-    RK_U8 spw, dpw;
-    RK_U32 s_stride, d_stride;
-    RK_U32 x_mirr, y_mirr, rot_90_flag;
-    RK_U32 yrgb_addr, u_addr, v_addr, s_yrgb_addr;
-    RK_U32 d_uv_stride, x_div, y_div;
-    RK_U32 y_lt_addr, y_ld_addr, y_rt_addr, y_rd_addr;
-    RK_U32 u_lt_addr, u_ld_addr, u_rt_addr, u_rd_addr;
-    RK_U32 v_lt_addr, v_ld_addr, v_rt_addr, v_rd_addr;
-
-    RK_U32 s_y_lt_addr, s_y_ld_addr, s_y_rt_addr, s_y_rd_addr;
-
-    dpw = 1;
-    x_div = y_div = 1;
-
-    bRGA_DST_INFO = (RK_U32 *)(base + RGA2_DST_INFO_OFFSET);
-    bRGA_DST_BASE0 = (RK_U32 *)(base + RGA2_DST_BASE0_OFFSET);
-    bRGA_DST_BASE1 = (RK_U32 *)(base + RGA2_DST_BASE1_OFFSET);
-    bRGA_DST_BASE2 = (RK_U32 *)(base + RGA2_DST_BASE2_OFFSET);
-
-    bRGA_SRC_BASE3 = (RK_U32 *)(base + RGA2_SRC_BASE3_OFFSET);
-
-    bRGA_DST_VIR_INFO = (RK_U32 *)(base + RGA2_DST_VIR_INFO_OFFSET);
-    bRGA_DST_ACT_INFO = (RK_U32 *)(base + RGA2_DST_ACT_INFO_OFFSET);
-
-    switch (msg->src1.format)
-    {
-        case RGA2_FORMAT_RGBA_8888    : src1_format = 0x0; spw = 4; break;
-        case RGA2_FORMAT_BGRA_8888    : src1_format = 0x0; src1_rb_swp = 0x1; spw = 4; break;
-        case RGA2_FORMAT_RGBX_8888    : src1_format = 0x1; spw = 4; break;
-        case RGA2_FORMAT_BGRX_8888    : src1_format = 0x1; src1_rb_swp = 0x1; spw = 4; break;
-        case RGA2_FORMAT_RGB_888      : src1_format = 0x2; src1_rgb_pack = 1; spw = 3; break;
-        case RGA2_FORMAT_BGR_888      : src1_format = 0x2; src1_rgb_pack = 1; src1_rb_swp = 1; spw = 3; break;
-        case RGA2_FORMAT_RGB_565      : src1_format = 0x4; spw = 2; src1_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_5551    : src1_format = 0x5; spw = 2; src1_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_4444    : src1_format = 0x6; spw = 2; src1_rb_swp = 0x1; break;
-        case RGA2_FORMAT_BGR_565      : src1_format = 0x4; spw = 2; break;
-        case RGA2_FORMAT_BGRA_5551    : src1_format = 0x5; spw = 2; break;
-        case RGA2_FORMAT_BGRA_4444    : src1_format = 0x6; spw = 2; break;
-        default                       : spw = 4; break;
-    };
-
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_FMT)) | (s_RGA2_DST_INFO_SW_SRC1_FMT(src1_format)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_RB_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_RB_SWP(src1_rb_swp)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(msg->alpha_swp >> 1)));
-
-
-    switch (msg->dst.format)
-    {
-        case RGA2_FORMAT_RGBA_8888    : dst_format = 0x0; dpw = 4; break;
-        case RGA2_FORMAT_BGRA_8888    : dst_format = 0x0; dst_rb_swp = 0x1; dpw = 4; break;
-        case RGA2_FORMAT_RGBX_8888    : dst_format = 0x1; dpw = 4; break;
-        case RGA2_FORMAT_BGRX_8888    : dst_format = 0x1; dst_rb_swp = 0x1; dpw = 4; break;
-        case RGA2_FORMAT_RGB_888      : dst_format = 0x2; dst_rgb_pack = 1; dpw = 3; break;
-        case RGA2_FORMAT_BGR_888      : dst_format = 0x2; dst_rgb_pack = 1; dst_rb_swp = 1; dpw = 3; break;
-        case RGA2_FORMAT_RGB_565      : dst_format = 0x4; dpw = 2; dst_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_5551    : dst_format = 0x5; dpw = 2; dst_rb_swp = 0x1; break;
-        case RGA2_FORMAT_RGBA_4444    : dst_format = 0x6; dpw = 2; dst_rb_swp = 0x1; break;
-        case RGA2_FORMAT_BGR_565      : dst_format = 0x4; dpw = 2; break;
-        case RGA2_FORMAT_BGRA_5551    : dst_format = 0x5; dpw = 2; break;
-        case RGA2_FORMAT_BGRA_4444    : dst_format = 0x6; dpw = 2; break;
-
-        case RGA2_FORMAT_YCbCr_422_SP : dst_format = 0x8; x_div = 1; y_div = 1; break;
-        case RGA2_FORMAT_YCbCr_422_P  : dst_format = 0x9; x_div = 2; y_div = 1; break;
-        case RGA2_FORMAT_YCbCr_420_SP : dst_format = 0xa; x_div = 1; y_div = 2; break;
-        case RGA2_FORMAT_YCbCr_420_P  : dst_format = 0xb; x_div = 2; y_div = 2; break;
-        case RGA2_FORMAT_YCrCb_422_SP : dst_format = 0x8; dst_cbcr_swp = 1; x_div = 1; y_div = 1; break;
-        case RGA2_FORMAT_YCrCb_422_P  : dst_format = 0x9; dst_cbcr_swp = 1; x_div = 2; y_div = 1; break;
-        case RGA2_FORMAT_YCrCb_420_SP : dst_format = 0xa; dst_cbcr_swp = 1; x_div = 1; y_div = 2; break;
-        case RGA2_FORMAT_YCrCb_420_P  : dst_format = 0xb; dst_cbcr_swp = 1; x_div = 2; y_div = 2; break;
+{
+    RK_U32 *bRGA_DST_INFO;
+    RK_U32 *bRGA_DST_BASE0, *bRGA_DST_BASE1, *bRGA_DST_BASE2, *bRGA_SRC_BASE3;
+    RK_U32 *bRGA_DST_VIR_INFO;
+    RK_U32 *bRGA_DST_ACT_INFO;
+
+    RK_U8 src1_format = 0;
+    RK_U8 src1_rb_swp = 0;
+    RK_U8 src1_rgb_pack = 0;
+    RK_U8 dst_format = 0;
+    RK_U8 dst_rb_swp = 0;
+    RK_U8 dst_rgb_pack = 0;
+    RK_U8 dst_cbcr_swp = 0;
+    RK_U32 reg = 0;
+    RK_U8 spw, dpw;
+    RK_U32 s_stride, d_stride;
+    RK_U32 x_mirr, y_mirr, rot_90_flag;
+    RK_U32 yrgb_addr, u_addr, v_addr, s_yrgb_addr;
+    RK_U32 d_uv_stride, x_div, y_div;
+    RK_U32 y_lt_addr, y_ld_addr, y_rt_addr, y_rd_addr;
+    RK_U32 u_lt_addr, u_ld_addr, u_rt_addr, u_rd_addr;
+    RK_U32 v_lt_addr, v_ld_addr, v_rt_addr, v_rd_addr;
+
+    RK_U32 s_y_lt_addr, s_y_ld_addr, s_y_rt_addr, s_y_rd_addr;
+
+    dpw = 1;
+    x_div = y_div = 1;
+
+    bRGA_DST_INFO = (RK_U32 *)(base + RGA2_DST_INFO_OFFSET);
+    bRGA_DST_BASE0 = (RK_U32 *)(base + RGA2_DST_BASE0_OFFSET);
+    bRGA_DST_BASE1 = (RK_U32 *)(base + RGA2_DST_BASE1_OFFSET);
+    bRGA_DST_BASE2 = (RK_U32 *)(base + RGA2_DST_BASE2_OFFSET);
+
+    bRGA_SRC_BASE3 = (RK_U32 *)(base + RGA2_SRC_BASE3_OFFSET);
+
+    bRGA_DST_VIR_INFO = (RK_U32 *)(base + RGA2_DST_VIR_INFO_OFFSET);
+    bRGA_DST_ACT_INFO = (RK_U32 *)(base + RGA2_DST_ACT_INFO_OFFSET);
+
+    switch (msg->src1.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src1_format = 0x0; spw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src1_format = 0x0; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src1_format = 0x1; spw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : src1_format = 0x1; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGB_888      : src1_format = 0x2; src1_rgb_pack = 1; spw = 3; break;
+        case RGA2_FORMAT_BGR_888      : src1_format = 0x2; src1_rgb_pack = 1; src1_rb_swp = 1; spw = 3; break;
+        case RGA2_FORMAT_RGB_565      : src1_format = 0x4; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src1_format = 0x5; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src1_format = 0x6; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src1_format = 0x4; spw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : src1_format = 0x5; spw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src1_format = 0x6; spw = 2; break;
+        default                       : spw = 4; break;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_FMT)) | (s_RGA2_DST_INFO_SW_SRC1_FMT(src1_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_RB_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_RB_SWP(src1_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(msg->alpha_swp >> 1)));
+
+
+    switch (msg->dst.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : dst_format = 0x0; dpw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : dst_format = 0x0; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : dst_format = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : dst_format = 0x1; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGB_888      : dst_format = 0x2; dst_rgb_pack = 1; dpw = 3; break;
+        case RGA2_FORMAT_BGR_888      : dst_format = 0x2; dst_rgb_pack = 1; dst_rb_swp = 1; dpw = 3; break;
+        case RGA2_FORMAT_RGB_565      : dst_format = 0x4; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : dst_format = 0x5; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : dst_format = 0x6; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : dst_format = 0x4; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : dst_format = 0x5; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : dst_format = 0x6; dpw = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : dst_format = 0x8; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : dst_format = 0x9; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : dst_format = 0xa; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : dst_format = 0xb; x_div = 2; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : dst_format = 0x8; dst_cbcr_swp = 1; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : dst_format = 0x9; dst_cbcr_swp = 1; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : dst_format = 0xa; dst_cbcr_swp = 1; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_420_P  : dst_format = 0xb; dst_cbcr_swp = 1; x_div = 2; y_div = 2; break;
 
 	case RGA2_FORMAT_YUYV_422     : dst_format = 0xc; dpw = 2; break;
 	case RGA2_FORMAT_YVYU_422     : dst_format = 0xc; dpw = 2; dst_cbcr_swp = 1; break;
@@ -402,60 +402,60 @@ static void RGA2_set_reg_dst_info(u8 *base, struct rga2_req *msg)
 	case RGA2_FORMAT_VYUY_422     : dst_format = 0xe; dpw = 2; dst_cbcr_swp = 1; break;
 	case RGA2_FORMAT_UYVY_420     : dst_format = 0xf; dpw = 2; break;
 	case RGA2_FORMAT_VYUY_420     : dst_format = 0xf; dpw = 2; dst_cbcr_swp = 1; break;
-    };
-
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_FMT)) | (s_RGA2_DST_INFO_SW_DST_FMT(dst_format)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_RB_SWAP)) | (s_RGA2_DST_INFO_SW_DST_RB_SWAP(dst_rb_swp)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_ALPHA_SWAP)) | (s_RGA2_DST_INFO_SW_ALPHA_SWAP(msg->alpha_swp >> 2)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_UV_SWAP)) | (s_RGA2_DST_INFO_SW_DST_UV_SWAP(dst_cbcr_swp)));
-
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_UP_E)) | (s_RGA2_DST_INFO_SW_DITHER_UP_E(msg->alpha_rop_flag >> 5)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_DOWN_E)) | (s_RGA2_DST_INFO_SW_DITHER_DOWN_E(msg->alpha_rop_flag >> 6)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_MODE)) | (s_RGA2_DST_INFO_SW_DITHER_MODE(msg->dither_mode)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_CSC_MODE)) | (s_RGA2_DST_INFO_SW_DST_CSC_MODE(msg->yuv2rgb_mode >> 4)));
-    reg = ((reg & (~m_RGA2_DST_INFO_SW_CSC_CLIP_MODE)) | (s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(msg->yuv2rgb_mode >> 6)));
-
-
-    *bRGA_DST_INFO = reg;
-
-    s_stride = ((msg->src1.vir_w * spw + 3) & ~3) >> 2;
-    d_stride = ((msg->dst.vir_w * dpw + 3) & ~3) >> 2;
-    d_uv_stride = (d_stride << 2) / x_div;
-
-    *bRGA_DST_VIR_INFO = d_stride | (s_stride << 16);
-    *bRGA_DST_ACT_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
-    s_stride <<= 2;
-	d_stride <<= 2;
-
-    if(((msg->rotate_mode & 0xf) == 0) || ((msg->rotate_mode & 0xf) == 1))
-    {
-        x_mirr = 0;
-        y_mirr = 0;
-    }
-    else
-    {
-        x_mirr = 1;
-        y_mirr = 1;
-    }
-
-    rot_90_flag = msg->rotate_mode & 1;
-    x_mirr = (x_mirr + ((msg->rotate_mode >> 4) & 1)) & 1;
-    y_mirr = (y_mirr + ((msg->rotate_mode >> 5) & 1)) & 1;
-
-    yrgb_addr = (RK_U32)msg->src1.yrgb_addr + (msg->src1.y_offset * s_stride) + (msg->src1.x_offset * spw);
-
-    s_y_lt_addr = yrgb_addr;
-    s_y_ld_addr = yrgb_addr + (msg->src1.act_h - 1) * s_stride;
-    s_y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * spw;
-    s_y_rd_addr = s_y_ld_addr + (msg->dst.act_w - 1) * spw;
-
-    yrgb_addr = (RK_U32)msg->dst.yrgb_addr + (msg->dst.y_offset * d_stride) + (msg->dst.x_offset * dpw);
-    u_addr = (RK_U32)msg->dst.uv_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
-    v_addr = (RK_U32)msg->dst.v_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
-
-    y_lt_addr = yrgb_addr;
-    u_lt_addr = u_addr;
-    v_lt_addr = v_addr;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_FMT)) | (s_RGA2_DST_INFO_SW_DST_FMT(dst_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_RB_SWAP)) | (s_RGA2_DST_INFO_SW_DST_RB_SWAP(dst_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_ALPHA_SWAP)) | (s_RGA2_DST_INFO_SW_ALPHA_SWAP(msg->alpha_swp >> 2)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_UV_SWAP)) | (s_RGA2_DST_INFO_SW_DST_UV_SWAP(dst_cbcr_swp)));
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_UP_E)) | (s_RGA2_DST_INFO_SW_DITHER_UP_E(msg->alpha_rop_flag >> 5)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_DOWN_E)) | (s_RGA2_DST_INFO_SW_DITHER_DOWN_E(msg->alpha_rop_flag >> 6)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_MODE)) | (s_RGA2_DST_INFO_SW_DITHER_MODE(msg->dither_mode)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_CSC_MODE)) | (s_RGA2_DST_INFO_SW_DST_CSC_MODE(msg->yuv2rgb_mode >> 4)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_CSC_CLIP_MODE)) | (s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(msg->yuv2rgb_mode >> 6)));
+
+
+    *bRGA_DST_INFO = reg;
+
+    s_stride = ((msg->src1.vir_w * spw + 3) & ~3) >> 2;
+    d_stride = ((msg->dst.vir_w * dpw + 3) & ~3) >> 2;
+    d_uv_stride = (d_stride << 2) / x_div;
+
+    *bRGA_DST_VIR_INFO = d_stride | (s_stride << 16);
+    *bRGA_DST_ACT_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
+    s_stride <<= 2;
+	d_stride <<= 2;
+
+    if(((msg->rotate_mode & 0xf) == 0) || ((msg->rotate_mode & 0xf) == 1))
+    {
+        x_mirr = 0;
+        y_mirr = 0;
+    }
+    else
+    {
+        x_mirr = 1;
+        y_mirr = 1;
+    }
+
+    rot_90_flag = msg->rotate_mode & 1;
+    x_mirr = (x_mirr + ((msg->rotate_mode >> 4) & 1)) & 1;
+    y_mirr = (y_mirr + ((msg->rotate_mode >> 5) & 1)) & 1;
+
+    yrgb_addr = (RK_U32)msg->src1.yrgb_addr + (msg->src1.y_offset * s_stride) + (msg->src1.x_offset * spw);
+
+    s_y_lt_addr = yrgb_addr;
+    s_y_ld_addr = yrgb_addr + (msg->src1.act_h - 1) * s_stride;
+    s_y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * spw;
+    s_y_rd_addr = s_y_ld_addr + (msg->dst.act_w - 1) * spw;
+
+    yrgb_addr = (RK_U32)msg->dst.yrgb_addr + (msg->dst.y_offset * d_stride) + (msg->dst.x_offset * dpw);
+    u_addr = (RK_U32)msg->dst.uv_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
+    v_addr = (RK_U32)msg->dst.v_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
+
+    y_lt_addr = yrgb_addr;
+    u_lt_addr = u_addr;
+    v_lt_addr = v_addr;
 
 	if (msg->dst.format < 0x18) {
 		/* 270 degree & Mirror V*/
@@ -498,504 +498,504 @@ static void RGA2_set_reg_dst_info(u8 *base, struct rga2_req *msg)
 			v_rd_addr = 0;
 		}
 	}
-    if(rot_90_flag == 0)
-    {
-        if(y_mirr == 1)
-        {
-            if(x_mirr == 1)
-            {
-                yrgb_addr = y_rd_addr;
-                u_addr = u_rd_addr;
-                v_addr = v_rd_addr;
-
-                s_yrgb_addr = s_y_rd_addr;
-            }
-            else
-            {
-                yrgb_addr = y_ld_addr;
-                u_addr = u_ld_addr;
-                v_addr = v_ld_addr;
-
-                s_yrgb_addr = s_y_ld_addr;
-            }
-        }
-        else
-        {
-            if(x_mirr == 1)
-            {
-                yrgb_addr = y_rt_addr;
-                u_addr = u_rt_addr;
-                v_addr = v_rt_addr;
-
-                s_yrgb_addr = s_y_rt_addr;
-            }
-            else
-            {
-                yrgb_addr = y_lt_addr;
-                u_addr = u_lt_addr;
-                v_addr = v_lt_addr;
-
-                s_yrgb_addr = s_y_lt_addr;
-            }
-        }
-    }
-    else
-    {
-        if(y_mirr == 1)
-        {
-            if(x_mirr == 1)
-            {
-                yrgb_addr = y_ld_addr;
-                u_addr = u_ld_addr;
-                v_addr = v_ld_addr;
-
-                s_yrgb_addr = s_y_ld_addr;
-            }
-            else
-            {
-                yrgb_addr = y_rd_addr;
-                u_addr = u_rd_addr;
-                v_addr = v_rd_addr;
-
-                s_yrgb_addr = s_y_rd_addr;
-            }
-        }
-        else
-        {
-            if(x_mirr == 1)
-            {
-                yrgb_addr = y_lt_addr;
-                u_addr = u_lt_addr;
-                v_addr = v_lt_addr;
-
-                s_yrgb_addr = s_y_lt_addr;
-            }
-            else
-            {
-                yrgb_addr = y_rt_addr;
-                u_addr = u_rt_addr;
-                v_addr = v_rt_addr;
-
-                s_yrgb_addr = s_y_rt_addr;
-            }
-        }
-    }
-
-    *bRGA_DST_BASE0 = (RK_U32)yrgb_addr;
-
-    if((msg->dst.format == RGA2_FORMAT_YCbCr_420_P) || (msg->dst.format == RGA2_FORMAT_YCrCb_420_P))
-    {
-        if(dst_cbcr_swp == 0) {
-            *bRGA_DST_BASE1 = (RK_U32)v_addr;
-            *bRGA_DST_BASE2 = (RK_U32)u_addr;
-        }
-        else {
-            *bRGA_DST_BASE1 = (RK_U32)u_addr;
-            *bRGA_DST_BASE2 = (RK_U32)v_addr;
-        }
-    }
-    else {
-        *bRGA_DST_BASE1 = (RK_U32)u_addr;
-        *bRGA_DST_BASE2 = (RK_U32)v_addr;
-    }
+    if(rot_90_flag == 0)
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+            else
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+        }
+    }
+    else
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+        }
+    }
+
+    *bRGA_DST_BASE0 = (RK_U32)yrgb_addr;
+
+    if((msg->dst.format == RGA2_FORMAT_YCbCr_420_P) || (msg->dst.format == RGA2_FORMAT_YCrCb_420_P))
+    {
+        if(dst_cbcr_swp == 0) {
+            *bRGA_DST_BASE1 = (RK_U32)v_addr;
+            *bRGA_DST_BASE2 = (RK_U32)u_addr;
+        }
+        else {
+            *bRGA_DST_BASE1 = (RK_U32)u_addr;
+            *bRGA_DST_BASE2 = (RK_U32)v_addr;
+        }
+    }
+    else {
+        *bRGA_DST_BASE1 = (RK_U32)u_addr;
+        *bRGA_DST_BASE2 = (RK_U32)v_addr;
+    }
 
 	if (msg->dst.format >= 0x18) {
 		*bRGA_DST_BASE1 = msg->dst.x_offset;
 	}
-    *bRGA_SRC_BASE3 = (RK_U32)s_y_lt_addr;
-}
-
+    *bRGA_SRC_BASE3 = (RK_U32)s_y_lt_addr;
+}
+
 static void RGA2_set_reg_alpha_info(u8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_ALPHA_CTRL0;
-    RK_U32 *bRGA_ALPHA_CTRL1;
-    RK_U32 *bRGA_FADING_CTRL;
-    RK_U32 reg0 = 0;
-    RK_U32 reg1 = 0;
-
-    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
-    bRGA_ALPHA_CTRL1 = (RK_U32 *)(base + RGA2_ALPHA_CTRL1_OFFSET);
-    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
-
-    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(msg->alpha_rop_flag)));
-    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(msg->alpha_rop_flag >> 1)));
-    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ROP_MODE)) | (s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(msg->rop_mode)));
-    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(msg->src_a_global_val)));
-    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(msg->dst_a_global_val)));
-
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(msg->alpha_mode_0 >> 15)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(msg->alpha_mode_0 >> 7)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(msg->alpha_mode_0 >> 12)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(msg->alpha_mode_0 >> 4)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(msg->alpha_mode_0 >> 11)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(msg->alpha_mode_0 >> 3)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(msg->alpha_mode_0 >> 9)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(msg->alpha_mode_0 >> 1)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(msg->alpha_mode_0 >> 8)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(msg->alpha_mode_0 >> 0)));
-
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(msg->alpha_mode_1 >> 12)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(msg->alpha_mode_1 >> 4)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(msg->alpha_mode_1 >> 11)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(msg->alpha_mode_1 >> 3)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(msg->alpha_mode_1 >> 9)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(msg->alpha_mode_1 >> 1)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(msg->alpha_mode_1 >> 8)));
-    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(msg->alpha_mode_1 >> 0)));
-
-    *bRGA_ALPHA_CTRL0 = reg0;
-    *bRGA_ALPHA_CTRL1 = reg1;
-
-    if((msg->alpha_rop_flag>>2)&1)
-    {
-        *bRGA_FADING_CTRL = (1<<24) | (msg->fading_b_value<<16) | (msg->fading_g_value<<8) | (msg->fading_r_value);
-    }
-}
-
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ALPHA_CTRL1;
+    RK_U32 *bRGA_FADING_CTRL;
+    RK_U32 reg0 = 0;
+    RK_U32 reg1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ALPHA_CTRL1 = (RK_U32 *)(base + RGA2_ALPHA_CTRL1_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(msg->alpha_rop_flag)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(msg->alpha_rop_flag >> 1)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ROP_MODE)) | (s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(msg->rop_mode)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(msg->src_a_global_val)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(msg->dst_a_global_val)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(msg->alpha_mode_0 >> 15)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(msg->alpha_mode_0 >> 7)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(msg->alpha_mode_0 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(msg->alpha_mode_0 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(msg->alpha_mode_0 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(msg->alpha_mode_0 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(msg->alpha_mode_0 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(msg->alpha_mode_0 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(msg->alpha_mode_0 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(msg->alpha_mode_0 >> 0)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(msg->alpha_mode_1 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(msg->alpha_mode_1 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(msg->alpha_mode_1 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(msg->alpha_mode_1 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(msg->alpha_mode_1 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(msg->alpha_mode_1 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(msg->alpha_mode_1 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(msg->alpha_mode_1 >> 0)));
+
+    *bRGA_ALPHA_CTRL0 = reg0;
+    *bRGA_ALPHA_CTRL1 = reg1;
+
+    if((msg->alpha_rop_flag>>2)&1)
+    {
+        *bRGA_FADING_CTRL = (1<<24) | (msg->fading_b_value<<16) | (msg->fading_g_value<<8) | (msg->fading_r_value);
+    }
+}
+
 static void RGA2_set_reg_rop_info(u8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_ALPHA_CTRL0;
-    RK_U32 *bRGA_ROP_CTRL0;
-    RK_U32 *bRGA_ROP_CTRL1;
-    RK_U32 *bRGA_MASK_ADDR;
-    RK_U32 *bRGA_FG_COLOR;
-    RK_U32 *bRGA_PAT_CON;
-
-    RK_U32 rop_code0 = 0;
-    RK_U32 rop_code1 = 0;
-
-    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
-    bRGA_ROP_CTRL0 = (RK_U32 *)(base + RGA2_ROP_CTRL0_OFFSET);
-    bRGA_ROP_CTRL1 = (RK_U32 *)(base + RGA2_ROP_CTRL1_OFFSET);
-	bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
-    bRGA_FG_COLOR  = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
-    bRGA_PAT_CON   = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
-
-    if(msg->rop_mode == 0) {
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL1;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_FG_COLOR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 rop_code0 = 0;
+    RK_U32 rop_code1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ROP_CTRL0 = (RK_U32 *)(base + RGA2_ROP_CTRL0_OFFSET);
+    bRGA_ROP_CTRL1 = (RK_U32 *)(base + RGA2_ROP_CTRL1_OFFSET);
+	bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FG_COLOR  = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_PAT_CON   = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    if(msg->rop_mode == 0) {
 	rop_code0 = RGA2_ROP3_code[(msg->rop_code & 0xff)];
-    }
-    else if(msg->rop_mode == 1) {
+    }
+    else if(msg->rop_mode == 1) {
 	rop_code0 = RGA2_ROP3_code[(msg->rop_code & 0xff)];
-    }
-    else if(msg->rop_mode == 2) {
+    }
+    else if(msg->rop_mode == 2) {
 	rop_code0 = RGA2_ROP3_code[(msg->rop_code & 0xff)];
 	rop_code1 = RGA2_ROP3_code[(msg->rop_code & 0xff00)>>8];
-    }
-
-    *bRGA_ROP_CTRL0 = rop_code0;
-    *bRGA_ROP_CTRL1 = rop_code1;
-    *bRGA_FG_COLOR = msg->fg_color;
-    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
-    *bRGA_PAT_CON = (msg->pat.act_w-1) | ((msg->pat.act_h-1) << 8)
-                     | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
-    *bRGA_ALPHA_CTRL0 = *bRGA_ALPHA_CTRL0 | (((msg->endian_mode >> 1) & 1) << 20);
-
-}
-
+    }
+
+    *bRGA_ROP_CTRL0 = rop_code0;
+    *bRGA_ROP_CTRL1 = rop_code1;
+    *bRGA_FG_COLOR = msg->fg_color;
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+    *bRGA_PAT_CON = (msg->pat.act_w-1) | ((msg->pat.act_h-1) << 8)
+                     | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    *bRGA_ALPHA_CTRL0 = *bRGA_ALPHA_CTRL0 | (((msg->endian_mode >> 1) & 1) << 20);
+
+}
+
 static void RGA2_set_reg_color_palette(RK_U8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_INFO, *bRGA_SRC_VIR_INFO, *bRGA_SRC_ACT_INFO, *bRGA_SRC_FG_COLOR, *bRGA_SRC_BG_COLOR;
-    RK_U32  *p;
-    RK_S16  x_off, y_off;
-    RK_U16  src_stride;
-    RK_U8   shift;
-    RK_U32  sw;
-    RK_U32  byte_num;
-    RK_U32 reg;
-
-    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
-	bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
-    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
-    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
-    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
-    bRGA_SRC_BG_COLOR = (RK_U32 *)(base + RGA2_SRC_BG_COLOR_OFFSET);
-
-    reg = 0;
-
-    shift = 3 - msg->palette_mode;
-
-    x_off = msg->src.x_offset;
-    y_off = msg->src.y_offset;
-
-    sw = msg->src.vir_w;
-    byte_num = sw >> shift;
-
-    src_stride = (byte_num + 3) & (~3);
-
-    p = (RK_U32 *)((unsigned long)msg->src.yrgb_addr);
-
-    #if 0
-    if(endian_mode)
-    {
-        p = p + (x_off>>shift) + y_off*src_stride;
-    }
-    else
-    {
-        p = p + (((x_off>>shift)>>2)<<2) + (3 - ((x_off>>shift) & 3)) + y_off*src_stride;
-    }
-    #endif
-
-    p = p + (x_off>>shift) + y_off*src_stride;
-
-
-    *bRGA_SRC_BASE0 = (unsigned long)p;
-
-	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT((msg->palette_mode | 0xc))));
-    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN)) | (s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(msg->endian_mode & 1)));
-    *bRGA_SRC_VIR_INFO = src_stride >> 2;
-    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
-    *bRGA_SRC_INFO = reg;
-
-    *bRGA_SRC_FG_COLOR = msg->fg_color;
-    *bRGA_SRC_BG_COLOR = msg->bg_color;
-
-}
-
+{
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_INFO, *bRGA_SRC_VIR_INFO, *bRGA_SRC_ACT_INFO, *bRGA_SRC_FG_COLOR, *bRGA_SRC_BG_COLOR;
+    RK_U32  *p;
+    RK_S16  x_off, y_off;
+    RK_U16  src_stride;
+    RK_U8   shift;
+    RK_U32  sw;
+    RK_U32  byte_num;
+    RK_U32 reg;
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+	bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_SRC_BG_COLOR = (RK_U32 *)(base + RGA2_SRC_BG_COLOR_OFFSET);
+
+    reg = 0;
+
+    shift = 3 - msg->palette_mode;
+
+    x_off = msg->src.x_offset;
+    y_off = msg->src.y_offset;
+
+    sw = msg->src.vir_w;
+    byte_num = sw >> shift;
+
+    src_stride = (byte_num + 3) & (~3);
+
+    p = (RK_U32 *)((unsigned long)msg->src.yrgb_addr);
+
+    #if 0
+    if(endian_mode)
+    {
+        p = p + (x_off>>shift) + y_off*src_stride;
+    }
+    else
+    {
+        p = p + (((x_off>>shift)>>2)<<2) + (3 - ((x_off>>shift) & 3)) + y_off*src_stride;
+    }
+    #endif
+
+    p = p + (x_off>>shift) + y_off*src_stride;
+
+
+    *bRGA_SRC_BASE0 = (unsigned long)p;
+
+	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT((msg->palette_mode | 0xc))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN)) | (s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(msg->endian_mode & 1)));
+    *bRGA_SRC_VIR_INFO = src_stride >> 2;
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+    *bRGA_SRC_INFO = reg;
+
+    *bRGA_SRC_FG_COLOR = msg->fg_color;
+    *bRGA_SRC_BG_COLOR = msg->bg_color;
+
+}
+
 static void RGA2_set_reg_color_fill(u8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_CF_GR_A;
-    RK_U32 *bRGA_CF_GR_B;
-    RK_U32 *bRGA_CF_GR_G;
-    RK_U32 *bRGA_CF_GR_R;
-    RK_U32 *bRGA_SRC_FG_COLOR;
-    RK_U32 *bRGA_MASK_ADDR;
-    RK_U32 *bRGA_PAT_CON;
-
-    RK_U32 mask_stride;
-    RK_U32 *bRGA_SRC_VIR_INFO;
-
-    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
-
-    bRGA_CF_GR_A = (RK_U32 *)(base + RGA2_CF_GR_A_OFFSET);
-    bRGA_CF_GR_B = (RK_U32 *)(base + RGA2_CF_GR_B_OFFSET);
-    bRGA_CF_GR_G = (RK_U32 *)(base + RGA2_CF_GR_G_OFFSET);
-    bRGA_CF_GR_R = (RK_U32 *)(base + RGA2_CF_GR_R_OFFSET);
-
-    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
-    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
-
-    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
-
-    mask_stride = msg->rop_mask_stride;
-
-    if(msg->color_fill_mode == 0)
-    {
-        /* solid color */
-        *bRGA_CF_GR_A = (msg->gr_color.gr_x_a & 0xffff) | (msg->gr_color.gr_y_a << 16);
-        *bRGA_CF_GR_B = (msg->gr_color.gr_x_b & 0xffff) | (msg->gr_color.gr_y_b << 16);
-        *bRGA_CF_GR_G = (msg->gr_color.gr_x_g & 0xffff) | (msg->gr_color.gr_y_g << 16);
-        *bRGA_CF_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
-
-        *bRGA_SRC_FG_COLOR = msg->fg_color;
-    }
-    else
-    {
-        /* patten color */
-        *bRGA_MASK_ADDR = (RK_U32)msg->pat.yrgb_addr;
-        *bRGA_PAT_CON = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8)
-                       | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
-    }
-	*bRGA_SRC_VIR_INFO = mask_stride << 16;
-}
-
+{
+    RK_U32 *bRGA_CF_GR_A;
+    RK_U32 *bRGA_CF_GR_B;
+    RK_U32 *bRGA_CF_GR_G;
+    RK_U32 *bRGA_CF_GR_R;
+    RK_U32 *bRGA_SRC_FG_COLOR;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 mask_stride;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+
+    bRGA_CF_GR_A = (RK_U32 *)(base + RGA2_CF_GR_A_OFFSET);
+    bRGA_CF_GR_B = (RK_U32 *)(base + RGA2_CF_GR_B_OFFSET);
+    bRGA_CF_GR_G = (RK_U32 *)(base + RGA2_CF_GR_G_OFFSET);
+    bRGA_CF_GR_R = (RK_U32 *)(base + RGA2_CF_GR_R_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+
+    mask_stride = msg->rop_mask_stride;
+
+    if(msg->color_fill_mode == 0)
+    {
+        /* solid color */
+        *bRGA_CF_GR_A = (msg->gr_color.gr_x_a & 0xffff) | (msg->gr_color.gr_y_a << 16);
+        *bRGA_CF_GR_B = (msg->gr_color.gr_x_b & 0xffff) | (msg->gr_color.gr_y_b << 16);
+        *bRGA_CF_GR_G = (msg->gr_color.gr_x_g & 0xffff) | (msg->gr_color.gr_y_g << 16);
+        *bRGA_CF_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
+
+        *bRGA_SRC_FG_COLOR = msg->fg_color;
+    }
+    else
+    {
+        /* patten color */
+        *bRGA_MASK_ADDR = (RK_U32)msg->pat.yrgb_addr;
+        *bRGA_PAT_CON = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8)
+                       | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    }
+	*bRGA_SRC_VIR_INFO = mask_stride << 16;
+}
+
 static void RGA2_set_reg_update_palette_table(RK_U8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_MASK_BASE;
-    RK_U32 *bRGA_FADING_CTRL;
-
-    bRGA_MASK_BASE  = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
-    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
-
-    *bRGA_FADING_CTRL = msg->fading_g_value << 8;
-    *bRGA_MASK_BASE = (RK_U32)msg->pat.yrgb_addr;
-}
-
-
+{
+    RK_U32 *bRGA_MASK_BASE;
+    RK_U32 *bRGA_FADING_CTRL;
+
+    bRGA_MASK_BASE  = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_FADING_CTRL = msg->fading_g_value << 8;
+    *bRGA_MASK_BASE = (RK_U32)msg->pat.yrgb_addr;
+}
+
+
 static void RGA2_set_reg_update_patten_buff(RK_U8 *base, struct rga2_req *msg)
-{
-    u32 *bRGA_PAT_MST;
-    u32 *bRGA_PAT_CON;
-    u32 *bRGA_PAT_START_POINT;
-    RK_U32 *bRGA_FADING_CTRL;
-    u32 reg = 0;
-    rga_img_info_t *pat;
-
-    RK_U32 num, offset;
-
-    pat = &msg->pat;
-
-    num = (pat->act_w * pat->act_h) - 1;
-
-    offset = pat->act_w * pat->y_offset + pat->x_offset;
-
-    bRGA_PAT_START_POINT = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
-    bRGA_PAT_MST = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
-    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
-    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
-
-    *bRGA_PAT_MST = (RK_U32)msg->pat.yrgb_addr;
-    *bRGA_PAT_START_POINT = (pat->act_w * pat->y_offset) + pat->x_offset;
-
-    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
-    *bRGA_PAT_CON = reg;
-
-    *bRGA_FADING_CTRL = (num << 8) | offset;
-}
-
+{
+    u32 *bRGA_PAT_MST;
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_PAT_START_POINT;
+    RK_U32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = (pat->act_w * pat->act_h) - 1;
+
+    offset = pat->act_w * pat->y_offset + pat->x_offset;
+
+    bRGA_PAT_START_POINT = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+    bRGA_PAT_MST = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_PAT_MST = (RK_U32)msg->pat.yrgb_addr;
+    *bRGA_PAT_START_POINT = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    *bRGA_FADING_CTRL = (num << 8) | offset;
+}
+
 static void RGA2_set_pat_info(RK_U8 *base, struct rga2_req *msg)
-{
-    u32 *bRGA_PAT_CON;
-    u32 *bRGA_FADING_CTRL;
-    u32 reg = 0;
-    rga_img_info_t *pat;
-
-    RK_U32 num, offset;
-
-    pat = &msg->pat;
-
-    num = ((pat->act_w * pat->act_h) - 1) & 0xff;
-
-    offset = (pat->act_w * pat->y_offset) + pat->x_offset;
-
-    bRGA_PAT_CON     = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
-    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
-
-    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
-    *bRGA_PAT_CON = reg;
-    *bRGA_FADING_CTRL = (num << 8) | offset;
-}
-
+{
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = ((pat->act_w * pat->act_h) - 1) & 0xff;
+
+    offset = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    bRGA_PAT_CON     = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+    *bRGA_FADING_CTRL = (num << 8) | offset;
+}
+
 static void RGA2_set_mmu_info(RK_U8 *base, struct rga2_req *msg)
-{
-    RK_U32 *bRGA_MMU_CTRL1;
-    RK_U32 *bRGA_MMU_SRC_BASE;
-    RK_U32 *bRGA_MMU_SRC1_BASE;
-    RK_U32 *bRGA_MMU_DST_BASE;
-    RK_U32 *bRGA_MMU_ELS_BASE;
-
-    RK_U32 reg;
-
-    bRGA_MMU_CTRL1 = (RK_U32 *)(base + RGA2_MMU_CTRL1_OFFSET);
-    bRGA_MMU_SRC_BASE = (RK_U32 *)(base + RGA2_MMU_SRC_BASE_OFFSET);
-    bRGA_MMU_SRC1_BASE = (RK_U32 *)(base + RGA2_MMU_SRC1_BASE_OFFSET);
-    bRGA_MMU_DST_BASE = (RK_U32 *)(base + RGA2_MMU_DST_BASE_OFFSET);
-    bRGA_MMU_ELS_BASE = (RK_U32 *)(base + RGA2_MMU_ELS_BASE_OFFSET);
-
-    reg = (msg->mmu_info.src0_mmu_flag & 0xf) | ((msg->mmu_info.src1_mmu_flag & 0xf) << 4)
-         | ((msg->mmu_info.dst_mmu_flag & 0xf) << 8) | ((msg->mmu_info.els_mmu_flag & 0x3) << 12);
-
-    *bRGA_MMU_CTRL1 = reg;
-    *bRGA_MMU_SRC_BASE  = (RK_U32)(msg->mmu_info.src0_base_addr) >> 4;
-    *bRGA_MMU_SRC1_BASE = (RK_U32)(msg->mmu_info.src1_base_addr) >> 4;
-    *bRGA_MMU_DST_BASE  = (RK_U32)(msg->mmu_info.dst_base_addr)  >> 4;
-    *bRGA_MMU_ELS_BASE  = (RK_U32)(msg->mmu_info.els_base_addr)  >> 4;
-}
-
-
-int
-RGA2_gen_reg_info(RK_U8 *base , struct rga2_req *msg)
-{
-
-    RGA2_set_mode_ctrl(base, msg);
-
-    RGA2_set_pat_info(base, msg);
-
-    switch(msg->render_mode)
-    {
-        case bitblt_mode:
-            RGA2_set_reg_src_info(base, msg);
-            RGA2_set_reg_dst_info(base, msg);
-            RGA2_set_reg_alpha_info(base, msg);
-            RGA2_set_reg_rop_info(base, msg);
-            break;
-        case color_fill_mode :
-            RGA2_set_reg_color_fill(base, msg);
-            RGA2_set_reg_dst_info(base, msg);
-            RGA2_set_reg_alpha_info(base, msg);
-            break;
-        case color_palette_mode :
-            RGA2_set_reg_color_palette(base, msg);
-            RGA2_set_reg_dst_info(base, msg);
-            break;
-        case update_palette_table_mode :
-            RGA2_set_reg_update_palette_table(base, msg);
-            break;
-        case update_patten_buff_mode :
-            RGA2_set_reg_update_patten_buff(base, msg);
-            break;
-        default :
-            printk("RGA2 ERROR msg render mode %d \n", msg->render_mode);
-            break;
-
-    }
-
-    RGA2_set_mmu_info(base, msg);
-
-    return 0;
-
-}
-
+{
+    RK_U32 *bRGA_MMU_CTRL1;
+    RK_U32 *bRGA_MMU_SRC_BASE;
+    RK_U32 *bRGA_MMU_SRC1_BASE;
+    RK_U32 *bRGA_MMU_DST_BASE;
+    RK_U32 *bRGA_MMU_ELS_BASE;
+
+    RK_U32 reg;
+
+    bRGA_MMU_CTRL1 = (RK_U32 *)(base + RGA2_MMU_CTRL1_OFFSET);
+    bRGA_MMU_SRC_BASE = (RK_U32 *)(base + RGA2_MMU_SRC_BASE_OFFSET);
+    bRGA_MMU_SRC1_BASE = (RK_U32 *)(base + RGA2_MMU_SRC1_BASE_OFFSET);
+    bRGA_MMU_DST_BASE = (RK_U32 *)(base + RGA2_MMU_DST_BASE_OFFSET);
+    bRGA_MMU_ELS_BASE = (RK_U32 *)(base + RGA2_MMU_ELS_BASE_OFFSET);
+
+    reg = (msg->mmu_info.src0_mmu_flag & 0xf) | ((msg->mmu_info.src1_mmu_flag & 0xf) << 4)
+         | ((msg->mmu_info.dst_mmu_flag & 0xf) << 8) | ((msg->mmu_info.els_mmu_flag & 0x3) << 12);
+
+    *bRGA_MMU_CTRL1 = reg;
+    *bRGA_MMU_SRC_BASE  = (RK_U32)(msg->mmu_info.src0_base_addr) >> 4;
+    *bRGA_MMU_SRC1_BASE = (RK_U32)(msg->mmu_info.src1_base_addr) >> 4;
+    *bRGA_MMU_DST_BASE  = (RK_U32)(msg->mmu_info.dst_base_addr)  >> 4;
+    *bRGA_MMU_ELS_BASE  = (RK_U32)(msg->mmu_info.els_base_addr)  >> 4;
+}
+
+
+int
+RGA2_gen_reg_info(RK_U8 *base , struct rga2_req *msg)
+{
+
+    RGA2_set_mode_ctrl(base, msg);
+
+    RGA2_set_pat_info(base, msg);
+
+    switch(msg->render_mode)
+    {
+        case bitblt_mode:
+            RGA2_set_reg_src_info(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            RGA2_set_reg_rop_info(base, msg);
+            break;
+        case color_fill_mode :
+            RGA2_set_reg_color_fill(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            break;
+        case color_palette_mode :
+            RGA2_set_reg_color_palette(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            break;
+        case update_palette_table_mode :
+            RGA2_set_reg_update_palette_table(base, msg);
+            break;
+        case update_patten_buff_mode :
+            RGA2_set_reg_update_patten_buff(base, msg);
+            break;
+        default :
+            printk("RGA2 ERROR msg render mode %d \n", msg->render_mode);
+            break;
+
+    }
+
+    RGA2_set_mmu_info(base, msg);
+
+    return 0;
+
+}
+
 static void format_name_convert(uint32_t *df, uint32_t sf)
-{
-    /*
-    RK_FORMAT_RGBA_8888    = 0x0,
-    RK_FORMAT_RGBX_8888    = 0x1,
-    RK_FORMAT_RGB_888      = 0x2,
-    RK_FORMAT_BGRA_8888    = 0x3,
-    RK_FORMAT_RGB_565      = 0x4,
-    RK_FORMAT_RGBA_5551    = 0x5,
-    RK_FORMAT_RGBA_4444    = 0x6,
-    RK_FORMAT_BGR_888      = 0x7,
-
-    RK_FORMAT_YCbCr_422_SP = 0x8,
-    RK_FORMAT_YCbCr_422_P  = 0x9,
-    RK_FORMAT_YCbCr_420_SP = 0xa,
-    RK_FORMAT_YCbCr_420_P  = 0xb,
-
-    RK_FORMAT_YCrCb_422_SP = 0xc,
-    RK_FORMAT_YCrCb_422_P  = 0xd,
-    RK_FORMAT_YCrCb_420_SP = 0xe,
-    RK_FORMAT_YCrCb_420_P  = 0xf,
-
-    RGA2_FORMAT_RGBA_8888    = 0x0,
-    RGA2_FORMAT_RGBX_8888    = 0x1,
-    RGA2_FORMAT_RGB_888      = 0x2,
-    RGA2_FORMAT_BGRA_8888    = 0x3,
-    RGA2_FORMAT_BGRX_8888    = 0x4,
-    RGA2_FORMAT_BGR_888      = 0x5,
-    RGA2_FORMAT_RGB_565      = 0x6,
-    RGA2_FORMAT_RGBA_5551    = 0x7,
-    RGA2_FORMAT_RGBA_4444    = 0x8,
-    RGA2_FORMAT_BGR_565      = 0x9,
-    RGA2_FORMAT_BGRA_5551    = 0xa,
-    RGA2_FORMAT_BGRA_4444    = 0xb,
-
-    RGA2_FORMAT_YCbCr_422_SP = 0x10,
-    RGA2_FORMAT_YCbCr_422_P  = 0x11,
-    RGA2_FORMAT_YCbCr_420_SP = 0x12,
-    RGA2_FORMAT_YCbCr_420_P  = 0x13,
-    RGA2_FORMAT_YCrCb_422_SP = 0x14,
-    RGA2_FORMAT_YCrCb_422_P  = 0x15,
-    RGA2_FORMAT_YCrCb_420_SP = 0x16,
-    RGA2_FORMAT_YCrCb_420_P  = 0x17,*/
-    switch(sf)
-    {
-        case 0x0: *df = RGA2_FORMAT_RGBA_8888; break;
-        case 0x1: *df = RGA2_FORMAT_RGBX_8888; break;
-        case 0x2: *df = RGA2_FORMAT_RGB_888; break;
-        case 0x3: *df = RGA2_FORMAT_BGRA_8888; break;
-        case 0x4: *df = RGA2_FORMAT_RGB_565; break;
-        case 0x5: *df = RGA2_FORMAT_RGBA_5551; break;
-        case 0x6: *df = RGA2_FORMAT_RGBA_4444; break;
-        case 0x7: *df = RGA2_FORMAT_BGR_888; break;
-        case 0x8: *df = RGA2_FORMAT_YCbCr_422_SP; break;
-        case 0x9: *df = RGA2_FORMAT_YCbCr_422_P; break;
-        case 0xa: *df = RGA2_FORMAT_YCbCr_420_SP; break;
-        case 0xb: *df = RGA2_FORMAT_YCbCr_420_P; break;
-        case 0xc: *df = RGA2_FORMAT_YCrCb_422_SP; break;
-        case 0xd: *df = RGA2_FORMAT_YCrCb_422_P; break;
-        case 0xe: *df = RGA2_FORMAT_YCrCb_420_SP; break;
-        case 0xf: *df = RGA2_FORMAT_YCrCb_420_P; break;
+{
+    /*
+    RK_FORMAT_RGBA_8888    = 0x0,
+    RK_FORMAT_RGBX_8888    = 0x1,
+    RK_FORMAT_RGB_888      = 0x2,
+    RK_FORMAT_BGRA_8888    = 0x3,
+    RK_FORMAT_RGB_565      = 0x4,
+    RK_FORMAT_RGBA_5551    = 0x5,
+    RK_FORMAT_RGBA_4444    = 0x6,
+    RK_FORMAT_BGR_888      = 0x7,
+
+    RK_FORMAT_YCbCr_422_SP = 0x8,
+    RK_FORMAT_YCbCr_422_P  = 0x9,
+    RK_FORMAT_YCbCr_420_SP = 0xa,
+    RK_FORMAT_YCbCr_420_P  = 0xb,
+
+    RK_FORMAT_YCrCb_422_SP = 0xc,
+    RK_FORMAT_YCrCb_422_P  = 0xd,
+    RK_FORMAT_YCrCb_420_SP = 0xe,
+    RK_FORMAT_YCrCb_420_P  = 0xf,
+
+    RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,*/
+    switch(sf)
+    {
+        case 0x0: *df = RGA2_FORMAT_RGBA_8888; break;
+        case 0x1: *df = RGA2_FORMAT_RGBX_8888; break;
+        case 0x2: *df = RGA2_FORMAT_RGB_888; break;
+        case 0x3: *df = RGA2_FORMAT_BGRA_8888; break;
+        case 0x4: *df = RGA2_FORMAT_RGB_565; break;
+        case 0x5: *df = RGA2_FORMAT_RGBA_5551; break;
+        case 0x6: *df = RGA2_FORMAT_RGBA_4444; break;
+        case 0x7: *df = RGA2_FORMAT_BGR_888; break;
+        case 0x8: *df = RGA2_FORMAT_YCbCr_422_SP; break;
+        case 0x9: *df = RGA2_FORMAT_YCbCr_422_P; break;
+        case 0xa: *df = RGA2_FORMAT_YCbCr_420_SP; break;
+        case 0xb: *df = RGA2_FORMAT_YCbCr_420_P; break;
+        case 0xc: *df = RGA2_FORMAT_YCrCb_422_SP; break;
+        case 0xd: *df = RGA2_FORMAT_YCrCb_422_P; break;
+        case 0xe: *df = RGA2_FORMAT_YCrCb_420_SP; break;
+        case 0xf: *df = RGA2_FORMAT_YCrCb_420_P; break;
 
 	case 0x18: *df = RGA2_FORMAT_YVYU_422; break;
 	case 0x19: *df = RGA2_FORMAT_YVYU_420; break;
@@ -1006,13 +1006,13 @@ static void format_name_convert(uint32_t *df, uint32_t sf)
 	case 0x1e: *df = RGA2_FORMAT_UYVY_422; break;
 	case 0x1f: *df = RGA2_FORMAT_UYVY_420; break;
 
-        case 0x20:*df = RGA2_FORMAT_YCbCr_420_SP_10B; break;
-        case 0x21:*df = RGA2_FORMAT_YCrCb_420_SP_10B; break;
+        case 0x20:*df = RGA2_FORMAT_YCbCr_420_SP_10B; break;
+        case 0x21:*df = RGA2_FORMAT_YCrCb_420_SP_10B; break;
+
+    }
+}
 
-    }
-}
-
-void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req)
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req)
 {
 	u16 alpha_mode_0, alpha_mode_1;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
@@ -1022,221 +1022,221 @@ void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req)
 	req_rga->render_mode &= (~RGA_BUF_GEM_TYPE_MASK);
 #endif
 
-    if (req_rga->render_mode == 6)
-        req->render_mode = update_palette_table_mode;
-    else if (req_rga->render_mode == 7)
-        req->render_mode = update_patten_buff_mode;
-    else if (req_rga->render_mode == 5)
-        req->render_mode = bitblt_mode;
-    else
-        req->render_mode = req_rga->render_mode;
-
-    memcpy(&req->src, &req_rga->src, sizeof(req_rga->src));
-    memcpy(&req->dst, &req_rga->dst, sizeof(req_rga->dst));
-    memcpy(&req->pat, &req_rga->pat, sizeof(req_rga->pat));
-    memcpy(&req->src1,&req_rga->pat, sizeof(req_rga->pat));
-
-    format_name_convert(&req->src.format, req_rga->src.format);
-    format_name_convert(&req->dst.format, req_rga->dst.format);
-
-    if(req_rga->rotate_mode == 1) {
-        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
-            /* rotate 0 */
-            req->rotate_mode = 0;
-        }
-        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
-            /* rotate 90 */
-            req->rotate_mode = 1;
-            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
-            req->dst.act_w = req_rga->dst.act_h;
-            req->dst.act_h = req_rga->dst.act_w;
-        }
-        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
-            /* rotate 180 */
-            req->rotate_mode = 2;
-            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
-            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
-        }
-        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
-            /* totate 270 */
-            req->rotate_mode = 3;
-            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
-            req->dst.act_w = req_rga->dst.act_h;
-            req->dst.act_h = req_rga->dst.act_w;
-        }
-    }
-    else if (req_rga->rotate_mode == 2)
-    {
-        //x_mirror
-        req->rotate_mode |= (1 << 4);
-    }
-    else if (req_rga->rotate_mode == 3)
-    {
-        //y_mirror
-        req->rotate_mode |= (2 << 4);
-    }
-    else {
-        req->rotate_mode = 0;
-    }
-
-    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
-        req->scale_bicu_mode |= (1<<4);
-
-    req->LUT_addr = req_rga->LUT_addr;
-    req->rop_mask_addr = req_rga->rop_mask_addr;
-
-    req->bitblt_mode = req_rga->bsfilter_flag;
-
-    req->src_a_global_val = req_rga->alpha_global_value;
-    req->dst_a_global_val = req_rga->alpha_global_value;
-    req->rop_code = req_rga->rop_code;
-    req->rop_mode = 0;
-
-    req->color_fill_mode = req_rga->color_fill_mode;
-    req->color_key_min   = req_rga->color_key_min;
-    req->color_key_max   = req_rga->color_key_max;
-
-    req->fg_color = req_rga->fg_color;
-    req->bg_color = req_rga->bg_color;
-    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
-
-    req->palette_mode = req_rga->palette_mode;
-    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
-    req->endian_mode = req_rga->endian_mode;
-    req->rgb2yuv_mode = 0;
-
-    req->fading_alpha_value = 0;
-    req->fading_r_value = req_rga->fading.r;
-    req->fading_g_value = req_rga->fading.g;
-    req->fading_b_value = req_rga->fading.b;
-
-    /* alpha mode set */
-    req->alpha_rop_flag = 0;
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
-
-    if (((req_rga->alpha_rop_flag) & 1)) {
-        if ((req_rga->alpha_rop_flag >> 3) & 1) {
-            /* porter duff alpha enable */
-            switch (req_rga->PD_mode)
-            {
-                case 0: //dst = 0
-                    break;
-                case 1: //dst = src
-                    break;
-                case 2: //dst = dst
-                    break;
-                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
-                    if((req_rga->alpha_rop_mode & 3) == 0) {
-                        alpha_mode_0 = 0x3818;
-                        alpha_mode_1 = 0x3818;
-                    }
-                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
-                        alpha_mode_0 = 0x381A;
-                        alpha_mode_1 = 0x381A;
-                    }
-                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
-                        alpha_mode_0 = 0x381C;
-                        alpha_mode_1 = 0x381C;
-                    }
-                    else {
-                        alpha_mode_0 = 0x381A;
-                        alpha_mode_1 = 0x381A;
-                    }
-                    req->alpha_mode_0 = alpha_mode_0;
-                    req->alpha_mode_1 = alpha_mode_1;
-                    break;
-                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
-                    break;
-                case 5: //dst = (da*sc) >> 8
-                    break;
-                case 6: //dst = (sa*dc) >> 8
-                    break;
-                case 7: //dst = ((256-da)*sc) >> 8
-                    break;
-                case 8: //dst = ((256-sa)*dc) >> 8
-                    break;
-                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
-                    req->alpha_mode_0 = 0x3848;
-                    req->alpha_mode_1 = 0x3848;
-                    break;
-                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
-                    break;
-                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
-                    break;
-		case 12:
-		    req->alpha_mode_0 = 0x0010;
-		    req->alpha_mode_1 = 0x0820;
-		    break;
-                default:
-                    break;
-            }
-        }
-        else {
-            if((req_rga->alpha_rop_mode & 3) == 0) {
-                req->alpha_mode_0 = 0x3848;
-                req->alpha_mode_1 = 0x3848;
-            }
-            else if ((req_rga->alpha_rop_mode & 3) == 1) {
+    if (req_rga->render_mode == 6)
+        req->render_mode = update_palette_table_mode;
+    else if (req_rga->render_mode == 7)
+        req->render_mode = update_patten_buff_mode;
+    else if (req_rga->render_mode == 5)
+        req->render_mode = bitblt_mode;
+    else
+        req->render_mode = req_rga->render_mode;
+
+    memcpy(&req->src, &req_rga->src, sizeof(req_rga->src));
+    memcpy(&req->dst, &req_rga->dst, sizeof(req_rga->dst));
+    memcpy(&req->pat, &req_rga->pat, sizeof(req_rga->pat));
+    memcpy(&req->src1,&req_rga->pat, sizeof(req_rga->pat));
+
+    format_name_convert(&req->src.format, req_rga->src.format);
+    format_name_convert(&req->dst.format, req_rga->dst.format);
+
+    if(req_rga->rotate_mode == 1) {
+        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
+            /* rotate 0 */
+            req->rotate_mode = 0;
+        }
+        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
+            /* rotate 90 */
+            req->rotate_mode = 1;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
+            /* rotate 180 */
+            req->rotate_mode = 2;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
+        }
+        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
+            /* totate 270 */
+            req->rotate_mode = 3;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+    }
+    else if (req_rga->rotate_mode == 2)
+    {
+        //x_mirror
+        req->rotate_mode |= (1 << 4);
+    }
+    else if (req_rga->rotate_mode == 3)
+    {
+        //y_mirror
+        req->rotate_mode |= (2 << 4);
+    }
+    else {
+        req->rotate_mode = 0;
+    }
+
+    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
+        req->scale_bicu_mode |= (1<<4);
+
+    req->LUT_addr = req_rga->LUT_addr;
+    req->rop_mask_addr = req_rga->rop_mask_addr;
+
+    req->bitblt_mode = req_rga->bsfilter_flag;
+
+    req->src_a_global_val = req_rga->alpha_global_value;
+    req->dst_a_global_val = req_rga->alpha_global_value;
+    req->rop_code = req_rga->rop_code;
+    req->rop_mode = 0;
+
+    req->color_fill_mode = req_rga->color_fill_mode;
+    req->color_key_min   = req_rga->color_key_min;
+    req->color_key_max   = req_rga->color_key_max;
+
+    req->fg_color = req_rga->fg_color;
+    req->bg_color = req_rga->bg_color;
+    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
+
+    req->palette_mode = req_rga->palette_mode;
+    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
+    req->endian_mode = req_rga->endian_mode;
+    req->rgb2yuv_mode = 0;
+
+    req->fading_alpha_value = 0;
+    req->fading_r_value = req_rga->fading.r;
+    req->fading_g_value = req_rga->fading.g;
+    req->fading_b_value = req_rga->fading.b;
+
+    /* alpha mode set */
+    req->alpha_rop_flag = 0;
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
+
+    if (((req_rga->alpha_rop_flag) & 1)) {
+        if ((req_rga->alpha_rop_flag >> 3) & 1) {
+            /* porter duff alpha enable */
+            switch (req_rga->PD_mode)
+            {
+                case 0: //dst = 0
+                    break;
+                case 1: //dst = src
+                    break;
+                case 2: //dst = dst
+                    break;
+                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
+                    if((req_rga->alpha_rop_mode & 3) == 0) {
+                        alpha_mode_0 = 0x3818;
+                        alpha_mode_1 = 0x3818;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                        alpha_mode_0 = 0x381C;
+                        alpha_mode_1 = 0x381C;
+                    }
+                    else {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    req->alpha_mode_0 = alpha_mode_0;
+                    req->alpha_mode_1 = alpha_mode_1;
+                    break;
+                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
+                    break;
+                case 5: //dst = (da*sc) >> 8
+                    break;
+                case 6: //dst = (sa*dc) >> 8
+                    break;
+                case 7: //dst = ((256-da)*sc) >> 8
+                    break;
+                case 8: //dst = ((256-sa)*dc) >> 8
+                    break;
+                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
+                    req->alpha_mode_0 = 0x3848;
+                    req->alpha_mode_1 = 0x3848;
+                    break;
+                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
+                    break;
+                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
+                    break;
+		case 12:
+		    req->alpha_mode_0 = 0x0010;
+		    req->alpha_mode_1 = 0x0820;
+		    break;
+                default:
+                    break;
+            }
+        }
+        else {
+            if((req_rga->alpha_rop_mode & 3) == 0) {
+                req->alpha_mode_0 = 0x3848;
+                req->alpha_mode_1 = 0x3848;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 1) {
 		req->alpha_mode_0 = 0x384A;
 		req->alpha_mode_1 = 0x3A4A;
-            }
-            else if ((req_rga->alpha_rop_mode & 3) == 2) {
-                req->alpha_mode_0 = 0x384C;
-                req->alpha_mode_1 = 0x384C;
-            }
-        }
-    }
-
-    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
-        req->mmu_info.src0_mmu_flag = 1;
-        req->mmu_info.dst_mmu_flag = 1;
-
-        if (req_rga->mmu_info.mmu_flag >> 31) {
-            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
-            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
-            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
-            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
-        }
-        else {
-            if (req_rga->src.yrgb_addr >= 0xa0000000) {
-               req->mmu_info.src0_mmu_flag = 0;
-               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
-               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
-               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
-            }
-
-            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
-               req->mmu_info.dst_mmu_flag = 0;
-               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
-            }
-        }
-    }
-}
-
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                req->alpha_mode_0 = 0x384C;
+                req->alpha_mode_1 = 0x384C;
+            }
+        }
+    }
+
+    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
+        req->mmu_info.src0_mmu_flag = 1;
+        req->mmu_info.dst_mmu_flag = 1;
+
+        if (req_rga->mmu_info.mmu_flag >> 31) {
+            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
+            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
+            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
+            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
+        }
+        else {
+            if (req_rga->src.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.src0_mmu_flag = 0;
+               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
+               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
+               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
+            }
+
+            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.dst_mmu_flag = 0;
+               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
+            }
+        }
+    }
+}
+
 static void memcpy_img_info(struct rga_img_info_t *dst, struct rga_img_info_32_t *src)
-{
-    dst->yrgb_addr = src->yrgb_addr;      /* yrgb    mem addr         */
-    dst->uv_addr = src->uv_addr;        /* cb/cr   mem addr         */
-    dst->v_addr = src->v_addr;         /* cr      mem addr         */
-    dst->format = src->format;         //definition by RK_FORMAT
-
-    dst->act_w = src->act_w;
-    dst->act_h = src->act_h;
-    dst->x_offset = src->x_offset;
-    dst->y_offset = src->y_offset;
-
-    dst->vir_w = src->vir_w;
-    dst->vir_h = src->vir_h;
-    dst->endian_mode = src->endian_mode; //for BPP
-    dst->alpha_swap = src->alpha_swap;
+{
+    dst->yrgb_addr = src->yrgb_addr;      /* yrgb    mem addr         */
+    dst->uv_addr = src->uv_addr;        /* cb/cr   mem addr         */
+    dst->v_addr = src->v_addr;         /* cr      mem addr         */
+    dst->format = src->format;         //definition by RK_FORMAT
+
+    dst->act_w = src->act_w;
+    dst->act_h = src->act_h;
+    dst->x_offset = src->x_offset;
+    dst->y_offset = src->y_offset;
+
+    dst->vir_w = src->vir_w;
+    dst->vir_h = src->vir_h;
+    dst->endian_mode = src->endian_mode; //for BPP
+    dst->alpha_swap = src->alpha_swap;
 }
 
-void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req)
+void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req)
 {
 	u16 alpha_mode_0, alpha_mode_1;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
@@ -1245,174 +1245,174 @@ void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req)
 
 	req_rga->render_mode &= (~RGA_BUF_GEM_TYPE_MASK);
 #endif
-    if (req_rga->render_mode == 6)
-        req->render_mode = update_palette_table_mode;
-    else if (req_rga->render_mode == 7)
-        req->render_mode = update_patten_buff_mode;
-    else if (req_rga->render_mode == 5)
-        req->render_mode = bitblt_mode;
-    else
-        req->render_mode = req_rga->render_mode;
-    memcpy_img_info(&req->src, &req_rga->src);
-    memcpy_img_info(&req->dst, &req_rga->dst);
-    memcpy_img_info(&req->pat, &req_rga->pat);
-    memcpy_img_info(&req->src1,&req_rga->pat);
-    format_name_convert(&req->src.format, req_rga->src.format);
-    format_name_convert(&req->dst.format, req_rga->dst.format);
-    if(req_rga->rotate_mode == 1) {
-        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
-            req->rotate_mode = 0;
-        }
-        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
-            req->rotate_mode = 1;
-            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
-            req->dst.act_w = req_rga->dst.act_h;
-            req->dst.act_h = req_rga->dst.act_w;
-        }
-        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
-            req->rotate_mode = 2;
-            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
-            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
-        }
-        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
-            req->rotate_mode = 3;
-            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
-            req->dst.act_w = req_rga->dst.act_h;
-            req->dst.act_h = req_rga->dst.act_w;
-        }
-    }
-    else if (req_rga->rotate_mode == 2)
-    {
-        req->rotate_mode = (1 << 4);
-    }
-    else if (req_rga->rotate_mode == 3)
-    {
-        req->rotate_mode = (2 << 4);
-    }
-    else {
-        req->rotate_mode = 0;
-    }
-    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
-        req->scale_bicu_mode |= (1<<4);
-    req->LUT_addr = req_rga->LUT_addr;
-    req->rop_mask_addr = req_rga->rop_mask_addr;
-    req->bitblt_mode = req_rga->bsfilter_flag;
-    req->src_a_global_val = req_rga->alpha_global_value;
-    req->dst_a_global_val = req_rga->alpha_global_value;
-    req->rop_code = req_rga->rop_code;
-    req->rop_mode = 0;
-    req->color_fill_mode = req_rga->color_fill_mode;
-    req->color_key_min   = req_rga->color_key_min;
-    req->color_key_max   = req_rga->color_key_max;
-    req->fg_color = req_rga->fg_color;
-    req->bg_color = req_rga->bg_color;
-    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
-    req->palette_mode = req_rga->palette_mode;
-    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
-    req->endian_mode = req_rga->endian_mode;
-    req->rgb2yuv_mode = 0;
-    req->fading_alpha_value = 0;
-    req->fading_r_value = req_rga->fading.r;
-    req->fading_g_value = req_rga->fading.g;
-    req->fading_b_value = req_rga->fading.b;
-    req->alpha_rop_flag = 0;
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
-    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
-    if(((req_rga->alpha_rop_flag) & 1)) {
-        if((req_rga->alpha_rop_flag >> 3) & 1) {
-            switch(req_rga->PD_mode)
-            {
-                case 0: //dst = 0
-                    break;
-                case 1: //dst = src
-                    break;
-                case 2: //dst = dst
-                    break;
-                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
-                    if((req_rga->alpha_rop_mode & 3) == 0) {
-                        alpha_mode_0 = 0x3818;
-                        alpha_mode_1 = 0x3818;
-                    }
-                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
-                        alpha_mode_0 = 0x381A;
-                        alpha_mode_1 = 0x381A;
-                    }
-                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
-                        alpha_mode_0 = 0x381C;
-                        alpha_mode_1 = 0x381C;
-                    }
-                    else {
-                        alpha_mode_0 = 0x381A;
-                        alpha_mode_1 = 0x381A;
-                    }
-                    req->alpha_mode_0 = alpha_mode_0;
-                    req->alpha_mode_1 = alpha_mode_1;
-                    break;
-                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
-                    break;
-                case 5: //dst = (da*sc) >> 8
-                    break;
-                case 6: //dst = (sa*dc) >> 8
-                    break;
-                case 7: //dst = ((256-da)*sc) >> 8
-                    break;
-                case 8: //dst = ((256-sa)*dc) >> 8
-                    break;
-                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
-                    req->alpha_mode_0 = 0x3848;
-                    req->alpha_mode_1 = 0x3848;
-                    break;
-                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
-                    break;
-                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
-                    break;
-		case 12:
-		    req->alpha_mode_0 = 0x0010;
-		    req->alpha_mode_1 = 0x0820;
-		    break;
-                default:
-                    break;
-            }
-        }
-        else {
-            if((req_rga->alpha_rop_mode & 3) == 0) {
-                req->alpha_mode_0 = 0x3848;
-                req->alpha_mode_1 = 0x3848;
-            }
-            else if ((req_rga->alpha_rop_mode & 3) == 1) {
+    if (req_rga->render_mode == 6)
+        req->render_mode = update_palette_table_mode;
+    else if (req_rga->render_mode == 7)
+        req->render_mode = update_patten_buff_mode;
+    else if (req_rga->render_mode == 5)
+        req->render_mode = bitblt_mode;
+    else
+        req->render_mode = req_rga->render_mode;
+    memcpy_img_info(&req->src, &req_rga->src);
+    memcpy_img_info(&req->dst, &req_rga->dst);
+    memcpy_img_info(&req->pat, &req_rga->pat);
+    memcpy_img_info(&req->src1,&req_rga->pat);
+    format_name_convert(&req->src.format, req_rga->src.format);
+    format_name_convert(&req->dst.format, req_rga->dst.format);
+    if(req_rga->rotate_mode == 1) {
+        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
+            req->rotate_mode = 0;
+        }
+        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
+            req->rotate_mode = 1;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
+            req->rotate_mode = 2;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
+        }
+        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
+            req->rotate_mode = 3;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+    }
+    else if (req_rga->rotate_mode == 2)
+    {
+        req->rotate_mode = (1 << 4);
+    }
+    else if (req_rga->rotate_mode == 3)
+    {
+        req->rotate_mode = (2 << 4);
+    }
+    else {
+        req->rotate_mode = 0;
+    }
+    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
+        req->scale_bicu_mode |= (1<<4);
+    req->LUT_addr = req_rga->LUT_addr;
+    req->rop_mask_addr = req_rga->rop_mask_addr;
+    req->bitblt_mode = req_rga->bsfilter_flag;
+    req->src_a_global_val = req_rga->alpha_global_value;
+    req->dst_a_global_val = req_rga->alpha_global_value;
+    req->rop_code = req_rga->rop_code;
+    req->rop_mode = 0;
+    req->color_fill_mode = req_rga->color_fill_mode;
+    req->color_key_min   = req_rga->color_key_min;
+    req->color_key_max   = req_rga->color_key_max;
+    req->fg_color = req_rga->fg_color;
+    req->bg_color = req_rga->bg_color;
+    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
+    req->palette_mode = req_rga->palette_mode;
+    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
+    req->endian_mode = req_rga->endian_mode;
+    req->rgb2yuv_mode = 0;
+    req->fading_alpha_value = 0;
+    req->fading_r_value = req_rga->fading.r;
+    req->fading_g_value = req_rga->fading.g;
+    req->fading_b_value = req_rga->fading.b;
+    req->alpha_rop_flag = 0;
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
+    if(((req_rga->alpha_rop_flag) & 1)) {
+        if((req_rga->alpha_rop_flag >> 3) & 1) {
+            switch(req_rga->PD_mode)
+            {
+                case 0: //dst = 0
+                    break;
+                case 1: //dst = src
+                    break;
+                case 2: //dst = dst
+                    break;
+                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
+                    if((req_rga->alpha_rop_mode & 3) == 0) {
+                        alpha_mode_0 = 0x3818;
+                        alpha_mode_1 = 0x3818;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                        alpha_mode_0 = 0x381C;
+                        alpha_mode_1 = 0x381C;
+                    }
+                    else {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    req->alpha_mode_0 = alpha_mode_0;
+                    req->alpha_mode_1 = alpha_mode_1;
+                    break;
+                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
+                    break;
+                case 5: //dst = (da*sc) >> 8
+                    break;
+                case 6: //dst = (sa*dc) >> 8
+                    break;
+                case 7: //dst = ((256-da)*sc) >> 8
+                    break;
+                case 8: //dst = ((256-sa)*dc) >> 8
+                    break;
+                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
+                    req->alpha_mode_0 = 0x3848;
+                    req->alpha_mode_1 = 0x3848;
+                    break;
+                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
+                    break;
+                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
+                    break;
+		case 12:
+		    req->alpha_mode_0 = 0x0010;
+		    req->alpha_mode_1 = 0x0820;
+		    break;
+                default:
+                    break;
+            }
+        }
+        else {
+            if((req_rga->alpha_rop_mode & 3) == 0) {
+                req->alpha_mode_0 = 0x3848;
+                req->alpha_mode_1 = 0x3848;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 1) {
 		req->alpha_mode_0 = 0x384A;
 		req->alpha_mode_1 = 0x3A4A;
-            }
-            else if ((req_rga->alpha_rop_mode & 3) == 2) {
-                req->alpha_mode_0 = 0x384C;
-                req->alpha_mode_1 = 0x384C;
-            }
-        }
-    }
-    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
-        req->mmu_info.src0_mmu_flag = 1;
-        req->mmu_info.dst_mmu_flag = 1;
-        if (req_rga->mmu_info.mmu_flag >> 31) {
-            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
-            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
-            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
-            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
-        }
-        else {
-            if (req_rga->src.yrgb_addr >= 0xa0000000) {
-               req->mmu_info.src0_mmu_flag = 0;
-               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
-               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
-               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
-            }
-            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
-               req->mmu_info.dst_mmu_flag = 0;
-               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
-            }
-        }
-    }
-}
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                req->alpha_mode_0 = 0x384C;
+                req->alpha_mode_1 = 0x384C;
+            }
+        }
+    }
+    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
+        req->mmu_info.src0_mmu_flag = 1;
+        req->mmu_info.dst_mmu_flag = 1;
+        if (req_rga->mmu_info.mmu_flag >> 31) {
+            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
+            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
+            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
+            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
+        }
+        else {
+            if (req_rga->src.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.src0_mmu_flag = 0;
+               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
+               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
+               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
+            }
+            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.dst_mmu_flag = 0;
+               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
+            }
+        }
+    }
+}
diff --git a/drivers/video/rockchip/rga2/rga2_reg_info.h b/drivers/video/rockchip/rga2/rga2_reg_info.h
index 422c96e33e7f..586603e5ca92 100644
--- a/drivers/video/rockchip/rga2/rga2_reg_info.h
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.h
@@ -1,302 +1,302 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __REG2_INFO_H__
-#define __REG2_INFO_H__
-
-
-//#include "chip_register.h"
-
-//#include "rga_struct.h"
-#include "rga2.h"
-
-#ifndef MIN
-#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
-#endif
-
-#ifndef MAX
-#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
-#endif
-
-#ifndef ABS
-#define ABS(X)              (((X) < 0) ? (-(X)) : (X))
-#endif
-
-#ifndef CLIP
-#define CLIP(x, a,  b)				((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x))
-#endif
-
-#define rRGA_SYS_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_SYS_CTRL_OFFSET    ))
-#define rRGA_CMD_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_CTRL_OFFSET    ))
-#define rRGA_CMD_BASE             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_BASE_OFFSET    ))
-#define rRGA_STATUS               (*(volatile u32 *)(RGA2_BASE + RGA2_STATUS_OFFSET      ))
-#define rRGA_INT                  (*(volatile u32 *)(RGA2_BASE + RGA2_INT_OFFSET         ))
-#define rRGA_MMU_CTRL0            (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CTRL0_OFFSET   ))
-#define rRGA_MMU_CMD_BASE         (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CMD_BASE_OFFSET))
-#define rRGA_CMD_ADDR             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_ADDR))
-
-/*RGA_INT*/
-#define m_RGA2_INT_ALL_CMD_DONE_INT_EN             ( 1<<10 )
-#define m_RGA2_INT_MMU_INT_EN                      ( 1<<9  )
-#define m_RGA2_INT_ERROR_INT_EN                    ( 1<<8  )
-#define m_RGA2_INT_NOW_CMD_DONE_INT_CLEAR          ( 1<<7  )
-#define m_RGA2_INT_ALL_CMD_DONE_INT_CLEAR          ( 1<<6  )
-#define m_RGA2_INT_MMU_INT_CLEAR                   ( 1<<5  )
-#define m_RGA2_INT_ERROR_INT_CLEAR                 ( 1<<4  )
-#define m_RGA2_INT_CUR_CMD_DONE_INT_FLAG           ( 1<<3  )
-#define m_RGA2_INT_ALL_CMD_DONE_INT_FLAG           ( 1<<2  )
-#define m_RGA2_INT_MMU_INT_FLAG                    ( 1<<1  )
-#define m_RGA2_INT_ERROR_INT_FLAG                  ( 1<<0  )
-
-#define s_RGA2_INT_ALL_CMD_DONE_INT_EN(x)          ( (x&0x1)<<10 )
-#define s_RGA2_INT_MMU_INT_EN(x)                   ( (x&0x1)<<9  )
-#define s_RGA2_INT_ERROR_INT_EN(x)                 ( (x&0x1)<<8  )
-#define s_RGA2_INT_NOW_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<7  )
-#define s_RGA2_INT_ALL_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<6  )
-#define s_RGA2_INT_MMU_INT_CLEAR(x)                ( (x&0x1)<<5  )
-#define s_RGA2_INT_ERROR_INT_CLEAR(x)              ( (x&0x1)<<4  )
-
-
-
-/* RGA_MODE_CTRL */
-#define m_RGA2_MODE_CTRL_SW_RENDER_MODE         (  0x7<<0  )
-#define m_RGA2_MODE_CTRL_SW_BITBLT_MODE         (  0x1<<3  )
-#define m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT         (  0x1<<4  )
-#define m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET      (  0x1<<5  )
-#define m_RGA2_MODE_CTRL_SW_GRADIENT_SAT        (  0x1<<6  )
-#define m_RGA2_MODE_CTRL_SW_INTR_CF_E           (  0x1<<7  )
-
-#define s_RGA2_MODE_CTRL_SW_RENDER_MODE(x)      (  (x&0x7)<<0  )
-#define s_RGA2_MODE_CTRL_SW_BITBLT_MODE(x)      (  (x&0x1)<<3  )
-#define s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(x)      (  (x&0x1)<<4  )
-#define s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(x)   (  (x&0x1)<<5  )
-#define s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(x)     (  (x&0x1)<<6  )
-#define s_RGA2_MODE_CTRL_SW_INTR_CF_E(x)        (  (x&0x1)<<7  )
-
-/* RGA_SRC_INFO */
-#define m_RGA2_SRC_INFO_SW_SRC_FMT                (   0xf<<0   )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP         (   0x1<<4   )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP      (   0x1<<5   )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP         (   0x1<<6   )
-#define m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN           (   0x1<<7   )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE        (   0x3<<8   )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE        (   0x3<<10  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE        (   0x3<<12  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE       (   0x3<<14  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE       (   0x3<<16  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE      (   0x1<<18  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E         (   0xf<<19  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E     (   0x1<<23  )
-#define m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER      (   0x3<<24  )
-#define m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL        (   0x1<<26  )
-#define m_RGA2_SRC_INFO_SW_SW_YUV10_E             (   0x1<<27  )
-#define m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E       (   0x1<<28  )
-
-
-
-
-
-#define s_RGA2_SRC_INFO_SW_SRC_FMT(x)                (   (x&0xf)<<0   )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(x)         (   (x&0x1)<<4   )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(x)      (   (x&0x1)<<5   )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(x)         (   (x&0x1)<<6   )
-#define s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(x)           (   (x&0x1)<<7   )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(x)        (   (x&0x3)<<8   )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(x)        (   (x&0x3)<<10  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE(x)        (   (x&0x3)<<12  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x)       (   (x&0x3)<<14  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(x)       (   (x&0x3)<<16  )
-
-#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(x)      (   (x&0x1)<<18  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(x)         (   (x&0xf)<<19  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E(x)     (   (x&0x1)<<23  )
-#define s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER(x)      (   (x&0x3)<<24  )
-#define s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL(x)        (   (x&0x1)<<26  )
-#define s_RGA2_SRC_INFO_SW_SW_YUV10_E(x)             (   (x&0x1)<<27  )
-#define s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E(x)       (   (x&0x1)<<28  )
-
-/* RGA_SRC_VIR_INFO */
-#define m_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE        (  0x7fff<<0  )         //modify
-#define m_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE       (   0x3ff<<16 )         //modify
-
-#define s_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE(x)        ( (x&0x7fff)<<0  )   //modify
-#define s_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE(x)       (   (x&0x3ff)<<16 )  //modify
-
-
-/* RGA_SRC_ACT_INFO */
-#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH        (  0x1fff<<0  )
-#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT       (  0x1fff<<16  )
-
-#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH(x)        (  (x&0x1fff)<<0  )
-#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT(x)       (  (x&0x1fff<)<16  )
-
-
-/* RGA_DST_INFO */
-#define m_RGA2_DST_INFO_SW_DST_FMT                   (  0xf<<0 )
-#define m_RGA2_DST_INFO_SW_DST_RB_SWAP               (  0x1<<4 )
-#define m_RGA2_DST_INFO_SW_ALPHA_SWAP                (  0x1<<5 )
-#define m_RGA2_DST_INFO_SW_DST_UV_SWAP               (  0x1<<6 )
-#define m_RGA2_DST_INFO_SW_SRC1_FMT                  (  0x7<<7 )
-#define m_RGA2_DST_INFO_SW_SRC1_RB_SWP               (  0x1<<10)
-#define m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP            (  0x1<<11)
-#define m_RGA2_DST_INFO_SW_DITHER_UP_E               (  0x1<<12)
-#define m_RGA2_DST_INFO_SW_DITHER_DOWN_E             (  0x1<<13)
-#define m_RGA2_DST_INFO_SW_DITHER_MODE               (  0x3<<14)
-#define m_RGA2_DST_INFO_SW_DST_CSC_MODE              (  0x3<<16)    //add
-#define m_RGA2_DST_INFO_SW_CSC_CLIP_MODE             (  0x1<<18)
-
-#define s_RGA2_DST_INFO_SW_DST_FMT(x)                   (  (x&0xf)<<0 )
-#define s_RGA2_DST_INFO_SW_DST_RB_SWAP(x)               (  (x&0x1)<<4 )
-#define s_RGA2_DST_INFO_SW_ALPHA_SWAP(x)                (  (x&0x1)<<5 )
-#define s_RGA2_DST_INFO_SW_DST_UV_SWAP(x)               (  (x&0x1)<<6 )
-#define s_RGA2_DST_INFO_SW_SRC1_FMT(x)                  (  (x&0x7)<<7 )
-#define s_RGA2_DST_INFO_SW_SRC1_RB_SWP(x)               (  (x&0x1)<<10)
-#define s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(x)            (  (x&0x1)<<11)
-#define s_RGA2_DST_INFO_SW_DITHER_UP_E(x)               (  (x&0x1)<<12)
-#define s_RGA2_DST_INFO_SW_DITHER_DOWN_E(x)             (  (x&0x1)<<13)
-#define s_RGA2_DST_INFO_SW_DITHER_MODE(x)               (  (x&0x3)<<14)
-#define s_RGA2_DST_INFO_SW_DST_CSC_MODE(x)              (  (x&0x3)<<16)    //add
-#define s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(x)             (  (x&0x1)<<18)
-
-
-/* RGA_ALPHA_CTRL0 */
-#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0             (  0x1<<0  )
-#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL           (  0x1<<1  )
-#define m_RGA2_ALPHA_CTRL0_SW_ROP_MODE                (  0x3<<2  )
-#define m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA        ( 0xff<<4  )
-#define m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA        ( 0xff<<12 )
-#define m_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN             (  0x1<<20 )         //add
-
-#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(x)             (  (x&0x1)<<0  )
-#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(x)           (  (x&0x1)<<1  )
-#define s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(x)                (  (x&0x3)<<2  )
-#define s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(x)        ( (x&0xff)<<4  )
-#define s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(x)        ( (x&0xff)<<12 )
-#define s_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN(x)             (  (x&0x1)<<20 )  //add
-
-
-
-/* RGA_ALPHA_CTRL1 */
-#define m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0            ( 0x1<<0 )
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0            ( 0x1<<1 )
-#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0           ( 0x7<<2 )
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0           ( 0x7<<5 )
-#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0        ( 0x1<<8 )
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0        ( 0x1<<9 )
-#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0            ( 0x3<<10)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0            ( 0x3<<12)
-#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0            ( 0x1<<14)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0            ( 0x1<<15)
-#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1           ( 0x7<<16)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1           ( 0x7<<19)
-#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1        ( 0x1<<22)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1        ( 0x1<<23)
-#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1            ( 0x3<<24)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1            ( 0x3<<26)
-#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1            ( 0x1<<28)
-#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1            ( 0x1<<29)
-
-#define s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(x)            ( (x&0x1)<<0 )
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(x)            ( (x&0x1)<<1 )
-#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(x)           ( (x&0x7)<<2 )
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(x)           ( (x&0x7)<<5 )
-#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(x)        ( (x&0x1)<<8 )
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(x)        ( (x&0x1)<<9 )
-#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(x)            ( (x&0x3)<<10)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(x)            ( (x&0x3)<<12)
-#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(x)            ( (x&0x1)<<14)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(x)            ( (x&0x1)<<15)
-#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(x)           ( (x&0x7)<<16)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(x)           ( (x&0x7)<<19)
-#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(x)        ( (x&0x1)<<22)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(x)        ( (x&0x1)<<23)
-#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(x)            ( (x&0x3)<<24)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(x)            ( (x&0x3)<<26)
-#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(x)            ( (x&0x1)<<28)
-#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(x)            ( (x&0x1)<<29)
-
-
-
-/* RGA_MMU_CTRL1 */
-#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_EN                  (  0x1<<0 )
-#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH               (  0x1<<1 )
-#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN         (  0x1<<2 )
-#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR        (  0x1<<3 )
-#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN                 (  0x1<<4 )
-#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH              (  0x1<<5 )
-#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN        (  0x1<<6 )
-#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR       (  0x1<<7 )
-#define m_RGA2_MMU_CTRL1_SW_DST_MMU_EN                  (  0x1<<8 )
-#define m_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH               (  0x1<<9 )
-#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN         (  0x1<<10 )
-#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR        (  0x1<<11 )
-#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_EN                  (  0x1<<12 )
-#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH               (  0x1<<13 )
-
-#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_EN(x)                  (  (x&0x1)<<0 )
-#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH(x)               (  (x&0x1)<<1 )
-#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN(x)         (  (x&0x1)<<2 )
-#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<3 )
-#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN(x)                 (  (x&0x1)<<4 )
-#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH(x)              (  (x&0x1)<<5 )
-#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN(x)        (  (x&0x1)<<6 )
-#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR(x)       (  (x&0x1)<<7 )
-#define s_RGA2_MMU_CTRL1_SW_DST_MMU_EN(x)                  (  (x&0x1)<<8 )
-#define s_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH(x)               (  (x&0x1)<<9 )
-#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN(x)         (  (x&0x1)<<10 )
-#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<11 )
-#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_EN(x)                  (  (x&0x1)<<12 )
-#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH(x)               (  (x&0x1)<<13 )
-
-
-#define RGA2_SYS_CTRL_OFFSET             0x0
-#define RGA2_CMD_CTRL_OFFSET             0x4
-#define RGA2_CMD_BASE_OFFSET             0x8
-#define RGA2_STATUS_OFFSET               0xc
-#define RGA2_INT_OFFSET                  0x10
-#define RGA2_MMU_CTRL0_OFFSET            0x14
-#define RGA2_MMU_CMD_BASE_OFFSET         0x18
-
-#define RGA2_MODE_CTRL_OFFSET                   0x00
-#define RGA2_SRC_INFO_OFFSET                    0x04
-#define RGA2_SRC_BASE0_OFFSET                   0x08
-#define RGA2_SRC_BASE1_OFFSET                   0x0c
-#define RGA2_SRC_BASE2_OFFSET                   0x10
-#define RGA2_SRC_BASE3_OFFSET                   0x14
-#define RGA2_SRC_VIR_INFO_OFFSET                0x18
-#define RGA2_SRC_ACT_INFO_OFFSET                0x1c
-#define RGA2_SRC_X_FACTOR_OFFSET                0x20
-#define RGA2_SRC_Y_FACTOR_OFFSET                0x24
-#define RGA2_SRC_BG_COLOR_OFFSET                0x28
-#define RGA2_SRC_FG_COLOR_OFFSET                0x2c
-#define RGA2_SRC_TR_COLOR0_OFFSET               0x30
-#define RGA2_CF_GR_A_OFFSET                     0x30 // repeat
-#define RGA2_SRC_TR_COLOR1_OFFSET               0x34
-#define RGA2_CF_GR_B_OFFSET                     0x34 // repeat
-#define RGA2_DST_INFO_OFFSET                    0x38
-#define RGA2_DST_BASE0_OFFSET                   0x3c
-#define RGA2_DST_BASE1_OFFSET                   0x40
-#define RGA2_DST_BASE2_OFFSET                   0x44
-#define RGA2_DST_VIR_INFO_OFFSET                0x48
-#define RGA2_DST_ACT_INFO_OFFSET                0x4c
-#define RGA2_ALPHA_CTRL0_OFFSET                 0x50
-#define RGA2_ALPHA_CTRL1_OFFSET                 0x54
-#define RGA2_FADING_CTRL_OFFSET                 0x58
-#define RGA2_PAT_CON_OFFSET                     0x5c
-#define RGA2_ROP_CTRL0_OFFSET                   0x60
-#define RGA2_CF_GR_G_OFFSET                     0x60 // repeat
-#define RGA2_ROP_CTRL1_OFFSET                   0x64
-#define RGA2_CF_GR_R_OFFSET                     0x64 // repeat
-#define RGA2_MASK_BASE_OFFSET                   0x68
-#define RGA2_MMU_CTRL1_OFFSET                   0x6c
-#define RGA2_MMU_SRC_BASE_OFFSET                0x70
-#define RGA2_MMU_SRC1_BASE_OFFSET               0x74
-#define RGA2_MMU_DST_BASE_OFFSET                0x78
-#define RGA2_MMU_ELS_BASE_OFFSET                0x7c
-
-int RGA2_gen_reg_info(unsigned char *base, struct rga2_req *msg);
-void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req);
-void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req);
-
-
-
-#endif
-
+#ifndef __REG2_INFO_H__
+#define __REG2_INFO_H__
+
+
+//#include "chip_register.h"
+
+//#include "rga_struct.h"
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+#ifndef ABS
+#define ABS(X)              (((X) < 0) ? (-(X)) : (X))
+#endif
+
+#ifndef CLIP
+#define CLIP(x, a,  b)				((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x))
+#endif
+
+#define rRGA_SYS_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_SYS_CTRL_OFFSET    ))
+#define rRGA_CMD_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_CTRL_OFFSET    ))
+#define rRGA_CMD_BASE             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_BASE_OFFSET    ))
+#define rRGA_STATUS               (*(volatile u32 *)(RGA2_BASE + RGA2_STATUS_OFFSET      ))
+#define rRGA_INT                  (*(volatile u32 *)(RGA2_BASE + RGA2_INT_OFFSET         ))
+#define rRGA_MMU_CTRL0            (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CTRL0_OFFSET   ))
+#define rRGA_MMU_CMD_BASE         (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CMD_BASE_OFFSET))
+#define rRGA_CMD_ADDR             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_ADDR))
+
+/*RGA_INT*/
+#define m_RGA2_INT_ALL_CMD_DONE_INT_EN             ( 1<<10 )
+#define m_RGA2_INT_MMU_INT_EN                      ( 1<<9  )
+#define m_RGA2_INT_ERROR_INT_EN                    ( 1<<8  )
+#define m_RGA2_INT_NOW_CMD_DONE_INT_CLEAR          ( 1<<7  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_CLEAR          ( 1<<6  )
+#define m_RGA2_INT_MMU_INT_CLEAR                   ( 1<<5  )
+#define m_RGA2_INT_ERROR_INT_CLEAR                 ( 1<<4  )
+#define m_RGA2_INT_CUR_CMD_DONE_INT_FLAG           ( 1<<3  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_FLAG           ( 1<<2  )
+#define m_RGA2_INT_MMU_INT_FLAG                    ( 1<<1  )
+#define m_RGA2_INT_ERROR_INT_FLAG                  ( 1<<0  )
+
+#define s_RGA2_INT_ALL_CMD_DONE_INT_EN(x)          ( (x&0x1)<<10 )
+#define s_RGA2_INT_MMU_INT_EN(x)                   ( (x&0x1)<<9  )
+#define s_RGA2_INT_ERROR_INT_EN(x)                 ( (x&0x1)<<8  )
+#define s_RGA2_INT_NOW_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<7  )
+#define s_RGA2_INT_ALL_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<6  )
+#define s_RGA2_INT_MMU_INT_CLEAR(x)                ( (x&0x1)<<5  )
+#define s_RGA2_INT_ERROR_INT_CLEAR(x)              ( (x&0x1)<<4  )
+
+
+
+/* RGA_MODE_CTRL */
+#define m_RGA2_MODE_CTRL_SW_RENDER_MODE         (  0x7<<0  )
+#define m_RGA2_MODE_CTRL_SW_BITBLT_MODE         (  0x1<<3  )
+#define m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT         (  0x1<<4  )
+#define m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET      (  0x1<<5  )
+#define m_RGA2_MODE_CTRL_SW_GRADIENT_SAT        (  0x1<<6  )
+#define m_RGA2_MODE_CTRL_SW_INTR_CF_E           (  0x1<<7  )
+
+#define s_RGA2_MODE_CTRL_SW_RENDER_MODE(x)      (  (x&0x7)<<0  )
+#define s_RGA2_MODE_CTRL_SW_BITBLT_MODE(x)      (  (x&0x1)<<3  )
+#define s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(x)      (  (x&0x1)<<4  )
+#define s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(x)   (  (x&0x1)<<5  )
+#define s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(x)     (  (x&0x1)<<6  )
+#define s_RGA2_MODE_CTRL_SW_INTR_CF_E(x)        (  (x&0x1)<<7  )
+
+/* RGA_SRC_INFO */
+#define m_RGA2_SRC_INFO_SW_SRC_FMT                (   0xf<<0   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP         (   0x1<<4   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP      (   0x1<<5   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP         (   0x1<<6   )
+#define m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN           (   0x1<<7   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE        (   0x3<<8   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE        (   0x3<<10  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE        (   0x3<<12  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE       (   0x3<<14  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE       (   0x3<<16  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE      (   0x1<<18  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E         (   0xf<<19  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E     (   0x1<<23  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER      (   0x3<<24  )
+#define m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL        (   0x1<<26  )
+#define m_RGA2_SRC_INFO_SW_SW_YUV10_E             (   0x1<<27  )
+#define m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E       (   0x1<<28  )
+
+
+
+
+
+#define s_RGA2_SRC_INFO_SW_SRC_FMT(x)                (   (x&0xf)<<0   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(x)         (   (x&0x1)<<4   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(x)      (   (x&0x1)<<5   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(x)         (   (x&0x1)<<6   )
+#define s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(x)           (   (x&0x1)<<7   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(x)        (   (x&0x3)<<8   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(x)        (   (x&0x3)<<10  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE(x)        (   (x&0x3)<<12  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x)       (   (x&0x3)<<14  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(x)       (   (x&0x3)<<16  )
+
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(x)      (   (x&0x1)<<18  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(x)         (   (x&0xf)<<19  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E(x)     (   (x&0x1)<<23  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER(x)      (   (x&0x3)<<24  )
+#define s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL(x)        (   (x&0x1)<<26  )
+#define s_RGA2_SRC_INFO_SW_SW_YUV10_E(x)             (   (x&0x1)<<27  )
+#define s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E(x)       (   (x&0x1)<<28  )
+
+/* RGA_SRC_VIR_INFO */
+#define m_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE        (  0x7fff<<0  )         //modify
+#define m_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE       (   0x3ff<<16 )         //modify
+
+#define s_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE(x)        ( (x&0x7fff)<<0  )   //modify
+#define s_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE(x)       (   (x&0x3ff)<<16 )  //modify
+
+
+/* RGA_SRC_ACT_INFO */
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH        (  0x1fff<<0  )
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT       (  0x1fff<<16  )
+
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH(x)        (  (x&0x1fff)<<0  )
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT(x)       (  (x&0x1fff<)<16  )
+
+
+/* RGA_DST_INFO */
+#define m_RGA2_DST_INFO_SW_DST_FMT                   (  0xf<<0 )
+#define m_RGA2_DST_INFO_SW_DST_RB_SWAP               (  0x1<<4 )
+#define m_RGA2_DST_INFO_SW_ALPHA_SWAP                (  0x1<<5 )
+#define m_RGA2_DST_INFO_SW_DST_UV_SWAP               (  0x1<<6 )
+#define m_RGA2_DST_INFO_SW_SRC1_FMT                  (  0x7<<7 )
+#define m_RGA2_DST_INFO_SW_SRC1_RB_SWP               (  0x1<<10)
+#define m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP            (  0x1<<11)
+#define m_RGA2_DST_INFO_SW_DITHER_UP_E               (  0x1<<12)
+#define m_RGA2_DST_INFO_SW_DITHER_DOWN_E             (  0x1<<13)
+#define m_RGA2_DST_INFO_SW_DITHER_MODE               (  0x3<<14)
+#define m_RGA2_DST_INFO_SW_DST_CSC_MODE              (  0x3<<16)    //add
+#define m_RGA2_DST_INFO_SW_CSC_CLIP_MODE             (  0x1<<18)
+
+#define s_RGA2_DST_INFO_SW_DST_FMT(x)                   (  (x&0xf)<<0 )
+#define s_RGA2_DST_INFO_SW_DST_RB_SWAP(x)               (  (x&0x1)<<4 )
+#define s_RGA2_DST_INFO_SW_ALPHA_SWAP(x)                (  (x&0x1)<<5 )
+#define s_RGA2_DST_INFO_SW_DST_UV_SWAP(x)               (  (x&0x1)<<6 )
+#define s_RGA2_DST_INFO_SW_SRC1_FMT(x)                  (  (x&0x7)<<7 )
+#define s_RGA2_DST_INFO_SW_SRC1_RB_SWP(x)               (  (x&0x1)<<10)
+#define s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(x)            (  (x&0x1)<<11)
+#define s_RGA2_DST_INFO_SW_DITHER_UP_E(x)               (  (x&0x1)<<12)
+#define s_RGA2_DST_INFO_SW_DITHER_DOWN_E(x)             (  (x&0x1)<<13)
+#define s_RGA2_DST_INFO_SW_DITHER_MODE(x)               (  (x&0x3)<<14)
+#define s_RGA2_DST_INFO_SW_DST_CSC_MODE(x)              (  (x&0x3)<<16)    //add
+#define s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(x)             (  (x&0x1)<<18)
+
+
+/* RGA_ALPHA_CTRL0 */
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0             (  0x1<<0  )
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL           (  0x1<<1  )
+#define m_RGA2_ALPHA_CTRL0_SW_ROP_MODE                (  0x3<<2  )
+#define m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA        ( 0xff<<4  )
+#define m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA        ( 0xff<<12 )
+#define m_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN             (  0x1<<20 )         //add
+
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(x)             (  (x&0x1)<<0  )
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(x)           (  (x&0x1)<<1  )
+#define s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(x)                (  (x&0x3)<<2  )
+#define s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(x)        ( (x&0xff)<<4  )
+#define s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(x)        ( (x&0xff)<<12 )
+#define s_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN(x)             (  (x&0x1)<<20 )  //add
+
+
+
+/* RGA_ALPHA_CTRL1 */
+#define m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0            ( 0x1<<0 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0            ( 0x1<<1 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0           ( 0x7<<2 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0           ( 0x7<<5 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0        ( 0x1<<8 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0        ( 0x1<<9 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0            ( 0x3<<10)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0            ( 0x3<<12)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0            ( 0x1<<14)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0            ( 0x1<<15)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1           ( 0x7<<16)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1           ( 0x7<<19)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1        ( 0x1<<22)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1        ( 0x1<<23)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1            ( 0x3<<24)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1            ( 0x3<<26)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1            ( 0x1<<28)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1            ( 0x1<<29)
+
+#define s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(x)            ( (x&0x1)<<0 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(x)            ( (x&0x1)<<1 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(x)           ( (x&0x7)<<2 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(x)           ( (x&0x7)<<5 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(x)        ( (x&0x1)<<8 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(x)        ( (x&0x1)<<9 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(x)            ( (x&0x3)<<10)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(x)            ( (x&0x3)<<12)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(x)            ( (x&0x1)<<14)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(x)            ( (x&0x1)<<15)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(x)           ( (x&0x7)<<16)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(x)           ( (x&0x7)<<19)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(x)        ( (x&0x1)<<22)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(x)        ( (x&0x1)<<23)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(x)            ( (x&0x3)<<24)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(x)            ( (x&0x3)<<26)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(x)            ( (x&0x1)<<28)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(x)            ( (x&0x1)<<29)
+
+
+
+/* RGA_MMU_CTRL1 */
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_EN                  (  0x1<<0 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH               (  0x1<<1 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN         (  0x1<<2 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR        (  0x1<<3 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN                 (  0x1<<4 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH              (  0x1<<5 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN        (  0x1<<6 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR       (  0x1<<7 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_EN                  (  0x1<<8 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH               (  0x1<<9 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN         (  0x1<<10 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR        (  0x1<<11 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_EN                  (  0x1<<12 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH               (  0x1<<13 )
+
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_EN(x)                  (  (x&0x1)<<0 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH(x)               (  (x&0x1)<<1 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN(x)         (  (x&0x1)<<2 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<3 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN(x)                 (  (x&0x1)<<4 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH(x)              (  (x&0x1)<<5 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN(x)        (  (x&0x1)<<6 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR(x)       (  (x&0x1)<<7 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_EN(x)                  (  (x&0x1)<<8 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH(x)               (  (x&0x1)<<9 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN(x)         (  (x&0x1)<<10 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<11 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_EN(x)                  (  (x&0x1)<<12 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH(x)               (  (x&0x1)<<13 )
+
+
+#define RGA2_SYS_CTRL_OFFSET             0x0
+#define RGA2_CMD_CTRL_OFFSET             0x4
+#define RGA2_CMD_BASE_OFFSET             0x8
+#define RGA2_STATUS_OFFSET               0xc
+#define RGA2_INT_OFFSET                  0x10
+#define RGA2_MMU_CTRL0_OFFSET            0x14
+#define RGA2_MMU_CMD_BASE_OFFSET         0x18
+
+#define RGA2_MODE_CTRL_OFFSET                   0x00
+#define RGA2_SRC_INFO_OFFSET                    0x04
+#define RGA2_SRC_BASE0_OFFSET                   0x08
+#define RGA2_SRC_BASE1_OFFSET                   0x0c
+#define RGA2_SRC_BASE2_OFFSET                   0x10
+#define RGA2_SRC_BASE3_OFFSET                   0x14
+#define RGA2_SRC_VIR_INFO_OFFSET                0x18
+#define RGA2_SRC_ACT_INFO_OFFSET                0x1c
+#define RGA2_SRC_X_FACTOR_OFFSET                0x20
+#define RGA2_SRC_Y_FACTOR_OFFSET                0x24
+#define RGA2_SRC_BG_COLOR_OFFSET                0x28
+#define RGA2_SRC_FG_COLOR_OFFSET                0x2c
+#define RGA2_SRC_TR_COLOR0_OFFSET               0x30
+#define RGA2_CF_GR_A_OFFSET                     0x30 // repeat
+#define RGA2_SRC_TR_COLOR1_OFFSET               0x34
+#define RGA2_CF_GR_B_OFFSET                     0x34 // repeat
+#define RGA2_DST_INFO_OFFSET                    0x38
+#define RGA2_DST_BASE0_OFFSET                   0x3c
+#define RGA2_DST_BASE1_OFFSET                   0x40
+#define RGA2_DST_BASE2_OFFSET                   0x44
+#define RGA2_DST_VIR_INFO_OFFSET                0x48
+#define RGA2_DST_ACT_INFO_OFFSET                0x4c
+#define RGA2_ALPHA_CTRL0_OFFSET                 0x50
+#define RGA2_ALPHA_CTRL1_OFFSET                 0x54
+#define RGA2_FADING_CTRL_OFFSET                 0x58
+#define RGA2_PAT_CON_OFFSET                     0x5c
+#define RGA2_ROP_CTRL0_OFFSET                   0x60
+#define RGA2_CF_GR_G_OFFSET                     0x60 // repeat
+#define RGA2_ROP_CTRL1_OFFSET                   0x64
+#define RGA2_CF_GR_R_OFFSET                     0x64 // repeat
+#define RGA2_MASK_BASE_OFFSET                   0x68
+#define RGA2_MMU_CTRL1_OFFSET                   0x6c
+#define RGA2_MMU_SRC_BASE_OFFSET                0x70
+#define RGA2_MMU_SRC1_BASE_OFFSET               0x74
+#define RGA2_MMU_DST_BASE_OFFSET                0x78
+#define RGA2_MMU_ELS_BASE_OFFSET                0x7c
+
+int RGA2_gen_reg_info(unsigned char *base, struct rga2_req *msg);
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req);
+void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req);
+
+
+
+#endif
+
diff --git a/drivers/video/rockchip/rga2/rga2_type.h b/drivers/video/rockchip/rga2/rga2_type.h
index ce3610ab9b67..30f5df2f38e5 100644
--- a/drivers/video/rockchip/rga2/rga2_type.h
+++ b/drivers/video/rockchip/rga2/rga2_type.h
@@ -1,49 +1,49 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __RGA_TYPE_H__
-#define __RGA_TYPE_H__
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
-
-typedef  unsigned int     UWORD32;
-typedef  unsigned int     uint32;
-typedef  unsigned int     RK_U32;
-
-typedef  unsigned short   UWORD16;
-typedef  unsigned short   RK_U16;
-
-typedef  unsigned char    UBYTE;
-typedef  unsigned char    RK_U8;
-
-typedef  int              WORD32;
-typedef  int              RK_S32;
-
-typedef  short            WORD16;
-typedef  short            RK_S16;
-
-typedef  char             BYTE;
-typedef  char             RK_S8;
-
-
-#ifndef NULL
-#define NULL              0L
-#endif
-
-#ifndef TRUE
-#define TRUE              1L
-#endif
-
-
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* __cplusplus */
-
-
-#endif /* __RGA_TYPR_H__ */
-
+#ifndef __RGA_TYPE_H__
+#define __RGA_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+typedef  unsigned int     UWORD32;
+typedef  unsigned int     uint32;
+typedef  unsigned int     RK_U32;
+
+typedef  unsigned short   UWORD16;
+typedef  unsigned short   RK_U16;
+
+typedef  unsigned char    UBYTE;
+typedef  unsigned char    RK_U8;
+
+typedef  int              WORD32;
+typedef  int              RK_S32;
+
+typedef  short            WORD16;
+typedef  short            RK_S16;
+
+typedef  char             BYTE;
+typedef  char             RK_S8;
+
+
+#ifndef NULL
+#define NULL              0L
+#endif
+
+#ifndef TRUE
+#define TRUE              1L
+#endif
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __RGA_TYPR_H__ */
+
-- 
2.35.3

