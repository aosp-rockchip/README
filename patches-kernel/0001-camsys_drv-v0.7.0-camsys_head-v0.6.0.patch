From c76142ff6455d33abfae9e0c7d98ec5a905e91b0 Mon Sep 17 00:00:00 2001
From: ddl <ddl@rock-chips.com>
Date: Tue, 6 May 2014 16:11:44 +0800
Subject: [PATCH] camsys_drv: v0.7.0  camsys_head: v0.6.0

---
 arch/arm/boot/dts/rk3288-pinctrl.dtsi         |  16 +-
 arch/arm/boot/dts/rk3288.dtsi                 |  21 +-
 drivers/media/video/rk_camsys/Makefile        |   2 +-
 drivers/media/video/rk_camsys/camsys_drv.c    | 167 ++++----
 .../media/video/rk_camsys/camsys_internal.h   |  46 ++-
 drivers/media/video/rk_camsys/camsys_marvin.c | 233 +++++------
 drivers/media/video/rk_camsys/camsys_marvin.h |   3 +-
 .../video/rk_camsys/camsys_mipicsi_phy.c      | 382 +++++++-----------
 .../video/rk_camsys/camsys_mipicsi_phy.h      |  20 +-
 .../media/video/rk_camsys/camsys_soc_priv.c   | 100 +++++
 .../media/video/rk_camsys/camsys_soc_priv.h   |  30 ++
 .../media/video/rk_camsys/camsys_soc_rk3288.c | 227 +++++++++++
 .../media/video/rk_camsys/camsys_soc_rk3288.h | 103 +++++
 drivers/pinctrl/pinctrl-rockchip.c            |   4 +-
 include/media/camsys_head.h                   |  57 ++-
 15 files changed, 882 insertions(+), 529 deletions(-)
 create mode 100755 drivers/media/video/rk_camsys/camsys_soc_priv.c
 create mode 100755 drivers/media/video/rk_camsys/camsys_soc_priv.h
 create mode 100755 drivers/media/video/rk_camsys/camsys_soc_rk3288.c
 create mode 100755 drivers/media/video/rk_camsys/camsys_soc_rk3288.h

diff --git a/arch/arm/boot/dts/rk3288-pinctrl.dtsi b/arch/arm/boot/dts/rk3288-pinctrl.dtsi
index 1eff2dcb475b..b5113f0ceb26 100755
--- a/arch/arm/boot/dts/rk3288-pinctrl.dtsi
+++ b/arch/arm/boot/dts/rk3288-pinctrl.dtsi
@@ -1115,7 +1115,7 @@
 				rockchip,drive = <VALUE_DRV_DEFAULT>;
 				//rockchip,tristate = <VALUE_TRI_DEFAULT>;			
 			};
-			isp_dvp_sync_d2d9:isp_dvp_force	{
+			isp_dvp_d2d9:isp_dvp_d2d9	{
 				rockchip,pins = <CIF_DATA2>,<CIF_DATA3>,
 								<CIF_DATA4>,<CIF_DATA5>,
 								<CIF_DATA6>,<CIF_DATA7>,
@@ -1135,12 +1135,22 @@
 				//rockchip,tristate = <VALUE_TRI_DEFAULT>;
 			};
 
-			isp_dvpd10d11:ispd10d11	{
+			isp_dvp_d10d11:isp_d10d11	{
 				rockchip,pins = <CIF_DATA10>,<CIF_DATA11>;
 				rockchip,pull = <VALUE_PULL_DISABLE>;
 				rockchip,drive = <VALUE_DRV_DEFAULT>;
 				//rockchip,tristate = <VALUE_TRI_DEFAULT>;
 			};
+			
+			isp_dvp_d0d7:isp_d0d7	{
+				rockchip,pins = <CIF_DATA0>,<CIF_DATA1>,
+								<CIF_DATA2>,<CIF_DATA3>,
+								<CIF_DATA4>,<CIF_DATA5>,
+								<CIF_DATA6>,<CIF_DATA7>;
+				rockchip,pull = <VALUE_PULL_DISABLE>;
+				rockchip,drive = <VALUE_DRV_DEFAULT>;
+				//rockchip,tristate = <VALUE_TRI_DEFAULT>;
+			};
 
 			isp_shutter:isp_shutter		{
 				rockchip,pins = <ISP_SHUTTEREN>,<ISP_SHUTTERTRIG>;
@@ -1149,7 +1159,7 @@
 				//rockchip,tristate = <VALUE_TRI_DEFAULT>;
 			};
 
-			isp_flash_trigger:isp_trigger {
+			isp_flash_trigger:isp_flash_trigger {
 				rockchip,pins = <ISP_FLASHTRIGOUTSPI1_CS0>;
 				rockchip,pull = <VALUE_PULL_DISABLE>;
 				rockchip,drive = <VALUE_DRV_DEFAULT>;
diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi
index 5e9cdd8cf78c..ad0e3f61e5e2 100755
--- a/arch/arm/boot/dts/rk3288.dtsi
+++ b/arch/arm/boot/dts/rk3288.dtsi
@@ -356,7 +356,7 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&spi1_txd &spi1_rxd &spi1_clk &spi1_cs0>;
+		pinctrl-0 = <&spi1_txd &spi1_rxd &spi1_clk &spi1_cs0>; 
 		rockchip,spi-src-clk = <1>;
         	num-cs = <1>;
 		clocks = <&clk_spi1>, <&clk_gates6 5>;
@@ -1228,14 +1228,21 @@
 	        compatible = "rockchip,isp";
 	        reg = <0xff910000 0x10000>;
 	        interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
-	        clocks = <&clk_gates16 2>, <&clk_gates16 1>, <&clk_isp>, <&clk_isp_jpe>, <&clkin_isp>, <&clk_cif_out>,<&clk_gates5 15>,<&clk_cif_pll>,<&pd_isp>;
-			clock-names = "aclk_isp", "hclk_isp", "clk_isp", "clk_isp_jpe", "pclkin_isp", "clk_vipout","clk_mipi_24m","cif0_out_div","pd_isp";
-			pinctrl-names = "default", "isp_dvp8bit","isp_dvp10bit","isp_dvp12bit";
+	        clocks = <&clk_gates16 2>, <&clk_gates16 1>, <&clk_isp>, <&clk_isp_jpe>, <&clkin_isp>, <&clk_cif_out>,<&clk_gates5 15>,<&clk_cif_pll>,<&pd_isp>,<&clk_gates16 6>;
+			clock-names = "aclk_isp", "hclk_isp", "clk_isp", "clk_isp_jpe", "pclkin_isp", "clk_cif_out","clk_mipi_24m","clk_cif_pll","pd_isp","hclk_mipiphy1";
+			pinctrl-names = "default", "isp_dvp8bit2","isp_dvp10bit","isp_dvp12bit","isp_dvp8bit0","isp_mipi_fl","isp_mipi_fl_prefl";
 			pinctrl-0 = <&isp_mipi>;
-			pinctrl-1 = <&isp_mipi &isp_dvp_sync_d2d9>;
-			pinctrl-2 = <&isp_mipi &isp_dvp_sync_d2d9 &isp_dvp_d0d1>;
-			pinctrl-3 = <&isp_mipi &isp_dvp_sync_d2d9 &isp_dvp_d0d1 &isp_dvpd10d11>;
+			pinctrl-1 = <&isp_mipi &isp_dvp_d2d9>;
+			pinctrl-2 = <&isp_mipi &isp_dvp_d2d9 &isp_dvp_d0d1>;
+			pinctrl-3 = <&isp_mipi &isp_dvp_d2d9 &isp_dvp_d0d1 &isp_dvp_d10d11>;
+			pinctrl-4 = <&isp_mipi &isp_dvp_d0d7>;
+			pinctrl-5 = <&isp_mipi &isp_flash_trigger>;
+			pinctrl-6 = <&isp_mipi &isp_flash_trigger &isp_prelight>;
 			
+			rockchip,isp,mipiphy = <2>;
+			rockchip,isp,cifphy = <1>;
+			
+			rockchip,isp,mipiphy1,reg = <0xff968000 0x4000>;
 			status = "okay";
 	};
 	
diff --git a/drivers/media/video/rk_camsys/Makefile b/drivers/media/video/rk_camsys/Makefile
index 4c0cc6a0bf9a..dfd880042164 100755
--- a/drivers/media/video/rk_camsys/Makefile
+++ b/drivers/media/video/rk_camsys/Makefile
@@ -2,6 +2,6 @@
 # Makefile for rockchip camsys driver
 #
 obj-$(CONFIG_CAMSYS_DRV) += camsys_drv.o 
-obj-$(CONFIG_CAMSYS_MRV) += camsys_marvin.o camsys_mipicsi_phy.o
+obj-$(CONFIG_CAMSYS_MRV) += camsys_marvin.o camsys_mipicsi_phy.o camsys_soc_priv.o 
 obj-$(CONFIG_CAMSYS_CIF) += camsys_cif.o
 
diff --git a/drivers/media/video/rk_camsys/camsys_drv.c b/drivers/media/video/rk_camsys/camsys_drv.c
index 6f16df4920eb..bd9df09af296 100755
--- a/drivers/media/video/rk_camsys/camsys_drv.c
+++ b/drivers/media/video/rk_camsys/camsys_drv.c
@@ -4,6 +4,7 @@
 #include "camsys_marvin.h"
 #include "camsys_mipicsi_phy.h"
 #include "camsys_gpio.h"
+#include "camsys_soc_priv.h"
 
 unsigned int camsys_debug=1;
 module_param(camsys_debug, int, S_IRUGO|S_IWUSR);
@@ -28,7 +29,6 @@ static int camsys_i2c_write(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev
     unsigned short msg_times,totallen,onelen;
     struct i2c_msg msg[1];
     struct i2c_adapter *adapter;
-    camsys_extdev_t *extdev;
     
     adapter = i2c_get_adapter(i2cinfo->bus_num);
     if (adapter == NULL) {
@@ -80,20 +80,6 @@ static int camsys_i2c_write(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev
     }
 
 end:
-#if 0
-    #if ((defined CONFIG_ARCH_RK319X) || (CONFIG_ARCH_ROCKCHIP))
-    if (!list_empty(&camsys_dev->extdevs.active)) {
-        list_for_each_entry(extdev, &camsys_dev->extdevs.active, active) {
-            if (extdev->phy.type == CamSys_Phy_Cif) {
-                if (extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_10b) {
-                    //iomux_set(CIF0_D0); // ZYC FOR 32
-                    //iomux_set(CIF0_D1); // ZYC FOR 32
-                }
-            }
-        }
-    }
-    #endif
-#endif
     return err;
 }
 
@@ -103,7 +89,6 @@ static int camsys_i2c_read(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev)
     unsigned char buf[8];
     struct i2c_msg msg[2];
     struct i2c_adapter *adapter;
-    camsys_extdev_t *extdev;
     
     adapter = i2c_get_adapter(i2cinfo->bus_num);
     if (adapter == NULL) {
@@ -151,20 +136,6 @@ static int camsys_i2c_read(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev)
     }
     
 end:
-#if 0
-    #if ((defined CONFIG_ARCH_RK319X) || (CONFIG_ARCH_ROCKCHIP))
-    if (!list_empty(&camsys_dev->extdevs.active)) {
-        list_for_each_entry(extdev, &camsys_dev->extdevs.active, active) {
-            if (extdev->phy.type == CamSys_Phy_Cif) {
-                if (extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_10b) {
-                    //iomux_set(CIF0_D0);//ZYC FOR 32
-                    //iomux_set(CIF0_D1);//ZYC FOR 32
-                }
-            }
-        }
-    }
-    #endif
-#endif 
     return err;
 }
 
@@ -182,19 +153,7 @@ static int camsys_extdev_register(camsys_devio_name_t *devio, camsys_dev_t *cams
         err = -EINVAL;
         camsys_err("dev_id: 0x%x is not support for camsys!",devio->dev_id);
         goto end;
-    }
-
-#if 0
-    if (devio->phy.type == CamSys_Phy_Mipi) {
-        if (camsys_find_devmem(CAMSYS_REGISTER_MIPIPHY_RES_NAME, camsys_dev) == NULL) {
-            camsys_err("dev_id: 0x%x is connect to MIPI CSI, but %s isn't support",devio->dev_id,
-                dev_name(camsys_dev->miscdev.this_device));
-
-            err = -EINVAL;
-            goto end;
-        }
-    }
-#endif    
+    }  
 
     extdev = camsys_find_extdev(devio->dev_id, camsys_dev);
     if (extdev != NULL) {
@@ -210,13 +169,15 @@ static int camsys_extdev_register(camsys_devio_name_t *devio, camsys_dev_t *cams
         err = -ENOMEM;
         goto end;
     }
-
+    
+    extdev->dev_cfg = devio->dev_cfg;
+    
     regulator_info = &devio->avdd;
     regulator = &extdev->avdd;
-    for (i=0; i<4; i++) {
+    for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
         if (strcmp(regulator_info->name,"NC")) {
             regulator->ldo = regulator_get(NULL,regulator_info->name);
-            if (IS_ERR(regulator->ldo)) {
+            if (IS_ERR_OR_NULL(regulator->ldo)) {
                 camsys_err("Get %s regulator for dev_id 0x%x failed!",regulator_info->name,devio->dev_id);
                 err = -EINVAL;
                 goto fail;
@@ -239,7 +200,7 @@ static int camsys_extdev_register(camsys_devio_name_t *devio, camsys_dev_t *cams
 
     gpio_info = &devio->pwrdn;
     gpio = &extdev->pwrdn;
-    for (i=0; i<5; i++) {
+    for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
         if (strcmp(gpio_info->name,"NC")) {
             gpio->io = camsys_gpio_get(gpio_info->name);
             if (gpio->io < 0) {
@@ -310,7 +271,7 @@ static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t *camsys_de
         }
 
         regulator = &extdev->avdd;
-        for (i=0; i<4; i++) {
+        for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
             if (!IS_ERR_OR_NULL(regulator->ldo)) {
                 while(regulator_is_enabled(regulator->ldo)>0)	
 		            regulator_disable(regulator->ldo);
@@ -320,7 +281,7 @@ static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t *camsys_de
         }
 
         gpio = &extdev->pwrdn;
-        for (i=0; i<5; i++) {
+        for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
             if (gpio->io!=0xffffffff) {                    
                 gpio_free(gpio->io);
             }
@@ -344,7 +305,7 @@ static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t *camsys_de
             extdev = list_first_entry(&camsys_dev->extdevs.list, camsys_extdev_t, list);
             if (extdev) {
                 regulator = &extdev->avdd;
-                for (i=0; i<4; i++) {
+                for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
                     if (!IS_ERR(regulator->ldo)) {
                         while(regulator_is_enabled(regulator->ldo)>0)	
     			            regulator_disable(regulator->ldo);
@@ -354,7 +315,7 @@ static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t *camsys_de
                 }
 
                 gpio = &extdev->pwrdn;
-                for (i=0; i<5; i++) {
+                for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
                     if (gpio->io!=0xffffffff) {                    
                         gpio_free(gpio->io);
                     }
@@ -402,18 +363,9 @@ static int camsys_sysctl(camsys_sysctrl_t *devctl, camsys_dev_t *camsys_dev)
 
             case CamSys_Rst:
             {
-                camsys_dev->reset_cb(camsys_dev);
+                camsys_dev->reset_cb(camsys_dev, devctl->on);
                 break;
-            }
-            #if 0
-            //for mipi
-            case CamSys_Gpio_Tag:
-            {
-                if((camsys_dev->mipiphy.ops )){
-                    camsys_dev->mipiphy.ops(NULL,NULL,devctl->on);
-                }
-            }
-            #endif
+            }            
             default:
                 break;
 
@@ -452,26 +404,32 @@ static int camsys_sysctl(camsys_sysctrl_t *devctl, camsys_dev_t *camsys_dev)
     mutex_unlock(&camsys_dev->extdevs.mut);
     return err;
 }
-static int camsys_phy_ops (camsys_extdev_phy_t *phy, void* ptr, unsigned int on)
+static int camsys_phy_ops (camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, void *ptr)
 {
     camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
+    camsys_mipiphy_t *mipiphy;
     int err = 0;
     
-    if (phy->type == CamSys_Phy_Mipi) {        
-        if (camsys_dev->mipiphy.ops && camsys_dev->mipiphy.clkin_cb) {
-            err =  camsys_dev->mipiphy.clkin_cb(camsys_dev,on);
-            err =  camsys_dev->mipiphy.ops(&phy->info.mipi,&camsys_dev->mipiphy, on);
+    if (extdev->phy.type == CamSys_Phy_Mipi) {
+        mipiphy = (camsys_mipiphy_t*)devctl->rev;
+        if (devctl->on == 0) {
+            mipiphy->phy_index = extdev->phy.info.mipi.phy_index;
+            mipiphy->bit_rate = 0;
+            mipiphy->data_en_bit = 0x00;
         } else {
-            camsys_err("%s isn't support mipi phy",dev_name(camsys_dev->miscdev.this_device));
-            err = -EINVAL;
+            if ((mipiphy->bit_rate == 0) || (mipiphy->data_en_bit == 0)) {
+                *mipiphy = extdev->phy.info.mipi;
+            }
+            if (mipiphy->phy_index != extdev->phy.info.mipi.phy_index) {
+                camsys_warn("mipiphy->phy_index(%d) != extdev->phy.info.mipi.phy_index(%d)!",
+                    mipiphy->phy_index,extdev->phy.info.mipi.phy_index);
+                mipiphy->phy_index = extdev->phy.info.mipi.phy_index;
+                
+            }
         }
-    } else if (phy->type == CamSys_Phy_Cif) {
-        if (camsys_dev->cifphy.ops && camsys_dev->cifphy.clkin_cb) {
-            err =  camsys_dev->cifphy.clkin_cb(camsys_dev,on);
-            err =  camsys_dev->cifphy.ops(&phy->info.cif,&camsys_dev->cifphy, on);
-        } else {
-            //camsys_err("%s isn't support cif phy",dev_name(camsys_dev->miscdev.this_device));
-            //err = -EINVAL;
+        err = camsys_dev->mipiphy[mipiphy->phy_index].ops(ptr,mipiphy);
+        if (err < 0) {
+            camsys_err("extdev(0x%x) mipi phy ops config failed!",extdev->dev_id);
         }
     }
 
@@ -492,13 +450,7 @@ static int camsys_irq_connect(camsys_irqcnnt_t *irqcnnt, camsys_dev_t *camsys_de
 
         err = -EINVAL;
         goto end;
-    }
-#if 0
-    //zyc for test mipi
-    if((camsys_dev->mipiphy.ops ) && (irqcnnt->mis == MRV_ISP_MIS)){
-        camsys_dev->mipiphy.ops(NULL,NULL,0);
-    }
-#endif    
+    }   
 
     spin_lock_irqsave(&camsys_dev->irq.lock,flags);
     if (!list_empty(&camsys_dev->irq.irq_pool)) {
@@ -598,7 +550,6 @@ static int camsys_irq_wait(camsys_irqsta_t *irqsta, camsys_dev_t *camsys_dev)
                 list_add_tail(&irqstas->list,&irqpool->deactive);
                 spin_unlock_irqrestore(&irqpool->lock,flags);
             } else {
-           //     camsys_warn("Thread(pid: %d) wait irq timeout!!",current->pid);
                 err = -EAGAIN;
             }
         } else {
@@ -700,6 +651,7 @@ static int camsys_open(struct inode *inode, struct file *file)
     int err = 0;
     int minor = iminor(inode);
     camsys_dev_t *camsys_dev;
+    unsigned int i,phycnt;
 
     spin_lock(&camsys_devs.lock);
     list_for_each_entry(camsys_dev, &camsys_devs.devs, list) {
@@ -712,6 +664,16 @@ static int camsys_open(struct inode *inode, struct file *file)
 
     //zyc add
     INIT_LIST_HEAD(&camsys_dev->extdevs.active);
+    
+    if (camsys_dev->mipiphy != NULL) {
+        phycnt = camsys_dev->mipiphy[0].phycnt;
+         
+        for (i=0; i<phycnt; i++) {
+            if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
+                camsys_dev->mipiphy[i].clkin_cb(camsys_dev,1);
+            }
+        }
+    }
 
     
     if (file->private_data == NULL) {
@@ -729,9 +691,20 @@ static int camsys_open(struct inode *inode, struct file *file)
 static int camsys_release(struct inode *inode, struct file *file)
 {
     camsys_dev_t *camsys_dev = (camsys_dev_t*)file->private_data;
-
+    unsigned int i,phycnt;
+    
     camsys_irq_disconnect(NULL,camsys_dev, true);
 
+    if (camsys_dev->mipiphy != NULL) {
+        phycnt = camsys_dev->mipiphy[0].phycnt;
+         
+        for (i=0; i<phycnt; i++) {
+            if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
+                camsys_dev->mipiphy[i].clkin_cb(camsys_dev,0);
+            }
+        }
+    }
+
     camsys_trace(1,"%s(%p) is closed",dev_name(camsys_dev->miscdev.this_device),camsys_dev);
 
     return 0;
@@ -1008,12 +981,13 @@ static int camsys_platform_probe(struct platform_device *pdev){
     unsigned long i2cmem;
 	camsys_meminfo_t *meminfo;
     unsigned int irq_id;
+    
     err = of_address_to_resource(dev->of_node, 0, &register_res);
     if (err < 0){
         camsys_err("Get register resource from %s platform device failed!",pdev->name);
         err = -ENODEV;
         goto fail_end;
-        }
+    }
 
  
     //map irqs
@@ -1046,8 +1020,14 @@ static int camsys_platform_probe(struct platform_device *pdev){
     
     INIT_LIST_HEAD(&camsys_dev->devmems.memslist);
 
+    // get soc operation
+    camsys_dev->soc = (void*)camsys_soc_get();
+    if (camsys_dev->soc == NULL) {
+        err = -ENODEV;
+        goto fail_end;
+    }
 
-        //Register mem init
+    //Register mem init
     meminfo = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
     if (meminfo == NULL) {
         err = -ENOMEM;
@@ -1059,7 +1039,7 @@ static int camsys_platform_probe(struct platform_device *pdev){
         camsys_err("%s ioremap %s failed",dev_name(&pdev->dev), CAMSYS_REGISTER_MEM_NAME);
         err = -ENXIO;
         goto request_mem_fail;
-        }
+    }
 
     strlcpy(meminfo->name, CAMSYS_REGISTER_MEM_NAME,sizeof(meminfo->name));
     meminfo->phy_base = register_res.start;
@@ -1067,7 +1047,7 @@ static int camsys_platform_probe(struct platform_device *pdev){
     list_add_tail(&meminfo->list, &camsys_dev->devmems.memslist);
 
 
-        //I2c mem init
+    //I2c mem init
     i2cmem = __get_free_page(GFP_KERNEL);
     if (i2cmem == 0) {
         camsys_err("Allocate i2cmem failed!");
@@ -1211,9 +1191,9 @@ static int  camsys_platform_remove(struct platform_device *pdev)
         if (!list_empty(&camsys_dev->extdevs.list)) {
             camsys_extdev_deregister(0,camsys_dev,true);
         }
-
-        if (camsys_dev->mipiphy.remove) 
-            camsys_dev->mipiphy.remove(pdev);
+        if (camsys_dev->mipiphy != NULL) {
+            camsys_dev->mipiphy->remove(pdev);
+        }
         if (camsys_dev->cifphy.remove)
             camsys_dev->cifphy.remove(pdev);
         camsys_dev->platform_remove(pdev);
@@ -1257,8 +1237,10 @@ static int __init camsys_platform_init(void)
         CAMSYS_DRIVER_VERSION&0xff,
         (CAMSYS_HEAD_VERSION&0xff0000)>>16, (CAMSYS_HEAD_VERSION&0xff00)>>8,
         CAMSYS_HEAD_VERSION&0xff);
+
     spin_lock_init(&camsys_devs.lock);
     INIT_LIST_HEAD(&camsys_devs.devs);
+    camsys_soc_init();
     platform_driver_register(&camsys_platform_driver);
    // platform_driver_probe(&camsys_platform_driver, camsys_platform_probe_new);
     
@@ -1268,6 +1250,7 @@ static int __init camsys_platform_init(void)
 static void __exit camsys_platform_exit(void)  
 {
     platform_driver_unregister(&camsys_platform_driver);
+    camsys_soc_deinit();
 } 
 
 module_init(camsys_platform_init);		
diff --git a/drivers/media/video/rk_camsys/camsys_internal.h b/drivers/media/video/rk_camsys/camsys_internal.h
index e652aec383e6..bf7a0d2c2375 100755
--- a/drivers/media/video/rk_camsys/camsys_internal.h
+++ b/drivers/media/video/rk_camsys/camsys_internal.h
@@ -45,7 +45,11 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/rockchip/cpu.h>
 #include <media/camsys_head.h>
+
+
+
 /*
 *               C A M S Y S   D R I V E R   V E R S I O N 
 *
@@ -63,10 +67,10 @@
 *        1) iomux d0 d1 for cif phy raw10 in rk319x after i2c operated;
 *        2) check mis value in camsys_irq_connect;
 *        3) add soft rest callback;
-*v0.0.7:
+*v0.7.0:
 *        1) check extdev is activate or not before delete from camsys_dev active list;
 */
-#define CAMSYS_DRIVER_VERSION                   KERNEL_VERSION(0,0,6)
+#define CAMSYS_DRIVER_VERSION                   KERNEL_VERSION(0,7,0)
 
 
 #define CAMSYS_PLATFORM_DRV_NAME                "RockChip-CamSys"
@@ -80,6 +84,7 @@
 
 #define CAMSYS_REGISTER_MEM_NAME                CAMSYS_REGISTER_RES_NAME
 #define CAMSYS_I2C_MEM_NAME                     "CamSys_I2cMem"
+#define CAMSYS_MIPIPHY_MEM_NAME                 CAMSYS_REGISTER_MIPIPHY_RES_NAME
 
 #define CAMSYS_NAMELEN_MIN(a)                   ((strlen(a)>(CAMSYS_NAME_LEN-1))?(CAMSYS_NAME_LEN-1):strlen(a))
 #define CAMSYS_IRQPOOL_NUM                      128
@@ -186,11 +191,12 @@ typedef struct camsys_extdev_s {
 } camsys_extdev_t;
 
 typedef struct camsys_phyinfo_s {
-    void               *clk;
-    camsys_meminfo_t   *reg;    
+    unsigned int             phycnt;
+    void                     *clk;
+    camsys_meminfo_t         *reg;    
 
     int (*clkin_cb)(void *ptr, unsigned int on);
-    int (*ops) (void *phy, void *phyinfo, unsigned int on);
+    int (*ops) (void *ptr, camsys_mipiphy_t *phy);
     int (*remove)(struct platform_device *pdev);
 } camsys_phyinfo_t;
 
@@ -208,17 +214,19 @@ typedef struct camsys_dev_s {
     struct miscdevice     miscdev;  
     void                  *clk;
 
-    camsys_phyinfo_t      mipiphy;
+    camsys_phyinfo_t      *mipiphy;
     camsys_phyinfo_t      cifphy;
 
     camsys_exdevs_t       extdevs;    
     struct list_head      list;
     struct platform_device *pdev;
 
+    void                  *soc;
+
     int (*clkin_cb)(void *ptr, unsigned int on);
     int (*clkout_cb)(void *ptr,unsigned int on,unsigned int clk);
-    int (*reset_cb)(void *ptr);
-    int (*phy_cb) (camsys_extdev_phy_t *phy,void* ptr, unsigned int on);
+    int (*reset_cb)(void *ptr, unsigned int on);
+    int (*phy_cb) (camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, void* ptr);
     int (*iomux)(camsys_extdev_t *extdev,void *ptr);
     int (*platform_remove)(struct platform_device *pdev);
 } camsys_dev_t;
@@ -260,15 +268,14 @@ static inline int camsys_sysctl_extdev(camsys_extdev_t *extdev, camsys_sysctrl_t
     camsys_regulator_t *regulator;
     camsys_gpio_t *gpio;
     
-    if (devctl->ops < CamSys_Vdd_Tag) {
+    if ((devctl->ops>CamSys_Vdd_Start_Tag) && (devctl->ops < CamSys_Vdd_End_Tag)) {
         regulator = &extdev->avdd;
-        regulator += devctl->ops;
-
-        //printk("regulator: %p  regulator->ldo: %p\n",regulator,regulator->ldo);
+        regulator += devctl->ops-1;
+        
         if (!IS_ERR_OR_NULL(regulator->ldo)) {
             if (devctl->on) {
-                regulator_set_voltage(regulator->ldo,regulator->min_uv,regulator->max_uv);
-                regulator_enable(regulator->ldo);
+                err = regulator_set_voltage(regulator->ldo,regulator->min_uv,regulator->max_uv);
+                err |= regulator_enable(regulator->ldo);
                 camsys_trace(1,"Sysctl %d success, regulator set (%d,%d) uv!",devctl->ops, regulator->min_uv,regulator->max_uv);
             } else {
                 while(regulator_is_enabled(regulator->ldo)>0)	
@@ -276,13 +283,13 @@ static inline int camsys_sysctl_extdev(camsys_extdev_t *extdev, camsys_sysctrl_t
 			    camsys_trace(1,"Sysctl %d success, regulator off!",devctl->ops);
             }
         } else {
-            camsys_err("Sysctl %d failed, because regulator ldo is NULL!",devctl->ops);
+            //camsys_err("Sysctl %d failed, because regulator ldo is NULL!",devctl->ops);
             err = -EINVAL;
             goto end;
         }
-    } else if (devctl->ops < CamSys_Gpio_Tag) {
+    } else if ((devctl->ops>CamSys_Gpio_Start_Tag) && (devctl->ops < CamSys_Gpio_End_Tag)) {
         gpio = &extdev->pwrdn;
-        gpio += devctl->ops - CamSys_Vdd_Tag -1;
+        gpio += devctl->ops - CamSys_Gpio_Start_Tag -1;
 
         if (gpio->io != 0xffffffff) {
             if (devctl->on) {
@@ -301,9 +308,10 @@ static inline int camsys_sysctl_extdev(camsys_extdev_t *extdev, camsys_sysctrl_t
         }
     } else if (devctl->ops == CamSys_ClkIn) {
         if (camsys_dev->clkout_cb)
-            camsys_dev->clkout_cb(camsys_dev,devctl->on,extdev->clk.in_rate);
+            camsys_dev->clkout_cb(camsys_dev,devctl->on,extdev->clk.in_rate);        
+    } else if (devctl->ops == CamSys_Phy) {
         if (camsys_dev->phy_cb)
-            camsys_dev->phy_cb(&extdev->phy, camsys_dev, devctl->on);
+            (camsys_dev->phy_cb)(extdev,devctl,(void*)camsys_dev);
     }
 
 end:
diff --git a/drivers/media/video/rk_camsys/camsys_marvin.c b/drivers/media/video/rk_camsys/camsys_marvin.c
index 751f749def50..5db6e547bf1c 100755
--- a/drivers/media/video/rk_camsys/camsys_marvin.c
+++ b/drivers/media/video/rk_camsys/camsys_marvin.c
@@ -1,119 +1,125 @@
 #include "camsys_marvin.h"
+#include "camsys_soc_priv.h"
 
 static const char miscdev_name[] = CAMSYS_MARVIN_DEVNAME;
 
 static int camsys_mrv_iomux_cb(camsys_extdev_t *extdev,void *ptr)
-{  
-    unsigned int cif_vol_sel;
-#if 0    
-    if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
-        iomux_set(ISP_FLASH_TRIG);  
-        if (extdev->fl.fl.io != 0xffffffff) {
-            iomux_set(ISP_FL_TRIG);
-        }
-    } 
-
-    if (extdev->dev_cfg & CAMSYS_DEVCFG_PREFLASHLIGHT) {
-        iomux_set(ISP_PRELIGHT_TRIG);
-    }
-    
-    if (extdev->dev_cfg & CAMSYS_DEVCFG_SHUTTER) {
-        iomux_set(ISP_SHUTTER_OPEN);
-        iomux_set(ISP_SHUTTER_TRIG);
-    }
-
-    iomux_set(CIF0_CLKOUT);
-#endif
-
+{
     struct pinctrl      *pinctrl;
     struct pinctrl_state    *state;
     int retval = 0;
     char state_str[20] = {0};
-
+    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
     struct device *dev = &(extdev->pdev->dev);
+    camsys_soc_priv_t *soc;
+
+    // DVP IO Config
     
     if (extdev->phy.type == CamSys_Phy_Cif) {
-        if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_8b)&& (extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
 
-           strcpy(state_str,"isp_dvp8bit");
+        switch (extdev->phy.info.cif.fmt)
+        {
+            case CamSys_Fmt_Raw_8b:
+            case CamSys_Fmt_Yuv420_8b:
+            case CamSys_Fmt_Yuv422_8b:
+            {
+                if (extdev->phy.info.cif.cifio == CamSys_SensorBit0_CifBit0) {
+                    strcpy(state_str,"isp_dvp8bit0");
+                } else if (extdev->phy.info.cif.cifio == CamSys_SensorBit0_CifBit2) {
+                    strcpy(state_str,"isp_dvp8bit2");
+                } else {
+                    camsys_err("extdev->phy.info.cif.cifio: 0x%x is invalidate!", extdev->phy.info.cif.cifio);
+                    goto fail;
+                }
 
-        }
+                break;
+            }
 
-        if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_10b)&& (extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
-           strcpy(state_str,"isp_dvp10bit");
-        }
+            case CamSys_Fmt_Raw_10b:
+            {
+                strcpy(state_str,"isp_dvp10bit");
+                break;
+            }
 
-        if (extdev->phy.info.cif.fmt == CamSys_Fmt_Raw_12b) {
-           strcpy(state_str,"isp_dvp12bit");
+            case CamSys_Fmt_Raw_12b:
+            {
+                strcpy(state_str,"isp_dvp12bit");
+                break;
+            }
 
+            default:
+            {
+                camsys_err("extdev->phy.info.cif.fmt: 0x%x is invalidate!",extdev->phy.info.cif.fmt);
+                goto fail;
+            }
+        }        
+    } else {
+        if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
+            if (extdev->dev_cfg & CAMSYS_DEVCFG_PREFLASHLIGHT) {
+                strcpy(state_str,"isp_mipi_fl_prefl");
+            } else {
+                strcpy(state_str,"isp_mipi_fl");
+            }
+        } else {
+            strcpy(state_str,"default");
         }
-    }else{
-           strcpy(state_str,"default");
     }
 
-    //mux CIF0_CLKOUT
-
+    camsys_trace(1,"marvin pinctrl select: %s", state_str);
+    
     pinctrl = devm_pinctrl_get(dev);
     if (IS_ERR(pinctrl)) {
-        camsys_err("%s:Get pinctrl failed!\n",__func__);
-        return -1;
+        camsys_err("devm_pinctrl_get failed!");
+        goto fail;
     }
     state = pinctrl_lookup_state(pinctrl,
                          state_str);
     if (IS_ERR(state)){
-        dev_err(dev, "%s:could not get %s pinstate\n",__func__,state_str);
-        return -1;
-        }
+        camsys_err("pinctrl_lookup_state failed!");
+        goto fail;
+    }
 
     if (!IS_ERR(state)) {
         retval = pinctrl_select_state(pinctrl, state);
         if (retval){
-            dev_err(dev,
-                "%s:could not set %s pins\n",__func__,state_str);
-                return -1;
-
-                }
+            camsys_err("pinctrl_select_state failed!");
+            goto fail;
+        }
     }
 
-    //set 1.8v vol domain for rk32
-    __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
-   __raw_writel(0xffffffff, RK_GRF_VIRT+0x01d4);   
-
-    //set cif vol domain
-    if (extdev->phy.type == CamSys_Phy_Cif) {
-
-        #if 0
-        if (!IS_ERR_OR_NULL(extdev->dovdd.ldo)) {
-            if (extdev->dovdd.max_uv >= 25000000) {
-                __raw_writel(((1<<1)|(1<<(1+16))),RK30_GRF_BASE+0x018c);
-            } else {
-                __raw_writel((1<<(1+16)),RK30_GRF_BASE+0x018c);
-            }
+    if (camsys_dev->soc) {
+        soc = (camsys_soc_priv_t*)camsys_dev->soc;
+        if (soc->soc_cfg) {
+            (soc->soc_cfg)(Cif_IoDomain_Cfg,(void*)&extdev->dovdd.min_uv);
+            (soc->soc_cfg)(Clk_DriverStrength_Cfg,(void*)&extdev->clk.driver_strength);
         } else {
-            __raw_writel(((1<<1)|(1<<(1+16))),RK30_GRF_BASE+0x018c);
+            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
         }
-        #else
-
-        //set 1.8v vol domain
-        __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
-        #endif
-        
-        //set driver strength
-      //  __raw_writel(0xffffffff, RK_GRF_VIRT+0x01dc);   
+    } else {
+        camsys_err("camsys_dev->soc is NULL!");
     }
     
     return 0;
+fail:
+    return -1;
 }
 
-static int camsys_mrv_reset_cb(void *ptr)
+static int camsys_mrv_reset_cb(void *ptr,unsigned int on)
 {
     camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    #if 0 //do nothing ,zyc
-    cru_set_soft_reset(SOFT_RST_ISP,true);
-    udelay(100);
-    cru_set_soft_reset(SOFT_RST_ISP,false);
-    #endif
-    camsys_trace(1, "%s soft reset\n",dev_name(camsys_dev->miscdev.this_device));
+    camsys_soc_priv_t *soc;
+
+    if (camsys_dev->soc) {
+        soc = (camsys_soc_priv_t*)camsys_dev->soc;
+        if (soc->soc_cfg) {
+            (soc->soc_cfg)(Isp_SoftRst,(void*)on);
+        } else {
+            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
+        }
+    } else {
+        camsys_err("camsys_dev->soc is NULL!");
+    }
+    
     return 0;
 }
 
@@ -121,15 +127,8 @@ static int camsys_mrv_clkin_cb(void *ptr, unsigned int on)
 {
     camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
     camsys_mrv_clk_t *clk = (camsys_mrv_clk_t*)camsys_dev->clk;
-    struct clk *cif_clk_out_div;
-	//  spin_lock(&clk->lock);
+	
     if (on && !clk->in_on) {
-        
-		clk_set_rate(clk->isp,180000000);
-        clk_set_rate(clk->isp_jpe, 180000000);
-   //     clk_set_rate(clk->aclk_isp,24000000);
-   //     clk_set_rate(clk->hclk_isp,24000000);
-
 
         clk_prepare_enable(clk->aclk_isp);
         clk_prepare_enable(clk->hclk_isp);
@@ -138,19 +137,13 @@ static int camsys_mrv_clkin_cb(void *ptr, unsigned int on)
         clk_prepare_enable(clk->clk_mipi_24m); 
         clk_prepare_enable(clk->pclkin_isp); 
 		clk_prepare_enable(clk->pd_isp);
-
-
- //       clk_enable(clk->pd_isp);
-  //      clk_enable(clk->aclk_isp);
-  //  	clk_enable(clk->hclk_isp);    	
-  //  	clk_enable(clk->isp);
- //   	clk_enable(clk->isp_jpe);
- //   	clk_enable(clk->pclkin_isp);
     	
         clk->in_on = true;
 
         camsys_trace(1, "%s clock in turn on",dev_name(camsys_dev->miscdev.this_device));
-        camsys_mrv_reset_cb(ptr);       
+        camsys_mrv_reset_cb(ptr,1);
+        udelay(100);
+        camsys_mrv_reset_cb(ptr,0);
         
     } else if (!on && clk->in_on) {
 
@@ -162,18 +155,11 @@ static int camsys_mrv_clkin_cb(void *ptr, unsigned int on)
         clk_disable_unprepare(clk->clk_mipi_24m); 
         clk_disable_unprepare(clk->pclkin_isp); 
 		clk_disable_unprepare(clk->pd_isp);
-  //      clk_disable(clk->pd_isp);
-  //      clk_disable(clk->aclk_isp);
-   // 	clk_disable(clk->hclk_isp);
-  //  	clk_disable(clk->isp);
-  //  	clk_disable(clk->isp_jpe);
- //   	clk_disable(clk->pclkin_isp);
-
 
         clk->in_on = false;
         camsys_trace(1, "%s clock in turn off",dev_name(camsys_dev->miscdev.this_device));
     }
-  //  spin_unlock(&clk->lock);
+    
     return 0;
 }
 
@@ -181,9 +167,8 @@ static int camsys_mrv_clkout_cb(void *ptr, unsigned int on,unsigned int inclk)
 {
     camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
     camsys_mrv_clk_t *clk = (camsys_mrv_clk_t*)camsys_dev->clk;
-    struct clk *cif_clk_out_div;
     
-    spin_lock(&clk->lock);
+    mutex_lock(&clk->lock);
     if (on && (clk->out_on != on)) {  
 
         clk_set_rate(clk->cif_clk_out,inclk);
@@ -191,29 +176,21 @@ static int camsys_mrv_clkout_cb(void *ptr, unsigned int on,unsigned int inclk)
         
 		clk->out_on = on;
         camsys_trace(1, "%s clock out(rate: %dHz) turn on",dev_name(camsys_dev->miscdev.this_device),
-                    clk->out_on);
+                    inclk);
     } else if (!on && clk->out_on) {
-        cif_clk_out_div =  clk_get(NULL, "cif0_out_div");
-        if(IS_ERR_OR_NULL(cif_clk_out_div)) {
-            cif_clk_out_div =  clk_get(NULL, "cif_out_div");
-			printk("can't get clk_cif_pll");
-        }
-
-        if(!IS_ERR_OR_NULL(cif_clk_out_div)) {
-            clk_set_parent(clk->cif_clk_out, cif_clk_out_div);
-            clk_put(cif_clk_out_div);
+        if(!IS_ERR_OR_NULL(clk->cif_clk_pll)) {
+            clk_set_parent(clk->cif_clk_out, clk->cif_clk_pll);
         } else {
             camsys_warn("%s clock out may be not off!", dev_name(camsys_dev->miscdev.this_device));
         }
 
         clk_disable_unprepare( clk->cif_clk_out);
-//        clk_disable(clk->cif_clk_out);
 
         clk->out_on = 0;
 
         camsys_trace(1, "%s clock out turn off",dev_name(camsys_dev->miscdev.this_device));
     }
-    spin_unlock(&clk->lock);    
+    mutex_unlock(&clk->lock);    
 
     return 0;
 }
@@ -295,25 +272,25 @@ static int camsys_mrv_remove_cb(struct platform_device *pdev)
             camsys_mrv_clkin_cb(mrv_clk,0);
     
         if (!IS_ERR_OR_NULL(mrv_clk->pd_isp)) {
-		 	clk_put(mrv_clk->pd_isp);
+		 	devm_clk_put(&pdev->dev,mrv_clk->pd_isp);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp)) {
-            clk_put(mrv_clk->aclk_isp);
+            devm_clk_put(&pdev->dev,mrv_clk->aclk_isp);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp)) {
-            clk_put(mrv_clk->hclk_isp);
+            devm_clk_put(&pdev->dev,mrv_clk->hclk_isp);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->isp)) {
-            clk_put(mrv_clk->isp);
+            devm_clk_put(&pdev->dev,mrv_clk->isp);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->isp_jpe)) {
-            clk_put(mrv_clk->isp_jpe);
+            devm_clk_put(&pdev->dev,mrv_clk->isp_jpe);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp)) {
-            clk_put(mrv_clk->pclkin_isp);
+            devm_clk_put(&pdev->dev,mrv_clk->pclkin_isp);
         }
         if (!IS_ERR_OR_NULL(mrv_clk->cif_clk_out)) {
-            clk_put(mrv_clk->cif_clk_out);
+            devm_clk_put(&pdev->dev,mrv_clk->cif_clk_out);
         }
 
         kfree(mrv_clk);
@@ -326,8 +303,6 @@ int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
 {
     int err = 0;   
     camsys_mrv_clk_t *mrv_clk=NULL;
-    //struct clk *clk_parent; 
-    struct clk *cif_clk_out_div;
     
 	err = request_irq(camsys_dev->irq.irq_id, camsys_mrv_irq, 0, CAMSYS_MARVIN_IRQNAME,camsys_dev);
     if (err) {
@@ -349,7 +324,8 @@ int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
     mrv_clk->isp = devm_clk_get(&pdev->dev, "clk_isp");
     mrv_clk->isp_jpe = devm_clk_get(&pdev->dev, "clk_isp_jpe");
     mrv_clk->pclkin_isp = devm_clk_get(&pdev->dev, "pclkin_isp");
-    mrv_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_vipout");
+    mrv_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
+    mrv_clk->cif_clk_pll = devm_clk_get(&pdev->dev, "clk_cif_pll");
     mrv_clk->clk_mipi_24m = devm_clk_get(&pdev->dev,"clk_mipi_24m"); 
     
 	if (IS_ERR_OR_NULL(mrv_clk->pd_isp) || IS_ERR_OR_NULL(mrv_clk->aclk_isp) || IS_ERR_OR_NULL(mrv_clk->hclk_isp) ||
@@ -359,12 +335,11 @@ int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
         err = -EINVAL;
         goto clk_failed;
     }
-
-   
-//    clk_set_rate(mrv_clk->isp,1800000000);
-//    clk_set_rate(mrv_clk->isp_jpe,180000000);
     
-    spin_lock_init(&mrv_clk->lock);
+    clk_set_rate(mrv_clk->isp,384000000);
+    clk_set_rate(mrv_clk->isp_jpe, 384000000);
+    
+    mutex_init(&mrv_clk->lock);
     
     mrv_clk->in_on = false;
     mrv_clk->out_on = 0;
diff --git a/drivers/media/video/rk_camsys/camsys_marvin.h b/drivers/media/video/rk_camsys/camsys_marvin.h
index dfdd0dbd40f8..a066807e3148 100755
--- a/drivers/media/video/rk_camsys/camsys_marvin.h
+++ b/drivers/media/video/rk_camsys/camsys_marvin.h
@@ -33,9 +33,10 @@ typedef struct camsys_mrv_clk_s {
     bool             in_on;
 
     struct clk      *cif_clk_out;
+    struct clk      *cif_clk_pll;
     unsigned int     out_on;
 
-    spinlock_t       lock;
+    struct mutex     lock;
 } camsys_mrv_clk_t;
 
 int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev);
diff --git a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
index 407ada10c465..a124be8c7b85 100755
--- a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
+++ b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
@@ -1,270 +1,174 @@
+#include "camsys_soc_priv.h"
 #include "camsys_mipicsi_phy.h"
 
-#if defined(CONFIG_ARCH_ROCKCHIP)
-//GRF_SOC_CON14
-//bit 0     dphy_rx0_testclr
-//bit 1     dphy_rx0_testclk
-//bit 2     dphy_rx0_testen
-//bit 3:10 dphy_rx0_testdin
-#define GRF_SOC_CON14_OFFSET    (0x027c)
-#define DPHY_RX0_TESTCLR_MASK   (0x1<<16)
-#define DPHY_RX0_TESTCLK_MASK   (0x1<<17)
-#define DPHY_RX0_TESTEN_MASK    (0x1<<18)
-#define DPHY_RX0_TESTDIN_MASK   (0xff<<19)
-
-#define DPHY_RX0_TESTCLR    (1<<0)
-#define DPHY_RX0_TESTCLK    (1<<1)
-#define DPHY_RX0_TESTEN     (1<<2)
-#define DPHY_RX0_TESTDIN_OFFSET    (3)
-
-#define DPHY_TX1RX1_ENABLECLK_MASK   (0x1<<28)
-#define DPHY_RX1_SRC_SEL_MASK        (0x1<<29)
-#define DPHY_TX1RX1_MASTERSLAVEZ_MASK (0x1<<30)
-#define DPHY_TX1RX1_BASEDIR_OFFSET  (0x1<<31)
-
-#define DPHY_TX1RX1_ENABLECLK           (0x1<<12)
-#define DPHY_TX1RX1_DISABLECLK          (0x0<<12)
-#define DPHY_RX1_SRC_SEL_ISP          (0x1<<13)
-#define DPHY_TX1RX1_SLAVEZ            (0x0<<14)
-#define DPHY_TX1RX1_BASEDIR_REC       (0x1<<15)
-
-
-
-//GRF_SOC_CON6
-//bit 0 grf_con_disable_isp
-//bit 1 grf_con_isp_dphy_sel  1'b0 mipi phy rx0
-#define GRF_SOC_CON6_OFFSET    (0x025c)
-#define MIPI_PHY_DISABLE_ISP_MASK       (0x1<<16)
-#define MIPI_PHY_DISABLE_ISP            (0x0<<0)
-
-#define DSI_CSI_TESTBUS_SEL_MASK        (0x1<<30)
-#define DSI_CSI_TESTBUS_SEL_OFFSET_BIT  (14)
-
-
-#define MIPI_PHY_DPHYSEL_OFFSET_MASK (0x1<<17)
-#define MIPI_PHY_DPHYSEL_OFFSET_BIT (0x1)
-
-//GRF_SOC_CON10
-//bit12:15 grf_dphy_rx0_enable
-//bit 0:3 turn disable
-#define GRF_SOC_CON10_OFFSET                (0x026c)
-#define DPHY_RX0_TURN_DISABLE_MASK          (0xf<<16)
-#define DPHY_RX0_TURN_DISABLE_OFFSET_BITS   (0x0)
-#define DPHY_RX0_ENABLE_MASK                (0xf<<28)
-#define DPHY_RX0_ENABLE_OFFSET_BITS         (12)
-
-//GRF_SOC_CON9
-//bit12:15 grf_dphy_rx0_enable
-//bit 0:3 turn disable
-#define GRF_SOC_CON9_OFFSET                (0x0268)
-#define DPHY_TX1RX1_TURN_DISABLE_MASK          (0xf<<16)
-#define DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS   (0x0)
-#define DPHY_TX1RX1_ENABLE_MASK                (0xf<<28)
-#define DPHY_TX1RX1_ENABLE_OFFSET_BITS         (12)
-
-//GRF_SOC_CON15
-//bit 0:3   turn request
-#define GRF_SOC_CON15_OFFSET                (0x03a4) 
-#define DPHY_RX0_TURN_REQUEST_MASK          (0xf<<16)
-#define DPHY_RX0_TURN_REQUEST_OFFSET_BITS   (0x0)
-
-#define DPHY_TX1RX1_TURN_REQUEST_MASK          (0xf<<20)
-#define DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS   (0x0)
-
-
-#endif
-
-
-static void phy_select(uint8_t index)
+static int camsys_mipiphy_clkin_cb(void *ptr, unsigned int on)
 {
-    if((index == 0) || (index == 1)){
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DPHYSEL_OFFSET_MASK | (index<<MIPI_PHY_DPHYSEL_OFFSET_BIT)); 
-        if(index == 1){
-            write_grf_reg(GRF_SOC_CON6_OFFSET, DSI_CSI_TESTBUS_SEL_MASK | (1<<DSI_CSI_TESTBUS_SEL_OFFSET_BIT)); 
-
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX1_SRC_SEL_ISP | DPHY_RX1_SRC_SEL_MASK); 
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_SLAVEZ | DPHY_TX1RX1_MASTERSLAVEZ_MASK); 
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_BASEDIR_REC | DPHY_TX1RX1_BASEDIR_OFFSET); 
+    camsys_mipiphy_clk_t *clk;
+    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
+    unsigned int i,phycnt;
+    
+    if (camsys_dev->mipiphy != NULL) {
+        phycnt = camsys_dev->mipiphy[0].phycnt;
+         
+        for (i=0; i<phycnt; i++) {
+            if (camsys_dev->mipiphy[i].clk != NULL) {
+                clk = (camsys_mipiphy_clk_t*)camsys_dev->mipiphy[i].clk;
+                if (on && !clk->on) {
+                    if (!IS_ERR_OR_NULL(clk->hclk))
+                        clk_prepare_enable(clk->hclk);  
+                    clk->on = on;
+                } else if (!on && clk->on) {
+                    if (!IS_ERR_OR_NULL(clk->hclk))
+                        clk_disable_unprepare(clk->hclk);                    
+                    clk->on = on;
+                }
+            }
         }
-
-    }else{
-        camsys_err("phy index is erro!");
-        
     }
+    if (on)
+        camsys_trace(1, "%s mipi phy clk in turn on",dev_name(camsys_dev->miscdev.this_device));
+    else 
+        camsys_trace(1, "%s mipi phy clk in turn off",dev_name(camsys_dev->miscdev.this_device));
+    
+    return 0;
 }
 
-
-static void phy0_WriteReg(uint8_t addr, uint8_t data)
+static int camsys_mipiphy_ops (void * ptr, camsys_mipiphy_t *phy)
 {
-   // uint8_t test_data = 0;
-    //TESTEN =1,TESTDIN=addr
-    write_grf_reg(GRF_SOC_CON14_OFFSET,(( addr << DPHY_RX0_TESTDIN_OFFSET) |DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN| DPHY_RX0_TESTEN_MASK)); 
-//	//TESTCLK=1
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);
+    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
+    camsys_mipiphy_soc_para_t para;
+    camsys_soc_priv_t *soc;
     
-    //TESTCLK=0
-	 write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK); 
-  
-    if(data != -1){ //write data ?
-    	 //TESTEN =0,TESTDIN=data
-        write_grf_reg(GRF_SOC_CON14_OFFSET, (( data << DPHY_RX0_TESTDIN_OFFSET)|DPHY_RX0_TESTDIN_MASK |DPHY_RX0_TESTEN)); 
-
-        //TESTCLK=1
-        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); 
+    if (camsys_dev->soc) {
+        soc = (camsys_soc_priv_t*)camsys_dev->soc;
+        if (soc->soc_cfg) { 
+            para.camsys_dev = camsys_dev;
+            para.phy = phy;
+            (soc->soc_cfg)(Mipi_Phy_Cfg,(void*)&para);
+        } else {
+            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
+        }
+    } else {
+        camsys_err("camsys_dev->soc is NULL!");
     }
+    
+    return 0;
 }
 
-static uint8_t phy0_ReadReg(uint8_t addr)  
+static int camsys_mipiphy_remove_cb(struct platform_device *pdev)
 {
-    uint8_t data = 0;
+    camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
+    camsys_mipiphy_clk_t *phyclk;
+    unsigned int i;
     
-    //TESTEN =1,TESTDIN=addr
-    write_grf_reg(GRF_SOC_CON14_OFFSET,(( addr << DPHY_RX0_TESTDIN_OFFSET) |DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN| DPHY_RX0_TESTEN_MASK)); 
-
-    //TESTCLK=0
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK); 
-
-    return data ;
+    if (camsys_dev->mipiphy != NULL) {
+        for (i=0; i<camsys_dev->mipiphy[0].phycnt; i++) {
+            if (camsys_dev->mipiphy[i].reg != NULL) {
+                if (camsys_dev->mipiphy[i].reg->vir_base != 0) {
+                    iounmap((void __iomem *)camsys_dev->mipiphy[i].reg->vir_base);
+                    camsys_dev->mipiphy[i].reg->vir_base = 0;
+                }
+                kfree(camsys_dev->mipiphy[i].reg);
+                camsys_dev->mipiphy[i].reg = NULL;
+            }
+
+            if (camsys_dev->mipiphy[i].clk != NULL) {
+                phyclk = (camsys_mipiphy_clk_t*)camsys_dev->mipiphy[i].clk;
+                devm_clk_put(&pdev->dev,phyclk->hclk);
+
+                kfree(camsys_dev->mipiphy[i].clk);
+                camsys_dev->mipiphy[i].clk = NULL;
+            }
+        }
+    }
 
     
+    return 0;
 }
-
-static void phy_config_num_lane(uint8_t index,int numLane)
+int camsys_mipiphy_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
 {
-    uint8_t lane_mask =0;
-    int i = 0;
-
-    for(i=0;i<numLane;i++){
-        lane_mask |= 1<<i;
+    struct device *dev = &pdev->dev;
+    camsys_meminfo_t *meminfo;
+    camsys_phyinfo_t *mipiphy;
+    unsigned int mipiphy_cnt,phyreg[2];
+    char str[31];
+    struct clk* clk;
+    camsys_mipiphy_clk_t *phyclk;
+    int err,i;
+
+    err = of_property_read_u32(dev->of_node,"rockchip,isp,mipiphy",&mipiphy_cnt);
+    if (err < 0) {
+        camsys_err("get property(rockchip,isp,mipiphy) failed!");
+        goto fail;
+    } else {
+        camsys_trace(2, "%s have %d mipi phy\n",dev_name(&pdev->dev),mipiphy_cnt);
     }
-    camsys_trace(1,"lane num = 0x%d\n",lane_mask);
-    if(index == 0){
-    //  set lane num
-        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_ENABLE_MASK | (lane_mask << DPHY_RX0_ENABLE_OFFSET_BITS)); 
-    //  set lan turndisab as 1
-        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_TURN_DISABLE_MASK | (0xf << DPHY_RX0_TURN_DISABLE_OFFSET_BITS));
-
-        write_grf_reg(GRF_SOC_CON10_OFFSET, (0xc<<4)|(0xf<<20));
-
-    //  set lan turnrequest as 0   
-        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_RX0_TURN_REQUEST_MASK | (0x0 << DPHY_RX0_TURN_REQUEST_OFFSET_BITS));
-    }else if(index == 1){
-    //  set lane num
-        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_ENABLE_MASK | (lane_mask << DPHY_TX1RX1_ENABLE_OFFSET_BITS)); 
-    //  set lan turndisab as 1
-        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_TURN_DISABLE_MASK | (0xf << DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS));
-    //  set lan turnrequest as 0   
-        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_TX1RX1_TURN_REQUEST_MASK | (0x0 << DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS));
+    
+    mipiphy = kzalloc(sizeof(camsys_phyinfo_t)*mipiphy_cnt,GFP_KERNEL);
+    if (mipiphy == NULL) {
+        err = -ENOMEM;
+        camsys_err("malloc camsys_phyinfo_t failed!");
+        goto fail;
     }
-}
-
-static void phy0_start(int freq,int numLane)
-{
-//TESTCLK=1
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); 
-//TESTCLR=1    
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK |DPHY_RX0_TESTCLR);   
-//TESTCLR=0  zyc
-//    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK); 
-    udelay(1000);
-
-//**********************************************************************//
-
-#if 1
-//set clock lane
-    phy0_WriteReg(0x34,0x14);
-
-//set lane 0
- /********************
-    500-550M 0x0E
-    600-650M 0x10
-    720M     0x12
-    360M     0x2A
-    *******************/
-    phy0_WriteReg(0x44,0x10);
-    if(numLane > 1)
-        phy0_WriteReg(0x54,0x10);
-#endif
- 
- //**********************************************************************//
-
-//Normal operation
-    phy0_WriteReg(0x0,-1);
-    //TESTCLK=1
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); 
-
-    //TESTEN =0
-    write_grf_reg(GRF_SOC_CON14_OFFSET, (DPHY_RX0_TESTEN_MASK)); 
-
-}
-
-
-
-static int camsys_mipiphy_ops (void *phy, void *phyinfo, unsigned int on)
-{
-#if 0
-    camsys_phyinfo_t* phyinfo_s = (camsys_phyinfo_t*)phyinfo;
-    struct camsys_mipiphy_s* phy_s = (struct camsys_mipiphy_s*)phy;
-    if(phy_s->phy_index == 0){
-        phy_select(phy_s->phy_index);
-        phy_config_num_lane(phy_s->data_en_bit);
-        phy0_start(0,phy_s->data_en_bit);
-
-    }else if(phy_s->phy_index == 1){
-
-    }else{
 
-        camsys_err("phy index is erro!");
-    }
-#else
-#if 0
-    if(on == 1){
-    //disable isp
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DISABLE_ISP_MASK | 1); 
-        phy_select(0);
-    //    phy_config_num_lane(0,2);
-        phy0_start(0,2);
+    camsys_dev->mipiphy = mipiphy;
+
+    memset(str,0x00,sizeof(str));
+    for (i=0; i<mipiphy_cnt; i++) {
+        meminfo = NULL;
+        sprintf(str,"rockchip,isp,mipiphy%d,reg",i);
+        if (of_property_read_u32_array(dev->of_node,str,phyreg,2) == 0) {
+            meminfo = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
+            if (meminfo == NULL) {                
+                camsys_err("malloc camsys_meminfo_t for mipiphy%d failed!",i);                
+            } else {
+                meminfo->vir_base = (unsigned int)ioremap(phyreg[0],phyreg[1]);
+                if (!meminfo->vir_base){
+                    camsys_err("%s ioremap %s failed",dev_name(&pdev->dev), str);                    
+                } else {
+                    strlcpy(meminfo->name, CAMSYS_MIPIPHY_MEM_NAME,sizeof(meminfo->name));
+                    meminfo->phy_base = phyreg[0];
+                    meminfo->size = phyreg[1];
+                }
+               
+                camsys_dev->mipiphy[i].reg = meminfo;
+            }
+        }
 
-        phy_config_num_lane(0,2);
-        udelay(200);
-    //enable isp
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DISABLE_ISP_MASK | 0); 
-    }else
-#endif
-    {
-    //disable isp
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DISABLE_ISP_MASK | 1); 
-        phy_select(0);
-        phy_config_num_lane(0,1);
-        phy0_start(0,1);
+        memset(str,sizeof(str),0x00);
+        sprintf(str,"hclk_mipiphy%d",i);
 
-        udelay(200);
-    //enable isp
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DISABLE_ISP_MASK | 0); 
-    }
+        clk = devm_clk_get(&pdev->dev, str);
+        if (!IS_ERR_OR_NULL(clk)) {
+            phyclk = kzalloc(sizeof(camsys_mipiphy_clk_t),GFP_KERNEL);
+            if (phyclk == NULL) {
+                camsys_err("malloc camsys_mipiphy_clk_t for %s failed!",str);
+            } else {
+                phyclk->hclk = clk;
+            }
 
-#endif   
-    return 0;
-}
+            camsys_dev->mipiphy[i].clk = (void*)phyclk;
+        }
 
-static int camsys_mipiphy_clkin_cb(void *ptr, unsigned int on)
-{
-    return 0;
-}
+        camsys_dev->mipiphy[i].phycnt = mipiphy_cnt;
+        camsys_dev->mipiphy[i].clkin_cb = camsys_mipiphy_clkin_cb;
+        camsys_dev->mipiphy[i].ops = camsys_mipiphy_ops;
+        camsys_dev->mipiphy[i].remove = camsys_mipiphy_remove_cb;
+
+        if (meminfo != NULL) {
+            camsys_trace(1,"%s mipi phy%d probe success(reg_phy: 0x%x  reg_vir: 0x%x  size: 0x%x)",
+                dev_name(&pdev->dev), i,meminfo->phy_base,meminfo->vir_base, meminfo->size);
+        } else {
+            camsys_trace(1,"%s mipi phy%d probe success(reg_phy: 0x%x  reg_vir: 0x%x  size: 0x%x)",
+                dev_name(&pdev->dev), i,0,0,0);
+        }
 
-static int camsys_mipiphy_remove_cb(struct platform_device *pdev)
-{
+    }   
+    
     return 0;
-}
-int camsys_mipiphy_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
-{
- 
-    camsys_dev->mipiphy.clkin_cb = camsys_mipiphy_clkin_cb;
-    camsys_dev->mipiphy.ops = camsys_mipiphy_ops;
-    camsys_dev->mipiphy.remove = camsys_mipiphy_remove_cb;
 
+fail:
 
-    return 0;
-  
+    return err;
 }
 
diff --git a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
index 4c0d64cb1bd7..68547717890d 100755
--- a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
+++ b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
@@ -3,25 +3,11 @@
 
 #include "camsys_internal.h"
 
-#if defined(CONFIG_ARCH_ROCKCHIP)
-
-#define write_grf_reg(addr, val)           __raw_writel(val, addr+RK_GRF_VIRT)
-#define read_grf_reg(addr)                 __raw_readl(addr+RK_GRF_VIRT)
-#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
-#else
-#define write_grf_reg(addr, val)  
-#define read_grf_reg(addr)                 0
-#define mask_grf_reg(addr, msk, val)	
-#endif
-
-
 typedef struct camsys_mipiphy_clk_s {
-    struct clk       *pd_mipi_csi;
-    struct clk       *pclk_mipiphy_csi;
-    bool             in_on;
-    spinlock_t       lock;
-} camsys_mipiphy_clk_t;
+    struct clk* hclk;
 
+    unsigned int on;
+} camsys_mipiphy_clk_t;
 
 int camsys_mipiphy_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev);
 
diff --git a/drivers/media/video/rk_camsys/camsys_soc_priv.c b/drivers/media/video/rk_camsys/camsys_soc_priv.c
new file mode 100755
index 000000000000..a77accf20f64
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_priv.c
@@ -0,0 +1,100 @@
+
+#include "camsys_soc_priv.h"
+
+
+
+static camsys_soc_priv_t* camsys_soc_p;
+
+#include "camsys_soc_rk3288.c"
+
+static int camsys_rk3288_cfg (camsys_soc_cfg_t cfg_cmd, void* cfg_para)
+{
+    unsigned int *para_int;
+    
+    switch (cfg_cmd)
+    {
+        case Clk_DriverStrength_Cfg:
+        {
+            para_int = (unsigned int*)cfg_para;
+            __raw_writel((((*para_int)&0x03)<<3)|(0x03<<3), RK_GRF_VIRT+0x01d4);
+            break;
+        }
+
+        case Cif_IoDomain_Cfg:
+        {
+            para_int = (unsigned int*)cfg_para;
+            if (*para_int < 28000000) {
+                __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);    // 1.8v IO
+            } else {
+                __raw_writel(((0<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);    // 3.3v IO
+            }
+            break;
+        }
+
+        case Mipi_Phy_Cfg:
+        {
+            camsys_rk3288_mipihpy_cfg((camsys_mipiphy_soc_para_t*)cfg_para);
+            break;
+        }
+
+        case Isp_SoftRst:
+        {
+
+            break;
+        }
+
+        default:
+        {
+            camsys_warn("cfg_cmd: 0x%x isn't support for %s",cfg_cmd,camsys_soc_p->name);
+            break;
+        }
+
+    }
+
+    return 0;
+
+
+}
+
+camsys_soc_priv_t* camsys_soc_get(void)
+{
+    if (camsys_soc_p != NULL) {
+        return camsys_soc_p;
+    } else {
+        return NULL;
+    }
+}
+
+int camsys_soc_init(void)
+{    
+    camsys_soc_p = kzalloc(sizeof(camsys_soc_priv_t),GFP_KERNEL);
+    if (camsys_soc_p == NULL) {
+        camsys_err("malloc camsys_soc_priv_t failed!");
+        goto fail;
+    }
+
+    if (soc_is_rk3288()) {
+        strlcpy(camsys_soc_p->name,"camsys_rk3288",31);
+        camsys_soc_p->soc_cfg = camsys_rk3288_cfg;
+    } else {
+        camsys_err("camsys isn't support soc: 0x%lx!",rockchip_soc_id);
+        goto fail;
+    }
+    
+    return 0;
+fail:
+    if (camsys_soc_p != NULL) {
+        kfree(camsys_soc_p);
+        camsys_soc_p = NULL;
+    }
+    return -1;
+}
+
+int camsys_soc_deinit(void)
+{
+    if (camsys_soc_p != NULL) {
+        kfree(camsys_soc_p);
+        camsys_soc_p = NULL;
+    }
+    return 0;
+}
diff --git a/drivers/media/video/rk_camsys/camsys_soc_priv.h b/drivers/media/video/rk_camsys/camsys_soc_priv.h
new file mode 100755
index 000000000000..6e58115a3512
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_priv.h
@@ -0,0 +1,30 @@
+#ifndef __RKCAMSYS_SOC_PRIV_H__
+#define __RKCAMSYS_SOC_PRIV_H__
+
+#include "camsys_internal.h"
+
+typedef struct camsys_mipiphy_soc_para_s {
+    camsys_dev_t        *camsys_dev;
+    camsys_mipiphy_t    *phy;
+} camsys_mipiphy_soc_para_t;
+
+
+typedef enum camsys_soc_cfg_e {
+    Clk_DriverStrength_Cfg = 0,
+    Cif_IoDomain_Cfg,
+    Mipi_Phy_Cfg,
+
+    Isp_SoftRst,
+} camsys_soc_cfg_t;
+
+typedef struct camsys_soc_priv_s {
+    char name[32];
+    int (*soc_cfg)(camsys_soc_cfg_t cfg_cmd, void* cfg_para);
+    
+} camsys_soc_priv_t;
+
+extern camsys_soc_priv_t* camsys_soc_get(void);
+extern int camsys_soc_init(void);
+extern int camsys_soc_deinit(void);
+#endif
+
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3288.c b/drivers/media/video/rk_camsys/camsys_soc_rk3288.c
new file mode 100755
index 000000000000..41048d950a8e
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3288.c
@@ -0,0 +1,227 @@
+#include "camsys_soc_priv.h"
+#include "camsys_soc_rk3288.h"
+
+
+struct mipiphy_hsfreqrange_s {
+    unsigned int range_l;
+    unsigned int range_h;
+    unsigned char cfg_bit;
+};
+
+static struct mipiphy_hsfreqrange_s mipiphy_hsfreqrange[] = {
+    {80,90,0x00},
+    {90,100,0x10},
+    {100,110,0x20},
+    {110,130,0x01},
+    {130,140,0x11},
+    {140,150,0x21},
+    {150,170,0x02},
+    {170,180,0x12},
+    {180,200,0x22},
+    {200,220,0x03},
+    {220,240,0x13},
+    {240,250,0x23},
+    {250,270,0x4},
+    {270,300,0x14},
+    {300,330,0x5},
+    {330,360,0x15},
+    {360,400,0x25},
+    {400,450,0x06},
+    {450,500,0x16},
+    {500,550,0x07},
+    {550,600,0x17},
+    {600,650,0x08},
+    {650,700,0x18},
+    {700,750,0x09},
+    {750,800,0x19},
+    {800,850,0x29},
+    {850,900,0x39},
+    {900,950,0x0a},
+    {950,1000,0x1a}
+    
+};
+
+
+static int camsys_rk3288_mipiphy0_wr_reg(unsigned char addr, unsigned char data)
+{
+    //TESTCLK=1
+    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);
+    //TESTEN =1,TESTDIN=addr
+    write_grf_reg(GRF_SOC_CON14_OFFSET,(( addr << DPHY_RX0_TESTDIN_OFFSET) |DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN| DPHY_RX0_TESTEN_MASK)); 
+    //TESTCLK=0
+	write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK); 
+  
+    if(data != 0xff){ //write data ?
+    	//TESTEN =0,TESTDIN=data
+        write_grf_reg(GRF_SOC_CON14_OFFSET, (( data << DPHY_RX0_TESTDIN_OFFSET)|DPHY_RX0_TESTDIN_MASK |DPHY_RX0_TESTEN_MASK)); 
+
+        //TESTCLK=1
+        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); 
+    }
+    return 0;
+}
+
+static int camsys_rk3288_mipiphy0_rd_reg(unsigned char addr)
+{
+    return read_grf_reg(GRF_SOC_STATUS21);
+}
+
+static int camsys_rk3288_mipiphy1_wr_reg(unsigned int phy_virt,unsigned char addr, unsigned char data)
+{
+    
+    write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,(0x00010000|addr));    //TESTEN =1,TESTDIN=addr
+    write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000000);         //TESTCLK=0
+    write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,(0x00000000|data));    //TESTEN =0,TESTDIN=data
+    write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);         //TESTCLK=1 
+
+    return 0;
+}
+
+static int camsys_rk3288_mipiphy1_rd_reg(unsigned int phy_virt,unsigned char addr)
+{
+    return (read_csihost_reg(((CSIHOST_PHY_TEST_CTRL1)&0xff00))>>8);
+}
+
+static int camsys_rk3288_mipihpy_cfg (camsys_mipiphy_soc_para_t *para)
+{    
+    unsigned char hsfreqrange=0xff,i;
+    struct mipiphy_hsfreqrange_s *hsfreqrange_p;
+    unsigned int phy_virt, phy_index;
+    unsigned int *base;
+
+    phy_index = para->phy->phy_index;
+    if (para->camsys_dev->mipiphy[phy_index].reg!=NULL) {
+        phy_virt  = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
+    } else {
+        phy_virt = 0x00;
+    }
+    
+    if ((para->phy->bit_rate == 0) || (para->phy->data_en_bit == 0)) {
+        if (para->phy->phy_index == 0) {
+            base = (unsigned int *)para->camsys_dev->devmems.registermem->vir_base;
+            *(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL)/4) &= ~(0x0f<<8);
+            camsys_trace(1, "mipi phy 0 standby!");
+        } else if (para->phy->phy_index == 1) {
+            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000000);           //SHUTDOWNZ=0
+            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000000);               //RSTZ=0
+
+            camsys_trace(1, "mipi phy 1 standby!");
+        }
+
+        return 0;
+    }
+    
+    
+    hsfreqrange_p = mipiphy_hsfreqrange;
+    for (i=0; i<(sizeof(mipiphy_hsfreqrange)/sizeof(struct mipiphy_hsfreqrange_s)); i++) {
+
+        if ((para->phy->bit_rate > hsfreqrange_p->range_l) && (para->phy->bit_rate <= hsfreqrange_p->range_h)) {
+            hsfreqrange = hsfreqrange_p->cfg_bit;
+            break;
+        }
+        hsfreqrange_p++;
+    }
+
+    if (hsfreqrange == 0xff) {
+        camsys_err("mipi phy config bitrate %d Mbps isn't supported!",para->phy->bit_rate);
+        hsfreqrange = 0x00;
+    }
+    hsfreqrange <<= 1;
+    
+    if (para->phy->phy_index == 0) {
+        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DPHYSEL_OFFSET_MASK | (para->phy->phy_index<<MIPI_PHY_DPHYSEL_OFFSET_BIT)); 
+
+        //  set lane num
+        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_ENABLE_MASK | (para->phy->data_en_bit << DPHY_RX0_ENABLE_OFFSET_BITS)); 
+        //  set lan turndisab as 1
+        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_TURN_DISABLE_MASK | (0xf << DPHY_RX0_TURN_DISABLE_OFFSET_BITS));
+        write_grf_reg(GRF_SOC_CON10_OFFSET, (0x0<<4)|(0xf<<20));
+        //  set lan turnrequest as 0   
+        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_RX0_TURN_REQUEST_MASK | (0x0 << DPHY_RX0_TURN_REQUEST_OFFSET_BITS));
+
+        //phy start
+        {
+            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); //TESTCLK=1              
+            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK |DPHY_RX0_TESTCLR);   //TESTCLR=1
+            udelay(100);
+            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK); //TESTCLR=0  zyc
+            udelay(100);
+
+            //set clock lane
+            camsys_rk3288_mipiphy0_wr_reg(0x34,0x15);
+            if (para->phy->data_en_bit >= 0x00)  
+                camsys_rk3288_mipiphy0_wr_reg(0x44,hsfreqrange);         
+            if (para->phy->data_en_bit >= 0x01) 
+                camsys_rk3288_mipiphy0_wr_reg(0x54,hsfreqrange);
+            if (para->phy->data_en_bit >= 0x04) { 
+                camsys_rk3288_mipiphy0_wr_reg(0x84,hsfreqrange);
+                camsys_rk3288_mipiphy0_wr_reg(0x94,hsfreqrange);
+            }
+
+            //Normal operation
+            camsys_rk3288_mipiphy0_wr_reg(0x0,-1);        
+            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);    //TESTCLK=1     
+            write_grf_reg(GRF_SOC_CON14_OFFSET, (DPHY_RX0_TESTEN_MASK));                     //TESTEN =0 
+        }
+
+        base = (unsigned int *)para->camsys_dev->devmems.registermem->vir_base;
+        *(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL)/4) |= (0x0f<<8);
+        
+    } else if (para->phy->phy_index == 1){
+        
+        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DPHYSEL_OFFSET_MASK | (para->phy->phy_index<<MIPI_PHY_DPHYSEL_OFFSET_BIT));         
+        write_grf_reg(GRF_SOC_CON6_OFFSET, DSI_CSI_TESTBUS_SEL_MASK | (1<<DSI_CSI_TESTBUS_SEL_OFFSET_BIT)); 
+
+        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX1_SRC_SEL_ISP | DPHY_RX1_SRC_SEL_MASK); 
+        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_SLAVEZ | DPHY_TX1RX1_MASTERSLAVEZ_MASK); 
+        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_BASEDIR_REC | DPHY_TX1RX1_BASEDIR_OFFSET); 
+
+        //  set lane num
+        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_ENABLE_MASK | (para->phy->data_en_bit << DPHY_TX1RX1_ENABLE_OFFSET_BITS)); 
+        //  set lan turndisab as 1
+        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_TURN_DISABLE_MASK | (0xf << DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS));
+        //  set lan turnrequest as 0   
+        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_TX1RX1_TURN_REQUEST_MASK | (0x0 << DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS));
+
+        //phy1 start
+        {
+            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000000);           //SHUTDOWNZ=0
+            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000000);               //RSTZ=0
+            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);          //TESTCLK=1
+            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000003);          //TESTCLR=1 TESTCLK=1  
+            udelay(100);
+            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);          //TESTCLR=0 TESTCLK=1
+            udelay(100);
+   
+            //set clock lane
+            camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x34,0x15);
+            if (para->phy->data_en_bit >= 0x00)  
+                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x44,hsfreqrange);         
+            if (para->phy->data_en_bit >= 0x01) 
+                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x54,hsfreqrange);
+            if (para->phy->data_en_bit >= 0x04) { 
+                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x84,hsfreqrange);
+                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x94,hsfreqrange);
+            }
+
+            camsys_rk3288_mipiphy1_rd_reg(phy_virt,0x0);
+            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);       //TESTCLK=1
+            write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,0x00000000);       //TESTEN =0
+            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000001);        //SHUTDOWNZ=1
+            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000001);            //RSTZ=1
+        }
+    } else {
+        camsys_err("mipi phy index %d is invalidate!",para->phy->phy_index);
+        goto fail;
+    }
+
+    camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",para->phy->phy_index,para->phy->data_en_bit, para->phy->bit_rate);
+
+
+    return 0;
+
+fail:
+    return -1;
+}
+
+
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3288.h b/drivers/media/video/rk_camsys/camsys_soc_rk3288.h
new file mode 100755
index 000000000000..8a5764b659b1
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3288.h
@@ -0,0 +1,103 @@
+#ifndef __RKCAMSYS_SOC_RK3288_H__
+#define __RKCAMSYS_SOC_RK3288_H__
+
+#include "camsys_internal.h"
+
+//MARVIN REGISTER
+#define MRV_MIPI_BASE                           0x1C00
+#define MRV_MIPI_CTRL                           0x00
+
+//GRF_SOC_CON14
+//bit 0     dphy_rx0_testclr
+//bit 1     dphy_rx0_testclk
+//bit 2     dphy_rx0_testen
+//bit 3:10 dphy_rx0_testdin
+#define GRF_SOC_CON14_OFFSET    (0x027c)
+#define DPHY_RX0_TESTCLR_MASK   (0x1<<16)
+#define DPHY_RX0_TESTCLK_MASK   (0x1<<17)
+#define DPHY_RX0_TESTEN_MASK    (0x1<<18)
+#define DPHY_RX0_TESTDIN_MASK   (0xff<<19)
+
+#define DPHY_RX0_TESTCLR    (1<<0)
+#define DPHY_RX0_TESTCLK    (1<<1)
+#define DPHY_RX0_TESTEN     (1<<2)
+#define DPHY_RX0_TESTDIN_OFFSET    (3)
+
+#define DPHY_TX1RX1_ENABLECLK_MASK   (0x1<<28)
+#define DPHY_RX1_SRC_SEL_MASK        (0x1<<29)
+#define DPHY_TX1RX1_MASTERSLAVEZ_MASK (0x1<<30)
+#define DPHY_TX1RX1_BASEDIR_OFFSET  (0x1<<31)
+
+#define DPHY_TX1RX1_ENABLECLK           (0x1<<12)
+#define DPHY_TX1RX1_DISABLECLK          (0x0<<12)
+#define DPHY_RX1_SRC_SEL_ISP          (0x1<<13)
+#define DPHY_TX1RX1_SLAVEZ            (0x0<<14)
+#define DPHY_TX1RX1_BASEDIR_REC       (0x1<<15)
+
+
+
+//GRF_SOC_CON6
+//bit 0 grf_con_disable_isp
+//bit 1 grf_con_isp_dphy_sel  1'b0 mipi phy rx0
+#define GRF_SOC_CON6_OFFSET    (0x025c)
+#define MIPI_PHY_DISABLE_ISP_MASK       (0x1<<16)
+#define MIPI_PHY_DISABLE_ISP            (0x0<<0)
+
+#define DSI_CSI_TESTBUS_SEL_MASK        (0x1<<30)
+#define DSI_CSI_TESTBUS_SEL_OFFSET_BIT  (14)
+
+
+#define MIPI_PHY_DPHYSEL_OFFSET_MASK (0x1<<17)
+#define MIPI_PHY_DPHYSEL_OFFSET_BIT (0x1)
+
+//GRF_SOC_CON10
+//bit12:15 grf_dphy_rx0_enable
+//bit 0:3 turn disable
+#define GRF_SOC_CON10_OFFSET                (0x026c)
+#define DPHY_RX0_TURN_DISABLE_MASK          (0xf<<16)
+#define DPHY_RX0_TURN_DISABLE_OFFSET_BITS   (0x0)
+#define DPHY_RX0_ENABLE_MASK                (0xf<<28)
+#define DPHY_RX0_ENABLE_OFFSET_BITS         (12)
+
+//GRF_SOC_CON9
+//bit12:15 grf_dphy_rx0_enable
+//bit 0:3 turn disable
+#define GRF_SOC_CON9_OFFSET                (0x0268)
+#define DPHY_TX1RX1_TURN_DISABLE_MASK          (0xf<<16)
+#define DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS   (0x0)
+#define DPHY_TX1RX1_ENABLE_MASK                (0xf<<28)
+#define DPHY_TX1RX1_ENABLE_OFFSET_BITS         (12)
+
+//GRF_SOC_CON15
+//bit 0:3   turn request
+#define GRF_SOC_CON15_OFFSET                (0x03a4) 
+#define DPHY_RX0_TURN_REQUEST_MASK          (0xf<<16)
+#define DPHY_RX0_TURN_REQUEST_OFFSET_BITS   (0x0)
+
+#define DPHY_TX1RX1_TURN_REQUEST_MASK          (0xf<<20)
+#define DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS   (0x0)
+
+//
+#define GRF_SOC_STATUS21                  (0x2D4)
+
+#define CSIHOST_PHY_TEST_CTRL0            (0x30)
+#define CSIHOST_PHY_TEST_CTRL1            (0x34)
+#define CSIHOST_PHY_SHUTDOWNZ             (0x08)
+#define CSIHOST_DPHY_RSTZ                 (0x0c)
+#define CSIHOST_N_LANES                   (0x04)
+#define CSIHOST_CSI2_RESETN               (0x10)
+#define CSIHOST_PHY_STATE                 (0x14)
+#define CSIHOST_DATA_IDS1                 (0x18)
+#define CSIHOST_DATA_IDS2                 (0x1C)
+#define CSIHOST_ERR1                      (0x20)
+#define CSIHOST_ERR2                      (0x24)
+
+
+#define write_grf_reg(addr, val)           __raw_writel(val, addr+RK_GRF_VIRT)
+#define read_grf_reg(addr)                 __raw_readl(addr+RK_GRF_VIRT)
+#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
+
+#define write_csihost_reg(addr, val)       __raw_writel(val, addr+IOMEM(phy_virt))
+#define read_csihost_reg(addr)             __raw_readl(addr+IOMEM(phy_virt))
+
+#endif
diff --git a/drivers/pinctrl/pinctrl-rockchip.c b/drivers/pinctrl/pinctrl-rockchip.c
index 904d046631ef..2c32fb8e4c99 100755
--- a/drivers/pinctrl/pinctrl-rockchip.c
+++ b/drivers/pinctrl/pinctrl-rockchip.c
@@ -3030,8 +3030,8 @@ static int rockchip_pinctrl_probe(struct platform_device *pdev)
 	*atomic_set(&info->bank_debug_flag, 1);
 	*atomic_set(&info->pin_debug_flag, 11);
 	*/
-	atomic_set(&info->bank_debug_flag, 0);
-	atomic_set(&info->pin_debug_flag, 0);
+	atomic_set(&info->bank_debug_flag, 8);
+	atomic_set(&info->pin_debug_flag, 14);
 	
 	printk("%s:name=%s,type=%d\n",__func__, ctrl->label, (int)ctrl->type);
 
diff --git a/include/media/camsys_head.h b/include/media/camsys_head.h
index 44974b1dfc25..891b1d3e0f00 100755
--- a/include/media/camsys_head.h
+++ b/include/media/camsys_head.h
@@ -15,9 +15,12 @@
 *v0.0.4:
 *        1) add clock information in struct camsys_devio_name_s;
 *v0.0.5:
-		 1) add pwren control
+*        1) add pwren control
+*v0.6.0:
+*        1) add support mipi phy configuration;
+*        2) add support io domain and mclk driver strength configuration;
 */
-#define CAMSYS_HEAD_VERSION           KERNEL_VERSION(0,0,5)
+#define CAMSYS_HEAD_VERSION           KERNEL_VERSION(0,6,0)
 
 #define CAMSYS_MARVIN_DEVNAME         "camsys_marvin"           
 #define CAMSYS_CIF0_DEVNAME           "camsys_cif0"
@@ -36,9 +39,9 @@
 #define CAMSYS_DEVID_EXTERNAL         0xFF000000
 #define CAMSYS_DEVID_EXTERNAL_NUM     8
 
-#define CAMSYS_DEVCFG_FLASHLIGHT      0x00000001
-#define CAMSYS_DEVCFG_PREFLASHLIGHT   0x00000002
-#define CAMSYS_DEVCFG_SHUTTER         0x00000004
+#define CAMSYS_DEVCFG_FLASHLIGHT          0x00000001
+#define CAMSYS_DEVCFG_PREFLASHLIGHT       0x00000002
+#define CAMSYS_DEVCFG_SHUTTER             0x00000004
 
 typedef struct camsys_irqsta_s {
     unsigned int ris;                 //Raw interrupt status
@@ -86,22 +89,30 @@ typedef struct camsys_reginfo_s {
 } camsys_reginfo_t;
 
 typedef enum camsys_sysctrl_ops_e {
-    CamSys_Avdd =0,
+
+    CamSys_Vdd_Start_Tag,
+    CamSys_Avdd,
     CamSys_Dovdd,
     CamSys_Dvdd,
     CamSys_Afvdd,
+    CamSys_Vdd_End_Tag,
 
-    CamSys_Vdd_Tag = 10,
-    
+    CamSys_Gpio_Start_Tag,    
     CamSys_PwrDn,
     CamSys_Rst,
     CamSys_AfPwr,
     CamSys_AfPwrDn,
-    CamSys_PwrEn,
-    
-    CamSys_Gpio_Tag = 50,
+    CamSys_PwrEn,    
+    CamSys_Gpio_End_Tag,
+
+    CamSys_Clk_Start_Tag,    
+    CamSys_ClkIn,
+    CamSys_Clk_End_Tag,
 
-    CamSys_ClkIn   
+    CamSys_Phy_Start_Tag,    
+    CamSys_Phy,
+    CamSys_Phy_End_Tag
+    
 } camsys_sysctrl_ops_t;
 
 typedef struct camsys_regulator_info_s {
@@ -119,6 +130,8 @@ typedef struct camsys_sysctrl_s {
     unsigned int              dev_mask;
     camsys_sysctrl_ops_t      ops;
     unsigned int              on;
+
+    unsigned int              rev[20];
 } camsys_sysctrl_t;
 
 typedef struct camsys_flash_info_s {
@@ -126,11 +139,9 @@ typedef struct camsys_flash_info_s {
 } camsys_flash_info_t;
 
 typedef struct camsys_mipiphy_s {
-    unsigned int                data_en_bit;        //data lane enable bit;
-    #if 0
-    unsigned int                freq;
-    unsigned int                phy_index;          //phy0,phy1
-    #endif
+    unsigned int                data_en_bit;        // data lane enable bit;
+    unsigned int                bit_rate;           // Mbps/lane
+    unsigned int                phy_index;          // phy0,phy1
 } camsys_mipiphy_t;
 
 typedef enum camsys_fmt_e {
@@ -149,9 +160,16 @@ typedef enum camsys_fmt_e {
     CamSys_Fmt_Raw_14b = 0x2d,
 } camsys_fmt_t;
 
+typedef enum camsys_cifio_e {
+    CamSys_SensorBit0_CifBit0 = 0x00,
+    CamSys_SensorBit0_CifBit2 = 0x01,
+} camsys_cifio_t;
+
 typedef struct camsys_cifphy_s {
     unsigned int                cif_num; 
     camsys_fmt_t                fmt;
+    camsys_cifio_t              cifio;
+    
 } camsys_cifphy_t;
 
 typedef enum camsys_phy_type_e {
@@ -172,6 +190,7 @@ typedef struct camsys_extdev_phy_s {
 
 typedef struct camsys_extdev_clk_s {
     unsigned int in_rate;
+    unsigned int driver_strength;             //0 - 3
 } camsys_extdev_clk_t;
 
 typedef struct camsys_devio_name_s {
@@ -186,7 +205,7 @@ typedef struct camsys_devio_name_s {
     camsys_gpio_info_t          rst;          // hard reset gpio name 
     camsys_gpio_info_t          afpwr;        // auto focus vcm driver ic power gpio name
     camsys_gpio_info_t          afpwrdn;      // auto focus vcm driver ic standby gpio 
-    camsys_gpio_info_t          pwren;          // power enable gpio name  
+    camsys_gpio_info_t          pwren;        // power enable gpio name  
 
 
     camsys_flash_info_t         fl;
@@ -207,7 +226,7 @@ typedef struct camsys_version_s {
  *
  */
 #define CAMSYS_IOC_MAGIC  'M'
-#define CAMSYS_IOC_MAXNR  12
+#define CAMSYS_IOC_MAXNR  14
 
 #define CAMSYS_VERCHK            _IOR(CAMSYS_IOC_MAGIC,  0, camsys_version_t)
 
-- 
2.35.3

