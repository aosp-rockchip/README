From f5796180ff26e167ea8f395b2f4fbf3253e1b9aa Mon Sep 17 00:00:00 2001
From: yxj <yxj@rock-chips.com>
Date: Thu, 19 Jul 2012 12:26:52 +0800
Subject: [PATCH] rk31:add lcdc support

---
 arch/arm/configs/rk31_fpga_defconfig     |  10 +
 arch/arm/mach-rk30/board-rk31-fpga.c     | 109 +++
 arch/arm/mach-rk30/devices.c             |   8 +-
 drivers/video/rockchip/Kconfig           |  28 +-
 drivers/video/rockchip/Makefile          |   3 +-
 drivers/video/rockchip/chips/rk31_lcdc.c | 969 +++++++++++++++++++++++
 drivers/video/rockchip/chips/rk31_lcdc.h | 543 +++++++++++++
 7 files changed, 1662 insertions(+), 8 deletions(-)
 create mode 100644 drivers/video/rockchip/chips/rk31_lcdc.c
 create mode 100644 drivers/video/rockchip/chips/rk31_lcdc.h

diff --git a/arch/arm/configs/rk31_fpga_defconfig b/arch/arm/configs/rk31_fpga_defconfig
index c58c4ba18355..7b739e2bbff1 100644
--- a/arch/arm/configs/rk31_fpga_defconfig
+++ b/arch/arm/configs/rk31_fpga_defconfig
@@ -75,6 +75,16 @@ CONFIG_SPI_FPGA_GPIO_NUM=0
 CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
 # CONFIG_HWMON is not set
 # CONFIG_MFD_SUPPORT is not set
+CONFIG_FB=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_LCD_TD043MGEA1=y
+CONFIG_FB_ROCKCHIP=y
+CONFIG_LCDC_RK31=y
+CONFIG_LCDC1_RK31=y
+# CONFIG_THREE_FB_BUFFER is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_HID_SUPPORT is not set
 # CONFIG_USB_SUPPORT is not set
 CONFIG_RTC_CLASS=y
diff --git a/arch/arm/mach-rk30/board-rk31-fpga.c b/arch/arm/mach-rk30/board-rk31-fpga.c
index 4495e7ca3cd9..309d3eb274ee 100644
--- a/arch/arm/mach-rk30/board-rk31-fpga.c
+++ b/arch/arm/mach-rk30/board-rk31-fpga.c
@@ -43,6 +43,108 @@
 #include <linux/rfkill-rk.h>
 #include <linux/sensor-dev.h>
 
+
+#define RK_FB_MEM_SIZE 3*SZ_1M
+
+#if defined(CONFIG_FB_ROCKCHIP)
+#define LCD_CS_MUX_NAME    GPIO4C7_SMCDATA7_TRACEDATA7_NAME
+#define LCD_CS_PIN         RK30_PIN4_PC7
+#define LCD_CS_VALUE       GPIO_HIGH
+
+#define LCD_EN_MUX_NAME    GPIO4C7_SMCDATA7_TRACEDATA7_NAME
+#define LCD_EN_PIN         RK30_PIN6_PB4
+#define LCD_EN_VALUE       GPIO_LOW
+
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+	int ret = 0;
+	rk30_mux_api_set(LCD_CS_MUX_NAME, GPIO4C_GPIO4C7);
+	ret = gpio_request(LCD_CS_PIN, NULL);
+	if (ret != 0)
+	{
+		gpio_free(LCD_CS_PIN);
+		printk(KERN_ERR "request lcd cs pin fail!\n");
+		return -1;
+	}
+	else
+	{
+		gpio_direction_output(LCD_CS_PIN, LCD_CS_VALUE);
+	}
+	ret = gpio_request(LCD_EN_PIN, NULL);
+	if (ret != 0)
+	{
+		gpio_free(LCD_EN_PIN);
+		printk(KERN_ERR "request lcd en pin fail!\n");
+		return -1;
+	}
+	else
+	{
+		gpio_direction_output(LCD_EN_PIN, LCD_EN_VALUE);
+	}
+	return 0;
+}
+static int rk_fb_io_disable(void)
+{
+	gpio_set_value(LCD_CS_PIN, LCD_CS_VALUE? 0:1);
+	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE? 0:1);
+	return 0;
+}
+static int rk_fb_io_enable(void)
+{
+	gpio_set_value(LCD_CS_PIN, LCD_CS_VALUE);
+	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+	return 0;
+}
+
+#if defined(CONFIG_LCDC0_RK31)
+struct rk29fb_info lcdc0_screen_info = {
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+};
+#endif
+
+#if defined(CONFIG_LCDC1_RK31)
+struct rk29fb_info lcdc1_screen_info = {
+	#if defined(CONFIG_HDMI_RK30)
+	.prop		= EXTEND,	//extend display device
+	.lcd_info  = NULL,
+	.set_screen_info = hdmi_init_lcdc,
+	#endif
+};
+#endif
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+};
+#endif
+
 //i2c
 #ifdef CONFIG_I2C0_RK30
 static struct i2c_board_info __initdata i2c0_info[] = {
@@ -90,6 +192,9 @@ static struct spi_board_info board_spi_devices[] = {
 };
 
 static struct platform_device *devices[] __initdata = {
+#if defined(CONFIG_FB_ROCKCHIP)
+	&device_fb,
+#endif
 };
 
 static void __init rk31_board_init(void)
@@ -101,6 +206,10 @@ static void __init rk31_board_init(void)
 
 static void __init rk31_reserve(void)
 {
+#if defined(CONFIG_FB_ROCKCHIP)
+	resource_fb[0].start = board_mem_reserve_add("fb0", RK_FB_MEM_SIZE);
+	resource_fb[0].end = resource_fb[0].start + RK_FB_MEM_SIZE - 1;
+#endif
 	board_mem_reserved();
 }
 
diff --git a/arch/arm/mach-rk30/devices.c b/arch/arm/mach-rk30/devices.c
index 6330b292ce1f..07c6e675ea54 100755
--- a/arch/arm/mach-rk30/devices.c
+++ b/arch/arm/mach-rk30/devices.c
@@ -749,7 +749,7 @@ static struct platform_device device_nand = {
 };
 #endif
 
-#ifdef CONFIG_LCDC0_RK30
+#if defined(CONFIG_LCDC0_RK30) || defined(CONFIG_LCDC0_RK31)
 extern struct rk29fb_info lcdc0_screen_info;
 static struct resource resource_lcdc0[] = {
 	[0] = {
@@ -777,7 +777,7 @@ static struct platform_device device_lcdc0 = {
 	},
 };
 #endif
-#ifdef CONFIG_LCDC1_RK30
+#if defined(CONFIG_LCDC1_RK30) || defined(CONFIG_LCDC1_RK31)
 extern struct rk29fb_info lcdc1_screen_info;
 static struct resource resource_lcdc1[] = {
 	[0] = {
@@ -1151,10 +1151,10 @@ static int __init rk30_init_devices(void)
 	platform_device_register(&device_rga);
 #endif
 	platform_device_register(&device_ipp);
-#ifdef CONFIG_LCDC0_RK30
+#if 	defined(CONFIG_LCDC0_RK30) || defined(CONFIG_LCDC0_RK31)
 	platform_device_register(&device_lcdc0);
 #endif
-#ifdef CONFIG_LCDC1_RK30
+#if     defined(CONFIG_LCDC1_RK30) || defined(CONFIG_LCDC1_RK31)
 	platform_device_register(&device_lcdc1);
 #endif
 #ifdef CONFIG_HDMI_RK30
diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index c6b81ec773f4..04ba7263c5ac 100755
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -14,6 +14,12 @@ config FB_WIMO
 	help
 	    Support wimo
 
+config LCDC_RK2928
+        tristate "rk2928 lcdc support "
+        depends on FB_ROCKCHIP
+        help
+          Driver for rk2928 lcdc .
+
 config LCDC_RK30
         tristate "rk30 lcdc support "
         depends on FB_ROCKCHIP
@@ -33,11 +39,27 @@ config LCDC1_RK30
         default y if HDMI_RK30
         help
            Support rk30 lcdc1 if you say y here
-config LCDC_RK2928
-	tristate "rk2928 lcdc support "
+
+config LCDC_RK31
+	tristate "rk31 lcdc support "
         depends on FB_ROCKCHIP
         help
-          Driver for rk2928 lcdc .
+          Driver for rk31 lcdc .There are two lcdc controllers on RK31
+
+config LCDC0_RK31
+        bool "lcdc0 support"
+        depends on LCDC_RK31
+        default y
+        help
+           Support rk31 lcdc0 if you say y here
+
+config LCDC1_RK31
+        bool "lcdc1 support"
+        depends on LCDC_RK31
+        default y if HDMI_RK31
+        help
+           Support rk31 lcdc1 if you say y here
+
 config DUAL_DISP_IN_KERNEL
 	bool "implement dual display in kernel"
 	depends on FB_ROCKCHIP
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index d5a4aed8c623..ed778bb77b99 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -1,6 +1,7 @@
 obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o
 obj-$(CONFIG_FB_WIMO) +=wimo.o
 obj-$(CONFIG_LCDC_RK30) += chips/rk30_lcdc.o 
-obj-$(CONFIG_LCDC_RK2928) += chips/rk2928_lcdc.o 
+obj-$(CONFIG_LCDC_RK2928) += chips/rk2928_lcdc.o
+obj-$(CONFIG_LCDC_RK31) += chips/rk31_lcdc.o 
 obj-$(CONFIG_RGA_RK30) += rga/
 obj-$(CONFIG_HDMI_RK30) += hdmi/
diff --git a/drivers/video/rockchip/chips/rk31_lcdc.c b/drivers/video/rockchip/chips/rk31_lcdc.c
new file mode 100644
index 000000000000..be14760bb886
--- /dev/null
+++ b/drivers/video/rockchip/chips/rk31_lcdc.c
@@ -0,0 +1,969 @@
+/*
+ * drivers/video/rockchip/chips/rk31_lcdc.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *Author:yzq<yzq@rock-chips.com>
+ *	yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include "rk31_lcdc.h"
+
+
+
+
+
+
+static int dbg_thresd = 0;
+module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+#define DBG(level,x...) do { if(unlikely(dbg_thresd > level)) printk(KERN_INFO x); } while (0)
+
+
+static int init_rk31_lcdc(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	if(lcdc_dev->id == 0) //lcdc0
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
+	}
+	else if(lcdc_dev->id == 1)
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
+	}
+	else
+	{
+		printk(KERN_ERR "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
+    	{
+       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
+   	}
+	clk_enable(lcdc_dev->pd);
+	clk_enable(lcdc_dev->hclk);  //enable aclk and hclk for register config
+	clk_enable(lcdc_dev->aclk);  
+	lcdc_dev->clk_on = 1;
+	
+	LcdMskReg(lcdc_dev,SYS_CFG, m_LCDC_AXICLK_AUTO_ENABLE | m_W0_AXI_OUTSTANDING2 |
+		m_W1_AXI_OUTSTANDING2,v_LCDC_AXICLK_AUTO_ENABLE(1) | v_W0_AXI_OUTSTANDING2(1) |
+		v_W1_AXI_OUTSTANDING2(1));//eanble axi-clk auto gating for low power
+	LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
+    	      m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
+    	      v_SCANNING_MASK(1));  //mask all interrupt in init
+	LcdMskReg(lcdc_dev,FIFO_WATER_MARK,m_WIN1_FIFO_FULL_LEVEL,v_WIN1_FIFO_FULL_LEVEL(0x1e0));
+	LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+	return 0;
+}
+
+static int rk31_lcdc_deinit(struct rk31_lcdc_device *lcdc_dev)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+		LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
+    	      		  m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
+    	                  v_SCANNING_MASK(1));  //mask all interrupt in init
+		LcdSetBit(lcdc_dev,SYS_CFG,m_LCDC_STANDBY);
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	mdelay(1);
+	
+	return 0;
+}
+
+static int rk31_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	rk_screen *screen = lcdc_dev->screen;
+	u64 ft;
+	int fps;
+	u16 face;
+	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
+	u16 right_margin = screen->right_margin;
+	u16 lower_margin = screen->lower_margin;
+	u16 x_res = screen->x_res, y_res = screen->y_res;
+
+	// set the rgb or mcu
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(screen->type==SCREEN_MCU)
+		{
+	    		LcdMskReg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
+			// set out format and mcu timing
+	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
+	    		if(mcu_total>31)    
+				mcu_total = 31;
+	   		if(mcu_total<3)    
+				mcu_total = 3;
+	    		mcu_rwstart = (mcu_total+1)/4 - 1;
+	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
+	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
+	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
+
+	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
+	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
+
+			// set horizontal & vertical out timing
+		
+		    	right_margin = x_res/6; 
+			screen->pixclock = 150000000; //mcu fix to 150 MHz
+			LcdMskReg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
+	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
+	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
+	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
+	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
+	
+		}
+
+		switch (screen->face)
+		{
+	        	case OUT_P565:
+	            		face = OUT_P565;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_P666:
+	            		face = OUT_P666;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_D888_P565:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_D888_P666:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_P888:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	default:
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		face = screen->face;
+	            		break;
+		}
+
+		//use default overlay,set vsyn hsync den dclk polarity
+		LcdMskReg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
+	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
+	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
+	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
+
+		//set background color to black,set swap according to the screen panel,disable blank mode
+		LcdMskReg(lcdc_dev, DSP_CTRL1, m_BG_COLOR | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | 
+		 	m_DUMMY_SWAP | m_BLANK_MODE,v_BG_COLOR(0x000000) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
+		 	v_OUTPUT_RG_SWAP(screen->swap_rg) | v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy) |
+		 	v_BLACK_MODE(0));
+
+		
+		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
+	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
+		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
+	             v_HASP(screen->hsync_len + screen->left_margin));
+
+		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
+	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
+		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
+	              v_VASP(screen->vsync_len + screen->upper_margin));
+		// let above to take effect
+		LCDC_REG_CFG_DONE();
+	}
+ 	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
+	if(ret)
+	{
+        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+	}
+    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	clk_enable(lcdc_dev->dclk);
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+		(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps;
+    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
+
+    	if(screen->init)
+    	{
+    		screen->init();
+    	}
+	
+	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	return 0;
+}
+
+static int mcu_refresh(struct rk31_lcdc_device *lcdc_dev)
+{
+   
+    return 0;
+}
+
+
+
+//enable layer,open:1,enable;0 disable
+static int win0_open(struct rk31_lcdc_device *lcdc_dev,bool open)
+{
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[0]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_EN, v_W0_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		LCDC_REG_CFG_DONE();	
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+static int win1_open(struct rk31_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
+				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W1_EN, v_W1_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
+			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+
+
+static int rk31_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
+{
+	struct rk31_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk31_lcdc_device ,driver);
+
+	printk(KERN_INFO "%s>>>>>%d\n",__func__, blank_mode);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch(blank_mode)
+	    	{
+	    		case FB_BLANK_UNBLANK:
+	      			LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
+				break;
+	    		case FB_BLANK_NORMAL:
+	         		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+	    		default:
+				LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+    	return 0;
+}
+
+static  int win0_display(struct rk31_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_YRGB_MST,y_addr);
+	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST,uv_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+	
+}
+
+static  int win1_display(struct rk31_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN1_YRGB_MST, y_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win0_set_par(struct rk31_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+
+	xact = par->xact;			    //active (origin) picture window width/height		
+	yact = par->yact;
+	xvir = par->xvir;			   // virtual resolution		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+   
+	
+	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	switch (par->format)
+	{
+		case YUV422:// yuv422
+			ScaleCbrX = CalScale((xact/2), par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		case YUV420: // yuv420
+			ScaleCbrX = CalScale(xact/2, par->xsize);
+		   	ScaleCbrY = CalScale(yact/2, par->ysize);
+		   	break;
+		case YUV444:// yuv444
+			ScaleCbrX = CalScale(xact, par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		default:
+		   break;
+	}
+
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
+		LcdMskReg(lcdc_dev,SYS_CFG, m_W0_FORMAT, v_W0_FORMAT(par->format - 1));		//(inf->video_mode==0)
+		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
+		LcdMskReg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
+			v_COLORKEY_EN(0) | v_KEYCOLOR(0));
+		LcdWrReg(lcdc_dev,WIN0_VIR,v_VIRWIDTH(xvir));
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+    return 0;
+
+}
+
+static int win1_set_par(struct rk31_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	ScaleYrgbX = CalScale(xact, par->xsize);
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch (par->format)
+	 	{
+			case YUV422:// yuv422
+				ScaleCbrX = CalScale((xact/2), par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			case YUV420: // yuv420
+				ScaleCbrX = CalScale(xact/2, par->xsize);
+				ScaleCbrY = CalScale(yact/2, par->ysize);
+				break;
+			case YUV444:// yuv444
+				ScaleCbrX = CalScale(xact, par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			default:
+				break;
+		}
+
+		LcdMskReg(lcdc_dev,SYS_CFG, m_W1_FORMAT, v_W1_FORMAT(par->format - 1));
+		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		LcdMskReg(lcdc_dev,WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(0) | v_KEYCOLOR(0));
+		LcdWrReg(lcdc_dev,WIN1_VIR,v_VIRWIDTH(xvir));
+		
+		LCDC_REG_CFG_DONE(); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int rk31_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	if(layer_id == 0)
+	{
+		win0_open(lcdc_dev,open);	
+	}
+	else if(layer_id == 1)
+	{
+		win1_open(lcdc_dev,open);
+	}
+
+	return 0;
+}
+
+static int rk31_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = lcdc_dev->screen;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_set_par(lcdc_dev,screen,par);
+	}
+	
+	return 0;
+}
+
+int rk31_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = lcdc_dev->screen;
+	unsigned long flags;
+	int timeout;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;	
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_display(lcdc_dev,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_display(lcdc_dev,par);
+	}
+	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
+	{
+		dev_drv->first_frame = 0;
+		LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_STARTCLEAR | m_FRM_STARTMASK ,
+			  v_FRM_STARTCLEAR(1) | v_FRM_STARTMASK(0));
+		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+		 
+	}
+
+	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
+	{
+		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->screen->ft+5));
+		if(!timeout&&(!dev_drv->frame_done.done))
+		{
+			printk(KERN_ERR "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	
+	return 0;
+}
+
+int rk31_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	switch(cmd)
+	{
+		case FBIOGET_PANEL_SIZE:    //get panel size
+                	panel_size[0] = lcdc_dev->screen->x_res;
+                	panel_size[1] = lcdc_dev->screen->y_res;
+            		if(copy_to_user(argp, panel_size, 8)) 
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+static int rk31_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	struct layer_par *par = dev_drv->layer_par[layer_id];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(layer_id == 0)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W0_EN);
+		}
+		else if( layer_id == 1)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W1_EN);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return par->state;
+	
+}
+
+/***********************************
+overlay manager
+swap:1 win0 on the top of win1
+        0 win1 on the top of win0
+set  : 1 set overlay 
+        0 get overlay state
+************************************/
+static int rk31_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(set)  //set overlay
+		{
+			LcdMskReg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
+			LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
+			LCDC_REG_CFG_DONE();
+			ovl = swap;
+		}
+		else  //get overlay
+		{
+			ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+		}
+	}
+	else
+	{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+static int rk31_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	return 0;
+}
+
+
+/*******************************************
+lcdc fps manager,set or get lcdc fps
+set:0 get
+     1 set
+********************************************/
+static int rk31_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	rk_screen * screen = dev_drv->screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+
+	if(set)
+	{
+		ft = div_u64(1000000000000llu,fps);
+		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
+		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+		}
+	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+			
+	}
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+	(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps ;  //one frame time in ms
+	return fps;
+}
+int rk31_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else  //clk already disabled
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	
+		
+	mdelay(1);
+	clk_disable(lcdc_dev->dclk);
+	clk_disable(lcdc_dev->hclk);
+	clk_disable(lcdc_dev->aclk);
+	clk_disable(lcdc_dev->pd);
+
+	return 0;
+}
+
+
+int rk31_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+{  
+	struct rk31_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk31_lcdc_device,driver);
+	
+	if(!lcdc_dev->clk_on)
+	{
+		clk_enable(lcdc_dev->pd);
+		clk_enable(lcdc_dev->hclk);
+		clk_enable(lcdc_dev->dclk);
+		clk_enable(lcdc_dev->aclk);
+	}
+	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0xc4);  //resume reg
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->atv_layer_cnt)
+	{
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+		LCDC_REG_CFG_DONE();
+	}
+	lcdc_dev->clk_on = 1;
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+    	return 0;
+}
+static irqreturn_t rk31_lcdc_isr(int irq, void *dev_id)
+{
+	struct rk31_lcdc_device *lcdc_dev = (struct rk31_lcdc_device *)dev_id;
+	
+	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+	LCDC_REG_CFG_DONE();
+	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
+ 
+	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
+	{
+		spin_lock(&(lcdc_dev->driver.cpl_lock));
+		complete(&(lcdc_dev->driver.frame_done));
+		spin_unlock(&(lcdc_dev->driver.cpl_lock));
+	}
+	return IRQ_HANDLED;
+}
+
+static struct layer_par lcdc_layer[] = {
+	[0] = {
+		.name  		= "win0",
+		.id		= 0,
+		.support_3d	= true,
+	},
+	[1] = {
+		.name  		= "win1",
+		.id		= 1,
+		.support_3d	= false,
+	},
+};
+
+static struct rk_lcdc_device_driver lcdc_driver = {
+	.name			= "lcdc",
+	.def_layer_par		= lcdc_layer,
+	.num_layer		= ARRAY_SIZE(lcdc_layer),
+	.open			= rk31_lcdc_open,
+	.init_lcdc		= init_rk31_lcdc,
+	.ioctl			= rk31_lcdc_ioctl,
+	.suspend		= rk31_lcdc_early_suspend,
+	.resume			= rk31_lcdc_early_resume,
+	.set_par       		= rk31_lcdc_set_par,
+	.blank         		= rk31_lcdc_blank,
+	.pan_display            = rk31_lcdc_pan_display,
+	.load_screen		= rk31_load_screen,
+	.get_layer_state	= rk31_lcdc_get_layer_state,
+	.ovl_mgr		= rk31_lcdc_ovl_mgr,
+	.get_disp_info		= rk31_lcdc_get_disp_info,
+	.fps_mgr		= rk31_lcdc_fps_mgr,
+};
+#ifdef CONFIG_PM
+static int rk31_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk31_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define rk31_lcdc_suspend NULL
+#define rk31_lcdc_resume NULL
+#endif
+
+static int __devinit rk31_lcdc_probe (struct platform_device *pdev)
+{
+	struct rk31_lcdc_device *lcdc_dev=NULL;
+	rk_screen *screen;
+	struct rk29fb_info *screen_ctr_info;
+	struct resource *res = NULL;
+	struct resource *mem;
+	int ret = 0;
+	
+	/*************Malloc rk31lcdc_inf and set it to pdev for drvdata**********/
+	lcdc_dev = kzalloc(sizeof(struct rk31_lcdc_device), GFP_KERNEL);
+    	if(!lcdc_dev)
+    	{
+        	dev_err(&pdev->dev, ">>rk31 lcdc device kmalloc fail!");
+        	return -ENOMEM;
+    	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->id = pdev->id;
+	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
+	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen)
+	{
+		dev_err(&pdev->dev, ">>rk31 lcdc screen kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	else
+	{
+		lcdc_dev->screen = screen;
+	}
+	/****************get lcdc0 reg  *************************/
+	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
+	if (res == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+    	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
+    	if (mem == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
+	if (lcdc_dev->reg_vir_base == NULL)
+	{
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	
+    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
+	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
+	lcdc_dev->driver.dev=&pdev->dev;
+	lcdc_dev->driver.screen = screen;
+	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
+	spin_lock_init(&lcdc_dev->reg_lock);
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if(lcdc_dev->irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err3;
+	}
+	ret = request_irq(lcdc_dev->irq, rk31_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
+	if (ret)
+	{
+	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
+	       ret = -EBUSY;
+	       goto err3;
+	}
+	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
+	if(ret < 0)
+	{
+		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
+		goto err4;
+	}
+	printk("rk31 lcdc%d probe ok!\n",lcdc_dev->id);
+
+	return 0;
+
+err4:
+	free_irq(lcdc_dev->irq,lcdc_dev);
+err3:	
+	iounmap(lcdc_dev->reg_vir_base);
+err2:
+	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
+err1:
+	kfree(screen);
+err0:
+	platform_set_drvdata(pdev, NULL);
+	kfree(lcdc_dev);
+	return ret;
+    
+}
+static int __devexit rk31_lcdc_remove(struct platform_device *pdev)
+{
+	struct rk31_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk31_lcdc_deinit(lcdc_dev);
+	iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);
+	return 0;
+}
+
+static void rk31_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct rk31_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk31_lcdc_deinit(lcdc_dev);
+	/*iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);*/
+}
+
+
+static struct platform_driver rk31_lcdc_driver = {
+	.probe		= rk31_lcdc_probe,
+	.remove		= __devexit_p(rk31_lcdc_remove),
+	.driver		= {
+		.name	= "rk30-lcdc",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= rk31_lcdc_suspend,
+	.resume		= rk31_lcdc_resume,
+	.shutdown   = rk31_lcdc_shutdown,
+};
+
+static int __init rk31_lcdc_init(void)
+{
+    return platform_driver_register(&rk31_lcdc_driver);
+}
+
+static void __exit rk31_lcdc_exit(void)
+{
+    platform_driver_unregister(&rk31_lcdc_driver);
+}
+
+
+
+fs_initcall(rk31_lcdc_init);
+module_exit(rk31_lcdc_exit);
+
+
+
diff --git a/drivers/video/rockchip/chips/rk31_lcdc.h b/drivers/video/rockchip/chips/rk31_lcdc.h
new file mode 100644
index 000000000000..25c6044d8688
--- /dev/null
+++ b/drivers/video/rockchip/chips/rk31_lcdc.h
@@ -0,0 +1,543 @@
+/* drivers/video/rockchip/chips/rk29_fb.h
+ *
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __RK31_LCDC_H
+#define __RK31_LCDC_H
+
+#include<linux/rk_fb.h>
+
+#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
+#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
+#define LcdRdReg(inf, addr)             (inf->preg->addr)
+#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
+#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
+#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
+#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
+#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
+
+
+/********************************************************************
+**                            ∫Í∂®“Â                                *
+********************************************************************/
+/* SYS_CONFIG */
+#define m_W2_FORMAT          (3<<0)
+#define m_W1_FORMAT          (1<<2)
+#define m_W0_FORMAT          (7<<3)
+#define m_W0_CBR_DEFLICK_EN  (1<<6)
+#define m_W0_YRGB_DEFLICK_EN  (1<<7)
+#define m_INTERIACE_EN       (1<<8)
+#define m_W2_EN              (1<<9)
+#define m_W1_EN              (1<<10)
+#define m_W0_EN              (1<<11)
+#define m_HWC_EN              (1<<12)
+#define m_HWC_RELOAD_EN         (1<<13)
+#define m_W2_INTERLACE_READ    (1<<14)
+#define m_W1_INTERLACE_READ    (1<<15)
+#define m_W0_INTERLACE_READ    (1<<16)
+#define m_LCDC_STANDBY            (1<<17)
+#define m_HWC_BURST          (3<<18)
+#define m_W2_BURST           (3<<20)
+#define m_W1_BURST           (3<<22)
+#define m_W0_BURST           (3<<24)
+#define m_W2_LUT_CTL         (1<<26)
+#define m_DSIP_LUT_CTL       (1<<27)
+#define m_HWC_REVERSED_COLOR   (1<<28)
+#define m_W1_AXI_OUTSTANDING2     (1<<29)
+#define m_W0_AXI_OUTSTANDING2     (1<<30)
+#define m_LCDC_AXICLK_AUTO_ENABLE (1<<31)
+
+#define v_W2_FORMAT(x)         (((x)&3)<<0)
+#define v_W1_FORMAT(x)          (((x)&1)<<2)
+#define v_W0_FORMAT(x)          (((x)&7)<<3)
+#define v_W0_CBR_DEFLICK_EN(x)  (((x)&1)<<6)
+#define v_W0_YRGB_DEFLICK_EN(x)  (((x)&1)<<7)
+#define v_INTERIACE_EN(x)       (((x)&1)<<8)
+#define v_W2_EN(x)          (((x)&)1<<9)
+#define v_W1_EN(x)          (((x)&1)<<10)
+#define v_W0_EN(x)          (((x)&1)<<11)
+#define v_HWC_EN(x)         (((x)&1)<<12)
+#define v_HWC_RELOAD_EN(x)         (((x)&1)<<13)
+#define v_W2_INTERLACE_READ(x)    (((x)&1)<<14)
+#define v_W1_INTERLACE_READ(x)    (((x)&1)<<15)
+#define v_W0_INTERLACE_READ(x)    (((x)&1)<<16)
+#define v_LCDC_STANDBY(x)            (((x)&1)<<17)
+#define v_HWC_BURST(x)          (((x)&3)<<18)
+#define v_W2_BURST(x)           (((x)&3)<<20)
+#define v_W1_BURST(x)           (((x)&3)<<22)
+#define v_W0_BURST(x)           (((x)&3)<<24)
+#define v_W2_LUT_CTL(x)         (((x)&1)<<26)
+#define v_DSIP_LUT_CTL(x)       (((x)&1)<<27)
+#define v_HWC_REVERSED_COLOR(x)   (((x)&1)<<28)
+#define v_W1_AXI_OUTSTANDING2(x)     (((x)&1)<<29)
+#define v_W0_AXI_OUTSTANDING2(x)     (((x)&1)<<30)
+#define v_LCDC_AXICLK_AUTO_ENABLE(x)    (((x)&1)<<31)
+
+//LCDC_SWAP_CTRL
+#define m_W1_565_RB_SWAP        (1<<0)
+#define m_W0_565_RB_SWAP        (1<<1)
+#define m_W0_YRGB_M8_SWAP       (1<<2)
+#define m_W0_YRGB_R_SHIFT_SWAP  (1<<3)
+#define m_W0_CBR_R_SHIFT_SWAP   (1<<4)
+#define m_W0_YRGB_16_SWAP       (1<<5)
+#define m_W0_YRGB_8_SWAP        (1<<6)
+#define m_W0_CBR_16_SWAP        (1<<7)
+#define m_W0_CBR_8_SWAP         (1<<8)
+#define m_W1_16_SWAP            (1<<9)
+#define m_W1_8_SWAP             (1<<10)
+#define m_W1_R_SHIFT_SWAP       (1<<11)
+#define m_OUTPUT_BG_SWAP        (1<<12)
+#define m_OUTPUT_RB_SWAP        (1<<13)
+#define m_OUTPUT_RG_SWAP        (1<<14)
+#define m_DELTA_SWAP            (1<<15)
+#define m_DUMMY_SWAP            (1<<16)
+#define m_W2_BYTE_SWAP          (1<<17)
+#define v_W1_565_RB_SWAP(x)        (((x)&1)<<0)
+#define v_W0_565_RB_SWAP(x)        (((x)&1)<<1)
+#define v_W0_YRGB_M8_SWAP(x)       (((x)&1)<<2)
+#define v_W0_YRGB_R_SHIFT_SWAP(x)  (((x)&1)<<3)
+#define v_W0_CBR_R_SHIFT_SWAP(x)   (((x)&1)<<4)
+#define v_W0_YRGB_16_SWAP(x)       (((x)&1)<<5)
+#define v_W0_YRGB_8_SWAP(x)        (((x)&1)<<6)
+#define v_W0_CBR_16_SWAP(x)        (((x)&1)<<7)
+#define v_W0_CBR_8_SWAP(x)         (((x)&1)<<8)
+#define v_W1_16_SWAP(x)            (((x)&1)<<9)
+#define v_W1_8_SWAP(x)             (((x)&1)<<10)
+#define v_W1_R_SHIFT_SWAP(x)       (((x)&1)<<11)
+#define v_OUTPUT_BG_SWAP(x)        (((x)&1)<<12)
+#define v_OUTPUT_RB_SWAP(x)        (((x)&1)<<13)
+#define v_OUTPUT_RG_SWAP(x)        (((x)&1)<<14)
+#define v_DELTA_SWAP(x)            (((x)&1)<<15)
+#define v_DUMMY_SWAP(x)            (((x)&1)<<16)
+#define v_W2_BYTE_SWAP(x)      (((x)&1)<<17)
+
+//LCDC_MCU_TIMING_CTRL
+#define m_MCU_WRITE_PERIOD      (31<<0)
+#define m_MCU_CS_ST             (31<<5)
+#define m_MCU_CS_END            (31<<10)
+#define m_MCU_RW_ST             (31<<15)
+#define m_MCU_RW_END            (31<<20)
+#define m_MCU_HOLDMODE_SELECT     (1<<27)
+#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
+#define m_MCU_RS_SELECT            (1<<29)
+#define m_MCU_BYPASSMODE_SELECT   (1<<30)
+#define m_MCU_OUTPUT_SELECT        (1<<31)
+#define v_MCU_WRITE_PERIOD(x)      (((x)&31)<<0)
+#define v_MCU_CS_ST(x)          (((x)&31)<<5)
+#define v_MCU_CS_END(x)         (((x)&31)<<10)
+#define v_MCU_RW_ST(x)          (((x)&31)<<15)
+#define v_MCU_RW_END(x)         (((x)&31)<<20)
+#define v_MCU_HOLD_STATUS(x)          (((x)&1)<<26)
+#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
+#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
+#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
+#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
+#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
+
+//LCDC_ BLEND_CTRL
+#define m_HWC_BLEND_EN         (1<<0)
+#define m_W2_BLEND_EN          (1<<1)
+#define m_W1_BLEND_EN          (1<<2)
+#define m_W0_BLEND_EN          (1<<3)
+#define m_HWC_BLEND_FACTOR     (15<<4)
+#define m_W2_BLEND_FACTOR     (0xff<<8)
+#define m_W1_BLEND_FACTOR     (0xff<<16)
+#define m_W0_BLEND_FACTOR     (0xff<<24)
+
+#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
+#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
+#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
+#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
+#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
+#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
+#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
+#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
+
+
+//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
+#define m_KEYCOLOR          (0xffffff<<0)
+#define m_KEYCOLOR_B          (0xff<<0)
+#define m_KEYCOLOR_G          (0xff<<8)
+#define m_KEYCOLOR_R          (0xff<<16)
+#define m_COLORKEY_EN         (1<<24)
+#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
+#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
+#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
+#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
+#define v_COLORKEY_EN(x)         (((x)&1)<<24)
+
+//LCDC_DEFLICKER_SCL_OFFSET
+#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
+#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
+#define m_W1_VSD_OFFSET           (0xff<<16)
+#define m_W1_VSP_OFFSET           (0xff<<24)
+#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
+#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
+#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
+#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
+
+//LCDC_DSP_CTRL_REG0
+#define m_DISPLAY_FORMAT             (0xf<<0)
+#define m_HSYNC_POLARITY             (1<<4)
+#define m_VSYNC_POLARITY             (1<<5)
+#define m_DEN_POLARITY               (1<<6)
+#define m_DCLK_POLARITY              (1<<7)
+#define m_COLOR_SPACE_CONVERSION     (3<<8)
+#define m_DITHER_UP_EN               (1<<10)
+#define m_DITHER_DOWN_MODE           (1<<11)
+#define m_DITHER_DOWN_EN             (1<<12)
+#define m_INTERLACE_FIELD_POLARITY   (1<<13)
+#define m_YUV_CLIP                   (1<<14)
+#define m_W1_TRANSP_FROM             (1<<15)
+#define m_W0_TRANSP_FROM             (1<<16)
+#define m_W0W1_POSITION_SWAP         (1<<17)
+#define m_W1_CLIP_EN                 (1<<18)
+#define m_W0_CLIP_EN                 (1<<19)
+#define m_W0_YCBR_PRIORITY_MODE      (1<<20)
+#define m_CBR_FILTER_656             (1<<21)
+#define m_W2_CHIP_EN                 (1<<22)
+
+#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
+#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
+#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
+#define v_DEN_POLARITY(x)               (((x)&1)<<6)
+#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
+#define v_COLOR_SPACE_CONVERSION(x)     (((x)&3)<<8)
+#define v_DITHER_UP_EN(x)               (((x)&1)<<10)
+#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<11)
+#define v_DITHER_DOWN_EN(x)             (((x)&1)<<12)
+#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
+#define v_YUV_CLIP(x)                   (((x)&1)<<14)
+#define v_W1_TRANSP_FROM(x)             (((x)&1)<<15)
+#define v_W0_TRANSP_FROM(x)             (((x)&1)<<16)
+#define v_W0W1_POSITION_SWAP(x)         (((x)&1)<<17)
+#define v_W1_CLIP_EN(x)                 (((x)&1)<<18)
+#define v_W0_CLIP_EN(x)                 (((x)&1)<<19)
+#define v_W0_YCBR_PRIORITY_MODE(x)      (((x)&1)<<20)
+#define v_CBR_FILTER_656(x)             (((x)&1)<<21)
+#define v_W2_CHIP_EN(x)                 (((x)&1)<<22)
+
+
+//LCDC_DSP_CTRL_REG1
+#define m_BG_COLOR                    (0xffffff<<0)
+#define m_BG_B                        (0xff<<0)
+#define m_BG_G                        (0xff<<8)
+#define m_BG_R                        (0xff<<16)
+#define m_BLANK_MODE                  (1<<24)
+#define m_BLACK_MODE                  (1<<25)
+#define m_DISP_FILTER_FACTOR          (3<<26)
+#define m_DISP_FILTER_MODE            (1<<28)
+#define m_DISP_FILTER_EN              (1<<29)
+#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
+#define v_BG_B(x)                     (((x)&0xff)<<0)
+#define v_BG_G(x)                     (((x)&0xff)<<8)
+#define v_BG_R(x)                     (((x)&0xff)<<16)
+#define v_BLANK_MODE(x)               (((x)&1)<<24)
+#define v_BLACK_MODE(x)               (((x)&1)<<25)
+#define v_DISP_FILTER_FACTOR(x)       (((x)&3)<<26)
+#define v_DISP_FILTER_MODE(x)         (((x)&1)<<28)
+#define v_DISP_FILTER_EN(x)           (((x)&1)<<29)
+
+//LCDC_INT_STATUS
+#define m_HOR_START         (1<<0)
+#define m_FRM_START         (1<<1)
+#define m_SCANNING_FLAG     (1<<2)
+#define m_HOR_STARTMASK     (1<<3)
+#define m_FRM_STARTMASK     (1<<4)
+#define m_SCANNING_MASK     (1<<5)
+#define m_HOR_STARTCLEAR    (1<<6)
+#define m_FRM_STARTCLEAR    (1<<7)
+#define m_SCANNING_CLEAR    (1<<8)
+#define m_SCAN_LINE_NUM     (0x7ff<<9)
+#define v_HOR_START(x)         (((x)&1)<<0)
+#define v_FRM_START(x)         (((x)&1)<<1)
+#define v_SCANNING_FLAG(x)     (((x)&1)<<2)
+#define v_HOR_STARTMASK(x)     (((x)&1)<<3)
+#define v_FRM_STARTMASK(x)     (((x)&1)<<4)
+#define v_SCANNING_MASK(x)     (((x)&1)<<5)
+#define v_HOR_STARTCLEAR(x)    (((x)&1)<<6)
+#define v_FRM_STARTCLEAR(x)    (((x)&1)<<7)
+#define v_SCANNING_CLEAR(x)    (((x)&1)<<8)
+#define v_SCAN_LINE_NUM(x)     (((x)&0x7ff)<<9)
+
+//AXI MS ID
+#define m_W0_YRGB_CH_ID        (0xF<<0)
+#define m_W0_CBR_CH_ID         (0xF<<4)
+#define m_W1_YRGB_CH_ID        (0xF<<8)
+#define m_W2_CH_ID             (0xF<<12)
+#define m_HWC_CH_ID            (0xF<<16)
+#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
+#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
+#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
+#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
+#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
+
+
+/* Low Bits Mask */
+#define m_WORDLO            (0xffff<<0)
+#define m_WORDHI            (0xffff<<16)
+#define v_WORDLO(x)         (((x)&0xffff)<<0)
+#define v_WORDHI(x)         (((x)&0xffff)<<16)
+
+#define m_BIT11LO           (0x7ff<<0)
+#define m_BIT11HI           (0x7ff<<16)
+#define v_BIT11LO(x)        (((x)&0x7ff)<<0)
+#define v_BIT11HI(x)        (((x)&0x7ff)<<16)
+
+#define m_BIT12LO           (0xfff<<0)
+#define m_BIT12HI           (0xfff<<16)
+#define v_BIT12LO(x)        (((x)&0xfff)<<0)
+#define v_BIT12HI(x)        (((x)&0xfff)<<16)
+
+
+#define m_VIRWIDTH       (0xffff<<0)
+#define m_VIRHEIGHT      (0xffff<<16)
+#define v_VIRWIDTH(x)       (((x)&0xffff)<<0)
+#define v_VIRHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_ACTWIDTH       (0xffff<<0)
+#define m_ACTHEIGHT      (0xffff<<16)
+#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
+#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_VIRST_X      (0xffff<<0)
+#define m_VIRST_Y      (0xffff<<16)
+#define v_VIRST_X(x)      (((x)&0xffff)<<0)
+#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
+
+#define m_PANELST_X      (0x3ff<<0)
+#define m_PANELST_Y      (0x3ff<<16)
+#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
+#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
+
+#define m_PANELWIDTH       (0x3ff<<0)
+#define m_PANELHEIGHT      (0x3ff<<16)
+#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
+#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
+
+#define m_HWC_B                 (0xff<<0)
+#define m_HWC_G                 (0xff<<8)
+#define m_HWC_R                 (0xff<<16)
+#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
+#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
+#define v_HWC_B(x)                 (((x)&0xff)<<0)
+#define v_HWC_G(x)                 (((x)&0xff)<<8)
+#define v_HWC_R(x)                 (((x)&0xff)<<16)
+#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
+#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
+
+
+//Panel display scanning
+#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
+
+#define m_PANEL_END              (0x3ff<<0)
+#define m_PANEL_START            (0x3ff<<16)
+#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
+#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
+
+#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
+//-----------
+
+#define m_HSCALE_FACTOR        (0xffff<<0)
+#define m_VSCALE_FACTOR        (0xffff<<16)
+#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
+#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
+
+#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
+#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
+#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
+#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
+#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
+#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
+#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
+#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
+
+
+#define m_WIN1_FIFO_FULL_LEVEL 		(0x7f << 0)
+#define m_WIN2_FIFO_FULL_LEVEL 		(0x1f << 7)
+#define v_WIN1_FIFO_FULL_LEVEL(x)	(((x)&0x7f) << 0)
+#define v_WIN2_FIFO_FULL_LEVEL(x)	(((x)&0x1f) << 7)
+
+
+
+//LCDC_WINx_SCL_FACTOR_Y/CBCR
+#define v_X_SCL_FACTOR(x)  ((x)<<0)
+#define v_Y_SCL_FACTOR(x)  ((x)<<16)
+
+//LCDC_DSP_HTOTAL_HS_END
+#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
+#define v_HORPRD(x) ((x)<<16)   //horizontal period
+
+
+//LCDC_DSP_HACT_ST_END
+#define v_HAEP(x) ((x)<<0)  //horizontal active end point
+#define v_HASP(x) ((x)<<16) //horizontal active start point
+
+//LCDC_DSP_VTOTAL_VS_END
+#define v_VSYNC(x) ((x)<<0)
+#define v_VERPRD(x) ((x)<<16)
+
+//LCDC_DSP_VACT_ST_END
+#define v_VAEP(x) ((x)<<0)
+#define v_VASP(x) ((x)<<16)
+
+//LCDC_WIN0_ACT_INFO
+#define v_ACT_WIDTH(x)     ((x)<<0)
+#define v_ACT_HEIGHT(x)    ((x)<<16)
+
+//LCDC_WIN0_DSP_INFO
+#define v_DSP_WIDTH(x)     ((x)<<0)
+#define v_DSP_HEIGHT(x)    ((x)<<16)
+
+//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
+#define v_DSP_STX(x)      (x<<0)
+#define v_DSP_STY(x)      (x<<16)
+
+
+/********************************************************************
+**                          Ω·ππ∂®“Â                                *
+********************************************************************/
+/* LCDCµƒºƒ¥Ê∆˜Ω·ππ */
+
+typedef volatile struct tagLCDC_REG
+{
+    /* offset 0x00~0xc0 */
+    unsigned int SYS_CFG;              //0x00 SYSTEM configure register
+    unsigned int SWAP_CTRL;               //0x04 Data SWAP control
+    unsigned int MCU_CTRL;         //0x08 MCU TIMING control register
+    unsigned int BLEND_CTRL;              //0x0c Blending control register
+    unsigned int WIN0_COLOR_KEY_CTRL;     //0x10 Win0 blending control register
+    unsigned int WIN1_COLOR_KEY_CTRL;     //0x14 Win1 blending control register
+    unsigned int WIN2_VIR;                //0x18 WIN2 virtual display width
+    unsigned int DSP_CTRL0;               //0x1c Display control register0
+    unsigned int DSP_CTRL1;               //0x20 Display control register1
+    unsigned int INT_STATUS;              //0x24 Interrupt status register
+    unsigned int WIN0_VIR;                //0x28 WIN0 virtual display width/height
+    unsigned int WIN0_YRGB_MST;           //0x2c Win0 active YRGB memory start address
+    unsigned int WIN0_CBR_MST;            //0x30 Win0 active Cbr memory start address
+    unsigned int WIN0_ACT_INFO;           //0x34 Win0 active window width/height
+    unsigned int WIN0_DSP_ST;             //0x38 Win0 display start point on panel
+    unsigned int WIN0_DSP_INFO;           //0x3c Win0 display width/height on panel
+    unsigned int WIN1_VIR;                //0x40 Win1 virtual display width/height
+    unsigned int WIN1_YRGB_MST;           //0x44 Win1 active  memory start address
+    unsigned int WIN1_DSP_INFO;           //0x48 Win1 display width/height on panel
+    unsigned int WIN1_DSP_ST;             //0x4c Win1 display start point on panel
+    unsigned int WIN2_MST;                //0X50 Win2 memory start address
+    unsigned int WIN2_DSP_INFO;           //0x54 Win1 display width/height on panel
+    unsigned int WIN2_DSP_ST;             //0x58 Win1 display start point on panel
+    unsigned int HWC_MST;                 //0x5C HWC memory start address
+    unsigned int HWC_DSP_ST;              //0x60 HWC display start point on panel
+    unsigned int HWC_COLOR_LUT0;          //0x64 Hardware cursor color 2°Øb01 look up table 0
+    unsigned int HWC_COLOR_LUT1;          //0x68 Hardware cursor color 2°Øb10 look up table 1
+    unsigned int HWC_COLOR_LUT2;          //0x6c Hardware cursor color 2°Øb11 look up table 2
+    unsigned int DSP_HTOTAL_HS_END;       //0x70 Panel scanning horizontal width and hsync pulse end point
+    unsigned int DSP_HACT_ST_END;         //0x74 Panel active horizontal scanning start/end point
+    unsigned int DSP_VTOTAL_VS_END;       //0x78 Panel scanning vertical height and vsync pulse end point
+    unsigned int DSP_VACT_ST_END;         //0x7c Panel active vertical scanning start/end point
+    unsigned int DSP_VS_ST_END_F1;        //0x80 Vertical scanning start point and vsync pulse end point of even filed in interlace mode
+    unsigned int DSP_VACT_ST_END_F1;      //0x84 Vertical scanning active start/end point of even filed in interlace mode
+    unsigned int WIN0_SCL_FACTOR_YRGB;    //0x88 Win0 YRGB scaling down factor setting
+    unsigned int WIN0_SCL_FACTOR_CBR;     //0x8c Win0 YRGB scaling up factor setting
+    unsigned int WIN0_SCL_OFFSET;         //0x90 Win0 Cbr scaling start point offset
+    unsigned int FIFO_WATER_MARK;         //0x94 Fifo water mark
+    unsigned int AXI_MS_ID;               //0x98 Axi master ID
+    unsigned int reserved0;               //0x9c
+    unsigned int REG_CFG_DONE;            //0xa0 REGISTER CONFIG FINISH
+    unsigned int reserved1[(0x100-0xa4)/4];
+    unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
+    unsigned int reserved2[(0x200-0x104)/4];
+    unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port
+} LCDC_REG, *pLCDC_REG;
+
+//roate
+#define 	ROTATE_0		0
+#define 	ROTATE_90		90
+#define 	ROTATE_180		180
+#define 	ROTATE_270		270
+#define 	X_MIRROR		(1<<10)
+#define		Y_MIRROR		(1<<11)
+
+
+
+
+#define CalScale(x, y)	             (((u32)x*0x1000)/y)
+struct rk31_lcdc_device{
+	int id;
+	struct rk_lcdc_device_driver driver;
+	rk_screen *screen;
+	
+	LCDC_REG *preg;         // LCDC reg base address and backup reg 
+    	LCDC_REG regbak;
+
+	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
+
+	unsigned int		irq;
+
+	struct clk		*pd;				//lcdc power domain
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
+	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
+	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk		*pd_display;		// display power domain
+	u32	pixclock;
+};
+
+struct lcdc_info{
+/*LCD CLK*/
+	struct rk31_lcdc_device lcdc0;
+	struct rk31_lcdc_device lcdc1;
+
+};
+
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    enum data_format format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+#endif
-- 
2.35.3

