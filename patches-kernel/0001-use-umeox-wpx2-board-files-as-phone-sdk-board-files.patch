From eb75eb34dcb3517106e195b3956aba410a6543f4 Mon Sep 17 00:00:00 2001
From: zwp <zwp@rock-chips.com>
Date: Tue, 12 Jun 2012 21:09:19 +0800
Subject: [PATCH] use umeox wpx2 board files as phone sdk board files.

---
 arch/arm/configs/rk30_phone_defconfig         |   50 +-
 arch/arm/mach-rk30/Kconfig                    |    3 +
 arch/arm/mach-rk30/Makefile                   |    1 +
 arch/arm/mach-rk30/board-rk30-phone-key.c     |    8 +-
 arch/arm/mach-rk30/board-rk30-phone.c         | 1707 +++++++++--------
 arch/arm/mach-rk30/include/mach/board.h       |   11 +
 drivers/input/touchscreen/Kconfig             |    4 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/ft5306_ts_wpx2.c    |  723 +++++++
 drivers/video/display/screen/Kconfig          |    2 +
 drivers/video/display/screen/Makefile         |    1 +
 .../display/screen/lcd_hsd100pxn_for_tdw851.c |  323 ++++
 12 files changed, 2011 insertions(+), 823 deletions(-)
 create mode 100755 drivers/input/touchscreen/ft5306_ts_wpx2.c
 create mode 100644 drivers/video/display/screen/lcd_hsd100pxn_for_tdw851.c

diff --git a/arch/arm/configs/rk30_phone_defconfig b/arch/arm/configs/rk30_phone_defconfig
index 69a52e23805d..ff7a8220f38b 100755
--- a/arch/arm/configs/rk30_phone_defconfig
+++ b/arch/arm/configs/rk30_phone_defconfig
@@ -22,10 +22,10 @@ CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
 CONFIG_ARCH_RK30=y
-CONFIG_DDR_TYPE_LPDDR=y
 CONFIG_DDR_SDRAM_FREQ=300
 CONFIG_WIFI_CONTROL_FUNC=y
 CONFIG_MACH_RK30_PHONE=y
+CONFIG_CLK_SWITCH_TO_32K=y
 # CONFIG_SWP_EMULATE is not set
 CONFIG_FIQ_DEBUGGER=y
 CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
@@ -51,6 +51,8 @@ CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_HOTPLUG=y
 CONFIG_CPU_IDLE=y
 CONFIG_VFP=y
 CONFIG_NEON=y
@@ -175,7 +177,9 @@ CONFIG_BT_HIDP=y
 CONFIG_BT_HCIUART=y
 CONFIG_BT_HCIUART_H4=y
 CONFIG_BT_HCIBCM4325=y
+CONFIG_BT_AUTOSLEEP=y
 CONFIG_RFKILL=y
+CONFIG_RFKILL_RK=y
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 # CONFIG_FIRMWARE_IN_KERNEL is not set
@@ -199,12 +203,12 @@ CONFIG_BLK_DEV_DM=y
 CONFIG_DM_CRYPT=y
 CONFIG_DM_UEVENT=y
 CONFIG_NETDEVICES=y
-CONFIG_MII=y
 CONFIG_PHYLIB=y
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
 CONFIG_WLAN_80211=y
 CONFIG_BCM4329=y
+CONFIG_USB_USBNET=y
 CONFIG_PPP=y
 CONFIG_PPP_MULTILINK=y
 CONFIG_PPP_FILTER=y
@@ -223,16 +227,17 @@ CONFIG_INPUT_KEYRESET=y
 CONFIG_INPUT_JOYSTICK=y
 CONFIG_INPUT_TABLET=y
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ILI2102_IIC=y
+CONFIG_TOUCHSCREEN_FT5306=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_TWL6030_PWRBUTTON=y
 CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_WM831X_ON=y
 CONFIG_MAG_SENSORS=y
 CONFIG_COMPASS_AK8975=y
 CONFIG_G_SENSOR_DEVICE=y
 CONFIG_GS_MMA8452=y
 CONFIG_GYRO_SENSOR_DEVICE=y
+CONFIG_GYRO_L3G4200D=y
 CONFIG_LIGHT_SENSOR_DEVICE=y
 # CONFIG_SERIO is not set
 # CONFIG_CONSOLE_TRANSLATIONS is not set
@@ -246,38 +251,36 @@ CONFIG_UART3_CTS_RTS_RK29=y
 CONFIG_I2C=y
 # CONFIG_I2C_COMPAT is not set
 CONFIG_I2C0_CONTROLLER_RK30=y
-# CONFIG_I2C1_RK30 is not set
+CONFIG_I2C1_CONTROLLER_RK30=y
 CONFIG_I2C2_CONTROLLER_RK30=y
 CONFIG_I2C3_CONTROLLER_RK30=y
 CONFIG_I2C4_CONTROLLER_RK30=y
-CONFIG_I2C_GPIO_RK30=y
 CONFIG_SPI=y
 CONFIG_SPIM_RK29=y
-CONFIG_SPIM0_RK29=y
 CONFIG_SPIM1_RK29=y
-CONFIG_RK_HEADSET_DET=y
-CONFIG_GPIO_WM831X=y
-CONFIG_GPIO_WM8994=y
+CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET=y
+CONFIG_GPIO_SYSFS=y
 CONFIG_EXPANDED_GPIO_NUM=0
 CONFIG_EXPANDED_GPIO_IRQ_NUM=0
 CONFIG_SPI_FPGA_GPIO_NUM=0
 CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
 CONFIG_POWER_SUPPLY=y
-CONFIG_WM831X_BACKUP=y
-CONFIG_WM831X_POWER=y
+CONFIG_TWL6030_BCI_BATTERY=y
 # CONFIG_HWMON is not set
-CONFIG_MFD_WM831X_I2C=y
-CONFIG_MFD_WM8994=y
+CONFIG_TWL4030_CORE=y
+CONFIG_TWL6030_POWEROFF=y
+CONFIG_TWL6030_MADC=y
+CONFIG_TWL6030_GPADC=y
+CONFIG_AIC3262_CODEC=y
 CONFIG_REGULATOR=y
-CONFIG_REGULATOR_WM831X=y
-CONFIG_REGULATOR_WM8994=y
-CONFIG_RK30_PWM_REGULATOR=y
+CONFIG_REGULATOR_TWL4030=y
 CONFIG_MEDIA_SUPPORT=y
 CONFIG_VIDEO_DEV=y
 CONFIG_SOC_CAMERA=y
-CONFIG_SOC_CAMERA_GC0309=y
+CONFIG_SOC_CAMERA_OV7675=y
+CONFIG_SOC_CAMERA_OV5640=y
 CONFIG_VIDEO_RK29=y
-CONFIG_SMS_SIANO_MDTV=y
+CONFIG_VIDEO_RK29_CAMMEM_ION=y
 CONFIG_ION=y
 CONFIG_ION_ROCKCHIP=y
 CONFIG_FB=y
@@ -285,12 +288,11 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
-# CONFIG_BACKLIGHT_RK29_BL is not set
-CONFIG_BACKLIGHT_AW9364=y
 CONFIG_DISPLAY_SUPPORT=y
-CONFIG_LCD_NT35510=y
+CONFIG_LCD_HSD100PXN_FOR_TDW851=y
 CONFIG_FB_ROCKCHIP=y
 CONFIG_LCDC_RK30=y
+# CONFIG_LCDC1_RK30 is not set
 CONFIG_RGA_RK30=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
@@ -304,7 +306,7 @@ CONFIG_SND=y
 CONFIG_SND_SOC=y
 CONFIG_SND_RK29_SOC=y
 CONFIG_SND_I2S_DMA_EVENT_STATIC=y
-CONFIG_SND_RK29_SOC_WM8994=y
+CONFIG_SND_RK29_SOC_AIC3262=y
 CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
 CONFIG_HID_A4TECH=y
 CONFIG_HID_ACRUX=y
@@ -383,7 +385,7 @@ CONFIG_LEDS_GPIO=y
 CONFIG_SWITCH=y
 CONFIG_SWITCH_GPIO=y
 CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_WM831X=y
+CONFIG_RTC_DRV_TWL4030=y
 CONFIG_STAGING=y
 CONFIG_ANDROID=y
 CONFIG_ANDROID_BINDER_IPC=y
diff --git a/arch/arm/mach-rk30/Kconfig b/arch/arm/mach-rk30/Kconfig
index 74d7ae57b158..cb9ffb0fb385 100755
--- a/arch/arm/mach-rk30/Kconfig
+++ b/arch/arm/mach-rk30/Kconfig
@@ -15,6 +15,9 @@ config MACH_RK30_PHONE
 
 config MACH_RK30_PHONE_LOQUAT
 	bool "RK30 smart phone loquat board"
+
+config MACH_RK30_PHONE_A22
+        bool "RK30 smart phone a22 board"
 	
 endchoice
 
diff --git a/arch/arm/mach-rk30/Makefile b/arch/arm/mach-rk30/Makefile
index 13bfb8d5eea2..eb2659740272 100755
--- a/arch/arm/mach-rk30/Makefile
+++ b/arch/arm/mach-rk30/Makefile
@@ -24,4 +24,5 @@ obj-$(CONFIG_MACH_RK3066_SDK) += board-rk30-sdk.o board-rk30-sdk-key.o
 obj-$(CONFIG_MACH_RK30_SDK) += board-rk30-sdk.o board-rk30-sdk-key.o
 obj-$(CONFIG_MACH_RK30_PHONE) += board-rk30-phone.o board-rk30-phone-key.o
 obj-$(CONFIG_MACH_RK30_PHONE_LOQUAT) += board-rk30-phone-loquat.o board-rk30-phone-loquat-key.o
+obj-$(CONFIG_MACH_RK30_PHONE_A22) += board-rk30-phone-a22.o board-rk30-phone-a22-key.o 
 
diff --git a/arch/arm/mach-rk30/board-rk30-phone-key.c b/arch/arm/mach-rk30/board-rk30-phone-key.c
index 46ef9165f0ee..eeb4d58170e2 100755
--- a/arch/arm/mach-rk30/board-rk30-phone-key.c
+++ b/arch/arm/mach-rk30/board-rk30-phone-key.c
@@ -8,12 +8,14 @@
 #define PRESS_LEV_HIGH			0
 
 static struct rk29_keys_button key_button[] = {
+#if 0
 	{
 		.desc	= "menu",
 		.code	= EV_MENU,
 		.gpio	= RK30_PIN0_PD0,
 		.active_low = PRESS_LEV_LOW,
 	},
+#endif
 	{
 		.desc	= "vol+",
 		.code	= KEY_VOLUMEUP,
@@ -26,6 +28,8 @@ static struct rk29_keys_button key_button[] = {
 		.gpio	= RK30_PIN4_PC5,
 		.active_low = PRESS_LEV_LOW,
 	},
+#if 0
+
 	{
 		.desc	= "home",
 		.code	= KEY_HOME,
@@ -44,7 +48,7 @@ static struct rk29_keys_button key_button[] = {
 		.gpio	= RK30_PIN0_PD3,
 		.active_low = PRESS_LEV_LOW,
 	},
-#if 0
+
 	{
 		.desc	= "play",
 		.code	= KEY_POWER,
@@ -53,13 +57,13 @@ static struct rk29_keys_button key_button[] = {
 		//.code_long_press = EV_ENCALL,
 		.wakeup	= 1,
 	},
-#endif
 	{
 		.desc	= "camera",
 		.code	= KEY_CAMERA,
 		.gpio = RK30_PIN0_PD4,
 		.active_low = PRESS_LEV_LOW,
 	},
+#endif
 };
 struct rk29_keys_platform_data rk29_keys_pdata = {
 	.buttons	= key_button,
diff --git a/arch/arm/mach-rk30/board-rk30-phone.c b/arch/arm/mach-rk30/board-rk30-phone.c
index c3c8be34f630..1cfe58041be5 100755
--- a/arch/arm/mach-rk30/board-rk30-phone.c
+++ b/arch/arm/mach-rk30/board-rk30-phone.c
@@ -40,19 +40,14 @@
 #include <mach/io.h>
 #include <mach/gpio.h>
 #include <mach/iomux.h>
-#include <linux/mpu.h>
 #include <linux/fb.h>
-#include <linux/wimo.h>
-
+#include <linux/rfkill-rk.h>
 #if defined(CONFIG_HDMI_RK30)
 	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
 #endif
-
-#include <linux/regulator/fixed.h>
-#include <linux/mfd/wm8994/pdata.h>
-#include <linux/regulator/machine.h>
 #include "../../../drivers/headset_observe/rk_headset.h"
-#include <linux/regulator/rk29-pwm-regulator.h>
+#include <linux/mfd/tlv320aic3262-core.h>
+#include <linux/mfd/tlv320aic3262-registers.h>
 
 #if defined(CONFIG_SPIM_RK29)
 #include "../../../drivers/spi/rk29_spim.h"
@@ -60,58 +55,72 @@
 #if defined(CONFIG_ANDROID_TIMED_GPIO)
 #include "../../../drivers/staging/android/timed_gpio.h"
 #endif
-#if defined(CONFIG_BACKLIGHT_AW9364)
-#include "../../../drivers/video/backlight/aw9364_bl.h"
-#endif
-#if defined(CONFIG_RK29_SC8800)
-#include "../../../drivers/tty/serial/sc8800.h"
-#endif
-#if defined(CONFIG_TDSC8800)
 #include <linux/mtk23d.h>
-#endif
-#if defined(CONFIG_SMS_SPI_ROCKCHIP)
-#include "../../../drivers/cmmb/siano/smsspiphy.h"
-#endif
-
-
+#include "../../../drivers/tty/serial/sc8800.h"
+#define BP_VOL_PIN			RK30_PIN6_PB2
 #define RK30_FB0_MEM_SIZE 8*SZ_1M
 
 #ifdef CONFIG_VIDEO_RK29
 /*---------------- Camera Sensor Macro Define Begin  ------------------------*/
 /*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
-#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_MT9T111						/* back camera sensor */
-#define CONFIG_SENSOR_IIC_ADDR_0		0x78
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  4
-#define CONFIG_SENSOR_CIF_INDEX_0                    1
-#define CONFIG_SENSOR_ORIENTATION_0 	  90
-#define CONFIG_SENSOR_POWER_PIN_0		  RK30_PIN4_PC6
-#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK30_PIN1_PD6
-#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
+
+//for back wpx2 back camera
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_0 	    0x78
+#define CONFIG_SENSOR_CIF_INDEX_0                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0    3
+#define CONFIG_SENSOR_ORIENTATION_0       90
+#define CONFIG_SENSOR_POWER_PIN_0         RK30_PIN4_PC6
+#define CONFIG_SENSOR_RESET_PIN_0         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0       RK30_PIN4_PB7
+#define CONFIG_SENSOR_FALSH_PIN_0         RK30_PIN4_PD6
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_H
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
 #define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
 #define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_H
 
-#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0      15000
 #define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
-#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0      30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_02		0x00//0x78
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02	  4
+#define CONFIG_SENSOR_CIF_INDEX_02                    1
+#define CONFIG_SENSOR_ORIENTATION_02 	  90
+#define CONFIG_SENSOR_POWER_PIN_02		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02	  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02 	  RK30_PIN1_PD6
+#define CONFIG_SENSOR_FALSH_PIN_02		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02		30000
 
 #define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
 #define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
 #define CONFIG_SENSOR_CIF_INDEX_01                    1
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
 #define CONFIG_SENSOR_ORIENTATION_01       90
-#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWER_PIN_01         RK30_PIN4_PC6
 #define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
 #define CONFIG_SENSOR_POWERDN_PIN_01       RK30_PIN1_PD6
 #define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
-#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_H
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
 #define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
 #define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
@@ -125,37 +134,16 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
 
-#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
-#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
-#define CONFIG_SENSOR_CIF_INDEX_02                    1
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
-#define CONFIG_SENSOR_ORIENTATION_02       90
-#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
-#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_02       RK30_PIN1_PD6
-#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
-#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
-#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
-#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
-#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
 
-#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
-#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
-#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
-#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
-#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
-#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
-#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
-#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
-
-#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_GC0309                      /* front camera sensor 0 */
+//front camera for wxp2
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV7675                      /* front camera sensor 0 */
 #define CONFIG_SENSOR_IIC_ADDR_1 	    0x42
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
-#define CONFIG_SENSOR_CIF_INDEX_1				  0
-#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  4
+#define CONFIG_SENSOR_CIF_INDEX_1				  1
+#define CONFIG_SENSOR_ORIENTATION_1       0//270
 #define CONFIG_SENSOR_POWER_PIN_1         RK30_PIN4_PC6
 #define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK30_PIN1_PB7
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK30_PIN1_PD6
 #define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_H
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
@@ -174,11 +162,11 @@
 #define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
 #define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
-#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_CIF_INDEX_11				  0
 #define CONFIG_SENSOR_ORIENTATION_11       270
 #define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_11       RK30_PIN1_PB7
+#define CONFIG_SENSOR_POWERDN_PIN_11       INVALID_GPIO//RK30_PIN1_PB7
 #define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
@@ -194,14 +182,14 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
 
-#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
-#define CONFIG_SENSOR_IIC_ADDR_12 	    0x00
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2659//RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	   0x00
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
-#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_CIF_INDEX_12				  0
 #define CONFIG_SENSOR_ORIENTATION_12       270
 #define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_12       RK30_PIN1_PB7
+#define CONFIG_SENSOR_POWERDN_PIN_12       INVALID_GPIO//RK30_PIN1_PB7
 #define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
@@ -218,6 +206,7 @@
 #define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
 
 
+
 #endif  //#ifdef CONFIG_VIDEO_RK29
 /*---------------- Camera Sensor Configuration Macro End------------------------*/
 #include "../../../drivers/media/video/rk30_camera.c"
@@ -232,7 +221,7 @@
 #define CONFIG_SENSOR_POWER_IOCTL_USR	   0
 #define CONFIG_SENSOR_RESET_IOCTL_USR	   0
 #define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
-#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   1
 
 #if CONFIG_SENSOR_POWER_IOCTL_USR
 static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
@@ -254,11 +243,47 @@ static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
 	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
 }
 #endif
-
+//hhb@rock-chips.com
 #if CONFIG_SENSOR_FLASH_IOCTL_USR
+//sgm3140 LED driver
+#define CONFIG_SENSOR_FALSH_EN_PIN_0		  RK30_PIN4_PD6    //high:enable
+#define CONFIG_SENSOR_FALSH_MODE_PIN_0		  RK30_PIN0_PD6    //high:FLASH, low:torch
 static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
 {
-	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+	static int init_flag = 0;
+	if(init_flag == 0) {
+		gpio_request(CONFIG_SENSOR_FALSH_MODE_PIN_0, "camera_falsh_mode");
+		rk30_mux_api_set(GPIO0D6_PWM2_NAME, GPIO0D_GPIO0D6);
+		gpio_request(CONFIG_SENSOR_FALSH_EN_PIN_0, "camera_falsh_en");
+		rk30_mux_api_set(GPIO4D6_SMCDATA14_TRACEDATA14_NAME, GPIO4D_GPIO4D6);
+		init_flag = 1;
+	}
+	switch (on) {
+		case Flash_Off: {
+			gpio_direction_output(CONFIG_SENSOR_FALSH_EN_PIN_0, 0);
+			gpio_direction_output(CONFIG_SENSOR_FALSH_MODE_PIN_0, 1);
+			break;
+		}
+
+		case Flash_On: {
+			gpio_direction_output(CONFIG_SENSOR_FALSH_EN_PIN_0, 1);
+			gpio_direction_output(CONFIG_SENSOR_FALSH_MODE_PIN_0, 1);
+			break;
+		}
+
+		case Flash_Torch: {
+			gpio_direction_output(CONFIG_SENSOR_FALSH_EN_PIN_0, 1);
+			gpio_direction_output(CONFIG_SENSOR_FALSH_MODE_PIN_0, 0);
+			break;
+		}
+
+		default: {
+			printk("%s..Flash command(%d) is invalidate \n",__FUNCTION__, on);
+			gpio_direction_output(CONFIG_SENSOR_FALSH_EN_PIN_0, 0);
+			break;
+		}
+	}
+	return 0;
 }
 #endif
 
@@ -308,456 +333,268 @@ static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
        {0x0000, 0x00,0,0}
 };
 #endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
 static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
 {
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
     {
        .rk_sensor_init_width = INVALID_VALUE,
        .rk_sensor_init_height = INVALID_VALUE,
        .rk_sensor_init_bus_param = INVALID_VALUE,
        .rk_sensor_init_pixelcode = INVALID_VALUE,
-       .rk_sensor_init_data = NULL,//rk_init_data_sensor_reg_0,
-       .rk_sensor_init_winseq = NULL,//rk_init_data_sensor_winseqreg_0,
-       .rk_sensor_winseq_size = 0,//sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
-    },{
-        .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
        .rk_sensor_init_height = INVALID_VALUE,
        .rk_sensor_init_bus_param = INVALID_VALUE,
        .rk_sensor_init_pixelcode = INVALID_VALUE,
-       .rk_sensor_init_data = NULL,//rk_init_data_sensor_reg_1,
-       .rk_sensor_init_winseq = NULL,//rk_init_data_sensor_winseqreg_1,
-       .rk_sensor_winseq_size = 0,//sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
-    }
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
 
  };
 #include "../../../drivers/media/video/rk30_camera.c"
 
 #endif /* CONFIG_VIDEO_RK29 */
 
-#if defined(CONFIG_TOUCHSCREEN_ILI2102_IIC) 
-#include "../../../drivers/input/touchscreen/ili2102_ts.h"
-#define TOUCH_GPIO_INT      RK30_PIN4_PC2
-#define TOUCH_GPIO_RESET    RK30_PIN4_PD0
-static struct ili2102_platform_data ili2102_info = {
-	.model			= 2102,
-	.swap_xy		= 0,
-	.x_min			= 0,
-	.x_max			= 480,
-	.y_min			= 0,
-	.y_max			= 800,
-	.gpio_reset     = TOUCH_GPIO_RESET,
-	.gpio_reset_active_low = 1,
-	.gpio_pendown		= TOUCH_GPIO_INT,
-	.pendown_iomux_name = GPIO4C2_SMCDATA2_TRACEDATA2_NAME,
-	.resetpin_iomux_name = GPIO4D0_SMCDATA8_TRACEDATA8_NAME,
-	.pendown_iomux_mode = GPIO4C_GPIO4C2,
-	.resetpin_iomux_mode = GPIO4D_GPIO4D0,
-};
-#endif
-
-
-#if defined(CONFIG_TOUCHSCREEN_GT8XX)
-#define TOUCH_RESET_PIN  RK30_PIN4_PD0
-#define TOUCH_PWR_PIN    INVALID_GPIO
-int goodix_init_platform_hw(void)
-{
-	int ret;
-	
-	rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME, GPIO4D_GPIO4D0);
-	rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME, GPIO4C_GPIO4C2);
-	printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO4D0_SMCDATA8_TRACEDATA8_NAME),rk30_mux_api_get(GPIO4C2_SMCDATA2_TRACEDATA2_NAME));
-
-	if (TOUCH_PWR_PIN != INVALID_GPIO) {
-		ret = gpio_request(TOUCH_PWR_PIN, "goodix power pin");
-		if (ret != 0) {
-			gpio_free(TOUCH_PWR_PIN);
-			printk("goodix power error\n");
-			return -EIO;
-		}
-		gpio_direction_output(TOUCH_PWR_PIN, 0);
-		gpio_set_value(TOUCH_PWR_PIN, GPIO_LOW);
-		msleep(100);
-	}
-
-	if (TOUCH_RESET_PIN != INVALID_GPIO) {
-		ret = gpio_request(TOUCH_RESET_PIN, "goodix reset pin");
-		if (ret != 0) {
-			gpio_free(TOUCH_RESET_PIN);
-			printk("goodix gpio_request error\n");
-			return -EIO;
-		}
-		gpio_direction_output(TOUCH_RESET_PIN, 0);
-		gpio_set_value(TOUCH_RESET_PIN, GPIO_LOW);
-		msleep(10);
-		gpio_set_value(TOUCH_RESET_PIN, GPIO_HIGH);
-		msleep(500);
-	}
-	return 0;
-}
-
-struct goodix_platform_data goodix_info = {
-	.model = 8105,
-	.irq_pin = RK30_PIN4_PC2,
-	.rest_pin = TOUCH_RESET_PIN,
-	.init_platform_hw = goodix_init_platform_hw,
+//hhb@rock-chips.com 2012-04-27
+#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_S3202)
+#include "../../../drivers/input/touchscreen/synaptics_i2c_rmi4.h"
+struct synaptics_rmi4_platform_data synaptics_s3202_info = {
+		.irq_type = IRQF_TRIGGER_FALLING,
+		.virtual_keys = true,
+		.lcd_width = 640,
+		.lcd_height = 960,
+		.h_delta = 40,
+		.w_delta = 0,
+		.x_flip = false,
+		.y_flip = false,
+		.regulator_en = false,
 };
 #endif
 
-#if defined(CONFIG_RK29_SC8800)
-static int sc8800_io_init(void)
-{
-	rk30_mux_api_set(GPIO2B5_LCDC1DATA13_SMCADDR17_HSADCDATA8_NAME, GPIO2B_GPIO2B5);
-	rk30_mux_api_set(GPIO2A2_LCDCDATA2_SMCADDR6_NAME, GPIO2A_GPIO2A2);
-	return 0;
-}
 
-static int sc8800_io_deinit(void)
+#if defined(CONFIG_TOUCHSCREEN_FT5306_WPX2)
+#define TOUCH_RESET_PIN	 RK30_PIN4_PD0  //for_wpx2
+#define TOUCH_INT_PIN 	 RK30_PIN4_PC2
+int ft5306_init_platform_hw(void)
 {
 
-	return 0;
-}
-
-
-static struct plat_sc8800 sc8800_plat_data = {
-	.slav_rts_pin = RK30_PIN6_PA0,
-	.slav_rdy_pin = RK30_PIN2_PB5,
-	.master_rts_pin = RK30_PIN6_PA1,
-	.master_rdy_pin = RK30_PIN2_PA2,
-	//.poll_time = 100,
-	.io_init = sc8800_io_init,
-    .io_deinit = sc8800_io_deinit,
-};
-
-static struct rk29xx_spi_chip sc8800_spi_chip = {
-	//.poll_mode = 1,
-	.enable_dma = 1,
-};
+	    rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME, GPIO4C_GPIO4C2);
+	rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME, GPIO4D_GPIO4D0);
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("ft5406_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
 
-#endif
-#if defined(CONFIG_SMS_SPI_ROCKCHIP)
-#define CMMB_1186_SPIIRQ RK30_PIN4_PB7
-#define CMMB_1186_RESET RK30_PIN0_PD5
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("ift5406_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
 
-void cmmb_io_init_mux(void)
-{
-//	rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,GPIO1A_GPIO1A4);
+	
+	gpio_direction_output(TOUCH_RESET_PIN, 0);
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+	mdelay(10);
+	gpio_direction_input(TOUCH_INT_PIN);
+	mdelay(10);
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+	msleep(300);
+    return 0;
 
 }
-void cmmb_io_set_for_pm(void)
-{
-	printk("entering cmmb_io_set_for_pm\n");
-	rk30_mux_api_set(GPIO0D5_I2S22CHSDO_SMCADDR1_NAME,GPIO0D_GPIO0D5);
-	gpio_request(CMMB_1186_RESET, NULL);//cmmb reset pin
-	gpio_direction_output(CMMB_1186_RESET,0);
-	rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,GPIO1A_GPIO1A4);
-	gpio_request(RK30_PIN1_PA4, NULL);//cmmb cs pin
-	gpio_direction_input(RK30_PIN1_PA4);
-	gpio_pull_updown(RK30_PIN1_PA4, 0);
-}
 
-void cmmb_power_on_by_wm831x(void)
+void ft5306_exit_platform_hw(void)
 {
-	struct regulator *ldo;
-#if 0
-	printk("entering cmmb_power_on_by_wm831x\n");
-
-	rk29_mux_api_set(GPIO1A3_EMMCDETECTN_SPI1CS1_NAME,GPIO1L_SPI0_CSN1);
-	gpio_request(RK29_PIN6_PD2, NULL);
-	gpio_direction_output(RK29_PIN6_PD2,0);
-	mdelay(200);
-
-	ldo = regulator_get(NULL, "ldo8");		//cmmb
-	regulator_set_voltage(ldo,1200000,1200000);
-	regulator_set_suspend_voltage(ldo,1200000);
-	regulator_enable(ldo);
-	printk("%s set ldo8=%dmV end\n", __FUNCTION__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo9");		//cmmb
-	regulator_set_voltage(ldo,3000000,3000000);
-	regulator_set_suspend_voltage(ldo,3000000);
-	regulator_enable(ldo);
-	printk("%s set ldo9=%dmV end\n", __FUNCTION__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-
-	mdelay(200);
-	gpio_direction_output(RK29_PIN6_PD2,1);
-#endif
+	printk("ft5306_exit_platform_hw\n");
+	gpio_free(TOUCH_RESET_PIN);
+	gpio_free(TOUCH_INT_PIN);
 }
 
-void cmmb_power_down_by_wm831x(void)
+int ft5306_platform_sleep(void)
 {
-	struct regulator* ldo;
-#if 0
-	printk("entering cmmb_power_down_by_wm831x\n");
-
-	ldo = regulator_get(NULL, "ldo8");
-	regulator_set_voltage(ldo,0,0);
-	regulator_disable(ldo);
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo9");
-	regulator_set_voltage(ldo,0,0);
-	regulator_disable(ldo);
-	regulator_put(ldo);
-#endif
+	//printk("ft5306_platform_sleep\n");
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+	return 0;
 }
 
-static struct cmmb_io_def_s cmmb_io = {
-	.cmmb_pw_en = INVALID_GPIO,
-	.cmmb_pw_dwn = INVALID_GPIO,
-	.cmmb_pw_rst = CMMB_1186_RESET,
-	.cmmb_irq = CMMB_1186_SPIIRQ,
-	.io_init_mux = cmmb_io_init_mux,
-	.cmmb_io_pm = cmmb_io_set_for_pm,
-	.cmmb_power_on = cmmb_power_on_by_wm831x,
-	.cmmb_power_down = cmmb_power_down_by_wm831x
-};
-
-static struct rk29xx_spi_chip cmb_spi_chip = {
-	//.poll_mode = 1,
-	.enable_dma = 1,
-};
-
-#endif
-
-static struct spi_board_info board_spi_devices[] = {
-#if defined(CONFIG_RK29_SC8800)
-		{
-			.modalias  = "sc8800",
-			.bus_num = 1,
-			.platform_data = &sc8800_plat_data,
-			.max_speed_hz  = 12*1000*1000,
-			.chip_select   = 0,		
-			.controller_data = &sc8800_spi_chip,
-		},
-#endif
-	
-#if defined(CONFIG_SMS_SPI_ROCKCHIP)
-		{
-			.modalias	= "siano1186",
-			.chip_select	= 0,
-			.max_speed_hz	= 12*1000*1000,
-			.bus_num	= 0,
-			.irq		=CMMB_1186_SPIIRQ,
-			.platform_data = &cmmb_io,	
-			.controller_data = &cmb_spi_chip,
-		},
-#endif
-
-};
-/*****************************************************************************************
- * wm8994  codec
- * author: qjb@rock-chips.com
- *****************************************************************************************/
-#if defined(CONFIG_MFD_WM8994)
-static struct regulator_consumer_supply wm8994_fixed_voltage0_supplies[] = {
-	REGULATOR_SUPPLY("DBVDD", "0-001a"),
-	REGULATOR_SUPPLY("AVDD2", "0-001a"),
-	REGULATOR_SUPPLY("CPVDD", "0-001a"),
-};
-
-static struct regulator_consumer_supply wm8994_fixed_voltage1_supplies[] = {
-	REGULATOR_SUPPLY("SPKVDD1", "0-001a"),
-	REGULATOR_SUPPLY("SPKVDD2", "0-001a"),
-};
-
-static struct regulator_init_data wm8994_fixed_voltage0_init_data = {
-	.constraints = {
-		.always_on = 1,
-	},
-	.num_consumer_supplies	= ARRAY_SIZE(wm8994_fixed_voltage0_supplies),
-	.consumer_supplies	= wm8994_fixed_voltage0_supplies,
-};
-
-static struct regulator_init_data wm8994_fixed_voltage1_init_data = {
-	.constraints = {
-		.always_on = 1,
-	},
-	.num_consumer_supplies	= ARRAY_SIZE(wm8994_fixed_voltage1_supplies),
-	.consumer_supplies	= wm8994_fixed_voltage1_supplies,
-};
-
-static struct fixed_voltage_config wm8994_fixed_voltage0_config = {
-	.supply_name	= "VCC_1.8V_PDA",
-	.microvolts	= 1800000,
-	.gpio		= -EINVAL,
-	.init_data	= &wm8994_fixed_voltage0_init_data,
-};
-
-static struct fixed_voltage_config wm8994_fixed_voltage1_config = {
-	.supply_name	= "V_BAT",
-	.microvolts	= 3700000,
-	.gpio		= -EINVAL,
-	.init_data	= &wm8994_fixed_voltage1_init_data,
-};
-
-static struct platform_device wm8994_fixed_voltage0 = {
-	.name		= "reg-fixed-voltage",
-	.id		= 0,
-	.dev		= {
-		.platform_data	= &wm8994_fixed_voltage0_config,
-	},
-};
-
-static struct platform_device wm8994_fixed_voltage1 = {
-	.name		= "reg-fixed-voltage",
-	.id		= 1,
-	.dev		= {
-		.platform_data	= &wm8994_fixed_voltage1_config,
-	},
-};
-
-static struct regulator_consumer_supply wm8994_avdd1_supply =
-	REGULATOR_SUPPLY("AVDD1", "0-001a");
-
-static struct regulator_consumer_supply wm8994_dcvdd_supply =
-	REGULATOR_SUPPLY("DCVDD", "0-001a");
-
-
-
-static struct regulator_init_data wm8994_ldo1_data = {
-	.constraints	= {
-		.name		= "AVDD1_3.0V",
-		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
-	},
-	.num_consumer_supplies	= 1,
-	.consumer_supplies	= &wm8994_avdd1_supply,
-};
-
-static struct regulator_init_data wm8994_ldo2_data = {
-	.constraints	= {
-		.name		= "DCVDD_1.0V",
-	},
-	.num_consumer_supplies	= 1,
-	.consumer_supplies	= &wm8994_dcvdd_supply,
-};
-
-static struct wm8994_pdata wm8994_platform_data = {
-#if defined (CONFIG_GPIO_WM8994)	
-	.gpio_base = WM8994_GPIO_EXPANDER_BASE,
-	//Fill value to initialize the GPIO	
-//	.gpio_defaults ={},
-	/* configure gpio1 function: 0x0001(Logic level input/output) */
-//	.gpio_defaults[0] = 0x0001,
-	/* configure gpio3/4/5/7 function for AIF2 voice */
-	.gpio_defaults[2] = 0x2100,
-	.gpio_defaults[3] = 0x2100,
-	.gpio_defaults[4] = 0xA100,
-//	.gpio_defaults[6] = 0x0100,
-	/* configure gpio8/9/10/11 function for AIF3 BT */
-	.gpio_defaults[7] = 0xA100,
-	.gpio_defaults[8] = 0x2100,
-	.gpio_defaults[9] = 0x2100,
-	.gpio_defaults[10] = 0x2100,	
-#endif		
-
-	.ldo[0]	= { RK30_PIN3_PA6, NULL, &wm8994_ldo1_data,GPIO3A6_SDMMC0RSTNOUT_NAME, GPIO3A_GPIO3A6},	/* XM0FRNB_2 */
-	.ldo[1]	= { 0, NULL, &wm8994_ldo2_data },
-
-	.micdet_irq = 0,
-	.irq_base = 0,
-
-	.lineout1_diff = 1,
-//      .BB_input_diff = 1,
-};
-#endif 
-
-#ifdef CONFIG_RK_HEADSET_DET
-#define HEADSET_GPIO RK29_PIN4_PD2
-struct rk_headset_pdata rk_headset_info = {
-	.Headset_gpio		= RK30_PIN6_PA5,
-	.headset_in_type= HEADSET_IN_HIGH,
-	.Hook_gpio = RK30_PIN1_PB2,//Detection Headset--Must be set
-	.hook_key_code = KEY_MEDIA,
-};
-
-struct platform_device rk_device_headset = {
-		.name	= "rk_headsetdet",
-		.id 	= 0,
-		.dev    = {
-		    .platform_data = &rk_headset_info,
-		}
-};
-#endif
-
-#if CONFIG_RK30_PWM_REGULATOR
-static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
-	{
-		.supply = "vdd_core",
-	}
-};
-
-static struct regulator_consumer_supply pwm_dcdc2_consumers[] = {
-	{
-		.supply = "vdd_cpu",
-	}
-};
-
-struct regulator_init_data pwm_regulator_init_dcdc[2] =
+int ft5306_platform_wakeup(void)
 {
-	{
-		.constraints = {
-			.name = "PWM_DCDC1",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
-		.consumer_supplies = pwm_dcdc1_consumers,
-	},
-	{
-		.constraints = {
-			.name = "PWM_DCDC2",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc2_consumers),
-		.consumer_supplies = pwm_dcdc2_consumers,
-	},
-};
-
-static struct pwm_platform_data pwm_regulator_info[2] = {
-	{
-		.pwm_id = 0,
-		.pwm_gpio = RK30_PIN0_PA3,
-		.pwm_iomux_name = GPIO0A3_PWM0_NAME,
-		.pwm_iomux_pwm = GPIO0A_PWM0,
-		.pwm_iomux_gpio = GPIO0A_GPIO0A3,
-		.pwm_voltage = 1100000,
-		.init_data	= &pwm_regulator_init_dcdc[0],
-	},
-	{
-		.pwm_id = 2,
-		.pwm_gpio = RK30_PIN0_PD6,
-		.pwm_iomux_name = GPIO0D6_PWM2_NAME,
-		.pwm_iomux_pwm = GPIO0D_PWM2,
-		.pwm_iomux_gpio = GPIO0D_GPIO0D6,
-		.pwm_voltage = 1100000,
-		.init_data	= &pwm_regulator_init_dcdc[1],
-	},
-
-};
-
+	//printk("ft5306_platform_wakeup\n");
+	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+	return 0;
+}
 
-struct platform_device pwm_regulator_device[2] = {
-	{
-		.name = "pwm-voltage-regulator",
-		.id = 0,
-		.dev		= {
-			.platform_data = &pwm_regulator_info[0],
-		}
-	},
-	{
-		.name = "pwm-voltage-regulator",
-		.id = 1,
-		.dev		= {
-			.platform_data = &pwm_regulator_info[1],
-		}
-	},
+struct ft5x0x_platform_data ft5306_info = {
 
+  .init_platform_hw= ft5306_init_platform_hw,
+  .exit_platform_hw= ft5306_exit_platform_hw,
+  .ft5x0x_platform_sleep  = ft5306_platform_sleep,
+  .ft5x0x_platform_wakeup = ft5306_platform_wakeup,
 };
 
 
@@ -766,48 +603,39 @@ struct platform_device pwm_regulator_device[2] = {
 /***********************************************************
 *	rk30  backlight
 ************************************************************/
-#ifdef CONFIG_BACKLIGHT_AW9364
-static int aw9364_backlight_io_init(void)
-{
-	rk30_mux_api_set(GPIO4D2_SMCDATA10_TRACEDATA10_NAME, GPIO4D_GPIO4D2);
-	return 0;
-}
-
-static int aw9364_backlight_io_deinit(void)
-{
-	return 0;
-}
-struct aw9364_platform_data aw9364_bl_info = {
-	.pin_en   = RK30_PIN4_PD2,
-	.io_init   = aw9364_backlight_io_init,
-	.io_deinit = aw9364_backlight_io_deinit,
-};
-
-struct platform_device aw9364_device_backlight = {
-	.name = "aw9364_backlight",
-	.id = -1,		
-	.dev		= {
-	.platform_data = &aw9364_bl_info,	
-	}			
-};
-	
-#endif
-
 #ifdef CONFIG_BACKLIGHT_RK29_BL
 #define PWM_ID            0
 #define PWM_MUX_NAME      GPIO0A3_PWM0_NAME
 #define PWM_MUX_MODE      GPIO0A_PWM0
 #define PWM_MUX_MODE_GPIO GPIO0A_GPIO0A3
 #define PWM_GPIO 	  RK30_PIN0_PA3
-#define PWM_EFFECT_VALUE  1
+#define PWM_EFFECT_VALUE  0
 
 #define LCD_DISP_ON_PIN
 
-#ifdef  LCD_DISP_ON_PIN
-//#define BL_EN_MUX_NAME    GPIOF34_UART3_SEL_NAME
-//#define BL_EN_MUX_MODE    IOMUXB_GPIO1_B34
+#define LCD_BL_IO	RK30_PIN4_PD2
+#define LCD_BL_ON	GPIO_HIGH
+#define LCD_BL_OFF	GPIO_LOW
+#define LCD_BL_MUX_NAME    GPIO4D2_SMCDATA10_TRACEDATA10_NAME
+static int wpx_lcd_bl_io_set(int value)
+{
+	int ret = 0;
+	
+	rk30_mux_api_set(LCD_BL_MUX_NAME, GPIO0D_GPIO0D2);
+	ret = gpio_request(LCD_BL_IO, NULL);
+	if(ret < 0)
+		return ret;
+
+	gpio_direction_output(LCD_BL_IO, value);
+	gpio_free(LCD_BL_IO);
+
+	return 0;
+}
 
-#define BL_EN_PIN         RK30_PIN6_PB3
+#ifdef  LCD_DISP_ON_PIN
+#define BL_EN_MUX_NAME    GPIO4D2_SMCDATA10_TRACEDATA10_NAME
+#define BL_EN_MUX_MODE    GPIO4D_GPIO4D2
+#define BL_EN_PIN         RK30_PIN4_PD2
 #define BL_EN_VALUE       GPIO_HIGH
 #endif
 static int rk29_backlight_io_init(void)
@@ -815,15 +643,21 @@ static int rk29_backlight_io_init(void)
 	int ret = 0;
 	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
 #ifdef  LCD_DISP_ON_PIN
-	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
-
+	usleep_range(80*1000, 80*1000);
+#if 0
+	rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
 	ret = gpio_request(BL_EN_PIN, NULL);
 	if (ret != 0) {
 		gpio_free(BL_EN_PIN);
+		printk("%s: gpio: %d request failed\n", __func__, BL_EN_PIN);
+		return ret;
 	}
 
 	gpio_direction_output(BL_EN_PIN, 0);
 	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#else
+	wpx_lcd_bl_io_set(LCD_BL_ON);
+#endif
 #endif
 	return ret;
 }
@@ -832,7 +666,11 @@ static int rk29_backlight_io_deinit(void)
 {
 	int ret = 0;
 #ifdef  LCD_DISP_ON_PIN
+#if 0
 	gpio_free(BL_EN_PIN);
+#else
+	wpx_lcd_bl_io_set(LCD_BL_OFF);
+#endif
 #endif
 	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
 	return ret;
@@ -848,8 +686,12 @@ static int rk29_backlight_pwm_suspend(void)
 	}
 	gpio_direction_output(PWM_GPIO, GPIO_LOW);
 #ifdef  LCD_DISP_ON_PIN
+#if 0
 	gpio_direction_output(BL_EN_PIN, 0);
 	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+#else
+	wpx_lcd_bl_io_set(LCD_BL_OFF);
+#endif
 #endif
 	return ret;
 }
@@ -859,9 +701,13 @@ static int rk29_backlight_pwm_resume(void)
 	gpio_free(PWM_GPIO);
 	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
 #ifdef  LCD_DISP_ON_PIN
-	msleep(30);
+	usleep_range(80*1000, 80*1000);
+#if 0
 	gpio_direction_output(BL_EN_PIN, 1);
 	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#else
+	wpx_lcd_bl_io_set(LCD_BL_ON);
+#endif
 #endif
 	return 0;
 }
@@ -869,22 +715,136 @@ static int rk29_backlight_pwm_resume(void)
 static struct rk29_bl_info rk29_bl_info = {
 	.pwm_id = PWM_ID,
 	.bl_ref = PWM_EFFECT_VALUE,
+        .min_brightness = 26,
 	.io_init = rk29_backlight_io_init,
 	.io_deinit = rk29_backlight_io_deinit,
 	.pwm_suspend = rk29_backlight_pwm_suspend,
 	.pwm_resume = rk29_backlight_pwm_resume,
+	.delay_ms = 1,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_RK29_SUPPORT_MODEM
+
+#define RK30_MODEM_POWER        RK30_PIN4_PD1
+#define RK30_MODEM_POWER_IOMUX  rk29_mux_api_set(GPIO4D1_SMCDATA9_TRACEDATA9_NAME, GPIO4D_GPIO4D1)
+
+static int rk30_modem_io_init(void)
+{
+    printk("%s\n", __FUNCTION__);
+    RK30_MODEM_POWER_IOMUX;
+
+	return 0;
+}
+
+static struct rk29_io_t rk30_modem_io = {
+    .io_addr    = RK30_MODEM_POWER,
+    .enable     = GPIO_HIGH,
+    .disable    = GPIO_LOW,
+    .io_init    = rk30_modem_io_init,
 };
 
-static struct platform_device rk29_device_backlight = {
-	.name	= "rk29_backlight",
-	.id 	= -1,
-	.dev	= {
-		.platform_data  = &rk29_bl_info,
-	}
+static struct platform_device rk30_device_modem = {
+	.name	= "rk30_modem",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk30_modem_io,
+	}
+};
+#endif
+#if defined(CONFIG_RK29_SC8800)
+// tdsc8800
+static int tdsc8800_io_init(void)
+{
+
+	return 0;
+}
+
+static int tdsc8800_io_deinit(void)
+{
+
+	return 0;
+}
+
+struct rk2818_23d_data rk29_tdsc8800_info = {
+	.io_init = tdsc8800_io_init,
+       .io_deinit = tdsc8800_io_deinit,
+	.bp_power = BP_VOL_PIN,
+	.bp_power_active_low = 1,
+};
+struct platform_device rk29_device_tdsc8800 = {
+        .name = "tdsc8800",
+	.id = -1,
+	.dev		= {
+		.platform_data = &rk29_tdsc8800_info,
+	}
+    };
+//sc8800
+static int sc8800_io_init(void)
+{
+	rk30_mux_api_set(GPIO2B5_LCDC1DATA13_SMCADDR17_HSADCDATA8_NAME, GPIO2B_GPIO2B5);
+	rk30_mux_api_set(GPIO2A2_LCDCDATA2_SMCADDR6_NAME, GPIO2A_GPIO2A2);
+
+	rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME, GPIO2C_GPIO2C2);//AP_ASK_BP_TEST1
+	gpio_request(RK30_PIN2_PC2, NULL);
+	gpio_direction_output(RK30_PIN2_PC2, 0);
+	gpio_request(RK30_PIN6_PB0, NULL);//AP_ON/OFF_BP
+	gpio_direction_output(RK30_PIN6_PB0, 0);
+
+
+	rk30_mux_api_set(GPIO2C3_LCDC1DATA19_SPI1CLK_HSADCDATA0_NAME, GPIO2C_SPI1_CLK);//spi 1
+	rk30_mux_api_set(GPIO2C4_LCDC1DATA20_SPI1CSN0_HSADCDATA1_NAME, GPIO2C_SPI1_CSN0);
+	rk30_mux_api_set(GPIO2C5_LCDC1DATA21_SPI1TXD_HSADCDATA2_NAME, GPIO2C_SPI1_TXD);
+	rk30_mux_api_set(GPIO2C6_LCDC1DATA22_SPI1RXD_HSADCDATA3_NAME, GPIO2C_SPI1_RXD);
+	return 0;
+}
+
+static int sc8800_io_deinit(void)
+{
+
+	return 0;
+}
+
+static struct plat_sc8800 sc8800_plat_data = {
+	.slav_rts_pin = RK30_PIN6_PA0,
+	.slav_rdy_pin = RK30_PIN6_PA1,
+	.master_rts_pin = RK30_PIN2_PB5,
+	.master_rdy_pin = RK30_PIN2_PA2,
+	//.poll_time = 100,
+	.io_init = sc8800_io_init,
+    .io_deinit = sc8800_io_deinit,
+};
+static struct rk29xx_spi_chip sc8800_spi_chip = {
+	//.poll_mode = 1,
+	.enable_dma = 1,
+};
+
+#endif
+
+static struct spi_board_info board_spi_devices[] = {
+
+#if defined(CONFIG_RK29_SC8800)
+		{
+			.modalias  = "sc8800",
+			.bus_num = 1,
+			.platform_data = &sc8800_plat_data,
+			.max_speed_hz  = 13*1000*1000,
+			.chip_select   = 0,		
+			.controller_data = &sc8800_spi_chip,
+		},
+#endif
+
 };
 
-#endif
-
 /*MMA8452 gsensor*/
 #if defined (CONFIG_GS_MMA8452)
 #define MMA8452_INT_PIN   RK30_PIN4_PC0
@@ -893,12 +853,6 @@ static int mma8452_init_platform_hw(void)
 {
 	rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
 
-	if (gpio_request(MMA8452_INT_PIN, NULL) != 0) {
-		gpio_free(MMA8452_INT_PIN);
-		printk("mma8452_init_platform_hw gpio_request error\n");
-		return -EIO;
-	}
-	gpio_pull_updown(MMA8452_INT_PIN, 1);
 	return 0;
 }
 
@@ -907,9 +861,63 @@ static struct gsensor_platform_data mma8452_info = {
 	.swap_xy = 0,
 	.swap_xyz = 1,
 	.init_platform_hw = mma8452_init_platform_hw,
-	.orientation = {0, -1, 0, 0, 0, -1, -1, 0, 0},
+	.orientation = {0, 1, 0, 0, 0, -1, 1, 0, 0},
+};
+#endif
+
+#if defined (CONFIG_GS_LIS3DH)
+#define LIS3DH_INT_PIN   RK30_PIN4_PC0
+
+static int lis3dh_init_platform_hw(void)
+{
+	rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
+
+	return 0;
+}
+
+static struct gsensor_platform_data lis3dh_info = {
+	.model = lis3dh,
+	.swap_xy = 0,
+	.swap_xyz = 1,
+	.init_platform_hw = lis3dh_init_platform_hw,
+	.orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
+};
+#endif
+
+
+#if defined (CONFIG_RK_HEADSET_DET) || defined (CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET)
+
+static int rk_headset_io_init(int gpio, char *iomux_name, int iomux_mode)
+{
+	int ret;
+	ret = gpio_request(gpio, NULL);
+	if(ret) 
+		return ret;
+
+	rk30_mux_api_set(iomux_name, iomux_mode);
+	gpio_pull_updown(gpio, PullDisable);
+	gpio_direction_input(gpio);
+	return 0;
+};
+
+struct rk_headset_pdata rk_headset_info = {
+	.Headset_gpio		= RK30_PIN0_PD3,
+	.headset_in_type = HEADSET_IN_HIGH,
+	.Hook_adc_chn = 2,
+	.hook_key_code = KEY_MEDIA,
+	.headset_gpio_info = {GPIO0D3_I2S22CHLRCKTX_SMCADVN_NAME, GPIO0D_GPIO0D3},
+	.headset_io_init = rk_headset_io_init,
+};
+
+struct platform_device rk_device_headset = {
+		.name	= "rk_headsetdet",
+		.id 	= 0,
+		.dev    = {
+		    .platform_data = &rk_headset_info,
+		}
 };
 #endif
+
 #if defined (CONFIG_COMPASS_AK8975)
 static struct akm8975_platform_data akm8975_info =
 {
@@ -917,7 +925,7 @@ static struct akm8975_platform_data akm8975_info =
 	{
 		{
 			{0, 1, 0},
-			{-1, 0, 0},
+			{1, 0, 0},
 			{0, 0, -1},
 		},
 
@@ -943,33 +951,6 @@ static struct akm8975_platform_data akm8975_info =
 
 #endif
 
-/*mpu3050*/
-#if defined (CONFIG_MPU_SENSORS_MPU3050)
-static struct mpu_platform_data mpu3050_data = {
-	.int_config = 0x10,
-	.orientation = { 1, 0, 0,0, 1, 0, 0, 0, 1 },
-};
-#endif
-
-/* accel */
-#if defined (CONFIG_MPU_SENSORS_MMA845X)
-static struct ext_slave_platform_data inv_mpu_mma845x_data = {
-	.bus         = EXT_SLAVE_BUS_SECONDARY,
-	.adapt_num = 0,
-	.orientation = {1, 0, 0, 0, 1, 0, 0, 0, 1},
-};
-#endif
-
-/* compass */
-#if defined (CONFIG_MPU_SENSORS_AK8975)
-static struct ext_slave_platform_data inv_mpu_ak8975_data = {
-	.bus         = EXT_SLAVE_BUS_PRIMARY,
-	.adapt_num = 0,
-	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
-};
-#endif
-
-
 #if defined(CONFIG_GYRO_L3G4200D)
 
 #include <linux/l3g4200d.h>
@@ -977,17 +958,13 @@ static struct ext_slave_platform_data inv_mpu_ak8975_data = {
 
 static int l3g4200d_init_platform_hw(void)
 {
-	if (gpio_request(L3G4200D_INT_PIN, NULL) != 0) {
-		gpio_free(L3G4200D_INT_PIN);
-		printk("%s: request l3g4200d int pin error\n", __func__);
-		return -EIO;
-	}
-	gpio_pull_updown(L3G4200D_INT_PIN, 1);
+	rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME, GPIO4C_GPIO4C3);
+	
 	return 0;
 }
 
 static struct l3g4200d_platform_data l3g4200d_info = {
-	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
+	.orientation = {1, 0, 0, 0, -1, 0, 0, 0, -1},
 	.init = l3g4200d_init_platform_hw,
 	.x_min = 40,//x_min,y_min,z_min = (0-100) according to hardware
 	.y_min = 40,
@@ -996,8 +973,6 @@ static struct l3g4200d_platform_data l3g4200d_info = {
 
 #endif
 
-
-
 #ifdef CONFIG_LS_CM3217
 
 #define CM3217_POWER_PIN 	INVALID_GPIO
@@ -1043,18 +1018,17 @@ static struct cm3217_platform_data cm3217_info = {
 
 /*****************************************************************************************
  * lcd  devices
- * author: zyw@rock-chips.com
+ * author: hhb@rock-chips.com
  *****************************************************************************************/
-//#ifdef  CONFIG_LCD_TD043MGEA1
 
-#define LCD_TXD_PIN		RK30_PIN0_PB7
-#define LCD_CLK_PIN		RK30_PIN0_PB6
-#define LCD_CS_PIN		RK30_PIN0_PB5
+#define LCD_TXD_PIN	      RK30_PIN1_PA6
+#define LCD_CLK_PIN		RK30_PIN1_PA5
+#define LCD_CS_PIN		RK30_PIN1_PA4
 #define LCD_RST_PIN		RK30_PIN4_PC7
 
 /*****************************************************************************************
 * frame buffer  devices
-* author: zyw@rock-chips.com
+* author: hhb@rock-chips.com
 *****************************************************************************************/
 #define FB_ID                       0
 #define FB_DISPLAY_ON_PIN           INVALID_GPIO//RK29_PIN6_PD0
@@ -1070,79 +1044,89 @@ static struct cm3217_platform_data cm3217_info = {
 static int rk29_lcd_io_init(void)
 {
 	int ret = 0;
+
 	//printk("rk29_lcd_io_init\n");
-	//ret = gpio_request(LCD_RXD_PIN, NULL);
+
 	ret = gpio_request(LCD_TXD_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(LCD_TXD_PIN);
+		printk("%s: request LCD_TXD_PIN error\n", __func__);
+		return -EIO;
+	}
+
 	ret = gpio_request(LCD_CLK_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(LCD_CLK_PIN);
+		printk("%s: request LCD_CLK_PIN error\n", __func__);
+		return -EIO;
+	}
+
 	ret = gpio_request(LCD_CS_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(LCD_CS_PIN);
+		printk("%s: request LCD_CS_PIN error\n", __func__);
+		return -EIO;
+	}
 
-	rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME, GPIO0B_GPIO0B7);
-	rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME, GPIO0B_GPIO0B6);
-	rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME, GPIO0B_GPIO0B5);
+	ret = gpio_request(LCD_RST_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(LCD_CS_PIN);
+		printk("%s: request LCD_RST_PIN error\n", __func__);
+		return -EIO;
+	}
+	rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0RXD_NAME,GPIO1A_GPIO1A6);
+	rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME,GPIO1A_GPIO1A5);
+	rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,GPIO1A_GPIO1A4);
 	
+	rk30_mux_api_set(GPIO0C7_TRACECTL_SMCADDR3_NAME,GPIO4C_GPIO4C7);
 
-	gpio_request(LCD_RST_PIN, NULL);
+	gpio_direction_output(LCD_CS_PIN, 1);
+	gpio_direction_output(LCD_CLK_PIN, 1);
+	gpio_direction_output(LCD_TXD_PIN, 1);
 	gpio_direction_output(LCD_RST_PIN, 1);
-	gpio_direction_output(LCD_RST_PIN, 0);
-	usleep_range(5*1000, 5*1000);
-	gpio_set_value(LCD_RST_PIN, 1);
-	usleep_range(50*1000, 50*1000);
-	gpio_free(LCD_RST_PIN);
-
-	return ret;
+	
+    return ret;
 }
 
-#if defined (CONFIG_RK29_WORKING_POWER_MANAGEMENT)
 static int rk29_lcd_io_deinit(void)
 {
-	int ret = 0;
-	
-	gpio_direction_output(LCD_TXD_PIN, 1);
-	gpio_direction_output(LCD_CLK_PIN, 1);
-
-	gpio_free(LCD_CS_PIN);
-	gpio_free(LCD_CLK_PIN);
-	gpio_free(LCD_TXD_PIN);
+    	int ret = 0;
 
-	return ret;
-}
-#else
-static int rk29_lcd_io_deinit(void)
-{
-	int ret = 0;
-	//printk("rk29_lcd_io_deinit\n");
+	gpio_direction_input(LCD_CS_PIN);
+	gpio_direction_input(LCD_CLK_PIN);
+	gpio_direction_input(LCD_TXD_PIN);
+	gpio_direction_input(LCD_RST_PIN);
 	gpio_free(LCD_CS_PIN);
 	gpio_free(LCD_CLK_PIN);
 	gpio_free(LCD_TXD_PIN);
-	//gpio_free(LCD_RXD_PIN);
-
-	//rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME, GPIO0B_GPIO0B7);
-	//rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME, GPIO0B_GPIO0B6);
-	//rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME, GPIO0B_GPIO0B5);
-
-	return ret;
+	gpio_free(LCD_RST_PIN);
+	//rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0RXD_NAME,GPIO1A_GPIO1A6);
+	//rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME,GPIO1A_GPIO1A5);
+	//rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,GPIO1A_GPIO1A4);
+	
+	//rk30_mux_api_set(GPIO0C7_TRACECTL_SMCADDR3_NAME,GPIO4C_GPIO4C7);
+    	return ret;
 }
-#endif
-
 
 static struct rk29lcd_info rk29_lcd_info = {
     .txd_pin  = LCD_TXD_PIN,
     .clk_pin = LCD_CLK_PIN,
     .cs_pin = LCD_CS_PIN,
+    .reset_pin = LCD_RST_PIN,
     .io_init   = rk29_lcd_io_init,
     .io_deinit = rk29_lcd_io_deinit,
 };
 
 
-
-#define LCD_EN_MUX_NAME    GPIO4C7_SMCDATA7_TRACEDATA7_NAME
-#define LCD_EN_PIN         RK30_PIN4_PC7
+#define LCD_EN_MUX_NAME    GPIO4D2_SMCDATA10_TRACEDATA10_NAME    //for wpx2
+#define LCD_EN_PIN         RK30_PIN4_PD2
 #define LCD_EN_VALUE       GPIO_HIGH
 
-static int rk_fb_io_init(void)
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
 {
 	int ret = 0;
-	rk30_mux_api_set(LCD_EN_MUX_NAME, GPIO4C_GPIO4C7);
+#if 0
+	rk30_mux_api_set(LCD_EN_MUX_NAME, GPIO0D_GPIO0D2);
 	ret = gpio_request(LCD_EN_PIN, NULL);
 	if (ret != 0)
 	{
@@ -1155,36 +1139,46 @@ static int rk_fb_io_init(void)
 		gpio_direction_output(LCD_EN_PIN, 1);
 		gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
 	}
+#else
+	//wpx_lcd_bl_io_set(LCD_BL_OFF);
+#endif
 	return 0;
 }
 static int rk_fb_io_disable(void)
 {
-	gpio_set_value(LCD_EN_PIN, ~LCD_EN_VALUE);
+#if 0
+	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE ? 0:1);
+#else
+	//wpx_lcd_bl_io_set(LCD_BL_OFF);
+#endif
 	return 0;
 }
 static int rk_fb_io_enable(void)
 {
+#if 0
 	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+#else
+	//wpx_lcd_bl_io_set(LCD_BL_ON);
+#endif
 	return 0;
 }
 
-
 #if defined(CONFIG_LCDC0_RK30)
 struct rk29fb_info lcdc0_screen_info = {
 	.fb_id   = FB_ID,
-	.prop	   = PRMRY,
-    	.mcu_fmk_pin = FB_MCU_FMK_PIN,
-    	.lcd_info = &rk29_lcd_info,
+	.prop	   = PRMRY,		//primary display device
+	.lcd_info = &rk29_lcd_info,
 	.io_init   = rk_fb_io_init,
 	.io_disable = rk_fb_io_disable,
 	.io_enable = rk_fb_io_enable,
 	.set_screen_info = set_lcd_info,
 };
 #endif
+
 #if defined(CONFIG_LCDC1_RK30)
 struct rk29fb_info lcdc1_screen_info = {
 	#if defined(CONFIG_HDMI_RK30)
-	.prop	   = EXTEND,
+	.prop		= EXTEND,	//extend display device
 	.lcd_info  = NULL,
 	.set_screen_info = hdmi_set_info,
 	#endif
@@ -1219,20 +1213,6 @@ static struct platform_device device_fb = {
 	.resource	= resource_fb,
 };
 #endif
-#ifdef	CONFIG_FB_WIMO
-static struct wimo_platform_data wimo_pdata = {
-        .name           = "wimo",
-};
-
-static struct platform_device wimo_device = {
-        .name           = "wimo",
-        .id                 = -1,
-        .dev            = {
-        .platform_data = &wimo_pdata,
-        },
-};
-#endif
-
 
 #ifdef CONFIG_ANDROID_TIMED_GPIO
 static struct timed_gpio timed_gpios[] = {
@@ -1424,7 +1404,7 @@ struct rk29_sdmmc_platform_data default_sdmmc0_data = {
 #else
 	.use_dma = 0,
 #endif
-	.detect_irq = INVALID_GPIO,	// INVALID_GPIO
+	.detect_irq = INVALID_GPIO, //RK30_PIN3_PB6,	// INVALID_GPIO
 	.enable_sd_wakeup = 0,
 
 #if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
@@ -1510,69 +1490,101 @@ struct rk29_sdmmc_platform_data default_sdmmc1_data = {
 };
 #endif //endif--#ifdef CONFIG_SDMMC1_RK29
 
-/* bluetooth rfkill device */
-static struct platform_device rk29sdk_rfkill = {
-        .name = "rk29sdk_rfkill",
-        .id = -1,
-};
-
 /**************************************************************************************************
  * the end of setting for SDMMC devices
 **************************************************************************************************/
 
-/*************td modem sc8800 power control*************/
-
-#if defined(CONFIG_TDSC8800)
-#define BP_VOL_PIN			RK30_PIN6_PB2
-
-static int tdsc8800_io_init(void)
-{
-	
-	return 0;
-}
+#ifdef CONFIG_BATTERY_RK30_ADC
+static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
+        .dc_det_pin      = RK30_PIN6_PA5,
+        .batt_low_pin    = RK30_PIN6_PA0,
+        .charge_set_pin  = INVALID_GPIO,
+        .charge_ok_pin   = RK30_PIN6_PA6,
+        .dc_det_level    = GPIO_LOW,
+        .charge_ok_level = GPIO_HIGH,
+};
+
+static struct platform_device rk30_device_adc_battery = {
+        .name   = "rk30-battery",
+        .id     = -1,
+        .dev = {
+                .platform_data = &rk30_adc_battery_platdata,
+        },
+};
+#endif
 
-static int tdsc8800_io_deinit(void)
-{
+#ifdef CONFIG_RFKILL_RK
+// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
+static struct rfkill_rk_platform_data rfkill_rk_platdata = {
+    .type               = RFKILL_TYPE_BLUETOOTH,
 
-	return 0;
-}
+    .poweron_gpio       = { // BT_REG_ON
+        .io             = RK30_PIN4_PD5,
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO4D5_SMCDATA13_TRACEDATA13_NAME,
+            .fgpio      = GPIO4D_GPIO4D5,
+        },
+    },
+
+    .reset_gpio         = { // BT_RST
+        .io             = RK30_PIN3_PD1, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name       = GPIO3D1_SDMMC1BACKENDPWR_NAME,
+            .fgpio      = GPIO3D_GPIO3D1,
+        },
+    },
+
+    .wake_gpio          = { // BT_WAKE, use to control bt's sleep and wakeup
+        .io             = RK30_PIN3_PC6, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_HIGH,
+        .iomux          = {
+            .name       = GPIO3C6_SDMMC1DETECTN_NAME,
+            .fgpio      = GPIO3C_GPIO3C6,
+        },
+    },
+
+    .wake_host_irq      = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
+        .gpio           = {
+            .io         = RK30_PIN6_PA5, // set io to INVALID_GPIO for disable it
+            .enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
+            .iomux      = {
+                .name   = NULL,
+            },
+        },
+    },
+
+    .rts_gpio           = { // UART_RTS, enable or disable BT's data coming
+        .io             = RK30_PIN1_PA3, // set io to INVALID_GPIO for disable it
+        .enable         = GPIO_LOW,
+        .iomux          = {
+            .name       = GPIO1A3_UART0RTSN_NAME,
+            .fgpio      = GPIO1A_GPIO1A3,
+            .fmux       = GPIO1A_UART0_RTS_N,
+        },
+    },
+};
 
-struct rk2818_23d_data rk29_tdsc8800_info = {
-	.io_init = tdsc8800_io_init,
-    .io_deinit = tdsc8800_io_deinit,
-	.bp_power = BP_VOL_PIN,
-	.bp_power_active_low = 1,
+static struct platform_device device_rfkill_rk = {
+    .name   = "rfkill_rk",
+    .id     = -1,
+    .dev    = {
+        .platform_data = &rfkill_rk_platdata,
+    },
 };
-struct platform_device rk29_device_tdsc8800 = {
-    .name = "tdsc8800",
-	.id = -1,
-	.dev		= {
-		.platform_data = &rk29_tdsc8800_info,
-	}
-    };
 #endif
 
-
 static struct platform_device *devices[] __initdata = {
-#ifdef CONFIG_RK30_PWM_REGULATOR
-		&pwm_regulator_device[0],
-		&pwm_regulator_device[1],
-#endif
 #ifdef CONFIG_BACKLIGHT_RK29_BL
 	&rk29_device_backlight,
 #endif
-#ifdef CONFIG_BACKLIGHT_AW9364
-	&aw9364_device_backlight,
-#endif
 #ifdef CONFIG_FB_ROCKCHIP
 	&device_fb,
 #endif
 #ifdef CONFIG_ION
 	&device_ion,
 #endif
-#ifdef CONFIG_FB_WIMO
-        &wimo_device,
-#endif
 #ifdef CONFIG_ANDROID_TIMED_GPIO
 	&rk29_device_vibrator,
 #endif
@@ -1585,20 +1597,54 @@ static struct platform_device *devices[] __initdata = {
 #ifdef CONFIG_WIFI_CONTROL_FUNC
 	&rk29sdk_wifi_device,
 #endif
-#ifdef CONFIG_BT
-    &rk29sdk_rfkill,
+#ifdef CONFIG_RFKILL_RK
+	&device_rfkill_rk,
+#endif
+#ifdef CONFIG_RK29_SUPPORT_MODEM
+    &rk30_device_modem,
+#endif
+#if defined(CONFIG_TDSC8800)
+&rk29_device_tdsc8800,
 #endif
-#ifdef CONFIG_MFD_WM8994
-	&wm8994_fixed_voltage0,
-	&wm8994_fixed_voltage1,
-#endif	
-#ifdef CONFIG_RK_HEADSET_DET
+#if defined (CONFIG_RK_HEADSET_DET) ||  defined (CONFIG_RK_HEADSET_IRQ_HOOK_ADC_DET)
     &rk_device_headset,
 #endif
-#ifdef CONFIG_TDSC8800
-	&rk29_device_tdsc8800,
+#ifdef CONFIG_BATTERY_RK30_ADC
+ 	&rk30_device_adc_battery,
 #endif
+};
 
+static struct aic3262_gpio_setup aic3262_gpio[] = {
+	{ // GPIO1
+		.used 		= 0,
+		.in 		= 0,
+		.value 		= AIC3262_GPIO1_FUNC_INT1_OUTPUT ,
+		
+	},
+	{// GPIO2
+		.used 		= 0,
+		.in 		= 0,
+		.value 		= AIC3262_GPIO2_FUNC_CLOCK_OUTPUT,
+	},
+	{// GPI1
+		.used 		= 1,
+		.in   		= 1,
+		.value 		= 0,
+	},
+	{// GPI2
+		.used 		= 1,
+		.in   		= 1,
+		.value 		= AIC3262_GPO1_FUNC_DISABLED,
+	},
+	{// GPO1
+		.used 		= 0,
+		.in 		= 0,
+		.value		= AIC3262_GPO1_FUNC_ADC_MOD_CLK_OUTPUT,
+	},
+};
+static struct aic3262_pdata aic3262_codec_pdata = {
+	.gpio 		= aic3262_gpio,
+	.gpio_reset = RK30_PIN0_PB7,
 };
 
 // i2c
@@ -1607,12 +1653,22 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 #if defined (CONFIG_GS_MMA8452)
 	{
 		.type	        = "gs_mma8452",
-		.addr	        = 0x1c,
+		.addr	        = 0x1d,
 		.flags	        = 0,
 		.irq	        = MMA8452_INT_PIN,
 		.platform_data = &mma8452_info,
 	},
 #endif
+#if defined (CONFIG_GS_LIS3DH)
+	{
+		.type	        = "lis3dh",
+		.addr	        = 0x19,
+		.flags	        = 0,
+		.irq	        = LIS3DH_INT_PIN,
+		.platform_data = &lis3dh_info,
+	},
+#endif
+
 #if defined (CONFIG_COMPASS_AK8975)
 	{
 		.type          = "ak8975",
@@ -1631,34 +1687,14 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 		.platform_data = &l3g4200d_info,
 	},
 #endif
-#if defined (CONFIG_MPU_SENSORS_MPU3050) 
-	{
-		.type			= "mpu3050",
-		.addr			= 0x68,
-		.flags			= 0,
-		.irq			= RK30_PIN4_PC3,
-		.platform_data	= &mpu3050_data,
-	},
-#endif
-#if defined (CONFIG_MPU_SENSORS_MMA845X)
-	{
-		.type    		= "mma845x",
-		.addr           = 0x1c,
-		.flags			= 0,	
-		.irq 			= RK30_PIN4_PC0,
-		.platform_data = &inv_mpu_mma845x_data,
-	},
-#endif
-#if defined (CONFIG_MPU_SENSORS_AK8975)
+#if defined (CONFIG_INPUT_LPSENSOR_AL3006)
 	{
-		.type			= "ak8975",
-		.addr			= 0x0d,
-		.flags			= 0,	
-		.irq 			= RK30_PIN4_PC1,
-		.platform_data = &inv_mpu_ak8975_data,
+		.type           = "al3006",
+		.addr           = 0x1c,             //sel = 0; if sel =1, then addr = 0x1D
+		.flags          = 0,
+		.irq            = RK30_PIN6_PA2,
 	},
 #endif
-
 #if defined (CONFIG_SND_SOC_RK1000)
 	{
 		.type          = "rk1000_i2c_codec",
@@ -1671,6 +1707,16 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 		.flags         = 0,
 	},
 #endif
+
+#if defined (CONFIG_SND_SOC_TLV320AIC326X)
+	{
+		.type    		= "tlv320aic3262",
+		.addr           = 0x18,
+		.flags			= 0,
+		.platform_data = &aic3262_codec_pdata,
+	},
+#endif
+
 #if defined (CONFIG_SND_SOC_RT5631)
         {
                 .type                   = "rt5631",
@@ -1708,60 +1754,53 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 		},
 #endif
 #endif
-#if defined (CONFIG_SND_SOC_WM8994)
-	{
-		.type    		= "wm8994",
-		.addr           = 0x1a,
-		.flags			= 0,
-	#if defined(CONFIG_MFD_WM8994)			
-		.platform_data  = &wm8994_platform_data,	
-	#endif			
-	},
-#endif
 
 };
 #endif
 
 #ifdef CONFIG_I2C1_RK30
-#if 0
-#include "board-rk30-phone-wm831x.c"
-
+#define DC3_VCC_DDR_VOL 1500000   //for vcc_ddr3 1.5v
+#define DC5_VCC_DDR_VOL 0000000	//
+#include "board-rk30-phone-twl60xx.c"
 static struct i2c_board_info __initdata i2c1_info[] = {
-#if defined (CONFIG_MFD_WM831X_I2C)
+
+#if defined (CONFIG_TWL4030_CORE)
 	{
-		.type          = "wm8310",
-		.addr          = 0x34,
-		.flags         = 0,
-		.irq           = RK30_PIN6_PA4,
-		.platform_data = &wm831x_platdata,
+		.type = "twl6032",
+		.addr = 0x48,
+		.flags = 0,
+		.irq            = RK30_PIN6_PA4, 
+		.platform_data = &tps80032_data,
+
 	},
+
 #endif
 };
 #endif
-#endif
 
 #ifdef CONFIG_I2C2_RK30
 static struct i2c_board_info __initdata i2c2_info[] = {
-#if defined (CONFIG_TOUCHSCREEN_ILI2102_IIC)
-	{
-		.type			= "ili2102_ts",
-		.addr			= 0x41,
-		.flags			= I2C_M_NEED_DELAY,
-		.udelay 	 = 100,
-		.irq			= TOUCH_GPIO_INT,
-		.platform_data = &ili2102_info,
-	},	
+
+#if defined (CONFIG_TOUCHSCREEN_SYNAPTICS_S3202)
+{
+	.type           = "synaptics_rmi4_i2c",
+	.addr           = 0x20,  //0x70
+	.flags          = 0,
+	.irq            = RK30_PIN4_PC2,
+	.platform_data = &synaptics_s3202_info,
+},
 #endif
 
-#if defined (CONFIG_TOUCHSCREEN_GT8XX)
-	{
-		.type          = "Goodix-TS",
-		.addr          = 0x55,
-		.flags         = 0,
-		.irq           = RK30_PIN4_PC2,
-		.platform_data = &goodix_info,
-	},
+#if defined (CONFIG_TOUCHSCREEN_FT5306_WPX2)
+{
+	.type           = "ft5x0x_ts",
+	.addr           = 0x38,
+	.flags          = 0,
+	.irq            = RK30_PIN4_PC2,//RK30_PIN2_PC2,
+	.platform_data = &ft5306_info,
+},
 #endif
+
 #if defined (CONFIG_LS_CM3217)
 	{
 		.type          = "lightsensor",
@@ -1775,7 +1814,10 @@ static struct i2c_board_info __initdata i2c2_info[] = {
 #endif
 
 #ifdef CONFIG_I2C3_RK30
+
 static struct i2c_board_info __initdata i2c3_info[] = {
+
+
 };
 #endif
 
@@ -1785,15 +1827,13 @@ static struct i2c_board_info __initdata i2c4_info[] = {
 #endif
 
 #ifdef CONFIG_I2C_GPIO_RK30
-#include "board-rk30-phone-wm831x.c"
-
-#define I2C_SDA_PIN     RK30_PIN2_PD7   //set sda_pin here
-#define I2C_SCL_PIN     RK30_PIN2_PD6   //set scl_pin here
+#define I2C_SDA_PIN     INVALID_GPIO// RK30_PIN2_PD6   //set sda_pin here
+#define I2C_SCL_PIN     INVALID_GPIO//RK30_PIN2_PD7   //set scl_pin here
 static int rk30_i2c_io_init(void)
 {
         //set iomux (gpio) here
-        rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME, GPIO2D_GPIO2D7);
-        rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME, GPIO2D_GPIO2D6);
+        //rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME, GPIO2D_GPIO2D7);
+        //rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME, GPIO2D_GPIO2D6);
 
         return 0;
 }
@@ -1806,19 +1846,9 @@ struct i2c_gpio_platform_data default_i2c_gpio_data = {
        .io_init = rk30_i2c_io_init,
 };
 static struct i2c_board_info __initdata i2c_gpio_info[] = {
-#if defined (CONFIG_MFD_WM831X_I2C)
-		{
-			.type		   = "wm8310",
-			.addr		   = 0x34,
-			.flags		   = 0,
-			.irq		   = RK30_PIN6_PA4,
-			.platform_data = &wm831x_platdata,
-		},
-#endif
 };
 #endif
 
-
 static void __init rk30_i2c_register_board_info(void)
 {
 #ifdef CONFIG_I2C0_RK30
@@ -1839,40 +1869,110 @@ static void __init rk30_i2c_register_board_info(void)
 #ifdef CONFIG_I2C_GPIO_RK30
 	i2c_register_board_info(5, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
 #endif
-
 }
 //end of i2c
 
-#define POWER_ON_PIN RK30_PIN6_PB0   //power_hold
 static void rk30_pm_power_off(void)
 {
 	printk(KERN_ERR "rk30_pm_power_off start...\n");
-	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
-#if defined(CONFIG_MFD_WM831X)
-	wm831x_device_shutdown(Wm831x);//wm8326 shutdown
+#if defined(CONFIG_TWL4030_CORE)
+	twl6030_poweroff();
 #endif
 	while (1);
 }
 
+/**********************************************************************************************
+ *
+ * The virtual keys for android "back", "home", "menu", "search", these four keys are touch key
+ * on the touch screen panel. (added by hhb@rock-chips.com 2011.04.21)
+ * attention please: kobj_attribute.attr.name virtualkeys.synaptics_rmi4_i2c should be the same as
+ * the input device in the touch screen driver.
+ ***********************************************************************************************/
+static ssize_t rk_virtual_keys_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+#if (defined(CONFIG_TOUCHSCREEN_SYNAPTICS_S3202))
+	 printk("rk_virtual_keys_show S3202\n");
+    /* centerx;centery;width;height; */
+	return sprintf(buf,
+		__stringify(EV_KEY) ":" __stringify(KEY_BACK)	     ":100:980:100:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":200:980:100:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_HOMEPAGE)   ":300:980:100:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":400:980:100:40"
+		"\n");
+#elif defined(CONFIG_TOUCHSCREEN_FT5306_WPX2)
+		 printk("rk_virtual_keys_show FT5306\n");
+    /* centerx;centery;width;height; */
+	return sprintf(buf,
+		__stringify(EV_KEY) ":" __stringify(KEY_BACK)	     ":320:840:70:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":190:840:80:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_HOMEPAGE)   ":50:840:100:40"
+		":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":440:840:80:40"
+		"\n");
+#endif
+	return 0;
+}
+
+static struct kobj_attribute rk_virtual_keys_attr = {
+	.attr = {
+#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_S3202)
+		.name = "virtualkeys.synaptics_rmi4_i2c",
+#elif defined(CONFIG_TOUCHSCREEN_FT5306_WPX2) 
+		.name = "virtualkeys.ft5x0x_ts-touchscreen",
+#else
+		.name = "virtualkeys",
+#endif
+		.mode = S_IRUGO,
+	},
+	.show = &rk_virtual_keys_show,
+};
+
+static struct attribute *rk_properties_attrs[] = {
+	&rk_virtual_keys_attr.attr,
+	NULL
+};
+
+static struct attribute_group rk_properties_attr_group = {
+	.attrs = rk_properties_attrs,
+};
+static int rk_virtual_keys_init(void)
+{
+	int ret;
+	struct kobject *properties_kobj;
+	printk("rk_virtual_keys_init \n");
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				&rk_properties_attr_group);
+	if (!properties_kobj || ret)
+	{
+		printk("failed to create board_properties for virtual key\n");
+	}
+	return ret;
+}
+
+/*************************end of virtual_keys************************/
+
+
+
+
 static void __init machine_rk30_board_init(void)
 {
-	gpio_request(POWER_ON_PIN, "poweronpin");
-	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
-	
 	pm_power_off = rk30_pm_power_off;
 	
 	rk30_i2c_register_board_info();
 	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 	board_usb_detect_init(RK30_PIN6_PA3);
-	
-#if defined (CONFIG_MPU_SENSORS_MPU3050)
-	rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME, GPIO4C_GPIO4C3);
-#endif
 
 #ifdef CONFIG_WIFI_CONTROL_FUNC
 	rk29sdk_wifi_bt_gpio_control_init();
 #endif
+
+#if (defined(CONFIG_TOUCHSCREEN_SYNAPTICS_S3202)) || defined(CONFIG_TOUCHSCREEN_FT5306_WPX2)
+	rk_virtual_keys_init();
+#endif
+
 }
 
 static void __init rk30_reserve(void)
@@ -1902,15 +2002,26 @@ static void __init rk30_reserve(void)
  * comments	: min arm/logic voltage
  */
 static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
-	//{.frequency = 252 * 1000,	.cpu_volt = 1050 * 1000,	.logic_volt = 1050 * 1000},//0.975V/1.000V
-	//{.frequency = 504 * 1000,	.cpu_volt = 1050 * 1000,	.logic_volt = 1050 * 1000},//0.975V/1.000V
-	{.frequency = 816 * 1000,	.cpu_volt = 1100 * 1000,	.logic_volt = 1100 * 1000},
-	{.frequency = 1008 * 1000,	.cpu_volt = 1150 * 1000,	.logic_volt = 1100 * 1000},
-	{.frequency = 1200 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1100 * 1000},
-	//{.frequency = 1272 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1150 * 1000},//1.150V/1.100V
-	//{.frequency = 1416 * 1000,	.cpu_volt = 1275 * 1000,	.logic_volt = 1150 * 1000},//1.225V/1.100V
-	//{.frequency = 1512 * 1000,	.cpu_volt = 1325 * 1000,	.logic_volt = 1200 * 1000},//1.300V/1.150V
-	//{.frequency = 1608 * 1000,	.cpu_volt = 1350 * 1000,	.logic_volt = 1200 * 1000},//1.325V/1.175V
+	{.frequency = 252 * 1000,	.cpu_volt = 1050 * 1000,	.logic_volt = 1050 * 1000},//0.975V/1.000V
+	{.frequency = 504 * 1000,	.cpu_volt = 1050 * 1000,	.logic_volt = 1100 * 1000},//0.975V/1.000V
+	{.frequency = 816 * 1000,	.cpu_volt = 1100 * 1000,	.logic_volt = 1150 * 1000},//1.000V/1.025V
+	{.frequency = 1008 * 1000,	.cpu_volt = 1100 * 1000,	.logic_volt = 1150 * 1000},//1.025V/1.050V
+	{.frequency = 1200 * 1000,	.cpu_volt = 1175 * 1000,	.logic_volt = 1200 * 1000},//1.100V/1.050V
+	{.frequency = 1272 * 1000,	.cpu_volt = 1225 * 1000,	.logic_volt = 1200 * 1000},//1.150V/1.100V
+	{.frequency = 1416 * 1000,	.cpu_volt = 1300 * 1000,	.logic_volt = 1200 * 1000},//1.225V/1.100V
+	{.frequency = 1512 * 1000,	.cpu_volt = 1350 * 1000,	.logic_volt = 1250 * 1000},//1.300V/1.150V
+	{.frequency = 1608 * 1000,	.cpu_volt = 1375 * 1000,	.logic_volt = 1275 * 1000},//1.325V/1.175V
+	{.frequency = CPUFREQ_TABLE_END},
+};
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{.frequency = 266 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1275 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 300 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1125 * 1000},
 	{.frequency = CPUFREQ_TABLE_END},
 };
 
@@ -1922,6 +2033,8 @@ void __init board_clock_init(void)
 {
 	rk30_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
 	dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
 }
 
 MACHINE_START(RK30, "RK30board")
diff --git a/arch/arm/mach-rk30/include/mach/board.h b/arch/arm/mach-rk30/include/mach/board.h
index f481fc608d66..e19392b4cc76 100755
--- a/arch/arm/mach-rk30/include/mach/board.h
+++ b/arch/arm/mach-rk30/include/mach/board.h
@@ -63,6 +63,17 @@ struct ft5x0x_platform_data{
 };
 #endif
 
+#if defined (CONFIG_TOUCHSCREEN_FT5306_WPX2)
+struct ft5x0x_platform_data{
+          u16     model;
+    int     (*get_pendown_state)(void);
+    int     (*init_platform_hw)(void);
+    int     (*ft5x0x_platform_sleep)(void);
+    int     (*ft5x0x_platform_wakeup)(void);
+    void    (*exit_platform_hw)(void);
+};
+#endif
+
 extern struct rk29_sdmmc_platform_data default_sdmmc0_data;
 extern struct rk29_sdmmc_platform_data default_sdmmc1_data;
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 7ada5dedf5f5..1aafaaf4469e 100755
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -999,6 +999,10 @@ config TOUCHSCREEN_FT5306
 	tristate "FT5306 based touchscreens: FT5306 Interface"
 	depends on I2C2_RK29 || I2C2_RK30
 
+config TOUCHSCREEN_FT5306_WPX2
+        tristate "FT5306 based touchscreens: FT5306 Interface,only used for umeox wpx2 board"
+        depends on I2C2_RK29 || I2C2_RK30
+
 config TOUCHSCREEN_FT5406
 	tristate "FT5406 based touchscreens: FT5406 Interface"
 	depends on I2C2_RK29
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index c6d1f6811931..61ccb8719731 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_D70_L3188A)		+= goodix_touch.o
 obj-$(CONFIG_TOUCHSCREEN_GT8XX)                += rk29_i2c_goodix.o
 obj-$(CONFIG_TOUCHSCREEN_FT5406)	+= ft5406_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FT5306)	+= ft5306_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5306_WPX2)        += ft5306_ts_wpx2.o
 obj-$(CONFIG_TOUCHSCREEN_GT819)		+= gt819.o
 obj-$(CONFIG_TOUCHSCREEN_NAS)		+= nas_ts.o
 obj-$(CONFIG_LAIBAO_TS)		+= ft5x0x_i2c_ts.o
diff --git a/drivers/input/touchscreen/ft5306_ts_wpx2.c b/drivers/input/touchscreen/ft5306_ts_wpx2.c
new file mode 100755
index 000000000000..28ed8ed1728a
--- /dev/null
+++ b/drivers/input/touchscreen/ft5306_ts_wpx2.c
@@ -0,0 +1,723 @@
+/* 
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/input-polldev.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#ifdef CONFIG_ANDROID_POWER
+#include <linux/android_power.h>
+#endif
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+#include <mach/irqs.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/sram.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/input/mt.h>
+
+
+#if 0
+#define fts_dbg(dev, format, arg...)		\
+	dev_printk(KERN_INFO , dev , format , ## arg)
+#else
+#define fts_dbg(dev, format, arg...)
+#endif
+
+#define FTS_NAME		"ft5x0x_ts"
+#define FTS_I2C_RATE		(400*1000)
+#define MAX_POINT		5
+#define SCREEN_MAX_Y		800
+#define SCREEN_MAX_X		480
+#define PRESS_MAX		255
+
+#define FTS_REPORT_RATE		0x0c //0x06 // report_rate = (FTS_REPORT_RATE)*(10Hz)
+#define FTS_VALID_THRES		0x0a // valid_tresshold = 0x0a * 4
+
+#define FTS_REG_THRES		0x80         /* Thresshold, the threshold be low, the sensitivy will be high */
+#define FTS_REG_REPORT_RATE	0x88         /* **************report rate, in unit of 10Hz **************/
+#define FTS_REG_PMODE		0xA5         /* Power Consume Mode 0 -- active, 1 -- monitor, 3 -- sleep */    
+#define FS_REG_FIRMID		0xA6         /* ***************firmware version **********************/
+#define FS_REG_NOISE_MODE	0xb2         /* to enable or disable power noise, 1 -- enable, 0 -- disable */
+
+//FT5X0X_REG_PMODE
+enum {
+	FTS_PMODE_ACTIVE  = 0x00,
+	FTS_PMODE_MONITOR,
+	FTS_PMODE_STANDBY,
+	FTS_PMODE_HIBERNATE,
+};
+
+struct fts_event{
+	u16 x;
+	u16 y;
+	u16 pressure;
+	s16 id;
+	u8 flag;
+};
+struct fts_data {
+	int irq;
+	u8 touch_point;
+	u16 down_count[MAX_POINT];
+	u8 flags[MAX_POINT];
+        struct workqueue_struct *freezable_work; 
+        struct delayed_work work;
+
+	struct i2c_client *client;
+	struct device *dev;
+	struct input_dev *input_dev;
+	int (*platform_sleep)(void);
+    	int (*platform_wakeup)(void);
+	int (*platform_init_hw)(void);
+    	void (*platform_deinit_hw)(void);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend suspend;
+#endif
+};
+
+static int fts_i2c_read(struct fts_data *ts, const char reg, char *buf, int len)
+{
+	int ret = 0;
+
+	ret = i2c_master_reg8_recv(ts->client, reg, buf, len, FTS_I2C_RATE);
+
+	if(ret < 0)
+		fts_dbg(ts->dev, "%s error, reg: 0x%x\n", __func__, reg);
+
+	ret = (ret < 0)?ret:0;
+
+	return ret;
+}
+static int fts_i2c_write(struct fts_data *ts, const char reg, const char *buf, int len)
+{
+	int ret  = 0;
+
+	ret = i2c_master_reg8_send(ts->client, reg, buf, len , FTS_I2C_RATE);
+	
+	if(ret < 0)
+		fts_dbg(ts->dev, "%s error, reg: 0x%x\n", __func__, reg);
+
+	ret = (ret < 0)?ret:0;
+
+	return ret;
+}
+#define    FTS_PACKET_LENGTH        128
+static u8 CTPM_FW[]=
+{
+#include "ft_app_5306.i"
+};
+
+typedef enum
+{
+	ERR_OK,
+	ERR_MODE,
+	ERR_READID,
+	ERR_ERASE,
+	ERR_STATUS,
+	ERR_ECC,
+	ERR_DL_ERASE_FAIL,
+	ERR_DL_PROGRAM_FAIL,
+	ERR_DL_VERIFY_FAIL,
+	ERR_RESET_FM
+}E_UPGRADE_ERR_TYPE;
+
+static int fts_ctpm_read(struct fts_data *ts, char *buf, int len)
+{
+	int ret  = 0;
+
+	ret = i2c_master_normal_recv(ts->client,  buf, len , FTS_I2C_RATE);
+	
+	if(ret < 0)
+		fts_dbg(ts->dev, "%s error\n", __func__);
+
+	ret = (ret < 0)?ret:0;
+
+	return ret;
+}
+static int fts_ctpm_write(struct fts_data *ts, char *buf, int len)
+{
+	int ret  = 0;
+
+	ret = i2c_master_normal_send(ts->client,  buf, len , FTS_I2C_RATE);
+	
+	if(ret < 0)
+		fts_dbg(ts->dev, "%s error\n", __func__);
+
+	ret = (ret < 0)?ret:0;
+
+	return ret;
+}
+
+E_UPGRADE_ERR_TYPE  fts_ctpm_fw_upgrade(struct fts_data *ts, u8* pbt_buf, int dw_lenth)
+{
+	char val[4];
+	int retry = 10, ret = 0, tmp;
+	int  i, j, i_is_new_protocol = 0, packet_number;
+	u8  packet_buf[FTS_PACKET_LENGTH + 6];
+	u8  bt_ecc = 0;
+
+	val[0] = 0xaa;
+	fts_i2c_write(ts, 0xfc, val, 1);
+	mdelay(50);
+	val[0] = 0x55;
+	fts_i2c_write(ts, 0xfc, val, 1);
+	fts_dbg(ts->dev, "[TSP] Step 1: Reset CTPM\n");
+	mdelay(10);
+	fts_dbg(ts->dev, "[TSP] Step 2:enter new update mode\n");
+
+	val[0] = 0x55;
+	val[1] = 0xaa;
+	do{
+		ret = fts_ctpm_write(ts, val, 2);
+	}while(retry-- && (ret < 0));
+
+	if (retry > 0)
+        	i_is_new_protocol = 1;
+
+	val[0] = 0x90;
+	val[1] = 0x00;
+	val[2] = 0x00;
+	val[3] = 0x00;
+	fts_ctpm_write(ts, val, 4);
+
+	fts_ctpm_read(ts, val, 2);
+	fts_dbg(ts->dev, "[TSP] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",val[0],val[1]);
+	if(val[0] != 0x79 || val[1] != 0x03)
+		return -ERR_READID;
+	
+	if(i_is_new_protocol)
+		val[0] = 0x61;
+	else
+		val[0] = 0x60;
+	
+	val[1] = 0x00;
+	val[2] = 0x00;
+	val[3] = 0x00;
+	fts_ctpm_write(ts, val, 1);
+
+	mdelay(1500);
+	fts_dbg(ts->dev,"[TSP] Step 4: erase. \n");
+
+	dw_lenth = dw_lenth - 8;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	fts_dbg(ts->dev,"[TSP] Step 5: start upgrade, packet_number = %d\n", packet_number);
+
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for(i = 0; i < packet_number; i++){
+		tmp = i * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8)(tmp >> 8);
+		packet_buf[3] = (u8)tmp ;
+		tmp = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8)(tmp >> 8);
+		packet_buf[5] = (u8)(tmp);
+
+		for(j = 0; j < FTS_PACKET_LENGTH; j++){
+			packet_buf[6+j] = pbt_buf[i*FTS_PACKET_LENGTH + j];
+			bt_ecc ^= packet_buf[6+j];
+		}
+		fts_ctpm_write(ts, packet_buf, FTS_PACKET_LENGTH + 6);
+		mdelay(FTS_PACKET_LENGTH/6 + 1);
+
+		if ((i * FTS_PACKET_LENGTH % 1024) == 0)
+        	{
+              		fts_dbg(ts->dev, "[TSP] upgrade the 0x%x th byte.\n", ((unsigned int)i) * FTS_PACKET_LENGTH);
+        	}
+	}
+	
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0)
+	{
+		tmp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8)(tmp>>8);
+		packet_buf[3] = (u8)tmp;
+		
+		tmp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8)(tmp>>8);
+		packet_buf[5] = (u8)tmp;
+
+		for (i=0;i<tmp; i++)
+		{
+			packet_buf[6+i] = pbt_buf[packet_number*FTS_PACKET_LENGTH + i]; 
+			bt_ecc ^= packet_buf[6+i];
+		}
+
+		fts_ctpm_write(ts, packet_buf, tmp + 6);    
+		mdelay(20);
+	}
+
+	for (i = 0; i<6; i++)
+	{
+		tmp = 0x6ffa + i;
+		packet_buf[2] = (u8)(tmp>>8);
+		packet_buf[3] = (u8)tmp;
+        	packet_buf[4] = (u8)(1>>8);
+        	packet_buf[5] = (u8)1;
+        	packet_buf[6] = pbt_buf[dw_lenth + i]; 
+        	bt_ecc ^= packet_buf[6];
+
+        	fts_ctpm_write(ts, packet_buf,7);  
+        	mdelay(20);
+    	}
+
+	val[0] = 0xcc;
+	val[1] = 0x00;
+	val[2] = 0x00;
+	val[3] = 0x00;
+	fts_ctpm_write(ts, val, 1);
+
+	fts_ctpm_read(ts, val, 1);
+	fts_dbg(ts->dev,"[TSP] Step 6:  ecc read 0x%x, new firmware 0x%x. \n", val[0], bt_ecc);
+
+	if(val[0] != bt_ecc)
+		return -ERR_ECC;
+
+	val[0] = 0x07;
+	val[1] = 0x00;
+	val[2] = 0x00;
+	val[3] = 0x00;
+	fts_ctpm_write(ts, val, 1);
+	
+	mdelay(100);//100ms
+	fts_dbg(ts->dev, "[TSP] Step 1: Reset new FM\n");
+	fts_i2c_read(ts, 0xfc, val, 1);
+	if(val[0] == 0x01){
+		val[0] = 0x04;
+		fts_i2c_write(ts, 0xfc, val, 1);
+		mdelay(2500);//2500ms
+		do{
+			fts_i2c_read(ts, 0xfc, val, 1);
+			mdelay(100);//100ms
+		}while(retry-- && val[0] != 1);
+
+		if(retry <= 0)
+			return -ERR_RESET_FM;
+	}
+	
+	fts_dbg(ts->dev, "[TSP] %s ok\n", __func__);	
+	return ERR_OK;
+}
+int fts_ctpm_fw_upgrade_with_i_file(struct fts_data *ts)
+{
+	u8* pbt_buf = 0;
+	int ret;
+    
+	pbt_buf = CTPM_FW;
+	ret =  fts_ctpm_fw_upgrade(ts, pbt_buf, sizeof(CTPM_FW));
+   
+	return ret;
+}
+unsigned char fts_ctpm_get_upg_ver(void)
+{
+	unsigned int ui_sz;
+	
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 2)
+	{
+		return CTPM_FW[ui_sz - 2];
+	}
+	else
+		return 0xff; 
+ 
+}
+static int fts_update_config(struct fts_data *ts)
+{
+	char old_ver, new_ver;
+	int ret = 0;
+
+	ret = fts_i2c_read(ts, FS_REG_FIRMID, &old_ver, 1);
+	if(ret < 0){
+		dev_err(ts->dev, "%s: i2c read version error\n", __func__);
+		return ret;
+	}
+
+	if(fts_ctpm_get_upg_ver() != old_ver){
+		msleep(200);
+		ret =  fts_ctpm_fw_upgrade_with_i_file(ts);
+		if(ret < 0){
+			dev_err(ts->dev, "%s: failed to ugrade\n", __func__);
+			return ret;
+		}
+		msleep(200);
+		fts_i2c_read(ts, FS_REG_FIRMID, &new_ver, 1);
+		dev_info(ts->dev, "Update from old version[0x%2x] to new version[0x%2x]\n", old_ver, new_ver);
+		msleep(4000);
+	}
+	return 0;
+}
+
+static void fts_work(struct work_struct *work)
+{
+        int ret = 0;
+        char buf[2];
+        struct fts_data *ts = container_of(work, struct fts_data, work.work); 
+
+	buf[0] = FTS_REPORT_RATE;
+	ret = fts_i2c_write(ts, FTS_REG_REPORT_RATE, &buf[0], 1);
+	if(ret == 0)
+		ret = fts_i2c_read(ts, FTS_REG_REPORT_RATE, &buf[0], 1);
+	if(ret < 0){
+		dev_err(ts->dev, "%s: i2c(r/w) error, reg: 0x%x\n", __func__, FTS_REG_REPORT_RATE);
+                goto again;
+	}
+	
+	buf[1] = FTS_VALID_THRES;
+	ret = fts_i2c_write(ts, FTS_REG_THRES, &buf[1], 1);
+	if(ret == 0)
+		ret = fts_i2c_read(ts, FTS_REG_THRES, &buf[1], 1);
+	if(ret < 0){
+		dev_err(ts->dev, "%s: i2c(r/w), reg: 0x%x\n", __func__, FTS_REG_THRES);
+                goto again;
+	}
+        if(buf[0] == FTS_REPORT_RATE && buf[1] == FTS_VALID_THRES){
+                dev_info(ts->dev, "%s: report rate: %dHz, valide thres: %d\n", __func__, buf[0]*10, buf[1]*4);
+                return;
+        }
+
+again:
+        queue_delayed_work(ts->freezable_work, &ts->work, msecs_to_jiffies(1000));
+        return;
+
+}
+
+static void fts_report_value(struct fts_data *ts)
+{
+	char buf[6*MAX_POINT+1], reg;
+	struct fts_event events[MAX_POINT], ev;
+	int ret = 0, i, off;
+
+	reg = 0x00;
+	ret = fts_i2c_read(ts, reg, buf, 6*MAX_POINT+1);
+
+	if (ret < 0) {
+		dev_err(ts->dev, "fts_i2c_write error:%d!\n",ret);
+		return;
+	}
+	memset(events, 0, sizeof(struct fts_event) * MAX_POINT);
+	ts->touch_point = buf[2]&0x07;
+
+	if(ts->touch_point == 0){
+		for(i = 0; i < MAX_POINT; i++){
+			if(ts->flags[i] != 0){
+				fts_dbg(ts->dev, "Point UP: id: %d, down_count: %d\n",i, ts->down_count[i]);
+				ts->flags[i] = 0;
+				ts->down_count[i] = 0;
+				input_mt_slot(ts->input_dev, i);
+				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+			}
+		}
+		input_sync(ts->input_dev);
+		return;
+	}
+
+	for(i = 0; i < ts->touch_point; i++){
+		off = i*6+3;
+		ev.id = (s16)(buf[off+2] & 0xF0)>>4;
+		if(unlikely((ev.id >= MAX_POINT) || (ev.id < 0))){
+			dev_err(ts->dev, "read touch_id[%d] error\n", ev.id);
+			return;
+		}
+		ev.x = ((buf[off+0] & 0x0F)<<8) | buf[off+1];
+		ev.y = ((buf[off+2] & 0x0F)<<8) | buf[off+3];
+		if(unlikely(ev.x > SCREEN_MAX_X || ev.y > (SCREEN_MAX_Y + 60))){
+			dev_err(ts->dev, "read pos[x:%d, y:%d] error\n", ev.x, ev.y);
+			continue;
+		}
+		ev.flag = (buf[off+0] & 0xc0) >> 6;
+		if(ev.flag){
+			events[ev.id].x = ev.x;
+			events[ev.id].y = ev.y;
+			events[ev.id].flag = ev.flag;
+			events[ev.id].pressure = 200;
+		}
+		fts_dbg(ts->dev, "get event: id: %d, x: %d, y: %d, flag:%d\n",ev.id, ev.x, ev.y, ev.flag);
+	}
+	for(i = 0; i < MAX_POINT; i++){
+		if((events[i].flag == 0) && (ts->flags[i] != 0)){
+			fts_dbg(ts->dev, "Point UP: id: %d, x: %d, y: %d, down_count: %d\n",
+				i, events[i].x, events[i].y, ts->down_count[i]);
+			ts->down_count[i] = 0;
+			input_mt_slot(ts->input_dev, i);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+		}else if(events[i].flag != 0){
+			fts_dbg(ts->dev, "Point DOWN: id: %d, x: %d, y: %d\n",i, events[i].x, events[i].y);
+			ts->down_count[i]++;
+			input_mt_slot(ts->input_dev, i);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+			//input_report_abs(data->input_dev, ABS_MT_PRESSURE, event.pressure);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X,  events[i].x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y,  events[i].y);
+		}
+		ts->flags[i] = events[i].flag;
+	}
+	input_sync(ts->input_dev);
+	return;
+}
+
+static irqreturn_t fts_interrupt(int irq, void *dev_id)
+{
+	struct fts_data *ts = dev_id;
+	
+	disable_irq_nosync(ts->irq);
+	fts_report_value(ts);
+	enable_irq(ts->irq);
+	return IRQ_HANDLED;
+}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void fts_early_suspend(struct early_suspend *h)
+{
+	struct fts_data *ts = container_of(h, struct fts_data, suspend);
+
+	char buf = FTS_PMODE_HIBERNATE;
+	int ret = 0;
+	
+	disable_irq(ts->irq);
+	cancel_delayed_work(&ts->work);
+	ret = fts_i2c_write(ts, FTS_REG_PMODE, &buf, 1);
+
+	if(ret < 0)
+		dev_err(ts->dev, "%s: i2c_write error, reg = 0x%x\n", __func__, FTS_REG_PMODE);
+	if(ts->platform_sleep)
+		ts->platform_sleep();
+	return;
+}
+void fts_early_resume(struct early_suspend *h)
+{
+	struct fts_data *ts = container_of(h, struct fts_data, suspend);
+	if(ts->platform_wakeup)
+		ts->platform_wakeup();
+
+        queue_delayed_work(ts->freezable_work, &ts->work, msecs_to_jiffies(1000));
+	
+	enable_irq(ts->irq);
+	return;
+}
+#endif
+static struct i2c_device_id fts_idtable[] = {
+	{ FTS_NAME, 0 },
+	{ }
+};
+
+static int  fts_probe(struct i2c_client *client ,const struct i2c_device_id *id)
+{
+	struct fts_data *ts;
+	struct ft5x0x_platform_data *pdata = client->dev.platform_data;
+
+	char buf[2];
+	int retrys = 5, ret = 0;
+
+	if (!pdata) {
+		dev_err(&client->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		return -ENODEV;
+	}
+	
+	if(!client->irq){
+		dev_err(&client->dev, "no irq.\n");
+		return -ENODEV;
+	}
+	
+	ts = kzalloc(sizeof(struct fts_data), GFP_KERNEL);	
+	if (!ts){
+		dev_err(&client->dev, "No memory for fts\n");
+		return -ENOMEM;
+	}
+	ts->client = client;
+	ts->dev = &client->dev;
+	ts->irq = gpio_to_irq(client->irq);
+	ts->platform_wakeup = pdata->ft5x0x_platform_wakeup;
+	ts->platform_sleep = pdata->ft5x0x_platform_sleep;
+	ts->platform_init_hw = pdata->init_platform_hw;
+	ts->platform_deinit_hw = pdata->exit_platform_hw;
+
+	i2c_set_clientdata(client, ts);
+
+	if (pdata->init_platform_hw)                              
+		pdata->init_platform_hw();
+
+	buf[0] = FTS_PMODE_MONITOR;
+	while(retrys--){
+		ret = fts_i2c_write(ts, FTS_REG_PMODE, buf, 1);
+		if(ret == 0)
+			break;
+	}
+	
+	if(ret < 0){
+		dev_err(ts->dev, "fts_i2c_write error, reg: 0x%x\n", FTS_REG_PMODE);
+		goto err_i2c_write;
+	}
+	
+	ts->input_dev = input_allocate_device();
+	if (!ts->input_dev) {
+		ret = -ENOMEM;
+		dev_err(ts->dev, "failed to allocate input device\n");
+		goto err_input_allocate_device;
+	}
+
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);	
+
+	input_mt_init_slots(ts->input_dev, MAX_POINT);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);	
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+
+	ts->input_dev->name = "ft5x0x_ts-touchscreen";		//dev_name(&client->dev)
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(ts->dev,"failed to register input device: \n");
+		goto err_input_register_device;
+	}
+
+	ret = fts_update_config(ts);
+	if(ret < 0){
+		dev_err(ts->dev, "failed to fts_update_config\n");
+		goto err_fts_update_config;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->suspend.suspend =fts_early_suspend;
+	ts->suspend.resume =fts_early_resume;
+	ts->suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;;
+	register_early_suspend(&ts->suspend);
+#endif
+
+        ts->freezable_work = system_freezable_wq;
+        INIT_DELAYED_WORK(&ts->work, fts_work);
+
+	buf[0] = FTS_REPORT_RATE;
+	ret = fts_i2c_write(ts, FTS_REG_REPORT_RATE, &buf[0], 1);
+	if(ret == 0)
+		ret = fts_i2c_read(ts, FTS_REG_REPORT_RATE, &buf[0], 1);
+	if(ret < 0){
+		dev_err(&client->dev, "fts_i2c_read error, reg: 0x%x\n", FTS_REG_REPORT_RATE);
+		goto err_request_irq;
+	}
+	
+	buf[1] = FTS_VALID_THRES;
+	ret = fts_i2c_write(ts, FTS_REG_THRES, &buf[1], 1);
+	if(ret == 0)
+		ret = fts_i2c_read(ts, FTS_REG_THRES, &buf[1], 1);
+	if(ret < 0){
+		dev_err(&client->dev, "fts_i2c_read error, reg: 0x%x\n", FTS_REG_THRES);
+		goto err_request_irq;
+	}
+	ret = request_threaded_irq(ts->irq, NULL, fts_interrupt, IRQF_TRIGGER_FALLING, client->dev.driver->name, ts);
+	if (ret < 0) {
+		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
+		goto err_request_irq;
+	}
+	
+	dev_info(ts->dev, "%s ok, i2c addr: 0x%x, report rate: %dHz, active thres: %d\n", 
+		__func__, ts->client->addr, buf[0]*10, buf[1]*4);
+	
+	return 0;
+	
+err_request_irq:
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->suspend);
+#endif 	
+err_fts_update_config:	
+	input_unregister_device(ts->input_dev);
+err_input_register_device:
+	input_free_device(ts->input_dev);
+err_input_allocate_device:
+err_i2c_write:
+	i2c_set_clientdata(client, NULL);
+	kfree(ts);
+	if (pdata->exit_platform_hw)                              
+		pdata->exit_platform_hw();
+	return ret;
+	
+}
+static int __devexit fts_remove(struct i2c_client *client)
+{
+	struct fts_data *ts = i2c_get_clientdata(client);
+
+	free_irq(ts->irq,ts);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->suspend);
+#endif 
+	input_unregister_device(ts->input_dev);
+	input_free_device(ts->input_dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(ts);
+	if(ts->platform_deinit_hw)
+		ts->platform_deinit_hw();
+	return 0;
+}
+MODULE_DEVICE_TABLE(i2c, fts_idtable);
+
+static struct i2c_driver fts_driver  = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= FTS_NAME
+	},
+	.id_table	= fts_idtable,
+	.probe		= fts_probe,
+	.remove 	= __devexit_p(fts_remove),
+};
+
+static int __init fts_ts_init(void)
+{
+	return i2c_add_driver(&fts_driver);
+}
+
+static void __exit fts_ts_exit(void)
+{
+	i2c_del_driver(&fts_driver);
+}
+
+module_init(fts_ts_init);
+module_exit(fts_ts_exit);
+
+MODULE_AUTHOR("<kfx@rock-chips.com>");
+MODULE_DESCRIPTION("FocalTech ft5x0x TouchScreen driver");
+
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index 9abe7feb8bb1..fb50de1744c4 100644
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -31,6 +31,8 @@ config LCD_LS035Y8DX02A
 	  bool "RGB LS035Y8DX02A(480X800)"
 config LCD_LS035Y8DX04A
 	  bool "RGB LS035Y8DX04A(480X800)"
+config LCD_HSD100PXN_FOR_TDW851
+	  bool "RGB Hannstar HSD100PXN(800X480)"	
 config LCD_CPTCLAA038LA31XE
 	  bool "RGB LCD_CPTCLAA038LA31XE(480X800)"	  
 config LCD_A060SE02
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index 06e7ed17ba58..4a1bc783ec06 100644
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -39,3 +39,4 @@ obj-$(CONFIG_LCD_AT070TN93)    += lcd_at070tn93.o
 obj-$(CONFIG_LCD_A050VL01)    += lcd_A050VL01.o
 obj-$(CONFIG_LCD_B101EW05)    += lcd_b101ew05.o
 obj-$(CONFIG_LCD_HJ050NA_06A)    += lcd_hj050na_06a.o
+obj-$(CONFIG_LCD_HSD100PXN_FOR_TDW851) += lcd_hsd100pxn_for_tdw851.o
diff --git a/drivers/video/display/screen/lcd_hsd100pxn_for_tdw851.c b/drivers/video/display/screen/lcd_hsd100pxn_for_tdw851.c
new file mode 100644
index 000000000000..c69d1b3d3e6b
--- /dev/null
+++ b/drivers/video/display/screen/lcd_hsd100pxn_for_tdw851.c
@@ -0,0 +1,323 @@
+/* This Lcd Driver is HSD070IDW1 write by cst 2009.10.27 */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888//OUT_D888_P666        //OUT_D888_P565
+#define OUT_CLK			 24000000
+#define LCDC_ACLK       456000000       //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			10
+#define H_BP			10
+#define H_VD			480
+#define H_FP			12
+
+#define V_PW			4
+#define V_BP			4
+#define V_VD			800
+#define V_FP			8
+
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			0
+
+#define LCD_WIDTH       68//800    //need modify
+#define LCD_HEIGHT      112//480
+
+static struct rk29lcd_info *gLcd_info = NULL;
+
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
+#define RST_PORT        gLcd_info->reset_pin
+
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 1)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 1)   
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+
+#define RST_OUT()       gpio_direction_output(RST_PORT, 1)   
+#define RST_SET()       gpio_set_value(RST_PORT, GPIO_HIGH)
+#define RST_CLR()       gpio_set_value(RST_PORT, GPIO_LOW)
+
+#define UDELAY_TIME     1
+#define MDELAY_TIME     120
+void Spi_Write_index(unsigned char index)
+{
+	int  j;
+	CS_CLR();
+	TXD_CLR();	//0
+	udelay(UDELAY_TIME);
+	  	
+	CLK_CLR();
+	udelay(3);//
+        
+	CLK_SET();        
+	udelay(UDELAY_TIME);
+
+	TXD_CLR();
+	CLK_CLR();
+		
+	for(j=0;j<8;j++)
+	{
+		if(index&0x80)
+		{
+			TXD_SET();	
+		}
+		else
+		{
+			TXD_CLR();
+		}
+		index<<=1;	
+			
+		CLK_CLR();     
+		udelay(UDELAY_TIME);
+		CLK_SET();
+		udelay(UDELAY_TIME);	
+	}
+	CS_SET();	
+}
+
+void Spi_Write_data(unsigned char data)
+{
+	int j;
+	CS_CLR();
+	TXD_SET();	
+	udelay(UDELAY_TIME);
+	  	
+	CLK_CLR();
+	udelay(3);
+        
+	CLK_SET();
+	udelay(UDELAY_TIME);
+		
+	TXD_CLR();
+	CLK_CLR();
+		
+	for(j=0;j<8;j++)
+	{
+		if(data&0x80)
+		{
+			TXD_SET();	
+		}
+		else
+		{
+			TXD_CLR();
+		}
+		data<<=1;	
+			
+		CLK_CLR();     
+		udelay(UDELAY_TIME);
+		CLK_SET();
+		udelay(UDELAY_TIME);	
+	}
+	CS_SET();
+}
+
+void  Lcd_WriteSpi_initial3(void)	//HX8363A+IVO 20111128 canshu
+{
+	//FOR IVO5.2 + HX8363-A
+	//Set_EXTC
+	printk("Lcd_WriteSpi_initial3-------------\n");
+	Spi_Write_index(0xB9);
+	Spi_Write_data(0xFF);
+	Spi_Write_data(0x83);
+	Spi_Write_data(0x63);
+
+	//Set_VCOM
+	Spi_Write_index(0xB6);
+	Spi_Write_data(0x27);//09
+
+
+	//Set_POWER
+	Spi_Write_index(0xB1);
+	Spi_Write_data(0x81);
+	Spi_Write_data(0x30);
+	Spi_Write_data(0x07);//04
+	Spi_Write_data(0x33);
+	Spi_Write_data(0x02);
+	Spi_Write_data(0x13);
+	Spi_Write_data(0x11);
+	Spi_Write_data(0x00);
+	Spi_Write_data(0x24);
+	Spi_Write_data(0x2B);
+	Spi_Write_data(0x3F);
+	Spi_Write_data(0x3F);
+
+	Spi_Write_index(0xBf);   //
+	Spi_Write_data(0x00); 
+	Spi_Write_data(0x10); 
+
+	//Sleep Out
+	Spi_Write_index(0x11);
+	mdelay(MDELAY_TIME);
+
+
+	//Set COLMOD
+	Spi_Write_index(0x3A);
+	Spi_Write_data(0x70);
+
+
+	//Set_RGBIF
+	Spi_Write_index(0xB3);
+	Spi_Write_data(0x01);
+
+
+	//Set_CYC
+	Spi_Write_index(0xB4);
+	Spi_Write_data(0x08);
+	Spi_Write_data(0x16);
+	Spi_Write_data(0x5C);
+	Spi_Write_data(0x0B);
+	Spi_Write_data(0x01);
+	Spi_Write_data(0x1E);
+	Spi_Write_data(0x7B);
+	Spi_Write_data(0x01);
+	Spi_Write_data(0x4D);
+
+	//Set_PANEL
+	Spi_Write_index(0xCC);
+	//Spi_Write_data(0x01);
+	Spi_Write_data(0x09);
+	mdelay(5);
+
+
+	//Set Gamma 2.2
+	Spi_Write_index(0xE0);
+	Spi_Write_data(0x00);
+	Spi_Write_data(0x1E);
+	Spi_Write_data(0x63);
+	Spi_Write_data(0x15);
+	Spi_Write_data(0x11);
+	Spi_Write_data(0x30);
+	Spi_Write_data(0x0C);
+	Spi_Write_data(0x8F);
+	Spi_Write_data(0x8F);
+	Spi_Write_data(0x15);
+	Spi_Write_data(0x17);
+	Spi_Write_data(0xD5);
+	Spi_Write_data(0x56);
+	Spi_Write_data(0x0e);
+	Spi_Write_data(0x15);
+	Spi_Write_data(0x00);
+	Spi_Write_data(0x1E);
+	Spi_Write_data(0x63);
+	Spi_Write_data(0x15);
+	Spi_Write_data(0x11);
+	Spi_Write_data(0x30);
+	Spi_Write_data(0x0C);
+	Spi_Write_data(0x8F);
+	Spi_Write_data(0x8F);
+	Spi_Write_data(0x15);
+	Spi_Write_data(0x17);
+	Spi_Write_data(0xD5);
+	Spi_Write_data(0x56);
+	Spi_Write_data(0x0e);
+	Spi_Write_data(0x15);
+	mdelay(5);
+	
+	//Display On
+	Spi_Write_index(0x29);
+	Spi_Write_index(0x2c);
+}
+
+
+static int init(void)
+{
+	if(gLcd_info)
+		gLcd_info->io_init();
+
+	TXD_OUT();
+	CLK_OUT();
+	CS_OUT();
+
+	RST_CLR();
+	CS_SET();
+	CLK_SET();
+
+	mdelay(5);
+	RST_SET();
+	mdelay(2);
+
+	Lcd_WriteSpi_initial3();
+
+	return 0;
+}
+static int deinit(void)
+{
+	Spi_Write_index(0x10);
+	if(gLcd_info)
+		gLcd_info->io_deinit();
+        return 0;
+
+}
+static int standby(u8 enable)
+{
+        if(!enable)
+                init();
+        else
+                deinit();
+        return 0;
+}
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+	/* screen type & face */
+	printk("%s\n",__func__);
+	screen->type		= OUT_TYPE;
+	screen->face	= OUT_FACE;
+
+	/* Screen size */
+	screen->x_res	= H_VD;
+	screen->y_res	= V_VD;
+
+	screen->width	= LCD_WIDTH;
+	screen->height	= LCD_HEIGHT;
+
+	/* Timing */
+	screen->lcdc_aclk	= LCDC_ACLK;
+	screen->pixclock	= OUT_CLK;
+	screen->left_margin	= H_BP;
+	screen->right_margin= H_FP;
+	screen->hsync_len	= H_PW;
+	screen->upper_margin= V_BP;
+	screen->lower_margin= V_FP;
+	screen->vsync_len	= V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync	= 0;
+	screen->pin_vsync	= 0;
+	screen->pin_den		= 0;
+	screen->pin_dclk	= DCLK_POL;
+
+	/* Swap rule */
+	screen->swap_rb		= SWAP_RB;
+	screen->swap_rg		= 0;
+	screen->swap_gb		= 0;
+	screen->swap_delta	= 0;
+	screen->swap_dumy	= 0;
+
+	/* Operation function*/
+	/*screen->init = init;*/
+	screen->init	= init;
+	screen->standby	= standby;
+	if(lcd_info)
+	gLcd_info = lcd_info;
+}
+
+
-- 
2.35.3

