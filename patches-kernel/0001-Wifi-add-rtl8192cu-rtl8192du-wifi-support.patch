From 837937e8d5be8a5b7f90ad0e1086347206b5a726 Mon Sep 17 00:00:00 2001
From: gwl <gwl@rock-chips.com>
Date: Tue, 16 Sep 2014 17:06:34 +0800
Subject: [PATCH] Wifi: add rtl8192cu & rtl8192du wifi support.

---
 drivers/net/wireless/Kconfig                  |    5 +-
 .../rtl8192cu/core/rtw_ieee80211.c            |    4 +-
 .../rtl8192cu/os_dep/linux/usb_intf.c         |   34 +-
 .../wireless/rockchip_wlan/rtl8192du/Kconfig  |    0
 .../wireless/rockchip_wlan/rtl8192du/Makefile |   86 +-
 .../rockchip_wlan/rtl8192du/core/rtw_ap.c     |   36 +-
 .../rockchip_wlan/rtl8192du/core/rtw_cmd.c    |   49 +-
 .../rockchip_wlan/rtl8192du/core/rtw_debug.c  | 1129 ++++------
 .../rtl8192du/core/rtw_ieee80211.c            |   68 +
 .../rtl8192du/core/rtw_ioctl_set.c            |    9 +-
 .../rockchip_wlan/rtl8192du/core/rtw_mlme.c   |  818 ++++---
 .../rtl8192du/core/rtw_mlme_ext.c             |  215 +-
 .../rockchip_wlan/rtl8192du/core/rtw_mp.c     |   15 +-
 .../rockchip_wlan/rtl8192du/core/rtw_p2p.c    |   53 +-
 .../rtl8192du/core/rtw_pwrctrl.c              |   22 +-
 .../rockchip_wlan/rtl8192du/core/rtw_recv.c   |   38 +-
 .../rtl8192du/core/rtw_wlan_util.c            |   36 +-
 .../rockchip_wlan/rtl8192du/core/rtw_xmit.c   |   30 +-
 .../rtl8192du/hal/OUTSRC/odm_RegDefine11AC.h  |   70 +
 .../rtl8192du/hal/OUTSRC/odm_RegDefine11N.h   |  178 ++
 .../rtl8192du/hal/OUTSRC/odm_debug.h          |  893 ++++++++
 .../wireless/rockchip_wlan/rtl8192du/hal/dm.c | 1145 ++++++++--
 .../wireless/rockchip_wlan/rtl8192du/hal/dm.h |   75 +-
 .../rockchip_wlan/rtl8192du/hal/hal_com.c     |  173 ++
 .../rockchip_wlan/rtl8192du/hal/hal_intf.c    |    3 +
 .../rtl8192du/hal/rtl8192d/rtl8192d_cmd.c     |  154 +-
 .../rtl8192du/hal/rtl8192d/rtl8192d_dm.c      |   90 +-
 .../hal/rtl8192d/rtl8192d_hal_init.c          |   67 +-
 .../rtl8192du/hal/rtl8192d/rtl8192d_mp.c      |  223 +-
 .../rtl8192du/hal/rtl8192d/rtl8192d_phycfg.c  |  234 +-
 .../hal/rtl8192d/usb/rtl8192du_led.c          |  172 +-
 .../hal/rtl8192d/usb/rtl8192du_xmit.c         |   48 +-
 .../rtl8192du/hal/rtl8192d/usb/usb_halinit.c  |  152 +-
 .../hal/rtl8192d/usb/usb_ops_linux.c          |   14 +-
 .../rtl8192du/include/Hal8192CPhyReg.h        |    1 +
 .../rtl8192du/include/Hal8192DPhyCfg.h        |    2 +-
 .../rtl8192du/include/Hal8192DPhyReg.h        |    1 +
 .../rtl8192du/include/autoconf.h              |    9 +-
 .../rtl8192du/include/drv_types.h             |   30 +-
 .../rockchip_wlan/rtl8192du/include/hal_com.h |    5 +
 .../rtl8192du/include/hal_intf.h              |    2 +
 .../rtl8192du/include/ieee80211.h             |    4 +
 .../rtl8192du/include/ioctl_cfg80211.h        |   10 +-
 .../rtl8192du/include/osdep_intf.h            |   11 +-
 .../rtl8192du/include/osdep_service.h         |    8 +-
 .../rtl8192du/include/rtl8192c_dm.h           |   15 -
 .../rtl8192du/include/rtl8192c_hal.h          |   13 +-
 .../rtl8192du/include/rtl8192d_dm.h           |   15 -
 .../rtl8192du/include/rtl8192d_hal.h          |   15 +-
 .../rtl8192du/include/rtl8192d_recv.h         |    4 +
 .../rtl8192du/include/rtl8192d_spec.h         |    9 +
 .../rtl8192du/include/rtl8192d_xmit.h         |    4 +
 .../rtl8192du/include/rtw_android.h           |    1 +
 .../rockchip_wlan/rtl8192du/include/rtw_ap.h  |    2 +
 .../rtl8192du/include/rtw_debug.h             |  575 ++---
 .../rtl8192du/include/rtw_efuse.h             |   19 +
 .../rtl8192du/include/rtw_mlme.h              |   73 +-
 .../rtl8192du/include/rtw_mlme_ext.h          |   16 +-
 .../rockchip_wlan/rtl8192du/include/rtw_mp.h  |   55 +-
 .../rtl8192du/include/rtw_mp_phy_regdef.h     |    1 +
 .../rtl8192du/include/rtw_pwrctrl.h           |    6 +-
 .../rtl8192du/include/rtw_version.h           |    2 +-
 .../rtl8192du/include/rtw_wifi_regd.h         |   28 +
 .../rtl8192du/include/rtw_xmit.h              |    8 +
 .../rockchip_wlan/rtl8192du/include/wifi.h    |   18 +
 .../rtl8192du/os_dep/linux/ioctl_cfg80211.c   |  446 ++--
 .../rtl8192du/os_dep/linux/ioctl_linux.c      | 1962 ++++++++++++-----
 .../rtl8192du/os_dep/linux/mlme_linux.c       |    2 +-
 .../rtl8192du/os_dep/linux/os_intfs.c         |  598 +----
 .../rtl8192du/os_dep/linux/pci_intf.c         |   41 +-
 .../rtl8192du/os_dep/linux/recv_linux.c       |    9 +-
 .../rtl8192du/os_dep/linux/rtw_android.c      |   16 +-
 .../rtl8192du/os_dep/linux/rtw_proc.c         |  735 ++++++
 .../rtl8192du/os_dep/linux/rtw_proc.h         |   52 +
 .../rtl8192du/os_dep/linux/usb_intf.c         |  136 +-
 .../rtl8192du/os_dep/linux/usb_ops_linux.c    |   10 +-
 .../rtl8192du/os_dep/linux/wifi_regd.c        |  547 +++++
 .../rtl8192du/os_dep/linux/wifi_version.h     |    2 +-
 .../rtl8192du/os_dep/linux/xmit_linux.c       |   11 +-
 .../rtl8192du/os_dep/osdep_service.c          |  142 +-
 80 files changed, 8426 insertions(+), 3583 deletions(-)
 mode change 100755 => 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig
 mode change 100755 => 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/Makefile
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11AC.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11N.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_debug.h
 mode change 100755 => 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/include/autoconf.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_wifi_regd.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_regd.c

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 09504235e6a7..0f832982cb06 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -40,11 +40,10 @@ choice
 
 source "drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8189es/Kconfig"
-#source "drivers/net/wireless/rockchip_wlan/rtl8192cu/Kconfig"
-#source "drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig"
+source "drivers/net/wireless/rockchip_wlan/rtl8192cu/Kconfig"
+source "drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8723au/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8723bu/Kconfig"
-#source "drivers/net/wireless/rockchip_wlan/rtl8723as/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8723bs/Kconfig"
 endchoice
 endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192cu/core/rtw_ieee80211.c b/drivers/net/wireless/rockchip_wlan/rtl8192cu/core/rtw_ieee80211.c
index 514a227a4039..a1c5cba18ee6 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8192cu/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192cu/core/rtw_ieee80211.c
@@ -1215,7 +1215,7 @@ u8 convert_ip_addr(u8 hch, u8 mch, u8 lch)
 }
 
 extern char* rtw_initmac;
-extern int rk29sdk_wifi_mac_addr(unsigned char *buf);
+#include <linux/rfkill-wlan.h>
 
 void rtw_macaddr_cfg(u8 *mac_addr)
 {
@@ -1238,7 +1238,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
     {
         printk("Wifi Efuse Mac => %02x:%02x:%02x:%02x:%02x:%02x\n", mac_addr[0], mac_addr[1],
             mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
-        if (!rk29sdk_wifi_mac_addr(macbuf)) {
+        if (!rockchip_wifi_mac_addr(macbuf)) {
             int jj,kk;
             printk("=========> get mac address from flash %s\n", macbuf);
             for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192cu/os_dep/linux/usb_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8192cu/os_dep/linux/usb_intf.c
index e0209ab3d807..d498a7580e69 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8192cu/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192cu/os_dep/linux/usb_intf.c
@@ -1616,49 +1616,33 @@ static void rtw_drv_halt(void)
 }
 
 #include "wifi_version.h"
-extern int wifi_activate_usb(void);
-extern int wifi_deactivate_usb(void);
+#include <linux/rfkill-wlan.h>
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-static int __init rockchip_wifi_init_module(void)
-#else
-int rockchip_wifi_init_module(void)
-#endif
+int rockchip_wifi_init_module_rtkwifi(void)
 {
     printk("\n");
     printk("=======================================================\n");
     printk("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
     printk("=======================================================\n");
-    printk("Realtek 8188CU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
-    wifi_deactivate_usb();
-    msleep(100);
-    wifi_activate_usb();
+    printk("Realtek 8192CU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
+    rockchip_wifi_power(1);
 
     return rtw_drv_entry();
 }
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-static void __exit rockchip_wifi_exit_module(void)
-#else
-void rockchip_wifi_exit_module(void)
-#endif
+void rockchip_wifi_exit_module_rtkwifi(void)
 {
     printk("\n");
     printk("=======================================================\n");
     printk("==== Dislaunching Wi-Fi driver! (Powered by Rockchip) ====\n");
     printk("=======================================================\n");
-    printk("Realtek 8188CU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
+    printk("Realtek 8192CU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
     rtw_drv_halt();
-    wifi_deactivate_usb();
+    rockchip_wifi_power(0);
 }
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-late_initcall(rockchip_wifi_init_module);
-module_exit(rockchip_wifi_exit_module);
-#else
-EXPORT_SYMBOL(rockchip_wifi_init_module);
-EXPORT_SYMBOL(rockchip_wifi_exit_module);
-#endif
+EXPORT_SYMBOL(rockchip_wifi_init_module_rtkwifi);
+EXPORT_SYMBOL(rockchip_wifi_exit_module_rtkwifi);
 //module_init(rtw_drv_entry);
 //module_exit(rtw_drv_halt);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig b/drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8192du/Makefile
old mode 100755
new mode 100644
index 9d96cd0ce4be..550699a2c197
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/Makefile
@@ -1,5 +1,5 @@
 EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-EXTRA_CFLAGS += -O1
+EXTRA_CFLAGS += -O1 -Wframe-larger-than=1200
 #EXTRA_CFLAGS += -O3
 #EXTRA_CFLAGS += -Wall
 #EXTRA_CFLAGS += -Wextra
@@ -18,6 +18,8 @@ EXTRA_CFLAGS += -Wno-uninitialized
 
 EXTRA_CFLAGS += -I$(src)/include
 
+EXTRA_LDFLAGS += --strip-debug
+
 CONFIG_AUTOCFG_CP = n
 
 CONFIG_RTL8192C = n
@@ -37,6 +39,7 @@ CONFIG_BT_COEXISTENCE = n
 CONFIG_RTL8192CU_REDEFINE_1X1 = n
 CONFIG_INTEL_WIDI = n
 CONFIG_WAKE_ON_WLAN = n
+CONFIG_ODM_ADAPTIVITY = n
 
 CONFIG_PLATFORM_I386_PC = n
 CONFIG_PLATFORM_TI_AM3517 = n
@@ -71,6 +74,7 @@ CONFIG_PLATFORM_MSTAR_A3 = n
 CONFIG_PLATFORM_MSTAR = n
 CONFIG_PLATFORM_ARM_SUNxI = n
 CONFIG_PLATFORM_ARM_SUN6I = n
+CONFIG_PLATFORM_ARM_RTD299X = n
 
 CONFIG_DRVEXT_MODULE = n
 
@@ -168,7 +172,9 @@ _OS_INTFS_FILES :=	os_dep/osdep_service.o \
 			os_dep/linux/mlme_linux.o \
 			os_dep/linux/recv_linux.o \
 			os_dep/linux/ioctl_cfg80211.o \
-			os_dep/linux/rtw_android.o
+			os_dep/linux/wifi_regd.o \
+			os_dep/linux/rtw_android.o \
+			os_dep/linux/rtw_proc.o
 
 
 _HAL_INTFS_FILES :=	hal/hal_intf.o \
@@ -237,6 +243,10 @@ ifeq ($(CONFIG_INTEL_WIDI), y)
 EXTRA_CFLAGS += -DCONFIG_INTEL_WIDI
 endif
 
+ifeq ($(CONFIG_ODM_ADAPTIVITY), y)
+EXTRA_CFLAGS += -DCONFIG_ODM_ADAPTIVITY
+endif
+
 ifeq ($(CONFIG_PLATFORM_I386_PC), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
@@ -274,7 +284,7 @@ endif
 
 
 ifeq ($(CONFIG_PLATFORM_MSTAR), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR 		#-DCONFIG_PLATFORM_MSTAR_SCAN_BEFORE_CONNECT
 ARCH:=arm
 CROSS_COMPILE:= /usr/src/bin/arm-none-linux-gnueabi-
 KVER:= 3.1.10
@@ -481,8 +491,8 @@ endif
 ifeq ($(CONFIG_PLATFORM_ARM_RK2818), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS -DCONFIG_MINIMAL_MEMORY_USAGE
 ARCH := arm
-#CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
-#KSRC := /usr/src/release_fae_version/kernel25_A7_281x
+CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
+KSRC := /usr/src/release_fae_version/kernel25_A7_281x
 MODULE_NAME := 8192du
 endif
 
@@ -536,6 +546,72 @@ KVER  := 3.3.0
 #KSRC:= ../lichee/linux-3.3/
 endif
 
+ifeq ($(CONFIG_PLATFORM_ARM_SUN7I), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN7I
+EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
+# default setting for Android 4.1, 4.2
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS -DCONFIG_QOS_OPTIMIZATION
+
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
+ifeq ($(CONFIG_USB_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
+_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
+endif
+
+ARCH := arm
+# ===Cross compile setting for Android 4.2 SDK ===
+#CROSS_COMPILE :=/home/android_sdk/Allwinner/a20_evb/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+#KVER  := 3.3.0
+#KSRC := /home/android_sdk/Allwinner/a20_evb/lichee/linux-3.3
+
+# ==== Cross compile setting for Android 4.3 SDK =====
+#CROSS_COMPILE := /home/android_sdk/Allwinner/a20/android-jb43/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+#KVER  := 3.4.39
+#KSRC :=/home/android_sdk/Allwinner/a20/android-jb43/lichee/linux-3.4
+
+# ==== Cross compile setting for Android 4.4 SDK =====
+CROSS_COMPILE := /home/android_sdk/Allwinner/a20/android-kitkat44/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+KVER  := 3.4.39
+KSRC :=/home/android_sdk/Allwinner/a20/android-kitkat44/lichee/linux-3.4
+
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_SUN8I), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN8I
+EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
+# default setting for Android 4.1, 4.2
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS
+
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
+ifeq ($(CONFIG_USB_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
+_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
+endif
+
+ARCH := arm
+CROSS_COMPILE := /home/android_sdk/Allwinner/a23/android-jb42/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+KVER  := 3.4.39
+KSRC :=/home/android_sdk/Allwinner/a23/android-jb42/lichee/linux-3.4
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_RTD299X), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+EXTRA_CFLAGS += -DUSB_XMITBUF_ALIGN_SZ=1024
+EXTRA_CFLAGS += -DUSB_PACKET_OFFSET_SZ=0
+#ARCH, CROSS_COMPILE, KSRC,and  MODDESTDIR are provided by external makefile
+ARCH := arm
+CROSS_COMPILE :=
+KSRC:=
+KVER := 3.7.2
+INSTALL_PREFIX :=
+endif
+
 ifneq ($(USER_MODULE_NAME),)
 MODULE_NAME := $(USER_MODULE_NAME)
 endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ap.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ap.c
index 02ba84a2570f..7bb1a894182b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ap.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ap.c
@@ -195,14 +195,6 @@ static void update_BCNTIM(_adapter *padapter)
 		pnetwork_mlmeext->IELength = offset + remainder_ielen;
 	
 	}
-
-#ifndef CONFIG_INTERRUPT_BASED_TXBCN 
-#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-	set_tx_beacon_cmd(padapter);
-#endif
-#endif //!CONFIG_INTERRUPT_BASED_TXBCN
-
-
 }
 
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len)
@@ -480,7 +472,7 @@ void	expire_timeout_chk(_adapter *padapter)
 
 					//to update bcn with tim_bitmap for this station
 					pstapriv->tim_bitmap |= BIT(psta->aid);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 
 					if(!pmlmeext->active_keep_alive_check)
 						continue;
@@ -801,7 +793,7 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 
 }
 
-static void update_bmc_sta(_adapter *padapter)
+void update_bmc_sta(_adapter *padapter)
 {
 	_irqL	irqL;
 	u32 init_rate=0;
@@ -1211,15 +1203,15 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	{
 		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 	}
-	else if(check_buddy_fwstate(padapter, _FW_LINKED)==_TRUE)//only second adapter can enter AP Mode
+	else if(check_buddy_fwstate(padapter, _FW_LINKED)==_TRUE)
 	{
 		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;		
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-	
-		//To sync cur_channel/cur_bwmode/cur_ch_offset with primary adapter
-		DBG_871X("primary iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
-		DBG_871X("primary adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
-		DBG_871X("second adapter, CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+
+		//To sync cur_channel/cur_bwmode/cur_ch_offset with buddy adapter
+		DBG_871X(ADPT_FMT" is at linked state\n", ADPT_ARG(pbuddy_adapter));
+		DBG_871X(ADPT_FMT": CH=%d, BW=%d, offset=%d\n", ADPT_ARG(pbuddy_adapter), pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
+		DBG_871X(ADPT_FMT": CH=%d, BW=%d, offset=%d\n", ADPT_ARG(padapter), cur_channel, cur_bwmode, cur_ch_offset);
 		
 		if((cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
 		(cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
@@ -1280,6 +1272,10 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 			}
 			
 		}
+		else
+		{
+			set_channel_bwmode(padapter, cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+		}
 
 		// to update channel value in beacon
 		pnetwork->Configuration.DSConfig = cur_channel;		
@@ -1303,7 +1299,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 #endif //CONFIG_CONCURRENT_MODE
 
-	DBG_871X("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+	DBG_871X(FUNC_ADPT_FMT" CH=%d, BW=%d, offset=%d\n", FUNC_ADPT_ARG(padapter), cur_channel, cur_bwmode, cur_ch_offset);
 
 	//
 	pmlmeext->cur_channel = cur_channel;	
@@ -1332,7 +1328,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 	if(_TRUE == pmlmeext->bstart_bss)
 	{
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+		update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 
 #ifndef CONFIG_INTERRUPT_BASED_TXBCN //other case will  tx beacon when bcn interrupt coming in.
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
@@ -1372,6 +1368,8 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv    *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *ie = pbss_network->IEs;
@@ -1676,7 +1674,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 		}
 
 		_rtw_memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);		
-		
+		_rtw_memcpy(&pmlmeinfo->HT_caps,p+2,ie_len);	
 	}
 
 	//parsing HT_INFO_IE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_cmd.c
index f906eb3489d1..53811d3f1b83 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_cmd.c
@@ -438,6 +438,8 @@ thread_return rtw_cmd_thread(thread_context context)
 	u8 ret;
 	struct cmd_obj *pcmd;
 	u8 *pcmdbuf, *prspbuf;
+	u32 cmd_start_time;
+	u32 cmd_process_time;
 	u8 (*cmd_hdl)(_adapter *padapter, u8* pbuf);
 	void (*pcmd_callback)(_adapter *dev, struct cmd_obj *pcmd);
        _adapter *padapter = (_adapter *)context;
@@ -459,12 +461,12 @@ _func_enter_;
 	while(1)
 	{
 		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL) {
-			LOG_LEVEL(_drv_err_, FUNC_ADPT_FMT" _rtw_down_sema(&pcmdpriv->cmd_queue_sema) return _FAIL, break\n", FUNC_ADPT_ARG(padapter));
+			LOG_LEVEL(_drv_always_, FUNC_ADPT_FMT" _rtw_down_sema(&pcmdpriv->cmd_queue_sema) return _FAIL, break\n", FUNC_ADPT_ARG(padapter));
 			break;
 		}
 
 		if (pcmdpriv->stop_req) {
-			LOG_LEVEL(_drv_err_, FUNC_ADPT_FMT" stop_req:%u, break\n", FUNC_ADPT_ARG(padapter), pcmdpriv->stop_req);
+			LOG_LEVEL(_drv_always_, FUNC_ADPT_FMT" stop_req:%u, break\n", FUNC_ADPT_ARG(padapter), pcmdpriv->stop_req);
 			break;
 		}
 
@@ -478,7 +480,7 @@ _func_enter_;
 _next:
 		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved == _TRUE))
 		{
-			LOG_LEVEL(_drv_err_, "%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",
+			LOG_LEVEL(_drv_always_, "%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",
 				__FUNCTION__, padapter->bDriverStopped, padapter->bSurpriseRemoved, __LINE__);
 			break;
 		}
@@ -490,6 +492,8 @@ _func_enter_;
 			continue;
 		}
 
+		cmd_start_time = rtw_get_current_time();
+
 		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) )
 		{
 			pcmd->res = H2C_DROPPED;
@@ -528,6 +532,25 @@ _func_enter_;
 
 post_process:
 
+		if((cmd_process_time = rtw_get_passing_time_ms(cmd_start_time)) > 1000)
+		{
+			if (pcmd->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {
+				struct drvextra_cmd_parm *drvextra_parm = (struct drvextra_cmd_parm *)pcmdbuf;
+				DBG_871X(ADPT_FMT" cmd=%d,%d,%d process_time=%d > 1 sec\n",
+					ADPT_ARG(pcmd->padapter), pcmd->cmdcode, drvextra_parm->ec_id, drvextra_parm->type_size, cmd_process_time);
+				//rtw_warn_on(1);
+			} else if(pcmd->cmdcode == GEN_CMD_CODE(_Set_MLME_EVT)){
+				struct C2HEvent_Header *pc2h_evt_hdr = (struct C2HEvent_Header *)pcmdbuf;
+				DBG_871X(ADPT_FMT" cmd=%d,%d, process_time=%d > 1 sec\n",
+					ADPT_ARG(pcmd->padapter), pcmd->cmdcode, pc2h_evt_hdr->ID, cmd_process_time);
+				//rtw_warn_on(1);
+			} else {
+				DBG_871X(ADPT_FMT" cmd=%d, process_time=%d > 1 sec\n",
+					ADPT_ARG(pcmd->padapter), pcmd->cmdcode, cmd_process_time);
+				//rtw_warn_on(1);
+			}
+		}
+
 		//call callback function for post-processed
 		if(pcmd->cmdcode <= (sizeof(rtw_cmd_callback) /sizeof(struct _cmd_callback)))
 		{
@@ -784,7 +807,6 @@ _func_enter_;
 
 		rtw_led_control(padapter, LED_CTL_SITE_SURVEY);
 
-		pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
 	} else {
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
@@ -2178,18 +2200,18 @@ static void traffic_status_watchdog(_adapter *padapter)
 		// LeisurePS only work in infra mode.
 		if(bEnterPS)
 		{
-			LPS_Enter(padapter);
+			LPS_Enter(padapter, "TRAFFIC_IDLE");
 		}
 		else
 		{
-			LPS_Leave(padapter);
+			LPS_Leave(padapter, "TRAFFIC_BUSY");
 		}
 #endif
 	}
 	else
 	{
 #ifdef CONFIG_LPS
-		LPS_Leave(padapter);
+		LPS_Leave(padapter, "NON_LINKED");
 #endif
 	}
 
@@ -2273,7 +2295,7 @@ _func_enter_;
 			break;
 		case LPS_CTRL_JOINBSS:
 			//DBG_871X("LPS_CTRL_JOINBSS \n");
-			LPS_Leave(padapter);
+			LPS_Leave(padapter, "LPS_CTRL_JOINBSS");
 			break;
 		case LPS_CTRL_CONNECT:
 			//DBG_871X("LPS_CTRL_CONNECT \n");
@@ -2285,13 +2307,13 @@ _func_enter_;
 		case LPS_CTRL_DISCONNECT:
 			//DBG_871X("LPS_CTRL_DISCONNECT \n");
 			mstatus = 0;
-			LPS_Leave(padapter);
+			LPS_Leave(padapter, "LPS_CTRL_DISCONNECT");
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
 			break;
 		case LPS_CTRL_SPECIAL_PACKET:
 			//DBG_871X("LPS_CTRL_SPECIAL_PACKET \n");
 			pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
-			LPS_Leave(padapter);
+			LPS_Leave(padapter, "LPS_CTRL_SPECIAL_PACKET");
 			break;
 
 		default:
@@ -2543,7 +2565,7 @@ static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
 			
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+			update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 		}	
 	}	
 	
@@ -2825,11 +2847,10 @@ _func_enter_;
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
 	else if(pcmd->res != H2C_SUCCESS)
-	{				
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+	{
 		_set_timer(&pmlmepriv->assoc_timer, 1);	
 	}
-	
+
 	rtw_free_cmd_obj(pcmd);
 	
 _func_exit_;	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_debug.c
index f70fcb7b2cd1..a067819fdf57 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_debug.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_debug.c
@@ -21,7 +21,6 @@
 
 
 #include <rtw_debug.h>
-#include <../hal/dm.h>
 
 //#ifdef CONFIG_DEBUG_RTL871X
 
@@ -60,94 +59,83 @@
 
 //#endif
 
-#ifdef CONFIG_PROC_DEBUG
 #include <rtw_version.h>
 
-int proc_get_drv_version(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+void dump_drv_version(void *sel)
 {
-	struct net_device *dev = data;
-	
-	int len = 0;
-
-	len += snprintf(page + len, count - len, "%s\n", DRIVERVERSION);
-				
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(sel, "%s %s\n", DRV_NAME, DRIVERVERSION);
+	DBG_871X_SEL_NL(sel, "build time: %s %s\n", __DATE__, __TIME__);
 }
 
-int proc_get_log_level(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+void dump_log_level(void *sel)
 {
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
-
-	len += snprintf(page + len, count - len,
-		"log_level:%d\n",
-		GlobalDebugLevel
-		);
-
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(sel, "log_level:%d\n", GlobalDebugLevel);
 }
 
-int proc_set_log_level(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+void mac_reg_dump(void *sel, _adapter *adapter)
 {
-	struct net_device *dev = (struct net_device *)data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	char tmp[32];
-	u32 is_signal_dbg;
-
-	if (count < 1)
-		return -EFAULT;
-
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+	int i, j = 1;
 
-		int num = sscanf(tmp, "%d ", &is_signal_dbg);
+	DBG_871X_SEL_NL(sel, "======= MAC REG =======\n");
 
-		if( is_signal_dbg >= 0 && is_signal_dbg < 10 )
-		{
-			GlobalDebugLevel= is_signal_dbg;
-			printk("%d\n", GlobalDebugLevel);
-		}
+	for(i=0x0;i<0x800;i+=4)
+	{
+		if(j%4==1)
+			DBG_871X_SEL_NL(sel, "0x%03x",i);
+		DBG_871X_SEL(sel, " 0x%08x ", rtw_read32(adapter,i));
+		if((j++)%4 == 0)
+			DBG_871X_SEL(sel, "\n");
 	}
-	
-	return count;
-	
 }
 
-#ifdef DBG_MEM_ALLOC
-int proc_get_mstat(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{	
-	int len = 0;
-
-	len += _rtw_mstat_dump(page+len, count-len);
-	*eof = 1;
+void bb_reg_dump(void *sel, _adapter *adapter)
+{
+	int i, j = 1;
 
-	return len;
+	DBG_871X_SEL_NL(sel, "======= BB REG =======\n");
+	for(i=0x800;i<0x1000;i+=4)
+	{
+		if(j%4==1)
+			DBG_871X_SEL_NL(sel, "0x%03x",i);
+		DBG_871X_SEL(sel, " 0x%08x ", rtw_read32(adapter,i));
+		if((j++)%4 == 0)
+			DBG_871X_SEL(sel, "\n");
+	}
 }
-#endif /* DBG_MEM_ALLOC */
 
-int proc_get_write_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+void rf_reg_dump(void *sel, _adapter *adapter)
 {
-	*eof = 1;
-	return 0;
+	int i, j = 1, path;
+	u32 value;
+	u8 rf_type = 0;
+	u8 path_nums = 0;
+
+	rtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))
+		path_nums = 1;
+	else
+		path_nums = 2;
+
+	DBG_871X_SEL_NL(sel, "======= RF REG =======\n");
+
+	for (path=0;path<path_nums;path++) {
+		DBG_871X_SEL_NL(sel, "RF_Path(%x)\n",path);
+		for (i=0;i<0x100;i++) {
+			//value = PHY_QueryRFReg(adapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
+			value = rtw_hal_read_rfreg(adapter, path, i, 0xffffffff);
+			if(j%4==1)
+				DBG_871X_SEL_NL(sel, "0x%02x ",i);
+			DBG_871X_SEL(sel, " 0x%08x ",value);
+			if((j++)%4==0)
+				DBG_871X_SEL(sel, "\n");
+		}
+	}
 }
 
-int proc_set_write_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+#ifdef CONFIG_PROC_DEBUG
+ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
 	u32 addr, val, len;
@@ -192,45 +180,38 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 static u32 proc_get_read_addr=0xeeeeeeee;
 static u32 proc_get_read_len=0x4;
 
-int proc_get_read_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{	
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
-	
-	int len = 0;
+int proc_get_read_reg(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	if(proc_get_read_addr==0xeeeeeeee)
-	{
-		*eof = 1;
-		return len;
+	if (proc_get_read_addr==0xeeeeeeee) {
+		DBG_871X_SEL_NL(m, "address not initialized\n");
+		return 0;
 	}	
 
 	switch(proc_get_read_len)
 	{
 		case 1:			
-			len += snprintf(page + len, count - len, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
+			DBG_871X_SEL_NL(m, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
 			break;
 		case 2:
-			len += snprintf(page + len, count - len, "rtw_read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
+			DBG_871X_SEL_NL(m, "rtw_read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
 			break;
 		case 4:
-			len += snprintf(page + len, count - len, "rtw_read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
+			DBG_871X_SEL_NL(m, "rtw_read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
 			break;
 		default:
-			len += snprintf(page + len, count - len, "error read length=%d\n", proc_get_read_len);
+			DBG_871X_SEL_NL(m, "error read length=%d\n", proc_get_read_len);
 			break;
 	}
 
-	*eof = 1;
-	return len;
-
+	return 0;
 }
 
-int proc_set_read_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
+	struct net_device *dev = data;
 	char tmp[16];
 	u32 addr, len;
 
@@ -258,120 +239,247 @@ int proc_set_read_reg(struct file *file, const char *buffer,
 
 }
 
-int proc_get_fwstate(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_fwstate(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
 
-	len += snprintf(page + len, count - len, "fwstate=0x%x\n", get_fwstate(pmlmepriv));
-				
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(m, "fwstate=0x%x\n", get_fwstate(pmlmepriv));
+
+	return 0;
 }
 
-int proc_get_sec_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_sec_info(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-	
-	int len = 0;
 
-	len += snprintf(page + len, count - len, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+	DBG_871X_SEL_NL(m, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
 						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
 						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
-				
-	*eof = 1;
-	return len;
+
+	return 0;
 }
 
-int proc_get_mlmext_state(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_mlmext_state(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X_SEL_NL(m, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+
+	return 0;
+}
+
+#ifdef CONFIG_LAYER2_ROAMING
+int proc_get_roam_flags(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X_SEL_NL(m, "0x%02x\n", rtw_roam_flags(adapter));
+
+	return 0;
+}
+
+ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	char tmp[32];
+	u8 flags;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%hhx", &flags);
+
+		if (num == 1)
+			rtw_assign_roam_flags(adapter, flags);
+	}
 	
-	int len = 0;
+	return count;
+	
+}
+
+int proc_get_roam_param(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+
+	DBG_871X_SEL_NL(m, "%12s %12s %11s\n", "rssi_diff_th", "scanr_exp_ms", "scan_int_ms");
+	DBG_871X_SEL_NL(m, "%-12u %-12u %-11u\n"
+		, mlme->roam_rssi_diff_th
+		, mlme->roam_scanr_exp_ms
+		, mlme->roam_scan_int_ms
+	);
+
+	return 0;
+}
+
+ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+
+	char tmp[32];
+	u8 rssi_diff_th;
+	u32 scanr_exp_ms;
+	u32 scan_int_ms;
+
+	if (count < 1)
+		return -EFAULT;
 
-	len += snprintf(page + len, count - len, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
-				
-	*eof = 1;
-	return len;
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%hhu %u %u", &rssi_diff_th, &scanr_exp_ms, &scan_int_ms);
+
+		if (num >= 1)
+			mlme->roam_rssi_diff_th = rssi_diff_th;
+		if (num >= 2)
+			mlme->roam_scanr_exp_ms = scanr_exp_ms;
+		if (num >= 3)
+			mlme->roam_scan_int_ms = scan_int_ms;
+	}
+	
+	return count;
+	
 }
 
-int proc_get_qos_option(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	char tmp[32];
+	u8 addr[ETH_ALEN];
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", addr, addr+1, addr+2, addr+3, addr+4, addr+5);
+		if (num == 6)
+			_rtw_memcpy(adapter->mlmepriv.roam_tgt_addr, addr, ETH_ALEN);
+
+		DBG_871X("set roam_tgt_addr to "MAC_FMT"\n", MAC_ARG(adapter->mlmepriv.roam_tgt_addr));
+	}
+
+	return count;
+}
+#endif /* CONFIG_LAYER2_ROAMING */
+
+int proc_get_qos_option(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
 
-	len += snprintf(page + len, count - len, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
-				
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(m, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
 
+	return 0;
 }
 
-int proc_get_ht_option(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_ht_option(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
 
-	len += snprintf(page + len, count - len, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
-				
-	*eof = 1;
-	return len;
+#ifdef CONFIG_80211N_HT
+	DBG_871X_SEL_NL(m, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+#endif //CONFIG_80211N_HT
+
+	return 0;
 }
 
-int proc_get_rf_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_rf_info(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	int len = 0;
 
-	len += snprintf(page + len, count - len, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n"
-		"oper_ch=%d, oper_bw=%d, oper_ch_offet=%d\n",
-		pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset,
+	DBG_871X_SEL_NL(m, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n",
+		pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+
+	DBG_871X_SEL_NL(m, "oper_ch=%d, oper_bw=%d, oper_ch_offet=%d\n",
 		rtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));
-	*eof = 1;
 
-	return len;
+	return 0;
 }
 
-int proc_get_ap_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+
+int proc_get_survey_info(struct seq_file *m, void *v)
 {
+	_irqL irqL;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct wlan_network	*pnetwork = NULL;
+	_list	*plist, *phead;
+	s32 notify_signal;
+	u16  index = 0;
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	if ((!phead) || (!plist))
+		return 0;
+
+	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %5s  %s\n","index", "bssid", "ch", "dBm", "SdBm", "age", "ssid");
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+                if (!pnetwork)
+			break;
+	
+		if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+			is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {
+			notify_signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
+		} else {
+			notify_signal = translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
+		}
+	
+		DBG_871X_SEL_NL(m, "%5d  "MAC_FMT"  %3d  %3d  %4d  %5d  %s\n", 
+			++index,
+			MAC_ARG(pnetwork->network.MacAddress), 
+			pnetwork->network.Configuration.DSConfig,
+			(int)pnetwork->network.Rssi,
+			notify_signal,
+			rtw_get_passing_time_ms((u32)pnetwork->last_scanned),
+			//translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength),
+			pnetwork->network.Ssid.Ssid);
+		plist = get_next(plist);
+	}
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	return 0;
+}
+
+
+int proc_get_ap_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
 	struct sta_info *psta;
-	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	int len = 0;
 
 	psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 	if(psta)
@@ -379,365 +487,155 @@ int proc_get_ap_info(char *page, char **start,
 		int i;
 		struct recv_reorder_ctrl *preorder_ctrl;
 					
-		len += snprintf(page + len, count - len, "SSID=%s\n", cur_network->network.Ssid.Ssid);		
-		len += snprintf(page + len, count - len, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
-		len += snprintf(page + len, count - len, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);		
-		len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-		len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
-		len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
-		len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
-		len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
-		len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
-					
+		DBG_871X_SEL_NL(m, "SSID=%s\n", cur_network->network.Ssid.Ssid);		
+		DBG_871X_SEL_NL(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+		DBG_871X_SEL_NL(m, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);		
+		DBG_871X_SEL_NL(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+		DBG_871X_SEL_NL(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+#ifdef CONFIG_80211N_HT
+		DBG_871X_SEL_NL(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+		DBG_871X_SEL_NL(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+		DBG_871X_SEL_NL(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+		DBG_871X_SEL_NL(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+#endif //CONFIG_80211N_HT
+
 		for(i=0;i<16;i++)
 		{							
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
 			if(preorder_ctrl->enable)
 			{
-				len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+				DBG_871X_SEL_NL(m, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
 			}
 		}	
 							
 	}
 	else
 	{							
-		len += snprintf(page + len, count - len, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
+		DBG_871X_SEL_NL(m, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
 	}
 
-	*eof = 1;
-	return len;
-
+	return 0;
 }
 
-int proc_get_adapter_state(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_adapter_state(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	
-	len += snprintf(page + len, count - len, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
-						padapter->bSurpriseRemoved, padapter->bDriverStopped);
 
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(m, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
+						padapter->bSurpriseRemoved, padapter->bDriverStopped);
 
+	return 0;
 }
 	
-int proc_get_trx_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_trx_info(struct seq_file *m, void *v)
 {
+	struct net_device *dev = m->private;
 	int i;
-	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct recv_priv  *precvpriv = &padapter->recvpriv;
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
-        struct hw_xmit *phwxmit;
-	int len = 0;
-	
-	len += snprintf(page + len, count - len, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d"
-				", free_ext_xmitbuf_cnt=%d, free_xframe_ext_cnt=%d"
-				", free_recvframe_cnt=%d\n",
-				pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt,
-				pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt,
-				precvpriv->free_recvframe_cnt);
-#ifdef CONFIG_USB_HCI
-	len += snprintf(page + len, count - len, "rx_urb_pending_cnt=%d\n", precvpriv->rx_pending_cnt);
-#endif
-
-	len += snprintf(page + len, count - len, "recvbuf_skb_alloc_fail_cnt=%d\n", precvpriv->recvbuf_skb_alloc_fail_cnt);
-	len += snprintf(page + len, count - len, "recvbuf_null_cnt=%d\n", precvpriv->recvbuf_null_cnt);
-	len += snprintf(page + len, count - len, "read_port_complete_EINPROGRESS_cnt=%d\n", precvpriv->read_port_complete_EINPROGRESS_cnt);
-	len += snprintf(page + len, count - len, "read_port_complete_other_urb_err_cnt=%d\n", precvpriv->read_port_complete_other_urb_err_cnt);
-	len += snprintf(page + len, count - len, "hw_init_completed=%d\n", padapter->hw_init_completed);
+	struct hw_xmit *phwxmit;
+
+	DBG_871X_SEL_NL(m, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d\n"
+		, pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt);
+	DBG_871X_SEL_NL(m, "free_ext_xmitbuf_cnt=%d, free_xframe_ext_cnt=%d\n"
+		, pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt);
+	DBG_871X_SEL_NL(m, "free_recvframe_cnt=%d\n"
+		, precvpriv->free_recvframe_cnt);
+
+	DBG_871X_SEL_NL(m, "recvbuf_skb_alloc_fail_cnt=%d\n", precvpriv->recvbuf_skb_alloc_fail_cnt);
+	DBG_871X_SEL_NL(m, "recvbuf_null_cnt=%d\n", precvpriv->recvbuf_null_cnt);
+	DBG_871X_SEL_NL(m, "read_port_complete_EINPROGRESS_cnt=%d\n", precvpriv->read_port_complete_EINPROGRESS_cnt);
+	DBG_871X_SEL_NL(m, "read_port_complete_other_urb_err_cnt=%d\n", precvpriv->read_port_complete_other_urb_err_cnt);
+	DBG_871X_SEL_NL(m, "hw_init_completed=%d\n", padapter->hw_init_completed);
 #ifdef CONFIG_USB_HCI
-	len += snprintf(page + len, count - len, "continual_urb_error=%d\n", atomic_read(&pdvobj->continual_urb_error));
+	DBG_871X_SEL_NL(m, "continual_urb_error=%d\n", atomic_read(&pdvobj->continual_urb_error));
 #endif
 
-        for(i = 0; i < 4; i++) 
+	for(i = 0; i < 4; i++) 
 	{
 		phwxmit = pxmitpriv->hwxmits + i;
-		len += snprintf(page + len, count - len, "%d, hwq.accnt=%d\n", i, phwxmit->accnt);
+		DBG_871X_SEL_NL(m, "%d, hwq.accnt=%d\n", i, phwxmit->accnt);
 	}
 
-	*eof = 1;
-	return len;
+#ifdef CONFIG_USB_HCI
+	DBG_871X_SEL_NL(m, "rx_urb_pending_cnt=%d\n", precvpriv->rx_pending_cnt);
+#endif
 
+	return 0;
 }
-	
-		
 
-int proc_get_mac_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_rate_ctl(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1;
-
-	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
+	struct net_device *dev = m->private;
+	int i;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
 
-	for(i=0x0;i<0x300;i+=4)
-	{	
-		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
+	if (adapter->fix_rate != 0xff) {
+		DBG_871X_SEL_NL(m, "FIX\n");
+		DBG_871X_SEL_NL(m, "0x%02x\n", adapter->fix_rate);
+	} else {
+		DBG_871X_SEL_NL(m, "RA\n");
 	}
 
-	*eof = 1;
-	return len;
-
-}
-
-int proc_get_mac_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1;
-
-	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
-	memset(page, 0, count);
-	for(i=0x300;i<0x600;i+=4)
-	{	
-		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
-	}
-	
-	*eof = 1;
-	return len;
-
+	return 0;
 }
 
-int proc_get_mac_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1;
-
-	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
-
-	for(i=0x600;i<0x800;i+=4)
-	{	
-		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
-	}
-
-	*eof = 1;
-	return len;
-
-}
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u8 fix_rate;
 
-int proc_get_bb_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
-	int len = 0;
-	int i,j=1;		
+	if (count < 1)
+		return -EFAULT;
 
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
-	for(i=0x800;i<0xB00;i+=4)
-	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
-	}
-	*eof = 1;
-	return len;	
-}
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
 
-int proc_get_bb_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
-	int len = 0;
-	int i,j=1;		
+		int num = sscanf(tmp, "%hhx", &fix_rate);
 
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
-	for(i=0xB00;i<0xE00;i+=4)
-	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
+		if (num >= 1)
+			adapter->fix_rate = fix_rate;
 	}
-	*eof = 1;
-	return len;	
-}
 
-int proc_get_bb_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
-	int len = 0;
-	int i,j=1;		
-
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
-	for(i=0xE00;i<0x1000;i+=4)
-	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
-	}
-	*eof = 1;
-	return len;	
+	return count;
 }
 
-int proc_get_rf_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_hw_status(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1,path;
-	u32 value;
-	
-	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
-	path = 1;
-	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
-	for(i=0;i<0xC0;i++)
-	{								
-		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
-		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
-	}
-
-	*eof = 1;
-	return len;	
-}
+	struct dvobj_priv *dvobj = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &dvobj->drv_dbg;
 
+	DBG_871X_SEL_NL(m, "RX FIFO full count: last_time=%lld, current_time=%lld, differential=%lld\n"
+	, pdbgpriv->dbg_rx_fifo_last_overflow, pdbgpriv->dbg_rx_fifo_curr_overflow, pdbgpriv->dbg_rx_fifo_diff_overflow);
 
-int proc_get_rf_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1,path;
-	u32 value;	
-
-	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");	
-	path = 1;
-	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
-	for(i=0xC0;i<0x100;i++)
-	{								
-		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
-		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
-	}
-	*eof = 1;
-	return len;	
+	return 0;
 }
 
-
-int proc_get_rf_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_rx_signal(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1,path;
-	u32 value;	
-
-	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
-	path = 2;
-	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
-	for(i=0;i<0xC0;i++)
-	{								
-		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
-		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
-	}
-
-	*eof = 1;
-	return len;	
-}
-
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-int proc_get_rf_reg_dump4(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-	int i,j=1,path;
-	u32 value;
+	DBG_871X_SEL_NL(m, "rssi:%d\n", padapter->recvpriv.rssi);
+	DBG_871X_SEL_NL(m, "rxpwdb:%d\n", padapter->recvpriv.rxpwdb);
+	DBG_871X_SEL_NL(m, "signal_strength:%u\n", padapter->recvpriv.signal_strength);
+	DBG_871X_SEL_NL(m, "signal_qual:%u\n", padapter->recvpriv.signal_qual);
+	DBG_871X_SEL_NL(m, "noise:%u\n", padapter->recvpriv.noise);
 
-	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
-	path = 2;
-	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
-	for(i=0xC0;i<0x100;i++)
-	{								
-		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
-		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");
-	}
-	*eof = 1;
-	return len;	
+	return 0;
 }
 
-
-		
-int proc_get_rx_signal(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
-
-	len += snprintf(page + len, count - len,
-		"rssi:%d\n"
-		"rxpwdb:%d\n"
-		"signal_strength:%u\n"
-		"signal_qual:%u\n"
-		"noise:%u\n", 
-		padapter->recvpriv.rssi,
-		padapter->recvpriv.rxpwdb,
-		padapter->recvpriv.signal_strength,
-		padapter->recvpriv.signal_qual,
-		padapter->recvpriv.noise
-		);
-				
-	*eof = 1;
-	return len;
-}
-
-int proc_set_rx_signal(struct file *file, const char *buffer,
-		unsigned long count, void *data)
-{
-	struct net_device *dev = (struct net_device *)data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
 	u32 is_signal_dbg, signal_strength;
 
@@ -769,31 +667,23 @@ int proc_set_rx_signal(struct file *file, const char *buffer,
 	return count;
 	
 }
+#ifdef CONFIG_80211N_HT
 
-int proc_get_ht_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_ht_enable(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	
-	int len = 0;
-	
+
 	if(pregpriv)
-		len += snprintf(page + len, count - len,
-			"%d\n",
-			pregpriv->ht_enable
-			);
+		DBG_871X_SEL_NL(m, "%d\n", pregpriv->ht_enable);
 
-	*eof = 1;
-	return len;
+	return 0;
 }
 
-int proc_set_ht_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
@@ -817,31 +707,21 @@ int proc_set_ht_enable(struct file *file, const char *buffer,
 	
 }
 
-
-int proc_get_cbw40_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_cbw40_enable(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	
-	int len = 0;
-	
+
 	if(pregpriv)
-		len += snprintf(page + len, count - len,
-			"%d\n",
-			pregpriv->cbw40_enable
-			);
+		DBG_871X_SEL_NL(m, "%d\n", pregpriv->cbw40_enable);
 
-	*eof = 1;
-	return len;
+	return 0;
 }
 
-int proc_set_cbw40_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_cbw40_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
@@ -865,30 +745,21 @@ int proc_set_cbw40_enable(struct file *file, const char *buffer,
 	
 }
 
-int proc_get_ampdu_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_ampdu_enable(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	
-	int len = 0;
-	
+
 	if(pregpriv)
-		len += snprintf(page + len, count - len,
-			"%d\n",
-			pregpriv->ampdu_enable
-			);
+		DBG_871X_SEL_NL(m, "%d\n", pregpriv->ampdu_enable);
 
-	*eof = 1;
-	return len;
+	return 0;
 }
 
-int proc_set_ampdu_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
@@ -912,51 +783,21 @@ int proc_set_ampdu_enable(struct file *file, const char *buffer,
 	
 }
 
-
-int proc_get_two_path_rssi(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_rx_stbc(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	
-	int len = 0;
-	
-	if(padapter)
-		len += snprintf(page + len, count - len,
-			"%d %d\n",
-			padapter->recvpriv.RxRssi[0],
-			padapter->recvpriv.RxRssi[1]
-			);
-
-	*eof = 1;
-	return len;
-}
-
-int proc_get_rx_stbc(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	
-	int len = 0;
-	
+
 	if(pregpriv)
-		len += snprintf(page + len, count - len,
-			"%d\n",
-			pregpriv->rx_stbc
-			);
+		DBG_871X_SEL_NL(m, "%d\n", pregpriv->rx_stbc);
 
-	*eof = 1;
-	return len;
+	return 0;
 }
 
-int proc_set_rx_stbc(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
@@ -979,57 +820,29 @@ int proc_set_rx_stbc(struct file *file, const char *buffer,
 	return count;
 	
 }
+#endif /* CONFIG_80211N_HT */
 
-int proc_get_vid(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_two_path_rssi(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	u16 VID=0;
-	int len = 0;
-
-	rtw_hal_get_hwreg(padapter, HW_VAR_VID, (u8 *)&VID);	
-	len += snprintf(page + len, count - len,
-		"%04x\n",
-		VID
-		);
-
-	*eof = 1;
-	return len;	
-}
-
-int proc_get_pid(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	u16 PID=0;	
-	int len = 0;
 
-	rtw_hal_get_hwreg(padapter, HW_VAR_PID, (u8 *)&PID);		
-	len += snprintf(page + len, count - len,
-		"%04x\n",
-		PID
-		);
+	if(padapter)
+		DBG_871X_SEL_NL(m, "%d %d\n",
+			padapter->recvpriv.RxRssi[0], padapter->recvpriv.RxRssi[1]);
 
-	*eof = 1;
-	return len;	
+	return 0;
 }
 
-int proc_get_rssi_disp(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_rssi_disp(struct seq_file *m, void *v)
 {
-	*eof = 1;
+	struct net_device *dev = m->private;
 	return 0;
 }
 
-int proc_set_rssi_disp(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
 	u32 enable=0;
@@ -1044,7 +857,7 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 
 		int num = sscanf(tmp, "%x", &enable);
 
-		if (num !=  1) {
+		if (num != 1) {
 			DBG_8192C("invalid set_rssi_disp parameter!\n");
 			return count;
 		}
@@ -1052,7 +865,7 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 		if(enable)
 		{			
 			DBG_8192C("Turn On Rx RSSI Display Function\n");
-			padapter->bRxRSSIDisplay = enable ;			
+			padapter->bRxRSSIDisplay = enable ;
 		}
 		else
 		{
@@ -1064,28 +877,46 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 	
 	return count;
 	
-}	
+}
+
+int proc_get_vid(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u16 VID=0;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_VID, (u8 *)&VID);	
+	DBG_871X_SEL_NL(m, "%04x\n",VID);
 
+	return 0;
+}
+
+int proc_get_pid(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u16 PID=0;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_PID, (u8 *)&PID);		
+	DBG_871X_SEL_NL(m, "%04x\n",PID);
+
+	return 0;
+}
 		
 #ifdef CONFIG_AP_MODE
-
-int proc_get_all_sta_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_all_sta_info(struct seq_file *m, void *v)
 {
+	struct net_device *dev = m->private;
 	_irqL irqL;
 	struct sta_info *psta;
-	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	int i, j;
 	_list	*plist, *phead;
 	struct recv_reorder_ctrl *preorder_ctrl;
-	int len = 0;	
-						
 
-	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
-					
+	DBG_871X_SEL_NL(m, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+
 	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 	for(i=0; i< NUM_STA; i++)
@@ -1101,28 +932,30 @@ int proc_get_all_sta_info(char *page, char **start,
 
 			//if(extra_arg == psta->aid)
 			{
-				len += snprintf(page + len, count - len, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
-				len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-				len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
-				len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
-				len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
-				len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
-				len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
-				len += snprintf(page + len, count - len, "sleepq_len=%d\n", psta->sleepq_len);
-				len += snprintf(page + len, count - len, "capability=0x%x\n", psta->capability);
-				len += snprintf(page + len, count - len, "flags=0x%x\n", psta->flags);
-				len += snprintf(page + len, count - len, "wpa_psk=0x%x\n", psta->wpa_psk);
-				len += snprintf(page + len, count - len, "wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
-				len += snprintf(page + len, count - len, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
-				len += snprintf(page + len, count - len, "qos_info=0x%x\n", psta->qos_info);
-				len += snprintf(page + len, count - len, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
+				DBG_871X_SEL_NL(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+				DBG_871X_SEL_NL(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+				DBG_871X_SEL_NL(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+#ifdef CONFIG_80211N_HT
+				DBG_871X_SEL_NL(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+				DBG_871X_SEL_NL(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+				DBG_871X_SEL_NL(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+				DBG_871X_SEL_NL(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+#endif //CONFIG_80211N_HT
+				DBG_871X_SEL_NL(m, "sleepq_len=%d\n", psta->sleepq_len);
+				DBG_871X_SEL_NL(m, "capability=0x%x\n", psta->capability);
+				DBG_871X_SEL_NL(m, "flags=0x%x\n", psta->flags);
+				DBG_871X_SEL_NL(m, "wpa_psk=0x%x\n", psta->wpa_psk);
+				DBG_871X_SEL_NL(m, "wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
+				DBG_871X_SEL_NL(m, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
+				DBG_871X_SEL_NL(m, "qos_info=0x%x\n", psta->qos_info);
+				DBG_871X_SEL_NL(m, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
 								
 				for(j=0;j<16;j++)
 				{							
 					preorder_ctrl = &psta->recvreorder_ctrl[j];
 					if(preorder_ctrl->enable)
 					{
-						len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+						DBG_871X_SEL_NL(m, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
 					}
 				}		
 									
@@ -1134,42 +967,30 @@ int proc_get_all_sta_info(char *page, char **start,
 	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
-	*eof = 1;
-	return len;
-
+	return 0;
 }
-	
-#endif		
+#endif /* CONFIG_AP_MODE */
 
 #ifdef DBG_MEMORY_LEAK
 #include <asm/atomic.h>
 extern atomic_t _malloc_cnt;;
 extern atomic_t _malloc_size;;
 
-int proc_get_malloc_cnt(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_malloc_cnt(struct seq_file *m, void *v)
 {
-	
-	int len = 0;
+	DBG_871X_SEL_NL(m, "_malloc_cnt=%d\n", atomic_read(&_malloc_cnt));
+	DBG_871X_SEL_NL(m, "_malloc_size=%d\n", atomic_read(&_malloc_size));
 
-	len += snprintf(page + len, count - len, "_malloc_cnt=%d\n", atomic_read(&_malloc_cnt));
-	len += snprintf(page + len, count - len, "_malloc_size=%d\n", atomic_read(&_malloc_size));
-				
-	*eof = 1;
-	return len;
+	return 0;
 }
 #endif /* DBG_MEMORY_LEAK */
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
-int proc_get_best_channel(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
+int proc_get_best_channel(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	int len = 0;
 	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
 
 	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
@@ -1209,23 +1030,20 @@ int proc_get_best_channel(char *page, char **start,
 			}
 		}
 #if 1 // debug
-		len += snprintf(page + len, count - len, "The rx cnt of channel %3d = %d\n", 
+		DBG_871X_SEL_NL(m, "The rx cnt of channel %3d = %d\n", 
 					pmlmeext->channel_set[i].ChannelNum, pmlmeext->channel_set[i].rx_count);
 #endif
 	}
 	
-	len += snprintf(page + len, count - len, "best_channel_5G = %d\n", best_channel_5G);
-	len += snprintf(page + len, count - len, "best_channel_24G = %d\n", best_channel_24G);
-
-	*eof = 1;
-	return len;
+	DBG_871X_SEL_NL(m, "best_channel_5G = %d\n", best_channel_5G);
+	DBG_871X_SEL_NL(m, "best_channel_24G = %d\n", best_channel_24G);
 
+	return 0;
 }
 
-int proc_set_best_channel(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+ssize_t proc_set_best_channel(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	char tmp[32];
@@ -1250,21 +1068,18 @@ int proc_set_best_channel(struct file *file, const char *buffer,
 
 #if defined(DBG_CONFIG_ERROR_DETECT)
 #include <rtw_sreset.h>
-int proc_get_sreset(char *page, char **start, off_t offset, int count, int *eof, void *data)
+int proc_get_sreset(struct seq_file *m, void *v)
 {
-	struct net_device *dev = data;
+	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	
-	int len = 0;
-	
-	*eof = 1;
-	return len;
+
+	return 0;
 }
 
-int proc_set_sreset(struct file *file, const char *buffer, unsigned long count, void *data)
+ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
-	struct net_device *dev = (struct net_device *)data;
+	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
 	s32 trigger_point;
@@ -1287,51 +1102,5 @@ int proc_set_sreset(struct file *file, const char *buffer, unsigned long count,
 }
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
-#ifdef CONFIG_DM_ADAPTIVITY
-int proc_get_dm_adaptivity(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	int len = 0;
-
-	len += dm_adaptivity_get_parm_str(padapter, page, count);
-
-	*eof = 1;
-	return len;
-}
-
-int proc_set_dm_adaptivity(struct file *file, const char *buffer,
-		unsigned long count, void *data)
-{
-	struct net_device *dev = (struct net_device *)data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	char tmp[32];
-	u32 TH_L2H_ini;
-	s8 TH_EDCCA_HL_diff;
-	u32 IGI_Base;
-	int ForceEDCCA;
-	u8 AdapEn_RSSI;
-	u8 IGI_LowerBound;
-
-	if (count < 1)
-		return -EFAULT;
-
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
-
-		int num = sscanf(tmp, "%x %hhd %x %d %hhu %hhu",
-			&TH_L2H_ini, &TH_EDCCA_HL_diff, &IGI_Base, &ForceEDCCA, &AdapEn_RSSI, &IGI_LowerBound);
-
-		if (num != 6)
-			return count;
-
-		dm_adaptivity_set_parm(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff, (s8)IGI_Base, (bool)ForceEDCCA, AdapEn_RSSI, IGI_LowerBound);
-	}
-	
-	return count;
-}
-#endif /* CONFIG_DM_ADAPTIVITY */
-
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ieee80211.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ieee80211.c
index 6305ba3fd841..2edc9a9f385d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ieee80211.c
@@ -809,6 +809,28 @@ u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen)
 	return match;
 }
 
+u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type)
+{
+	u8*	wps = NULL;
+
+	DBG_871X( "[%s] frame_type = %d\n", __FUNCTION__, frame_type );
+	switch( frame_type )
+	{
+		case 1:
+		case 3:
+		{	//	Beacon or Probe Response
+			wps = rtw_get_wps_ie(in_ie + _PROBERSP_IE_OFFSET_, in_len - _PROBERSP_IE_OFFSET_, wps_ie, wps_ielen);
+			break;
+		}
+		case 2:
+		{	//	Probe Request
+			wps = rtw_get_wps_ie(in_ie + _PROBEREQ_IE_OFFSET_ , in_len - _PROBEREQ_IE_OFFSET_ , wps_ie, wps_ielen);
+			break;
+		}
+	}
+	return wps;
+}
+
 /**
  * rtw_get_wps_ie - Search WPS IE from a series of IEs
  * @in_ie: Address of IEs to search
@@ -1390,6 +1412,28 @@ void dump_p2p_ie(u8 *ie, u32 ie_len) {
 	}	
 }
 
+u8 *rtw_get_p2p_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen, u8 frame_type)
+{
+	u8*	p2p = NULL;
+
+	DBG_871X( "[%s] frame_type = %d\n", __FUNCTION__, frame_type );
+	switch( frame_type )
+	{
+		case 1:
+		case 3:
+		{	//	Beacon or Probe Response
+			p2p = rtw_get_p2p_ie(in_ie + _PROBERSP_IE_OFFSET_, in_len - _PROBERSP_IE_OFFSET_, p2p_ie, p2p_ielen);
+			break;
+		}
+		case 2:
+		{	//	Probe Request
+			p2p = rtw_get_p2p_ie(in_ie + _PROBEREQ_IE_OFFSET_ , in_len - _PROBEREQ_IE_OFFSET_ , p2p_ie, p2p_ielen);
+			break;
+		}
+	}
+	return p2p;
+}
+
 /**
  * rtw_get_p2p_ie - Search P2P IE from a series of IEs
  * @in_ie: Address of IEs to search
@@ -1693,6 +1737,30 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 
 }
 
+int rtw_get_wfd_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen, u8 frame_type)
+{
+	int match;
+
+	match=_FALSE;
+
+	DBG_871X( "[%s] frame_type = %d\n", __FUNCTION__, frame_type );
+	switch( frame_type )
+	{
+		case 1:
+		case 3:
+		{	//	Beacon or Probe Response
+			match = rtw_get_wfd_ie(in_ie + _PROBERSP_IE_OFFSET_, in_len - _PROBERSP_IE_OFFSET_, wfd_ie, wfd_ielen);
+			break;
+		}
+		case 2:
+		{	//	Probe Request
+			match = rtw_get_wfd_ie(in_ie + _PROBEREQ_IE_OFFSET_ , in_len - _PROBEREQ_IE_OFFSET_ , wfd_ie, wfd_ielen);
+			break;
+		}
+	}
+	return match;
+}
+
 //	attr_content: The output buffer, contains the "body field" of WFD attribute.
 //	attr_contentlen: The data length of the "body field" of WFD attribute.
 int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ioctl_set.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ioctl_set.c
index e67f21917ab7..9c395833e382 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_ioctl_set.c
@@ -124,7 +124,7 @@ _func_enter_;
 		//we try to issue sitesurvey firstly	
             		
 		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==_FALSE
-			|| rtw_to_roaming(padapter) > 0
+			|| rtw_to_roam(padapter) > 0
 		)
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_do_join(): site survey if scanned_queue is empty\n."));
@@ -206,7 +206,7 @@ _func_enter_;
 				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
 				//we try to issue sitesurvey firstly			
 				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==_FALSE
-					|| rtw_to_roaming(padapter) > 0
+					|| rtw_to_roam(padapter) > 0
 				)
 				{
 					//DBG_871X("rtw_do_join() when   no desired bss in scanning queue \n");
@@ -388,6 +388,7 @@ _func_enter_;
 		goto release_mlme_lock;
 	}
 
+	_rtw_memset(&pmlmepriv->assoc_ssid, 0, sizeof(NDIS_802_11_SSID));
 	_rtw_memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
 	pmlmepriv->assoc_by_bssid=_TRUE;
 
@@ -585,10 +586,14 @@ _func_enter_;
 
 	if (ssid && ssid_valid)
 		_rtw_memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(NDIS_802_11_SSID));
+	else
+		_rtw_memset(&pmlmepriv->assoc_ssid, 0, sizeof(NDIS_802_11_SSID));
 
 	if (bssid && bssid_valid) {
 		_rtw_memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
 		pmlmepriv->assoc_by_bssid = _TRUE;
+	} else {
+		pmlmepriv->assoc_by_bssid = _FALSE;
 	}
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme.c
index 67e3f499cd5c..129f1a7bdc08 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme.c
@@ -94,6 +94,26 @@ _func_enter_;
 
 	rtw_clear_scan_deny(padapter);
 
+#ifdef CONFIG_LAYER2_ROAMING
+	#define RTW_ROAM_SCAN_RESULT_EXP_MS 5*1000
+	#define RTW_ROAM_RSSI_DIFF_TH 10
+	#define RTW_ROAM_SCAN_INTERVAL_MS 10*1000
+	
+		pmlmepriv->roam_flags = 0
+			| RTW_ROAM_ON_EXPIRED
+		#ifdef CONFIG_LAYER2_ROAMING_RESUME
+			| RTW_ROAM_ON_RESUME
+		#endif
+		#ifdef CONFIG_LAYER2_ROAMING_ACTIVE
+			| RTW_ROAM_ACTIVE
+		#endif
+			;
+
+		pmlmepriv->roam_scanr_exp_ms = RTW_ROAM_SCAN_RESULT_EXP_MS;
+		pmlmepriv->roam_rssi_diff_th = RTW_ROAM_RSSI_DIFF_TH;
+		pmlmepriv->roam_scan_int_ms = RTW_ROAM_SCAN_INTERVAL_MS;
+#endif /* CONFIG_LAYER2_ROAMING */
+
 	rtw_init_mlme_timer(padapter);
 
 exit:
@@ -615,7 +635,6 @@ int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork)
 	
 }
 
-inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b);
 inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b)
 {
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n",
@@ -624,7 +643,7 @@ inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b)
 		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==_TRUE;
 }
 
-int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature)
 {
 	 u16 s_cap, d_cap;
 	 
@@ -654,6 +673,14 @@ _func_enter_;
 	
 _func_exit_;			
 
+#ifdef CONFIG_P2P
+	if ((feature == 1) && // 1: P2P supported
+		(_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN) == _TRUE)
+		) {
+		return _TRUE;
+	}
+#endif
+
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
 			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
@@ -665,6 +692,45 @@ _func_exit_;
 	
 }
 
+struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network)
+{
+	_list *phead, *plist;
+	struct wlan_network *found = NULL;
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (plist != phead) {
+		found = LIST_CONTAINOR(plist, struct wlan_network ,list);
+
+		if (is_same_network(&network->network, &found->network, 0))
+			break;
+
+		plist = get_next(plist);
+	}
+
+	if(plist == phead)
+		found = NULL;
+exit:		
+	return found;
+}
+
+struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network)
+{
+	_irqL irqL;
+	struct wlan_network *found = NULL;
+
+	if (scanned_queue == NULL || network == NULL)
+		goto exit;	
+
+	_enter_critical_bh(&scanned_queue->lock, &irqL);
+	found = _rtw_find_same_network(scanned_queue, network);
+	_exit_critical_bh(&scanned_queue->lock, &irqL);
+
+exit:
+	return found;
+}
+
 struct	wlan_network	* rtw_get_oldest_wlan_network(_queue *scanned_queue)
 {
 	_list	*plist, *phead;
@@ -731,7 +797,7 @@ _func_enter_;
 	#endif
 
 	/* The rule below is 1/5 for sample value, 4/5 for history value */
-	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src, 0)) {
 		/* Take the recvpriv's value for the connected AP*/
 		ss_final = padapter->recvpriv.signal_strength;
 		sq_final = padapter->recvpriv.signal_qual;
@@ -755,8 +821,11 @@ _func_enter_;
 		
 	}
 
-	if (update_ie)
+	if (update_ie) {
+		dst->Reserved[0] = src->Reserved[0];
+		dst->Reserved[1] = src->Reserved[1];
 		_rtw_memcpy((u8 *)dst, (u8 *)src, get_WLAN_BSSID_EX_sz(src));
+	}
 
 	dst->PhyInfo.SignalStrength = ss_final;
 	dst->PhyInfo.SignalQuality = sq_final;
@@ -821,7 +890,7 @@ _func_enter_;
 	}
 #endif
 
-	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork, 0)))
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
 
@@ -850,22 +919,31 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 	_list	*plist, *phead;
 	ULONG	bssid_ex_sz;
 	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
+	struct wifidirect_info *pwdinfo= &(adapter->wdinfo);    
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct wlan_network	*pnetwork = NULL;
 	struct wlan_network	*oldest = NULL;
-
+	int target_find = 0;
+	u8 feature = 0;
+    
 _func_enter_;
 
 	_enter_critical_bh(&queue->lock, &irqL);
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
+#ifdef CONFIG_P2P
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		feature = 1; // p2p enable
+#endif
+
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
 			break;
 
-		pnetwork	= LIST_CONTAINOR(plist, struct wlan_network, list);
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
 		if ((unsigned long)(pnetwork) < 0x7ffffff)
 		{
@@ -874,11 +952,17 @@ _func_enter_;
 #endif
 		}
 
-		if (is_same_network(&(pnetwork->network), target))
+
+		if (is_same_network(&(pnetwork->network), target, feature)) {
+			target_find = 1; 
 			break;
+		}
 
-		if ((oldest == ((struct wlan_network *)0)) ||
-		time_after(oldest->last_scanned, pnetwork->last_scanned))
+		if (rtw_roam_flags(adapter)) {
+			/* TODO: don't  select netowrk in the same ess as oldest if it's new enough*/
+		}
+
+		if (oldest == NULL || time_after(oldest->last_scanned, pnetwork->last_scanned))
 			oldest = pnetwork;
 
 		plist = get_next(plist);
@@ -888,7 +972,8 @@ _func_enter_;
 	
 	/* If we didn't find a match, then get a new network slot to initialize
 	 * with this beacon's information */
-	if (rtw_end_of_queue_search(phead,plist)== _TRUE) {
+	//if (rtw_end_of_queue_search(phead,plist)== _TRUE) {
+	if (!target_find) {
 		
 		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == _TRUE) {
 			/* If there are no more slots, expire the oldest */
@@ -951,8 +1036,15 @@ _func_enter_;
 		pnetwork->last_scanned = rtw_get_current_time();
 
 		//target.Reserved[0]==1, means that scaned network is a bcn frame.
-		if((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
+		// probe resp(3) > beacon(1) > probe req(2)
+		if ((target->Reserved[0] != 2) &&
+			(target->Reserved[0] >= pnetwork->network.Reserved[0])
+			) {
+			update_ie = _TRUE;
+		}
+		else {
 			update_ie = _FALSE;
+		}
 
 		update_network(&(pnetwork->network), target,adapter, update_ie);
 	}
@@ -1255,13 +1347,13 @@ _func_enter_;
 			}
 			else
 			{
-				DBG_871X("try_to_join, but select scanning queue fail, to_roaming:%d\n", rtw_to_roaming(adapter));
-				#ifdef CONFIG_LAYER2_ROAMING
-				if (rtw_to_roaming(adapter) != 0) {
-					if( --pmlmepriv->to_roaming == 0
+				DBG_871X("try_to_join, but select scanning queue fail, to_roam:%d\n", rtw_to_roam(adapter));
+
+				if (rtw_to_roam(adapter) != 0) {
+					if(rtw_dec_to_roam(adapter) == 0
 						|| _SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)
 					) {
-						rtw_set_roaming(adapter, 0);
+						rtw_set_to_roam(adapter, 0);
 #ifdef CONFIG_INTEL_WIDI
 						if(adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
 						{
@@ -1276,13 +1368,26 @@ _func_enter_;
 						pmlmepriv->to_join = _TRUE;
 					}
 				}
-				#endif
+				else
+				{
+					rtw_indicate_disconnect(adapter);
+				}
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			}
 		}
+	} else {
+		if (rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+				&& check_fwstate(pmlmepriv, _FW_LINKED))
+			{
+				if (rtw_select_roaming_candidate(pmlmepriv) == _SUCCESS) {
+					receive_disconnect(adapter, pmlmepriv->cur_network.network.MacAddress
+						, WLAN_REASON_ACTIVE_ROAM);
+				}
+			}
+		}
 	}
 
-	indicate_wx_scan_complete_event(adapter);
 	//DBG_871X("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time));
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -1321,6 +1426,32 @@ _func_enter_;
 	rtw_cfg80211_surveydone_event_callback(adapter);
 #endif //CONFIG_IOCTL_CFG80211
 
+	rtw_indicate_scan_done(adapter, _FALSE);
+
+#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_IOCTL_CFG80211)
+	if (adapter->pbuddy_adapter) {
+		_adapter *buddy_adapter = adapter->pbuddy_adapter;
+		struct mlme_priv *buddy_mlme = &(buddy_adapter->mlmepriv);
+		struct rtw_wdev_priv *buddy_wdev_priv = adapter_wdev_data(buddy_adapter);
+		bool indicate_buddy_scan = _FALSE;
+
+		_enter_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		if (buddy_wdev_priv->scan_request && buddy_mlme->scanning_via_buddy_intf == _TRUE) {
+			buddy_mlme->scanning_via_buddy_intf = _FALSE;
+			clr_fwstate(buddy_mlme, _FW_UNDER_SURVEY);
+			indicate_buddy_scan = _TRUE;
+		}
+		_exit_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+
+		if (indicate_buddy_scan == _TRUE) {
+			#ifdef CONFIG_IOCTL_CFG80211
+			rtw_cfg80211_surveydone_event_callback(buddy_adapter);
+			#endif
+			rtw_indicate_scan_done(buddy_adapter, _FALSE);
+		}
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
 _func_exit_;	
 
 }
@@ -1366,6 +1497,14 @@ _func_enter_;
 _func_exit_;
 }
 	
+void rtw_reset_rx_info(struct debug_priv *pdbgpriv){
+	pdbgpriv->dbg_rx_ampdu_drop_count = 0;
+	pdbgpriv->dbg_rx_ampdu_forced_indicate_count = 0;
+	pdbgpriv->dbg_rx_ampdu_loss_count = 0;
+	pdbgpriv->dbg_rx_dup_mgt_frame_drop_count = 0;
+	pdbgpriv->dbg_rx_ampdu_window_shift_cnt = 0;
+}
+
 /*
 *rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
 */
@@ -1376,6 +1515,8 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
      	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
    	struct	sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct dvobj_priv *psdpriv = adapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;	
 	
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
@@ -1476,6 +1617,7 @@ _func_enter_;
 	
 	adapter->securitypriv.key_mask = 0;
 
+	rtw_reset_rx_info(pdbgpriv);
 _func_exit_;
 	
 }
@@ -1517,7 +1659,7 @@ _func_enter_;
 
 	}
 
-	rtw_set_roaming(padapter, 0);
+	rtw_set_to_roam(padapter, 0);
 
 #ifdef CONFIG_INTEL_WIDI
 	if(padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
@@ -1550,11 +1692,11 @@ _func_enter_;
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
 
-	if(rtw_to_roaming(padapter) > 0)
+	if(rtw_to_roam(padapter) > 0)
 		_clr_fwstate_(pmlmepriv, _FW_LINKED);
 
 	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED) 
-		|| (rtw_to_roaming(padapter) <= 0)
+		|| (rtw_to_roam(padapter) <= 0)
 	)
 	{
 		rtw_os_indicate_disconnect(padapter);
@@ -1587,6 +1729,7 @@ _func_exit_;
 
 inline void rtw_indicate_scan_done( _adapter *padapter, bool aborted)
 {
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 	rtw_os_indicate_scan_done(padapter, aborted);
 }
 
@@ -1904,7 +2047,7 @@ _func_enter_;
 			}
 			else
 			{
-				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+				ptarget_wlan = _rtw_find_same_network(&pmlmepriv->scanned_queue, pnetwork);
 				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
 					if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;			
 				}
@@ -1917,7 +2060,7 @@ _func_enter_;
 			}
 			else
 			{
-				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't find ptarget_wlan when joinbss_event callback\n"));
+				DBG_871X_LEVEL(_drv_always_, "Can't find ptarget_wlan when joinbss_event callback\n");
 				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 				goto ignore_joinbss_callback;
 			}
@@ -2174,8 +2317,8 @@ void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 	
 _func_enter_;	
 
-        if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
-        {
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+	{
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
 
@@ -2185,7 +2328,7 @@ _func_enter_;
 #endif //CONFIG_IOCTL_CFG80211
 
 		return;
-        }
+	}
 
 
 	mlmeext_sta_del_event_callback(adapter);
@@ -2194,22 +2337,40 @@ _func_enter_;
 
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 	{
+		u16 reason = *((unsigned short *)(pstadel->rsvd));
+		bool roam = _FALSE;
+		struct wlan_network *roam_target = NULL;
+
 		#ifdef CONFIG_LAYER2_ROAMING
-		if (rtw_to_roaming(adapter) > 0)
-			pmlmepriv->to_roaming--; /* this stadel_event is caused by roaming, decrease to_roaming */
-		else if (rtw_to_roaming(adapter) == 0)
-			rtw_set_roaming(adapter, adapter->registrypriv.max_roaming_times);
+		if(adapter->registrypriv.wifi_spec==1) {
+			roam = _FALSE;
+		} else if (reason == WLAN_REASON_EXPIRATION_CHK && rtw_chk_roam_flags(adapter, RTW_ROAM_ON_EXPIRED)) {
+			roam = _TRUE;
+		} else if (reason == WLAN_REASON_ACTIVE_ROAM && rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {
+			roam = _TRUE;
+			roam_target = pmlmepriv->roam_network;
+		}
 #ifdef CONFIG_INTEL_WIDI
-		if(adapter->mlmepriv.widi_state != INTEL_WIDI_STATE_CONNECTED)
+		else if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_CONNECTED) {
+			roam = _TRUE;
+		}
 #endif // CONFIG_INTEL_WIDI
-		if(*((unsigned short *)(pstadel->rsvd)) != WLAN_REASON_EXPIRATION_CHK)
-			rtw_set_roaming(adapter, 0); /* don't roam */
-		#endif
+
+		if (roam == _TRUE) {
+			if (rtw_to_roam(adapter) > 0)
+				rtw_dec_to_roam(adapter); /* this stadel_event is caused by roaming, decrease to_roam */
+			else if (rtw_to_roam(adapter) == 0)
+				rtw_set_to_roam(adapter, adapter->registrypriv.max_roaming_times);
+		} else {
+			rtw_set_to_roam(adapter, 0);
+		}
+		#endif /* CONFIG_LAYER2_ROAMING */
 
 		rtw_free_uc_swdec_pending_queue(adapter);
 
 		rtw_free_assoc_resources(adapter, 1);
 		rtw_indicate_disconnect(adapter);
+
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		// remove the network entry in scanned_queue
 		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);	
@@ -2218,13 +2379,13 @@ _func_enter_;
 			rtw_free_network_nolock(pmlmepriv, pwlan);
 		}
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
-		_rtw_roaming(adapter, tgt_network);
 		
 #ifdef CONFIG_INTEL_WIDI
-		if (!rtw_to_roaming(adapter))
+		if (!rtw_to_roam(adapter))
 			process_intel_widi_disconnect(adapter, 1);
 #endif // CONFIG_INTEL_WIDI
+
+		_rtw_roaming(adapter, tgt_network);
 	}
 
 	if ( check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) || 
@@ -2314,9 +2475,6 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 {
 	_irqL irqL;
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
-#ifdef CONFIG_LAYER2_ROAMING
-	int do_join_r;
-#endif //CONFIG_LAYER2_ROAMING
 
 #if 0
 	if (adapter->bDriverStopped == _TRUE){
@@ -2354,10 +2512,11 @@ _func_enter_;
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	#ifdef CONFIG_LAYER2_ROAMING
-	if (rtw_to_roaming(adapter) > 0) { /* join timeout caused by roaming */
+	if (rtw_to_roam(adapter) > 0) { /* join timeout caused by roaming */
 		while(1) {
-			pmlmepriv->to_roaming--;
-			if (rtw_to_roaming(adapter) != 0) { /* try another */
+			rtw_dec_to_roam(adapter);
+			if (rtw_to_roam(adapter) != 0) { /* try another */
+				int do_join_r;
 				DBG_871X("%s try another roaming\n", __FUNCTION__);
 				if( _SUCCESS!=(do_join_r=rtw_do_join(adapter)) ) {
 					DBG_871X("%s roaming do_join return %d\n", __FUNCTION__ ,do_join_r);
@@ -2425,55 +2584,96 @@ void rtw_scan_timeout_handler (_adapter *adapter)
 
 	rtw_indicate_scan_done(adapter, _TRUE);
 
+#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_IOCTL_CFG80211)
+	if (adapter->pbuddy_adapter) {
+		_adapter *buddy_adapter = adapter->pbuddy_adapter;
+		struct mlme_priv *buddy_mlme = &(buddy_adapter->mlmepriv);
+		struct rtw_wdev_priv *buddy_wdev_priv = adapter_wdev_data(buddy_adapter);
+		bool indicate_buddy_scan = _FALSE;
+
+		_enter_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		if (buddy_wdev_priv->scan_request && buddy_mlme->scanning_via_buddy_intf == _TRUE) {
+			buddy_mlme->scanning_via_buddy_intf = _FALSE;
+			clr_fwstate(buddy_mlme, _FW_UNDER_SURVEY);
+			indicate_buddy_scan = _TRUE;
+		}
+		_exit_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+
+		if (indicate_buddy_scan == _TRUE) {
+			rtw_indicate_scan_done(buddy_adapter, _TRUE);
+		}
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+}
+
+void rtw_mlme_reset_auto_scan_int(_adapter *adapter)
+{
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+
+#ifdef CONFIG_P2P
+	if(!rtw_p2p_chk_state(&adapter->wdinfo, P2P_STATE_NONE)) {
+		mlme->auto_scan_int_ms = 0; /* disabled */
+		goto exit;
+	}
+#endif
+
+	if(adapter->registrypriv.wifi_spec) {
+		mlme->auto_scan_int_ms = 60*1000;
+#ifdef CONFIG_LAYER2_ROAMING
+	} else if(rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {
+		if (check_fwstate(mlme, WIFI_STATION_STATE) && check_fwstate(mlme, _FW_LINKED))
+			mlme->auto_scan_int_ms = mlme->roam_scan_int_ms;
+#endif
+	} else {
+		mlme->auto_scan_int_ms = 0; /* disabled */
+	}
+exit:
+	return;
 }
 
 static void rtw_auto_scan_handler(_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	//auto site survey per 60sec
-	if(pmlmepriv->scan_interval >0)
-	{
-		pmlmepriv->scan_interval--;
-		if(pmlmepriv->scan_interval==0)
-		{
-/*		
+	rtw_mlme_reset_auto_scan_int(padapter);
+
+	if (pmlmepriv->auto_scan_int_ms != 0
+		&& rtw_get_passing_time_ms(pmlmepriv->scan_start_time) > pmlmepriv->auto_scan_int_ms) {
+
+		if (!padapter->registrypriv.wifi_spec) {
 			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) 
 			{
-				DBG_871X("exit %s when _FW_UNDER_SURVEY|_FW_UNDER_LINKING -> \n", __FUNCTION__);
-				return;
+				DBG_871X(FUNC_ADPT_FMT" _FW_UNDER_SURVEY|_FW_UNDER_LINKING\n", FUNC_ADPT_ARG(padapter));
+				goto exit;
 			}
 			
-			if(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)
+			if(pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE)
 			{
-				DBG_871X("%s exit cause traffic_busy(%x)\n",__FUNCTION__, pmlmepriv->sitesurveyctrl.traffic_busy);
-				return;
+				DBG_871X(FUNC_ADPT_FMT" exit BusyTraffic\n", FUNC_ADPT_ARG(padapter));
+				goto exit;
 			}
-*/
+		}
 
 #ifdef CONFIG_CONCURRENT_MODE
-			if (rtw_buddy_adapter_up(padapter))
+		if (rtw_buddy_adapter_up(padapter))
+		{
+			if ((check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+				(padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE))
 			{
-				if ((check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
-					(padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE))
-				{		
-					DBG_871X("%s, but buddy_intf is under scanning or linking or BusyTraffic\n", __FUNCTION__);
-					return;
-				}
+				DBG_871X(FUNC_ADPT_FMT", but buddy_intf is under scanning or linking or BusyTraffic\n"
+					, FUNC_ADPT_ARG(padapter));
+				goto exit;
 			}
+		}
 #endif
 
-			DBG_871X("%s\n", __FUNCTION__);
+		DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
-			rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);			
-			
-			pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
-			
-		}
-		
+		rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 	}
 
+exit:
+	return;
 }
 
 void rtw_dynamic_check_timer_handlder(_adapter *adapter)
@@ -2513,17 +2713,8 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 
 	rtw_dynamic_chk_wk_cmd(adapter);
 
-	if(pregistrypriv->wifi_spec==1)
-	{	
-#ifdef CONFIG_P2P
-		struct wifidirect_info *pwdinfo = &adapter->wdinfo;
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-#endif	
-		{
-			//auto site survey
-			rtw_auto_scan_handler(adapter);
-		}	
-	}
+	/* auto site survey */
+	rtw_auto_scan_handler(adapter);
 
 #ifndef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
@@ -2616,46 +2807,163 @@ void rtw_set_scan_deny(_adapter *adapter, u32 ms)
 }
 #endif
 
-#if defined(IEEE80211_SCAN_RESULT_EXPIRE)
-#define RTW_SCAN_RESULT_EXPIRE IEEE80211_SCAN_RESULT_EXPIRE/HZ*1000 -1000 //3000 -1000
-#else
-#define RTW_SCAN_RESULT_EXPIRE 2000
-#endif
+#ifdef CONFIG_LAYER2_ROAMING
+/*
+* Select a new roaming candidate from the original @param candidate and @param competitor
+* @return _TRUE: candidate is updated
+* @return _FALSE: candidate is not updated
+*/
+static int rtw_check_roaming_candidate(struct mlme_priv *mlme
+	, struct wlan_network **candidate, struct wlan_network *competitor)
+{
+	int updated = _FALSE;
+	_adapter *adapter = container_of(mlme, _adapter, mlmepriv);
+
+	if(is_same_ess(&competitor->network, &mlme->cur_network.network) == _FALSE)
+		goto exit;
+
+	if(rtw_is_desired_network(adapter, competitor) == _FALSE)
+		goto exit;
+
+	DBG_871X("roam candidate:%s %s("MAC_FMT", ch%3u) rssi:%d, age:%5d\n",
+		(competitor == mlme->cur_network_scanned)?"*":" " ,
+		competitor->network.Ssid.Ssid,
+		MAC_ARG(competitor->network.MacAddress),
+		competitor->network.Configuration.DSConfig,
+		(int)competitor->network.Rssi,
+		rtw_get_passing_time_ms(competitor->last_scanned)
+	);
+
+	/* got specific addr to roam */
+	if (!is_zero_mac_addr(mlme->roam_tgt_addr)) {
+		if(_rtw_memcmp(mlme->roam_tgt_addr, competitor->network.MacAddress, ETH_ALEN) == _TRUE)
+			goto update;
+		else
+			goto exit;
+	}
+	#if 1
+	if(rtw_get_passing_time_ms((u32)competitor->last_scanned) >= mlme->roam_scanr_exp_ms)
+		goto exit;
+
+	if (competitor->network.Rssi - mlme->cur_network_scanned->network.Rssi < mlme->roam_rssi_diff_th)
+		goto exit;
+
+	if(*candidate != NULL && (*candidate)->network.Rssi>=competitor->network.Rssi)
+		goto exit;
+	#else
+	goto exit;
+	#endif
+
+update:
+	*candidate = competitor;
+	updated = _TRUE;
+
+exit:
+	return updated;
+}
+
+int rtw_select_roaming_candidate(struct mlme_priv *mlme)
+{
+	_irqL	irqL;
+	int ret = _FAIL;
+	_list	*phead;
+	_adapter *adapter;	
+	_queue	*queue	= &(mlme->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	struct	wlan_network	*candidate = NULL;
+	u8 		bSupportAntDiv = _FALSE;
+
+_func_enter_;
+
+	if (mlme->cur_network_scanned == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	_enter_critical_bh(&(mlme->scanned_queue.lock), &irqL);
+	phead = get_list_head(queue);		
+	adapter = (_adapter *)mlme->nic_hdl;
+
+	mlme->pscanned = get_next(phead);
+
+	while (!rtw_end_of_queue_search(phead, mlme->pscanned)) {
+
+		pnetwork = LIST_CONTAINOR(mlme->pscanned, struct wlan_network, list);
+		if(pnetwork==NULL){
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s return _FAIL:(pnetwork==NULL)\n", __FUNCTION__));
+			ret = _FAIL;
+			goto exit;
+		}
+		
+		mlme->pscanned = get_next(mlme->pscanned);
+
+		if (0)
+		DBG_871X("%s("MAC_FMT", ch%u) rssi:%d\n"
+			, pnetwork->network.Ssid.Ssid
+			, MAC_ARG(pnetwork->network.MacAddress)
+			, pnetwork->network.Configuration.DSConfig
+			, (int)pnetwork->network.Rssi);
+
+		rtw_check_roaming_candidate(mlme, &candidate, pnetwork);
+
+	}
+
+	if(candidate == NULL) {
+		DBG_871X("%s: return _FAIL(candidate == NULL)\n", __FUNCTION__);
+		ret = _FAIL;
+		goto exit;
+	} else {
+		DBG_871X("%s: candidate: %s("MAC_FMT", ch:%u)\n", __FUNCTION__,
+			candidate->network.Ssid.Ssid, MAC_ARG(candidate->network.MacAddress),
+			candidate->network.Configuration.DSConfig);
+
+		mlme->roam_network = candidate;
+
+		if (_rtw_memcmp(candidate->network.MacAddress, mlme->roam_tgt_addr, ETH_ALEN) == _TRUE)
+			_rtw_memset(mlme->roam_tgt_addr,0, ETH_ALEN);
+	}
+
+	ret = _SUCCESS;
+exit:
+	_exit_critical_bh(&(mlme->scanned_queue.lock), &irqL);
+
+	return ret;
+}
+#endif /* CONFIG_LAYER2_ROAMING */
 
-#ifndef PLATFORM_FREEBSD
 /*
 * Select a new join candidate from the original @param candidate and @param competitor
 * @return _TRUE: candidate is updated
 * @return _FALSE: candidate is not updated
 */
-static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
+static int rtw_check_join_candidate(struct mlme_priv *mlme
 	, struct wlan_network **candidate, struct wlan_network *competitor)
 {
 	int updated = _FALSE;
-	_adapter *adapter = container_of(pmlmepriv, _adapter, mlmepriv);
+	_adapter *adapter = container_of(mlme, _adapter, mlmepriv);
 
 
 	//check bssid, if needed
-	if(pmlmepriv->assoc_by_bssid==_TRUE) {
-		if(_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==_FALSE)
+	if(mlme->assoc_by_bssid==_TRUE) {
+		if(_rtw_memcmp(competitor->network.MacAddress, mlme->assoc_bssid, ETH_ALEN) ==_FALSE)
 			goto exit;
 	}
 
 	//check ssid, if needed
-	if(pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
-		if(	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
-			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == _FALSE
+	if(mlme->assoc_ssid.Ssid && mlme->assoc_ssid.SsidLength) {
+		if( competitor->network.Ssid.SsidLength != mlme->assoc_ssid.SsidLength
+			|| _rtw_memcmp(competitor->network.Ssid.Ssid, mlme->assoc_ssid.Ssid, mlme->assoc_ssid.SsidLength) == _FALSE
 		)
 			goto exit;
 	}
 
-	if(rtw_is_desired_network(adapter, competitor)  == _FALSE)
+	if(rtw_is_desired_network(adapter, competitor)	== _FALSE)
 		goto exit;
 
 #ifdef  CONFIG_LAYER2_ROAMING
-	if(rtw_to_roaming(adapter) > 0) {
-		if(	rtw_get_passing_time_ms((u32)competitor->last_scanned) >= RTW_SCAN_RESULT_EXPIRE
-			|| is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) == _FALSE
+	if(rtw_to_roam(adapter) > 0) {
+		if( rtw_get_passing_time_ms((u32)competitor->last_scanned) >= mlme->roam_scanr_exp_ms
+			|| is_same_ess(&competitor->network, &mlme->cur_network.network) == _FALSE
 		)
 			goto exit;
 	}
@@ -2667,56 +2975,16 @@ static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
 		updated = _TRUE;
 	}
 
-#if 0
-	if(pmlmepriv->assoc_by_bssid==_TRUE) { // associate with bssid
-		if(	(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
-			&& _rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN)==_TRUE
-		) {
-			*candidate = competitor;
-			updated = _TRUE;
-		}
-	} else  if (pmlmepriv->assoc_ssid.SsidLength == 0 ) { // associate with ssid, but ssidlength is 0
-		if(	(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi ) ) {
-			*candidate = competitor;
-			updated = _TRUE;
-		}
-	} else
-#ifdef  CONFIG_LAYER2_ROAMING
-	if(rtw_to_roaming(adapter)) { // roaming
-		if(	(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
-			&& is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) 
-			//&&(!is_same_network(&competitor->network, &pmlmepriv->cur_network.network))
-			&& rtw_get_passing_time_ms((u32)competitor->last_scanned) < RTW_SCAN_RESULT_EXPIRE
-			&& rtw_is_desired_network(adapter, competitor)
-		) {
-			*candidate = competitor;
-			updated = _TRUE;
-		}
-		
-	} else
-#endif
-	{ // associate with ssid
-		if(	(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
-			&& (competitor->network.Ssid.SsidLength==pmlmepriv->assoc_ssid.SsidLength)
-			&&((_rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength)) == _TRUE)
-			&& rtw_is_desired_network(adapter, competitor)
-		) {
-			*candidate = competitor;
-			updated = _TRUE;
-		}
-	}
-#endif
-
 	if(updated){
 		DBG_871X("[by_bssid:%u][assoc_ssid:%s]"
 			#ifdef  CONFIG_LAYER2_ROAMING
-			"[to_roaming:%u] "
+			"[to_roam:%u] "
 			#endif
 			"new candidate: %s("MAC_FMT", ch%u) rssi:%d\n",
-			pmlmepriv->assoc_by_bssid,
-			pmlmepriv->assoc_ssid.Ssid,
+			mlme->assoc_by_bssid,
+			mlme->assoc_ssid.Ssid,
 			#ifdef  CONFIG_LAYER2_ROAMING
-			rtw_to_roaming(adapter),
+			rtw_to_roam(adapter),
 			#endif
 			(*candidate)->network.Ssid.Ssid,
 			MAC_ARG((*candidate)->network.MacAddress),
@@ -2753,11 +3021,20 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 
 _func_enter_;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	phead = get_list_head(queue);		
 	adapter = (_adapter *)pmlmepriv->nic_hdl;
 
-	pmlmepriv->pscanned = get_next( phead );
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	#ifdef CONFIG_LAYER2_ROAMING
+	if (pmlmepriv->roam_network) {
+		candidate = pmlmepriv->roam_network;
+		pmlmepriv->roam_network = NULL;
+		goto candidate_exist;
+	}
+	#endif
+
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
 
 	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
 
@@ -2770,9 +3047,12 @@ _func_enter_;
 		
 		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
 
-		#if 0
-		DBG_871X("MacAddress:"MAC_FMT" ssid:%s\n", MAC_ARG(pnetwork->network.MacAddress), pnetwork->network.Ssid.Ssid);
-		#endif
+		if (0)
+		DBG_871X("%s("MAC_FMT", ch%u) rssi:%d\n"
+			, pnetwork->network.Ssid.Ssid
+			, MAC_ARG(pnetwork->network.MacAddress)
+			, pnetwork->network.Configuration.DSConfig
+			, (int)pnetwork->network.Rssi);
 
 		rtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);
  
@@ -2786,8 +3066,10 @@ _func_enter_;
 		DBG_871X("%s: candidate: %s("MAC_FMT", ch:%u)\n", __FUNCTION__,
 			candidate->network.Ssid.Ssid, MAC_ARG(candidate->network.MacAddress),
 			candidate->network.Configuration.DSConfig);
+		goto candidate_exist;
 	}
-	
+
+candidate_exist:
 
 	// check for situation of  _FW_LINKED 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
@@ -2835,201 +3117,6 @@ _func_exit_;
 
 	return ret;
 }
-#else
-int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
-{	
-	_irqL	irqL;
-	_list	*phead;
-#ifdef CONFIG_ANTENNA_DIVERSITY
-	u8 CurrentAntenna;
-#endif
-	unsigned char *dst_ssid, *src_ssid;
-	_adapter *adapter;	
-	_queue	*queue	= &(pmlmepriv->scanned_queue);
-	struct	wlan_network	*pnetwork = NULL;
-	struct	wlan_network	*pnetwork_max_rssi = NULL;
-	#ifdef CONFIG_LAYER2_ROAMING
-	struct wlan_network * roaming_candidate=NULL;
-	u32 cur_time=rtw_get_current_time();
-	#endif
-
-_func_enter_;
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	phead = get_list_head(queue);		
-	adapter = (_adapter *)pmlmepriv->nic_hdl;
-
-	pmlmepriv->pscanned = get_next( phead );
-
-	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
-
-		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
-		if(pnetwork==NULL){
-			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(2)rtw_select_and_join_from_scanned_queue return _FAIL:(pnetwork==NULL)\n"));
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-			return _FAIL;	
-		}
-
-		dst_ssid = pnetwork->network.Ssid.Ssid;
-		src_ssid = pmlmepriv->assoc_ssid.Ssid;
-		
-		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
-
-		#if 0
-		DBG_871X("MacAddress:"MAC_FMT" ssid:%s\n", MAC_ARG(pnetwork->network.MacAddress), pnetwork->network.Ssid.Ssid);
-		#endif
-
-		if(pmlmepriv->assoc_by_bssid==_TRUE)
-		{
-			if(_rtw_memcmp(pnetwork->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN)==_TRUE)
-			{
-				//remove the condition @ 20081125
-				//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
-				//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
-				//		goto ask_for_joinbss;
-				
-				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-				{
-					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
-					{
-						//DBG_871X("select_and_join(1): _FW_LINKED and is same network, it needn't join again\n");
-
-						rtw_indicate_connect(adapter);//rtw_indicate_connect again
-						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
-						return 2;
-					}
-					else
-					{
-						rtw_disassoc_cmd(adapter, 0, _TRUE);
-						rtw_indicate_disconnect(adapter);
-						rtw_free_assoc_resources(adapter, 0);
-						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-						goto ask_for_joinbss;
-						
-					}
-				}
-				else
-				{
-					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-					goto ask_for_joinbss;
-				}
-							
-			}
-			
-		} else if (pmlmepriv->assoc_ssid.SsidLength == 0) {
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-			goto ask_for_joinbss;//anyway, join first selected(dequeued) pnetwork if ssid_len=0				
-	
-		#ifdef CONFIG_LAYER2_ROAMING
-		} else if (rtw_to_roaming(adapter) > 0) {
-		
-			if(	(roaming_candidate == NULL ||roaming_candidate->network.Rssi<pnetwork->network.Rssi )
-				&& is_same_ess(&pnetwork->network, &pmlmepriv->cur_network.network) 
-				//&&(!is_same_network(&pnetwork->network, &pmlmepriv->cur_network.network))
-				&&  rtw_get_time_interval_ms((u32)pnetwork->last_scanned,cur_time) < 5000
-				) {
-				roaming_candidate = pnetwork;
-				//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,
-				DBG_871X
-					("roaming_candidate???: %s("MAC_FMT")\n",
-					roaming_candidate->network.Ssid.Ssid, MAC_ARG(roaming_candidate->network.MacAddress) )
-					//)
-					;
-			}
-			continue;
-		#endif
-
-		} else if ( (pnetwork->network.Ssid.SsidLength==pmlmepriv->assoc_ssid.SsidLength)
-			&&((_rtw_memcmp(dst_ssid, src_ssid, pmlmepriv->assoc_ssid.SsidLength)) == _TRUE)
-			)
-		{
-			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("dst_ssid=%s, src_ssid=%s \n", dst_ssid, src_ssid));
-#ifdef CONFIG_ANTENNA_DIVERSITY
-			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));			
-			DBG_871X("#### dst_ssid=(%s) Opt_Ant_(%s) , cur_Ant(%s)\n", dst_ssid,
-				(2==pnetwork->network.PhyInfo.Optimum_antenna)?"A":"B",
-				(2==CurrentAntenna)?"A":"B");
-#endif
-			//remove the condition @ 20081125
-			//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
-			//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
-			//{
-			//	_rtw_memcpy(pmlmepriv->assoc_bssid, pnetwork->network.MacAddress, ETH_ALEN);
-			//	goto ask_for_joinbss;
-			//}
-
-			if(pmlmepriv->assoc_by_rssi==_TRUE)//if the ssid is the same, select the bss which has the max rssi
-			{
-				if( NULL==pnetwork_max_rssi|| pnetwork->network.Rssi > pnetwork_max_rssi->network.Rssi)
-						pnetwork_max_rssi = pnetwork;					
-			}
-			else if(rtw_is_desired_network(adapter, pnetwork) == _TRUE)
-			{
-				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-				{
-#if 0				
-					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
-					{
-						DBG_871X("select_and_join(2): _FW_LINKED and is same network, it needn't join again\n");
-						
-						rtw_indicate_connect(adapter);//rtw_indicate_connect again
-						
-						return 2;
-					}
-					else
-#endif						
-					{
-						rtw_disassoc_cmd(adapter, 0, _TRUE);
-						//rtw_indicate_disconnect(adapter);//
-						rtw_free_assoc_resources(adapter, 0);
-						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-						goto ask_for_joinbss;						
-					}
-				}
-				else
-				{
-					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-					goto ask_for_joinbss;
-				}				
-
-			}
-		
-			
-		}
- 	
- 	}
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	#ifdef CONFIG_LAYER2_ROAMING
-	if(rtw_to_roaming(adapter) > 0 && roaming_candidate ){
-		pnetwork=roaming_candidate;
-		DBG_871X("select_and_join_from_scanned_queue: roaming_candidate: %s("MAC_FMT")\n",
-			pnetwork->network.Ssid.Ssid, MAC_ARG(pnetwork->network.MacAddress));
-		goto ask_for_joinbss;
-	}
-	#endif
-
-	if((pmlmepriv->assoc_by_rssi==_TRUE)  && (pnetwork_max_rssi!=NULL))
-	{
-		pnetwork = pnetwork_max_rssi;
-		DBG_871X("select_and_join_from_scanned_queue: pnetwork_max_rssi: %s("MAC_FMT")\n",
-			pnetwork->network.Ssid.Ssid, MAC_ARG(pnetwork->network.MacAddress));
-		goto ask_for_joinbss;
-	}
-
-	DBG_871X("(1)rtw_select_and_join_from_scanned_queue return _FAIL\n");
-	
-_func_exit_;	
-
-     return _FAIL;
-
-ask_for_joinbss:
-	
-_func_exit_;
-
-	return rtw_joinbss_cmd(adapter, pnetwork);
-
-}
-#endif //PLATFORM_FREEBSD
-
 
 sint rtw_set_auth(_adapter * adapter,struct security_priv *psecuritypriv)
 {
@@ -3858,16 +3945,22 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
 #endif
 
 #ifdef CONFIG_LAYER2_ROAMING
-inline void rtw_set_roaming(_adapter *adapter, u8 to_roaming)
+inline void rtw_set_to_roam(_adapter *adapter, u8 to_roam)
 {
-	if (to_roaming == 0)
+	if (to_roam == 0)
 		adapter->mlmepriv.to_join = _FALSE;
-	adapter->mlmepriv.to_roaming = to_roaming;
+	adapter->mlmepriv.to_roam = to_roam;
 }
 
-inline u8 rtw_to_roaming(_adapter *adapter)
+inline u8 rtw_dec_to_roam(_adapter *adapter)
 {
-	return adapter->mlmepriv.to_roaming;
+	adapter->mlmepriv.to_roam--;
+	return adapter->mlmepriv.to_roam;
+}
+
+inline u8 rtw_to_roam(_adapter *adapter)
+{
+	return adapter->mlmepriv.to_roam;
 }
 
 void rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
@@ -3879,23 +3972,18 @@ void rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 	_rtw_roaming(padapter, tgt_network);
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 }
+
 void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 {
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *cur_network = &pmlmepriv->cur_network;
 	int do_join_r;
-
-	struct wlan_network *pnetwork;
-
-	if(tgt_network != NULL)
-		pnetwork = tgt_network;
-	else
-		pnetwork = &pmlmepriv->cur_network;
 	
-	if(0 < rtw_to_roaming(padapter)) {
+	if(0 < rtw_to_roam(padapter)) {
 		DBG_871X("roaming from %s("MAC_FMT"), length:%d\n",
-				pnetwork->network.Ssid.Ssid, MAC_ARG(pnetwork->network.MacAddress),
-				pnetwork->network.Ssid.SsidLength);
-		_rtw_memcpy(&pmlmepriv->assoc_ssid, &pnetwork->network.Ssid, sizeof(NDIS_802_11_SSID));
+				cur_network->network.Ssid.Ssid, MAC_ARG(cur_network->network.MacAddress),
+				cur_network->network.Ssid.SsidLength);
+		_rtw_memcpy(&pmlmepriv->assoc_ssid, &cur_network->network.Ssid, sizeof(NDIS_802_11_SSID));
 
 		pmlmepriv->assoc_by_bssid = _FALSE;
 
@@ -3904,9 +3992,9 @@ void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 				break;
 			} else {
 				DBG_871X("roaming do_join return %d\n", do_join_r);
-				pmlmepriv->to_roaming--;
+				rtw_dec_to_roam(padapter);
 				
-				if(0< rtw_to_roaming(padapter)) {
+				if(rtw_to_roam(padapter) > 0) {
 					continue;
 				} else {
 					DBG_871X("%s(%d) -to roaming fail, indicate_disconnect\n", __FUNCTION__,__LINE__);
@@ -3918,7 +4006,7 @@ void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 	}
 	
 }
-#endif
+#endif /* CONFIG_LAYER2_ROAMING */
 
 #ifdef CONFIG_CONCURRENT_MODE
 sint rtw_buddy_adapter_up(_adapter *padapter)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme_ext.c
index 41f01ddddb87..342c7805c1ef 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mlme_ext.c
@@ -27,6 +27,9 @@
 #include <wlan_bssdef.h>
 #include <mlme_osdep.h>
 #include <recv_osdep.h>
+#ifdef CONFIG_IOCTL_CFG80211
+#include <rtw_wifi_regd.h>
+#endif //CONFIG_IOCTL_CFG80211
 
 struct mlme_handler mlme_sta_tbl[]={
 	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
@@ -359,6 +362,8 @@ static void init_mlme_ext_priv_value(_adapter* padapter)
 	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
 	pmlmeinfo->key_index = 0;
 	pmlmeinfo->iv = 0;
+    
+	pmlmeinfo->assoc_AP_vendor = unknownAP;
 
 	pmlmeinfo->enc_algo = _NO_PRIVACY_;
 	pmlmeinfo->authModeToggle = 0;
@@ -651,7 +656,9 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(pframe));
-
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
 		 ("+mgt_dispatcher: type(0x%x) subtype(0x%x)\n",
 		  GetFrameType(pframe), GetFrameSubType(pframe)));
@@ -712,6 +719,7 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 			if (precv_frame->u.hdr.attrib.seq_num == psta->RxMgmtFrameSeqNum)
 			{
 				/* drop the duplicate management frame */
+				pdbgpriv->dbg_rx_dup_mgt_frame_drop_count++;
 				DBG_871X("Drop duplicate management frame with seq_num = %d.\n", precv_frame->u.hdr.attrib.seq_num);
 				return;
 			}
@@ -787,14 +795,14 @@ u32 p2p_listen_state_process(_adapter *padapter, unsigned char *da)
 	{
 		if(padapter->cfg80211_wdinfo.is_ro_ch == _FALSE
 			|| rtw_get_oper_ch(padapter) != padapter->wdinfo.listen_channel
-			|| wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == _FALSE
+			|| adapter_wdev_data(padapter)->p2p_enabled == _FALSE
 			|| padapter->mlmepriv.wps_probe_resp_ie == NULL
 			|| padapter->mlmepriv.p2p_probe_resp_ie == NULL
 		)
 		{
 #ifdef CONFIG_DEBUG_CFG80211
 			DBG_871X("DON'T issue_probersp_p2p: p2p_enabled:%d, wps_probe_resp_ie:%p, p2p_probe_resp_ie:%p, ",
-				wdev_to_priv(padapter->rtw_wdev)->p2p_enabled,
+				adapter_wdev_data(padapter)->p2p_enabled,
 				padapter->mlmepriv.wps_probe_resp_ie,
 				padapter->mlmepriv.p2p_probe_resp_ie);
 			DBG_871X("is_ro_ch:%d, op_ch:%d, p2p_listen_channel:%d\n", 
@@ -876,6 +884,10 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 			{
 				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 				{
+#ifndef CONFIG_IOCTL_CFG80211
+// FIXME
+					report_survey_event(padapter, precv_frame);
+#endif					
 					p2p_listen_state_process( padapter,  get_sa(pframe));
 
 					return _SUCCESS;	
@@ -1204,7 +1216,7 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
 		{
 			//check the vendor of the assoc AP
-			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));				
+			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));
 #ifdef CONFIG_P2P_PS
 			// do P2P PS Before link ? , ToDo
 			//process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
@@ -4898,7 +4910,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&pwdinfo->listen_channel, &pattrib->pktlen);
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 	{
 		if( pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL )
 		{
@@ -5235,7 +5247,7 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 	{
 		if( pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL )
 		{
@@ -5615,7 +5627,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 #ifdef CONFIG_P2P
 	_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211)
+	if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211)
 	{
 		rtw_cfg80211_rx_p2p_action_public(padapter, pframe, len);
 	}
@@ -5669,8 +5681,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
 				issue_p2p_GO_response( padapter, GetAddr2Ptr(pframe), frame_body, len, result );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5704,11 +5715,11 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 						if ( rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT )
 						{
 							pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
-							#ifdef P2P_OP_CHECK_SOCIAL_CH
+							#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 							pwdinfo->p2p_info.operation_ch[ 1 ] = 1;	//Check whether GO is operating in channel 1;
 							pwdinfo->p2p_info.operation_ch[ 2 ] = 6;	//Check whether GO is operating in channel 6;
 							pwdinfo->p2p_info.operation_ch[ 3 ] = 11;	//Check whether GO is operating in channel 11;
-							#endif //P2P_OP_CHECK_SOCIAL_CH
+							#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 							pwdinfo->p2p_info.scan_op_ch_only = 1;
 							_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
 						}
@@ -5738,11 +5749,11 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					if ( rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT )
 					{
 						pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
-						#ifdef P2P_OP_CHECK_SOCIAL_CH
+						#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 						pwdinfo->p2p_info.operation_ch[ 1 ] = 1;	//Check whether GO is operating in channel 1;
 						pwdinfo->p2p_info.operation_ch[ 2 ] = 6;	//Check whether GO is operating in channel 6;
 						pwdinfo->p2p_info.operation_ch[ 3 ] = 11;	//Check whether GO is operating in channel 11;
-						#endif //P2P_OP_CHECK_SOCIAL_CH
+						#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 						pwdinfo->p2p_info.scan_op_ch_only = 1;
 						_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
 					}
@@ -5823,11 +5834,11 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 											{
 												//	The operating channel is acceptable for this device.
 												pwdinfo->rx_invitereq_info.operation_ch[0]= operatingch_info[4];
-												#ifdef P2P_OP_CHECK_SOCIAL_CH
+												#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 												pwdinfo->rx_invitereq_info.operation_ch[1]= 1;		//Check whether GO is operating in channel 1;
 												pwdinfo->rx_invitereq_info.operation_ch[2]= 6;		//Check whether GO is operating in channel 6;
 												pwdinfo->rx_invitereq_info.operation_ch[3]= 11;		//Check whether GO is operating in channel 11;
-												#endif //P2P_OP_CHECK_SOCIAL_CH
+												#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 												pwdinfo->rx_invitereq_info.scan_op_ch_only = 1;
 												_set_timer( &pwdinfo->reset_ch_sitesurvey, P2P_RESET_SCAN_CH );
 												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH );
@@ -5919,8 +5930,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					_set_timer( &pwdinfo->restore_p2p_state_timer, 3000 );
 				}
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -6005,8 +6015,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -6186,7 +6195,7 @@ unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame)
 		return _SUCCESS;
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 	{
 		rtw_cfg80211_rx_action_p2p(padapter, pframe, len);
 		return _SUCCESS;
@@ -6556,7 +6565,7 @@ void issue_beacon(_adapter *padapter)
 			remainder_ielen = cur_network->IELength - wps_offset - wpsielen;
 
 #ifdef CONFIG_IOCTL_CFG80211
-			if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+			if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 			{
 				if(pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len>0)
 				{
@@ -6673,7 +6682,7 @@ void issue_beacon(_adapter *padapter)
 		{
 			u32 len;
 #ifdef CONFIG_IOCTL_CFG80211
-			if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+			if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 			{
 				len = pmlmepriv->p2p_beacon_ie_len;
 				if(pmlmepriv->p2p_beacon_ie && len>0)				
@@ -6991,11 +7000,13 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 	}	
 
 #ifdef CONFIG_P2P
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) /*&& is_valid_p2p_probereq*/)
+	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
+		/* IOT issue, When wifi_spec is not set, send probe_resp with P2P IE even if probe_req has no P2P IE */
+		&& (is_valid_p2p_probereq || !padapter->registrypriv.wifi_spec))
 	{
 		u32 len;
 #ifdef CONFIG_IOCTL_CFG80211
-		if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+		if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 		{
 			//if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p()
 			len = pmlmepriv->p2p_go_probe_resp_ie_len;
@@ -7077,7 +7088,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 }
 
-int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, int wait_ack)
+int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, u8 ch, bool append_wps, int wait_ack)
 {
 	int ret = _FAIL;
 	struct xmit_frame		*pmgntframe;
@@ -7155,25 +7166,19 @@ int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, int wai
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
 	}
 
-#if 0
-	//add wps_ie for wps2.0
-	if(pmlmepriv->probereq_wpsie_len>0 && pmlmepriv->probereq_wpsie_len<MAX_WPS_IE_LEN)
-	{
-		_rtw_memcpy(pframe, pmlmepriv->probereq_wpsie, pmlmepriv->probereq_wpsie_len);
-		pframe += pmlmepriv->probereq_wpsie_len;
-		pattrib->pktlen += pmlmepriv->probereq_wpsie_len;
-		//pmlmepriv->probereq_wpsie_len = 0 ;//reset to zero		
-	}	
-#else
-	//add wps_ie for wps2.0
-	if(pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
-	{
-		_rtw_memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
-		pframe += pmlmepriv->wps_probe_req_ie_len;
-		pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
-		//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero		
-	}	
-#endif
+	if (ch)
+		pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, &ch, &pattrib->pktlen);
+
+	if (append_wps) {
+		//add wps_ie for wps2.0
+		if(pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
+		{
+			_rtw_memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
+			pframe += pmlmepriv->wps_probe_req_ie_len;
+			pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
+			//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero
+		}
+	}
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -7192,10 +7197,10 @@ int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, int wai
 
 inline void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da)
 {
-	_issue_probereq(padapter, pssid, da, _FALSE);
+	_issue_probereq(padapter, pssid, da, 0, 1, _FALSE);
 }
 
-int issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da,
+int issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, u8 ch, bool append_wps,
 	int try_cnt, int wait_ms)
 {
 	int ret;
@@ -7204,7 +7209,7 @@ int issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da,
 
 	do
 	{
-		ret = _issue_probereq(padapter, pssid, da, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_probereq(padapter, pssid, da, ch, append_wps, wait_ms>0?_TRUE:_FALSE);
 
 		i++;
 
@@ -7893,7 +7898,7 @@ void issue_assocreq(_adapter *padapter)
 #ifdef CONFIG_P2P
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 	{
 		if(pmlmepriv->p2p_assoc_req_ie && pmlmepriv->p2p_assoc_req_ie_len>0)
 		{
@@ -9179,9 +9184,11 @@ void site_survey(_adapter *padapter)
 				int i;
 				for(i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
 					if(pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
-						//todo: to issue two probe req???
-						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
-						//rtw_msleep_os(SURVEY_TO>>1);
+						/* IOT issue, When wifi_spec is not set, send one probe req without WPS IE. */
+						if (padapter->registrypriv.wifi_spec)
+							issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
+						else
+							issue_probereq_ex(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL, 0, 0, 0, 0);
 						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
 					} else {
 						break;
@@ -9189,9 +9196,11 @@ void site_survey(_adapter *padapter)
 				}
 
 				if(pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {
-					//todo: to issue two probe req???
-					issue_probereq(padapter, NULL, NULL);
-					//rtw_msleep_os(SURVEY_TO>>1);
+					/* IOT issue, When wifi_spec is not set, send one probe req without WPS IE. */
+					if (padapter->registrypriv.wifi_spec)
+						issue_probereq(padapter, NULL, NULL);
+					else
+						issue_probereq_ex(padapter, NULL, NULL, 0, 0, 0, 0);
 					issue_probereq(padapter, NULL, NULL);
 				}
 			}
@@ -9218,13 +9227,13 @@ void site_survey(_adapter *padapter)
 		if (rtw_get_ch_setting_union(padapter, &cur_channel, &cur_bwmode, &cur_ch_offset) != 0)
 		{
 			if (0)
-			DBG_871X(FUNC_ADPT_FMT" back to linked union - ch:%u, bw:%u, offset:%u\n",
+			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
 				FUNC_ADPT_ARG(padapter), cur_channel, cur_bwmode, cur_ch_offset);
 		}
 		#ifdef CONFIG_IOCTL_CFG80211
 		else if(padapter->pbuddy_adapter
 			&& pbuddy_adapter->wdinfo.driver_interface == DRIVER_CFG80211
-			&& wdev_to_priv(pbuddy_adapter->rtw_wdev)->p2p_enabled
+			&& adapter_wdev_data(pbuddy_adapter)->p2p_enabled
 			&& rtw_p2p_chk_state(&pbuddy_adapter->wdinfo, P2P_STATE_LISTEN)
 			)
 		{
@@ -9351,7 +9360,7 @@ void site_survey(_adapter *padapter)
 
 
 #ifdef CONFIG_IOCTL_CFG80211
-			if((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == _TRUE)
+			if(adapter_wdev_data(padapter)->p2p_enabled == _TRUE)
 			{
 				restore_initial_gain = 0;
 			}
@@ -9417,7 +9426,7 @@ void site_survey(_adapter *padapter)
 
 }
 
-//collect bss info from Beacon and Probe response frames.
+//collect bss info from Beacon and Probe request/response frames.
 u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid)
 {
 	int	i;
@@ -9426,6 +9435,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 	u16	val16, subtype;
 	u8	*pframe = precv_frame->u.hdr.rx_data;
 	u32	packet_len = precv_frame->u.hdr.len;
+      u8 ie_offset;    
 	struct registry_priv 	*pregistrypriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -9442,10 +9452,24 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 
 	subtype = GetFrameSubType(pframe);
 
-	if(subtype==WIFI_BEACON)
+	if(subtype==WIFI_BEACON) {
 		bssid->Reserved[0] = 1;
-	else
-		bssid->Reserved[0] = 0;
+		ie_offset = _BEACON_IE_OFFSET_;
+	} else {
+		// FIXME : more type
+		if (subtype == WIFI_PROBERSP) {
+			ie_offset = _PROBERSP_IE_OFFSET_;
+			bssid->Reserved[0] = 3;
+		}
+		else if (subtype == WIFI_PROBEREQ) {
+			ie_offset = _PROBEREQ_IE_OFFSET_;
+			bssid->Reserved[0] = 2;
+		}
+		else {
+			bssid->Reserved[0] = 0;
+			ie_offset = _FIXED_IE_LENGTH_;
+		}
+	}
 		
 	bssid->Length = sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + len;
 
@@ -9464,7 +9488,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 #endif
 
 	// checking SSID
-	if ((p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_)) == NULL)
+	if ((p = rtw_get_ie(bssid->IEs + ie_offset, _SSID_IE_, &len, bssid->IELength - ie_offset)) == NULL)
 	{
 		DBG_871X("marc: cannot find SSID for survey event\n");
 		return _FAIL;
@@ -9489,7 +9513,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 
 	//checking rate info...
 	i = 0;
-	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	p = rtw_get_ie(bssid->IEs + ie_offset, _SUPPORTEDRATES_IE_, &len, bssid->IELength - ie_offset);
 	if (p != NULL)
 	{
 		if (len > NDIS_802_11_LENGTH_RATES_EX)
@@ -9501,7 +9525,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 		i = len;
 	}
 
-	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _EXT_SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	p = rtw_get_ie(bssid->IEs + ie_offset, _EXT_SUPPORTEDRATES_IE_, &len, bssid->IELength - ie_offset);
 	if (p != NULL)
 	{
 		if (len > (NDIS_802_11_LENGTH_RATES_EX-i))
@@ -9527,8 +9551,33 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 	if (bssid->IELength < 12)
 		return _FAIL;
 
+#ifdef CONFIG_P2P
+	if (subtype == WIFI_PROBEREQ) {
+		u8 *p2p_ie;
+		u32 p2p_ielen;
+		// Set Listion Channel
+		if ((p2p_ie = rtw_get_p2p_ie(bssid->IEs, bssid->IELength, NULL, &p2p_ielen))) {
+			u32 attr_contentlen = 0;
+			u8 listen_ch[5] = { 0x00 };
+
+			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, listen_ch, &attr_contentlen);
+			bssid->Configuration.DSConfig = listen_ch[4];
+		}
+		else { // use current channel
+			bssid->Configuration.DSConfig = rtw_get_oper_ch(padapter);
+			DBG_871X("%s()-%d: Cannot get p2p_ie. set DSconfig to op_ch(%d)\n", __FUNCTION__, __LINE__, bssid->Configuration.DSConfig);
+		}
+
+		// FIXME
+		bssid->InfrastructureMode = Ndis802_11Infrastructure;
+		_rtw_memcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);
+		bssid->Privacy = 1;
+		return _SUCCESS;
+	}
+#endif //CONFIG_P2P
+
 	// Checking for DSConfig
-	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	p = rtw_get_ie(bssid->IEs + ie_offset, _DSSET_IE_, &len, bssid->IELength - ie_offset);
 
 	bssid->Configuration.DSConfig = 0;
 	bssid->Configuration.Length = 0;
@@ -9540,7 +9589,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 	else
 	{// In 5G, some ap do not have DSSET IE
 		// checking HT info for channel
-		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+		p = rtw_get_ie(bssid->IEs + ie_offset, _HT_ADD_INFO_IE_, &len, bssid->IELength - ie_offset);
 		if(p)
 		{
 			struct HT_info_element *HT_info = (struct HT_info_element *)(p + 2);
@@ -9580,7 +9629,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 	{	
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 		
-		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+		p = rtw_get_ie(bssid->IEs + ie_offset, _HT_CAPABILITY_IE_, &len, bssid->IELength - ie_offset);
 		if(p && len>0)
 		{
 			struct HT_caps_element	*pHT_caps;
@@ -10835,7 +10884,7 @@ void linked_status_chk(_adapter *padapter)
 				}
 
 				if (rx_chk != _SUCCESS)
-					issue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, psta->hwaddr, 3, 1);
+					issue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, psta->hwaddr, 0, 0, 3, 1);
 
 				if ((tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) || rx_chk != _SUCCESS) {
 					tx_chk = issue_nulldata(padapter, psta->hwaddr, 0, 3, 1);
@@ -10857,9 +10906,9 @@ void linked_status_chk(_adapter *padapter)
 						#ifdef DBG_EXPIRATION_CHK
 						DBG_871X("issue_probereq to trigger probersp, retry=%d\n", pmlmeext->retry);
 						#endif
-						issue_probereq(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
-						issue_probereq(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
-						issue_probereq(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
+						issue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress, 0, 0, 0, 0);
+						issue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress, 0, 0, 0, 0);
+						issue_probereq_ex(padapter, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress, 0, 0, 0, 0);
 					}
 				}
 
@@ -11550,6 +11599,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 								break;
 				
 							default:
+								pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 								break;
 						}
@@ -11867,7 +11917,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 
 #ifdef CONFIG_P2P
 #ifdef CONFIG_IOCTL_CFG80211
-		if((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == _TRUE && pwdinfo->driver_interface == DRIVER_CFG80211 )
+		if(adapter_wdev_data(padapter)->p2p_enabled == _TRUE && pwdinfo->driver_interface == DRIVER_CFG80211 )
 		{
 			write_initial_gain = 0;
 		}
@@ -12957,6 +13007,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 	struct mlme_ext_priv *pbuddy_mlmeext;
 	struct mlme_ext_info *pbuddy_mlmeinfo;
 	WLAN_BSSID_EX *pbuddy_network_mlmeext;
+	WLAN_BSSID_EX *pnetwork;
 
 	pmlmeext = &padapter->mlmeextpriv;
 	pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -12970,6 +13021,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 
 	pbuddy_adapter = padapter->pbuddy_adapter;
 	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+	pnetwork = (WLAN_BSSID_EX *)&pbuddy_mlmepriv->cur_network.network;
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 	pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
@@ -13136,6 +13188,9 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 
 		DBG_871X("update pbuddy_adapter's beacon\n");
 		
+		_rtw_memcpy(pnetwork, pbuddy_network_mlmeext, sizeof(WLAN_BSSID_EX));
+		//update bmc rate to avoid bb cck hang
+		update_bmc_sta(pbuddy_adapter);
 		update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
 
 	}
@@ -13256,6 +13311,7 @@ int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset)
 
 		connect_allow = chbw_allow;
 
+#ifdef CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT
 		#if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 		/* wlan0-sta mode has higher priority than p2p0-p2p client */
 		if (!rtw_p2p_chk_state(&(pbuddy_adapter->wdinfo), P2P_STATE_NONE)
@@ -13264,6 +13320,9 @@ int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset)
 			connect_allow = _TRUE;
 		}
 		#endif /* CONFIG_P2P && CONFIG_IOCTL_CFG80211 */
+#else
+		connect_allow = _TRUE;
+#endif /* CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT */
 
 		DBG_871X("start_clnt_join: connect_allow:%d, chbw_allow:%d\n", connect_allow, chbw_allow);
 		if (connect_allow == _TRUE && chbw_allow == _FALSE) {
@@ -13292,7 +13351,7 @@ int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset)
 	return connect_allow == _TRUE ? _SUCCESS : _FAIL;
 }
 
-/* Find union about ch, bw, ch_offset of all linked interfaces */
+/* Find union about ch, bw, ch_offset of all linked/linking interfaces */
 int rtw_get_ch_setting_union(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -13312,7 +13371,7 @@ int rtw_get_ch_setting_union(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset)
 		iface = dvobj->padapters[i];
 		mlmeext = &iface->mlmeextpriv;
 
-		if (!check_fwstate(&iface->mlmepriv, _FW_LINKED))
+		if (!check_fwstate(&iface->mlmepriv, _FW_LINKED|_FW_UNDER_LINKING))
 			continue;
 
 		if (num == 0) {
@@ -13385,7 +13444,13 @@ u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf)
 
 	pmlmeext->max_chan_nums = init_channel_set(padapter, setChannelPlan_param->channel_plan, pmlmeext->channel_set);
 	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);	
-
+#ifdef CONFIG_IOCTL_CFG80211
+	if ((padapter->rtw_wdev != NULL) && (padapter->rtw_wdev->wiphy)) {
+		struct regulatory_request request;
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+		rtw_reg_notifier(padapter->rtw_wdev->wiphy, &request);
+	}
+#endif //CONFIG_IOCTL_CFG80211
 	return 	H2C_SUCCESS;
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mp.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mp.c
index 68fda5398c9b..d5dd25840e75 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mp.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_mp.c
@@ -34,10 +34,6 @@
 #ifdef CONFIG_RTL8192D
 #include <rtl8192d_hal.h>
 #endif
-#ifdef CONFIG_RTL8723A
-#include <rtl8723a_hal.h>
-#endif
-
 
 #ifdef CONFIG_MP_INCLUDED
 
@@ -295,10 +291,14 @@ s32 init_mp_priv(PADAPTER padapter)
 
 	_init_mp_priv_(pmppriv);
 	pmppriv->papdater = padapter;
-
+	pmppriv->mp_dm =0;
 	pmppriv->tx.stop = 1;
 	mp_init_xmit_attrib(&pmppriv->tx, padapter);
 
+	pmppriv->antenna_tx = ANTENNA_A;
+	pmppriv->antenna_rx = ANTENNA_A;
+	pmppriv->bandwidth = HT_CHANNEL_WIDTH_20;
+/*	
 	switch (padapter->registrypriv.rf_config) {
 		case RF_1T1R:
 			pmppriv->antenna_tx = ANTENNA_A;
@@ -319,7 +319,7 @@ s32 init_mp_priv(PADAPTER padapter)
 			pmppriv->antenna_rx = ANTENNA_ABCD;
 			break;
 	}
-
+*/
 	return _SUCCESS;
 }
 
@@ -340,7 +340,7 @@ void free_mp_priv(struct mp_priv *pmp_priv)
 #endif
 
 #ifdef CONFIG_RTL8192D
-#define PHY_IQCalibrate(a)	rtl8192d_PHY_IQCalibrate(a)
+#define PHY_IQCalibrate(a)	rtl8192d_PHY_IQCalibrate(a, _FALSE)
 #define PHY_LCCalibrate(a)	rtl8192d_PHY_LCCalibrate(a, _TRUE)
 #define dm_CheckTXPowerTracking(a)	rtl8192d_dm_CheckTXPowerTracking(a)
 #define PHY_SetRFPathSwitch(a,b)	rtl8192d_PHY_SetRFPathSwitch(a,b)
@@ -412,6 +412,7 @@ MPT_InitializeAdapter(
 	PHY_IQCalibrate(pAdapter);
 	dm_CheckTXPowerTracking(pAdapter);	//trigger thermal meter
 	PHY_LCCalibrate(pAdapter);
+	PHY_SetRFPathSwitch(pAdapter, 1/*pHalData->bDefaultAntenna*/);	//Wifi default use Main
 #endif
 
 #ifdef CONFIG_PCI_HCI
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_p2p.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_p2p.c
index 64c325128ce5..b4d18398ef1e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_p2p.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_p2p.c
@@ -3559,10 +3559,10 @@ _func_enter_;
 
 	if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
 		if (0)
-		DBG_871X(FUNC_ADPT_FMT" back to linked union - ch:%u, bw:%u, offset:%u\n",
+		DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
 			FUNC_ADPT_ARG(padapter), ch, bw, offset);
 	}
-	else if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->listen_channel) {
+	else if (adapter_wdev_data(padapter)->p2p_enabled && pwdinfo->listen_channel) {
 		ch = pwdinfo->listen_channel;
 		bw = HT_CHANNEL_WIDTH_20;
 		offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -3601,7 +3601,7 @@ _func_exit_;
 static void ro_ch_timer_process (void *FunctionContext)
 {
 	_adapter *adapter = (_adapter *)FunctionContext;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 
 	//printk("%s \n", __FUNCTION__);
 	
@@ -3829,7 +3829,7 @@ void rtw_append_wfd_ie(_adapter *padapter, u8 *buf, u32* len)
 	unsigned char	*frame_body;
 	u8 category, action, OUI_Subtype, dialogToken=0;
 	u32	wfdielen = 0;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
 	
 	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));	
 	category = frame_body[0];
@@ -4010,7 +4010,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 	u8 category, action, OUI_Subtype, dialogToken=0;
 	u8 *p2p_ie = NULL;
 	uint p2p_ielen = 0;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
 	int status = -1;
 	u8 ch_list_buf[128] = {'\0'};
 	int op_ch = -1;
@@ -4057,7 +4057,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 						}
 						#endif //CONFIG_DRV_ISSUE_PROV_REQ
 
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
@@ -4086,7 +4086,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 							(tx==_TRUE)?"Tx":"Rx", dialogToken, (intent>>1), intent&0x1 ? "+" : "-", listen_ch, op_ch, ch_list_buf);
 
 					if (!tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED)
 							&& rtw_chk_p2pie_ch_list_with_buddy(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr)) == _FALSE)
 						{
@@ -4103,7 +4103,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 					struct rtw_wdev_nego_info* nego_info = &pwdev_priv->nego_info;
 
 					if (tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
@@ -4133,7 +4133,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 
 					if (!tx) {
 						pwdev_priv->provdisc_req_issued = _FALSE;
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED)
 							&& rtw_chk_p2pie_ch_list_with_buddy(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr)) == _FALSE)
 						{
@@ -4151,7 +4151,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 					bool is_go = _FALSE;
 
 					if (tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
@@ -4170,7 +4170,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 						nego_info->state = 2;
 
 						if (status == 0) {
-							if (rtw_p2p_nego_intent_compare(nego_info->req_intent, nego_info->rsp_intent) && tx)
+							if (rtw_p2p_nego_intent_compare(nego_info->req_intent, nego_info->rsp_intent) ^ !tx)
 								is_go = _TRUE;
 						}
 
@@ -4192,7 +4192,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 					int flags = -1;
 
 					if (tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
@@ -4218,7 +4218,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 							(tx==_TRUE)?"Tx":"Rx", dialogToken, flags, op_ch, ch_list_buf);
 
 					if (!tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED)) {
 							if (op_ch != -1 && rtw_chk_p2pie_op_ch_with_buddy(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr)) == _FALSE) {
 								DBG_871X(FUNC_ADPT_FMT" op_ch:%u has no intersect with buddy\n", FUNC_ADPT_ARG(padapter), op_ch);
@@ -4238,7 +4238,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 					struct rtw_wdev_invit_info* invit_info = &pwdev_priv->invit_info;
 
 					if (tx) {
-						#ifdef CONFIG_CONCURRENT_MODE
+						#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
 						if(check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
@@ -4703,11 +4703,11 @@ static void reset_ch_sitesurvey_timer_process (void *FunctionContext)
 	DBG_871X( "[%s] In\n", __FUNCTION__ );
 	//	Reset the operation channel information
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
-#ifdef P2P_OP_CHECK_SOCIAL_CH
+#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[2] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[3] = 0;
-#endif //P2P_OP_CHECK_SOCIAL_CH 
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH 
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 }
 
@@ -4722,11 +4722,11 @@ static void reset_ch_sitesurvey_timer_process2 (void *FunctionContext)
 	DBG_871X( "[%s] In\n", __FUNCTION__ );
 	//	Reset the operation channel information
 	pwdinfo->p2p_info.operation_ch[0] = 0;
-#ifdef P2P_OP_CHECK_SOCIAL_CH
+#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->p2p_info.operation_ch[1] = 0;
 	pwdinfo->p2p_info.operation_ch[2] = 0;
 	pwdinfo->p2p_info.operation_ch[3] = 0;
-#endif //P2P_OP_CHECK_SOCIAL_CH
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
 
@@ -4809,7 +4809,7 @@ void ap_p2p_switch_timer_process (void *FunctionContext)
 	_adapter *adapter = (_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 #ifdef CONFIG_IOCTL_CFG80211	
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 #endif
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -5043,19 +5043,19 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;	//	Used to indicate the scan end in site survey function
-#ifdef P2P_OP_CHECK_SOCIAL_CH
+#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->rx_invitereq_info.operation_ch[2] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[3] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[4] = 0;
-#endif //P2P_OP_CHECK_SOCIAL_CH
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 	pwdinfo->p2p_info.operation_ch[0] = 0;
 	pwdinfo->p2p_info.operation_ch[1] = 0;			//	Used to indicate the scan end in site survey function
-#ifdef P2P_OP_CHECK_SOCIAL_CH
+#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->p2p_info.operation_ch[2] = 0;
 	pwdinfo->p2p_info.operation_ch[3] = 0;
 	pwdinfo->p2p_info.operation_ch[4] = 0;
-#endif //P2P_OP_CHECK_SOCIAL_CH
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
 
@@ -5249,7 +5249,7 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 
 #ifdef CONFIG_IOCTL_CFG80211
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
-			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _FALSE;
+			adapter_wdev_data(padapter)->p2p_enabled = _FALSE;
 #endif //CONFIG_IOCTL_CFG80211
 
 		if (_FAIL == rtw_pwr_wakeup(padapter)) {
@@ -5271,8 +5271,13 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer);
 			#endif
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
+			rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_NONE);
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
 			_rtw_memset(&pwdinfo->rx_prov_disc_info, 0x00, sizeof(struct rx_provdisc_req_info));
+
+			/* Remove profiles in wifidirect_info structure. */
+			_rtw_memset( &pwdinfo->profileinfo[ 0 ], 0x00, sizeof( struct profile_info ) * P2P_MAX_PERSISTENT_GROUP_NUM );
+			pwdinfo->profileindex = 0;
 		}
 
 		//Restore to initial setting.
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_pwrctrl.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_pwrctrl.c
index d1c11fa6f606..d7eca65ed8b0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_pwrctrl.c
@@ -390,7 +390,7 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 	return _TRUE;
 }
 
-void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps)
+void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, const char *msg)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 #ifdef CONFIG_P2P
@@ -430,7 +430,8 @@ _func_enter_;
 #ifdef CONFIG_LPS_LCLK
 			_enter_pwrlock(&pwrpriv->lock);
 #endif
-			DBG_871X("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
+			DBG_871X(FUNC_ADPT_FMT" Leave 802.11 power save - %s\n",
+				FUNC_ADPT_ARG(padapter), msg);
 
 #ifdef CONFIG_TDLS
 			_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
@@ -484,7 +485,8 @@ _func_enter_;
 #ifdef CONFIG_LPS_LCLK
 			_enter_pwrlock(&pwrpriv->lock);
 #endif
-			DBG_871X("rtw_set_ps_mode(): Enter 802.11 power save mode...\n");
+			DBG_871X(FUNC_ADPT_FMT" Enter 802.11 power save - %s\n",
+				FUNC_ADPT_ARG(padapter), msg);
 
 #ifdef CONFIG_TDLS
 			_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
@@ -540,11 +542,12 @@ _func_exit_;
 //	Description:
 //		Enter the leisure power save mode.
 //
-void LPS_Enter(PADAPTER padapter)
+void LPS_Enter(PADAPTER padapter, const char *msg)
 {
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	_adapter *buddy = padapter->pbuddy_adapter;
+	char buf[32] = {0};
 
 _func_enter_;
 
@@ -602,7 +605,8 @@ _func_enter_;
 		{
 			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
-				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, 2);
+				sprintf(buf, "WIFI-%s", msg);
+				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, 2, buf);
 			}	
 		}
 		else
@@ -619,13 +623,14 @@ _func_exit_;
 //	Description:
 //		Leave the leisure power save mode.
 //
-void LPS_Leave(PADAPTER padapter)
+void LPS_Leave(PADAPTER padapter, const char *msg)
 {
 #define LPS_LEAVE_TIMEOUT_MS 100
 
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	u32 start_time;
 	BOOLEAN bAwake = _FALSE;
+	char buf[32] = {0};
 	
 _func_enter_;
 
@@ -640,7 +645,8 @@ _func_enter_;
 	{	
 		if(pwrpriv->pwr_mode != PS_MODE_ACTIVE)
 		{
-			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0);
+			sprintf(buf, "WIFI-%s", msg);
+			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, buf);
 
 			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
@@ -689,7 +695,7 @@ _func_enter_;
 #endif // CONFIG_P2P_PS
 #ifdef CONFIG_LPS
 		//DBG_871X("==> leave LPS.......\n");
-		LPS_Leave(Adapter);
+		LPS_Leave(Adapter, "LPS_CTRL_LEAVE");
 #endif
 	}
 	else
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_recv.c
index 274fb3dafaa1..d3e8d47ce843 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_recv.c
@@ -1661,7 +1661,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);		
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 				}
 				
 				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
@@ -1693,7 +1693,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 				}
 				
 			}				
@@ -3325,6 +3325,9 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num);
 int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
 {
+	PADAPTER padapter = preorder_ctrl->padapter;
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
 	u8	wsize = preorder_ctrl->wsize_b;
 	u16	wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;//% 4096;
 
@@ -3380,7 +3383,7 @@ int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
 			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
 		else
 			preorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;
-
+		pdbgpriv->dbg_rx_ampdu_window_shift_cnt++;
 		#ifdef DBG_RX_SEQ
 		DBG_871X("DBG_RX_SEQ %s:%d SN_LESS(wend, seq_num) IndicateSeq: %d, NewSeq: %d\n", __FUNCTION__, __LINE__,
 			preorder_ctrl->indicate_seq, seq_num);
@@ -3454,6 +3457,20 @@ int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union rec
 
 }
 
+void recv_indicatepkts_pkt_loss_cnt(struct debug_priv *pdbgpriv, u64 prev_seq, u64 current_seq);
+void recv_indicatepkts_pkt_loss_cnt(struct debug_priv *pdbgpriv, u64 prev_seq, u64 current_seq)
+{
+	if(current_seq < prev_seq)
+	{
+		pdbgpriv->dbg_rx_ampdu_loss_count+= (4096 + current_seq - prev_seq);
+
+	}
+	else
+	{
+		pdbgpriv->dbg_rx_ampdu_loss_count+= (current_seq - prev_seq);
+	}
+}
+
 int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced);
 int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced)
 {
@@ -3466,7 +3483,9 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 	int bPktInBuf = _FALSE;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
-
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	
 	//DbgPrint("+recv_indicatepkts_in_order\n");
 
 	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
@@ -3484,6 +3503,7 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 	// Handling some condition for forced indicate case.
 	if(bforced==_TRUE)
 	{
+		pdbgpriv->dbg_rx_ampdu_forced_indicate_count++;
 		if(rtw_is_list_empty(phead))
 		{
 			// _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
@@ -3491,8 +3511,9 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 			return _TRUE;
 		}
 	
-		 prframe = LIST_CONTAINOR(plist, union recv_frame, u);
-	        pattrib = &prframe->u.hdr.attrib;	
+		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pattrib = &prframe->u.hdr.attrib;	
+		recv_indicatepkts_pkt_loss_cnt(pdbgpriv,preorder_ctrl->indicate_seq,pattrib->seq_num);
 		preorder_ctrl->indicate_seq = pattrib->seq_num;		
 		#ifdef DBG_RX_SEQ
 		DBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n", __FUNCTION__, __LINE__,
@@ -3631,7 +3652,9 @@ int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
 	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
 	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
-
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	
 	if(!pattrib->amsdu)
 	{
 		//s1.
@@ -3727,6 +3750,7 @@ int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 	//s2. check if winstart_b(indicate_seq) needs to been updated
 	if(!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
 	{
+		pdbgpriv->dbg_rx_ampdu_drop_count++;
 		//pHTInfo->RxReorderDropCounter++;
 		//ReturnRFDList(Adapter, pRfd);
 		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_wlan_util.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_wlan_util.c
index 56dac60d53b6..1cf4928eb816 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_wlan_util.c
@@ -454,10 +454,39 @@ inline u8 rtw_get_oper_ch(_adapter *adapter)
 
 inline void rtw_set_oper_ch(_adapter *adapter, u8 ch)
 {
-	if (adapter_to_dvobj(adapter)->oper_channel != ch)
-		adapter_to_dvobj(adapter)->on_oper_ch_time = rtw_get_current_time();
+#ifdef DBG_CH_SWITCH
+	const int len = 128;
+	char msg[128] = {0};
+	int cnt = 0;
+	int i = 0;
+#endif  /* DBG_CH_SWITCH */
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	
+	if (dvobj->oper_channel != ch) {
+		dvobj->on_oper_ch_time = rtw_get_current_time();
+
+#ifdef DBG_CH_SWITCH
+		cnt += snprintf(msg+cnt, len-cnt, "switch to ch %3u", ch);
+
+		for (i = 0; i < dvobj->iface_nums; i++) {
+			_adapter *iface = dvobj->padapters[i];
+			cnt += snprintf(msg+cnt, len-cnt, " ["ADPT_FMT":", ADPT_ARG(iface));
+			if (iface->mlmeextpriv.cur_channel == ch)
+				cnt += snprintf(msg+cnt, len-cnt, "C");
+			else
+				cnt += snprintf(msg+cnt, len-cnt, "_");
+			if (iface->wdinfo.listen_channel == ch && !rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_NONE))
+				cnt += snprintf(msg+cnt, len-cnt, "L");
+			else
+				cnt += snprintf(msg+cnt, len-cnt, "_");
+			cnt += snprintf(msg+cnt, len-cnt, "]");
+		}
+
+		DBG_871X(FUNC_ADPT_FMT" %s\n", FUNC_ADPT_ARG(adapter), msg);
+#endif /* DBG_CH_SWITCH */
+	}
 
-	adapter_to_dvobj(adapter)->oper_channel = ch;
+	dvobj->oper_channel = ch;
 }
 
 inline u8 rtw_get_oper_bw(_adapter *adapter)
@@ -1074,6 +1103,7 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 				break;
 				
 			default:
+				new_bwmode = HT_CHANNEL_WIDTH_20;
 				new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 				break;
 		}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_xmit.c
index 18f1fdb319bd..9825b3b73458 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/core/rtw_xmit.c
@@ -2440,7 +2440,11 @@ void rtw_init_xmitframe(struct xmit_frame *pxframe)
 
 #ifdef CONFIG_USB_HCI
 		pxframe->pkt = NULL;
+#ifdef USB_PACKET_OFFSET_SZ
+		pxframe->pkt_offset = 0;
+#else
 		pxframe->pkt_offset = 1;//default use pkt_offset to fill tx desc
+#endif
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 		pxframe->agg_num = 1;
@@ -3538,7 +3542,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 			
 			//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);//tx bc/mc packets after upate bcn
+			update_beacon(padapter, _TIM_IE_, NULL, _TRUE);//tx bc/mc packets after upate bcn
 			
 			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);				
 			
@@ -3603,7 +3607,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 				{
 					//DBG_871X("sleepq_len==1, update BCNTIM\n");
 					//upate BCN for TIM IE
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 				}
 			}
 
@@ -3644,18 +3648,20 @@ static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
 		plist = get_next(plist);	
-		
+
+		pattrib = &pxmitframe->attrib;
+
+		pattrib->triggered = 0;
+        
 		ret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);	
 
 		if(_TRUE == ret)
 		{
-		pattrib = &pxmitframe->attrib;
+		    ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
-		ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
-
-		ptxservq->qcnt--;
-		phwxmits[ac_index].accnt--;		
-	}
+		    ptxservq->qcnt--;
+		    phwxmits[ac_index].accnt--;		
+		}
 		else
 		{
 			//DBG_871X("xmitframe_enqueue_for_sleeping_sta return _FALSE\n");
@@ -3872,7 +3878,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 				psta->state ^= WIFI_SLEEP_STATE;
 
 			goto _exit;
-	}	
+		}	
 #endif //CONFIG_TDLS
 		pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
@@ -3902,7 +3908,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	{
 		//update_BCNTIM(padapter);
 		//printk("%s => call update_beacon\n",__FUNCTION__);
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+		update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 	}	
 	
 }
@@ -3994,7 +4000,7 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
 			//upate BCN for TIM IE
 			//update_BCNTIM(padapter);
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+			update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 			//update_mask = BIT(0);
 		}
 	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11AC.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11AC.h
new file mode 100644
index 000000000000..5c10ea57e809
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11AC.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__ODM_REGDEFINE11AC_H__
+#define __ODM_REGDEFINE11AC_H__
+
+//2 RF REG LIST
+
+
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
+#define	ODM_REG_BB_RX_PATH_11AC			0x808
+#define	ODM_REG_DBG_RPT_11AC				0x8fc
+//PAGE 9
+#define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+#define	ODM_REG_NHM_TIMER_11AC			0x990
+#define	ODM_REG_NHM_TH9_TH10_11AC			0x994
+#define	ODM_REG_NHM_TH3_TO_TH0_11AC		0x998
+#define	ODM_REG_NHM_TH7_TO_TH4_11AC		0x99c
+#define	ODM_REG_NHM_TH8_11AC				0x9a0
+#define	ODM_REG_NHM_9E8_11AC				0x9e8
+//PAGE A
+#define	ODM_REG_CCK_CCA_11AC			0xA0A
+#define	ODM_REG_CCK_FA_RST_11AC			0xA2C
+#define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE C
+#define	ODM_REG_TRMUX_11AC				0xC08
+#define	ODM_REG_IGI_A_11AC				0xC50
+//PAGE E
+#define	ODM_REG_IGI_B_11AC				0xE50
+//PAGE F
+#define	ODM_REG_OFDM_FA_11AC			0xF48
+#define	ODM_REG_RPT_11AC					0xfa0
+#define	ODM_REG_NHM_CNT_11AC			0xfa8
+//PAGE 18
+#define	ODM_REG_IGI_C_11AC				0x1850
+//PAGE 1A
+#define	ODM_REG_IGI_D_11AC				0x1A50
+
+//2 MAC REG LIST
+#define	ODM_REG_RESP_TX_11AC				0x6D8
+
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11AC					0xFFFFFFFF
+#define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT16
+#define	ODM_BIT_BB_RX_PATH_11AC			0xF
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11N.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11N.h
new file mode 100644
index 000000000000..55b93f318ae2
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_RegDefine11N.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__ODM_REGDEFINE11N_H__
+#define __ODM_REGDEFINE11N_H__
+
+
+//2 RF REG LIST
+#define	ODM_REG_RF_MODE_11N				0x00
+#define	ODM_REG_RF_0B_11N				0x0B
+#define	ODM_REG_CHNBW_11N				0x18
+#define	ODM_REG_T_METER_11N				0x24
+#define	ODM_REG_RF_25_11N				0x25
+#define	ODM_REG_RF_26_11N				0x26
+#define	ODM_REG_RF_27_11N				0x27
+#define	ODM_REG_RF_2B_11N				0x2B
+#define	ODM_REG_RF_2C_11N				0x2C
+#define	ODM_REG_RXRF_A3_11N				0x3C
+#define	ODM_REG_T_METER_92D_11N			0x42
+#define	ODM_REG_T_METER_88E_11N			0x42
+
+
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_BB_CTRL_11N				0x800
+#define	ODM_REG_RF_PIN_11N				0x804
+#define	ODM_REG_PSD_CTRL_11N				0x808
+#define	ODM_REG_TX_ANT_CTRL_11N			0x80C
+#define	ODM_REG_BB_PWR_SAV5_11N			0x818
+#define	ODM_REG_CCK_RPT_FORMAT_11N		0x824
+#define	ODM_REG_RX_DEFUALT_A_11N		0x858
+#define	ODM_REG_RX_DEFUALT_B_11N		0x85A
+#define	ODM_REG_BB_PWR_SAV3_11N			0x85C
+#define	ODM_REG_ANTSEL_CTRL_11N			0x860
+#define	ODM_REG_RX_ANT_CTRL_11N			0x864
+#define	ODM_REG_PIN_CTRL_11N				0x870
+#define	ODM_REG_BB_PWR_SAV1_11N			0x874
+#define	ODM_REG_ANTSEL_PATH_11N			0x878
+#define	ODM_REG_BB_3WIRE_11N			0x88C
+#define	ODM_REG_SC_CNT_11N				0x8C4
+#define	ODM_REG_PSD_DATA_11N			0x8B4
+#define	ODM_REG_PSD_DATA_11N			0x8B4
+#define	ODM_REG_NHM_TIMER_11N			0x894
+#define	ODM_REG_NHM_TH9_TH10_11N		0x890
+#define	ODM_REG_NHM_TH3_TO_TH0_11N		0x898
+#define	ODM_REG_NHM_TH7_TO_TH4_11N		0x89c
+#define	ODM_REG_NHM_CNT_11N				0x8d8
+//PAGE 9
+#define	ODM_REG_DBG_RPT_11N				0x908
+#define	ODM_REG_ANT_MAPPING1_11N		0x914
+#define	ODM_REG_ANT_MAPPING2_11N		0x918
+//PAGE A
+#define	ODM_REG_CCK_ANTDIV_PARA1_11N	0xA00
+#define	ODM_REG_CCK_CCA_11N				0xA0A
+#define	ODM_REG_CCK_ANTDIV_PARA2_11N	0xA0C
+#define	ODM_REG_CCK_ANTDIV_PARA3_11N	0xA10
+#define	ODM_REG_CCK_ANTDIV_PARA4_11N	0xA14
+#define	ODM_REG_CCK_FILTER_PARA1_11N	0xA22
+#define	ODM_REG_CCK_FILTER_PARA2_11N	0xA23
+#define	ODM_REG_CCK_FILTER_PARA3_11N	0xA24
+#define	ODM_REG_CCK_FILTER_PARA4_11N	0xA25
+#define	ODM_REG_CCK_FILTER_PARA5_11N	0xA26
+#define	ODM_REG_CCK_FILTER_PARA6_11N	0xA27
+#define	ODM_REG_CCK_FILTER_PARA7_11N	0xA28
+#define	ODM_REG_CCK_FILTER_PARA8_11N	0xA29
+#define	ODM_REG_CCK_FA_RST_11N			0xA2C
+#define	ODM_REG_CCK_FA_MSB_11N			0xA58
+#define	ODM_REG_CCK_FA_LSB_11N			0xA5C
+#define	ODM_REG_CCK_CCA_CNT_11N			0xA60
+#define	ODM_REG_BB_PWR_SAV4_11N			0xA74
+//PAGE B
+#define	ODM_REG_LNA_SWITCH_11N			0xB2C
+#define	ODM_REG_PATH_SWITCH_11N			0xB30
+#define	ODM_REG_RSSI_CTRL_11N			0xB38
+#define	ODM_REG_CONFIG_ANTA_11N			0xB68
+#define	ODM_REG_RSSI_BT_11N				0xB9C
+//PAGE C
+#define	ODM_REG_OFDM_FA_HOLDC_11N		0xC00
+#define	ODM_REG_BB_RX_PATH_11N			0xC04
+#define	ODM_REG_TRMUX_11N				0xC08
+#define	ODM_REG_OFDM_FA_RSTC_11N		0xC0C
+#define	ODM_REG_RXIQI_MATRIX_11N		0xC14
+#define	ODM_REG_TXIQK_MATRIX_LSB1_11N	0xC4C
+#define	ODM_REG_IGI_A_11N				0xC50
+#define	ODM_REG_ANTDIV_PARA2_11N		0xC54
+#define	ODM_REG_IGI_B_11N					0xC58
+#define	ODM_REG_ANTDIV_PARA3_11N		0xC5C
+#define   ODM_REG_L1SBD_PD_CH_11N			0XC6C
+#define	ODM_REG_BB_PWR_SAV2_11N		0xC70
+#define	ODM_REG_RX_OFF_11N				0xC7C
+#define	ODM_REG_TXIQK_MATRIXA_11N		0xC80
+#define	ODM_REG_TXIQK_MATRIXB_11N		0xC88
+#define	ODM_REG_TXIQK_MATRIXA_LSB2_11N	0xC94
+#define	ODM_REG_TXIQK_MATRIXB_LSB2_11N	0xC9C
+#define	ODM_REG_RXIQK_MATRIX_LSB_11N	0xCA0
+#define	ODM_REG_ANTDIV_PARA1_11N		0xCA4
+#define	ODM_REG_OFDM_FA_TYPE1_11N		0xCF0
+//PAGE D
+#define	ODM_REG_OFDM_FA_RSTD_11N		0xD00
+#define	ODM_REG_OFDM_FA_TYPE2_11N		0xDA0
+#define	ODM_REG_OFDM_FA_TYPE3_11N		0xDA4
+#define	ODM_REG_OFDM_FA_TYPE4_11N		0xDA8
+#define	ODM_REG_RPT_11N					0xDF4
+//PAGE E
+#define	ODM_REG_TXAGC_A_6_18_11N		0xE00
+#define	ODM_REG_TXAGC_A_24_54_11N		0xE04
+#define	ODM_REG_TXAGC_A_1_MCS32_11N	0xE08
+#define	ODM_REG_TXAGC_A_MCS0_3_11N		0xE10
+#define	ODM_REG_TXAGC_A_MCS4_7_11N		0xE14
+#define	ODM_REG_TXAGC_A_MCS8_11_11N	0xE18
+#define	ODM_REG_TXAGC_A_MCS12_15_11N	0xE1C
+#define	ODM_REG_FPGA0_IQK_11N			0xE28
+#define	ODM_REG_TXIQK_TONE_A_11N		0xE30
+#define	ODM_REG_RXIQK_TONE_A_11N		0xE34
+#define	ODM_REG_TXIQK_PI_A_11N			0xE38
+#define	ODM_REG_RXIQK_PI_A_11N			0xE3C
+#define	ODM_REG_TXIQK_11N				0xE40
+#define	ODM_REG_RXIQK_11N				0xE44
+#define	ODM_REG_IQK_AGC_PTS_11N			0xE48
+#define	ODM_REG_IQK_AGC_RSP_11N			0xE4C
+#define	ODM_REG_BLUETOOTH_11N			0xE6C
+#define	ODM_REG_RX_WAIT_CCA_11N			0xE70
+#define	ODM_REG_TX_CCK_RFON_11N			0xE74
+#define	ODM_REG_TX_CCK_BBON_11N			0xE78
+#define	ODM_REG_OFDM_RFON_11N			0xE7C
+#define	ODM_REG_OFDM_BBON_11N			0xE80
+#define 	ODM_REG_TX2RX_11N				0xE84
+#define	ODM_REG_TX2TX_11N				0xE88
+#define	ODM_REG_RX_CCK_11N				0xE8C
+#define	ODM_REG_RX_OFDM_11N				0xED0
+#define	ODM_REG_RX_WAIT_RIFS_11N		0xED4
+#define	ODM_REG_RX2RX_11N				0xED8
+#define	ODM_REG_STANDBY_11N				0xEDC
+#define	ODM_REG_SLEEP_11N				0xEE0
+#define	ODM_REG_PMPD_ANAEN_11N			0xEEC
+#define	ODM_REG_IGI_C_11N					0xF84
+#define	ODM_REG_IGI_D_11N					0xF88
+
+//2 MAC REG LIST
+#define	ODM_REG_BB_RST_11N				0x02
+#define	ODM_REG_ANTSEL_PIN_11N			0x4C
+#define	ODM_REG_EARLY_MODE_11N			0x4D0
+#define	ODM_REG_RSSI_MONITOR_11N		0x4FE
+#define	ODM_REG_EDCA_VO_11N				0x500
+#define	ODM_REG_EDCA_VI_11N				0x504
+#define	ODM_REG_EDCA_BE_11N				0x508
+#define	ODM_REG_EDCA_BK_11N				0x50C
+#define	ODM_REG_TXPAUSE_11N				0x522
+#define	ODM_REG_RESP_TX_11N				0x6D8
+#define	ODM_REG_ANT_TRAIN_PARA1_11N	0x7b0
+#define	ODM_REG_ANT_TRAIN_PARA2_11N	0x7b4
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11N					0x0000007F
+#define	ODM_BIT_CCK_RPT_FORMAT_11N		BIT9
+#define	ODM_BIT_BB_RX_PATH_11N			0xF
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_debug.h
new file mode 100644
index 000000000000..6a69ee6791c5
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/OUTSRC/odm_debug.h
@@ -0,0 +1,893 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__ODM_DBG_H__
+#define __ODM_DBG_H__
+
+
+//-----------------------------------------------------------------------------
+//	Define the debug levels
+//
+//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
+//	So that, they can help SW engineer to develope or trace states changed 
+//	and also help HW enginner to trace every operation to and from HW, 
+//	e.g IO, Tx, Rx. 
+//
+//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
+//	which help us to debug SW or HW.
+//
+//-----------------------------------------------------------------------------
+//
+//	Never used in a call to ODM_RT_TRACE()!
+//
+#define ODM_DBG_OFF					1
+
+//
+//	Fatal bug. 
+//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
+//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
+//
+#define ODM_DBG_SERIOUS				2
+
+//
+//	Abnormal, rare, or unexpeted cases.
+//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
+//
+#define ODM_DBG_WARNING				3
+
+//
+//	Normal case with useful information about current SW or HW state. 
+//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
+//	SW protocol state change, dynamic mechanism state change and so on.
+//
+#define ODM_DBG_LOUD					4
+
+//
+//	Normal case with detail execution flow or information.
+//
+#define ODM_DBG_TRACE					5
+
+//-----------------------------------------------------------------------------
+// Define the tracing components
+//
+//-----------------------------------------------------------------------------
+//BB Functions
+#define ODM_COMP_DIG				BIT0	
+#define ODM_COMP_RA_MASK			BIT1	
+#define ODM_COMP_DYNAMIC_TXPWR		BIT2
+#define ODM_COMP_FA_CNT				BIT3
+#define ODM_COMP_RSSI_MONITOR		BIT4
+#define ODM_COMP_CCK_PD				BIT5
+#define ODM_COMP_ANT_DIV			BIT6
+#define ODM_COMP_PWR_SAVE			BIT7
+#define ODM_COMP_PWR_TRAIN			BIT8
+#define ODM_COMP_RATE_ADAPTIVE		BIT9
+#define ODM_COMP_PATH_DIV			BIT10
+#define ODM_COMP_PSD				BIT11
+#define ODM_COMP_DYNAMIC_PRICCA		BIT12
+#define ODM_COMP_RXHP				BIT13			
+#define ODM_COMP_MP					BIT14
+#define ODM_COMP_DYNAMIC_ATC			BIT15
+//MAC Functions
+#define ODM_COMP_EDCA_TURBO			BIT16
+#define ODM_COMP_EARLY_MODE			BIT17
+//RF Functions
+#define ODM_COMP_TX_PWR_TRACK		BIT24
+#define ODM_COMP_RX_GAIN_TRACK		BIT25
+#define ODM_COMP_CALIBRATION		BIT26
+//Common Functions
+#define ODM_COMP_COMMON				BIT30
+#define ODM_COMP_INIT				BIT31
+
+/*------------------------Export Marco Definition---------------------------*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#define RT_PRINTK				DbgPrint
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#define DbgPrint	printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+	#define	RT_DISP(dbgtype, dbgflag, printstr)
+#else
+	#define DbgPrint	panic_printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+#endif
+
+#ifndef ASSERT
+	#define ASSERT(expr)
+#endif
+
+#define ODM_DBG 1
+#if ODM_DBG
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)									\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel || level == ODM_DBG_SERIOUS))	\
+		{																			\
+			RT_PRINTK fmt;															\
+		}
+
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)									\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+		{																			\
+			RT_PRINTK fmt;															\
+		}
+
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)											\
+		if(!(expr)) {																	\
+			DbgPrint( "Assertion failed! %s at ......\n", #expr);								\
+			DbgPrint( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);			\
+			RT_PRINTK fmt;															\
+			ASSERT(FALSE);															\
+		}
+#define ODM_dbg_enter() { DbgPrint("==> %s\n", __FUNCTION__); }
+#define ODM_dbg_exit() { DbgPrint("<== %s\n", __FUNCTION__); }
+#define ODM_dbg_trace(str) { DbgPrint("%s:%s\n", __FUNCTION__, str); }
+
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)							\
+			if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	__ptr = (pu1Byte)ptr;											\
+				DbgPrint("[ODM] ");													\
+				DbgPrint(title_str);													\
+				DbgPrint(" ");														\
+				for( __i=0; __i<6; __i++ )												\
+					DbgPrint("%02X%s", __ptr[__i], (__i==5)?"":"-");						\
+				DbgPrint("\n");														\
+			}
+#else
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)
+#define ODM_dbg_enter()
+#define ODM_dbg_exit()
+#define ODM_dbg_trace(str)
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)
+#endif
+
+
+VOID 
+ODM_InitDebugSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+
+
+#if 0
+#if DBG
+#define DbgPrint printk
+
+#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)								\
+			{																		\
+				char			*szTitle = _TitleString;									\
+				pu1Byte		pbtHexData = _HexData;									\
+				u4Byte		u4bHexDataLen = _HexDataLen;							\
+				u4Byte		__i;														\
+				DbgPrint("%s", szTitle);													\
+				for (__i=0;__i<u4bHexDataLen;__i++)									\
+				{																	\
+					if ((__i & 15) == 0) 												\
+					{																\
+						DbgPrint("\n");												\
+					}																\
+					DbgPrint("%02X%s", pbtHexData[__i], ( ((__i&3)==3) ? "  " : " ") );		\
+				}																	\
+				DbgPrint("\n");														\
+			}
+
+// RT_PRINT_XXX macros: implemented for debugging purpose.
+// Added by Annie, 2005-11-21.
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
+			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	ptr = (pu1Byte)_HexData;										\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				for( __i=0; __i<(int)_HexDataLen; __i++ )								\
+				{																	\
+					DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");			\
+					if (((__i + 1) % 16) == 0)	DbgPrint("\n");							\
+				}																	\
+				DbgPrint("\n");														\
+			}
+
+#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)								\
+			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	ptr = (pu1Byte)_Ptr;											\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint(" ");															\
+				for( __i=0; __i<6; __i++ )												\
+					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");							\
+				DbgPrint("\n");														\
+			}
+
+#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)					\
+			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
+			{																		\
+				int __i, __j;															\
+				pu1Byte	ptr = (pu1Byte)_Ptr;											\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint("\n");														\
+				for( __i=0; __i<(int)_AddNum; __i++ )									\
+				{																	\
+					for( __j=0; __j<6; __j++ )											\
+						DbgPrint("%02X%s", ptr[__i*6+__j], (__j==5)?"":"-");				\
+					DbgPrint("\n");													\
+				}																	\
+			}
+
+// Added by Annie, 2005-11-22.
+#define	MAX_STR_LEN	64
+#define	PRINTABLE(_ch)	(_ch>=' ' &&_ch<='~' )	// I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.
+
+#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)							\
+			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
+			{																		\
+				int		__i;															\
+				u1Byte	buffer[MAX_STR_LEN];											\
+				int	length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;				\
+				PlatformZeroMemory( buffer, MAX_STR_LEN );							\
+				PlatformMoveMemory( buffer, (pu1Byte)_Ptr, length );						\
+				for( __i=0; __i<MAX_STR_LEN; __i++ )									\
+				{																	\
+					if( !PRINTABLE(buffer[__i]) )	buffer[__i] = '?';						\
+				}																	\
+				buffer[length] = '\0';													\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint(": %d, <%s>\n", _Len, buffer);									\
+			}
+			
+#else	// of #if DBG
+#define DbgPrint(...)	
+#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)
+#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)
+#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)
+#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)
+#endif	// of #if DBG
+
+#endif	
+
+
+#if 0
+/* Define debug print header for every service module.*/
+typedef struct tag_ODM_DBGP_Service_Module_Header_Name_Structure
+{
+	const char 	*pMANS;
+	const char 	*pRTOS;
+	const char 	*pALM;
+	const char 	*pPEM;
+	const char 	*pCMPK;
+	const char 	*pRAPD;
+	const char 	*pTXPB;
+	const char 	*pQUMG;
+}ODM_DBGP_HEAD_T;
+
+
+/* Define different debug flag for dedicated service modules in debug flag array. */
+// Each module has independt 32 bit debug flag you cnn define the flag as yout require.
+typedef enum tag_ODM_DBGP_Flag_Type_Definition
+{
+	ODM_FTX				= 0,
+	ODM_FRX				,	
+	ODM_FPHY				,
+	ODM_FPWR				,
+	ODM_FDM				,
+	ODM_FC2H				,
+	ODM_FBT				,
+	ODM_DBGP_TYPE_MAX
+}ODM_DBGP_FLAG_E;
+
+
+// Define TX relative debug bit				--> FTX
+#define		ODM_TX_DESC			BIT0
+#define		ODM_TX_DESC_TID		BIT1
+#define		ODM_TX_PATH			BIT2
+
+// Define RX relative debug  bit				--> FRX
+#define		ODM_RX_DATA				BIT0	
+#define		ODM_RX_PHY_STS			BIT1
+#define		ODM_RX_PHY_SS				BIT2
+#define		ODM_RX_PHY_SQ				BIT3
+#define		ODM_RX_PHY_ASTS			BIT4
+#define		ODM_RX_ERR_LEN			BIT5
+#define		ODM_RX_DEFRAG				BIT6
+#define		ODM_RX_ERR_RATE			BIT7
+#define		ODM_RX_PATH				BIT8
+#define		ODM_RX_BEACON				BIT9
+
+// Define PHY-BB/RF/MAC check module bit		--> FPHY
+#define		ODM_PHY_BBR				BIT0
+#define		ODM_PHY_BBW				BIT1
+#define		ODM_PHY_RFR				BIT2
+#define		ODM_PHY_RFW				BIT3
+#define		ODM_PHY_MACR				BIT4
+#define		ODM_PHY_MACW				BIT5
+#define		ODM_PHY_ALLR				BIT6
+#define		ODM_PHY_ALLW				BIT7
+#define		ODM_PHY_TXPWR			BIT8
+#define		ODM_PHY_PWRDIFF			BIT9
+#define		ODM_PHY_SICR				BIT10
+#define		ODM_PHY_SICW				BIT11
+
+
+
+
+extern	u4Byte ODM_GlobalDebugLevel;
+
+
+#if DBG
+extern	u8Byte ODM_GlobalDebugComponents;
+#endif
+#endif
+#if 0
+
+//-----------------------------------------------------------------------------
+//	Define the debug levels
+//
+//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
+//	So that, they can help SW engineer to develope or trace states changed 
+//	and also help HW enginner to trace every operation to and from HW, 
+//	e.g IO, Tx, Rx. 
+//
+//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
+//	which help us to debug SW or HW.
+//
+//-----------------------------------------------------------------------------
+//
+//	Never used in a call to ODM_RT_TRACE(pDM_Odm,)!
+//
+#define DBG_OFF					0
+
+//
+//	Deprecated! Don't use it! 
+//	TODO: fix related debug message!
+//
+//#define DBG_SEC					1
+
+//
+//	Fatal bug. 
+//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
+//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
+//
+#define DBG_SERIOUS				2
+
+//
+//	Abnormal, rare, or unexpeted cases.
+//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
+//
+#define DBG_WARNING				3
+
+//
+//	Normal case with useful information about current SW or HW state. 
+//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
+//	SW protocol state change, dynamic mechanism state change and so on.
+//
+#define DBG_LOUD				4
+
+//
+//	Normal case with detail execution flow or information.
+//
+#define DBG_TRACE				5
+
+
+
+//-----------------------------------------------------------------------------
+// Define the tracing components
+//
+//-----------------------------------------------------------------------------
+#define COMP_TRACE				BIT0		// For function call tracing.
+#define COMP_DBG				BIT1		// Only for temporary debug message.
+#define COMP_INIT				BIT2		// during driver initialization / halt / reset.
+#define COMP_OID_QUERY				BIT3		// Query OID.
+#define COMP_OID_SET				BIT4		// Set OID.
+#define COMP_RECV				BIT5		// Reveive part data path.
+#define COMP_SEND				BIT6		// Send part path.
+#define COMP_IO					BIT7		// I/O Related. Added by Annie, 2006-03-02.
+#define COMP_POWER				BIT8		// 802.11 Power Save mode or System/Device Power state related.
+#define COMP_MLME				BIT9		// 802.11 link related: join/start BSS, leave BSS.
+#define COMP_SCAN				BIT10	// For site survey.
+#define COMP_SYSTEM				BIT11	// For general platform function.
+#define COMP_SEC				BIT12	// For Security.
+#define COMP_AP					BIT13	// For AP mode related.
+#define COMP_TURBO				BIT14	// For Turbo Mode related. By Annie, 2005-10-21.
+#define COMP_QOS				BIT15	// For QoS.
+#define COMP_AUTHENTICATOR			BIT16	// For AP mode Authenticator. Added by Annie, 2006-01-30.
+#define COMP_BEACON				BIT17	// For Beacon related, by rcnjko.
+#define COMP_ANTENNA				BIT18	// For Antenna diversity related, by rcnjko. 
+#define COMP_RATE				BIT19	// For Rate Adaptive mechanism, 2006.07.02, by rcnjko. #define COMP_EVENTS				0x00000080	// Event handling
+#define COMP_EVENTS				BIT20	// Event handling
+#define COMP_FPGA				BIT21	// For FPGA verfication 
+#define COMP_RM					BIT22	// For Radio Measurement. 
+#define COMP_MP					BIT23	// For mass production test, by shien chang, 2006.07.13
+#define COMP_RXDESC				BIT24	// Show Rx desc information for SD3 debug. Added by Annie, 2006-07-15.
+#define COMP_CKIP				BIT25	// For CCX 1 S13: CKIP. Added by Annie, 2006-08-14.
+#define COMP_DIG				BIT26	// For DIG, 2006.09.25, by rcnjko.
+#define COMP_TXAGC				BIT27	// For Tx power, 060928, by rcnjko. 
+#define COMP_HIPWR				BIT28	// For High Power Mechanism, 060928, by rcnjko. 
+#define COMP_HALDM				BIT29	// For HW Dynamic Mechanism, 061010, by rcnjko. 
+#define COMP_RSNA				BIT30	// For RSNA IBSS , 061201, by CCW. 
+#define COMP_INDIC				BIT31	// For link indication
+#define COMP_LED				BIT32	// For LED.
+#define COMP_RF					BIT33	// For RF.
+//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
+//1//1Attention Please!!!<11n or 8190 specific code should be put below this line>
+//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+#define COMP_HT					BIT34	// For 802.11n HT related information. by Emily 2006-8-11
+#define COMP_POWER_TRACKING			BIT35	//FOR 8190 TX POWER TRACKING
+#define COMP_RX_REORDER				BIT36	// 8190 Rx Reorder
+#define COMP_AMSDU				BIT37	// For A-MSDU Debugging
+#define COMP_WPS				BIT38   //WPS Debug Message 
+#define COMP_RATR				BIT39	
+#define COMP_RESET				BIT40
+// For debug command to print on dbgview!!
+#define COMP_CMD				BIT41
+#define COMP_EFUSE				BIT42
+#define COMP_MESH_INTERWORKING 			BIT43
+#define COMP_CCX				BIT44	//CCX Debug Flag
+#define	COMP_IOCTL				BIT45	// IO Control
+#define COMP_GP					BIT46	// For generic parser.
+#define COMP_TXAGG				BIT47
+#define COMP_HVL                            	BIT48     // For Ndis 6.2 Context Swirch and Hardware Virtualiztion Layer
+#define COMP_TEST				BIT49
+#define COMP_BB_POWERSAVING	BIT50
+#define COMP_SWAS				BIT51	// For SW Antenna Switch
+#define COMP_P2P				BIT52
+#define COMP_MUX				BIT53
+#define COMP_FUNC				BIT54
+#define COMP_TDLS				BIT55
+#define COMP_OMNIPEEK			BIT56
+#define COMP_DUALMACSWITCH	BIT60	// 2010/12/27 Add for Dual mac mode debug
+#define COMP_EASY_CONCURRENT	BIT61	// 2010/12/27 Add for easy cncurrent mode debug
+#define COMP_PSD				BIT63	//2011/3/9 Add for WLAN PSD for BT AFH
+
+#define COMP_DFS                                BIT62
+
+#define	COMP_ALL				UINT64_C(0xFFFFFFFFFFFFFFFF) // All components
+// For debug print flag to use
+/*------------------------------Define structure----------------------------*/
+/* 2007/07/13 MH  *//*------For DeBuG Print modeue------*/
+
+/* Defnie structure to store different debug flag variable. Every debug flag 
+     is a UINT32 integer and you can assign 32 different events. */
+typedef struct tag_DBGP_Debug_Flag_Structure
+{
+	u4Byte	Mans;			/* Main Scheduler module. */
+	u4Byte	Rtos;			/* RTOS module. */
+	u4Byte	Alarm;		/* Alarm module. */	
+	u4Byte	Pm;			/* Performance monitor module. */	
+}DBGP_FLAG_T;
+
+/* Define debug print header for every service module.*/
+typedef struct tag_DBGP_Service_Module_Header_Name_Structure
+{
+	const char 	*pMANS;
+	const char 	*pRTOS;
+	const char 	*pALM;
+	const char 	*pPEM;
+	const char 	*pCMPK;
+	const char 	*pRAPD;
+	const char 	*pTXPB;
+	const char 	*pQUMG;
+}DBGP_HEAD_T;
+
+
+/* Define different debug flag for dedicated service modules in debug flag array. */
+// Each module has independt 32 bit debug flag you cnn define the flag as yout require.
+typedef enum tag_DBGP_Flag_Type_Definition
+{
+	FQoS				= 0,	
+	FTX					= 1,
+	FRX					= 2,	
+	FSEC				= 3,
+	FMGNT				= 4,
+	FMLME				= 5,
+	FRESOURCE			= 6,
+	FBEACON				= 7,
+	FISR				= 8,
+	FPHY				= 9,
+	FMP					= 10,
+	FEEPROM			= 11,
+	FPWR				= 12,
+	FDM					= 13,
+	FDBG_CTRL			= 14,
+	FC2H				= 15,
+	FBT					= 16,
+	FINIT				= 17,
+	FIOCTL				= 18,
+	FSHORT_CUT			= 19,
+	DBGP_TYPE_MAX
+}DBGP_FLAG_E;
+
+
+// Define Qos Relative debug flag bit		--> FQoS
+#define		QoS_INIT			BIT0
+#define		QoS_VISTA			BIT1
+
+// Define TX relative debug bit				--> FTX
+#define		TX_DESC			BIT0
+#define		TX_DESC_TID		BIT1
+#define		TX_PATH			BIT2
+
+// Define RX relative debug  bit				--> FRX
+#define		RX_DATA				BIT0	
+#define		RX_PHY_STS				BIT1
+#define		RX_PHY_SS				BIT2
+#define		RX_PHY_SQ				BIT3
+#define		RX_PHY_ASTS			BIT4
+#define		RX_ERR_LEN			BIT5
+#define		RX_DEFRAG			BIT6
+#define		RX_ERR_RATE			BIT7
+#define		RX_PATH				BIT8
+#define		RX_BEACON				BIT9
+
+// Define Security relative debug  bit			--> FSEC
+
+// Define MGNT relative debug bit			--> FMGNT
+
+// Define MLME relative debug bit				--> FMLME
+#define		MEDIA_STS			BIT0
+#define		LINK_STS			BIT1
+
+// Define OS resource check module bit		--> FRESOURCE
+#define		OS_CHK				BIT0
+
+// Define beacon content check module bit		--> FBEACON
+#define		BCN_SHOW			BIT0
+#define		BCN_PEER			BIT1
+
+// Define ISR/IMR check module bit		--> FISR
+#define		ISR_CHK				BIT0
+
+// Define PHY-BB/RF/MAC check module bit		--> FPHY
+#define		PHY_BBR				BIT0
+#define		PHY_BBW				BIT1
+#define		PHY_RFR				BIT2
+#define		PHY_RFW				BIT3
+#define		PHY_MACR				BIT4
+#define		PHY_MACW				BIT5
+#define		PHY_ALLR				BIT6
+#define		PHY_ALLW				BIT7
+#define		PHY_TXPWR				BIT8
+#define		PHY_PWRDIFF			BIT9
+#define		PHY_SICR				BIT10
+#define		PHY_SICW				BIT11
+
+// Define MPT driver check module bit		--> FMP
+#define		MP_RX					BIT0
+#define		MP_SWICH_CH			BIT1
+
+// Define EEPROM and EFUSE  check module bit		--> FEEPROM
+#define		EEPROM_W					BIT0
+#define		EFUSE_PG					BIT1
+#define		EFUSE_READ_ALL			BIT2
+#define		EFUSE_ANALYSIS				BIT3
+#define		EFUSE_PG_DETAIL			BIT4
+
+// Define power save  check module bit		--> FPWR
+#define		LPS					BIT0
+#define		IPS					BIT1
+#define		PWRSW				BIT2
+#define		PWRHW				BIT3
+#define		PWRHAL				BIT4
+
+// Define Dynamic Mechanism check module bit		--> FDM
+#define		WA_IOT				BIT0
+#define		DM_PWDB			BIT1
+#define		DM_Monitor			BIT2
+#define		DM_DIG				BIT3
+#define		DM_EDCA_Turbo		BIT4
+#define		DM_BT30			BIT5
+
+// Define Dbg Control module bit		--> FDBG_CTRL
+#define		DBG_CTRL_TRACE			BIT0
+#define		DBG_CTRL_INBAND_NOISE	BIT1
+
+// Define FW C2H Cmd check module bit		--> FC2H
+#define		C2H_Summary				BIT0
+#define		C2H_PacketData				BIT1
+#define		C2H_ContentData			BIT2
+// Define BT Cmd check module bit		--> FBT
+#define		BT_TRACE					BIT0
+#define		BT_RFPoll					BIT1
+
+// Define init check for module bit		--> FINIT
+#define		INIT_EEPROM				BIT0
+#define		INIT_TxPower				BIT1
+#define		INIT_IQK					BIT2
+#define		INIT_RF						BIT3
+
+// Define IOCTL Cmd check module bit		--> FIOCTL
+// section 1 : IRP related
+#define		IOCTL_IRP						BIT0
+#define		IOCTL_IRP_DETAIL				BIT1
+#define		IOCTL_IRP_STATISTICS			BIT2
+#define		IOCTL_IRP_HANDLE				BIT3
+// section 2 : HCI command/event
+#define		IOCTL_BT_HCICMD				BIT8
+#define		IOCTL_BT_HCICMD_DETAIL		BIT9
+#define		IOCTL_BT_HCICMD_EXT			BIT10
+#define		IOCTL_BT_EVENT					BIT11
+#define		IOCTL_BT_EVENT_DETAIL			BIT12
+#define		IOCTL_BT_EVENT_PERIODICAL		BIT13
+// section 3 : BT tx/rx data and throughput
+#define		IOCTL_BT_TX_ACLDATA			BIT16
+#define		IOCTL_BT_TX_ACLDATA_DETAIL	BIT17
+#define		IOCTL_BT_RX_ACLDATA			BIT18
+#define		IOCTL_BT_RX_ACLDATA_DETAIL	BIT19
+#define		IOCTL_BT_TP					BIT20
+// section 4 : BT connection state machine.
+#define 		IOCTL_STATE					BIT21	
+#define		IOCTL_BT_LOGO					BIT22
+// section 5 : BT function trace
+#define		IOCTL_CALLBACK_FUN			BIT24
+#define		IOCTL_PARSE_BT_PKT			BIT25
+#define		IOCTL_BT_TX_PKT				BIT26
+#define		IOCTL_BT_FLAG_MON				BIT27
+
+//
+// Define init check for module bit		--> FSHORT_CUT
+// 2011/07/20 MH Add for short but definition.
+//
+#define		SHCUT_TX				BIT0
+#define		SHCUT_RX				BIT1
+
+
+/* 2007/07/13 MH  *//*------For DeBuG Print modeue------*/
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+#if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
+#define RT_PRINTK(fmt, args...)    printk( "%s(): " fmt, __FUNCTION__, ## args);
+
+#if DBG
+#define ODM_RT_TRACE(pDM_Odm,comp, level, fmt)											\
+		if(((comp) & GlobalDebugComponents) && (level <= GlobalDebugLevel))	\
+		{																	\
+			RT_PRINTK fmt;													\
+		}
+
+#define RT_TRACE_F(comp, level, fmt)											\
+		if(((comp) & GlobalDebugComponents) && (level <= GlobalDebugLevel))	\
+		{																	\
+			RT_PRINTK fmt;													\
+		}
+
+#define RT_ASSERT(expr,fmt)													\
+		if(!(expr)) {															\
+			printk( "Assertion failed! %s at ......\n", #expr);							\
+			printk( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);	\
+		}
+#define dbg_enter() { printk("==> %s\n", __FUNCTION__); }
+#define dbg_exit() { printk("<== %s\n", __FUNCTION__); }
+#define dbg_trace(str) { printk("%s:%s\n", __FUNCTION__, str); }
+#else
+#define ODM_RT_TRACE(pDM_Odm,comp, level, fmt)
+#define RT_TRACE_F(comp, level, fmt)
+#define RT_ASSERT(expr, fmt)
+#define dbg_enter()
+#define dbg_exit()
+#define dbg_trace(str)
+#endif
+
+#if DBG
+#define DbgPrint printk
+
+#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)								\
+			{																		\
+				char			*szTitle = _TitleString;									\
+				pu1Byte		pbtHexData = _HexData;									\
+				u4Byte		u4bHexDataLen = _HexDataLen;							\
+				u4Byte		__i;														\
+				DbgPrint("%s", szTitle);													\
+				for (__i=0;__i<u4bHexDataLen;__i++)									\
+				{																	\
+					if ((__i & 15) == 0) 												\
+					{																\
+						DbgPrint("\n");												\
+					}																\
+					DbgPrint("%02X%s", pbtHexData[__i], ( ((__i&3)==3) ? "  " : " ") );		\
+				}																	\
+				DbgPrint("\n");														\
+			}
+
+// RT_PRINT_XXX macros: implemented for debugging purpose.
+// Added by Annie, 2005-11-21.
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
+			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	ptr = (pu1Byte)_HexData;										\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				for( __i=0; __i<(int)_HexDataLen; __i++ )								\
+				{																	\
+					DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");			\
+					if (((__i + 1) % 16) == 0)	DbgPrint("\n");							\
+				}																	\
+				DbgPrint("\n");														\
+			}
+
+#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)								\
+			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	ptr = (pu1Byte)_Ptr;											\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint(" ");															\
+				for( __i=0; __i<6; __i++ )												\
+					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");							\
+				DbgPrint("\n");														\
+			}
+
+#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)					\
+			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+			{																		\
+				int __i, __j;															\
+				pu1Byte	ptr = (pu1Byte)_Ptr;											\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint("\n");														\
+				for( __i=0; __i<(int)_AddNum; __i++ )									\
+				{																	\
+					for( __j=0; __j<6; __j++ )											\
+						DbgPrint("%02X%s", ptr[__i*6+__j], (__j==5)?"":"-");				\
+					DbgPrint("\n");													\
+				}																	\
+			}
+
+// Added by Annie, 2005-11-22.
+#define	MAX_STR_LEN	64
+#define	PRINTABLE(_ch)	(_ch>=' ' &&_ch<='~' )	// I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.
+
+#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)							\
+			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+			{																		\
+				int		__i;															\
+				u1Byte	buffer[MAX_STR_LEN];											\
+				int	length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;				\
+				PlatformZeroMemory( buffer, MAX_STR_LEN );							\
+				PlatformMoveMemory( buffer, (pu1Byte)_Ptr, length );						\
+				for( __i=0; __i<MAX_STR_LEN; __i++ )									\
+				{																	\
+					if( !PRINTABLE(buffer[__i]) )	buffer[__i] = '?';						\
+				}																	\
+				buffer[length] = '\0';													\
+				DbgPrint("Rtl819x: ");													\
+				DbgPrint(_TitleString);												\
+				DbgPrint(": %d, <%s>\n", _Len, buffer);									\
+			}
+			
+#else	// of #if DBG
+#define DbgPrint(...)	
+#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)
+#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)
+#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)
+#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)
+#endif	// of #if DBG
+
+
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
+
+#define		DEBUG_PRINT				1
+
+// Please add new OS's print API by yourself
+
+//#if (RT_PLATFORM==PLATFORM_WINDOWS) 
+#if (DEBUG_PRINT == 1) && DBG
+#define	RT_DISP(dbgtype, dbgflag, printstr)\
+{\
+	if (DBGP_Type[dbgtype] & dbgflag)\
+	{\
+		DbgPrint printstr;\
+	}\
+}
+
+#define	RT_DISP_ADDR(dbgtype, dbgflag, printstr, _Ptr)\
+{\
+	if (DBGP_Type[dbgtype] & dbgflag)\
+	{\
+				int __i;						\
+				pu1Byte	ptr = (pu1Byte)_Ptr;	\
+				DbgPrint printstr;				\
+				DbgPrint(" ");					\
+				for( __i=0; __i<6; __i++ )		\
+					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");		\
+				DbgPrint("\n");							\
+	}\
+}
+
+#define RT_DISP_DATA(dbgtype, dbgflag, _TitleString, _HexData, _HexDataLen)\
+{\
+	if (DBGP_Type[dbgtype] & dbgflag)\
+	{\
+		int __i;									\
+		pu1Byte	ptr = (pu1Byte)_HexData;			\
+		DbgPrint(_TitleString);					\
+		for( __i=0; __i<(int)_HexDataLen; __i++ )	\
+		{										\
+			DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");\
+			if (((__i + 1) % 16) == 0)	DbgPrint("\n");\
+		}										\
+		DbgPrint("\n");							\
+	}\
+}
+
+#define FunctionIn(_comp)		ODM_RT_TRACE(pDM_Odm,(_comp), DBG_LOUD, ("==========> %s\n",  __FUNCTION__))
+#define FunctionOut(_comp)		ODM_RT_TRACE(pDM_Odm,(_comp), DBG_LOUD, ("<========== %s\n",  __FUNCTION__))
+
+
+#else
+
+#define	RT_DISP(dbgtype, dbgflag, printstr)
+#define	RT_DISP_ADDR(dbgtype, dbgflag, printstr, _Ptr)
+#define   RT_DISP_DATA(dbgtype, dbgflag, _TitleString, _HexData, _HexDataLen)
+
+#define FunctionIn(_comp)
+#define FunctionOut(_comp)
+#endif
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+extern	u4Byte			DBGP_Type[DBGP_TYPE_MAX];
+extern	DBGP_HEAD_T	DBGP_Head;
+
+/*------------------------Export global variable----------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+extern	void	DBGP_Flag_Init(void);
+extern	void	DBG_PrintAllFlag(void);
+extern	void	DBG_PrintAllComp(void);
+extern	void	DBG_PrintFlagEvent(u1Byte	DbgFlag);
+extern	void	DBG_DumpMem(const u1Byte DbgComp, 
+							const u1Byte DbgLevel, 
+							pu1Byte pMem, 
+							u2Byte Len);
+
+/*--------------------------Exported Function prototype---------------------*/
+
+
+
+
+
+
+
+
+
+extern u4Byte GlobalDebugLevel;
+extern u8Byte GlobalDebugComponents;
+
+
+#endif
+
+
+#endif	// __ODM_DBG_H__
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.c
index f0afda743777..c314d5227329 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.c
@@ -30,6 +30,493 @@
 #include <rtl8192d_hal.h>
 #endif
 
+#define u1Byte		u8
+#define pu1Byte 	u8* 
+
+#define u2Byte		u16
+#define pu2Byte 	u16*		
+
+#define u4Byte		u32
+#define pu4Byte 	u32*	
+
+#define u8Byte		u64
+#define pu8Byte 	u64*
+
+#define s1Byte		s8
+#define ps1Byte 	s8* 
+
+#define s2Byte		s16
+#define ps2Byte 	s16*	
+
+#define s4Byte		s32
+#define ps4Byte 	s32*	
+
+#define s8Byte		s64
+#define ps8Byte 	s64*
+
+typedef enum _ODM_RF_RADIO_PATH {
+    ODM_RF_PATH_A = 0,   //Radio Path A
+    ODM_RF_PATH_B = 1,   //Radio Path B
+    ODM_RF_PATH_C = 2,   //Radio Path C
+    ODM_RF_PATH_D = 3,   //Radio Path D
+    ODM_RF_PATH_AB,
+    ODM_RF_PATH_AC,
+    ODM_RF_PATH_AD,
+    ODM_RF_PATH_BC,
+    ODM_RF_PATH_BD,
+    ODM_RF_PATH_CD,
+    ODM_RF_PATH_ABC,
+    ODM_RF_PATH_ACD,
+    ODM_RF_PATH_BCD,
+    ODM_RF_PATH_ABCD,
+  //  ODM_RF_PATH_MAX,    //Max RF number 90 support
+} ODM_RF_RADIO_PATH_E, *PODM_RF_RADIO_PATH_E;
+
+#define	ODM_AP		 	0x01	//BIT0 
+#define	ODM_ADSL	 	0x02	//BIT1
+#define	ODM_CE		 	0x04	//BIT2
+#define	ODM_WIN		 	0x08	//BIT3
+
+#define	DM_ODM_SUPPORT_TYPE			ODM_CE
+
+typedef enum tag_ODM_Support_Interface_Definition
+{
+	ODM_ITRF_PCIE 	=	0x1,
+	ODM_ITRF_USB 	=	0x2,
+	ODM_ITRF_SDIO 	=	0x4,
+	ODM_ITRF_ALL 	=	0x7,
+}ODM_INTERFACE_E;
+
+typedef enum tag_ODM_Support_IC_Type_Definition
+{
+	ODM_RTL8192S 	=	BIT0,
+	ODM_RTL8192C 	=	BIT1,
+	ODM_RTL8192D 	=	BIT2,
+	ODM_RTL8723A 	=	BIT3,
+	ODM_RTL8188E 	=	BIT4,
+	ODM_RTL8812 	=	BIT5,
+	ODM_RTL8821 	=	BIT6,
+	ODM_RTL8192E 	=	BIT7,	
+	ODM_RTL8723B	=	BIT8,
+	ODM_RTL8813A	=	BIT9,	
+	ODM_RTL8881A 	=	BIT10
+}ODM_IC_TYPE_E;
+
+#define ODM_IC_11N_SERIES		(ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B)
+#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8813A|ODM_RTL8881A)
+
+u1Byte
+ODM_Read1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R8(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read8(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead1Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+u2Byte
+ODM_Read2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R16(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read16(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead2Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+u4Byte
+ODM_Read4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	return	RTL_R32(RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return rtw_read32(Adapter,RegAddr);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return	PlatformEFIORead4Byte(Adapter, RegAddr);
+#endif	
+
+}
+
+
+VOID
+ODM_Write1Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W8(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write8(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite1Byte(Adapter, RegAddr, Data);
+#endif
+	
+}
+
+
+VOID
+ODM_Write2Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W16(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write16(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite2Byte(Adapter, RegAddr, Data);
+#endif	
+
+}
+
+
+VOID
+ODM_Write4Byte(
+	IN 	PDM_ODM_T		pDM_Odm,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	RTL_W32(RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	rtw_write32(Adapter,RegAddr, Data);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PlatformEFIOWrite4Byte(Adapter, RegAddr, Data);
+#endif	
+
+}
+
+
+VOID
+ODM_SetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PHY_SetBBReg(pDM_Odm->priv, RegAddr, BitMask, Data);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetMACReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryMacReg(pDM_Odm->priv, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return PHY_QueryMacReg(Adapter, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	return PHY_QueryBBReg(pDM_Odm->Adapter, RegAddr, BitMask);
+#endif	
+}
+
+
+VOID
+ODM_SetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask,
+	IN	u4Byte		Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PHY_SetBBReg(pDM_Odm->priv, RegAddr, BitMask, Data);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetBBReg(	
+	IN 	PDM_ODM_T	pDM_Odm,
+	IN	u4Byte		RegAddr,
+	IN	u4Byte		BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryBBReg(pDM_Odm->priv, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return PHY_QueryBBReg(Adapter, RegAddr, BitMask);
+#endif	
+}
+
+
+VOID
+ODM_SetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask,
+	IN	u4Byte				Data
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PHY_SetRFReg(pDM_Odm->priv, eRFPath, RegAddr, BitMask, Data);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
+#endif	
+}
+
+
+u4Byte 
+ODM_GetRFReg(	
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	ODM_RF_RADIO_PATH_E	eRFPath,
+	IN	u4Byte				RegAddr,
+	IN	u4Byte				BitMask
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	return PHY_QueryRFReg(pDM_Odm->priv, eRFPath, RegAddr, BitMask, 1);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	return PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
+#endif	
+}
+
+
+#include "OUTSRC/odm_RegDefine11N.h"
+#include "OUTSRC/odm_RegDefine11AC.h"
+#include "OUTSRC/odm_debug.h"
+
+VOID 
+ODM_InitDebugSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+pDM_Odm->DebugLevel				= 	ODM_DBG_LOUD;
+
+pDM_Odm->DebugComponents			= 
+\
+#if ODM_DBG
+//BB Functions
+//									ODM_COMP_DIG					|
+//									ODM_COMP_RA_MASK				|
+//									ODM_COMP_DYNAMIC_TXPWR		|
+//									ODM_COMP_FA_CNT				|
+//									ODM_COMP_RSSI_MONITOR			|
+//									ODM_COMP_CCK_PD				|
+//									ODM_COMP_ANT_DIV				|
+//									ODM_COMP_PWR_SAVE				|
+//									ODM_COMP_PWR_TRAIN			|
+//									ODM_COMP_RATE_ADAPTIVE		|
+//									ODM_COMP_PATH_DIV				|
+//									ODM_COMP_DYNAMIC_PRICCA		|
+//									ODM_COMP_RXHP					|
+//									ODM_COMP_MP 					|
+//									ODM_COMP_DYNAMIC_ATC		|
+
+//MAC Functions
+//									ODM_COMP_EDCA_TURBO			|
+//									ODM_COMP_EARLY_MODE			|
+//RF Functions
+//									ODM_COMP_TX_PWR_TRACK		|
+//									ODM_COMP_RX_GAIN_TRACK		|
+//									ODM_COMP_CALIBRATION			|
+//Common
+//									ODM_COMP_COMMON				|
+//									ODM_COMP_INIT					|
+//									ODM_COMP_PSD					|
+#endif
+									0;
+}
+
+const char *odm_comp_str[] = {
+	/* BIT0 */"ODM_COMP_DIG",
+	/* BIT1 */"ODM_COMP_RA_MASK",
+	/* BIT2 */"ODM_COMP_DYNAMIC_TXPWR",
+	/* BIT3 */"ODM_COMP_FA_CNT",
+	/* BIT4 */"ODM_COMP_RSSI_MONITOR",
+	/* BIT5 */"ODM_COMP_CCK_PD",
+	/* BIT6 */"ODM_COMP_ANT_DIV",
+	/* BIT7 */"ODM_COMP_PWR_SAVE",
+	/* BIT8 */"ODM_COMP_PWR_TRAIN",
+	/* BIT9 */"ODM_COMP_RATE_ADAPTIVE",
+	/* BIT10 */"ODM_COMP_PATH_DIV",
+	/* BIT11 */"ODM_COMP_PSD",
+	/* BIT12 */"ODM_COMP_DYNAMIC_PRICCA",
+	/* BIT13 */"ODM_COMP_RXHP",
+	/* BIT14 */"ODM_COMP_MP",
+	/* BIT15 */"ODM_COMP_DYNAMIC_ATC",
+	/* BIT16 */"ODM_COMP_EDCA_TURBO",
+	/* BIT17 */"ODM_COMP_EARLY_MODE",
+	/* BIT18 */NULL,
+	/* BIT19 */NULL,
+	/* BIT20 */NULL,
+	/* BIT21 */NULL,
+	/* BIT22 */NULL,
+	/* BIT23 */NULL,
+	/* BIT24 */"ODM_COMP_TX_PWR_TRACK",
+	/* BIT25 */"ODM_COMP_RX_GAIN_TRACK",
+	/* BIT26 */"ODM_COMP_CALIBRATION",
+	/* BIT27 */NULL,
+	/* BIT28 */NULL,
+	/* BIT29 */NULL,
+	/* BIT30 */"ODM_COMP_COMMON",
+	/* BIT31 */"ODM_COMP_INIT",
+};
+
+#define RTW_ODM_COMP_MAX 32
+
+const char *odm_dbg_level_str[] = {
+	NULL,
+	"ODM_DBG_OFF",
+	"ODM_DBG_SERIOUS",
+	"ODM_DBG_WARNING",
+	"ODM_DBG_LOUD",
+	"ODM_DBG_TRACE",
+};
+
+#define RTW_ODM_DBG_LEVEL_NUM 6
+
+void rtw_odm_dbg_comp_msg(void *sel, _adapter *adapter)
+{
+	DM_ODM_T *odm = adapter_to_odm(adapter);
+	int cnt = 0;
+	u64 dbg_comp;
+	int i;
+
+	dbg_comp = odm->DebugComponents;
+	DBG_871X_SEL_NL(sel, "odm.DebugComponents = 0x%016llx \n", dbg_comp);
+	for (i=0;i<RTW_ODM_COMP_MAX;i++) {
+		if (odm_comp_str[i])
+		DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
+			(BIT0 << i) & dbg_comp ? '+' : ' ', i, odm_comp_str[i]);
+	}
+}
+
+inline void rtw_odm_dbg_comp_set(_adapter *adapter, u64 comps)
+{
+	DM_ODM_T *odm = adapter_to_odm(adapter);
+	odm->DebugComponents = comps;
+}
+
+void rtw_odm_dbg_level_msg(void *sel, _adapter *adapter)
+{
+	DM_ODM_T *odm = adapter_to_odm(adapter);
+	int cnt = 0;
+	u32 dbg_level;
+	int i;
+
+	dbg_level = odm->DebugLevel;
+	DBG_871X_SEL_NL(sel, "odm.DebugLevel = %u\n", dbg_level);
+	for (i=0;i<RTW_ODM_DBG_LEVEL_NUM;i++) {
+		if (odm_dbg_level_str[i])
+			DBG_871X_SEL_NL(sel, "%u %s\n", i, odm_dbg_level_str[i]);
+	}
+}
+
+inline void rtw_odm_dbg_level_set(_adapter *adapter, u32 level)
+{
+	DM_ODM_T *odm = adapter_to_odm(adapter);
+	odm->DebugLevel= level;
+}
+
+const char *dm_ability_str[] = {
+	/* BIT0 */"DYNAMIC_FUNC_DIG",
+	/* BIT1 */"DYNAMIC_FUNC_HP",
+	/* BIT2 */"DYNAMIC_FUNC_SS",
+	/* BIT3 */"DYNAMIC_FUNC_BT",
+	/* BIT4 */"DYNAMIC_FUNC_ANT_DIV",
+#ifdef CONFIG_ODM_ADAPTIVITY
+	/* BIT5 */"DYNAMIC_FUNC_ADAPTIVITY",
+#endif
+};
+
+#ifdef CONFIG_ODM_ADAPTIVITY
+#define RTW_DM_ABILITY_MAX 6
+#else
+#define RTW_DM_ABILITY_MAX 5
+#endif
+
+void rtw_dm_check_rxfifo_full(_adapter *adapter)
+{
+	struct dvobj_priv *psdpriv = adapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	//check RX fifo counter
+	rtw_write8(adapter, REG_RXERR_RPT+3, rtw_read8(adapter, REG_RXERR_RPT+3)|0xa0);
+	pdbgpriv->dbg_rx_fifo_last_overflow = pdbgpriv->dbg_rx_fifo_curr_overflow;
+	pdbgpriv->dbg_rx_fifo_curr_overflow = rtw_read16(adapter, REG_RXERR_RPT);
+	pdbgpriv->dbg_rx_fifo_diff_overflow = pdbgpriv->dbg_rx_fifo_curr_overflow-pdbgpriv->dbg_rx_fifo_last_overflow;
+}
+
+void rtw_dm_ability_msg(void *sel, _adapter *adapter)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
+	int cnt = 0;
+	u8 ability = 0;
+	int i;
+
+	rtw_hal_get_hwreg(adapter, HW_VAR_DM_FLAG, (u8*)&ability);
+	DBG_871X_SEL_NL(sel, "dm.DMFlag = 0x%02x\n", ability);
+	for (i=0;i<RTW_DM_ABILITY_MAX;i++) {
+		if (dm_ability_str[i])
+		DBG_871X_SEL_NL(sel, "%cBIT%-2d %s\n",
+			(BIT0 << i) & ability ? '+' : ' ', i, dm_ability_str[i]);
+	}
+}
+
+inline void rtw_dm_ability_set(_adapter *adapter, u8 ability)
+{
+	rtw_hal_set_hwreg(adapter, HW_VAR_DM_FLAG, (u8*)&ability);
+}
+
 bool rtw_adapter_linked(_adapter *adapter)
 {
 	bool linked = _FALSE;
@@ -66,120 +553,347 @@ bool dm_linked(_adapter *adapter)
 	return linked;
 }
 
-#if 0
-void dm_enable_EDCCA(_adapter *adapter)
+/* v4 branch doesn't have common traffic_stat in dvobj */
+u64 dev_tx_uncast_bytes(_adapter *adapter)
 {
-	// Enable EDCCA. The value is suggested by SD3 Wilson.
+	u64	tx_bytes = 0;
 
-	//
-	// Revised for ASUS 11b/g performance issues, suggested by BB Neil, 2012.04.13.
-	//
-	/*if((pDM_Odm->SupportICType == ODM_RTL8723A)&&(IS_WIRELESS_MODE_G(pAdapter)))
-	{
-		rtw_write8(adapter,rOFDM0_ECCAThreshold,0x00);
-		rtw_write8(adapter,rOFDM0_ECCAThreshold+2,0xFD);
-		
-	}	
-	else*/
-	{
-		rtw_write8(adapter,rOFDM0_ECCAThreshold,0x03);
-		rtw_write8(adapter,rOFDM0_ECCAThreshold+2,0x00);
-	}
+	tx_bytes += adapter->xmitpriv.tx_bytes;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((adapter = adapter->pbuddy_adapter) == NULL)
+		goto exit;
+	tx_bytes += adapter->xmitpriv.tx_bytes;
+#endif
+
+exit:
+	return tx_bytes;
 }
 
-void dm_disable_EDCCA(_adapter *adapter)
-{	
-	// Disable EDCCA..
-	rtw_write8(adapter, rOFDM0_ECCAThreshold, 0x7f);
-	rtw_write8(adapter, rOFDM0_ECCAThreshold+2, 0x7f);
+u64 dev_rx_uncast_bytes(_adapter *adapter)
+{
+	u64	rx_bytes = 0;
+
+	rx_bytes += adapter->recvpriv.rx_bytes;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((adapter = adapter->pbuddy_adapter) == NULL)
+		goto exit;
+	rx_bytes += adapter->recvpriv.rx_bytes;
+#endif
+
+exit:
+	return rx_bytes;
+}
+
+void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter)
+{
+#ifdef CONFIG_ODM_ADAPTIVITY
+	DM_ODM_T *odm = adapter_to_odm(adapter);
+
+	DBG_871X_SEL_NL(sel, "%10s %16s %8s %10s %11s %14s\n"
+		, "TH_L2H_ini", "TH_EDCCA_HL_diff", "IGI_Base", "ForceEDCCA", "AdapEn_RSSI", "IGI_LowerBound");
+	DBG_871X_SEL_NL(sel, "0x%-8x %-16d 0x%-6x %-10d %-11u %-14u\n"
+		, (u8)odm->TH_L2H_ini
+		, odm->TH_EDCCA_HL_diff
+		, odm->IGI_Base
+		, odm->ForceEDCCA
+		, odm->AdapEn_RSSI
+		, odm->IGI_LowerBound
+	);
+#endif /* CONFIG_ODM_ADAPTIVITY */
+}
+
+void rtw_odm_adaptivity_parm_set(_adapter *pAdapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
+	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound)
+{
+#ifdef CONFIG_ODM_ADAPTIVITY
+	DM_ODM_T *odm = adapter_to_odm(pAdapter);
+
+	odm->TH_L2H_ini = TH_L2H_ini;
+	odm->TH_EDCCA_HL_diff = TH_EDCCA_HL_diff;
+	odm->IGI_Base = IGI_Base;
+	odm->ForceEDCCA = ForceEDCCA;
+	odm->AdapEn_RSSI = AdapEn_RSSI;
+	odm->IGI_LowerBound = IGI_LowerBound;
+
+#endif /* CONFIG_ODM_ADAPTIVITY */
+}
+
+#ifdef CONFIG_ODM_ADAPTIVITY
+VOID
+odm_NHMBBInit(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	pDM_Odm->adaptivity_flag = 0;
+	pDM_Odm->tolerance_cnt = 3;
+	pDM_Odm->NHMLastTxOkcnt = 0;
+	pDM_Odm->NHMLastRxOkcnt = 0;
+	pDM_Odm->NHMCurTxOkcnt = 0;
+	pDM_Odm->NHMCurRxOkcnt = 0;
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		{
+		//PHY parameters initialize for ac series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC+2, 0x2710);	//0x990[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC+2, 0xffff);	//0x994[31:16]=0xffff	th_9, th_10
+		//ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff5c);	//0x998=0xffffff5c 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff52);	//0x998=0xffffff52 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffffff);	//0x99c=0xffffffff		th_7, th_6, th_5, th_4
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH8_11AC, bMaskByte0, 0xff);		//0x9a0[7:0]=0xff		th_8
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8|BIT9|BIT10, 7);	//0x994[9:8]=3			enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_9E8_11AC, BIT0, 1);		//0x9e8[7]=1			max power among all RX ants	
+				
+		//panic_printk("RTL8812AU phy parameters init %s,%d\n", __FUNCTION__, __LINE__);
+		}
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		{
+		//PHY parameters initialize for n series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0x2710);	//0x894[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		//ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0x4e20);	//0x894[31:16]=0x4e20	Time duration for NHM unit: 4us, 0x4e20=80ms
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);	//0x890[31:16]=0xffff	th_9, th_10
+		//ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff5c);	//0x898=0xffffff5c 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff52);	//0x898=0xffffff52 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);	//0x89c=0xffffffff		th_7, th_6, th_5, th_4
+		ODM_SetBBReg(pDM_Odm, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		//0xe28[7:0]=0xff		th_8
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 7);	//0x890[9:8]=3			enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 1);		//0xc0c[7]=1			max power among all RX ants				
+		}
+
 }
 
 //
-// Description: According to initial gain value to determine to enable or disable EDCCA.
-//
-// Suggested by SD3 Wilson. Added by tynli. 2011.11.25.
-//
-void dm_dynamic_EDCCA(_adapter *pAdapter)
+VOID
+odm_NHMBB(
+	IN		PVOID			pDM_VOID
+)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	_adapter *adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv *dmpriv = &pHalData->dmpriv;
-	u8 RegC50, RegC58;
+
+	u1Byte	NHM_cnt_0;//, NHM_cnt_1;
+	u4Byte	value32 = 0;
+	u64 tx_unicast_bytes;
+	u64 rx_unicast_bytes;
+	//u1Byte 	test_status;
+	//PFALSE_ALARM_STATISTICS pFalseAlmCnt = &(dmpriv->FalseAlmCnt);
 	
-	RegC50 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0);
-	RegC58 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0);
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11AC, bMaskDWord);
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11N, bMaskDWord);
 
+	NHM_cnt_0= (u1Byte)(value32 & bMaskByte0);
+	//NHM_cnt_1= (u1Byte)((value32 & bMaskByte1)>>8);
 
- 	if((RegC50 > 0x28 && RegC58 > 0x28)
-  		/*|| ((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26))
-  		|| (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28)*/
-  	)
+	tx_unicast_bytes = dev_tx_uncast_bytes(adapter);
+	rx_unicast_bytes = dev_rx_uncast_bytes(adapter);
+	
+	pDM_Odm->NHMCurTxOkcnt = tx_unicast_bytes - pDM_Odm->NHMLastTxOkcnt;
+	pDM_Odm->NHMCurRxOkcnt = rx_unicast_bytes - pDM_Odm->NHMLastRxOkcnt;
+	pDM_Odm->NHMLastTxOkcnt = tx_unicast_bytes;
+	pDM_Odm->NHMLastRxOkcnt = rx_unicast_bytes;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("NHM_cnt_0=%d, NHMCurTxOkcnt = %llu, NHMCurRxOkcnt = %llu\n", 
+		NHM_cnt_0, pDM_Odm->NHMCurTxOkcnt, pDM_Odm->NHMCurRxOkcnt));
+
+	
+	if ( (pDM_Odm->NHMCurTxOkcnt) + 1 > (u8Byte)(pDM_Odm->NHMCurRxOkcnt<<2) + 1)		//Tx > 4*Rx possible for adaptivity test
 	{
-		if(!dmpriv->bPreEdccaEnable)
+		if(NHM_cnt_0 >= 190 || pDM_Odm->adaptivity_flag == _TRUE)
+		{
+			//Enable EDCCA since it is possible running Adaptivity testing
+			//test_status = 1;
+			pDM_Odm->adaptivity_flag = _TRUE;
+			ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	//don't ignore EDCCA	 reg520[15]=0
+			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);	//reg524[11]=1	
+			pDM_Odm->tolerance_cnt = 0;
+            	}
+		else
 		{
-			dm_enable_EDCCA(pAdapter);
-			dmpriv->bPreEdccaEnable = _TRUE;
+			if(pDM_Odm->tolerance_cnt<3)
+				pDM_Odm->tolerance_cnt = pDM_Odm->tolerance_cnt + 1;
+			else
+				pDM_Odm->tolerance_cnt = 4;	
+			//test_status = 5;
+			if(pDM_Odm->tolerance_cnt > 3)
+			{
+				//test_status = 3;
+				ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	//ignore EDCCA	reg520[15]=1
+				ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);		//reg524[11]=0
+				pDM_Odm->adaptivity_flag = _FALSE;
+			}
 		}
-		
 	}
-	else if((RegC50 < 0x25 && RegC58 < 0x25)
-		/*|| (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25)*/
-	)
+	else	// TX<RX 
 	{
-		if(dmpriv->bPreEdccaEnable)
+		if(pDM_Odm->adaptivity_flag == _TRUE && NHM_cnt_0 <= 200)
+		{
+			//test_status = 2;
+			ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	//don't ignore EDCCA	 reg520[15]=0
+			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);	//reg524[11]=1	
+			pDM_Odm->tolerance_cnt = 0;
+		}
+		else
 		{
-			dm_disable_EDCCA(pAdapter);
-			dmpriv->bPreEdccaEnable = _FALSE;
+			if(pDM_Odm->tolerance_cnt<3)
+				pDM_Odm->tolerance_cnt = pDM_Odm->tolerance_cnt + 1;
+			else
+				pDM_Odm->tolerance_cnt = 4;	
+			//test_status = 5;
+			if(pDM_Odm->tolerance_cnt >3)
+			{
+				//test_status = 4;
+				ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	//ignore EDCCA	reg520[15]=1
+				ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);		//reg524[11]=0
+				pDM_Odm->adaptivity_flag = _FALSE;
+			}
 		}
 	}
+	 
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("adaptivity_flag = %d\n", pDM_Odm->adaptivity_flag));
+
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)	//disable enable NHX
+	{           		
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 0);
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 1);
+	}	
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
+	}
 }
-#endif
 
-#define DM_ADAPTIVITY_VER "ADAPTIVITY_V001"
 
-int dm_adaptivity_get_parm_str(_adapter *pAdapter, char *buf, int len)
+VOID
+ODM_Write_DIG(
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	u1Byte			CurrentIGI
+	)
 {
-#ifdef CONFIG_DM_ADAPTIVITY
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(pAdapter);
+	_adapter *adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv *dmpriv = &pHalData->dmpriv;
+	DIG_T *pDigTable = &dmpriv->DM_DigTable;
 
-	return snprintf(buf, len, DM_ADAPTIVITY_VER"\n"
-		"TH_L2H_ini\tTH_EDCCA_HL_diff\tIGI_Base\tForceEDCCA\tAdapEn_RSSI\tIGI_LowerBound\n"
-		"0x%02x\t%d\t0x%02x\t%d\t%u\t%u\n",
-		(u8)dmpriv->TH_L2H_ini,
-		dmpriv->TH_EDCCA_HL_diff,
-		dmpriv->IGI_Base,
-		dmpriv->ForceEDCCA,
-		dmpriv->AdapEn_RSSI,
-		dmpriv->IGI_LowerBound
-	);
-#endif /* CONFIG_DM_ADAPTIVITY */
-	return 0;
+	if(pDigTable->CurIGValue != CurrentIGI) {
+		pDigTable->CurIGValue = CurrentIGI;
+		rtw_warn_on(!pDM_Odm->write_dig);
+		if (pDM_Odm->write_dig)
+			pDM_Odm->write_dig(adapter);
+	}
 }
 
-void dm_adaptivity_set_parm(_adapter *pAdapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
-	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound)
+VOID
+odm_SearchPwdBLowerBound(
+	IN		PVOID		pDM_VOID,
+	IN		u1Byte		IGI_target
+)
 {
-#ifdef CONFIG_DM_ADAPTIVITY
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(pAdapter);
-	struct dm_priv *dmpriv = &pHalData->dmpriv;
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			value32 =0;
+	u1Byte			cnt, IGI;
+	BOOLEAN			bAdjust=_TRUE;
+	s1Byte 			TH_L2H_dmc, TH_H2L_dmc;
+	s1Byte 			TH_L2H, TH_H2L, Diff;
 
-	dmpriv->TH_L2H_ini = TH_L2H_ini;
-	dmpriv->TH_EDCCA_HL_diff = TH_EDCCA_HL_diff;
-	dmpriv->IGI_Base = IGI_Base;
-	dmpriv->ForceEDCCA = ForceEDCCA;
-	dmpriv->AdapEn_RSSI = AdapEn_RSSI;
-	dmpriv->IGI_LowerBound = IGI_LowerBound;
+	IGI = 0x50; // find H2L, L2H lower bound
+	ODM_Write_DIG(pDM_Odm, IGI);
+	
 
-#endif /* CONFIG_DM_ADAPTIVITY */
+	Diff = IGI_target -(s1Byte)IGI;
+	TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+		if(TH_L2H_dmc > 10) 	
+			TH_L2H_dmc = 10;
+	TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		{
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
+		}
+	else
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u1Byte)TH_H2L_dmc<<8) | (u1Byte)TH_L2H_dmc);
+					
+		rtw_mdelay_os(5);
+		
+		while(bAdjust)
+			{
+			for(cnt=0; cnt<20; cnt ++)
+				{
+				if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+					value32 = ODM_GetBBReg(pDM_Odm,ODM_REG_RPT_11N, bMaskDWord);
+				else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+					value32 = ODM_GetBBReg(pDM_Odm,ODM_REG_RPT_11AC, bMaskDWord);
+			
+				if (value32 & BIT30 && (pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8723B|ODM_RTL8188E)))
+					pDM_Odm->txEdcca1 = pDM_Odm->txEdcca1 + 1;
+				else if(value32 & BIT29)
+					pDM_Odm->txEdcca1 = pDM_Odm->txEdcca1 + 1;
+				else
+					pDM_Odm->txEdcca0 = pDM_Odm->txEdcca0 + 1;
+				}
+			//DbgPrint("txEdcca1 = %d, txEdcca0 = %d\n", pDM_Odm->txEdcca1, pDM_Odm->txEdcca0);
+			
+				if(pDM_Odm->txEdcca1 > 5 )
+				{
+					IGI = IGI -1;
+					TH_L2H_dmc = TH_L2H_dmc + 1;
+						if(TH_L2H_dmc > 10)
+							TH_L2H_dmc = 10;
+					TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+					if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+					{
+						ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+						ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
+					}
+					else
+						ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u1Byte)TH_H2L_dmc<<8) | (u1Byte)TH_L2H_dmc);
+
+					pDM_Odm->TxHangFlg = _TRUE;
+					pDM_Odm->txEdcca1 = 0;
+					pDM_Odm->txEdcca0 = 0;
+
+					if(TH_L2H_dmc == 10)
+						{
+						bAdjust = _FALSE;
+						pDM_Odm->TxHangFlg = _FALSE;
+						pDM_Odm->txEdcca1 = 0;
+						pDM_Odm->txEdcca0 = 0;
+						pDM_Odm->H2L_lb = TH_H2L_dmc;
+						pDM_Odm->L2H_lb = TH_L2H_dmc;
+						pDM_Odm->Adaptivity_IGI_upper = IGI;
+						}
+					}
+				else
+				{
+					bAdjust = _FALSE;
+					pDM_Odm->TxHangFlg = _FALSE;
+					pDM_Odm->txEdcca1 = 0;
+					pDM_Odm->txEdcca0 = 0;
+					pDM_Odm->H2L_lb = TH_H2L_dmc;
+					pDM_Odm->L2H_lb = TH_L2H_dmc;	
+					pDM_Odm->Adaptivity_IGI_upper = IGI;
+				}
+			}
+
+							
+ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("IGI = 0x%x, H2L_lb = 0x%x, L2H_lb = 0x%x\n", IGI, pDM_Odm->H2L_lb , pDM_Odm->L2H_lb));
+		
 }
+#endif /* CONFIG_ODM_ADAPTIVITY */
 
-void dm_adaptivity_init(_adapter *pAdapter)
+VOID
+odm_AdaptivityInit(
+IN PDM_ODM_T pDM_Odm
+)
 {
-#ifdef CONFIG_DM_ADAPTIVITY
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(pAdapter);
-	struct dm_priv *dmpriv = &pHalData->dmpriv;
+#ifdef CONFIG_ODM_ADAPTIVITY
 
-	/*
 	if(pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
 		pDM_Odm->TH_L2H_ini = 0xf8; // -8
@@ -188,77 +902,185 @@ void dm_adaptivity_init(_adapter *pAdapter)
 	{
 		pDM_Odm->TH_L2H_ini = 0xf0; // -16
 	}
-	else */
+	else
 	{
-		dmpriv->TH_L2H_ini = 0xf9; // -7
+		pDM_Odm->TH_L2H_ini = 0xf7; // -9
 	}
+	
+	pDM_Odm->TH_EDCCA_HL_diff = 7;
+	pDM_Odm->IGI_Base = 0x32;
+	pDM_Odm->IGI_target = 0x1c;
+	pDM_Odm->ForceEDCCA = 0;
+	pDM_Odm->AdapEn_RSSI = 20;
 
-	dmpriv->TH_EDCCA_HL_diff = 7;
-	dmpriv->IGI_Base = 0x32;
-	dmpriv->IGI_target = 0x1c;
-	dmpriv->ForceEDCCA = 0;
-	dmpriv->AdapEn_RSSI = 20;
-	dmpriv->IGI_LowerBound = 0;
-
+	pDM_Odm->NHM_disable = _FALSE;
+	pDM_Odm->TxHangFlg = _TRUE;
+	pDM_Odm->txEdcca0 = 0;
+	pDM_Odm->txEdcca1 = 0;
+	pDM_Odm->H2L_lb= 0;
+	pDM_Odm->L2H_lb= 0;
+	pDM_Odm->Adaptivity_IGI_upper = 0;
+	odm_NHMBBInit(pDM_Odm);
 	//Reg524[11]=0 is easily to transmit packets during adaptivity test
-	PHY_SetBBReg(pAdapter, 0x524, BIT11, 1); // stop counting if EDCCA is asserted
 
-#endif /* CONFIG_DM_ADAPTIVITY */
+	ODM_SetBBReg(pDM_Odm, REG_RD_CTRL, BIT11, 1); // stop counting if EDCCA is asserted
+
+#endif /* CONFIG_ODM_ADAPTIVITY */
+}
+
+// Add by Neil Chen to enable edcca to MP Platform 
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+VOID
+odm_EnableEDCCA(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+
+	// This should be moved out of OUTSRC
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	// Enable EDCCA. The value is suggested by SD3 Wilson.
+
+	//
+	// Revised for ASUS 11b/g performance issues, suggested by BB Neil, 2012.04.13.
+	//
+	if((pDM_Odm->SupportICType == ODM_RTL8723A)&&(IS_WIRELESS_MODE_G(pAdapter)))
+	{
+		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x00);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x00);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0xFD);
+		
+	}	
+	else
+	{
+		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x03);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x03);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0x00);
+	}	
+	
+	//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold+2, 0x00);
+}
+
+VOID
+odm_DisableEDCCA(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{	
+	// Disable EDCCA..
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x7f);
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold+2, 0x7f);
+}
+
+//
+// Description: According to initial gain value to determine to enable or disable EDCCA.
+//
+// Suggested by SD3 Wilson. Added by tynli. 2011.11.25.
+//
+VOID
+odm_DynamicEDCCA(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u1Byte	RegC50, RegC58;
+	BOOLEAN		bFwCurrentInPSMode=FALSE;	
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
+
+	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
+	if(bFwCurrentInPSMode)
+		return;
+	
+	RegC50 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
+	RegC58 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0);
+
+
+ 	if((RegC50 > 0x28 && RegC58 > 0x28) ||
+  		((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26)) ||
+  		(pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28))
+	{
+		if(!pHalData->bPreEdccaEnable)
+		{
+			odm_EnableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = TRUE;
+		}
+		
+	}
+	else if((RegC50 < 0x25 && RegC58 < 0x25) || (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25))
+	{
+		if(pHalData->bPreEdccaEnable)
+		{
+			odm_DisableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = FALSE;
+		}
+	}
 }
 
-void dm_adaptivity(_adapter *pAdapter)
+
+#endif    // end MP platform support
+
+VOID
+odm_Adaptivity(
+	IN		PDM_ODM_T		pDM_Odm
+)
 {
-#ifdef CONFIG_DM_ADAPTIVITY
-	s8 TH_L2H_dmc, TH_H2L_dmc;
-	s8 TH_L2H, TH_H2L, Diff, IGI_target;
+#ifdef CONFIG_ODM_ADAPTIVITY
+	s1Byte TH_L2H_dmc, TH_H2L_dmc;
+	s1Byte Diff, IGI_target;
 	u32 value32;
-	BOOLEAN EDCCA_State;
+	BOOLEAN EDCCA_State = 0;
 
+	_adapter *pAdapter = pDM_Odm->Adapter;
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv *dmpriv = &pHalData->dmpriv;
 	DIG_T *pDigTable = &dmpriv->DM_DigTable;
 	u8 IGI = pDigTable->CurIGValue;
 	u8 RSSI_Min = pDigTable->Rssi_val_min;
-	HT_CHANNEL_WIDTH BandWidth = pHalData->CurrentChannelBW;
+	HT_CHANNEL_WIDTH BandWidth = rtw_get_oper_bw(pAdapter);
 
 	if (!(dmpriv->DMFlag & DYNAMIC_FUNC_ADAPTIVITY))
 	{
-		LOG_LEVEL(_drv_info_, "Go to odm_DynamicEDCCA() \n");
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Go to odm_DynamicEDCCA() \n"));
 		// Add by Neil Chen to enable edcca to MP Platform 
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 		// Adjust EDCCA.
-		/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-			dm_dynamic_EDCCA(pAdapter);
-		*/
+		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			odm_DynamicEDCCA(pDM_Odm);
+#endif
 		return;
 	}
-	LOG_LEVEL(_drv_info_, "odm_Adaptivity() =====> \n");
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_Adaptivity() =====> \n"));
 
-	LOG_LEVEL(_drv_info_, "ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
-		dmpriv->ForceEDCCA, dmpriv->IGI_Base, dmpriv->TH_L2H_ini, dmpriv->TH_EDCCA_HL_diff, dmpriv->AdapEn_RSSI);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
+		pDM_Odm->ForceEDCCA, pDM_Odm->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff, pDM_Odm->AdapEn_RSSI));
 
-	/*if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-		PHY_SetBBReg(0x800, BIT10, 0); //ADC_mask enable
-	*/
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0); //ADC_mask enable
 	
-	if(!dm_linked(pAdapter) || pHalData->CurrentChannel > 149) /* Band4 doesn't need adaptivity */
+	if(!dm_linked(pAdapter) || pHalData->CurrentChannel > 149) // Band4 doesn't need adaptivity
 	{
-		/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)*/
+		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
 		{
-			PHY_SetBBReg(pAdapter,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
-			PHY_SetBBReg(pAdapter,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
+			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
+			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
 		}
-		/*else
-		{
+		else
 			ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, (0x7f<<8) | 0x7f);
-		}*/
 		return;
 	}
 
-	if(!dmpriv->ForceEDCCA)
+#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)	
+		if(pMgntInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
+			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0a); 
+		else
+			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0e);
+#endif
+	if(!pDM_Odm->ForceEDCCA)
 	{
-		if(RSSI_Min > dmpriv->AdapEn_RSSI)
+		if(RSSI_Min > pDM_Odm->AdapEn_RSSI)
 			EDCCA_State = 1;
-		else if(RSSI_Min < (dmpriv->AdapEn_RSSI - 5))
+		else if(RSSI_Min < (pDM_Odm->AdapEn_RSSI - 5))
 			EDCCA_State = 0;
 	}
 	else
@@ -269,46 +1091,97 @@ void dm_adaptivity(_adapter *pAdapter)
 	{
 
 		if(BandWidth == HT_CHANNEL_WIDTH_20) //CHANNEL_WIDTH_20
-			IGI_target = dmpriv->IGI_Base;
+			IGI_target = pDM_Odm->IGI_Base;
 		else if(BandWidth == HT_CHANNEL_WIDTH_40)
-			IGI_target = dmpriv->IGI_Base + 2;
+			IGI_target = pDM_Odm->IGI_Base + 2;
 		/*else if(*pDM_Odm->pBandWidth == ODM_BW80M)
 			IGI_target = pDM_Odm->IGI_Base + 6;*/
 		else
-			IGI_target = dmpriv->IGI_Base;
+			IGI_target = pDM_Odm->IGI_Base;
 	}
 
-	dmpriv->IGI_target = (u8)IGI_target;
+	pDM_Odm->IGI_target = (u1Byte) IGI_target;
 
-	LOG_LEVEL(_drv_info_, "BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d\n",
-		(BandWidth==HT_CHANNEL_WIDTH_40)?"40M":"20M", IGI_target, EDCCA_State);
+	//Search pwdB lower bound
+	if(pDM_Odm->TxHangFlg == _TRUE)
+	{
+		if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			ODM_SetBBReg(pDM_Odm,ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
+		else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+			ODM_SetBBReg(pDM_Odm,ODM_REG_DBG_RPT_11AC, bMaskDWord, 0x209);
+
+		odm_SearchPwdBLowerBound(pDM_Odm, IGI_target);
+	}
+
+	if(dm_linked(pAdapter) && pDM_Odm->TxHangFlg == _FALSE &&pDM_Odm->NHM_disable == _FALSE)
+		odm_NHMBB(pDM_Odm);
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d\n",
+		(BandWidth==HT_CHANNEL_WIDTH_40)?"40M":"20M", IGI_target, EDCCA_State));
 
 	if(EDCCA_State == 1)
 	{
-		Diff = IGI_target -(s8)IGI;
-		TH_L2H_dmc = dmpriv->TH_L2H_ini + Diff;
+		Diff = IGI_target -(s1Byte)IGI;
+		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
 		if(TH_L2H_dmc > 10) 	TH_L2H_dmc = 10;
-		TH_H2L_dmc = TH_L2H_dmc - dmpriv->TH_EDCCA_HL_diff;
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+		//replace lower bound to prevent EDCCA always equal 1
+			if(TH_H2L_dmc < pDM_Odm->H2L_lb)				
+				TH_H2L_dmc = pDM_Odm->H2L_lb;
+			if(TH_L2H_dmc < pDM_Odm->L2H_lb)
+				TH_L2H_dmc = pDM_Odm->L2H_lb;
 	}
 	else
 	{
 		TH_L2H_dmc = 0x7f;
 		TH_H2L_dmc = 0x7f;
 	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
+		IGI, TH_L2H_dmc, TH_H2L_dmc));
 
-	LOG_LEVEL(_drv_info_, "IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
-		IGI, TH_L2H_dmc, TH_H2L_dmc);
-
-	/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)*/
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
 	{
-		PHY_SetBBReg(pAdapter,rOFDM0_ECCAThreshold, bMaskByte0, (u8)TH_L2H_dmc);
-		PHY_SetBBReg(pAdapter,rOFDM0_ECCAThreshold, bMaskByte2, (u8)TH_H2L_dmc);
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
 	}
-	/*else
-		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u8)TH_H2L_dmc<<8) | (u8)TH_L2H_dmc);*/
+	else
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u1Byte)TH_H2L_dmc<<8) | (u1Byte)TH_L2H_dmc);
+
+#endif /* CONFIG_ODM_ADAPTIVITY */
+}
+
+void rtw_odm_init(_adapter *adapter)
+{
+	PDM_ODM_T odm = adapter_to_odm(adapter);
+
+	odm->Adapter = adapter;
+	rtw_warn_on(!odm->Adapter);
+
+	switch (adapter->chip_type) {
+	case RTL8188C_8192C:
+		odm->SupportICType = ODM_RTL8192C;
+		break;
+	case RTL8192D:
+ 		odm->SupportICType = ODM_RTL8192D;
+		break;
+	default:
+		odm->SupportICType = 0;
+	};
+	rtw_warn_on(!odm->SupportICType);
+
+	switch (adapter->interface_type) {
+	case RTW_USB:
+		odm->SupportInterface = ODM_ITRF_USB;
+		break;
+	case RTW_PCIE:
+		odm->SupportInterface = ODM_ITRF_PCIE;
+		break;
+	default:
+		odm->SupportInterface = 0;
+	};
+	rtw_warn_on(!odm->SupportInterface);
 
-skip_dm:
-	return;
-#endif /* CONFIG_DM_ADAPTIVITY */
+	ODM_InitDebugSetting(odm);
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.h
index 17c3de6594e6..c145f6d7b7d6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/dm.h
@@ -18,13 +18,78 @@
  *
  ******************************************************************************/
 
- #ifndef	__DM_H__
+#ifndef	__DM_H__
 #define __DM_H__
 
-int dm_adaptivity_get_parm_str(_adapter *pAdapter, char *buf, int len);
-void dm_adaptivity_set_parm(_adapter *pAdapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
+#define	DYNAMIC_FUNC_DISABLE		(0x0)
+#define	DYNAMIC_FUNC_DIG			BIT(0)
+#define	DYNAMIC_FUNC_HP			BIT(1)
+#define	DYNAMIC_FUNC_SS			BIT(2) //Tx Power Tracking
+#define DYNAMIC_FUNC_BT			BIT(3)
+#define DYNAMIC_FUNC_ANT_DIV		BIT(4)
+#define DYNAMIC_FUNC_ADAPTIVITY	BIT(5)
+
+void rtw_dm_ability_msg(void *sel, _adapter *adapter);
+void rtw_dm_ability_set(_adapter *adapter, u8 ability);
+
+void rtw_dm_check_rxfifo_full(_adapter *adapter);
+
+void rtw_odm_dbg_comp_msg(void *sel, _adapter *adapter);
+void rtw_odm_dbg_comp_set(_adapter *adapter, u64 comps);
+void rtw_odm_dbg_level_msg(void *sel, _adapter *adapter);
+void rtw_odm_dbg_level_set(_adapter *adapter, u32 level);
+
+void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter);
+void rtw_odm_adaptivity_parm_set(_adapter *pAdapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
 	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound);
-void dm_adaptivity_init(_adapter *pAdapter);
-void dm_adaptivity(_adapter *pAdapter);
+
+void rtw_odm_init(_adapter *adapter);
+
+typedef struct DM_Out_Source_Dynamic_Mechanism_Structure
+{
+	_adapter *Adapter;
+	u32 SupportICType;
+	u8 SupportInterface;
+
+	u64 DebugComponents;
+	u32 DebugLevel;
+
+	void (*write_dig)(_adapter *adapter);
+
+#ifdef CONFIG_ODM_ADAPTIVITY
+	/* Ported from ODM, for ESTI Adaptivity test */
+	s8 TH_L2H_ini;
+	s8 TH_EDCCA_HL_diff;
+	s8 IGI_Base;
+	u8 IGI_target;
+	bool ForceEDCCA;
+	u8 AdapEn_RSSI;
+	s8 Force_TH_H;
+	s8 Force_TH_L;
+	u8 IGI_LowerBound;
+
+	bool	bPreEdccaEnable;
+
+	// add by Yu Cehn for adaptivtiy
+	bool adaptivity_flag;
+	bool NHM_disable;
+	bool TxHangFlg;
+	u8 tolerance_cnt;
+	u64 NHMCurTxOkcnt;
+	u64 NHMCurRxOkcnt;
+	u64 NHMLastTxOkcnt;
+	u64 NHMLastRxOkcnt;
+	u8 txEdcca1;
+	u8 txEdcca0;
+	s8 H2L_lb;
+	s8 L2H_lb;
+	u8 Adaptivity_IGI_upper;
+#endif
+
+} DM_ODM_T, *PDM_ODM_T; /* ODM structure for ease of partial porting */
+
+void odm_AdaptivityInit(PDM_ODM_T pDM_Odm);
+void odm_Adaptivity(PDM_ODM_T pDM_Odm);
 
 #endif /* __DM_H__ */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_com.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_com.c
index 4dcafd656eae..56331fd43253 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_com.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_com.c
@@ -369,3 +369,176 @@ s32 c2h_evt_read(_adapter *adapter, u8 *buf)
 	return ret;
 }
 
+void SetHwReg(_adapter *adapter, HW_VARIABLES variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct dm_priv *dm = &(hal_data->dmpriv);
+
+	switch (variable) {
+	case HW_VAR_DM_FLAG:
+		dm->DMFlag = *((u8*)val);
+		break;
+	case HW_VAR_ENC_BMC_ENABLE:
+	{
+		u8 seccfg;
+		struct security_priv *psecuritypriv = &adapter->securitypriv;
+		//enable MC/BC hw decrypt
+		seccfg = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
+		rtw_write8(adapter, REG_SECCFG, seccfg);
+		break;
+	}
+	case HW_VAR_ENC_BMC_DISABLE:
+	{
+		struct security_priv *psecuritypriv = &adapter->securitypriv;
+		rtw_write8(adapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC
+		break;
+	}
+	case HW_VAR_CHECK_TXBUF:
+	{
+		u8 retry_limit;
+		u16 val16;
+		u32 reg_200 = 0, reg_204 = 0;
+		u32 init_reg_200 = 0, init_reg_204 = 0;
+		u32 start = rtw_get_current_time();
+		u32 pass_ms;
+		int i = 0;
+
+		retry_limit = 0x01;
+
+		val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
+		rtw_write16(adapter, REG_RL, val16);
+
+		while (rtw_get_passing_time_ms(start) < 2000
+			&& !adapter->bDriverStopped && !adapter->bSurpriseRemoved
+		) {
+			reg_200 = rtw_read32(adapter, 0x200);
+			reg_204 = rtw_read32(adapter, 0x204);
+
+			if (i == 0) {
+				init_reg_200 = reg_200;
+				init_reg_204 = reg_204;
+			}
+
+			i++;
+			if ((reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
+				//DBG_871X("%s: (HW_VAR_CHECK_TXBUF)TXBUF NOT empty - 0x204=0x%x, 0x200=0x%x (%d)\n", __FUNCTION__, reg_204, reg_200, i);
+				rtw_msleep_os(10);
+			} else {
+				break;
+			}
+		}
+
+		pass_ms = rtw_get_passing_time_ms(start);
+
+		if (adapter->bDriverStopped || adapter->bSurpriseRemoved) {
+		} else if (pass_ms >= 2000 || (reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
+			DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)NOT empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
+			DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)0x200=0x%08x, 0x204=0x%08x (0x%08x, 0x%08x)\n",
+				__FUNCTION__, reg_200, reg_204, init_reg_200, init_reg_204);
+			//rtw_warn_on(1);
+		} else {
+			DBG_871X("%s:(HW_VAR_CHECK_TXBUF)TXBUF Empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
+		}
+
+		retry_limit = 0x30;
+		val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
+		rtw_write16(adapter, REG_RL, val16);
+	}
+		break;
+	default:
+		if(0)
+		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HW_VARIABLES(%d) not defined!\n", __FUNCTION__, variable);
+		break;
+	}
+}
+
+void GetHwReg(_adapter *adapter, HW_VARIABLES variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct dm_priv *dm = &(hal_data->dmpriv);
+
+	switch (variable) {
+	case HW_VAR_DM_FLAG:
+		*((u8*)val) = dm->DMFlag;
+		break;
+	default:
+		if(0)
+		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HW_VARIABLES(%d) not defined!\n", __FUNCTION__, variable);
+		break;
+	}
+}
+
+u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct dm_priv *dm = &(hal_data->dmpriv);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+	case HAL_DEF_DBG_DM_FUNC:
+	{
+		u8 dm_func = *((u8*)val);
+
+		if (dm_func == 0){ //disable all dynamic func
+			dm->DMFlag = DYNAMIC_FUNC_DISABLE;
+			DBG_8192C("==> Disable all dynamic function...\n");
+		}
+		else if (dm_func == 1){//disable DIG
+			dm->DMFlag &= (~DYNAMIC_FUNC_DIG);
+			DBG_8192C("==> Disable DIG...\n");
+		}
+		else if (dm_func == 2){//disable High power
+			dm->DMFlag &= (~DYNAMIC_FUNC_HP);
+		}
+		else if (dm_func == 3){//disable tx power tracking
+			dm->DMFlag &= (~DYNAMIC_FUNC_SS);
+			DBG_8192C("==> Disable tx power tracking...\n");
+		}
+		else if (dm_func == 4){//disable BT coexistence
+			dm->DMFlag &= (~DYNAMIC_FUNC_BT);
+		}
+		else if (dm_func == 5){//disable antenna diversity
+			dm->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
+		}				
+		else if (dm_func == 6){//turn on all dynamic func
+			if (!(dm->DMFlag & DYNAMIC_FUNC_DIG)) {
+				DIG_T	*pDigTable = &dm->DM_DigTable;
+				pDigTable->PreIGValue = rtw_read8(adapter, 0xc50);	
+			}
+
+			dm->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS|
+				DYNAMIC_FUNC_BT|DYNAMIC_FUNC_ANT_DIV) ;
+			DBG_8192C("==> Turn on all dynamic function...\n");
+		}
+	}
+		break;
+	default:
+		if(0)
+		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
+		bResult = _FAIL;
+		break;
+	}
+
+	return bResult;
+}
+
+u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct dm_priv *dm = &(hal_data->dmpriv);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+	case HAL_DEF_DBG_DM_FUNC:
+		*((u8*)val) = dm->DMFlag;
+		break;
+	default:
+		if(0)
+		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
+		bResult = _FAIL;
+		break;
+	}
+
+	return bResult;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_intf.c
index 6c56e72d2588..9ade8885ea56 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/hal_intf.c
@@ -183,6 +183,8 @@ uint	 rtw_hal_init(_adapter *padapter)
 
 	rtw_sec_restore_wep_key(padapter);
 
+	rtw_led_control(padapter, LED_CTL_POWER_ON);
+
 	init_hw_mlme_ext(padapter);
 
 fail:
@@ -201,6 +203,7 @@ _func_enter_;
 	status = padapter->HalFunc.hal_deinit(padapter);
 
 	if(status == _SUCCESS){
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 		padapter->hw_init_completed = _FALSE;
 	}
 	else
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_cmd.c
index 529afb6166ea..bc2c00c42cac 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_cmd.c
@@ -718,7 +718,7 @@ void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 
 #ifdef CONFIG_USB_HCI
 	BufIndex = TXDESC_OFFSET;
-	TxDescOffset = TxDescLen+8; //Shift index for 8 bytes because the dummy bytes in the first descipstor.
+	TxDescOffset = TxDescLen + PACKET_OFFSET_SZ;;
 #else
 	BufIndex = 0;
 	TxDescOffset = 0;
@@ -1080,88 +1080,82 @@ _func_enter_;
 	pwowlan_parm.second_mode =0;
 	pwowlan_parm.reserve=0;
 
-
-	
-	if(pwrpriv->wowlan_mode ==_TRUE){
-		//pause RX DMA
-		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
-		test |= BIT(2);
-		rtw_write8(padapter, REG_RXPKT_NUM+2, test);
-		//286 BIT(1) , not 1(means idle) do rx urb
+	//pause RX DMA
+	test = rtw_read8(padapter, REG_RXPKT_NUM+2);
+	test |= BIT(2);
+	rtw_write8(padapter, REG_RXPKT_NUM+2, test);
+	//286 BIT(1) , not 1(means idle) do rx urb
+	test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
+	//printk("line(%d) 0x286=%d\n", __LINE__, rtw_read8(padapter, REG_RXPKT_NUM+2));
+	//check DMA idle?
+	while(test != BIT(1))
+	{
+		tasklet_schedule(&precvpriv->recv_tasklet);
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
-		//printk("line(%d) 0x286=%d\n", __LINE__, rtw_read8(padapter, REG_RXPKT_NUM+2));
-		//check DMA idle?
-		while(test != BIT(1))
-		{
-			tasklet_schedule(&precvpriv->recv_tasklet);
-			test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
-			rtw_msleep_os(10);
-			//printk("line(%d) 0x286=%d\n", __LINE__, test);
-		}
-		//mask usb se0 reset by Alex and DD
-		test = rtw_read8(padapter, 0xf8);
-		test &= ~(BIT(3)|BIT(4));
-		rtw_write8(padapter, 0xf8, test);
-
-		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
-		//printk("\n %s 1.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		if(pwrpriv->wowlan_pattern ==_TRUE){
-			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
-		//printk("\n %s 2.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		}
-		if(pwrpriv->wowlan_magic ==_TRUE){
-			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
-		//printk("\n %s 3.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		}
-		if(pwrpriv->wowlan_unicast ==_TRUE){
-			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
-		//printk("\n %s 4.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		}
-		
-		rtl8192d_set_FwJoinBssReport_cmd(padapter, 1);
-		
-		//WOWLAN_GPIO_ACTIVE means GPIO high active
-		//pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
-		pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
-		pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
-		
-		//GPIO 0
-		pwowlan_parm.gpio_index=0;
-		
-		//duration unit is 64us
-		pwowlan_parm.gpio_duration=0xff;
-		
-		pwowlan_parm.second_mode|=FW_WOWLAN_GPIO_WAKEUP_EN;
-		pwowlan_parm.second_mode|=FW_FW_PARSE_MAGIC_PKT;
-		//printk("\n %s 5.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		{	u8 *ptr=(u8 *)&pwowlan_parm;
-			printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x \n",__FUNCTION__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4] );
-		}
-		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
-			
-		
-		//keep alive period = 3 * 10 BCN interval
-		pwowlan_parm.mode =3;
-		pwowlan_parm.gpio_index=3;
-		FillH2CCmd92D(padapter, KEEP_ALIVE_CONTROL_CMD, 2, (u8 *)&pwowlan_parm);
-		printk("%s after KEEP_ALIVE_CONTROL_CMD register 0x81=%x \n",__FUNCTION__,rtw_read8(padapter, 0x85));
-
-		pwowlan_parm.mode =1;
-		pwowlan_parm.gpio_index=0;
-		pwowlan_parm.gpio_duration=0;
-		FillH2CCmd92D(padapter, DISCONNECT_DECISION_CTRL_CMD, 3, (u8 *)&pwowlan_parm);
-		printk("%s after DISCONNECT_DECISION_CTRL_CMD register 0x81=%x \n",__FUNCTION__,rtw_read8(padapter, 0x85));
+		rtw_msleep_os(10);
+		//printk("line(%d) 0x286=%d\n", __LINE__, test);
+	}
+	//mask usb se0 reset by Alex and DD
+	test = rtw_read8(padapter, 0xf8);
+	test &= ~(BIT(3)|BIT(4));
+	rtw_write8(padapter, 0xf8, test);
+
+	pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
+	//printk("\n %s 1.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
+	if(pwrpriv->wowlan_pattern ==_TRUE){
+		pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
+	//printk("\n %s 2.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
+	}
+	//if(pwrpriv->wowlan_magic ==_TRUE){
+		//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
+	//printk("\n %s 3.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
+	//}
+	if(pwrpriv->wowlan_unicast ==_TRUE){
+		pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
+	//printk("\n %s 4.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
+	}
+	
+	rtl8192d_set_FwJoinBssReport_cmd(padapter, 1);
+	
+	//WOWLAN_GPIO_ACTIVE means GPIO high active
+	//pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
+	pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
+	pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
+	
+	//GPIO 0
+	pwowlan_parm.gpio_index=0;
+	
+	//duration unit is 64us
+	pwowlan_parm.gpio_duration=0xff;
+	
+	pwowlan_parm.second_mode|=FW_WOWLAN_GPIO_WAKEUP_EN;
+	pwowlan_parm.second_mode|=FW_FW_PARSE_MAGIC_PKT;
+	//printk("\n %s 5.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
+	{	u8 *ptr=(u8 *)&pwowlan_parm;
+		printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x \n",__FUNCTION__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4] );
+	}
+	FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 		
-		//enable GPIO wakeup
-		pwowlan_parm.mode =1;
-		pwowlan_parm.gpio_index=0;
-		pwowlan_parm.gpio_duration=0;
-		FillH2CCmd92D(padapter, REMOTE_WAKE_CTRL_CMD, 1, (u8 *)&pwowlan_parm);
-		printk("%s after DISCONNECT_DECISION_CTRL_CMD register \n",__FUNCTION__);
+	
+	//keep alive period = 3 * 10 BCN interval
+	pwowlan_parm.mode =3;
+	pwowlan_parm.gpio_index=3;
+	FillH2CCmd92D(padapter, KEEP_ALIVE_CONTROL_CMD, 2, (u8 *)&pwowlan_parm);
+	printk("%s after KEEP_ALIVE_CONTROL_CMD register 0x81=%x \n",__FUNCTION__,rtw_read8(padapter, 0x85));
+
+	pwowlan_parm.mode =1;
+	pwowlan_parm.gpio_index=0;
+	pwowlan_parm.gpio_duration=0;
+	FillH2CCmd92D(padapter, DISCONNECT_DECISION_CTRL_CMD, 3, (u8 *)&pwowlan_parm);
+	printk("%s after DISCONNECT_DECISION_CTRL_CMD register 0x81=%x \n",__FUNCTION__,rtw_read8(padapter, 0x85));
+	
+	//enable GPIO wakeup
+	pwowlan_parm.mode =1;
+	pwowlan_parm.gpio_index=0;
+	pwowlan_parm.gpio_duration=0;
+	FillH2CCmd92D(padapter, REMOTE_WAKE_CTRL_CMD, 1, (u8 *)&pwowlan_parm);
+	printk("%s after DISCONNECT_DECISION_CTRL_CMD register \n",__FUNCTION__);
 
-	}
-	else
-		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
 	
 _func_exit_;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_dm.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_dm.c
index 65bc9ed78002..bfa60da79b2f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_dm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_dm.c
@@ -579,6 +579,7 @@ static void odm_DIG(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct mlme_priv	*pmlmepriv = &(pAdapter->mlmepriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	DM_ODM_T *odm = adapter_to_odm(pAdapter);
 	struct registry_priv	 *pregistrypriv = &pAdapter->registrypriv;
 	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
 	pDIG_T	pDM_DigTable = &pdmpriv->DM_DigTable;
@@ -595,9 +596,6 @@ static void odm_DIG(
 	struct mlme_priv	*pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
 	struct dm_priv	*pbuddy_pdmpriv = &pbuddy_pHalData->dmpriv;
 #endif //CONFIG_CONCURRENT_MODE
-#ifdef CONFIG_DM_ADAPTIVITY
-	u8 Adap_IGI_Upper = pdmpriv->IGI_target + 30 + (u8) pdmpriv->TH_L2H_ini -(u8) pdmpriv->TH_EDCCA_HL_diff;
-#endif
 
 	//RT_TRACE(COMP_DIG, DBG_LOUD, ("odm_DIG() ==>\n"));
 	
@@ -863,21 +861,23 @@ static void odm_DIG(
 	if(pDM_DigTable->CurIGValue < pDM_DigTable->rx_gain_range_min)
 		pDM_DigTable->CurIGValue = pDM_DigTable->rx_gain_range_min;
 
-#ifdef CONFIG_DM_ADAPTIVITY
-	if(pdmpriv->DMFlag & DYNAMIC_FUNC_ADAPTIVITY)
+#ifdef CONFIG_ODM_ADAPTIVITY
+	if((pdmpriv->DMFlag & DYNAMIC_FUNC_ADAPTIVITY) && odm->adaptivity_flag == _TRUE)
 	{
+		u8 Adap_IGI_Upper = odm->Adaptivity_IGI_upper;
+
 		if(pDM_DigTable->CurIGValue > Adap_IGI_Upper)
 			pDM_DigTable->CurIGValue = Adap_IGI_Upper;
 
-		if(pdmpriv->IGI_LowerBound != 0)
+		if(odm->IGI_LowerBound != 0)
 		{
-			if(pDM_DigTable->CurIGValue < pdmpriv->IGI_LowerBound)
-				pDM_DigTable->CurIGValue = pdmpriv->IGI_LowerBound;
+			if(pDM_DigTable->CurIGValue < odm->IGI_LowerBound)
+				pDM_DigTable->CurIGValue = odm->IGI_LowerBound;
 		}
-		LOG_LEVEL(_drv_info_, FUNC_ADPT_FMT": pdmpriv->IGI_LowerBound = %d\n",
-			FUNC_ADPT_ARG(pAdapter), pdmpriv->IGI_LowerBound);
+		LOG_LEVEL(_drv_info_, FUNC_ADPT_FMT": odm->IGI_LowerBound = %d\n",
+			FUNC_ADPT_ARG(pAdapter), odm->IGI_LowerBound);
 	}
-#endif /* CONFIG_DM_ADAPTIVITY */
+#endif /* CONFIG_ODM_ADAPTIVITY */
 
 	if ( pAdapter->bRxRSSIDisplay )
 	{
@@ -1627,6 +1627,10 @@ dm_CheckEdcaTurbo(
 	u64	cur_rx_bytes = 0;
 	u32	EDCA_BE[2] = {0x5ea42b, 0x5ea42b};
 	u8	bbtchange = _FALSE;
+	u8	bLinked = _FALSE;
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	buddy_bLinked = _FALSE;
+#endif //CONFIG_CONCURRENT_MODE
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
 	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
@@ -1634,6 +1638,13 @@ dm_CheckEdcaTurbo(
 	struct registry_priv	*pregpriv = &Adapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+#ifdef CONFIG_CONCURRENT_MODE
+	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
+	struct xmit_priv		*pbuddy_pxmitpriv = &(pbuddy_adapter->xmitpriv);
+      	struct recv_priv		*pbuddy_precvpriv = &(pbuddy_adapter->recvpriv);
+	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif //CONFIG_CONCURRENT_MODE
 
 	if(IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
@@ -1656,12 +1667,35 @@ dm_CheckEdcaTurbo(
 		goto dm_CheckEdcaTurbo_EXIT;
 	}
 
+	if((check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == _TRUE)&&(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == _TRUE))			
+		bLinked = _TRUE;    
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if((check_fwstate(&pbuddy_adapter->mlmepriv, _FW_LINKED) == _TRUE)&&(check_fwstate(&pbuddy_adapter->mlmepriv, WIFI_STATION_STATE) == _TRUE))			
+		buddy_bLinked = _TRUE;
+#endif //CONFIG_CONCURRENT_MODE
+	if((!bLinked) 
+#ifdef CONFIG_CONCURRENT_MODE
+            && (!buddy_bLinked) 
+#endif //CONFIG_CONCURRENT_MODE     
+        )
+	{
+		goto dm_CheckEdcaTurbo_EXIT;
+	}
+      
 	// Check if the status needs to be changed.
 	if((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
 	{
 		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
 		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
 
+#ifdef CONFIG_CONCURRENT_MODE
+		cur_tx_bytes += pbuddy_pxmitpriv->tx_bytes - pbuddy_pxmitpriv->last_tx_bytes;
+		cur_rx_bytes += pbuddy_precvpriv->rx_bytes - pbuddy_precvpriv->last_rx_bytes;
+
+		if(_TRUE == buddy_bLinked)
+                    pmlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+#endif //CONFIG_CONCURRENT_MODE
 		//traffic, TX or RX
 		if((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
 		{
@@ -1686,8 +1720,15 @@ dm_CheckEdcaTurbo(
 			}
 		}
 
-		if ((pdmpriv->prv_traffic_idx != trafficIndex) || (!pHalData->bCurrentTurboEDCA))
+		//if ((pdmpriv->prv_traffic_idx != trafficIndex) || (!pHalData->bCurrentTurboEDCA))
 		{
+#ifdef CONFIG_CONCURRENT_MODE		
+			if((_TRUE == bLinked) && (_TRUE == buddy_bLinked))
+			{
+				edca_param = 0x5ea42b;
+			}         
+			else
+#endif //CONFIG_CONCURRENT_MODE              
 			{
 				if((pmlmeinfo->assoc_AP_vendor == ciscoAP) && (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N)))
 				{
@@ -1740,6 +1781,10 @@ dm_CheckEdcaTurbo(
 	precvpriv->bIsAnyNonBEPkts = _FALSE;
 	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
 	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
+#ifdef CONFIG_CONCURRENT_MODE
+	pbuddy_pxmitpriv->last_tx_bytes = pbuddy_pxmitpriv->tx_bytes;
+	pbuddy_precvpriv->last_rx_bytes = pbuddy_precvpriv->rx_bytes;
+#endif //CONFIG_CONCURRENT_MODE
 
 }	// dm_CheckEdcaTurbo
 
@@ -1878,6 +1923,12 @@ dm_TXPowerTrackingCallback_ThermalMeter_92D(
 //#if MP_DRIVER != 1
 //	return;
 //#endif
+	if(!pdmpriv->TxPowerTrackControl)
+		return;
+		
+#ifdef CONFIG_MP_INCLUDED
+	DBG_871X("%s() \n",__func__);
+#endif
 
 	pdmpriv->TXPowerTrackingCallbackCnt++;	//cosa add for debug
 	pdmpriv->bTXPowerTrackingInit = _TRUE;
@@ -2303,7 +2354,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_92D(
 			}
 #endif
 			pdmpriv->ThermalValue_IQK = ThermalValue;
-			rtl8192d_PHY_IQCalibrate(Adapter);
+			rtl8192d_PHY_IQCalibrate(Adapter, _TRUE);
 		}
 
 		if(delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G 
@@ -2842,6 +2893,7 @@ rtl8192d_InitHalDm(
 {
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	PDM_ODM_T odm = adapter_to_odm(Adapter);
 	u8	i;
 
 	pdmpriv->DM_Type = DM_Type_ByDriver;	
@@ -2880,11 +2932,15 @@ rtl8192d_InitHalDm(
 		pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL+i) & 0x3f;
 	}
 
-#ifdef CONFIG_DM_ADAPTIVITY
+#ifdef CONFIG_ODM_ADAPTIVITY
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_ADAPTIVITY;
-	dm_adaptivity_init(Adapter);
+	odm_AdaptivityInit(odm);
 #endif
 
+	if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		odm->write_dig = DM_Write_DIG_DMSP;
+	else
+		odm->write_dig = DM_Write_DIG;
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3013,6 +3069,7 @@ rtl8192d_HalDmWatchDog(
 		bFwPSAwake = _FALSE;
 #endif // CONFIG_P2P_PS
 
+
 	// Stop dynamic mechanism when:
 	// 1. RF is OFF. (No need to do DM.)
 	// 2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.)
@@ -3067,7 +3124,8 @@ rtl8192d_HalDmWatchDog(
 		odm_FindMinimumRSSI_92D(Adapter);
 #endif //CONFIG_CONCURRENT_MODE
 		odm_DIG(Adapter);
-		dm_adaptivity(Adapter);
+		odm_Adaptivity(adapter_to_odm(Adapter));
+		rtw_dm_check_rxfifo_full(Adapter);
 		//PHY_SetBBReg( Adapter, 0xC50, 0x7f, 0x32 );
 		//PHY_SetBBReg( Adapter, 0xC58, 0x7f, 0x32 );
 		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_hal_init.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_hal_init.c
index 0a328fafc070..e11533647ffd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_hal_init.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_hal_init.c
@@ -664,17 +664,18 @@ int FirmwareDownload92D(
 		
 		rtStatus = _WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
 
-		if(rtStatus == _SUCCESS
-			||(rtw_get_passing_time_ms(fwdl_start_time) > 500 && writeFW_retry++ >= 3)
+		if(rtStatus == _SUCCESS || Adapter->bDriverStopped || Adapter->bSurpriseRemoved
+			||(writeFW_retry++ >= 3 && rtw_get_passing_time_ms(fwdl_start_time) > 500)
 		)
 			break;
-
-		DBG_871X("%s writeFW_retry:%u, time after fwdl_start_time:%ums\n", __FUNCTION__
-			, writeFW_retry
-			, rtw_get_passing_time_ms(fwdl_start_time)
-		);
 	}
 	_FWDownloadEnable(Adapter, _FALSE);
+
+	DBG_871X("%s writeFW_retry:%u, time after fwdl_start_time:%ums\n", __FUNCTION__
+		, writeFW_retry
+		, rtw_get_passing_time_ms(fwdl_start_time)
+	);
+
 	if(_SUCCESS != rtStatus){
 		DBG_871X("DL Firmware failed!\n");
 		goto Exit;
@@ -1374,7 +1375,7 @@ _func_enter_;
 	DBG_8192C("===== rtl8192du_free_hal_data =====\n");
 
 	if(padapter->HalData)
-		rtw_mfree(padapter->HalData, sizeof(HAL_DATA_TYPE));
+		rtw_vmfree(padapter->HalData, sizeof(HAL_DATA_TYPE));
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	GlobalFirstConfigurationForNormalChip = _TRUE;
 #endif
@@ -2474,6 +2475,56 @@ static s32 c2h_handler_8192d(_adapter *padapter, struct c2h_evt_hdr *c2h_evt)
 	return ret;
 }
 
+void SetHwReg8192D(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+
+	switch (variable) {
+	default:
+		SetHwReg(adapter, variable, val);
+		break;
+	}
+}
+
+void GetHwReg8192D(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+
+	switch (variable) {
+	default:
+		GetHwReg(adapter, variable, val);
+		break;
+	}
+}
+
+u8 SetHalDefVar8192D(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+	default:
+		bResult = SetHalDefVar(adapter, variable, val);
+		break;
+	}
+
+	return bResult;
+}
+
+u8 GetHalDefVar8192D(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+	default:
+		bResult = GetHalDefVar(adapter, variable, val);
+		break;
+	}
+
+	return bResult;
+}
+
 void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc)
 {
 	pHalFunc->free_hal_data = &rtl8192d_free_hal_data;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_mp.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_mp.c
index 5abcb93c3bc1..d4816120f078 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_mp.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_mp.c
@@ -29,7 +29,7 @@
 
 #define IQK_DELAY_TIME		1 	//ms
 
-#define PHY_IQCalibrate(a)	rtl8192d_PHY_IQCalibrate(a)
+#define PHY_IQCalibrate(a)	rtl8192d_PHY_IQCalibrate(a, _FALSE)
 #define PHY_LCCalibrate(a)	rtl8192d_PHY_LCCalibrate(a, _TRUE)
 #define dm_CheckTXPowerTracking(a)	rtl8192d_dm_CheckTXPowerTracking(a)
 #define PHY_SetRFPathSwitch(a,b)	rtl8192d_PHY_SetRFPathSwitch(a,b)
@@ -380,10 +380,14 @@ void Hal_SetSingleToneTx ( PADAPTER pAdapter , u8 bStart )
     }
     if(bStart)
     {   // Start Single Tone.
-
     	RT_TRACE(_module_mp_,_drv_alert_, ("SetSingleToneTx: test start\n"));
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x0);
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x0);
+	//Rlk Helen 20121220 add for Reg_88c: set bit20-23=0xf,disable 3write------
+	 write_bbreg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0xf);//Reg_88c
+        //Rlk Helen 20121220 END--------------------
+
+
 		if(is92C)
        	{
 			_write_rfreg(pAdapter, RF_PATH_A, 0x21, BIT19, 0x01);
@@ -397,20 +401,30 @@ void Hal_SetSingleToneTx ( PADAPTER pAdapter , u8 bStart )
 		} 
 		else
 		{
+			if( pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			{
 			write_rfreg(pAdapter, rfPath, 0x21, 0xd4000);
 			rtw_usleep_os(100);
-			write_rfreg(pAdapter, rfPath, 0x00, 0x2001f); // PAD all on.
+				write_rfreg(pAdapter, rfPath, 0x00, 0x20000); // PAD all on.
+				rtw_usleep_os(100);
+			}
+			else
+			{
+				write_rfreg(pAdapter, rfPath, 0x41, 0xd4000);
+				rtw_usleep_os(100);
+				write_rfreg(pAdapter, rfPath, 0x00, 0x20000); // PAD all on.
 			rtw_usleep_os(100);
 		}
-		// Turn On Continue Tx and turn off the other test modes.
-		PHY_SetBBReg(pAdapter, rOFDM1_LSTF, BIT30|BIT29|BIT28, OFDM_SingleTone);
+		}
     }
     else
     {   // Stop Single Tone.
     	RT_TRACE(_module_mp_,_drv_alert_, ("SetSingleToneTx: test stop\n"));
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x1);
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x1);
-
+	//Rlk Helen 20121220 add for Reg_88c: set bit20-23=0x0,enable 3write------
+	write_bbreg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0);//Reg_88c: set bit20-23=0x0,enable 3write
+	//       	//Rlk Helen 20121220 END--------------------	
 		if(is92C)
 		{
 			_write_rfreg(pAdapter, RF_PATH_A, 0x21, BIT19, 0x00);
@@ -419,14 +433,22 @@ void Hal_SetSingleToneTx ( PADAPTER pAdapter , u8 bStart )
 			write_rfreg(pAdapter, RF_PATH_B, 0x00, 0x32d75); // PAD all on.
 			rtw_usleep_os(100);
 		} else {
+
+			if( pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			{
 			write_rfreg(pAdapter, rfPath, 0x21, 0x54000);
 			rtw_usleep_os(100);
 			write_rfreg(pAdapter, rfPath, 0x00, 0x30000); // PAD all on.
 			rtw_usleep_os(100);
 		}
-			// Turn off all test modes.
-		PHY_SetBBReg(pAdapter, rOFDM1_LSTF, BIT30|BIT29|BIT28, OFDM_ALL_OFF);
-
+			else
+			{
+				write_rfreg(pAdapter, rfPath, 0x41, 0x54000);
+				rtw_usleep_os(100);
+				write_rfreg(pAdapter, rfPath, 0x00, 0x30000); // PAD all on.
+				rtw_usleep_os(100);
+			}
+		}
     }
 
 }
@@ -527,12 +549,14 @@ void Hal_SetTxPower (PADAPTER pAdapter)
 	}
 	switch(pHalData->rf_chip)
 	{
+		 u8 path = (pHalData->AntennaTxPath == ANTENNA_A) ? (ANTENNA_A) : (ANTENNA_B);
 		// 2008/09/12 MH Test only !! We enable the TX power tracking for MP!!!!!
 		// We should call normal driver API later!!
 		case RF_8225:
 		case RF_8256:
 		case RF_6052:
 			Hal_MptSet8256CCKTxPower(pAdapter, &TxPowerLevel_CCK[0]);
+			Hal_MPT_CCKTxPowerAdjustbyIndex(pAdapter, pMptCtx->TxPwrLevel[path]%2 == 0);
 			Hal_MptSet8256OFDMTxPower(pAdapter, &TxPowerLevel_HTOFDM[0]);
 			break;
 
@@ -1325,7 +1349,8 @@ void Hal_mpt_SwitchRfSetting(PADAPTER pAdapter)
 	PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
     BOOLEAN             bInteralPA = _FALSE;
     u32				value = 0;
-    phy_SwitchRfSetting8192D(pAdapter,ChannelToSw);
+    
+   // phy_SwitchRfSetting8192D(pAdapter,ChannelToSw);
 #if 0    
 	if (((ulRateIdx == MPT_RATE_1M || ulRateIdx == MPT_RATE_6M || ulRateIdx == MPT_RATE_MCS0 ||
         ulRateIdx == MPT_RATE_MCS8) && ulbandwidth == HT_CHANNEL_WIDTH_20 &&
@@ -1360,23 +1385,139 @@ void Hal_mpt_SwitchRfSetting(PADAPTER pAdapter)
 void Hal_SetBandwidth(PADAPTER pAdapter)
 {
 	struct mp_priv *pmp = &pAdapter->mppriv;
+	ULONG ulbandwidth = pmp->bandwidth;
 
-	SetBWMode(pAdapter, pmp->bandwidth, pmp->prime_channel_offset);
-	Hal_mpt_SwitchRfSetting(pAdapter);
+	if (ulbandwidth == HT_CHANNEL_WIDTH_20 )
+	{
+		/* 20 MHZ sub-carrier mode --> dont care. */
+		pmp->bCurBW40MHz = _FALSE;
+		SetBWMode(pAdapter,HT_CHANNEL_WIDTH_20,pmp->prime_channel_offset);		
+	}
+	/* Sub-Carrier mode is defined in MAC data sheet chapter 12.3. */
+	else
+	{
+		/* 40 MHZ sub-carrier mode --> dont care. */
+		pmp->bCurBW40MHz = _TRUE;					
+		SetBWMode(pAdapter,HT_CHANNEL_WIDTH_40,pmp->prime_channel_offset);
+		//SetBWMode(pAdapter,HT_CHANNEL_WIDTH_40,HAL_PRIME_CHNL_OFFSET_UPPER);
+	}
+	
+	SelectChannel(pAdapter, pmp->channel);
+	//phy_SwitchRfSetting(pAdapter,pmp->channel);
 }
 
+void Hal_MPT_CCKTxPowerAdjustbyIndex(PADAPTER pAdapter, BOOLEAN beven)
+{
+	s32 	TempCCk;
+	u8		CCK_index, CCK_index_old=0;
+	u8		Action = 0; //0: no action, 1: even->odd, 2:odd->even
+	u8		TimeOut = 100;
+	s32 	i = 0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PMPT_CONTEXT	pMptCtx = &pAdapter->mppriv.MptCtx;
+
+
+	if (!IS_92C_SERIAL(pHalData->VersionID))
+		return;
+#if 0
+	while(PlatformAtomicExchange(&Adapter->IntrCCKRefCount, TRUE) == TRUE)
+	{
+		PlatformSleepUs(100);
+		TimeOut--;
+		if(TimeOut <= 0)
+		{
+			RTPRINT(FINIT, INIT_TxPower,
+			 ("!!!MPT_CCKTxPowerAdjustbyIndex Wait for check CCK gain index too long!!!\n" ));
+			break;
+		}
+	}
+#endif
+	if (beven && !pMptCtx->bMptIndexEven)	//odd->even
+	{
+		Action = 2;
+		pMptCtx->bMptIndexEven = _TRUE;
+	}
+	else if (!beven && pMptCtx->bMptIndexEven)	//even->odd
+	{
+		Action = 1;
+		pMptCtx->bMptIndexEven = _FALSE;
+	}
+
+	if (Action != 0)
+	{
+		//Query CCK default setting From 0xa24
+		TempCCk = read_bbreg(pAdapter, rCCK0_TxFilter2, bMaskDWord) & bMaskCCK;
+		for (i = 0; i < CCK_TABLE_SIZE; i++)
+		{
+			if (pHalData->dmpriv.bCCKinCH14)
+			{
+				if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4) == _TRUE)
+				{
+					CCK_index_old = (u8) i;
+//					RTPRINT(FINIT, INIT_TxPower,("MPT_CCKTxPowerAdjustbyIndex: Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch 14 %d\n",
+//						rCCK0_TxFilter2, TempCCk, CCK_index_old, pHalData->bCCKinCH14));
+					break;
+				}
+			}
+			else
+			{
+				if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4) == _TRUE)
+				{
+					CCK_index_old = (u8) i;
+//					RTPRINT(FINIT, INIT_TxPower,("MPT_CCKTxPowerAdjustbyIndex: Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch14 %d\n",
+//						rCCK0_TxFilter2, TempCCk, CCK_index_old, pHalData->bCCKinCH14));
+					break;
+				}
+			}
+		}
+
+		if (Action == 1)
+			CCK_index = CCK_index_old - 1;
+		else
+			CCK_index = CCK_index_old + 1;
+
+//		RTPRINT(FINIT, INIT_TxPower,("MPT_CCKTxPowerAdjustbyIndex: new CCK_index=0x%x\n",
+//			 CCK_index));
+
+		//Adjust CCK according to gain index
+		if (!pHalData->dmpriv.bCCKinCH14) {
+			rtw_write8(pAdapter, 0xa22, CCKSwingTable_Ch1_Ch13[CCK_index][0]);
+			rtw_write8(pAdapter, 0xa23, CCKSwingTable_Ch1_Ch13[CCK_index][1]);
+			rtw_write8(pAdapter, 0xa24, CCKSwingTable_Ch1_Ch13[CCK_index][2]);
+			rtw_write8(pAdapter, 0xa25, CCKSwingTable_Ch1_Ch13[CCK_index][3]);
+			rtw_write8(pAdapter, 0xa26, CCKSwingTable_Ch1_Ch13[CCK_index][4]);
+			rtw_write8(pAdapter, 0xa27, CCKSwingTable_Ch1_Ch13[CCK_index][5]);
+			rtw_write8(pAdapter, 0xa28, CCKSwingTable_Ch1_Ch13[CCK_index][6]);
+			rtw_write8(pAdapter, 0xa29, CCKSwingTable_Ch1_Ch13[CCK_index][7]);
+		} else {
+			rtw_write8(pAdapter, 0xa22, CCKSwingTable_Ch14[CCK_index][0]);
+			rtw_write8(pAdapter, 0xa23, CCKSwingTable_Ch14[CCK_index][1]);
+			rtw_write8(pAdapter, 0xa24, CCKSwingTable_Ch14[CCK_index][2]);
+			rtw_write8(pAdapter, 0xa25, CCKSwingTable_Ch14[CCK_index][3]);
+			rtw_write8(pAdapter, 0xa26, CCKSwingTable_Ch14[CCK_index][4]);
+			rtw_write8(pAdapter, 0xa27, CCKSwingTable_Ch14[CCK_index][5]);
+			rtw_write8(pAdapter, 0xa28, CCKSwingTable_Ch14[CCK_index][6]);
+			rtw_write8(pAdapter, 0xa29, CCKSwingTable_Ch14[CCK_index][7]);
+		}
+	}
+#if 0
+	RTPRINT(FINIT, INIT_TxPower,
+	("MPT_CCKTxPowerAdjustbyIndex 0xa20=%x\n", PlatformEFIORead4Byte(Adapter, 0xa20)));
+
+	PlatformAtomicExchange(&Adapter->IntrCCKRefCount, FALSE);
+#endif
+}
 
-void MPT_CCKTxPowerAdjust(PADAPTER Adapter,BOOLEAN	bInCH14)
+void Hal_MPT_CCKTxPowerAdjust(PADAPTER Adapter, BOOLEAN bInCH14)
 {
-	u4Byte				TempVal = 0, TempVal2 = 0, TempVal3 = 0;
-	u4Byte				CurrCCKSwingVal=0, CCKSwingIndex=12;
+	u32 	TempVal = 0, TempVal2 = 0, TempVal3 = 0;
+	u32 	CurrCCKSwingVal = 0, CCKSwingIndex = 12;
+	u8		i;
 	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(Adapter);
-	u1Byte				i;
 
 
 	// get current cck swing value and check 0xa22 & 0xa23 later to match the table.
-	
-	CurrCCKSwingVal = PHY_QueryBBReg(Adapter, rCCK0_TxFilter1, bMaskHWord);
+	CurrCCKSwingVal = read_bbreg(Adapter, rCCK0_TxFilter1, bMaskHWord);
 	
 	if(!bInCH14)
 	{
@@ -1384,11 +1525,12 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapter,BOOLEAN	bInCH14)
 		// get the current swing index
 		for(i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][0]) &&
-				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][1]) )
+			if (((CurrCCKSwingVal&0xff) == (u32)CCKSwingTable_Ch1_Ch13[i][0]) &&
+				(((CurrCCKSwingVal&0xff00)>>8) == (u32)CCKSwingTable_Ch1_Ch13[i][1]))
 			{
 				CCKSwingIndex = i;
-				//RT_TRACE(COMP_INIT, DBG_LOUD,("Ch1~13, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n", (rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
+//				RT_TRACE(COMP_INIT, DBG_LOUD,("Ch1~13, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n",
+//					(rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
 				break;
 			}
 		}
@@ -1409,18 +1551,17 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapter,BOOLEAN	bInCH14)
 		TempVal3 = 0;
 		TempVal3 =	CCKSwingTable_Ch1_Ch13[CCKSwingIndex][6] +
 					(CCKSwingTable_Ch1_Ch13[CCKSwingIndex][7]<<8) ;
-		
-		
 	}
 	else
 	{
 		for(i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch14[i][0]) &&
-				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch14[i][1]) )
+			if (((CurrCCKSwingVal&0xff) == (u32)CCKSwingTable_Ch14[i][0]) &&
+				(((CurrCCKSwingVal&0xff00)>>8) == (u32)CCKSwingTable_Ch14[i][1]))
 			{
 				CCKSwingIndex = i;
-				//RT_TRACE(COMP_INIT, DBG_LOUD,("Ch14, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n", (rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
+//				RT_TRACE(COMP_INIT, DBG_LOUD,("Ch14, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n",
+//					(rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
 				break;
 			}
 		}
@@ -1442,13 +1583,9 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapter,BOOLEAN	bInCH14)
 					(CCKSwingTable_Ch14[CCKSwingIndex][7]<<8) ;
 	}
 
-	PHY_SetBBReg(Adapter, rCCK0_TxFilter1,bMaskHWord, TempVal);
-	//RTPRINT(FMP, MP_SWICH_CH, ("0xA20=0x%x\n", TempVal));
-	PHY_SetBBReg(Adapter, rCCK0_TxFilter2,bMaskDWord, TempVal2);
-	//RTPRINT(FMP, MP_SWICH_CH, ("0xA24=0x%x\n", TempVal2));
-	PHY_SetBBReg(Adapter, rCCK0_DebugPort,bMaskLWord, TempVal3);
-	//RTPRINT(FMP, MP_SWICH_CH, ("0xA28=0x%x\n", TempVal3));
-
+	write_bbreg(Adapter, rCCK0_TxFilter1, bMaskHWord, TempVal);
+	write_bbreg(Adapter, rCCK0_TxFilter2, bMaskDWord, TempVal2);
+	write_bbreg(Adapter, rCCK0_DebugPort, bMaskLWord, TempVal3);
 }
 
 
@@ -1468,8 +1605,12 @@ void Hal_SetChannel(PADAPTER pAdapter)
 	u8		bandwidth = pmp->bandwidth;
 	u8		rate = pmp->rateidx;
 
-
+	if(channel > 14)
+		pHalData->CurrentBandType92D=BAND_ON_5G;
+	else
+		pHalData->CurrentBandType92D=BAND_ON_2_4G;
 	// set RF channel register
+	#if 0
 	for (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
 	{
 	  if(IS_HARDWARE_TYPE_8192D(pAdapter))
@@ -1477,18 +1618,20 @@ void Hal_SetChannel(PADAPTER pAdapter)
 		else
 			_write_rfreg(pAdapter, eRFPath, rRfChannel, 0x3FF, channel);
 	}
-
-	Hal_mpt_SwitchRfSetting(pAdapter);
-
+	#endif
+	//phy_SwitchRfSetting(pAdapter,channel);
+	DBG_8192C("%s SelectChannel 0X864 = 0x%8x \n",__func__,PHY_QueryBBReg(pAdapter, 0x864, bMaskDWord));
 	SelectChannel(pAdapter, channel);
+	DBG_8192C("%s After SelectChannel 0X864 = 0x%8x \n",__func__,PHY_QueryBBReg(pAdapter, 0x864, bMaskDWord));
+	Hal_SetBandwidth(pAdapter);
 
 	if (pHalData->CurrentChannel == 14 && !pHalData->dmpriv.bCCKinCH14) {
 		pHalData->dmpriv.bCCKinCH14 = _TRUE;
-		MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
+		Hal_MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
 	}
 	else if (pHalData->CurrentChannel != 14 && pHalData->dmpriv.bCCKinCH14) {
 		pHalData->dmpriv.bCCKinCH14 = _FALSE;
-		MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
+		Hal_MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
 	}
 
 #endif
@@ -1591,7 +1734,7 @@ void Hal_SetAntennaPathPower(PADAPTER pAdapter)
 
 void Hal_SetDataRate(PADAPTER pAdapter)
 {
-	Hal_mpt_SwitchRfSetting(pAdapter);
+	//Hal_mpt_SwitchRfSetting(pAdapter);
 }
 
 void Hal_SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_phycfg.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_phycfg.c
index 7bb2a57c9668..2938970627c0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_phycfg.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/rtl8192d_phycfg.c
@@ -3514,7 +3514,7 @@ static  VOID
 	if(pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
 	{ //Re Do IQK.
 		DBG_8192C("Do IQK Matrix reg for channel:%d....\n", channel);
-		rtl8192d_PHY_IQCalibrate(Adapter);
+		rtl8192d_PHY_IQCalibrate(Adapter, _FALSE);
 	}
 	else //Just load the value.
 	{
@@ -4958,9 +4958,9 @@ phy_PathAStandBy(
 {
 	//RTPRINT(FINIT, INIT_IQK, ("Path-A standby mode!\n"));
 
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x0);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 	PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 }
 
 static VOID
@@ -5208,7 +5208,7 @@ phy_IQCalibrate(
 
 	// IQ calibration setting
 	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
 
@@ -5266,7 +5266,7 @@ phy_IQCalibrate(
 
 	//Back to BB mode, load original value
 	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	if(t!=0)
 	{
@@ -5387,7 +5387,7 @@ phy_IQCalibrate_5G(
 	PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 
 	//IQK global setting
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
 
@@ -5431,7 +5431,7 @@ phy_IQCalibrate_5G(
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 	//Exit IQK mode
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	//Check_TX_IQK_A_result()
 	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
@@ -5469,7 +5469,7 @@ phy_IQCalibrate_5G(
 			PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
 
 		//IQK global setting
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 		//path-A IQK setting
 		if(pHalData->interfaceIndex == 0)
@@ -5513,7 +5513,7 @@ phy_IQCalibrate_5G(
 		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
 
 		//Exit IQK mode
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 		//Check_RX_IQK_A_result()
 		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
@@ -5555,7 +5555,7 @@ phy_IQCalibrate_5G(
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
 
 	//IQK global setting
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);	
 	
 	//path-A IQK setting
@@ -5581,7 +5581,7 @@ phy_IQCalibrate_5G(
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 	//Exit IQK mode
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	// Check_TX_IQK_B_result()
 	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
@@ -5625,7 +5625,7 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
 
 		//IQK global setting
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 		
 		//path-A IQK setting
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
@@ -5673,7 +5673,7 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
 
 	//Exit IQK mode
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 	phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
 	
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
@@ -5692,11 +5692,101 @@ phy_IQCalibrate_5G(
 	
 }
 
+void phy_IQCalibrate_Setting(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		is2T,
+	IN	BOOLEAN		isON
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth, 	
+						rRx_Wait_CCA, 		rTx_CCK_RFON,
+						rTx_CCK_BBON, 	rTx_OFDM_RFON, 	
+						rTx_OFDM_BBON, 	rTx_To_Rx,
+						rTx_To_Tx, 		rRx_CCK, 	
+						rRx_OFDM, 		rRx_Wait_RIFS,
+						rRx_TO_Rx, 		rStandby, 	
+						rSleep, 			rPMPD_ANAEN };
+	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE, 		REG_BCN_CTRL,	
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	u32			IQK_BB_REG[IQK_BB_REG_NUM] = {	//for normal
+						rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,	
+						rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
+						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,	
+						rFPGA0_RFMOD,			rFPGA0_AnalogParameter4,
+						rOFDM0_XAAGCCore1,		rOFDM0_XBAGCCore1
+					};
+
+	if (isON)
+	{
+		PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
+		PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+		PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+		PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
+
+		//Page A AP setting for IQK
+		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x20000000);
+
+		//Page B AP setting for IQK	
+		if(is2T)
+		{
+			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x00000000);
+			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x20000000);
+		}
+
+		// IQ calibration setting
+		//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
+		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+		PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
+		PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+	}
+	else
+	{
+		//Back to BB mode, load original value
+		//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
+		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+	
+		if(is2T)			
+			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+		else
+			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
+
+		//path A IQ path to DP block
+		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x010170b8);
+
+		//path B IQ path to DP block
+		if(is2T)
+			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x010170b8);
+
+		// Reload MAC parameters
+		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);		
+		
+		if(!pdmpriv->bRfPiEnable){
+			// Switch back BB to SI mode after finish IQ Calibration.
+			phy_PIModeSwitch(pAdapter, _FALSE);
+		}
+
+	 	// Reload ADDA power saving parameters
+	 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+
+		//load 0xe30 IQC default value
+		//PHY_SetBBReg(pAdapter, 0xe30, bMaskDWord, 0x01008c00);
+		//PHY_SetBBReg(pAdapter, 0xe34, bMaskDWord, 0x01008c00);
+	}
+}
+
 static VOID	
 phy_IQCalibrate_5G_Normal(
 	IN	PADAPTER	pAdapter,
 	IN	int 		result[][8],
-	IN	u8		t
+	IN	u8		t,
+	IN	u8		FromPT
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -5738,7 +5828,7 @@ phy_IQCalibrate_5G_Normal(
 	//rtw_udelay_os(IQK_DELAY_TIME*1000*100);	//delay after set IMR
 	
 	//rtw_udelay_os(IQK_DELAY_TIME*1000*20);
-	rtw_mdelay_os(IQK_DELAY_TIME*20);
+	//rtw_mdelay_os(IQK_DELAY_TIME*20);
 
 	if(t==0)
 	{
@@ -5787,38 +5877,7 @@ phy_IQCalibrate_5G_Normal(
 		phy_PIModeSwitch(pAdapter, _TRUE);
 	}
 
-	PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
-
-#if 0
-	//Page B init
-	PHY_SetBBReg(pAdapter, 0xb68, bMaskDWord, 0x0f600000);
-	
-	if(is2T)
-	{
-		PHY_SetBBReg(pAdapter, 0xb6c, bMaskDWord, 0x0f600000);
-	}
-#else	
-
-	//Page A AP setting for IQK
-	PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x00000000);
-	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x20000000);
-
-	//Page B AP setting for IQK	
-	if(is2T)
-	{
-		PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x00000000);
-		PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x20000000);
-	}
-#endif
-	// IQ calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
-	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+	phy_IQCalibrate_Setting(pAdapter, is2T, _TRUE);
 
 	{
 		PathAOK = phy_PathA_IQK_5G_Normal(pAdapter, is2T);
@@ -5838,14 +5897,24 @@ phy_IQCalibrate_5G_Normal(
 		}
 		else
 		{
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 			DBG_871X("0xe70 = 0x%x\n", PHY_QueryBBReg(pAdapter, rRx_Wait_CCA, bMaskDWord));
 			DBG_871X("RF path A 0x0 = 0x%x\n", PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask));
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);					
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);					
 			DBG_871X("Path A IQK Fail!!\n");
 		}
 	}
 
+	if (FromPT)
+	{
+		phy_IQCalibrate_Setting(pAdapter, is2T, _FALSE);
+
+		// sleep 50ms for next IQK
+		rtw_msleep_os(50);
+
+		phy_IQCalibrate_Setting(pAdapter, is2T, _TRUE);
+	}
+
 	if(is2T){
 		//_PHY_PathAStandBy(pAdapter);
 
@@ -5872,43 +5941,15 @@ phy_IQCalibrate_5G_Normal(
 			}			
 		}
 	}
-	
-	//Back to BB mode, load original value
-	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
-
-	if(t!=0)
-	{
-		if(is2T)			
-			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
-		else
-			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
-
-#if 1
-		//path A IQ path to DP block
-		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x010170b8);
-
-		//path B IQ path to DP block
-		if(is2T)
-			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x010170b8);
-#endif
-
-		// Reload MAC parameters
-		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);		
-		
-		if(!pdmpriv->bRfPiEnable){
-			// Switch back BB to SI mode after finish IQ Calibration.
-			phy_PIModeSwitch(pAdapter, _FALSE);
-		}
 
-	 	// Reload ADDA power saving parameters
-	 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-
-		//load 0xe30 IQC default value
-		//PHY_SetBBReg(pAdapter, 0xe30, bMaskDWord, 0x01008c00);
-		//PHY_SetBBReg(pAdapter, 0xe34, bMaskDWord, 0x01008c00);
+	phy_IQCalibrate_Setting(pAdapter, is2T, _FALSE);
 
+	if (FromPT && t != 2)
+	{
+		// sleep 50ms for next IQK
+		rtw_msleep_os(50);
 	}
+
 	//RTPRINT(FINIT, INIT_IQK, ("_PHY_IQCalibrate_5G_Normal() <==\n"));
 	
 }
@@ -6504,7 +6545,7 @@ phy_APCalibrate(
 			}	
 			
 			//page-B1
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 		
 			//path A
 			offset = rPdp_AntA;
@@ -6515,7 +6556,7 @@ phy_APCalibrate(
 				
 				offset += 0x04;
 			}				
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);							
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);							
 		}
 		else if(path == RF_PATH_B)
 		{
@@ -6545,7 +6586,7 @@ phy_APCalibrate(
 			}	
 			
 			//page-B1
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 			
 			//path B
 			offset = 0xb60;
@@ -6556,7 +6597,7 @@ phy_APCalibrate(
 				
 				offset += 0x04;
 			}				
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);							
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);							
 		}
 	
 		//save RF default value
@@ -6667,7 +6708,7 @@ phy_APCalibrate(
 			i = 0;
 			do
 			{
-				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
+				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x800000);
 				{
 					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);		
 					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
@@ -6677,7 +6718,7 @@ phy_APCalibrate(
 
 					rtw_mdelay_os(20);
 				}
-				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 				if(path == RF_PATH_A)
 					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
@@ -6772,7 +6813,8 @@ static VOID phy_SetRFPathSwitch(
 
 VOID
 rtl8192d_PHY_IQCalibrate(
-	IN	PADAPTER	pAdapter
+	IN	PADAPTER	pAdapter,
+	IN	u8			FromPT
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -6783,7 +6825,7 @@ rtl8192d_PHY_IQCalibrate(
 	int			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
 	BOOLEAN		is12simular, is13simular, is23simular;
 	BOOLEAN 	bStartContTx = _FALSE, bSingleTone = _FALSE, bCarrierSuppression = _FALSE;
-
+	u32 IQK_process_time = 0;
 	//if (ODM_CheckPowerStatus(pAdapter) == _FALSE)
 	//	return;
 
@@ -6805,7 +6847,7 @@ rtl8192d_PHY_IQCalibrate(
 	if(pHalData->bSlaveOfDMSP)
 		return;
 #endif
-
+	IQK_process_time = rtw_get_current_time();
 	//RTPRINT(FINIT, INIT_IQK, ("IQK:Start!!!interface %d channel %d\n", pHalData->interfaceIndex, pHalData->CurrentChannel));
 
 	for(i = 0; i < 8; i++)
@@ -6829,7 +6871,7 @@ rtl8192d_PHY_IQCalibrate(
 	{
 		if(pHalData->CurrentBandType92D == BAND_ON_5G)
 		{
-			phy_IQCalibrate_5G_Normal(pAdapter, result, i);
+			phy_IQCalibrate_5G_Normal(pAdapter, result, i, FromPT);
 		}
 		else if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		{
@@ -6956,6 +6998,7 @@ rtl8192d_PHY_IQCalibrate(
 		}
 #endif
 	}
+	DBG_871X("IQK: process time %u ms\n", rtw_get_passing_time_ms(IQK_process_time));
 
 }
 
@@ -6970,6 +7013,7 @@ rtl8192d_PHY_LCCalibrate(
 	struct mlme_ext_priv	*pmlmeext = &pAdapter->mlmeextpriv;
 	BOOLEAN 	bStartContTx = _FALSE, bSingleTone = _FALSE, bCarrierSuppression = _FALSE;
 	u32			timeout = 2000, timecount = 0;
+	u32 LCK_process_time = 0;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	PADAPTER	BuddyAdapter = pAdapter->pbuddy_adapter;
 	struct mlme_priv	*pmlmeprivBuddyAdapter;
@@ -7005,7 +7049,7 @@ rtl8192d_PHY_LCCalibrate(
 
 	if(pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 		return;
-
+	LCK_process_time = rtw_get_current_time();
 	pHalData->bLCKInProgress = _TRUE;
 
 	//DBG_8192C("LCK:Start!!!interface %d currentband %x delay %d ms\n", pHalData->interfaceIndex, pHalData->CurrentBandType92D, timecount);
@@ -7020,7 +7064,7 @@ rtl8192d_PHY_LCCalibrate(
 	}
 
 	pHalData->bLCKInProgress = _FALSE;
-
+	DBG_871X("LCK: process time %u ms\n", rtw_get_passing_time_ms(LCK_process_time));
 	//RTPRINT(FINIT, INIT_IQK, ("LCK:Finish!!!interface %d\n", pHalData->interfaceIndex));
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_led.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_led.c
index f8be6432d510..f35037ee6537 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_led.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_led.c
@@ -63,7 +63,7 @@ static void
 ResetLedStatus(PLED_871x	pLed) {
 	pLed->CurrLedState = RTW_LED_OFF; // Current LED state.
 	pLed->bLedOn = _FALSE; // true if LED is ON, false if LED is OFF.
-	
+	pLed->bSWLedCtrl = _FALSE;
 	pLed->bLedBlinkInProgress = _FALSE; // true if it is blinking, false o.w..
 	pLed->bLedNoLinkBlinkInProgress = _FALSE;
 	pLed->bLedLinkBlinkInProgress = _FALSE;
@@ -157,39 +157,64 @@ SwLedOn(
 )
 {
 	u8	LedCfg;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 
-	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
 	{
 		return;
 	}
 
-	//LedCfg = PlatformEFIORead1Byte(Adapter, LEDCFG);
-
-	switch(pLed->LedPin)
+	if( 	(BOARD_MINICARD == pHalData->BoardType )||
+		(BOARD_USB_SOLO == pHalData->BoardType)||
+		(BOARD_USB_COMBO == pHalData->BoardType))
 	{
-		case LED_PIN_GPIO0:
-			break;
-
-		case LED_PIN_LED0:
-			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
-			rtw_write8(padapter, REG_LEDCFG2, LedCfg&0xf0); // SW control led0 on.
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED0\n"));
-			
-			break;
-
-		case LED_PIN_LED1:
-			LedCfg = rtw_read8(padapter, (REG_LEDCFG2 + 1));
-			rtw_write8(padapter, (REG_LEDCFG2 + 1), LedCfg&0x0f); // SW control led1 on.
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED1\n"));
-			
-			break;
-
-		default:
-			break;
+		LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+		//RT_TRACE(COMP_LED,DBG_LOUD,("In SwLedON,LedAddr:%X LEDPIN=%d\n",REG_LEDCFG2, pLed->LedPin));
+
+		switch(pLed->LedPin)
+		{	
+			case LED_PIN_GPIO0:
+				break;
+
+			case LED_PIN_LED0:
+				//RT_TRACE(COMP_LED,DBG_LOUD,("In SwLedOn,LedAddr:%X LEDPIN=%d\n",REG_LEDCFG2, pLed->LedPin));				
+				LedCfg = rtw_read8(padapter, REG_LEDCFG2);			
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg&0xf0)|BIT5|BIT6); // SW control led0 on.
+				break;
+
+			case LED_PIN_LED1:
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg&0x0f)|BIT5); // SW control led1 on.
+				break;
+
+			default:
+				break;
+		}
+	}
+	else
+	{
+		switch(pLed->LedPin)
+		{
+			case LED_PIN_GPIO0:
+				break;
+
+			case LED_PIN_LED0:
+				LedCfg = rtw_read8(padapter, (REG_LEDCFG0));
+				rtw_write8(padapter, (REG_LEDCFG0), LedCfg&0xF0);
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED0\n"));
+				break;
+
+			case LED_PIN_LED1:
+				LedCfg = rtw_read8(padapter, (REG_LEDCFG1));
+				rtw_write8(padapter, (REG_LEDCFG1), LedCfg&0xF0); // SW control led1 on.
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED1 0x%x\n", rtw_read32(padapter, REG_LEDCFG0)));
+				break;
+
+			default:
+				break;
+		}
 	}
 
 	pLed->bLedOn = _TRUE;
-	
 }
 
 
@@ -209,41 +234,82 @@ SwLedOff(
 )
 {
 	u8	LedCfg;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 
-	if((padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+	if(padapter->bSurpriseRemoved == _TRUE)
 	{
              return;
 	}
 
-	//LedCfg = PlatformEFIORead1Byte(Adapter, LEDCFG);
+	if( 	(BOARD_MINICARD == pHalData->BoardType )||
+		(BOARD_USB_SOLO == pHalData->BoardType)||
+		(BOARD_USB_COMBO == pHalData->BoardType))
+	{		
+		//RT_TRACE(COMP_LED,DBG_LOUD,("In SwLedOff,LedAddr:%X LEDPIN=%d\n",REG_LEDCFG2, pLed->LedPin));
+		LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+		
+		// 2009/10/23 MH Issau eed to move the LED GPIO from bit  0 to bit3.
+		// 2009/10/26 MH Issau if tyhe device is 8c DID is 0x8176, we need to enable bit6 to
+		// enable GPIO8 for controlling LED.	
+		// 2010/07/02 Supprt Open-drain arrangement for controlling the LED. Added by Roger.
+		//
+		switch(pLed->LedPin)
+		{
 
-	switch(pLed->LedPin)
-	{
-		case LED_PIN_GPIO0:
-			break;
+			case LED_PIN_GPIO0:
+				break;
 
-		case LED_PIN_LED0:
-			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
-			LedCfg &= 0xf0; // Set to software control.
-			rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0\n"));
-			
-			break;
+			case LED_PIN_LED0:
+				if(pHalData->bLedOpenDrain == _TRUE)					
+				{
+					LedCfg &= 0x90; // Set to software control.				
+					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));				
+					LedCfg = rtw_read8(padapter, REG_MAC_PINMUX_CFG);
+					LedCfg &= 0xFE;
+					rtw_write8(padapter, REG_MAC_PINMUX_CFG, LedCfg);									
+				}
+				else
+				{
+					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3|BIT5|BIT6));
+				}
+				break;
 
-		case LED_PIN_LED1:
-			LedCfg = rtw_read8(padapter, (REG_LEDCFG2+1));
-			LedCfg &= 0x0f; // Set to software control.
-			rtw_write8(padapter, (REG_LEDCFG2+1), (LedCfg|BIT3));
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED1\n"));
-			
-			break;
+			case LED_PIN_LED1:
+				LedCfg &= 0x0f; // Set to software control.
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
+				break;
 
-		default:
-			break;
+			default:
+				break;
+		}
+	}
+	else
+	{
+		switch(pLed->LedPin)
+		{
+			case LED_PIN_GPIO0:
+				break;
+
+			case LED_PIN_LED0:
+				LedCfg = rtw_read8(padapter, (REG_LEDCFG0));
+				LedCfg &= 0xF0; // Set to software control.
+				rtw_write8(padapter, (REG_LEDCFG0), (LedCfg|BIT3));
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0\n"));
+				break;
+
+			case LED_PIN_LED1:
+				LedCfg = rtw_read8(padapter, (REG_LEDCFG1));
+				LedCfg &= 0xF0; // Set to software control.
+				rtw_write8(padapter, (REG_LEDCFG1), (LedCfg|BIT3));
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED1 0x%x\n", rtw_read32(Adapter, REG_LEDCFG0)));
+				break;
+
+			default:
+				break;
+		}
 	}
 
 	pLed->bLedOn = _FALSE;
-	
 }
 
 //
@@ -1236,7 +1302,7 @@ BlinkTimerCallback(
 	PLED_871x	 pLed = (PLED_871x)data;
 	_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->hw_init_completed == _FALSE))	
        {
              return;
        }
@@ -1256,7 +1322,7 @@ void BlinkWorkItemCallback(struct work_struct *work)
 	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
 	_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->hw_init_completed == _FALSE))	
        {
              return;
        }
@@ -1447,6 +1513,7 @@ SwLedControlMode1(
 	
 	switch(LedAction)
 	{
+		case LED_CTL_POWER_ON:
 		case LED_CTL_START_TO_LINK:	
 		case LED_CTL_NO_LINK:
 			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
@@ -2502,7 +2569,7 @@ LedControl871x(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->hw_init_completed == _FALSE))
        {
              return;
        }
@@ -2516,7 +2583,8 @@ LedControl871x(
 	//if(priv->bInHctTest)
 	//	return;
 	
-	if(	padapter->pwrctrlpriv.rf_pwrstate != rf_on && 
+	if(	(padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
+		padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS) &&
 		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX || 
 		 LedAction == LED_CTL_SITE_SURVEY || 
 		 LedAction == LED_CTL_LINK || 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_xmit.c
index 2ed02f3c7679..82febc5af10f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/rtl8192du_xmit.c
@@ -253,6 +253,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 {
 	int	pull=0;
 	uint	qsel;
+	u8 data_rate;
 	_adapter				*padapter = pxmitframe->padapter;
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
@@ -271,16 +272,18 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
+#ifndef USB_PACKET_OFFSET_SZ
 if (padapter->registrypriv.mp_mode == 0)
 {
 
-	if((_FALSE == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
+	if((PACKET_OFFSET_SZ != 0) && (_FALSE == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
 	{
 		ptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);
 		pull = 1;
 		pxmitframe->pkt_offset --;
 	}
 }
+#endif //USB_PACKET_OFFSET_SZ
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
 		
 	_rtw_memset(ptxdesc, 0, sizeof(struct tx_desc));
@@ -334,21 +337,21 @@ if (padapter->registrypriv.mp_mode == 0)
 
 			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);//RTS Rate=24M
 			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);//
-			//ptxdesc->txdw5 |= cpu_to_le32(0x0000000b);//DataRate - 54M
 
 			//use REG_INIDATA_RATE_SEL value
-			ptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);
+			data_rate = pdmpriv->INIDATA_RATE[pattrib->mac_id];
 
-              	if(0)//for driver dbg
-			{
-				ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-				
-				if(pattrib->ht_en)
-					ptxdesc->txdw5 |= cpu_to_le32(BIT(6));//SGI
-
-				ptxdesc->txdw5 |= cpu_to_le32(0x00000013);//init rate - mcs7
+			if (padapter->fix_rate != 0xFF) {
+				ptxdesc->txdw4 |= cpu_to_le32(USERATE);
+				ptxdesc->txdw4 |= cpu_to_le32(DISDATAFB);
+				if((padapter->fix_rate & BIT(7)))
+					ptxdesc->txdw5 |= cpu_to_le32(SGI);
+				else
+					ptxdesc->txdw5 &= ~(cpu_to_le32(SGI));
+				data_rate = padapter->fix_rate & 0x3F;
 			}
 
+			ptxdesc->txdw5 |= cpu_to_le32(data_rate);
 		}
 		else
 		{
@@ -580,7 +583,7 @@ s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		}
 
 		pull = update_txdesc(pxmitframe, mem_addr, sz, _FALSE);
-		
+#ifndef USB_PACKET_OFFSET_SZ
 		if(pull)
 		{
 			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
@@ -594,7 +597,9 @@ s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		{
 			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
 		}	
-
+#else
+		w_sz = sz + TXDESC_SIZE;
+#endif //USB_PACKET_OFFSET_SZ
 		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
 
 		inner_ret = rtw_write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)pxmitbuf);
@@ -733,8 +738,9 @@ s32 rtl8192du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 			pxmitbuf->priv_data = pxmitframe;
 
 			//pxmitframe->agg_num = 1; // alloc xmitframe should assign to 1.
+#ifndef USB_PACKET_OFFSET_SZ
 			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET; // first frame of aggregation, reserve 2 offset for 512 alignment and early mode
-
+#endif //USB_PACKET_OFFSET_SZ
 			pfirstframe = pxmitframe;
 			_enter_critical_bh(&pxmitpriv->lock, &irqL);
 			ptxservq = rtw_get_sta_pending(padapter, pfirstframe->attrib.psta, pfirstframe->attrib.priority, (u8 *)(&ac_index));
@@ -753,8 +759,11 @@ s32 rtl8192du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
-
+#ifndef USB_PACKET_OFFSET_SZ
 				len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + ((USB_92D_DUMMY_OFFSET - 1) * PACKET_OFFSET_SZ);
+#else
+				len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE;
+#endif //USB_PACKET_OFFSET_SZ
 				if (pbuf + _RND8(len) > aggMaxLength)
 				{
 					bulkstart = _TRUE;
@@ -785,7 +794,9 @@ s32 rtl8192du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 			pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
 
 			pxmitframe->agg_num = 0; // not first frame of aggregation
+#ifndef USB_PACKET_OFFSET_SZ
 			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET - 1; // not first frame of aggregation, reserve 1 offset for early mode
+#endif //USB_PACKET_OFFSET_SZ
 		}
 
 		if(pHalData->bEarlyModeEnable)
@@ -850,13 +861,15 @@ s32 rtl8192du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
+#ifndef USB_PACKET_OFFSET_SZ
 	//3 3. update first frame txdesc
-	if ((pbuf_tail % bulkSize) == 0) {
+	if ((PACKET_OFFSET_SZ != 0) && ((pbuf_tail % bulkSize) == 0)) {
 		// remove 1 pkt_offset
 		pbuf_tail -= PACKET_OFFSET_SZ;
 		pfirstframe->buf_addr += PACKET_OFFSET_SZ;
 		pfirstframe->pkt_offset--;
 	}
+#endif //USB_PACKET_OFFSET_SZ
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
 	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, _TRUE);
 
@@ -869,8 +882,9 @@ s32 rtl8192du_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	//3 5. update statisitc
 	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
 	//if (pfirstframe->pkt_offset == 1) pbuf_tail -= PACKET_OFFSET_SZ;
+#ifndef USB_PACKET_OFFSET_SZ
 	pbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);
-	
+#endif //USB_PACKET_OFFSET_SZ
 	rtw_count_tx_stats(padapter, pfirstframe, pbuf_tail);
 
 	rtw_free_xmitframe(pxmitpriv, pfirstframe);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_halinit.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_halinit.c
index 568a84e11999..0f90bb300734 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_halinit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_halinit.c
@@ -1742,7 +1742,8 @@ static void _InitHWLed(PADAPTER Adapter)
 // HW led control
 // to do .... 
 //must consider the cases of antenna diversity/ commbo card/solo card/mini card
-
+	rtw_write16(Adapter, REG_LEDCFG0, 0x8282);
+	rtw_write8(Adapter, REG_LEDCFG2, 0x82);
 }
 #endif //CONFIG_LED
 
@@ -2263,7 +2264,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 		// do IQK for 2.4G for better scan result, if current bandtype is 2.4G.
 		if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
-			rtl8192d_PHY_IQCalibrate(padapter);
+			rtl8192d_PHY_IQCalibrate(padapter, _FALSE);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
 		rtl8192d_dm_CheckTXPowerTracking(padapter);
@@ -2445,6 +2446,8 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 
 	//3. Disable LED0 & 1
 	rtw_write16(Adapter, REG_LEDCFG0, 0x8888);
+	//Disable LED2
+	rtw_write8(Adapter, REG_LEDCFG2, 0x88);
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
  
@@ -3066,8 +3069,6 @@ _func_enter_;
 
 	RT_SET_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC);
 
-	rtw_led_control(padapter, LED_CTL_POWER_OFF);
-
 	padapter->bHaltInProgress = _FALSE;
 
 _func_exit_;
@@ -3416,26 +3417,11 @@ _ReadBoardType(
 	boardType &= BOARD_TYPE_NORMAL_MASK;
 	boardType >>= 5;
 
-#if 0
-	switch(boardType & 0xF)
-	{
-		case 0:
-		case 1:
-		case 2:
-		case 3:
-		case 4:
-			pHalData->rf_type = RF_2T2R;
-			break;
-		case 5:
-			pHalData->rf_type = RF_1T2R;
-			break;
-		default:
-			pHalData->rf_type = RF_1T1R;
-			break;
-	}
+	pHalData->BoardType = boardType;
+	DBG_871X("_ReadBoardType(%x)\n",pHalData->BoardType);
 
-	pHalData->BluetoothCoexist = (boardType >> 4) ? _TRUE : _FALSE;
-#endif
+	if (boardType == BOARD_USB_High_PA)
+		pHalData->ExternalPA = 1;
 }
 
 
@@ -3449,6 +3435,7 @@ _ReadLEDSetting(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv 	*pledpriv = &(Adapter->ledpriv);
 
+#ifdef CONFIG_SW_LED
 	// Led mode
 	switch(pHalData->CustomerID)
 	{
@@ -3461,9 +3448,10 @@ _ReadLEDSetting(
 			break;			
 	}
 
-	#ifdef CONFIG_FORCE_HW_LED
+	pHalData->bLedOpenDrain = _TRUE;// Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16.
+#else
 	pledpriv->LedStrategy = HW_LED;
-	#endif
+#endif
 }
 
 #ifdef CONFIG_WOWLAN
@@ -3480,7 +3468,7 @@ _ReadWOWLAN(
 	{
 		// decide hw if support remote wakeup function
 		// if hw supported, 8051 (SIE) will generate WeakUP signal( D+/D- toggle) when autoresume
-		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?_TRUE :_FALSE;
+		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & EEPROM_USB_REMOTE_WAKEUP)?_TRUE :_FALSE;
 		DBG_871X("efuse remote wakeup =%d \n", Adapter->pwrctrlpriv.bSupportRemoteWakeup);
 	}
 }
@@ -4529,7 +4517,6 @@ static void dc_hw_var_mlme_join(PADAPTER Adapter, u8 join_state)
 }
 #endif
 
-void SetHwReg8192DU(PADAPTER Adapter, u8 variable, u8* val);
 void SetHwReg8192DU(PADAPTER Adapter, u8 variable, u8* val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -4939,9 +4926,6 @@ _func_enter_;
 			rtw_write8(Adapter, REG_SECCFG, *((u8 *)val));
 #endif //CONFIG_CONCURRENT_MODE
 			break;
-		case HW_VAR_DM_FLAG:
-			pdmpriv->DMFlag = *((u8 *)val);
-			break;
 		case HW_VAR_DM_FUNC_OP:
 			if(val[0])
 			{// save dm flag
@@ -5329,8 +5313,9 @@ _func_enter_;
 	
 					case WOWLAN_DISABLE:
 						Adapter->pwrctrlpriv.wowlan_mode=_FALSE;
-						rtl8192d_set_wowlan_cmd(Adapter);
-						rtw_msleep_os(10);
+						DBG_8192C("wake on wlan reason 0x%02x\n", rtw_read8(Adapter, REG_WOWLAN_REASON));
+						//rtl8192d_set_wowlan_cmd(Adapter);
+						//rtw_msleep_os(10);
 						break;
 	
 					case WOWLAN_STATUS:
@@ -5406,42 +5391,9 @@ _func_enter_;
 					default:
 						break;
 				}
-				if (Adapter->pwrctrlpriv.wowlan_unicast||Adapter->pwrctrlpriv.wowlan_magic || Adapter->pwrctrlpriv.wowlan_pattern)
-					Adapter->pwrctrlpriv.wowlan_mode =_TRUE;
-				else
-					Adapter->pwrctrlpriv.wowlan_mode =_FALSE;
 			}
 			break;
 #endif //CONFIG_WOWLAN
-		case HW_VAR_CHECK_TXBUF:
-#if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
-			{
-				int i;
-				u8	RetryLimit = 0x01;
-				
-				//rtw_write16(Adapter, REG_RL,0x0101);
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-		
-				for(i=0;i<1000;i++)
-				{
-					if(rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
-					{
-						//DBG_871X("packet in tx packet buffer - 0x204=%x, 0x200=%x (%d)\n", rtw_read32(Adapter, 0x204), rtw_read32(Adapter, 0x200), i);
-						rtw_msleep_os(10);
-					}
-					else
-					{
-						DBG_871X("no packet in tx packet buffer (%d)\n", i);
-						break;
-					}
-				}
-
-				RetryLimit = 0x30;	
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-		
-			}
-#endif
-			break;
 		case HW_VAR_BCN_VALID:
 			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw
 			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0); 
@@ -5450,13 +5402,13 @@ _func_enter_;
 			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, *((u8 *)val));
 			break;
 		default:
+			SetHwReg8192D(Adapter, variable, val);
 			break;
 	}
 
 _func_exit_;
 }
 
-void GetHwReg8192DU(PADAPTER Adapter, u8 variable, u8* val);
 void GetHwReg8192DU(PADAPTER Adapter, u8 variable, u8* val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -5475,9 +5427,6 @@ _func_enter_;
 			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2
 			val[0] = (BIT0 & rtw_read8(Adapter, REG_TDECTRL+2))?_TRUE:_FALSE;
 			break;
-		case HW_VAR_DM_FLAG:
-			val[0] = pHalData->dmpriv.DMFlag;
-			break;
 		case HW_VAR_RF_TYPE:
 			val[0] = pHalData->rf_type;
 			break;
@@ -5513,6 +5462,7 @@ _func_enter_;
 			*((u16 *)(val)) = pHalData->EEPROMPID;
 			break;
 		default:
+			GetHwReg8192D(Adapter, variable, val);
 			break;
 	}
 
@@ -5524,12 +5474,6 @@ _func_exit_;
 //		Query setting of specified variable.
 //
 u8
-GetHalDefVar8192DUsb(
-	IN	PADAPTER				Adapter,
-	IN	HAL_DEF_VARIABLE		eVariable,
-	IN	PVOID					pValue
-	);
-u8
 GetHalDefVar8192DUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
@@ -5574,9 +5518,6 @@ GetHalDefVar8192DUsb(
 		case HAL_DEF_DBG_DUMP_RXPKT:
 			*(( u8*)pValue) = pHalData->bDumpRxPkt;
 			break;
-		case HAL_DEF_DBG_DM_FUNC:
-			*(( u8*)pValue) = pHalData->dmpriv.DMFlag;
-			break;
 		case HAL_DEF_DUAL_MAC_MODE:
 			if ((pHalData->MacPhyMode92D == DUALMAC_DUALPHY) ||(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
 				*(( u8*)pValue) = _TRUE;
@@ -5584,8 +5525,7 @@ GetHalDefVar8192DUsb(
 				*(( u8*)pValue) = _FALSE;
 			break;
 		default:
-			//RT_TRACE(COMP_INIT, DBG_WARNING, ("GetHalDefVar8192CUsb(): Unkown variable: %d!\n", eVariable));
-			bResult = _FALSE;
+			bResult = GetHalDefVar8192D(Adapter, eVariable, pValue);
 			break;
 	}
 
@@ -5598,12 +5538,6 @@ GetHalDefVar8192DUsb(
 //		Change default setting of specified variable.
 //
 u8
-SetHalDefVar8192DUsb(
-	IN	PADAPTER				Adapter,
-	IN	HAL_DEF_VARIABLE		eVariable,
-	IN	PVOID					pValue
-	);
-u8
 SetHalDefVar8192DUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
@@ -5618,49 +5552,8 @@ SetHalDefVar8192DUsb(
 		case HAL_DEF_DBG_DUMP_RXPKT:
 			pHalData->bDumpRxPkt = *(( u8*)pValue);
 			break;
-		case HAL_DEF_DBG_DM_FUNC:
-			{
-				u8 dm_func = *(( u8*)pValue);
-				struct dm_priv	*pdmpriv = &pHalData->dmpriv;	
-				
-				if(dm_func == 0){ //disable all dynamic func
-					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
-					DBG_8192C("==> Disable all dynamic function...\n");
-				}
-				else if(dm_func == 1){//disable DIG
-					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
-					DBG_8192C("==> Disable DIG...\n");
-				}
-				else if(dm_func == 2){//disable High power
-					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_HP);
-				}
-				else if(dm_func == 3){//disable tx power tracking
-					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
-					DBG_8192C("==> Disable tx power tracking...\n");
-				}
-				else if(dm_func == 4){//disable BT coexistence
-					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_BT);
-				}
-				else if(dm_func == 5){//disable antenna diversity
-					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
-				}				
-				else if(dm_func == 6){//turn on all dynamic func
-					if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
-					{
-						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-						DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
-						pDigTable->PreIGValue = rtw_read8(Adapter,0xc50);	
-					}
-						
-					pdmpriv->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS|
-						DYNAMIC_FUNC_BT|DYNAMIC_FUNC_ANT_DIV) ;
-					DBG_8192C("==> Turn on all dynamic function...\n");
-				}			
-			}
-			break;
 		default:
-			//RT_TRACE(COMP_INIT, DBG_TRACE, ("SetHalDefVar819xUsb(): Unkown variable: %d!\n", eVariable));
-			bResult = _FALSE;
+			bResult = SetHalDefVar8192D(Adapter, eVariable, pValue);
 			break;
 	}
 
@@ -5925,11 +5818,10 @@ void rtl8192du_set_hal_ops(_adapter * padapter)
 
 _func_enter_;
 
-	padapter->HalData = rtw_zmalloc(sizeof(HAL_DATA_TYPE));
+	padapter->HalData = rtw_zvmalloc(sizeof(HAL_DATA_TYPE));
 	if(padapter->HalData == NULL){
 		DBG_8192C("cant not alloc memory for HAL DATA \n");
 	}
-	//_rtw_memset(padapter->HalData, 0, sizeof(HAL_DATA_TYPE));
 	padapter->hal_data_sz = sizeof(HAL_DATA_TYPE);
 
 	pHalFunc->hal_init = &rtl8192du_hal_init;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_ops_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_ops_linux.c
index cab8eab31cb5..693ef7ccc7b0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/hal/rtl8192d/usb/usb_ops_linux.c
@@ -1104,7 +1104,7 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 			rtw_free_recvframe(precvframe, pfree_recv_queue);
 			goto _exit_recvbuf2recvframe;
 		}
-
+#ifdef CONFIG_USB_RX_AGGREGATION //no usb rx aggregation, no skb copy
 		//	Modified by Albert 20101213
 		//	For 8 bytes IP header alignment.
 		if (pattrib->qos)	//	Qos data, wireless lan header length is 26
@@ -1164,7 +1164,14 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 
 		recvframe_put(precvframe, skb_len);
 		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
-
+#else //CONFIG_USB_RX_AGGREGATION
+		precvframe->u.hdr.pkt = pskb;
+		precvframe->u.hdr.rx_head = pskb->data;
+		precvframe->u.hdr.rx_end = skb_end_pointer(pskb);
+		precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pskb->data;
+		recvframe_put(precvframe, pkt_offset);
+		recvframe_pull(precvframe, pattrib->drvinfo_sz + RXDESC_SIZE);
+#endif //CONFIG_USB_RX_AGGREGATION, no usb rx aggregation, no copy
 #ifdef CONFIG_USB_RX_AGGREGATION
 		switch(pHalData->UsbRxAggMode)
 		{
@@ -1237,7 +1244,7 @@ void rtl8192du_recv_tasklet(void *priv)
 		}
 	
 		recvbuf2recvframe(padapter, pskb);
-
+#ifdef CONFIG_USB_RX_AGGREGATION //no usb rx aggregation, no copy
 #ifdef CONFIG_PREALLOC_RECV_SKB
 
 		skb_reset_tail_pointer(pskb);
@@ -1248,6 +1255,7 @@ void rtl8192du_recv_tasklet(void *priv)
 #else
 		rtw_skb_free(pskb);
 #endif
+#endif //CONFIG_USB_RX_AGGREGATION, no usb rx aggregation, no copy
 				
 	}
 	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192CPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192CPhyReg.h
index 6364166d68cf..82aa0200842d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192CPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192CPhyReg.h
@@ -1066,6 +1066,7 @@
 #define		bMaskByte1			0xff00
 #define		bMaskByte2			0xff0000
 #define		bMaskByte3			0xff000000
+#define		bMaskH3Bytes		0xffffff00
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyCfg.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyCfg.h
index db0bddbbffe4..6872b0ff0f4b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyCfg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyCfg.h
@@ -425,7 +425,7 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192D(IN	PADAPTER	pAdapter,
 //
 // IQ calibrate
 //
-void	rtl8192d_PHY_IQCalibrate(	IN	PADAPTER	pAdapter);
+void	rtl8192d_PHY_IQCalibrate(	IN	PADAPTER	pAdapter, IN	u8		FromPT);
 
 
 //
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyReg.h
index f28aa033bbe0..bccade6f1448 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/Hal8192DPhyReg.h
@@ -1108,6 +1108,7 @@
 #define		bMaskByte1			0xff00
 #define		bMaskByte2			0xff0000
 #define		bMaskByte3			0xff000000
+#define		bMaskH3Bytes		0xffffff00
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/autoconf.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/autoconf.h
old mode 100755
new mode 100644
index 5b1736b8a5a5..aa8702e0945c
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/autoconf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/autoconf.h
@@ -104,7 +104,7 @@
 
 	//#define CONFIG_P2P_PS
 	#define CONFIG_P2P_IPS
-	#define P2P_OP_CHECK_SOCIAL_CH
+	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
 		// Added comment by Borg 2013/06/21
 		// Issue:  Nexus 4 is hard to do miracast.
 		// Root Cause: After group formation, 
@@ -112,6 +112,8 @@
 		// Patch: While scan OP channel, 
 		//		 not only scan OP channel of Invitation Resp/Nego Confirm, 
 		//		 but also scan social channel(1, 6, 11)
+	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  
+	#define CONFIG_P2P_INVITE_IOT
 #endif
 
 //	Added by Kurt 20110511
@@ -150,7 +152,6 @@
 #endif	// CONFIG_BR_EXT
 
 #define CONFIG_TX_MCAST2UNI	1	// Support IP multicast->unicast
-//#define CONFIG_DM_ADAPTIVITY 1
 //#define CONFIG_CHECK_AC_LIFETIME	1	// Check packet lifetime of 4 ACs.
 //#define CONFIG_DISABLE_MCS13TO15	1	// Disable MSC13-15 rates for more stable TX throughput with some 5G APs
 
@@ -165,7 +166,7 @@
 #ifdef CONFIG_CONCURRENT_MODE
 	#define CONFIG_TSF_RESET_OFFLOAD 1			// For 2 PORT TSF SYNC.
 	//#define CONFIG_HWPORT_SWAP				//Port0->Sec , Port1 -> Pri
-	//#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+	#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 	//#define CONFIG_MULTI_VIR_IFACES //besides primary&secondary interfaces, extend to support more interfaces
 	#undef CONFIG_DUALMAC_CONCURRENT //can not turn on CONFIG_CONCURRENT_MODE & CONFIG_DUALMAC_CONCURRENT at the same time
 #endif	// CONFIG_CONCURRENT_MODE
@@ -264,7 +265,7 @@
 
 #define DBG 0
 
-//#define CONFIG_DEBUG_RTL819X
+//#define CONFIG_DEBUG
 
 #define CONFIG_PROC_DEBUG 1
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/drv_types.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/drv_types.h
index 0ac34f21e33e..a3c55cbb3f96 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/drv_types.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/drv_types.h
@@ -85,6 +85,8 @@ typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
 #include <rtw_tdls.h>
 #include <rtw_ap.h>
 
+#include "../hal/dm.h"
+
 #ifdef CONFIG_DRVEXT_MODULE
 #include <drvext_api.h>
 #endif
@@ -231,11 +233,27 @@ struct registry_priv
 #define INTF_DATA SDIO_DATA
 #endif
 
+#ifdef CONFIG_CONCURRENT_MODE
+#define is_primary_adapter(adapter) (adapter->adapter_type == PRIMARY_ADAPTER)
+#define get_iface_type(adapter) (adapter->iface_type)
+#else
+#define is_primary_adapter(adapter) (1)
+#define get_iface_type(adapter) (IFACE_PORT0)
+#endif
 #define GET_PRIMARY_ADAPTER(padapter) (((_adapter *)padapter)->dvobj->if1)
-
 #define GET_IFACE_NUMS(padapter) (((_adapter *)padapter)->dvobj->iface_nums)
 #define GET_ADAPTER(padapter, iface_id) (((_adapter *)padapter)->dvobj->padapters[iface_id])
 
+struct debug_priv {
+	u64 dbg_rx_fifo_last_overflow;
+	u64 dbg_rx_fifo_curr_overflow;
+	u64 dbg_rx_fifo_diff_overflow;
+	u64 dbg_rx_ampdu_drop_count;
+	u64 dbg_rx_ampdu_forced_indicate_count;
+	u64 dbg_rx_ampdu_loss_count;
+	u64 dbg_rx_ampdu_window_shift_cnt;
+	u64 dbg_rx_dup_mgt_frame_drop_count;};
+
 enum _IFACE_ID {
 	IFACE_ID0, //maping to PRIMARY_ADAPTER
 	IFACE_ID1, //maping to SECONDARY_ADAPTER
@@ -250,7 +268,7 @@ struct dvobj_priv
 	_adapter *if2; //SECONDARY_ADAPTER
 
 	s32 processing_dev_remove;
-
+	struct debug_priv drv_dbg;
 	//for local/global synchronization
 	_mutex hw_init_mutex;
 	_mutex h2c_fwcmd_mutex;
@@ -377,6 +395,8 @@ struct dvobj_priv
 #endif//PLATFORM_LINUX
 
 #endif//CONFIG_PCI_HCI
+
+	DM_ODM_T odmpriv;
 };
 
 #ifdef PLATFORM_LINUX
@@ -547,6 +567,7 @@ struct _ADAPTER{
 
 #ifdef PLATFORM_LINUX
 	_nic_hdl pnetdev;
+	char old_ifname[IFNAMSIZ];
 
 	// used by rtw_rereg_nd_name related function
 	struct rereg_nd_name_data {
@@ -560,9 +581,11 @@ struct _ADAPTER{
 	struct net_device_stats stats;
 	struct iw_statistics iwstats;
 	struct proc_dir_entry *dir_dev;// for proc directory
+	struct proc_dir_entry *dir_dm;
 
 #ifdef CONFIG_IOCTL_CFG80211
 	struct wireless_dev *rtw_wdev;
+	struct rtw_wdev_priv wdev_data;
 #endif //CONFIG_IOCTL_CFG80211
 
 #endif //end of PLATFORM_LINUX
@@ -646,9 +669,12 @@ struct _ADAPTER{
 	PLOOPBACKDATA ploopback;
 #endif
 
+	u8 fix_rate;
 };
 
 #define adapter_to_dvobj(adapter) (adapter->dvobj)
+#define adapter_to_odm(adapter) (&(adapter->dvobj->odmpriv))
+#define adapter_wdev_data(adapter) (&((adapter)->wdev_data))
 
 int rtw_handle_dualmac(_adapter *adapter, bool init);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_com.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_com.h
index 42aae0e057b1..06cc9d0e8c47 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_com.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_com.h
@@ -142,5 +142,10 @@ void hal_init_macaddr(_adapter *adapter);
 void c2h_evt_clear(_adapter *adapter);
 s32 c2h_evt_read(_adapter *adapter, u8 *buf);
 
+void SetHwReg(_adapter *adapter, HW_VARIABLES variable, u8 *val);
+void GetHwReg(_adapter *adapter, HW_VARIABLES variable, u8 *val);
+u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+
 #endif //__HAL_COMMON_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_intf.h
index dd8266229edd..a67b472a4842 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/hal_intf.h
@@ -118,6 +118,8 @@ typedef enum _HW_VARIABLES{
 	HW_VAR_MBSSID_CAM_CLEAR,
 	HW_VAR_RCR_MBSSID_EN,
 	HW_VAR_USB_RXAGG_PAGE_TO,
+	HW_VAR_ENC_BMC_ENABLE,
+	HW_VAR_ENC_BMC_DISABLE,
 }HW_VARIABLES;
 
 typedef enum _HAL_DEF_VARIABLE{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ieee80211.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ieee80211.h
index e283a5f25d4c..4a199d3e5f62 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ieee80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ieee80211.h
@@ -606,6 +606,7 @@ struct ieee80211_snap_hdr {
 #define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
 #define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
 #define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_ACTIVE_ROAM 65533
 #define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
 #define WLAN_REASON_EXPIRATION_CHK 65535
 
@@ -1523,6 +1524,7 @@ int rtw_parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwi
 int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
 
 u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
+u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type);
 u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
 u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_attr, u32 *len_attr);
 u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_content, uint *len_content);
@@ -1544,6 +1546,7 @@ u32 rtw_get_p2p_merged_ies_len(u8 *in_ie, u32 in_len);
 int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie);
 void dump_p2p_ie(u8 *ie, u32 ie_len);
 u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
+u8 *rtw_get_p2p_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen, u8 frame_type);
 u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_attr, u32 *len_attr);
 u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_content, uint *len_content);
 u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr);
@@ -1552,6 +1555,7 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
 
 #ifdef CONFIG_WFD
 int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
+int rtw_get_wfd_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen, u8 frame_type);
 int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen);
 #endif // CONFIG_WFD
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ioctl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ioctl_cfg80211.h
index 2f824b3edaa6..f1a572f83346 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ioctl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/ioctl_cfg80211.h
@@ -55,7 +55,7 @@ struct rtw_wdev_invit_info {
 	} while (0)
 
 struct rtw_wdev_nego_info {
-	u8 state; /* 0: req, 1:rep, 3:conf */
+	u8 state; /* 0: req, 1:rep, 2:conf */
 	u8 peer_mac[ETH_ALEN];
 	u8 active;
 	u8 token;
@@ -113,11 +113,9 @@ struct rtw_wdev_priv
 	
 };
 
-#define wdev_to_priv(w) ((struct rtw_wdev_priv *)(wdev_priv(w)))
+#define wiphy_to_adapter(x) (*((_adapter**)wiphy_priv(x)))
 
-#define wiphy_to_adapter(x) (_adapter *)(((struct rtw_wdev_priv*)wiphy_priv(x))->padapter)
-
-#define wiphy_to_wdev(x) (struct wireless_dev *)(((struct rtw_wdev_priv*)wiphy_priv(x))->rtw_wdev)
+#define wdev_to_ndev(w) ((w)->netdev)
 
 int rtw_wdev_alloc(_adapter *padapter, struct device *dev);
 void rtw_wdev_free(struct wireless_dev *wdev);
@@ -130,7 +128,7 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 int rtw_cfg80211_check_bss(_adapter *padapter);
 void rtw_cfg80211_indicate_connect(_adapter *padapter);
 void rtw_cfg80211_indicate_disconnect(_adapter *padapter);
-void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted);
+void rtw_cfg80211_indicate_scan_done(_adapter *adapter, bool aborted);
 
 #ifdef CONFIG_AP_MODE
 void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_intf.h
index 3cd165969f2f..30a492c37315 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_intf.h
@@ -115,13 +115,10 @@ void rtw_unregister_netdevs(struct dvobj_priv *dvobj);
 u16 rtw_recv_select_queue(struct sk_buff *skb);
 #endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
 
-#ifdef CONFIG_PROC_DEBUG
-void rtw_proc_init_one(struct net_device *dev);
-void rtw_proc_remove_one(struct net_device *dev);
-#else //!CONFIG_PROC_DEBUG
-static void rtw_proc_init_one(struct net_device *dev){}
-static void rtw_proc_remove_one(struct net_device *dev){}
-#endif //!CONFIG_PROC_DEBUG
+int rtw_ndev_notifier_register(void);
+void rtw_ndev_notifier_unregister(void);
+
+#include "../os_dep/linux/rtw_proc.h"
 #endif //PLATFORM_LINUX
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_service.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_service.h
index d75f795f1b05..4b6d418aa492 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_service.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/osdep_service.h
@@ -782,7 +782,6 @@ __inline static void _set_workitem(_workitem *pwork)
 	#include <linux/if_arp.h>
 	#include <linux/rtnetlink.h>
 	#include <linux/delay.h>
-	#include <linux/proc_fs.h>	// Necessary because we use the proc fs
 	#include <linux/interrupt.h>	// for struct tasklet_struct
 	#include <linux/ip.h>
 	#include <linux/kthread.h>
@@ -1238,7 +1237,7 @@ __inline static void _set_workitem(_workitem *pwork)
 
 extern int RTW_STATUS_CODE(int error_code);
 
-//#define CONFIG_USE_VMALLOC
+#define CONFIG_USE_VMALLOC
 
 /* flags used for rtw_mstat_update() */
 enum mstat_f {
@@ -1270,8 +1269,7 @@ typedef enum mstat_status{
 
 #ifdef DBG_MEM_ALLOC
 void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz);
-int _rtw_mstat_dump(char *buf, int len);
-void rtw_mstat_dump (void);
+void rtw_mstat_dump(void *sel);
 u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
 u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
 void dbg_rtw_vmfree(u8 *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
@@ -1332,7 +1330,7 @@ void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dm
 
 #else /* DBG_MEM_ALLOC */
 #define rtw_mstat_update(flag, status, sz) do {} while(0)
-#define rtw_mstat_dump() do {} while(0)
+#define rtw_mstat_dump(sel) do {} while(0)
 u8*	_rtw_vmalloc(u32 sz);
 u8*	_rtw_zvmalloc(u32 sz);
 void	_rtw_vmfree(u8 *pbuf, u32 sz);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_dm.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_dm.h
index 9d065405ecbc..07e5b1d91437 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_dm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_dm.h
@@ -462,21 +462,6 @@ struct 	dm_priv
 
 	// Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas
 	u8	INIDATA_RATE[32];
-
-#ifdef CONFIG_DM_ADAPTIVITY
-	/* Ported from ODM, for ESTI Adaptivity test */
-	s8 TH_L2H_ini;
-	s8 TH_EDCCA_HL_diff;
-	s8 IGI_Base;
-	u8 IGI_target;
-	bool ForceEDCCA;
-	u8 AdapEn_RSSI;
-	s8 Force_TH_H;
-	s8 Force_TH_L;
-	u8 IGI_LowerBound;
-
-	bool	bPreEdccaEnable;
-#endif
 };
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_hal.h
index 3348971c8018..cfa19d01f07d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192c_hal.h
@@ -32,6 +32,7 @@
 #ifdef DBG_CONFIG_ERROR_DETECT
 #include "rtl8192c_sreset.h"
 #endif
+#include "rtw_efuse.h"
 
 #ifdef CONFIG_PCI_HCI
 
@@ -666,6 +667,8 @@ struct hal_data_8192ce
 	u8	FwRsvdPageStartOffset; //2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.
 
 	u16	EfuseUsedBytes;
+
+	EFUSE_HAL			EfuseHal;
 	
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
@@ -874,7 +877,9 @@ struct hal_data_8192cu
 	BOOLEAN		SlimComboDbg;
 
 	u16	EfuseUsedBytes;
-
+	
+	EFUSE_HAL			EfuseHal;
+	
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
 #endif //CONFIG_P2P
@@ -901,6 +906,12 @@ VOID rtl8192c_EfuseParseIDCode(PADAPTER pAdapter, u8 *hwinfo);
 void rtl8192c_set_hal_ops(struct hal_ops *pHalFunc);
 
 s32 c2h_id_filter_ccx_8192c(u8 id);
+
+void SetHwReg8192C(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8192C(PADAPTER padapter, u8 variable, u8 *val);
+u8 SetHalDefVar8192C(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+u8 GetHalDefVar8192C(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+
 #endif
 
 #ifdef CONFIG_MP_INCLUDED
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_dm.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_dm.h
index e794c6f24af7..5d4942583d8e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_dm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_dm.h
@@ -384,21 +384,6 @@ struct 	dm_priv
 
 	// Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas
 	u8	INIDATA_RATE[32];
-
-#ifdef CONFIG_DM_ADAPTIVITY
-	/* Ported from ODM, for ESTI Adaptivity test */
-	s8 TH_L2H_ini;
-	s8 TH_EDCCA_HL_diff;
-	s8 IGI_Base;
-	u8 IGI_target;
-	bool ForceEDCCA;
-	u8 AdapEn_RSSI;
-	s8 Force_TH_H;
-	s8 Force_TH_L;
-	u8 IGI_LowerBound;
-
-	bool	bPreEdccaEnable;
-#endif
 };
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_hal.h
index b22ff1db58b6..02390293a0e1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_hal.h
@@ -29,6 +29,7 @@
 #include "rtl8192d_recv.h"
 #include "rtl8192d_xmit.h"
 #include "rtl8192d_cmd.h"
+#include "rtw_efuse.h"
 
 /*---------------------------Define Local Constant---------------------------*/
 /* Channel switch:The size of command tables for switch channel*/
@@ -840,6 +841,9 @@ struct hal_data_8192de
 
 	u16	EfuseUsedBytes;
 	u8	RTSInitRate;	 // 2010.11.24.by tynli.
+
+	EFUSE_HAL			EfuseHal;
+	
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
 #endif //CONFIG_P2P
@@ -909,7 +913,7 @@ struct hal_data_8192du
 	u8	nCur40MhzPrimeSC;// Control channel sub-carrier
 	u16	BasicRateSet;
 
-	INTERFACE_SELECT_8192DUSB	InterfaceSel;
+	u8	BoardType;
 
 	//rf_ctrl
 	u8	rf_chip;
@@ -966,6 +970,8 @@ struct hal_data_8192du
 	u8	ExternalPA;
 	u8	InternalPA5G[2];	//pathA / pathB
 
+	u8	bLedOpenDrain; // Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16.
+
 	//u32	LedControlNum;
 	//u32	LedControlMode;
 	//u32	TxPowerTrackControl;
@@ -1067,6 +1073,8 @@ struct hal_data_8192du
 
 	u16	EfuseUsedBytes;
 	u8	RTSInitRate;	 // 2010.11.24.by tynli.
+
+	EFUSE_HAL			EfuseHal;
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
 #endif //CONFIG_P2P
@@ -1091,6 +1099,11 @@ VOID PHY_SetPowerOnFor8192D(PADAPTER Adapter);
 void rtl8192d_free_hal_data(_adapter * padapter);
 void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc);
 
+void SetHwReg8192D(_adapter *adapter, u8 variable, u8 *val);
+void GetHwReg8192D(_adapter *adapter, u8 variable, u8 *val);
+u8 SetHalDefVar8192D(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+u8 GetHalDefVar8192D(_adapter *adapter, HAL_DEF_VARIABLE variable, void *val);
+
 #endif
 
 #ifdef CONFIG_MP_INCLUDED
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_recv.h
index 36cc2322be76..4997e25bc230 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_recv.h
@@ -64,7 +64,11 @@
 		#ifdef CONFIG_PLATFORM_MSTAR
 			#define MAX_RECVBUF_SZ (8192) // 8K
 		#else
+			#ifndef CONFIG_USB_RX_AGGREGATION
+			#define MAX_RECVBUF_SZ (4000) // about 4K
+			#else
 			#define MAX_RECVBUF_SZ (15360) // 15k < 16k
+			#endif //CONFIG_USB_RX_AGGREGATION
 		#endif
 	#else
 		#define MAX_RECVBUF_SZ (4000) // about 4K
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_spec.h
index bef7184e27c0..5bcfe03069b1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_spec.h
@@ -1034,6 +1034,15 @@ Default: 00b.
 #define	EEPROM_CID_CCX							0x10 // CCX test. By Bruce, 2009-02-25.
 
 #endif
+
+//should be renamed and moved to another file
+typedef	enum _BOARD_TYPE_8192DUSB{
+	BOARD_USB_DONGLE 			= 0,		// USB dongle
+	BOARD_USB_High_PA 		= 1,		// USB dongle with high power PA
+	BOARD_MINICARD		  	= 2,		// Minicard
+	BOARD_USB_SOLO 		 	= 3,		// USB solo-Slim module
+	BOARD_USB_COMBO			= 4,		// USB Combo-Slim module
+} BOARD_TYPE_8192DUSB, *PBOARD_TYPE_8192DUSB;
 #endif
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_xmit.h
index d01fb4a76caa..3fd097fd2f21 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtl8192d_xmit.h
@@ -33,7 +33,11 @@
 #define QSLT_CMD						0x13
 
 //Because we open EM for normal case, we just always insert 2*8 bytes.by wl
+#ifdef USB_PACKET_OFFSET_SZ
+#define USB_92D_DUMMY_OFFSET		(PACKET_OFFSET_SZ/8)
+#else
 #define USB_92D_DUMMY_OFFSET		2
+#endif
 #define USB_92D_DUMMY_LENGTH		(USB_92D_DUMMY_OFFSET * PACKET_OFFSET_SZ)
 #define USB_HWDESC_HEADER_LEN	(TXDESC_SIZE + USB_92D_DUMMY_LENGTH)
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_android.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_android.h
index f9214c2d8a05..767a830a55cb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_android.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_android.h
@@ -66,6 +66,7 @@ enum ANDROID_WIFI_CMD {
 	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
 	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
 
+	ANDROID_WIFI_CMD_P2P_DISABLE,
 	ANDROID_WIFI_CMD_MAX
 };
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_ap.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_ap.h
index 66085c370434..cbac08aa0b48 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_ap.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_ap.h
@@ -60,5 +60,7 @@ void stop_ap_mode(_adapter *padapter);
 #endif
 #endif //end of CONFIG_AP_MODE
 
+void update_bmc_sta(_adapter *padapter);
+
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_debug.h
index 0ccf2206e582..f9f9c18bba37 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_debug.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,18 +24,17 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
+#define _drv_always_		1
+#define _drv_emerg_			2
+#define _drv_alert_			3
+#define _drv_crit_			4
+#define _drv_err_			5
+#define	_drv_warning_		6
+#define _drv_notice_		7
+#define _drv_info_			8
+#define _drv_dump_			9
+#define	_drv_debug_			10
 
-#define	_no_debug_			0
-#define _drv_emerg_			1
-#define _drv_alert_			2
-#define _drv_crit_			3
-#define _drv_err_			4
-#define	_drv_warning_		5
-#define _drv_notice_			6
-#define _drv_info_			7
-#define _drv_dump_			8
-#define	_drv_debug_		9
-#define _drv_always_ _drv_emerg_
 
 #define _module_rtl871x_xmit_c_		BIT(0)
 #define _module_xmit_osdep_c_		BIT(1)
@@ -105,7 +104,7 @@
 	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
 #elif defined _HAL_INTF_C_
 	#define	_MODULE_DEFINE_	_module_hal_init_c_
-#elif defined _HCI_HAL_INIT_C_
+#elif (defined _HCI_HAL_INIT_C_) || (defined _SDIO_HALINIT_C_)
 	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
 #elif defined _RTL871X_IOCTL_C_
 	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
@@ -160,379 +159,243 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 #define _func_exit_ do{}while(0)
 #define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen) do{}while(0)
 
-#undef	_dbgdump
-
-#ifdef CONFIG_DEBUG_RTL871X
-
-#ifndef _RTL871X_DEBUG_C_
-	extern u32 GlobalDebugLevel;
-	extern u64 GlobalDebugComponents;
-#endif
-
-#ifdef PLATFORM_WINDOWS
-
-	#ifdef PLATFORM_OS_XP
-
-	#define _dbgdump	DbgPrint
-
-	#elif defined PLATFORM_OS_CE
-
-	#define _dbgdump	rtl871x_cedbg
-
-	#endif
-
-#elif defined PLATFORM_LINUX
-
-	#define _dbgdump	printk
-
-#elif defined PLATFORM_FREEBSD
-
-	#define _dbgdump	printf
-
-#endif
-
-#endif /* CONFIG_DEBUG_RTL871X */
-
-
-#if	defined (_dbgdump) && defined (_MODULE_DEFINE_)
-
-		#undef RT_TRACE
-		#define RT_TRACE(_Comp, _Level, Fmt)\
-		do {\
-			if((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
-				_dbgdump("%s [0x%08x,%d]", RTL871X_MODULE_NAME, (unsigned int)_Comp, _Level);\
-				_dbgdump Fmt;\
-			}\
-		}while(0)
-
-#endif
-
-
-#if	defined (_dbgdump)
-
-		#undef  _func_enter_
-		#define _func_enter_ \
-		do {	\
-			if (GlobalDebugLevel >= _drv_debug_) \
-			{																	\
-				_dbgdump("\n %s : %s enters at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__);\
-			}		\
-		} while(0)
-
-		#undef  _func_exit_
-		#define _func_exit_ \
-		do {	\
-			if (GlobalDebugLevel >= _drv_debug_) \
-			{																	\
-				_dbgdump("\n %s : %s exits at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__); \
-			}	\
-		} while(0)
-
-		#undef RT_PRINT_DATA
-		#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
-			{									\
-				int __i;								\
-				u8	*ptr = (u8 *)_HexData;				\
-				_dbgdump("Rtl871x: ");						\
-				_dbgdump(_TitleString);						\
-				for( __i=0; __i<(int)_HexDataLen; __i++ )				\
-				{								\
-					_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");	\
-					if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
-				}								\
-				_dbgdump("\n");							\
-			}
-#endif
-
-
-#ifdef CONFIG_DEBUG_RTL819X
-
-#undef	_dbgdump
-
-#ifdef PLATFORM_WINDOWS
-
-	#ifdef PLATFORM_OS_XP
-
-	#define _dbgdump	DbgPrint
-
-	#elif defined PLATFORM_OS_CE
-
-	#define _dbgdump	rtl871x_cedbg
-
-	#endif
-
-#elif defined PLATFORM_LINUX
-
-	#define _dbgdump	printk
-
-#elif defined PLATFORM_FREEBSD
-
-	#define _dbgdump	printf
-
-#endif
-
-#endif /* CONFIG_DEBUG_RTL819X */
-
-
 #ifdef PLATFORM_WINDOWS
 	#define DBG_871X do {} while(0)
 	#define MSG_8192C do {} while(0)
 	#define DBG_8192C do {} while(0)
-	#define WRN_8192C do {} while(0)
-	#define ERR_8192C do {} while(0)
-#endif
-
-#ifdef PLATFORM_LINUX
+	#define DBG_871X_LEVEL do {} while(0)
+#else
 	#define DBG_871X(x, ...) do {} while(0)
 	#define MSG_8192C(x, ...) do {} while(0)
 	#define DBG_8192C(x,...) do {} while(0)
-	#define WRN_8192C(x,...) do {} while(0)
-	#define ERR_8192C(x,...) do {} while(0)
+	#define DBG_871X_LEVEL(x,...) do {} while(0)
 #endif
 
-#ifdef PLATFORM_FREEBSD
-	#define _dbgdump	printf
-	#define DBG_871X(x, ...) do {} while(0)
-	#define MSG_8192C(x, ...) do {} while(0)
-	#define DBG_8192C(x,...) do {} while(0)
-	#define WRN_8192C(x,...) do {} while(0)
-	#define ERR_8192C(x,...) do {} while(0)
+#undef _dbgdump
+#undef _seqdump
+
+#ifndef _RTL871X_DEBUG_C_
+	extern u32 GlobalDebugLevel;
+	extern u64 GlobalDebugComponents;
 #endif
 
-extern u32 GlobalDebugLevel;
-#define LOG_LEVEL(level, ...)\
-                do {\
-                        if(level <= GlobalDebugLevel) {\
-                                printk(__VA_ARGS__);\
-                        }\
-                }while(0)
+#if defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_XP)
+	#define _dbgdump DbgPrint
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#elif defined(PLATFORM_WINDOWS) && defined(PLATFORM_OS_CE)
+	#define _dbgdump rtl871x_cedbg
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#elif defined PLATFORM_LINUX
+	#define _dbgdump printk
+	#define _seqdump seq_printf
+#elif defined PLATFORM_FREEBSD
+	#define _dbgdump printf
+	#define _seqdump(sel, fmt, arg...) _dbgdump(fmt, ##arg)
+#endif
 
-#define DBG_871X_LEVEL LOG_LEVEL
+#define DRIVER_PREFIX "RTL871X: "
+
+#if defined(_dbgdump)
+
+/* with driver-defined prefix */
+#undef DBG_871X_LEVEL
+#define DBG_871X_LEVEL(level, fmt, arg...)     \
+	do {\
+		if (level <= GlobalDebugLevel) {\
+			if (level <= _drv_err_ && level > _drv_always_) \
+				_dbgdump(DRIVER_PREFIX"ERROR " fmt, ##arg);\
+			else \
+				_dbgdump(DRIVER_PREFIX fmt, ##arg);\
+		}\
+	}while(0)
+
+/* without driver-defined prefix */
+#undef _DBG_871X_LEVEL
+#define _DBG_871X_LEVEL(level, fmt, arg...)	   \
+	do {\
+		if (level <= GlobalDebugLevel) {\
+			if (level <= _drv_err_ && level > _drv_always_) \
+				_dbgdump("ERROR " fmt, ##arg);\
+			else \
+				_dbgdump(fmt, ##arg);\
+		}\
+	}while(0)
+
+#define LOG_LEVEL DBG_871X_LEVEL
+
+#if defined(_seqdump)
+#define RTW_DBGDUMP 0 /* 'stream' for _dbgdump */
+
+/* dump message to selected 'stream' */
+#define DBG_871X_SEL(sel, fmt, arg...) \
+	do {\
+		if (sel == RTW_DBGDUMP)\
+			_DBG_871X_LEVEL(_drv_always_, fmt, ##arg); \
+		else {\
+			if(_seqdump(sel, fmt, ##arg)) /*rtw_warn_on(1)*/; \
+		} \
+	}while(0)
+
+/* dump message to selected 'stream' with driver-defined prefix */
+#define DBG_871X_SEL_NL(sel, fmt, arg...) \
+	do {\
+		if (sel == RTW_DBGDUMP)\
+			DBG_871X_LEVEL(_drv_always_, fmt, ##arg); \
+		else {\
+			if(_seqdump(sel, fmt, ##arg)) /*rtw_warn_on(1)*/; \
+		} \
+	}while(0)
+
+#endif /* defined(_seqdump) */
+
+#endif /* defined(_dbgdump) */
+
+#ifdef CONFIG_DEBUG
+#if	defined(_dbgdump)
+	#undef DBG_871X
+	#define DBG_871X(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+
+	#undef MSG_8192C
+	#define MSG_8192C(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+
+	#undef DBG_8192C
+	#define DBG_8192C(...)     do {\
+		_dbgdump(DRIVER_PREFIX __VA_ARGS__);\
+	}while(0)
+#endif /* defined(_dbgdump) */
+#endif /* CONFIG_DEBUG */
 
-#if     defined (_dbgdump)
-        #undef DBG_871X
-//      #define DBG_871X _dbgdump
-        #define DBG_871X(...) LOG_LEVEL(_drv_emerg_ , __VA_ARGS__)
+#ifdef CONFIG_DEBUG_RTL871X
 
-        #undef MSG_8192C
-//      #define MSG_8192C _dbgdump
-        #define MSG_8192C(...) LOG_LEVEL(_drv_emerg_ , __VA_ARGS__)
+#if	defined(_dbgdump) && defined(_MODULE_DEFINE_)
+
+	#undef RT_TRACE
+	#define RT_TRACE(_Comp, _Level, Fmt)\
+	do {\
+		if((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
+			_dbgdump("%s [0x%08x,%d]", DRIVER_PREFIX, (unsigned int)_Comp, _Level);\
+			_dbgdump Fmt;\
+		}\
+	}while(0)
+
+#endif /* defined(_dbgdump) && defined(_MODULE_DEFINE_) */
+
+
+#if	defined(_dbgdump)
+	#undef  _func_enter_
+	#define _func_enter_ \
+	do {	\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{																	\
+			_dbgdump("\n %s : %s enters at %d\n", DRIVER_PREFIX, __FUNCTION__, __LINE__);\
+		}		\
+	} while(0)
+
+	#undef  _func_exit_
+	#define _func_exit_ \
+	do {	\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{																	\
+			_dbgdump("\n %s : %s exits at %d\n", DRIVER_PREFIX, __FUNCTION__, __LINE__); \
+		}	\
+	} while(0)
+
+	#undef RT_PRINT_DATA
+	#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
+		if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+		{									\
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			_dbgdump("%s", DRIVER_PREFIX);						\
+			_dbgdump(_TitleString);						\
+			for( __i=0; __i<(int)_HexDataLen; __i++ )				\
+			{								\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");	\
+				if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
+			}								\
+			_dbgdump("\n");							\
+		}
+#endif /* defined(_dbgdump) */
+#endif /* CONFIG_DEBUG_RTL871X */
 
-        #undef DBG_8192C
-//      #define DBG_8192C _dbgdump
-        #define DBG_8192C(...) LOG_LEVEL(_drv_emerg_ ,  __VA_ARGS__)
+void dump_drv_version(void *sel);
+void dump_log_level(void *sel);
 
+void mac_reg_dump(void *sel, _adapter *adapter);
+void bb_reg_dump(void *sel, _adapter *adapter);
+void rf_reg_dump(void *sel, _adapter *adapter);
 
-	#undef WRN_8192C
-	#define WRN_8192C _dbgdump
+#ifdef CONFIG_PROC_DEBUG
+ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_read_reg(struct seq_file *m, void *v);
+ssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_hw_status(struct seq_file *m, void *v);
+int proc_get_fwstate(struct seq_file *m, void *v);
+int proc_get_sec_info(struct seq_file *m, void *v);
+int proc_get_mlmext_state(struct seq_file *m, void *v);
+#ifdef CONFIG_LAYER2_ROAMING
+int proc_get_roam_flags(struct seq_file *m, void *v);
+ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_roam_param(struct seq_file *m, void *v);
+ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_LAYER2_ROAMING */
+int proc_get_qos_option(struct seq_file *m, void *v);
+int proc_get_ht_option(struct seq_file *m, void *v);
+int proc_get_rf_info(struct seq_file *m, void *v);
+int proc_get_survey_info(struct seq_file *m, void *v);
+int proc_get_ap_info(struct seq_file *m, void *v);
+int proc_get_adapter_state(struct seq_file *m, void *v);
+int proc_get_trx_info(struct seq_file *m, void *v);
+int proc_get_rate_ctl(struct seq_file *m, void *v);
+ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-	#undef ERR_8192C
-	#define ERR_8192C _dbgdump
-#endif
+#ifdef CONFIG_AP_MODE
+int proc_get_all_sta_info(struct seq_file *m, void *v);
+#endif /* CONFIG_AP_MODE */
 
+#ifdef DBG_MEMORY_LEAK
+int proc_get_malloc_cnt(struct seq_file *m, void *v);
+#endif /* DBG_MEMORY_LEAK */
 
-#ifdef CONFIG_PROC_DEBUG
+#ifdef CONFIG_FIND_BEST_CHANNEL
+int proc_get_best_channel(struct seq_file *m, void *v);
+ssize_t proc_set_best_channel(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_FIND_BEST_CHANNEL */
 
-	int proc_get_drv_version(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_log_level(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-			  
-	int proc_set_log_level(struct file *file, const char *buffer,
-			unsigned long count, void *data);
-
-#ifdef DBG_MEM_ALLOC
-	int proc_get_mstat(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-#endif /* DBG_MEM_ALLOC */
-
-	int proc_get_write_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
- 	int proc_set_write_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-
-	int proc_get_read_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_set_read_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-
-
-	int proc_get_fwstate(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_sec_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_mlmext_state(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_qos_option(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_ht_option(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_rf_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_ap_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_adapter_state(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_trx_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_mac_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_mac_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_mac_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-	
-	int proc_get_bb_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_bb_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-	
-	int proc_get_bb_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-	
-	int proc_get_rf_reg_dump1(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_rf_reg_dump2(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_rf_reg_dump3(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_rf_reg_dump4(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
+int proc_get_rx_signal(struct seq_file *m, void *v);
+ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-#ifdef CONFIG_AP_MODE
+int proc_get_ht_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-	int proc_get_all_sta_info(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
+int proc_get_cbw40_enable(struct seq_file *m, void *v);
+ssize_t proc_set_cbw40_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-#endif
+int proc_get_ampdu_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-#ifdef DBG_MEMORY_LEAK
-	int proc_get_malloc_cnt(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-#endif
+int proc_get_rx_stbc(struct seq_file *m, void *v);
+ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-#ifdef CONFIG_FIND_BEST_CHANNEL
-	int proc_get_best_channel(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-	int proc_set_best_channel(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-#endif
+int proc_get_two_path_rssi(struct seq_file *m, void *v);
+int proc_get_rssi_disp(struct seq_file *m, void *v);
+ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-	int proc_get_rx_signal(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_set_rx_signal(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-		
-	int proc_get_ht_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-			  
-	int proc_set_ht_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-			  
-	int proc_get_cbw40_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_set_cbw40_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-	
-	int proc_get_ampdu_enable(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-			  
-	int proc_set_ampdu_enable(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-	
-	int proc_get_two_path_rssi(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-	
-	int proc_get_rx_stbc(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-		
-	int proc_set_rx_stbc(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-
-
-	int proc_get_vid(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_pid(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_get_rssi_disp(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-
-	int proc_set_rssi_disp(struct file *file, const char *buffer,
-		unsigned long count, void *data);
+int proc_get_vid(struct seq_file *m, void *v);
+int proc_get_pid(struct seq_file *m, void *v);
 
 #if defined(DBG_CONFIG_ERROR_DETECT)
-int proc_get_sreset(char *page, char **start, off_t offset, int count, int *eof, void *data);
-int proc_set_sreset(struct file *file, const char *buffer, unsigned long count, void *data);
+int proc_get_sreset(struct seq_file *m, void *v);
+ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
-#ifdef CONFIG_DM_ADAPTIVITY
-int proc_get_dm_adaptivity(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data);
-int proc_set_dm_adaptivity(struct file *file, const char *buffer,
-		unsigned long count, void *data);
-#endif /* CONFIG_DM_ADAPTIVITY */
-
-#endif //CONFIG_PROC_DEBUG
+#endif /* CONFIG_PROC_DEBUG */
 
-#endif	//__RTW_DEBUG_H__
+#endif /* __RTW_DEBUG_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_efuse.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_efuse.h
index 224aa4f92bd7..e0cb33ce6ce5 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_efuse.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_efuse.h
@@ -77,6 +77,25 @@ typedef struct PG_PKT_STRUCT_A{
 	u8 word_cnts;
 }PGPKT_STRUCT,*PPGPKT_STRUCT;
 /*------------------------------Define structure----------------------------*/ 
+/*------------------------------Define structure----------------------------*/ 
+typedef struct _EFUSE_HAL{
+	u8	fakeEfuseBank;
+	u32 fakeEfuseUsedBytes;
+	u8	fakeEfuseContent[EFUSE_MAX_HW_SIZE];
+	u8	fakeEfuseInitMap[EFUSE_MAX_MAP_LEN];
+	u8	fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN];
+
+	u16 BTEfuseUsedBytes;
+	u8	BTEfuseUsedPercentage;
+	u8	BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+
+	u16 fakeBTEfuseUsedBytes;
+	u8	fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+}EFUSE_HAL, *PEFUSE_HAL;
 
 
 /*------------------------Export global variable----------------------------*/
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme.h
index 040e1e5b1966..4ac4a98f32ad 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme.h
@@ -40,8 +40,6 @@
 
 #define 	SCANNING_TIMEOUT 	8000
 
-#define	SCAN_INTERVAL	(30) // unit:2sec, 30*2=60sec
-
 #ifdef PALTFORM_OS_WINCE
 #define	SCANQUEUE_LIFETIME 12000000 // unit:us
 #else
@@ -250,11 +248,11 @@ struct group_id_info{
 
 struct scan_limit_info{
 	u8					scan_op_ch_only;			//	When this flag is set, the driver should just scan the operation channel
-#ifndef P2P_OP_CHECK_SOCIAL_CH
+#ifndef CONFIG_P2P_OP_CHK_SOCIAL_CH
 	u8					operation_ch[2];				//	Store the operation channel of invitation request frame
 #else
 	u8					operation_ch[5];				//	Store additional channel 1,6,11  for Android 4.2 IOT & Nexus 4
-#endif //P2P_OP_CHECK_SOCIAL_CH
+#endif //CONFIG_P2P_OP_CHK_SOCIAL_CH
 };
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -393,6 +391,13 @@ struct tdls_info{
 #endif		
 };
 
+/* used for mlme_priv.roam_flags */
+enum {
+	RTW_ROAM_ON_EXPIRED = 0x01,
+	RTW_ROAM_ON_RESUME = 0x02,
+	RTW_ROAM_ACTIVE = 0x04,
+};
+
 struct mlme_priv {
 
 	_lock	lock;
@@ -400,7 +405,13 @@ struct mlme_priv {
 
 	u8	to_join; //flag
 	#ifdef CONFIG_LAYER2_ROAMING
-	u8 to_roaming; // roaming trying times
+	u8 to_roam; /* roaming trying times */
+	struct wlan_network *roam_network; /* the target of active roam */
+	u8 roam_flags;
+	u8 roam_rssi_diff_th; /* rssi difference threshold for active scan candidate selection */
+	u32 roam_scan_int_ms; /* scan interval for active roam */
+	u32 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
+	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
 	#endif
 
 	u8	*nic_hdl;
@@ -420,7 +431,7 @@ struct mlme_priv {
 
 	//uint wireless_mode; no used, remove it
 
-	u32	scan_interval;
+	u32	auto_scan_int_ms;
 
 	_timer assoc_timer;
 
@@ -459,8 +470,6 @@ struct mlme_priv {
 	u8	ChannelPlan;
 	RT_SCAN_TYPE 	scan_mode; // active: 1, passive: 0
 
-	//u8 probereq_wpsie[MAX_WPS_IE_LEN];//added in probe req	
-	//int probereq_wpsie_len;
 	u8 *wps_probe_req_ie;
 	u32 wps_probe_req_ie_len;
 
@@ -592,6 +601,13 @@ struct mlme_priv {
 #endif
 };
 
+#define rtw_mlme_set_auto_scan_int(adapter, ms) \
+	do { \
+		adapter->mlmepriv.auto_scan_int_ms = ms; \
+	while (0)
+
+void rtw_mlme_reset_auto_scan_int(_adapter *adapter);
+
 #ifdef CONFIG_AP_MODE
 
 struct hostapd_priv
@@ -751,6 +767,8 @@ extern void rtw_disconnect_hdl_under_linked(_adapter* adapter, struct sta_info *
 extern void rtw_generate_random_ibss(u8 *pibss);
 extern struct wlan_network* rtw_find_network(_queue *scanned_queue, u8 *addr);
 extern struct wlan_network* rtw_get_oldest_wlan_network(_queue *scanned_queue);
+struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
+struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
 
 extern void rtw_free_assoc_resources(_adapter* adapter, int lock_scanned_queue);
 extern void rtw_indicate_disconnect(_adapter* adapter);
@@ -821,20 +839,45 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
 #endif
 
 int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
-int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst);
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature);
 
 #ifdef CONFIG_LAYER2_ROAMING
+#define rtw_roam_flags(adapter) ((adapter)->mlmepriv.roam_flags)
+#define rtw_chk_roam_flags(adapter, flags) ((adapter)->mlmepriv.roam_flags & flags)
+#define rtw_clr_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags &= ~flags); \
+	} while (0)
+
+#define rtw_set_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags |= flags); \
+	} while (0)
+
+#define rtw_assign_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags = flags); \
+	} while (0)
+
 void _rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
 void rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
-void rtw_set_roaming(_adapter *adapter, u8 to_roaming);
-u8 rtw_to_roaming(_adapter *adapter);
+void rtw_set_to_roam(_adapter *adapter, u8 to_roam);
+u8 rtw_dec_to_roam(_adapter *adapter);
+u8 rtw_to_roam(_adapter *adapter);
+int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
 #else
+#define rtw_roam_flags(adapter) 0
+#define rtw_chk_roam_flags(adapter, flags) 0
+#define rtw_clr_roam_flags(adapter, flags) do {} while (0)
+#define rtw_set_roam_flags(adapter, flags) do {} while (0)
+#define rtw_assign_roam_flags(adapter, flags) do {} while (0)
 #define _rtw_roaming(adapter, tgt_network) do {} while(0)
 #define rtw_roaming(adapter, tgt_network) do {} while(0)
-#define rtw_set_roaming(adapter, to_roaming) do {} while(0)
-#define rtw_to_roaming(adapter) 0
-#endif
-
+#define rtw_set_to_roam(adapter, to_roam) do {} while(0)
+#define rtw_dec_to_roam(adapter) 0
+#define rtw_to_roam(adapter) 0
+#define rtw_select_roaming_candidate(mlme) _FAIL
+#endif /* CONFIG_LAYER2_ROAMING */
 
 #ifdef CONFIG_INTEL_PROXIM
 void rtw_proxim_enable(_adapter *padapter);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme_ext.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme_ext.h
index a08d9246bb5b..5c50ae2e829e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mlme_ext.h
@@ -54,14 +54,6 @@
 //#define	SET_CHANNEL_CMD	0xF3000000
 //#define	UPDATE_RA_CMD	0xFD0000A2
 
-#define	DYNAMIC_FUNC_DISABLE		(0x0)
-#define	DYNAMIC_FUNC_DIG			BIT(0)
-#define	DYNAMIC_FUNC_HP			BIT(1)
-#define	DYNAMIC_FUNC_SS			BIT(2) //Tx Power Tracking
-#define DYNAMIC_FUNC_BT			BIT(3)
-#define DYNAMIC_FUNC_ANT_DIV		BIT(4)
-#define DYNAMIC_FUNC_ADAPTIVITY	BIT(5)
-
 #define _HW_STATE_NOLINK_		0x00
 #define _HW_STATE_ADHOC_		0x01
 #define _HW_STATE_STATION_ 	0x02
@@ -346,9 +338,9 @@ struct FW_Sta_Info
  * 5. ... and so on, till survey done.
  */
 #if defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
-#define RTW_SCAN_NUM_OF_CH			8
-#define RTW_STAY_AP_CH_MILLISECOND	3	// this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for 
-											// 3 * SURVEY_TO millisecond. 
+#define RTW_SCAN_NUM_OF_CH			3
+#define RTW_STAY_AP_CH_MILLISECOND	4	// this value is a multiplier,for example, when this value is 4, it would stay AP's op ch for 
+											// 4 * SURVEY_TO millisecond. 
 #endif //defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
 
 struct mlme_ext_info
@@ -644,7 +636,7 @@ void issue_assocreq(_adapter *padapter);
 void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
 void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
 void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da);
-s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8* da, int try_cnt, int wait_ms);
+s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8* da, u8 ch, bool append_wps, int try_cnt, int wait_ms);
 int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
 int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
 int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp.h
index 0ebb1ba62575..1a0b43eea3e2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp.h
@@ -114,6 +114,42 @@
 #define MPT_READ_TSSI			32
 #define MPT_GET_THERMAL_METER		33
 #endif
+#ifndef BIT
+#define BIT(x)		(1 << (x))
+#endif
+
+#define BIT0		0x00000001
+#define BIT1		0x00000002
+#define BIT2		0x00000004
+#define BIT3		0x00000008
+#define BIT4		0x00000010
+#define BIT5		0x00000020
+#define BIT6		0x00000040
+#define BIT7		0x00000080
+#define BIT8		0x00000100
+#define BIT9		0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
 
 #define MAX_MP_XMITBUF_SZ 	2048
 #define NR_MP_XMITFRAME		8
@@ -391,7 +427,7 @@ struct mp_priv
 	u8 check_mp_pkt;
 
 //	uint ForcedDataRate;
-
+	u8 mp_dm;
 	struct wlan_network mp_network;
 	NDIS_802_11_MAC_ADDRESS network_macaddr;
 
@@ -424,7 +460,13 @@ struct mp_priv
 	u8 *pmp_xmtframe_buf;
 	_queue free_mp_xmitqueue;
 	u32 free_mp_xmitframe_cnt;
-
+	//
+	BOOLEAN 			bRegBW40MHz;				// Tx 40MHz channel capablity
+	BOOLEAN 			bCurBW40MHz;				// Tx 40MHz channel capability
+	// 40MHz Channel Offset settings.
+	HT_EXTCHNL_OFFSET	CurSTAExtChnlOffset;
+	BOOLEAN 			bPeer40MHzCap;					// Supported channel width set
+	BOOLEAN 			bPeer40MHzIntolerant;			// Forty MHz Intolerant
 	MPT_CONTEXT MptCtx;
 };
 
@@ -563,6 +605,15 @@ typedef enum _POWER_MODE_ {
 #define RX_PKT_DEST_ADDR	2
 #define RX_PKT_PHY_MATCH	3
 
+typedef enum _MPT_Bandwidth_Switch_Mode{
+	BAND_20MHZ_MODE = 0,
+	BAND_40MHZ_DUPLICATE_MODE = 1,
+	BAND_40MHZ_LOWER_MODE = 2,
+	BAND_40MHZ_UPPER_MODE = 3,
+	BAND_40MHZ_DONTCARE_MODE = 4,
+	BAND_80MHZ_DONTCARE_MODE
+}MPT_BANDWIDTH_MODE_E, *PMPT_BANDWIDTH_MODE_E;
+
 #if 0
 #define RPTMaxCount 0x000FFFFF;
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp_phy_regdef.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp_phy_regdef.h
index 0b47cb5c546f..1b9dbab62eb0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp_phy_regdef.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_mp_phy_regdef.h
@@ -1012,6 +1012,7 @@
 #define		bMaskByte1		0xff00
 #define		bMaskByte2		0xff0000
 #define		bMaskByte3		0xff000000
+#define		bMaskH3Bytes	0xffffff00
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord		0x0000ffff
 #define		bMaskDWord		0xffffffff
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_pwrctrl.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_pwrctrl.h
index a4cb292e1aea..548f2230c94d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_pwrctrl.h
@@ -308,7 +308,7 @@ extern void rtw_unregister_evt_alive(PADAPTER padapter);
 extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportpwrstate);
 #endif
 
-extern void rtw_set_ps_mode(_adapter * padapter, u8 ps_mode, u8 smart_ps);
+extern void rtw_set_ps_mode(_adapter * padapter, u8 ps_mode, u8 smart_ps, const char *msg);
 extern void rtw_set_rpwm(_adapter * padapter, u8 val8);
 extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
 #ifdef CONFIG_IPS
@@ -329,8 +329,8 @@ rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter );
 
 
 #ifdef CONFIG_LPS
-void LPS_Enter(PADAPTER padapter);
-void LPS_Leave(PADAPTER padapter);
+void LPS_Enter(PADAPTER padapter, const char *msg);
+void LPS_Leave(PADAPTER padapter, const char *msg);
 #endif
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_version.h
index d552ea63c87a..bf4aed90c970 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_version.h
@@ -1 +1 @@
-#define DRIVERVERSION	"v4.0.2_9377.20131025_beta"
+#define DRIVERVERSION	"v4.0.4_10867.20140321_beta"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_wifi_regd.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_wifi_regd.h
new file mode 100644
index 000000000000..8b28be34b0ae
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_wifi_regd.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2010  Realtek Corporation.
+ *
+ *****************************************************************************/
+
+#ifndef __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__
+
+struct country_code_to_enum_rd {
+	u16 countrycode;
+	const char *iso_name;
+};
+
+enum country_code_type_t {
+	COUNTRY_CODE_USER = 0,
+
+	/*add new channel plan above this line */
+	COUNTRY_CODE_MAX
+}; 
+
+int rtw_regd_init(_adapter *padapter,
+	void (*reg_notifier)(struct wiphy *wiphy,
+		struct regulatory_request *request));
+void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_xmit.h
index f7eaf4a68b11..35f259ecba28 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/rtw_xmit.h
@@ -61,9 +61,13 @@
 #ifdef CONFIG_PCI_HCI
 #define XMITBUF_ALIGN_SZ 4
 #else
+#ifdef USB_XMITBUF_ALIGN_SZ
+#define XMITBUF_ALIGN_SZ (USB_XMITBUF_ALIGN_SZ)
+#else
 #define XMITBUF_ALIGN_SZ 512
 #endif
 #endif
+#endif
 
 // xmit extension buff defination
 #define MAX_XMIT_EXTBUF_SZ	(1536)
@@ -143,7 +147,11 @@ do{\
 #endif
 
 #ifdef CONFIG_USB_HCI
+#ifdef USB_PACKET_OFFSET_SZ
+#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
+#else
 #define PACKET_OFFSET_SZ (8)
+#endif
 #define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/wifi.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/wifi.h
index 0bb55bb28252..85dded814fc9 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/include/wifi.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/include/wifi.h
@@ -1240,7 +1240,25 @@ enum P2P_PS_MODE
 #define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
 #endif	// CONFIG_TX_MCAST2UNI
 
+#ifdef CONFIG_IOCTL_CFG80211
+/* Regulatroy Domain */
+struct regd_pair_mapping {
+	u16 reg_dmnenum;
+	u16 reg_5ghz_ctl;
+	u16 reg_2ghz_ctl;
+};
 
+struct rtw_regulatory {
+	char alpha2[2];
+	u16 country_code;
+	u16 max_power_level;
+	u32 tp_scale;
+	u16 current_rd;
+	u16 current_rd_ext;
+	int16_t power_limit;
+	struct regd_pair_mapping *regpair;
+};
+#endif
 
 #endif // _WIFI_H_
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_cfg80211.c
index 6c95afdfa6b0..547a7520042c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_cfg80211.c
@@ -29,12 +29,14 @@
 
 #ifdef CONFIG_IOCTL_CFG80211
 
+#include <rtw_wifi_regd.h>
+
 #include "ioctl_cfg80211.h"	
 
 #define RTW_MAX_MGMT_TX_CNT (8)
 
 #define RTW_SCAN_IE_LEN_MAX      2304
-#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 65535 //ms
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 3000 //ms
 #define RTW_MAX_NUM_PMKIDS 4
 
 #define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
@@ -74,6 +76,23 @@ static const u32 rtw_cipher_suites[] = {
 	.max_power		= 30,				\
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+/* if wowlan is not supported, kernel generate a disconnect at each suspend
+ * cf: /net/wireless/sysfs.c, so register a stub wowlan.
+ * Moreover wowlan has to be enabled via a the nl80211_set_wowlan callback.
+ * (from user space, e.g. iw phy0 wowlan enable)
+ */
+static const struct wiphy_wowlan_support wowlan_stub = {
+	.flags = WIPHY_WOWLAN_ANY,
+	.n_patterns = 0,
+	.pattern_max_len = 0,
+	.pattern_min_len = 0,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	.max_pkt_offset = 0,
+#endif
+};
+#endif
+
 static struct ieee80211_rate rtw_rates[] = {
 	RATETAB_ENT(10,  0x1,   0),
 	RATETAB_ENT(20,  0x2,   0),
@@ -351,11 +370,11 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 
 	//To reduce PBC Overlap rate
 	//_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
-	if(wdev_to_priv(wdev)->scan_request != NULL)
+	if(adapter_wdev_data(padapter)->scan_request != NULL)
 	{
 		u8 *psr=NULL, sr = 0;
 		NDIS_802_11_SSID *pssid = &pnetwork->network.Ssid;
-		struct cfg80211_scan_request *request = wdev_to_priv(wdev)->scan_request;
+		struct cfg80211_scan_request *request = adapter_wdev_data(padapter)->scan_request;
 		struct cfg80211_ssid *ssids = request->ssids;
 		u32 wpsielen=0;
 		u8 *wpsie=NULL;	
@@ -367,11 +386,13 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 		
 		if (sr != 0)
 		{			
-			if(request->n_ssids == 1  && request->n_channels == 1) // it means under processing WPS
+			if(request->n_ssids == 1 && request->n_channels == 1) // it means under processing WPS
 			{
 				DBG_8192C("ssid=%s, len=%d\n", pssid->Ssid, pssid->SsidLength);
-			
-				if(pssid->SsidLength == ssids[0].ssid_len &&
+
+				if (ssids[0].ssid_len == 0) {
+				}
+				else if(pssid->SsidLength == ssids[0].ssid_len &&
 					_rtw_memcmp(pssid->Ssid, ssids[0].ssid, ssids[0].ssid_len))
 				{
 					DBG_871X("%s, got sr and ssid match!\n", __func__);
@@ -441,7 +462,7 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 
 	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
 	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
-		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {
 		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
 	} else {
 		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
@@ -614,17 +635,19 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 	}
 #endif //CONFIG_P2P
 
-	if (!rtw_cfg80211_check_bss(padapter)) {
+	{
 		WLAN_BSSID_EX  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);
 		struct wlan_network *scanned = pmlmepriv->cur_network_scanned;
 
 		//DBG_871X(FUNC_ADPT_FMT" BSS not found\n", FUNC_ADPT_ARG(padapter));
 
-		if(scanned == NULL)
+		if(scanned == NULL) {
 			rtw_warn_on(1);
+			goto check_bss;
+		}
 
-		if (_rtw_memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(NDIS_802_11_SSID)) == _TRUE
-			&& _rtw_memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS)) == _TRUE
+		if (_rtw_memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS)) == _TRUE
+			&& _rtw_memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(NDIS_802_11_SSID)) == _TRUE
 		) {
 			if (!rtw_cfg80211_inform_bss(padapter,scanned)) {
 				DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
@@ -632,15 +655,19 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 				//DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
 			}
 		} else {
+			DBG_871X("scanned: %s("MAC_FMT"), cur: %s("MAC_FMT")\n",
+				scanned->network.Ssid.Ssid, MAC_ARG(scanned->network.MacAddress),
+				pnetwork->Ssid.Ssid, MAC_ARG(pnetwork->MacAddress)
+			);
 			rtw_warn_on(1);
 		}
-
-		if (!rtw_cfg80211_check_bss(padapter))
-			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));
 	}
 
-	#ifdef CONFIG_LAYER2_ROAMING
-	if (rtw_to_roaming(padapter) > 0) {
+check_bss:
+	if (!rtw_cfg80211_check_bss(padapter))
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));
+
+	if (rtw_to_roam(padapter) > 0) {
 		#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
 		struct wiphy *wiphy = pwdev->wiphy;
 		struct ieee80211_channel *notify_channel;
@@ -667,8 +694,7 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
 			, GFP_ATOMIC);
 	}
-	else 
-	#endif
+	else
 	{
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
 		cfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress
@@ -1369,8 +1395,8 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 	u32 param_len;
 	struct ieee_param *param = NULL;	
 	int ret=0;
-	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct wireless_dev *rtw_wdev = padapter->rtw_wdev;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	
 	DBG_871X(FUNC_NDEV_FMT" adding key for %pM\n", FUNC_NDEV_ARG(ndev), mac_addr);
@@ -1570,7 +1596,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 				    u8 *mac, struct station_info *sinfo)
 {
 	int ret = 0;
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -1663,10 +1689,10 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 				     struct vif_params *params)
 {
 	enum nl80211_iftype old_type;
-	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct wireless_dev *rtw_wdev = padapter->rtw_wdev;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	_irqL irqL;
 	_queue *queue = &pmlmepriv->scanned_queue;
@@ -1782,21 +1808,18 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 	return ret;
 }
 
-void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted)
+void rtw_cfg80211_indicate_scan_done(_adapter *adapter, bool aborted)
 {
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 	_irqL	irqL;
 
 	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
-	if(pwdev_priv->scan_request != NULL)
-	{
-		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
-	
+	if (pwdev_priv->scan_request != NULL) {
 		#ifdef CONFIG_DEBUG_CFG80211
-		DBG_871X("%s with scan req\n", __FUNCTION__);	
+		DBG_871X("%s with scan req\n", __FUNCTION__);
 		#endif
 
-		//avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
-		//if(scan_request == wiphy_to_dev(scan_request->wiphy)->scan_req)
+		/* avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req); */
 		if(pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
 		{
 			DBG_8192C("error wiphy compare\n");
@@ -1807,7 +1830,6 @@ void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool abor
 		}
 
 		pwdev_priv->scan_request = NULL;
-		
 	} else {
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s without scan req\n", __FUNCTION__);
@@ -1829,7 +1851,7 @@ void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 #ifdef CONFIG_P2P
 	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
 #endif //CONFIG_P2P
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
 #ifdef CONFIG_DEBUG_CFG80211
@@ -1863,9 +1885,6 @@ void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 	}
 	
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	
-	//call this after other things have been done
-	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), _FALSE);
 }
 
 static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, int len)
@@ -1993,11 +2012,12 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 	#endif
 	, struct cfg80211_scan_request *request)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(request->wdev);
+#endif
 	int i;
 	u8 _status = _FALSE;
 	int ret = 0;	
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
 	_irqL	irqL;
@@ -2007,18 +2027,33 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 	uint p2p_ielen=0;
 	u8 survey_times=3;
 	u8 survey_times_for_one_ch=6;
-#ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
-#endif //CONFIG_P2P
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 	int social_channel = 0, j = 0;
 	bool need_indicate_scan_done = _FALSE;
+
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct mlme_priv *pmlmepriv;
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo;
+#endif //CONFIG_P2P
 #ifdef CONFIG_CONCURRENT_MODE	
 	PADAPTER pbuddy_adapter = NULL;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 #endif //CONFIG_CONCURRENT_MODE
 
+	if (ndev == NULL) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pmlmepriv= &padapter->mlmepriv;
+#ifdef CONFIG_P2P
+	pwdinfo= &(padapter->wdinfo);
+#endif //CONFIG_P2P
+
 //#ifdef CONFIG_DEBUG_CFG80211
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 //#endif
@@ -2079,7 +2114,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 			{
 				u32 initialgain = 0x30;
 				rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-				wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _TRUE;
+				adapter_wdev_data(padapter)->p2p_enabled = _TRUE;
 				padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_INITIAL_GAIN, (u8 *)&(initialgain));
 				padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_INITIAL_GAIN, (u8 *)&(initialgain));
 			}
@@ -2139,36 +2174,45 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 		goto check_need_indicate_scan_done;
 	}
 
-	if (check_buddy_fwstate(padapter,
-		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
-	{		
-		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
-		{
-			DBG_8192C("scanning_via_buddy_intf\n");
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE) {
+		DBG_871X("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+
+	} else if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY)) {
+		bool scan_via_buddy = _FALSE;
+		struct rtw_wdev_priv *buddy_wdev_priv = adapter_wdev_data(pbuddy_adapter);
+
+		_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+		_enter_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		if (buddy_wdev_priv->scan_request) {
+			DBG_871X("scan via buddy\n");
 			pmlmepriv->scanning_via_buddy_intf = _TRUE;
-		}		
+			_enter_critical_bh(&pmlmepriv->lock, &irqL);
+			set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			scan_via_buddy = _TRUE;
+		}
+		_exit_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+
+		if (scan_via_buddy == _FALSE)
+			need_indicate_scan_done = _TRUE;
 
-		DBG_8192C("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
-		
-		need_indicate_scan_done = _TRUE;
 		goto check_need_indicate_scan_done;
 	}
-#endif
-
+#endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_P2P
-	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-		{
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-			rtw_free_network_queue(padapter, _TRUE);
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_free_network_queue(padapter, _TRUE);
 
-			if(social_channel == 0)
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-			else
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
-		}
+		if(social_channel == 0)
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		else
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
 	}
 #endif //CONFIG_P2P
 
@@ -2198,13 +2242,13 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 		for(i=1;i<survey_times_for_one_ch;i++)
 			_rtw_memcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));
 		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times_for_one_ch);
-	} else if (request->n_channels == 2) {
-		_rtw_memcpy(&ch[3], &ch[1], sizeof(struct rtw_ieee80211_channel));
-		for(i=1;i<survey_times;i++) {
-			_rtw_memcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));
-			_rtw_memcpy(&ch[i+3], &ch[3], sizeof(struct rtw_ieee80211_channel));
+	} else if (request->n_channels <= 4) {
+		for(j=request->n_channels-1;j>=0;j--)
+			for(i=0;i<survey_times;i++)
+		{
+			_rtw_memcpy(&ch[j*survey_times+i], &ch[j], sizeof(struct rtw_ieee80211_channel));
 		}
-		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times * 2);
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times * request->n_channels);
 	} else {
 		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);
 	}
@@ -2217,8 +2261,10 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 	}
 
 check_need_indicate_scan_done:
-	if(need_indicate_scan_done)
+	if(need_indicate_scan_done) {
 		rtw_cfg80211_surveydone_event_callback(padapter);
+		rtw_cfg80211_indicate_scan_done(padapter, _FALSE);
+	}
 
 exit:
 
@@ -2671,26 +2717,28 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 	//u8 matched_by_bssid=_FALSE;
 	//u8 matched_by_ssid=_FALSE;
 	u8 matched=_FALSE;
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	_queue *queue = &pmlmepriv->scanned_queue;	
-	
+
+	padapter->mlmepriv.not_indic_disco = _TRUE;
+
 	DBG_871X("=>"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	DBG_871X("privacy=%d, key=%p, key_len=%d, key_idx=%d\n",
 		sme->privacy, sme->key, sme->key_len, sme->key_idx);
 
 
-	if(wdev_to_priv(padapter->rtw_wdev)->block == _TRUE)
+	if(adapter_wdev_data(padapter)->block == _TRUE)
 	{
 		ret = -EBUSY;
 		DBG_871X("%s wdev_priv.block is set\n", __FUNCTION__);
 		goto exit;
 	}
 
-#ifdef CONFIG_PLATFORM_MSTAR
+#ifdef CONFIG_PLATFORM_MSTAR_SCAN_BEFORE_CONNECT
 	printk("MStar Android!\n");
-	if((wdev_to_priv(padapter->rtw_wdev))->bandroid_scan == _FALSE)
+	if(adapter_wdev_data(padapter)->bandroid_scan == _FALSE)
 	{
 #ifdef CONFIG_P2P
 		struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
@@ -2871,20 +2919,24 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 exit:
 
 	DBG_8192C("<=%s, ret %d\n",__FUNCTION__, ret);
-	
+
+	padapter->mlmepriv.not_indic_disco = _FALSE;
+
 	return ret;
 }
 
 static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
 				   u16 reason_code)
 {
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	rtw_set_roaming(padapter, 0);
+	padapter->mlmepriv.not_indic_disco = _TRUE;
+
+	rtw_set_to_roam(padapter, 0);
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) 
+	//if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 	{
 		rtw_scan_abort(padapter);
 		LeaveAllPowerSaveMode(padapter);
@@ -2892,13 +2944,14 @@ static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
 		
 		DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
 		
-		padapter->mlmepriv.not_indic_disco = _TRUE;
 		rtw_indicate_disconnect(padapter);
-		padapter->mlmepriv.not_indic_disco = _FALSE;
 		
 		rtw_free_assoc_resources(padapter, 1);
 	}
-	
+
+	padapter->mlmepriv.not_indic_disco = _FALSE;
+
+	DBG_871X(FUNC_NDEV_FMT" return 0\n", FUNC_NDEV_ARG(ndev));
 	return 0;
 }
 
@@ -2948,8 +3001,6 @@ static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
 #endif
 	int *dbm)
 {
-	//_adapter *padapter = wiphy_to_adapter(wiphy);
-
 	DBG_8192C("%s\n", __func__);
 
 	*dbm = (12);
@@ -2959,7 +3010,7 @@ static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
 
 inline bool rtw_cfg80211_pwr_mgmt(_adapter *adapter)
 {
-	struct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	struct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(adapter);
 	return rtw_wdev_priv->power_mgmt;
 }
 
@@ -2967,8 +3018,8 @@ static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
 				       struct net_device *ndev,
 				       bool enabled, int timeout)
 {
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(padapter);
 	
 	DBG_871X(FUNC_NDEV_FMT" enabled:%u, timeout:%d\n", FUNC_NDEV_ARG(ndev),
 		enabled, timeout);
@@ -2977,22 +3028,22 @@ static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
 
 	#ifdef CONFIG_LPS
 	if (!enabled)
-		LPS_Leave(padapter);
+		LPS_Leave(padapter, "CFG80211_PWRMGMT");
 	#endif
 
 	return 0;
 }
 
 static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
-				  struct net_device *netdev,
+				  struct net_device *ndev,
 				  struct cfg80211_pmksa *pmksa)
 {
 	u8	index,blInserted = _FALSE;
-	_adapter	*padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
 	{
@@ -3006,7 +3057,7 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 	{
 		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
 		{ // BSSID is matched, the same AP => rewrite with new PMKID.
-			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
+			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(ndev));
 
 			_rtw_memcpy( psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
 			psecuritypriv->PMKIDList[index].bUsed = _TRUE;
@@ -3020,7 +3071,7 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 	{
 		// Find a new entry
 		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
-			FUNC_NDEV_ARG(netdev), psecuritypriv->PMKIDIndex );
+			FUNC_NDEV_ARG(ndev), psecuritypriv->PMKIDIndex );
 
 		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, pmksa->bssid, ETH_ALEN);
 		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
@@ -3037,14 +3088,14 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 }
 
 static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
-				  struct net_device *netdev,
+				  struct net_device *ndev,
 				  struct cfg80211_pmksa *pmksa)
 {
 	u8	index, bMatched = _FALSE;
-	_adapter	*padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
@@ -3061,7 +3112,7 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 	if(_FALSE == bMatched)
 	{
 		DBG_871X(FUNC_NDEV_FMT" do not have matched BSSID\n"
-			, FUNC_NDEV_ARG(netdev));
+			, FUNC_NDEV_ARG(ndev));
 		return -EINVAL;
 	}
 
@@ -3069,12 +3120,12 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 }
 
 static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,
-				    struct net_device *netdev)
+				    struct net_device *ndev)
 {
-	_adapter	*padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	_rtw_memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
 	psecuritypriv->PMKIDIndex = 0;
@@ -3278,6 +3329,8 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 
 		/* Use the real net device to transmit the packet */		
 		ret = _rtw_xmit_entry(skb, padapter->pnetdev);
+		if (ret != NETDEV_TX_OK)
+			rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_FREE, skb->truesize);
 
 		return ret;
 
@@ -3369,7 +3422,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 	
 fail:
 	
-	dev_kfree_skb(skb);
+	rtw_skb_free(skb);
 
 	return 0;
 	
@@ -3407,7 +3460,7 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	struct net_device* mon_ndev = NULL;
 	struct wireless_dev* mon_wdev = NULL;
 	struct rtw_netdev_priv_indicator *pnpi;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
 		
 	if (!name ) {
 		DBG_871X(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));
@@ -3554,14 +3607,20 @@ static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
 #endif
 )
 {
-	struct rtw_wdev_priv *pwdev_priv = (struct rtw_wdev_priv *)wiphy_priv(wiphy);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
-	struct net_device *ndev;
-	ndev = wdev ? wdev->netdev : NULL;
+	struct net_device *ndev = wdev_to_ndev(wdev);
 #endif
+	int ret = 0;
+	_adapter *adapter;
+	struct rtw_wdev_priv *pwdev_priv;
 
-	if (!ndev)
+	if (!ndev) {
+		ret = -EINVAL;
 		goto exit;
+	}
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(adapter);
 
 	unregister_netdevice(ndev);
 
@@ -3572,7 +3631,7 @@ static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
 	}
 
 exit:
-	return 0;
+	return ret;
 }
 
 static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, const u8 *tail, size_t tail_len)
@@ -3634,7 +3693,7 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 			{			
 				DBG_8192C("Enable P2P function for the first time\n");
 				rtw_p2p_enable(adapter, P2P_ROLE_GO);
-				wdev_to_priv(adapter->rtw_wdev)->p2p_enabled = _TRUE;
+				adapter_wdev_data(adapter)->p2p_enabled = _TRUE;
 			}
 			else
 			{
@@ -3677,11 +3736,11 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) && !defined(COMPAT_KERNEL_RELEASE)
-static int	cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
+static int cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
 			      struct beacon_parameters *info)
 {
 	int ret=0;
-	_adapter *adapter = wiphy_to_adapter(wiphy);
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
@@ -3689,11 +3748,11 @@ static int	cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
 	return ret;
 }
 
-static int	cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
+static int cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
 			      struct beacon_parameters *info)
 {
-	_adapter *padapter = wiphy_to_adapter(wiphy);	
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
 	
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
@@ -3715,7 +3774,7 @@ static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 								struct cfg80211_ap_settings *settings)
 {
 	int ret = 0;
-	_adapter *adapter = wiphy_to_adapter(wiphy);
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
 	
 	DBG_871X(FUNC_NDEV_FMT" hidden_ssid:%d, auth_type:%d\n", FUNC_NDEV_ARG(ndev),
 		settings->hidden_ssid, settings->auth_type);
@@ -3752,7 +3811,7 @@ static int cfg80211_rtw_change_beacon(struct wiphy *wiphy, struct net_device *nd
                                 struct cfg80211_beacon_data *info)
 {
 	int ret = 0;
-	_adapter *adapter = wiphy_to_adapter(wiphy);
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
@@ -4016,7 +4075,7 @@ void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const
 	s32 freq;
 	int channel;
 	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);	
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 	u8 category, action;
 
 	channel = rtw_get_oper_ch(adapter);
@@ -4280,14 +4339,27 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 #endif
 	unsigned int duration, u64 *cookie)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
 	s32 err = 0;
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 	u8 remain_ch = (u8) ieee80211_frequency_to_channel(channel->center_freq);
 	u8 ready_on_channel = _FALSE;
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct mlme_ext_priv *pmlmeext;
+	struct wifidirect_info *pwdinfo;
+	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
+
+	if (ndev == NULL) {
+		return  -EINVAL;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pmlmeext = &padapter->mlmeextpriv;
+	pwdinfo = &padapter->wdinfo;
+	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
 
@@ -4323,11 +4395,24 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 		rtw_scan_abort(padapter->pbuddy_adapter);			
 #endif //CONFIG_CONCURRENT_MODE
 
+	if (check_fwstate(&padapter->mlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+	{
+		DBG_871X("mlme state:0x%x\n", get_fwstate(&padapter->mlmepriv));
+		remain_ch = padapter->mlmeextpriv.cur_channel;
+	}
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+	{
+		DBG_871X("buddy_intf's mlme state:0x%x\n", get_fwstate(&(padapter->pbuddy_adapter->mlmepriv)));
+		remain_ch = padapter->pbuddy_adapter->mlmeextpriv.cur_channel;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
 	//if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _TRUE;
+		adapter_wdev_data(padapter)->p2p_enabled = _TRUE;
 		padapter->wdinfo.listen_channel = remain_ch;
 	}
 	else
@@ -4442,12 +4527,24 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 #endif
 	u64 cookie)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
 	s32 err = 0;
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct wifidirect_info *pwdinfo;
+	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
+
+	if (ndev == NULL) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pwdinfo = &padapter->wdinfo;
+	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
@@ -4480,6 +4577,7 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 	}
 	pcfg80211_wdinfo->is_ro_ch = _FALSE;
 
+exit:
 	return err;
 }
 
@@ -4493,7 +4591,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 	int ret = _FAIL;
 	bool ack = _TRUE;
 	struct rtw_ieee80211_hdr *pwlanhdr;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -4672,8 +4770,9 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 #endif
 	u64 *cookie)
 {
-	_adapter *padapter = (_adapter *)wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
 	int ret = 0;
 	int tx_ret;
 	u32 dump_limit = RTW_MAX_MGMT_TX_CNT;
@@ -4683,6 +4782,16 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 	u8 category, action;
 	int type = (-1);
 	u32 start = rtw_get_current_time();
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+
+	if (ndev == NULL) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
 
 	/* cookie generation */
 	*cookie = (unsigned long) buf;
@@ -4770,7 +4879,15 @@ static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
 #endif
 	u16 frame_type, bool reg)
 {
-	_adapter *adapter = wiphy_to_adapter(wiphy);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+	_adapter *adapter;
+
+	if (ndev == NULL)
+		goto exit;
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
 
 #ifdef CONFIG_DEBUG_CFG80211
 	DBG_871X(FUNC_ADPT_FMT" frame_type:%x, reg:%d\n", FUNC_ADPT_ARG(adapter),
@@ -4779,7 +4896,7 @@ static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
 
 	if (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))
 		return;
-
+exit:
 	return;
 }
 
@@ -4957,14 +5074,23 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode 
 			if ( (puconfig_method = (u16*)rtw_get_wps_attr_content( wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL )
 			{
+				//struct registry_priv *pregistrypriv = &padapter->registrypriv;
+				struct wireless_dev *wdev = padapter->rtw_wdev;
+
 				#ifdef CONFIG_DEBUG_CFG80211		
 				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
 				#endif
 				
-				uconfig_method = WPS_CM_PUSH_BUTTON;
-				uconfig_method = cpu_to_be16( uconfig_method );
-
-				*puconfig_method |= uconfig_method;			
+				//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+				#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+				if(wdev->iftype != NL80211_IFTYPE_P2P_GO) //for WIFI-DIRECT LOGO 4.2.2, AUTO GO can't set PUSH_BUTTON flags
+				{
+					uconfig_method = WPS_CM_PUSH_BUTTON;
+					uconfig_method = cpu_to_be16( uconfig_method );
+			
+					*puconfig_method |= uconfig_method;
+				}
+				#endif
 			}
 			
 			_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, wps_ie, wps_ielen);
@@ -5286,6 +5412,9 @@ void rtw_cfg80211_init_wiphy(_adapter *padapter)
 		if(bands)
 			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
 	}
+
+	/* init regulary domain */
+	rtw_regd_init(padapter, rtw_reg_notifier);
 }
 
 /*
@@ -5368,10 +5497,30 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;
 #endif
 
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#ifdef CONFIG_PNO_SUPPORT
+	wiphy->max_sched_scan_ssids = MAX_PNO_LIST_COUNT;
+#endif
+#endif
+
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+	wiphy->wowlan = wowlan_stub;
+#endif
+
+#if defined(CONFIG_TDLS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+	//wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+#endif /* CONFIG_TDLS */
+
 	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
 	else 
 		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
+#endif
 }
 
 int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
@@ -5385,13 +5534,14 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
 
 	/* wiphy */
-	wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct rtw_wdev_priv));
+	wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(_adapter*));
 	if (!wiphy) {
 		DBG_8192C("Couldn't allocate wiphy device\n");
 		ret = -ENOMEM;
 		goto exit;
 	}
 	set_wiphy_dev(wiphy, dev);
+	*((_adapter**)wiphy_priv(wiphy)) = padapter;
 	rtw_cfg80211_preinit_wiphy(padapter, wiphy);
 
 	ret = wiphy_register(wiphy);
@@ -5415,7 +5565,7 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 	pnetdev->ieee80211_ptr = wdev;
 
 	//init pwdev_priv
-	pwdev_priv = wdev_to_priv(wdev);
+	pwdev_priv = adapter_wdev_data(padapter);
 	pwdev_priv->rtw_wdev = wdev;
 	pwdev_priv->pmon_ndev = NULL;
 	pwdev_priv->ifname_mon[0] = '\0';
@@ -5454,15 +5604,11 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 
 void rtw_wdev_free(struct wireless_dev *wdev)
 {
-	struct rtw_wdev_priv *pwdev_priv;
-
 	DBG_8192C("%s(wdev=%p)\n", __func__, wdev);
 
 	if (!wdev)
 		return;
 
-	pwdev_priv = wdev_to_priv(wdev);
-
 	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_2GHZ]);
 	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_5GHZ]);
 	
@@ -5473,6 +5619,8 @@ void rtw_wdev_free(struct wireless_dev *wdev)
 
 void rtw_wdev_unregister(struct wireless_dev *wdev)
 {
+	struct net_device *ndev;
+	_adapter *adapter;
 	struct rtw_wdev_priv *pwdev_priv;
 
 	DBG_8192C("%s(wdev=%p)\n", __func__, wdev);
@@ -5480,9 +5628,13 @@ void rtw_wdev_unregister(struct wireless_dev *wdev)
 	if (!wdev)
 		return;
 
-	pwdev_priv = wdev_to_priv(wdev);
+	if(!(ndev = wdev_to_ndev(wdev)))
+		return;
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(adapter);
 
-	rtw_cfg80211_indicate_scan_done(pwdev_priv, _TRUE);
+	rtw_cfg80211_indicate_scan_done(adapter, _TRUE);
 
 	if (pwdev_priv->pmon_ndev) {
 		DBG_8192C("%s, unregister monitor interface\n", __func__);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_linux.c
index 9adbeaf16cf8..a25a95270dce 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/ioctl_linux.c
@@ -43,6 +43,13 @@
 #ifdef CONFIG_MP_INCLUDED
 #include <rtw_mp.h>
 #endif
+#ifdef CONFIG_RTL8192C
+#include <rtl8192c_hal.h>
+#endif
+#ifdef CONFIG_RTL8192D
+#include <rtl8192d_hal.h>
+#endif
+
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
 #define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
@@ -320,7 +327,7 @@ static char *translate_scan(_adapter *padapter,
 				u32	p2pielen = 0;
 
 				//	Verifying the P2P IE
-				if ( rtw_get_p2p_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen) )
+				if (rtw_get_p2p_ie_from_scan_queue(&pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0]))
 				{
 					blnGotP2PIE = _TRUE;
 				}
@@ -341,7 +348,7 @@ static char *translate_scan(_adapter *padapter,
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
 		
-		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
+		if ( rtw_get_wfd_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength,  wfd_ie, &wfd_ielen, pnetwork->network.Reserved[0]) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
@@ -392,8 +399,14 @@ static char *translate_scan(_adapter *padapter,
 	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
 
 	//parsing HT_CAP_IE
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		p = rtw_get_ie(&pnetwork->network.IEs[0], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength);
+	}
+	else
+	{
 		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
-
+	}
 	if(p && ht_ielen>0)
 	{
 		struct rtw_ieee80211_ht_cap *pht_capie;
@@ -441,11 +454,16 @@ static char *translate_scan(_adapter *padapter,
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
 
 	  /* Add mode */
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		cap = 0;
+	}
+	else
+	{
         iwe.cmd = SIOCGIWMODE;
-	_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
-
-
-	cap = le16_to_cpu(cap);
+		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+		cap = le16_to_cpu(cap);
+	}
 
 	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
 		if (cap & WLAN_CAPABILITY_BSS)
@@ -515,8 +533,9 @@ static char *translate_scan(_adapter *padapter,
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
 
 	//parsing WPA/WPA2 IE
+	if (pnetwork->network.Reserved[0] != 2) // Probe Request
 	{
-		u8 buf[MAX_WPA_IE_LEN];
+		u8 buf[MAX_WPA_IE_LEN*2];
 		u8 wpa_ie[255],rsn_ie[255];
 		u16 wpa_len=0,rsn_len=0;
 		u8 *p;
@@ -528,11 +547,20 @@ static char *translate_scan(_adapter *padapter,
 		if (wpa_len > 0)
 		{
 			p=buf;
-			_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
 			p += sprintf(p, "wpa_ie=");
 			for (i = 0; i < wpa_len; i++) {
 				p += sprintf(p, "%02x", wpa_ie[i]);
 			}
+
+			if (wpa_len > 100) {
+				printk("-----------------Len %d----------------\n", wpa_len);
+				for (i = 0; i < wpa_len; i++) {
+					printk("%02x ", wpa_ie[i]);
+				}
+				printk("\n");
+				printk("-----------------Len %d----------------\n", wpa_len);
+			}
 	
 			_rtw_memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd = IWEVCUSTOM;
@@ -547,7 +575,7 @@ static char *translate_scan(_adapter *padapter,
 		if (rsn_len > 0)
 		{
 			p = buf;
-			_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
 			p += sprintf(p, "rsn_ie=");
 			for (i = 0; i < rsn_len; i++) {
 				p += sprintf(p, "%02x", rsn_ie[i]);
@@ -572,6 +600,17 @@ static char *translate_scan(_adapter *padapter,
 		u8 *ie_ptr = pnetwork->network.IEs +_FIXED_IE_LENGTH_;
 		total_ielen= pnetwork->network.IELength - _FIXED_IE_LENGTH_;
 
+		if (pnetwork->network.Reserved[0] == 2) // Probe Request
+		{
+			ie_ptr = pnetwork->network.IEs;
+			total_ielen = pnetwork->network.IELength;
+		}
+		else     // Beacon or Probe Respones
+		{
+			ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+			total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+		}
+
 		while(cnt < total_ielen)
 		{
 			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
@@ -581,7 +620,7 @@ static char *translate_scan(_adapter *padapter,
 				iwe.u.data.length = (u16)wps_ielen;
 				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);						
 			}			
-			cnt+=ie_ptr[cnt+1]+2; //goto next		
+			cnt+=ie_ptr[cnt+1]+2; //goto next
 		}
 	}
 
@@ -599,7 +638,7 @@ static char *translate_scan(_adapter *padapter,
 	;
 
 	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
-		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {
 		ss = padapter->recvpriv.signal_strength;
 		sq = padapter->recvpriv.signal_qual;
 	} else {
@@ -626,7 +665,21 @@ static char *translate_scan(_adapter *padapter,
 
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
 }
-	
+
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 * p,*pos;
+		int len;
+		p = buf;
+		pos = pnetwork->network.Reserved;
+		_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+		p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
+		_rtw_memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		iwe.u.data.length = strlen(buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+	}
+    
 	return start;	
 }
 
@@ -1895,15 +1948,8 @@ _func_enter_;
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter,
 		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
-	{		
-		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
-		{
-			printk("scanning_via_buddy_intf\n");
-			pmlmepriv->scanning_via_buddy_intf = _TRUE;
-		}		
-
+	{
 		indicate_wx_scan_complete_event(padapter);
-		
 		goto exit;
 	}
 #endif
@@ -1916,23 +1962,6 @@ _func_enter_;
 	}
 #endif
 
-//	Mareded by Albert 20101103
-//	For the DMP WiFi Display project, the driver won't to scan because
-//	the pmlmepriv->scan_interval is always equal to 3.
-//	So, the wpa_supplicant won't find out the WPS SoftAP.
-
-/*
-	if(pmlmepriv->scan_interval>10)
-		pmlmepriv->scan_interval = 0;
-
-	if(pmlmepriv->scan_interval > 0)
-	{
-		DBG_871X("scan done\n");
-		ret = 0;
-		goto exit;
-	}
-		
-*/
 #ifdef CONFIG_P2P
 	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
@@ -2134,21 +2163,18 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 	}
 #endif //CONFIG_P2P
 
-/*
-#ifdef CONFIG_CONCURRENT_MODE	
-	if(pmlmepriv->scanning_via_buddy_intf == _TRUE)
-	{
-		pmlmepriv->scanning_via_buddy_intf = _FALSE;//reset
+#if 1 // Wireless Extension use EAGAIN to try
+	wait_status = _FW_UNDER_SURVEY
+#ifndef CONFIG_ANDROID
+		| _FW_UNDER_LINKING
+#endif
+	;
 
-		// change pointers to buddy interface
-		padapter = pbuddy_adapter;
-		pmlmepriv = pbuddy_mlmepriv;
-		queue = &(pbuddy_mlmepriv->scanned_queue);		
-		
+	while (check_fwstate(pmlmepriv, wait_status) == _TRUE)
+	{
+		return -EAGAIN;
 	}
-#endif // CONFIG_CONCURRENT_MODE			
-*/
-
+#else
 	wait_status = _FW_UNDER_SURVEY
 		#ifndef CONFIG_ANDROID
 		|_FW_UNDER_LINKING
@@ -2172,6 +2198,7 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 		if(cnt > wait_for_surveydone )
 			break;
 	}
+#endif
 
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
@@ -4500,7 +4527,7 @@ static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
 
 			//	The mac address is matched.
 
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
 			{
 				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_CONF_METHOD, (u8 *)&attr_content, &attr_contentlen);
 				if (attr_contentlen)
@@ -4636,7 +4663,7 @@ static int rtw_p2p_get_go_device_address(struct net_device *dev,
 			//	Match the device address located in the P2P IE
 			//	This is for the case that the P2P device address is not the same as the P2P interface address.
 
-			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
+			if ((p2pie = rtw_get_p2p_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0])))
 			{
 				while (p2pie)
 				{
@@ -4729,7 +4756,7 @@ static int rtw_p2p_get_device_type(struct net_device *dev,
 
 			//	The mac address is matched.
 
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
 			{
 				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_PRIMARY_DEV_TYPE, dev_type, &dev_type_len);
 				if (dev_type_len)
@@ -4807,7 +4834,7 @@ static int rtw_p2p_get_device_name(struct net_device *dev,
 
 			//	The mac address is matched.
 
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
 			{
 				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_DEVICE_NAME, dev_name, &dev_len);
 				if (dev_len)
@@ -4880,7 +4907,7 @@ static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
 			//	Match the device address located in the P2P IE
 			//	This is for the case that the P2P device address is not the same as the P2P interface address.
 
-			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
+			if ((p2pie = rtw_get_p2p_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0])))
 			{
 				while (p2pie)
 				{
@@ -5143,7 +5170,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 		//	Match the device address located in the P2P IE
 		//	This is for the case that the P2P device address is not the same as the P2P interface address.
 
-		if ( (p2pie=rtw_get_p2p_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)) )
+		if ( (p2pie=rtw_get_p2p_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0])))
 		{
 			//	The P2P Device ID attribute is included in the Beacon frame.
 			//	The P2P Device Info attribute is included in the probe response frame.
@@ -5181,7 +5208,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
 		
-		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
+		if ( rtw_get_wfd_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength,  wfd_ie, &wfd_ielen, pnetwork->network.Reserved[0]) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
@@ -5481,7 +5508,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 		//	Match the device address located in the P2P IE
 		//	This is for the case that the P2P device address is not the same as the P2P interface address.
 
-		if ( (p2pie=rtw_get_p2p_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)) )
+		if ( (p2pie=rtw_get_p2p_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0])))
 		{
 			//	The P2P Device ID attribute is included in the Beacon frame.
 			//	The P2P Device Info attribute is included in the probe response frame.
@@ -5521,7 +5548,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
 		
-		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
+		if ( rtw_get_wfd_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength,  wfd_ie, &wfd_ielen, pnetwork->network.Reserved[0]) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
@@ -5839,7 +5866,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		} else { // Beacon or Probe Respones
 			ie_offset = 12;
 		}
-		if ( (p2pie=rtw_get_p2p_ie( &pnetwork->network.IEs[ie_offset], pnetwork->network.IELength - ie_offset, NULL, &p2pielen)) )
+		if ( (p2pie=rtw_get_p2p_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0])))
 		{
 			while ( p2pie )
 			{
@@ -5897,7 +5924,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
 		
-		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
+			if ( rtw_get_wfd_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength,  wfd_ie, &wfd_ielen, pnetwork->network.Reserved[0]) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
@@ -5991,6 +6018,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 	{
 		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
 #ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 		rtw_free_network_queue(padapter, _TRUE);		
@@ -6387,112 +6415,6 @@ static int rtw_rereg_nd_name(struct net_device *dev,
 
 }
 
-#if 0
-void mac_reg_dump(_adapter *padapter)
-{
-	int i,j=1;		
-	DBG_871X("\n======= MAC REG =======\n");
-	for(i=0x0;i<0x300;i+=4)
-	{	
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}
-	for(i=0x400;i<0x800;i+=4)
-	{	
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}									
-}
-void bb_reg_dump(_adapter *padapter)
-{
-	int i,j=1;		
-	DBG_871X("\n======= BB REG =======\n");
-	for(i=0x800;i<0x1000;i+=4)
-	{
-		if(j%4==1) DBG_871X("0x%02x",i);
-				
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}		
-}
-void rf_reg_dump(_adapter *padapter)
-{	
-	int i,j=1,path;
-	u32 value;			
-	DBG_871X("\n======= RF REG =======\n");
-	for(path=0;path<2;path++)
-	{
-		DBG_871X("\nRF_Path(%x)\n",path);
-		for(i=0;i<0x100;i++)
-		{								
-			value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-			if(j%4==1)	DBG_871X("0x%02x ",i);
-			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");	
-		}	
-	}
-}
-
-#endif
-
-void mac_reg_dump(_adapter *padapter)
-{
-	int i,j=1;		
-	DBG_871X("\n======= MAC REG =======\n");
-	for(i=0x0;i<0x300;i+=4)
-	{	
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}
-	for(i=0x400;i<0x800;i+=4)
-	{	
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}									
-}
-void bb_reg_dump(_adapter *padapter)
-{
-	int i,j=1;		
-	DBG_871X("\n======= BB REG =======\n");
-	for(i=0x800;i<0x1000;i+=4)
-	{
-		if(j%4==1) DBG_871X("0x%02x",i);
-				
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
-		if((j++)%4 == 0)	DBG_871X("\n");	
-	}		
-}
-void rf_reg_dump(_adapter *padapter)
-{	
-	int i,j=1,path;
-	u32 value;	
-	u8 rf_type,path_nums = 0;
-	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		
-	DBG_871X("\n======= RF REG =======\n");
-	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	
-		path_nums = 1;
-	else	
-		path_nums = 2;
-		
-	for(path=0;path<path_nums;path++)
-	{
-		DBG_871X("\nRF_Path(%x)\n",path);
-		for(i=0;i<0x100;i++)
-		{								
-			//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-			value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-			if(j%4==1)	DBG_871X("0x%02x ",i);
-			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");	
-		}	
-	}
-}
-
 #ifdef CONFIG_IOL
 #include <rtw_iol.h>
 #endif
@@ -6929,7 +6851,7 @@ static int rtw_dbg_port(struct net_device *dev,
 		#endif	
 
 				case 0x10:// driver version display
-					DBG_871X("rtw driver version=%s\n", DRIVERVERSION);
+					dump_drv_version(RTW_DBGDUMP);
 					break;
 				case 0x11:
 					{
@@ -6993,22 +6915,29 @@ static int rtw_dbg_port(struct net_device *dev,
 #endif // CONFIG_P2P
 						break;						
 					}
-#if 1
+
+				case 0xaa:
+				{
+					if((extra_arg & 0x7F)> 0x3F) extra_arg = 0xFF;
+					DBG_871X("chang data rate to :0x%02x\n",extra_arg);
+					padapter->fix_rate = extra_arg;
+				}
+					break;
+
 				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
 					{						
 						if(extra_arg==0){
-							mac_reg_dump(padapter);
+							mac_reg_dump(RTW_DBGDUMP, padapter);
 						}
 						else if(extra_arg==1){
-							bb_reg_dump(padapter);
+							bb_reg_dump(RTW_DBGDUMP, padapter);
 						}
 						else if(extra_arg==2){
-							rf_reg_dump(padapter);
+							rf_reg_dump(RTW_DBGDUMP, padapter);
 						}
-																				
 					}
-					break;		
-#endif
+					break;
+
 				case 0xee://turn on/off dynamic funcs
 					{
 						u8 dm_flag;
@@ -8234,12 +8163,12 @@ static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param,
 	ie_len = len-12-2;// 12 = param header, 2:no packed
 	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);
 
-	if (ssid_ie && ssid_len) {
+	if (ssid_ie && ssid_len > 0 && ssid_len <= NDIS_802_11_LENGTH_SSID) {
 		WLAN_BSSID_EX *pbss_network = &mlmepriv->cur_network.network;
 		WLAN_BSSID_EX *pbss_network_ext = &mlmeinfo->network;
 
 		_rtw_memcpy(ssid, ssid_ie+2, ssid_len);
-		ssid[ssid_len>NDIS_802_11_LENGTH_SSID?NDIS_802_11_LENGTH_SSID:ssid_len] = 0x0;
+		ssid[ssid_len] = 0x0;
 
 		if(0)
 		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
@@ -8528,9 +8457,6 @@ static int rtw_wx_set_priv(struct net_device *dev,
 			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==_TRUE))
 		{
 			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
-
-			//_rtw_memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz);
-			//pmlmepriv->probereq_wpsie_len = cp_sz;
 					
 			printk("probe_req_wps_ielen=%d\n", cp_sz);
 						
@@ -8658,25 +8584,57 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			struct iw_request_info *info,
 			union iwreq_data *wdata, char *extra)
 {
-	struct iw_point *wrqu = (struct iw_point *)wdata;
 	PADAPTER padapter = rtw_netdev_priv(dev);
-	struct mp_priv *pmp_priv;	
-	
-	int i,j =0;
-	u8 data[EFUSE_MAP_SIZE];
-	u8 rawdata[EFUSE_MAX_SIZE];
-	u16 mapLen=0;
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
+	PEFUSE_HAL pEfuseHal;
+	struct iw_point *wrqu;
+	
+	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
+	u8 ips_mode,lps_mode;
+	struct pwrctrl_priv *pwrctrlpriv ;
+	u8 *data = NULL;
+	u8 *rawdata = NULL;
 	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
-	u16 addr = 0, cnts = 0, max_available_size = 0,raw_cursize = 0 ,raw_maxsize = 0;
+	u16 i=0, j=0, mapLen=0, addr=0, cnts=0;
+	u16 max_available_size=0, raw_cursize=0, raw_maxsize=0;
+	int err;
+	
 	
-	_rtw_memset(data, '\0', sizeof(data));
-	_rtw_memset(rawdata, '\0', sizeof(rawdata));
+	wrqu = (struct iw_point*)wdata;
+	pwrctrlpriv = &padapter->pwrctrlpriv; 
+	pEfuseHal = &pHalData->EfuseHal;
+	err = 0;
+	data = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
+	if (data == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	rawdata = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
+	if (rawdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
 	
 	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
-		return -EFAULT;
+	{
+		err = -EFAULT;
+		goto exit;
+	}
+	#ifdef CONFIG_LPS
+	lps_mode = pwrctrlpriv->power_mgnt;//keep org value
+	rtw_pm_set_lps(padapter,PS_MODE_ACTIVE);
+	#endif	
+	
+	#ifdef CONFIG_IPS	
+	ips_mode = pwrctrlpriv->ips_mode;//keep org value
+	rtw_pm_set_ips(padapter,IPS_NONE);
+	#endif	
 
 	pch = extra;
-	DBG_871X("%s: in=%s\n", __func__, extra);
+	DBG_871X("%s: in=%s\n", __FUNCTION__, extra);
 	
 	i=0;
 	//mac 16 "00e04c871200" rmap,00,2
@@ -8687,285 +8645,601 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			i++;
 	}
 	
-	if ( strcmp(tmp[0],"realmap") == 0 ) {
-		
-		DBG_871X("strcmp OK =	%s \n" ,tmp[0]);
-
+	if (strcmp(tmp[0], "drvmap") == 0)
+	{
 		mapLen = EFUSE_MAP_SIZE;
 		 
-		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS){
-			DBG_871X("\t  rtw_efuse_map_read \n"); 
-		}else {
-			DBG_871X("\t  rtw_efuse_map_read : Fail \n");
-			return -EFAULT;
+		sprintf(extra, "\n");
+		for (i = 0; i < EFUSE_MAP_SIZE; i += 16)
+		{
+//			DBG_871X("0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, PROMContent[i+j]);
 		} 
-		_rtw_memset(extra, '\0', sizeof(extra));
-		DBG_871X("\tOFFSET\tVALUE(hex)\n");
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, PROMContent[i+j]);
+			}
+//			DBG_871X("\n");
 		sprintf(extra, "%s \n", extra);
-		for ( i = 0; i < EFUSE_MAP_SIZE; i += 16 )
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0], "realmap") == 0)
 		{
-			DBG_871X("\t0x%02x\t", i);
-			sprintf(extra, "%s \t0x%02x\t", extra,i);
-			for (j = 0; j < 8; j++)
+		mapLen = EFUSE_MAP_SIZE;
+		if (rtw_efuse_map_read(padapter, 0, mapLen, pEfuseHal->fakeEfuseInitMap) == _FAIL)
 			{	  
-				DBG_871X("%02X ", data[i+j]);
-				sprintf(extra, "%s %02X", extra, data[i+j]);
+			DBG_871X("%s: read realmap Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+			}
+
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for ( i = 0; i < EFUSE_MAP_SIZE; i += 16 )
+		{
+//			DBG_871X("0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseInitMap[i+j]);
 			}
-			DBG_871X("\t");
+//			DBG_871X("\t");
 			sprintf(extra,"%s\t",extra);
 			for (; j < 16; j++){
-				DBG_871X("%02X ", data[i+j]);
-				sprintf(extra, "%s %02X", extra, data[i+j]);
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseInitMap[i+j]);
 			}
-			DBG_871X("\n");
+//			DBG_871X("\n");
 			sprintf(extra,"%s\n",extra);	
 		}
-		DBG_871X("\n");
-		wrqu->length = strlen(extra);
-	
-		return 0;
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0], "rmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			DBG_871X("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
 	}
-	else if ( strcmp(tmp[0],"rmap") == 0 ) {
-		if ( tmp[1]==NULL || tmp[2]==NULL ) return	-EINVAL;
+
 		// rmap addr cnts
 		addr = simple_strtoul(tmp[1], &ptmp, 16);
-
-		DBG_871X("addr = %x \n" ,addr);
+		DBG_871X("%s: addr=%x\n", __FUNCTION__, addr);
 
 		cnts=simple_strtoul(tmp[2], &ptmp,10);
-		if(cnts==0) return -EINVAL;
-
-		DBG_871X("cnts = %d \n" ,cnts);
-		//_rtw_memset(extra, '\0', wrqu->data.length);
+		if (cnts == 0)
+		{
+			DBG_871X("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
+		}
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
 
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-		if ((addr + cnts) > max_available_size) {
-			DBG_871X("(addr + cnts parameter error \n");
-			return -EFAULT;
+		if ((addr + cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EINVAL;
+			goto exit;
 		}
 				
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
 		{
-			DBG_871X("rtw_efuse_access error \n"); 		
-		}
-		else{
-			DBG_871X("rtw_efuse_access ok \n");
+			DBG_871X("%s: rtw_efuse_map_read error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 		}	
 
-		_rtw_memset(extra, '\0', sizeof(extra));	 
+//		DBG_871X("%s: data={", __FUNCTION__);
+		*extra = 0;
 		for ( i = 0; i < cnts; i ++) {
-			DBG_871X("0x%02x", data[i]);
+//			DBG_871X("0x%02x ", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i]);
-			DBG_871X(" ");
-			sprintf(extra,"%s ",extra);
 		}
-
-		wrqu->length = strlen(extra)+1;
-
-		DBG_871X("extra = %s ", extra);
-
-		return 0;	
+//		DBG_871X("}\n");
 	}
-	else if ( strcmp(tmp[0],"realraw") == 0 ) {
+	else if (strcmp(tmp[0], "realraw") == 0)
+	{
 		addr=0;
 		mapLen = EFUSE_MAX_SIZE;
-
 		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL)
 		{
-			DBG_871X("\t  rtw_efuse_map_read : Fail \n");
-			return -EFAULT;
-		} else
-		{
-			DBG_871X("\t  rtw_efuse_access raw ok \n");	
+			DBG_871X("%s: rtw_efuse_access Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 		}
 				
-		_rtw_memset(extra, '\0', sizeof(extra));
-		for ( i=0; i<mapLen; i++ ) {
-			DBG_871X(" %02x", rawdata[i]);
-			sprintf(extra, "%s %02x", extra, rawdata[i] );
+//		DBG_871X("%s: realraw={\n", __FUNCTION__);
+		sprintf(extra, "\n");
+		for (i=0; i<mapLen; i++)
+		{
+//			DBG_871X("%02X", rawdata[i]);
+			sprintf(extra, "%s%02X", extra, rawdata[i]);
 
 			if ((i & 0xF) == 0xF){ 
-				DBG_871X("\n\t");
-				sprintf(extra, "%s\n\t", extra);
+//				DBG_871X("\n");
+				sprintf(extra, "%s\n", extra);
 			}
 			else if ((i & 0x7) == 0x7){ 
-				DBG_871X("\t");
+//				DBG_871X("\t");
 				sprintf(extra, "%s\t", extra);
+			} else {
+//				DBG_871X(" ");
+				sprintf(extra, "%s ", extra);
 			}
 		}
-		wrqu->length = strlen(extra);
-		return 0;
+//		DBG_871X("}\n");
 	}
-	else if ( strcmp(tmp[0],"mac") == 0 ) {
-		if ( tmp[1]==NULL || tmp[2]==NULL ) return	-EINVAL;
+	else if (strcmp(tmp[0], "mac") == 0)
+	{
 		#ifdef CONFIG_RTL8192C
-		addr = 0x16;
-		cnts = 6;
+		addr = 0x16; // EEPROM_MAC_ADDR
 		#endif
 		#ifdef CONFIG_RTL8192D
 		addr = 0x19;
-		cnts = 6;
 		#endif
+		cnts = 6;
+
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-		if ((addr + mapLen) > max_available_size) {
-			DBG_871X("(addr + cnts parameter error \n");
-			return -EFAULT;
+		if ((addr + cnts) > max_available_size) {
+			DBG_871X("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
 		}
+
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
 		{
-			DBG_871X("rtw_efuse_access error \n"); 		
+			DBG_871X("%s: rtw_efuse_map_read error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 		}
-		else{
-			DBG_871X("rtw_efuse_access ok \n");
+
+//		DBG_871X("%s: MAC address={", __FUNCTION__);
+		*extra = 0;
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("%02X", data[i]);
+			sprintf(extra, "%s%02X", extra, data[i]);
+			if (i != (cnts-1))
+			{
+//				DBG_871X(":");
+				sprintf(extra,"%s:",extra);
 		}	
-		_rtw_memset(extra, '\0', sizeof(extra));		 
-		for ( i = 0; i < cnts; i ++) {
-			DBG_871X("0x%02x", data[i]);
-			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
-			DBG_871X(" ");
-			sprintf(extra,"%s ",extra);
 		}
-		wrqu->length = strlen(extra);
-		return 0;
+//		DBG_871X("}\n");
 	}
-	else if ( strcmp(tmp[0],"vidpid") == 0 ) {
-		if ( tmp[1]==NULL || tmp[2]==NULL ) return	-EINVAL;
+	else if (strcmp(tmp[0], "vidpid") == 0)
+	{
 		#ifdef CONFIG_RTL8192C
-		addr=0x0a;
+		addr = 0x0a; // EEPROM_VID
 		#endif
 		#ifdef CONFIG_RTL8192D
 		addr = 0x0c;
 		#endif
+		
 		cnts = 4;
+
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-		if ((addr + mapLen) > max_available_size) {
-			DBG_871X("(addr + cnts parameter error \n");
-			return -EFAULT;
+		if ((addr + cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
 		}
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
 		{
-			DBG_871X("rtw_efuse_access error \n"); 		
+			DBG_871X("%s: rtw_efuse_access error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 		}
-		else{
-			DBG_871X("rtw_efuse_access ok \n");
+
+//		DBG_871X("%s: {VID,PID}={", __FUNCTION__);
+		*extra = 0;
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("0x%02x", data[i]);
+			sprintf(extra, "%s0x%02X", extra, data[i]);
+			if (i != (cnts-1))
+			{
+//				DBG_871X(",");
+				sprintf(extra,"%s,",extra);
 		}	
-		_rtw_memset(extra, '\0', sizeof(extra));		 
-		for ( i = 0; i < cnts; i ++) {
-			DBG_871X("0x%02x", data[i]);
-			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
-			DBG_871X(" ");
-			sprintf(extra,"%s ",extra);
 		}
-		wrqu->length = strlen(extra);
-		return 0;
+//		DBG_871X("}\n");
 	}
-	else if ( strcmp(tmp[0],"ableraw") == 0 ) {
+	else if (strcmp(tmp[0], "ableraw") == 0)
+	{
 		efuse_GetCurrentSize(padapter,&raw_cursize);
 		raw_maxsize = efuse_GetMaxSize(padapter);
-		sprintf(extra, "%s : [ available raw size] = %d",extra,raw_maxsize-raw_cursize);
-		wrqu->length = strlen(extra);
+		sprintf(extra, "[available raw size]= %d bytes", raw_maxsize-raw_cursize);
+	}
+	#if 0
+	else if (strcmp(tmp[0], "btfmap") == 0)
+	{
+		mapLen = EFUSE_BT_MAX_MAP_LEN;
+		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
 
-		return 0;
-	}else
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<512; i+=16) // set 512 because the iwpriv's extra size have limit 0x7FF
 	{
-		 sprintf(extra, "%s : Command not found\n",extra);
-		  wrqu->length = strlen(extra);
-		  return 0;
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra,"%s\t",extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
 	}
-	
-	return 0;
-}
-
-static int rtw_mp_efuse_set(struct net_device *dev,
-			struct iw_request_info *info,
-			union iwreq_data *wdata, char *extra)
-{
-	struct iw_point *wrqu = (struct iw_point *)wdata;
-	PADAPTER padapter = rtw_netdev_priv(dev);
-	
-	u8 buffer[40];
-	u32 i,jj,kk;
-	u8 setdata[EFUSE_MAP_SIZE];
-	u8 setrawdata[EFUSE_MAX_SIZE];
-	char *pch, *ptmp, *token, *edata,*tmp[3]={0x00,0x00,0x00};
-
-	u16 addr = 0, max_available_size = 0;
-	u32  cnts = 0;
-	
-	pch = extra;
-	DBG_871X("%s: in=%s\n", __func__, extra);
-	
-	i=0;
-	while ( (token = strsep (&pch,",") )!=NULL )
+	else if (strcmp(tmp[0],"btbmap") == 0)
 	{
-		if(i>2) break;
-		tmp[i] = token;
-		i++;
+		mapLen = EFUSE_BT_MAX_MAP_LEN;
+		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 	}
-
-	// tmp[0],[1],[2]
-	// wmap,addr,00e04c871200
-	if ( strcmp(tmp[0],"wmap") == 0 ) {
-		 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
-			if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT; 			
-				  
-			addr = simple_strtoul( tmp[1], &ptmp, 16 );
-			addr = addr & 0xFF;
-			DBG_871X("addr = %x \n" ,addr);
-					
-			cnts = strlen( tmp[2] )/2;	
-			if ( cnts == 0) return -EFAULT;
-					
-			DBG_871X("cnts = %d \n" ,cnts);
-			DBG_871X("target data = %s \n" ,tmp[2]);
-					
-			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
-			{
-				setdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
-			}
 	
-			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-			
-			if ((addr + cnts) > max_available_size) {
-						DBG_871X("parameter error \n");
-						return -EFAULT;
-			}	
-			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {			
-					DBG_871X("rtw_efuse_map_write error \n");
-					return -EFAULT;
-			} else
-			   DBG_871X("rtw_efuse_map_write ok \n");
-		
-		return 0;
-	}
-	else if ( strcmp(tmp[0],"wraw") == 0 ) {
-			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
-			 if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT;			 
-			addr = simple_strtoul( tmp[1], &ptmp, 16 );
-			addr = addr & 0xFF;
-			DBG_871X("addr = %x \n" ,addr);
-				
-			cnts=strlen( tmp[2] )/2;
-			if ( cnts == 0) return -EFAULT;
-
-			DBG_871X(" cnts = %d \n" ,cnts );		
-			DBG_871X("target data = %s \n" ,tmp[2] );
-			
-			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=512; i<1024 ; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++)
 			{
-					setrawdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
 			}
-					
-			if ( rtw_efuse_access( padapter, _TRUE, addr, cnts, setrawdata ) == _FAIL ){
-					DBG_871X("\t  rtw_efuse_map_read : Fail \n");
-						return -EFAULT;
-			} else
-			  DBG_871X("\t  rtw_efuse_access raw ok \n");	
+//			DBG_871X("\t");
+			sprintf(extra,"%s\t",extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"btrmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		// rmap addr cnts
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+
+		cnts = simple_strtoul(tmp[2], &ptmp, 10);
+		if (cnts == 0)
+		{
+			DBG_871X("%s: btrmap Fail!! cnts error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
+		}
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		if ((addr + cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_BT_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		*extra = 0;
+//		DBG_871X("%s: bt efuse data={", __FUNCTION__);
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("0x%02x ", data[i]);
+			sprintf(extra, "%s 0x%02X ", extra, data[i]);
+		}
+//		DBG_871X("}\n");
+	}
+	else if (strcmp(tmp[0], "btffake") == 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<512; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"btbfake") == 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=512; i<1024; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	#endif
+	else if (strcmp(tmp[0],"wlrfkmap")== 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<EFUSE_MAP_SIZE; i+=16)
+		{
+//			DBG_871X("\t0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s %02X", extra, pEfuseHal->fakeEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else
+	{
+		 sprintf(extra, "Command not found!");
+	}
+
+exit:
+	if (data)
+		rtw_mfree(data, EFUSE_BT_MAX_MAP_LEN);
+	if (rawdata)
+		rtw_mfree(rawdata, EFUSE_BT_MAX_MAP_LEN);
+	if (!err)
+		wrqu->length = strlen(extra);
+	
+	#ifdef CONFIG_IPS		
+	rtw_pm_set_ips(padapter, ips_mode);
+	#endif
+	#ifdef CONFIG_LPS	
+	rtw_pm_set_lps(padapter, lps_mode);
+	#endif
+	
+	return err;
+}
+
+
+static int rtw_mp_efuse_set(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu;
+	PADAPTER padapter;
+	struct pwrctrl_priv *pwrctrlpriv;
+	PHAL_DATA_TYPE pHalData;
+	PEFUSE_HAL pEfuseHal;
+	
+	u8 ips_mode,lps_mode;
+	u32 i=0,jj=0,kk=0;
+	u8 *setdata = NULL;
+	u8 *ShadowMapBT = NULL;
+	u8 *ShadowMapWiFi = NULL;
+	u8 *setrawdata = NULL;
+	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
+	u16 addr=0, cnts=0, max_available_size=0;
+	int err;
+	wrqu = (struct iw_point*)wdata;
+
+	
+	padapter = rtw_netdev_priv(dev);
+	pwrctrlpriv = &padapter->pwrctrlpriv; 
+	pHalData = GET_HAL_DATA(padapter);
+	pEfuseHal = &pHalData->EfuseHal;
+	err = 0;
+	setdata = rtw_zmalloc(1024);
+	if (setdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	ShadowMapBT = rtw_malloc(EFUSE_BT_MAX_MAP_LEN);
+	if (ShadowMapBT == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	ShadowMapWiFi = rtw_malloc(EFUSE_MAP_SIZE);
+	if (ShadowMapWiFi == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	setrawdata = rtw_malloc(EFUSE_MAX_SIZE);
+	if (setrawdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	#ifdef CONFIG_LPS
+	lps_mode = pwrctrlpriv->power_mgnt;//keep org value
+	rtw_pm_set_lps(padapter,PS_MODE_ACTIVE);
+	#endif	
+	
+	#ifdef CONFIG_IPS	
+	ips_mode = pwrctrlpriv->ips_mode;//keep org value
+	rtw_pm_set_ips(padapter,IPS_NONE);
+	#endif	
+	
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+			return -EFAULT;
+
+	pch = extra;
+	DBG_871X("%s: in=%s\n", __FUNCTION__, extra);
+	
+	i=0;
+	while ( (token = strsep (&pch,",") )!=NULL )
+	{
+		if(i>2) break;
+		tmp[i] = token;
+		i++;
+	}
+
+	// tmp[0],[1],[2]
+	// wmap,addr,00e04c871200
+	if (strcmp(tmp[0], "wmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+				  
+			addr = simple_strtoul( tmp[1], &ptmp, 16 );
+		addr &= 0xFFF;
+					
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+					
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: map data=%s\n", __FUNCTION__, tmp[2]);
+					
+			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
+			{
+				setdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
+			}
+		//Change to check TYPE_EFUSE_MAP_LEN ,beacuse 8188E raw 256,logic map over 256.
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_size, _FALSE);
+		if ((addr+cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+			}	
+		
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		sprintf(extra, "wmap completed \n");
+	}
+	}
+	else if (strcmp(tmp[0], "wraw") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+	}
+
+			addr = simple_strtoul( tmp[1], &ptmp, 16 );
+		addr &= 0xFFF;
+				
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: raw data=%s\n", __FUNCTION__, tmp[2]);
+			
+			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
+			{
+					setrawdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
+			}
+					
+		if (rtw_efuse_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_access error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
 			
-					return 0;
+		sprintf(extra, "wraw completed \n");
+		}
+	else if (strcmp(tmp[0], "mac") == 0)
+	{
+		if (tmp[1]==NULL)
+		{
+			err = -EINVAL;
+			goto exit;
 		}
-	else if ( strcmp(tmp[0],"mac") == 0 ) { 
-			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
+
 			//mac,00e04c871200
 			#ifdef CONFIG_RTL8192C
 				addr = 0x16;
@@ -8973,36 +9247,62 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 			#ifdef CONFIG_RTL8192D
 				addr = 0x19;
 			#endif
-				cnts = strlen( tmp[1] )/2;
-				if ( cnts == 0) return -EFAULT;
-				if ( cnts > 6 ){
-						DBG_871X("error data for mac addr = %s \n" ,tmp[1]);
-						return -EFAULT;
+		
+		cnts = strlen(tmp[1]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		if (cnts > 6)
+		{
+			DBG_871X("%s: error data for mac addr=\"%s\"\n", __FUNCTION__, tmp[1]);
+			err = -EFAULT;
+			goto exit;
 				}
 				
-				DBG_871X("target data = %s \n" ,tmp[1]);
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: MAC address=%s\n", __FUNCTION__, tmp[1]);
 				
 				for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 				{
 					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
 				}
 				
-				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		//Change to check TYPE_EFUSE_MAP_LEN ,beacuse 8188E raw 256,logic map over 256.
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_size, _FALSE);
 		
-				if ((addr + cnts) > max_available_size) {
-						DBG_871X("parameter error \n");
-						return -EFAULT;
+		if ((addr+cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
 					}	
-				if ( rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL ) {
-					DBG_871X("rtw_efuse_map_write error \n");
-					return -EFAULT;
-				} else
-					DBG_871X("rtw_efuse_map_write ok \n");
 				
-			return 0;
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		
+		sprintf(extra, "wmac completed \n");
+	}
+	else if (strcmp(tmp[0], "vidpid") == 0)
+	{
+		if (tmp[1]==NULL)
+		{
+			err = -EINVAL;
+			goto exit;
 		}
-		else if ( strcmp(tmp[0],"vidpid") == 0 ) { 
-			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
+
 				// pidvid,da0b7881
 				#ifdef CONFIG_RTL8192C
 					   addr=0x0a;
@@ -9011,9 +9311,22 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 					addr = 0x0c;
 				#endif
 				
-				cnts=strlen( tmp[1] )/2;
-				if ( cnts == 0) return -EFAULT;
-				DBG_871X("target data = %s \n" ,tmp[1]);
+		cnts = strlen(tmp[1]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+				
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: VID/PID=%s\n", __FUNCTION__, tmp[1]);
 				
 				for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 				{
@@ -9021,32 +9334,223 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 				}
 
 				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		if ((addr+cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
 				
-				if ((addr + cnts) > max_available_size) {
-						DBG_871X("parameter error \n");
-						return -EFAULT;
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
 					}	
 				
-				if ( rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL ) {
-					DBG_871X("rtw_efuse_map_write error \n");
-					return -EFAULT;
-				} else
-					DBG_871X("rtw_efuse_map_write ok \n");
+		sprintf(extra, "wvidpid completed \n");
+	}
+	else if (strcmp(tmp[0], "wldumpfake") == 0)
+	{
+		if (rtw_efuse_map_read(padapter, 0, EFUSE_MAP_SIZE,  pEfuseHal->fakeEfuseModifiedMap) == _SUCCESS) {
+			DBG_871X("%s: WiFi hw efuse dump to Fake map success \n", __FUNCTION__); 
+			sprintf(extra, "wvidpid completed \n");
+		} else {
+			DBG_871X("%s: WiFi hw efuse dump to Fake map Fail \n", __FUNCTION__);
+			err = -EFAULT;
+		}
 			
-				return 0;
+		sprintf(extra, "wldumpfake completed \n");
 		}
-		else{
-				 DBG_871X("Command not found\n");
-			   return 0;
+	#if 0
+	else if (strcmp(tmp[0], "btwfake") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
 		}
 		
-	  return 0;
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
 }
 
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: BT tmp data=%s\n", __FUNCTION__, tmp[2]);
 
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			pEfuseHal->fakeBTEfuseModifiedMap[addr+jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+	}
+	else if (strcmp(tmp[0], "btwmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+					}	
 
-#if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+			
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: BT data=%s\n", __FUNCTION__, tmp[2]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+}
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		if ((addr+cnts) > max_available_size)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_BT_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+	else if (strcmp(tmp[0], "btdumpfake") == 0)
+	{
+		if (rtw_BT_efuse_map_read(padapter, 0, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _SUCCESS) {
+			DBG_871X("%s: BT read all map success\n", __FUNCTION__);
+		} else {
+			DBG_871X("%s: BT read all map Fail!\n", __FUNCTION__);
+			err = -EFAULT;
+		}
+	}
+	
+	else if (strcmp(tmp[0], "btfk2map") == 0)
+	{
+		_rtw_memcpy(pEfuseHal->BTEfuseModifiedMap, pEfuseHal->fakeBTEfuseModifiedMap, EFUSE_BT_MAX_MAP_LEN);
+			
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE); 
+		if (max_available_size < 1)
+		{
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_BT_efuse_map_write(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_write error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+	#endif
+	else if (strcmp(tmp[0], "wlfk2map") == 0)
+	{
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);					
+		if (max_available_size < 1)
+		{
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_efuse_map_write(padapter, 0x00, EFUSE_MAP_SIZE, pEfuseHal->fakeEfuseModifiedMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		
+		sprintf(extra, "wlfk2map completed \n");
+	}
+	else if (strcmp(tmp[0], "wlwfake") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: map tmp data=%s\n", __FUNCTION__, tmp[2]);
 
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			pEfuseHal->fakeEfuseModifiedMap[addr+jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+		
+		sprintf(extra, "wlwfake completed \n");
+	}
+
+	
+exit:
+	if (setdata)
+		rtw_mfree(setdata, 1024);
+	if (ShadowMapBT)
+		rtw_mfree(ShadowMapBT, EFUSE_BT_MAX_MAP_LEN);
+	if (ShadowMapWiFi)
+		rtw_mfree(ShadowMapWiFi, EFUSE_MAP_SIZE);
+	if (setrawdata)
+		rtw_mfree(setrawdata, EFUSE_MAX_SIZE);
+	
+	#ifdef CONFIG_IPS		
+	rtw_pm_set_ips(padapter, ips_mode);
+	#endif
+	#ifdef CONFIG_LPS	
+	rtw_pm_set_lps(padapter, lps_mode);
+	#endif
+	wrqu->length = strlen(extra);
+	return err;
+}
+
+
+
+#if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
 /*
  * Input Format: %s,%d,%d
  *	%s is width, could be
@@ -9066,9 +9570,15 @@ static int rtw_mp_write_reg(struct net_device *dev,
 	u32 addr, data;
 	int ret;
 	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[wrqu->length];
+	
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+				 return -EFAULT;
 
+	_rtw_memset(extra, 0, wrqu->length);	
+	  
+	pch = input;
 
-	pch = extra;
 	pnext = strpbrk(pch, " ,.-");
 	if (pnext == NULL) return -EINVAL;
 	*pnext = 0;
@@ -9174,7 +9684,7 @@ static int rtw_mp_read_reg(struct net_device *dev,
 		case 'w':
 			// 2 bytes
 			//*(u16*)data = rtw_read16(padapter, addr);
-			sprintf(data, "%04d\n", rtw_read16(padapter, addr));
+			sprintf(data, "%04x\n", rtw_read16(padapter, addr));
 			for( i=0 ; i <= strlen(data) ; i++)
 				{
 					  if( i%2==0 )
@@ -9193,6 +9703,9 @@ static int rtw_mp_read_reg(struct net_device *dev,
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
+					if (!pnext)
+						break;
+					
 					pnext++;
 					if ( *pnext != '\0' )
 					{
@@ -9204,7 +9717,7 @@ static int rtw_mp_read_reg(struct net_device *dev,
 					}
 					pch = pnext;
 				}
-			wrqu->length = 6;
+			wrqu->length = 7;
 			break;
 		case 'd':
 			// 4 bytes
@@ -9218,7 +9731,9 @@ static int rtw_mp_read_reg(struct net_device *dev,
 						   tmp[j]=' ';
 						   j++;
 					  }
+					  if ( data[i] != '\0' )
 					  tmp[j] = data[i];
+					  
 					  j++;
 				}
 				pch = tmp;		
@@ -9227,6 +9742,9 @@ static int rtw_mp_read_reg(struct net_device *dev,
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
+					if (!pnext)
+						break;
+					
 					pnext++;
 					if ( *pnext != '\0' )
 					{
@@ -9268,19 +9786,24 @@ static int rtw_mp_read_reg(struct net_device *dev,
 	u32 path, addr, data;
 	int ret;
 	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[wrqu->length];
 
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+				 return -EFAULT;
 
-	ret = sscanf(extra, "%d,%x,%x", &path, &addr, &data);
+	ret = sscanf(input, "%d,%x,%x", &path, &addr, &data);
 	if (ret < 3) return -EINVAL;
 
 	if (path >= MAX_RF_PATH_NUMS) return -EINVAL;
 	if (addr > 0xFF) return -EINVAL;
 	if (data > 0xFFFFF) return -EINVAL;
+	
 	_rtw_memset(extra, 0, wrqu->length);
 
 	write_rfreg(padapter, path, addr, data);
 
 	sprintf(extra, "write_rf completed \n");
+	wrqu->length = strlen(extra);
 	
 	return 0;
 }
@@ -9360,6 +9883,8 @@ static int rtw_mp_start(struct net_device *dev,
 	u8 val8;
 	PADAPTER padapter = rtw_netdev_priv(dev);
 
+        rtw_pm_set_ips(padapter,IPS_NONE);
+	LeaveAllPowerSaveMode(padapter);    
 
 	if (padapter->registrypriv.mp_mode == 0)
 		return -EPERM;
@@ -9381,7 +9906,7 @@ static int rtw_mp_stop(struct net_device *dev,
 
 
 	if (padapter->mppriv.mode != MP_OFF) {
-		mp_stop_test(padapter);
+		//mp_stop_test(padapter);
 		padapter->mppriv.mode = MP_OFF;
 	}
 
@@ -9525,7 +10050,7 @@ static int rtw_mp_ant_tx(struct net_device *dev,
 			}
 	}
 	//antenna |= BIT(extra[i]-'a');
-	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
+	DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
 	padapter->mppriv.antenna_tx = antenna;
 	//DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_tx);
 	
@@ -9584,7 +10109,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 	struct pkt_attrib *pattrib;
 
 	PADAPTER padapter = rtw_netdev_priv(dev);
-
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 
 	pmp_priv = &padapter->mppriv;
 
@@ -9599,7 +10124,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 	scTx = strncmp(extra, "background,sc", 20);
 	sgleTx = strncmp(extra, "background,stone", 20);
 	pkTx = strncmp(extra, "background,pkt", 20);
-	stop = strncmp(extra, "stop", 5);
+	stop = strncmp(extra, "stop", 4);
 	sscanf(extra, "count=%d,pkt", &count);
 	
 	//DBG_871X("%s: count=%d countPkTx=%d cotuTx=%d CarrSprTx=%d scTx=%d sgleTx=%d pkTx=%d stop=%d\n", __func__, count, countPkTx, cotuTx, CarrSprTx, pkTx, sgleTx, scTx, stop);
@@ -9629,7 +10154,18 @@ static int rtw_mp_ctx(struct net_device *dev,
 		pmp_priv->mode = MP_CARRIER_SUPPRISSION_TX;
 	if (scTx == 0)
 		pmp_priv->mode = MP_SINGLE_CARRIER_TX;
-
+#ifdef CONFIG_RTL8192D
+	if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	{
+		rtw_write32(padapter, 0x860,0x66F60610);
+		rtw_write32(padapter, 0x864,0x061F0510);
+	}
+	else
+	{
+		rtw_write32(padapter, 0x860, 0x66F60250);
+		rtw_write32(padapter, 0x864, 0x061F0150);
+	}
+#endif	
 	switch (pmp_priv->mode)
 	{
 		case MP_PACKET_TX:
@@ -9651,6 +10187,11 @@ static int rtw_mp_ctx(struct net_device *dev,
 				pattrib = &pmp_priv->tx.attrib;
 				pattrib->pktlen = 1460;
 				_rtw_memset(pattrib->dst, 0xFF, ETH_ALEN);
+				#ifdef CONFIG_RTL8192D
+					if(pHalData->CurrentBandType92D != BAND_ON_2_4G)
+						PHY_SetBBReg(padapter, 0x864, bMaskDWord, 0x061f0151);
+						//PHY_SetBBReg(padapter, 0x864, bMaskDWord, 0x061f0510);
+				#endif
 				SetPacketTx(padapter);
 			} 
 			else {
@@ -9664,13 +10205,12 @@ static int rtw_mp_ctx(struct net_device *dev,
 			//DBG_871X("%s: sgleTx %d \n", __func__, bStartTest);
 			if (bStartTest != 0){
 				sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
-            		
            		 }
 			Hal_SetSingleToneTx(padapter, (u8)bStartTest);
 			break;
 
 		case MP_CONTINUOUS_TX:
-			DBG_871X("%s: cotuTx %d\n", __func__, bStartTest);
+			//DBG_871X("%s: cotuTx %d\n", __func__, bStartTest);
 			if (bStartTest != 0){
 				sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
            		 }
@@ -9683,10 +10223,10 @@ static int rtw_mp_ctx(struct net_device *dev,
 				if( pmp_priv->rateidx <= MPT_RATE_11M ) 
 				{
 					sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
+					Hal_SetCarrierSuppressionTx(padapter, (u8)bStartTest);
 				}else
 					sprintf( extra, "Specify carrier suppression but not CCK rate");
 			}
-			Hal_SetCarrierSuppressionTx(padapter, (u8)bStartTest);
 			break;
 
 		case MP_SINGLE_CARRIER_TX:
@@ -9703,7 +10243,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 			return -EFAULT;
 	}
 
-	if (bStartTest) {
+	if ( bStartTest==1 && pmp_priv->mode != MP_ON) {
 		struct mp_priv *pmp_priv = &padapter->mppriv;
 		if (pmp_priv->tx.stop == 0) {
 			pmp_priv->tx.stop = 1;
@@ -9725,10 +10265,13 @@ static int rtw_mp_arx(struct net_device *dev,
 			struct iw_request_info *info,
 			struct iw_point *wrqu, char *extra)
 {
-	u8 bStartRx=0,bStopRx=0;
-	PADAPTER padapter = rtw_netdev_priv(dev);
+	u8 bStartRx=0,bStopRx=0,bQueryPhy;
+	u32 cckok=0,cckcrc=0,ofdmok=0,ofdmcrc=0,htok=0,htcrc=0,OFDM_FA=0,CCK_FA=0;
 	u8 		input[wrqu->length];
 
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
 
@@ -9736,21 +10279,49 @@ static int rtw_mp_arx(struct net_device *dev,
 
 	bStartRx = (strncmp(input, "start", 5)==0)?1:0; // strncmp TRUE is 0
 	bStopRx = (strncmp(input, "stop", 5)==0)?1:0; // strncmp TRUE is 0
-	SetPacketRx(padapter, bStartRx);
+	bQueryPhy = (strncmp(input, "phy", 3)==0)?1:0; // strncmp TRUE is 0
 
 	if(bStartRx)
 	{
 		sprintf( extra, "start");
-		wrqu->length = strlen(extra) + 1;
+		SetPacketRx(padapter, bStartRx);
 	}
 	else if(bStopRx)
 	{
-		sprintf( extra, "Received packet OK:%d CRC error:%d",padapter->mppriv.rx_pktcount,
-														padapter->mppriv.rx_crcerrpktcount);
-		wrqu->length = strlen(extra) + 1;
+		SetPacketRx(padapter, 0);
+		sprintf( extra, "Received packet OK:%d CRC error:%d",padapter->mppriv.rx_pktcount,padapter->mppriv.rx_crcerrpktcount);
 	}
-	
-
+	else if(bQueryPhy)
+	{          
+		/*
+		OFDM FA
+		RegCF0[15:0]
+		RegCF2[31:16]
+		RegDA0[31:16]
+		RegDA4[15:0]
+		RegDA4[31:16]
+		RegDA8[15:0]
+		CCK FA
+		(RegA5B<<8) | RegA5C
+		*/
+		cckok = read_bbreg(padapter, 0xf88, 0xffffffff );
+		cckcrc = read_bbreg(padapter, 0xf84, 0xffffffff );
+		ofdmok = read_bbreg(padapter, 0xf94, 0x0000FFFF );
+		ofdmcrc = read_bbreg(padapter, 0xf94 , 0xFFFF0000 );
+		htok = read_bbreg(padapter, 0xf90, 0x0000FFFF );
+		htcrc = read_bbreg(padapter,0xf90, 0xFFFF0000 );
+	
+		OFDM_FA=+read_bbreg(padapter, 0xcf0, 0x0000FFFF );
+		OFDM_FA=+read_bbreg(padapter, 0xcf2, 0xFFFF0000 );
+		OFDM_FA=+read_bbreg(padapter, 0xda0, 0xFFFF0000 );
+		OFDM_FA=+read_bbreg(padapter, 0xda4, 0x0000FFFF );
+		OFDM_FA=+read_bbreg(padapter, 0xda4, 0xFFFF0000 );
+		OFDM_FA=+read_bbreg(padapter, 0xda8, 0x0000FFFF );
+ 		CCK_FA=(rtw_read8(padapter, 0xa5b )<<8 ) | (rtw_read8(padapter, 0xa5c));
+
+		sprintf( extra, "Phy Received packet OK:%d CRC error:%d FA Counter: %d",cckok+ofdmok+htok,cckcrc+ofdmcrc+htcrc,OFDM_FA+CCK_FA);
+	}
+		wrqu->length = strlen(extra) + 1;
 	return 0;
 }
 
@@ -9790,6 +10361,7 @@ static int rtw_mp_pwrtrk(struct net_device *dev,
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
 
+	DBG_871X("%s:iwpriv in=%s\n", __func__, input);
 	_rtw_memset(extra, 0, wrqu->length);
 		
 	enable = 1;
@@ -9803,8 +10375,10 @@ static int rtw_mp_pwrtrk(struct net_device *dev,
 				ret = Hal_SetThermalMeter(padapter, (u8)thermal);
 				if (ret == _FAIL) return -EPERM;
 				sprintf(extra, "mp tx power tracking start,target value=%d ok ",thermal);
-		}else	{
-			return -EINVAL;
+		}
+		else	
+		{
+			//return -EINVAL;
 		}
 	}
 
@@ -9897,8 +10471,14 @@ static int rtw_mp_reset_stats(struct net_device *dev,
 	pmp_priv = &padapter->mppriv;
 	
 	pmp_priv->tx.sended = 0;
-	padapter->mppriv.rx_pktcount = 0;
-	padapter->mppriv.rx_crcerrpktcount = 0;
+	pmp_priv->tx_pktcount = 0;
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+
+	//reset phy counter
+	write_bbreg(padapter,0xf14,BIT16,0x1);
+	rtw_msleep_os(10);
+	write_bbreg(padapter,0xf14,BIT16,0x0);
 
 	return 0;
 }
@@ -10029,14 +10609,6 @@ static int rtw_mp_set(struct net_device *dev,
 
 	switch(subcmd)
 	{
-	case WRITE_REG :
-			rtw_mp_write_reg (dev,info,wrqu,extra);
-			 break;
-			 
-	case WRITE_RF:
-			rtw_mp_write_rf (dev,info,wrqu,extra);
-			 break; 
-			 
 	case MP_START:
 			DBG_871X("set case mp_start \n");
 			rtw_mp_start (dev,info,wrqu,extra);
@@ -10057,11 +10629,6 @@ static int rtw_mp_set(struct net_device *dev,
 			rtw_mp_reset_stats	(dev,info,wrqu,extra);
 			break;
 			
-	case EFUSE_SET:
-			DBG_871X("efuse set \n");
-			rtw_mp_efuse_set (dev,info,wdata,extra);
-			break;	
-		 		
 	}
 
 	  
@@ -10091,6 +10658,14 @@ static int rtw_mp_get(struct net_device *dev,
 	
 	switch(subcmd)
 	{
+	case WRITE_REG :
+			rtw_mp_write_reg (dev,info,wrqu,extra);
+			 break;
+			 
+	case WRITE_RF:
+			rtw_mp_write_rf (dev,info,wrqu,extra);
+			 break; 
+			 
 	case MP_PHYPARA:
 			DBG_871X("mp_get  MP_PHYPARA \n");
 			rtw_mp_phypara(dev,info,wrqu,extra);	
@@ -10150,6 +10725,11 @@ static int rtw_mp_get(struct net_device *dev,
 			rtw_mp_efuse_get(dev,info,wdata,extra);
 		 break; 
 		 
+	case EFUSE_SET:
+			DBG_871X("efuse set \n");
+			rtw_mp_efuse_set (dev,info,wdata,extra);
+			break;	
+		 			 
 	case MP_DUMP:
 			DBG_871X("set case MP_DUMP \n");
 			rtw_mp_dump (dev,info,wrqu,extra);
@@ -10935,11 +11515,12 @@ static int rtw_widi_set_probe_request(struct net_device *dev,
 	pbuf = rtw_malloc(sizeof(l2_msg_t));
 	if(pbuf)
 	{
-		copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length);
+		if ( copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length) )
+			ret = -EFAULT;
 		//_rtw_memcpy(pbuf, wrqu->data.pointer, wrqu->data.length);
 
 		if( wrqu->data.flags == 0 )
-		intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf);
+			intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf);
 		else if( wrqu->data.flags == 1 )
 			rtw_set_wfd_rds_sink_info( padapter, (l2_msg_t *)pbuf );
 	}
@@ -11516,37 +12097,6 @@ static int rtw_test(
 }
 #endif //RTL8723A_SDIO_LOOPBACK
 
-#include <rtw_android.h>
-int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct iwreq *wrq = (struct iwreq *)rq;
-	int ret=0;
-
-	switch (cmd)
-	{
-	    case RTL_IOCTL_WPA_SUPPLICANT:	
-			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
-			break;
-#ifdef CONFIG_AP_MODE
-		case RTL_IOCTL_HOSTAPD:
-			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);			
-			break;
-#ifdef CONFIG_NO_WIRELESS_HANDLERS			
-		case SIOCSIWMODE:
-			ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
-			break;
-#endif			
-#endif
-		case (SIOCDEVPRIVATE+1):
-			ret = rtw_android_priv_cmd(dev, rq, cmd);
-			break;
-	    default:
-			ret = -EOPNOTSUPP;
-			break;
-	}
-	
-	return ret;
-}
 
 static iw_handler rtw_handlers[] =
 {
@@ -11649,14 +12199,22 @@ static const struct iw_priv_args rtw_private_args[] =
 		{ MP_ARX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_arx"},
 		{ MP_ANT_RX , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ant_rx"},
 		{ MP_THER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ther"},
-		{ EFUSE_SET, IW_PRIV_TYPE_CHAR | 1024, 0, "efuse_set" },
 		{ EFUSE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get" },
+		{ EFUSE_SET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_set" },
 		{ MP_NULL , IW_PRIV_TYPE_CHAR | 1024, 0, "NULL"},
 		{ MP_PWRTRK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrtrk" },
 		{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"}, // mp_ioctl	
 		
 	
-	{ SIOCIWFIRSTPRIV + 0x02, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "test"},//set
+	{
+		SIOCIWFIRSTPRIV + 0x2,
+		IW_PRIV_TYPE_CHAR | 0x7FF, 0, "write"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3,
+		IW_PRIV_TYPE_CHAR | 0x7FF,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read"
+	},
 };
 
 
@@ -11664,6 +12222,8 @@ static iw_handler rtw_private_handler[] =
 {
 	rtw_mp_set,
 	rtw_mp_get,
+	rtw_wx_write32,					//0x00
+	rtw_wx_read32,					//0x01
 };
 
 #else // not inlucde MP
@@ -11895,15 +12455,415 @@ struct iw_handler_def rtw_handlers_def =
 {
 	.standard = rtw_handlers,
 	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) || defined(CONFIG_WEXT_PRIV)
+//#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) || defined(CONFIG_WEXT_PRIV)
 	.private = rtw_private_handler,
 	.private_args = (struct iw_priv_args *)rtw_private_args,
 	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
  	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
-#endif
+//#endif
 #if WIRELESS_EXT >= 17
 	.get_wireless_stats = rtw_get_wireless_stats,
 #endif
 };
 #endif
 
+// copy from net/wireless/wext.c start
+/* ---------------------------------------------------------------- */
+/*
+ * Calculate size of private arguments
+ */
+static const char iw_priv_type_size[] = {
+	0,								/* IW_PRIV_TYPE_NONE */
+	1,								/* IW_PRIV_TYPE_BYTE */
+	1,								/* IW_PRIV_TYPE_CHAR */
+	0,								/* Not defined */
+	sizeof(__u32),					/* IW_PRIV_TYPE_INT */
+	sizeof(struct iw_freq), 		/* IW_PRIV_TYPE_FLOAT */
+	sizeof(struct sockaddr),		/* IW_PRIV_TYPE_ADDR */
+	0,								/* Not defined */
+};
+
+static int get_priv_size(__u16 args)
+{
+	int num = args & IW_PRIV_SIZE_MASK;
+	int type = (args & IW_PRIV_TYPE_MASK) >> 12;
+
+	return num * iw_priv_type_size[type];
+}
+
+// copy from net/wireless/wext.c end
+
+static int rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_data)
+{
+	int err = 0;
+	u8 *input = NULL;
+	u32 input_len = 0;
+	const char delim[] = " ";
+	u8 *output = NULL;
+	u32 output_len = 0;
+	u32 count = 0;
+	u8 *buffer= NULL;
+	u32 buffer_len = 0;
+	char *ptr = NULL;
+	u8 cmdname[17] = {0}; // IFNAMSIZ+1
+	u32 cmdlen;
+	s32 len;
+	u8 *extra = NULL;
+	u32 extra_size = 0;
+
+	s32 k;
+	const iw_handler *priv; 	/* Private ioctl */
+	const struct iw_priv_args *priv_args;	/* Private ioctl description */
+	u32 num_priv;				/* Number of ioctl */
+	u32 num_priv_args;			/* Number of descriptions */
+	iw_handler handler;
+	int temp;
+	int subcmd = 0; 			/* sub-ioctl index */
+	int offset = 0; 			/* Space for sub-ioctl index */
+
+	union iwreq_data wdata;
+
+
+	_rtw_memcpy(&wdata, wrq_data, sizeof(wdata));
+
+	input_len = wdata.data.length;
+	input = rtw_zmalloc(input_len);
+	if (NULL == input)
+		return -ENOMEM;
+	if (copy_from_user(input, wdata.data.pointer, input_len)) {
+		err = -EFAULT;
+		goto exit;
+	}
+	ptr = input;
+	len = input_len;
+
+	sscanf(ptr, "%16s", cmdname);
+	cmdlen = strlen(cmdname);
+	DBG_8192C("%s: cmd=%s\n", __func__, cmdname);
+
+	// skip command string
+	if (cmdlen > 0)
+		cmdlen += 1; // skip one space
+	ptr += cmdlen;
+	len -= cmdlen;
+	DBG_8192C("%s: parameters=%s\n", __func__, ptr);
+
+	priv = rtw_private_handler;
+	priv_args = rtw_private_args;
+	num_priv = sizeof(rtw_private_handler) / sizeof(iw_handler);
+	num_priv_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args);
+
+	if (num_priv_args == 0) {
+		err = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Search the correct ioctl */
+	k = -1;
+	while((++k < num_priv_args) && strcmp(priv_args[k].name, cmdname));
+
+	/* If not found... */
+	if (k == num_priv_args) {
+		err = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Watch out for sub-ioctls ! */
+	if (priv_args[k].cmd < SIOCDEVPRIVATE)
+	{
+		int j = -1;
+
+		/* Find the matching *real* ioctl */
+		while ((++j < num_priv_args) && ((priv_args[j].name[0] != '\0') ||
+			(priv_args[j].set_args != priv_args[k].set_args) ||
+			(priv_args[j].get_args != priv_args[k].get_args)));
+
+		/* If not found... */
+		if (j == num_priv_args) {
+			err = -EINVAL;
+			goto exit;
+		}
+
+		/* Save sub-ioctl number */
+		subcmd = priv_args[k].cmd;
+		/* Reserve one int (simplify alignment issues) */
+		offset = sizeof(__u32);
+		/* Use real ioctl definition from now on */
+		k = j;
+	}
+
+	buffer = rtw_zmalloc(4096);
+	if (NULL == buffer) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/* If we have to set some data */
+	if ((priv_args[k].set_args & IW_PRIV_TYPE_MASK) &&
+		(priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+	{
+		u8 *str;
+
+		switch (priv_args[k].set_args & IW_PRIV_TYPE_MASK)
+		{
+			case IW_PRIV_TYPE_BYTE:
+				/* Fetch args */
+				count = 0;
+				do {
+					str = strsep(&ptr, delim);
+					if (NULL == str) break;
+					sscanf(str, "%i", &temp);
+					buffer[count++] = (u8)temp;
+				} while (1);
+				buffer_len = count;
+
+				/* Number of args to fetch */
+				wdata.data.length = count;
+				if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+					wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+				break;
+
+			case IW_PRIV_TYPE_INT:
+				/* Fetch args */
+				count = 0;
+				do {
+					str = strsep(&ptr, delim);
+					if (NULL == str) break;
+					sscanf(str, "%i", &temp);
+					((s32*)buffer)[count++] = (s32)temp;
+				} while (1);
+				buffer_len = count * sizeof(s32);
+
+				/* Number of args to fetch */
+				wdata.data.length = count;
+				if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+					wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+				break;
+
+			case IW_PRIV_TYPE_CHAR:
+				if (len > 0)
+				{
+					/* Size of the string to fetch */
+					wdata.data.length = len;
+					if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+						wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+					/* Fetch string */
+					_rtw_memcpy(buffer, ptr, wdata.data.length);
+				}
+				else
+				{
+					wdata.data.length = 1;
+					buffer[0] = '\0';
+				}
+				buffer_len = wdata.data.length;
+				break;
+
+			default:
+				DBG_8192C("%s: Not yet implemented...\n", __func__);
+				err = -1;
+				goto exit;
+		}
+
+		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+			(wdata.data.length != (priv_args[k].set_args & IW_PRIV_SIZE_MASK)))
+		{
+			DBG_8192C("%s: The command %s needs exactly %d argument(s)...\n",
+					__func__, cmdname, priv_args[k].set_args & IW_PRIV_SIZE_MASK);
+			err = -EINVAL;
+			goto exit;
+		}
+	}	/* if args to set */
+	else
+	{
+		wdata.data.length = 0L;
+	}
+
+	/* Those two tests are important. They define how the driver
+	* will have to handle the data */
+	if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+		((get_priv_size(priv_args[k].set_args) + offset) <= IFNAMSIZ))
+	{
+		/* First case : all SET args fit within wrq */
+		if (offset)
+			wdata.mode = subcmd;
+		_rtw_memcpy(wdata.name + offset, buffer, IFNAMSIZ - offset);
+	}
+	else
+	{
+		if ((priv_args[k].set_args == 0) &&
+			(priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(get_priv_size(priv_args[k].get_args) <= IFNAMSIZ))
+		{
+			/* Second case : no SET args, GET args fit within wrq */
+			if (offset)
+				wdata.mode = subcmd;
+		}
+		else
+		{
+			/* Third case : args won't fit in wrq, or variable number of args */
+			if (copy_to_user(wdata.data.pointer, buffer, buffer_len)) {
+				err = -EFAULT;
+				goto exit;
+			}
+			wdata.data.flags = subcmd;
+		}
+	}
+
+	rtw_mfree(input, input_len);
+	input = NULL;
+
+	extra_size = 0;
+	if (IW_IS_SET(priv_args[k].cmd))
+	{
+		/* Size of set arguments */
+		extra_size = get_priv_size(priv_args[k].set_args);
+
+		/* Does it fits in iwr ? */
+		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+			((extra_size + offset) <= IFNAMSIZ))
+			extra_size = 0;
+	} else {
+		/* Size of get arguments */
+		extra_size = get_priv_size(priv_args[k].get_args);
+
+		/* Does it fits in iwr ? */
+		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(extra_size <= IFNAMSIZ))
+			extra_size = 0;
+	}
+
+	if (extra_size == 0) {
+		extra = (u8*)&wdata;
+		rtw_mfree(buffer, 4096);
+		buffer = NULL;
+	} else
+		extra = buffer;
+
+	handler = priv[priv_args[k].cmd - SIOCIWFIRSTPRIV];
+	err = handler(dev, NULL, &wdata, extra);
+
+	/* If we have to get some data */
+	if ((priv_args[k].get_args & IW_PRIV_TYPE_MASK) &&
+		(priv_args[k].get_args & IW_PRIV_SIZE_MASK))
+	{
+		int j;
+		int n = 0;	/* number of args */
+		u8 str[20] = {0};
+
+		/* Check where is the returned data */
+		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(get_priv_size(priv_args[k].get_args) <= IFNAMSIZ))
+			n = priv_args[k].get_args & IW_PRIV_SIZE_MASK;
+		else
+			n = wdata.data.length;
+
+		output = rtw_zmalloc(4096);
+		if (NULL == output) {
+			err =  -ENOMEM;
+			goto exit;
+		}
+
+		switch (priv_args[k].get_args & IW_PRIV_TYPE_MASK)
+		{
+			case IW_PRIV_TYPE_BYTE:
+				/* Display args */
+				for (j = 0; j < n; j++)
+				{
+					sprintf(str, "%d  ", extra[j]);
+					len = strlen(str);
+					output_len = strlen(output);
+					if ((output_len + len + 1) > 4096) {
+						err = -E2BIG;
+						goto exit;
+					}
+					_rtw_memcpy(output+output_len, str, len);
+				}
+				break;
+
+			case IW_PRIV_TYPE_INT:
+				/* Display args */
+				for (j = 0; j < n; j++)
+				{
+					sprintf(str, "%d  ", ((__s32*)extra)[j]);
+					len = strlen(str);
+					output_len = strlen(output);
+					if ((output_len + len + 1) > 4096) {
+						err = -E2BIG;
+						goto exit;
+					}
+					_rtw_memcpy(output+output_len, str, len);
+				}
+				break;
+
+			case IW_PRIV_TYPE_CHAR:
+				/* Display args */
+				_rtw_memcpy(output, extra, n);
+				break;
+
+			default:
+				DBG_8192C("%s: Not yet implemented...\n", __func__);
+				err = -1;
+				goto exit;
+		}
+
+		output_len = strlen(output) + 1;
+		wrq_data->data.length = output_len;
+		if (copy_to_user(wrq_data->data.pointer, output, output_len)) {
+			err = -EFAULT;
+			goto exit;
+		}
+	}	/* if args to set */
+	else
+	{
+		wrq_data->data.length = 0;
+	}
+
+exit:
+	if (input)
+		rtw_mfree(input, input_len);
+	if (buffer)
+		rtw_mfree(buffer, 4096);
+	if (output)
+		rtw_mfree(output, 4096);
+
+	return err;
+}
+
+#include <rtw_android.h>
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret=0;
+
+	switch (cmd)
+	{
+		case RTL_IOCTL_WPA_SUPPLICANT:	
+			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+			break;
+#ifdef CONFIG_AP_MODE
+		case RTL_IOCTL_HOSTAPD:
+			ret = rtw_hostapd_ioctl(dev, &wrq->u.data); 		
+			break;
+#ifdef CONFIG_NO_WIRELESS_HANDLERS			
+		case SIOCSIWMODE:
+			ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
+			break;
+#endif			
+#endif
+		case SIOCDEVPRIVATE:
+			ret = rtw_ioctl_wext_private(dev, &wrq->u);
+			break;
+		case (SIOCDEVPRIVATE+1):
+			ret = rtw_android_priv_cmd(dev, rq, cmd);
+			break;
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+	
+	return ret;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/mlme_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/mlme_linux.c
index 6fc9f034af11..5cacd593aae7 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/mlme_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/mlme_linux.c
@@ -160,7 +160,7 @@ extern void indicate_wx_scan_complete_event(_adapter *padapter);
 void rtw_os_indicate_scan_done( _adapter *padapter, bool aborted)
 {
 #ifdef CONFIG_IOCTL_CFG80211
-	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), aborted);
+	rtw_cfg80211_indicate_scan_done(padapter, aborted);
 #endif
 	indicate_wx_scan_complete_event(padapter);
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/os_intfs.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/os_intfs.c
index 3f9c81fa26a7..d171f4887c9e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/os_intfs.c
@@ -268,490 +268,6 @@ int netdev_open (struct net_device *pnetdev);
 static int netdev_close (struct net_device *pnetdev);
 
 //#ifdef RTK_DMP_PLATFORM
-#ifdef CONFIG_PROC_DEBUG
-#define RTL8192C_PROC_NAME "rtl819xC"
-#define RTL8192D_PROC_NAME "rtl819xD"
-static char rtw_proc_name[IFNAMSIZ];
-static struct proc_dir_entry *rtw_proc = NULL;
-static int	rtw_proc_cnt = 0;
-
-#define RTW_PROC_NAME DRV_NAME
-
-void rtw_proc_init_one(struct net_device *dev)
-{
-	struct proc_dir_entry *dir_dev = NULL;
-	struct proc_dir_entry *entry=NULL;
-	_adapter	*padapter = rtw_netdev_priv(dev);
-	u8 rf_type;
-
-	if(rtw_proc == NULL)
-	{
-		if(padapter->chip_type == RTL8188C_8192C)
-		{
-			_rtw_memcpy(rtw_proc_name, RTL8192C_PROC_NAME, sizeof(RTL8192C_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8192D)
-		{
-			_rtw_memcpy(rtw_proc_name, RTL8192D_PROC_NAME, sizeof(RTL8192D_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8723A)
-		{
-			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8188E)
-		{
-			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
-		else
-		{
-			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
-
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
-#else
-		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
-#endif
-		if (rtw_proc == NULL) {
-			DBG_871X(KERN_ERR "Unable to create rtw_proc directory\n");
-			return;
-		}
-
-		entry = create_proc_read_entry("ver_info", S_IFREG | S_IRUGO, rtw_proc, proc_get_drv_version, dev);
-		if (!entry) {
-			DBG_871X("Unable to create_proc_read_entry!\n");
-			return;
-		}
-
-		entry = create_proc_read_entry("log_level", S_IFREG | S_IRUGO,
-				   rtw_proc, proc_get_log_level, dev);
-		if (!entry) {
-			DBG_871X("Unable to create_proc_read_entry!\n");
-			return;
-		}
-		entry->write_proc = proc_set_log_level;
-		
-#ifdef DBG_MEM_ALLOC
-		entry = create_proc_read_entry("mstat", S_IFREG | S_IRUGO,
-				   rtw_proc, proc_get_mstat, dev);
-		if (!entry) {
-			DBG_871X("Unable to create_proc_read_entry!\n");
-			return;
-		}
-#endif /* DBG_MEM_ALLOC */
-	}
-
-
-
-	if(padapter->dir_dev == NULL)
-	{
-		padapter->dir_dev = create_proc_entry(dev->name,
-					  S_IFDIR | S_IRUGO | S_IXUGO,
-					  rtw_proc);
-
-		dir_dev = padapter->dir_dev;
-
-		if(dir_dev==NULL)
-		{
-			if(rtw_proc_cnt == 0)
-			{
-				if(rtw_proc){
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-					remove_proc_entry(rtw_proc_name, proc_net);
-#else
-					remove_proc_entry(rtw_proc_name, init_net.proc_net);
-#endif
-					rtw_proc = NULL;
-				}
-			}
-
-			DBG_871X("Unable to create dir_dev directory\n");
-			return;
-		}
-	}
-	else
-	{
-		return;
-	}
-
-	rtw_proc_cnt++;
-
-	entry = create_proc_read_entry("write_reg", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_write_reg, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_write_reg;
-
-	entry = create_proc_read_entry("read_reg", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_read_reg, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_read_reg;
-
-
-	entry = create_proc_read_entry("fwstate", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_fwstate, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-
-	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_sec_info, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-
-	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_mlmext_state, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-
-	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_qos_option, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("ht_option", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ht_option, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("rf_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rf_info, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("ap_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ap_info, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("adapter_state", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_adapter_state, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("trx_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_trx_info, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("mac_reg_dump1", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_mac_reg_dump1, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("mac_reg_dump2", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_mac_reg_dump2, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("mac_reg_dump3", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_mac_reg_dump3, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("bb_reg_dump1", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_bb_reg_dump1, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("bb_reg_dump2", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_bb_reg_dump2, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("bb_reg_dump3", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_bb_reg_dump3, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("rf_reg_dump1", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rf_reg_dump1, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("rf_reg_dump2", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rf_reg_dump2, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	{
-		entry = create_proc_read_entry("rf_reg_dump3", S_IFREG | S_IRUGO,
-					   dir_dev, proc_get_rf_reg_dump3, dev);
-		if (!entry) {
-			DBG_871X("Unable to create_proc_read_entry!\n");
-			return;
-		}
-
-		entry = create_proc_read_entry("rf_reg_dump4", S_IFREG | S_IRUGO,
-					   dir_dev, proc_get_rf_reg_dump4, dev);
-		if (!entry) {
-			DBG_871X("Unable to create_proc_read_entry!\n");
-			return;
-		}
-	}
-
-#ifdef CONFIG_AP_MODE
-
-	entry = create_proc_read_entry("all_sta_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_all_sta_info, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-#endif
-
-#ifdef DBG_MEMORY_LEAK
-	entry = create_proc_read_entry("_malloc_cnt", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_malloc_cnt, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-#endif
-
-#ifdef CONFIG_FIND_BEST_CHANNEL
-	entry = create_proc_read_entry("best_channel", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_best_channel, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_best_channel;
-#endif
-
-	entry = create_proc_read_entry("rx_signal", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rx_signal, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_rx_signal;
-
-	entry = create_proc_read_entry("ht_enable", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ht_enable, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_ht_enable;
-
-	entry = create_proc_read_entry("cbw40_enable", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_cbw40_enable, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_cbw40_enable;
-
-	entry = create_proc_read_entry("ampdu_enable", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ampdu_enable, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_ampdu_enable;
-
-	entry = create_proc_read_entry("rx_stbc", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rx_stbc, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_rx_stbc;
-
-
-	entry = create_proc_read_entry("path_rssi", S_IFREG | S_IRUGO,
-					dir_dev, proc_get_two_path_rssi, dev);
-
-	entry = create_proc_read_entry("vid", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_vid, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("pid", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_pid, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-
-	entry = create_proc_read_entry("rssi_disp", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rssi_disp, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_rssi_disp;
-
-#if defined(DBG_CONFIG_ERROR_DETECT)
-	entry = create_proc_read_entry("sreset", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_sreset, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_sreset;
-#endif /* DBG_CONFIG_ERROR_DETECT */
-
-#ifdef CONFIG_DM_ADAPTIVITY
-	entry = create_proc_read_entry("dm_adaptivity", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_dm_adaptivity, dev);
-	if (!entry) {
-		DBG_871X("Unable to create_proc_read_entry!\n");
-		return;
-	}
-	entry->write_proc = proc_set_dm_adaptivity;
-#endif /* CONFIG_DM_ADAPTIVITY */
-
-}
-
-void rtw_proc_remove_one(struct net_device *dev)
-{
-	struct proc_dir_entry *dir_dev = NULL;
-	_adapter	*padapter = rtw_netdev_priv(dev);
-	u8 rf_type;
-
-	dir_dev = padapter->dir_dev;
-	padapter->dir_dev = NULL;
-
-	if (dir_dev) {
-
-		remove_proc_entry("write_reg", dir_dev);
-		remove_proc_entry("read_reg", dir_dev);
-		remove_proc_entry("fwstate", dir_dev);
-		remove_proc_entry("sec_info", dir_dev);
-		remove_proc_entry("mlmext_state", dir_dev);
-		remove_proc_entry("qos_option", dir_dev);
-		remove_proc_entry("ht_option", dir_dev);
-		remove_proc_entry("rf_info", dir_dev);
-		remove_proc_entry("ap_info", dir_dev);
-		remove_proc_entry("adapter_state", dir_dev);
-		remove_proc_entry("trx_info", dir_dev);
-
-		remove_proc_entry("mac_reg_dump1", dir_dev);
-		remove_proc_entry("mac_reg_dump2", dir_dev);
-		remove_proc_entry("mac_reg_dump3", dir_dev);
-		remove_proc_entry("bb_reg_dump1", dir_dev);
-		remove_proc_entry("bb_reg_dump2", dir_dev);
-		remove_proc_entry("bb_reg_dump3", dir_dev);
-		remove_proc_entry("rf_reg_dump1", dir_dev);
-		remove_proc_entry("rf_reg_dump2", dir_dev);
-		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	{
-			remove_proc_entry("rf_reg_dump3", dir_dev);
-			remove_proc_entry("rf_reg_dump4", dir_dev);
-		}
-#ifdef CONFIG_AP_MODE
-		remove_proc_entry("all_sta_info", dir_dev);
-#endif
-
-#ifdef DBG_MEMORY_LEAK
-		remove_proc_entry("_malloc_cnt", dir_dev);
-#endif
-
-#ifdef CONFIG_FIND_BEST_CHANNEL
-		remove_proc_entry("best_channel", dir_dev);
-#endif
-		remove_proc_entry("rx_signal", dir_dev);
-
-		remove_proc_entry("cbw40_enable", dir_dev);
-
-		remove_proc_entry("ht_enable", dir_dev);
-
-		remove_proc_entry("ampdu_enable", dir_dev);
-
-		remove_proc_entry("rx_stbc", dir_dev);
-
-		remove_proc_entry("path_rssi", dir_dev);
-
-		remove_proc_entry("vid", dir_dev);
-
-		remove_proc_entry("pid", dir_dev);
-
-		remove_proc_entry("rssi_disp", dir_dev);
-
-#if defined(DBG_CONFIG_ERROR_DETECT)
-		remove_proc_entry("sreset", dir_dev);
-#endif /* DBG_CONFIG_ERROR_DETECT */
-
-#ifdef CONFIG_DM_ADAPTIVITY
-		remove_proc_entry("dm_adaptivity", dir_dev);
-#endif
-
-		remove_proc_entry(dev->name, rtw_proc);
-		dir_dev = NULL;
-
-	}
-	else
-	{
-		return;
-	}
-
-	rtw_proc_cnt--;
-
-	if(rtw_proc_cnt == 0)
-	{
-		if(rtw_proc){
-			remove_proc_entry("ver_info", rtw_proc);
-
-			remove_proc_entry("log_level", rtw_proc);
-			#ifdef DBG_MEM_ALLOC
-			remove_proc_entry("mstat", rtw_proc);
-			#endif /* DBG_MEM_ALLOC */
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-			remove_proc_entry(rtw_proc_name, proc_net);
-#else
-			remove_proc_entry(rtw_proc_name, init_net.proc_net);
-#endif
-			rtw_proc = NULL;
-		}
-	}
-}
-#endif
 
 uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev);
 uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev)
@@ -990,8 +506,66 @@ u16 rtw_recv_select_queue(struct sk_buff *skb)
 
 #endif
 
+static int rtw_ndev_notifier_call(struct notifier_block * nb, unsigned long state, void *ndev)
+{
+	struct net_device *dev = ndev;
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+	if (dev->netdev_ops->ndo_do_ioctl != rtw_ioctl)
+#else
+	if (dev->do_ioctl != rtw_ioctl)
+#endif
+		return NOTIFY_DONE;
+
+	DBG_871X_LEVEL(_drv_info_, FUNC_NDEV_FMT" state:%lu\n", FUNC_NDEV_ARG(dev), state);
+
+	switch (state) {
+	case NETDEV_CHANGENAME:
+		rtw_adapter_proc_replace(dev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block rtw_ndev_notifier = {
+	.notifier_call = rtw_ndev_notifier_call,
+};
+
+int rtw_ndev_notifier_register(void)
+{
+	return register_netdevice_notifier(&rtw_ndev_notifier);
+}
+
+void rtw_ndev_notifier_unregister(void)
+{
+	unregister_netdevice_notifier(&rtw_ndev_notifier);
+}
+
+
+int rtw_ndev_init(struct net_device *dev)
+{
+	_adapter *adapter = rtw_netdev_priv(dev);
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(adapter));
+	strncpy(adapter->old_ifname, dev->name, IFNAMSIZ);
+	rtw_adapter_proc_init(dev);
+
+	return 0;
+}
+
+void rtw_ndev_uninit(struct net_device *dev)
+{
+	_adapter *adapter = rtw_netdev_priv(dev);
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(adapter));
+	rtw_adapter_proc_deinit(dev);
+}
+
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtw_netdev_ops = {
+	.ndo_init = rtw_ndev_init,
+	.ndo_uninit = rtw_ndev_uninit,
 	.ndo_open = netdev_open,
 	.ndo_stop = netdev_close,
 	.ndo_start_xmit = rtw_xmit_entry,
@@ -1037,9 +611,6 @@ int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
 			dev_put(TargetNetdev);
 			unregister_netdev(TargetNetdev);
 
-			if(TargetAdapter->chip_type == padapter->chip_type)
-				rtw_proc_remove_one(TargetNetdev);
-
 			padapter->DriverState = DRIVER_REPLACE_DONGLE;
 		}
 	}
@@ -1084,6 +655,8 @@ struct net_device *rtw_init_netdev(_adapter *old_padapter)
 	DBG_871X("register rtw_netdev_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_ops;
 #else
+	pnetdev->init = rtw_ndev_init;
+	pnetdev->uninit = rtw_ndev_uninit;
 	pnetdev->open = netdev_open;
 	pnetdev->stop = netdev_close;
 	pnetdev->hard_start_xmit = rtw_xmit_entry;
@@ -1131,7 +704,6 @@ void rtw_unregister_netdevs(struct dvobj_priv *dvobj)
 
 		if((padapter->DriverState != DRIVER_DISAPPEAR) && pnetdev) {
 			unregister_netdev(pnetdev); //will call netdev_close()
-			rtw_proc_remove_one(pnetdev);
 		}
 
 		#ifdef CONFIG_IOCTL_CFG80211
@@ -1238,7 +810,6 @@ u8 rtw_init_default_value(_adapter *padapter)
 
 
 	//mlme_priv
-	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
 	pmlmepriv->scan_mode = SCAN_ACTIVE;
 
 	//qos_priv
@@ -1287,6 +858,9 @@ u8 rtw_init_default_value(_adapter *padapter)
 #ifdef CONFIG_P2P
 	padapter->bShowGetP2PState = 1;
 #endif
+
+	padapter->fix_rate = 0xFF;
+
 	return ret;
 }
 
@@ -1331,7 +905,6 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 	padapter->bReadPortCancel = _FALSE;
 	padapter->bWritePortCancel = _FALSE;
 	padapter->bRxRSSIDisplay = 0;
-	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
 
 	pwrctrlpriv->bips_processing = _FALSE;
 	pwrctrlpriv->rf_pwrstate = rf_on;
@@ -1357,6 +930,10 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 	//mlmeextpriv
 	padapter->mlmeextpriv.sitesurvey_res.state= SCAN_DISABLE;
 
+	// cancel sw led timer
+	rtw_hal_sw_led_deinit(padapter);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel DeInitSwLeds! \n"));
+
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
@@ -1457,6 +1034,7 @@ _func_enter_;
 
 	padapter->stapriv.padapter = padapter;
 	padapter->setband = GHZ24_50;
+	padapter->fix_rate = 0xFF;
 	rtw_init_bcmc_stainfo(padapter);
 
 	rtw_init_pwrctrl_priv(padapter);
@@ -1471,6 +1049,9 @@ _func_enter_;
 
 	ret8 = rtw_init_default_value(padapter);
 
+	if (is_primary_adapter(padapter))
+		rtw_odm_init(padapter);
+
 	rtw_hal_dm_init(padapter);
 	rtw_hal_sw_led_init(padapter);
 
@@ -1671,9 +1252,6 @@ int _netdev_vir_if_open(struct net_device *pnetdev)
 			goto _netdev_virtual_iface_open_error;
 		}
 
-		padapter->dir_dev = NULL;
-		rtw_proc_init_one(pnetdev);
-
 #ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
@@ -1734,7 +1312,7 @@ static int netdev_vir_if_close(struct net_device *pnetdev)
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
 #endif
 
 	return 0;
@@ -2049,10 +1627,6 @@ int _netdev_if2_open(struct net_device *pnetdev)
 
 		padapter->hw_init_completed = _TRUE;
 
-		padapter->dir_dev = NULL;
-		rtw_proc_init_one(pnetdev);
-
-
 #ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
@@ -2107,9 +1681,13 @@ static int netdev_if2_close(struct net_device *pnetdev)
 			rtw_netif_stop_queue(pnetdev);
 	}
 
+#ifdef CONFIG_P2P
+	rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+#endif
+
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
 #endif
 
 	return 0;
@@ -2117,12 +1695,14 @@ static int netdev_if2_close(struct net_device *pnetdev)
 
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtw_netdev_if2_ops = {
+	.ndo_init = rtw_ndev_init,
+	.ndo_uninit = rtw_ndev_uninit,
 	.ndo_open = netdev_if2_open,
-        .ndo_stop = netdev_if2_close,
-        .ndo_start_xmit = rtw_xmit_entry,
-        .ndo_set_mac_address = rtw_net_set_mac_address,
-        .ndo_get_stats = rtw_net_get_stats,
-        .ndo_do_ioctl = rtw_ioctl,
+	.ndo_stop = netdev_if2_close,
+	.ndo_start_xmit = rtw_xmit_entry,
+	.ndo_set_mac_address = rtw_net_set_mac_address,
+	.ndo_get_stats = rtw_net_get_stats,
+	.ndo_do_ioctl = rtw_ioctl,
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	.ndo_select_queue	= rtw_select_queue,
 #endif
@@ -2146,6 +1726,8 @@ _adapter *rtw_drv_if2_init(_adapter *primary_padapter, void (*set_intf_ops)(stru
 	DBG_871X("register rtw_netdev_if2_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_if2_ops;
 #else
+	pnetdev->init = rtw_ndev_init;
+	pnetdev->uninit = rtw_ndev_uninit;
 	pnetdev->open = netdev_if2_open;
 	pnetdev->stop = netdev_if2_close;
 #endif
@@ -2485,10 +2067,6 @@ int _netdev_open(struct net_device *pnetdev)
 			padapter->intf_start(padapter);
 		}
 
-#ifndef RTK_DMP_PLATFORM
-		rtw_proc_init_one(pnetdev);
-#endif
-
 #ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
@@ -2616,8 +2194,6 @@ void rtw_ips_pwr_down(_adapter *padapter)
 	padapter->bCardDisableWOHSM = _TRUE;
 	padapter->net_closed = _TRUE;
 
-	rtw_led_control(padapter, LED_CTL_POWER_OFF);
-
 	rtw_ips_dev_unload(padapter);
 	padapter->bCardDisableWOHSM = _FALSE;
 	DBG_871X("<=== rtw_ips_pwr_down..................... in %dms\n", rtw_get_passing_time_ms(start_time));
@@ -2719,7 +2295,7 @@ static int netdev_close(struct net_device *pnetdev)
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
 	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; //set this at the end
 #endif //CONFIG_IOCTL_CFG80211
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/pci_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/pci_intf.c
index 5bf576f1a3e3..01811940d055 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/pci_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/pci_intf.c
@@ -1855,11 +1855,6 @@ static int rtw_drv_init(struct pci_dev *pdev, const struct pci_device_id *did)
 	rtd2885_wlan_netlink_sendMsg("linkup", "8712");
 #endif
 
-#ifdef RTK_DMP_PLATFORM
-	rtw_proc_init_one(if1->pnetdev);
-#endif
-
-
 	/* alloc irq */
 	if (pci_alloc_irq(dvobj) != _SUCCESS)
 		goto free_if2;
@@ -1956,39 +1951,55 @@ _func_exit_;
 	return;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
+extern int console_suspend_enabled;
+#endif
 
 static int __init rtw_drv_entry(void)
 {
 	int ret = 0;
 
-	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_entry\n"));
-	DBG_871X("rtw driver version=%s\n", DRIVERVERSION);
-	DBG_871X("Build at: %s %s\n", __DATE__, __TIME__);
-	pci_drvpriv.drv_registered = _TRUE;
+	DBG_871X_LEVEL(_drv_always_, "module init start\n");
+	dump_drv_version(RTW_DBGDUMP);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)) 
+		//console_suspend_enabled=0;
+#endif
+
+	pci_drvpriv.drv_registered = _TRUE;
 	rtw_suspend_lock_init();
+	rtw_drv_proc_init();
+	rtw_ndev_notifier_register();
 
 	ret = pci_register_driver(&pci_drvpriv.rtw_pci_drv);
-	if (ret) {
-		RT_TRACE(_module_hci_intfs_c_, _drv_err_, (": No device found\n"));
+	if (ret != 0) {
+		pci_drvpriv.drv_registered = _FALSE;
+		rtw_suspend_lock_uninit();
+		rtw_drv_proc_deinit();
+		rtw_ndev_notifier_unregister();
+		goto exit;
 	}
 
+exit:
+	DBG_871X_LEVEL(_drv_always_, "module init ret=%d\n", ret);
 	return ret;
 }
 
 static void __exit rtw_drv_halt(void)
 {
-	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_halt\n"));
-	DBG_871X("+rtw_drv_halt\n");
+	DBG_871X_LEVEL(_drv_always_, "module exit start\n");
 
 	pci_drvpriv.drv_registered = _FALSE;
 
 	pci_unregister_driver(&pci_drvpriv.rtw_pci_drv);
 
 	rtw_suspend_lock_uninit();
-	DBG_871X("-rtw_drv_halt\n");
+	rtw_drv_proc_deinit();
+	rtw_ndev_notifier_unregister();
+
+	DBG_871X_LEVEL(_drv_always_, "module exit success\n");
 
-	rtw_mstat_dump();
+	rtw_mstat_dump(RTW_DBGDUMP);
 }
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/recv_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/recv_linux.c
index 9c92019adeeb..c1f534b68b2e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/recv_linux.c
@@ -307,6 +307,7 @@ _func_enter_;
 
 			if(psta)
 			{
+				int tx_ret;
 				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;			
 
 				//DBG_871X("directly forwarding to the rtw_xmit_entry\n");
@@ -317,8 +318,12 @@ _func_enter_;
 				skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
 #endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
 			
-				_rtw_xmit_entry(skb, pnetdev);
-			
+				tx_ret = _rtw_xmit_entry(skb, pnetdev);
+				if (tx_ret != NETDEV_TX_OK) {
+					padapter->xmitpriv.tx_drop++;
+					rtw_skb_free(skb);
+				}
+
 				if(bmcast)
 					skb = pskb2;
 				else
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_android.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_android.c
index 15e38c902af9..3b3be6017936 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_android.c
@@ -75,6 +75,8 @@ const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
 	"WFD-SET-TCPPORT",
 	"WFD-SET-MAXTPUT",
 	"WFD-SET-DEVTYPE",	
+/*	Private command for	P2P disable*/
+	"P2P_DISABLE"
 };
 
 #ifdef PNO_SUPPORT
@@ -302,7 +304,7 @@ int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK]) + 1;
 
 	#ifdef CONFIG_IOCTL_CFG80211
-	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?_FALSE:_TRUE;
+	adapter_wdev_data(adapter)->block = (*block_value=='0')?_FALSE:_TRUE;
 	#endif
 	
 	return 0;
@@ -418,7 +420,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_ACTIVE);
 #ifdef CONFIG_PLATFORM_MSTAR
 #ifdef CONFIG_IOCTL_CFG80211
-		(wdev_to_priv(net->ieee80211_ptr))->bandroid_scan = _TRUE;	
+		adapter_wdev_data((_adapter *)rtw_netdev_priv(net))->bandroid_scan = _TRUE;
 #endif //CONFIG_IOCTL_CFG80211
 #endif //CONFIG_PLATFORM_MSTAR
 		break;
@@ -584,6 +586,16 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		}
 		break;
 	}
+	case ANDROID_WIFI_CMD_P2P_DISABLE:
+	{
+		struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
+		struct wifidirect_info 	*pwdinfo= &(padapter->wdinfo);
+		u8 channel, ch_offset;
+		u16 bwmode;
+
+		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+		break;
+	}
 #endif
 	default:
 		DBG_871X("Unknown PRIVATE command %s - ignored\n", command);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.c
new file mode 100644
index 000000000000..9693bd8ecf46
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.c
@@ -0,0 +1,735 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <drv_types.h>
+#include "rtw_proc.h"
+
+#ifdef CONFIG_PROC_DEBUG
+
+static struct proc_dir_entry *rtw_proc = NULL;
+
+inline struct proc_dir_entry *get_rtw_drv_proc(void)
+{
+	return rtw_proc;
+}
+
+#define RTW_PROC_NAME DRV_NAME
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+#define file_inode(file) ((file)->f_dentry->d_inode)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
+#define PDE_DATA(inode) PDE((inode))->data
+#define proc_get_parent_data(inode) PDE((inode))->parent->data
+#endif
+
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#define get_proc_net proc_net
+#else
+#define get_proc_net init_net.proc_net
+#endif
+
+inline struct proc_dir_entry *rtw_proc_create_dir(const char *name, struct proc_dir_entry *parent, void *data)
+{
+	struct proc_dir_entry *entry;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+	entry = proc_mkdir_data(name, S_IRUGO|S_IXUGO, parent, data);
+#else
+	//entry = proc_mkdir_mode(name, S_IRUGO|S_IXUGO, parent);
+	entry = proc_mkdir(name, parent);
+	if (entry)
+		entry->data = data;
+#endif
+
+	return entry;
+}
+
+inline struct proc_dir_entry *rtw_proc_create_entry(const char *name, struct proc_dir_entry *parent, 
+	const struct file_operations *fops, void * data)
+{
+	struct proc_dir_entry *entry;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	entry = proc_create_data(name,  S_IFREG|S_IRUGO, parent, fops, data);
+#else
+	entry = create_proc_entry(name, S_IFREG|S_IRUGO, parent);
+	if (entry) {
+		entry->data = data;
+		entry->proc_fops = fops;
+	}
+#endif
+
+	return entry;
+}
+
+static int proc_get_dummy(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static int proc_get_drv_version(struct seq_file *m, void *v)
+{
+	dump_drv_version(m);
+	return 0;
+}
+
+static int proc_get_log_level(struct seq_file *m, void *v)
+{
+	dump_log_level(m);
+	return 0;
+}
+
+static ssize_t proc_set_log_level(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	char tmp[32];
+	int log_level;
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%d ", &log_level);
+
+		if( log_level >= _drv_always_ && log_level <= _drv_debug_ )
+		{
+			GlobalDebugLevel= log_level;
+			printk("%d\n", GlobalDebugLevel);
+		}
+	} else {
+		return -EFAULT;
+	}
+	
+	return count;
+}
+
+#ifdef DBG_MEM_ALLOC
+static int proc_get_mstat(struct seq_file *m, void *v)
+{	
+	rtw_mstat_dump(m);
+	return 0;
+}
+#endif /* DBG_MEM_ALLOC */
+
+
+/*
+* rtw_drv_proc:
+* init/deinit when register/unregister driver
+*/
+const struct rtw_proc_hdl drv_proc_hdls [] = {
+	{"ver_info", proc_get_drv_version, NULL},
+	{"log_level", proc_get_log_level, proc_set_log_level},
+#ifdef DBG_MEM_ALLOC
+	{"mstat", proc_get_mstat, NULL},
+#endif /* DBG_MEM_ALLOC */
+};
+
+const int drv_proc_hdls_num = sizeof(drv_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_drv_proc_open(struct inode *inode, struct file *file)
+{
+	//struct net_device *dev = proc_get_parent_data(inode);
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = drv_proc_hdls+index;
+       return single_open(file, hdl->show, NULL);
+}
+
+static ssize_t rtw_drv_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = drv_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+	
+	if (write)
+		return write(file, buffer, count, pos, NULL);
+
+	return -EROFS;
+}
+
+static const struct file_operations rtw_drv_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_drv_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_drv_proc_write,
+};
+
+int rtw_drv_proc_init(void)
+{
+	int ret = _FAIL;
+	ssize_t i;
+	struct proc_dir_entry *entry = NULL;
+
+	if (rtw_proc != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	rtw_proc = rtw_proc_create_dir(RTW_PROC_NAME, get_proc_net, NULL);
+
+	if (rtw_proc == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	for (i=0;i<drv_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(drv_proc_hdls[i].name, rtw_proc, &rtw_drv_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+void rtw_drv_proc_deinit(void)
+{
+	int i;
+
+	if (rtw_proc == NULL)
+		return;
+
+	for (i=0;i<drv_proc_hdls_num;i++)
+		remove_proc_entry(drv_proc_hdls[i].name, rtw_proc);
+
+	remove_proc_entry(RTW_PROC_NAME, get_proc_net);
+	rtw_proc = NULL;
+}
+
+#ifdef CONFIG_SDIO_HCI
+static int proc_get_sd_f0_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	sd_f0_reg_dump(m, adapter);
+
+	return 0;
+}
+#endif /* CONFIG_SDIO_HCI */
+
+static int proc_get_mac_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	mac_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_bb_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	bb_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rf_reg_dump(m, adapter);
+
+	return 0;
+}
+
+
+int proc_reset_rx_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	char cmd[32];
+	if (buffer && !copy_from_user(cmd, buffer, sizeof(cmd))) {
+		if('0' == cmd[0]){
+			pdbgpriv->dbg_rx_ampdu_drop_count = 0;
+			pdbgpriv->dbg_rx_ampdu_forced_indicate_count = 0;
+			pdbgpriv->dbg_rx_ampdu_loss_count = 0;
+			pdbgpriv->dbg_rx_dup_mgt_frame_drop_count = 0;
+			pdbgpriv->dbg_rx_ampdu_window_shift_cnt = 0;
+		}
+	}
+
+	return count;
+}
+
+
+int proc_get_rx_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	
+	//Counts of packets whose seq_num is less than preorder_ctrl->indicate_seq, Ex delay, retransmission, redundant packets and so on
+	DBG_871X_SEL_NL(m,"Counts of Packets Whose Seq_Num Less Than Reorder Control Seq_Num: %llu\n",(unsigned long long)pdbgpriv->dbg_rx_ampdu_drop_count);
+	//How many times the Rx Reorder Timer is triggered.
+	DBG_871X_SEL_NL(m,"Rx Reorder Time-out Trigger Counts: %llu\n",(unsigned long long)pdbgpriv->dbg_rx_ampdu_forced_indicate_count);
+	//Total counts of packets loss
+	DBG_871X_SEL_NL(m,"Rx Packet Loss Counts: %llu\n",(unsigned long long)pdbgpriv->dbg_rx_ampdu_loss_count);
+	DBG_871X_SEL_NL(m,"Duplicate Management Frame Drop Count: %llu\n",(unsigned long long)pdbgpriv->dbg_rx_dup_mgt_frame_drop_count);
+	DBG_871X_SEL_NL(m,"AMPDU BA window shift Count: %llu\n",(unsigned long long)pdbgpriv->dbg_rx_ampdu_window_shift_cnt);
+	return 0;
+}
+
+/*
+* rtw_adapter_proc:
+* init/deinit when register/unregister net_device
+*/
+const struct rtw_proc_hdl adapter_proc_hdls [] = {
+	{"write_reg", proc_get_dummy, proc_set_write_reg},
+	{"read_reg", proc_get_read_reg, proc_set_read_reg},
+	{"fwstate", proc_get_fwstate, NULL},
+	{"sec_info", proc_get_sec_info, NULL},
+	{"mlmext_state", proc_get_mlmext_state, NULL},
+	{"qos_option", proc_get_qos_option, NULL},
+	{"ht_option", proc_get_ht_option, NULL},
+	{"rf_info", proc_get_rf_info, NULL},
+	{"survey_info", proc_get_survey_info, NULL},	
+	{"ap_info", proc_get_ap_info, NULL},
+	{"adapter_state", proc_get_adapter_state, NULL},
+	{"trx_info", proc_get_trx_info, NULL},
+	{"rate_ctl", proc_get_rate_ctl, proc_set_rate_ctl},
+	{"hw_info", proc_get_hw_status, NULL},
+	{"rx_info", proc_get_rx_info, proc_reset_rx_info},
+	
+#ifdef CONFIG_LAYER2_ROAMING
+	{"roam_flags", proc_get_roam_flags, proc_set_roam_flags},
+	{"roam_param", proc_get_roam_param, proc_set_roam_param},
+	{"roam_tgt_addr", proc_get_dummy, proc_set_roam_tgt_addr},
+#endif /* CONFIG_LAYER2_ROAMING */
+
+	{"mac_reg_dump", proc_get_mac_reg_dump, NULL},
+	{"bb_reg_dump", proc_get_bb_reg_dump, NULL},
+	{"rf_reg_dump", proc_get_rf_reg_dump, NULL},
+
+#ifdef CONFIG_AP_MODE
+	{"all_sta_info", proc_get_all_sta_info, NULL},
+#endif
+
+#ifdef DBG_MEMORY_LEAK
+	{"_malloc_cnt", proc_get_malloc_cnt, NULL},
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+
+	{"best_channel", proc_get_best_channel, proc_set_best_channel},
+#endif
+
+	{"rx_signal", proc_get_rx_signal, proc_set_rx_signal},
+
+	{"ht_enable", proc_get_ht_enable, proc_set_ht_enable},
+	{"cbw40_enable", proc_get_cbw40_enable, proc_set_cbw40_enable},
+	{"ampdu_enable", proc_get_ampdu_enable, proc_set_ampdu_enable},
+	{"rx_stbc", proc_get_rx_stbc, proc_set_rx_stbc},
+
+	{"path_rssi", proc_get_two_path_rssi, NULL},
+	{"rssi_disp", proc_get_rssi_disp, proc_set_rssi_disp},
+
+	{"vid", proc_get_vid, NULL},
+	{"pid", proc_get_pid, NULL},
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+	{"sreset", proc_get_sreset, proc_set_sreset},
+#endif /* DBG_CONFIG_ERROR_DETECT */
+};
+
+const int adapter_proc_hdls_num = sizeof(adapter_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_adapter_proc_open(struct inode *inode, struct file *file)
+{
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = adapter_proc_hdls+index;
+
+	return single_open(file, hdl->show, proc_get_parent_data(inode));
+}
+
+static ssize_t rtw_adapter_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = adapter_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+
+	if (write)
+		return write(file, buffer, count, pos, ((struct seq_file *)file->private_data)->private);
+
+	return -EROFS;
+}
+
+static const struct file_operations rtw_adapter_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_adapter_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_adapter_proc_write,
+};
+
+int proc_get_dm_ability(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_dm_ability_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_dm_ability(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u8 ability;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%hhx", &ability);
+
+		if (num != 1)
+			return count;
+
+		rtw_dm_ability_set(adapter, ability);
+	}
+
+	return count;
+}
+
+int proc_get_odm_dbg_comp(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_dbg_comp_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_dbg_comp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u64 dbg_comp;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%llx", &dbg_comp);
+
+		if (num != 1)
+			return count;
+
+		rtw_odm_dbg_comp_set(adapter, dbg_comp);
+	}
+
+	return count;
+}
+
+int proc_get_odm_dbg_level(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_dbg_level_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_dbg_level(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u32 dbg_level;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%u", &dbg_level);
+
+		if (num != 1)
+			return count;
+
+		rtw_odm_dbg_level_set(adapter, dbg_level);
+	}
+
+	return count;
+}
+
+#ifdef CONFIG_ODM_ADAPTIVITY
+int proc_get_odm_adaptivity(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_adaptivity_parm_msg(m, padapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 TH_L2H_ini;
+	s8 TH_EDCCA_HL_diff;
+	u32 IGI_Base;
+	int ForceEDCCA;
+	u8 AdapEn_RSSI;
+	u8 IGI_LowerBound;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%x %hhd %x %d %hhu %hhu",
+			&TH_L2H_ini, &TH_EDCCA_HL_diff, &IGI_Base, &ForceEDCCA, &AdapEn_RSSI, &IGI_LowerBound);
+
+		if (num != 6)
+			return count;
+
+		rtw_odm_adaptivity_parm_set(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff, (s8)IGI_Base, (bool)ForceEDCCA, AdapEn_RSSI, IGI_LowerBound);
+	}
+	
+	return count;
+}
+#endif /* CONFIG_ODM_ADAPTIVITY */
+
+/*
+* rtw_dm_proc:
+* init/deinit when register/unregister net_device, along with rtw_adapter_proc
+*/
+const struct rtw_proc_hdl dm_proc_hdls [] = {
+	{"dbg_comp", proc_get_odm_dbg_comp, proc_set_odm_dbg_comp},
+	{"dbg_level", proc_get_odm_dbg_level, proc_set_odm_dbg_level},
+	{"ability", proc_get_dm_ability, proc_set_dm_ability},
+#ifdef CONFIG_ODM_ADAPTIVITY
+	{"adaptivity", proc_get_odm_adaptivity, proc_set_odm_adaptivity},
+#endif
+};
+
+const int dm_proc_hdls_num = sizeof(dm_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_dm_proc_open(struct inode *inode, struct file *file)
+{
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = dm_proc_hdls+index;
+
+	return single_open(file, hdl->show, proc_get_parent_data(inode));
+}
+
+static ssize_t rtw_dm_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = dm_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+	
+	if (write)
+		return write(file, buffer, count, pos, ((struct seq_file *)file->private_data)->private);
+
+	return -EROFS;
+}
+
+static const struct file_operations rtw_dm_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_dm_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_dm_proc_write,
+};
+
+struct proc_dir_entry *rtw_dm_proc_init(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_dm = NULL;
+	struct proc_dir_entry *entry = NULL;
+	_adapter	*adapter = rtw_netdev_priv(dev);
+	ssize_t i;
+
+	if (adapter->dir_dev == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	if (adapter->dir_dm != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	dir_dm = rtw_proc_create_dir("dm", adapter->dir_dev, dev);
+	if (dir_dm == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	adapter->dir_dm = dir_dm;
+
+	for (i=0;i<dm_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(dm_proc_hdls[i].name, dir_dm, &rtw_dm_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+exit:
+	return dir_dm;
+}
+
+void rtw_dm_proc_deinit(_adapter	*adapter)
+{
+	struct proc_dir_entry *dir_dm = NULL;
+	int i;
+
+	dir_dm = adapter->dir_dm;
+
+	if (dir_dm == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<dm_proc_hdls_num;i++)
+		remove_proc_entry(dm_proc_hdls[i].name, dir_dm);
+
+	remove_proc_entry("dm", adapter->dir_dev);
+
+	adapter->dir_dm = NULL;
+}
+
+struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	struct proc_dir_entry *entry = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	u8 rf_type;
+	ssize_t i;
+
+	if (drv_proc == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	if (adapter->dir_dev != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	dir_dev = rtw_proc_create_dir(dev->name, drv_proc, dev);
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	adapter->dir_dev = dir_dev;
+
+	for (i=0;i<adapter_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(adapter_proc_hdls[i].name, dir_dev, &rtw_adapter_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+	rtw_dm_proc_init(dev);
+
+exit:
+	return dir_dev;
+}
+
+void rtw_adapter_proc_deinit(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	int i;
+
+	dir_dev = adapter->dir_dev;
+
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<adapter_proc_hdls_num;i++)
+		remove_proc_entry(adapter_proc_hdls[i].name, dir_dev);
+
+	rtw_dm_proc_deinit(adapter);
+
+	remove_proc_entry(dev->name, drv_proc);
+
+	adapter->dir_dev = NULL;
+}
+
+void rtw_adapter_proc_replace(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	int i;
+
+	dir_dev = adapter->dir_dev;
+
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<adapter_proc_hdls_num;i++)
+		remove_proc_entry(adapter_proc_hdls[i].name, dir_dev);
+
+	rtw_dm_proc_deinit(adapter);
+
+	remove_proc_entry(adapter->old_ifname, drv_proc);
+
+	adapter->dir_dev = NULL;
+
+	rtw_adapter_proc_init(dev);
+
+}
+
+#endif /* CONFIG_PROC_DEBUG */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.h
new file mode 100644
index 000000000000..d45a28e2bb46
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/rtw_proc.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_PROC_H__
+#define __RTW_PROC_H__
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+struct rtw_proc_hdl {
+	char *name;
+	int (*show)(struct seq_file *, void *);
+	ssize_t (*write)(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+};
+
+#ifdef CONFIG_PROC_DEBUG
+
+struct proc_dir_entry *get_rtw_drv_proc(void);
+int rtw_drv_proc_init(void);
+void rtw_drv_proc_deinit(void);
+struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev);
+void rtw_adapter_proc_deinit(struct net_device *dev);
+void rtw_adapter_proc_replace(struct net_device *dev);
+
+#else //!CONFIG_PROC_DEBUG
+
+struct proc_dir_entry *get_rtw_drv_proc(void) {return NULL;}
+int rtw_drv_proc_init(void) {return 0;}
+void rtw_drv_proc_deinit(void) {}
+struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev){return NULL;}
+void rtw_adapter_proc_deinit(struct net_device *dev){}
+void rtw_adapter_proc_replace(struct net_device *dev){}
+
+#endif //!CONFIG_PROC_DEBUG
+
+#endif //__RTW_PROC_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_intf.c
index 2605b151c074..240b6bfa30d5 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_intf.c
@@ -898,11 +898,17 @@ static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
 		rtw_netif_stop_queue(pnetdev);
 	}
 #ifdef CONFIG_WOWLAN
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
+		pwrpriv->wowlan_mode = _TRUE;
+	else
+		pwrpriv->wowlan_mode = _FALSE;
+
 	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==_TRUE&&padapter->pwrctrlpriv.wowlan_mode==_TRUE){
 		u8 ps_mode=PS_MODE_MIN;
 		//set H2C command
 		poidparam.subcode=WOWLAN_ENABLE;
 		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
+		rtw_hal_set_hwreg(padapter, HW_VAR_ENC_BMC_ENABLE, 0);
 		//rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, &ps_mode);
 		//rtw_set_rpwm(padapter, PS_STATE_S2);
 	}
@@ -913,18 +919,20 @@ static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
 		rtw_disassoc_cmd(padapter, 0, _FALSE);
 	}
 
-#ifdef CONFIG_LAYER2_ROAMING_RESUME
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) )
-	{
-		//printk("%s:%d assoc_ssid:%s\n", __FUNCTION__, __LINE__, pmlmepriv->assoc_ssid.Ssid);
-		DBG_871X("%s:%d %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__, __LINE__,
-				pmlmepriv->cur_network.network.Ssid.Ssid,
-				MAC_ARG(pmlmepriv->cur_network.network.MacAddress),
-				pmlmepriv->cur_network.network.Ssid.SsidLength,
-				pmlmepriv->assoc_ssid.SsidLength);
-		rtw_set_roaming(padapter, 1);
+	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+			&& check_fwstate(pmlmepriv, _FW_LINKED) )
+		{
+			//printk("%s:%d assoc_ssid:%s\n", __FUNCTION__, __LINE__, pmlmepriv->assoc_ssid.Ssid);
+			DBG_871X("%s:%d %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__, __LINE__,
+					pmlmepriv->cur_network.network.Ssid.Ssid,
+					MAC_ARG(pmlmepriv->cur_network.network.MacAddress),
+					pmlmepriv->cur_network.network.Ssid.SsidLength,
+					pmlmepriv->assoc_ssid.SsidLength);
+			rtw_set_to_roam(padapter, 1);
 		}
-#endif
+	}
+
 	//s2-2.  indicate disconnect to os
 	rtw_indicate_disconnect(padapter);
 	//s2-3.
@@ -993,6 +1001,9 @@ int rtw_resume_process(_adapter *padapter)
 	struct pwrctrl_priv *pwrpriv;
 	int ret = -1;
 	u32 start_time = rtw_get_current_time();
+#ifdef CONFIG_WOWLAN
+	struct wowlan_ioctl_param poidparam;
+#endif // CONFIG_WOWLAN
 	_func_enter_;
 
 	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
@@ -1007,7 +1018,14 @@ int rtw_resume_process(_adapter *padapter)
 	_enter_pwrlock(&pwrpriv->lock);
 	rtw_reset_drv_sw(padapter);
 	pwrpriv->bkeepfwalive = _FALSE;
-
+#ifdef CONFIG_WOWLAN
+	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==_TRUE&&padapter->pwrctrlpriv.wowlan_mode==_TRUE){
+		//set H2C command
+		poidparam.subcode=WOWLAN_DISABLE;
+		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
+		rtw_hal_set_hwreg(padapter, HW_VAR_ENC_BMC_DISABLE, 0);
+	}
+#endif //CONFIG_WOWLAN
 	DBG_871X("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
 	if(pm_netdev_open(pnetdev,_TRUE) != 0) {
 		_exit_pwrlock(&pwrpriv->lock);
@@ -1043,9 +1061,8 @@ int rtw_resume_process(_adapter *padapter)
 		rtw_signal_process(padapter->pid[1], SIGUSR2);
 	}
 
-	#ifdef CONFIG_LAYER2_ROAMING_RESUME
-	rtw_roaming(padapter, NULL);
-	#endif
+	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME))
+		rtw_roaming(padapter, NULL);
 
 	ret = 0;
 exit:
@@ -1443,10 +1460,6 @@ static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device
 	rtd2885_wlan_netlink_sendMsg("linkup", "8712");
 #endif
 
-#ifdef RTK_DMP_PLATFORM
-	rtw_proc_init_one(if1->pnetdev);
-#endif
-
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_drv - drv_init, success!\n"));
 
 	status = _SUCCESS;
@@ -1537,16 +1550,22 @@ extern int console_suspend_enabled;
 
 static int rtw_drv_entry(void)
 {
+	int ret = 0;
+
+	DBG_871X_LEVEL(_drv_always_, "module init start\n");
+	dump_drv_version(RTW_DBGDUMP);
+
 #ifdef CONFIG_PLATFORM_RTK_DMP
-	u32 tmp;
-	tmp=readl((volatile unsigned int*)0xb801a608);
-	tmp &= 0xffffff00;
-	tmp |= 0x55;
-	writel(tmp,(volatile unsigned int*)0xb801a608);//write dummy register for 1055
+	{
+		u32 tmp;
+		tmp=readl((volatile unsigned int*)0xb801a608);
+		tmp &= 0xffffff00;
+		tmp |= 0x55;
+		writel(tmp,(volatile unsigned int*)0xb801a608);//write dummy register for 1055
+	}
 #endif
+
 #ifdef CONFIG_PLATFORM_ARM_SUNxI
-#ifndef CONFIG_RTL8723A
-	int ret = 0;
 	/* ----------get usb_wifi_usbc_num------------- */
 	ret = script_parser_fetch("usb_wifi_para", "usb_wifi_usbc_num", (int *)&usb_wifi_host, 64);
 	if(ret != 0){
@@ -1556,7 +1575,6 @@ static int rtw_drv_entry(void)
 	}
 	printk("sw_usb_enable_hcd: usbc_num = %d\n", usb_wifi_host);
 	sw_usb_enable_hcd(usb_wifi_host);
-#endif //CONFIG_RTL8723A
 #endif //CONFIG_PLATFORM_ARM_SUNxI
 
 #ifdef CONFIG_PLATFORM_ARM_SUN6I
@@ -1574,25 +1592,33 @@ static int rtw_drv_entry(void)
 	sw_usb_enable_hcd(item.val);
 #endif //CONFIG_PLATFORM_ARM_SUN6I
 
-	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_entry\n"));
-
-	DBG_871X(DRV_NAME " driver version=%s\n", DRIVERVERSION);
-	DBG_871X("build time: %s %s\n", __DATE__, __TIME__);
-
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 	//console_suspend_enabled=0;
 #endif
 
+	usb_drv->drv_registered = _TRUE;
 	rtw_suspend_lock_init();
+	rtw_drv_proc_init();
+	rtw_ndev_notifier_register();
 
-	usb_drv->drv_registered = _TRUE;
-	return usb_register(&usb_drv->usbdrv);
+	ret = usb_register(&usb_drv->usbdrv);
+
+	if (ret != 0) {
+		usb_drv->drv_registered = _FALSE;
+		rtw_suspend_lock_uninit();
+		rtw_drv_proc_deinit();
+		rtw_ndev_notifier_unregister();
+		goto exit;
+	}
+
+exit:
+	DBG_871X_LEVEL(_drv_always_, "module init ret=%d\n", ret);
+	return ret;
 }
 
 static void rtw_drv_halt(void)
 {
-	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_halt\n"));
-	DBG_871X("+rtw_drv_halt\n");
+	DBG_871X_LEVEL(_drv_always_, "module exit start\n");
 
 	usb_drv->drv_registered = _FALSE;
 	usb_deregister(&usb_drv->usbdrv);
@@ -1609,38 +1635,31 @@ static void rtw_drv_halt(void)
 #endif
 
 	rtw_suspend_lock_uninit();
-	DBG_871X("-rtw_drv_halt\n");
+	rtw_drv_proc_deinit();
+	rtw_ndev_notifier_unregister();
 
-	rtw_mstat_dump();
+	DBG_871X_LEVEL(_drv_always_, "module exit success\n");
+
+	rtw_mstat_dump(RTW_DBGDUMP);
 }
 
+
 #include "wifi_version.h"
-extern int wifi_activate_usb(void);
-extern int wifi_deactivate_usb(void);
+#include <linux/rfkill-wlan.h>
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-static int __init rockchip_wifi_init_module(void)
-#else
-int rockchip_wifi_init_module(void)
-#endif
+int rockchip_wifi_init_module_rtkwifi(void)
 {
     printk("\n");
     printk("=======================================================\n");
     printk("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
     printk("=======================================================\n");
     printk("Realtek 8192DU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
-    wifi_deactivate_usb();
-    msleep(100);
-    wifi_activate_usb();
+    rockchip_wifi_power(1);
 
     return rtw_drv_entry();
 }
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-static void __exit rockchip_wifi_exit_module(void)
-#else
-void rockchip_wifi_exit_module(void)
-#endif
+void rockchip_wifi_exit_module_rtkwifi(void)
 {
     printk("\n");
     printk("=======================================================\n");
@@ -1648,16 +1667,11 @@ void rockchip_wifi_exit_module(void)
     printk("=======================================================\n");
     printk("Realtek 8192DU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
     rtw_drv_halt();
-    wifi_deactivate_usb();
+    rockchip_wifi_power(0);
 }
 
-#ifdef CONFIG_RK_CHECK_UACCESS
-late_initcall(rockchip_wifi_init_module);
-module_exit(rockchip_wifi_exit_module);
-#else
-EXPORT_SYMBOL(rockchip_wifi_init_module);
-EXPORT_SYMBOL(rockchip_wifi_exit_module);
-#endif
+EXPORT_SYMBOL(rockchip_wifi_init_module_rtkwifi);
+EXPORT_SYMBOL(rockchip_wifi_exit_module_rtkwifi);
 //module_init(rtw_drv_entry);
 //module_exit(rtw_drv_halt);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_ops_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_ops_linux.c
index 906cc1ab2e2c..ed3b90e88c41 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_ops_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/usb_ops_linux.c
@@ -563,9 +563,15 @@ _func_enter_;
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	purb->transfer_dma = pxmitbuf->dma_transfer_addr;
 	purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-	purb->transfer_flags |= URB_ZERO_PACKET;
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
-              			
+
+	purb->transfer_flags |= URB_ZERO_PACKET;
+#ifdef USB_PACKET_OFFSET_SZ
+#if (USB_PACKET_OFFSET_SZ == 0)
+	purb->transfer_flags |= URB_ZERO_PACKET;
+#endif
+#endif
+
 #if 0
 	if (bwritezero)
         {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_regd.c
new file mode 100644
index 000000000000..e7f8d534f954
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_regd.c
@@ -0,0 +1,547 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2010  Realtek Corporation.
+ *
+ *****************************************************************************/
+
+#include <drv_types.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#include <rtw_wifi_regd.h>
+
+static struct country_code_to_enum_rd allCountries[] = {
+	{COUNTRY_CODE_USER, "RD"},
+};
+
+/* 
+ * REG_RULE(freq start, freq end, bandwidth, max gain, eirp, reg_flags)
+ */
+
+/*
+ *Only these channels all allow active
+ *scan on all world regulatory domains
+ */
+
+/* 2G chan 01 - chan 11 */
+#define RTW_2GHZ_CH01_11	\
+	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+
+/*
+ *We enable active scan on these a case
+ *by case basis by regulatory domain
+ */
+
+/* 2G chan 12 - chan 13, PASSIV SCAN */
+#define RTW_2GHZ_CH12_13	\
+	REG_RULE(2467-10, 2472+10, 40, 0, 20,	\
+	NL80211_RRF_PASSIVE_SCAN)
+
+/* 2G chan 14, PASSIVS SCAN, NO OFDM (B only) */
+#define RTW_2GHZ_CH14	\
+	REG_RULE(2484-10, 2484+10, 40, 0, 20,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+
+/* 5G chan 36 - chan 64 */
+#define RTW_5GHZ_5150_5350	\
+	REG_RULE(5150-10, 5350+10, 40, 0, 30,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 100 - chan 165 */
+#define RTW_5GHZ_5470_5850	\
+	REG_RULE(5470-10, 5850+10, 40, 0, 30, \
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 149 - chan 165 */
+#define RTW_5GHZ_5725_5850	\
+	REG_RULE(5725-10, 5850+10, 40, 0, 30, \
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 36 - chan 165 */
+#define RTW_5GHZ_5150_5850	\
+	REG_RULE(5150-10, 5850+10, 40, 0, 30,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+static const struct ieee80211_regdomain rtw_regdom_rd = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_5GHZ_5150_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_11 = {
+	.n_reg_rules = 1,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_12_13 = {
+	.n_reg_rules = 2,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_no_midband = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_5GHZ_5150_5350,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_60_64 = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_14_60_64 = {
+	.n_reg_rules = 4,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_2GHZ_CH14,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_14 = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_2GHZ_CH14,
+		      }
+};
+
+#if 0
+static struct rtw_regulatory *rtw_regd;
+#endif
+
+static bool _rtw_is_radar_freq(u16 center_freq)
+{
+	return (center_freq >= 5260 && center_freq <= 5700);
+}
+
+#if 0 // not_yet
+static void _rtw_reg_apply_beaconing_flags(struct wiphy *wiphy,
+					   enum nl80211_reg_initiator initiator)
+{
+	enum ieee80211_band band;
+	struct ieee80211_supported_band *sband;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+	u32 bandwidth = 0;
+	int r;
+
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+
+		if (!wiphy->bands[band])
+			continue;
+
+		sband = wiphy->bands[band];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+			if (_rtw_is_radar_freq(ch->center_freq) ||
+			    (ch->flags & IEEE80211_CHAN_RADAR))
+				continue;
+			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+				r = freq_reg_info(wiphy, ch->center_freq,
+						  bandwidth, &reg_rule);
+				if (r)
+					continue;
+
+				/*
+				 *If 11d had a rule for this channel ensure
+				 *we enable adhoc/beaconing if it allows us to
+				 *use it. Note that we would have disabled it
+				 *by applying our static world regdomain by
+				 *default during init, prior to calling our
+				 *regulatory_hint().
+				 */
+
+				if (!(reg_rule->flags & NL80211_RRF_NO_IBSS))
+					ch->flags &= ~IEEE80211_CHAN_NO_IBSS;
+				if (!
+				    (reg_rule->flags &
+				     NL80211_RRF_PASSIVE_SCAN))
+					ch->flags &=
+					    ~IEEE80211_CHAN_PASSIVE_SCAN;
+			} else {
+				if (ch->beacon_found)
+					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
+						       IEEE80211_CHAN_PASSIVE_SCAN);
+			}
+		}
+	}
+}
+
+/* Allows active scan scan on Ch 12 and 13 */
+static void _rtw_reg_apply_active_scan_flags(struct wiphy *wiphy,
+					     enum nl80211_reg_initiator
+					     initiator)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	const struct ieee80211_reg_rule *reg_rule;
+	u32 bandwidth = 0;
+	int r;
+
+	if (!wiphy->bands[IEEE80211_BAND_2GHZ])
+		return;
+	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+
+	/*
+	 * If no country IE has been received always enable active scan
+	 * on these channels. This is only done for specific regulatory SKUs
+	 */
+	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+		ch = &sband->channels[11];	/* CH 12 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		ch = &sband->channels[12];	/* CH 13 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		return;
+	}
+
+	/*
+	 * If a country IE has been received check its rule for this
+	 * channel first before enabling active scan. The passive scan
+	 * would have been enforced by the initial processing of our
+	 * custom regulatory domain.
+	 */
+
+	ch = &sband->channels[11];	/* CH 12 */
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+
+	ch = &sband->channels[12];	/* CH 13 */
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+}
+#endif
+
+/*
+ * Always apply Radar/DFS rules on
+ * freq range 5260 MHz - 5700 MHz
+ */
+static void _rtw_reg_apply_radar_flags(struct wiphy *wiphy)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+
+	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
+		return;
+
+	sband = wiphy->bands[IEEE80211_BAND_5GHZ];
+
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+		if (!_rtw_is_radar_freq(ch->center_freq))
+			continue;
+#ifdef CONFIG_DFS
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
+			ch->flags |= IEEE80211_CHAN_RADAR |
+			    IEEE80211_CHAN_NO_IBSS;
+#endif
+
+#if 0
+		/*
+		 * We always enable radar detection/DFS on this
+		 * frequency range. Additionally we also apply on
+		 * this frequency range:
+		 * - If STA mode does not yet have DFS supports disable
+		 *  active scanning
+		 * - If adhoc mode does not support DFS yet then disable
+		 *  adhoc in the frequency.
+		 * - If AP mode does not yet support radar detection/DFS
+		 *  do not allow AP mode
+		 */
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
+			ch->flags |= IEEE80211_CHAN_RADAR |
+			    IEEE80211_CHAN_NO_IBSS |
+			    IEEE80211_CHAN_PASSIVE_SCAN;
+#endif
+	}
+}
+
+static int rtw_ieee80211_channel_to_frequency(int chan, int band)
+{
+	/* see 802.11 17.3.8.3.2 and Annex J
+	 * there are overlapping channel numbers in 5GHz and 2GHz bands */
+
+	if (band == IEEE80211_BAND_5GHZ) {
+		if (chan >= 182 && chan <= 196)
+			return 4000 + chan * 5;
+		else
+			return 5000 + chan * 5;
+	} else {		/* IEEE80211_BAND_2GHZ */
+		if (chan == 14)
+			return 2484;
+		else if (chan < 14)
+			return 2407 + chan * 5;
+		else
+			return 0;	/* not supported */
+	}
+}
+
+static void _rtw_reg_apply_flags(struct wiphy *wiphy)
+{
+#if 1				// by channel plan
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	u8 channel_plan = padapter->mlmepriv.ChannelPlan;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	RT_CHANNEL_INFO *channel_set = pmlmeext->channel_set;
+	u8 max_chan_nums = pmlmeext->max_chan_nums;
+
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i, j;
+	u16 channel;
+	u32 freq;
+
+	// all channels disable
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
+		sband = wiphy->bands[i];
+
+		if (sband) {
+			for (j = 0; j < sband->n_channels; j++) {
+				ch = &sband->channels[j];
+
+				if (ch)
+					ch->flags = IEEE80211_CHAN_DISABLED;
+			}
+		}
+	}
+
+	// channels apply by channel plans.
+	for (i = 0; i < max_chan_nums; i++) {
+		channel = channel_set[i].ChannelNum;
+		if (channel <= 14)
+			freq =
+			    rtw_ieee80211_channel_to_frequency(channel,
+							       IEEE80211_BAND_2GHZ);
+		else
+			freq =
+			    rtw_ieee80211_channel_to_frequency(channel,
+							       IEEE80211_BAND_5GHZ);
+
+		ch = ieee80211_get_channel(wiphy, freq);
+		if (ch) {
+			if (channel_set[i].ScanType == SCAN_PASSIVE)
+				ch->flags = IEEE80211_CHAN_PASSIVE_SCAN;
+			else
+				ch->flags = 0;
+		}
+	}
+
+#else
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i, j;
+	u16 channels[37] =
+	    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 36, 40, 44, 48, 52, 56,
+		60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
+		149, 153,
+		157, 161, 165
+	};
+	u16 channel;
+	u32 freq;
+
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
+		sband = wiphy->bands[i];
+
+		if (sband)
+			for (j = 0; j < sband->n_channels; j++) {
+				ch = &sband->channels[j];
+
+				if (ch)
+					ch->flags = IEEE80211_CHAN_DISABLED;
+			}
+	}
+
+	for (i = 0; i < 37; i++) {
+		channel = channels[i];
+		if (channel <= 14)
+			freq =
+			    rtw_ieee80211_channel_to_frequency(channel,
+							       IEEE80211_BAND_2GHZ);
+		else
+			freq =
+			    rtw_ieee80211_channel_to_frequency(channel,
+							       IEEE80211_BAND_5GHZ);
+
+		ch = ieee80211_get_channel(wiphy, freq);
+		if (ch) {
+			if (channel <= 11)
+				ch->flags = 0;
+			else
+				ch->flags = 0;	//IEEE80211_CHAN_PASSIVE_SCAN;
+		}
+		//printk("%s: freq %d(%d) flag 0x%02X \n", __func__, freq, channel, ch->flags);
+	}
+#endif
+}
+
+static void _rtw_reg_apply_world_flags(struct wiphy *wiphy,
+				       enum nl80211_reg_initiator initiator,
+				       struct rtw_regulatory *reg)
+{
+	//_rtw_reg_apply_beaconing_flags(wiphy, initiator);
+	//_rtw_reg_apply_active_scan_flags(wiphy, initiator);
+	return;
+}
+
+static int _rtw_reg_notifier_apply(struct wiphy *wiphy,
+				   struct regulatory_request *request,
+				   struct rtw_regulatory *reg)
+{
+
+	/* Hard code flags */
+	_rtw_reg_apply_flags(wiphy);
+
+	/* We always apply this */
+	_rtw_reg_apply_radar_flags(wiphy);
+
+	switch (request->initiator) {
+	case NL80211_REGDOM_SET_BY_DRIVER:
+		DBG_8192C("%s: %s\n", __func__, "NL80211_REGDOM_SET_BY_DRIVER");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_CORE:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_CORE to DRV");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_USER:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_USER to DRV");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_COUNTRY_IE");
+		_rtw_reg_apply_world_flags(wiphy, request->initiator, reg);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct ieee80211_regdomain *_rtw_regdomain_select(struct
+							       rtw_regulatory
+							       *reg)
+{
+#if 0
+	switch (reg->country_code) {
+	case COUNTRY_CODE_USER:
+	default:
+		return &rtw_regdom_rd;
+	}
+#else
+	return &rtw_regdom_rd;
+#endif
+}
+
+static int _rtw_regd_init_wiphy(struct rtw_regulatory *reg,
+				struct wiphy *wiphy,
+				void (*reg_notifier) (struct wiphy * wiphy,
+						     struct regulatory_request *
+						     request))
+{
+	const struct ieee80211_regdomain *regd;
+
+	wiphy->reg_notifier = reg_notifier;
+
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
+	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
+
+	regd = _rtw_regdomain_select(reg);
+	wiphy_apply_custom_regulatory(wiphy, regd);
+
+	/* Hard code flags */
+	_rtw_reg_apply_flags(wiphy);
+	_rtw_reg_apply_radar_flags(wiphy);
+	_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
+	return 0;
+}
+
+static struct country_code_to_enum_rd *_rtw_regd_find_country(u16 countrycode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
+		if (allCountries[i].countrycode == countrycode)
+			return &allCountries[i];
+	}
+	return NULL;
+}
+
+int rtw_regd_init(_adapter * padapter,
+		  void (*reg_notifier) (struct wiphy * wiphy,
+				       struct regulatory_request * request))
+{
+	//struct registry_priv  *registrypriv = &padapter->registrypriv;
+	struct wiphy *wiphy = padapter->rtw_wdev->wiphy;
+
+#if 0
+	if (rtw_regd == NULL) {
+		rtw_regd = (struct rtw_regulatory *)
+		    rtw_malloc(sizeof(struct rtw_regulatory));
+
+		rtw_regd->alpha2[0] = '9';
+		rtw_regd->alpha2[1] = '9';
+
+		rtw_regd->country_code = COUNTRY_CODE_USER;
+	}
+
+	DBG_8192C("%s: Country alpha2 being used: %c%c\n",
+		  __func__, rtw_regd->alpha2[0], rtw_regd->alpha2[1]);
+#endif
+
+	_rtw_regd_init_wiphy(NULL, wiphy, reg_notifier);
+
+	return 0;
+}
+
+void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+{
+	struct rtw_regulatory *reg = NULL;
+
+	DBG_8192C("%s\n", __func__);
+
+	_rtw_reg_notifier_apply(wiphy, request, reg);
+}
+#endif //CONFIG_IOCTL_CFG80211
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_version.h b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_version.h
index 42ef54a1d538..b09fa9d3de1c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/wifi_version.h
@@ -7,7 +7,7 @@
 /*
  * Broadcom BCM4319 driver version.
  */
-#define RTL8192_DRV_VERSION "3.00.WFD"
+#define RTL8192_DRV_VERSION "3.10.WFD"
 
 #endif /* WIFI_VERSION_H */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/xmit_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/xmit_linux.c
index 9105e293eb3c..d6fb21537ce2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/xmit_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/linux/xmit_linux.c
@@ -409,13 +409,20 @@ _func_enter_;
 
 _func_exit_;
 
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 {
+	int ret;
+
 	if (pkt)
 		rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, pkt->truesize);
-	return _rtw_xmit_entry(pkt, pnetdev);
+
+	ret = _rtw_xmit_entry(pkt, pnetdev);
+	if (ret != NETDEV_TX_OK)
+		rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_FREE, pkt->truesize);
+
+	return ret;
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/osdep_service.c b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/osdep_service.c
index e73a068e441a..769e3707d9a9 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8192du/os_dep/osdep_service.c
@@ -395,7 +395,9 @@ struct rtw_mem_stat {
 };
 
 struct rtw_mem_stat rtw_mem_type_stat[mstat_tf_idx(MSTAT_TYPE_MAX)];
+#ifdef RTW_MEM_FUNC_STAT
 struct rtw_mem_stat rtw_mem_func_stat[mstat_ff_idx(MSTAT_FUNC_MAX)];
+#endif
 
 char *MSTAT_TYPE_str[] = {
 	"VIR",
@@ -404,6 +406,7 @@ char *MSTAT_TYPE_str[] = {
 	"USB",
 };
 
+#ifdef RTW_MEM_FUNC_STAT
 char *MSTAT_FUNC_str[] = {
 	"UNSP",
 	"IO",
@@ -412,13 +415,15 @@ char *MSTAT_FUNC_str[] = {
 	"TX",
 	"RX",
 };
+#endif
 
-int _rtw_mstat_dump(char *buf, int len)
+void rtw_mstat_dump(void *sel)
 {
-	int cnt = 0;
 	int i;
 	int value_t[4][mstat_tf_idx(MSTAT_TYPE_MAX)];
+#ifdef RTW_MEM_FUNC_STAT
 	int value_f[4][mstat_ff_idx(MSTAT_FUNC_MAX)];
+#endif
 	
 	int vir_alloc, vir_peak, vir_alloc_err, phy_alloc, phy_peak, phy_alloc_err;
 	int tx_alloc, tx_peak, tx_alloc_err, rx_alloc, rx_peak, rx_alloc_err;
@@ -430,7 +435,7 @@ int _rtw_mstat_dump(char *buf, int len)
 		value_t[3][i] = ATOMIC_READ(&(rtw_mem_type_stat[i].alloc_err_cnt));
 	}
 
-	#if 0
+	#ifdef RTW_MEM_FUNC_STAT
 	for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
 		value_f[0][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].alloc));
 		value_f[1][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].peak));
@@ -439,28 +444,18 @@ int _rtw_mstat_dump(char *buf, int len)
 	}
 	#endif
 
-	cnt += snprintf(buf+cnt, len-cnt, "===================== MSTAT =====================\n");
-	cnt += snprintf(buf+cnt, len-cnt, "%4s %10s %10s %10s %10s\n", "TAG", "alloc", "peak", "aloc_cnt", "err_cnt");
-	cnt += snprintf(buf+cnt, len-cnt, "-------------------------------------------------\n");
+	DBG_871X_SEL_NL(sel, "===================== MSTAT =====================\n");
+	DBG_871X_SEL_NL(sel, "%4s %10s %10s %10s %10s\n", "TAG", "alloc", "peak", "aloc_cnt", "err_cnt");
+	DBG_871X_SEL_NL(sel, "-------------------------------------------------\n");
 	for(i=0;i<mstat_tf_idx(MSTAT_TYPE_MAX);i++) {
-		cnt += snprintf(buf+cnt, len-cnt, "%4s %10d %10d %10d %10d\n", MSTAT_TYPE_str[i], value_t[0][i], value_t[1][i], value_t[2][i], value_t[3][i]);
+		DBG_871X_SEL_NL(sel, "%4s %10d %10d %10d %10d\n", MSTAT_TYPE_str[i], value_t[0][i], value_t[1][i], value_t[2][i], value_t[3][i]);
 	}
-	#if 0
-	cnt += snprintf(buf+cnt, len-cnt, "-------------------------------------------------\n");
+	#ifdef RTW_MEM_FUNC_STAT
+	DBG_871X_SEL_NL(sel, "-------------------------------------------------\n");
 	for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
-		cnt += snprintf(buf+cnt, len-cnt, "%4s %10d %10d %10d %10d\n", MSTAT_FUNC_str[i], value_f[0][i], value_f[1][i], value_f[2][i], value_f[3][i]);
+		DBG_871X_SEL_NL(sel, "%4s %10d %10d %10d %10d\n", MSTAT_FUNC_str[i], value_f[0][i], value_f[1][i], value_f[2][i], value_f[3][i]);
 	}
 	#endif
-
-	return cnt;
-}
-
-void rtw_mstat_dump(void)
-{
-	char buf[768] = {0};
-
-	_rtw_mstat_dump(buf, 768);
-	DBG_871X("\n%s", buf);
 }
 
 void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz)
@@ -477,12 +472,14 @@ void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 s
 			ATOMIC_SET(&(rtw_mem_type_stat[i].alloc_cnt), 0);
 			ATOMIC_SET(&(rtw_mem_type_stat[i].alloc_err_cnt), 0);
 		}
+		#ifdef RTW_MEM_FUNC_STAT
 		for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
 			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc), 0);
 			ATOMIC_SET(&(rtw_mem_func_stat[i].peak), 0);
 			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc_cnt), 0);
 			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc_err_cnt), 0);
 		}
+		#endif
 	}
 
 	switch(status) {
@@ -493,40 +490,73 @@ void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 s
 			if (peak<alloc)
 				ATOMIC_SET(&(rtw_mem_type_stat[mstat_tf_idx(flags)].peak), alloc);
 
+			#ifdef RTW_MEM_FUNC_STAT
 			ATOMIC_INC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_cnt));
 			alloc = ATOMIC_ADD_RETURN(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc), sz);
 			peak=ATOMIC_READ(&(rtw_mem_func_stat[mstat_ff_idx(flags)].peak));
 			if (peak<alloc)
 				ATOMIC_SET(&(rtw_mem_func_stat[mstat_ff_idx(flags)].peak), alloc);
+			#endif
 			break;
 
 		case MSTAT_ALLOC_FAIL:
 			ATOMIC_INC(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc_err_cnt));
-
+			#ifdef RTW_MEM_FUNC_STAT
 			ATOMIC_INC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_err_cnt));
+			#endif
 			break;
 
 		case MSTAT_FREE:
 			ATOMIC_DEC(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc_cnt));
 			ATOMIC_SUB(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc), sz);
-
+			#ifdef RTW_MEM_FUNC_STAT
 			ATOMIC_DEC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_cnt));
 			ATOMIC_SUB(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc), sz);
+			#endif
 			break;
 	};
 
 	//if (rtw_get_passing_time_ms(update_time) > 5000) {
-	//	rtw_mstat_dump();
+	//	rtw_mstat_dump(RTW_DBGDUMP);
 		update_time=rtw_get_current_time();
 	//}
 }
 
+#ifndef SIZE_MAX
+	#define SIZE_MAX (~(size_t)0)
+#endif
+
+struct mstat_sniff_rule {
+	enum mstat_f flags;
+	size_t lb;
+	size_t hb;
+};
+
+struct mstat_sniff_rule mstat_sniff_rules[] = {
+	{MSTAT_TYPE_PHY, 4097, SIZE_MAX},
+};
 
+int mstat_sniff_rule_num = sizeof(mstat_sniff_rules)/sizeof(struct mstat_sniff_rule);
+
+bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size)
+{
+	int i;
+	for (i = 0; i<mstat_sniff_rule_num; i++) {
+		if (mstat_sniff_rules[i].flags == flags
+				&& mstat_sniff_rules[i].lb <= size
+				&& mstat_sniff_rules[i].hb >= size)
+			return _TRUE;
+	}
+
+	return _FALSE;
+}
 
 inline u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
 	u8  *p;
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func,  line, __FUNCTION__, (sz));
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 	
 	p=_rtw_vmalloc((sz));
 
@@ -542,8 +572,10 @@ inline u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 inline u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
 	u8 *p;
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz)); 
-	
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
 	p=_rtw_zvmalloc((sz)); 
 
 	rtw_mstat_update(
@@ -557,8 +589,10 @@ inline u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func,
 
 inline void dbg_rtw_vmfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%p,%d)\n",  func, line, __FUNCTION__, (pbuf), (sz));
-	
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
 	_rtw_vmfree((pbuf), (sz)); 
 
 	rtw_mstat_update(
@@ -572,14 +606,11 @@ inline u8* dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, co
 {
 	u8 *p;
 
-	//if(sz>=153 && sz<=306) 
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
-
-	//if((sz)>4096) 
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz)); 
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
 	p=_rtw_malloc((sz));
-	
+
 	rtw_mstat_update(
 		flags
 		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
@@ -593,11 +624,8 @@ inline u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 {
 	u8 *p;
 
-	//if(sz>=153 && sz<=306) 
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
-
-	//if((sz)>4096)
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
 	p = _rtw_zmalloc((sz));
 
@@ -612,12 +640,9 @@ inline u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 
 inline void dbg_rtw_mfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
-	//if(sz>=153 && sz<=306) 
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
-	//if((sz)>4096)
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%p,%d)\n", func, line, __FUNCTION__, (pbuf), (sz));
-	
 	_rtw_mfree((pbuf), (sz));
 
 	rtw_mstat_update(
@@ -637,7 +662,7 @@ inline struct sk_buff * dbg_rtw_skb_alloc(unsigned int size, const enum mstat_f
 	if(skb)
 		truesize = skb->truesize;
 
-	if(!skb || truesize < size /*|| size > 4096*/)
+	if(!skb || truesize < size || match_mstat_sniff_rules(flags, truesize))
 		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, size, skb, truesize);
 
 	rtw_mstat_update(
@@ -653,11 +678,11 @@ inline void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, cons
 {
 	unsigned int truesize = skb->truesize;
 
-	//if(truesize > 4096)
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
 
 	_rtw_skb_free(skb);
-	
+
 	rtw_mstat_update(
 		flags
 		, MSTAT_FREE
@@ -675,7 +700,7 @@ inline struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum ms
 	if(skb_cp)
 		cp_truesize = skb_cp->truesize;
 
-	if(!skb_cp || cp_truesize != truesize /*||cp_truesize > 4096*/)
+	if(!skb_cp || cp_truesize < truesize || match_mstat_sniff_rules(flags, cp_truesize))
 		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%u), skb_cp:%p, cp_truesize=%u\n", func, line, __FUNCTION__, truesize, skb_cp, cp_truesize);
 
 	rtw_mstat_update(
@@ -697,7 +722,7 @@ inline struct sk_buff *dbg_rtw_skb_clone(struct sk_buff *skb, const enum mstat_f
 	if(skb_cl)
 		cl_truesize = skb_cl->truesize;
 
-	if(!skb_cl || cl_truesize != truesize /*|| cl_truesize > 4096*/)
+	if(!skb_cl || cl_truesize < truesize || match_mstat_sniff_rules(flags, cl_truesize))
 		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%u), skb_cl:%p, cl_truesize=%u\n", func, line, __FUNCTION__, truesize, skb_cl, cl_truesize);
 
 	rtw_mstat_update(
@@ -714,8 +739,8 @@ inline int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat
 	int ret;
 	unsigned int truesize = skb->truesize;
 
-	//if(truesize > 4096)
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
 
 	ret = _rtw_netif_rx(ndev, skb);
 	
@@ -740,8 +765,10 @@ inline void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flag
 inline void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma, const enum mstat_f flags, const char *func, int line)
 {
 	void *p;
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
-	
+
+	if(match_mstat_sniff_rules(flags, size))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
+
 	p = _rtw_usb_buffer_alloc(dev, size, dma);
 	
 	rtw_mstat_update(
@@ -755,7 +782,8 @@ inline void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_a
 
 inline void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma, const enum mstat_f flags, const char *func, int line)
 {
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
+	if(match_mstat_sniff_rules(flags, size))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
 
 	_rtw_usb_buffer_free(dev, size, addr, dma);
 
@@ -2022,8 +2050,6 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
 #endif
 		unregister_netdevice(cur_pnetdev);
 
-	rtw_proc_remove_one(cur_pnetdev);
-
 	rereg_priv->old_pnetdev=cur_pnetdev;
 
 	pnetdev = rtw_init_netdev(padapter);
@@ -2050,8 +2076,6 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
 		goto error;
 	}
 
-	rtw_proc_init_one(pnetdev);
-
 	return 0;
 
 error:
-- 
2.35.3

