From 99d9e3f5ff41bd4172dc295005b9a4196d95c77a Mon Sep 17 00:00:00 2001
From: li bing <libing@rock-chips.com>
Date: Thu, 29 Jan 2015 14:09:41 +0800
Subject: [PATCH] Wifi->rtl8723au: update dirver to version
 4.00(4.1.11_12622.20141215).

---
 .../wireless/rockchip_wlan/rtl8723au/Makefile |  20 +-
 .../rockchip_wlan/rtl8723au/core/rtw_ap.c     |  21 +-
 .../rockchip_wlan/rtl8723au/core/rtw_cmd.c    |  61 +-
 .../rockchip_wlan/rtl8723au/core/rtw_debug.c  |  77 ++-
 .../rtl8723au/core/rtw_ieee80211.c            |  15 +-
 .../rtl8723au/core/rtw_ioctl_set.c            |   4 +-
 .../rockchip_wlan/rtl8723au/core/rtw_mlme.c   |  97 ++-
 .../rtl8723au/core/rtw_mlme_ext.c             | 405 ++++++-----
 .../rockchip_wlan/rtl8723au/core/rtw_p2p.c    |  27 +-
 .../rockchip_wlan/rtl8723au/core/rtw_recv.c   |  10 +-
 .../rtl8723au/core/rtw_security.c             | 105 ++-
 .../rockchip_wlan/rtl8723au/core/rtw_sreset.c |   2 +-
 .../rockchip_wlan/rtl8723au/core/rtw_tdls.c   |   2 +-
 .../rtl8723au/core/rtw_wlan_util.c            | 506 +++++++++++---
 .../rockchip_wlan/rtl8723au/core/rtw_xmit.c   | 193 ++++--
 .../rtl8723au/hal/OUTSRC/odm_HWConfig.c       |   9 +
 .../rtl8723au/hal/OUTSRC/odm_HWConfig.h       |   7 +
 .../hal/OUTSRC/rtl8723a/Hal8723SHWImg_CE.c    |   4 +-
 .../hal/OUTSRC/rtl8723a/Hal8723UHWImg_CE.c    |  12 +-
 .../rockchip_wlan/rtl8723au/hal/hal_com.c     | 361 ++++++++++
 .../rockchip_wlan/rtl8723au/hal/hal_intf.c    |  60 +-
 .../hal/rtl8723a/rtl8723a_bt-coexist.c        |  21 +-
 .../rtl8723au/hal/rtl8723a/rtl8723a_dm.c      |  17 +-
 .../hal/rtl8723a/rtl8723a_hal_init.c          | 261 ++++++--
 .../rtl8723au/hal/rtl8723a/rtl8723a_rf6052.c  |  34 +-
 .../rtl8723au/hal/rtl8723a/rtl8723a_rxdesc.c  |  15 +-
 .../hal/rtl8723a/sdio/sdio_halinit.c          |  88 ++-
 .../hal/rtl8723a/usb/rtl8723au_recv.c         |   2 -
 .../rtl8723au/hal/rtl8723a/usb/usb_halinit.c  | 102 ++-
 .../hal/rtl8723a/usb/usb_ops_linux.c          |  12 +-
 .../rtl8723au/include/autoconf.h              |  62 +-
 .../rtl8723au/include/drv_conf.h              |   5 +
 .../rtl8723au/include/drv_types.h             |  21 +
 .../rockchip_wlan/rtl8723au/include/hal_com.h |  17 +
 .../rtl8723au/include/hal_com_reg.h           | 103 +++
 .../rtl8723au/include/hal_intf.h              |   8 +
 .../rtl8723au/include/osdep_intf.h            |   4 -
 .../rtl8723au/include/rtl8188e_spec.h         |  58 +-
 .../rtl8723au/include/rtl8192c_spec.h         |  59 +-
 .../rtl8723au/include/rtl8192d_spec.h         |  69 +-
 .../rtl8723au/include/rtl8723a_bt-coexist.h   |   1 -
 .../rtl8723au/include/rtl8723a_hal.h          |   1 +
 .../rockchip_wlan/rtl8723au/include/rtw_ap.h  |   3 +-
 .../rockchip_wlan/rtl8723au/include/rtw_cmd.h |  21 +-
 .../rtl8723au/include/rtw_debug.h             |   6 +
 .../rtl8723au/include/rtw_mlme.h              |   7 +
 .../rtl8723au/include/rtw_mlme_ext.h          |  27 +-
 .../rtl8723au/include/rtw_recv.h              |  10 +-
 .../rtl8723au/include/rtw_security.h          |  26 +
 .../rtl8723au/include/rtw_version.h           |   2 +-
 .../rtl8723au/include/rtw_xmit.h              |   2 +-
 .../rtl8723au/os_dep/linux/gspi_intf.c        |   3 +
 .../rtl8723au/os_dep/linux/ioctl_cfg80211.c   | 110 +--
 .../rtl8723au/os_dep/linux/ioctl_linux.c      | 630 +++++++++++-------
 .../rtl8723au/os_dep/linux/os_intfs.c         |  78 +--
 .../rtl8723au/os_dep/linux/pci_intf.c         |   5 +
 .../rtl8723au/os_dep/linux/rtw_proc.c         |  93 +++
 .../rtl8723au/os_dep/linux/rtw_proc.h         |  12 +-
 .../rtl8723au/os_dep/linux/sdio_intf.c        |   3 +
 .../rtl8723au/os_dep/linux/usb_intf.c         |   9 +-
 .../rtl8723au/os_dep/linux/usb_ops_linux.c    |   7 +-
 .../rtl8723au/os_dep/linux/xmit_linux.c       |   6 +-
 62 files changed, 2748 insertions(+), 1270 deletions(-)
 create mode 100755 drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com_reg.h

diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8723au/Makefile
index a01e58145c0d..680ad384f724 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/Makefile
@@ -357,6 +357,8 @@ endif
 
 ifeq ($(CONFIG_EFUSE_CONFIG_FILE), y)
 EXTRA_CFLAGS += -DCONFIG_EFUSE_CONFIG_FILE
+EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_$(MODULE_NAME).map\"
+EXTRA_CFLAGS += -DWIFIMAC_PATH=\"/data/wifimac.txt\"
 endif
 
 ifeq ($(CONFIG_EXT_CLK), y)
@@ -371,6 +373,10 @@ ifeq ($(CONFIG_ODM_ADAPTIVITY), y)
 EXTRA_CFLAGS += -DCONFIG_ODM_ADAPTIVITY
 endif
 
+ifeq ($(CONFIG_SKIP_SIGNAL_SCALE_MAPPING), y)
+EXTRA_CFLAGS += -DCONFIG_SKIP_SIGNAL_SCALE_MAPPING
+endif
+
 ifeq ($(CONFIG_MMC_PM_KEEP_POWER), y)
 EXTRA_CFLAGS += -DCONFIG_MMC_PM_KEEP_POWER
 endif
@@ -631,7 +637,7 @@ endif
 ARCH := arm
 CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
 KSRC := /usr/src/release_fae_version/kernel25_A7_281x
-MODULE_NAME := 8723au
+MODULE_NAME := wlan
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y)
@@ -736,14 +742,10 @@ KVER  := 3.3.0
 #Android-JB42
 #CROSS_COMPILE := /home/android_sdk/Allwinner/a31/android-jb42/lichee/buildroot/output/external-toolchain/bin/arm-linux-gnueabi-
 #KSRC :=/home/android_sdk/Allwinner/a31/android-jb42/lichee/linux-3.3
-
-#Android-KK44
-CROSS_COMPILE := /home/android_sdk/Allwinner/a31/android-kk44/A3x-KK-SDK/lichee/buildroot/output/external-toolchain/bin/arm-linux-gnueabi-
-KSRC :=/home/android_sdk/Allwinner/a31/android-kk44/A3x-KK-SDK/lichee/linux-3.3
-
-ifeq ($(CONFIG_USB_HCI), y)
-MODULE_NAME := 8188eu_sw
-endif
+# ==== Cross compile setting for kitkat-a3x_v4.5 =====
+CROSS_COMPILE := /home/android_sdk/Allwinner/a31/kitkat-a3x_v4.5/lichee/buildroot/output/external-toolchain/bin/arm-linux-gnueabi-
+KSRC :=/home/android_sdk/Allwinner/a31/kitkat-a3x_v4.5/lichee/linux-3.3
+MODULE_NAME := 8192eu
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_SUN7I), y)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ap.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ap.c
index c865a744bf18..a81ffbf82a71 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ap.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ap.c
@@ -193,14 +193,6 @@ static void update_BCNTIM(_adapter *padapter)
 		pnetwork_mlmeext->IELength = offset + remainder_ielen;
 	
 	}
-
-#ifndef CONFIG_INTERRUPT_BASED_TXBCN 
-#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-	set_tx_beacon_cmd(padapter);
-#endif
-#endif //!CONFIG_INTERRUPT_BASED_TXBCN
-
-
 }
 
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len)
@@ -495,7 +487,7 @@ void	expire_timeout_chk(_adapter *padapter)
 
 					//to update bcn with tim_bitmap for this station
 					pstapriv->tim_bitmap |= BIT(psta->aid);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 
 					if(!pmlmeext->active_keep_alive_check)
 						continue;
@@ -1354,7 +1346,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 	if(_TRUE == pmlmeext->bstart_bss)
 	{
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+		update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 
 #ifndef CONFIG_INTERRUPT_BASED_TXBCN //other case will  tx beacon when bcn interrupt coming in.
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
@@ -2074,7 +2066,7 @@ static void update_bcn_vendor_spec_ie(_adapter *padapter, u8*oui)
 	
 }
 
-void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag)
 {
 	_irqL irqL;
 	struct mlme_priv *pmlmepriv;
@@ -2152,6 +2144,8 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 	if(tx)
 	{
 		//send_beacon(padapter);//send_beacon must execute on TSR level
+		if (0)
+			DBG_871X(FUNC_ADPT_FMT" ie_id:%u - %s\n", FUNC_ADPT_ARG(padapter), ie_id, tag);
 		set_tx_beacon_cmd(padapter);
 	}
 #else
@@ -2597,8 +2591,7 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 	//report_del_sta_event(padapter, psta->hwaddr, reason);
 
 	//clear cam entry / key
-	//clear_cam_entry(padapter, (psta->mac_id + 3));
-	rtw_clearstakey_cmd(padapter, (u8*)psta, (u8)rtw_get_camid(psta->mac_id), _TRUE);
+	rtw_clearstakey_cmd(padapter, psta, _TRUE);
 
 
 	_enter_critical_bh(&psta->lock, &irqL);
@@ -2835,7 +2828,7 @@ void rtw_ap_restore_network(_adapter *padapter)
 			if(	(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_) ||
 				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_))
 			{
-				rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE,_FALSE);
+				rtw_setstakey_cmd(padapter, psta, _TRUE,_FALSE);
 			}			
 		}
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_cmd.c
index 5853d235eebb..2679d42e91d9 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_cmd.c
@@ -1466,7 +1466,7 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key, bool enqueue)
+u8 rtw_setstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 unicast_key, bool enqueue)
 {
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
@@ -1475,7 +1475,6 @@ u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key, bool enqueue)
 	
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
-	struct sta_info* 			sta = (struct sta_info* )psta;
 	u8	res=_SUCCESS;
 
 _func_enter_;
@@ -1547,7 +1546,7 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
+u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue)
 {
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
@@ -1555,14 +1554,18 @@ u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 	struct set_stakey_rsp		*psetstakey_rsp = NULL;	
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
-	struct sta_info* 			sta = (struct sta_info* )psta;
+	s16 cam_id = 0;
 	u8	res=_SUCCESS;
 
 _func_enter_;
 
 	if(!enqueue)
 	{
-		clear_cam_entry(padapter, entry);
+		while((cam_id = rtw_camid_search(padapter, sta->hwaddr, -1)) >= 0) {
+			DBG_871X_LEVEL(_drv_always_, "clear key for addr:"MAC_FMT", camid:%d\n", MAC_ARG(sta->hwaddr), cam_id);
+			clear_cam_entry(padapter, cam_id);
+			rtw_camid_free(padapter, cam_id);
+		}
 	}
 	else
 	{
@@ -1594,8 +1597,6 @@ _func_enter_;
 		_rtw_memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
 
 		psetstakey_para->algorithm = _NO_PRIVACY_;
-
-		psetstakey_para->id = entry;
 	
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 		
@@ -2322,7 +2323,7 @@ static void traffic_status_watchdog(_adapter *padapter)
 	pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;
 	pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;
 #ifdef CONFIG_BT_COEXIST
-	pHalData->bt_coexist.halCoex8723.bBusyTrafficForCoex = bBusyTrafficForCoex;
+	pmlmepriv->LinkDetectInfo.bBusyTrafficForCoex = bBusyTrafficForCoex;
 #endif
 }
 
@@ -2711,49 +2712,43 @@ _func_exit_;
 
 static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 {
-	int cnt=0;
 	struct sta_info *psta_bmc;
 	struct sta_priv *pstapriv = &padapter->stapriv;
+	u32 start = rtw_get_current_time();
+	u8 empty = _FALSE;
 
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 	if(!psta_bmc)
 		return;
 
-	if(psta_bmc->sleepq_len==0)
-	{		
-		u8 val = 0;
+	rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);
 
-		//while((rtw_read32(padapter, 0x414)&0x00ffff00)!=0)
-		//while((rtw_read32(padapter, 0x414)&0x0000ff00)!=0)
-		
-		rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);		
-		
-		while(_FALSE == val)
-		{
-			rtw_msleep_os(100);
+	while(_FALSE == empty && rtw_get_passing_time_ms(start) < rtw_get_wait_hiq_empty_ms())
+	{
+		rtw_msleep_os(100);
+		rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);
+	}
 
-			cnt++;
-			
-			if(cnt>10)
-				break;
+	if(psta_bmc->sleepq_len==0)
+	{
+		if(empty == _SUCCESS)
+		{
+			bool update_tim = _FALSE;
 
-			rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);
-		}
+			if (pstapriv->tim_bitmap & BIT(0))
+				update_tim = _TRUE;
 
-		if(cnt<=10)
-		{
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
-			
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+
+			if (update_tim == _TRUE)
+				_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "bmc sleepq and HIQ empty");
 		}
 		else //re check again
 		{
 			rtw_chk_hi_queue_cmd(padapter);
 		}
-		
-	}	
-	
+	}
 }
 
 u8 rtw_chk_hi_queue_cmd(_adapter*padapter)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_debug.c
index 00cff458e430..e20476dd3fe3 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_debug.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_debug.c
@@ -131,6 +131,36 @@ void rf_reg_dump(void *sel, _adapter *adapter)
 	}
 }
 
+static u8 fwdl_test_chksum_fail = 0;
+static u8 fwdl_test_wintint_rdy_fail = 0;
+
+bool rtw_fwdl_test_trigger_chksum_fail()
+{
+	if (fwdl_test_chksum_fail) {
+		DBG_871X_LEVEL(_drv_always_, "fwdl test case: trigger chksum_fail\n");
+		fwdl_test_chksum_fail--;
+		return _TRUE;
+	}
+	return _FALSE;
+}
+
+bool rtw_fwdl_test_trigger_wintint_rdy_fail()
+{
+	if (fwdl_test_wintint_rdy_fail) {
+		DBG_871X_LEVEL(_drv_always_, "fwdl test case: trigger wintint_rdy_fail\n");
+		fwdl_test_wintint_rdy_fail--;
+		return _TRUE;
+	}
+	return _FALSE;
+}
+
+static u32 g_wait_hiq_empty_ms = 0;
+
+u32 rtw_get_wait_hiq_empty_ms()
+{
+	return g_wait_hiq_empty_ms;
+}
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
@@ -253,11 +283,30 @@ int proc_get_sec_info(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
-	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct security_priv *sec = &padapter->securitypriv;
 
 	DBG_871X_SEL_NL(m, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
-						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
-						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+						sec->dot11AuthAlgrthm, sec->dot11PrivacyAlgrthm,
+						sec->ndisauthtype, sec->ndisencryptstatus);
+
+	DBG_871X_SEL_NL(m, "hw_decrypted=%d\n", sec->hw_decrypted);
+
+#ifdef DBG_SW_SEC_CNT
+	DBG_871X_SEL_NL(m, "wep_sw_enc_cnt=%llu, %llu, %llu\n"
+		, sec->wep_sw_enc_cnt_bc , sec->wep_sw_enc_cnt_mc, sec->wep_sw_enc_cnt_uc);
+	DBG_871X_SEL_NL(m, "wep_sw_dec_cnt=%llu, %llu, %llu\n"
+		, sec->wep_sw_dec_cnt_bc , sec->wep_sw_dec_cnt_mc, sec->wep_sw_dec_cnt_uc);
+
+	DBG_871X_SEL_NL(m, "tkip_sw_enc_cnt=%llu, %llu, %llu\n"
+		, sec->tkip_sw_enc_cnt_bc , sec->tkip_sw_enc_cnt_mc, sec->tkip_sw_enc_cnt_uc);	
+	DBG_871X_SEL_NL(m, "tkip_sw_dec_cnt=%llu, %llu, %llu\n"
+		, sec->tkip_sw_dec_cnt_bc , sec->tkip_sw_dec_cnt_mc, sec->tkip_sw_dec_cnt_uc);
+
+	DBG_871X_SEL_NL(m, "aes_sw_enc_cnt=%llu, %llu, %llu\n"
+		, sec->aes_sw_enc_cnt_bc , sec->aes_sw_enc_cnt_mc, sec->aes_sw_enc_cnt_uc);
+	DBG_871X_SEL_NL(m, "aes_sw_dec_cnt=%llu, %llu, %llu\n"
+		, sec->aes_sw_dec_cnt_bc , sec->aes_sw_dec_cnt_mc, sec->aes_sw_dec_cnt_uc);
+#endif /* DBG_SW_SEC_CNT */
 
 	return 0;
 }
@@ -901,7 +950,7 @@ int proc_get_best_channel(struct seq_file *m, void *v)
 			index_5G = i;
 	}	
 	
-	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+	for (i=0; (pmlmeext->channel_set[i].ChannelNum !=0) && (i < MAX_CHANNEL_NUM); i++) {
 		// 2.4G
 		if ( pmlmeext->channel_set[i].ChannelNum == 6 ) {
 			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
@@ -1047,8 +1096,6 @@ ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t cou
 }
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
-u8 g_fwdl_chksum_fail = 0;
-u8 g_fwdl_wintint_rdy_fail = 0;
 ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -1059,7 +1106,23 @@ ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, si
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
-		int num = sscanf(tmp, "%hhu %hhu", &g_fwdl_chksum_fail, &g_fwdl_wintint_rdy_fail);
+		int num = sscanf(tmp, "%hhu %hhu", &fwdl_test_chksum_fail, &fwdl_test_wintint_rdy_fail);
+	}
+
+	return count;
+}
+
+ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%u", &g_wait_hiq_empty_ms);
 	}
 
 	return count;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ieee80211.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ieee80211.c
index 98c92eedaca0..1f641cd33bfb 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ieee80211.c
@@ -1317,13 +1317,12 @@ extern char* rtw_initmac;
 #include <linux/rfkill-wlan.h>
 void rtw_macaddr_cfg(u8 *mac_addr)
 {
-    u8 mac[ETH_ALEN];
-
-    if(mac_addr == NULL)    return;
-
-    if ( rtw_initmac )
-    {   //  Users specify the mac address
-        int jj,kk;
+	u8 mac[ETH_ALEN];
+	if(mac_addr == NULL)	return;
+	
+	if ( rtw_initmac )
+	{	//	Users specify the mac address
+		int jj,kk;
 
         for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
         {
@@ -1361,7 +1360,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
         DBG_871X("MAC Address from efuse error, assign default one !!!\n");
     }
 
-    DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
+	DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
 }
 
 void dump_ies(u8 *buf, u32 buf_len)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ioctl_set.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ioctl_set.c
index d2d07d7ef386..1cd87785f37a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ioctl_set.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_ioctl_set.c
@@ -1265,11 +1265,11 @@ _func_enter_;
 			//Set key to CAM through H2C command
 			if(bgrouptkey)//never go to here
 			{
-				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _FALSE, _TRUE);
+				res=rtw_setstakey_cmd(padapter, stainfo, _FALSE, _TRUE);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
 			}
 			else{
-				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _TRUE, _TRUE);
+				res=rtw_setstakey_cmd(padapter, stainfo, _TRUE, _TRUE);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
 			}
 			
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme.c
index 1872700eea3c..76f6cba101bb 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme.c
@@ -1622,6 +1622,8 @@ void rtw_indicate_disconnect( _adapter *padapter )
 	WLAN_BSSID_EX	*cur_network = &(pmlmeinfo->network);
 	struct sta_info *psta;
 	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 *wps_ie=NULL;
+	uint wpsie_len=0;
 
 _func_enter_;	
 	
@@ -1629,7 +1631,22 @@ _func_enter_;
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
 
-        //DBG_871X("clear wps when %s\n", __func__);
+	// force to clear cur_network_scanned's SELECTED REGISTRAR
+	if (pmlmepriv->cur_network_scanned) {
+		WLAN_BSSID_EX	*current_joined_bss = &(pmlmepriv->cur_network_scanned->network);
+		if (current_joined_bss) {
+			wps_ie=rtw_get_wps_ie(current_joined_bss->IEs +_FIXED_IE_LENGTH_,
+				current_joined_bss->IELength-_FIXED_IE_LENGTH_, NULL, &wpsie_len);
+			if (wps_ie && wpsie_len>0) {
+				u8 *attr = NULL;
+				u32 attr_len;
+				attr=rtw_get_wps_attr(wps_ie, wpsie_len, WPS_ATTR_SELECTED_REGISTRAR,
+							   NULL, &attr_len);
+				if (attr)
+					*(attr + 4) = 0;
+			}
+		}
+	}
 
 	if(rtw_to_roaming(padapter) > 0)
 		_clr_fwstate_(pmlmepriv, _FW_LINKED);
@@ -1760,6 +1777,7 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 			_rtw_memset((u8 *)&psta->dot11tkiptxmickey, 0, sizeof (union Keytype));
 						
 			_rtw_memset((u8 *)&psta->dot11txpn, 0, sizeof (union pn48));
+			psta->dot11txpn.val = psta->dot11txpn.val + 1;
 #ifdef CONFIG_IEEE80211W
 			_rtw_memset((u8 *)&psta->dot11wtxpn, 0, sizeof (union pn48));
 #endif //CONFIG_IEEE80211W
@@ -2317,7 +2335,7 @@ _func_enter_;
 	
 #ifdef CONFIG_RTL8711
 	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta	
-	rtw_setstakey_cmd(adapter, (unsigned char*)psta, _FALSE, _TRUE);
+	rtw_setstakey_cmd(adapter, psta, _FALSE, _TRUE);
 #endif
 		
 exit:
@@ -3469,25 +3487,71 @@ static int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
 // 13th element in the array is the IE length  
 //
 
-static int rtw_append_pmkid(_adapter *Adapter,int iEntry, u8 *ie, uint ie_len)
+static int rtw_append_pmkid(_adapter *adapter,int iEntry, u8 *ie, uint ie_len)
 {
-	struct security_priv *psecuritypriv=&Adapter->securitypriv;
+	struct security_priv *sec=&adapter->securitypriv;
 
-	if(ie[13]<=20){	
-		// The RSN IE didn't include the PMK ID, append the PMK information 
-			ie[ie_len]=1;
-			ie_len++;
-			ie[ie_len]=0;	//PMKID count = 0x0100
-			ie_len++;
-			_rtw_memcpy(	&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
-		
-			ie_len+=16;
-			ie[13]+=18;//PMKID length = 2+16
+	if (ie[13] > 20) {
+		int i;
+		u16 pmkid_cnt = RTW_GET_LE16(ie+14+20);
+		if (pmkid_cnt == 1 && _rtw_memcmp(ie+14+20+2, &sec->PMKIDList[iEntry].PMKID, 16)) {
+			DBG_871X(FUNC_ADPT_FMT" has carried the same PMKID:"KEY_FMT"\n"
+				, FUNC_ADPT_ARG(adapter), KEY_ARG(&sec->PMKIDList[iEntry].PMKID));
+			goto exit;
+		}
+
+		DBG_871X(FUNC_ADPT_FMT" remove original PMKID, count:%u\n"
+			, FUNC_ADPT_ARG(adapter), pmkid_cnt);
 
+		for (i=0;i<pmkid_cnt;i++)
+			DBG_871X("    "KEY_FMT"\n", KEY_ARG(ie+14+20+2+i*16));
+
+		ie_len -= 2+pmkid_cnt*16;
+		ie[13] = 20;
+	}
+
+	if (ie[13] <= 20) {	
+		/* The RSN IE didn't include the PMK ID, append the PMK information */
+
+		DBG_871X(FUNC_ADPT_FMT" append PMKID:"KEY_FMT"\n"
+				, FUNC_ADPT_ARG(adapter), KEY_ARG(&sec->PMKIDList[iEntry].PMKID));
+
+		RTW_PUT_LE16(&ie[ie_len], 1);
+		ie_len += 2;
+
+		_rtw_memcpy(&ie[ie_len], &sec->PMKIDList[iEntry].PMKID, 16);
+		ie_len += 16;
+
+		ie[13] += 18;//PMKID length = 2+16
 	}
+
+exit:
 	return (ie_len);
 	
 }
+
+static int rtw_remove_pmkid(_adapter *adapter, u8 *ie, uint ie_len)
+{
+	struct security_priv *sec=&adapter->securitypriv;
+	int i;
+	u16 pmkid_cnt = RTW_GET_LE16(ie+14+20);
+
+	if (ie[13] <= 20)
+		goto exit;
+
+	DBG_871X(FUNC_ADPT_FMT" remove original PMKID, count:%u\n"
+		, FUNC_ADPT_ARG(adapter), pmkid_cnt);
+
+	for (i=0;i<pmkid_cnt;i++)
+		DBG_871X("    "KEY_FMT"\n", KEY_ARG(ie+14+20+2+i*16));
+
+	ie_len -= 2+pmkid_cnt*16;
+	ie[13] = 20;
+
+exit:
+	return (ie_len);
+}
+
 sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 {
 	u8 authmode, securitytype, match;
@@ -3544,14 +3608,13 @@ _func_enter_;
 	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
 	if(iEntry<0)
 	{
-		return ielength;
+		if(authmode == _WPA2_IE_ID_)
+			ielength = rtw_remove_pmkid(adapter, out_ie, ielength);
 	}
 	else
 	{
 		if(authmode == _WPA2_IE_ID_)
-		{
 			ielength=rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
-		}
 	}
 
 _func_exit_;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme_ext.c
index 800982364b97..c75b90899567 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_mlme_ext.c
@@ -5594,8 +5594,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
 				issue_p2p_GO_response( padapter, GetAddr2Ptr(pframe), frame_body, len, result );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5845,8 +5844,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					_set_timer( &pwdinfo->restore_p2p_state_timer, 3000 );
 				}
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5931,8 +5929,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -6094,10 +6091,7 @@ unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame)
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
 	struct	wifidirect_info	*pwdinfo = &( padapter->wdinfo );
-	
 
-	DBG_871X("%s\n", __FUNCTION__);
-	
 	//check RA matches or not
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
 		return _SUCCESS;
@@ -7478,6 +7472,7 @@ void issue_assocreq(_adapter *padapter)
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	int	bssrate_len = 0, sta_bssrate_len = 0;
+	u8	vs_ie_length = 0;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8					p2pie[ 255 ] = { 0x00 };
@@ -7721,17 +7716,18 @@ void issue_assocreq(_adapter *padapter)
 				if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) ||
 						(_rtw_memcmp(pIE->data, WMM_OUI, 4)) ||
 						(_rtw_memcmp(pIE->data, WPS_OUI, 4)))
-				{
-					if(!padapter->registrypriv.wifi_spec)
+				{	
+					vs_ie_length = pIE->Length;
+					if((!padapter->registrypriv.wifi_spec) && (_rtw_memcmp(pIE->data, WPS_OUI, 4)))
 					{
 						//Commented by Kurt 20110629
 						//In some older APs, WPS handshake
 						//would be fail if we append vender extensions informations to AP
-						if(_rtw_memcmp(pIE->data, WPS_OUI, 4)){
-							pIE->Length=14;
-						}
+
+						vs_ie_length = 14;
 					}
-					pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, pIE->Length, pIE->data, &(pattrib->pktlen));
+					
+					pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, vs_ie_length, pIE->data, &(pattrib->pktlen));
 				}
 				break;
 
@@ -8024,9 +8020,12 @@ static int _issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int p
 	return ret;
 }
 
-
-//when wait_ms >0 , this function shoule be called at process context
-//da == NULL for station mode
+/*
+ * [IMPORTANT] Don't call this function in interrupt context
+ *
+ * When wait_ms > 0, this function shoule be called at process context
+ * da == NULL for station mode
+ */
 int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms)
 {
 	int ret;
@@ -8034,13 +8033,26 @@ int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mod
 	u32 start = rtw_get_current_time();
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info *psta;
+
 
 	/* da == NULL, assum it's null data for sta to ap*/
 	if (da == NULL)
 		da = get_my_bssid(&(pmlmeinfo->network));
 
-	do
-	{
+	psta = rtw_get_stainfo(&padapter->stapriv, da);
+	if (psta) {
+		if (power_mode)
+			rtw_hal_macid_sleep(padapter, psta->mac_id);
+		else
+			rtw_hal_macid_wakeup(padapter, psta->mac_id);
+	} else {
+		DBG_871X(FUNC_ADPT_FMT ": Can't find sta info for " MAC_FMT ", skip macid %s!!\n",
+			FUNC_ADPT_ARG(padapter), MAC_ARG(da), power_mode?"sleep":"wakeup");
+		rtw_warn_on(1);
+	}
+
+	do {
 		ret = _issue_nulldata(padapter, da, power_mode, wait_ms>0?_TRUE:_FALSE);
 
 		i++;
@@ -8074,6 +8086,31 @@ int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mod
 	return ret;
 }
 
+/*
+ * [IMPORTANT] This function run in interrupt context
+ *
+ * The null data packet would be sent without power bit,
+ * and not guarantee success.
+ */
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da)
+{
+	int ret;
+	struct mlme_ext_priv *pmlmeext;
+	struct mlme_ext_info *pmlmeinfo;
+
+
+	pmlmeext = &padapter->mlmeextpriv;
+	pmlmeinfo = &pmlmeext->mlmext_info;
+
+	/* da == NULL, assum it's null data for sta to ap*/
+	if (da == NULL)
+		da = get_my_bssid(&(pmlmeinfo->network));
+
+	ret = _issue_nulldata(padapter, da, 0, _FALSE);
+
+	return ret;
+}
+
 //when wait_ack is ture, this function shoule be called at process context
 static int _issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int wait_ack)
 {
@@ -10589,6 +10626,10 @@ void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res)
 		set_sta_rate(padapter, psta);
 		
 		rtw_sta_media_status_rpt(padapter, psta, 1);
+
+		/* wakeup macid after join bss successfully to ensure 
+			the subsequent data frames can be sent out normally */
+		rtw_hal_macid_wakeup(padapter, psta->mac_id);
 	}
 
 	join_type = 2;
@@ -10677,6 +10718,14 @@ void mlmeext_sta_del_event_callback(_adapter *padapter)
 	if (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter))
 	{
 		//set_opmode_cmd(padapter, infra_client_with_mlme);
+		{
+			struct sta_info *psta;
+			WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+
+			psta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));
+			if (psta)
+				rtw_hal_macid_wakeup(padapter, psta->mac_id);
+		}
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 		rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
@@ -10909,7 +10958,7 @@ void linked_status_chk(_adapter *padapter)
 					#ifdef DBG_EXPIRATION_CHK
 					DBG_871X("%s issue_nulldata 0\n", __FUNCTION__);
 					#endif
-					tx_chk = issue_nulldata(padapter, NULL, 0, 1, 0);
+					tx_chk = issue_nulldata_in_interrupt(padapter, NULL);
 				}
 			}
 
@@ -11167,7 +11216,7 @@ void link_timer_hdl(_adapter *padapter)
 			{
 				if (tx_cnt == pxmitpriv->tx_pkts)
 				{
-					issue_nulldata(padapter, NULL, 0, 0, 0);
+					issue_nulldata_in_interrupt(padapter, NULL);
 				}
 
 				tx_cnt = pxmitpriv->tx_pkts;
@@ -11613,6 +11662,15 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 		
 	_cancel_timer_ex(&pmlmeext->link_timer);
 
+	{
+		struct sta_info *psta;
+		WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	
+		psta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));
+		if (psta)
+			rtw_hal_macid_wakeup(padapter, psta->mac_id);
+	}
+
 	rtw_free_uc_swdec_pending_queue(padapter);
 	
 	return 	H2C_SUCCESS;
@@ -11833,33 +11891,48 @@ u8 setauth_hdl(_adapter *padapter, unsigned char *pbuf)
 
 u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 {
-	unsigned short				ctrl;
+	u16	ctrl = 0;
+	s16 cam_id = 0;
 	struct setkey_parm		*pparm = (struct setkey_parm *)pbuf;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	unsigned char					null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	unsigned char null_addr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	u8 *addr;
 
 	//main tx key for wep.
 	if(pparm->set_tx)
 		pmlmeinfo->key_index = pparm->keyid;
-	
-	//write cam
-	ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;	
 
-	DBG_871X_LEVEL(_drv_always_, "set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) "
-			"keyid:%d\n", pparm->algorithm, pparm->keyid);
-	write_cam(padapter, pparm->keyid, ctrl, null_sta, pparm->key);
-	
+	cam_id = rtw_camid_alloc(padapter, NULL, pparm->keyid);
+
+	if (cam_id < 0){
+	} else {
+		if (cam_id > 3) /* not default key, searched by A2 */
+			addr = get_bssid(&padapter->mlmepriv);
+		else
+			addr = null_addr;
+		
+		ctrl = BIT(15) | BIT(6) |((pparm->algorithm) << 2) | pparm->keyid;
+		write_cam(padapter, cam_id, ctrl, addr, pparm->key);
+		DBG_871X_LEVEL(_drv_always_, "set group key camid:%d, addr:"MAC_FMT", kid:%d, type:%s\n"
+			,cam_id, MAC_ARG(addr), pparm->keyid, security_type_str(pparm->algorithm));
+	}
+
+	#ifdef DYNAMIC_CAMID_ALLOC
+	if (cam_id >=0 && cam_id <=3)
+		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_TRUE);
+	#endif
+
 	//allow multicast packets to driver
-        padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_ON_RCR_AM, null_addr);
+	padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_ON_RCR_AM, null_addr);
 
 	return H2C_SUCCESS;
 }
 
 u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 {
-	u16 ctrl=0;
-	u8 cam_id = 0;//cam_entry
+	u16 ctrl = 0;
+	s16 cam_id = 0;
 	u8 ret = H2C_SUCCESS;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -11870,96 +11943,38 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
 #endif //CONFIG_TDLS
 
-	//cam_entry:
-	//0~3 for default key
-
-	//for concurrent mode (ap+sta, sta+sta):
-	//default key is disable, using sw encrypt/decrypt
-	//camid 0, 1, 2, 3 is default entry for default key/group key
-	//macid = 1 is for bc/mc stainfo, no mapping to camid
-	//macid = 0 mapping to camid 4
-	//for macid >=2, camid = macid+3;
+	if(pparm->algorithm == _NO_PRIVACY_)
+		goto write_to_cam;
 
-
-	if(pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
-	{
-		clear_cam_entry(padapter, pparm->id);
-		ret = H2C_SUCCESS;
-		goto exit_set_stakey_hdl;
+	psta = rtw_get_stainfo(pstapriv, pparm->addr);
+	if (!psta) {
+		DBG_871X_LEVEL(_drv_always_, "%s sta:"MAC_FMT" not found\n", __func__, MAC_ARG(pparm->addr));
+		ret = H2C_REJECTED;
+		goto exit;
 	}
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-	{
-		psta = rtw_get_stainfo(pstapriv, pparm->addr);
-		if(psta)
-		{
-			ctrl = (BIT(15) | ((pparm->algorithm) << 2));
-
-			DBG_871X("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);
-
-			if((psta->mac_id == 1) || (psta->mac_id>(NUM_STA-4)))
-			{
-				DBG_871X("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);
-				ret = H2C_REJECTED;
-				goto exit_set_stakey_hdl;
-			}
-
-			cam_id = (u8)rtw_get_camid(psta->mac_id);//0~3 for default key, cmd_id=macid + 3;
-
-			DBG_871X("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0],
-						pparm->addr[1], pparm->addr[2], pparm->addr[3], pparm->addr[4],
-						pparm->addr[5], cam_id);
-
-			write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
-
-			ret = H2C_SUCCESS_RSP;
-			goto exit_set_stakey_hdl;
+	pmlmeinfo->enc_algo = pparm->algorithm;
+	cam_id = rtw_camid_alloc(padapter, psta, 0);
+	if (cam_id < 0)
+		goto exit;
 
+write_to_cam:
+	if(pparm->algorithm == _NO_PRIVACY_) {
+		while((cam_id = rtw_camid_search(padapter, pparm->addr, -1)) >= 0) {
+			DBG_871X_LEVEL(_drv_always_, "clear key for addr:"MAC_FMT", camid:%d\n", MAC_ARG(pparm->addr), cam_id);
+			clear_cam_entry(padapter, cam_id);
+			rtw_camid_free(padapter,cam_id);
 		}
-		else
-		{
-			DBG_871X("r871x_set_stakey_hdl(): sta has been free\n");
-			ret = H2C_REJECTED;
-			goto exit_set_stakey_hdl;
-		}
-
-	}
-
-
-	//below for sta mode
-
-	if((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)))
-		cam_id = (u8)rtw_get_camid(psta->mac_id);
-	else
-		cam_id = 4;
-
-	ctrl = BIT(15) | ((pparm->algorithm) << 2);
-
-#ifdef CONFIG_TDLS
-	if(ptdlsinfo->clear_cam!=0){
-		clear_cam_entry(padapter, ptdlsinfo->clear_cam);
-		ptdlsinfo->clear_cam=0;
-		ret = H2C_SUCCESS;
-		goto exit_set_stakey_hdl;
-	}
-
-	psta = rtw_get_stainfo(pstapriv, pparm->addr);//Get TDLS Peer STA
-	if( psta->tdls_sta_state&TDLS_LINKED_STATE ){
-		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
-	}
-	else
-#endif //CONFIG_TDLS
+	} else {
+		DBG_871X_LEVEL(_drv_always_, "set pairwise key camid:%d, addr:"MAC_FMT", kid:%d, type:%s\n",
+			cam_id, MAC_ARG(pparm->addr), pparm->keyid, security_type_str(pparm->algorithm));
+		ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;
 		write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
+	}
+	ret = H2C_SUCCESS_RSP;
 
-	pmlmeinfo->enc_algo = pparm->algorithm;
-
-exit_set_stakey_hdl:
-
-	DBG_871X_LEVEL(_drv_always_, "set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
-		       	pparm->algorithm, cam_id);
-
+exit:
 	return ret;
-
 }
 
 u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf)
@@ -12002,6 +12017,31 @@ u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf)
 	return 	H2C_SUCCESS;
 }
 
+u8 chk_bmc_sleepq_cmd(_adapter* padapter)
+{
+	struct cmd_obj *ph2c;
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_parm_rsp(ph2c, GEN_CMD_CODE(_ChkBMCSleepq));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
 u8 set_tx_beacon_cmd(_adapter* padapter)
 {
 	struct cmd_obj	*ph2c;
@@ -12011,15 +12051,15 @@ u8 set_tx_beacon_cmd(_adapter* padapter)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8	res = _SUCCESS;
 	int len_diff = 0;
-	
-_func_enter_;	
-	
+
+_func_enter_;
+
 	if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
 	{
 		res= _FAIL;
 		goto exit;
 	}
-	
+
 	if ((ptxBeacon_parm = (struct Tx_Beacon_param *)rtw_zmalloc(sizeof(struct Tx_Beacon_param))) == NULL)
 	{
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
@@ -12028,21 +12068,20 @@ _func_enter_;
 	}
 
 	_rtw_memcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
-	
+
 	len_diff = update_hidden_ssid(
 		ptxBeacon_parm->network.IEs+_BEACON_IE_OFFSET_
 		, ptxBeacon_parm->network.IELength-_BEACON_IE_OFFSET_
 		, pmlmeinfo->hidden_ssid_mode
 	);
 	ptxBeacon_parm->network.IELength += len_diff;
-		
+
 	init_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
-	
 exit:
-	
+
 _func_exit_;
 
 	return res;
@@ -12121,87 +12160,87 @@ u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf)
 	return H2C_SUCCESS;
 }
 
-u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
+u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf)
 {
-	if(send_beacon(padapter)==_FAIL)
-	{
-		DBG_871X("issue_beacon, fail!\n");
-		return H2C_PARAMETERS_ERROR;
-	}
 #ifdef CONFIG_AP_MODE
-	else //tx bc/mc frames after update TIM 
-	{	
-		_irqL irqL;
-		struct sta_info *psta_bmc;
-		_list	*xmitframe_plist, *xmitframe_phead;
-		struct xmit_frame *pxmitframe=NULL;
-		struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-		struct sta_priv  *pstapriv = &padapter->stapriv;
-		
-		//for BC/MC Frames
-		psta_bmc = rtw_get_bcmc_stainfo(padapter);
-		if(!psta_bmc)
-			return H2C_SUCCESS;
-	
-		if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0))
-		{				
+	_irqL irqL;
+	struct sta_info *psta_bmc;
+	_list	*xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe=NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct sta_priv  *pstapriv = &padapter->stapriv;
+
+	//for BC/MC Frames
+	psta_bmc = rtw_get_bcmc_stainfo(padapter);
+	if(!psta_bmc)
+		return H2C_SUCCESS;
+
+	if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0))
+	{
 #ifndef CONFIG_PCI_HCI
-			rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
+		rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
 #endif
-			//_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-			_enter_critical_bh(&pxmitpriv->lock, &irqL);
+		//_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+		_enter_critical_bh(&pxmitpriv->lock, &irqL);
 
-			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
-			xmitframe_plist = get_next(xmitframe_phead);
+		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
+		xmitframe_plist = get_next(xmitframe_phead);
 
-			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-			{			
-				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+		{
+			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
-				xmitframe_plist = get_next(xmitframe_plist);
+			xmitframe_plist = get_next(xmitframe_plist);
 
-				rtw_list_delete(&pxmitframe->list);
+			rtw_list_delete(&pxmitframe->list);
 
-				psta_bmc->sleepq_len--;
-				if(psta_bmc->sleepq_len>0)
-					pxmitframe->attrib.mdata = 1;
-				else
-					pxmitframe->attrib.mdata = 0;
+			psta_bmc->sleepq_len--;
+			if(psta_bmc->sleepq_len>0)
+				pxmitframe->attrib.mdata = 1;
+			else
+				pxmitframe->attrib.mdata = 0;
 
-				pxmitframe->attrib.triggered=1;
+			pxmitframe->attrib.triggered=1;
 
+			if (xmitframe_hiq_filter(pxmitframe) == _TRUE)
 				pxmitframe->attrib.qsel = 0x11;//HIQ
 
-#if 0
-				_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-				if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-				{		
-					rtw_os_xmit_complete(padapter, pxmitframe);
-				}
-				_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-
-#endif
-				rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
+			#if 0
+			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+			{
+				rtw_os_xmit_complete(padapter, pxmitframe);
+			}
+			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			#endif
+			rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
+		}
 
-				//pstapriv->tim_bitmap &= ~BIT(0);				
-		
-			}	
-	
-			//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
-			_exit_critical_bh(&pxmitpriv->lock, &irqL);
+		//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+		_exit_critical_bh(&pxmitpriv->lock, &irqL);
 
-//#if defined(CONFIG_PCI_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+		if (padapter->interface_type != RTW_PCIE) {
+			/* check hi queue and bmc_sleepq */
 			rtw_chk_hi_queue_cmd(padapter);
+		}
+	}
 #endif
 
-		}
+	return H2C_SUCCESS;
+}
 
+u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	if(send_beacon(padapter)==_FAIL)
+	{
+		DBG_871X("issue_beacon, fail!\n");
+		return H2C_PARAMETERS_ERROR;
 	}
-#endif
+
+	/* tx bc/mc frames after update TIM */
+	chk_bmc_sleepq_hdl(padapter, NULL);
 
 	return H2C_SUCCESS;
-	
 }
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_p2p.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_p2p.c
index f786bbe0cd7f..dcb7dc75e6cc 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_p2p.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_p2p.c
@@ -3432,6 +3432,8 @@ _func_exit_;
 void p2p_concurrent_handler( _adapter*	padapter )
 {
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	//_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
 	//struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
@@ -3472,9 +3474,12 @@ _func_enter_;
 					}
 
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-					val8 = 1;
-					rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-
+					if(!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
+					!(pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+					{	
+						val8 = 1;
+						rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					}
 					//	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not.
 					_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period );
 				}
@@ -3494,8 +3499,12 @@ _func_enter_;
 				if ( pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel )
 				{
 					set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-					val8 = 0;
-					padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					if(!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&	
+					!(pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+					{
+						val8 = 0;
+						padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					}
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
 					issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 				}
@@ -3588,6 +3597,9 @@ _func_enter_;
 
 	pcfg80211_wdinfo->is_ro_ch = _FALSE;
 
+	if (pcfg80211_wdinfo->not_indic_ro_ch_exp == _TRUE)
+		return;
+
 	DBG_871X("cfg80211_remain_on_channel_expired\n");
 
 	rtw_cfg80211_remain_on_channel_expired(padapter, 
@@ -5273,6 +5285,11 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_NONE);
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
 			_rtw_memset(&pwdinfo->rx_prov_disc_info, 0x00, sizeof(struct rx_provdisc_req_info));
+
+			/* Remove profiles in wifidirect_info structure. */
+			_rtw_memset( &pwdinfo->profileinfo[ 0 ], 0x00, sizeof( struct profile_info ) * P2P_MAX_PERSISTENT_GROUP_NUM );
+			pwdinfo->profileindex = 0;
+
 		}
 
 		rtw_hal_set_odm_var(padapter,HAL_ODM_P2P_STATE,NULL,_FALSE);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_recv.c
index a6c6a2e13cc3..ed32eb40e49c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_recv.c
@@ -1682,12 +1682,12 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 
 				if(psta->sleepq_len>0)
 					pxmitframe->attrib.mdata = 1;
-                                else
+				else
 					pxmitframe->attrib.mdata = 0;
 
 				pxmitframe->attrib.triggered = 1;
 
-	                        //DBG_871X("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
+				//DBG_871X("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 #if 0
                                 _exit_critical_bh(&psta->sleep_q.lock, &irqL);	
@@ -1707,7 +1707,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);		
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 				}
 				
 				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
@@ -1727,7 +1727,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 						DBG_871X("no buffered packets to xmit\n");
 
 						//issue nulldata with More data bit = 0 to indicate we have no buffered packets
-						issue_nulldata(padapter, psta->hwaddr, 0, 0, 0);
+						issue_nulldata_in_interrupt(padapter, psta->hwaddr);
 					}
 					else
 					{
@@ -1739,7 +1739,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 				}
 				
 			}				
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_security.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_security.c
index 66df244eeaf7..a5d2a28ad165 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_security.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_security.c
@@ -25,6 +25,85 @@
 #include <wifi.h>
 #include <osdep_intf.h>
 
+static const char *_security_type_str[] = {
+	"N/A",
+	"WEP40",
+	"TKIP",
+	"TKIP_WM",
+	"AES",
+	"WEP104",
+	"SMS4",
+	"WEP_WPA",
+	"BIP",
+};
+
+const char *security_type_str(u8 value)
+{
+#ifdef CONFIG_IEEE80211W
+	if (value <= _BIP_)
+#else
+	if (value <= _WEP_WPA_MIXED_)
+#endif
+		return _security_type_str[value];
+	return NULL;
+}
+
+#ifdef DBG_SW_SEC_CNT
+#define WEP_SW_ENC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->wep_sw_enc_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->wep_sw_enc_cnt_mc++; \
+	else \
+		sec->wep_sw_enc_cnt_uc++;
+
+#define WEP_SW_DEC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->wep_sw_dec_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->wep_sw_dec_cnt_mc++; \
+	else \
+		sec->wep_sw_dec_cnt_uc++;
+
+#define TKIP_SW_ENC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->tkip_sw_enc_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->tkip_sw_enc_cnt_mc++; \
+	else \
+		sec->tkip_sw_enc_cnt_uc++;
+
+#define TKIP_SW_DEC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->tkip_sw_dec_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->tkip_sw_dec_cnt_mc++; \
+	else \
+		sec->tkip_sw_dec_cnt_uc++;
+
+#define AES_SW_ENC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->aes_sw_enc_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->aes_sw_enc_cnt_mc++; \
+	else \
+		sec->aes_sw_enc_cnt_uc++;
+
+#define AES_SW_DEC_CNT_INC(sec, ra) \
+	if (is_broadcast_mac_addr(ra)) \
+		sec->aes_sw_dec_cnt_bc++; \
+	else if (is_multicast_mac_addr(ra)) \
+		sec->aes_sw_dec_cnt_mc++; \
+	else \
+		sec->aes_sw_dec_cnt_uc++;
+#else
+#define WEP_SW_ENC_CNT_INC(sec, ra)
+#define WEP_SW_DEC_CNT_INC(sec, ra)
+#define TKIP_SW_ENC_CNT_INC(sec, ra)
+#define TKIP_SW_DEC_CNT_INC(sec, ra)
+#define AES_SW_ENC_CNT_INC(sec, ra)
+#define AES_SW_DEC_CNT_INC(sec, ra)
+#endif /* DBG_SW_SEC_CNT */
 
 //=====WEP related===== 
 
@@ -233,7 +312,8 @@ _func_enter_;
 			}
 			
 		}		
-						
+
+		WEP_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);
 	}
 	
 _func_exit_;						
@@ -281,8 +361,9 @@ _func_enter_;
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
-		}	
-						
+		}
+
+		WEP_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
 	}
 	
 _func_exit_;		
@@ -754,7 +835,7 @@ _func_enter_;
 				}
 			}
 
-
+			TKIP_SW_ENC_CNT_INC(psecuritypriv,pattrib->ra);
 		}
 		else{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo==NULL!!!\n"));
@@ -844,7 +925,6 @@ _func_enter_;
 			}
 			else
 			{
-			        RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo!=NULL!!!\n"));
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 				prwskeylen=16;
 			}
@@ -874,8 +954,8 @@ _func_enter_;
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
 				res=_FAIL;
 			}
-						
-		
+
+			TKIP_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
 		}
 		else{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo==NULL!!!\n"));
@@ -1681,7 +1761,7 @@ _func_enter_;
 				}
 			}
 
-
+			AES_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);
 		}
 		else{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
@@ -2004,7 +2084,6 @@ _func_enter_;
 				static u32 no_gkey_bc_cnt = 0;
 				static u32 no_gkey_mc_cnt = 0;
 
-				//in concurrent we should use sw descrypt in group key, so we remove this message			
 				//DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
 				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
 				if(psecuritypriv->binstallGrpkey==_FALSE)
@@ -2080,10 +2159,10 @@ _func_enter_;
 
 			res= aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
 
-
+			AES_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
 		}
 		else{
-			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
 						
@@ -3127,9 +3206,9 @@ void rtw_sec_restore_wep_key(_adapter *adapter)
 		for(keyid=0;keyid<4;keyid++){
 			if(securitypriv->key_mask & BIT(keyid)){
 				if(keyid == securitypriv->dot11PrivacyKeyIndex)
-					rtw_set_key(adapter,securitypriv, keyid, 1, _TRUE);
+					rtw_set_key(adapter,securitypriv, keyid, 1, _FALSE);
 				else
-					rtw_set_key(adapter,securitypriv, keyid, 0, _TRUE);
+					rtw_set_key(adapter,securitypriv, keyid, 0, _FALSE);
 			}
 		}
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_sreset.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_sreset.c
index bc34827b492b..25812b83e267 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_sreset.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_sreset.c
@@ -161,7 +161,7 @@ void sreset_restore_security_station(_adapter *padapter)
 		else
 		{
 			//pairwise key
-			rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE,_FALSE);
+			rtw_setstakey_cmd(padapter, psta, _TRUE,_FALSE);
 			//group key
 			rtw_set_key(padapter,&padapter->securitypriv,padapter->securitypriv.dot118021XGrpKeyid, 0,_FALSE);
 		}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_tdls.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_tdls.c
index f7ca24aab826..c2a8279fbe35 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_tdls.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_tdls.c
@@ -294,7 +294,7 @@ void rtw_tdls_set_key(_adapter *adapter, struct rx_pkt_attrib *prx_pkt_attrib, s
 	if(prx_pkt_attrib->encrypt)
 	{
 		ptdls_sta->dot118021XPrivacy=_AES_;
-		rtw_setstakey_cmd(adapter, (u8*)ptdls_sta, _TRUE, _TRUE);
+		rtw_setstakey_cmd(adapter, ptdls_sta, _TRUE, _TRUE);
 	}
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_wlan_util.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_wlan_util.c
index 0e7153d38a3e..5488ef05b1bf 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_wlan_util.c
@@ -59,6 +59,9 @@ extern unsigned char RSN_TKIP_CIPHER[4];
 #define WAIT_FOR_BCN_TO_MIN	(6000)
 #define WAIT_FOR_BCN_TO_MAX	(20000)
 
+#define DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS 1000
+#define DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD 3
+
 static u8 rtw_basic_rate_cck[4] = {
 	IEEE80211_CCK_RATE_1MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_2MB|IEEE80211_BASIC_RATE_MASK,
 	IEEE80211_CCK_RATE_5MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_11MB|IEEE80211_BASIC_RATE_MASK
@@ -662,9 +665,34 @@ void CAM_empty_entry(
 	rtw_hal_set_hwreg(Adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
 }
 
+#ifdef CONFIG_RTL8192C
+#include <rtl8192c_hal.h>
+#endif
+
+#ifdef CONFIG_RTL8192D
+#include <rtl8192d_hal.h>
+#endif
+
+#ifdef CONFIG_RTL8723A
+#include <rtl8723a_hal.h>
+#endif
+
+#ifdef CONFIG_RTL8188E
+#include <rtl8188e_hal.h>
+#endif
+
 void invalidate_cam_all(_adapter *padapter)
 {
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+
 	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	cam_ctl->bitmap = 0;
+	_rtw_memset(dvobj->cam_cache, 0, sizeof(struct cam_entry_cache)*TOTAL_CAM_ENTRY);
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
 }
 #if 0
 static u32 _ReadCAM(_adapter *padapter ,u32 addr)
@@ -700,80 +728,310 @@ void read_cam(_adapter *padapter ,u8 entry)
 	DBG_8192C("*********************************\n");
 }
 
-
-void write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
+void _write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
 {
-	unsigned int	i, val, addr;
-	//unsigned int    cmd;
+	unsigned int i, val, addr;
 	int j;
 	u32	cam_val[2];
 
 	addr = entry << 3;
 
-	for (j = 5; j >= 0; j--)
-	{	
-		switch (j)
-		{
-			case 0:
-				val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
-				break;
-				
-			case 1:
-				val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
-				break;
-			
-			default:
-				i = (j - 2) << 2;
-				val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
-				break;
-				
+	for (j = 5; j >= 0; j--) {
+		switch (j) {
+		case 0:
+			val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
+			break;
+		case 1:
+			val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+			break;
+		default:
+			i = (j - 2) << 2;
+			val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
+			break;
 		}
 
 		cam_val[0] = val;
 		cam_val[1] = addr + (unsigned int)j;
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
-		
-		//rtw_write32(padapter, WCAMI, val);
-		
-		//cmd = CAM_POLLINIG | CAM_WRITE | (addr + j);
-		//rtw_write32(padapter, RWCAM, cmd);
-		
-		//DBG_871X("%s=> cam write: %x, %x\n",__FUNCTION__, cmd, val);
-		
 	}
+}
 
+void _clear_cam_entry(_adapter *padapter, u8 entry)
+{
+	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00};
+
+	_write_cam(padapter, entry, 0, null_sta, null_key);
 }
 
-void clear_cam_entry(_adapter *padapter, u8 entry)
-{	
-#if 0
-	u32	addr, val=0;
-	u32	cam_val[2];
+inline void write_cam(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)
+{
+#ifdef CONFIG_WRITE_CACHE_ONLY
+	write_cam_cache(adapter, id ,ctrl, mac, key);
+#else
+	_write_cam(adapter, id, ctrl, mac, key);
+	write_cam_cache(adapter, id ,ctrl, mac, key);
+#endif
+}
 
-	addr = entry << 3;
+inline void clear_cam_entry(_adapter *adapter, u8 id)
+{
+	_clear_cam_entry(adapter, id);
+	clear_cam_cache(adapter, id);
+}
+
+inline void write_cam_from_cache(_adapter *adapter, u8 id)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+	struct cam_entry_cache cache;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	_rtw_memcpy(&cache, &dvobj->cam_cache[id], sizeof(struct cam_entry_cache));
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
+
+	_write_cam(adapter, id, cache.ctrl, cache.mac, cache.key);
+}
+
+void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+
+	dvobj->cam_cache[id].ctrl = ctrl;
+	_rtw_memcpy(dvobj->cam_cache[id].mac, mac, ETH_ALEN);
+	_rtw_memcpy(dvobj->cam_cache[id].key, key, 16);
+
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
+}
+
+void clear_cam_cache(_adapter *adapter, u8 id)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+
+	_rtw_memset(&(dvobj->cam_cache[id]), 0, sizeof(struct cam_entry_cache));
+
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
+}
+
+s16 rtw_get_camid(_adapter *adapter, struct sta_info *sta, s16 kid)
+{
+	u8 macid;
+	s16 camid;
+
+	//cam_entry:
+	//0~3 for default key
+
+	//for concurrent mode (ap+sta, sta+sta):
+	//default key is disable, using sw encrypt/decrypt
+	//camid 0, 1, 2, 3 is default entry for default key/group key
+	//macid = 1 is for bc/mc stainfo, no mapping to camid
+	//macid = 0 mapping to camid 4
+	//for macid >=2, camid = macid+3;
+
+	if (sta) {
+		struct mlme_ext_info *mlmeinfo = &adapter->mlmeextpriv.mlmext_info;
+		macid = sta->mac_id;
+
+		if((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {
+			if((macid == 1) || (macid>(NUM_STA-4))){
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" failed, mac_id=%d\n", FUNC_ADPT_ARG(adapter), macid);
+				camid = -1;
+				goto exit;
+			}
+		}
+
+		if(macid==0)
+			camid = 4;
+		else if(macid >=2)
+			camid = macid + 3;
+		else
+			camid = 4;
+	}
+	else {
+		/* default key is disabled */
+		camid = -1;
+	}
+
+exit:
+	return (s16)camid;
+}
+
+bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	bool ret = _FALSE;
+
+	if (cam_id >= TOTAL_CAM_ENTRY)
+		goto exit;
+
+	if (!(cam_ctl->bitmap & BIT(cam_id)))
+		goto exit;
 	
+	ret = (dvobj->cam_cache[cam_id].ctrl&BIT6)?_TRUE:_FALSE;
+
+exit:
+	return ret;
+}
+
+bool rtw_camid_is_gk(_adapter *adapter, u8 cam_id)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+	bool ret;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	ret = _rtw_camid_is_gk(adapter, cam_id);
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
+
+	return ret;
+}
+
+s16 _rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	int i;
+	s16 cam_id = -1;
 
-	cam_val[0] = val;
-	cam_val[1] = addr + (unsigned int)0;
+	for (i=0;i<TOTAL_CAM_ENTRY;i++) {
+		if (addr && _rtw_memcmp(dvobj->cam_cache[i].mac, addr, ETH_ALEN) == _FALSE)
+			continue;
+		if (kid >= 0 && kid != (dvobj->cam_cache[i].ctrl&0x03))
+			continue;
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
+		cam_id = i;
+		break;
+	}
+
+	if (0) {
+		if (addr)
+			DBG_871X(FUNC_ADPT_FMT" addr:"MAC_FMT" kid:%d, return cam_id:%d\n"
+				, FUNC_ADPT_ARG(adapter), MAC_ARG(addr), kid, cam_id);
+		else
+			DBG_871X(FUNC_ADPT_FMT" addr:%p kid:%d, return cam_id:%d\n"
+				, FUNC_ADPT_ARG(adapter), addr, kid, cam_id);
+	}
+
+	return cam_id;
+}
+
+s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+	s16 cam_id = -1;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	cam_id = _rtw_camid_search(adapter, addr, kid);
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
+
+	return cam_id;
+}
+
+s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+	s16 cam_id = -1;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+
+#ifdef DYNAMIC_CAMID_ALLOC
+	{
+		struct mlme_ext_info *mlmeinfo = &adapter->mlmeextpriv.mlmext_info;
+
+		if((((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) || ((mlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
+			&& !sta) {
+			/* AP/Ad-hoc mode group key: static alloction to default key by key ID */
+			if (kid > 3) {
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key with invalid key id:%u\n"
+					, FUNC_ADPT_ARG(adapter), kid);
+				rtw_warn_on(1);
+				goto bitmap_handle;
+			}
 
+			cam_id = kid;
+		}
+		else {
+			int i;
+			u8 *addr = sta?sta->hwaddr:NULL;
+
+			if(!sta) {
+				if (!(mlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
+					/* bypass STA mode group key setting before connected(ex:WEP) because bssid is not ready */
+					goto bitmap_handle;
+				}
+
+				addr = get_bssid(&adapter->mlmepriv);
+			}
+
+			if ((i = _rtw_camid_search(adapter, addr, kid)) >= 0) {
+				/* Fix issue that pairwise and group key have same key id. Pairwise key first, group key can overwirte group only(ex: rekey) */
+				if (sta || _rtw_camid_is_gk(adapter, i) == _TRUE)
+					cam_id = i;
+				else
+					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"
+						, FUNC_ADPT_ARG(adapter), kid);
+				goto bitmap_handle;
+			}
 
+			for (i=4;i<TOTAL_CAM_ENTRY;i++)
+				if (!(cam_ctl->bitmap & BIT(i)))
+					break;
 
-	cam_val[0] = val;
-	cam_val[1] = addr + (unsigned int)1;
+			if (i == TOTAL_CAM_ENTRY) {
+				if (sta)
+					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pairwise key with "MAC_FMT" id:%u no room\n"
+					, FUNC_ADPT_ARG(adapter), MAC_ARG(sta->hwaddr), kid);
+				else
+					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u no room\n"
+					, FUNC_ADPT_ARG(adapter), kid);
+				rtw_warn_on(1);
+				goto bitmap_handle;
+			}
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
+			cam_id = i;
+		}
+	}
 #else
+	cam_id = rtw_get_camid(adapter, sta, kid);
+#endif /* DYNAMIC_CAMID_ALLOC */
 
-	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+bitmap_handle:
+	if (cam_id >= 0)
+		cam_ctl->bitmap |= BIT(cam_id);
 
-	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00};
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
 
-	write_cam(padapter, entry, 0, null_sta, null_key);
+	return cam_id;
+}
 
-#endif
+void rtw_camid_free(_adapter *adapter, u8 cam_id)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	_irqL irqL;
+
+	_enter_critical_bh(&cam_ctl->lock, &irqL);
+
+	if (cam_id < TOTAL_CAM_ENTRY)
+		cam_ctl->bitmap &= ~(BIT(cam_id));
+
+	_exit_critical_bh(&cam_ctl->lock, &irqL);
 }
 
 int allocate_fw_sta_entry(_adapter *padapter)
@@ -797,49 +1055,58 @@ int allocate_fw_sta_entry(_adapter *padapter)
 
 void flush_all_cam_entry(_adapter *padapter)
 {
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-#ifdef CONFIG_CONCURRENT_MODE
-
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	//if(check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))	
-	if(check_buddy_fwstate(padapter, _FW_LINKED) == _FALSE)
-	{
-		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);		
-	}
-	else
+#ifdef CONFIG_CONCURRENT_MODE
+	if(check_buddy_fwstate(padapter, _FW_LINKED) == _TRUE)
 	{
 		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 		{
 			struct sta_priv	*pstapriv = &padapter->stapriv;
 			struct sta_info	*psta;
-			u8 cam_id;//cam_entry
 
 			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 			if(psta) {
 				if(psta->state & WIFI_AP_STATE)
 				{}   //clear cam when ap free per sta_info        
 				else {
-
-					cam_id = (u8)rtw_get_camid(psta->mac_id);
-
-					//clear_cam_entry(padapter, cam_id);
-					rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, _FALSE);
-				}				
+					rtw_clearstakey_cmd(padapter, psta, _FALSE);
+				}
 			}
 		}
 		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 		{
-			//clear cam when ap free per sta_info 
-		}			
-	}
-#else //CONFIG_CONCURRENT_MODE
+			/* clear default key */
+			int i, cam_id;
+			u8 null_addr[ETH_ALEN]= {0,0,0,0,0,0};
+
+			for (i=0;i<4;i++) {
+				cam_id = rtw_camid_search(padapter, null_addr, i);
+				if (cam_id >= 0) {
+					clear_cam_entry(padapter, cam_id);
+					rtw_camid_free(padapter, cam_id);
+				}
+			}
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);	
+			/* clear default key related key search setting */
+			#ifdef DYNAMIC_CAMID_ALLOC
+			rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
+			#endif
 
+			/* leave pairwise key when ap free per sta_info */
+		}
+	}
+	else
 #endif //CONFIG_CONCURRENT_MODE
+	{
+		invalidate_cam_all(padapter);
+		/* clear default key related key search setting */
+		#ifdef DYNAMIC_CAMID_ALLOC
+		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
+		#endif
+	}
 
 	_rtw_memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
 	
@@ -1437,6 +1704,7 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	u32 bcn_channel;
 	unsigned short 	ht_cap_info;
 	unsigned char	ht_info_infos_0;
+	struct mlme_priv *pmlmepriv = &Adapter->mlmepriv;
 
 	if (is_client_associated_to_ap(Adapter) == _FALSE)
 		return _TRUE;
@@ -1456,6 +1724,12 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 
 	bssid = (WLAN_BSSID_EX *)rtw_zmalloc(sizeof(WLAN_BSSID_EX));
 
+	if ((pmlmepriv->timeBcnInfoChkStart != 0) && (rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart) > DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS))
+	{
+		pmlmepriv->timeBcnInfoChkStart = 0;
+		pmlmepriv->NumOfBcnInfoChkFail = 0;
+	}
+
 	subtype = GetFrameSubType(pframe) >> 4;
 
 	if(subtype==WIFI_BEACON)
@@ -1490,7 +1764,7 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 						   	ht_cap_info, ht_info_infos_0);
 			DBG_871X("%s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
 						   	cur_network->BcnInfo.ht_cap_info, cur_network->BcnInfo.ht_info_infos_0);
-			DBG_871X("%s bw mode change, disconnect\n", __func__);
+			DBG_871X("%s bw mode change\n", __func__);
 			{	
 				//bcn_info_update
 				cur_network->BcnInfo.ht_cap_info = ht_cap_info;
@@ -1543,7 +1817,7 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	if (_rtw_memcmp(bssid->Ssid.Ssid, cur_network->network.Ssid.Ssid, 32) == _FALSE ||
 			bssid->Ssid.SsidLength != cur_network->network.Ssid.SsidLength) {
 		if (bssid->Ssid.Ssid[0] != '\0' && bssid->Ssid.SsidLength != 0) { /* not hidden ssid */
-			DBG_871X("%s(), SSID is not match return FAIL\n", __func__);
+			DBG_871X("%s(), SSID is not match\n", __func__);
 			goto _mismatch;
 		}
 	}
@@ -1560,7 +1834,7 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 			("%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",
 			 __func__, cur_network->network.Privacy,bssid->Privacy));
 	if (cur_network->network.Privacy != bssid->Privacy) {
-		DBG_871X("%s(), privacy is not match return FAIL\n",__func__);
+		DBG_871X("%s(), privacy is not match\n",__func__);
 		goto _mismatch;
 	}
 
@@ -1576,7 +1850,7 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	}
 
 	if (cur_network->BcnInfo.encryp_protocol != encryp_protocol) {
-		DBG_871X("%s(): enctyp is not match ,return FAIL\n",__func__);
+		DBG_871X("%s(): enctyp is not match\n",__func__);
 		goto _mismatch;
 	}
 
@@ -1603,14 +1877,14 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,
 				("%s cur_network->group_cipher is %d: %d\n",__func__, cur_network->BcnInfo.group_cipher, group_cipher));
 		if (pairwise_cipher != cur_network->BcnInfo.pairwise_cipher || group_cipher != cur_network->BcnInfo.group_cipher) {
-			DBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match ,return FAIL\n",__func__,
+			DBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match\n",__func__,
 					pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
 					group_cipher, cur_network->BcnInfo.group_cipher);
 			goto _mismatch;
 		}
 
 		if (is_8021x != cur_network->BcnInfo.is_8021x) {
-			DBG_871X("%s authentication is not match ,return FAIL\n", __func__);
+			DBG_871X("%s authentication is not match\n", __func__);
 			goto _mismatch;
 		}
 	}
@@ -1620,9 +1894,26 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 
 _mismatch:
 	rtw_mfree((u8 *)bssid, sizeof(WLAN_BSSID_EX));
-	return _FAIL;
 
-	_func_exit_;
+	if (pmlmepriv->NumOfBcnInfoChkFail == 0)
+	{
+		pmlmepriv->timeBcnInfoChkStart = rtw_get_current_time();
+	}
+
+	pmlmepriv->NumOfBcnInfoChkFail++;
+	DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d (SeqNum of this Beacon frame = %d).\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail, GetSequence(pframe));
+
+	if ((pmlmepriv->timeBcnInfoChkStart != 0) && (rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart) <= DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS) 
+		&& (pmlmepriv->NumOfBcnInfoChkFail >= DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD))
+	{
+		DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d >= threshold : %d (in %d ms), return FAIL.\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail, 
+			DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD, rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart));
+		pmlmepriv->timeBcnInfoChkStart = 0;
+		pmlmepriv->NumOfBcnInfoChkFail = 0;
+		return _FAIL;
+	}
+
+	return _SUCCESS;
 }
 
 void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
@@ -2440,25 +2731,6 @@ void beacon_timing_control(_adapter *padapter)
 	rtw_hal_bcn_related_reg_setting(padapter);
 }
 
-uint rtw_get_camid(uint macid)
-{
-	uint camid;
-
-	//camid 0, 1, 2, 3 is default entry for default key/group key
-	//macid = 1 is for bc/mc stainfo, no mapping to camid
-	//macid = 0 mapping to camid 4
-	//for macid >=2, camid = macid+3;
-
-	if(macid==0)
-		camid = 4;
-	else if(macid >=2)
-		camid = macid + 3;
-	else
-		camid = 4;
-
-	return camid;
-}
-
 void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta)
 {
 	int i;
@@ -2772,3 +3044,47 @@ void rtw_set_sec_iv(PADAPTER padapter)
 		}
 }
 #endif //CONFIG_WOWLAN
+
+/*
+ * Description:
+ * rtw_check_invalid_mac_address: 
+ * This is only used for checking mac address valid or not.
+ *
+ * Input:
+ * adapter: mac_address pointer.
+ *
+ * Output:
+ * _TRUE: The mac address is invalid.
+ * _FALSE: The mac address is valid.
+ *
+ * Auther: Isaac.Li
+ */
+u8 rtw_check_invalid_mac_address(u8 *mac_addr) {
+	u8 null_mac_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
+	u8 multi_mac_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	u8 res = _FALSE;
+
+	if (_rtw_memcmp(mac_addr, null_mac_addr, ETH_ALEN)) {
+		res = _TRUE;
+		goto func_exit;
+	}
+
+	if (_rtw_memcmp(mac_addr, multi_mac_addr, ETH_ALEN)) {
+		res = _TRUE;
+		goto func_exit;
+	}
+
+	if (mac_addr[0] & BIT0) {
+		res = _TRUE;
+		goto func_exit;
+	}
+
+	if (mac_addr[0] & BIT1) {
+		res = _TRUE;
+		goto func_exit;
+	}
+
+func_exit:
+	return res;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_xmit.c
index ee5e9fe77897..6b5c31e04226 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/core/rtw_xmit.c
@@ -603,8 +603,10 @@ static void update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitf
 	}
 }
 
-static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
+static void update_attrib_phy_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta)
 {
+	struct mlme_ext_priv *mlmeext = &padapter->mlmeextpriv;
+
 	/*if(psta->rtsen)	
 		pattrib->vcs_mode = RTS_CTS;	
 	else if(psta->cts2self)	
@@ -622,7 +624,10 @@ static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *
 	pattrib->raid = psta->raid;
 #ifdef CONFIG_80211N_HT
 	pattrib->ht_en = psta->htpriv.ht_option;
-	pattrib->bwmode = psta->htpriv.bwmode;
+	if (mlmeext->cur_bwmode < psta->htpriv.bwmode)
+		pattrib->bwmode = mlmeext->cur_bwmode;
+	else
+		pattrib->bwmode = psta->htpriv.bwmode;
 	pattrib->ch_offset = psta->htpriv.ch_offset;
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = _FALSE;
@@ -728,12 +733,12 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
-		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, myid(&padapter->eeprompriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_adhoc);
 	}
 	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 		_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, myid(&padapter->eeprompriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_sta);
 	}
 	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
@@ -970,7 +975,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=_FALSE\n"));
 	}
 
-#ifdef CONFIG_CONCURRENT_MODE
+#if defined(CONFIG_CONCURRENT_MODE) && !defined(DYNAMIC_CAMID_ALLOC)
 	if((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
 	{
 		pattrib->bswenc = _TRUE;//force using sw enc.
@@ -984,7 +989,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 
 	rtw_set_tx_chksum_offload(pkt, pattrib);
 
-	update_attrib_phy_info(pattrib, psta);
+	update_attrib_phy_info(padapter, pattrib, psta);
 
 exit:
 
@@ -1235,7 +1240,6 @@ _func_enter_;
 	if (pattrib->subtype & WIFI_DATA_TYPE)
 	{
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == _TRUE)) {
-			//to_ds = 1, fr_ds = 0;
 #ifdef CONFIG_TDLS
 			if((ptdlsinfo->setup_state == TDLS_LINKED_STATE)){
 				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
@@ -1256,10 +1260,11 @@ _func_enter_;
 			}else
 #endif //CONFIG_TDLS
 			{
+				//to_ds = 1, fr_ds = 0;
 				//Data transfer to AP
 				SetToDs(fctrl);							
 				_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-				_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+				_rtw_memcpy(pwlanhdr->addr2, pattrib->ta, ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
 			} 
 
@@ -1280,7 +1285,7 @@ _func_enter_;
 		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
 			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, pattrib->ta, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 
 			if(psta->qos_option)			
@@ -3588,6 +3593,47 @@ sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_fra
 }
 #endif //CONFIG_TDLS
 
+#define RTW_HIQ_FILTER_ALLOW_ALL 0
+#define RTW_HIQ_FILTER_ALLOW_SPECIAL 1
+#define RTW_HIQ_FILTER_DENY_ALL 2
+
+inline bool xmitframe_hiq_filter(struct xmit_frame *xmitframe)
+{
+	bool allow = _FALSE;
+	_adapter *adapter = xmitframe->padapter;
+	struct registry_priv *registry = &adapter->registrypriv;
+
+if (adapter->interface_type != RTW_PCIE) {
+
+	if (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_SPECIAL) {
+	
+		struct pkt_attrib *attrib = &xmitframe->attrib;
+
+		if (attrib->ether_type == 0x0806
+			|| attrib->ether_type == 0x888e
+			#ifdef CONFIG_WAPI_SUPPORT
+			|| attrib->ether_type == 0x88B4
+			#endif
+			|| attrib->dhcp_pkt
+		) {
+			if (0)
+			DBG_871X(FUNC_ADPT_FMT" ether_type:0x%04x%s\n", FUNC_ADPT_ARG(xmitframe->padapter)
+				, attrib->ether_type, attrib->dhcp_pkt?" DHCP":"");
+			allow = _TRUE;
+		}
+	}
+	else if (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_ALL) {
+		allow = _TRUE;
+	}
+	else if (registry->hiq_filter == RTW_HIQ_FILTER_DENY_ALL) {
+	}
+	else {
+		rtw_warn_on(1);
+	}
+}
+	return allow;
+}
+
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -3599,6 +3645,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	sint bmcst = IS_MCAST(pattrib->ra);
+	bool update_tim = _FALSE;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
@@ -3645,10 +3692,8 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 		//DBG_871X("directly xmit pspoll_triggered packet\n");
 
 		//pattrib->triggered=0;
-
-		if(bmcst)
+		if (bmcst && xmitframe_hiq_filter(pxmitframe) == _TRUE)
 			pattrib->qsel = 0x11;//HIQ
-		
 
 		return ret;
 	}
@@ -3670,13 +3715,23 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 			
 			psta->sleepq_len++;
 
+			if (!(pstapriv->tim_bitmap & BIT(0)))
+				update_tim = _TRUE;
+
 			pstapriv->tim_bitmap |= BIT(0);//
 			pstapriv->sta_dz_bitmap |= BIT(0);
-			
+
 			//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);//tx bc/mc packets after upate bcn
-			
+			if (update_tim == _TRUE) {
+				if (is_broadcast_mac_addr(pattrib->ra))
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer BC");
+				else
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer MC");
+			} else {
+				chk_bmc_sleepq_cmd(padapter);
+			}
+
 			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);				
 			
 			ret = _TRUE;			
@@ -3734,15 +3789,18 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 
 			if(((psta->has_legacy_ac) && (!wmmps_ac)) ||((!psta->has_legacy_ac)&&(wmmps_ac)))
 			{
+				if (!(pstapriv->tim_bitmap & BIT(psta->aid)))
+					update_tim = _TRUE;
+
 				pstapriv->tim_bitmap |= BIT(psta->aid);
 
 				//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
-				if(psta->sleepq_len==1)
+				if(update_tim == _TRUE)
 				{
 					//DBG_871X("sleepq_len==1, update BCNTIM\n");
 					//upate BCN for TIM IE
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer UC");
 				}
 			}
 
@@ -3784,13 +3842,15 @@ static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
 		plist = get_next(plist);	
-		
+
+		pattrib = &pxmitframe->attrib;
+
+		pattrib->triggered = 0;
+        		
 		ret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);	
 
 		if(_TRUE == ret)
 		{
-			pattrib = &pxmitframe->attrib;
-
 			ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
 			ptxservq->qcnt--;
@@ -3949,9 +4009,41 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 */
 		rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
-		
 	}	
-	
+
+	if(psta->sleepq_len==0)
+	{
+#ifdef CONFIG_TDLS
+		if( psta->tdls_sta_state & TDLS_LINKED_STATE )
+		{
+			if(psta->state&WIFI_SLEEP_STATE)
+				psta->state ^= WIFI_SLEEP_STATE;
+
+			goto _exit;
+		}
+#endif //CONFIG_TDLS
+
+		if (pstapriv->tim_bitmap & BIT(psta->aid)) {
+			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
+			//upate BCN for TIM IE
+			//update_BCNTIM(padapter);
+			update_mask = BIT(0);
+		}
+
+		pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+		if(psta->state&WIFI_SLEEP_STATE)
+			psta->state ^= WIFI_SLEEP_STATE;
+
+		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
+		{
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+	}
+
 	//for BC/MC Frames
 	if(!psta_bmc)
 		goto _exit;
@@ -3992,46 +4084,17 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	
 		if(psta_bmc->sleepq_len==0)
 		{
+			if (pstapriv->tim_bitmap & BIT(0)) {
+				//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
+				//upate BCN for TIM IE
+				//update_BCNTIM(padapter);
+				update_mask |= BIT(1);
+			}
+
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
-
-			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-			//upate BCN for TIM IE
-			//update_BCNTIM(padapter);
-			update_mask |= BIT(1);
-		}		
-	
-	}	
-
-	if(psta->sleepq_len==0)
-	{
-#ifdef CONFIG_TDLS
-		if( psta->tdls_sta_state & TDLS_LINKED_STATE )
-		{
-			if(psta->state&WIFI_SLEEP_STATE)
-				psta->state ^= WIFI_SLEEP_STATE;
-
-			goto _exit;
-		}
-#endif //CONFIG_TDLS
-		pstapriv->tim_bitmap &= ~BIT(psta->aid);
-
-		//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-		//upate BCN for TIM IE
-		//update_BCNTIM(padapter);
-		update_mask = BIT(0);
-
-		if(psta->state&WIFI_SLEEP_STATE)
-			psta->state ^= WIFI_SLEEP_STATE;
-
-		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
-		{
-			psta->expire_to = pstapriv->expire_to;
-			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
 		}
-
-		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
-	}
+	}	
 
 _exit:
 
@@ -4041,9 +4104,13 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	if(update_mask)
 	{
 		//update_BCNTIM(padapter);
-		//printk("%s => call update_beacon\n",__FUNCTION__);
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
-	}	
+		if ((update_mask & (BIT(0)|BIT(1))) == (BIT(0)|BIT(1)))
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear UC&BMC");
+		else if ((update_mask & BIT(1)) == BIT(1))
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear BMC");
+		else
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear UC");
+	}
 	
 }
 
@@ -4134,7 +4201,7 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
 			//upate BCN for TIM IE
 			//update_BCNTIM(padapter);
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+			update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
 			//update_mask = BIT(0);
 		}
 	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.c
index a11a8154448f..8c84a03d157f 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.c
@@ -710,8 +710,12 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_MP)
 		// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 		pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, PWDB_ALL));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		pPhyInfo->SignalStrength = (u1Byte)PWDB_ALL;
 #else
 		pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, PWDB_ALL));//PWDB_ALL;
+#endif
 #endif
 	}
 	else
@@ -721,8 +725,13 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_MP)
 			// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 			pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, total_rssi/=rf_rx_num));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+			total_rssi/=rf_rx_num;
+			pPhyInfo->SignalStrength = (u1Byte)total_rssi;
 #else
 			pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, total_rssi/=rf_rx_num));
+#endif
 #endif
 		}
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.h
index 9b53a8aa3361..2799a27e9c56 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/odm_HWConfig.h
@@ -188,6 +188,13 @@ HAL_STATUS
 ODM_ConfigMACWithHeaderFile(
 	IN  	PDM_ODM_T	pDM_Odm
     );
+
+s4Byte
+odm_SignalScaleMapping(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN	s4Byte CurrSig 
+	);
+
 #endif
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723SHWImg_CE.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723SHWImg_CE.c
index e4e646eed982..7b634355ae6a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723SHWImg_CE.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723SHWImg_CE.c
@@ -5267,7 +5267,7 @@ const u32 Rtl8723SPHY_REG_1TArray[Rtl8723SPHY_REG_1TArrayLength] = {
 0x908,0x00000000,
 0x90c,0x81121111,
 0xa00,0x00d047c8,
-0xa04,0x80ff000c,
+0xa04,0x80ff800c,
 0xa08,0x8c838300,
 0xa0c,0x2e68120f,
 0xa10,0x9500bb78,
@@ -5341,7 +5341,7 @@ const u32 Rtl8723SPHY_REG_1TArray[Rtl8723SPHY_REG_1TArrayLength] = {
 0xce4,0x00000000,
 0xce8,0x37644302,
 0xcec,0x2f97d40c,
-0xd00,0x00080740,
+0xd00,0x00000740,
 0xd04,0x00020401,
 0xd08,0x0000907f,
 0xd0c,0x20010201,
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723UHWImg_CE.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723UHWImg_CE.c
index a6f106df8b3f..c0fe819e8f74 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723UHWImg_CE.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/OUTSRC/rtl8723a/Hal8723UHWImg_CE.c
@@ -5369,7 +5369,7 @@ u32 Rtl8723UPHY_REG_1TArray[Rtl8723UPHY_REG_1TArrayLength] = {
 0x908,0x00000000,
 0x90c,0x81121111,
 0xa00,0x00d047c8,
-0xa04,0x80ff000c,
+0xa04,0x80ff800c,
 0xa08,0x8c838300,
 0xa0c,0x2e68120f,
 0xa10,0x9500bb78,
@@ -5443,7 +5443,7 @@ u32 Rtl8723UPHY_REG_1TArray[Rtl8723UPHY_REG_1TArrayLength] = {
 0xce4,0x00000000,
 0xce8,0x37644302,
 0xcec,0x2f97d40c,
-0xd00,0x00080740,
+0xd00,0x00000740,
 0xd04,0x00020401,
 0xd08,0x0000907f,
 0xd0c,0x20010201,
@@ -5568,7 +5568,7 @@ u32 Rtl8723UPHY_REG_1T_mCardArray[Rtl8723UPHY_REG_1T_mCardArrayLength] = {
 0x908,0x00000000,
 0x90c,0x81121111,
 0xa00,0x00d047c8,
-0xa04,0x80ff000c,
+0xa04,0x80ff800c,
 0xa08,0x8c838300,
 0xa0c,0x2e68120f,
 0xa10,0x9500bb78,
@@ -5642,7 +5642,7 @@ u32 Rtl8723UPHY_REG_1T_mCardArray[Rtl8723UPHY_REG_1T_mCardArrayLength] = {
 0xce4,0x00000000,
 0xce8,0x37644302,
 0xcec,0x2f97d40c,
-0xd00,0x00080740,
+0xd00,0x00000740,
 0xd04,0x00020401,
 0xd08,0x0000907f,
 0xd0c,0x20010201,
@@ -5757,7 +5757,7 @@ u32 Rtl8723UPHY_REG_1T_SDIOArray[Rtl8723UPHY_REG_1T_SDIOArrayLength] = {
 0x908,0x00000000,
 0x90c,0x81121111,
 0xa00,0x00d047c8,
-0xa04,0x80ff000c,
+0xa04,0x80ff800c,
 0xa08,0x8c838300,
 0xa0c,0x2e68120f,
 0xa10,0x9500bb78,
@@ -5831,7 +5831,7 @@ u32 Rtl8723UPHY_REG_1T_SDIOArray[Rtl8723UPHY_REG_1T_SDIOArrayLength] = {
 0xce4,0x00000000,
 0xce8,0x37644302,
 0xcec,0x2f97d40c,
-0xd00,0x00080740,
+0xd00,0x00000740,
 0xd04,0x00020401,
 0xd08,0x0000907f,
 0xd0c,0x20010201,
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_com.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_com.c
index 9f413a09cfbf..d18b011f5d09 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_com.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_com.c
@@ -40,6 +40,18 @@
 
 #define _HAL_INIT_C_
 
+#ifdef CONFIG_RF_GAIN_OFFSET
+#ifdef CONFIG_RTL8723A
+#define	RF_GAIN_OFFSET_ON			BIT0
+#define	REG_RF_BB_GAIN_OFFSET	0x7f
+#define	RF_GAIN_OFFSET_MASK		0xfffff
+#else
+#define	RF_GAIN_OFFSET_ON			BIT4
+#define	REG_RF_BB_GAIN_OFFSET	0x55
+#define	RF_GAIN_OFFSET_MASK		0xfffff
+#endif  //CONFIG_RTL8723A
+#endif //CONFIG_RF_GAIN_OFFSET
+
 void dump_chip_info(HAL_VERSION	ChipVersion)
 {
 	int cnt = 0;
@@ -396,6 +408,74 @@ s32 c2h_evt_read(_adapter *adapter, u8 *buf)
 	return ret;
 }
 
+void SetHwReg(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+
+_func_enter_;
+
+	switch (variable) {
+	case HW_VAR_SEC_CFG:
+	{
+		#if defined(CONFIG_CONCURRENT_MODE) && !defined(DYNAMIC_CAMID_ALLOC)
+		// enable tx enc and rx dec engine, and no key search for MC/BC
+		rtw_write8(adapter, REG_SECCFG, SCR_NoSKMC|SCR_RxDecEnable|SCR_TxEncEnable);
+		#elif defined(DYNAMIC_CAMID_ALLOC)
+		u16 reg_scr;
+
+		reg_scr = rtw_read16(adapter, REG_SECCFG);
+		rtw_write16(adapter, REG_SECCFG, reg_scr|SCR_CHK_KEYID|SCR_RxDecEnable|SCR_TxEncEnable);
+		#else
+		rtw_write8(adapter, REG_SECCFG, *((u8*)val));
+		#endif
+	}
+		break;
+	case HW_VAR_SEC_DK_CFG:
+	{
+		struct security_priv *sec = &adapter->securitypriv;
+		u8 reg_scr = rtw_read8(adapter, REG_SECCFG);
+
+		if (val) /* Enable default key related setting */
+		{
+			reg_scr |= SCR_TXBCUSEDK;
+			if (sec->dot11AuthAlgrthm != dot11AuthAlgrthm_8021X)
+				reg_scr |= (SCR_RxUseDK|SCR_TxUseDK);
+		}
+		else /* Disable default key related setting */
+		{
+			reg_scr &= ~(SCR_RXBCUSEDK|SCR_TXBCUSEDK|SCR_RxUseDK|SCR_TxUseDK);
+		}
+
+		rtw_write8(adapter, REG_SECCFG, reg_scr);
+	}
+		break;
+	default:
+		if (0)
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
+			FUNC_ADPT_ARG(adapter), variable);
+		break;
+	}
+
+_func_exit_;
+}
+
+void GetHwReg(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+
+_func_enter_;
+
+	switch (variable) {
+	default:
+		if (0)
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
+			FUNC_ADPT_ARG(adapter), variable);
+		break;
+	}
+}
+
 u8
 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
 {
@@ -442,6 +522,9 @@ GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
 	case HAL_DEF_DBG_DM_FUNC:
 		*((u32*)value) = pHalData->odmpriv.SupportAbility;
 		break;
+	case HAL_DEF_MACID_SLEEP:
+		*(u8*)value = _FALSE; // support macid sleep
+		break;
 	default:
 		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
 		bResult = _FAIL;
@@ -451,3 +534,281 @@ GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
 	return bResult;
 }
 
+#ifdef CONFIG_RF_GAIN_OFFSET
+void rtw_bb_rf_gain_offset(_adapter *padapter)
+{
+	u8      value = padapter->eeprompriv.EEPROMRFGainOffset;
+	u8      tmp = 0x3e;
+	u32     res;
+
+	DBG_871X("+%s value: 0x%02x+\n", __func__, value);
+
+	if (value & RF_GAIN_OFFSET_ON) {
+		//DBG_871X("Offset RF Gain.\n");
+		//DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x\n",padapter->eeprompriv.EEPROMRFGainVal);
+		if(padapter->eeprompriv.EEPROMRFGainVal != 0xff){
+#ifdef CONFIG_RTL8723A
+			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0xd, 0xffffffff);
+			//DBG_871X("Offset RF Gain. reg 0xd=0x%x\n",res);
+			res &= 0xfff87fff;
+
+			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15;
+			//DBG_871X("Offset RF Gain.    reg 0xd=0x%x\n",res);
+
+			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
+
+			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0xe, 0xffffffff);
+			DBG_871X("Offset RF Gain. reg 0xe=0x%x\n",res);
+			res &= 0xfffffff0;
+
+			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f);
+			//DBG_871X("Offset RF Gain.    reg 0xe=0x%x\n",res);
+
+			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
+#else
+			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, 0xffffffff);
+			DBG_871X("REG_RF_BB_GAIN_OFFSET=%x \n",res);
+			res &= 0xfff87fff;
+			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15;
+			DBG_871X("write REG_RF_BB_GAIN_OFFSET=%x \n",res);
+			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
+#endif
+		}
+		else
+		{
+			//DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x  != 0xff, didn't run Kfree\n",padapter->eeprompriv.EEPROMRFGainVal);
+		}
+	} else {
+		//DBG_871X("Using the default RF gain.\n");
+	}
+
+}
+#endif //CONFIG_RF_GAIN_OFFSET
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter) {
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8* pContent = pEEPROM->efuse_eeprom_data;
+	int index = 0;
+	u16 tx_index_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723A:
+			tx_index_offset = EEPROM_CCK_TX_PWR_INX_8723A;
+		break;
+		default:
+			tx_index_offset = 0x0010;
+		break;
+	}
+	for (index = 0 ; index < 12 ; index++) {
+		if (pContent[tx_index_offset + index] == 0xFF) {
+			return _FALSE;
+		} 
+	}
+	DBG_871X("phy efuse with valid tx power info\n");
+	return _TRUE;
+}
+
+int check_phy_efuse_macaddr_info_valid(PADAPTER padapter) {
+
+	u8 val = 0;
+	u16 addr_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723A:
+			if (padapter->interface_type == RTW_USB) 
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			}
+			else if (padapter->interface_type == RTW_SDIO)
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AS;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			}
+			else if (padapter->interface_type == RTW_PCIE)
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			}
+		break;
+	}
+
+	if (addr_offset == 0x0000) {
+		DBG_871X("phy efuse MAC addr offset is 0!!\n");
+		return _FALSE;
+	} else {
+		rtw_efuse_map_read(padapter, addr_offset, 1, &val);
+	}
+
+	if (val == 0xFF) {
+		return _FALSE;
+	} else {
+		DBG_871X("phy efuse with valid MAC addr\n");
+		return _TRUE;
+	}
+}
+
+u32 Hal_readPGDataFromConfigFile(
+	PADAPTER	padapter,
+	struct file *fp)
+{
+	u32 i;
+	mm_segment_t fs;
+	u8 temp[3];
+	loff_t pos = 0;
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
+
+	temp[2] = 0; // add end of string '\0'
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	for (i = 0 ; i < HWSET_MAX_SIZE ; i++) {
+		vfs_read(fp, temp, 2, &pos);
+		PROMContent[i] = simple_strtoul(temp, NULL, 16);
+		if ((i % EFUSE_FILE_COLUMN_NUM) == (EFUSE_FILE_COLUMN_NUM - 1)) {
+			//Filter the lates space char.
+			vfs_read(fp, temp, 1, &pos);
+			if (strchr(temp, ' ') == NULL) {
+				pos--;
+				vfs_read(fp, temp, 2, &pos);
+			}
+		} else {
+			pos += 1; // Filter the space character
+		}
+	}
+
+	set_fs(fs);
+	pEEPROM->bloadfile_fail_flag = _FALSE;
+
+#ifdef CONFIG_DEBUG
+	DBG_871X("Efuse configure file:\n");
+	for (i=0; i<HWSET_MAX_SIZE; i++)
+	{
+		if (i % 16 == 0)
+			printk("\n");
+
+		printk("%02X ", PROMContent[i]);
+	}
+	printk("\n");
+#endif
+
+	return _SUCCESS;
+}
+
+void Hal_ReadMACAddrFromFile(
+	PADAPTER		padapter,
+	struct file *fp)
+{
+	u32 i;
+	mm_segment_t fs;
+	u8 source_addr[18];
+	loff_t pos = 0;
+	u32	curtime = rtw_get_current_time();
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8 *head, *end;
+
+	_rtw_memset(source_addr, 0, 18);
+	_rtw_memset(pEEPROM->mac_addr, 0, ETH_ALEN);
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	DBG_871X("wifi mac address:\n");
+	vfs_read(fp, source_addr, 18, &pos);
+	source_addr[17] = ':';
+
+	head = end = source_addr;
+	for (i=0; i<ETH_ALEN; i++) {
+		while (end && (*end != ':') )
+			end++;
+
+		if (end && (*end == ':') )
+			*end = '\0';
+
+		pEEPROM->mac_addr[i] = simple_strtoul(head, NULL, 16 );
+
+		if (end) {
+			end++;
+			head = end;
+		}
+	}
+
+	set_fs(fs);
+	pEEPROM->bloadmac_fail_flag = _FALSE;
+
+	if (rtw_check_invalid_mac_address(pEEPROM->mac_addr) == _TRUE) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		get_random_bytes(pEEPROM->mac_addr, ETH_ALEN);
+		pEEPROM->mac_addr[0] = 0x00;
+		pEEPROM->mac_addr[1] = 0xe0;
+		pEEPROM->mac_addr[2] = 0x4c;
+#else
+		pEEPROM->mac_addr[0] = 0x00;
+		pEEPROM->mac_addr[1] = 0xe0;
+		pEEPROM->mac_addr[2] = 0x4c;
+		pEEPROM->mac_addr[3] = (u8)(curtime & 0xff) ;
+		pEEPROM->mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
+		pEEPROM->mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
+#endif
+                DBG_871X("MAC Address from wifimac error is invalid, assign random MAC !!!\n");
+	}
+
+	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
+			__func__, pEEPROM->mac_addr[0], pEEPROM->mac_addr[1],
+			pEEPROM->mac_addr[2], pEEPROM->mac_addr[3],
+			pEEPROM->mac_addr[4], pEEPROM->mac_addr[5]);
+}
+
+void Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8* mac_addr) {
+	int i = 0;
+	u16 addr_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723A:
+			if (padapter->interface_type == RTW_USB) 
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			}
+			else if (padapter->interface_type == RTW_SDIO)
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AS;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			}
+			else if (padapter->interface_type == RTW_PCIE)
+			{
+				addr_offset = EEPROM_MAC_ADDR_8723AE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			}
+		break;
+	}
+
+	rtw_efuse_map_read(padapter, addr_offset, ETH_ALEN, mac_addr);
+
+	if (rtw_check_invalid_mac_address(mac_addr) == _TRUE) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		get_random_bytes(mac_addr, ETH_ALEN);
+		mac_addr[0] = 0x00;
+		mac_addr[1] = 0xe0;
+		mac_addr[2] = 0x4c;
+#else
+		mac_addr[0] = 0x00;
+		mac_addr[1] = 0xe0;
+		mac_addr[2] = 0x4c;
+		mac_addr[3] = (u8)(curtime & 0xff) ;
+		mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
+		mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
+#endif
+                DBG_871X("MAC Address from phy efuse error, assign random MAC !!!\n");
+	}
+
+	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
+			__func__, mac_addr[0], mac_addr[1], mac_addr[2],
+			mac_addr[3], mac_addr[4], mac_addr[5]);
+}
+#endif //CONFIG_EFUSE_CONFIG_FILE
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_intf.c
index a37c9ccb3f57..a16d5a2bf3a5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/hal_intf.c
@@ -142,24 +142,26 @@ uint	 rtw_hal_init(_adapter *padapter)
 	status = padapter->HalFunc.hal_init(padapter);
 
 	if(status == _SUCCESS){
-		for (i = 0; i<dvobj->iface_nums; i++) {
-			padapter = dvobj->padapters[i];
-			padapter->hw_init_completed = _TRUE;
-		}
+		for (i = 0; i<dvobj->iface_nums; i++)
+			dvobj->padapters[i]->hw_init_completed = _TRUE;
 			
 		if (padapter->registrypriv.notch_filter == 1)
 			rtw_hal_notch_filter(padapter, 1);
 
 		rtw_hal_reset_security_engine(padapter);
-		rtw_sec_restore_wep_key(padapter);
+
+		for (i = 0; i<dvobj->iface_nums; i++)
+			rtw_sec_restore_wep_key(dvobj->padapters[i]);
 
 		init_hw_mlme_ext(padapter);
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+		rtw_bb_rf_gain_offset(padapter);
+#endif //CONFIG_RF_GAIN_OFFSET		
 	}
 	else{
-		for (i = 0; i<dvobj->iface_nums; i++) {
-			padapter = dvobj->padapters[i];
-			padapter->hw_init_completed = _FALSE;
-		}
+		for (i = 0; i<dvobj->iface_nums; i++)
+			dvobj->padapters[i]->hw_init_completed = _FALSE;
 		DBG_871X("rtw_hal_init: hal__init fail\n");
 	}
 
@@ -597,3 +599,43 @@ c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter)
 	return adapter->HalFunc.c2h_id_filter_ccx;
 }
 
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid)
+{
+	u8 support;
+
+	support = _FALSE;
+	rtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);
+	if (_FALSE == support)
+		return _FAIL;
+
+	if (macid >= 32) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT": Invalid macid(%u)\n",
+			FUNC_ADPT_ARG(padapter), macid);
+		return _FAIL;
+	}
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_SLEEP, &macid);
+
+	return _SUCCESS;
+}
+
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid)
+{
+	u8 support;
+
+	support = _FALSE;
+	rtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);
+	if (_FALSE == support)
+		return _FAIL;
+
+	if (macid >= 32) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT": Invalid macid(%u)\n",
+			FUNC_ADPT_ARG(padapter), macid);
+		return _FAIL;
+	}
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_WAKEUP, &macid);
+
+	return _SUCCESS;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_bt-coexist.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_bt-coexist.c
index b6c6a3a6bb75..fbe18866fec2 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_bt-coexist.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_bt-coexist.c
@@ -8238,7 +8238,7 @@ btdm_1AntPsTdma(
 				if (btdm_Is1AntPsTdmaStateChange(padapter))
 				{
 					// wide duration for WiFi
-					BTDM_SetFw3a(padapter, 0xd3, 0x1a, 0x1a, 0x0, 0x50);
+					BTDM_SetFw3a(padapter, 0xd3, 0x1a, 0x1a, 0x0, 0x10);
 					btdm_1AntSetBTCoexTable(padapter, 6);
 				}
 				break;
@@ -8246,7 +8246,7 @@ btdm_1AntPsTdma(
 				if (btdm_Is1AntPsTdmaStateChange(padapter))
 				{
 					// normal duration for WiFi
-					BTDM_SetFw3a(padapter, 0xd3, 0x12, 0x12, 0x0, 0x50);
+					BTDM_SetFw3a(padapter, 0xd3, 0x12, 0x12, 0x0, 0x10);
 					btdm_1AntSetBTCoexTable(padapter, 6);
 				}
 				break;
@@ -8278,7 +8278,7 @@ btdm_1AntPsTdma(
 				if (btdm_Is1AntPsTdmaStateChange(padapter))
 				{
 					// narrow duration for WiFi
-					BTDM_SetFw3a(padapter, 0xd3, 0xa, 0xa, 0x0, 0x50); //narrow duration for WiFi
+					BTDM_SetFw3a(padapter, 0xd3, 0x10, 0x10, 0x0, 0x10); //narrow duration for WiFi
 					btdm_1AntSetBTCoexTable(padapter, 6);
 				}
 				break;
@@ -8293,7 +8293,7 @@ btdm_1AntPsTdma(
 				if (btdm_Is1AntPsTdmaStateChange(padapter))
 				{
 					// narrow duration for WiFi
-					BTDM_SetFw3a(padapter, 0x53, 0x10, 0x03, 0x10, 0x50);
+					BTDM_SetFw3a(padapter, 0xd3, 0x10, 0x10, 0x0, 0x10);
 					btdm_1AntSetBTCoexTable(padapter, 6);
 				}
 				break;
@@ -8385,7 +8385,7 @@ btdm_1AntPsTdma(
 			case 37:
 				if (btdm_Is1AntPsTdmaStateChange(padapter))
 				{
-					BTDM_SetFw3a(padapter, 0x53, 0x10, 0x03, 0x10, 0x10);
+					BTDM_SetFw3a(padapter, 0xd3, 0x20, 0x03, 0x10, 0x10);
 					btdm_1AntSetBTCoexTable(padapter, 6);
 				}
 				break;
@@ -10480,8 +10480,10 @@ void btdm_2AntIgnoreWlanAct(PADAPTER	padapter,u8	bEnable)
 	//RTPRINT(FBT, BT_TRACE, ("[BTCoex], bPreIgnoreWlanAct = %d, bCurIgnoreWlanAct = %d!!\n",
 	//	pBtdm8723->bPreIgnoreWlanAct, pBtdm8723->bCurIgnoreWlanAct));
 
+#if 0
 	if(pBtdm8723->bPreIgnoreWlanAct == pBtdm8723->bCurIgnoreWlanAct)
 		return;
+#endif
 
 	btdm_SetFwIgnoreWlanAct(padapter,bEnable);
 	pBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;
@@ -17880,8 +17882,6 @@ void btdm_InitBtCoexistDM(PADAPTER padapter)
 	pHalData->bt_coexist.CurrentState = 0;
 	pHalData->bt_coexist.PreviousState = 0;
 
-	pHalData->bt_coexist.halCoex8723.bBusyTrafficForCoex = _FALSE;
-
 	BTDM_8723AInit(padapter);
 	pHalData->bt_coexist.bInitlized = _TRUE;
 }
@@ -19467,18 +19467,15 @@ u8 BTDM_IsWifiBusy(PADAPTER padapter)
 {
 //	PMGNT_INFO 		pMgntInfo = &(GetDefaultAdapter(padapter)->MgntInfo);
 	struct mlme_priv *pmlmepriv = &(GetDefaultAdapter(padapter)->mlmepriv);
-	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
 	PBT30Info		pBTInfo = GET_BT_INFO(padapter);
 	PBT_TRAFFIC 	pBtTraffic = &pBTInfo->BtTraffic;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	struct mlme_priv *pbuddy_mlmepriv;
-	PHAL_DATA_TYPE pBuddyHalData;
 
 	if (padapter->pbuddy_adapter != NULL)
 	{
 		pbuddy_mlmepriv = &(padapter->pbuddy_adapter->mlmepriv);
-		pBuddyHalData = GET_HAL_DATA(padapter->pbuddy_adapter);
 
 #if 1	
 		if ((btdm_BtWifiAntNum(padapter) == Ant_x1) && ((BT_IsBtDisabled(padapter) == _TRUE) || ((BT_IsBtDisabled(padapter) == _FALSE && (BT_GetBtState(padapter) <= BT_INFO_STATE_CONNECT_IDLE)))))
@@ -19489,7 +19486,7 @@ u8 BTDM_IsWifiBusy(PADAPTER padapter)
 		}
 #endif
 	
-		if (pHalData->bt_coexist.halCoex8723.bBusyTrafficForCoex ||pBuddyHalData->bt_coexist.halCoex8723.bBusyTrafficForCoex ||
+		if (pmlmepriv->LinkDetectInfo.bBusyTrafficForCoex ||pbuddy_mlmepriv->LinkDetectInfo.bBusyTrafficForCoex ||
 			pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic ||
 			pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic)
 			return _TRUE;
@@ -19498,7 +19495,7 @@ u8 BTDM_IsWifiBusy(PADAPTER padapter)
 	}
 #endif
 
-	if (pHalData->bt_coexist.halCoex8723.bBusyTrafficForCoex ||
+	if (pmlmepriv->LinkDetectInfo.bBusyTrafficForCoex ||
 		pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic ||
 		pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic)
 		return _TRUE;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_dm.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_dm.c
index fd0c45e5d4fc..b8117870663a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_dm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_dm.c
@@ -89,6 +89,7 @@ dm_CheckStatistics(
 #endif
 }
 
+#ifdef CONFIG_SUPPORT_HW_WPS_PBC
 static void dm_CheckPbcGPIO(_adapter *padapter)
 {
 	u8	tmp1byte;
@@ -156,6 +157,7 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 #endif
 	}
 }
+#endif //#ifdef CONFIG_SUPPORT_HW_WPS_PBC
 
 #ifdef CONFIG_PCI_HCI
 //
@@ -559,16 +561,11 @@ if (Adapter->registrypriv.mp_mode == 1 && Adapter->mppriv.mp_dm ==0)
 	}
 
 skip_dm:
-
-	// Check GPIO to determine current RF on/off and Pbc status.
-	// Check Hardware Radio ON/OFF or not
-#ifdef CONFIG_PCI_HCI
-	if(pHalData->bGpioHwWpsPbc)
-#endif
-	{
-		dm_CheckPbcGPIO(Adapter);				// Add by hpfan 2008-03-11
-	}
-
+#ifdef CONFIG_SUPPORT_HW_WPS_PBC
+	// Check GPIO to determine current Pbc status.
+	dm_CheckPbcGPIO(Adapter);
+#endif	
+	return;
 }
 
 void rtl8723a_init_dm_priv(IN PADAPTER Adapter)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_hal_init.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_hal_init.c
index f5d3716cd140..dad346a87734 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_hal_init.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_hal_init.c
@@ -249,7 +249,6 @@ void _8051Reset8723A(PADAPTER padapter)
 	DBG_871X("=====> _8051Reset8723A(): 8051 reset success .\n");
 }
 
-extern u8 g_fwdl_chksum_fail;
 static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 {
 	s32 ret = _FAIL;
@@ -270,11 +269,8 @@ static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 		goto exit;
 	}
 
-	if (g_fwdl_chksum_fail) {
-		DBG_871X("%s: fwdl test case: fwdl_chksum_fail\n", __FUNCTION__);
-		g_fwdl_chksum_fail--;
+	if (rtw_fwdl_test_trigger_chksum_fail())
 		goto exit;
-	}
 
 	ret = _SUCCESS;
 
@@ -285,7 +281,6 @@ static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 	return ret;
 }
 
-extern u8 g_fwdl_wintint_rdy_fail;
 static s32 _FWFreeToGo(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 {
 	s32 ret = _FAIL;
@@ -313,11 +308,8 @@ static s32 _FWFreeToGo(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 		goto exit;
 	}
 
-	if (g_fwdl_wintint_rdy_fail) {
-		DBG_871X("%s: fwdl test case: wintint_rdy_fail\n", __FUNCTION__);
-		g_fwdl_wintint_rdy_fail--;
+	if (rtw_fwdl_test_trigger_wintint_rdy_fail())
 		goto exit;
-	}
 
 	ret = _SUCCESS;
 
@@ -1386,6 +1378,20 @@ hal_ReadEFuse_WiFi(
 	for (i=0; i<_size_byte; i++)
 		pbuf[i] = efuseTbl[_offset+i];
 
+#ifdef CONFIG_DEBUG
+if(1)
+{
+	DBG_871X("Efuse Realmap:\n");
+	for(i=0; i<_size_byte; i++)
+	{
+		if (i % 16 == 0)
+			printk("\n");
+		printk("%02X ", pbuf[i]);
+	}
+	printk("\n");
+}
+#endif
+
 	// Calculate Efuse utilization
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total, bPseudoTest);
 	used = eFuse_Addr - 1;
@@ -4904,39 +4910,46 @@ _func_enter_;
 			break;
 
 		case HW_VAR_BASIC_RATE:
+		{
+			struct mlme_ext_info *mlmext_info = &padapter->mlmeextpriv.mlmext_info;
+			u16 input_b = 0, masked = 0, ioted = 0, BrateCfg = 0;
+			u16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);
+			u16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|RRSR_6M|RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M);
+			u8			RateIndex = 0;
+
+			HalSetBrateCfg(padapter, val, &BrateCfg);
+			input_b = BrateCfg;
+
+			/* apply force and allow mask */
+			BrateCfg |= rrsr_2g_force_mask;
+			BrateCfg &= rrsr_2g_allow_mask;
+			masked = BrateCfg;
+
+			/* IOT consideration */
+			if (mlmext_info->assoc_AP_vendor == HT_IOT_PEER_CISCO) {
+				/* if peer is cisco and didn't use ofdm rate, we enable 6M ack */
+				if((BrateCfg & (RRSR_24M|RRSR_12M|RRSR_6M)) == 0)
+					BrateCfg |= RRSR_6M;
+			}
+			ioted = BrateCfg;
+
+			pHalData->BasicRateSet = BrateCfg;
+
+			DBG_8192C("HW_VAR_BASIC_RATE: %#x -> %#x -> %#x\n", input_b, masked, ioted);
+
+			// Set RRSR rate table.
+			rtw_write16(padapter, REG_RRSR, BrateCfg);
+			rtw_write8(padapter, REG_RRSR+2, rtw_read8(padapter, REG_RRSR+2)&0xf0);
+
+			// Set RTS initial rate
+			while (BrateCfg > 0x1)
 			{
-				u16			BrateCfg = 0;
-				u8			RateIndex = 0;
-
-				// 2007.01.16, by Emily
-				// Select RRSR (in Legacy-OFDM and CCK)
-				// For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate.
-				// We do not use other rates.
-				HalSetBrateCfg(padapter, val, &BrateCfg);
-
-				//2011.03.30 add by Luke Lee
-				//CCK 2M ACK should be disabled for some BCM and Atheros AP IOT
-				//because CCK 2M has poor TXEVM
-				//CCK 5.5M & 11M ACK should be enabled for better performance
-
-				pHalData->BasicRateSet = BrateCfg = (BrateCfg |0xd) & 0x15d;
-				BrateCfg |= 0x01; // default enable 1M ACK rate
-				DBG_8192C("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
-
-				// Set RRSR rate table.
-				rtw_write8(padapter, REG_RRSR, BrateCfg&0xff);
-				rtw_write8(padapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
-				rtw_write8(padapter, REG_RRSR+2, rtw_read8(padapter, REG_RRSR+2)&0xf0);
-
-				// Set RTS initial rate
-				while (BrateCfg > 0x1)
-				{
-					BrateCfg = (BrateCfg >> 1);
-					RateIndex++;
-				}
-				// Ziv - Check
-				rtw_write8(padapter, REG_INIRTS_RATE_SEL, RateIndex);
+				BrateCfg = (BrateCfg >> 1);
+				RateIndex++;
 			}
+			// Ziv - Check
+			rtw_write8(padapter, REG_INIRTS_RATE_SEL, RateIndex);
+		}
 			break;
 
 		case HW_VAR_TXPAUSE:
@@ -5122,14 +5135,6 @@ _func_enter_;
 			}
 			break;
 
-		case HW_VAR_SEC_CFG:
-#ifdef CONFIG_CONCURRENT_MODE
-			rtw_write8(padapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC
-#else
-			rtw_write8(padapter, REG_SECCFG, *val);
-#endif
-			break;
-
 		case HW_VAR_DM_FLAG:
 			pHalData->odmpriv.SupportAbility = *((u32*)val);
 			break;
@@ -5510,13 +5515,137 @@ _func_enter_;
 			rtw_write8(padapter, REG_TDECTRL+2, rtw_read8(padapter, REG_TDECTRL+2) | BIT0);
 			break;
 
+		case HW_VAR_MACID_SLEEP:
+		{
+			u32 reg_macid_sleep;
+			u8 bit_shift;
+			u8 id = *(u8*)val;
+			u32 val32;
+
+			if (id < 32) {
+				reg_macid_sleep = REG_MACID_SLEEP;
+				bit_shift = id;
+			} else {
+				rtw_warn_on(1);
+				break;
+			}
+
+			val32 = rtw_read32(padapter, reg_macid_sleep);
+			DBG_8192C(FUNC_ADPT_FMT ": [HW_VAR_MACID_SLEEP] macid=%d, org reg_0x%03x=0x%08X\n",
+				FUNC_ADPT_ARG(padapter), id, reg_macid_sleep, val32);
+
+			if (val32 & BIT(bit_shift))
+				break;
+
+			val32 |= BIT(bit_shift);
+			rtw_write32(padapter, reg_macid_sleep, val32);
+		}
+			break;
+
+		case HW_VAR_MACID_WAKEUP:
+		{
+			u32 reg_macid_sleep;
+			u8 bit_shift;
+			u8 id = *(u8*)val;
+			u32 val32;
+
+			if (id < 32) {
+				reg_macid_sleep = REG_MACID_SLEEP;
+				bit_shift = id;
+			} else {
+				rtw_warn_on(1);
+				break;
+			}
+
+			val32 = rtw_read32(padapter, reg_macid_sleep);
+			DBG_8192C(FUNC_ADPT_FMT ": [HW_VAR_MACID_WAKEUP] macid=%d, org reg_0x%03x=0x%08X\n",
+				FUNC_ADPT_ARG(padapter), id, reg_macid_sleep, val32);
+
+			if (!(val32 & BIT(bit_shift)))
+				break;
+
+			val32 &= ~BIT(bit_shift);
+			rtw_write32(padapter, reg_macid_sleep, val32);
+		}
+			break;
+
 		default:
+			SetHwReg(padapter, variable, val);
 			break;
 	}
 
 _func_exit_;
 }
 
+struct qinfo_8723a {
+	u32 head:8;
+	u32 pkt_num:8;
+	u32 tail:8;
+	u32 empty:1;
+	u32 ac:2;
+	u32 macid:5;
+};
+
+struct bcn_qinfo_8723a {
+	u16 head:8;
+	u16 pkt_num:8;
+};
+
+void dump_qinfo_8723a(void *sel, struct qinfo_8723a *info, const char *tag)
+{
+	//if (info->pkt_num)
+	DBG_871X_SEL_NL(sel, "%shead:0x%02x, tail:0x%02x, pkt_num:%u, empty:%u, macid:%u, ac:%u\n"
+		, tag ? tag : "", info->head, info->tail, info->pkt_num, info->empty, info->macid, info->ac
+	);
+}
+
+void dump_bcn_qinfo_8723a(void *sel, struct bcn_qinfo_8723a *info, const char *tag)
+{
+	//if (info->pkt_num)
+	DBG_871X_SEL_NL(sel, "%shead:0x%02x, pkt_num:%u\n"
+		, tag ? tag : "", info->head, info->pkt_num
+	);
+}
+
+void dump_mac_qinfo_8723a(void *sel, _adapter *adapter)
+{
+	u32 q0_info;
+	u32 q1_info;
+	u32 q2_info;
+	u32 q3_info;
+	u32 q4_info;
+	u32 q5_info;
+	u32 q6_info;
+	u32 q7_info;
+	u32 mg_q_info;
+	u32 hi_q_info;
+	u16 bcn_q_info;
+
+	q0_info = rtw_read32(adapter, REG_Q0_INFO);
+	q1_info = rtw_read32(adapter, REG_Q1_INFO);
+	q2_info = rtw_read32(adapter, REG_Q2_INFO);
+	q3_info = rtw_read32(adapter, REG_Q3_INFO);
+	q4_info = rtw_read32(adapter, REG_Q4_INFO);
+	q5_info = rtw_read32(adapter, REG_Q5_INFO);
+	q6_info = rtw_read32(adapter, REG_Q6_INFO);
+	q7_info = rtw_read32(adapter, REG_Q7_INFO);
+	mg_q_info = rtw_read32(adapter, REG_MGQ_INFO);
+	hi_q_info = rtw_read32(adapter, REG_HGQ_INFO);
+	bcn_q_info = rtw_read16(adapter, REG_BCNQ_INFO);
+
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q0_info, "Q0 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q1_info, "Q1 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q2_info, "Q2 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q3_info, "Q3 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q4_info, "Q4 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q5_info, "Q5 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q6_info, "Q6 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&q7_info, "Q7 ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&mg_q_info, "MG ");
+	dump_qinfo_8723a(sel, (struct qinfo_8723a *)&hi_q_info, "HI ");
+	dump_bcn_qinfo_8723a(sel, (struct bcn_qinfo_8723a *)&bcn_q_info, "BCN ");
+}
+
 void GetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val)
 {
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
@@ -5616,15 +5745,45 @@ void GetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val)
 			*val = pHalData->bMacPwrCtrlOn;
 			break;
 		case HW_VAR_CHK_HI_QUEUE_EMPTY:
-			*val = ((rtw_read32(padapter, REG_HGQ_INFORMATION)&0x0000ff00)==0) ? _TRUE:_FALSE;
+			*val = ((rtw_read32(padapter, REG_HGQ_INFO)&0x0000ff00)==0) ? _TRUE:_FALSE;
 			break;	
 		case HW_VAR_C2HEVT_CLEAR:
 			*val =  rtw_read8(padapter, REG_C2HEVT_CLEAR);
 			break;
 		case HW_VAR_C2HEVT_MSG_NORMAL:
 			*val =  rtw_read8(padapter, REG_C2HEVT_MSG_NORMAL);
-			break;	
+			break;
+		case HW_VAR_DUMP_MAC_QUEUE_INFO:
+			dump_mac_qinfo_8723a(val, padapter);
+			break;
+		default:
+			GetHwReg(padapter, variable, val);
+			break;
+	}
+}
+
+u8
+GetHalDefVar8723A(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	u8 bResult = _SUCCESS;
+
+	switch(eVariable) {
+
+	case HAL_DEF_MACID_SLEEP:
+		*(u8*)pValue = _TRUE; // support macid sleep
+		break;
+
+	default:
+		bResult = GetHalDefVar(Adapter, eVariable, pValue);
+		break;
 	}
+
+	return bResult;
 }
 
 #ifdef CONFIG_BT_COEXIST
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rf6052.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rf6052.c
index b6449371f5a7..eede4b5a32ba 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rf6052.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rf6052.c
@@ -184,6 +184,21 @@ rtl8192c_PHY_RF6052SetBandwidth(
 
 }
 
+#define MGN_2M 0x04
+s8 tx_power_extra_bias(
+	IN	u8				RFPath,
+	IN	u8				Rate,	
+	IN	HT_CHANNEL_WIDTH	BandWidth,	
+	IN	u8				Channel
+	)
+{
+	s8 bias = 0;
+
+	if (Rate == MGN_2M)
+		bias = -9;
+
+	return bias;
+}
 
 /*-----------------------------------------------------------------------------
  * Function:	PHY_RF6052SetCckTxPower
@@ -216,6 +231,7 @@ rtl8192c_PHY_RF6052SetCckTxPower(
 	BOOLEAN		TurboScanOff = _FALSE;
 	u8			idx1, idx2;
 	u8*			ptr;
+	s8 bias_2m;
 
 	// 2010/10/18 MH Accorsing to SD3 eechou's suggestion, we need to disable turbo scan for RU.
 	// Otherwise, external PA will be broken if power index > 0x20.
@@ -290,9 +306,20 @@ rtl8192c_PHY_RF6052SetCckTxPower(
 
 	for(idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
 	{
+		bias_2m = tx_power_extra_bias(idx1, MGN_2M, 0, 0);
 		ptr = (u8*)(&(TxAGC[idx1]));
 		for(idx2=0; idx2<4; idx2++)
 		{
+			if (idx2 == 1) /* 2M */
+			{
+				s16 value = *ptr + bias_2m;
+				if (value < 0)
+					value = 0;
+				else if (value > RF6052_MAX_TX_PWR)
+					value = RF6052_MAX_TX_PWR;
+
+				*ptr = (u8)value;
+			}
 			if(*ptr > RF6052_MAX_TX_PWR)
 				*ptr = RF6052_MAX_TX_PWR;
 			ptr++;
@@ -306,6 +333,8 @@ rtl8192c_PHY_RF6052SetCckTxPower(
 	tmpval = TxAGC[RF_PATH_A]>>8;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
 	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 2~11M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
+	if (0)
+		DBG_871X("CCK PWR 2~11M (rf-A) = 0x%x (H3Bytes of reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11);
 
 	// rf-B cck tx power
 	tmpval = TxAGC[RF_PATH_B]>>24;
@@ -313,8 +342,9 @@ rtl8192c_PHY_RF6052SetCckTxPower(
 	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
 	tmpval = TxAGC[RF_PATH_B]&0x00ffffff;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n",
-	//	tmpval, rTxAGC_B_CCK1_55_Mcs32));
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK1_55_Mcs32));
+	if (0)
+		DBG_871X("CCK PWR 1~5.5M (rf-B) = 0x%x (H3Bytes of reg 0x%x)\n", tmpval, rTxAGC_B_CCK1_55_Mcs32);
 
 }	/* PHY_RF6052SetCckTxPower */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rxdesc.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rxdesc.c
index f030eb821291..8c7d8de2343b 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rxdesc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/rtl8723a_rxdesc.c
@@ -24,17 +24,6 @@
 #include <drv_types.h>
 #include <rtl8723a_hal.h>
 
-static s32  translate2dbm(u8 signal_strength_idx)
-{
-	s32	signal_power; // in dBm.
-
-
-	// Translate to dBm (x=0.5y-95).
-	signal_power = (s32)((signal_strength_idx + 1) >> 1);
-	signal_power -= 95;
-
-	return signal_power;
-}
 #if 0
 static u8 evm_db2percentage(s8 value)
 {
@@ -547,10 +536,10 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 		
 		if(padapter->recvpriv.is_signal_dbg) {
 			padapter->recvpriv.signal_strength= padapter->recvpriv.signal_strength_dbg;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)padapter->recvpriv.signal_strength_dbg);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(padapter->recvpriv.signal_strength_dbg);
 		} else {
 			padapter->recvpriv.signal_strength= tmp_val;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(tmp_val);
 		}
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/sdio/sdio_halinit.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/sdio/sdio_halinit.c
index 61a6c1b0a3ae..aa18608e61ac 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/sdio/sdio_halinit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/sdio/sdio_halinit.c
@@ -1827,45 +1827,6 @@ Hal_CustomizeByCustomerID_8723AS(
 }
 
 #ifdef CONFIG_EFUSE_CONFIG_FILE
-static u32 Hal_readPGDataFromConfigFile(
-	PADAPTER	padapter)
-{
-	u32 i;
-	struct file *fp;
-	mm_segment_t fs;
-	u8 temp[3];
-	loff_t pos = 0;
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
-
-
-	temp[2] = 0; // add end of string '\0'
-
-	fp = filp_open("/system/etc/wifi/wifi_efuse.map", O_RDONLY, 0);
-	if (IS_ERR(fp)) {
-		pEEPROM->bloadfile_fail_flag = _TRUE;
-		DBG_871X("Error, Efuse configure file doesn't exist.\n");
-		return _FAIL;
-	}
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	DBG_871X("Efuse configure file:\n");
-	for (i=0; i<HWSET_MAX_SIZE_88E; i++) {
-		vfs_read(fp, temp, 2, &pos);
-		PROMContent[i] = simple_strtoul(temp, NULL, 16 );
-		pos += 1; // Filter the space character
-		DBG_871X("%02X \n", PROMContent[i]);
-	}
-	DBG_871X("\n");
-	set_fs(fs);
-
-	filp_close(fp, NULL);
-	pEEPROM->bloadfile_fail_flag = _FALSE;
-	return _SUCCESS;
-}
-
 static void
 Hal_ReadMACAddrFromFile_8723AS(
 	PADAPTER		padapter
@@ -1945,25 +1906,58 @@ readAdapterInfo(
 {
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
 //	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-	u8			hwinfo[HWSET_MAX_SIZE];
+	u8*			hwinfo = NULL;
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	struct file *fp = NULL;
+#endif
 
 	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("====> readpadapterInfo_8723S()\n"));
 
+	if (sizeof(pEEPROM->efuse_eeprom_data) < HWSET_MAX_SIZE)
+		DBG_871X("[WARNING] size of efuse_eeprom_data is less than HWSET_MAX_SIZE!\n");
+
+	hwinfo = pEEPROM->efuse_eeprom_data;
+
 	//
 	// This part read and parse the eeprom/efuse content
 	//
 	Hal_InitPGData(padapter, hwinfo);
-#ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_readPGDataFromConfigFile(padapter, hwinfo);
-#endif
 
+	/* Check Tx power index info in phy efuse first to decide whether we need to read PG data from external config file or not */
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	if (check_phy_efuse_tx_power_info_valid(padapter) == _FALSE) {
+		fp = filp_open(EFUSE_MAP_PATH, O_RDONLY, 0);
+		if (fp == NULL || IS_ERR(fp)) {
+			DBG_871X("[WARNING] invalid phy efuse and no efuse file, use driver default!!\n");
+		} else {
+			Hal_readPGDataFromConfigFile(padapter, fp);
+			filp_close(fp, NULL);
+		}
+	}
+#endif //CONFIG_EFUSE_CONFIG_FILE	
+	
 	Hal_EfuseParseIDCode(padapter, hwinfo);
 	Hal_EfuseParsePIDVID_8723AS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 
-	Hal_EfuseParseMACAddr_8723AS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
+	/* Check macaddr info in phy efuse to decide whether we need to get macaddr from external file or not */
 #ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_ReadMACAddrFromFile_8723AS(padapter);
-#endif
+	if (check_phy_efuse_macaddr_info_valid(padapter) == _TRUE) {
+		DBG_871X("using phy efuse mac\n");
+		Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
+	} else {
+		fp = filp_open(WIFIMAC_PATH, O_RDONLY, 0);
+		if (fp == NULL || IS_ERR(fp)) {
+			DBG_871X("wifimac does not exist!!\n");
+			Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
+		} else {
+			Hal_ReadMACAddrFromFile(padapter, fp);
+			filp_close(fp, NULL);
+		}
+	}
+#else //CONFIG_EFUSE_CONFIG_FILE
+	Hal_EfuseParseMACAddr_8723AS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
+#endif //CONFIG_EFUSE_CONFIG_FILE
+
 	Hal_EfuseParseTxPowerInfo_8723A(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 	Hal_EfuseParseBTCoexistInfo_8723A(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 	Hal_EfuseParseEEPROMVer(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
@@ -2157,7 +2151,7 @@ GetHalDefVar8723ASDIO(
 			*(( u32*)pValue) = MAX_AMPDU_FACTOR_64K;
 			break;
 		default:
-			bResult = GetHalDefVar(Adapter, eVariable, pValue);
+			bResult = GetHalDefVar8723A(Adapter, eVariable, pValue);
 			break;
 	}
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/rtl8723au_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/rtl8723au_recv.c
index 330c41c8f044..00e450c30d8a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/rtl8723au_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/rtl8723au_recv.c
@@ -91,9 +91,7 @@ int	rtl8192cu_init_recv_priv(_adapter *padapter)
 	//init recv_buf
 	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 	_rtw_init_queue(&precvpriv->recv_buf_pending_queue);
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
 
 	precvpriv->pallocated_recv_buf = rtw_zmalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
 	if(precvpriv->pallocated_recv_buf==NULL){
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_halinit.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_halinit.c
index 626a54039a59..6efc078b20a5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_halinit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_halinit.c
@@ -3276,47 +3276,6 @@ Hal_EfuseParseMACAddr_8723AU(
 
 
 #ifdef CONFIG_EFUSE_CONFIG_FILE
-static u32 Hal_readPGDataFromConfigFile(
-	PADAPTER	padapter)
-{
-	u32 i;
-	struct file *fp;
-	mm_segment_t fs;
-	u8 temp[3];
-	loff_t pos = 0;
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
-
-
-	temp[2] = 0; // add end of string '\0'
-
-	fp = filp_open("/system/etc/wifi/wifi_efuse.map", O_RDWR,  0644);
-	if (IS_ERR(fp)) {
-		pEEPROM->bloadfile_fail_flag= _TRUE;
-		DBG_871X("Error, Efuse configure file doesn't exist.\n");
-		return _FAIL;
-	}
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	DBG_871X("Efuse configure file:\n");
-	for (i=0; i<HWSET_MAX_SIZE_88E; i++) {
-		vfs_read(fp, temp, 2, &pos);
-		PROMContent[i] = simple_strtoul(temp, NULL, 16 );
-		pos += 1; // Filter the space character
-		DBG_871X("%02X \n", PROMContent[i]);
-	}
-	DBG_871X("\n");
-	set_fs(fs);
-
-	filp_close(fp, NULL);
-	
-	pEEPROM->bloadfile_fail_flag= _FALSE;
-	return _SUCCESS;
-}
-
-
 static void
 Hal_ReadMACAddrFromFile_8723AU(
 	PADAPTER		padapter
@@ -3398,21 +3357,54 @@ readAdapterInfo(
 {
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
 	//PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
-	u8			hwinfo[HWSET_MAX_SIZE];
-	
+	u8*			hwinfo = NULL;
 #ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_readPGDataFromConfigFile(padapter);
-#else //CONFIG_EFUSE_CONFIG_FILE	
+	struct file *fp = NULL;
+#endif
+
+	if (sizeof(pEEPROM->efuse_eeprom_data) < HWSET_MAX_SIZE)
+		DBG_871X("[WARNING] size of efuse_eeprom_data is less than HWSET_MAX_SIZE!\n");
+
+	hwinfo = pEEPROM->efuse_eeprom_data;
+
 	Hal_InitPGData(padapter, hwinfo);
-#endif	//CONFIG_EFUSE_CONFIG_FILE	
+
+	/* Check Tx power index info in phy efuse first to decide whether we need to read PG data from external config file or not */
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	if (check_phy_efuse_tx_power_info_valid(padapter) == _FALSE) {
+		fp = filp_open(EFUSE_MAP_PATH, O_RDONLY, 0);
+		if (fp == NULL || IS_ERR(fp)) {
+			DBG_871X("[WARNING] invalid phy efuse and no efuse file, use driver default!!\n");
+		} else {
+			Hal_readPGDataFromConfigFile(padapter, fp);
+			filp_close(fp, NULL);
+		}
+	}
+#endif //CONFIG_EFUSE_CONFIG_FILE	
+	
 	Hal_EfuseParseIDCode(padapter, hwinfo);
 	Hal_EfuseParsePIDVID_8723AU(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 	Hal_EfuseParseEEPROMVer(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
+
+	/* Check macaddr info in phy efuse to decide whether we need to get macaddr from external file or not */
 #ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_ReadMACAddrFromFile_8723AU(padapter);
+	if (check_phy_efuse_macaddr_info_valid(padapter) == _TRUE) {
+		DBG_871X("using phy efuse mac\n");
+		Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
+	} else {
+		fp = filp_open(WIFIMAC_PATH, O_RDONLY, 0);
+		if (fp == NULL || IS_ERR(fp)) {
+			DBG_871X("wifimac does not exist!!\n");
+			Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
+		} else {
+			Hal_ReadMACAddrFromFile(padapter, fp);
+			filp_close(fp, NULL);
+		}
+	}
 #else //CONFIG_EFUSE_CONFIG_FILE
 	Hal_EfuseParseMACAddr_8723AU(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
-#endif
+#endif //CONFIG_EFUSE_CONFIG_FILE
+
 	Hal_EfuseParseTxPowerInfo_8723A(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 	_ReadBoardType(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
 	Hal_EfuseParseBTCoexistInfo_8723A(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
@@ -3433,7 +3425,9 @@ readAdapterInfo(
 	//
 	Hal_InitChannelPlan(padapter);
 
-	
+#ifdef CONFIG_RF_GAIN_OFFSET
+	Hal_ReadRFGainOffset(padapter, hwinfo, pEEPROM->bautoload_fail_flag);
+#endif	//CONFIG_RF_GAIN_OFFSET
 
 	//hal_CustomizedBehavior_8723U(Adapter);
 
@@ -3683,7 +3677,7 @@ _func_exit_;
 //		Query setting of specified variable.
 //
 u8
-GetHalDefVar8192CUsb(
+GetHalDefVar8723AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
 	IN	PVOID					pValue
@@ -3723,7 +3717,7 @@ GetHalDefVar8192CUsb(
 			*(( u32*)pValue) = MAX_AMPDU_FACTOR_64K;
 			break;
 		default:
-			bResult = GetHalDefVar(Adapter, eVariable, pValue);
+			bResult = GetHalDefVar8723A(Adapter, eVariable, pValue);
 			break;
 	}
 
@@ -3738,7 +3732,7 @@ GetHalDefVar8192CUsb(
 //		Change default setting of specified variable.
 //
 u8
-SetHalDefVar8192CUsb(
+SetHalDefVar8723AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
 	IN	PVOID					pValue
@@ -4033,8 +4027,8 @@ _func_enter_;
 
 	pHalFunc->SetHwRegHandler = &SetHwReg8723AU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8723AU;
-	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8192CUsb;
-	pHalFunc->SetHalDefVarHandler = &SetHalDefVar8192CUsb;
+	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8723AUsb;
+	pHalFunc->SetHalDefVarHandler = &SetHalDefVar8723AUsb;
 
 	pHalFunc->UpdateRAMaskHandler = &UpdateHalRAMask8192CUsb;
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_ops_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_ops_linux.c
index eb6a5bfaf33e..f34ae9097c87 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/hal/rtl8723a/usb/usb_ops_linux.c
@@ -1394,6 +1394,7 @@ void rtl8192cu_recv_tasklet(void *priv)
 	_pkt			*pskb;
 	_adapter		*padapter = (_adapter*)priv;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	struct recv_buf	*precvbuf = NULL;
 	
 	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
 	{
@@ -1419,7 +1420,13 @@ void rtl8192cu_recv_tasklet(void *priv)
 #endif
 				
 	}
-	
+	while (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue)))
+	{
+		DBG_871X("dequeue_recvbuf %p\n", precvbuf);
+		precvbuf->pskb = NULL;
+		precvbuf->reuse = _FALSE;
+		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+	}	
 }
 
 
@@ -1585,6 +1592,9 @@ _func_enter_;
 			if(precvbuf->pskb == NULL)		
 			{
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
+				DBG_8192C("#### usb_read_port() alloc_skb fail!  precvbuf=%p #####\n", precvbuf);
+				//enqueue precvbuf and wait for free skb
+				rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);	
 				return _FAIL;
 			}	
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/autoconf.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/autoconf.h
index 0ac76f61716a..67e006595aa6 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/autoconf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/autoconf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -20,8 +20,9 @@
 #define CONFIG_ODM_REFRESH_RAMASK
 #define CONFIG_PHY_SETTING_WITH_ODM
 
+
 /*
- * Public  General Config
+ * Automatically generated C config: don't edit
  */
 
 #define AUTOCONF_INCLUDED
@@ -33,19 +34,18 @@
 #define CONFIG_USB_HCI	
 #define PLATFORM_LINUX	
 
-#define CONFIG_EMBEDDED_FWIMG	
+#define CONFIG_EMBEDDED_FWIMG
 //#define CONFIG_FILE_FWIMG
 
 /*
  * Functions Config
  */
-
 #define CONFIG_XMIT_ACK
 #ifdef CONFIG_XMIT_ACK
 	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #endif
-#define CONFIG_80211N_HT	
-#define CONFIG_RECV_REORDERING_CTRL	
+#define CONFIG_80211N_HT
+#define CONFIG_RECV_REORDERING_CTRL
 
 
 #define SUPPORT_HW_RFOFF_DETECTED	
@@ -55,26 +55,26 @@
 #ifdef CONFIG_IOCTL_CFG80211
 	#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
 	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
-	//#define CONFIG_DEBUG_CFG80211 
+	//#define CONFIG_DEBUG_CFG80211
 	#define CONFIG_SET_SCAN_DENY_TIMER
 #endif
 
-#define CONFIG_AP_MODE	
+#define CONFIG_AP_MODE
 #ifdef CONFIG_AP_MODE
-	#define CONFIG_NATIVEAP_MLME 
+	#define CONFIG_NATIVEAP_MLME
 	#ifndef CONFIG_NATIVEAP_MLME
-		#define CONFIG_HOSTAPD_MLME	
-	#endif			
-	//#define CONFIG_FIND_BEST_CHANNEL	
-	//#define CONFIG_NO_WIRELESS_HANDLERS	
+		#define CONFIG_HOSTAPD_MLME
+	#endif
+	//#define CONFIG_FIND_BEST_CHANNEL
+	//#define CONFIG_NO_WIRELESS_HANDLERS
 #endif
 
-#define CONFIG_P2P	
+#define CONFIG_P2P
 #ifdef CONFIG_P2P
 	//Added by Albert 20110812
 	//The CONFIG_WFD is for supporting the Wi-Fi display
 	#define CONFIG_WFD
-	
+
 	#ifndef CONFIG_WIFI_TEST
 		#define CONFIG_P2P_REMOVE_GROUP_INFO
 	#endif
@@ -87,7 +87,7 @@
 #endif
 
 //	Added by Kurt 20110511
-//#define CONFIG_TDLS	
+//#define CONFIG_TDLS
 #ifdef CONFIG_TDLS
 //	#ifndef CONFIG_WFD
 //		#define CONFIG_WFD	
@@ -112,12 +112,13 @@
 
 #define USB_INTERFERENCE_ISSUE // this should be checked in all usb interface
 //#define CONFIG_ADAPTOR_INFO_CACHING_FILE // now just applied on 8192cu only, should make it general...
-#define CONFIG_RESUME_IN_WORKQUEUE
+//#define CONFIG_RESUME_IN_WORKQUEUE
 //#define CONFIG_SET_SCAN_DENY_TIMER
 #define CONFIG_LONG_DELAY_ISSUE
 #define CONFIG_NEW_SIGNAL_STAT_PROCESS
-#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,  */
+#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
 #define CONFIG_DEAUTH_BEFORE_CONNECT
+//#define CONFIG_PATCH_JOIN_WRONG_CHANNEL
 
 
 //#define CONFIG_ANTENNA_DIVERSITY
@@ -308,7 +309,7 @@
  */
 #define DBG	0
 
-#define CONFIG_DEBUG /* DBG_871X, etc... */
+//#define CONFIG_DEBUG /* DBG_871X, etc... */
 //#define CONFIG_DEBUG_RTL871X /* RT_TRACE, RT_PRINT_DATA, _func_enter_, _func_exit_ */
 
 #define CONFIG_PROC_DEBUG
@@ -316,27 +317,6 @@
 #define DBG_CONFIG_ERROR_DETECT
 #define DBG_CONFIG_ERROR_RESET
 
-//#define DBG_IO
-//#define DBG_DELAY_OS
-//#define DBG_MEM_ALLOC
-//#define DBG_IOCTL
-
-//#define DBG_TX
 //#define DBG_XMIT_BUF
-//#define DBG_TX_DROP_FRAME
-
-//#define DBG_RX_DROP_FRAME
-//#define DBG_RX_SEQ
-
-//#define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
-//#define DBG_ROAMING_TEST
-
-//#define DBG_HAL_INIT_PROFILING
-
-//#define DBG_MEMORY_LEAK	1
-
-//TX use 1 urb
-//#define CONFIG_SINGLE_XMIT_BUF
-//RX use 1 urb
-//#define CONFIG_SINGLE_RECV_BUF
+//#define DBG_XMIT_BUF_EXT
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_conf.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_conf.h
index 0443b65e1c5c..47a07e9e1a9e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_conf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_conf.h
@@ -71,6 +71,11 @@
 	#define CONFIG_USB_VENDOR_REQ_MUTEX
 #endif
 
+#define DYNAMIC_CAMID_ALLOC
+
+#ifndef CONFIG_RTW_HIQ_FILTER
+	#define CONFIG_RTW_HIQ_FILTER 1
+#endif
 
 //#include <rtl871x_byteorder.h>
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_types.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_types.h
index 420dd0ea7872..cb21a12d32db 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_types.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/drv_types.h
@@ -226,6 +226,8 @@ struct registry_priv
 #endif
 	u8 regulatory_tid;
 	u8 qos_opt_enable;
+
+	u8 hiq_filter;
 };
 
 
@@ -386,6 +388,22 @@ struct int_logs {
 
 #endif
 
+struct cam_ctl_t {
+	_lock lock;
+	u64 bitmap;
+};
+
+struct cam_entry_cache {
+	u16 ctrl;
+	u8 mac[ETH_ALEN];
+	u8 key[16];
+};
+
+#define KEY_FMT "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+#define KEY_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5], \
+	((u8*)(x))[6],((u8*)(x))[7],((u8*)(x))[8],((u8*)(x))[9],((u8*)(x))[10],((u8*)(x))[11], \
+	((u8*)(x))[12],((u8*)(x))[13],((u8*)(x))[14],((u8*)(x))[15]
+
 struct dvobj_priv
 {
 	_adapter *if1; //PRIMARY_ADAPTER
@@ -411,6 +429,9 @@ struct dvobj_priv
 	_adapter *padapters[IFACE_ID_MAX];
 	u8 iface_nums; // total number of ifaces used runtime
 
+	struct cam_ctl_t cam_ctl;
+	struct cam_entry_cache cam_cache[32];
+
 	//For 92D, DMDP have 2 interface.
 	u8	InterfaceNumber;
 	u8	NumInterfaces;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com.h
index e1542783ae28..52f72f639b93 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com.h
@@ -178,8 +178,25 @@ void hal_init_macaddr(_adapter *adapter);
 void c2h_evt_clear(_adapter *adapter);
 s32 c2h_evt_read(_adapter *adapter, u8 *buf);
 
+void SetHwReg(_adapter *adapter, u8 variable, u8 *val);
+void GetHwReg(_adapter *adapter, u8 variable, u8 *val);
+
 u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
 u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
 
+#ifdef CONFIG_RF_GAIN_OFFSET
+void rtw_bb_rf_gain_offset(_adapter *padapter);
+#endif //CONFIG_RF_GAIN_OFFSET
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+#define		EFUSE_FILE_COLUMN_NUM		16
+u32 Hal_readPGDataFromConfigFile(PADAPTER padapter, struct file *fp);
+void Hal_ReadMACAddrFromFile(PADAPTER padapter, struct file *fp);
+void Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8* mac_addr);
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter);
+int check_phy_efuse_macaddr_info_valid(PADAPTER padapter);
+#endif //CONFIG_EFUSE_CONFIG_FILE
+
+
 #endif //__HAL_COMMON_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com_reg.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com_reg.h
new file mode 100755
index 000000000000..7b5c5e0d22ba
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_com_reg.h
@@ -0,0 +1,103 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_REG_H__
+#define __HAL_COMMON_REG_H__
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+
+/* 92C, 92D */
+#define REG_VOQ_INFO	0x0400
+#define REG_VIQ_INFO	0x0404
+#define REG_BEQ_INFO	0x0408
+#define REG_BKQ_INFO	0x040C
+
+/* 88E, 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q0_INFO	0x400
+#define REG_Q1_INFO	0x404
+#define REG_Q2_INFO	0x408
+#define REG_Q3_INFO	0x40C
+
+#define REG_MGQ_INFO	0x0410
+#define REG_HGQ_INFO	0x0414
+#define REG_BCNQ_INFO	0x0418
+
+/* 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q4_INFO	0x468
+#define REG_Q5_INFO	0x46C
+#define REG_Q6_INFO	0x470
+#define REG_Q7_INFO	0x474
+
+/* 8723A */
+#define REG_MACID_DROP	0x04D0
+
+/* 8723A, 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP	0x04D4
+
+// Security
+#define REG_CAMCMD		0x0670
+#define REG_CAMWRITE	0x0674
+#define REG_CAMREAD		0x0678
+#define REG_CAMDBG		0x067C
+#define REG_SECCFG		0x0680
+
+//----------------------------------------------------------------------------
+//       CAM Config Setting (offset 0x680, 1 byte)
+//----------------------------------------------------------------------------   	       		
+#define CAM_VALID				BIT15
+#define CAM_NOTVALID			0x0000
+#define CAM_USEDK				BIT5
+
+#define CAM_CONTENT_COUNT 	8
+
+#define CAM_NONE				0x0
+#define CAM_WEP40				0x01
+#define CAM_TKIP				0x02
+#define CAM_AES					0x04
+#define CAM_WEP104				0x05
+#define CAM_SMS4				0x6
+
+#define TOTAL_CAM_ENTRY		32
+#define HALF_CAM_ENTRY			16	
+       		
+#define CAM_CONFIG_USEDK		_TRUE
+#define CAM_CONFIG_NO_USEDK	_FALSE
+
+#define CAM_WRITE				BIT16
+#define CAM_READ				0x00000000
+#define CAM_POLLINIG			BIT31
+
+
+//2 SECCFG
+#define	SCR_TxUseDK				BIT(0)			//Force Tx Use Default Key
+#define	SCR_RxUseDK				BIT(1)			//Force Rx Use Default Key
+#define	SCR_TxEncEnable			BIT(2)			//Enable Tx Encryption
+#define	SCR_RxDecEnable			BIT(3)			//Enable Rx Decryption
+#define	SCR_SKByA2				BIT(4)			//Search kEY BY A2
+#define	SCR_NoSKMC				BIT(5)			//No Key Search Multicast
+#define SCR_TXBCUSEDK			BIT(6)			// Force Tx Broadcast packets Use Default Key
+#define SCR_RXBCUSEDK			BIT(7)			// Force Rx Broadcast packets Use Default Key
+#define SCR_CHK_KEYID			BIT(8)
+
+#endif //__HAL_COMMON_H__
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_intf.h
index 67eb6b99ec4e..d38037b1216c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/hal_intf.h
@@ -70,6 +70,7 @@ typedef enum _HW_VARIABLES{
 	HW_VAR_RESP_SIFS,
 	HW_VAR_ACK_PREAMBLE,
 	HW_VAR_SEC_CFG,
+	HW_VAR_SEC_DK_CFG,
 	HW_VAR_BCN_VALID,
 	HW_VAR_RF_TYPE,
 	HW_VAR_DM_FLAG,
@@ -128,6 +129,9 @@ typedef enum _HW_VARIABLES{
 	HW_VAR_READ_LLT_TAB,
 	HW_VAR_C2HEVT_CLEAR,
 	HW_VAR_C2HEVT_MSG_NORMAL,
+	HW_VAR_DUMP_MAC_QUEUE_INFO,
+	HW_VAR_MACID_SLEEP,
+	HW_VAR_MACID_WAKEUP,
 }HW_VARIABLES;
 
 typedef enum _HAL_DEF_VARIABLE{
@@ -148,6 +152,7 @@ typedef enum _HAL_DEF_VARIABLE{
 	HW_DEF_FA_CNT_DUMP,
 	HW_DEF_ODM_DBG_FLAG,
 	HW_DEF_ODM_DBG_LEVEL,
+	HAL_DEF_MACID_SLEEP, // Support for MACID sleep
 }HAL_DEF_VARIABLE;
 
 typedef enum _HAL_ODM_VARIABLE{
@@ -487,5 +492,8 @@ void rtw_hal_reset_security_engine(_adapter * adapter);
 s32 rtw_hal_c2h_handler(_adapter *adapter, struct c2h_evt_hdr *c2h_evt);
 c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter);
 
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid);
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid);
+
 #endif //__HAL_INTF_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/osdep_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/osdep_intf.h
index 5f2c814b39ec..44b514a4a70e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/osdep_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/osdep_intf.h
@@ -127,10 +127,6 @@ extern int rtw_ioctl(struct ifnet * ifp, u_long cmd, caddr_t data);
 
 void rtw_ips_dev_unload(_adapter *padapter);
 
-#ifdef CONFIG_RF_GAIN_OFFSET
-void rtw_bb_rf_gain_offset(_adapter *padapter);
-#endif //CONFIG_RF_GAIN_OFFSET
-
 #ifdef CONFIG_IPS
 int rtw_ips_pwr_up(_adapter *padapter);
 void rtw_ips_pwr_down(_adapter *padapter);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8188e_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8188e_spec.h
index 0421da900700..093e7a7daa26 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8188e_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8188e_spec.h
@@ -20,6 +20,7 @@
 #define __RTL8188E_SPEC_H__
 
 #include <drv_conf.h>
+#include "hal_com_reg.h"
 
 #ifndef BIT
 #define BIT(x)		(1 << (x))
@@ -254,13 +255,6 @@
 //	0x0400h ~ 0x047Fh	Protocol Configuration
 //
 //-----------------------------------------------------
-#define REG_VOQ_INFORMATION			0x0400
-#define REG_VIQ_INFORMATION			0x0404
-#define REG_BEQ_INFORMATION			0x0408
-#define REG_BKQ_INFORMATION			0x040C
-#define REG_MGQ_INFORMATION			0x0410
-#define REG_HGQ_INFORMATION			0x0414
-#define REG_BCNQ_INFORMATION			0x0418
 #define REG_TXPKT_EMPTY				0x041A
 
 #define REG_CPU_MGQ_INFORMATION		0x041C
@@ -448,13 +442,6 @@
 #define REG_RXERR_RPT				0x0664
 #define REG_WMAC_TRXPTCL_CTL		0x0668
 
-// Security
-#define REG_CAMCMD					0x0670
-#define REG_CAMWRITE					0x0674
-#define REG_CAMREAD					0x0678
-#define REG_CAMDBG					0x067C
-#define REG_SECCFG					0x0680
-
 // Power
 #define REG_WOW_CTRL					0x0690
 #define REG_PS_RX_INFO				0x0692
@@ -658,37 +645,6 @@ Default: 00b.
 #define	BW_OPMODE_20MHZ			BIT2
 #define	BW_OPMODE_5G				BIT1
 
-
-//----------------------------------------------------------------------------
-//       8192C CAM Config Setting (offset 0x250, 1 byte)
-//----------------------------------------------------------------------------
-#define	CAM_VALID					BIT15
-#define	CAM_NOTVALID				0x0000
-#define	CAM_USEDK					BIT5
-
-#define	CAM_CONTENT_COUNT 		8
-       	       		
-#define	CAM_NONE					0x0
-#define	CAM_WEP40					0x01
-#define	CAM_TKIP					0x02
-#define	CAM_AES					0x04
-#define	CAM_WEP104				0x05
-#define	CAM_SMS4					0x6
-        		
-#define	TOTAL_CAM_ENTRY			32
-#define	HALF_CAM_ENTRY			16	
-       		
-#define	CAM_CONFIG_USEDK			_TRUE
-#define	CAM_CONFIG_NO_USEDK		_FALSE
-       		
-#define	CAM_WRITE					BIT16
-#define	CAM_READ					0x00000000
-#define	CAM_POLLINIG				BIT31
-
-#define	SCR_UseDK					0x01
-#define	SCR_TxSecEnable			0x02
-#define	SCR_RxSecEnable			0x04
-
 //
 // 10. Power Save Control Registers	 (Offset: 0x0260 - 0x02DF)
 //
@@ -1317,18 +1273,6 @@ Current IOREG MAP
 #define APP_MIC						BIT(30)
 #define APP_FCS						BIT(31)
 
-
-//2 SECCFG
-#define	SCR_TxUseDK						BIT(0)			//Force Tx Use Default Key
-#define	SCR_RxUseDK						BIT(1)			//Force Rx Use Default Key
-#define	SCR_TxEncEnable					BIT(2)			//Enable Tx Encryption
-#define	SCR_RxDecEnable					BIT(3)			//Enable Rx Decryption
-#define	SCR_SKByA2						BIT(4)			//Search kEY BY A2
-#define	SCR_NoSKMC						BIT(5)			//No Key Search Multicast
-#define 	SCR_TXBCUSEDK					BIT(6)			// Force Tx Broadcast packets Use Default Key
-#define 	SCR_RXBCUSEDK					BIT(7)			// Force Rx Broadcast packets Use Default Key
-
-
 //-----------------------------------------------------
 //
 //	RTL8188E SDIO Configuration
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192c_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192c_spec.h
index ce88b0224452..54f7ca229159 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192c_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192c_spec.h
@@ -21,6 +21,7 @@
 #define __RTL8192C_SPEC_H__
 
 #include <drv_conf.h>
+#include "hal_com_reg.h"
 
 //============================================================
 //       8192C Regsiter offset definition
@@ -193,15 +194,6 @@
 //	0x0400h ~ 0x047Fh	Protocol Configuration
 //
 //-----------------------------------------------------
-#define REG_VOQ_INFORMATION			0x0400
-#define REG_VIQ_INFORMATION			0x0404
-#define REG_BEQ_INFORMATION			0x0408
-#define REG_BKQ_INFORMATION			0x040C
-#define REG_MGQ_INFORMATION			0x0410
-#define REG_HGQ_INFORMATION			0x0414
-#define REG_BCNQ_INFORMATION			0x0418
-
-
 #define REG_CPU_MGQ_INFORMATION		0x041C
 #define REG_FWHW_TXQ_CTRL				0x0420
 #define REG_HWSEQ_CTRL					0x0423
@@ -344,13 +336,6 @@
 #define REG_WMAC_TRXPTCL_CTL		0x0668
 
 
-// Security
-#define REG_CAMCMD					0x0670
-#define REG_CAMWRITE				0x0674
-#define REG_CAMREAD				0x0678
-#define REG_CAMDBG					0x067C
-#define REG_SECCFG					0x0680
-
 // Power
 #define REG_WOW_CTRL				0x0690
 #define REG_PSSTATUS				0x0691
@@ -537,37 +522,6 @@ Default: 00b.
 #define	BW_OPMODE_5G				BIT1
 #define	BW_OPMODE_11J				BIT0
 
-
-//----------------------------------------------------------------------------
-//       8192C CAM Config Setting (offset 0x250, 1 byte)
-//----------------------------------------------------------------------------
-#define	CAM_VALID					BIT15
-#define	CAM_NOTVALID				0x0000
-#define	CAM_USEDK					BIT5
-
-#define	CAM_CONTENT_COUNT 		8
-       	       		
-#define	CAM_NONE					0x0
-#define	CAM_WEP40					0x01
-#define	CAM_TKIP					0x02
-#define	CAM_AES					0x04
-#define	CAM_WEP104				0x05
-        		
-#define	TOTAL_CAM_ENTRY			32
-#define	HALF_CAM_ENTRY			16	
-       		
-#define	CAM_CONFIG_USEDK			_TRUE
-#define	CAM_CONFIG_NO_USEDK		_FALSE
-       		
-#define	CAM_WRITE					BIT16
-#define	CAM_READ					0x00000000
-#define	CAM_POLLINIG				BIT31
-
-#define	SCR_UseDK					0x01
-#define	SCR_TxSecEnable			0x02
-#define	SCR_RxSecEnable			0x04
-
-
 //
 // 12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F)
 //
@@ -1696,17 +1650,6 @@ Current IOREG MAP
 #define RXERR_RPT_RST						BIT(27)
 #define _RXERR_RPT_SEL(type)				((type) << 28)
 
-
-//2 SECCFG
-#define	SCR_TxUseDK						BIT(0)			//Force Tx Use Default Key
-#define	SCR_RxUseDK						BIT(1)			//Force Rx Use Default Key
-#define	SCR_TxEncEnable					BIT(2)			//Enable Tx Encryption
-#define	SCR_RxDecEnable					BIT(3)			//Enable Rx Decryption
-#define	SCR_SKByA2							BIT(4)			//Search kEY BY A2
-#define	SCR_NoSKMC							BIT(5)			//No Key Search Multicast
-
-
-
 //-----------------------------------------------------
 //
 //	0xFE00h ~ 0xFE55h	USB Configuration
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192d_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192d_spec.h
index 74e11d5af653..1ebb126ec0e3 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192d_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8192d_spec.h
@@ -22,6 +22,7 @@
 #define __RTL8192D_SPEC_H__
 
 #include <drv_conf.h>
+#include "hal_com_reg.h"
 
 //============================================================
 //       8192D Regsiter offset definition
@@ -207,15 +208,6 @@
 //	0x0400h ~ 0x047Fh	Protocol Configuration
 //
 //-----------------------------------------------------
-#define REG_VOQ_INFORMATION			0x0400
-#define REG_VIQ_INFORMATION			0x0404
-#define REG_BEQ_INFORMATION			0x0408
-#define REG_BKQ_INFORMATION			0x040C
-#define REG_MGQ_INFORMATION			0x0410
-#define REG_HGQ_INFORMATION			0x0414
-#define REG_BCNQ_INFORMATION			0x0418
-
-
 #define REG_CPU_MGQ_INFORMATION		0x041C
 #define REG_FWHW_TXQ_CTRL				0x0420
 #define REG_HWSEQ_CTRL					0x0423
@@ -356,14 +348,6 @@
 #define REG_RXERR_RPT				0x0664
 #define REG_WMAC_TRXPTCL_CTL		0x0668
 
-
-// Security
-#define REG_CAMCMD					0x0670
-#define REG_CAMWRITE				0x0674
-#define REG_CAMREAD				0x0678
-#define REG_CAMDBG					0x067C
-#define REG_SECCFG					0x0680
-
 // Power
 #define REG_WOW_CTRL				0x0690
 #define REG_PSSTATUS				0x0691
@@ -553,39 +537,6 @@ Default: 00b.
 #define	BW_OPMODE_5G				BIT1
 #define	BW_OPMODE_11J				BIT0
 
-
-//----------------------------------------------------------------------------
-//       8192C CAM Config Setting (offset 0x250, 1 byte)
-//----------------------------------------------------------------------------
-#define	CAM_VALID					BIT15
-#define	CAM_NOTVALID				0x0000
-#define	CAM_USEDK					BIT5
-
-#define	CAM_CONTENT_COUNT 		8
-
-#define	CAM_NONE					0x0
-#define	CAM_WEP40					0x01
-#define	CAM_TKIP					0x02
-#define	CAM_AES					0x04
-#define	CAM_WEP104				0x05
-#define	CAM_SMS4					0x6
-
-
-#define	TOTAL_CAM_ENTRY			32
-#define	HALF_CAM_ENTRY			16	
-       		
-#define	CAM_CONFIG_USEDK			_TRUE
-#define	CAM_CONFIG_NO_USEDK		_FALSE
-       		
-#define	CAM_WRITE					BIT16
-#define	CAM_READ					0x00000000
-#define	CAM_POLLINIG				BIT31
-
-#define	SCR_UseDK					0x01
-#define	SCR_TxSecEnable			0x02
-#define	SCR_RxSecEnable			0x04
-
-
 //
 // 12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F)
 //
@@ -1687,24 +1638,6 @@ Current IOREG MAP
 #define RXERR_RPT_RST					BIT(27)
 #define _RXERR_RPT_SEL(type)			((type) << 28)
 
-
-//2 SECCFG
-#define	SCR_TxUseDK					BIT(0)			//Force Tx Use Default Key
-#define	SCR_RxUseDK					BIT(1)			//Force Rx Use Default Key
-#define	SCR_TxEncEnable				BIT(2)			//Enable Tx Encryption
-#define	SCR_RxDecEnable				BIT(3)			//Enable Rx Decryption
-#define	SCR_SKByA2						BIT(4)			//Search kEY BY A2
-#define	SCR_NoSKMC						BIT(5)			//No Key Search Multicast
-#define 	SCR_TXBCUSEDK					BIT(6)			// Force Tx Broadcast packets Use Default Key
-#define 	SCR_RXBCUSEDK					BIT(7)			// Force Rx Broadcast packets Use Default Key
-
-//vivi added for new cam search flow, 20091028
-#ifdef HW_EN_DE_CRYPTION_FOR_NEW_CAM_SEARCH_FLOW
-#define	SCR_TxUseBroadcastDK			BIT6			//Force Tx Use Broadcast Default Key
-#define	SCR_RxUseBroadcastDK			BIT7			//Force Rx Use Broadcast Default Key
-#endif
-
-
 //-----------------------------------------------------
 //
 //	0xFE00h ~ 0xFE55h	USB Configuration
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_bt-coexist.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_bt-coexist.h
index 128eaff2387e..78d64b8d81b9 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_bt-coexist.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_bt-coexist.h
@@ -1466,7 +1466,6 @@ typedef struct _BT_COEXIST_8723A
 	u8					bC2hBtInfoReqSent;
 	u8					bForceFwBtInfo;
 	u8					bForceA2dpSink;
-	u8					bBusyTrafficForCoex;
 //	u8					bForceLps;
 //	u8					bBtPwrSaveMode;
 	BTDM_8723A_2ANT			btdm2Ant;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_hal.h
index 2111999b82f4..eab5aafa5fd8 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtl8723a_hal.h
@@ -818,6 +818,7 @@ void Hal_InitChannelPlan(PADAPTER padapter);
 void rtl8723a_set_hal_ops(struct hal_ops *pHalFunc);
 void SetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val);
 void GetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val);
+u8 GetHalDefVar8723A(PADAPTER Adapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 #ifdef CONFIG_BT_COEXIST
 void rtl8723a_SingleDualAntennaDetection(PADAPTER padapter);
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_ap.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_ap.h
index a93e1e8da886..0aa871d73661 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_ap.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_ap.h
@@ -37,7 +37,8 @@ void free_mlme_ap_info(_adapter *padapter);
 //void update_BCNTIM(_adapter *padapter);
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
 void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
-void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag);
+#define update_beacon(adapter, ie_id, oui, tx) _update_beacon((adapter), (ie_id), (oui), (tx), __func__)
 void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level);
 void expire_timeout_chk(_adapter *padapter);
 void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_cmd.h
index 97a468c04b27..cbf5222f4c5e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_cmd.h
@@ -130,6 +130,16 @@ do {\
 	pcmd->rspsz = 0;\
 } while(0)
 
+#define init_h2fwcmd_w_parm_no_parm_rsp(pcmd, code) \
+do {\
+	_rtw_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = NULL;\
+	pcmd->cmdsz = 0;\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
 struct c2h_evt_hdr {
 	u8 id:4;
 	u8 plen:4;
@@ -351,7 +361,7 @@ when shared key ==> algorithm/keyid
 struct set_stakey_parm {
 	u8	addr[ETH_ALEN];
 	u8	algorithm;
-	u8 	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_ 
+	u8	keyid;
 	u8	key[16];
 };
 
@@ -945,8 +955,11 @@ u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num,
 extern u8 rtw_createbss_cmd(_adapter  *padapter);
 extern u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz);
 extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
-extern u8 rtw_setstakey_cmd(_adapter  *padapter, u8 *psta, u8 unicast_key, bool enqueue);
-extern u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue);
+
+struct sta_info;
+extern u8 rtw_setstakey_cmd(_adapter  *padapter, struct sta_info *sta, u8 unicast_key, bool enqueue);
+extern u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue);
+
 extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork);
 u8 rtw_disassoc_cmd(_adapter *padapter, u32 deauth_timeout_ms, bool enqueue);
 extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, bool enqueue);
@@ -1089,6 +1102,7 @@ enum rtw_h2c_cmd
 
 	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
 	GEN_CMD_CODE(_TDLS), /*62*/
+	GEN_CMD_CODE(_ChkBMCSleepq), /*63*/
 	
 	MAX_H2CCMD
 };
@@ -1171,6 +1185,7 @@ struct _cmd_callback 	rtw_cmd_callback[] =
 	
 	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
 	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
+	{GEN_CMD_CODE(_ChkBMCSleepq), NULL}, /*63*/
 };
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_debug.h
index bb9685ecb818..e3d78548bb0d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_debug.h
@@ -335,6 +335,11 @@ void mac_reg_dump(void *sel, _adapter *adapter);
 void bb_reg_dump(void *sel, _adapter *adapter);
 void rf_reg_dump(void *sel, _adapter *adapter);
 
+bool rtw_fwdl_test_trigger_chksum_fail(void);
+bool rtw_fwdl_test_trigger_wintint_rdy_fail(void);
+
+u32 rtw_get_wait_hiq_empty_ms(void);
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 int proc_get_read_reg(struct seq_file *m, void *v);
@@ -351,6 +356,7 @@ int proc_get_adapter_state(struct seq_file *m, void *v);
 int proc_get_trx_info(struct seq_file *m, void *v);
 
 ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
 #ifdef CONFIG_DBG_COUNTER
 int proc_get_rx_logs(struct seq_file *m, void *v);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme.h
index 33c6f4229306..fba8bbc50567 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme.h
@@ -171,6 +171,9 @@ typedef struct _RT_LINK_DETECT_T{
 	BOOLEAN			bHigherBusyTraffic; // For interrupt migration purpose.
 	BOOLEAN			bHigherBusyRxTraffic; // We may disable Tx interrupt according as Rx traffic.
 	BOOLEAN			bHigherBusyTxTraffic; // We may disable Tx interrupt according as Tx traffic.
+#ifdef CONFIG_BT_COEXIST	
+	BOOLEAN			bBusyTrafficForCoex;
+#endif
 }RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;
 
 struct profile_info {
@@ -261,6 +264,7 @@ struct cfg80211_wifidirect_info{
 	struct ieee80211_channel	remain_on_ch_channel;
 	enum nl80211_channel_type	remain_on_ch_type;
 	u64						remain_on_ch_cookie;
+	bool not_indic_ro_ch_exp;
 	bool is_ro_ch;
 };
 #endif //CONFIG_IOCTL_CFG80211
@@ -601,6 +605,9 @@ struct mlme_priv {
 #ifdef CONFIG_FTP_PROTECT
 	u8	ftp_lock_flag;
 #endif //CONFIG_FTP_PROTECT
+
+	u8 	NumOfBcnInfoChkFail;
+	u32	timeBcnInfoChkStart;
 };
 
 #ifdef CONFIG_AP_MODE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme_ext.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme_ext.h
index c94e03372904..63fd7142977c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_mlme_ext.h
@@ -599,8 +599,19 @@ void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_
 
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
 void read_cam(_adapter *padapter ,u8 entry);
-void write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key);
-void clear_cam_entry(_adapter *padapter, u8 entry);
+
+/* modify HW only */
+void _write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key);
+void _clear_cam_entry(_adapter *padapter, u8 entry);
+void write_cam_from_cache(_adapter *adapter, u8 id);
+
+/* modify both HW and cache */
+void write_cam(_adapter *padapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_entry(_adapter *padapter, u8 id);
+
+/* modify cache only */
+void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_cache(_adapter *adapter, u8 id);
 
 void invalidate_cam_all(_adapter *padapter);
 void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
@@ -655,6 +666,8 @@ void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
 void rtw_get_sec_iv(PADAPTER padapter, u8*pcur_dot11txpn, u8 *StaAddr);
 #endif
 
+u8 rtw_check_invalid_mac_address (u8 *mac_addr);
+
 //for sta/adhoc mode
 void update_sta_info(_adapter *padapter, struct sta_info *psta);
 unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
@@ -671,7 +684,11 @@ unsigned int is_ap_in_tkip(_adapter *padapter);
 unsigned int is_ap_in_wep(_adapter *padapter);
 unsigned int should_forbid_n_rate(_adapter * padapter);
 
-extern uint rtw_get_camid(uint macid);
+s16 rtw_get_camid(_adapter *adapter, struct sta_info* sta, s16 kid);
+s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid);
+s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid);
+void rtw_camid_free(_adapter *adapter, u8 cam_id);
+
 extern void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
 extern void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
 extern u8 rtw_search_max_mac_id(_adapter *padapter);
@@ -683,6 +700,7 @@ void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr, unsigned s
 void report_add_sta_event(_adapter *padapter, unsigned char* MacAddr, int cam_idx);
 
 void beacon_timing_control(_adapter *padapter);
+u8 chk_bmc_sleepq_cmd(_adapter* padapter);
 extern u8 set_tx_beacon_cmd(_adapter*padapter);
 unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
 void update_mgnt_tx_rate(_adapter *padapter, u8 rate);
@@ -708,6 +726,7 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da);
 s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8* da, int try_cnt, int wait_ms);
 int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da);
 int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
 int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
 int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
@@ -844,6 +863,7 @@ u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf);
 
 u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf);
 u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf);
 u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf);
 u8 set_ch_hdl(_adapter *padapter, u8 *pbuf);
 u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf);
@@ -925,6 +945,7 @@ struct cmd_hdl wlancmds[] =
 
 	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl) /*61*/
 	GEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl) /*62*/
+	GEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl) /*63*/
 };
 
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_recv.h
index 97ffea34a063..337d355a2f12 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_recv.h
@@ -324,9 +324,6 @@ struct recv_priv
 	struct ifqueue rx_indicate_queue;
 #endif	// CONFIG_RX_INDICATE_QUEUE
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	_queue	recv_buf_pending_queue;
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
 #endif //defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
 
 	u8 *pallocated_recv_buf;
@@ -334,7 +331,7 @@ struct recv_priv
 	_queue	free_recv_buf_queue;
 	u32	free_recv_buf_queue_cnt;
 
-#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI) || defined(CONFIG_USB_HCI) 
 	_queue	recv_buf_pending_queue;
 #endif
 
@@ -740,9 +737,14 @@ __inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 {
 	s32	SignalPower; // in dBm.
 
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	// Translate to dBm (x=y-100)
+	SignalPower = SignalStrengthIndex - 100;
+#else
 	// Translate to dBm (x=0.5y-95).
 	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1); 
 	SignalPower -= 95; 
+#endif
 
 	return SignalPower;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_security.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_security.h
index 730857c2b97e..6243222fd63a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_security.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_security.h
@@ -39,6 +39,8 @@
 #endif //CONFIG_IEEE80211W
 #define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
 
+const char *security_type_str(u8 value);
+
 #define _WPA_IE_ID_	0xdd
 #define _WPA2_IE_ID_	0x30
 
@@ -205,6 +207,30 @@ struct security_priv
 	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
 
 	u8 bWepDefaultKeyIdxSet;
+
+#define DBG_SW_SEC_CNT
+#ifdef DBG_SW_SEC_CNT
+	u64 wep_sw_enc_cnt_bc;
+	u64 wep_sw_enc_cnt_mc;
+	u64 wep_sw_enc_cnt_uc;
+	u64 wep_sw_dec_cnt_bc;
+	u64 wep_sw_dec_cnt_mc;
+	u64 wep_sw_dec_cnt_uc;
+
+	u64 tkip_sw_enc_cnt_bc;
+	u64 tkip_sw_enc_cnt_mc;
+	u64 tkip_sw_enc_cnt_uc;
+	u64 tkip_sw_dec_cnt_bc;
+	u64 tkip_sw_dec_cnt_mc;
+	u64 tkip_sw_dec_cnt_uc;
+
+	u64 aes_sw_enc_cnt_bc;
+	u64 aes_sw_enc_cnt_mc;
+	u64 aes_sw_enc_cnt_uc;
+	u64 aes_sw_dec_cnt_bc;
+	u64 aes_sw_dec_cnt_mc;
+	u64 aes_sw_dec_cnt_uc;
+#endif /* DBG_SW_SEC_CNT */
 };
 
 struct sha256_state {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_version.h
index 3331da403a06..d8ebbe51bbe1 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_version.h
@@ -1 +1 @@
-#define DRIVERVERSION	"v4.1.10_10648.20140227_BTCOEX20131115_ver3.4"
+#define DRIVERVERSION	"v4.1.11_12622.20141215_BTCOEX20140409_ver3.5"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_xmit.h
index 0da14ddd621c..5c817939ecf0 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/include/rtw_xmit.h
@@ -744,7 +744,7 @@ void rtw_free_hwxmits(_adapter *padapter);
 
 
 s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
-
+bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
 void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/gspi_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/gspi_intf.c
index eb1a13f01b73..948b29dc469a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/gspi_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/gspi_intf.c
@@ -195,6 +195,7 @@ _func_enter_;
 	dvobj->processing_dev_remove = _FALSE;
 	_rtw_spinlock_init(&dvobj->lock);
 	dvobj->macid[1] = _TRUE; //macid=1 for bc/mc stainfo
+	_rtw_spinlock_init(&dvobj->cam_ctl.lock);
 	//spi init
 	/* This is the only SPI value that we need to set here, the rest
 	 * comes from the board-peripherals file */
@@ -236,6 +237,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 		dvobj = NULL;
 	}
@@ -260,6 +262,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 	}
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_cfg80211.c
index 60e61dfc633c..6299edc6dabd 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_cfg80211.c
@@ -357,6 +357,19 @@ static int rtw_ieee80211_channel_to_frequency(int chan, int band)
 	}
 }
 
+static u64 rtw_get_systime_us(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
+	struct timespec ts;
+	get_monotonic_boottime(&ts);
+	return ((u64)ts.tv_sec*1000000) + ts.tv_nsec / 1000;
+#else
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	return ((u64)tv.tv_sec*1000000) + tv.tv_usec;
+#endif
+}
+
 #define MAX_BSSINFO_LEN 1000
 struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnetwork)
 {
@@ -371,7 +384,10 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	u8 *notify_ie;
 	size_t notify_ielen;
 	s32 notify_signal;
-	u8 buf[MAX_BSSINFO_LEN], *pbuf;
+	//u8 buf[MAX_BSSINFO_LEN];
+
+	u8 *pbuf;
+	size_t buf_size = MAX_BSSINFO_LEN;
 	size_t len,bssinf_len=0;
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
@@ -381,12 +397,17 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	struct wiphy *wiphy = wdev->wiphy;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
+	pbuf = rtw_zmalloc(buf_size);
+	if(pbuf == NULL){
+		DBG_871X("%s pbuf allocate failed  !! \n",__FUNCTION__);
+		return bss;
+	}
 
 	//DBG_8192C("%s\n", __func__);
 
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
-	if(bssinf_len > MAX_BSSINFO_LEN){
-		DBG_871X("%s IE Length too long > %d byte \n",__FUNCTION__,MAX_BSSINFO_LEN);
+	if(bssinf_len > buf_size){
+		DBG_871X("%s IE Length too long > %zu byte \n",__FUNCTION__,buf_size);
 		goto exit;
 	}
 
@@ -472,13 +493,14 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 
-	//rtw_get_timestampe_from_ie()
-	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
+	if (0)
+		notify_timestamp = le64_to_cpu(*(u64*)rtw_get_timestampe_from_ie(pnetwork->network.IEs));
+	else
+		notify_timestamp = rtw_get_systime_us();
 
 	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
 	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));		
 
-	
 	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
@@ -496,10 +518,10 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	DBG_8192C("Capability: %X\n", notify_capability);
 	DBG_8192C("Beacon interval: %d\n", notify_interval);
 	DBG_8192C("Signal: %d\n", notify_signal);
-	DBG_8192C("notify_timestamp: %#018llx\n", notify_timestamp);
+	DBG_8192C("notify_timestamp: %llu\n", notify_timestamp);
 	#endif
 
-	pbuf = buf;
+	//pbuf = buf;
 	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;	
 	fctrl = &(pwlanhdr->frame_ctl);
@@ -520,10 +542,11 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	_rtw_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
 
 
-	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);	
+	//pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
 	len = sizeof (struct rtw_ieee80211_hdr_3addr);
+	_rtw_memcpy((pbuf+len), pnetwork->network.IEs, pnetwork->network.IELength);
+	*((u64*)(pbuf+len)) = cpu_to_le64(notify_timestamp);
 
-	_rtw_memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
 	len += pnetwork->network.IELength;
 
 	//#ifdef CONFIG_P2P
@@ -532,10 +555,9 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	//	DBG_8192C("%s, got p2p_ie\n", __func__);
 	//}
 	//#endif
-	
 
 #if 1	
-	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
+	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)pbuf,
 		len, notify_signal, GFP_ATOMIC);
 #else			 
 			
@@ -587,7 +609,11 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	cfg80211_put_bss(bss);
 #endif
 
-exit:	
+exit:
+
+	if(pbuf)
+		rtw_mfree(pbuf, buf_size);
+
 	return bss;
 	
 }
@@ -619,6 +645,12 @@ int rtw_cfg80211_check_bss(_adapter *padapter)
 			pnetwork->Ssid.SsidLength,
 			WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+	cfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);
+#else
+	cfg80211_put_bss(bss);
+#endif
+
 	return 	(bss!=NULL);
 }
 
@@ -1393,7 +1425,7 @@ _func_enter_;
 					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:unicastkey\n");
 					
-					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE, _TRUE);
+					rtw_setstakey_cmd(padapter, psta, _TRUE, _TRUE);
 				}
 				else//group key
 				{
@@ -1407,14 +1439,7 @@ _func_enter_;
 						DBG_871X(" ~~~~set sta key:groupkey\n");
 	
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
-#ifdef CONFIG_CONCURRENT_MODE 
-						if (padapter->adapter_type == PRIMARY_ADAPTER)
-							rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1,_TRUE);
-						else
-							DBG_871X_LEVEL(_drv_always_, "second interface do not set cam.\n");
-#else
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1,_TRUE);
-#endif
 					}
 #ifdef CONFIG_IEEE80211W
 					else if(strcmp(param->u.crypt.alg, "BIP") == 0)
@@ -2356,18 +2381,15 @@ if (padapter->registrypriv.mp_mode == 1)
 
 
 #ifdef CONFIG_P2P
-	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-		{
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-			rtw_free_network_queue(padapter, _TRUE);
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_free_network_queue(padapter, _TRUE);
 
-			if(social_channel == 0)
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-			else
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
-		}
+		if(social_channel == 0)
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		else
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
 	}
 #endif //CONFIG_P2P
 
@@ -3324,16 +3346,23 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 {
 	u8	index,blInserted = _FALSE;
 	_adapter	*padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *mlme = &padapter->mlmepriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(netdev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
 
 	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
 	{
 		return -EINVAL;
 	}
 
+	if (check_fwstate(mlme, _FW_LINKED) == _FALSE) {
+		DBG_871X(FUNC_NDEV_FMT" not set pmksa cause not in linked state\n", FUNC_NDEV_ARG(netdev));
+		return -EINVAL;
+	}
+
 	blInserted = _FALSE;
 	
 	//overwrite PMKID
@@ -3379,7 +3408,8 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 	_adapter	*padapter = wiphy_to_adapter(wiphy);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(netdev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
 
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
@@ -3389,6 +3419,7 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 			_rtw_memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
 			psecuritypriv->PMKIDList[index].bUsed = _FALSE;
 			bMatched = _TRUE;
+			DBG_871X(FUNC_NDEV_FMT" clear id:%hhu\n", FUNC_NDEV_ARG(netdev), index);		
 			break;
 		}	
 	}
@@ -4628,15 +4659,14 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 
 	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
 	{
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
-		
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-
-#ifdef CONFIG_CONCURRENT_MODE
-                ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);			
-#endif //CONFIG_CONCURRENT_MODE	
-
+		#ifdef CONFIG_CONCURRENT_MODE
+		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+		#endif //CONFIG_CONCURRENT_MODE
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	pcfg80211_wdinfo->is_ro_ch = _TRUE;
@@ -4781,12 +4811,14 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
 	if (pcfg80211_wdinfo->is_ro_ch == _TRUE) {
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		#ifdef CONFIG_CONCURRENT_MODE
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 		#endif
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	#if 0
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_linux.c
index b0d1bacaf16a..331f6ebe800b 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/ioctl_linux.c
@@ -188,7 +188,7 @@ static void indicate_wx_custom_event(_adapter *padapter, char *msg)
 
 }
 
-
+#ifdef CONFIG_SUPPORT_HW_WPS_PBC
 static void request_wps_pbc_event(_adapter *padapter)
 {
 	u8 *buff, *p;
@@ -223,7 +223,7 @@ static void request_wps_pbc_event(_adapter *padapter)
 	}
 
 }
-
+#endif//#ifdef CONFIG_SUPPORT_HW_WPS_PBC
 
 void indicate_wx_scan_complete_event(_adapter *padapter)
 {	
@@ -309,27 +309,12 @@ uint	rtw_is_cckratesonly_included(u8 *rate)
 }
 */
 
-static char *translate_scan(_adapter *padapter, 
+static int search_p2p_wfd_ie(_adapter *padapter,
 				struct iw_request_info* info, struct wlan_network *pnetwork,
 				char *start, char *stop)
 {
-	struct iw_event iwe;
-	u16 cap;
-	u32 ht_ielen = 0;
-	char custom[MAX_CUSTOM_LEN];
-	char *p;
-	u16 max_rate=0, rate, ht_cap=_FALSE;
-	u32 i = 0;	
-	char	*current_val;
-	long rssi;
-	u8 bw_40MHz=0, short_GI=0;
-	u16 mcs_rate=0;
-	struct registry_priv *pregpriv = &padapter->registrypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
-
-#ifdef CONFIG_P2P
 #ifdef CONFIG_WFD
 	if ( SCAN_RESULT_ALL == pwdinfo->wfd_info->scan_result_type )
 	{
@@ -352,24 +337,16 @@ static char *translate_scan(_adapter *padapter,
 			{
 				u32	p2pielen = 0;
 
-				if (pnetwork->network.Reserved[0] == 2) { // Probe Request
-					//	Verifying the P2P IE
-					if ( rtw_get_p2p_ie( pnetwork->network.IEs, pnetwork->network.IELength, NULL, &p2pielen) )
-					{
-						blnGotP2PIE = _TRUE;
-					}
-				} else { // Beacon or Probe Respones
-					//	Verifying the P2P IE
-					if ( rtw_get_p2p_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen) )
-					{
-						blnGotP2PIE = _TRUE;
-					}
+				//	Verifying the P2P IE
+				if (rtw_get_p2p_ie_from_scan_queue(&pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &p2pielen, pnetwork->network.Reserved[0]))
+				{
+					blnGotP2PIE = _TRUE;
 				}
 			}
 
 			if ( blnGotP2PIE == _FALSE )
 			{
-				return start;
+				return _FALSE;
 			}
 			
 		}
@@ -413,141 +390,223 @@ static char *translate_scan(_adapter *padapter,
 		
 		if ( blnGotWFD == _FALSE )
 		{
-			return start;
+			return _FALSE;
 		}
 	}
 #endif // CONFIG_WFD
 
 #endif //CONFIG_P2P
+	return _TRUE;
+}
 
+static inline char *iwe_stream_mac_addr_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
 	/*  AP MAC address  */
-	iwe.cmd = SIOCGIWAP;
-	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	iwe->cmd = SIOCGIWAP;
+	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
 
-	_rtw_memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+	_rtw_memcpy(iwe->u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);
+	return start;
+}
 
+static inline char * iwe_stream_essid_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
 	/* Add the ESSID */
-	iwe.cmd = SIOCGIWESSID;
-	iwe.u.data.flags = 1;	
-	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
-	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+	iwe->cmd = SIOCGIWESSID;
+	iwe->u.data.flags = 1;
+	iwe->u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);
+	return start;
+}
 
-	//parsing HT_CAP_IE
-	if (pnetwork->network.Reserved[0] == 2) // Probe Request
-	{
-		p = rtw_get_ie(&pnetwork->network.IEs[0], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength);
+static inline char * iwe_stream_chan_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	/* Add frequency/channel */
+	iwe->cmd = SIOCGIWFREQ;
+	iwe->u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe->u.freq.e = 1;
+	iwe->u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_FREQ_LEN);
+	return start;
+}
+
+static inline char * iwe_stream_mode_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{
+	/* Add mode */
+	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+		iwe->cmd = SIOCGIWMODE;
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe->u.mode = IW_MODE_MASTER;
+		else
+			iwe->u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_UINT_LEN);
 	}
+	return start;
+}
+
+static inline char * iwe_stream_encryption_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{
+	/* Add encryption capability */
+	iwe->cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe->u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 	else
-	{
-		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
-	}
+		iwe->u.data.flags = IW_ENCODE_DISABLED;
+	iwe->u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);
+	return start;
+}
+
+static inline char * iwe_stream_protocol_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u16 ht_cap=_FALSE,vht_cap = _FALSE;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request
+
+	//parsing HT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);
 	if(p && ht_ielen>0)
-	{
-		struct rtw_ieee80211_ht_cap *pht_capie;
-		ht_cap = _TRUE;			
-		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);		
-		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
-		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
-		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
-	}
+		ht_cap = _TRUE;
 
+	#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+		vht_cap = _TRUE;
+	#endif
 	/* Add the protocol name */
-	iwe.cmd = SIOCGIWNAME;
-	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
+	iwe->cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
 	{
 		if(ht_cap == _TRUE)
-			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bn");
 		else
-		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
-	}	
-	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11b");
+	}
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
 	{
 		if(ht_cap == _TRUE)
-			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bgn");
 		else
-			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
-	}	
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}
 	else
 	{
 		if(pnetwork->network.Configuration.DSConfig > 14)
 		{
-			if(ht_cap == _TRUE)
-				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
+			#ifdef CONFIG_80211AC_VHT
+			if(vht_cap == _TRUE){
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11AC");
+			}
 			else
-				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
+			#endif
+			{
+				if(ht_cap == _TRUE)
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11an");
+				else
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11a");
+			}
 		}
 		else
 		{
 			if(ht_cap == _TRUE)
-				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11gn");
 			else
-				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11g");
 		}
-	}	
+	}
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_CHAR_LEN);
+	return start;
+}
 
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+static inline char * iwe_stream_rate_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
+	u32 i = 0;
+	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
+	u16 mcs_rate=0, vht_data_rate=0;
+	char custom[MAX_CUSTOM_LEN]={0};
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request
 
-	  /* Add mode */
-	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	//parsing HT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && ht_ielen>0)
 	{
-		cap = 0;
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = _TRUE;
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
 	}
-	else
+
+#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
 	{
-        iwe.cmd = SIOCGIWMODE;
-		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
-		cap = le16_to_cpu(cap);
-	}
+		u8	mcs_map[2];
 
-	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
-		if (cap & WLAN_CAPABILITY_BSS)
-			iwe.u.mode = IW_MODE_MASTER;
+		vht_cap = _TRUE;
+		bw_160MHz = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+		if(bw_160MHz)
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI160M(p+2);
 		else
-			iwe.u.mode = IW_MODE_ADHOC;
-
-		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
-	}
-
-	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
-		pnetwork->network.Configuration.DSConfig = 1;
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI80M(p+2);
 
-	 /* Add frequency/channel */
-	iwe.cmd = SIOCGIWFREQ;
-	iwe.u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
-	iwe.u.freq.e = 1;
-	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+		_rtw_memcpy(mcs_map, GET_VHT_CAPABILITY_ELE_TX_MCS(p+2), 2);
 
-	/* Add encryption capability */
-	iwe.cmd = SIOCGIWENCODE;
-	if (cap & WLAN_CAPABILITY_PRIVACY)
-		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-	else
-		iwe.u.data.flags = IW_ENCODE_DISABLED;
-	iwe.u.data.length = 0;
-	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+		vht_highest_rate = rtw_get_vht_highest_rate(mcs_map);
+		vht_data_rate = rtw_vht_mcs_to_data_rate(CHANNEL_WIDTH_80, short_GI, vht_highest_rate);
+	}
+#endif
 
 	/*Add basic and extended rates */
-	max_rate = 0;
 	p = custom;
 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
 	while(pnetwork->network.SupportedRates[i]!=0)
 	{
-		rate = pnetwork->network.SupportedRates[i]&0x7F; 
+		rate = pnetwork->network.SupportedRates[i]&0x7F;
 		if (rate > max_rate)
 			max_rate = rate;
 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
 			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
 		i++;
 	}
-	
+
+#ifdef CONFIG_80211AC_VHT
+	if(vht_cap == _TRUE) {
+		max_rate = vht_data_rate;
+	}
+	else
+#endif
 	if(ht_cap == _TRUE)
 	{
 		if(mcs_rate&0x8000)//MCS15
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
-			
 		}
 		else if(mcs_rate&0x0080)//MCS7
 		{
@@ -559,119 +618,143 @@ static char *translate_scan(_adapter *padapter,
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
 
-		max_rate = max_rate*2;//Mbps/2;		
+		max_rate = max_rate*2;//Mbps/2;
 	}
 
-	iwe.cmd = SIOCGIWRATE;
-	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
-	iwe.u.bitrate.value = max_rate * 500000;
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
+	iwe->cmd = SIOCGIWRATE;
+	iwe->u.bitrate.fixed = iwe->u.bitrate.disabled = 0;
+	iwe->u.bitrate.value = max_rate * 500000;
+	start =iwe_stream_add_event(info, start, stop, iwe, IW_EV_PARAM_LEN);
+	return start ;
+}
 
-	//parsing WPA/WPA2 IE
-	if (pnetwork->network.Reserved[0] != 2) // Probe Request
-	{
-		u8 buf[MAX_WPA_IE_LEN*2];
-		u8 wpa_ie[255],rsn_ie[255];
-		u16 wpa_len=0,rsn_len=0;
-		u8 *p;
-		sint out_len=0;
-		out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+static inline char * iwe_stream_wpa_wpa2_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	int buf_size = MAX_WPA_IE_LEN*2;
+	//u8 pbuf[buf_size]={0};
+	u8 *pbuf = rtw_zmalloc(buf_size);
+
+	u8 wpa_ie[255]={0},rsn_ie[255]={0};
+	u16 i, wpa_len=0,rsn_len=0;
+	u8 *p;
+	sint out_len=0;
 
-		if (wpa_len > 0)
+	if(pbuf){
+		p=pbuf;
+
+		//parsing WPA/WPA2 IE
+		if (pnetwork->network.Reserved[0] != 2) // Probe Request
 		{
-			p=buf;
-			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
-			p += sprintf(p, "wpa_ie=");
-			for (i = 0; i < wpa_len; i++) {
-				p += sprintf(p, "%02x", wpa_ie[i]);
-			}
+			out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
 
-			if (wpa_len > 100) {
-				printk("-----------------Len %d----------------\n", wpa_len);
+			if (wpa_len > 0){
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "wpa_ie=");
 				for (i = 0; i < wpa_len; i++) {
-					printk("%02x ", wpa_ie[i]);
+					p += sprintf(p, "%02x", wpa_ie[i]);
 				}
-				printk("\n");
-				printk("-----------------Len %d----------------\n", wpa_len);
+
+				if (wpa_len > 100) {
+					printk("-----------------Len %d----------------\n", wpa_len);
+					for (i = 0; i < wpa_len; i++) {
+						printk("%02x ", wpa_ie[i]);
+					}
+					printk("\n");
+					printk("-----------------Len %d----------------\n", wpa_len);
+				}
+
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = wpa_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, wpa_ie);
 			}
-	
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			iwe.u.data.length = strlen(buf);
-			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
-			
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd =IWEVGENIE;
-			iwe.u.data.length = wpa_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);			
-		}
-		if (rsn_len > 0)
-		{
-			p = buf;
-			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
-			p += sprintf(p, "rsn_ie=");
-			for (i = 0; i < rsn_len; i++) {
-				p += sprintf(p, "%02x", rsn_ie[i]);
+
+			if (rsn_len > 0){
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "rsn_ie=");
+				for (i = 0; i < rsn_len; i++) {
+					p += sprintf(p, "%02x", rsn_ie[i]);
+				}
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = rsn_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, rsn_ie);
 			}
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			iwe.u.data.length = strlen(buf);
-			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
-		
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd =IWEVGENIE;
-			iwe.u.data.length = rsn_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);		
 		}
+
+		rtw_mfree(pbuf, buf_size);
 	}
+	return start;
+}
 
-	{ //parsing WPS IE
-		uint cnt = 0,total_ielen;	
-		u8 *wpsie_ptr=NULL;
-		uint wps_ielen = 0;		
+static inline char * iwe_stream_wps_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	//parsing WPS IE
+	uint cnt = 0,total_ielen;
+	u8 *wpsie_ptr=NULL;
+	uint wps_ielen = 0;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
 
-		u8 *ie_ptr = pnetwork->network.IEs +_FIXED_IE_LENGTH_;
-		total_ielen= pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+	u8 *ie_ptr = pnetwork->network.IEs + ie_offset;
+	total_ielen= pnetwork->network.IELength - ie_offset;
 
-		if (pnetwork->network.Reserved[0] == 2) // Probe Request
-		{
-			ie_ptr = pnetwork->network.IEs;
-			total_ielen = pnetwork->network.IELength;
-		}
-		else     // Beacon or Probe Respones
-		{
-			ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
-			total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
-		}
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		ie_ptr = pnetwork->network.IEs;
+		total_ielen = pnetwork->network.IELength;
+	}
+	else // Beacon or Probe Respones
+	{
+		ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+	}
 
-		while(cnt < total_ielen)
+	while(cnt < total_ielen)
+	{
+		if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))
 		{
-			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
-			{
-				wpsie_ptr = &ie_ptr[cnt];
-				iwe.cmd =IWEVGENIE;
-				iwe.u.data.length = (u16)wps_ielen;
-				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);						
-			}			
-			cnt+=ie_ptr[cnt+1]+2; //goto next
+			wpsie_ptr = &ie_ptr[cnt];
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = (u16)wps_ielen;
+			start = iwe_stream_add_point(info, start, stop,iwe, wpsie_ptr);
 		}
+		cnt+=ie_ptr[cnt+1]+2; //goto next
 	}
+	return start;
+}
 
+static inline char * iwe_stream_wapi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
 #ifdef CONFIG_WAPI_SUPPORT
+	char *p;
+
 	if (pnetwork->network.Reserved[0] != 2) // Probe Request
 	{
 		sint out_len_wapi=0;
 		/* here use static for stack size */
-		static u8 buf_wapi[MAX_WAPI_IE_LEN*2];
-		static u8 wapi_ie[MAX_WAPI_IE_LEN];
+		static u8 buf_wapi[MAX_WAPI_IE_LEN*2]={0};
+		static u8 wapi_ie[MAX_WAPI_IE_LEN]={0};
 		u16 wapi_len=0;
 		u16  i;
 
-		_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN);
-		_rtw_memset(wapi_ie, 0, MAX_WAPI_IE_LEN);
-
 		out_len_wapi=rtw_get_wapi_ie(pnetwork->network.IEs ,pnetwork->network.IELength,wapi_ie,&wapi_len);
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wapi_len=%d \n",wapi_len));
@@ -679,88 +762,151 @@ static char *translate_scan(_adapter *padapter,
 		DBG_871X("rtw_wx_get_scan: %s ",pnetwork->network.Ssid.Ssid);
 		DBG_871X("rtw_wx_get_scan: ssid = %d ",wapi_len);
 
-
 		if (wapi_len > 0)
 		{
 			p=buf_wapi;
-			_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
+			//_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
 			p += sprintf(p, "wapi_ie=");
 			for (i = 0; i < wapi_len; i++) {
 				p += sprintf(p, "%02x", wapi_ie[i]);
 			}
 
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			iwe.u.data.length = strlen(buf_wapi);
-			start = iwe_stream_add_point(info, start, stop, &iwe,buf_wapi);
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd = IWEVCUSTOM;
+			iwe->u.data.length = strlen(buf_wapi);
+			start = iwe_stream_add_point(info, start, stop, iwe,buf_wapi);
 
-			_rtw_memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd =IWEVGENIE;
-			iwe.u.data.length = wapi_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, wapi_ie);
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = wapi_len;
+			start = iwe_stream_add_point(info, start, stop, iwe, wapi_ie);
 		}
 	}
-#endif //CONFIG_WAPI_SUPPORT
+#endif//#ifdef CONFIG_WAPI_SUPPORT
+	return start;
+}
 
+static inline char *  iwe_stream_rssi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
 {
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 ss, sq;
-	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
 	/* Add quality statistics */
-	iwe.cmd = IWEVQUAL;
-	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
+	iwe->cmd = IWEVQUAL;
+	iwe->u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		| IW_QUAL_NOISE_UPDATED
+	#else
+		| IW_QUAL_NOISE_INVALID
+	#endif
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		| IW_QUAL_DBM
 	#endif
 	;
 
 	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
-		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)){
 		ss = padapter->recvpriv.signal_strength;
 		sq = padapter->recvpriv.signal_qual;
 	} else {
 		ss = pnetwork->network.PhyInfo.SignalStrength;
 		sq = pnetwork->network.PhyInfo.SignalQuality;
 	}
-	
-	
-	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
-	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
+
+#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	iwe->u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
+#else
+	#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	{
+		/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+		HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+		iwe->u.qual.level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, ss);
+	}
 	#else
-	iwe.u.qual.level = (u8)ss;//%
+	iwe->u.qual.level = (u8)ss;//%
 	#ifdef CONFIG_BT_COEXIST
-	BT_SignalCompensation(padapter, &iwe.u.qual.level, NULL);
+	BT_SignalCompensation(padapter, &iwe->u.qual.level, NULL);
 	#endif // CONFIG_BT_COEXIST
 	#endif
-	
-	iwe.u.qual.qual = (u8)sq;   // signal quality
+#endif
+
+	iwe->u.qual.qual = (u8)sq;   // signal quality
 
 	#ifdef CONFIG_PLATFORM_ROCKCHIPS
-	iwe.u.qual.noise = -100; // noise level suggest by zhf@rockchips
-	#else 
-	iwe.u.qual.noise = 0; // noise level
+	iwe->u.qual.noise = -100; // noise level suggest by zhf@rockchips
+	#else
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	{
+		s16 tmp_noise=0;
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(tmp_noise));
+		iwe->u.qual.noise = tmp_noise;
+	}
+	#else
+	iwe->u.qual.noise = 0; // noise level
+	#endif
 	#endif //CONFIG_PLATFORM_ROCKCHIPS
-	
+
 	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
 
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_QUAL_LEN);
+	return start;
 }
 
+static inline char *  iwe_stream_net_rsv_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u8 buf[32] = {0};
+	u8 * p,*pos;
+	int len;
+	p = buf;
+	pos = pnetwork->network.Reserved;
+
+	p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
+	_rtw_memset(iwe, 0, sizeof(*iwe));
+	iwe->cmd = IWEVCUSTOM;
+	iwe->u.data.length = strlen(buf);
+	start = iwe_stream_add_point(info, start, stop,iwe, buf);
+	return start;
+}
+
+static char *translate_scan(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+	struct iw_event iwe;
+	u16 cap = 0;
+	_rtw_memset(&iwe, 0, sizeof(iwe));
+
+	if(_FALSE == search_p2p_wfd_ie(padapter,info,pnetwork,start,stop))
+		return start;
+
+	start = iwe_stream_mac_addr_proess(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_essid_proess(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_protocol_process(padapter,info,pnetwork,start,stop,&iwe);
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
 	{
-		u8 buf[MAX_WPA_IE_LEN];
-		u8 * p,*pos;
-		int len;
-		p = buf;
-		pos = pnetwork->network.Reserved;
-		_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
-		p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
-		_rtw_memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVCUSTOM;
-		iwe.u.data.length = strlen(buf);
-		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		cap = 0;
 	}
-	
-	return start;	
+	else
+	{
+		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+		cap = le16_to_cpu(cap);
+	}
+
+	start = iwe_stream_mode_process(padapter,info,pnetwork,start,stop,&iwe,cap);
+	start = iwe_stream_chan_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_encryption_process(padapter,info,pnetwork,start,stop,&iwe,cap);
+	start = iwe_stream_rate_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wpa_wpa2_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wps_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wapi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_rssi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_net_rsv_process(padapter,info,pnetwork,start,stop,&iwe);
+
+	return start;
 }
 
 static int wpa_set_auth_algs(struct net_device *dev, u32 value)
@@ -987,7 +1133,7 @@ _func_enter_;
 					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:unicastkey\n");
 					
-					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE, _TRUE);
+					rtw_setstakey_cmd(padapter, psta, _TRUE, _TRUE);
 				}
 				else//group key
 				{ 					
@@ -6271,6 +6417,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 	{
 		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
 #ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 		rtw_free_network_queue(padapter, _TRUE);		
@@ -12622,7 +12769,8 @@ static int rtw_widi_set_probe_request(struct net_device *dev,
 	pbuf = rtw_malloc(sizeof(l2_msg_t));
 	if(pbuf)
 	{
-		copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length);
+		if ( copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length) )
+			ret = -EFAULT;
 		//_rtw_memcpy(pbuf, wrqu->data.pointer, wrqu->data.length);
 
 		if( wrqu->data.flags == 0 )
@@ -13711,6 +13859,15 @@ static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength); 
 		#else
+		#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		{
+			/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+			
+			HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+			
+			tmp_level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, padapter->recvpriv.signal_strength);
+		}
+		#else
 		tmp_level = padapter->recvpriv.signal_strength;
 		#ifdef CONFIG_BT_COEXIST
 		{
@@ -13720,6 +13877,7 @@ static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 		}
 		#endif // CONFIG_BT_COEXIST
 		#endif
+		#endif
 		
 		tmp_qual = padapter->recvpriv.signal_qual;
 		tmp_noise =padapter->recvpriv.noise;		
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/os_intfs.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/os_intfs.c
index 594eeb6a2d14..1b7cbb27b6f4 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/os_intfs.c
@@ -47,18 +47,6 @@
 #include <rtw_br_ext.h>
 #endif //CONFIG_BR_EXT
 
-#ifdef CONFIG_RF_GAIN_OFFSET
-#ifdef CONFIG_RTL8723A
-#define	RF_GAIN_OFFSET_ON			BIT0
-#define		REG_RF_BB_GAIN_OFFSET	0x7f
-#define		RF_GAIN_OFFSET_MASK		0xfffff
-#else
-#define	RF_GAIN_OFFSET_ON			BIT4
-#define		REG_RF_BB_GAIN_OFFSET	0x55
-#define		RF_GAIN_OFFSET_MASK		0xfffff
-#endif  //CONFIG_RTL8723A
-#endif //CONFIG_RF_GAIN_OFFSET
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
 MODULE_AUTHOR("Realtek Semiconductor Corp.");
@@ -308,6 +296,10 @@ uint rtw_notch_filter = RTW_NOTCH_FILTER;
 module_param(rtw_notch_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
 
+uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;
+module_param(rtw_hiq_filter, uint, 0644);
+MODULE_PARM_DESC(rtw_hiq_filter, "0:allow all, 1:allow special, 2:deny all");
+
 static uint loadparam(PADAPTER padapter, _nic_hdl pnetdev);
 int _netdev_open(struct net_device *pnetdev);
 int netdev_open (struct net_device *pnetdev);
@@ -442,7 +434,8 @@ _func_enter_;
 	registry_par->force_igi = (u8)rtw_force_igi;
 #endif
 	registry_par->regulatory_tid = (u8)rtw_regulatory_id;
-	
+
+	registry_par->hiq_filter = (u8)rtw_hiq_filter;
 
 _func_exit_;
 
@@ -1727,10 +1720,6 @@ int _netdev_open(struct net_device *pnetdev)
 		
 		DBG_871X("MAC Address = "MAC_FMT"\n", MAC_ARG(pnetdev->dev_addr));
 
-#ifdef CONFIG_RF_GAIN_OFFSET
-		rtw_bb_rf_gain_offset(padapter);	
-#endif //CONFIG_RF_GAIN_OFFSET
-
 		status=rtw_start_drv_threads(padapter);
 		if(status ==_FAIL)
 		{			
@@ -1837,10 +1826,6 @@ int  ips_netdrv_open(_adapter *padapter)
 		goto netdev_open_error;
 	}
 	
-#ifdef CONFIG_RF_GAIN_OFFSET
-	rtw_bb_rf_gain_offset(padapter);	
-#endif //CONFIG_RF_GAIN_OFFSET
-
 	if(padapter->intf_start)
 	{
 		padapter->intf_start(padapter);
@@ -1911,57 +1896,6 @@ void rtw_ips_dev_unload(_adapter *padapter)
 
 }
 
-#ifdef CONFIG_RF_GAIN_OFFSET
-void rtw_bb_rf_gain_offset(_adapter *padapter)
-{
-	u8      value = padapter->eeprompriv.EEPROMRFGainOffset;
-	u8      tmp = 0x3e;
-	u32     res;
-
-	DBG_871X("+%s value: 0x%02x+\n", __func__, value);
-
-	if (value & RF_GAIN_OFFSET_ON) {
-		//DBG_871X("Offset RF Gain.\n");
-		//DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x\n",padapter->eeprompriv.EEPROMRFGainVal);
-		if(padapter->eeprompriv.EEPROMRFGainVal != 0xff){
-#ifdef CONFIG_RTL8723A
-			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0xd, 0xffffffff);
-			//DBG_871X("Offset RF Gain. reg 0xd=0x%x\n",res);
-			res &= 0xfff87fff;
-
-			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15;
-			//DBG_871X("Offset RF Gain.    reg 0xd=0x%x\n",res);
-
-			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
-
-			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0xe, 0xffffffff);
-			DBG_871X("Offset RF Gain. reg 0xe=0x%x\n",res);
-			res &= 0xfffffff0;
-
-			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f);
-			//DBG_871X("Offset RF Gain.    reg 0xe=0x%x\n",res);
-
-			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
-#else
-			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, 0xffffffff);
-			DBG_871X("REG_RF_BB_GAIN_OFFSET=%x \n",res);
-			res &= 0xfff87fff;
-			res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15;
-			DBG_871X("write REG_RF_BB_GAIN_OFFSET=%x \n",res);
-			rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
-#endif
-		}
-		else
-		{
-			//DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x  != 0xff, didn't run Kfree\n",padapter->eeprompriv.EEPROMRFGainVal);
-		}
-	} else {
-		//DBG_871X("Using the default RF gain.\n");
-	}
-
-}
-#endif //CONFIG_RF_GAIN_OFFSET
-
 int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
 {
 	int status;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/pci_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/pci_intf.c
index ed675f4191b4..c87868d73750 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/pci_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/pci_intf.c
@@ -1161,6 +1161,9 @@ _func_enter_;
 	dvobj->macid[1] = _TRUE; //macid=1 for bc/mc stainfo
 
 	dvobj->processing_dev_remove = _FALSE;
+
+	_rtw_spinlock_init(&dvobj->cam_ctl.lock);
+
 	if ( (err = pci_enable_device(pdev)) != 0) {
 		DBG_871X(KERN_ERR "%s : Cannot enable new PCI device\n", pci_name(pdev));
 		goto free_dvobj;
@@ -1328,6 +1331,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 		dvobj = NULL;
 	}
@@ -1359,6 +1363,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.c
index a26e5d559772..b8b485971ad5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.c
@@ -250,6 +250,95 @@ static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
 	return 0;
 }
 
+static int proc_get_mac_qinfo(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_hal_get_hwreg(adapter, HW_VAR_DUMP_MAC_QUEUE_INFO, (u8 *)m);
+
+	return 0;
+}
+
+static int proc_get_cam(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 i;
+
+	return 0;
+}
+
+static ssize_t proc_set_cam(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter;
+
+	char tmp[32];
+	char cmd[4];
+	u8 id;
+
+	adapter = (_adapter *)rtw_netdev_priv(dev);
+	if (!adapter)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		/* c <id>: clear specific cam entry */
+		/* wfc <id>: write specific cam entry from cam cache */
+
+		int num = sscanf(tmp, "%s %hhu", cmd, &id);
+
+		if (num < 2)
+			return count;
+
+		if (strcmp("c", cmd) == 0) {
+			_clear_cam_entry(adapter, id);
+			adapter->securitypriv.hw_decrypted = _FALSE; /* temporarily set this for TX path to use SW enc */
+		} else if (strcmp("wfc", cmd) == 0) {
+			write_cam_from_cache(adapter, id);
+		}
+	}
+
+	return count;
+}
+
+static int proc_get_cam_cache(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	u8 i;
+
+	DBG_871X_SEL_NL(m, "cam bitmap:0x%016llx\n", dvobj->cam_ctl.bitmap);
+
+	DBG_871X_SEL_NL(m, "%-2s %-6s %-17s %-32s %-3s %-7s"
+		//" %-2s %-2s %-4s %-5s"
+		"\n"
+		, "id", "ctrl", "addr", "key", "kid", "type"
+		//, "MK", "GK", "MFB", "valid"
+	);
+
+	for (i=0;i<32;i++) {
+		if (dvobj->cam_cache[i].ctrl != 0)
+			DBG_871X_SEL_NL(m, "%2u 0x%04x "MAC_FMT" "KEY_FMT" %3u %-7s"
+				//" %2u %2u 0x%02x %5u"
+				"\n", i
+				, dvobj->cam_cache[i].ctrl
+				, MAC_ARG(dvobj->cam_cache[i].mac)
+				, KEY_ARG(dvobj->cam_cache[i].key)
+				, (dvobj->cam_cache[i].ctrl)&0x03
+				, security_type_str(((dvobj->cam_cache[i].ctrl)>>2)&0x07)
+				//, ((dvobj->cam_cache[i].ctrl)>>5)&0x01
+				//, ((dvobj->cam_cache[i].ctrl)>>6)&0x01
+				//, ((dvobj->cam_cache[i].ctrl)>>8)&0x7f
+				//, ((dvobj->cam_cache[i].ctrl)>>15)&0x01
+			);
+	}
+
+	return 0;
+}
+
 /*
 * rtw_adapter_proc:
 * init/deinit when register/unregister net_device
@@ -266,6 +355,9 @@ const struct rtw_proc_hdl adapter_proc_hdls [] = {
 	{"ap_info", proc_get_ap_info, NULL},
 	{"adapter_state", proc_get_adapter_state, NULL},
 	{"trx_info", proc_get_trx_info, NULL},
+	{"mac_qinfo", proc_get_mac_qinfo, NULL},
+	{"cam", proc_get_cam, proc_set_cam},
+	{"cam_cache", proc_get_cam_cache, NULL},
 
 #ifdef CONFIG_DBG_COUNTER
 	{"rx_logs", proc_get_rx_logs, NULL},
@@ -274,6 +366,7 @@ const struct rtw_proc_hdl adapter_proc_hdls [] = {
 #endif
 
 	{"fwdl_test_case", proc_get_dummy, proc_set_fwdl_test_case},
+	{"wait_hiq_empty", proc_get_dummy, proc_set_wait_hiq_empty},
 
 	{"mac_reg_dump", proc_get_mac_reg_dump, NULL},
 	{"bb_reg_dump", proc_get_bb_reg_dump, NULL},
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.h b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.h
index d45a28e2bb46..9aee7bf56f68 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/rtw_proc.h
@@ -40,12 +40,12 @@ void rtw_adapter_proc_replace(struct net_device *dev);
 
 #else //!CONFIG_PROC_DEBUG
 
-struct proc_dir_entry *get_rtw_drv_proc(void) {return NULL;}
-int rtw_drv_proc_init(void) {return 0;}
-void rtw_drv_proc_deinit(void) {}
-struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev){return NULL;}
-void rtw_adapter_proc_deinit(struct net_device *dev){}
-void rtw_adapter_proc_replace(struct net_device *dev){}
+#define get_rtw_drv_proc() NULL
+#define rtw_drv_proc_init() 0
+#define rtw_drv_proc_deinit() do {} while (0)
+#define rtw_adapter_proc_init(dev) NULL
+#define rtw_adapter_proc_deinit(dev) do {} while (0)
+#define rtw_adapter_proc_replace(dev) do {} while (0)
 
 #endif //!CONFIG_PROC_DEBUG
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/sdio_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/sdio_intf.c
index 334b5b898af4..38701c813566 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/sdio_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/sdio_intf.c
@@ -349,6 +349,7 @@ _func_enter_;
 	 _rtw_spinlock_init(&dvobj->lock);
 
 	 dvobj->macid[1] = _TRUE; //macid=1 for bc/mc stainfo
+	 _rtw_spinlock_init(&dvobj->cam_ctl.lock);
 
 #ifdef CONFIG_WOWLAN
 	sdio_claim_host(func);
@@ -375,6 +376,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 		dvobj = NULL;
 	}
@@ -396,6 +398,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 	}
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_intf.c
index bae55ac6290b..282262b22e38 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_intf.c
@@ -556,8 +556,9 @@ _func_enter_;
 	_rtw_mutex_init(&pdvobjpriv->setbw_mutex);
 	pdvobjpriv->processing_dev_remove = _FALSE;
 
-        _rtw_spinlock_init(&pdvobjpriv->lock);
+	_rtw_spinlock_init(&pdvobjpriv->lock);
 	pdvobjpriv->macid[1] = _TRUE; //macid=1 for bc/mc stainfo
+	_rtw_spinlock_init(&pdvobjpriv->cam_ctl.lock);
 
 	pdvobjpriv->pusbintf = usb_intf ;
 	pusbd = pdvobjpriv->pusbdev = interface_to_usbdev(usb_intf);
@@ -698,6 +699,7 @@ _func_enter_;
 		_rtw_mutex_free(&pdvobjpriv->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&pdvobjpriv->setch_mutex);
 		_rtw_mutex_free(&pdvobjpriv->setbw_mutex);
+		_rtw_spinlock_free(&pdvobjpriv->cam_ctl.lock);
 		rtw_mfree((u8*)pdvobjpriv, sizeof(*pdvobjpriv));
 		pdvobjpriv = NULL;
 	}
@@ -730,6 +732,7 @@ _func_enter_;
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
 		_rtw_mutex_free(&dvobj->setch_mutex);
 		_rtw_mutex_free(&dvobj->setbw_mutex);
+		_rtw_spinlock_free(&dvobj->cam_ctl.lock);
 		rtw_mfree((u8*)dvobj, sizeof(*dvobj));
 	}
 	
@@ -2048,7 +2051,7 @@ _func_exit_;
 extern int console_suspend_enabled;
 #endif
 
-static int rtw_drv_entry(void)
+static int /*__init*/ rtw_drv_entry(void)
 {
 	int ret = 0;
 
@@ -2122,7 +2125,7 @@ static int rtw_drv_entry(void)
 	return ret;
 }
 
-static void rtw_drv_halt(void)
+static void /*exit*/ rtw_drv_halt(void)
 {
 	DBG_871X_LEVEL(_drv_always_, "module exit start\n");
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_ops_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_ops_linux.c
index e9229e613337..655c3e853c08 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_ops_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/usb_ops_linux.c
@@ -167,7 +167,7 @@ unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
 		pipe=usb_rcvbulkpipe(pusbd, pdvobj->RtInPipe[0]);
 		
 	} else if (addr == RECV_INT_IN_ADDR) {	
-		pipe=usb_rcvbulkpipe(pusbd, pdvobj->RtInPipe[1]);
+		pipe=usb_rcvintpipe(pusbd, pdvobj->RtInPipe[1]);
 		
 	} else if (addr < HW_QUEUE_ENTRY) {
 		ep_num = pdvobj->Queue2Pipe[addr];
@@ -330,11 +330,6 @@ _func_enter_;
 		case BK_QUEUE_INX:
 			pxmitpriv->bkq_cnt--;			
 			break;
-		case HIGH_QUEUE_INX:
-#ifdef CONFIG_AP_MODE			
-			rtw_chk_hi_queue_cmd(padapter);
-#endif
-			break;
 		default:			
 			break;
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/xmit_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/xmit_linux.c
index 9baccc3f08e1..ffc4c6ef75f1 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/xmit_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723au/os_dep/linux/xmit_linux.c
@@ -422,7 +422,11 @@ _func_enter_;
 	if ( !rtw_mc2u_disable
 		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
 		&& ( IP_MCAST_MAC(pkt->data)
-			|| ICMPV6_MCAST_MAC(pkt->data) )
+			|| ICMPV6_MCAST_MAC(pkt->data)
+			#ifdef CONFIG_TX_BCAST2UNI
+			|| is_broadcast_mac_addr(pkt->data)
+			#endif
+			)
 		&& (padapter->registrypriv.wifi_spec == 0)
                 )
 	{
-- 
2.35.3

