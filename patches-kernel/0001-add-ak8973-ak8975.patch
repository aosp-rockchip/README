From a93ac942ee0bccf1997b245eaab790d3e306caa3 Mon Sep 17 00:00:00 2001
From: lhh <lhh@rock-chips.com>
Date: Tue, 30 Nov 2010 09:50:50 +0800
Subject: [PATCH] add ak8973 ak8975

---
 arch/arm/mach-rk29/board-rk29sdk.c        |   4 +-
 drivers/staging/iio/Kconfig               |   2 +-
 drivers/staging/iio/Makefile              |   4 +-
 drivers/staging/iio/magnetometer/Kconfig  |  25 +
 drivers/staging/iio/magnetometer/Makefile |   5 +
 drivers/staging/iio/magnetometer/ak8973.c | 751 ++++++++++++++++++++++
 drivers/staging/iio/magnetometer/ak8973.h |  53 ++
 drivers/staging/iio/magnetometer/ak8975.c | 501 +++++++++++++++
 drivers/staging/iio/magnetometer/magnet.h |  31 +
 9 files changed, 1372 insertions(+), 4 deletions(-)
 create mode 100644 drivers/staging/iio/magnetometer/Kconfig
 create mode 100644 drivers/staging/iio/magnetometer/Makefile
 create mode 100644 drivers/staging/iio/magnetometer/ak8973.c
 create mode 100644 drivers/staging/iio/magnetometer/ak8973.h
 create mode 100644 drivers/staging/iio/magnetometer/ak8975.c
 create mode 100644 drivers/staging/iio/magnetometer/magnet.h

diff --git a/arch/arm/mach-rk29/board-rk29sdk.c b/arch/arm/mach-rk29/board-rk29sdk.c
index e247da0c4327..a4239137a171 100644
--- a/arch/arm/mach-rk29/board-rk29sdk.c
+++ b/arch/arm/mach-rk29/board-rk29sdk.c
@@ -450,13 +450,15 @@ static struct i2c_board_info __initdata board_i2c1_devices[] = {
 		.type    		= "ak8973",
 		.addr           = 0x1c,
 		.flags			= 0,
+		.irq			= RK29_PIN4_PA1,
 	},
 #endif
-#if defined (CONFIG_SENSORS_AK8973)
+#if defined (CONFIG_SENSORS_AK8975)
 	{
 		.type    		= "ak8975",
 		.addr           = 0x1c,
 		.flags			= 0,
+		.irq			= RK29_PIN4_PA1,
 	},
 #endif
 };
diff --git a/drivers/staging/iio/Kconfig b/drivers/staging/iio/Kconfig
index 4586650d65c3..ee6988360d2c 100644
--- a/drivers/staging/iio/Kconfig
+++ b/drivers/staging/iio/Kconfig
@@ -42,7 +42,7 @@ config IIO_TRIGGER
 source "drivers/staging/iio/accel/Kconfig"
 source "drivers/staging/iio/adc/Kconfig"
 source "drivers/staging/iio/light/Kconfig"
-
+source "drivers/staging/iio/magnetometer/Kconfig"
 source "drivers/staging/iio/trigger/Kconfig"
 
 endif # IIO
diff --git a/drivers/staging/iio/Makefile b/drivers/staging/iio/Makefile
index 7ec021810a77..caa53f3f3eaa 100644
--- a/drivers/staging/iio/Makefile
+++ b/drivers/staging/iio/Makefile
@@ -12,5 +12,5 @@ obj-$(CONFIG_IIO_SW_RING) += ring_sw.o
 obj-y += accel/
 obj-y += adc/
 obj-y += light/
-
-obj-y += trigger/
\ No newline at end of file
+obj-y += trigger/
+obj-y += magnetometer/
\ No newline at end of file
diff --git a/drivers/staging/iio/magnetometer/Kconfig b/drivers/staging/iio/magnetometer/Kconfig
new file mode 100644
index 000000000000..7d023296e810
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/Kconfig
@@ -0,0 +1,25 @@
+
+#
+# Magnetometer sensors
+#s"
+comment "Magnetometer sensor
+config SENSORS_AK8975                                          
+  tristate "Asahi Kasei AK8975 3-Axis Magnetometer"             
+  default n                                                     
+  depends on I2C                                                
+  help                                                          
+  Say yes here to build support for Asahi Kasei AK8975 3-Axis   
+  Magnetometer.                                                 
+                                                                
+  To compile this driver as a module, choose M here: the module 
+  will be called ak8975.      
+config SENSORS_AK8973                                          
+  tristate "Asahi Kasei AK8973 3-Axis Magnetometer"             
+  default n                                                     
+  depends on I2C                                                
+  help                                                          
+  Say yes here to build support for Asahi Kasei AK8973 3-Axis   
+  Magnetometer.                                                 
+                                                                
+  To compile this driver as a module, choose M here: the module 
+  will be called ak8973.                                        
\ No newline at end of file
diff --git a/drivers/staging/iio/magnetometer/Makefile b/drivers/staging/iio/magnetometer/Makefile
new file mode 100644
index 000000000000..b982369efd1a
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for industrial I/O Magnetometer sensors
+#
+obj-$(CONFIG_SENSORS_AK8975) := ak8975.o 
+obj-$(CONFIG_SENSORS_AK8973) := ak8973.o 
\ No newline at end of file
diff --git a/drivers/staging/iio/magnetometer/ak8973.c b/drivers/staging/iio/magnetometer/ak8973.c
new file mode 100644
index 000000000000..6d0b2ca5fabf
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/ak8973.c
@@ -0,0 +1,751 @@
+/*
+ * drivers/i2c/chips/ak8973.c - ak8973 compass driver
+ *
+ *  Copyright (C) 2008 viral wang <viralwang@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <asm/gpio.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include "ak8973.h"
+#include<linux/earlysuspend.h>
+
+#define DEBUG 0
+#define MAX_FAILURE_COUNT 3
+
+static struct i2c_client *this_client;
+
+struct akm8973_data {
+	struct input_dev *input_dev;
+	struct work_struct work;
+#ifdef CONFIG_HAS_EARLYSUSPEND	
+	struct early_suspend early_suspend_akm;
+#endif	
+};
+
+/* Addresses to scan -- protected by sense_data_mutex */
+static char sense_data[RBUFF_SIZE + 1];
+static struct mutex sense_data_mutex;
+#define AKM8973_RETRY_COUNT 10
+static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
+static DECLARE_WAIT_QUEUE_HEAD(open_wq);
+
+static atomic_t data_ready;
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+static atomic_t m_flag;
+static atomic_t a_flag;
+static atomic_t t_flag;
+static atomic_t mv_flag;
+
+static int failure_count = 0;
+
+static short akmd_delay = 0;
+#ifdef CONFIG_HAS_EARLYSUSPEND  
+static atomic_t suspend_flag = ATOMIC_INIT(0);
+#endif
+
+static int AKI2C_RxData(char *rxData, int length)
+{
+	uint8_t loop_i;
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = 1,
+		 .buf = rxData,
+		 },
+		{
+		 .addr = this_client->addr,
+		 .flags = I2C_M_RD,
+		 .len = length,
+		 .buf = rxData,
+		 },
+	};
+
+	for (loop_i = 0; loop_i < AKM8973_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (loop_i >= AKM8973_RETRY_COUNT) {
+		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8973_RETRY_COUNT);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int AKI2C_TxData(char *txData, int length)
+{
+	uint8_t loop_i;
+	struct i2c_msg msg[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txData,
+		 },
+	};
+	
+	for (loop_i = 0; loop_i < AKM8973_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (loop_i >= AKM8973_RETRY_COUNT) {
+		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8973_RETRY_COUNT);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int AKECS_StartMeasure(void)
+{
+	char buffer[2];
+
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_MEASURE;
+
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_PowerDown(void)
+{
+	char buffer[2];
+	int ret;
+
+	/* Set powerdown mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_POWERDOWN;
+	/* Set data */
+	ret = AKI2C_TxData(buffer, 2);
+	if (ret < 0)
+		return ret;
+
+	/* Dummy read for clearing INT pin */
+	buffer[0] = AKECS_REG_TMPS;
+	/* Read data */
+	ret = AKI2C_RxData(buffer, 1);
+	if (ret < 0)
+		return ret;
+	return ret;
+}
+
+static int AKECS_StartE2PRead(void)
+{
+	char buffer[2];
+
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_E2P_READ;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_GetData(void)
+{
+	char buffer[RBUFF_SIZE + 1];
+	int ret;
+
+	memset(buffer, 0, RBUFF_SIZE + 1);
+	buffer[0] = AKECS_REG_ST;
+	ret = AKI2C_RxData(buffer, RBUFF_SIZE+1);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&sense_data_mutex);
+	memcpy(sense_data, buffer, sizeof(buffer));
+	atomic_set(&data_ready, 1);
+	wake_up(&data_ready_wq);
+	mutex_unlock(&sense_data_mutex);
+
+	return 0;
+}
+
+static int AKECS_SetMode(char mode)
+{
+	int ret;
+
+	switch (mode) {
+	case AKECS_MODE_MEASURE:
+		ret = AKECS_StartMeasure();
+		break;
+	case AKECS_MODE_E2P_READ:
+		ret = AKECS_StartE2PRead();
+		break;
+	case AKECS_MODE_POWERDOWN:
+		ret = AKECS_PowerDown();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* wait at least 300us after changing mode */
+	msleep(1);
+	return ret;
+}
+
+static int AKECS_TransRBuff(char *rbuf, int size)
+{
+	wait_event_interruptible_timeout(data_ready_wq,
+					 atomic_read(&data_ready), 1000);
+	if (!atomic_read(&data_ready)) {
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		if (!atomic_read(&suspend_flag)) {
+			printk(KERN_ERR
+				"AKM8973 AKECS_TransRBUFF: Data not ready\n");
+			failure_count++;
+			if (failure_count >= MAX_FAILURE_COUNT) {
+				printk(KERN_ERR
+				       "AKM8973 AKECS_TransRBUFF: successive %d failure.\n",
+				       failure_count);
+				atomic_set(&open_flag, -1);
+				wake_up(&open_wq);
+				failure_count = 0;
+			}
+		}
+		#endif
+		return -1;
+	}
+
+	mutex_lock(&sense_data_mutex);
+	memcpy(&rbuf[1], &sense_data[1], size);
+	atomic_set(&data_ready, 0);
+	mutex_unlock(&sense_data_mutex);
+
+	failure_count = 0;
+	return 0;
+}
+
+
+static void AKECS_Report_Value(short *rbuf)
+{
+	struct akm8973_data *data = i2c_get_clientdata(this_client);
+#if DEBUG
+	printk(KERN_INFO"AKECS_Report_Value: yaw = %d, pitch = %d, roll = %d\n", rbuf[0],
+	       rbuf[1], rbuf[2]);
+	printk(KERN_INFO"                    tmp = %d, m_stat= %d, g_stat=%d\n", rbuf[3],
+	       rbuf[4], rbuf[5]);
+	printk(KERN_INFO"          G_Sensor:   x = %d LSB, y = %d LSB, z = %d LSB\n",
+	       rbuf[6], rbuf[7], rbuf[8]);
+#endif
+	/* Report magnetic sensor information */
+	if (atomic_read(&m_flag)) {
+		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
+		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
+		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
+		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
+	}
+
+	/* Report acceleration sensor information */
+	if (atomic_read(&a_flag)) {
+		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
+		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
+		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
+		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
+	}
+
+	/* Report temperature information */
+	if (atomic_read(&t_flag))
+		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
+
+	if (atomic_read(&mv_flag)) {
+		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
+	}
+
+	input_sync(data->input_dev);
+}
+
+static int AKECS_GetOpenStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
+	return atomic_read(&open_flag);
+}
+
+static int AKECS_GetCloseStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
+	return atomic_read(&open_flag);
+}
+
+static void AKECS_CloseDone(void)
+{
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&t_flag, 1);
+	atomic_set(&mv_flag, 1);
+}
+
+static int akm_aot_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int akm_aot_release(struct inode *inode, struct file *file)
+{
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+	return 0;
+}
+
+static int
+akm_aot_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	short flag;
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+	case ECS_IOCTL_APP_SET_AFLAG:
+	case ECS_IOCTL_APP_SET_TFLAG:
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+		atomic_set(&m_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_MFLAG:
+		flag = atomic_read(&m_flag);
+		break;
+	case ECS_IOCTL_APP_SET_AFLAG:
+		atomic_set(&a_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_AFLAG:
+		flag = atomic_read(&a_flag);
+		break;
+	case ECS_IOCTL_APP_SET_TFLAG:
+		atomic_set(&t_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_TFLAG:
+		flag = atomic_read(&t_flag);
+		break;
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		atomic_set(&mv_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_MVFLAG:
+		flag = atomic_read(&mv_flag);
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		akmd_delay = flag;
+		break;
+	case ECS_IOCTL_APP_GET_DELAY:
+		flag = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_GET_MFLAG:
+	case ECS_IOCTL_APP_GET_AFLAG:
+	case ECS_IOCTL_APP_GET_TFLAG:
+	case ECS_IOCTL_APP_GET_MVFLAG:
+	case ECS_IOCTL_APP_GET_DELAY:
+		if (copy_to_user(argp, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int akmd_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int akmd_release(struct inode *inode, struct file *file)
+{
+	AKECS_CloseDone();
+	return 0;
+}
+
+static int
+akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	   unsigned long arg)
+{
+
+	void __user *argp = (void __user *)arg;
+
+	char msg[RBUFF_SIZE + 1], rwbuf[5];
+	int ret = -1, status;
+	short mode, value[12], delay;
+
+	switch (cmd) {
+	case ECS_IOCTL_WRITE:
+	case ECS_IOCTL_READ:
+		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		if (copy_from_user(&mode, argp, sizeof(mode)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		if (copy_from_user(&value, argp, sizeof(value)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_WRITE:
+		if (rwbuf[0] < 2)
+			return -EINVAL;
+		ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_READ:
+		if (rwbuf[0] < 1)
+			return -EINVAL;
+		ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		ret = AKECS_SetMode((char)mode);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_GETDATA:
+		ret = AKECS_TransRBuff(msg, RBUFF_SIZE);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		AKECS_Report_Value(value);
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+		status = AKECS_GetOpenStatus();
+		break;
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		status = AKECS_GetCloseStatus();
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		delay = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GETDATA:
+		if (copy_to_user(argp, &msg, sizeof(msg)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		if (copy_to_user(argp, &status, sizeof(status)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		if (copy_to_user(argp, &delay, sizeof(delay)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void akm_work_func(struct work_struct *work)
+{
+	if (AKECS_GetData() < 0)
+		printk(KERN_ERR "AKM8973 akm_work_func: Get data failed\n");
+	enable_irq(this_client->irq);
+}
+
+static irqreturn_t akm8973_interrupt(int irq, void *dev_id)
+{
+	struct akm8973_data *data = dev_id;
+	disable_irq(this_client->irq);
+	schedule_work(&data->work);
+	return IRQ_HANDLED;
+}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void akm8973_early_suspend(struct early_suspend *handler)
+{
+	atomic_set(&suspend_flag, 1);
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	disable_irq(this_client->irq);
+}
+
+static void akm8973_early_resume(struct early_suspend *handler)
+{
+	enable_irq(this_client->irq);
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+}
+#endif
+static struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = akmd_open,
+	.release = akmd_release,
+	.ioctl = akmd_ioctl,
+};
+
+static struct file_operations akm_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_aot_open,
+	.release = akm_aot_release,
+	.ioctl = akm_aot_ioctl,
+};
+
+
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8973_aot",
+	.fops = &akm_aot_fops,
+};
+
+
+static struct miscdevice akmd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8973_daemon",
+	.fops = &akmd_fops,
+};
+
+static ssize_t compass_reset_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	int val;
+
+	val = -1;
+	sscanf(buf, "%u", &val);
+	if (val != 1)
+		return -EINVAL;
+
+	return count;
+}
+
+static DEVICE_ATTR(reset, 0644, NULL, compass_reset_store);
+
+int akm8973_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct akm8973_data *akm;
+	int err = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	akm = kzalloc(sizeof(struct akm8973_data), GFP_KERNEL);
+	if (!akm) {
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	INIT_WORK(&akm->work, akm_work_func);
+	i2c_set_clientdata(client, akm);
+
+	this_client = client;
+
+	err = AKECS_PowerDown();
+	if (err < 0) {
+		printk(KERN_ERR"AKM8973 akm8973_probe: set power down mode error\n");
+		goto exit_set_mode_failed;
+	}
+
+	err = request_irq(client->irq, akm8973_interrupt, IRQF_TRIGGER_HIGH,
+			  "akm8973", akm);
+
+	if (err < 0) {
+		printk(KERN_ERR"AKM8973 akm8973_probe: request irq failed\n");
+		goto exit_irq_request_failed;
+	}
+
+	akm->input_dev = input_allocate_device();
+
+	if (!akm->input_dev) {
+		err = -ENOMEM;
+		printk(KERN_ERR
+		       "AKM8973 akm8973_probe: Failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	set_bit(EV_ABS, akm->input_dev->evbit);
+	/* yaw */
+	input_set_abs_params(akm->input_dev, ABS_RX, 0, 360, 0, 0);
+	/* pitch */
+	input_set_abs_params(akm->input_dev, ABS_RY, -180, 180, 0, 0);
+	/* roll */
+	input_set_abs_params(akm->input_dev, ABS_RZ, -90, 90, 0, 0);
+	/* x-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_X, -1872, 1872, 0, 0);
+	/* y-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Y, -1872, 1872, 0, 0);
+	/* z-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Z, -1872, 1872, 0, 0);
+	/* temparature */
+	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	/* status of magnetic sensor */
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
+	/* status of acceleration sensor */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
+	/* step count */
+	input_set_abs_params(akm->input_dev, ABS_GAS, 0, 65535, 0, 0);
+	/* x-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0X, -2048, 2032, 0, 0);
+	/* y-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -2048, 2032, 0, 0);
+	/* z-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_BRAKE, -2048, 2032, 0, 0);
+
+	akm->input_dev->name = "compass";
+
+	err = input_register_device(akm->input_dev);
+
+	if (err) {
+		printk(KERN_ERR
+		       "AKM8973 akm8973_probe: Unable to register input device: %s\n",
+		       akm->input_dev->name);
+		goto exit_input_register_device_failed;
+	}
+
+	err = misc_register(&akmd_device);
+	if (err) {
+		printk(KERN_ERR "AKM8973 akm8973_probe: akmd_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = misc_register(&akm_aot_device);
+	if (err) {
+		printk(KERN_ERR
+		       "AKM8973 akm8973_probe: akm_aot_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	mutex_init(&sense_data_mutex);
+
+	init_waitqueue_head(&data_ready_wq);
+	init_waitqueue_head(&open_wq);
+
+	/* As default, report all information */
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&t_flag, 1);
+	atomic_set(&mv_flag, 1);
+#ifdef CONFIG_HAS_EARLYSUSPEND  
+	akm->early_suspend_akm.suspend = akm8973_early_suspend;
+	akm->early_suspend_akm.resume = akm8973_early_resume;
+	register_early_suspend(&akm->early_suspend_akm);
+#endif
+	err = device_create_file(&client->dev, &dev_attr_reset);
+	if (err)
+		printk(KERN_ERR
+		"AKM8973 akm8973_probe: create dev_attr_reset failed\n");
+
+	return 0;
+
+exit_misc_device_register_failed:
+exit_input_register_device_failed:
+	input_free_device(akm->input_dev);
+exit_input_dev_alloc_failed:
+	free_irq(client->irq, akm);
+exit_irq_request_failed:
+exit_set_mode_failed:
+	kfree(akm);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+
+}
+
+static int akm8973_remove(struct i2c_client *client)
+{
+	struct akm8973_data *akm = i2c_get_clientdata(client);
+	free_irq(client->irq, akm);
+	input_unregister_device(akm->input_dev);
+	kfree(akm);
+	return 0;
+}
+static const struct i2c_device_id akm8973_id[] = {
+	{ AKM8973_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver akm8973_driver = {
+	.probe 	= akm8973_probe,
+	.remove 	= akm8973_remove,
+	.id_table	= akm8973_id,
+	.driver = {
+		   .name = AKM8973_I2C_NAME,
+		},
+};
+
+static int __init akm8973_init(void)
+{
+	printk(KERN_INFO "AKM8973 compass driver: init\n");
+	return i2c_add_driver(&akm8973_driver);
+}
+
+static void __exit akm8973_exit(void)
+{
+	i2c_del_driver(&akm8973_driver);
+}
+
+module_init(akm8973_init);
+module_exit(akm8973_exit);
+
+MODULE_AUTHOR("viral wang <viral_wang@htc.com>");
+MODULE_DESCRIPTION("AKM8973 compass driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/iio/magnetometer/ak8973.h b/drivers/staging/iio/magnetometer/ak8973.h
new file mode 100644
index 000000000000..350eba7dbe6c
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/ak8973.h
@@ -0,0 +1,53 @@
+/*
+ * Definitions for ak8973 compass chip.
+ */
+#ifndef AKM8973_H
+#define AKM8973_H
+
+#include <linux/ioctl.h>
+
+#define AKM8973_I2C_NAME "ak8973"
+
+/* Compass device dependent definition */
+#define AKECS_MODE_MEASURE	0x00	/* Starts measurement. Please use AKECS_MODE_MEASURE_SNG */
+					/* or AKECS_MODE_MEASURE_SEQ instead of this. */
+#define AKECS_MODE_E2P_READ	0x02	/* E2P access mode (read). */
+#define AKECS_MODE_POWERDOWN	0x03	/* Power down mode */
+
+#define RBUFF_SIZE		4	/* Rx buffer size */
+
+/* AK8973 register address */
+#define AKECS_REG_ST			0xC0
+#define AKECS_REG_TMPS			0xC1
+#define AKECS_REG_MS1			0xE0
+
+#define AKMIO				0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x01, char[5])
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x02, char[5])
+#define ECS_IOCTL_RESET      	          _IO(AKMIO, 0x03)
+#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x04, short)
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x05, char[RBUFF_SIZE+1])
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x06, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x07, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x08, int)
+#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
+
+/* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
+#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
+#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
+#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
+#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
+#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)
+#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)
+#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)
+#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
+#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
+#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)	/* Set raw magnetic vector flag */
+#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)	/* Get raw magnetic vector flag */
+
+
+#endif
+
diff --git a/drivers/staging/iio/magnetometer/ak8975.c b/drivers/staging/iio/magnetometer/ak8975.c
new file mode 100644
index 000000000000..644615243150
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/ak8975.c
@@ -0,0 +1,501 @@
+/*
+ * A sensor driver for the magnetometer AK8975. 
+ * 
+ * Magnetic compass sensor driver for monitoring magnetic flux information. 
+ * 
+ * Copyright (c) 2010, NVIDIA Corporation. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version. 
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+ * more details. 
+ * 
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. 
+ */ 
+ 
+#include <linux/module.h> 
+#include <linux/kernel.h> 
+#include <linux/slab.h> 
+#include <linux/i2c.h> 
+#include <linux/err.h> 
+#include <linux/mutex.h> 
+#include <linux/delay.h> 
+ 
+#include <linux/gpio.h> 
+ 
+#include "../iio.h" 
+#include "magnet.h" 
+ 
+/* 
+ * Register definitions, as well as various shifts and masks to get at the 
+ * individual fields of the registers. 
+ */ 
+#define AK8975_REG_WIA 0x00 
+#define AK8975_DEVICE_ID 0x48 
+ 
+#define AK8975_REG_INFO 0x01 
+ 
+#define AK8975_REG_ST1 0x02 
+#define AK8975_REG_ST1_DRDY_SHIFT 0 
+#define AK8975_REG_ST1_DRDY_MASK (1 << AK8975_REG_ST1_DRDY_SHIFT) 
+ 
+#define AK8975_REG_HXL 0x03 
+#define AK8975_REG_HXH 0x04 
+#define AK8975_REG_HYL 0x05 
+#define AK8975_REG_HYH 0x06 
+#define AK8975_REG_HZL 0x07 
+#define AK8975_REG_HZH 0x08 
+#define AK8975_REG_ST2 0x09 
+#define AK8975_REG_ST2_DERR_SHIFT 2 
+#define AK8975_REG_ST2_DERR_MASK (1 << AK8975_REG_ST2_DERR_SHIFT) 
+ 
+#define AK8975_REG_ST2_HOFL_SHIFT 3 
+#define AK8975_REG_ST2_HOFL_MASK (1 << AK8975_REG_ST2_HOFL_SHIFT) 
+ 
+#define AK8975_REG_CNTL 0x0A 
+#define AK8975_REG_CNTL_MODE_SHIFT 0 
+#define AK8975_REG_CNTL_MODE_MASK (0xF << AK8975_REG_CNTL_MODE_SHIFT) 
+#define AK8975_REG_CNTL_MODE_POWER_DOWN 0 
+#define AK8975_REG_CNTL_MODE_ONCE 1 
+#define AK8975_REG_CNTL_MODE_SELF_TEST 8 
+#define AK8975_REG_CNTL_MODE_FUSE_ROM 0xF 
+ 
+#define AK8975_REG_RSVC 0x0B 
+#define AK8975_REG_ASTC 0x0C 
+#define AK8975_REG_TS1 0x0D 
+#define AK8975_REG_TS2 0x0E 
+#define AK8975_REG_I2CDIS 0x0F 
+#define AK8975_REG_ASAX 0x10 
+#define AK8975_REG_ASAY 0x11 
+#define AK8975_REG_ASAZ 0x12 
+ 
+#define AK8975_MAX_REGS AK8975_REG_ASAZ 
+ 
+/* 
+ * Miscellaneous values. 
+ */ 
+#define AK8975_MAX_CONVERSION_TRIAL 5 
+#define AK8975_MAX_CONVERSION_TIMEOUT 500 
+#define AK8975_CONVERSION_DONE_POLL_TIME 10 
+ 
+/* 
+ * Per-instance context data for the device. 
+ */ 
+struct ak8975_data { 
+	struct i2c_client *client; 
+	struct iio_dev *indio_dev; 
+	struct attribute_group attrs; 
+	struct mutex lock; 
+	u8 asa[3]; 
+	unsigned long mode; 
+	u8 reg_cache[AK8975_MAX_REGS]; 
+	int eoc_gpio; 
+	int eoc_irq; 
+}; 
+ 
+/* 
+ * Helper function to write to the I2C device's registers. 
+ */ 
+static bool ak8975_write_data(struct i2c_client *client, 
+	u8 reg, u8 val, u8 mask, u8 shift) 
+{ 
+	u8 regval; 
+	struct i2c_msg msg; 
+	u8 w_data[2]; 
+	int ret = 0; 
+	
+	struct ak8975_data *data = i2c_get_clientdata(client); 
+	
+	regval = data->reg_cache[reg]; 
+	regval &= ~mask; 
+	regval |= val << shift; 
+	
+	w_data[0] = reg; 
+	w_data[1] = regval; 
+	
+	msg.addr = client->addr; 
+	msg.flags = 0; 
+	msg.len = 2; 
+	msg.buf = w_data; 
+	
+	ret = i2c_transfer(client->adapter, &msg, 1); 
+	if (ret < 0) { 
+		dev_err(&client->dev, "Write to device fails status %x\n", ret); 
+		return false; 
+	} 
+	data->reg_cache[reg] = regval; 
+	
+	return true; 
+} 
+ 
+/* 
+ * Helper function to read a contiguous set of the I2C device's registers. 
+ */ 
+static bool ak8975_read_data(struct i2c_client *client, 
+	u8 reg, u8 length, u8 *buffer) 
+{ 
+	struct i2c_msg msg[2]; 
+	u8 w_data[2]; 
+	int ret = 0; 
+	
+	w_data[0] = reg; 
+	
+	msg[0].addr = client->addr; 
+	msg[0].flags = I2C_M_NOSTART; /* set repeated start and write */ 
+	msg[0].len = 1; 
+	msg[0].buf = w_data; 
+	
+	msg[1].addr = client->addr; 
+	msg[1].flags = I2C_M_RD; 
+	msg[1].len = length; 
+	msg[1].buf = buffer; 
+	
+	ret = i2c_transfer(client->adapter, msg, 2); 
+	if (ret < 0) { 
+		dev_err(&client->dev, "Read from device fails\n"); 
+		return false; 
+	} 
+	
+	return true; 
+} 
+ 
+/* 
+ * Perform some start-of-day setup, including reading the asa calibration 
+ * values and caching them. 
+ */ 
+static int ak8975_setup(struct i2c_client *client) 
+{ 
+	struct ak8975_data *data = i2c_get_clientdata(client); 
+	u8 device_id; 
+	u8 buffer[3]; 
+	bool status; 
+	
+	/* Confirm that the device we're talking to is really an AK8975. */ 
+	status = ak8975_read_data(client, AK8975_REG_WIA, 1, &device_id); 
+	if ((!status) || (device_id != AK8975_DEVICE_ID)) { 
+		dev_err(&client->dev, "Device ak8975 not found\n"); 
+		return -ENODEV; 
+	} 
+	
+	/* Write the fused rom access mode. */ 
+	status = ak8975_write_data(client, AK8975_REG_CNTL, AK8975_REG_CNTL_MODE_FUSE_ROM, AK8975_REG_CNTL_MODE_MASK, AK8975_REG_CNTL_MODE_SHIFT); 
+	if (!status) { 
+		dev_err(&client->dev, "Error in setting fuse access mode\n"); 
+		return false; 
+	} 
+	
+	/* Get asa data and store in the device data. */ 
+	status = ak8975_read_data(client, AK8975_REG_ASAX, 3, buffer); 
+	if (!status) { 
+		dev_err(&client->dev, "Not able to read asa data\n"); 
+		return -ENODEV; 
+	} 
+	
+	data->asa[0] = buffer[0] & 0xFF; 
+	data->asa[1] = buffer[1] & 0xFF; 
+	data->asa[2] = buffer[2] & 0xFF; 
+	
+	return 0; 
+} 
+ 
+/* 
+ * Shows the device's mode. 0 = off, 1 = on. 
+ */ 
+static ssize_t show_mode(struct device *dev, struct device_attribute *devattr, 
+	char *buf) 
+{ 
+	struct iio_dev *indio_dev = dev_get_drvdata(dev); 
+	struct ak8975_data *data = indio_dev->dev_data; 
+	
+	return sprintf(buf, "%lu\n", data->mode); 
+} 
+ 
+/* 
+ * Sets the device's mode. 0 = off, 1 = on. The device's mode must be on 
+ * for the magn raw attributes to be available. 
+ */ 
+static ssize_t store_mode(struct device *dev, struct device_attribute *devattr, 
+	const char *buf, size_t count) 
+{ 
+	struct iio_dev *indio_dev = dev_get_drvdata(dev); 
+	struct ak8975_data *data = indio_dev->dev_data; 
+	struct i2c_client *client = data->client; 
+	unsigned long oval; 
+	bool status; 
+	
+	/* Convert mode string and do some basic sanity checking on it. 
+	only 0 or 1 are valid. */ 
+	if (strict_strtol(buf, 10, &oval)) 
+		return -EINVAL; 
+	
+	if ((oval < 0) || (oval > 1)) { 
+		dev_err(dev, "mode value is not supported\n"); 
+		return -EINVAL; 
+	} 
+	
+	mutex_lock(&data->lock); 
+	
+	/* Write the mode to the device. */ 
+	if (data->mode != oval) { 
+		status = ak8975_write_data(client, AK8975_REG_CNTL, (u8)oval, AK8975_REG_CNTL_MODE_MASK, AK8975_REG_CNTL_MODE_SHIFT); 	
+		if (!status) { 
+			dev_err(&client->dev, "Error in setting mode\n"); 
+			mutex_unlock(&data->lock); 
+			return -EINVAL; 
+		} 
+		data->mode = oval; 
+	} 
+	
+	mutex_unlock(&data->lock); 
+	
+	return count; 
+} 
+ 
+/* 
+ * Emits the ASA sensitivity adjustment value for the x, y, or z axis. 
+ * These ASA values are read from the sensor device at start of day, and 
+ * cached in the device context struct. 
+ */ 
+static ssize_t show_calibscale(struct device *dev, 
+	struct device_attribute *devattr, char *buf) 
+{ 
+	struct iio_dev *indio_dev = dev_get_drvdata(dev); 
+	struct ak8975_data *data = indio_dev->dev_data; 
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(devattr); 
+	
+	if (!data) { 
+		dev_err(dev, "No device found\n"); 
+		return -ENODEV; 
+	} 
+	
+	return sprintf(buf, "%d\n", data->asa[this_attr->address]); 
+} 
+ 
+/* 
+ * Emits the raw flux value for the x, y, or z axis. 
+ * 
+ * Adjusting the flux value with the sensitivity adjustment value should be 
+ * done via the following formula: 
+ * 
+ * Hadj = H * ( ( ( (ASA-128)*0.5 ) / 128 ) + 1 ) 
+ * 
+ * where H is the raw value, ASA is the sensitivity adjustment, and Hadj 
+ * is the resultant adjusted value. 
+ */ 
+static ssize_t show_raw(struct device *dev, struct device_attribute *devattr, 
+	char *buf) 
+{ 
+	struct iio_dev *indio_dev = dev_get_drvdata(dev); 
+	struct ak8975_data *data = indio_dev->dev_data; 
+	struct i2c_client *client = data->client; 
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(devattr); 
+	u32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT; 
+	u16 meas_reg; 
+	s16 raw; 
+	u8 read_status; 
+	bool status; 
+	int state; 
+	
+	/* Set up the device for taking a sample. */ 
+	status = ak8975_write_data(client, AK8975_REG_CNTL, AK8975_REG_CNTL_MODE_ONCE, AK8975_REG_CNTL_MODE_MASK, AK8975_REG_CNTL_MODE_SHIFT); 
+	if (!status) { 
+		dev_err(&client->dev, "Error in setting operating mode\n"); 
+		return false; 
+	} 
+	
+	/* Wait for the conversion to complete. */ 
+	while (timeout_ms) { 
+		msleep(AK8975_CONVERSION_DONE_POLL_TIME); 
+		state = (gpio_get_value(data->eoc_gpio) ? 1 : 0); 
+		if (state) 
+		break; 
+		timeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME; 
+	} 
+	if (!timeout_ms) { 
+		dev_err(&client->dev, "Conversion timeout happend\n"); 
+		return false; 
+	} 
+	
+	status = ak8975_read_data(client, AK8975_REG_ST1, 1, &read_status); 
+	if (!status) { 
+		dev_err(&client->dev, "Error in reading ST1\n"); 
+		return false; 
+	} 
+	
+	if (read_status & AK8975_REG_ST1_DRDY_MASK) { 
+		status = ak8975_read_data(client, AK8975_REG_ST2, 1, &read_status); 
+		if (!status) { 
+			dev_err(&client->dev, "Error in reading ST2\n"); 
+			return false; 
+		} 
+		if (read_status & (AK8975_REG_ST2_DERR_MASK | AK8975_REG_ST2_HOFL_MASK)) { 
+			dev_err(&client->dev, "ST2 status error 0x%x\n", 
+			read_status); 
+			return false; 
+		} 
+	} 
+	
+	/* Read the flux value from the appropriate register 
+	(the register is specified in the iio device attributes). */ 
+	status = ak8975_read_data(client, this_attr->address, 2, 
+	(u8 *)&meas_reg); 
+	if (!status) { 
+		dev_err(&client->dev, "Read axis data fails\n"); 
+		return false; 
+	} 
+	
+	/* Endian conversion of the measured values */ 
+	raw = (s16) (le16_to_cpu(meas_reg)); 
+	
+	return sprintf(buf, "%d\n", raw); 
+} 
+ 
+static IIO_DEVICE_ATTR(mode, S_IRUGO | S_IWUSR, show_mode, store_mode, 0); 
+static IIO_DEVICE_ATTR(magn_x_calibscale, S_IRUGO, show_calibscale, NULL, 0); 
+static IIO_DEVICE_ATTR(magn_y_calibscale, S_IRUGO, show_calibscale, NULL, 1); 
+static IIO_DEVICE_ATTR(magn_z_calibscale, S_IRUGO, show_calibscale, NULL, 2); 
+static IIO_DEV_ATTR_MAGN_X(show_raw, AK8975_REG_HXL); 
+static IIO_DEV_ATTR_MAGN_Y(show_raw, AK8975_REG_HYL); 
+static IIO_DEV_ATTR_MAGN_Z(show_raw, AK8975_REG_HZL); 
+ 
+static struct attribute *ak8975_attr[] = { 
+	&iio_dev_attr_mode.dev_attr.attr, 
+	&iio_dev_attr_magn_x_calibscale.dev_attr.attr, 
+	&iio_dev_attr_magn_y_calibscale.dev_attr.attr, 
+	&iio_dev_attr_magn_z_calibscale.dev_attr.attr, 
+	&iio_dev_attr_magn_x_raw.dev_attr.attr, 
+	&iio_dev_attr_magn_y_raw.dev_attr.attr, 
+	&iio_dev_attr_magn_z_raw.dev_attr.attr, 
+	NULL 
+}; 
+ 
+static struct attribute_group ak8975_attr_group = { 
+	.attrs = ak8975_attr, 
+}; 
+ 
+static int ak8975_probe(struct i2c_client *client, 
+	const struct i2c_device_id *id) 
+{ 
+	struct ak8975_data *data; 
+	int err; 
+	
+	/* Allocate our device context. */ 
+	data = kzalloc(sizeof(struct ak8975_data), GFP_KERNEL); 
+	if (!data) { 
+		dev_err(&client->dev, "Memory allocation fails\n"); 
+		err = -ENOMEM; 
+		goto exit; 
+	} 
+	
+	i2c_set_clientdata(client, data); 
+	data->client = client; 
+	
+	mutex_init(&data->lock); 
+	
+	/* Grab and set up the supplied GPIO. */ 
+	data->eoc_irq = client->irq; 
+	data->eoc_gpio = irq_to_gpio(client->irq); 
+	
+	err = gpio_request(data->eoc_gpio, "ak_8975"); 
+	if (err < 0) { 
+		dev_err(&client->dev, "failed to request GPIO %d, error %d\n", 
+		data->eoc_gpio, err); 
+		goto exit_free; 
+	} 
+	
+	err = gpio_direction_input(data->eoc_gpio); 
+	if (err < 0) { 
+		dev_err(&client->dev, "Failed to configure input direction for GPIO %d, error %d\n", data->eoc_gpio, err); 
+		gpio_free(data->eoc_gpio); 
+		goto exit_gpio; 
+	} 
+	
+	/* Perform some basic start-of-day setup of the device. */ 
+	err = ak8975_setup(client); 
+	if (err < 0) { 
+		dev_err(&client->dev, "AK8975 initialization fails\n"); 
+		goto exit_gpio; 
+	} 
+	
+	/* Register with IIO */ 
+	data->indio_dev = iio_allocate_device(); 
+	if (data->indio_dev == NULL) { 
+		err = -ENOMEM; 
+		goto exit_gpio; 
+	} 
+	
+	data->indio_dev->dev.parent = &client->dev; 
+	data->indio_dev->attrs = &ak8975_attr_group; 
+	data->indio_dev->dev_data = (void *)(data); 
+	data->indio_dev->driver_module = THIS_MODULE; 
+	data->indio_dev->modes = INDIO_DIRECT_MODE; 
+	
+	err = iio_device_register(data->indio_dev); 
+	if (err < 0) 
+		goto exit_free_iio; 
+	
+	return 0; 
+	
+exit_free_iio: 
+	iio_free_device(data->indio_dev); 
+exit_gpio: 
+	gpio_free(data->eoc_gpio); 
+exit_free: 
+	kfree(data); 
+exit: 
+	return err; 
+} 
+ 
+static int ak8975_remove(struct i2c_client *client) 
+{ 
+	struct ak8975_data *data = i2c_get_clientdata(client); 
+	
+	iio_device_unregister(data->indio_dev); 
+	iio_free_device(data->indio_dev); 
+	
+	gpio_free(data->eoc_gpio); 
+	
+	kfree(data); 
+	
+	return 0; 
+} 
+ 
+static const struct i2c_device_id ak8975_id[] = { 
+	{"ak8975", 0}, 
+	{} 
+}; 
+ 
+MODULE_DEVICE_TABLE(i2c, ak8975_id); 
+ 
+static struct i2c_driver ak8975_driver = { 
+	.driver = { 
+	.name = "ak8975", 
+		}, 
+	.probe = ak8975_probe, 
+	.remove = __devexit_p(ak8975_remove), 
+	.id_table = ak8975_id, 
+}; 
+ 
+static int __init ak8975_init(void) 
+{ 
+	return i2c_add_driver(&ak8975_driver); 
+} 
+ 
+static void __exit ak8975_exit(void) 
+{ 
+	i2c_del_driver(&ak8975_driver); 
+} 
+ 
+module_init(ak8975_init); 
+module_exit(ak8975_exit); 
+ 
+MODULE_AUTHOR("Laxman Dewangan <ldewangan [at] nvidia>"); 
+MODULE_DESCRIPTION("AK8975 magnetometer driver"); 
+MODULE_LICENSE("GPL"); 
diff --git a/drivers/staging/iio/magnetometer/magnet.h b/drivers/staging/iio/magnetometer/magnet.h
new file mode 100644
index 000000000000..64338301f8df
--- /dev/null
+++ b/drivers/staging/iio/magnetometer/magnet.h
@@ -0,0 +1,31 @@
+
+#include "../sysfs.h"
+
+/* Magnetometer types of attribute */
+
+#define IIO_DEV_ATTR_MAGN_X_OFFSET(_mode, _show, _store, _addr)	\
+	IIO_DEVICE_ATTR(magn_x_offset, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Y_OFFSET(_mode, _show, _store, _addr)	\
+	IIO_DEVICE_ATTR(magn_y_offset, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Z_OFFSET(_mode, _show, _store, _addr)	\
+	IIO_DEVICE_ATTR(magn_z_offset, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_X_GAIN(_mode, _show, _store, _addr)		\
+	IIO_DEVICE_ATTR(magn_x_gain, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Y_GAIN(_mode, _show, _store, _addr)		\
+	IIO_DEVICE_ATTR(magn_y_gain, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Z_GAIN(_mode, _show, _store, _addr)		\
+	IIO_DEVICE_ATTR(magn_z_gain, _mode, _show, _store, _addr)
+
+#define IIO_DEV_ATTR_MAGN_X(_show, _addr)				\
+	IIO_DEVICE_ATTR(magn_x_raw, S_IRUGO, _show, NULL, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Y(_show, _addr)				\
+	IIO_DEVICE_ATTR(magn_y_raw, S_IRUGO, _show, NULL, _addr)
+
+#define IIO_DEV_ATTR_MAGN_Z(_show, _addr)				\
+	IIO_DEVICE_ATTR(magn_z_raw, S_IRUGO, _show, NULL, _addr)
-- 
2.35.3

