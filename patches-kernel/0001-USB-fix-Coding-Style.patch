From a8dda01fcd38be48f290088083d8f983c4abf4b2 Mon Sep 17 00:00:00 2001
From: wlf <wulf@rock-chips.com>
Date: Thu, 22 May 2014 11:30:11 +0800
Subject: [PATCH] USB: fix Coding Style.

---
 drivers/usb/dwc_otg_310/Makefile              |    8 +-
 drivers/usb/dwc_otg_310/Makefile-original     |    8 +-
 drivers/usb/dwc_otg_310/common_port/dwc_cc.c  |   28 +-
 drivers/usb/dwc_otg_310/common_port/dwc_cc.h  |   23 +-
 .../common_port/dwc_common_linux.c            |   87 +-
 .../usb/dwc_otg_310/common_port/dwc_crypto.c  |    4 +-
 drivers/usb/dwc_otg_310/common_port/dwc_dh.c  |   37 +-
 .../usb/dwc_otg_310/common_port/dwc_list.h    |  123 +-
 drivers/usb/dwc_otg_310/common_port/dwc_mem.c |    2 +-
 .../usb/dwc_otg_310/common_port/dwc_modpow.c  |  674 +++----
 .../usb/dwc_otg_310/common_port/dwc_modpow.h  |    2 +-
 .../dwc_otg_310/common_port/dwc_notifier.c    |    4 +-
 drivers/usb/dwc_otg_310/common_port/dwc_os.h  |  169 +-
 drivers/usb/dwc_otg_310/common_port/usb.h     |   24 +-
 drivers/usb/dwc_otg_310/dummy_audio.c         | 1066 ++++++-----
 drivers/usb/dwc_otg_310/dwc_cfi_common.h      |   26 +-
 drivers/usb/dwc_otg_310/dwc_otg_adp.c         |  290 +--
 drivers/usb/dwc_otg_310/dwc_otg_adp.h         |   26 +-
 drivers/usb/dwc_otg_310/dwc_otg_attr.c        |  262 ++-
 drivers/usb/dwc_otg_310/dwc_otg_attr.h        |   11 +-
 drivers/usb/dwc_otg_310/dwc_otg_cfi.c         |  303 ++--
 drivers/usb/dwc_otg_310/dwc_otg_cfi.h         |   36 +-
 drivers/usb/dwc_otg_310/dwc_otg_cil.c         | 1607 +++++++++--------
 drivers/usb/dwc_otg_310/dwc_otg_cil.h         |  290 +--
 drivers/usb/dwc_otg_310/dwc_otg_cil_intr.c    |  436 +++--
 drivers/usb/dwc_otg_310/dwc_otg_core_if.h     |  307 ++--
 drivers/usb/dwc_otg_310/dwc_otg_dbg.h         |   16 +-
 drivers/usb/dwc_otg_310/dwc_otg_driver.c      |  792 ++++----
 drivers/usb/dwc_otg_310/dwc_otg_driver.h      |    8 +-
 drivers/usb/dwc_otg_310/dwc_otg_hcd.c         |  486 ++---
 drivers/usb/dwc_otg_310/dwc_otg_hcd.h         |  114 +-
 drivers/usb/dwc_otg_310/dwc_otg_hcd_ddma.c    |  347 ++--
 drivers/usb/dwc_otg_310/dwc_otg_hcd_if.h      |   90 +-
 drivers/usb/dwc_otg_310/dwc_otg_hcd_intr.c    |  381 ++--
 drivers/usb/dwc_otg_310/dwc_otg_hcd_linux.c   |  407 +++--
 drivers/usb/dwc_otg_310/dwc_otg_hcd_queue.c   |   99 +-
 drivers/usb/dwc_otg_310/dwc_otg_os_dep.h      |   18 +-
 drivers/usb/dwc_otg_310/dwc_otg_pcd.c         |  487 ++---
 drivers/usb/dwc_otg_310/dwc_otg_pcd.h         |   25 +-
 drivers/usb/dwc_otg_310/dwc_otg_pcd_if.h      |  104 +-
 drivers/usb/dwc_otg_310/dwc_otg_pcd_intr.c    | 1574 ++++++++++------
 drivers/usb/dwc_otg_310/dwc_otg_pcd_linux.c   |  397 ++--
 drivers/usb/dwc_otg_310/dwc_otg_regs.h        |   63 +-
 drivers/usb/dwc_otg_310/usbdev_bc.c           |  331 ++--
 drivers/usb/dwc_otg_310/usbdev_bc.h           |   32 +-
 drivers/usb/dwc_otg_310/usbdev_grf_regs.h     |  183 +-
 drivers/usb/dwc_otg_310/usbdev_rk.h           |   60 +-
 drivers/usb/dwc_otg_310/usbdev_rk30.c         |  349 ++--
 .../usb/dwc_otg_310/usbdev_rk3190_grf_regs.h  |  147 +-
 drivers/usb/dwc_otg_310/usbdev_rk32.c         |  721 ++++----
 drivers/usb/dwc_otg_310/usbdev_rkuoc.h        |   49 +-
 drivers/usb/gadget/f_hid_rk.c                 | 1011 ++++++-----
 drivers/usb/gadget/f_mass_storage.c           | 1090 ++++++-----
 drivers/usb/gadget/storage_common.c           |    6 +-
 drivers/usb/host/ehci-rkhsic.c                |  234 +--
 drivers/usb/host/ehci-rockchip.c              |  265 +--
 drivers/usb/host/ohci-rockchip.c              |  115 +-
 57 files changed, 8392 insertions(+), 7462 deletions(-)

diff --git a/drivers/usb/dwc_otg_310/Makefile b/drivers/usb/dwc_otg_310/Makefile
index 2572229065fa..9af238ce165b 100755
--- a/drivers/usb/dwc_otg_310/Makefile
+++ b/drivers/usb/dwc_otg_310/Makefile
@@ -14,9 +14,9 @@ EXTRA_CFLAGS	+= $(BUS_INTERFACE)
 #EXTRA_CFLAGS	+= -DDWC_DEV_SRPCAP
 
 
-dwc_otg-objs	:= dwc_otg_driver.o dwc_otg_attr.o 
-dwc_otg-objs	+= dwc_otg_cil.o dwc_otg_cil_intr.o 
-dwc_otg-objs	+= dwc_otg_pcd_linux.o dwc_otg_pcd.o dwc_otg_pcd_intr.o 
+dwc_otg-objs	:= dwc_otg_driver.o dwc_otg_attr.o
+dwc_otg-objs	+= dwc_otg_cil.o dwc_otg_cil_intr.o
+dwc_otg-objs	+= dwc_otg_pcd_linux.o dwc_otg_pcd.o dwc_otg_pcd_intr.o
 dwc_otg-objs	+= dwc_otg_hcd.o dwc_otg_hcd_linux.o dwc_otg_hcd_intr.o dwc_otg_hcd_queue.o dwc_otg_hcd_ddma.o
 dwc_otg-objs	+= dwc_otg_adp.o
 ifneq ($(CFI),)
@@ -24,6 +24,6 @@ dwc_otg-objs	+= dwc_otg_cfi.o
 endif
 dwc_otg-objs	+= common_port/dwc_common_linux.o
 
-#objs relative to RK platform 
+#objs relative to RK platform
 dwc_otg-objs 	+= usbdev_rk30.o usbdev_rk32.o usbdev_bc.o
 obj-$(CONFIG_DWC_OTG_310) := dwc_otg.o
diff --git a/drivers/usb/dwc_otg_310/Makefile-original b/drivers/usb/dwc_otg_310/Makefile-original
index 9695a22fca93..d53ffb19a8ad 100755
--- a/drivers/usb/dwc_otg_310/Makefile-original
+++ b/drivers/usb/dwc_otg_310/Makefile-original
@@ -3,7 +3,7 @@
 #
 
 ifneq ($(KERNELRELEASE),)
-CPPFLAGS	+= -DDEBUG 
+CPPFLAGS	+= -DDEBUG
 
 # Use one of the following flags to compile the software in host-only or
 # device-only mode.
@@ -14,9 +14,9 @@ CPPFLAGS	+= -Dlinux -DDWC_HS_ELECT_TST
 
 obj-m	:= dwc_otg.o
 
-dwc_otg-objs	:= dwc_otg_driver.o dwc_otg_attr.o 
-dwc_otg-objs	+= dwc_otg_cil.o dwc_otg_cil_intr.o 
-dwc_otg-objs	+= dwc_otg_pcd.o dwc_otg_pcd_intr.o 
+dwc_otg-objs	:= dwc_otg_driver.o dwc_otg_attr.o
+dwc_otg-objs	+= dwc_otg_cil.o dwc_otg_cil_intr.o
+dwc_otg-objs	+= dwc_otg_pcd.o dwc_otg_pcd_intr.o
 dwc_otg-objs	+= dwc_otg_hcd.o dwc_otg_hcd_intr.o dwc_otg_hcd_queue.o
 
 else
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_cc.c b/drivers/usb/dwc_otg_310/common_port/dwc_cc.c
index 0d1062ab067a..fc950b8979f6 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_cc.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_cc.c
@@ -37,22 +37,20 @@ _otg_/* ========================================================================
 
 #include "dwc_cc.h"
 
-typedef struct dwc_cc
-{
+typedef struct dwc_cc {
 	uint32_t uid;
 	uint8_t chid[16];
 	uint8_t cdid[16];
 	uint8_t ck[16];
 	uint8_t *name;
 	uint8_t length;
-        DWC_CIRCLEQ_ENTRY(dwc_cc) list_entry;
+	DWC_CIRCLEQ_ENTRY(dwc_cc) list_entry;
 } dwc_cc_t;
 
 DWC_CIRCLEQ_HEAD(context_list, dwc_cc);
 
 /** The main structure for CC management.  */
-struct dwc_cc_if
-{
+struct dwc_cc_if {
 	dwc_mutex_t *mutex;
 	char *filename;
 
@@ -68,7 +66,7 @@ static inline void dump_bytes(char *name, uint8_t *bytes, int len)
 {
 	int i;
 	DWC_PRINTF("%s: ", name);
-	for (i=0; i<len; i++) {
+	for (i = 0; i < len; i++) {
 		DWC_PRINTF("%02x ", bytes[i]);
 	}
 	DWC_PRINTF("\n");
@@ -184,16 +182,14 @@ static int32_t cc_add(void *mem_ctx, dwc_cc_if_t *cc_if, uint8_t *chid,
 
 	if (cc_if->is_host) {
 		uid = cc_match_cdid(cc_if, cdid);
-	}
-	else {
+	} else {
 		uid = cc_match_chid(cc_if, chid);
 	}
 
 	if (uid) {
 		DWC_DEBUG("Replacing previous connection context id=%d name=%p name_len=%d", uid, name, length);
 		cc = cc_find(cc_if, uid);
-	}
-	else {
+	} else {
 		cc = alloc_cc(mem_ctx, name, length);
 		cc->uid = next_uid(cc_if);
 		DWC_CIRCLEQ_INSERT_TAIL(&cc_if->list, cc, list_entry);
@@ -220,7 +216,7 @@ static void cc_clear(void *mem_ctx, dwc_cc_if_t *cc_if)
 	}
 }
 
-dwc_cc_if_t *dwc_cc_if_alloc(void *mem_ctx, void *mtx_ctx, 
+dwc_cc_if_t *dwc_cc_if_alloc(void *mem_ctx, void *mtx_ctx,
 			     dwc_notifier_t *notifier, unsigned is_host)
 {
 	dwc_cc_if_t *cc_if = NULL;
@@ -289,7 +285,7 @@ int32_t dwc_cc_add(void *mem_ctx, dwc_cc_if_t *cc_if, uint8_t *chid,
 void dwc_cc_change(void *mem_ctx, dwc_cc_if_t *cc_if, int32_t id, uint8_t *chid,
 		   uint8_t *cdid, uint8_t *ck, uint8_t *name, uint8_t length)
 {
-	dwc_cc_t* cc;
+	dwc_cc_t *cc;
 
 	DWC_DEBUG("Change connection context %d", id);
 
@@ -391,8 +387,7 @@ uint8_t *dwc_cc_data_for_save(void *mem_ctx, dwc_cc_if_t *cc_if, unsigned int *l
 			x += 1;
 			DWC_MEMCPY(x, cc->name, cc->length);
 			x += cc->length;
-		}
-		else {
+		} else {
 			DWC_MEMCPY(x, &zero, 1);
 			x += 1;
 		}
@@ -423,13 +418,12 @@ void dwc_cc_restore_from_data(void *mem_ctx, dwc_cc_if_t *cc_if, uint8_t *data,
 		i += 16;
 
 		name_length = data[i];
-		i ++;
+		i++;
 
 		if (name_length) {
 			name = &data[i];
 			i += name_length;
-		}
-		else {
+		} else {
 			name = NULL;
 		}
 
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_cc.h b/drivers/usb/dwc_otg_310/common_port/dwc_cc.h
index 6b2bbaff446f..3ed868d761f4 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_cc.h
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_cc.h
@@ -184,33 +184,36 @@ extern uint8_t *dwc_cc_cdid(dwc_cc_if_t *cc_if, int32_t id);
 extern uint8_t *dwc_cc_name(dwc_cc_if_t *cc_if, int32_t id, uint8_t *length);
 
 /** Checks a buffer for non-zero.
- * @param id A pointer to a 16 byte buffer. 
+ * @param id A pointer to a 16 byte buffer.
  * @return true if the 16 byte value is non-zero. */
-static inline unsigned dwc_assoc_is_not_zero_id(uint8_t *id) {
+static inline unsigned dwc_assoc_is_not_zero_id(uint8_t *id)
+{
 	int i;
-	for (i=0; i<16; i++) {
-		if (id[i]) return 1;
+	for (i = 0; i < 16; i++) {
+		if (id[i])
+			return 1;
 	}
 	return 0;
 }
 
 /** Checks a buffer for zero.
- * @param id A pointer to a 16 byte buffer. 
+ * @param id A pointer to a 16 byte buffer.
  * @return true if the 16 byte value is zero. */
-static inline unsigned dwc_assoc_is_zero_id(uint8_t *id) {
+static inline unsigned dwc_assoc_is_zero_id(uint8_t *id)
+{
 	return !dwc_assoc_is_not_zero_id(id);
 }
 
 /** Prints an ASCII representation for the 16-byte chid, cdid, or ck, into
  * buffer. */
-static inline int dwc_print_id_string(char *buffer, uint8_t *id) {
+static inline int dwc_print_id_string(char *buffer, uint8_t *id)
+{
 	char *ptr = buffer;
 	int i;
-	for (i=0; i<16; i++) {
+	for (i = 0; i < 16; i++) {
 		ptr += DWC_SPRINTF(ptr, "%02x", id[i]);
-		if (i < 15) {
+		if (i < 15)
 			ptr += DWC_SPRINTF(ptr, " ");
-		}
 	}
 	return ptr - buffer;
 }
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_common_linux.c b/drivers/usb/dwc_otg_310/common_port/dwc_common_linux.c
index 6368e146a8f6..b9da543e8004 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_common_linux.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_common_linux.c
@@ -42,7 +42,7 @@
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 # include <linux/usb/gadget.h>
 #else
 # include <linux/usb_gadget.h>
@@ -154,8 +154,8 @@ int DWC_UTF8_TO_UTF16LE(uint8_t const *s, uint16_t *cp, unsigned len)
 	 */
 	while (len != 0 && (c = (u8) *s++) != 0) {
 		if (unlikely(c & 0x80)) {
-			// 2-byte sequence:
-			// 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
+			/* 2-byte sequence: */
+			/* 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx */
 			if ((c & 0xe0) == 0xc0) {
 				uchar = (c & 0x1f) << 6;
 
@@ -165,8 +165,8 @@ int DWC_UTF8_TO_UTF16LE(uint8_t const *s, uint16_t *cp, unsigned len)
 				c &= 0x3f;
 				uchar |= c;
 
-			// 3-byte sequence (most CJKV characters):
-			// zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
+			/* 3-byte sequence (most CJKV characters): */
+			/* zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx */
 			} else if ((c & 0xf0) == 0xe0) {
 				uchar = (c & 0x0f) << 12;
 
@@ -186,11 +186,11 @@ int DWC_UTF8_TO_UTF16LE(uint8_t const *s, uint16_t *cp, unsigned len)
 				if (0xd800 <= uchar && uchar <= 0xdfff)
 					goto fail;
 
-			// 4-byte sequence (surrogate pairs, currently rare):
-			// 11101110wwwwzzzzyy + 110111yyyyxxxxxx
-			//     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
-			// (uuuuu = wwww + 1)
-			// FIXME accept the surrogate code points (only)
+			/* 4-byte sequence (surrogate pairs, currently rare): */
+			/* 11101110wwwwzzzzyy + 110111yyyyxxxxxx */
+			/*     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */
+			/* (uuuuu = wwww + 1) */
+			/*  FIXME accept the surrogate code points (only) */
 			} else
 				goto fail;
 		} else
@@ -345,7 +345,7 @@ void DWC_DMA_POOL_FREE(dwc_pool_t *pool, void *vaddr, void *daddr)
 
 void *__DWC_DMA_ALLOC(void *dma_ctx, uint32_t size, dwc_dma_t *dma_addr)
 {
-#if 1 //def xxCOSIM /* Only works for 32-bit cosim */
+#if 1 /* def xxCOSIM  Only works for 32-bit cosim */
 	void *buf = dma_alloc_coherent(dma_ctx, (size_t)size, dma_addr, GFP_KERNEL);
 #else
 	void *buf = dma_alloc_coherent(dma_ctx, (size_t)size, dma_addr, GFP_KERNEL | GFP_DMA32);
@@ -483,8 +483,10 @@ uint32_t DWC_CPU_TO_LE32(uint32_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
+	uint32_t ret;
+	ret = u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24);
 
-	return (u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24));
+	return ret;
 #endif
 }
 
@@ -494,8 +496,10 @@ uint32_t DWC_CPU_TO_BE32(uint32_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
+	uint32_t ret;
+	ret = u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24);
 
-	return (u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24));
+	return ret;
 #endif
 }
 
@@ -505,8 +509,10 @@ uint32_t DWC_LE32_TO_CPU(uint32_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
+	uint32_t ret;
+	ret = u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24);
 
-	return (u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24));
+	return ret;
 #endif
 }
 
@@ -516,8 +522,10 @@ uint32_t DWC_BE32_TO_CPU(uint32_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
+	uint32_t ret;
+	ret = u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24);
 
-	return (u_p[3] | (u_p[2] << 8) | (u_p[1] << 16) | (u_p[0] << 24));
+	return ret;
 #endif
 }
 
@@ -527,7 +535,9 @@ uint16_t DWC_CPU_TO_LE16(uint16_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
-	return (u_p[1] | (u_p[0] << 8));
+	uint16_t ret;
+	ret = u_p[1] | (u_p[0] << 8);
+	return ret;
 #endif
 }
 
@@ -537,7 +547,9 @@ uint16_t DWC_CPU_TO_BE16(uint16_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
-	return (u_p[1] | (u_p[0] << 8));
+	uint16_t ret;
+	ret = u_p[1] | (u_p[0] << 8);
+	return ret;
 #endif
 }
 
@@ -547,7 +559,9 @@ uint16_t DWC_LE16_TO_CPU(uint16_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
-	return (u_p[1] | (u_p[0] << 8));
+	uint16_t ret;
+	ret = u_p[1] | (u_p[0] << 8);
+	return ret;
 #endif
 }
 
@@ -557,44 +571,46 @@ uint16_t DWC_BE16_TO_CPU(uint16_t *p)
 	return *p;
 #else
 	uint8_t *u_p = (uint8_t *)p;
-	return (u_p[1] | (u_p[0] << 8));
+	uint16_t ret;
+	ret = u_p[1] | (u_p[0] << 8);
+	return ret;
 #endif
 }
 
 
 /* Registers */
 
-uint32_t DWC_READ_REG32(uint32_t volatile *reg)
+uint32_t DWC_READ_REG32(volatile uint32_t *reg)
 {
 	return readl_relaxed(reg);
 }
 
 #if 0
-uint64_t DWC_READ_REG64(uint64_t volatile *reg)
+uint64_t DWC_READ_REG64(volatile uint64_t *reg)
 {
 }
 #endif
 
-void DWC_WRITE_REG32(uint32_t volatile *reg, uint32_t value)
+void DWC_WRITE_REG32(volatile uint32_t *reg, uint32_t value)
 {
 	writel_relaxed(value, reg);
 	dsb();
 }
 
 #if 0
-void DWC_WRITE_REG64(uint64_t volatile *reg, uint64_t value)
+void DWC_WRITE_REG64(volatile uint64_t *reg, uint64_t value)
 {
 }
 #endif
 
-void DWC_MODIFY_REG32(uint32_t volatile *reg, uint32_t clear_mask, uint32_t set_mask)
+void DWC_MODIFY_REG32(volatile uint32_t *reg, uint32_t clear_mask, uint32_t set_mask)
 {
 	writel_relaxed((readl_relaxed(reg) & ~clear_mask) | set_mask, reg);
 	dsb();
 }
 
 #if 0
-void DWC_MODIFY_REG64(uint64_t volatile *reg, uint64_t clear_mask, uint64_t set_mask)
+void DWC_MODIFY_REG64(volatile uint64_t *reg, uint64_t clear_mask, uint64_t set_mask)
 {
 }
 #endif
@@ -745,7 +761,7 @@ static void timer_callback(unsigned long data)
 	DWC_SPINLOCK_IRQSAVE(timer->lock, &flags);
 	timer->scheduled = 0;
 	DWC_SPINUNLOCK_IRQRESTORE(timer->lock, flags);
-	//DWC_DEBUG("Timer %s callback", timer->name);
+	/* DWC_DEBUG("Timer %s callback", timer->name); */
 	timer->cb(timer->data);
 }
 
@@ -821,11 +837,13 @@ void DWC_TIMER_SCHEDULE(dwc_timer_t *timer, uint32_t time)
 
 	if (!timer->scheduled) {
 		timer->scheduled = 1;
-		//DWC_DEBUG("Scheduling timer %s to expire in +%d msec", timer->name, time);
+		/* DWC_DEBUG("Scheduling timer %s to expire in +%d msec",
+		 * 	     timer->name, time);*/
 		timer->t->expires = jiffies + msecs_to_jiffies(time);
 		add_timer(timer->t);
 	} else {
-		//DWC_DEBUG("Modifying timer %s to expire in +%d msec", timer->name, time);
+		/* DWC_DEBUG("Modifying timer %s to expire in +%d msec",
+		 * 	     timer->name, time);*/
 		mod_timer(timer->t, jiffies + msecs_to_jiffies(time));
 	}
 
@@ -1044,7 +1062,8 @@ static void do_work(struct work_struct *work)
 #ifdef DEBUG
 	DWC_CIRCLEQ_REMOVE(&wq->entries, container, entry);
 #endif
-	//DWC_DEBUG("Work done: %s, container=%p", container->name, container);
+	/* DWC_DEBUG("Work done: %s, container=%p",
+	 * 	     container->name, container); */
 	if (container->name) {
 		DWC_FREE(container->name);
 	}
@@ -1157,7 +1176,8 @@ void DWC_WORKQ_SCHEDULE(dwc_workq_t *wq, dwc_work_callback_t cb, void *data,
 	container->cb = cb;
 	container->data = data;
 	container->wq = wq;
-	//DWC_DEBUG("Queueing work: %s, container=%p", container->name, container);
+	/* DWC_DEBUG("Queueing work: %s, container=%p",
+	 * 	     container->name, container);*/
 	INIT_WORK(&container->work.work, do_work);
 
 #ifdef DEBUG
@@ -1199,7 +1219,8 @@ void DWC_WORKQ_SCHEDULE_DELAYED(dwc_workq_t *wq, dwc_work_callback_t cb,
 	container->cb = cb;
 	container->data = data;
 	container->wq = wq;
-	//DWC_DEBUG("Queueing work: %s, container=%p", container->name, container);
+	/* DWC_DEBUG("Queueing work: %s, container=%p",
+	 * 	     container->name, container);*/
 	INIT_DELAYED_WORK(&container->work, do_work);
 
 #ifdef DEBUG
@@ -1384,7 +1405,7 @@ static int dwc_common_port_init_module(void)
 {
 	int result = 0;
 
-	printk(KERN_DEBUG "Module dwc_common_port init\n" );
+	printk(KERN_DEBUG "Module dwc_common_port init\n");
 
 #ifdef DWC_DEBUG_MEMORY
 	result = dwc_memory_debug_start(NULL);
@@ -1410,7 +1431,7 @@ static int dwc_common_port_init_module(void)
 
 static void dwc_common_port_exit_module(void)
 {
-	printk(KERN_DEBUG "Module dwc_common_port exit\n" );
+	printk(KERN_DEBUG "Module dwc_common_port exit\n");
 
 #ifdef DWC_NOTIFYLIB
 	dwc_free_notification_manager();
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_crypto.c b/drivers/usb/dwc_otg_310/common_port/dwc_crypto.c
index 3b0353296148..240e6d919ed0 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_crypto.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_crypto.c
@@ -48,7 +48,7 @@ static inline void dump_bytes(char *name, uint8_t *bytes, int len)
 {
 	int i;
 	DWC_PRINTF("%s: ", name);
-	for (i=0; i<len; i++) {
+	for (i = 0; i < len; i++) {
 		DWC_PRINTF("%02x ", bytes[i]);
 	}
 	DWC_PRINTF("\n");
@@ -113,7 +113,7 @@ void dwc_wusb_cmf(u8 *key, u8 *nonce,
 	u16 la = (u16)(len + 14);
 
 	/* Set the AES-128 key */
-	//dwc_aes_setkey(tfm, key, 16);
+	/* dwc_aes_setkey(tfm, key, 16); */
 
 	/* Fill block B0 from flags = 0x59, N, and l(m) = 0 */
 	block_m[0] = 0x59;
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_dh.c b/drivers/usb/dwc_otg_310/common_port/dwc_dh.c
index 997f753edf22..800ff85647a3 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_dh.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_dh.c
@@ -48,16 +48,18 @@ static void dh_dump(char *str, void *_num, int len)
 	uint8_t *num = _num;
 	int i;
 	DWC_PRINTF("%s\n", str);
-	for (i = 0; i < len; i ++) {
+	for (i = 0; i < len; i++) {
 		DWC_PRINTF("%02x", num[i]);
-		if (((i + 1) % 2) == 0) DWC_PRINTF(" ");
-		if (((i + 1) % 26) == 0) DWC_PRINTF("\n");
+		if (((i + 1) % 2) == 0)
+			DWC_PRINTF(" ");
+		if (((i + 1) % 26) == 0)
+			DWC_PRINTF("\n");
 	}
 
 	DWC_PRINTF("\n");
 }
 #else
-#define dh_dump(_x...) do {; } while(0)
+#define dh_dump(_x...) do {; } while (0)
 #endif
 
 /* Constant g value */
@@ -86,7 +88,7 @@ static void dh_swap_bytes(void *_in, void *_out, uint32_t len)
 	uint8_t *in = _in;
 	uint8_t *out = _out;
 	int i;
-	for (i=0; i<len; i++) {
+	for (i = 0; i < len; i++) {
 		out[i] = in[len-1-i];
 	}
 }
@@ -145,9 +147,10 @@ int dwc_dh_pk(void *mem_ctx, uint8_t nd, uint8_t *exp, uint8_t *pk, uint8_t *has
 #endif
 
 	/* Compute the pkd */
-	if ((retval = dwc_dh_modpow(mem_ctx, dh_g, 4,
-				    exp, 32,
-				    dh_p, 384, pk))) {
+	retval = dwc_dh_modpow(mem_ctx, dh_g, 4,
+			       exp, 32,
+			       dh_p, 384, pk);
+	if (retval) {
 		return retval;
 	}
 
@@ -155,8 +158,8 @@ int dwc_dh_pk(void *mem_ctx, uint8_t nd, uint8_t *exp, uint8_t *pk, uint8_t *has
 	DWC_MEMCPY(&m3[0], pk, 384);
 	DWC_SHA256(m3, 385, hash);
 
- 	dh_dump("PK", pk, 384);
- 	dh_dump("SHA-256(M3)", hash, 32);
+	dh_dump("PK", pk, 384);
+	dh_dump("SHA-256(M3)", hash, 32);
 	return 0;
 }
 
@@ -176,14 +179,14 @@ int dwc_dh_derive_keys(void *mem_ctx, uint8_t nd, uint8_t *pkh, uint8_t *pkd,
 
 	if (is_host) {
 		pk = pkd;
-	}
-	else {
+	} else {
 		pk = pkh;
 	}
 
-	if ((retval = dwc_dh_modpow(mem_ctx, pk, 384,
-				    exp, 32,
-				    dh_p, 384, shared_secret))) {
+	retval = dwc_dh_modpow(mem_ctx, pk, 384,
+			       exp, 32,
+			       dh_p, 384, shared_secret);
+	if (retval) {
 		return retval;
 	}
 	dh_dump("Shared Secret", shared_secret, 384);
@@ -225,12 +228,12 @@ int dwc_dh_derive_keys(void *mem_ctx, uint8_t nd, uint8_t *pkh, uint8_t *pkd,
 
 	message = "connection key";
 	DWC_HMAC_SHA256(message, DWC_STRLEN(message), dhkey, 32, sha_result);
- 	dh_dump("HMAC(SHA-256, DHKey, connection key)", sha_result, 32);
+	dh_dump("HMAC(SHA-256, DHKey, connection key)", sha_result, 32);
 	DWC_MEMCPY(ck, sha_result, 16);
 
 	message = "key derivation key";
 	DWC_HMAC_SHA256(message, DWC_STRLEN(message), dhkey, 32, sha_result);
- 	dh_dump("HMAC(SHA-256, DHKey, key derivation key)", sha_result, 32);
+	dh_dump("HMAC(SHA-256, DHKey, key derivation key)", sha_result, 32);
 	DWC_MEMCPY(kdk, sha_result, 32);
 
 	return 0;
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_list.h b/drivers/usb/dwc_otg_310/common_port/dwc_list.h
index 89cc325045fc..46f1da352349 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_list.h
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_list.h
@@ -99,10 +99,10 @@ extern "C" {
  * Double-linked List.
  */
 
-typedef struct dwc_list_link {
-	struct dwc_list_link *next;
-	struct dwc_list_link *prev;
-} dwc_list_link_t;
+	typedef struct dwc_list_link {
+		struct dwc_list_link *next;
+		struct dwc_list_link *prev;
+	} dwc_list_link_t;
 
 #define DWC_LIST_INIT(link) do {	\
 	(link)->next = (link);		\
@@ -152,38 +152,41 @@ typedef struct dwc_list_link {
 #endif
 
 #if 0
-static inline void __list_add(struct list_head *new,
-                              struct list_head *prev,
-                              struct list_head *next)
-{
-        next->prev = new;
-        new->next = next;
-        new->prev = prev;
-        prev->next = new;
-}
-
-static inline void list_add(struct list_head *new, struct list_head *head)
-{
-        __list_add(new, head, head->next);
-}
-
-static inline void list_add_tail(struct list_head *new, struct list_head *head)
-{
-        __list_add(new, head->prev, head);
-}
-
-static inline void __list_del(struct list_head * prev, struct list_head * next)
-{
-        next->prev = prev;
-        prev->next = next;
-}
-
-static inline void list_del(struct list_head *entry)
-{
-        __list_del(entry->prev, entry->next);
-        entry->next = LIST_POISON1;
-        entry->prev = LIST_POISON2;
-}
+	static inline void __list_add(struct list_head *new,
+				      struct list_head *prev,
+				      struct list_head *next)
+	{
+		next->prev = new;
+		new->next = next;
+		new->prev = prev;
+		prev->next = new;
+	}
+
+	static inline void list_add(struct list_head *new,
+				      struct list_head *head)
+	{
+		__list_add(new, head, head->next);
+	}
+
+	static inline void list_add_tail(struct list_head *new,
+					 struct list_head *head)
+	{
+		__list_add(new, head->prev, head);
+	}
+
+	static inline void __list_del(struct list_head *prev,
+				      struct list_head *next)
+	{
+		next->prev = prev;
+		prev->next = next;
+	}
+
+	static inline void list_del(struct list_head *entry)
+	{
+		__list_del(entry->prev, entry->next);
+		entry->next = LIST_POISON1;
+		entry->prev = LIST_POISON2;
+	}
 #endif
 
 #define DWC_LIST_REMOVE(link) do {				\
@@ -207,17 +210,17 @@ static inline void list_del(struct list_head *entry)
 } while (0)
 
 #define DWC_LIST_FOREACH(var, list)				\
-	for((var) = DWC_LIST_FIRST(list);			\
+	for ((var) = DWC_LIST_FIRST(list);			\
 	    (var) != DWC_LIST_END(list);			\
 	    (var) = DWC_LIST_NEXT(var))
 
 #define DWC_LIST_FOREACH_SAFE(var, var2, list)			\
-	for((var) = DWC_LIST_FIRST(list), (var2) = DWC_LIST_NEXT(var);	\
+	for ((var) = DWC_LIST_FIRST(list), (var2) = DWC_LIST_NEXT(var);	\
 	    (var) != DWC_LIST_END(list);			\
 	    (var) = (var2), (var2) = DWC_LIST_NEXT(var2))
 
 #define DWC_LIST_FOREACH_REVERSE(var, list)			\
-	for((var) = DWC_LIST_LAST(list);			\
+	for ((var) = DWC_LIST_LAST(list);			\
 	    (var) != DWC_LIST_END(list);			\
 	    (var) = DWC_LIST_PREV(var))
 
@@ -246,12 +249,12 @@ struct {								\
 #define DWC_SLIST_NEXT(elm, field)	((elm)->field.sle_next)
 
 #define DWC_SLIST_FOREACH(var, head, field)				\
-	for((var) = SLIST_FIRST(head);					\
+	for ((var) = SLIST_FIRST(head);					\
 	    (var) != SLIST_END(head);					\
 	    (var) = SLIST_NEXT(var, field))
 
 #define DWC_SLIST_FOREACH_PREVPTR(var, varp, head, field)		\
-	for((varp) = &SLIST_FIRST((head));				\
+	for ((varp) = &SLIST_FIRST((head));				\
 	    ((var) = *(varp)) != SLIST_END(head);			\
 	    (varp) = &SLIST_NEXT((var), field))
 
@@ -286,7 +289,7 @@ struct {								\
 	}								\
 	else {								\
 		struct type *curelm = (head)->slh_first;		\
-		while( curelm->field.sle_next != (elm) )		\
+		while (curelm->field.sle_next != (elm))			\
 			curelm = curelm->field.sle_next;		\
 		curelm->field.sle_next =				\
 		    curelm->field.sle_next->field.sle_next;		\
@@ -319,7 +322,7 @@ struct {								\
 #define DWC_SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)
 
 #define DWC_SIMPLEQ_FOREACH(var, head, field)				\
-	for((var) = SIMPLEQ_FIRST(head);				\
+	for ((var) = SIMPLEQ_FIRST(head);				\
 	    (var) != SIMPLEQ_END(head);					\
 	    (var) = SIMPLEQ_NEXT(var, field))
 
@@ -332,7 +335,8 @@ struct {								\
 } while (0)
 
 #define DWC_SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
-	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+	(elm)->field.sqe_next = (head)->sqh_first;			\
+	if ((elm)->field.sqe_next == NULL)				\
 		(head)->sqh_last = &(elm)->field.sqe_next;		\
 	(head)->sqh_first = (elm);					\
 } while (0)
@@ -344,13 +348,15 @@ struct {								\
 } while (0)
 
 #define DWC_SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {	\
-	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+	(elm)->field.sqe_next = (listelm)->field.sqe_next;		\
+	if ((elm)->field.sqe_next == NULL)				\
 		(head)->sqh_last = &(elm)->field.sqe_next;		\
 	(listelm)->field.sqe_next = (elm);				\
 } while (0)
 
 #define DWC_SIMPLEQ_REMOVE_HEAD(head, field) do {			\
-	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+	(head)->sqh_first = (head)->sqh_first->field.sqe_next;		\
+	if ((head)->sqh_first == NULL)					\
 		(head)->sqh_last = &(head)->sqh_first;			\
 } while (0)
 
@@ -387,12 +393,12 @@ struct {								\
 	(TAILQ_FIRST(head) == TAILQ_END(head))
 
 #define DWC_TAILQ_FOREACH(var, head, field)				\
-	for((var) = TAILQ_FIRST(head);					\
+	for ((var) = TAILQ_FIRST(head);					\
 	    (var) != TAILQ_END(head);					\
 	    (var) = TAILQ_NEXT(var, field))
 
 #define DWC_TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
-	for((var) = TAILQ_LAST(head, headname);				\
+	for ((var) = TAILQ_LAST(head, headname);				\
 	    (var) != TAILQ_END(head);					\
 	    (var) = TAILQ_PREV(var, headname, field))
 
@@ -405,7 +411,8 @@ struct {								\
 } while (0)
 
 #define DWC_TAILQ_INSERT_HEAD(head, elm, field) do {			\
-	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+	(elm)->field.tqe_next = (head)->tqh_first;			\
+	if ((elm)->field.tqe_next != NULL)	\
 		(head)->tqh_first->field.tqe_prev =			\
 		    &(elm)->field.tqe_next;				\
 	else								\
@@ -422,7 +429,8 @@ struct {								\
 } while (0)
 
 #define DWC_TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+	(elm)->field.tqe_next = (listelm)->field.tqe_next;		\
+	if ((elm)->field.tqe_next != NULL)				\
 		(elm)->field.tqe_next->field.tqe_prev =			\
 		    &(elm)->field.tqe_next;				\
 	else								\
@@ -448,7 +456,8 @@ struct {								\
 } while (0)
 
 #define DWC_TAILQ_REPLACE(head, elm, elm2, field) do {			\
-	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
+	(elm2)->field.tqe_next = (elm)->field.tqe_next;			\
+	if ((elm2)->field.tqe_next != NULL)	\
 		(elm2)->field.tqe_next->field.tqe_prev =		\
 		    &(elm2)->field.tqe_next;				\
 	else								\
@@ -489,17 +498,17 @@ struct {								\
 #define DWC_CIRCLEQ_EMPTY_ENTRY(elm, field) (((elm)->field.cqe_next == NULL) && ((elm)->field.cqe_prev == NULL))
 
 #define DWC_CIRCLEQ_FOREACH(var, head, field)				\
-	for((var) = DWC_CIRCLEQ_FIRST(head);				\
+	for ((var) = DWC_CIRCLEQ_FIRST(head);				\
 	    (var) != DWC_CIRCLEQ_END(head);				\
 	    (var) = DWC_CIRCLEQ_NEXT(var, field))
 
 #define DWC_CIRCLEQ_FOREACH_SAFE(var, var2, head, field)			\
-	for((var) = DWC_CIRCLEQ_FIRST(head), var2 = DWC_CIRCLEQ_NEXT(var, field); \
+	for ((var) = DWC_CIRCLEQ_FIRST(head), var2 = DWC_CIRCLEQ_NEXT(var, field); \
 	    (var) != DWC_CIRCLEQ_END(head);					\
 	    (var) = var2, var2 = DWC_CIRCLEQ_NEXT(var, field))
 
 #define DWC_CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
-	for((var) = DWC_CIRCLEQ_LAST(head);				\
+	for ((var) = DWC_CIRCLEQ_LAST(head);				\
 	    (var) != DWC_CIRCLEQ_END(head);				\
 	    (var) = DWC_CIRCLEQ_PREV(var, field))
 
@@ -575,12 +584,14 @@ struct {								\
 } while (0)
 
 #define DWC_CIRCLEQ_REPLACE(head, elm, elm2, field) do {		\
-	if (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==		\
+	(elm2)->field.cqe_next = (elm)->field.cqe_next;			\
+	if ((elm2)->field.cqe_next ==					\
 	    DWC_CIRCLEQ_END(head))					\
 		(head).cqh_last = (elm2);				\
 	else								\
 		(elm2)->field.cqe_next->field.cqe_prev = (elm2);	\
-	if (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==		\
+	(elm2)->field.cqe_prev = (elm)->field.cqe_prev;			\
+	if ((elm2)->field.cqe_prev ==					\
 	    DWC_CIRCLEQ_END(head))					\
 		(head).cqh_first = (elm2);				\
 	else								\
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_mem.c b/drivers/usb/dwc_otg_310/common_port/dwc_mem.c
index ad645ff1ba7e..6d6c6c52d0e3 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_mem.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_mem.c
@@ -29,7 +29,7 @@ struct allocation_manager {
 	uint32_t max;
 };
 
-static struct allocation_manager *manager = NULL;
+static struct allocation_manager *manager;
 
 static int add_allocation(void *ctx, uint32_t size, char const *func, int line, void *addr,
 			  int dma)
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_modpow.c b/drivers/usb/dwc_otg_310/common_port/dwc_modpow.c
index f410f6e83c27..541c464960f0 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_modpow.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_modpow.c
@@ -37,14 +37,14 @@
 #define BIGNUM_TOP_BIT   0x80000000UL
 #define BIGNUM_INT_BITS  32
 
-
 static void *snmalloc(void *mem_ctx, size_t n, size_t size)
 {
-    void *p;
-    size *= n;
-    if (size == 0) size = 1;
-    p = dwc_alloc(mem_ctx, size);
-    return p;
+	void *p;
+	size *= n;
+	if (size == 0)
+		size = 1;
+	p = dwc_alloc(mem_ctx, size);
+	return p;
 }
 
 #define snewn(ctx, n, type) ((type *)snmalloc((ctx), (n), sizeof(type)))
@@ -85,21 +85,21 @@ static void *snmalloc(void *mem_ctx, size_t n, size_t size)
 
 static Bignum newbn(void *mem_ctx, int length)
 {
-    Bignum b = snewn(mem_ctx, length + 1, BignumInt);
-    //if (!b)
-    //abort();		       /* FIXME */
-    DWC_MEMSET(b, 0, (length + 1) * sizeof(*b));
-    b[0] = length;
-    return b;
+	Bignum b = snewn(mem_ctx, length + 1, BignumInt);
+	/* if (!b) */
+	/* abort(); */                 /* FIXME */
+	DWC_MEMSET(b, 0, (length + 1) * sizeof(*b));
+	b[0] = length;
+	return b;
 }
 
 void freebn(void *mem_ctx, Bignum b)
 {
-    /*
-     * Burn the evidence, just in case.
-     */
-    DWC_MEMSET(b, 0, sizeof(b[0]) * (b[0] + 1));
-    sfree(mem_ctx, b);
+	/*
+	 * Burn the evidence, just in case.
+	 */
+	DWC_MEMSET(b, 0, sizeof(b[0]) * (b[0] + 1));
+	sfree(mem_ctx, b);
 }
 
 /*
@@ -107,42 +107,40 @@ void freebn(void *mem_ctx, Bignum b)
  * Input is in the first len words of a and b.
  * Result is returned in the first 2*len words of c.
  */
-static void internal_mul(BignumInt *a, BignumInt *b,
-			 BignumInt *c, int len)
+static void internal_mul(BignumInt *a, BignumInt *b, BignumInt *c, int len)
 {
-    int i, j;
-    BignumDblInt t;
-
-    for (j = 0; j < 2 * len; j++)
-	c[j] = 0;
-
-    for (i = len - 1; i >= 0; i--) {
-	t = 0;
-	for (j = len - 1; j >= 0; j--) {
-	    t += MUL_WORD(a[i], (BignumDblInt) b[j]);
-	    t += (BignumDblInt) c[i + j + 1];
-	    c[i + j + 1] = (BignumInt) t;
-	    t = t >> BIGNUM_INT_BITS;
+	int i, j;
+	BignumDblInt t;
+
+	for (j = 0; j < 2 * len; j++)
+		c[j] = 0;
+
+	for (i = len - 1; i >= 0; i--) {
+		t = 0;
+		for (j = len - 1; j >= 0; j--) {
+			t += MUL_WORD(a[i], (BignumDblInt) b[j]);
+			t += (BignumDblInt) c[i + j + 1];
+			c[i + j + 1] = (BignumInt) t;
+			t = t >> BIGNUM_INT_BITS;
+		}
+		c[i] = (BignumInt) t;
 	}
-	c[i] = (BignumInt) t;
-    }
 }
 
-static void internal_add_shifted(BignumInt *number,
-				 unsigned n, int shift)
+static void internal_add_shifted(BignumInt *number, unsigned n, int shift)
 {
-    int word = 1 + (shift / BIGNUM_INT_BITS);
-    int bshift = shift % BIGNUM_INT_BITS;
-    BignumDblInt addend;
-
-    addend = (BignumDblInt)n << bshift;
-
-    while (addend) {
-	addend += number[word];
-	number[word] = (BignumInt) addend & BIGNUM_INT_MASK;
-	addend >>= BIGNUM_INT_BITS;
-	word++;
-    }
+	int word = 1 + (shift / BIGNUM_INT_BITS);
+	int bshift = shift % BIGNUM_INT_BITS;
+	BignumDblInt addend;
+
+	addend = (BignumDblInt) n << bshift;
+
+	while (addend) {
+		addend += number[word];
+		number[word] = (BignumInt) addend & BIGNUM_INT_MASK;
+		addend >>= BIGNUM_INT_BITS;
+		word++;
+	}
 }
 
 /*
@@ -156,96 +154,100 @@ static void internal_add_shifted(BignumInt *number,
  * left by `qshift' before adding into quot.
  */
 static void internal_mod(BignumInt *a, int alen,
-			 BignumInt *m, int mlen,
-			 BignumInt *quot, int qshift)
+			 BignumInt *m, int mlen, BignumInt *quot, int qshift)
 {
-    BignumInt m0, m1;
-    unsigned int h;
-    int i, k;
-
-    m0 = m[0];
-    if (mlen > 1)
-	m1 = m[1];
-    else
-	m1 = 0;
-
-    for (i = 0; i <= alen - mlen; i++) {
-	BignumDblInt t;
-	unsigned int q, r, c, ai1;
+	BignumInt m0, m1;
+	unsigned int h;
+	int i, k;
 
-	if (i == 0) {
-	    h = 0;
-	} else {
-	    h = a[i - 1];
-	    a[i - 1] = 0;
-	}
-
-	if (i == alen - 1)
-	    ai1 = 0;
+	m0 = m[0];
+	if (mlen > 1)
+		m1 = m[1];
 	else
-	    ai1 = a[i + 1];
-
-	/* Find q = h:a[i] / m0 */
-	if (h >= m0) {
-	    /*
-	     * Special case.
-	     * 
-	     * To illustrate it, suppose a BignumInt is 8 bits, and
-	     * we are dividing (say) A1:23:45:67 by A1:B2:C3. Then
-	     * our initial division will be 0xA123 / 0xA1, which
-	     * will give a quotient of 0x100 and a divide overflow.
-	     * However, the invariants in this division algorithm
-	     * are not violated, since the full number A1:23:... is
-	     * _less_ than the quotient prefix A1:B2:... and so the
-	     * following correction loop would have sorted it out.
-	     * 
-	     * In this situation we set q to be the largest
-	     * quotient we _can_ stomach (0xFF, of course).
-	     */
-	    q = BIGNUM_INT_MASK;
-	} else {
-	    /* Macro doesn't want an array subscript expression passed
-	     * into it (see definition), so use a temporary. */
-	    BignumInt tmplo = a[i];
-	    DIVMOD_WORD(q, r, h, tmplo, m0);
-
-	    /* Refine our estimate of q by looking at
-	     h:a[i]:a[i+1] / m0:m1 */
-	    t = MUL_WORD(m1, q);
-	    if (t > ((BignumDblInt) r << BIGNUM_INT_BITS) + ai1) {
-		q--;
-		t -= m1;
-		r = (r + m0) & BIGNUM_INT_MASK;     /* overflow? */
-		if (r >= (BignumDblInt) m0 &&
-		    t > ((BignumDblInt) r << BIGNUM_INT_BITS) + ai1) q--;
-	    }
-	}
-
-	/* Subtract q * m from a[i...] */
-	c = 0;
-	for (k = mlen - 1; k >= 0; k--) {
-	    t = MUL_WORD(q, m[k]);
-	    t += c;
-	    c = (unsigned)(t >> BIGNUM_INT_BITS);
-	    if ((BignumInt) t > a[i + k])
-		c++;
-	    a[i + k] -= (BignumInt) t;
-	}
-
-	/* Add back m in case of borrow */
-	if (c != h) {
-	    t = 0;
-	    for (k = mlen - 1; k >= 0; k--) {
-		t += m[k];
-		t += a[i + k];
-		a[i + k] = (BignumInt) t;
-		t = t >> BIGNUM_INT_BITS;
-	    }
-	    q--;
+		m1 = 0;
+
+	for (i = 0; i <= alen - mlen; i++) {
+		BignumDblInt t;
+		unsigned int q, r, c, ai1;
+
+		if (i == 0) {
+			h = 0;
+		} else {
+			h = a[i - 1];
+			a[i - 1] = 0;
+		}
+
+		if (i == alen - 1)
+			ai1 = 0;
+		else
+			ai1 = a[i + 1];
+
+		/* Find q = h:a[i] / m0 */
+		if (h >= m0) {
+			/*
+			 * Special case.
+			 *
+			 * To illustrate it, suppose a BignumInt is 8 bits, and
+			 * we are dividing (say) A1:23:45:67 by A1:B2:C3. Then
+			 * our initial division will be 0xA123 / 0xA1, which
+			 * will give a quotient of 0x100 and a divide overflow.
+			 * However, the invariants in this division algorithm
+			 * are not violated, since the full number A1:23:... is
+			 * _less_ than the quotient prefix A1:B2:... and so the
+			 * following correction loop would have sorted it out.
+			 *
+			 * In this situation we set q to be the largest
+			 * quotient we _can_ stomach (0xFF, of course).
+			 */
+			q = BIGNUM_INT_MASK;
+		} else {
+			/* Macro doesn't want an array subscript expression passed
+			 * into it (see definition), so use a temporary. */
+			BignumInt tmplo = a[i];
+			DIVMOD_WORD(q, r, h, tmplo, m0);
+
+			/* Refine our estimate of q by looking at
+			   h:a[i]:a[i+1] / m0:m1 */
+			t = MUL_WORD(m1, q);
+			if (t > ((BignumDblInt) r << BIGNUM_INT_BITS) + ai1) {
+				q--;
+				t -= m1;
+				r = (r + m0) & BIGNUM_INT_MASK;	/* overflow? */
+				if (r >= (BignumDblInt) m0 &&
+				    t >
+				    ((BignumDblInt) r << BIGNUM_INT_BITS) + ai1)
+					q--;
+			}
+		}
+
+		/* Subtract q * m from a[i...] */
+		c = 0;
+		for (k = mlen - 1; k >= 0; k--) {
+			t = MUL_WORD(q, m[k]);
+			t += c;
+			c = (unsigned)(t >> BIGNUM_INT_BITS);
+			if ((BignumInt) t > a[i + k])
+				c++;
+			a[i + k] -= (BignumInt) t;
+		}
+
+		/* Add back m in case of borrow */
+		if (c != h) {
+			t = 0;
+			for (k = mlen - 1; k >= 0; k--) {
+				t += m[k];
+				t += a[i + k];
+				a[i + k] = (BignumInt) t;
+				t = t >> BIGNUM_INT_BITS;
+			}
+			q--;
+		}
+		if (quot)
+			internal_add_shifted(quot, q,
+					     qshift + BIGNUM_INT_BITS * (alen -
+									 mlen -
+									 i));
 	}
-	if (quot)
-	    internal_add_shifted(quot, q, qshift + BIGNUM_INT_BITS * (alen - mlen - i));
-    }
 }
 
 /*
@@ -255,73 +257,80 @@ static void internal_mod(BignumInt *a, int alen,
  * We optionally write out a quotient if `quotient' is non-NULL.
  * We can avoid writing out the result if `result' is NULL.
  */
-void bigdivmod(void *mem_ctx, Bignum p, Bignum mod, Bignum result, Bignum quotient)
+void bigdivmod(void *mem_ctx, Bignum p, Bignum mod, Bignum result,
+	       Bignum quotient)
 {
-    BignumInt *n, *m;
-    int mshift;
-    int plen, mlen, i, j;
-
-    /* Allocate m of size mlen, copy mod to m */
-    /* We use big endian internally */
-    mlen = mod[0];
-    m = snewn(mem_ctx, mlen, BignumInt);
-    //if (!m)
-    //abort();		       /* FIXME */
-    for (j = 0; j < mlen; j++)
-	m[j] = mod[mod[0] - j];
-
-    /* Shift m left to make msb bit set */
-    for (mshift = 0; mshift < BIGNUM_INT_BITS-1; mshift++)
-	if ((m[0] << mshift) & BIGNUM_TOP_BIT)
-	    break;
-    if (mshift) {
-	for (i = 0; i < mlen - 1; i++)
-	    m[i] = (m[i] << mshift) | (m[i + 1] >> (BIGNUM_INT_BITS - mshift));
-	m[mlen - 1] = m[mlen - 1] << mshift;
-    }
-
-    plen = p[0];
-    /* Ensure plen > mlen */
-    if (plen <= mlen)
-	plen = mlen + 1;
-
-    /* Allocate n of size plen, copy p to n */
-    n = snewn(mem_ctx, plen, BignumInt);
-    //if (!n)
-    //abort();		       /* FIXME */
-    for (j = 0; j < plen; j++)
-	n[j] = 0;
-    for (j = 1; j <= (int)p[0]; j++)
-	n[plen - j] = p[j];
-
-    /* Main computation */
-    internal_mod(n, plen, m, mlen, quotient, mshift);
-
-    /* Fixup result in case the modulus was shifted */
-    if (mshift) {
-	for (i = plen - mlen - 1; i < plen - 1; i++)
-	    n[i] = (n[i] << mshift) | (n[i + 1] >> (BIGNUM_INT_BITS - mshift));
-	n[plen - 1] = n[plen - 1] << mshift;
-	internal_mod(n, plen, m, mlen, quotient, 0);
-	for (i = plen - 1; i >= plen - mlen; i--)
-	    n[i] = (n[i] >> mshift) | (n[i - 1] << (BIGNUM_INT_BITS - mshift));
-    }
-
-    /* Copy result to buffer */
-    if (result) {
-	for (i = 1; i <= (int)result[0]; i++) {
-	    int j = plen - i;
-	    result[i] = j >= 0 ? n[j] : 0;
+	BignumInt *n, *m;
+	int mshift;
+	int plen, mlen, i, j;
+
+	/* Allocate m of size mlen, copy mod to m */
+	/* We use big endian internally */
+	mlen = mod[0];
+	m = snewn(mem_ctx, mlen, BignumInt);
+	/* if (!m) */
+	/* abort(); */                /* FIXME */
+	for (j = 0; j < mlen; j++)
+		m[j] = mod[mod[0] - j];
+
+	/* Shift m left to make msb bit set */
+	for (mshift = 0; mshift < BIGNUM_INT_BITS - 1; mshift++)
+		if ((m[0] << mshift) & BIGNUM_TOP_BIT)
+			break;
+	if (mshift) {
+		for (i = 0; i < mlen - 1; i++)
+			m[i] =
+			    (m[i] << mshift) | (m[i + 1] >>
+						(BIGNUM_INT_BITS - mshift));
+		m[mlen - 1] = m[mlen - 1] << mshift;
 	}
-    }
-
-    /* Free temporary arrays */
-    for (i = 0; i < mlen; i++)
-	m[i] = 0;
-    sfree(mem_ctx, m);
-    for (i = 0; i < plen; i++)
-	n[i] = 0;
-    sfree(mem_ctx, n);
+
+	plen = p[0];
+	/* Ensure plen > mlen */
+	if (plen <= mlen)
+		plen = mlen + 1;
+
+	/* Allocate n of size plen, copy p to n */
+	n = snewn(mem_ctx, plen, BignumInt);
+	/* if (!n) */
+	/* abort(); */                /* FIXME */
+	for (j = 0; j < plen; j++)
+		n[j] = 0;
+	for (j = 1; j <= (int)p[0]; j++)
+		n[plen - j] = p[j];
+
+	/* Main computation */
+	internal_mod(n, plen, m, mlen, quotient, mshift);
+
+	/* Fixup result in case the modulus was shifted */
+	if (mshift) {
+		for (i = plen - mlen - 1; i < plen - 1; i++)
+			n[i] =
+			    (n[i] << mshift) | (n[i + 1] >>
+						(BIGNUM_INT_BITS - mshift));
+		n[plen - 1] = n[plen - 1] << mshift;
+		internal_mod(n, plen, m, mlen, quotient, 0);
+		for (i = plen - 1; i >= plen - mlen; i--)
+			n[i] =
+			    (n[i] >> mshift) | (n[i - 1] <<
+						(BIGNUM_INT_BITS - mshift));
+	}
+
+	/* Copy result to buffer */
+	if (result) {
+		for (i = 1; i <= (int)result[0]; i++) {
+			int j = plen - i;
+			result[i] = j >= 0 ? n[j] : 0;
+		}
+	}
+
+	/* Free temporary arrays */
+	for (i = 0; i < mlen; i++)
+		m[i] = 0;
+	sfree(mem_ctx, m);
+	for (i = 0; i < plen; i++)
+		n[i] = 0;
+	sfree(mem_ctx, n);
 }
 
 /*
@@ -329,9 +338,9 @@ void bigdivmod(void *mem_ctx, Bignum p, Bignum mod, Bignum result, Bignum quotie
  */
 Bignum bigmod(void *mem_ctx, Bignum a, Bignum b)
 {
-    Bignum r = newbn(mem_ctx, b[0]);
-    bigdivmod(mem_ctx, a, b, r, NULL);
-    return r;
+	Bignum r = newbn(mem_ctx, b[0]);
+	bigdivmod(mem_ctx, a, b, r, NULL);
+	return r;
 }
 
 /*
@@ -339,136 +348,135 @@ Bignum bigmod(void *mem_ctx, Bignum a, Bignum b)
  */
 Bignum dwc_modpow(void *mem_ctx, Bignum base_in, Bignum exp, Bignum mod)
 {
-    BignumInt *a, *b, *n, *m;
-    int mshift;
-    int mlen, i, j;
-    Bignum base, result;
-
-    /*
-     * The most significant word of mod needs to be non-zero. It
-     * should already be, but let's make sure.
-     */
-    //assert(mod[mod[0]] != 0);
-
-    /*
-     * Make sure the base is smaller than the modulus, by reducing
-     * it modulo the modulus if not.
-     */
-    base = bigmod(mem_ctx, base_in, mod);
-
-    /* Allocate m of size mlen, copy mod to m */
-    /* We use big endian internally */
-    mlen = mod[0];
-    m = snewn(mem_ctx, mlen, BignumInt);
-    //if (!m)
-    //abort();		       /* FIXME */
-    for (j = 0; j < mlen; j++)
-	m[j] = mod[mod[0] - j];
-
-    /* Shift m left to make msb bit set */
-    for (mshift = 0; mshift < BIGNUM_INT_BITS - 1; mshift++)
-	if ((m[0] << mshift) & BIGNUM_TOP_BIT)
-	    break;
-    if (mshift) {
-	for (i = 0; i < mlen - 1; i++)
-	    m[i] =
-		(m[i] << mshift) | (m[i + 1] >>
-				    (BIGNUM_INT_BITS - mshift));
-	m[mlen - 1] = m[mlen - 1] << mshift;
-    }
-
-    /* Allocate n of size mlen, copy base to n */
-    n = snewn(mem_ctx, mlen, BignumInt);
-    //if (!n)
-    //abort();		       /* FIXME */
-    i = mlen - base[0];
-    for (j = 0; j < i; j++)
-	n[j] = 0;
-    for (j = 0; j < base[0]; j++)
-	n[i + j] = base[base[0] - j];
-
-    /* Allocate a and b of size 2*mlen. Set a = 1 */
-    a = snewn(mem_ctx, 2 * mlen, BignumInt);
-    //if (!a)
-    //abort();		       /* FIXME */
-    b = snewn(mem_ctx, 2 * mlen, BignumInt);
-    //if (!b)
-    //abort();		       /* FIXME */
-    for (i = 0; i < 2 * mlen; i++)
-	a[i] = 0;
-    a[2 * mlen - 1] = 1;
-
-    /* Skip leading zero bits of exp. */
-    i = 0;
-    j = BIGNUM_INT_BITS - 1;
-    while (i < exp[0] && (exp[exp[0] - i] & (1 << j)) == 0) {
-	j--;
-	if (j < 0) {
-	    i++;
-	    j = BIGNUM_INT_BITS - 1;
+	BignumInt *a, *b, *n, *m;
+	int mshift;
+	int mlen, i, j;
+	Bignum base, result;
+
+	/*
+	 * The most significant word of mod needs to be non-zero. It
+	 * should already be, but let's make sure.
+	 */
+	/* assert(mod[mod[0]] != 0); */
+
+	/*
+	 * Make sure the base is smaller than the modulus, by reducing
+	 * it modulo the modulus if not.
+	 */
+	base = bigmod(mem_ctx, base_in, mod);
+
+	/* Allocate m of size mlen, copy mod to m */
+	/* We use big endian internally */
+	mlen = mod[0];
+	m = snewn(mem_ctx, mlen, BignumInt);
+	/* if (!m) */
+	/* abort(); */                /* FIXME */
+	for (j = 0; j < mlen; j++)
+		m[j] = mod[mod[0] - j];
+
+	/* Shift m left to make msb bit set */
+	for (mshift = 0; mshift < BIGNUM_INT_BITS - 1; mshift++)
+		if ((m[0] << mshift) & BIGNUM_TOP_BIT)
+			break;
+	if (mshift) {
+		for (i = 0; i < mlen - 1; i++)
+			m[i] =
+			    (m[i] << mshift) | (m[i + 1] >>
+						(BIGNUM_INT_BITS - mshift));
+		m[mlen - 1] = m[mlen - 1] << mshift;
+	}
+
+	/* Allocate n of size mlen, copy base to n */
+	n = snewn(mem_ctx, mlen, BignumInt);
+	/* if (!n) */
+	/* abort(); */                /* FIXME */
+	i = mlen - base[0];
+	for (j = 0; j < i; j++)
+		n[j] = 0;
+	for (j = 0; j < base[0]; j++)
+		n[i + j] = base[base[0] - j];
+
+	/* Allocate a and b of size 2*mlen. Set a = 1 */
+	a = snewn(mem_ctx, 2 * mlen, BignumInt);
+	/* if (!a) */
+	/* abort(); */                /* FIXME */
+	b = snewn(mem_ctx, 2 * mlen, BignumInt);
+	/* if (!b) */
+	/* abort(); */                /* FIXME */
+	for (i = 0; i < 2 * mlen; i++)
+		a[i] = 0;
+	a[2 * mlen - 1] = 1;
+
+	/* Skip leading zero bits of exp. */
+	i = 0;
+	j = BIGNUM_INT_BITS - 1;
+	while (i < exp[0] && (exp[exp[0] - i] & (1 << j)) == 0) {
+		j--;
+		if (j < 0) {
+			i++;
+			j = BIGNUM_INT_BITS - 1;
+		}
 	}
-    }
-
-    /* Main computation */
-    while (i < exp[0]) {
-	while (j >= 0) {
-	    internal_mul(a + mlen, a + mlen, b, mlen);
-	    internal_mod(b, mlen * 2, m, mlen, NULL, 0);
-	    if ((exp[exp[0] - i] & (1 << j)) != 0) {
-		internal_mul(b + mlen, n, a, mlen);
+
+	/* Main computation */
+	while (i < exp[0]) {
+		while (j >= 0) {
+			internal_mul(a + mlen, a + mlen, b, mlen);
+			internal_mod(b, mlen * 2, m, mlen, NULL, 0);
+			if ((exp[exp[0] - i] & (1 << j)) != 0) {
+				internal_mul(b + mlen, n, a, mlen);
+				internal_mod(a, mlen * 2, m, mlen, NULL, 0);
+			} else {
+				BignumInt *t;
+				t = a;
+				a = b;
+				b = t;
+			}
+			j--;
+		}
+		i++;
+		j = BIGNUM_INT_BITS - 1;
+	}
+
+	/* Fixup result in case the modulus was shifted */
+	if (mshift) {
+		for (i = mlen - 1; i < 2 * mlen - 1; i++)
+			a[i] =
+			    (a[i] << mshift) | (a[i + 1] >>
+						(BIGNUM_INT_BITS - mshift));
+		a[2 * mlen - 1] = a[2 * mlen - 1] << mshift;
 		internal_mod(a, mlen * 2, m, mlen, NULL, 0);
-	    } else {
-		BignumInt *t;
-		t = a;
-		a = b;
-		b = t;
-	    }
-	    j--;
+		for (i = 2 * mlen - 1; i >= mlen; i--)
+			a[i] =
+			    (a[i] >> mshift) | (a[i - 1] <<
+						(BIGNUM_INT_BITS - mshift));
 	}
-	i++;
-	j = BIGNUM_INT_BITS - 1;
-    }
-
-    /* Fixup result in case the modulus was shifted */
-    if (mshift) {
-	for (i = mlen - 1; i < 2 * mlen - 1; i++)
-	    a[i] =
-		(a[i] << mshift) | (a[i + 1] >>
-				    (BIGNUM_INT_BITS - mshift));
-	a[2 * mlen - 1] = a[2 * mlen - 1] << mshift;
-	internal_mod(a, mlen * 2, m, mlen, NULL, 0);
-	for (i = 2 * mlen - 1; i >= mlen; i--)
-	    a[i] =
-		(a[i] >> mshift) | (a[i - 1] <<
-				    (BIGNUM_INT_BITS - mshift));
-    }
-
-    /* Copy result to buffer */
-    result = newbn(mem_ctx, mod[0]);
-    for (i = 0; i < mlen; i++)
-	result[result[0] - i] = a[i + mlen];
-    while (result[0] > 1 && result[result[0]] == 0)
-	result[0]--;
-
-    /* Free temporary arrays */
-    for (i = 0; i < 2 * mlen; i++)
-	a[i] = 0;
-    sfree(mem_ctx, a);
-    for (i = 0; i < 2 * mlen; i++)
-	b[i] = 0;
-    sfree(mem_ctx, b);
-    for (i = 0; i < mlen; i++)
-	m[i] = 0;
-    sfree(mem_ctx, m);
-    for (i = 0; i < mlen; i++)
-	n[i] = 0;
-    sfree(mem_ctx, n);
-
-    freebn(mem_ctx, base);
-
-    return result;
-}
 
+	/* Copy result to buffer */
+	result = newbn(mem_ctx, mod[0]);
+	for (i = 0; i < mlen; i++)
+		result[result[0] - i] = a[i + mlen];
+	while (result[0] > 1 && result[result[0]] == 0)
+		result[0]--;
+
+	/* Free temporary arrays */
+	for (i = 0; i < 2 * mlen; i++)
+		a[i] = 0;
+	sfree(mem_ctx, a);
+	for (i = 0; i < 2 * mlen; i++)
+		b[i] = 0;
+	sfree(mem_ctx, b);
+	for (i = 0; i < mlen; i++)
+		m[i] = 0;
+	sfree(mem_ctx, m);
+	for (i = 0; i < mlen; i++)
+		n[i] = 0;
+	sfree(mem_ctx, n);
+
+	freebn(mem_ctx, base);
+
+	return result;
+}
 
 #ifdef UNITTEST
 
@@ -591,7 +599,7 @@ static __u32 dh_b[] = {
 	0x6fa452cd,
 	0x2df89d30,
 	0xc75f1b0f,
-	0x8ce3578f, 
+	0x8ce3578f,
 	0x7980a324,
 	0x5daec786,
 };
@@ -608,19 +616,19 @@ int main(void)
 	k = dwc_modpow(NULL, dh_g, dh_a, dh_p);
 
 	printf("\n\n");
-	for (i=0; i<k[0]; i++) {
+	for (i = 0; i < k[0]; i++) {
 		__u32 word32 = k[k[0] - i];
 		__u16 l = word32 & 0xffff;
 		__u16 m = (word32 & 0xffff0000) >> 16;
 		printf("%04x %04x ", m, l);
-		if (!((i + 1)%13)) printf("\n");
+		if (!((i + 1) % 13))
+			printf("\n");
 	}
 	printf("\n\n");
 
 	if ((k[0] == 0x60) && (k[1] == 0x28e490e5) && (k[0x60] == 0x5a0d3d4e)) {
 		printf("PASS\n\n");
-	}
-	else {
+	} else {
 		printf("FAIL\n\n");
 	}
 
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_modpow.h b/drivers/usb/dwc_otg_310/common_port/dwc_modpow.h
index 64f00c276e71..e96f59246539 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_modpow.h
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_modpow.h
@@ -22,7 +22,7 @@ extern "C" {
 
 typedef uint32_t BignumInt;
 typedef uint64_t BignumDblInt;
-typedef BignumInt *Bignum;
+typedef uint32_t *Bignum;
 
 /* Compute modular exponentiaion */
 extern Bignum dwc_modpow(void *mem_ctx, Bignum base_in, Bignum exp, Bignum mod);
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_notifier.c b/drivers/usb/dwc_otg_310/common_port/dwc_notifier.c
index d3dadce4bc74..bbe769201a87 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_notifier.c
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_notifier.c
@@ -26,11 +26,11 @@ typedef struct manager {
 	void *mem_ctx;
 	void *wkq_ctx;
 	dwc_workq_t *wq;
-//	dwc_mutex_t *mutex;
+	/* dwc_mutex_t *mutex; */
 	struct notifier_queue notifiers;
 } manager_t;
 
-static manager_t *manager = NULL;
+static manager_t *manager;
 
 static int create_manager(void *mem_ctx, void *wkq_ctx)
 {
diff --git a/drivers/usb/dwc_otg_310/common_port/dwc_os.h b/drivers/usb/dwc_otg_310/common_port/dwc_os.h
index 7914eb37c377..62bacae0f17a 100755
--- a/drivers/usb/dwc_otg_310/common_port/dwc_os.h
+++ b/drivers/usb/dwc_otg_310/common_port/dwc_os.h
@@ -144,7 +144,8 @@ extern dwc_bool_t DWC_IN_IRQ(void);
 #define dwc_in_irq DWC_IN_IRQ
 
 /** Returns "IRQ" if DWC_IN_IRQ is true. */
-static inline char *dwc_irq(void) {
+static inline char *dwc_irq(void)
+{
 	return DWC_IN_IRQ() ? "IRQ" : "";
 }
 
@@ -153,7 +154,8 @@ extern dwc_bool_t DWC_IN_BH(void);
 #define dwc_in_bh DWC_IN_BH
 
 /** Returns "BH" if DWC_IN_BH is true. */
-static inline char *dwc_bh(void) {
+static inline char *dwc_bh(void)
+{
 	return DWC_IN_BH() ? "BH" : "";
 }
 
@@ -297,8 +299,9 @@ extern void __DWC_DEBUG(char *format, ...)
 /** Prints out a exception error message if the _expr expression fails.  Disabled
  * if DEBUG is not enabled. */
 #define DWC_ASSERT(_expr, _format, _args...) do { \
-	if (!(_expr)) { DWC_EXCEPTION("%s:%s:%d: " _format "\n", dwc_irq(), \
-				      __FILE__, __LINE__, ## _args); } \
+	if (!(_expr)) { \
+		DWC_EXCEPTION("%s:%s:%d: " _format "\n", dwc_irq(), \
+				__FILE__, __LINE__, ## _args); } \
 	} while (0)
 #else
 #define DWC_ASSERT(_x...)
@@ -356,29 +359,29 @@ extern uint16_t DWC_BE16_TO_CPU(uint16_t *p);
  * just throw away the IO context parameter.
  */
 /** Reads the content of a 32-bit register. */
-extern uint32_t DWC_READ_REG32(uint32_t volatile *reg);
-#define dwc_read_reg32(_ctx_,_reg_) DWC_READ_REG32(_reg_)
+extern uint32_t DWC_READ_REG32(volatile uint32_t *reg);
+#define dwc_read_reg32(_ctx_, _reg_) DWC_READ_REG32(_reg_)
 
 /** Reads the content of a 64-bit register. */
-extern uint64_t DWC_READ_REG64(uint64_t volatile *reg);
-#define dwc_read_reg64(_ctx_,_reg_) DWC_READ_REG64(_reg_)
+extern uint64_t DWC_READ_REG64(volatile uint64_t *reg);
+#define dwc_read_reg64(_ctx_, _reg_) DWC_READ_REG64(_reg_)
 
 /** Writes to a 32-bit register. */
-extern void DWC_WRITE_REG32(uint32_t volatile *reg, uint32_t value);
-#define dwc_write_reg32(_ctx_,_reg_,_val_) DWC_WRITE_REG32(_reg_, _val_)
+extern void DWC_WRITE_REG32(volatile uint32_t *reg, uint32_t value);
+#define dwc_write_reg32(_ctx_, _reg_, _val_) DWC_WRITE_REG32(_reg_, _val_)
 
 /** Writes to a 64-bit register. */
-extern void DWC_WRITE_REG64(uint64_t volatile *reg, uint64_t value);
-#define dwc_write_reg64(_ctx_,_reg_,_val_) DWC_WRITE_REG64(_reg_, _val_)
+extern void DWC_WRITE_REG64(volatile uint64_t  *reg, uint64_t value);
+#define dwc_write_reg64(_ctx_, _reg_, _val_) DWC_WRITE_REG64(_reg_, _val_)
 
 /**
  * Modify bit values in a register.  Using the
  * algorithm: (reg_contents & ~clear_mask) | set_mask.
  */
-extern void DWC_MODIFY_REG32(uint32_t volatile *reg, uint32_t clear_mask, uint32_t set_mask);
-#define dwc_modify_reg32(_ctx_,_reg_,_cmsk_,_smsk_) DWC_MODIFY_REG32(_reg_,_cmsk_,_smsk_)
-extern void DWC_MODIFY_REG64(uint64_t volatile *reg, uint64_t clear_mask, uint64_t set_mask);
-#define dwc_modify_reg64(_ctx_,_reg_,_cmsk_,_smsk_) DWC_MODIFY_REG64(_reg_,_cmsk_,_smsk_)
+extern void DWC_MODIFY_REG32(volatile uint32_t *reg, uint32_t clear_mask, uint32_t set_mask);
+#define dwc_modify_reg32(_ctx_, _reg_, _cmsk_, _smsk_) DWC_MODIFY_REG32(_reg_, _cmsk_, _smsk_)
+extern void DWC_MODIFY_REG64(volatile uint64_t  *reg, uint64_t clear_mask, uint64_t set_mask);
+#define dwc_modify_reg64(_ctx_, _reg_, _cmsk_, _smsk_) DWC_MODIFY_REG64(_reg_, _cmsk_, _smsk_)
 
 #endif	/* DWC_LINUX */
 
@@ -393,28 +396,28 @@ typedef struct dwc_ioctx {
  * them in using the IO context parameter.
  */
 /** Reads the content of a 32-bit register. */
-extern uint32_t DWC_READ_REG32(void *io_ctx, uint32_t volatile *reg);
+extern uint32_t DWC_READ_REG32(void *io_ctx, volatile uint32_t *reg);
 #define dwc_read_reg32 DWC_READ_REG32
 
 /** Reads the content of a 64-bit register. */
-extern uint64_t DWC_READ_REG64(void *io_ctx, uint64_t volatile *reg);
+extern uint64_t DWC_READ_REG64(void *io_ctx, volatile uint64_t *reg);
 #define dwc_read_reg64 DWC_READ_REG64
 
 /** Writes to a 32-bit register. */
-extern void DWC_WRITE_REG32(void *io_ctx, uint32_t volatile *reg, uint32_t value);
+extern void DWC_WRITE_REG32(void *io_ctx, volatile uint32_t *reg, uint32_t value);
 #define dwc_write_reg32 DWC_WRITE_REG32
 
 /** Writes to a 64-bit register. */
-extern void DWC_WRITE_REG64(void *io_ctx, uint64_t volatile *reg, uint64_t value);
+extern void DWC_WRITE_REG64(void *io_ctx, volatile uint64_t *reg, uint64_t value);
 #define dwc_write_reg64 DWC_WRITE_REG64
 
 /**
  * Modify bit values in a register.  Using the
  * algorithm: (reg_contents & ~clear_mask) | set_mask.
  */
-extern void DWC_MODIFY_REG32(void *io_ctx, uint32_t volatile *reg, uint32_t clear_mask, uint32_t set_mask);
+extern void DWC_MODIFY_REG32(void *io_ctx, volatile uint32_t *reg, uint32_t clear_mask, uint32_t set_mask);
 #define dwc_modify_reg32 DWC_MODIFY_REG32
-extern void DWC_MODIFY_REG64(void *io_ctx, uint64_t volatile *reg, uint64_t clear_mask, uint64_t set_mask);
+extern void DWC_MODIFY_REG64(void *io_ctx, volatile uint64_t *reg, uint64_t clear_mask, uint64_t set_mask);
 #define dwc_modify_reg64 DWC_MODIFY_REG64
 
 #endif	/* DWC_FREEBSD || DWC_NETBSD */
@@ -428,40 +431,48 @@ extern void DWC_MODIFY_REG64(void *io_ctx, uint64_t volatile *reg, uint64_t clea
 
 # ifdef DWC_DEBUG_REGS
 
-#define dwc_define_read_write_reg_n(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg##_n(_container_type *container, int num) { \
+#define dwc_define_read_write_reg_n(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg##_n(_container_type * container, int num) \
+{ \
 	return DWC_READ_REG32(&container->regs->_reg[num]); \
 } \
-static inline void dwc_write_##_reg##_n(_container_type *container, int num, uint32_t data) { \
+static inline void dwc_write_##_reg##_n(_container_type *container, int num, uint32_t data) \
+{ \
 	DWC_DEBUG("WRITING %8s[%d]: %p: %08x", #_reg, num, \
-		  &(((uint32_t*)container->regs->_reg)[num]), data); \
-	DWC_WRITE_REG32(&(((uint32_t*)container->regs->_reg)[num]), data); \
+		  &(((uint32_t *)container->regs->_reg)[num]), data); \
+	DWC_WRITE_REG32(&(((uint32_t *)container->regs->_reg)[num]), data); \
 }
 
-#define dwc_define_read_write_reg(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg(_container_type *container) { \
+#define dwc_define_read_write_reg(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg(_container_type *container) \
+{ \
 	return DWC_READ_REG32(&container->regs->_reg); \
 } \
-static inline void dwc_write_##_reg(_container_type *container, uint32_t data) { \
+static inline void dwc_write_##_reg(_container_type *container, uint32_t data) \
+{ \
 	DWC_DEBUG("WRITING %11s: %p: %08x", #_reg, &container->regs->_reg, data); \
 	DWC_WRITE_REG32(&container->regs->_reg, data); \
 }
 
 # else	/* DWC_DEBUG_REGS */
 
-#define dwc_define_read_write_reg_n(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg##_n(_container_type *container, int num) { \
+#define dwc_define_read_write_reg_n(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg##_n(_container_type *container, int num) \
+{ \
 	return DWC_READ_REG32(&container->regs->_reg[num]); \
 } \
-static inline void dwc_write_##_reg##_n(_container_type *container, int num, uint32_t data) { \
-	DWC_WRITE_REG32(&(((uint32_t*)container->regs->_reg)[num]), data); \
+static inline void dwc_write_##_reg##_n(_container_type *container, int num, uint32_t data) \
+{ \
+	DWC_WRITE_REG32(&(((uint32_t *)container->regs->_reg)[num]), data); \
 }
 
-#define dwc_define_read_write_reg(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg(_container_type *container) { \
+#define dwc_define_read_write_reg(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg(_container_type *container) \
+{ \
 	return DWC_READ_REG32(&container->regs->_reg); \
 } \
-static inline void dwc_write_##_reg(_container_type *container, uint32_t data) { \
+static inline void dwc_write_##_reg(_container_type *container, uint32_t data) \
+{ \
 	DWC_WRITE_REG32(&container->regs->_reg, data); \
 }
 
@@ -473,40 +484,48 @@ static inline void dwc_write_##_reg(_container_type *container, uint32_t data) {
 
 # ifdef DWC_DEBUG_REGS
 
-#define dwc_define_read_write_reg_n(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg##_n(void *io_ctx, _container_type *container, int num) { \
+#define dwc_define_read_write_reg_n(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg##_n(void *io_ctx, _container_type *container, int num) \
+{ \
 	return DWC_READ_REG32(io_ctx, &container->regs->_reg[num]); \
 } \
-static inline void dwc_write_##_reg##_n(void *io_ctx, _container_type *container, int num, uint32_t data) { \
+static inline void dwc_write_##_reg##_n(void *io_ctx, _container_type *container, int num, uint32_t data) \
+{ \
 	DWC_DEBUG("WRITING %8s[%d]: %p: %08x", #_reg, num, \
-		  &(((uint32_t*)container->regs->_reg)[num]), data); \
-	DWC_WRITE_REG32(io_ctx, &(((uint32_t*)container->regs->_reg)[num]), data); \
+		  &(((uint32_t *)container->regs->_reg)[num]), data); \
+	DWC_WRITE_REG32(io_ctx, &(((uint32_t *)container->regs->_reg)[num]), data); \
 }
 
-#define dwc_define_read_write_reg(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg(void *io_ctx, _container_type *container) { \
+#define dwc_define_read_write_reg(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg(void *io_ctx, _container_type *container) \
+{ \
 	return DWC_READ_REG32(io_ctx, &container->regs->_reg); \
 } \
-static inline void dwc_write_##_reg(void *io_ctx, _container_type *container, uint32_t data) { \
+static inline void dwc_write_##_reg(void *io_ctx, _container_type *container, uint32_t data) \
+{ \
 	DWC_DEBUG("WRITING %11s: %p: %08x", #_reg, &container->regs->_reg, data); \
 	DWC_WRITE_REG32(io_ctx, &container->regs->_reg, data); \
 }
 
 # else	/* DWC_DEBUG_REGS */
 
-#define dwc_define_read_write_reg_n(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg##_n(void *io_ctx, _container_type *container, int num) { \
+#define dwc_define_read_write_reg_n(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg##_n(void *io_ctx, _container_type *container, int num) \
+{ \
 	return DWC_READ_REG32(io_ctx, &container->regs->_reg[num]); \
 } \
-static inline void dwc_write_##_reg##_n(void *io_ctx, _container_type *container, int num, uint32_t data) { \
-	DWC_WRITE_REG32(io_ctx, &(((uint32_t*)container->regs->_reg)[num]), data); \
+static inline void dwc_write_##_reg##_n(void *io_ctx, _container_type *container, int num, uint32_t data) \
+{ \
+	DWC_WRITE_REG32(io_ctx, &(((uint32_t *)container->regs->_reg)[num]), data); \
 }
 
-#define dwc_define_read_write_reg(_reg,_container_type) \
-static inline uint32_t dwc_read_##_reg(void *io_ctx, _container_type *container) { \
+#define dwc_define_read_write_reg(_reg, _container_type) \
+static inline uint32_t dwc_read_##_reg(void *io_ctx, _container_type *container) \
+{ \
 	return DWC_READ_REG32(io_ctx, &container->regs->_reg); \
 } \
-static inline void dwc_write_##_reg(void *io_ctx, _container_type *container, uint32_t data) { \
+static inline void dwc_write_##_reg(void *io_ctx, _container_type *container, uint32_t data) \
+{ \
 	DWC_WRITE_REG32(io_ctx, &container->regs->_reg, data); \
 }
 
@@ -654,9 +673,9 @@ extern void __DWC_FREE(void *mem_ctx, void *addr);
 #define DWC_FREE(_addr_) __DWC_FREE(NULL, _addr_)
 
 # ifdef DWC_LINUX
-#define DWC_DMA_ALLOC(_size_,_dma_) __DWC_DMA_ALLOC(NULL, _size_, _dma_)
-#define DWC_DMA_ALLOC_ATOMIC(_size_,_dma_) __DWC_DMA_ALLOC_ATOMIC(NULL, _size_,_dma_)
-#define DWC_DMA_FREE(_size_,_virt_,_dma_) __DWC_DMA_FREE(NULL, _size_, _virt_, _dma_)
+#define DWC_DMA_ALLOC(_size_, _dma_) __DWC_DMA_ALLOC(NULL, _size_, _dma_)
+#define DWC_DMA_ALLOC_ATOMIC(_size_, _dma_) __DWC_DMA_ALLOC_ATOMIC(NULL, _size_, _dma_)
+#define DWC_DMA_FREE(_size_, _virt_, _dma_) __DWC_DMA_FREE(NULL, _size_, _virt_, _dma_)
 # endif
 
 # if defined(DWC_FREEBSD) || defined(DWC_NETBSD)
@@ -671,7 +690,7 @@ extern void *dwc_alloc_atomic_debug(void *mem_ctx, uint32_t size, char const *fu
 extern void dwc_free_debug(void *mem_ctx, void *addr, char const *func, int line);
 extern void *dwc_dma_alloc_debug(void *dma_ctx, uint32_t size, dwc_dma_t *dma_addr,
 				 char const *func, int line);
-extern void *dwc_dma_alloc_atomic_debug(void *dma_ctx, uint32_t size, dwc_dma_t *dma_addr, 
+extern void *dwc_dma_alloc_atomic_debug(void *dma_ctx, uint32_t size, dwc_dma_t *dma_addr,
 				char const *func, int line);
 extern void dwc_dma_free_debug(void *dma_ctx, uint32_t size, void *virt_addr,
 			       dwc_dma_t dma_addr, char const *func, int line);
@@ -686,34 +705,34 @@ extern void dwc_memory_debug_report(void);
 #define DWC_FREE(_addr_) dwc_free_debug(NULL, _addr_, __func__, __LINE__)
 
 # ifdef DWC_LINUX
-#define DWC_DMA_ALLOC(_size_,_dma_) dwc_dma_alloc_debug(NULL, _size_, \
+#define DWC_DMA_ALLOC(_size_, _dma_) dwc_dma_alloc_debug(NULL, _size_, \
 						_dma_, __func__, __LINE__)
-#define DWC_DMA_ALLOC_ATOMIC(_size_,_dma_) dwc_dma_alloc_atomic_debug(NULL, _size_, \
+#define DWC_DMA_ALLOC_ATOMIC(_size_, _dma_) dwc_dma_alloc_atomic_debug(NULL, _size_, \
 						_dma_, __func__, __LINE__)
-#define DWC_DMA_FREE(_size_,_virt_,_dma_) dwc_dma_free_debug(NULL, _size_, \
+#define DWC_DMA_FREE(_size_, _virt_, _dma_) dwc_dma_free_debug(NULL, _size_, \
 						_virt_, _dma_, __func__, __LINE__)
 # endif
 
 # if defined(DWC_FREEBSD) || defined(DWC_NETBSD)
-#define DWC_DMA_ALLOC(_ctx_,_size_,_dma_) dwc_dma_alloc_debug(_ctx_, _size_, \
+#define DWC_DMA_ALLOC(_ctx_, _size_, _dma_) dwc_dma_alloc_debug(_ctx_, _size_, \
 						_dma_, __func__, __LINE__)
-#define DWC_DMA_FREE(_ctx_,_size_,_virt_,_dma_) dwc_dma_free_debug(_ctx_, _size_, \
+#define DWC_DMA_FREE(_ctx_, _size_, _virt_, _dma_) dwc_dma_free_debug(_ctx_, _size_, \
 						 _virt_, _dma_, __func__, __LINE__)
 # endif
 
 #endif /* DWC_DEBUG_MEMORY */
 
-#define dwc_alloc(_ctx_,_size_) DWC_ALLOC(_size_)
-#define dwc_alloc_atomic(_ctx_,_size_) DWC_ALLOC_ATOMIC(_size_)
-#define dwc_free(_ctx_,_addr_) DWC_FREE(_addr_)
+#define dwc_alloc(_ctx_, _size_) DWC_ALLOC(_size_)
+#define dwc_alloc_atomic(_ctx_, _size_) DWC_ALLOC_ATOMIC(_size_)
+#define dwc_free(_ctx_, _addr_) DWC_FREE(_addr_)
 
 #ifdef DWC_LINUX
 /* Linux doesn't need any extra parameters for DMA buffer allocation, so we
  * just throw away the DMA context parameter.
  */
-#define dwc_dma_alloc(_ctx_,_size_,_dma_) DWC_DMA_ALLOC(_size_, _dma_)
-#define dwc_dma_alloc_atomic(_ctx_,_size_,_dma_) DWC_DMA_ALLOC_ATOMIC(_size_, _dma_)
-#define dwc_dma_free(_ctx_,_size_,_virt_,_dma_) DWC_DMA_FREE(_size_, _virt_, _dma_)
+#define dwc_dma_alloc(_ctx_, _size_, _dma_) DWC_DMA_ALLOC(_size_, _dma_)
+#define dwc_dma_alloc_atomic(_ctx_, _size_, _dma_) DWC_DMA_ALLOC_ATOMIC(_size_, _dma_)
+#define dwc_dma_free(_ctx_, _size_, _virt_, _dma_) DWC_DMA_FREE(_size_, _virt_, _dma_)
 #endif
 
 #if defined(DWC_FREEBSD) || defined(DWC_NETBSD)
@@ -764,7 +783,7 @@ extern char *DWC_STRCPY(char *to, const char *from);
  * calling a predefined strdup.  Otherwise the memory allocated by this routine
  * will not be seen by the debugging routines. */
 extern char *DWC_STRDUP(char const *str);
-#define dwc_strdup(_ctx_,_str_) DWC_STRDUP(_str_)
+#define dwc_strdup(_ctx_, _str_) DWC_STRDUP(_str_)
 
 /** NOT an atoi() clone.  Read the description carefully.  Returns an integer
  * converted from the string str in base 10 unless the string begins with a "0x"
@@ -857,7 +876,7 @@ typedef int (*dwc_thread_function_t)(void *data);
 /** Create a thread and start it running the thread_function.  Returns a handle
  * to the thread */
 extern dwc_thread_t *DWC_THREAD_RUN(dwc_thread_function_t func, char *name, void *data);
-#define dwc_thread_run(_ctx_,_func_,_name_,_data_) DWC_THREAD_RUN(_func_, _name_, _data_)
+#define dwc_thread_run(_ctx_, _func_, _name_, _data_) DWC_THREAD_RUN(_func_, _name_, _data_)
 
 /** Stops a thread.  Return the value returned by the thread.  Or will return
  * DWC_ABORT if the thread never started. */
@@ -899,7 +918,7 @@ typedef void (*dwc_work_callback_t)(void *data);
 
 /** Allocate a workq */
 extern dwc_workq_t *DWC_WORKQ_ALLOC(char *name);
-#define dwc_workq_alloc(_ctx_,_name_) DWC_WORKQ_ALLOC(_name_)
+#define dwc_workq_alloc(_ctx_, _name_) DWC_WORKQ_ALLOC(_name_)
 
 /** Free a workq.  All work must be completed before being freed. */
 extern void DWC_WORKQ_FREE(dwc_workq_t *workq);
@@ -950,7 +969,7 @@ typedef void (*dwc_tasklet_callback_t)(void *data);
 
 /** Allocates a tasklet */
 extern dwc_tasklet_t *DWC_TASK_ALLOC(char *name, dwc_tasklet_callback_t cb, void *data);
-#define dwc_task_alloc(_ctx_,_name_,_cb_,_data_) DWC_TASK_ALLOC(_name_, _cb_, _data_)
+#define dwc_task_alloc(_ctx_, _name_, _cb_, _data_) DWC_TASK_ALLOC(_name_, _cb_, _data_)
 
 /** Frees a tasklet */
 extern void DWC_TASK_FREE(dwc_tasklet_t *task);
@@ -975,7 +994,7 @@ typedef void (*dwc_timer_callback_t)(void *data);
 
 /** Allocates a timer */
 extern dwc_timer_t *DWC_TIMER_ALLOC(char *name, dwc_timer_callback_t cb, void *data);
-#define dwc_timer_alloc(_ctx_,_name_,_cb_,_data_) DWC_TIMER_ALLOC(_name_,_cb_,_data_)
+#define dwc_timer_alloc(_ctx_, _name_, _cb_, _data_) DWC_TIMER_ALLOC(_name_, _cb_, _data_)
 
 /** Frees a timer */
 extern void DWC_TIMER_FREE(dwc_timer_t *timer);
@@ -1022,7 +1041,7 @@ extern dwc_spinlock_t *DWC_SPINLOCK_ALLOC(void);
 
 /** Frees an initialized lock variable. */
 extern void DWC_SPINLOCK_FREE(dwc_spinlock_t *lock);
-#define dwc_spinlock_free(_ctx_,_lock_) DWC_SPINLOCK_FREE(_lock_)
+#define dwc_spinlock_free(_ctx_, _lock_) DWC_SPINLOCK_FREE(_lock_)
 
 /** Disables interrupts and blocks until it acquires the lock.
  *
@@ -1086,11 +1105,11 @@ extern dwc_mutex_t *DWC_MUTEX_ALLOC(void);
 #define DWC_MUTEX_FREE(__mutexp) do { \
 	mutex_destroy((struct mutex *)__mutexp); \
 	DWC_FREE(__mutexp); \
-} while(0)
+} while (0)
 #else
 /** Free a mutex */
 extern void DWC_MUTEX_FREE(dwc_mutex_t *mutex);
-#define dwc_mutex_free(_ctx_,_mutex_) DWC_MUTEX_FREE(_mutex_)
+#define dwc_mutex_free(_ctx_, _mutex_) DWC_MUTEX_FREE(_mutex_)
 #endif
 
 /** Lock a mutex */
diff --git a/drivers/usb/dwc_otg_310/common_port/usb.h b/drivers/usb/dwc_otg_310/common_port/usb.h
index 27bda82dac2e..31e2dd77a9ee 100755
--- a/drivers/usb/dwc_otg_310/common_port/usb.h
+++ b/drivers/usb/dwc_otg_310/common_port/usb.h
@@ -55,16 +55,16 @@ typedef u_int8_t uByte;
 typedef u_int8_t uWord[2];
 typedef u_int8_t uDWord[4];
 
-#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
+#define USETW2(w, h, l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
 #define UCONSTW(x)	{ (x) & 0xff, ((x) >> 8) & 0xff }
 #define UCONSTDW(x)	{ (x) & 0xff, ((x) >> 8) & 0xff, \
 			  ((x) >> 16) & 0xff, ((x) >> 24) & 0xff }
 
 #if 1
 #define UGETW(w) ((w)[0] | ((w)[1] << 8))
-#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
+#define USETW(w, v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
 #define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
-#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
+#define USETDW(w, v) ((w)[0] = (u_int8_t)(v), \
 		     (w)[1] = (u_int8_t)((v) >> 8), \
 		     (w)[2] = (u_int8_t)((v) >> 16), \
 		     (w)[3] = (u_int8_t)((v) >> 24))
@@ -74,22 +74,22 @@ typedef u_int8_t uDWord[4];
  * (e.g. i386) these macros can be replaced by the following.
  */
 #define UGETW(w) (*(u_int16_t *)(w))
-#define USETW(w,v) (*(u_int16_t *)(w) = (v))
+#define USETW(w, v) (*(u_int16_t *)(w) = (v))
 #define UGETDW(w) (*(u_int32_t *)(w))
-#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
+#define USETDW(w, v) (*(u_int32_t *)(w) = (v))
 #endif
 
 /*
  * Macros for accessing UAS IU fields, which are big-endian
  */
-#define IUSETW2(w,h,l) ((w)[0] = (u_int8_t)(h), (w)[1] = (u_int8_t)(l))
+#define IUSETW2(w, h, l) ((w)[0] = (u_int8_t)(h), (w)[1] = (u_int8_t)(l))
 #define IUCONSTW(x)	{ ((x) >> 8) & 0xff, (x) & 0xff }
 #define IUCONSTDW(x)	{ ((x) >> 24) & 0xff, ((x) >> 16) & 0xff, \
 			((x) >> 8) & 0xff, (x) & 0xff }
 #define IUGETW(w) (((w)[0] << 8) | (w)[1])
-#define IUSETW(w,v) ((w)[0] = (u_int8_t)((v) >> 8), (w)[1] = (u_int8_t)(v))
+#define IUSETW(w, v) ((w)[0] = (u_int8_t)((v) >> 8), (w)[1] = (u_int8_t)(v))
 #define IUGETDW(w) (((w)[0] << 24) | ((w)[1] << 16) | ((w)[2] << 8) | (w)[3])
-#define IUSETDW(w,v) ((w)[0] = (u_int8_t)((v) >> 24), \
+#define IUSETDW(w, v) ((w)[0] = (u_int8_t)((v) >> 24), \
 		      (w)[1] = (u_int8_t)((v) >> 16), \
 		      (w)[2] = (u_int8_t)((v) >> 8), \
 		      (w)[3] = (u_int8_t)(v))
@@ -310,7 +310,7 @@ typedef struct {
 	uByte		bDescriptorType;
 	uByte		bEndpointAddress;
 #define UE_GET_DIR(a)	((a) & 0x80)
-#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
+#define UE_SET_DIR(a, d) ((a) | (((d)&1) << 7))
 #define UE_DIR_IN	0x80
 #define UE_DIR_OUT	0x00
 #define UE_ADDR		0x0f
@@ -774,9 +774,9 @@ typedef struct wusb_hndshk_data {
 
 /* WUSB Connection Context */
 typedef struct wusb_conn_context {
-	uByte CHID [16];
-	uByte CDID [16];
-	uByte CK [16];
+	uByte CHID[16];
+	uByte CDID[16];
+	uByte CK[16];
 } UPACKED wusb_conn_context_t;
 
 /* WUSB Security Descriptor */
diff --git a/drivers/usb/dwc_otg_310/dummy_audio.c b/drivers/usb/dwc_otg_310/dummy_audio.c
index b912086a7773..e45d92cfcdf5 100755
--- a/drivers/usb/dwc_otg_310/dummy_audio.c
+++ b/drivers/usb/dwc_otg_310/dummy_audio.c
@@ -35,7 +35,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 /*
  * Gadget Zero only needs two bulk endpoints, and is an example of how you
  * can write a hardware-agnostic gadget driver running inside a USB device.
@@ -87,46 +86,46 @@
 #include <linux/usb_ch9.h>
 #include <linux/usb_gadget.h>
 
-
 /*-------------------------------------------------------------------------*/
 /*-------------------------------------------------------------------------*/
 
-
 static int utf8_to_utf16le(const char *s, u16 *cp, unsigned len)
 {
-	int	count = 0;
-	u8	c;
-	u16	uchar;
+	int count = 0;
+	u8 c;
+	u16 uchar;
 
 	/* this insists on correct encodings, though not minimal ones.
 	 * BUT it currently rejects legit 4-byte UTF-8 code points,
 	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
 	 */
-	while (len != 0 && (c = (u8) *s++) != 0) {
+	while (len != 0 && (c = (u8)*s++) != 0) {
 		if (unlikely(c & 0x80)) {
-			// 2-byte sequence:
-			// 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
+			/* 2-byte sequence:
+			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
+			 */
 			if ((c & 0xe0) == 0xc0) {
 				uchar = (c & 0x1f) << 6;
 
-				c = (u8) *s++;
+				c = (u8)*s++;
 				if ((c & 0xc0) != 0xc0)
 					goto fail;
 				c &= 0x3f;
 				uchar |= c;
 
-			// 3-byte sequence (most CJKV characters):
-			// zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
+				/* 3-byte sequence (most CJKV characters):
+				 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
+				 */
 			} else if ((c & 0xf0) == 0xe0) {
 				uchar = (c & 0x0f) << 12;
 
-				c = (u8) *s++;
+				c = (u8)*s++;
 				if ((c & 0xc0) != 0xc0)
 					goto fail;
 				c &= 0x3f;
 				uchar |= c << 6;
 
-				c = (u8) *s++;
+				c = (u8)*s++;
 				if ((c & 0xc0) != 0xc0)
 					goto fail;
 				c &= 0x3f;
@@ -136,17 +135,19 @@ static int utf8_to_utf16le(const char *s, u16 *cp, unsigned len)
 				if (0xd800 <= uchar && uchar <= 0xdfff)
 					goto fail;
 
-			// 4-byte sequence (surrogate pairs, currently rare):
-			// 11101110wwwwzzzzyy + 110111yyyyxxxxxx
-			//     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
-			// (uuuuu = wwww + 1)
-			// FIXME accept the surrogate code points (only)
+				/* 4-byte sequence
+				 * (surrogate pairs, currently rare):
+				 * 11101110wwwwzzzzyy + 110111yyyyxxxxxx
+				 *     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
+				 * (uuuuu = wwww + 1)
+				 * FIXME accept the surrogate code points (only)
+				 */
 
 			} else
 				goto fail;
 		} else
 			uchar = c;
-		put_unaligned (cpu_to_le16 (uchar), cp++);
+		put_unaligned(cpu_to_le16(uchar), cp++);
 		count++;
 		len--;
 	}
@@ -155,9 +156,8 @@ static int utf8_to_utf16le(const char *s, u16 *cp, unsigned len)
 	return -1;
 }
 
-
 /**
- * usb_gadget_get_string - fill out a string descriptor 
+ * usb_gadget_get_string - fill out a string descriptor
  * @table: of c strings encoded using UTF-8
  * @id: string id, from low byte of wValue in get string descriptor
  * @buf: at least 256 bytes
@@ -173,18 +173,17 @@ static int utf8_to_utf16le(const char *s, u16 *cp, unsigned len)
  * the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
  * characters (which are also widely used in C strings).
  */
-int
-usb_gadget_get_string (struct usb_gadget_strings *table, int id, u8 *buf)
+int usb_gadget_get_string(struct usb_gadget_strings *table, int id, u8 *buf)
 {
-	struct usb_string	*s;
-	int			len;
+	struct usb_string *s;
+	int len;
 
 	/* descriptor 0 has the language id */
 	if (id == 0) {
-		buf [0] = 4;
-		buf [1] = USB_DT_STRING;
-		buf [2] = (u8) table->language;
-		buf [3] = (u8) (table->language >> 8);
+		buf[0] = 4;
+		buf[1] = USB_DT_STRING;
+		buf[2] = (u8) table->language;
+		buf[3] = (u8) (table->language >> 8);
 		return 4;
 	}
 	for (s = table->strings; s && s->s; s++)
@@ -196,21 +195,19 @@ usb_gadget_get_string (struct usb_gadget_strings *table, int id, u8 *buf)
 		return -EINVAL;
 
 	/* string descriptors have length, tag, then UTF16-LE text */
-	len = min ((size_t) 126, strlen (s->s));
-	memset (buf + 2, 0, 2 * len);	/* zero all the bytes */
+	len = min((size_t) 126, strlen(s->s));
+	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
 	len = utf8_to_utf16le(s->s, (u16 *)&buf[2], len);
 	if (len < 0)
 		return -EINVAL;
-	buf [0] = (len + 1) * 2;
-	buf [1] = USB_DT_STRING;
-	return buf [0];
+	buf[0] = (len + 1) * 2;
+	buf[1] = USB_DT_STRING;
+	return buf[0];
 }
 
-
 /*-------------------------------------------------------------------------*/
 /*-------------------------------------------------------------------------*/
 
-
 /**
  * usb_descriptor_fillbuf - fill buffer with descriptors
  * @buf: Buffer to be filled
@@ -225,16 +222,16 @@ usb_gadget_get_string (struct usb_gadget_strings *table, int id, u8 *buf)
  */
 int
 usb_descriptor_fillbuf(void *buf, unsigned buflen,
-		const struct usb_descriptor_header **src)
+		       const struct usb_descriptor_header **src)
 {
-	u8	*dest = buf;
+	u8 *dest = buf;
 
 	if (!src)
 		return -EINVAL;
 
 	/* fill buffer from src[] until null descriptor ptr */
 	for (; 0 != *src; src++) {
-		unsigned		len = (*src)->bLength;
+		unsigned len = (*src)->bLength;
 
 		if (len > buflen)
 			return -EINVAL;
@@ -242,10 +239,9 @@ usb_descriptor_fillbuf(void *buf, unsigned buflen,
 		buflen -= len;
 		dest += len;
 	}
-	return dest - (u8 *)buf;
+	return dest - (u8 *) buf;
 }
 
-
 /**
  * usb_gadget_config_buf - builts a complete configuration descriptor
  * @config: Header for the descriptor, including characteristics such
@@ -266,24 +262,22 @@ usb_descriptor_fillbuf(void *buf, unsigned buflen,
  * in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
  * resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.
  */
-int usb_gadget_config_buf(
-	const struct usb_config_descriptor	*config,
-	void					*buf,
-	unsigned				length,
-	const struct usb_descriptor_header	**desc
-)
+int usb_gadget_config_buf(const struct usb_config_descriptor *config,
+			  void *buf,
+			  unsigned length,
+			  const struct usb_descriptor_header **desc)
 {
-	struct usb_config_descriptor		*cp = buf;
-	int					len;
+	struct usb_config_descriptor *cp = buf;
+	int len;
 
 	/* config descriptor first */
 	if (length < USB_DT_CONFIG_SIZE || !desc)
 		return -EINVAL;
-	*cp = *config; 
+	*cp = *config;
 
 	/* then interface/endpoint/class/vendor/... */
-	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8*)buf,
-			length - USB_DT_CONFIG_SIZE, desc);
+	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *) buf,
+				     length - USB_DT_CONFIG_SIZE, desc);
 	if (len < 0)
 		return len;
 	len += USB_DT_CONFIG_SIZE;
@@ -301,7 +295,6 @@ int usb_gadget_config_buf(
 /*-------------------------------------------------------------------------*/
 /*-------------------------------------------------------------------------*/
 
-
 #define RBUF_LEN (1024*1024)
 static int rbuf_start;
 static int rbuf_len;
@@ -311,11 +304,11 @@ static __u8 rbuf[RBUF_LEN];
 
 #define DRIVER_VERSION		"St Patrick's Day 2004"
 
-static const char shortname [] = "zero";
-static const char longname [] = "YAMAHA YST-MS35D USB Speaker  ";
+static const char shortname[] = "zero";
+static const char longname[] = "YAMAHA YST-MS35D USB Speaker  ";
 
-static const char source_sink [] = "source and sink data";
-static const char loopback [] = "loop input to output";
+static const char source_sink[] = "source and sink data";
+static const char loopback[] = "loop input to output";
 
 /*-------------------------------------------------------------------------*/
 
@@ -326,8 +319,8 @@ static const char loopback [] = "loop input to output";
  * this version autoconfigures as much as possible,
  * which is reasonable for most "bulk-only" drivers.
  */
-static const char *EP_IN_NAME;		/* source */
-static const char *EP_OUT_NAME;		/* sink */
+static const char *EP_IN_NAME;	/* source */
+static const char *EP_OUT_NAME;	/* sink */
 
 /*-------------------------------------------------------------------------*/
 
@@ -335,62 +328,62 @@ static const char *EP_OUT_NAME;		/* sink */
 #define USB_BUFSIZ	512
 
 struct zero_dev {
-	spinlock_t		lock;
-	struct usb_gadget	*gadget;
-	struct usb_request	*req;		/* for control responses */
+	spinlock_t lock;
+	struct usb_gadget *gadget;
+	struct usb_request *req;	/* for control responses */
 
 	/* when configured, we have one of two configs:
 	 * - source data (in to host) and sink it (out from host)
 	 * - or loop it back (out from host back in to host)
 	 */
-	u8			config;
-	struct usb_ep		*in_ep, *out_ep;
+	u8 config;
+	struct usb_ep *in_ep, *out_ep;
 
 	/* autoresume timer */
-	struct timer_list	resume;
+	struct timer_list resume;
 };
 
-#define xprintk(d,level,fmt,args...) \
-	dev_printk(level , &(d)->gadget->dev , fmt , ## args)
+#define xprintk(d, level, fmt, args...) \
+	dev_printk(level, &(d)->gadget->dev, fmt, ## args)
 
 #ifdef DEBUG
-#define DBG(dev,fmt,args...) \
-	xprintk(dev , KERN_DEBUG , fmt , ## args)
+#define DBG(dev, fmt, args...) \
+	xprintk(dev, KERN_DEBUG, fmt, ## args)
 #else
-#define DBG(dev,fmt,args...) \
+#define DBG(dev, fmt, args...) \
 	do { } while (0)
 #endif /* DEBUG */
 
 #ifdef VERBOSE
 #define VDBG	DBG
 #else
-#define VDBG(dev,fmt,args...) \
+#define VDBG(dev, fmt, args...) \
 	do { } while (0)
 #endif /* VERBOSE */
 
-#define ERROR(dev,fmt,args...) \
-	xprintk(dev , KERN_ERR , fmt , ## args)
-#define WARN(dev,fmt,args...) \
-	xprintk(dev , KERN_WARNING , fmt , ## args)
-#define INFO(dev,fmt,args...) \
-	xprintk(dev , KERN_INFO , fmt , ## args)
+#define ERROR(dev, fmt, args...) \
+	xprintk(dev, KERN_ERR, fmt, ## args)
+#define WARN(dev, fmt, args...) \
+	xprintk(dev, KERN_WARNING, fmt, ## args)
+#define INFO(dev, fmt, args...) \
+	xprintk(dev, KERN_INFO, fmt, ## args)
 
 /*-------------------------------------------------------------------------*/
 
 static unsigned buflen = 4096;
 static unsigned qlen = 32;
-static unsigned pattern = 0;
+static unsigned pattern;
 
-module_param (buflen, uint, S_IRUGO|S_IWUSR);
-module_param (qlen, uint, S_IRUGO|S_IWUSR);
-module_param (pattern, uint, S_IRUGO|S_IWUSR);
+module_param(buflen, uint, S_IRUGO | S_IWUSR);
+module_param(qlen, uint, S_IRUGO | S_IWUSR);
+module_param(pattern, uint, S_IRUGO | S_IWUSR);
 
 /*
  * if it's nonzero, autoresume says how many seconds to wait
  * before trying to wake up the host after suspend.
  */
-static unsigned autoresume = 0;
-module_param (autoresume, uint, 0);
+static unsigned autoresume;
+module_param(autoresume, uint, 0);
 
 /*
  * Normally the "loopback" configuration is second (index 1) so
@@ -398,9 +391,9 @@ module_param (autoresume, uint, 0);
  * work better with hosts where config changes are problematic.
  * Or controllers (like superh) that only support one config.
  */
-static int loopdefault = 0;
+static int loopdefault0;
 
-module_param (loopdefault, bool, S_IRUGO|S_IWUSR);
+module_param(loopdefault, bool, S_IRUGO | S_IWUSR);
 
 /*-------------------------------------------------------------------------*/
 
@@ -410,10 +403,10 @@ module_param (loopdefault, bool, S_IRUGO|S_IWUSR);
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
 #ifndef	CONFIG_USB_ZERO_HNPTEST
-#define DRIVER_VENDOR_NUM	0x0525		/* NetChip */
-#define DRIVER_PRODUCT_NUM	0xa4a0		/* Linux-USB "Gadget Zero" */
+#define DRIVER_VENDOR_NUM	0x0525	/* NetChip */
+#define DRIVER_PRODUCT_NUM	0xa4a0	/* Linux-USB "Gadget Zero" */
 #else
-#define DRIVER_VENDOR_NUM	0x1a0a		/* OTG test device IDs */
+#define DRIVER_VENDOR_NUM	0x1a0a	/* OTG test device IDs */
 #define DRIVER_PRODUCT_NUM	0xbadd
 #endif
 
@@ -462,42 +455,41 @@ device_desc = {
 */
 static struct usb_device_descriptor
 device_desc = {
-	.bLength =		sizeof device_desc,
-	.bDescriptorType =	USB_DT_DEVICE,
-	.bcdUSB =		__constant_cpu_to_le16 (0x0100),
-	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
-	.bDeviceSubClass =      0,
-	.bDeviceProtocol =      0,
-	.bMaxPacketSize0 =      64,
-	.bcdDevice =            __constant_cpu_to_le16 (0x0100),
-	.idVendor =		__constant_cpu_to_le16 (0x0499),
-	.idProduct =		__constant_cpu_to_le16 (0x3002),
-	.iManufacturer =	STRING_MANUFACTURER,
-	.iProduct =		STRING_PRODUCT,
-	.iSerialNumber =	STRING_SERIAL,
-	.bNumConfigurations =	1,
+	.bLength = sizeof(device_desc),
+	.bDescriptorType = USB_DT_DEVICE,
+	.bcdUSB = __constant_cpu_to_le16(0x0100),
+	.bDeviceClass = USB_CLASS_PER_INTERFACE,
+	.bDeviceSubClass = 0,
+	.bDeviceProtocol = 0,
+	.bMaxPacketSize0 = 64,
+	.bcdDevice = __constant_cpu_to_le16(0x0100),
+	.idVendor = __constant_cpu_to_le16(0x0499),
+	.idProduct = __constant_cpu_to_le16(0x3002),
+	.iManufacturer = STRING_MANUFACTURER,
+	.iProduct = STRING_PRODUCT,
+	.iSerialNumber = STRING_SERIAL,
+	.bNumConfigurations = 1,
 };
 
 static struct usb_config_descriptor
 z_config = {
-	.bLength =		sizeof z_config,
-	.bDescriptorType =	USB_DT_CONFIG,
+	.bLength = sizeof(z_config),
+	.bDescriptorType = USB_DT_CONFIG,
 
 	/* compute wTotalLength on the fly */
-	.bNumInterfaces =	2,
-	.bConfigurationValue =	1,
-	.iConfiguration =	0,
-	.bmAttributes =		0x40,
-	.bMaxPower =		0,	/* self-powered */
+	.bNumInterfaces = 2,
+	.bConfigurationValue = 1,
+	.iConfiguration = 0,
+	.bmAttributes = 0x40,
+	.bMaxPower = 0,		/* self-powered */
 };
 
-
 static struct usb_otg_descriptor
 otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
+	.bLength = sizeof(otg_descriptor),
+	.bDescriptorType = USB_DT_OTG,
 
-	.bmAttributes =		USB_OTG_SRP,
+	.bmAttributes = USB_OTG_SRP,
 };
 
 /* one interface in each configuration */
@@ -514,44 +506,43 @@ otg_descriptor = {
 
 static struct usb_qualifier_descriptor
 dev_qualifier = {
-	.bLength =		sizeof dev_qualifier,
-	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
+	.bLength = sizeof(dev_qualifier),
+	.bDescriptorType = USB_DT_DEVICE_QUALIFIER,
 
-	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
-	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
+	.bcdUSB = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass = USB_CLASS_VENDOR_SPEC,
 
-	.bNumConfigurations =	2,
+	.bNumConfigurations = 2,
 };
 
-
 struct usb_cs_as_general_descriptor {
-	__u8  bLength;
-	__u8  bDescriptorType;
+	__u8 bLength;
+	__u8 bDescriptorType;
 
-	__u8  bDescriptorSubType;
-	__u8  bTerminalLink;
-	__u8  bDelay;
-	__u16  wFormatTag;
-} __attribute__ ((packed));
+	__u8 bDescriptorSubType;
+	__u8 bTerminalLink;
+	__u8 bDelay;
+	__u16 wFormatTag;
+} __attribute__((packed));
 
 struct usb_cs_as_format_descriptor {
-	__u8  bLength;
-	__u8  bDescriptorType;
-
-	__u8  bDescriptorSubType;
-	__u8  bFormatType;
-	__u8  bNrChannels;
-	__u8  bSubframeSize;
-	__u8  bBitResolution;
-	__u8  bSamfreqType;
-	__u8  tLowerSamFreq[3];
-	__u8  tUpperSamFreq[3];
-} __attribute__ ((packed));
+	__u8 bLength;
+	__u8 bDescriptorType;
+
+	__u8 bDescriptorSubType;
+	__u8 bFormatType;
+	__u8 bNrChannels;
+	__u8 bSubframeSize;
+	__u8 bBitResolution;
+	__u8 bSamfreqType;
+	__u8 tLowerSamFreq[3];
+	__u8 tUpperSamFreq[3];
+} __attribute__((packed));
 
 static const struct usb_interface_descriptor
 z_audio_control_if_desc = {
-	.bLength =		sizeof z_audio_control_if_desc,
-	.bDescriptorType =	USB_DT_INTERFACE,
+	.bLength = sizeof(z_audio_control_if_desc),
+	.bDescriptorType = USB_DT_INTERFACE,
 	.bInterfaceNumber = 0,
 	.bAlternateSetting = 0,
 	.bNumEndpoints = 0,
@@ -563,8 +554,8 @@ z_audio_control_if_desc = {
 
 static const struct usb_interface_descriptor
 z_audio_if_desc = {
-	.bLength =		sizeof z_audio_if_desc,
-	.bDescriptorType =	USB_DT_INTERFACE,
+	.bLength = sizeof(z_audio_if_desc),
+	.bDescriptorType = USB_DT_INTERFACE,
 	.bInterfaceNumber = 1,
 	.bAlternateSetting = 0,
 	.bNumEndpoints = 0,
@@ -576,8 +567,8 @@ z_audio_if_desc = {
 
 static const struct usb_interface_descriptor
 z_audio_if_desc2 = {
-	.bLength =		sizeof z_audio_if_desc,
-	.bDescriptorType =	USB_DT_INTERFACE,
+	.bLength = sizeof(z_audio_if_desc),
+	.bDescriptorType = USB_DT_INTERFACE,
 	.bInterfaceNumber = 1,
 	.bAlternateSetting = 1,
 	.bNumEndpoints = 1,
@@ -591,19 +582,18 @@ static const struct usb_cs_as_general_descriptor
 z_audio_cs_as_if_desc = {
 	.bLength = 7,
 	.bDescriptorType = 0x24,
-	
+
 	.bDescriptorSubType = 0x01,
 	.bTerminalLink = 0x01,
 	.bDelay = 0x0,
-	.wFormatTag = __constant_cpu_to_le16 (0x0001)
+	.wFormatTag = __constant_cpu_to_le16(0x0001)
 };
 
-
-static const struct usb_cs_as_format_descriptor 
+static const struct usb_cs_as_format_descriptor
 z_audio_cs_as_format_desc = {
 	.bLength = 0xe,
 	.bDescriptorType = 0x24,
-	
+
 	.bDescriptorSubType = 2,
 	.bFormatType = 1,
 	.bNrChannels = 1,
@@ -614,7 +604,7 @@ z_audio_cs_as_format_desc = {
 	.tUpperSamFreq = {0xe2, 0xd6, 0x00},
 };
 
-static const struct usb_endpoint_descriptor 
+static const struct usb_endpoint_descriptor
 z_iso_ep = {
 	.bLength = 0x09,
 	.bDescriptorType = 0x05,
@@ -623,159 +613,178 @@ z_iso_ep = {
 	.wMaxPacketSize = 0x0038,
 	.bInterval = 0x01,
 	.bRefresh = 0x00,
-	.bSynchAddress = 0x00,	
+	.bSynchAddress = 0x00,
 };
 
-static char z_iso_ep2[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char z_iso_ep2[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
 
-// 9 bytes
-static char z_ac_interface_header_desc[] = 
-{ 0x09, 0x24, 0x01, 0x00, 0x01, 0x2b, 0x00, 0x01, 0x01 };
-
-// 12 bytes
-static char z_0[] = {0x0c, 0x24, 0x02, 0x01, 0x01, 0x01, 0x00, 0x02, 
-		     0x03, 0x00, 0x00, 0x00};
-// 13 bytes
-static char z_1[] = {0x0d, 0x24, 0x06, 0x02, 0x01, 0x02, 0x15, 0x00, 
-		     0x02, 0x00, 0x02, 0x00, 0x00};
-// 9 bytes
-static char z_2[] = {0x09, 0x24, 0x03, 0x03, 0x01, 0x03, 0x00, 0x02, 
-		     0x00};
+/* 9 bytes */
+static char z_ac_interface_header_desc[] = {
+	0x09, 0x24, 0x01, 0x00, 0x01, 0x2b, 0x00, 0x01, 0x01
+};
 
-static char za_0[] = {0x09, 0x04, 0x01, 0x02, 0x01, 0x01, 0x02, 0x00, 
-		      0x00};
+/* 12 bytes */
+static char z_0[] = { 0x0c, 0x24, 0x02, 0x01, 0x01, 0x01, 0x00, 0x02,
+	0x03, 0x00, 0x00, 0x00
+};
 
-static char za_1[] = {0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00};
+/* 13 bytes */
+static char z_1[] = { 0x0d, 0x24, 0x06, 0x02, 0x01, 0x02, 0x15, 0x00,
+	0x02, 0x00, 0x02, 0x00, 0x00
+};
 
-static char za_2[] = {0x0e, 0x24, 0x02, 0x01, 0x02, 0x01, 0x08, 0x00, 
-		      0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00};
+/* 9 bytes */
+static char z_2[] = { 0x09, 0x24, 0x03, 0x03, 0x01, 0x03, 0x00, 0x02,
+	0x00
+};
 
-static char za_3[] = {0x09, 0x05, 0x04, 0x09, 0x70, 0x00, 0x01, 0x00,
-		      0x00};
+static char za_0[] = { 0x09, 0x04, 0x01, 0x02, 0x01, 0x01, 0x02, 0x00,
+	0x00
+};
 
-static char za_4[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char za_1[] = { 0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00 };
 
-static char za_5[] = {0x09, 0x04, 0x01, 0x03, 0x01, 0x01, 0x02, 0x00,
-		      0x00};
+static char za_2[] = { 0x0e, 0x24, 0x02, 0x01, 0x02, 0x01, 0x08, 0x00,
+	0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00
+};
 
-static char za_6[] = {0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00};
+static char za_3[] = { 0x09, 0x05, 0x04, 0x09, 0x70, 0x00, 0x01, 0x00,
+	0x00
+};
 
-static char za_7[] = {0x0e, 0x24, 0x02, 0x01, 0x01, 0x02, 0x10, 0x00,
-		      0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00};
+static char za_4[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
 
-static char za_8[] = {0x09, 0x05, 0x04, 0x09, 0x70, 0x00, 0x01, 0x00,
-		      0x00};
+static char za_5[] = { 0x09, 0x04, 0x01, 0x03, 0x01, 0x01, 0x02, 0x00,
+	0x00
+};
 
-static char za_9[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char za_6[] = { 0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00 };
 
-static char za_10[] = {0x09, 0x04, 0x01, 0x04, 0x01, 0x01, 0x02, 0x00,
-		       0x00};
+static char za_7[] = { 0x0e, 0x24, 0x02, 0x01, 0x01, 0x02, 0x10, 0x00,
+	0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00
+};
 
-static char za_11[] = {0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00};
+static char za_8[] = { 0x09, 0x05, 0x04, 0x09, 0x70, 0x00, 0x01, 0x00,
+	0x00
+};
 
-static char za_12[] = {0x0e, 0x24, 0x02, 0x01, 0x02, 0x02, 0x10, 0x00,
-		       0x73, 0x13, 0x00, 0xe2, 0xd6, 0x00};
+static char za_9[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
 
-static char za_13[] = {0x09, 0x05, 0x04, 0x09, 0xe0, 0x00, 0x01, 0x00,
-		       0x00};
+static char za_10[] = { 0x09, 0x04, 0x01, 0x04, 0x01, 0x01, 0x02, 0x00,
+	0x00
+};
 
-static char za_14[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char za_11[] = { 0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00 };
 
-static char za_15[] = {0x09, 0x04, 0x01, 0x05, 0x01, 0x01, 0x02, 0x00, 
-		       0x00};
+static char za_12[] = { 0x0e, 0x24, 0x02, 0x01, 0x02, 0x02, 0x10, 0x00,
+	0x73, 0x13, 0x00, 0xe2, 0xd6, 0x00
+};
 
-static char za_16[] = {0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00};
+static char za_13[] = { 0x09, 0x05, 0x04, 0x09, 0xe0, 0x00, 0x01, 0x00,
+	0x00
+};
 
-static char za_17[] = {0x0e, 0x24, 0x02, 0x01, 0x01, 0x03, 0x14, 0x00, 
-		       0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00};
+static char za_14[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
 
-static char za_18[] = {0x09, 0x05, 0x04, 0x09, 0xa8, 0x00, 0x01, 0x00,
-		       0x00};
+static char za_15[] = { 0x09, 0x04, 0x01, 0x05, 0x01, 0x01, 0x02, 0x00,
+	0x00
+};
 
-static char za_19[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char za_16[] = { 0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00 };
 
-static char za_20[] = {0x09, 0x04, 0x01, 0x06, 0x01, 0x01, 0x02, 0x00,
-		       0x00};
+static char za_17[] = { 0x0e, 0x24, 0x02, 0x01, 0x01, 0x03, 0x14, 0x00,
+	0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00
+};
 
-static char za_21[] = {0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00};
+static char za_18[] = { 0x09, 0x05, 0x04, 0x09, 0xa8, 0x00, 0x01, 0x00,
+	0x00
+};
 
-static char za_22[] = {0x0e, 0x24, 0x02, 0x01, 0x02, 0x03, 0x14, 0x00, 
-		       0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00};
+static char za_19[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
 
-static char za_23[] = {0x09, 0x05, 0x04, 0x09, 0x50, 0x01, 0x01, 0x00,
-		       0x00};
+static char za_20[] = { 0x09, 0x04, 0x01, 0x06, 0x01, 0x01, 0x02, 0x00,
+	0x00
+};
 
-static char za_24[] = {0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02};
+static char za_21[] = { 0x07, 0x24, 0x01, 0x01, 0x00, 0x01, 0x00 };
 
+static char za_22[] = { 0x0e, 0x24, 0x02, 0x01, 0x02, 0x03, 0x14, 0x00,
+	0x7e, 0x13, 0x00, 0xe2, 0xd6, 0x00
+};
 
+static char za_23[] = { 0x09, 0x05, 0x04, 0x09, 0x50, 0x01, 0x01, 0x00,
+	0x00
+};
 
-static const struct usb_descriptor_header *z_function [] = {
-	(struct usb_descriptor_header *) &z_audio_control_if_desc,
-	(struct usb_descriptor_header *) &z_ac_interface_header_desc,
-	(struct usb_descriptor_header *) &z_0,
-	(struct usb_descriptor_header *) &z_1,
-	(struct usb_descriptor_header *) &z_2,
-	(struct usb_descriptor_header *) &z_audio_if_desc,
-	(struct usb_descriptor_header *) &z_audio_if_desc2,
-	(struct usb_descriptor_header *) &z_audio_cs_as_if_desc,
-	(struct usb_descriptor_header *) &z_audio_cs_as_format_desc,
-	(struct usb_descriptor_header *) &z_iso_ep,
-	(struct usb_descriptor_header *) &z_iso_ep2,
-	(struct usb_descriptor_header *) &za_0,
-	(struct usb_descriptor_header *) &za_1,
-	(struct usb_descriptor_header *) &za_2,
-	(struct usb_descriptor_header *) &za_3,
-	(struct usb_descriptor_header *) &za_4,
-	(struct usb_descriptor_header *) &za_5,
-	(struct usb_descriptor_header *) &za_6,
-	(struct usb_descriptor_header *) &za_7,
-	(struct usb_descriptor_header *) &za_8,
-	(struct usb_descriptor_header *) &za_9,
-	(struct usb_descriptor_header *) &za_10,
-	(struct usb_descriptor_header *) &za_11,
-	(struct usb_descriptor_header *) &za_12,
-	(struct usb_descriptor_header *) &za_13,
-	(struct usb_descriptor_header *) &za_14,
-	(struct usb_descriptor_header *) &za_15,
-	(struct usb_descriptor_header *) &za_16,
-	(struct usb_descriptor_header *) &za_17,
-	(struct usb_descriptor_header *) &za_18,
-	(struct usb_descriptor_header *) &za_19,
-	(struct usb_descriptor_header *) &za_20,
-	(struct usb_descriptor_header *) &za_21,
-	(struct usb_descriptor_header *) &za_22,
-	(struct usb_descriptor_header *) &za_23,
-	(struct usb_descriptor_header *) &za_24,
+static char za_24[] = { 0x07, 0x25, 0x01, 0x00, 0x02, 0x00, 0x02 };
+
+static const struct usb_descriptor_header *z_function[] = {
+	(struct usb_descriptor_header *)&z_audio_control_if_desc,
+	(struct usb_descriptor_header *)&z_ac_interface_header_desc,
+	(struct usb_descriptor_header *)&z_0,
+	(struct usb_descriptor_header *)&z_1,
+	(struct usb_descriptor_header *)&z_2,
+	(struct usb_descriptor_header *)&z_audio_if_desc,
+	(struct usb_descriptor_header *)&z_audio_if_desc2,
+	(struct usb_descriptor_header *)&z_audio_cs_as_if_desc,
+	(struct usb_descriptor_header *)&z_audio_cs_as_format_desc,
+	(struct usb_descriptor_header *)&z_iso_ep,
+	(struct usb_descriptor_header *)&z_iso_ep2,
+	(struct usb_descriptor_header *)&za_0,
+	(struct usb_descriptor_header *)&za_1,
+	(struct usb_descriptor_header *)&za_2,
+	(struct usb_descriptor_header *)&za_3,
+	(struct usb_descriptor_header *)&za_4,
+	(struct usb_descriptor_header *)&za_5,
+	(struct usb_descriptor_header *)&za_6,
+	(struct usb_descriptor_header *)&za_7,
+	(struct usb_descriptor_header *)&za_8,
+	(struct usb_descriptor_header *)&za_9,
+	(struct usb_descriptor_header *)&za_10,
+	(struct usb_descriptor_header *)&za_11,
+	(struct usb_descriptor_header *)&za_12,
+	(struct usb_descriptor_header *)&za_13,
+	(struct usb_descriptor_header *)&za_14,
+	(struct usb_descriptor_header *)&za_15,
+	(struct usb_descriptor_header *)&za_16,
+	(struct usb_descriptor_header *)&za_17,
+	(struct usb_descriptor_header *)&za_18,
+	(struct usb_descriptor_header *)&za_19,
+	(struct usb_descriptor_header *)&za_20,
+	(struct usb_descriptor_header *)&za_21,
+	(struct usb_descriptor_header *)&za_22,
+	(struct usb_descriptor_header *)&za_23,
+	(struct usb_descriptor_header *)&za_24,
 	NULL,
 };
 
 /* maxpacket and other transfer characteristics vary by speed. */
-#define ep_desc(g,hs,fs) (((g)->speed==USB_SPEED_HIGH)?(hs):(fs))
+#define ep_desc(g, hs, fs) (((g)->speed == USB_SPEED_HIGH) ? (hs) : (fs))
 
 #else
 
 /* if there's no high speed support, maxpacket doesn't change. */
-#define ep_desc(g,hs,fs) fs
+#define ep_desc(g, hs, fs) fs
 
-#endif	/* !CONFIG_USB_GADGET_DUALSPEED */
+#endif /* !CONFIG_USB_GADGET_DUALSPEED */
 
-static char				manufacturer [40];
-//static char				serial [40];
-static char				serial [] = "Ser 00 em";
+static char manufacturer[40];
+/* static char                           serial [40]; */
+static char serial[] = "Ser 00 em";
 
 /* static strings, in UTF-8 */
-static struct usb_string		strings [] = {
-	{ STRING_MANUFACTURER, manufacturer, },
-	{ STRING_PRODUCT, longname, },
-	{ STRING_SERIAL, serial, },
-	{ STRING_LOOPBACK, loopback, },
-	{ STRING_SOURCE_SINK, source_sink, },
-	{  }			/* end of list */
+static struct usb_string strings[] = {
+	{STRING_MANUFACTURER, manufacturer,},
+	{STRING_PRODUCT, longname,},
+	{STRING_SERIAL, serial,},
+	{STRING_LOOPBACK, loopback,},
+	{STRING_SOURCE_SINK, source_sink,},
+	{}			/* end of list */
 };
 
-static struct usb_gadget_strings	stringtab = {
-	.language	= 0x0409,	/* en-us */
-	.strings	= strings,
+static struct usb_gadget_strings stringtab = {
+	.language = 0x0409,	/* en-us */
+	.strings = strings,
 };
 
 /*
@@ -797,44 +806,43 @@ static struct usb_gadget_strings	stringtab = {
  * device?)
  */
 static int
-config_buf (struct usb_gadget *gadget, u8 *buf, u8 type, unsigned index)
+config_buf(struct usb_gadget *gadget, u8 *buf, u8 type, unsigned index)
 {
 	int len;
 	const struct usb_descriptor_header **function;
-	
+
 	function = z_function;
-	len = usb_gadget_config_buf (&z_config, buf, USB_BUFSIZ, function);
+	len = usb_gadget_config_buf(&z_config, buf, USB_BUFSIZ, function);
 	if (len < 0)
 		return len;
-	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
+	((struct usb_config_descriptor *)buf)->bDescriptorType = type;
 	return len;
 }
 
 /*-------------------------------------------------------------------------*/
 
-static struct usb_request *
-alloc_ep_req (struct usb_ep *ep, unsigned length)
+static struct usb_request *alloc_ep_req(struct usb_ep *ep, unsigned length)
 {
-	struct usb_request	*req;
+	struct usb_request *req;
 
-	req = usb_ep_alloc_request (ep, GFP_ATOMIC);
+	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
 	if (req) {
 		req->length = length;
-		req->buf = usb_ep_alloc_buffer (ep, length,
-				&req->dma, GFP_ATOMIC);
+		req->buf = usb_ep_alloc_buffer(ep, length,
+					       &req->dma, GFP_ATOMIC);
 		if (!req->buf) {
-			usb_ep_free_request (ep, req);
+			usb_ep_free_request(ep, req);
 			req = NULL;
 		}
 	}
 	return req;
 }
 
-static void free_ep_req (struct usb_ep *ep, struct usb_request *req)
+static void free_ep_req(struct usb_ep *ep, struct usb_request *req)
 {
 	if (req->buf)
-		usb_ep_free_buffer (ep, req->buf, req->dma, req->length);
-	usb_ep_free_request (ep, req);
+		usb_ep_free_buffer(ep, req->buf, req->dma, req->length);
+	usb_ep_free_request(ep, req);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -842,34 +850,31 @@ static void free_ep_req (struct usb_ep *ep, struct usb_request *req)
 /* optionally require specific source/sink data patterns  */
 
 static int
-check_read_data (
-	struct zero_dev		*dev,
-	struct usb_ep		*ep,
-	struct usb_request	*req
-)
+check_read_data(struct zero_dev *dev,
+		struct usb_ep *ep, struct usb_request *req)
 {
-	unsigned	i;
-	u8		*buf = req->buf;
+	unsigned i;
+	u8 *buf = req->buf;
 
 	for (i = 0; i < req->actual; i++, buf++) {
 		switch (pattern) {
-		/* all-zeroes has no synchronization issues */
+			/* all-zeroes has no synchronization issues */
 		case 0:
 			if (*buf == 0)
 				continue;
 			break;
-		/* mod63 stays in sync with short-terminated transfers,
-		 * or otherwise when host and gadget agree on how large
-		 * each usb transfer request should be.  resync is done
-		 * with set_interface or set_config.
-		 */
+			/* mod63 stays in sync with short-terminated transfers,
+			 * or otherwise when host and gadget agree on how large
+			 * each usb transfer request should be.  resync is done
+			 * with set_interface or set_config.
+			 */
 		case 1:
-			if (*buf == (u8)(i % 63))
+			if (*buf == (u8) (i % 63))
 				continue;
 			break;
 		}
-		ERROR (dev, "bad OUT byte, buf [%d] = %d\n", i, *buf);
-		usb_ep_set_halt (ep);
+		ERROR(dev, "bad OUT byte, buf [%d] = %d\n", i, *buf);
+		usb_ep_set_halt(ep);
 		return -EINVAL;
 	}
 	return 0;
@@ -877,110 +882,110 @@ check_read_data (
 
 /*-------------------------------------------------------------------------*/
 
-static void zero_reset_config (struct zero_dev *dev)
+static void zero_reset_config(struct zero_dev *dev)
 {
 	if (dev->config == 0)
 		return;
 
-	DBG (dev, "reset config\n");
+	DBG(dev, "reset config\n");
 
 	/* just disable endpoints, forcing completion of pending i/o.
 	 * all our completion handlers free their requests in this case.
 	 */
 	if (dev->in_ep) {
-		usb_ep_disable (dev->in_ep);
+		usb_ep_disable(dev->in_ep);
 		dev->in_ep = NULL;
 	}
 	if (dev->out_ep) {
-		usb_ep_disable (dev->out_ep);
+		usb_ep_disable(dev->out_ep);
 		dev->out_ep = NULL;
 	}
 	dev->config = 0;
-	del_timer (&dev->resume);
+	del_timer(&dev->resume);
 }
 
 #define _write(f, buf, sz) (f->f_op->write(f, buf, sz, &f->f_pos))
 
-static void 
-zero_isoc_complete (struct usb_ep *ep, struct usb_request *req)
+static void zero_isoc_complete(struct usb_ep *ep, struct usb_request *req)
 {
-	struct zero_dev	*dev = ep->driver_data;
-	int		status = req->status;
+	struct zero_dev *dev = ep->driver_data;
+	int status = req->status;
 	int i, j;
 
 	switch (status) {
 
-	case 0: 			/* normal completion? */
-		//printk ("\nzero ---------------> isoc normal completion %d bytes\n", req->actual);
-		for (i=0, j=rbuf_start; i<req->actual; i++) {
-			//printk ("%02x ", ((__u8*)req->buf)[i]);
-			rbuf[j] = ((__u8*)req->buf)[i];
+	case 0:		/* normal completion? */
+		/* printk ("\nzero ---------------> isoc normal completion %d bytes\n",
+		 * req->actual);
+		 */
+		for (i = 0, j = rbuf_start; i < req->actual; i++) {
+			/* printk ("%02x ", ((__u8*)req->buf)[i]); */
+			rbuf[j] = ((__u8 *) req->buf)[i];
 			j++;
-			if (j >= RBUF_LEN) j=0;
+			if (j >= RBUF_LEN)
+				j = 0;
 		}
 		rbuf_start = j;
-		//printk ("\n\n");
+		/* printk ("\n\n"); */
 
 		if (rbuf_len < RBUF_LEN) {
 			rbuf_len += req->actual;
-			if (rbuf_len > RBUF_LEN) {
+			if (rbuf_len > RBUF_LEN)
 				rbuf_len = RBUF_LEN;
-			}
 		}
 
 		break;
 
-	/* this endpoint is normally active while we're configured */
-	case -ECONNABORTED: 		/* hardware forced ep reset */
-	case -ECONNRESET:		/* request dequeued */
-	case -ESHUTDOWN:		/* disconnect from host */
-		VDBG (dev, "%s gone (%d), %d/%d\n", ep->name, status,
-				req->actual, req->length);
+		/* this endpoint is normally active while we're configured */
+	case -ECONNABORTED:	/* hardware forced ep reset */
+	case -ECONNRESET:	/* request dequeued */
+	case -ESHUTDOWN:	/* disconnect from host */
+		VDBG(dev, "%s gone (%d), %d/%d\n", ep->name, status,
+		     req->actual, req->length);
 		if (ep == dev->out_ep)
-			check_read_data (dev, ep, req);
-		free_ep_req (ep, req);
+			check_read_data(dev, ep, req);
+		free_ep_req(ep, req);
 		return;
 
-	case -EOVERFLOW:		/* buffer overrun on read means that
-					 * we didn't provide a big enough
-					 * buffer.
-					 */
+	case -EOVERFLOW:	/* buffer overrun on read means that
+				 * we didn't provide a big enough
+				 * buffer.
+				 */
 	default:
 #if 1
-		DBG (dev, "%s complete --> %d, %d/%d\n", ep->name,
-				status, req->actual, req->length);
+		DBG(dev, "%s complete --> %d, %d/%d\n", ep->name,
+		    status, req->actual, req->length);
 #endif
-	case -EREMOTEIO:		/* short read */
+	case -EREMOTEIO:	/* short read */
 		break;
 	}
 
-	status = usb_ep_queue (ep, req, GFP_ATOMIC);
+	status = usb_ep_queue(ep, req, GFP_ATOMIC);
 	if (status) {
-		ERROR (dev, "kill %s:  resubmit %d bytes --> %d\n",
-				ep->name, req->length, status);
-		usb_ep_set_halt (ep);
+		ERROR(dev, "kill %s:  resubmit %d bytes --> %d\n",
+		      ep->name, req->length, status);
+		usb_ep_set_halt(ep);
 		/* FIXME recover later ... somehow */
 	}
 }
 
-static struct usb_request *
-zero_start_isoc_ep (struct usb_ep *ep, int gfp_flags)
+static struct usb_request *zero_start_isoc_ep(struct usb_ep *ep, int gfp_flags)
 {
-	struct usb_request	*req;
-	int			status;
+	struct usb_request *req;
+	int status;
 
-	req = alloc_ep_req (ep, 512);
+	req = alloc_ep_req(ep, 512);
 	if (!req)
 		return NULL;
 
 	req->complete = zero_isoc_complete;
 
-	status = usb_ep_queue (ep, req, gfp_flags);
+	status = usb_ep_queue(ep, req, gfp_flags);
 	if (status) {
-		struct zero_dev	*dev = ep->driver_data;
+		struct zero_dev *dev = ep->driver_data;
 
-		ERROR (dev, "start %s --> %d\n", ep->name, status);
-		free_ep_req (ep, req);
+		ERROR(dev, "start %s --> %d\n", ep->name, status);
+		free_ep_req(ep, req);
 		req = NULL;
 	}
 
@@ -997,37 +1002,36 @@ zero_start_isoc_ep (struct usb_ep *ep, int gfp_flags)
  * code can do, perhaps by disallowing more than one configuration or
  * by limiting configuration choices (like the pxa2xx).
  */
-static int
-zero_set_config (struct zero_dev *dev, unsigned number, int gfp_flags)
+static int zero_set_config(struct zero_dev *dev, unsigned number, int gfp_flags)
 {
-	int			result = 0;
-	struct usb_gadget	*gadget = dev->gadget;
-	const struct usb_endpoint_descriptor	*d;
-	struct usb_ep		*ep;
+	int result = 0;
+	struct usb_gadget *gadget = dev->gadget;
+	const struct usb_endpoint_descriptor *d;
+	struct usb_ep *ep;
 
 	if (number == dev->config)
 		return 0;
 
-	zero_reset_config (dev);
-
-	gadget_for_each_ep (ep, gadget) {
+	zero_reset_config(dev);
 
-		if (strcmp (ep->name, "ep4") == 0) {
+	gadget_for_each_ep(ep, gadget) {
 
-			d = (struct usb_endpoint_descripter *)&za_23; // isoc ep desc for audio i/f alt setting 6
-			result = usb_ep_enable (ep, d);
+		if (strcmp(ep->name, "ep4") == 0) {
+			/* isoc ep desc for audio i/f alt setting 6 */
+			d = (struct usb_endpoint_descripter *)&za_23;
+			result = usb_ep_enable(ep, d);
 
 			if (result == 0) {
 				ep->driver_data = dev;
 				dev->in_ep = ep;
 
-				if (zero_start_isoc_ep (ep, gfp_flags) != 0) {
+				if (zero_start_isoc_ep(ep, gfp_flags) != 0) {
 
 					dev->in_ep = ep;
 					continue;
 				}
 
-				usb_ep_disable (ep);
+				usb_ep_disable(ep);
 				result = -EIO;
 			}
 		}
@@ -1040,12 +1044,12 @@ zero_set_config (struct zero_dev *dev, unsigned number, int gfp_flags)
 
 /*-------------------------------------------------------------------------*/
 
-static void zero_setup_complete (struct usb_ep *ep, struct usb_request *req)
+static void zero_setup_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	if (req->status || req->actual != req->length)
-		DBG ((struct zero_dev *) ep->driver_data,
-				"setup complete --> %d, %d/%d\n",
-				req->status, req->actual, req->length);
+		DBG((struct zero_dev *)ep->driver_data,
+		    "setup complete --> %d, %d/%d\n",
+		    req->status, req->actual, req->length);
 }
 
 /*
@@ -1056,11 +1060,11 @@ static void zero_setup_complete (struct usb_ep *ep, struct usb_request *req)
  * the work is in config-specific setup.
  */
 static int
-zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
+zero_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 {
-	struct zero_dev		*dev = get_gadget_data (gadget);
-	struct usb_request	*req = dev->req;
-	int			value = -EOPNOTSUPP;
+	struct zero_dev *dev = get_gadget_data(gadget);
+	struct usb_request *req = dev->req;
+	int value = -EOPNOTSUPP;
 
 	/* usually this stores reply data in the pre-allocated ep0 buffer,
 	 * but config change events will reconfigure hardware.
@@ -1073,28 +1077,28 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		switch (ctrl->wValue >> 8) {
 
 		case USB_DT_DEVICE:
-			value = min (ctrl->wLength, (u16) sizeof device_desc);
-			memcpy (req->buf, &device_desc, value);
+			value = min(ctrl->wLength, (u16) sizeof(device_desc));
+			memcpy(req->buf, &device_desc, value);
 			break;
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 		case USB_DT_DEVICE_QUALIFIER:
 			if (!gadget->is_dualspeed)
 				break;
-			value = min (ctrl->wLength, (u16) sizeof dev_qualifier);
-			memcpy (req->buf, &dev_qualifier, value);
+			value = min(ctrl->wLength, (u16) sizeof(dev_qualifier));
+			memcpy(req->buf, &dev_qualifier, value);
 			break;
 
 		case USB_DT_OTHER_SPEED_CONFIG:
 			if (!gadget->is_dualspeed)
 				break;
-			// FALLTHROUGH
+			/* FALLTHROUGH */
 #endif /* CONFIG_USB_GADGET_DUALSPEED */
 		case USB_DT_CONFIG:
-			value = config_buf (gadget, req->buf,
-					ctrl->wValue >> 8,
-					ctrl->wValue & 0xff);
+			value = config_buf(gadget, req->buf,
+					   ctrl->wValue >> 8,
+					   ctrl->wValue & 0xff);
 			if (value >= 0)
-				value = min (ctrl->wLength, (u16) value);
+				value = min(ctrl->wLength, (u16) value);
 			break;
 
 		case USB_DT_STRING:
@@ -1103,42 +1107,42 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			 * add string tables for other languages, using
 			 * any UTF-8 characters
 			 */
-			value = usb_gadget_get_string (&stringtab,
-					ctrl->wValue & 0xff, req->buf);
-			if (value >= 0) {
-				value = min (ctrl->wLength, (u16) value);
-			}
+			value = usb_gadget_get_string(&stringtab,
+						      ctrl->wValue & 0xff,
+						      req->buf);
+			if (value >= 0)
+				value = min(ctrl->wLength, (u16) value);
 			break;
 		}
 		break;
 
-	/* currently two configs, two speeds */
+		/* currently two configs, two speeds */
 	case USB_REQ_SET_CONFIGURATION:
 		if (ctrl->bRequestType != 0)
 			goto unknown;
 
-		spin_lock (&dev->lock);
-		value = zero_set_config (dev, ctrl->wValue, GFP_ATOMIC);
-		spin_unlock (&dev->lock);
+		spin_lock(&dev->lock);
+		value = zero_set_config(dev, ctrl->wValue, GFP_ATOMIC);
+		spin_unlock(&dev->lock);
 		break;
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
 			goto unknown;
-		*(u8 *)req->buf = dev->config;
-		value = min (ctrl->wLength, (u16) 1);
+		*(u8 *) req->buf = dev->config;
+		value = min(ctrl->wLength, (u16) 1);
 		break;
 
-	/* until we add altsetting support, or other interfaces,
-	 * only 0/0 are possible.  pxa2xx only supports 0/0 (poorly)
-	 * and already killed pending endpoint I/O.
-	 */
+		/* until we add altsetting support, or other interfaces,
+		 * only 0/0 are possible.  pxa2xx only supports 0/0 (poorly)
+		 * and already killed pending endpoint I/O.
+		 */
 	case USB_REQ_SET_INTERFACE:
 
 		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
 			goto unknown;
-		spin_lock (&dev->lock);
+		spin_lock(&dev->lock);
 		if (dev->config) {
-			u8		config = dev->config;
+			u8 config = dev->config;
 
 			/* resets interface configuration, forgets about
 			 * previous transaction state (queued bufs, etc)
@@ -1147,19 +1151,19 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			 * if we had more than one interface we couldn't
 			 * use this "reset the config" shortcut.
 			 */
-			zero_reset_config (dev);
-			zero_set_config (dev, config, GFP_ATOMIC);
+			zero_reset_config(dev);
+			zero_set_config(dev, config, GFP_ATOMIC);
 			value = 0;
 		}
-		spin_unlock (&dev->lock);
+		spin_unlock(&dev->lock);
 		break;
 	case USB_REQ_GET_INTERFACE:
 		if ((ctrl->bRequestType == 0x21) && (ctrl->wIndex == 0x02)) {
 			value = ctrl->wLength;
 			break;
-		}
-		else {
-			if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
+		} else {
+			if (ctrl->bRequestType !=
+			    (USB_DIR_IN | USB_RECIP_INTERFACE))
 				goto unknown;
 			if (!dev->config)
 				break;
@@ -1167,18 +1171,18 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				value = -EDOM;
 				break;
 			}
-			*(u8 *)req->buf = 0;
-			value = min (ctrl->wLength, (u16) 1);
+			*(u8 *) req->buf = 0;
+			value = min(ctrl->wLength, (u16) 1);
 		}
 		break;
 
-	/*
-	 * These are the same vendor-specific requests supported by
-	 * Intel's USB 2.0 compliance test devices.  We exceed that
-	 * device spec by allowing multiple-packet requests.
-	 */
-	case 0x5b:	/* control WRITE test -- fill the buffer */
-		if (ctrl->bRequestType != (USB_DIR_OUT|USB_TYPE_VENDOR))
+		/*
+		 * These are the same vendor-specific requests supported by
+		 * Intel's USB 2.0 compliance test devices.  We exceed that
+		 * device spec by allowing multiple-packet requests.
+		 */
+	case 0x5b:		/* control WRITE test -- fill the buffer */
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR))
 			goto unknown;
 		if (ctrl->wValue || ctrl->wIndex)
 			break;
@@ -1187,19 +1191,18 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 			break;
 		value = ctrl->wLength;
 		break;
-	case 0x5c:	/* control READ test -- return the buffer */
-		if (ctrl->bRequestType != (USB_DIR_IN|USB_TYPE_VENDOR))
+	case 0x5c:		/* control READ test -- return the buffer */
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR))
 			goto unknown;
 		if (ctrl->wValue || ctrl->wIndex)
 			break;
 		/* expect those bytes are still in the buffer; send back */
-		if (ctrl->wLength > USB_BUFSIZ
-				|| ctrl->wLength != req->length)
+		if (ctrl->wLength > USB_BUFSIZ || ctrl->wLength != req->length)
 			break;
 		value = ctrl->wLength;
 		break;
 
-	case 0x01: // SET_CUR
+	case 0x01:		/* SET_CUR */
 	case 0x02:
 	case 0x03:
 	case 0x04:
@@ -1210,92 +1213,91 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		switch (ctrl->wValue) {
 		case 0x0201:
 		case 0x0202:
-			((u8*)req->buf)[0] = 0x00;
-			((u8*)req->buf)[1] = 0xe3;
+			((u8 *) req->buf)[0] = 0x00;
+			((u8 *) req->buf)[1] = 0xe3;
 			break;
 		case 0x0300:
 		case 0x0500:
-			((u8*)req->buf)[0] = 0x00;
+			((u8 *) req->buf)[0] = 0x00;
 			break;
 		}
-		//((u8*)req->buf)[0] = 0x81;
-		//((u8*)req->buf)[1] = 0x81;
+		/* ((u8*)req->buf)[0] = 0x81; */
+		/* ((u8*)req->buf)[1] = 0x81; */
 		value = ctrl->wLength;
 		break;
 	case 0x82:
 		switch (ctrl->wValue) {
 		case 0x0201:
 		case 0x0202:
-			((u8*)req->buf)[0] = 0x00;
-			((u8*)req->buf)[1] = 0xc3;
+			((u8 *) req->buf)[0] = 0x00;
+			((u8 *) req->buf)[1] = 0xc3;
 			break;
 		case 0x0300:
 		case 0x0500:
-			((u8*)req->buf)[0] = 0x00;
+			((u8 *) req->buf)[0] = 0x00;
 			break;
 		}
-		//((u8*)req->buf)[0] = 0x82;
-		//((u8*)req->buf)[1] = 0x82;
+		/* ((u8*)req->buf)[0] = 0x82; */
+		/* ((u8*)req->buf)[1] = 0x82; */
 		value = ctrl->wLength;
 		break;
 	case 0x83:
 		switch (ctrl->wValue) {
 		case 0x0201:
 		case 0x0202:
-			((u8*)req->buf)[0] = 0x00;
-			((u8*)req->buf)[1] = 0x00;
+			((u8 *) req->buf)[0] = 0x00;
+			((u8 *) req->buf)[1] = 0x00;
 			break;
 		case 0x0300:
-			((u8*)req->buf)[0] = 0x60;
+			((u8 *) req->buf)[0] = 0x60;
 			break;
-		case 0x0500:	
-			((u8*)req->buf)[0] = 0x18;
+		case 0x0500:
+			((u8 *) req->buf)[0] = 0x18;
 			break;
 		}
-		//((u8*)req->buf)[0] = 0x83;
-		//((u8*)req->buf)[1] = 0x83;
+		/* ((u8*)req->buf)[0] = 0x83; */
+		/* ((u8*)req->buf)[1] = 0x83; */
 		value = ctrl->wLength;
 		break;
 	case 0x84:
 		switch (ctrl->wValue) {
 		case 0x0201:
 		case 0x0202:
-			((u8*)req->buf)[0] = 0x00;
-			((u8*)req->buf)[1] = 0x01;
+			((u8 *) req->buf)[0] = 0x00;
+			((u8 *) req->buf)[1] = 0x01;
 			break;
 		case 0x0300:
 		case 0x0500:
-			((u8*)req->buf)[0] = 0x08;
+			((u8 *) req->buf)[0] = 0x08;
 			break;
 		}
-		//((u8*)req->buf)[0] = 0x84;
-		//((u8*)req->buf)[1] = 0x84;
+		/* ((u8*)req->buf)[0] = 0x84; */
+		/* ((u8*)req->buf)[1] = 0x84; */
 		value = ctrl->wLength;
 		break;
 	case 0x85:
-		((u8*)req->buf)[0] = 0x85;
-		((u8*)req->buf)[1] = 0x85;
+		((u8 *) req->buf)[0] = 0x85;
+		((u8 *) req->buf)[1] = 0x85;
 		value = ctrl->wLength;
 		break;
 
-	
 	default:
 unknown:
 		printk("unknown control req%02x.%02x v%04x i%04x l%d\n",
-			ctrl->bRequestType, ctrl->bRequest,
-			ctrl->wValue, ctrl->wIndex, ctrl->wLength);
+		       ctrl->bRequestType, ctrl->bRequest,
+		       ctrl->wValue, ctrl->wIndex, ctrl->wLength);
 	}
 
 	/* respond with data transfer before status phase? */
 	if (value >= 0) {
 		req->length = value;
 		req->zero = value < ctrl->wLength
-				&& (value % gadget->ep0->maxpacket) == 0;
-		value = usb_ep_queue (gadget->ep0, req, GFP_ATOMIC);
+		    && (value % gadget->ep0->maxpacket) == 0;
+		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0) {
-			DBG (dev, "ep_queue < 0 --> %d\n", value);
+			DBG(dev, "ep_queue < 0 --> %d\n", value);
 			req->status = 0;
-			zero_setup_complete (gadget->ep0, req);
+			zero_setup_complete(gadget->ep0, req);
 		}
 	}
 
@@ -1303,63 +1305,59 @@ zero_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 	return value;
 }
 
-static void
-zero_disconnect (struct usb_gadget *gadget)
+static void zero_disconnect(struct usb_gadget *gadget)
 {
-	struct zero_dev		*dev = get_gadget_data (gadget);
-	unsigned long		flags;
+	struct zero_dev *dev = get_gadget_data(gadget);
+	unsigned long flags;
 
-	spin_lock_irqsave (&dev->lock, flags);
-	zero_reset_config (dev);
+	spin_lock_irqsave(&dev->lock, flags);
+	zero_reset_config(dev);
 
 	/* a more significant application might have some non-usb
 	 * activities to quiesce here, saving resources like power
 	 * or pushing the notification up a network stack.
 	 */
-	spin_unlock_irqrestore (&dev->lock, flags);
+	spin_unlock_irqrestore(&dev->lock, flags);
 
 	/* next we may get setup() calls to enumerate new connections;
 	 * or an unbind() during shutdown (including removing module).
 	 */
 }
 
-static void
-zero_autoresume (unsigned long _dev)
+static void zero_autoresume(unsigned long _dev)
 {
-	struct zero_dev	*dev = (struct zero_dev *) _dev;
-	int		status;
+	struct zero_dev *dev = (struct zero_dev *)_dev;
+	int status;
 
 	/* normally the host would be woken up for something
 	 * more significant than just a timer firing...
 	 */
 	if (dev->gadget->speed != USB_SPEED_UNKNOWN) {
-		status = usb_gadget_wakeup (dev->gadget);
-		DBG (dev, "wakeup --> %d\n", status);
+		status = usb_gadget_wakeup(dev->gadget);
+		DBG(dev, "wakeup --> %d\n", status);
 	}
 }
 
 /*-------------------------------------------------------------------------*/
 
-static void
-zero_unbind (struct usb_gadget *gadget)
+static void zero_unbind(struct usb_gadget *gadget)
 {
-	struct zero_dev		*dev = get_gadget_data (gadget);
+	struct zero_dev *dev = get_gadget_data(gadget);
 
-	DBG (dev, "unbind\n");
+	DBG(dev, "unbind\n");
 
 	/* we've already been disconnected ... no i/o is active */
 	if (dev->req)
-		free_ep_req (gadget->ep0, dev->req);
-	del_timer_sync (&dev->resume);
-	kfree (dev);
-	set_gadget_data (gadget, NULL);
+		free_ep_req(gadget->ep0, dev->req);
+	del_timer_sync(&dev->resume);
+	kfree(dev);
+	set_gadget_data(gadget, NULL);
 }
 
-static int
-zero_bind (struct usb_gadget *gadget)
+static int zero_bind(struct usb_gadget *gadget)
 {
-	struct zero_dev		*dev;
-	//struct usb_ep		*ep;
+	struct zero_dev *dev;
+	/* struct usb_ep         *ep; */
 
 	printk("binding\n");
 	/*
@@ -1368,24 +1366,23 @@ zero_bind (struct usb_gadget *gadget)
 	 * with different host-visible configurations or behavior
 	 * restrictions -- using ep1in/ep2out vs ep1out/ep3in, etc
 	 */
-	//device_desc.bcdDevice = __constant_cpu_to_le16 (0x0201);
-
+	/* device_desc.bcdDevice = __constant_cpu_to_le16 (0x0201); */
 
 	/* ok, we made sense of the hardware ... */
-	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
+	dev = kmalloc(sizeof(*dev), SLAB_KERNEL);
 	if (!dev)
 		return -ENOMEM;
-	memset (dev, 0, sizeof *dev);
-	spin_lock_init (&dev->lock);
+	memset(dev, 0, sizeof(*dev));
+	spin_lock_init(&dev->lock);
 	dev->gadget = gadget;
-	set_gadget_data (gadget, dev);
+	set_gadget_data(gadget, dev);
 
 	/* preallocate control response and buffer */
-	dev->req = usb_ep_alloc_request (gadget->ep0, GFP_KERNEL);
+	dev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
 	if (!dev->req)
 		goto enomem;
-	dev->req->buf = usb_ep_alloc_buffer (gadget->ep0, USB_BUFSIZ,
-				&dev->req->dma, GFP_KERNEL);
+	dev->req->buf = usb_ep_alloc_buffer(gadget->ep0, USB_BUFSIZ,
+					    &dev->req->dma, GFP_KERNEL);
 	if (!dev->req->buf)
 		goto enomem;
 
@@ -1398,99 +1395,94 @@ zero_bind (struct usb_gadget *gadget)
 	dev_qualifier.bMaxPacketSize0 = device_desc.bMaxPacketSize0;
 
 	/* and that all endpoints are dual-speed */
-	//hs_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress;
-	//hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
+	/* hs_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress; */
+	/* hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress; */
 #endif
 
-	usb_gadget_set_selfpowered (gadget);
+	usb_gadget_set_selfpowered(gadget);
 
-	init_timer (&dev->resume);
+	init_timer(&dev->resume);
 	dev->resume.function = zero_autoresume;
-	dev->resume.data = (unsigned long) dev;
+	dev->resume.data = (unsigned long)dev;
 
 	gadget->ep0->driver_data = dev;
 
-	INFO (dev, "%s, version: " DRIVER_VERSION "\n", longname);
-	INFO (dev, "using %s, OUT %s IN %s\n", gadget->name,
-		EP_OUT_NAME, EP_IN_NAME);
+	INFO(dev, "%s, version: " DRIVER_VERSION "\n", longname);
+	INFO(dev, "using %s, OUT %s IN %s\n", gadget->name,
+	     EP_OUT_NAME, EP_IN_NAME);
 
-	snprintf (manufacturer, sizeof manufacturer,
-		UTS_SYSNAME " " UTS_RELEASE " with %s",
-		gadget->name);
+	snprintf(manufacturer, sizeof(manufacturer),
+		 UTS_SYSNAME " " UTS_RELEASE " with %s", gadget->name);
 
 	return 0;
 
 enomem:
-	zero_unbind (gadget);
+	zero_unbind(gadget);
 	return -ENOMEM;
 }
 
 /*-------------------------------------------------------------------------*/
 
-static void
-zero_suspend (struct usb_gadget *gadget)
+static void zero_suspend(struct usb_gadget *gadget)
 {
-	struct zero_dev		*dev = get_gadget_data (gadget);
+	struct zero_dev *dev = get_gadget_data(gadget);
 
 	if (gadget->speed == USB_SPEED_UNKNOWN)
 		return;
 
 	if (autoresume) {
-		mod_timer (&dev->resume, jiffies + (HZ * autoresume));
-		DBG (dev, "suspend, wakeup in %d seconds\n", autoresume);
+		mod_timer(&dev->resume, jiffies + (HZ * autoresume));
+		DBG(dev, "suspend, wakeup in %d seconds\n", autoresume);
 	} else
-		DBG (dev, "suspend\n");
+		DBG(dev, "suspend\n");
 }
 
-static void
-zero_resume (struct usb_gadget *gadget)
+static void zero_resume(struct usb_gadget *gadget)
 {
-	struct zero_dev		*dev = get_gadget_data (gadget);
+	struct zero_dev *dev = get_gadget_data(gadget);
 
-	DBG (dev, "resume\n");
-	del_timer (&dev->resume);
+	DBG(dev, "resume\n");
+	del_timer(&dev->resume);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver zero_driver = {
 #ifdef CONFIG_USB_GADGET_DUALSPEED
-	.speed		= USB_SPEED_HIGH,
+	.speed = USB_SPEED_HIGH,
 #else
-	.speed		= USB_SPEED_FULL,
+	.speed = USB_SPEED_FULL,
 #endif
-	.function	= (char *) longname,
-	.bind		= zero_bind,
-	.unbind		= zero_unbind,
-
-	.setup		= zero_setup,
-	.disconnect	= zero_disconnect,
-
-	.suspend	= zero_suspend,
-	.resume		= zero_resume,
-
-	.driver 	= {
-		.name		= (char *) shortname,
-		// .shutdown = ...
-		// .suspend = ...
-		// .resume = ...
-	},
+	.function = (char *)longname,
+	.bind = zero_bind,
+	.unbind = zero_unbind,
+
+	.setup = zero_setup,
+	.disconnect = zero_disconnect,
+
+	.suspend = zero_suspend,
+	.resume = zero_resume,
+
+	.driver = {
+		   .name = (char *)shortname,
+		   /* .shutdown = ... */
+		   /* .suspend = ... */
+		   /* .resume = ... */
+		   },
 };
 
-MODULE_AUTHOR ("David Brownell");
-MODULE_LICENSE ("Dual BSD/GPL");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("Dual BSD/GPL");
 
 static struct proc_dir_entry *pdir, *pfile;
 
-static int isoc_read_data (char *page, char **start,
-			   off_t off, int count,
-			   int *eof, void *data)
+static int isoc_read_data(char *page, char **start,
+			  off_t off, int count, int *eof, void *data)
 {
 	int i;
-	static int c = 0;
-	static int done = 0;
-	static int s = 0;
+	static int c;
+	static int done;
+	static int s;
 
 /*
 	printk ("\ncount: %d\n", count);
@@ -1509,30 +1501,30 @@ static int isoc_read_data (char *page, char **start,
 	if (c == 0) {
 		if (rbuf_len == RBUF_LEN)
 			s = rbuf_start;
-		else s = 0;
+		else
+			s = 0;
 	}
 
-	for (i=0; i<count && c<rbuf_len; i++, c++) {
-		page[i] = rbuf[(c+s) % RBUF_LEN];
-	}
+	for (i = 0; i < count && c < rbuf_len; i++, c++)
+		page[i] = rbuf[(c + s) % RBUF_LEN];
+
 	*start = page;
-	
+
 	if (c >= rbuf_len) {
 		*eof = 1;
 		done = 1;
 	}
 
-
 	return i;
 }
 
-static int __init init (void)
+static int __init init(void)
 {
 
 	int retval = 0;
 
 	pdir = proc_mkdir("isoc_test", NULL);
-	if(pdir == NULL) {
+	if (pdir == NULL) {
 		retval = -ENOMEM;
 		printk("Error creating dir\n");
 		goto done;
@@ -1540,9 +1532,7 @@ static int __init init (void)
 	pdir->owner = THIS_MODULE;
 
 	pfile = create_proc_read_entry("isoc_data",
-				       0444, pdir,
-				       isoc_read_data,
-				       NULL);
+				       0444, pdir, isoc_read_data, NULL);
 	if (pfile == NULL) {
 		retval = -ENOMEM;
 		printk("Error creating file\n");
@@ -1550,21 +1540,23 @@ static int __init init (void)
 	}
 	pfile->owner = THIS_MODULE;
 
-	return usb_gadget_register_driver (&zero_driver);
+	return usb_gadget_register_driver(&zero_driver);
 
- no_file:
+no_file:
 	remove_proc_entry("isoc_data", NULL);
- done:
+done:
 	return retval;
 }
-module_init (init);
 
-static void __exit cleanup (void)
+module_init(init);
+
+static void __exit cleanup(void)
 {
 
-	usb_gadget_unregister_driver (&zero_driver);
-	
+	usb_gadget_unregister_driver(&zero_driver);
+
 	remove_proc_entry("isoc_data", pdir);
 	remove_proc_entry("isoc_test", NULL);
 }
-module_exit (cleanup);
+
+module_exit(cleanup);
diff --git a/drivers/usb/dwc_otg_310/dwc_cfi_common.h b/drivers/usb/dwc_otg_310/dwc_cfi_common.h
index be56af4d2223..7a42268b1b58 100755
--- a/drivers/usb/dwc_otg_310/dwc_cfi_common.h
+++ b/drivers/usb/dwc_otg_310/dwc_cfi_common.h
@@ -2,7 +2,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -12,7 +12,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -29,10 +29,10 @@
 #if !defined(__DWC_CFI_COMMON_H__)
 #define __DWC_CFI_COMMON_H__
 
-//#include <linux/types.h>
+/* #include <linux/types.h> */
 
 /**
- * @file 
+ * @file
  *
  * This file contains the CFI specific common constants, interfaces
  * (functions and macros) and structures for Linux. No PCD specific
@@ -49,8 +49,8 @@
 /** This command allows the host to set the value of a specific Core Feature */
 #define VEN_CORE_SET_FEATURE		0xB3
 
-/** This command allows the host to set the default values of 
- * either all or any specific Core Feature 
+/** This command allows the host to set the default values of
+ * either all or any specific Core Feature
  */
 #define VEN_CORE_RESET_FEATURES		0xB4
 
@@ -63,20 +63,20 @@
 /** This request writes a DWORD value into a register at the specified offset */
 #define VEN_CORE_WRITE_REGISTER		0xB7
 
-/** This structure is the header of the Core Features dataset returned to 
+/** This structure is the header of the Core Features dataset returned to
  *  the Host
  */
 struct cfi_all_features_header {
 /** The features header structure length is */
 #define CFI_ALL_FEATURES_HDR_LEN		8
 	/**
-	 * The total length of the features dataset returned to the Host 
+	 * The total length of the features dataset returned to the Host
 	 */
 	uint16_t wTotalLen;
 
 	/**
 	 * CFI version number inBinary-Coded Decimal (i.e., 1.00 is 100H).
-	 * This field identifies the version of the CFI Specification with which 
+	 * This field identifies the version of the CFI Specification with which
 	 * the device is compliant.
 	 */
 	uint16_t wVersion;
@@ -93,7 +93,7 @@ struct cfi_all_features_header {
 
 typedef struct cfi_all_features_header cfi_all_features_header_t;
 
-/** This structure is a header of the Core Feature descriptor dataset returned to 
+/** This structure is a header of the Core Feature descriptor dataset returned to
  *  the Host after the VEN_CORE_GET_FEATURES request
  */
 struct cfi_feature_desc_header {
@@ -110,8 +110,8 @@ struct cfi_feature_desc_header {
 	/** The data length of this feature in bytes */
 	uint16_t wDataLength;
 
-	/** 
-	 * Attributes of this features 
+	/**
+	 * Attributes of this features
 	 * D0: Access rights
 	 * 0 - Read/Write
 	 * 1 - Read only
@@ -124,7 +124,7 @@ struct cfi_feature_desc_header {
 	uint8_t bNameLen;
 
 	/** The feature name buffer */
-	//uint8_t *name;
+	/* uint8_t *name; */
 } UPACKED;
 
 typedef struct cfi_feature_desc_header cfi_feature_desc_header_t;
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_adp.c b/drivers/usb/dwc_otg_310/dwc_otg_adp.c
index 56e984a1f0f7..7e4bfe7e9529 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_adp.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_adp.c
@@ -43,7 +43,7 @@
  *
  */
 
-void dwc_otg_adp_write_reg(dwc_otg_core_if_t * core_if, uint32_t value)
+void dwc_otg_adp_write_reg(dwc_otg_core_if_t *core_if, uint32_t value)
 {
 	adpctl_data_t adpctl;
 
@@ -52,16 +52,15 @@ void dwc_otg_adp_write_reg(dwc_otg_core_if_t * core_if, uint32_t value)
 
 	DWC_WRITE_REG32(&core_if->core_global_regs->adpctl, adpctl.d32);
 
-	while (adpctl.b.ar) {
+	while (adpctl.b.ar)
 		adpctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->adpctl);
-	}
 
 }
 
 /**
  * Function is called to read ADP registers
  */
-uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t *core_if)
 {
 	adpctl_data_t adpctl;
 
@@ -70,9 +69,8 @@ uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t * core_if)
 
 	DWC_WRITE_REG32(&core_if->core_global_regs->adpctl, adpctl.d32);
 
-	while (adpctl.b.ar) {
+	while (adpctl.b.ar)
 		adpctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->adpctl);
-	}
 
 	return adpctl.d32;
 }
@@ -80,7 +78,7 @@ uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t * core_if)
 /**
  * Function is called to read ADPCTL register and filter Write-clear bits
  */
-uint32_t dwc_otg_adp_read_reg_filter(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_read_reg_filter(dwc_otg_core_if_t *core_if)
 {
 	adpctl_data_t adpctl;
 
@@ -88,23 +86,23 @@ uint32_t dwc_otg_adp_read_reg_filter(dwc_otg_core_if_t * core_if)
 	adpctl.b.adp_tmout_int = 0;
 	adpctl.b.adp_prb_int = 0;
 	adpctl.b.adp_tmout_int = 0;
-		
+
 	return adpctl.d32;
 }
 
 /**
  * Function is called to write ADP registers
  */
-void dwc_otg_adp_modify_reg(dwc_otg_core_if_t * core_if, uint32_t clr,
+void dwc_otg_adp_modify_reg(dwc_otg_core_if_t *core_if, uint32_t clr,
 			    uint32_t set)
 {
 	dwc_otg_adp_write_reg(core_if,
 			      (dwc_otg_adp_read_reg(core_if) & (~clr)) | set);
 }
 
-static void adp_probe_func(void * ptr)
+static void adp_probe_func(void *ptr)
 {
-	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *) ptr;	
+	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *) ptr;
 	dwc_otg_adp_probe_start(core_if);
 }
 
@@ -116,7 +114,7 @@ static void adp_sense_timeout(void *ptr)
 	if (core_if->adp_enable) {
 		dwc_otg_adp_sense_stop(core_if);
 		DWC_WORKQ_SCHEDULE_DELAYED(core_if->wq_otg, adp_probe_func,
-									core_if, 2500, "start probe");
+					   core_if, 2500, "start probe");
 	}
 }
 
@@ -129,7 +127,8 @@ static void adp_vbuson_timeout(void *ptr)
 	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *) ptr;
 	hprt0_data_t hprt0 = {.d32 = 0 };
 	pcgcctl_data_t pcgcctl = {.d32 = 0 };
-	DWC_PRINTF("%s: 1.1 seconds expire after turning on VBUS\n",__FUNCTION__);
+	DWC_PRINTF("%s: 1.1 seconds expire after turning on VBUS\n",
+		   __func__);
 	if (core_if) {
 		core_if->adp.vbuson_timer_started = 0;
 		/* Turn off vbus */
@@ -140,7 +139,7 @@ static void adp_vbuson_timeout(void *ptr)
 		/* Power off the core */
 		if (core_if->power_down == 2) {
 			/* Enable Wakeup Logic */
-//                      gpwrdn.b.wkupactiv = 1;
+			/* gpwrdn.b.wkupactiv = 1; */
 			gpwrdn.b.pmuactv = 0;
 			gpwrdn.b.pwrdnrstn = 1;
 			gpwrdn.b.pwrdnclmp = 1;
@@ -152,7 +151,7 @@ static void adp_vbuson_timeout(void *ptr)
 			DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
 
 			/* Switch on VDD */
-//                      gpwrdn.b.wkupactiv = 1;
+			/* gpwrdn.b.wkupactiv = 1; */
 			gpwrdn.b.pmuactv = 1;
 			gpwrdn.b.pwrdnrstn = 1;
 			gpwrdn.b.pwrdnclmp = 1;
@@ -162,7 +161,8 @@ static void adp_vbuson_timeout(void *ptr)
 			/* Enable Power Down Logic */
 			gpwrdn.b.pmuintsel = 1;
 			gpwrdn.b.pmuactv = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+					 gpwrdn.d32);
 		}
 
 		/* Power off the core */
@@ -176,7 +176,8 @@ static void adp_vbuson_timeout(void *ptr)
 		/* Unmask SRP detected interrupt from Power Down Logic */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.srp_det_msk = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+				 gpwrdn.d32);
 
 		dwc_otg_adp_probe_start(core_if);
 		dwc_otg_dump_global_registers(core_if);
@@ -186,21 +187,20 @@ static void adp_vbuson_timeout(void *ptr)
 }
 
 /**
- * Start the ADP Initial Probe timer to detect if Port Connected interrupt is 
+ * Start the ADP Initial Probe timer to detect if Port Connected interrupt is
  * not asserted within 1.1 seconds.
  *
  * @param core_if the pointer to core_if strucure.
  */
-void dwc_otg_adp_vbuson_timer_start(dwc_otg_core_if_t * core_if)
+void dwc_otg_adp_vbuson_timer_start(dwc_otg_core_if_t *core_if)
 {
 	core_if->adp.vbuson_timer_started = 1;
-	if (core_if->adp.vbuson_timer)
-	{
+	if (core_if->adp.vbuson_timer) {
 		DWC_PRINTF("SCHEDULING VBUSON TIMER\n");
-		/* 1.1 secs + 60ms necessary for cil_hcd_start*/
+		/* 1.1 secs + 60ms necessary for cil_hcd_start */
 		DWC_TIMER_SCHEDULE(core_if->adp.vbuson_timer, 1160);
 	} else {
-		DWC_WARN("VBUSON_TIMER = %p\n",core_if->adp.vbuson_timer);
+		DWC_WARN("VBUSON_TIMER = %p\n", core_if->adp.vbuson_timer);
 	}
 }
 
@@ -209,7 +209,7 @@ void dwc_otg_adp_vbuson_timer_start(dwc_otg_core_if_t * core_if)
  * Masks all DWC OTG core interrupts
  *
  */
-static void mask_all_interrupts(dwc_otg_core_if_t * core_if)
+static void mask_all_interrupts(dwc_otg_core_if_t *core_if)
 {
 	int i;
 	gahbcfg_data_t ahbcfg = {.d32 = 0 };
@@ -219,7 +219,8 @@ static void mask_all_interrupts(dwc_otg_core_if_t * core_if)
 	/* Clear and disable HCINTs */
 	for (i = 0; i < core_if->core_params->host_channels; i++) {
 		DWC_WRITE_REG32(&core_if->host_if->hc_regs[i]->hcintmsk, 0);
-		DWC_WRITE_REG32(&core_if->host_if->hc_regs[i]->hcint, 0xFFFFFFFF);
+		DWC_WRITE_REG32(&core_if->host_if->hc_regs[i]->hcint,
+				0xFFFFFFFF);
 
 	}
 
@@ -232,15 +233,15 @@ static void mask_all_interrupts(dwc_otg_core_if_t * core_if)
 		/* Clear and disable IN Endpoint interrupts */
 		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->diepmsk, 0);
 		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->
-					diepint, 0xFFFFFFFF);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[i]->diepint, 0xFFFFFFFF);
 		}
 
 		/* Clear and disable OUT Endpoint interrupts */
 		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->doepmsk, 0);
 		for (i = 0; i <= core_if->dev_if->num_out_eps; i++) {
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->
-					doepint, 0xFFFFFFFF);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					out_ep_regs[i]->doepint, 0xFFFFFFFF);
 		}
 
 		/* Clear and disable DAINT */
@@ -249,17 +250,17 @@ static void mask_all_interrupts(dwc_otg_core_if_t * core_if)
 		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->daintmsk, 0);
 	} else {
 		for (i = 0; i < core_if->dev_if->num_in_eps; ++i) {
-			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->
-					diepeachintmsk[i], 0);
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->
-					diepint, 0xFFFFFFFF);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					dev_global_regs->diepeachintmsk[i], 0);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[i]->diepint, 0xFFFFFFFF);
 		}
 
 		for (i = 0; i < core_if->dev_if->num_out_eps; ++i) {
-			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->
-					doepeachintmsk[i], 0);
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->
-					doepint, 0xFFFFFFFF);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					dev_global_regs->doepeachintmsk[i], 0);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					out_ep_regs[i]->doepint, 0xFFFFFFFF);
 		}
 
 		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->deachintmsk,
@@ -287,9 +288,9 @@ static void mask_all_interrupts(dwc_otg_core_if_t * core_if)
  * Unmask Port Connection Detected interrupt
  *
  */
-static void unmask_conn_det_intr(dwc_otg_core_if_t * core_if)
+static void unmask_conn_det_intr(dwc_otg_core_if_t *core_if)
 {
-	gintmsk_data_t gintmsk = {.d32 = 0,.b.portintr = 1 };
+	gintmsk_data_t gintmsk = {.d32 = 0, .b.portintr = 1};
 
 	DWC_WRITE_REG32(&core_if->core_global_regs->gintmsk, gintmsk.d32);
 }
@@ -300,20 +301,21 @@ static void unmask_conn_det_intr(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if structure.
  */
-uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t *core_if)
 {
 
-	adpctl_data_t adpctl = {.d32 = 0};
+	adpctl_data_t adpctl = {.d32 = 0 };
 	gpwrdn_data_t gpwrdn;
 #if 0
 	adpctl_data_t adpctl_int = {.d32 = 0, .b.adp_prb_int = 1,
-								.b.adp_sns_int = 1, b.adp_tmout_int};
+		.b.adp_sns_int = 1, b.adp_tmout_int
+	};
 #endif
 	if (core_if->stop_adpprb) {
 		core_if->stop_adpprb = 0;
 		return 0;
 	}
-	
+
 	dwc_otg_disable_global_interrupts(core_if);
 	DWC_PRINTF("ADP Probe Start\n");
 	core_if->adp.probe_enabled = 1;
@@ -321,9 +323,8 @@ uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t * core_if)
 	adpctl.b.adpres = 1;
 	dwc_otg_adp_write_reg(core_if, adpctl.d32);
 
-	while (adpctl.b.adpres) {
+	while (adpctl.b.adpres)
 		adpctl.d32 = dwc_otg_adp_read_reg(core_if);
-	}
 
 	adpctl.d32 = 0;
 	gpwrdn.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
@@ -331,9 +332,10 @@ uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t * core_if)
 	/* In Host mode unmask SRP detected interrupt */
 	gpwrdn.d32 = 0;
 	gpwrdn.b.sts_chngint_msk = 1;
-	if (!gpwrdn.b.idsts) {
+
+	if (!gpwrdn.b.idsts)
 		gpwrdn.b.srp_det_msk = 1;
-	}
+
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
 
 	adpctl.b.adp_tmout_int_msk = 1;
@@ -350,15 +352,15 @@ uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t * core_if)
 }
 
 /**
- * Starts the ADP Sense timer to detect if ADP Sense interrupt is not asserted 
+ * Starts the ADP Sense timer to detect if ADP Sense interrupt is not asserted
  * within 3 seconds.
  *
  * @param core_if the pointer to core_if strucure.
  */
-void dwc_otg_adp_sense_timer_start(dwc_otg_core_if_t * core_if)
+void dwc_otg_adp_sense_timer_start(dwc_otg_core_if_t *core_if)
 {
 	core_if->adp.sense_timer_started = 1;
-	DWC_TIMER_SCHEDULE(core_if->adp.sense_timer, 3300 /* 3.3 secs */ );
+	DWC_TIMER_SCHEDULE(core_if->adp.sense_timer, 3300 /* 3.3 secs */);
 }
 
 /**
@@ -366,7 +368,7 @@ void dwc_otg_adp_sense_timer_start(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if strucure.
  */
-uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t *core_if)
 {
 	adpctl_data_t adpctl;
 
@@ -376,16 +378,15 @@ uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t * core_if)
 	adpctl.d32 = dwc_otg_adp_read_reg_filter(core_if);
 	adpctl.b.adp_sns_int_msk = 1;
 	dwc_otg_adp_write_reg(core_if, adpctl.d32);
-	dwc_otg_disable_global_interrupts(core_if); // vahrama 
+	dwc_otg_disable_global_interrupts(core_if);	/* vahrama */
 
-	/* Set ADP reset bit*/
+	/* Set ADP reset bit */
 	adpctl.d32 = dwc_otg_adp_read_reg_filter(core_if);
 	adpctl.b.adpres = 1;
 	dwc_otg_adp_write_reg(core_if, adpctl.d32);
 
-	while (adpctl.b.adpres) {
+	while (adpctl.b.adpres)
 		adpctl.d32 = dwc_otg_adp_read_reg(core_if);
-	}
 
 	adpctl.b.adpres = 0;
 	adpctl.b.adpen = 1;
@@ -402,13 +403,13 @@ uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if strucure.
  */
-uint32_t dwc_otg_adp_probe_stop(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_probe_stop(dwc_otg_core_if_t *core_if)
 {
 
 	adpctl_data_t adpctl;
 	DWC_PRINTF("Stop ADP probe\n");
 	core_if->adp.probe_enabled = 0;
-	//core_if->adp.probe_counter = 0;
+	/* core_if->adp.probe_counter = 0; */
 	adpctl.d32 = dwc_otg_adp_read_reg(core_if);
 
 	adpctl.b.adpen = 0;
@@ -425,7 +426,7 @@ uint32_t dwc_otg_adp_probe_stop(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if strucure.
  */
-uint32_t dwc_otg_adp_sense_stop(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_adp_sense_stop(dwc_otg_core_if_t *core_if)
 {
 	adpctl_data_t adpctl;
 
@@ -446,7 +447,7 @@ uint32_t dwc_otg_adp_sense_stop(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if structure.
  */
-void dwc_otg_adp_turnon_vbus(dwc_otg_core_if_t * core_if)
+void dwc_otg_adp_turnon_vbus(dwc_otg_core_if_t *core_if)
 {
 	hprt0_data_t hprt0 = {.d32 = 0 };
 	hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -454,9 +455,9 @@ void dwc_otg_adp_turnon_vbus(dwc_otg_core_if_t * core_if)
 
 	if (hprt0.b.prtpwr == 0) {
 		hprt0.b.prtpwr = 1;
-		//DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+		/* DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32); */
 	}
-	
+
 	dwc_otg_adp_vbuson_timer_start(core_if);
 }
 
@@ -467,7 +468,7 @@ void dwc_otg_adp_turnon_vbus(dwc_otg_core_if_t * core_if)
  * @param core_if the pointer to core_if structure.
  * @param is_host - flag for current mode of operation either from GINTSTS or GPWRDN
  */
-void dwc_otg_adp_start(dwc_otg_core_if_t * core_if, uint8_t is_host)
+void dwc_otg_adp_start(dwc_otg_core_if_t *core_if, uint8_t is_host)
 {
 	gpwrdn_data_t gpwrdn;
 
@@ -478,32 +479,36 @@ void dwc_otg_adp_start(dwc_otg_core_if_t * core_if, uint8_t is_host)
 	dwc_otg_disable_global_interrupts(core_if);
 	if (is_host) {
 		DWC_PRINTF("HOST MODE\n");
-		/* Enable Power Down Logic Interrupt*/
+		/* Enable Power Down Logic Interrupt */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuintsel = 1;
 		gpwrdn.b.pmuactv = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+				 gpwrdn.d32);
 		/* Initialize first ADP probe to obtain Ramp Time value */
 		core_if->adp.initial_probe = 1;
 		dwc_otg_adp_probe_start(core_if);
 	} else {
 		gotgctl_data_t gotgctl;
-		gotgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+		gotgctl.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 		DWC_PRINTF("DEVICE MODE\n");
-		//dwc_otg_core_init(core_if);
+		/* dwc_otg_core_init(core_if); */
 		if (gotgctl.b.bsesvld == 0) {
-			/* Enable Power Down Logic Interrupt*/
+			/* Enable Power Down Logic Interrupt */
 			gpwrdn.d32 = 0;
 			DWC_PRINTF("VBUS is not valid - start ADP probe\n");
 			gpwrdn.b.pmuintsel = 1;
 			gpwrdn.b.pmuactv = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+					 gpwrdn.d32);
 			core_if->adp.initial_probe = 1;
 			dwc_otg_adp_probe_start(core_if);
 		} else {
-			DWC_PRINTF("VBUS is valid - initialize core as a Device\n");
+			DWC_PRINTF
+			    ("VBUS is valid - initialize core as a Device\n");
 			core_if->op_state = B_PERIPHERAL;
-			//dwc_otg_core_init(core_if);
+			/* dwc_otg_core_init(core_if); */
 			dwc_otg_enable_global_interrupts(core_if);
 			cil_pcd_start(core_if);
 			dwc_otg_dump_global_registers(core_if);
@@ -512,7 +517,7 @@ void dwc_otg_adp_start(dwc_otg_core_if_t * core_if, uint8_t is_host)
 	}
 }
 
-void dwc_otg_adp_init(dwc_otg_core_if_t * core_if)
+void dwc_otg_adp_init(dwc_otg_core_if_t *core_if)
 {
 	core_if->adp.adp_started = 0;
 	core_if->adp.initial_probe = 0;
@@ -531,37 +536,33 @@ void dwc_otg_adp_init(dwc_otg_core_if_t * core_if)
 	core_if->adp.vbuson_timer =
 	    DWC_TIMER_ALLOC("ADP VBUS ON TIMER", adp_vbuson_timeout, core_if);
 	if (!core_if->adp.sense_timer || !core_if->adp.vbuson_timer)
-	{
 		DWC_ERROR("Could not allocate memory for ADP timers\n");
-	}
 }
 
-void dwc_otg_adp_remove(dwc_otg_core_if_t * core_if)
+void dwc_otg_adp_remove(dwc_otg_core_if_t *core_if)
 {
-	gpwrdn_data_t gpwrdn = { .d32 = 0 };
+	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	gpwrdn.b.pmuintsel = 1;
 	gpwrdn.b.pmuactv = 1;
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
 
-	if (core_if->adp.probe_enabled)		
+	if (core_if->adp.probe_enabled)
 		dwc_otg_adp_probe_stop(core_if);
-	if (core_if->adp.sense_enabled)		
+	if (core_if->adp.sense_enabled)
 		dwc_otg_adp_sense_stop(core_if);
-	if (core_if->adp.sense_timer_started)		
+	if (core_if->adp.sense_timer_started)
 		DWC_TIMER_CANCEL(core_if->adp.sense_timer);
-	if (core_if->adp.vbuson_timer_started)		
+	if (core_if->adp.vbuson_timer_started)
 		DWC_TIMER_CANCEL(core_if->adp.vbuson_timer);
 	DWC_TIMER_FREE(core_if->adp.sense_timer);
 	DWC_TIMER_FREE(core_if->adp.vbuson_timer);
 }
 
-/////////////////////////////////////////////////////////////////////
-////////////// ADP Interrupt Handlers ///////////////////////////////
-/////////////////////////////////////////////////////////////////////
+/* ADP Interrupt Handlers */
 /**
  * This function sets Ramp Timer values
  */
-static uint32_t set_timer_value(dwc_otg_core_if_t * core_if, uint32_t val)
+static uint32_t set_timer_value(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	if (core_if->adp.probe_timer_values[0] == -1) {
 		core_if->adp.probe_timer_values[0] = val;
@@ -578,41 +579,47 @@ static uint32_t set_timer_value(dwc_otg_core_if_t * core_if, uint32_t val)
 /**
  * This function compares Ramp Timer values
  */
-static uint32_t compare_timer_values(dwc_otg_core_if_t * core_if)
+static uint32_t compare_timer_values(dwc_otg_core_if_t *core_if)
 {
 	uint32_t diff;
-	DWC_DEBUGPL(DBG_ANY, "timer value 0 %d timer value 1 %d\n", 
-		core_if->adp.probe_timer_values[0], core_if->adp.probe_timer_values[1]);
-	if (core_if->adp.probe_timer_values[0] >= core_if->adp.probe_timer_values[1])
-		diff = core_if->adp.probe_timer_values[0] - core_if->adp.probe_timer_values[1];
+	DWC_DEBUGPL(DBG_ANY, "timer value 0 %d timer value 1 %d\n",
+		    core_if->adp.probe_timer_values[0],
+		    core_if->adp.probe_timer_values[1]);
+	if (core_if->adp.probe_timer_values[0] >=
+	    core_if->adp.probe_timer_values[1])
+		diff =
+		    core_if->adp.probe_timer_values[0] -
+		    core_if->adp.probe_timer_values[1];
 	else
-		diff = core_if->adp.probe_timer_values[1] - core_if->adp.probe_timer_values[0];   	
-	if(diff < 3) {
+		diff =
+		    core_if->adp.probe_timer_values[1] -
+		    core_if->adp.probe_timer_values[0];
+	if (diff < 3)
 		return 0;
-	} else {
+	else
 		return 1;
-	}
 }
 
 /**
  * This function handles ADP Probe Interrupts
  */
-static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
-						 uint32_t val)
+static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t *core_if,
+					   uint32_t val)
 {
 	adpctl_data_t adpctl = {.d32 = 0 };
 	gpwrdn_data_t gpwrdn, temp;
 	adpctl.d32 = val;
 
 	temp.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
-	
-	core_if->adp.gpwrdn = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
-	if (adpctl.b.rtim == 0 /*&& !temp.b.idsts*/){
-		DWC_PRINTF("RTIM value is 0\n");	
+
+	core_if->adp.gpwrdn =
+	    DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
+	if (adpctl.b.rtim == 0 /*&& !temp.b.idsts */) {
+		DWC_PRINTF("RTIM value is 0\n");
 		goto exit;
 	}
 	core_if->adp.probe_counter++;
-	
+
 	if (set_timer_value(core_if, adpctl.b.rtim) &&
 	    core_if->adp.initial_probe) {
 		core_if->adp.initial_probe = 0;
@@ -620,8 +627,10 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuactv = 1;
 		gpwrdn.b.pmuintsel = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
-		DWC_WRITE_REG32(&core_if->core_global_regs->gintsts, 0xFFFFFFFF);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,
+				0xFFFFFFFF);
 
 		/* check which value is for device mode and which for Host mode */
 		if (!temp.b.idsts) {	/* considered host mode value is 0 */
@@ -641,18 +650,19 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 			dwc_otg_enable_global_interrupts(core_if);
 			dwc_otg_initiate_srp(core_if);
 		}
-	} else if (core_if->adp.probe_counter > 2){
+	} else if (core_if->adp.probe_counter > 2) {
 		gpwrdn.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
 		if (compare_timer_values(core_if)) {
 			DWC_PRINTF("Difference in timer values !!! \n");
-//          core_if->adp.attached = DWC_OTG_ADP_ATTACHED;
+			/* core_if->adp.attached = DWC_OTG_ADP_ATTACHED; */
 			dwc_otg_adp_probe_stop(core_if);
 
 			/* Power on the core */
 			if (core_if->power_down == 2) {
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 			}
 
 			/* check which value is for device mode and which for Host mode */
@@ -661,8 +671,9 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuintsel = 1;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn,
+						 gpwrdn.d32, 0);
 
 				/*
 				 * Initialize the Core for Host mode.
@@ -676,25 +687,29 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 				/* Mask SRP detected interrupt from Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.srp_det_msk = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn,
+						 gpwrdn.d32, 0);
 
 				/* Disable Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuintsel = 1;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn,
+						 gpwrdn.d32, 0);
 
 				/*
 				 * Initialize the Core for Device mode.
 				 */
 				core_if->op_state = B_PERIPHERAL;
-				//dwc_otg_core_init(core_if);
+				/* dwc_otg_core_init(core_if); */
 				cil_pcd_start(core_if);
 				dwc_otg_enable_global_interrupts(core_if);
 
-				gotgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+				gotgctl.d32 =
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gotgctl);
 				if (!gotgctl.b.bsesvld)
 					dwc_otg_initiate_srp(core_if);
 			}
@@ -704,12 +719,14 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 				/* Mask SRP detected interrupt from Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.srp_det_msk = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
-				
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
+
 				/* Disable Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
 
 				/*
 				 * Initialize the Core for Device mode.
@@ -733,7 +750,7 @@ static int32_t dwc_otg_adp_handle_prb_intr(dwc_otg_core_if_t * core_if,
 /**
  * This function hadles ADP Sense Interrupt
  */
-static int32_t dwc_otg_adp_handle_sns_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_adp_handle_sns_intr(dwc_otg_core_if_t *core_if)
 {
 	adpctl_data_t adpctl;
 	/* Stop ADP Sense timer */
@@ -741,7 +758,7 @@ static int32_t dwc_otg_adp_handle_sns_intr(dwc_otg_core_if_t * core_if)
 
 	/* Restart ADP Sense timer */
 	dwc_otg_adp_sense_timer_start(core_if);
-	
+
 	/* Clear interrupt */
 	adpctl.d32 = dwc_otg_adp_read_reg(core_if);
 	adpctl.b.adp_sns_int = 1;
@@ -753,13 +770,13 @@ static int32_t dwc_otg_adp_handle_sns_intr(dwc_otg_core_if_t * core_if)
 /**
  * This function handles ADP Probe Interrupts
  */
-static int32_t dwc_otg_adp_handle_prb_tmout_intr(dwc_otg_core_if_t * core_if,
+static int32_t dwc_otg_adp_handle_prb_tmout_intr(dwc_otg_core_if_t *core_if,
 						 uint32_t val)
 {
 	adpctl_data_t adpctl = {.d32 = 0 };
 	adpctl.d32 = val;
 	set_timer_value(core_if, adpctl.b.rtim);
-	
+
 	/* Clear interrupt */
 	adpctl.d32 = dwc_otg_adp_read_reg(core_if);
 	adpctl.b.adp_tmout_int = 1;
@@ -772,13 +789,13 @@ static int32_t dwc_otg_adp_handle_prb_tmout_intr(dwc_otg_core_if_t * core_if,
  * ADP Interrupt handler.
  *
  */
-int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t *core_if)
 {
 	int retval = 0;
-	adpctl_data_t adpctl = {.d32 = 0};
+	adpctl_data_t adpctl = {.d32 = 0 };
 
 	adpctl.d32 = dwc_otg_adp_read_reg(core_if);
-	DWC_PRINTF("ADPCTL = %08x\n",adpctl.d32);
+	DWC_PRINTF("ADPCTL = %08x\n", adpctl.d32);
 
 	if (adpctl.b.adp_sns_int & adpctl.b.adp_sns_int_msk) {
 		DWC_PRINTF("ADP Sense interrupt\n");
@@ -786,16 +803,16 @@ int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t * core_if)
 	}
 	if (adpctl.b.adp_tmout_int & adpctl.b.adp_tmout_int_msk) {
 		DWC_PRINTF("ADP timeout interrupt\n");
-		retval |= dwc_otg_adp_handle_prb_tmout_intr(core_if, adpctl.d32);
+		retval |=
+		    dwc_otg_adp_handle_prb_tmout_intr(core_if, adpctl.d32);
 	}
 	if (adpctl.b.adp_prb_int & adpctl.b.adp_prb_int_msk) {
 		DWC_PRINTF("ADP Probe interrupt\n");
-		adpctl.b.adp_prb_int = 1;	
+		adpctl.b.adp_prb_int = 1;
 		retval |= dwc_otg_adp_handle_prb_intr(core_if, adpctl.d32);
 	}
-
-//	dwc_otg_adp_modify_reg(core_if, adpctl.d32, 0);
-	//dwc_otg_adp_write_reg(core_if, adpctl.d32);
+	/* dwc_otg_adp_modify_reg(core_if, adpctl.d32, 0); */
+	/* dwc_otg_adp_write_reg(core_if, adpctl.d32); */
 	DWC_PRINTF("RETURN FROM ADP ISR\n");
 
 	return retval;
@@ -805,13 +822,14 @@ int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t *core_if)
 {
 
 #ifndef DWC_HOST_ONLY
 	hprt0_data_t hprt0;
 	gpwrdn_data_t gpwrdn;
-	DWC_DEBUGPL(DBG_ANY, "++ Power Down Logic Session Request Interrupt++\n");
+	DWC_DEBUGPL(DBG_ANY,
+		    "++ Power Down Logic Session Request Interrupt++\n");
 
 	gpwrdn.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
 	/* check which value is for device mode and which for Host mode */
@@ -824,8 +842,9 @@ int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t * core_if)
 			/* Power on the core */
 			if (core_if->power_down == 2) {
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 			}
 
 			core_if->op_state = A_HOST;
@@ -843,15 +862,16 @@ int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t * core_if)
 		 * if connect does not occur within 10 seconds. */
 		cil_hcd_session_start(core_if);
 	} else {
-		DWC_PRINTF("SRP: Device mode %s\n", __FUNCTION__);
+		DWC_PRINTF("SRP: Device mode %s\n", __func__);
 		if (core_if->adp_enable) {
 			dwc_otg_adp_probe_stop(core_if);
 
 			/* Power on the core */
 			if (core_if->power_down == 2) {
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 			}
 
 			gpwrdn.d32 = 0;
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_adp.h b/drivers/usb/dwc_otg_310/dwc_otg_adp.h
index d8c3f8512518..9d6b3189401c 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_adp.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_adp.h
@@ -47,7 +47,7 @@
 #define DWC_OTG_ADP_UNKOWN	2
 
 typedef struct dwc_otg_adp {
-	uint32_t adp_started;	
+	uint32_t adp_started;
 	uint32_t initial_probe;
 	int32_t probe_timer_values[2];
 	uint32_t probe_enabled;
@@ -65,16 +65,16 @@ typedef struct dwc_otg_adp {
  * Attach Detect Protocol functions
  */
 
-extern void dwc_otg_adp_write_reg(dwc_otg_core_if_t * core_if, uint32_t value);
-extern uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t * core_if);
-extern uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t * core_if);
-extern uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t * core_if);
-extern uint32_t dwc_otg_adp_probe_stop(dwc_otg_core_if_t * core_if);
-extern uint32_t dwc_otg_adp_sense_stop(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_adp_start(dwc_otg_core_if_t * core_if, uint8_t is_host);
-extern void dwc_otg_adp_init(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_adp_remove(dwc_otg_core_if_t * core_if);
-extern int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t * core_if);
-extern int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t * core_if);
+extern void dwc_otg_adp_write_reg(dwc_otg_core_if_t *core_if, uint32_t value);
+extern uint32_t dwc_otg_adp_read_reg(dwc_otg_core_if_t *core_if);
+extern uint32_t dwc_otg_adp_probe_start(dwc_otg_core_if_t *core_if);
+extern uint32_t dwc_otg_adp_sense_start(dwc_otg_core_if_t *core_if);
+extern uint32_t dwc_otg_adp_probe_stop(dwc_otg_core_if_t *core_if);
+extern uint32_t dwc_otg_adp_sense_stop(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_adp_start(dwc_otg_core_if_t *core_if, uint8_t is_host);
+extern void dwc_otg_adp_init(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_adp_remove(dwc_otg_core_if_t *core_if);
+extern int32_t dwc_otg_adp_handle_intr(dwc_otg_core_if_t *core_if);
+extern int32_t dwc_otg_adp_handle_srp_intr(dwc_otg_core_if_t *core_if);
 
-#endif //__DWC_OTG_ADP_H__
+#endif /* __DWC_OTG_ADP_H__ */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_attr.c b/drivers/usb/dwc_otg_310/dwc_otg_attr.c
index 5fce5067ad0a..0fa93d2d068e 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_attr.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_attr.c
@@ -214,28 +214,28 @@
 
  <tr>
  <td> rem_wakeup_pwrdn </td>
- <td> On read, shows the status core - hibernated or not. On write, initiates 
+ <td> On read, shows the status core - hibernated or not. On write, initiates
  a remote wakeup of the device from Hibernation. </td>
  <td> Read/Write</td>
  </tr>
 
  <tr>
  <td> mode_ch_tim_en </td>
- <td> This bit is used to enable or disable the host core to wait for 200 PHY 
+ <td> This bit is used to enable or disable the host core to wait for 200 PHY
  clock cycles at the end of Resume to change the opmode signal to the PHY to 00
  after Suspend or LPM. </td>
  <td> Read/Write</td>
  </tr>
- 
+
  <tr>
  <td> fr_interval </td>
- <td> On read, shows the value of HFIR Frame Interval. On write, dynamically 
+ <td> On read, shows the value of HFIR Frame Interval. On write, dynamically
  reload HFIR register during runtime. The application can write a value to this
- register only after the Port Enable bit of the Host Port Control and Status 
+ register only after the Port Enable bit of the Host Port Control and Status
  register (HPRT.PrtEnaPort) has been set </td>
  <td> Read/Write</td>
  </tr>
- 
+
  <tr>
  <td> disconnect_us </td>
  <td> On read, shows the status of disconnect_device_us. On write, sets disconnect_us
@@ -297,13 +297,13 @@
  <td> Shows sleep status of device.
  <td> Read</td>
  </tr>
- 
+
  <tr>
  <td> hird_thres </td>
  <td> Gets or sets the "HIRD_Thres[3:0]" bits in the Core LPM Configuration Register.
  <td> Read/Write</td>
  </tr>
- 
+
  <tr>
  <td> besl_reject </td>
  <td> Gets or sets the "besl_reject" bit in the Device Control Register.
@@ -332,18 +332,17 @@
  * MACROs for defining sysfs attribute
  */
 
-
-#define DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_string_) \
-static ssize_t _otg_attr_name_##_show (struct device *_dev, struct device_attribute *attr, char *buf) \
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_, _string_) \
+static ssize_t _otg_attr_name_##_show(struct device *_dev, struct device_attribute *attr, char *buf) \
 { \
 	 \
 	dwc_otg_device_t *otg_dev = _dev->platform_data;		\
 	uint32_t val; \
-	val = dwc_otg_get_##_otg_attr_name_ (otg_dev->core_if); \
-	return sprintf (buf, "%s = 0x%x\n", _string_, val); \
+	val = dwc_otg_get_##_otg_attr_name_(otg_dev->core_if); \
+	return sprintf(buf, "%s = 0x%x\n", _string_, val); \
 }
-#define DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_,_string_) \
-static ssize_t _otg_attr_name_##_store (struct device *_dev, struct device_attribute *attr, \
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_, _string_) \
+static ssize_t _otg_attr_name_##_store(struct device *_dev, struct device_attribute *attr, \
 					const char *buf, size_t count) \
 { \
 	 \
@@ -357,56 +356,58 @@ static ssize_t _otg_attr_name_##_store (struct device *_dev, struct device_attri
  * MACROs for defining sysfs attribute for 32-bit registers
  */
 
-#define DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_string_) \
-static ssize_t _otg_attr_name_##_show (struct device *_dev, struct device_attribute *attr, char *buf) \
+#define DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_, _string_) \
+static ssize_t _otg_attr_name_##_show(struct device *_dev, struct device_attribute *attr, char *buf) \
 { \
 	 \
 	dwc_otg_device_t *otg_dev = _dev->platform_data; \
 	uint32_t val; \
-	val = dwc_otg_get_##_otg_attr_name_ (otg_dev->core_if); \
-	return sprintf (buf, "%s = 0x%08x\n", _string_, val); \
+	val = dwc_otg_get_##_otg_attr_name_(otg_dev->core_if); \
+	return sprintf(buf, "%s = 0x%08x\n", _string_, val); \
 }
-#define DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_,_string_) \
-static ssize_t _otg_attr_name_##_store (struct device *_dev, struct device_attribute *attr, \
+#define DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_, _string_) \
+static ssize_t _otg_attr_name_##_store(struct device *_dev, struct device_attribute *attr, \
 					const char *buf, size_t count) \
 { \
 	 \
 	dwc_otg_device_t *otg_dev = _dev->platform_data; \
 	uint32_t val = simple_strtoul(buf, NULL, 16); \
-	dwc_otg_set_##_otg_attr_name_ (otg_dev->core_if, val); \
+	dwc_otg_set_##_otg_attr_name_(otg_dev->core_if, val); \
 	return count; \
 }
 
-#define DWC_OTG_DEVICE_ATTR_BITFIELD_RW(_otg_attr_name_,_string_) \
-DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_string_) \
-DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_,_string_) \
-DEVICE_ATTR(_otg_attr_name_,0644,_otg_attr_name_##_show,_otg_attr_name_##_store);
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_RW(_otg_attr_name_, _string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_, _string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_, _string_) \
+DEVICE_ATTR(_otg_attr_name_, 0644, _otg_attr_name_##_show, \
+	    _otg_attr_name_##_store);
 
-#define DWC_OTG_DEVICE_ATTR_BITFIELD_RO(_otg_attr_name_,_string_) \
-DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_string_) \
-DEVICE_ATTR(_otg_attr_name_,0444,_otg_attr_name_##_show,NULL);
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_RO(_otg_attr_name_, _string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_, _string_) \
+DEVICE_ATTR(_otg_attr_name_, 0444, _otg_attr_name_##_show, NULL);
 
-#define DWC_OTG_DEVICE_ATTR_REG32_RW(_otg_attr_name_,_addr_,_string_) \
-DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_string_) \
-DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_,_string_) \
-DEVICE_ATTR(_otg_attr_name_,0644,_otg_attr_name_##_show,_otg_attr_name_##_store);
+#define DWC_OTG_DEVICE_ATTR_REG32_RW(_otg_attr_name_, _addr_, _string_) \
+DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_, _string_) \
+DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_, _string_) \
+DEVICE_ATTR(_otg_attr_name_, 0644, _otg_attr_name_##_show, \
+	    _otg_attr_name_##_store);
 
-#define DWC_OTG_DEVICE_ATTR_REG32_RO(_otg_attr_name_,_addr_,_string_) \
-DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_string_) \
-DEVICE_ATTR(_otg_attr_name_,0444,_otg_attr_name_##_show,NULL);
+#define DWC_OTG_DEVICE_ATTR_REG32_RO(_otg_attr_name_, _addr_, _string_) \
+DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_, _string_) \
+DEVICE_ATTR(_otg_attr_name_, 0444, _otg_attr_name_##_show, NULL);
 
 void dwc_set_device_platform_data(struct platform_device *pdev, void *data)
 {
-	if(NULL == pdev || NULL == &pdev->dev)
-        DWC_ERROR("NULL Pointer in func %s \n", __func__);
+	if (NULL == pdev || NULL == &pdev->dev)
+		DWC_ERROR("NULL Pointer in func %s \n", __func__);
 
 	pdev->dev.platform_data = data;
 }
 
 void *dwc_get_device_platform_data(const struct platform_device *pdev)
 {
-	if(NULL == pdev || NULL == &pdev->dev)
-       DWC_ERROR("NULL Pointer in func %s \n", __func__);
+	if (NULL == pdev || NULL == &pdev->dev)
+		DWC_ERROR("NULL Pointer in func %s \n", __func__);
 
 	return pdev->dev.platform_data;
 }
@@ -421,7 +422,6 @@ static ssize_t regoffset_show(struct device *_dev,
 			      struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 
 	return snprintf(buf, sizeof("0xFFFFFFFF\n") + 1, "0x%08x\n",
@@ -429,22 +429,20 @@ static ssize_t regoffset_show(struct device *_dev,
 }
 
 /**
- * Set the register offset for the next Register Access 	Read/Write
+ * Set the register offset for the next Register Access Read/Write
  */
 static ssize_t regoffset_store(struct device *_dev,
 			       struct device_attribute *attr,
 			       const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t offset = simple_strtoul(buf, NULL, 16);
 
-	if (offset < SZ_256K) {
+	if (offset < SZ_256K)
 		otg_dev->os_dep.reg_offset = offset;
-	} else {
+	else
 		dev_err(_dev, "invalid offset\n");
-	}
 
 	return count;
 }
@@ -459,22 +457,23 @@ static ssize_t regvalue_show(struct device *_dev,
 			     struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t val;
 	volatile uint32_t *addr;
 
-	if (otg_dev->os_dep.reg_offset != 0xFFFFFFFF && 0 != otg_dev->os_dep.base) {
+	if (otg_dev->os_dep.reg_offset != 0xFFFFFFFF
+	    && 0 != otg_dev->os_dep.base) {
 		/* Calculate the address */
 		addr = (uint32_t *) (otg_dev->os_dep.reg_offset +
 				     (uint8_t *) otg_dev->os_dep.base);
 		val = DWC_READ_REG32(addr);
 		return snprintf(buf,
 				sizeof("Reg@0xFFFFFFFF = 0xFFFFFFFF\n") + 1,
-				"Reg@0x%06x = 0x%08x\n", otg_dev->os_dep.reg_offset,
-				val);
+				"Reg@0x%06x = 0x%08x\n",
+				otg_dev->os_dep.reg_offset, val);
 	} else {
-		dev_err(_dev, "Invalid offset (0x%0x)\n", otg_dev->os_dep.reg_offset);
+		dev_err(_dev, "Invalid offset (0x%0x)\n",
+			otg_dev->os_dep.reg_offset);
 		return sprintf(buf, "invalid offset\n");
 	}
 }
@@ -489,12 +488,14 @@ static ssize_t regvalue_store(struct device *_dev,
 			      const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	volatile uint32_t *addr;
 	uint32_t val = simple_strtoul(buf, NULL, 16);
-	//dev_dbg(_dev, "Offset=0x%08x Val=0x%08x\n", otg_dev->reg_offset, val);
-	if (otg_dev->os_dep.reg_offset != 0xFFFFFFFF && 0 != otg_dev->os_dep.base) {
+	/* dev_dbg(_dev, "Offset=0x%08x Val=0x%08x\n",
+	 * otg_dev->reg_offset, val);
+	 */
+	if (otg_dev->os_dep.reg_offset != 0xFFFFFFFF
+	    && 0 != otg_dev->os_dep.base) {
 		/* Calculate the address */
 		addr = (uint32_t *) (otg_dev->os_dep.reg_offset +
 				     (uint8_t *) otg_dev->os_dep.base);
@@ -517,8 +518,12 @@ DWC_OTG_DEVICE_ATTR_BITFIELD_RW(srpcapable, "SRPCapable");
 DWC_OTG_DEVICE_ATTR_BITFIELD_RW(hsic_connect, "HSIC Connect");
 DWC_OTG_DEVICE_ATTR_BITFIELD_RW(inv_sel_hsic, "Invert Select HSIC");
 
-//DWC_OTG_DEVICE_ATTR_BITFIELD_RW(buspower,&(otg_dev->core_if->core_global_regs->gotgctl),(1<<8),8,"Mode");
-//DWC_OTG_DEVICE_ATTR_BITFIELD_RW(bussuspend,&(otg_dev->core_if->core_global_regs->gotgctl),(1<<8),8,"Mode");
+/* DWC_OTG_DEVICE_ATTR_BITFIELD_RW(buspower,
+ * &(otg_dev->core_if->core_global_regs->gotgctl), (1<<8), 8, "Mode");
+ */
+/* DWC_OTG_DEVICE_ATTR_BITFIELD_RW(bussuspend,
+ * &(otg_dev->core_if->core_global_regs->gotgctl), (1<<8), 8, "Mode");
+ */
 DWC_OTG_DEVICE_ATTR_BITFIELD_RO(busconnected, "Bus Connected");
 
 DWC_OTG_DEVICE_ATTR_REG32_RW(gotgctl, 0, "GOTGCTL");
@@ -560,7 +565,6 @@ static ssize_t hnp_show(struct device *_dev,
 			struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "HstNegScs = 0x%x\n",
 		       dwc_otg_get_hnpstatus(otg_dev->core_if));
@@ -574,7 +578,6 @@ static ssize_t hnp_store(struct device *_dev,
 			 const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t in = simple_strtoul(buf, NULL, 16);
 	dwc_otg_set_hnpreq(otg_dev->core_if, in);
@@ -594,7 +597,6 @@ static ssize_t srp_show(struct device *_dev,
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "SesReqScs = 0x%x\n",
 		       dwc_otg_get_srpstatus(otg_dev->core_if));
@@ -612,7 +614,6 @@ static ssize_t srp_store(struct device *_dev,
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_pcd_initiate_srp(otg_dev->pcd);
 #endif
@@ -631,7 +632,6 @@ static ssize_t buspower_show(struct device *_dev,
 			     struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "Bus Power = 0x%x\n",
 		       dwc_otg_get_prtpower(otg_dev->core_if));
@@ -645,7 +645,6 @@ static ssize_t buspower_store(struct device *_dev,
 			      const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t on = simple_strtoul(buf, NULL, 16);
 	dwc_otg_set_prtpower(otg_dev->core_if, on);
@@ -664,7 +663,6 @@ static ssize_t bussuspend_show(struct device *_dev,
 			       struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "Bus Suspend = 0x%x\n",
 		       dwc_otg_get_prtsuspend(otg_dev->core_if));
@@ -678,7 +676,6 @@ static ssize_t bussuspend_store(struct device *_dev,
 				const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t in = simple_strtoul(buf, NULL, 16);
 	dwc_otg_set_prtsuspend(otg_dev->core_if, in);
@@ -694,7 +691,6 @@ static ssize_t mode_ch_tim_en_show(struct device *_dev,
 				   struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "Mode Change Ready Timer Enable = 0x%x\n",
 		       dwc_otg_get_mode_ch_tim(otg_dev->core_if));
@@ -708,7 +704,6 @@ static ssize_t mode_ch_tim_en_store(struct device *_dev,
 				    const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t in = simple_strtoul(buf, NULL, 16);
 	dwc_otg_set_mode_ch_tim(otg_dev->core_if, in);
@@ -724,7 +719,6 @@ static ssize_t fr_interval_show(struct device *_dev,
 				struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "Frame Interval = 0x%x\n",
 		       dwc_otg_get_fr_interval(otg_dev->core_if));
@@ -738,7 +732,6 @@ static ssize_t fr_interval_store(struct device *_dev,
 				 const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t in = simple_strtoul(buf, NULL, 10);
 	dwc_otg_set_fr_interval(otg_dev->core_if, in);
@@ -755,7 +748,6 @@ static ssize_t remote_wakeup_show(struct device *_dev,
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf,
 		       "Remote Wakeup Sig = %d Enabled = %d LPM Remote Wakeup = %d\n",
@@ -779,15 +771,14 @@ static ssize_t remote_wakeup_store(struct device *_dev,
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 
-	if (val & 1) {
+	if (val & 1)
 		dwc_otg_pcd_remote_wakeup(otg_dev->pcd, 1);
-	} else {
+	else
 		dwc_otg_pcd_remote_wakeup(otg_dev->pcd, 0);
-	}
+
 #endif /* DWC_HOST_ONLY */
 	return count;
 }
@@ -796,25 +787,24 @@ DEVICE_ATTR(remote_wakeup, S_IRUGO | S_IWUSR, remote_wakeup_show,
 	    remote_wakeup_store);
 
 /**
- * Show the whether core is hibernated or not. 					
+ * Show the whether core is hibernated or not.
  */
 static ssize_t rem_wakeup_pwrdn_show(struct device *_dev,
 				     struct device_attribute *attr, char *buf)
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
-	if (dwc_otg_get_core_state(otg_dev->core_if)) {
+	if (dwc_otg_get_core_state(otg_dev->core_if))
 		DWC_PRINTF("Core is in hibernation\n");
-	} else {
+	else
 		DWC_PRINTF("Core is not in hibernation\n");
-	}
+
 #endif /* DWC_HOST_ONLY */
 	return 0;
 }
 
-extern int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t *core_if,
 					      int rem_wakeup, int reset);
 
 /**
@@ -826,7 +816,6 @@ static ssize_t rem_wakeup_pwrdn_store(struct device *_dev,
 {
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_device_hibernation_restore(otg_dev->core_if, 1, 0);
 #endif
@@ -843,7 +832,6 @@ static ssize_t disconnect_us(struct device *_dev,
 
 #ifndef DWC_HOST_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 	DWC_PRINTF("The Passed value is %04x\n", val);
@@ -864,15 +852,13 @@ static ssize_t regdump_show(struct device *_dev,
 			    struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_dump_global_registers(otg_dev->core_if);
-	if (dwc_otg_is_host_mode(otg_dev->core_if)) {
+	if (dwc_otg_is_host_mode(otg_dev->core_if))
 		dwc_otg_dump_host_registers(otg_dev->core_if);
-	} else {
+	else
 		dwc_otg_dump_dev_registers(otg_dev->core_if);
 
-	}
 	return sprintf(buf, "Register Dump\n");
 }
 
@@ -886,7 +872,6 @@ static ssize_t spramdump_show(struct device *_dev,
 			      struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_dump_spram(otg_dev->core_if);
 
@@ -903,7 +888,6 @@ static ssize_t hcddump_show(struct device *_dev,
 {
 #ifndef DWC_DEVICE_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_hcd_dump_state(otg_dev->hcd);
 #endif /* DWC_DEVICE_ONLY */
@@ -922,7 +906,6 @@ static ssize_t hcd_frrem_show(struct device *_dev,
 {
 #ifndef DWC_DEVICE_ONLY
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_hcd_dump_frrem(otg_dev->hcd);
 #endif /* DWC_DEVICE_ONLY */
@@ -936,12 +919,11 @@ DEVICE_ATTR(hcd_frrem, S_IRUGO, hcd_frrem_show, 0);
  * output shows the number of times the register is read).
  */
 #define RW_REG_COUNT 10000000
-#define MSEC_PER_JIFFIE 1000/HZ
+#define MSEC_PER_JIFFIE (1000/HZ)
 static ssize_t rd_reg_test_show(struct device *_dev,
 				struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	int i;
 	int time;
@@ -950,9 +932,8 @@ static ssize_t rd_reg_test_show(struct device *_dev,
 	printk("HZ %d, MSEC_PER_JIFFIE %d, loops_per_jiffy %lu\n",
 	       HZ, MSEC_PER_JIFFIE, loops_per_jiffy);
 	start_jiffies = jiffies;
-	for (i = 0; i < RW_REG_COUNT; i++) {
+	for (i = 0; i < RW_REG_COUNT; i++)
 		dwc_otg_get_gnptxfsiz(otg_dev->core_if);
-	}
 	time = jiffies - start_jiffies;
 	return sprintf(buf,
 		       "Time to read GNPTXFSIZ reg %d times: %d msecs (%d jiffies)\n",
@@ -969,7 +950,6 @@ static ssize_t wr_reg_test_show(struct device *_dev,
 				struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t reg_val;
 	int i;
@@ -980,9 +960,8 @@ static ssize_t wr_reg_test_show(struct device *_dev,
 	       HZ, MSEC_PER_JIFFIE, loops_per_jiffy);
 	reg_val = dwc_otg_get_gnptxfsiz(otg_dev->core_if);
 	start_jiffies = jiffies;
-	for (i = 0; i < RW_REG_COUNT; i++) {
+	for (i = 0; i < RW_REG_COUNT; i++)
 		dwc_otg_set_gnptxfsiz(otg_dev->core_if, reg_val);
-	}
 	time = jiffies - start_jiffies;
 	return sprintf(buf,
 		       "Time to write GNPTXFSIZ reg %d times: %d msecs (%d jiffies)\n",
@@ -1000,14 +979,13 @@ static ssize_t lpmresp_show(struct device *_dev,
 			    struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return sprintf(buf, "** LPM is DISABLED **\n");
 
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return sprintf(buf, "** Current mode is not device mode\n");
-	}
+
 	return sprintf(buf, "lpm_response = %d\n",
 		       dwc_otg_get_lpmresponse(otg_dev->core_if));
 }
@@ -1020,17 +998,14 @@ static ssize_t lpmresp_store(struct device *_dev,
 			     const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 
-	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if)) {
+	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return 0;
-	}
 
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return 0;
-	}
 
 	dwc_otg_set_lpmresponse(otg_dev->core_if, val);
 	return count;
@@ -1042,51 +1017,45 @@ DEVICE_ATTR(lpm_response, S_IRUGO | S_IWUSR, lpmresp_show, lpmresp_store);
 * Show the besl_reject attribute.
 */
 static ssize_t beslreject_show(struct device *_dev,
-			    struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
- 	
+
 	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return sprintf(buf, "** LPM is DISABLED **\n");
 	if (!dwc_otg_get_param_besl_enable(otg_dev->core_if))
-		return sprintf(buf, "** EnBesl is DISABLED **\n");	
+		return sprintf(buf, "** EnBesl is DISABLED **\n");
 
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return sprintf(buf, "** Current mode is not device mode\n");
-	}
-			
+
 	return sprintf(buf, "besl_reject = %d\n",
-		        dwc_otg_get_beslreject(otg_dev->core_if));
+		       dwc_otg_get_beslreject(otg_dev->core_if));
 }
 
 /**
 * Store the besl_reject attribute.
 */
 static ssize_t beslreject_store(struct device *_dev,
-			     struct device_attribute *attr,
-			     const char *buf, size_t count)
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 
-	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if)) {
+	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return 0;
-	}
-	
-	if (!dwc_otg_get_param_besl_enable(otg_dev->core_if)) {
+
+	if (!dwc_otg_get_param_besl_enable(otg_dev->core_if))
 		return 0;
-	}
 
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return 0;
-	}
-	
-	 dwc_otg_set_beslreject(otg_dev->core_if,val);
-			
+
+	dwc_otg_set_beslreject(otg_dev->core_if, val);
+
 	return count;
 }
 
@@ -1096,46 +1065,41 @@ DEVICE_ATTR(besl_reject, S_IRUGO | S_IWUSR, beslreject_show, beslreject_store);
 * Show the hird_thresh attribute.
 */
 static ssize_t hirdthresh_show(struct device *_dev,
-			    struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
-  		
+
 	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return sprintf(buf, "** LPM is DISABLED **\n");
-	
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return sprintf(buf, "** Current mode is not device mode\n");
-	}
-			
+
 	return sprintf(buf, "hirdthresh = 0x%x\n",
-		        dwc_otg_get_hirdthresh(otg_dev->core_if));
+		       dwc_otg_get_hirdthresh(otg_dev->core_if));
 }
 
 /**
 * Store the hird_thresh attribute.
 */
 static ssize_t hirdthresh_store(struct device *_dev,
-			     struct device_attribute *attr,
-			     const char *buf, size_t count)
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 
-	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if)) {
+	if (!dwc_otg_get_param_lpm_enable(otg_dev->core_if))
 		return 0;
-	}
-	
-	if (!dwc_otg_is_device_mode(otg_dev->core_if)) {
+
+	if (!dwc_otg_is_device_mode(otg_dev->core_if))
 		return 0;
-	}
-	
-	 dwc_otg_set_hirdthresh(otg_dev->core_if,val);
-			
+
+	dwc_otg_set_hirdthresh(otg_dev->core_if, val);
+
 	return count;
 }
 
@@ -1148,7 +1112,6 @@ static ssize_t sleepstatus_show(struct device *_dev,
 				struct device_attribute *attr, char *buf)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	return sprintf(buf, "Sleep Status = %d\n",
 		       dwc_otg_get_lpm_portsleepstatus(otg_dev->core_if));
@@ -1162,7 +1125,6 @@ static ssize_t sleepstatus_store(struct device *_dev,
 				 const char *buf, size_t count)
 {
 
-	
 	dwc_otg_device_t *otg_dev = _dev->platform_data;
 	dwc_otg_core_if_t *core_if = otg_dev->core_if;
 
@@ -1187,10 +1149,7 @@ DEVICE_ATTR(sleep_status, S_IRUGO | S_IWUSR, sleepstatus_show,
 /**
  * Create the device files
  */
-void dwc_otg_attr_create(
-
-				struct platform_device *dev
-    )
+void dwc_otg_attr_create(struct platform_device *dev)
 {
 	int error;
 
@@ -1240,10 +1199,7 @@ void dwc_otg_attr_create(
 /**
  * Remove the device files
  */
-void dwc_otg_attr_remove(
-
-				struct platform_device *dev
-    )
+void dwc_otg_attr_remove(struct platform_device *dev)
 {
 	device_remove_file(&dev->dev, &dev_attr_regoffset);
 	device_remove_file(&dev->dev, &dev_attr_regvalue);
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_attr.h b/drivers/usb/dwc_otg_310/dwc_otg_attr.h
index 86f93790f2c6..7d483eb3f14e 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_attr.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_attr.h
@@ -7,7 +7,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -17,7 +17,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -66,16 +66,17 @@ extern struct device_attribute dev_attr_hprt0;
 extern struct device_attribute dev_attr_lpm_response;
 extern struct device_attribute devi_attr_sleep_status;
 #endif
-extern void dwc_set_device_platform_data(struct platform_device *pdev, void *data);
+extern void dwc_set_device_platform_data(struct platform_device *pdev,
+					 void *data);
 extern void *dwc_get_device_platform_data(const struct platform_device *pdev);
 
 void dwc_otg_attr_create(
 
 				struct platform_device *dev
-    );
+	);
 
 void dwc_otg_attr_remove(
 
 				struct platform_device *dev
-    );
+	);
 #endif
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_cfi.c b/drivers/usb/dwc_otg_310/dwc_otg_cfi.c
index a9878d6474a2..96c5e3eb1d82 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_cfi.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_cfi.c
@@ -2,7 +2,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -12,7 +12,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -26,10 +26,10 @@
  * DAMAGE.
  * ========================================================================== */
 
-/** @file 
+/** @file
  *
- * This file contains the most of the CFI(Core Feature Interface) 
- * implementation for the OTG. 
+ * This file contains the most of the CFI(Core Feature Interface)
+ * implementation for the OTG.
  */
 
 #ifdef DWC_UTE_CFI
@@ -40,28 +40,28 @@
 /** This definition should actually migrate to the Portability Library */
 #define DWC_CONSTANT_CPU_TO_LE16(x) (x)
 
-extern dwc_otg_pcd_ep_t *get_ep_by_addr(dwc_otg_pcd_t * pcd, u16 wIndex);
+extern dwc_otg_pcd_ep_t *get_ep_by_addr(dwc_otg_pcd_t *pcd, u16 wIndex);
 
-static int cfi_core_features_buf(uint8_t * buf, uint16_t buflen);
-static int cfi_get_feature_value(uint8_t * buf, uint16_t buflen,
+static int cfi_core_features_buf(uint8_t *buf, uint16_t buflen);
+static int cfi_get_feature_value(uint8_t *buf, uint16_t buflen,
 				 struct dwc_otg_pcd *pcd,
 				 struct cfi_usb_ctrlrequest *ctrl_req);
 static int cfi_set_feature_value(struct dwc_otg_pcd *pcd);
-static int cfi_ep_get_sg_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_sg_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 			     struct cfi_usb_ctrlrequest *req);
-static int cfi_ep_get_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_concat_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 				 struct cfi_usb_ctrlrequest *req);
-static int cfi_ep_get_align_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_align_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 				struct cfi_usb_ctrlrequest *req);
 static int cfi_preproc_reset(struct dwc_otg_pcd *pcd,
 			     struct cfi_usb_ctrlrequest *req);
-static void cfi_free_ep_bs_dyn_data(cfi_ep_t * cfiep);
+static void cfi_free_ep_bs_dyn_data(cfi_ep_t *cfiep);
 
-static uint16_t get_dfifo_size(dwc_otg_core_if_t * core_if);
-static int32_t get_rxfifo_size(dwc_otg_core_if_t * core_if, uint16_t wValue);
+static uint16_t get_dfifo_size(dwc_otg_core_if_t *core_if);
+static int32_t get_rxfifo_size(dwc_otg_core_if_t *core_if, uint16_t wValue);
 static int32_t get_txfifo_size(struct dwc_otg_pcd *pcd, uint16_t wValue);
 
-static uint8_t resize_fifos(dwc_otg_core_if_t * core_if);
+static uint8_t resize_fifos(dwc_otg_core_if_t *core_if);
 
 /** This is the header of the all features descriptor */
 static cfi_all_features_header_t all_props_desc_header = {
@@ -98,7 +98,7 @@ static cfi_feature_desc_header_t prop_descs[] = {
 	{
 	 .wFeatureID = DWC_CONSTANT_CPU_TO_LE16(FT_ID_DMA_CONCAT_SETUP),
 	 .bmAttributes = CFI_FEATURE_ATTR_RW,
-	 //.wDataLength  = DWC_CONSTANT_CPU_TO_LE16(6),
+	 /* .wDataLength  = DWC_CONSTANT_CPU_TO_LE16(6), */
 	 },
 
 	/* FT_ID_DMA_CIRCULAR */
@@ -153,10 +153,10 @@ cfi_string_t prop_name_table[] = {
 
 /************************************************************************/
 
-/** 
- * Returns the name of the feature by its ID 
+/**
+ * Returns the name of the feature by its ID
  * or NULL if no featute ID matches.
- * 
+ *
  */
 const uint8_t *get_prop_name(uint16_t prop_id, int *len)
 {
@@ -174,7 +174,7 @@ const uint8_t *get_prop_name(uint16_t prop_id, int *len)
 
 /**
  * This function handles all CFI specific control requests.
- * 
+ *
  * Return a negative value to stall the DCE.
  */
 int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
@@ -189,8 +189,9 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
 	uint32_t regaddr = 0;
 	uint32_t regval = 0;
 
-	/* Save this Control Request in the CFI object. 
-	 * The data field will be assigned in the data stage completion CB function.
+	/* Save this Control Request in the CFI object.
+	 * The data field will be assigned in the data
+	 * stage completion CB function.
 	 */
 	cfi->ctrl_req = *ctrl;
 	cfi->ctrl_req.data = NULL;
@@ -202,11 +203,13 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
 	case VEN_CORE_GET_FEATURES:
 		retval = cfi_core_features_buf(cfi->buf_in.buf, CFI_IN_BUF_LEN);
 		if (retval >= 0) {
-			//dump_msg(cfi->buf_in.buf, retval);
+			/* dump_msg(cfi->buf_in.buf, retval); */
 			ep = &pcd->ep0;
 
 			retval = min((uint16_t) retval, wLen);
-			/* Transfer this buffer to the host through the EP0-IN EP */
+			/* Transfer this buffer to the host
+			 * through the EP0-IN EP
+			 */
 			ep->dwc_ep.dma_addr = cfi->buf_in.addr;
 			ep->dwc_ep.start_xfer_buff = cfi->buf_in.buf;
 			ep->dwc_ep.xfer_buff = cfi->buf_in.buf;
@@ -229,7 +232,9 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
 			ep = &pcd->ep0;
 
 			retval = min((uint16_t) retval, wLen);
-			/* Transfer this buffer to the host through the EP0-IN EP */
+			/* Transfer this buffer to the host
+			 * through the EP0-IN EP
+			 */
 			ep->dwc_ep.dma_addr = cfi->buf_in.addr;
 			ep->dwc_ep.start_xfer_buff = cfi->buf_in.buf;
 			ep->dwc_ep.xfer_buff = cfi->buf_in.buf;
@@ -280,14 +285,15 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
 
 	case VEN_CORE_READ_REGISTER:
 		CFI_INFO("VEN_CORE_READ_REGISTER\n");
-		/* wValue optionally contains the HI WORD of the register offset and
-		 * wIndex contains the LOW WORD of the register offset 
+		/* wValue optionally contains the HI WORD of
+		 * the register offset and wIndex contains
+		 * the LOW WORD of the register offset
 		 */
 		if (wValue == 0) {
 			/* @TODO - MAS - fix the access to the base field */
 			regaddr = 0;
-			//regaddr = (uint32_t) pcd->otg_dev->os_dep.base;
-			//GET_CORE_IF(pcd)->co
+			/* regaddr = (uint32_t) pcd->otg_dev->os_dep.base; */
+			/* GET_CORE_IF(pcd)->co */
 			regaddr |= wIndex;
 		} else {
 			regaddr = (wValue << 16) | wIndex;
@@ -345,7 +351,7 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
 /**
  * This function prepares the core features descriptors and copies its
  * raw representation into the buffer <buf>.
- * 
+ *
  * The buffer structure is as follows:
  *	all_features_header (8 bytes)
  *	features_#1 (8 bytes + feature name string length)
@@ -353,7 +359,7 @@ int cfi_setup(struct dwc_otg_pcd *pcd, struct cfi_usb_ctrlrequest *ctrl)
  *	.....
  *	features_#n - where n=the total count of feature descriptors
  */
-static int cfi_core_features_buf(uint8_t * buf, uint16_t buflen)
+static int cfi_core_features_buf(uint8_t *buf, uint16_t buflen)
 {
 	cfi_feature_desc_header_t *prop_hdr = prop_descs;
 	cfi_feature_desc_header_t *prop;
@@ -399,7 +405,7 @@ static int cfi_core_features_buf(uint8_t * buf, uint16_t buflen)
 /**
  * This function releases all the dynamic memory in the CFI object.
  */
-static void cfi_release(cfiobject_t * cfiobj)
+static void cfi_release(cfiobject_t *cfiobj)
 {
 	cfi_ep_t *cfiep;
 	dwc_list_link_t *tmp;
@@ -419,7 +425,7 @@ static void cfi_release(cfiobject_t * cfiobj)
 	}
 
 	/* Free the Buffer Setup values for each EP */
-	//list_for_each_entry(cfiep, &cfiobj->active_eps, lh) {
+	/* list_for_each_entry(cfiep, &cfiobj->active_eps, lh) { */
 	DWC_LIST_FOREACH(tmp, &cfiobj->active_eps) {
 		cfiep = DWC_LIST_ENTRY(tmp, struct cfi_ep, lh);
 		cfi_free_ep_bs_dyn_data(cfiep);
@@ -429,7 +435,7 @@ static void cfi_release(cfiobject_t * cfiobj)
 /**
  * This function frees the dynamically allocated EP buffer setup data.
  */
-static void cfi_free_ep_bs_dyn_data(cfi_ep_t * cfiep)
+static void cfi_free_ep_bs_dyn_data(cfi_ep_t *cfiep)
 {
 	if (cfiep->bm_sg) {
 		DWC_FREE(cfiep->bm_sg);
@@ -456,7 +462,7 @@ static void cfi_free_ep_bs_dyn_data(cfi_ep_t * cfiep)
  * for a specific endpoint and should be called only once when
  * the EP is enabled first time.
  */
-static int cfi_ep_init_defaults(struct dwc_otg_pcd *pcd, cfi_ep_t * cfiep)
+static int cfi_ep_init_defaults(struct dwc_otg_pcd *pcd, cfi_ep_t *cfiep)
 {
 	int retval = 0;
 
@@ -468,13 +474,14 @@ static int cfi_ep_init_defaults(struct dwc_otg_pcd *pcd, cfi_ep_t * cfiep)
 	dwc_memset(cfiep->bm_sg, 0, sizeof(ddma_sg_buffer_setup_t));
 
 	/* For the Concatenation feature's default value we do not allocate
-	 * memory for the wTxBytes field - it will be done in the set_feature_value
-	 * request handler.
+	 * memory for the wTxBytes field - it will be done in the
+	 * set_feature_value request handler.
 	 */
 	cfiep->bm_concat = DWC_ALLOC(sizeof(ddma_concat_buffer_setup_t));
 	if (NULL == cfiep->bm_concat) {
 		CFI_INFO
-		    ("Failed to allocate memory for CONCATENATION feature value\n");
+		    ("Failed to allocate memory for
+		     CONCATENATION feature value\n");
 		DWC_FREE(cfiep->bm_sg);
 		return -DWC_E_NO_MEMORY;
 	}
@@ -497,7 +504,7 @@ static int cfi_ep_init_defaults(struct dwc_otg_pcd *pcd, cfi_ep_t * cfiep)
  * The callback function that notifies the CFI on the activation of
  * an endpoint in the PCD. The following steps are done in this function:
  *
- *	Create a dynamically allocated cfi_ep_t object (a CFI wrapper to the PCD's 
+ *	Create a dynamically allocated cfi_ep_t object (a CFI wrapper to the PCD's
  *		active endpoint)
  *	Create MAX_DMA_DESCS_PER_EP count DMA Descriptors for the EP
  *	Set the Buffer Mode to standard
@@ -529,7 +536,8 @@ static int cfi_ep_enable(struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
 		/* Save the dwc_otg_pcd_ep pointer in the cfiep object */
 		cfiep->ep = ep;
 
-		/* Allocate the DMA Descriptors chain of MAX_DMA_DESCS_PER_EP count */
+		/* Allocate the DMA Descriptors chain of
+		 * MAX_DMA_DESCS_PER_EP count */
 		ep->dwc_ep.descs =
 		    DWC_DMA_ALLOC(MAX_DMA_DESCS_PER_EP *
 				  sizeof(dwc_otg_dma_desc_t),
@@ -542,15 +550,18 @@ static int cfi_ep_enable(struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
 
 		DWC_LIST_INIT(&cfiep->lh);
 
-		/* Set the buffer mode to BM_STANDARD. It will be modified 
+		/* Set the buffer mode to BM_STANDARD. It will be modified
 		 * when building descriptors for a specific buffer mode */
 		ep->dwc_ep.buff_mode = BM_STANDARD;
 
-		/* Create and initialize the default values for this EP's Buffer modes */
-		if ((retval = cfi_ep_init_defaults(pcd, cfiep)) < 0)
+		/* Create and initialize the default values
+		 * for this EP's Buffer modes */
+		retval = cfi_ep_init_defaults(pcd, cfiep);
+		if (retval < 0)
 			return retval;
 
-		/* Add the cfi_ep_t object to the CFI object's list of active endpoints */
+		/* Add the cfi_ep_t object to the CFI object's
+		 * list of active endpoints */
 		DWC_LIST_INSERT_TAIL(&cfi->active_eps, &cfiep->lh);
 		retval = 0;
 	} else {		/* The sought EP already is in the list */
@@ -564,7 +575,7 @@ static int cfi_ep_enable(struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
 /**
  * This function is called when the data stage of a 3-stage Control Write request
  * is complete.
- * 
+ *
  */
 static int cfi_ctrl_write_complete(struct cfiobject *cfi,
 				   struct dwc_otg_pcd *pcd)
@@ -573,7 +584,7 @@ static int cfi_ctrl_write_complete(struct cfiobject *cfi,
 	uint16_t wIndex, wValue;
 	uint8_t bRequest;
 	uint8_t *buf = cfi->buf_out.buf;
-	//struct usb_ctrlrequest *ctrl_req = &cfi->ctrl_req_saved;
+	/* struct usb_ctrlrequest *ctrl_req = &cfi->ctrl_req_saved; */
 	struct cfi_usb_ctrlrequest *ctrl_req = &cfi->ctrl_req;
 	int retval = -DWC_E_NOT_SUPPORTED;
 
@@ -583,7 +594,7 @@ static int cfi_ctrl_write_complete(struct cfiobject *cfi,
 	wIndex = DWC_CONSTANT_CPU_TO_LE16(ctrl_req->wIndex);
 	wValue = DWC_CONSTANT_CPU_TO_LE16(ctrl_req->wValue);
 
-	/* 
+	/*
 	 * Save the pointer to the data stage in the ctrl_req's <data> field.
 	 * The request should be already saved in the command stage by now.
 	 */
@@ -593,24 +604,26 @@ static int cfi_ctrl_write_complete(struct cfiobject *cfi,
 
 	switch (bRequest) {
 	case VEN_CORE_WRITE_REGISTER:
-		/* The buffer contains raw data of the new value for the register */
+		/* The buffer contains raw data of
+		 * the new value for the register */
 		reg_value = *((uint32_t *) buf);
 		if (wValue == 0) {
 			addr = 0;
-			//addr = (uint32_t) pcd->otg_dev->os_dep.base;
+			/* addr = (uint32_t) pcd->otg_dev->os_dep.base; */
 			addr += wIndex;
 		} else {
 			addr = (wValue << 16) | wIndex;
 		}
 
-		//writel(reg_value, addr);
+		/* writel(reg_value, addr); */
 
 		retval = 0;
 		cfi->need_status_in_complete = 1;
 		break;
 
 	case VEN_CORE_SET_FEATURE:
-		/* The buffer contains raw data of the new value of the feature */
+		/* The buffer contains raw data of
+		 * the new value of the feature */
 		retval = cfi_set_feature_value(pcd);
 		if (retval < 0)
 			return retval;
@@ -628,8 +641,8 @@ static int cfi_ctrl_write_complete(struct cfiobject *cfi,
 /**
  * This function builds the DMA descriptors for the SG buffer mode.
  */
-static void cfi_build_sg_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
-			       dwc_otg_pcd_request_t * req)
+static void cfi_build_sg_descs(struct cfiobject *cfi, cfi_ep_t *cfiep,
+			       dwc_otg_pcd_request_t *req)
 {
 	struct dwc_otg_pcd_ep *ep = cfiep->ep;
 	ddma_sg_buffer_setup_t *sgval = cfiep->bm_sg;
@@ -642,8 +655,8 @@ static void cfi_build_sg_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
 	txsize = sgval->wSize;
 	off = sgval->bOffset;
 
-//      CFI_INFO("%s: %s TXSIZE=0x%08x; OFFSET=0x%08x\n", 
-//              __func__, cfiep->ep->ep.name, txsize, off);
+	/* CFI_INFO("%s: %s TXSIZE=0x%08x; OFFSET=0x%08x\n",
+		    __func__, cfiep->ep->ep.name, txsize, off);*/
 
 	for (i = 0; i < sgval->bCount; i++) {
 		desc->status.b.bs = BS_HOST_BUSY;
@@ -672,8 +685,8 @@ static void cfi_build_sg_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
 /**
  * This function builds the DMA descriptors for the Concatenation buffer mode.
  */
-static void cfi_build_concat_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
-				   dwc_otg_pcd_request_t * req)
+static void cfi_build_concat_descs(struct cfiobject *cfi, cfi_ep_t *cfiep,
+				   dwc_otg_pcd_request_t *req)
 {
 	struct dwc_otg_pcd_ep *ep = cfiep->ep;
 	ddma_concat_buffer_setup_t *concatval = cfiep->bm_concat;
@@ -712,17 +725,18 @@ static void cfi_build_concat_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
 /**
  * This function builds the DMA descriptors for the Circular buffer mode
  */
-static void cfi_build_circ_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
-				 dwc_otg_pcd_request_t * req)
+static void cfi_build_circ_descs(struct cfiobject *cfi, cfi_ep_t *cfiep,
+				 dwc_otg_pcd_request_t *req)
 {
-	/* @todo: MAS - add implementation when this feature needs to be tested */
+	/* @todo: MAS - add implementation when
+	 * this feature needs to be tested */
 }
 
 /**
  * This function builds the DMA descriptors for the Alignment buffer mode
  */
-static void cfi_build_align_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
-				  dwc_otg_pcd_request_t * req)
+static void cfi_build_align_descs(struct cfiobject *cfi, cfi_ep_t *cfiep,
+				  dwc_otg_pcd_request_t *req)
 {
 	struct dwc_otg_pcd_ep *ep = cfiep->ep;
 	ddma_align_buffer_setup_t *alignval = cfiep->bm_align;
@@ -748,7 +762,7 @@ static void cfi_build_align_descs(struct cfiobject *cfi, cfi_ep_t * cfiep,
 static void cfi_build_descriptors(struct cfiobject *cfi,
 				  struct dwc_otg_pcd *pcd,
 				  struct dwc_otg_pcd_ep *ep,
-				  dwc_otg_pcd_request_t * req)
+				  dwc_otg_pcd_request_t *req)
 {
 	cfi_ep_t *cfiep;
 
@@ -789,7 +803,7 @@ static void cfi_build_descriptors(struct cfiobject *cfi,
  * Allocate DMA buffer for different Buffer modes.
  */
 static void *cfi_ep_alloc_buf(struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
-			      struct dwc_otg_pcd_ep *ep, dma_addr_t * dma,
+			      struct dwc_otg_pcd_ep *ep, dma_addr_t *dma,
 			      unsigned size, gfp_t flags)
 {
 	return DWC_DMA_ALLOC(size, dma);
@@ -798,7 +812,7 @@ static void *cfi_ep_alloc_buf(struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
 /**
  * This function initializes the CFI object.
  */
-int init_cfi(cfiobject_t * cfiobj)
+int init_cfi(cfiobject_t *cfiobj)
 {
 	CFI_INFO("%s\n", __func__);
 
@@ -834,9 +848,9 @@ int init_cfi(cfiobject_t * cfiobj)
 /**
  * This function reads the required feature's current value into the buffer
  *
- * @retval: Returns negative as error, or the data length of the feature  
+ * @retval: Returns negative as error, or the data length of the feature
  */
-static int cfi_get_feature_value(uint8_t * buf, uint16_t buflen,
+static int cfi_get_feature_value(uint8_t *buf, uint16_t buflen,
 				 struct dwc_otg_pcd *pcd,
 				 struct cfi_usb_ctrlrequest *ctrl_req)
 {
@@ -902,7 +916,7 @@ static int cfi_get_feature_value(uint8_t * buf, uint16_t buflen,
 /**
  * This function resets the SG for the specified EP to its default value
  */
-static int cfi_reset_sg_val(cfi_ep_t * cfiep)
+static int cfi_reset_sg_val(cfi_ep_t *cfiep)
 {
 	dwc_memset(cfiep->bm_sg, 0, sizeof(ddma_sg_buffer_setup_t));
 	return 0;
@@ -911,7 +925,7 @@ static int cfi_reset_sg_val(cfi_ep_t * cfiep)
 /**
  * This function resets the Alignment for the specified EP to its default value
  */
-static int cfi_reset_align_val(cfi_ep_t * cfiep)
+static int cfi_reset_align_val(cfi_ep_t *cfiep)
 {
 	dwc_memset(cfiep->bm_sg, 0, sizeof(ddma_sg_buffer_setup_t));
 	return 0;
@@ -919,10 +933,10 @@ static int cfi_reset_align_val(cfi_ep_t * cfiep)
 
 /**
  * This function resets the Concatenation for the specified EP to its default value
- * This function will also set the value of the wTxBytes field to NULL after 
+ * This function will also set the value of the wTxBytes field to NULL after
  * freeing the memory previously allocated for this field.
  */
-static int cfi_reset_concat_val(cfi_ep_t * cfiep)
+static int cfi_reset_concat_val(cfi_ep_t *cfiep)
 {
 	/* First we need to free the wTxBytes field */
 	if (cfiep->bm_concat->wTxBytes) {
@@ -937,7 +951,7 @@ static int cfi_reset_concat_val(cfi_ep_t * cfiep)
 /**
  * This function resets all the buffer setups of the specified endpoint
  */
-static int cfi_ep_reset_all_setup_vals(cfi_ep_t * cfiep)
+static int cfi_ep_reset_all_setup_vals(cfi_ep_t *cfiep)
 {
 	cfi_reset_sg_val(cfiep);
 	cfi_reset_align_val(cfiep);
@@ -985,9 +999,8 @@ static int cfi_handle_reset_fifo_val(struct dwc_otg_pcd *pcd, uint8_t ep_addr,
 			    params->dev_tx_fifo_size[ep->dwc_ep.tx_fifo_num -
 						     1];
 			params->dev_tx_fifo_size[ep->dwc_ep.tx_fifo_num - 1] =
-			    GET_CORE_IF(pcd)->init_txfsiz[ep->
-							  dwc_ep.tx_fifo_num -
-							  1];
+			    GET_CORE_IF(pcd)->init_txfsiz[ep->dwc_ep.
+							  tx_fifo_num - 1];
 		}
 	}
 
@@ -997,23 +1010,21 @@ static int cfi_handle_reset_fifo_val(struct dwc_otg_pcd *pcd, uint8_t ep_addr,
 		CFI_INFO
 		    ("%s: Error resetting the feature Reset All(FIFO size)\n",
 		     __func__);
-		if (rx_rst) {
+		if (rx_rst)
 			params->dev_rx_fifo_size = rx_siz;
-		}
 
 		if (tx_rst) {
 			if (ep_addr == 0) {
 				int i;
 				for (i = 0; i < core_if->hwcfg4.b.num_in_eps;
 				     i++) {
-					core_if->
-					    core_params->dev_tx_fifo_size[i] =
-					    tx_siz[i];
+					core_if->core_params->
+					    dev_tx_fifo_size[i] = tx_siz[i];
 				}
 			} else {
-				params->dev_tx_fifo_size[ep->
-							 dwc_ep.tx_fifo_num -
-							 1] = tx_siz[0];
+				params->dev_tx_fifo_size[ep->dwc_ep.
+							 tx_fifo_num - 1] =
+				    tx_siz[0];
 			}
 		}
 		retval = -DWC_E_INVALID;
@@ -1029,11 +1040,11 @@ static int cfi_handle_reset_all(struct dwc_otg_pcd *pcd, uint8_t addr)
 	dwc_list_link_t *tmp;
 
 	retval = cfi_handle_reset_fifo_val(pcd, addr, 1, 1);
-	if (retval < 0) {
+	if (retval < 0)
 		return retval;
-	}
 
-	/* If the EP address is known then reset the features for only that EP */
+	/* If the EP address is known then
+	 * reset the features for only that EP */
 	if (addr) {
 		cfiep = get_cfi_ep_by_addr(pcd->cfi, addr);
 		if (NULL == cfiep) {
@@ -1046,8 +1057,9 @@ static int cfi_handle_reset_all(struct dwc_otg_pcd *pcd, uint8_t addr)
 	}
 	/* Otherwise (wValue == 0), reset all features of all EP's */
 	else {
-		/* Traverse all the active EP's and reset the feature(s) value(s) */
-		//list_for_each_entry(cfiep, &cfi->active_eps, lh) {
+		/* Traverse all the active EP's and
+		 * reset the feature(s) value(s) */
+		/* list_for_each_entry(cfiep, &cfi->active_eps, lh) { */
 		DWC_LIST_FOREACH(tmp, &cfi->active_eps) {
 			cfiep = DWC_LIST_ENTRY(tmp, struct cfi_ep, lh);
 			retval = cfi_ep_reset_all_setup_vals(cfiep);
@@ -1071,7 +1083,9 @@ static int cfi_handle_reset_dma_buff_setup(struct dwc_otg_pcd *pcd,
 	cfiobject_t *cfi = pcd->cfi;
 	dwc_list_link_t *tmp;
 
-	/* If the EP address is known then reset the features for only that EP */
+	/* If the EP address is known then reset
+	 * the features for only that EP */
+
 	if (addr) {
 		cfiep = get_cfi_ep_by_addr(pcd->cfi, addr);
 		if (NULL == cfiep) {
@@ -1083,8 +1097,9 @@ static int cfi_handle_reset_dma_buff_setup(struct dwc_otg_pcd *pcd,
 	}
 	/* Otherwise (wValue == 0), reset all features of all EP's */
 	else {
-		/* Traverse all the active EP's and reset the feature(s) value(s) */
-		//list_for_each_entry(cfiep, &cfi->active_eps, lh) {
+		/* Traverse all the active EP's and
+		 * reset the feature(s) value(s) */
+		/* list_for_each_entry(cfiep, &cfi->active_eps, lh) { */
 		DWC_LIST_FOREACH(tmp, &cfi->active_eps) {
 			cfiep = DWC_LIST_ENTRY(tmp, struct cfi_ep, lh);
 			retval = cfi_reset_sg_val(cfiep);
@@ -1106,7 +1121,8 @@ static int cfi_handle_reset_concat_val(struct dwc_otg_pcd *pcd, uint8_t addr)
 	cfiobject_t *cfi = pcd->cfi;
 	dwc_list_link_t *tmp;
 
-	/* If the EP address is known then reset the features for only that EP */
+	/* If the EP address is known then
+	 * reset the features for only that EP */
 	if (addr) {
 		cfiep = get_cfi_ep_by_addr(pcd->cfi, addr);
 		if (NULL == cfiep) {
@@ -1118,8 +1134,9 @@ static int cfi_handle_reset_concat_val(struct dwc_otg_pcd *pcd, uint8_t addr)
 	}
 	/* Otherwise (wValue == 0), reset all features of all EP's */
 	else {
-		/* Traverse all the active EP's and reset the feature(s) value(s) */
-		//list_for_each_entry(cfiep, &cfi->active_eps, lh) {
+		/* Traverse all the active EP's and
+		 * reset the feature(s) value(s) */
+		/* list_for_each_entry(cfiep, &cfi->active_eps, lh) { */
 		DWC_LIST_FOREACH(tmp, &cfi->active_eps) {
 			cfiep = DWC_LIST_ENTRY(tmp, struct cfi_ep, lh);
 			retval = cfi_reset_concat_val(cfiep);
@@ -1154,7 +1171,7 @@ static int cfi_handle_reset_align_val(struct dwc_otg_pcd *pcd, uint8_t addr)
 	/* Otherwise (wValue == 0), reset all features of all EP's */
 	else {
 		/* Traverse all the active EP's and reset the feature(s) value(s) */
-		//list_for_each_entry(cfiep, &cfi->active_eps, lh) {
+		/* list_for_each_entry(cfiep, &cfi->active_eps, lh) { */
 		DWC_LIST_FOREACH(tmp, &cfi->active_eps) {
 			cfiep = DWC_LIST_ENTRY(tmp, struct cfi_ep, lh);
 			retval = cfi_reset_align_val(cfiep);
@@ -1216,7 +1233,7 @@ static int cfi_preproc_reset(struct dwc_otg_pcd *pcd,
 /**
  * This function sets a new value for the SG buffer setup.
  */
-static int cfi_ep_set_sg_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
+static int cfi_ep_set_sg_val(uint8_t *buf, struct dwc_otg_pcd *pcd)
 {
 	uint8_t inaddr, outaddr;
 	cfi_ep_t *epin, *epout;
@@ -1273,7 +1290,7 @@ static int cfi_ep_set_sg_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
 /**
  * This function sets a new value for the buffer Alignment setup.
  */
-static int cfi_ep_set_alignment_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
+static int cfi_ep_set_alignment_val(uint8_t *buf, struct dwc_otg_pcd *pcd)
 {
 	cfi_ep_t *ep;
 	uint8_t addr;
@@ -1299,7 +1316,7 @@ static int cfi_ep_set_alignment_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
 /**
  * This function sets a new value for the Concatenation buffer setup.
  */
-static int cfi_ep_set_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
+static int cfi_ep_set_concat_val(uint8_t *buf, struct dwc_otg_pcd *pcd)
 {
 	uint8_t addr;
 	cfi_ep_t *ep;
@@ -1372,13 +1389,13 @@ static int cfi_ep_set_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd)
 
 /**
  * This function calculates the total of all FIFO sizes
- * 
+ *
  * @param core_if Programming view of DWC_otg controller
  *
  * @return The total of data FIFO sizes.
  *
  */
-static uint16_t get_dfifo_size(dwc_otg_core_if_t * core_if)
+static uint16_t get_dfifo_size(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_params_t *params = core_if->core_params;
 	uint16_t dfifo_total = 0;
@@ -1389,22 +1406,21 @@ static uint16_t get_dfifo_size(dwc_otg_core_if_t * core_if)
 	    params->dev_rx_fifo_size + params->dev_nperio_tx_fifo_size;
 
 	/* Add up each TxFIFO size to the total */
-	for (i = 0; i < core_if->hwcfg4.b.num_in_eps; i++) {
+	for (i = 0; i < core_if->hwcfg4.b.num_in_eps; i++)
 		dfifo_total += params->dev_tx_fifo_size[i];
-	}
 
 	return dfifo_total;
 }
 
 /**
  * This function returns Rx FIFO size
- * 
+ *
  * @param core_if Programming view of DWC_otg controller
  *
  * @return The total of data FIFO sizes.
  *
  */
-static int32_t get_rxfifo_size(dwc_otg_core_if_t * core_if, uint16_t wValue)
+static int32_t get_rxfifo_size(dwc_otg_core_if_t *core_if, uint16_t wValue)
 {
 	switch (wValue >> 8) {
 	case 0:
@@ -1422,7 +1438,7 @@ static int32_t get_rxfifo_size(dwc_otg_core_if_t * core_if, uint16_t wValue)
 
 /**
  * This function returns Tx FIFO size for IN EP
- * 
+ *
  * @param core_if Programming view of DWC_otg controller
  *
  * @return The total of data FIFO sizes.
@@ -1451,13 +1467,14 @@ static int32_t get_txfifo_size(struct dwc_otg_pcd *pcd, uint16_t wValue)
 	case 0:
 		return (GET_CORE_IF(pcd)->pwron_txfsiz
 			[ep->dwc_ep.tx_fifo_num - 1] <
-			768) ? GET_CORE_IF(pcd)->pwron_txfsiz[ep->
-							      dwc_ep.tx_fifo_num
-							      - 1] : 32768;
+			768) ? GET_CORE_IF(pcd)->pwron_txfsiz[ep->dwc_ep.
+							      tx_fifo_num -
+							      1] : 32768;
 		break;
 	case 1:
-		return GET_CORE_IF(pcd)->core_params->
-		    dev_tx_fifo_size[ep->dwc_ep.num - 1];
+		return GET_CORE_IF(pcd)->core_params->dev_tx_fifo_size[ep->
+								       dwc_ep.
+								       num - 1];
 		break;
 	default:
 		return -DWC_E_INVALID;
@@ -1466,15 +1483,15 @@ static int32_t get_txfifo_size(struct dwc_otg_pcd *pcd, uint16_t wValue)
 }
 
 /**
- * This function checks if the submitted combination of 
+ * This function checks if the submitted combination of
  * device mode FIFO sizes is possible or not.
- * 
+ *
  * @param core_if Programming view of DWC_otg controller
  *
  * @return 1 if possible, 0 otherwise.
  *
  */
-static uint8_t check_fifo_sizes(dwc_otg_core_if_t * core_if)
+static uint8_t check_fifo_sizes(dwc_otg_core_if_t *core_if)
 {
 	uint16_t dfifo_actual = 0;
 	dwc_otg_core_params_t *params = core_if->core_params;
@@ -1484,13 +1501,11 @@ static uint8_t check_fifo_sizes(dwc_otg_core_if_t * core_if)
 	dfifo_actual =
 	    params->dev_rx_fifo_size + params->dev_nperio_tx_fifo_size;
 
-	for (i = 0; i < core_if->hwcfg4.b.num_in_eps; i++) {
+	for (i = 0; i < core_if->hwcfg4.b.num_in_eps; i++)
 		dfifo_actual += params->dev_tx_fifo_size[i];
-	}
 
-	if (dfifo_actual > core_if->total_fifo_size) {
+	if (dfifo_actual > core_if->total_fifo_size)
 		return 0;
-	}
 
 	if (params->dev_rx_fifo_size > 32768 || params->dev_rx_fifo_size < 16)
 		return 0;
@@ -1526,13 +1541,13 @@ static uint8_t check_fifo_sizes(dwc_otg_core_if_t * core_if)
 
 /**
  * This function resizes Device mode FIFOs
- * 
+ *
  * @param core_if Programming view of DWC_otg controller
  *
  * @return 1 if successful, 0 otherwise
  *
  */
-static uint8_t resize_fifos(dwc_otg_core_if_t * core_if)
+static uint8_t resize_fifos(dwc_otg_core_if_t *core_if)
 {
 	int i = 0;
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1548,9 +1563,8 @@ static uint8_t resize_fifos(dwc_otg_core_if_t * core_if)
 	uint16_t start_address;
 	uint8_t retval = 1;
 
-	if (!check_fifo_sizes(core_if)) {
+	if (!check_fifo_sizes(core_if))
 		return 0;
-	}
 
 	/* Configure data FIFO sizes */
 	if (core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo) {
@@ -1587,13 +1601,11 @@ static uint8_t resize_fifos(dwc_otg_core_if_t * core_if)
 		}
 
 		/** Check if register values are set correctly */
-		if (rx_fifo_size != DWC_READ_REG32(&global_regs->grxfsiz)) {
+		if (rx_fifo_size != DWC_READ_REG32(&global_regs->grxfsiz))
 			retval = 0;
-		}
 
-		if (nptxfifosize.d32 != DWC_READ_REG32(&global_regs->gnptxfsiz)) {
+		if (nptxfifosize.d32 != DWC_READ_REG32(&global_regs->gnptxfsiz))
 			retval = 0;
-		}
 
 		for (i = 0; i < core_if->hwcfg4.b.num_in_eps; i++) {
 			if (txfifosize[i].d32 !=
@@ -1628,7 +1640,7 @@ static uint8_t resize_fifos(dwc_otg_core_if_t * core_if)
 /**
  * This function sets a new value for the buffer Alignment setup.
  */
-static int cfi_ep_set_tx_fifo_val(uint8_t * buf, dwc_otg_pcd_t * pcd)
+static int cfi_ep_set_tx_fifo_val(uint8_t *buf, dwc_otg_pcd_t *pcd)
 {
 	int retval;
 	uint32_t fsiz;
@@ -1673,7 +1685,7 @@ static int cfi_ep_set_tx_fifo_val(uint8_t * buf, dwc_otg_pcd_t * pcd)
 /**
  * This function sets a new value for the buffer Alignment setup.
  */
-static int cfi_set_rx_fifo_val(uint8_t * buf, dwc_otg_pcd_t * pcd)
+static int cfi_set_rx_fifo_val(uint8_t *buf, dwc_otg_pcd_t *pcd)
 {
 	int retval;
 	uint32_t fsiz;
@@ -1702,14 +1714,15 @@ static int cfi_set_rx_fifo_val(uint8_t * buf, dwc_otg_pcd_t * pcd)
 /**
  * This function reads the SG of an EP's buffer setup into the buffer buf
  */
-static int cfi_ep_get_sg_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_sg_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 			     struct cfi_usb_ctrlrequest *req)
 {
 	int retval = -DWC_E_INVALID;
 	uint8_t addr;
 	cfi_ep_t *ep;
 
-	/* The Low Byte of the wValue contains a non-zero address of the endpoint */
+	/* The Low Byte of the wValue contains
+	 * a non-zero address of the endpoint */
 	addr = req->wValue & 0xFF;
 	if (addr == 0)		/* The address should be non-zero */
 		return retval;
@@ -1727,10 +1740,10 @@ static int cfi_ep_get_sg_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
 }
 
 /**
- * This function reads the Concatenation value of an EP's buffer mode into 
+ * This function reads the Concatenation value of an EP's buffer mode into
  * the buffer buf
  */
-static int cfi_ep_get_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_concat_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 				 struct cfi_usb_ctrlrequest *req)
 {
 	int retval = -DWC_E_INVALID;
@@ -1738,7 +1751,8 @@ static int cfi_ep_get_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
 	cfi_ep_t *ep;
 	uint8_t desc_count;
 
-	/* The Low Byte of the wValue contains a non-zero address of the endpoint */
+	/* The Low Byte of the wValue contains
+	 * a non-zero address of the endpoint */
 	addr = req->wValue & 0xFF;
 	if (addr == 0)		/* The address should be non-zero */
 		return retval;
@@ -1764,12 +1778,12 @@ static int cfi_ep_get_concat_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
 }
 
 /**
- * This function reads the buffer Alignment value of an EP's buffer mode into 
+ * This function reads the buffer Alignment value of an EP's buffer mode into
  * the buffer buf
  *
  * @return The total number of bytes copied to the buffer or negative error code.
  */
-static int cfi_ep_get_align_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
+static int cfi_ep_get_align_val(uint8_t *buf, struct dwc_otg_pcd *pcd,
 				struct cfi_usb_ctrlrequest *req)
 {
 	int retval = -DWC_E_INVALID;
@@ -1796,9 +1810,9 @@ static int cfi_ep_get_align_val(uint8_t * buf, struct dwc_otg_pcd *pcd,
 
 /**
  * This function sets a new value for the specified feature
- * 
+ *
  * @param	pcd	A pointer to the PCD object
- * 
+ *
  * @return 0 if successful, negative error code otherwise to stall the DCE.
  */
 static int cfi_set_feature_value(struct dwc_otg_pcd *pcd)
@@ -1823,7 +1837,8 @@ static int cfi_set_feature_value(struct dwc_otg_pcd *pcd)
 	switch (wIndex) {
 	case FT_ID_DMA_BUFFER_SETUP:
 		/* Modify the feature */
-		if ((retval = cfi_ep_set_sg_val(buf, pcd)) < 0)
+		retval = cfi_ep_set_sg_val(buf, pcd);
+		if (retval < 0)
 			return retval;
 
 		/* And send this request to the gadget */
@@ -1831,14 +1846,16 @@ static int cfi_set_feature_value(struct dwc_otg_pcd *pcd)
 		break;
 
 	case FT_ID_DMA_BUFF_ALIGN:
-		if ((retval = cfi_ep_set_alignment_val(buf, pcd)) < 0)
+		retval = cfi_ep_set_alignment_val(buf, pcd);
+		if (retval < 0)
 			return retval;
 		cfi->need_gadget_att = 1;
 		break;
 
 	case FT_ID_DMA_CONCAT_SETUP:
 		/* Modify the feature */
-		if ((retval = cfi_ep_set_concat_val(buf, pcd)) < 0)
+		retval = cfi_ep_set_concat_val(buf, pcd);
+		if (retval < 0)
 			return retval;
 		cfi->need_gadget_att = 1;
 		break;
@@ -1857,14 +1874,16 @@ static int cfi_set_feature_value(struct dwc_otg_pcd *pcd)
 
 	case FT_ID_TX_FIFO_DEPTH:
 		CFI_INFO("FT_ID_TX_FIFO_DEPTH\n");
-		if ((retval = cfi_ep_set_tx_fifo_val(buf, pcd)) < 0)
+		retval = cfi_ep_set_tx_fifo_val(buf, pcd);
+		if (retval < 0)
 			return retval;
 		cfi->need_gadget_att = 0;
 		break;
 
 	case FT_ID_RX_FIFO_DEPTH:
 		CFI_INFO("FT_ID_RX_FIFO_DEPTH\n");
-		if ((retval = cfi_set_rx_fifo_val(buf, pcd)) < 0)
+		retval = cfi_set_rx_fifo_val(buf, pcd);
+		if (retval < 0)
 			return retval;
 		cfi->need_gadget_att = 0;
 		break;
@@ -1873,4 +1892,4 @@ static int cfi_set_feature_value(struct dwc_otg_pcd *pcd)
 	return retval;
 }
 
-#endif //DWC_UTE_CFI
+#endif /* DWC_UTE_CFI */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_cfi.h b/drivers/usb/dwc_otg_310/dwc_otg_cfi.h
index cbccdabe001b..4a07a80d649b 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_cfi.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_cfi.h
@@ -34,9 +34,9 @@
 
 /**
  * @file
- * This file contains the CFI related OTG PCD specific common constants, 
- * interfaces(functions and macros) and data structures.The CFI Protocol is an 
- * optional interface for internal testing purposes that a DUT may implement to 
+ * This file contains the CFI related OTG PCD specific common constants,
+ * interfaces(functions and macros) and data structures.The CFI Protocol is an
+ * optional interface for internal testing purposes that a DUT may implement to
  * support testing of configurable features.
  *
  */
@@ -65,10 +65,10 @@ struct dwc_otg_pcd_ep;
 #define CFI_INFO(fmt...)
 #endif
 
-#define min(x,y) ({ \
+#define min(x, y) ({ \
 	x < y ? x : y; })
 
-#define max(x,y) ({ \
+#define max(x, y) ({ \
 	x > y ? x : y; })
 
 /**
@@ -198,18 +198,18 @@ struct cfiobject;
  * @param	ctrl_write_complete	Called when the data stage of the request is complete
  */
 typedef struct cfi_ops {
-	int (*ep_enable) (struct cfiobject * cfi, struct dwc_otg_pcd * pcd,
-			  struct dwc_otg_pcd_ep * ep);
-	void *(*ep_alloc_buf) (struct cfiobject * cfi, struct dwc_otg_pcd * pcd,
-			       struct dwc_otg_pcd_ep * ep, dma_addr_t * dma,
+	int (*ep_enable) (struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
+			  struct dwc_otg_pcd_ep *ep);
+	void *(*ep_alloc_buf) (struct cfiobject *cfi, struct dwc_otg_pcd *pcd,
+			       struct dwc_otg_pcd_ep *ep, dma_addr_t *dma,
 			       unsigned size, gfp_t flags);
-	void (*release) (struct cfiobject * cfi);
-	int (*ctrl_write_complete) (struct cfiobject * cfi,
-				    struct dwc_otg_pcd * pcd);
-	void (*build_descriptors) (struct cfiobject * cfi,
-				   struct dwc_otg_pcd * pcd,
-				   struct dwc_otg_pcd_ep * ep,
-				   dwc_otg_pcd_request_t * req);
+	void (*release) (struct cfiobject *cfi);
+	int (*ctrl_write_complete) (struct cfiobject *cfi,
+				    struct dwc_otg_pcd *pcd);
+	void (*build_descriptors) (struct cfiobject *cfi,
+				   struct dwc_otg_pcd *pcd,
+				   struct dwc_otg_pcd_ep *ep,
+				   dwc_otg_pcd_request_t *req);
 } cfi_ops_t;
 
 struct cfiobject {
@@ -245,7 +245,7 @@ typedef struct cfiobject cfiobject_t;
 #define DUMP_MSG
 
 #if defined(DUMP_MSG)
-static inline void dump_msg(const u8 * buf, unsigned int length)
+static inline void dump_msg(const u8 *buf, unsigned int length)
 {
 	unsigned int start, num, i;
 	char line[52], *p;
@@ -271,7 +271,7 @@ static inline void dump_msg(const u8 * buf, unsigned int length)
 	}
 }
 #else
-static inline void dump_msg(const u8 * buf, unsigned int length)
+static inline void dump_msg(const u8 *buf, unsigned int length)
 {
 }
 #endif
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_cil.c b/drivers/usb/dwc_otg_310/dwc_otg_cil.c
index acd1c679fcb6..0ed45a84199b 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_cil.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_cil.c
@@ -51,7 +51,7 @@
  *
  * The Core Interface Layer has the following requirements:
  * - Provides basic controller operations.
- * - Minimal use of OS services. 
+ * - Minimal use of OS services.
  * - The OS services used will be abstracted by using inline functions
  *	 or macros.
  *
@@ -64,7 +64,7 @@
 #include "usbdev_rk.h"
 #include "dwc_otg_hcd.h"
 
-static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if);
+static int dwc_otg_setup_params(dwc_otg_core_if_t *core_if);
 
 /**
  * This function is called to initialize the DWC_otg CSR data
@@ -78,7 +78,7 @@ static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if);
  * @param reg_base_addr Base address of DWC_otg core registers
  *
  */
-dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
+dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t *reg_base_addr)
 {
 	dwc_otg_core_if_t *core_if = 0;
 	dwc_otg_dev_if_t *dev_if = 0;
@@ -126,7 +126,7 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
 			    i, &dev_if->out_ep_regs[i]->doepctl);
 	}
 
-	dev_if->speed = 0;	// unknown
+	dev_if->speed = 0;	/* unknown */
 
 	core_if->dev_if = dev_if;
 
@@ -194,15 +194,19 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
 	/* Force host mode to get HPTXFSIZ exact power on value */
 	{
 		gusbcfg_data_t gusbcfg = {.d32 = 0 };
-		gusbcfg.d32 =  DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
+		gusbcfg.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 		gusbcfg.b.force_host_mode = 1;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, gusbcfg.d32);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg,
+				gusbcfg.d32);
 		dwc_mdelay(100);
 		core_if->hptxfsiz.d32 =
 		    DWC_READ_REG32(&core_if->core_global_regs->hptxfsiz);
-		gusbcfg.d32 =  DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
+		gusbcfg.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 		gusbcfg.b.force_host_mode = 0;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, gusbcfg.d32);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg,
+				gusbcfg.d32);
 		dwc_mdelay(100);
 	}
 #endif
@@ -256,17 +260,17 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
 	}
 
 	core_if->snpsid = DWC_READ_REG32(&core_if->core_global_regs->gsnpsid);
-        DWC_PRINTF("%p\n",&core_if->core_global_regs->gsnpsid);
+	DWC_PRINTF("%p\n", &core_if->core_global_regs->gsnpsid);
 	DWC_PRINTF("Core Release: %x.%x%x%x\n",
 		   (core_if->snpsid >> 12 & 0xF),
 		   (core_if->snpsid >> 8 & 0xF),
 		   (core_if->snpsid >> 4 & 0xF), (core_if->snpsid & 0xF));
 
-        core_if->wkp_tasklet = DWC_TASK_ALLOC("wkp_tasklet", w_wakeup_detected, core_if);
+	core_if->wkp_tasklet =
+	    DWC_TASK_ALLOC("wkp_tasklet", w_wakeup_detected, core_if);
 
-	if (dwc_otg_setup_params(core_if)) {
+	if (dwc_otg_setup_params(core_if))
 		DWC_WARN("Error while setting core params\n");
-	}
 
 	core_if->hibernation_suspend = 0;
 	if (core_if->otg_ver)
@@ -274,7 +278,7 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
 
 	/** ADP initialization */
 	dwc_otg_adp_init(core_if);
-	
+
 	return core_if;
 }
 
@@ -282,10 +286,10 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * reg_base_addr)
  * This function frees the structures allocated by dwc_otg_cil_init().
  *
  * @param core_if The core interface pointer returned from
- * 		  dwc_otg_cil_init().
+ * dwc_otg_cil_init().
  *
  */
-void dwc_otg_cil_remove(dwc_otg_core_if_t * core_if)
+void dwc_otg_cil_remove(dwc_otg_core_if_t *core_if)
 {
 	dctl_data_t dctl = {.d32 = 0 };
 	/* Disable all interrupts */
@@ -302,24 +306,20 @@ void dwc_otg_cil_remove(dwc_otg_core_if_t * core_if)
 		DWC_WORKQ_WAIT_WORK_DONE(core_if->wq_otg, 500);
 		DWC_WORKQ_FREE(core_if->wq_otg);
 	}
-	if (core_if->dev_if) {
+	if (core_if->dev_if)
 		DWC_FREE(core_if->dev_if);
-	}
-	if (core_if->host_if) {
+	if (core_if->host_if)
 		DWC_FREE(core_if->host_if);
-	}
 
 	/** Remove ADP Stuff  */
 	dwc_otg_adp_remove(core_if);
-	if (core_if->core_params) {
+	if (core_if->core_params)
 		DWC_FREE(core_if->core_params);
-	}
-        if (core_if->wkp_tasklet){
-                DWC_TASK_FREE(core_if->wkp_tasklet);
-        }
-	if (core_if->srp_timer) {
+	if (core_if->wkp_tasklet)
+		DWC_TASK_FREE(core_if->wkp_tasklet);
+	if (core_if->srp_timer)
 		DWC_TIMER_FREE(core_if->srp_timer);
-	}
+
 	DWC_FREE(core_if);
 }
 
@@ -329,7 +329,7 @@ void dwc_otg_cil_remove(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_enable_global_interrupts(dwc_otg_core_if_t * core_if)
+void dwc_otg_enable_global_interrupts(dwc_otg_core_if_t *core_if)
 {
 	gahbcfg_data_t ahbcfg = {.d32 = 0 };
 	ahbcfg.b.glblintrmsk = 1;	/* Enable interrupts */
@@ -342,7 +342,7 @@ void dwc_otg_enable_global_interrupts(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_disable_global_interrupts(dwc_otg_core_if_t * core_if)
+void dwc_otg_disable_global_interrupts(dwc_otg_core_if_t *core_if)
 {
 	gahbcfg_data_t ahbcfg = {.d32 = 0 };
 	ahbcfg.b.glblintrmsk = 1;	/* Disable interrupts */
@@ -356,7 +356,7 @@ void dwc_otg_disable_global_interrupts(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of the DWC_otg controller
  *
  */
-static void dwc_otg_enable_common_interrupts(dwc_otg_core_if_t * core_if)
+static void dwc_otg_enable_common_interrupts(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	gintmsk_data_t intr_mask = {.d32 = 0 };
@@ -381,11 +381,10 @@ static void dwc_otg_enable_common_interrupts(dwc_otg_core_if_t * core_if)
 	intr_mask.b.wkupintr = 1;
 	intr_mask.b.disconnect = 0;
 	intr_mask.b.usbsuspend = 1;
-	//intr_mask.b.sessreqintr = 1;
+	/* intr_mask.b.sessreqintr = 1; */
 #ifdef CONFIG_USB_DWC_OTG_LPM
-	if (core_if->core_params->lpm_enable) {
+	if (core_if->core_params->lpm_enable)
 		intr_mask.b.lpmtranrcvd = 1;
-	}
 #endif
 	DWC_WRITE_REG32(&global_regs->gintmsk, intr_mask.d32);
 }
@@ -398,7 +397,7 @@ static void dwc_otg_enable_common_interrupts(dwc_otg_core_if_t * core_if)
  * @param rem_wakeup - indicates whether resume is initiated by Device or Host.
  * @param reset - indicates whether resume is initiated by Reset.
  */
-int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
+int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t *core_if,
 				       int rem_wakeup, int reset)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
@@ -412,7 +411,7 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 		return 1;
 	}
 
-	DWC_DEBUGPL(DBG_PCD, "%s called\n", __FUNCTION__);
+	DWC_DEBUGPL(DBG_PCD, "%s called\n", __func__);
 	/* Switch-on voltage to the core */
 	gpwrdn.b.pwrdnswtch = 1;
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
@@ -435,9 +434,8 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 	gpwrdn.b.pwrdnclmp = 1;
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
 
-	if (rem_wakeup) {
+	if (rem_wakeup)
 		dwc_udelay(70);
-	}
 
 	/* Deassert Reset core */
 	gpwrdn.d32 = 0;
@@ -476,7 +474,7 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 
 	if (core_if->hibernation_suspend == 0) {
 		/*
-		 * Wait For Restore_done Interrupt. This mechanism of polling the 
+		 * Wait For Restore_done Interrupt. This mechanism of polling the
 		 * interrupt is introduced to avoid any possible race conditions
 		 */
 		do {
@@ -486,15 +484,17 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 			if (gintsts.b.restoredone) {
 				gintsts.d32 = 0;
 				gintsts.b.restoredone = 1;
-				DWC_WRITE_REG32(&core_if->core_global_regs->
-						gintsts, gintsts.d32);
+				DWC_WRITE_REG32(&core_if->
+						core_global_regs->gintsts,
+						gintsts.d32);
 				DWC_PRINTF("Restore Done Interrupt seen\n");
 				break;
 			}
 			dwc_udelay(10);
 		} while (--timeout);
 		if (!timeout) {
-			DWC_PRINTF("Restore Done interrupt wasn't generated here\n");
+			DWC_PRINTF
+			    ("Restore Done interrupt wasn't generated here\n");
 		}
 	}
 	/* Clear all pending interupts */
@@ -527,12 +527,14 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 	if (!rem_wakeup) {
 		/* Set Device programming done bit */
 		dctl.b.pwronprgdone = 1;
-		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
+		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0,
+				 dctl.d32);
 	} else {
 		/* Start Remote Wakeup Signaling */
 		dctl.d32 = core_if->dr_backup->dctl;
 		dctl.b.rmtwkupsig = 1;
-		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
+		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				dctl.d32);
 	}
 
 	dwc_mdelay(2);
@@ -548,7 +550,8 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
 		dwc_mdelay(7);
 		dctl.d32 = 0;
 		dctl.b.rmtwkupsig = 1;
-		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32, 0);
+		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				 dctl.d32, 0);
 	}
 
 	core_if->hibernation_suspend = 0;
@@ -567,7 +570,7 @@ int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
  * @param rem_wakeup - indicates whether resume is initiated by Device or Host.
  * @param reset - indicates whether resume is initiated by Reset.
  */
-int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
+int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t *core_if,
 				     int rem_wakeup, int reset)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
@@ -575,7 +578,7 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 
 	int timeout = 2000;
 
-	DWC_DEBUGPL(DBG_HCD, "%s called\n", __FUNCTION__);
+	DWC_DEBUGPL(DBG_HCD, "%s called\n", __func__);
 	/* Switch-on voltage to the core */
 	gpwrdn.b.pwrdnswtch = 1;
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
@@ -598,9 +601,8 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 	gpwrdn.b.pwrdnclmp = 1;
 	DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
 
-	if (!rem_wakeup) {
+	if (!rem_wakeup)
 		dwc_udelay(50);
-	}
 
 	/* Deassert Reset core */
 	gpwrdn.d32 = 0;
@@ -637,22 +639,25 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 		 */
 		do {
 			gintsts_data_t gintsts;
-			gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
+			gintsts.d32 =
+			    DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 			if (gintsts.b.restoredone) {
 				gintsts.d32 = 0;
 				gintsts.b.restoredone = 1;
-         		DWC_WRITE_REG32(&core_if->core_global_regs->gintsts, gintsts.d32);
-				DWC_DEBUGPL(DBG_HCD,"Restore Done Interrupt seen\n");	
+				DWC_WRITE_REG32(&core_if->core_global_regs->
+						gintsts, gintsts.d32);
+				DWC_DEBUGPL(DBG_HCD,
+					    "Restore Done Interrupt seen\n");
 				break;
 			}
 			dwc_udelay(10);
 		} while (--timeout);
-		if (!timeout) {
+		if (!timeout)
 			DWC_WARN("Restore Done interrupt wasn't generated\n");
-		}
 	}
 
-	/* Set the flag's value to 0 again after receiving restore done interrupt */
+	/* Set the flag's value to 0 again after
+	 * receiving restore done interrupt */
 	core_if->hibernation_suspend = 0;
 
 	/* This step is not described in functional spec but if not wait for this
@@ -689,7 +694,8 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 	DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 
 	DWC_PRINTF("Resume Starts Now\n");
-	if (!reset) {		// Indicates it is Resume Operation
+	if (!reset) {
+		/* Indicates it is Resume Operation */
 		hprt0.d32 = core_if->hr_backup->hprt0_local;
 		hprt0.b.prtres = 1;
 		hprt0.b.prtpwr = 1;
@@ -703,7 +709,8 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 		dwc_mdelay(100);
 		DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 
-	} else {		// Indicates it is Reset Operation
+	} else {
+		/* Indicates it is Reset Operation */
 		hprt0.d32 = core_if->hr_backup->hprt0_local;
 		hprt0.b.prtrst = 1;
 		hprt0.b.prtpwr = 1;
@@ -736,7 +743,7 @@ int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
 }
 
 /** Saves some register values into system memory. */
-int dwc_otg_save_global_regs(dwc_otg_core_if_t * core_if)
+int dwc_otg_save_global_regs(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_global_regs_backup *gr;
 	int i;
@@ -744,9 +751,8 @@ int dwc_otg_save_global_regs(dwc_otg_core_if_t * core_if)
 	gr = core_if->gr_backup;
 	if (!gr) {
 		gr = DWC_ALLOC(sizeof(*gr));
-		if (!gr) {
+		if (!gr)
 			return -DWC_E_NO_MEMORY;
-		}
 		core_if->gr_backup = gr;
 	}
 
@@ -755,8 +761,10 @@ int dwc_otg_save_global_regs(dwc_otg_core_if_t * core_if)
 	gr->gahbcfg_local = DWC_READ_REG32(&core_if->core_global_regs->gahbcfg);
 	gr->gusbcfg_local = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 	gr->grxfsiz_local = DWC_READ_REG32(&core_if->core_global_regs->grxfsiz);
-	gr->gnptxfsiz_local = DWC_READ_REG32(&core_if->core_global_regs->gnptxfsiz);
-	gr->hptxfsiz_local = DWC_READ_REG32(&core_if->core_global_regs->hptxfsiz);
+	gr->gnptxfsiz_local =
+	    DWC_READ_REG32(&core_if->core_global_regs->gnptxfsiz);
+	gr->hptxfsiz_local =
+	    DWC_READ_REG32(&core_if->core_global_regs->hptxfsiz);
 #ifdef CONFIG_USB_DWC_OTG_LPM
 	gr->glpmcfg_local = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 #endif
@@ -784,34 +792,35 @@ int dwc_otg_save_global_regs(dwc_otg_core_if_t * core_if)
 #endif
 	DWC_DEBUGPL(DBG_ANY, "Backed up gi2cctl   = %08x\n", gr->gi2cctl_local);
 	DWC_DEBUGPL(DBG_ANY, "Backed up pcgcctl   = %08x\n", gr->pcgcctl_local);
-	DWC_DEBUGPL(DBG_ANY,"Backed up gdfifocfg   = %08x\n",gr->gdfifocfg_local);
+	DWC_DEBUGPL(DBG_ANY, "Backed up gdfifocfg   = %08x\n",
+		    gr->gdfifocfg_local);
 
 	return 0;
 }
 
 /** Saves GINTMSK register before setting the msk bits. */
-int dwc_otg_save_gintmsk_reg(dwc_otg_core_if_t * core_if)
+int dwc_otg_save_gintmsk_reg(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_global_regs_backup *gr;
 
 	gr = core_if->gr_backup;
 	if (!gr) {
 		gr = DWC_ALLOC(sizeof(*gr));
-		if (!gr) {
+		if (!gr)
 			return -DWC_E_NO_MEMORY;
-		}
 		core_if->gr_backup = gr;
 	}
 
 	gr->gintmsk_local = DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
 
-	DWC_DEBUGPL(DBG_ANY,"=============Backing GINTMSK registers============\n");
+	DWC_DEBUGPL(DBG_ANY,
+		    "=============Backing GINTMSK registers============\n");
 	DWC_DEBUGPL(DBG_ANY, "Backed up gintmsk   = %08x\n", gr->gintmsk_local);
 
 	return 0;
 }
 
-int dwc_otg_save_dev_regs(dwc_otg_core_if_t * core_if)
+int dwc_otg_save_dev_regs(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_dev_regs_backup *dr;
 	int i;
@@ -819,9 +828,8 @@ int dwc_otg_save_dev_regs(dwc_otg_core_if_t * core_if)
 	dr = core_if->dr_backup;
 	if (!dr) {
 		dr = DWC_ALLOC(sizeof(*dr));
-		if (!dr) {
+		if (!dr)
 			return -DWC_E_NO_MEMORY;
-		}
 		core_if->dr_backup = dr;
 	}
 
@@ -863,7 +871,7 @@ int dwc_otg_save_dev_regs(dwc_otg_core_if_t * core_if)
 	return 0;
 }
 
-int dwc_otg_save_host_regs(dwc_otg_core_if_t * core_if)
+int dwc_otg_save_host_regs(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_host_regs_backup *hr;
 	int i;
@@ -871,9 +879,8 @@ int dwc_otg_save_host_regs(dwc_otg_core_if_t * core_if)
 	hr = core_if->hr_backup;
 	if (!hr) {
 		hr = DWC_ALLOC(sizeof(*hr));
-		if (!hr) {
+		if (!hr)
 			return -DWC_E_NO_MEMORY;
-		}
 		core_if->hr_backup = hr;
 	}
 
@@ -906,15 +913,14 @@ int dwc_otg_save_host_regs(dwc_otg_core_if_t * core_if)
 	return 0;
 }
 
-int dwc_otg_restore_global_regs(dwc_otg_core_if_t * core_if)
+int dwc_otg_restore_global_regs(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_global_regs_backup *gr;
 	int i;
 
 	gr = core_if->gr_backup;
-	if (!gr) {
+	if (!gr)
 		return -DWC_E_INVALID;
-	}
 
 	DWC_WRITE_REG32(&core_if->core_global_regs->gotgctl, gr->gotgctl_local);
 	DWC_WRITE_REG32(&core_if->core_global_regs->gintmsk, gr->gintmsk_local);
@@ -939,7 +945,7 @@ int dwc_otg_restore_global_regs(dwc_otg_core_if_t * core_if)
 	return 0;
 }
 
-int dwc_otg_restore_dev_regs(dwc_otg_core_if_t * core_if, int rem_wakeup)
+int dwc_otg_restore_dev_regs(dwc_otg_core_if_t *core_if, int rem_wakeup)
 {
 	struct dwc_otg_dev_regs_backup *dr;
 	int i;
@@ -954,35 +960,43 @@ int dwc_otg_restore_dev_regs(dwc_otg_core_if_t * core_if, int rem_wakeup)
 		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
 				dr->dctl);
 	}
-	
-	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->daintmsk, dr->daintmsk);
-	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->diepmsk, dr->diepmsk);
-	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->doepmsk, dr->doepmsk);
+
+	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->daintmsk,
+			dr->daintmsk);
+	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->diepmsk,
+			dr->diepmsk);
+	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->doepmsk,
+			dr->doepmsk);
 
 	for (i = 0; i < core_if->dev_if->num_in_eps; ++i) {
-		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->dieptsiz, dr->dieptsiz[i]);
-		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->diepdma, dr->diepdma[i]);
-		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->diepctl, dr->diepctl[i]);
+		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->dieptsiz,
+				dr->dieptsiz[i]);
+		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->diepdma,
+				dr->diepdma[i]);
+		DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[i]->diepctl,
+				dr->diepctl[i]);
 	}
 
 	return 0;
 }
 
-int dwc_otg_restore_host_regs(dwc_otg_core_if_t * core_if, int reset)
+int dwc_otg_restore_host_regs(dwc_otg_core_if_t *core_if, int reset)
 {
 	struct dwc_otg_host_regs_backup *hr;
 	int i;
 	hr = core_if->hr_backup;
 
-	if (!hr) {
+	if (!hr)
 		return -DWC_E_INVALID;
-	}
 
-	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hcfg, hr->hcfg_local);
-	//if (!reset)
-	//{
-	//      DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hfir, hr->hfir_local);
-	//}
+	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hcfg,
+			hr->hcfg_local);
+	/* if (!reset)
+	 * {
+	 *	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hfir,
+	 *			hr->hfir_local);
+	 * }
+	 */
 
 	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->haintmsk,
 			hr->haintmsk_local);
@@ -994,7 +1008,7 @@ int dwc_otg_restore_host_regs(dwc_otg_core_if_t * core_if, int reset)
 	return 0;
 }
 
-int restore_lpm_i2c_regs(dwc_otg_core_if_t * core_if)
+int restore_lpm_i2c_regs(dwc_otg_core_if_t *core_if)
 {
 	struct dwc_otg_global_regs_backup *gr;
 
@@ -1009,7 +1023,7 @@ int restore_lpm_i2c_regs(dwc_otg_core_if_t * core_if)
 	return 0;
 }
 
-int restore_essential_regs(dwc_otg_core_if_t * core_if, int rmode, int is_host)
+int restore_essential_regs(dwc_otg_core_if_t *core_if, int rmode, int is_host)
 {
 	struct dwc_otg_global_regs_backup *gr;
 	pcgcctl_data_t pcgcctl = {.d32 = 0 };
@@ -1059,7 +1073,8 @@ int restore_essential_regs(dwc_otg_core_if_t * core_if, int rmode, int is_host)
 		DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
 		dwc_udelay(10);
 
-		/* Load restore values for [31:14] bits and set EssRegRestored bit */
+		/* Load restore values for [31:14] bits
+		 * and set EssRegRestored bit */
 		pcgcctl.d32 = gr->pcgcctl_local | 0xffffc000;
 		pcgcctl.d32 = gr->pcgcctl_local & 0xffffc000;
 		pcgcctl.b.ess_reg_restored = 1;
@@ -1069,14 +1084,14 @@ int restore_essential_regs(dwc_otg_core_if_t * core_if, int rmode, int is_host)
 	} else {
 		dcfg_data_t dcfg = {.d32 = 0 };
 		dcfg.d32 = core_if->dr_backup->dcfg;
-		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dcfg, dcfg.d32);
+		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dcfg,
+				dcfg.d32);
 
 		/* Load restore values for [31:14] bits */
 		pcgcctl.d32 = gr->pcgcctl_local & 0xffffc000;
 		pcgcctl.d32 = gr->pcgcctl_local | 0x00020000;
-		if (!rmode) {
+		if (!rmode)
 			pcgcctl.d32 |= 0x208;
-		}
 		DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
 		dwc_udelay(10);
 
@@ -1096,7 +1111,7 @@ int restore_essential_regs(dwc_otg_core_if_t * core_if, int rmode, int is_host)
  * Initializes the FSLSPClkSel field of the HCFG register depending on the PHY
  * type.
  */
-static void init_fslspclksel(dwc_otg_core_if_t * core_if)
+static void init_fslspclksel(dwc_otg_core_if_t *core_if)
 {
 	uint32_t val;
 	hcfg_data_t hcfg;
@@ -1122,7 +1137,7 @@ static void init_fslspclksel(dwc_otg_core_if_t * core_if)
  * Initializes the DevSpd field of the DCFG register depending on the PHY type
  * and the enumeration speed of the device.
  */
-static void init_devspd(dwc_otg_core_if_t * core_if)
+static void init_devspd(dwc_otg_core_if_t *core_if)
 {
 	uint32_t val;
 	dcfg_data_t dcfg;
@@ -1154,7 +1169,7 @@ static void init_devspd(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of the DWC_otg controller
  */
-static uint32_t calc_num_in_eps(dwc_otg_core_if_t * core_if)
+static uint32_t calc_num_in_eps(dwc_otg_core_if_t *core_if)
 {
 	uint32_t num_in_eps = 0;
 	uint32_t num_eps = core_if->hwcfg2.b.num_dev_ep;
@@ -1183,7 +1198,7 @@ static uint32_t calc_num_in_eps(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of the DWC_otg controller
  */
-static uint32_t calc_num_out_eps(dwc_otg_core_if_t * core_if)
+static uint32_t calc_num_out_eps(dwc_otg_core_if_t *core_if)
 {
 	uint32_t num_out_eps = 0;
 	uint32_t num_eps = core_if->hwcfg2.b.num_dev_ep;
@@ -1199,7 +1214,7 @@ static uint32_t calc_num_out_eps(dwc_otg_core_if_t * core_if)
 	return num_out_eps;
 }
 
-void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
+void dwc_otg_core_init(dwc_otg_core_if_t *core_if)
 {
 	int i = 0;
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1278,14 +1293,13 @@ void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
 			dwc_otg_core_reset(core_if);
 		}
 
-		/* Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS.      Also
+		/* Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS. Also
 		 * do this on HNP Dev/Host mode switches (done in dev_init and
 		 * host_init). */
-		if (dwc_otg_is_host_mode(core_if)) {
+		if (dwc_otg_is_host_mode(core_if))
 			init_fslspclksel(core_if);
-		} else {
+		else
 			init_devspd(core_if);
-		}
 
 		if (core_if->core_params->i2c_enable) {
 			DWC_DEBUGPL(DBG_CIL, "FS_PHY Enabling I2c\n");
@@ -1321,12 +1335,10 @@ void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
 			} else if (core_if->core_params->phy_type == 1) {
 				/* UTMI+ interface */
 				usbcfg.b.ulpi_utmi_sel = 0;
-				if (core_if->core_params->phy_utmi_width == 16) {
+				if (core_if->core_params->phy_utmi_width == 16)
 					usbcfg.b.phyif = 1;
-
-				} else {
+				else
 					usbcfg.b.phyif = 0;
-				}
 			} else {
 				DWC_ERROR("FS PHY TYPE\n");
 			}
@@ -1390,19 +1402,17 @@ void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
 
 	}
 	if (core_if->dma_enable) {
-		if (core_if->dma_desc_enable) {
+		if (core_if->dma_desc_enable)
 			DWC_PRINTF("Using Descriptor DMA mode\n");
-		} else {
+		else
 			DWC_PRINTF("Using Buffer DMA mode\n");
-		}
 	} else {
 		DWC_PRINTF("Using Slave mode\n");
 		core_if->dma_desc_enable = 0;
 	}
 
-	if (core_if->core_params->ahb_single) {
+	if (core_if->core_params->ahb_single)
 		ahbcfg.b.ahbsingle = 1;
-	}
 
 	ahbcfg.b.dmaenable = core_if->dma_enable;
 	DWC_WRITE_REG32(&global_regs->gahbcfg, ahbcfg.d32);
@@ -1506,16 +1516,17 @@ void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
 	/* Do device or host intialization based on mode during PCD
 	 * and HCD initialization  */
 	if (dwc_otg_is_host_mode(core_if)) {
-		DWC_PRINTF("^^^^^^^^^^^^^^^^^^Host Mode\n" );
+		DWC_PRINTF("^^^^^^^^^^^^^^^^^^Host Mode\n");
 		core_if->op_state = A_HOST;
 	} else {
-		DWC_PRINTF("^^^^^^^^^^^^^^^^^Device Mode\n" );
+		DWC_PRINTF("^^^^^^^^^^^^^^^^^Device Mode\n");
 		core_if->op_state = B_PERIPHERAL;
 #ifdef DWC_DEVICE_ONLY
 		dwc_otg_core_dev_init(core_if);
 #endif
 	}
 }
+
 /**
  * This function initializes the DWC_otg controller registers and
  * prepares the core for device mode or host mode operation.
@@ -1523,7 +1534,7 @@ void dwc_otg_core_init(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of the DWC_otg controller
  *
  */
-void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
+void dwc_otg_core_init_no_reset(dwc_otg_core_if_t *core_if)
 {
 	int i = 0;
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1547,7 +1558,7 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 	DWC_WRITE_REG32(&global_regs->gusbcfg, usbcfg.d32);
 
 	/* Reset the Controller */
-//	dwc_otg_core_reset(core_if);
+	/* dwc_otg_core_reset(core_if); */
 
 	core_if->adp_enable = core_if->core_params->adp_supp_enable;
 	core_if->power_down = core_if->core_params->power_down;
@@ -1599,17 +1610,16 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 			DWC_WRITE_REG32(&global_regs->gusbcfg, usbcfg.d32);
 
 			/* Reset after a PHY select */
-//			dwc_otg_core_reset(core_if);
+			/* dwc_otg_core_reset(core_if); */
 		}
 
-		/* Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS.      Also
+		/* Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS. Also
 		 * do this on HNP Dev/Host mode switches (done in dev_init and
 		 * host_init). */
-		if (dwc_otg_is_host_mode(core_if)) {
+		if (dwc_otg_is_host_mode(core_if))
 			init_fslspclksel(core_if);
-		} else {
+		else
 			init_devspd(core_if);
-		}
 
 		if (core_if->core_params->i2c_enable) {
 			DWC_DEBUGPL(DBG_CIL, "FS_PHY Enabling I2c\n");
@@ -1645,18 +1655,16 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 			} else if (core_if->core_params->phy_type == 1) {
 				/* UTMI+ interface */
 				usbcfg.b.ulpi_utmi_sel = 0;
-				if (core_if->core_params->phy_utmi_width == 16) {
+				if (core_if->core_params->phy_utmi_width == 16)
 					usbcfg.b.phyif = 1;
-
-				} else {
+				else
 					usbcfg.b.phyif = 0;
-				}
 			} else {
 				DWC_ERROR("FS PHY TYPE\n");
 			}
 			DWC_WRITE_REG32(&global_regs->gusbcfg, usbcfg.d32);
 			/* Reset after setting the PHY parameters */
-//			dwc_otg_core_reset(core_if);
+			/* dwc_otg_core_reset(core_if); */
 		}
 	}
 
@@ -1704,7 +1712,7 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 
 	case DWC_INT_DMA_ARCH:
 		DWC_DEBUGPL(DBG_CIL, "Internal DMA Mode\n");
-		/* Old value was DWC_GAHBCFG_INT_DMA_BURST_INCR - done for 
+		/* Old value was DWC_GAHBCFG_INT_DMA_BURST_INCR - done for
 		   Host mode ISOC in issue fix - vahrama */
 		ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR16;
 		core_if->dma_enable = (core_if->core_params->dma_enable != 0);
@@ -1714,19 +1722,17 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 
 	}
 	if (core_if->dma_enable) {
-		if (core_if->dma_desc_enable) {
+		if (core_if->dma_desc_enable)
 			DWC_PRINTF("Using Descriptor DMA mode\n");
-		} else {
+		else
 			DWC_PRINTF("Using Buffer DMA mode\n");
-		}
 	} else {
 		DWC_PRINTF("Using Slave mode\n");
 		core_if->dma_desc_enable = 0;
 	}
 
-	if (core_if->core_params->ahb_single) {
+	if (core_if->core_params->ahb_single)
 		ahbcfg.b.ahbsingle = 1;
-	}
 
 	ahbcfg.b.dmaenable = core_if->dma_enable;
 	DWC_WRITE_REG32(&global_regs->gahbcfg, ahbcfg.d32);
@@ -1830,10 +1836,10 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
 	/* Do device or host intialization based on mode during PCD
 	 * and HCD initialization  */
 	if (dwc_otg_is_host_mode(core_if)) {
-		DWC_PRINTF("^^^^^^^^^^^^^^^^^^Host Mode\n" );
+		DWC_PRINTF("^^^^^^^^^^^^^^^^^^Host Mode\n");
 		core_if->op_state = A_HOST;
 	} else {
-		DWC_PRINTF("^^^^^^^^^^^^^^^^^Device Mode\n" );
+		DWC_PRINTF("^^^^^^^^^^^^^^^^^Device Mode\n");
 		core_if->op_state = B_PERIPHERAL;
 #ifdef DWC_DEVICE_ONLY
 		dwc_otg_core_dev_init(core_if);
@@ -1846,7 +1852,7 @@ void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller
  */
-void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * core_if)
+void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t *core_if)
 {
 	gintmsk_data_t intr_mask = {.d32 = 0 };
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1875,11 +1881,10 @@ void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * core_if)
 
 	intr_mask.b.erlysuspend = 1;
 
-	if (core_if->en_multiple_tx_fifo == 0) {
+	if (core_if->en_multiple_tx_fifo == 0)
 		intr_mask.b.epmismatch = 1;
-	}
 
-	//intr_mask.b.incomplisoout = 1;
+	/* intr_mask.b.incomplisoout = 1; */
 	intr_mask.b.incomplisoin = 1;
 
 /* Enable the ignore frame number for ISOC xfers - MAS */
@@ -1890,11 +1895,12 @@ void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * core_if)
 		if (core_if->dma_desc_enable) {
 			dctl_data_t dctl1 = {.d32 = 0 };
 			dctl1.b.ifrmnum = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
-					 dctl, 0, dctl1.d32);
+			DWC_MODIFY_REG32(&core_if->dev_if->
+					 dev_global_regs->dctl, 0, dctl1.d32);
 			DWC_DEBUG("----Enabled Ignore frame number (0x%08x)",
-				  DWC_READ_REG32(&core_if->dev_if->
-						 dev_global_regs->dctl));
+				  DWC_READ_REG32(&core_if->
+						 dev_if->dev_global_regs->
+						 dctl));
 		}
 	}
 #endif
@@ -1905,9 +1911,9 @@ void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * core_if)
 			if (core_if->pti_enh_enable) {
 				dctl_data_t dctl = {.d32 = 0 };
 				dctl.b.ifrmnum = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 dev_if->dev_global_regs->dctl,
-						 0, dctl.d32);
+				DWC_MODIFY_REG32(&core_if->dev_if->
+						 dev_global_regs->dctl, 0,
+						 dctl.d32);
 			} else {
 				intr_mask.b.incomplisoin = 1;
 				intr_mask.b.incomplisoout = 1;
@@ -1940,7 +1946,7 @@ void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of DWC_otg controller
  *
  */
-void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
+void dwc_otg_core_dev_init(dwc_otg_core_if_t *core_if)
 {
 	int i;
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1954,12 +1960,12 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 	fifosize_data_t txfifosize;
 	dthrctl_data_t dthrctl;
 	fifosize_data_t ptxfifosize;
-//	uint16_t rxfsiz, nptxfsiz;
-//	gdfifocfg_data_t gdfifocfg = {.d32 = 0 };
-//	hwcfg3_data_t hwcfg3 = {.d32 = 0 };
+	/* uint16_t rxfsiz, nptxfsiz; */
+	/* gdfifocfg_data_t gdfifocfg = {.d32 = 0 }; */
+	/* hwcfg3_data_t hwcfg3 = {.d32 = 0 }; */
 	gotgctl_data_t gotgctl = {.d32 = 0 };
-	gahbcfg_data_t gahbcfg = {.d32 = 0};
-	
+	gahbcfg_data_t gahbcfg = {.d32 = 0 };
+
 	/* Restart the Phy Clock */
 	pcgcctl_data_t pcgcctl = {.d32 = 0 };
 	/* Restart the Phy Clock */
@@ -1968,7 +1974,7 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 	dwc_udelay(10);
 
 	gahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR16;
-	DWC_MODIFY_REG32(&global_regs->gahbcfg, 0 , gahbcfg.b.hburstlen);
+	DWC_MODIFY_REG32(&global_regs->gahbcfg, 0, gahbcfg.b.hburstlen);
 
 	/* Device configuration register */
 	init_devspd(core_if);
@@ -1976,9 +1982,8 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 	dcfg.b.descdma = (core_if->dma_desc_enable) ? 1 : 0;
 	dcfg.b.perfrint = DWC_DCFG_FRAME_INTERVAL_80;
 	/* Enable Device OUT NAK in case of DDMA mode */
-	if (core_if->core_params->dev_out_nak) {
+	if (core_if->core_params->dev_out_nak)
 		dcfg.b.endevoutnak = 1;
-	}
 
 	if (core_if->core_params->cont_on_bna) {
 		dctl_data_t dctl = {.d32 = 0 };
@@ -1989,13 +1994,14 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 	if (core_if->otg_ver) {
 		core_if->otg_sts = 0;
 		gotgctl.b.devhnpen = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gotgctl, gotgctl.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gotgctl,
+				 gotgctl.d32, 0);
 	}
-	
+
 	DWC_WRITE_REG32(&dev_if->dev_global_regs->dcfg, dcfg.d32);
 
 	/* Configure data FIFO sizes */
-	
+
 	if (core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo) {
 #ifdef DWC_UTE_CFI
 		core_if->pwron_rxfsiz = DWC_READ_REG32(&global_regs->grxfsiz);
@@ -2009,7 +2015,8 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 
 		/** Set Tx FIFO Mask all bits 0 */
 		core_if->tx_msk = 0;
-		/* core_if->en_multiple_tx_fifo equals core_if->hwcfg4.b.ded_fifo_en,
+		/* core_if->en_multiple_tx_fifo equals
+		 * core_if->hwcfg4.b.ded_fifo_en,
 		 * and ded_fifo_en is 1 in default*/
 		if (core_if->en_multiple_tx_fifo == 0) {
 			/* Non-periodic Tx FIFO */
@@ -2035,19 +2042,20 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 			/** @todo Finish debug of this */
 			ptxfifosize.b.startaddr =
 			    nptxfifosize.b.startaddr + nptxfifosize.b.depth;
-			for (i = 0; i < core_if->hwcfg4.b.num_dev_perio_in_ep; i++) {
+			for (i = 0; i < core_if->hwcfg4.b.num_dev_perio_in_ep;
+			     i++) {
 				ptxfifosize.b.depth =
 				    params->dev_perio_tx_fifo_size[i];
 				DWC_DEBUGPL(DBG_CIL,
 					    "initial dtxfsiz[%d]=%08x\n", i,
-					    DWC_READ_REG32(&global_regs->dtxfsiz
-							   [i]));
+					    DWC_READ_REG32(&global_regs->
+							   dtxfsiz[i]));
 				DWC_WRITE_REG32(&global_regs->dtxfsiz[i],
 						ptxfifosize.d32);
 				DWC_DEBUGPL(DBG_CIL, "new dtxfsiz[%d]=%08x\n",
 					    i,
-					    DWC_READ_REG32(&global_regs->dtxfsiz
-							   [i]));
+					    DWC_READ_REG32(&global_regs->
+							   dtxfsiz[i]));
 				ptxfifosize.b.startaddr += ptxfifosize.b.depth;
 			}
 		} else {
@@ -2113,25 +2121,30 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 
 				txfifosize.b.startaddr += txfifosize.b.depth;
 			}
-			#if 0
-			/* Calculating DFIFOCFG for Device mode to include RxFIFO and NPTXFIFO 
-			 * Before 3.00a EpInfoBase was being configured in ep enable/disable 
+#if 0
+			/* Calculating DFIFOCFG for Device mode to include RxFIFO and NPTXFIFO
+			 * Before 3.00a EpInfoBase was being configured in ep enable/disable
 			 * routine as well. Starting from 3.00a it will be set to the end of
 			 * allocated FIFO space here due to ep 0 OUT always keeping enabled
 			 */
 			gdfifocfg.d32 = DWC_READ_REG32(&global_regs->gdfifocfg);
 			hwcfg3.d32 = DWC_READ_REG32(&global_regs->ghwcfg3);
-			gdfifocfg.b.gdfifocfg = (DWC_READ_REG32(&global_regs->ghwcfg3) >> 16);
+			gdfifocfg.b.gdfifocfg =
+			    (DWC_READ_REG32(&global_regs->ghwcfg3) >> 16);
 			DWC_WRITE_REG32(&global_regs->gdfifocfg, gdfifocfg.d32);
 			if (core_if->snpsid <= OTG_CORE_REV_2_94a) {
-				rxfsiz = (DWC_READ_REG32(&global_regs->grxfsiz) & 0x0000ffff);
-				nptxfsiz = (DWC_READ_REG32(&global_regs->gnptxfsiz) >> 16);
+				rxfsiz =
+				    (DWC_READ_REG32(&global_regs->grxfsiz) &
+				     0x0000ffff);
+				nptxfsiz =
+				    (DWC_READ_REG32(&global_regs->gnptxfsiz) >>
+				     16);
 				gdfifocfg.b.epinfobase = rxfsiz + nptxfsiz;
 			} else {
 				gdfifocfg.b.epinfobase = txfifosize.b.startaddr;
 			}
-			//DWC_WRITE_REG32(&global_regs->gdfifocfg, gdfifocfg.d32);
-			#endif
+			/* DWC_WRITE_REG32(&global_regs->gdfifocfg, gdfifocfg.d32); */
+#endif
 		}
 	}
 
@@ -2145,16 +2158,16 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 
 	if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable) {
 		core_if->start_predict = 0;
-		for (i = 0; i <= core_if->dev_if->num_in_eps; ++i) {
-			core_if->nextep_seq[i] = 0xff;	// 0xff - EP not active
-		}
+		for (i = 0; i <= core_if->dev_if->num_in_eps; ++i)
+			core_if->nextep_seq[i] = 0xff;	/* 0xff - EP not active */
 		core_if->nextep_seq[0] = 0;
 		core_if->first_in_nextep_seq = 0;
 		diepctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[0]->diepctl);
 		diepctl.b.nextep = 0;
 		DWC_WRITE_REG32(&dev_if->in_ep_regs[0]->diepctl, diepctl.d32);
 
-		/* Update IN Endpoint Mismatch Count by active IN NP EP count + 1 */
+		/* Update IN Endpoint Mismatch Count
+		 * by active IN NP EP count + 1 */
 		dcfg.d32 = DWC_READ_REG32(&dev_if->dev_global_regs->dcfg);
 		dcfg.b.epmscnt = 2;
 		DWC_WRITE_REG32(&dev_if->dev_global_regs->dcfg, dcfg.d32);
@@ -2162,25 +2175,24 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 		DWC_DEBUGPL(DBG_CILV,
 			    "%s first_in_nextep_seq= %2d; nextep_seq[]:\n",
 			    __func__, core_if->first_in_nextep_seq);
-		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
+		for (i = 0; i <= core_if->dev_if->num_in_eps; i++)
 			DWC_DEBUGPL(DBG_CILV, "%2d ", core_if->nextep_seq[i]);
-		}
 		DWC_DEBUGPL(DBG_CILV, "\n");
 	}
 
-	/* Clear all pending Device Interrupts */
-	/** @todo - if the condition needed to be checked
-	 *  or in any case all pending interrutps should be cleared?
-     */
+	/* Clear all pending Device Interrupts
+	 * @todo - if the condition needed to be checked
+	 * or in any case all pending interrutps should be cleared?
+	 */
 	if (core_if->multiproc_int_enable) {
 		for (i = 0; i < core_if->dev_if->num_in_eps; ++i) {
-			DWC_WRITE_REG32(&dev_if->dev_global_regs->
-					diepeachintmsk[i], 0);
+			DWC_WRITE_REG32(&dev_if->
+					dev_global_regs->diepeachintmsk[i], 0);
 		}
 
 		for (i = 0; i < core_if->dev_if->num_out_eps; ++i) {
-			DWC_WRITE_REG32(&dev_if->dev_global_regs->
-					doepeachintmsk[i], 0);
+			DWC_WRITE_REG32(&dev_if->
+					dev_global_regs->doepeachintmsk[i], 0);
 		}
 
 		DWC_WRITE_REG32(&dev_if->dev_global_regs->deachint, 0xFFFFFFFF);
@@ -2219,41 +2231,52 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 			gintmsk_data_t gintsts = {.d32 = 0 };
 			doepint_data_t doepint = {.d32 = 0 };
 			dctl.b.sgoutnak = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
+			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
+					 dctl, 0, dctl.d32);
 			do {
 				j++;
 				dwc_udelay(10);
-				gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
+				gintsts.d32 =
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gintsts);
 				if (j == 100000) {
-					DWC_ERROR("SNAK as not set during 10s\n");
+					DWC_ERROR
+					    ("SNAK as not set during 10s\n");
 					break;
 				}
 			} while (!gintsts.b.goutnakeff);
 			gintsts.d32 = 0;
 			gintsts.b.goutnakeff = 1;
-			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts, gintsts.d32);
+			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,
+					gintsts.d32);
 
 			depctl.d32 = 0;
 			depctl.b.epdis = 1;
 			depctl.b.snak = 1;
 			j = 0;
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->doepctl, depctl.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->
+					doepctl, depctl.d32);
 			do {
 				dwc_udelay(10);
-				doepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-					out_ep_regs[i]->doepint);
+				doepint.d32 =
+				    DWC_READ_REG32(&core_if->
+						   dev_if->out_ep_regs[i]->
+						   doepint);
 				if (j == 100000) {
-					DWC_ERROR("EPDIS was not set during 10s\n");
+					DWC_ERROR
+					    ("EPDIS was not set during 10s\n");
 					break;
 				}
 			} while (!doepint.b.epdisabled);
 
 			doepint.b.epdisabled = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->doepint, doepint.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[i]->
+					doepint, doepint.d32);
 
 			dctl.d32 = 0;
 			dctl.b.cgoutnak = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
+			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
+					 dctl, 0, dctl.d32);
 		} else {
 			depctl.d32 = 0;
 		}
@@ -2299,8 +2322,9 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
 		diepmsk_data_t msk = {.d32 = 0 };
 		msk.b.txfifoundrn = 1;
 		if (core_if->multiproc_int_enable) {
-			DWC_MODIFY_REG32(&dev_if->dev_global_regs->
-					 diepeachintmsk[0], msk.d32, msk.d32);
+			DWC_MODIFY_REG32(&dev_if->
+					 dev_global_regs->diepeachintmsk[0],
+					 msk.d32, msk.d32);
 		} else {
 			DWC_MODIFY_REG32(&dev_if->dev_global_regs->diepmsk,
 					 msk.d32, msk.d32);
@@ -2320,7 +2344,7 @@ void dwc_otg_core_dev_init(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller
  */
-void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t * core_if)
+void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	gintmsk_data_t intr_mask = {.d32 = 0 };
@@ -2353,7 +2377,7 @@ void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller
  */
-void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t * core_if)
+void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	gintmsk_data_t intr_mask = {.d32 = 0 };
@@ -2384,7 +2408,7 @@ void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of DWC_otg controller
  *
  */
-void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
+void dwc_otg_core_host_init(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	dwc_otg_host_if_t *host_if = core_if->host_if;
@@ -2392,8 +2416,8 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 	hprt0_data_t hprt0 = {.d32 = 0 };
 	fifosize_data_t nptxfifosize;
 	fifosize_data_t ptxfifosize;
-//	uint16_t rxfsiz, nptxfsiz, hptxfsiz;
-//	gdfifocfg_data_t gdfifocfg = {.d32 = 0 };
+	/* uint16_t rxfsiz, nptxfsiz, hptxfsiz; */
+	/* gdfifocfg_data_t gdfifocfg = {.d32 = 0 }; */
 	int i;
 	hcchar_data_t hcchar;
 	hcfg_data_t hcfg;
@@ -2405,17 +2429,16 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 	struct dwc_otg_platform_data *pldata;
 	pldata = core_if->otg_dev->pldata;
 
-
-
 	DWC_DEBUGPL(DBG_CILV, "%s(%p)\n", __func__, core_if);
 
 	/* Restart the Phy Clock */
 	pcgcctl.b.stoppclk = 1;
 	DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
 	dwc_udelay(10);
-	
-	if ((core_if->otg_ver == 1) && (core_if->op_state == A_HOST)) {	
-		DWC_PRINTF("Init: Port Power? op_state=%d\n", core_if->op_state);
+
+	if ((core_if->otg_ver == 1) && (core_if->op_state == A_HOST)) {
+		DWC_PRINTF("Init: Port Power? op_state=%d\n",
+			   core_if->op_state);
 		hprt0.d32 = dwc_otg_read_hprt0(core_if);
 		DWC_PRINTF("Init: Power Port (%d)\n", hprt0.b.prtpwr);
 		if (hprt0.b.prtpwr == 0) {
@@ -2434,7 +2457,7 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 	}
 
 	/* This bit allows dynamic reloading of the HFIR register
-	 * during runtime. This bit needs to be programmed during 
+	 * during runtime. This bit needs to be programmed during
 	 * initial configuration and its value must not be changed
 	 * during runtime.*/
 	if (core_if->core_params->reload_ctl == 1) {
@@ -2482,15 +2505,18 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 		/* Rx FIFO */
 		DWC_DEBUGPL(DBG_CIL, "initial grxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->grxfsiz));
-		DWC_WRITE_REG32(&global_regs->grxfsiz, 0x0200);//params->host_rx_fifo_size);
+		/* params->host_rx_fifo_size  */
+		DWC_WRITE_REG32(&global_regs->grxfsiz, 0x0200);
 		DWC_DEBUGPL(DBG_CIL, "new grxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->grxfsiz));
 
 		/* Non-periodic Tx FIFO */
 		DWC_DEBUGPL(DBG_CIL, "initial gnptxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->gnptxfsiz));
-		nptxfifosize.b.depth = 0x0080;//params->host_nperio_tx_fifo_size;
-		nptxfifosize.b.startaddr = 0x0200;//params->host_rx_fifo_size;
+		/* params->host_nperio_tx_fifo_size */
+		nptxfifosize.b.depth = 0x0080;
+		/* params->host_rx_fifo_size */
+		nptxfifosize.b.startaddr = 0x0200;
 		DWC_WRITE_REG32(&global_regs->gnptxfsiz, nptxfifosize.d32);
 		DWC_DEBUGPL(DBG_CIL, "new gnptxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->gnptxfsiz));
@@ -2498,33 +2524,41 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 		/* Periodic Tx FIFO */
 		DWC_DEBUGPL(DBG_CIL, "initial hptxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->hptxfsiz));
-		ptxfifosize.b.depth = 0x0100;//params->host_perio_tx_fifo_size;
-		ptxfifosize.b.startaddr = 0x0280;//nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+		/* params->host_perio_tx_fifo_size */
+		ptxfifosize.b.depth = 0x0100;
+		/* nptxfifosize.b.startaddr + nptxfifosize.b.depth */
+		ptxfifosize.b.startaddr = 0x0280;
 		DWC_WRITE_REG32(&global_regs->hptxfsiz, ptxfifosize.d32);
 		DWC_DEBUGPL(DBG_CIL, "new hptxfsiz=%08x\n",
 			    DWC_READ_REG32(&global_regs->hptxfsiz));
-        #if 0
+#if 0
 		/* core_if->en_multiple_tx_fifo equals core_if->hwcfg4.b.ded_fifo_en,
 		 * and ded_fifo_en is 1 in default
 		 */
 		if (core_if->en_multiple_tx_fifo) {
-			/* Global DFIFOCFG calculation for Host mode - include RxFIFO, NPTXFIFO and HPTXFIFO */
+			/* Global DFIFOCFG calculation for Host mode
+			 * - include RxFIFO, NPTXFIFO and HPTXFIFO */
 			gdfifocfg.d32 = DWC_READ_REG32(&global_regs->gdfifocfg);
-			rxfsiz = (DWC_READ_REG32(&global_regs->grxfsiz) & 0x0000ffff);
-			nptxfsiz = (DWC_READ_REG32(&global_regs->gnptxfsiz) >> 16);
-			hptxfsiz = (DWC_READ_REG32(&global_regs->hptxfsiz) >> 16);
+			rxfsiz =
+			    (DWC_READ_REG32(&global_regs->grxfsiz) &
+			     0x0000ffff);
+			nptxfsiz =
+			    (DWC_READ_REG32(&global_regs->gnptxfsiz) >> 16);
+			hptxfsiz =
+			    (DWC_READ_REG32(&global_regs->hptxfsiz) >> 16);
 			gdfifocfg.b.epinfobase = rxfsiz + nptxfsiz + hptxfsiz;
 			DWC_WRITE_REG32(&global_regs->gdfifocfg, gdfifocfg.d32);
 		}
-		#endif
+#endif
 	}
 
 	/* TODO - check this */
 	/* Clear Host Set HNP Enable in the OTG Control Register */
 	gotgctl.b.hstsethnpen = 1;
 	DWC_MODIFY_REG32(&global_regs->gotgctl, gotgctl.d32, 0);
-	/* Make sure the FIFOs are flushed. */
-	dwc_otg_flush_tx_fifo(core_if, 0x10 /* all TX FIFOs */ );
+	/* Make sure the FIFOs are flushed
+	 * all TX FIFOs */
+	dwc_otg_flush_tx_fifo(core_if, 0x10);
 	dwc_otg_flush_rx_fifo(core_if);
 
 	/* Clear Host Set HNP Enable in the OTG Control Register */
@@ -2553,7 +2587,8 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 			hcchar.b.chdis = 1;
 			hcchar.b.epdir = 0;
 			DWC_WRITE_REG32(&hc_regs->hcchar, hcchar.d32);
-			DWC_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", __func__, i);
+			DWC_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", __func__,
+				    i);
 			do {
 				hcchar.d32 = DWC_READ_REG32(&hc_regs->hcchar);
 				if (++count > 1000) {
@@ -2575,8 +2610,8 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
 			hprt0.b.prtpwr = 1;
 			DWC_WRITE_REG32(host_if->hprt0, hprt0.d32);
 		}
-		if(pldata->power_enable)
-		    pldata->power_enable(1);
+		if (pldata->power_enable)
+			pldata->power_enable(1);
 	}
 
 	dwc_otg_enable_host_interrupts(core_if);
@@ -2591,7 +2626,7 @@ void dwc_otg_core_host_init(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of DWC_otg controller
  * @param hc Information needed to initialize the host channel
  */
-void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_init(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	uint32_t intr_enable;
 	hcintmsk_data_t hc_intr_mask;
@@ -2612,7 +2647,8 @@ void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 	hc_intr_mask.d32 = 0;
 	hc_intr_mask.b.chhltd = 1;
 	if (core_if->dma_enable) {
-		/* For Descriptor DMA mode core halts the channel on AHB error. Interrupt is not required */
+		/* For Descriptor DMA mode core halts the channel
+		 * on AHB error. Interrupt is not required */
 		if (!core_if->dma_desc_enable)
 			hc_intr_mask.b.ahberr = 1;
 		else {
@@ -2625,9 +2661,8 @@ void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 			hc_intr_mask.b.ack = 1;
 			if (hc->ep_is_in) {
 				hc_intr_mask.b.datatglerr = 1;
-				if (hc->ep_type != DWC_OTG_EP_TYPE_INTR) {
+				if (hc->ep_type != DWC_OTG_EP_TYPE_INTR)
 					hc_intr_mask.b.nak = 1;
-				}
 			}
 		}
 	} else {
@@ -2643,23 +2678,20 @@ void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 			} else {
 				hc_intr_mask.b.nak = 1;
 				hc_intr_mask.b.nyet = 1;
-				if (hc->do_ping) {
+				if (hc->do_ping)
 					hc_intr_mask.b.ack = 1;
-				}
 			}
 
 			if (hc->do_split) {
 				hc_intr_mask.b.nak = 1;
-				if (hc->complete_split) {
+				if (hc->complete_split)
 					hc_intr_mask.b.nyet = 1;
-				} else {
+				else
 					hc_intr_mask.b.ack = 1;
-				}
 			}
 
-			if (hc->error_state) {
+			if (hc->error_state)
 				hc_intr_mask.b.ack = 1;
-			}
 			break;
 		case DWC_OTG_EP_TYPE_INTR:
 			hc_intr_mask.b.xfercompl = 1;
@@ -2669,18 +2701,15 @@ void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 			hc_intr_mask.b.datatglerr = 1;
 			hc_intr_mask.b.frmovrun = 1;
 
-			if (hc->ep_is_in) {
+			if (hc->ep_is_in)
 				hc_intr_mask.b.bblerr = 1;
-			}
-			if (hc->error_state) {
+			if (hc->error_state)
 				hc_intr_mask.b.ack = 1;
-			}
 			if (hc->do_split) {
-				if (hc->complete_split) {
+				if (hc->complete_split)
 					hc_intr_mask.b.nyet = 1;
-				} else {
+				else
 					hc_intr_mask.b.ack = 1;
-				}
 			}
 			break;
 		case DWC_OTG_EP_TYPE_ISOC:
@@ -2779,8 +2808,8 @@ void dwc_otg_hc_init(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * @param hc Host channel to halt.
  * @param halt_status Reason for halting the channel.
  */
-void dwc_otg_hc_halt(dwc_otg_core_if_t * core_if,
-		     dwc_hc_t * hc, dwc_otg_halt_status_e halt_status)
+void dwc_otg_hc_halt(dwc_otg_core_if_t *core_if,
+		     dwc_hc_t *hc, dwc_otg_halt_status_e halt_status)
 {
 	gnptxsts_data_t nptxsts;
 	hptxsts_data_t hptxsts;
@@ -2856,8 +2885,8 @@ void dwc_otg_hc_halt(dwc_otg_core_if_t * core_if,
 
 	hcchar.d32 = DWC_READ_REG32(&hc_regs->hcchar);
 
-	/* No need to set the bit in DDMA for disabling the channel */
-	//TODO check it everywhere channel is disabled          
+	/* No need to set the bit in DDMA for disabling the channel
+	 * TODO check it everywhere channel is disabled */
 	if (!core_if->core_params->dma_desc_enable)
 		hcchar.b.chen = 1;
 	hcchar.b.chdis = 1;
@@ -2867,9 +2896,8 @@ void dwc_otg_hc_halt(dwc_otg_core_if_t * core_if,
 		if (hc->ep_type == DWC_OTG_EP_TYPE_CONTROL ||
 		    hc->ep_type == DWC_OTG_EP_TYPE_BULK) {
 			nptxsts.d32 = DWC_READ_REG32(&global_regs->gnptxsts);
-			if (nptxsts.b.nptxqspcavail == 0) {
+			if (nptxsts.b.nptxqspcavail == 0)
 				hcchar.b.chen = 0;
-			}
 		} else {
 			hptxsts.d32 =
 			    DWC_READ_REG32(&host_global_regs->hptxsts);
@@ -2906,7 +2934,7 @@ void dwc_otg_hc_halt(dwc_otg_core_if_t * core_if,
  * @param core_if Programming view of DWC_otg controller.
  * @param hc Identifies the host channel to clean up.
  */
-void dwc_otg_hc_cleanup(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_cleanup(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	dwc_otg_hc_regs_t *hc_regs;
 
@@ -2934,8 +2962,8 @@ void dwc_otg_hc_cleanup(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * @param hcchar Current value of the HCCHAR register for the specified host
  * channel.
  */
-static inline void hc_set_even_odd_frame(dwc_otg_core_if_t * core_if,
-					 dwc_hc_t * hc, hcchar_data_t * hcchar)
+static inline void hc_set_even_odd_frame(dwc_otg_core_if_t *core_if,
+					 dwc_hc_t *hc, hcchar_data_t *hcchar)
 {
 	if (hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
 	    hc->ep_type == DWC_OTG_EP_TYPE_ISOC) {
@@ -3025,32 +3053,30 @@ void ep_xfer_timeout(void *ptr)
 
 	}
 
-	if (!gintsts.b.goutnakeff) {
+	if (!gintsts.b.goutnakeff)
 		dctl.b.sgoutnak = 1;
-	}
+
 	DWC_WRITE_REG32(&xfer_info->core_if->dev_if->dev_global_regs->dctl,
 			dctl.d32);
 
 }
 
-void set_pid_isoc(dwc_hc_t * hc)
+void set_pid_isoc(dwc_hc_t *hc)
 {
 	/* Set up the initial PID for the transfer. */
 	if (hc->speed == DWC_OTG_EP_SPEED_HIGH) {
 		if (hc->ep_is_in) {
-			if (hc->multi_count == 1) {
+			if (hc->multi_count == 1)
 				hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
-			} else if (hc->multi_count == 2) {
+			else if (hc->multi_count == 2)
 				hc->data_pid_start = DWC_OTG_HC_PID_DATA1;
-			} else {
+			else
 				hc->data_pid_start = DWC_OTG_HC_PID_DATA2;
-			}
 		} else {
-			if (hc->multi_count == 1) {
+			if (hc->multi_count == 1)
 				hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
-			} else {
+			else
 				hc->data_pid_start = DWC_OTG_HC_PID_MDATA;
-			}
 		}
 	} else {
 		hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
@@ -3088,7 +3114,7 @@ void set_pid_isoc(dwc_hc_t * hc)
  * PktCnt fields in the HCTSIZn register. The multi_count value may be changed
  * to reflect the final xfer_len value.
  */
-void dwc_otg_hc_start_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_start_transfer(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	hcchar_data_t hcchar;
 	hctsiz_data_t hctsiz;
@@ -3139,12 +3165,11 @@ void dwc_otg_hc_start_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 			 */
 			uint32_t max_periodic_len =
 			    hc->multi_count * hc->max_packet;
-			if (hc->xfer_len > max_periodic_len) {
+			if (hc->xfer_len > max_periodic_len)
 				hc->xfer_len = max_periodic_len;
-			} else {
-			}
 		} else if (hc->xfer_len > max_hc_xfer_size) {
-			/* Make sure that xfer_len is a multiple of max packet size. */
+			/* Make sure that xfer_len is a
+			 * multiple of max packet size. */
 			hc->xfer_len = max_hc_xfer_size - hc->max_packet + 1;
 		}
 
@@ -3193,11 +3218,10 @@ void dwc_otg_hc_start_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 
 	if (core_if->dma_enable) {
 		dwc_dma_t dma_addr;
-		if (hc->align_buff) {
+		if (hc->align_buff)
 			dma_addr = hc->align_buff;
-		} else {
+		else
 			dma_addr = ((unsigned long)hc->xfer_buff & 0xffffffff);
-		}
 		DWC_WRITE_REG32(&hc_regs->hcdma, dma_addr);
 	}
 
@@ -3257,7 +3281,7 @@ void dwc_otg_hc_start_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * @param core_if Programming view of DWC_otg controller.
  * @param hc Information needed to initialize the host channel.
  */
-void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	dwc_otg_hc_regs_t *hc_regs = core_if->host_if->hc_regs[hc->hc_num];
 	hcchar_data_t hcchar;
@@ -3274,8 +3298,10 @@ void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 
 	/* Packet Count and Xfer Size are not used in Descriptor DMA mode */
 	hctsiz.b_ddma.pid = hc->data_pid_start;
-	hctsiz.b_ddma.ntd = hc->ntd - 1;	/* 0 - 1 descriptor, 1 - 2 descriptors, etc. */
-	hctsiz.b_ddma.schinfo = hc->schinfo;	/* Non-zero only for high-speed interrupt endpoints */
+	/* 0 - 1 descriptor, 1 - 2 descriptors, etc. */
+	hctsiz.b_ddma.ntd = hc->ntd - 1;
+	/* Non-zero only for high-speed interrupt endpoints */
+	hctsiz.b_ddma.schinfo = hc->schinfo;
 
 	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, hc->hc_num);
 	DWC_DEBUGPL(DBG_HCDV, "	 Start PID: %d\n", hctsiz.b.pid);
@@ -3337,7 +3363,7 @@ void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * @return 1 if a new request is queued, 0 if no more requests are required
  * for this transfer.
  */
-int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, hc->hc_num);
 
@@ -3399,7 +3425,7 @@ int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * Starts a PING transfer. This function should only be called in Slave mode.
  * The Do Ping bit is set in the HCTSIZ register, then the channel is enabled.
  */
-void dwc_otg_hc_do_ping(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_do_ping(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	hcchar_data_t hcchar;
 	hctsiz_data_t hctsiz;
@@ -3428,7 +3454,7 @@ void dwc_otg_hc_do_ping(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * Upon return the xfer_buff and xfer_count fields in _hc are incremented by
  * then number of bytes written to the Tx FIFO.
  */
-void dwc_otg_hc_write_packet(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
+void dwc_otg_hc_write_packet(dwc_otg_core_if_t *core_if, dwc_hc_t *hc)
 {
 	uint32_t i;
 	uint32_t remaining_count;
@@ -3439,19 +3465,17 @@ void dwc_otg_hc_write_packet(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
 	uint32_t *data_fifo = core_if->data_fifo[hc->hc_num];
 
 	remaining_count = hc->xfer_len - hc->xfer_count;
-	if (remaining_count > hc->max_packet) {
+	if (remaining_count > hc->max_packet)
 		byte_count = hc->max_packet;
-	} else {
+	else
 		byte_count = remaining_count;
-	}
 
 	dword_count = (byte_count + 3) / 4;
 
 	if ((((unsigned long)data_buff) & 0x3) == 0) {
 		/* xfer_buff is DWORD aligned. */
-		for (i = 0; i < dword_count; i++, data_buff++) {
+		for (i = 0; i < dword_count; i++, data_buff++)
 			DWC_WRITE_REG32(data_fifo, *data_buff);
-		}
 	} else {
 		/* xfer_buff is not DWORD aligned. */
 		for (i = 0; i < dword_count; i++, data_buff++) {
@@ -3471,7 +3495,7 @@ void dwc_otg_hc_write_packet(dwc_otg_core_if_t * core_if, dwc_hc_t * hc)
  * Gets the current USB frame number. This is the frame number from the last
  * SOF packet.
  */
-uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t *core_if)
 {
 	dsts_data_t dsts;
 	dsts.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dsts);
@@ -3481,18 +3505,18 @@ uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t * core_if)
 }
 
 /**
- * Calculates and gets the frame Interval value of HFIR register according PHY 
+ * Calculates and gets the frame Interval value of HFIR register according PHY
  * type and speed.The application can modify a value of HFIR register only after
- * the Port Enable bit of the Host Port Control and Status register 
+ * the Port Enable bit of the Host Port Control and Status register
  * (HPRT.PrtEnaPort) has been set.
 */
 
-uint32_t calc_frame_interval(dwc_otg_core_if_t * core_if)
+uint32_t calc_frame_interval(dwc_otg_core_if_t *core_if)
 {
 	gusbcfg_data_t usbcfg;
 	hwcfg2_data_t hwcfg2;
 	hprt0_data_t hprt0;
-	int clock = 60;		// default value
+	int clock = 60;		/* default value */
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 	hwcfg2.d32 = DWC_READ_REG32(&core_if->core_global_regs->ghwcfg2);
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
@@ -3529,7 +3553,7 @@ uint32_t calc_frame_interval(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of DWC_otg controller.
  * @param dest Destination buffer for packet data.
  */
-void dwc_otg_read_setup_packet(dwc_otg_core_if_t * core_if, uint32_t * dest)
+void dwc_otg_read_setup_packet(dwc_otg_core_if_t *core_if, uint32_t *dest)
 {
 	device_grxsts_data_t status;
 	/* Get the 8 bytes of a setup transaction data */
@@ -3555,7 +3579,7 @@ void dwc_otg_read_setup_packet(dwc_otg_core_if_t * core_if, uint32_t * dest)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP0 data.
  */
-void dwc_otg_ep0_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep0_activate(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 	dsts_data_t dsts;
@@ -3610,7 +3634,7 @@ void dwc_otg_ep0_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to activate.
  */
-void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_activate(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 	depctl_data_t depctl;
@@ -3644,25 +3668,29 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		depctl.b.eptype = ep->type;
 		depctl.b.txfnum = ep->tx_fifo_num;
 
-		if (ep->type == DWC_OTG_EP_TYPE_ISOC) {
-			depctl.b.setd0pid = 1;	// ???
-		} else {
+		if (ep->type == DWC_OTG_EP_TYPE_ISOC)
 			depctl.b.setd0pid = 1;
-		}
+		else
+			depctl.b.setd0pid = 1;
+
 		depctl.b.usbactep = 1;
 
 		/* Update nextep_seq array and EPMSCNT in DCFG */
-		if (!(depctl.b.eptype & 1) && (ep->is_in == 1)) {	// NP IN EP
+		if (!(depctl.b.eptype & 1) && (ep->is_in == 1)) {/*NP IN EP*/
 			for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
-				if (core_if->nextep_seq[i] == core_if->first_in_nextep_seq)
+				if (core_if->nextep_seq[i] ==
+				    core_if->first_in_nextep_seq)
 					break;
 			}
 			core_if->nextep_seq[i] = ep->num;
-			core_if->nextep_seq[ep->num] = core_if->first_in_nextep_seq;
+			core_if->nextep_seq[ep->num] =
+			    core_if->first_in_nextep_seq;
 			depctl.b.nextep = core_if->nextep_seq[ep->num];
-			dcfg.d32 = DWC_READ_REG32(&dev_if->dev_global_regs->dcfg);
+			dcfg.d32 =
+			    DWC_READ_REG32(&dev_if->dev_global_regs->dcfg);
 			dcfg.b.epmscnt++;
-			DWC_WRITE_REG32(&dev_if->dev_global_regs->dcfg, dcfg.d32);
+			DWC_WRITE_REG32(&dev_if->dev_global_regs->dcfg,
+					dcfg.d32);
 
 			DWC_DEBUGPL(DBG_PCDV,
 				    "%s first_in_nextep_seq= %2d; nextep_seq[]:\n",
@@ -3674,7 +3702,6 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 
 		}
 
-
 		DWC_WRITE_REG32(addr, depctl.d32);
 		DWC_DEBUGPL(DBG_PCDV, "DEPCTL=%08x\n", DWC_READ_REG32(addr));
 	}
@@ -3688,25 +3715,26 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			diepmsk.b.epdisabled = 1;
 			diepmsk.b.ahberr = 1;
 			diepmsk.b.intknepmis = 1;
-			if (!core_if->en_multiple_tx_fifo && core_if->dma_enable)
+			if (!core_if->en_multiple_tx_fifo
+			    && core_if->dma_enable)
 				diepmsk.b.intknepmis = 0;
-			diepmsk.b.txfifoundrn = 1;	//?????
-			if (ep->type == DWC_OTG_EP_TYPE_ISOC) {
+			diepmsk.b.txfifoundrn = 1;
+			if (ep->type == DWC_OTG_EP_TYPE_ISOC)
 				diepmsk.b.nak = 1;
-			}
 
-/*
+			/*
 			if (core_if->dma_desc_enable) {
 				diepmsk.b.bna = 1;
 			}
-*/
-/*			
+
 			if (core_if->dma_enable) {
 				doepmsk.b.nak = 1;
 			}
-*/
-			DWC_WRITE_REG32(&dev_if->dev_global_regs->
-					diepeachintmsk[ep->num], diepmsk.d32);
+			*/
+			DWC_WRITE_REG32(&dev_if->
+					dev_global_regs->diepeachintmsk[ep->
+									num],
+					diepmsk.d32);
 
 		} else {
 			doepmsk_data_t doepmsk = {.d32 = 0 };
@@ -3716,19 +3744,19 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			if (ep->type == DWC_OTG_EP_TYPE_ISOC)
 				doepmsk.b.outtknepdis = 1;
 
-/*			
-
+			/*
 			if (core_if->dma_desc_enable) {
 				doepmsk.b.bna = 1;
 			}
-*/
-/*			
 			doepmsk.b.babble = 1;
 			doepmsk.b.nyet = 1;
 			doepmsk.b.nak = 1;
-*/
-			DWC_WRITE_REG32(&dev_if->dev_global_regs->
-					doepeachintmsk[ep->num], doepmsk.d32);
+			*/
+
+			DWC_WRITE_REG32(&dev_if->
+					dev_global_regs->doepeachintmsk[ep->
+									num],
+					doepmsk.d32);
 		}
 		DWC_MODIFY_REG32(&dev_if->dev_global_regs->deachintmsk,
 				 0, daintmsk.d32);
@@ -3737,11 +3765,13 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			if (ep->is_in) {
 				diepmsk_data_t diepmsk = {.d32 = 0 };
 				diepmsk.b.nak = 1;
-				DWC_MODIFY_REG32(&dev_if->dev_global_regs->diepmsk, 0, diepmsk.d32);
+				DWC_MODIFY_REG32(&dev_if->dev_global_regs->
+						 diepmsk, 0, diepmsk.d32);
 			} else {
 				doepmsk_data_t doepmsk = {.d32 = 0 };
 				doepmsk.b.outtknepdis = 1;
-				DWC_MODIFY_REG32(&dev_if->dev_global_regs->doepmsk, 0, doepmsk.d32);
+				DWC_MODIFY_REG32(&dev_if->dev_global_regs->
+						 doepmsk, 0, doepmsk.d32);
 			}
 		}
 		DWC_MODIFY_REG32(&dev_if->dev_global_regs->daintmsk,
@@ -3764,7 +3794,7 @@ void dwc_otg_ep_activate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to deactivate.
  */
-void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_deactivate(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl = {.d32 = 0 };
 	volatile uint32_t *addr;
@@ -3791,8 +3821,9 @@ void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 
 	depctl.b.usbactep = 0;
 
-	/* Update nextep_seq array and EPMSCNT in DCFG */
-	if (!(depctl.b.eptype & 1) && ep->is_in == 1) {	// NP EP IN
+	/* Update nextep_seq array and EPMSCNT in DCFG
+	 * NP EP IN */
+	if (!(depctl.b.eptype & 1) && ep->is_in == 1) {
 		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
 			if (core_if->nextep_seq[i] == ep->num)
 				break;
@@ -3811,11 +3842,10 @@ void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		DWC_DEBUGPL(DBG_PCDV,
 			    "%s first_in_nextep_seq= %2d; nextep_seq[]:\n",
 			    __func__, core_if->first_in_nextep_seq);
-		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
+		for (i = 0; i <= core_if->dev_if->num_in_eps; i++)
 			DWC_DEBUGPL(DBG_PCDV, "%2d\n", core_if->nextep_seq[i]);
-		}
 	}
-		
+
 	if (ep->is_in == 1)
 		depctl.b.txfnum = 0;
 
@@ -3831,65 +3861,77 @@ void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			diepint_data_t diepint = {.d32 = 0 };
 
 			depctl.b.snak = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-					diepctl, depctl.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[ep->num]->diepctl,
+					depctl.d32);
 			do {
 				dwc_udelay(10);
 				diepint.d32 =
-				    DWC_READ_REG32(&core_if->
-						   dev_if->in_ep_regs[ep->num]->
-						   diepint);
+				    DWC_READ_REG32(&core_if->dev_if->
+						   in_ep_regs[ep->
+							      num]->diepint);
 			} while (!diepint.b.inepnakeff);
 			diepint.b.inepnakeff = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-					diepint, diepint.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[ep->num]->diepint,
+					diepint.d32);
 			depctl.d32 = 0;
 			depctl.b.epdis = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-					diepctl, depctl.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[ep->num]->diepctl,
+					depctl.d32);
 			do {
 				dwc_udelay(10);
 				diepint.d32 =
-				    DWC_READ_REG32(&core_if->
-						   dev_if->in_ep_regs[ep->num]->
-						   diepint);
+				    DWC_READ_REG32(&core_if->dev_if->
+						   in_ep_regs[ep->
+							      num]->diepint);
 			} while (!diepint.b.epdisabled);
 			diepint.b.epdisabled = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-					diepint, diepint.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[ep->num]->diepint,
+					diepint.d32);
 		} else {
-			dctl_data_t dctl = {.d32 = 0};
-			gintmsk_data_t gintsts = {.d32 = 0};
-			doepint_data_t doepint = {.d32 = 0};
+			dctl_data_t dctl = {.d32 = 0 };
+			gintmsk_data_t gintsts = {.d32 = 0 };
+			doepint_data_t doepint = {.d32 = 0 };
 			dctl.b.sgoutnak = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
-					 dctl, 0, dctl.d32);
+			DWC_MODIFY_REG32(&core_if->dev_if->
+					 dev_global_regs->dctl, 0, dctl.d32);
 			do {
 				dwc_udelay(10);
-				gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
-			} while (!gintsts.b.goutnakeff); 
+				gintsts.d32 =
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gintsts);
+			} while (!gintsts.b.goutnakeff);
 			gintsts.d32 = 0;
 			gintsts.b.goutnakeff = 1;
-			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts, gintsts.d32);
+			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,
+					gintsts.d32);
 
 			depctl.d32 = 0;
 			depctl.b.epdis = 1;
 			depctl.b.snak = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->doepctl, depctl.d32);
-			do 
-			{
+			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->
+					doepctl, depctl.d32);
+			do {
 				dwc_udelay(10);
-				doepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-											out_ep_regs[ep->num]->doepint);
-			} while (!doepint.b.epdisabled); 
+				doepint.d32 =
+				    DWC_READ_REG32(&core_if->
+						   dev_if->out_ep_regs[ep->
+								       num]->
+						   doepint);
+			} while (!doepint.b.epdisabled);
 
 			doepint.b.epdisabled = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->doepint, doepint.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->
+					doepint, doepint.d32);
 
 			dctl.d32 = 0;
 			dctl.b.cgoutnak = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
-		}		
+			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
+					 dctl, 0, dctl.d32);
+		}
 	}
 
 	/* Disable the Interrupt for this EP */
@@ -3898,11 +3940,15 @@ void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 				 daintmsk.d32, 0);
 
 		if (ep->is_in == 1) {
-			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->
-					diepeachintmsk[ep->num], 0);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					dev_global_regs->diepeachintmsk[ep->
+									num],
+					0);
 		} else {
-			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->
-					doepeachintmsk[ep->num], 0);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					dev_global_regs->doepeachintmsk[ep->
+									num],
+					0);
 		}
 	} else {
 		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->daintmsk,
@@ -3917,7 +3963,7 @@ void dwc_otg_ep_deactivate(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to start the transfer on.
  */
-static void init_dma_desc_chain(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+static void init_dma_desc_chain(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	dwc_otg_dev_dma_desc_t *dma_desc;
 	uint32_t offset;
@@ -3975,15 +4021,16 @@ static void init_dma_desc_chain(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			if (ep->is_in) {
 				dma_desc->status.b.sp =
 				    (xfer_est %
-				     ep->maxpacket) ? 1 : ((ep->
-							    sent_zlp) ? 1 : 0);
+				     ep->
+				     maxpacket) ? 1 : ((ep->sent_zlp) ? 1 : 0);
 				dma_desc->status.b.bytes = xfer_est;
 			} else {
 				if (maxxfer_local == ep->maxpacket)
 					dma_desc->status.b.bytes = xfer_est;
-				else	
+				else
 					dma_desc->status.b.bytes =
-				    		xfer_est + ((4 - (xfer_est & 0x3)) & 0x3);
+					    xfer_est +
+					    ((4 - (xfer_est & 0x3)) & 0x3);
 			}
 
 			dma_desc->buf = ep->dma_addr + offset;
@@ -3995,10 +4042,11 @@ static void init_dma_desc_chain(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 }
 
 /**
- * This function is called when to write ISOC data into appropriate dedicated 
+ * This function is called when to write ISOC data into appropriate dedicated
  * periodic FIFO.
  */
-static int32_t write_isoc_tx_fifo(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
+static int32_t write_isoc_tx_fifo(dwc_otg_core_if_t *core_if,
+				  dwc_ep_t *dwc_ep)
 {
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 	dwc_otg_dev_in_ep_regs_t *ep_regs;
@@ -4013,9 +4061,8 @@ static int32_t write_isoc_tx_fifo(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep
 
 	len = dwc_ep->xfer_len - dwc_ep->xfer_count;
 
-	if (len > dwc_ep->maxpacket) {
+	if (len > dwc_ep->maxpacket)
 		len = dwc_ep->maxpacket;
-	}
 
 	dwords = (len + 3) / 4;
 
@@ -4030,9 +4077,8 @@ static int32_t write_isoc_tx_fifo(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep
 		dwc_otg_ep_write_packet(core_if, dwc_ep, 0);
 
 		len = dwc_ep->xfer_len - dwc_ep->xfer_count;
-		if (len > dwc_ep->maxpacket) {
+		if (len > dwc_ep->maxpacket)
 			len = dwc_ep->maxpacket;
-		}
 
 		dwords = (len + 3) / 4;
 		txstatus.d32 =
@@ -4057,7 +4103,7 @@ static int32_t write_isoc_tx_fifo(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep
  * @param ep The EP to start the transfer on.
  */
 
-void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_start_transfer(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl;
 	deptsiz_data_t deptsiz;
@@ -4091,12 +4137,17 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		deptsiz.d32 = DWC_READ_REG32(&(in_regs->dieptsiz));
 
 		if (ep->maxpacket > ep->maxxfer / MAX_PKT_CNT)
-			ep->xfer_len += (ep->maxxfer < (ep->total_len - ep->xfer_len)) ?
-		    		ep->maxxfer : (ep->total_len - ep->xfer_len);
-		else 
-			ep->xfer_len += (MAX_PKT_CNT * ep->maxpacket < (ep->total_len - ep->xfer_len)) ?
-				 MAX_PKT_CNT * ep->maxpacket : (ep->total_len - ep->xfer_len);
-
+			ep->xfer_len +=
+			    (ep->maxxfer <
+			     (ep->total_len -
+			      ep->xfer_len)) ? ep->maxxfer : (ep->total_len -
+							      ep->xfer_len);
+		else
+			ep->xfer_len +=
+			    (MAX_PKT_CNT * ep->maxpacket <
+			     (ep->total_len -
+			      ep->xfer_len)) ? MAX_PKT_CNT *
+			    ep->maxpacket : (ep->total_len - ep->xfer_len);
 
 		/* Zero Length Packet? */
 		if ((ep->xfer_len - ep->xfer_count) == 0) {
@@ -4106,7 +4157,7 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			/* Program the transfer size and packet count
 			 *      as follows: xfersize = N * maxpacket +
 			 *      short_packet pktcnt = N + (short_packet
-			 *      exist ? 1 : 0) 
+			 *	exist ? 1 : 0)
 			 */
 			deptsiz.b.xfersize = ep->xfer_len - ep->xfer_count;
 			deptsiz.b.pktcnt =
@@ -4114,9 +4165,10 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			     ep->maxpacket) / ep->maxpacket;
 			if (deptsiz.b.pktcnt > MAX_PKT_CNT) {
 				deptsiz.b.pktcnt = MAX_PKT_CNT;
-				deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
-			} 
-			if (ep->type == DWC_OTG_EP_TYPE_ISOC) 
+				deptsiz.b.xfersize =
+				    deptsiz.b.pktcnt * ep->maxpacket;
+			}
+			if (ep->type == DWC_OTG_EP_TYPE_ISOC)
 				deptsiz.b.mc = deptsiz.b.pktcnt;
 		}
 
@@ -4131,7 +4183,8 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 						(uint32_t) ep->dma_addr);
 			} else {
 #ifdef DWC_UTE_CFI
-				/* The descriptor chain should be already initialized by now */
+				/* The descriptor chain should be
+				 * already initialized by now */
 				if (ep->buff_mode != BM_STANDARD) {
 					DWC_WRITE_REG32(&in_regs->diepdma,
 							ep->descs_dma_addr);
@@ -4156,16 +4209,19 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 				if (core_if->en_multiple_tx_fifo == 0) {
 					intr_mask.b.nptxfempty = 1;
 					DWC_MODIFY_REG32
-					    (&core_if->core_global_regs->gintmsk,
-					     intr_mask.d32, intr_mask.d32);
+					    (&core_if->core_global_regs->
+					     gintmsk, intr_mask.d32,
+					     intr_mask.d32);
 				} else {
 					/* Enable the Tx FIFO Empty Interrupt for this EP */
 					if (ep->xfer_len > 0) {
 						uint32_t fifoemptymsk = 0;
 						fifoemptymsk = 1 << ep->num;
 						DWC_MODIFY_REG32
-						    (&core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
-						     0, fifoemptymsk);
+						    (&core_if->dev_if->
+						     dev_global_regs->
+						     dtknqr4_fifoemptymsk, 0,
+						     fifoemptymsk);
 
 					}
 				}
@@ -4173,26 +4229,27 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 				write_isoc_tx_fifo(core_if, ep);
 			}
 		}
-		if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable)
+		if (!core_if->core_params->en_multiple_tx_fifo
+		    && core_if->dma_enable)
 			depctl.b.nextep = core_if->nextep_seq[ep->num];
 
 		if (ep->type == DWC_OTG_EP_TYPE_ISOC) {
 			dsts_data_t dsts = {.d32 = 0 };
 			if (ep->bInterval == 1) {
 				dsts.d32 =
-				    DWC_READ_REG32(&core_if->dev_if->
-						   dev_global_regs->dsts);
+				    DWC_READ_REG32(&core_if->
+						   dev_if->dev_global_regs->
+						   dsts);
 				ep->frame_num = dsts.b.soffn + ep->bInterval;
 				if (ep->frame_num > 0x3FFF) {
 					ep->frm_overrun = 1;
 					ep->frame_num &= 0x3FFF;
 				} else
 					ep->frm_overrun = 0;
-				if (ep->frame_num & 0x1) {
+				if (ep->frame_num & 0x1)
 					depctl.b.setd1pid = 1;
-				} else {
+				else
 					depctl.b.setd0pid = 1;
-				}
 			}
 		}
 		/* EP enable, IN data in FIFO */
@@ -4208,19 +4265,29 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		depctl.d32 = DWC_READ_REG32(&(out_regs->doepctl));
 		deptsiz.d32 = DWC_READ_REG32(&(out_regs->doeptsiz));
 
-		if (!core_if->dma_desc_enable) {	
+		if (!core_if->dma_desc_enable) {
 			if (ep->maxpacket > ep->maxxfer / MAX_PKT_CNT)
-				ep->xfer_len += (ep->maxxfer < (ep->total_len - ep->xfer_len)) ?
-                        	ep->maxxfer : (ep->total_len - ep->xfer_len);
-                else
-					ep->xfer_len += (MAX_PKT_CNT * ep->maxpacket < (ep->total_len 
-					- ep->xfer_len)) ? MAX_PKT_CNT * ep->maxpacket : (ep->total_len - ep->xfer_len);
+				ep->xfer_len +=
+				    (ep->maxxfer <
+				     (ep->total_len -
+				      ep->xfer_len)) ? ep->maxxfer : (ep->
+								      total_len
+								      -
+								      ep->
+								      xfer_len);
+			else
+				ep->xfer_len +=
+				    (MAX_PKT_CNT * ep->maxpacket <
+				     (ep->total_len -
+				      ep->xfer_len)) ? MAX_PKT_CNT *
+				    ep->maxpacket : (ep->total_len -
+						     ep->xfer_len);
 		}
 
 		/* Program the transfer size and packet count as follows:
 		 *
-		 *      pktcnt = N                                                                                
-		 *      xfersize = N * maxpacket
+		 *	pktcnt = N
+		 *	xfersize = N * maxpacket
 		 */
 		if ((ep->xfer_len - ep->xfer_count) == 0) {
 			/* Zero Length Packet */
@@ -4230,12 +4297,12 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			deptsiz.b.pktcnt =
 			    (ep->xfer_len - ep->xfer_count +
 			     (ep->maxpacket - 1)) / ep->maxpacket;
-			if (deptsiz.b.pktcnt > MAX_PKT_CNT) {
+			if (deptsiz.b.pktcnt > MAX_PKT_CNT)
 				deptsiz.b.pktcnt = MAX_PKT_CNT;
-			}
 			if (!core_if->dma_desc_enable) {
 				ep->xfer_len =
-			    		deptsiz.b.pktcnt * ep->maxpacket + ep->xfer_count;
+				    deptsiz.b.pktcnt * ep->maxpacket +
+				    ep->xfer_count;
 			}
 			deptsiz.b.xfersize = ep->xfer_len - ep->xfer_count;
 		}
@@ -4252,26 +4319,38 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 						(uint32_t) ep->dma_addr);
 			} else {
 #ifdef DWC_UTE_CFI
-				/* The descriptor chain should be already initialized by now */
+				/* The descriptor chain should be
+				 * already initialized by now */
 				if (ep->buff_mode != BM_STANDARD) {
 					DWC_WRITE_REG32(&out_regs->doepdma,
 							ep->descs_dma_addr);
 				} else {
 #endif
-					/** This is used for interrupt out transfers*/
+					/* This is used for
+					 * interrupt out transfers*/
 					if (!ep->xfer_len)
 						ep->xfer_len = ep->total_len;
 					init_dma_desc_chain(core_if, ep);
 
 					if (core_if->core_params->dev_out_nak) {
-						if (ep->type == DWC_OTG_EP_TYPE_BULK) {
-							deptsiz.b.pktcnt = (ep->total_len +
-								(ep->maxpacket - 1)) / ep->maxpacket;
-							deptsiz.b.xfersize = ep->total_len;
+						if (ep->type ==
+						    DWC_OTG_EP_TYPE_BULK) {
+							deptsiz.b.pktcnt =
+							    (ep->total_len +
+							     (ep->maxpacket -
+							      1)) /
+							    ep->maxpacket;
+							deptsiz.b.xfersize =
+							    ep->total_len;
 							/* Remember initial value of doeptsiz */
-							core_if->start_doeptsiz_val[ep->num] = deptsiz.d32;
-							DWC_WRITE_REG32(&out_regs->doeptsiz,
-								deptsiz.d32);													
+							core_if->
+							    start_doeptsiz_val
+							    [ep->num] =
+							    deptsiz.d32;
+							DWC_WRITE_REG32
+							    (&out_regs->
+							     doeptsiz,
+							     deptsiz.d32);
 						}
 					}
 				/** DOEPDMAn Register write */
@@ -4289,8 +4368,9 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			dsts_data_t dsts = {.d32 = 0 };
 			if (ep->bInterval == 1) {
 				dsts.d32 =
-				    DWC_READ_REG32(&core_if->dev_if->
-						   dev_global_regs->dsts);
+				    DWC_READ_REG32(&core_if->
+						   dev_if->dev_global_regs->
+						   dsts);
 				ep->frame_num = dsts.b.soffn + ep->bInterval;
 				if (ep->frame_num > 0x3FFF) {
 					ep->frm_overrun = 1;
@@ -4298,11 +4378,10 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 				} else
 					ep->frm_overrun = 0;
 
-				if (ep->frame_num & 0x1) {
+				if (ep->frame_num & 0x1)
 					depctl.b.setd1pid = 1;
-				} else {
+				else
 					depctl.b.setd0pid = 1;
-				}
 			}
 		}
 
@@ -4316,23 +4395,26 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			    DWC_READ_REG32(&out_regs->doepctl),
 			    DWC_READ_REG32(&out_regs->doeptsiz));
 		DWC_DEBUGPL(DBG_PCD, "DAINTMSK=%08x GINTMSK=%08x\n",
-			    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
-					   daintmsk),
-			    DWC_READ_REG32(&core_if->core_global_regs->
-					   gintmsk));
-
-		/* Timer is scheduling only for out bulk transfers for 
-		 * "Device DDMA OUT NAK Enhancement" feature to inform user 
-		 * about received data payload in case of timeout 
+			    DWC_READ_REG32(&core_if->dev_if->
+					   dev_global_regs->daintmsk),
+			    DWC_READ_REG32(&core_if->
+					   core_global_regs->gintmsk));
+
+		/* Timer is scheduling only for out bulk transfers for
+		 * "Device DDMA OUT NAK Enhancement" feature to inform user
+		 * about received data payload in case of timeout
 		 */
 		if (core_if->core_params->dev_out_nak) {
 			if (ep->type == DWC_OTG_EP_TYPE_BULK) {
-				core_if->ep_xfer_info[ep->num].core_if = core_if;
+				core_if->ep_xfer_info[ep->num].core_if =
+				    core_if;
 				core_if->ep_xfer_info[ep->num].ep = ep;
 				core_if->ep_xfer_info[ep->num].state = 1;
 
 				/* Start a timer for this transfer. */
-				DWC_TIMER_SCHEDULE(core_if->ep_xfer_timer[ep->num], 10000);
+				DWC_TIMER_SCHEDULE(core_if->
+						   ep_xfer_timer[ep->num],
+						   10000);
 			}
 		}
 	}
@@ -4346,7 +4428,7 @@ void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param ep The EP to start the transfer on.
  *
  */
-void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 
 	depctl_data_t depctl;
@@ -4385,22 +4467,24 @@ void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			 */
 			if (core_if->en_multiple_tx_fifo == 0) {
 				intr_mask.b.nptxfempty = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gintmsk,
-						 intr_mask.d32, intr_mask.d32);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gintmsk, intr_mask.d32,
+						 intr_mask.d32);
 			} else {
 				/* Enable the Tx FIFO Empty Interrupt for this EP */
 				if (ep->xfer_len > 0) {
 					uint32_t fifoemptymsk = 0;
 					fifoemptymsk = 1 << ep->num;
-					DWC_MODIFY_REG32(&core_if->
-							 dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+					DWC_MODIFY_REG32(&core_if->dev_if->
+							 dev_global_regs->
+							 dtknqr4_fifoemptymsk,
 							 0, fifoemptymsk);
 				}
 			}
 		}
 
-		if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable)
+		if (!core_if->core_params->en_multiple_tx_fifo
+		    && core_if->dma_enable)
 			depctl.b.nextep = core_if->nextep_seq[ep->num];
 		/* EP enable, IN data in FIFO */
 		depctl.b.cnak = 1;
@@ -4449,7 +4533,7 @@ void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP0 data.
  */
-void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl;
 	deptsiz0_data_t deptsiz;
@@ -4479,13 +4563,13 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		gtxstatus.d32 =
 		    DWC_READ_REG32(&core_if->core_global_regs->gnptxsts);
 
-		/* If dedicated FIFO every time flush fifo before enable ep*/
-		if (core_if->en_multiple_tx_fifo && core_if->snpsid >= OTG_CORE_REV_3_00a)
+		/* If dedicated FIFO every time flush fifo before enable ep */
+		if (core_if->en_multiple_tx_fifo
+		    && core_if->snpsid >= OTG_CORE_REV_3_00a)
 			dwc_otg_flush_tx_fifo(core_if, ep->tx_fifo_num);
 
 		if (core_if->en_multiple_tx_fifo == 0
-		    && gtxstatus.b.nptxqspcavail == 0
-		    && !core_if->dma_enable) {
+		    && gtxstatus.b.nptxqspcavail == 0 && !core_if->dma_enable) {
 #ifdef DEBUG
 			deptsiz.d32 = DWC_READ_REG32(&in_regs->dieptsiz);
 			DWC_DEBUGPL(DBG_PCD, "DIEPCTL0=%0x\n",
@@ -4510,7 +4594,7 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			/* Program the transfer size and packet count
 			 *      as follows: xfersize = N * maxpacket +
 			 *      short_packet pktcnt = N + (short_packet
-			 *      exist ? 1 : 0) 
+			 *	exist ? 1 : 0)
 			 */
 			if (ep->xfer_len > ep->maxpacket) {
 				ep->xfer_len = ep->maxpacket;
@@ -4550,14 +4634,15 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 
 				/** DIEPDMA0 Register write */
 				DWC_WRITE_REG32(&in_regs->diepdma,
-						core_if->
-						dev_if->dma_in_desc_addr);
+						core_if->dev_if->
+						dma_in_desc_addr);
 			}
 		} else {
 			DWC_WRITE_REG32(&in_regs->dieptsiz, deptsiz.d32);
 		}
 
-		if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable)
+		if (!core_if->core_params->en_multiple_tx_fifo
+		    && core_if->dma_enable)
 			depctl.b.nextep = core_if->nextep_seq[ep->num];
 		/* EP enable, IN data in FIFO */
 		depctl.b.cnak = 1;
@@ -4571,16 +4656,17 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		if (!core_if->dma_enable) {
 			if (core_if->en_multiple_tx_fifo == 0) {
 				intr_mask.b.nptxfempty = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gintmsk,
-						 intr_mask.d32, intr_mask.d32);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gintmsk, intr_mask.d32,
+						 intr_mask.d32);
 			} else {
 				/* Enable the Tx FIFO Empty Interrupt for this EP */
 				if (ep->xfer_len > 0) {
 					uint32_t fifoemptymsk = 0;
 					fifoemptymsk |= 1 << ep->num;
-					DWC_MODIFY_REG32(&core_if->
-							 dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+					DWC_MODIFY_REG32(&core_if->dev_if->
+							 dev_global_regs->
+							 dtknqr4_fifoemptymsk,
 							 0, fifoemptymsk);
 				}
 			}
@@ -4630,8 +4716,8 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 
 				/** DOEPDMA0 Register write */
 				DWC_WRITE_REG32(&out_regs->doepdma,
-						core_if->dev_if->
-						dma_out_desc_addr);
+						core_if->
+						dev_if->dma_out_desc_addr);
 			}
 		} else {
 			DWC_WRITE_REG32(&out_regs->doeptsiz, deptsiz.d32);
@@ -4653,7 +4739,7 @@ void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP0 data.
  */
-void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl;
 	deptsiz0_data_t deptsiz;
@@ -4674,9 +4760,9 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		deptsiz.d32 = DWC_READ_REG32(&in_regs->dieptsiz);
 
 		/* Program the transfer size and packet count
-		 *      as follows: xfersize = N * maxpacket +
-		 *      short_packet pktcnt = N + (short_packet
-		 *      exist ? 1 : 0) 
+		 * 	as follows: xfersize = N * maxpacket +
+		 * 	short_packet pktcnt = N + (short_packet
+		 * 	exist ? 1 : 0)
 		 */
 
 		if (core_if->dma_desc_enable == 0) {
@@ -4685,11 +4771,10 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			    ep->maxpacket ? ep->maxpacket : (ep->total_len -
 							     ep->xfer_count);
 			deptsiz.b.pktcnt = 1;
-			if (core_if->dma_enable == 0) {
+			if (core_if->dma_enable == 0)
 				ep->xfer_len += deptsiz.b.xfersize;
-			} else {
+			else
 				ep->xfer_len = deptsiz.b.xfersize;
-			}
 			DWC_WRITE_REG32(&in_regs->dieptsiz, deptsiz.d32);
 		} else {
 			ep->xfer_len =
@@ -4726,7 +4811,8 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 				DWC_WRITE_REG32(&(in_regs->diepdma),
 						(uint32_t) ep->dma_addr);
 		}
-		if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable)
+		if (!core_if->core_params->en_multiple_tx_fifo
+		    && core_if->dma_enable)
 			depctl.b.nextep = core_if->nextep_seq[ep->num];
 		/* EP enable, IN data in FIFO */
 		depctl.b.cnak = 1;
@@ -4741,17 +4827,18 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 			if (core_if->en_multiple_tx_fifo == 0) {
 				/* First clear it from GINTSTS */
 				intr_mask.b.nptxfempty = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gintmsk,
-						 intr_mask.d32, intr_mask.d32);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gintmsk, intr_mask.d32,
+						 intr_mask.d32);
 
 			} else {
 				/* Enable the Tx FIFO Empty Interrupt for this EP */
 				if (ep->xfer_len > 0) {
 					uint32_t fifoemptymsk = 0;
 					fifoemptymsk |= 1 << ep->num;
-					DWC_MODIFY_REG32(&core_if->
-							 dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+					DWC_MODIFY_REG32(&core_if->dev_if->
+							 dev_global_regs->
+							 dtknqr4_fifoemptymsk,
 							 0, fifoemptymsk);
 				}
 			}
@@ -4764,9 +4851,9 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		deptsiz.d32 = DWC_READ_REG32(&out_regs->doeptsiz);
 
 		/* Program the transfer size and packet count
-		 *      as follows: xfersize = N * maxpacket +
-		 *      short_packet pktcnt = N + (short_packet
-		 *      exist ? 1 : 0) 
+		 * 	as follows: xfersize = N * maxpacket +
+		 * 	short_packet pktcnt = N + (short_packet
+		 * 	exist ? 1 : 0)
 		 */
 		deptsiz.b.xfersize = ep->maxpacket;
 		deptsiz.b.pktcnt = 1;
@@ -4812,7 +4899,7 @@ void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 }
 
 #ifdef DEBUG
-void dump_msg(const u8 * buf, unsigned int length)
+void dump_msg(const u8 *buf, unsigned int length)
 {
 	unsigned int start, num, i;
 	char line[52], *p;
@@ -4837,7 +4924,7 @@ void dump_msg(const u8 * buf, unsigned int length)
 	}
 }
 #else
-static inline void dump_msg(const u8 * buf, unsigned int length)
+static inline void dump_msg(const u8 *buf, unsigned int length)
 {
 }
 #endif
@@ -4852,7 +4939,7 @@ static inline void dump_msg(const u8 * buf, unsigned int length)
  * @param ep The EP to write packet for.
  * @param dma Indicates if DMA is being used.
  */
-void dwc_otg_ep_write_packet(dwc_otg_core_if_t * core_if, dwc_ep_t * ep,
+void dwc_otg_ep_write_packet(dwc_otg_core_if_t *core_if, dwc_ep_t *ep,
 			     int dma)
 {
 	/**
@@ -4884,11 +4971,10 @@ void dwc_otg_ep_write_packet(dwc_otg_core_if_t * core_if, dwc_ep_t * ep,
 	}
 
 	/* Find the byte length of the packet either short packet or MPS */
-	if ((ep->xfer_len - ep->xfer_count) < ep->maxpacket) {
+	if ((ep->xfer_len - ep->xfer_count) < ep->maxpacket)
 		byte_count = ep->xfer_len - ep->xfer_count;
-	} else {
+	else
 		byte_count = ep->maxpacket;
-	}
 
 	/* Find the DWORD length, padded by extra bytes as neccessary if MPS
 	 * is not a multiple of DWORD */
@@ -4907,9 +4993,8 @@ void dwc_otg_ep_write_packet(dwc_otg_core_if_t * core_if, dwc_ep_t * ep,
 		    fifo, data_buff, *data_buff, byte_count);
 
 	if (!dma) {
-		for (i = 0; i < dword_count; i++, data_buff++) {
+		for (i = 0; i < dword_count; i++, data_buff++)
 			DWC_WRITE_REG32(fifo, *data_buff);
-		}
 	}
 
 	ep->xfer_count += byte_count;
@@ -4923,7 +5008,7 @@ void dwc_otg_ep_write_packet(dwc_otg_core_if_t * core_if, dwc_ep_t * ep,
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to set the stall on.
  */
-void dwc_otg_ep_set_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_set_stall(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl;
 	volatile uint32_t *depctl_addr;
@@ -4936,9 +5021,8 @@ void dwc_otg_ep_set_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 		depctl.d32 = DWC_READ_REG32(depctl_addr);
 
 		/* set the disable and stall bits */
-		if (depctl.b.epena) {
+		if (depctl.b.epena)
 			depctl.b.epdis = 1;
-		}
 		depctl.b.stall = 1;
 		DWC_WRITE_REG32(depctl_addr, depctl.d32);
 	} else {
@@ -4961,7 +5045,7 @@ void dwc_otg_ep_set_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to clear stall from.
  */
-void dwc_otg_ep_clear_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_ep_clear_stall(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl;
 	volatile uint32_t *depctl_addr;
@@ -4969,11 +5053,10 @@ void dwc_otg_ep_clear_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 	DWC_DEBUGPL(DBG_PCD, "%s ep%d-%s\n", __func__, ep->num,
 		    (ep->is_in ? "IN" : "OUT"));
 
-	if (ep->is_in == 1) {
+	if (ep->is_in == 1)
 		depctl_addr = &(core_if->dev_if->in_ep_regs[ep->num]->diepctl);
-	} else {
+	else
 		depctl_addr = &(core_if->dev_if->out_ep_regs[ep->num]->doepctl);
-	}
 
 	depctl.d32 = DWC_READ_REG32(depctl_addr);
 
@@ -5004,8 +5087,8 @@ void dwc_otg_ep_clear_stall(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param dest	  Destination buffer for the packet.
  * @param bytes  Number of bytes to copy to the destination.
  */
-void dwc_otg_read_packet(dwc_otg_core_if_t * core_if,
-			 uint8_t * dest, uint16_t bytes)
+void dwc_otg_read_packet(dwc_otg_core_if_t *core_if,
+			 uint8_t *dest, uint16_t bytes)
 {
 	int i;
 	int word_count = (bytes + 3) / 4;
@@ -5022,9 +5105,8 @@ void dwc_otg_read_packet(dwc_otg_core_if_t * core_if,
 	DWC_DEBUGPL((DBG_PCDV | DBG_CILV), "%s(%p,%p,%d)\n", __func__,
 		    core_if, dest, bytes);
 
-	for (i = 0; i < word_count; i++, data_buff++) {
+	for (i = 0; i < word_count; i++, data_buff++)
 		*data_buff = DWC_READ_REG32(fifo);
-	}
 
 	return;
 }
@@ -5034,7 +5116,7 @@ void dwc_otg_read_packet(dwc_otg_core_if_t * core_if,
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
+void dwc_otg_dump_dev_registers(dwc_otg_core_if_t *core_if)
 {
 	int i;
 	volatile uint32_t *addr;
@@ -5106,8 +5188,8 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
 
 		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
 			addr =
-			    &core_if->dev_if->
-			    dev_global_regs->diepeachintmsk[i];
+			    &core_if->dev_if->dev_global_regs->
+			    diepeachintmsk[i];
 			DWC_PRINTF("DIEPEACHINTMSK[%d]	 @0x%08lX : 0x%08X\n",
 				   i, (unsigned long)addr,
 				   DWC_READ_REG32(addr));
@@ -5115,8 +5197,8 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
 
 		for (i = 0; i <= core_if->dev_if->num_out_eps; i++) {
 			addr =
-			    &core_if->dev_if->
-			    dev_global_regs->doepeachintmsk[i];
+			    &core_if->dev_if->dev_global_regs->
+			    doepeachintmsk[i];
 			DWC_PRINTF("DOEPEACHINTMSK[%d]	 @0x%08lX : 0x%08X\n",
 				   i, (unsigned long)addr,
 				   DWC_READ_REG32(addr));
@@ -5124,7 +5206,7 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
 	}
 
 	for (i = 0; i <= core_if->core_params->dev_endpoints; i++) {
-		if(hwcfg1 & (2<<(i<<1))){
+		if (hwcfg1 & (2 << (i << 1))) {
 			DWC_PRINTF("Device IN EP %d Registers\n", i);
 			addr = &core_if->dev_if->in_ep_regs[i]->diepctl;
 			DWC_PRINTF("DIEPCTL	 @0x%08lX : 0x%08X\n",
@@ -5143,12 +5225,13 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
 				   (unsigned long)addr, DWC_READ_REG32(addr));
 			addr = &core_if->dev_if->in_ep_regs[i]->diepdmab;
 			DWC_PRINTF("DIEPDMAB	 @0x%08lX : 0x%08X\n",
-				   (unsigned long)addr, 0 /*DWC_READ_REG32(addr) */ );
+				   (unsigned long)addr,
+				   0 /*DWC_READ_REG32(addr) */);
 		}
 	}
 
 	for (i = 0; i <= core_if->core_params->dev_endpoints; i++) {
-		if(hwcfg1 & (1<<(i<<1))){
+		if (hwcfg1 & (1 << (i << 1))) {
 			DWC_PRINTF("Device OUT EP %d Registers\n", i);
 			addr = &core_if->dev_if->out_ep_regs[i]->doepctl;
 			DWC_PRINTF("DOEPCTL	 @0x%08lX : 0x%08X\n",
@@ -5162,10 +5245,13 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
 			addr = &core_if->dev_if->out_ep_regs[i]->doepdma;
 			DWC_PRINTF("DOEPDMA	 @0x%08lX : 0x%08X\n",
 				   (unsigned long)addr, DWC_READ_REG32(addr));
-			if (core_if->dma_enable) {	/* Don't access this register in SLAVE mode */
-				addr = &core_if->dev_if->out_ep_regs[i]->doepdmab;
+			/* Don't access this register in SLAVE mode */
+			if (core_if->dma_enable) {
+				addr =
+				    &core_if->dev_if->out_ep_regs[i]->doepdmab;
 				DWC_PRINTF("DOEPDMAB	 @0x%08lX : 0x%08X\n",
-					   (unsigned long)addr, DWC_READ_REG32(addr));
+					   (unsigned long)addr,
+					   DWC_READ_REG32(addr));
 			}
 		}
 
@@ -5177,7 +5263,7 @@ void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_dump_spram(dwc_otg_core_if_t * core_if)
+void dwc_otg_dump_spram(dwc_otg_core_if_t *core_if)
 {
 	volatile uint8_t *addr, *start_addr, *end_addr;
 
@@ -5205,7 +5291,7 @@ void dwc_otg_dump_spram(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_dump_host_registers(dwc_otg_core_if_t * core_if)
+void dwc_otg_dump_host_registers(dwc_otg_core_if_t *core_if)
 {
 	int i;
 	volatile uint32_t *addr;
@@ -5274,7 +5360,7 @@ void dwc_otg_dump_host_registers(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_dump_global_registers(dwc_otg_core_if_t * core_if)
+void dwc_otg_dump_global_registers(dwc_otg_core_if_t *core_if)
 {
 	int i, ep_num;
 	volatile uint32_t *addr;
@@ -5380,7 +5466,7 @@ void dwc_otg_dump_global_registers(dwc_otg_core_if_t * core_if)
  * @param core_if Programming view of DWC_otg controller.
  * @param num Tx FIFO to flush.
  */
-void dwc_otg_flush_tx_fifo(dwc_otg_core_if_t * core_if, const int num)
+void dwc_otg_flush_tx_fifo(dwc_otg_core_if_t *core_if, const int num)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	volatile grstctl_t greset = {.d32 = 0 };
@@ -5412,7 +5498,7 @@ void dwc_otg_flush_tx_fifo(dwc_otg_core_if_t * core_if, const int num)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-void dwc_otg_flush_rx_fifo(dwc_otg_core_if_t * core_if)
+void dwc_otg_flush_rx_fifo(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	volatile grstctl_t greset = {.d32 = 0 };
@@ -5443,11 +5529,11 @@ void dwc_otg_flush_rx_fifo(dwc_otg_core_if_t * core_if)
  * Do core a soft reset of the core.  Be careful with this because it
  * resets all the internal state machines of the core.
  */
-void dwc_otg_core_reset(dwc_otg_core_if_t * core_if)
+void dwc_otg_core_reset(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	volatile grstctl_t greset = {.d32 = 0 };
-	volatile gusbcfg_data_t usbcfg = { .d32 = 0 };
+	volatile gusbcfg_data_t usbcfg = {.d32 = 0 };
 	int count = 0;
 
 	DWC_DEBUGPL(DBG_CILV, "%s\n", __func__);
@@ -5460,13 +5546,13 @@ void dwc_otg_core_reset(dwc_otg_core_if_t * core_if)
 				 greset.d32);
 			return;
 		}
-	}
-	while (greset.b.ahbidle == 0);
+	} while (greset.b.ahbidle == 0);
 
 	/* Core Soft Reset */
 	count = 0;
 	greset.b.csftrst = 1;
 	DWC_WRITE_REG32(&global_regs->grstctl, greset.d32);
+
 	do {
 		greset.d32 = DWC_READ_REG32(&global_regs->grstctl);
 		if (++count > 10000) {
@@ -5475,35 +5561,32 @@ void dwc_otg_core_reset(dwc_otg_core_if_t * core_if)
 			break;
 		}
 		dwc_udelay(1);
-	}
-	while (greset.b.csftrst == 1);
+	} while (greset.b.csftrst == 1);
+
 	usbcfg.d32 = DWC_READ_REG32(&global_regs->gusbcfg);
-	if(core_if->usb_mode == USB_MODE_FORCE_HOST)
-	{
+	if (core_if->usb_mode == USB_MODE_FORCE_HOST) {
 		usbcfg.b.force_host_mode = 1;
 		usbcfg.b.force_dev_mode = 0;
-	} else if(core_if->usb_mode == USB_MODE_FORCE_DEVICE)
-	{
+	} else if (core_if->usb_mode == USB_MODE_FORCE_DEVICE) {
 		usbcfg.b.force_host_mode = 0;
 		usbcfg.b.force_dev_mode = 1;
-	} else
-	{
+	} else {
 		usbcfg.b.force_host_mode = 0;
 		usbcfg.b.force_dev_mode = 0;
 	}
-	DWC_WRITE_REG32( &global_regs->gusbcfg, usbcfg.d32 );
+	DWC_WRITE_REG32(&global_regs->gusbcfg, usbcfg.d32);
 
 	/* Wait for 3 PHY Clocks */
 	dwc_mdelay(100);
 
 }
 
-uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t * _core_if)
+uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t *_core_if)
 {
 	return (dwc_otg_mode(_core_if) != DWC_HOST_MODE);
 }
 
-uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t * _core_if)
+uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t *_core_if)
 {
 	return (dwc_otg_mode(_core_if) == DWC_HOST_MODE);
 }
@@ -5516,11 +5599,11 @@ uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t * _core_if)
  * @param cb the HCD callback structure.
  * @param p pointer to be passed to callback function (usb_hcd*).
  */
-void dwc_otg_cil_register_hcd_callbacks(dwc_otg_core_if_t * core_if,
-					dwc_otg_cil_callbacks_t * cb, void *p)
+void dwc_otg_cil_register_hcd_callbacks(dwc_otg_core_if_t *core_if,
+					dwc_otg_cil_callbacks_t *cb, void *p)
 {
 	core_if->hcd_cb = cb;
-	//cb->p = p;
+	/* cb->p = p; */
 	core_if->hcd_cb_p = p;
 }
 
@@ -5532,8 +5615,8 @@ void dwc_otg_cil_register_hcd_callbacks(dwc_otg_core_if_t * core_if,
  * @param cb the PCD callback structure.
  * @param p pointer to be passed to callback function (pcd*).
  */
-void dwc_otg_cil_register_pcd_callbacks(dwc_otg_core_if_t * core_if,
-					dwc_otg_cil_callbacks_t * cb, void *p)
+void dwc_otg_cil_register_pcd_callbacks(dwc_otg_core_if_t *core_if,
+					dwc_otg_cil_callbacks_t *cb, void *p)
 {
 	core_if->pcd_cb = cb;
 	cb->p = p;
@@ -5548,7 +5631,7 @@ void dwc_otg_cil_register_pcd_callbacks(dwc_otg_core_if_t * core_if,
  * @param ep The EP to start the transfer on.
  *
  */
-void write_isoc_frame_data(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void write_isoc_frame_data(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	dwc_otg_dev_in_ep_regs_t *ep_regs;
 	dtxfsts_data_t txstatus = {.d32 = 0 };
@@ -5586,8 +5669,8 @@ void write_isoc_frame_data(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 
 		dwords = (len + 3) / 4;
 		txstatus.d32 =
-		    DWC_READ_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-				   dtxfsts);
+		    DWC_READ_REG32(&core_if->dev_if->
+				   in_ep_regs[ep->num]->dtxfsts);
 		DWC_DEBUGPL(DBG_PCDV, "dtxfsts[%d]=0x%08x\n", ep->num,
 			    txstatus.d32);
 	}
@@ -5600,19 +5683,18 @@ void write_isoc_frame_data(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param ep The EP to start the transfer on.
  *
  */
-void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
-				       dwc_ep_t * ep)
+void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t *core_if,
+				       dwc_ep_t *ep)
 {
 	deptsiz_data_t deptsiz = {.d32 = 0 };
 	depctl_data_t depctl = {.d32 = 0 };
 	dsts_data_t dsts = {.d32 = 0 };
 	volatile uint32_t *addr;
 
-	if (ep->is_in) {
+	if (ep->is_in)
 		addr = &core_if->dev_if->in_ep_regs[ep->num]->diepctl;
-	} else {
+	else
 		addr = &core_if->dev_if->out_ep_regs[ep->num]->doepctl;
-	}
 
 	ep->xfer_len = ep->data_per_frame;
 	ep->xfer_count = 0;
@@ -5621,9 +5703,9 @@ void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
 
 	if (ep->is_in) {
 		/* Program the transfer size and packet count
-		 *      as follows: xfersize = N * maxpacket +
-		 *      short_packet pktcnt = N + (short_packet
-		 *      exist ? 1 : 0) 
+		 *	as follows: xfersize = N * maxpacket +
+		 *	short_packet pktcnt = N + (short_packet
+		 *	exist ? 1 : 0)
 		 */
 		deptsiz.b.xfersize = ep->xfer_len;
 		deptsiz.b.pktcnt =
@@ -5635,22 +5717,22 @@ void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
 		/* Write the DMA register */
 		if (core_if->dma_enable) {
 			DWC_WRITE_REG32(&
-					(core_if->dev_if->in_ep_regs[ep->num]->
-					 diepdma), (uint32_t) ep->dma_addr);
+					(core_if->dev_if->
+					 in_ep_regs[ep->num]->diepdma),
+					(uint32_t) ep->dma_addr);
 		}
 	} else {
 		deptsiz.b.pktcnt =
 		    (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 		deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 
-		DWC_WRITE_REG32(&core_if->dev_if->
-				out_ep_regs[ep->num]->doeptsiz, deptsiz.d32);
+		DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->
+				doeptsiz, deptsiz.d32);
 
 		if (core_if->dma_enable) {
 			DWC_WRITE_REG32(&
-					(core_if->dev_if->
-					 out_ep_regs[ep->num]->doepdma),
-					(uint32_t) ep->dma_addr);
+					(core_if->dev_if->out_ep_regs[ep->num]->
+					 doepdma), (uint32_t) ep->dma_addr);
 		}
 	}
 
@@ -5662,19 +5744,17 @@ void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
 		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dsts);
 		ep->next_frame = dsts.b.soffn + ep->bInterval;
 
-		if (ep->next_frame & 0x1) {
+		if (ep->next_frame & 0x1)
 			depctl.b.setd1pid = 1;
-		} else {
+		else
 			depctl.b.setd0pid = 1;
-		}
 	} else {
 		ep->next_frame += ep->bInterval;
 
-		if (ep->next_frame & 0x1) {
+		if (ep->next_frame & 0x1)
 			depctl.b.setd1pid = 1;
-		} else {
+		else
 			depctl.b.setd0pid = 1;
-		}
 	}
 	depctl.b.epena = 1;
 	depctl.b.cnak = 1;
@@ -5689,7 +5769,7 @@ void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
 }
 #endif /* DWC_EN_ISOC */
 
-static void dwc_otg_set_uninitialized(int32_t * p, int size)
+static void dwc_otg_set_uninitialized(int32_t *p, int size)
 {
 	int i;
 	for (i = 0; i < size; i++) {
@@ -5702,15 +5782,14 @@ static int dwc_otg_param_initialized(int32_t val)
 	return val != -1;
 }
 
-static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if)
+static int dwc_otg_setup_params(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 	gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 
 	core_if->core_params = DWC_ALLOC(sizeof(*core_if->core_params));
-	if (!core_if->core_params) {
+	if (!core_if->core_params)
 		return -DWC_E_NO_MEMORY;
-	}
 	dwc_otg_set_uninitialized((int32_t *) core_if->core_params,
 				  sizeof(*core_if->core_params) /
 				  sizeof(int32_t));
@@ -5768,30 +5847,38 @@ static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if)
 	if (gintsts.b.curmode) {
 		/* Force device mode to get power-on values of device FIFOs */
 		gusbcfg_data_t gusbcfg = {.d32 = 0 };
-		gusbcfg.d32 =  DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
+		gusbcfg.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 		gusbcfg.b.force_dev_mode = 1;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, gusbcfg.d32);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg,
+				gusbcfg.d32);
 		dwc_mdelay(100);
 		for (i = 0; i < 15; i++) {
-		dwc_otg_set_param_dev_perio_tx_fifo_size(core_if,
-							 dwc_param_dev_perio_tx_fifo_size_default, i);
+			dwc_otg_set_param_dev_perio_tx_fifo_size(core_if,
+								 dwc_param_dev_perio_tx_fifo_size_default,
+								 i);
 		}
 		for (i = 0; i < 15; i++) {
 			dwc_otg_set_param_dev_tx_fifo_size(core_if,
-							   dwc_param_dev_tx_fifo_size_default, i);
+							   dwc_param_dev_tx_fifo_size_default,
+							   i);
 		}
-		gusbcfg.d32 =  DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
+		gusbcfg.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 		gusbcfg.b.force_dev_mode = 0;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, gusbcfg.d32);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg,
+				gusbcfg.d32);
 		dwc_mdelay(100);
 	} else {
 		for (i = 0; i < 15; i++) {
 			dwc_otg_set_param_dev_perio_tx_fifo_size(core_if,
-				dwc_param_dev_perio_tx_fifo_size_default, i);
+								 dwc_param_dev_perio_tx_fifo_size_default,
+								 i);
 		}
 		for (i = 0; i < 15; i++) {
 			dwc_otg_set_param_dev_tx_fifo_size(core_if,
-				dwc_param_dev_tx_fifo_size_default, i);
+							   dwc_param_dev_tx_fifo_size_default,
+							   i);
 		}
 	}
 #endif
@@ -5799,11 +5886,12 @@ static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if)
 	dwc_otg_set_param_mpi_enable(core_if, dwc_param_mpi_enable_default);
 	dwc_otg_set_param_pti_enable(core_if, dwc_param_pti_enable_default);
 	dwc_otg_set_param_lpm_enable(core_if, dwc_param_lpm_enable_default);
-		
+
 	dwc_otg_set_param_besl_enable(core_if, dwc_param_besl_enable_default);
-	dwc_otg_set_param_baseline_besl(core_if, dwc_param_baseline_besl_default);
+	dwc_otg_set_param_baseline_besl(core_if,
+					dwc_param_baseline_besl_default);
 	dwc_otg_set_param_deep_besl(core_if, dwc_param_deep_besl_default);
-	
+
 	dwc_otg_set_param_ic_usb_cap(core_if, dwc_param_ic_usb_cap_default);
 	dwc_otg_set_param_tx_thr_length(core_if,
 					dwc_param_tx_thr_length_default);
@@ -5821,7 +5909,7 @@ static int dwc_otg_setup_params(dwc_otg_core_if_t * core_if)
 	return 0;
 }
 
-uint8_t dwc_otg_is_dma_enable(dwc_otg_core_if_t * core_if)
+uint8_t dwc_otg_is_dma_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->dma_enable;
 }
@@ -5832,7 +5920,7 @@ uint8_t dwc_otg_is_dma_enable(dwc_otg_core_if_t * core_if)
 		((_param_) > (_high_)))
 
 /* Parameter access functions */
-int dwc_otg_set_param_otg_cap(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_otg_cap(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int valid;
 	int retval = 0;
@@ -5891,12 +5979,12 @@ int dwc_otg_set_param_otg_cap(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_otg_cap(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_otg_cap(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->otg_cap;
 }
 
-int dwc_otg_set_param_opt(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_opt(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
 		DWC_WARN("Wrong value for opt parameter\n");
@@ -5906,12 +5994,12 @@ int dwc_otg_set_param_opt(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_opt(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_opt(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->opt;
 }
 
-int dwc_otg_set_param_dma_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dma_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -5936,12 +6024,12 @@ int dwc_otg_set_param_dma_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dma_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dma_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dma_enable;
 }
 
-int dwc_otg_set_param_dma_desc_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dma_desc_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -5966,12 +6054,12 @@ int dwc_otg_set_param_dma_desc_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dma_desc_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dma_desc_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dma_desc_enable;
 }
 
-int dwc_otg_set_param_host_support_fs_ls_low_power(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_host_support_fs_ls_low_power(dwc_otg_core_if_t *core_if,
 						   int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -5983,13 +6071,13 @@ int dwc_otg_set_param_host_support_fs_ls_low_power(dwc_otg_core_if_t * core_if,
 	return 0;
 }
 
-int32_t dwc_otg_get_param_host_support_fs_ls_low_power(dwc_otg_core_if_t *
-						       core_if)
+int32_t dwc_otg_get_param_host_support_fs_ls_low_power(dwc_otg_core_if_t
+						       *core_if)
 {
 	return core_if->core_params->host_support_fs_ls_low_power;
 }
 
-int dwc_otg_set_param_enable_dynamic_fifo(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_enable_dynamic_fifo(dwc_otg_core_if_t *core_if,
 					  int32_t val)
 {
 	int retval = 0;
@@ -6013,12 +6101,12 @@ int dwc_otg_set_param_enable_dynamic_fifo(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_enable_dynamic_fifo(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_enable_dynamic_fifo(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->enable_dynamic_fifo;
 }
 
-int dwc_otg_set_param_data_fifo_size(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_data_fifo_size(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 32, 32768)) {
@@ -6042,12 +6130,12 @@ int dwc_otg_set_param_data_fifo_size(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_data_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_data_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->data_fifo_size;
 }
 
-int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 16, 32768)) {
@@ -6057,8 +6145,10 @@ int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if, int32_t val)
 	}
 
 	if (val > DWC_READ_REG32(&core_if->core_global_regs->grxfsiz)) {
-		if (dwc_otg_param_initialized(core_if->core_params->dev_rx_fifo_size)) {
-		DWC_WARN("%d invalid for dev_rx_fifo_size parameter\n", val);
+		if (dwc_otg_param_initialized
+		    (core_if->core_params->dev_rx_fifo_size)) {
+			DWC_WARN("%d invalid for dev_rx_fifo_size parameter\n",
+				 val);
 		}
 		val = DWC_READ_REG32(&core_if->core_global_regs->grxfsiz);
 		retval = -DWC_E_INVALID;
@@ -6068,12 +6158,12 @@ int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dev_rx_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dev_rx_fifo_size;
 }
 
-int dwc_otg_set_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					      int32_t val)
 {
 	int retval = 0;
@@ -6101,12 +6191,12 @@ int dwc_otg_set_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dev_nperio_tx_fifo_size;
 }
 
-int dwc_otg_set_param_host_rx_fifo_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_host_rx_fifo_size(dwc_otg_core_if_t *core_if,
 					int32_t val)
 {
 	int retval = 0;
@@ -6133,12 +6223,12 @@ int dwc_otg_set_param_host_rx_fifo_size(dwc_otg_core_if_t * core_if,
 
 }
 
-int32_t dwc_otg_get_param_host_rx_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_host_rx_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->host_rx_fifo_size;
 }
 
-int dwc_otg_set_param_host_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_host_nperio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					       int32_t val)
 {
 	int retval = 0;
@@ -6166,12 +6256,12 @@ int dwc_otg_set_param_host_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_host_nperio_tx_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_host_nperio_tx_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->host_nperio_tx_fifo_size;
 }
 
-int dwc_otg_set_param_host_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_host_perio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					      int32_t val)
 {
 	int retval = 0;
@@ -6196,12 +6286,12 @@ int dwc_otg_set_param_host_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_host_perio_tx_fifo_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_host_perio_tx_fifo_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->host_perio_tx_fifo_size;
 }
 
-int dwc_otg_set_param_max_transfer_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_max_transfer_size(dwc_otg_core_if_t *core_if,
 					int32_t val)
 {
 	int retval = 0;
@@ -6229,12 +6319,12 @@ int dwc_otg_set_param_max_transfer_size(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_max_transfer_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_max_transfer_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->max_transfer_size;
 }
 
-int dwc_otg_set_param_max_packet_count(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_max_packet_count(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6260,12 +6350,12 @@ int dwc_otg_set_param_max_packet_count(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_max_packet_count(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_max_packet_count(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->max_packet_count;
 }
 
-int dwc_otg_set_param_host_channels(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_host_channels(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6290,12 +6380,12 @@ int dwc_otg_set_param_host_channels(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_host_channels(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_host_channels(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->host_channels;
 }
 
-int dwc_otg_set_param_dev_endpoints(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dev_endpoints(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6320,12 +6410,12 @@ int dwc_otg_set_param_dev_endpoints(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_endpoints(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dev_endpoints(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dev_endpoints;
 }
 
-int dwc_otg_set_param_phy_type(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_phy_type(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 0;
@@ -6369,12 +6459,12 @@ int dwc_otg_set_param_phy_type(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_phy_type(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_phy_type(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->phy_type;
 }
 
-int dwc_otg_set_param_speed(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_speed(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6398,12 +6488,12 @@ int dwc_otg_set_param_speed(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_speed(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_speed(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->speed;
 }
 
-int dwc_otg_set_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t *core_if,
 						int32_t val)
 {
 	int retval = 0;
@@ -6435,12 +6525,12 @@ int dwc_otg_set_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->host_ls_low_power_phy_clk;
 }
 
-int dwc_otg_set_param_phy_ulpi_ddr(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_phy_ulpi_ddr(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
 		DWC_WARN("Wrong value for phy_ulpi_ddr\n");
@@ -6452,12 +6542,12 @@ int dwc_otg_set_param_phy_ulpi_ddr(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_phy_ulpi_ddr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_phy_ulpi_ddr(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->phy_ulpi_ddr;
 }
 
-int dwc_otg_set_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t *core_if,
 					int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6470,12 +6560,12 @@ int dwc_otg_set_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if,
 	return 0;
 }
 
-int32_t dwc_otg_get_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->phy_ulpi_ext_vbus;
 }
 
-int dwc_otg_set_param_phy_utmi_width(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_phy_utmi_width(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 8, 8) && DWC_OTG_PARAM_TEST(val, 16, 16)) {
 		DWC_WARN("Wrong valaue for phy_utmi_width\n");
@@ -6487,12 +6577,12 @@ int dwc_otg_set_param_phy_utmi_width(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_phy_utmi_width(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_phy_utmi_width(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->phy_utmi_width;
 }
 
-int dwc_otg_set_param_ulpi_fs_ls(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_ulpi_fs_ls(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
 		DWC_WARN("Wrong valaue for ulpi_fs_ls\n");
@@ -6504,12 +6594,12 @@ int dwc_otg_set_param_ulpi_fs_ls(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_ulpi_fs_ls(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_ulpi_fs_ls(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->ulpi_fs_ls;
 }
 
-int dwc_otg_set_param_ts_dline(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_ts_dline(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
 		DWC_WARN("Wrong valaue for ts_dline\n");
@@ -6521,12 +6611,12 @@ int dwc_otg_set_param_ts_dline(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_ts_dline(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_ts_dline(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->ts_dline;
 }
 
-int dwc_otg_set_param_i2c_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_i2c_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6550,36 +6640,44 @@ int dwc_otg_set_param_i2c_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_i2c_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_i2c_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->i2c_enable;
 }
 
-int dwc_otg_set_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					     int32_t val, int fifo_num)
 {
 	int retval = 0;
 	gintsts_data_t gintsts;
 	gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 
-	if (core_if->hwcfg4.b.ded_fifo_en == 0){
+	if (core_if->hwcfg4.b.ded_fifo_en == 0) {
 		if (DWC_OTG_PARAM_TEST(val, 4, 768)) {
 			DWC_WARN("Wrong value for dev_perio_tx_fifo_size\n");
 			DWC_WARN("dev_perio_tx_fifo_size must be 4-768\n");
 			return -DWC_E_INVALID;
 		}
 
-		if (val > (DWC_READ_REG32(&core_if->core_global_regs->dtxfsiz[fifo_num]) >> 16)) {
-			printk("%d   ",DWC_READ_REG32(&core_if->core_global_regs->dtxfsiz[fifo_num]) >> 16);
-			printk("val = %d fifo_num = %d\n",val,fifo_num);
+		if (val >
+		    (DWC_READ_REG32
+		     (&core_if->core_global_regs->dtxfsiz[fifo_num]) >> 16)) {
+			printk("%d   ",
+			       DWC_READ_REG32(&core_if->core_global_regs->
+					      dtxfsiz[fifo_num]) >> 16);
+			printk("val = %d fifo_num = %d\n", val, fifo_num);
 			DWC_WARN("Value is larger then power-on FIFO size\n");
 			if (dwc_otg_param_initialized
-			   (core_if->core_params->dev_perio_tx_fifo_size[fifo_num])) {
+			    (core_if->core_params->
+			     dev_perio_tx_fifo_size[fifo_num])) {
 				DWC_ERROR
-				("`%d' invalid for parameter `dev_perio_fifo_size_%d'. Check HW configuration.\n",
-				val, fifo_num);
+				    ("`%d' invalid for parameter `dev_perio_fifo_size_%d'. Check HW configuration.\n",
+				     val, fifo_num);
 			}
-			val = (DWC_READ_REG32(&core_if->core_global_regs->dtxfsiz[fifo_num]) >> 16);
+			val =
+			    (DWC_READ_REG32
+			     (&core_if->core_global_regs->
+			      dtxfsiz[fifo_num]) >> 16);
 			retval = -DWC_E_INVALID;
 		}
 
@@ -6588,13 +6686,13 @@ int dwc_otg_set_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int32_t dwc_otg_get_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 						 int fifo_num)
 {
 	return core_if->core_params->dev_perio_tx_fifo_size[fifo_num];
 }
 
-int dwc_otg_set_param_en_multiple_tx_fifo(dwc_otg_core_if_t * core_if,
+int dwc_otg_set_param_en_multiple_tx_fifo(dwc_otg_core_if_t *core_if,
 					  int32_t val)
 {
 	int retval = 0;
@@ -6619,17 +6717,18 @@ int dwc_otg_set_param_en_multiple_tx_fifo(dwc_otg_core_if_t * core_if,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_en_multiple_tx_fifo(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_en_multiple_tx_fifo(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->en_multiple_tx_fifo;
 }
 
-int dwc_otg_set_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if, int32_t val,
+int dwc_otg_set_param_dev_tx_fifo_size(dwc_otg_core_if_t *core_if, int32_t val,
 				       int fifo_num)
 {
 	int retval = 0;
 	fifosize_data_t txfifosize;
-	txfifosize.d32 = DWC_READ_REG32(&core_if->core_global_regs->dtxfsiz[fifo_num]);	
+	txfifosize.d32 =
+	    DWC_READ_REG32(&core_if->core_global_regs->dtxfsiz[fifo_num]);
 
 	if (DWC_OTG_PARAM_TEST(val, 16, 32768)) {
 		DWC_WARN("Wrong value for dev_tx_fifo_size\n");
@@ -6641,13 +6740,13 @@ int dwc_otg_set_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if, int32_t val,
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if,
+int32_t dwc_otg_get_param_dev_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					   int fifo_num)
 {
 	return core_if->core_params->dev_tx_fifo_size[fifo_num];
 }
 
-int dwc_otg_set_param_thr_ctl(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_thr_ctl(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6673,12 +6772,12 @@ int dwc_otg_set_param_thr_ctl(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_thr_ctl(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_thr_ctl(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->thr_ctl;
 }
 
-int dwc_otg_set_param_lpm_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_lpm_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6702,12 +6801,12 @@ int dwc_otg_set_param_lpm_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_lpm_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_lpm_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->lpm_enable;
 }
 
-int dwc_otg_set_param_besl_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_besl_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6718,24 +6817,23 @@ int dwc_otg_set_param_besl_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	}
 
 	core_if->core_params->besl_enable = val;
-	
-	if(val)
-	{
-		retval += dwc_otg_set_param_lpm_enable(core_if,val);
+
+	if (val) {
+		retval += dwc_otg_set_param_lpm_enable(core_if, val);
 	}
-	
+
 	return retval;
 }
 
-int32_t dwc_otg_get_param_besl_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_besl_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->besl_enable;
 }
 
-int dwc_otg_set_param_baseline_besl(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_baseline_besl(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
-		
+
 	if (DWC_OTG_PARAM_TEST(val, 0, 15)) {
 		DWC_WARN("Wrong value for baseline_besl\n");
 		DWC_WARN("baseline_besl must be 0-15\n");
@@ -6746,12 +6844,12 @@ int dwc_otg_set_param_baseline_besl(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_baseline_besl(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_baseline_besl(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->baseline_besl;
 }
 
-int dwc_otg_set_param_deep_besl(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_deep_besl(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -6765,12 +6863,12 @@ int dwc_otg_set_param_deep_besl(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_deep_besl(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_deep_besl(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->deep_besl;
 }
 
-int dwc_otg_set_param_tx_thr_length(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_tx_thr_length(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 8, 128)) {
 		DWC_WARN("Wrong valaue for tx_thr_length\n");
@@ -6782,12 +6880,12 @@ int dwc_otg_set_param_tx_thr_length(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_tx_thr_length(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_tx_thr_length(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->tx_thr_length;
 }
 
-int dwc_otg_set_param_rx_thr_length(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_rx_thr_length(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 8, 128)) {
 		DWC_WARN("Wrong valaue for rx_thr_length\n");
@@ -6799,12 +6897,12 @@ int dwc_otg_set_param_rx_thr_length(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_rx_thr_length(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_rx_thr_length(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->rx_thr_length;
 }
 
-int dwc_otg_set_param_dma_burst_size(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dma_burst_size(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	if (DWC_OTG_PARAM_TEST(val, 1, 1) &&
 	    DWC_OTG_PARAM_TEST(val, 4, 4) &&
@@ -6821,12 +6919,12 @@ int dwc_otg_set_param_dma_burst_size(dwc_otg_core_if_t * core_if, int32_t val)
 	return 0;
 }
 
-int32_t dwc_otg_get_param_dma_burst_size(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dma_burst_size(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dma_burst_size;
 }
 
-int dwc_otg_set_param_pti_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_pti_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6846,12 +6944,12 @@ int dwc_otg_set_param_pti_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_pti_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_pti_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->pti_enable;
 }
 
-int dwc_otg_set_param_mpi_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_mpi_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6871,12 +6969,12 @@ int dwc_otg_set_param_mpi_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_mpi_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_mpi_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->mpi_enable;
 }
 
-int dwc_otg_set_param_adp_enable(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_adp_enable(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6901,12 +6999,12 @@ int dwc_otg_set_param_adp_enable(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_adp_enable(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_adp_enable(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->adp_supp_enable;
 }
 
-int dwc_otg_set_param_ic_usb_cap(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_ic_usb_cap(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	if (DWC_OTG_PARAM_TEST(val, 0, 1)) {
@@ -6928,12 +7026,12 @@ int dwc_otg_set_param_ic_usb_cap(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_ic_usb_cap(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_ic_usb_cap(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->ic_usb_cap;
 }
 
-int dwc_otg_set_param_ahb_thr_ratio(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_ahb_thr_ratio(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -6968,12 +7066,12 @@ int dwc_otg_set_param_ahb_thr_ratio(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_ahb_thr_ratio(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_ahb_thr_ratio(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->ahb_thr_ratio;
 }
 
-int dwc_otg_set_param_power_down(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_power_down(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -7007,12 +7105,12 @@ int dwc_otg_set_param_power_down(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_power_down(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_power_down(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->power_down;
 }
 
-int dwc_otg_set_param_reload_ctl(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_reload_ctl(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -7038,12 +7136,12 @@ int dwc_otg_set_param_reload_ctl(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_reload_ctl(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_reload_ctl(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->reload_ctl;
 }
 
-int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -7059,7 +7157,8 @@ int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t * core_if, int32_t val)
 		valid = 0;
 	}
 	if (valid == 0) {
-		if (dwc_otg_param_initialized(core_if->core_params->dev_out_nak)) {
+		if (dwc_otg_param_initialized
+		    (core_if->core_params->dev_out_nak)) {
 			DWC_ERROR("%d invalid for parameter dev_out_nak."
 				  "Check HW configuration.\n", val);
 		}
@@ -7070,12 +7169,12 @@ int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_dev_out_nak(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_dev_out_nak(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->dev_out_nak;
 }
 
-int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -7091,9 +7190,10 @@ int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t * core_if, int32_t val)
 		valid = 0;
 	}
 	if (valid == 0) {
-		if (dwc_otg_param_initialized(core_if->core_params->cont_on_bna)) {
+		if (dwc_otg_param_initialized
+		    (core_if->core_params->cont_on_bna)) {
 			DWC_ERROR("%d invalid for parameter cont_on_bna."
-				"Check HW configuration.\n", val);
+				  "Check HW configuration.\n", val);
 		}
 		retval = -DWC_E_INVALID;
 		val = 0;
@@ -7102,12 +7202,12 @@ int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_cont_on_bna(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_cont_on_bna(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->cont_on_bna;
 }
 
-int dwc_otg_set_param_ahb_single(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_ahb_single(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 	int valid = 1;
@@ -7133,12 +7233,12 @@ int dwc_otg_set_param_ahb_single(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_ahb_single(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_ahb_single(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->ahb_single;
 }
 
-int dwc_otg_set_param_otg_ver(dwc_otg_core_if_t * core_if, int32_t val)
+int dwc_otg_set_param_otg_ver(dwc_otg_core_if_t *core_if, int32_t val)
 {
 	int retval = 0;
 
@@ -7153,57 +7253,59 @@ int dwc_otg_set_param_otg_ver(dwc_otg_core_if_t * core_if, int32_t val)
 	return retval;
 }
 
-int32_t dwc_otg_get_param_otg_ver(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_get_param_otg_ver(dwc_otg_core_if_t *core_if)
 {
 	return core_if->core_params->otg_ver;
 }
 
-uint32_t dwc_otg_get_hnpstatus(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_hnpstatus(dwc_otg_core_if_t *core_if)
 {
 	gotgctl_data_t otgctl;
 	otgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 	return otgctl.b.hstnegscs;
 }
 
-uint32_t dwc_otg_get_srpstatus(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_srpstatus(dwc_otg_core_if_t *core_if)
 {
 	gotgctl_data_t otgctl;
 	otgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 	return otgctl.b.sesreqscs;
 }
 
-void dwc_otg_set_hnpreq(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_hnpreq(dwc_otg_core_if_t *core_if, uint32_t val)
 {
-	if(core_if->otg_ver == 0) {
+	if (core_if->otg_ver == 0) {
 		gotgctl_data_t otgctl;
-		otgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+		otgctl.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 		otgctl.b.hnpreq = val;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gotgctl, otgctl.d32);
+		DWC_WRITE_REG32(&core_if->core_global_regs->gotgctl,
+				otgctl.d32);
 	} else {
 		core_if->otg_sts = val;
 	}
 }
 
-uint32_t dwc_otg_get_gsnpsid(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_gsnpsid(dwc_otg_core_if_t *core_if)
 {
 	return core_if->snpsid;
 }
 
-uint32_t dwc_otg_get_mode(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_mode(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 	gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 	return gintsts.b.curmode;
 }
 
-uint32_t dwc_otg_get_hnpcapable(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_hnpcapable(dwc_otg_core_if_t *core_if)
 {
 	gusbcfg_data_t usbcfg;
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 	return usbcfg.b.hnpcap;
 }
 
-void dwc_otg_set_hnpcapable(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_hnpcapable(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	gusbcfg_data_t usbcfg;
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
@@ -7211,14 +7313,14 @@ void dwc_otg_set_hnpcapable(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, usbcfg.d32);
 }
 
-uint32_t dwc_otg_get_srpcapable(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_srpcapable(dwc_otg_core_if_t *core_if)
 {
 	gusbcfg_data_t usbcfg;
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 	return usbcfg.b.srpcap;
 }
 
-void dwc_otg_set_srpcapable(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_srpcapable(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	gusbcfg_data_t usbcfg;
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
@@ -7226,14 +7328,14 @@ void dwc_otg_set_srpcapable(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, usbcfg.d32);
 }
 
-uint32_t dwc_otg_get_devspeed(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_devspeed(dwc_otg_core_if_t *core_if)
 {
 	dcfg_data_t dcfg;
 	dcfg.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dcfg);
 	return dcfg.b.devspd;
 }
 
-void dwc_otg_set_devspeed(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_devspeed(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	dcfg_data_t dcfg;
 	dcfg.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dcfg);
@@ -7241,21 +7343,21 @@ void dwc_otg_set_devspeed(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dcfg, dcfg.d32);
 }
 
-uint32_t dwc_otg_get_busconnected(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_busconnected(dwc_otg_core_if_t *core_if)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
 	return hprt0.b.prtconnsts;
 }
 
-uint32_t dwc_otg_get_enumspeed(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_enumspeed(dwc_otg_core_if_t *core_if)
 {
 	dsts_data_t dsts;
 	dsts.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dsts);
 	return dsts.b.enumspd;
 }
 
-uint32_t dwc_otg_get_prtpower(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_prtpower(dwc_otg_core_if_t *core_if)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
@@ -7263,12 +7365,12 @@ uint32_t dwc_otg_get_prtpower(dwc_otg_core_if_t * core_if)
 
 }
 
-uint32_t dwc_otg_get_core_state(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_core_state(dwc_otg_core_if_t *core_if)
 {
 	return core_if->hibernation_suspend;
 }
 
-void dwc_otg_set_prtpower(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_prtpower(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -7276,7 +7378,7 @@ void dwc_otg_set_prtpower(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 }
 
-uint32_t dwc_otg_get_prtsuspend(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_prtsuspend(dwc_otg_core_if_t *core_if)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
@@ -7284,7 +7386,7 @@ uint32_t dwc_otg_get_prtsuspend(dwc_otg_core_if_t * core_if)
 
 }
 
-void dwc_otg_set_prtsuspend(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_prtsuspend(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -7292,7 +7394,7 @@ void dwc_otg_set_prtsuspend(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 }
 
-uint32_t dwc_otg_get_fr_interval(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_fr_interval(dwc_otg_core_if_t *core_if)
 {
 	hfir_data_t hfir;
 	hfir.d32 = DWC_READ_REG32(&core_if->host_if->host_global_regs->hfir);
@@ -7300,7 +7402,7 @@ uint32_t dwc_otg_get_fr_interval(dwc_otg_core_if_t * core_if)
 
 }
 
-void dwc_otg_set_fr_interval(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_fr_interval(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	hfir_data_t hfir;
 	uint32_t fram_int;
@@ -7365,7 +7467,7 @@ void dwc_otg_set_fr_interval(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hfir, hfir.d32);
 }
 
-uint32_t dwc_otg_get_mode_ch_tim(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_mode_ch_tim(dwc_otg_core_if_t *core_if)
 {
 	hcfg_data_t hcfg;
 	hcfg.d32 = DWC_READ_REG32(&core_if->host_if->host_global_regs->hcfg);
@@ -7373,7 +7475,7 @@ uint32_t dwc_otg_get_mode_ch_tim(dwc_otg_core_if_t * core_if)
 
 }
 
-void dwc_otg_set_mode_ch_tim(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_mode_ch_tim(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	hcfg_data_t hcfg;
 	hcfg.d32 = DWC_READ_REG32(&core_if->host_if->host_global_regs->hcfg);
@@ -7381,7 +7483,7 @@ void dwc_otg_set_mode_ch_tim(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->host_if->host_global_regs->hcfg, hcfg.d32);
 }
 
-void dwc_otg_set_prtresume(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_prtresume(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -7389,50 +7491,51 @@ void dwc_otg_set_prtresume(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 }
 
-uint32_t dwc_otg_get_remotewakesig(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_remotewakesig(dwc_otg_core_if_t *core_if)
 {
 	dctl_data_t dctl;
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 	return dctl.b.rmtwkupsig;
 }
 
-uint32_t dwc_otg_get_beslreject(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_beslreject(dwc_otg_core_if_t *core_if)
 {
 	dctl_data_t dctl;
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 	return dctl.b.besl_reject;
 }
 
-void dwc_otg_set_beslreject(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_beslreject(dwc_otg_core_if_t *core_if, uint32_t val)
 {
-    dctl_data_t dctl;
+	dctl_data_t dctl;
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 	dctl.b.besl_reject = val;
 	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
 }
-uint32_t dwc_otg_get_hirdthresh(dwc_otg_core_if_t * core_if)
+
+uint32_t dwc_otg_get_hirdthresh(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	return lpmcfg.b.hird_thres;
 }
 
-void dwc_otg_set_hirdthresh(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_hirdthresh(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	glpmcfg_data_t lpmcfg;
-	
+
 	if (DWC_OTG_PARAM_TEST(val, 0, 15)) {
 		DWC_WARN("Wrong valaue for hird_thres\n");
 		DWC_WARN("hird_thres must be 0-f\n");
-		return ;
+		return;
 	}
-	
+
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	lpmcfg.b.hird_thres |= val;
 	DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg, lpmcfg.d32);
 }
 
-uint32_t dwc_otg_get_lpm_portsleepstatus(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_lpm_portsleepstatus(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -7445,21 +7548,21 @@ uint32_t dwc_otg_get_lpm_portsleepstatus(dwc_otg_core_if_t * core_if)
 	return lpmcfg.b.prt_sleep_sts;
 }
 
-uint32_t dwc_otg_get_lpm_remotewakeenabled(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_lpm_remotewakeenabled(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	return lpmcfg.b.rem_wkup_en;
 }
 
-uint32_t dwc_otg_get_lpmresponse(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_lpmresponse(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	return lpmcfg.b.appl_resp;
 }
 
-void dwc_otg_set_lpmresponse(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_lpmresponse(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -7467,14 +7570,14 @@ void dwc_otg_set_lpmresponse(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg, lpmcfg.d32);
 }
 
-uint32_t dwc_otg_get_hsic_connect(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_hsic_connect(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	return lpmcfg.b.hsic_connect;
 }
 
-void dwc_otg_set_hsic_connect(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_hsic_connect(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -7482,7 +7585,7 @@ void dwc_otg_set_hsic_connect(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg, lpmcfg.d32);
 }
 
-uint32_t dwc_otg_get_inv_sel_hsic(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_inv_sel_hsic(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -7490,7 +7593,7 @@ uint32_t dwc_otg_get_inv_sel_hsic(dwc_otg_core_if_t * core_if)
 
 }
 
-void dwc_otg_set_inv_sel_hsic(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_inv_sel_hsic(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	glpmcfg_data_t lpmcfg;
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -7498,95 +7601,96 @@ void dwc_otg_set_inv_sel_hsic(dwc_otg_core_if_t * core_if, uint32_t val)
 	DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg, lpmcfg.d32);
 }
 
-uint32_t dwc_otg_get_gotgctl(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_gotgctl(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 }
 
-void dwc_otg_set_gotgctl(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_gotgctl(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->gotgctl, val);
 }
 
-uint32_t dwc_otg_get_gusbcfg(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_gusbcfg(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
 }
 
-void dwc_otg_set_gusbcfg(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_gusbcfg(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, val);
 }
 
-uint32_t dwc_otg_get_grxfsiz(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_grxfsiz(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->grxfsiz);
 }
 
-void dwc_otg_set_grxfsiz(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_grxfsiz(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->grxfsiz, val);
 }
 
-uint32_t dwc_otg_get_gnptxfsiz(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_gnptxfsiz(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->gnptxfsiz);
 }
 
-void dwc_otg_set_gnptxfsiz(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_gnptxfsiz(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->gnptxfsiz, val);
 }
 
-uint32_t dwc_otg_get_gpvndctl(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_gpvndctl(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->gpvndctl);
 }
 
-void dwc_otg_set_gpvndctl(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_gpvndctl(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->gpvndctl, val);
 }
 
-uint32_t dwc_otg_get_ggpio(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_ggpio(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->ggpio);
 }
 
-void dwc_otg_set_ggpio(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_ggpio(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->ggpio, val);
 }
 
-uint32_t dwc_otg_get_hprt0(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_hprt0(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(core_if->host_if->hprt0);
 
 }
 
-void dwc_otg_set_hprt0(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_hprt0(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(core_if->host_if->hprt0, val);
 }
 
-uint32_t dwc_otg_get_guid(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_guid(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->guid);
 }
 
-void dwc_otg_set_guid(dwc_otg_core_if_t * core_if, uint32_t val)
+void dwc_otg_set_guid(dwc_otg_core_if_t *core_if, uint32_t val)
 {
 	DWC_WRITE_REG32(&core_if->core_global_regs->guid, val);
 }
 
-uint32_t dwc_otg_get_hptxfsiz(dwc_otg_core_if_t * core_if)
+uint32_t dwc_otg_get_hptxfsiz(dwc_otg_core_if_t *core_if)
 {
 	return DWC_READ_REG32(&core_if->core_global_regs->hptxfsiz);
 }
 
-uint16_t dwc_otg_get_otg_version(dwc_otg_core_if_t * core_if)
+uint16_t dwc_otg_get_otg_version(dwc_otg_core_if_t *core_if)
 {
-	return ((core_if->otg_ver == 1) ? (uint16_t)0x0200 : (uint16_t)0x0103);
+	return ((core_if->otg_ver ==
+		 1) ? (uint16_t) 0x0200 : (uint16_t) 0x0103);
 }
 
 /**
@@ -7595,16 +7699,16 @@ uint16_t dwc_otg_get_otg_version(dwc_otg_core_if_t * core_if)
  *
  * @param core_if the pointer to core_if strucure.
  */
-void dwc_otg_pcd_start_srp_timer(dwc_otg_core_if_t * core_if)
+void dwc_otg_pcd_start_srp_timer(dwc_otg_core_if_t *core_if)
 {
 	core_if->srp_timer_started = 1;
-	DWC_TIMER_SCHEDULE(core_if->srp_timer, 6000 /* 6 secs */ );
+	DWC_TIMER_SCHEDULE(core_if->srp_timer, 6000 /* 6 secs */);
 }
 
-void dwc_otg_initiate_srp(void * p)
+void dwc_otg_initiate_srp(void *p)
 {
-	dwc_otg_core_if_t * core_if = p;
-	uint32_t *addr = (uint32_t *) & (core_if->core_global_regs->gotgctl);
+	dwc_otg_core_if_t *core_if = p;
+	uint32_t *addr = (uint32_t *)&(core_if->core_global_regs->gotgctl);
 	gotgctl_data_t mem;
 	gotgctl_data_t val;
 
@@ -7614,7 +7718,7 @@ void dwc_otg_initiate_srp(void * p)
 		return;
 	}
 
-	DWC_INFO("Session Request Initated\n");	//NOTICE
+	DWC_INFO("Session Request Initated\n");
 	mem.d32 = DWC_READ_REG32(addr);
 	mem.b.sesreq = 1;
 	DWC_WRITE_REG32(addr, mem.d32);
@@ -7624,15 +7728,14 @@ void dwc_otg_initiate_srp(void * p)
 	return;
 }
 
-int dwc_otg_check_haps_status(dwc_otg_core_if_t * core_if)
+int dwc_otg_check_haps_status(dwc_otg_core_if_t *core_if)
 {
-   int retval = 0;
+	int retval = 0;
 
-   if(DWC_READ_REG32(&core_if->core_global_regs->gsnpsid) == 0xffffffff)
-   {
+	if (DWC_READ_REG32(&core_if->core_global_regs->gsnpsid) == 0xffffffff) {
 		return -1;
-   } else {
+	} else {
 		return retval;
-   } 
+	}
 
 }
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_cil.h b/drivers/usb/dwc_otg_310/dwc_otg_cil.h
index a7c5960577f5..d25a72ed8742 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_cil.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_cil.h
@@ -60,7 +60,7 @@ typedef enum _data_buffer_mode {
 	BM_CIRCULAR = 3,	/* data buffer uses the circular DMA mode */
 	BM_ALIGN = 4		/* data buffer is in buffer alignment mode */
 } data_buffer_mode_e;
-#endif //DWC_UTE_CFI
+#endif /* DWC_UTE_CFI */
 
 /** Macros defined for DWC OTG HW Release version */
 
@@ -100,7 +100,7 @@ typedef struct dwc_ep {
 	unsigned active:1;
 
 	/**
-	 * Periodic Tx FIFO # for IN EPs For INTR EP set to 0 to use non-periodic 
+	 * Periodic Tx FIFO # for IN EPs For INTR EP set to 0 to use non-periodic
 	 * Tx FIFO. If dedicated Tx FIFOs are enabled Tx FIFO # FOR IN EPs*/
 	unsigned tx_fifo_num:4;
 	/** EP type: 0 - Control, 1 - ISOC,	 2 - BULK,	3 - INTR */
@@ -164,13 +164,13 @@ typedef struct dwc_ep {
 	dma_addr_t descs_dma_addr;
 	/** This variable stores the length of the last enqueued request */
 	uint32_t cfi_req_len;
-#endif				//DWC_UTE_CFI
+#endif/* DWC_UTE_CFI */
 
 /** Max DMA Descriptor count for any EP */
 #define MAX_DMA_DESC_CNT 256
 	/** Allocated DMA Desc count */
 	uint32_t desc_cnt;
-	
+
 	/** bInterval */
 	uint32_t bInterval;
 	/** Next frame num to setup next ISOC transfer */
@@ -448,8 +448,8 @@ typedef struct dwc_otg_core_params {
 	int32_t dma_enable;
 
 	/**
-	 * When DMA mode is enabled specifies whether to use address DMA or DMA 
-	 * Descriptor mode for accessing the data FIFOs in device mode. The driver 
+	 * When DMA mode is enabled specifies whether to use address DMA or DMA
+	 * Descriptor mode for accessing the data FIFOs in device mode. The driver
 	 * will automatically detect the value for this if none is specified.
 	 * 0 - address DMA
 	 * 1 - DMA Descriptor(default, if available)
@@ -648,21 +648,21 @@ typedef struct dwc_otg_core_params {
 	 * Specifies whether LPM (Link Power Management) support is enabled
 	 */
 	int32_t lpm_enable;
-		
+
 	/**
 	* Specifies whether LPM Errata (Link Power Management) support is enabled
 	*/
 	int32_t besl_enable;
-	
+
 	/**
 	* Specifies the baseline besl value
 	*/
 	int32_t baseline_besl;
-	
+
 	/**
 	* Specifies the deep besl value
 	*/
-	int32_t deep_besl;	
+	int32_t deep_besl;
 	/** Per Transfer Interrupt
 	 *	mode enable flag
 	 * 1 - Enabled
@@ -703,22 +703,22 @@ typedef struct dwc_otg_core_params {
 	 */
 	int32_t reload_ctl;
 
-	/** DCFG: Enable device Out NAK 
+	/** DCFG: Enable device Out NAK
 	 * 0 - The core does not set NAK after Bulk Out transfer complete.
 	 * 1 - The core sets NAK after Bulk OUT transfer complete.
 	 */
 	int32_t dev_out_nak;
 
-	/** DCFG: Enable Continue on BNA 
+	/** DCFG: Enable Continue on BNA
 	 * After receiving BNA interrupt the core disables the endpoint,when the
-	 * endpoint is re-enabled by the application the core starts processing 
+	 * endpoint is re-enabled by the application the core starts processing
 	 * 0 - from the DOEPDMA descriptor
 	 * 1 - from the descriptor which received the BNA.
 	 */
 	int32_t cont_on_bna;
 
-	/** GAHBCFG: AHB Single Support 
-	 * This bit when programmed supports SINGLE transfers for remainder 
+	/** GAHBCFG: AHB Single Support
+	 * This bit when programmed supports SINGLE transfers for remainder
 	 * data in a transfer for DMA mode of operation.
 	 * 0 - in this case the remainder data will be sent using INCR burst size.
 	 * 1 - in this case the remainder data will be sent using SINGLE burst size.
@@ -821,7 +821,7 @@ struct dwc_otg_core_if {
 	dwc_otg_dev_if_t *dev_if;
 	/** Host-specific information */
 	dwc_otg_host_if_t *host_if;
-	
+
 	/** Value from SNPSID register */
 	uint32_t snpsid;
 
@@ -842,7 +842,7 @@ struct dwc_otg_core_if {
 	/** Timer for SRP. If it expires before SRP is successful
 	 * clear the SRP. */
 	dwc_timer_t *srp_timer;
-	
+
 	uint8_t usb_mode;
 #define USB_MODE_NORMAL (0)
 #define USB_MODE_FORCE_HOST (1)
@@ -945,8 +945,8 @@ struct dwc_otg_core_if {
 	/** Workqueue object used for handling several interrupts */
 	dwc_workq_t *wq_otg;
 
-        /** Tasklet used for handling "Wakeup Detected" Interrupt*/
-        dwc_tasklet_t *wkp_tasklet;
+	/** Tasklet used for handling "Wakeup Detected" Interrupt*/
+	dwc_tasklet_t *wkp_tasklet;
 	/** This arrays used for debug purposes for DEV OUT NAK enhancement */
 	uint32_t start_doeptsiz_val[MAX_EPS_CHANNELS];
 	ep_xfer_info_t ep_xfer_info[MAX_EPS_CHANNELS];
@@ -1013,7 +1013,7 @@ struct dwc_otg_core_if {
 	 * also used as counter of disabled NP IN EP's */
 	uint8_t start_predict;
 
-	/** NextEp sequence, including EP0: nextep_seq[] = EP if non-periodic and 
+	/** NextEp sequence, including EP0: nextep_seq[] = EP if non-periodic and
 	 * active, 0xff otherwise */
 	uint8_t nextep_seq[MAX_EPS_CHANNELS];
 
@@ -1021,7 +1021,7 @@ struct dwc_otg_core_if {
 	uint8_t first_in_nextep_seq;
 
 	/** Frame number while entering to ISR - needed for ISOCs **/
-	uint32_t frame_num; 
+	uint32_t frame_num;
 
 	/** Flag to not perform ADP probing if IDSTS event happened */
 	uint8_t stop_adpprb;
@@ -1049,66 +1049,66 @@ extern void w_conn_id_status_change(void *p);
 extern void w_wakeup_detected(void *data);
 
 /** Saves global register values into system memory. */
-extern int dwc_otg_save_global_regs(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_save_global_regs(dwc_otg_core_if_t *core_if);
 /** Saves device register values into system memory. */
-extern int dwc_otg_save_dev_regs(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_save_dev_regs(dwc_otg_core_if_t *core_if);
 /** Saves host register values into system memory. */
-extern int dwc_otg_save_host_regs(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_save_host_regs(dwc_otg_core_if_t *core_if);
 /** Restore global register values. */
-extern int dwc_otg_restore_global_regs(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_restore_global_regs(dwc_otg_core_if_t *core_if);
 /** Restore host register values. */
-extern int dwc_otg_restore_host_regs(dwc_otg_core_if_t * core_if, int reset);
+extern int dwc_otg_restore_host_regs(dwc_otg_core_if_t *core_if, int reset);
 /** Restore device register values. */
-extern int dwc_otg_restore_dev_regs(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_restore_dev_regs(dwc_otg_core_if_t *core_if,
 				    int rem_wakeup);
-extern int restore_lpm_i2c_regs(dwc_otg_core_if_t * core_if);
-extern int restore_essential_regs(dwc_otg_core_if_t * core_if, int rmode,
+extern int restore_lpm_i2c_regs(dwc_otg_core_if_t *core_if);
+extern int restore_essential_regs(dwc_otg_core_if_t *core_if, int rmode,
 				  int is_host);
 
-extern int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_host_hibernation_restore(dwc_otg_core_if_t *core_if,
 					    int restore_mode, int reset);
-extern int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_device_hibernation_restore(dwc_otg_core_if_t *core_if,
 					      int rem_wakeup, int reset);
 
 /*
  * The following functions support initialization of the CIL driver component
  * and the DWC_otg controller.
  */
-extern void dwc_otg_core_host_init(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_core_dev_init(dwc_otg_core_if_t * _core_if);
+extern void dwc_otg_core_host_init(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_dev_init(dwc_otg_core_if_t *_core_if);
 
 /** @name Device CIL Functions
  * The following functions support managing the DWC_otg controller in device
  * mode.
  */
 /**@{*/
-extern void dwc_otg_wakeup(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_read_setup_packet(dwc_otg_core_if_t * _core_if,
-				      uint32_t * _dest);
-extern uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_ep0_activate(dwc_otg_core_if_t * _core_if, dwc_ep_t * _ep);
-extern void dwc_otg_ep_activate(dwc_otg_core_if_t * _core_if, dwc_ep_t * _ep);
-extern void dwc_otg_ep_deactivate(dwc_otg_core_if_t * _core_if, dwc_ep_t * _ep);
-extern void dwc_otg_ep_start_transfer(dwc_otg_core_if_t * _core_if,
-				      dwc_ep_t * _ep);
-extern void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t * _core_if,
-					 dwc_ep_t * _ep);
-extern void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t * _core_if,
-				       dwc_ep_t * _ep);
-extern void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t * _core_if,
-					  dwc_ep_t * _ep);
-extern void dwc_otg_ep_write_packet(dwc_otg_core_if_t * _core_if,
-				    dwc_ep_t * _ep, int _dma);
-extern void dwc_otg_ep_set_stall(dwc_otg_core_if_t * _core_if, dwc_ep_t * _ep);
-extern void dwc_otg_ep_clear_stall(dwc_otg_core_if_t * _core_if,
-				   dwc_ep_t * _ep);
-extern void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t * _core_if);
+extern void dwc_otg_wakeup(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_read_setup_packet(dwc_otg_core_if_t *_core_if,
+				      uint32_t *_dest);
+extern uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_ep0_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_deactivate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_start_transfer(dwc_otg_core_if_t *_core_if,
+				      dwc_ep_t *_ep);
+extern void dwc_otg_ep_start_zl_transfer(dwc_otg_core_if_t *_core_if,
+					 dwc_ep_t *_ep);
+extern void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t *_core_if,
+				       dwc_ep_t *_ep);
+extern void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t *_core_if,
+					  dwc_ep_t *_ep);
+extern void dwc_otg_ep_write_packet(dwc_otg_core_if_t *_core_if,
+				    dwc_ep_t *_ep, int _dma);
+extern void dwc_otg_ep_set_stall(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_clear_stall(dwc_otg_core_if_t *_core_if,
+				   dwc_ep_t *_ep);
+extern void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t *_core_if);
 
 #ifdef DWC_EN_ISOC
-extern void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t * core_if,
-					      dwc_ep_t * ep);
-extern void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
-					      dwc_ep_t * ep);
+extern void dwc_otg_iso_ep_start_frm_transfer(dwc_otg_core_if_t *core_if,
+					      dwc_ep_t *ep);
+extern void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t *core_if,
+					      dwc_ep_t *ep);
 #endif /* DWC_EN_ISOC */
 /**@}*/
 
@@ -1117,25 +1117,25 @@ extern void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
  * mode.
  */
 /**@{*/
-extern void dwc_otg_hc_init(dwc_otg_core_if_t * _core_if, dwc_hc_t * _hc);
-extern void dwc_otg_hc_halt(dwc_otg_core_if_t * _core_if,
-			    dwc_hc_t * _hc, dwc_otg_halt_status_e _halt_status);
-extern void dwc_otg_hc_cleanup(dwc_otg_core_if_t * _core_if, dwc_hc_t * _hc);
-extern void dwc_otg_hc_start_transfer(dwc_otg_core_if_t * _core_if,
-				      dwc_hc_t * _hc);
-extern int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t * _core_if,
-					dwc_hc_t * _hc);
-extern void dwc_otg_hc_do_ping(dwc_otg_core_if_t * _core_if, dwc_hc_t * _hc);
-extern void dwc_otg_hc_write_packet(dwc_otg_core_if_t * _core_if,
-				    dwc_hc_t * _hc);
-extern void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t * _core_if);
-
-extern void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t * core_if,
-					   dwc_hc_t * hc);
-
-extern uint32_t calc_frame_interval(dwc_otg_core_if_t * core_if);
-extern int dwc_otg_check_haps_status(dwc_otg_core_if_t * core_if);
+extern void dwc_otg_hc_init(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_halt(dwc_otg_core_if_t *_core_if,
+			    dwc_hc_t *_hc, dwc_otg_halt_status_e _halt_status);
+extern void dwc_otg_hc_cleanup(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_start_transfer(dwc_otg_core_if_t *_core_if,
+				      dwc_hc_t *_hc);
+extern int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t *_core_if,
+					dwc_hc_t *_hc);
+extern void dwc_otg_hc_do_ping(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_write_packet(dwc_otg_core_if_t *_core_if,
+				    dwc_hc_t *_hc);
+extern void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t *_core_if);
+
+extern void dwc_otg_hc_start_transfer_ddma(dwc_otg_core_if_t *core_if,
+					   dwc_hc_t *hc);
+
+extern uint32_t calc_frame_interval(dwc_otg_core_if_t *core_if);
+extern int dwc_otg_check_haps_status(dwc_otg_core_if_t *core_if);
 
 /* Macro used to clear one channel interrupt */
 #define clear_hc_int(_hc_regs_, _intr_) \
@@ -1164,7 +1164,7 @@ do { \
  * WC bits 0 so that if they are read as 1, they won't clear when you
  * write it back
  */
-static inline uint32_t dwc_otg_read_hprt0(dwc_otg_core_if_t * _core_if)
+static inline uint32_t dwc_otg_read_hprt0(dwc_otg_core_if_t *_core_if)
 {
 	hprt0_data_t hprt0;
 	hprt0.d32 = DWC_READ_REG32(_core_if->host_if->hprt0);
@@ -1183,97 +1183,103 @@ static inline uint32_t dwc_otg_read_hprt0(dwc_otg_core_if_t * _core_if)
  */
 /**@{*/
 
-extern void dwc_otg_read_packet(dwc_otg_core_if_t * core_if,
-				uint8_t * dest, uint16_t bytes);
+extern void dwc_otg_read_packet(dwc_otg_core_if_t *core_if,
+				uint8_t *dest, uint16_t bytes);
 
-extern void dwc_otg_flush_tx_fifo(dwc_otg_core_if_t * _core_if, const int _num);
-extern void dwc_otg_flush_rx_fifo(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_core_reset(dwc_otg_core_if_t * _core_if);
+extern void dwc_otg_flush_tx_fifo(dwc_otg_core_if_t *_core_if, const int _num);
+extern void dwc_otg_flush_rx_fifo(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_reset(dwc_otg_core_if_t *_core_if);
 
 /**
  * This function returns the Core Interrupt register.
  */
-static inline uint32_t dwc_otg_read_core_intr(dwc_otg_core_if_t * core_if)
+static inline uint32_t dwc_otg_read_core_intr(dwc_otg_core_if_t *core_if)
 {
-	return (DWC_READ_REG32(&core_if->core_global_regs->gintsts) &
-		DWC_READ_REG32(&core_if->core_global_regs->gintmsk));
+	uint32_t retval;
+	retval = DWC_READ_REG32(&core_if->core_global_regs->gintsts) &
+		 DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
+	return retval;
 }
 
 /**
  * This function returns the OTG Interrupt register.
  */
-static inline uint32_t dwc_otg_read_otg_intr(dwc_otg_core_if_t * core_if)
+static inline uint32_t dwc_otg_read_otg_intr(dwc_otg_core_if_t *core_if)
 {
-	return (DWC_READ_REG32(&core_if->core_global_regs->gotgint));
+	uint32_t retval;
+	retval = DWC_READ_REG32(&core_if->core_global_regs->gotgint);
+	return retval;
 }
 
 /**
  * This function reads the Device All Endpoints Interrupt register and
  * returns the IN endpoint interrupt bits.
  */
-static inline uint32_t dwc_otg_read_dev_all_in_ep_intr(dwc_otg_core_if_t *
-						       core_if)
+static inline uint32_t dwc_otg_read_dev_all_in_ep_intr(dwc_otg_core_if_t
+						       *core_if)
 {
 
 	uint32_t v;
 
 	if (core_if->multiproc_int_enable) {
-		v = DWC_READ_REG32(&core_if->dev_if->
-				   dev_global_regs->deachint) &
-		    DWC_READ_REG32(&core_if->
-				   dev_if->dev_global_regs->deachintmsk);
+		v = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
+				   deachint) & DWC_READ_REG32(&core_if->dev_if->
+							      dev_global_regs->
+							      deachintmsk);
 	} else {
 		v = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->daint) &
 		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->daintmsk);
 	}
-	return (v & 0xffff);
+	v &= 0xffff;
+	return v;
 }
 
 /**
  * This function reads the Device All Endpoints Interrupt register and
  * returns the OUT endpoint interrupt bits.
  */
-static inline uint32_t dwc_otg_read_dev_all_out_ep_intr(dwc_otg_core_if_t *
-							core_if)
+static inline uint32_t dwc_otg_read_dev_all_out_ep_intr(dwc_otg_core_if_t
+							*core_if)
 {
 	uint32_t v;
 
 	if (core_if->multiproc_int_enable) {
-		v = DWC_READ_REG32(&core_if->dev_if->
-				   dev_global_regs->deachint) &
-		    DWC_READ_REG32(&core_if->
-				   dev_if->dev_global_regs->deachintmsk);
+		v = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
+				   deachint) & DWC_READ_REG32(&core_if->dev_if->
+							      dev_global_regs->
+							      deachintmsk);
 	} else {
 		v = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->daint) &
 		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->daintmsk);
 	}
 
-	return ((v & 0xffff0000) >> 16);
+	v = (v & 0xffff0000) >> 16;
+	return v;
 }
 
 /**
  * This function returns the Device IN EP Interrupt register
  */
-static inline uint32_t dwc_otg_read_dev_in_ep_intr(dwc_otg_core_if_t * core_if,
-						   dwc_ep_t * ep)
+static inline uint32_t dwc_otg_read_dev_in_ep_intr(dwc_otg_core_if_t *core_if,
+						   dwc_ep_t *ep)
 {
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 	uint32_t v, msk, emp;
 
 	if (core_if->multiproc_int_enable) {
 		msk =
-		    DWC_READ_REG32(&dev_if->
-				   dev_global_regs->diepeachintmsk[ep->num]);
+		    DWC_READ_REG32(&dev_if->dev_global_regs->
+				   diepeachintmsk[ep->num]);
 		emp =
-		    DWC_READ_REG32(&dev_if->
-				   dev_global_regs->dtknqr4_fifoemptymsk);
+		    DWC_READ_REG32(&dev_if->dev_global_regs->
+				   dtknqr4_fifoemptymsk);
 		msk |= ((emp >> ep->num) & 0x1) << 7;
 		v = DWC_READ_REG32(&dev_if->in_ep_regs[ep->num]->diepint) & msk;
 	} else {
 		msk = DWC_READ_REG32(&dev_if->dev_global_regs->diepmsk);
 		emp =
-		    DWC_READ_REG32(&dev_if->
-				   dev_global_regs->dtknqr4_fifoemptymsk);
+		    DWC_READ_REG32(&dev_if->dev_global_regs->
+				   dtknqr4_fifoemptymsk);
 		msk |= ((emp >> ep->num) & 0x1) << 7;
 		v = DWC_READ_REG32(&dev_if->in_ep_regs[ep->num]->diepint) & msk;
 	}
@@ -1285,7 +1291,7 @@ static inline uint32_t dwc_otg_read_dev_in_ep_intr(dwc_otg_core_if_t * core_if,
  * This function returns the Device OUT EP Interrupt register
  */
 static inline uint32_t dwc_otg_read_dev_out_ep_intr(dwc_otg_core_if_t *
-						    _core_if, dwc_ep_t * _ep)
+						    _core_if, dwc_ep_t *_ep)
 {
 	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
 	uint32_t v;
@@ -1293,20 +1299,20 @@ static inline uint32_t dwc_otg_read_dev_out_ep_intr(dwc_otg_core_if_t *
 
 	if (_core_if->multiproc_int_enable) {
 		msk.d32 =
-		    DWC_READ_REG32(&dev_if->
-				   dev_global_regs->doepeachintmsk[_ep->num]);
+		    DWC_READ_REG32(&dev_if->dev_global_regs->
+				   doepeachintmsk[_ep->num]);
 		if (_core_if->pti_enh_enable) {
 			msk.b.pktdrpsts = 1;
 		}
-		v = DWC_READ_REG32(&dev_if->
-				   out_ep_regs[_ep->num]->doepint) & msk.d32;
+		v = DWC_READ_REG32(&dev_if->out_ep_regs[_ep->num]->
+				   doepint) & msk.d32;
 	} else {
 		msk.d32 = DWC_READ_REG32(&dev_if->dev_global_regs->doepmsk);
 		if (_core_if->pti_enh_enable) {
 			msk.b.pktdrpsts = 1;
 		}
-		v = DWC_READ_REG32(&dev_if->
-				   out_ep_regs[_ep->num]->doepint) & msk.d32;
+		v = DWC_READ_REG32(&dev_if->out_ep_regs[_ep->num]->
+				   doepint) & msk.d32;
 	}
 	return v;
 }
@@ -1317,14 +1323,17 @@ static inline uint32_t dwc_otg_read_dev_out_ep_intr(dwc_otg_core_if_t *
 static inline uint32_t dwc_otg_read_host_all_channels_intr(dwc_otg_core_if_t *
 							   _core_if)
 {
-	return (DWC_READ_REG32(&_core_if->host_if->host_global_regs->haint));
+	uint32_t retval;
+	retval = DWC_READ_REG32(&_core_if->host_if->host_global_regs->haint);
+	return retval;
 }
 
 static inline uint32_t dwc_otg_read_host_channel_intr(dwc_otg_core_if_t *
-						      _core_if, dwc_hc_t * _hc)
+						      _core_if, dwc_hc_t *_hc)
 {
-	return (DWC_READ_REG32
-		(&_core_if->host_if->hc_regs[_hc->hc_num]->hcint));
+	uint32_t retval;
+	retval = DWC_READ_REG32(&_core_if->host_if->hc_regs[_hc->hc_num]->hcint);
+	return retval;
 }
 
 /**
@@ -1332,9 +1341,11 @@ static inline uint32_t dwc_otg_read_host_channel_intr(dwc_otg_core_if_t *
  *
  * @return 0 - Device Mode, 1 - Host Mode
  */
-static inline uint32_t dwc_otg_mode(dwc_otg_core_if_t * _core_if)
+static inline uint32_t dwc_otg_mode(dwc_otg_core_if_t *_core_if)
 {
-	return (DWC_READ_REG32(&_core_if->core_global_regs->gintsts) & 0x1);
+	uint32_t retval;
+	retval = DWC_READ_REG32(&_core_if->core_global_regs->gintsts) & 0x1;
+	return retval;
 }
 
 /**@}*/
@@ -1365,21 +1376,20 @@ typedef struct dwc_otg_cil_callbacks {
 	void *p;
 } dwc_otg_cil_callbacks_t;
 
-extern void dwc_otg_cil_register_pcd_callbacks(dwc_otg_core_if_t * _core_if,
-					       dwc_otg_cil_callbacks_t * _cb,
+extern void dwc_otg_cil_register_pcd_callbacks(dwc_otg_core_if_t *_core_if,
+					       dwc_otg_cil_callbacks_t *_cb,
 					       void *_p);
-extern void dwc_otg_cil_register_hcd_callbacks(dwc_otg_core_if_t * _core_if,
-					       dwc_otg_cil_callbacks_t * _cb,
+extern void dwc_otg_cil_register_hcd_callbacks(dwc_otg_core_if_t *_core_if,
+					       dwc_otg_cil_callbacks_t *_cb,
 					       void *_p);
 
-void dwc_otg_initiate_srp(void * core_if);
+void dwc_otg_initiate_srp(void *core_if);
 
-//////////////////////////////////////////////////////////////////////
 /** Start the HCD.  Helper function for using the HCD callbacks.
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_start(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_start(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->start) {
 		core_if->hcd_cb->start(core_if->hcd_cb_p);
@@ -1390,7 +1400,7 @@ static inline void cil_hcd_start(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_stop(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_stop(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->stop) {
 		core_if->hcd_cb->stop(core_if->hcd_cb_p);
@@ -1401,7 +1411,7 @@ static inline void cil_hcd_stop(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_disconnect(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_disconnect(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->disconnect) {
 		core_if->hcd_cb->disconnect(core_if->hcd_cb_p);
@@ -1413,7 +1423,7 @@ static inline void cil_hcd_disconnect(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_session_start(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_session_start(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->session_start) {
 		core_if->hcd_cb->session_start(core_if->hcd_cb_p);
@@ -1427,7 +1437,7 @@ static inline void cil_hcd_session_start(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_sleep(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_sleep(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->sleep) {
 		core_if->hcd_cb->sleep(core_if->hcd_cb_p);
@@ -1439,7 +1449,7 @@ static inline void cil_hcd_sleep(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_hcd_resume(dwc_otg_core_if_t * core_if)
+static inline void cil_hcd_resume(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->hcd_cb && core_if->hcd_cb->resume_wakeup) {
 		core_if->hcd_cb->resume_wakeup(core_if->hcd_cb_p);
@@ -1450,7 +1460,7 @@ static inline void cil_hcd_resume(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_pcd_start(dwc_otg_core_if_t * core_if)
+static inline void cil_pcd_start(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->pcd_cb && core_if->pcd_cb->start) {
 		core_if->pcd_cb->start(core_if->pcd_cb->p);
@@ -1461,7 +1471,7 @@ static inline void cil_pcd_start(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_pcd_stop(dwc_otg_core_if_t * core_if)
+static inline void cil_pcd_stop(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->pcd_cb && core_if->pcd_cb->stop) {
 		core_if->pcd_cb->stop(core_if->pcd_cb->p);
@@ -1472,7 +1482,7 @@ static inline void cil_pcd_stop(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_pcd_suspend(dwc_otg_core_if_t * core_if)
+static inline void cil_pcd_suspend(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->pcd_cb && core_if->pcd_cb->suspend) {
 		core_if->pcd_cb->suspend(core_if->pcd_cb->p);
@@ -1483,13 +1493,11 @@ static inline void cil_pcd_suspend(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static inline void cil_pcd_resume(dwc_otg_core_if_t * core_if)
+static inline void cil_pcd_resume(dwc_otg_core_if_t *core_if)
 {
 	if (core_if->pcd_cb && core_if->pcd_cb->resume_wakeup) {
 		core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->p);
 	}
 }
 
-//////////////////////////////////////////////////////////////////////
-
 #endif
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_cil_intr.c b/drivers/usb/dwc_otg_310/dwc_otg_cil_intr.c
index ef82bef5f8c8..9c54dceebdff 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_cil_intr.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_cil_intr.c
@@ -48,7 +48,7 @@
 #include "usbdev_rk.h"
 
 #ifdef DEBUG
-inline const char *op_state_str(dwc_otg_core_if_t * core_if)
+inline const char *op_state_str(dwc_otg_core_if_t *core_if)
 {
 	return (core_if->op_state == A_HOST ? "a_host" :
 		(core_if->op_state == A_SUSPEND ? "a_suspend" :
@@ -62,7 +62,7 @@ inline const char *op_state_str(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-int32_t dwc_otg_handle_mode_mismatch_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_mode_mismatch_intr(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 	DWC_WARN("Mode Mismatch Interrupt: currently in %s mode\n",
@@ -82,14 +82,14 @@ int32_t dwc_otg_handle_mode_mismatch_intr(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 	gotgint_data_t gotgint;
 	gotgctl_data_t gotgctl;
 	gintmsk_data_t gintmsk;
 	gpwrdn_data_t gpwrdn;
-	dctl_data_t dctl = {.d32=0};
+	dctl_data_t dctl = {.d32 = 0 };
 
 	gotgint.d32 = DWC_READ_REG32(&global_regs->gotgint);
 	gotgctl.d32 = DWC_READ_REG32(&global_regs->gotgctl);
@@ -102,12 +102,15 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 			    op_state_str(core_if));
 
 		/* do soft disconnect */
-		dctl.d32= DWC_READ_REG32( &core_if->dev_if->dev_global_regs->dctl );
+		dctl.d32 =
+		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 		dctl.b.sftdiscon = 1;
-		DWC_WRITE_REG32( &core_if->dev_if->dev_global_regs->dctl, dctl.d32 );
+		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				dctl.d32);
 		dwc_otg_disable_global_interrupts(core_if);
 		core_if->otg_dev->pcd->vbus_status = USB_BC_TYPE_DISCNT;
-		DWC_PRINTF("********session end ,soft disconnect************************\n");
+		DWC_PRINTF
+		    ("********session end ,soft disconnect************************\n");
 
 		gotgctl.d32 = DWC_READ_REG32(&global_regs->gotgctl);
 
@@ -119,7 +122,8 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 			 * Did not succeed!*/
 			if (gotgctl.b.devhnpen) {
 				DWC_DEBUGPL(DBG_ANY, "Session End Detected\n");
-				__DWC_ERROR("Device Not Connected/Responding!\n");
+				__DWC_ERROR
+				    ("Device Not Connected/Responding!\n");
 			}
 
 			/* If Session End Detected the B-Cable has
@@ -135,26 +139,32 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 				/** PET testing*/
 				gotgctl.d32 = 0;
 				gotgctl.b.devhnpen = 1;
-				DWC_MODIFY_REG32(&global_regs->gotgctl, gotgctl.d32, 0);
+				DWC_MODIFY_REG32(&global_regs->gotgctl,
+						 gotgctl.d32, 0);
 				if (core_if->test_mode == 6) {
-					DWC_WORKQ_SCHEDULE_DELAYED(core_if->wq_otg,	dwc_otg_initiate_srp, 
-								core_if, 3000, "initate SRP"); //manukz: old value was 50
+					/* manukz: old value was 50 */
+					DWC_WORKQ_SCHEDULE_DELAYED(core_if->wq_otg,
+								   dwc_otg_initiate_srp,
+								   core_if, 3000,
+								   "initate SRP");
 					core_if->test_mode = 0;
-				} else	if (core_if->adp_enable) {
+				} else if (core_if->adp_enable) {
 					if (core_if->power_down == 2) {
 						gpwrdn.d32 = 0;
 						gpwrdn.b.pwrdnswtch = 1;
-						DWC_MODIFY_REG32(&core_if->
-								 core_global_regs->
-								 gpwrdn, gpwrdn.d32, 0);
+						DWC_MODIFY_REG32
+						    (&core_if->core_global_regs->gpwrdn,
+						     gpwrdn.d32, 0);
 					}
 
 					gpwrdn.d32 = 0;
 					gpwrdn.b.pmuintsel = 1;
 					gpwrdn.b.pmuactv = 1;
-					DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+					DWC_MODIFY_REG32(&core_if->
+							 core_global_regs->
+							 gpwrdn, 0, gpwrdn.d32);
 					dwc_otg_adp_sense_start(core_if);
-				} 
+				}
 			}
 		}
 		if (core_if->otg_ver == 0) {
@@ -170,7 +180,8 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 		if (gotgctl.b.sesreqscs) {
 
 			if ((core_if->core_params->phy_type ==
-			     DWC_PHY_TYPE_PARAM_FS) && (core_if->core_params->i2c_enable)) {
+			     DWC_PHY_TYPE_PARAM_FS)
+			    && (core_if->core_params->i2c_enable)) {
 				core_if->srp_success = 1;
 			} else {
 				DWC_SPINUNLOCK(core_if->lock);
@@ -207,7 +218,7 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 				 */
 				gintmsk.d32 = 0;
 				gintmsk.b.sofintr = 1;
-				//gintmsk.b.usbsuspend = 1; // vahrama !!!!!!
+				/* gintmsk.b.usbsuspend = 1; */
 				DWC_MODIFY_REG32(&global_regs->gintmsk,
 						 gintmsk.d32, 0);
 				/* Call callback function with spin lock released */
@@ -272,8 +283,8 @@ int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t * core_if)
 	}
 	if (gotgint.b.debdone) {
 		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: " "Debounce Done++\n");
-		/* Need to power off VBUS after 10s if OTG2 non-hnp capable host*/
-		if(core_if->otg_ver == 1)
+		/* Need to power off VBUS after 10s if OTG2 non-hnp capable host */
+		if (core_if->otg_ver == 1)
 			cil_hcd_session_start(core_if);
 	}
 
@@ -300,12 +311,14 @@ void w_conn_id_status_change(void *p)
 
 		/* Wait for switch to device mode. */
 		while (!dwc_otg_is_device_mode(core_if)) {
-			gotgctl_local.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
-			DWC_DEBUGPL(DBG_ANY, "Waiting for Peripheral Mode, Mode=%s count = %d gotgctl=%08x\n",
-				   (dwc_otg_is_host_mode(core_if) ? "Host" :
-				    "Peripheral"), count, gotgctl_local.d32);
-			dwc_mdelay(1); //vahrama previous value was 100
-			if(!gotgctl_local.b.conidsts)
+			gotgctl_local.d32 =
+			    DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+			DWC_DEBUGPL(DBG_ANY,
+				    "Waiting for Peripheral Mode, Mode=%s count = %d gotgctl=%08x\n",
+				    (dwc_otg_is_host_mode(core_if) ? "Host" :
+				     "Peripheral"), count, gotgctl_local.d32);
+			dwc_mdelay(1);	/* vahrama previous value was 100 */
+			if (!gotgctl_local.b.conidsts)
 				goto host;
 			if (++count > 10000)
 				break;
@@ -314,10 +327,10 @@ void w_conn_id_status_change(void *p)
 			   "Connection id status change timed out");
 		core_if->op_state = B_PERIPHERAL;
 		cil_hcd_stop(core_if);;
-		//pcd->phy_suspend = 1;
+		/* pcd->phy_suspend = 1; */
 		pcd->vbus_status = 0;
 		dwc_otg_pcd_start_check_vbus_work(pcd);
-		if(core_if->otg_ver == 0)
+		if (core_if->otg_ver == 0)
 			dwc_otg_core_init(core_if);
 		dwc_otg_enable_global_interrupts(core_if);
 		cil_pcd_start(core_if);
@@ -325,10 +338,10 @@ void w_conn_id_status_change(void *p)
 host:
 		/* A-Device connector (Host Mode) */
 		while (!dwc_otg_is_host_mode(core_if)) {
-		DWC_DEBUGPL(DBG_ANY,"Waiting for Host Mode, Mode=%s\n",
-				   (dwc_otg_is_host_mode(core_if) ? "Host" :
-				    "Peripheral"));
-			dwc_mdelay(1);	//vahrama previously was 100
+			DWC_DEBUGPL(DBG_ANY, "Waiting for Host Mode, Mode=%s\n",
+				    (dwc_otg_is_host_mode(core_if) ? "Host" :
+				     "Peripheral"));
+			dwc_mdelay(1);	/* vahrama previously was 100 */
 			if (++count > 10000)
 				break;
 		}
@@ -356,14 +369,14 @@ void w_conn_id_status_change(void *p)
  * This function handles the Connector ID Status Change Interrupt.  It
  * reads the OTG Interrupt Register (GOTCTL) to determine whether this
  * is a Device to Host Mode transition or a Host Mode to Device
- * Transition. 
+ * Transition.
  *
  * This only occurs when the cable is connected/removed from the PHY
  * connector.
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-int32_t dwc_otg_handle_conn_id_status_change_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_conn_id_status_change_intr(dwc_otg_core_if_t *core_if)
 {
 
 	/*
@@ -375,8 +388,8 @@ int32_t dwc_otg_handle_conn_id_status_change_intr(dwc_otg_core_if_t * core_if)
 	 */
 	gintmsk_data_t gintmsk = {.d32 = 0 };
 	gintsts_data_t gintsts = {.d32 = 0 };
-	
-	if(core_if->usb_mode != USB_MODE_NORMAL)
+
+	if (core_if->usb_mode != USB_MODE_NORMAL)
 		goto out;
 
 	gintmsk.b.sofintr = 1;
@@ -412,7 +425,7 @@ int32_t dwc_otg_handle_conn_id_status_change_intr(dwc_otg_core_if_t * core_if)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-int32_t dwc_otg_handle_session_req_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_session_req_intr(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 
@@ -422,15 +435,16 @@ int32_t dwc_otg_handle_session_req_intr(dwc_otg_core_if_t * core_if)
 		gotgctl_data_t gotgctl = {.d32 = 0 };
 		DWC_PRINTF("SRP: Device mode\n");
 		gotgctl.d32 =
-			DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+		    DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 		if (gotgctl.b.sesreqscs)
 			DWC_PRINTF("SRP Success\n");
 		else
 			DWC_PRINTF("SRP Fail\n");
 		if (core_if->otg_ver) {
-			gotgctl.d32 = 0 ;	
+			gotgctl.d32 = 0;
 			gotgctl.b.devhnpen = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gotgctl, gotgctl.d32, 0);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gotgctl,
+					 gotgctl.d32, 0);
 		}
 	} else {
 		hprt0_data_t hprt0;
@@ -457,7 +471,7 @@ int32_t dwc_otg_handle_session_req_intr(dwc_otg_core_if_t * core_if)
 
 void w_wakeup_detected(void *data)
 {
-	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *)data;
+	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *) data;
 	/*
 	 * Clear the Resume after 70ms. (Need 20 ms minimum. Use 70 ms
 	 * so that OPT tests pass with all PHYs).
@@ -469,10 +483,10 @@ void w_wakeup_detected(void *data)
 	pcgcctl.b.stoppclk = 1;
 	DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
 	dwc_udelay(10);
-#endif //0
+#endif
 	hprt0.d32 = dwc_otg_read_hprt0(core_if);
 	DWC_DEBUGPL(DBG_ANY, "Resume: HPRT0=%0x\n", hprt0.d32);
-        dwc_mdelay(70);
+	dwc_mdelay(70);
 	hprt0.b.prtres = 0;	/* Resume */
 	DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 	DWC_DEBUGPL(DBG_ANY, "Clear Resume: HPRT0=%0x\n",
@@ -491,7 +505,7 @@ void w_wakeup_detected(void *data)
  * power mode. The controller automatically begins resume
  * signaling. The handler schedules a time to stop resume signaling.
  */
-int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 
@@ -503,8 +517,8 @@ int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
 	if (dwc_otg_is_device_mode(core_if)) {
 		dctl_data_t dctl = {.d32 = 0 };
 		DWC_DEBUGPL(DBG_PCD, "DSTS=0x%0x\n",
-			    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
-					   dsts));
+			    DWC_READ_REG32(&core_if->dev_if->
+					   dev_global_regs->dsts));
 		if (core_if->lx_state == DWC_OTG_L2) {
 #ifdef PARTIAL_POWER_DOWN
 			if (core_if->hwcfg4.b.power_optimiz) {
@@ -526,12 +540,13 @@ int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
 #endif
 			/* Clear the Remote Wakeup Signaling */
 			dctl.b.rmtwkupsig = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
-					 dctl, dctl.d32, 0);
+			DWC_MODIFY_REG32(&core_if->dev_if->
+					 dev_global_regs->dctl, dctl.d32, 0);
 
 			DWC_SPINUNLOCK(core_if->lock);
 			if (core_if->pcd_cb && core_if->pcd_cb->resume_wakeup) {
-				core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->p);
+				core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->
+							       p);
 			}
 			DWC_SPINLOCK(core_if->lock);
 		} else {
@@ -540,12 +555,12 @@ int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
 
 			lpmcfg.d32 =
 			    DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
-			lpmcfg.b.hird_thres &= (~(1 << 4));	
-	       	lpmcfg.b.en_utmi_sleep = 0; 
+			lpmcfg.b.hird_thres &= (~(1 << 4));
+			lpmcfg.b.en_utmi_sleep = 0;
 
 			/* Clear Enbl_L1Gating bit. */
 			pcgcctl.b.enbl_sleep_gating = 1;
-			DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32,0);
+			DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
 
 			DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg,
 					lpmcfg.d32);
@@ -559,7 +574,7 @@ int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
 			/* Restart the Phy Clock */
 			pcgcctl.b.stoppclk = 1;
 			DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
-                        DWC_TASK_SCHEDULE(core_if->wkp_tasklet);
+			DWC_TASK_SCHEDULE(core_if->wkp_tasklet);
 		} else {
 			/** Change to L0 state*/
 			core_if->lx_state = DWC_OTG_L0;
@@ -578,7 +593,7 @@ int32_t dwc_otg_handle_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
  * This interrupt indicates that the Wakeup Logic has detected a
  * Device disconnect.
  */
-static int32_t dwc_otg_handle_pwrdn_disconnect_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_pwrdn_disconnect_intr(dwc_otg_core_if_t *core_if)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	gpwrdn_data_t gpwrdn_temp = {.d32 = 0 };
@@ -645,7 +660,8 @@ static int32_t dwc_otg_handle_pwrdn_disconnect_intr(dwc_otg_core_if_t * core_if)
  * This interrupt indicates that the Wakeup Logic has detected a
  * remote wakeup sequence.
  */
-static int32_t dwc_otg_handle_pwrdn_wakeup_detected_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_pwrdn_wakeup_detected_intr(dwc_otg_core_if_t *
+							 core_if)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	DWC_DEBUGPL(DBG_ANY,
@@ -657,7 +673,7 @@ static int32_t dwc_otg_handle_pwrdn_wakeup_detected_intr(dwc_otg_core_if_t * cor
 	}
 
 	gpwrdn.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
-	if (gpwrdn.b.idsts) {	// Device Mode
+	if (gpwrdn.b.idsts) {	/* Device Mode */
 		if ((core_if->power_down == 2)
 		    && (core_if->hibernation_suspend == 1)) {
 			dwc_otg_device_hibernation_restore(core_if, 0, 0);
@@ -671,7 +687,7 @@ static int32_t dwc_otg_handle_pwrdn_wakeup_detected_intr(dwc_otg_core_if_t * cor
 	return 1;
 }
 
-static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t * otg_dev)
+static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t *otg_dev)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	gpwrdn_data_t gpwrdn_temp = {.d32 = 0 };
@@ -684,33 +700,39 @@ static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t * otg_dev)
 			DWC_PRINTF("Already exited from Hibernation\n");
 			return 1;
 		}
-		DWC_DEBUGPL(DBG_ANY, "Exit from hibernation on ID sts change\n");
+		DWC_DEBUGPL(DBG_ANY,
+			    "Exit from hibernation on ID sts change\n");
 		/* Switch on the voltage to the core */
 		gpwrdn.b.pwrdnswtch = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		/* Reset the core */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnrstn = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		/* Disable power clamps */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnclmp = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 
 		/* Remove reset the core signal */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnrstn = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+				 gpwrdn.d32);
 		dwc_udelay(10);
 
 		/* Disable PMU interrupt */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuintsel = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 
 		/*Indicates that we are exiting from hibernation */
 		core_if->hibernation_suspend = 0;
@@ -718,14 +740,16 @@ static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t * otg_dev)
 		/* Disable PMU */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuactv = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		gpwrdn.d32 = core_if->gr_backup->gpwrdn_local;
 		if (gpwrdn.b.dis_vbus == 1) {
 			gpwrdn.d32 = 0;
 			gpwrdn.b.dis_vbus = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn,
+					 gpwrdn.d32, 0);
 		}
 
 		if (gpwrdn_temp.b.idsts) {
@@ -775,7 +799,8 @@ static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t * otg_dev)
 		gpwrdn_temp.d32 = 0;
 		gpwrdn_temp.b.pmuactv = 1;
 		gpwrdn_temp.b.pmuintsel = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		DWC_PRINTF("Check point 1\n");
 		dwc_mdelay(110);
 		dwc_otg_adp_start(core_if, is_host);
@@ -785,7 +810,7 @@ static int32_t dwc_otg_handle_pwrdn_idsts_change(dwc_otg_device_t * otg_dev)
 	return 1;
 }
 
-static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t *core_if)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	int32_t otg_cap_param = core_if->core_params->otg_cap;
@@ -811,30 +836,35 @@ static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
 		/* Switch on the voltage to the core */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnswtch = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		/* Reset the core */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnrstn = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		/* Disable power clamps */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnclmp = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 
 		/* Remove reset the core signal */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pwrdnrstn = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0, gpwrdn.d32);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, 0,
+				 gpwrdn.d32);
 		dwc_udelay(10);
 
 		/* Disable PMU interrupt */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuintsel = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		/*Indicates that we are exiting from hibernation */
@@ -843,7 +873,8 @@ static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
 		/* Disable PMU */
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuactv = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 		dwc_udelay(10);
 
 		core_if->op_state = B_PERIPHERAL;
@@ -858,7 +889,7 @@ static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
 			 */
 			dwc_otg_initiate_srp(core_if);
 		}
-	} else if (core_if->adp_enable){
+	} else if (core_if->adp_enable) {
 		dwc_otg_adp_probe_stop(core_if);
 		if (DWC_WORKQ_PENDING(core_if->wq_otg))
 			core_if->stop_adpprb = 1;
@@ -866,8 +897,8 @@ static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
 		gpwrdn.d32 = 0;
 		gpwrdn.b.pmuintsel = 1;
 		gpwrdn.b.pmuactv = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->
-				 gpwrdn, gpwrdn.d32, 0);
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32,
+				 0);
 
 		/*
 		 * Initialize the Core for Device mode.
@@ -884,7 +915,7 @@ static int32_t dwc_otg_handle_pwrdn_session_change(dwc_otg_core_if_t * core_if)
  * This interrupt indicates that the Wakeup Logic has detected a
  * status change either on IDDIG or BSessVld.
  */
-static uint32_t dwc_otg_handle_pwrdn_stschng_intr(dwc_otg_device_t * otg_dev)
+static uint32_t dwc_otg_handle_pwrdn_stschng_intr(dwc_otg_device_t *otg_dev)
 {
 	int retval;
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
@@ -919,7 +950,7 @@ static uint32_t dwc_otg_handle_pwrdn_stschng_intr(dwc_otg_device_t * otg_dev)
  * This interrupt indicates that the Wakeup Logic has detected a
  * SRP.
  */
-static int32_t dwc_otg_handle_pwrdn_srp_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_pwrdn_srp_intr(dwc_otg_core_if_t *core_if)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 
@@ -988,12 +1019,12 @@ static int32_t dwc_otg_handle_pwrdn_srp_intr(dwc_otg_core_if_t * core_if)
 
 /** This interrupt indicates that restore command after Hibernation
  * was completed by the core. */
-int32_t dwc_otg_handle_restore_done_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_restore_done_intr(dwc_otg_core_if_t *core_if)
 {
 	pcgcctl_data_t pcgcctl;
 	DWC_DEBUGPL(DBG_ANY, "++Restore Done Interrupt++\n");
 
-	//TODO De-assert restore signal. 8.a
+	/* TODO De-assert restore signal. 8.a */
 	pcgcctl.d32 = DWC_READ_REG32(core_if->pcgcctl);
 	if (pcgcctl.b.restoremode == 1) {
 		gintmsk_data_t gintmsk = {.d32 = 0 };
@@ -1013,7 +1044,7 @@ int32_t dwc_otg_handle_restore_done_intr(dwc_otg_core_if_t * core_if)
  * This interrupt indicates that a device has been disconnected from
  * the root port.
  */
-int32_t dwc_otg_handle_disconnect_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_disconnect_intr(dwc_otg_core_if_t *core_if)
 {
 	gintsts_data_t gintsts;
 
@@ -1054,15 +1085,16 @@ int32_t dwc_otg_handle_disconnect_intr(dwc_otg_core_if_t * core_if)
 	} else {
 		if (core_if->op_state == A_HOST) {
 			/* A-Cable still connected but device disconnected. */
-			cil_hcd_disconnect(core_if);	
+			cil_hcd_disconnect(core_if);
 			if (core_if->adp_enable) {
 				gpwrdn_data_t gpwrdn = {.d32 = 0 };
 				cil_hcd_stop(core_if);
 				/* Enable Power Down Logic */
 				gpwrdn.b.pmuintsel = 1;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_otg_adp_probe_start(core_if);
 
 				/* Power off the core */
@@ -1096,7 +1128,7 @@ int32_t dwc_otg_handle_disconnect_intr(dwc_otg_core_if_t * core_if)
  * When power management is enabled the core will be put in low power
  * mode.
  */
-int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
+int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t *core_if)
 {
 	dsts_data_t dsts;
 	gintsts_data_t gintsts;
@@ -1104,8 +1136,8 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 
 	DWC_DEBUGPL(DBG_ANY, "USB SUSPEND\n");
 
-	if ((core_if->otg_ver == 1) && (core_if->op_state == A_PERIPHERAL)) 
-		dwc_mdelay(200); //vahrama - WA - see BU's mail
+	if ((core_if->otg_ver == 1) && (core_if->op_state == A_PERIPHERAL))
+		dwc_mdelay(200);	/* vahrama - WA - see BU's mail */
 
 	if (dwc_otg_is_device_mode(core_if)) {
 		/* Check the Device status register to determine if the Suspend
@@ -1139,11 +1171,14 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 #endif
 		/* PCD callback for suspend. Release the lock inside of callback function */
 		cil_pcd_suspend(core_if);
-		if (core_if->power_down == 2)
-		{
-			dcfg.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dcfg);
-			DWC_DEBUGPL(DBG_ANY,"lx_state = %08x\n",core_if->lx_state);
-			DWC_DEBUGPL(DBG_ANY," device address = %08d\n",dcfg.b.devaddr);
+		if (core_if->power_down == 2) {
+			dcfg.d32 =
+			    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
+					   dcfg);
+			DWC_DEBUGPL(DBG_ANY, "lx_state = %08x\n",
+				    core_if->lx_state);
+			DWC_DEBUGPL(DBG_ANY, " device address = %08d\n",
+				    dcfg.b.devaddr);
 
 			if (core_if->lx_state != DWC_OTG_L3 && dcfg.b.devaddr) {
 				pcgcctl_data_t pcgcctl = {.d32 = 0 };
@@ -1156,15 +1191,16 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 				/* Clear interrupt in gintsts */
 				gintsts.d32 = 0;
 				gintsts.b.usbsuspend = 1;
-				DWC_WRITE_REG32(&core_if->core_global_regs->
-						gintsts, gintsts.d32);
+				DWC_WRITE_REG32(&core_if->
+						core_global_regs->gintsts,
+						gintsts.d32);
 				DWC_PRINTF("Start of hibernation completed\n");
 				dwc_otg_save_global_regs(core_if);
 				dwc_otg_save_dev_regs(core_if);
 
 				gusbcfg.d32 =
-				    DWC_READ_REG32(&core_if->core_global_regs->
-						   gusbcfg);
+				    DWC_READ_REG32(&core_if->
+						   core_global_regs->gusbcfg);
 				if (gusbcfg.b.ulpi_utmi_sel == 1) {
 					/* ULPI interface */
 					/* Suspend the Phy Clock */
@@ -1174,15 +1210,15 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 							 pcgcctl.d32);
 					dwc_udelay(10);
 					gpwrdn.b.pmuactv = 1;
-					DWC_MODIFY_REG32(&core_if->
-							 core_global_regs->
-							 gpwrdn, 0, gpwrdn.d32);
+					DWC_MODIFY_REG32
+					    (&core_if->core_global_regs->gpwrdn,
+					     0, gpwrdn.d32);
 				} else {
 					/* UTMI+ Interface */
 					gpwrdn.b.pmuactv = 1;
-					DWC_MODIFY_REG32(&core_if->
-							 core_global_regs->
-							 gpwrdn, 0, gpwrdn.d32);
+					DWC_MODIFY_REG32
+					    (&core_if->core_global_regs->gpwrdn,
+					     0, gpwrdn.d32);
 					dwc_udelay(10);
 					pcgcctl.b.stoppclk = 1;
 					DWC_MODIFY_REG32(core_if->pcgcctl, 0,
@@ -1195,8 +1231,9 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 				/* Enable interrupts from wake up logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuintsel = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				/* Unmask device mode interrupts in GPWRDN */
@@ -1204,86 +1241,109 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 				gpwrdn.b.rst_det_msk = 1;
 				gpwrdn.b.lnstchng_msk = 1;
 				gpwrdn.b.sts_chngint_msk = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				/* Enable Power Down Clamp */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pwrdnclmp = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				/* Switch off VDD */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 
 				/* Save gpwrdn register for further usage if stschng interrupt */
 				core_if->gr_backup->gpwrdn_local =
-							DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gpwrdn);
 				DWC_PRINTF("Hibernation completed\n");
 
 				return 1;
 			}
 		} else if (core_if->power_down == 3) {
 			pcgcctl_data_t pcgcctl = {.d32 = 0 };
-			dcfg.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dcfg);
-			DWC_DEBUGPL(DBG_ANY, "lx_state = %08x\n",core_if->lx_state);
-			DWC_DEBUGPL(DBG_ANY, " device address = %08d\n",dcfg.b.devaddr);
+			dcfg.d32 =
+			    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->
+					   dcfg);
+			DWC_DEBUGPL(DBG_ANY, "lx_state = %08x\n",
+				    core_if->lx_state);
+			DWC_DEBUGPL(DBG_ANY, " device address = %08d\n",
+				    dcfg.b.devaddr);
 
 			if (core_if->lx_state != DWC_OTG_L3 && dcfg.b.devaddr) {
-				DWC_DEBUGPL(DBG_ANY, "Start entering to extended hibernation\n");
+				DWC_DEBUGPL(DBG_ANY,
+					    "Start entering to extended hibernation\n");
 				core_if->xhib = 1;
-							
+
 				/* Clear interrupt in gintsts */
 				gintsts.d32 = 0;
 				gintsts.b.usbsuspend = 1;
-				DWC_WRITE_REG32(&core_if->core_global_regs->
-					gintsts, gintsts.d32);
+				DWC_WRITE_REG32(&core_if->
+						core_global_regs->gintsts,
+						gintsts.d32);
 
 				dwc_otg_save_global_regs(core_if);
 				dwc_otg_save_dev_regs(core_if);
-				
+
 				/* Wait for 10 PHY clocks */
 				dwc_udelay(10);
 
 				/* Program GPIO register while entering to xHib */
-				DWC_WRITE_REG32(&core_if->core_global_regs->ggpio, 0x1);
+				DWC_WRITE_REG32(&core_if->core_global_regs->
+						ggpio, 0x1);
 
 				pcgcctl.b.enbl_extnd_hiber = 1;
-				DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
-				DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
-				
+				DWC_MODIFY_REG32(core_if->pcgcctl, 0,
+						 pcgcctl.d32);
+				DWC_MODIFY_REG32(core_if->pcgcctl, 0,
+						 pcgcctl.d32);
+
 				pcgcctl.d32 = 0;
 				pcgcctl.b.extnd_hiber_pwrclmp = 1;
-				DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
+				DWC_MODIFY_REG32(core_if->pcgcctl, 0,
+						 pcgcctl.d32);
 
 				pcgcctl.d32 = 0;
 				pcgcctl.b.extnd_hiber_switch = 1;
-				core_if->gr_backup->xhib_gpwrdn = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
-				core_if->gr_backup->xhib_pcgcctl = DWC_READ_REG32(core_if->pcgcctl) | pcgcctl.d32;
-				DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
+				core_if->gr_backup->xhib_gpwrdn =
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gpwrdn);
+				core_if->gr_backup->xhib_pcgcctl =
+				    DWC_READ_REG32(core_if->pcgcctl) | pcgcctl.
+				    d32;
+				DWC_MODIFY_REG32(core_if->pcgcctl, 0,
+						 pcgcctl.d32);
+
+				DWC_DEBUGPL(DBG_ANY,
+					    "Finished entering to extended hibernation\n");
 
-				DWC_DEBUGPL(DBG_ANY, "Finished entering to extended hibernation\n");
-				
 				return 1;
 			}
 		}
-		if ((core_if->otg_ver == 1) && (core_if->core_params->otg_cap == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)) {
+		if ((core_if->otg_ver == 1)
+		    && (core_if->core_params->otg_cap ==
+			DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)) {
 			gotgctl_data_t gotgctl = {.d32 = 0 };
-			gotgctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
-			if (gotgctl.b.devhnpen && core_if->otg_ver == 1){
+			gotgctl.d32 =
+			    DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
+			if (gotgctl.b.devhnpen && core_if->otg_ver == 1) {
 				gotgctl_data_t gotgctl = {.d32 = 0 };
 				dwc_mdelay(5);
 				/**@todo Is the gotgctl.devhnpen cleared
 				 * by a USB Reset? */
 				gotgctl.b.devhnpen = 1;
 				gotgctl.b.hnpreq = 1;
-				DWC_WRITE_REG32(&core_if->core_global_regs->gotgctl,
-						gotgctl.d32);
+				DWC_WRITE_REG32(&core_if->core_global_regs->
+						gotgctl, gotgctl.d32);
 			}
 		}
 	} else {
@@ -1309,7 +1369,7 @@ int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t * core_if)
 	return 1;
 }
 
-static int32_t dwc_otg_handle_xhib_exit_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_xhib_exit_intr(dwc_otg_core_if_t *core_if)
 {
 	gpwrdn_data_t gpwrdn = {.d32 = 0 };
 	pcgcctl_data_t pcgcctl = {.d32 = 0 };
@@ -1377,7 +1437,7 @@ static int32_t dwc_otg_handle_xhib_exit_intr(dwc_otg_core_if_t * core_if)
 /**
  * This function hadles LPM transaction received interrupt.
  */
-static int32_t dwc_otg_handle_lpm_intr(dwc_otg_core_if_t * core_if)
+static int32_t dwc_otg_handle_lpm_intr(dwc_otg_core_if_t *core_if)
 {
 	glpmcfg_data_t lpmcfg;
 	gintsts_data_t gintsts;
@@ -1399,14 +1459,14 @@ static int32_t dwc_otg_handle_lpm_intr(dwc_otg_core_if_t * core_if)
 		lpmcfg.b.en_utmi_sleep = 1;
 
 		pcgcctl.b.enbl_sleep_gating = 1;
-	   	DWC_MODIFY_REG32(core_if->pcgcctl,0,pcgcctl.d32);
+		DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
 
-		if(dwc_otg_get_param_besl_enable(core_if)) {
-			lpmcfg.b.en_besl = 1;				
+		if (dwc_otg_get_param_besl_enable(core_if)) {
+			lpmcfg.b.en_besl = 1;
 		}
 
 		DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg,
-				lpmcfg.d32);		
+				lpmcfg.d32);
 	}
 
 	/* Examine prt_sleep_sts after TL1TokenTetry period max (10 us) */
@@ -1428,8 +1488,10 @@ static int32_t dwc_otg_handle_lpm_intr(dwc_otg_core_if_t * core_if)
 /**
  * This function returns the Core Interrupt register.
  */
-static inline uint32_t dwc_otg_read_common_intr(dwc_otg_core_if_t * core_if)
+static inline uint32_t dwc_otg_read_common_intr(dwc_otg_core_if_t *core_if)
 {
+	uint32_t retval;
+
 	gahbcfg_data_t gahbcfg = {.d32 = 0 };
 	gintsts_data_t gintsts;
 	gintmsk_data_t gintmsk;
@@ -1446,8 +1508,8 @@ static inline uint32_t dwc_otg_read_common_intr(dwc_otg_core_if_t * core_if)
 #endif
 	gintmsk_common.b.restoredone = 1;
 	/** @todo: The port interrupt occurs while in device
-         * mode. Added code to CIL to clear the interrupt for now!
-         */
+	 * mode. Added code to CIL to clear the interrupt for now!
+	 */
 	gintmsk_common.b.portintr = 1;
 
 	gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
@@ -1461,17 +1523,18 @@ static inline uint32_t dwc_otg_read_common_intr(dwc_otg_core_if_t * core_if)
 			    gintsts.d32, gintmsk.d32);
 	}
 #endif
-	if (gahbcfg.b.glblintrmsk)
-		return ((gintsts.d32 & gintmsk.d32) & gintmsk_common.d32);
-	else
+	if (gahbcfg.b.glblintrmsk) {
+		retval = (gintsts.d32 & gintmsk.d32) & gintmsk_common.d32;
+		return retval;
+	} else {
 		return 0;
-
+	}
 }
 
 /* MACRO for clearing interupt bits in GPWRDN register */
-#define CLEAR_GPWRDN_INTR(__core_if,__intr) \
+#define CLEAR_GPWRDN_INTR(__core_if, __intr) \
 do { \
-		gpwrdn_data_t gpwrdn = {.d32=0}; \
+		gpwrdn_data_t gpwrdn = {.d32 = 0}; \
 		gpwrdn.b.__intr = 1; \
 		DWC_MODIFY_REG32(&__core_if->core_global_regs->gpwrdn, \
 		0, gpwrdn.d32); \
@@ -1500,15 +1563,15 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 	dwc_otg_device_t *otg_dev = dev;
 	dwc_otg_core_if_t *core_if = otg_dev->core_if;
 	gpwrdn.d32 = DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
-	
-	if (dwc_otg_check_haps_status(core_if) == -1 ) {
-		DWC_WARN("HAPS is disconnected");			
+
+	if (dwc_otg_check_haps_status(core_if) == -1) {
+		DWC_WARN("HAPS is disconnected");
 		return retval;
 	}
-	
+
 	if (dwc_otg_is_device_mode(core_if))
 		core_if->frame_num = dwc_otg_get_frame_number(core_if);
-		
+
 	if (core_if->lock)
 		DWC_SPINLOCK(core_if->lock);
 
@@ -1561,26 +1624,38 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 				pcgcctl_data_t pcgcctl = {.d32 = 0 };
 				dctl_data_t dctl = {.d32 = 0 };
 
-				DWC_WRITE_REG32(&core_if->core_global_regs->
-						gintsts, 0xFFFFFFFF);
+				DWC_WRITE_REG32(&core_if->
+						core_global_regs->gintsts,
+						0xFFFFFFFF);
 
 				DWC_DEBUGPL(DBG_ANY,
 					    "RESTORE DONE generated\n");
 
 				gpwrdn.b.restore = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->gpwrdn, gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
 				dwc_udelay(10);
 
 				pcgcctl.b.rstpdwnmodule = 1;
-				DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
+				DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32,
+						 0);
 
-				DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, core_if->gr_backup->gusbcfg_local);
-				DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dcfg, core_if->dr_backup->dcfg);
-				DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, core_if->dr_backup->dctl);
+				DWC_WRITE_REG32(&core_if->core_global_regs->
+						gusbcfg,
+						core_if->gr_backup->
+						gusbcfg_local);
+				DWC_WRITE_REG32(&core_if->dev_if->
+						dev_global_regs->dcfg,
+						core_if->dr_backup->dcfg);
+				DWC_WRITE_REG32(&core_if->dev_if->
+						dev_global_regs->dctl,
+						core_if->dr_backup->dctl);
 				dwc_udelay(50);
-				
+
 				dctl.b.pwronprgdone = 1;
-				DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
+				DWC_MODIFY_REG32(&core_if->dev_if->
+						 dev_global_regs->dctl, 0,
+						 dctl.d32);
 				dwc_udelay(10);
 
 				dwc_otg_restore_global_regs(core_if);
@@ -1588,27 +1663,34 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 
 				dctl.d32 = 0;
 				dctl.b.pwronprgdone = 1;
-				DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32, 0);
+				DWC_MODIFY_REG32(&core_if->dev_if->
+						 dev_global_regs->dctl,
+						 dctl.d32, 0);
 				dwc_udelay(10);
 
 				pcgcctl.d32 = 0;
 				pcgcctl.b.enbl_extnd_hiber = 1;
-				DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
+				DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32,
+						 0);
 
 				/* The core will be in ON STATE */
 				core_if->lx_state = DWC_OTG_L0;
 				core_if->xhib = 0;
 
 				DWC_SPINUNLOCK(core_if->lock);
-				if (core_if->pcd_cb && core_if->pcd_cb->resume_wakeup) {
-					core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->p);
+				if (core_if->pcd_cb
+				    && core_if->pcd_cb->resume_wakeup) {
+					core_if->pcd_cb->resume_wakeup(core_if->
+								       pcd_cb->
+								       p);
 				}
 				DWC_SPINLOCK(core_if->lock);
 
 			}
 
 			gintsts.b.restoredone = 1;
-			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,gintsts.d32);
+			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,
+					gintsts.d32);
 			DWC_PRINTF(" --Restore done interrupt received-- \n");
 			retval |= 1;
 		}
@@ -1618,7 +1700,8 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 			 */
 			gintsts.d32 = 0;
 			gintsts.b.portintr = 1;
-			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,gintsts.d32);
+			DWC_WRITE_REG32(&core_if->core_global_regs->gintsts,
+					gintsts.d32);
 			retval |= 1;
 
 		}
@@ -1630,7 +1713,8 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 			if (gpwrdn.b.linestate == 0) {
 				dwc_otg_handle_pwrdn_disconnect_intr(core_if);
 			} else {
-				DWC_PRINTF("Disconnect detected while linestate is not 0\n");
+				DWC_PRINTF
+				    ("Disconnect detected while linestate is not 0\n");
 			}
 
 			retval |= 1;
@@ -1639,9 +1723,11 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 			CLEAR_GPWRDN_INTR(core_if, lnstschng);
 			/* remote wakeup from hibernation */
 			if (gpwrdn.b.linestate == 2 || gpwrdn.b.linestate == 1) {
-				dwc_otg_handle_pwrdn_wakeup_detected_intr(core_if);
+				dwc_otg_handle_pwrdn_wakeup_detected_intr
+				    (core_if);
 			} else {
-				DWC_PRINTF("gpwrdn.linestate = %d\n", gpwrdn.b.linestate);
+				DWC_PRINTF("gpwrdn.linestate = %d\n",
+					   gpwrdn.b.linestate);
 			}
 			retval |= 1;
 		}
@@ -1649,7 +1735,9 @@ int32_t dwc_otg_handle_common_intr(void *dev)
 			CLEAR_GPWRDN_INTR(core_if, rst_det);
 			if (gpwrdn.b.linestate == 0) {
 				DWC_PRINTF("Reset detected\n");
-				retval |= dwc_otg_device_hibernation_restore(core_if, 0, 1);
+				retval |=
+				    dwc_otg_device_hibernation_restore(core_if,
+								       0, 1);
 			}
 		}
 		if (gpwrdn.b.srp_det && gpwrdn.b.srp_det_msk) {
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_core_if.h b/drivers/usb/dwc_otg_310/dwc_otg_core_if.h
index 6b69bd968919..1acb210327b1 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_core_if.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_core_if.h
@@ -50,18 +50,18 @@ typedef struct dwc_otg_core_if dwc_otg_core_if_t;
 /** Maximum number of Endpoints/HostChannels */
 #define MAX_EPS_CHANNELS 16
 
-extern dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t * _reg_base_addr);
-extern void dwc_otg_core_init(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_core_init_no_reset(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_cil_remove(dwc_otg_core_if_t * _core_if);
+extern dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t *_reg_base_addr);
+extern void dwc_otg_core_init(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_init_no_reset(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_cil_remove(dwc_otg_core_if_t *_core_if);
 
-extern void dwc_otg_enable_global_interrupts(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_disable_global_interrupts(dwc_otg_core_if_t * _core_if);
+extern void dwc_otg_enable_global_interrupts(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_disable_global_interrupts(dwc_otg_core_if_t *_core_if);
 
-extern uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t * _core_if);
-extern uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t * _core_if);
+extern uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t *_core_if);
+extern uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t *_core_if);
 
-extern uint8_t dwc_otg_is_dma_enable(dwc_otg_core_if_t * core_if);
+extern uint8_t dwc_otg_is_dma_enable(dwc_otg_core_if_t *core_if);
 
 /** This function should be called on every hardware interrupt. */
 extern int32_t dwc_otg_handle_common_intr(void *otg_dev);
@@ -76,15 +76,15 @@ extern int32_t dwc_otg_handle_common_intr(void *otg_dev);
  * 1 - SRP Only capable
  * 2 - No HNP/SRP capable
  */
-extern int dwc_otg_set_param_otg_cap(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_otg_cap(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_otg_cap(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_otg_cap(dwc_otg_core_if_t *core_if);
 #define DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE 0
 #define DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE 1
 #define DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE 2
 #define dwc_param_otg_cap_default DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE
 
-extern int dwc_otg_set_param_opt(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_opt(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_opt(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_opt(dwc_otg_core_if_t *core_if);
 #define dwc_param_opt_default 1
 
 /**
@@ -94,9 +94,9 @@ extern int32_t dwc_otg_get_param_opt(dwc_otg_core_if_t * core_if);
  * 0 - Slave
  * 1 - DMA (default, if available)
  */
-extern int dwc_otg_set_param_dma_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dma_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_dma_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dma_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_dma_enable_default 1
 
 /**
@@ -107,17 +107,17 @@ extern int32_t dwc_otg_get_param_dma_enable(dwc_otg_core_if_t * core_if);
  * 0 - address DMA
  * 1 - DMA Descriptor(default, if available)
  */
-extern int dwc_otg_set_param_dma_desc_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dma_desc_enable(dwc_otg_core_if_t *core_if,
 					     int32_t val);
-extern int32_t dwc_otg_get_param_dma_desc_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dma_desc_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_dma_desc_enable_default 0
 
 /** The DMA Burst size (applicable only for External DMA
  * Mode). 1, 4, 8 16, 32, 64, 128, 256 (default 32)
  */
-extern int dwc_otg_set_param_dma_burst_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dma_burst_size(dwc_otg_core_if_t *core_if,
 					    int32_t val);
-extern int32_t dwc_otg_get_param_dma_burst_size(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dma_burst_size(dwc_otg_core_if_t *core_if);
 #define dwc_param_dma_burst_size_default 32
 
 /**
@@ -128,8 +128,8 @@ extern int32_t dwc_otg_get_param_dma_burst_size(dwc_otg_core_if_t * core_if);
  * 0 - High Speed (default)
  * 1 - Full Speed
  */
-extern int dwc_otg_set_param_speed(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_speed(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_speed(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_speed(dwc_otg_core_if_t *core_if);
 #define dwc_param_speed_default 0
 #define DWC_SPEED_PARAM_HIGH 0
 #define DWC_SPEED_PARAM_FULL 1
@@ -142,7 +142,7 @@ extern int32_t dwc_otg_get_param_speed(dwc_otg_core_if_t * core_if);
 extern int dwc_otg_set_param_host_support_fs_ls_low_power(dwc_otg_core_if_t *
 							  core_if, int32_t val);
 extern int32_t dwc_otg_get_param_host_support_fs_ls_low_power(dwc_otg_core_if_t
-							      * core_if);
+							      *core_if);
 #define dwc_param_host_support_fs_ls_low_power_default 0
 
 /** Specifies the PHY clock rate in low power mode when connected to a
@@ -165,7 +165,7 @@ extern int32_t dwc_otg_get_param_host_ls_low_power_phy_clk(dwc_otg_core_if_t *
  * 0 - Use cC FIFO size parameters
  * 1 - Allow dynamic FIFO sizing (default)
  */
-extern int dwc_otg_set_param_enable_dynamic_fifo(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_enable_dynamic_fifo(dwc_otg_core_if_t *core_if,
 						 int32_t val);
 extern int32_t dwc_otg_get_param_enable_dynamic_fifo(dwc_otg_core_if_t *
 						     core_if);
@@ -177,18 +177,18 @@ extern int32_t dwc_otg_get_param_enable_dynamic_fifo(dwc_otg_core_if_t *
  * 32 to 32768 (default 8192)
  * Note: The total FIFO memory depth in the FPGA configuration is 8192.
  */
-extern int dwc_otg_set_param_data_fifo_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_data_fifo_size(dwc_otg_core_if_t *core_if,
 					    int32_t val);
-extern int32_t dwc_otg_get_param_data_fifo_size(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_data_fifo_size(dwc_otg_core_if_t *core_if);
 #define dwc_param_data_fifo_size_default 8192
 
 /** Number of 4-byte words in the Rx FIFO in device mode when dynamic
  * FIFO sizing is enabled.
  * 16 to 32768 (default 1064)
  */
-extern int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dev_rx_fifo_size(dwc_otg_core_if_t *core_if,
 					      int32_t val);
-extern int32_t dwc_otg_get_param_dev_rx_fifo_size(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dev_rx_fifo_size(dwc_otg_core_if_t *core_if);
 #define dwc_param_dev_rx_fifo_size_default 1064
 
 /** Number of 4-byte words in the non-periodic Tx FIFO in device mode
@@ -205,7 +205,7 @@ extern int32_t dwc_otg_get_param_dev_nperio_tx_fifo_size(dwc_otg_core_if_t *
  * mode when dynamic FIFO sizing is enabled.
  * 4 to 768 (default 256)
  */
-extern int dwc_otg_set_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t *core_if,
 						    int32_t val, int fifo_num);
 extern int32_t dwc_otg_get_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t *
 							core_if, int fifo_num);
@@ -215,9 +215,9 @@ extern int32_t dwc_otg_get_param_dev_perio_tx_fifo_size(dwc_otg_core_if_t *
  * FIFO sizing is enabled.
  * 16 to 32768 (default 1024)
  */
-extern int dwc_otg_set_param_host_rx_fifo_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_host_rx_fifo_size(dwc_otg_core_if_t *core_if,
 					       int32_t val);
-extern int32_t dwc_otg_get_param_host_rx_fifo_size(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_host_rx_fifo_size(dwc_otg_core_if_t *core_if);
 #define dwc_param_host_rx_fifo_size_default 1024
 
 /** Number of 4-byte words in the non-periodic Tx FIFO in host mode
@@ -243,26 +243,26 @@ extern int32_t dwc_otg_get_param_host_perio_tx_fifo_size(dwc_otg_core_if_t *
 /** The maximum transfer size supported in bytes.
  * 2047 to 65,535  (default 65,535)
  */
-extern int dwc_otg_set_param_max_transfer_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_max_transfer_size(dwc_otg_core_if_t *core_if,
 					       int32_t val);
-extern int32_t dwc_otg_get_param_max_transfer_size(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_max_transfer_size(dwc_otg_core_if_t *core_if);
 #define dwc_param_max_transfer_size_default 65535
 
 /** The maximum number of packets in a transfer.
  * 15 to 511  (default 511)
  */
-extern int dwc_otg_set_param_max_packet_count(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_max_packet_count(dwc_otg_core_if_t *core_if,
 					      int32_t val);
-extern int32_t dwc_otg_get_param_max_packet_count(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_max_packet_count(dwc_otg_core_if_t *core_if);
 #define dwc_param_max_packet_count_default 511
 
 /** The number of host channel registers to use.
  * 1 to 16 (default 12)
  * Note: The FPGA configuration supports a maximum of 12 host channels.
  */
-extern int dwc_otg_set_param_host_channels(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_host_channels(dwc_otg_core_if_t *core_if,
 					   int32_t val);
-extern int32_t dwc_otg_get_param_host_channels(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_host_channels(dwc_otg_core_if_t *core_if);
 #define dwc_param_host_channels_default 16
 
 /** The number of endpoints in addition to EP0 available for device
@@ -271,9 +271,9 @@ extern int32_t dwc_otg_get_param_host_channels(dwc_otg_core_if_t * core_if);
  * Note: The FPGA configuration supports a maximum of 6 IN and OUT
  * endpoints in addition to EP0.
  */
-extern int dwc_otg_set_param_dev_endpoints(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dev_endpoints(dwc_otg_core_if_t *core_if,
 					   int32_t val);
-extern int32_t dwc_otg_get_param_dev_endpoints(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dev_endpoints(dwc_otg_core_if_t *core_if);
 #define dwc_param_dev_endpoints_default 9
 
 /**
@@ -284,8 +284,8 @@ extern int32_t dwc_otg_get_param_dev_endpoints(dwc_otg_core_if_t * core_if);
  * 1 - UTMI+ (default)
  * 2 - ULPI
  */
-extern int dwc_otg_set_param_phy_type(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_phy_type(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_phy_type(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_phy_type(dwc_otg_core_if_t *core_if);
 #define DWC_PHY_TYPE_PARAM_FS 0
 #define DWC_PHY_TYPE_PARAM_UTMI 1
 #define DWC_PHY_TYPE_PARAM_ULPI 2
@@ -302,9 +302,9 @@ extern int32_t dwc_otg_get_param_phy_type(dwc_otg_core_if_t * core_if);
  *
  * 8 or 16 bits (default 16)
  */
-extern int dwc_otg_set_param_phy_utmi_width(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_phy_utmi_width(dwc_otg_core_if_t *core_if,
 					    int32_t val);
-extern int32_t dwc_otg_get_param_phy_utmi_width(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_phy_utmi_width(dwc_otg_core_if_t *core_if);
 #define dwc_param_phy_utmi_width_default 16
 
 /**
@@ -317,18 +317,18 @@ extern int32_t dwc_otg_get_param_phy_utmi_width(dwc_otg_core_if_t * core_if);
  * 1 - double data rate ULPI interface with 4 bit wide data
  * bus
  */
-extern int dwc_otg_set_param_phy_ulpi_ddr(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_phy_ulpi_ddr(dwc_otg_core_if_t *core_if,
 					  int32_t val);
-extern int32_t dwc_otg_get_param_phy_ulpi_ddr(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_phy_ulpi_ddr(dwc_otg_core_if_t *core_if);
 #define dwc_param_phy_ulpi_ddr_default 0
 
 /**
  * Specifies whether to use the internal or external supply to
  * drive the vbus with a ULPI phy.
  */
-extern int dwc_otg_set_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t *core_if,
 					       int32_t val);
-extern int32_t dwc_otg_get_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t *core_if);
 #define DWC_PHY_ULPI_INTERNAL_VBUS 0
 #define DWC_PHY_ULPI_EXTERNAL_VBUS 1
 #define dwc_param_phy_ulpi_ext_vbus_default DWC_PHY_ULPI_INTERNAL_VBUS
@@ -339,18 +339,18 @@ extern int32_t dwc_otg_get_param_phy_ulpi_ext_vbus(dwc_otg_core_if_t * core_if);
  * 0 - No (default)
  * 1 - Yes
  */
-extern int dwc_otg_set_param_i2c_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_i2c_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_i2c_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_i2c_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_i2c_enable_default 0
 
-extern int dwc_otg_set_param_ulpi_fs_ls(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_ulpi_fs_ls(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_ulpi_fs_ls(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_ulpi_fs_ls(dwc_otg_core_if_t *core_if);
 #define dwc_param_ulpi_fs_ls_default 0
 
-extern int dwc_otg_set_param_ts_dline(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_ts_dline(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_ts_dline(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_ts_dline(dwc_otg_core_if_t *core_if);
 #define dwc_param_ts_dline_default 0
 
 /**
@@ -359,7 +359,7 @@ extern int32_t dwc_otg_get_param_ts_dline(dwc_otg_core_if_t * core_if);
  * 0 - No
  * 1 - Yes
  */
-extern int dwc_otg_set_param_en_multiple_tx_fifo(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_en_multiple_tx_fifo(dwc_otg_core_if_t *core_if,
 						 int32_t val);
 extern int32_t dwc_otg_get_param_en_multiple_tx_fifo(dwc_otg_core_if_t *
 						     core_if);
@@ -369,9 +369,9 @@ extern int32_t dwc_otg_get_param_en_multiple_tx_fifo(dwc_otg_core_if_t *
  * mode when dynamic FIFO sizing is enabled.
  * 4 to 768 (default 256)
  */
-extern int dwc_otg_set_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dev_tx_fifo_size(dwc_otg_core_if_t *core_if,
 					      int fifo_num, int32_t val);
-extern int32_t dwc_otg_get_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if,
+extern int32_t dwc_otg_get_param_dev_tx_fifo_size(dwc_otg_core_if_t *core_if,
 						  int fifo_num);
 #define dwc_param_dev_tx_fifo_size_default 256
 
@@ -380,123 +380,123 @@ extern int32_t dwc_otg_get_param_dev_tx_fifo_size(dwc_otg_core_if_t * core_if,
  * bit 1 - enable ISO Tx thresholding
  * bit 2 - enable Rx thresholding
  */
-extern int dwc_otg_set_param_thr_ctl(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_thr_ctl(dwc_otg_core_if_t * core_if, int fifo_num);
+extern int dwc_otg_set_param_thr_ctl(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_thr_ctl(dwc_otg_core_if_t *core_if, int fifo_num);
 #define dwc_param_thr_ctl_default 0
 
 /** Thresholding length for Tx
  * FIFOs in 32 bit DWORDs
  */
-extern int dwc_otg_set_param_tx_thr_length(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_tx_thr_length(dwc_otg_core_if_t *core_if,
 					   int32_t val);
-extern int32_t dwc_otg_get_tx_thr_length(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_tx_thr_length(dwc_otg_core_if_t *core_if);
 #define dwc_param_tx_thr_length_default 64
 
 /** Thresholding length for Rx
  *	FIFOs in 32 bit DWORDs
  */
-extern int dwc_otg_set_param_rx_thr_length(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_rx_thr_length(dwc_otg_core_if_t *core_if,
 					   int32_t val);
-extern int32_t dwc_otg_get_rx_thr_length(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_rx_thr_length(dwc_otg_core_if_t *core_if);
 #define dwc_param_rx_thr_length_default 64
 
 /**
  * Specifies whether LPM (Link Power Management) support is enabled
  */
-extern int dwc_otg_set_param_lpm_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_lpm_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_lpm_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_lpm_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_lpm_enable_default 1
 
 /**
  * Specifies whether LPM Errata (Link Power Management) support is enabled
  */
-extern int dwc_otg_set_param_besl_enable(dwc_otg_core_if_t * core_if,
-					int32_t val);
-extern int32_t dwc_otg_get_param_besl_enable(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_besl_enable(dwc_otg_core_if_t *core_if,
+					 int32_t val);
+extern int32_t dwc_otg_get_param_besl_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_besl_enable_default 0
 
 /**
  * Specifies baseline_besl default value
  */
-extern int dwc_otg_set_param_baseline_besl(dwc_otg_core_if_t * core_if,
-					int32_t val);
-extern int32_t dwc_otg_get_param_baseline_besl(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_baseline_besl(dwc_otg_core_if_t *core_if,
+					   int32_t val);
+extern int32_t dwc_otg_get_param_baseline_besl(dwc_otg_core_if_t *core_if);
 #define dwc_param_baseline_besl_default 0
 
 /**
  * Specifies deep_besl default value
  */
-extern int dwc_otg_set_param_deep_besl(dwc_otg_core_if_t * core_if,
-					int32_t val);
-extern int32_t dwc_otg_get_param_deep_besl(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_deep_besl(dwc_otg_core_if_t *core_if,
+				       int32_t val);
+extern int32_t dwc_otg_get_param_deep_besl(dwc_otg_core_if_t *core_if);
 #define dwc_param_deep_besl_default 15
 
 /**
  * Specifies whether PTI enhancement is enabled
  */
-extern int dwc_otg_set_param_pti_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_pti_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_pti_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_pti_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_pti_enable_default 0
 
 /**
  * Specifies whether MPI enhancement is enabled
  */
-extern int dwc_otg_set_param_mpi_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_mpi_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_mpi_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_mpi_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_mpi_enable_default 0
 
 /**
  * Specifies whether ADP capability is enabled
  */
-extern int dwc_otg_set_param_adp_enable(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_adp_enable(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_adp_enable(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_adp_enable(dwc_otg_core_if_t *core_if);
 #define dwc_param_adp_enable_default 0
 
 /**
  * Specifies whether IC_USB capability is enabled
  */
 
-extern int dwc_otg_set_param_ic_usb_cap(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_ic_usb_cap(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_ic_usb_cap(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_ic_usb_cap(dwc_otg_core_if_t *core_if);
 #define dwc_param_ic_usb_cap_default 0
 
-extern int dwc_otg_set_param_ahb_thr_ratio(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_ahb_thr_ratio(dwc_otg_core_if_t *core_if,
 					   int32_t val);
-extern int32_t dwc_otg_get_param_ahb_thr_ratio(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_ahb_thr_ratio(dwc_otg_core_if_t *core_if);
 #define dwc_param_ahb_thr_ratio_default 0
 
-extern int dwc_otg_set_param_power_down(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_power_down(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_power_down(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_power_down(dwc_otg_core_if_t *core_if);
 #define dwc_param_power_down_default 0
 
-extern int dwc_otg_set_param_reload_ctl(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_reload_ctl(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_reload_ctl(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_reload_ctl(dwc_otg_core_if_t *core_if);
 #define dwc_param_reload_ctl_default 0
 
-extern int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_dev_out_nak(dwc_otg_core_if_t *core_if,
 					 int32_t val);
-extern int32_t dwc_otg_get_param_dev_out_nak(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_dev_out_nak(dwc_otg_core_if_t *core_if);
 #define dwc_param_dev_out_nak_default 0
 
-extern int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_cont_on_bna(dwc_otg_core_if_t *core_if,
 					 int32_t val);
-extern int32_t dwc_otg_get_param_cont_on_bna(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_cont_on_bna(dwc_otg_core_if_t *core_if);
 #define dwc_param_cont_on_bna_default 0
 
-extern int dwc_otg_set_param_ahb_single(dwc_otg_core_if_t * core_if,
+extern int dwc_otg_set_param_ahb_single(dwc_otg_core_if_t *core_if,
 					int32_t val);
-extern int32_t dwc_otg_get_param_ahb_single(dwc_otg_core_if_t * core_if);
+extern int32_t dwc_otg_get_param_ahb_single(dwc_otg_core_if_t *core_if);
 #define dwc_param_ahb_single_default 0
 
-extern int dwc_otg_set_param_otg_ver(dwc_otg_core_if_t * core_if, int32_t val);
-extern int32_t dwc_otg_get_param_otg_ver(dwc_otg_core_if_t * core_if);
+extern int dwc_otg_set_param_otg_ver(dwc_otg_core_if_t *core_if, int32_t val);
+extern int32_t dwc_otg_get_param_otg_ver(dwc_otg_core_if_t *core_if);
 #define dwc_param_otg_ver_default 0
 
 /** @} */
@@ -506,184 +506,183 @@ extern int32_t dwc_otg_get_param_otg_ver(dwc_otg_core_if_t * core_if);
 /**
  * Dump core registers and SPRAM
  */
-extern void dwc_otg_dump_dev_registers(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_dump_spram(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_dump_host_registers(dwc_otg_core_if_t * _core_if);
-extern void dwc_otg_dump_global_registers(dwc_otg_core_if_t * _core_if);
+extern void dwc_otg_dump_dev_registers(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_dump_spram(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_dump_host_registers(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_dump_global_registers(dwc_otg_core_if_t *_core_if);
 
 /**
  * Get host negotiation status.
  */
-extern uint32_t dwc_otg_get_hnpstatus(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_hnpstatus(dwc_otg_core_if_t *core_if);
 
 /**
  * Get srp status
  */
-extern uint32_t dwc_otg_get_srpstatus(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_srpstatus(dwc_otg_core_if_t *core_if);
 
 /**
  * Set hnpreq bit in the GOTGCTL register.
  */
-extern void dwc_otg_set_hnpreq(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_hnpreq(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get Content of SNPSID register.
  */
-extern uint32_t dwc_otg_get_gsnpsid(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_gsnpsid(dwc_otg_core_if_t *core_if);
 
 /**
  * Get current mode.
  * Returns 0 if in device mode, and 1 if in host mode.
  */
-extern uint32_t dwc_otg_get_mode(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_mode(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of hnpcapable field in the GUSBCFG register
  */
-extern uint32_t dwc_otg_get_hnpcapable(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_hnpcapable(dwc_otg_core_if_t *core_if);
 /**
  * Set value of hnpcapable field in the GUSBCFG register
  */
-extern void dwc_otg_set_hnpcapable(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_hnpcapable(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of srpcapable field in the GUSBCFG register
  */
-extern uint32_t dwc_otg_get_srpcapable(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_srpcapable(dwc_otg_core_if_t *core_if);
 /**
  * Set value of srpcapable field in the GUSBCFG register
  */
-extern void dwc_otg_set_srpcapable(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_srpcapable(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of devspeed field in the DCFG register
  */
-extern uint32_t dwc_otg_get_devspeed(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_devspeed(dwc_otg_core_if_t *core_if);
 /**
  * Set value of devspeed field in the DCFG register
  */
-extern void dwc_otg_set_devspeed(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_devspeed(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get the value of busconnected field from the HPRT0 register
  */
-extern uint32_t dwc_otg_get_busconnected(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_busconnected(dwc_otg_core_if_t *core_if);
 
 /**
  * Gets the device enumeration Speed.
  */
-extern uint32_t dwc_otg_get_enumspeed(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_enumspeed(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of prtpwr field from the HPRT0 register
  */
-extern uint32_t dwc_otg_get_prtpower(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_prtpower(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of flag indicating core state - hibernated or not
  */
-extern uint32_t dwc_otg_get_core_state(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_core_state(dwc_otg_core_if_t *core_if);
 
 /**
  * Set value of prtpwr field from the HPRT0 register
  */
-extern void dwc_otg_set_prtpower(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_prtpower(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of prtsusp field from the HPRT0 regsiter
  */
-extern uint32_t dwc_otg_get_prtsuspend(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_prtsuspend(dwc_otg_core_if_t *core_if);
 /**
  * Set value of prtpwr field from the HPRT0 register
  */
-extern void dwc_otg_set_prtsuspend(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_prtsuspend(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of ModeChTimEn field from the HCFG regsiter
  */
-extern uint32_t dwc_otg_get_mode_ch_tim(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_mode_ch_tim(dwc_otg_core_if_t *core_if);
 /**
  * Set value of ModeChTimEn field from the HCFG regsiter
  */
-extern void dwc_otg_set_mode_ch_tim(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_mode_ch_tim(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of Fram Interval field from the HFIR regsiter
  */
-extern uint32_t dwc_otg_get_fr_interval(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_fr_interval(dwc_otg_core_if_t *core_if);
 /**
  * Set value of Frame Interval field from the HFIR regsiter
  */
-extern void dwc_otg_set_fr_interval(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_fr_interval(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Set value of prtres field from the HPRT0 register
  *FIXME Remove?
  */
-extern void dwc_otg_set_prtresume(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_prtresume(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of rmtwkupsig bit in DCTL register
  */
-extern uint32_t dwc_otg_get_remotewakesig(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_remotewakesig(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of besl_reject bit in DCTL register
  */
- 
-extern uint32_t dwc_otg_get_beslreject(dwc_otg_core_if_t * core_if);
+
+extern uint32_t dwc_otg_get_beslreject(dwc_otg_core_if_t *core_if);
 
 /**
  * Set value of besl_reject bit in DCTL register
  */
- 
-extern void dwc_otg_set_beslreject(dwc_otg_core_if_t * core_if, uint32_t val);
+
+extern void dwc_otg_set_beslreject(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of prt_sleep_sts field from the GLPMCFG register
  */
-extern uint32_t dwc_otg_get_lpm_portsleepstatus(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_lpm_portsleepstatus(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of rem_wkup_en field from the GLPMCFG register
  */
-extern uint32_t dwc_otg_get_lpm_remotewakeenabled(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_lpm_remotewakeenabled(dwc_otg_core_if_t *core_if);
 
 /**
  * Get value of appl_resp field from the GLPMCFG register
  */
-extern uint32_t dwc_otg_get_lpmresponse(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_lpmresponse(dwc_otg_core_if_t *core_if);
 /**
  * Set value of appl_resp field from the GLPMCFG register
  */
-extern void dwc_otg_set_lpmresponse(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_lpmresponse(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of hsic_connect field from the GLPMCFG register
  */
-extern uint32_t dwc_otg_get_hsic_connect(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_hsic_connect(dwc_otg_core_if_t *core_if);
 /**
  * Set value of hsic_connect field from the GLPMCFG register
  */
-extern void dwc_otg_set_hsic_connect(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_hsic_connect(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * Get value of inv_sel_hsic field from the GLPMCFG register.
  */
-extern uint32_t dwc_otg_get_inv_sel_hsic(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_inv_sel_hsic(dwc_otg_core_if_t *core_if);
 /**
  * Set value of inv_sel_hsic field from the GLPMFG register.
  */
-extern void dwc_otg_set_inv_sel_hsic(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_inv_sel_hsic(dwc_otg_core_if_t *core_if, uint32_t val);
 /**
  * Set value of hird_thresh field from the GLPMFG register.
  */
-extern void dwc_otg_set_hirdthresh(dwc_otg_core_if_t * core_if, uint32_t val);
+extern void dwc_otg_set_hirdthresh(dwc_otg_core_if_t *core_if, uint32_t val);
 /**
  * Get value of hird_thresh field from the GLPMFG register.
  */
-extern uint32_t dwc_otg_get_hirdthresh(dwc_otg_core_if_t * core_if);
-
+extern uint32_t dwc_otg_get_hirdthresh(dwc_otg_core_if_t *core_if);
 
 /*
  * Some functions for accessing registers
@@ -692,52 +691,52 @@ extern uint32_t dwc_otg_get_hirdthresh(dwc_otg_core_if_t * core_if);
 /**
  *  GOTGCTL register
  */
-extern uint32_t dwc_otg_get_gotgctl(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_gotgctl(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_gotgctl(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_gotgctl(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GUSBCFG register
  */
-extern uint32_t dwc_otg_get_gusbcfg(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_gusbcfg(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_gusbcfg(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_gusbcfg(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GRXFSIZ register
  */
-extern uint32_t dwc_otg_get_grxfsiz(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_grxfsiz(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_grxfsiz(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_grxfsiz(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GNPTXFSIZ register
  */
-extern uint32_t dwc_otg_get_gnptxfsiz(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_gnptxfsiz(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_gnptxfsiz(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_gnptxfsiz(dwc_otg_core_if_t *core_if, uint32_t val);
 
-extern uint32_t dwc_otg_get_gpvndctl(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_gpvndctl(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_gpvndctl(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_gpvndctl(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GGPIO register
  */
-extern uint32_t dwc_otg_get_ggpio(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_ggpio(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_ggpio(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_ggpio(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GUID register
  */
-extern uint32_t dwc_otg_get_guid(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_guid(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_guid(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_guid(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * HPRT0 register
  */
-extern uint32_t dwc_otg_get_hprt0(dwc_otg_core_if_t * core_if);
-extern void dwc_otg_set_hprt0(dwc_otg_core_if_t * core_if, uint32_t val);
+extern uint32_t dwc_otg_get_hprt0(dwc_otg_core_if_t *core_if);
+extern void dwc_otg_set_hprt0(dwc_otg_core_if_t *core_if, uint32_t val);
 
 /**
  * GHPTXFSIZE
  */
-extern uint32_t dwc_otg_get_hptxfsiz(dwc_otg_core_if_t * core_if);
+extern uint32_t dwc_otg_get_hptxfsiz(dwc_otg_core_if_t *core_if);
 
 /** @} */
 
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_dbg.h b/drivers/usb/dwc_otg_310/dwc_otg_dbg.h
index e81d0935512e..83fe29ada526 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_dbg.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_dbg.h
@@ -3,7 +3,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -13,7 +13,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -32,7 +32,7 @@
 
 /** @file
  * This file defines debug levels.
- * Debugging support vanishes in non-debug builds.  
+ * Debugging support vanishes in non-debug builds.
  */
 
 /**
@@ -78,7 +78,7 @@ static inline uint32_t SET_DEBUG_LEVEL(const uint32_t new)
 /** Prefix string for DWC_DEBUG print macros. */
 #define USB_DWC "DWC_otg: "
 
-/** 
+/**
  * Print a debug message when the Global debug level variable contains
  * the bit defined in <code>lvl</code>.
  *
@@ -90,21 +90,21 @@ static inline uint32_t SET_DEBUG_LEVEL(const uint32_t new)
  *      DWC_DEBUGPL( DBG_ANY, "%s(%p)\n", __func__, _reg_base_addr);
  * </code>
  * <br>
- * results in:<br> 
+ * results in:<br>
  * <code>
  * usb-DWC_otg: dwc_otg_cil_init(ca867000)
  * </code>
  */
 #ifdef DEBUG
 
-# define DWC_DEBUGPL(lvl, x...) do{ if ((lvl)&g_dbg_lvl)__DWC_DEBUG(USB_DWC x ); }while(0)
-# define DWC_DEBUGP(x...)	DWC_DEBUGPL(DBG_ANY, x )
+# define DWC_DEBUGPL(lvl, x...) do { if ((lvl)&g_dbg_lvl)__DWC_DEBUG(USB_DWC x); } while (0)
+# define DWC_DEBUGP(x...)	DWC_DEBUGPL(DBG_ANY, x)
 
 # define CHK_DEBUG_LEVEL(level) ((level) & g_dbg_lvl)
 
 #else
 
-# define DWC_DEBUGPL(lvl, x...) do{}while(0)
+# define DWC_DEBUGPL(lvl, x...) do {} while (0)
 # define DWC_DEBUGP(x...)
 
 # define CHK_DEBUG_LEVEL(level) (0)
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_driver.c b/drivers/usb/dwc_otg_310/dwc_otg_driver.c
index 49026c432d17..d20173159647 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_driver.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_driver.c
@@ -65,42 +65,42 @@
 #define DWC_DRIVER_DESC		"HS OTG USB Controller driver"
 
 static const char dwc_host20_driver_name[] = "usb20_host";
-static const char dwc_otg20_driver_name[]  = "usb20_otg";
+static const char dwc_otg20_driver_name[] = "usb20_otg";
 
-dwc_otg_device_t* g_otgdev = NULL;
+dwc_otg_device_t *g_otgdev;
 
-extern int pcd_init( struct platform_device *_dev );
-extern int otg20_hcd_init( struct platform_device *_dev );
-extern int host20_hcd_init( struct platform_device *_dev );
-extern int pcd_remove(     struct platform_device *_dev );
-extern void hcd_remove(     struct platform_device *_dev);
-extern void dwc_otg_adp_start( dwc_otg_core_if_t * core_if, uint8_t is_host);
+extern int pcd_init(struct platform_device *_dev);
+extern int otg20_hcd_init(struct platform_device *_dev);
+extern int host20_hcd_init(struct platform_device *_dev);
+extern int pcd_remove(struct platform_device *_dev);
+extern void hcd_remove(struct platform_device *_dev);
+extern void dwc_otg_adp_start(dwc_otg_core_if_t *core_if, uint8_t is_host);
 
 #ifdef CONFIG_USB20_OTG
 static struct usb20otg_pdata_id usb20otg_pdata[] = {
 	{
-		.name = "rk3188-usb20otg",
-		.pdata = &usb20otg_pdata_rk3188,
-	},
+	 .name = "rk3188-usb20otg",
+	 .pdata = &usb20otg_pdata_rk3188,
+	 },
 	{
-		.name = "rk3288-usb20otg",
-		.pdata = &usb20otg_pdata_rk3288,
-	},
-	{ },
+	 .name = "rk3288-usb20otg",
+	 .pdata = &usb20otg_pdata_rk3288,
+	 },
+	{},
 };
 #endif
 
 #ifdef CONFIG_USB20_HOST
 static struct usb20host_pdata_id usb20host_pdata[] = {
 	{
-		.name = "rk3188-usb20host",
-		.pdata = &usb20host_pdata_rk3188,
-	},
+	 .name = "rk3188-usb20host",
+	 .pdata = &usb20host_pdata_rk3188,
+	 },
 	{
-		.name = "rk3288-usb20host",
-		.pdata = &usb20host_pdata_rk3288,
-	},
-	{ },
+	 .name = "rk3288-usb20host",
+	 .pdata = &usb20host_pdata_rk3288,
+	 },
+	{},
 };
 #endif
 
@@ -348,7 +348,7 @@ static DRIVER_ATTR(version, S_IRUGO, version_show, NULL);
 /**
  * Global Debug Level Mask.
  */
-uint32_t g_dbg_lvl = DBG_OFF;		/* OFF */
+uint32_t g_dbg_lvl = DBG_OFF;	/* OFF */
 
 /**
  * This function shows the driver Debug Level.
@@ -378,21 +378,20 @@ extern void dwc_otg_hub_disconnect_device(struct usb_hub *hub);
 void dwc_otg_force_host(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_device_t *otg_dev = core_if->otg_dev;
-	dctl_data_t dctl = {.d32=0};
+	dctl_data_t dctl = {.d32 = 0 };
 	unsigned long flags;
 
-	if(core_if->op_state == A_HOST)
-    {
-    	printk("dwc_otg_force_host,already in A_HOST mode,everest\n");
-    	return;
-    }
+	if (core_if->op_state == A_HOST) {
+		printk("dwc_otg_force_host,already in A_HOST mode,everest\n");
+		return;
+	}
 	core_if->op_state = A_HOST;
 
 	cancel_delayed_work(&otg_dev->pcd->check_vbus_work);
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 	dctl.b.sftdiscon = 1;
 	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
-	
+
 	local_irq_save(flags);
 	cil_pcd_stop(core_if);
 	/*
@@ -404,6 +403,7 @@ void dwc_otg_force_host(dwc_otg_core_if_t *core_if)
 	cil_hcd_start(core_if);
 	local_irq_restore(flags);
 }
+
 void dwc_otg_force_device(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_device_t *otg_dev = core_if->otg_dev;
@@ -411,46 +411,48 @@ void dwc_otg_force_device(dwc_otg_core_if_t *core_if)
 
 	local_irq_save(flags);
 
-	if(core_if->op_state == B_PERIPHERAL) {
-		printk("dwc_otg_force_device,already in B_PERIPHERAL,everest\n");
+	if (core_if->op_state == B_PERIPHERAL) {
+		printk
+		    ("dwc_otg_force_device,already in B_PERIPHERAL,everest\n");
 		return;
 	}
 	core_if->op_state = B_PERIPHERAL;
 	cil_hcd_stop(core_if);
-	//dwc_otg_hub_disconnect_device(g_dwc_otg_root_hub20);
+	/* dwc_otg_hub_disconnect_device(g_dwc_otg_root_hub20); */
 	otg_dev->pcd->phy_suspend = 1;
 	otg_dev->pcd->vbus_status = 0;
 	dwc_otg_pcd_start_check_vbus_work(otg_dev->pcd);
-	
+
 	/* Reset the Controller */
-	dwc_otg_core_reset( core_if );
-	
+	dwc_otg_core_reset(core_if);
+
 	dwc_otg_core_init(core_if);
 	dwc_otg_disable_global_interrupts(core_if);
 	cil_pcd_start(core_if);
 
 	local_irq_restore(flags);
 }
+
 static void dwc_otg_set_force_mode(dwc_otg_core_if_t *core_if, int mode)
 {
-	gusbcfg_data_t usbcfg = { .d32 = 0 };
+	gusbcfg_data_t usbcfg = {.d32 = 0 };
 	printk("!!!dwc_otg_set_force_mode\n");
-	usbcfg.d32 = DWC_READ_REG32( &core_if->core_global_regs->gusbcfg);
-	switch(mode) {
-		case USB_MODE_FORCE_HOST:
-			usbcfg.b.force_host_mode = 1;
-			usbcfg.b.force_dev_mode = 0;
-			break;
-		case USB_MODE_FORCE_DEVICE:
-			usbcfg.b.force_host_mode = 0;
-			usbcfg.b.force_dev_mode = 1;
-			break;
-		case USB_MODE_NORMAL:
-			usbcfg.b.force_host_mode = 0;
-			usbcfg.b.force_dev_mode = 0;
-			break;
-	}
-	DWC_WRITE_REG32( &core_if->core_global_regs->gusbcfg, usbcfg.d32 );
+	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
+	switch (mode) {
+	case USB_MODE_FORCE_HOST:
+		usbcfg.b.force_host_mode = 1;
+		usbcfg.b.force_dev_mode = 0;
+		break;
+	case USB_MODE_FORCE_DEVICE:
+		usbcfg.b.force_host_mode = 0;
+		usbcfg.b.force_dev_mode = 1;
+		break;
+	case USB_MODE_NORMAL:
+		usbcfg.b.force_host_mode = 0;
+		usbcfg.b.force_dev_mode = 0;
+		break;
+	}
+	DWC_WRITE_REG32(&core_if->core_global_regs->gusbcfg, usbcfg.d32);
 }
 
 static ssize_t force_usb_mode_show(struct device_driver *drv, char *buf)
@@ -462,260 +464,240 @@ static ssize_t force_usb_mode_show(struct device_driver *drv, char *buf)
 }
 
 static ssize_t force_usb_mode_store(struct device_driver *drv, const char *buf,
-                                    size_t count )
+				    size_t count)
 {
 	int new_mode = simple_strtoul(buf, NULL, 16);
 	dwc_otg_device_t *otg_dev = g_otgdev;
 	dwc_otg_core_if_t *core_if;
 	struct dwc_otg_platform_data *pldata;
 
-	if(!otg_dev)
+	if (!otg_dev)
 		return -EINVAL;
 
 	core_if = otg_dev->core_if;
 	pldata = otg_dev->pldata;
 
-	DWC_PRINTF("%s %d->%d\n",__func__, core_if->usb_mode, new_mode);
+	DWC_PRINTF("%s %d->%d\n", __func__, core_if->usb_mode, new_mode);
 
-	if(core_if->usb_mode == new_mode) {
+	if (core_if->usb_mode == new_mode) {
 		return count;
 	}
 
-	if(pldata->phy_status == USB_PHY_SUSPEND) {
+	if (pldata->phy_status == USB_PHY_SUSPEND) {
 		pldata->clock_enable(pldata, 1);
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 	}
 
-	switch(new_mode) {
-		case USB_MODE_FORCE_HOST:
-			if(USB_MODE_FORCE_DEVICE == core_if->usb_mode) {
-				/* device-->host */
-				core_if->usb_mode = new_mode;
+	switch (new_mode) {
+	case USB_MODE_FORCE_HOST:
+		if (USB_MODE_FORCE_DEVICE == core_if->usb_mode) {
+			/* device-->host */
+			core_if->usb_mode = new_mode;
+			dwc_otg_force_host(core_if);
+		} else if (USB_MODE_NORMAL == core_if->usb_mode) {
+			core_if->usb_mode = new_mode;
+			if (dwc_otg_is_host_mode(core_if))
+				dwc_otg_set_force_mode(core_if, new_mode);
+			else
 				dwc_otg_force_host(core_if);
-			} else if(USB_MODE_NORMAL == core_if->usb_mode) {
-				core_if->usb_mode = new_mode;
-				if(dwc_otg_is_host_mode(core_if)) {
-					dwc_otg_set_force_mode(core_if, new_mode);
-				} else {
-					dwc_otg_force_host(core_if);
-				}
-			}
-			break;
-
-		case USB_MODE_FORCE_DEVICE:
-			if(USB_MODE_FORCE_HOST == core_if->usb_mode) {
-				core_if->usb_mode = new_mode;
+		}
+		break;
+
+	case USB_MODE_FORCE_DEVICE:
+		if (USB_MODE_FORCE_HOST == core_if->usb_mode) {
+			core_if->usb_mode = new_mode;
+			dwc_otg_force_device(core_if);
+		} else if (USB_MODE_NORMAL == core_if->usb_mode) {
+			core_if->usb_mode = new_mode;
+			if (dwc_otg_is_device_mode(core_if))
+				dwc_otg_set_force_mode(core_if, new_mode);
+			else
 				dwc_otg_force_device(core_if);
-			} else if(USB_MODE_NORMAL == core_if->usb_mode) {
-				core_if->usb_mode = new_mode;
-				if(dwc_otg_is_device_mode(core_if)) {
-					dwc_otg_set_force_mode(core_if, new_mode);
-				} else {
-					dwc_otg_force_device(core_if);
-				}
+		}
+		break;
+
+	case USB_MODE_NORMAL:
+		if (USB_MODE_FORCE_DEVICE == core_if->usb_mode) {
+			core_if->usb_mode = new_mode;
+			cancel_delayed_work(&otg_dev->pcd->check_vbus_work);
+			dwc_otg_set_force_mode(core_if, new_mode);
+			/* msleep(100); */
+			if (dwc_otg_is_host_mode(core_if)) {
+				dwc_otg_force_host(core_if);
+			} else {
+				dwc_otg_pcd_start_check_vbus_work(otg_dev->pcd);
 			}
-			break;
-
-		case USB_MODE_NORMAL:
-			if(USB_MODE_FORCE_DEVICE == core_if->usb_mode) {
-				core_if->usb_mode = new_mode;
-				cancel_delayed_work(&otg_dev->pcd->check_vbus_work);
-				dwc_otg_set_force_mode(core_if, new_mode);
-				//msleep(100);
-				if(dwc_otg_is_host_mode(core_if)) {
-					dwc_otg_force_host(core_if);
-				} else {
-					dwc_otg_pcd_start_check_vbus_work(otg_dev->pcd);
-				}
-			} else if(USB_MODE_FORCE_HOST == core_if->usb_mode) {
-				core_if->usb_mode = new_mode;
-				dwc_otg_set_force_mode(core_if, new_mode);
-				//msleep(100);
-				if(dwc_otg_is_device_mode(core_if)) {
-					dwc_otg_force_device(core_if);
-				}
+		} else if (USB_MODE_FORCE_HOST == core_if->usb_mode) {
+			core_if->usb_mode = new_mode;
+			dwc_otg_set_force_mode(core_if, new_mode);
+			/* msleep(100); */
+			if (dwc_otg_is_device_mode(core_if)) {
+				dwc_otg_force_device(core_if);
 			}
-			break;
+		}
+		break;
 
-		default:
-			break;
+	default:
+		break;
 	}
 	return count;
 }
 
-static DRIVER_ATTR(force_usb_mode, S_IRUGO | S_IWUSR, force_usb_mode_show, force_usb_mode_store);
-
+static DRIVER_ATTR(force_usb_mode, S_IRUGO | S_IWUSR, force_usb_mode_show,
+		   force_usb_mode_store);
 
 static ssize_t dwc_otg_conn_en_show(struct device_driver *_drv, char *_buf)
 {
 
-    dwc_otg_device_t *otg_dev = g_otgdev;
-    dwc_otg_pcd_t *_pcd = otg_dev->pcd;
-    return sprintf (_buf, "%d\n", _pcd->conn_en);
+	dwc_otg_device_t *otg_dev = g_otgdev;
+	dwc_otg_pcd_t *_pcd = otg_dev->pcd;
+	return sprintf(_buf, "%d\n", _pcd->conn_en);
 
 }
 
-static ssize_t dwc_otg_conn_en_store(struct device_driver *_drv, const char *_buf,
-				     size_t _count)
+static ssize_t dwc_otg_conn_en_store(struct device_driver *_drv,
+				     const char *_buf, size_t _count)
 {
-    int enable = simple_strtoul(_buf, NULL, 10);
-    dwc_otg_device_t *otg_dev = g_otgdev;
-    dwc_otg_pcd_t *_pcd = otg_dev->pcd;
-    DWC_PRINTF("%s %d->%d\n",__func__, _pcd->conn_en, enable);
-    
-    _pcd->conn_en = enable;
-    return _count;
+	int enable = simple_strtoul(_buf, NULL, 10);
+	dwc_otg_device_t *otg_dev = g_otgdev;
+	dwc_otg_pcd_t *_pcd = otg_dev->pcd;
+	DWC_PRINTF("%s %d->%d\n", __func__, _pcd->conn_en, enable);
+
+	_pcd->conn_en = enable;
+	return _count;
 }
-static DRIVER_ATTR(dwc_otg_conn_en, S_IRUGO|S_IWUSR, dwc_otg_conn_en_show, dwc_otg_conn_en_store);
+
+static DRIVER_ATTR(dwc_otg_conn_en, S_IRUGO | S_IWUSR, dwc_otg_conn_en_show,
+		   dwc_otg_conn_en_store);
 
 static ssize_t vbus_status_show(struct device_driver *_drv, char *_buf)
 {
 	dwc_otg_device_t *otg_dev = g_otgdev;
 	dwc_otg_pcd_t *_pcd = otg_dev->pcd;
-	return sprintf (_buf, "%d\n", _pcd->vbus_status);
+	return sprintf(_buf, "%d\n", _pcd->vbus_status);
 }
+
 static DRIVER_ATTR(vbus_status, S_IRUGO, vbus_status_show, NULL);
 
 /**
  * This function is called during module intialization
  * to pass module parameters to the DWC_OTG CORE.
  */
-static int set_parameters(dwc_otg_core_if_t * core_if, struct dwc_otg_driver_module_params module_params)
+static int set_parameters(dwc_otg_core_if_t *core_if,
+			  struct dwc_otg_driver_module_params module_params)
 {
 	int retval = 0;
 	int i;
 
 	if (module_params.otg_cap != -1) {
 		retval +=
-		    dwc_otg_set_param_otg_cap(core_if,
-					      module_params.otg_cap);
+		    dwc_otg_set_param_otg_cap(core_if, module_params.otg_cap);
 	}
 	if (module_params.dma_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_dma_enable(core_if,
-						 module_params.
-						 dma_enable);
+						 module_params.dma_enable);
 	}
 	if (module_params.dma_desc_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_dma_desc_enable(core_if,
-						      module_params.
-						      dma_desc_enable);
+						      module_params.dma_desc_enable);
 	}
 	if (module_params.opt != -1) {
-		retval +=
-		    dwc_otg_set_param_opt(core_if, module_params.opt);
+		retval += dwc_otg_set_param_opt(core_if, module_params.opt);
 	}
 	if (module_params.dma_burst_size != -1) {
 		retval +=
 		    dwc_otg_set_param_dma_burst_size(core_if,
-						     module_params.
-						     dma_burst_size);
+						     module_params.dma_burst_size);
 	}
 	if (module_params.host_support_fs_ls_low_power != -1) {
 		retval +=
 		    dwc_otg_set_param_host_support_fs_ls_low_power(core_if,
-								   module_params.
-								   host_support_fs_ls_low_power);
+								   module_params.host_support_fs_ls_low_power);
 	}
 	if (module_params.enable_dynamic_fifo != -1) {
 		retval +=
 		    dwc_otg_set_param_enable_dynamic_fifo(core_if,
-							  module_params.
-							  enable_dynamic_fifo);
+							  module_params.enable_dynamic_fifo);
 	}
 	if (module_params.data_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_data_fifo_size(core_if,
-						     module_params.
-						     data_fifo_size);
+						     module_params.data_fifo_size);
 	}
 	if (module_params.dev_rx_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_dev_rx_fifo_size(core_if,
-						       module_params.
-						       dev_rx_fifo_size);
+						       module_params.dev_rx_fifo_size);
 	}
 	if (module_params.dev_nperio_tx_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_dev_nperio_tx_fifo_size(core_if,
-							      module_params.
-							      dev_nperio_tx_fifo_size);
+							      module_params.dev_nperio_tx_fifo_size);
 	}
 	if (module_params.host_rx_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_host_rx_fifo_size(core_if,
-							module_params.host_rx_fifo_size);
+							module_params.
+							host_rx_fifo_size);
 	}
 	if (module_params.host_nperio_tx_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_host_nperio_tx_fifo_size(core_if,
-							       module_params.
-							       host_nperio_tx_fifo_size);
+							       module_params.host_nperio_tx_fifo_size);
 	}
 	if (module_params.host_perio_tx_fifo_size != -1) {
 		retval +=
 		    dwc_otg_set_param_host_perio_tx_fifo_size(core_if,
-							      module_params.
-							      host_perio_tx_fifo_size);
+							      module_params.host_perio_tx_fifo_size);
 	}
 	if (module_params.max_transfer_size != -1) {
 		retval +=
 		    dwc_otg_set_param_max_transfer_size(core_if,
-							module_params.
-							max_transfer_size);
+							module_params.max_transfer_size);
 	}
 	if (module_params.max_packet_count != -1) {
 		retval +=
 		    dwc_otg_set_param_max_packet_count(core_if,
-						       module_params.
-						       max_packet_count);
+						       module_params.max_packet_count);
 	}
 	if (module_params.host_channels != -1) {
 		retval +=
 		    dwc_otg_set_param_host_channels(core_if,
-						    module_params.
-						    host_channels);
+						    module_params.host_channels);
 	}
 	if (module_params.dev_endpoints != -1) {
 		retval +=
 		    dwc_otg_set_param_dev_endpoints(core_if,
-						    module_params.
-						    dev_endpoints);
+						    module_params.dev_endpoints);
 	}
 	if (module_params.phy_type != -1) {
 		retval +=
-		    dwc_otg_set_param_phy_type(core_if,
-					       module_params.phy_type);
+		    dwc_otg_set_param_phy_type(core_if, module_params.phy_type);
 	}
 	if (module_params.speed != -1) {
-		retval +=
-		    dwc_otg_set_param_speed(core_if,
-					    module_params.speed);
+		retval += dwc_otg_set_param_speed(core_if, module_params.speed);
 	}
 	if (module_params.host_ls_low_power_phy_clk != -1) {
 		retval +=
 		    dwc_otg_set_param_host_ls_low_power_phy_clk(core_if,
-								module_params.
-								host_ls_low_power_phy_clk);
+								module_params.host_ls_low_power_phy_clk);
 	}
 	if (module_params.phy_ulpi_ddr != -1) {
 		retval +=
 		    dwc_otg_set_param_phy_ulpi_ddr(core_if,
-						   module_params.
-						   phy_ulpi_ddr);
+						   module_params.phy_ulpi_ddr);
 	}
 	if (module_params.phy_ulpi_ext_vbus != -1) {
 		retval +=
 		    dwc_otg_set_param_phy_ulpi_ext_vbus(core_if,
-							module_params.
-							phy_ulpi_ext_vbus);
+							module_params.phy_ulpi_ext_vbus);
 	}
 	if (module_params.phy_utmi_width != -1) {
 		retval +=
 		    dwc_otg_set_param_phy_utmi_width(core_if,
-						     module_params.
-						     phy_utmi_width);
+						     module_params.phy_utmi_width);
 	}
 	if (module_params.ulpi_fs_ls != -1) {
 		retval +=
@@ -724,27 +706,23 @@ static int set_parameters(dwc_otg_core_if_t * core_if, struct dwc_otg_driver_mod
 	}
 	if (module_params.ts_dline != -1) {
 		retval +=
-		    dwc_otg_set_param_ts_dline(core_if,
-					       module_params.ts_dline);
+		    dwc_otg_set_param_ts_dline(core_if, module_params.ts_dline);
 	}
 	if (module_params.i2c_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_i2c_enable(core_if,
-						 module_params.
-						 i2c_enable);
+						 module_params.i2c_enable);
 	}
 	if (module_params.en_multiple_tx_fifo != -1) {
 		retval +=
 		    dwc_otg_set_param_en_multiple_tx_fifo(core_if,
-							  module_params.
-							  en_multiple_tx_fifo);
+							  module_params.en_multiple_tx_fifo);
 	}
 	for (i = 0; i < 15; i++) {
 		if (module_params.dev_perio_tx_fifo_size[i] != -1) {
 			retval +=
 			    dwc_otg_set_param_dev_perio_tx_fifo_size(core_if,
-								     module_params.
-								     dev_perio_tx_fifo_size
+								     module_params.dev_perio_tx_fifo_size
 								     [i], i);
 		}
 	}
@@ -752,73 +730,65 @@ static int set_parameters(dwc_otg_core_if_t * core_if, struct dwc_otg_driver_mod
 	for (i = 0; i < 15; i++) {
 		if (module_params.dev_tx_fifo_size[i] != -1) {
 			retval += dwc_otg_set_param_dev_tx_fifo_size(core_if,
-								     module_params.
-								     dev_tx_fifo_size
+								     module_params.dev_tx_fifo_size
 								     [i], i);
 		}
 	}
 	if (module_params.thr_ctl != -1) {
 		retval +=
-		    dwc_otg_set_param_thr_ctl(core_if,
-					      module_params.thr_ctl);
+		    dwc_otg_set_param_thr_ctl(core_if, module_params.thr_ctl);
 	}
 	if (module_params.mpi_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_mpi_enable(core_if,
-						 module_params.
-						 mpi_enable);
+						 module_params.mpi_enable);
 	}
 	if (module_params.pti_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_pti_enable(core_if,
-						 module_params.
-						 pti_enable);
+						 module_params.pti_enable);
 	}
 	if (module_params.lpm_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_lpm_enable(core_if,
-						 module_params.
-						 lpm_enable);
-	}	
+						 module_params.lpm_enable);
+	}
 	if (module_params.besl_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_besl_enable(core_if,
-						 module_params.
-						 besl_enable);
+						  module_params.besl_enable);
 	}
 	if (module_params.baseline_besl != -1) {
 		retval +=
 		    dwc_otg_set_param_baseline_besl(core_if,
-						 module_params.
-						 baseline_besl);
+						    module_params.baseline_besl);
 	}
 	if (module_params.deep_besl != -1) {
 		retval +=
 		    dwc_otg_set_param_deep_besl(core_if,
-						 module_params.
-						 deep_besl);
-	}		
+						module_params.deep_besl);
+	}
 	if (module_params.ic_usb_cap != -1) {
 		retval +=
 		    dwc_otg_set_param_ic_usb_cap(core_if,
-						 module_params.
-						 ic_usb_cap);
+						 module_params.ic_usb_cap);
 	}
 	if (module_params.tx_thr_length != -1) {
 		retval +=
 		    dwc_otg_set_param_tx_thr_length(core_if,
-						    module_params.tx_thr_length);
+						    module_params.
+						    tx_thr_length);
 	}
 	if (module_params.rx_thr_length != -1) {
 		retval +=
 		    dwc_otg_set_param_rx_thr_length(core_if,
-						    module_params.
-						    rx_thr_length);
+						    module_params.rx_thr_length);
 	}
 	if (module_params.ahb_thr_ratio != -1) {
 		retval +=
 		    dwc_otg_set_param_ahb_thr_ratio(core_if,
-						    module_params.ahb_thr_ratio);
+						    module_params.
+						    ahb_thr_ratio);
 	}
 	if (module_params.power_down != -1) {
 		retval +=
@@ -833,32 +803,30 @@ static int set_parameters(dwc_otg_core_if_t * core_if, struct dwc_otg_driver_mod
 
 	if (module_params.dev_out_nak != -1) {
 		retval +=
-			dwc_otg_set_param_dev_out_nak(core_if,
-			module_params.dev_out_nak);
+		    dwc_otg_set_param_dev_out_nak(core_if,
+						  module_params.dev_out_nak);
 	}
 
 	if (module_params.cont_on_bna != -1) {
 		retval +=
-			dwc_otg_set_param_cont_on_bna(core_if,
-			module_params.cont_on_bna);
+		    dwc_otg_set_param_cont_on_bna(core_if,
+						  module_params.cont_on_bna);
 	}
 
 	if (module_params.ahb_single != -1) {
 		retval +=
-			dwc_otg_set_param_ahb_single(core_if,
-			module_params.ahb_single);
+		    dwc_otg_set_param_ahb_single(core_if,
+						 module_params.ahb_single);
 	}
 
 	if (module_params.otg_ver != -1) {
 		retval +=
-		    dwc_otg_set_param_otg_ver(core_if,
-					      module_params.otg_ver);
+		    dwc_otg_set_param_otg_ver(core_if, module_params.otg_ver);
 	}
 	if (module_params.adp_enable != -1) {
 		retval +=
 		    dwc_otg_set_param_adp_enable(core_if,
-						 module_params.
-						 adp_enable);
+						 module_params.adp_enable);
 	}
 	return retval;
 }
@@ -873,7 +841,7 @@ static irqreturn_t dwc_otg_common_irq(int irq, void *dev)
 
 	retval = dwc_otg_handle_common_intr(dev);
 	if (retval != 0) {
-		//S3C2410X_CLEAR_EINTPEND();
+		/* S3C2410X_CLEAR_EINTPEND(); */
 	}
 	return IRQ_RETVAL(retval);
 }
@@ -888,7 +856,7 @@ static irqreturn_t dwc_otg_common_irq(int irq, void *dev)
  *
  * @param _dev
  */
-static int host20_driver_remove( struct platform_device *_dev )
+static int host20_driver_remove(struct platform_device *_dev)
 {
 
 	dwc_otg_device_t *otg_dev = dwc_get_device_platform_data(_dev);
@@ -899,7 +867,6 @@ static int host20_driver_remove( struct platform_device *_dev )
 		DWC_DEBUGPL(DBG_ANY, "%s: otg_dev NULL!\n", __func__);
 		return 0;
 	}
-
 #ifndef DWC_DEVICE_ONLY
 	if (otg_dev->hcd) {
 		hcd_remove(_dev);
@@ -922,10 +889,11 @@ static int host20_driver_remove( struct platform_device *_dev )
 	 * Free the IRQ
 	 */
 	if (otg_dev->common_irq_installed) {
-		//free_irq(_dev->irq, otg_dev);
-		free_irq(platform_get_irq(_dev,0), otg_dev );
+		/* free_irq(_dev->irq, otg_dev); */
+		free_irq(platform_get_irq(_dev, 0), otg_dev);
 	} else {
-		DWC_DEBUGPL(DBG_ANY, "%s: There is no installed irq!\n", __func__);
+		DWC_DEBUGPL(DBG_ANY, "%s: There is no installed irq!\n",
+			    __func__);
 		return 0;
 	}
 
@@ -960,15 +928,16 @@ static int host20_driver_remove( struct platform_device *_dev )
 
 static const struct of_device_id usb20_host_of_match[] = {
 	{
-		.compatible = "rockchip,rk3188_usb20_host", 
-		.data = &usb20host_pdata[RK3188_USB_CTLR],
-	},
+	 .compatible = "rockchip,rk3188_usb20_host",
+	 .data = &usb20host_pdata[RK3188_USB_CTLR],
+	 },
 	{
-		.compatible = "rockchip,rk3288_usb20_host",
-		.data = &usb20host_pdata[RK3288_USB_CTLR],
-	},
-	{ },
+	 .compatible = "rockchip,rk3288_usb20_host",
+	 .data = &usb20host_pdata[RK3288_USB_CTLR],
+	 },
+	{},
 };
+
 MODULE_DEVICE_TABLE(of, usb20_host_of_match);
 
 /**
@@ -988,16 +957,16 @@ static int host20_driver_probe(struct platform_device *_dev)
 	int irq;
 	struct resource *res_base;
 	dwc_otg_device_t *dwc_otg_device;
-	struct device           *dev = &_dev->dev;
-	struct device_node      *node = _dev->dev.of_node;
+	struct device *dev = &_dev->dev;
+	struct device_node *node = _dev->dev.of_node;
 	struct dwc_otg_platform_data *pldata;
 	struct usb20host_pdata_id *p;
 	const struct of_device_id *match =
-		of_match_device(of_match_ptr( usb20_host_of_match ), &_dev->dev);
+	    of_match_device(of_match_ptr(usb20_host_of_match), &_dev->dev);
 
-	if (match){
+	if (match) {
 		p = (struct usb20host_pdata_id *)match->data;
-	}else{
+	} else {
 		dev_err(dev, "usb20host match failed\n");
 		return -EINVAL;
 	}
@@ -1011,21 +980,21 @@ static int host20_driver_probe(struct platform_device *_dev)
 		return -EINVAL;
 	}
 
-	if(pldata->hw_init)
+	if (pldata->hw_init)
 		pldata->hw_init();
 
-	if(pldata->clock_init){
+	if (pldata->clock_init) {
 		pldata->clock_init(pldata);
 		pldata->clock_enable(pldata, 1);
 	}
 
-	if(pldata->phy_suspend)
+	if (pldata->phy_suspend)
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 
-	if(pldata->soft_reset)
+	if (pldata->soft_reset)
 		pldata->soft_reset();
 
-	res_base=platform_get_resource(_dev, IORESOURCE_MEM, 0);
+	res_base = platform_get_resource(_dev, IORESOURCE_MEM, 0);
 
 	dwc_otg_device = DWC_ALLOC(sizeof(dwc_otg_device_t));
 
@@ -1043,7 +1012,7 @@ static int host20_driver_probe(struct platform_device *_dev)
 	 */
 
 	dwc_otg_device->os_dep.base = devm_ioremap_resource(dev, res_base);
-    
+
 	if (!dwc_otg_device->os_dep.base) {
 		dev_err(&_dev->dev, "ioremap() failed\n");
 		DWC_FREE(dwc_otg_device);
@@ -1066,14 +1035,13 @@ static int host20_driver_probe(struct platform_device *_dev)
 
 	dwc_otg_device->core_if = dwc_otg_cil_init(dwc_otg_device->os_dep.base);
 
-	
 	if (!dwc_otg_device->core_if) {
 		dev_err(&_dev->dev, "CIL initialization failed!\n");
 		retval = -ENOMEM;
 		goto fail;
 	}
 
-	dwc_otg_device->core_if->otg_dev= dwc_otg_device;
+	dwc_otg_device->core_if->otg_dev = dwc_otg_device;
 
 	/*
 	 * Attempt to ensure this device is really a DWC_otg Controller.
@@ -1082,8 +1050,10 @@ static int host20_driver_probe(struct platform_device *_dev)
 	 * as in "OTG version 2.XX" or "OTG version 3.XX".
 	 */
 
-	if (((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=	0x4F542000) &&
-		((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) != 0x4F543000)) {
+	if (((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=
+	     0x4F542000)
+	    && ((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=
+		0x4F543000)) {
 		dev_err(&_dev->dev, "Bad value for SNPSID: 0x%08x\n",
 			dwc_otg_get_gsnpsid(dwc_otg_device->core_if));
 		retval = -EINVAL;
@@ -1093,11 +1063,11 @@ static int host20_driver_probe(struct platform_device *_dev)
 	/*
 	 * Validate parameter values.
 	 */
-	if (set_parameters(dwc_otg_device->core_if ,dwc_host_module_params )) {
+	if (set_parameters(dwc_otg_device->core_if, dwc_host_module_params)) {
 		retval = -EINVAL;
 		goto fail;
 	}
-	
+
 	/*
 	 * Create Device Attributes in sysfs
 	 */
@@ -1113,12 +1083,10 @@ static int host20_driver_probe(struct platform_device *_dev)
 	 * Install the interrupt handler for the common interrupts before
 	 * enabling common interrupts in core_init below.
 	 */
-	irq = platform_get_irq(_dev,0);
-	DWC_DEBUGPL(DBG_CIL, "registering (common) handler for irq%d\n",
-		    irq);
+	irq = platform_get_irq(_dev, 0);
+	DWC_DEBUGPL(DBG_CIL, "registering (common) handler for irq%d\n", irq);
 	retval = request_irq(irq, dwc_otg_common_irq,
-			     IRQF_SHARED , "dwc_otg",
-			     dwc_otg_device);
+			     IRQF_SHARED, "dwc_otg", dwc_otg_device);
 	if (retval) {
 		DWC_ERROR("request of irq%d failed\n", irq);
 		retval = -EBUSY;
@@ -1133,7 +1101,7 @@ static int host20_driver_probe(struct platform_device *_dev)
 	 * we do core soft reset after connection detected.
 	 */
 	dwc_otg_core_init_no_reset(dwc_otg_device->core_if);
-		
+
 	/*
 	 * Initialize the HCD
 	 */
@@ -1147,71 +1115,68 @@ static int host20_driver_probe(struct platform_device *_dev)
 	clk_set_rate(pldata->phyclk_480m, 480000000);
 	/*
 	 * Enable the global interrupt after all the interrupt
-	 * handlers are installed if there is no ADP support else 
+	 * handlers are installed if there is no ADP support else
 	 * perform initial actions required for Internal ADP logic.
 	 */
-	if (!dwc_otg_get_param_adp_enable(dwc_otg_device->core_if))	{
-		if( pldata->phy_status == USB_PHY_ENABLED ){
+	if (!dwc_otg_get_param_adp_enable(dwc_otg_device->core_if)) {
+		if (pldata->phy_status == USB_PHY_ENABLED) {
 			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 			udelay(3);
-			pldata->clock_enable( pldata, 0);
+			pldata->clock_enable(pldata, 0);
 		}
-//		dwc_otg_enable_global_interrupts(dwc_otg_device->core_if);
-	}
-	else
-		dwc_otg_adp_start(dwc_otg_device->core_if, 
-							dwc_otg_is_host_mode(dwc_otg_device->core_if));
+		/* dwc_otg_enable_global_interrupts(dwc_otg_device->core_if); */
+	} else
+		dwc_otg_adp_start(dwc_otg_device->core_if,
+				  dwc_otg_is_host_mode(dwc_otg_device->
+						       core_if));
 
 	return 0;
 
 fail:
 	host20_driver_remove(_dev);
 clk_disable:
-	if(pldata->clock_enable)
+	if (pldata->clock_enable)
 		pldata->clock_enable(pldata, 0);
 
 	return retval;
 }
 #endif
 
-static int dwc_otg_driver_suspend(struct platform_device *_dev , pm_message_t state )
+static int dwc_otg_driver_suspend(struct platform_device *_dev,
+				  pm_message_t state)
 {
-    return 0;
+	return 0;
 }
 
-static int dwc_otg_driver_resume(struct platform_device *_dev )
+static int dwc_otg_driver_resume(struct platform_device *_dev)
 {
-    return 0;
+	return 0;
 }
 
-static void dwc_otg_driver_shutdown(struct platform_device *_dev )
+static void dwc_otg_driver_shutdown(struct platform_device *_dev)
 {
 	struct device *dev = &_dev->dev;
 	dwc_otg_device_t *otg_dev = dev->platform_data;
-    dwc_otg_core_if_t *core_if = otg_dev->core_if;
-    dctl_data_t dctl = {.d32=0};
-
-    DWC_PRINTF("%s: disconnect USB %s mode\n" , __func__ ,
-        dwc_otg_is_host_mode(core_if) ? "host" : "device");
-    if(dwc_otg_is_host_mode(core_if))
-    {
-        if (core_if->hcd_cb && core_if->hcd_cb->stop)
-        {
-        	core_if->hcd_cb->stop( core_if->hcd_cb_p);
-        }
-    }
-    else
-    {
-        /* soft disconnect */
-        dctl.d32 = DWC_READ_REG32( &core_if->dev_if->dev_global_regs->dctl );
-        dctl.b.sftdiscon = 1;
-        DWC_WRITE_REG32( &core_if->dev_if->dev_global_regs->dctl, dctl.d32 );
-    }
-    /* Clear any pending interrupts */
-    DWC_WRITE_REG32( &core_if->core_global_regs->gintsts, 0xFFFFFFFF); 
+	dwc_otg_core_if_t *core_if = otg_dev->core_if;
+	dctl_data_t dctl = {.d32 = 0 };
 
-}
+	DWC_PRINTF("%s: disconnect USB %s mode\n", __func__,
+		   dwc_otg_is_host_mode(core_if) ? "host" : "device");
+	if (dwc_otg_is_host_mode(core_if)) {
+		if (core_if->hcd_cb && core_if->hcd_cb->stop)
+			core_if->hcd_cb->stop(core_if->hcd_cb_p);
+	} else {
+		/* soft disconnect */
+		dctl.d32 =
+		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
+		dctl.b.sftdiscon = 1;
+		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				dctl.d32);
+	}
+	/* Clear any pending interrupts */
+	DWC_WRITE_REG32(&core_if->core_global_regs->gintsts, 0xFFFFFFFF);
 
+}
 
 /**
  * This structure defines the methods to be called by a bus driver
@@ -1227,9 +1192,9 @@ static void dwc_otg_driver_shutdown(struct platform_device *_dev )
 #ifdef CONFIG_USB20_HOST
 static struct platform_driver dwc_host_driver = {
 	.driver = {
-		.name = (char *)dwc_host20_driver_name,
-		.of_match_table = of_match_ptr(usb20_host_of_match),
-	},
+		   .name = (char *)dwc_host20_driver_name,
+		   .of_match_table = of_match_ptr(usb20_host_of_match),
+		   },
 	.probe = host20_driver_probe,
 	.remove = host20_driver_remove,
 	.suspend = dwc_otg_driver_suspend,
@@ -1247,7 +1212,7 @@ static struct platform_driver dwc_host_driver = {
  *
  * @param _dev
  */
-static int otg20_driver_remove( struct platform_device *_dev )
+static int otg20_driver_remove(struct platform_device *_dev)
 {
 
 	dwc_otg_device_t *otg_dev = dwc_get_device_platform_data(_dev);
@@ -1279,10 +1244,11 @@ static int otg20_driver_remove( struct platform_device *_dev )
 	 * Free the IRQ
 	 */
 	if (otg_dev->common_irq_installed) {
-		//free_irq(_dev->irq, otg_dev);
-		free_irq(platform_get_irq(_dev,0), otg_dev );
+		/* free_irq(_dev->irq, otg_dev); */
+		free_irq(platform_get_irq(_dev, 0), otg_dev);
 	} else {
-		DWC_DEBUGPL(DBG_ANY, "%s: There is no installed irq!\n", __func__);
+		DWC_DEBUGPL(DBG_ANY, "%s: There is no installed irq!\n",
+			    __func__);
 		return 0;
 	}
 
@@ -1301,9 +1267,8 @@ static int otg20_driver_remove( struct platform_device *_dev )
 	/*
 	 * Return the memory.
 	 */
-	if (otg_dev->os_dep.base) {
+	if (otg_dev->os_dep.base)
 		iounmap(otg_dev->os_dep.base);
-	}
 	DWC_FREE(otg_dev);
 
 	/*
@@ -1317,16 +1282,17 @@ static int otg20_driver_remove( struct platform_device *_dev )
 
 static const struct of_device_id usb20_otg_of_match[] = {
 	{
-		.compatible = "rockchip,rk3188_usb20_otg",
-		.data = &usb20otg_pdata[RK3188_USB_CTLR],
-	},
+	 .compatible = "rockchip,rk3188_usb20_otg",
+	 .data = &usb20otg_pdata[RK3188_USB_CTLR],
+	 },
 	{
-		.compatible = "rockchip,rk3288_usb20_otg",
-		.data = &usb20otg_pdata[RK3288_USB_CTLR],
-	},
+	 .compatible = "rockchip,rk3288_usb20_otg",
+	 .data = &usb20otg_pdata[RK3288_USB_CTLR],
+	 },
 	{
-	},
+	 },
 };
+
 MODULE_DEVICE_TABLE(of, usb20_otg_of_match);
 
 /**
@@ -1347,60 +1313,60 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	uint32_t val;
 	struct resource *res_base;
 	dwc_otg_device_t *dwc_otg_device;
-	struct device 		*dev = &_dev->dev;
-	struct device_node      *node = _dev->dev.of_node;
+	struct device *dev = &_dev->dev;
+	struct device_node *node = _dev->dev.of_node;
 	struct dwc_otg_platform_data *pldata;
 	struct usb20otg_pdata_id *p;
 	const struct of_device_id *match =
-		of_match_device(of_match_ptr( usb20_otg_of_match ), &_dev->dev);
+	    of_match_device(of_match_ptr(usb20_otg_of_match), &_dev->dev);
 
-	if (match){
+	if (match) {
 		p = (struct usb20otg_pdata_id *)match->data;
-	}else{
+	} else {
 		dev_err(dev, "usb20otg match failed\n");
 		return -EINVAL;
 	}
 
 	dev->platform_data = p->pdata;
-//	dev->platform_data = &usb20otg_pdata;
-	pldata =  dev->platform_data;
+	/* dev->platform_data = &usb20otg_pdata; */
+	pldata = dev->platform_data;
 	pldata->dev = dev;
 
 	if (!node) {
 		dev_err(dev, "device node not found\n");
 		return -EINVAL;
 	}
-	/*todo : move to usbdev_rk-XX.c*/
-	if(pldata->hw_init)
+	/*todo : move to usbdev_rk-XX.c */
+	if (pldata->hw_init)
 		pldata->hw_init();
-        
-	if(pldata->clock_init){
+
+	if (pldata->clock_init) {
 		pldata->clock_init(pldata);
 		pldata->clock_enable(pldata, 1);
 	}
 
-	if(pldata->phy_suspend)
+	if (pldata->phy_suspend)
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 
-	if(pldata->dwc_otg_uart_mode)
+	if (pldata->dwc_otg_uart_mode)
 		pldata->dwc_otg_uart_mode(pldata, PHY_USB_MODE);
 
 	/* do reset later, because reset need about
 	 * 100ms to ensure otg id state change.
 	 */
 	/*
-	if(pldata->soft_reset)
-		pldata->soft_reset();
-	*/
-	/*end todo*/
+	   if(pldata->soft_reset)
+	   pldata->soft_reset();
+	 */
+	/*end todo */
 
-	res_base=platform_get_resource(_dev, IORESOURCE_MEM, 0);
+	res_base = platform_get_resource(_dev, IORESOURCE_MEM, 0);
 
 	dwc_otg_device = DWC_ALLOC(sizeof(dwc_otg_device_t));
 
 	if (!dwc_otg_device) {
 		dev_err(&_dev->dev, "kmalloc of dwc_otg_device failed\n");
-		retval = -ENOMEM;	
+		retval = -ENOMEM;
 		goto clk_disable;
 	}
 
@@ -1428,7 +1394,7 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	 */
 
 	g_otgdev = dwc_otg_device;
-	pldata->privdata =  dwc_otg_device;
+	pldata->privdata = dwc_otg_device;
 	dwc_otg_device->pldata = pldata;
 
 	dwc_set_device_platform_data(_dev, dwc_otg_device);
@@ -1441,7 +1407,7 @@ static int otg20_driver_probe(struct platform_device *_dev)
 		retval = -ENOMEM;
 		goto fail;
 	}
-	
+
 	dwc_otg_device->core_if->otg_dev = dwc_otg_device;
 	/*
 	 * Attempt to ensure this device is really a DWC_otg Controller.
@@ -1450,8 +1416,10 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	 * as in "OTG version 2.XX" or "OTG version 3.XX".
 	 */
 
-	if (((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=	0x4F542000) &&
-		((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) != 0x4F543000)) {
+	if (((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=
+	     0x4F542000)
+	    && ((dwc_otg_get_gsnpsid(dwc_otg_device->core_if) & 0xFFFFF000) !=
+		0x4F543000)) {
 		dev_err(&_dev->dev, "Bad value for SNPSID: 0x%08x\n",
 			dwc_otg_get_gsnpsid(dwc_otg_device->core_if));
 		retval = -EINVAL;
@@ -1461,11 +1429,11 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	/*
 	 * Validate parameter values.
 	 */
-	if (set_parameters(dwc_otg_device->core_if ,dwc_otg_module_params)) {
+	if (set_parameters(dwc_otg_device->core_if, dwc_otg_module_params)) {
 		retval = -EINVAL;
 		goto fail;
 	}
-	
+
 	/*
 	 * Create Device Attributes in sysfs
 	 */
@@ -1481,12 +1449,10 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	 * Install the interrupt handler for the common interrupts before
 	 * enabling common interrupts in core_init below.
 	 */
-	irq = platform_get_irq(_dev,0);
-	DWC_DEBUGPL(DBG_CIL, "registering (common) handler for irq%d\n",
-		    irq);
+	irq = platform_get_irq(_dev, 0);
+	DWC_DEBUGPL(DBG_CIL, "registering (common) handler for irq%d\n", irq);
 	retval = request_irq(irq, dwc_otg_common_irq,
-			     IRQF_SHARED , "dwc_otg",
-			     dwc_otg_device);
+			     IRQF_SHARED, "dwc_otg", dwc_otg_device);
 	if (retval) {
 		DWC_ERROR("request of irq%d failed\n", irq);
 		retval = -EBUSY;
@@ -1519,7 +1485,7 @@ static int otg20_driver_probe(struct platform_device *_dev)
 		DWC_ERROR("pcd_init failed\n");
 		dwc_otg_device->pcd = NULL;
 		goto fail;
-	}	
+	}
 #endif
 #ifndef DWC_DEVICE_ONLY
 	/*
@@ -1534,20 +1500,20 @@ static int otg20_driver_probe(struct platform_device *_dev)
 #endif
 	/*
 	 * Enable the global interrupt after all the interrupt
-	 * handlers are installed if there is no ADP support else 
+	 * handlers are installed if there is no ADP support else
 	 * perform initial actions required for Internal ADP logic.
 	 */
-	if (!dwc_otg_get_param_adp_enable(dwc_otg_device->core_if)){
-		if( pldata->phy_status == USB_PHY_ENABLED ){
+	if (!dwc_otg_get_param_adp_enable(dwc_otg_device->core_if)) {
+		if (pldata->phy_status == USB_PHY_ENABLED) {
 			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 			udelay(3);
-			pldata->clock_enable( pldata, 0);
+			pldata->clock_enable(pldata, 0);
 		}
-//		dwc_otg_enable_global_interrupts(dwc_otg_device->core_if);
-	}
-	else
-		dwc_otg_adp_start(dwc_otg_device->core_if, 
-							dwc_otg_is_host_mode(dwc_otg_device->core_if));
+		/* dwc_otg_enable_global_interrupts(dwc_otg_device->core_if); */
+	} else
+		dwc_otg_adp_start(dwc_otg_device->core_if,
+				  dwc_otg_is_host_mode(dwc_otg_device->
+						       core_if));
 
 	return 0;
 
@@ -1555,7 +1521,7 @@ static int otg20_driver_probe(struct platform_device *_dev)
 	otg20_driver_remove(_dev);
 
 clk_disable:
-	if(pldata->clock_enable)
+	if (pldata->clock_enable)
 		pldata->clock_enable(pldata, 0);
 
 	return retval;
@@ -1563,9 +1529,9 @@ static int otg20_driver_probe(struct platform_device *_dev)
 
 static struct platform_driver dwc_otg_driver = {
 	.driver = {
-		.name = (char *)dwc_otg20_driver_name,
-		.of_match_table = of_match_ptr(usb20_otg_of_match),
-	},
+		   .name = (char *)dwc_otg20_driver_name,
+		   .of_match_table = of_match_ptr(usb20_otg_of_match),
+		   },
 	.probe = otg20_driver_probe,
 	.remove = otg20_driver_remove,
 	.suspend = dwc_otg_driver_suspend,
@@ -1580,29 +1546,39 @@ void rk_usb_power_up(void)
 	struct dwc_otg_platform_data *pldata_host;
 	struct rkehci_platform_data *pldata_ehci;
 
-	if(cpu_is_rk3288()){
+	if (cpu_is_rk3288()) {
 #ifdef CONFIG_RK_USB_UART
 		/* enable USB bypass UART function  */
-		writel_relaxed(0x00c00000 | usb_to_uart_status, RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
+		writel_relaxed(0x00c00000 | usb_to_uart_status,
+			       RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
 
 #endif
 		/* unset siddq,the analog blocks are powered up */
 #ifdef CONFIG_USB20_OTG
-		if((pldata_otg = &usb20otg_pdata_rk3288)){
-			if(pldata_otg->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)<<16, RK_GRF_VIRT + RK3288_GRF_UOC0_CON0);
+		pldata_otg = &usb20otg_pdata_rk3288;
+		if (pldata_otg) {
+			if (pldata_otg->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) << 16,
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC0_CON0);
 		}
 #endif
 #ifdef CONFIG_USB20_HOST
-		if((pldata_host = &usb20host_pdata_rk3288)){
-			if(pldata_host->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)<<16, RK_GRF_VIRT + RK3288_GRF_UOC2_CON0);
+		pldata_host = &usb20host_pdata_rk3288;
+		if (pldata_host) {
+			if (pldata_host->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) << 16,
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC2_CON0);
 		}
 #endif
 #ifdef CONFIG_USB_EHCI_RK
-		if((pldata_ehci = &rkehci_pdata_rk3288)){
-			if(pldata_ehci->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)<<16, RK_GRF_VIRT + RK3288_GRF_UOC1_CON0);
+		pldata_ehci = &rkehci_pdata_rk3288;
+		if (pldata_ehci) {
+			if (pldata_ehci->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) << 16,
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC1_CON0);
 		}
 #endif
 
@@ -1615,10 +1591,11 @@ void rk_usb_power_down(void)
 	struct dwc_otg_platform_data *pldata_host;
 	struct rkehci_platform_data *pldata_ehci;
 
-	if(cpu_is_rk3288()){
+	if (cpu_is_rk3288()) {
 #ifdef CONFIG_RK_USB_UART
 		/* disable USB bypass UART function */
-		usb_to_uart_status = readl_relaxed(RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
+		usb_to_uart_status =
+		    readl_relaxed(RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
 		writel_relaxed(0x00c00000, RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
 #endif
 		/* set siddq,the analog blocks are powered down
@@ -1628,21 +1605,33 @@ void rk_usb_power_down(void)
 		 * and TESTBURNIN are set to 1'b0.
 		 * 2. Before asserting SIDDQ, ensure that phy enter suspend.*/
 #ifdef CONFIG_USB20_OTG
-		if((pldata_otg = &usb20otg_pdata_rk3288)){
-			if(pldata_otg->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)|((0x01<<13)<<16), RK_GRF_VIRT + RK3288_GRF_UOC0_CON0);
+		pldata_otg = &usb20otg_pdata_rk3288;
+		if (pldata_otg) {
+			if (pldata_otg->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) |
+					       ((0x01 << 13) << 16),
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC0_CON0);
 		}
 #endif
 #ifdef CONFIG_USB20_HOST
-		if((pldata_host = &usb20host_pdata_rk3288)){
-			if(pldata_host->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)|((0x01<<13)<<16), RK_GRF_VIRT + RK3288_GRF_UOC2_CON0);
+		pldata_host = &usb20host_pdata_rk3288;
+		if (pldata_host) {
+			if (pldata_host->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) |
+					       ((0x01 << 13) << 16),
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC2_CON0);
 		}
 #endif
 #ifdef CONFIG_USB_EHCI_RK
-		if((pldata_ehci = &rkehci_pdata_rk3288)){
-			if(pldata_ehci->phy_status == USB_PHY_SUSPEND)
-				writel_relaxed((0x01<<13)|((0x01<<13)<<16), RK_GRF_VIRT + RK3288_GRF_UOC1_CON0);
+		pldata_ehci = &rkehci_pdata_rk3288;
+		if (pldata_ehci) {
+			if (pldata_ehci->phy_status == USB_PHY_SUSPEND)
+				writel_relaxed((0x01 << 13) |
+					       ((0x01 << 13) << 16),
+					       RK_GRF_VIRT +
+					       RK3288_GRF_UOC1_CON0);
 		}
 #endif
 	}
@@ -1664,11 +1653,11 @@ static int __init dwc_otg_driver_init(void)
 {
 	int retval = 0;
 	int error;
-	
+
 #ifdef CONFIG_USB20_OTG
-	//register otg20
+	/* register otg20 */
 	printk(KERN_INFO "%s: version %s\n", dwc_otg20_driver_name,
-		   DWC_DRIVER_VERSION);
+	       DWC_DRIVER_VERSION);
 
 	retval = platform_driver_register(&dwc_otg_driver);
 	if (retval < 0) {
@@ -1676,15 +1665,23 @@ static int __init dwc_otg_driver_init(void)
 		return retval;
 	}
 
-	error = driver_create_file(&dwc_otg_driver.driver, &driver_attr_version);
-	error = driver_create_file(&dwc_otg_driver.driver, &driver_attr_debuglevel);
-	error = driver_create_file(&dwc_otg_driver.driver, &driver_attr_dwc_otg_conn_en);
-	error = driver_create_file(&dwc_otg_driver.driver, &driver_attr_vbus_status);
-	error = driver_create_file(&dwc_otg_driver.driver, &driver_attr_force_usb_mode);
-		
+	error =
+	    driver_create_file(&dwc_otg_driver.driver, &driver_attr_version);
+	error =
+	    driver_create_file(&dwc_otg_driver.driver, &driver_attr_debuglevel);
+	error =
+	    driver_create_file(&dwc_otg_driver.driver,
+			       &driver_attr_dwc_otg_conn_en);
+	error =
+	    driver_create_file(&dwc_otg_driver.driver,
+			       &driver_attr_vbus_status);
+	error =
+	    driver_create_file(&dwc_otg_driver.driver,
+			       &driver_attr_force_usb_mode);
+
 #endif
-	
-	//register host20
+
+	/* register host20 */
 #ifdef CONFIG_USB20_HOST
 	printk(KERN_INFO "%s: version %s\n", dwc_host20_driver_name,
 	       DWC_DRIVER_VERSION);
@@ -1695,8 +1692,11 @@ static int __init dwc_otg_driver_init(void)
 		return retval;
 	}
 
-	error = driver_create_file(&dwc_host_driver.driver, &driver_attr_version);
-	error = driver_create_file(&dwc_host_driver.driver, &driver_attr_debuglevel);
+	error =
+	    driver_create_file(&dwc_host_driver.driver, &driver_attr_version);
+	error =
+	    driver_create_file(&dwc_host_driver.driver,
+			       &driver_attr_debuglevel);
 #endif
 	return retval;
 }
@@ -1714,7 +1714,7 @@ static void __exit dwc_otg_driver_cleanup(void)
 	printk(KERN_DEBUG "dwc_otg_driver_cleanup()\n");
 
 #ifdef CONFIG_USB20_HOST
-	/*for host20*/
+	/*for host20 */
 	driver_remove_file(&dwc_host_driver.driver, &driver_attr_debuglevel);
 	driver_remove_file(&dwc_host_driver.driver, &driver_attr_version);
 	platform_driver_unregister(&dwc_host_driver);
@@ -1722,8 +1722,9 @@ static void __exit dwc_otg_driver_cleanup(void)
 #endif
 
 #ifdef CONFIG_USB20_OTG
-	/*for otg*/
-	driver_remove_file(&dwc_otg_driver.driver, &driver_attr_dwc_otg_conn_en);
+	/*for otg */
+	driver_remove_file(&dwc_otg_driver.driver,
+			   &driver_attr_dwc_otg_conn_en);
 	driver_remove_file(&dwc_otg_driver.driver, &driver_attr_debuglevel);
 	driver_remove_file(&dwc_otg_driver.driver, &driver_attr_version);
 	driver_remove_file(&dwc_otg_driver.driver, &driver_attr_vbus_status);
@@ -1956,7 +1957,8 @@ MODULE_PARM_DESC(lpm_enable, "LPM Enable 0=LPM Disabled 1=LPM Enabled");
 
 module_param_named(besl_enable, dwc_otg_module_params.besl_enable, int, 0444);
 MODULE_PARM_DESC(besl_enable, "BESL Enable 0=BESL Disabled 1=BESL Enabled");
-module_param_named(baseline_besl, dwc_otg_module_params.baseline_besl, int, 0444);
+module_param_named(baseline_besl, dwc_otg_module_params.baseline_besl, int,
+		   0444);
 MODULE_PARM_DESC(baseline_besl, "Set the baseline besl value");
 module_param_named(deep_besl, dwc_otg_module_params.deep_besl, int, 0444);
 MODULE_PARM_DESC(deep_besl, "Set the deep besl value");
@@ -2180,7 +2182,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  - 0: Disabled (default)
  - 1: Enabled
  </td></tr>
- 
+
  <tr>
  <td>en_multiple_tx_fifo</td>
  <td>Specifies whether dedicatedto tx fifos are enabled for non periodic IN EPs.
@@ -2211,7 +2213,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
 
 <tr>
  <td>thr_ctl</td>
- <td>Specifies whether to enable Thresholding for Device mode. Bits 0, 1, 2 of 
+ <td>Specifies whether to enable Thresholding for Device mode. Bits 0, 1, 2 of
  this parmater specifies if thresholding is enabled for non-Iso Tx, Iso Tx and
  Rx transfers accordingly.
  The driver will automatically detect the value for this parameter if none is
@@ -2257,22 +2259,22 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  - 0: LPM disabled
  - 1: LPM enable (default, if available)
  </td></tr>
-  
+
  <tr>
  <td>besl_enable</td>
  <td>Specifies whether to enable LPM Errata support.
  The driver will automatically detect the value for this parameter if none is
  specified.
  - 0: LPM Errata disabled (default)
- - 1: LPM Errata enable 
+ - 1: LPM Errata enable
  </td></tr>
- 
+
   <tr>
  <td>baseline_besl</td>
  <td>Specifies the baseline besl value.
  - Values: 0 to 15 (default 0)
  </td></tr>
- 
+
   <tr>
  <td>deep_besl</td>
  <td>Specifies the deep besl value.
@@ -2285,7 +2287,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  The driver will automatically detect the value for this parameter if none is
  specified.
  - 0: IC_USB disabled (default, if available)
- - 1: IC_USB enable 
+ - 1: IC_USB enable
  </td></tr>
 
 <tr>
@@ -2302,7 +2304,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  - 0: Power Down disabled (default)
  - 2: Power Down enabled
  </td></tr>
- 
+
  <tr>
  <td>reload_ctl</td>
  <td>Specifies whether dynamic reloading of the HFIR register is allowed during
@@ -2324,9 +2326,9 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
 
  <tr>
  <td>cont_on_bna</td>
- <td>Specifies whether Enable Continue on BNA enabled or no. 
+ <td>Specifies whether Enable Continue on BNA enabled or no.
  After receiving BNA interrupt the core disables the endpoint,when the
- endpoint is re-enabled by the application the  
+ endpoint is re-enabled by the application the
  - 0: Core starts processing from the DOEPDMA descriptor (default)
  - 1: Core starts processing from the descriptor which received the BNA.
  This parameter is valid only when OTG_EN_DESC_DMA == 1b1.
@@ -2335,7 +2337,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  <tr>
  <td>ahb_single</td>
  <td>This bit when programmed supports SINGLE transfers for remainder data
- in a transfer for DMA mode of operation. 
+ in a transfer for DMA mode of operation.
  - 0: The remainder data will be sent using INCR burst size (default)
  - 1: The remainder data will be sent using SINGLE burst size.
  </td></tr>
@@ -2354,7 +2356,7 @@ MODULE_PARM_DESC(otg_ver, "OTG revision supported 0=OTG 1.3 1=OTG 2.0");
  <td>Specifies whether OTG is performing as USB OTG Revision 2.0 or Revision 1.3
  USB OTG device.
  - 0: OTG 2.0 support disabled (default)
- - 1: OTG 2.0 support enabled 
+ - 1: OTG 2.0 support enabled
  </td></tr>
 
 */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_driver.h b/drivers/usb/dwc_otg_310/dwc_otg_driver.h
index cdbaf51d560e..0e4d9715cd58 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_driver.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_driver.h
@@ -7,7 +7,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -17,7 +17,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -71,8 +71,8 @@ typedef struct dwc_otg_device {
 
 } dwc_otg_device_t;
 
-/*We must clear S3C24XX_EINTPEND external interrupt register 
- * because after clearing in this register trigerred IRQ from 
+/*We must clear S3C24XX_EINTPEND external interrupt register
+ * because after clearing in this register trigerred IRQ from
  * H/W core in kernel interrupt can be occured again before OTG
  * handlers clear all IRQ sources of Core registers because of
  * timing latencies and Low Level IRQ Type.
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd.c b/drivers/usb/dwc_otg_310/dwc_otg_hcd.c
index 42c241440966..06fc33531e11 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd.c
@@ -44,7 +44,7 @@
 #include "usbdev_rk.h"
 #include "dwc_otg_driver.h"
 #include <linux/usb.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
 #include <../drivers/usb/core/hcd.h>
 #else
 #include <linux/usb/hcd.h>
@@ -72,7 +72,7 @@ void dwc_otg_hcd_connect_timeout(void *ptr)
 }
 
 #ifdef DEBUG
-static void dump_channel_info(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static void dump_channel_info(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	if (qh->channel != NULL) {
 		dwc_hc_t *hc = qh->channel;
@@ -143,7 +143,7 @@ static void hcd_start_func(void *_vp)
 	}
 }
 
-static void del_xfer_timers(dwc_otg_hcd_t * hcd)
+static void del_xfer_timers(dwc_otg_hcd_t *hcd)
 {
 #ifdef DEBUG
 	int i;
@@ -154,7 +154,7 @@ static void del_xfer_timers(dwc_otg_hcd_t * hcd)
 #endif
 }
 
-static void del_timers(dwc_otg_hcd_t * hcd)
+static void del_timers(dwc_otg_hcd_t *hcd)
 {
 	del_xfer_timers(hcd);
 	DWC_TIMER_CANCEL(hcd->conn_timer);
@@ -164,7 +164,7 @@ static void del_timers(dwc_otg_hcd_t * hcd)
  * Processes all the URBs in a single list of QHs. Completes them with
  * -ETIMEDOUT and frees the QTD.
  */
-static void kill_urbs_in_qh_list(dwc_otg_hcd_t * hcd, dwc_list_link_t * qh_list)
+static void kill_urbs_in_qh_list(dwc_otg_hcd_t *hcd, dwc_list_link_t *qh_list)
 {
 	dwc_list_link_t *qh_item;
 	dwc_otg_qh_t *qh;
@@ -191,7 +191,7 @@ static void kill_urbs_in_qh_list(dwc_otg_hcd_t * hcd, dwc_list_link_t * qh_list)
  * the schedule and freed. This function may be called when a disconnect is
  * detected or when the HCD is being stopped.
  */
-static void kill_all_urbs(dwc_otg_hcd_t * hcd)
+static void kill_all_urbs(dwc_otg_hcd_t *hcd)
 {
 	kill_urbs_in_qh_list(hcd, &hcd->non_periodic_sched_inactive);
 	kill_urbs_in_qh_list(hcd, &hcd->non_periodic_sched_active);
@@ -207,9 +207,9 @@ static void kill_all_urbs(dwc_otg_hcd_t * hcd)
  * timer is deleted if a port connect interrupt occurs before the
  * timer expires.
  */
-static void dwc_otg_hcd_start_connect_timer(dwc_otg_hcd_t * hcd)
+static void dwc_otg_hcd_start_connect_timer(dwc_otg_hcd_t *hcd)
 {
-	DWC_TIMER_SCHEDULE(hcd->conn_timer, 10000 /* 10 secs */ );
+	DWC_TIMER_SCHEDULE(hcd->conn_timer, 10000 /* 10 secs */);
 }
 
 /**
@@ -261,8 +261,8 @@ static int32_t dwc_otg_hcd_start_cb(void *p)
 	if (core_if->otg_ver)
 		timeout = 25;
 	DWC_WORKQ_SCHEDULE_DELAYED(core_if->wq_otg,
-				hcd_start_func, dwc_otg_hcd, timeout,
-				"start hcd");
+				   hcd_start_func, dwc_otg_hcd, timeout,
+				   "start hcd");
 
 	return 1;
 }
@@ -341,8 +341,8 @@ static int32_t dwc_otg_hcd_disconnect_cb(void *p)
 				if (DWC_CIRCLEQ_EMPTY_ENTRY
 				    (channel, hc_list_entry)) {
 					hc_regs =
-					    dwc_otg_hcd->core_if->
-					    host_if->hc_regs[i];
+					    dwc_otg_hcd->core_if->host_if->
+					    hc_regs[i];
 					hcchar.d32 =
 					    DWC_READ_REG32(&hc_regs->hcchar);
 					if (hcchar.b.chen) {
@@ -427,12 +427,12 @@ static int dwc_otg_hcd_sleep_cb(void *p)
  *
  * @param p void pointer to the <code>struct usb_hcd</code>
  */
-extern inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t * dwc_otg_hcd);
+extern inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t *dwc_otg_hcd);
 static int dwc_otg_hcd_rem_wakeup_cb(void *p)
 {
 	dwc_otg_hcd_t *dwc_otg_hcd = p;
 	struct usb_hcd *hcd = dwc_otg_hcd_to_hcd(dwc_otg_hcd);
-        
+
 	if (dwc_otg_hcd->core_if->lx_state == DWC_OTG_L2) {
 		dwc_otg_hcd->flags.b.port_suspend_change = 1;
 		usb_hcd_resume_root_hub(hcd);
@@ -449,11 +449,11 @@ static int dwc_otg_hcd_rem_wakeup_cb(void *p)
  * Halts the DWC_otg host mode operations in a clean manner. USB transfers are
  * stopped.
  */
-void dwc_otg_hcd_stop(dwc_otg_hcd_t * hcd)
+void dwc_otg_hcd_stop(dwc_otg_hcd_t *hcd)
 {
 	hprt0_data_t hprt0 = {.d32 = 0 };
 	struct dwc_otg_platform_data *pldata;
-    pldata = hcd->core_if->otg_dev->pldata;
+	pldata = hcd->core_if->otg_dev->pldata;
 
 	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD STOP\n");
 
@@ -471,15 +471,14 @@ void dwc_otg_hcd_stop(dwc_otg_hcd_t * hcd)
 	hprt0.b.prtpwr = 0;
 	DWC_WRITE_REG32(hcd->core_if->host_if->hprt0, hprt0.d32);
 
-	if(pldata->power_enable)
-	    pldata->power_enable(0);
+	if (pldata->power_enable)
+		pldata->power_enable(0);
 
-	
 	dwc_mdelay(1);
 }
 
-int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * hcd,
-			    dwc_otg_hcd_urb_t * dwc_otg_urb, void **ep_handle,
+int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t *hcd,
+			    dwc_otg_hcd_urb_t *dwc_otg_urb, void **ep_handle,
 			    int atomic_alloc)
 {
 	dwc_irqflags_t flags;
@@ -500,7 +499,8 @@ int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * hcd,
 	}
 
 	retval =
-	    dwc_otg_hcd_qtd_add(qtd, hcd, (dwc_otg_qh_t **) ep_handle, atomic_alloc);
+	    dwc_otg_hcd_qtd_add(qtd, hcd, (dwc_otg_qh_t **) ep_handle,
+				atomic_alloc);
 
 	DWC_SPINLOCK_IRQSAVE(hcd->lock, &flags);
 	if (retval < 0) {
@@ -508,7 +508,8 @@ int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * hcd,
 			  "Error status %d\n", retval);
 		dwc_otg_hcd_qtd_free(qtd);
 	}
-	intr_mask.d32 = DWC_READ_REG32(&hcd->core_if->core_global_regs->gintmsk);
+	intr_mask.d32 =
+	    DWC_READ_REG32(&hcd->core_if->core_global_regs->gintmsk);
 	if (!intr_mask.b.sofintr && retval == 0) {
 		dwc_otg_transaction_type_e tr_type;
 		if ((qtd->qh->ep_type == UE_BULK)
@@ -527,16 +528,16 @@ int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * hcd,
 	return retval;
 }
 
-int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t * hcd,
-			    dwc_otg_hcd_urb_t * dwc_otg_urb)
+int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t *hcd,
+			    dwc_otg_hcd_urb_t *dwc_otg_urb)
 {
 	dwc_otg_qh_t *qh;
 	dwc_otg_qtd_t *urb_qtd;
 
 	urb_qtd = dwc_otg_urb->qtd;
-	if(((uint32_t)urb_qtd&0xf0000000) == 0){
+	if (((uint32_t) urb_qtd & 0xf0000000) == 0) {
 		DWC_PRINTF("%s error: urb_qtd is %p dwc_otg_urb %p!!!\n",
-			  __func__, urb_qtd, dwc_otg_urb);
+			   __func__, urb_qtd, dwc_otg_urb);
 		return 0;
 	}
 	qh = urb_qtd->qh;
@@ -582,7 +583,7 @@ int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t * hcd,
 	return 0;
 }
 
-int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t * hcd, void *ep_handle,
+int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t *hcd, void *ep_handle,
 				 int retry)
 {
 	dwc_otg_qh_t *qh = (dwc_otg_qh_t *) ep_handle;
@@ -623,8 +624,8 @@ int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t * hcd, void *ep_handle,
 	return retval;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
-int dwc_otg_hcd_endpoint_reset(dwc_otg_hcd_t * hcd, void *ep_handle)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
+int dwc_otg_hcd_endpoint_reset(dwc_otg_hcd_t *hcd, void *ep_handle)
 {
 	int retval = 0;
 	dwc_otg_qh_t *qh = (dwc_otg_qh_t *) ep_handle;
@@ -672,7 +673,7 @@ static void reset_tasklet_func(void *data)
 	dwc_otg_hcd->flags.b.port_reset_change = 1;
 }
 
-static void qh_list_free(dwc_otg_hcd_t * hcd, dwc_list_link_t * qh_list)
+static void qh_list_free(dwc_otg_hcd_t *hcd, dwc_list_link_t *qh_list)
 {
 	dwc_list_link_t *item;
 	dwc_otg_qh_t *qh;
@@ -683,8 +684,8 @@ static void qh_list_free(dwc_otg_hcd_t * hcd, dwc_list_link_t * qh_list)
 		return;
 	}
 	/*
-	 * Hold spinlock here. Not needed in that case if bellow 
-	 * function is being called from ISR 
+	 * Hold spinlock here. Not needed in that case if bellow
+	 * function is being called from ISR
 	 */
 	DWC_SPINLOCK_IRQSAVE(hcd->lock, &flags);
 	/* Ensure there are no QTDs or URBs left. */
@@ -763,7 +764,7 @@ void dwc_otg_hcd_power_up(void *ptr)
  * Frees secondary storage associated with the dwc_otg_hcd structure contained
  * in the struct usb_hcd field.
  */
-static void dwc_otg_hcd_free(dwc_otg_hcd_t * dwc_otg_hcd)
+static void dwc_otg_hcd_free(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	int i;
 
@@ -820,7 +821,7 @@ static void dwc_otg_hcd_free(dwc_otg_hcd_t * dwc_otg_hcd)
 	DWC_FREE(dwc_otg_hcd);
 }
 
-int dwc_otg_hcd_init(dwc_otg_hcd_t * hcd, dwc_otg_core_if_t * core_if)
+int dwc_otg_hcd_init(dwc_otg_hcd_t *hcd, dwc_otg_core_if_t *core_if)
 {
 	int retval = 0;
 	int num_channels;
@@ -882,14 +883,16 @@ int dwc_otg_hcd_init(dwc_otg_hcd_t * hcd, dwc_otg_core_if_t * core_if)
 					  dwc_otg_hcd_connect_timeout, hcd);
 
 	/* Initialize reset tasklet. */
-	hcd->reset_tasklet = DWC_TASK_ALLOC("reset_tasklet", reset_tasklet_func, hcd);
+	hcd->reset_tasklet =
+	    DWC_TASK_ALLOC("reset_tasklet", reset_tasklet_func, hcd);
 #ifdef DWC_DEV_SRPCAP
 	if (hcd->core_if->power_down == 2) {
 		/* Initialize Power on timer for Host power up in case hibernation */
 		hcd->core_if->pwron_timer = DWC_TIMER_ALLOC("PWRON TIMER",
-									dwc_otg_hcd_power_up, core_if);
+							    dwc_otg_hcd_power_up,
+							    core_if);
 	}
-#endif	
+#endif
 
 	/*
 	 * Allocate space for storing data on status transactions. Normally no
@@ -900,7 +903,7 @@ int dwc_otg_hcd_init(dwc_otg_hcd_t * hcd, dwc_otg_core_if_t * core_if)
 	if (hcd->core_if->dma_enable) {
 		hcd->status_buf =
 		    DWC_DMA_ALLOC_ATOMIC(DWC_OTG_HCD_STATUS_BUF_SIZE,
-				  &hcd->status_buf_dma);
+					 &hcd->status_buf_dma);
 	} else {
 		hcd->status_buf = DWC_ALLOC(DWC_OTG_HCD_STATUS_BUF_SIZE);
 	}
@@ -919,7 +922,7 @@ int dwc_otg_hcd_init(dwc_otg_hcd_t * hcd, dwc_otg_core_if_t * core_if)
 	return retval;
 }
 
-void dwc_otg_hcd_remove(dwc_otg_hcd_t * hcd)
+void dwc_otg_hcd_remove(dwc_otg_hcd_t *hcd)
 {
 	/* Turn off all host-specific interrupts. */
 	dwc_otg_disable_host_interrupts(hcd->core_if);
@@ -930,7 +933,7 @@ void dwc_otg_hcd_remove(dwc_otg_hcd_t * hcd)
 /**
  * Initializes dynamic portions of the DWC_otg HCD state.
  */
-static void dwc_otg_hcd_reinit(dwc_otg_hcd_t * hcd)
+static void dwc_otg_hcd_reinit(dwc_otg_hcd_t *hcd)
 {
 	int num_channels;
 	int i;
@@ -976,13 +979,13 @@ static void dwc_otg_hcd_reinit(dwc_otg_hcd_t * hcd)
  * @param qh Transactions from the first QTD for this QH are selected and
  * assigned to a free host channel.
  */
-static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static int assign_and_init_hc(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	dwc_hc_t *hc;
 	dwc_otg_qtd_t *qtd;
 	dwc_otg_hcd_urb_t *urb;
-	void* ptr = NULL;
-	int  retval = 0;
+	void *ptr = NULL;
+	int retval = 0;
 
 	DWC_DEBUGPL(DBG_HCDV, "%s(%p,%p)\n", __func__, hcd, qh);
 
@@ -994,12 +997,12 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	qtd = DWC_CIRCLEQ_FIRST(&qh->qtd_list);
 
 	urb = qtd->urb;
-	if (urb == NULL){
+	if (urb == NULL) {
 		printk("%s : urb is NULL\n", __func__);
 		retval = -EINVAL;
 		return retval;
 	}
-        
+
 	qh->channel = hc;
 
 	qtd->in_process = 1;
@@ -1028,11 +1031,10 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	 */
 
 	hc->ep_is_in = (dwc_otg_hcd_is_pipe_in(&urb->pipe_info) != 0);
-	if (hc->ep_is_in) {
+	if (hc->ep_is_in)
 		hc->do_ping = 0;
-	} else {
+	else
 		hc->do_ping = qh->ping_state;
-	}
 
 	hc->data_pid_start = qh->data_toggle;
 	hc->multi_count = 1;
@@ -1074,11 +1076,11 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 			hc->do_ping = 0;
 			hc->ep_is_in = 0;
 			hc->data_pid_start = DWC_OTG_HC_PID_SETUP;
-			if (hcd->core_if->dma_enable) {
+			if (hcd->core_if->dma_enable)
 				hc->xfer_buff = (uint8_t *) urb->setup_dma;
-			} else {
+			else
 				hc->xfer_buff = (uint8_t *) urb->setup_packet;
-			}
+
 			hc->xfer_len = 8;
 			ptr = NULL;
 			break;
@@ -1098,18 +1100,17 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 				hc->ep_is_in =
 				    dwc_otg_hcd_is_pipe_out(&urb->pipe_info);
 			}
-			if (hc->ep_is_in) {
+			if (hc->ep_is_in)
 				hc->do_ping = 0;
-			}
 
 			hc->data_pid_start = DWC_OTG_HC_PID_DATA1;
 
 			hc->xfer_len = 0;
-			if (hcd->core_if->dma_enable) {
+			if (hcd->core_if->dma_enable)
 				hc->xfer_buff = (uint8_t *) hcd->status_buf_dma;
-			} else {
+			else
 				hc->xfer_buff = (uint8_t *) hcd->status_buf;
-			}
+
 			ptr = NULL;
 			break;
 		}
@@ -1163,17 +1164,18 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 		}
 		break;
 	}
-	/* non DWORD-aligned buffer case */	
+	/* non DWORD-aligned buffer case */
 	if (ptr) {
 		uint32_t buf_size;
 		if (hc->ep_type != DWC_OTG_EP_TYPE_ISOC) {
 			buf_size = hcd->core_if->core_params->max_transfer_size;
-		} else {				
+		} else {
 			buf_size = 4096;
 		}
 		if (!qh->dw_align_buf) {
 			qh->dw_align_buf = DWC_DMA_ALLOC_ATOMIC(buf_size,
-							 &qh->dw_align_buf_dma);
+								&qh->
+								dw_align_buf_dma);
 			if (!qh->dw_align_buf) {
 				DWC_ERROR
 				    ("%s: Failed to allocate memory to handle "
@@ -1216,7 +1218,7 @@ static int assign_and_init_hc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return The types of new transactions that were assigned to host channels.
  */
-dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t * hcd)
+dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t *hcd)
 {
 	dwc_list_link_t *qh_ptr;
 	dwc_otg_qh_t *qh;
@@ -1270,7 +1272,7 @@ dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t * hcd)
 		 */
 		qh_ptr = DWC_LIST_NEXT(qh_ptr);
 		if (err != 0)
-		        continue;
+			continue;
 		DWC_LIST_MOVE_HEAD(&hcd->non_periodic_sched_active,
 				   &qh->qh_list_entry);
 
@@ -1304,8 +1306,8 @@ dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t * hcd)
  * complete the transfer, 0 if no more requests are required for this
  * transfer, -1 if there is insufficient space in the Tx FIFO.
  */
-static int queue_transaction(dwc_otg_hcd_t * hcd,
-			     dwc_hc_t * hc, uint16_t fifo_dwords_avail)
+static int queue_transaction(dwc_otg_hcd_t *hcd,
+			     dwc_hc_t *hc, uint16_t fifo_dwords_avail)
 {
 	int retval;
 
@@ -1364,7 +1366,7 @@ static int queue_transaction(dwc_otg_hcd_t * hcd,
  * to queue as Periodic Tx FIFO or request queue space becomes available.
  * Otherwise, the Periodic Tx FIFO Empty interrupt is disabled.
  */
-static void process_periodic_channels(dwc_otg_hcd_t * hcd)
+static void process_periodic_channels(dwc_otg_hcd_t *hcd)
 {
 	hptxsts_data_t tx_status;
 	dwc_list_link_t *qh_ptr;
@@ -1481,7 +1483,7 @@ static void process_periodic_channels(dwc_otg_hcd_t * hcd)
  * NP Tx FIFO or request queue space becomes available. Otherwise, the NP Tx
  * FIFO Empty interrupt is disabled.
  */
-static void process_non_periodic_channels(dwc_otg_hcd_t * hcd)
+static void process_non_periodic_channels(dwc_otg_hcd_t *hcd)
 {
 	gnptxsts_data_t tx_status;
 	dwc_list_link_t *orig_qh_ptr;
@@ -1591,7 +1593,7 @@ static void process_non_periodic_channels(dwc_otg_hcd_t * hcd)
  * @param tr_type The type(s) of transactions to queue (non-periodic,
  * periodic, or both).
  */
-void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t * hcd,
+void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t *hcd,
 				    dwc_otg_transaction_type_e tr_type)
 {
 #ifdef DEBUG_SOF
@@ -1617,9 +1619,8 @@ void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t * hcd,
 			 */
 			gintmsk_data_t gintmsk = {.d32 = 0 };
 			gintmsk.b.nptxfempty = 1;
-			DWC_MODIFY_REG32(&hcd->core_if->
-					 core_global_regs->gintmsk, gintmsk.d32,
-					 0);
+			DWC_MODIFY_REG32(&hcd->core_if->core_global_regs->
+					 gintmsk, gintmsk.d32, 0);
 		}
 	}
 }
@@ -1689,9 +1690,9 @@ static void do_setup(void)
 	hcchar.d32 = DWC_READ_REG32(&hc_regs->hcchar);
 	if (hcchar.b.chen) {
 		hcchar.b.chdis = 1;
-//              hcchar.b.chen = 1;
+		/* hcchar.b.chen = 1; */
 		DWC_WRITE_REG32(&hc_regs->hcchar, hcchar.d32);
-		//sleep(1);
+		/* sleep(1); */
 		dwc_mdelay(1000);
 
 		/* Read GINTSTS */
@@ -1823,7 +1824,7 @@ static void do_in_ack(void)
 		hcchar.b.chdis = 1;
 		hcchar.b.chen = 1;
 		DWC_WRITE_REG32(&hc_regs->hcchar, hcchar.d32);
-		//sleep(1);
+		/* sleep(1); */
 		dwc_mdelay(1000);
 
 		/* Read GINTSTS */
@@ -1951,8 +1952,8 @@ static void do_in_ack(void)
 	/* Read GINTSTS */
 	gintsts.d32 = DWC_READ_REG32(&global_regs->gintsts);
 
-//      usleep(100000);
-//      mdelay(100);
+	/* usleep(100000); */
+	/* mdelay(100); */
 	dwc_mdelay(1);
 
 	/*
@@ -1986,7 +1987,7 @@ static void do_in_ack(void)
 		hcchar.b.chdis = 1;
 		hcchar.b.chen = 1;
 		DWC_WRITE_REG32(&hc_regs->hcchar, hcchar.d32);
-		//sleep(1);
+		/* sleep(1); */
 		dwc_mdelay(1000);
 
 		/* Read GINTSTS */
@@ -2066,10 +2067,10 @@ static void do_in_ack(void)
 #endif
 
 /** Handles hub class-specific requests. */
-int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
+int dwc_otg_hcd_hub_control(dwc_otg_hcd_t *dwc_otg_hcd,
 			    uint16_t typeReq,
 			    uint16_t wValue,
-			    uint16_t wIndex, uint8_t * buf, uint16_t wLength)
+			    uint16_t wIndex, uint8_t *buf, uint16_t wLength)
 {
 	int retval = 0;
 
@@ -2111,9 +2112,6 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 			DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 			break;
 		case UHF_PORT_SUSPEND:
-#if 0//def CONFIG_PM_RUNTIME
-			break;
-#endif
 			DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD HUB CONTROL - "
 				    "ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
 
@@ -2125,12 +2123,14 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 
 				hprt0.d32 = dwc_otg_read_hprt0(core_if);
 				hprt0.b.prtres = 1;
-				DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+				DWC_WRITE_REG32(core_if->host_if->hprt0,
+						hprt0.d32);
 				hprt0.b.prtsusp = 0;
 				/* Clear Resume bit */
 				dwc_mdelay(100);
 				hprt0.b.prtres = 0;
-				DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+				DWC_WRITE_REG32(core_if->host_if->hprt0,
+						hprt0.d32);
 			}
 			break;
 #ifdef CONFIG_USB_DWC_OTG_LPM
@@ -2140,14 +2140,13 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				glpmcfg_data_t lpmcfg = {.d32 = 0 };
 
 				lpmcfg.d32 =
-				    DWC_READ_REG32(&core_if->
-						   core_global_regs->glpmcfg);
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   glpmcfg);
 				lpmcfg.b.en_utmi_sleep = 0;
 				lpmcfg.b.hird_thres &= (~(1 << 4));
 				lpmcfg.b.prt_sleep_sts = 1;
-				DWC_WRITE_REG32(&core_if->
-						core_global_regs->glpmcfg,
-						lpmcfg.d32);
+				DWC_WRITE_REG32(&core_if->core_global_regs->
+						glpmcfg, lpmcfg.d32);
 
 				/* Clear Enbl_L1Gating bit. */
 				pcgcctl.b.enbl_sleep_gating = 1;
@@ -2314,11 +2313,11 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 			port_status |= (1 << UHF_PORT_L1);
 		}
 		/*
-		   For Synopsys HW emulation of Power down wkup_control asserts the 
-		   hreset_n and prst_n on suspned. This causes the HPRT0 to be zero. 
-		   We intentionally tell the software that port is in L2Suspend state. 
+		   For Synopsys HW emulation of Power down wkup_control asserts the
+		   hreset_n and prst_n on suspned. This causes the HPRT0 to be zero.
+		   We intentionally tell the software that port is in L2Suspend state.
 		   Only for STE.
-		*/
+		 */
 		if ((core_if->power_down == 2)
 		    && (core_if->hibernation_suspend == 1)) {
 			port_status |= (1 << UHF_PORT_SUSPEND);
@@ -2350,9 +2349,6 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 
 		switch (wValue) {
 		case UHF_PORT_SUSPEND:
-#if 0//def CONFIG_PM_RUNTIME
-			break;
-#endif
 			DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD HUB CONTROL - "
 				    "SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
 			if (dwc_otg_hcd_otg_port(dwc_otg_hcd) != wIndex) {
@@ -2365,9 +2361,11 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				gpwrdn_data_t gpwrdn = {.d32 = 0 };
 				gusbcfg_data_t gusbcfg = {.d32 = 0 };
 #ifdef DWC_DEV_SRPCAP
-				int32_t otg_cap_param = core_if->core_params->otg_cap;
+				int32_t otg_cap_param =
+				    core_if->core_params->otg_cap;
 #endif
-				DWC_PRINTF("Preparing for complete power-off\n");
+				DWC_PRINTF
+				    ("Preparing for complete power-off\n");
 
 				/* Save registers before hibernation */
 				dwc_otg_save_global_regs(core_if);
@@ -2376,7 +2374,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				hprt0.d32 = dwc_otg_read_hprt0(core_if);
 				hprt0.b.prtsusp = 1;
 				hprt0.b.prtena = 0;
-				DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+				DWC_WRITE_REG32(core_if->host_if->hprt0,
+						hprt0.d32);
 				/* Spin hprt0.b.prtsusp to became 1 */
 				do {
 					hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -2404,8 +2403,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						hprt0.d32);
 #endif
 				gusbcfg.d32 =
-				    DWC_READ_REG32(&core_if->core_global_regs->
-						   gusbcfg);
+				    DWC_READ_REG32(&core_if->
+						   core_global_regs->gusbcfg);
 				if (gusbcfg.b.ulpi_utmi_sel == 1) {
 					/* ULPI interface */
 					/* Suspend the Phy Clock */
@@ -2415,30 +2414,33 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 							 pcgcctl.d32);
 					dwc_udelay(10);
 					gpwrdn.b.pmuactv = 1;
-					DWC_MODIFY_REG32(&core_if->
-							 core_global_regs->
-							 gpwrdn, 0, gpwrdn.d32);
+					DWC_MODIFY_REG32
+					    (&core_if->core_global_regs->gpwrdn,
+					     0, gpwrdn.d32);
 				} else {
 					/* UTMI+ Interface */
 					gpwrdn.b.pmuactv = 1;
-					DWC_MODIFY_REG32(&core_if->
-							 core_global_regs->
-							 gpwrdn, 0, gpwrdn.d32);
+					DWC_MODIFY_REG32
+					    (&core_if->core_global_regs->gpwrdn,
+					     0, gpwrdn.d32);
 					dwc_udelay(10);
 					pcgcctl.b.stoppclk = 1;
-					DWC_MODIFY_REG32(core_if->pcgcctl, 0, pcgcctl.d32);
+					DWC_MODIFY_REG32(core_if->pcgcctl, 0,
+							 pcgcctl.d32);
 					dwc_udelay(10);
 				}
-#ifdef DWC_DEV_SRPCAP				
+#ifdef DWC_DEV_SRPCAP
 				gpwrdn.d32 = 0;
 				gpwrdn.b.dis_vbus = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 #endif
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuintsel = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				gpwrdn.d32 = 0;
@@ -2448,40 +2450,46 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				gpwrdn.b.disconn_det_msk = 1;
 				gpwrdn.b.lnstchng_msk = 1;
 				gpwrdn.b.sts_chngint_msk = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				/* Enable Power Down Clamp and all interrupts in GPWRDN */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pwrdnclmp = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 				dwc_udelay(10);
 
 				/* Switch off VDD */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 
 #ifdef DWC_DEV_SRPCAP
-				if (otg_cap_param == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)
-				{
+				if (otg_cap_param ==
+				    DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE) {
 					core_if->pwron_timer_started = 1;
-					DWC_TIMER_SCHEDULE(core_if->pwron_timer, 6000 /* 6 secs */ );
+					DWC_TIMER_SCHEDULE(core_if->pwron_timer,
+							   6000 /* 6 secs */);
 				}
 #endif
 				/* Save gpwrdn register for further usage if stschng interrupt */
 				core_if->gr_backup->gpwrdn_local =
-						DWC_READ_REG32(&core_if->core_global_regs->gpwrdn);
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gpwrdn);
 
 				/* Set flag to indicate that we are in hibernation */
 				core_if->hibernation_suspend = 1;
-				DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock,flags);
+				DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock,
+							  flags);
 
 				DWC_PRINTF("Host hibernation completed\n");
-				// Exit from case statement
+				/* Exit from case statement */
 				break;
 
 			}
@@ -2489,8 +2497,9 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 			    dwc_otg_hcd->fops->get_b_hnp_enable(dwc_otg_hcd)) {
 				gotgctl_data_t gotgctl = {.d32 = 0 };
 				gotgctl.b.hstsethnpen = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gotgctl, 0, gotgctl.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gotgctl, 0,
+						 gotgctl.d32);
 				core_if->op_state = A_SUSPEND;
 			}
 			hprt0.d32 = dwc_otg_read_hprt0(core_if);
@@ -2501,7 +2510,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				/* Update lx_state */
 				DWC_SPINLOCK_IRQSAVE(dwc_otg_hcd->lock, &flags);
 				core_if->lx_state = DWC_OTG_L2;
-				DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock, flags);
+				DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock,
+							  flags);
 			}
 			/* Suspend the Phy Clock */
 			if (core_if->otg_ver == 0) {
@@ -2516,35 +2526,37 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 			if (dwc_otg_hcd->fops->get_b_hnp_enable(dwc_otg_hcd)) {
 				pcgcctl_data_t pcgcctl = {.d32 = 0 };
 				pcgcctl.b.stoppclk = 1;
-                DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
+				DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32,
+						 0);
 				dwc_mdelay(200);
 			}
 
 			/** @todo - check how sw can wait for 1 sec to check asesvld??? */
-#if 0 //vahrama !!!!!!!!!!!!!!!!!!
+#if 0
 			if (core_if->adp_enable) {
 				gotgctl_data_t gotgctl = {.d32 = 0 };
 				gpwrdn_data_t gpwrdn;
 
 				while (gotgctl.b.asesvld == 1) {
 					gotgctl.d32 =
-					    DWC_READ_REG32(&core_if->
-							   core_global_regs->
-							   gotgctl);
+					    DWC_READ_REG32
+					    (&core_if->core_global_regs->gotgctl);
 					dwc_mdelay(100);
 				}
 
 				/* Enable Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 
 				/* Unmask SRP detected interrupt from Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.srp_det_msk = 1;
-				DWC_MODIFY_REG32(&core_if->core_global_regs->
-						 gpwrdn, 0, gpwrdn.d32);
+				DWC_MODIFY_REG32(&core_if->
+						 core_global_regs->gpwrdn, 0,
+						 gpwrdn.d32);
 
 				dwc_otg_adp_probe_start(core_if);
 			}
@@ -2574,20 +2586,25 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 					pcgcctl_data_t pcgcctl = {.d32 = 0 };
 					pcgcctl.b.enbl_sleep_gating = 1;
 					pcgcctl.b.stoppclk = 1;
-					DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
+					DWC_MODIFY_REG32(core_if->pcgcctl,
+							 pcgcctl.d32, 0);
 					DWC_WRITE_REG32(core_if->pcgcctl, 0);
 				}
 #ifdef CONFIG_USB_DWC_OTG_LPM
 				{
 					glpmcfg_data_t lpmcfg;
 					lpmcfg.d32 =
-						DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
+					    DWC_READ_REG32(&core_if->
+							   core_global_regs->
+							   glpmcfg);
 					if (lpmcfg.b.prt_sleep_sts) {
 						lpmcfg.b.en_utmi_sleep = 0;
-						lpmcfg.b.hird_thres &= (~(1 << 4));
-						DWC_WRITE_REG32
-						    (&core_if->core_global_regs->glpmcfg,
-						     lpmcfg.d32);
+						lpmcfg.b.hird_thres &=
+						    (~(1 << 4));
+						DWC_WRITE_REG32(&core_if->
+								core_global_regs->
+								glpmcfg,
+								lpmcfg.d32);
 						dwc_mdelay(1);
 					}
 				}
@@ -2602,14 +2619,17 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				if (!dwc_otg_hcd_is_b_host(dwc_otg_hcd)) {
 					hprt0.b.prtpwr = 1;
 					hprt0.b.prtrst = 1;
-					DWC_PRINTF("Indeed it is in host mode hprt0 = %08x\n",hprt0.d32);
+					DWC_PRINTF
+					    ("Indeed it is in host mode hprt0 = %08x\n",
+					     hprt0.d32);
 					DWC_WRITE_REG32(core_if->host_if->hprt0,
 							hprt0.d32);
 				}
 				/* Clear reset bit in 10ms (FS/LS) or 50ms (HS) */
 				dwc_mdelay(60);
 				hprt0.b.prtrst = 0;
-				DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+				DWC_WRITE_REG32(core_if->host_if->hprt0,
+						hprt0.d32);
 				core_if->lx_state = DWC_OTG_L0;	/* Now back to the on state */
 			}
 			break;
@@ -2654,7 +2674,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						/* Disable all interrupts while we muck with
 						 * the hardware directly
 						 */
-						DWC_WRITE_REG32(&global_regs->gintmsk, 0);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk, 0);
 
 						/* 15 second delay per the test spec */
 						dwc_mdelay(15000);
@@ -2664,7 +2685,9 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						    dwc_otg_read_hprt0(core_if);
 						hprt0.b.prtsusp = 1;
 						hprt0.b.prtres = 0;
-						DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+						DWC_WRITE_REG32(core_if->
+								host_if->hprt0,
+								hprt0.d32);
 
 						/* 15 second delay per the test spec */
 						dwc_mdelay(15000);
@@ -2674,15 +2697,21 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						    dwc_otg_read_hprt0(core_if);
 						hprt0.b.prtsusp = 0;
 						hprt0.b.prtres = 1;
-						DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+						DWC_WRITE_REG32(core_if->
+								host_if->hprt0,
+								hprt0.d32);
 						dwc_mdelay(100);
 
 						/* Clear the resume bit */
 						hprt0.b.prtres = 0;
-						DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
+						DWC_WRITE_REG32(core_if->
+								host_if->hprt0,
+								hprt0.d32);
 
 						/* Restore interrupts */
-						DWC_WRITE_REG32(&global_regs->gintmsk, gintmsk.d32);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk,
+								gintmsk.d32);
 					} else if (t == 7) {	/* SINGLE_STEP_GET_DEVICE_DESCRIPTOR setup */
 						/* Save current interrupt mask */
 						gintmsk.d32 =
@@ -2692,7 +2721,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						/* Disable all interrupts while we muck with
 						 * the hardware directly
 						 */
-						DWC_WRITE_REG32(&global_regs->gintmsk, 0);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk, 0);
 
 						/* 15 second delay per the test spec */
 						dwc_mdelay(15000);
@@ -2704,7 +2734,9 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						dwc_mdelay(15000);
 
 						/* Restore interrupts */
-						DWC_WRITE_REG32(&global_regs->gintmsk, gintmsk.d32);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk,
+								gintmsk.d32);
 					} else if (t == 8) {	/* SINGLE_STEP_GET_DEVICE_DESCRIPTOR execute */
 						/* Save current interrupt mask */
 						gintmsk.d32 =
@@ -2714,7 +2746,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						/* Disable all interrupts while we muck with
 						 * the hardware directly
 						 */
-						DWC_WRITE_REG32(&global_regs->gintmsk, 0);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk, 0);
 
 						/* Send the Setup packet */
 						do_setup();
@@ -2729,7 +2762,9 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 						dwc_mdelay(15000);
 
 						/* Restore interrupts */
-						DWC_WRITE_REG32(&global_regs->gintmsk, gintmsk.d32);
+						DWC_WRITE_REG32(&global_regs->
+								gintmsk,
+								gintmsk.d32);
 					}
 				}
 				break;
@@ -2812,7 +2847,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 			 */
 			do {
 				gintsts.d32 =
-				    DWC_READ_REG32(&core_if->core_global_regs->gintsts);
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   gintsts);
 				if (gintsts.b.lpmtranrcvd) {
 					break;
 				}
@@ -2830,7 +2866,8 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 				dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd);
 			} else {
 				lpmcfg.d32 =
-				    DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
+				    DWC_READ_REG32(&core_if->core_global_regs->
+						   glpmcfg);
 				if (lpmcfg.b.lpm_resp == 0x3) {
 					/* ACK responce from the device */
 					buf[0] = 0x00;	/* Success */
@@ -2864,7 +2901,7 @@ int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
 
 #ifdef CONFIG_USB_DWC_OTG_LPM
 /** Returns index of host channel to perform LPM transaction. */
-int dwc_otg_hcd_get_hc_for_lpm_tran(dwc_otg_hcd_t * hcd, uint8_t devaddr)
+int dwc_otg_hcd_get_hc_for_lpm_tran(dwc_otg_hcd_t *hcd, uint8_t devaddr)
 {
 	dwc_otg_core_if_t *core_if = hcd->core_if;
 	dwc_hc_t *hc;
@@ -2901,7 +2938,7 @@ int dwc_otg_hcd_get_hc_for_lpm_tran(dwc_otg_hcd_t * hcd, uint8_t devaddr)
 }
 
 /** Release hc after performing LPM transaction */
-void dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd_t * hcd)
+void dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd_t *hcd)
 {
 	dwc_hc_t *hc;
 	glpmcfg_data_t lpmcfg;
@@ -2917,7 +2954,7 @@ void dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd_t * hcd)
 	DWC_CIRCLEQ_INSERT_TAIL(&hcd->free_hc_list, hc, hc_list_entry);
 }
 
-int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t * hcd, uint8_t devaddr, uint8_t hird,
+int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t *hcd, uint8_t devaddr, uint8_t hird,
 			 uint8_t bRemoteWake)
 {
 	glpmcfg_data_t lpmcfg;
@@ -2938,14 +2975,14 @@ int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t * hcd, uint8_t devaddr, uint8_t hird,
 	/* Program LPM transaction fields */
 	lpmcfg.b.rem_wkup_en = bRemoteWake;
 	lpmcfg.b.hird = hird;
-	
-	if(dwc_otg_get_param_besl_enable(hcd->core_if)) {
+
+	if (dwc_otg_get_param_besl_enable(hcd->core_if)) {
 		lpmcfg.b.hird_thres = 0x16;
 		lpmcfg.b.en_besl = 1;
 	} else {
 		lpmcfg.b.hird_thres = 0x1c;
 	}
-	
+
 	lpmcfg.b.lpm_chan_index = channel;
 	lpmcfg.b.en_utmi_sleep = 1;
 	/* Program LPM config register */
@@ -2960,7 +2997,7 @@ int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t * hcd, uint8_t devaddr, uint8_t hird,
 
 #endif /* CONFIG_USB_DWC_OTG_LPM */
 
-int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t * hcd, int port)
+int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t *hcd, int port)
 {
 	int retval;
 
@@ -2992,12 +3029,12 @@ int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t * hcd, int port)
 	return retval;
 }
 
-int dwc_otg_hcd_get_frame_number(dwc_otg_hcd_t * dwc_otg_hcd)
+int dwc_otg_hcd_get_frame_number(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	hfnum_data_t hfnum;
 	hfnum.d32 =
-	    DWC_READ_REG32(&dwc_otg_hcd->core_if->host_if->host_global_regs->
-			   hfnum);
+	    DWC_READ_REG32(&dwc_otg_hcd->core_if->host_if->
+			   host_global_regs->hfnum);
 
 #ifdef DEBUG_SOF
 	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD GET FRAME NUMBER %d\n",
@@ -3006,14 +3043,14 @@ int dwc_otg_hcd_get_frame_number(dwc_otg_hcd_t * dwc_otg_hcd)
 	return hfnum.b.frnum;
 }
 
-int dwc_otg_hcd_start(dwc_otg_hcd_t * hcd,
+int dwc_otg_hcd_start(dwc_otg_hcd_t *hcd,
 		      struct dwc_otg_hcd_function_ops *fops)
 {
 	int retval = 0;
 
 	hcd->fops = fops;
-	if (!dwc_otg_is_device_mode(hcd->core_if) && 
-		(!hcd->core_if->adp_enable || hcd->core_if->adp.adp_started)) {
+	if (!dwc_otg_is_device_mode(hcd->core_if) &&
+	    (!hcd->core_if->adp_enable || hcd->core_if->adp.adp_started)) {
 		dwc_otg_hcd_reinit(hcd);
 	} else {
 		retval = -DWC_E_NO_DEVICE;
@@ -3022,22 +3059,22 @@ int dwc_otg_hcd_start(dwc_otg_hcd_t * hcd,
 	return retval;
 }
 
-void *dwc_otg_hcd_get_priv_data(dwc_otg_hcd_t * hcd)
+void *dwc_otg_hcd_get_priv_data(dwc_otg_hcd_t *hcd)
 {
 	return hcd->priv;
 }
 
-void dwc_otg_hcd_set_priv_data(dwc_otg_hcd_t * hcd, void *priv_data)
+void dwc_otg_hcd_set_priv_data(dwc_otg_hcd_t *hcd, void *priv_data)
 {
 	hcd->priv = priv_data;
 }
 
-uint32_t dwc_otg_hcd_otg_port(dwc_otg_hcd_t * hcd)
+uint32_t dwc_otg_hcd_otg_port(dwc_otg_hcd_t *hcd)
 {
 	return hcd->otg_port;
 }
 
-uint32_t dwc_otg_hcd_is_b_host(dwc_otg_hcd_t * hcd)
+uint32_t dwc_otg_hcd_is_b_host(dwc_otg_hcd_t *hcd)
 {
 	uint32_t is_b_host;
 	if (hcd->core_if->op_state == B_HOST) {
@@ -3049,7 +3086,7 @@ uint32_t dwc_otg_hcd_is_b_host(dwc_otg_hcd_t * hcd)
 	return is_b_host;
 }
 
-dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t * hcd,
+dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t *hcd,
 					 int iso_desc_count, int atomic_alloc)
 {
 	dwc_otg_hcd_urb_t *dwc_otg_urb;
@@ -3068,7 +3105,7 @@ dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t * hcd,
 	return dwc_otg_urb;
 }
 
-void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t * dwc_otg_urb,
+void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t *dwc_otg_urb,
 				  uint8_t dev_addr, uint8_t ep_num,
 				  uint8_t ep_type, uint8_t ep_dir, uint16_t mps)
 {
@@ -3081,7 +3118,7 @@ void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t * dwc_otg_urb,
 #endif
 }
 
-void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t * dwc_otg_urb,
+void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t *dwc_otg_urb,
 				void *urb_handle, void *buf, dwc_dma_t dma,
 				uint32_t buflen, void *setup_packet,
 				dwc_dma_t setup_dma, uint32_t flags,
@@ -3098,22 +3135,22 @@ void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t * dwc_otg_urb,
 	dwc_otg_urb->status = -DWC_E_IN_PROGRESS;
 }
 
-uint32_t dwc_otg_hcd_urb_get_status(dwc_otg_hcd_urb_t * dwc_otg_urb)
+uint32_t dwc_otg_hcd_urb_get_status(dwc_otg_hcd_urb_t *dwc_otg_urb)
 {
 	return dwc_otg_urb->status;
 }
 
-uint32_t dwc_otg_hcd_urb_get_actual_length(dwc_otg_hcd_urb_t * dwc_otg_urb)
+uint32_t dwc_otg_hcd_urb_get_actual_length(dwc_otg_hcd_urb_t *dwc_otg_urb)
 {
 	return dwc_otg_urb->actual_length;
 }
 
-uint32_t dwc_otg_hcd_urb_get_error_count(dwc_otg_hcd_urb_t * dwc_otg_urb)
+uint32_t dwc_otg_hcd_urb_get_error_count(dwc_otg_hcd_urb_t *dwc_otg_urb)
 {
 	return dwc_otg_urb->error_count;
 }
 
-void dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_hcd_urb_t * dwc_otg_urb,
+void dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_hcd_urb_t *dwc_otg_urb,
 					 int desc_num, uint32_t offset,
 					 uint32_t length)
 {
@@ -3121,7 +3158,7 @@ void dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_hcd_urb_t * dwc_otg_urb,
 	dwc_otg_urb->iso_descs[desc_num].length = length;
 }
 
-uint32_t dwc_otg_hcd_urb_get_iso_desc_status(dwc_otg_hcd_urb_t * dwc_otg_urb,
+uint32_t dwc_otg_hcd_urb_get_iso_desc_status(dwc_otg_hcd_urb_t *dwc_otg_urb,
 					     int desc_num)
 {
 	return dwc_otg_urb->iso_descs[desc_num].status;
@@ -3133,7 +3170,7 @@ uint32_t dwc_otg_hcd_urb_get_iso_desc_actual_length(dwc_otg_hcd_urb_t *
 	return dwc_otg_urb->iso_descs[desc_num].actual_length;
 }
 
-int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t * hcd, void *ep_handle)
+int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t *hcd, void *ep_handle)
 {
 	int allocated = 0;
 	dwc_otg_qh_t *qh = (dwc_otg_qh_t *) ep_handle;
@@ -3146,7 +3183,7 @@ int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t * hcd, void *ep_handle)
 	return allocated;
 }
 
-int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t * hcd, void *ep_handle)
+int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t *hcd, void *ep_handle)
 {
 	dwc_otg_qh_t *qh = (dwc_otg_qh_t *) ep_handle;
 	int freed = 0;
@@ -3159,14 +3196,14 @@ int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t * hcd, void *ep_handle)
 	return freed;
 }
 
-uint8_t dwc_otg_hcd_get_ep_bandwidth(dwc_otg_hcd_t * hcd, void *ep_handle)
+uint8_t dwc_otg_hcd_get_ep_bandwidth(dwc_otg_hcd_t *hcd, void *ep_handle)
 {
 	dwc_otg_qh_t *qh = (dwc_otg_qh_t *) ep_handle;
 	DWC_ASSERT(qh, "qh is not allocated\n");
 	return qh->usecs;
 }
 
-void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd)
+void dwc_otg_hcd_dump_state(dwc_otg_hcd_t *hcd)
 {
 #ifdef DEBUG
 	int num_channels;
@@ -3211,20 +3248,20 @@ void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd)
 			hcint_data_t hcint;
 			hcintmsk_data_t hcintmsk;
 			hfnum.d32 =
-			    DWC_READ_REG32(&hcd->core_if->
-					   host_if->host_global_regs->hfnum);
-			hcchar.d32 =
 			    DWC_READ_REG32(&hcd->core_if->host_if->
-					   hc_regs[i]->hcchar);
+					   host_global_regs->hfnum);
+			hcchar.d32 =
+			    DWC_READ_REG32(&hcd->core_if->host_if->hc_regs[i]->
+					   hcchar);
 			hctsiz.d32 =
-			    DWC_READ_REG32(&hcd->core_if->host_if->
-					   hc_regs[i]->hctsiz);
+			    DWC_READ_REG32(&hcd->core_if->host_if->hc_regs[i]->
+					   hctsiz);
 			hcint.d32 =
-			    DWC_READ_REG32(&hcd->core_if->host_if->
-					   hc_regs[i]->hcint);
+			    DWC_READ_REG32(&hcd->core_if->host_if->hc_regs[i]->
+					   hcint);
 			hcintmsk.d32 =
-			    DWC_READ_REG32(&hcd->core_if->host_if->
-					   hc_regs[i]->hcintmsk);
+			    DWC_READ_REG32(&hcd->core_if->host_if->hc_regs[i]->
+					   hcintmsk);
 			DWC_PRINTF("    hfnum: 0x%08x\n", hfnum.d32);
 			DWC_PRINTF("    hcchar: 0x%08x\n", hcchar.d32);
 			DWC_PRINTF("    hctsiz: 0x%08x\n", hctsiz.d32);
@@ -3234,32 +3271,37 @@ void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd)
 		if (hc->xfer_started && hc->qh) {
 			dwc_otg_qtd_t *qtd;
 			dwc_otg_hcd_urb_t *urb;
-			
-			DWC_CIRCLEQ_FOREACH(qtd, &hc->qh->qtd_list, qtd_list_entry) {
+
+			DWC_CIRCLEQ_FOREACH(qtd, &hc->qh->qtd_list,
+					    qtd_list_entry) {
 				if (!qtd->in_process)
 					break;
-				
+
 				urb = qtd->urb;
-			DWC_PRINTF("    URB Info:\n");
-			DWC_PRINTF("      qtd: %p, urb: %p\n", qtd, urb);
-			if (urb) {
-				DWC_PRINTF("      Dev: %d, EP: %d %s\n",
-					   dwc_otg_hcd_get_dev_addr(&urb->
-								    pipe_info),
-					   dwc_otg_hcd_get_ep_num(&urb->
-								  pipe_info),
-					   dwc_otg_hcd_is_pipe_in(&urb->
-								  pipe_info) ?
-					   "IN" : "OUT");
-				DWC_PRINTF("      Max packet size: %d\n",
-					   dwc_otg_hcd_get_mps(&urb->
-							       pipe_info));
-				DWC_PRINTF("      transfer_buffer: %p\n",
-					   urb->buf);
-				DWC_PRINTF("      transfer_dma: %p\n",
-					   (void *)urb->dma);
-				DWC_PRINTF("      transfer_buffer_length: %d\n",
-					   urb->length);
+				DWC_PRINTF("    URB Info:\n");
+				DWC_PRINTF("      qtd: %p, urb: %p\n", qtd,
+					   urb);
+				if (urb) {
+					DWC_PRINTF("      Dev: %d, EP: %d %s\n",
+						   dwc_otg_hcd_get_dev_addr
+						   (&urb->pipe_info),
+						   dwc_otg_hcd_get_ep_num
+						   (&urb->pipe_info),
+						   dwc_otg_hcd_is_pipe_in
+						   (&urb->pipe_info) ? "IN" :
+						   "OUT");
+					DWC_PRINTF
+					    ("      Max packet size: %d\n",
+					     dwc_otg_hcd_get_mps
+					     (&urb->pipe_info));
+					DWC_PRINTF
+					    ("      transfer_buffer: %p\n",
+					     urb->buf);
+					DWC_PRINTF("      transfer_dma: %p\n",
+						   (void *)urb->dma);
+					DWC_PRINTF
+					    ("      transfer_buffer_length: %d\n",
+					     urb->length);
 					DWC_PRINTF("      actual_length: %d\n",
 						   urb->actual_length);
 				}
@@ -3290,7 +3332,7 @@ void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd)
 }
 
 #ifdef DEBUG
-void dwc_print_setup_data(uint8_t * setup)
+void dwc_print_setup_data(uint8_t *setup)
 {
 	int i;
 	if (CHK_DEBUG_LEVEL(DBG_HCD)) {
@@ -3335,14 +3377,14 @@ void dwc_print_setup_data(uint8_t * setup)
 			break;
 		}
 		DWC_PRINTF("  bRequest = 0x%0x\n", setup[1]);
-		DWC_PRINTF("  wValue = 0x%0x\n", *((uint16_t *) & setup[2]));
-		DWC_PRINTF("  wIndex = 0x%0x\n", *((uint16_t *) & setup[4]));
-		DWC_PRINTF("  wLength = 0x%0x\n\n", *((uint16_t *) & setup[6]));
+		DWC_PRINTF("  wValue = 0x%0x\n", *((uint16_t *)&setup[2]));
+		DWC_PRINTF("  wIndex = 0x%0x\n", *((uint16_t *)&setup[4]));
+		DWC_PRINTF("  wLength = 0x%0x\n\n", *((uint16_t *)&setup[6]));
 	}
 }
 #endif
 
-void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t * hcd)
+void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t *hcd)
 {
 #if 0
 	DWC_PRINTF("Frame remaining at SOF:\n");
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd.h b/drivers/usb/dwc_otg_310/dwc_otg_hcd.h
index 949e4dfb65ad..8d667cfeb362 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd.h
@@ -142,7 +142,9 @@ static inline uint8_t dwc_otg_hcd_is_pipe_in(struct dwc_otg_hcd_pipe_info *pipe)
 static inline uint8_t dwc_otg_hcd_is_pipe_out(struct dwc_otg_hcd_pipe_info
 					      *pipe)
 {
-	return (!dwc_otg_hcd_is_pipe_in(pipe));
+	uint8_t ret;
+	ret = !dwc_otg_hcd_is_pipe_in(pipe);
+	return ret;
 }
 
 static inline void dwc_otg_hcd_fill_pipe(struct dwc_otg_hcd_pipe_info *pipe,
@@ -244,8 +246,8 @@ typedef struct dwc_otg_qtd {
 	/** Number of DMA descriptors for this QTD */
 	uint8_t n_desc;
 
-	/** 
-	 * Last activated frame(packet) index. 
+	/**
+	 * Last activated frame(packet) index.
 	 * Used in Descriptor DMA mode only.
 	 */
 	uint16_t isoc_frame_index_last;
@@ -326,8 +328,8 @@ typedef struct dwc_otg_qh {
 
 	/** @} */
 
-	/** 
-	 * Used instead of original buffer if 
+	/**
+	 * Used instead of original buffer if
 	 * it(physical address) is not dword-aligned.
 	 */
 	uint8_t *dw_align_buf;
@@ -345,9 +347,9 @@ typedef struct dwc_otg_qh {
 	/** Descriptor List physical address. */
 	dwc_dma_t desc_list_dma;
 
-	/** 
+	/**
 	 * Xfer Bytes array.
-	 * Each element corresponds to a descriptor and indicates 
+	 * Each element corresponds to a descriptor and indicates
 	 * original XferSize size value for the descriptor.
 	 */
 	uint32_t *n_bytes;
@@ -559,30 +561,30 @@ struct dwc_otg_hcd {
 	uint32_t hfnum_other_samples_b;
 	uint64_t hfnum_other_frrem_accum_b;
 #endif
-    /** Flag to indicate whether host controller is enabled. 
+    /** Flag to indicate whether host controller is enabled.
      *  0: force disable by sysfs
      *  1: enable
      *  2: not enable
      **/
-    uint8_t host_enabled;
-    uint8_t host_setenable;
-    struct timer_list 	connect_detect_timer;
-    struct delayed_work	host_enable_work;
+	uint8_t host_enabled;
+	uint8_t host_setenable;
+	struct timer_list connect_detect_timer;
+	struct delayed_work host_enable_work;
 };
 
 /** @name Transaction Execution Functions */
 /** @{ */
 extern dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t
-								  * hcd);
-extern void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t * hcd,
+								  *hcd);
+extern void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t *hcd,
 					   dwc_otg_transaction_type_e tr_type);
 
 /** @} */
 
 /** @name Interrupt Handler Functions */
 /** @{ */
-extern int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * dwc_otg_hcd);
-extern int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t * dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t *dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t *dwc_otg_hcd);
 extern int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd_t *
 							 dwc_otg_hcd);
 extern int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_t *
@@ -591,14 +593,14 @@ extern int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_hcd_t *
 							   dwc_otg_hcd);
 extern int32_t dwc_otg_hcd_handle_incomplete_periodic_intr(dwc_otg_hcd_t *
 							   dwc_otg_hcd);
-extern int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t *dwc_otg_hcd);
 extern int32_t dwc_otg_hcd_handle_conn_id_status_change_intr(dwc_otg_hcd_t *
 							     dwc_otg_hcd);
-extern int32_t dwc_otg_hcd_handle_disconnect_intr(dwc_otg_hcd_t * dwc_otg_hcd);
-extern int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t * dwc_otg_hcd);
-extern int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t * dwc_otg_hcd,
+extern int32_t dwc_otg_hcd_handle_disconnect_intr(dwc_otg_hcd_t *dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t *dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t *dwc_otg_hcd,
 					    uint32_t num);
-extern int32_t dwc_otg_hcd_handle_session_req_intr(dwc_otg_hcd_t * dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_session_req_intr(dwc_otg_hcd_t *dwc_otg_hcd);
 extern int32_t dwc_otg_hcd_handle_wakeup_detected_intr(dwc_otg_hcd_t *
 						       dwc_otg_hcd);
 /** @} */
@@ -607,17 +609,18 @@ extern int32_t dwc_otg_hcd_handle_wakeup_detected_intr(dwc_otg_hcd_t *
 /** @{ */
 
 /* Implemented in dwc_otg_hcd_queue.c */
-extern dwc_otg_qh_t *dwc_otg_hcd_qh_create(dwc_otg_hcd_t * hcd,
-					   dwc_otg_hcd_urb_t * urb, int atomic_alloc);
-extern void dwc_otg_hcd_qh_free(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
-extern int dwc_otg_hcd_qh_add(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
-extern void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
-extern void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
+extern dwc_otg_qh_t *dwc_otg_hcd_qh_create(dwc_otg_hcd_t *hcd,
+					   dwc_otg_hcd_urb_t *urb,
+					   int atomic_alloc);
+extern void dwc_otg_hcd_qh_free(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
+extern int dwc_otg_hcd_qh_add(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
+extern void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
+extern void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh,
 				      int sched_csplit);
 
 /** Remove and free a QH */
-static inline void dwc_otg_hcd_qh_remove_and_free(dwc_otg_hcd_t * hcd,
-						  dwc_otg_qh_t * qh)
+static inline void dwc_otg_hcd_qh_remove_and_free(dwc_otg_hcd_t *hcd,
+						  dwc_otg_qh_t *qh)
 {
 	dwc_irqflags_t flags;
 	DWC_SPINLOCK_IRQSAVE(hcd->lock, &flags);
@@ -636,18 +639,19 @@ static inline dwc_otg_qh_t *dwc_otg_hcd_qh_alloc(int atomic_alloc)
 		return (dwc_otg_qh_t *) DWC_ALLOC(sizeof(dwc_otg_qh_t));
 }
 
-extern dwc_otg_qtd_t *dwc_otg_hcd_qtd_create(dwc_otg_hcd_urb_t * urb,
+extern dwc_otg_qtd_t *dwc_otg_hcd_qtd_create(dwc_otg_hcd_urb_t *urb,
 					     int atomic_alloc);
-extern void dwc_otg_hcd_qtd_init(dwc_otg_qtd_t * qtd, dwc_otg_hcd_urb_t * urb);
-extern int dwc_otg_hcd_qtd_add(dwc_otg_qtd_t * qtd, dwc_otg_hcd_t * dwc_otg_hcd,
-			       dwc_otg_qh_t ** qh, int atomic_alloc);
+extern void dwc_otg_hcd_qtd_init(dwc_otg_qtd_t *qtd, dwc_otg_hcd_urb_t *urb);
+extern int dwc_otg_hcd_qtd_add(dwc_otg_qtd_t *qtd, dwc_otg_hcd_t *dwc_otg_hcd,
+			       dwc_otg_qh_t **qh, int atomic_alloc);
 
 /** Allocates memory for a QTD structure.
  * @return Returns the memory allocate or NULL on error. */
 static inline dwc_otg_qtd_t *dwc_otg_hcd_qtd_alloc(int atomic_alloc)
 {
 	if (atomic_alloc)
-		return (dwc_otg_qtd_t *) DWC_ALLOC_ATOMIC(sizeof(dwc_otg_qtd_t));
+		return (dwc_otg_qtd_t *)
+		    DWC_ALLOC_ATOMIC(sizeof(dwc_otg_qtd_t));
 	else
 		return (dwc_otg_qtd_t *) DWC_ALLOC(sizeof(dwc_otg_qtd_t));
 }
@@ -655,7 +659,7 @@ static inline dwc_otg_qtd_t *dwc_otg_hcd_qtd_alloc(int atomic_alloc)
 /** Frees the memory for a QTD structure.  QTD should already be removed from
  * list.
  * @param qtd QTD to free.*/
-static inline void dwc_otg_hcd_qtd_free(dwc_otg_qtd_t * qtd)
+static inline void dwc_otg_hcd_qtd_free(dwc_otg_qtd_t *qtd)
 {
 	DWC_FREE(qtd);
 }
@@ -665,19 +669,19 @@ static inline void dwc_otg_hcd_qtd_free(dwc_otg_qtd_t * qtd)
  * @param qtd QTD to remove from list.
  * @param qh QTD belongs to.
  */
-static inline void dwc_otg_hcd_qtd_remove(dwc_otg_hcd_t * hcd,
-					  dwc_otg_qtd_t * qtd,
-					  dwc_otg_qh_t * qh)
+static inline void dwc_otg_hcd_qtd_remove(dwc_otg_hcd_t *hcd,
+					  dwc_otg_qtd_t *qtd,
+					  dwc_otg_qh_t *qh)
 {
 	DWC_CIRCLEQ_REMOVE(&qh->qtd_list, qtd, qtd_list_entry);
 }
 
-/** Remove and free a QTD 
-  * Need to disable IRQ and hold hcd lock while calling this function out of 
+/** Remove and free a QTD
+  * Need to disable IRQ and hold hcd lock while calling this function out of
   * interrupt servicing chain */
-static inline void dwc_otg_hcd_qtd_remove_and_free(dwc_otg_hcd_t * hcd,
-						   dwc_otg_qtd_t * qtd,
-						   dwc_otg_qh_t * qh)
+static inline void dwc_otg_hcd_qtd_remove_and_free(dwc_otg_hcd_t *hcd,
+						   dwc_otg_qtd_t *qtd,
+						   dwc_otg_qh_t *qh)
 {
 	dwc_otg_hcd_qtd_remove(hcd, qtd, qh);
 	dwc_otg_hcd_qtd_free(qtd);
@@ -688,26 +692,26 @@ static inline void dwc_otg_hcd_qtd_remove_and_free(dwc_otg_hcd_t * hcd,
 /** @name Descriptor DMA Supporting Functions */
 /** @{ */
 
-extern void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
-extern void dwc_otg_hcd_complete_xfer_ddma(dwc_otg_hcd_t * hcd,
-					   dwc_hc_t * hc,
-					   dwc_otg_hc_regs_t * hc_regs,
+extern void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
+extern void dwc_otg_hcd_complete_xfer_ddma(dwc_otg_hcd_t *hcd,
+					   dwc_hc_t *hc,
+					   dwc_otg_hc_regs_t *hc_regs,
 					   dwc_otg_halt_status_e halt_status);
 
-extern int dwc_otg_hcd_qh_init_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
-extern void dwc_otg_hcd_qh_free_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh);
+extern int dwc_otg_hcd_qh_init_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
+extern void dwc_otg_hcd_qh_free_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh);
 
 /** @} */
 
 /** @name Internal Functions */
 /** @{ */
-dwc_otg_qh_t *dwc_urb_to_qh(dwc_otg_hcd_urb_t * urb);
+dwc_otg_qh_t *dwc_urb_to_qh(dwc_otg_hcd_urb_t *urb);
 /** @} */
 
 #ifdef CONFIG_USB_DWC_OTG_LPM
-extern int dwc_otg_hcd_get_hc_for_lpm_tran(dwc_otg_hcd_t * hcd,
+extern int dwc_otg_hcd_get_hc_for_lpm_tran(dwc_otg_hcd_t *hcd,
 					   uint8_t devaddr);
-extern void dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd_t * hcd);
+extern void dwc_otg_hcd_free_hc_from_lpm(dwc_otg_hcd_t *hcd);
 #endif
 
 /** Gets the QH that contains the list_head */
@@ -768,9 +772,9 @@ static inline uint16_t dwc_micro_frame_num(uint16_t frame)
 	return frame & 0x7;
 }
 
-void dwc_otg_hcd_save_data_toggle(dwc_hc_t * hc,
-				  dwc_otg_hc_regs_t * hc_regs,
-				  dwc_otg_qtd_t * qtd);
+void dwc_otg_hcd_save_data_toggle(dwc_hc_t *hc,
+				  dwc_otg_hc_regs_t *hc_regs,
+				  dwc_otg_qtd_t *qtd);
 
 #ifdef DEBUG
 /**
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd_ddma.c b/drivers/usb/dwc_otg_310/dwc_otg_hcd_ddma.c
index 146e527ea0bd..6d70577aff47 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd_ddma.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd_ddma.c
@@ -41,10 +41,13 @@
 
 static inline uint8_t frame_list_idx(uint16_t frame)
 {
-	return (frame & (MAX_FRLIST_EN_NUM - 1));
+	uint8_t ret;
+	ret = frame & (MAX_FRLIST_EN_NUM - 1);
+	return ret;
 }
 
-static inline uint16_t desclist_idx_inc(uint16_t idx, uint16_t inc, uint8_t speed)
+static inline uint16_t desclist_idx_inc(uint16_t idx, uint16_t inc,
+					uint8_t speed)
 {
 	return (idx + inc) &
 	    (((speed ==
@@ -52,7 +55,8 @@ static inline uint16_t desclist_idx_inc(uint16_t idx, uint16_t inc, uint8_t spee
 	      MAX_DMA_DESC_NUM_GENERIC) - 1);
 }
 
-static inline uint16_t desclist_idx_dec(uint16_t idx, uint16_t inc, uint8_t speed)
+static inline uint16_t desclist_idx_dec(uint16_t idx, uint16_t inc,
+					uint8_t speed)
 {
 	return (idx - inc) &
 	    (((speed ==
@@ -60,20 +64,21 @@ static inline uint16_t desclist_idx_dec(uint16_t idx, uint16_t inc, uint8_t spee
 	      MAX_DMA_DESC_NUM_GENERIC) - 1);
 }
 
-static inline uint16_t max_desc_num(dwc_otg_qh_t * qh)
+static inline uint16_t max_desc_num(dwc_otg_qh_t *qh)
 {
 	return (((qh->ep_type == UE_ISOCHRONOUS)
 		 && (qh->dev_speed == DWC_OTG_EP_SPEED_HIGH))
 		? MAX_DMA_DESC_NUM_HS_ISOC : MAX_DMA_DESC_NUM_GENERIC);
 }
-static inline uint16_t frame_incr_val(dwc_otg_qh_t * qh)
+
+static inline uint16_t frame_incr_val(dwc_otg_qh_t *qh)
 {
 	return ((qh->dev_speed == DWC_OTG_EP_SPEED_HIGH)
 		? ((qh->interval + 8 - 1) / 8)
 		: qh->interval);
 }
 
-static int desc_list_alloc(dwc_otg_qh_t * qh)
+static int desc_list_alloc(dwc_otg_qh_t *qh)
 {
 	int retval = 0;
 
@@ -83,8 +88,9 @@ static int desc_list_alloc(dwc_otg_qh_t * qh)
 
 	if (!qh->desc_list) {
 		retval = -DWC_E_NO_MEMORY;
-		DWC_ERROR("%s: DMA descriptor list allocation failed\n", __func__);
-		
+		DWC_ERROR("%s: DMA descriptor list allocation failed\n",
+			  __func__);
+
 	}
 
 	dwc_memset(qh->desc_list, 0x00,
@@ -104,7 +110,7 @@ static int desc_list_alloc(dwc_otg_qh_t * qh)
 
 }
 
-static void desc_list_free(dwc_otg_qh_t * qh)
+static void desc_list_free(dwc_otg_qh_t *qh)
 {
 	if (qh->desc_list) {
 		DWC_DMA_FREE(max_desc_num(qh), qh->desc_list,
@@ -118,7 +124,7 @@ static void desc_list_free(dwc_otg_qh_t * qh)
 	}
 }
 
-static int frame_list_alloc(dwc_otg_hcd_t * hcd)
+static int frame_list_alloc(dwc_otg_hcd_t *hcd)
 {
 	int retval = 0;
 	if (hcd->frame_list)
@@ -136,21 +142,23 @@ static int frame_list_alloc(dwc_otg_hcd_t * hcd)
 	return retval;
 }
 
-static void frame_list_free(dwc_otg_hcd_t * hcd)
+static void frame_list_free(dwc_otg_hcd_t *hcd)
 {
 	if (!hcd->frame_list)
 		return;
-	
-	DWC_DMA_FREE(4 * MAX_FRLIST_EN_NUM, hcd->frame_list, hcd->frame_list_dma);
+
+	DWC_DMA_FREE(4 * MAX_FRLIST_EN_NUM, hcd->frame_list,
+		     hcd->frame_list_dma);
 	hcd->frame_list = NULL;
 }
 
-static void per_sched_enable(dwc_otg_hcd_t * hcd, uint16_t fr_list_en)
+static void per_sched_enable(dwc_otg_hcd_t *hcd, uint16_t fr_list_en)
 {
 
 	hcfg_data_t hcfg;
 
-	hcfg.d32 = DWC_READ_REG32(&hcd->core_if->host_if->host_global_regs->hcfg);
+	hcfg.d32 =
+	    DWC_READ_REG32(&hcd->core_if->host_if->host_global_regs->hcfg);
 
 	if (hcfg.b.perschedena) {
 		/* already enabled */
@@ -180,16 +188,18 @@ static void per_sched_enable(dwc_otg_hcd_t * hcd, uint16_t fr_list_en)
 	hcfg.b.perschedena = 1;
 
 	DWC_DEBUGPL(DBG_HCD, "Enabling Periodic schedule\n");
-	DWC_WRITE_REG32(&hcd->core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+	DWC_WRITE_REG32(&hcd->core_if->host_if->host_global_regs->hcfg,
+			hcfg.d32);
 
 }
 
-static void per_sched_disable(dwc_otg_hcd_t * hcd)
+static void per_sched_disable(dwc_otg_hcd_t *hcd)
 {
 	hcfg_data_t hcfg;
 
-	hcfg.d32 = DWC_READ_REG32(&hcd->core_if->host_if->host_global_regs->hcfg);
-	
+	hcfg.d32 =
+	    DWC_READ_REG32(&hcd->core_if->host_if->host_global_regs->hcfg);
+
 	if (!hcfg.b.perschedena) {
 		/* already disabled */
 		return;
@@ -197,14 +207,15 @@ static void per_sched_disable(dwc_otg_hcd_t * hcd)
 	hcfg.b.perschedena = 0;
 
 	DWC_DEBUGPL(DBG_HCD, "Disabling Periodic schedule\n");
-	DWC_WRITE_REG32(&hcd->core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+	DWC_WRITE_REG32(&hcd->core_if->host_if->host_global_regs->hcfg,
+			hcfg.d32);
 }
 
-/* 
- * Activates/Deactivates FrameList entries for the channel 
+/*
+ * Activates/Deactivates FrameList entries for the channel
  * based on endpoint servicing period.
  */
-void update_frame_list(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, uint8_t enable)
+void update_frame_list(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh, uint8_t enable)
 {
 	uint16_t i, j, inc;
 	dwc_hc_t *hc = NULL;
@@ -238,8 +249,7 @@ void update_frame_list(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, uint8_t enable)
 		else
 			hcd->frame_list[j] &= ~(1 << hc->hc_num);
 		j = (j + inc) & (MAX_FRLIST_EN_NUM - 1);
-	}
-	while (j != i);
+	} while (j != i);
 	if (!enable)
 		return;
 	hc->schinfo = 0;
@@ -257,7 +267,7 @@ void update_frame_list(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, uint8_t enable)
 }
 
 #if 1
-void dump_frame_list(dwc_otg_hcd_t * hcd)
+void dump_frame_list(dwc_otg_hcd_t *hcd)
 {
 	int i = 0;
 	DWC_PRINTF("--FRAME LIST (hex) --\n");
@@ -271,7 +281,7 @@ void dump_frame_list(dwc_otg_hcd_t * hcd)
 }
 #endif
 
-static void release_channel_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static void release_channel_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	dwc_hc_t *hc = qh->channel;
 	if (dwc_qh_is_non_per(qh))
@@ -279,7 +289,7 @@ static void release_channel_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	else
 		update_frame_list(hcd, qh, 0);
 
-	/* 
+	/*
 	 * The condition is added to prevent double cleanup try in case of device
 	 * disconnect. See channel cleanup in dwc_otg_hcd_disconnect_cb().
 	 */
@@ -298,10 +308,10 @@ static void release_channel_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	}
 }
 
-/** 
+/**
  * Initializes a QH structure's Descriptor DMA related members.
  * Allocates memory for descriptor list.
- * On first periodic QH, allocates memory for FrameList 
+ * On first periodic QH, allocates memory for FrameList
  * and enables periodic scheduling.
  *
  * @param hcd The HCD state structure for the DWC OTG controller.
@@ -309,14 +319,15 @@ static void release_channel_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-int dwc_otg_hcd_qh_init_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+int dwc_otg_hcd_qh_init_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	int retval = 0;
 
 	if (qh->do_split) {
-		DWC_ERROR("SPLIT Transfers are not supported in Descriptor DMA.\n");
-    		return -1;
-    	}
+		DWC_ERROR
+		    ("SPLIT Transfers are not supported in Descriptor DMA.\n");
+		return -1;
+	}
 
 	retval = desc_list_alloc(qh);
 
@@ -335,20 +346,20 @@ int dwc_otg_hcd_qh_init_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	return retval;
 }
 
-/** 
- * Frees descriptor list memory associated with the QH. 
- * If QH is periodic and the last, frees FrameList memory 
- * and disables periodic scheduling. 
+/**
+ * Frees descriptor list memory associated with the QH.
+ * If QH is periodic and the last, frees FrameList memory
+ * and disables periodic scheduling.
  *
  * @param hcd The HCD state structure for the DWC OTG controller.
  * @param qh The QH to init.
  */
-void dwc_otg_hcd_qh_free_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+void dwc_otg_hcd_qh_free_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	desc_list_free(qh);
 
-	/* 
-	 * Channel still assigned due to some reasons. 
+	/*
+	 * Channel still assigned due to some reasons.
 	 * Seen on Isoc URB dequeue. Channel halted but no subsequent
 	 * ChHalted interrupt to release the channel. Afterwards
 	 * when it comes here from endpoint disable routine
@@ -365,32 +376,36 @@ void dwc_otg_hcd_qh_free_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	}
 }
 
-static uint8_t frame_to_desc_idx(dwc_otg_qh_t * qh, uint16_t frame_idx)
+static uint8_t frame_to_desc_idx(dwc_otg_qh_t *qh, uint16_t frame_idx)
 {
+	uint8_t ret;
+
 	if (qh->dev_speed == DWC_OTG_EP_SPEED_HIGH) {
-		/* 
+		/*
 		 * Descriptor set(8 descriptors) index
 		 * which is 8-aligned.
 		 */
-		return (frame_idx & ((MAX_DMA_DESC_NUM_HS_ISOC / 8) - 1)) * 8;
+		ret = (frame_idx & ((MAX_DMA_DESC_NUM_HS_ISOC / 8) - 1)) * 8;
 	} else {
-		return (frame_idx & (MAX_DMA_DESC_NUM_GENERIC - 1));
+		ret = frame_idx & (MAX_DMA_DESC_NUM_GENERIC - 1);
 	}
+
+	return ret;
 }
 
-/* 
- * Determine starting frame for Isochronous transfer. 
- * Few frames skipped to prevent race condition with HC. 
+/*
+ * Determine starting frame for Isochronous transfer.
+ * Few frames skipped to prevent race condition with HC.
  */
-static uint8_t calc_starting_frame(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
-				   uint8_t * skip_frames)
+static uint8_t calc_starting_frame(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh,
+				   uint8_t *skip_frames)
 {
 	uint16_t frame = 0;
 	hcd->frame_number = dwc_otg_hcd_get_frame_number(hcd);
-	
+
 	/* sched_frame is always frame number(not uFrame) both in FS and HS !! */
-	
-	/* 
+
+	/*
 	 * skip_frames is used to limit activated descriptors number
 	 * to avoid the situation when HC services the last activated
 	 * descriptor firstly.
@@ -404,10 +419,10 @@ static uint8_t calc_starting_frame(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 	 * up to 11 uframes(16 in the code) may be skipped.
 	 */
 	if (qh->dev_speed == DWC_OTG_EP_SPEED_HIGH) {
-		/* 
+		/*
 		 * Consider uframe counter also, to start xfer asap.
 		 * If half of the frame elapsed skip 2 frames otherwise
-		 * just 1 frame. 
+		 * just 1 frame.
 		 * Starting descriptor index must be 8-aligned, so
 		 * if the current frame is near to complete the next one
 		 * is skipped as well.
@@ -415,15 +430,17 @@ static uint8_t calc_starting_frame(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 
 		if (dwc_micro_frame_num(hcd->frame_number) >= 5) {
 			*skip_frames = 2 * 8;
-		 	frame = dwc_frame_num_inc(hcd->frame_number, *skip_frames);
+			frame =
+			    dwc_frame_num_inc(hcd->frame_number, *skip_frames);
 		} else {
 			*skip_frames = 1 * 8;
-			frame = dwc_frame_num_inc(hcd->frame_number, *skip_frames);
+			frame =
+			    dwc_frame_num_inc(hcd->frame_number, *skip_frames);
 		}
 
 		frame = dwc_full_frame_num(frame);
 	} else {
-		/* 
+		/*
 		 * Two frames are skipped for FS - the current and the next.
 		 * But for descriptor programming, 1 frame(descriptor) is enough,
 		 * see example above.
@@ -435,23 +452,23 @@ static uint8_t calc_starting_frame(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 	return frame;
 }
 
-/* 
+/*
  * Calculate initial descriptor index for isochronous transfer
- * based on scheduled frame. 
+ * based on scheduled frame.
  */
-static uint8_t recalc_initial_desc_idx(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static uint8_t recalc_initial_desc_idx(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	uint16_t frame = 0, fr_idx, fr_idx_tmp;
 	uint8_t skip_frames = 0;
-	/* 
+	/*
 	 * With current ISOC processing algorithm the channel is being
 	 * released when no more QTDs in the list(qh->ntd == 0).
-	 * Thus this function is called only when qh->ntd == 0 and qh->channel == 0. 
+	 * Thus this function is called only when qh->ntd == 0 and qh->channel == 0.
 	 *
 	 * So qh->channel != NULL branch is not used and just not removed from the
 	 * source file. It is required for another possible approach which is,
-	 * do not disable and release the channel when ISOC session completed, 
-	 * just move QH to inactive schedule until new QTD arrives. 
+	 * do not disable and release the channel when ISOC session completed,
+	 * just move QH to inactive schedule until new QTD arrives.
 	 * On new QTD, the QH moved back to 'ready' schedule,
 	 * starting frame and therefore starting desc_index are recalculated.
 	 * In this case channel is released only on ep_disable.
@@ -460,7 +477,7 @@ static uint8_t recalc_initial_desc_idx(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	/* Calculate starting descriptor index. For INTERRUPT endpoint it is always 0. */
 	if (qh->channel) {
 		frame = calc_starting_frame(hcd, qh, &skip_frames);
-		/* 
+		/*
 		 * Calculate initial descriptor index based on FrameList current bitmap
 		 * and servicing period.
 		 */
@@ -486,7 +503,7 @@ static uint8_t recalc_initial_desc_idx(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 #define MAX_ISOC_XFER_SIZE_HS 3072
 #define DESCNUM_THRESHOLD 4
 
-static void init_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
+static void init_isoc_dma_desc(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh,
 			       uint8_t skip_frames)
 {
 	struct dwc_otg_hcd_iso_packet_desc *frame_desc;
@@ -509,13 +526,14 @@ static void init_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 
 	DWC_CIRCLEQ_FOREACH(qtd, &qh->qtd_list, qtd_list_entry) {
 		while ((qh->ntd < ntd_max)
-		       && (qtd->isoc_frame_index_last <
-			   qtd->urb->packet_count)) {
+		       && (qtd->isoc_frame_index_last < qtd->urb->packet_count)) {
 
 			dma_desc = &qh->desc_list[idx];
-			dwc_memset(dma_desc, 0x00, sizeof(dwc_otg_host_dma_desc_t));
+			dwc_memset(dma_desc, 0x00,
+				   sizeof(dwc_otg_host_dma_desc_t));
 
-			frame_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index_last];
+			frame_desc =
+			    &qtd->urb->iso_descs[qtd->isoc_frame_index_last];
 
 			if (frame_desc->length > max_xfer_size)
 				qh->n_bytes[idx] = max_xfer_size;
@@ -532,8 +550,8 @@ static void init_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 			qtd->isoc_frame_index_last++;
 
 #ifdef	ISOC_URB_GIVEBACK_ASAP
-			/* 
-			 * Set IOC for each descriptor corresponding to the 
+			/*
+			 * Set IOC for each descriptor corresponding to the
 			 * last frame of the URB.
 			 */
 			if (qtd->isoc_frame_index_last ==
@@ -557,25 +575,27 @@ static void init_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 		qh->desc_list[idx].status.b_isoc.ioc = 1;
 	}
 #else
-	/* 
-	 * Set IOC bit only for one descriptor. 
+	/*
+	 * Set IOC bit only for one descriptor.
 	 * Always try to be ahead of HW processing,
 	 * i.e. on IOC generation driver activates next descriptors but
 	 * core continues to process descriptors followed the one with IOC set.
 	 */
 
 	if (n_desc > DESCNUM_THRESHOLD) {
-		/* 
-		 * Move IOC "up". Required even if there is only one QTD 
+		/*
+		 * Move IOC "up". Required even if there is only one QTD
 		 * in the list, cause QTDs migth continue to be queued,
 		 * but during the activation it was only one queued.
-		 * Actually more than one QTD might be in the list if this function called 
+		 * Actually more than one QTD might be in the list if this function called
 		 * from XferCompletion - QTDs was queued during HW processing of the previous
 		 * descriptor chunk.
 		 */
-		idx = dwc_desclist_idx_dec(idx, inc * ((qh->ntd + 1) / 2), qh->dev_speed);
+		idx =
+		    dwc_desclist_idx_dec(idx, inc * ((qh->ntd + 1) / 2),
+					 qh->dev_speed);
 	} else {
-		/* 
+		/*
 		 * Set the IOC for the latest descriptor
 		 * if either number of descriptor is not greather than threshold
 		 * or no more new descriptors activated.
@@ -587,7 +607,7 @@ static void init_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 #endif
 }
 
-static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static void init_non_isoc_dma_desc(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 
 	dwc_hc_t *hc;
@@ -597,8 +617,8 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 	hc = qh->channel;
 
-	/* 
-	 * Start with hc->xfer_buff initialized in 
+	/*
+	 * Start with hc->xfer_buff initialized in
 	 * assign_and_init_hc(), then if SG transfer consists of multiple URBs,
 	 * this pointer re-assigned to the buffer of the currently processed QTD.
 	 * For non-SG request there is always one QTD active.
@@ -608,8 +628,10 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 		if (n_desc) {
 			/* SG request - more than 1 QTDs */
-	 		hc->xfer_buff = (uint8_t *)qtd->urb->dma + qtd->urb->actual_length;
-			hc->xfer_len = qtd->urb->length - qtd->urb->actual_length;
+			hc->xfer_buff =
+			    (uint8_t *) qtd->urb->dma + qtd->urb->actual_length;
+			hc->xfer_len =
+			    qtd->urb->length - qtd->urb->actual_length;
 		}
 
 		qtd->n_desc = 0;
@@ -623,13 +645,15 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 			if (hc->ep_is_in) {
 				if (len > 0) {
-					num_packets = (len + hc->max_packet - 1) / hc->max_packet;
+					num_packets =
+					    (len + hc->max_packet -
+					     1) / hc->max_packet;
 				} else {
 					/* Need 1 packet for transfer length of 0. */
 					num_packets = 1;
 				}
 				/* Always program an integral # of max packets for IN transfers. */
-				len = num_packets * hc->max_packet;
+				len = num_packets*hc->max_packet;
 			}
 
 			dma_desc->status.b.n_bytes = len;
@@ -646,8 +670,8 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 			dma_desc->buf =
 			    ((unsigned long)hc->xfer_buff & 0xffffffff);
 
-			/* 
-			 * Last descriptor(or single) of IN transfer 
+			/*
+			 * Last descriptor(or single) of IN transfer
 			 * with actual size less than MaxPacket.
 			 */
 			if (len > hc->xfer_len) {
@@ -659,9 +683,8 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 			qtd->n_desc++;
 			n_desc++;
-		}
-		while ((hc->xfer_len > 0) && (n_desc != MAX_DMA_DESC_NUM_GENERIC));
-		
+		} while ((hc->xfer_len > 0)
+			 && (n_desc != MAX_DMA_DESC_NUM_GENERIC));
 
 		qtd->in_process = 1;
 
@@ -682,7 +705,7 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	}
 }
 
-/** 
+/**
  * For Control and Bulk endpoints initializes descriptor list
  * and starts the transfer.
  *
@@ -690,8 +713,8 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  * then updates FrameList, marking appropriate entries as active.
  * In case of Isochronous, the starting descriptor index is calculated based
  * on the scheduled frame, but only on the first transfer descriptor within a session.
- * Then starts the transfer via enabling the channel. 
- * For Isochronous endpoint the channel is not halted on XferComplete 
+ * Then starts the transfer via enabling the channel.
+ * For Isochronous endpoint the channel is not halted on XferComplete
  * interrupt so remains assigned to the endpoint(QH) until session is done.
  *
  * @param hcd The HCD state structure for the DWC OTG controller.
@@ -699,7 +722,7 @@ static void init_non_isoc_dma_desc(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	/* Channel is already assigned */
 	dwc_hc_t *hc = qh->channel;
@@ -729,9 +752,9 @@ void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 			update_frame_list(hcd, qh, 1);
 
-			/* 
+			/*
 			 * Always set to max, instead of actual size.
-			 * Otherwise ntd will be changed with 
+			 * Otherwise ntd will be changed with
 			 * channel being enabled. Not recommended.
 			 *
 			 */
@@ -747,9 +770,9 @@ void dwc_otg_hcd_start_xfer_ddma(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	}
 }
 
-static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
-				    dwc_hc_t * hc,
-				    dwc_otg_hc_regs_t * hc_regs,
+static void complete_isoc_xfer_ddma(dwc_otg_hcd_t *hcd,
+				    dwc_hc_t *hc,
+				    dwc_otg_hc_regs_t *hc_regs,
 				    dwc_otg_halt_status_e halt_status)
 {
 	struct dwc_otg_hcd_iso_packet_desc *frame_desc;
@@ -763,15 +786,16 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 	idx = qh->td_first;
 
 	if (hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE) {
-		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list, qtd_list_entry)
+		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list,
+					 qtd_list_entry)
 		    qtd->in_process = 0;
 		return;
 	} else if ((halt_status == DWC_OTG_HC_XFER_AHB_ERR) ||
 		   (halt_status == DWC_OTG_HC_XFER_BABBLE_ERR)) {
-		/* 
+		/*
 		 * Channel is halted in these error cases.
 		 * Considered as serious issues.
-		 * Complete all URBs marking all frames as failed, 
+		 * Complete all URBs marking all frames as failed,
 		 * irrespective whether some of the descriptors(frames) succeeded or no.
 		 * Pass error code to completion routine as well, to
 		 * update urb->status, some of class drivers might use it to stop
@@ -780,8 +804,9 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 		int err = (halt_status == DWC_OTG_HC_XFER_AHB_ERR)
 		    ? (-DWC_E_IO)
 		    : (-DWC_E_OVERFLOW);
-						
-		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list, qtd_list_entry) {
+
+		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list,
+					 qtd_list_entry) {
 			for (idx = 0; idx < qtd->urb->packet_count; idx++) {
 				frame_desc = &qtd->urb->iso_descs[idx];
 				frame_desc->status = err;
@@ -792,7 +817,8 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 		return;
 	}
 
-	DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list, qtd_list_entry) {
+	DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list,
+				 qtd_list_entry) {
 
 		if (!qtd->in_process)
 			break;
@@ -802,23 +828,27 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 		do {
 
 			dma_desc = &qh->desc_list[idx];
-			
-			frame_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index];
-			remain = hc->ep_is_in ? dma_desc->status.b_isoc.n_bytes : 0;
+
+			frame_desc =
+			    &qtd->urb->iso_descs[qtd->isoc_frame_index];
+			remain =
+			    hc->ep_is_in ? dma_desc->status.b_isoc.n_bytes : 0;
 
 			if (dma_desc->status.b_isoc.sts == DMA_DESC_STS_PKTERR) {
-				/* 
-				 * XactError or, unable to complete all the transactions 
-				 * in the scheduled micro-frame/frame, 
+				/*
+				 * XactError or, unable to complete all the transactions
+				 * in the scheduled micro-frame/frame,
 				 * both indicated by DMA_DESC_STS_PKTERR.
 				 */
 				qtd->urb->error_count++;
-				frame_desc->actual_length = qh->n_bytes[idx] - remain;
+				frame_desc->actual_length =
+				    qh->n_bytes[idx] - remain;
 				frame_desc->status = -DWC_E_PROTOCOL;
 			} else {
 				/* Success */
-								
-				frame_desc->actual_length = qh->n_bytes[idx] - remain;
+
+				frame_desc->actual_length =
+				    qh->n_bytes[idx] - remain;
 				frame_desc->status = 0;
 			}
 
@@ -828,16 +858,18 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 				 * The individual frame_desc status are used instead.
 				 */
 
-				hcd->fops->complete(hcd, qtd->urb->priv, qtd->urb, 0);
+				hcd->fops->complete(hcd, qtd->urb->priv,
+						    qtd->urb, 0);
 				dwc_otg_hcd_qtd_remove_and_free(hcd, qtd, qh);
 
-				/* 
-				 * This check is necessary because urb_dequeue can be called 
+				/*
+				 * This check is necessary because urb_dequeue can be called
 				 * from urb complete callback(sound driver example).
 				 * All pending URBs are dequeued there, so no need for
 				 * further processing.
 				 */
-				if (hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE) {	
+				if (hc->halt_status ==
+				    DWC_OTG_HC_XFER_URB_DEQUEUE) {
 					return;
 				}
 
@@ -849,7 +881,9 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 
 			/* Stop if IOC requested descriptor reached */
 			if (dma_desc->status.b_isoc.ioc) {
-				idx = desclist_idx_inc(idx, qh->interval, hc->speed);	
+				idx =
+				    desclist_idx_inc(idx, qh->interval,
+						     hc->speed);
 				goto stop_scan;
 			}
 
@@ -857,19 +891,18 @@ static void complete_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 
 			if (urb_compl)
 				break;
-		}
-		while (idx != qh->td_first);
+		} while (idx != qh->td_first);
 	}
 stop_scan:
 	qh->td_first = idx;
 }
 
-uint8_t update_non_isoc_urb_state_ddma(dwc_otg_hcd_t * hcd,
-				       dwc_hc_t * hc,
-				       dwc_otg_qtd_t * qtd,
-				       dwc_otg_host_dma_desc_t * dma_desc,
+uint8_t update_non_isoc_urb_state_ddma(dwc_otg_hcd_t *hcd,
+				       dwc_hc_t *hc,
+				       dwc_otg_qtd_t *qtd,
+				       dwc_otg_host_dma_desc_t *dma_desc,
 				       dwc_otg_halt_status_e halt_status,
-				       uint32_t n_bytes, uint8_t * xfer_done)
+				       uint32_t n_bytes, uint8_t *xfer_done)
 {
 
 	uint16_t remain = hc->ep_is_in ? dma_desc->status.b.n_bytes : 0;
@@ -890,9 +923,10 @@ uint8_t update_non_isoc_urb_state_ddma(dwc_otg_hcd_t * hcd,
 		case DWC_OTG_HC_XFER_XACT_ERR:
 			urb->status = -DWC_E_PROTOCOL;
 			break;
-		default:	
-			DWC_ERROR("%s: Unhandled descriptor error status (%d)\n", __func__,
-			  	  halt_status);
+		default:
+			DWC_ERROR
+			    ("%s: Unhandled descriptor error status (%d)\n",
+			     __func__, halt_status);
 			break;
 		}
 		return 1;
@@ -909,7 +943,7 @@ uint8_t update_non_isoc_urb_state_ddma(dwc_otg_hcd_t * hcd,
 		if (qtd->control_phase == DWC_OTG_CONTROL_DATA) {
 			urb->actual_length += n_bytes - remain;
 			if (remain || urb->actual_length == urb->length) {
-				/* 
+				/*
 				 * For Control Data stage do not set urb->status=0 to prevent
 				 * URB callback. Set it when Status phase done. See below.
 				 */
@@ -933,9 +967,9 @@ uint8_t update_non_isoc_urb_state_ddma(dwc_otg_hcd_t * hcd,
 	return 0;
 }
 
-static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
-					dwc_hc_t * hc,
-					dwc_otg_hc_regs_t * hc_regs,
+static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t *hcd,
+					dwc_hc_t *hc,
+					dwc_otg_hc_regs_t *hc_regs,
 					dwc_otg_halt_status_e halt_status)
 {
 	dwc_otg_hcd_urb_t *urb = NULL;
@@ -949,7 +983,8 @@ static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 
 	qh = hc->qh;
 	if (hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE) {
-		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list, qtd_list_entry) {
+		DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &hc->qh->qtd_list,
+					 qtd_list_entry) {
 			qtd->in_process = 0;
 		}
 		return;
@@ -986,21 +1021,29 @@ static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 			} else if (qh->ep_type == UE_CONTROL) {
 				if (qtd->control_phase == DWC_OTG_CONTROL_SETUP) {
 					if (urb->length > 0) {
-						qtd->control_phase = DWC_OTG_CONTROL_DATA;
+						qtd->control_phase =
+						    DWC_OTG_CONTROL_DATA;
 					} else {
-						qtd->control_phase = DWC_OTG_CONTROL_STATUS;
+						qtd->control_phase =
+						    DWC_OTG_CONTROL_STATUS;
 					}
-					DWC_DEBUGPL(DBG_HCDV, "  Control setup transaction done\n");
-				} else if (qtd->control_phase == DWC_OTG_CONTROL_DATA) {
+					DWC_DEBUGPL(DBG_HCDV,
+						    "  Control setup transaction done\n");
+				} else if (qtd->control_phase ==
+					   DWC_OTG_CONTROL_DATA) {
 					if (xfer_done) {
-						qtd->control_phase = DWC_OTG_CONTROL_STATUS;
-						DWC_DEBUGPL(DBG_HCDV, "  Control data transfer done\n");
+						qtd->control_phase =
+						    DWC_OTG_CONTROL_STATUS;
+						DWC_DEBUGPL(DBG_HCDV,
+							    "  Control data transfer done\n");
 					} else if (i + 1 == qtd->n_desc) {
-						/* 
+						/*
 						 * Last descriptor for Control data stage which is
 						 * not completed yet.
 						 */
-						dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
+						dwc_otg_hcd_save_data_toggle(hc,
+									     hc_regs,
+									     qtd);
 					}
 				}
 			}
@@ -1013,9 +1056,9 @@ static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
 stop_scan:
 
 	if (qh->ep_type != UE_CONTROL) {
-		/* 
+		/*
 		 * Resetting the data toggle for bulk
-		 * and interrupt endpoints in case of stall. See handle_hc_stall_intr() 
+		 * and interrupt endpoints in case of stall. See handle_hc_stall_intr()
 		 */
 		if (halt_status == DWC_OTG_HC_XFER_STALL)
 			qh->data_toggle = DWC_OTG_HC_PID_DATA0;
@@ -1045,7 +1088,7 @@ static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
  * Scans the descriptor list, updates URB's status and
  * calls completion routine for the URB if it's done.
  * Releases the channel to be used by other transfers.
- * In case of Isochronous endpoint the channel is not halted until 
+ * In case of Isochronous endpoint the channel is not halted until
  * the end of the session, i.e. QTD list is empty.
  * If periodic channel released the FrameList is updated accordingly.
  *
@@ -1054,12 +1097,12 @@ static void complete_non_isoc_xfer_ddma(dwc_otg_hcd_t * hcd,
  * @param hcd The HCD state structure for the DWC OTG controller.
  * @param hc Host channel, the transfer is completed on.
  * @param hc_regs Host channel registers.
- * @param halt_status Reason the channel is being halted, 
+ * @param halt_status Reason the channel is being halted,
  *		      or just XferComplete for isochronous transfer
  */
-void dwc_otg_hcd_complete_xfer_ddma(dwc_otg_hcd_t * hcd,
-				    dwc_hc_t * hc,
-				    dwc_otg_hc_regs_t * hc_regs,
+void dwc_otg_hcd_complete_xfer_ddma(dwc_otg_hcd_t *hcd,
+				    dwc_hc_t *hc,
+				    dwc_otg_hc_regs_t *hc_regs,
 				    dwc_otg_halt_status_e halt_status)
 {
 	uint8_t continue_isoc_xfer = 0;
@@ -1089,7 +1132,7 @@ void dwc_otg_hcd_complete_xfer_ddma(dwc_otg_hcd_t * hcd,
 
 		}
 		/** @todo Consider the case when period exceeds FrameList size.
-		 *  Frame Rollover interrupt should be used. 
+		 *  Frame Rollover interrupt should be used.
 		 */
 	} else {
 		/* Scan descriptor list to complete the URB(s), then release the channel */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd_if.h b/drivers/usb/dwc_otg_310/dwc_otg_hcd_if.h
index b3dc806a87d1..3b406d8008eb 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd_if.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd_if.h
@@ -50,28 +50,28 @@ typedef struct dwc_otg_hcd_urb dwc_otg_hcd_urb_t;
 /** @{ */
 
 /** This function is called whenever core switches to host mode. */
-typedef int (*dwc_otg_hcd_start_cb_t) (dwc_otg_hcd_t * hcd);
+typedef int (*dwc_otg_hcd_start_cb_t) (dwc_otg_hcd_t *hcd);
 
 /** This function is called when device has been disconnected */
-typedef int (*dwc_otg_hcd_disconnect_cb_t) (dwc_otg_hcd_t * hcd);
+typedef int (*dwc_otg_hcd_disconnect_cb_t) (dwc_otg_hcd_t *hcd);
 
 /** Wrapper provides this function to HCD to core, so it can get hub information to which device is connected */
-typedef int (*dwc_otg_hcd_hub_info_from_urb_cb_t) (dwc_otg_hcd_t * hcd,
+typedef int (*dwc_otg_hcd_hub_info_from_urb_cb_t) (dwc_otg_hcd_t *hcd,
 						   void *urb_handle,
-						   uint32_t * hub_addr,
-						   uint32_t * port_addr);
+						   uint32_t *hub_addr,
+						   uint32_t *port_addr);
 /** Via this function HCD core gets device speed */
-typedef int (*dwc_otg_hcd_speed_from_urb_cb_t) (dwc_otg_hcd_t * hcd,
+typedef int (*dwc_otg_hcd_speed_from_urb_cb_t) (dwc_otg_hcd_t *hcd,
 						void *urb_handle);
 
 /** This function is called when urb is completed */
-typedef int (*dwc_otg_hcd_complete_urb_cb_t) (dwc_otg_hcd_t * hcd,
+typedef int (*dwc_otg_hcd_complete_urb_cb_t) (dwc_otg_hcd_t *hcd,
 					      void *urb_handle,
-					      dwc_otg_hcd_urb_t * dwc_otg_urb,
+					      dwc_otg_hcd_urb_t *dwc_otg_urb,
 					      int32_t status);
 
 /** Via this function HCD core gets b_hnp_enable parameter */
-typedef int (*dwc_otg_hcd_get_b_hnp_enable) (dwc_otg_hcd_t * hcd);
+typedef int (*dwc_otg_hcd_get_b_hnp_enable) (dwc_otg_hcd_t *hcd);
 
 struct dwc_otg_hcd_function_ops {
 	dwc_otg_hcd_start_cb_t start;
@@ -94,15 +94,15 @@ extern dwc_otg_hcd_t *dwc_otg_hcd_alloc_hcd(void);
  * @param core_if The DWC_OTG Core
  *
  * Returns -DWC_E_NO_MEMORY if no enough memory.
- * Returns 0 on success  
+ * Returns 0 on success
  */
-extern int dwc_otg_hcd_init(dwc_otg_hcd_t * hcd, dwc_otg_core_if_t * core_if);
+extern int dwc_otg_hcd_init(dwc_otg_hcd_t *hcd, dwc_otg_core_if_t *core_if);
 
 /** Frees HCD
  *
  * @param hcd The HCD
  */
-extern void dwc_otg_hcd_remove(dwc_otg_hcd_t * hcd);
+extern void dwc_otg_hcd_remove(dwc_otg_hcd_t *hcd);
 
 /** This function should be called on every hardware interrupt.
  *
@@ -111,15 +111,15 @@ extern void dwc_otg_hcd_remove(dwc_otg_hcd_t * hcd);
  * Returns non zero if interrupt is handled
  * Return 0 if interrupt is not handled
  */
-extern int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t *dwc_otg_hcd);
 
 /**
  * Returns private data set by
- * dwc_otg_hcd_set_priv_data function.
+ *dwc_otg_hcd_set_priv_data function.
  *
  * @param hcd The HCD
  */
-extern void *dwc_otg_hcd_get_priv_data(dwc_otg_hcd_t * hcd);
+extern void *dwc_otg_hcd_get_priv_data(dwc_otg_hcd_t *hcd);
 
 /**
  * Set private data.
@@ -127,7 +127,7 @@ extern void *dwc_otg_hcd_get_priv_data(dwc_otg_hcd_t * hcd);
  * @param hcd The HCD
  * @param priv_data pointer to be stored in private data
  */
-extern void dwc_otg_hcd_set_priv_data(dwc_otg_hcd_t * hcd, void *priv_data);
+extern void dwc_otg_hcd_set_priv_data(dwc_otg_hcd_t *hcd, void *priv_data);
 
 /**
  * This function initializes the HCD Core.
@@ -138,16 +138,16 @@ extern void dwc_otg_hcd_set_priv_data(dwc_otg_hcd_t * hcd, void *priv_data);
  * Returns -DWC_E_NO_DEVICE if Core is currently is in device mode.
  * Returns 0 on success
  */
-extern int dwc_otg_hcd_start(dwc_otg_hcd_t * hcd,
+extern int dwc_otg_hcd_start(dwc_otg_hcd_t *hcd,
 			     struct dwc_otg_hcd_function_ops *fops);
 
 /**
  * Halts the DWC_otg host mode operations in a clean manner. USB transfers are
- * stopped. 
+ * stopped.
  *
  * @param hcd The HCD
  */
-extern void dwc_otg_hcd_stop(dwc_otg_hcd_t * hcd);
+extern void dwc_otg_hcd_stop(dwc_otg_hcd_t *hcd);
 
 /**
  * Handles hub class-specific requests.
@@ -156,15 +156,15 @@ extern void dwc_otg_hcd_stop(dwc_otg_hcd_t * hcd);
  * @param typeReq Request Type
  * @param wValue wValue from control request
  * @param wIndex wIndex from control request
- * @param buf data buffer 
+ * @param buf data buffer
  * @param wLength data buffer length
  *
  * Returns -DWC_E_INVALID if invalid argument is passed
  * Returns 0 on success
  */
-extern int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
+extern int dwc_otg_hcd_hub_control(dwc_otg_hcd_t *dwc_otg_hcd,
 				   uint16_t typeReq, uint16_t wValue,
-				   uint16_t wIndex, uint8_t * buf,
+				   uint16_t wIndex, uint8_t *buf,
 				   uint16_t wLength);
 
 /**
@@ -172,35 +172,35 @@ extern int dwc_otg_hcd_hub_control(dwc_otg_hcd_t * dwc_otg_hcd,
  *
  * @param hcd The HCD
  */
-extern uint32_t dwc_otg_hcd_otg_port(dwc_otg_hcd_t * hcd);
+extern uint32_t dwc_otg_hcd_otg_port(dwc_otg_hcd_t *hcd);
 
 /**
  * Returns OTG version - either 1.3 or 2.0.
  *
  * @param core_if The core_if structure pointer
  */
-extern uint16_t dwc_otg_get_otg_version(dwc_otg_core_if_t * core_if);
+extern uint16_t dwc_otg_get_otg_version(dwc_otg_core_if_t *core_if);
 
 /**
  * Returns 1 if currently core is acting as B host, and 0 otherwise.
  *
  * @param hcd The HCD
  */
-extern uint32_t dwc_otg_hcd_is_b_host(dwc_otg_hcd_t * hcd);
+extern uint32_t dwc_otg_hcd_is_b_host(dwc_otg_hcd_t *hcd);
 
 /**
  * Returns current frame number.
  *
  * @param hcd The HCD
  */
-extern int dwc_otg_hcd_get_frame_number(dwc_otg_hcd_t * hcd);
+extern int dwc_otg_hcd_get_frame_number(dwc_otg_hcd_t *hcd);
 
 /**
  * Dumps hcd state.
  *
  * @param hcd The HCD
  */
-extern void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd);
+extern void dwc_otg_hcd_dump_state(dwc_otg_hcd_t *hcd);
 
 /**
  * Dump the average frame remaining at SOF. This can be used to
@@ -210,7 +210,7 @@ extern void dwc_otg_hcd_dump_state(dwc_otg_hcd_t * hcd);
  *
  * @param hcd The HCD
  */
-extern void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t * hcd);
+extern void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t *hcd);
 
 /**
  * Sends LPM transaction to the local device.
@@ -223,7 +223,7 @@ extern void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t * hcd);
  * Returns negative value if sending LPM transaction was not succeeded.
  * Returns 0 on success.
  */
-extern int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t * hcd, uint8_t devaddr,
+extern int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t *hcd, uint8_t devaddr,
 				uint8_t hird, uint8_t bRemoteWake);
 
 /* URB interface */
@@ -236,7 +236,7 @@ extern int dwc_otg_hcd_send_lpm(dwc_otg_hcd_t * hcd, uint8_t devaddr,
  * @param iso_desc_count Count of ISOC descriptors
  * @param atomic_alloc Specefies whether to perform atomic allocation.
  */
-extern dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t * hcd,
+extern dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t *hcd,
 						int iso_desc_count,
 						int atomic_alloc);
 
@@ -250,7 +250,7 @@ extern dwc_otg_hcd_urb_t *dwc_otg_hcd_urb_alloc(dwc_otg_hcd_t * hcd,
  * @param ep_dir Endpoint Direction
  * @param mps Max Packet Size
  */
-extern void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t * hcd_urb,
+extern void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t *hcd_urb,
 					 uint8_t devaddr, uint8_t ep_num,
 					 uint8_t ep_type, uint8_t ep_dir,
 					 uint16_t mps);
@@ -273,7 +273,7 @@ extern void dwc_otg_hcd_urb_set_pipeinfo(dwc_otg_hcd_urb_t * hcd_urb,
  * @param flags Transfer flags
  * @param interval Polling interval for interrupt or isochronous transfers.
  */
-extern void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t * urb,
+extern void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t *urb,
 				       void *urb_handle, void *buf,
 				       dwc_dma_t dma, uint32_t buflen, void *sp,
 				       dwc_dma_t sp_dma, uint32_t flags,
@@ -283,7 +283,7 @@ extern void dwc_otg_hcd_urb_set_params(dwc_otg_hcd_urb_t * urb,
  *
  * @param dwc_otg_urb DWC_OTG URB
  */
-extern uint32_t dwc_otg_hcd_urb_get_status(dwc_otg_hcd_urb_t * dwc_otg_urb);
+extern uint32_t dwc_otg_hcd_urb_get_status(dwc_otg_hcd_urb_t *dwc_otg_urb);
 
 /** Gets actual length from dwc_otg_hcd_urb
  *
@@ -306,14 +306,14 @@ extern uint32_t dwc_otg_hcd_urb_get_error_count(dwc_otg_hcd_urb_t *
  * @param offset Offset from beginig of buffer.
  * @param length Transaction length
  */
-extern void dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_hcd_urb_t * dwc_otg_urb,
+extern void dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_hcd_urb_t *dwc_otg_urb,
 						int desc_num, uint32_t offset,
 						uint32_t length);
 
 /** Get status of ISOC descriptor, specified by desc_num
  *
  * @param dwc_otg_urb DWC_OTG URB
- * @param desc_num ISOC descriptor number 
+ * @param desc_num ISOC descriptor number
  */
 extern uint32_t dwc_otg_hcd_urb_get_iso_desc_status(dwc_otg_hcd_urb_t *
 						    dwc_otg_urb, int desc_num);
@@ -338,8 +338,8 @@ extern uint32_t dwc_otg_hcd_urb_get_iso_desc_actual_length(dwc_otg_hcd_urb_t *
  * Returns -DWC_E_NO_MEMORY if there is no enough memory.
  * Returns 0 on success.
  */
-extern int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * dwc_otg_hcd,
-				   dwc_otg_hcd_urb_t * dwc_otg_urb,
+extern int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t *dwc_otg_hcd,
+				   dwc_otg_hcd_urb_t *dwc_otg_urb,
 				   void **ep_handle, int atomic_alloc);
 
 /** De-queue the specified URB
@@ -347,8 +347,8 @@ extern int dwc_otg_hcd_urb_enqueue(dwc_otg_hcd_t * dwc_otg_hcd,
  * @param dwc_otg_hcd The HCD
  * @param dwc_otg_urb DWC_OTG URB
  */
-extern int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t * dwc_otg_hcd,
-				   dwc_otg_hcd_urb_t * dwc_otg_urb);
+extern int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t *dwc_otg_hcd,
+				   dwc_otg_hcd_urb_t *dwc_otg_urb);
 
 /** Frees resources in the DWC_otg controller related to a given endpoint.
  * Any URBs for the endpoint must already be dequeued.
@@ -360,7 +360,7 @@ extern int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_t * dwc_otg_hcd,
  * Returns -DWC_E_INVALID if invalid arguments are passed.
  * Returns 0 on success
  */
-extern int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t * hcd, void *ep_handle,
+extern int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t *hcd, void *ep_handle,
 					int retry);
 
 /* Resets the data toggle in qh structure. This function can be called from
@@ -372,14 +372,14 @@ extern int dwc_otg_hcd_endpoint_disable(dwc_otg_hcd_t * hcd, void *ep_handle,
  * Returns -DWC_E_INVALID if invalid arguments are passed.
  * Returns 0 on success
  */
-extern int dwc_otg_hcd_endpoint_reset(dwc_otg_hcd_t * hcd, void *ep_handle);
+extern int dwc_otg_hcd_endpoint_reset(dwc_otg_hcd_t *hcd, void *ep_handle);
 
 /** Returns 1 if status of specified port is changed and 0 otherwise.
  *
  * @param hcd The HCD
  * @param port Port number
  */
-extern int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t * hcd, int port);
+extern int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t *hcd, int port);
 
 /** Call this function to check if bandwidth was allocated for specified endpoint.
  * Only for ISOC and INTERRUPT endpoints.
@@ -387,7 +387,7 @@ extern int dwc_otg_hcd_is_status_changed(dwc_otg_hcd_t * hcd, int port);
  * @param hcd The HCD
  * @param ep_handle Endpoint handle
  */
-extern int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t * hcd,
+extern int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t *hcd,
 					      void *ep_handle);
 
 /** Call this function to check if bandwidth was freed for specified endpoint.
@@ -395,7 +395,7 @@ extern int dwc_otg_hcd_is_bandwidth_allocated(dwc_otg_hcd_t * hcd,
  * @param hcd The HCD
  * @param ep_handle Endpoint handle
  */
-extern int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t * hcd, void *ep_handle);
+extern int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t *hcd, void *ep_handle);
 
 /** Returns bandwidth allocated for specified endpoint in microseconds.
  * Only for ISOC and INTERRUPT endpoints.
@@ -403,7 +403,7 @@ extern int dwc_otg_hcd_is_bandwidth_freed(dwc_otg_hcd_t * hcd, void *ep_handle);
  * @param hcd The HCD
  * @param ep_handle Endpoint handle
  */
-extern uint8_t dwc_otg_hcd_get_ep_bandwidth(dwc_otg_hcd_t * hcd,
+extern uint8_t dwc_otg_hcd_get_ep_bandwidth(dwc_otg_hcd_t *hcd,
 					    void *ep_handle);
 
 /** @} */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd_intr.c b/drivers/usb/dwc_otg_310/dwc_otg_hcd_intr.c
index de629e0e72d9..fb6de91b5a5d 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd_intr.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd_intr.c
@@ -35,7 +35,7 @@
 #include "dwc_otg_hcd.h"
 #include "dwc_otg_regs.h"
 #include <linux/usb.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
 #include <../drivers/usb/core/hcd.h>
 #else
 #include <linux/usb/hcd.h>
@@ -45,7 +45,7 @@
  */
 
 /** This function handles interrupts for the HCD. */
-int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	int retval = 0;
 	dwc_irqflags_t flags;
@@ -55,9 +55,9 @@ int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 #ifdef DEBUG
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
 #endif
-	
-	if (dwc_otg_check_haps_status(core_if) == -1 ) {
-		DWC_WARN("HAPS is disconnected");			
+
+	if (dwc_otg_check_haps_status(core_if) == -1) {
+		DWC_WARN("HAPS is disconnected");
 		return retval;
 	}
 
@@ -153,9 +153,9 @@ static inline void track_missed_sofs(uint16_t curr_frame_number)
 {
 	static uint16_t frame_num_array[FRAME_NUM_ARRAY_SIZE];
 	static uint16_t last_frame_num_array[FRAME_NUM_ARRAY_SIZE];
-	static int frame_num_idx = 0;
+	static int frame_num_idx;
 	static uint16_t last_frame_num = DWC_HFNUM_MAX_FRNUM;
-	static int dumped_frame_num_array = 0;
+	static int dumped_frame_num_array;
 
 	if (frame_num_idx < FRAME_NUM_ARRAY_SIZE) {
 		if (((last_frame_num + 1) & DWC_HFNUM_MAX_FRNUM) !=
@@ -183,7 +183,7 @@ static inline void track_missed_sofs(uint16_t curr_frame_number)
  * (micro)frame. Periodic transactions may be queued to the controller for the
  * next (micro)frame.
  */
-int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t * hcd)
+int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t *hcd)
 {
 	hfnum_data_t hfnum;
 	dwc_list_link_t *qh_entry;
@@ -236,7 +236,7 @@ int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t * hcd)
 /** Handles the Rx Status Queue Level Interrupt, which indicates that there is at
  * least one packet in the Rx FIFO.  The packets are moved from the FIFO to
  * memory if the DWC_otg controller is operating in Slave mode. */
-int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	host_grxsts_data_t grxsts;
 	dwc_hc_t *hc = NULL;
@@ -289,7 +289,7 @@ int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd_t * dwc_otg_hcd)
  * data packets may be written to the FIFO for OUT transfers. More requests
  * may be written to the non-periodic request queue for IN transfers. This
  * interrupt is enabled only in Slave mode. */
-int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Non-Periodic TxFIFO Empty Interrupt--\n");
 	dwc_otg_hcd_queue_transactions(dwc_otg_hcd,
@@ -301,7 +301,7 @@ int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_t * dwc_otg_hcd)
  * packets may be written to the FIFO for OUT transfers. More requests may be
  * written to the periodic request queue for IN transfers. This interrupt is
  * enabled only in Slave mode. */
-int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Periodic TxFIFO Empty Interrupt--\n");
 	dwc_otg_hcd_queue_transactions(dwc_otg_hcd,
@@ -309,11 +309,11 @@ int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 	return 1;
 }
 
-extern inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t * dwc_otg_hcd);
+extern inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t *dwc_otg_hcd);
 /** There are multiple conditions that can cause a port interrupt. This function
  * determines which interrupt conditions have occurred and handles them
  * appropriately. */
-int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	int retval = 0;
 	hprt0_data_t hprt0;
@@ -335,37 +335,42 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 	/* Port Connect Detected
 	 * Set flag and clear if detected */
 	if (dwc_otg_hcd->core_if->hibernation_suspend == 1) {
-		// Dont modify port status if we are in hibernation state
+		/* Dont modify port status if we are in hibernation state */
 		hprt0_modify.b.prtconndet = 1;
 		hprt0_modify.b.prtenchng = 1;
-		DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->hprt0, hprt0_modify.d32);
-		hprt0.d32 = DWC_READ_REG32(dwc_otg_hcd->core_if->host_if->hprt0);
+		DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->hprt0,
+				hprt0_modify.d32);
+		hprt0.d32 =
+		    DWC_READ_REG32(dwc_otg_hcd->core_if->host_if->hprt0);
 		return retval;
 	}
 
 	if (hprt0.b.prtconndet) {
 		/** @todo - check if steps performed in 'else' block should be perfromed regardles adp */
-		if (dwc_otg_hcd->core_if->adp_enable && 	
-				dwc_otg_hcd->core_if->adp.vbuson_timer_started == 1) {
+		if (dwc_otg_hcd->core_if->adp_enable &&
+		    dwc_otg_hcd->core_if->adp.vbuson_timer_started == 1) {
 			DWC_PRINTF("PORT CONNECT DETECTED ----------------\n");
-			DWC_TIMER_CANCEL(dwc_otg_hcd->core_if->adp.vbuson_timer);
+			DWC_TIMER_CANCEL(dwc_otg_hcd->core_if->adp.
+					 vbuson_timer);
 			dwc_otg_hcd->core_if->adp.vbuson_timer_started = 0;
 			/* TODO - check if this is required, as
 			 * host initialization was already performed
 			 * after initial ADP probing
 			 */
 			/*dwc_otg_hcd->core_if->adp.vbuson_timer_started = 0;
-			dwc_otg_core_init(dwc_otg_hcd->core_if);
-			dwc_otg_enable_global_interrupts(dwc_otg_hcd->core_if);
-			cil_hcd_start(dwc_otg_hcd->core_if);*/
+			   dwc_otg_core_init(dwc_otg_hcd->core_if);
+			   dwc_otg_enable_global_interrupts(dwc_otg_hcd->core_if);
+			   cil_hcd_start(dwc_otg_hcd->core_if); */
 		} else {
 			hprt0_data_t hprt0_local;
 			/* check if root hub is in suspend state
 			 * if root hub in suspend, resume it.
 			 */
-			if ((bus->root_hub) && (hcd->state == HC_STATE_SUSPENDED) ) {
-				DWC_PRINTF("%s: hcd->state = %d, hcd->flags = %ld\n",
-						__func__, hcd->state, hcd->flags);
+			if ((bus->root_hub)
+			    && (hcd->state == HC_STATE_SUSPENDED)) {
+				DWC_PRINTF
+				    ("%s: hcd->state = %d, hcd->flags = %ld\n",
+				     __func__, hcd->state, hcd->flags);
 				usb_hcd_resume_root_hub(hcd);
 			}
 			DWC_DEBUGPL(DBG_HCD, "--Port Interrupt HPRT0=0x%08x "
@@ -374,16 +379,21 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 			dwc_otg_hcd->flags.b.port_connect_status = 1;
 			hprt0_modify.b.prtconndet = 1;
 			/* PET testing */
-			if (dwc_otg_hcd->core_if->otg_ver && (dwc_otg_hcd->core_if->test_mode == 7)) {
-				hprt0_local.d32 = dwc_otg_read_hprt0(dwc_otg_hcd->core_if);
+			if (dwc_otg_hcd->core_if->otg_ver
+			    && (dwc_otg_hcd->core_if->test_mode == 7)) {
+				hprt0_local.d32 =
+				    dwc_otg_read_hprt0(dwc_otg_hcd->core_if);
 				hprt0_local.b.prtrst = 1;
-				DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->hprt0, hprt0_local.d32);
+				DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->
+						hprt0, hprt0_local.d32);
 				dwc_mdelay(60);
-				hprt0.d32 = dwc_otg_read_hprt0(dwc_otg_hcd->core_if);
+				hprt0.d32 =
+				    dwc_otg_read_hprt0(dwc_otg_hcd->core_if);
 				hprt0.b.prtrst = 0;
-				DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->hprt0, hprt0.d32);
+				DWC_WRITE_REG32(dwc_otg_hcd->core_if->host_if->
+						hprt0, hprt0.d32);
 			}
-	
+
 			/* B-Device has connected, Delete the connection timer. */
 			DWC_TIMER_CANCEL(dwc_otg_hcd->conn_timer);
 		}
@@ -407,13 +417,16 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 			    dwc_otg_hcd->core_if->core_global_regs;
 			dwc_otg_host_if_t *host_if =
 			    dwc_otg_hcd->core_if->host_if;
-			    
+
 			/* Every time when port enables calculate
 			 * HFIR.FrInterval
 			 */
-			hfir.d32 = DWC_READ_REG32(&host_if->host_global_regs->hfir);
-			hfir.b.frint = calc_frame_interval(dwc_otg_hcd->core_if);
-			DWC_WRITE_REG32(&host_if->host_global_regs->hfir, hfir.d32);
+			hfir.d32 =
+			    DWC_READ_REG32(&host_if->host_global_regs->hfir);
+			hfir.b.frint =
+			    calc_frame_interval(dwc_otg_hcd->core_if);
+			DWC_WRITE_REG32(&host_if->host_global_regs->hfir,
+					hfir.d32);
 
 			/* Check if we need to adjust the PHY clock speed for
 			 * low power and adjust it */
@@ -447,8 +460,7 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 					    DWC_HPRT0_PRTSPD_LOW_SPEED
 					    && params->host_ls_low_power_phy_clk
 					    ==
-					    DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ)
-					{
+					    DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ) {
 						/* 6 MHZ */
 						DWC_DEBUGPL(DBG_CIL,
 							    "FS_PHY programming HCFG to 6 MHz (Low Power)\n");
@@ -457,8 +469,9 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 							hcfg.b.fslspclksel =
 							    DWC_HCFG_6_MHZ;
 							DWC_WRITE_REG32
-							    (&host_if->host_global_regs->hcfg,
-							     hcfg.d32);
+							    (&host_if->
+							     host_global_regs->
+							     hcfg, hcfg.d32);
 							do_reset = 1;
 						}
 					} else {
@@ -470,8 +483,9 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 							hcfg.b.fslspclksel =
 							    DWC_HCFG_48_MHZ;
 							DWC_WRITE_REG32
-							    (&host_if->host_global_regs->hcfg,
-							     hcfg.d32);
+							    (&host_if->
+							     host_global_regs->
+							     hcfg, hcfg.d32);
 							do_reset = 1;
 						}
 					}
@@ -489,7 +503,8 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
 				}
 
 				if (do_reset) {
-					DWC_TASK_SCHEDULE(dwc_otg_hcd->reset_tasklet);
+					DWC_TASK_SCHEDULE(dwc_otg_hcd->
+							  reset_tasklet);
 				}
 			}
 
@@ -522,7 +537,7 @@ int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * dwc_otg_hcd)
  * interrupt. There are multiple conditions that can cause each host channel
  * interrupt. This function determines which conditions have occurred for each
  * host channel interrupt and handles them appropriately. */
-int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t * dwc_otg_hcd)
+int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	int i;
 	int retval = 0;
@@ -552,9 +567,9 @@ int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t * dwc_otg_hcd)
  * return. short_read may also be NULL on entry, in which case it remains
  * unchanged.
  */
-static uint32_t get_actual_xfer_length(dwc_hc_t * hc,
-				       dwc_otg_hc_regs_t * hc_regs,
-				       dwc_otg_qtd_t * qtd,
+static uint32_t get_actual_xfer_length(dwc_hc_t *hc,
+				       dwc_otg_hc_regs_t *hc_regs,
+				       dwc_otg_qtd_t *qtd,
 				       dwc_otg_halt_status_e halt_status,
 				       int *short_read)
 {
@@ -603,10 +618,10 @@ static uint32_t get_actual_xfer_length(dwc_hc_t * hc,
  * @return 1 if the data transfer specified by the URB is completely finished,
  * 0 otherwise.
  */
-static int update_urb_state_xfer_comp(dwc_hc_t * hc,
-				      dwc_otg_hc_regs_t * hc_regs,
-				      dwc_otg_hcd_urb_t * urb,
-				      dwc_otg_qtd_t * qtd)
+static int update_urb_state_xfer_comp(dwc_hc_t *hc,
+				      dwc_otg_hc_regs_t *hc_regs,
+				      dwc_otg_hcd_urb_t *urb,
+				      dwc_otg_qtd_t *qtd)
 {
 	int xfer_done = 0;
 	int short_read = 0;
@@ -617,7 +632,6 @@ static int update_urb_state_xfer_comp(dwc_hc_t * hc,
 					     DWC_OTG_HC_XFER_COMPLETE,
 					     &short_read);
 
-
 	/* non DWORD-aligned buffer case handling. */
 	if (hc->align_buff && xfer_length && hc->ep_is_in) {
 		dwc_memcpy(urb->buf + urb->actual_length, hc->qh->dw_align_buf,
@@ -635,7 +649,6 @@ static int update_urb_state_xfer_comp(dwc_hc_t * hc,
 		xfer_done = 1;
 		urb->status = 0;
 	}
-	
 #ifdef DEBUG
 	{
 		hctsiz_data_t hctsiz;
@@ -663,8 +676,9 @@ static int update_urb_state_xfer_comp(dwc_hc_t * hc,
  * saved in the QH for non-control transfers and it's saved in the QTD for
  * control transfers.
  */
-void dwc_otg_hcd_save_data_toggle(dwc_hc_t * hc,
-			     dwc_otg_hc_regs_t * hc_regs, dwc_otg_qtd_t * qtd)
+void dwc_otg_hcd_save_data_toggle(dwc_hc_t *hc,
+				  dwc_otg_hc_regs_t *hc_regs,
+				  dwc_otg_qtd_t *qtd)
 {
 	hctsiz_data_t hctsiz;
 	hctsiz.d32 = DWC_READ_REG32(&hc_regs->hctsiz);
@@ -695,10 +709,10 @@ void dwc_otg_hcd_save_data_toggle(dwc_hc_t * hc,
  * transferred in the URB. Otherwise return DWC_OTG_HC_XFER_URB_COMPLETE.
  */
 static dwc_otg_halt_status_e
-update_isoc_urb_state(dwc_otg_hcd_t * hcd,
-		      dwc_hc_t * hc,
-		      dwc_otg_hc_regs_t * hc_regs,
-		      dwc_otg_qtd_t * qtd, dwc_otg_halt_status_e halt_status)
+update_isoc_urb_state(dwc_otg_hcd_t *hcd,
+		      dwc_hc_t *hc,
+		      dwc_otg_hc_regs_t *hc_regs,
+		      dwc_otg_qtd_t *qtd, dwc_otg_halt_status_e halt_status)
 {
 	dwc_otg_hcd_urb_t *urb = qtd->urb;
 	dwc_otg_halt_status_e ret_val = halt_status;
@@ -713,10 +727,11 @@ update_isoc_urb_state(dwc_otg_hcd_t * hcd,
 
 		/* non DWORD-aligned buffer case handling. */
 		if (hc->align_buff && frame_desc->actual_length && hc->ep_is_in) {
-			dwc_memcpy(urb->buf + frame_desc->offset + qtd->isoc_split_offset,
-				   hc->qh->dw_align_buf, frame_desc->actual_length);
+			dwc_memcpy(urb->buf + frame_desc->offset +
+				   qtd->isoc_split_offset, hc->qh->dw_align_buf,
+				   frame_desc->actual_length);
 		}
-		
+
 		break;
 	case DWC_OTG_HC_XFER_FRAME_OVERRUN:
 		urb->error_count++;
@@ -740,8 +755,9 @@ update_isoc_urb_state(dwc_otg_hcd_t * hcd,
 
 		/* non DWORD-aligned buffer case handling. */
 		if (hc->align_buff && frame_desc->actual_length && hc->ep_is_in) {
-			dwc_memcpy(urb->buf + frame_desc->offset + qtd->isoc_split_offset,
-				   hc->qh->dw_align_buf, frame_desc->actual_length);
+			dwc_memcpy(urb->buf + frame_desc->offset +
+				   qtd->isoc_split_offset, hc->qh->dw_align_buf,
+				   frame_desc->actual_length);
 		}
 		/* Skip whole frame */
 		if (hc->qh->do_split && (hc->ep_type == DWC_OTG_EP_TYPE_ISOC) &&
@@ -775,7 +791,7 @@ update_isoc_urb_state(dwc_otg_hcd_t * hcd,
  * non-periodic schedule. For periodic QHs, removes the QH from the periodic
  * schedule if no more QTDs are linked to the QH.
  */
-static void deactivate_qh(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, int free_qtd)
+static void deactivate_qh(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh, int free_qtd)
 {
 	int continue_split = 0;
 	dwc_otg_qtd_t *qtd;
@@ -811,9 +827,9 @@ static void deactivate_qh(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, int free_qtd)
  * @param halt_status Reason the channel is being released. This status
  * determines the actions taken by this function.
  */
-static void release_channel(dwc_otg_hcd_t * hcd,
-			    dwc_hc_t * hc,
-			    dwc_otg_qtd_t * qtd,
+static void release_channel(dwc_otg_hcd_t *hcd,
+			    dwc_hc_t *hc,
+			    dwc_otg_qtd_t *qtd,
 			    dwc_otg_halt_status_e halt_status)
 {
 	dwc_otg_transaction_type_e tr_type;
@@ -822,19 +838,22 @@ static void release_channel(dwc_otg_hcd_t * hcd,
 	DWC_DEBUGPL(DBG_HCDV, "  %s: channel %d, halt_status %d\n",
 		    __func__, hc->hc_num, halt_status);
 
-	if(halt_status != DWC_OTG_HC_XFER_URB_DEQUEUE){
-		if(((uint32_t) qtd & 0xf0000000)==0){
-			DWC_PRINTF("%s error: qtd %p, status %d 0!!!\n", __func__, qtd, halt_status);
+	if (halt_status != DWC_OTG_HC_XFER_URB_DEQUEUE) {
+		if (((uint32_t) qtd & 0xf0000000) == 0) {
+			DWC_PRINTF("%s error: qtd %p, status %d 0!!!\n",
+				   __func__, qtd, halt_status);
 			goto cleanup;
 		}
 
-		if(((uint32_t) qtd & 0x80000000)==0){
-			DWC_PRINTF("%s error: qtd %p, status %d 1!!!\n", __func__, qtd, halt_status);
+		if (((uint32_t) qtd & 0x80000000) == 0) {
+			DWC_PRINTF("%s error: qtd %p, status %d 1!!!\n",
+				   __func__, qtd, halt_status);
 			goto cleanup;
 		}
 
-		if(((uint32_t) qtd->urb & 0xf0000000)==0){
-			DWC_PRINTF("%s qtd %p urb %p, status %d\n", __func__, qtd, qtd->urb, halt_status);
+		if (((uint32_t) qtd->urb & 0xf0000000) == 0) {
+			DWC_PRINTF("%s qtd %p urb %p, status %d\n", __func__,
+				   qtd, qtd->urb, halt_status);
 			goto cleanup;
 		}
 	}
@@ -871,12 +890,10 @@ static void release_channel(dwc_otg_hcd_t * hcd,
 		free_qtd = 0;
 		break;
 	case DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE:
-		DWC_DEBUGPL(DBG_HCDV,
-			"  Complete URB with I/O error\n");
+		DWC_DEBUGPL(DBG_HCDV, "  Complete URB with I/O error\n");
 		free_qtd = 1;
 		qtd->urb->status = -DWC_E_IO;
-		hcd->fops->complete(hcd, qtd->urb->priv,
-			qtd->urb, -DWC_E_IO);
+		hcd->fops->complete(hcd, qtd->urb->priv, qtd->urb, -DWC_E_IO);
 		break;
 	default:
 		free_qtd = 0;
@@ -926,9 +943,9 @@ static void release_channel(dwc_otg_hcd_t * hcd,
  * simply released since the core always halts the channel automatically in
  * DMA mode.
  */
-static void halt_channel(dwc_otg_hcd_t * hcd,
-			 dwc_hc_t * hc,
-			 dwc_otg_qtd_t * qtd, dwc_otg_halt_status_e halt_status)
+static void halt_channel(dwc_otg_hcd_t *hcd,
+			 dwc_hc_t *hc,
+			 dwc_otg_qtd_t *qtd, dwc_otg_halt_status_e halt_status)
 {
 	if (hcd->core_if->dma_enable) {
 		release_channel(hcd, hc, qtd, halt_status);
@@ -978,10 +995,10 @@ static void halt_channel(dwc_otg_hcd_t * hcd,
  * Complete interrupt. This function should be called after any endpoint type
  * specific handling is finished to release the host channel.
  */
-static void complete_non_periodic_xfer(dwc_otg_hcd_t * hcd,
-				       dwc_hc_t * hc,
-				       dwc_otg_hc_regs_t * hc_regs,
-				       dwc_otg_qtd_t * qtd,
+static void complete_non_periodic_xfer(dwc_otg_hcd_t *hcd,
+				       dwc_hc_t *hc,
+				       dwc_otg_hc_regs_t *hc_regs,
+				       dwc_otg_qtd_t *qtd,
 				       dwc_otg_halt_status_e halt_status)
 {
 	hcint_data_t hcint;
@@ -1030,10 +1047,10 @@ static void complete_non_periodic_xfer(dwc_otg_hcd_t * hcd,
  * interrupt. This function should be called after any endpoint type specific
  * handling is finished to release the host channel.
  */
-static void complete_periodic_xfer(dwc_otg_hcd_t * hcd,
-				   dwc_hc_t * hc,
-				   dwc_otg_hc_regs_t * hc_regs,
-				   dwc_otg_qtd_t * qtd,
+static void complete_periodic_xfer(dwc_otg_hcd_t *hcd,
+				   dwc_hc_t *hc,
+				   dwc_otg_hc_regs_t *hc_regs,
+				   dwc_otg_qtd_t *qtd,
 				   dwc_otg_halt_status_e halt_status)
 {
 	hctsiz_data_t hctsiz;
@@ -1049,10 +1066,10 @@ static void complete_periodic_xfer(dwc_otg_hcd_t * hcd,
 	}
 }
 
-static int32_t handle_xfercomp_isoc_split_in(dwc_otg_hcd_t * hcd,
-					     dwc_hc_t * hc,
-					     dwc_otg_hc_regs_t * hc_regs,
-					     dwc_otg_qtd_t * qtd)
+static int32_t handle_xfercomp_isoc_split_in(dwc_otg_hcd_t *hcd,
+					     dwc_hc_t *hc,
+					     dwc_otg_hc_regs_t *hc_regs,
+					     dwc_otg_qtd_t *qtd)
 {
 	uint32_t len;
 	struct dwc_otg_hcd_iso_packet_desc *frame_desc;
@@ -1094,10 +1111,10 @@ static int32_t handle_xfercomp_isoc_split_in(dwc_otg_hcd_t * hcd,
  * Handles a host channel Transfer Complete interrupt. This handler may be
  * called in either DMA mode or Slave mode.
  */
-static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * hcd,
-				       dwc_hc_t * hc,
-				       dwc_otg_hc_regs_t * hc_regs,
-				       dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t *hcd,
+				       dwc_hc_t *hc,
+				       dwc_otg_hc_regs_t *hc_regs,
+				       dwc_otg_qtd_t *qtd)
 {
 	int urb_xfer_done;
 	dwc_otg_halt_status_e halt_status = DWC_OTG_HC_XFER_COMPLETE;
@@ -1107,14 +1124,14 @@ static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * hcd,
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "Transfer Complete--\n", hc->hc_num);
 
-	if(((uint32_t) qtd & 0xf0000000)==0){
+	if (((uint32_t) qtd & 0xf0000000) == 0) {
 		DWC_PRINTF("%s qtd %p\n", __func__, qtd);
 		release_channel(hcd, hc, qtd, hc->halt_status);
 		return 1;
 	}
 
 	urb = qtd->urb;
-	if(((uint32_t)urb & 0xf0000000)==0){
+	if (((uint32_t) urb & 0xf0000000) == 0) {
 		DWC_PRINTF("%s qtd %p, urb %p\n", __func__, qtd, urb);
 		release_channel(hcd, hc, qtd, hc->halt_status);
 		return 1;
@@ -1172,7 +1189,9 @@ static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * hcd,
 					DWC_DEBUGPL(DBG_HCDV,
 						    "  Control data transfer done\n");
 				} else {
-					dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
+					dwc_otg_hcd_save_data_toggle(hc,
+								     hc_regs,
+								     qtd);
 				}
 				halt_status = DWC_OTG_HC_XFER_COMPLETE;
 				break;
@@ -1206,17 +1225,17 @@ static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * hcd,
 	case UE_INTERRUPT:
 		DWC_DEBUGPL(DBG_HCDV, "  Interrupt transfer complete\n");
 		urb_xfer_done =
-			update_urb_state_xfer_comp(hc, hc_regs, urb, qtd);
+		    update_urb_state_xfer_comp(hc, hc_regs, urb, qtd);
 
 		/*
 		 * Interrupt URB is done on the first transfer complete
 		 * interrupt.
 		 */
 		if (urb_xfer_done) {
-				hcd->fops->complete(hcd, urb->priv, urb, urb->status);
-				halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
+			hcd->fops->complete(hcd, urb->priv, urb, urb->status);
+			halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
 		} else {
-				halt_status = DWC_OTG_HC_XFER_COMPLETE;
+			halt_status = DWC_OTG_HC_XFER_COMPLETE;
 		}
 
 		dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
@@ -1243,10 +1262,10 @@ static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel STALL interrupt. This handler may be called in
  * either DMA mode or Slave mode.
  */
-static int32_t handle_hc_stall_intr(dwc_otg_hcd_t * hcd,
-				    dwc_hc_t * hc,
-				    dwc_otg_hc_regs_t * hc_regs,
-				    dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_stall_intr(dwc_otg_hcd_t *hcd,
+				    dwc_hc_t *hc,
+				    dwc_otg_hc_regs_t *hc_regs,
+				    dwc_otg_qtd_t *qtd)
 {
 	dwc_otg_hcd_urb_t *urb = qtd->urb;
 	int pipe_type = dwc_otg_hcd_get_pipe_type(&urb->pipe_info);
@@ -1255,7 +1274,8 @@ static int32_t handle_hc_stall_intr(dwc_otg_hcd_t * hcd,
 		    "STALL Received--\n", hc->hc_num);
 
 	if (hcd->core_if->dma_desc_enable) {
-		dwc_otg_hcd_complete_xfer_ddma(hcd, hc, hc_regs, DWC_OTG_HC_XFER_STALL);
+		dwc_otg_hcd_complete_xfer_ddma(hcd, hc, hc_regs,
+					       DWC_OTG_HC_XFER_STALL);
 		goto handle_stall_done;
 	}
 
@@ -1289,10 +1309,10 @@ static int32_t handle_hc_stall_intr(dwc_otg_hcd_t * hcd,
  * actual_length field of the URB to reflect the number of bytes that have
  * actually been transferred via the host channel.
  */
-static void update_urb_state_xfer_intr(dwc_hc_t * hc,
-				       dwc_otg_hc_regs_t * hc_regs,
-				       dwc_otg_hcd_urb_t * urb,
-				       dwc_otg_qtd_t * qtd,
+static void update_urb_state_xfer_intr(dwc_hc_t *hc,
+				       dwc_otg_hc_regs_t *hc_regs,
+				       dwc_otg_hcd_urb_t *urb,
+				       dwc_otg_qtd_t *qtd,
 				       dwc_otg_halt_status_e halt_status)
 {
 	uint32_t bytes_transferred = get_actual_xfer_length(hc, hc_regs, qtd,
@@ -1330,10 +1350,10 @@ static void update_urb_state_xfer_intr(dwc_hc_t * hc,
  * Handles a host channel NAK interrupt. This handler may be called in either
  * DMA mode or Slave mode.
  */
-static int32_t handle_hc_nak_intr(dwc_otg_hcd_t * hcd,
-				  dwc_hc_t * hc,
-				  dwc_otg_hc_regs_t * hc_regs,
-				  dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_nak_intr(dwc_otg_hcd_t *hcd,
+				  dwc_hc_t *hc,
+				  dwc_otg_hc_regs_t *hc_regs,
+				  dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "NAK Received--\n", hc->hc_num);
@@ -1410,10 +1430,10 @@ static int32_t handle_hc_nak_intr(dwc_otg_hcd_t * hcd,
  * performing the PING protocol in Slave mode, when errors occur during
  * either Slave mode or DMA mode, and during Start Split transactions.
  */
-static int32_t handle_hc_ack_intr(dwc_otg_hcd_t * hcd,
-				  dwc_hc_t * hc,
-				  dwc_otg_hc_regs_t * hc_regs,
-				  dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_ack_intr(dwc_otg_hcd_t *hcd,
+				  dwc_hc_t *hc,
+				  dwc_otg_hc_regs_t *hc_regs,
+				  dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "ACK Received--\n", hc->hc_num);
@@ -1452,8 +1472,8 @@ static int32_t handle_hc_ack_intr(dwc_otg_hcd_t * hcd,
 					*frame_desc;
 
 					frame_desc =
-					    &qtd->urb->
-					    iso_descs[qtd->isoc_frame_index];
+					    &qtd->urb->iso_descs[qtd->
+								 isoc_frame_index];
 					qtd->isoc_split_offset += 188;
 
 					if ((frame_desc->length -
@@ -1504,10 +1524,10 @@ static int32_t handle_hc_ack_intr(dwc_otg_hcd_t * hcd,
  * handled in the xfercomp interrupt handler, not here. This handler may be
  * called in either DMA mode or Slave mode.
  */
-static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t * hcd,
-				   dwc_hc_t * hc,
-				   dwc_otg_hc_regs_t * hc_regs,
-				   dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t *hcd,
+				   dwc_hc_t *hc,
+				   dwc_otg_hc_regs_t *hc_regs,
+				   dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "NYET Received--\n", hc->hc_num);
@@ -1522,14 +1542,16 @@ static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t * hcd,
 			qtd->complete_split = 0;
 			qtd->isoc_split_offset = 0;
 			if (++qtd->isoc_frame_index == qtd->urb->packet_count) {
-				hcd->fops->complete(hcd, qtd->urb->priv, qtd->urb, 0);
-				release_channel(hcd, hc, qtd, DWC_OTG_HC_XFER_URB_COMPLETE);	
-			}
-			else
-				release_channel(hcd, hc, qtd, DWC_OTG_HC_XFER_NO_HALT_STATUS);	
+				hcd->fops->complete(hcd, qtd->urb->priv,
+						    qtd->urb, 0);
+				release_channel(hcd, hc, qtd,
+						DWC_OTG_HC_XFER_URB_COMPLETE);
+			} else
+				release_channel(hcd, hc, qtd,
+						DWC_OTG_HC_XFER_NO_HALT_STATUS);
 			goto handle_nyet_done;
 		}
-		
+
 		if (hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
 		    hc->ep_type == DWC_OTG_EP_TYPE_ISOC) {
 			int frnum = dwc_otg_hcd_get_frame_number(hcd);
@@ -1583,10 +1605,10 @@ static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel babble interrupt. This handler may be called in
  * either DMA mode or Slave mode.
  */
-static int32_t handle_hc_babble_intr(dwc_otg_hcd_t * hcd,
-				     dwc_hc_t * hc,
-				     dwc_otg_hc_regs_t * hc_regs,
-				     dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_babble_intr(dwc_otg_hcd_t *hcd,
+				     dwc_hc_t *hc,
+				     dwc_otg_hc_regs_t *hc_regs,
+				     dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "Babble Error--\n", hc->hc_num);
@@ -1617,10 +1639,10 @@ static int32_t handle_hc_babble_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel AHB error interrupt. This handler is only called in
  * DMA mode.
  */
-static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t * hcd,
-				     dwc_hc_t * hc,
-				     dwc_otg_hc_regs_t * hc_regs,
-				     dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t *hcd,
+				     dwc_hc_t *hc,
+				     dwc_otg_hc_regs_t *hc_regs,
+				     dwc_otg_qtd_t *qtd)
 {
 	hcchar_data_t hcchar;
 	hcsplt_data_t hcsplt;
@@ -1717,10 +1739,10 @@ static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel transaction error interrupt. This handler may be
  * called in either DMA mode or Slave mode.
  */
-static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t * hcd,
-				      dwc_hc_t * hc,
-				      dwc_otg_hc_regs_t * hc_regs,
-				      dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t *hcd,
+				      dwc_hc_t *hc,
+				      dwc_otg_hc_regs_t *hc_regs,
+				      dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "Transaction Error--\n", hc->hc_num);
@@ -1780,10 +1802,10 @@ static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel frame overrun interrupt. This handler may be called
  * in either DMA mode or Slave mode.
  */
-static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t * hcd,
-				       dwc_hc_t * hc,
-				       dwc_otg_hc_regs_t * hc_regs,
-				       dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t *hcd,
+				       dwc_hc_t *hc,
+				       dwc_otg_hc_regs_t *hc_regs,
+				       dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "Frame Overrun--\n", hc->hc_num);
@@ -1816,10 +1838,10 @@ static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t * hcd,
  * Handles a host channel data toggle error interrupt. This handler may be
  * called in either DMA mode or Slave mode.
  */
-static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t * hcd,
-					 dwc_hc_t * hc,
-					 dwc_otg_hc_regs_t * hc_regs,
-					 dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t *hcd,
+					 dwc_hc_t *hc,
+					 dwc_otg_hc_regs_t *hc_regs,
+					 dwc_otg_qtd_t *qtd)
 {
 	DWC_ERROR("--Host Channel %d Interrupt: "
 		  "Data Toggle Error--\n", hc->hc_num);
@@ -1829,14 +1851,14 @@ static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t * hcd,
 		return 1;
 	}
 	if (hc->ep_is_in) {
-		qtd->error_count += 3;//Complete the error URB immediately
+		qtd->error_count += 3;	/* Complete the error URB immediately */
 	} else {
 		DWC_ERROR("Data Toggle Error on OUT transfer,"
 			  "channel %d\n", hc->hc_num);
 	}
 	dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
 	halt_channel(hcd, hc, qtd, DWC_OTG_HC_XFER_XACT_ERR);
-	clear_hc_int(hc_regs,chhltd);
+	clear_hc_int(hc_regs, chhltd);
 
 	return 1;
 }
@@ -1848,10 +1870,10 @@ static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t * hcd,
  * taken and a warning is issued.
  * @return 1 if halt status is ok, 0 otherwise.
  */
-static inline int halt_status_ok(dwc_otg_hcd_t * hcd,
-				 dwc_hc_t * hc,
-				 dwc_otg_hc_regs_t * hc_regs,
-				 dwc_otg_qtd_t * qtd)
+static inline int halt_status_ok(dwc_otg_hcd_t *hcd,
+				 dwc_hc_t *hc,
+				 dwc_otg_hc_regs_t *hc_regs,
+				 dwc_otg_qtd_t *qtd)
 {
 	hcchar_data_t hcchar;
 	hctsiz_data_t hctsiz;
@@ -1908,10 +1930,10 @@ static inline int halt_status_ok(dwc_otg_hcd_t * hcd,
  * Handles a host Channel Halted interrupt in DMA mode. This handler
  * determines the reason the channel halted and proceeds accordingly.
  */
-static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * hcd,
-				      dwc_hc_t * hc,
-				      dwc_otg_hc_regs_t * hc_regs,
-				      dwc_otg_qtd_t * qtd)
+static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t *hcd,
+				      dwc_hc_t *hc,
+				      dwc_otg_hc_regs_t *hc_regs,
+				      dwc_otg_qtd_t *qtd)
 {
 	hcint_data_t hcint;
 	hcintmsk_data_t hcintmsk;
@@ -1986,10 +2008,9 @@ static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * hcd,
 		handle_hc_babble_intr(hcd, hc, hc_regs, qtd);
 	} else if (hcint.b.frmovrun) {
 		handle_hc_frmovrun_intr(hcd, hc, hc_regs, qtd);
-	} else if(hcint.b.datatglerr){
-        handle_hc_datatglerr_intr(hcd, hc, hc_regs, qtd);
-	}
-	else if (!out_nak_enh) {
+	} else if (hcint.b.datatglerr) {
+		handle_hc_datatglerr_intr(hcd, hc, hc_regs, qtd);
+	} else if (!out_nak_enh) {
 		if (hcint.b.nyet) {
 			/*
 			 * Must handle nyet before nak or ack. Could get a nyet at the
@@ -2035,18 +2056,17 @@ static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * hcd,
 				    ("%s: Channel %d, DMA Mode -- ChHltd set, but reason "
 				     "for halting is unknown, hcint 0x%08x, intsts 0x%08x\n",
 				     __func__, hc->hc_num, hcint.d32,
-				     DWC_READ_REG32(&hcd->
-						    core_if->core_global_regs->
-						    gintsts));
-					 clear_hc_int(hc_regs,chhltd);
+				     DWC_READ_REG32(&hcd->core_if->
+						    core_global_regs->gintsts));
+				clear_hc_int(hc_regs, chhltd);
 			}
 
 		}
 	} else {
 		DWC_PRINTF("NYET/NAK/ACK/other in non-error case, 0x%08x\n",
 			   hcint.d32);
-		if(!hcint.b.nyet && !hcint.b.nak  && !hcint.b.ack)
-			clear_hc_int(hc_regs,chhltd);
+		if (!hcint.b.nyet && !hcint.b.nak && !hcint.b.ack)
+			clear_hc_int(hc_regs, chhltd);
 	}
 }
 
@@ -2061,10 +2081,10 @@ static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * hcd,
  * processing a transfer on a channel. Other host channel interrupts (except
  * ahberr) are disabled in DMA mode.
  */
-static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t * hcd,
-				     dwc_hc_t * hc,
-				     dwc_otg_hc_regs_t * hc_regs,
-				     dwc_otg_qtd_t * qtd)
+static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t *hcd,
+				     dwc_hc_t *hc,
+				     dwc_otg_hc_regs_t *hc_regs,
+				     dwc_otg_qtd_t *qtd)
 {
 	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
 		    "Channel Halted--\n", hc->hc_num);
@@ -2084,7 +2104,7 @@ static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t * hcd,
 }
 
 /** Handles interrupt for a specific Host Channel */
-int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t * dwc_otg_hcd, uint32_t num)
+int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t *dwc_otg_hcd, uint32_t num)
 {
 	int retval = 0;
 	hcint_data_t hcint;
@@ -2135,8 +2155,9 @@ int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t * dwc_otg_hcd, uint32_t num)
 		retval |= handle_hc_nak_intr(dwc_otg_hcd, hc, hc_regs, qtd);
 	}
 	if (hcint.b.ack) {
-		if(!hcint.b.chhltd)
-			retval |= handle_hc_ack_intr(dwc_otg_hcd, hc, hc_regs, qtd);
+		if (!hcint.b.chhltd)
+			retval |=
+			    handle_hc_ack_intr(dwc_otg_hcd, hc, hc_regs, qtd);
 	}
 	if (hcint.b.nyet) {
 		retval |= handle_hc_nyet_intr(dwc_otg_hcd, hc, hc_regs, qtd);
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd_linux.c b/drivers/usb/dwc_otg_310/dwc_otg_hcd_linux.c
index 6ab5719fb78c..7da1cd71e0d6 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd_linux.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd_linux.c
@@ -51,7 +51,7 @@
 #include <linux/version.h>
 #include <asm/io.h>
 #include <linux/usb.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
 #include <../drivers/usb/core/hcd.h>
 #else
 #include <linux/usb/hcd.h>
@@ -76,18 +76,18 @@ static const char dwc_otg_hcd_name[] = "dwc_otg_hcd";
 /** @name Linux HC Driver API Functions */
 /** @{ */
 static int urb_enqueue(struct usb_hcd *hcd,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 		       struct usb_host_endpoint *ep,
 #endif
 		       struct urb *urb, gfp_t mem_flags);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb);
 #else
 static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
 #endif
 
 static void endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 static void endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep);
 #endif
 static irqreturn_t dwc_otg_hcd_irq(struct usb_hcd *hcd);
@@ -117,24 +117,24 @@ static struct hc_driver dwc_otg_hc_driver = {
 
 	.flags = HCD_MEMORY | HCD_USB2,
 
-	//.reset =              
+	/* .reset = */
 	.start = hcd_start,
-	//.suspend =            
-	//.resume =             
+	/* .suspend = */
+	/* .resume = */
 	.stop = hcd_stop,
 
 	.urb_enqueue = urb_enqueue,
 	.urb_dequeue = urb_dequeue,
 	.endpoint_disable = endpoint_disable,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 	.endpoint_reset = endpoint_reset,
 #endif
 	.get_frame_number = get_frame_number,
 
 	.hub_status_data = hub_status_data,
 	.hub_control = hub_control,
-	.bus_suspend = hcd_suspend ,              
-	.bus_resume = hcd_resume,       
+	.bus_suspend = hcd_suspend,
+	.bus_resume = hcd_resume,
 };
 
 /** Gets the dwc_otg_hcd from a struct usb_hcd */
@@ -146,10 +146,11 @@ static inline dwc_otg_hcd_t *hcd_to_dwc_otg_hcd(struct usb_hcd *hcd)
 }
 
 /** Gets the struct usb_hcd that contains a dwc_otg_hcd_t. */
-inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t * dwc_otg_hcd)
+inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t *dwc_otg_hcd)
 {
 	return dwc_otg_hcd_get_priv_data(dwc_otg_hcd);
 }
+
 EXPORT_SYMBOL(dwc_otg_hcd_to_hcd);
 
 /** Gets the usb_host_endpoint associated with an URB. */
@@ -167,7 +168,7 @@ inline struct usb_host_endpoint *dwc_urb_to_endpoint(struct urb *urb)
 		return dev->ep_out[ep_num];
 }
 
-static int _disconnect(dwc_otg_hcd_t * hcd)
+static int _disconnect(dwc_otg_hcd_t *hcd)
 {
 	struct usb_hcd *usb_hcd = dwc_otg_hcd_to_hcd(hcd);
 
@@ -175,7 +176,7 @@ static int _disconnect(dwc_otg_hcd_t * hcd)
 	return 0;
 }
 
-static int _start(dwc_otg_hcd_t * hcd)
+static int _start(dwc_otg_hcd_t *hcd)
 {
 	struct usb_hcd *usb_hcd = dwc_otg_hcd_to_hcd(hcd);
 
@@ -185,8 +186,8 @@ static int _start(dwc_otg_hcd_t * hcd)
 	return 0;
 }
 
-static int _hub_info(dwc_otg_hcd_t * hcd, void *urb_handle, uint32_t * hub_addr,
-		     uint32_t * port_addr)
+static int _hub_info(dwc_otg_hcd_t *hcd, void *urb_handle, uint32_t *hub_addr,
+		     uint32_t *port_addr)
 {
 	struct urb *urb = (struct urb *)urb_handle;
 	if (urb->dev->tt) {
@@ -198,13 +199,13 @@ static int _hub_info(dwc_otg_hcd_t * hcd, void *urb_handle, uint32_t * hub_addr,
 	return 0;
 }
 
-static int _speed(dwc_otg_hcd_t * hcd, void *urb_handle)
+static int _speed(dwc_otg_hcd_t *hcd, void *urb_handle)
 {
 	struct urb *urb = (struct urb *)urb_handle;
 	return urb->dev->speed;
 }
 
-static int _get_b_hnp_enable(dwc_otg_hcd_t * hcd)
+static int _get_b_hnp_enable(dwc_otg_hcd_t *hcd)
 {
 	struct usb_hcd *usb_hcd = dwc_otg_hcd_to_hcd(hcd);
 	return usb_hcd->self.b_hnp_enable;
@@ -236,8 +237,8 @@ static void free_bus_bandwidth(struct usb_hcd *hcd, uint32_t bw,
  * Sets the final status of an URB and returns it to the device driver. Any
  * required cleanup of the URB is performed.
  */
-static int _complete(dwc_otg_hcd_t * hcd, void *urb_handle,
-		     dwc_otg_hcd_urb_t * dwc_otg_urb, int32_t status)
+static int _complete(dwc_otg_hcd_t *hcd, void *urb_handle,
+		     dwc_otg_hcd_urb_t *dwc_otg_urb, int32_t status)
 {
 	struct urb *urb = (struct urb *)urb_handle;
 #ifdef DEBUG
@@ -312,7 +313,8 @@ static int _complete(dwc_otg_hcd_t * hcd, void *urb_handle,
 		if (ep) {
 			free_bus_bandwidth(dwc_otg_hcd_to_hcd(hcd),
 					   dwc_otg_hcd_get_ep_bandwidth(hcd,
-									ep->hcpriv),
+									ep->
+									hcpriv),
 					   urb);
 		}
 	}
@@ -320,7 +322,7 @@ static int _complete(dwc_otg_hcd_t * hcd, void *urb_handle,
 	DWC_FREE(dwc_otg_urb);
 
 	DWC_SPINUNLOCK(hcd->lock);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 	usb_hcd_giveback_urb(dwc_otg_hcd_to_hcd(hcd), urb);
 #else
 	usb_hcd_giveback_urb(dwc_otg_hcd_to_hcd(hcd), urb, status);
@@ -334,9 +336,8 @@ void dwc_otg_clear_halt(struct urb *_urb)
 {
 	struct dwc_otg_qh *_qh;
 	struct usb_host_endpoint *ep = dwc_urb_to_endpoint(_urb);
-	if((ep)&&(ep->hcpriv))
-	{
-		_qh =  (dwc_otg_qh_t *) ep->hcpriv;
+	if ((ep) && (ep->hcpriv)) {
+		_qh = (dwc_otg_qh_t *) ep->hcpriv;
 		_qh->data_toggle = 0;
 	}
 }
@@ -349,6 +350,7 @@ static struct dwc_otg_hcd_function_ops hcd_fops = {
 	.complete = _complete,
 	.get_b_hnp_enable = _get_b_hnp_enable,
 };
+
 static void dwc_otg_hcd_enable(struct work_struct *work)
 {
 	dwc_otg_hcd_t *dwc_otg_hcd;
@@ -357,33 +359,34 @@ static void dwc_otg_hcd_enable(struct work_struct *work)
 	dwc_otg_hcd = container_of(work, dwc_otg_hcd_t, host_enable_work.work);
 	core_if = dwc_otg_hcd->core_if;
 	pldata = core_if->otg_dev->pldata;
-	if(dwc_otg_hcd->host_enabled == dwc_otg_hcd->host_setenable){
-//	DWC_PRINT("%s, enable flag %d\n", __func__, dwc_otg_hcd->host_setenable);
+	if (dwc_otg_hcd->host_enabled == dwc_otg_hcd->host_setenable) {
+	/* DWC_PRINT("%s, enable flag %d\n",
+	 * 	     __func__, dwc_otg_hcd->host_setenable); */
 		goto out;
 	}
-	    
-	if(dwc_otg_hcd->host_setenable == 2){// enable -> disable
-		if(pldata->get_status(USB_STATUS_DPDM)){// usb device connected
+
+	if (dwc_otg_hcd->host_setenable == 2) {/* enable -> disable */
+		if (pldata->get_status(USB_STATUS_DPDM)) {/* usb device connected */
 			dwc_otg_hcd->host_setenable = 1;
 			goto out;
 		}
 		DWC_PRINTF("%s, disable host controller\n", __func__);
 #if 0
 		if (_core_if->hcd_cb && _core_if->hcd_cb->disconnect) {
-		_core_if->hcd_cb->disconnect( _core_if->hcd_cb->p );
+			_core_if->hcd_cb->disconnect(_core_if->hcd_cb->p);
 		}
 #endif
 		pldata->soft_reset();
-		dwc_otg_disable_host_interrupts( core_if );
-		if(pldata->phy_suspend) 
-			pldata->phy_suspend( pldata, USB_PHY_SUSPEND);
+		dwc_otg_disable_host_interrupts(core_if);
+		if (pldata->phy_suspend)
+			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 		udelay(3);
-		pldata->clock_enable( pldata, 0);
-	}else if(dwc_otg_hcd->host_setenable == 1){
+		pldata->clock_enable(pldata, 0);
+	} else if (dwc_otg_hcd->host_setenable == 1) {
 		DWC_PRINTF("%s, enable host controller\n", __func__);
-		pldata->clock_enable( pldata, 1);
-		if(pldata->phy_suspend) 
-			pldata->phy_suspend( pldata, USB_PHY_ENABLED);
+		pldata->clock_enable(pldata, 1);
+		if (pldata->phy_suspend)
+			pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 		mdelay(5);
 		dwc_otg_core_init(core_if);
 		dwc_otg_enable_global_interrupts(core_if);
@@ -393,39 +396,41 @@ static void dwc_otg_hcd_enable(struct work_struct *work)
 out:
 	return;
 }
+
 static void dwc_otg_hcd_connect_detect(unsigned long pdata)
 {
-	dwc_otg_hcd_t *dwc_otg_hcd = (dwc_otg_hcd_t *)pdata;
+	dwc_otg_hcd_t *dwc_otg_hcd = (dwc_otg_hcd_t *) pdata;
 	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
 	unsigned long flags;
 	struct dwc_otg_platform_data *pldata;
 	pldata = core_if->otg_dev->pldata;
 	local_irq_save(flags);
-	if(pldata->get_status(USB_STATUS_DPDM)) // usb device connected   
-	{
+	if (pldata->get_status(USB_STATUS_DPDM)) {
+		/* usb device connected */
 		dwc_otg_hcd->host_setenable = 1;
+	} else {
+		/* no device, suspend host */
+		if ((dwc_otg_read_hprt0(core_if) & 1) == 0)
+			dwc_otg_hcd->host_setenable = 2;
 	}
-	else
-	{                                   // no device, suspend host    
-	if((dwc_otg_read_hprt0(core_if) & 1) == 0)
-		dwc_otg_hcd->host_setenable = 2;
-	}
-	if((dwc_otg_hcd->host_enabled) && (dwc_otg_hcd->host_setenable != dwc_otg_hcd->host_enabled)){
+	if ((dwc_otg_hcd->host_enabled)
+	    && (dwc_otg_hcd->host_setenable != dwc_otg_hcd->host_enabled)) {
 		schedule_delayed_work(&dwc_otg_hcd->host_enable_work, 1);
 	}
-	mod_timer(&dwc_otg_hcd->connect_detect_timer,jiffies + (HZ<<1)); 
+	mod_timer(&dwc_otg_hcd->connect_detect_timer, jiffies + (HZ << 1));
 	local_irq_restore(flags);
 	return;
 }
 
 static void otg20_hcd_connect_detect(struct work_struct *work)
 {
-	dwc_otg_hcd_t *dwc_otg_hcd = container_of(work, dwc_otg_hcd_t, host_enable_work.work);
+	dwc_otg_hcd_t *dwc_otg_hcd =
+	    container_of(work, dwc_otg_hcd_t, host_enable_work.work);
 	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
 	struct dwc_otg_platform_data *pldata;
 	pldata = core_if->otg_dev->pldata;
 
-	if( pldata->phy_status == USB_PHY_SUSPEND){
+	if (pldata->phy_status == USB_PHY_SUSPEND) {
 		pldata->clock_enable(pldata, 1);
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 	}
@@ -440,7 +445,7 @@ static void otg20_hcd_connect_detect(struct work_struct *work)
  * USB bus with the core and calls the hc_driver->start() function. It returns
  * a negative error on failure.
  */
-int otg20_hcd_init( struct platform_device *_dev )
+int otg20_hcd_init(struct platform_device *_dev)
 {
 	struct usb_hcd *hcd = NULL;
 	dwc_otg_hcd_t *dwc_otg_hcd = NULL;
@@ -467,13 +472,15 @@ int otg20_hcd_init( struct platform_device *_dev )
 	 * Allocate memory for the base HCD plus the DWC OTG HCD.
 	 * Initialize the base HCD.
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
 	hcd = usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev, _dev->dev.bus_id);
 #else
-	hcd = usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev, dev_name(&_dev->dev));
+	hcd =
+	    usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev,
+			   dev_name(&_dev->dev));
 	hcd->has_tt = 1;
-//      hcd->uses_new_polling = 1;
-//      hcd->poll_rh = 0;
+	/* hcd->uses_new_polling = 1; */
+	/* hcd->poll_rh = 0; */
 #endif
 	if (!hcd) {
 		retval = -ENOMEM;
@@ -497,22 +504,25 @@ int otg20_hcd_init( struct platform_device *_dev )
 
 	otg_dev->hcd->otg_dev = otg_dev;
 	hcd->self.otg_port = dwc_otg_hcd_otg_port(dwc_otg_hcd);
-#if 0//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) //don't support for LM(with 2.6.20.1 kernel)
+#if 0
+	/* #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33) */
+	/* don't support for LM(with 2.6.20.1 kernel) */
 	hcd->self.otg_version = dwc_otg_get_otg_version(otg_dev->core_if);
 	/* Don't support SG list at this point */
 	hcd->self.sg_tablesize = 0;
 #endif
-#if 0//LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+#if 0
+	/* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
 	/* Do not to do HNP polling if not capable */
-	//if (otg_dev->core_if->otg_ver)
-	//	hcd->self.is_hnp_cap = dwc_otg_get_hnpcapable(otg_dev->core_if);
+	/* if (otg_dev->core_if->otg_ver) */
+	/*      hcd->self.is_hnp_cap = dwc_otg_get_hnpcapable(otg_dev->core_if); */
 #endif
 	/*
 	 * Finish generic HCD initialization and start the HCD. This function
 	 * allocates the DMA buffer pool, registers the USB bus, requests the
 	 * IRQ line, and calls hcd_start method.
 	 */
-	irq = platform_get_irq(_dev,0);
+	irq = platform_get_irq(_dev, 0);
 	retval = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
 	if (retval < 0) {
 		goto error2;
@@ -520,10 +530,11 @@ int otg20_hcd_init( struct platform_device *_dev )
 
 	dwc_otg_hcd_set_priv_data(dwc_otg_hcd, hcd);
 	dwc_otg_hcd->host_enabled = 1;
-	if(dwc_otg_is_host_mode(otg_dev->core_if) ||
-	  (otg_dev->core_if->usb_mode == USB_MODE_FORCE_HOST)){
-		INIT_DELAYED_WORK(&dwc_otg_hcd->host_enable_work, otg20_hcd_connect_detect);
-		schedule_delayed_work(&dwc_otg_hcd->host_enable_work, HZ>>2);
+	if (dwc_otg_is_host_mode(otg_dev->core_if) ||
+	    (otg_dev->core_if->usb_mode == USB_MODE_FORCE_HOST)) {
+		INIT_DELAYED_WORK(&dwc_otg_hcd->host_enable_work,
+				  otg20_hcd_connect_detect);
+		schedule_delayed_work(&dwc_otg_hcd->host_enable_work, HZ >> 2);
 	}
 	return 0;
 
@@ -533,14 +544,13 @@ int otg20_hcd_init( struct platform_device *_dev )
 	return retval;
 }
 
-
 /**
  * Initializes the HCD. This function allocates memory for and initializes the
  * static parts of the usb_hcd and dwc_otg_hcd structures. It also registers the
  * USB bus with the core and calls the hc_driver->start() function. It returns
  * a negative error on failure.
  */
-int host20_hcd_init( struct platform_device *_dev )
+int host20_hcd_init(struct platform_device *_dev)
 {
 	struct usb_hcd *hcd = NULL;
 	dwc_otg_hcd_t *dwc_otg_hcd = NULL;
@@ -548,7 +558,7 @@ int host20_hcd_init( struct platform_device *_dev )
 	dwc_otg_device_t *otg_dev = dwc_get_device_platform_data(_dev);
 	int retval = 0;
 	int irq;
-	static u64 usb_dmamask = 0xffffffffUL; 
+	static u64 usb_dmamask = 0xffffffffUL;
 	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD INIT\n");
 
 	/* Set device flags indicating whether the HCD supports DMA. */
@@ -566,13 +576,15 @@ int host20_hcd_init( struct platform_device *_dev )
 	 * Allocate memory for the base HCD plus the DWC OTG HCD.
 	 * Initialize the base HCD.
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
 	hcd = usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev, _dev->dev.bus_id);
 #else
-	hcd = usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev, dev_name(&_dev->dev));
+	hcd =
+	    usb_create_hcd(&dwc_otg_hc_driver, &_dev->dev,
+			   dev_name(&_dev->dev));
 	hcd->has_tt = 1;
-//      hcd->uses_new_polling = 1;
-//      hcd->poll_rh = 0;
+	/* hcd->uses_new_polling = 1; */
+	/* hcd->poll_rh = 0; */
 #endif
 	if (!hcd) {
 		retval = -ENOMEM;
@@ -596,22 +608,25 @@ int host20_hcd_init( struct platform_device *_dev )
 
 	otg_dev->hcd->otg_dev = otg_dev;
 	hcd->self.otg_port = dwc_otg_hcd_otg_port(dwc_otg_hcd);
-#if 0//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33) //don't support for LM(with 2.6.20.1 kernel)
+#if 0
+	/* #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33) */
+	/* don't support for LM(with 2.6.20.1 kernel) */
 	hcd->self.otg_version = dwc_otg_get_otg_version(otg_dev->core_if);
 	/* Don't support SG list at this point */
 	hcd->self.sg_tablesize = 0;
 #endif
-#if 0//LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+#if 0
+	/* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0) */
 	/* Do not to do HNP polling if not capable */
-	//if (otg_dev->core_if->otg_ver)
-	//	hcd->self.is_hnp_cap = dwc_otg_get_hnpcapable(otg_dev->core_if);
+	/* if (otg_dev->core_if->otg_ver) */
+	/*      hcd->self.is_hnp_cap = dwc_otg_get_hnpcapable(otg_dev->core_if);*/
 #endif
 	/*
 	 * Finish generic HCD initialization and start the HCD. This function
 	 * allocates the DMA buffer pool, registers the USB bus, requests the
 	 * IRQ line, and calls hcd_start method.
 	 */
-	irq = platform_get_irq(_dev,0);
+	irq = platform_get_irq(_dev, 0);
 	retval = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
 	if (retval < 0) {
 		goto error2;
@@ -623,9 +638,9 @@ int host20_hcd_init( struct platform_device *_dev )
 	dwc_otg_hcd->host_setenable = 2;
 	dwc_otg_hcd->connect_detect_timer.function = dwc_otg_hcd_connect_detect;
 	dwc_otg_hcd->connect_detect_timer.data = (unsigned long)(dwc_otg_hcd);
-	init_timer( &dwc_otg_hcd->connect_detect_timer);
-	mod_timer(&dwc_otg_hcd->connect_detect_timer, jiffies+(HZ<<3)); 
-    
+	init_timer(&dwc_otg_hcd->connect_detect_timer);
+	mod_timer(&dwc_otg_hcd->connect_detect_timer, jiffies + (HZ << 3));
+
 	INIT_DELAYED_WORK(&dwc_otg_hcd->host_enable_work, dwc_otg_hcd_enable);
 	return 0;
 
@@ -639,10 +654,7 @@ int host20_hcd_init( struct platform_device *_dev )
  * Removes the HCD.
  * Frees memory and resources associated with the HCD and deregisters the bus.
  */
-void hcd_remove(
-
-		       struct platform_device *_dev
-    )
+void hcd_remove(struct platform_device *_dev)
 {
 
 	dwc_otg_device_t *otg_dev = dwc_get_device_platform_data(_dev);
@@ -720,34 +732,32 @@ void hcd_stop(struct usb_hcd *hcd)
 	dwc_otg_hcd_stop(dwc_otg_hcd);
 }
 
-
 static int dwc_otg_hcd_suspend(struct usb_hcd *hcd)
 {
-	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (hcd);
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
 	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
 	hprt0_data_t hprt0;
 	pcgcctl_data_t pcgcctl;
 	struct dwc_otg_platform_data *pldata;
 	pldata = core_if->otg_dev->pldata;
 
-	if(core_if->op_state == B_PERIPHERAL){
+	if (core_if->op_state == B_PERIPHERAL) {
 		DWC_PRINTF("%s, usb device mode\n", __func__);
 		return 0;
 	}
 
-	if(!(dwc_otg_hcd->host_enabled&1))
+	if (!(dwc_otg_hcd->host_enabled & 1))
 		return 0;
 
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
-#ifdef CONFIG_PM_RUNTIME    
-	if((!hprt0.b.prtena) && (!hprt0.b.prtpwr))
+#ifdef CONFIG_PM_RUNTIME
+	if ((!hprt0.b.prtena) && (!hprt0.b.prtpwr))
 		return 0;
-#endif        
-	DWC_PRINTF("%s suspend, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32);
+#endif
+	DWC_PRINTF("%s suspend, HPRT0:0x%x\n", hcd->self.bus_name, hprt0.d32);
 
-	if(hprt0.b.prtconnsts){ // usb device connected
-		if(!hprt0.b.prtsusp)
-		{
+	if (hprt0.b.prtconnsts) { /* usb device connected */
+		if (!hprt0.b.prtsusp) {
 			hprt0.b.prtsusp = 1;
 			hprt0.b.prtena = 0;
 			DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
@@ -755,8 +765,7 @@ static int dwc_otg_hcd_suspend(struct usb_hcd *hcd)
 		udelay(10);
 		hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
 
-		if(!hprt0.b.prtsusp)
-		{
+		if (!hprt0.b.prtsusp) {
 			hprt0.b.prtsusp = 1;
 			hprt0.b.prtena = 0;
 			DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
@@ -764,94 +773,91 @@ static int dwc_otg_hcd_suspend(struct usb_hcd *hcd)
 		mdelay(5);
 
 		pcgcctl.d32 = DWC_READ_REG32(core_if->pcgcctl);
-		//Partial Power-Down mode not enable
+		/* Partial Power-Down mode not enable */
 		pcgcctl.b.pwrclmp = 0;
 		DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
 		udelay(1);
-		//pcgcctl.b.rstpdwnmodule = 1;//reset PDM
-		pcgcctl.b.stoppclk = 1;//stop phy clk
+		/* reset PDM  */
+		/* pcgcctl.b.rstpdwnmodule = 1; */
+		pcgcctl.b.stoppclk = 1;	/* stop phy clk */
 		DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
-	}
-	else{ //no device connect
-		if(!pldata->get_status(USB_REMOTE_WAKEUP)){
-			if(pldata->phy_suspend)
+	} else {/* no device connect */
+		if (!pldata->get_status(USB_REMOTE_WAKEUP)) {
+			if (pldata->phy_suspend)
 				pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 			udelay(3);
 			if (pldata->clock_enable)
-					pldata->clock_enable(pldata, 0);
+				pldata->clock_enable(pldata, 0);
 		}
 	}
 
-
 	return 0;
 }
 
-
 static int dwc_otg_hcd_resume(struct usb_hcd *hcd)
 {
-	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (hcd);
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
 	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
 	hprt0_data_t hprt0;
 	pcgcctl_data_t pcgcctl;
 	gintmsk_data_t gintmsk;
 	struct dwc_otg_platform_data *pldata;
 	pldata = core_if->otg_dev->pldata;
-	
-	if(core_if->op_state == B_PERIPHERAL){
-    		DWC_PRINTF("%s, usb device mode\n", __func__);
+
+	if (core_if->op_state == B_PERIPHERAL) {
+		DWC_PRINTF("%s, usb device mode\n", __func__);
 		return 0;
 	}
-
-//#ifdef CONFIG_PM_RUNTIME    
-	if(!(dwc_otg_hcd->host_enabled&1))
+/* #ifdef CONFIG_PM_RUNTIME */
+	if (!(dwc_otg_hcd->host_enabled & 1))
 		return 0;
-//#endif
+/* #endif */
 
-	if(!pldata->get_status(USB_REMOTE_WAKEUP)){
+	if (!pldata->get_status(USB_REMOTE_WAKEUP)) {
 		if (pldata->clock_enable)
-			pldata->clock_enable( pldata, 1);
+			pldata->clock_enable(pldata, 1);
 	}
 
-	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0); 
+	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
 #ifdef CONFIG_PM_RUNTIME
-	//USB HCD already resumed by remote wakeup, return now
-	if((!hprt0.b.prtsusp) && (hprt0.b.prtena))
+	/* USB HCD already resumed by remote wakeup, return now */
+	if ((!hprt0.b.prtsusp) && (hprt0.b.prtena))
 		return 0;
 #endif
 
-	//power on
+	/* power on */
 	pcgcctl.d32 = DWC_READ_REG32(core_if->pcgcctl);;
-	pcgcctl.b.stoppclk = 0;//restart phy clk
+	pcgcctl.b.stoppclk = 0;	/* restart phy clk */
 	DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
 	udelay(1);
-	pcgcctl.b.pwrclmp = 0;//power clamp
+	pcgcctl.b.pwrclmp = 0;	/* power clamp */
 	DWC_WRITE_REG32(core_if->pcgcctl, pcgcctl.d32);
 	udelay(2);
 
 	gintmsk.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
 	gintmsk.b.portintr = 0;
 	DWC_WRITE_REG32(&core_if->core_global_regs->gintmsk, gintmsk.d32);
-        
+
 	hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
 
 #ifdef CONFIG_PM_RUNTIME
-	if((!hprt0.b.prtena) && (!hprt0.b.prtpwr))
+	if ((!hprt0.b.prtena) && (!hprt0.b.prtpwr))
 		return 0;
 #endif
-	DWC_PRINTF("%s resume, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32);
-	
-	if(hprt0.b.prtconnsts){
-		//hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0);
-		//DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32);
-		hprt0.b.prtpwr = 1;    
+	DWC_PRINTF("%s resume, HPRT0:0x%x\n", hcd->self.bus_name, hprt0.d32);
+
+	if (hprt0.b.prtconnsts) {
+		/* hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0); */
+		/* DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32); */
+		hprt0.b.prtpwr = 1;
 		hprt0.b.prtres = 1;
 		hprt0.b.prtena = 0;
 		DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 		mdelay(20);
-		hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);	
-		//DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32);
-		//hprt0.d32 = 0;
-		hprt0.b.prtpwr = 1;    
+		hprt0.d32 = DWC_READ_REG32(core_if->host_if->hprt0);
+		/* DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32); */
+		/* hprt0.d32 = 0; */
+		hprt0.b.prtpwr = 1;
 		hprt0.b.prtres = 0;
 		hprt0.b.prtena = 0;
 		DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
@@ -861,15 +867,14 @@ static int dwc_otg_hcd_resume(struct usb_hcd *hcd)
 		hprt0.b.prtconndet = 1;
 		DWC_WRITE_REG32(core_if->host_if->hprt0, hprt0.d32);
 
-		//hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0);	
-		//DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32);
-    	
+		/* hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0); */
+		/* DWC_PRINT("%s, HPRT0:0x%x\n",hcd->self.bus_name,hprt0.d32); */
+
 		mdelay(10);
-	}
-	else{
-		if(!pldata->get_status(USB_REMOTE_WAKEUP)){
-			if(pldata->phy_suspend)
-				pldata->phy_suspend( pldata, USB_PHY_ENABLED);
+	} else {
+		if (!pldata->get_status(USB_REMOTE_WAKEUP)) {
+			if (pldata->phy_suspend)
+				pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 		}
 	}
 	gintmsk.b.portintr = 1;
@@ -881,7 +886,7 @@ static int dwc_otg_hcd_resume(struct usb_hcd *hcd)
 /** HCD Suspend */
 int hcd_suspend(struct usb_hcd *hcd)
 {
-	//dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
+	/* dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd); */
 
 	DWC_DEBUGPL(DBG_HCD, "HCD SUSPEND\n");
 
@@ -893,16 +898,15 @@ int hcd_suspend(struct usb_hcd *hcd)
 /** HCD resume */
 int hcd_resume(struct usb_hcd *hcd)
 {
-	//dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
+	/* dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd); */
 
 	DWC_DEBUGPL(DBG_HCD, "HCD RESUME\n");
-	
+
 	dwc_otg_hcd_resume(hcd);
 
 	return 0;
 }
 
-
 /** Returns the current frame number. */
 static int get_frame_number(struct usb_hcd *hcd)
 {
@@ -918,26 +922,43 @@ static void dump_urb_info(struct urb *urb, char *fn_name)
 	DWC_PRINTF("  Device address: %d\n", usb_pipedevice(urb->pipe));
 	DWC_PRINTF("  Endpoint: %d, %s\n", usb_pipeendpoint(urb->pipe),
 		   (usb_pipein(urb->pipe) ? "IN" : "OUT"));
-	DWC_PRINTF("  Endpoint type: %s\n", ( {
+	DWC_PRINTF("  Endpoint type: %s\n", ({
 					     char *pipetype;
 					     switch (usb_pipetype(urb->pipe)) {
-case PIPE_CONTROL:
-pipetype = "CONTROL"; break; case PIPE_BULK:
-pipetype = "BULK"; break; case PIPE_INTERRUPT:
-pipetype = "INTERRUPT"; break; case PIPE_ISOCHRONOUS:
-pipetype = "ISOCHRONOUS"; break; default:
-					     pipetype = "UNKNOWN"; break;};
-					     pipetype;}
-		   )) ;
-	DWC_PRINTF("  Speed: %s\n", ( {
-				     char *speed; switch (urb->dev->speed) {
-case USB_SPEED_HIGH:
-speed = "HIGH"; break; case USB_SPEED_FULL:
-speed = "FULL"; break; case USB_SPEED_LOW:
-speed = "LOW"; break; default:
-				     speed = "UNKNOWN"; break;};
-				     speed;}
-		   )) ;
+					     case PIPE_CONTROL:
+						  pipetype = "CONTROL";
+					     break;
+					     case PIPE_BULK:
+						  pipetype = "BULK";
+					     break;
+					     case PIPE_INTERRUPT:
+						  pipetype = "INTERRUPT";
+					     break;
+					     case PIPE_ISOCHRONOUS:
+						  pipetype = "ISOCHRONOUS";
+					     break;
+					     default:
+						  pipetype = "UNKNOWN";
+					     break; };
+					     pipetype; }
+					     )) ;
+	DWC_PRINTF("  Speed: %s\n", ({
+				     char *speed;
+				     switch (urb->dev->speed) {
+				     case USB_SPEED_HIGH:
+					  speed = "HIGH";
+				     break;
+				     case USB_SPEED_FULL:
+					  speed = "FULL";
+				     break;
+				     case USB_SPEED_LOW:
+					  speed = "LOW";
+				     break;
+				     default:
+					  speed = "UNKNOWN";
+				     break; };
+				     speed; }
+				     )) ;
 	DWC_PRINTF("  Max packet size: %d\n",
 		   usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)));
 	DWC_PRINTF("  Data buffer length: %d\n", urb->transfer_buffer_length);
@@ -963,13 +984,13 @@ speed = "LOW"; break; default:
  * (URB). mem_flags indicates the type of memory allocation to use while
  * processing this URB. */
 static int urb_enqueue(struct usb_hcd *hcd,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 		       struct usb_host_endpoint *ep,
 #endif
 		       struct urb *urb, gfp_t mem_flags)
 {
 	int retval = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
 	struct usb_host_endpoint *ep = urb->ep;
 #endif
 	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
@@ -989,14 +1010,17 @@ static int urb_enqueue(struct usb_hcd *hcd,
 	if (unlikely(atomic_read(&urb->use_count) > 1)) {
 		retval = -EPERM;
 		printk("%s urb %p already in queue, qtd %p, use_count %d\n",
-			__func__, urb, urb->hcpriv, atomic_read(&urb->use_count));
+		       __func__, urb, urb->hcpriv,
+		       atomic_read(&urb->use_count));
 		return retval;
 	}
 
 	if (unlikely(atomic_read(&urb->reject))) {
 		retval = -EPERM;
-		printk("%s urb %p submissions will fail, urb->reject %d, use_count %d\n",
-		        __func__, urb, atomic_read(&urb->reject), atomic_read(&urb->use_count));
+		printk
+		    ("%s urb %p submissions will fail, urb->reject %d, use_count %d\n",
+		     __func__, urb, atomic_read(&urb->reject),
+		     atomic_read(&urb->use_count));
 		return retval;
 
 	}
@@ -1037,9 +1061,10 @@ static int urb_enqueue(struct usb_hcd *hcd,
 						   !(usb_pipein(urb->pipe))));
 
 #ifdef DEBUG
-	if((uint32_t)urb->transfer_buffer & 3){
-		DWC_PRINTF("%s urb->transfer_buffer address not align to 4-byte 0x%x\n", 
-			    __func__, (uint32_t)urb->transfer_buffer);
+	if ((uint32_t) urb->transfer_buffer & 3) {
+		DWC_PRINTF
+		    ("%s urb->transfer_buffer address not align to 4-byte 0x%x\n",
+		     __func__, (uint32_t) urb->transfer_buffer);
 	}
 #endif
 
@@ -1068,10 +1093,10 @@ static int urb_enqueue(struct usb_hcd *hcd,
 
 	for (i = 0; i < urb->number_of_packets; ++i) {
 		dwc_otg_hcd_urb_set_iso_desc_params(dwc_otg_urb, i,
-						    urb->
-						    iso_frame_desc[i].offset,
-						    urb->
-						    iso_frame_desc[i].length);
+						    urb->iso_frame_desc[i].
+						    offset,
+						    urb->iso_frame_desc[i].
+						    length);
 	}
 
 	urb->hcpriv = dwc_otg_urb;
@@ -1094,7 +1119,7 @@ static int urb_enqueue(struct usb_hcd *hcd,
 
 /** Aborts/cancels a USB transfer request. Always returns 0 to indicate
  * success.  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 #else
 static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
@@ -1114,22 +1139,23 @@ static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 
 	DWC_SPINLOCK_IRQSAVE(dwc_otg_hcd->lock, &flags);
 
-	if(((uint32_t)urb&0xf0000000)==0){
+	if (((uint32_t) urb & 0xf0000000) == 0) {
 		DWC_PRINTF("%s error: urb is %p!!!\n", __func__, urb);
 		goto out1;
 	}
-	
-	if(((uint32_t)urb->hcpriv&0xf0000000) == 0){
-		DWC_PRINTF("%s error: urb->hcpriv %p urb %p, count %d!!!\n",__func__, 
-			   urb->hcpriv, urb, atomic_read(&urb->use_count));
-		if((atomic_read(&urb->use_count)) == 1)
+
+	if (((uint32_t) urb->hcpriv & 0xf0000000) == 0) {
+		DWC_PRINTF("%s error: urb->hcpriv %p urb %p, count %d!!!\n",
+			   __func__, urb->hcpriv, urb,
+			   atomic_read(&urb->use_count));
+		if ((atomic_read(&urb->use_count)) == 1)
 			goto out2;
-		else{
+		else {
 			DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock, flags);
 			return 0;
 		}
 	}
-	
+
 	dwc_otg_hcd_urb_dequeue(dwc_otg_hcd, urb->hcpriv);
 
 out2:
@@ -1138,7 +1164,7 @@ static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd->lock, flags);
 
 	/* Higher layer software sets URB status. */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 	usb_hcd_giveback_urb(hcd, urb);
 #else
 	usb_hcd_giveback_urb(hcd, urb, status);
@@ -1166,8 +1192,8 @@ static void endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	ep->hcpriv = NULL;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
-/* Resets endpoint specific parameter values, in current version used to reset 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
+/* Resets endpoint specific parameter values, in current version used to reset
  * the data toggle(as a WA). This function can be called from usb_clear_halt routine */
 static void endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 {
@@ -1184,7 +1210,8 @@ static void endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	else
 		return;
 
-	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD EP RESET: Endpoint Num=0x%02d\n", epnum);
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD EP RESET: Endpoint Num=0x%02d\n",
+		    epnum);
 
 	DWC_SPINLOCK_IRQSAVE(dwc_otg_hcd->lock, &flags);
 	usb_settoggle(udev, epnum, is_out, 0);
@@ -1208,7 +1235,7 @@ static irqreturn_t dwc_otg_hcd_irq(struct usb_hcd *hcd)
 	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
 	int32_t retval = dwc_otg_hcd_handle_intr(dwc_otg_hcd);
 	if (retval != 0) {
-		//S3C2410X_CLEAR_EINTPEND();
+		/* S3C2410X_CLEAR_EINTPEND(); */
 	}
 	return IRQ_RETVAL(retval);
 }
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_hcd_queue.c b/drivers/usb/dwc_otg_310/dwc_otg_hcd_queue.c
index 83b4c34a4f12..04661ce09852 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_hcd_queue.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_hcd_queue.c
@@ -7,7 +7,7 @@
  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
  * otherwise expressly agreed to in writing between Synopsys and you.
- * 
+ *
  * The Software IS NOT an item of Licensed Software or Licensed Product under
  * any End User Software License Agreement or Agreement for Licensed Product
  * with Synopsys or any supplement thereto. You are permitted to use and
@@ -17,7 +17,7 @@
  * any information contained herein except pursuant to this license grant from
  * Synopsys. If you do not agree with this notice, including the disclaimer
  * below, then you are not authorized to use the Software.
- * 
+ *
  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -42,7 +42,7 @@
 #include "dwc_otg_hcd.h"
 #include "dwc_otg_regs.h"
 
-/** 
+/**
  * Free each QTD in the QH's QTD-list then free the QH.  QH should already be
  * removed from a list.  QTD list should already be empty if called from URB
  * Dequeue.
@@ -50,7 +50,7 @@
  * @param hcd HCD instance.
  * @param qh The QH to free.
  */
-void dwc_otg_hcd_qh_free(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+void dwc_otg_hcd_qh_free(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	dwc_otg_qtd_t *qtd, *qtd_tmp;
 	dwc_irqflags_t flags;
@@ -79,7 +79,7 @@ void dwc_otg_hcd_qh_free(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	return;
 }
 
-#define BitStuffTime(bytecount)  ((8 * 7* bytecount) / 6)
+#define BitStuffTime(bytecount)  ((8*7*bytecount) / 6)
 #define HS_HOST_DELAY		5	/* nanoseconds */
 #define FS_LS_HOST_DELAY	1000	/* nanoseconds */
 #define HUB_LS_SETUP		333	/* nanoseconds */
@@ -144,16 +144,16 @@ static uint32_t calc_bus_time(int speed, int is_in, int is_isoc, int bytecount)
 	return NS_TO_US(retval);
 }
 
-/** 
+/**
  * Initializes a QH structure.
  *
  * @param hcd The HCD state structure for the DWC OTG controller.
  * @param qh  The QH to init.
  * @param urb Holds the information about the device/endpoint that we need
- * 	      to initialize the QH. 
+ * 	      to initialize the QH.
  */
 #define SCHEDULE_SLOP 10
-void qh_init(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, dwc_otg_hcd_urb_t * urb)
+void qh_init(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh, dwc_otg_hcd_urb_t *urb)
 {
 	char *speed, *type;
 	int dev_speed;
@@ -171,7 +171,7 @@ void qh_init(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, dwc_otg_hcd_urb_t * urb)
 	DWC_LIST_INIT(&qh->qh_list_entry);
 	qh->channel = NULL;
 
-	/* FS/LS Enpoint on HS Hub 
+	/* FS/LS Enpoint on HS Hub
 	 * NOT virtual root hub */
 	dev_speed = hcd->fops->speed(hcd, urb->priv);
 
@@ -288,8 +288,8 @@ void qh_init(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh, dwc_otg_hcd_urb_t * urb)
  * @param atomic_alloc Flag to do atomic allocation if needed
  *
  * @return Returns pointer to the newly allocated QH, or NULL on error. */
-dwc_otg_qh_t *dwc_otg_hcd_qh_create(dwc_otg_hcd_t * hcd,
-				    dwc_otg_hcd_urb_t * urb, int atomic_alloc)
+dwc_otg_qh_t *dwc_otg_hcd_qh_create(dwc_otg_hcd_t *hcd,
+				    dwc_otg_hcd_urb_t *urb, int atomic_alloc)
 {
 	dwc_otg_qh_t *qh;
 
@@ -317,7 +317,7 @@ dwc_otg_qh_t *dwc_otg_hcd_qh_create(dwc_otg_hcd_t * hcd,
  *
  * @return 0 if successful, negative error code otherise.
  */
-static int periodic_channel_available(dwc_otg_hcd_t * hcd)
+static int periodic_channel_available(dwc_otg_hcd_t *hcd)
 {
 	/*
 	 * Currently assuming that there is a dedicated host channnel for each
@@ -333,7 +333,8 @@ static int periodic_channel_available(dwc_otg_hcd_t * hcd)
 		status = 0;
 	} else {
 		DWC_INFO("%s: Total channels: %d, Periodic: %d, Non-periodic: %d\n",
-			__func__, num_channels, hcd->periodic_channels, hcd->non_periodic_channels);	//NOTICE
+			 __func__, num_channels, hcd->periodic_channels,
+			 hcd->non_periodic_channels);
 		status = -DWC_E_NO_SPACE;
 	}
 
@@ -350,7 +351,7 @@ static int periodic_channel_available(dwc_otg_hcd_t * hcd)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-static int check_periodic_bandwidth(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static int check_periodic_bandwidth(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	int status;
 	int16_t max_claimed_usecs;
@@ -373,7 +374,8 @@ static int check_periodic_bandwidth(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	}
 
 	if (hcd->periodic_usecs > max_claimed_usecs) {
-		DWC_INFO("%s: already claimed usecs %d, required usecs %d\n", __func__, hcd->periodic_usecs, qh->usecs);	//NOTICE
+		DWC_INFO("%s: already claimed usecs %d, required usecs %d\n",
+			 __func__, hcd->periodic_usecs, qh->usecs);
 		status = -DWC_E_NO_SPACE;
 	}
 
@@ -390,7 +392,7 @@ static int check_periodic_bandwidth(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-static int check_max_xfer_size(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static int check_max_xfer_size(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	int status;
 	uint32_t max_xfer_size;
@@ -403,7 +405,7 @@ static int check_max_xfer_size(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 
 	if (max_xfer_size > max_channel_xfer_size) {
 		DWC_INFO("%s: Periodic xfer length %d > " "max xfer length for channel %d\n",
-				__func__, max_xfer_size, max_channel_xfer_size);	//NOTICE
+			 __func__, max_xfer_size, max_channel_xfer_size);
 		status = -DWC_E_NO_SPACE;
 	}
 
@@ -419,35 +421,36 @@ static int check_max_xfer_size(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-static int schedule_periodic(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static int schedule_periodic(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	int status = 0;
 
 	status = periodic_channel_available(hcd);
 	if (status) {
-		DWC_INFO("%s: No host channel available for periodic " "transfer.\n", __func__);	//NOTICE
+		DWC_INFO("%s: No host channel available for periodic " "transfer.\n", __func__);
 		return status;
 	}
 
 	status = check_periodic_bandwidth(hcd, qh);
 	if (status) {
-		DWC_INFO("%s: Insufficient periodic bandwidth for " "periodic transfer.\n", __func__);	//NOTICE
+		DWC_INFO("%s: Insufficient periodic bandwidth for " "periodic transfer.\n", __func__);
 		return status;
 	}
 
 	status = check_max_xfer_size(hcd, qh);
 	if (status) {
-		DWC_INFO("%s: Channel max transfer size too small " "for periodic transfer.\n", __func__);	//NOTICE
+		DWC_INFO("%s: Channel max transfer size too small " "for periodic transfer.\n", __func__);
 		return status;
 	}
 
 	if (hcd->core_if->dma_desc_enable) {
 		/* Don't rely on SOF and start in ready schedule */
-		DWC_LIST_INSERT_TAIL(&hcd->periodic_sched_ready, &qh->qh_list_entry);
-	}
-	else {
-	/* Always start in the inactive schedule. */
-	DWC_LIST_INSERT_TAIL(&hcd->periodic_sched_inactive, &qh->qh_list_entry);
+		DWC_LIST_INSERT_TAIL(&hcd->periodic_sched_ready,
+				     &qh->qh_list_entry);
+	} else {
+		/* Always start in the inactive schedule. */
+		DWC_LIST_INSERT_TAIL(&hcd->periodic_sched_inactive,
+				     &qh->qh_list_entry);
 	}
 
 	/* Reserve the periodic channel. */
@@ -466,7 +469,7 @@ static int schedule_periodic(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-int dwc_otg_hcd_qh_add(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+int dwc_otg_hcd_qh_add(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	int status = 0;
 	gintmsk_data_t intr_mask = {.d32 = 0 };
@@ -483,10 +486,11 @@ int dwc_otg_hcd_qh_add(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 				     &qh->qh_list_entry);
 	} else {
 		status = schedule_periodic(hcd, qh);
-		if ( !hcd->periodic_qh_count ) {
+		if (!hcd->periodic_qh_count) {
 			intr_mask.b.sofintr = 1;
-			DWC_MODIFY_REG32(&hcd->core_if->core_global_regs->gintmsk,
-								intr_mask.d32, intr_mask.d32);
+			DWC_MODIFY_REG32(&hcd->core_if->
+					 core_global_regs->gintmsk,
+					 intr_mask.d32, intr_mask.d32);
 		}
 		hcd->periodic_qh_count++;
 	}
@@ -500,7 +504,7 @@ int dwc_otg_hcd_qh_add(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  * @param hcd The HCD state structure for the DWC OTG controller.
  * @param qh QH for the periodic transfer.
  */
-static void deschedule_periodic(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+static void deschedule_periodic(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	DWC_LIST_REMOVE_INIT(&qh->qh_list_entry);
 
@@ -511,13 +515,13 @@ static void deschedule_periodic(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	hcd->periodic_usecs -= qh->usecs;
 }
 
-/** 
+/**
  * Removes a QH from either the non-periodic or periodic schedule.  Memory is
  * not freed.
  *
  * @param hcd The HCD state structure.
  * @param qh QH to remove from schedule. */
-void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
+void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh)
 {
 	gintmsk_data_t intr_mask = {.d32 = 0 };
 
@@ -535,10 +539,11 @@ void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
 	} else {
 		deschedule_periodic(hcd, qh);
 		hcd->periodic_qh_count--;
-		if( !hcd->periodic_qh_count ) {
+		if (!hcd->periodic_qh_count) {
 			intr_mask.b.sofintr = 1;
-				DWC_MODIFY_REG32(&hcd->core_if->core_global_regs->gintmsk,
-									intr_mask.d32, 0);
+			DWC_MODIFY_REG32(&hcd->core_if->
+					 core_global_regs->gintmsk,
+					 intr_mask.d32, 0);
 		}
 	}
 }
@@ -556,9 +561,9 @@ void dwc_otg_hcd_qh_remove(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh)
  * inactive schedule. If there are no QTDs attached to the QH, the QH is
  * completely removed from the periodic schedule.
  */
-void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
+void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t *hcd, dwc_otg_qh_t *qh,
 			       int sched_next_periodic_split)
-{	
+{
 	if (dwc_qh_is_non_per(qh)) {
 		dwc_otg_hcd_qh_remove(hcd, qh);
 		if (!DWC_CIRCLEQ_EMPTY(&qh->qtd_list)) {
@@ -587,7 +592,8 @@ void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 					if ((qh->ep_type != UE_ISOCHRONOUS) ||
 					    (qh->ep_is_in != 0)) {
 						qh->sched_frame =
-						    dwc_frame_num_inc(qh->sched_frame, 1);
+						    dwc_frame_num_inc
+						    (qh->sched_frame, 1);
 					}
 				}
 			} else {
@@ -628,15 +634,15 @@ void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t * hcd, dwc_otg_qh_t * qh,
 	}
 }
 
-/** 
- * This function allocates and initializes a QTD. 
+/**
+ * This function allocates and initializes a QTD.
  *
  * @param urb The URB to create a QTD from.  Each URB-QTD pair will end up
  * 	      pointing to each other so each pair should have a unique correlation.
  * @param atomic_alloc Flag to do atomic alloc if needed
  *
  * @return Returns pointer to the newly allocated QTD, or NULL on error. */
-dwc_otg_qtd_t *dwc_otg_hcd_qtd_create(dwc_otg_hcd_urb_t * urb, int atomic_alloc)
+dwc_otg_qtd_t *dwc_otg_hcd_qtd_create(dwc_otg_hcd_urb_t *urb, int atomic_alloc)
 {
 	dwc_otg_qtd_t *qtd;
 
@@ -649,12 +655,12 @@ dwc_otg_qtd_t *dwc_otg_hcd_qtd_create(dwc_otg_hcd_urb_t * urb, int atomic_alloc)
 	return qtd;
 }
 
-/** 
+/**
  * Initializes a QTD structure.
  *
  * @param qtd The QTD to initialize.
  * @param urb The URB to use for initialization.  */
-void dwc_otg_hcd_qtd_init(dwc_otg_qtd_t * qtd, dwc_otg_hcd_urb_t * urb)
+void dwc_otg_hcd_qtd_init(dwc_otg_qtd_t *qtd, dwc_otg_hcd_urb_t *urb)
 {
 	dwc_memset(qtd, 0, sizeof(dwc_otg_qtd_t));
 	qtd->urb = urb;
@@ -692,8 +698,9 @@ void dwc_otg_hcd_qtd_init(dwc_otg_qtd_t * qtd, dwc_otg_hcd_urb_t * urb)
  *
  * @return 0 if successful, negative error code otherwise.
  */
-int dwc_otg_hcd_qtd_add(dwc_otg_qtd_t * qtd,
-			dwc_otg_hcd_t * hcd, dwc_otg_qh_t ** qh, int atomic_alloc)
+int dwc_otg_hcd_qtd_add(dwc_otg_qtd_t *qtd,
+			dwc_otg_hcd_t *hcd, dwc_otg_qh_t **qh,
+			int atomic_alloc)
 {
 	int retval = 0;
 	dwc_irqflags_t flags;
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_os_dep.h b/drivers/usb/dwc_otg_310/dwc_otg_os_dep.h
index 051e5e510a3c..e890bfbd81e5 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_os_dep.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_os_dep.h
@@ -31,23 +31,23 @@
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
 # include <linux/irq.h>
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)
 # include <linux/usb/ch9.h>
 #else
 # include <linux/usb_ch9.h>
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 # include <linux/usb/gadget.h>
 #else
 # include <linux/usb_gadget.h>
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 # include <asm/irq.h>
 #endif
 
@@ -59,18 +59,18 @@
 # include <linux/of.h>
 # include <linux/of_platform.h>
 
-//# include <asm/arch/lm.h>
-//# include <asm/arch/irqs.h>
-//# include <asm/arch/regs-irq.h>
+/* # include <asm/arch/lm.h> */
+/* # include <asm/arch/irqs.h> */
+/* # include <asm/arch/regs-irq.h> */
 
 /** The OS page size */
 #define DWC_OS_PAGE_SIZE	PAGE_SIZE
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
 typedef int gfp_t;
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 # define IRQF_SHARED SA_SHIRQ
 #endif
 
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_pcd.c b/drivers/usb/dwc_otg_310/dwc_otg_pcd.c
index dfe28d329fad..ddb0375d292a 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_pcd.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_pcd.c
@@ -53,13 +53,13 @@
 #ifdef DWC_UTE_CFI
 #include "dwc_otg_cfi.h"
 
-extern int init_cfi(cfiobject_t * cfiobj);
+extern int init_cfi(cfiobject_t *cfiobj);
 #endif
 
 /**
  * Choose endpoint from ep arrays using usb_ep structure.
  */
-static dwc_otg_pcd_ep_t *get_ep_from_handle(dwc_otg_pcd_t * pcd, void *handle)
+static dwc_otg_pcd_ep_t *get_ep_from_handle(dwc_otg_pcd_t *pcd, void *handle)
 {
 	int i;
 	if (pcd->ep0.priv == handle) {
@@ -78,7 +78,7 @@ static dwc_otg_pcd_ep_t *get_ep_from_handle(dwc_otg_pcd_t * pcd, void *handle)
 /**
  * This function completes a request.  It call's the request call back.
  */
-void dwc_otg_request_done(dwc_otg_pcd_ep_t * ep, dwc_otg_pcd_request_t * req,
+void dwc_otg_request_done(dwc_otg_pcd_ep_t *ep, dwc_otg_pcd_request_t *req,
 			  int32_t status)
 {
 	unsigned stopped = ep->stopped;
@@ -103,7 +103,7 @@ void dwc_otg_request_done(dwc_otg_pcd_ep_t * ep, dwc_otg_pcd_request_t * req,
 /**
  * This function terminates all the requsts in the EP request queue.
  */
-void dwc_otg_request_nuke(dwc_otg_pcd_ep_t * ep)
+void dwc_otg_request_nuke(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_pcd_request_t *req;
 
@@ -116,7 +116,7 @@ void dwc_otg_request_nuke(dwc_otg_pcd_ep_t * ep)
 	}
 }
 
-void dwc_otg_pcd_start(dwc_otg_pcd_t * pcd,
+void dwc_otg_pcd_start(dwc_otg_pcd_t *pcd,
 		       const struct dwc_otg_pcd_function_ops *fops)
 {
 	pcd->fops = fops;
@@ -137,7 +137,7 @@ static int32_t dwc_otg_pcd_start_cb(void *p)
 	 * Initialized the Core for Device mode.
 	 */
 	if (dwc_otg_is_device_mode(core_if)) {
-		//dwc_otg_core_dev_init(core_if);
+		/* dwc_otg_core_dev_init(core_if); */
 		/* Set core_if's lock pointer to the pcd->lock */
 		core_if->lock = pcd->lock;
 	}
@@ -146,7 +146,7 @@ static int32_t dwc_otg_pcd_start_cb(void *p)
 
 /** CFI-specific buffer allocation function for EP */
 #ifdef DWC_UTE_CFI
-uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t * pcd, void *pep, dwc_dma_t * addr,
+uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t *pcd, void *pep, dwc_dma_t *addr,
 			      size_t buflen, int flags)
 {
 	dwc_otg_pcd_ep_t *ep;
@@ -160,7 +160,7 @@ uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t * pcd, void *pep, dwc_dma_t * addr,
 					  flags);
 }
 #else
-uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t * pcd, void *pep, dwc_dma_t * addr,
+uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t *pcd, void *pep, dwc_dma_t *addr,
 			      size_t buflen, int flags);
 #endif
 
@@ -216,7 +216,7 @@ static int32_t dwc_otg_pcd_suspend_cb(void *p)
 static int32_t dwc_otg_pcd_stop_cb(void *p)
 {
 	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *) p;
-	extern void dwc_otg_pcd_stop(dwc_otg_pcd_t * _pcd);
+	extern void dwc_otg_pcd_stop(dwc_otg_pcd_t *_pcd);
 
 	dwc_otg_pcd_stop(pcd);
 	return 1;
@@ -237,7 +237,7 @@ static dwc_otg_cil_callbacks_t pcd_callbacks = {
  * This function allocates a DMA Descriptor chain for the Endpoint
  * buffer to be used for a transfer to/from the specified endpoint.
  */
-dwc_otg_dev_dma_desc_t *dwc_otg_ep_alloc_desc_chain(dwc_dma_t * dma_desc_addr,
+dwc_otg_dev_dma_desc_t *dwc_otg_ep_alloc_desc_chain(dwc_dma_t *dma_desc_addr,
 						    uint32_t count)
 {
 	return DWC_DMA_ALLOC_ATOMIC(count * sizeof(dwc_otg_dev_dma_desc_t),
@@ -247,7 +247,7 @@ dwc_otg_dev_dma_desc_t *dwc_otg_ep_alloc_desc_chain(dwc_dma_t * dma_desc_addr,
 /**
  * This function frees a DMA Descriptor chain that was allocated by ep_alloc_desc.
  */
-void dwc_otg_ep_free_desc_chain(dwc_otg_dev_dma_desc_t * desc_addr,
+void dwc_otg_ep_free_desc_chain(dwc_otg_dev_dma_desc_t *desc_addr,
 				uint32_t dma_desc_addr, uint32_t count)
 {
 	DWC_DMA_FREE(count * sizeof(dwc_otg_dev_dma_desc_t), desc_addr,
@@ -263,8 +263,8 @@ void dwc_otg_ep_free_desc_chain(dwc_otg_dev_dma_desc_t * desc_addr,
  * @param dwc_ep The EP to start the transfer on.
  *
  */
-void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
-					dwc_ep_t * dwc_ep)
+void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t *core_if,
+					dwc_ep_t *dwc_ep)
 {
 
 	dsts_data_t dsts = {.d32 = 0 };
@@ -277,7 +277,7 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		dwc_ep->desc_cnt = dwc_ep->buf_proc_intrvl / dwc_ep->bInterval;
 	else
 		dwc_ep->desc_cnt =
-		    dwc_ep->buf_proc_intrvl * dwc_ep->pkt_per_frm /
+		    dwc_ep->buf_proc_intrvl*dwc_ep->pkt_per_frm /
 		    dwc_ep->bInterval;
 
 	/** Allocate descriptors for double buffering */
@@ -320,11 +320,11 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		     i += dwc_ep->pkt_per_frm) {
 
 			for (j = 0; j < dwc_ep->pkt_per_frm; ++j) {
-				uint32_t len = (j + 1) * dwc_ep->maxpacket;
+				uint32_t len = (j + 1)*dwc_ep->maxpacket;
 				if (len > dwc_ep->data_per_frame)
 					data_per_desc =
 					    dwc_ep->data_per_frame -
-					    j * dwc_ep->maxpacket;
+					    j*dwc_ep->maxpacket;
 				else
 					data_per_desc = dwc_ep->maxpacket;
 				len = data_per_desc % 4;
@@ -342,11 +342,11 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		}
 
 		for (j = 0; j < dwc_ep->pkt_per_frm - 1; ++j) {
-			uint32_t len = (j + 1) * dwc_ep->maxpacket;
+			uint32_t len = (j + 1)*dwc_ep->maxpacket;
 			if (len > dwc_ep->data_per_frame)
 				data_per_desc =
 				    dwc_ep->data_per_frame -
-				    j * dwc_ep->maxpacket;
+				    j*dwc_ep->maxpacket;
 			else
 				data_per_desc = dwc_ep->maxpacket;
 			len = data_per_desc % 4;
@@ -362,10 +362,10 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		}
 
 		sts.b_iso_out.ioc = 1;
-		len = (j + 1) * dwc_ep->maxpacket;
+		len = (j + 1)*dwc_ep->maxpacket;
 		if (len > dwc_ep->data_per_frame)
 			data_per_desc =
-			    dwc_ep->data_per_frame - j * dwc_ep->maxpacket;
+			    dwc_ep->data_per_frame - j*dwc_ep->maxpacket;
 		else
 			data_per_desc = dwc_ep->maxpacket;
 		len = data_per_desc % 4;
@@ -385,11 +385,11 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		for (i = 0; i < dwc_ep->desc_cnt - dwc_ep->pkt_per_frm;
 		     i += dwc_ep->pkt_per_frm) {
 			for (j = 0; j < dwc_ep->pkt_per_frm; ++j) {
-				uint32_t len = (j + 1) * dwc_ep->maxpacket;
+				uint32_t len = (j + 1)*dwc_ep->maxpacket;
 				if (len > dwc_ep->data_per_frame)
 					data_per_desc =
 					    dwc_ep->data_per_frame -
-					    j * dwc_ep->maxpacket;
+					    j*dwc_ep->maxpacket;
 				else
 					data_per_desc = dwc_ep->maxpacket;
 				len = data_per_desc % 4;
@@ -408,9 +408,9 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		}
 		for (j = 0; j < dwc_ep->pkt_per_frm - 1; ++j) {
 			data_per_desc =
-			    ((j + 1) * dwc_ep->maxpacket >
+			    ((j + 1)*dwc_ep->maxpacket >
 			     dwc_ep->data_per_frame) ? dwc_ep->data_per_frame -
-			    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+			    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 			data_per_desc +=
 			    (data_per_desc % 4) ? (4 - data_per_desc % 4) : 0;
 			sts.b_iso_out.rxbytes = data_per_desc;
@@ -425,9 +425,9 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		sts.b_iso_out.ioc = 1;
 		sts.b_iso_out.l = 1;
 		data_per_desc =
-		    ((j + 1) * dwc_ep->maxpacket >
+		    ((j + 1)*dwc_ep->maxpacket >
 		     dwc_ep->data_per_frame) ? dwc_ep->data_per_frame -
-		    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+		    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 		data_per_desc +=
 		    (data_per_desc % 4) ? (4 - data_per_desc % 4) : 0;
 		sts.b_iso_out.rxbytes = data_per_desc;
@@ -453,8 +453,8 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
 		fifosize_data_t txfifosize, rxfifosize;
 
 		txfifosize.d32 =
-		    DWC_READ_REG32(&core_if->dev_if->in_ep_regs[dwc_ep->num]->
-				   dtxfsts);
+		    DWC_READ_REG32(&core_if->dev_if->
+				   in_ep_regs[dwc_ep->num]->dtxfsts);
 		rxfifosize.d32 =
 		    DWC_READ_REG32(&core_if->core_global_regs->grxfsiz);
 
@@ -537,8 +537,8 @@ void dwc_otg_iso_ep_start_ddma_transfer(dwc_otg_core_if_t * core_if,
  * @param ep The EP to start the transfer on.
  *
  */
-void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
-				       dwc_ep_t * ep)
+void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t *core_if,
+				       dwc_ep_t *ep)
 {
 	depctl_data_t depctl = {.d32 = 0 };
 	volatile uint32_t *addr;
@@ -555,7 +555,7 @@ void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
 		deptsiz_data_t deptsiz = {.d32 = 0 };
 
 		ep->xfer_len =
-		    ep->data_per_frame * ep->buf_proc_intrvl / ep->bInterval;
+		    ep->data_per_frame*ep->buf_proc_intrvl / ep->bInterval;
 		ep->pkt_cnt =
 		    (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 		ep->xfer_count = 0;
@@ -568,33 +568,37 @@ void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
 			/* Program the transfer size and packet count
 			 *      as follows: xfersize = N * maxpacket +
 			 *      short_packet pktcnt = N + (short_packet
-			 *      exist ? 1 : 0) 
+			 *      exist ? 1 : 0)
 			 */
 			deptsiz.b.mc = ep->pkt_per_frm;
 			deptsiz.b.xfersize = ep->xfer_len;
 			deptsiz.b.pktcnt =
 			    (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
-			DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[ep->num]->
-					dieptsiz, deptsiz.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					in_ep_regs[ep->num]->dieptsiz,
+					deptsiz.d32);
 
 			/* Write the DMA register */
 			DWC_WRITE_REG32(&
-					(core_if->dev_if->in_ep_regs[ep->num]->
-					 diepdma), (uint32_t) ep->dma_addr);
+					(core_if->dev_if->
+					 in_ep_regs[ep->num]->diepdma),
+					(uint32_t) ep->dma_addr);
 
 		} else {
 			deptsiz.b.pktcnt =
 			    (ep->xfer_len + (ep->maxpacket - 1)) /
 			    ep->maxpacket;
-			deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
+			deptsiz.b.xfersize = deptsiz.b.pktcnt*ep->maxpacket;
 
-			DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[ep->num]->
-					doeptsiz, deptsiz.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->
+					out_ep_regs[ep->num]->doeptsiz,
+					deptsiz.d32);
 
 			/* Write the DMA register */
 			DWC_WRITE_REG32(&
-					(core_if->dev_if->out_ep_regs[ep->num]->
-					 doepdma), (uint32_t) ep->dma_addr);
+					(core_if->dev_if->
+					 out_ep_regs[ep->num]->doepdma),
+					(uint32_t) ep->dma_addr);
 
 		}
 		/** Enable endpoint, clear nak  */
@@ -616,8 +620,8 @@ void dwc_otg_iso_ep_start_buf_transfer(dwc_otg_core_if_t * core_if,
  * @param ep The EP to start the transfer on.
  */
 
-static void dwc_otg_iso_ep_start_transfer(dwc_otg_core_if_t * core_if,
-					  dwc_ep_t * ep)
+static void dwc_otg_iso_ep_start_transfer(dwc_otg_core_if_t *core_if,
+					  dwc_ep_t *ep)
 {
 	if (core_if->dma_enable) {
 		if (core_if->dma_desc_enable) {
@@ -632,11 +636,11 @@ static void dwc_otg_iso_ep_start_transfer(dwc_otg_core_if_t * core_if,
 				dwc_otg_iso_ep_start_buf_transfer(core_if, ep);
 			} else {
 				ep->cur_pkt_addr =
-				    (ep->proc_buf_num) ? ep->xfer_buff1 : ep->
-				    xfer_buff0;
+				    (ep->proc_buf_num) ? ep->
+				    xfer_buff1 : ep->xfer_buff0;
 				ep->cur_pkt_dma_addr =
-				    (ep->proc_buf_num) ? ep->dma_addr1 : ep->
-				    dma_addr0;
+				    (ep->proc_buf_num) ? ep->
+				    dma_addr1 : ep->dma_addr0;
 				dwc_otg_iso_ep_start_frm_transfer(core_if, ep);
 			}
 		}
@@ -651,13 +655,13 @@ static void dwc_otg_iso_ep_start_transfer(dwc_otg_core_if_t * core_if,
 
 /**
  * This function stops transfer for an EP and
- * resets the ep's variables. 
+ * resets the ep's variables.
  *
  * @param core_if Programming view of DWC_otg controller.
  * @param ep The EP to start the transfer on.
  */
 
-void dwc_otg_iso_ep_stop_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void dwc_otg_iso_ep_stop_transfer(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	depctl_data_t depctl = {.d32 = 0 };
 	volatile uint32_t *addr;
@@ -701,8 +705,8 @@ void dwc_otg_iso_ep_stop_transfer(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
 	ep->iso_dma_desc_addr = 0;
 }
 
-int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
-			     uint8_t * buf0, uint8_t * buf1, dwc_dma_t dma0,
+int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t *pcd, void *ep_handle,
+			     uint8_t *buf0, uint8_t *buf1, dwc_dma_t dma0,
 			     dwc_dma_t dma1, int sync_frame, int dp_frame,
 			     int data_per_frame, int start_frame,
 			     int buf_proc_intrvl, void *req_handle,
@@ -771,7 +775,7 @@ int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 	if (!core_if->pti_enh_enable) {
 		dwc_ep->pkt_cnt =
-		    dwc_ep->buf_proc_intrvl * dwc_ep->pkt_per_frm /
+		    dwc_ep->buf_proc_intrvl*dwc_ep->pkt_per_frm /
 		    dwc_ep->bInterval;
 	} else {
 		dwc_ep->pkt_cnt =
@@ -782,16 +786,16 @@ int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 	if (core_if->dma_desc_enable) {
 		dwc_ep->desc_cnt =
-		    dwc_ep->buf_proc_intrvl * dwc_ep->pkt_per_frm /
+		    dwc_ep->buf_proc_intrvl*dwc_ep->pkt_per_frm /
 		    dwc_ep->bInterval;
 	}
 
 	if (atomic_alloc) {
 		dwc_ep->pkt_info =
-		    DWC_ALLOC_ATOMIC(sizeof(iso_pkt_info_t) * dwc_ep->pkt_cnt);
+		    DWC_ALLOC_ATOMIC(sizeof(iso_pkt_info_t)*dwc_ep->pkt_cnt);
 	} else {
 		dwc_ep->pkt_info =
-		    DWC_ALLOC(sizeof(iso_pkt_info_t) * dwc_ep->pkt_cnt);
+		    DWC_ALLOC(sizeof(iso_pkt_info_t)*dwc_ep->pkt_cnt);
 	}
 	if (!dwc_ep->pkt_info) {
 		DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags);
@@ -799,7 +803,7 @@ int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
 	}
 	if (core_if->pti_enh_enable) {
 		dwc_memset(dwc_ep->pkt_info, 0,
-			   sizeof(iso_pkt_info_t) * dwc_ep->pkt_cnt);
+			   sizeof(iso_pkt_info_t)*dwc_ep->pkt_cnt);
 	}
 
 	dwc_ep->cur_pkt = 0;
@@ -810,7 +814,7 @@ int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
 	return 0;
 }
 
-int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t * pcd, void *ep_handle,
+int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t *pcd, void *ep_handle,
 			    void *req_handle)
 {
 	dwc_irqflags_t flags = 0;
@@ -846,7 +850,7 @@ int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t * pcd, void *ep_handle,
  *	- Every time a sync period completes this function is called to
  *	  perform data exchange between PCD and gadget
  */
-void dwc_otg_iso_buffer_done(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep,
+void dwc_otg_iso_buffer_done(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *ep,
 			     void *req_handle)
 {
 	int i;
@@ -866,7 +870,7 @@ void dwc_otg_iso_buffer_done(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep,
 	}
 }
 
-int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t * pcd, void *ep_handle,
+int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t *pcd, void *ep_handle,
 				     void *iso_req_handle)
 {
 	dwc_otg_pcd_ep_t *ep;
@@ -882,7 +886,7 @@ int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t * pcd, void *ep_handle,
 	return dwc_ep->pkt_cnt;
 }
 
-void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t * pcd, void *ep_handle,
+void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t *pcd, void *ep_handle,
 				       void *iso_req_handle, int packet,
 				       int *status, int *actual, int *offset)
 {
@@ -902,7 +906,7 @@ void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 #endif /* DWC_EN_ISOC */
 
-static void dwc_otg_pcd_init_ep(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * pcd_ep,
+static void dwc_otg_pcd_init_ep(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *pcd_ep,
 				uint32_t is_in, uint32_t ep_num)
 {
 	/* Init EP structure */
@@ -934,7 +938,7 @@ static void dwc_otg_pcd_init_ep(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * pcd_ep,
 /**
  * Initialize ep's
  */
-static void dwc_otg_pcd_reinit(dwc_otg_pcd_t * pcd)
+static void dwc_otg_pcd_reinit(dwc_otg_pcd_t *pcd)
 {
 	int i;
 	uint32_t hwcfg1;
@@ -1009,9 +1013,8 @@ static void srp_timeout(void *ptr)
 			/* Power off the core */
 			if (core_if->power_down == 2) {
 				gpwrdn.b.pwrdnswtch = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gpwrdn,
-						 gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
 			}
 
 			gpwrdn.d32 = 0;
@@ -1035,7 +1038,8 @@ static void srp_timeout(void *ptr)
 
 		if ((core_if->srp_success) && (gotgctl.b.bsesvld)) {
 			if (core_if->pcd_cb && core_if->pcd_cb->resume_wakeup) {
-				core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->p);
+				core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->
+							       p);
 			}
 
 			/* Clear Session Request */
@@ -1065,7 +1069,7 @@ static void srp_timeout(void *ptr)
  * Tasklet
  *
  */
-extern void start_next_request(dwc_otg_pcd_ep_t * ep);
+extern void start_next_request(dwc_otg_pcd_ep_t *ep);
 
 static void start_xfer_tasklet_func(void *data)
 {
@@ -1082,7 +1086,7 @@ static void start_xfer_tasklet_func(void *data)
 	if (pcd->ep0.queue_sof) {
 		pcd->ep0.queue_sof = 0;
 		start_next_request(&pcd->ep0);
-		// break;
+		/* break; */
 	}
 
 	for (i = 0; i < core_if->dev_if->num_in_eps; i++) {
@@ -1093,7 +1097,7 @@ static void start_xfer_tasklet_func(void *data)
 		if (pcd->in_ep[i].queue_sof) {
 			pcd->in_ep[i].queue_sof = 0;
 			start_next_request(&pcd->in_ep[i]);
-			// break;
+			/* break; */
 		}
 	}
 
@@ -1104,7 +1108,7 @@ static void start_xfer_tasklet_func(void *data)
  * This function initialized the PCD portion of the driver.
  *
  */
-dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
+dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_pcd_t *pcd = NULL;
 	dwc_otg_dev_if_t *dev_if;
@@ -1139,12 +1143,12 @@ dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
 	}
 
 	/*
-	 * Initialized the Core for Device mode here if there is nod ADP support. 
+	 * Initialized the Core for Device mode here if there is nod ADP support.
 	 * Otherwise it will be done later in dwc_otg_adp_start routine.
 	 */
-	//if (dwc_otg_is_device_mode(core_if) /*&& !core_if->adp_enable */ ) {
-	//	dwc_otg_core_dev_init(core_if);
-	//}
+	/* if (dwc_otg_is_device_mode(core_if) ) { */
+	/*      dwc_otg_core_dev_init(core_if); */
+	/*} */
 
 	/*
 	 * Register the PCD Callbacks.
@@ -1157,7 +1161,7 @@ dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
 	if (GET_CORE_IF(pcd)->dma_enable) {
 		pcd->setup_pkt =
 		    DWC_DMA_ALLOC_ATOMIC(sizeof(*pcd->setup_pkt) * 5,
-				  &pcd->setup_pkt_dma_handle);
+					 &pcd->setup_pkt_dma_handle);
 		if (pcd->setup_pkt == NULL) {
 			DWC_FREE(pcd);
 			return NULL;
@@ -1165,7 +1169,7 @@ dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
 
 		pcd->status_buf =
 		    DWC_DMA_ALLOC_ATOMIC(sizeof(uint16_t),
-				  &pcd->status_buf_dma_handle);
+					 &pcd->status_buf_dma_handle);
 		if (pcd->status_buf == NULL) {
 			DWC_DMA_FREE(sizeof(*pcd->setup_pkt) * 5,
 				     pcd->setup_pkt, pcd->setup_pkt_dma_handle);
@@ -1260,7 +1264,7 @@ dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
 	core_if->srp_timer = DWC_TIMER_ALLOC("SRP TIMER", srp_timeout, core_if);
 
 	if (core_if->core_params->dev_out_nak) {
-		/** 
+		/**
 		* Initialize xfer timeout timer. Implemented for
 		* 2.93a feature "Device DDMA OUT NAK Enhancement"
 		*/
@@ -1292,7 +1296,7 @@ dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if)
 /**
  * Remove PCD specific data
  */
-void dwc_otg_pcd_remove(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_remove(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(pcd)->dev_if;
 	int i;
@@ -1352,7 +1356,7 @@ void dwc_otg_pcd_remove(dwc_otg_pcd_t * pcd)
 /**
  * Returns whether registered pcd is dual speed or not
  */
-uint32_t dwc_otg_pcd_is_dualspeed(dwc_otg_pcd_t * pcd)
+uint32_t dwc_otg_pcd_is_dualspeed(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 
@@ -1369,28 +1373,28 @@ uint32_t dwc_otg_pcd_is_dualspeed(dwc_otg_pcd_t * pcd)
 /**
  * Returns whether registered pcd is OTG capable or not
  */
-uint32_t dwc_otg_pcd_is_otg(dwc_otg_pcd_t * pcd)
+uint32_t dwc_otg_pcd_is_otg(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	gusbcfg_data_t usbcfg = {.d32 = 0 };
 	uint32_t retval = 0;
 
 	usbcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->gusbcfg);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
 	if (!usbcfg.b.srpcap || !usbcfg.b.hnpcap)
 		return 0;
-	else 
+	else
 		return 1;
 # else
 	if (!usbcfg.b.srpcap)
 		return 0;
-	else 
+	else
 		retval |= 1;
 
 	if (usbcfg.b.hnpcap)
 		retval |= 2;
-	
-	if (core_if->adp_enable) 
+
+	if (core_if->adp_enable)
 		retval |= 4;
 #endif
 
@@ -1401,7 +1405,7 @@ uint32_t dwc_otg_pcd_is_otg(dwc_otg_pcd_t * pcd)
  * This function assigns periodic Tx FIFO to an periodic EP
  * in shared Tx FIFO mode
  */
-static uint32_t assign_tx_fifo(dwc_otg_core_if_t * core_if)
+static uint32_t assign_tx_fifo(dwc_otg_core_if_t *core_if)
 {
 	uint32_t TxMsk = 1;
 	int i;
@@ -1420,7 +1424,7 @@ static uint32_t assign_tx_fifo(dwc_otg_core_if_t * core_if)
  * This function assigns periodic Tx FIFO to an periodic EP
  * in shared Tx FIFO mode
  */
-static uint32_t assign_perio_tx_fifo(dwc_otg_core_if_t * core_if)
+static uint32_t assign_perio_tx_fifo(dwc_otg_core_if_t *core_if)
 {
 	uint32_t PerTxMsk = 1;
 	int i;
@@ -1438,7 +1442,7 @@ static uint32_t assign_perio_tx_fifo(dwc_otg_core_if_t * core_if)
  * This function releases periodic Tx FIFO
  * in shared Tx FIFO mode
  */
-static void release_perio_tx_fifo(dwc_otg_core_if_t * core_if,
+static void release_perio_tx_fifo(dwc_otg_core_if_t *core_if,
 				  uint32_t fifo_num)
 {
 	core_if->p_tx_msk =
@@ -1449,26 +1453,26 @@ static void release_perio_tx_fifo(dwc_otg_core_if_t * core_if,
  * This function releases periodic Tx FIFO
  * in shared Tx FIFO mode
  */
-static void release_tx_fifo(dwc_otg_core_if_t * core_if, uint32_t fifo_num)
+static void release_tx_fifo(dwc_otg_core_if_t *core_if, uint32_t fifo_num)
 {
 	core_if->tx_msk =
 	    (core_if->tx_msk & (1 << (fifo_num - 1))) ^ core_if->tx_msk;
 }
 
 /**
- * This function is being called from gadget 
+ * This function is being called from gadget
  * to enable PCD endpoint.
  */
-int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t * pcd,
-			  const uint8_t * ep_desc, void *usb_ep)
+int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t *pcd,
+			  const uint8_t *ep_desc, void *usb_ep)
 {
 	int num, dir;
 	dwc_otg_pcd_ep_t *ep = NULL;
 	const usb_endpoint_descriptor_t *desc;
 	dwc_irqflags_t flags;
-//	fifosize_data_t dptxfsiz = {.d32 = 0 };
-//	gdfifocfg_data_t gdfifocfg = {.d32 = 0 };
-//	gdfifocfg_data_t gdfifocfgbase = {.d32 = 0 };
+	/* fifosize_data_t dptxfsiz = {.d32 = 0 }; */
+	/* gdfifocfg_data_t gdfifocfg = {.d32 = 0 }; */
+	/* gdfifocfg_data_t gdfifocfgbase = {.d32 = 0 }; */
 	int retval = 0;
 	int i, epcount;
 
@@ -1549,26 +1553,27 @@ int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t * pcd,
 		}
 
 		/* Calculating EP info controller base address */
-		#if 0
+#if 0
 		if (ep->dwc_ep.tx_fifo_num
 		    && GET_CORE_IF(pcd)->en_multiple_tx_fifo) {
 			gdfifocfg.d32 =
-			    DWC_READ_REG32(&GET_CORE_IF(pcd)->
-					   core_global_regs->gdfifocfg);
+			    DWC_READ_REG32(&GET_CORE_IF(pcd)->core_global_regs->
+					   gdfifocfg);
 			gdfifocfgbase.d32 = gdfifocfg.d32 >> 16;
 			dptxfsiz.d32 =
 			    (DWC_READ_REG32
-			     (&GET_CORE_IF(pcd)->core_global_regs->
-			      dtxfsiz[ep->dwc_ep.tx_fifo_num - 1]) >> 16);
+			     (&GET_CORE_IF(pcd)->
+			      core_global_regs->dtxfsiz[ep->dwc_ep.tx_fifo_num -
+							1]) >> 16);
 			gdfifocfg.b.epinfobase =
 			    gdfifocfgbase.d32 + dptxfsiz.d32;
 			if (GET_CORE_IF(pcd)->snpsid <= OTG_CORE_REV_2_94a) {
-				DWC_WRITE_REG32(&GET_CORE_IF(pcd)->
-						core_global_regs->gdfifocfg,
-						gdfifocfg.d32);
+				DWC_WRITE_REG32(&GET_CORE_IF
+						(pcd)->core_global_regs->
+						gdfifocfg, gdfifocfg.d32);
 			}
 		}
-		#endif
+#endif
 	}
 	/* Set initial data PID. */
 	if (ep->dwc_ep.type == UE_BULK) {
@@ -1581,8 +1586,8 @@ int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t * pcd,
 		if (ep->dwc_ep.type != UE_ISOCHRONOUS) {
 #endif
 			ep->dwc_ep.desc_addr =
-			    dwc_otg_ep_alloc_desc_chain(&ep->
-							dwc_ep.dma_desc_addr,
+			    dwc_otg_ep_alloc_desc_chain(&ep->dwc_ep.
+							dma_desc_addr,
 							MAX_DMA_DESC_CNT);
 			if (!ep->dwc_ep.desc_addr) {
 				DWC_WARN("%s, can't allocate DMA descriptor\n",
@@ -1622,10 +1627,10 @@ int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t * pcd,
 }
 
 /**
- * This function is being called from gadget 
+ * This function is being called from gadget
  * to disable PCD endpoint.
  */
-int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle)
+int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t *pcd, void *ep_handle)
 {
 	dwc_otg_pcd_ep_t *ep;
 	dwc_irqflags_t flags;
@@ -1633,7 +1638,7 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle)
 	dwc_dma_t dma_desc_addr;
 	gdfifocfg_data_t gdfifocfgbase = {.d32 = 0 };
 	gdfifocfg_data_t gdfifocfg = {.d32 = 0 };
-//	fifosize_data_t dptxfsiz = {.d32 = 0 };
+	/* fifosize_data_t dptxfsiz = {.d32 = 0 }; */
 
 	ep = get_ep_from_handle(pcd, ep_handle);
 
@@ -1666,20 +1671,22 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle)
 		}
 		release_perio_tx_fifo(GET_CORE_IF(pcd), ep->dwc_ep.tx_fifo_num);
 		release_tx_fifo(GET_CORE_IF(pcd), ep->dwc_ep.tx_fifo_num);
-		#if 0
+#if 0
 		if (GET_CORE_IF(pcd)->en_multiple_tx_fifo) {
 			/* Decreasing EPinfo Base Addr */
 			dptxfsiz.d32 =
 			    (DWC_READ_REG32
-			     (&GET_CORE_IF(pcd)->
-		      		core_global_regs->dtxfsiz[ep->dwc_ep.tx_fifo_num-1]) >> 16);
-			gdfifocfg.b.epinfobase = gdfifocfgbase.d32 - dptxfsiz.d32;
+			     (&GET_CORE_IF(pcd)->core_global_regs->
+			      dtxfsiz[ep->dwc_ep.tx_fifo_num - 1]) >> 16);
+			gdfifocfg.b.epinfobase =
+			    gdfifocfgbase.d32 - dptxfsiz.d32;
 			if (GET_CORE_IF(pcd)->snpsid <= OTG_CORE_REV_2_94a) {
-				DWC_WRITE_REG32(&GET_CORE_IF(pcd)->core_global_regs->gdfifocfg,
+				DWC_WRITE_REG32(&GET_CORE_IF(pcd)->
+						core_global_regs->gdfifocfg,
 						gdfifocfg.d32);
 			}
 		}
-		#endif
+#endif
 	}
 
 	/* Free DMA Descriptors */
@@ -1712,7 +1719,7 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle)
  * Free the request and its extended parts
  *
  */
-void dwc_pcd_xiso_ereq_free(dwc_otg_pcd_ep_t * ep, dwc_otg_pcd_request_t * req)
+void dwc_pcd_xiso_ereq_free(dwc_otg_pcd_ep_t *ep, dwc_otg_pcd_request_t *req)
 {
 	DWC_FREE(req->ext_req.per_io_frame_descs);
 	DWC_FREE(req);
@@ -1722,8 +1729,8 @@ void dwc_pcd_xiso_ereq_free(dwc_otg_pcd_ep_t * ep, dwc_otg_pcd_request_t * req)
  * Start the next request in the endpoint's queue.
  *
  */
-int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
-					dwc_otg_pcd_ep_t * ep)
+int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t *pcd,
+					dwc_otg_pcd_ep_t *ep)
 {
 	int i;
 	dwc_otg_pcd_request_t *req = NULL;
@@ -1736,10 +1743,12 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
 	dwcep = &ep->dwc_ep;
 
 	if (dwcep->xiso_active_xfers > 0) {
-#if 0	//Disable this to decrease s/w overhead that is crucial for Isoc transfers
+#if 0
+		/* Disable this to decrease s/w overhead
+		 * that is crucial for Isoc transfers */
 		DWC_WARN("There are currently active transfers for EP%d \
-				(active=%d; queued=%d)", dwcep->num, dwcep->xiso_active_xfers, 
-				dwcep->xiso_queued_xfers);
+			(active=%d; queued=%d)", dwcep->num,
+			dwcep->xiso_active_xfers, dwcep->xiso_queued_xfers);
 #endif
 		return 0;
 	}
@@ -1762,7 +1771,7 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
 		if (dwcep->is_in) {
 			/* Setup DMA Descriptor chain for IN Isoc request */
 			for (i = 0; i < ereq->pio_pkt_count; i++) {
-				//if ((i % (nat + 1)) == 0)
+				/* if ((i % (nat + 1)) == 0) */
 				if (i > 0)
 					dwcep->xiso_frame_num =
 					    (dwcep->xiso_bInterval +
@@ -1780,33 +1789,38 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
 				    (ddesc_iso[i].length %
 				     dwcep->maxpacket) ? 1 : 0;
 				dwcep->desc_addr[i].status.b_iso_in.ioc = 0;
-				dwcep->desc_addr[i].status.b_iso_in.pid = nat + 1;
+				dwcep->desc_addr[i].status.b_iso_in.pid =
+				    nat + 1;
 				dwcep->desc_addr[i].status.b_iso_in.l = 0;
 
 				/* Process the last descriptor */
 				if (i == ereq->pio_pkt_count - 1) {
-					dwcep->desc_addr[i].status.b_iso_in.ioc = 1;
-					dwcep->desc_addr[i].status.b_iso_in.l = 1;
+					dwcep->desc_addr[i].status.b_iso_in.
+					    ioc = 1;
+					dwcep->desc_addr[i].status.b_iso_in.l =
+					    1;
 				}
 			}
 
 			/* Setup and start the transfer for this endpoint */
 			dwcep->xiso_active_xfers++;
-			DWC_WRITE_REG32(&GET_CORE_IF(pcd)->dev_if->
-					in_ep_regs[dwcep->num]->diepdma,
+			DWC_WRITE_REG32(&GET_CORE_IF(pcd)->
+					dev_if->in_ep_regs[dwcep->num]->diepdma,
 					dwcep->dma_desc_addr);
 			diepctl.d32 = 0;
 			diepctl.b.epena = 1;
 			diepctl.b.cnak = 1;
-			DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->dev_if->
-					 in_ep_regs[dwcep->num]->diepctl, 0,
-					 diepctl.d32);
+			DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->
+					 dev_if->in_ep_regs[dwcep->num]->
+					 diepctl, 0, diepctl.d32);
 		} else {
 			/* Setup DMA Descriptor chain for OUT Isoc request */
 			for (i = 0; i < ereq->pio_pkt_count; i++) {
-				//if ((i % (nat + 1)) == 0)
-				dwcep->xiso_frame_num = (dwcep->xiso_bInterval + 
-										dwcep->xiso_frame_num) & 0x3FFF;
+				/* if ((i % (nat + 1)) == 0) */
+				dwcep->xiso_frame_num = (dwcep->xiso_bInterval +
+							 dwcep->
+							 xiso_frame_num) &
+				    0x3FFF;
 				dwcep->desc_addr[i].buf =
 				    req->dma + ddesc_iso[i].offset;
 				dwcep->desc_addr[i].status.b_iso_out.rxbytes =
@@ -1820,27 +1834,30 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
 				    (ddesc_iso[i].length %
 				     dwcep->maxpacket) ? 1 : 0;
 				dwcep->desc_addr[i].status.b_iso_out.ioc = 0;
-				dwcep->desc_addr[i].status.b_iso_out.pid = nat + 1;
+				dwcep->desc_addr[i].status.b_iso_out.pid =
+				    nat + 1;
 				dwcep->desc_addr[i].status.b_iso_out.l = 0;
-				
+
 				/* Process the last descriptor */
 				if (i == ereq->pio_pkt_count - 1) {
-					dwcep->desc_addr[i].status.b_iso_out.ioc = 1;
-					dwcep->desc_addr[i].status.b_iso_out.l = 1;
-				}			
+					dwcep->desc_addr[i].status.b_iso_out.
+					    ioc = 1;
+					dwcep->desc_addr[i].status.b_iso_out.l =
+					    1;
+				}
 			}
-			
+
 			/* Setup and start the transfer for this endpoint */
 			dwcep->xiso_active_xfers++;
-			DWC_WRITE_REG32(&GET_CORE_IF(pcd)->
-					dev_if->out_ep_regs[dwcep->num]->
-					doepdma, dwcep->dma_desc_addr);
+			DWC_WRITE_REG32(&GET_CORE_IF(pcd)->dev_if->
+					out_ep_regs[dwcep->num]->doepdma,
+					dwcep->dma_desc_addr);
 			diepctl.d32 = 0;
 			diepctl.b.epena = 1;
 			diepctl.b.cnak = 1;
-			DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->
-					 dev_if->out_ep_regs[dwcep->num]->
-					 doepctl, 0, diepctl.d32);
+			DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->dev_if->
+					 out_ep_regs[dwcep->num]->doepctl, 0,
+					 diepctl.d32);
 		}
 
 	} else {
@@ -1853,7 +1870,7 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t * pcd,
 /**
  *	- Remove the request from the queue
  */
-void complete_xiso_ep(dwc_otg_pcd_ep_t * ep)
+void complete_xiso_ep(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_pcd_request_t *req = NULL;
 	struct dwc_iso_xreq_port *ereq = NULL;
@@ -1861,7 +1878,7 @@ void complete_xiso_ep(dwc_otg_pcd_ep_t * ep)
 	dwc_ep_t *dwcep = NULL;
 	int i;
 
-	//DWC_DEBUG();
+	/* DWC_DEBUG(); */
 	dwcep = &ep->dwc_ep;
 
 	/* Get the first pending request from the queue */
@@ -1925,7 +1942,7 @@ void complete_xiso_ep(dwc_otg_pcd_ep_t * ep)
  * Create and initialize the Isoc pkt descriptors of the extended request.
  *
  */
-static int dwc_otg_pcd_xiso_create_pkt_descs(dwc_otg_pcd_request_t * req,
+static int dwc_otg_pcd_xiso_create_pkt_descs(dwc_otg_pcd_request_t *req,
 					     void *ereq_nonport,
 					     int atomic_alloc)
 {
@@ -1996,8 +2013,8 @@ static void prn_ext_request(struct dwc_iso_xreq_port *ereq)
 /**
  *
  */
-int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
-			      uint8_t * buf, dwc_dma_t dma_buf, uint32_t buflen,
+int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t *pcd, void *ep_handle,
+			      uint8_t *buf, dwc_dma_t dma_buf, uint32_t buflen,
 			      int zero, void *req_handle, int atomic_alloc,
 			      void *ereq_nonport)
 {
@@ -2047,7 +2064,7 @@ int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 	req->sent_zlp = zero;
 	req->priv = req_handle;
 
-	//DWC_SPINLOCK_IRQSAVE(pcd->lock, &flags);
+	/* DWC_SPINLOCK_IRQSAVE(pcd->lock, &flags); */
 	ep->dwc_ep.dma_addr = dma_buf;
 	ep->dwc_ep.start_xfer_buff = buf;
 	ep->dwc_ep.xfer_buff = buf;
@@ -2060,12 +2077,12 @@ int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 	DWC_CIRCLEQ_INSERT_TAIL(&ep->queue, req, queue_entry);
 	ep->dwc_ep.xiso_queued_xfers++;
 
-//DWC_DEBUG("CP_0");
-//DWC_DEBUG("req->ext_req.tr_sub_flags=%d", req->ext_req.tr_sub_flags);
-//prn_ext_request((struct dwc_iso_xreq_port *) ereq_nonport);
-//prn_ext_request(&req->ext_req);
+	/* DWC_DEBUG("CP_0"); */
+	/* DWC_DEBUG("req->ext_req.tr_sub_flags=%d", req->ext_req.tr_sub_flags); */
+	/* prn_ext_request((struct dwc_iso_xreq_port *) ereq_nonport); */
+	/* prn_ext_request(&req->ext_req); */
 
-	//DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags);
+	/* DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags); */
 
 	/* If the req->status == ASAP  then check if there is any active transfer
 	 * for this endpoint. If no active transfers, then get the first entry
@@ -2087,8 +2104,8 @@ int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 #endif
 /* END ifdef DWC_UTE_PER_IO ***************************************************/
-int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
-			 uint8_t * buf, dwc_dma_t dma_buf, uint32_t buflen,
+int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t *pcd, void *ep_handle,
+			 uint8_t *buf, dwc_dma_t dma_buf, uint32_t buflen,
 			 int zero, void *req_handle, int atomic_alloc)
 {
 	dwc_irqflags_t flags;
@@ -2133,24 +2150,27 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 	/*
 	 * After adding request to the queue for IN ISOC wait for In Token Received
-	 * when TX FIFO is empty interrupt and for OUT ISOC wait for OUT Token 
+	 * when TX FIFO is empty interrupt and for OUT ISOC wait for OUT Token
 	 * Received when EP is disabled interrupt to obtain starting microframe
 	 * (odd/even) start transfer
 	 */
 	if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
 		if (req != 0) {
 			depctl_data_t depctl = {.d32 =
-				    DWC_READ_REG32(&pcd->core_if->dev_if->
-						   in_ep_regs[ep->dwc_ep.num]->
-						   diepctl) };
+				    DWC_READ_REG32(&pcd->core_if->
+						   dev_if->in_ep_regs[ep->
+								      dwc_ep.
+								      num]->diepctl)
+			};
 			++pcd->request_pending;
 
 			DWC_CIRCLEQ_INSERT_TAIL(&ep->queue, req, queue_entry);
 			if (ep->dwc_ep.is_in) {
 				depctl.b.cnak = 1;
-				DWC_WRITE_REG32(&pcd->core_if->dev_if->
-						in_ep_regs[ep->dwc_ep.num]->
-						diepctl, depctl.d32);
+				DWC_WRITE_REG32(&pcd->core_if->
+						dev_if->in_ep_regs[ep->dwc_ep.
+								   num]->diepctl,
+						depctl.d32);
 			}
 
 			DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags);
@@ -2163,7 +2183,7 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 	 */
 	if (ep->dwc_ep.num == 0 && ep->dwc_ep.is_in) {
 		DWC_DEBUGPL(DBG_PCDV, "%d-OUT ZLP\n", ep->dwc_ep.num);
-		//_req->zero = 1;
+		/* _req->zero = 1; */
 	}
 
 	/* Start the transfer */
@@ -2220,7 +2240,7 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 			dwc_otg_ep0_start_transfer(GET_CORE_IF(pcd),
 						   &ep->dwc_ep);
-		}		// non-ep0 endpoints
+		}		/* non-ep0 endpoints */
 		else {
 #ifdef DWC_UTE_CFI
 			if (ep->dwc_ep.buff_mode != BM_STANDARD) {
@@ -2231,8 +2251,8 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 			} else {
 #endif
 				max_transfer =
-				    GET_CORE_IF(ep->pcd)->core_params->
-				    max_transfer_size;
+				    GET_CORE_IF(ep->pcd)->
+				    core_params->max_transfer_size;
 
 				/* Setup and start the Transfer */
 				if (req->dw_align_buf) {
@@ -2304,14 +2324,14 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 			diepmsk_data_t diepmsk = {.d32 = 0 };
 			diepmsk.b.intktxfemp = 1;
 			if (GET_CORE_IF(pcd)->multiproc_int_enable) {
-				DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->
-						 dev_if->dev_global_regs->diepeachintmsk
-						 [ep->dwc_ep.num], 0,
-						 diepmsk.d32);
+				DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->dev_if->
+						 dev_global_regs->
+						 diepeachintmsk[ep->dwc_ep.num],
+						 0, diepmsk.d32);
 			} else {
-				DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->
-						 dev_if->dev_global_regs->
-						 diepmsk, 0, diepmsk.d32);
+				DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->dev_if->
+						 dev_global_regs->diepmsk, 0,
+						 diepmsk.d32);
 			}
 
 		}
@@ -2321,7 +2341,7 @@ int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
 	return 0;
 }
 
-int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t * pcd, void *ep_handle,
+int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t *pcd, void *ep_handle,
 			   void *req_handle)
 {
 	dwc_irqflags_t flags;
@@ -2360,7 +2380,7 @@ int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t * pcd, void *ep_handle,
 
 }
 
-int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t * pcd, void *ep_handle, int value)
+int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t *pcd, void *ep_handle, int value)
 {
 	dwc_otg_pcd_ep_t *ep;
 	dwc_irqflags_t flags;
@@ -2380,22 +2400,20 @@ int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t * pcd, void *ep_handle, int value)
 			 ep->dwc_ep.is_in ? "IN" : "OUT");
 		retval = -DWC_E_AGAIN;
 	} else if (value == 0) {
-	    ep->dwc_ep.stall_clear_flag = 0;
+		ep->dwc_ep.stall_clear_flag = 0;
 		dwc_otg_ep_clear_stall(GET_CORE_IF(pcd), &ep->dwc_ep);
 	} else if (value == 1) {
-	stall:
+stall:
 		if (ep->dwc_ep.is_in == 1 && GET_CORE_IF(pcd)->dma_desc_enable) {
 			dtxfsts_data_t txstatus;
 			fifosize_data_t txfifosize;
 
 			txfifosize.d32 =
-			    DWC_READ_REG32(&GET_CORE_IF(pcd)->
-					   core_global_regs->dtxfsiz[ep->dwc_ep.
-								     tx_fifo_num]);
+			    DWC_READ_REG32(&GET_CORE_IF(pcd)->core_global_regs->
+					   dtxfsiz[ep->dwc_ep.tx_fifo_num]);
 			txstatus.d32 =
-			    DWC_READ_REG32(&GET_CORE_IF(pcd)->
-					   dev_if->in_ep_regs[ep->dwc_ep.num]->
-					   dtxfsts);
+			    DWC_READ_REG32(&GET_CORE_IF(pcd)->dev_if->
+					   in_ep_regs[ep->dwc_ep.num]->dtxfsts);
 
 			if (txstatus.b.txfspcavail < txfifosize.b.depth) {
 				DWC_WARN("%s() Data In Tx Fifo\n", __func__);
@@ -2432,7 +2450,7 @@ int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t * pcd, void *ep_handle, int value)
 /**
  * This function initiates remote wakeup of the host from suspend state.
  */
-void dwc_otg_pcd_rem_wkup_from_suspend(dwc_otg_pcd_t * pcd, int set)
+void dwc_otg_pcd_rem_wkup_from_suspend(dwc_otg_pcd_t *pcd, int set)
 {
 	dctl_data_t dctl = { 0 };
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
@@ -2454,16 +2472,14 @@ void dwc_otg_pcd_rem_wkup_from_suspend(dwc_otg_pcd_t * pcd, int set)
 				/* Mask SRP detected interrupt from Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.srp_det_msk = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gpwrdn,
-						 gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
 
 				/* Disable Power Down Logic */
 				gpwrdn.d32 = 0;
 				gpwrdn.b.pmuactv = 1;
-				DWC_MODIFY_REG32(&core_if->
-						 core_global_regs->gpwrdn,
-						 gpwrdn.d32, 0);
+				DWC_MODIFY_REG32(&core_if->core_global_regs->
+						 gpwrdn, gpwrdn.d32, 0);
 
 				/*
 				 * Initialize the Core for Device mode.
@@ -2477,13 +2493,13 @@ void dwc_otg_pcd_rem_wkup_from_suspend(dwc_otg_pcd_t * pcd, int set)
 			}
 
 			dctl.b.rmtwkupsig = 1;
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
-					 dctl, 0, dctl.d32);
+			DWC_MODIFY_REG32(&core_if->dev_if->
+					 dev_global_regs->dctl, 0, dctl.d32);
 			DWC_DEBUGPL(DBG_PCD, "Set Remote Wakeup\n");
 
 			dwc_mdelay(2);
-			DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->
-					 dctl, dctl.d32, 0);
+			DWC_MODIFY_REG32(&core_if->dev_if->
+					 dev_global_regs->dctl, dctl.d32, 0);
 			DWC_DEBUGPL(DBG_PCD, "Clear Remote Wakeup\n");
 		}
 	} else {
@@ -2495,11 +2511,11 @@ void dwc_otg_pcd_rem_wkup_from_suspend(dwc_otg_pcd_t * pcd, int set)
 /**
  * This function initiates remote wakeup of the host from L1 sleep state.
  */
-void dwc_otg_pcd_rem_wkup_from_sleep(dwc_otg_pcd_t * pcd, int set)
+void dwc_otg_pcd_rem_wkup_from_sleep(dwc_otg_pcd_t *pcd, int set)
 {
 	glpmcfg_data_t lpmcfg;
 	pcgcctl_data_t pcgcctl = {.d32 = 0 };
-	
+
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
@@ -2525,11 +2541,11 @@ void dwc_otg_pcd_rem_wkup_from_sleep(dwc_otg_pcd_t * pcd, int set)
 	lpmcfg.d32 = DWC_READ_REG32(&core_if->core_global_regs->glpmcfg);
 	lpmcfg.b.en_utmi_sleep = 0;
 	lpmcfg.b.hird_thres &= (~(1 << 4));
-	
+
 	/* Clear Enbl_L1Gating bit. */
 	pcgcctl.b.enbl_sleep_gating = 1;
-	DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32,0);
-			
+	DWC_MODIFY_REG32(core_if->pcgcctl, pcgcctl.d32, 0);
+
 	DWC_WRITE_REG32(&core_if->core_global_regs->glpmcfg, lpmcfg.d32);
 
 	if (set) {
@@ -2549,7 +2565,7 @@ void dwc_otg_pcd_rem_wkup_from_sleep(dwc_otg_pcd_t * pcd, int set)
 /**
  * Performs remote wakeup.
  */
-void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t * pcd, int set)
+void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t *pcd, int set)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_irqflags_t flags;
@@ -2569,26 +2585,28 @@ void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t * pcd, int set)
 	return;
 }
 
-void dwc_otg_pcd_disconnect_us(dwc_otg_pcd_t * pcd, int no_of_usecs)
+void dwc_otg_pcd_disconnect_us(dwc_otg_pcd_t *pcd, int no_of_usecs)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dctl_data_t dctl = { 0 };
 
 	if (dwc_otg_is_device_mode(core_if)) {
 		dctl.b.sftdiscon = 1;
-		DWC_PRINTF("Soft disconnect for %d useconds\n",no_of_usecs);
-		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0, dctl.d32);
+		DWC_PRINTF("Soft disconnect for %d useconds\n", no_of_usecs);
+		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, 0,
+				 dctl.d32);
 		dwc_udelay(no_of_usecs);
-		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32,0);
-		
-	} else{
+		DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				 dctl.d32, 0);
+
+	} else {
 		DWC_PRINTF("NOT SUPPORTED IN HOST MODE\n");
 	}
 	return;
 
 }
 
-int dwc_otg_pcd_wakeup(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_wakeup(dwc_otg_pcd_t *pcd)
 {
 	dsts_data_t dsts;
 	gotgctl_data_t gotgctl;
@@ -2606,8 +2624,8 @@ int dwc_otg_pcd_wakeup(dwc_otg_pcd_t * pcd)
 		/* Check if suspend state */
 		dsts.d32 =
 		    DWC_READ_REG32(&
-				   (GET_CORE_IF(pcd)->dev_if->
-				    dev_global_regs->dsts));
+				   (GET_CORE_IF(pcd)->dev_if->dev_global_regs->
+				    dsts));
 		if (dsts.b.suspsts) {
 			dwc_otg_pcd_remote_wakeup(pcd, 1);
 		}
@@ -2619,31 +2637,32 @@ int dwc_otg_pcd_wakeup(dwc_otg_pcd_t * pcd)
 
 }
 
-
 /**
  * Implement Soft-Connect and Soft-Disconnect function
  */
 
-void dwc_otg_pcd_pullup_enable(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_pullup_enable(dwc_otg_pcd_t *pcd)
 {
-    if(pcd);
-        DWC_MODIFY_REG32( &(GET_CORE_IF(pcd)->dev_if->dev_global_regs->dctl),2,0 );
+	if (pcd)
+	DWC_MODIFY_REG32(&(GET_CORE_IF(pcd)->dev_if->dev_global_regs->dctl), 2,
+			 0);
 }
 
-void dwc_otg_pcd_pullup_disable(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_pullup_disable(dwc_otg_pcd_t *pcd)
 {
-    if(pcd);
-        DWC_MODIFY_REG32( &(GET_CORE_IF(pcd)->dev_if->dev_global_regs->dctl),0,2 );
+	if (pcd)
+	DWC_MODIFY_REG32(&(GET_CORE_IF(pcd)->dev_if->dev_global_regs->dctl), 0,
+			 2);
 }
 
 void dwc_pcd_reset(dwc_otg_pcd_t *pcd)
 {
-    dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
-    dwc_otg_disable_global_interrupts(core_if);
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
+	dwc_otg_disable_global_interrupts(core_if);
 	dwc_otg_core_init(core_if);
-    dwc_otg_pcd_reinit(pcd);
-    dwc_otg_core_dev_init(core_if);
-    dwc_otg_enable_global_interrupts(core_if);
+	dwc_otg_pcd_reinit(pcd);
+	dwc_otg_core_dev_init(core_if);
+	dwc_otg_enable_global_interrupts(core_if);
 }
 
 /**
@@ -2652,7 +2671,7 @@ void dwc_pcd_reset(dwc_otg_pcd_t *pcd)
  *
  * @param pcd the pcd structure.
  */
-void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t *pcd)
 {
 	dwc_irqflags_t flags;
 	DWC_SPINLOCK_IRQSAVE(pcd->lock, &flags);
@@ -2660,47 +2679,47 @@ void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t * pcd)
 	DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags);
 }
 
-int dwc_otg_pcd_get_frame_number(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_get_frame_number(dwc_otg_pcd_t *pcd)
 {
 	return dwc_otg_get_frame_number(GET_CORE_IF(pcd));
 }
 
-int dwc_otg_pcd_is_lpm_enabled(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_is_lpm_enabled(dwc_otg_pcd_t *pcd)
 {
 	return GET_CORE_IF(pcd)->core_params->lpm_enable;
 }
 
-int dwc_otg_pcd_is_besl_enabled(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_is_besl_enabled(dwc_otg_pcd_t *pcd)
 {
 	return GET_CORE_IF(pcd)->core_params->besl_enable;
 }
 
-int dwc_otg_pcd_get_param_baseline_besl(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_get_param_baseline_besl(dwc_otg_pcd_t *pcd)
 {
 	return GET_CORE_IF(pcd)->core_params->baseline_besl;
 }
 
-int dwc_otg_pcd_get_param_deep_besl(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_get_param_deep_besl(dwc_otg_pcd_t *pcd)
 {
 	return GET_CORE_IF(pcd)->core_params->deep_besl;
 }
 
-uint32_t get_b_hnp_enable(dwc_otg_pcd_t * pcd)
+uint32_t get_b_hnp_enable(dwc_otg_pcd_t *pcd)
 {
 	return pcd->b_hnp_enable;
 }
 
-uint32_t get_a_hnp_support(dwc_otg_pcd_t * pcd)
+uint32_t get_a_hnp_support(dwc_otg_pcd_t *pcd)
 {
 	return pcd->a_hnp_support;
 }
 
-uint32_t get_a_alt_hnp_support(dwc_otg_pcd_t * pcd)
+uint32_t get_a_alt_hnp_support(dwc_otg_pcd_t *pcd)
 {
 	return pcd->a_alt_hnp_support;
 }
 
-int dwc_otg_pcd_get_rmwkup_enable(dwc_otg_pcd_t * pcd)
+int dwc_otg_pcd_get_rmwkup_enable(dwc_otg_pcd_t *pcd)
 {
 	return pcd->remote_wakeup_enable;
 }
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_pcd.h b/drivers/usb/dwc_otg_310/dwc_otg_pcd.h
index c87f5b413d52..0618692b8a60 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_pcd.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_pcd.h
@@ -64,7 +64,7 @@ struct cfiobject;
 /**
  * Get the pointer to the core_if from the pcd pointer.
  */
-#define GET_CORE_IF( _pcd ) (_pcd->core_if)
+#define GET_CORE_IF(_pcd) (_pcd->core_if)
 
 /**
  * States of EP0.
@@ -143,7 +143,7 @@ typedef struct dwc_otg_pcd_request {
 	 DWC_CIRCLEQ_ENTRY(dwc_otg_pcd_request) queue_entry;
 #ifdef DWC_UTE_PER_IO
 	struct dwc_iso_xreq_port ext_req;
-	//void *priv_ereq_nport; /*  */
+	/* void *priv_ereq_nport; */
 #endif
 } dwc_otg_pcd_request_t;
 
@@ -167,7 +167,7 @@ typedef struct dwc_otg_pcd_ep {
 #ifdef DWC_EN_ISOC
 	/** ISOC req handle passed */
 	void *iso_req_handle;
-#endif				//_EN_ISOC_
+#endif /* _EN_ISOC_ */
 
 	/** DWC_otg ep data. */
 	dwc_ep_t dwc_ep;
@@ -231,7 +231,7 @@ struct dwc_otg_pcd {
 	/** Array of OUT EPs. */
 	dwc_otg_pcd_ep_t out_ep[MAX_EPS_CHANNELS - 1];
 	/** number of valid EPs in the above array. */
-//        unsigned      num_eps : 4;
+	/** unsigned      num_eps : 4; */
 	dwc_spinlock_t *lock;
 
 	/** Tasklet to defer starting of TEST mode transmissions until
@@ -260,23 +260,24 @@ struct dwc_otg_pcd {
 	/** connect status used during enumeration */
 	int8_t conn_status;
 	/* otg check vbus work and connect work,used for power management */
-	struct delayed_work	reconnect;
-	struct delayed_work	check_vbus_work;
+	struct delayed_work reconnect;
+	struct delayed_work check_vbus_work;
 	/** pervent device suspend while usb connected */
 	struct wake_lock wake_lock;
 
 };
 
-//FIXME this functions should be static, and this prototypes should be removed
-extern void dwc_otg_request_nuke(dwc_otg_pcd_ep_t * ep);
-extern void dwc_otg_request_done(dwc_otg_pcd_ep_t * ep,
-				 dwc_otg_pcd_request_t * req, int32_t status);
+/* FIXME this functions should be static,
+ * and this prototypes should be removed */
+extern void dwc_otg_request_nuke(dwc_otg_pcd_ep_t *ep);
+extern void dwc_otg_request_done(dwc_otg_pcd_ep_t *ep,
+				 dwc_otg_pcd_request_t *req, int32_t status);
 
-void dwc_otg_iso_buffer_done(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep,
+void dwc_otg_iso_buffer_done(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *ep,
 			     void *req_handle);
 
 extern void do_test_mode(void *data);
 extern void dwc_pcd_reset(dwc_otg_pcd_t *pcd);
-extern void dwc_otg_pcd_start_check_vbus_work(dwc_otg_pcd_t * pcd);
+extern void dwc_otg_pcd_start_check_vbus_work(dwc_otg_pcd_t *pcd);
 #endif
 #endif /* DWC_HOST_ONLY */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_pcd_if.h b/drivers/usb/dwc_otg_310/dwc_otg_pcd_if.h
index 9a71d0d54539..32d7c21f5cc1 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_pcd_if.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_pcd_if.h
@@ -35,7 +35,7 @@
 #if !defined(__DWC_PCD_IF_H__)
 #define __DWC_PCD_IF_H__
 
-//#include "common_port/dwc_os.h"
+/* #include "common_port/dwc_os.h" */
 #include "dwc_otg_core_if.h"
 
 /** @file
@@ -58,7 +58,7 @@ typedef struct dwc_otg_pcd dwc_otg_pcd_t;
  * failed or aborted transfer, or -DWC_E_RESTART to indicate the device was reset,
  * or -DWC_E_TIMEOUT to indicate it timed out, or -DWC_E_INVALID to indicate invalid
  * parameters. */
-typedef int (*dwc_completion_cb_t) (dwc_otg_pcd_t * pcd, void *ep_handle,
+typedef int (*dwc_completion_cb_t) (dwc_otg_pcd_t *pcd, void *ep_handle,
 				    void *req_handle, int32_t status,
 				    uint32_t actual);
 /**
@@ -68,7 +68,7 @@ typedef int (*dwc_completion_cb_t) (dwc_otg_pcd_t * pcd, void *ep_handle,
  * The status of each ISOC packet could be read using dwc_otg_pcd_get_iso_packet_*
  * functions.
  */
-typedef int (*dwc_isoc_completion_cb_t) (dwc_otg_pcd_t * pcd, void *ep_handle,
+typedef int (*dwc_isoc_completion_cb_t) (dwc_otg_pcd_t *pcd, void *ep_handle,
 					 void *req_handle, int proc_buf_num);
 /** This function should handle any SETUP request that cannot be handled by the
  * PCD Core.  This includes most GET_DESCRIPTORs, SET_CONFIGS, Any
@@ -78,30 +78,30 @@ typedef int (*dwc_isoc_completion_cb_t) (dwc_otg_pcd_t * pcd, void *ep_handle,
  * Returns -DWC_E_NOT_SUPPORTED if the request is not supported.
  * Returns -DWC_E_INVALID if the setup request had invalid parameters or bytes.
  * Returns -DWC_E_SHUTDOWN on any other error. */
-typedef int (*dwc_setup_cb_t) (dwc_otg_pcd_t * pcd, uint8_t * bytes);
+typedef int (*dwc_setup_cb_t) (dwc_otg_pcd_t *pcd, uint8_t *bytes);
 /** This is called whenever the device has been disconnected.  The function
  * driver should take appropriate action to clean up all pending requests in the
  * PCD Core, remove all endpoints (except ep0), and initialize back to reset
  * state. */
-typedef int (*dwc_disconnect_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_disconnect_cb_t) (dwc_otg_pcd_t *pcd);
 /** This function is called when device has been connected. */
-typedef int (*dwc_connect_cb_t) (dwc_otg_pcd_t * pcd, int speed);
+typedef int (*dwc_connect_cb_t) (dwc_otg_pcd_t *pcd, int speed);
 /** This function is called when device has been suspended */
-typedef int (*dwc_suspend_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_suspend_cb_t) (dwc_otg_pcd_t *pcd);
 /** This function is called when device has received LPM tokens, i.e.
  * device has been sent to sleep state. */
-typedef int (*dwc_sleep_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_sleep_cb_t) (dwc_otg_pcd_t *pcd);
 /** This function is called when device has been resumed
  * from suspend(L2) or L1 sleep state. */
-typedef int (*dwc_resume_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_resume_cb_t) (dwc_otg_pcd_t *pcd);
 /** This function is called whenever hnp params has been changed.
  * User can call get_b_hnp_enable, get_a_hnp_support, get_a_alt_hnp_support functions
  * to get hnp parameters. */
-typedef int (*dwc_hnp_params_changed_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_hnp_params_changed_cb_t) (dwc_otg_pcd_t *pcd);
 /** This function is called whenever USB RESET is detected. */
-typedef int (*dwc_reset_cb_t) (dwc_otg_pcd_t * pcd);
+typedef int (*dwc_reset_cb_t) (dwc_otg_pcd_t *pcd);
 
-typedef int (*cfi_setup_cb_t) (dwc_otg_pcd_t * pcd, void *ctrl_req_bytes);
+typedef int (*cfi_setup_cb_t) (dwc_otg_pcd_t *pcd, void *ctrl_req_bytes);
 
 /**
  *
@@ -109,7 +109,7 @@ typedef int (*cfi_setup_cb_t) (dwc_otg_pcd_t * pcd, void *ctrl_req_bytes);
  * @param ereq_port Pointer to the extended request structure created in the
  *					portable part.
  */
-typedef int (*xiso_completion_cb_t) (dwc_otg_pcd_t * pcd, void *ep_handle,
+typedef int (*xiso_completion_cb_t) (dwc_otg_pcd_t *pcd, void *ep_handle,
 				     void *req_handle, int32_t status,
 				     void *ereq_port);
 /** Function Driver Ops Data Structure */
@@ -139,20 +139,20 @@ struct dwc_otg_pcd_function_ops {
  *
  * @param core_if The DWC_OTG Core
  */
-extern dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t * core_if);
+extern dwc_otg_pcd_t *dwc_otg_pcd_init(dwc_otg_core_if_t *core_if);
 
 /** Frees PCD allocated by dwc_otg_pcd_init
  *
  * @param pcd The PCD
  */
-extern void dwc_otg_pcd_remove(dwc_otg_pcd_t * pcd);
+extern void dwc_otg_pcd_remove(dwc_otg_pcd_t *pcd);
 
 /** Call this to bind the function driver to the PCD Core.
  *
  * @param pcd Pointer on dwc_otg_pcd_t returned by dwc_otg_pcd_init function.
  * @param fops The Function Driver Ops data structure containing pointers to all callbacks.
  */
-extern void dwc_otg_pcd_start(dwc_otg_pcd_t * pcd,
+extern void dwc_otg_pcd_start(dwc_otg_pcd_t *pcd,
 			      const struct dwc_otg_pcd_function_ops *fops);
 
 /** Enables an endpoint for use.  This function enables an endpoint in
@@ -170,15 +170,15 @@ extern void dwc_otg_pcd_start(dwc_otg_pcd_t * pcd,
  * @param ep_desc Endpoint descriptor
  * @param ep_handle Handle on endpoint, that will be used to identify endpoint.
  */
-extern int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t * pcd,
-				 const uint8_t * ep_desc, void *ep_handle);
+extern int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t *pcd,
+				 const uint8_t *ep_desc, void *ep_handle);
 
 /** Disable the endpoint referenced by ep_handle.
  *
  * Returns -DWC_E_INVALID if invalid parameters were passed.
  * Returns -DWC_E_SHUTDOWN if any other error occurred.
  * Returns 0 on success. */
-extern int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle);
+extern int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t *pcd, void *ep_handle);
 
 /** Queue a data transfer request on the endpoint referenced by ep_handle.
  * After the transfer is completes, the complete callback will be called with
@@ -198,8 +198,8 @@ extern int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t * pcd, void *ep_handle);
  * Returns -DWC_E_INVALID if invalid parameters were passed.
  * Returns -DWC_E_SHUTDOWN if any other error ocurred.
  * Returns 0 on success. */
-extern int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
-				uint8_t * buf, dwc_dma_t dma_buf,
+extern int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t *pcd, void *ep_handle,
+				uint8_t *buf, dwc_dma_t dma_buf,
 				uint32_t buflen, int zero, void *req_handle,
 				int atomic_alloc);
 #ifdef DWC_UTE_PER_IO
@@ -208,8 +208,8 @@ extern int dwc_otg_pcd_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
  * @param ereq_nonport	Pointer to the extended request part of the
  *						usb_request structure defined in usb_gadget.h file.
  */
-extern int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
-				     uint8_t * buf, dwc_dma_t dma_buf,
+extern int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t *pcd, void *ep_handle,
+				     uint8_t *buf, dwc_dma_t dma_buf,
 				     uint32_t buflen, int zero,
 				     void *req_handle, int atomic_alloc,
 				     void *ereq_nonport);
@@ -221,7 +221,7 @@ extern int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t * pcd, void *ep_handle,
  * Returns -DWC_E_INVALID if invalid parameters were passed.
  * Returns -DWC_E_SHUTDOWN if any other error ocurred.
  * Returns 0 on success. */
-extern int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t * pcd, void *ep_handle,
+extern int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t *pcd, void *ep_handle,
 				  void *req_handle);
 
 /** Halt (STALL) an endpoint or clear it.
@@ -230,13 +230,13 @@ extern int dwc_otg_pcd_ep_dequeue(dwc_otg_pcd_t * pcd, void *ep_handle,
  * Returns -DWC_E_SHUTDOWN if any other error ocurred.
  * Returns -DWC_E_AGAIN if the STALL cannot be sent and must be tried again later
  * Returns 0 on success. */
-extern int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t * pcd, void *ep_handle, int value);
+extern int dwc_otg_pcd_ep_halt(dwc_otg_pcd_t *pcd, void *ep_handle, int value);
 
 /** This function should be called on every hardware interrupt */
-extern int32_t dwc_otg_pcd_handle_intr(dwc_otg_pcd_t * pcd);
+extern int32_t dwc_otg_pcd_handle_intr(dwc_otg_pcd_t *pcd);
 
 /** This function returns current frame number */
-extern int dwc_otg_pcd_get_frame_number(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_get_frame_number(dwc_otg_pcd_t *pcd);
 
 /**
  * Start isochronous transfers on the endpoint referenced by ep_handle.
@@ -264,8 +264,8 @@ extern int dwc_otg_pcd_get_frame_number(dwc_otg_pcd_t * pcd);
  * Returns -DW_E_SHUTDOWN for any other error.
  * Returns 0 on success
  */
-extern int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
-				    uint8_t * buf0, uint8_t * buf1,
+extern int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t *pcd, void *ep_handle,
+				    uint8_t *buf0, uint8_t *buf1,
 				    dwc_dma_t dma0, dwc_dma_t dma1,
 				    int sync_frame, int dp_frame,
 				    int data_per_frame, int start_frame,
@@ -281,7 +281,7 @@ extern int dwc_otg_pcd_iso_ep_start(dwc_otg_pcd_t * pcd, void *ep_handle,
  * Returns -DWC_E_INVALID if incorrect arguments are passed to the function
  * Returns 0 on success
  */
-int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t * pcd, void *ep_handle,
+int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t *pcd, void *ep_handle,
 			    void *req_handle);
 
 /** Get ISOC packet status.
@@ -295,7 +295,7 @@ int dwc_otg_pcd_iso_ep_stop(dwc_otg_pcd_t * pcd, void *ep_handle,
  * @param offset Out parameter for returning offset
  *
  */
-extern void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t * pcd,
+extern void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t *pcd,
 					      void *ep_handle,
 					      void *iso_req_handle, int packet,
 					      int *status, int *actual,
@@ -307,7 +307,7 @@ extern void dwc_otg_pcd_get_iso_packet_params(dwc_otg_pcd_t * pcd,
  * @param ep_handle The handle of the endpoint
  * @param iso_req_handle
  */
-extern int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t * pcd,
+extern int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t *pcd,
 					    void *ep_handle,
 					    void *iso_req_handle);
 
@@ -315,56 +315,56 @@ extern int dwc_otg_pcd_get_iso_packet_count(dwc_otg_pcd_t * pcd,
  * a session is already in progress, but the device is suspended,
  * remote wakeup signaling is started.
  */
-extern int dwc_otg_pcd_wakeup(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_wakeup(dwc_otg_pcd_t *pcd);
 
 /** This function returns 1 if LPM support is enabled, and 0 otherwise. */
-extern int dwc_otg_pcd_is_lpm_enabled(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_is_lpm_enabled(dwc_otg_pcd_t *pcd);
 
 /** This function returns 1 if LPM Errata support is enabled, and 0 otherwise. */
-extern int dwc_otg_pcd_is_besl_enabled(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_is_besl_enabled(dwc_otg_pcd_t *pcd);
 
 /** This function returns baseline_besl module parametr. */
-extern int dwc_otg_pcd_get_param_baseline_besl(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_get_param_baseline_besl(dwc_otg_pcd_t *pcd);
 
 /** This function returns deep_besl module parametr. */
-extern int dwc_otg_pcd_get_param_deep_besl(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_get_param_deep_besl(dwc_otg_pcd_t *pcd);
 
 /** This function returns 1 if remote wakeup is allowed and 0, otherwise. */
-extern int dwc_otg_pcd_get_rmwkup_enable(dwc_otg_pcd_t * pcd);
+extern int dwc_otg_pcd_get_rmwkup_enable(dwc_otg_pcd_t *pcd);
 
 /** Initiate SRP */
-extern void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t * pcd);
+extern void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t *pcd);
 
 /** Starts remote wakeup signaling. */
-extern void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t * pcd, int set);
+extern void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t *pcd, int set);
 
 /** Starts micorsecond soft disconnect. */
-extern void dwc_otg_pcd_disconnect_us(dwc_otg_pcd_t * pcd, int no_of_usecs);
+extern void dwc_otg_pcd_disconnect_us(dwc_otg_pcd_t *pcd, int no_of_usecs);
 /** This function returns whether device is dualspeed.*/
-extern uint32_t dwc_otg_pcd_is_dualspeed(dwc_otg_pcd_t * pcd);
+extern uint32_t dwc_otg_pcd_is_dualspeed(dwc_otg_pcd_t *pcd);
 
 /** This function returns whether device is otg. */
-extern uint32_t dwc_otg_pcd_is_otg(dwc_otg_pcd_t * pcd);
+extern uint32_t dwc_otg_pcd_is_otg(dwc_otg_pcd_t *pcd);
 
 /** These functions allow to get hnp parameters */
-extern uint32_t get_b_hnp_enable(dwc_otg_pcd_t * pcd);
-extern uint32_t get_a_hnp_support(dwc_otg_pcd_t * pcd);
-extern uint32_t get_a_alt_hnp_support(dwc_otg_pcd_t * pcd);
+extern uint32_t get_b_hnp_enable(dwc_otg_pcd_t *pcd);
+extern uint32_t get_a_hnp_support(dwc_otg_pcd_t *pcd);
+extern uint32_t get_a_alt_hnp_support(dwc_otg_pcd_t *pcd);
 
 /** CFI specific Interface functions */
 /** Allocate a cfi buffer */
-extern uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t * pcd, void *pep,
-				     dwc_dma_t * addr, size_t buflen,
+extern uint8_t *cfiw_ep_alloc_buffer(dwc_otg_pcd_t *pcd, void *pep,
+				     dwc_dma_t *addr, size_t buflen,
 				     int flags);
 
 /** Device soft-connect and soft-disconnect*/
-extern void dwc_otg_pcd_pullup_enable(dwc_otg_pcd_t * pcd);
-extern void dwc_otg_pcd_pullup_disable(dwc_otg_pcd_t * pcd);
+extern void dwc_otg_pcd_pullup_enable(dwc_otg_pcd_t *pcd);
+extern void dwc_otg_pcd_pullup_disable(dwc_otg_pcd_t *pcd);
 
 /******************************************************************************/
 
 /** @} */
 
-#endif				/* __DWC_PCD_IF_H__ */
+#endif /* __DWC_PCD_IF_H__ */
 
-#endif				/* DWC_HOST_ONLY */
+#endif /* DWC_HOST_ONLY */
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_pcd_intr.c b/drivers/usb/dwc_otg_310/dwc_otg_pcd_intr.c
index 2522df6d2582..fb2f8884acdb 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_pcd_intr.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_pcd_intr.c
@@ -40,16 +40,16 @@
 #endif
 
 #ifdef DWC_UTE_PER_IO
-extern void complete_xiso_ep(dwc_otg_pcd_ep_t * ep);
+extern void complete_xiso_ep(dwc_otg_pcd_ep_t *ep);
 #endif
-//#define PRINT_CFI_DMA_DESCS
+/* #define PRINT_CFI_DMA_DESCS */
 
 #define DEBUG_EP0
 
 /**
  * This function updates OTG.
  */
-static void dwc_otg_pcd_update_otg(dwc_otg_pcd_t * pcd, const unsigned reset)
+static void dwc_otg_pcd_update_otg(dwc_otg_pcd_t *pcd, const unsigned reset)
 {
 
 	if (reset) {
@@ -77,7 +77,7 @@ static void dwc_otg_pcd_update_otg(dwc_otg_pcd_t * pcd, const unsigned reset)
 /**
  * This function prints the ep0 state for debug purposes.
  */
-static inline void print_ep0_state(dwc_otg_pcd_t * pcd)
+static inline void print_ep0_state(dwc_otg_pcd_t *pcd)
 {
 #ifdef DEBUG
 	char str[40];
@@ -113,42 +113,39 @@ static inline void print_ep0_state(dwc_otg_pcd_t * pcd)
 }
 
 /**
- * This function calculate the size of the payload in the memory 
- * for out endpoints and prints size for debug purposes(used in 
+ * This function calculate the size of the payload in the memory
+ * for out endpoints and prints size for debug purposes(used in
  * 2.93a DevOutNak feature).
  */
-static inline void print_memory_payload(dwc_otg_pcd_t * pcd,  dwc_ep_t * ep)
+static inline void print_memory_payload(dwc_otg_pcd_t *pcd, dwc_ep_t *ep)
 {
 #ifdef DEBUG
 	deptsiz_data_t deptsiz_init = {.d32 = 0 };
 	deptsiz_data_t deptsiz_updt = {.d32 = 0 };
 	int pack_num;
 	unsigned payload;
-	
+
 	deptsiz_init.d32 = pcd->core_if->start_doeptsiz_val[ep->num];
 	deptsiz_updt.d32 =
-		DWC_READ_REG32(&pcd->core_if->dev_if->
-						out_ep_regs[ep->num]->doeptsiz);
+	    DWC_READ_REG32(&pcd->core_if->dev_if->
+			   out_ep_regs[ep->num]->doeptsiz);
 	/* Payload will be */
 	payload = deptsiz_init.b.xfersize - deptsiz_updt.b.xfersize;
 	/* Packet count is decremented every time a packet
 	 * is written to the RxFIFO not in to the external memory
 	 * So, if payload == 0, then it means no packet was sent to ext memory*/
-	pack_num = (!payload) ? 0 : (deptsiz_init.b.pktcnt - deptsiz_updt.b.pktcnt);
-	DWC_DEBUGPL(DBG_PCDV,
-		"Payload for EP%d-%s\n",
-		ep->num, (ep->is_in ? "IN" : "OUT"));
-	DWC_DEBUGPL(DBG_PCDV,
-		"Number of transfered bytes = 0x%08x\n", payload);
-	DWC_DEBUGPL(DBG_PCDV,
-		"Number of transfered packets = %d\n", pack_num);	
-#endif	
+	pack_num =
+	    (!payload) ? 0 : (deptsiz_init.b.pktcnt - deptsiz_updt.b.pktcnt);
+	DWC_DEBUGPL(DBG_PCDV, "Payload for EP%d-%s\n", ep->num,
+		    (ep->is_in ? "IN" : "OUT"));
+	DWC_DEBUGPL(DBG_PCDV, "Number of transfered bytes = 0x%08x\n", payload);
+	DWC_DEBUGPL(DBG_PCDV, "Number of transfered packets = %d\n", pack_num);
+#endif
 }
 
-
 #ifdef DWC_UTE_CFI
 static inline void print_desc(struct dwc_otg_dma_desc *ddesc,
-			      const uint8_t * epname, int descnum)
+			      const uint8_t *epname, int descnum)
 {
 	CFI_INFO
 	    ("%s DMA_DESC(%d) buf=0x%08x bytes=0x%04x; sp=0x%x; l=0x%x; sts=0x%02x; bs=0x%02x\n",
@@ -161,7 +158,7 @@ static inline void print_desc(struct dwc_otg_dma_desc *ddesc,
 /**
  * This function returns pointer to in ep struct with number ep_num
  */
-static inline dwc_otg_pcd_ep_t *get_in_ep(dwc_otg_pcd_t * pcd, uint32_t ep_num)
+static inline dwc_otg_pcd_ep_t *get_in_ep(dwc_otg_pcd_t *pcd, uint32_t ep_num)
 {
 	int i;
 	int num_in_eps = GET_CORE_IF(pcd)->dev_if->num_in_eps;
@@ -179,7 +176,7 @@ static inline dwc_otg_pcd_ep_t *get_in_ep(dwc_otg_pcd_t * pcd, uint32_t ep_num)
 /**
  * This function returns pointer to out ep struct with number ep_num
  */
-static inline dwc_otg_pcd_ep_t *get_out_ep(dwc_otg_pcd_t * pcd, uint32_t ep_num)
+static inline dwc_otg_pcd_ep_t *get_out_ep(dwc_otg_pcd_t *pcd, uint32_t ep_num)
 {
 	int i;
 	int num_out_eps = GET_CORE_IF(pcd)->dev_if->num_out_eps;
@@ -198,7 +195,7 @@ static inline dwc_otg_pcd_ep_t *get_out_ep(dwc_otg_pcd_t * pcd, uint32_t ep_num)
  * This functions gets a pointer to an EP from the wIndex address
  * value of the control request.
  */
-dwc_otg_pcd_ep_t *get_ep_by_addr(dwc_otg_pcd_t * pcd, u16 wIndex)
+dwc_otg_pcd_ep_t *get_ep_by_addr(dwc_otg_pcd_t *pcd, u16 wIndex)
 {
 	dwc_otg_pcd_ep_t *ep;
 	uint32_t ep_num = UE_GET_ADDR(wIndex);
@@ -218,7 +215,7 @@ dwc_otg_pcd_ep_t *get_ep_by_addr(dwc_otg_pcd_t * pcd, u16 wIndex)
  * This function checks the EP request queue, if the queue is not
  * empty the next request is started.
  */
-void start_next_request(dwc_otg_pcd_ep_t * ep)
+void start_next_request(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_pcd_request_t *req = 0;
 	uint32_t max_transfer =
@@ -296,7 +293,7 @@ void start_next_request(dwc_otg_pcd_ep_t * ep)
  * This function handles the SOF Interrupts. At this time the SOF
  * Interrupt is disabled.
  */
-int32_t dwc_otg_pcd_handle_sof_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_sof_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 
@@ -329,7 +326,7 @@ int32_t dwc_otg_pcd_handle_sof_intr(dwc_otg_pcd_t * pcd)
  *	 -# If OUT Data Packet call dwc_otg_read_packet to copy the data
  *		to the destination buffer
  */
-int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -341,7 +338,7 @@ int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t * pcd)
 	static char *dpid_str[] = { "D0", "D2", "D1", "MDATA" };
 #endif
 
-	//DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _pcd);
+	/* DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _pcd); */
 	/* Disable the Rx Status Queue Level interrupt */
 	gintmask.b.rxstsqlvl = 1;
 	DWC_MODIFY_REG32(&global_regs->gintmsk, gintmask.d32, 0);
@@ -406,7 +403,7 @@ int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t * pcd)
 	gintsts.b.rxstsqlvl = 1;
 	DWC_WRITE_REG32(&global_regs->gintsts, gintsts.d32);
 
-	//DWC_DEBUGPL(DBG_PCDV, "EXIT: %s\n", __func__);
+	/* DWC_DEBUGPL(DBG_PCDV, "EXIT: %s\n", __func__); */
 	return 1;
 }
 
@@ -422,7 +419,7 @@ int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t * pcd)
  * @param core_if Programming view of DWC_otg controller.
  *
  */
-static inline int get_ep_of_last_in_token(dwc_otg_core_if_t * core_if)
+static inline int get_ep_of_last_in_token(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_device_global_regs_t *dev_global_regs =
 	    core_if->dev_if->dev_global_regs;
@@ -436,7 +433,7 @@ static inline int get_ep_of_last_in_token(dwc_otg_core_if_t * core_if)
 	volatile uint32_t *addr = &dev_global_regs->dtknqr1;
 	int epnum = 0;
 
-	//DWC_DEBUGPL(DBG_PCD,"dev_token_q_depth=%d\n",TOKEN_Q_DEPTH);
+	/* DWC_DEBUGPL(DBG_PCD,"dev_token_q_depth=%d\n",TOKEN_Q_DEPTH); */
 
 	/* Read the DTKNQ Registers */
 	for (i = 0; i < DTKNQ_REG_CNT; i++) {
@@ -457,7 +454,7 @@ static inline int get_ep_of_last_in_token(dwc_otg_core_if_t * core_if)
 	in_tkn_epnums[0] = dtknqr1.b.epnums0_5;
 	ndx = dtknqr1.b.intknwptr - 1;
 
-	//DWC_DEBUGPL(DBG_PCDV,"ndx=%d\n",ndx);
+	/* DWC_DEBUGPL(DBG_PCDV,"ndx=%d\n",ndx); */
 	if (ndx == -1) {
 		/** @todo Find a simpler way to calculate the max
 		 * queue position.*/
@@ -486,7 +483,7 @@ static inline int get_ep_of_last_in_token(dwc_otg_core_if_t * core_if)
 			epnum = (in_tkn_epnums[3] >> (ndx * 4)) & 0xF;
 		}
 	}
-	//DWC_DEBUGPL(DBG_PCD,"epnum=%d\n",epnum);
+	/* DWC_DEBUGPL(DBG_PCD,"epnum=%d\n",epnum); */
 	return epnum;
 }
 
@@ -495,7 +492,7 @@ static inline int get_ep_of_last_in_token(dwc_otg_core_if_t * core_if)
  * The active request is checked for the next packet to be loaded into
  * the non-periodic Tx FIFO.
  */
-int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -559,7 +556,7 @@ int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(dwc_otg_pcd_t * pcd)
  * The active request is checked for the next packet to be loaded into
  * apropriate Tx FIFO.
  */
-static int32_t write_empty_tx_fifo(dwc_otg_pcd_t * pcd, uint32_t epnum)
+static int32_t write_empty_tx_fifo(dwc_otg_pcd_t *pcd, uint32_t epnum)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
@@ -617,7 +614,7 @@ static int32_t write_empty_tx_fifo(dwc_otg_pcd_t * pcd, uint32_t epnum)
  * any active requests and informs the Gadget driver of the
  * disconnect.
  */
-void dwc_otg_pcd_stop(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_stop(dwc_otg_pcd_t *pcd)
 {
 	int i, num_in_eps, num_out_eps;
 	dwc_otg_pcd_ep_t *ep;
@@ -676,7 +673,7 @@ void dwc_otg_pcd_stop(dwc_otg_pcd_t * pcd)
 /**
  * This interrupt indicates that ...
  */
-int32_t dwc_otg_pcd_handle_i2c_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_i2c_intr(dwc_otg_pcd_t *pcd)
 {
 	gintmsk_data_t intr_mask = {.d32 = 0 };
 	gintsts_data_t gintsts;
@@ -697,7 +694,7 @@ int32_t dwc_otg_pcd_handle_i2c_intr(dwc_otg_pcd_t * pcd)
 /**
  * This interrupt indicates that ...
  */
-int32_t dwc_otg_pcd_handle_early_suspend_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_early_suspend_intr(dwc_otg_pcd_t *pcd)
 {
 	gintsts_data_t gintsts;
 #if defined(VERBOSE)
@@ -729,8 +726,8 @@ int32_t dwc_otg_pcd_handle_early_suspend_intr(dwc_otg_pcd_t * pcd)
  * @param core_if Programming view of DWC_otg controller.
  * @param pcd	  Programming view of the PCD.
  */
-static inline void ep0_out_start(dwc_otg_core_if_t * core_if,
-				 dwc_otg_pcd_t * pcd)
+static inline void ep0_out_start(dwc_otg_core_if_t *core_if,
+				 dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 	deptsiz0_data_t doeptsize0 = {.d32 = 0 };
@@ -799,7 +796,8 @@ static inline void ep0_out_start(dwc_otg_core_if_t * core_if,
 		doepctl.b.cnak = 1;
 		DWC_WRITE_REG32(&dev_if->out_ep_regs[0]->doepctl, doepctl.d32);
 	} else {
-		DWC_MODIFY_REG32(&dev_if->out_ep_regs[0]->doepctl, 0, doepctl.d32);
+		DWC_MODIFY_REG32(&dev_if->out_ep_regs[0]->doepctl, 0,
+				 doepctl.d32);
 	}
 
 #ifdef VERBOSE
@@ -833,7 +831,7 @@ static inline void ep0_out_start(dwc_otg_core_if_t * core_if,
  * At this point, all the required initialization, except for enabling
  * the control 0 OUT endpoint is done, for receiving SETUP packets.
  */
-int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
@@ -864,7 +862,7 @@ int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
 
 	core_if->lx_state = DWC_OTG_L0;
 	core_if->otg_sts = 0;
-	
+
 	DWC_PRINTF("USB RESET\n");
 #ifdef DWC_EN_ISOC
 	for (i = 1; i < 16; ++i) {
@@ -900,7 +898,7 @@ int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
 	if (!core_if->core_params->en_multiple_tx_fifo && core_if->dma_enable) {
 		core_if->start_predict = 0;
 		for (i = 0; i <= core_if->dev_if->num_in_eps; ++i) {
-			core_if->nextep_seq[i] = 0xff;	// 0xff - EP not active
+			core_if->nextep_seq[i] = 0xff; /*0xff - EP not active */
 		}
 		core_if->nextep_seq[0] = 0;
 		core_if->first_in_nextep_seq = 0;
@@ -939,10 +937,10 @@ int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
 		}
 		if (core_if->dma_desc_enable)
 			doepmsk.b.bna = 1;
-/*		
+/*
 		doepmsk.b.babble = 1;
 		doepmsk.b.nyet = 1;
-		
+
 		if (core_if->dma_enable) {
 			doepmsk.b.nak = 1;
 		}
@@ -962,7 +960,7 @@ int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
 			diepmsk.b.bna = 1;
 		}
 */
-/*		
+/*
 		if (core_if->dma_enable) {
 			diepmsk.b.nak = 1;
 		}
@@ -1027,7 +1025,7 @@ int32_t dwc_otg_pcd_handle_usb_reset_intr(dwc_otg_pcd_t * pcd)
  *
  * @param core_if Programming view of DWC_otg controller.
  */
-static int get_device_speed(dwc_otg_core_if_t * core_if)
+static int get_device_speed(dwc_otg_core_if_t *core_if)
 {
 	dsts_data_t dsts;
 	int speed = 0;
@@ -1055,7 +1053,7 @@ static int get_device_speed(dwc_otg_core_if_t * core_if)
  * data structure.
  * Set up EP0 to receive SETUP packets by calling dwc_ep0_activate.
  */
-int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_pcd_ep_t *ep0 = &pcd->ep0;
 	gintsts_data_t gintsts;
@@ -1068,7 +1066,7 @@ int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t * pcd)
 	DWC_DEBUGPL(DBG_PCD, "SPEED ENUM\n");
 
 	if (GET_CORE_IF(pcd)->snpsid >= OTG_CORE_REV_2_60a) {
-		utmi16b = 5;	//vahrama old value was 6;
+		utmi16b = 5;	/* vahrama old value was 6; */
 		utmi8b = 9;
 	} else {
 		utmi16b = 4;
@@ -1078,7 +1076,6 @@ int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t * pcd)
 	if (GET_CORE_IF(pcd)->snpsid >= OTG_CORE_REV_3_00a) {
 		ep0_out_start(GET_CORE_IF(pcd), pcd);
 	}
-
 #ifdef DEBUG_EP0
 	print_ep0_state(pcd);
 #endif
@@ -1154,7 +1151,7 @@ int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t * pcd)
  * Rx FIFO full or Rx Status Queue Full.  If this interrupt occurs
  * read all the data from the Rx FIFO.
  */
-int32_t dwc_otg_pcd_handle_isoc_out_packet_dropped_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_isoc_out_packet_dropped_intr(dwc_otg_pcd_t *pcd)
 {
 	gintmsk_data_t intr_mask = {.d32 = 0 };
 	gintsts_data_t gintsts;
@@ -1180,7 +1177,7 @@ int32_t dwc_otg_pcd_handle_isoc_out_packet_dropped_intr(dwc_otg_pcd_t * pcd)
  * for periodic transactions.  If there is a periodic transaction for
  * the next frame, load the packets into the EP periodic Tx FIFO.
  */
-int32_t dwc_otg_pcd_handle_end_periodic_frame_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_end_periodic_frame_intr(dwc_otg_pcd_t *pcd)
 {
 	gintmsk_data_t intr_mask = {.d32 = 0 };
 	gintsts_data_t gintsts;
@@ -1208,7 +1205,7 @@ int32_t dwc_otg_pcd_handle_end_periodic_frame_intr(dwc_otg_pcd_t * pcd)
  * is flushed, so it can be reloaded in the order seen in the IN Token
  * Queue.
  */
-int32_t dwc_otg_pcd_handle_ep_mismatch_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_ep_mismatch_intr(dwc_otg_pcd_t *pcd)
 {
 	gintsts_data_t gintsts;
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
@@ -1219,23 +1216,30 @@ int32_t dwc_otg_pcd_handle_ep_mismatch_intr(dwc_otg_pcd_t * pcd)
 		core_if->start_predict = 1;
 
 		DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, core_if);
-	
-		gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
+
+		gintsts.d32 =
+		    DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 		if (!gintsts.b.ginnakeff) {
 			/* Disable EP Mismatch interrupt */
 			intr_mask.d32 = 0;
 			intr_mask.b.epmismatch = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk,
+					 intr_mask.d32, 0);
 			/* Enable the Global IN NAK Effective Interrupt */
 			intr_mask.d32 = 0;
 			intr_mask.b.ginnakeff = 1;
-			DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk, 0, intr_mask.d32);
+			DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk, 0,
+					 intr_mask.d32);
 			/* Set the global non-periodic IN NAK handshake */
-			dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
+			dctl.d32 =
+			    DWC_READ_REG32(&core_if->dev_if->
+					   dev_global_regs->dctl);
 			dctl.b.sgnpinnak = 1;
-			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
+			DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
+					dctl.d32);
 		} else {
-			DWC_PRINTF("gintsts.b.ginnakeff = 1! dctl.b.sgnpinnak not set\n");
+			DWC_PRINTF
+			    ("gintsts.b.ginnakeff = 1! dctl.b.sgnpinnak not set\n");
 		}
 		/* Disabling of all EP's will be done in dwc_otg_pcd_handle_in_nak_effective()
 		 * handler after Global IN NAK Effective interrupt will be asserted */
@@ -1253,10 +1257,10 @@ int32_t dwc_otg_pcd_handle_ep_mismatch_intr(dwc_otg_pcd_t * pcd)
  * core has stopped fetching data for IN endpoints due to the unavailability of
  * TxFIFO space or Request Queue space. This interrupt is used by the
  * application for an endpoint mismatch algorithm.
- * 
- * @param pcd The PCD 
+ *
+ * @param pcd The PCD
  */
-int32_t dwc_otg_pcd_handle_ep_fetsusp_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_ep_fetsusp_intr(dwc_otg_pcd_t *pcd)
 {
 	gintsts_data_t gintsts;
 	gintmsk_data_t gintmsk_data;
@@ -1267,8 +1271,9 @@ int32_t dwc_otg_pcd_handle_ep_fetsusp_intr(dwc_otg_pcd_t * pcd)
 	/* Clear the global non-periodic IN NAK handshake */
 	dctl.d32 = 0;
 	dctl.b.cgnpinnak = 1;
-	DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32, dctl.d32); 
-	
+	DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32,
+			 dctl.d32);
+
 	/* Mask GINTSTS.FETSUSP interrupt */
 	gintmsk_data.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
 	gintmsk_data.b.fetsusp = 0;
@@ -1285,7 +1290,7 @@ int32_t dwc_otg_pcd_handle_ep_fetsusp_intr(dwc_otg_pcd_t * pcd)
 /**
  * This funcion stalls EP0.
  */
-static inline void ep0_do_stall(dwc_otg_pcd_t * pcd, const int err_val)
+static inline void ep0_do_stall(dwc_otg_pcd_t *pcd, const int err_val)
 {
 	dwc_otg_pcd_ep_t *ep0 = &pcd->ep0;
 	usb_device_request_t *ctrl = &pcd->setup_pkt->req;
@@ -1304,14 +1309,15 @@ static inline void ep0_do_stall(dwc_otg_pcd_t * pcd, const int err_val)
 /**
  * This functions delegates the setup command to the gadget driver.
  */
-static inline void do_gadget_setup(dwc_otg_pcd_t * pcd,
-				   usb_device_request_t * ctrl)
+static inline void do_gadget_setup(dwc_otg_pcd_t *pcd,
+				   usb_device_request_t *ctrl)
 {
 	int ret = 0;
 	DWC_SPINUNLOCK(pcd->lock);
 	ret = pcd->fops->setup(pcd, (uint8_t *) ctrl);
-	if(spin_is_locked((spinlock_t *)pcd->lock))
-		DWC_WARN("%s warning: pcd->lock locked without unlock\n", __func__);
+	if (spin_is_locked((spinlock_t *) pcd->lock))
+		DWC_WARN("%s warning: pcd->lock locked without unlock\n",
+			 __func__);
 	DWC_SPINLOCK(pcd->lock);
 	if (ret < 0) {
 		ep0_do_stall(pcd, ret);
@@ -1339,7 +1345,7 @@ static inline void do_gadget_setup(dwc_otg_pcd_t * pcd,
  * This functions delegates the CFI setup commands to the gadget driver.
  * This function will return a negative value to indicate a failure.
  */
-static inline int cfi_gadget_setup(dwc_otg_pcd_t * pcd,
+static inline int cfi_gadget_setup(dwc_otg_pcd_t *pcd,
 				   struct cfi_usb_ctrlrequest *ctrl_req)
 {
 	int ret = 0;
@@ -1362,7 +1368,7 @@ static inline int cfi_gadget_setup(dwc_otg_pcd_t * pcd,
  * This function starts the Zero-Length Packet for the IN status phase
  * of a 2 stage control transfer.
  */
-static inline void do_setup_in_status_phase(dwc_otg_pcd_t * pcd)
+static inline void do_setup_in_status_phase(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_pcd_ep_t *ep0 = &pcd->ep0;
 	if (pcd->ep0state == EP0_STALL) {
@@ -1388,14 +1394,14 @@ static inline void do_setup_in_status_phase(dwc_otg_pcd_t * pcd)
 	dwc_otg_ep0_start_transfer(GET_CORE_IF(pcd), &ep0->dwc_ep);
 
 	/* Prepare for more SETUP Packets */
-	//ep0_out_start(GET_CORE_IF(pcd), pcd);
+	/* ep0_out_start(GET_CORE_IF(pcd), pcd); */
 }
 
 /**
  * This function starts the Zero-Length Packet for the OUT status phase
  * of a 2 stage control transfer.
  */
-static inline void do_setup_out_status_phase(dwc_otg_pcd_t * pcd)
+static inline void do_setup_out_status_phase(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_pcd_ep_t *ep0 = &pcd->ep0;
 	if (pcd->ep0state == EP0_STALL) {
@@ -1421,7 +1427,7 @@ static inline void do_setup_out_status_phase(dwc_otg_pcd_t * pcd)
  * Clear the EP halt (STALL) and if pending requests start the
  * transfer.
  */
-static inline void pcd_clear_halt(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep)
+static inline void pcd_clear_halt(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *ep)
 {
 	if (ep->dwc_ep.stall_clear_flag) {
 		/* Start Control Status Phase */
@@ -1472,33 +1478,33 @@ void do_test_mode(void *data)
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	int test_mode = pcd->test_mode;
 
-//        DWC_WARN("%s() has not been tested since being rewritten!\n", __func__);
+	/* DWC_WARN("%s() has not been tested since being rewritten!\n", __func__); */
 
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 	switch (test_mode) {
-	case 1:		// TEST_J
+	case 1:		/* TEST_J */
 		dctl.b.tstctl = 1;
 		break;
 
-	case 2:		// TEST_K
+	case 2:		/* TEST_K */
 		dctl.b.tstctl = 2;
 		break;
 
-	case 3:		// TEST_SE0_NAK
+	case 3:		/* TEST_SE0_NAK */
 		dctl.b.tstctl = 3;
 		break;
 
-	case 4:		// TEST_PACKET
+	case 4:		/* TEST_PACKET */
 		dctl.b.tstctl = 4;
 		break;
 
-	case 5:		// TEST_FORCE_ENABLE
+	case 5:		/* TEST_FORCE_ENABLE */
 		dctl.b.tstctl = 5;
 		break;
-	case 7:	
+	case 7:
 		dwc_otg_set_hnpreq(core_if, 1);
 	}
-	DWC_PRINTF("test mode = %d\n",test_mode);
+	DWC_PRINTF("test mode = %d\n", test_mode);
 	core_if->test_mode = test_mode;
 	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
 }
@@ -1506,7 +1512,7 @@ void do_test_mode(void *data)
 /**
  * This function process the GET_STATUS Setup Commands.
  */
-static inline void do_get_status(dwc_otg_pcd_t * pcd)
+static inline void do_get_status(dwc_otg_pcd_t *pcd)
 {
 	usb_device_request_t ctrl = pcd->setup_pkt->req;
 	dwc_otg_pcd_ep_t *ep;
@@ -1584,7 +1590,7 @@ static inline void do_get_status(dwc_otg_pcd_t * pcd)
 /**
  * This function process the SET_FEATURE Setup Commands.
  */
-static inline void do_set_feature(dwc_otg_pcd_t * pcd)
+static inline void do_set_feature(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
@@ -1626,7 +1632,8 @@ static inline void do_set_feature(dwc_otg_pcd_t * pcd)
 			if (otg_cap_param == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE) {
 				gotgctl.b.devhnpen = 1;
 				if (core_if->otg_ver == 1)
-					DWC_MODIFY_REG32(&global_regs->gotgctl, 0, gotgctl.d32);
+					DWC_MODIFY_REG32(&global_regs->gotgctl,
+							 0, gotgctl.d32);
 				else {
 					pcd->b_hnp_enable = 1;
 					dwc_otg_pcd_update_otg(pcd, 0);
@@ -1634,7 +1641,8 @@ static inline void do_set_feature(dwc_otg_pcd_t * pcd)
 					/**@todo Is the gotgctl.devhnpen cleared
 					 * by a USB Reset? */
 					gotgctl.b.hnpreq = 1;
-					DWC_WRITE_REG32(&global_regs->gotgctl, gotgctl.d32);
+					DWC_WRITE_REG32(&global_regs->gotgctl,
+							gotgctl.d32);
 				}
 			} else {
 				ep0_do_stall(pcd, -DWC_E_NOT_SUPPORTED);
@@ -1698,7 +1706,7 @@ static inline void do_set_feature(dwc_otg_pcd_t * pcd)
 /**
  * This function process the CLEAR_FEATURE Setup Commands.
  */
-static inline void do_clear_feature(dwc_otg_pcd_t * pcd)
+static inline void do_clear_feature(dwc_otg_pcd_t *pcd)
 {
 	usb_device_request_t ctrl = pcd->setup_pkt->req;
 	dwc_otg_pcd_ep_t *ep = 0;
@@ -1743,7 +1751,7 @@ static inline void do_clear_feature(dwc_otg_pcd_t * pcd)
 /**
  * This function process the SET_ADDRESS Setup Commands.
  */
-static inline void do_set_address(dwc_otg_pcd_t * pcd)
+static inline void do_set_address(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(pcd)->dev_if;
 	usb_device_request_t ctrl = pcd->setup_pkt->req;
@@ -1752,7 +1760,7 @@ static inline void do_set_address(dwc_otg_pcd_t * pcd)
 		dcfg_data_t dcfg = {.d32 = 0 };
 
 #ifdef DEBUG_EP0
-//                      DWC_DEBUGPL(DBG_PCDV, "SET_ADDRESS:%d\n", ctrl.wValue);
+		/* DWC_DEBUGPL(DBG_PCDV, "SET_ADDRESS:%d\n", ctrl.wValue); */
 #endif
 		dcfg.b.devaddr = UGETW(ctrl.wValue);
 		DWC_MODIFY_REG32(&dev_if->dev_global_regs->dcfg, 0, dcfg.d32);
@@ -1808,9 +1816,9 @@ static inline void do_set_address(dwc_otg_pcd_t * pcd)
  *
  * When the SETUP Phase Done interrupt occurs, the PCD SETUP commands are
  * processed by pcd_setup. Calling the Function Driver's setup function from
- * pcd_setup processes the gadget SETUP commands.
+ *pcd_setup processes the gadget SETUP commands.
  */
-static inline void pcd_setup(dwc_otg_pcd_t * pcd)
+static inline void pcd_setup(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
@@ -1869,8 +1877,8 @@ static inline void pcd_setup(dwc_otg_pcd_t * pcd)
 #ifdef DWC_UTE_CFI
 		DWC_MEMCPY(&cfi_req, &ctrl, sizeof(usb_device_request_t));
 
-		//printk(KERN_ALERT "CFI: req_type=0x%02x; req=0x%02x\n", 
-		ctrl.bRequestType, ctrl.bRequest);
+		/* printk(KERN_ALERT "CFI: req_type=0x%02x; req=0x%02x\n",
+		 * ctrl.bRequestType, ctrl.bRequest); */
 		if (UT_GET_TYPE(cfi_req.bRequestType) == UT_VENDOR) {
 			if (cfi_req.bRequest > 0xB0 && cfi_req.bRequest < 0xBF) {
 				retval = cfi_setup(pcd, &cfi_req);
@@ -1907,8 +1915,7 @@ static inline void pcd_setup(dwc_otg_pcd_t * pcd)
 
 	/** @todo NGS: Handle bad setup packet? */
 
-///////////////////////////////////////////
-//// --- Standard Request handling --- ////
+	/* --- Standard Request handling --- */
 
 	switch (ctrl.bRequest) {
 	case UR_GET_STATUS:
@@ -1929,7 +1936,7 @@ static inline void pcd_setup(dwc_otg_pcd_t * pcd)
 
 	case UR_SET_INTERFACE:
 	case UR_SET_CONFIG:
-//              _pcd->request_config = 1;       /* Configuration changed */
+		/* _pcd->request_config = 1; */      /* Configuration changed */
 		do_gadget_setup(pcd, &ctrl);
 		break;
 
@@ -1947,7 +1954,7 @@ static inline void pcd_setup(dwc_otg_pcd_t * pcd)
 /**
  * This function completes the ep0 control transfer.
  */
-static int32_t ep0_complete_request(dwc_otg_pcd_ep_t * ep)
+static int32_t ep0_complete_request(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(ep->pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
@@ -1987,10 +1994,9 @@ static int32_t ep0_complete_request(dwc_otg_pcd_ep_t * ep)
 				    && ctrlreq->bRequest < 0xBF) {
 
 					/* Return if the PCD failed to handle the request */
-					if ((retval =
-					     pcd->cfi->ops.
-					     ctrl_write_complete(pcd->cfi,
-								 pcd)) < 0) {
+					retval = pcd->cfi->ops.
+						 ctrl_write_complete(pcd->cfi, pcd);
+					if (retval < 0) {
 						CFI_INFO
 						    ("ERROR setting a new value in the PCD(%d)\n",
 						     retval);
@@ -2001,7 +2007,7 @@ static int32_t ep0_complete_request(dwc_otg_pcd_ep_t * ep)
 
 					/* If the gadget needs to be notified on the request */
 					if (pcd->cfi->need_gadget_att == 1) {
-						//retval = do_gadget_setup(pcd, &pcd->cfi->ctrl_req);
+						/* retval = do_gadget_setup(pcd, &pcd->cfi->ctrl_req); */
 						retval =
 						    cfi_gadget_setup(pcd,
 								     &pcd->cfi->
@@ -2089,8 +2095,8 @@ static int32_t ep0_complete_request(dwc_otg_pcd_ep_t * ep)
 #endif
 			req->sent_zlp = 0;
 		}
-		/* For older cores do setup in status phase in Slave/BDMA modes, 
-		 * starting from 3.00 do that only in slave, and for DMA modes 
+		/* For older cores do setup in status phase in Slave/BDMA modes,
+		 * starting from 3.00 do that only in slave, and for DMA modes
 		 * just re-enable ep 0 OUT here*/
 		if (core_if->dma_enable == 0
 		    || (core_if->dma_desc_enable == 0
@@ -2121,7 +2127,7 @@ static int32_t ep0_complete_request(dwc_otg_pcd_ep_t * ep)
  *
  * @return The total bytes left to transfered, or a negative value as failure
  */
-static inline int cfi_calc_desc_residue(dwc_otg_pcd_ep_t * ep)
+static inline int cfi_calc_desc_residue(dwc_otg_pcd_ep_t *ep)
 {
 	int32_t ret = 0;
 	int i;
@@ -2158,7 +2164,7 @@ static inline int cfi_calc_desc_residue(dwc_otg_pcd_ep_t * ep)
  * This function completes the request for the EP. If there are
  * additional requests for the EP in the queue they will be started.
  */
-static void complete_ep(dwc_otg_pcd_ep_t * ep)
+static void complete_ep(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(ep->pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
@@ -2207,8 +2213,8 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 					DWC_DEBUGPL(DBG_PCDV,
 						    "%d-%s len=%d  xfersize=%d pktcnt=%d\n",
 						    ep->dwc_ep.num,
-						    (ep->dwc_ep.
-						     is_in ? "IN" : "OUT"),
+						    (ep->dwc_ep.is_in ? "IN" :
+						     "OUT"),
 						    ep->dwc_ep.xfer_len,
 						    deptsiz.b.xfersize,
 						    deptsiz.b.pktcnt);
@@ -2218,7 +2224,7 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 						dwc_otg_ep_start_transfer
 						    (core_if, &ep->dwc_ep);
 					} else if (ep->dwc_ep.sent_zlp) {
-						/*     
+						/*
 						 * This fragment of code should initiate 0
 						 * length transfer in case if it is queued
 						 * a transfer with size divisible to EPs max
@@ -2243,7 +2249,8 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 					if (ep->dwc_ep.type ==
 					    DWC_OTG_EP_TYPE_ISOC) {
 						req->actual = 0;
-						dwc_otg_request_done(ep, req, 0);
+						dwc_otg_request_done(ep, req,
+								     0);
 
 						ep->dwc_ep.start_xfer_buff = 0;
 						ep->dwc_ep.xfer_buff = 0;
@@ -2253,11 +2260,13 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 						start_next_request(ep);
 					} else
 						DWC_WARN
-						("Incomplete transfer (%d - %s [siz=%d pkt=%d])\n",
-						ep->dwc_ep.num,
-						(ep->dwc_ep.is_in ? "IN" : "OUT"),
-						deptsiz.b.xfersize,
-						deptsiz.b.pktcnt);
+						    ("Incomplete transfer (%d - %s [siz=%d pkt=%d])\n",
+						     ep->dwc_ep.num,
+						     (ep->
+						      dwc_ep.is_in ? "IN" :
+						      "OUT"),
+						     deptsiz.b.xfersize,
+						     deptsiz.b.pktcnt);
 				}
 			} else {
 				dma_desc = ep->dwc_ep.desc_addr;
@@ -2304,14 +2313,14 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 					    deptsiz.b.xfersize,
 					    deptsiz.b.pktcnt);
 
-				/*      Check if the whole transfer was completed, 
+				/*      Check if the whole transfer was completed,
 				 *      if no, setup transfer for next portion of data
 				 */
 				if (ep->dwc_ep.xfer_len < ep->dwc_ep.total_len) {
 					dwc_otg_ep_start_transfer(core_if,
 								  &ep->dwc_ep);
 				} else if (ep->dwc_ep.sent_zlp) {
-					/*     
+					/*
 					 * This fragment of code should initiate 0
 					 * length trasfer in case if it is queued
 					 * a trasfer with size divisible to EPs max
@@ -2372,8 +2381,8 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 #ifdef DWC_UTE_CFI
 				}
 #endif
-				/* Checking for interrupt Out transfers with not 
-				 * dword aligned mps sizes 
+				/* Checking for interrupt Out transfers with not
+				 * dword aligned mps sizes
 				 */
 				if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_INTR &&
 				    (ep->dwc_ep.maxpacket % 4)) {
@@ -2386,7 +2395,7 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 						MAX_DMA_DESC_CNT))
 						ep->dwc_ep.xfer_len -=
 						    (ep->dwc_ep.desc_cnt -
-						     1) * ep->dwc_ep.maxpacket +
+						     1)*ep->dwc_ep.maxpacket +
 						    ep->dwc_ep.xfer_len %
 						    ep->dwc_ep.maxpacket;
 					else
@@ -2419,14 +2428,14 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 				ep->dwc_ep.dma_addr += byte_count;
 				ep->dwc_ep.xfer_count += byte_count;
 
-				/*      Check if the whole transfer was completed, 
+				/*      Check if the whole transfer was completed,
 				 *      if no, setup transfer for next portion of data
 				 */
 				if (ep->dwc_ep.xfer_len < ep->dwc_ep.total_len) {
 					dwc_otg_ep_start_transfer(core_if,
 								  &ep->dwc_ep);
 				} else if (ep->dwc_ep.sent_zlp) {
-					/*     
+					/*
 					 * This fragment of code should initiate 0
 					 * length trasfer in case if it is queued
 					 * a trasfer with size divisible to EPs max
@@ -2449,13 +2458,13 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 				}
 			}
 		} else {
-			/*      Check if the whole transfer was completed, 
+			/*      Check if the whole transfer was completed,
 			 *      if no, setup transfer for next portion of data
 			 */
 			if (ep->dwc_ep.xfer_len < ep->dwc_ep.total_len) {
 				dwc_otg_ep_start_transfer(core_if, &ep->dwc_ep);
 			} else if (ep->dwc_ep.sent_zlp) {
-				/*     
+				/*
 				 * This fragment of code should initiate 0
 				 * length transfer in case if it is queued
 				 * a transfer with size divisible to EPs max
@@ -2499,7 +2508,8 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
 #endif
 		if (req->dw_align_buf) {
 			if (!ep->dwc_ep.is_in) {
-				dwc_memcpy(req->buf, req->dw_align_buf, req->length); 
+				dwc_memcpy(req->buf, req->dw_align_buf,
+					   req->length);
 			}
 			DWC_DMA_FREE(req->length, req->dw_align_buf,
 				     req->dw_align_buf_dma);
@@ -2522,11 +2532,12 @@ static void complete_ep(dwc_otg_pcd_ep_t * ep)
  * This function BNA interrupt for Isochronous EPs
  *
  */
-static void dwc_otg_pcd_handle_iso_bna(dwc_otg_pcd_ep_t * ep)
+static void dwc_otg_pcd_handle_iso_bna(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_ep_t *dwc_ep = &ep->dwc_ep;
 	volatile uint32_t *addr;
-	depctl_data_t depctl = {.d32 = 0 };
+	depctl_data_t depctl = {
+	.d32 = 0};
 	dwc_otg_pcd_t *pcd = ep->pcd;
 	dwc_otg_dev_dma_desc_t *dma_desc;
 	int i;
@@ -2535,14 +2546,16 @@ static void dwc_otg_pcd_handle_iso_bna(dwc_otg_pcd_ep_t * ep)
 	    dwc_ep->iso_desc_addr + dwc_ep->desc_cnt * (dwc_ep->proc_buf_num);
 
 	if (dwc_ep->is_in) {
-		dev_dma_desc_sts_t sts = {.d32 = 0 };
+		dev_dma_desc_sts_t sts = {
+		.d32 = 0};
 		for (i = 0; i < dwc_ep->desc_cnt; ++i, ++dma_desc) {
 			sts.d32 = dma_desc->status.d32;
 			sts.b_iso_in.bs = BS_HOST_READY;
 			dma_desc->status.d32 = sts.d32;
 		}
 	} else {
-		dev_dma_desc_sts_t sts = {.d32 = 0 };
+		dev_dma_desc_sts_t sts = {
+		.d32 = 0};
 		for (i = 0; i < dwc_ep->desc_cnt; ++i, ++dma_desc) {
 			sts.d32 = dma_desc->status.d32;
 			sts.b_iso_out.bs = BS_HOST_READY;
@@ -2569,9 +2582,10 @@ static void dwc_otg_pcd_handle_iso_bna(dwc_otg_pcd_ep_t * ep)
  * @param ep The EP to start the transfer on.
  *
  */
-void set_current_pkt_info(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+void set_current_pkt_info(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
-	deptsiz_data_t deptsiz = {.d32 = 0 };
+	deptsiz_data_t deptsiz = {
+	.d32 = 0};
 	dma_addr_t dma_addr;
 	uint32_t offset;
 
@@ -2617,11 +2631,11 @@ void set_current_pkt_info(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param dwc_ep The EP to start the transfer on.
  *
  */
-static void set_ddma_iso_pkts_info(dwc_otg_core_if_t * core_if,
-				   dwc_ep_t * dwc_ep)
-{
+static void set_ddma_iso_pkts_info(dwc_otg_core_if_t *core_if,
+				   dwc_ep_t *dwc_ep) {
 	dwc_otg_dev_dma_desc_t *dma_desc;
-	dev_dma_desc_sts_t sts = {.d32 = 0 };
+	dev_dma_desc_sts_t sts = {
+	.d32 = 0};
 	iso_pkt_info_t *iso_packet;
 	uint32_t data_per_desc;
 	uint32_t offset;
@@ -2634,17 +2648,17 @@ static void set_ddma_iso_pkts_info(dwc_otg_core_if_t * core_if,
 	if (dwc_ep->is_in == 0) {
 		dma_desc =
 		    dwc_ep->iso_desc_addr +
-		    dwc_ep->desc_cnt * dwc_ep->proc_buf_num;
+		    dwc_ep->desc_cnt*dwc_ep->proc_buf_num;
 		offset = 0;
 
 		for (i = 0; i < dwc_ep->desc_cnt - dwc_ep->pkt_per_frm;
 		     i += dwc_ep->pkt_per_frm) {
 			for (j = 0; j < dwc_ep->pkt_per_frm; ++j) {
 				data_per_desc =
-				    ((j + 1) * dwc_ep->maxpacket >
+				    ((j + 1)*dwc_ep->maxpacket >
 				     dwc_ep->
 				     data_per_frame) ? dwc_ep->data_per_frame -
-				    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+				    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 				data_per_desc +=
 				    (data_per_desc % 4) ? (4 -
 							   data_per_desc %
@@ -2683,9 +2697,9 @@ static void set_ddma_iso_pkts_info(dwc_otg_core_if_t * core_if,
 
 		for (j = 0; j < dwc_ep->pkt_per_frm - 1; ++j) {
 			data_per_desc =
-			    ((j + 1) * dwc_ep->maxpacket >
+			    ((j + 1)*dwc_ep->maxpacket >
 			     dwc_ep->data_per_frame) ? dwc_ep->data_per_frame -
-			    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+			    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 			data_per_desc +=
 			    (data_per_desc % 4) ? (4 - data_per_desc % 4) : 0;
 
@@ -2734,7 +2748,7 @@ static void set_ddma_iso_pkts_info(dwc_otg_core_if_t * core_if,
 
 		dma_desc =
 		    dwc_ep->iso_desc_addr +
-		    dwc_ep->desc_cnt * dwc_ep->proc_buf_num;
+		    dwc_ep->desc_cnt*dwc_ep->proc_buf_num;
 
 		for (i = 0; i < dwc_ep->desc_cnt - 1; i++) {
 			sts.d32 = dma_desc->status.d32;
@@ -2780,13 +2794,14 @@ static void set_ddma_iso_pkts_info(dwc_otg_core_if_t * core_if,
  * @param dwc_ep The EP to start the transfer on.
  *
  */
-static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
+static void reinit_ddma_iso_xfer(dwc_otg_core_if_t *core_if, dwc_ep_t *dwc_ep)
 {
 	int i, j;
 	dwc_otg_dev_dma_desc_t *dma_desc;
 	dma_addr_t dma_ad;
 	volatile uint32_t *addr;
-	dev_dma_desc_sts_t sts = {.d32 = 0 };
+	dev_dma_desc_sts_t sts = {
+	.d32 = 0};
 	uint32_t data_per_desc;
 
 	if (dwc_ep->is_in == 0) {
@@ -2808,7 +2823,7 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
 	if (dwc_ep->is_in == 0) {
 		dma_desc =
 		    dwc_ep->iso_desc_addr +
-		    dwc_ep->desc_cnt * dwc_ep->proc_buf_num;
+		    dwc_ep->desc_cnt*dwc_ep->proc_buf_num;
 
 		sts.b_iso_out.bs = BS_HOST_READY;
 		sts.b_iso_out.rxsts = 0;
@@ -2822,10 +2837,10 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
 		     i += dwc_ep->pkt_per_frm) {
 			for (j = 0; j < dwc_ep->pkt_per_frm; ++j) {
 				data_per_desc =
-				    ((j + 1) * dwc_ep->maxpacket >
+				    ((j + 1)*dwc_ep->maxpacket >
 				     dwc_ep->
 				     data_per_frame) ? dwc_ep->data_per_frame -
-				    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+				    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 				data_per_desc +=
 				    (data_per_desc % 4) ? (4 -
 							   data_per_desc %
@@ -2842,9 +2857,9 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
 		for (j = 0; j < dwc_ep->pkt_per_frm - 1; ++j) {
 
 			data_per_desc =
-			    ((j + 1) * dwc_ep->maxpacket >
+			    ((j + 1)*dwc_ep->maxpacket >
 			     dwc_ep->data_per_frame) ? dwc_ep->data_per_frame -
-			    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+			    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 			data_per_desc +=
 			    (data_per_desc % 4) ? (4 - data_per_desc % 4) : 0;
 			sts.b_iso_out.rxbytes = data_per_desc;
@@ -2860,9 +2875,9 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
 		sts.b_iso_out.l = dwc_ep->proc_buf_num;
 
 		data_per_desc =
-		    ((j + 1) * dwc_ep->maxpacket >
+		    ((j + 1)*dwc_ep->maxpacket >
 		     dwc_ep->data_per_frame) ? dwc_ep->data_per_frame -
-		    j * dwc_ep->maxpacket : dwc_ep->maxpacket;
+		    j*dwc_ep->maxpacket : dwc_ep->maxpacket;
 		data_per_desc +=
 		    (data_per_desc % 4) ? (4 - data_per_desc % 4) : 0;
 		sts.b_iso_out.rxbytes = data_per_desc;
@@ -2874,7 +2889,7 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
 
 		dma_desc =
 		    dwc_ep->iso_desc_addr +
-		    dwc_ep->desc_cnt * dwc_ep->proc_buf_num;
+		    dwc_ep->desc_cnt*dwc_ep->proc_buf_num;
 
 		sts.b_iso_in.bs = BS_HOST_READY;
 		sts.b_iso_in.txsts = 0;
@@ -2914,14 +2929,15 @@ static void reinit_ddma_iso_xfer(dwc_otg_core_if_t * core_if, dwc_ep_t * dwc_ep)
  * @param dwc_ep The EP for wihich transfer complete was asserted
  *
  */
-static uint32_t handle_iso_out_pkt_dropped(dwc_otg_core_if_t * core_if,
-					   dwc_ep_t * dwc_ep)
-{
+static uint32_t handle_iso_out_pkt_dropped(dwc_otg_core_if_t *core_if,
+					   dwc_ep_t *dwc_ep) {
 	uint32_t dma_addr;
 	uint32_t drp_pkt;
 	uint32_t drp_pkt_cnt;
-	deptsiz_data_t deptsiz = {.d32 = 0 };
-	depctl_data_t depctl = {.d32 = 0 };
+	deptsiz_data_t deptsiz = {
+	.d32 = 0};
+	depctl_data_t depctl = {
+	.d32 = 0};
 	int i;
 
 	deptsiz.d32 =
@@ -2941,7 +2957,7 @@ static uint32_t handle_iso_out_pkt_dropped(dwc_otg_core_if_t * core_if,
 	if (deptsiz.b.pktcnt > 0) {
 		deptsiz.b.xfersize =
 		    dwc_ep->xfer_len - (dwc_ep->pkt_cnt -
-					deptsiz.b.pktcnt) * dwc_ep->maxpacket;
+					deptsiz.b.pktcnt)*dwc_ep->maxpacket;
 	} else {
 		deptsiz.b.xfersize = 0;
 		deptsiz.b.pktcnt = 0;
@@ -2985,7 +3001,7 @@ static uint32_t handle_iso_out_pkt_dropped(dwc_otg_core_if_t * core_if,
  * @param ep The EP to start the transfer on.
  *
  */
-static uint32_t set_iso_pkts_info(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
+static uint32_t set_iso_pkts_info(dwc_otg_core_if_t *core_if, dwc_ep_t *ep)
 {
 	int i, j;
 	dma_addr_t dma_ad;
@@ -3061,7 +3077,7 @@ static uint32_t set_iso_pkts_info(dwc_otg_core_if_t * core_if, dwc_ep_t * ep)
  * @param ep The EP for which transfer complete was asserted
  *
  */
-static void complete_iso_ep(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep)
+static void complete_iso_ep(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *ep)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(ep->pcd);
 	dwc_ep_t *dwc_ep = &ep->dwc_ep;
@@ -3136,14 +3152,16 @@ static void complete_iso_ep(dwc_otg_pcd_t * pcd, dwc_otg_pcd_ep_t * ep)
  * This function handle BNA interrupt for Non Isochronous EPs
  *
  */
-static void dwc_otg_pcd_handle_noniso_bna(dwc_otg_pcd_ep_t * ep)
+static void dwc_otg_pcd_handle_noniso_bna(dwc_otg_pcd_ep_t *ep)
 {
 	dwc_ep_t *dwc_ep = &ep->dwc_ep;
 	volatile uint32_t *addr;
-	depctl_data_t depctl = {.d32 = 0 };
+	depctl_data_t depctl = {
+	.d32 = 0};
 	dwc_otg_pcd_t *pcd = ep->pcd;
 	dwc_otg_dev_dma_desc_t *dma_desc;
-	dev_dma_desc_sts_t sts = {.d32 = 0 };
+	dev_dma_desc_sts_t sts = {
+	.d32 = 0};
 	dwc_otg_core_if_t *core_if = ep->pcd->core_if;
 	int i, start;
 
@@ -3152,18 +3170,19 @@ static void dwc_otg_pcd_handle_noniso_bna(dwc_otg_pcd_ep_t * ep)
 			 (dwc_ep->is_in ? "IN" : "OUT"), dwc_ep->desc_cnt);
 
 	if (core_if->core_params->cont_on_bna && !dwc_ep->is_in
-							&& dwc_ep->type != DWC_OTG_EP_TYPE_CONTROL) {
+	    && dwc_ep->type != DWC_OTG_EP_TYPE_CONTROL) {
 		uint32_t doepdma;
 		dwc_otg_dev_out_ep_regs_t *out_regs =
-			core_if->dev_if->out_ep_regs[dwc_ep->num];
+		    core_if->dev_if->out_ep_regs[dwc_ep->num];
 		doepdma = DWC_READ_REG32(&(out_regs->doepdma));
-		start = (doepdma - dwc_ep->dma_desc_addr)/sizeof(dwc_otg_dev_dma_desc_t);
+		start =
+		    (doepdma -
+		     dwc_ep->dma_desc_addr) / sizeof(dwc_otg_dev_dma_desc_t);
 		dma_desc = &(dwc_ep->desc_addr[start]);
 	} else {
 		start = 0;
 		dma_desc = dwc_ep->desc_addr;
 	}
-	
 
 	for (i = start; i < dwc_ep->desc_cnt; ++i, ++dma_desc) {
 		sts.d32 = dma_desc->status.d32;
@@ -3190,7 +3209,7 @@ static void dwc_otg_pcd_handle_noniso_bna(dwc_otg_pcd_ep_t * ep)
  * The state of the control transfers are tracked in
  * <code>ep0state</code>.
  */
-static void handle_ep0(dwc_otg_pcd_t * pcd)
+static void handle_ep0(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_pcd_ep_t *ep0 = &pcd->ep0;
@@ -3324,11 +3343,12 @@ static void handle_ep0(dwc_otg_pcd_t * pcd)
 /**
  * Restart transfer
  */
-static void restart_transfer(dwc_otg_pcd_t * pcd, const uint32_t epnum)
+static void restart_transfer(dwc_otg_pcd_t *pcd, const uint32_t epnum)
 {
 	dwc_otg_core_if_t *core_if;
 	dwc_otg_dev_if_t *dev_if;
-	deptsiz_data_t dieptsiz = {.d32 = 0 };
+	deptsiz_data_t dieptsiz = {
+	.d32 = 0};
 	dwc_otg_pcd_ep_t *ep;
 
 	ep = get_in_ep(pcd, epnum);
@@ -3381,7 +3401,7 @@ static void restart_transfer(dwc_otg_pcd_t * pcd, const uint32_t epnum)
  *
  * @param core_if Programming view of DWC_otg controller
  */
-void predict_nextep_seq( dwc_otg_core_if_t * core_if)
+void predict_nextep_seq(dwc_otg_core_if_t *core_if)
 {
 	dwc_otg_device_global_regs_t *dev_global_regs =
 	    core_if->dev_if->dev_global_regs;
@@ -3392,7 +3412,8 @@ void predict_nextep_seq( dwc_otg_core_if_t * core_if)
 	uint32_t in_tkn_epnums[4];
 	uint8_t seqnum[MAX_EPS_CHANNELS];
 	uint8_t intkn_seq[TOKEN_Q_DEPTH];
-	grstctl_t resetctl = {.d32 = 0 };
+	grstctl_t resetctl = {
+	.d32 = 0};
 	uint8_t temp;
 	int ndx = 0;
 	int start = 0;
@@ -3524,7 +3545,8 @@ void predict_nextep_seq( dwc_otg_core_if_t * core_if)
 			if (seqnum[i + 1] != 0xff) {
 				core_if->nextep_seq[seqnum[i]] = seqnum[i + 1];
 			} else {
-				core_if->nextep_seq[seqnum[i]] = core_if->first_in_nextep_seq;
+				core_if->nextep_seq[seqnum[i]] =
+				    core_if->first_in_nextep_seq;
 				break;
 			}
 		} else {
@@ -3542,20 +3564,21 @@ void predict_nextep_seq( dwc_otg_core_if_t * core_if)
 	resetctl.d32 = DWC_READ_REG32(&core_if->core_global_regs->grstctl);
 	resetctl.b.intknqflsh = 1;
 	DWC_WRITE_REG32(&core_if->core_global_regs->grstctl, resetctl.d32);
-	
 
 }
 
 /**
  * handle the IN EP disable interrupt.
  */
-static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t * pcd,
+static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t *pcd,
 					     const uint32_t epnum)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
-	deptsiz_data_t dieptsiz = {.d32 = 0 };
-	dctl_data_t dctl = {.d32 = 0 };
+	deptsiz_data_t dieptsiz = {
+	.d32 = 0};
+	dctl_data_t dctl = {
+	.d32 = 0};
 	dwc_otg_pcd_ep_t *ep;
 	dwc_ep_t *dwc_ep;
 	gintmsk_data_t gintmsk_data;
@@ -3586,11 +3609,13 @@ static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t * pcd,
 		if (ep->stopped) {
 			if (core_if->en_multiple_tx_fifo)
 				/* Flush the Tx FIFO */
-				dwc_otg_flush_tx_fifo(core_if, dwc_ep->tx_fifo_num);
+				dwc_otg_flush_tx_fifo(core_if,
+						      dwc_ep->tx_fifo_num);
 			/* Clear the Global IN NP NAK */
 			dctl.d32 = 0;
 			dctl.b.cgnpinnak = 1;
-			DWC_MODIFY_REG32(&dev_if->dev_global_regs->dctl, dctl.d32, dctl.d32); 
+			DWC_MODIFY_REG32(&dev_if->dev_global_regs->dctl,
+					 dctl.d32, dctl.d32);
 			/* Restart the transaction */
 			if (dieptsiz.b.pktcnt != 0 || dieptsiz.b.xfersize != 0) {
 				restart_transfer(pcd, epnum);
@@ -3605,72 +3630,108 @@ static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t * pcd,
 		return;
 	}
 
-	if (core_if->start_predict > 2) {	// NP IN EP
+	if (core_if->start_predict > 2) {
+		/* NP IN EP */
 		core_if->start_predict--;
 		return;
 	}
 
 	core_if->start_predict--;
 
-	if (core_if->start_predict == 1) {	// All NP IN Ep's disabled now
-
+	if (core_if->start_predict == 1) {
+		/* All NP IN Ep's disabled now */
 		predict_nextep_seq(core_if);
 
 		/* Update all active IN EP's NextEP field based of nextep_seq[] */
 		for (i = 0; i <= core_if->dev_if->num_in_eps; i++) {
 			depctl.d32 =
 			    DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
-			if (core_if->nextep_seq[i] != 0xff) {	// Active NP IN EP
+			if (core_if->nextep_seq[i] != 0xff) {
+				/* Active NP IN EP */
 				depctl.b.nextep = core_if->nextep_seq[i];
-				DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl, depctl.d32);
+				DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl,
+						depctl.d32);
 			}
 		}
 		/* Flush Shared NP TxFIFO */
 		dwc_otg_flush_tx_fifo(core_if, 0);
 		/* Rewind buffers */
-		if (!core_if->dma_desc_enable) {		
+		if (!core_if->dma_desc_enable) {
 			i = core_if->first_in_nextep_seq;
 			do {
 				ep = get_in_ep(pcd, i);
-				dieptsiz.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->dieptsiz);
-				xfer_size = ep->dwc_ep.total_len - ep->dwc_ep.xfer_count;
-				if (xfer_size > ep->dwc_ep.maxxfer) 
+				dieptsiz.d32 =
+				    DWC_READ_REG32(&dev_if->
+						   in_ep_regs[i]->dieptsiz);
+				xfer_size =
+				    ep->dwc_ep.total_len -
+				    ep->dwc_ep.xfer_count;
+				if (xfer_size > ep->dwc_ep.maxxfer)
 					xfer_size = ep->dwc_ep.maxxfer;
-				depctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
+				depctl.d32 =
+				    DWC_READ_REG32(&dev_if->
+						   in_ep_regs[i]->diepctl);
 				if (dieptsiz.b.pktcnt != 0) {
 					if (xfer_size == 0) {
 						remain_to_transfer = 0;
 					} else {
-						if ((xfer_size % ep->dwc_ep.maxpacket) == 0) {
-							remain_to_transfer = 
-								dieptsiz.b.pktcnt * ep->dwc_ep.maxpacket;
+						if ((xfer_size %
+						     ep->dwc_ep.maxpacket) ==
+						    0) {
+							remain_to_transfer =
+							    dieptsiz.b.pktcnt *
+							    ep->
+							    dwc_ep.maxpacket;
 						} else {
-							remain_to_transfer = ((dieptsiz.b.pktcnt -1) * ep->dwc_ep.maxpacket) 
-								+ (xfer_size % ep->dwc_ep.maxpacket);
+							remain_to_transfer =
+							    ((dieptsiz.
+							      b.pktcnt -
+							      1) *
+							     ep->
+							     dwc_ep.maxpacket)
+							    +
+							    (xfer_size %
+							     ep->
+							     dwc_ep.maxpacket);
 						}
 					}
-					diepdma = DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepdma);
-					dieptsiz.b.xfersize = remain_to_transfer;
-					DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->dieptsiz, dieptsiz.d32);
-					diepdma = ep->dwc_ep.dma_addr + (xfer_size - remain_to_transfer);
-					DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepdma, diepdma);
+					diepdma =
+					    DWC_READ_REG32(&dev_if->in_ep_regs
+							   [i]->diepdma);
+					dieptsiz.b.xfersize =
+					    remain_to_transfer;
+					DWC_WRITE_REG32(&dev_if->
+							in_ep_regs[i]->dieptsiz,
+							dieptsiz.d32);
+					diepdma =
+					    ep->dwc_ep.dma_addr + (xfer_size -
+								   remain_to_transfer);
+					DWC_WRITE_REG32(&dev_if->
+							in_ep_regs[i]->diepdma,
+							diepdma);
 				}
 				i = core_if->nextep_seq[i];
 			} while (i != core_if->first_in_nextep_seq);
-		} else { // dma_desc_enable
-				DWC_PRINTF("%s Learning Queue not supported in DDMA\n", __func__);
+		} else {	/* dma_desc_enable */
+			DWC_PRINTF("%s Learning Queue not supported in DDMA\n",
+				   __func__);
 		}
-				
+
 		/* Restart transfers in predicted sequences */
 		i = core_if->first_in_nextep_seq;
 		do {
-			dieptsiz.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->dieptsiz);
-			depctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
+			dieptsiz.d32 =
+			    DWC_READ_REG32(&dev_if->in_ep_regs[i]->dieptsiz);
+			depctl.d32 =
+			    DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
 			if (dieptsiz.b.pktcnt != 0) {
-				depctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
+				depctl.d32 =
+				    DWC_READ_REG32(&dev_if->
+						   in_ep_regs[i]->diepctl);
 				depctl.b.epena = 1;
 				depctl.b.cnak = 1;
-				DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl, depctl.d32);
+				DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl,
+						depctl.d32);
 			}
 			i = core_if->nextep_seq[i];
 		} while (i != core_if->first_in_nextep_seq);
@@ -3678,35 +3739,40 @@ static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t * pcd,
 		/* Clear the global non-periodic IN NAK handshake */
 		dctl.d32 = 0;
 		dctl.b.cgnpinnak = 1;
-		DWC_MODIFY_REG32(&dev_if->dev_global_regs->dctl, dctl.d32, dctl.d32); 
-			
+		DWC_MODIFY_REG32(&dev_if->dev_global_regs->dctl, dctl.d32,
+				 dctl.d32);
+
 		/* Unmask EP Mismatch interrupt */
 		gintmsk_data.d32 = 0;
 		gintmsk_data.b.epmismatch = 1;
-		DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk, 0, gintmsk_data.d32);
-		
+		DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk, 0,
+				 gintmsk_data.d32);
+
 		core_if->start_predict = 0;
 
-	} 
+	}
 }
 
 /**
  * Handler for the IN EP timeout handshake interrupt.
  */
-static inline void handle_in_ep_timeout_intr(dwc_otg_pcd_t * pcd,
+static inline void handle_in_ep_timeout_intr(dwc_otg_pcd_t *pcd,
 					     const uint32_t epnum)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
 
 #ifdef DEBUG
-	deptsiz_data_t dieptsiz = {.d32 = 0 };
+	deptsiz_data_t dieptsiz = {
+	.d32 = 0};
 	uint32_t num = 0;
 #endif
-	dctl_data_t dctl = {.d32 = 0 };
+	dctl_data_t dctl = {
+	.d32 = 0};
 	dwc_otg_pcd_ep_t *ep;
 
-	gintmsk_data_t intr_mask = {.d32 = 0 };
+	gintmsk_data_t intr_mask = {
+	.d32 = 0};
 
 	ep = get_in_ep(pcd, epnum);
 
@@ -3754,12 +3820,13 @@ static inline void handle_in_ep_timeout_intr(dwc_otg_pcd_t * pcd,
 /**
  * Handler for the IN EP NAK interrupt.
  */
-static inline int32_t handle_in_ep_nak_intr(dwc_otg_pcd_t * pcd,
+static inline int32_t handle_in_ep_nak_intr(dwc_otg_pcd_t *pcd,
 					    const uint32_t epnum)
 {
 	/** @todo implement ISR */
 	dwc_otg_core_if_t *core_if;
-	diepmsk_data_t intr_mask = {.d32 = 0 };
+	diepmsk_data_t intr_mask = {
+	.d32 = 0};
 
 	DWC_PRINTF("INTERRUPT Handler not implemented for %s\n", "IN EP NAK");
 	core_if = GET_CORE_IF(pcd);
@@ -3779,12 +3846,13 @@ static inline int32_t handle_in_ep_nak_intr(dwc_otg_pcd_t * pcd,
 /**
  * Handler for the OUT EP Babble interrupt.
  */
-static inline int32_t handle_out_ep_babble_intr(dwc_otg_pcd_t * pcd,
+static inline int32_t handle_out_ep_babble_intr(dwc_otg_pcd_t *pcd,
 						const uint32_t epnum)
 {
 	/** @todo implement ISR */
 	dwc_otg_core_if_t *core_if;
-	doepmsk_data_t intr_mask = {.d32 = 0 };
+	doepmsk_data_t intr_mask = {
+	.d32 = 0};
 
 	DWC_PRINTF("INTERRUPT Handler not implemented for %s\n",
 		   "OUT EP Babble");
@@ -3805,14 +3873,16 @@ static inline int32_t handle_out_ep_babble_intr(dwc_otg_pcd_t * pcd,
 /**
  * Handler for the OUT EP NAK interrupt.
  */
-static inline int32_t handle_out_ep_nak_intr(dwc_otg_pcd_t * pcd,
+static inline int32_t handle_out_ep_nak_intr(dwc_otg_pcd_t *pcd,
 					     const uint32_t epnum)
 {
 	/** @todo implement ISR */
 	dwc_otg_core_if_t *core_if;
-	doepmsk_data_t intr_mask = {.d32 = 0 };
+	doepmsk_data_t intr_mask = {
+	.d32 = 0};
 
-	DWC_DEBUGPL(DBG_ANY, "INTERRUPT Handler not implemented for %s\n", "OUT EP NAK");
+	DWC_DEBUGPL(DBG_ANY, "INTERRUPT Handler not implemented for %s\n",
+		    "OUT EP NAK");
 	core_if = GET_CORE_IF(pcd);
 	intr_mask.b.nak = 1;
 
@@ -3830,12 +3900,13 @@ static inline int32_t handle_out_ep_nak_intr(dwc_otg_pcd_t * pcd,
 /**
  * Handler for the OUT EP NYET interrupt.
  */
-static inline int32_t handle_out_ep_nyet_intr(dwc_otg_pcd_t * pcd,
+static inline int32_t handle_out_ep_nyet_intr(dwc_otg_pcd_t *pcd,
 					      const uint32_t epnum)
 {
 	/** @todo implement ISR */
 	dwc_otg_core_if_t *core_if;
-	doepmsk_data_t intr_mask = {.d32 = 0 };
+	doepmsk_data_t intr_mask = {
+	.d32 = 0};
 
 	DWC_PRINTF("INTERRUPT Handler not implemented for %s\n", "OUT EP NYET");
 	core_if = GET_CORE_IF(pcd);
@@ -3868,11 +3939,11 @@ static inline int32_t handle_out_ep_nyet_intr(dwc_otg_pcd_t * pcd,
  * -#	If "IN Token EP Mismatch" (disable, this is handled by EP
  *		Mismatch Interrupt)
  */
-static int32_t dwc_otg_pcd_handle_in_ep_intr(dwc_otg_pcd_t * pcd)
+static int32_t dwc_otg_pcd_handle_in_ep_intr(dwc_otg_pcd_t *pcd)
 {
-#define CLEAR_IN_EP_INTR(__core_if,__epnum,__intr) \
+#define CLEAR_IN_EP_INTR(__core_if, __epnum, __intr) \
 do { \
-		diepint_data_t diepint = {.d32=0}; \
+		diepint_data_t diepint = {.d32 = 0}; \
 		diepint.b.__intr = 1; \
 		DWC_WRITE_REG32(&__core_if->dev_if->in_ep_regs[__epnum]->diepint, \
 		diepint.d32); \
@@ -3880,14 +3951,18 @@ do { \
 
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
-	diepint_data_t diepint = {.d32 = 0 };
-	depctl_data_t depctl = {.d32 = 0 };
+	diepint_data_t diepint = {
+	.d32 = 0};
+	depctl_data_t depctl = {
+	.d32 = 0};
 	uint32_t ep_intr;
 	uint32_t epnum = 0;
 	dwc_otg_pcd_ep_t *ep;
 	dwc_ep_t *dwc_ep;
-	gintmsk_data_t intr_mask = {.d32 = 0 };
-	dctl_data_t dctl = {.d32=0};
+	gintmsk_data_t intr_mask = {
+	.d32 = 0};
+	dctl_data_t dctl = {
+	.d32 = 0};
 
 	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, pcd);
 
@@ -3930,7 +4005,8 @@ do { \
 				if (core_if->en_multiple_tx_fifo == 0) {
 					intr_mask.b.nptxfempty = 1;
 					DWC_MODIFY_REG32
-					    (&core_if->core_global_regs->gintmsk,
+					    (&core_if->
+					     core_global_regs->gintmsk,
 					     intr_mask.d32, 0);
 				} else {
 					/* Disable the Tx FIFO Empty Interrupt for this EP */
@@ -3960,19 +4036,21 @@ do { \
 				}
 #endif /* DWC_UTE_PER_IO */
 				else {
-					if (dwc_ep->type == DWC_OTG_EP_TYPE_ISOC && 
-							dwc_ep->bInterval > 1) {
-						dwc_ep->frame_num += dwc_ep->bInterval;
-						if (dwc_ep->frame_num > 0x3FFF)
-						{
+					if (dwc_ep->type == DWC_OTG_EP_TYPE_ISOC
+					    && dwc_ep->bInterval > 1) {
+						dwc_ep->frame_num +=
+						    dwc_ep->bInterval;
+						if (dwc_ep->frame_num > 0x3FFF) {
 							dwc_ep->frm_overrun = 1;
-							dwc_ep->frame_num &= 0x3FFF;
-						} else 
+							dwc_ep->frame_num &=
+							    0x3FFF;
+						} else
 							dwc_ep->frm_overrun = 0;
 					}
 					complete_ep(ep);
-					if(diepint.b.nak)
-						CLEAR_IN_EP_INTR(core_if, epnum, nak);
+					if (diepint.b.nak)
+						CLEAR_IN_EP_INTR(core_if, epnum,
+								 nak);
 				}
 			}
 			/* Endpoint disable      */
@@ -3989,15 +4067,22 @@ do { \
 				DWC_ERROR("EP%d IN AHB Error\n", epnum);
 				/* Clear the bit in DIEPINTn for this interrupt */
 				DWC_ERROR("EP%d DEPDMA=0x%08x \n",
-						epnum, core_if->dev_if->in_ep_regs[epnum]->diepdma);
+					  epnum,
+					  core_if->dev_if->
+					  in_ep_regs[epnum]->diepdma);
 				CLEAR_IN_EP_INTR(core_if, epnum, ahberr);
-				dctl.d32= DWC_READ_REG32( &core_if->dev_if->dev_global_regs->dctl );
+				dctl.d32 =
+				    DWC_READ_REG32(&core_if->
+						   dev_if->dev_global_regs->
+						   dctl);
 				dctl.b.sftdiscon = 1;
-				DWC_WRITE_REG32( &core_if->dev_if->dev_global_regs->dctl, dctl.d32 );
+				DWC_WRITE_REG32(&core_if->
+						dev_if->dev_global_regs->dctl,
+						dctl.d32);
 				dwc_otg_disable_global_interrupts(core_if);
 				ep->pcd->vbus_status = 0;
-				if(ep->pcd->conn_status){
-						ep->pcd->conn_status = 0;
+				if (ep->pcd->conn_status) {
+					ep->pcd->conn_status = 0;
 				}
 				DWC_SPINUNLOCK(pcd->lock);
 				cil_pcd_stop(core_if);
@@ -4017,23 +4102,26 @@ do { \
 					    epnum);
 				if (!ep->stopped && epnum != 0) {
 
-					diepmsk_data_t diepmsk = {.d32 = 0 };
+					diepmsk_data_t diepmsk = {
+					.d32 = 0};
 					diepmsk.b.intktxfemp = 1;
 
 					if (core_if->multiproc_int_enable) {
 						DWC_MODIFY_REG32
-						    (&dev_if->dev_global_regs->diepeachintmsk
+						    (&dev_if->
+						     dev_global_regs->diepeachintmsk
 						     [epnum], diepmsk.d32, 0);
 					} else {
 						DWC_MODIFY_REG32
-						    (&dev_if->dev_global_regs->diepmsk,
+						    (&dev_if->
+						     dev_global_regs->diepmsk,
 						     diepmsk.d32, 0);
 					}
 				} else if (core_if->dma_desc_enable
 					   && epnum == 0
 					   && pcd->ep0state ==
 					   EP0_OUT_STATUS_PHASE) {
-					// EP0 IN set STALL
+					/* EP0 IN set STALL */
 					depctl.d32 =
 					    DWC_READ_REG32(&dev_if->in_ep_regs
 							   [epnum]->diepctl);
@@ -4098,11 +4186,13 @@ do { \
 						 */
 						if (dwc_ep->next_frame !=
 						    0xffffffff)
-							dwc_otg_pcd_handle_iso_bna(ep);
+							dwc_otg_pcd_handle_iso_bna
+							    (ep);
 					} else
-#endif				/* DWC_EN_ISOC */
+#endif /* DWC_EN_ISOC */
 					{
-						dwc_otg_pcd_handle_noniso_bna(ep);
+						dwc_otg_pcd_handle_noniso_bna
+						    (ep);
 					}
 				}
 			}
@@ -4113,26 +4203,44 @@ do { \
 				if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
 					depctl_data_t depctl;
 					if (ep->dwc_ep.frame_num == 0xFFFFFFFF) {
-						ep->dwc_ep.frame_num = core_if->frame_num;
+						ep->dwc_ep.frame_num =
+						    core_if->frame_num;
 						if (ep->dwc_ep.bInterval > 1) {
 							depctl.d32 = 0;
-							depctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[epnum]->diepctl);
-							if (ep->dwc_ep.frame_num & 0x1) {
-								depctl.b.setd1pid = 1;
-								depctl.b.setd0pid = 0;
+							depctl.d32 =
+							    DWC_READ_REG32
+							    (&dev_if->in_ep_regs
+							     [epnum]->diepctl);
+							if (ep->
+							    dwc_ep.frame_num &
+							    0x1) {
+								depctl.
+								    b.setd1pid =
+								    1;
+								depctl.
+								    b.setd0pid =
+								    0;
 							} else {
-								depctl.b.setd0pid = 1;
-								depctl.b.setd1pid = 0;
+								depctl.
+								    b.setd0pid =
+								    1;
+								depctl.
+								    b.setd1pid =
+								    0;
 							}
-							DWC_WRITE_REG32(&dev_if->in_ep_regs[epnum]->diepctl, depctl.d32);
+							DWC_WRITE_REG32
+							    (&dev_if->in_ep_regs
+							     [epnum]->diepctl,
+							     depctl.d32);
 						}
 						start_next_request(ep);
 					}
-					ep->dwc_ep.frame_num += ep->dwc_ep.bInterval;
-					if (dwc_ep->frame_num > 0x3FFF)	{
+					ep->dwc_ep.frame_num +=
+					    ep->dwc_ep.bInterval;
+					if (dwc_ep->frame_num > 0x3FFF) {
 						dwc_ep->frm_overrun = 1;
 						dwc_ep->frame_num &= 0x3FFF;
-					} else 
+					} else
 						dwc_ep->frm_overrun = 0;
 				}
 
@@ -4160,11 +4268,11 @@ do { \
  * -#	If "Setup Phase Done" process Setup Packet (See Standard USB
  *		Command Processing)
  */
-static int32_t dwc_otg_pcd_handle_out_ep_intr(dwc_otg_pcd_t * pcd)
+static int32_t dwc_otg_pcd_handle_out_ep_intr(dwc_otg_pcd_t *pcd)
 {
-#define CLEAR_OUT_EP_INTR(__core_if,__epnum,__intr) \
+#define CLEAR_OUT_EP_INTR(__core_if, __epnum, __intr) \
 do { \
-		doepint_data_t doepint = {.d32=0}; \
+		doepint_data_t doepint = {.d32 = 0}; \
 		doepint.b.__intr = 1; \
 		DWC_WRITE_REG32(&__core_if->dev_if->out_ep_regs[__epnum]->doepint, \
 		doepint.d32); \
@@ -4172,13 +4280,15 @@ do { \
 
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	uint32_t ep_intr;
-	doepint_data_t doepint = {.d32 = 0 };
+	doepint_data_t doepint = {
+	.d32 = 0};
 	uint32_t epnum = 0;
 	dwc_otg_pcd_ep_t *ep;
 	dwc_ep_t *dwc_ep;
-	dctl_data_t dctl = {.d32 = 0 };
-	gintmsk_data_t gintmsk = {.d32 = 0 };
-
+	dctl_data_t dctl = {
+	.d32 = 0};
+	gintmsk_data_t gintmsk = {
+	.d32 = 0};
 
 	DWC_DEBUGPL(DBG_PCDV, "%s()\n", __func__);
 
@@ -4204,290 +4314,557 @@ do { \
 
 				if (epnum == 0) {
 					/* Clear the bit in DOEPINTn for this interrupt */
-					CLEAR_OUT_EP_INTR(core_if, epnum, xfercompl); 
-					if (core_if->snpsid >= OTG_CORE_REV_3_00a) {
-						DWC_DEBUGPL(DBG_PCDV, "in xfer xomplete DOEPINT=%x doepint=%x\n", 
-							DWC_READ_REG32(&core_if->dev_if->out_ep_regs[0]->doepint),
-							doepint.d32);
-						DWC_DEBUGPL(DBG_PCDV, "DOEPCTL=%x \n", 
-							DWC_READ_REG32(&core_if->dev_if->out_ep_regs[0]->doepctl));
-
-						if (core_if->snpsid >= OTG_CORE_REV_3_00a
-							&& core_if->dma_enable == 0) {
+					CLEAR_OUT_EP_INTR(core_if, epnum,
+							  xfercompl);
+					if (core_if->snpsid >=
+					    OTG_CORE_REV_3_00a) {
+						DWC_DEBUGPL(DBG_PCDV,
+							    "in xfer xomplete DOEPINT=%x doepint=%x\n",
+							    DWC_READ_REG32
+							    (&core_if->
+							     dev_if->out_ep_regs
+							     [0]->doepint),
+							    doepint.d32);
+						DWC_DEBUGPL(DBG_PCDV,
+							    "DOEPCTL=%x \n",
+							    DWC_READ_REG32
+							    (&core_if->
+							     dev_if->out_ep_regs
+							     [0]->doepctl));
+
+						if (core_if->snpsid >=
+						    OTG_CORE_REV_3_00a
+						    && core_if->dma_enable ==
+						    0) {
 							doepint_data_t doepint;
-							doepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-														out_ep_regs[0]->doepint);
-							if (pcd->ep0state == EP0_IDLE && doepint.b.sr) {
-								CLEAR_OUT_EP_INTR(core_if, epnum, sr);
+							doepint.d32 =
+							    DWC_READ_REG32
+							    (&core_if->dev_if->
+							     out_ep_regs[0]->
+							     doepint);
+							if (pcd->ep0state ==
+							    EP0_IDLE
+							    && doepint.b.sr) {
+								CLEAR_OUT_EP_INTR
+								    (core_if,
+								     epnum, sr);
 								goto exit_xfercompl;
 							}
 						}
 						/* In case of DDMA  look at SR bit to go to the Data Stage */
 						if (core_if->dma_desc_enable) {
-							dev_dma_desc_sts_t status = {.d32 = 0};
-							if (pcd->ep0state == EP0_IDLE) {
-								status.d32 = core_if->dev_if->setup_desc_addr[core_if->
-											dev_if->setup_desc_index]->status.d32;
-								if(pcd->data_terminated) {
-									 pcd->data_terminated = 0;
-									 status.d32 = core_if->dev_if->out_desc_addr->status.d32;
-									 dwc_memcpy(&pcd->setup_pkt->req, pcd->backup_buf, 8);
+							dev_dma_desc_sts_t
+							    status = {
+							.d32 = 0};
+							if (pcd->ep0state ==
+							    EP0_IDLE) {
+								status.d32 =
+								    core_if->dev_if->setup_desc_addr
+								    [core_if->
+								     dev_if->setup_desc_index]->status.
+								    d32;
+								if (pcd->data_terminated) {
+									pcd->data_terminated
+									    = 0;
+									status.d32
+									    =
+									    core_if->dev_if->out_desc_addr->status.d32;
+									dwc_memcpy
+									    (&pcd->setup_pkt->req,
+									     pcd->backup_buf,
+									     8);
 								}
 								if (status.b.sr) {
 									if (doepint.b.setup) {
-										DWC_DEBUGPL(DBG_PCDV, "DMA DESC EP0_IDLE SR=1 setup=1\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "DMA DESC EP0_IDLE SR=1 setup=1\n");
 										/* Already started data stage, clear setup */
-										CLEAR_OUT_EP_INTR(core_if, epnum, setup);
-										doepint.b.setup = 0;
-										handle_ep0(pcd);
+										CLEAR_OUT_EP_INTR
+										    (core_if,
+										     epnum,
+										     setup);
+										doepint.b.setup
+										    =
+										    0;
+										handle_ep0
+										    (pcd);
 										/* Prepare for more setup packets */
-										if (pcd->ep0state == EP0_IN_STATUS_PHASE || 
-											pcd->ep0state == EP0_IN_DATA_PHASE) {
-											ep0_out_start(core_if, pcd);
+										if (pcd->ep0state == EP0_IN_STATUS_PHASE || pcd->ep0state == EP0_IN_DATA_PHASE) {
+											ep0_out_start
+											    (core_if,
+											     pcd);
 										}
-										
+
 										goto exit_xfercompl;
 									} else {
 										/* Prepare for more setup packets */
-										DWC_DEBUGPL(DBG_PCDV, 
-											"EP0_IDLE SR=1 setup=0 new setup comes\n");
-										ep0_out_start(core_if, pcd);
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "EP0_IDLE SR=1 setup=0 new setup comes\n");
+										ep0_out_start
+										    (core_if,
+										     pcd);
 									}
 								}
 							} else {
-								dwc_otg_pcd_request_t *req;
-								dev_dma_desc_sts_t status = {.d32 = 0};
-								diepint_data_t diepint0;
-								diepint0.d32 = DWC_READ_REG32(&core_if->dev_if->
-															in_ep_regs[0]->diepint);
+								dwc_otg_pcd_request_t
+								    *req;
+								dev_dma_desc_sts_t
+								    status = {
+								.d32 = 0};
+								diepint_data_t
+								    diepint0;
+								diepint0.d32 =
+								    DWC_READ_REG32
+								    (&core_if->dev_if->
+								     in_ep_regs
+								     [0]->diepint);
 
 								if (pcd->ep0state == EP0_STALL || pcd->ep0state == EP0_DISCONNECT) {
-									DWC_ERROR("EP0 is stalled/disconnected\n");
+									DWC_ERROR
+									    ("EP0 is stalled/disconnected\n");
 								}
 
 								/* Clear IN xfercompl if set */
-								if (diepint0.b.xfercompl && (pcd->ep0state == EP0_IN_STATUS_PHASE
-									|| pcd->ep0state == EP0_IN_DATA_PHASE)) {
-									DWC_WRITE_REG32(&core_if->dev_if->
-										in_ep_regs[0]->diepint, diepint0.d32);
+								if (diepint0.
+								    b.xfercompl
+								    &&
+								    (pcd->ep0state
+								     ==
+								     EP0_IN_STATUS_PHASE
+								     ||
+								     pcd->ep0state
+								     ==
+								     EP0_IN_DATA_PHASE)) {
+									DWC_WRITE_REG32
+									    (&core_if->dev_if->
+									     in_ep_regs
+									     [0]->diepint,
+									     diepint0.d32);
 								}
 
-								status.d32 = core_if->dev_if->setup_desc_addr[core_if->
-									dev_if->setup_desc_index]->status.d32;
-
-								if (ep->dwc_ep.xfer_count != ep->dwc_ep.total_len
-									&& (pcd->ep0state == EP0_OUT_DATA_PHASE))
-									status.d32 = core_if->dev_if->out_desc_addr->status.d32;
+								status.d32 =
+								    core_if->dev_if->setup_desc_addr
+								    [core_if->
+								     dev_if->setup_desc_index]->status.
+								    d32;
+
+								if (ep->
+								    dwc_ep.xfer_count
+								    !=
+								    ep->
+								    dwc_ep.total_len
+								    &&
+								    (pcd->ep0state
+								     ==
+								     EP0_OUT_DATA_PHASE))
+									status.d32
+									    =
+									    core_if->dev_if->out_desc_addr->status.d32;
 								if (pcd->ep0state == EP0_OUT_STATUS_PHASE)
-									status.d32 = core_if->dev_if->
-									out_desc_addr->status.d32;
-								
+									status.d32
+									    =
+									    core_if->dev_if->
+									    out_desc_addr->status.d32;
+
 								if (status.b.sr) {
 									if (DWC_CIRCLEQ_EMPTY(&ep->queue)) {
-										DWC_DEBUGPL(DBG_PCDV, "Request queue empty!!\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "Request queue empty!!\n");
 									} else {
-										DWC_DEBUGPL(DBG_PCDV, "complete req!!\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "complete req!!\n");
 										req = DWC_CIRCLEQ_FIRST(&ep->queue);
-										if (ep->dwc_ep.xfer_count != ep->dwc_ep.total_len &&
-											pcd->ep0state == EP0_OUT_DATA_PHASE) {
-												/* Read arrived setup packet from req->buf */
-												dwc_memcpy(&pcd->setup_pkt->req, 
-													req->buf + ep->dwc_ep.xfer_count, 8);
+										if (ep->dwc_ep.xfer_count != ep->dwc_ep.total_len && pcd->ep0state == EP0_OUT_DATA_PHASE) {
+											/* Read arrived setup packet from req->buf */
+											dwc_memcpy
+											    (&pcd->setup_pkt->req,
+											     req->buf
+											     +
+											     ep->dwc_ep.xfer_count,
+											     8);
 										}
-										req->actual = ep->dwc_ep.xfer_count;
-										dwc_otg_request_done(ep, req, -ECONNRESET);
+										req->actual
+										    =
+										    ep->dwc_ep.xfer_count;
+										dwc_otg_request_done
+										    (ep,
+										     req,
+										     -ECONNRESET);
 										ep->dwc_ep.start_xfer_buff = 0;
 										ep->dwc_ep.xfer_buff = 0;
 										ep->dwc_ep.xfer_len = 0;
 									}
-									pcd->ep0state = EP0_IDLE;
+									pcd->ep0state
+									    =
+									    EP0_IDLE;
 									if (doepint.b.setup) {
-										DWC_DEBUGPL(DBG_PCDV, "EP0_IDLE SR=1 setup=1\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "EP0_IDLE SR=1 setup=1\n");
 										/* Data stage started, clear setup */
-										CLEAR_OUT_EP_INTR(core_if, epnum, setup);
-										doepint.b.setup = 0;
-										handle_ep0(pcd);
-										/* Prepare for setup packets if ep0in was enabled*/
+										CLEAR_OUT_EP_INTR
+										    (core_if,
+										     epnum,
+										     setup);
+										doepint.b.setup
+										    =
+										    0;
+										handle_ep0
+										    (pcd);
+										/* Prepare for setup packets if ep0in was enabled */
 										if (pcd->ep0state == EP0_IN_STATUS_PHASE) {
-											ep0_out_start(core_if, pcd);
+											ep0_out_start
+											    (core_if,
+											     pcd);
 										}
 
 										goto exit_xfercompl;
 									} else {
 										/* Prepare for more setup packets */
-										DWC_DEBUGPL(DBG_PCDV, 
-											"EP0_IDLE SR=1 setup=0 new setup comes 2\n");
-										ep0_out_start(core_if, pcd);
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "EP0_IDLE SR=1 setup=0 new setup comes 2\n");
+										ep0_out_start
+										    (core_if,
+										     pcd);
 									}
 								}
 							}
- 						}
-						if (core_if->snpsid >= OTG_CORE_REV_3_00a && core_if->dma_enable
-							&& core_if->dma_desc_enable == 0) {
-							doepint_data_t doepint_temp = {.d32 = 0};
-							deptsiz0_data_t doeptsize0 = {.d32 = 0 };
-							doepint_temp.d32 = DWC_READ_REG32(&core_if->dev_if->
-															out_ep_regs[ep->dwc_ep.num]->doepint);
-							doeptsize0.d32 = DWC_READ_REG32(&core_if->dev_if->
-															out_ep_regs[ep->dwc_ep.num]->doeptsiz);
-							if (((ep->dwc_ep.xfer_count == ep->dwc_ep.total_len || doeptsize0.b.xfersize == 64) &&
-								pcd->ep0state == EP0_OUT_DATA_PHASE && doepint.b.stsphsercvd) ||
-								(doeptsize0.b.xfersize == 24 && pcd->ep0state == EP0_IN_STATUS_PHASE)) {
-									CLEAR_OUT_EP_INTR(core_if, epnum, xfercompl);
-									DWC_DEBUGPL(DBG_PCDV, "WA for xfercompl along with stsphs \n");
-									doepint.b.xfercompl = 0;
-									ep0_out_start(core_if, pcd);
-									goto exit_xfercompl;
+						}
+						if (core_if->snpsid >=
+						    OTG_CORE_REV_3_00a
+						    && core_if->dma_enable
+						    && core_if->dma_desc_enable
+						    == 0) {
+							doepint_data_t
+							    doepint_temp = {
+							.d32 = 0};
+							deptsiz0_data_t
+							    doeptsize0 = {
+							.d32 = 0};
+							doepint_temp.d32 =
+							    DWC_READ_REG32
+							    (&core_if->dev_if->
+							     out_ep_regs[ep->
+									 dwc_ep.
+									 num]->doepint);
+							doeptsize0.d32 =
+							    DWC_READ_REG32
+							    (&core_if->dev_if->
+							     out_ep_regs[ep->
+									 dwc_ep.
+									 num]->doeptsiz);
+							if (((ep->
+							      dwc_ep.xfer_count
+							      ==
+							      ep->
+							      dwc_ep.total_len
+							      || doeptsize0.
+							      b.xfersize == 64)
+							     && pcd->ep0state ==
+							     EP0_OUT_DATA_PHASE
+							     && doepint.
+							     b.stsphsercvd)
+							    || (doeptsize0.
+								b.xfersize == 24
+								&& pcd->ep0state
+								==
+								EP0_IN_STATUS_PHASE)){
+								CLEAR_OUT_EP_INTR
+								    (core_if,
+								     epnum,
+								     xfercompl);
+								DWC_DEBUGPL
+								    (DBG_PCDV,
+								     "WA for xfercompl along with stsphs \n");
+								doepint.
+								    b.xfercompl
+								    = 0;
+								ep0_out_start
+								    (core_if,
+								     pcd);
+								goto exit_xfercompl;
 							}
 
-							if (pcd->ep0state == EP0_IDLE) {
+							if (pcd->ep0state ==
+							    EP0_IDLE) {
 								if (doepint_temp.b.sr) {
-									CLEAR_OUT_EP_INTR(core_if, epnum, sr);	
+									CLEAR_OUT_EP_INTR
+									    (core_if,
+									     epnum,
+									     sr);
 								}
-									/* Delay is needed for core to update setup 
-									 * packet count from 3 to 2 after receiving 
-									 * setup packet*/
-									dwc_udelay(100);
-									doepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-																	out_ep_regs[0]->doepint);
-									if (doeptsize0.b.supcnt == 3) {
-										DWC_DEBUGPL(DBG_ANY, "Rolling over!!!!!!!\n");
-										ep->dwc_ep.stp_rollover = 1;
-									}
-									if (doepint.b.setup) {
+								/* Delay is needed for core to update setup
+								 * packet count from 3 to 2 after receiving
+								 * setup packet*/
+								dwc_udelay(100);
+								doepint.d32 =
+								    DWC_READ_REG32
+								    (&core_if->dev_if->
+								     out_ep_regs
+								     [0]->doepint);
+								if (doeptsize0.b.supcnt == 3) {
+									DWC_DEBUGPL
+									    (DBG_ANY,
+									     "Rolling over!!!!!!!\n");
+									ep->dwc_ep.stp_rollover = 1;
+								}
+								if (doepint.
+								    b.setup) {
 retry:
-										/* Already started data stage, clear setup */
-										CLEAR_OUT_EP_INTR(core_if, epnum, setup);
-										doepint.b.setup = 0;
-										handle_ep0(pcd);
-										ep->dwc_ep.stp_rollover = 0;
-										/* Prepare for more setup packets */
-										if (pcd->ep0state == EP0_IN_STATUS_PHASE || 
-											pcd->ep0state == EP0_IN_DATA_PHASE) {
-											depctl_data_t depctl = {.d32 = 0};
-											depctl.b.cnak = 1;
-											ep0_out_start(core_if, pcd);
-											/* Core not updating setup packet count 
-											 * in case of PET testing - @TODO vahrama
-											 * to check with HW team further */
-											if (!core_if->otg_ver) {
-												DWC_MODIFY_REG32(&core_if->dev_if->
-													out_ep_regs[0]->doepctl, 0, depctl.d32);
-											}
+									/* Already started data stage, clear setup */
+									CLEAR_OUT_EP_INTR(core_if, epnum, setup);
+									doepint.b.setup
+									    = 0;
+									handle_ep0
+									    (pcd);
+									ep->dwc_ep.stp_rollover = 0;
+									/* Prepare for more setup packets */
+									if (pcd->ep0state == EP0_IN_STATUS_PHASE || pcd->ep0state == EP0_IN_DATA_PHASE) {
+										depctl_data_t
+										    depctl
+										    = {
+										.d32 = 0};
+										depctl.b.cnak
+										    =
+										    1;
+										ep0_out_start
+										    (core_if,
+										     pcd);
+										/* Core not updating setup packet count
+										 * in case of PET testing - @TODO vahrama
+										 * to check with HW team further */
+										if (!core_if->otg_ver) {
+											DWC_MODIFY_REG32
+											    (&core_if->dev_if->
+											     out_ep_regs
+											     [0]->doepctl,
+											     0,
+											     depctl.d32);
 										}
-										goto exit_xfercompl;
-									} else {
-										/* Prepare for more setup packets */
-										DWC_DEBUGPL(DBG_ANY, 
-											"EP0_IDLE SR=1 setup=0 new setup comes\n");
-										doepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-																	out_ep_regs[0]->doepint);
-										if(doepint.b.setup)
-											goto retry;
-										ep0_out_start(core_if, pcd);
 									}
+									goto exit_xfercompl;
+								} else {
+									/* Prepare for more setup packets */
+									DWC_DEBUGPL
+									    (DBG_ANY,
+									     "EP0_IDLE SR=1 setup=0 new setup comes\n");
+									doepint.d32
+									    =
+									    DWC_READ_REG32
+									    (&core_if->dev_if->
+									     out_ep_regs
+									     [0]->doepint);
+									if (doepint.b.setup)
+										goto retry;
+									ep0_out_start
+									    (core_if,
+									     pcd);
+								}
 							} else {
-								dwc_otg_pcd_request_t *req;
-								diepint_data_t diepint0 = {.d32 = 0};
-								doepint_data_t doepint_temp = {.d32 = 0};
-								depctl_data_t diepctl0;
-								diepint0.d32 = DWC_READ_REG32(&core_if->dev_if->
-																in_ep_regs[0]->diepint);
-								diepctl0.d32 = DWC_READ_REG32(&core_if->dev_if->
-																in_ep_regs[0]->diepctl);
-								
-								if (pcd->ep0state == EP0_IN_DATA_PHASE
-									|| pcd->ep0state == EP0_IN_STATUS_PHASE) {
+								dwc_otg_pcd_request_t
+								    *req;
+								diepint_data_t
+								    diepint0 = {
+								.d32 = 0};
+								doepint_data_t
+								    doepint_temp
+								    = {
+								.d32 = 0};
+								depctl_data_t
+								    diepctl0;
+								diepint0.d32 =
+								    DWC_READ_REG32
+								    (&core_if->dev_if->
+								     in_ep_regs
+								     [0]->diepint);
+								diepctl0.d32 =
+								    DWC_READ_REG32
+								    (&core_if->dev_if->
+								     in_ep_regs
+								     [0]->diepctl);
+
+								if (pcd->ep0state == EP0_IN_DATA_PHASE || pcd->ep0state == EP0_IN_STATUS_PHASE) {
 									if (diepint0.b.xfercompl) {
-										DWC_WRITE_REG32(&core_if->dev_if->
-											in_ep_regs[0]->diepint, diepint0.d32);
+										DWC_WRITE_REG32
+										    (&core_if->dev_if->
+										     in_ep_regs
+										     [0]->diepint,
+										     diepint0.d32);
 									}
 									if (diepctl0.b.epena) {
-										diepint_data_t diepint = {.d32 = 0};
-										diepctl0.b.snak = 1;
-										DWC_WRITE_REG32(&core_if->dev_if->
-														in_ep_regs[0]->diepctl, diepctl0.d32);
+										diepint_data_t
+										    diepint
+										    = {
+										.d32 = 0};
+										diepctl0.b.snak
+										    =
+										    1;
+										DWC_WRITE_REG32
+										    (&core_if->dev_if->
+										     in_ep_regs
+										     [0]->diepctl,
+										     diepctl0.d32);
 										do {
-											dwc_udelay(10);
-											diepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-												in_ep_regs[0]->diepint);
-										} while (!diepint.b.inepnakeff); 
-										diepint.b.inepnakeff = 1;
-										DWC_WRITE_REG32(&core_if->dev_if->
-											in_ep_regs[0]->diepint, diepint.d32);
-										diepctl0.d32 = 0;
-										diepctl0.b.epdis = 1;
-										DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[0]->diepctl,
-														diepctl0.d32);
+											dwc_udelay
+											    (10);
+											diepint.d32
+											    =
+											    DWC_READ_REG32
+											    (&core_if->dev_if->
+											     in_ep_regs
+											     [0]->diepint);
+										} while (!diepint.b.inepnakeff);
+										diepint.b.inepnakeff
+										    =
+										    1;
+										DWC_WRITE_REG32
+										    (&core_if->dev_if->
+										     in_ep_regs
+										     [0]->diepint,
+										     diepint.d32);
+										diepctl0.d32
+										    =
+										    0;
+										diepctl0.b.epdis
+										    =
+										    1;
+										DWC_WRITE_REG32
+										    (&core_if->dev_if->in_ep_regs
+										     [0]->diepctl,
+										     diepctl0.d32);
 										do {
-											dwc_udelay(10);
-											diepint.d32 = DWC_READ_REG32(&core_if->dev_if->
-												in_ep_regs[0]->diepint);
-										} while (!diepint.b.epdisabled); 
-										diepint.b.epdisabled = 1;
-										DWC_WRITE_REG32(&core_if->dev_if->in_ep_regs[0]->diepint,
-															diepint.d32);
+											dwc_udelay
+											    (10);
+											diepint.d32
+											    =
+											    DWC_READ_REG32
+											    (&core_if->dev_if->
+											     in_ep_regs
+											     [0]->diepint);
+										} while (!diepint.b.epdisabled);
+										diepint.b.epdisabled
+										    =
+										    1;
+										DWC_WRITE_REG32
+										    (&core_if->dev_if->in_ep_regs
+										     [0]->diepint,
+										     diepint.d32);
 									}
 								}
-								doepint_temp.d32 = DWC_READ_REG32(&core_if->dev_if->
-																out_ep_regs[ep->dwc_ep.num]->doepint);
+								doepint_temp.d32
+								    =
+								    DWC_READ_REG32
+								    (&core_if->dev_if->
+								     out_ep_regs
+								     [ep->dwc_ep.num]->doepint);
 								if (doepint_temp.b.sr) {
-									CLEAR_OUT_EP_INTR(core_if, epnum, sr);
+									CLEAR_OUT_EP_INTR
+									    (core_if,
+									     epnum,
+									     sr);
 									if (DWC_CIRCLEQ_EMPTY(&ep->queue)) {
-										DWC_DEBUGPL(DBG_PCDV, "Request queue empty!!\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "Request queue empty!!\n");
 									} else {
-										DWC_DEBUGPL(DBG_PCDV, "complete req!!\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "complete req!!\n");
 										req = DWC_CIRCLEQ_FIRST(&ep->queue);
-										if (ep->dwc_ep.xfer_count != ep->dwc_ep.total_len &&
-											pcd->ep0state == EP0_OUT_DATA_PHASE) {
-												/* Read arrived setup packet from req->buf */
-												dwc_memcpy(&pcd->setup_pkt->req, 
-													req->buf + ep->dwc_ep.xfer_count, 8);
+										if (ep->dwc_ep.xfer_count != ep->dwc_ep.total_len && pcd->ep0state == EP0_OUT_DATA_PHASE) {
+											/* Read arrived setup packet from req->buf */
+											dwc_memcpy
+											    (&pcd->setup_pkt->req,
+											     req->buf
+											     +
+											     ep->dwc_ep.xfer_count,
+											     8);
 										}
-										req->actual = ep->dwc_ep.xfer_count;
-										dwc_otg_request_done(ep, req, -ECONNRESET);
+										req->actual
+										    =
+										    ep->dwc_ep.xfer_count;
+										dwc_otg_request_done
+										    (ep,
+										     req,
+										     -ECONNRESET);
 										ep->dwc_ep.start_xfer_buff = 0;
 										ep->dwc_ep.xfer_buff = 0;
 										ep->dwc_ep.xfer_len = 0;
 									}
-									pcd->ep0state = EP0_IDLE;
+									pcd->ep0state
+									    =
+									    EP0_IDLE;
 									if (doepint.b.setup) {
-										DWC_DEBUGPL(DBG_PCDV, "EP0_IDLE SR=1 setup=1\n");
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "EP0_IDLE SR=1 setup=1\n");
 										/* Data stage started, clear setup */
-										CLEAR_OUT_EP_INTR(core_if, epnum, setup);
-										doepint.b.setup = 0;
-										handle_ep0(pcd);
-										/* Prepare for setup packets if ep0in was enabled*/
+										CLEAR_OUT_EP_INTR
+										    (core_if,
+										     epnum,
+										     setup);
+										doepint.b.setup
+										    =
+										    0;
+										handle_ep0
+										    (pcd);
+										/* Prepare for setup packets if ep0in was enabled */
 										if (pcd->ep0state == EP0_IN_STATUS_PHASE) {
-											depctl_data_t depctl = {.d32 = 0};
-											depctl.b.cnak = 1;
-											ep0_out_start(core_if, pcd);
-											/* Core not updating setup packet count 
-											* in case of PET testing - @TODO vahrama
-											* to check with HW team further */
+											depctl_data_t
+											    depctl
+											    = {
+											.d32 = 0};
+											depctl.b.cnak
+											    =
+											    1;
+											ep0_out_start
+											    (core_if,
+											     pcd);
+											/* Core not updating setup packet count
+											 * in case of PET testing - @TODO vahrama
+											 * to check with HW team further */
 											if (!core_if->otg_ver) {
-												DWC_MODIFY_REG32(&core_if->dev_if->
-														out_ep_regs[0]->doepctl, 0, depctl.d32);
+												DWC_MODIFY_REG32
+												    (&core_if->dev_if->
+												     out_ep_regs
+												     [0]->doepctl,
+												     0,
+												     depctl.d32);
 											}
 										}
 										goto exit_xfercompl;
 									} else {
 										/* Prepare for more setup packets */
-										DWC_DEBUGPL(DBG_PCDV, 
-											"EP0_IDLE SR=1 setup=0 new setup comes 2\n");
-										ep0_out_start(core_if, pcd);
+										DWC_DEBUGPL
+										    (DBG_PCDV,
+										     "EP0_IDLE SR=1 setup=0 new setup comes 2\n");
+										ep0_out_start
+										    (core_if,
+										     pcd);
 									}
 								}
 							}
-						} 
-						if (core_if->dma_enable == 0 || pcd->ep0state != EP0_IDLE)
+						}
+						if (core_if->dma_enable == 0
+						    || pcd->ep0state !=
+						    EP0_IDLE)
 							handle_ep0(pcd);
 exit_xfercompl:
-						DWC_DEBUGPL(DBG_PCDV, "after DOEPINT=%x doepint=%x\n", 
-							dwc_otg_read_dev_out_ep_intr(core_if, dwc_ep), doepint.d32);
+						DWC_DEBUGPL(DBG_PCDV,
+							    "after DOEPINT=%x doepint=%x\n",
+							    dwc_otg_read_dev_out_ep_intr
+							    (core_if, dwc_ep),
+							    doepint.d32);
 					} else {
-						if (core_if->dma_desc_enable == 0
-							|| pcd->ep0state != EP0_IDLE)
+						if (core_if->dma_desc_enable ==
+						    0
+						    || pcd->ep0state !=
+						    EP0_IDLE)
 							handle_ep0(pcd);
 					}
 #ifdef DWC_EN_ISOC
@@ -4500,11 +4877,13 @@ do { \
 						complete_iso_ep(pcd, ep);
 					} else {
 
-						doepint_data_t doepint = {.d32 = 0 };
+						doepint_data_t doepint = {
+						.d32 = 0};
 						doepint.b.xfercompl = 1;
 						doepint.b.pktdrpsts = 1;
 						DWC_WRITE_REG32
-						    (&core_if->dev_if->out_ep_regs
+						    (&core_if->
+						     dev_if->out_ep_regs
 						     [epnum]->doepint,
 						     doepint.d32);
 						if (handle_iso_out_pkt_dropped
@@ -4516,7 +4895,8 @@ do { \
 #endif /* DWC_EN_ISOC */
 #ifdef DWC_UTE_PER_IO
 				} else if (dwc_ep->type == DWC_OTG_EP_TYPE_ISOC) {
-					CLEAR_OUT_EP_INTR(core_if, epnum, xfercompl);
+					CLEAR_OUT_EP_INTR(core_if, epnum,
+							  xfercompl);
 					if (!ep->stopped)
 						complete_xiso_ep(ep);
 #endif /* DWC_UTE_PER_IO */
@@ -4526,13 +4906,18 @@ do { \
 							  xfercompl);
 
 					if (core_if->core_params->dev_out_nak) {
-						DWC_TIMER_CANCEL(pcd->core_if->ep_xfer_timer[epnum]);
-						pcd->core_if->ep_xfer_info[epnum].state = 0;
+						DWC_TIMER_CANCEL(pcd->
+								 core_if->ep_xfer_timer
+								 [epnum]);
+						pcd->
+						    core_if->ep_xfer_info
+						    [epnum].state = 0;
 #ifdef DEBUG
-						print_memory_payload(pcd, dwc_ep);
+						print_memory_payload(pcd,
+								     dwc_ep);
 #endif
 					}
-					complete_ep(ep);						
+					complete_ep(ep);
 				}
 
 			}
@@ -4541,14 +4926,16 @@ do { \
 				deptsiz0_data_t deptsiz;
 				CLEAR_OUT_EP_INTR(core_if, epnum, stsphsercvd);
 				deptsiz.d32 =
-					DWC_READ_REG32(&core_if->dev_if->
-					out_ep_regs[0]->doeptsiz);
-				if ((core_if->dma_desc_enable) || (core_if->dma_enable &&
-					core_if->snpsid >= OTG_CORE_REV_3_00a)) {
-						do_setup_in_status_phase(pcd);
+				    DWC_READ_REG32(&core_if->dev_if->
+						   out_ep_regs[0]->doeptsiz);
+				if ((core_if->dma_desc_enable)
+				    || (core_if->dma_enable
+					&& core_if->snpsid >=
+					OTG_CORE_REV_3_00a)) {
+					do_setup_in_status_phase(pcd);
 				}
 			}
-		   
+
 			/* Endpoint disable      */
 			if (doepint.b.epdisabled) {
 
@@ -4559,47 +4946,62 @@ do { \
 					print_memory_payload(pcd, dwc_ep);
 #endif
 					/* In case of timeout condition */
-					if (core_if->ep_xfer_info[epnum].state == 2) {
-						dctl.d32 = DWC_READ_REG32(&core_if->dev_if->
-										dev_global_regs->dctl);
+					if (core_if->
+					    ep_xfer_info[epnum].state == 2) {
+						dctl.d32 =
+						    DWC_READ_REG32
+						    (&core_if->dev_if->
+						     dev_global_regs->dctl);
 						dctl.b.cgoutnak = 1;
-						DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
-																dctl.d32);
+						DWC_WRITE_REG32
+						    (&core_if->dev_if->dev_global_regs->dctl,
+						     dctl.d32);
 						/* Unmask goutnakeff interrupt which was masked
 						 * during handle nak out interrupt */
 						gintmsk.b.goutnakeff = 1;
-						DWC_MODIFY_REG32(&core_if->core_global_regs->gintmsk,
-																0, gintmsk.d32);
-					
+						DWC_MODIFY_REG32
+						    (&core_if->core_global_regs->gintmsk,
+						     0, gintmsk.d32);
+
 						complete_ep(ep);
 					}
 				}
-				if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC)
-				{
+				if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
 					dctl_data_t dctl;
-					gintmsk_data_t intr_mask = {.d32 = 0};
+					gintmsk_data_t intr_mask = {
+					.d32 = 0};
 					dwc_otg_pcd_request_t *req = 0;
 
-					dctl.d32 = DWC_READ_REG32(&core_if->dev_if->
-						dev_global_regs->dctl);
+					dctl.d32 =
+					    DWC_READ_REG32(&core_if->dev_if->
+							   dev_global_regs->dctl);
 					dctl.b.cgoutnak = 1;
-					DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
-						dctl.d32);
+					DWC_WRITE_REG32(&core_if->
+							dev_if->dev_global_regs->
+							dctl, dctl.d32);
 
 					intr_mask.d32 = 0;
 					intr_mask.b.incomplisoout = 1;
 
 					/* Get any pending requests */
 					if (!DWC_CIRCLEQ_EMPTY(&ep->queue)) {
-						req = DWC_CIRCLEQ_FIRST(&ep->queue);
+						req =
+						    DWC_CIRCLEQ_FIRST
+						    (&ep->queue);
 						if (!req) {
-							DWC_PRINTF("complete_ep 0x%p, req = NULL!\n", ep);
+							DWC_PRINTF
+							    ("complete_ep 0x%p, req = NULL!\n",
+							     ep);
 						} else {
-							dwc_otg_request_done(ep, req, 0);
+							dwc_otg_request_done(ep,
+									     req,
+									     0);
 							start_next_request(ep);
 						}
 					} else {
-						DWC_PRINTF("complete_ep 0x%p, ep->queue empty!\n", ep);
+						DWC_PRINTF
+						    ("complete_ep 0x%p, ep->queue empty!\n",
+						     ep);
 					}
 				}
 			}
@@ -4607,13 +5009,16 @@ do { \
 			if (doepint.b.ahberr) {
 				DWC_ERROR("EP%d OUT AHB Error\n", epnum);
 				DWC_ERROR("EP%d DEPDMA=0x%08x \n",
-					  epnum, core_if->dev_if->out_ep_regs[epnum]->doepdma);
+					  epnum,
+					  core_if->dev_if->
+					  out_ep_regs[epnum]->doepdma);
 				CLEAR_OUT_EP_INTR(core_if, epnum, ahberr);
 			}
 			/* Setup Phase Done (contorl EPs) */
 			if (doepint.b.setup) {
 #ifdef DEBUG_EP0
-				DWC_DEBUGPL(DBG_PCD, "EP%d SETUP Done\n", epnum);
+				DWC_DEBUGPL(DBG_PCD, "EP%d SETUP Done\n",
+					    epnum);
 #endif
 				CLEAR_OUT_EP_INTR(core_if, epnum, setup);
 
@@ -4633,11 +5038,13 @@ do { \
 						 */
 						if (dwc_ep->next_frame !=
 						    0xffffffff)
-							dwc_otg_pcd_handle_iso_bna(ep);
+							dwc_otg_pcd_handle_iso_bna
+							    (ep);
 					} else
-#endif				/* DWC_EN_ISOC */
+#endif /* DWC_EN_ISOC */
 					{
-						dwc_otg_pcd_handle_noniso_bna(ep);
+						dwc_otg_pcd_handle_noniso_bna
+						    (ep);
 					}
 				}
 			}
@@ -4651,14 +5058,20 @@ do { \
 			}
 			if (doepint.b.outtknepdis) {
 				DWC_DEBUGPL(DBG_ANY, "EP%d OUT Token received when EP is \
-					disabled\n",epnum);
+					disabled\n",
+					    epnum);
 				if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
-					doepmsk_data_t doepmsk = {.d32 = 0};
-					ep->dwc_ep.frame_num = core_if->frame_num;
+					doepmsk_data_t doepmsk = {
+					.d32 = 0};
+					ep->dwc_ep.frame_num =
+					    core_if->frame_num;
 					if (ep->dwc_ep.bInterval > 1) {
 						depctl_data_t depctl;
-						depctl.d32 = DWC_READ_REG32(&core_if->dev_if->
-													out_ep_regs[epnum]->doepctl);
+						depctl.d32 =
+						    DWC_READ_REG32
+						    (&core_if->dev_if->
+						     out_ep_regs
+						     [epnum]->doepctl);
 						if (ep->dwc_ep.frame_num & 0x1) {
 							depctl.b.setd1pid = 1;
 							depctl.b.setd0pid = 0;
@@ -4666,13 +5079,17 @@ do { \
 							depctl.b.setd0pid = 1;
 							depctl.b.setd1pid = 0;
 						}
-						DWC_WRITE_REG32(&core_if->dev_if->
-										out_ep_regs[epnum]->doepctl, depctl.d32);
+						DWC_WRITE_REG32
+						    (&core_if->dev_if->
+						     out_ep_regs
+						     [epnum]->doepctl,
+						     depctl.d32);
 					}
 					start_next_request(ep);
 					doepmsk.b.outtknepdis = 1;
-					DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->doepmsk, 
-								 doepmsk.d32, 0);
+					DWC_MODIFY_REG32(&core_if->
+							 dev_if->dev_global_regs->doepmsk,
+							 doepmsk.d32, 0);
 				}
 				CLEAR_OUT_EP_INTR(core_if, epnum, outtknepdis);
 			}
@@ -4701,10 +5118,12 @@ do { \
 
 #undef CLEAR_OUT_EP_INTR
 }
-static int drop_transfer(uint32_t trgt_fr, uint32_t curr_fr, uint8_t frm_overrun)
+
+static int drop_transfer(uint32_t trgt_fr, uint32_t curr_fr,
+			 uint8_t frm_overrun)
 {
 	int retval = 0;
-	if(!frm_overrun && curr_fr >= trgt_fr) 
+	if (!frm_overrun && curr_fr >= trgt_fr)
 		retval = 1;
 	else if (frm_overrun
 		 && (curr_fr >= trgt_fr && ((curr_fr - trgt_fr) < 0x3FFF / 2)))
@@ -4724,15 +5143,18 @@ static int drop_transfer(uint32_t trgt_fr, uint32_t curr_fr, uint8_t frm_overrun
  *	-#	Disable EP; when "Endpoint Disabled" interrupt is received
  *		Flush FIFO
  */
-int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t *pcd)
 {
 	gintsts_data_t gintsts;
 
 #ifdef DWC_EN_ISOC
 	dwc_otg_dev_if_t *dev_if;
-	deptsiz_data_t deptsiz = {.d32 = 0 };
-	depctl_data_t depctl = {.d32 = 0 };
-	dsts_data_t dsts = {.d32 = 0 };
+	deptsiz_data_t deptsiz = {
+	.d32 = 0};
+	depctl_data_t depctl = {
+	.d32 = 0};
+	dsts_data_t dsts = {
+	.d32 = 0};
 	dwc_ep_t *dwc_ep;
 	int i;
 
@@ -4780,27 +5202,30 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t * pcd)
 	}
 
 #else
-	depctl_data_t depctl = {.d32 = 0 };
+	depctl_data_t depctl = {
+	.d32 = 0};
 	dwc_ep_t *dwc_ep;
 	dwc_otg_dev_if_t *dev_if;
 	int i;
 	dev_if = GET_CORE_IF(pcd)->dev_if;
 
-	DWC_DEBUGPL(DBG_PCD,"Incomplete ISO IN \n");
-	
+	DWC_DEBUGPL(DBG_PCD, "Incomplete ISO IN \n");
+
 	for (i = 1; i <= dev_if->num_in_eps; ++i) {
-		dwc_ep = &pcd->in_ep[i-1].dwc_ep;
-		depctl.d32 =
-			DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
+		dwc_ep = &pcd->in_ep[i - 1].dwc_ep;
+		depctl.d32 = DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
 		if (depctl.b.epena && dwc_ep->type == DWC_OTG_EP_TYPE_ISOC) {
-			if (drop_transfer(dwc_ep->frame_num, GET_CORE_IF(pcd)->frame_num, 
-							dwc_ep->frm_overrun))
-			{
+			if (drop_transfer
+			    (dwc_ep->frame_num, GET_CORE_IF(pcd)->frame_num,
+			     dwc_ep->frm_overrun)) {
 				depctl.d32 =
-					DWC_READ_REG32(&dev_if->in_ep_regs[i]->diepctl);
+				    DWC_READ_REG32(&dev_if->
+						   in_ep_regs[i]->diepctl);
 				depctl.b.snak = 1;
 				depctl.b.epdis = 1;
-				DWC_MODIFY_REG32(&dev_if->in_ep_regs[i]->diepctl, depctl.d32, depctl.d32);
+				DWC_MODIFY_REG32(&dev_if->
+						 in_ep_regs[i]->diepctl,
+						 depctl.d32, depctl.d32);
 			}
 		}
 	}
@@ -4808,7 +5233,7 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t * pcd)
 	/*intr_mask.b.incomplisoin = 1;
 	   DWC_MODIFY_REG32(&GET_CORE_IF(pcd)->core_global_regs->gintmsk,
 	   intr_mask.d32, 0);    */
-#endif //DWC_EN_ISOC
+#endif /* DWC_EN_ISOC */
 
 	/* Clear interrupt */
 	gintsts.d32 = 0;
@@ -4834,16 +5259,19 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t * pcd)
  *	-#	Disable EP. When "Endpoint Disabled" interrupt is received
  *		re-enable EP.
  */
-int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t *pcd)
 {
 
 	gintsts_data_t gintsts;
 
 #ifdef DWC_EN_ISOC
 	dwc_otg_dev_if_t *dev_if;
-	deptsiz_data_t deptsiz = {.d32 = 0 };
-	depctl_data_t depctl = {.d32 = 0 };
-	dsts_data_t dsts = {.d32 = 0 };
+	deptsiz_data_t deptsiz = {
+	.d32 = 0};
+	depctl_data_t depctl = {
+	.d32 = 0};
+	dsts_data_t dsts = {
+	.d32 = 0};
 	dwc_ep_t *dwc_ep;
 	int i;
 
@@ -4893,11 +5321,15 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t * pcd)
 	}
 #else
 	/** @todo implement ISR */
-	gintmsk_data_t intr_mask = {.d32 = 0 };
+	gintmsk_data_t intr_mask = {
+	.d32 = 0};
 	dwc_otg_core_if_t *core_if;
-	deptsiz_data_t deptsiz = {.d32 = 0 };
-	depctl_data_t depctl = {.d32 = 0 };
-	dctl_data_t dctl = {.d32 = 0 };
+	deptsiz_data_t deptsiz = {
+	.d32 = 0};
+	depctl_data_t depctl = {
+	.d32 = 0};
+	dctl_data_t dctl = {
+	.d32 = 0};
 	dwc_ep_t *dwc_ep = NULL;
 	int i;
 	core_if = GET_CORE_IF(pcd);
@@ -4905,12 +5337,16 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t * pcd)
 	for (i = 0; i < core_if->dev_if->num_out_eps; ++i) {
 		dwc_ep = &pcd->out_ep[i].dwc_ep;
 		depctl.d32 =
-			DWC_READ_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doepctl);
-		if (depctl.b.epena && depctl.b.dpid == (core_if->frame_num & 0x1)) {
-			core_if->dev_if->isoc_ep = dwc_ep;	
+		    DWC_READ_REG32(&core_if->dev_if->
+				   out_ep_regs[dwc_ep->num]->doepctl);
+		if (depctl.b.epena
+		    && depctl.b.dpid == (core_if->frame_num & 0x1)) {
+			core_if->dev_if->isoc_ep = dwc_ep;
 			deptsiz.d32 =
-					DWC_READ_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doeptsiz);
-				break;
+			    DWC_READ_REG32(&core_if->
+					   dev_if->out_ep_regs[dwc_ep->num]->
+					   doeptsiz);
+			break;
 		}
 	}
 	dctl.d32 = DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
@@ -4920,23 +5356,26 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t * pcd)
 	if (!intr_mask.b.goutnakeff) {
 		/* Unmask it */
 		intr_mask.b.goutnakeff = 1;
-		DWC_WRITE_REG32(&core_if->core_global_regs->gintmsk, intr_mask.d32);
- 	}
+		DWC_WRITE_REG32(&core_if->core_global_regs->gintmsk,
+				intr_mask.d32);
+	}
 	if (!gintsts.b.goutnakeff) {
 		dctl.b.sgoutnak = 1;
 	}
 	DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl, dctl.d32);
 
-	depctl.d32 = DWC_READ_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doepctl);
+	depctl.d32 =
+	    DWC_READ_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doepctl);
 	if (depctl.b.epena) {
 		depctl.b.epdis = 1;
 		depctl.b.snak = 1;
 	}
-	DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doepctl, depctl.d32);
+	DWC_WRITE_REG32(&core_if->dev_if->out_ep_regs[dwc_ep->num]->doepctl,
+			depctl.d32);
 
 	intr_mask.d32 = 0;
 	intr_mask.b.incomplisoout = 1;
-		
+
 #endif /* DWC_EN_ISOC */
 
 	/* Clear interrupt */
@@ -4952,11 +5391,13 @@ int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t * pcd)
  * This function handles the Global IN NAK Effective interrupt.
  *
  */
-int32_t dwc_otg_pcd_handle_in_nak_effective(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_in_nak_effective(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(pcd)->dev_if;
-	depctl_data_t diepctl = {.d32 = 0 };
-	gintmsk_data_t intr_mask = {.d32 = 0 };
+	depctl_data_t diepctl = {
+	.d32 = 0};
+	gintmsk_data_t intr_mask = {
+	.d32 = 0};
 	gintsts_data_t gintsts;
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 	int i;
@@ -4971,10 +5412,10 @@ int32_t dwc_otg_pcd_handle_in_nak_effective(dwc_otg_pcd_t * pcd)
 				core_if->start_predict++;
 			diepctl.b.epdis = 1;
 			diepctl.b.snak = 1;
-			DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl, diepctl.d32);
-		}						
+			DWC_WRITE_REG32(&dev_if->in_ep_regs[i]->diepctl,
+					diepctl.d32);
+		}
 	}
-	
 
 	/* Disable the Global IN NAK Effective Interrupt */
 	intr_mask.b.ginnakeff = 1;
@@ -4994,10 +5435,11 @@ int32_t dwc_otg_pcd_handle_in_nak_effective(dwc_otg_pcd_t * pcd)
  * OUT NAK Effective.
  *
  */
-int32_t dwc_otg_pcd_handle_out_nak_effective(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_out_nak_effective(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(pcd)->dev_if;
-	gintmsk_data_t intr_mask = {.d32 = 0 };
+	gintmsk_data_t intr_mask = {
+	.d32 = 0};
 	gintsts_data_t gintsts;
 	depctl_data_t doepctl;
 	int i;
@@ -5010,7 +5452,7 @@ int32_t dwc_otg_pcd_handle_out_nak_effective(dwc_otg_pcd_t * pcd)
 	/* If DEV OUT NAK enabled */
 	if (pcd->core_if->core_params->dev_out_nak) {
 		/* Run over all out endpoints to determine the ep number on
-		 * which the timeout has happened 
+		 * which the timeout has happened
 		 */
 		for (i = 0; i <= dev_if->num_out_eps; i++) {
 			if (pcd->core_if->ep_xfer_info[i].state == 2)
@@ -5079,7 +5521,7 @@ int32_t dwc_otg_pcd_handle_out_nak_effective(dwc_otg_pcd_t * pcd)
  * All interrupt registers are processed from LSB to MSB.
  *
  */
-int32_t dwc_otg_pcd_handle_intr(dwc_otg_pcd_t * pcd)
+int32_t dwc_otg_pcd_handle_intr(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
 #ifdef VERBOSE
@@ -5087,9 +5529,9 @@ int32_t dwc_otg_pcd_handle_intr(dwc_otg_pcd_t * pcd)
 #endif
 	gintsts_data_t gintr_status;
 	int32_t retval = 0;
-	
-	if (dwc_otg_check_haps_status(core_if) == -1 ) {
-		DWC_WARN("HAPS is disconnected");			
+
+	if (dwc_otg_check_haps_status(core_if) == -1) {
+		DWC_WARN("HAPS is disconnected");
 		return retval;
 	}
 
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_pcd_linux.c b/drivers/usb/dwc_otg_310/dwc_otg_pcd_linux.c
index 23bc90f0e509..4459547e82eb 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_pcd_linux.c
+++ b/drivers/usb/dwc_otg_310/dwc_otg_pcd_linux.c
@@ -74,13 +74,13 @@ static struct gadget_wrapper {
 } *gadget_wrapper;
 
 /* Display the contents of the buffer */
-extern void dump_msg(const u8 * buf, unsigned int length);
+extern void dump_msg(const u8 *buf, unsigned int length);
 
 /**
  * Get the dwc_otg_pcd_ep_t* from usb_ep* pointer - NULL in case
  * if the endpoint is not found
  */
-static struct dwc_otg_pcd_ep *ep_from_handle(dwc_otg_pcd_t * pcd, void *handle)
+static struct dwc_otg_pcd_ep *ep_from_handle(dwc_otg_pcd_t *pcd, void *handle)
 {
 	int i;
 	if (pcd->ep0.priv == handle) {
@@ -243,7 +243,7 @@ static void dwc_otg_pcd_free_request(struct usb_ep *ep, struct usb_request *req)
 	kfree(req);
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 /**
  * This function allocates an I/O buffer to be used for a transfer
  * to/from the specified endpoint.
@@ -255,7 +255,7 @@ static void dwc_otg_pcd_free_request(struct usb_ep *ep, struct usb_request *req)
  * @return address of a new buffer or null is buffer could not be allocated.
  */
 static void *dwc_otg_pcd_alloc_buffer(struct usb_ep *usb_ep, unsigned bytes,
-				      dma_addr_t * dma, gfp_t gfp_flags)
+				      dma_addr_t *dma, gfp_t gfp_flags)
 {
 	void *buf;
 	dwc_otg_pcd_t *pcd = 0;
@@ -358,17 +358,18 @@ static int ep_queue(struct usb_ep *usb_ep, struct usb_request *usb_req,
 		is_isoc_ep = 0;
 	else
 		is_isoc_ep = (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) ? 1 : 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 	dma_addr = usb_req->dma;
 #else
 	if (GET_CORE_IF(pcd)->dma_enable) {
-//		if (usb_req->length != 0/* && usb_req->dma == DWC_DMA_ADDR_INVALID*/) {
-		if(usb_req->dma == DWC_DMA_ADDR_INVALID){
-			dma_addr = dma_map_single(gadget_wrapper->gadget.dev.parent,
-				 		  usb_req->buf, usb_req->length,
-						  ep->dwc_ep.is_in 
-						  ? DMA_TO_DEVICE 
-						  : DMA_FROM_DEVICE);
+		/* if (usb_req->length != 0) {*/
+		if (usb_req->dma == DWC_DMA_ADDR_INVALID) {
+			dma_addr =
+			    dma_map_single(gadget_wrapper->gadget.dev.parent,
+					   usb_req->buf, usb_req->length,
+					   ep->dwc_ep.
+					   is_in ? DMA_TO_DEVICE :
+					   DMA_FROM_DEVICE);
 			usb_req->dma = dma_addr;
 		}
 
@@ -459,7 +460,7 @@ static int ep_halt(struct usb_ep *usb_ep, int value)
 	return retval;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 static int ep_wedge(struct usb_ep *usb_ep)
 {
 	DWC_DEBUGPL(DBG_PCD, "WEDGE %s\n", usb_ep->name);
@@ -500,8 +501,7 @@ static int iso_ep_start(struct usb_ep *usb_ep, struct usb_iso_request *req,
 				     req->buf1, req->dma0, req->dma1,
 				     req->sync_frame, req->data_pattern_frame,
 				     req->data_per_frame,
-				     req->
-				     flags & USB_REQ_ISO_ASAP ? -1 :
+				     req->flags & USB_REQ_ISO_ASAP ? -1 :
 				     req->start_frame, req->buf_proc_intrvl,
 				     req, gfp_flags == GFP_ATOMIC ? 1 : 0);
 
@@ -566,28 +566,28 @@ static void free_iso_request(struct usb_ep *ep, struct usb_iso_request *req)
 
 static struct usb_isoc_ep_ops dwc_otg_pcd_ep_ops = {
 	.ep_ops = {
-		.enable = ep_enable,
-		.disable = ep_disable,
+		   .enable = ep_enable,
+		   .disable = ep_disable,
 
-		.alloc_request = dwc_otg_pcd_alloc_request,
-		.free_request = dwc_otg_pcd_free_request,
+		   .alloc_request = dwc_otg_pcd_alloc_request,
+		   .free_request = dwc_otg_pcd_free_request,
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
-		.alloc_buffer = dwc_otg_pcd_alloc_buffer,
-		.free_buffer = dwc_otg_pcd_free_buffer,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
+		   .alloc_buffer = dwc_otg_pcd_alloc_buffer,
+		   .free_buffer = dwc_otg_pcd_free_buffer,
 #endif
 
-		.queue = ep_queue,
-		.dequeue = ep_dequeue,
+		   .queue = ep_queue,
+		   .dequeue = ep_dequeue,
 
-		.set_halt = ep_halt,
-		 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
-		.set_wedge = ep_wedge,
+		   .set_halt = ep_halt,
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+		   .set_wedge = ep_wedge,
 #endif
-		.fifo_status = 0,
-		.fifo_flush = 0,
-	},
+		   .fifo_status = 0,
+		   .fifo_flush = 0,
+		   },
 
 	.iso_ep_start = iso_ep_start,
 	.iso_ep_stop = iso_ep_stop,
@@ -604,7 +604,7 @@ static struct usb_ep_ops dwc_otg_pcd_ep_ops = {
 	.alloc_request = dwc_otg_pcd_alloc_request,
 	.free_request = dwc_otg_pcd_free_request,
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
 	.alloc_buffer = dwc_otg_pcd_alloc_buffer,
 	.free_buffer = dwc_otg_pcd_free_buffer,
 #endif
@@ -613,10 +613,10 @@ static struct usb_ep_ops dwc_otg_pcd_ep_ops = {
 	.dequeue = ep_dequeue,
 
 	.set_halt = ep_halt,
-	
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
-		.set_wedge = ep_wedge,
-    #endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	.set_wedge = ep_wedge,
+#endif
 
 	.fifo_status = 0,
 	.fifo_flush = 0,
@@ -666,7 +666,8 @@ static int test_lpm_enabled(struct usb_gadget *gadget)
 
 	return dwc_otg_pcd_is_lpm_enabled(d->pcd);
 }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 static int test_besl_enabled(struct usb_gadget *gadget)
 {
 	struct gadget_wrapper *d;
@@ -675,6 +676,7 @@ static int test_besl_enabled(struct usb_gadget *gadget)
 
 	return dwc_otg_pcd_is_besl_enabled(d->pcd);
 }
+
 static int get_param_baseline_besl(struct usb_gadget *gadget)
 {
 	struct gadget_wrapper *d;
@@ -683,6 +685,7 @@ static int get_param_baseline_besl(struct usb_gadget *gadget)
 
 	return dwc_otg_pcd_get_param_baseline_besl(d->pcd);
 }
+
 static int get_param_deep_besl(struct usb_gadget *gadget)
 {
 	struct gadget_wrapper *d;
@@ -714,26 +717,27 @@ static int wakeup(struct usb_gadget *gadget)
 	dwc_otg_pcd_wakeup(d->pcd);
 	return 0;
 }
+
 static int dwc_otg_pcd_pullup(struct usb_gadget *_gadget, int is_on)
 {
 	struct gadget_wrapper *d;
 	dwc_otg_pcd_t *pcd;
 	dwc_otg_core_if_t *core_if;
-	
-	printk( "pcd_pullup, is_on %d\n",is_on);
+
+	printk("pcd_pullup, is_on %d\n", is_on);
 	if (_gadget == NULL)
 		return -ENODEV;
-	else{
+	else {
 		d = container_of(_gadget, struct gadget_wrapper, gadget);
 		pcd = d->pcd;
 		core_if = GET_CORE_IF(d->pcd);
 	}
 
-	if(is_on){
-		//dwc_otg_pcd_pullup_enable(pcd);
+	if (is_on) {
+		/* dwc_otg_pcd_pullup_enable(pcd); */
 		pcd->conn_en = 1;
 		pcd->conn_status = 0;
-	}else{
+	} else {
 		dwc_otg_pcd_pullup_disable(pcd);
 		pcd->conn_status = 2;
 	}
@@ -745,12 +749,13 @@ static int dwc_otg_pcd_pullup(struct usb_gadget *_gadget, int is_on)
 static int dwc_otg_gadget_start(struct usb_gadget *g,
 				struct usb_gadget_driver *driver)
 {
-	DWC_DEBUGPL(DBG_PCD, "registering gadget driver '%s'\n", driver->driver.name);
-	if (gadget_wrapper == 0){
+	DWC_DEBUGPL(DBG_PCD, "registering gadget driver '%s'\n",
+		    driver->driver.name);
+	if (gadget_wrapper == 0) {
 		DWC_ERROR("ENODEV\n");
 		return -ENODEV;
 	}
-	if (gadget_wrapper->driver != 0){
+	if (gadget_wrapper->driver != 0) {
 		DWC_ERROR("EBUSY (%p)\n", gadget_wrapper->driver);
 		return -EBUSY;
 	}
@@ -775,21 +780,19 @@ static const struct usb_gadget_ops dwc_otg_pcd_ops = {
 	.pullup = dwc_otg_pcd_pullup,
 #ifdef CONFIG_USB_DWC_OTG_LPM
 	.lpm_support = test_lpm_enabled,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 	.besl_support = test_besl_enabled,
 	.get_baseline_besl = get_param_baseline_besl,
 	.get_deep_besl = get_param_deep_besl,
-#endif	
+#endif
 #endif
 	.udc_start = dwc_otg_gadget_start,
 	.udc_stop = dwc_otg_gadget_stop,
 
-	// current versions must always be self-powered
+	/* current versions must always be self-powered */
 };
 
-
-
-static int _setup(dwc_otg_pcd_t * pcd, uint8_t * bytes)
+static int _setup(dwc_otg_pcd_t *pcd, uint8_t *bytes)
 {
 	int retval = -DWC_E_NOT_SUPPORTED;
 	if (gadget_wrapper->driver && gadget_wrapper->driver->setup) {
@@ -808,7 +811,7 @@ static int _setup(dwc_otg_pcd_t * pcd, uint8_t * bytes)
 }
 
 #ifdef DWC_EN_ISOC
-static int _isoc_complete(dwc_otg_pcd_t * pcd, void *ep_handle,
+static int _isoc_complete(dwc_otg_pcd_t *pcd, void *ep_handle,
 			  void *req_handle, int proc_buf_num)
 {
 	int i, packet_count;
@@ -863,7 +866,7 @@ static int _isoc_complete(dwc_otg_pcd_t * pcd, void *ep_handle,
  *						created in the the portable part that contains the
  *						results of the processed iso packets.
  */
-static int _xisoc_complete(dwc_otg_pcd_t * pcd, void *ep_handle,
+static int _xisoc_complete(dwc_otg_pcd_t *pcd, void *ep_handle,
 			   void *req_handle, int32_t status, void *ereq_port)
 {
 	struct dwc_ute_iso_req_ext *ereqorg = NULL;
@@ -871,8 +874,8 @@ static int _xisoc_complete(dwc_otg_pcd_t * pcd, void *ep_handle,
 	struct dwc_ute_iso_packet_descriptor *desc_org = NULL;
 	int i;
 	struct usb_request *req;
-	//struct dwc_ute_iso_packet_descriptor *
-	//int status = 0;
+	/* struct dwc_ute_iso_packet_descriptor * */
+	/* int status = 0; */
 
 	req = (struct usb_request *)req_handle;
 	ereqorg = &req->ext_req;
@@ -913,12 +916,12 @@ static int _xisoc_complete(dwc_otg_pcd_t * pcd, void *ep_handle,
 }
 #endif /* DWC_UTE_PER_IO */
 
-static int _complete(dwc_otg_pcd_t * pcd, void *ep_handle,
+static int _complete(dwc_otg_pcd_t *pcd, void *ep_handle,
 		     void *req_handle, int32_t status, uint32_t actual)
 {
 	struct usb_request *req = (struct usb_request *)req_handle;
-	struct device * dev = NULL;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27)
+	struct device *dev = NULL;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27)
 	struct dwc_otg_pcd_ep *ep = NULL;
 #endif
 
@@ -946,31 +949,30 @@ static int _complete(dwc_otg_pcd_t * pcd, void *ep_handle,
 		req->complete(ep_handle, req);
 		DWC_SPINLOCK(pcd->lock);
 	}
-	
+
 	dev = &gadget_wrapper->pcd->otg_dev->os_dep.pdev->dev;
 	ep = ep_from_handle(pcd, ep_handle);
 
 	if (GET_CORE_IF(pcd)->dma_enable) {
-//		if (req->length != 0)
-		if(req->dma != DWC_DMA_ADDR_INVALID){
+		/* if (req->length != 0) */
+		if (req->dma != DWC_DMA_ADDR_INVALID) {
 			dma_unmap_single(gadget_wrapper->gadget.dev.parent,
 					 req->dma, req->length,
 					 ep->dwc_ep.is_in
-					 ? DMA_TO_DEVICE
-					 : DMA_FROM_DEVICE);
+					 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 			req->dma = DWC_DMA_ADDR_INVALID;
 		}
 	}
 	return 0;
 }
 
-static int _connect(dwc_otg_pcd_t * pcd, int speed)
+static int _connect(dwc_otg_pcd_t *pcd, int speed)
 {
 	gadget_wrapper->gadget.speed = speed;
 	return 0;
 }
 
-static int _disconnect(dwc_otg_pcd_t * pcd)
+static int _disconnect(dwc_otg_pcd_t *pcd)
 {
 	if (gadget_wrapper->driver && gadget_wrapper->driver->disconnect) {
 		gadget_wrapper->driver->disconnect(&gadget_wrapper->gadget);
@@ -978,7 +980,7 @@ static int _disconnect(dwc_otg_pcd_t * pcd)
 	return 0;
 }
 
-static int _resume(dwc_otg_pcd_t * pcd)
+static int _resume(dwc_otg_pcd_t *pcd)
 {
 	if (gadget_wrapper->driver && gadget_wrapper->driver->resume) {
 		gadget_wrapper->driver->resume(&gadget_wrapper->gadget);
@@ -987,7 +989,7 @@ static int _resume(dwc_otg_pcd_t * pcd)
 	return 0;
 }
 
-static int _suspend(dwc_otg_pcd_t * pcd)
+static int _suspend(dwc_otg_pcd_t *pcd)
 {
 	if (gadget_wrapper->driver && gadget_wrapper->driver->suspend) {
 		gadget_wrapper->driver->suspend(&gadget_wrapper->gadget);
@@ -998,7 +1000,7 @@ static int _suspend(dwc_otg_pcd_t * pcd)
 /**
  * This function updates the otg values in the gadget structure.
  */
-static int _hnp_changed(dwc_otg_pcd_t * pcd)
+static int _hnp_changed(dwc_otg_pcd_t *pcd)
 {
 
 	if (!gadget_wrapper->gadget.is_otg)
@@ -1010,20 +1012,22 @@ static int _hnp_changed(dwc_otg_pcd_t * pcd)
 	return 0;
 }
 
-static int _reset(dwc_otg_pcd_t * pcd)
+static int _reset(dwc_otg_pcd_t *pcd)
 {
 	return 0;
 }
 
 #ifdef DWC_UTE_CFI
-static int _cfi_setup(dwc_otg_pcd_t * pcd, void *cfi_req)
+static int _cfi_setup(dwc_otg_pcd_t *pcd, void *cfi_req)
 {
 	int retval = -DWC_E_INVALID;
 	if (gadget_wrapper->driver->cfi_feature_setup) {
 		retval =
-		    gadget_wrapper->driver->
-		    cfi_feature_setup(&gadget_wrapper->gadget,
-				      (struct cfi_usb_ctrlrequest *)cfi_req);
+		    gadget_wrapper->driver->cfi_feature_setup(&gadget_wrapper->
+							      gadget,
+							      (struct
+							       cfi_usb_ctrlrequest
+							       *)cfi_req);
 	}
 
 	return retval;
@@ -1060,7 +1064,7 @@ static irqreturn_t dwc_otg_pcd_irq(int irq, void *dev)
 
 	retval = dwc_otg_pcd_handle_intr(pcd);
 	if (retval != 0) {
-		//S3C2410X_CLEAR_EINTPEND();
+		/* S3C2410X_CLEAR_EINTPEND();*/
 	}
 	return IRQ_RETVAL(retval);
 }
@@ -1117,7 +1121,7 @@ void gadget_add_eps(struct gadget_wrapper *d)
 	INIT_LIST_HEAD(&d->gadget.ep_list);
 	d->gadget.ep0 = &d->ep0;
 	d->gadget.speed = USB_SPEED_UNKNOWN;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
 	d->gadget.max_speed = USB_SPEED_HIGH;
 #endif
 
@@ -1196,10 +1200,7 @@ static void dwc_otg_pcd_gadget_release(struct device *dev)
 	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, dev);
 }
 
-static struct gadget_wrapper *alloc_wrapper(
-
-	struct platform_device *_dev
-    )
+static struct gadget_wrapper *alloc_wrapper(struct platform_device *_dev)
 {
 	static char pcd_name[] = "dwc_otg_pcd";
 
@@ -1217,7 +1218,7 @@ static struct gadget_wrapper *alloc_wrapper(
 	d->gadget.name = pcd_name;
 	d->pcd = otg_dev->pcd;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
 	strcpy(d->gadget.dev.bus_id, "gadget");
 #else
 	dev_set_name(&d->gadget.dev, "%s", "gadget");
@@ -1226,7 +1227,7 @@ static struct gadget_wrapper *alloc_wrapper(
 	d->gadget.dev.parent = &_dev->dev;
 	d->gadget.dev.release = dwc_otg_pcd_gadget_release;
 	d->gadget.ops = &dwc_otg_pcd_ops;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0)
 	d->gadget.is_dualspeed = dwc_otg_pcd_is_dualspeed(otg_dev->pcd);
 #endif
 	d->gadget.is_otg = dwc_otg_pcd_is_otg(otg_dev->pcd);
@@ -1258,7 +1259,8 @@ static void free_wrapper(struct gadget_wrapper *d)
 	DWC_FREE(d);
 }
 
-static void dwc_otg_pcd_work_init(dwc_otg_pcd_t *pcd, struct platform_device *dev);
+static void dwc_otg_pcd_work_init(dwc_otg_pcd_t *pcd,
+				  struct platform_device *dev);
 
 /**
  * This function initialized the PCD portion of the driver.
@@ -1274,7 +1276,7 @@ int pcd_init(struct platform_device *_dev)
 	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _dev);
 
 	otg_dev->pcd = dwc_otg_pcd_init(otg_dev->core_if);
-	printk("pcd_init otg_dev = %p\n",otg_dev);
+	printk("pcd_init otg_dev = %p\n", otg_dev);
 
 	if (!otg_dev->pcd) {
 		DWC_ERROR("dwc_otg_pcd_init failed\n");
@@ -1291,10 +1293,10 @@ int pcd_init(struct platform_device *_dev)
 	/*
 	 * Setup interupt handler
 	 */
-	irq = platform_get_irq(_dev,0);
+	irq = platform_get_irq(_dev, 0);
 	DWC_DEBUGPL(DBG_ANY, "registering handler for irq%d\n", irq);
 	retval = request_irq(irq, dwc_otg_pcd_irq,
-			     IRQF_SHARED ,
+			     IRQF_SHARED,
 			     gadget_wrapper->gadget.name, otg_dev->pcd);
 	if (retval != 0) {
 		DWC_ERROR("request of irq%d failed\n", irq);
@@ -1312,10 +1314,7 @@ int pcd_init(struct platform_device *_dev)
 /**
  * Cleanup the PCD.
  */
-void pcd_remove(
-
-	struct platform_device *_dev
-    )
+void pcd_remove(struct platform_device *_dev)
 {
 
 	dwc_otg_device_t *otg_dev = dwc_get_device_platform_data(_dev);
@@ -1327,10 +1326,10 @@ void pcd_remove(
 	/*
 	 * Free the IRQ
 	 */
-	irq = platform_get_irq(_dev,0);
+	irq = platform_get_irq(_dev, 0);
 	free_irq(irq, pcd);
 	free_wrapper(gadget_wrapper);
-	dwc_otg_pcd_remove(otg_dev->pcd);	
+	dwc_otg_pcd_remove(otg_dev->pcd);
 	otg_dev->pcd = 0;
 }
 
@@ -1346,11 +1345,11 @@ void pcd_remove(
  * @param bind The bind function of gadget driver
  */
 #if 0
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
 int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 #else
 int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
-		int (*bind)(struct usb_gadget *))
+			    int (*bind) (struct usb_gadget *))
 #endif
 {
 	int retval;
@@ -1358,16 +1357,16 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
 	DWC_DEBUGPL(DBG_PCD, "registering gadget driver '%s'\n",
 		    driver->driver.name);
 
-	if (!driver || 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
-		driver->speed == USB_SPEED_UNKNOWN ||
+	if (!driver ||
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+	    driver->speed == USB_SPEED_UNKNOWN ||
 #else
-		driver->max_speed == USB_SPEED_UNKNOWN ||
+	    driver->max_speed == USB_SPEED_UNKNOWN ||
 #endif
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
 	    !driver->bind ||
 #else
-		!bind ||
+	    !bind ||
 #endif
 	    !driver->unbind || !driver->disconnect || !driver->setup) {
 		DWC_DEBUGPL(DBG_PCDV, "EINVAL\n");
@@ -1387,7 +1386,7 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
 	gadget_wrapper->gadget.dev.driver = &driver->driver;
 
 	DWC_DEBUGPL(DBG_PCD, "bind to driver %s\n", driver->driver.name);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
 	retval = driver->bind(&gadget_wrapper->gadget);
 #else
 	retval = bind(&gadget_wrapper->gadget);
@@ -1403,7 +1402,8 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
 		    driver->driver.name);
 	return 0;
 }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
 EXPORT_SYMBOL(usb_gadget_register_driver);
 #else
 EXPORT_SYMBOL(usb_gadget_probe_driver);
@@ -1416,7 +1416,7 @@ EXPORT_SYMBOL(usb_gadget_probe_driver);
  */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
-	//DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _driver);
+	/* DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _driver); */
 
 	if (gadget_wrapper == 0) {
 		DWC_DEBUGPL(DBG_ANY, "%s Return(%d): s_pcd==0\n", __func__,
@@ -1460,24 +1460,24 @@ void dwc_otg_msc_unlock(dwc_otg_pcd_t *pcd)
 
 unsigned int dwc_otg_battery_detect(bool det_type)
 {
-    printk("%s\n",__func__);
-    return 0;
+	printk("%s\n", __func__);
+	return 0;
 }
 
 static void dwc_phy_reconnect(struct work_struct *work)
 {
 	dwc_otg_pcd_t *pcd;
 	dwc_otg_core_if_t *core_if;
-	gotgctl_data_t    gctrl;
-	dctl_data_t dctl = {.d32=0};
+	gotgctl_data_t gctrl;
+	dctl_data_t dctl = {.d32 = 0 };
 	struct dwc_otg_platform_data *pldata;
 
 	pcd = container_of(work, dwc_otg_pcd_t, reconnect.work);
 	pldata = pcd->otg_dev->pldata;
 	core_if = GET_CORE_IF(pcd);
-	gctrl.d32 = DWC_READ_REG32( &core_if->core_global_regs->gotgctl );
+	gctrl.d32 = DWC_READ_REG32(&core_if->core_global_regs->gotgctl);
 
-	if(gctrl.b.bsesvld){
+	if (gctrl.b.bsesvld) {
 		pcd->conn_status++;
 		pldata->soft_reset();
 		dwc_pcd_reset(pcd);
@@ -1485,183 +1485,192 @@ static void dwc_phy_reconnect(struct work_struct *work)
 		 * Enable the global interrupt after all the interrupt
 		 * handlers are installed.
 		 */
-		dctl.d32 = DWC_READ_REG32( &core_if->dev_if->dev_global_regs->dctl );
+		dctl.d32 =
+		    DWC_READ_REG32(&core_if->dev_if->dev_global_regs->dctl);
 		dctl.b.sftdiscon = 0;
-		DWC_WRITE_REG32( &core_if->dev_if->dev_global_regs->dctl, dctl.d32 );
-		printk("*******************soft connect!!!*******************\n");
+		DWC_WRITE_REG32(&core_if->dev_if->dev_global_regs->dctl,
+				dctl.d32);
+		printk
+		    ("*******************soft connect!!!*******************\n");
 	}
 }
 
-static void dwc_otg_pcd_check_vbus_work( struct work_struct *work )
+static void dwc_otg_pcd_check_vbus_work(struct work_struct *work)
 {
-	dwc_otg_pcd_t * _pcd = container_of(work, dwc_otg_pcd_t, check_vbus_work.work);
-	struct dwc_otg_device* otg_dev = _pcd->otg_dev;
+	dwc_otg_pcd_t *_pcd =
+	    container_of(work, dwc_otg_pcd_t, check_vbus_work.work);
+	struct dwc_otg_device *otg_dev = _pcd->otg_dev;
 	struct dwc_otg_platform_data *pldata = otg_dev->pldata;
 	unsigned long flags;
 
 	local_irq_save(flags);
 
-	if(!pldata->get_status(USB_STATUS_ID)){
-		// id low, host mode
-		if( pldata->dwc_otg_uart_mode != NULL ){
-			//exit phy bypass to uart & enable usb phy
-			pldata->dwc_otg_uart_mode( pldata, PHY_USB_MODE);
+	if (!pldata->get_status(USB_STATUS_ID)) {
+		/* id low, host mode */
+		if (pldata->dwc_otg_uart_mode != NULL) {
+			/* exit phy bypass to uart & enable usb phy */
+			pldata->dwc_otg_uart_mode(pldata, PHY_USB_MODE);
 		}
-		if( pldata->phy_status){
-			pldata->clock_enable( pldata, 1);
+		if (pldata->phy_status) {
+			pldata->clock_enable(pldata, 1);
 			pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 		}
-		if( pldata->bc_detect_cb != NULL )
-            pldata->bc_detect_cb( _pcd->vbus_status = USB_BC_TYPE_DISCNT );
-        else
-            _pcd->vbus_status = USB_BC_TYPE_DISCNT;
-	    dwc_otg_enable_global_interrupts(otg_dev->core_if);
-
-	}else if(pldata->get_status(USB_STATUS_BVABLID)){
+		if (pldata->bc_detect_cb != NULL)
+			pldata->bc_detect_cb(_pcd->vbus_status =
+					     USB_BC_TYPE_DISCNT);
+		else
+			_pcd->vbus_status = USB_BC_TYPE_DISCNT;
+		dwc_otg_enable_global_interrupts(otg_dev->core_if);
+
+	} else if (pldata->get_status(USB_STATUS_BVABLID)) {
 		/* if usb not connect before ,then start connect */
-		if( _pcd->vbus_status == USB_BC_TYPE_DISCNT ) {
-			printk("*******************vbus detect*********************\n");
-//            if( pldata->bc_detect_cb != NULL )
-//                pldata->bc_detect_cb( _pcd->vbus_status = usb_battery_charger_detect(1) );
-//            else
-                _pcd->vbus_status = USB_BC_TYPE_SDP;
-			if(_pcd->conn_en){
+		if (_pcd->vbus_status == USB_BC_TYPE_DISCNT) {
+			printk("*****************vbus detect*******************\n");
+			/* if( pldata->bc_detect_cb != NULL ) */
+			/* 	pldata->bc_detect_cb(_pcd->vbus_status */
+			/*			     = usb_battery_charger_detect(1)); */
+			/* else */
+			_pcd->vbus_status = USB_BC_TYPE_SDP;
+			if (_pcd->conn_en) {
 				goto connect;
-			}
-			else if( pldata->phy_status == USB_PHY_ENABLED ){
-				// do not allow to connect, suspend phy
+			} else if (pldata->phy_status == USB_PHY_ENABLED) {
+				/* do not allow to connect, suspend phy */
 				pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 				udelay(3);
-				pldata->clock_enable( pldata, 0);
+				pldata->clock_enable(pldata, 0);
 			}
-		}else if((_pcd->conn_en)&&(_pcd->conn_status>=0)&&(_pcd->conn_status <2)){
-			printk("******************soft reconnect********************\n");
+		} else if ((_pcd->conn_en) && (_pcd->conn_status >= 0)
+			   && (_pcd->conn_status < 2)) {
+			printk("****************soft reconnect******************\n");
 			goto connect;
-		}else if(_pcd->conn_status == 2){
+		} else if (_pcd->conn_status == 2) {
 			/* release pcd->wake_lock if fail to connect,
 			 * allow system to enter second sleep.
 			 */
 			dwc_otg_msc_unlock(_pcd);
 			_pcd->conn_status++;
-            if( pldata->bc_detect_cb != NULL ){
-                rk_usb_charger_status = USB_BC_TYPE_DCP;
-                pldata->bc_detect_cb( _pcd->vbus_status = USB_BC_TYPE_DCP ); 
-            }else{
-                _pcd->vbus_status = USB_BC_TYPE_DCP;
-                rk_usb_charger_status = USB_BC_TYPE_DCP;
+			if (pldata->bc_detect_cb != NULL) {
+				rk_usb_charger_status = USB_BC_TYPE_DCP;
+				pldata->bc_detect_cb(_pcd->vbus_status =
+						     USB_BC_TYPE_DCP);
+			} else {
+				_pcd->vbus_status = USB_BC_TYPE_DCP;
+				rk_usb_charger_status = USB_BC_TYPE_DCP;
 			}
 			/* fail to connect, suspend usb phy and disable clk */
-			if( pldata->phy_status == USB_PHY_ENABLED ){
+			if (pldata->phy_status == USB_PHY_ENABLED) {
 				pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 				udelay(3);
-				pldata->clock_enable( pldata, 0);
+				pldata->clock_enable(pldata, 0);
 			}
 		}
-	}else {
-        if( pldata->bc_detect_cb != NULL )
-            pldata->bc_detect_cb( _pcd->vbus_status = USB_BC_TYPE_DISCNT );
-        else
-		    _pcd->vbus_status = USB_BC_TYPE_DISCNT;
+	} else {
+		if (pldata->bc_detect_cb != NULL)
+			pldata->bc_detect_cb(_pcd->vbus_status =
+					     USB_BC_TYPE_DISCNT);
+		else
+			_pcd->vbus_status = USB_BC_TYPE_DISCNT;
 
-		if(_pcd->conn_status){
+		if (_pcd->conn_status) {
 			_pcd->conn_status = 0;
 		}
 
-		if( pldata->phy_status == USB_PHY_ENABLED ){
+		if (pldata->phy_status == USB_PHY_ENABLED) {
 			/* release wake lock */
 			dwc_otg_msc_unlock(_pcd);
 			/* no vbus detect here , close usb phy  */
 			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 			udelay(3);
-			pldata->clock_enable( pldata, 0);
+			pldata->clock_enable(pldata, 0);
 		}
 
 		/* usb phy bypass to uart mode  */
-		if( pldata->dwc_otg_uart_mode != NULL )
-			pldata->dwc_otg_uart_mode( pldata, PHY_UART_MODE);
+		if (pldata->dwc_otg_uart_mode != NULL)
+			pldata->dwc_otg_uart_mode(pldata, PHY_UART_MODE);
 	}
 
 	schedule_delayed_work(&_pcd->check_vbus_work, HZ);
 	local_irq_restore(flags);
 
 	return;
-    
+
 connect:
-	if( pldata->phy_status)
-	{
+	if (pldata->phy_status) {
 		pldata->clock_enable(pldata, 1);
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 	}
 
-	if(_pcd->conn_status==0)
+	if (_pcd->conn_status == 0)
 		dwc_otg_msc_lock(_pcd);
 
-	schedule_delayed_work( &_pcd->reconnect , 8 ); /* delay 8 jiffies */
-	schedule_delayed_work(&_pcd->check_vbus_work, (HZ<<2));
+	schedule_delayed_work(&_pcd->reconnect, 8);	/* delay 8 jiffies */
+	schedule_delayed_work(&_pcd->check_vbus_work, (HZ << 2));
 	local_irq_restore(flags);
 
 	return;
 }
 
-void dwc_otg_pcd_start_check_vbus_work(dwc_otg_pcd_t * pcd)
+void dwc_otg_pcd_start_check_vbus_work(dwc_otg_pcd_t *pcd)
 {
-        /* 
-         * when receive reset int,the vbus state may not be update,so 
-         * always start vbus work here.
-         */
-	schedule_delayed_work(&pcd->check_vbus_work, (HZ*2));
+	/*
+	 * when receive reset int,the vbus state may not be update,so
+	 * always start vbus work here.
+	 */
+	schedule_delayed_work(&pcd->check_vbus_work, (HZ * 2));
 }
 
 /*
 * 20091228,HSL@RK,to get the current vbus status.
 */
-int dwc_vbus_status( void )
+int dwc_vbus_status(void)
 {
 #ifdef CONFIG_USB20_OTG
 	dwc_otg_pcd_t *pcd = 0;
-	if(gadget_wrapper){
+	if (gadget_wrapper) {
 		pcd = gadget_wrapper->pcd;
 	}
 
-	if(!pcd)
+	if (!pcd)
 		return 0;
 	else
-		return pcd->vbus_status ;
+		return pcd->vbus_status;
 #else
 	return 0;
 #endif
 }
+
 EXPORT_SYMBOL(dwc_vbus_status);
 
-static void dwc_otg_pcd_work_init(dwc_otg_pcd_t *pcd, struct platform_device *dev)
+static void dwc_otg_pcd_work_init(dwc_otg_pcd_t *pcd,
+				  struct platform_device *dev)
 {
 
-	struct dwc_otg_device* otg_dev = pcd->otg_dev;
+	struct dwc_otg_device *otg_dev = pcd->otg_dev;
 	struct dwc_otg_platform_data *pldata = otg_dev->pldata;
-	pcd->vbus_status  = USB_BC_TYPE_DISCNT;
-	pcd->phy_suspend  = USB_PHY_ENABLED;
+	pcd->vbus_status = USB_BC_TYPE_DISCNT;
+	pcd->phy_suspend = USB_PHY_ENABLED;
 
-	INIT_DELAYED_WORK(&pcd->reconnect , dwc_phy_reconnect);
-	INIT_DELAYED_WORK(&pcd->check_vbus_work , dwc_otg_pcd_check_vbus_work);
+	INIT_DELAYED_WORK(&pcd->reconnect, dwc_phy_reconnect);
+	INIT_DELAYED_WORK(&pcd->check_vbus_work, dwc_otg_pcd_check_vbus_work);
 
 	wake_lock_init(&pcd->wake_lock, WAKE_LOCK_SUSPEND, "usb_pcd");
-    
-	if(dwc_otg_is_device_mode(pcd->core_if) &&
-	  (otg_dev->core_if->usb_mode != USB_MODE_FORCE_HOST)){
-#ifdef CONFIG_RK_USB_UART        
-		if(pldata->get_status(USB_STATUS_BVABLID)){
-			//enter usb phy mode
+
+	if (dwc_otg_is_device_mode(pcd->core_if) &&
+	    (otg_dev->core_if->usb_mode != USB_MODE_FORCE_HOST)) {
+#ifdef CONFIG_RK_USB_UART
+		if (pldata->get_status(USB_STATUS_BVABLID)) {
+			/* enter usb phy mode */
 			pldata->dwc_otg_uart_mode(pldata, PHY_USB_MODE);
-		}else{
-			//usb phy bypass to uart mode
+		} else {
+			/* usb phy bypass to uart mode */
 			pldata->dwc_otg_uart_mode(pldata, PHY_UART_MODE);
 		}
 #endif
-		schedule_delayed_work(&pcd->check_vbus_work, (HZ<<4));
+		schedule_delayed_work(&pcd->check_vbus_work, (HZ << 4));
 	}
 #ifdef CONFIG_RK_USB_UART
-	else if(pldata->dwc_otg_uart_mode != NULL)
-		//host mode,enter usb phy mode
+	else if (pldata->dwc_otg_uart_mode != NULL)
+		/* host mode,enter usb phy mode */
 		pldata->dwc_otg_uart_mode(pldata, PHY_USB_MODE);
 #endif
 
diff --git a/drivers/usb/dwc_otg_310/dwc_otg_regs.h b/drivers/usb/dwc_otg_310/dwc_otg_regs.h
index a762b27dc28e..5d0a8b75744a 100755
--- a/drivers/usb/dwc_otg_310/dwc_otg_regs.h
+++ b/drivers/usb/dwc_otg_310/dwc_otg_regs.h
@@ -64,7 +64,7 @@
  */
 
 /****************************************************************************/
-/** DWC_otg Core registers . 
+/** DWC_otg Core registers .
  * The dwc_otg_core_global_regs structure defines the size
  * and relative field offsets for the Core Global registers.
  */
@@ -380,7 +380,7 @@ typedef union grstctl_data {
 		 * to clear.
 		 */
 		unsigned rxfflsh:1;
-		/** TxFIFO Flush (TxFFlsh) (Device and Host). 
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
 		 *
 		 * This bit is used to selectively flush a single or
 		 * all transmit FIFOs. The application must first
@@ -528,12 +528,12 @@ typedef union device_grxsts_data {
 		unsigned bcnt:11;
 		unsigned dpid:2;
 
-#define DWC_STS_DATA_UPDT		0x2	// OUT Data Packet
-#define DWC_STS_XFER_COMP		0x3	// OUT Data Transfer Complete
+#define DWC_STS_DATA_UPDT		0x2	/* OUT Data Packet */
+#define DWC_STS_XFER_COMP		0x3	/* OUT Data Transfer Complete */
 
-#define DWC_DSTS_GOUT_NAK		0x1	// Global OUT NAK
-#define DWC_DSTS_SETUP_COMP		0x4	// Setup Phase Complete
-#define DWC_DSTS_SETUP_UPDT 0x6	// SETUP Packet
+#define DWC_DSTS_GOUT_NAK		0x1	/* Global OUT NAK */
+#define DWC_DSTS_SETUP_COMP		0x4	/* Setup Phase Complete */
+#define DWC_DSTS_SETUP_UPDT		0x6	/* SETUP Packet */
 		unsigned pktsts:4;
 		unsigned fn:4;
 		unsigned reserved25_31:7;
@@ -566,7 +566,7 @@ typedef union host_grxsts_data {
 
 /**
  * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
- * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element 
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element
  * then read out the bits using the <i>b</i>it elements.
  */
 typedef union fifosize_data {
@@ -673,7 +673,7 @@ typedef union gpvndctl_data {
 } gpvndctl_data_t;
 
 /**
- * This union represents the bit fields in the General Purpose 
+ * This union represents the bit fields in the General Purpose
  * Input/Output Register (GGPIO).
  * Read the register into the <i>d32</i> element then read out the
  * bits using the <i>b</i>it elements.
@@ -894,10 +894,10 @@ typedef union glpmctl_data {
 		 * LPM transaction.
 		 * In Device mode the response of the core to
 		 * LPM transaction received is reflected in these two bits.
-		 	- 0x0 : ERROR (No handshake response)
+			- 0x0 : ERROR (No handshake response)
 			- 0x1 : STALL
 			- 0x2 : NYET
-			- 0x3 : ACK			
+			- 0x3 : ACK
 		 */
 		unsigned lpm_resp:2;
 		/** Port Sleep Status (SlpSts) (Device and Host)
@@ -936,7 +936,7 @@ typedef union glpmctl_data {
 		 *  This bit enables the BESL features as defined in the LPM errata
 		 */
 		unsigned en_besl:1;
-		
+
 		unsigned reserved29:1;
 		/** In host mode once this bit is set, the host
 		 * configures to drive the HSIC Idle state on the bus.
@@ -964,7 +964,7 @@ typedef union adpctl_data {
 	/** register bits */
 	struct {
 		/** Probe Discharge (PRB_DSCHG)
-		 *  These bits set the times for TADP_DSCHG. 
+		 *  These bits set the times for TADP_DSCHG.
 		 *  These bits are defined as follows:
 		 *  2'b00 - 4 msec
 		 *  2'b01 - 8 msec
@@ -991,8 +991,8 @@ typedef union adpctl_data {
 		 *  2'b11  -  Reserved
 		 */
 		unsigned prb_per:2;
-		/** These bits capture the latest time it took for VBUS to ramp from 
-		 *  VADP_SINK to VADP_PRB. 
+		/** These bits capture the latest time it took for VBUS to ramp from
+		 *  VADP_SINK to VADP_PRB.
 		 *  0x000  -  1 cycles
 		 *  0x001  -  2 cycles
 		 *  0x002  -  3 cycles
@@ -1014,7 +1014,7 @@ typedef union adpctl_data {
 		/** ADP Reset (ADPRes)
 		 *  When set, ADP controller is reset.
 		 *  This bit is valid only if OTG_Ver = 1'b1.
- 		 */
+		 */
 		unsigned adpres:1;
 		/** ADP Enable (ADPEn)
 		 *  When set, the core performs either ADP probing or sensing
@@ -1030,7 +1030,7 @@ typedef union adpctl_data {
 		unsigned adp_prb_int:1;
 		/**
 		 *  ADP Sense Interrupt (ADP_SNS_INT)
-		 *  When this bit is set, it means that the VBUS voltage is greater than 
+		 *  When this bit is set, it means that the VBUS voltage is greater than
 		 *  VADP_SNS value or VADP_SNS is reached.
 		 *  This bit is valid only if OTG_Ver = 1'b1.
 		 */
@@ -1060,7 +1060,7 @@ typedef union adpctl_data {
 		 */
 		unsigned adp_tmout_int_msk:1;
 		/** Access Request
-		 * 2'b00 - Read/Write Valid (updated by the core) 
+		 * 2'b00 - Read/Write Valid (updated by the core)
 		 * 2'b01 - Read
 		 * 2'b00 - Write
 		 * 2'b00 - Reserved
@@ -1071,9 +1071,8 @@ typedef union adpctl_data {
 	} b;
 } adpctl_data_t;
 
-////////////////////////////////////////////
-// Device Registers
 /**
+ * Device Registers
  * Device Global Registers. <i>Offsets 800h-BFFh</i>
  *
  * The following structures define the size and relative field offsets
@@ -1673,9 +1672,7 @@ typedef union deptsiz0_data {
 	} b;
 } deptsiz0_data_t;
 
-/////////////////////////////////////////////////
-// DMA Descriptor Specific Structures
-//
+/* DMA Descriptor Specific Structures */
 
 /** Buffer status definitions */
 
@@ -1723,7 +1720,7 @@ typedef union dev_dma_desc_sts {
 		unsigned bs:2;
 	} b;
 
-//#ifdef DWC_EN_ISOC
+/* #ifdef DWC_EN_ISOC */
 		/** iso out quadlet bits */
 	struct {
 		/** Received number of bytes */
@@ -1765,7 +1762,7 @@ typedef union dev_dma_desc_sts {
 		/** Buffer Status */
 		unsigned bs:2;
 	} b_iso_in;
-//#endif                                /* DWC_EN_ISOC */
+/* #endif */  /* DWC_EN_ISOC */
 } dev_dma_desc_sts_t;
 
 /**
@@ -1853,10 +1850,8 @@ typedef struct dwc_otg_dev_if {
 
 } dwc_otg_dev_if_t;
 
-/////////////////////////////////////////////////
-// Host Mode Register Structures
-//
 /**
+ * Host Mode Register Structures
  * The Host Global Registers structure defines the size and relative
  * field offsets for the Host Mode Global Registers.  Host Global
  * Registers offsets 400h-7FFh.
@@ -1918,7 +1913,7 @@ typedef union hcfg_data {
 
 /**
  * This union represents the bit fields in the Host Frame Remaing/Number
- * Register. 
+ * Register.
  */
 typedef union hfir_data {
 	/** raw register data */
@@ -1934,7 +1929,7 @@ typedef union hfir_data {
 
 /**
  * This union represents the bit fields in the Host Frame Remaing/Number
- * Register. 
+ * Register.
  */
 typedef union hfnum_data {
 	/** raw register data */
@@ -2006,7 +2001,7 @@ typedef union hprt0_data {
 
 /**
  * This union represents the bit fields in the Host All Interrupt
- * Register. 
+ * Register.
  */
 typedef union haint_data {
 	/** raw register data */
@@ -2040,7 +2035,7 @@ typedef union haint_data {
 
 /**
  * This union represents the bit fields in the Host All Interrupt
- * Register. 
+ * Register.
  */
 typedef union haintmsk_data {
 	/** raw register data */
@@ -2174,7 +2169,7 @@ typedef union hcsplt_data {
 
 /**
  * This union represents the bit fields in the Host All Interrupt
- * Register. 
+ * Register.
  */
 typedef union hcint_data {
 	/** raw register data */
@@ -2311,7 +2306,7 @@ typedef union hctsiz_data {
 } hctsiz_data_t;
 
 /**
- * This union represents the bit fields in the Host DMA Address 
+ * This union represents the bit fields in the Host DMA Address
  * Register used in Descriptor DMA mode.
  */
 typedef union hcdma_data {
diff --git a/drivers/usb/dwc_otg_310/usbdev_bc.c b/drivers/usb/dwc_otg_310/usbdev_bc.c
index ced7cb4b1ae3..d7443add91b6 100755
--- a/drivers/usb/dwc_otg_310/usbdev_bc.c
+++ b/drivers/usb/dwc_otg_310/usbdev_bc.c
@@ -19,71 +19,85 @@
 /****** GET and SET REGISTER FIELDS IN GRF UOC ******/
 
 #define BC_GET(x) grf_uoc_get_field(&pBC_UOC_FIELDS[x])
-#define BC_SET(x,v) grf_uoc_set_field(&pBC_UOC_FIELDS[x], v)
+#define BC_SET(x, v) grf_uoc_set_field(&pBC_UOC_FIELDS[x], v)
 
-uoc_field_t *pBC_UOC_FIELDS = NULL;
-static void *pGRF_BASE = NULL;
+uoc_field_t *pBC_UOC_FIELDS;
+static void *pGRF_BASE;
 int rk_usb_charger_status = USB_BC_TYPE_DISCNT;
 
 /****** GET REGISTER FIELD INFO FROM Device Tree ******/
 
-inline static void *get_grf_base(struct device_node *np)
+static inline void *get_grf_base(struct device_node *np)
 {
-    void *grf_base = of_iomap(of_get_parent(np), 0);
-    if(of_machine_is_compatible("rockchip,rk3188"))
-        return (grf_base - 0xac);
-    else if(of_machine_is_compatible("rockchip,rk3288"))
-        return (grf_base - 0x284);
-}
+	void *grf_base = of_iomap(of_get_parent(np), 0);
+
+	if (of_machine_is_compatible("rockchip,rk3188"))
+		grf_base -= 0xac;
+	else if (of_machine_is_compatible("rockchip,rk3288"))
+		grf_base -= 0x284;
 
+	return grf_base;
+}
 
 void grf_uoc_set_field(uoc_field_t *field, u32 value)
 {
-    if(!uoc_field_valid(field))
-        return ;
-    grf_uoc_set(pGRF_BASE, field->b.offset, field->b.bitmap, field->b.mask, value);
+	if (!uoc_field_valid(field))
+		return;
+	grf_uoc_set(pGRF_BASE, field->b.offset, field->b.bitmap, field->b.mask,
+		    value);
 }
 
 u32 grf_uoc_get_field(uoc_field_t *field)
 {
-    return grf_uoc_get(pGRF_BASE, field->b.offset, field->b.bitmap, field->b.mask);
+	return grf_uoc_get(pGRF_BASE, field->b.offset, field->b.bitmap,
+			   field->b.mask);
 }
 
-inline static int uoc_init_field(struct device_node *np, const char* name, uoc_field_t *f)
+static inline int uoc_init_field(struct device_node *np, const char *name,
+				 uoc_field_t *f)
 {
-    of_property_read_u32_array(np, name, f->array, 3);
-    //printk("usb battery charger detect: uoc_init_field: 0x%08x %d %d \n",f->b.offset,f->b.bitmap,f->b.mask);
-    return 0;
+	of_property_read_u32_array(np, name, f->array, 3);
+	/* printk("usb battery charger detect: uoc_init_field: 0x%08x %d %d \n",
+	 * 	  f->b.offset,f->b.bitmap,f->b.mask);*/
+	return 0;
 }
-inline static void uoc_init_synop(struct device_node *np)
+
+static inline void uoc_init_synop(struct device_node *np)
 {
-    pBC_UOC_FIELDS = (uoc_field_t *)kzalloc(SYNOP_BC_MAX * sizeof(uoc_field_t), GFP_ATOMIC);
-
-    uoc_init_field(np, "rk_usb,bvalid", &pBC_UOC_FIELDS[SYNOP_BC_BVALID]);
-    uoc_init_field(np, "rk_usb,dcdenb", &pBC_UOC_FIELDS[SYNOP_BC_DCDENB]);
-    uoc_init_field(np, "rk_usb,vdatsrcenb", &pBC_UOC_FIELDS[SYNOP_BC_VDATSRCENB]);
-    uoc_init_field(np, "rk_usb,vdatdetenb", &pBC_UOC_FIELDS[SYNOP_BC_VDATDETENB]);
-    uoc_init_field(np, "rk_usb,chrgsel",  &pBC_UOC_FIELDS[SYNOP_BC_CHRGSEL]);
-    uoc_init_field(np, "rk_usb,chgdet",   &pBC_UOC_FIELDS[SYNOP_BC_CHGDET]);
-    uoc_init_field(np, "rk_usb,fsvplus",  &pBC_UOC_FIELDS[SYNOP_BC_FSVPLUS]);
-    uoc_init_field(np, "rk_usb,fsvminus", &pBC_UOC_FIELDS[SYNOP_BC_FSVMINUS]);
+	pBC_UOC_FIELDS =
+	    (uoc_field_t *) kzalloc(SYNOP_BC_MAX * sizeof(uoc_field_t),
+				    GFP_ATOMIC);
+
+	uoc_init_field(np, "rk_usb,bvalid", &pBC_UOC_FIELDS[SYNOP_BC_BVALID]);
+	uoc_init_field(np, "rk_usb,dcdenb", &pBC_UOC_FIELDS[SYNOP_BC_DCDENB]);
+	uoc_init_field(np, "rk_usb,vdatsrcenb",
+		       &pBC_UOC_FIELDS[SYNOP_BC_VDATSRCENB]);
+	uoc_init_field(np, "rk_usb,vdatdetenb",
+		       &pBC_UOC_FIELDS[SYNOP_BC_VDATDETENB]);
+	uoc_init_field(np, "rk_usb,chrgsel", &pBC_UOC_FIELDS[SYNOP_BC_CHRGSEL]);
+	uoc_init_field(np, "rk_usb,chgdet", &pBC_UOC_FIELDS[SYNOP_BC_CHGDET]);
+	uoc_init_field(np, "rk_usb,fsvplus", &pBC_UOC_FIELDS[SYNOP_BC_FSVPLUS]);
+	uoc_init_field(np, "rk_usb,fsvminus",
+		       &pBC_UOC_FIELDS[SYNOP_BC_FSVMINUS]);
 }
 
-inline static void uoc_init_rk(struct device_node *np)
+static inline void uoc_init_rk(struct device_node *np)
 {
-    pBC_UOC_FIELDS = (uoc_field_t *)kzalloc(RK_BC_MAX * sizeof(uoc_field_t), GFP_ATOMIC);
-
-    uoc_init_field(np, "rk_usb,bvalid",   &pBC_UOC_FIELDS[RK_BC_BVALID]);
-    uoc_init_field(np, "rk_usb,line",     &pBC_UOC_FIELDS[RK_BC_LINESTATE]);
-    uoc_init_field(np, "rk_usb,softctrl", &pBC_UOC_FIELDS[RK_BC_SOFTCTRL]);
-    uoc_init_field(np, "rk_usb,opmode",   &pBC_UOC_FIELDS[RK_BC_OPMODE]);
-    uoc_init_field(np, "rk_usb,xcvrsel",  &pBC_UOC_FIELDS[RK_BC_XCVRSELECT]);
-    uoc_init_field(np, "rk_usb,termsel",  &pBC_UOC_FIELDS[RK_BC_TERMSELECT]);
+	pBC_UOC_FIELDS =
+	    (uoc_field_t *) kzalloc(RK_BC_MAX * sizeof(uoc_field_t),
+				    GFP_ATOMIC);
+
+	uoc_init_field(np, "rk_usb,bvalid", &pBC_UOC_FIELDS[RK_BC_BVALID]);
+	uoc_init_field(np, "rk_usb,line", &pBC_UOC_FIELDS[RK_BC_LINESTATE]);
+	uoc_init_field(np, "rk_usb,softctrl", &pBC_UOC_FIELDS[RK_BC_SOFTCTRL]);
+	uoc_init_field(np, "rk_usb,opmode", &pBC_UOC_FIELDS[RK_BC_OPMODE]);
+	uoc_init_field(np, "rk_usb,xcvrsel", &pBC_UOC_FIELDS[RK_BC_XCVRSELECT]);
+	uoc_init_field(np, "rk_usb,termsel", &pBC_UOC_FIELDS[RK_BC_TERMSELECT]);
 }
 
-inline static void uoc_init_inno(struct device_node *np)
+static inline void uoc_init_inno(struct device_node *np)
 {
-    ;
+	;
 }
 
 /****** BATTERY CHARGER DETECT FUNCTIONS ******/
@@ -91,63 +105,65 @@ inline static void uoc_init_inno(struct device_node *np)
 int usb_battery_charger_detect_rk(bool wait)
 {
 
-    int port_type = USB_BC_TYPE_DISCNT;
-    
-    if(BC_GET(RK_BC_BVALID))
-    {   
-        mdelay(10);
-        BC_SET(RK_BC_SOFTCTRL, 1);
-        BC_SET(RK_BC_OPMODE, 0);
-        BC_SET(RK_BC_XCVRSELECT, 1);
-        BC_SET(RK_BC_TERMSELECT, 1);
-        
-        mdelay(1);
-        switch (BC_GET(RK_BC_LINESTATE))
-        {
-            case 1:
-                port_type = USB_BC_TYPE_SDP;
-                break;
-                
-            case 3:
-                port_type = USB_BC_TYPE_DCP;
-                break;
-                
-            default:
-                port_type = USB_BC_TYPE_SDP;
-                //printk("%s linestate = %d bad status\n", __func__, BC_GET(RK_BC_LINESTATE));
-        }
-        
-    }
-    BC_SET(RK_BC_SOFTCTRL, 0);    
-    
-    //printk("%s , battery_charger_detect %d\n", __func__, port_type);
-    return port_type;
+	int port_type = USB_BC_TYPE_DISCNT;
+
+	if (BC_GET(RK_BC_BVALID)) {
+		mdelay(10);
+		BC_SET(RK_BC_SOFTCTRL, 1);
+		BC_SET(RK_BC_OPMODE, 0);
+		BC_SET(RK_BC_XCVRSELECT, 1);
+		BC_SET(RK_BC_TERMSELECT, 1);
+
+		mdelay(1);
+		switch (BC_GET(RK_BC_LINESTATE)) {
+		case 1:
+			port_type = USB_BC_TYPE_SDP;
+			break;
+
+		case 3:
+			port_type = USB_BC_TYPE_DCP;
+			break;
+
+		default:
+			port_type = USB_BC_TYPE_SDP;
+			/* printk("%s linestate = %d bad status\n",
+			 *	  __func__, BC_GET(RK_BC_LINESTATE)); */
+		}
+
+	}
+	BC_SET(RK_BC_SOFTCTRL, 0);
+
+	/* printk("%s , battery_charger_detect %d\n",
+	 *	  __func__, port_type); */
+	return port_type;
 }
 
 int usb_battery_charger_detect_inno(bool wait)
 {
 
-    return -1;
+	return -1;
 }
 
 /* When do BC detect PCD pull-up register should be disabled  */
-//wait wait for dcd timeout 900ms
+/* wait wait for dcd timeout 900ms */
 int usb_battery_charger_detect_synop(bool wait)
 {
 	int port_type = USB_BC_TYPE_DISCNT;
 	int dcd_state;
 	int timeout = 0, i = 0;
-	//VBUS Valid detect
-	if(BC_GET(SYNOP_BC_BVALID)) {
-		if(wait) {
-			//Do DCD
+	/* VBUS Valid detect */
+	if (BC_GET(SYNOP_BC_BVALID)) {
+		if (wait) {
+			/* Do DCD */
 			dcd_state = DCD_TIMEOUT;
 			BC_SET(SYNOP_BC_DCDENB, 1);
 			timeout = T_DCD_TIMEOUT;
-			while(timeout--) {
-				if(!BC_GET(SYNOP_BC_FSVPLUS))
+			while (timeout--) {
+				if (!BC_GET(SYNOP_BC_FSVPLUS))
 					i++;
-				if(i >= 3) {//It is a filter here to assure data lines contacted for at least 3ms
+				if (i >= 3) {
+					/* It is a filter here to assure data
+					 * lines contacted for at least 3ms */
 					dcd_state = DCD_POSITIVE;
 					break;
 				}
@@ -155,24 +171,24 @@ int usb_battery_charger_detect_synop(bool wait)
 				mdelay(1);
 			}
 			BC_SET(SYNOP_BC_DCDENB, 0);
-		} else{
+		} else {
 			dcd_state = DCD_PASSED;
 		}
-		if(dcd_state == DCD_TIMEOUT){
+		if (dcd_state == DCD_TIMEOUT) {
 			port_type = USB_BC_TYPE_UNKNOW;
 			goto out;
 		}
 
 		/* Turn on VDPSRC */
-		//Primary Detection
+		/* Primary Detection */
 		BC_SET(SYNOP_BC_VDATSRCENB, 1);
 		BC_SET(SYNOP_BC_VDATDETENB, 1);
 		BC_SET(SYNOP_BC_CHRGSEL, 0);
-		
+
 		udelay(T_BC_CHGDET_VALID);
-		
+
 		/* SDP and CDP/DCP distinguish */
-		if(BC_GET(SYNOP_BC_CHGDET)) {
+		if (BC_GET(SYNOP_BC_CHGDET)) {
 			/* Turn off VDPSRC */
 			BC_SET(SYNOP_BC_VDATSRCENB, 0);
 			BC_SET(SYNOP_BC_VDATDETENB, 0);
@@ -184,7 +200,7 @@ int usb_battery_charger_detect_synop(bool wait)
 			BC_SET(SYNOP_BC_VDATDETENB, 1);
 			BC_SET(SYNOP_BC_CHRGSEL, 1);
 			udelay(T_BC_CHGDET_VALID);
-			if(BC_GET(SYNOP_BC_CHGDET))
+			if (BC_GET(SYNOP_BC_CHGDET))
 				port_type = USB_BC_TYPE_DCP;
 			else
 				port_type = USB_BC_TYPE_CDP;
@@ -198,74 +214,71 @@ int usb_battery_charger_detect_synop(bool wait)
 	}
 out:
 	printk("%s , battery_charger_detect %d, %s DCD, dcd_state = %d\n",
-		__func__, port_type, wait ? "wait" : "pass", dcd_state);
+	       __func__, port_type, wait ? "wait" : "pass", dcd_state);
 	return port_type;
 }
 
-
 int usb_battery_charger_detect(bool wait)
 {
-    static struct device_node *np = NULL;
-    if(!np)
-        np = of_find_node_by_name(NULL, "usb_bc");
-    if(!np)
-        goto fail;
-    if(!pGRF_BASE) {
-        pGRF_BASE = get_grf_base(np);
-    }
-
-    if(of_device_is_compatible(np,"rockchip,ctrl")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_rk(np);
-        return usb_battery_charger_detect_rk(wait);
-    }
-
-    else if(of_device_is_compatible(np,"synopsys,phy")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_synop(np);
-        return usb_battery_charger_detect_synop(wait);
-    }
-
-    else if(of_device_is_compatible(np,"inno,phy")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_inno(np);
-        return usb_battery_charger_detect_inno(wait);
-    }
+	static struct device_node *np;
+	if (!np)
+		np = of_find_node_by_name(NULL, "usb_bc");
+	if (!np)
+		goto fail;
+	if (!pGRF_BASE)
+		pGRF_BASE = get_grf_base(np);
+
+	if (of_device_is_compatible(np, "rockchip,ctrl")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_rk(np);
+		return usb_battery_charger_detect_rk(wait);
+	}
+
+	else if (of_device_is_compatible(np, "synopsys,phy")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_synop(np);
+		return usb_battery_charger_detect_synop(wait);
+	}
+
+	else if (of_device_is_compatible(np, "inno,phy")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_inno(np);
+		return usb_battery_charger_detect_inno(wait);
+	}
 fail:
-    return -1;
+	return -1;
 }
-EXPORT_SYMBOL(usb_battery_charger_detect);
 
+EXPORT_SYMBOL(usb_battery_charger_detect);
 
 int dwc_otg_check_dpdm(bool wait)
 {
-    static struct device_node *np = NULL;
-    if(!np)
-        np = of_find_node_by_name(NULL, "usb_bc");
-    if(!np)
-        return -1;
-    if(!pGRF_BASE) {
-        pGRF_BASE = get_grf_base(np);
-    }
-
-    if(of_device_is_compatible(np,"rockchip,ctrl")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_rk(np);
-		if(!BC_GET(RK_BC_BVALID))
+	static struct device_node *np;
+	if (!np)
+		np = of_find_node_by_name(NULL, "usb_bc");
+	if (!np)
+		return -1;
+	if (!pGRF_BASE)
+		pGRF_BASE = get_grf_base(np);
+
+	if (of_device_is_compatible(np, "rockchip,ctrl")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_rk(np);
+		if (!BC_GET(RK_BC_BVALID))
 			rk_usb_charger_status = USB_BC_TYPE_DISCNT;
 
-    }else if(of_device_is_compatible(np,"synopsys,phy")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_synop(np);
-		if(!BC_GET(SYNOP_BC_BVALID))
+	} else if (of_device_is_compatible(np, "synopsys,phy")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_synop(np);
+		if (!BC_GET(SYNOP_BC_BVALID))
 			rk_usb_charger_status = USB_BC_TYPE_DISCNT;
 
-    }else if(of_device_is_compatible(np,"inno,phy")) {
-        if(!pBC_UOC_FIELDS)
-            uoc_init_inno(np);
-    }
+	} else if (of_device_is_compatible(np, "inno,phy")) {
+		if (!pBC_UOC_FIELDS)
+			uoc_init_inno(np);
+	}
 
-    return rk_usb_charger_status;
+	return rk_usb_charger_status;
 }
 EXPORT_SYMBOL(dwc_otg_check_dpdm);
 
@@ -273,30 +286,30 @@ EXPORT_SYMBOL(dwc_otg_check_dpdm);
 
 void usb20otg_battery_charger_detect_cb(int charger_type_new)
 {
-    static int charger_type = USB_BC_TYPE_DISCNT;
-    if(charger_type != charger_type_new) {
-        switch(charger_type_new) {
-            case USB_BC_TYPE_DISCNT:
-                break;
+	static int charger_type = USB_BC_TYPE_DISCNT;
+	if (charger_type != charger_type_new) {
+		switch (charger_type_new) {
+		case USB_BC_TYPE_DISCNT:
+			break;
 
-            case USB_BC_TYPE_SDP:
-                break;
+		case USB_BC_TYPE_SDP:
+			break;
 
-            case USB_BC_TYPE_DCP:
-                break;
+		case USB_BC_TYPE_DCP:
+			break;
 
-            case USB_BC_TYPE_CDP:
-                break;
+		case USB_BC_TYPE_CDP:
+			break;
 
-            case USB_BC_TYPE_UNKNOW:
-                break;
+		case USB_BC_TYPE_UNKNOW:
+			break;
 
-            default :
-                break;
-        }
+		default:
+			break;
+		}
 
-        //printk("%s , battery_charger_detect %d\n", __func__, charger_type_new);
-    }
-    charger_type = charger_type_new;
+		/* printk("%s , battery_charger_detect %d\n",
+		 *	  __func__, charger_type_new);*/
+	}
+	charger_type = charger_type_new;
 }
-
diff --git a/drivers/usb/dwc_otg_310/usbdev_bc.h b/drivers/usb/dwc_otg_310/usbdev_bc.h
index 7e6b9bdf41e9..0299c625b89e 100644
--- a/drivers/usb/dwc_otg_310/usbdev_bc.h
+++ b/drivers/usb/dwc_otg_310/usbdev_bc.h
@@ -9,25 +9,25 @@
 #define USB_BC_TYPE_UNKNOW  (4)
 
 enum {
-    SYNOP_BC_BVALID = 0,
-    SYNOP_BC_DCDENB,
-    SYNOP_BC_VDATSRCENB,
-    SYNOP_BC_VDATDETENB,
-    SYNOP_BC_CHRGSEL,
-    SYNOP_BC_CHGDET,
-    SYNOP_BC_FSVPLUS,
-    SYNOP_BC_FSVMINUS,
-    SYNOP_BC_MAX,	
+	SYNOP_BC_BVALID = 0,
+	SYNOP_BC_DCDENB,
+	SYNOP_BC_VDATSRCENB,
+	SYNOP_BC_VDATDETENB,
+	SYNOP_BC_CHRGSEL,
+	SYNOP_BC_CHGDET,
+	SYNOP_BC_FSVPLUS,
+	SYNOP_BC_FSVMINUS,
+	SYNOP_BC_MAX,
 };
 
 enum {
-    RK_BC_BVALID = 0,
-    RK_BC_LINESTATE,
-    RK_BC_SOFTCTRL,
-    RK_BC_OPMODE,
-    RK_BC_XCVRSELECT,
-    RK_BC_TERMSELECT,
-    RK_BC_MAX,
+	RK_BC_BVALID = 0,
+	RK_BC_LINESTATE,
+	RK_BC_SOFTCTRL,
+	RK_BC_OPMODE,
+	RK_BC_XCVRSELECT,
+	RK_BC_TERMSELECT,
+	RK_BC_MAX,
 };
 
 #define T_DCD_TIMEOUT	 (400)
diff --git a/drivers/usb/dwc_otg_310/usbdev_grf_regs.h b/drivers/usb/dwc_otg_310/usbdev_grf_regs.h
index c74063a99135..319581bf803f 100644
--- a/drivers/usb/dwc_otg_310/usbdev_grf_regs.h
+++ b/drivers/usb/dwc_otg_310/usbdev_grf_regs.h
@@ -1,19 +1,17 @@
 #ifndef __USBDEV_GRF_REGS_H__
 #define __USBDEV_GRF_REGS_H__
 
-typedef volatile struct tag_grf_uoc0_reg
-{
+typedef volatile struct tag_grf_uoc0_reg {
 	/* OTG */
 	u32 CON0;
 	u32 CON1;
 	u32 CON2;
 	u32 CON3;
 	u32 CON4;
-}GRF_UOC0_REG, *pGRF_UOC0_REG;
+} GRF_UOC0_REG, *pGRF_UOC0_REG;
 
-typedef volatile struct tag_grf_uoc1_reg
-{
-	/* HOST0 
+typedef volatile struct tag_grf_uoc1_reg {
+	/* HOST0
 	 * RK3188: DWC_OTG
 	 * RK3288: OHCI & EHCI
 	 */
@@ -22,11 +20,9 @@ typedef volatile struct tag_grf_uoc1_reg
 	u32 CON2;
 	u32 CON3;
 	u32 CON4;
-}GRF_UOC1_REG, *pGRF_UOC1_REG;
+} GRF_UOC1_REG, *pGRF_UOC1_REG;
 
-
-typedef volatile struct tag_grf_uoc2_reg
-{
+typedef volatile struct tag_grf_uoc2_reg {
 	/* RK3188: HISC PHY
 	 * RK3288: HOST1 DWC_OTG
 	 */
@@ -34,122 +30,115 @@ typedef volatile struct tag_grf_uoc2_reg
 	u32 CON1;
 	u32 CON2;
 	u32 CON3;
-}GRF_UOC2_REG, *pGRF_UOC2_REG;
+} GRF_UOC2_REG, *pGRF_UOC2_REG;
 
-typedef volatile struct tag_grf_uoc3_reg
-{
+typedef volatile struct tag_grf_uoc3_reg {
 	/* RK3188: HSIC CTLR
-	 * RK3288: HSIC PHY 
+	 * RK3288: HSIC PHY
 	 */
 	u32 CON0;
 	u32 CON1;
 	u32 CON2;
 	u32 CON3;
-}GRF_UOC3_REG, *pGRF_UOC3_REG;
+} GRF_UOC3_REG, *pGRF_UOC3_REG;
 
-typedef volatile struct tag_grf_uoc4_reg
-{
+typedef volatile struct tag_grf_uoc4_reg {
 	/* RK3288: HSIC CTLR */
 	u32 CON0;
 	u32 CON1;
 	u32 CON2;
 	u32 CON3;
-}GRF_UOC4_REG, *pGRF_UOC4_REG;
+} GRF_UOC4_REG, *pGRF_UOC4_REG;
 
-typedef volatile struct tag_grf_soc_status0_rk3188
-{
-	unsigned reserved2 : 9;
+typedef volatile struct tag_grf_soc_status0_rk3188 {
+	unsigned reserved2:9;
 	/* OTG20 */
-	unsigned otg_vbusvalid : 1;
-	unsigned otg_bvalid : 1;
-	unsigned otg_linestate : 2;
-	unsigned otg_iddig : 1;
-	unsigned otg_adpsns : 1;
-	unsigned otg_adpprb : 1;
+	unsigned otg_vbusvalid:1;
+	unsigned otg_bvalid:1;
+	unsigned otg_linestate:2;
+	unsigned otg_iddig:1;
+	unsigned otg_adpsns:1;
+	unsigned otg_adpprb:1;
 	/* HOST20 */
-	unsigned uhost_vbusvalid : 1;
-	unsigned uhost_bvalid : 1;
-	unsigned uhost_linestate : 2;
-	unsigned uhost_iddig : 1;
-	unsigned uhost_adpsns : 1;
-	unsigned uhost_adpprb : 1;
-	unsigned reserved1 : 9;
+	unsigned uhost_vbusvalid:1;
+	unsigned uhost_bvalid:1;
+	unsigned uhost_linestate:2;
+	unsigned uhost_iddig:1;
+	unsigned uhost_adpsns:1;
+	unsigned uhost_adpprb:1;
+	unsigned reserved1:9;
 
-}GRF_SOC_STATUS_RK3188, *pGRF_SOC_STATUS_RK3188;
+} GRF_SOC_STATUS_RK3188, *pGRF_SOC_STATUS_RK3188;
 
-typedef volatile struct tag_grf_soc_status1_rk3288
-{
-	unsigned reserved2 : 16;
-	unsigned hsic_ehci_usbsts : 6;
-	unsigned hsic_ehci_lpsmc_state : 4;
-	unsigned reserved1 : 6;
+typedef volatile struct tag_grf_soc_status1_rk3288 {
+	unsigned reserved2:16;
+	unsigned hsic_ehci_usbsts:6;
+	unsigned hsic_ehci_lpsmc_state:4;
+	unsigned reserved1:6;
 
-}GRF_SOC_STATUS1_RK3288, *pGRF_SOC_STATUS1_RK3288;
+} GRF_SOC_STATUS1_RK3288, *pGRF_SOC_STATUS1_RK3288;
 
-typedef volatile struct tag_grf_soc_status2_rk3288
-{
+typedef volatile struct tag_grf_soc_status2_rk3288 {
 	/* HSIC  */
-	unsigned hsic_ehci_xfer_cnt : 11;
-	unsigned hsic_ehci_xfer_prdc : 1;
-	unsigned reserved2 : 1;
+	unsigned hsic_ehci_xfer_cnt:11;
+	unsigned hsic_ehci_xfer_prdc:1;
+	unsigned reserved2:1;
 	/* OTG20  */
-	unsigned otg_vbusvalid : 1;
-	unsigned otg_bvalid : 1;
-	unsigned otg_linestate : 2;
-	unsigned otg_iddig : 1;
-	/* HOST1 DWC_OTG*/
-	unsigned host1_chirp_on : 1;
-	unsigned host1_vbusvalid : 1;
-	unsigned host1_bvalid : 1;
-	unsigned host1_linestate : 2;
-	unsigned host1_iddig : 1;
+	unsigned otg_vbusvalid:1;
+	unsigned otg_bvalid:1;
+	unsigned otg_linestate:2;
+	unsigned otg_iddig:1;
+	/* HOST1 DWC_OTG */
+	unsigned host1_chirp_on:1;
+	unsigned host1_vbusvalid:1;
+	unsigned host1_bvalid:1;
+	unsigned host1_linestate:2;
+	unsigned host1_iddig:1;
 	/* HOST0 OHCI */
-	unsigned host0_ohci_ccs : 1;
-	unsigned host0_ohci_rwe : 1;
-	unsigned host0_ohci_drwe : 1;
-	unsigned host0_linestate : 2;
-	unsigned host0_ohci_rmtwkp : 1;
-	unsigned host0_ohci_bufacc : 1;
-	unsigned reserved1 : 1;
-}GRF_SOC_STATUS2_RK3288, *pGRF_SOC_STATUS2_RK3288;
+	unsigned host0_ohci_ccs:1;
+	unsigned host0_ohci_rwe:1;
+	unsigned host0_ohci_drwe:1;
+	unsigned host0_linestate:2;
+	unsigned host0_ohci_rmtwkp:1;
+	unsigned host0_ohci_bufacc:1;
+	unsigned reserved1:1;
+} GRF_SOC_STATUS2_RK3288, *pGRF_SOC_STATUS2_RK3288;
 
-typedef volatile struct tag_grf_soc_status19_rk3288
-{
-	unsigned host_sidle_ack : 2;
-	unsigned host_mstandby : 1;
-	unsigned host_mwakeup : 1;
-	unsigned host_mwait_out : 1;
-	unsigned host_eoi_out : 2;
-	unsigned host_wakeack : 1;
-	unsigned host_l3_ocp_mconnect : 2;
-	unsigned host_l3_ocp_tactive : 1;
-	unsigned host_l3_ocp_sconnect : 3;
-	unsigned reserved : 9;
+typedef volatile struct tag_grf_soc_status19_rk3288 {
+	unsigned host_sidle_ack:2;
+	unsigned host_mstandby:1;
+	unsigned host_mwakeup:1;
+	unsigned host_mwait_out:1;
+	unsigned host_eoi_out:2;
+	unsigned host_wakeack:1;
+	unsigned host_l3_ocp_mconnect:2;
+	unsigned host_l3_ocp_tactive:1;
+	unsigned host_l3_ocp_sconnect:3;
+	unsigned reserved:9;
 	/* OTG20 PHY STATUS */
-	unsigned otg_chgdet : 1;
-	unsigned otg_fsvplus : 1;
-	unsigned otg_fsvminus : 1;
+	unsigned otg_chgdet:1;
+	unsigned otg_fsvplus:1;
+	unsigned otg_fsvminus:1;
 	/* HOST0 PHY STATUS */
-	unsigned host0_chgdet : 1;
-	unsigned host0_fsvplus : 1;
-	unsigned host0_fsvminus : 1;
+	unsigned host0_chgdet:1;
+	unsigned host0_fsvplus:1;
+	unsigned host0_fsvminus:1;
 	/* HOST1 PHY STATUS */
-	unsigned host1_chgdet : 1;
-	unsigned host1_fsvplus : 1;
-	unsigned host1_fsvminus : 1;
-}GRF_SOC_STATUS19_RK3288, *pGRF_SOC_STATUS19_RK3288;
+	unsigned host1_chgdet:1;
+	unsigned host1_fsvplus:1;
+	unsigned host1_fsvminus:1;
+} GRF_SOC_STATUS19_RK3288, *pGRF_SOC_STATUS19_RK3288;
 
-typedef volatile struct tag_grf_soc_status21_rk3288
-{
-	unsigned reserved : 8;
+typedef volatile struct tag_grf_soc_status21_rk3288 {
+	unsigned reserved:8;
 	/* HOST0 OHCI  */
-	unsigned host0_ohci_globalsuspend : 1;
+	unsigned host0_ohci_globalsuspend:1;
 	/* HOST0 EHCI  */
-	unsigned host0_ehci_bufacc : 1;
-	unsigned host0_ehci_lpsmc_state : 4;
-	unsigned host0_ehci_xfer_prdc : 1;
-	unsigned host0_ehci_xfer_cnt : 11;
-	unsigned host0_ehci_usbsts : 6;
-}GRF_SOC_STATUS21_RK3288, *pGRF_SOC_STATUS21_RK3288;
+	unsigned host0_ehci_bufacc:1;
+	unsigned host0_ehci_lpsmc_state:4;
+	unsigned host0_ehci_xfer_prdc:1;
+	unsigned host0_ehci_xfer_cnt:11;
+	unsigned host0_ehci_usbsts:6;
+} GRF_SOC_STATUS21_RK3288, *pGRF_SOC_STATUS21_RK3288;
 
 #endif
diff --git a/drivers/usb/dwc_otg_310/usbdev_rk.h b/drivers/usb/dwc_otg_310/usbdev_rk.h
index 5812703042ba..f79adac1563f 100755
--- a/drivers/usb/dwc_otg_310/usbdev_rk.h
+++ b/drivers/usb/dwc_otg_310/usbdev_rk.h
@@ -33,7 +33,7 @@
 #define PHY_UART_MODE   (1)
 
 #define USB_STATUS_BVABLID    (1)
-#define USB_STATUS_DPDM	 	  (2)
+#define USB_STATUS_DPDM       (2)
 #define USB_STATUS_ID         (3)
 #define USB_STATUS_UARTMODE   (4)
 #define USB_CHIP_ID           (5)
@@ -54,37 +54,37 @@ extern struct rkehci_platform_data rkehci_pdata_rk3288;
 extern struct rkehci_platform_data rkohci_pdata_rk3288;
 
 struct dwc_otg_platform_data {
-    void *privdata;
-    struct device *dev;
-    struct clk* phyclk;
-    struct clk* ahbclk;
-    struct clk* busclk;
-    struct clk* phyclk_480m;
-    int phy_status;
-    void (*hw_init)(void);
-    void (*phy_suspend)(void* pdata, int suspend);
-    void (*soft_reset)(void);
-    void (*clock_init)(void* pdata);
-    void (*clock_enable)(void* pdata, int enable);
-    void (*power_enable)(int enable);
-    void (*dwc_otg_uart_mode)(void* pdata, int enter_usb_uart_mode);
-    void (*bc_detect_cb)(int bc_type);
-    int (*get_status)(int id);
+	void *privdata;
+	struct device *dev;
+	struct clk *phyclk;
+	struct clk *ahbclk;
+	struct clk *busclk;
+	struct clk *phyclk_480m;
+	int phy_status;
+	void (*hw_init) (void);
+	void (*phy_suspend) (void *pdata, int suspend);
+	void (*soft_reset) (void);
+	void (*clock_init) (void *pdata);
+	void (*clock_enable) (void *pdata, int enable);
+	void (*power_enable) (int enable);
+	void (*dwc_otg_uart_mode) (void *pdata, int enter_usb_uart_mode);
+	void (*bc_detect_cb) (int bc_type);
+	int (*get_status) (int id);
 };
 
-struct rkehci_platform_data{
+struct rkehci_platform_data {
 	struct device *dev;
-	struct clk* hclk_hsic;
-	struct clk* hsic_phy_480m;
-	struct clk* hsic_phy_12m;
-	struct clk* phyclk;
-	struct clk* ahbclk;
-	void (*hw_init)(void);
-	void (*clock_init)(void* pdata);
-	void (*clock_enable)(void *pdata, int enable);
-	void (*phy_suspend)(void* pdata, int suspend);
-	void (*soft_reset)(void);
-	int (*get_status)(int id);
+	struct clk *hclk_hsic;
+	struct clk *hsic_phy_480m;
+	struct clk *hsic_phy_12m;
+	struct clk *phyclk;
+	struct clk *ahbclk;
+	void (*hw_init) (void);
+	void (*clock_init) (void *pdata);
+	void (*clock_enable) (void *pdata, int enable);
+	void (*phy_suspend) (void *pdata, int suspend);
+	void (*soft_reset) (void);
+	int (*get_status) (int id);
 	int clk_status;
 	int phy_status;
 };
@@ -102,7 +102,7 @@ struct dwc_otg_control_usb {
 	pGRF_SOC_STATUS21_RK3288 grf_soc_status21_rk3288;
 	struct gpio *host_gpios;
 	struct gpio *otg_gpios;
-	struct clk* hclk_usb_peri;
+	struct clk *hclk_usb_peri;
 	struct delayed_work usb_det_wakeup_work;
 	struct delayed_work usb_charger_det_work;
 	struct wake_lock usb_wakelock;
diff --git a/drivers/usb/dwc_otg_310/usbdev_rk30.c b/drivers/usb/dwc_otg_310/usbdev_rk30.c
index e93fbf804b67..0f3c134c9e55 100755
--- a/drivers/usb/dwc_otg_310/usbdev_rk30.c
+++ b/drivers/usb/dwc_otg_310/usbdev_rk30.c
@@ -10,10 +10,10 @@ static struct dwc_otg_control_usb *control_usb;
 static void usb20otg_hw_init(void)
 {
 #ifndef CONFIG_USB20_HOST
-	//enable soft control
-	control_usb->grf_uoc1_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-	// enter suspend
-	control_usb->grf_uoc1_base->CON3 = 0x2A|(0x3F<<16);
+	/* enable soft control */
+	control_usb->grf_uoc1_base->CON2 = (0x01 << 2) | ((0x01 << 2) << 16);
+	/* enter suspend */
+	control_usb->grf_uoc1_base->CON3 = 0x2A | (0x3F << 16);
 #endif
 	/* usb phy config init
 	 * usb phy enter usb mode */
@@ -21,24 +21,24 @@ static void usb20otg_hw_init(void)
 
 	/* other haredware init,include:
 	 * DRV_VBUS GPIO init */
-	if(gpio_get_value(control_usb->otg_gpios->gpio)){
+	if (gpio_get_value(control_usb->otg_gpios->gpio))
 		gpio_set_value(control_usb->otg_gpios->gpio, 0);
-	}
 }
 
-static void usb20otg_phy_suspend(void* pdata, int suspend)
+static void usb20otg_phy_suspend(void *pdata, int suspend)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-
-	if(suspend){
-		//enable soft control
-		control_usb->grf_uoc0_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-		// enter suspend
-		control_usb->grf_uoc0_base->CON3 = 0x2A|(0x3F<<16);
+	struct dwc_otg_platform_data *usbpdata = pdata;
+
+	if (suspend) {
+		/* enable soft control */
+		control_usb->grf_uoc0_base->CON2 =
+		    (0x01 << 2) | ((0x01 << 2) << 16);
+		/* enter suspend */
+		control_usb->grf_uoc0_base->CON3 = 0x2A | (0x3F << 16);
 		usbpdata->phy_status = 1;
-	}else{
-		// exit suspend.
-		control_usb->grf_uoc0_base->CON2 = ((0x01<<2)<<16);
+	} else {
+		/* exit suspend */
+		control_usb->grf_uoc0_base->CON2 = ((0x01 << 2) << 16);
 		usbpdata->phy_status = 0;
 	}
 }
@@ -47,10 +47,10 @@ static void usb20otg_soft_reset(void)
 {
 }
 
-static void usb20otg_clock_init(void* pdata)
+static void usb20otg_clock_init(void *pdata)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-	struct clk* ahbclk,*phyclk;
+	struct dwc_otg_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk;
 
 	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb0");
 	if (IS_ERR(ahbclk)) {
@@ -68,14 +68,14 @@ static void usb20otg_clock_init(void* pdata)
 	usbpdata->ahbclk = ahbclk;
 }
 
-static void usb20otg_clock_enable(void* pdata, int enable)
+static void usb20otg_clock_enable(void *pdata, int enable)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
+	struct dwc_otg_platform_data *usbpdata = pdata;
 
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 	}
@@ -85,39 +85,39 @@ static int usb20otg_get_status(int id)
 {
 	int ret = -1;
 
-	switch(id){
-		case USB_STATUS_BVABLID:
-			// bvalid in grf
-			ret = control_usb->grf_soc_status0_rk3188->otg_bvalid;
-			break;
-		case USB_STATUS_DPDM:
-			// dpdm in grf
-			ret = control_usb->grf_soc_status0_rk3188->otg_linestate;
-			break;
-		case USB_STATUS_ID:
-			// id in grf
-			ret = control_usb->grf_soc_status0_rk3188->otg_iddig;
-			break;
-		case USB_CHIP_ID:
-			ret = control_usb->chip_id;
-			break;
-		case USB_REMOTE_WAKEUP:
-			ret = control_usb->remote_wakeup;
-			break;
-		case USB_IRQ_WAKEUP:
-			ret = control_usb->usb_irq_wakeup;
-			break;
-		default:
-			break;
+	switch (id) {
+	case USB_STATUS_BVABLID:
+		/* bvalid in grf */
+		ret = control_usb->grf_soc_status0_rk3188->otg_bvalid;
+		break;
+	case USB_STATUS_DPDM:
+		/* dpdm in grf */
+		ret = control_usb->grf_soc_status0_rk3188->otg_linestate;
+		break;
+	case USB_STATUS_ID:
+		/* id in grf */
+		ret = control_usb->grf_soc_status0_rk3188->otg_iddig;
+		break;
+	case USB_CHIP_ID:
+		ret = control_usb->chip_id;
+		break;
+	case USB_REMOTE_WAKEUP:
+		ret = control_usb->remote_wakeup;
+		break;
+	case USB_IRQ_WAKEUP:
+		ret = control_usb->usb_irq_wakeup;
+		break;
+	default:
+		break;
 	}
 
 	return ret;
 }
 
 #ifdef CONFIG_RK_USB_UART
-static void dwc_otg_uart_mode(void* pdata, int enter_usb_uart_mode)
+static void dwc_otg_uart_mode(void *pdata, int enter_usb_uart_mode)
 {
-	if(1 == enter_usb_uart_mode){
+	if (1 == enter_usb_uart_mode) {
 		/* enter uart mode
 		 * note: can't disable otg here! If otg disable, the ID change
 		 * interrupt can't be triggered when otg cable connect without
@@ -125,7 +125,7 @@ static void dwc_otg_uart_mode(void* pdata, int enter_usb_uart_mode)
 		 */
 		/* bypass dm, enter uart mode */
 		control_usb->grf_uoc0_base->CON0 = (0x0300 | (0x0300 << 16));
-	}else if(0 == enter_usb_uart_mode){
+	} else if (0 == enter_usb_uart_mode) {
 		/* enter usb mode */
 		control_usb->grf_uoc0_base->CON0 = (0x0300 << 16);
 	}
@@ -134,9 +134,11 @@ static void dwc_otg_uart_mode(void* pdata, int enter_usb_uart_mode)
 
 static void usb20otg_power_enable(int enable)
 {
-	if(0 == enable){//disable otg_drv power
+	if (0 == enable) {
+		/* disable otg_drv power */
 		gpio_set_value(control_usb->otg_gpios->gpio, 0);
-	}else if(1 == enable){//enable otg_drv power
+	} else if (1 == enable) {
+		/* enable otg_drv power */
 		gpio_set_value(control_usb->otg_gpios->gpio, 1);
 	}
 }
@@ -156,7 +158,7 @@ struct dwc_otg_platform_data usb20otg_pdata_rk3188 = {
 #ifdef CONFIG_RK_USB_UART
 	.dwc_otg_uart_mode = dwc_otg_uart_mode,
 #endif
-    .bc_detect_cb=usb20otg_battery_charger_detect_cb,
+	.bc_detect_cb = usb20otg_battery_charger_detect_cb,
 };
 
 #endif
@@ -168,24 +170,24 @@ static void usb20host_hw_init(void)
 
 	/* other haredware init,include:
 	 * DRV_VBUS GPIO init */
-	if(!gpio_get_value(control_usb->host_gpios->gpio)){
+	if (!gpio_get_value(control_usb->host_gpios->gpio))
 		gpio_set_value(control_usb->host_gpios->gpio, 1);
-	}
 }
 
-static void usb20host_phy_suspend(void* pdata, int suspend)
+static void usb20host_phy_suspend(void *pdata, int suspend)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-
-	if(suspend){
-		// enable soft control
-		control_usb->grf_uoc1_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-		// enter suspend
-		control_usb->grf_uoc1_base->CON3 = 0x2A|(0x3F<<16); 
+	struct dwc_otg_platform_data *usbpdata = pdata;
+
+	if (suspend) {
+		/* enable soft control */
+		control_usb->grf_uoc1_base->CON2 =
+		    (0x01 << 2) | ((0x01 << 2) << 16);
+		/* enter suspend */
+		control_usb->grf_uoc1_base->CON3 = 0x2A | (0x3F << 16);
 		usbpdata->phy_status = 1;
-	}else{
-		//exit suspend.
-		control_usb->grf_uoc1_base->CON2 = ((0x01<<2)<<16);
+	} else {
+		/* exit suspend */
+		control_usb->grf_uoc1_base->CON2 = ((0x01 << 2) << 16);
 		usbpdata->phy_status = 0;
 	}
 }
@@ -194,10 +196,10 @@ static void usb20host_soft_reset(void)
 {
 }
 
-static void usb20host_clock_init(void* pdata)
+static void usb20host_clock_init(void *pdata)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-	struct clk* ahbclk,*phyclk;
+	struct dwc_otg_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk;
 
 	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb1");
 	if (IS_ERR(ahbclk)) {
@@ -215,14 +217,14 @@ static void usb20host_clock_init(void* pdata)
 	usbpdata->ahbclk = ahbclk;
 }
 
-static void usb20host_clock_enable(void* pdata, int enable)
+static void usb20host_clock_enable(void *pdata, int enable)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
+	struct dwc_otg_platform_data *usbpdata = pdata;
 
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 	}
@@ -232,30 +234,30 @@ static int usb20host_get_status(int id)
 {
 	int ret = -1;
 
-	switch(id){
-		case USB_STATUS_BVABLID:
-			// bvalid in grf
-			ret = control_usb->grf_soc_status0_rk3188->uhost_bvalid;
-			break;
-		case USB_STATUS_DPDM:
-			// dpdm in grf
-			ret = control_usb->grf_soc_status0_rk3188->uhost_linestate;
-			break;
-		case USB_STATUS_ID:
-			// id in grf
-			ret = control_usb->grf_soc_status0_rk3188->uhost_iddig;
-			break;
-		case USB_CHIP_ID:
-			ret = control_usb->chip_id;
-			break;
-		case USB_REMOTE_WAKEUP:
-			ret = control_usb->remote_wakeup;
-			break;
-		case USB_IRQ_WAKEUP:
-			ret = control_usb->usb_irq_wakeup;
-			break;
-		default:
-			break;
+	switch (id) {
+	case USB_STATUS_BVABLID:
+		/* bvalid in grf */
+		ret = control_usb->grf_soc_status0_rk3188->uhost_bvalid;
+		break;
+	case USB_STATUS_DPDM:
+		/* dpdm in grf */
+		ret = control_usb->grf_soc_status0_rk3188->uhost_linestate;
+		break;
+	case USB_STATUS_ID:
+		/* id in grf */
+		ret = control_usb->grf_soc_status0_rk3188->uhost_iddig;
+		break;
+	case USB_CHIP_ID:
+		ret = control_usb->chip_id;
+		break;
+	case USB_REMOTE_WAKEUP:
+		ret = control_usb->remote_wakeup;
+		break;
+	case USB_IRQ_WAKEUP:
+		ret = control_usb->usb_irq_wakeup;
+		break;
+	default:
+		break;
 	}
 
 	return ret;
@@ -263,9 +265,11 @@ static int usb20host_get_status(int id)
 
 static void usb20host_power_enable(int enable)
 {
-	if(0 == enable){//disable host_drv power
-		//do not disable power in default
-	}else if(1 == enable){//enable host_drv power
+	if (0 == enable) {
+		/* disable host_drv power */
+		/* do not disable power in default */
+	} else if (1 == enable) {
+		/* enable host_drv power */
 		gpio_set_value(control_usb->host_gpios->gpio, 1);
 	}
 }
@@ -288,16 +292,16 @@ struct dwc_otg_platform_data usb20host_pdata_rk3188 = {
 #ifdef CONFIG_USB_EHCI_RKHSIC
 static void rk_hsic_hw_init(void)
 {
-	// usb phy config init
-	// hsic phy config init, set hsicphy_txsrtune
-	control_usb->grf_uoc2_base->CON0 = ((0xf<<6)<<16)|(0xf<<6);
+	/* usb phy config init
+	 * hsic phy config init, set hsicphy_txsrtune */
+	control_usb->grf_uoc2_base->CON0 = ((0xf << 6) << 16) | (0xf << 6);
 
 	/* other haredware init
 	 * set common_on, in suspend mode, otg/host PLL blocks remain powered
 	 * for RK3168 set control_usb->grf_uoc0_base->CON0 = (1<<16)|0;
 	 * for Rk3188 set control_usb->grf_uoc1_base->CON0 = (1<<16)|0;
 	 */
-	control_usb->grf_uoc1_base->CON0 = (1<<16)|0;
+	control_usb->grf_uoc1_base->CON0 = (1 << 16) | 0;
 
 	/* change INCR to INCR16 or INCR8(beats less than 16)
 	 * or INCR4(beats less than 8) or SINGLE(beats less than 4)
@@ -305,13 +309,13 @@ static void rk_hsic_hw_init(void)
 	control_usb->grf_uoc3_base->CON0 = 0x00ff00bc;
 }
 
-static void rk_hsic_clock_init(void* pdata)
+static void rk_hsic_clock_init(void *pdata)
 {
 	/* By default, hsicphy_480m's parent is otg phy 480MHz clk
 	 * rk3188 must use host phy 480MHz clk, because if otg bypass
 	 * to uart mode, otg phy 480MHz clk will be closed automatically
 	 */
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 	struct clk *ahbclk, *phyclk480m_hsic, *phyclk12m_hsic, *phyclk_usbphy1;
 
 	phyclk480m_hsic = devm_clk_get(usbpdata->dev, "hsicphy_480m");
@@ -339,24 +343,24 @@ static void rk_hsic_clock_init(void* pdata)
 	}
 
 	clk_set_parent(phyclk480m_hsic, phyclk_usbphy1);
-	
+
 	usbpdata->hclk_hsic = ahbclk;
 	usbpdata->hsic_phy_480m = phyclk480m_hsic;
 	usbpdata->hsic_phy_12m = phyclk12m_hsic;
 }
 
-static void rk_hsic_clock_enable(void* pdata, int enable)
+static void rk_hsic_clock_enable(void *pdata, int enable)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 
-	if(enable == usbpdata->clk_status)
+	if (enable == usbpdata->clk_status)
 		return;
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->hclk_hsic);
 		clk_prepare_enable(usbpdata->hsic_phy_480m);
 		clk_prepare_enable(usbpdata->hsic_phy_12m);
 		usbpdata->clk_status = 1;
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->hclk_hsic);
 		clk_disable_unprepare(usbpdata->hsic_phy_480m);
 		clk_disable_unprepare(usbpdata->hsic_phy_12m);
@@ -383,9 +387,9 @@ struct rkehci_platform_data rkhsic_pdata_rk3188 = {
 
 #define WAKE_LOCK_TIMEOUT (HZ * 10)
 
-inline static void do_wakeup(struct work_struct *work)
+static inline void do_wakeup(struct work_struct *work)
 {
-	rk_send_wakeup_key(); // wake up the system
+	rk_send_wakeup_key();	/* wake up the system */
 }
 
 /********** handler for bvalid irq **********/
@@ -399,9 +403,11 @@ static irqreturn_t bvalid_irq_handler(int irq, void *dev_id)
 	dwc_otg_uart_mode(NULL, PHY_USB_MODE);
 #endif
 
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_timeout(&control_usb->usb_wakelock, WAKE_LOCK_TIMEOUT);
-		schedule_delayed_work(&control_usb->usb_det_wakeup_work, HZ/10);
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_timeout(&control_usb->usb_wakelock,
+				  WAKE_LOCK_TIMEOUT);
+		schedule_delayed_work(&control_usb->usb_det_wakeup_work,
+				      HZ / 10);
 	}
 
 	return IRQ_HANDLED;
@@ -413,15 +419,17 @@ static int otg_irq_detect_init(struct platform_device *pdev)
 	int ret = 0;
 	int irq = 0;
 
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_init(&control_usb->usb_wakelock, WAKE_LOCK_SUSPEND, "usb_detect");
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_init(&control_usb->usb_wakelock, WAKE_LOCK_SUSPEND,
+			       "usb_detect");
 		INIT_DELAYED_WORK(&control_usb->usb_det_wakeup_work, do_wakeup);
 	}
 
 	irq = platform_get_irq_byname(pdev, "otg_bvalid");
 	if (irq > 0) {
-		ret = request_irq(irq, bvalid_irq_handler, 0, "otg_bvalid", NULL);
-		if(ret < 0){
+		ret =
+		    request_irq(irq, bvalid_irq_handler, 0, "otg_bvalid", NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
 		}
@@ -429,9 +437,8 @@ static int otg_irq_detect_init(struct platform_device *pdev)
 		/* clear & enable bvalid irq */
 		control_usb->grf_uoc0_base->CON3 = (3 << 30) | (3 << 14);
 
-		if(control_usb->usb_irq_wakeup){
+		if (control_usb->usb_irq_wakeup)
 			enable_irq_wake(irq);
-		}
 	}
 
 	return ret;
@@ -448,49 +455,50 @@ static int usb_grf_ioremap(struct platform_device *pdev)
 	void *grf_uoc3_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_SOC_STATUS0");
+					   "GRF_SOC_STATUS0");
 	grf_soc_status0 = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_soc_status0)){
+	if (IS_ERR(grf_soc_status0)) {
 		ret = PTR_ERR(grf_soc_status0);
 		return ret;
 	}
-	control_usb->grf_soc_status0_rk3188 = (pGRF_SOC_STATUS_RK3188)grf_soc_status0;
+	control_usb->grf_soc_status0_rk3188 =
+	    (pGRF_SOC_STATUS_RK3188) grf_soc_status0;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC0_BASE");
+					   "GRF_UOC0_BASE");
 	grf_uoc0_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc0_base)){
+	if (IS_ERR(grf_uoc0_base)) {
 		ret = PTR_ERR(grf_uoc0_base);
 		return ret;
 	}
-	control_usb->grf_uoc0_base = (pGRF_UOC0_REG)grf_uoc0_base;
+	control_usb->grf_uoc0_base = (pGRF_UOC0_REG) grf_uoc0_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC1_BASE");
+					   "GRF_UOC1_BASE");
 	grf_uoc1_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc1_base)){
+	if (IS_ERR(grf_uoc1_base)) {
 		ret = PTR_ERR(grf_uoc1_base);
 		return ret;
 	}
-	control_usb->grf_uoc1_base = (pGRF_UOC1_REG)grf_uoc1_base;
+	control_usb->grf_uoc1_base = (pGRF_UOC1_REG) grf_uoc1_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC2_BASE");
+					   "GRF_UOC2_BASE");
 	grf_uoc2_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc2_base)){
+	if (IS_ERR(grf_uoc2_base)) {
 		ret = PTR_ERR(grf_uoc2_base);
 		return ret;
 	}
-	control_usb->grf_uoc2_base = (pGRF_UOC2_REG)grf_uoc2_base;
+	control_usb->grf_uoc2_base = (pGRF_UOC2_REG) grf_uoc2_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC3_BASE");
+					   "GRF_UOC3_BASE");
 	grf_uoc3_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc3_base)){
+	if (IS_ERR(grf_uoc3_base)) {
 		ret = PTR_ERR(grf_uoc3_base);
 		return ret;
 	}
-	control_usb->grf_uoc3_base = (pGRF_UOC3_REG)grf_uoc3_base;
+	control_usb->grf_uoc3_base = (pGRF_UOC3_REG) grf_uoc3_base;
 
 	return ret;
 }
@@ -499,10 +507,11 @@ static int usb_grf_ioremap(struct platform_device *pdev)
 
 static const struct of_device_id dwc_otg_control_usb_id_table[] = {
 	{
-		.compatible = "rockchip,rk3188-dwc-control-usb",
-	},
-	{ },
+	 .compatible = "rockchip,rk3188-dwc-control-usb",
+	 },
+	{},
 };
+
 MODULE_DEVICE_TABLE(of, dwc_otg_control_usb_id_table);
 #endif
 
@@ -510,22 +519,23 @@ static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 {
 	int gpio, err;
 	struct device_node *np = pdev->dev.of_node;
-	struct clk* hclk_usb_peri;
+	struct clk *hclk_usb_peri;
 	int ret = 0;
 
-	control_usb = devm_kzalloc(&pdev->dev, sizeof(*control_usb),GFP_KERNEL);
+	control_usb =
+	    devm_kzalloc(&pdev->dev, sizeof(*control_usb), GFP_KERNEL);
 
 	if (!control_usb) {
 		dev_err(&pdev->dev, "unable to alloc memory for control usb\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto err1;
 	}
 
 	control_usb->chip_id = RK3188_USB_CTLR;
 	control_usb->remote_wakeup = of_property_read_bool(np,
-		"rockchip,remote_wakeup");
+							   "rockchip,remote_wakeup");
 	control_usb->usb_irq_wakeup = of_property_read_bool(np,
-		"rockchip,usb_irq_wakeup");
+							    "rockchip,usb_irq_wakeup");
 
 	hclk_usb_peri = devm_clk_get(&pdev->dev, "hclk_usb_peri");
 	if (IS_ERR(hclk_usb_peri)) {
@@ -538,21 +548,22 @@ static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 	clk_prepare_enable(hclk_usb_peri);
 
 	ret = usb_grf_ioremap(pdev);
-	if(ret){
+	if (ret) {
 		dev_err(&pdev->dev, "Failed to ioremap usb grf\n");
 		goto err2;
 	}
 
 	/* init host gpio */
-	control_usb->host_gpios = devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
-	if(!control_usb->host_gpios){
+	control_usb->host_gpios =
+	    devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
+	if (!control_usb->host_gpios) {
 		dev_err(&pdev->dev, "unable to alloc memory for host_gpios\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto err2;
 	}
 
-	gpio =  of_get_named_gpio(np, "gpios", 0);
-	if(!gpio_is_valid(gpio)){
+	gpio = of_get_named_gpio(np, "gpios", 0);
+	if (!gpio_is_valid(gpio)) {
 		dev_err(&pdev->dev, "invalid host gpio%d\n", gpio);
 		ret = -EINVAL;
 		goto err2;
@@ -563,23 +574,23 @@ static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 	err = devm_gpio_request(&pdev->dev, gpio, "host_drv_gpio");
 	if (err) {
 		dev_err(&pdev->dev,
-			"failed to request GPIO%d for host_drv\n",
-			gpio);
+			"failed to request GPIO%d for host_drv\n", gpio);
 		ret = err;
 		goto err2;
 	}
 	gpio_direction_output(control_usb->host_gpios->gpio, 1);
 
 	/* init otg gpio */
-	control_usb->otg_gpios = devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
-	if(!control_usb->otg_gpios){
+	control_usb->otg_gpios =
+	    devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
+	if (!control_usb->otg_gpios) {
 		dev_err(&pdev->dev, "unable to alloc memory for otg_gpios\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto err2;
 	}
 
-	gpio =  of_get_named_gpio(np, "gpios", 1);
-	if(!gpio_is_valid(gpio)){
+	gpio = of_get_named_gpio(np, "gpios", 1);
+	if (!gpio_is_valid(gpio)) {
 		dev_err(&pdev->dev, "invalid otg gpio%d\n", gpio);
 		ret = -EINVAL;
 		goto err2;
@@ -588,8 +599,7 @@ static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 	err = devm_gpio_request(&pdev->dev, gpio, "otg_drv_gpio");
 	if (err) {
 		dev_err(&pdev->dev,
-			"failed to request GPIO%d for otg_drv\n",
-			gpio);
+			"failed to request GPIO%d for otg_drv\n", gpio);
 		ret = err;
 		goto err2;
 	}
@@ -614,19 +624,20 @@ static int dwc_otg_control_usb_remove(struct platform_device *pdev)
 }
 
 static struct platform_driver dwc_otg_control_usb_driver = {
-	.probe		= dwc_otg_control_usb_probe,
-	.remove		= dwc_otg_control_usb_remove,
-	.driver		= {
-		.name	= "rk3188-dwc-control-usb",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(dwc_otg_control_usb_id_table),
-	},
+	.probe = dwc_otg_control_usb_probe,
+	.remove = dwc_otg_control_usb_remove,
+	.driver = {
+		   .name = "rk3188-dwc-control-usb",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(dwc_otg_control_usb_id_table),
+		   },
 };
 
 static int __init dwc_otg_control_usb_init(void)
 {
 	return platform_driver_register(&dwc_otg_control_usb_driver);
 }
+
 subsys_initcall(dwc_otg_control_usb_init);
 
 static void __exit dwc_otg_control_usb_exit(void)
diff --git a/drivers/usb/dwc_otg_310/usbdev_rk3190_grf_regs.h b/drivers/usb/dwc_otg_310/usbdev_rk3190_grf_regs.h
index a495be6e4730..ee14bb1b22e6 100755
--- a/drivers/usb/dwc_otg_310/usbdev_rk3190_grf_regs.h
+++ b/drivers/usb/dwc_otg_310/usbdev_rk3190_grf_regs.h
@@ -11,86 +11,79 @@
 #define GRF_UOC1_BASE (GRF_REG_BASE + GRF_UOC1_CON0)
 #define GRF_UOC2_BASE (GRF_REG_BASE + GRF_UOC2_CON0)
 
-typedef volatile struct tag_grf_uoc0_reg
-{
-    u32 CON0;
-    u32 CON1;
-    u32 CON2;
-    u32 CON3;
-} GRF_UOC0_REG ,*pGRF_UOC0_REG;
+typedef volatile struct tag_grf_uoc0_reg {
+	u32 CON0;
+	u32 CON1;
+	u32 CON2;
+	u32 CON3;
+} GRF_UOC0_REG, *pGRF_UOC0_REG;
 
-typedef volatile struct tag_grf_uoc1_reg
-{
-    u32 CON0;
-    u32 CON1;
-} GRF_UOC1_REG ,*pGRF_UOC1_REG;
+typedef volatile struct tag_grf_uoc1_reg {
+	u32 CON0;
+	u32 CON1;
+} GRF_UOC1_REG, *pGRF_UOC1_REG;
 
-typedef volatile struct tag_grf_hsic_reg
-{
-    u32 PHY_CON0;
-    u32 PHY_CON1;
-    u32 CTRLER_CON0;
-    u32 CTRLER_CON1;
-} GRF_HSIC_REG ,*pGRF_HSIC_REG;
+typedef volatile struct tag_grf_hsic_reg {
+	u32 PHY_CON0;
+	u32 PHY_CON1;
+	u32 CTRLER_CON0;
+	u32 CTRLER_CON1;
+} GRF_HSIC_REG, *pGRF_HSIC_REG;
 
-typedef volatile struct tag_grf_usbphy_reg
-{
-    u32 CON0;
-    u32 CON1;
-    u32 CON2;
-    u32 CON3;
-    u32 CON4;
-    u32 CON5;
-    u32 CON6;
-    u32 CON7;
-    u32 CON8;
-    u32 CON9;
-    u32 CON10;
-    u32 CON11;
-} GRF_USBPHY_REG ,*pGRF_USBPHY_REG;
+typedef volatile struct tag_grf_usbphy_reg {
+	u32 CON0;
+	u32 CON1;
+	u32 CON2;
+	u32 CON3;
+	u32 CON4;
+	u32 CON5;
+	u32 CON6;
+	u32 CON7;
+	u32 CON8;
+	u32 CON9;
+	u32 CON10;
+	u32 CON11;
+} GRF_USBPHY_REG, *pGRF_USBPHY_REG;
 
-
-typedef volatile struct tag_grf_soc_status0
-{
-    unsigned reserved2 : 9;
-    //Otg20 VBus Valid
-    unsigned otg_vbusvalid : 1;
-    //Otg20 BValid
-    unsigned otg_bvalid : 1;
-    //Otg20 Linestate
-    unsigned otg_linestate : 2;
-    //Otg20 Iddig
-    unsigned otg_iddig : 1;
-    //Otg20 ADP Sense Signal
-    unsigned otg_adpsns : 1;
-    //Otg20 ADP Probe Signal
-    unsigned otg_adpprb : 1;
-    //Host20 VBus Valid
-    unsigned uhost_vbusvalid : 1;
-    //Host20 BValid
-    unsigned uhost_bvalid : 1;
-    //Host20 Linestate
-    unsigned uhost_linestate : 2;
-    //Host20 Iddig
-    unsigned uhost_iddig : 1;
-    //Host20 Adp sense
-    unsigned uhost_adpsns : 1;
-    //Host20 Adp Probe
-    unsigned uhost_adpprb : 1;
-    //INNO phy dcp detect
-    unsigned inno_dcp_det : 1;
-    //INNO phy cp detect
-    unsigned inno_cp_det : 1;
-    //INNO phy dp attached
-    unsigned inno_dp_attch : 1;
-    //Synopsis phy BC CHGDET0
-    unsigned snps_chgdet : 1;
-    //Synopsis phy FSVMINUS
-    unsigned snps_fsvminus : 1;
-    //Synopsis phy FSVPLUS
-    unsigned snps_fsvplus : 1; 
-    unsigned reserved1 : 3;
-} GRF_SOC_STATUS,*pGRF_SOC_STATUS;
+typedef volatile struct tag_grf_soc_status0 {
+	unsigned reserved2:9;
+	/* Otg20 VBus Valid */
+	unsigned otg_vbusvalid:1;
+	/* Otg20 BValid */
+	unsigned otg_bvalid:1;
+	/* Otg20 Linestate */
+	unsigned otg_linestate:2;
+	/* Otg20 Iddig */
+	unsigned otg_iddig:1;
+	/* Otg20 ADP Sense Signal */
+	unsigned otg_adpsns:1;
+	/* Otg20 ADP Probe Signal */
+	unsigned otg_adpprb:1;
+	/* Host20 VBus Valid */
+	unsigned uhost_vbusvalid:1;
+	/* Host20 BValid */
+	unsigned uhost_bvalid:1;
+	/* Host20 Linestate */
+	unsigned uhost_linestate:2;
+	/* Host20 Iddig */
+	unsigned uhost_iddig:1;
+	/* Host20 Adp sense */
+	unsigned uhost_adpsns:1;
+	/* Host20 Adp Probe */
+	unsigned uhost_adpprb:1;
+	/* INNO phy dcp detect */
+	unsigned inno_dcp_det:1;
+	/* INNO phy cp detect */
+	unsigned inno_cp_det:1;
+	/* INNO phy dp attached */
+	unsigned inno_dp_attch:1;
+	/* Synopsis phy BC CHGDET0 */
+	unsigned snps_chgdet:1;
+	/* Synopsis phy FSVMINUS */
+	unsigned snps_fsvminus:1;
+	/* Synopsis phy FSVPLUS */
+	unsigned snps_fsvplus:1;
+	unsigned reserved1:3;
+} GRF_SOC_STATUS, *pGRF_SOC_STATUS;
 
 #endif
-
diff --git a/drivers/usb/dwc_otg_310/usbdev_rk32.c b/drivers/usb/dwc_otg_310/usbdev_rk32.c
index e06ce4b3c3a8..83167500d7cc 100755
--- a/drivers/usb/dwc_otg_310/usbdev_rk32.c
+++ b/drivers/usb/dwc_otg_310/usbdev_rk32.c
@@ -8,10 +8,10 @@ static struct dwc_otg_control_usb *control_usb;
 static void usb20otg_hw_init(void)
 {
 #ifndef CONFIG_USB20_HOST
-	//enable soft control
-	control_usb->grf_uoc2_base->CON2 = (0x01<<2)|((0x01<<2)<<16);	
-	// enter suspend
-	control_usb->grf_uoc2_base->CON3 = 0x2A|(0x3F<<16); 	
+	/* enable soft control */
+	control_usb->grf_uoc2_base->CON2 = (0x01 << 2) | ((0x01 << 2) << 16);
+	/* enter suspend */
+	control_usb->grf_uoc2_base->CON3 = 0x2A | (0x3F << 16);
 #endif
 	/* usb phy config init
 	 * usb phy enter usb mode */
@@ -19,26 +19,26 @@ static void usb20otg_hw_init(void)
 
 	/* other haredware init,include:
 	 * DRV_VBUS GPIO init */
-	if(gpio_is_valid(control_usb->otg_gpios->gpio)){
-		if(gpio_get_value(control_usb->otg_gpios->gpio)){
+	if (gpio_is_valid(control_usb->otg_gpios->gpio)) {
+		if (gpio_get_value(control_usb->otg_gpios->gpio))
 			gpio_set_value(control_usb->otg_gpios->gpio, 0);
-		}
 	}
 }
 
-static void usb20otg_phy_suspend(void* pdata, int suspend)
+static void usb20otg_phy_suspend(void *pdata, int suspend)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-
-	if(suspend){
-		//enable soft control
-		control_usb->grf_uoc0_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-		//enter suspend
-		control_usb->grf_uoc0_base->CON3 = 0x2A|(0x3F<<16);
+	struct dwc_otg_platform_data *usbpdata = pdata;
+
+	if (suspend) {
+		/* enable soft control */
+		control_usb->grf_uoc0_base->CON2 =
+		    (0x01 << 2) | ((0x01 << 2) << 16);
+		/* enter suspend */
+		control_usb->grf_uoc0_base->CON3 = 0x2A | (0x3F << 16);
 		usbpdata->phy_status = 1;
-	}else{
-		// exit suspend.
-		control_usb->grf_uoc0_base->CON2 = ((0x01<<2)<<16);
+	} else {
+		/* exit suspend */
+		control_usb->grf_uoc0_base->CON2 = ((0x01 << 2) << 16);
 		usbpdata->phy_status = 0;
 	}
 }
@@ -56,10 +56,10 @@ static void usb20otg_soft_reset(void)
 	mdelay(2);
 }
 
-static void usb20otg_clock_init(void* pdata)
+static void usb20otg_clock_init(void *pdata)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-	struct clk* ahbclk,*phyclk;
+	struct dwc_otg_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk;
 
 	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb0");
 	if (IS_ERR(ahbclk)) {
@@ -77,14 +77,14 @@ static void usb20otg_clock_init(void* pdata)
 	usbpdata->ahbclk = ahbclk;
 }
 
-static void usb20otg_clock_enable(void* pdata, int enable)
+static void usb20otg_clock_enable(void *pdata, int enable)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
+	struct dwc_otg_platform_data *usbpdata = pdata;
 
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 	}
@@ -94,43 +94,43 @@ static int usb20otg_get_status(int id)
 {
 	int ret = -1;
 
-	switch(id){
-		case USB_STATUS_BVABLID:
-			// bvalid in grf
-			ret = control_usb->grf_soc_status2_rk3288->otg_bvalid;
-			break;
-		case USB_STATUS_DPDM:
-			// dpdm in grf
-			ret = control_usb->grf_soc_status2_rk3288->otg_linestate;
-			break;
-		case USB_STATUS_ID:
-			// id in grf
-			ret = control_usb->grf_soc_status2_rk3288->otg_iddig;
-			break;
-		case USB_CHIP_ID:
-			ret = control_usb->chip_id;
-			break;
-		case USB_REMOTE_WAKEUP:
-			ret = control_usb->remote_wakeup;
-			break;
-		case USB_IRQ_WAKEUP:
-			ret = control_usb->usb_irq_wakeup;
-			break;
-		default:
-			break;
+	switch (id) {
+	case USB_STATUS_BVABLID:
+		/* bvalid in grf */
+		ret = control_usb->grf_soc_status2_rk3288->otg_bvalid;
+		break;
+	case USB_STATUS_DPDM:
+		/* dpdm in grf */
+		ret = control_usb->grf_soc_status2_rk3288->otg_linestate;
+		break;
+	case USB_STATUS_ID:
+		/* id in grf */
+		ret = control_usb->grf_soc_status2_rk3288->otg_iddig;
+		break;
+	case USB_CHIP_ID:
+		ret = control_usb->chip_id;
+		break;
+	case USB_REMOTE_WAKEUP:
+		ret = control_usb->remote_wakeup;
+		break;
+	case USB_IRQ_WAKEUP:
+		ret = control_usb->usb_irq_wakeup;
+		break;
+	default:
+		break;
 	}
 
 	return ret;
 }
 
 #ifdef CONFIG_RK_USB_UART
-static void dwc_otg_uart_mode(void* pdata, int enter_usb_uart_mode)
+static void dwc_otg_uart_mode(void *pdata, int enter_usb_uart_mode)
 {
-	if(1 == enter_usb_uart_mode){
-		/* bypass dm, enter uart mode*/
+	if (1 == enter_usb_uart_mode) {
+		/* bypass dm, enter uart mode */
 		control_usb->grf_uoc0_base->CON3 = (0x00c0 | (0x00c0 << 16));
-	
-	}else if(0 == enter_usb_uart_mode){
+
+	} else if (0 == enter_usb_uart_mode) {
 		/* enter usb mode */
 		control_usb->grf_uoc0_base->CON3 = (0x00c0 << 16);
 	}
@@ -139,16 +139,17 @@ static void dwc_otg_uart_mode(void* pdata, int enter_usb_uart_mode)
 
 static void usb20otg_power_enable(int enable)
 {
-	if(0 == enable){//disable otg_drv power
-		if(gpio_is_valid(control_usb->otg_gpios->gpio))
+	if (0 == enable) {
+		/* disable otg_drv power */
+		if (gpio_is_valid(control_usb->otg_gpios->gpio))
 			gpio_set_value(control_usb->otg_gpios->gpio, 0);
-	}else if(1 == enable){//enable otg_drv power
-		if(gpio_is_valid(control_usb->otg_gpios->gpio))
+	} else if (1 == enable) {
+		/* enable otg_drv power */
+		if (gpio_is_valid(control_usb->otg_gpios->gpio))
 			gpio_set_value(control_usb->otg_gpios->gpio, 1);
 	}
 }
 
-
 struct dwc_otg_platform_data usb20otg_pdata_rk3288 = {
 	.phyclk = NULL,
 	.ahbclk = NULL,
@@ -164,7 +165,7 @@ struct dwc_otg_platform_data usb20otg_pdata_rk3288 = {
 #ifdef CONFIG_RK_USB_UART
 	.dwc_otg_uart_mode = dwc_otg_uart_mode,
 #endif
-    .bc_detect_cb=usb20otg_battery_charger_detect_cb,
+	.bc_detect_cb = usb20otg_battery_charger_detect_cb,
 };
 
 #endif
@@ -177,30 +178,30 @@ static void usb20host_hw_init(void)
 	 * set common_on = 0, in suspend mode, host1 PLL blocks remain powered.
 	 * for RK3288, hsic and other modules use host1 (DWC_OTG) 480M phy clk.
 	 */
-	control_usb->grf_uoc2_base->CON0 = (1<<16)|0;
+	control_usb->grf_uoc2_base->CON0 = (1 << 16) | 0;
 
 	/* other haredware init,include:
 	 * DRV_VBUS GPIO init */
-	if(gpio_is_valid(control_usb->host_gpios->gpio)){
-		if(!gpio_get_value(control_usb->host_gpios->gpio)){
+	if (gpio_is_valid(control_usb->host_gpios->gpio)) {
+		if (!gpio_get_value(control_usb->host_gpios->gpio))
 			gpio_set_value(control_usb->host_gpios->gpio, 1);
-		}
 	}
 }
 
-static void usb20host_phy_suspend(void* pdata, int suspend)
+static void usb20host_phy_suspend(void *pdata, int suspend)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-
-	if(suspend){
-		// enable soft control
-		control_usb->grf_uoc2_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-		// enter suspend
-		control_usb->grf_uoc2_base->CON3 = 0x2A|(0x3F<<16); 
+	struct dwc_otg_platform_data *usbpdata = pdata;
+
+	if (suspend) {
+		/* enable soft control */
+		control_usb->grf_uoc2_base->CON2 =
+		    (0x01 << 2) | ((0x01 << 2) << 16);
+		/* enter suspend */
+		control_usb->grf_uoc2_base->CON3 = 0x2A | (0x3F << 16);
 		usbpdata->phy_status = 1;
-	}else{
-		//exit suspend.
-		control_usb->grf_uoc2_base->CON2 = ((0x01<<2)<<16);
+	} else {
+		/* exit suspend */
+		control_usb->grf_uoc2_base->CON2 = ((0x01 << 2) << 16);
 		usbpdata->phy_status = 0;
 	}
 }
@@ -218,10 +219,10 @@ static void usb20host_soft_reset(void)
 	mdelay(2);
 }
 
-static void usb20host_clock_init(void* pdata)
+static void usb20host_clock_init(void *pdata)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
-	struct clk* ahbclk, *phyclk, *phyclk_480m;
+	struct dwc_otg_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk, *phyclk_480m;
 
 	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb1");
 	if (IS_ERR(ahbclk)) {
@@ -246,14 +247,14 @@ static void usb20host_clock_init(void* pdata)
 	usbpdata->phyclk_480m = phyclk_480m;
 }
 
-static void usb20host_clock_enable(void* pdata, int enable)
+static void usb20host_clock_enable(void *pdata, int enable)
 {
-	struct dwc_otg_platform_data *usbpdata=pdata;
+	struct dwc_otg_platform_data *usbpdata = pdata;
 
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 	}
@@ -263,30 +264,30 @@ static int usb20host_get_status(int id)
 {
 	int ret = -1;
 
-	switch(id){
-		case USB_STATUS_BVABLID:
-			// bvalid in grf
-			ret = control_usb->grf_soc_status2_rk3288->host1_bvalid;	
-			break;
-		case USB_STATUS_DPDM:
-			// dpdm in grf
-			ret = control_usb->grf_soc_status2_rk3288->host1_linestate;
-			break;
-		case USB_STATUS_ID:
-			// id in grf
-			ret = control_usb->grf_soc_status2_rk3288->host1_iddig;
-			break;
-		case USB_CHIP_ID:
-			ret = control_usb->chip_id;
-			break;
-		case USB_REMOTE_WAKEUP:
-			ret = control_usb->remote_wakeup;
-			break;
-		case USB_IRQ_WAKEUP:
-			ret = control_usb->usb_irq_wakeup;
-			break;
-		default:
-			break;
+	switch (id) {
+	case USB_STATUS_BVABLID:
+		/* bvalid in grf */
+		ret = control_usb->grf_soc_status2_rk3288->host1_bvalid;
+		break;
+	case USB_STATUS_DPDM:
+		/* dpdm in grf */
+		ret = control_usb->grf_soc_status2_rk3288->host1_linestate;
+		break;
+	case USB_STATUS_ID:
+		/* id in grf */
+		ret = control_usb->grf_soc_status2_rk3288->host1_iddig;
+		break;
+	case USB_CHIP_ID:
+		ret = control_usb->chip_id;
+		break;
+	case USB_REMOTE_WAKEUP:
+		ret = control_usb->remote_wakeup;
+		break;
+	case USB_IRQ_WAKEUP:
+		ret = control_usb->usb_irq_wakeup;
+		break;
+	default:
+		break;
 	}
 
 	return ret;
@@ -294,15 +295,16 @@ static int usb20host_get_status(int id)
 
 static void usb20host_power_enable(int enable)
 {
-	if(0 == enable){//disable host_drv power
-		//do not disable power in default
-	}else if(1 == enable){//enable host_drv power
-		if(gpio_is_valid(control_usb->host_gpios->gpio))
+	if (0 == enable) {
+		/* disable host_drv power */
+		/* do not disable power in default */
+	} else if (1 == enable) {
+		/* enable host_drv power */
+		if (gpio_is_valid(control_usb->host_gpios->gpio))
 			gpio_set_value(control_usb->host_gpios->gpio, 1);
 	}
 }
 
-
 struct dwc_otg_platform_data usb20host_pdata_rk3288 = {
 	.phyclk = NULL,
 	.ahbclk = NULL,
@@ -322,15 +324,16 @@ struct dwc_otg_platform_data usb20host_pdata_rk3288 = {
 #ifdef CONFIG_USB_EHCI_RKHSIC
 static void rk_hsic_hw_init(void)
 {
-	// usb phy config init
-	// hsic phy config init, set hsicphy_txsrtune
-	control_usb->grf_uoc3_base->CON0 = ((0xf<<6)<<16)|(0xf<<6);
+	/* usb phy config init
+	 * hsic phy config init, set hsicphy_txsrtune */
+	control_usb->grf_uoc3_base->CON0 = ((0xf << 6) << 16) | (0xf << 6);
 
 	/* other haredware init
-	 * set common_on = 0, in suspend mode, otg/host PLL blocks remain powered
+	 * set common_on = 0, in suspend mode,
+	 * otg/host PLL blocks remain powered
 	 * for RK3288, use host1 (DWC_OTG) 480M phy clk
 	 */
-	control_usb->grf_uoc2_base->CON0 = (1<<16)|0;
+	control_usb->grf_uoc2_base->CON0 = (1 << 16) | 0;
 
 	/* change INCR to INCR16 or INCR8(beats less than 16)
 	 * or INCR4(beats less than 8) or SINGLE(beats less than 4)
@@ -338,13 +341,13 @@ static void rk_hsic_hw_init(void)
 	control_usb->grf_uoc4_base->CON0 = 0x00ff00bc;
 }
 
-static void rk_hsic_clock_init(void* pdata)
+static void rk_hsic_clock_init(void *pdata)
 {
 	/* By default, hsicphy_480m's parent is otg phy 480MHz clk
 	 * rk3188 must use host phy 480MHz clk, because if otg bypass
 	 * to uart mode, otg phy 480MHz clk will be closed automatically
 	 */
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 	struct clk *ahbclk, *phyclk480m_hsic, *phyclk12m_hsic;
 
 	phyclk480m_hsic = devm_clk_get(usbpdata->dev, "hsicphy_480m");
@@ -370,18 +373,18 @@ static void rk_hsic_clock_init(void* pdata)
 	usbpdata->hsic_phy_12m = phyclk12m_hsic;
 }
 
-static void rk_hsic_clock_enable(void* pdata, int enable)
+static void rk_hsic_clock_enable(void *pdata, int enable)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 
-	if(enable == usbpdata->clk_status)
+	if (enable == usbpdata->clk_status)
 		return;
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->hclk_hsic);
 		clk_prepare_enable(usbpdata->hsic_phy_480m);
 		clk_prepare_enable(usbpdata->hsic_phy_12m);
 		usbpdata->clk_status = 1;
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->hclk_hsic);
 		clk_disable_unprepare(usbpdata->hsic_phy_480m);
 		clk_disable_unprepare(usbpdata->hsic_phy_12m);
@@ -402,9 +405,9 @@ static void rk_hsic_soft_reset(void)
 	mdelay(2);
 
 	/* HSIC per-port reset */
-	control_usb->grf_uoc3_base->CON0 = ((1<<10)<<16)|(1<<10);
+	control_usb->grf_uoc3_base->CON0 = ((1 << 10) << 16) | (1 << 10);
 	udelay(2);
-	control_usb->grf_uoc3_base->CON0 = ((1<<10)<<16)|(0<<10);
+	control_usb->grf_uoc3_base->CON0 = ((1 << 10) << 16) | (0 << 10);
 	udelay(2);
 }
 
@@ -426,34 +429,34 @@ static void rk_ehci_hw_init(void)
 	/* usb phy config init */
 
 	/* DRV_VBUS GPIO init */
-	if(gpio_is_valid(control_usb->host_gpios->gpio)){
-		if(!gpio_get_value(control_usb->host_gpios->gpio)){
+	if (gpio_is_valid(control_usb->host_gpios->gpio)) {
+		if (!gpio_get_value(control_usb->host_gpios->gpio))
 			gpio_set_value(control_usb->host_gpios->gpio, 1);
-		}
 	}
 }
 
-static void rk_ehci_phy_suspend(void* pdata, int suspend)
+static void rk_ehci_phy_suspend(void *pdata, int suspend)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
-
-	if(suspend){
-		// enable soft control
-		control_usb->grf_uoc1_base->CON2 = (0x01<<2)|((0x01<<2)<<16);
-		// enter suspend
-		control_usb->grf_uoc1_base->CON3 = 0x2A|(0x3F<<16);
+	struct rkehci_platform_data *usbpdata = pdata;
+
+	if (suspend) {
+		/* enable soft control */
+		control_usb->grf_uoc1_base->CON2 =
+		    (0x01 << 2) | ((0x01 << 2) << 16);
+		/* enter suspend */
+		control_usb->grf_uoc1_base->CON3 = 0x2A | (0x3F << 16);
 		usbpdata->phy_status = 1;
-	}else{
-		// exit suspend
-		control_usb->grf_uoc1_base->CON2 = ((0x01<<2)<<16);
+	} else {
+		/* exit suspend */
+		control_usb->grf_uoc1_base->CON2 = ((0x01 << 2) << 16);
 		usbpdata->phy_status = 0;
 	}
 }
 
-static void rk_ehci_clock_init(void* pdata)
+static void rk_ehci_clock_init(void *pdata)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
-	struct clk* ahbclk,*phyclk;
+	struct rkehci_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk;
 
 	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb2");
 	if (IS_ERR(ahbclk)) {
@@ -471,17 +474,17 @@ static void rk_ehci_clock_init(void* pdata)
 	usbpdata->ahbclk = ahbclk;
 }
 
-static void rk_ehci_clock_enable(void* pdata, int enable)
+static void rk_ehci_clock_enable(void *pdata, int enable)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 
-	if(enable == usbpdata->clk_status)
+	if (enable == usbpdata->clk_status)
 		return;
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
 		usbpdata->clk_status = 1;
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 		usbpdata->clk_status = 0;
@@ -507,22 +510,22 @@ static int rk_ehci_get_status(int id)
 {
 	int ret = -1;
 
-	switch(id){
-		case USB_STATUS_DPDM:
-			// dpdm in grf
-			ret = control_usb->grf_soc_status2_rk3288->host0_linestate;
-			break;
-		case USB_CHIP_ID:
-			ret = control_usb->chip_id;
-			break;
-		case USB_REMOTE_WAKEUP:
-			ret = control_usb->remote_wakeup;
-			break;
-		case USB_IRQ_WAKEUP:
-			ret = control_usb->usb_irq_wakeup;
-			break;
-		default:
-			break;
+	switch (id) {
+	case USB_STATUS_DPDM:
+		/* dpdm in grf */
+		ret = control_usb->grf_soc_status2_rk3288->host0_linestate;
+		break;
+	case USB_CHIP_ID:
+		ret = control_usb->chip_id;
+		break;
+	case USB_REMOTE_WAKEUP:
+		ret = control_usb->remote_wakeup;
+		break;
+	case USB_IRQ_WAKEUP:
+		ret = control_usb->usb_irq_wakeup;
+		break;
+	default:
+		break;
 	}
 
 	return ret;
@@ -548,25 +551,24 @@ static void rk_ohci_hw_init(void)
 	/* usb phy config init */
 
 	/* DRV_VBUS GPIO init */
-	if(gpio_is_valid(control_usb->host_gpios->gpio)){
-		if(!gpio_get_value(control_usb->host_gpios->gpio)){
+	if (gpio_is_valid(control_usb->host_gpios->gpio)) {
+		if (!gpio_get_value(control_usb->host_gpios->gpio))
 			gpio_set_value(control_usb->host_gpios->gpio, 1);
-		}
 	}
 }
 
-static void rk_ohci_clock_init(void* pdata)
+static void rk_ohci_clock_init(void *pdata)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
-	struct clk* ahbclk,*phyclk;
+	struct rkehci_platform_data *usbpdata = pdata;
+	struct clk *ahbclk, *phyclk;
 
-	ahbclk =devm_clk_get(usbpdata->dev, "hclk_usb3");
+	ahbclk = devm_clk_get(usbpdata->dev, "hclk_usb3");
 	if (IS_ERR(ahbclk)) {
 		dev_err(usbpdata->dev, "Failed to get hclk_usb3\n");
 		return;
 	}
 
-	phyclk = devm_clk_get(usbpdata->dev, "clk_usbphy3");;
+	phyclk = devm_clk_get(usbpdata->dev, "clk_usbphy3");
 	if (IS_ERR(phyclk)) {
 		dev_err(usbpdata->dev, "Failed to get clk_usbphy3\n");
 		return;
@@ -576,17 +578,17 @@ static void rk_ohci_clock_init(void* pdata)
 	usbpdata->ahbclk = ahbclk;
 }
 
-static void rk_ohci_clock_enable(void* pdata, int enable)
+static void rk_ohci_clock_enable(void *pdata, int enable)
 {
-	struct rkehci_platform_data *usbpdata=pdata;
+	struct rkehci_platform_data *usbpdata = pdata;
 
-	if(enable == usbpdata->clk_status)
+	if (enable == usbpdata->clk_status)
 		return;
-	if(enable){
+	if (enable) {
 		clk_prepare_enable(usbpdata->ahbclk);
 		clk_prepare_enable(usbpdata->phyclk);
 		usbpdata->clk_status = 1;
-	}else{
+	} else {
 		clk_disable_unprepare(usbpdata->ahbclk);
 		clk_disable_unprepare(usbpdata->phyclk);
 		usbpdata->clk_status = 0;
@@ -609,19 +611,21 @@ struct rkehci_platform_data rkohci_pdata_rk3288 = {
 #endif
 
 /*********************************************************************
-                        rk3288 usb detections 
+			rk3288 usb detections
 *********************************************************************/
 
 #define WAKE_LOCK_TIMEOUT (HZ * 10)
-inline static void do_wakeup(struct work_struct *work)
+static inline void do_wakeup(struct work_struct *work)
 {
-	rk_send_wakeup_key(); // wake up the system
+	/* wake up the system */
+	rk_send_wakeup_key();
 }
 
 static void usb_battery_charger_detect_work(struct work_struct *work)
 {
 	rk_usb_charger_status = usb_battery_charger_detect(0);
 }
+
 /********** handler for bvalid irq **********/
 static irqreturn_t bvalid_irq_handler(int irq, void *dev_id)
 {
@@ -633,13 +637,15 @@ static irqreturn_t bvalid_irq_handler(int irq, void *dev_id)
 	dwc_otg_uart_mode(NULL, PHY_USB_MODE);
 #endif
 
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_timeout(&control_usb->usb_wakelock, WAKE_LOCK_TIMEOUT);
-		schedule_delayed_work(&control_usb->usb_det_wakeup_work, HZ/10);
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_timeout(&control_usb->usb_wakelock,
+				  WAKE_LOCK_TIMEOUT);
+		schedule_delayed_work(&control_usb->usb_det_wakeup_work,
+				      HZ / 10);
 	}
 
 	rk_usb_charger_status = USB_BC_TYPE_SDP;
-	schedule_delayed_work(&control_usb->usb_charger_det_work, HZ/10);
+	schedule_delayed_work(&control_usb->usb_charger_det_work, HZ / 10);
 
 	return IRQ_HANDLED;
 }
@@ -647,57 +653,60 @@ static irqreturn_t bvalid_irq_handler(int irq, void *dev_id)
 /***** handler for otg id rise and fall edge *****/
 static irqreturn_t id_irq_handler(int irq, void *dev_id)
 {
-    unsigned int uoc_con;
-
-     /* clear irq */
-    uoc_con = control_usb->grf_uoc0_base->CON4;
-    
-    if(uoc_con & (1<<5))//id rise 
-    {
-        control_usb->grf_uoc0_base->CON4 = ((1<<5)|(1<<21)); //clear id rise irq pandding
-    }
-    
-    if(uoc_con & (1<<7))//id fall
-    { 
+	unsigned int uoc_con;
+
+	/* clear irq */
+	uoc_con = control_usb->grf_uoc0_base->CON4;
+
+	/* id rise */
+	if (uoc_con & (1 << 5)) {
+		/* clear id rise irq pandding */
+		control_usb->grf_uoc0_base->CON4 = ((1 << 5) | (1 << 21));
+	}
+
+	/* id fall */
+	if (uoc_con & (1 << 7)) {
 #ifdef CONFIG_RK_USB_UART
-        /* usb otg dp/dm switch to usb phy */
-        dwc_otg_uart_mode(NULL, PHY_USB_MODE);
+		/* usb otg dp/dm switch to usb phy */
+		dwc_otg_uart_mode(NULL, PHY_USB_MODE);
 #endif
-        control_usb->grf_uoc0_base->CON4 = ((1<<7)|(1<<23));//clear id fall irq pandding
-    }
+		/* clear id fall irq pandding */
+		control_usb->grf_uoc0_base->CON4 = ((1 << 7) | (1 << 23));
+	}
 
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_timeout(&control_usb->usb_wakelock, WAKE_LOCK_TIMEOUT);
-		schedule_delayed_work(&control_usb->usb_det_wakeup_work, HZ/10);
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_timeout(&control_usb->usb_wakelock,
+				  WAKE_LOCK_TIMEOUT);
+		schedule_delayed_work(&control_usb->usb_det_wakeup_work,
+				      HZ / 10);
 	}
 
-    return IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
 
 /***** handler for otg line status change *****/
 
 static irqreturn_t line_irq_handler(int irq, void *dev_id)
 {
-    /* clear irq */
-    
-    if(control_usb->grf_uoc0_base->CON0 & 1<<15){
-        control_usb->grf_uoc0_base->CON0 = (1<<15 | 1<<31);
-    }  
-    
-    if(control_usb->grf_uoc1_base->CON0 & 1<<15){
-        control_usb->grf_uoc1_base->CON0 = (1<<15 | 1<<31);
-    }    
-    
-    if(control_usb->grf_uoc2_base->CON0 & 1<<15){
-        control_usb->grf_uoc2_base->CON0 = (1<<15 | 1<<31);
-    }
-
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_timeout(&control_usb->usb_wakelock, WAKE_LOCK_TIMEOUT);
-		schedule_delayed_work(&control_usb->usb_det_wakeup_work, HZ/10);
+	/* clear irq */
+
+	if (control_usb->grf_uoc0_base->CON0 & 1 << 15)
+		control_usb->grf_uoc0_base->CON0 = (1 << 15 | 1 << 31);
+
+	if (control_usb->grf_uoc1_base->CON0 & 1 << 15)
+		control_usb->grf_uoc1_base->CON0 = (1 << 15 | 1 << 31);
+
+	if (control_usb->grf_uoc2_base->CON0 & 1 << 15)
+		control_usb->grf_uoc2_base->CON0 = (1 << 15 | 1 << 31);
+
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_timeout(&control_usb->usb_wakelock,
+				  WAKE_LOCK_TIMEOUT);
+		schedule_delayed_work(&control_usb->usb_det_wakeup_work,
+				      HZ / 10);
 	}
 
-    return IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
 
 /************* register usb detection irqs **************/
@@ -706,86 +715,90 @@ static int otg_irq_detect_init(struct platform_device *pdev)
 	int ret = 0;
 	int irq = 0;
 
-	if(control_usb->usb_irq_wakeup){
-		wake_lock_init(&control_usb->usb_wakelock, WAKE_LOCK_SUSPEND, "usb_detect");
+	if (control_usb->usb_irq_wakeup) {
+		wake_lock_init(&control_usb->usb_wakelock, WAKE_LOCK_SUSPEND,
+			       "usb_detect");
 		INIT_DELAYED_WORK(&control_usb->usb_det_wakeup_work, do_wakeup);
 	}
 
-    /*register otg_bvalid irq*/
+	/*register otg_bvalid irq */
 	irq = platform_get_irq_byname(pdev, "otg_bvalid");
 	if (irq > 0) {
-		ret = request_irq(irq, bvalid_irq_handler, 0, "otg_bvalid", NULL);
-		if(ret < 0){
+		ret =
+		    request_irq(irq, bvalid_irq_handler, 0, "otg_bvalid", NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
-		}else{
-		    control_usb->grf_uoc0_base->CON4 = 0x000c000c;// enable bvalid irq 
-			if(control_usb->usb_irq_wakeup){
-					enable_irq_wake(irq);
-			}
+		} else {
+			/* enable bvalid irq  */
+			control_usb->grf_uoc0_base->CON4 = 0x000c000c;
+			if (control_usb->usb_irq_wakeup)
+				enable_irq_wake(irq);
 		}
 	}
 #if 0
-    /*register otg_id irq*/
-    irq = platform_get_irq_byname(pdev, "otg_id");
-    if(irq > 0){
-        ret = request_irq(irq, id_irq_handler, 0, "otg_id", NULL);
-        if(ret < 0){
+	/*register otg_id irq */
+	irq = platform_get_irq_byname(pdev, "otg_id");
+	if (irq > 0) {
+		ret = request_irq(irq, id_irq_handler, 0, "otg_id", NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
-		}else{
-		    control_usb->grf_uoc0_base->CON4 = 0x00f000f0;
-			if(control_usb->usb_irq_wakeup){
-					enable_irq_wake(irq);
-			}
+		} else {
+			control_usb->grf_uoc0_base->CON4 = 0x00f000f0;
+			if (control_usb->usb_irq_wakeup)
+				enable_irq_wake(irq);
 		}
-    }
+	}
 
-    /*register otg_linestate irq*/
-    irq = platform_get_irq_byname(pdev, "otg_linestate");
-    if(irq > 0){
-        ret = request_irq(irq, line_irq_handler, 0, "otg_linestate", NULL);
-        if(ret < 0){
+	/*register otg_linestate irq */
+	irq = platform_get_irq_byname(pdev, "otg_linestate");
+	if (irq > 0) {
+		ret =
+		    request_irq(irq, line_irq_handler, 0, "otg_linestate",
+				NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
-		}else{
-		    control_usb->grf_uoc0_base->CON0 = 0xc000c000;
-			if(control_usb->usb_irq_wakeup){
-					enable_irq_wake(irq);
-			}
+		} else {
+			control_usb->grf_uoc0_base->CON0 = 0xc000c000;
+			if (control_usb->usb_irq_wakeup)
+				enable_irq_wake(irq);
 		}
-    }
-    
-    /*register host0_linestate irq*/
-    irq = platform_get_irq_byname(pdev, "host0_linestate");
-    if(irq > 0){
-        ret = request_irq(irq, line_irq_handler, 0, "host0_linestate", NULL);
-        if(ret < 0){
+	}
+
+	/*register host0_linestate irq */
+	irq = platform_get_irq_byname(pdev, "host0_linestate");
+	if (irq > 0) {
+		ret =
+		    request_irq(irq, line_irq_handler, 0, "host0_linestate",
+				NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
-		}else{
-		    control_usb->grf_uoc1_base->CON0 = 0xc000c000;
-			if(control_usb->usb_irq_wakeup){
-					enable_irq_wake(irq);
-			}
+		} else {
+			control_usb->grf_uoc1_base->CON0 = 0xc000c000;
+			if (control_usb->usb_irq_wakeup)
+				enable_irq_wake(irq);
 		}
-    }
-    
-    /*register host1_linestate irq*/
-    irq = platform_get_irq_byname(pdev, "host1_linestate");
-    if(irq > 0){
-        ret = request_irq(irq, line_irq_handler, 0, "host1_linestate", NULL);
-        if(ret < 0){
+	}
+
+	/*register host1_linestate irq */
+	irq = platform_get_irq_byname(pdev, "host1_linestate");
+	if (irq > 0) {
+		ret =
+		    request_irq(irq, line_irq_handler, 0, "host1_linestate",
+				NULL);
+		if (ret < 0) {
 			dev_err(&pdev->dev, "request_irq %d failed!\n", irq);
 			return ret;
-		}else{
-		    control_usb->grf_uoc2_base->CON0 = 0xc000c000;
-			if(control_usb->usb_irq_wakeup){
-					enable_irq_wake(irq);
-			}
+		} else {
+			control_usb->grf_uoc2_base->CON0 = 0xc000c000;
+			if (control_usb->usb_irq_wakeup)
+				enable_irq_wake(irq);
 		}
-    }
-#endif	
+	}
+#endif
 	return ret;
 }
 
@@ -806,85 +819,89 @@ static int usb_grf_ioremap(struct platform_device *pdev)
 	void *grf_uoc4_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_SOC_STATUS1");
+					   "GRF_SOC_STATUS1");
 	grf_soc_status1 = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_soc_status1)){
+	if (IS_ERR(grf_soc_status1)) {
 		ret = PTR_ERR(grf_soc_status1);
 		return ret;
 	}
-	control_usb->grf_soc_status1_rk3288 = (pGRF_SOC_STATUS1_RK3288)grf_soc_status1;
+	control_usb->grf_soc_status1_rk3288 =
+	    (pGRF_SOC_STATUS1_RK3288) grf_soc_status1;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_SOC_STATUS2");
+					   "GRF_SOC_STATUS2");
 	grf_soc_status2 = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_soc_status2)){
+	if (IS_ERR(grf_soc_status2)) {
 		ret = PTR_ERR(grf_soc_status2);
 		return ret;
 	}
-	control_usb->grf_soc_status2_rk3288 = (pGRF_SOC_STATUS2_RK3288)grf_soc_status2;
+	control_usb->grf_soc_status2_rk3288 =
+	    (pGRF_SOC_STATUS2_RK3288) grf_soc_status2;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_SOC_STATUS19");
+					   "GRF_SOC_STATUS19");
 	grf_soc_status19 = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_soc_status19)){
+	if (IS_ERR(grf_soc_status19)) {
 		ret = PTR_ERR(grf_soc_status19);
 		return ret;
 	}
-	control_usb->grf_soc_status19_rk3288 = (pGRF_SOC_STATUS19_RK3288)grf_soc_status19;
+	control_usb->grf_soc_status19_rk3288 =
+	    (pGRF_SOC_STATUS19_RK3288) grf_soc_status19;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_SOC_STATUS21");
+					   "GRF_SOC_STATUS21");
 	grf_soc_status21 = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_soc_status21)){
+	if (IS_ERR(grf_soc_status21)) {
 		ret = PTR_ERR(grf_soc_status21);
 		return ret;
 	}
-	control_usb->grf_soc_status21_rk3288 = (pGRF_SOC_STATUS21_RK3288)grf_soc_status21;
+	control_usb->grf_soc_status21_rk3288 =
+	    (pGRF_SOC_STATUS21_RK3288) grf_soc_status21;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC0_BASE");
+					   "GRF_UOC0_BASE");
 	grf_uoc0_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc0_base)){
+	if (IS_ERR(grf_uoc0_base)) {
 		ret = PTR_ERR(grf_uoc0_base);
 		return ret;
 	}
-	control_usb->grf_uoc0_base = (pGRF_UOC0_REG)grf_uoc0_base;
+	control_usb->grf_uoc0_base = (pGRF_UOC0_REG) grf_uoc0_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC1_BASE");
+					   "GRF_UOC1_BASE");
 	grf_uoc1_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc1_base)){
+	if (IS_ERR(grf_uoc1_base)) {
 		ret = PTR_ERR(grf_uoc1_base);
 		return ret;
 	}
-	control_usb->grf_uoc1_base = (pGRF_UOC1_REG)grf_uoc1_base;
+	control_usb->grf_uoc1_base = (pGRF_UOC1_REG) grf_uoc1_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC2_BASE");
+					   "GRF_UOC2_BASE");
 	grf_uoc2_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc2_base)){
+	if (IS_ERR(grf_uoc2_base)) {
 		ret = PTR_ERR(grf_uoc2_base);
 		return ret;
 	}
-	control_usb->grf_uoc2_base = (pGRF_UOC2_REG)grf_uoc2_base;
+	control_usb->grf_uoc2_base = (pGRF_UOC2_REG) grf_uoc2_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC3_BASE");
+					   "GRF_UOC3_BASE");
 	grf_uoc3_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc3_base)){
+	if (IS_ERR(grf_uoc3_base)) {
 		ret = PTR_ERR(grf_uoc3_base);
 		return ret;
 	}
-	control_usb->grf_uoc3_base = (pGRF_UOC3_REG)grf_uoc3_base;
+	control_usb->grf_uoc3_base = (pGRF_UOC3_REG) grf_uoc3_base;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"GRF_UOC4_BASE");
+					   "GRF_UOC4_BASE");
 	grf_uoc4_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(grf_uoc4_base)){
+	if (IS_ERR(grf_uoc4_base)) {
 		ret = PTR_ERR(grf_uoc4_base);
 		return ret;
 	}
-	control_usb->grf_uoc4_base = (pGRF_UOC4_REG)grf_uoc4_base;
+	control_usb->grf_uoc4_base = (pGRF_UOC4_REG) grf_uoc4_base;
 
 	return ret;
 }
@@ -893,9 +910,9 @@ static int usb_grf_ioremap(struct platform_device *pdev)
 
 static const struct of_device_id rk_usb_control_id_table[] = {
 	{
-		.compatible = "rockchip,rk3288-usb-control",
-	},
-	{ },
+	 .compatible = "rockchip,rk3288-usb-control",
+	 },
+	{},
 };
 
 #endif
@@ -906,35 +923,37 @@ static int rk_usb_control_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	int ret = 0;
 
-	control_usb = devm_kzalloc(&pdev->dev, sizeof(*control_usb),GFP_KERNEL);
+	control_usb =
+	    devm_kzalloc(&pdev->dev, sizeof(*control_usb), GFP_KERNEL);
 	if (!control_usb) {
 		dev_err(&pdev->dev, "unable to alloc memory for control usb\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto out;
 	}
 
 	control_usb->chip_id = RK3288_USB_CTLR;
 	control_usb->remote_wakeup = of_property_read_bool(np,
-		"rockchip,remote_wakeup");
+							   "rockchip,remote_wakeup");
 	control_usb->usb_irq_wakeup = of_property_read_bool(np,
-		"rockchip,usb_irq_wakeup");
-
-	INIT_DELAYED_WORK(&control_usb->usb_charger_det_work, usb_battery_charger_detect_work);
+							    "rockchip,usb_irq_wakeup");
 
+	INIT_DELAYED_WORK(&control_usb->usb_charger_det_work,
+			  usb_battery_charger_detect_work);
 
-	control_usb->host_gpios = devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
-	if(!control_usb->host_gpios){
+	control_usb->host_gpios =
+	    devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
+	if (!control_usb->host_gpios) {
 		dev_err(&pdev->dev, "unable to alloc memory for host_gpios\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto out;
 	}
 
-	gpio =  of_get_named_gpio(np, "host_drv_gpio", 0);
+	gpio = of_get_named_gpio(np, "host_drv_gpio", 0);
 	control_usb->host_gpios->gpio = gpio;
 
-	if(!gpio_is_valid(gpio)){
+	if (!gpio_is_valid(gpio)) {
 		dev_err(&pdev->dev, "invalid host gpio%d\n", gpio);
-	}else{
+	} else {
 		err = devm_gpio_request(&pdev->dev, gpio, "host_drv_gpio");
 		if (err) {
 			dev_err(&pdev->dev,
@@ -946,24 +965,24 @@ static int rk_usb_control_probe(struct platform_device *pdev)
 		gpio_direction_output(control_usb->host_gpios->gpio, 1);
 	}
 
-	control_usb->otg_gpios = devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
-	if(!control_usb->otg_gpios){
+	control_usb->otg_gpios =
+	    devm_kzalloc(&pdev->dev, sizeof(struct gpio), GFP_KERNEL);
+	if (!control_usb->otg_gpios) {
 		dev_err(&pdev->dev, "unable to alloc memory for otg_gpios\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto out;
 	}
 
-	gpio =  of_get_named_gpio(np, "otg_drv_gpio", 0);
+	gpio = of_get_named_gpio(np, "otg_drv_gpio", 0);
 	control_usb->otg_gpios->gpio = gpio;
 
-	if(!gpio_is_valid(gpio)){
+	if (!gpio_is_valid(gpio)) {
 		dev_err(&pdev->dev, "invalid otg gpio%d\n", gpio);
-	}else{
+	} else {
 		err = devm_gpio_request(&pdev->dev, gpio, "otg_drv_gpio");
 		if (err) {
 			dev_err(&pdev->dev,
-				"failed to request GPIO%d for otg_drv\n",
-				gpio);
+				"failed to request GPIO%d for otg_drv\n", gpio);
 			ret = err;
 			goto out;
 		}
@@ -980,34 +999,34 @@ static int rk_usb_control_remove(struct platform_device *pdev)
 }
 
 static struct platform_driver rk_usb_control_driver = {
-	.probe          = rk_usb_control_probe,
-	.remove         = rk_usb_control_remove,
-	.driver         = {
-		.name   = "rk3288-usb-control",
-		.owner  = THIS_MODULE,
-		.of_match_table = of_match_ptr(rk_usb_control_id_table),
-	},
+	.probe = rk_usb_control_probe,
+	.remove = rk_usb_control_remove,
+	.driver = {
+		   .name = "rk3288-usb-control",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk_usb_control_id_table),
+		   },
 };
 
 #ifdef CONFIG_OF
 
 static const struct of_device_id dwc_otg_control_usb_id_table[] = {
 	{
-		.compatible = "rockchip,rk3288-dwc-control-usb",
-	},
-	{ },
+	 .compatible = "rockchip,rk3288-dwc-control-usb",
+	 },
+	{},
 };
 
 #endif
 
 static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 {
-	struct clk* hclk_usb_peri, *phyclk_480m, *phyclk480m_parent;
+	struct clk *hclk_usb_peri, *phyclk_480m, *phyclk480m_parent;
 	int ret = 0;
 
 	if (!control_usb) {
 		dev_err(&pdev->dev, "unable to alloc memory for control usb\n");
-		ret =  -ENOMEM;
+		ret = -ENOMEM;
 		goto err1;
 	}
 
@@ -1036,15 +1055,15 @@ static int dwc_otg_control_usb_probe(struct platform_device *pdev)
 	clk_set_parent(phyclk_480m, phyclk480m_parent);
 
 	ret = usb_grf_ioremap(pdev);
-	if(ret){
+	if (ret) {
 		dev_err(&pdev->dev, "Failed to ioremap usb grf\n");
 		goto err2;
 	}
-
 #ifdef CONFIG_USB20_OTG
-	if(usb20otg_get_status(USB_STATUS_BVABLID)){
+	if (usb20otg_get_status(USB_STATUS_BVABLID)) {
 		rk_usb_charger_status = USB_BC_TYPE_SDP;
-		schedule_delayed_work(&control_usb->usb_charger_det_work, HZ/10);
+		schedule_delayed_work(&control_usb->usb_charger_det_work,
+				      HZ / 10);
 	}
 #endif
 
@@ -1067,13 +1086,13 @@ static int dwc_otg_control_usb_remove(struct platform_device *pdev)
 }
 
 static struct platform_driver dwc_otg_control_usb_driver = {
-	.probe          = dwc_otg_control_usb_probe,
-	.remove         = dwc_otg_control_usb_remove,
-	.driver         = {
-		.name   = "rk3288-dwc-control-usb",
-		.owner  = THIS_MODULE,
-		.of_match_table = of_match_ptr(dwc_otg_control_usb_id_table),
-	},
+	.probe = dwc_otg_control_usb_probe,
+	.remove = dwc_otg_control_usb_remove,
+	.driver = {
+		   .name = "rk3288-dwc-control-usb",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(dwc_otg_control_usb_id_table),
+		   },
 };
 
 static int __init dwc_otg_control_usb_init(void)
diff --git a/drivers/usb/dwc_otg_310/usbdev_rkuoc.h b/drivers/usb/dwc_otg_310/usbdev_rkuoc.h
index 419ae0b8ecb2..41bcc155b73f 100644
--- a/drivers/usb/dwc_otg_310/usbdev_rkuoc.h
+++ b/drivers/usb/dwc_otg_310/usbdev_rkuoc.h
@@ -1,35 +1,44 @@
 #ifndef __USBDEV_RKUOC_H
 #define _USBDEV_RKUOC_H
 
-typedef union uoc_field
-{
-    u32 array[3];
-    struct {
-            u32 offset;
-            u32 bitmap;
-            u32 mask;
-    }b;
+typedef union uoc_field {
+	u32 array[3];
+	struct {
+		u32 offset;
+		u32 bitmap;
+		u32 mask;
+	} b;
 } uoc_field_t;
 
-inline static void grf_uoc_set(void *base, u32 offset, u8 bitmap, u8 mask, u32 value)
+static inline void grf_uoc_set(void *base, u32 offset, u8 bitmap, u8 mask,
+			       u32 value)
 {
-    //printk("bc_debug:set addr %p val = 0x%08x\n",((u32*)(base + offset)),(((((1 << mask) - 1) & value) | (((1 << mask) - 1) << 16))<< bitmap));
-    *((u32*)(base + offset)) = (((((1 << mask) - 1) & value) | (((1 << mask) - 1) << 16))<< bitmap);
+	/* printk("bc_debug:set addr %p val = 0x%08x\n",
+	 *	  ((u32*)(base + offset)),(((((1 << mask) - 1) & value)
+	 *	  | (((1 << mask) - 1) << 16))<< bitmap));*/
+	*((u32 *) (base + offset)) =
+	    (((((1 << mask) - 1) & value) | (((1 << mask) -
+					      1) << 16)) << bitmap);
 }
-inline static u32 grf_uoc_get(void *base, u32 offset, u32 bitmap, u32 mask)
+
+static inline u32 grf_uoc_get(void *base, u32 offset, u32 bitmap, u32 mask)
 {
-    //printk("bc_debug:get addr %p bit %d val = 0x%08x\n",(u32*)(base + offset), bitmap, *((u32*)(base + offset)));
-    return ((*((u32*)(base + offset)) >> bitmap) & ((1 << mask) - 1));
+	u32 ret;
+	/* printk("bc_debug:get addr %p bit %d val = 0x%08x\n",
+	 *	  (u32*)(base + offset), bitmap,
+	 *	  *((u32*)(base + offset))); */
+	ret = (*((u32 *) (base + offset)) >> bitmap) & ((1 << mask) - 1);
+	return ret;
 }
 
 static inline bool uoc_field_valid(uoc_field_t *f)
 {
-    if((f->b.bitmap < 32)&&(f->b.mask < 32))
-        return true;
-    else        {
-        printk("%s field invalid\n",__func__);
-        return false;
-    }
+	if ((f->b.bitmap < 32) && (f->b.mask < 32))
+		return true;
+	else {
+		printk("%s field invalid\n", __func__);
+		return false;
+	}
 }
 
 #endif
diff --git a/drivers/usb/gadget/f_hid_rk.c b/drivers/usb/gadget/f_hid_rk.c
index 19cbd9c39385..5e9a31147616 100755
--- a/drivers/usb/gadget/f_hid_rk.c
+++ b/drivers/usb/gadget/f_hid_rk.c
@@ -29,8 +29,6 @@
 #include <linux/wait.h>
 #include <linux/usb/g_hid.h>
 
-
-
 static int major, minors;
 static struct class *hidg_class;
 
@@ -39,85 +37,87 @@ static struct class *hidg_class;
 
 struct f_hidg {
 	/* configuration */
-	unsigned char			bInterfaceSubClass;
-	unsigned char			bInterfaceProtocol;
-	unsigned short			report_desc_length;
-	char				*report_desc;
-	unsigned short			report_length;
+	unsigned char bInterfaceSubClass;
+	unsigned char bInterfaceProtocol;
+	unsigned short report_desc_length;
+	char *report_desc;
+	unsigned short report_length;
 
 	/* recv report */
-	char				*set_report_buff;
-	unsigned short			set_report_length;
-	spinlock_t			spinlock;
-	wait_queue_head_t		read_queue;
-	struct usb_request		*req_out;
+	char *set_report_buff;
+	unsigned short set_report_length;
+	spinlock_t spinlock;
+	wait_queue_head_t read_queue;
+	struct usb_request *req_out;
 
 	/* send report */
-	struct mutex			lock;
-	bool				write_pending;
-	wait_queue_head_t		write_queue;
-	struct usb_request		*req;
-
-	int				minor;
-	struct cdev			cdev;
-	struct usb_function		func;
-	struct usb_ep			*in_ep;
-	struct usb_endpoint_descriptor	*fs_in_ep_desc;
-	struct usb_endpoint_descriptor	*hs_in_ep_desc;
-	struct usb_endpoint_descriptor	*fs_out_ep_desc;
-	struct usb_endpoint_descriptor	*hs_out_ep_desc;
-	
-    struct usb_composite_dev        *u_cdev;
+	struct mutex lock;
+	bool write_pending;
+	wait_queue_head_t write_queue;
+	struct usb_request *req;
+
+	int minor;
+	struct cdev cdev;
+	struct usb_function func;
+	struct usb_ep *in_ep;
+	struct usb_endpoint_descriptor *fs_in_ep_desc;
+	struct usb_endpoint_descriptor *hs_in_ep_desc;
+	struct usb_endpoint_descriptor *fs_out_ep_desc;
+	struct usb_endpoint_descriptor *hs_out_ep_desc;
+
+	struct usb_composite_dev *u_cdev;
 
 	bool connected;
-	bool  boot_protocol;//4   1 for boot protocol , 0 for report protocol
+	/* 4   1 for boot protocol , 0 for report protocol */
+	bool boot_protocol;
 	bool suspend;
 };
 
-bool  bypass_input = 0;
+bool bypass_input;
 static inline struct f_hidg *func_to_hidg(struct usb_function *f)
 {
 	return container_of(f, struct f_hidg, func);
 }
+
 void hidg_disconnect();
 
 /*-------------------------------------------------------------------------*/
 /*                           Static descriptors                            */
 
 static struct usb_interface_descriptor hidg_interface_desc = {
-	.bLength		= sizeof hidg_interface_desc,
-	.bDescriptorType	= USB_DT_INTERFACE,
-	/* .bInterfaceNumber	= DYNAMIC */
-	.bAlternateSetting	= 0,
-	.bNumEndpoints		= 1,
-	.bInterfaceClass	= USB_CLASS_HID,
-	/* .bInterfaceSubClass	= DYNAMIC */
-	/* .bInterfaceProtocol	= DYNAMIC */
-	/* .iInterface		= DYNAMIC */
+	.bLength = sizeof hidg_interface_desc,
+	.bDescriptorType = USB_DT_INTERFACE,
+	/* .bInterfaceNumber    = DYNAMIC */
+	.bAlternateSetting = 0,
+	.bNumEndpoints = 1,
+	.bInterfaceClass = USB_CLASS_HID,
+	/* .bInterfaceSubClass  = DYNAMIC */
+	/* .bInterfaceProtocol  = DYNAMIC */
+	/* .iInterface          = DYNAMIC */
 };
 
 static struct hid_descriptor hidg_desc = {
-	.bLength			= sizeof hidg_desc,
-	.bDescriptorType		= HID_DT_HID,
-	.bcdHID				= 0x0110, //0x0101,
-	.bCountryCode			= 0x00,
-	.bNumDescriptors		= 0x1,
-	/*.desc[0].bDescriptorType	= DYNAMIC */
-	/*.desc[0].wDescriptorLenght	= DYNAMIC */
+	.bLength = sizeof hidg_desc,
+	.bDescriptorType = HID_DT_HID,
+	.bcdHID = 0x0110,	/* 0x0101, */
+	.bCountryCode = 0x00,
+	.bNumDescriptors = 0x1,
+	/*.desc[0].bDescriptorType      = DYNAMIC */
+	/*.desc[0].wDescriptorLenght    = DYNAMIC */
 };
 
 /* High-Speed Support */
 
 static struct usb_endpoint_descriptor hidg_hs_in_ep_desc = {
-	.bLength		= USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType	= USB_DT_ENDPOINT,
-	.bEndpointAddress	= USB_DIR_IN,
-	.bmAttributes		= USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize	  = cpu_to_le16(64),
-	.bInterval		= 4, /* FIXME: Add this field in the
-				      * HID gadget configuration?
-				      * (struct hidg_func_descriptor)
-				      */
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = cpu_to_le16(64),
+	.bInterval = 4,		/* FIXME: Add this field in the
+				 * HID gadget configuration?
+				 * (struct hidg_func_descriptor)
+				 */
 };
 
 static struct usb_descriptor_header *hidg_hs_descriptors[] = {
@@ -130,15 +130,15 @@ static struct usb_descriptor_header *hidg_hs_descriptors[] = {
 /* Full-Speed Support */
 
 static struct usb_endpoint_descriptor hidg_fs_in_ep_desc = {
-	.bLength		= USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType	= USB_DT_ENDPOINT,
-	.bEndpointAddress	= USB_DIR_IN,
-	.bmAttributes		= USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize	= cpu_to_le16(64),
-	.bInterval		= 10, /* FIXME: Add this field in the
-				       * HID gadget configuration?
-				       * (struct hidg_func_descriptor)
-				       */
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = cpu_to_le16(64),
+	.bInterval = 10,	/* FIXME: Add this field in the
+				 * HID gadget configuration?
+				 * (struct hidg_func_descriptor)
+				 */
 };
 
 static struct usb_descriptor_header *hidg_fs_descriptors[] = {
@@ -150,93 +150,92 @@ static struct usb_descriptor_header *hidg_fs_descriptors[] = {
 
 /* hid descriptor for a keyboard */
 const struct hidg_func_descriptor my_hid_data = {
-	.subclass		= 1, /* No subclass */
-	.protocol		= 1, /* 1-Keyboard,2-mouse */
-	.report_length		= 64,
+	.subclass = 1,		/* No subclass */
+	.protocol = 1,		/* 1-Keyboard,2-mouse */
+	.report_length = 64,
 	.report_desc_length = 150,
-	.report_desc        = {
-        
-        0x05, 0x01, /*       USAGE_PAGE (Generic Desktop)         */
-        0x09, 0x06, /*       USAGE (Keyboard)                     */
-        0xA1, 0x01, /*       COLLECTION (Application)             */
-            0x85, 0x01, /*   REPORT ID (0x01)                     */
-            0x05, 0x07, /*   USAGE_PAGE (Keyboard)                */
-            0x19, 0xE0, /*   USAGE_MINIMUM (Keyboard LeftControl) */
-            0x29, 0xE7, /*   USAGE_MAXIMUM (Keyboard Right GUI)   */
-            0x15, 0x00, /*   LOGICAL_MINIMUM (0)                  */
-            0x25, 0x01, /*   LOGICAL_MAXIMUM (1)                  */
-            0x75, 0x01, /*   REPORT_SIZE (1)                      */
-            0x95, 0x08, /*   REPORT_COUNT (8)                     */
-            0x81, 0x02, /*   INPUT (Data,Var,Abs)                 */
-            0x95, 0x01, /*   REPORT_COUNT (1)                     */
-            0x75, 0x08, /*   REPORT_SIZE (8)                      */
-            0x81, 0x03, /*   INPUT (Cnst,Var,Abs)                 */
-            0x95, 0x05, /*   REPORT_COUNT (5)                     */
-            0x75, 0x01, /*   REPORT_SIZE (1)                      */
-            0x05, 0x08, /*   USAGE_PAGE (LEDs)                    */
-            0x19, 0x01, /*   USAGE_MINIMUM (Num Lock)             */
-            0x29, 0x05, /*   USAGE_MAXIMUM (Kana)                 */
-            0x91, 0x02, /*   OUTPUT (Data,Var,Abs)                */
-            0x95, 0x01, /*   REPORT_COUNT (1)                     */
-            0x75, 0x03, /*   REPORT_SIZE (3)                      */
-            0x91, 0x03, /*   OUTPUT (Cnst,Var,Abs)                */
-            0x95, 0x06, /*   REPORT_COUNT (6)                     */
-            0x75, 0x08, /*   REPORT_SIZE (8)                      */
-            0x15, 0x00, /*   LOGICAL_MINIMUM (0)                  */
-            0x25, 0x65, /*   LOGICAL_MAXIMUM (101)                */
-            0x05, 0x07, /*   USAGE_PAGE (Keyboard)                */
-            0x19, 0x00, /*   USAGE_MINIMUM (Reserved)             */
-            0x29, 0x65, /*   USAGE_MAXIMUM (Keyboard Application) */
-            0x81, 0x00, /*   INPUT (Data,Ary,Abs)                 */                                                        
-        0xC0,           /*   END_COLLECTION                       */   
-        
-        0x05, 0x0C,     /*   USAGE_PAGE (consumer page)           */
-        0x09, 0x01,     /*   USAGE (consumer control)             */
-        0xA1, 0x01,     /*   COLLECTION (Application)             */
-            0x85, 0x03, /*   REPORT ID (0x03)                     */
-            0x15, 0x00, /*   LOGICAL_MINIMUM (0)                  */
-            0x26, 0xFF, 0x02, /*  LOGICAL_MAXIMUM (0x2FF)         */
-            0x19, 0x00, /*   USAGE_MINIMUM (00)                   */
-            0x2A, 0xFF, 0x02, /*  USAGE_MAXIMUM (0x2FF)           */
-            0x75, 0x10, /*   REPORT_SIZE (16)                     */
-            0x95, 0x01, /*   REPORT_COUNT (1)                     */
-            0x81, 0x00, /*   INPUT (Data,Ary,Abs)                 */ 
-        0xC0,
-        
-        0x05, 0x01,     /*   USAGE_PAGE (Generic Desktop)         */
-        0x09, 0x02,     /*   USAGE (Mouse)                        */
-        0xA1, 0x01,     /*   COLLECTION (Application)             */
-            0x85, 0x02,     /*   REPORT ID (0x02)                 */
-            0x09, 0x01,     /*   USAGE (Pointer)                  */
-            
-            0xA1, 0x00,     /*   COLLECTION (Application)         */
-            0x05, 0x09,     /*   USAGE_PAGE (Button)              */
-            0x19, 0x01,     /*   USAGE_MINIMUM (Button 1)         */
-            0x29, 0x08,     /*   USAGE_MAXIMUM (Button 8)         */
-            0x15, 0x00,     /*   LOGICAL_MINIMUM (0)              */
-            0x25, 0x01,     /*   LOGICAL_MAXIMUM (1)              */
-            0x75, 0x01,     /*   REPORT_SIZE (1)                  */
-            0x95, 0x08,     /*   REPORT_COUNT (8)                 */
-            0x81, 0x02,     /*   INPUT (Data,Var,Abs)             */
-            0x05, 0x01,     /*   USAGE_PAGE (Generic Desktop)     */
-            0x09, 0x30,     /*   USAGE (X)                        */
-            0x09, 0x31,     /*   USAGE (Y)                        */
-            0x16, 0x01, 0xF8, /* LOGICAL_MINIMUM (-2047)          */
-            0x26, 0xFF, 0x07, /* LOGICAL_MAXIMUM (2047)           */
-            0x75, 0x0C,     /*   REPORT_SIZE (12)                 */
-            0x95, 0x02,     /*   REPORT_COUNT (2)                 */
-            0x81, 0x06,     /*   INPUT (Data,Var,Rel)             */
-            0x09, 0x38, 
-            0x15, 0x81,     /*   LOGICAL_MINIMUM (-127)           */
-            0x25, 0x7F,     /*   LOGICAL_MAXIMUM (127)            */
-            0x75, 0x08,     /*   REPORT_SIZE (8)                  */
-            0x95, 0x01,     /*   REPORT_COUNT (1)                 */
-            0x81, 0x06,     /*   INPUT (Data,Var,Rel)             */
-            0xC0 ,          /*   END_COLLECTION                   */
-            
-        0xC0            /*   END_COLLECTION                       */
-
-	},
+	.report_desc = {
+
+			0x05, 0x01,	/*       USAGE_PAGE (Generic Desktop)         */
+			0x09, 0x06,	/*       USAGE (Keyboard)                     */
+			0xA1, 0x01,	/*       COLLECTION (Application)             */
+			0x85, 0x01,	/*   REPORT ID (0x01)                     */
+			0x05, 0x07,	/*   USAGE_PAGE (Keyboard)                */
+			0x19, 0xE0,	/*   USAGE_MINIMUM (Keyboard LeftControl) */
+			0x29, 0xE7,	/*   USAGE_MAXIMUM (Keyboard Right GUI)   */
+			0x15, 0x00,	/*   LOGICAL_MINIMUM (0)                  */
+			0x25, 0x01,	/*   LOGICAL_MAXIMUM (1)                  */
+			0x75, 0x01,	/*   REPORT_SIZE (1)                      */
+			0x95, 0x08,	/*   REPORT_COUNT (8)                     */
+			0x81, 0x02,	/*   INPUT (Data,Var,Abs)                 */
+			0x95, 0x01,	/*   REPORT_COUNT (1)                     */
+			0x75, 0x08,	/*   REPORT_SIZE (8)                      */
+			0x81, 0x03,	/*   INPUT (Cnst,Var,Abs)                 */
+			0x95, 0x05,	/*   REPORT_COUNT (5)                     */
+			0x75, 0x01,	/*   REPORT_SIZE (1)                      */
+			0x05, 0x08,	/*   USAGE_PAGE (LEDs)                    */
+			0x19, 0x01,	/*   USAGE_MINIMUM (Num Lock)             */
+			0x29, 0x05,	/*   USAGE_MAXIMUM (Kana)                 */
+			0x91, 0x02,	/*   OUTPUT (Data,Var,Abs)                */
+			0x95, 0x01,	/*   REPORT_COUNT (1)                     */
+			0x75, 0x03,	/*   REPORT_SIZE (3)                      */
+			0x91, 0x03,	/*   OUTPUT (Cnst,Var,Abs)                */
+			0x95, 0x06,	/*   REPORT_COUNT (6)                     */
+			0x75, 0x08,	/*   REPORT_SIZE (8)                      */
+			0x15, 0x00,	/*   LOGICAL_MINIMUM (0)                  */
+			0x25, 0x65,	/*   LOGICAL_MAXIMUM (101)                */
+			0x05, 0x07,	/*   USAGE_PAGE (Keyboard)                */
+			0x19, 0x00,	/*   USAGE_MINIMUM (Reserved)             */
+			0x29, 0x65,	/*   USAGE_MAXIMUM (Keyboard Application) */
+			0x81, 0x00,	/*   INPUT (Data,Ary,Abs)                 */
+			0xC0,	/*   END_COLLECTION                       */
+
+			0x05, 0x0C,	/*   USAGE_PAGE (consumer page)           */
+			0x09, 0x01,	/*   USAGE (consumer control)             */
+			0xA1, 0x01,	/*   COLLECTION (Application)             */
+			0x85, 0x03,	/*   REPORT ID (0x03)                     */
+			0x15, 0x00,	/*   LOGICAL_MINIMUM (0)                  */
+			0x26, 0xFF, 0x02,	/*  LOGICAL_MAXIMUM (0x2FF)         */
+			0x19, 0x00,	/*   USAGE_MINIMUM (00)                   */
+			0x2A, 0xFF, 0x02,	/*  USAGE_MAXIMUM (0x2FF)           */
+			0x75, 0x10,	/*   REPORT_SIZE (16)                     */
+			0x95, 0x01,	/*   REPORT_COUNT (1)                     */
+			0x81, 0x00,	/*   INPUT (Data,Ary,Abs)                 */
+			0xC0,
+
+			0x05, 0x01,	/*   USAGE_PAGE (Generic Desktop)         */
+			0x09, 0x02,	/*   USAGE (Mouse)                        */
+			0xA1, 0x01,	/*   COLLECTION (Application)             */
+			0x85, 0x02,	/*   REPORT ID (0x02)                 */
+			0x09, 0x01,	/*   USAGE (Pointer)                  */
+
+			0xA1, 0x00,	/*   COLLECTION (Application)         */
+			0x05, 0x09,	/*   USAGE_PAGE (Button)              */
+			0x19, 0x01,	/*   USAGE_MINIMUM (Button 1)         */
+			0x29, 0x08,	/*   USAGE_MAXIMUM (Button 8)         */
+			0x15, 0x00,	/*   LOGICAL_MINIMUM (0)              */
+			0x25, 0x01,	/*   LOGICAL_MAXIMUM (1)              */
+			0x75, 0x01,	/*   REPORT_SIZE (1)                  */
+			0x95, 0x08,	/*   REPORT_COUNT (8)                 */
+			0x81, 0x02,	/*   INPUT (Data,Var,Abs)             */
+			0x05, 0x01,	/*   USAGE_PAGE (Generic Desktop)     */
+			0x09, 0x30,	/*   USAGE (X)                        */
+			0x09, 0x31,	/*   USAGE (Y)                        */
+			0x16, 0x01, 0xF8,	/* LOGICAL_MINIMUM (-2047)          */
+			0x26, 0xFF, 0x07,	/* LOGICAL_MAXIMUM (2047)           */
+			0x75, 0x0C,	/*   REPORT_SIZE (12)                 */
+			0x95, 0x02,	/*   REPORT_COUNT (2)                 */
+			0x81, 0x06,	/*   INPUT (Data,Var,Rel)             */
+			0x09, 0x38,
+			0x15, 0x81,	/*   LOGICAL_MINIMUM (-127)           */
+			0x25, 0x7F,	/*   LOGICAL_MAXIMUM (127)            */
+			0x75, 0x08,	/*   REPORT_SIZE (8)                  */
+			0x95, 0x01,	/*   REPORT_COUNT (1)                 */
+			0x81, 0x06,	/*   INPUT (Data,Var,Rel)             */
+			0xC0,	/*   END_COLLECTION                   */
+
+			0xC0	/*   END_COLLECTION                       */
+			},
 };
 
 struct f_hidg *g_hidg;
@@ -245,11 +244,11 @@ struct f_hidg *g_hidg;
 /*                              Char Device                                */
 
 static ssize_t f_hidg_read(struct file *file, char __user *buffer,
-			size_t count, loff_t *ptr)
+			   size_t count, loff_t *ptr)
 {
-	struct f_hidg	*hidg     = file->private_data;
-	char		*tmp_buff = NULL;
-	unsigned long	flags;
+	struct f_hidg *hidg = file->private_data;
+	char *tmp_buff = NULL;
+	unsigned long flags;
 
 	if (!count)
 		return 0;
@@ -272,7 +271,6 @@ static ssize_t f_hidg_read(struct file *file, char __user *buffer,
 		spin_lock_irqsave(&hidg->spinlock, flags);
 	}
 
-
 	count = min_t(unsigned, count, hidg->set_report_length);
 	tmp_buff = hidg->set_report_buff;
 	hidg->set_report_buff = NULL;
@@ -294,7 +292,7 @@ static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
 	struct f_hidg *hidg = (struct f_hidg *)ep->driver_data;
 
 	if (req->status != 0) {
-        ;
+		;
 	}
 
 	wake_up(&hidg->write_queue);
@@ -305,7 +303,7 @@ static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 			    size_t count, loff_t *offp)
 {
 #if 0
-	struct f_hidg *hidg  = file->private_data;
+	struct f_hidg *hidg = file->private_data;
 	ssize_t status = -ENOMEM;
 
 	if (!access_ok(VERIFY_READ, buffer, count))
@@ -321,34 +319,34 @@ static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		if (wait_event_interruptible_exclusive(
-				hidg->write_queue, WRITE_COND))
+		if (wait_event_interruptible_exclusive
+		    (hidg->write_queue, WRITE_COND))
 			return -ERESTARTSYS;
 
 		mutex_lock(&hidg->lock);
 	}
 
-	count  = min_t(unsigned, count, hidg->report_length);
+	count = min_t(unsigned, count, hidg->report_length);
 	status = copy_from_user(hidg->req->buf, buffer, count);
 
 	if (status != 0) {
-		//ERROR(hidg->func.config->cdev,
-		//	"copy_from_user error\n");
+		/* ERROR(hidg->func.config->cdev, */
+		/*      "copy_from_user error\n"); */
 		mutex_unlock(&hidg->lock);
 		return -EINVAL;
 	}
 
-	hidg->req->status   = 0;
-	hidg->req->zero     = 0;
-	hidg->req->length   = count;
+	hidg->req->status = 0;
+	hidg->req->zero = 0;
+	hidg->req->length = count;
 	hidg->req->complete = f_hidg_req_complete;
-	hidg->req->context  = hidg;
+	hidg->req->context = hidg;
 	hidg->write_pending = 1;
 
 	status = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
 	if (status < 0) {
-		//ERROR(hidg->func.config->cdev,
-		//	"usb_ep_queue error on int endpoint %zd\n", status);
+		/* ERROR(hidg->func.config->cdev,*/
+		/*      "usb_ep_queue error on int endpoint %zd\n", status); */
 		hidg->write_pending = 0;
 		wake_up(&hidg->write_queue);
 	} else {
@@ -360,243 +358,280 @@ static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 	return count;
 }
 
-
 static void f_hid_queue_report(u8 *data, int len)
 {
-    //this function will run in interrupt context 
-    ssize_t status = -ENOMEM;
-    struct f_hidg *hidg = g_hidg;
-    //static char raw_report[8];
-    
-    if(hidg){
-        if(hidg->connected){
-            //mutex_lock(&hidg->lock);
-            memcpy(hidg->req->buf, data, len);
-        	hidg->req->status   = 0;
-        	hidg->req->zero     = 0;
-        	hidg->req->length   = len;
-        	//hidg->req->buf      = raw_report;
-        	hidg->req->complete = f_hidg_req_complete;
-        	hidg->req->context  = hidg;
-
-            status = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
-            if (status < 0) {
-            	//printk("usb_ep_queue error on int endpoint %zd\n", status);
-        	}
-	    }
-    //mutex_unlock(&hidg->lock);
-    }
+	/* this function will run in interrupt context */
+	ssize_t status = -ENOMEM;
+	struct f_hidg *hidg = g_hidg;
+	/* static char raw_report[8]; */
+
+	if (hidg) {
+		if (hidg->connected) {
+			/* mutex_lock(&hidg->lock); */
+			memcpy(hidg->req->buf, data, len);
+			hidg->req->status = 0;
+			hidg->req->zero = 0;
+			hidg->req->length = len;
+			/* hidg->req->buf      = raw_report; */
+			hidg->req->complete = f_hidg_req_complete;
+			hidg->req->context = hidg;
+
+			status =
+			    usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
+			if (status < 0) {
+				/* printk("usb_ep_queue error on int endpoint %zd\n",
+				 * 	  status);*/
+			}
+		}
+		/* mutex_unlock(&hidg->lock); */
+	}
 }
 
-
 #define KBD_REPORT_ID (0x01)
 #define MOUSE_REPORT_ID (0x02)
 #define CONSUMER_REPORT_ID (0x03)
 
 unsigned int f_hid_bypass_input_get()
 {
-    if(!g_hidg)
-        return 0;
-    else
-        return bypass_input;
+	if (!g_hidg)
+		return 0;
+	else
+		return bypass_input;
 }
+
 EXPORT_SYMBOL(f_hid_bypass_input_get);
 
-unsigned char kbd_idle[]     = {KBD_REPORT_ID,0,0,0,0,0,0,0,0};
-unsigned char mouse_idle[]   = {MOUSE_REPORT_ID,0,0,0,0,0};
-unsigned char consumer_idle[]= {CONSUMER_REPORT_ID,0,0};
+unsigned char kbd_idle[] = { KBD_REPORT_ID, 0, 0, 0, 0, 0, 0, 0, 0 };
+unsigned char mouse_idle[] = { MOUSE_REPORT_ID, 0, 0, 0, 0, 0 };
+unsigned char consumer_idle[] = { CONSUMER_REPORT_ID, 0, 0 };
 
 static void f_hid_send_idle_report(void)
 {
-    if(g_hidg){
-        mdelay(2);
-        f_hid_queue_report(kbd_idle, sizeof(kbd_idle));
-        mdelay(2);
-        f_hid_queue_report(mouse_idle, sizeof(mouse_idle));
-        mdelay(2);
-        f_hid_queue_report(consumer_idle, sizeof(consumer_idle));
-    }
+	if (g_hidg) {
+		mdelay(2);
+		f_hid_queue_report(kbd_idle, sizeof(kbd_idle));
+		mdelay(2);
+		f_hid_queue_report(mouse_idle, sizeof(mouse_idle));
+		mdelay(2);
+		f_hid_queue_report(consumer_idle, sizeof(consumer_idle));
+	}
 }
 
 static void f_hid_bypass_input_set(u8 bypass)
 {
-    if(g_hidg){
-
-        u8 current_state = f_hid_bypass_input_get();
-
-        if( bypass && (!current_state))
-        {
-            bypass_input = 1;
-        }
-        if(!bypass && (current_state))
-        {
-            f_hid_send_idle_report();
-            bypass_input = 0;
-        }
-    }
+	if (g_hidg) {
+
+		u8 current_state = f_hid_bypass_input_get();
+
+		if (bypass && (!current_state)) {
+			bypass_input = 1;
+		}
+		if (!bypass && (current_state)) {
+			f_hid_send_idle_report();
+			bypass_input = 0;
+		}
+	}
 }
 
 void f_hid_wakeup()
 {
-    g_hidg->u_cdev->gadget->ops->wakeup(g_hidg->u_cdev->gadget);
+	g_hidg->u_cdev->gadget->ops->wakeup(g_hidg->u_cdev->gadget);
 }
 
 struct kbd_report {
-    u8        id;
-    u8        command;
-    u8        reserved;
-    u8        key_array[6];
-}__attribute__ ((packed));
+	u8 id;
+	u8 command;
+	u8 reserved;
+	u8 key_array[6];
+} __attribute__ ((packed));
 
 struct consumer_report {
-    u8        id;
-    u16        data;
-}__attribute__ ((packed));
+	u8 id;
+	u16 data;
+} __attribute__ ((packed));
 
 void f_hid_kbd_translate_report(struct hid_report *report, u8 *data)
 {
-    if(f_hid_bypass_input_get())
-    {
-        int i,j;
-        struct kbd_report  k = {0};
-        struct consumer_report c = {0};
-        
-        struct hid_field *field;
-        
-        k.id = KBD_REPORT_ID;//report id
-        for (i = 0; i < report->maxfield; i++){
-            field = report->field[i];
-            if(HID_MAIN_ITEM_VARIABLE & field->flags)//VARIABLE REPORT
-            {
-                for(j = 0; j < field->report_count; j++)
-                {
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_LEFTCTRL)) 
-                        k.command |= field->value[j] ? 1 << 0 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_LEFTSHIFT)) 
-                        k.command |= field->value[j] ? 1 << 1 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_LEFTALT)) 
-                        k.command |= field->value[j] ? 1 << 2 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_LEFTMETA))
-                        k.command |= field->value[j] ? 1 << 3 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_RIGHTCTRL))
-                        k.command |= field->value[j] ? 1 << 4 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_RIGHTSHIFT)) 
-                        k.command |= field->value[j] ? 1 << 5 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_RIGHTALT)) 
-                        k.command |= field->value[j] ? 1 << 6 : 0 ;
-                    if((field->usage[j].type == EV_KEY) && (field->usage[j].code == KEY_RIGHTMETA)) 
-                        k.command |= field->value[j] ? 1 << 7 : 0 ;
-                }
-            }
-            else // ARRAY REPORT 
-            {
-                if(field->application == HID_GD_KEYBOARD)
-                {
-                    for(j = 0 ; j<(min(6,field->report_count)); j++)
-                    {
-                        k.key_array[j] = field->value[j];
-                    }
-                }
-                if(field->application == 0x000c0001)//CONSUMER PAGE
-                {
-                    for(j = 0 ; j < (field->report_count); j++)
-                    {
-                        c.id = CONSUMER_REPORT_ID;
-                        c.data = field->value[j];
-                        f_hid_queue_report((u8 *)&c, sizeof(c));
-                        return;
-                    }
-                }
-            }
-        } 
-        if(g_hidg->boot_protocol)
-            f_hid_queue_report((u8 *)&k+1, sizeof(k)-1);
-        else
-        {
-            f_hid_wakeup();
-            f_hid_queue_report((u8 *)&k, sizeof(k));
-        }
-    }
+	if (f_hid_bypass_input_get()) {
+		int i, j;
+		struct kbd_report k = { 0 };
+		struct consumer_report c = { 0 };
+
+		struct hid_field *field;
+
+		k.id = KBD_REPORT_ID;	/* report id */
+		for (i = 0; i < report->maxfield; i++) {
+			field = report->field[i];
+			/* VARIABLE REPORT */
+			if (HID_MAIN_ITEM_VARIABLE & field->flags) {
+				for (j = 0; j < field->report_count; j++) {
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_LEFTCTRL))
+						k.command |=
+						    field->value[j] ? 1 << 0 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_LEFTSHIFT))
+						k.command |=
+						    field->value[j] ? 1 << 1 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_LEFTALT))
+						k.command |=
+						    field->value[j] ? 1 << 2 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_LEFTMETA))
+						k.command |=
+						    field->value[j] ? 1 << 3 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_RIGHTCTRL))
+						k.command |=
+						    field->value[j] ? 1 << 4 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_RIGHTSHIFT))
+						k.command |=
+						    field->value[j] ? 1 << 5 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_RIGHTALT))
+						k.command |=
+						    field->value[j] ? 1 << 6 :
+						    0;
+					if ((field->usage[j].type == EV_KEY)
+					    && (field->usage[j].code ==
+						KEY_RIGHTMETA))
+						k.command |=
+						    field->value[j] ? 1 << 7 :
+						    0;
+				}
+			} else {
+				/* ARRAY REPORT */
+				if (field->application == HID_GD_KEYBOARD) {
+					for (j = 0;
+					     j < (min(6, field->report_count));
+					     j++) {
+						k.key_array[j] =
+						    field->value[j];
+					}
+				}
+				if (field->application == 0x000c0001) {
+					/* CONSUMER PAGE */
+					for (j = 0; j < (field->report_count);
+					     j++) {
+						c.id = CONSUMER_REPORT_ID;
+						c.data = field->value[j];
+						f_hid_queue_report((u8 *)&c,
+								   sizeof(c));
+						return;
+					}
+				}
+			}
+		}
+		if (g_hidg->boot_protocol)
+			f_hid_queue_report((u8 *)&k + 1, sizeof(k) - 1);
+		else {
+			f_hid_wakeup();
+			f_hid_queue_report((u8 *)&k, sizeof(k));
+		}
+	}
 }
+
 EXPORT_SYMBOL(f_hid_kbd_translate_report);
 
 struct mouse_report {
-    u8        id:8;
-    bool      button_left:1;
-    bool      button_right:1;
-    bool      button_middle:1;
-    bool      button_side:1;
-    bool      button_extra:1;
-    bool      button_forward:1;
-    bool      button_back:1;
-    bool      button_task:1;
-
-    signed    x :12;
-    signed    y :12;
-    s8        wheel:8;
-}__attribute__ ((packed));
-
+	u8 id:8;
+	bool button_left:1;
+	bool button_right:1;
+	bool button_middle:1;
+	bool button_side:1;
+	bool button_extra:1;
+	bool button_forward:1;
+	bool button_back:1;
+	bool button_task:1;
+
+	signed x : 12;
+	signed y : 12;
+	s8 wheel:8;
+} __attribute__ ((packed));
 
 void f_hid_mouse_translate_report(struct hid_report *report, u8 *data)
 {
 
-    if(f_hid_bypass_input_get() && !g_hidg->boot_protocol)
-    {
-        struct mouse_report m = {0};
-        struct hid_field *field;
-        
-        int i,j;
-        m.id     = MOUSE_REPORT_ID;
-        for (i = 0; i < report->maxfield; i++){
-            field = report->field[i];
-            for(j=0; j<field->report_count; j++)
-            {
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_LEFT))
-                    if(field->value[j])
-                        m.button_left= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_RIGHT))
-                    if(field->value[j])
-                        m.button_right= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_MIDDLE))
-                    if(field->value[j])
-                        m.button_middle= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_SIDE))
-                    if(field->value[j])
-                        m.button_side= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_EXTRA))
-                    if(field->value[j])
-                        m.button_extra= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_FORWARD))
-                    if(field->value[j])
-                        m.button_forward= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_BACK))
-                    if(field->value[j])
-                        m.button_back= 1;
-                if((field->usage[j].type == EV_KEY) && (field->usage[j].code == BTN_TASK))
-                    if(field->value[j])
-                        m.button_task= 1;
-
-                        
-                if((field->usage[j].type == EV_REL) && (field->usage[j].code == REL_X))
-                    m.x = field->value[j];
-                if((field->usage[j].type == EV_REL) && (field->usage[j].code == REL_Y))
-                    m.y = field->value[j];
-                if((field->usage[j].type == EV_REL) && (field->usage[j].code == REL_WHEEL))
-                    m.wheel= field->value[j];
-            }
-        }
-        if(m.button_right || m.button_left)
-            f_hid_wakeup();
-        f_hid_queue_report((u8 *)&m, sizeof(m));
-    }
+	if (f_hid_bypass_input_get() && !g_hidg->boot_protocol) {
+		struct mouse_report m = { 0 };
+		struct hid_field *field;
+
+		int i, j;
+		m.id = MOUSE_REPORT_ID;
+		for (i = 0; i < report->maxfield; i++) {
+			field = report->field[i];
+			for (j = 0; j < field->report_count; j++) {
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_LEFT))
+					if (field->value[j])
+						m.button_left = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_RIGHT))
+					if (field->value[j])
+						m.button_right = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_MIDDLE))
+					if (field->value[j])
+						m.button_middle = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_SIDE))
+					if (field->value[j])
+						m.button_side = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_EXTRA))
+					if (field->value[j])
+						m.button_extra = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_FORWARD))
+					if (field->value[j])
+						m.button_forward = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_BACK))
+					if (field->value[j])
+						m.button_back = 1;
+				if ((field->usage[j].type == EV_KEY)
+				    && (field->usage[j].code == BTN_TASK))
+					if (field->value[j])
+						m.button_task = 1;
+
+				if ((field->usage[j].type == EV_REL)
+				    && (field->usage[j].code == REL_X))
+					m.x = field->value[j];
+				if ((field->usage[j].type == EV_REL)
+				    && (field->usage[j].code == REL_Y))
+					m.y = field->value[j];
+				if ((field->usage[j].type == EV_REL)
+				    && (field->usage[j].code == REL_WHEEL))
+					m.wheel = field->value[j];
+			}
+		}
+		if (m.button_right || m.button_left)
+			f_hid_wakeup();
+		f_hid_queue_report((u8 *)&m, sizeof(m));
+	}
 }
+
 EXPORT_SYMBOL(f_hid_mouse_translate_report);
 
 #undef KBD_REPORT_ID
 #undef MOUSE_REPORT_ID
 #undef CONSUMER_REPORT_ID
 
-
 static unsigned int f_hidg_poll(struct file *file, poll_table *wait)
 {
 	return 0;
@@ -613,8 +648,7 @@ static int f_hidg_release(struct inode *inode, struct file *fd)
 
 static int f_hidg_open(struct inode *inode, struct file *fd)
 {
-	struct f_hidg *hidg =
-		container_of(inode->i_cdev, struct f_hidg, cdev);
+	struct f_hidg *hidg = container_of(inode->i_cdev, struct f_hidg, cdev);
 
 	fd->private_data = hidg;
 
@@ -626,33 +660,34 @@ static int f_hidg_open(struct inode *inode, struct file *fd)
 
 void hidg_connect()
 {
-    if(g_hidg)
-        g_hidg->connected = 1; 
+	if (g_hidg)
+		g_hidg->connected = 1;
 }
 
 void hidg_disconnect()
 {
-    if(g_hidg){
-        g_hidg->connected = 0;
-    }
+	if (g_hidg) {
+		g_hidg->connected = 0;
+	}
 }
+
 EXPORT_SYMBOL(hidg_disconnect);
 int hidg_start(struct usb_composite_dev *cdev);
 
 static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_hidg *hidg = (struct f_hidg *)req->context;
-    printk("hidg_set_report_complete ,req->status = %d len = %d\n",
-    req->status,req->actual);
+	printk("hidg_set_report_complete ,req->status = %d len = %d\n",
+	       req->status, req->actual);
 	if (req->status != 0 || req->buf == NULL || req->actual == 0) {
 		return;
 	}
-    
+
 	spin_lock(&hidg->spinlock);
 
-    if(!hidg->connected)
-        hidg_connect();
-    
+	if (!hidg->connected)
+		hidg_connect();
+
 	hidg->set_report_buff = krealloc(hidg->set_report_buff,
 					 req->actual, GFP_ATOMIC);
 
@@ -662,31 +697,31 @@ static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
 	}
 	hidg->set_report_length = req->actual;
 	memcpy(hidg->set_report_buff, req->buf, req->actual);
-    
+
 	spin_unlock(&hidg->spinlock);
 
 	wake_up(&hidg->read_queue);
 }
 
 static int hidg_setup(struct usb_function *f,
-		const struct usb_ctrlrequest *ctrl)
+		      const struct usb_ctrlrequest *ctrl)
 {
-	struct f_hidg			*hidg = func_to_hidg(f);
-	struct usb_composite_dev	*cdev = f->config->cdev;
-	struct usb_request		*req  = cdev->req;
+	struct f_hidg *hidg = func_to_hidg(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request *req = cdev->req;
 	int status = 0;
 	__u16 value, length;
 
-	value	= __le16_to_cpu(ctrl->wValue);
-	length	= __le16_to_cpu(ctrl->wLength);
+	value = __le16_to_cpu(ctrl->wValue);
+	length = __le16_to_cpu(ctrl->wLength);
 
 	VDBG(cdev, "hid_setup crtl_request : bRequestType:0x%x bRequest:0x%x "
-		"Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);
+	     "Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);
 
 	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
-	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_GET_REPORT):
-		VDBG(cdev, "get_report\n");
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_GET_REPORT):
+		VDBG(cdev,
+		     "get_report\n");
 
 		/* send an empty report */
 		length = min_t(unsigned, length, hidg->report_length);
@@ -695,48 +730,46 @@ static int hidg_setup(struct usb_function *f,
 		goto respond;
 		break;
 
-	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_GET_PROTOCOL):
-		VDBG(cdev, "get_protocol\n");
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_GET_PROTOCOL):
+		VDBG(cdev,
+		     "get_protocol\n");
 		goto stall;
 		break;
 
-	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_SET_REPORT):
-		VDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);
-		req->context  = hidg;
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_SET_REPORT):
+		VDBG(cdev, "set_report | wLenght=%d\n",
+		     ctrl->wLength);
+		req->context = hidg;
 		req->complete = hidg_set_report_complete;
 		goto respond;
 		break;
 
-	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_SET_PROTOCOL):
-		VDBG(cdev, "set_protocol\n");
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_SET_PROTOCOL):
+		VDBG(cdev,
+		     "set_protocol\n");
 		goto stall;
 		break;
 
-	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8
-		  | USB_REQ_GET_DESCRIPTOR):
+	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8 | USB_REQ_GET_DESCRIPTOR):
 		switch (value >> 8) {
 		case HID_DT_REPORT:
 			VDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");
 			length = min_t(unsigned short, length,
-						   hidg->report_desc_length);
+				       hidg->report_desc_length);
 			memcpy(req->buf, hidg->report_desc, length);
 			goto respond;
 			break;
 
 		default:
 			VDBG(cdev, "Unknown decriptor request 0x%x\n",
-				 value >> 8);
+			     value >> 8);
 			goto stall;
 			break;
 		}
 		break;
 
 	default:
-		VDBG(cdev, "Unknown request 0x%x\n",
-			 ctrl->bRequest);
+		VDBG(cdev, "Unknown request 0x%x\n", ctrl->bRequest);
 		goto stall;
 		break;
 	}
@@ -748,76 +781,75 @@ static int hidg_setup(struct usb_function *f,
 	req->zero = 0;
 	req->length = length;
 	status = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
-	if (status < 0)
-		;//ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);
+	/* if (status < 0) ; */
+	/* ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);*/
 	return status;
 }
 
 static int hidg_ctrlrequest(struct usb_composite_dev *cdev,
-		const struct usb_ctrlrequest *ctrl)
+			    const struct usb_ctrlrequest *ctrl)
 {
-	struct f_hidg			*hidg = g_hidg;
-	struct usb_request		*req  = cdev->req;
+	struct f_hidg *hidg = g_hidg;
+	struct usb_request *req = cdev->req;
 	int status = 0;
 	__u16 value, length;
 
-	value	= __le16_to_cpu(ctrl->wValue);
-	length	= __le16_to_cpu(ctrl->wLength);
+	value = __le16_to_cpu(ctrl->wValue);
+	length = __le16_to_cpu(ctrl->wLength);
 
-    /*
-	printk("hid_setup crtl_request : bRequestType:0x%x bRequest:0x%x "
-		"Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);
-    */
+	/*
+	   printk("hid_setup crtl_request : bRequestType:0x%x bRequest:0x%x "
+	   "Value:0x%x\n", ctrl->bRequestType, ctrl->bRequest, value);
+	 */
 	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
-	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_GET_REPORT):
-		VDBG(cdev, "get_report\n");
-        return -EOPNOTSUPP;//this command bypass to rndis
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_GET_REPORT):
+		VDBG(cdev,
+		     "get_report\n");
+		return -EOPNOTSUPP;	/* this command bypass to rndis */
 		/* send an empty report */
 		length = min_t(unsigned, length, hidg->report_length);
 		memset(req->buf, 0x0, length);
 		goto respond;
 		break;
 
-	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_GET_PROTOCOL):
-		VDBG(cdev, "get_protocol\n");
+	case ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_GET_PROTOCOL):
+		VDBG(cdev,
+		     "get_protocol\n");
 		goto stall;
 		break;
 
-	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_SET_REPORT):
-		VDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);
-		req->context  = hidg;
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_SET_REPORT):
+		VDBG(cdev, "set_report | wLenght=%d\n",
+		     ctrl->wLength);
+		req->context = hidg;
 		req->complete = hidg_set_report_complete;
 		goto respond;
 		break;
-		
-    case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-          | HID_REQ_SET_IDLE):
-        VDBG(cdev, "set_report | wLenght=%d\n", ctrl->wLength);
-        req->context  = hidg;
-        req->complete = hidg_set_report_complete;
-        goto respond;
-        break;
-
-	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8
-		  | HID_REQ_SET_PROTOCOL):
-		VDBG(cdev, "set_protocol\n");
-		req->context  = hidg;
+
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_SET_IDLE):
+		VDBG(cdev, "set_report | wLenght=%d\n",
+		     ctrl->wLength);
+		req->context = hidg;
+		req->complete = hidg_set_report_complete;
+		goto respond;
+		break;
+
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8 | HID_REQ_SET_PROTOCOL):
+		VDBG(cdev,
+		     "set_protocol\n");
+		req->context = hidg;
 		req->complete = hidg_set_report_complete;
 		hidg->boot_protocol = 1;
 		hidg_start(cdev);
 		goto respond;
 		break;
 
-	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8
-		  | USB_REQ_GET_DESCRIPTOR):
+	case ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8 | USB_REQ_GET_DESCRIPTOR):
 		switch (value >> 8) {
 		case HID_DT_REPORT:
 			VDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");
 			length = min_t(unsigned short, length,
-						   hidg->report_desc_length);
+				       hidg->report_desc_length);
 			memcpy(req->buf, hidg->report_desc, length);
 			hidg->boot_protocol = 0;
 			goto respond;
@@ -825,15 +857,14 @@ static int hidg_ctrlrequest(struct usb_composite_dev *cdev,
 
 		default:
 			VDBG(cdev, "Unknown decriptor request 0x%x\n",
-				 value >> 8);
+			     value >> 8);
 			goto stall;
 			break;
 		}
 		break;
 
 	default:
-		VDBG(cdev, "Unknown request 0x%x\n",
-			 ctrl->bRequest);
+		VDBG(cdev, "Unknown request 0x%x\n", ctrl->bRequest);
 		goto stall;
 		break;
 	}
@@ -845,8 +876,8 @@ static int hidg_ctrlrequest(struct usb_composite_dev *cdev,
 	req->zero = 0;
 	req->length = length;
 	status = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
-	if (status < 0)
-		;//ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);
+	/* if (status < 0) ; */
+	/* ERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);*/
 	return status;
 }
 
@@ -860,13 +891,13 @@ static void hidg_disable(struct usb_function *f)
 
 static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
-	struct usb_composite_dev		*cdev = f->config->cdev;
-	struct f_hidg				*hidg = func_to_hidg(f);
-	const struct usb_endpoint_descriptor	*ep_desc;
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct f_hidg *hidg = func_to_hidg(f);
+	const struct usb_endpoint_descriptor *ep_desc;
 	int status = 0;
 	VDBG(cdev, "hidg_set_alt intf:%d alt:%d\n", intf, alt);
-	
-    printk("^^^^^hidg_set_alt\n");
+
+	printk("^^^^^hidg_set_alt\n");
 
 	if (hidg->in_ep != NULL) {
 		/* restart endpoint */
@@ -874,10 +905,10 @@ static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 			usb_ep_disable(hidg->in_ep);
 
 		ep_desc = ep_choose(f->config->cdev->gadget,
-				hidg->hs_in_ep_desc, hidg->fs_in_ep_desc);
+				    hidg->hs_in_ep_desc, hidg->fs_in_ep_desc);
 		status = usb_ep_enable(hidg->in_ep, ep_desc);
 		if (status < 0) {
-			//ERROR(cdev, "Enable endpoint FAILED!\n");
+			/* ERROR(cdev, "Enable endpoint FAILED!\n"); */
 			goto fail;
 		}
 		hidg->in_ep->driver_data = hidg;
@@ -888,9 +919,9 @@ static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 int hidg_start(struct usb_composite_dev *cdev)
 {
-    printk("^^^^^hidg_start\n");
-	struct f_hidg				*hidg = g_hidg;
-	const struct usb_endpoint_descriptor	*ep_desc;
+	printk("^^^^^hidg_start\n");
+	struct f_hidg *hidg = g_hidg;
+	const struct usb_endpoint_descriptor *ep_desc;
 	int status = 0;
 
 	if (hidg->in_ep != NULL) {
@@ -899,7 +930,7 @@ int hidg_start(struct usb_composite_dev *cdev)
 			usb_ep_disable(hidg->in_ep);
 
 		ep_desc = ep_choose(cdev->gadget,
-				hidg->hs_in_ep_desc, hidg->fs_in_ep_desc);
+				    hidg->hs_in_ep_desc, hidg->fs_in_ep_desc);
 		status = usb_ep_enable(hidg->in_ep, ep_desc);
 		if (status < 0) {
 			printk("Enable endpoint FAILED!\n");
@@ -911,24 +942,23 @@ int hidg_start(struct usb_composite_dev *cdev)
 	return status;
 }
 
-
 const struct file_operations f_hidg_fops = {
-	.owner		= THIS_MODULE,
-	.open		= f_hidg_open,
-	.release	= f_hidg_release,
-	.write		= NULL,//f_hidg_write,disable write to /dev/hidg0
-	.read		= f_hidg_read,
-	.poll		= NULL,//f_hidg_poll,
-	.llseek		= noop_llseek,
+	.owner = THIS_MODULE,
+	.open = f_hidg_open,
+	.release = f_hidg_release,
+	.write = NULL,		/* f_hidg_write,disable write to /dev/hidg0 */
+	.read = f_hidg_read,
+	.poll = NULL,		/* f_hidg_poll, */
+	.llseek = noop_llseek,
 };
 
 static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 {
-    
-	struct usb_ep		*ep_in;
-	struct f_hidg		*hidg = func_to_hidg(f);
-	int			status;
-	dev_t			dev;
+
+	struct usb_ep *ep_in;
+	struct f_hidg *hidg = func_to_hidg(f);
+	int status;
+	dev_t dev;
 	/* allocate instance-specific interface IDs, and patch descriptors */
 	status = usb_interface_id(c, f);
 	if (status < 0)
@@ -949,7 +979,6 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 	if (!hidg->req)
 		goto fail;
 
-
 	hidg->req->buf = kmalloc(hidg->report_length, GFP_KERNEL);
 	if (!hidg->req->buf)
 		goto fail;
@@ -957,10 +986,10 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 	/* set descriptor dynamic values */
 	hidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;
 	hidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;
-//	hidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
-//	hidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
-//    hidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
-//	hidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);
+	/* hidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length); */
+	/* hidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length); */
+	/* hidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length); */
+	/* hidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length); */
 	hidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;
 	hidg_desc.desc[0].wDescriptorLength =
 		cpu_to_le16(hidg->report_desc_length);
@@ -978,7 +1007,7 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 
 	if (gadget_is_dualspeed(c->cdev->gadget)) {
 		hidg_hs_in_ep_desc.bEndpointAddress =
-			hidg_fs_in_ep_desc.bEndpointAddress;
+		    hidg_fs_in_ep_desc.bEndpointAddress;
 		f->hs_descriptors = usb_copy_descriptors(hidg_hs_descriptors);
 		if (!f->hs_descriptors)
 			goto fail;
@@ -989,7 +1018,7 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 		hidg->hs_in_ep_desc = NULL;
 	}
 
-    hidg->connected = 0;
+	hidg->connected = 0;
 
 	mutex_init(&hidg->lock);
 	spin_lock_init(&hidg->spinlock);
@@ -1008,13 +1037,13 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 	return 0;
 
 fail:
-	;//ERROR(f->config->cdev, "hidg_bind FAILED\n");
+	/* ERROR(f->config->cdev, "hidg_bind FAILED\n"); */
 	if (hidg->req != NULL) {
 		kfree(hidg->req->buf);
 		if (hidg->in_ep != NULL)
 			usb_ep_free_request(hidg->in_ep, hidg->req);
 	}
-    g_hidg = NULL;
+	g_hidg = NULL;
 	usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
 
@@ -1024,7 +1053,7 @@ static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
 static void hidg_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_hidg *hidg = func_to_hidg(f);
-    hidg_disconnect();
+	hidg_disconnect();
 
 	device_destroy(hidg_class, MKDEV(major, hidg->minor));
 	cdev_del(&hidg->cdev);
@@ -1032,19 +1061,18 @@ static void hidg_unbind(struct usb_configuration *c, struct usb_function *f)
 	/* disable/free request and end point */
 	usb_ep_disable(hidg->in_ep);
 	usb_ep_dequeue(hidg->in_ep, hidg->req);
-	if(hidg->req->buf)
-	kfree(hidg->req->buf);
+	if (hidg->req->buf)
+		kfree(hidg->req->buf);
 	usb_ep_free_request(hidg->in_ep, hidg->req);
 
 	/* free descriptors copies */
 	usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
-	
-    
+
 	kfree(hidg->report_desc);
 	kfree(hidg->set_report_buff);
 	kfree(hidg);
-	
+
 	g_hidg = NULL;
 }
 
@@ -1054,13 +1082,13 @@ static void hidg_unbind(struct usb_configuration *c, struct usb_function *f)
 #define CT_FUNC_HID_IDX	0
 
 static struct usb_string ct_func_string_defs[] = {
-	[CT_FUNC_HID_IDX].s	= "HID Interface",
+	[CT_FUNC_HID_IDX].s = "HID Interface",
 	{},			/* end of list */
 };
 
 static struct usb_gadget_strings ct_func_string_table = {
-	.language	= 0x0409,	/* en-US */
-	.strings	= ct_func_string_defs,
+	.language = 0x0409,	/* en-US */
+	.strings = ct_func_string_defs,
 };
 
 static struct usb_gadget_strings *ct_func_strings[] = {
@@ -1072,7 +1100,7 @@ static struct usb_gadget_strings *ct_func_strings[] = {
 /*                             usb_configuration                           */
 
 int hidg_bind_config(struct usb_configuration *c,
-			    const struct hidg_func_descriptor *fdesc, int index)
+		     const struct hidg_func_descriptor *fdesc, int index)
 {
 	struct f_hidg *hidg;
 	int status;
@@ -1101,27 +1129,26 @@ int hidg_bind_config(struct usb_configuration *c,
 	hidg->report_length = fdesc->report_length;
 	hidg->report_desc_length = fdesc->report_desc_length;
 	hidg->report_desc = kmemdup(fdesc->report_desc,
-				    fdesc->report_desc_length,
-				    GFP_KERNEL);
+				    fdesc->report_desc_length, GFP_KERNEL);
 	if (!hidg->report_desc) {
 		kfree(hidg);
 		return -ENOMEM;
 	}
 
-	hidg->func.name    = "hid";
+	hidg->func.name = "hid";
 	hidg->func.strings = ct_func_strings;
-	hidg->func.bind    = hidg_bind;
-	hidg->func.unbind  = hidg_unbind;
+	hidg->func.bind = hidg_bind;
+	hidg->func.unbind = hidg_unbind;
 	hidg->func.set_alt = hidg_set_alt;
 	hidg->func.disable = hidg_disable;
-	hidg->func.setup   = hidg_setup;
-    
+	hidg->func.setup = hidg_setup;
+
 	status = usb_add_function(c, &hidg->func);
 	if (status)
 		kfree(hidg);
 	else
-        g_hidg = hidg;
-    g_hidg->u_cdev = c->cdev;
+		g_hidg = hidg;
+	g_hidg->u_cdev = c->cdev;
 	return status;
 }
 
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 7f4c3605b9f9..f39c0330a277 100755
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -193,7 +193,6 @@
  * of the Gadget, USB Mass Storage, and SCSI protocols.
  */
 
-
 /* #define VERBOSE_DEBUG */
 /* #define DUMP_MSGS */
 
@@ -252,77 +251,77 @@ struct fsg_operations {
 	 * marked as non-removable or with prevent_medium_removal flag
 	 * set).
 	 */
-	int (*thread_exits)(struct fsg_common *common);
+	int (*thread_exits) (struct fsg_common *common);
 	/*
 	 * Called prior to ejection.  Negative return means error,
 	 * zero means to continue with ejection, positive means not to
 	 * eject.
 	 */
-	int (*pre_eject)(struct fsg_common *common,
-			 struct fsg_lun *lun, int num);
+	int (*pre_eject) (struct fsg_common *common,
+			  struct fsg_lun *lun, int num);
 	/*
 	 * Called after ejection.  Negative return means error, zero
 	 * or positive is just a success.
 	 */
-	int (*post_eject)(struct fsg_common *common,
-			  struct fsg_lun *lun, int num);
+	int (*post_eject) (struct fsg_common *common,
+			   struct fsg_lun *lun, int num);
 };
 
 /* Data shared by all the FSG instances. */
 struct fsg_common {
-	struct usb_gadget	*gadget;
+	struct usb_gadget *gadget;
 	struct usb_composite_dev *cdev;
-	struct fsg_dev		*fsg, *new_fsg;
-	wait_queue_head_t	fsg_wait;
+	struct fsg_dev *fsg, *new_fsg;
+	wait_queue_head_t fsg_wait;
 
 	/* filesem protects: backing files in use */
-	struct rw_semaphore	filesem;
+	struct rw_semaphore filesem;
 
 	/* lock protects: state, all the req_busy's */
-	spinlock_t		lock;
-
-	struct usb_ep		*ep0;		/* Copy of gadget->ep0 */
-	struct usb_request	*ep0req;	/* Copy of cdev->req */
-	unsigned int		ep0_req_tag;
-
-	struct fsg_buffhd	*next_buffhd_to_fill;
-	struct fsg_buffhd	*next_buffhd_to_drain;
-	struct fsg_buffhd	*buffhds;
-
-	int			cmnd_size;
-	u8			cmnd[MAX_COMMAND_SIZE];
-
-	unsigned int		nluns;
-	unsigned int		lun;
-	struct fsg_lun		*luns;
-	struct fsg_lun		*curlun;
-
-	unsigned int		bulk_out_maxpacket;
-	enum fsg_state		state;		/* For exception handling */
-	unsigned int		exception_req_tag;
-
-	enum data_direction	data_dir;
-	u32			data_size;
-	u32			data_size_from_cmnd;
-	u32			tag;
-	u32			residue;
-	u32			usb_amount_left;
-
-	unsigned int		can_stall:1;
-	unsigned int		free_storage_on_release:1;
-	unsigned int		phase_error:1;
-	unsigned int		short_packet_received:1;
-	unsigned int		bad_lun_okay:1;
-	unsigned int		running:1;
-
-	int			thread_wakeup_needed;
-	struct completion	thread_notifier;
-	struct task_struct	*thread_task;
+	spinlock_t lock;
+
+	struct usb_ep *ep0;	/* Copy of gadget->ep0 */
+	struct usb_request *ep0req;	/* Copy of cdev->req */
+	unsigned int ep0_req_tag;
+
+	struct fsg_buffhd *next_buffhd_to_fill;
+	struct fsg_buffhd *next_buffhd_to_drain;
+	struct fsg_buffhd *buffhds;
+
+	int cmnd_size;
+	u8 cmnd[MAX_COMMAND_SIZE];
+
+	unsigned int nluns;
+	unsigned int lun;
+	struct fsg_lun *luns;
+	struct fsg_lun *curlun;
+
+	unsigned int bulk_out_maxpacket;
+	enum fsg_state state;	/* For exception handling */
+	unsigned int exception_req_tag;
+
+	enum data_direction data_dir;
+	u32 data_size;
+	u32 data_size_from_cmnd;
+	u32 tag;
+	u32 residue;
+	u32 usb_amount_left;
+
+	unsigned int can_stall:1;
+	unsigned int free_storage_on_release:1;
+	unsigned int phase_error:1;
+	unsigned int short_packet_received:1;
+	unsigned int bad_lun_okay:1;
+	unsigned int running:1;
+
+	int thread_wakeup_needed;
+	struct completion thread_notifier;
+	struct task_struct *thread_task;
 
 	/* Callback functions. */
-	const struct fsg_operations	*ops;
+	const struct fsg_operations *ops;
 	/* Gadget's private data. */
-	void			*private_data;
+	void *private_data;
 
 	/*
 	 * Vendor (8 chars), product (16 chars), release (4
@@ -330,7 +329,7 @@ struct fsg_common {
 	 */
 	char inquiry_string[8 + 16 + 4 + 1];
 
-	struct kref		ref;
+	struct kref ref;
 };
 
 struct fsg_config {
@@ -344,31 +343,31 @@ struct fsg_config {
 	} luns[FSG_MAX_LUNS];
 
 	/* Callback functions. */
-	const struct fsg_operations	*ops;
+	const struct fsg_operations *ops;
 	/* Gadget's private data. */
-	void			*private_data;
+	void *private_data;
 
-	const char *vendor_name;		/*  8 characters or less */
-	const char *product_name;		/* 16 characters or less */
+	const char *vendor_name;	/*  8 characters or less */
+	const char *product_name;	/* 16 characters or less */
 
-	char			can_stall;
+	char can_stall;
 };
 
 struct fsg_dev {
-	struct usb_function	function;
-	struct usb_gadget	*gadget;	/* Copy of cdev->gadget */
-	struct fsg_common	*common;
+	struct usb_function function;
+	struct usb_gadget *gadget;	/* Copy of cdev->gadget */
+	struct fsg_common *common;
 
-	u16			interface_number;
+	u16 interface_number;
 
-	unsigned int		bulk_in_enabled:1;
-	unsigned int		bulk_out_enabled:1;
+	unsigned int bulk_in_enabled:1;
+	unsigned int bulk_out_enabled:1;
 
-	unsigned long		atomic_bitflags;
+	unsigned long atomic_bitflags;
 #define IGNORE_BULK_OUT		0
 
-	struct usb_ep		*bulk_in;
-	struct usb_ep		*bulk_out;
+	struct usb_ep *bulk_in;
+	struct usb_ep *bulk_out;
 };
 
 static inline int __fsg_is_set(struct fsg_common *common,
@@ -388,7 +387,7 @@ static inline struct fsg_dev *fsg_from_func(struct usb_function *f)
 	return container_of(f, struct fsg_dev, function);
 }
 
-typedef void (*fsg_routine_t)(struct fsg_dev *);
+typedef void (*fsg_routine_t) (struct fsg_dev *);
 static int send_status(struct fsg_common *common);
 
 static int exception_in_progress(struct fsg_common *common)
@@ -400,7 +399,7 @@ static int exception_in_progress(struct fsg_common *common)
 static void set_bulk_out_req_length(struct fsg_common *common,
 				    struct fsg_buffhd *bh, unsigned int length)
 {
-	unsigned int	rem;
+	unsigned int rem;
 
 	bh->bulk_out_intended_length = length;
 	rem = length % common->bulk_out_maxpacket;
@@ -409,12 +408,11 @@ static void set_bulk_out_req_length(struct fsg_common *common,
 	bh->outreq->length = length;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 {
-	const char	*name;
+	const char *name;
 
 	if (ep == fsg->bulk_in)
 		name = "bulk-in";
@@ -426,7 +424,6 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 	return usb_ep_set_halt(ep);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 /* These routines may be called in process context or in_irq */
@@ -434,7 +431,7 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 /* Caller must hold fsg->lock */
 static void wakeup_thread(struct fsg_common *common)
 {
-	smp_wmb();	/* ensure the write of bh->state is complete */
+	smp_wmb();		/* ensure the write of bh->state is complete */
 	/* Tell the main thread that something has happened */
 	common->thread_wakeup_needed = 1;
 	if (common->thread_task)
@@ -443,7 +440,7 @@ static void wakeup_thread(struct fsg_common *common)
 
 static void raise_exception(struct fsg_common *common, enum fsg_state new_state)
 {
-	unsigned long		flags;
+	unsigned long flags;
 
 	/*
 	 * Do nothing if a higher-priority exception is already in progress.
@@ -461,12 +458,11 @@ static void raise_exception(struct fsg_common *common, enum fsg_state new_state)
 	spin_unlock_irqrestore(&common->lock, flags);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int ep0_queue(struct fsg_common *common)
 {
-	int	rc;
+	int rc;
 
 	rc = usb_ep_queue(common->ep0, common->ep0req, GFP_ATOMIC);
 	common->ep0->driver_data = common;
@@ -478,20 +474,19 @@ static int ep0_queue(struct fsg_common *common)
 	return rc;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 /* Completion handlers. These always run in_irq. */
 
 static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 {
-	struct fsg_common	*common = ep->driver_data;
-	struct fsg_buffhd	*bh = req->context;
+	struct fsg_common *common = ep->driver_data;
+	struct fsg_buffhd *bh = req->context;
 
 	if (req->status || req->actual != req->length)
 		DBG(common, "%s --> %d, %u/%u\n", __func__,
 		    req->status, req->actual, req->length);
-	if (req->status == -ECONNRESET)		/* Request was cancelled */
+	if (req->status == -ECONNRESET)	/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
@@ -505,14 +500,14 @@ static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 
 static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 {
-	struct fsg_common	*common = ep->driver_data;
-	struct fsg_buffhd	*bh = req->context;
+	struct fsg_common *common = ep->driver_data;
+	struct fsg_buffhd *bh = req->context;
 
 	dump_msg(common, "bulk-out", req->buf, req->actual);
 	if (req->status || req->actual != bh->bulk_out_intended_length)
 		DBG(common, "%s --> %d, %u/%u\n", __func__,
 		    req->status, req->actual, bh->bulk_out_intended_length);
-	if (req->status == -ECONNRESET)		/* Request was cancelled */
+	if (req->status == -ECONNRESET)	/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
@@ -524,14 +519,13 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 	spin_unlock(&common->lock);
 }
 
-static int fsg_setup(struct usb_function *f,
-		     const struct usb_ctrlrequest *ctrl)
+static int fsg_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 {
-	struct fsg_dev		*fsg = fsg_from_func(f);
-	struct usb_request	*req = fsg->common->ep0req;
-	u16			w_index = le16_to_cpu(ctrl->wIndex);
-	u16			w_value = le16_to_cpu(ctrl->wValue);
-	u16			w_length = le16_to_cpu(ctrl->wLength);
+	struct fsg_dev *fsg = fsg_from_func(f);
+	struct usb_request *req = fsg->common->ep0req;
+	u16 w_index = le16_to_cpu(ctrl->wIndex);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u16 w_length = le16_to_cpu(ctrl->wLength);
 
 	if (!fsg_is_set(fsg->common))
 		return -EOPNOTSUPP;
@@ -548,7 +542,7 @@ static int fsg_setup(struct usb_function *f,
 		    (USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE))
 			break;
 		if (w_index != fsg->interface_number || w_value != 0 ||
-				w_length != 0)
+		    w_length != 0)
 			return -EDOM;
 
 		/*
@@ -564,13 +558,13 @@ static int fsg_setup(struct usb_function *f,
 		    (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE))
 			break;
 		if (w_index != fsg->interface_number || w_value != 0 ||
-				w_length != 1)
+		    w_length != 1)
 			return -EDOM;
 		VDBG(fsg, "get max LUN\n");
-		*(u8 *)req->buf = fsg->common->nluns - 1;
+		*(u8 *) req->buf = fsg->common->nluns - 1;
 
 		/* Respond with data/status */
-		req->length = min((u16)1, w_length);
+		req->length = min((u16) 1, w_length);
 		return ep0_queue(fsg->common);
 	}
 
@@ -581,7 +575,6 @@ static int fsg_setup(struct usb_function *f,
 	return -EOPNOTSUPP;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 /* All the following routines run in process context */
@@ -591,7 +584,7 @@ static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
 			   struct usb_request *req, int *pbusy,
 			   enum fsg_buffer_state *state)
 {
-	int	rc;
+	int rc;
 
 	if (ep == fsg->bulk_in)
 		dump_msg(fsg, "bulk-in", req->buf, req->length);
@@ -638,7 +631,7 @@ static bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 
 static int sleep_thread(struct fsg_common *common)
 {
-	int	rc = 0;
+	int rc = 0;
 
 	/* Wait until a signal arrives or we are woken up */
 	for (;;) {
@@ -654,25 +647,24 @@ static int sleep_thread(struct fsg_common *common)
 	}
 	__set_current_state(TASK_RUNNING);
 	common->thread_wakeup_needed = 0;
-	smp_rmb();	/* ensure the latest bh->state is visible */
+	smp_rmb();		/* ensure the latest bh->state is visible */
 	return rc;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int do_read(struct fsg_common *common)
 {
-	struct fsg_lun		*curlun = common->curlun;
-	u32			lba;
-	struct fsg_buffhd	*bh;
-	int			rc;
-	u32			amount_left;
-	loff_t			file_offset, file_offset_tmp;
-	unsigned int		amount;
-	ssize_t			nread;
+	struct fsg_lun *curlun = common->curlun;
+	u32 lba;
+	struct fsg_buffhd *bh;
+	int rc;
+	u32 amount_left;
+	loff_t file_offset, file_offset_tmp;
+	unsigned int amount;
+	ssize_t nread;
 #ifdef CONFIG_USB_MSC_PROFILING
-	ktime_t			start, diff;
+	ktime_t start, diff;
 #endif
 
 	/*
@@ -703,7 +695,7 @@ static int do_read(struct fsg_common *common)
 	/* Carry out the file reads */
 	amount_left = common->data_size_from_cmnd;
 	if (unlikely(amount_left == 0))
-		return -EIO;		/* No default reply */
+		return -EIO;	/* No default reply */
 
 	for (;;) {
 		/*
@@ -713,16 +705,16 @@ static int do_read(struct fsg_common *common)
 		 * And don't try to read past the end of the file.
 		 */
 		amount = min(amount_left, FSG_BUFLEN);
-		amount = min((loff_t)amount,
+		amount = min((loff_t) amount,
 			     curlun->file_length - file_offset);
 		/* kever@rk
 		 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
 		 * because of the DOEPTSIZ.PKTCNT has only 10 bits
 		 */
-		if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
+		if ((common->gadget->speed != USB_SPEED_HIGH)
+		    && (amount > 0x8000))
 			amount = 0x8000;
 
-
 		/* Wait for the next buffer to become available */
 		bh = common->next_buffhd_to_fill;
 		while (bh->state != BUF_STATE_EMPTY) {
@@ -737,9 +729,9 @@ static int do_read(struct fsg_common *common)
 		 */
 		if (amount == 0) {
 			curlun->sense_data =
-					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			    SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun->sense_data_info =
-					file_offset >> curlun->blkbits;
+			    file_offset >> curlun->blkbits;
 			curlun->info_valid = 1;
 			bh->inreq->length = 0;
 			bh->state = BUF_STATE_FULL;
@@ -773,8 +765,8 @@ static int do_read(struct fsg_common *common)
 			     (int)nread, amount);
 			nread = round_down(nread, curlun->blksize);
 		}
-		file_offset  += nread;
-		amount_left  -= nread;
+		file_offset += nread;
+		amount_left -= nread;
 		common->residue -= nread;
 
 		/*
@@ -789,13 +781,13 @@ static int do_read(struct fsg_common *common)
 		if (nread < amount) {
 			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun->sense_data_info =
-					file_offset >> curlun->blkbits;
+			    file_offset >> curlun->blkbits;
 			curlun->info_valid = 1;
 			break;
 		}
 
 		if (amount_left == 0)
-			break;		/* No more left to read */
+			break;	/* No more left to read */
 
 		/* Send this buffer and go read some more */
 		bh->inreq->zero = 0;
@@ -808,27 +800,26 @@ static int do_read(struct fsg_common *common)
 	return -EIO;		/* No default reply */
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int do_write(struct fsg_common *common)
 {
-	struct fsg_lun		*curlun = common->curlun;
-	u32			lba;
-	struct fsg_buffhd	*bh;
-	int			get_some_more;
-	u32			amount_left_to_req, amount_left_to_write;
-	loff_t			usb_offset, file_offset, file_offset_tmp;
-	unsigned int		amount;
-	ssize_t			nwritten;
-	int			rc;
+	struct fsg_lun *curlun = common->curlun;
+	u32 lba;
+	struct fsg_buffhd *bh;
+	int get_some_more;
+	u32 amount_left_to_req, amount_left_to_write;
+	loff_t usb_offset, file_offset, file_offset_tmp;
+	unsigned int amount;
+	ssize_t nwritten;
+	int rc;
 
 #ifdef CONFIG_USB_CSW_HACK
-	int			i;
+	int i;
 #endif
 
 #ifdef CONFIG_USB_MSC_PROFILING
-	ktime_t			start, diff;
+	ktime_t start, diff;
 #endif
 	if (curlun->ro) {
 		curlun->sense_data = SS_WRITE_PROTECTED;
@@ -857,7 +848,7 @@ static int do_write(struct fsg_common *common)
 			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 			return -EINVAL;
 		}
-		if (!curlun->nofua && (common->cmnd[1] & 0x08)) { /* FUA */
+		if (!curlun->nofua && (common->cmnd[1] & 0x08)) {	/* FUA */
 			spin_lock(&curlun->filp->f_lock);
 			curlun->filp->f_flags |= O_SYNC;
 			spin_unlock(&curlun->filp->f_lock);
@@ -891,9 +882,9 @@ static int do_write(struct fsg_common *common)
 			if (usb_offset >= curlun->file_length) {
 				get_some_more = 0;
 				curlun->sense_data =
-					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+				    SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 				curlun->sense_data_info =
-					usb_offset >> curlun->blkbits;
+				    usb_offset >> curlun->blkbits;
 				curlun->info_valid = 1;
 				continue;
 			}
@@ -909,7 +900,8 @@ static int do_write(struct fsg_common *common)
 			 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
 			 * because of the DOEPTSIZ.PKTCNT has only 10 bits
 			 */
-			if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
+			if ((common->gadget->speed != USB_SPEED_HIGH)
+			    && (amount > 0x8000))
 				amount = 0x8000;
 
 			/*
@@ -928,7 +920,7 @@ static int do_write(struct fsg_common *common)
 		/* Write the received data to the backing file */
 		bh = common->next_buffhd_to_drain;
 		if (bh->state == BUF_STATE_EMPTY && !get_some_more)
-			break;			/* We stopped early */
+			break;	/* We stopped early */
 #ifdef CONFIG_USB_CSW_HACK
 		/*
 		 * If the csw packet is already submmitted to the hardware,
@@ -948,7 +940,7 @@ static int do_write(struct fsg_common *common)
 			if (bh->outreq->status != 0) {
 				curlun->sense_data = SS_COMMUNICATION_FAILURE;
 				curlun->sense_data_info =
-					file_offset >> curlun->blkbits;
+				    file_offset >> curlun->blkbits;
 				curlun->info_valid = 1;
 				break;
 			}
@@ -986,10 +978,10 @@ static int do_write(struct fsg_common *common)
 			diff = ktime_sub(ktime_get(), start);
 			curlun->perf.wbytes += nwritten;
 			curlun->perf.wtime =
-					ktime_add(curlun->perf.wtime, diff);
+			    ktime_add(curlun->perf.wtime, diff);
 #endif
 			if (signal_pending(current))
-				return -EINTR;		/* Interrupted! */
+				return -EINTR;	/* Interrupted! */
 
 			if (nwritten < 0) {
 				LDBG(curlun, "error in file write: %d\n",
@@ -998,7 +990,8 @@ static int do_write(struct fsg_common *common)
 			} else if (nwritten < amount) {
 				LDBG(curlun, "partial file write: %d/%u\n",
 				     (int)nwritten, amount);
-				nwritten = round_down(nwritten, curlun->blksize);
+				nwritten =
+				    round_down(nwritten, curlun->blksize);
 			}
 			file_offset += nwritten;
 			amount_left_to_write -= nwritten;
@@ -1008,7 +1001,7 @@ static int do_write(struct fsg_common *common)
 			if (nwritten < amount) {
 				curlun->sense_data = SS_WRITE_ERROR;
 				curlun->sense_data_info =
-					file_offset >> curlun->blkbits;
+				    file_offset >> curlun->blkbits;
 				curlun->info_valid = 1;
 #ifdef CONFIG_USB_CSW_HACK
 				write_error_after_csw_sent = 1;
@@ -1016,7 +1009,6 @@ static int do_write(struct fsg_common *common)
 #endif
 				break;
 			}
-
 #ifdef CONFIG_USB_CSW_HACK
 write_error:
 			if ((nwritten == amount) && !csw_hack_sent) {
@@ -1031,7 +1023,7 @@ static int do_write(struct fsg_common *common)
 				 */
 				for (i = 0; i < fsg_num_buffers; i++) {
 					if (common->buffhds[i].state ==
-							BUF_STATE_BUSY)
+					    BUF_STATE_BUSY)
 						break;
 				}
 				if (!amount_left_to_req && i == fsg_num_buffers) {
@@ -1041,7 +1033,7 @@ static int do_write(struct fsg_common *common)
 			}
 #endif
 
- empty_write:
+empty_write:
 			/* Did the host decide to stop early? */
 			if (bh->outreq->actual < bh->bulk_out_intended_length) {
 				common->short_packet_received = 1;
@@ -1059,13 +1051,12 @@ static int do_write(struct fsg_common *common)
 	return -EIO;		/* No default reply */
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int do_synchronize_cache(struct fsg_common *common)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		rc;
+	struct fsg_lun *curlun = common->curlun;
+	int rc;
 
 	/* We ignore the requested LBA and write out all file's
 	 * dirty data buffers. */
@@ -1075,14 +1066,13 @@ static int do_synchronize_cache(struct fsg_common *common)
 	return 0;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static void invalidate_sub(struct fsg_lun *curlun)
 {
-	struct file	*filp = curlun->filp;
-	struct inode	*inode = file_inode(filp);
-	unsigned long	rc;
+	struct file *filp = curlun->filp;
+	struct inode *inode = file_inode(filp);
+	unsigned long rc;
 
 	rc = invalidate_mapping_pages(inode->i_mapping, 0, -1);
 	VLDBG(curlun, "invalidate_mapping_pages -> %ld\n", rc);
@@ -1090,14 +1080,14 @@ static void invalidate_sub(struct fsg_lun *curlun)
 
 static int do_verify(struct fsg_common *common)
 {
-	struct fsg_lun		*curlun = common->curlun;
-	u32			lba;
-	u32			verification_length;
-	struct fsg_buffhd	*bh = common->next_buffhd_to_fill;
-	loff_t			file_offset, file_offset_tmp;
-	u32			amount_left;
-	unsigned int		amount;
-	ssize_t			nread;
+	struct fsg_lun *curlun = common->curlun;
+	u32 lba;
+	u32 verification_length;
+	struct fsg_buffhd *bh = common->next_buffhd_to_fill;
+	loff_t file_offset, file_offset_tmp;
+	u32 amount_left;
+	unsigned int amount;
+	ssize_t nread;
 
 	/*
 	 * Get the starting Logical Block Address and check that it's
@@ -1120,7 +1110,7 @@ static int do_verify(struct fsg_common *common)
 
 	verification_length = get_unaligned_be16(&common->cmnd[7]);
 	if (unlikely(verification_length == 0))
-		return -EIO;		/* No default reply */
+		return -EIO;	/* No default reply */
 
 	/* Prepare to carry out the file verify */
 	amount_left = verification_length << curlun->blkbits;
@@ -1144,13 +1134,13 @@ static int do_verify(struct fsg_common *common)
 		 * And don't try to read past the end of the file.
 		 */
 		amount = min(amount_left, FSG_BUFLEN);
-		amount = min((loff_t)amount,
+		amount = min((loff_t) amount,
 			     curlun->file_length - file_offset);
 		if (amount == 0) {
 			curlun->sense_data =
-					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			    SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun->sense_data_info =
-				file_offset >> curlun->blkbits;
+			    file_offset >> curlun->blkbits;
 			curlun->info_valid = 1;
 			break;
 		}
@@ -1158,11 +1148,10 @@ static int do_verify(struct fsg_common *common)
 		/* Perform the read */
 		file_offset_tmp = file_offset;
 		nread = vfs_read(curlun->filp,
-				(char __user *) bh->buf,
-				amount, &file_offset_tmp);
+				 (char __user *)bh->buf,
+				 amount, &file_offset_tmp);
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
-				(unsigned long long) file_offset,
-				(int) nread);
+		      (unsigned long long)file_offset, (int)nread);
 		if (signal_pending(current))
 			return -EINTR;
 
@@ -1177,7 +1166,7 @@ static int do_verify(struct fsg_common *common)
 		if (nread == 0) {
 			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun->sense_data_info =
-				file_offset >> curlun->blkbits;
+			    file_offset >> curlun->blkbits;
 			curlun->info_valid = 1;
 			break;
 		}
@@ -1187,19 +1176,18 @@ static int do_verify(struct fsg_common *common)
 	return 0;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)
 {
 	struct fsg_lun *curlun = common->curlun;
-	u8	*buf = (u8 *) bh->buf;
+	u8 *buf = (u8 *) bh->buf;
 
 	if (!curlun) {		/* Unsupported LUNs are okay */
 		common->bad_lun_okay = 1;
 		memset(buf, 0, 36);
-		buf[0] = 0x7f;		/* Unsupported, no device-type */
-		buf[4] = 31;		/* Additional length */
+		buf[0] = 0x7f;	/* Unsupported, no device-type */
+		buf[4] = 31;	/* Additional length */
 		return 36;
 	}
 
@@ -1217,10 +1205,10 @@ static int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)
 
 static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	u8		*buf = (u8 *) bh->buf;
-	u32		sd, sdinfo;
-	int		valid;
+	struct fsg_lun *curlun = common->curlun;
+	u8 *buf = (u8 *) bh->buf;
+	u32 sd, sdinfo;
+	int valid;
 
 	/*
 	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):
@@ -1230,10 +1218,10 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 	 * generates the contingent allegiance condition), then the
 	 * target shall either:
 	 *   a) report any pending sense data and preserve the unit
-	 *	attention condition on the logical unit, or,
+	 *      attention condition on the logical unit, or,
 	 *   b) report the unit attention condition, may discard any
-	 *	pending sense data, and clear the unit attention
-	 *	condition on the logical unit for that initiator.
+	 *      pending sense data, and clear the unit attention
+	 *      condition on the logical unit for that initiator.
 	 *
 	 * FSG normally uses option a); enable this code to use option b).
 	 */
@@ -1259,10 +1247,10 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 	}
 
 	memset(buf, 0, 18);
-	buf[0] = valid | 0x70;			/* Valid, current error */
+	buf[0] = valid | 0x70;	/* Valid, current error */
 	buf[2] = SK(sd);
 	put_unaligned_be32(sdinfo, &buf[3]);	/* Sense information */
-	buf[7] = 18 - 8;			/* Additional sense length */
+	buf[7] = 18 - 8;	/* Additional sense length */
 	buf[12] = ASC(sd);
 	buf[13] = ASCQ(sd);
 	return 18;
@@ -1270,10 +1258,10 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 
 static int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	u32		lba = get_unaligned_be32(&common->cmnd[2]);
-	int		pmi = common->cmnd[8];
-	u8		*buf = (u8 *)bh->buf;
+	struct fsg_lun *curlun = common->curlun;
+	u32 lba = get_unaligned_be32(&common->cmnd[2]);
+	int pmi = common->cmnd[8];
+	u8 *buf = (u8 *) bh->buf;
 
 	/* Check the PMI and LBA fields */
 	if (pmi > 1 || (pmi == 0 && lba != 0)) {
@@ -1282,19 +1270,19 @@ static int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)
 	}
 
 	put_unaligned_be32(curlun->num_sectors - 1, &buf[0]);
-						/* Max logical block */
-	put_unaligned_be32(curlun->blksize, &buf[4]);/* Block length */
+	/* Max logical block */
+	put_unaligned_be32(curlun->blksize, &buf[4]);	/* Block length */
 	return 8;
 }
 
 static int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		msf = common->cmnd[1] & 0x02;
-	u32		lba = get_unaligned_be32(&common->cmnd[2]);
-	u8		*buf = (u8 *)bh->buf;
+	struct fsg_lun *curlun = common->curlun;
+	int msf = common->cmnd[1] & 0x02;
+	u32 lba = get_unaligned_be32(&common->cmnd[2]);
+	u8 *buf = (u8 *) bh->buf;
 
-	if (common->cmnd[1] & ~0x02) {		/* Mask away MSF */
+	if (common->cmnd[1] & ~0x02) {	/* Mask away MSF */
 		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 		return -EINVAL;
 	}
@@ -1311,41 +1299,41 @@ static int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)
 
 static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		msf = common->cmnd[1] & 0x02;
-	int		start_track = common->cmnd[6];
-	u8		*buf = (u8 *)bh->buf;
+	struct fsg_lun *curlun = common->curlun;
+	int msf = common->cmnd[1] & 0x02;
+	int start_track = common->cmnd[6];
+	u8 *buf = (u8 *) bh->buf;
 
 	if ((common->cmnd[1] & ~0x02) != 0 ||	/* Mask away MSF */
-			start_track > 1) {
+	    start_track > 1) {
 		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 		return -EINVAL;
 	}
 
 	memset(buf, 0, 20);
-	buf[1] = (20-2);		/* TOC data length */
-	buf[2] = 1;			/* First track number */
-	buf[3] = 1;			/* Last track number */
-	buf[5] = 0x16;			/* Data track, copying allowed */
-	buf[6] = 0x01;			/* Only track is number 1 */
+	buf[1] = (20 - 2);	/* TOC data length */
+	buf[2] = 1;		/* First track number */
+	buf[3] = 1;		/* Last track number */
+	buf[5] = 0x16;		/* Data track, copying allowed */
+	buf[6] = 0x01;		/* Only track is number 1 */
 	store_cdrom_address(&buf[8], msf, 0);
 
-	buf[13] = 0x16;			/* Lead-out track is data */
-	buf[14] = 0xAA;			/* Lead-out track number */
+	buf[13] = 0x16;		/* Lead-out track is data */
+	buf[14] = 0xAA;		/* Lead-out track number */
 	store_cdrom_address(&buf[16], msf, curlun->num_sectors);
 	return 20;
 }
 
 static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		mscmnd = common->cmnd[0];
-	u8		*buf = (u8 *) bh->buf;
-	u8		*buf0 = buf;
-	int		pc, page_code;
-	int		changeable_values, all_pages;
-	int		valid_page = 0;
-	int		len, limit;
+	struct fsg_lun *curlun = common->curlun;
+	int mscmnd = common->cmnd[0];
+	u8 *buf = (u8 *) bh->buf;
+	u8 *buf0 = buf;
+	int pc, page_code;
+	int changeable_values, all_pages;
+	int valid_page = 0;
+	int len, limit;
 
 	if ((common->cmnd[1] & ~0x08) != 0) {	/* Mask away DBD */
 		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
@@ -1368,13 +1356,13 @@ static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 	 */
 	memset(buf, 0, 8);
 	if (mscmnd == MODE_SENSE) {
-		buf[2] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+		buf[2] = (curlun->ro ? 0x80 : 0x00);	/* WP, DPOFUA */
 		buf += 4;
 		limit = 255;
-	} else {			/* MODE_SENSE_10 */
-		buf[3] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+	} else {		/* MODE_SENSE_10 */
+		buf[3] = (curlun->ro ? 0x80 : 0x00);	/* WP, DPOFUA */
 		buf += 8;
-		limit = 65535;		/* Should really be FSG_BUFLEN */
+		limit = 65535;	/* Should really be FSG_BUFLEN */
 	}
 
 	/* No block descriptors */
@@ -1385,21 +1373,21 @@ static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 	 */
 	if (page_code == 0x08 || all_pages) {
 		valid_page = 1;
-		buf[0] = 0x08;		/* Page code */
-		buf[1] = 10;		/* Page length */
-		memset(buf+2, 0, 10);	/* None of the fields are changeable */
+		buf[0] = 0x08;	/* Page code */
+		buf[1] = 10;	/* Page length */
+		memset(buf + 2, 0, 10);	/* None of the fields are changeable */
 
 		if (!changeable_values) {
 			buf[2] = 0x04;	/* Write cache enable, */
-					/* Read cache not disabled */
-					/* No cache retention priorities */
+			/* Read cache not disabled */
+			/* No cache retention priorities */
 			put_unaligned_be16(0xffff, &buf[4]);
-					/* Don't disable prefetch */
-					/* Minimum prefetch = 0 */
+			/* Don't disable prefetch */
+			/* Minimum prefetch = 0 */
 			put_unaligned_be16(0xffff, &buf[8]);
-					/* Maximum prefetch */
+			/* Maximum prefetch */
 			put_unaligned_be16(0xffff, &buf[10]);
-					/* Maximum prefetch ceiling */
+			/* Maximum prefetch ceiling */
 		}
 		buf += 12;
 	}
@@ -1424,21 +1412,21 @@ static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
 
 static int do_start_stop(struct fsg_common *common)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		loej, start;
+	struct fsg_lun *curlun = common->curlun;
+	int loej, start;
 
 	if (!curlun) {
 		return -EINVAL;
 	} else if (!curlun->removable) {
 		curlun->sense_data = SS_INVALID_COMMAND;
 		return -EINVAL;
-	} else if ((common->cmnd[1] & ~0x01) != 0 || /* Mask away Immed */
-		   (common->cmnd[4] & ~0x03) != 0) { /* Mask LoEj, Start */
+	} else if ((common->cmnd[1] & ~0x01) != 0 ||	/* Mask away Immed */
+		   (common->cmnd[4] & ~0x03) != 0) {	/* Mask LoEj, Start */
 		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 		return -EINVAL;
 	}
 
-	loej  = common->cmnd[4] & 0x02;
+	loej = common->cmnd[4] & 0x02;
 	start = common->cmnd[4] & 0x01;
 
 	/*
@@ -1480,15 +1468,15 @@ static int do_start_stop(struct fsg_common *common)
 	down_read(&common->filesem);
 
 	return common->ops && common->ops->post_eject
-		? min(0, common->ops->post_eject(common, curlun,
-						 curlun - common->luns))
-		: 0;
+	    ? min(0, common->ops->post_eject(common, curlun,
+					     curlun - common->luns))
+	    : 0;
 }
 
 static int do_prevent_allow(struct fsg_common *common)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	int		prevent;
+	struct fsg_lun *curlun = common->curlun;
+	int prevent;
 
 	if (!common->curlun) {
 		return -EINVAL;
@@ -1510,25 +1498,25 @@ static int do_prevent_allow(struct fsg_common *common)
 }
 
 static int do_read_format_capacities(struct fsg_common *common,
-			struct fsg_buffhd *bh)
+				     struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
-	u8		*buf = (u8 *) bh->buf;
+	struct fsg_lun *curlun = common->curlun;
+	u8 *buf = (u8 *) bh->buf;
 
 	buf[0] = buf[1] = buf[2] = 0;
-	buf[3] = 8;	/* Only the Current/Maximum Capacity Descriptor */
+	buf[3] = 8;		/* Only the Current/Maximum Capacity Descriptor */
 	buf += 4;
 
 	put_unaligned_be32(curlun->num_sectors, &buf[0]);
-						/* Number of blocks */
-	put_unaligned_be32(curlun->blksize, &buf[4]);/* Block length */
-	buf[4] = 0x02;				/* Current capacity */
+	/* Number of blocks */
+	put_unaligned_be32(curlun->blksize, &buf[4]);	/* Block length */
+	buf[4] = 0x02;		/* Current capacity */
 	return 12;
 }
 
 static int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)
 {
-	struct fsg_lun	*curlun = common->curlun;
+	struct fsg_lun *curlun = common->curlun;
 
 	/* We don't support MODE SELECT */
 	if (curlun)
@@ -1536,12 +1524,11 @@ static int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)
 	return -EINVAL;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int halt_bulk_in_endpoint(struct fsg_dev *fsg)
 {
-	int	rc;
+	int rc;
 
 	rc = fsg_set_halt(fsg, fsg->bulk_in);
 	if (rc == -EAGAIN)
@@ -1563,7 +1550,7 @@ static int halt_bulk_in_endpoint(struct fsg_dev *fsg)
 
 static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 {
-	int	rc;
+	int rc;
 
 	DBG(fsg, "bulk-in set wedge\n");
 	rc = usb_ep_set_wedge(fsg->bulk_in);
@@ -1586,9 +1573,9 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 
 static int throw_away_data(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh;
-	u32			amount;
-	int			rc;
+	struct fsg_buffhd *bh;
+	u32 amount;
+	int rc;
 
 	for (bh = common->next_buffhd_to_drain;
 	     bh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;
@@ -1612,8 +1599,7 @@ static int throw_away_data(struct fsg_common *common)
 
 		/* Try to submit another request if we need one */
 		bh = common->next_buffhd_to_fill;
-		if (bh->state == BUF_STATE_EMPTY
-		 && common->usb_amount_left > 0) {
+		if (bh->state == BUF_STATE_EMPTY && common->usb_amount_left > 0) {
 			amount = min(common->usb_amount_left, FSG_BUFLEN);
 
 			/*
@@ -1640,19 +1626,19 @@ static int throw_away_data(struct fsg_common *common)
 
 static int finish_reply(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh = common->next_buffhd_to_fill;
-	int			rc = 0;
+	struct fsg_buffhd *bh = common->next_buffhd_to_fill;
+	int rc = 0;
 
 	switch (common->data_dir) {
 	case DATA_DIR_NONE:
-		break;			/* Nothing to send */
+		break;		/* Nothing to send */
 
-	/*
-	 * If we don't know whether the host wants to read or write,
-	 * this must be CB or CBI with an unknown command.  We mustn't
-	 * try to send or receive any data.  So stall both bulk pipes
-	 * if we can and wait for a reset.
-	 */
+		/*
+		 * If we don't know whether the host wants to read or write,
+		 * this must be CB or CBI with an unknown command.  We mustn't
+		 * try to send or receive any data.  So stall both bulk pipes
+		 * if we can and wait for a reset.
+		 */
 	case DATA_DIR_UNKNOWN:
 		if (!common->can_stall) {
 			/* Nothing */
@@ -1665,29 +1651,29 @@ static int finish_reply(struct fsg_common *common)
 		}
 		break;
 
-	/* All but the last buffer of data must have already been sent */
+		/* All but the last buffer of data must have already been sent */
 	case DATA_DIR_TO_HOST:
 		if (common->data_size == 0) {
 			/* Nothing to send */
 
-		/* Don't know what to do if common->fsg is NULL */
+			/* Don't know what to do if common->fsg is NULL */
 		} else if (!fsg_is_set(common)) {
 			rc = -EIO;
 
-		/* If there's no residue, simply send the last buffer */
+			/* If there's no residue, simply send the last buffer */
 		} else if (common->residue == 0) {
 			bh->inreq->zero = 0;
 			if (!start_in_transfer(common, bh))
 				return -EIO;
 			common->next_buffhd_to_fill = bh->next;
 
-		/*
-		 * For Bulk-only, mark the end of the data with a short
-		 * packet.  If we are allowed to stall, halt the bulk-in
-		 * endpoint.  (Note: This violates the Bulk-Only Transport
-		 * specification, which requires us to pad the data if we
-		 * don't halt the endpoint.  Presumably nobody will mind.)
-		 */
+			/*
+			 * For Bulk-only, mark the end of the data with a short
+			 * packet.  If we are allowed to stall, halt the bulk-in
+			 * endpoint.  (Note: This violates the Bulk-Only Transport
+			 * specification, which requires us to pad the data if we
+			 * don't halt the endpoint.  Presumably nobody will mind.)
+			 */
 		} else {
 			bh->inreq->zero = 1;
 			if (!start_in_transfer(common, bh))
@@ -1698,27 +1684,27 @@ static int finish_reply(struct fsg_common *common)
 		}
 		break;
 
-	/*
-	 * We have processed all we want from the data the host has sent.
-	 * There may still be outstanding bulk-out requests.
-	 */
+		/*
+		 * We have processed all we want from the data the host has sent.
+		 * There may still be outstanding bulk-out requests.
+		 */
 	case DATA_DIR_FROM_HOST:
 		if (common->residue == 0) {
 			/* Nothing to receive */
 
-		/* Did the host stop sending unexpectedly early? */
+			/* Did the host stop sending unexpectedly early? */
 		} else if (common->short_packet_received) {
 			raise_exception(common, FSG_STATE_ABORT_BULK_OUT);
 			rc = -EINTR;
 
-		/*
-		 * We haven't processed all the incoming data.  Even though
-		 * we may be allowed to stall, doing so would cause a race.
-		 * The controller may already have ACK'ed all the remaining
-		 * bulk-out packets, in which case the host wouldn't see a
-		 * STALL.  Not realizing the endpoint was halted, it wouldn't
-		 * clear the halt -- leading to problems later on.
-		 */
+			/*
+			 * We haven't processed all the incoming data.  Even though
+			 * we may be allowed to stall, doing so would cause a race.
+			 * The controller may already have ACK'ed all the remaining
+			 * bulk-out packets, in which case the host wouldn't see a
+			 * STALL.  Not realizing the endpoint was halted, it wouldn't
+			 * clear the halt -- leading to problems later on.
+			 */
 #if 0
 		} else if (common->can_stall) {
 			if (fsg_is_set(common))
@@ -1728,10 +1714,10 @@ static int finish_reply(struct fsg_common *common)
 			rc = -EINTR;
 #endif
 
-		/*
-		 * We can't stall.  Read in the excess data and throw it
-		 * all away.
-		 */
+			/*
+			 * We can't stall.  Read in the excess data and throw it
+			 * all away.
+			 */
 		} else {
 			rc = throw_away_data(common);
 		}
@@ -1742,12 +1728,12 @@ static int finish_reply(struct fsg_common *common)
 
 static int send_status(struct fsg_common *common)
 {
-	struct fsg_lun		*curlun = common->curlun;
-	struct fsg_buffhd	*bh;
-	struct bulk_cs_wrap	*csw;
-	int			rc;
-	u8			status = US_BULK_STAT_OK;
-	u32			sd, sdinfo = 0;
+	struct fsg_lun *curlun = common->curlun;
+	struct fsg_buffhd *bh;
+	struct bulk_cs_wrap *csw;
+	int rc;
+	u8 status = US_BULK_STAT_OK;
+	u32 sd, sdinfo = 0;
 
 	/* Wait for the next buffer to become available */
 	bh = common->next_buffhd_to_fill;
@@ -1773,8 +1759,7 @@ static int send_status(struct fsg_common *common)
 		DBG(common, "sending command-failure status\n");
 		status = US_BULK_STAT_FAIL;
 		VDBG(common, "  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"
-				"  info x%x\n",
-				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
+		     "  info x%x\n", SK(sd), ASC(sd), ASCQ(sd), sdinfo);
 	}
 
 	/* Store and send the Bulk-only CSW */
@@ -1808,7 +1793,6 @@ static int send_status(struct fsg_common *common)
 	return 0;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1819,18 +1803,18 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 			 enum data_direction data_dir, unsigned int mask,
 			 int needs_medium, const char *name)
 {
-	int			i;
-	unsigned int		lun = common->cmnd[1] >> 5;
-	static const char	dirletter[4] = {'u', 'o', 'i', 'n'};
-	char			hdlen[20];
-	struct fsg_lun		*curlun;
+	int i;
+	unsigned int lun = common->cmnd[1] >> 5;
+	static const char dirletter[4] = { 'u', 'o', 'i', 'n' };
+	char hdlen[20];
+	struct fsg_lun *curlun;
 
 	hdlen[0] = 0;
 	if (common->data_dir != DATA_DIR_UNKNOWN)
-		sprintf(hdlen, ", H%c=%u", dirletter[(int) common->data_dir],
+		sprintf(hdlen, ", H%c=%u", dirletter[(int)common->data_dir],
 			common->data_size);
 	VDBG(common, "SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s\n",
-	     name, cmnd_size, dirletter[(int) data_dir],
+	     name, cmnd_size, dirletter[(int)data_dir],
 	     common->data_size_from_cmnd, common->cmnd_size, hdlen);
 
 	/*
@@ -1916,15 +1900,14 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 	 * REQUEST SENSE commands are allowed; anything else must fail.
 	 */
 	if (curlun && curlun->unit_attention_data != SS_NO_SENSE &&
-	    common->cmnd[0] != INQUIRY &&
-	    common->cmnd[0] != REQUEST_SENSE) {
+	    common->cmnd[0] != INQUIRY && common->cmnd[0] != REQUEST_SENSE) {
 		curlun->sense_data = curlun->unit_attention_data;
 		curlun->unit_attention_data = SS_NO_SENSE;
 		return -EINVAL;
 	}
 
 	/* Check that only command bytes listed in the mask are non-zero */
-	common->cmnd[1] &= 0x1f;			/* Mask away the LUN */
+	common->cmnd[1] &= 0x1f;	/* Mask away the LUN */
 	for (i = 1; i < cmnd_size; ++i) {
 		if (common->cmnd[i] && !(mask & (1 << i))) {
 			if (curlun)
@@ -1945,13 +1928,15 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 
 /* wrapper of check_command for data size in blocks handling */
 static int check_command_size_in_blocks(struct fsg_common *common,
-		int cmnd_size, enum data_direction data_dir,
-		unsigned int mask, int needs_medium, const char *name)
+					int cmnd_size,
+					enum data_direction data_dir,
+					unsigned int mask, int needs_medium,
+					const char *name)
 {
 	if (common->curlun)
 		common->data_size_from_cmnd <<= common->curlun->blkbits;
 	return check_command(common, cmnd_size, data_dir,
-			mask, needs_medium, name);
+			     mask, needs_medium, name);
 }
 
 #ifdef CONFIG_ARCH_ROCKCHIP
@@ -1960,144 +1945,148 @@ static void deferred_restart(struct work_struct *dummy)
 	sys_sync();
 	kernel_restart("loader");
 }
+
 static DECLARE_WORK(restart_work, deferred_restart);
 
-typedef struct tagLoaderParam
-{
-	int	tag;
-	int	length;
-	char	parameter[1];
-	int	crc;
+typedef struct tagLoaderParam {
+	int tag;
+	int length;
+	char parameter[1];
+	int crc;
 } PARM_INFO;
 #define PARM_TAG			0x4D524150
 #define MSC_EXT_DBG			1
-extern int  GetParamterInfo(char * pbuf , int len);
+extern int GetParamterInfo(char *pbuf, int len);
 
 /* the buf is bh->buf,it is large enough. */
-static char * get_param_tag( char* buf , const char* tag )
+static char *get_param_tag(char *buf, const char *tag)
 {
-	PARM_INFO	*pi;
-	int 		i;
-	char		*pp = buf+256;
-	char		*spp;
-	i = GetParamterInfo( pp , 1024 );
-	pi = (PARM_INFO*)pp;
-	if( pi->tag != PARM_TAG ){
+	PARM_INFO *pi;
+	int i;
+	char *pp = buf + 256;
+	char *spp;
+	i = GetParamterInfo(pp, 1024);
+	pi = (PARM_INFO *) pp;
+	if (pi->tag != PARM_TAG) {
 error_out:
-		printk("paramter error,tag=0x%x\n" , pi->tag );
+		printk("paramter error,tag=0x%x\n", pi->tag);
 		return NULL;
 	}
-	if( pi->length+sizeof(PARM_INFO) > i ) {
-		GetParamterInfo( pp , pi->length+sizeof(PARM_INFO)  + 511 );
+	if (pi->length + sizeof(PARM_INFO) > i) {
+		GetParamterInfo(pp, pi->length + sizeof(PARM_INFO) + 511);
 	}
-	pp = strstr( pi->parameter , tag );
-	if( !pp )
+	pp = strstr(pi->parameter, tag);
+	if (!pp)
 		goto error_out;
-	pp += strlen(tag); // sizeof "MACHINE_MODEL:"
-	while( *pp == ' ' || *pp == '\t' ) {
-		if(pp - pi->parameter >= pi->length)
+	pp += strlen(tag);	/* sizeof "MACHINE_MODEL:" */
+	while (*pp == ' ' || *pp == '\t') {
+		if (pp - pi->parameter >= pi->length)
 			break;
 		pp++;
 	}
 	spp = pp;
-	while( *pp != 0x0d && *pp != 0x0a ) {
-		if(pp - pi->parameter >= pi->length)
+	while (*pp != 0x0d && *pp != 0x0a) {
+		if (pp - pi->parameter >= pi->length)
 			break;
 		pp++;
 	}
 	*pp = 0;
-	if( spp == pp ) return NULL;
-		return spp;
+	if (spp == pp)
+		return NULL;
+	return spp;
 }
 
-static int do_get_product_name(int ret ,char *buf)
+static int do_get_product_name(int ret, char *buf)
 {
-	char		*tag = "MACHINE_MODEL:";
-	char		*pname;
+	char *tag = "MACHINE_MODEL:";
+	char *pname;
 #if MSC_EXT_DBG
-	char 		tbuf[1024];
-	if( buf == NULL )   buf = tbuf;
+	char tbuf[1024];
+	if (buf == NULL)
+		buf = tbuf;
 #endif
-	memset( buf , 0 , ret );
-	pname = get_param_tag( buf , tag );
-	if( pname ){
-		strcpy( buf , pname);
+	memset(buf, 0, ret);
+	pname = get_param_tag(buf, tag);
+	if (pname) {
+		strcpy(buf, pname);
 	}
 #if MSC_EXT_DBG
-	printk("%s%s\n" , tag , buf );
+	printk("%s%s\n", tag, buf);
 #endif
 	return ret;
 }
 
-static int do_get_versions( int ret ,char* buf )
+static int do_get_versions(int ret, char *buf)
 {
 	/* get boot version and fireware version from cmdline
-	* bootver=2010-07-08#4.02 firmware_ver=1.0.0 // Firmware Ver:16.01.0000
-	* return format: 0x02 0x04 0x00 0x00 0x00 0x01
-	* RK29: bootver=2011-07-18#2.05 firmware_ver=0.2.3 (==00.02.0003)
-	* for the old loader,the firmware_ver may be empty,so get the fw ver from paramter.
-	*/
-#define ASC_BCD0( c )  (((c-'0'))&0xf)
-#define ASC_BCD1( c )  (((c-'0')<<4)&0xf0)
+	 * bootver=2010-07-08#4.02 firmware_ver=1.0.0 // Firmware Ver:16.01.0000
+	 * return format: 0x02 0x04 0x00 0x00 0x00 0x01
+	 * RK29: bootver=2011-07-18#2.05 firmware_ver=0.2.3 (==00.02.0003)
+	 * for the old loader,the firmware_ver may be empty,so get the fw ver from paramter.
+	 */
+#define ASC_BCD0(c)  (((c-'0'))&0xf)
+#define ASC_BCD1(c)  (((c-'0')<<4)&0xf0)
 
 	char *ver = buf;
-	char *p_l , *p_f;
+	char *p_l, *p_f;
 	char *l_tag = "bootver=";
 	char *fw_tag = "FIRMWARE_VER:";
 
 #if MSC_EXT_DBG
 	char tbuf[1024];
-	if( ver == NULL )
+	if (ver == NULL)
 		ver = tbuf;
 #endif
 
-	memset( ver , 0x00 , ret );
-	p_l = strstr( saved_command_line , l_tag );
-	if( !p_l ) {
+	memset(ver, 0x00, ret);
+	p_l = strstr(saved_command_line, l_tag);
+	if (!p_l) {
 		return ret;
 	}
-	p_l+=strlen( l_tag );
-	if( (p_l = strchr( p_l,'#')) ) {
+	p_l += strlen(l_tag);
+	p_l = strchr(p_l, '#');
+	if (p_l) {
 		p_l++;
-		if( p_l[1] == '.' ) {
+		if (p_l[1] == '.') {
 			ver[1] = ASC_BCD0(p_l[0]);
-			p_l+=2;
+			p_l += 2;
 		} else {
-			ver[1] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
-			p_l+=3;
+			ver[1] = ASC_BCD1(p_l[0]) | ASC_BCD0(p_l[1]);
+			p_l += 3;
 		}
-		ver[0] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
+		ver[0] = ASC_BCD1(p_l[0]) | ASC_BCD0(p_l[1]);
 	}
 
-	p_f = get_param_tag( ver , fw_tag );
-	if( !p_f ) return ret;
+	p_f = get_param_tag(ver, fw_tag);
+	if (!p_f)
+		return ret;
 
-	if( p_f[1] == '.' ) {
+	if (p_f[1] == '.') {
 		ver[5] = ASC_BCD0(p_f[0]);
-		p_f+=2;
+		p_f += 2;
 	} else {
-		ver[5] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
-		p_f+=3;
+		ver[5] = ASC_BCD1(p_f[0]) | ASC_BCD0(p_f[1]);
+		p_f += 3;
 	}
-	if( p_f[1] == '.' ) {
+	if (p_f[1] == '.') {
 		ver[4] = ASC_BCD0(p_f[0]);
-		p_f+=2;
+		p_f += 2;
 	} else {
-		ver[4] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
-		p_f+=3;
+		ver[4] = ASC_BCD1(p_f[0]) | ASC_BCD0(p_f[1]);
+		p_f += 3;
 	}
 	ver[2] = ASC_BCD0(p_f[0]);
 	p_f++;
-	if( p_f[0] != ' ' ){
+	if (p_f[0] != ' ') {
 		ver[2] |= ASC_BCD1(p_f[0]);
 		p_f++;
 	}
-	// only support 2 byte version.
+	/* only support 2 byte version. */
 	ver[3] = 0;
 
 #if MSC_EXT_DBG
-	printk("VERSION:%02x %02x %02x %02x %02x %02x\n" ,
-	ver[0],ver[1],ver[2],ver[3],ver[4],ver[5]);
+	printk("VERSION:%02x %02x %02x %02x %02x %02x\n",
+	       ver[0], ver[1], ver[2], ver[3], ver[4], ver[5]);
 #endif
 	return ret;
 }
@@ -2106,13 +2095,13 @@ static int do_get_versions( int ret ,char* buf )
 
 static int do_scsi_command(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh;
-	int			rc;
-	int			reply = -EINVAL;
-	int			i;
-	static char		unknown[16];
+	struct fsg_buffhd *bh;
+	int rc;
+	int reply = -EINVAL;
+	int i;
+	static char unknown[16];
 #ifdef CONFIG_ARCH_ROCKCHIP
-	struct fsg_common	*fsg = common;
+	struct fsg_common *fsg = common;
 #endif
 
 	dump_cdb(common);
@@ -2134,8 +2123,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case INQUIRY:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
-				      (1<<4), 0,
-				      "INQUIRY");
+				      (1 << 4), 0, "INQUIRY");
 		if (reply == 0)
 			reply = do_inquiry(common, bh);
 		break;
@@ -2143,17 +2131,16 @@ static int do_scsi_command(struct fsg_common *common)
 	case MODE_SELECT:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_FROM_HOST,
-				      (1<<1) | (1<<4), 0,
-				      "MODE SELECT(6)");
+				      (1 << 1) | (1 << 4), 0, "MODE SELECT(6)");
 		if (reply == 0)
 			reply = do_mode_select(common, bh);
 		break;
 
 	case MODE_SELECT_10:
 		common->data_size_from_cmnd =
-			get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_FROM_HOST,
-				      (1<<1) | (3<<7), 0,
+				      (1 << 1) | (3 << 7), 0,
 				      "MODE SELECT(10)");
 		if (reply == 0)
 			reply = do_mode_select(common, bh);
@@ -2162,7 +2149,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case MODE_SENSE:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
-				      (1<<1) | (1<<2) | (1<<4), 0,
+				      (1 << 1) | (1 << 2) | (1 << 4), 0,
 				      "MODE SENSE(6)");
 		if (reply == 0)
 			reply = do_mode_sense(common, bh);
@@ -2170,9 +2157,9 @@ static int do_scsi_command(struct fsg_common *common)
 
 	case MODE_SENSE_10:
 		common->data_size_from_cmnd =
-			get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (1<<1) | (1<<2) | (3<<7), 0,
+				      (1 << 1) | (1 << 2) | (3 << 7), 0,
 				      "MODE SENSE(10)");
 		if (reply == 0)
 			reply = do_mode_sense(common, bh);
@@ -2181,7 +2168,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case ALLOW_MEDIUM_REMOVAL:
 		common->data_size_from_cmnd = 0;
 		reply = check_command(common, 6, DATA_DIR_NONE,
-				      (1<<4), 0,
+				      (1 << 4), 0,
 				      "PREVENT-ALLOW MEDIUM REMOVAL");
 		if (reply == 0)
 			reply = do_prevent_allow(common);
@@ -2191,31 +2178,33 @@ static int do_scsi_command(struct fsg_common *common)
 		i = common->cmnd[4];
 		common->data_size_from_cmnd = (i == 0) ? 256 : i;
 		reply = check_command_size_in_blocks(common, 6,
-				      DATA_DIR_TO_HOST,
-				      (7<<1) | (1<<4), 1,
-				      "READ(6)");
+						     DATA_DIR_TO_HOST,
+						     (7 << 1) | (1 << 4), 1,
+						     "READ(6)");
 		if (reply == 0)
 			reply = do_read(common);
 		break;
 
 	case READ_10:
 		common->data_size_from_cmnd =
-				get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command_size_in_blocks(common, 10,
-				      DATA_DIR_TO_HOST,
-				      (1<<1) | (0xf<<2) | (3<<7), 1,
-				      "READ(10)");
+						     DATA_DIR_TO_HOST,
+						     (1 << 1) | (0xf << 2) | (3
+									      <<
+									      7),
+						     1, "READ(10)");
 		if (reply == 0)
 			reply = do_read(common);
 		break;
 
 	case READ_12:
 		common->data_size_from_cmnd =
-				get_unaligned_be32(&common->cmnd[6]);
+		    get_unaligned_be32(&common->cmnd[6]);
 		reply = check_command_size_in_blocks(common, 12,
-				      DATA_DIR_TO_HOST,
-				      (1<<1) | (0xf<<2) | (0xf<<6), 1,
-				      "READ(12)");
+						     DATA_DIR_TO_HOST,
+						     (1 << 1) | (0xf << 2) |
+						     (0xf << 6), 1, "READ(12)");
 		if (reply == 0)
 			reply = do_read(common);
 		break;
@@ -2223,7 +2212,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case READ_CAPACITY:
 		common->data_size_from_cmnd = 8;
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (0xf<<2) | (1<<8), 1,
+				      (0xf << 2) | (1 << 8), 1,
 				      "READ CAPACITY");
 		if (reply == 0)
 			reply = do_read_capacity(common, bh);
@@ -2233,10 +2222,9 @@ static int do_scsi_command(struct fsg_common *common)
 		if (!common->curlun || !common->curlun->cdrom)
 			goto unknown_cmnd;
 		common->data_size_from_cmnd =
-			get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (3<<7) | (0x1f<<1), 1,
-				      "READ HEADER");
+				      (3 << 7) | (0x1f << 1), 1, "READ HEADER");
 		if (reply == 0)
 			reply = do_read_header(common, bh);
 		break;
@@ -2245,20 +2233,18 @@ static int do_scsi_command(struct fsg_common *common)
 		if (!common->curlun || !common->curlun->cdrom)
 			goto unknown_cmnd;
 		common->data_size_from_cmnd =
-			get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (7<<6) | (1<<1), 1,
-				      "READ TOC");
+				      (7 << 6) | (1 << 1), 1, "READ TOC");
 		if (reply == 0)
 			reply = do_read_toc(common, bh);
 		break;
 
 	case READ_FORMAT_CAPACITIES:
 		common->data_size_from_cmnd =
-			get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (3<<7), 1,
-				      "READ FORMAT CAPACITIES");
+				      (3 << 7), 1, "READ FORMAT CAPACITIES");
 		if (reply == 0)
 			reply = do_read_format_capacities(common, bh);
 		break;
@@ -2266,8 +2252,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case REQUEST_SENSE:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
-				      (1<<4), 0,
-				      "REQUEST SENSE");
+				      (1 << 4), 0, "REQUEST SENSE");
 		if (reply == 0)
 			reply = do_request_sense(common, bh);
 		break;
@@ -2275,7 +2260,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case START_STOP:
 		common->data_size_from_cmnd = 0;
 		reply = check_command(common, 6, DATA_DIR_NONE,
-				      (1<<1) | (1<<4), 0,
+				      (1 << 1) | (1 << 4), 0,
 				      "START-STOP UNIT");
 		if (reply == 0)
 			reply = do_start_stop(common);
@@ -2284,7 +2269,7 @@ static int do_scsi_command(struct fsg_common *common)
 	case SYNCHRONIZE_CACHE:
 		common->data_size_from_cmnd = 0;
 		reply = check_command(common, 10, DATA_DIR_NONE,
-				      (0xf<<2) | (3<<7), 1,
+				      (0xf << 2) | (3 << 7), 1,
 				      "SYNCHRONIZE CACHE");
 		if (reply == 0)
 			reply = do_synchronize_cache(common);
@@ -2293,22 +2278,21 @@ static int do_scsi_command(struct fsg_common *common)
 	case TEST_UNIT_READY:
 		common->data_size_from_cmnd = 0;
 		reply = check_command(common, 6, DATA_DIR_NONE,
-				0, 1,
-				"TEST UNIT READY");
+				      0, 1, "TEST UNIT READY");
 		break;
 
-	/*
-	 * Although optional, this command is used by MS-Windows.  We
-	 * support a minimal version: BytChk must be 0.
-	 */
+		/*
+		 * Although optional, this command is used by MS-Windows.  We
+		 * support a minimal version: BytChk must be 0.
+		 */
 	case VERIFY:
 		common->data_size_from_cmnd = 0;
 		reply = check_command(common, 10, DATA_DIR_NONE,
-				      (1<<1) | (0xf<<2) | (3<<7), 1,
+				      (1 << 1) | (0xf << 2) | (3 << 7), 1,
 				      "VERIFY");
 		if (reply == 0)
 #ifdef CONFIG_ARCH_ROCKCHIP
-			reply = 0; //zyf 20100302
+			reply = 0;	/* zyf 20100302 */
 #else
 			reply = do_verify(common);
 #endif
@@ -2318,41 +2302,44 @@ static int do_scsi_command(struct fsg_common *common)
 		i = common->cmnd[4];
 		common->data_size_from_cmnd = (i == 0) ? 256 : i;
 		reply = check_command_size_in_blocks(common, 6,
-				      DATA_DIR_FROM_HOST,
-				      (7<<1) | (1<<4), 1,
-				      "WRITE(6)");
+						     DATA_DIR_FROM_HOST,
+						     (7 << 1) | (1 << 4), 1,
+						     "WRITE(6)");
 		if (reply == 0)
 			reply = do_write(common);
 		break;
 
 	case WRITE_10:
 		common->data_size_from_cmnd =
-				get_unaligned_be16(&common->cmnd[7]);
+		    get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command_size_in_blocks(common, 10,
-				      DATA_DIR_FROM_HOST,
-				      (1<<1) | (0xf<<2) | (3<<7), 1,
-				      "WRITE(10)");
+						     DATA_DIR_FROM_HOST,
+						     (1 << 1) | (0xf << 2) | (3
+									      <<
+									      7),
+						     1, "WRITE(10)");
 		if (reply == 0)
 			reply = do_write(common);
 		break;
 
 	case WRITE_12:
 		common->data_size_from_cmnd =
-				get_unaligned_be32(&common->cmnd[6]);
+		    get_unaligned_be32(&common->cmnd[6]);
 		reply = check_command_size_in_blocks(common, 12,
-				      DATA_DIR_FROM_HOST,
-				      (1<<1) | (0xf<<2) | (0xf<<6), 1,
-				      "WRITE(12)");
+						     DATA_DIR_FROM_HOST,
+						     (1 << 1) | (0xf << 2) |
+						     (0xf << 6), 1,
+						     "WRITE(12)");
 		if (reply == 0)
 			reply = do_write(common);
 		break;
 
-	/*
-	 * Some mandatory commands that we recognize but don't implement.
-	 * They don't mean much in this setting.  It's left as an exercise
-	 * for anyone interested to implement RESERVE and RELEASE in terms
-	 * of Posix locks.
-	 */
+		/*
+		 * Some mandatory commands that we recognize but don't implement.
+		 * They don't mean much in this setting.  It's left as an exercise
+		 * for anyone interested to implement RESERVE and RELEASE in terms
+		 * of Posix locks.
+		 */
 	case FORMAT_UNIT:
 	case RELEASE:
 	case RESERVE:
@@ -2372,19 +2359,19 @@ static int do_scsi_command(struct fsg_common *common)
 		break;
 #ifdef CONFIG_ARCH_ROCKCHIP
 	case 0xff:
-		if( fsg->cmnd[1] != 0xe0 ||
+		if (fsg->cmnd[1] != 0xe0 ||
 		    fsg->cmnd[2] != 0xff || fsg->cmnd[3] != 0xff ||
-		    fsg->cmnd[4] != 0xff )
-		break;
+		    fsg->cmnd[4] != 0xff)
+			break;
 		if (fsg->cmnd_size >= 6 && fsg->cmnd[5] == 0xfe) {
 			schedule_work(&restart_work);
-		}else if ( fsg->cmnd[5] == 0xf3 ) {
+		} else if (fsg->cmnd[5] == 0xf3) {
 			fsg->data_size_from_cmnd = fsg->data_size;
 			/* get product name from parameter section */
-			reply = do_get_product_name( fsg->data_size,bh->buf );
-		}else if ( fsg->cmnd[5] == 0xff ){
+			reply = do_get_product_name(fsg->data_size, bh->buf);
+		} else if (fsg->cmnd[5] == 0xff) {
 			fsg->data_size_from_cmnd = fsg->data_size;
-			reply = do_get_versions( fsg->data_size,bh->buf );
+			reply = do_get_versions(fsg->data_size, bh->buf);
 		}
 		break;
 #endif
@@ -2396,25 +2383,24 @@ static int do_scsi_command(struct fsg_common *common)
 
 	/* Set up the single reply buffer for finish_reply() */
 	if (reply == -EINVAL)
-		reply = 0;		/* Error reply length */
+		reply = 0;	/* Error reply length */
 	if (reply >= 0 && common->data_dir == DATA_DIR_TO_HOST) {
-		reply = min((u32)reply, common->data_size_from_cmnd);
+		reply = min((u32) reply, common->data_size_from_cmnd);
 		bh->inreq->length = reply;
 		bh->state = BUF_STATE_FULL;
 		common->residue -= reply;
-	}				/* Otherwise it's already set */
-
+	}
+	/* Otherwise it's already set */
 	return 0;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
-	struct usb_request	*req = bh->outreq;
-	struct bulk_cb_wrap	*cbw = req->buf;
-	struct fsg_common	*common = fsg->common;
+	struct usb_request *req = bh->outreq;
+	struct bulk_cb_wrap *cbw = req->buf;
+	struct fsg_common *common = fsg->common;
 
 	/* Was this a real packet?  Should it be ignored? */
 	if (req->status || test_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))
@@ -2422,11 +2408,9 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 	/* Is the CBW valid? */
 	if (req->actual != US_BULK_CB_WRAP_LEN ||
-			cbw->Signature != cpu_to_le32(
-				US_BULK_CB_SIGN)) {
+	    cbw->Signature != cpu_to_le32(US_BULK_CB_SIGN)) {
 		DBG(fsg, "invalid CBW: len %u sig 0x%x\n",
-				req->actual,
-				le32_to_cpu(cbw->Signature));
+		    req->actual, le32_to_cpu(cbw->Signature));
 
 		/*
 		 * The Bulk-only spec says we MUST stall the IN endpoint
@@ -2446,10 +2430,9 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 	/* Is the CBW meaningful? */
 	if (cbw->Lun >= FSG_MAX_LUNS || cbw->Flags & ~US_BULK_FLAG_IN ||
-			cbw->Length <= 0 || cbw->Length > MAX_COMMAND_SIZE) {
+	    cbw->Length <= 0 || cbw->Length > MAX_COMMAND_SIZE) {
 		DBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "
-				"cmdlen %u\n",
-				cbw->Lun, cbw->Flags, cbw->Length);
+		    "cmdlen %u\n", cbw->Lun, cbw->Flags, cbw->Length);
 
 		/*
 		 * We can do anything we want here, so let's stall the
@@ -2483,8 +2466,8 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 static int get_next_command(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh;
-	int			rc = 0;
+	struct fsg_buffhd *bh;
+	int rc = 0;
 
 	/* Wait for the next buffer to become available */
 	bh = common->next_buffhd_to_fill;
@@ -2519,11 +2502,10 @@ static int get_next_command(struct fsg_common *common)
 	return rc;
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int alloc_request(struct fsg_common *common, struct usb_ep *ep,
-		struct usb_request **preq)
+			 struct usb_request **preq)
 {
 	*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);
 	if (*preq)
@@ -2604,7 +2586,7 @@ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 
 	/* Allocate the requests */
 	for (i = 0; i < fsg_num_buffers; ++i) {
-		struct fsg_buffhd	*bh = &common->buffhds[i];
+		struct fsg_buffhd *bh = &common->buffhds[i];
 
 		rc = alloc_request(common, fsg->bulk_in, &bh->inreq);
 		if (rc)
@@ -2624,7 +2606,6 @@ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 	return rc;
 }
 
-
 /****************************** ALT CONFIGS ******************************/
 
 static int fsg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
@@ -2642,17 +2623,16 @@ static void fsg_disable(struct usb_function *f)
 	raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static void handle_exception(struct fsg_common *common)
 {
-	siginfo_t		info;
-	int			i;
-	struct fsg_buffhd	*bh;
-	enum fsg_state		old_state;
-	struct fsg_lun		*curlun;
-	unsigned int		exception_req_tag;
+	siginfo_t info;
+	int i;
+	struct fsg_buffhd *bh;
+	enum fsg_state old_state;
+	struct fsg_lun *curlun;
+	unsigned int exception_req_tag;
 
 	/*
 	 * Clear the existing signals.  Anything but SIGUSR1 is converted
@@ -2660,7 +2640,7 @@ static void handle_exception(struct fsg_common *common)
 	 */
 	for (;;) {
 		int sig =
-			dequeue_signal_lock(current, &current->blocked, &info);
+		    dequeue_signal_lock(current, &current->blocked, &info);
 		if (!sig)
 			break;
 		if (sig != SIGUSR1) {
@@ -2762,8 +2742,8 @@ static void handle_exception(struct fsg_common *common)
 		 * CONFIG_CHANGE cases.
 		 */
 		/* for (i = 0; i < common->nluns; ++i) */
-		/*	common->luns[i].unit_attention_data = */
-		/*		SS_RESET_OCCURRED;  */
+		/*      common->luns[i].unit_attention_data = */
+		/*              SS_RESET_OCCURRED;  */
 		break;
 
 	case FSG_STATE_CONFIG_CHANGE:
@@ -2774,7 +2754,7 @@ static void handle_exception(struct fsg_common *common)
 
 	case FSG_STATE_EXIT:
 	case FSG_STATE_TERMINATED:
-		do_set_interface(common, NULL);		/* Free resources */
+		do_set_interface(common, NULL);	/* Free resources */
 		spin_lock_irq(&common->lock);
 		common->state = FSG_STATE_TERMINATED;	/* Stop the thread */
 		spin_unlock_irq(&common->lock);
@@ -2790,12 +2770,11 @@ static void handle_exception(struct fsg_common *common)
 	}
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static int fsg_main_thread(void *common_)
 {
-	struct fsg_common	*common = common_;
+	struct fsg_common *common = common_;
 
 	/*
 	 * Allow the thread to be killed by a signal, but set the signal mask
@@ -2868,7 +2847,7 @@ static int fsg_main_thread(void *common_)
 	spin_unlock_irq(&common->lock);
 
 	if (!common->ops || !common->ops->thread_exits
-	 || common->ops->thread_exits(common) < 0) {
+	    || common->ops->thread_exits(common) < 0) {
 		struct fsg_lun *curlun = common->luns;
 		unsigned i = common->nluns;
 
@@ -2887,7 +2866,6 @@ static int fsg_main_thread(void *common_)
 	complete_and_exit(&common->thread_notifier, 0);
 }
 
-
 /*************************** DEVICE ATTRIBUTES ***************************/
 
 static DEVICE_ATTR(ro, 0644, fsg_show_ro, fsg_store_ro);
@@ -2898,10 +2876,9 @@ static DEVICE_ATTR(perf, 0644, fsg_show_perf, fsg_store_perf);
 #endif
 
 static struct device_attribute dev_attr_ro_cdrom =
-	__ATTR(ro, 0444, fsg_show_ro, NULL);
+__ATTR(ro, 0444, fsg_show_ro, NULL);
 static struct device_attribute dev_attr_file_nonremovable =
-	__ATTR(file, 0444, fsg_show_file, NULL);
-
+__ATTR(file, 0444, fsg_show_file, NULL);
 
 /****************************** FSG COMMON ******************************/
 
@@ -3015,14 +2992,13 @@ static struct fsg_common *fsg_common_init(struct fsg_common *common,
 
 		rc = device_create_file(&curlun->dev,
 					curlun->cdrom
-				      ? &dev_attr_ro_cdrom
-				      : &dev_attr_ro);
+					? &dev_attr_ro_cdrom : &dev_attr_ro);
 		if (rc)
 			goto error_luns;
 		rc = device_create_file(&curlun->dev,
 					curlun->removable
-				      ? &dev_attr_file
-				      : &dev_attr_file_nonremovable);
+					? &dev_attr_file
+					: &dev_attr_file_nonremovable);
 		if (rc)
 			goto error_luns;
 		rc = device_create_file(&curlun->dev, &dev_attr_nofua);
@@ -3065,27 +3041,25 @@ static struct fsg_common *fsg_common_init(struct fsg_common *common,
 	/* Prepare inquiryString */
 	i = get_default_bcdDevice();
 	snprintf(common->inquiry_string, sizeof common->inquiry_string,
-		 "%-8s%-16s%04x", cfg->vendor_name ?: "Linux",
+		 "%-8s%-16s%04x", cfg->vendor_name ? : "Linux",
 		 /* Assume product name dependent on the first LUN */
-		 cfg->product_name ?: (common->luns->cdrom
-				     ? "File-Stor Gadget"
-				     : "File-CD Gadget"),
-		 i);
+		 cfg->product_name ? : (common->luns->cdrom
+					? "File-Stor Gadget"
+					: "File-CD Gadget"), i);
 
 	/*
 	 * Some peripheral controllers are known not to be able to
 	 * halt bulk endpoints correctly.  If one of them is present,
 	 * disable stalls.
 	 */
-	common->can_stall = cfg->can_stall &&
-		!(gadget_is_at91(common->gadget));
+	common->can_stall = cfg->can_stall && !(gadget_is_at91(common->gadget));
 
 	spin_lock_init(&common->lock);
 	kref_init(&common->ref);
 
 	/* Tell the thread to start working */
 	common->thread_task =
-		kthread_create(fsg_main_thread, common, "file-storage");
+	    kthread_create(fsg_main_thread, common, "file-storage");
 	if (IS_ERR(common->thread_task)) {
 		rc = PTR_ERR(common->thread_task);
 		goto error_release;
@@ -3099,8 +3073,7 @@ static struct fsg_common *fsg_common_init(struct fsg_common *common,
 
 	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
 	for (i = 0, nluns = common->nluns, curlun = common->luns;
-	     i < nluns;
-	     ++curlun, ++i) {
+	     i < nluns; ++curlun, ++i) {
 		char *p = "(no medium)";
 		if (fsg_lun_is_open(curlun)) {
 			p = "(error)";
@@ -3114,8 +3087,7 @@ static struct fsg_common *fsg_common_init(struct fsg_common *common,
 		LINFO(curlun, "LUN: %s%s%sfile: %s\n",
 		      curlun->removable ? "removable " : "",
 		      curlun->ro ? "read only " : "",
-		      curlun->cdrom ? "CD-ROM " : "",
-		      p);
+		      curlun->cdrom ? "CD-ROM " : "", p);
 	}
 	kfree(pathbuf);
 
@@ -3156,12 +3128,11 @@ static void fsg_common_release(struct kref *ref)
 			device_remove_file(&lun->dev, &dev_attr_nofua);
 			device_remove_file(&lun->dev,
 					   lun->cdrom
-					 ? &dev_attr_ro_cdrom
-					 : &dev_attr_ro);
+					   ? &dev_attr_ro_cdrom : &dev_attr_ro);
 			device_remove_file(&lun->dev,
 					   lun->removable
-					 ? &dev_attr_file
-					 : &dev_attr_file_nonremovable);
+					   ? &dev_attr_file
+					   : &dev_attr_file_nonremovable);
 			fsg_lun_close(lun);
 			device_unregister(&lun->dev);
 		}
@@ -3182,13 +3153,12 @@ static void fsg_common_release(struct kref *ref)
 		kfree(common);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
 static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
 {
-	struct fsg_dev		*fsg = fsg_from_func(f);
-	struct fsg_common	*common = fsg->common;
+	struct fsg_dev *fsg = fsg_from_func(f);
+	struct fsg_common *common = fsg->common;
 
 	DBG(fsg, "unbind\n");
 	if (fsg->common->fsg == fsg) {
@@ -3205,12 +3175,12 @@ static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
 
 static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 {
-	struct fsg_dev		*fsg = fsg_from_func(f);
-	struct usb_gadget	*gadget = c->cdev->gadget;
-	int			i;
-	struct usb_ep		*ep;
-	unsigned		max_burst;
-	int			ret;
+	struct fsg_dev *fsg = fsg_from_func(f);
+	struct usb_gadget *gadget = c->cdev->gadget;
+	int i;
+	struct usb_ep *ep;
+	unsigned max_burst;
+	int ret;
 
 	fsg->gadget = gadget;
 
@@ -3236,23 +3206,23 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 
 	/* Assume endpoint addresses are the same for both speeds */
 	fsg_hs_bulk_in_desc.bEndpointAddress =
-		fsg_fs_bulk_in_desc.bEndpointAddress;
+	    fsg_fs_bulk_in_desc.bEndpointAddress;
 	fsg_hs_bulk_out_desc.bEndpointAddress =
-		fsg_fs_bulk_out_desc.bEndpointAddress;
+	    fsg_fs_bulk_out_desc.bEndpointAddress;
 
 	/* Calculate bMaxBurst, we know packet size is 1024 */
 	max_burst = min_t(unsigned, FSG_BUFLEN / 1024, 15);
 
 	fsg_ss_bulk_in_desc.bEndpointAddress =
-		fsg_fs_bulk_in_desc.bEndpointAddress;
+	    fsg_fs_bulk_in_desc.bEndpointAddress;
 	fsg_ss_bulk_in_comp_desc.bMaxBurst = max_burst;
 
 	fsg_ss_bulk_out_desc.bEndpointAddress =
-		fsg_fs_bulk_out_desc.bEndpointAddress;
+	    fsg_fs_bulk_out_desc.bEndpointAddress;
 	fsg_ss_bulk_out_comp_desc.bMaxBurst = max_burst;
 
 	ret = usb_assign_descriptors(f, fsg_fs_function, fsg_hs_function,
-			fsg_ss_function);
+				     fsg_ss_function);
 	if (ret)
 		goto autoconf_fail;
 
@@ -3281,15 +3251,15 @@ static int fsg_bind_config(struct usb_composite_dev *cdev,
 	if (unlikely(!fsg))
 		return -ENOMEM;
 
-	fsg->function.name        = FSG_DRIVER_DESC;
-	fsg->function.strings     = fsg_strings_array;
-	fsg->function.bind        = fsg_bind;
-	fsg->function.unbind      = fsg_unbind;
-	fsg->function.setup       = fsg_setup;
-	fsg->function.set_alt     = fsg_set_alt;
-	fsg->function.disable     = fsg_disable;
+	fsg->function.name = FSG_DRIVER_DESC;
+	fsg->function.strings = fsg_strings_array;
+	fsg->function.bind = fsg_bind;
+	fsg->function.unbind = fsg_unbind;
+	fsg->function.setup = fsg_setup;
+	fsg->function.set_alt = fsg_set_alt;
+	fsg->function.disable = fsg_disable;
 
-	fsg->common               = common;
+	fsg->common = common;
 	/*
 	 * Our caller holds a reference to common structure so we
 	 * don't have to be worry about it being freed until we return
@@ -3306,20 +3276,19 @@ static int fsg_bind_config(struct usb_composite_dev *cdev,
 	return rc;
 }
 
-
 /************************* Module parameters *************************/
 
 struct fsg_module_parameters {
-	char		*file[FSG_MAX_LUNS];
-	bool		ro[FSG_MAX_LUNS];
-	bool		removable[FSG_MAX_LUNS];
-	bool		cdrom[FSG_MAX_LUNS];
-	bool		nofua[FSG_MAX_LUNS];
-
-	unsigned int	file_count, ro_count, removable_count, cdrom_count;
-	unsigned int	nofua_count;
-	unsigned int	luns;	/* nluns */
-	bool		stall;	/* can_stall */
+	char *file[FSG_MAX_LUNS];
+	bool ro[FSG_MAX_LUNS];
+	bool removable[FSG_MAX_LUNS];
+	bool cdrom[FSG_MAX_LUNS];
+	bool nofua[FSG_MAX_LUNS];
+
+	unsigned int file_count, ro_count, removable_count, cdrom_count;
+	unsigned int nofua_count;
+	unsigned int luns;	/* nluns */
+	bool stall;		/* can_stall */
 };
 
 #define _FSG_MODULE_PARAM_ARRAY(prefix, params, name, type, desc)	\
@@ -3358,16 +3327,15 @@ fsg_config_from_params(struct fsg_config *cfg,
 
 	/* Configure LUNs */
 	cfg->nluns =
-		min(params->luns ?: (params->file_count ?: 1u),
-		    (unsigned)FSG_MAX_LUNS);
+	    min(params->luns ? : (params->file_count ? : 1u),
+		(unsigned)FSG_MAX_LUNS);
 	for (i = 0, lun = cfg->luns; i < cfg->nluns; ++i, ++lun) {
 		lun->ro = !!params->ro[i];
 		lun->cdrom = !!params->cdrom[i];
 		lun->removable = !!params->removable[i];
-		lun->filename =
-			params->file_count > i && params->file[i][0]
-			? params->file[i]
-			: 0;
+		lun->filename = params->file_count > i && params->file[i][0]
+		    ? params->file[i]
+		    : 0;
 	}
 
 	/* Let MSF use defaults */
@@ -3381,15 +3349,21 @@ fsg_config_from_params(struct fsg_config *cfg,
 	cfg->can_stall = params->stall;
 }
 
-static inline struct fsg_common *
-fsg_common_from_params(struct fsg_common *common,
-		       struct usb_composite_dev *cdev,
-		       const struct fsg_module_parameters *params)
-	__attribute__((unused));
-static inline struct fsg_common *
-fsg_common_from_params(struct fsg_common *common,
-		       struct usb_composite_dev *cdev,
-		       const struct fsg_module_parameters *params)
+static inline struct fsg_common *fsg_common_from_params(struct fsg_common
+							*common,
+							struct usb_composite_dev
+							*cdev,
+							const struct
+							fsg_module_parameters
+							*params)
+    __attribute__ ((unused));
+static inline struct fsg_common *fsg_common_from_params(struct fsg_common
+							*common,
+							struct usb_composite_dev
+							*cdev,
+							const struct
+							fsg_module_parameters
+							*params)
 {
 	struct fsg_config cfg;
 	fsg_config_from_params(&cfg, params);
diff --git a/drivers/usb/gadget/storage_common.c b/drivers/usb/gadget/storage_common.c
index 3c203df9041f..a7977eb3ab7b 100755
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -53,8 +53,8 @@
 #define VLDBG(lun, fmt, args...) do { } while (0)
 #endif /* VERBOSE_DEBUG */
 
-#define LDBG(lun, fmt, args...)   dev_dbg (&(lun)->dev, fmt, ## args)
-#define LERROR(lun, fmt, args...) dev_err (&(lun)->dev, fmt, ## args)
+#define LDBG(lun, fmt, args...)   dev_dbg(&(lun)->dev, fmt, ## args)
+#define LERROR(lun, fmt, args...) dev_err(&(lun)->dev, fmt, ## args)
 #define LWARN(lun, fmt, args...)  dev_warn(&(lun)->dev, fmt, ## args)
 #define LINFO(lun, fmt, args...)  dev_info(&(lun)->dev, fmt, ## args)
 
@@ -195,7 +195,7 @@ static inline int fsg_num_buffers_validate(void)
 	if (fsg_num_buffers >= 2 && fsg_num_buffers <= 4)
 		return 0;
 	pr_err("fsg_num_buffers %u is out of range (%d to %d)\n",
-	       fsg_num_buffers, 2 ,4);
+	       fsg_num_buffers, 2 , 4);
 	return -EINVAL;
 }
 
diff --git a/drivers/usb/host/ehci-rkhsic.c b/drivers/usb/host/ehci-rkhsic.c
index f37808afb2bb..72495a8c8291 100755
--- a/drivers/usb/host/ehci-rkhsic.c
+++ b/drivers/usb/host/ehci-rkhsic.c
@@ -33,94 +33,95 @@
 
 static int rkhsic_status = 1;
 static struct ehci_hcd *g_hsic_ehci;
-#define HSIC_EHCI_PRINT(x...)	printk( KERN_INFO "HSIC_EHCI: " x )
+#define HSIC_EHCI_PRINT(x...)	printk(KERN_INFO "HSIC_EHCI: " x)
 
 static struct rkehci_pdata_id rkhsic_pdata[] = {
 	{
-		.name = "rk3188-hsic",
-		.pdata = &rkhsic_pdata_rk3188,
-	},
+	 .name = "rk3188-hsic",
+	 .pdata = &rkhsic_pdata_rk3188,
+	 },
 	{
-		.name = "rk3288-hsic",
-		.pdata = &rkhsic_pdata_rk3288,
-	},
-	{ },
+	 .name = "rk3288-hsic",
+	 .pdata = &rkhsic_pdata_rk3288,
+	 },
+	{},
 };
 
-static void ehci_rkhsic_port_power (struct ehci_hcd *ehci, int is_on)
+static void ehci_rkhsic_port_power(struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
 
-	if (!HCS_PPC (ehci->hcs_params))
+	if (!HCS_PPC(ehci->hcs_params))
 		return;
 
-	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
-		(void) ehci_hub_control(ehci_to_hcd(ehci),
-				is_on ? SetPortFeature : ClearPortFeature,
-				USB_PORT_FEAT_POWER,
-				port--, NULL, 0);
+	ehci_dbg(ehci, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0;)
+		(void)ehci_hub_control(ehci_to_hcd(ehci),
+				       is_on ? SetPortFeature :
+				       ClearPortFeature, USB_PORT_FEAT_POWER,
+				       port--, NULL, 0);
 	/* Flush those writes */
 	ehci_readl(ehci, &ehci->regs->command);
 	msleep(20);
 }
 
 static struct hc_driver rk_hsic_driver = {
-	.description		= hcd_name,
-	.product_desc		= "Rockchip On-Chip HSIC EHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.description = hcd_name,
+	.product_desc = "Rockchip On-Chip HSIC EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
 
 	/*
 	 * generic hardware linkage
 	 */
-	.irq			= ehci_irq,
-	.flags			= HCD_USB2 | HCD_MEMORY,
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
 
-	.reset			= ehci_init,
-	.start			= ehci_run,
+	.reset = ehci_init,
+	.start = ehci_run,
 
-	.stop			= ehci_stop,
-	.shutdown		= ehci_shutdown,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
 
 	/*
 	 * managing i/o requests and associated device resources
 	 */
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.endpoint_reset		= ehci_endpoint_reset,
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 
 	/*
 	 * scheduling support
 	 */
-	.get_frame_number	= ehci_get_frame,
+	.get_frame_number = ehci_get_frame,
 
 	/*
 	 * root hub support
 	 */
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-	.relinquish_port	= ehci_relinquish_port,
-	.port_handed_over	= ehci_port_handed_over,
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 
 	/*
 	 * PM support
 	 */
 #ifdef CONFIG_PM
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
 #endif
 };
 
-static ssize_t ehci_rkhsic_power_show( struct device *_dev, 
-				struct device_attribute *attr, char *buf) 
+static ssize_t ehci_rkhsic_power_show(struct device *_dev,
+				      struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", rkhsic_status);
 }
-static ssize_t ehci_rkhsic_power_store( struct device *_dev,
-					struct device_attribute *attr, 
-					const char *buf, size_t count ) 
+
+static ssize_t ehci_rkhsic_power_store(struct device *_dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
 {
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 	struct usb_hcd *hcd = dev_get_drvdata(_dev);
@@ -128,81 +129,96 @@ static ssize_t ehci_rkhsic_power_store( struct device *_dev,
 	struct rkehci_platform_data *pldata = _dev->platform_data;
 
 	printk("%s: %d setting to: %d\n", __func__, rkhsic_status, val);
-	if(val == rkhsic_status)
+	if (val == rkhsic_status)
 		goto out;
-	
+
 	rkhsic_status = val;
-	switch(val){
-		case 0: //power down
-			ehci_rkhsic_port_power(ehci, 0);
-			writel_relaxed(0 ,hcd->regs +0xb0);
-			dsb();
-			msleep(5);
-			usb_remove_hcd(hcd);
-            		break;
-		case 1: // power on
-			pldata->soft_reset();
-          		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
-        
-    			ehci_rkhsic_port_power(ehci, 1);
-    			writel_relaxed(1 ,hcd->regs +0xb0);
-    			writel_relaxed(0x1d4d ,hcd->regs +0x90);
-			writel_relaxed(0x4 ,hcd->regs +0xa0);
-			dsb();
-            		break;
-		default:
-            		break;
+	switch (val) {
+	case 0:	/* power down */
+		ehci_rkhsic_port_power(ehci, 0);
+		writel_relaxed(0, hcd->regs + 0xb0);
+		dsb();
+		msleep(5);
+		usb_remove_hcd(hcd);
+		break;
+	case 1:	/* power on */
+		pldata->soft_reset();
+		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
+
+		ehci_rkhsic_port_power(ehci, 1);
+		writel_relaxed(1, hcd->regs + 0xb0);
+		writel_relaxed(0x1d4d, hcd->regs + 0x90);
+		writel_relaxed(0x4, hcd->regs + 0xa0);
+		dsb();
+		break;
+	default:
+		break;
 	}
 out:
 	return count;
 }
-static DEVICE_ATTR(ehci_rkhsic_power, S_IRUGO|S_IWUSR, ehci_rkhsic_power_show, ehci_rkhsic_power_store);
 
-static ssize_t hsic_debug_show( struct device *_dev,
-				struct device_attribute *attr, char *buf)
+static DEVICE_ATTR(ehci_rkhsic_power, S_IRUGO | S_IWUSR, ehci_rkhsic_power_show,
+		   ehci_rkhsic_power_store);
+
+static ssize_t hsic_debug_show(struct device *_dev,
+			       struct device_attribute *attr, char *buf)
 {
 	volatile uint32_t *addr;
 
 	HSIC_EHCI_PRINT("******** EHCI Capability Registers **********\n");
 	addr = &g_hsic_ehci->caps->hc_capbase;
-	HSIC_EHCI_PRINT("HCIVERSION / CAPLENGTH  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("HCIVERSION / CAPLENGTH  @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->caps->hcs_params;
-	HSIC_EHCI_PRINT("HCSPARAMS               @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("HCSPARAMS               @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->caps->hcc_params;
-	HSIC_EHCI_PRINT("HCCPARAMS               @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("HCCPARAMS               @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	HSIC_EHCI_PRINT("********* EHCI Operational Registers *********\n");
 	addr = &g_hsic_ehci->regs->command;
-	HSIC_EHCI_PRINT("USBCMD                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("USBCMD                  @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->status;
-	HSIC_EHCI_PRINT("USBSTS                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("USBSTS                  @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->intr_enable;
-	HSIC_EHCI_PRINT("USBINTR                 @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("USBINTR                 @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->frame_index;
-	HSIC_EHCI_PRINT("FRINDEX                 @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("FRINDEX                 @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->segment;
-	HSIC_EHCI_PRINT("CTRLDSSEGMENT           @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("CTRLDSSEGMENT           @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->frame_list;
-	HSIC_EHCI_PRINT("PERIODICLISTBASE        @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr)); 
+	HSIC_EHCI_PRINT("PERIODICLISTBASE        @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->async_next;
-	HSIC_EHCI_PRINT("ASYNCLISTADDR           @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("ASYNCLISTADDR           @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = &g_hsic_ehci->regs->configured_flag;
-	HSIC_EHCI_PRINT("CONFIGFLAG              @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("CONFIGFLAG              @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	addr = g_hsic_ehci->regs->port_status;
-	HSIC_EHCI_PRINT("PORTSC                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	HSIC_EHCI_PRINT("PORTSC                  @0x%08x:  0x%08x\n",
+			(uint32_t) addr, readl_relaxed(addr));
 	return sprintf(buf, "HSIC_EHCI Registers Dump\n");
 }
+
 static DEVICE_ATTR(hsic_debug_ehci, S_IRUGO, hsic_debug_show, NULL);
 
 static struct of_device_id rk_hsic_of_match[] = {
 	{
-		.compatible = "rockchip,rk3188_rk_hsic_host",
-		.data = &rkhsic_pdata[RK3188_USB_CTLR],
-	},
+	 .compatible = "rockchip,rk3188_rk_hsic_host",
+	 .data = &rkhsic_pdata[RK3188_USB_CTLR],
+	 },
 	{
-		.compatible = "rockchip,rk3288_rk_hsic_host",
-		.data = &rkhsic_pdata[RK3288_USB_CTLR],
-	},
-	{ },
+	 .compatible = "rockchip,rk3288_rk_hsic_host",
+	 .data = &rkhsic_pdata[RK3288_USB_CTLR],
+	 },
+	{},
 };
 
 MODULE_DEVICE_TABLE(of, rk_hsic_of_match);
@@ -220,13 +236,13 @@ static int ehci_rkhsic_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct rkehci_pdata_id *p;
 	const struct of_device_id *match =
-		of_match_device(of_match_ptr( rk_hsic_of_match ), &pdev->dev);
+	    of_match_device(of_match_ptr(rk_hsic_of_match), &pdev->dev);
 
 	dev_dbg(&pdev->dev, "ehci_rkhsic proble\n");
 
-	if (match){
+	if (match) {
 		p = (struct rkehci_pdata_id *)match->data;
-	}else{
+	} else {
 		dev_err(dev, "ehci_rkhsic match failed\n");
 		return -EINVAL;
 	}
@@ -247,18 +263,18 @@ static int ehci_rkhsic_probe(struct platform_device *pdev)
 	hcd = usb_create_hcd(&rk_hsic_driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
 		dev_err(&pdev->dev, "Unable to create HCD\n");
-		return  -ENOMEM;
+		return -ENOMEM;
 	}
-	
-	if(pldata->hw_init)
+
+	if (pldata->hw_init)
 		pldata->hw_init();
 
-	if(pldata->clock_init){
+	if (pldata->clock_init) {
 		pldata->clock_init(pldata);
 		pldata->clock_enable(pldata, 1);
 	}
-	
-	if(pldata->soft_reset)
+
+	if (pldata->soft_reset)
 		pldata->soft_reset();
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -277,19 +293,19 @@ static int ehci_rkhsic_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto put_hcd;
 	}
-	
+
 	hcd->irq = platform_get_irq(pdev, 0);
 	if (hcd->irq < 0) {
 		dev_err(&pdev->dev, "Unable to get IRQ resource\n");
 		ret = hcd->irq;
 		goto put_hcd;
 	}
-	
+
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = hcd->regs;
 	ehci->regs = hcd->regs + 0x10;
 	printk("%s %p %p\n", __func__, ehci->caps, ehci->regs);
-    
+
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");
 
@@ -300,21 +316,20 @@ static int ehci_rkhsic_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Failed to add USB HCD\n");
 		goto put_hcd;
 	}
-	
+
 	g_hsic_ehci = ehci;
 	ehci_rkhsic_port_power(ehci, 1);
-	writel_relaxed(1 ,hcd->regs +0xb0);
-	writel_relaxed(0x1d4d ,hcd->regs +0x90);
-	writel_relaxed(0x4 ,hcd->regs +0xa0);
+	writel_relaxed(1, hcd->regs + 0xb0);
+	writel_relaxed(0x1d4d, hcd->regs + 0x90);
+	writel_relaxed(0x4, hcd->regs + 0xa0);
 	dsb();
 
-
 	printk("%s ok\n", __func__);
 
 	return 0;
 
 put_hcd:
-	if(pldata->clock_enable)
+	if (pldata->clock_enable)
 		pldata->clock_enable(pldata, 0);
 	usb_put_hcd(hcd);
 
@@ -334,7 +349,7 @@ static int ehci_rkhsic_remove(struct platform_device *pdev)
 static int ehci_rkhsic_pm_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	bool do_wakeup  = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev);
 	int ret;
 
 	dev_dbg(dev, "ehci-rkhsic PM suspend\n");
@@ -358,19 +373,18 @@ static int ehci_rkhsic_pm_resume(struct device *dev)
 #endif
 
 static const struct dev_pm_ops ehci_rkhsic_dev_pm_ops = {
-	.suspend	= ehci_rkhsic_pm_suspend,
-	.resume		= ehci_rkhsic_pm_resume,
+	.suspend = ehci_rkhsic_pm_suspend,
+	.resume = ehci_rkhsic_pm_resume,
 };
 
 static struct platform_driver ehci_rkhsic_driver = {
-	.probe	= ehci_rkhsic_probe,
-	.remove	= ehci_rkhsic_remove,
+	.probe = ehci_rkhsic_probe,
+	.remove = ehci_rkhsic_remove,
 	.driver = {
 		   .name = "rockchip_hsic_host",
 		   .of_match_table = of_match_ptr(rk_hsic_of_match),
 #ifdef CONFIG_PM
 		   .pm = &ehci_rkhsic_dev_pm_ops,
 #endif
-	},
+		   },
 };
-
diff --git a/drivers/usb/host/ehci-rockchip.c b/drivers/usb/host/ehci-rockchip.c
index 6b471403a441..74fd0b786d53 100755
--- a/drivers/usb/host/ehci-rockchip.c
+++ b/drivers/usb/host/ehci-rockchip.c
@@ -31,36 +31,36 @@ struct rk_ehci_hcd {
 	uint8_t host_enabled;
 	uint8_t host_setenable;
 	struct rkehci_platform_data *pldata;
-	struct timer_list 	connect_detect_timer;
-	struct delayed_work	host_enable_work;
+	struct timer_list connect_detect_timer;
+	struct delayed_work host_enable_work;
 };
-#define EHCI_PRINT(x...)   printk( KERN_INFO "EHCI: " x )
+#define EHCI_PRINT(x...)   printk(KERN_INFO "EHCI: " x)
 
 static struct rkehci_pdata_id rkehci_pdata[] = {
 	{
-		.name = "rk3188-reserved",
-		.pdata = NULL,
-	},
+	 .name = "rk3188-reserved",
+	 .pdata = NULL,
+	 },
 	{
-		.name = "rk3288-ehci",
-		.pdata = &rkehci_pdata_rk3288,
-	},
-	{ },
+	 .name = "rk3288-ehci",
+	 .pdata = &rkehci_pdata_rk3288,
+	 },
+	{},
 };
 
-static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
+static void ehci_port_power(struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
 
-	if (!HCS_PPC (ehci->hcs_params))
+	if (!HCS_PPC(ehci->hcs_params))
 		return;
 
-	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
-		(void) ehci_hub_control(ehci_to_hcd(ehci),
-				is_on ? SetPortFeature : ClearPortFeature,
-				USB_PORT_FEAT_POWER,
-				port--, NULL, 0);
+	ehci_dbg(ehci, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0;)
+		(void)ehci_hub_control(ehci_to_hcd(ehci),
+				       is_on ? SetPortFeature :
+				       ClearPortFeature, USB_PORT_FEAT_POWER,
+				       port--, NULL, 0);
 	/* Flush those writes */
 	ehci_readl(ehci, &ehci->regs->command);
 	msleep(20);
@@ -78,13 +78,16 @@ static void rk_ehci_hcd_enable(struct work_struct *work)
 	ehci = rk_ehci->ehci;
 	hcd = ehci_to_hcd(ehci);
 
-	if(rk_ehci->host_enabled == rk_ehci->host_setenable){
-		printk("%s, enable flag %d\n", __func__, rk_ehci->host_setenable);
+	if (rk_ehci->host_enabled == rk_ehci->host_setenable) {
+		printk("%s, enable flag %d\n", __func__,
+		       rk_ehci->host_setenable);
 		goto out;
 	}
 
-	if(rk_ehci->host_setenable == 2){// enable -> disable
-		if(pldata->get_status(USB_STATUS_DPDM)){// usb device connected
+	if (rk_ehci->host_setenable == 2) {
+		/* enable -> disable */
+		if (pldata->get_status(USB_STATUS_DPDM)) {
+			/* usb device connected */
 			rk_ehci->host_setenable = 1;
 			goto out;
 		}
@@ -96,15 +99,15 @@ static void rk_ehci_hcd_enable(struct work_struct *work)
 		/* reset cru and reinitialize EHCI controller */
 		pldata->soft_reset();
 		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
-		if(pldata->phy_suspend)
+		if (pldata->phy_suspend)
 			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 		/* do not disable EHCI clk, otherwise RK3288
 		 * host1(DWC_OTG) can't work normally.
 		 */
-		//pldata->clock_enable(pldata, 0);
-	}else if(rk_ehci->host_setenable == 1){
-		//pldata->clock_enable(pldata, 1);
-		if(pldata->phy_suspend)
+		/* pldata->clock_enable(pldata, 0); */
+	} else if (rk_ehci->host_setenable == 1) {
+		/* pldata->clock_enable(pldata, 1); */
+		if (pldata->phy_suspend)
 			pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 		mdelay(5);
 		ehci_port_power(ehci, 1);
@@ -118,7 +121,7 @@ static void rk_ehci_hcd_enable(struct work_struct *work)
 
 static void rk_ehci_hcd_connect_detect(unsigned long pdata)
 {
-	struct rk_ehci_hcd *rk_ehci= (struct rk_ehci_hcd*)pdata;
+	struct rk_ehci_hcd *rk_ehci = (struct rk_ehci_hcd *)pdata;
 	struct ehci_hcd *ehci = rk_ehci->ehci;
 	struct rkehci_platform_data *pldata;
 	uint32_t status;
@@ -128,82 +131,85 @@ static void rk_ehci_hcd_connect_detect(unsigned long pdata)
 
 	pldata = rk_ehci->pldata;
 
-	if(pldata->get_status(USB_STATUS_DPDM)){
-		// usb device connected
+	if (pldata->get_status(USB_STATUS_DPDM)) {
+		/* usb device connected */
 		rk_ehci->host_setenable = 1;
-	}else{
-		// no device, suspend host
+	} else {
+		/* no device, suspend host */
 		status = readl(&ehci->regs->port_status[0]);
-		if(!(status & PORT_CONNECT)){
+		if (!(status & PORT_CONNECT)) {
 			rk_ehci->host_setenable = 2;
 		}
 	}
 
-	if((rk_ehci->host_enabled) && (rk_ehci->host_setenable != rk_ehci->host_enabled)){
+	if ((rk_ehci->host_enabled)
+	    && (rk_ehci->host_setenable != rk_ehci->host_enabled)) {
 		schedule_delayed_work(&rk_ehci->host_enable_work, 1);
 	}
 
-	mod_timer(&rk_ehci->connect_detect_timer,jiffies + (HZ<<1));
+	mod_timer(&rk_ehci->connect_detect_timer, jiffies + (HZ << 1));
 
 	local_irq_restore(flags);
 	return;
 }
 
 static struct hc_driver rk_ehci_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "Rockchip On-Chip EHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.description = hcd_name,
+	.product_desc = "Rockchip On-Chip EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
 
 	/*
 	 * generic hardware linkage
 	 */
-	.irq			= ehci_irq,
-	.flags			= HCD_USB2 | HCD_MEMORY,
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
 
-	.reset			= ehci_init,
-	.start			= ehci_run,
+	.reset = ehci_init,
+	.start = ehci_run,
 
-	.stop			= ehci_stop,
-	.shutdown		= ehci_shutdown,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
 
 	/*
 	 * managing i/o requests and associated device resources
 	 */
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.endpoint_reset		= ehci_endpoint_reset,
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 
 	/*
 	 * scheduling support
 	 */
-	.get_frame_number	= ehci_get_frame,
+	.get_frame_number = ehci_get_frame,
 
 	/*
 	 * root hub support
 	 */
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-	.relinquish_port	= ehci_relinquish_port,
-	.port_handed_over	= ehci_port_handed_over,
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 
 	/*
 	 * PM support
 	 */
 #ifdef CONFIG_PM
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
 #endif
 };
-static ssize_t ehci_power_show( struct device *_dev,
-				struct device_attribute *attr, char *buf)
+
+static ssize_t ehci_power_show(struct device *_dev,
+			       struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", rkehci_status);
 }
-static ssize_t ehci_power_store( struct device *_dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count )
+
+static ssize_t ehci_power_store(struct device *_dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	uint32_t val = simple_strtoul(buf, NULL, 16);
 	struct usb_hcd *hcd = dev_get_drvdata(_dev);
@@ -211,73 +217,86 @@ static ssize_t ehci_power_store( struct device *_dev,
 	struct rkehci_platform_data *pldata = _dev->platform_data;
 
 	printk("%s: %d setting to: %d\n", __func__, rkehci_status, val);
-	if(val == rkehci_status)
+	if (val == rkehci_status)
 		goto out;
 
 	rkehci_status = val;
-	switch(val){
-		case 0: //power down
-			ehci_port_power(ehci, 0);
-			msleep(5);
-			usb_remove_hcd(hcd);
-			break;
-		case 1:// power on
-			pldata->soft_reset();
-			usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
-			ehci_port_power(ehci, 1);
-//			writel_relaxed(0x1d4d ,hcd->regs +0x90);
-//			writel_relaxed(0x4 ,hcd->regs +0xa0);
-//			dsb();
-			break;
-		default:
-			break;
+	switch (val) {
+	case 0:	/* power down */
+		ehci_port_power(ehci, 0);
+		msleep(5);
+		usb_remove_hcd(hcd);
+		break;
+	case 1:	/*  power on */
+		pldata->soft_reset();
+		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
+		ehci_port_power(ehci, 1);
+		break;
+	default:
+		break;
 	}
 out:
 	return count;
 }
-static DEVICE_ATTR(ehci_power, S_IRUGO|S_IWUSR, ehci_power_show, ehci_power_store);
-static ssize_t debug_show( struct device *_dev,
-				struct device_attribute *attr, char *buf)
+
+static DEVICE_ATTR(ehci_power, S_IRUGO | S_IWUSR, ehci_power_show,
+		   ehci_power_store);
+static ssize_t debug_show(struct device *_dev, struct device_attribute *attr,
+			  char *buf)
 {
 	volatile uint32_t *addr;
 
 	EHCI_PRINT("******** EHCI Capability Registers **********\n");
 	addr = &g_ehci->caps->hc_capbase;
-	EHCI_PRINT("HCIVERSION / CAPLENGTH  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("HCIVERSION / CAPLENGTH  @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->caps->hcs_params;
-	EHCI_PRINT("HCSPARAMS               @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("HCSPARAMS               @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->caps->hcc_params;
-	EHCI_PRINT("HCCPARAMS               @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("HCCPARAMS               @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	EHCI_PRINT("********* EHCI Operational Registers *********\n");
 	addr = &g_ehci->regs->command;
-	EHCI_PRINT("USBCMD                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("USBCMD                  @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->status;
-	EHCI_PRINT("USBSTS                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("USBSTS                  @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->intr_enable;
-	EHCI_PRINT("USBINTR                 @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("USBINTR                 @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->frame_index;
-	EHCI_PRINT("FRINDEX                 @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("FRINDEX                 @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->segment;
-	EHCI_PRINT("CTRLDSSEGMENT           @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("CTRLDSSEGMENT           @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->frame_list;
-	EHCI_PRINT("PERIODICLISTBASE        @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr)); 
+	EHCI_PRINT("PERIODICLISTBASE        @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->async_next;
-	EHCI_PRINT("ASYNCLISTADDR           @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("ASYNCLISTADDR           @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = &g_ehci->regs->configured_flag;
-	EHCI_PRINT("CONFIGFLAG              @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("CONFIGFLAG              @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	addr = g_ehci->regs->port_status;
-	EHCI_PRINT("PORTSC                  @0x%08x:  0x%08x\n", (uint32_t)addr, readl_relaxed(addr));
+	EHCI_PRINT("PORTSC                  @0x%08x:  0x%08x\n",
+		   (uint32_t) addr, readl_relaxed(addr));
 	return sprintf(buf, "EHCI Registers Dump\n");
 }
+
 static DEVICE_ATTR(debug_ehci, S_IRUGO, debug_show, NULL);
 
 static struct of_device_id rk_ehci_of_match[] = {
 	{
-		.compatible = "rockchip,rk3288_rk_ehci_host",
-		.data = &rkehci_pdata[RK3288_USB_CTLR],
-	},
-	{ },
+	 .compatible = "rockchip,rk3288_rk_ehci_host",
+	 .data = &rkehci_pdata[RK3288_USB_CTLR],
+	 },
+	{},
 };
+
 MODULE_DEVICE_TABLE(of, rk_ehci_of_match);
 
 static int ehci_rk_probe(struct platform_device *pdev)
@@ -294,13 +313,13 @@ static int ehci_rk_probe(struct platform_device *pdev)
 	struct rkehci_pdata_id *p;
 	struct rk_ehci_hcd *rk_ehci;
 	const struct of_device_id *match =
-		of_match_device(of_match_ptr( rk_ehci_of_match ), &pdev->dev);
+	    of_match_device(of_match_ptr(rk_ehci_of_match), &pdev->dev);
 
 	dev_dbg(&pdev->dev, "ehci_rk proble\n");
-	
-	if (match){
+
+	if (match) {
 		p = (struct rkehci_pdata_id *)match->data;
-	}else{
+	} else {
 		dev_err(dev, "ehci_rk match failed\n");
 		return -EINVAL;
 	}
@@ -318,24 +337,26 @@ static int ehci_rk_probe(struct platform_device *pdev)
 
 	retval = device_create_file(dev, &dev_attr_ehci_power);
 	retval = device_create_file(dev, &dev_attr_debug_ehci);
-	hcd = usb_create_hcd(&rk_ehci_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+	hcd =
+	    usb_create_hcd(&rk_ehci_hc_driver, &pdev->dev,
+			   dev_name(&pdev->dev));
 	if (!hcd) {
 		dev_err(&pdev->dev, "Unable to create HCD\n");
-		return  -ENOMEM;
+		return -ENOMEM;
 	}
 
-	if(pldata->hw_init)
+	if (pldata->hw_init)
 		pldata->hw_init();
 
-	if(pldata->clock_init){
+	if (pldata->clock_init) {
 		pldata->clock_init(pldata);
 		pldata->clock_enable(pldata, 1);
 	}
 
-	if(pldata->phy_suspend)
+	if (pldata->phy_suspend)
 		pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 
-	if(pldata->soft_reset)
+	if (pldata->soft_reset)
 		pldata->soft_reset();
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -381,8 +402,8 @@ static int ehci_rk_probe(struct platform_device *pdev)
 	g_ehci = ehci;
 
 	rk_ehci = devm_kzalloc(&pdev->dev, sizeof(struct rk_ehci_hcd),
-						   GFP_KERNEL);
-	if(!rk_ehci){
+			       GFP_KERNEL);
+	if (!rk_ehci) {
 		ret = -ENOMEM;
 		goto put_hcd;
 	}
@@ -393,14 +414,14 @@ static int ehci_rk_probe(struct platform_device *pdev)
 	rk_ehci->host_setenable = 2;
 	rk_ehci->connect_detect_timer.function = rk_ehci_hcd_connect_detect;
 	rk_ehci->connect_detect_timer.data = (unsigned long)(rk_ehci);
-	init_timer( &rk_ehci->connect_detect_timer );
-	mod_timer( &rk_ehci->connect_detect_timer, jiffies+(HZ<<3) );
-	INIT_DELAYED_WORK( &rk_ehci->host_enable_work, rk_ehci_hcd_enable );
+	init_timer(&rk_ehci->connect_detect_timer);
+	mod_timer(&rk_ehci->connect_detect_timer, jiffies + (HZ << 3));
+	INIT_DELAYED_WORK(&rk_ehci->host_enable_work, rk_ehci_hcd_enable);
 
 	ehci_port_power(ehci, 0);
 
-	if(pldata->phy_suspend){
-		if( pldata->phy_status == USB_PHY_ENABLED ){
+	if (pldata->phy_suspend) {
+		if (pldata->phy_status == USB_PHY_ENABLED) {
 			pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
 			/* do not disable EHCI clk, otherwise RK3288
 			 * host1(DWC_OTG) can't work normally.
@@ -413,14 +434,15 @@ static int ehci_rk_probe(struct platform_device *pdev)
 	printk("%s ok\n", __func__);
 
 	return 0;
- 
+
 put_hcd:
-	if(pldata->clock_enable)
+	if (pldata->clock_enable)
 		pldata->clock_enable(pldata, 0);
 	usb_put_hcd(hcd);
 
 	return ret;
 }
+
 static int ehci_rk_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
@@ -429,11 +451,12 @@ static int ehci_rk_remove(struct platform_device *pdev)
 
 	return 0;
 }
+
 #ifdef CONFIG_PM
 static int ehci_rk_pm_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	bool do_wakeup  = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev);
 	int ret;
 
 	dev_dbg(dev, "ehci-rockchip PM suspend\n");
@@ -458,18 +481,18 @@ static int ehci_rk_pm_resume(struct device *dev)
 #endif
 
 static const struct dev_pm_ops ehci_rk_dev_pm_ops = {
-	.suspend	= ehci_rk_pm_suspend,
-	.resume		= ehci_rk_pm_resume,
+	.suspend = ehci_rk_pm_suspend,
+	.resume = ehci_rk_pm_resume,
 };
 
 static struct platform_driver ehci_rk_driver = {
-	.probe	= ehci_rk_probe,
-	.remove	= ehci_rk_remove,
+	.probe = ehci_rk_probe,
+	.remove = ehci_rk_remove,
 	.driver = {
 		   .name = "rockchip_ehci_host",
 		   .of_match_table = of_match_ptr(rk_ehci_of_match),
 #ifdef CONFIG_PM
 		   .pm = &ehci_rk_dev_pm_ops,
 #endif
-	},
+		   },
 };
diff --git a/drivers/usb/host/ohci-rockchip.c b/drivers/usb/host/ohci-rockchip.c
index ea36310d40e2..1eb84b232f40 100755
--- a/drivers/usb/host/ohci-rockchip.c
+++ b/drivers/usb/host/ohci-rockchip.c
@@ -18,14 +18,14 @@
 
 static struct rkehci_pdata_id rkohci_pdata[] = {
 	{
-		.name = "rk3188-reserved",
-		.pdata = NULL,
-	},
-	{	
-		.name = "rk3288-ohci",
-		.pdata = &rkohci_pdata_rk3288,
-	},
-	{ },
+	 .name = "rk3188-reserved",
+	 .pdata = NULL,
+	 },
+	{
+	 .name = "rk3288-ohci",
+	 .pdata = &rkohci_pdata_rk3288,
+	 },
+	{},
 };
 
 static int ohci_rk_init(struct usb_hcd *hcd)
@@ -58,55 +58,56 @@ static int ohci_rk_start(struct usb_hcd *hcd)
 }
 
 static const struct hc_driver ohci_rk_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"RK OHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
+	.description = hcd_name,
+	.product_desc = "RK OHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ohci_hcd),
 
 	/*
 	 * generic hardware linkage
 	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
+	.irq = ohci_irq,
+	.flags = HCD_USB11 | HCD_MEMORY,
 
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset =		ohci_rk_init,
-	.start =		ohci_rk_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
+	.reset = ohci_rk_init,
+	.start = ohci_rk_start,
+	.stop = ohci_stop,
+	.shutdown = ohci_shutdown,
 
 	/*
 	 * managing i/o requests and associated device resources
 	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
+	.urb_enqueue = ohci_urb_enqueue,
+	.urb_dequeue = ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
 
 	/*
 	 * scheduling support
 	 */
-	.get_frame_number =	ohci_get_frame,
+	.get_frame_number = ohci_get_frame,
 
 	/*
 	 * root hub support
 	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
+	.hub_status_data = ohci_hub_status_data,
+	.hub_control = ohci_hub_control,
 #ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
+	.bus_suspend = ohci_bus_suspend,
+	.bus_resume = ohci_bus_resume,
 #endif
-	.start_port_reset =	ohci_start_port_reset,
+	.start_port_reset = ohci_start_port_reset,
 };
 
 static struct of_device_id rk_ohci_of_match[] = {
 	{
-		.compatible = "rockchip,rk3288_rk_ohci_host",
-		.data = &rkohci_pdata[RK3288_USB_CTLR],
-	},
-	{ },
+	 .compatible = "rockchip,rk3288_rk_ohci_host",
+	 .data = &rkohci_pdata[RK3288_USB_CTLR],
+	 },
+	{},
 };
+
 MODULE_DEVICE_TABLE(of, rk_ohci_of_match);
 
 /* ohci_hcd_rk_probe - initialize RK-based HCDs
@@ -116,26 +117,26 @@ MODULE_DEVICE_TABLE(of, rk_ohci_of_match);
  */
 static int ohci_hcd_rk_probe(struct platform_device *pdev)
 {
-	struct device		*dev = &pdev->dev;
-	struct usb_hcd		*hcd = NULL;
-	void __iomem		*regs = NULL;
-	struct resource		*res;
-	int			ret = -ENODEV;
-	int			irq;
+	struct device *dev = &pdev->dev;
+	struct usb_hcd *hcd = NULL;
+	void __iomem *regs = NULL;
+	struct resource *res;
+	int ret = -ENODEV;
+	int irq;
 	struct rkehci_platform_data *pldata;
-	struct device_node	*node = pdev->dev.of_node;
+	struct device_node *node = pdev->dev.of_node;
 	struct rkehci_pdata_id *p;
 	const struct of_device_id *match =
-		of_match_device(of_match_ptr( rk_ohci_of_match ), &pdev->dev);
+	    of_match_device(of_match_ptr(rk_ohci_of_match), &pdev->dev);
 
 	dev_dbg(&pdev->dev, "ohci_hcd_rk_probe\n");
 
 	if (usb_disabled())
 		return -ENODEV;
 
-	if (match){
+	if (match) {
 		p = (struct rkehci_pdata_id *)match->data;
-	}else{
+	} else {
 		dev_err(dev, "ohci_rk match failed\n");
 		return -EINVAL;
 	}
@@ -148,16 +149,16 @@ static int ohci_hcd_rk_probe(struct platform_device *pdev)
 		dev_err(dev, "device node not found\n");
 		return -EINVAL;
 	}
-	
-	if(pldata->hw_init)
+
+	if (pldata->hw_init)
 		pldata->hw_init();
 
-	if(pldata->clock_init){
+	if (pldata->clock_init) {
 		pldata->clock_init(pldata);
 		pldata->clock_enable(pldata, 1);
 	}
 
-	if(pldata->soft_reset)
+	if (pldata->soft_reset)
 		pldata->soft_reset();
 
 	irq = platform_get_irq(pdev, 0);
@@ -191,8 +192,7 @@ static int ohci_hcd_rk_probe(struct platform_device *pdev)
 	if (!dev->coherent_dma_mask)
 		dev->coherent_dma_mask = DMA_BIT_MASK(32);
 
-	hcd = usb_create_hcd(&ohci_rk_hc_driver, dev,
-			dev_name(dev));
+	hcd = usb_create_hcd(&ohci_rk_hc_driver, dev, dev_name(dev));
 	if (!hcd) {
 		dev_err(dev, "usb_create_hcd failed\n");
 		ret = -ENOMEM;
@@ -201,7 +201,7 @@ static int ohci_hcd_rk_probe(struct platform_device *pdev)
 
 	hcd->rsrc_start = res->start;
 	hcd->rsrc_len = resource_size(res);
-	hcd->regs =  regs;
+	hcd->regs = regs;
 
 	ohci_hcd_init(hcd_to_ohci(hcd));
 
@@ -217,7 +217,7 @@ static int ohci_hcd_rk_probe(struct platform_device *pdev)
 	usb_put_hcd(hcd);
 
 clk_disable:
-	if(pldata->clock_enable)
+	if (pldata->clock_enable)
 		pldata->clock_enable(pldata, 0);
 
 	return ret;
@@ -225,8 +225,8 @@ static int ohci_hcd_rk_probe(struct platform_device *pdev)
 
 static int ohci_hcd_rk_remove(struct platform_device *pdev)
 {
-	struct device *dev	= &pdev->dev;
-	struct usb_hcd *hcd	= dev_get_drvdata(dev);
+	struct device *dev = &pdev->dev;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
 
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
@@ -242,12 +242,13 @@ static void ohci_hcd_rk_shutdown(struct platform_device *pdev)
 }
 
 static struct platform_driver ohci_hcd_rk_driver = {
-	.probe		= ohci_hcd_rk_probe,
-	.remove		= ohci_hcd_rk_remove,
-	.shutdown	= ohci_hcd_rk_shutdown,
-	.driver		= {
-		.name	= "ohci-rockchip",
-		.of_match_table = of_match_ptr(rk_ohci_of_match),
-	},
+	.probe = ohci_hcd_rk_probe,
+	.remove = ohci_hcd_rk_remove,
+	.shutdown = ohci_hcd_rk_shutdown,
+	.driver = {
+		   .name = "ohci-rockchip",
+		   .of_match_table = of_match_ptr(rk_ohci_of_match),
+		   },
 };
+
 MODULE_ALIAS("platform:rockchip-ohci");
-- 
2.35.3

