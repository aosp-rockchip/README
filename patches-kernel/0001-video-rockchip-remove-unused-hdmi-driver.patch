From 567278c61b952c3909124c41db38ae3ad7ca2286 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Mon, 9 Sep 2019 17:56:47 +0800
Subject: [PATCH] video: rockchip: remove unused hdmi driver

Change-Id: I02744c042c5c29b79c98b5da17acf0da889a005e
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/video/rockchip/hdmi/Kconfig           |   16 -
 drivers/video/rockchip/hdmi/Makefile          |   10 -
 .../video/rockchip/hdmi/rockchip-hdmi-cec.c   |  307 ---
 .../video/rockchip/hdmi/rockchip-hdmi-cec.h   |  193 --
 .../video/rockchip/hdmi/rockchip-hdmi-core.c  |  840 ------
 .../video/rockchip/hdmi/rockchip-hdmi-edid.c  |  560 ----
 .../video/rockchip/hdmi/rockchip-hdmi-lcdc.c  | 1597 ------------
 .../video/rockchip/hdmi/rockchip-hdmi-sysfs.c |  673 -----
 drivers/video/rockchip/hdmi/rockchip-hdmi.h   |  613 -----
 .../rockchip/hdmi/rockchip-hdmiv1/Kconfig     |    7 -
 .../rockchip/hdmi/rockchip-hdmiv1/Makefile    |    8 -
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c    |  441 ----
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h    |   39 -
 .../rockchip-hdmiv1/rockchip_hdmiv1_cec.c     |  153 --
 .../rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c    |  835 ------
 .../rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h    |  187 --
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c |  995 -------
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h |  472 ----
 .../rockchip/hdmi/rockchip-hdmiv2/Kconfig     |    8 -
 .../rockchip/hdmi/rockchip-hdmiv2/Makefile    |    8 -
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c    |  841 ------
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h    |   80 -
 .../rockchip-hdmiv2/rockchip_hdmiv2_cec.c     |  121 -
 .../rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c    |  678 -----
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c | 2310 -----------------
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h | 1756 -------------
 26 files changed, 13748 deletions(-)
 delete mode 100644 drivers/video/rockchip/hdmi/Kconfig
 delete mode 100644 drivers/video/rockchip/hdmi/Makefile
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmi.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
 delete mode 100644 drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h

diff --git a/drivers/video/rockchip/hdmi/Kconfig b/drivers/video/rockchip/hdmi/Kconfig
deleted file mode 100644
index 941f9f742bd6..000000000000
--- a/drivers/video/rockchip/hdmi/Kconfig
+++ /dev/null
@@ -1,16 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menuconfig RK_HDMI
-       bool "Rockchip HDMI support"
-       depends on FB_ROCKCHIP || DRM_ROCKCHIP
-       select FB_MODE_HELPERS
-
-source "drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig"
-source "drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig"
-
-config RK_HDMI_DEBUG
-		bool "Rockchip HDMI Debugging"
-        depends on RK_HDMI
-        default n
-		help
-		  Enableds verbose debugging the the HDMI drivers
-
diff --git a/drivers/video/rockchip/hdmi/Makefile b/drivers/video/rockchip/hdmi/Makefile
deleted file mode 100644
index 98bf7edb35c6..000000000000
--- a/drivers/video/rockchip/hdmi/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for HDMI linux kernel module.
-#
-
-ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
-
-obj-$(CONFIG_RK_HDMI) += rockchip-hdmi-core.o rockchip-hdmi-lcdc.o rockchip-hdmi-edid.o rockchip-hdmi-sysfs.o rockchip-hdmi-cec.o
-obj-$(CONFIG_RK_HDMI_V2) += rockchip-hdmiv2/
-obj-$(CONFIG_RK_HDMI_V1) += rockchip-hdmiv1/
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
deleted file mode 100644
index ba0938e5d0cb..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/firmware.h>
-#include <linux/ioctl.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pagemap.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/workqueue.h>
-#include "rockchip-hdmi-cec.h"
-
-static struct cec_device *cec_dev;
-
-static int cecreadframe(struct cec_framedata *frame)
-{
-	int ret = -1;
-
-	if (frame && cec_dev && cec_dev->readframe && cec_dev->enable) {
-		mutex_lock(&cec_dev->hdmi->pclk_lock);
-		ret = cec_dev->readframe(cec_dev->hdmi, frame);
-		mutex_unlock(&cec_dev->hdmi->pclk_lock);
-	}
-	return ret;
-}
-
-static int cecsendframe(struct cec_framedata *frame)
-{
-	int ret = -1;
-
-	if (frame && cec_dev && cec_dev->sendframe) {
-		mutex_lock(&cec_dev->hdmi->pclk_lock);
-		ret = cec_dev->sendframe(cec_dev->hdmi, frame);
-		mutex_unlock(&cec_dev->hdmi->pclk_lock);
-	}
-	return ret;
-}
-
-static void cecsetlogicaddr(int addr)
-{
-	if (cec_dev && cec_dev->setceclogicaddr) {
-		mutex_lock(&cec_dev->hdmi->pclk_lock);
-		cec_dev->setceclogicaddr(cec_dev->hdmi, addr);
-		mutex_unlock(&cec_dev->hdmi->pclk_lock);
-	}
-}
-
-static void cecworkfunc(struct work_struct *work)
-{
-	struct cec_delayed_work *cec_w =
-		container_of(work, struct cec_delayed_work, work.work);
-	struct cecframelist *list_node;
-
-	switch (cec_w->event) {
-	case EVENT_ENUMERATE:
-		break;
-	case EVENT_RX_FRAME:
-		list_node = kmalloc(sizeof(*list_node), GFP_KERNEL);
-		if (!list_node)
-			return;
-		cecreadframe(&list_node->cecframe);
-		if (cec_dev->enable) {
-			mutex_lock(&cec_dev->cec_lock);
-			list_add_tail(&list_node->framelist,
-				      &cec_dev->ceclist);
-			sysfs_notify(&cec_dev->device.this_device->kobj,
-				     NULL, "stat");
-			mutex_unlock(&cec_dev->cec_lock);
-		} else {
-			kfree(list_node);
-		}
-		break;
-	default:
-		break;
-	}
-
-	kfree(cec_w->data);
-	kfree(cec_w);
-}
-
-void rockchip_hdmi_cec_submit_work(int event, int delay, void *data)
-{
-	struct cec_delayed_work *work;
-
-	HDMIDBG(1, "%s event %04x delay %d\n", __func__, event, delay);
-
-	if (!cec_dev)
-		return;
-
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-
-	if (work) {
-		INIT_DELAYED_WORK(&work->work, cecworkfunc);
-		work->event = event;
-		work->data = data;
-		queue_delayed_work(cec_dev->workqueue,
-				   &work->work,
-				   msecs_to_jiffies(delay));
-	} else {
-		HDMIDBG(1, "CEC: Cannot allocate memory\n");
-	}
-}
-
-void rockchip_hdmi_cec_set_pa(int devpa)
-{
-	struct list_head *pos, *n;
-
-	if (cec_dev) {
-		cec_dev->address_phy = devpa;
-		pr_info("%s %x\n", __func__, devpa);
-		/*when hdmi hpd , ceclist will be reset*/
-		mutex_lock(&cec_dev->cec_lock);
-		if (!list_empty(&cec_dev->ceclist)) {
-			list_for_each_safe(pos, n, &cec_dev->ceclist) {
-				list_del(pos);
-				kfree(pos);
-			}
-		}
-		INIT_LIST_HEAD(&cec_dev->ceclist);
-		sysfs_notify(&cec_dev->device.this_device->kobj, NULL, "stat");
-		mutex_unlock(&cec_dev->cec_lock);
-	}
-}
-
-static ssize_t  cec_enable_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%d\n", cec_dev->enable);
-}
-
-static ssize_t cec_enable_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
-{
-	int ret;
-
-	ret = kstrtoint(buf, 0, &cec_dev->enable);
-	return count;
-}
-
-static ssize_t  cec_phy_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "0x%x\n", cec_dev->address_phy);
-}
-
-static ssize_t cec_phy_store(struct device *dev,
-			     struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	int ret;
-
-	ret = kstrtoint(buf, 0, &cec_dev->address_phy);
-	return count;
-}
-
-static ssize_t  cec_logic_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "0x%02x\n", cec_dev->address_logic);
-}
-
-static ssize_t cec_logic_store(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	int ret;
-
-	ret = kstrtoint(buf, 0, &cec_dev->address_logic);
-	return count;
-}
-
-static ssize_t  cec_state_show(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	int stat;
-
-	mutex_lock(&cec_dev->cec_lock);
-	if (!cec_dev->address_phy)
-		stat = 0;
-	else if (list_empty(&cec_dev->ceclist))
-		stat = 1;
-	else
-		stat = 2;
-	mutex_unlock(&cec_dev->cec_lock);
-	return snprintf(buf, PAGE_SIZE, "%d\n", stat);
-}
-
-static struct device_attribute cec_attrs[] = {
-	__ATTR(logic, 0644, cec_logic_show, cec_logic_store),
-	__ATTR(phy, 0644, cec_phy_show, cec_phy_store),
-	__ATTR(enable, 0644, cec_enable_show, cec_enable_store),
-	__ATTR(stat, S_IRUGO, cec_state_show, NULL),
-};
-
-static long cec_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	int ret;
-	void __user *argp;
-	struct cec_framedata cecsendtemp;
-	struct cecframelist *listemp;
-
-	argp = (void __user *)arg;
-	switch (cmd) {
-	case HDMI_IOCTL_CECSETLA:
-		ret = copy_from_user(&cec_dev->address_logic,
-				     argp, sizeof(int));
-		cecsetlogicaddr(cec_dev->address_logic);
-		break;
-	case HDMI_IOCTL_CECSEND:
-		ret = copy_from_user(&cecsendtemp, argp,
-				     sizeof(struct cec_framedata));
-		ret = cecsendframe(&cecsendtemp);
-		cecsendtemp.returnval = ret;
-		ret = copy_to_user(argp, &cecsendtemp,
-				   sizeof(struct cec_framedata));
-		break;
-	case HDMI_IOCTL_CECENAB:
-		ret = copy_from_user(&cec_dev->enable, argp, sizeof(int));
-		break;
-	case HDMI_IOCTL_CECPHY:
-		ret = copy_to_user(argp, &cec_dev->address_phy, sizeof(int));
-		break;
-	case HDMI_IOCTL_CECLOGIC:
-		ret = copy_to_user(argp, &cec_dev->address_logic,
-				   sizeof(int));
-		break;
-	case HDMI_IOCTL_CECREAD:
-		mutex_lock(&cec_dev->cec_lock);
-		if (!list_empty(&cec_dev->ceclist)) {
-			listemp = list_entry(cec_dev->ceclist.next,
-					     struct cecframelist, framelist);
-			ret = copy_to_user(argp, &listemp->cecframe,
-					   sizeof(struct cec_framedata));
-			list_del(&listemp->framelist);
-			kfree(listemp);
-		}
-		mutex_unlock(&cec_dev->cec_lock);
-		break;
-	case HDMI_IOCTL_CECCLEARLA:
-		break;
-	case HDMI_IOCTL_CECWAKESTATE:
-		ret = copy_to_user(argp, &cec_dev->hdmi->sleep, sizeof(int));
-		break;
-
-	default:
-		break;
-	}
-	return 0;
-}
-
-static const struct file_operations cec_fops = {
-	.owner		= THIS_MODULE,
-	.compat_ioctl	= cec_ioctl,
-	.unlocked_ioctl	= cec_ioctl,
-};
-
-int rockchip_hdmi_cec_init(struct hdmi *hdmi,
-			   int (*sendframe)(struct hdmi *,
-					    struct cec_framedata *),
-			   int (*readframe)(struct hdmi *,
-					    struct cec_framedata *),
-			   void (*setceclogicaddr)(struct hdmi *, int))
-{
-	int ret, i;
-
-	cec_dev = kmalloc(sizeof(*cec_dev), GFP_KERNEL);
-	if (!cec_dev)
-		return -ENOMEM;
-
-	memset(cec_dev, 0, sizeof(struct cec_device));
-	mutex_init(&cec_dev->cec_lock);
-	INIT_LIST_HEAD(&cec_dev->ceclist);
-	cec_dev->hdmi = hdmi;
-	cec_dev->enable = 1;
-	cec_dev->sendframe = sendframe;
-	cec_dev->readframe = readframe;
-	cec_dev->setceclogicaddr = setceclogicaddr;
-	cec_dev->workqueue = create_singlethread_workqueue("hdmi-cec");
-	if (!cec_dev->workqueue) {
-		pr_err("HDMI CEC: create workqueue failed.\n");
-		return -1;
-	}
-	cec_dev->device.minor = MISC_DYNAMIC_MINOR;
-	cec_dev->device.name = "cec";
-	cec_dev->device.mode = 0666;
-	cec_dev->device.fops = &cec_fops;
-	if (misc_register(&cec_dev->device)) {
-		pr_err("CEC: Could not add cec misc driver\n");
-		goto error;
-	}
-	for (i = 0; i < ARRAY_SIZE(cec_attrs); i++) {
-		ret = device_create_file(cec_dev->device.this_device,
-					 &cec_attrs[i]);
-		if (ret) {
-			pr_err("CEC: Could not add sys file\n");
-			goto error1;
-		}
-	}
-	return 0;
-
-error1:
-	misc_deregister(&cec_dev->device);
-error:
-	return -EINVAL;
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h
deleted file mode 100644
index 74e2b9918720..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROCKCHIP_HDMI_CEC_H__
-#define __ROCKCHIP_HDMI_CEC_H__
-
-#include <linux/input.h>
-#include <linux/miscdevice.h>
-#include "rockchip-hdmi.h"
-
-enum {
-	CEC_LOGADDR_TV          = 0x00,
-	CEC_LOGADDR_RECDEV1     = 0x01,
-	CEC_LOGADDR_RECDEV2     = 0x02,
-	CEC_LOGADDR_TUNER1      = 0x03,     /* STB1 in Spev v1.3 */
-	CEC_LOGADDR_PLAYBACK1   = 0x04,     /* DVD1 in Spev v1.3 */
-	CEC_LOGADDR_AUDSYS      = 0x05,
-	CEC_LOGADDR_TUNER2      = 0x06,     /* STB2 in Spec v1.3 */
-	CEC_LOGADDR_TUNER3      = 0x07,     /* STB3 in Spec v1.3 */
-	CEC_LOGADDR_PLAYBACK2   = 0x08,     /* DVD2 in Spec v1.3 */
-	CEC_LOGADDR_RECDEV3     = 0x09,
-	CEC_LOGADDR_TUNER4      = 0x0A,     /* RES1 in Spec v1.3 */
-	CEC_LOGADDR_PLAYBACK3   = 0x0B,     /* RES2 in Spec v1.3 */
-	CEC_LOGADDR_RES3        = 0x0C,
-	CEC_LOGADDR_RES4        = 0x0D,
-	CEC_LOGADDR_FREEUSE     = 0x0E,
-	CEC_LOGADDR_UNREGORBC   = 0x0F
-
-};
-
-enum {                   /* CEC Messages */
-	CECOP_FEATURE_ABORT			= 0x00,
-	CECOP_IMAGE_VIEW_ON			= 0x04,
-	CECOP_TUNER_STEP_INCREMENT		= 0x05,
-	CECOP_TUNER_STEP_DECREMENT		= 0x06,
-	CECOP_TUNER_DEVICE_STATUS		= 0x07,
-	CECOP_GIVE_TUNER_DEVICE_STATUS		= 0x08,
-	CECOP_RECORD_ON				= 0x09,
-	CECOP_RECORD_STATUS			= 0x0A,
-	CECOP_RECORD_OFF			= 0x0B,
-	CECOP_TEXT_VIEW_ON			= 0x0D,
-	CECOP_RECORD_TV_SCREEN			= 0x0F,
-	CECOP_GIVE_DECK_STATUS			= 0x1A,
-	CECOP_DECK_STATUS			= 0x1B,
-	CECOP_SET_MENU_LANGUAGE			= 0x32,
-	CECOP_CLEAR_ANALOGUE_TIMER		= 0x33,     /* Spec 1.3A */
-	CECOP_SET_ANALOGUE_TIMER		= 0x34,     /* Spec 1.3A */
-	CECOP_TIMER_STATUS			= 0x35,     /* Spec 1.3A */
-	CECOP_STANDBY				= 0x36,
-	CECOP_PLAY				= 0x41,
-	CECOP_DECK_CONTROL			= 0x42,
-	CECOP_TIMER_CLEARED_STATUS		= 0x43,     /* Spec 1.3A */
-	CECOP_USER_CONTROL_PRESSED		= 0x44,
-	CECOP_USER_CONTROL_RELEASED		= 0x45,
-	CECOP_GIVE_OSD_NAME			= 0x46,
-	CECOP_SET_OSD_NAME			= 0x47,
-	CECOP_SET_OSD_STRING			= 0x64,
-	CECOP_SET_TIMER_PROGRAM_TITLE		= 0x67,	/* Spec 1.3A */
-	CECOP_SYSTEM_AUDIO_MODE_REQUEST		= 0x70,	/* Spec 1.3A */
-	CECOP_GIVE_AUDIO_STATUS			= 0x71,	/* Spec 1.3A */
-	CECOP_SET_SYSTEM_AUDIO_MODE		= 0x72,	/* Spec 1.3A */
-	CECOP_REPORT_AUDIO_STATUS		= 0x7A,	/* Spec 1.3A */
-	CECOP_GIVE_SYSTEM_AUDIO_MODE_STATUS	= 0x7D,	/* Spec 1.3A */
-	CECOP_SYSTEM_AUDIO_MODE_STATUS		= 0x7E,	/* Spec 1.3A */
-	CECOP_ROUTING_CHANGE			= 0x80,
-	CECOP_ROUTING_INFORMATION		= 0x81,
-	CECOP_ACTIVE_SOURCE			= 0x82,
-	CECOP_GIVE_PHYSICAL_ADDRESS		= 0x83,
-	CECOP_REPORT_PHYSICAL_ADDRESS		= 0x84,
-	CECOP_REQUEST_ACTIVE_SOURCE		= 0x85,
-	CECOP_SET_STREAM_PATH			= 0x86,
-	CECOP_DEVICE_VENDOR_ID			= 0x87,
-	CECOP_VENDOR_COMMAND			= 0x89,
-	CECOP_VENDOR_REMOTE_BUTTON_DOWN		= 0x8A,
-	CECOP_VENDOR_REMOTE_BUTTON_UP		= 0x8B,
-	CECOP_GIVE_DEVICE_VENDOR_ID		= 0x8C,
-	CECOP_MENU_REQUEST			= 0x8D,
-	CECOP_MENU_STATUS			= 0x8E,
-	CECOP_GIVE_DEVICE_POWER_STATUS		= 0x8F,
-	CECOP_REPORT_POWER_STATUS		= 0x90,
-	CECOP_GET_MENU_LANGUAGE			= 0x91,
-	CECOP_SELECT_ANALOGUE_SERVICE		= 0x92,     /* Spec 1.3A */
-	CECOP_SELECT_DIGITAL_SERVICE		= 0x93,
-	CECOP_SET_DIGITAL_TIMER			= 0x97,     /* Spec 1.3A */
-	CECOP_CLEAR_DIGITAL_TIMER		= 0x99,     /* Spec 1.3A */
-	CECOP_SET_AUDIO_RATE			= 0x9A,     /* Spec 1.3A */
-	CECOP_INACTIVE_SOURCE			= 0x9D,     /* Spec 1.3A */
-	CECOP_CEC_VERSION			= 0x9E,     /* Spec 1.3A */
-	CECOP_GET_CEC_VERSION			= 0x9F,     /* Spec 1.3A */
-	CECOP_VENDOR_COMMAND_WITH_ID		= 0xA0,     /* Spec 1.3A */
-	CECOP_CLEAR_EXTERNAL_TIMER		= 0xA1,     /* Spec 1.3A */
-	CECOP_SET_EXTERNAL_TIMER		= 0xA2,     /* Spec 1.3A */
-	CDCOP_HEADER				= 0xF8,
-	CECOP_ABORT				= 0xFF,
-
-	CECOP_REPORT_SHORT_AUDIO		= 0xA3,     /* Spec 1.4 */
-	CECOP_REQUEST_SHORT_AUDIO		= 0xA4,     /* Spec 1.4 */
-
-	CECOP_ARC_INITIATE			= 0xC0,
-	CECOP_ARC_REPORT_INITIATED		= 0xC1,
-	CECOP_ARC_REPORT_TERMINATED		= 0xC2,
-
-	CECOP_ARC_REQUEST_INITIATION		= 0xC3,
-	CECOP_ARC_REQUEST_TERMINATION		= 0xC4,
-	CECOP_ARC_TERMINATE			= 0xC5,
-
-};
-
-/* Operands for <Feature Abort> Opcode */
-enum {
-	CECAR_UNRECOG_OPCODE            = 0x00,
-	CECAR_NOT_CORRECT_MODE,
-	CECAR_CANT_PROVIDE_SOURCE,
-	CECAR_INVALID_OPERAND,
-	CECAR_REFUSED
-};
-
-/* Operands for <Power Status> Opcode */
-enum {
-	CEC_POWERSTATUS_ON              = 0x00,
-	CEC_POWERSTATUS_STANDBY         = 0x01,
-	CEC_POWERSTATUS_STANDBY_TO_ON   = 0x02,
-	CEC_POWERSTATUS_ON_TO_STANDBY   = 0x03,
-};
-
-enum {
-	EVENT_RX_FRAME,
-	EVENT_ENUMERATE,
-};
-
-enum {
-	CEC_SEND_SUCCESS = 0,
-	CEC_SEND_NACK,
-	CEC_SEND_BUSY
-};
-
-#define MAKE_SRCDEST(src, dest)    ((src << 4) | dest)
-
-#define MAX_CMD_SIZE 16
-
-struct cec_framedata {
-	u8 srcdestaddr; /* Source in upper nybble, dest in lower nybble */
-	u8 opcode;
-	u8 args[MAX_CMD_SIZE];
-	u8 argcount;
-	char returnval;
-};
-
-struct cec_delayed_work {
-	struct delayed_work work;
-	int event;
-	void *data;
-};
-
-struct cecframelist {
-	struct list_head framelist;
-	struct cec_framedata cecframe;
-};
-
-struct cec_device {
-	struct workqueue_struct *workqueue;
-	struct hdmi *hdmi;
-	struct miscdevice device;
-	int address_phy;
-	int address_logic;
-	int powerstatus;
-	int enable;
-	struct list_head ceclist;
-	struct mutex cec_lock;	/* mutex for hdmicec operation*/
-
-	int (*sendframe)(struct hdmi *, struct cec_framedata *);
-	int (*readframe)(struct hdmi *, struct cec_framedata *);
-	void (*setceclogicaddr)(struct hdmi *, int);
-};
-
-#define HDMI_CEC_MAGIC     'N'
-#define HDMI_IOCTL_CECSEND   _IOW(HDMI_CEC_MAGIC, 0, struct cec_framedata)
-#define HDMI_IOCTL_CECENAB   _IOW(HDMI_CEC_MAGIC, 1, int)
-#define HDMI_IOCTL_CECPHY    _IOR(HDMI_CEC_MAGIC, 2, int)
-#define HDMI_IOCTL_CECLOGIC  _IOR(HDMI_CEC_MAGIC, 3, int)
-#define HDMI_IOCTL_CECREAD   _IOR(HDMI_CEC_MAGIC, 4, struct cec_framedata)
-#define HDMI_IOCTL_CECSETLA  _IOW(HDMI_CEC_MAGIC, 5, int)
-#define HDMI_IOCTL_CECCLEARLA  _IOW(HDMI_CEC_MAGIC, 6, int)
-#define HDMI_IOCTL_CECWAKESTATE  _IOR(HDMI_CEC_MAGIC, 7, int)
-/*for HAL ioctl end*/
-
-int rockchip_hdmi_cec_init(struct hdmi *hdmi,
-			   int (*sendframe)(struct hdmi *,
-					    struct cec_framedata *),
-			   int (*readframe)(struct hdmi *,
-					    struct cec_framedata *),
-			   void (*setceclogicaddr)(struct hdmi *, int));
-void rockchip_hdmi_cec_set_pa(int devpa);
-void rockchip_hdmi_cec_submit_work(int event, int delay, void *data);
-#endif /* __HDMI_CEC_H__ */
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
deleted file mode 100644
index d940a53914a7..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
+++ /dev/null
@@ -1,840 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/delay.h>
-#include <sound/pcm_params.h>
-#include "rockchip-hdmi.h"
-#include "rockchip-hdmi-cec.h"
-
-#define HW_PARAMS_FLAG_LPCM 0
-#define HW_PARAMS_FLAG_NLPCM 1
-
-struct hdmi_delayed_work {
-	struct delayed_work work;
-	struct hdmi *hdmi;
-	int event;
-	int sync;
-	void *data;
-};
-
-struct hdmi_id_ref_info {
-	struct hdmi *hdmi;
-	int id;
-	int ref;
-} ref_info[HDMI_MAX_ID];
-
-static int uboot_vic;
-static void hdmi_work_queue(struct work_struct *work);
-
-void hdmi_submit_work(struct hdmi *hdmi,
-		      int event, int delay, int sync)
-{
-	struct hdmi_delayed_work *work;
-
-	HDMIDBG(2, "%s event %04x delay %d sync %d\n",
-		__func__, event, delay, sync);
-
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-
-	if (work) {
-		INIT_DELAYED_WORK(&work->work, hdmi_work_queue);
-		work->hdmi = hdmi;
-		work->event = event;
-		work->data = NULL;
-		work->sync = sync;
-		queue_delayed_work(hdmi->workqueue,
-				   &work->work,
-				   msecs_to_jiffies(delay));
-		if (sync) {
-			flush_delayed_work(&work->work);
-			kfree(work);
-		}
-	} else {
-		pr_warn("HDMI: Cannot allocate memory to create work\n");
-	}
-}
-
-static void hdmi_send_uevent(struct hdmi *hdmi, int uevent)
-{
-	char *envp[3];
-
-	envp[0] = "INTERFACE=HDMI";
-	envp[1] = kmalloc(32, GFP_KERNEL);
-	if (!envp[1])
-		return;
-	sprintf(envp[1], "SCREEN=%d", hdmi->ddev->property);
-	envp[2] = NULL;
-	kobject_uevent_env(&hdmi->ddev->dev->kobj, uevent, envp);
-	kfree(envp[1]);
-}
-
-static inline void hdmi_wq_set_output(struct hdmi *hdmi, int mute)
-{
-	HDMIDBG(2, "%s mute %d\n", __func__, mute);
-	if (hdmi->ops->setmute)
-		hdmi->ops->setmute(hdmi, mute);
-}
-
-static inline void hdmi_wq_set_audio(struct hdmi *hdmi)
-{
-	HDMIDBG(2, "%s\n", __func__);
-	if (hdmi->ops->setaudio)
-		hdmi->ops->setaudio(hdmi, &hdmi->audio);
-}
-
-static int hdmi_check_format(struct hdmi *hdmi, struct hdmi_video *vpara)
-{
-	struct hdmi_video_timing *timing;
-	struct fb_videomode *mode;
-	int tmdsclk;
-
-	if (!vpara)
-		return -ENOENT;
-	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
-	if (!timing) {
-		pr_err("[%s] not found vic %d\n", __func__, vpara->vic);
-		return -ENOENT;
-	}
-	mode = &timing->mode;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		tmdsclk = mode->pixclock / 2;
-	else if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
-		tmdsclk = 2 * mode->pixclock;
-	else
-		tmdsclk = mode->pixclock;
-	if (vpara->color_output != HDMI_COLOR_YCBCR422) {
-		switch (vpara->color_output_depth) {
-		case 10:
-			tmdsclk += tmdsclk / 4;
-			break;
-		case 12:
-			tmdsclk += tmdsclk / 2;
-			break;
-		case 16:
-			tmdsclk += tmdsclk;
-			break;
-		case 8:
-		default:
-			break;
-		}
-	} else if (vpara->color_output_depth > 12) {
-		/* YCbCr422 mode only support up to 12bit */
-		vpara->color_output_depth = 12;
-	}
-	if ((tmdsclk > 594000000) ||
-	    (tmdsclk > 340000000 &&
-	     tmdsclk > hdmi->edid.maxtmdsclock)) {
-		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
-			pr_err("out of max tmdsclk, disable 3d\n");
-			vpara->format_3d = 0;
-		} else if (vpara->color_output == HDMI_COLOR_YCBCR444 &&
-			   hdmi->edid.ycbcr422) {
-			pr_warn("out of max tmdsclk, down to YCbCr422");
-			vpara->color_output = HDMI_COLOR_YCBCR422;
-		} else {
-			pr_warn("out of max tmds clock, limit to 8bit\n");
-			vpara->color_output_depth = 8;
-		}
-	}
-	return 0;
-}
-
-static void hdmi_wq_set_video(struct hdmi *hdmi)
-{
-	struct hdmi_video *video = &hdmi->video;
-	int	deepcolor;
-
-	HDMIDBG(2, "%s\n", __func__);
-
-	video->sink_hdmi = hdmi->edid.sink_hdmi;
-	video->format_3d = hdmi->mode_3d;
-	video->colorimetry = hdmi->colorimetry;
-	video->color_output_depth = 8;
-	if (hdmi->autoset)
-		hdmi->vic = hdmi_find_best_mode(hdmi, 0);
-	else
-		hdmi->vic = hdmi_find_best_mode(hdmi, hdmi->vic);
-
-	if (hdmi->vic == 0)
-		hdmi->vic = hdmi->property->defaultmode;
-
-	/* For DVI, output RGB */
-	if (video->sink_hdmi == 0) {
-		video->color_output = HDMI_COLOR_RGB_0_255;
-	} else {
-		if (hdmi->colormode == HDMI_COLOR_AUTO) {
-			if (hdmi->edid.ycbcr444)
-				video->color_output = HDMI_COLOR_YCBCR444;
-			else if (hdmi->edid.ycbcr422)
-				video->color_output = HDMI_COLOR_YCBCR422;
-			else
-				video->color_output = HDMI_COLOR_RGB_16_235;
-		} else {
-			video->color_output = hdmi->colormode;
-		}
-		if (hdmi->vic & HDMI_VIDEO_YUV420) {
-			video->color_output = HDMI_COLOR_YCBCR420;
-			deepcolor = hdmi->edid.deepcolor_420;
-		} else {
-			deepcolor = hdmi->edid.deepcolor;
-		}
-		if ((hdmi->property->feature & SUPPORT_DEEP_10BIT) &&
-		    (deepcolor & HDMI_DEEP_COLOR_30BITS) &&
-		     hdmi->colordepth == 10)
-			video->color_output_depth = 10;
-	}
-	pr_info("hdmi output corlor mode is %d\n", video->color_output);
-	if ((hdmi->property->feature & SUPPORT_YCBCR_INPUT) &&
-	    (video->color_output == HDMI_COLOR_YCBCR444 ||
-	     video->color_output == HDMI_COLOR_YCBCR422))
-		video->color_input = HDMI_COLOR_YCBCR444;
-	else if (video->color_output == HDMI_COLOR_YCBCR420)
-		video->color_input = HDMI_COLOR_YCBCR420;
-	else
-		video->color_input = HDMI_COLOR_RGB_0_255;
-
-	if ((hdmi->vic & HDMI_VIDEO_DMT) || (hdmi->vic & HDMI_VIDEO_DISCRETE_VR)) {
-		if (hdmi->edid_auto_support) {
-			if (hdmi->prop.value.vic)
-				video->vic = hdmi->prop.value.vic;
-			else
-				video->vic = hdmi->vic;
-		} else {
-			video->vic = hdmi->vic;
-		}
-		video->color_output_depth = 8;
-		video->eotf = 0;
-	} else {
-		video->vic = hdmi->vic & HDMI_VIC_MASK;
-
-		if (hdmi->eotf & hdmi->edid.hdr.hdrinfo.eotf)
-			video->eotf = hdmi->eotf;
-		else
-			video->eotf = 0;
-		/* ST_2084 must be 10bit and bt2020 */
-		if (video->eotf & EOTF_ST_2084) {
-			if (deepcolor & HDMI_DEEP_COLOR_30BITS)
-				video->color_output_depth = 10;
-			if (video->color_output > HDMI_COLOR_RGB_16_235)
-				video->colorimetry =
-					HDMI_COLORIMETRY_EXTEND_BT_2020_YCC;
-			else
-				video->colorimetry =
-					HDMI_COLORIMETRY_EXTEND_BT_2020_RGB;
-		}
-	}
-	hdmi_check_format(hdmi, video);
-	if (hdmi->uboot) {
-		if ((uboot_vic & HDMI_UBOOT_VIC_MASK) != hdmi->vic)
-			hdmi->uboot = 0;
-	}
-
-	hdmi_set_lcdc(hdmi);
-	if (hdmi->ops->setvideo)
-		hdmi->ops->setvideo(hdmi, video);
-}
-
-static void hdmi_wq_set_hdr(struct hdmi *hdmi)
-{
-	struct hdmi_video *video = &hdmi->video;
-	int deepcolor = 8;
-
-	if (hdmi->vic & HDMI_VIDEO_YUV420)
-		deepcolor = hdmi->edid.deepcolor_420;
-	else
-		deepcolor = hdmi->edid.deepcolor;
-
-	if ((hdmi->property->feature & SUPPORT_DEEP_10BIT) &&
-	    (deepcolor & HDMI_DEEP_COLOR_30BITS) &&
-	     hdmi->colordepth == 10)
-		deepcolor = 10;
-
-	if (deepcolor == video->color_output_depth &&
-	    hdmi->ops->sethdr && hdmi->ops->setavi &&
-	    hdmi->edid.sink_hdmi) {
-		if (hdmi->eotf & hdmi->edid.hdr.hdrinfo.eotf)
-			video->eotf = hdmi->eotf;
-		else
-			video->eotf = 0;
-
-		/* ST_2084 must be 10bit and bt2020 */
-		if (video->eotf & EOTF_ST_2084) {
-			if (video->color_output > HDMI_COLOR_RGB_16_235)
-				video->colorimetry =
-					HDMI_COLORIMETRY_EXTEND_BT_2020_YCC;
-			else
-				video->colorimetry =
-					HDMI_COLORIMETRY_EXTEND_BT_2020_RGB;
-		} else {
-			video->colorimetry = hdmi->colorimetry;
-		}
-		hdmi_set_lcdc(hdmi);
-		hdmi->ops->sethdr(hdmi, hdmi->eotf, &hdmi->hdr);
-		hdmi->ops->setavi(hdmi, video);
-	} else {
-		hdmi_submit_work(hdmi, HDMI_SET_COLOR, 0, 0);
-	}
-}
-
-static void hdmi_wq_parse_edid(struct hdmi *hdmi)
-{
-	struct hdmi_edid *pedid;
-
-	int rc = HDMI_ERROR_SUCCESS, extendblock = 0, i, trytimes;
-
-	if (!hdmi)
-		return;
-
-	HDMIDBG(2, "%s\n", __func__);
-
-	pedid = &hdmi->edid;
-	fb_destroy_modelist(&pedid->modelist);
-	memset(pedid, 0, sizeof(struct hdmi_edid));
-	INIT_LIST_HEAD(&pedid->modelist);
-
-	pedid->raw[0] = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
-	if (!pedid->raw[0]) {
-		rc = HDMI_ERROR_FALSE;
-		goto out;
-	}
-
-	if (!hdmi->ops->getedid) {
-		rc = HDMI_ERROR_FALSE;
-		goto out;
-	}
-
-	/* Read base block edid.*/
-	for (trytimes = 0; trytimes < 3; trytimes++) {
-		if (trytimes)
-			msleep(50);
-		memset(pedid->raw[0], 0, HDMI_EDID_BLOCK_SIZE);
-		rc = hdmi->ops->getedid(hdmi, 0, pedid->raw[0]);
-		if (rc) {
-			dev_err(hdmi->dev,
-				"[HDMI] read edid base block error\n");
-			continue;
-		}
-
-		rc = hdmi_edid_parse_base(hdmi,
-					  pedid->raw[0], &extendblock, pedid);
-		if (rc) {
-			dev_err(hdmi->dev,
-				"[HDMI] parse edid base block error\n");
-			continue;
-		}
-		if (!rc)
-			break;
-	}
-	if (rc)
-		goto out;
-
-	for (i = 1; (i < extendblock + 1) && (i < HDMI_MAX_EDID_BLOCK); i++) {
-		pedid->raw[i] = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
-		if (!pedid->raw[i]) {
-			dev_err(hdmi->dev,
-				"[%s] can not allocate memory for edid buff.\n",
-				__func__);
-			rc = HDMI_ERROR_FALSE;
-			goto out;
-		}
-		for (trytimes = 0; trytimes < 3; trytimes++) {
-			if (trytimes)
-				msleep(20);
-			memset(pedid->raw[i], 0, HDMI_EDID_BLOCK_SIZE);
-			rc = hdmi->ops->getedid(hdmi, i, pedid->raw[i]);
-			if (rc) {
-				dev_err(hdmi->dev,
-					"[HDMI] read edid block %d error\n",
-					i);
-				continue;
-			}
-
-			rc = hdmi_edid_parse_extensions(pedid->raw[i], pedid);
-			if (rc) {
-				dev_err(hdmi->dev,
-					"[HDMI] parse edid block %d error\n",
-					i);
-				continue;
-			}
-
-			if (!rc)
-				break;
-		}
-	}
-out:
-	rc = hdmi_ouputmode_select(hdmi, rc);
-}
-
-static void hdmi_wq_insert(struct hdmi *hdmi)
-{
-	HDMIDBG(2, "%s\n", __func__);
-	if (hdmi->ops->insert)
-		hdmi->ops->insert(hdmi);
-	hdmi_wq_parse_edid(hdmi);
-	if (hdmi->property->feature & SUPPORT_CEC)
-		rockchip_hdmi_cec_set_pa(hdmi->edid.cecaddress);
-	hdmi_send_uevent(hdmi, KOBJ_ADD);
-	if (hdmi->enable) {
-		/*hdmi->autoset = 0;*/
-		hdmi_wq_set_video(hdmi);
-		#ifdef CONFIG_SWITCH
-		switch_set_state(&hdmi->switchdev, 1);
-		#endif
-		hdmi_wq_set_audio(hdmi);
-		hdmi_wq_set_output(hdmi, hdmi->mute);
-		hdmi_submit_work(hdmi, HDMI_ENABLE_HDCP, 100, 0);
-		if (hdmi->ops->setcec)
-			hdmi->ops->setcec(hdmi);
-	}
-	if (hdmi->uboot)
-		hdmi->uboot = 0;
-}
-
-static void hdmi_wq_remove(struct hdmi *hdmi)
-{
-	struct list_head *pos, *n;
-	struct rk_screen screen;
-	int i;
-
-	HDMIDBG(2, "%s\n", __func__);
-	if (hdmi->ops->remove)
-		hdmi->ops->remove(hdmi);
-	if (hdmi->property->feature & SUPPORT_CEC)
-		rockchip_hdmi_cec_set_pa(0);
-	if (hdmi->hotplug == HDMI_HPD_ACTIVATED) {
-		screen.type = SCREEN_HDMI;
-		rk_fb_switch_screen(&screen, 0, hdmi->lcdc->id);
-	}
-	#ifdef CONFIG_SWITCH
-	switch_set_state(&hdmi->switchdev, 0);
-	#endif
-	list_for_each_safe(pos, n, &hdmi->edid.modelist) {
-		list_del(pos);
-		kfree(pos);
-	}
-	for (i = 0; i < HDMI_MAX_EDID_BLOCK; i++)
-		kfree(hdmi->edid.raw[i]);
-	kfree(hdmi->edid.audio);
-	if (hdmi->edid.specs) {
-		kfree(hdmi->edid.specs->modedb);
-		kfree(hdmi->edid.specs);
-	}
-	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
-	hdmi_init_modelist(hdmi);
-	hdmi->mute	= HDMI_AV_UNMUTE;
-	hdmi->mode_3d = HDMI_3D_NONE;
-	hdmi->uboot = 0;
-	hdmi->hotplug = HDMI_HPD_REMOVED;
-	hdmi_send_uevent(hdmi, KOBJ_REMOVE);
-}
-
-static void hdmi_work_queue(struct work_struct *work)
-{
-	struct hdmi_delayed_work *hdmi_w =
-		container_of(work, struct hdmi_delayed_work, work.work);
-	struct hdmi *hdmi = hdmi_w->hdmi;
-	int event = hdmi_w->event;
-	int hpd = HDMI_HPD_REMOVED;
-
-	mutex_lock(&hdmi->ddev->lock);
-
-	HDMIDBG(2, "\nhdmi_work_queue() - evt= %x %d\n",
-		(event & 0xFF00) >> 8, event & 0xFF);
-
-	if ((!hdmi->enable || hdmi->sleep) &&
-	    (event != HDMI_ENABLE_CTL) &&
-	    (event != HDMI_RESUME_CTL) &&
-	    (event != HDMI_DISABLE_CTL) &&
-	    (event != HDMI_SUSPEND_CTL))
-		goto exit;
-
-	switch (event) {
-	case HDMI_ENABLE_CTL:
-		if (!hdmi->enable) {
-			hdmi->enable = 1;
-			if (!hdmi->sleep) {
-				if (hdmi->ops->enable)
-					hdmi->ops->enable(hdmi);
-				if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-					hdmi_wq_insert(hdmi);
-			}
-		}
-		break;
-	case HDMI_RESUME_CTL:
-		if (hdmi->sleep) {
-			if (hdmi->ops->enable)
-				hdmi->ops->enable(hdmi);
-			hdmi->sleep = 0;
-		}
-		break;
-	case HDMI_DISABLE_CTL:
-		if (hdmi->enable) {
-			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-				hdmi_wq_set_output(hdmi,
-						   HDMI_VIDEO_MUTE |
-						   HDMI_AUDIO_MUTE);
-			if (!hdmi->sleep) {
-				if (hdmi->ops->disable)
-					hdmi->ops->disable(hdmi);
-				hdmi_wq_remove(hdmi);
-			}
-			hdmi->enable = 0;
-		}
-		break;
-	case HDMI_SUSPEND_CTL:
-		if (!hdmi->sleep) {
-			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-				hdmi_wq_set_output(hdmi,
-						   HDMI_VIDEO_MUTE |
-						   HDMI_AUDIO_MUTE);
-			if (hdmi->ops->disable)
-				hdmi->ops->disable(hdmi);
-			if (hdmi->enable)
-				hdmi_wq_remove(hdmi);
-			hdmi->sleep = 1;
-		}
-		break;
-	case HDMI_HPD_CHANGE:
-		if (hdmi->ops->getstatus)
-			hpd = hdmi->ops->getstatus(hdmi);
-		HDMIDBG(2, "hdmi_work_queue() - hpd is %d hotplug is %d\n",
-			hpd, hdmi->hotplug);
-		if (hpd != hdmi->hotplug) {
-			if (hpd == HDMI_HPD_ACTIVATED) {
-				hdmi->hotplug = hpd;
-				hdmi_wq_insert(hdmi);
-			} else if (hdmi->hotplug == HDMI_HPD_ACTIVATED) {
-				hdmi_wq_remove(hdmi);
-			}
-			hdmi->hotplug = hpd;
-		}
-		break;
-	case HDMI_SET_VIDEO:
-		hdmi_wq_set_output(hdmi,
-				   HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE);
-		if (rk_fb_get_display_policy() == DISPLAY_POLICY_BOX)
-			msleep(2000);
-		else
-			msleep(1100);
-		hdmi_wq_set_video(hdmi);
-		hdmi_send_uevent(hdmi, KOBJ_CHANGE);
-		hdmi_wq_set_audio(hdmi);
-		hdmi_wq_set_output(hdmi, hdmi->mute);
-		if (hdmi->ops->hdcp_cb)
-			hdmi->ops->hdcp_cb(hdmi);
-		break;
-	case HDMI_SET_AUDIO:
-		if ((hdmi->mute & HDMI_AUDIO_MUTE) == 0) {
-			hdmi_wq_set_output(hdmi, HDMI_AUDIO_MUTE);
-			hdmi_wq_set_audio(hdmi);
-			hdmi_wq_set_output(hdmi, hdmi->mute);
-		}
-		break;
-	case HDMI_MUTE_AUDIO:
-	case HDMI_UNMUTE_AUDIO:
-		if (hdmi->mute & HDMI_AUDIO_MUTE ||
-		    hdmi->hotplug != HDMI_HPD_ACTIVATED)
-			break;
-		if (event == HDMI_MUTE_AUDIO)
-			hdmi_wq_set_output(hdmi, hdmi->mute |
-					   HDMI_AUDIO_MUTE);
-		else
-			hdmi_wq_set_output(hdmi,
-					   hdmi->mute & (~HDMI_AUDIO_MUTE));
-		break;
-	case HDMI_SET_3D:
-		if (hdmi->ops->setvsi && hdmi->edid.sink_hdmi) {
-			if (hdmi->mode_3d == HDMI_3D_FRAME_PACKING ||
-			    hdmi->video.format_3d ==
-			    HDMI_3D_FRAME_PACKING) {
-				hdmi_wq_set_output(hdmi,
-						   HDMI_VIDEO_MUTE |
-						   HDMI_AUDIO_MUTE);
-				msleep(100);
-				hdmi_wq_set_video(hdmi);
-				hdmi_wq_set_audio(hdmi);
-				hdmi_wq_set_output(hdmi, hdmi->mute);
-			} else if (hdmi->mode_3d != HDMI_3D_NONE) {
-				hdmi->ops->setvsi(hdmi, hdmi->mode_3d,
-						  HDMI_VIDEO_FORMAT_3D);
-			} else if ((hdmi->vic & HDMI_TYPE_MASK) == 0) {
-				hdmi->ops->setvsi(hdmi, hdmi->vic,
-						  HDMI_VIDEO_FORMAT_NORMAL);
-			}
-		}
-		break;
-	case HDMI_SET_COLOR:
-		hdmi_wq_set_output(hdmi,
-				   HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE);
-		msleep(100);
-		hdmi_wq_set_video(hdmi);
-		hdmi_wq_set_audio(hdmi);
-		hdmi_wq_set_output(hdmi, hdmi->mute);
-		break;
-	case HDMI_SET_HDR:
-		hdmi_wq_set_hdr(hdmi);
-		break;
-	case HDMI_ENABLE_HDCP:
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED && hdmi->ops->hdcp_cb)
-			hdmi->ops->hdcp_cb(hdmi);
-		break;
-	case HDMI_HDCP_AUTH_2ND:
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED &&
-		    hdmi->ops->hdcp_auth2nd)
-			hdmi->ops->hdcp_auth2nd(hdmi);
-		break;
-	default:
-		break;
-	}
-exit:
-	kfree(hdmi_w->data);
-	if (!hdmi_w->sync)
-		kfree(hdmi_w);
-
-	HDMIDBG(2, "\nhdmi_work_queue() - exit evt= %x %d\n",
-		(event & 0xFF00) >> 8, event & 0xFF);
-	mutex_unlock(&hdmi->ddev->lock);
-}
-
-struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
-				    struct hdmi_ops *ops)
-{
-	struct hdmi *hdmi;
-	char name[32];
-	int i;
-
-	if (!property || !ops) {
-		pr_err("HDMI: %s invalid parameter\n", __func__);
-		return NULL;
-	}
-
-	for (i = 0; i < HDMI_MAX_ID; i++) {
-		if (ref_info[i].ref == 0)
-			break;
-	}
-	if (i == HDMI_MAX_ID)
-		return NULL;
-
-	HDMIDBG(2, "hdmi_register() - video source %d display %d\n",
-		property->videosrc,  property->display);
-
-	hdmi = kmalloc(sizeof(*hdmi), GFP_KERNEL);
-	if (!hdmi)
-		return NULL;
-
-	memset(hdmi, 0, sizeof(struct hdmi));
-	mutex_init(&hdmi->lock);
-	mutex_init(&hdmi->pclk_lock);
-
-	hdmi->property = property;
-	hdmi->ops = ops;
-	hdmi->enable = false;
-	hdmi->mute = HDMI_AV_UNMUTE;
-	hdmi->hotplug = HDMI_HPD_REMOVED;
-	hdmi->autoset = HDMI_AUTO_CONFIG;
-	if (uboot_vic > 0) {
-		hdmi->vic = uboot_vic & HDMI_UBOOT_VIC_MASK;
-		if (uboot_vic & HDMI_UBOOT_NOT_INIT)
-			hdmi->uboot = 0;
-		else
-			hdmi->uboot = 1;
-		hdmi->autoset = 0;
-	} else if (hdmi->autoset) {
-		hdmi->vic = 0;
-	} else {
-		hdmi->vic = hdmi->property->defaultmode;
-	}
-	hdmi->colormode = HDMI_VIDEO_DEFAULT_COLORMODE;
-	hdmi->colordepth = hdmi->property->defaultdepth;
-	hdmi->colorimetry = HDMI_COLORIMETRY_NO_DATA;
-	hdmi->mode_3d = HDMI_3D_NONE;
-	hdmi->audio.type = HDMI_AUDIO_DEFAULT_TYPE;
-	hdmi->audio.channel = HDMI_AUDIO_DEFAULT_CHANNEL;
-	hdmi->audio.rate = HDMI_AUDIO_DEFAULT_RATE;
-	hdmi->audio.word_length = HDMI_AUDIO_DEFAULT_WORDLENGTH;
-	hdmi->xscale = 100;
-	hdmi->yscale = 100;
-
-	if (hdmi->property->videosrc == DISPLAY_SOURCE_LCDC0)
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
-	else
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
-	if (!hdmi->lcdc)
-		goto err_create_wq;
-	if (hdmi->lcdc->prop == EXTEND)
-		hdmi->property->display = DISPLAY_AUX;
-	else
-		hdmi->property->display = DISPLAY_MAIN;
-	memset(name, 0, 32);
-	sprintf(name, "hdmi-%s", hdmi->property->name);
-	hdmi->workqueue = create_singlethread_workqueue(name);
-	if (!hdmi->workqueue) {
-		pr_err("HDMI,: create workqueue failed.\n");
-		goto err_create_wq;
-	}
-	hdmi->ddev = hdmi_register_display_sysfs(hdmi, NULL);
-	if (!hdmi->ddev) {
-		pr_err("HDMI : register display sysfs failed.\n");
-		goto err_register_display;
-	}
-	hdmi->id = i;
-	hdmi_init_modelist(hdmi);
-	#ifdef CONFIG_SWITCH
-	if (hdmi->id == 0) {
-		hdmi->switchdev.name = "hdmi";
-	} else {
-		hdmi->switchdev.name = kzalloc(32, GFP_KERNEL);
-		memset((char *)hdmi->switchdev.name, 0, 32);
-		sprintf((char *)hdmi->switchdev.name, "hdmi%d", hdmi->id);
-	}
-	switch_dev_register(&hdmi->switchdev);
-	#endif
-
-	ref_info[i].hdmi = hdmi;
-	ref_info[i].ref = 1;
-	return hdmi;
-
-err_register_display:
-	destroy_workqueue(hdmi->workqueue);
-err_create_wq:
-	kfree(hdmi);
-	return NULL;
-}
-
-void rockchip_hdmi_unregister(struct hdmi *hdmi)
-{
-	if (hdmi) {
-		flush_workqueue(hdmi->workqueue);
-		destroy_workqueue(hdmi->workqueue);
-		#ifdef CONFIG_SWITCH
-		switch_dev_unregister(&hdmi->switchdev);
-		#endif
-		hdmi_unregister_display_sysfs(hdmi);
-		fb_destroy_modelist(&hdmi->edid.modelist);
-		kfree(hdmi->edid.audio);
-		if (hdmi->edid.specs) {
-			kfree(hdmi->edid.specs->modedb);
-			kfree(hdmi->edid.specs);
-		}
-		ref_info[hdmi->id].ref = 0;
-		ref_info[hdmi->id].hdmi = NULL;
-		kfree(hdmi);
-
-		hdmi = NULL;
-	}
-}
-
-int hdmi_get_hotplug(void)
-{
-	if (ref_info[0].hdmi)
-		return ref_info[0].hdmi->hotplug;
-	else
-		return HDMI_HPD_REMOVED;
-}
-
-int hdmi_config_audio(struct hdmi_audio	*audio)
-{
-	int i;
-	struct hdmi *hdmi;
-
-	if (!audio)
-		return HDMI_ERROR_FALSE;
-
-	for (i = 0; i < HDMI_MAX_ID; i++) {
-		if (ref_info[i].ref == 0)
-			continue;
-		hdmi = ref_info[i].hdmi;
-		memcpy(&hdmi->audio, audio, sizeof(struct hdmi_audio));
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-			hdmi_submit_work(hdmi, HDMI_SET_AUDIO, 0, 0);
-	}
-	return 0;
-}
-
-int snd_config_hdmi_audio(struct snd_pcm_hw_params *params)
-{
-	struct hdmi_audio audio_cfg;
-	u32	rate;
-
-	switch (params_rate(params)) {
-	case 32000:
-		rate = HDMI_AUDIO_FS_32000;
-		break;
-	case 44100:
-		rate = HDMI_AUDIO_FS_44100;
-		break;
-	case 48000:
-		rate = HDMI_AUDIO_FS_48000;
-		break;
-	case 88200:
-		rate = HDMI_AUDIO_FS_88200;
-		break;
-	case 96000:
-		rate = HDMI_AUDIO_FS_96000;
-		break;
-	case 176400:
-		rate = HDMI_AUDIO_FS_176400;
-		break;
-	case 192000:
-		rate = HDMI_AUDIO_FS_192000;
-		break;
-	default:
-		pr_err("rate %d unsupport.\n", params_rate(params));
-		rate = HDMI_AUDIO_FS_44100;
-	}
-
-	audio_cfg.rate = rate;
-
-	if (params->flags == HW_PARAMS_FLAG_NLPCM)
-		audio_cfg.type = HDMI_AUDIO_NLPCM;
-	else
-		audio_cfg.type = HDMI_AUDIO_LPCM;
-
-	audio_cfg.channel = params_channels(params);
-	audio_cfg.word_length = HDMI_AUDIO_WORD_LENGTH_16bit;
-
-	return hdmi_config_audio(&audio_cfg);
-}
-EXPORT_SYMBOL(snd_config_hdmi_audio);
-
-void hdmi_audio_mute(int mute)
-{
-	int i;
-	struct hdmi *hdmi;
-
-	for (i = 0; i < HDMI_MAX_ID; i++) {
-		if (ref_info[i].ref == 0)
-			continue;
-		hdmi = ref_info[i].hdmi;
-
-		if (mute)
-			hdmi_submit_work(hdmi, HDMI_MUTE_AUDIO, 0, 0);
-		else
-			hdmi_submit_work(hdmi, HDMI_UNMUTE_AUDIO, 0, 0);
-	}
-}
-
-static int __init bootloader_setup(char *str)
-{
-	if (str) {
-		pr_info("hdmi init vic is %s\n", str);
-		if (kstrtoint(str, 0, &uboot_vic) < 0)
-			uboot_vic = 0;
-	}
-	return 0;
-}
-
-early_param("hdmi.vic", bootloader_setup);
-
-static int __init hdmi_class_init(void)
-{
-	int i;
-
-	for (i = 0; i < HDMI_MAX_ID; i++) {
-		ref_info[i].id = i;
-		ref_info[i].ref = 0;
-		ref_info[i].hdmi = NULL;
-	}
-	pr_info("Rockchip hdmi driver version 2.0\n.");
-	return 0;
-}
-
-subsys_initcall(hdmi_class_init);
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
deleted file mode 100644
index d99be01bb8bd..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
+++ /dev/null
@@ -1,560 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include "rockchip-hdmi.h"
-#include "../../fbdev/edid.h"
-
-#ifdef EDIDDEBUG
-#define EDBG	DBG
-#else
-#define EDBG(format, ...)
-#endif
-
-enum {
-	E_HDMI_EDID_SUCCESS = 0,
-	E_HDMI_EDID_PARAM,
-	E_HDMI_EDID_HEAD,
-	E_HDMI_EDID_CHECKSUM,
-	E_HDMI_EDID_VERSION,
-	E_HDMI_EDID_UNKOWNDATA,
-	E_HDMI_EDID_NOMEMORY
-};
-
-static int hdmi_edid_checksum(unsigned char *buf)
-{
-	int i;
-	int checksum = 0;
-
-	for (i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
-		checksum += buf[i];
-
-	checksum &= 0xff;
-
-	if (checksum == 0)
-		return E_HDMI_EDID_SUCCESS;
-	else
-		return E_HDMI_EDID_CHECKSUM;
-}
-
-/*
- *	@Des	Parse Detail Timing Descriptor.
- *	@Param	buf	:	pointer to DTD data.
- *	@Param	pvic:	VIC of DTD descripted.
- */
-static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
-{
-	mode->xres = H_ACTIVE;
-	mode->yres = V_ACTIVE;
-	mode->pixclock = PIXEL_CLOCK;
-	mode->right_margin = H_SYNC_OFFSET;
-	mode->left_margin = (H_ACTIVE + H_BLANKING) -
-		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
-	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
-		V_SYNC_WIDTH;
-	mode->lower_margin = V_SYNC_OFFSET;
-	mode->hsync_len = H_SYNC_WIDTH;
-	mode->vsync_len = V_SYNC_WIDTH;
-	if (HSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
-	if (VSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
-	mode->refresh = PIXEL_CLOCK / ((H_ACTIVE + H_BLANKING) *
-				       (V_ACTIVE + V_BLANKING));
-	if (INTERLACED) {
-		mode->yres *= 2;
-		mode->upper_margin *= 2;
-		mode->lower_margin *= 2;
-		mode->vsync_len *= 2;
-		mode->vmode |= FB_VMODE_INTERLACED;
-	}
-	mode->flag = FB_MODE_IS_DETAILED;
-
-	EDBG("<<<<<<<<Detailed Time>>>>>>>>>\n");
-	EDBG("%d KHz Refresh %d Hz",
-	     PIXEL_CLOCK / 1000, mode->refresh);
-	EDBG("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
-	     H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
-	EDBG("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
-	     V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
-	EDBG("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
-	     (VSYNC_POSITIVE) ? "+" : "-");
-	return E_HDMI_EDID_SUCCESS;
-}
-
-static int edid_parse_prop_value(unsigned char *buf,
-				 struct hdmi_edid *pedid)
-{
-	unsigned char *block = &buf[0x36];
-
-	pedid->value.vid = ((buf[ID_MANUFACTURER_NAME_END] << 8) |
-				(buf[ID_MANUFACTURER_NAME]));
-	pedid->value.pid = ((buf[ID_MODEL + 1] << 8) |
-				(buf[ID_MODEL]));
-	pedid->value.sn = ((buf[ID_SERIAL_NUMBER + 3] << 24) |
-				(buf[ID_SERIAL_NUMBER + 2] << 16) |
-				(buf[ID_SERIAL_NUMBER + 1] << 8) |
-				buf[ID_SERIAL_NUMBER]);
-	pedid->value.xres = H_ACTIVE;
-	pedid->value.yres = V_ACTIVE;
-
-	pr_info("%s:read:vid=0x%x,pid=0x%x,sn=0x%x,xres=%d,yres=%d\n",
-		__func__, pedid->value.vid, pedid->value.pid,
-		pedid->value.sn, pedid->value.xres, pedid->value.yres);
-
-	return 0;
-}
-
-int hdmi_edid_parse_base(struct hdmi *hdmi, unsigned char *buf,
-			 int *extend_num, struct hdmi_edid *pedid)
-{
-	int rc = E_HDMI_EDID_SUCCESS;
-
-	if (!buf || !extend_num)
-		return E_HDMI_EDID_PARAM;
-
-	*extend_num = buf[0x7e];
-	#ifdef DEBUG
-	EDBG("[EDID] extend block num is %d\n", buf[0x7e]);
-	#endif
-
-	/* Check first 8 byte to ensure it is an edid base block. */
-	if (buf[0] != 0x00 ||
-	    buf[1] != 0xFF ||
-	    buf[2] != 0xFF ||
-	    buf[3] != 0xFF ||
-	    buf[4] != 0xFF ||
-	    buf[5] != 0xFF ||
-	    buf[6] != 0xFF ||
-	    buf[7] != 0x00) {
-		pr_err("[EDID] check header error\n");
-		rc = E_HDMI_EDID_HEAD;
-		goto out;
-	}
-
-	/* Checksum */
-	rc = hdmi_edid_checksum(buf);
-	if (rc != E_HDMI_EDID_SUCCESS) {
-		pr_err("[EDID] base block checksum error\n");
-		rc = E_HDMI_EDID_CHECKSUM;
-		goto out;
-	}
-
-	pedid->specs = kzalloc(sizeof(*pedid->specs), GFP_KERNEL);
-	if (!pedid->specs)
-		return E_HDMI_EDID_NOMEMORY;
-
-	fb_edid_to_monspecs(buf, pedid->specs);
-
-	if (hdmi->edid_auto_support)
-		edid_parse_prop_value(buf, pedid);
-
-out:
-	/* For some sink, edid checksum is failed because several
-	 * byte is wrong. To fix this case, we think it is a good
-	 * edid if 1 <= *extend_num <= 4.
-	 */
-	if ((rc != E_HDMI_EDID_SUCCESS) &&
-	    (*extend_num < 1 || *extend_num > 4))
-		return rc;
-	else
-		return E_HDMI_EDID_SUCCESS;
-}
-
-/* Parse CEA Short Video Descriptor */
-static int hdmi_edid_get_cea_svd(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	int count, i, vic;
-
-	count = buf[0] & 0x1F;
-	for (i = 0; i < count; i++) {
-		EDBG("[CEA] %02x VID %d native %d\n",
-		     buf[1 + i], buf[1 + i] & 0x7f, buf[1 + i] >> 7);
-		vic = buf[1 + i] & 0x7f;
-		hdmi_add_vic(vic, &pedid->modelist);
-	}
-	return 0;
-}
-
-/* Parse CEA Short Audio Descriptor */
-static int hdmi_edid_parse_cea_sad(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	int i, count;
-
-	count = buf[0] & 0x1F;
-	pedid->audio = kmalloc((count / 3) * sizeof(struct hdmi_audio),
-			       GFP_KERNEL);
-	if (!pedid->audio)
-		return E_HDMI_EDID_NOMEMORY;
-
-	pedid->audio_num = count / 3;
-	for (i = 0; i < pedid->audio_num; i++) {
-		pedid->audio[i].type = (buf[1 + i * 3] >> 3) & 0x0F;
-		pedid->audio[i].channel = (buf[1 + i * 3] & 0x07) + 1;
-		pedid->audio[i].rate = buf[1 + i * 3 + 1];
-		if (pedid->audio[i].type == HDMI_AUDIO_LPCM)
-			pedid->audio[i].word_length = buf[1 + i * 3 + 2];
-	}
-	return E_HDMI_EDID_SUCCESS;
-}
-
-static int hdmi_edid_parse_3dinfo(unsigned char *buf, struct list_head *head)
-{
-	int i, j, len = 0, format_3d, vic_mask;
-	unsigned char offset = 2, vic_2d, structure_3d;
-	struct list_head *pos;
-	struct display_modelist *modelist;
-
-	if (buf[1] & 0xe0) {
-		len = (buf[1] & 0xe0) >> 5;
-		for (i = 0; i < len; i++) {
-			if (buf[offset]) {
-				vic_2d = (buf[offset] == 4) ?
-					 98 : (96 - buf[offset]);
-				hdmi_add_vic(vic_2d, head);
-			}
-			offset++;
-		}
-	}
-
-	if (buf[0] & 0x80) {
-		/* 3d supported */
-		len += (buf[1] & 0x1F) + 2;
-		if (((buf[0] & 0x60) == 0x40) || ((buf[0] & 0x60) == 0x20)) {
-			format_3d = buf[offset++] << 8;
-			format_3d |= buf[offset++];
-			if ((buf[0] & 0x60) == 0x20) {
-				vic_mask = 0xFFFF;
-			} else {
-				vic_mask  = buf[offset++] << 8;
-				vic_mask |= buf[offset++];
-			}
-		} else {
-			format_3d = 0;
-			vic_mask = 0;
-		}
-
-		for (i = 0; i < 16; i++) {
-			if (vic_mask & (1 << i)) {
-				j = 0;
-				for (pos = (head)->next; pos != (head);
-					pos = pos->next) {
-					if (j++ == i) {
-						modelist =
-			list_entry(pos, struct display_modelist, list);
-						modelist->format_3d = format_3d;
-						break;
-					}
-				}
-			}
-		}
-		while (offset < len) {
-			vic_2d = (buf[offset] & 0xF0) >> 4;
-			structure_3d = (buf[offset++] & 0x0F);
-			j = 0;
-			for (pos = (head)->next; pos != (head);
-				pos = pos->next) {
-				j++;
-				if (j == vic_2d) {
-					modelist =
-				list_entry(pos, struct display_modelist, list);
-					modelist->format_3d |=
-						(1 << structure_3d);
-					if (structure_3d & 0x08)
-						modelist->detail_3d =
-						(buf[offset++] & 0xF0) >> 4;
-					break;
-				}
-			}
-		}
-		/* mandatory formats */
-		for (pos = (head)->next; pos != (head); pos = pos->next) {
-			modelist = list_entry(pos,
-					      struct display_modelist,
-					      list);
-			if (modelist->vic == HDMI_1920X1080P_24HZ ||
-			    modelist->vic == HDMI_1280X720P_60HZ ||
-			    modelist->vic == HDMI_1280X720P_50HZ) {
-				modelist->format_3d |=
-					(1 << HDMI_3D_FRAME_PACKING) |
-					(1 << HDMI_3D_TOP_BOOTOM);
-			} else if (modelist->vic == HDMI_1920X1080I_60HZ ||
-				   modelist->vic == HDMI_1920X1080I_50HZ) {
-				modelist->format_3d |=
-					(1 << HDMI_3D_SIDE_BY_SIDE_HALF);
-			}
-		}
-	}
-
-	return 0;
-}
-
-static int hdmi_edmi_parse_vsdb(unsigned char *buf, struct hdmi_edid *pedid,
-				int cur_offset, int IEEEOUI)
-{
-	int count, buf_offset;
-
-	count = buf[cur_offset] & 0x1F;
-	switch (IEEEOUI) {
-	case 0x0c03:
-		pedid->sink_hdmi = 1;
-		pedid->cecaddress = buf[cur_offset + 5];
-		pedid->cecaddress |= buf[cur_offset + 4] << 8;
-		EDBG("[CEA] CEC Physical address is 0x%08x.\n",
-		     pedid->cecaddress);
-		if (count > 6)
-			pedid->deepcolor = (buf[cur_offset + 6] >> 3) & 0x0F;
-		if (count > 7) {
-			pedid->maxtmdsclock = buf[cur_offset + 7] * 5000000;
-			EDBG("[CEA] maxtmdsclock is %d.\n",
-			     pedid->maxtmdsclock);
-		}
-		if (count > 8) {
-			pedid->fields_present = buf[cur_offset + 8];
-			EDBG("[CEA] fields_present is 0x%02x.\n",
-			     pedid->fields_present);
-		}
-		buf_offset = cur_offset + 9;
-		if (pedid->fields_present & 0x80) {
-			pedid->video_latency = buf[buf_offset++];
-			pedid->audio_latency = buf[buf_offset++];
-		}
-		if (pedid->fields_present & 0x40) {
-			pedid->interlaced_video_latency = buf[buf_offset++];
-			pedid->interlaced_audio_latency = buf[buf_offset++];
-		}
-		if (pedid->fields_present & 0x20) {
-			hdmi_edid_parse_3dinfo(buf + buf_offset,
-					       &pedid->modelist);
-		}
-		break;
-	case 0xc45dd8:
-		pedid->sink_hdmi = 1;
-		pedid->hf_vsdb_version = buf[cur_offset + 4];
-		switch (pedid->hf_vsdb_version) {
-		case 1:/*compliant with HDMI Specification 2.0*/
-			pedid->maxtmdsclock =
-				buf[cur_offset + 5] * 5000000;
-			EDBG("[CEA] maxtmdsclock is %d.\n",
-			     pedid->maxtmdsclock);
-			pedid->scdc_present = buf[cur_offset + 6] >> 7;
-			pedid->rr_capable =
-				(buf[cur_offset + 6] & 0x40) >> 6;
-			pedid->lte_340mcsc_scramble =
-				(buf[cur_offset + 6] & 0x08) >> 3;
-			pedid->independent_view =
-				(buf[cur_offset + 6] & 0x04) >> 2;
-			pedid->dual_view =
-				(buf[cur_offset + 6] & 0x02) >> 1;
-			pedid->osd_disparity_3d =
-				buf[cur_offset + 6] & 0x01;
-			pedid->deepcolor_420 =
-				(buf[cur_offset + 7] & 0x7) << 1;
-			break;
-		default:
-			pr_info("hf_vsdb_version = %d\n",
-				pedid->hf_vsdb_version);
-			break;
-		}
-		break;
-	default:
-		pr_info("IEEOUT = 0x%x\n", IEEEOUI);
-		break;
-	}
-	return 0;
-}
-
-static void hdmi_edid_parse_yuv420cmdb(unsigned char *buf, int count,
-				       struct list_head *head)
-{
-	struct list_head *pos;
-	struct display_modelist *modelist;
-	int i, j, yuv420_mask = 0, vic;
-
-	if (count == 1) {
-		list_for_each(pos, head) {
-			modelist =
-				list_entry(pos, struct display_modelist, list);
-			vic = modelist->vic | HDMI_VIDEO_YUV420;
-			hdmi_add_vic(vic, head);
-		}
-	} else {
-		for (i = 0; i < count - 1; i++) {
-			EDBG("vic which support yuv420 mode is %x\n", buf[i]);
-			yuv420_mask |= buf[i] << (8 * i);
-		}
-		for (i = 0; i < 32; i++) {
-			if (!(yuv420_mask & (1 << i)))
-				continue;
-			j = 0;
-			list_for_each(pos, head) {
-				if (j++ == i) {
-					modelist =
-				list_entry(pos, struct display_modelist, list);
-					vic = modelist->vic |
-					      HDMI_VIDEO_YUV420;
-					hdmi_add_vic(vic, head);
-					break;
-				}
-			}
-		}
-	}
-}
-
-/* Parse CEA 861 Serial Extension. */
-static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
-					  struct hdmi_edid *pedid)
-{
-	unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
-	unsigned int tag, IEEEOUI = 0, count, i;
-	struct fb_videomode *vmode;
-
-	if (!buf)
-		return E_HDMI_EDID_PARAM;
-
-	/* Check ces extension version */
-	if (buf[1] != 3) {
-		pr_err("[CEA] error version.\n");
-		return E_HDMI_EDID_VERSION;
-	}
-
-	ddc_offset = buf[2];
-	pedid->baseaudio_support = (buf[3] >> 6) & 0x01;
-	pedid->ycbcr444 = (buf[3] >> 5) & 0x01;
-	pedid->ycbcr422 = (buf[3] >> 4) & 0x01;
-	native_dtd_num = buf[3] & 0x0F;
-	/* Parse data block */
-	while (cur_offset < ddc_offset) {
-		tag = buf[cur_offset] >> 5;
-		count = buf[cur_offset] & 0x1F;
-		switch (tag) {
-		case 0x02:	/* Video Data Block */
-			EDBG("[CEA] Video Data Block.\n");
-			hdmi_edid_get_cea_svd(buf + cur_offset, pedid);
-			break;
-		case 0x01:	/* Audio Data Block */
-			EDBG("[CEA] Audio Data Block.\n");
-			hdmi_edid_parse_cea_sad(buf + cur_offset, pedid);
-			break;
-		case 0x04:	/* Speaker Allocation Data Block */
-			EDBG("[CEA] Speaker Allocatio Data Block.\n");
-			break;
-		case 0x03:	/* Vendor Specific Data Block */
-			EDBG("[CEA] Vendor Specific Data Block.\n");
-
-			IEEEOUI = buf[cur_offset + 3];
-			IEEEOUI <<= 8;
-			IEEEOUI += buf[cur_offset + 2];
-			IEEEOUI <<= 8;
-			IEEEOUI += buf[cur_offset + 1];
-			EDBG("[CEA] IEEEOUI is 0x%08x.\n", IEEEOUI);
-
-			hdmi_edmi_parse_vsdb(buf, pedid,
-					     cur_offset, IEEEOUI);
-			break;
-		case 0x05:	/* VESA DTC Data Block */
-			EDBG("[CEA] VESA DTC Data Block.\n");
-			break;
-		case 0x07:	/* Use Extended Tag */
-			EDBG("[CEA] Use Extended Tag Data Block %02x.\n",
-			     buf[cur_offset + 1]);
-			switch (buf[cur_offset + 1]) {
-			case 0x00:
-				EDBG("[CEA] Video Capability Data Block\n");
-				EDBG("value is %02x\n", buf[cur_offset + 2]);
-				break;
-			case 0x05:
-				EDBG("[CEA] Colorimetry Data Block\n");
-				EDBG("value is %02x\n", buf[cur_offset + 2]);
-				pedid->colorimetry = buf[cur_offset + 2];
-				break;
-			case 0x06:
-				EDBG("[CEA] HDR Static Metedata data Block\n");
-				for (i = 0; i < count - 1; i++)
-					pedid->hdr.data[i] =
-						buf[cur_offset + 2 + i];
-				break;
-			case 0x0e:
-				EDBG("[CEA] YCBCR 4:2:0 Video Data Block\n");
-				for (i = 0; i < count - 1; i++) {
-					EDBG("mode is %d\n",
-					     buf[cur_offset + 2 + i]);
-					pedid->ycbcr420 = 1;
-					IEEEOUI = buf[cur_offset + 2 + i] |
-						  HDMI_VIDEO_YUV420;
-					hdmi_add_vic(IEEEOUI,
-						     &pedid->modelist);
-				}
-				break;
-			case 0x0f:
-				EDBG("[CEA] YCBCR 4:2:0 Capability Map Data\n");
-				hdmi_edid_parse_yuv420cmdb(&buf[cur_offset + 2],
-							   count,
-							   &pedid->modelist);
-				pedid->ycbcr420 = 1;
-				break;
-			}
-			break;
-		default:
-			pr_err("[CEA] unkowned data block tag.\n");
-			break;
-		}
-		cur_offset += (buf[cur_offset] & 0x1F) + 1;
-	}
-
-	/* Parse DTD */
-	vmode = kmalloc(sizeof(*vmode), GFP_KERNEL);
-
-	if (!vmode)
-		return E_HDMI_EDID_SUCCESS;
-	while (ddc_offset < HDMI_EDID_BLOCK_SIZE - 2) {
-		if (!buf[ddc_offset] && !buf[ddc_offset + 1])
-			break;
-		memset(vmode, 0, sizeof(struct fb_videomode));
-		hdmi_edid_parse_dtd(buf + ddc_offset, vmode);
-		hdmi_add_vic(hdmi_videomode_to_vic(vmode), &pedid->modelist);
-		ddc_offset += 18;
-	}
-	kfree(vmode);
-
-	return E_HDMI_EDID_SUCCESS;
-}
-
-int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	int rc;
-
-	if (!buf || !pedid)
-		return E_HDMI_EDID_PARAM;
-
-	/* Checksum */
-	rc = hdmi_edid_checksum(buf);
-	if (rc != E_HDMI_EDID_SUCCESS) {
-		pr_err("[EDID] extensions block checksum error\n");
-		return E_HDMI_EDID_CHECKSUM;
-	}
-
-	switch (buf[0]) {
-	case 0xF0:
-		EDBG("[EDID-EXTEND] Iextensions block map.\n");
-		break;
-	case 0x02:
-		EDBG("[EDID-EXTEND] CEA 861 Series Extension.\n");
-		hdmi_edid_parse_extensions_cea(buf, pedid);
-		break;
-	case 0x10:
-		EDBG("[EDID-EXTEND] Video Timing Block Extension.\n");
-		break;
-	case 0x40:
-		EDBG("[EDID-EXTEND] Display Information Extension.\n");
-		break;
-	case 0x50:
-		EDBG("[EDID-EXTEND] Localized String Extension.\n");
-		break;
-	case 0x60:
-		EDBG("[EDID-EXTEND] Digital Packet Video Link Extension.\n");
-		break;
-	default:
-		pr_err("[EDID-EXTEND] Unkowned Extension.\n");
-		return E_HDMI_EDID_UNKOWNDATA;
-	}
-
-	return E_HDMI_EDID_SUCCESS;
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
deleted file mode 100644
index 49b6d3547583..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
+++ /dev/null
@@ -1,1597 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include "rockchip-hdmi.h"
-
-static const struct hdmi_video_timing hdmi_mode[] = {
-	{
-		.mode = {
-			.name = "720x480i@60Hz",
-			.refresh = 60,
-			.xres = 720,
-			.yres = 480,
-			.pixclock = 27000000,
-			.left_margin = 57,
-			.right_margin = 19,
-			.upper_margin = 15,
-			.lower_margin = 4,
-			.hsync_len = 62,
-			.vsync_len = 3,
-			.sync = 0,
-			.vmode = FB_VMODE_INTERLACED,
-			.flag = 0,
-		},
-		.vic = HDMI_720X480I_60HZ_4_3,
-		.vic_2nd = HDMI_720X480I_60HZ_16_9,
-		.pixelrepeat = 2,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "720x576i@50Hz",
-			.refresh = 50,
-			.xres = 720,
-			.yres = 576,
-			.pixclock = 27000000,
-			.left_margin = 69,
-			.right_margin = 12,
-			.upper_margin = 19,
-			.lower_margin = 2,
-			.hsync_len = 63,
-			.vsync_len = 3,
-			.sync = 0,
-			.vmode = FB_VMODE_INTERLACED,
-			.flag = 0,
-		},
-		.vic = HDMI_720X576I_50HZ_4_3,
-		.vic_2nd = HDMI_720X576I_50HZ_16_9,
-		.pixelrepeat = 2,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "720x480p@60Hz",
-			.refresh = 60,
-			.xres = 720,
-			.yres = 480,
-			.pixclock = 27000000,
-			.left_margin = 60,
-			.right_margin = 16,
-			.upper_margin = 30,
-			.lower_margin = 9,
-			.hsync_len = 62,
-			.vsync_len = 6,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_720X480P_60HZ_4_3,
-		.vic_2nd = HDMI_720X480P_60HZ_16_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "720x576p@50Hz",
-			.refresh = 50,
-			.xres = 720,
-			.yres = 576,
-			.pixclock = 27000000,
-			.left_margin = 68,
-			.right_margin = 12,
-			.upper_margin = 39,
-			.lower_margin = 5,
-			.hsync_len = 64,
-			.vsync_len = 5,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_720X576P_50HZ_4_3,
-		.vic_2nd = HDMI_720X576P_50HZ_16_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x720p@24Hz",
-			.refresh = 24,
-			.xres = 1280,
-			.yres = 720,
-			.pixclock = 59400000,
-			.left_margin = 220,
-			.right_margin = 1760,
-			.upper_margin = 20,
-			.lower_margin = 5,
-			.hsync_len = 40,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1280X720P_24HZ,
-		.vic_2nd = HDMI_1280X720P_24HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x720p@25Hz",
-			.refresh = 25,
-			.xres = 1280,
-			.yres = 720,
-			.pixclock = 74250000,
-			.left_margin = 220,
-			.right_margin = 2420,
-			.upper_margin = 20,
-			.lower_margin = 5,
-			.hsync_len = 40,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1280X720P_25HZ,
-		.vic_2nd = HDMI_1280X720P_25HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x720p@30Hz",
-			.refresh = 30,
-			.xres = 1280,
-			.yres = 720,
-			.pixclock = 74250000,
-			.left_margin = 220,
-			.right_margin = 1760,
-			.upper_margin = 20,
-			.lower_margin = 5,
-			.hsync_len = 40,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1280X720P_30HZ,
-		.vic_2nd = HDMI_1280X720P_30HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x720p@50Hz",
-			.refresh = 50,
-			.xres = 1280,
-			.yres = 720,
-			.pixclock = 74250000,
-			.left_margin = 220,
-			.right_margin = 440,
-			.upper_margin = 20,
-			.lower_margin = 5,
-			.hsync_len = 40,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1280X720P_50HZ,
-		.vic_2nd = HDMI_1280X720P_50HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x720p@60Hz",
-			.refresh = 60,
-			.xres = 1280,
-			.yres = 720,
-			.pixclock = 74250000,
-			.left_margin = 220,
-			.right_margin = 110,
-			.upper_margin = 20,
-			.lower_margin = 5,
-			.hsync_len = 40,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1280X720P_60HZ,
-		.vic_2nd = HDMI_1280X720P_60HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080i@50Hz",
-			.refresh = 50,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 74250000,
-			.left_margin = 148,
-			.right_margin = 528,
-			.upper_margin = 15,
-			.lower_margin = 2,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = FB_VMODE_INTERLACED,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080I_50HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080i@60Hz",
-			.refresh = 60,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 74250000,
-			.left_margin = 148,
-			.right_margin = 88,
-			.upper_margin = 15,
-			.lower_margin = 2,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = FB_VMODE_INTERLACED,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080I_60HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080p@24Hz",
-			.refresh = 24,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 74250000,
-			.left_margin = 148,
-			.right_margin = 638,
-			.upper_margin = 36,
-			.lower_margin = 4,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080P_24HZ,
-		.vic_2nd = HDMI_1920X1080P_24HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080p@25Hz",
-			.refresh = 25,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 74250000,
-			.left_margin = 148,
-			.right_margin = 528,
-			.upper_margin = 36,
-			.lower_margin = 4,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080P_25HZ,
-		.vic_2nd = HDMI_1920X1080P_25HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080p@30Hz",
-			.refresh = 30,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 74250000,
-			.left_margin = 148,
-			.right_margin = 88,
-			.upper_margin = 36,
-			.lower_margin = 4,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080P_30HZ,
-		.vic_2nd = HDMI_1920X1080P_30HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080p@50Hz",
-			.refresh = 50,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 148500000,
-			.left_margin = 148,
-			.right_margin = 528,
-			.upper_margin = 36,
-			.lower_margin = 4,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080P_50HZ,
-		.vic_2nd = HDMI_1920X1080P_50HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1920x1080p@60Hz",
-			.refresh = 60,
-			.xres = 1920,
-			.yres = 1080,
-			.pixclock = 148500000,
-			.left_margin = 148,
-			.right_margin = 88,
-			.upper_margin = 36,
-			.lower_margin = 4,
-			.hsync_len = 44,
-			.vsync_len = 5,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_1920X1080P_60HZ,
-		.vic_2nd = HDMI_1920X1080P_60HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "3840x2160p@24Hz",
-			.refresh = 24,
-			.xres = 3840,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 296,
-			.right_margin = 1276,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_3840X2160P_24HZ,
-		.vic_2nd = HDMI_3840X2160P_24HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "3840x2160p@25Hz",
-			.refresh = 25,
-			.xres = 3840,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 296,
-			.right_margin = 1056,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_3840X2160P_25HZ,
-		.vic_2nd = HDMI_3840X2160P_25HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "3840x2160p@30Hz",
-			.refresh = 30,
-			.xres = 3840,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 296,
-			.right_margin = 176,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_3840X2160P_30HZ,
-		.vic_2nd = HDMI_3840X2160P_30HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "4096x2160p@24Hz",
-			.refresh = 24,
-			.xres = 4096,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 296,
-			.right_margin = 1020,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_4096X2160P_24HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "4096x2160p@25Hz",
-			.refresh = 25,
-			.xres = 4096,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 128,
-			.right_margin = 968,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_4096X2160P_25HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "4096x2160p@30Hz",
-			.refresh = 30,
-			.xres = 4096,
-			.yres = 2160,
-			.pixclock = 297000000,
-			.left_margin = 128,
-			.right_margin = 88,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_4096X2160P_30HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "3840x2160p@50Hz",
-			.refresh = 50,
-			.xres = 3840,
-			.yres = 2160,
-			.pixclock = 594000000,
-			.left_margin = 296,
-			.right_margin = 1056,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_3840X2160P_50HZ,
-		.vic_2nd = HDMI_3840X2160P_50HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "3840x2160p@60Hz",
-			.refresh = 60,
-			.xres = 3840,
-			.yres = 2160,
-			.pixclock = 594000000,
-			.left_margin = 296,
-			.right_margin = 176,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_3840X2160P_60HZ,
-		.vic_2nd = HDMI_3840X2160P_60HZ_21_9,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "4096x2160p@50Hz",
-			.refresh = 50,
-			.xres = 4096,
-			.yres = 2160,
-			.pixclock = 594000000,
-			.left_margin = 128,
-			.right_margin = 968,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_4096X2160P_50HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "4096x2160p@60Hz",
-			.refresh = 60,
-			.xres = 4096,
-			.yres = 2160,
-			.pixclock = 594000000,
-			.left_margin = 128,
-			.right_margin = 88,
-			.upper_margin = 72,
-			.lower_margin = 8,
-			.hsync_len = 88,
-			.vsync_len = 10,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_4096X2160P_60HZ,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "800x600p@60Hz",
-			.refresh = 60,
-			.xres = 800,
-			.yres = 600,
-			.pixclock = 40000000,
-			.left_margin = 88,
-			.right_margin = 40,
-			.upper_margin = 23,
-			.lower_margin = 1,
-			.hsync_len = 128,
-			.vsync_len = 4,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 1,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1024x768p@60Hz",
-			.refresh = 60,
-			.xres = 1024,
-			.yres = 768,
-			.pixclock = 65000000,
-			.left_margin = 160,
-			.right_margin = 24,
-			.upper_margin = 29,
-			.lower_margin = 3,
-			.hsync_len = 136,
-			.vsync_len = 6,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 2,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x960p@60Hz",
-			.refresh = 60,
-			.xres = 1280,
-			.yres = 960,
-			.pixclock = 108000000,
-			.left_margin = 312,
-			.right_margin = 96,
-			.upper_margin = 36,
-			.lower_margin = 1,
-			.hsync_len = 112,
-			.vsync_len = 3,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 3,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1280x1024p@60Hz",
-			.refresh = 60,
-			.xres = 1280,
-			.yres = 1024,
-			.pixclock = 108000000,
-			.left_margin = 248,
-			.right_margin = 48,
-			.upper_margin = 38,
-			.lower_margin = 1,
-			.hsync_len = 112,
-			.vsync_len = 3,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 4,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1360x768p@60Hz",
-			.refresh = 60,
-			.xres = 1360,
-			.yres = 768,
-			.pixclock = 85500000,
-			.left_margin = 256,
-			.right_margin = 64,
-			.upper_margin = 18,
-			.lower_margin = 3,
-			.hsync_len = 112,
-			.vsync_len = 6,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 5,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1366x768p@60Hz",
-			.refresh = 60,
-			.xres = 1366,
-			.yres = 768,
-			.pixclock = 85500000,
-			.left_margin = 213,
-			.right_margin = 70,
-			.upper_margin = 24,
-			.lower_margin = 3,
-			.hsync_len = 143,
-			.vsync_len = 3,
-			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 6,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1440x900p@60Hz",
-			.refresh = 60,
-			.xres = 1440,
-			.yres = 900,
-			.pixclock = 106500000,
-			.left_margin = 232,
-			.right_margin = 80,
-			.upper_margin = 25,
-			.lower_margin = 3,
-			.hsync_len = 152,
-			.vsync_len = 6,
-			.sync = FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 7,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1600x900p@60Hz",
-			.refresh = 60,
-			.xres = 1600,
-			.yres = 900,
-			.pixclock = 108000000,
-			.left_margin = 96,
-			.right_margin = 24,
-			.upper_margin = 96,
-			.lower_margin = 1,
-			.hsync_len = 80,
-			.vsync_len = 3,
-			.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 8,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1680x1050@60Hz",
-			.refresh = 60,
-			.xres = 1680,
-			.yres = 1050,
-			.pixclock = 146250000,
-			.left_margin = 280,
-			.right_margin = 104,
-			.upper_margin = 30,
-			.lower_margin = 3,
-			.hsync_len = 176,
-			.vsync_len = 6,
-			.sync = FB_SYNC_VERT_HIGH_ACT,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DMT | 9,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		.mode = {
-			.name = "1440x1280@60Hz",
-			.refresh = 60,
-			.xres = 1440,
-			.yres = 1280,
-			.pixclock = 148500000,
-			.left_margin = 84,
-			.right_margin = 360,
-			.upper_margin = 8,
-			.lower_margin = 10,
-			.hsync_len = 20,
-			.vsync_len = 2,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DISCRETE_VR | 1,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		/* AUO 3.81 */
-		.mode = {
-			.name = "2160x1200@75Hz",
-			.refresh = 75,
-			.xres = 2160,
-			.yres = 1200,
-			.pixclock = 245000000,
-			.left_margin = 100,
-			.right_margin = 420,
-			.upper_margin = 3,
-			.lower_margin = 6,
-			.hsync_len = 32,
-			.vsync_len = 3,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DISCRETE_VR | 3,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		/* sharp 2.89 */
-		.mode = {
-			.name = "2880x1440@75Hz",
-			.refresh = 75,
-			.xres = 2880,
-			.yres = 1440,
-			.pixclock = 340000000,
-			.left_margin = 100,
-			.right_margin = 50,
-			.upper_margin = 8,
-			.lower_margin = 6,
-			.hsync_len = 50,
-			.vsync_len = 1,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DISCRETE_VR | 4,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		/* RAYKEN 5.46 */
-		.mode = {
-			.name = "1440x2560@60Hz",
-			.refresh = 60,
-			.xres = 1440,
-			.yres = 2560,
-			.pixclock = 268500000,
-			.left_margin = 50,
-			.right_margin = 200,
-			.upper_margin = 20,
-			.lower_margin = 20,
-			.hsync_len = 20,
-			.vsync_len = 10,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DISCRETE_VR | 5,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-	{
-		/* samsung */
-		.mode = {
-			.name = "1440x2560@70Hz",
-			.refresh = 70,
-			.xres = 1440,
-			.yres = 2560,
-			.pixclock = 285000000,
-			.left_margin = 40,
-			.right_margin = 80,
-			.upper_margin = 2,
-			.lower_margin = 6,
-			.hsync_len = 20,
-			.vsync_len = 8,
-			.sync = 0,
-			.vmode = 0,
-			.flag = 0,
-		},
-		.vic = HDMI_VIDEO_DISCRETE_VR | 6,
-		.vic_2nd = 0,
-		.pixelrepeat = 1,
-		.interface = OUT_P888,
-	},
-};
-
-static int hdmi_set_info(struct rk_screen *screen, struct hdmi *hdmi)
-{
-	int i, vic, colorimetry;
-	struct fb_videomode *mode;
-
-	if (!screen || !hdmi)
-		return HDMI_ERROR_FALSE;
-
-	if (hdmi->vic == 0)
-		hdmi->vic = hdmi->property->defaultmode;
-
-	if (hdmi->edid_auto_support) {
-		if ((hdmi->vic & HDMI_VIDEO_DMT) ||
-		    (hdmi->vic & HDMI_VIDEO_DISCRETE_VR)) {
-			if (hdmi->prop.value.vic)
-				vic = hdmi->prop.value.vic;
-			else
-				vic = hdmi->vic;
-		} else {
-			vic = hdmi->vic & HDMI_VIC_MASK;
-		}
-	} else {
-		if ((hdmi->vic & HDMI_VIDEO_DMT) ||
-		    (hdmi->vic & HDMI_VIDEO_DISCRETE_VR))
-			vic = hdmi->vic;
-		else
-			vic = hdmi->vic & HDMI_VIC_MASK;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		if (hdmi_mode[i].vic == vic ||
-		    hdmi_mode[i].vic_2nd == vic)
-			break;
-	}
-	if (i == ARRAY_SIZE(hdmi_mode))
-		return HDMI_ERROR_FALSE;
-
-	memset(screen, 0, sizeof(struct rk_screen));
-
-	/* screen type & face */
-	screen->type = SCREEN_HDMI;
-	colorimetry = hdmi->video.colorimetry;
-	mode = (struct fb_videomode *)&hdmi_mode[i].mode;
-	if (hdmi->video.color_input == HDMI_COLOR_RGB_0_255) {
-		screen->color_mode = COLOR_RGB;
-	} else if (colorimetry > HDMI_COLORIMETRY_EXTEND_ADOBE_RGB) {
-		screen->color_mode = COLOR_YCBCR_BT2020;
-		if (hdmi->video.eotf == EOTF_ST_2084)
-			screen->data_space = 1;
-	} else if (colorimetry == HDMI_COLORIMETRY_NO_DATA) {
-		if (mode->xres > 720 && mode->yres > 576)
-			screen->color_mode = COLOR_YCBCR_BT709;
-		else
-			screen->color_mode = COLOR_YCBCR;
-	} else if (colorimetry == HDMI_COLORIMETRY_SMTPE_170M) {
-		screen->color_mode = COLOR_YCBCR;
-	} else {
-		screen->color_mode = COLOR_YCBCR_BT709;
-	}
-
-	if (hdmi->vic & HDMI_VIDEO_YUV420) {
-		if (hdmi->video.color_output_depth == 10)
-			screen->face = OUT_YUV_420_10BIT;
-		else
-			screen->face = OUT_YUV_420;
-	} else {
-		if (hdmi->video.color_output_depth == 10)
-			screen->face = OUT_P101010;
-		else
-			screen->face = hdmi_mode[i].interface;
-	}
-	screen->pixelrepeat = hdmi_mode[i].pixelrepeat - 1;
-	screen->mode = *mode;
-	if (hdmi->video.format_3d == HDMI_3D_FRAME_PACKING) {
-		screen->mode.pixclock = 2 * mode->pixclock;
-		if (mode->vmode == 0) {
-			screen->mode.yres = 2 * mode->yres +
-					mode->upper_margin +
-					mode->lower_margin +
-					mode->vsync_len;
-		} else {
-			screen->mode.yres = 2 * mode->yres +
-					    3 * (mode->upper_margin +
-						 mode->lower_margin +
-						 mode->vsync_len) + 2;
-			screen->mode.vmode = 0;
-		}
-	}
-	/* Pin polarity */
-	if (FB_SYNC_HOR_HIGH_ACT & mode->sync)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if (FB_SYNC_VERT_HIGH_ACT & mode->sync)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-
-	screen->pin_den = 0;
-	screen->pin_dclk = 1;
-
-	/* Swap rule */
-	if (hdmi->soctype > HDMI_SOC_RK312X &&
-	    screen->color_mode > COLOR_RGB &&
-	    (screen->face == OUT_P888 ||
-	     screen->face == OUT_P101010))
-		screen->swap_rb = 1;
-	else
-		screen->swap_rb = 0;
-	screen->swap_rg = 0;
-	screen->swap_gb = 0;
-	screen->swap_delta = 0;
-	screen->swap_dumy = 0;
-
-	/* Operation function*/
-	screen->init = NULL;
-	screen->standby = NULL;
-
-	screen->overscan.left = hdmi->xscale;
-	screen->overscan.top = hdmi->yscale;
-	screen->overscan.right = hdmi->xscale;
-	screen->overscan.bottom = hdmi->yscale;
-
-	screen->width = hdmi->prop.value.width;
-	screen->height = hdmi->prop.value.height;
-	pr_info("%s:line=%d %d %d %d %d %d %d %d %d\n",
-		__func__, __LINE__, screen->mode.xres, screen->mode.yres,
-		screen->mode.left_margin, screen->mode.right_margin,
-		screen->mode.upper_margin, screen->mode.lower_margin,
-		screen->mode.hsync_len, screen->mode.vsync_len);
-
-	return 0;
-}
-
-/**
- * hdmi_find_best_mode: find the video mode nearest to input vic
- * @hdmi:
- * @vic: input vic
- *
- * NOTES:
- * If vic is zero, return the high resolution video mode vic.
- */
-int hdmi_find_best_mode(struct hdmi *hdmi, int vic)
-{
-	struct list_head *pos, *head = &hdmi->edid.modelist;
-	struct display_modelist *modelist = NULL;
-	int found = 0;
-
-	if (vic) {
-		list_for_each(pos, head) {
-			modelist =
-				list_entry(pos,
-					   struct display_modelist, list);
-			if (modelist->vic == vic) {
-				found = 1;
-				break;
-			}
-		}
-	}
-	if ((!vic || !found) && head->next != head) {
-		/* If parse edid error, we select default mode; */
-		if (hdmi->edid.specs &&
-		    hdmi->edid.specs->modedb_len)
-			modelist = list_entry(head->next,
-					      struct display_modelist, list);
-		else
-			return hdmi->property->defaultmode;
-	}
-
-	if (modelist)
-		return modelist->vic;
-	else
-		return 0;
-}
-
-/**
- * hdmi_set_lcdc: switch lcdc mode to required video mode
- * @hdmi:
- *
- * NOTES:
- *
- */
-int hdmi_set_lcdc(struct hdmi *hdmi)
-{
-	int rc = 0;
-	struct rk_screen screen;
-
-	rc = hdmi_set_info(&screen, hdmi);
-	if (!rc)
-		rk_fb_switch_screen(&screen, 1, hdmi->lcdc->id);
-	return rc;
-}
-
-/**
- * hdmi_videomode_compare - compare 2 videomodes
- * @mode1: first videomode
- * @mode2: second videomode
- *
- * RETURNS:
- * 1 if mode1 > mode2, 0 if mode1 = mode2, -1 mode1 < mode2
- */
-static int hdmi_videomode_compare(const struct fb_videomode *mode1,
-				  const struct fb_videomode *mode2)
-{
-	if (mode1->xres > mode2->xres)
-		return 1;
-
-	if (mode1->xres == mode2->xres) {
-		if (mode1->yres > mode2->yres)
-			return 1;
-		if (mode1->yres == mode2->yres) {
-			if (mode1->vmode < mode2->vmode)
-				return 1;
-			if (mode1->pixclock > mode2->pixclock)
-				return 1;
-			if (mode1->pixclock == mode2->pixclock) {
-				if (mode1->refresh > mode2->refresh)
-					return 1;
-				if (mode1->refresh == mode2->refresh) {
-					if (mode2->flag > mode1->flag)
-						return 1;
-					if (mode2->flag < mode1->flag)
-						return -1;
-					if (mode2->vmode > mode1->vmode)
-						return 1;
-					if (mode2->vmode == mode1->vmode)
-						return 0;
-				}
-			}
-		}
-	}
-	return -1;
-}
-
-/**
- * hdmi_add_vic - add entry to modelist according vic
- * @vic: vic to be added
- * @head: struct list_head of modelist
- *
- * NOTES:
- * Will only add unmatched mode entries
- */
-int hdmi_add_vic(int vic, struct list_head *head)
-{
-	struct list_head *pos;
-	struct display_modelist *modelist;
-	int found = 0, v;
-
-	/*pr_info("%s vic %d\n", __FUNCTION__, vic);*/
-	if (vic == 0)
-		return -1;
-
-	if (vic & HDMI_VIDEO_YUV420) {
-		v = vic & 0xff;
-		if (v != HDMI_3840X2160P_50HZ &&
-		    v != HDMI_3840X2160P_60HZ &&
-		    v != HDMI_4096X2160P_50HZ &&
-		    v != HDMI_4096X2160P_60HZ &&
-		    v != HDMI_3840X2160P_50HZ_21_9 &&
-		    v != HDMI_3840X2160P_60HZ_21_9) {
-			return -1;
-		}
-	}
-
-	list_for_each(pos, head) {
-		modelist = list_entry(pos, struct display_modelist, list);
-		v = modelist->vic;
-		if (v == vic) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found) {
-		modelist = kmalloc(sizeof(*modelist),
-				   GFP_KERNEL);
-
-		if (!modelist)
-			return -ENOMEM;
-		memset(modelist, 0, sizeof(struct display_modelist));
-		modelist->vic = vic;
-		list_add_tail(&modelist->list, head);
-	}
-	return 0;
-}
-
-/**
- * hdmi_add_videomode: adds videomode entry to modelist
- * @mode: videomode to be added
- * @head: struct list_head of modelist
- *
- * NOTES:
- * Will only add unmatched mode entries
- */
-static int hdmi_add_videomode(const struct fb_videomode *mode,
-			      struct list_head *head)
-{
-	struct list_head *pos;
-	struct display_modelist *modelist, *modelist_new;
-	struct fb_videomode *m;
-	int i, found = 0;
-
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		m = (struct fb_videomode *)&hdmi_mode[i].mode;
-		if (fb_mode_is_equal(m, mode)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (found) {
-		list_for_each(pos, head) {
-			modelist = list_entry(pos,
-					      struct display_modelist, list);
-			m = &modelist->mode;
-			if (fb_mode_is_equal(m, mode))
-				return 0;
-			else if (hdmi_videomode_compare(m, mode) == -1)
-				break;
-		}
-
-		modelist_new = kmalloc(sizeof(*modelist_new), GFP_KERNEL);
-		if (!modelist_new)
-			return -ENOMEM;
-		memset(modelist_new, 0, sizeof(struct display_modelist));
-		modelist_new->mode = hdmi_mode[i].mode;
-		modelist_new->vic = hdmi_mode[i].vic;
-		list_add_tail(&modelist_new->list, pos);
-	}
-
-	return 0;
-}
-
-/**
- * hdmi_sort_modelist: sort modelist of edid
- * @edid: edid to be sort
- */
-static void hdmi_sort_modelist(struct hdmi_edid *edid, int feature)
-{
-	struct list_head *pos, *pos_new;
-	struct list_head head_new, *head = &edid->modelist;
-	struct display_modelist *modelist, *modelist_new, *modelist_n;
-	struct fb_videomode *m, *m_new;
-	int i, compare, vic;
-
-	INIT_LIST_HEAD(&head_new);
-	list_for_each(pos, head) {
-		modelist = list_entry(pos, struct display_modelist, list);
-		/*pr_info("%s vic %d\n", __function__, modelist->vic);*/
-		for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-			if ((modelist->vic & HDMI_VIDEO_DMT) || (modelist->vic & HDMI_VIDEO_DISCRETE_VR)) {
-				if (feature & (SUPPORT_VESA_DMT | SUPPORT_RK_DISCRETE_VR))
-					vic = modelist->vic;
-				else
-					continue;
-			} else {
-				vic = modelist->vic & HDMI_VIC_MASK;
-			}
-			if (vic == hdmi_mode[i].vic ||
-			    vic == hdmi_mode[i].vic_2nd) {
-				if ((feature & SUPPORT_4K) == 0 &&
-				    hdmi_mode[i].mode.xres >= 3840)
-					continue;
-				if ((feature & SUPPORT_4K_4096) == 0 &&
-				    hdmi_mode[i].mode.xres == 4096)
-					continue;
-				if ((feature & SUPPORT_TMDS_600M) == 0 &&
-				    !(modelist->vic & HDMI_VIDEO_YUV420) &&
-				    hdmi_mode[i].mode.pixclock > 340000000)
-					continue;
-				if ((modelist->vic & HDMI_VIDEO_YUV420) &&
-				    (feature & SUPPORT_YUV420) == 0)
-					continue;
-				if ((feature & SUPPORT_1080I) == 0 &&
-				    hdmi_mode[i].mode.xres == 1920 &&
-				    (hdmi_mode[i].mode.vmode &
-				     FB_VMODE_INTERLACED))
-					continue;
-				if ((feature & SUPPORT_480I_576I) == 0 &&
-				    hdmi_mode[i].mode.xres == 720 &&
-				    hdmi_mode[i].mode.vmode &
-				     FB_VMODE_INTERLACED)
-					continue;
-				modelist->mode = hdmi_mode[i].mode;
-				if (modelist->vic & HDMI_VIDEO_YUV420)
-					modelist->mode.flag = 1;
-
-				compare = 1;
-				m = (struct fb_videomode *)&modelist->mode;
-				list_for_each(pos_new, &head_new) {
-					modelist_new =
-					list_entry(pos_new,
-						   struct display_modelist,
-						   list);
-					m_new = &modelist_new->mode;
-					compare =
-					hdmi_videomode_compare(m, m_new);
-					if (compare != -1)
-						break;
-				}
-				if (compare != 0) {
-					modelist_n =
-						kmalloc(sizeof(*modelist_n),
-							GFP_KERNEL);
-					if (!modelist_n)
-						return;
-					*modelist_n = *modelist;
-					list_add_tail(&modelist_n->list,
-						      pos_new);
-				}
-				break;
-			}
-		}
-	}
-	fb_destroy_modelist(head);
-	if (head_new.next == &head_new) {
-		pr_info("There is no available video mode in EDID.\n");
-		INIT_LIST_HEAD(&edid->modelist);
-	} else {
-		edid->modelist = head_new;
-		edid->modelist.prev->next = &edid->modelist;
-		edid->modelist.next->prev = &edid->modelist;
-	}
-}
-
-static int edid_select_prop_value(struct hdmi *hdmi)
-{
-	struct edid_prop_value *prop_value = NULL;
-	int nstates = 0;
-	int i, vid, pid, sn, xres, yres, reboot = 0;
-
-	prop_value = hdmi->pvalue;
-	nstates = hdmi->nstates;
-
-	if (!prop_value) {
-		pr_info("%s:pvalue is NULL\n", __func__);
-		return -1;
-	}
-
-	vid = hdmi->edid.value.vid;
-	pid = hdmi->edid.value.pid;
-	sn = hdmi->edid.value.sn;
-	xres = hdmi->edid.value.xres;
-	yres = hdmi->edid.value.yres;
-
-	for (i = 0; i < nstates; i++) {
-		if ((prop_value[i].vid == vid) &&
-		    (prop_value[i].pid == pid) &&
-		    (prop_value[i].sn == sn) &&
-		    (prop_value[i].xres == xres) &&
-		    (prop_value[i].yres == yres)) {
-			hdmi->edid.value = prop_value[i];
-			hdmi->prop.value = prop_value[i];
-			if ((hdmi->prop.valid) &&
-			    ((hdmi->prop.last_vid != vid) ||
-			    (hdmi->prop.last_pid != pid) ||
-			    (hdmi->prop.last_sn != sn) ||
-			    (hdmi->prop.last_xres != xres) ||
-			    (hdmi->prop.last_yres != yres))) {
-				reboot = 1;
-			} else {
-				reboot = 0;
-			}
-
-			hdmi->prop.last_vid = vid;
-			hdmi->prop.last_pid = pid;
-			hdmi->prop.last_sn = sn;
-			hdmi->prop.last_xres = xres;
-			hdmi->prop.last_yres = yres;
-			hdmi->prop.valid = 1;
-			pr_info("%s:i=%d reboot=%d,valid=%d\n",
-				__func__, i, reboot, hdmi->prop.valid);
-
-			break;
-		}
-	}
-
-	if (reboot) {
-		dev_info(hdmi->dev, "%s:kernel_restart\n", __func__);
-		kernel_restart(NULL);
-	}
-
-	return 0;
-}
-
-/**
- * hdmi_ouputmode_select - select hdmi transmitter output mode: hdmi or dvi?
- * @hdmi: handle of hdmi
- * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCCESS means success.
- */
-int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
-{
-	struct list_head *head = &hdmi->edid.modelist;
-	struct fb_monspecs *specs = hdmi->edid.specs;
-	struct fb_videomode *modedb = NULL, *mode = NULL;
-	int i, pixclock, feature = hdmi->property->feature;
-
-	if (edid_ok != HDMI_ERROR_SUCCESS) {
-		dev_err(hdmi->dev, "warning: EDID error, assume sink as HDMI !!!!");
-		hdmi->edid.status = -1;
-		hdmi->edid.sink_hdmi = 1;
-		hdmi->edid.baseaudio_support = 1;
-		hdmi->edid.ycbcr444 = 0;
-		hdmi->edid.ycbcr422 = 0;
-	}
-
-	if (hdmi->edid_auto_support)
-		edid_select_prop_value(hdmi);
-
-	if (head->next == head) {
-		dev_info(hdmi->dev,
-			 "warning: no CEA video mode parsed from EDID !!!!\n");
-		/* If EDID get error, list all system supported mode.
-		 * If output mode is set to DVI and EDID is ok, check
-		 * the output timing.
-		 */
-		if (hdmi->edid.sink_hdmi == 0 && specs && specs->modedb_len) {
-			/* Get max resolution timing */
-			modedb = &specs->modedb[0];
-			for (i = 0; i < specs->modedb_len; i++) {
-				if (specs->modedb[i].xres > modedb->xres)
-					modedb = &specs->modedb[i];
-				else if (specs->modedb[i].xres ==
-					 modedb->xres &&
-					 specs->modedb[i].yres > modedb->yres)
-					modedb = &specs->modedb[i];
-			}
-			/* For some monitor, the max pixclock read from EDID
-			 * is smaller than the clock of max resolution mode
-			 * supported. We fix it.
-			 */
-			pixclock = PICOS2KHZ(modedb->pixclock);
-			pixclock /= 250;
-			pixclock *= 250;
-			pixclock *= 1000;
-			if (pixclock == 148250000)
-				pixclock = 148500000;
-			if (pixclock > specs->dclkmax)
-				specs->dclkmax = pixclock;
-		}
-
-		for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-			mode = (struct fb_videomode *)&hdmi_mode[i].mode;
-			if (modedb) {
-				if ((mode->pixclock < specs->dclkmin) ||
-				    (mode->pixclock > specs->dclkmax) ||
-				    (mode->refresh < specs->vfmin) ||
-				    (mode->refresh > specs->vfmax) ||
-				    (mode->xres > modedb->xres) ||
-				    (mode->yres > modedb->yres))
-					continue;
-			} else {
-				/* If there is no valid information in EDID,
-				 * just list common hdmi foramt.
-				 */
-				if (mode->xres > 3840 ||
-				    mode->refresh < 50 ||
-				    (mode->vmode & FB_VMODE_INTERLACED) ||
-				    hdmi_mode[i].vic & HDMI_VIDEO_DMT ||
-				    hdmi_mode[i].vic & HDMI_VIDEO_DISCRETE_VR)
-					continue;
-			}
-			if ((feature & SUPPORT_TMDS_600M) == 0 &&
-			    mode->pixclock > 340000000)
-				continue;
-			if ((feature & SUPPORT_4K) == 0 &&
-			    mode->xres >= 3840)
-				continue;
-			if ((feature & SUPPORT_4K_4096) == 0 &&
-			    mode->xres == 4096)
-				continue;
-			if ((feature & SUPPORT_1080I) == 0 &&
-			    mode->xres == 1920 &&
-			    (mode->vmode & FB_VMODE_INTERLACED))
-				continue;
-			if ((feature & SUPPORT_480I_576I) == 0 &&
-			    mode->xres == 720 &&
-			    (mode->vmode & FB_VMODE_INTERLACED))
-				continue;
-			hdmi_add_videomode(mode, head);
-		}
-	} else {
-		/* There are some video mode is not defined in EDID extend
-		 * block, so we need to check first block data.
-		 */
-		if (specs && specs->modedb_len) {
-			for (i = 0; i < specs->modedb_len; i++) {
-				modedb = &specs->modedb[i];
-				pixclock = hdmi_videomode_to_vic(modedb);
-				if (pixclock)
-					hdmi_add_vic(pixclock, head);
-			}
-		}
-		hdmi_sort_modelist(&hdmi->edid, hdmi->property->feature);
-	}
-
-	return HDMI_ERROR_SUCCESS;
-}
-
-/**
- * hdmi_videomode_to_vic: transverse video mode to vic
- * @vmode: videomode to transverse
- *
- */
-int hdmi_videomode_to_vic(struct fb_videomode *vmode)
-{
-	struct fb_videomode *mode;
-	unsigned int vic = 0;
-	int i = 0;
-
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		mode = (struct fb_videomode *)&hdmi_mode[i].mode;
-		if (vmode->vmode == mode->vmode &&
-		    vmode->refresh == mode->refresh &&
-		    vmode->xres == mode->xres &&
-		    vmode->yres == mode->yres &&
-		    vmode->left_margin == mode->left_margin &&
-		    vmode->right_margin == mode->right_margin &&
-		    vmode->upper_margin == mode->upper_margin &&
-		    vmode->lower_margin == mode->lower_margin &&
-		    vmode->hsync_len == mode->hsync_len &&
-		    vmode->vsync_len == mode->vsync_len) {
-			vic = hdmi_mode[i].vic;
-			break;
-		}
-	}
-	return vic;
-}
-
-/**
- * hdmi_vic2timing: transverse vic mode to video timing
- * @vmode: vic to transverse
- *
- */
-const struct hdmi_video_timing *hdmi_vic2timing(int vic)
-{
-	int i;
-
-	if (vic == 0)
-		return NULL;
-
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		if (hdmi_mode[i].vic == vic || hdmi_mode[i].vic_2nd == vic)
-			return &hdmi_mode[i];
-	}
-	return NULL;
-}
-
-/**
- * hdmi_vic_to_videomode: transverse vic mode to video mode
- * @vmode: vic to transverse
- *
- */
-const struct fb_videomode *hdmi_vic_to_videomode(int vic)
-{
-	int i, vid;
-
-	if (vic == 0)
-		return NULL;
-	else if ((vic & HDMI_VIDEO_DMT) || (vic & HDMI_VIDEO_DISCRETE_VR))
-		vid = vic;
-	else
-		vid = vic & HDMI_VIC_MASK;
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		if (hdmi_mode[i].vic == vid ||
-		    hdmi_mode[i].vic_2nd == vid)
-			return &hdmi_mode[i].mode;
-	}
-	return NULL;
-}
-
-/**
- * hdmi_init_modelist: initial hdmi mode list
- * @hdmi:
- *
- * NOTES:
- *
- */
-void hdmi_init_modelist(struct hdmi *hdmi)
-{
-	int i, feature;
-	struct list_head *head = &hdmi->edid.modelist;
-
-	feature = hdmi->property->feature;
-	INIT_LIST_HEAD(&hdmi->edid.modelist);
-	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		if ((hdmi_mode[i].vic & HDMI_VIDEO_DMT) || (hdmi_mode[i].vic & HDMI_VIDEO_DISCRETE_VR))
-			continue;
-		if ((feature & SUPPORT_TMDS_600M) == 0 &&
-		    hdmi_mode[i].mode.pixclock > 340000000)
-			continue;
-		if ((feature & SUPPORT_4K) == 0 &&
-		    hdmi_mode[i].mode.xres >= 3840)
-			continue;
-		if ((feature & SUPPORT_4K_4096) == 0 &&
-		    hdmi_mode[i].mode.xres == 4096)
-			continue;
-		if ((feature & SUPPORT_1080I) == 0 &&
-		    hdmi_mode[i].mode.xres == 1920 &&
-		    (hdmi_mode[i].mode.vmode & FB_VMODE_INTERLACED))
-			continue;
-		if ((feature & SUPPORT_480I_576I) == 0 &&
-		    hdmi_mode[i].mode.xres == 720 &&
-		    (hdmi_mode[i].mode.vmode & FB_VMODE_INTERLACED))
-			continue;
-		hdmi_add_videomode(&hdmi_mode[i].mode, head);
-	}
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
deleted file mode 100644
index af43598ab76e..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
+++ /dev/null
@@ -1,673 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/ctype.h>
-#include <linux/string.h>
-#include <linux/display-sys.h>
-#include <linux/interrupt.h>
-#include <linux/moduleparam.h>
-#include "rockchip-hdmi.h"
-
-int hdmi_dbg_level;
-module_param(hdmi_dbg_level, int, S_IRUGO | S_IWUSR);
-
-static int hdmi_get_enable(struct rk_display_device *device)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int enable;
-
-	enable = hdmi->enable;
-	return enable;
-}
-
-static int hdmi_set_enable(struct rk_display_device *device, int enable)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (enable == 0)
-		hdmi_submit_work(hdmi, HDMI_DISABLE_CTL, 0, 0);
-	else
-		hdmi_submit_work(hdmi, HDMI_ENABLE_CTL, 0, 0);
-	return 0;
-}
-
-static int hdmi_get_status(struct rk_display_device *device)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-		return 1;
-	else
-		return 0;
-}
-
-static int hdmi_get_modelist(struct rk_display_device *device,
-			     struct list_head **modelist)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	*modelist = &hdmi->edid.modelist;
-	return 0;
-}
-
-static int hdmi_set_mode(struct rk_display_device *device,
-			 struct fb_videomode *mode)
-{
-	struct hdmi *hdmi = device->priv_data;
-	struct display_modelist *display_modelist =
-			container_of(mode, struct display_modelist, mode);
-	int vic = 0;
-
-	if (!mode) {
-		hdmi->autoset = 1;
-		vic = hdmi_find_best_mode(hdmi, 0);
-	} else {
-		hdmi->autoset = 0;
-		vic = display_modelist->vic;
-	}
-
-	if (vic && hdmi->vic != vic) {
-		hdmi->vic = vic;
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-			hdmi_submit_work(hdmi, HDMI_SET_VIDEO, 0, 0);
-	}
-	return 0;
-}
-
-static int hdmi_get_mode(struct rk_display_device *device,
-			 struct fb_videomode *mode)
-{
-	struct hdmi *hdmi = device->priv_data;
-	struct fb_videomode *vmode;
-
-	if (!mode)
-		return -1;
-
-	if (hdmi->vic) {
-		vmode = (struct fb_videomode *)
-			hdmi_vic_to_videomode(hdmi->vic);
-		if (unlikely(!vmode))
-			return -1;
-		*mode = *vmode;
-		if (hdmi->vic & HDMI_VIDEO_YUV420)
-			mode->flag = 1;
-	} else {
-		memset(mode, 0, sizeof(struct fb_videomode));
-	}
-	return 0;
-}
-
-static int hdmi_set_3dmode(struct rk_display_device *device, int mode)
-{
-	struct hdmi *hdmi = device->priv_data;
-	struct list_head *modelist, *pos;
-	struct display_modelist *display_modelist = NULL;
-
-	if (!hdmi)
-		return -1;
-
-	modelist = &hdmi->edid.modelist;
-	list_for_each(pos, modelist) {
-		display_modelist =
-			list_entry(pos, struct display_modelist, list);
-		if (hdmi->vic != display_modelist->vic)
-			display_modelist = NULL;
-		else
-			break;
-	}
-	if (!display_modelist)
-		return -1;
-
-	if ((mode != HDMI_3D_NONE) &&
-	    ((display_modelist->format_3d & (1 << mode)) == 0))
-		pr_warn("warning: sink not support input 3d mode %d", mode);
-
-	if (hdmi->mode_3d != mode) {
-		hdmi->mode_3d = mode;
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-			hdmi_submit_work(hdmi, HDMI_SET_3D, 0, 0);
-	}
-	return 0;
-}
-
-static int hdmi_get_3dmode(struct rk_display_device *device)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (!hdmi)
-		return -1;
-	else
-		return hdmi->mode_3d;
-}
-
-/* CEA 861-E: Audio Coding Type
- * sync width enum hdmi_audio_type
- */
-static const char * const audioformatstr[] = {
-	"",
-	"LPCM",		/*HDMI_AUDIO_LPCM = 1,*/
-	"AC3",		/*HDMI_AUDIO_AC3,*/
-	"MPEG1",	/*HDMI_AUDIO_MPEG1,*/
-	"MP3",		/*HDMI_AUDIO_MP3,*/
-	"MPEG2",	/*HDMI_AUDIO_MPEG2,*/
-	"AAC-LC",	/*HDMI_AUDIO_AAC_LC, AAC*/
-	"DTS",		/*HDMI_AUDIO_DTS,*/
-	"ATARC",	/*HDMI_AUDIO_ATARC,*/
-	"DSD",		/*HDMI_AUDIO_DSD, One bit Audio */
-	"E-AC3",	/*HDMI_AUDIO_E_AC3,*/
-	"DTS-HD",	/*HDMI_AUDIO_DTS_HD,*/
-	"MLP",		/*HDMI_AUDIO_MLP,*/
-	"DST",		/*HDMI_AUDIO_DST,*/
-	"WMA-PRO",	/*HDMI_AUDIO_WMA_PRO*/
-};
-
-static int hdmi_get_edidaudioinfo(struct rk_display_device *device,
-				  char *audioinfo, int len)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int i = 0, size = 0;
-	struct hdmi_audio *audio;
-
-	if (!hdmi)
-		return -1;
-
-	memset(audioinfo, 0x00, len);
-	/*printk("hdmi:edid: audio_num: %d\n", hdmi->edid.audio_num);*/
-	for (i = 0; i < hdmi->edid.audio_num; i++) {
-		audio = &hdmi->edid.audio[i];
-		if (audio->type < 1 || audio->type > HDMI_AUDIO_WMA_PRO) {
-			pr_info("audio type: unsupported.");
-			continue;
-		}
-		size = strlen(audioformatstr[audio->type]);
-		memcpy(audioinfo, audioformatstr[audio->type], size);
-		audioinfo[size] = ',';
-		audioinfo += (size + 1);
-	}
-	return 0;
-}
-
-static int hdmi_get_color(struct rk_display_device *device, char *buf)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int i, mode;
-
-	mode = (1 << HDMI_COLOR_RGB_0_255);
-	if (hdmi->edid.sink_hdmi) {
-		mode |= (1 << HDMI_COLOR_RGB_16_235);
-		if (hdmi->edid.ycbcr422)
-			mode |= (1 << HDMI_COLOR_YCBCR422);
-		if (hdmi->edid.ycbcr444)
-			mode |= (1 << HDMI_COLOR_YCBCR444);
-	}
-	i = snprintf(buf, PAGE_SIZE,
-		     "Supported Color Mode: %d\n", mode);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Current Color Mode: %d\n", hdmi->video.color_output);
-
-	mode = (1 << 1); /* 24 bit*/
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_30BITS &&
-	    hdmi->property->feature & SUPPORT_DEEP_10BIT)
-		mode |= (1 << HDMI_DEEP_COLOR_30BITS);
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_36BITS &&
-	    hdmi->property->feature & SUPPORT_DEEP_12BIT)
-		mode |= (1 << HDMI_DEEP_COLOR_36BITS);
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_48BITS &&
-	    hdmi->property->feature & SUPPORT_DEEP_16BIT)
-		mode |= (1 << HDMI_DEEP_COLOR_48BITS);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Supported Color Depth: %d\n", mode);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Current Color Depth: %d\n",
-		      hdmi->video.color_output_depth);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Supported Colorimetry: %d\n", hdmi->edid.colorimetry);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Current Colorimetry: %d\n", hdmi->colorimetry);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Supported EOTF: 0x%x\n", hdmi->edid.hdr.hdrinfo.eotf);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "Current EOTF: 0x%x\n", hdmi->eotf);
-	i += snprintf(buf + i, PAGE_SIZE - i,
-		      "HDR MeteData: %d %d %d %d %d %d %d %d %d %d %d %d\n",
-		      hdmi->hdr.prim_x0, hdmi->hdr.prim_y0,
-		      hdmi->hdr.prim_x1, hdmi->hdr.prim_y1,
-		      hdmi->hdr.prim_x2, hdmi->hdr.prim_y2,
-		      hdmi->hdr.white_px, hdmi->hdr.white_py,
-		      hdmi->hdr.max_dml, hdmi->hdr.min_dml,
-		      hdmi->hdr.max_cll, hdmi->hdr.max_fall);
-	return i;
-}
-
-static int hdmi_set_color(struct rk_display_device *device,
-			  const char *buf, int len)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int value;
-
-	if (!strncmp(buf, "mode", 4)) {
-		if (sscanf(buf, "mode=%d", &value) == -1)
-			return -1;
-		pr_debug("current mode is %d input mode is %x\n",
-			 hdmi->colormode, value);
-		if (hdmi->colormode != (value & 0xff))
-			hdmi->colormode = value & 0xff;
-		if (hdmi->colordepth != ((value >> 8) & 0xff)) {
-			pr_debug("current depth is %d input mode is %d\n",
-				 hdmi->colordepth, ((value >> 8) & 0xff));
-			hdmi->colordepth = ((value >> 8) & 0xff);
-		}
-	} else if (!strncmp(buf, "depth", 5)) {
-		if (sscanf(buf, "depth=%d", &value) == -1)
-			return -1;
-		pr_debug("current depth is %d input mode is %d\n",
-			 hdmi->colordepth, value);
-		if (hdmi->colordepth != value)
-			hdmi->colordepth = value;
-		else
-			return 0;
-	} else if (!strncmp(buf, "colorimetry", 11)) {
-		if (sscanf(buf, "colorimetry=%d", &value) == -1)
-			return -1;
-		pr_debug("current colorimetry is %d input colorimetry is %d\n",
-			 hdmi->colorimetry, value);
-		if (hdmi->colorimetry != value)
-			hdmi->colorimetry = value;
-		else
-			return 0;
-	} else if (!strncmp(buf, "hdr", 3)) {
-		if (sscanf(buf, "hdr=%d", &value) == -1)
-			return -1;
-		pr_info("current hdr eotf is %d input hdr eotf is %d\n",
-			hdmi->eotf, value);
-		if (hdmi->eotf != value &&
-		    (value & hdmi->edid.hdr.hdrinfo.eotf ||
-		     value == 0)) {
-			hdmi->eotf = value;
-			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-				hdmi_submit_work(hdmi, HDMI_SET_HDR, 0, 0);
-		}
-		return 0;
-	} else if (!strncmp(buf, "hdrmdata", 8)) {
-		value = sscanf(buf,
-			       "hdrmdata=%u %u %u %u %u %u %u %u %u %u %u %u",
-			       &hdmi->hdr.prim_x0, &hdmi->hdr.prim_y0,
-			       &hdmi->hdr.prim_x1, &hdmi->hdr.prim_y1,
-			       &hdmi->hdr.prim_x2, &hdmi->hdr.prim_y2,
-			       &hdmi->hdr.white_px, &hdmi->hdr.white_py,
-			       &hdmi->hdr.max_dml, &hdmi->hdr.min_dml,
-			       &hdmi->hdr.max_cll, &hdmi->hdr.max_fall);
-		if (value == -1)
-			return -1;
-		else
-			return 0;
-	} else {
-		pr_err("%s unknown event\n", __func__);
-		return -1;
-	}
-	if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
-		hdmi_submit_work(hdmi, HDMI_SET_COLOR, 0, 0);
-	return 0;
-}
-
-static int hdmi_set_scale(struct rk_display_device *device, int direction,
-			  int value)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (!hdmi || value < 0 || value > 100)
-		return -1;
-
-	if (!hdmi->hotplug)
-		return 0;
-
-	if (direction == DISPLAY_SCALE_X)
-		hdmi->xscale = value;
-	else if (direction == DISPLAY_SCALE_Y)
-		hdmi->yscale = value;
-	else
-		return -1;
-	rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, hdmi->lcdc->id);
-	return 0;
-}
-
-static int hdmi_get_scale(struct rk_display_device *device, int direction)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (!hdmi)
-		return -1;
-
-	if (direction == DISPLAY_SCALE_X)
-		return hdmi->xscale;
-	else if (direction == DISPLAY_SCALE_Y)
-		return hdmi->yscale;
-	else
-		return -1;
-}
-
-static int hdmi_get_monspecs(struct rk_display_device *device,
-			     struct fb_monspecs *monspecs)
-{
-	struct hdmi *hdmi = device->priv_data;
-
-	if (!hdmi)
-		return -1;
-
-	if (hdmi->edid.specs)
-		*monspecs = *hdmi->edid.specs;
-	return 0;
-}
-
-/**
- * hdmi_show_sink_info: show hdmi sink device information
- * @hdmi: handle of hdmi
- */
-static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
-{
-	struct list_head *pos, *head = &hdmi->edid.modelist;
-	struct display_modelist *modelist;
-	struct fb_videomode *m;
-	struct hdmi_audio *audio;
-	int i, lens = len;
-
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			"******** Show Sink Info ********\n");
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			 "Max tmds clk is %u\n",
-			 hdmi->edid.maxtmdsclock);
-	if (hdmi->edid.hf_vsdb_version)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "Support HFVSDB\n");
-	if (hdmi->edid.scdc_present)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "Support SCDC\n");
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			 "Support video mode:\n");
-	list_for_each(pos, head) {
-		modelist = list_entry(pos, struct display_modelist, list);
-		m = &modelist->mode;
-		if (m->flag)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 "\t%s(YCbCr420)\n", m->name);
-		else
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 "\t%s\n", m->name);
-	}
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			 "Support video color mode:");
-	lens += snprintf(buf + lens, PAGE_SIZE - lens, " RGB");
-	if (hdmi->edid.ycbcr420)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 " YCbCr420");
-	if (hdmi->edid.ycbcr422)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 " YCbCr422");
-	if (hdmi->edid.ycbcr444)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 " YCbCr444");
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			 "\nSupport video color depth:");
-	lens += snprintf(buf + lens, PAGE_SIZE - lens, " 24bit");
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_30BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 30bit");
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_36BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 36bit");
-	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_48BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 48bit");
-	if (hdmi->edid.ycbcr420)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_24bit");
-	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_30BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_30bit");
-	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_36BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_36bit");
-	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_48BITS)
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_48bit");
-	if (hdmi->edid.colorimetry) {
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "\nExtended Colorimetry:");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_XVYCC_601 - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " xvYCC601");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_XVYCC_709 - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " xvYCC709");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_SYCC_601 - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " sYCC601");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_ADOBE_YCC601 - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " AdobeYCC601");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_ADOBE_RGB - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " AdobeRGB");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_YCC_C - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " BT2020cYCC");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_YCC - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " BT2020YCC");
-		if (hdmi->edid.colorimetry &
-		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_RGB - 3)))
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " BT2020RGB");
-	}
-	lens += snprintf(buf + lens, PAGE_SIZE - lens,
-			 "\nSupport audio type:");
-	for (i = 0; i < hdmi->edid.audio_num; i++) {
-		audio = &hdmi->edid.audio[i];
-		switch (audio->type) {
-		case HDMI_AUDIO_LPCM:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				" LPCM\n");
-			break;
-		case HDMI_AUDIO_AC3:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " AC3");
-			break;
-		case HDMI_AUDIO_MPEG1:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " MPEG1");
-			break;
-		case HDMI_AUDIO_MP3:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " MP3");
-			break;
-		case HDMI_AUDIO_MPEG2:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " MPEG2");
-			break;
-		case HDMI_AUDIO_AAC_LC:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " AAC");
-			break;
-		case HDMI_AUDIO_DTS:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " DTS");
-			break;
-		case HDMI_AUDIO_ATARC:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " ATARC");
-			break;
-		case HDMI_AUDIO_DSD:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " DSD");
-			break;
-		case HDMI_AUDIO_E_AC3:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " E-AC3");
-			break;
-		case HDMI_AUDIO_DTS_HD:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " DTS-HD");
-			break;
-		case HDMI_AUDIO_MLP:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " MLP");
-			break;
-		case HDMI_AUDIO_DST:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " DST");
-			break;
-		case HDMI_AUDIO_WMA_PRO:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " WMP-PRO");
-			break;
-		default:
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " Unknown");
-			break;
-		}
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "Support max audio channel is %d\n",
-				 audio->channel);
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "Support audio sample rate:");
-		if (audio->rate & HDMI_AUDIO_FS_32000)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 32000");
-		if (audio->rate & HDMI_AUDIO_FS_44100)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 44100");
-		if (audio->rate & HDMI_AUDIO_FS_48000)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 48000");
-		if (audio->rate & HDMI_AUDIO_FS_88200)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 88200");
-		if (audio->rate & HDMI_AUDIO_FS_96000)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 96000");
-		if (audio->rate & HDMI_AUDIO_FS_176400)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 176400");
-		if (audio->rate & HDMI_AUDIO_FS_192000)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 192000");
-		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "\nSupport audio word length:");
-		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_16bit)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 16bit");
-		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_20bit)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 20bit");
-		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_24bit)
-			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " 24bit");
-		lens += snprintf(buf + lens, PAGE_SIZE - lens, "\n");
-	}
-	return lens;
-}
-
-static int hdmi_get_debug(struct rk_display_device *device, char *buf)
-{
-	struct hdmi *hdmi = device->priv_data;
-	u8 *buff;
-	int i, j, len = 0;
-
-	if (!hdmi)
-		return 0;
-	len += snprintf(buf + len, PAGE_SIZE - len, "EDID status:%s\n",
-			hdmi->edid.status ? "False" : "Okay");
-	len += snprintf(buf + len, PAGE_SIZE - len, "Raw Data:");
-	for (i = 0; i < HDMI_MAX_EDID_BLOCK; i++) {
-		if (!hdmi->edid.raw[i])
-			break;
-		buff = hdmi->edid.raw[i];
-		for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
-			if (j % 16 == 0)
-				len += snprintf(buf + len,
-						PAGE_SIZE - len, "\n");
-			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x, ",
-					buff[j]);
-		}
-	}
-	len += snprintf(buf + len, PAGE_SIZE, "\n");
-	if (!hdmi->edid.status)
-		len += hdmi_show_sink_info(hdmi, buf, len);
-	return len;
-}
-
-static int vr_get_info(struct rk_display_device *device, char *buf)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int valid, width, height, x_w, x_h, hwr, einit, vsync, panel, scan;
-	int len = 0;
-
-	valid = hdmi->prop.valid;
-	width = hdmi->prop.value.width;
-	height = hdmi->prop.value.height;
-	x_w = hdmi->prop.value.x_w;
-	x_h = hdmi->prop.value.x_h;
-	hwr = hdmi->prop.value.hwrotation;
-	einit = hdmi->prop.value.einit;
-	vsync = hdmi->prop.value.vsync;
-	panel = hdmi->prop.value.panel;
-	scan = hdmi->prop.value.scan;
-
-	len = snprintf(buf, PAGE_SIZE,
-		"valid=%d,width=%d,height=%d,xres=%d,yres=%d,hwrotation=%d,orientation=%d,vsync=%d,panel=%d,scan=%d\n",
-		valid, width, height, x_w, x_h, hwr, einit, vsync, panel, scan);
-
-	return len;
-}
-
-static struct rk_display_ops hdmi_display_ops = {
-	.setenable = hdmi_set_enable,
-	.getenable = hdmi_get_enable,
-	.getstatus = hdmi_get_status,
-	.getmodelist = hdmi_get_modelist,
-	.setmode = hdmi_set_mode,
-	.getmode = hdmi_get_mode,
-	.set3dmode = hdmi_set_3dmode,
-	.get3dmode = hdmi_get_3dmode,
-	.getedidaudioinfo = hdmi_get_edidaudioinfo,
-	.setcolor = hdmi_set_color,
-	.getcolor = hdmi_get_color,
-	.getmonspecs = hdmi_get_monspecs,
-	.setscale = hdmi_set_scale,
-	.getscale = hdmi_get_scale,
-	.getdebug = hdmi_get_debug,
-	.getvrinfo = vr_get_info,
-};
-
-static int hdmi_display_probe(struct rk_display_device *device, void *devdata)
-{
-	struct hdmi *hdmi = devdata;
-
-	device->owner = THIS_MODULE;
-	strcpy(device->type, "HDMI");
-	if (strstr(hdmi->property->name, "dp"))
-		strcpy(device->type, "DP");
-	else
-		strcpy(device->type, "HDMI");
-
-	device->priority = DISPLAY_PRIORITY_HDMI;
-	device->name = hdmi->property->name;
-	device->property = hdmi->property->display;
-	device->priv_data = devdata;
-	device->ops = &hdmi_display_ops;
-	return 1;
-}
-
-static struct rk_display_driver display_hdmi = {
-	.probe = hdmi_display_probe,
-};
-
-struct rk_display_device *hdmi_register_display_sysfs(struct hdmi *hdmi,
-						      struct device *parent)
-{
-	return rk_display_device_register(&display_hdmi, parent, hdmi);
-}
-
-void hdmi_unregister_display_sysfs(struct hdmi *hdmi)
-{
-	if (hdmi->ddev)
-		rk_display_device_unregister(hdmi->ddev);
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi.h b/drivers/video/rockchip/hdmi/rockchip-hdmi.h
deleted file mode 100644
index 6bd2d2020b05..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi.h
+++ /dev/null
@@ -1,613 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROCKCHIP_HDMI_H__
-#define __ROCKCHIP_HDMI_H__
-
-#include <linux/fb.h>
-#include <linux/rk_fb.h>
-#include <linux/display-sys.h>
-#ifdef CONFIG_SWITCH
-#include <linux/switch.h>
-#endif
-#include <sound/pcm_params.h>
-#include <linux/reboot.h>
-
-#define HDMI_VIDEO_NORMAL				0
-#define HDMI_VIDEO_DMT					BIT(9)
-#define HDMI_VIDEO_YUV420				BIT(10)
-#define HDMI_VIDEO_DISCRETE_VR				BIT(11)
-
-#define HDMI_VIC_MASK					(0xFF)
-#define HDMI_TYPE_MASK					(0xFF << 8)
-#define HDMI_MAX_ID					4
-
-#define HDMI_UBOOT_NOT_INIT				BIT(16)
-#define HDMI_UBOOT_VIC_MASK				0xFFFF
-
-/* HDMI video information code according CEA-861-F */
-enum hdmi_video_information_code {
-	HDMI_640X480P_60HZ = 1,
-	HDMI_720X480P_60HZ_4_3,
-	HDMI_720X480P_60HZ_16_9,
-	HDMI_1280X720P_60HZ,
-	HDMI_1920X1080I_60HZ,		/*5*/
-	HDMI_720X480I_60HZ_4_3,
-	HDMI_720X480I_60HZ_16_9,
-	HDMI_720X240P_60HZ_4_3,
-	HDMI_720X240P_60HZ_16_9,
-	HDMI_2880X480I_60HZ_4_3,	/*10*/
-	HDMI_2880X480I_60HZ_16_9,
-	HDMI_2880X240P_60HZ_4_3,
-	HDMI_2880X240P_60HZ_16_9,
-	HDMI_1440X480P_60HZ_4_3,
-	HDMI_1440X480P_60HZ_16_9,	/*15*/
-	HDMI_1920X1080P_60HZ,
-	HDMI_720X576P_50HZ_4_3,
-	HDMI_720X576P_50HZ_16_9,
-	HDMI_1280X720P_50HZ,
-	HDMI_1920X1080I_50HZ,		/*20*/
-	HDMI_720X576I_50HZ_4_3,
-	HDMI_720X576I_50HZ_16_9,
-	HDMI_720X288P_50HZ_4_3,
-	HDMI_720X288P_50HZ_16_9,
-	HDMI_2880X576I_50HZ_4_3,	/*25*/
-	HDMI_2880X576I_50HZ_16_9,
-	HDMI_2880X288P_50HZ_4_3,
-	HDMI_2880X288P_50HZ_16_9,
-	HDMI_1440X576P_50HZ_4_3,
-	HDMI_1440X576P_50HZ_16_9,	/*30*/
-	HDMI_1920X1080P_50HZ,
-	HDMI_1920X1080P_24HZ,
-	HDMI_1920X1080P_25HZ,
-	HDMI_1920X1080P_30HZ,
-	HDMI_2880X480P_60HZ_4_3,	/*35*/
-	HDMI_2880X480P_60HZ_16_9,
-	HDMI_2880X576P_50HZ_4_3,
-	HDMI_2880X576P_50HZ_16_9,
-	HDMI_1920X1080I_50HZ_1250,	/* V Line 1250 total*/
-	HDMI_1920X1080I_100HZ,		/*40*/
-	HDMI_1280X720P_100HZ,
-	HDMI_720X576P_100HZ_4_3,
-	HDMI_720X576P_100HZ_16_9,
-	HDMI_720X576I_100HZ_4_3,
-	HDMI_720X576I_100HZ_16_9,	/*45*/
-	HDMI_1920X1080I_120HZ,
-	HDMI_1280X720P_120HZ,
-	HDMI_720X480P_120HZ_4_3,
-	HDMI_720X480P_120HZ_16_9,
-	HDMI_720X480I_120HZ_4_3,	/*50*/
-	HDMI_720X480I_120HZ_16_9,
-	HDMI_720X576P_200HZ_4_3,
-	HDMI_720X576P_200HZ_16_9,
-	HDMI_720X576I_200HZ_4_3,
-	HDMI_720X576I_200HZ_16_9,	/*55*/
-	HDMI_720X480P_240HZ_4_3,
-	HDMI_720X480P_240HZ_16_9,
-	HDMI_720X480I_240HZ_4_3,
-	HDMI_720X480I_240HZ_16_9,
-	HDMI_1280X720P_24HZ,		/*60*/
-	HDMI_1280X720P_25HZ,
-	HDMI_1280X720P_30HZ,
-	HDMI_1920X1080P_120HZ,
-	HDMI_1920X1080P_100HZ,
-	HDMI_1280X720P_24HZ_21_9,	/*65*/
-	HDMI_1280X720P_25HZ_21_9,
-	HDMI_1280X720P_30HZ_21_9,
-	HDMI_1280X720P_50HZ_21_9,
-	HDMI_1280X720P_60HZ_21_9,
-	HDMI_1280X720P_100HZ_21_9,	/*70*/
-	HDMI_1280X720P_120HZ_21_9,
-	HDMI_1920X1080P_24HZ_21_9,
-	HDMI_1920X1080P_25HZ_21_9,
-	HDMI_1920X1080P_30HZ_21_9,
-	HDMI_1920X1080P_50HZ_21_9,	/*75*/
-	HDMI_1920X1080P_60HZ_21_9,
-	HDMI_1920X1080P_100HZ_21_9,
-	HDMI_1920X1080P_120HZ_21_9,
-	HDMI_1680X720P_24HZ,
-	HDMI_1680X720P_25HZ,		/*80*/
-	HDMI_1680X720P_30HZ,
-	HDMI_1680X720P_50HZ,
-	HDMI_1680X720P_60HZ,
-	HDMI_1680X720P_100HZ,
-	HDMI_1680X720P_120HZ,		/*85*/
-	HDMI_2560X1080P_24HZ,
-	HDMI_2560X1080P_25HZ,
-	HDMI_2560X1080P_30HZ,
-	HDMI_2560X1080P_50HZ,
-	HDMI_2560X1080P_60HZ,		/*90*/
-	HDMI_2560X1080P_100HZ,
-	HDMI_2560X1080P_120HZ,
-	HDMI_3840X2160P_24HZ,
-	HDMI_3840X2160P_25HZ,
-	HDMI_3840X2160P_30HZ,		/*95*/
-	HDMI_3840X2160P_50HZ,
-	HDMI_3840X2160P_60HZ,
-	HDMI_4096X2160P_24HZ,
-	HDMI_4096X2160P_25HZ,
-	HDMI_4096X2160P_30HZ,		/*100*/
-	HDMI_4096X2160P_50HZ,
-	HDMI_4096X2160P_60HZ,
-	HDMI_3840X2160P_24HZ_21_9,
-	HDMI_3840X2160P_25HZ_21_9,
-	HDMI_3840X2160P_30HZ_21_9,	/*105*/
-	HDMI_3840X2160P_50HZ_21_9,
-	HDMI_3840X2160P_60HZ_21_9,
-};
-
-/* HDMI Extended Resolution */
-enum {
-	HDMI_VIC_4KX2K_30HZ = 1,
-	HDMI_VIC_4KX2K_25HZ,
-	HDMI_VIC_4KX2K_24HZ,
-	HDMI_VIC_4KX2K_24HZ_SMPTE
-};
-
-/* HDMI Video Format */
-enum {
-	HDMI_VIDEO_FORMAT_NORMAL = 0,
-	HDMI_VIDEO_FORMAT_4KX2K,
-	HDMI_VIDEO_FORMAT_3D,
-};
-
-/* HDMI 3D type */
-enum {
-	HDMI_3D_NONE = -1,
-	HDMI_3D_FRAME_PACKING = 0,
-	HDMI_3D_TOP_BOOTOM = 6,
-	HDMI_3D_SIDE_BY_SIDE_HALF = 8,
-};
-
-/* HDMI Video Data Color Mode */
-enum hdmi_video_color_mode {
-	HDMI_COLOR_AUTO	= 0,
-	HDMI_COLOR_RGB_0_255,
-	HDMI_COLOR_RGB_16_235,
-	HDMI_COLOR_YCBCR444,
-	HDMI_COLOR_YCBCR422,
-	HDMI_COLOR_YCBCR420
-};
-
-/* HDMI Video Data Color Depth */
-enum hdmi_deep_color {
-	HDMI_DEPP_COLOR_AUTO = 0,
-	HDMI_DEEP_COLOR_Y444 = 0x1,
-	HDMI_DEEP_COLOR_30BITS = 0x2,
-	HDMI_DEEP_COLOR_36BITS = 0x4,
-	HDMI_DEEP_COLOR_48BITS = 0x8,
-};
-
-enum hdmi_colorimetry {
-	HDMI_COLORIMETRY_NO_DATA = 0,
-	HDMI_COLORIMETRY_SMTPE_170M,
-	HDMI_COLORIMETRY_ITU709,
-	HDMI_COLORIMETRY_EXTEND_XVYCC_601,
-	HDMI_COLORIMETRY_EXTEND_XVYCC_709,
-	HDMI_COLORIMETRY_EXTEND_SYCC_601,
-	HDMI_COLORIMETRY_EXTEND_ADOBE_YCC601,
-	HDMI_COLORIMETRY_EXTEND_ADOBE_RGB,
-	HDMI_COLORIMETRY_EXTEND_BT_2020_YCC_C, /*constant luminance*/
-	HDMI_COLORIMETRY_EXTEND_BT_2020_YCC,
-	HDMI_COLORIMETRY_EXTEND_BT_2020_RGB,
-};
-
-/* HDMI Audio source */
-enum {
-	HDMI_AUDIO_SRC_IIS = 0,
-	HDMI_AUDIO_SRC_SPDIF
-};
-
-/* HDMI Audio Type */
-enum hdmi_audio_type {
-	HDMI_AUDIO_NLPCM = 0,
-	HDMI_AUDIO_LPCM = 1,
-	HDMI_AUDIO_AC3,
-	HDMI_AUDIO_MPEG1,
-	HDMI_AUDIO_MP3,
-	HDMI_AUDIO_MPEG2,
-	HDMI_AUDIO_AAC_LC,		/*AAC */
-	HDMI_AUDIO_DTS,
-	HDMI_AUDIO_ATARC,
-	HDMI_AUDIO_DSD,			/* One bit Audio */
-	HDMI_AUDIO_E_AC3,
-	HDMI_AUDIO_DTS_HD,
-	HDMI_AUDIO_MLP,
-	HDMI_AUDIO_DST,
-	HDMI_AUDIO_WMA_PRO
-};
-
-/* HDMI Audio Sample Rate */
-enum hdmi_audio_samplerate {
-	HDMI_AUDIO_FS_32000  = 0x1,
-	HDMI_AUDIO_FS_44100  = 0x2,
-	HDMI_AUDIO_FS_48000  = 0x4,
-	HDMI_AUDIO_FS_88200  = 0x8,
-	HDMI_AUDIO_FS_96000  = 0x10,
-	HDMI_AUDIO_FS_176400 = 0x20,
-	HDMI_AUDIO_FS_192000 = 0x40
-};
-
-/* HDMI Audio Word Length */
-enum hdmi_audio_word_length {
-	HDMI_AUDIO_WORD_LENGTH_16bit = 0x1,
-	HDMI_AUDIO_WORD_LENGTH_20bit = 0x2,
-	HDMI_AUDIO_WORD_LENGTH_24bit = 0x4
-};
-
-/* HDMI Hotplug Status */
-enum hdmi_hotpulg_status {
-	HDMI_HPD_REMOVED = 0,	/* HDMI is disconnected */
-	HDMI_HPD_INSERT,	/* HDMI is connected, but HDP is low
-				 * or TMDS link is not pull up to 3.3V.
-				 */
-	HDMI_HPD_ACTIVATED	/* HDMI is connected, all singnal
-				 * is normal
-				 */
-};
-
-enum hdmi_mute_status {
-	HDMI_AV_UNMUTE = 0,
-	HDMI_VIDEO_MUTE = 0x1,
-	HDMI_AUDIO_MUTE = 0x2,
-};
-
-/* HDMI Error Code */
-enum hdmi_error_code {
-	HDMI_ERROR_SUCCESS = 0,
-	HDMI_ERROR_FALSE,
-	HDMI_ERROR_I2C,
-	HDMI_ERROR_EDID,
-};
-
-/* HDMI Video Timing */
-struct hdmi_video_timing {
-	struct fb_videomode mode;	/* Video timing*/
-	unsigned int vic;		/* Video information code*/
-	unsigned int vic_2nd;
-	unsigned int pixelrepeat;	/* Video pixel repeat rate*/
-	unsigned int interface;		/* Video input interface*/
-};
-
-/* HDMI Video Parameters */
-struct hdmi_video {
-	unsigned int vic;		/* Video information code*/
-	unsigned int color_input;	/* Input video color mode*/
-	unsigned int color_output;	/* Output video color mode*/
-	unsigned int color_output_depth;/* Output video Color Depth*/
-	unsigned int colorimetry;	/* Output Colorimetry */
-	unsigned int sink_hdmi;		/* Output signal is DVI or HDMI*/
-	unsigned int format_3d;		/* Output 3D mode*/
-	unsigned int eotf;		/* EOTF */
-};
-
-/* HDMI Audio Parameters */
-struct hdmi_audio {
-	u32	type;			/*Audio type*/
-	u32	channel;		/*Audio channel number*/
-	u32	rate;			/*Audio sampling rate*/
-	u32	word_length;		/*Audio data word length*/
-};
-
-enum hdmi_hdr_eotf {
-	EOTF_TRADITIONAL_GMMA_SDR = 1,
-	EOFT_TRADITIONAL_GMMA_HDR = 2,
-	EOTF_ST_2084 = 4,
-};
-
-struct hdmi_hdr_metadata {
-	u32	prim_x0;
-	u32	prim_y0;
-	u32	prim_x1;
-	u32	prim_y1;
-	u32	prim_x2;
-	u32	prim_y2;
-	u32	white_px;
-	u32	white_py;
-	u32	max_dml;
-	u32	min_dml;
-	u32	max_cll;		/*max content light level*/
-	u32	max_fall;		/*max frame-average light level*/
-};
-
-struct hdmi_hdr {
-	u8	eotf;
-	u8	metadata;	/*Staic Metadata Descriptor*/
-	u8	maxluminance;
-	u8	max_average_luminance;
-	u8	minluminance;
-};
-
-#define HDMI_MAX_EDID_BLOCK		8
-
-struct edid_prop_value {
-	int vid;
-	int pid;
-	int sn;
-	int xres;
-	int yres;
-	int vic;
-	int width;
-	int height;
-	int x_w;
-	int x_h;
-	int hwrotation;
-	int einit;
-	int vsync;
-	int panel;
-	int scan;
-};
-
-struct edid_prop_data {
-	struct edid_prop_value value;
-
-	int valid;
-	int last_vid;
-	int last_pid;
-	int last_sn;
-	int last_xres;
-	int last_yres;
-};
-
-/* HDMI EDID Information */
-struct hdmi_edid {
-	unsigned char sink_hdmi;	/* HDMI display device flag */
-	unsigned char ycbcr444;		/* Display device support YCbCr444 */
-	unsigned char ycbcr422;		/* Display device support YCbCr422 */
-	unsigned char ycbcr420;		/* Display device support YCbCr420 */
-	unsigned char deepcolor;	/* bit3:DC_48bit; bit2:DC_36bit;
-					 * bit1:DC_30bit; bit0:DC_Y444;
-					 */
-	unsigned char deepcolor_420;
-	unsigned int  cecaddress;	/* CEC physical address */
-	unsigned int  maxtmdsclock;	/* Max supported tmds clock */
-	unsigned char fields_present;	/* bit7: latency
-					 * bit6: i_lantency
-					 * bit5: hdmi_video
-					 */
-	unsigned char video_latency;
-	unsigned char audio_latency;
-	unsigned char interlaced_video_latency;
-	unsigned char interlaced_audio_latency;
-	/* for hdmi 2.0 */
-	unsigned char hf_vsdb_version;
-	unsigned char scdc_present;
-	unsigned char rr_capable;
-	unsigned char lte_340mcsc_scramble;
-	unsigned char independent_view;
-	unsigned char dual_view;
-	unsigned char osd_disparity_3d;
-
-	struct edid_prop_value value;
-
-	unsigned int colorimetry;
-	struct fb_monspecs	*specs;	/*Device spec*/
-	struct list_head modelist;	/*Device supported display mode list*/
-	unsigned char baseaudio_support;
-	struct hdmi_audio *audio;	/*Device supported audio info*/
-	unsigned int  audio_num;	/*Device supported audio type number*/
-
-	unsigned int status;		/*EDID read status, success or failed*/
-	u8 *raw[HDMI_MAX_EDID_BLOCK];	/*Raw EDID Data*/
-	union {
-		u8	data[5];
-		struct hdmi_hdr hdrinfo;
-	} hdr;
-};
-
-struct hdmi;
-
-struct hdmi_ops {
-	int (*enable)(struct hdmi *);
-	int (*disable)(struct hdmi *);
-	int (*getstatus)(struct hdmi *);
-	int (*insert)(struct hdmi *);
-	int (*remove)(struct hdmi *);
-	int (*getedid)(struct hdmi *, int, unsigned char *);
-	int (*setvideo)(struct hdmi *, struct hdmi_video *);
-	int (*setaudio)(struct hdmi *, struct hdmi_audio *);
-	int (*setmute)(struct hdmi *, int);
-	int (*setvsi)(struct hdmi *, unsigned char, unsigned char);
-	int (*setcec)(struct hdmi *);
-	void (*sethdr)(struct hdmi *, int, struct hdmi_hdr_metadata *);
-	void (*setavi)(struct hdmi *, struct hdmi_video *);
-	/* call back for hdcp operatoion */
-	void (*hdcp_cb)(struct hdmi *);
-	void (*hdcp_auth2nd)(struct hdmi *);
-	void (*hdcp_irq_cb)(int);
-	int (*hdcp_power_on_cb)(void);
-	void (*hdcp_power_off_cb)(struct hdmi *);
-};
-
-enum rk_hdmi_feature {
-	SUPPORT_480I_576I	=	(1 << 0),
-	SUPPORT_1080I		=	(1 << 1),
-	SUPPORT_DEEP_10BIT	=	(1 << 2),
-	SUPPORT_DEEP_12BIT	=	(1 << 3),
-	SUPPORT_DEEP_16BIT	=	(1 << 4),
-	SUPPORT_4K		=	(1 << 5),
-	SUPPORT_4K_4096		=	(1 << 6),
-	SUPPORT_TMDS_600M	=	(1 << 7),
-	SUPPORT_YUV420		=	(1 << 8),
-	SUPPORT_CEC		=	(1 << 9),
-	SUPPORT_HDCP		=	(1 << 10),
-	SUPPORT_HDCP2		=	(1 << 11),
-	SUPPORT_YCBCR_INPUT	=	(1 << 12),
-	SUPPORT_VESA_DMT	=	(1 << 13),
-	SUPPORT_RK_DISCRETE_VR	=	(1 << 14)
-};
-
-struct hdmi_property {
-	char *name;
-	int videosrc;
-	int display;
-	int feature;
-	int defaultmode;
-	int defaultdepth;
-	void *priv;
-};
-
-enum {
-	HDMI_SOC_RK3036 = 0,
-	HDMI_SOC_RK312X,
-	HDMI_SOC_RK322X,
-	HDMI_SOC_RK3288,
-	HDMI_SOC_RK3366,
-	HDMI_SOC_RK3368,
-	HDMI_SOC_RK3399,
-};
-
-/* HDMI Information */
-struct hdmi {
-	int id;					/*HDMI id*/
-	int soctype;
-	struct device	*dev;			/*HDMI device*/
-	struct rk_lcdc_driver *lcdc;		/*HDMI linked lcdc*/
-	struct rk_display_device *ddev;		/*Registered display device*/
-	#ifdef CONFIG_SWITCH
-	struct switch_dev	switchdev;	/*Registered switch device*/
-	#endif
-
-	struct hdmi_property *property;
-	struct hdmi_ops *ops;
-
-	struct mutex lock;			/* mutex for hdmi operation */
-	struct mutex pclk_lock;			/* mutex for pclk operation */
-	struct workqueue_struct *workqueue;
-
-	bool uboot;	/* if true, HDMI is initialized in uboot*/
-
-	int hotplug;	/* hot plug status*/
-	int autoset;	/* if true, auto set hdmi output mode according EDID.*/
-	int mute;	/* HDMI display status:
-			 * 2 - mute audio,
-			 * 1 - mute display;
-			 * 0 - unmute
-			 */
-	int colordepth;			/* Output color depth*/
-	int colormode;			/* Output color mode*/
-	int colorimetry;		/* Output colorimetry */
-	struct hdmi_edid edid;		/* EDID information*/
-	struct edid_prop_data prop;	/* Property for dp */
-	struct edid_prop_value *pvalue;
-	int nstates;
-	int edid_auto_support;		/* Auto dp enable flag */
-
-	int enable;			/* Enable flag*/
-	int sleep;			/* Sleep flag*/
-	int vic;			/* HDMI output video information code*/
-	int mode_3d;			/* HDMI output video 3d mode*/
-	int eotf;			/* HDMI HDR EOTF */
-	struct hdmi_hdr_metadata hdr;	/* HDMI HDR MedeData */
-	struct hdmi_audio audio;	/* HDMI output audio information.*/
-	struct hdmi_video video;	/* HDMI output video information.*/
-	int xscale;
-	int yscale;
-};
-
-/* HDMI EDID Block Size */
-#define HDMI_EDID_BLOCK_SIZE	128
-
-/* SCDC Registers */
-#define SCDC_SINK_VER		0x01	/* sink version		*/
-#define SCDC_SOURCE_VER		0x02	/* source version	*/
-#define SCDC_UPDATE_0		0x10	/* Update_0		*/
-#define SCDC_UPDATE_1		0x11	/* Update_1		*/
-#define SCDC_UPDATE_RESERVED	0x12	/* 0x12-0x1f - Reserved */
-#define SCDC_TMDS_CONFIG	0x20	/* TMDS_Config   */
-#define SCDC_SCRAMBLER_STAT	0x21	/* Scrambler_Status   */
-#define SCDC_CONFIG_0		0x30	/* Config_0           */
-#define SCDC_CONFIG_RESERVED	0x31	/* 0x31-0x3f - Reserved */
-#define SCDC_STATUS_FLAG_0	0x40	/* Status_Flag_0        */
-#define SCDC_STATUS_FLAG_1	0x41	/* Status_Flag_1        */
-#define SCDC_STATUS_RESERVED	0x42	/* 0x42-0x4f - Reserved */
-#define SCDC_ERR_DET_0_L	0x50	/* Err_Det_0_L          */
-#define SCDC_ERR_DET_0_H	0x51	/* Err_Det_0_H          */
-#define SCDC_ERR_DET_1_L	0x52	/* Err_Det_1_L          */
-#define SCDC_ERR_DET_1_H	0x53	/* Err_Det_1_H          */
-#define SCDC_ERR_DET_2_L	0x54	/* Err_Det_2_L          */
-#define SCDC_ERR_DET_2_H	0x55	/* Err_Det_2_H          */
-#define SCDC_ERR_DET_CHKSUM	0x56	/* Err_Det_Checksum     */
-#define SCDC_TEST_CFG_0		0xc0	/* Test_config_0        */
-#define SCDC_TEST_RESERVED	0xc1	/* 0xc1-0xcf		*/
-#define SCDC_MAN_OUI_3RD	0xd0	/* Manufacturer IEEE OUI,
-					 * Third Octet
-					 */
-#define SCDC_MAN_OUI_2ND	0xd1	/* Manufacturer IEEE OUI,
-					 * Second Octet
-					 */
-#define SCDC_MAN_OUI_1ST	0xd2	/* Manufacturer IEEE OUI,
-					 * First Octet
-					 */
-#define SCDC_DEVICE_ID		0xd3	/* 0xd3-0xdd - Device ID            */
-#define SCDC_MAN_SPECIFIC	0xde	/* 0xde-0xff - ManufacturerSpecific */
-
-/* Event source */
-#define HDMI_SRC_SHIFT		8
-#define HDMI_SYSFS_SRC		(0x1 << HDMI_SRC_SHIFT)
-#define HDMI_SUSPEND_SRC	(0x2 << HDMI_SRC_SHIFT)
-#define HDMI_IRQ_SRC		(0x4 << HDMI_SRC_SHIFT)
-#define HDMI_WORKQUEUE_SRC	(0x8 << HDMI_SRC_SHIFT)
-
-/* Event */
-#define HDMI_ENABLE_CTL			(HDMI_SYSFS_SRC		| 0)
-#define HDMI_DISABLE_CTL		(HDMI_SYSFS_SRC		| 1)
-#define HDMI_SUSPEND_CTL		(HDMI_SUSPEND_SRC	| 2)
-#define HDMI_RESUME_CTL			(HDMI_SUSPEND_SRC	| 3)
-#define HDMI_HPD_CHANGE			(HDMI_IRQ_SRC		| 4)
-#define HDMI_SET_VIDEO			(HDMI_SYSFS_SRC		| 5)
-#define HDMI_SET_AUDIO			(HDMI_SYSFS_SRC		| 6)
-#define HDMI_SET_3D			(HDMI_SYSFS_SRC		| 7)
-#define HDMI_MUTE_AUDIO			(HDMI_SYSFS_SRC		| 8)
-#define HDMI_UNMUTE_AUDIO		(HDMI_SYSFS_SRC		| 9)
-#define HDMI_SET_COLOR			(HDMI_SYSFS_SRC		| 10)
-#define HDMI_ENABLE_HDCP		(HDMI_SYSFS_SRC		| 11)
-#define HDMI_HDCP_AUTH_2ND		(HDMI_IRQ_SRC		| 12)
-#define HDMI_SET_HDR			(HDMI_SYSFS_SRC		| 13)
-
-#define HDMI_DEFAULT_SCALE		95
-#define HDMI_AUTO_CONFIG		false
-
-/* HDMI default vide mode */
-#define HDMI_VIDEO_DEFAULT_MODE			HDMI_1280X720P_60HZ
-						/*HDMI_1920X1080P_60HZ*/
-#define HDMI_VIDEO_DEFAULT_COLORMODE		HDMI_COLOR_AUTO
-#define HDMI_VIDEO_DEFAULT_COLORDEPTH		8
-
-/* HDMI default audio parameter */
-#define HDMI_AUDIO_DEFAULT_TYPE			HDMI_AUDIO_LPCM
-#define HDMI_AUDIO_DEFAULT_CHANNEL		2
-#define HDMI_AUDIO_DEFAULT_RATE			HDMI_AUDIO_FS_44100
-#define HDMI_AUDIO_DEFAULT_WORDLENGTH	HDMI_AUDIO_WORD_LENGTH_16bit
-
-extern int hdmi_dbg_level;
-#define HDMIDBG(x, format, ...) do {			\
-	if (unlikely(hdmi_dbg_level >= x))	\
-		pr_info(format, ## __VA_ARGS__); \
-			} while (0)
-
-struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
-				    struct hdmi_ops *ops);
-void rockchip_hdmi_unregister(struct hdmi *hdmi);
-void hdmi_submit_work(struct hdmi *hdmi,
-		      int event, int delay, int sync);
-
-struct rk_display_device *hdmi_register_display_sysfs(struct hdmi *hdmi,
-						      struct device *parent);
-void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
-
-int hdmi_edid_parse_base(struct hdmi *hdmi, unsigned char *buf,
-			 int *extend_num, struct hdmi_edid *pedid);
-int hdmi_edid_parse_extensions(unsigned char *buf,
-			       struct hdmi_edid *pedid);
-
-void hdmi_init_modelist(struct hdmi *hdmi);
-int hdmi_set_lcdc(struct hdmi *hdmi);
-int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok);
-int hdmi_add_vic(int vic, struct list_head *head);
-int hdmi_find_best_mode(struct hdmi *hdmi, int vic);
-int hdmi_videomode_to_vic(struct fb_videomode *vmode);
-const struct fb_videomode *hdmi_vic_to_videomode(int vic);
-const struct hdmi_video_timing *hdmi_vic2timing(int vic);
-int hdmi_config_audio(struct hdmi_audio *audio);
-int hdmi_get_hotplug(void);
-int snd_config_hdmi_audio(struct snd_pcm_hw_params *params);
-#endif
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig
deleted file mode 100644
index bd92ea912860..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config  RK_HDMI_V1
-        bool "RockChip HDMI V1 support"
-        depends on RK_HDMI
-        help
-           Support rockchip hdmi version 1 if you say y here.
-
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile
deleted file mode 100644
index c1a66540f661..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for HDMI linux kernel module.
-#
-
-ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
-
-obj-$(CONFIG_RK_HDMI_V1) += rockchip_hdmiv1_hw.o rockchip_hdmiv1.o rockchip_hdmiv1_cec.o rockchip_hdmiv1_hdcp.o
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
deleted file mode 100644
index eaa3834bc199..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
+++ /dev/null
@@ -1,441 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/uaccess.h>
-
-#include <linux/of_gpio.h>
-#include <linux/rk_fb.h>
-
-#if defined(CONFIG_DEBUG_FS)
-#include <linux/fs.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#endif
-
-#include "rockchip_hdmiv1.h"
-#include "rockchip_hdmiv1_hw.h"
-
-static struct hdmi_dev *hdmi_dev;
-
-#if defined(CONFIG_DEBUG_FS)
-static int rockchip_hdmiv1_reg_show(struct seq_file *s, void *v)
-{
-	int i = 0;
-	u32 val = 0;
-
-	seq_puts(s, "\n\n>>>rk3036_ctl reg");
-	for (i = 0; i < 16; i++)
-		seq_printf(s, " %2x", i);
-
-	seq_puts(s,
-		 "\n-----------------------------------------------------------------");
-
-	for (i = 0; i <= PHY_PRE_DIV_RATIO; i++) {
-		hdmi_readl(hdmi_dev, i, &val);
-		if (i % 16 == 0)
-			seq_printf(s, "\n>>>rk3036_ctl %2x:", i);
-		seq_printf(s, " %02x", val);
-	}
-	seq_puts(s,
-		 "\n-----------------------------------------------------------------\n");
-
-	return 0;
-}
-
-static ssize_t rockchip_hdmiv1_reg_write(struct file *file,
-					 const char __user *buf,
-					 size_t count,
-					 loff_t *ppos)
-{
-	u32 reg;
-	u32 val;
-	char kbuf[25];
-	static int ret;
-	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
-
-	if (copy_from_user(kbuf, buf, count))
-		return -EFAULT;
-	ret = sscanf(kbuf, "%x%x", &reg, &val);
-	if ((reg < 0) || (reg > 0xed)) {
-		dev_info(hdmi_drv->dev, "it is no hdmi reg\n");
-		return count;
-	}
-	dev_info(hdmi_drv->dev, "/**********rk3036 reg config******/");
-	dev_info(hdmi_drv->dev, "\n reg=%x val=%x\n", reg, val);
-	hdmi_writel(hdmi_dev, reg, val);
-
-	return count;
-}
-
-static int rockchip_hdmiv1_reg_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rockchip_hdmiv1_reg_show, NULL);
-}
-
-static const struct file_operations rockchip_hdmiv1_reg_fops = {
-	.owner = THIS_MODULE,
-	.open = rockchip_hdmiv1_reg_open,
-	.read = seq_read,
-	.write = rockchip_hdmiv1_reg_write,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-#endif
-
-static int rockchip_hdmiv1_clk_enable(struct hdmi_dev *hdmi_dev)
-{
-	struct hdmi *hdmi_drv;
-
-	hdmi_drv =  hdmi_dev->hdmi;
-	if (!hdmi_dev->clk_on) {
-		if (hdmi_dev->soctype == HDMI_SOC_RK312X)
-			clk_prepare_enable(hdmi_dev->pd);
-
-		clk_prepare_enable(hdmi_dev->hclk);
-		spin_lock(&hdmi_dev->reg_lock);
-		hdmi_dev->clk_on = 1;
-		spin_unlock(&hdmi_dev->reg_lock);
-	}
-
-	return 0;
-}
-
-static int rockchip_hdmiv1_clk_disable(struct hdmi_dev *hdmi_dev)
-{
-	struct hdmi *hdmi_drv;
-
-	hdmi_drv =  hdmi_dev->hdmi;
-	if (hdmi_dev->clk_on) {
-		spin_lock(&hdmi_dev->reg_lock);
-		hdmi_dev->clk_on = 0;
-		spin_unlock(&hdmi_dev->reg_lock);
-		if (hdmi_dev->soctype == HDMI_SOC_RK312X)
-			clk_disable_unprepare(hdmi_dev->pd);
-		clk_disable_unprepare(hdmi_dev->hclk);
-	}
-
-	return 0;
-}
-
-static void rockchip_hdmiv1_early_suspend(void)
-{
-	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
-
-	dev_info(hdmi_drv->dev, "hdmi suspend\n");
-	hdmi_submit_work(hdmi_drv,
-			 HDMI_SUSPEND_CTL, 0, 1);
-	mutex_lock(&hdmi_drv->lock);
-	if (hdmi_dev->irq)
-		disable_irq(hdmi_dev->irq);
-	mutex_unlock(&hdmi_drv->lock);
-	rockchip_hdmiv1_clk_disable(hdmi_dev);
-}
-
-static void rockchip_hdmiv1_early_resume(void)
-{
-	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
-
-	dev_info(hdmi_drv->dev, "hdmi resume\n");
-	mutex_lock(&hdmi_drv->lock);
-	rockchip_hdmiv1_clk_enable(hdmi_dev);
-	rockchip_hdmiv1_initial(hdmi_drv);
-	if (hdmi_drv->enable && hdmi_dev->irq) {
-		rockchip_hdmiv1_irq(hdmi_drv);
-		enable_irq(hdmi_dev->irq);
-	}
-	mutex_unlock(&hdmi_drv->lock);
-	hdmi_submit_work(hdmi_drv, HDMI_RESUME_CTL, 0, 0);
-}
-
-static int rockchip_hdmiv1_fb_event_notify(struct notifier_block *self,
-					   unsigned long action,
-					   void *data)
-{
-	struct fb_event *event = data;
-
-	if (action == FB_EARLY_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			break;
-		default:
-			if (!hdmi_dev->hdmi->sleep)
-				rockchip_hdmiv1_early_suspend();
-			break;
-		}
-	} else if (action == FB_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			if (hdmi_dev->hdmi->sleep)
-				rockchip_hdmiv1_early_resume();
-			break;
-		default:
-			break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block rockchip_hdmiv1_fb_notifier = {
-	.notifier_call = rockchip_hdmiv1_fb_event_notify,
-};
-
-static irqreturn_t rockchip_hdmiv1_irq_func(int irq, void *dev_id)
-{
-	struct hdmi *hdmi_drv = hdmi_dev->hdmi;
-
-	rockchip_hdmiv1_irq(hdmi_drv);
-
-	return IRQ_HANDLED;
-}
-
-static struct hdmi_property rockchip_hdmiv1_property = {
-	.videosrc = DISPLAY_SOURCE_LCDC0,
-	.display = DISPLAY_MAIN,
-};
-
-static struct hdmi_ops rockchip_hdmiv1_ops;
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rockchip_hdmiv1_dt_ids[] = {
-	{.compatible = "rockchip,rk3036-hdmi"},
-	{.compatible = "rockchip,rk312x-hdmi"},
-	{}
-};
-
-static int rockchip_hdmiv1_parse_dt(struct hdmi_dev *hdmi_dev)
-{
-	int val = 0;
-	struct device_node *np = hdmi_dev->dev->of_node;
-	const struct of_device_id *match;
-
-	match = of_match_node(rockchip_hdmiv1_dt_ids, np);
-	if (!match)
-		return -EINVAL;
-
-	if (!strcmp(match->compatible, "rockchip,rk3036-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK3036;
-	} else if (!strcmp(match->compatible, "rockchip,rk312x-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK312X;
-	} else {
-		pr_err("It is not a valid rockchip soc!");
-		return -ENOMEM;
-	}
-
-	if (!of_property_read_u32(np, "rockchip,hdmi_video_source", &val))
-		rockchip_hdmiv1_property.videosrc = val;
-
-	if (!of_property_read_u32(np, "rockchip,hdmi_audio_source", &val))
-		hdmi_dev->audiosrc = val;
-
-	if (!of_property_read_u32(np, "rockchip,cec_enable", &val) &&
-	    (val == 1)) {
-		pr_debug("hdmi support cec\n");
-		rockchip_hdmiv1_property.feature |= SUPPORT_CEC;
-	}
-	if (!of_property_read_u32(np, "rockchip,hdcp_enable", &val) &&
-	    (val == 1)) {
-		pr_debug("hdmi support hdcp\n");
-		rockchip_hdmiv1_property.feature |= SUPPORT_HDCP;
-	}
-	if (!of_property_read_u32(np, "rockchip,defaultmode", &val) &&
-	    (val > 0)) {
-		pr_debug("default mode is %d\n", val);
-		rockchip_hdmiv1_property.defaultmode = val;
-	} else {
-		rockchip_hdmiv1_property.defaultmode =
-						HDMI_VIDEO_DEFAULT_MODE;
-	}
-
-	return 0;
-}
-MODULE_DEVICE_TABLE(of, rockchip_hdmiv1_dt_ids);
-#endif
-
-static int rockchip_hdmiv1_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-
-	hdmi_dev = devm_kzalloc(&pdev->dev,
-				sizeof(struct hdmi_dev),
-				GFP_KERNEL);
-	if (!hdmi_dev) {
-		dev_err(&pdev->dev, ">>rk_hdmi kmalloc fail!");
-		return -ENOMEM;
-	}
-	hdmi_dev->dev = &pdev->dev;
-	platform_set_drvdata(pdev, hdmi_dev);
-	spin_lock_init(&hdmi_dev->reg_lock);
-	rockchip_hdmiv1_parse_dt(hdmi_dev);
-	/* request and remap iomem */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(hdmi_dev->dev, "Unable to get register resource\n");
-		ret = -ENXIO;
-		goto failed;
-	}
-	hdmi_dev->regbase_phy = res->start;
-	hdmi_dev->regsize_phy = resource_size(res);
-	hdmi_dev->regbase = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(hdmi_dev->regbase)) {
-		ret = PTR_ERR(hdmi_dev->regbase);
-		dev_err(hdmi_dev->dev, "cannot ioremap registers,err=%d\n",
-			ret);
-		goto failed;
-	}
-	if (hdmi_dev->soctype == HDMI_SOC_RK312X) {
-		hdmi_dev->pd = devm_clk_get(hdmi_dev->dev, "pd_hdmi");
-		if (IS_ERR(hdmi_dev->pd)) {
-			dev_err(hdmi_dev->hdmi->dev, "Unable to get hdmi pd\n");
-			ret = -ENXIO;
-			goto failed;
-		}
-	}
-	hdmi_dev->hclk = devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
-	if (IS_ERR(hdmi_dev->hclk)) {
-		dev_err(hdmi_dev->hdmi->dev, "Unable to get hdmi hclk\n");
-		ret = -ENXIO;
-		goto failed;
-	}
-	/* enable clk */
-	rockchip_hdmiv1_clk_enable(hdmi_dev);
-	hdmi_dev->hclk_rate = clk_get_rate(hdmi_dev->hclk);
-
-	rockchip_hdmiv1_dev_init_ops(&rockchip_hdmiv1_ops);
-	rockchip_hdmiv1_property.name = (char *)pdev->name;
-	rockchip_hdmiv1_property.priv = hdmi_dev;
-	if (rk_fb_get_display_policy() == DISPLAY_POLICY_BOX)
-		rockchip_hdmiv1_property.feature |= SUPPORT_1080I |
-						    SUPPORT_480I_576I;
-	hdmi_dev->hdmi = rockchip_hdmi_register(&rockchip_hdmiv1_property,
-						&rockchip_hdmiv1_ops);
-	if (!hdmi_dev->hdmi) {
-		dev_err(&pdev->dev, "register hdmi device failed\n");
-		ret = -ENOMEM;
-		goto failed;
-	}
-	hdmi_dev->hdmi->dev = &pdev->dev;
-
-	fb_register_client(&rockchip_hdmiv1_fb_notifier);
-	rockchip_hdmiv1_initial(hdmi_dev->hdmi);
-
-	rk_display_device_enable(hdmi_dev->hdmi->ddev);
-	hdmi_submit_work(hdmi_dev->hdmi, HDMI_HPD_CHANGE, 0, 1);
-
-#if defined(CONFIG_DEBUG_FS)
-	hdmi_dev->debugfs_dir = debugfs_create_dir("rockchip_hdmiv1", NULL);
-	if (IS_ERR(hdmi_dev->debugfs_dir)) {
-		dev_err(hdmi_dev->hdmi->dev,
-			"failed to create debugfs dir for hdmi!\n");
-	} else {
-		debugfs_create_file("hdmi", S_IRUSR,
-				    hdmi_dev->debugfs_dir, hdmi_dev->hdmi,
-				    &rockchip_hdmiv1_reg_fops);
-	}
-#endif
-
-	/* get the IRQ */
-	hdmi_dev->irq = platform_get_irq(pdev, 0);
-	if (hdmi_dev->irq <= 0) {
-		dev_err(hdmi_dev->hdmi->dev, "failed to get hdmi irq resource (%d).\n",
-			hdmi_dev->irq);
-		hdmi_dev->irq = 0;
-	} else {
-		/* request the IRQ */
-		ret = devm_request_irq(hdmi_dev->hdmi->dev,
-				       hdmi_dev->irq,
-				       rockchip_hdmiv1_irq_func,
-				       IRQF_TRIGGER_HIGH,
-				       dev_name(hdmi_dev->hdmi->dev),
-				       hdmi_dev->hdmi);
-		if (ret) {
-			dev_err(hdmi_dev->hdmi->dev, "hdmi request_irq failed (%d)\n",
-				ret);
-			goto failed1;
-		}
-	}
-	dev_info(hdmi_dev->hdmi->dev, "hdmi probe success.\n");
-	return 0;
-
-failed1:
-	rockchip_hdmi_unregister(hdmi_dev->hdmi);
-failed:
-	hdmi_dev = NULL;
-	dev_err(&pdev->dev, "rk3288 hdmi probe error.\n");
-	return ret;
-}
-
-static int rockchip_hdmiv1_remove(struct platform_device *pdev)
-{
-	struct hdmi *hdmi_drv = NULL;
-
-	hdmi_drv = hdmi_dev->hdmi;
-	rockchip_hdmi_unregister(hdmi_drv);
-	return 0;
-}
-
-static void rockchip_hdmiv1_shutdown(struct platform_device *pdev)
-{
-	struct hdmi_dev *hdmi_dev = platform_get_drvdata(pdev);
-	struct hdmi *hdmi_drv = NULL;
-
-	if (hdmi_dev) {
-		hdmi_drv = hdmi_dev->hdmi;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi_drv->early_suspend);
-#endif
-		mutex_lock(&hdmi_drv->lock);
-		hdmi_drv->sleep = 1;
-		if (!hdmi_drv->enable) {
-			mutex_unlock(&hdmi_drv->lock);
-			return;
-		}
-		if (hdmi_dev->irq)
-			disable_irq(hdmi_dev->irq);
-		mutex_unlock(&hdmi_drv->lock);
-		if (hdmi_drv->hotplug == HDMI_HPD_ACTIVATED)
-			hdmi_drv->ops->setmute(hdmi_drv,
-					       HDMI_VIDEO_MUTE |
-					       HDMI_AUDIO_MUTE);
-		rockchip_hdmiv1_clk_disable(hdmi_dev);
-	}
-	dev_info(hdmi_drv->dev, "rk hdmi shut down.\n");
-}
-
-static struct platform_driver rockchip_hdmiv1_driver = {
-	.probe = rockchip_hdmiv1_probe,
-	.remove = rockchip_hdmiv1_remove,
-	.driver = {
-		.name = "rk-hdmi",
-		.owner = THIS_MODULE,
-		#if defined(CONFIG_OF)
-		.of_match_table = of_match_ptr(rockchip_hdmiv1_dt_ids),
-		#endif
-	},
-	.shutdown = rockchip_hdmiv1_shutdown,
-};
-
-static int __init rockchip_hdmiv1_init(void)
-{
-	return platform_driver_register(&rockchip_hdmiv1_driver);
-}
-
-static void __exit rockchip_hdmiv1_exit(void)
-{
-	platform_driver_unregister(&rockchip_hdmiv1_driver);
-}
-
-module_init(rockchip_hdmiv1_init);
-module_exit(rockchip_hdmiv1_exit);
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
deleted file mode 100644
index ba9a4720f139..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROCKCHIP_HDMI_V1_H__
-#define __ROCKCHIP_HDMI_V1_H__
-
-#include "../rockchip-hdmi.h"
-
-struct hdmi_dev {
-	void __iomem		*regbase;
-	int			regbase_phy;
-	int			regsize_phy;
-
-	struct clk		*pd;
-	struct clk		*hclk;
-	unsigned int		hclk_rate;
-
-	struct hdmi		*hdmi;
-	struct device		*dev;
-	struct dentry		*debugfs_dir;
-	int			irq;
-
-	struct work_struct	irq_work;
-	struct delayed_work	delay_work;
-	struct workqueue_struct *workqueue;
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend	early_suspend;
-#endif
-	int			soctype;
-	int			audiosrc;
-	int			enable;
-	unsigned char		clk_disable;
-	unsigned char		clk_on;
-	spinlock_t		reg_lock;	/* lock for clk */
-
-	unsigned int		tmdsclk;
-	unsigned int		pixelrepeat;
-	int			pwr_mode;
-};
-#endif /* __RK3036_HDMI_H__ */
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
deleted file mode 100644
index 6d0f61cf45c0..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
+++ /dev/null
@@ -1,153 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include "rockchip_hdmiv1.h"
-#include "rockchip_hdmiv1_hw.h"
-#include "../rockchip-hdmi-cec.h"
-
-struct cec_t {
-	wait_queue_head_t wait;
-	int busfree;
-	int tx_done;
-};
-
-static int init = 1;
-static struct cec_t cec;
-
-static int rockchip_hdmiv1_cec_read_frame(struct hdmi *hdmi,
-					  struct cec_framedata *frame)
-{
-	int i, length, val;
-	char *data = (char *)frame;
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (!frame)
-		return -1;
-
-	hdmi_readl(hdmi_dev, CEC_RX_LENGTH, &length);
-	hdmi_writel(hdmi_dev, CEC_RX_OFFSET, 0);
-
-	HDMIDBG(1, "CEC: %s length is %d\n", __func__, length);
-	for (i = 0; i < length; i++) {
-		hdmi_readl(hdmi_dev, CEC_DATA, &val);
-		data[i] = val;
-		pr_info("%02x\n", data[i]);
-	}
-	return 0;
-}
-
-static int rockchip_hdmiv1_cec_send_frame(struct hdmi *hdmi,
-					  struct cec_framedata *frame)
-{
-	int i;
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(1, "CEC: TX srcdestaddr %x opcode %x ",
-		frame->srcdestaddr, frame->opcode);
-	if (frame->argcount) {
-		HDMIDBG(1, "args:");
-		for (i = 0; i < frame->argcount; i++)
-			HDMIDBG(1, "%02x ", frame->args[i]);
-	}
-	HDMIDBG(1, "\n");
-
-	hdmi_writel(hdmi_dev, CEC_TX_OFFSET, 0);
-	hdmi_writel(hdmi_dev, CEC_DATA, frame->srcdestaddr);
-	hdmi_writel(hdmi_dev, CEC_DATA, frame->opcode);
-
-	for (i = 0; i < frame->argcount; i++)
-		hdmi_writel(hdmi_dev, CEC_DATA, frame->args[i]);
-
-	hdmi_writel(hdmi_dev, CEC_TX_LENGTH, frame->argcount + 2);
-
-	/*Wait for bus free*/
-	cec.busfree = 1;
-	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE);
-	HDMIDBG(1, "start wait bus free\n");
-	if (wait_event_interruptible_timeout(cec.wait,
-					     cec.busfree == 0,
-					     msecs_to_jiffies(17)))
-		return CEC_SEND_BUSY;
-
-	HDMIDBG(1, "end wait bus free,start tx,busfree=%d\n", cec.busfree);
-	/*Start TX*/
-	cec.tx_done = 0;
-	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE | m_START_TX);
-	if (wait_event_interruptible_timeout(cec.wait,
-					     cec.tx_done != 0,
-					     msecs_to_jiffies(100)))
-		hdmi_writel(hdmi_dev, CEC_CTRL, 0);
-	HDMIDBG(1, "end tx,tx_done=%d\n", cec.tx_done);
-
-	if (cec.tx_done == 1) {
-		cec.tx_done = 0;
-		return CEC_SEND_SUCCESS;
-	} else {
-		return CEC_SEND_NACK;
-	}
-}
-
-void rockchip_hdmiv1_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(1, "CEC: %s\n", __func__);
-	hdmi_writel(hdmi_dev, CEC_LOGICADDR, ceclgaddr);
-}
-
-void rockchip_hdmiv1_cec_isr(struct hdmi_dev *hdmi_dev)
-{
-	int tx_isr = 0, rx_isr = 0;
-
-	hdmi_readl(hdmi_dev, CEC_TX_INT, &tx_isr);
-	hdmi_readl(hdmi_dev, CEC_RX_INT, &rx_isr);
-
-	HDMIDBG(1, "CEC: rockchip_hdmiv1_cec_isr:tx_isr %02x  rx_isr %02x\n\n",
-		tx_isr, rx_isr);
-
-	hdmi_writel(hdmi_dev, CEC_TX_INT, tx_isr);
-	hdmi_writel(hdmi_dev, CEC_RX_INT, rx_isr);
-
-	if (tx_isr & m_TX_BUSNOTFREE) {
-		cec.busfree = 0;
-		HDMIDBG(1, "CEC: m_TX_BUSNOTFREE,busfree=%d\n", cec.busfree);
-	} else if (tx_isr & m_TX_DONE) {
-		cec.tx_done = 1;
-		HDMIDBG(1, "CEC: m_TX_DONE,busfree=%d\n", cec.tx_done);
-	} else {
-		cec.tx_done = -1;
-		HDMIDBG(1, "CEC: else:busfree=%d\n", cec.tx_done);
-	}
-
-	wake_up_interruptible_all(&cec.wait);
-	if (rx_isr & m_RX_DONE)
-		rockchip_hdmi_cec_submit_work(EVENT_RX_FRAME, 0, NULL);
-}
-
-void rockchip_hdmiv1_cec_init(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (init) {
-		/*Fref = Fsys / ((register 0xd4 + 1)*(register 0xd5 + 1))*/
-		/*Fref = 0.5M, Fsys = 74.25M*/
-		hdmi_writel(hdmi_dev, CEC_CLK_H, 11);
-		hdmi_writel(hdmi_dev, CEC_CLK_L, 11);
-
-		/*Set bus free time to 16.8ms*/
-		hdmi_writel(hdmi_dev, CEC_BUSFREETIME_L, 0xd0);
-		hdmi_writel(hdmi_dev, CEC_BUSFREETIME_H, 0x20);
-
-		/*Enable TX/RX INT*/
-		hdmi_writel(hdmi_dev, CEC_TX_INT, 0xFF);
-		hdmi_writel(hdmi_dev, CEC_RX_INT, 0xFF);
-
-		HDMIDBG(1, "CEC: rockchip_hdmiv1_cec_init sucess\n");
-		rockchip_hdmi_cec_init(hdmi,
-				       rockchip_hdmiv1_cec_send_frame,
-				       rockchip_hdmiv1_cec_read_frame,
-				       rockchip_hdmiv1_cec_setcecla);
-		init = 0;
-		init_waitqueue_head(&cec.wait);
-	}
-	HDMIDBG(1, "%s", __func__);
-}
-
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
deleted file mode 100644
index e104010444f0..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
+++ /dev/null
@@ -1,835 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/miscdevice.h>
-#include <linux/workqueue.h>
-#include <linux/firmware.h>
-#include <linux/timer.h>
-#include <linux/jiffies.h>
-#include "rockchip_hdmiv1.h"
-#include "rockchip_hdmiv1_hdcp.h"
-#include "rockchip_hdmiv1_hw.h"
-
-static struct hdcp *hdcp;
-
-static void hdcp_work_queue(struct work_struct *work);
-
-#define AUTH_TIMEOUT (2 * HZ)
-static struct timer_list auth_timer;
-static int timer_state;
-
-static int is_1b_03_test(struct hdmi_dev *hdmi_dev)
-{
-	int reg_value;
-	int reg_val_1;
-
-	hdmi_readl(hdmi_dev, 0x58, &reg_value);
-	hdmi_readl(hdmi_dev, 0xc3, &reg_val_1);
-
-	if (reg_value != 0) {
-		if ((reg_val_1 & 0x40) == 0)
-			return 1;
-	}
-	return 0;
-}
-
-static void rockchip_hdmiv1_set_colorbar(struct hdmi_dev *hdmi_dev,
-					 int enable)
-{
-	static int display_mask;
-	int reg_value;
-	int tmds_clk;
-
-	tmds_clk = hdmi_dev->tmdsclk;
-	if (enable) {
-		if (!display_mask) {
-			if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
-				hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
-				hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-					     m_REG_CLK_SOURCE,
-					     v_REG_CLK_SOURCE_SYS);
-				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x00);
-				hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
-			} else {
-				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x00);
-			}
-			display_mask = 1;
-		}
-	} else {
-		if (display_mask) {
-			if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
-				hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
-				hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-					     m_REG_CLK_SOURCE,
-					     v_REG_CLK_SOURCE_SYS);
-				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x10);
-				hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
-			} else {
-				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x10);
-			}
-			display_mask = 0;
-		}
-	}
-}
-
-static void rockchip_hdmiv1_hdcp_disable(struct hdmi_dev *hdmi_dev)
-{
-	int reg_value;
-	int tmds_clk;
-
-	tmds_clk = hdmi_dev->tmdsclk;
-	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
-		hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
-	}
-
-	/* Disable HDCP Interrupt */
-	hdmi_writel(hdmi_dev, HDCP_INT_MASK1, 0x00);
-	/* Stop and Reset HDCP*/
-	hdmi_msk_reg(hdmi_dev, HDCP_CTRL1,
-		     m_AUTH_START | m_AUTH_STOP | m_HDCP_RESET,
-		     v_AUTH_START(0) | v_AUTH_STOP(1) | v_HDCP_RESET(1));
-
-	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
-		hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
-}
-
-static int rockchip_hdmiv1_hdcp_key_check(struct hdcp_keys *key)
-{
-	int i = 0;
-
-	HDMIDBG(3, "HDCP: check hdcp key\n");
-	/*check 40 private key */
-	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++) {
-		if (key->devicekey[i] != 0x00)
-			return HDCP_KEY_VALID;
-	}
-	/*check aksv*/
-	for (i = 0; i < 5; i++) {
-		if (key->ksv[i] != 0x00)
-			return HDCP_KEY_VALID;
-	}
-
-	return HDCP_KEY_INVALID;
-}
-
-static int rockchip_hdmiv1_hdcp_load_key2mem(void)
-{
-	int i;
-	struct hdmi_dev *hdmi_dev;
-	struct hdcp_keys *key;
-
-	if (!hdcp)
-		return -1;
-	hdmi_dev = hdcp->hdmi_dev;
-	key = hdcp->keys;
-	HDMIDBG(3, "HDCP: rockchip_hdmiv1_hdcp_load_key2mem start\n");
-	/* Write 40 private key*/
-	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++)
-		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->devicekey[i]);
-	/* Write 1st aksv*/
-	for (i = 0; i < 5; i++)
-		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->ksv[i]);
-	/* Write 2nd aksv*/
-	for (i = 0; i < 5; i++)
-		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->ksv[i]);
-	HDMIDBG(3, "HDCP: rockchip_hdmiv1_hdcp_load_key2mem end\n");
-	return HDCP_OK;
-}
-
-static int rockchip_hdmiv1_hdcp_start_authentication(struct hdmi_dev *hdmi_dev)
-{
-	int temp;
-	int retry = 0;
-	int tmds_clk;
-
-	tmds_clk = hdmi_dev->tmdsclk;
-	if (!hdcp->keys) {
-		HDCP_WARN("HDCP: key is not loaded\n");
-		return HDCP_KEY_ERR;
-	}
-	if (rockchip_hdmiv1_hdcp_key_check(hdcp->keys) == HDCP_KEY_INVALID) {
-		HDCP_WARN("loaded HDCP key is incorrect\n");
-		return HDCP_KEY_ERR;
-	}
-	if (tmds_clk > (HDMI_SYS_FREG_CLK << 2)) {
-		/*Select TMDS CLK to configure regs*/
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_TMDS);
-	} else {
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
-	}
-	hdmi_writel(hdmi_dev, HDCP_TIMER_100MS, 0x28);
-	hdmi_readl(hdmi_dev, HDCP_KEY_STATUS, &temp);
-	while ((temp & m_KEY_READY) == 0) {
-		if (retry > 1000) {
-			HDCP_WARN("HDCP: loaded key error\n");
-			return HDCP_KEY_ERR;
-		}
-		rockchip_hdmiv1_hdcp_load_key2mem();
-		usleep_range(900, 1000);
-		hdmi_readl(hdmi_dev, HDCP_KEY_STATUS, &temp);
-		retry++;
-	}
-	/*Config DDC bus clock: ddc_clk = reg_clk/4*(reg 0x4c 0x4b)*/
-	retry = hdmi_dev->hclk_rate / (HDCP_DDC_CLK << 2);
-	hdmi_writel(hdmi_dev, DDC_CLK_L, retry & 0xFF);
-	hdmi_writel(hdmi_dev, DDC_CLK_H, (retry >> 8) & 0xFF);
-	hdmi_writel(hdmi_dev, HDCP_CTRL2, 0x67);
-	/*Enable interrupt*/
-	hdmi_writel(hdmi_dev, HDCP_INT_MASK1,
-		    m_INT_HDCP_ERR | m_INT_BKSV_READY | m_INT_BKSV_UPDATE |
-		    m_INT_AUTH_SUCCESS | m_INT_AUTH_READY);
-	hdmi_writel(hdmi_dev, HDCP_INT_MASK2, 0x00);
-	/*Start authentication*/
-	hdmi_msk_reg(hdmi_dev, HDCP_CTRL1,
-		     m_AUTH_START | m_ENCRYPT_ENABLE | m_ADVANED_ENABLE |
-		     m_AUTH_STOP | m_HDCP_RESET,
-		     v_AUTH_START(1) | v_ENCRYPT_ENABLE(1) |
-		     v_ADVANED_ENABLE(0) | v_AUTH_STOP(0) | v_HDCP_RESET(0));
-
-	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_REG_CLK_SOURCE,
-			     v_REG_CLK_SOURCE_TMDS);
-	}
-	return HDCP_OK;
-}
-
-static int rockchip_hdmiv1_hdcp_stop_authentication(struct hdmi_dev *hdmi_dev)
-{
-	hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-		     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
-	hdmi_writel(hdmi_dev, DDC_CLK_L, 0x1c);
-	hdmi_writel(hdmi_dev, DDC_CLK_H, 0x00);
-	hdmi_writel(hdmi_dev, HDCP_CTRL2, 0x08);
-	hdmi_writel(hdmi_dev, HDCP_INT_MASK2, 0x06);
-	hdmi_writel(hdmi_dev, HDCP_CTRL1, 0x02);
-	return 0;
-	/*hdmi_writel(HDCP_CTRL1, 0x0a);*/
-}
-
-static int rockchip_hdmiv1_hdcp_error(int value)
-{
-	if (value & 0x80)
-		HDCP_WARN("Timed out waiting for downstream repeater\n");
-	else if (value & 0x40)
-		HDCP_WARN("Too many devices connected to repeater tree\n");
-	else if (value & 0x20)
-		HDCP_WARN("SHA-1 hash check of BKSV list failed\n");
-	else if (value & 0x10)
-		HDCP_WARN("SHA-1 hash check of BKSV list failed\n");
-	else if (value & 0x08)
-		HDCP_WARN("DDC channels no acknowledge\n");
-	else if (value & 0x04)
-		HDCP_WARN("Pj mismatch\n");
-	else if (value & 0x02)
-		HDCP_WARN("Ri mismatch\n");
-	else if (value & 0x01)
-		HDCP_WARN("Bksv is wrong\n");
-	else
-		return 0;
-	return 1;
-}
-
-static void rockchip_hdmiv1_hdcp_interrupt(struct hdmi_dev *hdmi_dev,
-					   char *status1, char *status2)
-{
-	int interrupt1 = 0;
-	int interrupt2 = 0;
-	int temp = 0;
-	int tmds_clk;
-
-	tmds_clk = hdmi_dev->tmdsclk;
-	hdmi_readl(hdmi_dev, HDCP_INT_STATUS1, &interrupt1);
-	hdmi_readl(hdmi_dev, HDCP_INT_STATUS2, &interrupt2);
-
-	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
-			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
-
-	if (interrupt1) {
-		hdmi_writel(hdmi_dev, HDCP_INT_STATUS1, interrupt1);
-		if (interrupt1 & m_INT_HDCP_ERR) {
-			hdmi_readl(hdmi_dev, HDCP_ERROR, &temp);
-			HDCP_WARN("HDCP: Error reg 0x65 = 0x%02x\n", temp);
-			rockchip_hdmiv1_hdcp_error(temp);
-			hdmi_writel(hdmi_dev, HDCP_ERROR, temp);
-		}
-	}
-	if (interrupt2)
-		hdmi_writel(hdmi_dev, HDCP_INT_STATUS2, interrupt2);
-
-	*status1 = interrupt1;
-	*status2 = interrupt2;
-
-	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_REG_CLK_SOURCE,
-			     v_REG_CLK_SOURCE_TMDS);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_submit_work
- *-----------------------------------------------------------------------------
- */
-static struct delayed_work *hdcp_submit_work(int event, int delay)
-{
-	struct hdcp_delayed_work *work;
-
-	HDMIDBG(3, "%s event %04x delay %d\n", __func__, event, delay);
-	work = kmalloc(sizeof(*work), GFP_ATOMIC);
-
-	if (work) {
-		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
-		work->event = event;
-		queue_delayed_work(hdcp->workqueue,
-				   &work->work,
-				   msecs_to_jiffies(delay));
-	} else {
-		HDCP_WARN("HDCP:Cannot allocate memory to create work\n");
-		return 0;
-	}
-
-	return &work->work;
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_cancel_work
- *-----------------------------------------------------------------------------
- */
-static void hdcp_cancel_work(struct delayed_work **work)
-{
-	int ret = 0;
-
-	if (*work) {
-		ret = cancel_delayed_work(*work);
-		if (ret != 1) {
-			ret = cancel_work_sync(&((*work)->work));
-			HDCP_WARN("Canceling sync work failed %d\n", ret);
-		}
-		kfree(*work);
-		*work = 0;
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: auth_timer_func
- *-----------------------------------------------------------------------------
- */
-static void auth_timer_func(unsigned long data)
-{
-	HDCP_WARN("hdcp auth 2 second timeout\n");
-	if (hdcp->auth_state == 0) {
-		mod_timer(&auth_timer, jiffies + AUTH_TIMEOUT);
-		if ((hdcp->hdcp_state != HDCP_DISABLED) &&
-		    (hdcp->hdcp_state != HDCP_ENABLE_PENDING)) {
-			if (is_1b_03_test(hdcp->hdmi_dev))
-				return;
-			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
-		}
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_authentication_failure
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_authentication_failure(void)
-{
-	if (hdcp->hdmi_state == HDMI_STOPPED)
-		return;
-
-	rockchip_hdmiv1_hdcp_disable(hdcp->hdmi_dev);
-
-	/* rockchip_hdmiv1_hdmi_control_output(false); */
-
-	rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 1);
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-	if (hdcp->retry_cnt && (hdcp->hdmi_state != HDMI_STOPPED)) {
-		if (hdcp->retry_cnt <= HDCP_INFINITE_REAUTH) {
-			hdcp->retry_cnt--;
-			HDCP_WARN("authentication failed attempts=%d\n",
-				  hdcp->retry_cnt);
-		} else {
-			HDCP_WARN("authentication failed retrying\n");
-		}
-		hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
-
-		if (hdcp->auth_state == 1 && timer_state == 0) {
-			HDMIDBG(3, "add auth timer\n");
-			hdcp->auth_state = 0;
-			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-			auth_timer.expires = jiffies + AUTH_TIMEOUT;
-			add_timer(&auth_timer);
-			timer_state = 1;
-		}
-
-		hdcp->pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
-							 HDCP_REAUTH_DELAY);
-	} else {
-		HDCP_WARN("authentication failed HDCP disabled\n");
-		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-
-		if (timer_state == 1) {
-			HDMIDBG(3, "delete auth timer\n");
-			del_timer_sync(&auth_timer);
-			timer_state = 0;
-		}
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_start_authentication
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_start_authentication(void)
-{
-	int status = HDCP_OK;
-
-	hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
-	HDMIDBG(3, "HDCP: authentication start\n");
-	status = rockchip_hdmiv1_hdcp_start_authentication(hdcp->hdmi_dev);
-	if (status != HDCP_OK) {
-		HDMIDBG(3, "HDCP: authentication failed\n");
-		hdcp_wq_authentication_failure();
-	} else {
-		/*hdcp->hdcp_state = HDCP_WAIT_KSV_LIST;*/
-		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
-	}
-}
-
-#if 0
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_check_bksv
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_check_bksv(void)
-{
-	int status = HDCP_OK;
-
-	DBG("Check BKSV start");
-	status = rockchip_hdmiv1_hdcp_check_bksv();
-	if (status != HDCP_OK) {
-		HDCP_WARN("HDCP: Check BKSV failed");
-		hdcp->retry_cnt = 0;
-		hdcp_wq_authentication_failure();
-	} else {
-		DBG("HDCP: Check BKSV successful");
-		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
-		/* Restore retry counter */
-		if (hdcp->retry_times == 0)
-			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-		else
-			hdcp->retry_cnt = hdcp->retry_times;
-	}
-}
-#endif
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_authentication_success
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_authentication_success(void)
-{
-	hdcp->auth_state = 1;
-	if (timer_state == 1) {
-		HDMIDBG(3, "delete auth timer\n");
-		timer_state = 0;
-		del_timer_sync(&auth_timer);
-	}
-
-	rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 0);
-	HDCP_WARN("HDCP: authentication pass\n");
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_disable
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_disable(int event)
-{
-	HDCP_WARN("HDCP: disabled\n");
-
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-	rockchip_hdmiv1_hdcp_disable(hdcp->hdmi_dev);
-	if (event == HDCP_DISABLE_CTL) {
-		hdcp->hdcp_state = HDCP_DISABLED;
-		if (hdcp->hdmi_state == HDMI_STARTED)
-			rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 0);
-	} else if (event == HDCP_STOP_FRAME_EVENT) {
-		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_work_queue
- *-----------------------------------------------------------------------------
- */
-static void hdcp_work_queue(struct work_struct *work)
-{
-	struct hdcp_delayed_work *hdcp_w =
-		container_of(work, struct hdcp_delayed_work, work.work);
-	int event = hdcp_w->event;
-
-	mutex_lock(&hdcp->lock);
-	HDMIDBG(3, "%s - START - %u hdmi=%d hdcp=%d evt= %x %d\n",
-		__func__,
-		jiffies_to_msecs(jiffies),
-		hdcp->hdmi_state,
-		hdcp->hdcp_state,
-		(event & 0xFF00) >> 8,
-		event & 0xFF);
-
-	if (event == HDCP_STOP_FRAME_EVENT)
-		hdcp->hdmi_state = HDMI_STOPPED;
-	if (event == HDCP_DISABLE_CTL || event == HDCP_STOP_FRAME_EVENT)
-		hdcp_wq_disable(event);
-	if (event & HDCP_WORKQUEUE_SRC)
-		hdcp->pending_wq_event = 0;
-	/* First handle HDMI state */
-	if (event == HDCP_START_FRAME_EVENT) {
-		hdcp->pending_start = 0;
-		hdcp->hdmi_state = HDMI_STARTED;
-	}
-
-	/**********************/
-	/* HDCP state machine */
-	/**********************/
-	switch (hdcp->hdcp_state) {
-	case HDCP_DISABLED:
-		/* HDCP enable control or re-authentication event */
-		if (event == HDCP_ENABLE_CTL) {
-			#if 0
-			if (hdcp->retry_times == 0)
-				hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-			else
-				hdcp->retry_cnt = hdcp->retry_times;
-			#endif
-			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-			if (hdcp->hdmi_state == HDMI_STARTED)
-				hdcp_wq_start_authentication();
-			else
-				hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-		}
-		break;
-	case HDCP_ENABLE_PENDING:
-		/* HDMI start frame event */
-		if (event == HDCP_START_FRAME_EVENT)
-			hdcp_wq_start_authentication();
-		break;
-	case HDCP_AUTHENTICATION_START:
-		/* Re-authentication */
-		if (event == HDCP_AUTH_REATT_EVENT)
-			hdcp_wq_start_authentication();
-		break;
-#if 0
-	case HDCP_WAIT_KSV_LIST:
-		/* KSV failure */
-		if (event == HDCP_FAIL_EVENT) {
-			HDCP_WARN("HDCP: KSV switch failure\n");
-			hdcp_wq_authentication_failure();
-		}
-		/* KSV list ready event */
-		else if (event == HDCP_KSV_LIST_RDY_EVENT)
-			hdcp_wq_check_bksv();
-		break;
-#endif
-	case HDCP_LINK_INTEGRITY_CHECK:
-		/* authentication failure */
-		if (event == HDCP_FAIL_EVENT) {
-			HDCP_WARN("HDCP: Ri check failure\n");
-			hdcp_wq_authentication_failure();
-		} else if (event == HDCP_AUTH_PASS_EVENT) {
-			hdcp_wq_authentication_success();
-		}
-		break;
-	default:
-		HDCP_WARN("HDCP: error - unknown HDCP state\n");
-		break;
-	}
-	kfree(hdcp_w);
-	if (event == HDCP_STOP_FRAME_EVENT)
-		complete(&hdcp->complete);
-	mutex_unlock(&hdcp->lock);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_start_frame_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_start_frame_cb(struct hdmi *hdmi)
-{
-	HDMIDBG(3, "hdcp_start_frame_cb()\n");
-
-	/* Cancel any pending work */
-	if (hdcp->pending_start)
-		hdcp_cancel_work(&hdcp->pending_start);
-	if (hdcp->pending_wq_event)
-		hdcp_cancel_work(&hdcp->pending_wq_event);
-
-	if (timer_state == 0) {
-		HDMIDBG(3, "add auth timer\n");
-		auth_timer.expires = jiffies + AUTH_TIMEOUT;
-		add_timer(&auth_timer);
-		timer_state = 1;
-	}
-
-	hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-	hdcp->pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
-					       HDCP_ENABLE_DELAY);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_irq_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_irq_cb(int status)
-{
-	char interrupt1;
-	char interrupt2;
-
-	rockchip_hdmiv1_hdcp_interrupt(hdcp->hdmi_dev,
-				       &interrupt1,
-				       &interrupt2);
-	HDMIDBG(3, "%s 0x%02x 0x%02x\n", __func__, interrupt1, interrupt2);
-	if (interrupt1 & m_INT_HDCP_ERR) {
-		if ((hdcp->hdcp_state != HDCP_DISABLED) &&
-		    (hdcp->hdcp_state != HDCP_ENABLE_PENDING))
-			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
-	}
-	#if 0
-	else if (interrupt1 & (m_INT_BKSV_READY | m_INT_BKSV_UPDATE))
-		hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
-	#endif
-	else if (interrupt1 & m_INT_AUTH_SUCCESS)
-		hdcp_submit_work(HDCP_AUTH_PASS_EVENT, 0);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_power_on_cb
- *-----------------------------------------------------------------------------
- */
-static int hdcp_power_on_cb(void)
-{
-	HDMIDBG(3, "%s", __func__);
-	return rockchip_hdmiv1_hdcp_load_key2mem();
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_power_off_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_power_off_cb(struct hdmi *hdmi)
-{
-	unsigned int time;
-
-	HDMIDBG(3, "%s\n", __func__);
-	if (timer_state == 1) {
-		HDMIDBG(3, "delete auth timer\n");
-		timer_state = 0;
-		del_timer_sync(&auth_timer);
-	}
-	hdcp->auth_state = 0;
-
-	if (!hdcp->enable)
-		return;
-	rockchip_hdmiv1_hdcp_stop_authentication(hdcp->hdmi_dev);
-	hdcp_cancel_work(&hdcp->pending_start);
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-	init_completion(&hdcp->complete);
-	/* Post event to workqueue */
-	time = msecs_to_jiffies(5000);
-	if (hdcp_submit_work(HDCP_STOP_FRAME_EVENT, 0))
-		wait_for_completion_interruptible_timeout(&hdcp->complete,
-							  time);
-}
-
-/*
- * Load HDCP key to external HDCP memory
- */
-static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
-{
-	if (!fw) {
-		pr_err("HDCP: failed to load keys\n");
-		return;
-	}
-	if (fw->size < HDCP_KEY_SIZE) {
-		pr_err("HDCP: firmware wrong size %d\n", (int)fw->size);
-		return;
-	}
-	hdcp->keys =  kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
-	if (!hdcp->keys)
-		return;
-	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
-	HDCP_WARN("HDCP: load hdcp key success\n");
-
-	if (fw->size > HDCP_KEY_SIZE) {
-		HDMIDBG(3, "%s invalid key size %d\n", __func__,
-			(int)fw->size - HDCP_KEY_SIZE);
-		if ((fw->size - HDCP_KEY_SIZE) % 5) {
-			pr_err("HDCP: failed to load invalid keys\n");
-			return;
-		}
-		hdcp->invalidkeys =
-			kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
-		if (!hdcp->invalidkeys) {
-			pr_err("HDCP: can't allocated space for invalid keys\n");
-			return;
-		}
-		memcpy(hdcp->invalidkeys, fw->data +
-		       HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
-		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE) / 5;
-		HDCP_WARN("HDCP: loaded hdcp invalid key success\n");
-	}
-}
-
-static ssize_t hdcp_enable_read(struct device *device,
-				struct device_attribute *attr,
-				char *buf)
-{
-	int enable = 0;
-
-	if (hdcp)
-		enable = hdcp->enable;
-	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
-}
-
-static ssize_t hdcp_enable_write(struct device *device,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	int enable;
-
-	if (!hdcp)
-		return -EINVAL;
-	if (kstrtoint(buf, 0, &enable))
-		return -EINVAL;
-	if (hdcp->enable != enable) {
-		/* Post event to workqueue */
-		if (enable) {
-			if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
-				return -EFAULT;
-		} else {
-			hdcp_cancel_work(&hdcp->pending_start);
-			hdcp_cancel_work(&hdcp->pending_wq_event);
-
-			/* Post event to workqueue */
-			if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
-				return -EFAULT;
-		}
-		hdcp->enable = enable;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
-			 hdcp_enable_read, hdcp_enable_write);
-
-static ssize_t hdcp_trytimes_read(struct device *device,
-				  struct device_attribute *attr,
-				  char *buf)
-{
-	int trytimes = 0;
-
-	if (hdcp)
-		trytimes = hdcp->retry_times;
-	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
-}
-
-static ssize_t hdcp_trytimes_wrtie(struct device *device,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	int trytimes;
-
-	if (!hdcp)
-		return -EINVAL;
-	if (kstrtoint(buf, 0, &trytimes))
-		return -EINVAL;
-	if (hdcp->retry_times != trytimes)
-		hdcp->retry_times = trytimes;
-	return count;
-}
-
-static DEVICE_ATTR(trytimes, S_IRUGO | S_IWUSR,
-			 hdcp_trytimes_read, hdcp_trytimes_wrtie);
-static struct miscdevice mdev;
-
-int rockchip_hdmiv1_hdcp_init(struct hdmi *hdmi)
-{
-	int ret;
-
-	HDMIDBG(3, "[%s]\n", __func__);
-	if (hdcp)
-		return 0;
-
-	hdcp = kmalloc(sizeof(*hdcp), GFP_KERNEL);
-	if (!hdcp) {
-		HDCP_WARN(">>HDCP: kmalloc fail!\n");
-		ret = -ENOMEM;
-		goto error0;
-	}
-	memset(hdcp, 0, sizeof(struct hdcp));
-	mutex_init(&hdcp->lock);
-	mdev.minor = MISC_DYNAMIC_MINOR;
-	mdev.name = "hdcp";
-	mdev.mode = 0666;
-	if (misc_register(&mdev)) {
-		HDCP_WARN("HDCP: Could not add character driver\n");
-		ret = HDMI_ERROR_FALSE;
-		goto error1;
-	}
-	ret = device_create_file(mdev.this_device, &dev_attr_enable);
-	if (ret) {
-		HDCP_WARN("HDCP: Could not add sys file enable\n");
-		ret = -EINVAL;
-		goto error2;
-	}
-	ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
-	if (ret) {
-		HDCP_WARN("HDCP: Could not add sys file trytimes\n");
-		ret = -EINVAL;
-			goto error3;
-	}
-	hdcp->workqueue = create_singlethread_workqueue("hdcp");
-	if (!hdcp->workqueue) {
-		HDCP_WARN("HDCP,: create workqueue failed.\n");
-		goto error4;
-	}
-	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
-				      "hdcp", mdev.this_device,
-				      GFP_KERNEL, hdcp,
-				      hdcp_load_keys_cb);
-	if (ret < 0) {
-		HDCP_WARN("HDCP: request_firmware_nowait failed: %d\n", ret);
-		goto error5;
-	}
-	hdcp->hdmi_dev = hdmi->property->priv;
-	hdmi->ops->hdcp_cb = hdcp_start_frame_cb;
-	hdmi->ops->hdcp_irq_cb = hdcp_irq_cb;
-	hdmi->ops->hdcp_power_on_cb = hdcp_power_on_cb;
-	hdmi->ops->hdcp_power_off_cb = hdcp_power_off_cb;
-
-	init_timer(&auth_timer);
-	auth_timer.data = 0;
-	auth_timer.function = auth_timer_func;
-	HDMIDBG(3, "%s success\n", __func__);
-	return 0;
-error5:
-	destroy_workqueue(hdcp->workqueue);
-error4:
-	device_remove_file(mdev.this_device, &dev_attr_trytimes);
-error3:
-	device_remove_file(mdev.this_device, &dev_attr_enable);
-error2:
-	misc_deregister(&mdev);
-error1:
-	kfree(hdcp->keys);
-	kfree(hdcp->invalidkeys);
-	kfree(hdcp);
-error0:
-	return ret;
-}
-
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
deleted file mode 100644
index 0ac4f6ee4a2b..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
+++ /dev/null
@@ -1,187 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROCKCHIP_HDMIV1_HDCP_H__
-#define __ROCKCHIP_HDMIV1_HDCP_H__
-
-/***************************/
-/* Definitions             */
-/***************************/
-
-/* Status / error codes */
-#define HDCP_OK			0
-#define HDCP_KEY_ERR		1
-#define HDCP_KSV_ERR		2
-#define HDCP_KEY_VALID		3
-#define HDCP_KEY_INVALID	4
-
-/* Delays */
-#define HDCP_ENABLE_DELAY	300
-#define HDCP_REAUTH_DELAY	100
-
-/* Event source */
-#define HDCP_SRC_SHIFT		8
-#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
-#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
-#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
-#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
-
-/* Event */
-#define HDCP_ENABLE_CTL		(HDCP_IOCTL_SRC	| 0)
-#define HDCP_DISABLE_CTL	(HDCP_IOCTL_SRC	| 1)
-#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC	| 2)
-#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC	| 3)
-#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC	| 4)
-#define HDCP_FAIL_EVENT		(HDCP_IRQ_SRC	| 5)
-#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC	| 6)
-#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC | 7)
-
-/* Key size */
-#define HDCP_KEY_SIZE			308
-
-/* HDCP DDC Clock */
-#define HDCP_DDC_CLK			100000
-
-/* Authentication retry times */
-#define HDCP_INFINITE_REAUTH	0x100
-
-/* HDCP Regs */
-#define HDCP_CTRL1				0x52
-	#define m_AUTH_START		BIT(7)
-	#define m_BKSV_VALID		BIT(6)
-	#define m_BKSV_INVALID		BIT(5)
-	#define m_ENCRYPT_ENABLE	BIT(4)
-	#define m_AUTH_STOP		BIT(3)
-	#define m_ADVANED_ENABLE	BIT(2)
-	#define m_HDMI_DVI		BIT(1)
-	#define m_HDCP_RESET		BIT(0)
-
-	#define v_AUTH_START(n)		(n << 7)
-	#define v_BKSV_VALID(n)		(n << 6)
-	#define v_BKSV_INVALID(n)	(n << 5)
-	#define v_ENCRYPT_ENABLE(n)	(n << 4)
-	#define v_AUTH_STOP(n)		(n << 3)
-	#define v_ADVANED_ENABLE(n)	(n << 2)
-	#define v_HDMI_DVI(n)		(n << 1)
-	#define v_HDCP_RESET(n)		(n << 0)
-
-#define HDCP_CTRL2				0x53
-	#define m_DISABLE_127_CHECK			BIT(7)
-	#define m_SKIP_BKSV_CHECK			BIT(6)
-	#define m_ENABLE_PJ_CHECK			BIT(5)
-	#define m_DISABLE_DEVICE_NUMBER_CHECK		BIT(4)
-	#define m_DELAY_RI_1_CLK			BIT(3)
-	#define m_USE_PRESET_AN				BIT(2)
-	#define m_KEY_COMBINATION			(BIT(1) | BIT(0))
-
-	#define v_DISABLE_127_CHECK(n)			(n << 7)
-	#define v_SKIP_BKSV_CHECK(n)			(n << 6)
-	#define v_ENABLE_PJ_CHECK(n)			(n << 5)
-	#define v_DISABLE_DEVICE_NUMBER_CHECK(n)(n << 4)
-	#define v_DELAY_RI_1_CLK(n)				(n << 3)
-	#define v_USE_PRESET_AN(n)				(n << 2)
-	#define v_KEY_COMBINATION(n)			(n << 0)
-
-#define HDCP_KEY_STATUS			0x54
-	#define m_KEY_READY			BIT(0)
-
-#define HDCP_CTRL_SOFT			0x57
-	#define m_DISABLE_127_CHECK			BIT(7)
-	#define m_SKIP_BKSV_CHECK			BIT(6)
-	#define m_NOT_AUTHENTICATED			BIT(5)
-	#define m_ENCRYPTED				BIT(4)
-	#define m_ADVANCED_CIPHER			BIT(3)
-
-#define HDCP_BCAPS_RX			0x58
-#define HDCP_TIMER_100MS		0x63
-#define HDCP_TIMER_5S			0x64
-#define HDCP_ERROR				0x65
-	#define m_DDC_NO_ACK		BIT(3)
-	#define m_PJ_MISMACH		BIT(2)
-	#define m_RI_MISMACH		BIT(1)
-	#define m_BKSV_WRONG		BIT(0)
-
-#define HDCP_KSV_BYTE0			0x66
-#define HDCP_KSV_BYTE1			0x67
-#define HDCP_KSV_BYTE2			0x68
-#define HDCP_KSV_BYTE3			0x69
-#define HDCP_KSV_BYTE4			0x6a
-
-#define HDCP_AN_SEED			0x6c
-
-#define HDCP_BCAPS_TX			0x80
-#define HDCP_BSTATE_0			0x81
-#define HDCP_BSTATE_1			0x82
-
-#define HDCP_KEY_FIFO			0x98
-
-#define HDCP_INT_MASK1			0xc2
-#define HDCP_INT_STATUS1		0xc3
-	#define m_INT_HDCP_ERR		BIT(7)
-	#define m_INT_BKSV_READY	BIT(6)
-	#define m_INT_BKSV_UPDATE	BIT(5)
-	#define m_INT_AUTH_SUCCESS	BIT(4)
-	#define m_INT_AUTH_READY	BIT(3)
-
-#define HDCP_INT_MASK2			0xc4
-#define HDCP_INT_STATUS2		0xc5
-	#define m_INT_SOFT_MODE_READY			BIT(7)
-	#define m_INT_AUTH_M0_REDAY			BIT(6)
-	#define m_INT_1st_FRAME_ARRIVE			BIT(5)
-	#define m_INT_AN_READY				BIT(4)
-	#define m_INT_ENCRYPTED				BIT(2)
-	#define m_INT_NOT_ENCRYPTED_AVMUTE		BIT(1)
-	#define m_INT_NOT_ENCRYPTED_AVUNMUTE	BIT(0)
-
-enum hdcp_states {
-	HDCP_DISABLED,
-	HDCP_ENABLE_PENDING,
-	HDCP_AUTHENTICATION_START,
-	HDCP_WAIT_KSV_LIST,
-	HDCP_LINK_INTEGRITY_CHECK,
-};
-
-enum hdmi_states {
-	HDMI_STOPPED,
-	HDMI_STARTED
-};
-
-#define HDCP_PRIVATE_KEY_SIZE	280
-#define HDCP_KEY_SHA_SIZE		20
-
-struct hdcp_keys {
-	u8 ksv[8];
-	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
-	u8 sha1[HDCP_KEY_SHA_SIZE];
-};
-
-struct hdcp_delayed_work {
-	struct delayed_work work;
-	int event;
-};
-
-struct hdcp {
-	int	enable;
-	int retry_times;
-	struct hdcp_keys *keys;
-	int invalidkey;
-	char *invalidkeys;
-	struct mutex lock;	/* use for workqueue */
-	struct completion	complete;
-	struct workqueue_struct *workqueue;
-
-	enum hdmi_states hdmi_state;
-	enum hdcp_states hdcp_state;
-
-	struct delayed_work *pending_start;
-	struct delayed_work *pending_wq_event;
-	int retry_cnt;
-	int auth_state;
-	struct hdmi_dev *hdmi_dev;
-};
-
-#if 1
-#define HDCP_WARN(x...) pr_warn(x)
-#else
-#define I2S_DBG(x...) do { } while (0)
-#endif
-int	rockchip_hdmiv1_hdcp_init(struct hdmi *hdmi);
-#endif /* __ROCKCHIP_HDMIV1_HDCP_H__ */
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
deleted file mode 100644
index 3878b79f2b7c..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
+++ /dev/null
@@ -1,995 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-#include "rockchip_hdmiv1.h"
-#include "rockchip_hdmiv1_hw.h"
-#include "rockchip_hdmiv1_hdcp.h"
-
-static inline void delay100us(void)
-{
-	usleep_range(99, 100);
-}
-
-static void rockchip_hdmiv1_av_mute(struct hdmi *hdmi_drv, bool enable)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (enable) {
-		hdmi_msk_reg(hdmi_dev, AV_MUTE,
-			     m_AVMUTE_CLEAR | m_AVMUTE_ENABLE,
-			     v_AVMUTE_CLEAR(0) | v_AVMUTE_ENABLE(1));
-	} else {
-		hdmi_msk_reg(hdmi_dev, AV_MUTE,
-			     m_AVMUTE_CLEAR | m_AVMUTE_ENABLE,
-			     v_AVMUTE_CLEAR(1) | v_AVMUTE_ENABLE(0));
-	}
-	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
-		     m_PACKET_GCP_EN, v_PACKET_GCP_EN(1));
-}
-
-static void rockchip_hdmiv1_sys_power(struct hdmi *hdmi_drv, bool enable)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (enable)
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_POWER, v_PWR_ON);
-	else
-		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_POWER, v_PWR_OFF);
-}
-
-static void rockchip_hdmiv1_set_pwr_mode(struct hdmi *hdmi_drv, int mode)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (hdmi_dev->pwr_mode == mode)
-		return;
-
-	dev_info(hdmi_drv->dev, "%s change pwr_mode %d --> %d\n", __func__,
-		 hdmi_dev->pwr_mode, mode);
-
-	switch (mode) {
-	case NORMAL:
-		dev_info(hdmi_drv->dev,
-			 "%s change pwr_mode NORMAL\n",
-			 __func__);
-		rockchip_hdmiv1_sys_power(hdmi_drv, false);
-		if (hdmi_dev->soctype == HDMI_SOC_RK3036) {
-			hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x6f);
-			hdmi_writel(hdmi_dev, PHY_DRIVER, 0xbb);
-		} else if (hdmi_dev->soctype == HDMI_SOC_RK312X) {
-			hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x5f);
-			hdmi_writel(hdmi_dev, PHY_DRIVER, 0xaa);
-		}
-
-		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x15);
-		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x14);
-		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x10);
-		hdmi_writel(hdmi_dev, PHY_CHG_PWR, 0x0f);
-		hdmi_writel(hdmi_dev, 0xce, 0x00);
-		hdmi_writel(hdmi_dev, 0xce, 0x01);
-		rockchip_hdmiv1_sys_power(hdmi_drv, true);
-		break;
-	case LOWER_PWR:
-		dev_info(hdmi_drv->dev,
-			 "%s change pwr_mode LOWER_PWR\n",
-			 __func__);
-		rockchip_hdmiv1_sys_power(hdmi_drv, false);
-		hdmi_writel(hdmi_dev, PHY_DRIVER, 0x00);
-		hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x00);
-		hdmi_writel(hdmi_dev, PHY_CHG_PWR, 0x00);
-		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x17);
-		break;
-	default:
-		dev_info(hdmi_drv->dev, "unknown rk3036 hdmi pwr mode %d\n",
-			 mode);
-	}
-
-	hdmi_dev->pwr_mode = mode;
-}
-
-int rockchip_hdmiv1_detect_hotplug(struct hdmi *hdmi_drv)
-{
-	int value = 0;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	hdmi_readl(hdmi_dev, HDMI_STATUS, &value);
-	value &= m_HOTPLUG;
-	if (value == m_HOTPLUG)
-		return HDMI_HPD_ACTIVATED;
-	else if (value)
-		return HDMI_HPD_INSERT;
-	else
-		return HDMI_HPD_REMOVED;
-}
-
-int rockchip_hdmiv1_insert(struct hdmi *hdmi_drv)
-{
-	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, NORMAL);
-	return 0;
-}
-
-int rockchip_hdmiv1_read_edid(struct hdmi *hdmi_drv, int block, u8 *buf)
-{
-	u32 c = 0;
-	u8 segment = 0;
-	u8 offset = 0;
-	int ret = -1;
-	int i, j;
-	int ddc_bus_freq;
-	int trytime;
-	int checksum = 0;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (block % 2)
-		offset = HDMI_EDID_BLOCK_SIZE;
-
-	if (block / 2)
-		segment = 1;
-	ddc_bus_freq = (hdmi_dev->hclk_rate >> 2) / HDMI_SCL_RATE;
-	hdmi_writel(hdmi_dev, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
-	hdmi_writel(hdmi_dev, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
-
-	dev_info(hdmi_drv->dev,
-		 "EDID DATA (Segment = %d Block = %d Offset = %d):\n",
-		 (int)segment, (int)block, (int)offset);
-	disable_irq(hdmi_dev->irq);
-
-	/* Enable edid interrupt */
-	hdmi_writel(hdmi_dev, INTERRUPT_MASK1, m_INT_EDID_READY);
-
-	for (trytime = 0; trytime < 10; trytime++) {
-		checksum = 0;
-		hdmi_writel(hdmi_dev, INTERRUPT_STATUS1, 0x04);
-
-		/* Set edid fifo first addr */
-		hdmi_writel(hdmi_dev, EDID_FIFO_OFFSET, 0x00);
-
-		/* Set edid word address 0x00/0x80 */
-		hdmi_writel(hdmi_dev, EDID_WORD_ADDR, offset);
-
-		/* Set edid segment pointer */
-		hdmi_writel(hdmi_dev, EDID_SEGMENT_POINTER, segment);
-
-		for (i = 0; i < 200; i++) {
-			/* Wait edid interrupt */
-			usleep_range(900, 1000);
-			c = 0x00;
-			hdmi_readl(hdmi_dev, INTERRUPT_STATUS1, &c);
-
-			if (c & m_INT_EDID_READY)
-				break;
-		}
-
-		if (c & m_INT_EDID_READY) {
-			for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
-				c = 0;
-				hdmi_readl(hdmi_dev, 0x50, &c);
-				buf[j] = c;
-				checksum += c;
-			}
-
-			if ((checksum & 0xff) == 0) {
-				ret = 0;
-				dev_info(hdmi_drv->dev,
-					 "[%s] edid read success\n", __func__);
-				break;
-			}
-		}
-	}
-	/*close edid irq*/
-	hdmi_writel(hdmi_dev, INTERRUPT_MASK1, 0);
-	/* clear EDID interrupt reg */
-	hdmi_writel(hdmi_dev, INTERRUPT_STATUS1,
-		    m_INT_EDID_READY);
-
-	enable_irq(hdmi_dev->irq);
-
-	return ret;
-}
-
-static const char coeff_csc[][24] = {
-	/* YUV2RGB:601 SD mode(Y[16:235],UV[16:240],RGB[0:255]):
-	 *  R = 1.164*Y +1.596*V - 204
-	 *  G = 1.164*Y - 0.391*U - 0.813*V + 154
-	 *  B = 1.164*Y + 2.018*U - 258
-	 */
-	{
-	0x04, 0xa7, 0x00, 0x00, 0x06, 0x62, 0x02, 0xcc,
-	0x04, 0xa7, 0x11, 0x90, 0x13, 0x40, 0x00, 0x9a,
-	0x04, 0xa7, 0x08, 0x12, 0x00, 0x00, 0x03, 0x02},
-
-	/* YUV2RGB:601 SD mode(YUV[0:255],RGB[0:255]):
-	 *  R = Y + 1.402*V - 248
-	 *  G = Y - 0.344*U - 0.714*V + 135
-	 *  B = Y + 1.772*U - 227
-	 */
-	{
-	0x04, 0x00, 0x00, 0x00, 0x05, 0x9b, 0x02, 0xf8,
-	0x04, 0x00, 0x11, 0x60, 0x12, 0xdb, 0x00, 0x87,
-	0x04, 0x00, 0x07, 0x16, 0x00, 0x00, 0x02, 0xe3},
-	/* YUV2RGB:709 HD mode(Y[16:235],UV[16:240],RGB[0:255]):
-	 *  R = 1.164*Y +1.793*V - 248
-	 *  G = 1.164*Y - 0.213*U - 0.534*V + 77
-	 *  B = 1.164*Y + 2.115*U - 289
-	 */
-	{
-	0x04, 0xa7, 0x00, 0x00, 0x07, 0x2c, 0x02, 0xf8,
-	0x04, 0xa7, 0x10, 0xda, 0x12, 0x22, 0x00, 0x4d,
-	0x04, 0xa7, 0x08, 0x74, 0x00, 0x00, 0x03, 0x21},
-	/* RGB2YUV:601 SD mode:
-	 *  Cb = -0.291G  - 0.148R + 0.439B + 128
-	 *  Y   = 0.504G   + 0.257R + 0.098B + 16
-	 *  Cr  = -0.368G + 0.439R - 0.071B + 128
-	 */
-	{
-	0x11, 0x5f, 0x01, 0x82, 0x10, 0x23, 0x00, 0x80,
-	0x02, 0x1c, 0x00, 0xa1, 0x00, 0x36, 0x00, 0x1e,
-	0x11, 0x29, 0x10, 0x59, 0x01, 0x82, 0x00, 0x80
-	},
-
-	/* RGB2YUV:709 HD mode:
-	 *  Cb = - 0.338G - 0.101R +  0.439B + 128
-	 *  Y  =    0.614G + 0.183R +  0.062B + 16
-	 *  Cr = - 0.399G + 0.439R  -  0.040B + 128
-	 */
-	{
-	0x11, 0x98, 0x01, 0xc1, 0x10, 0x28, 0x00, 0x80,
-	0x02, 0x74, 0x00, 0xbb, 0x00, 0x3f, 0x00, 0x10,
-	0x11, 0x5a, 0x10, 0x67, 0x01, 0xc1, 0x00, 0x80
-	},
-	/* RGB[0:255]2RGB[16:235]:
-	 * R' = R x (235-16)/255 + 16;
-	 * G' = G x (235-16)/255 + 16;
-	 * B' = B x (235-16)/255 + 16;
-	 */
-	{
-	0x00, 0x00, 0x03, 0x6F, 0x00, 0x00, 0x00, 0x10,
-	0x03, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
-	0x00, 0x00, 0x00, 0x00, 0x03, 0x6F, 0x00, 0x10},
-};
-
-static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
-				     struct hdmi_video *vpara)
-{
-	int value, i, csc_mode, c0_c2_change, auto_csc, csc_enable;
-	const char *coeff = NULL;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	/* Enable or disalbe color space convert */
-	dev_info(hdmi_drv->dev, "[%s] input_color=%d,output_color=%d\n",
-		 __func__, vpara->color_input, vpara->color_output);
-	if (vpara->color_input == vpara->color_output) {
-		if ((vpara->color_input >= HDMI_COLOR_YCBCR444) ||
-		    (vpara->color_input == HDMI_COLOR_RGB_0_255)) {
-			value = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,
-				     v_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |
-				     v_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));
-			return 0;
-		} else if (vpara->color_input == HDMI_COLOR_RGB_16_235) {
-			csc_mode = CSC_RGB_0_255_TO_RGB_16_235_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_ENABLE;
-		}
-	}
-
-	switch (vpara->vic) {
-	case HDMI_720X480I_60HZ_4_3:
-	case HDMI_720X576I_50HZ_4_3:
-	case HDMI_720X480P_60HZ_4_3:
-	case HDMI_720X576P_50HZ_4_3:
-	case HDMI_720X480I_60HZ_16_9:
-	case HDMI_720X576I_50HZ_16_9:
-	case HDMI_720X480P_60HZ_16_9:
-	case HDMI_720X576P_50HZ_16_9:
-		if (((vpara->color_input == HDMI_COLOR_RGB_0_255) ||
-		     (vpara->color_input == HDMI_COLOR_RGB_16_235)) &&
-		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
-			csc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_ENABLE;
-		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
-			   ((vpara->color_output == HDMI_COLOR_RGB_0_255) ||
-			   (vpara->color_output == HDMI_COLOR_RGB_16_235))) {
-#ifdef AUTO_DEFINE_CSC
-			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_ENABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_DISABLE;
-#else
-			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_ENABLE;
-			csc_enable = v_CSC_ENABLE;
-#endif
-		}
-		break;
-	default:
-		if (((vpara->color_input == HDMI_COLOR_RGB_0_255) ||
-		     (vpara->color_input == HDMI_COLOR_RGB_16_235)) &&
-		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
-			csc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_ENABLE;
-		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
-			   ((vpara->color_output == HDMI_COLOR_RGB_0_255) ||
-			   (vpara->color_output == HDMI_COLOR_RGB_16_235))) {
-#ifdef AUTO_DEFINE_CSC
-			csc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_ENABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_DISABLE;
-#else
-			/*CSC_ITU709_16_235_TO_RGB_0_255_8BIT;*/
-			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_ENABLE;
-			csc_enable = v_CSC_ENABLE;
-#endif
-		}
-		break;
-	}
-
-	coeff = coeff_csc[csc_mode];
-	for (i = 0; i < 24; i++)
-		hdmi_writel(hdmi_dev, VIDEO_CSC_COEF + i, coeff[i]);
-
-	value = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);
-	hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-	hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-		     m_VIDEO_AUTO_CSC |
-		     m_VIDEO_C0_C2_SWAP,
-		     v_VIDEO_AUTO_CSC(auto_csc) |
-		     v_VIDEO_C0_C2_SWAP(c0_c2_change));
-
-#if 0
-	if (vpara->input_color != vpara->output_color) {
-		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB) {/*rgb2yuv*/
-			coeff = coeff_csc[3];
-			for (i = 0; i < 24; i++)
-				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF + i, coeff[i]);
-
-			value = v_SOF_DISABLE | v_CSC_ENABLE;
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
-				     v_VIDEO_AUTO_CSC(0) |
-				     v_VIDEO_C0_C2_EXCHANGE(1));
-		} else {/*yuv2rgb*/
-#ifdef AUTO_DEFINE_CSC
-			value = v_SOF_DISABLE | v_CSC_DISABLE;
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
-				     v_VIDEO_AUTO_CSC(1) |
-				     v_VIDEO_C0_C2_EXCHANGE(1));
-#else
-			if (hdmi_drv->lcdc->cur_screen->mode.xres <= 576) {
-				/*x <= 576,REC-601*/
-				coeff = coeff_csc[0];
-				pr_info("xres<=576,xres=%d\n",
-					hdmi_drv->lcdc->cur_screen->mode.xres);
-			} else/*x > 576,REC-709*/{
-				coeff = coeff_csc[2];
-				pr_info("xres>576,xres=%d\n",
-					hdmi_drv->lcdc->cur_screen->mode.xres);
-			}
-			for (i = 0; i < 24; i++)
-				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF + i, coeff[i]);
-
-			value = v_SOF_DISABLE | v_CSC_ENABLE;
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC |
-				     m_VIDEO_C0_C2_EXCHANGE,
-				     v_VIDEO_AUTO_CSC(0) |
-				     v_VIDEO_C0_C2_EXCHANGE(0));
-#endif
-		}
-	} else {
-		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB) {
-			/*rgb[0:255]->rbg[16:235]*/
-			coeff = coeff_csc[5];
-			for (i = 0; i < 24; i++)
-				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF + i, coeff[i]);
-
-			value = v_SOF_DISABLE | v_CSC_ENABLE;
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
-				     v_VIDEO_AUTO_CSC(0) |
-				     v_VIDEO_C0_C2_EXCHANGE(1));
-		} else {
-			value = v_SOF_DISABLE;
-			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
-			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
-				     m_VIDEO_AUTO_CSC |
-				     m_VIDEO_C0_C2_EXCHANGE,
-				     v_VIDEO_AUTO_CSC(0) |
-				     v_VIDEO_C0_C2_EXCHANGE(1));
-		}
-	}
-#endif
-	return 0;
-}
-
-static int rockchip_hdmiv1_config_vsi(struct hdmi *hdmi,
-				      unsigned char vic_3d,
-				      unsigned char format)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	u8 info[SIZE_VSI_INFOFRAME];
-	int i;
-
-	HDMIDBG(2, "[%s] vic_3d %d format %d.\n", __func__, vic_3d, format);
-	memset(info, 0, SIZE_VSI_INFOFRAME);
-	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
-		     m_PACKET_VSI_EN, v_PACKET_VSI_EN(0));
-	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_VSI);
-	/* Header Bytes */
-	info[0] = 0x81;
-	info[1] = 0x01;
-	/* PB1 - PB3 contain the 24bit IEEE Registration Identifier */
-	info[4] = 0x03;
-	info[5] = 0x0c;
-	info[6] = 0x00;
-	/* PB4 - HDMI_Video_Format into bits 7:5 */
-	info[7] = format << 5;
-	/* PB5 - Depending on the video format, this byte will contain either
-	 * the HDMI_VIC code in buts 7:0, OR the 3D_Structure in bits 7:4.
-	 */
-	switch (format) {
-	case HDMI_VIDEO_FORMAT_4KX2K:
-		/* This is a 2x4K mode, set the HDMI_VIC in buts 7:0.  Values
-		 * are from HDMI 1.4 Spec, 8.2.3.1 (Table 8-13).
-		 */
-		info[2] = 0x06 - 1;
-		info[8] = vic_3d;
-		info[9] = 0;
-		break;
-	case HDMI_VIDEO_FORMAT_3D:
-		/* This is a 3D mode, set the 3D_Structure in buts 7:4
-		 * Bits 3:0 are reseved so set to 0.  Values are from HDMI 1.4
-		 * Spec, Appendix H (Table H-2).
-		 */
-		info[8] = vic_3d << 4;
-		/* Add the Extended data field when the 3D format is
-		 * Side-by-Side(Half). See Spec Table H-3 for details.
-		 */
-		if ((info[8] >> 4) == HDMI_3D_SIDE_BY_SIDE_HALF) {
-			info[2] = 0x06;
-			info[9] = 0x00;
-		} else {
-			info[2] = 0x06 - 1;
-		}
-		break;
-	default:
-		info[2] = 0x06 - 2;
-		info[8] = 0;
-		info[9] = 0;
-		break;
-	}
-	info[3] = info[0] + info[1] + info[2];
-	/* Calculate InfoFrame ChecKsum */
-	for (i = 4; i < SIZE_VSI_INFOFRAME; i++)
-		info[3] += info[i];
-	info[3] = 0x100 - info[3];
-
-	for (i = 0; i < SIZE_VSI_INFOFRAME; i++)
-		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
-	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
-		     m_PACKET_VSI_EN, v_PACKET_VSI_EN(1));
-	return 0;
-}
-
-static void rockchip_hdmiv1_config_avi(struct hdmi *hdmi_drv,
-				       unsigned char vic,
-				       unsigned char output_color)
-{
-	int i;
-	int avi_color_mode;
-	u8 info[SIZE_AVI_INFOFRAME];
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	memset(info, 0, SIZE_AVI_INFOFRAME);
-	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_AVI);
-	info[0] = 0x82;
-	info[1] = 0x02;
-	info[2] = 0x0D;
-	info[3] = info[0] + info[1] + info[2];
-
-	if ((output_color == HDMI_COLOR_RGB_0_255) ||
-	    (output_color == HDMI_COLOR_RGB_16_235))
-		avi_color_mode = AVI_COLOR_MODE_RGB;
-	else if (output_color == HDMI_COLOR_YCBCR444)
-		avi_color_mode = AVI_COLOR_MODE_YCBCR444;
-	else if (output_color == HDMI_COLOR_YCBCR422)
-		avi_color_mode = AVI_COLOR_MODE_YCBCR422;
-	else
-		avi_color_mode = HDMI_COLOR_RGB_0_255;
-	info[4] = (avi_color_mode << 5);
-	info[5] =
-	    (AVI_COLORIMETRY_NO_DATA << 6) |
-	    (AVI_CODED_FRAME_ASPECT_NO_DATA << 4) |
-	    ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME;
-	info[6] = 0;
-	info[7] = vic;
-	if ((vic == HDMI_720X480I_60HZ_4_3) ||
-	    (vic == HDMI_720X576I_50HZ_4_3) ||
-	    (vic == HDMI_720X480I_60HZ_16_9) ||
-	    (vic == HDMI_720X576I_50HZ_16_9))
-		info[8] = 1;
-	else
-		info[8] = 0;
-
-	/* Calculate AVI InfoFrame ChecKsum */
-	for (i = 4; i < SIZE_AVI_INFOFRAME; i++)
-		info[3] += info[i];
-
-	info[3] = 0x100 - info[3];
-
-	for (i = 0; i < SIZE_AVI_INFOFRAME; i++)
-		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
-}
-
-static int rockchip_hdmiv1_config_video(struct hdmi *hdmi_drv,
-					struct hdmi_video *vpara)
-{
-	struct fb_videomode *mode;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-	int value;
-
-	dev_dbg(hdmi_drv->dev, "[%s]\n", __func__);
-
-	if (!vpara) {
-		dev_err(hdmi_drv->dev, "[%s] input parameter error\n",
-			__func__);
-		return -1;
-	}
-
-	if (hdmi_dev->soctype == HDMI_SOC_RK3036) {
-		/*rk3036 vop only can output rgb fmt*/
-		vpara->color_input = HDMI_COLOR_RGB_0_255;
-	}
-
-	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
-	if (!mode) {
-		dev_err(hdmi_drv->dev, "[%s] not found vic %d\n", __func__,
-			vpara->vic);
-		return -ENOENT;
-	}
-	hdmi_dev->tmdsclk = mode->pixclock;
-	if (hdmi_drv->uboot)
-		return 0;
-	/* Disable video and audio output */
-	hdmi_msk_reg(hdmi_dev, AV_MUTE,
-		     m_AUDIO_MUTE | m_AUDIO_PD | m_VIDEO_BLACK,
-		     v_AUDIO_MUTE(1) | v_AUDIO_PD(1) | v_VIDEO_MUTE(1));
-
-	/* Input video mode is SDR RGB24bit,
-	 * Data enable signal from external
-	 */
-	hdmi_writel(hdmi_dev, VIDEO_CONTRL1,
-		    v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444) |
-		    v_DE_EXTERNAL);
-
-	value = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS);
-	if (vpara->color_output <= HDMI_COLOR_RGB_16_235)
-		value |= v_VIDEO_OUTPUT_COLOR(0);
-	else
-		value |= v_VIDEO_OUTPUT_COLOR((vpara->color_output - 2) & 0x3);
-	if (vpara->color_input <= HDMI_COLOR_RGB_16_235)
-		value |= v_VIDEO_INPUT_CSP(0);
-	else
-		value |= v_VIDEO_INPUT_CSP((vpara->color_input - 2) & 0x1);
-
-	hdmi_writel(hdmi_dev, VIDEO_CONTRL2, value);
-	/* Set HDMI Mode */
-	hdmi_writel(hdmi_dev, HDCP_CTRL, v_HDMI_DVI(vpara->sink_hdmi));
-
-	/* Enable or disalbe color space convert */
-	rockchip_hdmiv1_video_csc(hdmi_drv, vpara);
-
-	/* Set ext video timing */
-	if ((mode->vmode || mode->pixclock <= 27000000) &&
-	    vpara->format_3d != HDMI_3D_FRAME_PACKING) {
-		hdmi_writel(hdmi_dev, VIDEO_TIMING_CTL, 0);
-	} else {
-		if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
-			value = v_EXTERANL_VIDEO(1) |
-				v_INETLACE(0);
-		else
-			value = v_EXTERANL_VIDEO(1) |
-				v_INETLACE(mode->vmode);
-		if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
-			value |= v_HSYNC_POLARITY(1);
-		if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
-			value |= v_VSYNC_POLARITY(1);
-		hdmi_writel(hdmi_dev, VIDEO_TIMING_CTL, value);
-
-		value = mode->left_margin +
-			mode->xres + mode->right_margin +
-			mode->hsync_len;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HTOTAL_L, value & 0xFF);
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);
-
-		value = mode->left_margin +
-			mode->right_margin +
-			mode->hsync_len;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HBLANK_L, value & 0xFF);
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
-
-		value = mode->left_margin + mode->hsync_len;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HDELAY_L, value & 0xFF);
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
-
-		value = mode->hsync_len;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HDURATION_L,
-			    value & 0xFF);
-		hdmi_writel(hdmi_dev, VIDEO_EXT_HDURATION_H,
-			    (value >> 8) & 0xFF);
-
-		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
-			if (mode->vmode == 0)
-				value = mode->upper_margin +
-					mode->lower_margin +
-					mode->vsync_len +
-					2 * mode->yres;
-			else
-				value = 4 * (mode->upper_margin +
-					     mode->lower_margin +
-					     mode->vsync_len) +
-					2 * mode->yres + 2;
-		} else {
-			value = mode->upper_margin +
-				mode->lower_margin +
-				mode->vsync_len +
-				mode->yres;
-		}
-		hdmi_writel(hdmi_dev, VIDEO_EXT_VTOTAL_L, value & 0xFF);
-		hdmi_writel(hdmi_dev, VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);
-
-		value = mode->upper_margin +
-			mode->vsync_len +
-			mode->lower_margin;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_VBLANK, value & 0xFF);
-
-		if (vpara->vic == HDMI_720X480P_60HZ_4_3 ||
-		    vpara->vic == HDMI_720X480P_60HZ_16_9)
-			value = 42;
-		else
-			value = mode->upper_margin + mode->vsync_len;
-
-		hdmi_writel(hdmi_dev, VIDEO_EXT_VDELAY, value & 0xFF);
-
-		value = mode->vsync_len;
-		hdmi_writel(hdmi_dev, VIDEO_EXT_VDURATION, value & 0xFF);
-	}
-	if (vpara->sink_hdmi == OUTPUT_HDMI) {
-		rockchip_hdmiv1_config_avi(hdmi_drv, vpara->vic,
-					   vpara->color_output);
-		if (vpara->format_3d != HDMI_3D_NONE) {
-			rockchip_hdmiv1_config_vsi(hdmi_drv,
-						   vpara->format_3d,
-						   HDMI_VIDEO_FORMAT_3D);
-		} else if ((vpara->vic > 92 && vpara->vic < 96) ||
-			 (vpara->vic == 98)) {
-			vpara->vic = (vpara->vic == 98) ?
-				     4 : (96 - vpara->vic);
-			rockchip_hdmiv1_config_vsi(hdmi_drv,
-						   vpara->vic,
-						   HDMI_VIDEO_FORMAT_4KX2K);
-		} else {
-			rockchip_hdmiv1_config_vsi(hdmi_drv,
-						   vpara->vic,
-						   HDMI_VIDEO_FORMAT_NORMAL);
-		}
-		dev_info(hdmi_drv->dev,
-			 "[%s] success output HDMI.\n", __func__);
-	} else {
-		dev_info(hdmi_drv->dev,
-			 "[%s] success output DVI.\n", __func__);
-	}
-
-	/* rk3028a */
-	hdmi_writel(hdmi_dev, PHY_PRE_DIV_RATIO, 0x1e);
-	hdmi_writel(hdmi_dev, PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);
-	hdmi_writel(hdmi_dev, PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);
-
-	return 0;
-}
-
-static void rockchip_hdmiv1_config_aai(struct hdmi *hdmi_drv)
-{
-	int i;
-	u8 info[SIZE_AUDIO_INFOFRAME];
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	memset(info, 0, SIZE_AUDIO_INFOFRAME);
-
-	info[0] = 0x84;
-	info[1] = 0x01;
-	info[2] = 0x0A;
-
-	info[3] = info[0] + info[1] + info[2];
-	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
-		info[3] += info[i];
-
-	info[3] = 0x100 - info[3];
-
-	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_AAI);
-	for (i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
-		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
-}
-
-static int rockchip_hdmiv1_config_audio(struct hdmi *hdmi_drv,
-					struct hdmi_audio *audio)
-{
-	int rate, N, channel, mclk_fs;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (audio->channel < 3)
-		channel = I2S_CHANNEL_1_2;
-	else if (audio->channel < 5)
-		channel = I2S_CHANNEL_3_4;
-	else if (audio->channel < 7)
-		channel = I2S_CHANNEL_5_6;
-	else
-		channel = I2S_CHANNEL_7_8;
-
-	switch (audio->rate) {
-	case HDMI_AUDIO_FS_32000:
-		rate = AUDIO_32K;
-		N = N_32K;
-		mclk_fs = MCLK_384FS;
-		break;
-	case HDMI_AUDIO_FS_44100:
-		rate = AUDIO_441K;
-		N = N_441K;
-		mclk_fs = MCLK_256FS;
-		break;
-	case HDMI_AUDIO_FS_48000:
-		rate = AUDIO_48K;
-		N = N_48K;
-		mclk_fs = MCLK_256FS;
-		break;
-	case HDMI_AUDIO_FS_88200:
-		rate = AUDIO_882K;
-		N = N_882K;
-		mclk_fs = MCLK_128FS;
-		break;
-	case HDMI_AUDIO_FS_96000:
-		rate = AUDIO_96K;
-		N = N_96K;
-		mclk_fs = MCLK_128FS;
-		break;
-	case HDMI_AUDIO_FS_176400:
-		rate = AUDIO_1764K;
-		N = N_1764K;
-		mclk_fs = MCLK_128FS;
-		break;
-	case HDMI_AUDIO_FS_192000:
-		rate = AUDIO_192K;
-		N = N_192K;
-		mclk_fs = MCLK_128FS;
-		break;
-	default:
-		dev_err(hdmi_drv->dev,
-			"[%s] not support such sample rate %d\n",
-			__func__, audio->rate);
-		return -ENOENT;
-	}
-
-	/* set_audio source I2S */
-	if (hdmi_dev->audiosrc == HDMI_AUDIO_SRC_IIS) {
-		hdmi_writel(hdmi_dev, AUDIO_CTRL1, 0x01);
-		hdmi_writel(hdmi_dev, AUDIO_SAMPLE_RATE, rate);
-		hdmi_writel(hdmi_dev, AUDIO_I2S_MODE,
-			    v_I2S_MODE(I2S_STANDARD) |
-			    v_I2S_CHANNEL(channel));
-		hdmi_writel(hdmi_dev, AUDIO_I2S_MAP, 0x00);
-		/* no swap */
-		hdmi_writel(hdmi_dev, AUDIO_I2S_SWAPS_SPDIF, 0);
-	} else {
-		hdmi_writel(hdmi_dev, AUDIO_CTRL1, 0x08);
-		/* no swap */
-		hdmi_writel(hdmi_dev, AUDIO_I2S_SWAPS_SPDIF, 0);
-	}
-
-	/* Set N value */
-	hdmi_writel(hdmi_dev, AUDIO_N_H, (N >> 16) & 0x0F);
-	hdmi_writel(hdmi_dev, AUDIO_N_M, (N >> 8) & 0xFF);
-	hdmi_writel(hdmi_dev, AUDIO_N_L, N & 0xFF);
-
-	/*Set hdmi nlpcm mode to support hdmi bitstream*/
-	if (audio->type == HDMI_AUDIO_NLPCM)
-		hdmi_writel(hdmi_dev, AUDIO_CHANNEL_STATUS,
-			    v_AUDIO_STATUS_NLPCM(1));
-	else
-		hdmi_writel(hdmi_dev, AUDIO_CHANNEL_STATUS,
-			    v_AUDIO_STATUS_NLPCM(0));
-
-	rockchip_hdmiv1_config_aai(hdmi_drv);
-
-	return 0;
-}
-
-int rockchip_hdmiv1_control_output(struct hdmi *hdmi_drv, int enable)
-{
-	int mutestatus = 0;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (hdmi_drv->uboot) {
-		hdmi_drv->uboot = 0;
-		return 0;
-	}
-
-	if (enable == HDMI_AV_UNMUTE) {
-		if (hdmi_dev->pwr_mode == LOWER_PWR)
-			rockchip_hdmiv1_set_pwr_mode(hdmi_drv, NORMAL);
-		hdmi_readl(hdmi_dev, AV_MUTE, &mutestatus);
-		if (mutestatus & m_VIDEO_BLACK) {
-			rockchip_hdmiv1_sys_power(hdmi_drv, true);
-			rockchip_hdmiv1_sys_power(hdmi_drv, false);
-			delay100us();
-			rockchip_hdmiv1_sys_power(hdmi_drv, true);
-			hdmi_writel(hdmi_dev, 0xce, 0x00);
-			delay100us();
-			hdmi_writel(hdmi_dev, 0xce, 0x01);
-		}
-
-		if (mutestatus == (m_AUDIO_MUTE | m_VIDEO_BLACK)) {
-			hdmi_msk_reg(hdmi_dev, AV_MUTE,
-				     m_AUDIO_MUTE |
-				     m_AUDIO_PD |
-				     m_VIDEO_BLACK,
-				     v_AUDIO_MUTE(0) |
-				     v_AUDIO_PD(0) |
-				     v_VIDEO_MUTE(0));
-		}
-		rockchip_hdmiv1_av_mute(hdmi_drv, 0);
-	} else {
-		mutestatus = 0;
-		if (enable & HDMI_VIDEO_MUTE)
-			mutestatus |= v_VIDEO_MUTE(1);
-		if (enable & HDMI_AUDIO_MUTE)
-			mutestatus |= (v_AUDIO_MUTE(1) | v_AUDIO_PD(1));
-		hdmi_msk_reg(hdmi_dev, AV_MUTE,
-			     m_AUDIO_MUTE | m_AUDIO_PD | m_VIDEO_BLACK,
-			     mutestatus);
-
-		if (enable == (HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE)) {
-			rockchip_hdmiv1_av_mute(hdmi_drv, 1);
-			msleep(100);
-			rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
-		}
-	}
-	return 0;
-}
-
-int rockchip_hdmiv1_removed(struct hdmi *hdmi_drv)
-{
-	dev_info(hdmi_drv->dev, "Removed.\n");
-	if (hdmi_drv->ops->hdcp_power_off_cb)
-		hdmi_drv->ops->hdcp_power_off_cb(hdmi_drv);
-
-	rockchip_hdmiv1_control_output(hdmi_drv, -1);
-	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
-
-	return HDMI_ERROR_SUCCESS;
-}
-
-static int rockchip_hdmiv1_enable(struct hdmi *hdmi_drv)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (!hdmi_dev->enable) {
-		hdmi_dev->enable = 1;
-		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
-			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));
-	}
-	hdmi_submit_work(hdmi_drv, HDMI_HPD_CHANGE, 10, 0);
-	return 0;
-}
-
-static int rockchip_hdmiv1_disable(struct hdmi *hdmi_drv)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	if (hdmi_dev->enable) {
-		hdmi_dev->enable = 0;
-		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
-			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(0));
-	}
-	return 0;
-}
-
-void rockchip_hdmiv1_irq(struct hdmi *hdmi_drv)
-{
-	u32 interrupt = 0;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	hdmi_readl(hdmi_dev, INTERRUPT_STATUS1, &interrupt);
-	if (interrupt) {
-		hdmi_writel(hdmi_dev, INTERRUPT_STATUS1, interrupt);
-		dev_info(hdmi_drv->dev, "Clear edid irq.\n");
-	}
-
-	hdmi_readl(hdmi_dev, HDMI_STATUS, &interrupt);
-	if (interrupt)
-		hdmi_writel(hdmi_dev, HDMI_STATUS, interrupt);
-	if (interrupt & m_INT_HOTPLUG)
-		hdmi_submit_work(hdmi_drv, HDMI_HPD_CHANGE, 20, 0);
-
-	if (hdmi_drv->ops->hdcp_irq_cb)
-		hdmi_drv->ops->hdcp_irq_cb(0);
-	if (hdmi_drv->property->feature & SUPPORT_CEC)
-		rockchip_hdmiv1_cec_isr(hdmi_dev);
-}
-
-static void rockchip_hdmiv1_reset(struct hdmi *hdmi_drv)
-{
-	u32 val = 0;
-	u32 msk = 0;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);
-	delay100us();
-	hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);
-	delay100us();
-	msk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;
-	val = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;
-	hdmi_msk_reg(hdmi_dev, SYS_CTRL, msk, val);
-
-	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
-}
-
-void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops)
-{
-	if (ops) {
-		ops->disable = rockchip_hdmiv1_disable;
-		ops->enable = rockchip_hdmiv1_enable;
-		ops->remove = rockchip_hdmiv1_removed;
-		ops->setmute = rockchip_hdmiv1_control_output;
-		ops->setvideo = rockchip_hdmiv1_config_video;
-		ops->setaudio = rockchip_hdmiv1_config_audio;
-		ops->getstatus = rockchip_hdmiv1_detect_hotplug;
-		ops->getedid = rockchip_hdmiv1_read_edid;
-		ops->insert	= rockchip_hdmiv1_insert;
-		ops->setvsi = rockchip_hdmiv1_config_vsi;
-	}
-}
-
-int rockchip_hdmiv1_initial(struct hdmi *hdmi_drv)
-{
-	int rc = HDMI_ERROR_SUCCESS;
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-
-	hdmi_dev->pwr_mode = NORMAL;
-
-	if (!hdmi_drv->uboot) {
-		rockchip_hdmiv1_reset_pclk();
-		rockchip_hdmiv1_reset(hdmi_drv);
-		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
-			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(0));
-	} else if (hdmi_drv->ops->getstatus(hdmi_drv) == HDMI_HPD_REMOVED) {
-		rockchip_hdmiv1_removed(hdmi_drv);
-		hdmi_drv->lcdc->uboot_logo = 0;
-		hdmi_drv->uboot = 0;
-	}
-	if (hdmi_drv->property->feature & SUPPORT_CEC)
-		rockchip_hdmiv1_cec_init(hdmi_drv);
-	if (hdmi_drv->property->feature & SUPPORT_HDCP)
-		rockchip_hdmiv1_hdcp_init(hdmi_drv);
-	return rc;
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
deleted file mode 100644
index d3be29dbfb3f..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
+++ /dev/null
@@ -1,472 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROCKCHIP_HDMI_V1_HW_H__
-#define __ROCKCHIP_HDMI_V1_HW_H__
-
-#include <linux/rockchip/iomap.h>
-#include <linux/delay.h>
-
-enum PWR_MODE {
-	NORMAL,
-	LOWER_PWR,
-};
-
-enum {
-	OUTPUT_DVI = 0,
-	OUTPUT_HDMI
-};
-
-/* C0 C2 Change */
-enum {
-	C0_C2_CHANGE_ENABLE,	/* enable c0 c2 change*/
-	C0_C2_CHANGE_DISABLE	/* disable c0 c2 change*/
-};
-
-/* Auto CSC mode enable */
-enum {
-	AUTO_CSC_DISABLE,	/* disable auto csc*/
-	AUTO_CSC_ENABLE	/* enable auto csc*/
-};
-
-/* Color Limit Range */
-enum {
-	COLOR_LIMIT_RANGE_0_255,	/* Color Limit Range 0 To 255*/
-	COLOR_LIMIT_RANGE_16_235,	/* Color Limit Range 16 To 235*/
-};
-
-/* Color Space Conversion Mode */
-enum {
-	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,/* YCbCr 16-235 input to RGB
-					     * 0-255 output according BT601
-					     * that is 8bit clolor depth
-					     */
-	CSC_ITU601_0_255_TO_RGB_0_255_8BIT, /* YCbCr 0-255 input to RGB
-					     * 0-255 output according BT601
-					     * that is 8bit clolor depth
-					     */
-	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,/* YCbCr 16-235 input to RGB
-					     * 0-255 output according BT709
-					     * that is 8bit clolor depth
-					     */
-	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,/* RGB 0-255 input to YCbCr
-					     * 16-235 output according BT601
-					     * that is 8bit clolor depth
-					     */
-	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,/* RGB 0-255 input to YCbCr 16-235
-					     * output accroding BT709 that is
-					     * 8bit clolor depth
-					     */
-	CSC_RGB_0_255_TO_RGB_16_235_8BIT,   /* RGB 0-255 input to RGB 16-235
-					     * output that is 8bit clolor depth
-					     */
-};
-
-#define AUTO_DEFINE_CSC
-#ifdef RK616_USE_MCLK_12M
-#define HDMI_SYS_FREG_CLK        12000000
-#else
-#define HDMI_SYS_FREG_CLK        11289600
-#endif
-
-#define HDMI_SCL_RATE            (100 * 1000)
-#define DDC_BUS_FREQ_L			0x4b
-#define DDC_BUS_FREQ_H			0x4c
-
-#define SYS_CTRL			0x00
-#define m_RST_ANALOG		BIT(6)
-#define v_RST_ANALOG		(0 << 6)
-#define v_NOT_RST_ANALOG	BIT(6)
-
-#define m_RST_DIGITAL		BIT(5)
-#define v_RST_DIGITAL		(0 << 5)
-#define v_NOT_RST_DIGITAL	BIT(5)
-
-#define m_REG_CLK_INV		BIT(4)
-#define v_REG_CLK_NOT_INV	(0 << 4)
-#define v_REG_CLK_INV		BIT(4)
-#define m_VCLK_INV		BIT(3)
-#define v_VCLK_NOT_INV		(0 << 3)
-#define v_VCLK_INV		BIT(3)
-#define m_REG_CLK_SOURCE	BIT(2)
-#define v_REG_CLK_SOURCE_TMDS	(0 << 2)
-#define v_REG_CLK_SOURCE_SYS	BIT(2)
-#define m_POWER			BIT(1)
-#define v_PWR_ON		(0 << 1)
-#define v_PWR_OFF		BIT(1)
-#define m_INT_POL		BIT(0)
-#define v_INT_POL_HIGH		1
-#define v_INT_POL_LOW		0
-
-#define VIDEO_CONTRL1			0x01
-#define m_VIDEO_INPUT_FORMAT	(7 << 1)
-#define m_DE_SOURCE		BIT(0)
-enum {
-	VIDEO_INPUT_SDR_RGB444 = 0,
-	VIDEO_INPUT_DDR_RGB444 = 5,
-	VIDEO_INPUT_DDR_YCBCR422 = 6
-};
-
-#define v_VIDEO_INPUT_FORMAT(n)	(n << 1)
-#define v_DE_EXTERNAL		1
-#define v_DE_INTERNAL		0
-
-#define VIDEO_CONTRL2			0x02
-#define m_VIDEO_OUTPUT_COLOR	(3 << 6)
-#define m_VIDEO_INPUT_BITS	(3 << 4)
-#define m_VIDEO_INPUT_CSP	BIT(0)
-#define v_VIDEO_OUTPUT_COLOR(n) (((n) & 0x3) << 6)
-#define v_VIDEO_INPUT_BITS(n)	(n << 4)
-#define v_VIDEO_INPUT_CSP(n)	(n << 0)
-
-enum {
-	VIDEO_INPUT_12BITS = 0,
-	VIDEO_INPUT_10BITS,
-	VIDEO_INPUT_REVERT,
-	VIDEO_INPUT_8BITS
-};
-
-#define VIDEO_CONTRL			0x03
-#define m_VIDEO_AUTO_CSC		BIT(7)
-#define v_VIDEO_AUTO_CSC(n)		(n << 7)
-#define m_VIDEO_C0_C2_SWAP		BIT(0)
-#define v_VIDEO_C0_C2_SWAP(n)		(n << 0)
-
-#define VIDEO_CONTRL3			0x04
-#define m_COLOR_DEPTH_NOT_INDICATED BIT(4)
-#define m_SOF			BIT(3)
-#define m_COLOR_RANGE		BIT(2)
-#define m_CSC			BIT(0)
-#define v_COLOR_DEPTH_NOT_INDICATED(n) ((n) << 4) /* 1: Force GCP CD[3:0] zero
-						   * 0: GCP CD[3:0] according
-						   *    color depth
-						   */
-#define v_SOF_ENABLE		(0 << 3)
-#define v_SOF_DISABLE		BIT(3)
-#define v_COLOR_RANGE_FULL	BIT(2)
-#define v_COLOR_RANGE_LIMITED	(0 << 2)
-#define v_CSC_ENABLE		1
-#define v_CSC_DISABLE		0
-
-#define AV_MUTE				0x05
-#define m_AVMUTE_CLEAR		BIT(7)
-#define m_AVMUTE_ENABLE		BIT(6)
-#define m_AUDIO_PD		BIT(2)
-#define m_AUDIO_MUTE		BIT(1)
-#define m_VIDEO_BLACK		BIT(0)
-#define v_AVMUTE_CLEAR(n)	(n << 7)
-#define v_AVMUTE_ENABLE(n)	(n << 6)
-#define v_AUDIO_PD(n)		(n << 2)
-#define v_AUDIO_MUTE(n)		(n << 1)
-#define v_VIDEO_MUTE(n)		(n << 0)
-
-#define VIDEO_TIMING_CTL		0x08
-#define v_HSYNC_POLARITY(n)	(n << 3)
-#define v_VSYNC_POLARITY(n)	(n << 2)
-#define v_INETLACE(n)		(n << 1)
-#define v_EXTERANL_VIDEO(n)	(n << 0)
-
-#define VIDEO_EXT_HTOTAL_L		0x09
-#define VIDEO_EXT_HTOTAL_H		0x0a
-#define VIDEO_EXT_HBLANK_L		0x0b
-#define VIDEO_EXT_HBLANK_H		0x0c
-#define VIDEO_EXT_HDELAY_L		0x0d
-#define VIDEO_EXT_HDELAY_H		0x0e
-#define VIDEO_EXT_HDURATION_L		0x0f
-#define VIDEO_EXT_HDURATION_H		0x10
-#define VIDEO_EXT_VTOTAL_L		0x11
-#define VIDEO_EXT_VTOTAL_H		0x12
-#define VIDEO_EXT_VBLANK		0x13
-#define VIDEO_EXT_VDELAY		0x14
-#define VIDEO_EXT_VDURATION		0x15
-
-#define VIDEO_CSC_COEF			0x18
-
-#define AUDIO_CTRL1			0x35
-enum {
-	CTS_SOURCE_INTERNAL = 0,
-	CTS_SOURCE_EXTERNAL
-};
-
-#define v_CTS_SOURCE(n)		(n << 7)
-enum {
-	DOWNSAMPLE_DISABLE = 0,
-	DOWNSAMPLE_1_2,
-	DOWNSAMPLE_1_4
-};
-
-#define v_DOWN_SAMPLE(n)	(n << 5)
-enum {
-	AUDIO_SOURCE_IIS = 0,
-	AUDIO_SOURCE_SPDIF
-};
-
-#define v_AUDIO_SOURCE(n)	(n << 3)
-#define v_MCLK_ENABLE(n)	(n << 2)
-enum {
-	MCLK_128FS = 0,
-	MCLK_256FS,
-	MCLK_384FS,
-	MCLK_512FS
-};
-
-#define v_MCLK_RATIO(n)		(n)
-
-#define AUDIO_SAMPLE_RATE		0x37
-enum {
-	AUDIO_32K = 0x3,
-	AUDIO_441K = 0x0,
-	AUDIO_48K = 0x2,
-	AUDIO_882K = 0x8,
-	AUDIO_96K = 0xa,
-	AUDIO_1764K = 0xc,
-	AUDIO_192K = 0xe,
-};
-
-#define AUDIO_I2S_MODE			0x38
-enum {
-	I2S_CHANNEL_1_2 = 1,
-	I2S_CHANNEL_3_4 = 3,
-	I2S_CHANNEL_5_6 = 7,
-	I2S_CHANNEL_7_8 = 0xf
-};
-
-#define v_I2S_CHANNEL(n)	((n) << 2)
-enum {
-	I2S_STANDARD = 0,
-	I2S_LEFT_JUSTIFIED,
-	I2S_RIGHT_JUSTIFIED
-};
-
-#define v_I2S_MODE(n)		(n)
-
-#define AUDIO_I2S_MAP			0x39
-#define AUDIO_I2S_SWAPS_SPDIF		0x3a
-#define v_SPIDF_FREQ(n)		(n)
-
-#define N_32K		0x1000
-#define N_441K		0x1880
-#define N_882K		0x3100
-#define N_1764K		0x6200
-#define N_48K		0x1800
-#define N_96K		0x3000
-#define N_192K		0x6000
-
-#define AUDIO_CHANNEL_STATUS		0x3e
-	#define m_AUDIO_STATUS_NLPCM		BIT(7)
-	#define m_AUDIO_STATUS_USE		BIT(6)
-	#define m_AUDIO_STATUS_COPYRIGHT	BIT(5)
-	#define m_AUDIO_STATUS_ADDITION		(3 << 2)
-	#define m_AUDIO_STATUS_CLK_ACCURACY	(2 << 0)
-
-	#define v_AUDIO_STATUS_NLPCM(n)		((n & 1) << 7)
-#define AUDIO_N_H			0x3f
-#define AUDIO_N_M			0x40
-#define AUDIO_N_L			0x41
-
-#define AUDIO_CTS_H			0x45
-#define AUDIO_CTS_M			0x46
-#define AUDIO_CTS_L			0x47
-
-#define DDC_CLK_L			0x4b
-#define DDC_CLK_H			0x4c
-
-#define EDID_SEGMENT_POINTER		0x4d
-#define EDID_WORD_ADDR			0x4e
-#define EDID_FIFO_OFFSET		0x4f
-#define EDID_FIFO_ADDR			0x50
-
-#define PACKET_SEND_MANUAL		0x9c
-#define PACKET_SEND_AUTO		0x9d
-	#define m_PACKET_GCP_EN		BIT(7)
-	#define m_PACKET_MSI_EN		BIT(6) /* MPEG Source InfoFrame */
-	#define m_PACKET_SDI_EN		BIT(5) /* Source product descriptor */
-	#define m_PACKET_VSI_EN		BIT(4) /* HDMI Vendor Specific
-						  * InfoFrame
-						  */
-	#define v_PACKET_GCP_EN(n)	((n & 1) << 7)
-	#define v_PACKET_MSI_EN(n)	((n & 1) << 6)
-	#define v_PACKET_SDI_EN(n)	((n & 1) << 5)
-	#define v_PACKET_VSI_EN(n)	((n & 1) << 4)
-
-/* CONTROL_PACKET_BUF_INDEX */
-#define CONTROL_PACKET_BUF_INDEX	0x9f
-enum {
-	INFOFRAME_VSI = 0x05,
-	INFOFRAME_AVI = 0x06,
-	INFOFRAME_AAI = 0x08,
-};
-
-#define CONTROL_PACKET_ADDR		0xa0
-#define SIZE_VSI_INFOFRAME		0x0A	/* 10 bytes */
-#define SIZE_AVI_INFOFRAME		0x11	/* 14 bytes */
-#define SIZE_AUDIO_INFOFRAME		0x0F	/* 15 bytes */
-enum {
-	AVI_COLOR_MODE_RGB = 0,
-	AVI_COLOR_MODE_YCBCR422,
-	AVI_COLOR_MODE_YCBCR444
-};
-
-enum {
-	AVI_COLORIMETRY_NO_DATA = 0,
-	AVI_COLORIMETRY_SMPTE_170M,
-	AVI_COLORIMETRY_ITU709,
-	AVI_COLORIMETRY_EXTENDED
-};
-
-enum {
-	AVI_CODED_FRAME_ASPECT_NO_DATA,
-	AVI_CODED_FRAME_ASPECT_4_3,
-	AVI_CODED_FRAME_ASPECT_16_9
-};
-
-enum {
-	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
-	ACTIVE_ASPECT_RATE_4_3,
-	ACTIVE_ASPECT_RATE_16_9,
-	ACTIVE_ASPECT_RATE_14_9
-};
-
-#define HDCP_CTRL			0x52
-#define m_HDMI_DVI		BIT(1)
-#define v_HDMI_DVI(n)		(n << 1)
-
-#define INTERRUPT_MASK1			0xc0
-#define INTERRUPT_STATUS1		0xc1
-#define	m_INT_ACTIVE_VSYNC	BIT(5)
-#define m_INT_EDID_READY	BIT(2)
-
-#define INTERRUPT_MASK2			0xc2
-#define INTERRUPT_STATUS2		0xc3
-#define m_INT_HDCP_ERR		BIT(7)
-#define m_INT_BKSV_FLAG		BIT(6)
-#define m_INT_HDCP_OK		BIT(4)
-
-#define HDMI_STATUS			0xc8
-	#define m_HOTPLUG	BIT(7)
-	#define m_MASK_INT_HOTPLUG	BIT(5)
-	#define m_INT_HOTPLUG		BIT(1)
-	#define v_MASK_INT_HOTPLUG(n)	((n & 0x1) << 5)
-
-#define HDMI_COLORBAR                   0xc9
-
-#define PHY_SYNC			0xce	/* sync phy parameter */
-#define PHY_SYS_CTL			0xe0
-#define m_TMDS_CLK_SOURCE	BIT(5)
-#define v_TMDS_FROM_PLL		(0 << 5)
-#define v_TMDS_FROM_GEN		BIT(5)
-#define m_PHASE_CLK		BIT(4)
-#define v_DEFAULT_PHASE		(0 << 4)
-#define v_SYNC_PHASE		BIT(4)
-#define m_TMDS_CURRENT_PWR	BIT(3)
-#define v_TURN_ON_CURRENT	(0 << 3)
-#define v_CAT_OFF_CURRENT	BIT(3)
-#define m_BANDGAP_PWR		BIT(2)
-#define v_BANDGAP_PWR_UP	(0 << 2)
-#define v_BANDGAP_PWR_DOWN	BIT(2)
-#define m_PLL_PWR		BIT(1)
-#define v_PLL_PWR_UP		(0 << 1)
-#define v_PLL_PWR_DOWN		BIT(1)
-#define m_TMDS_CHG_PWR		BIT(0)
-#define v_TMDS_CHG_PWR_UP	(0 << 0)
-#define v_TMDS_CHG_PWR_DOWN	BIT(0)
-
-#define PHY_CHG_PWR			0xe1
-#define v_CLK_CHG_PWR(n)	((n & 1) << 3)
-#define v_DATA_CHG_PWR(n)	((n & 7) << 0)
-
-#define PHY_DRIVER			0xe2
-#define v_CLK_MAIN_DRIVER(n)	(n << 4)
-#define v_DATA_MAIN_DRIVER(n)	(n << 0)
-
-#define PHY_PRE_EMPHASIS		0xe3
-#define v_PRE_EMPHASIS(n)	((n & 7) << 4)
-#define v_CLK_PRE_DRIVER(n)	((n & 3) << 2)
-#define v_DATA_PRE_DRIVER(n)	((n & 3) << 0)
-
-#define PHY_FEEDBACK_DIV_RATIO_LOW	0xe7
-#define v_FEEDBACK_DIV_LOW(n)	(n & 0xff)
-#define PHY_FEEDBACK_DIV_RATIO_HIGH	0xe8
-#define v_FEEDBACK_DIV_HIGH(n)	(n & 1)
-
-#define PHY_PRE_DIV_RATIO		0xed
-#define v_PRE_DIV_RATIO(n)	(n & 0x1f)
-
-/*-----START----- HDMI CEC CTRL------START------*/
-#define CEC_CTRL		0xd0
-	#define m_ADJUST_FOR_HISENSE	BIT(6)
-	#define m_REJECT_RX_BROADCAST	BIT(5)
-	#define m_BUSFREETIME_ENABLE	BIT(2)
-	#define m_REJECT_RX				BIT(1)
-	#define m_START_TX				BIT(0)
-
-#define CEC_DATA		0xd1
-#define CEC_TX_OFFSET	0xd2
-#define CEC_RX_OFFSET	0xd3
-#define CEC_CLK_H		0xd4
-#define CEC_CLK_L		0xd5
-#define CEC_TX_LENGTH	0xd6
-#define CEC_RX_LENGTH	0xd7
-#define CEC_TX_INT_MASK	0xd8
-	#define m_TX_DONE			BIT(3)
-	#define m_TX_NOACK			BIT(2)
-	#define m_TX_BROADCAST_REJ		BIT(1)
-	#define m_TX_BUSNOTFREE			BIT(0)
-
-#define CEC_RX_INT_MASK 0xd9
-	#define m_RX_LA_ERR			BIT(4)
-	#define m_RX_GLITCH			BIT(3)
-	#define m_RX_DONE			BIT(0)
-
-#define CEC_TX_INT		0xda
-#define CEC_RX_INT		0xdb
-#define CEC_BUSFREETIME_L	0xdc
-#define CEC_BUSFREETIME_H	0xdd
-#define CEC_LOGICADDR		0xde
-/*------END------ HDMI CEC CTRL------END-------*/
-
-static inline int hdmi_readl(struct hdmi_dev *hdmi_dev,
-			     u16 offset,
-			     u32 *val)
-{
-	int ret = 0;
-
-	*val = readl_relaxed(hdmi_dev->regbase + (offset) * 0x04);
-	return ret;
-}
-
-static inline int hdmi_writel(struct hdmi_dev *hdmi_dev,
-			      u16 offset,
-			      u32 val)
-{
-	int ret = 0;
-
-	writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
-	return ret;
-}
-
-static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
-			       u16 offset, u32 msk, u32 val)
-{
-	int ret = 0;
-	u32 temp;
-
-	temp = readl_relaxed(hdmi_dev->regbase +
-			     (offset) * 0x04) & (0xFF - (msk));
-	writel_relaxed(temp | ((val) & (msk)),
-		       hdmi_dev->regbase + (offset) * 0x04);
-	return ret;
-}
-
-static inline void rockchip_hdmiv1_reset_pclk(void)
-{
-	writel_relaxed(0x00010001, RK_CRU_VIRT + 0x128);
-	msleep(100);
-	writel_relaxed(0x00010000, RK_CRU_VIRT + 0x128);
-}
-
-void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops);
-int rockchip_hdmiv1_initial(struct hdmi *hdmi);
-void rockchip_hdmiv1_irq(struct hdmi *hdmi);
-void rockchip_hdmiv1_cec_init(struct hdmi *hdmi);
-void rockchip_hdmiv1_cec_isr(struct hdmi_dev *hdmi_dev);
-
-#endif
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig
deleted file mode 100644
index c45593abbf58..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config  RK_HDMI_V2
-        bool "RockChip HDMI V2 support"
-        depends on RK_HDMI
-        default y
-        help
-		Rockchip hdmi version 2 which support hdmi 2.0.
-
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile
deleted file mode 100644
index f853c433cb9f..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for HDMI linux kernel module.
-#
-
-ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
-
-obj-$(CONFIG_RK_HDMI_V2) += rockchip_hdmiv2.o rockchip_hdmiv2_hw.o rockchip_hdmiv2_cec.o rockchip_hdmiv2_hdcp.o
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
deleted file mode 100644
index 0b0ff31ddd81..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
+++ /dev/null
@@ -1,841 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/interrupt.h>
-#include <linux/clk.h>
-#include <linux/of_gpio.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/grf.h>
-#include <linux/mfd/syscon.h>
-#if defined(CONFIG_DEBUG_FS)
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#endif
-
-#include "rockchip_hdmiv2.h"
-#include "rockchip_hdmiv2_hw.h"
-
-static struct hdmi_dev *hdmi_dev;
-
-static struct hdmi_property rk_hdmi_property = {
-	.videosrc = DISPLAY_SOURCE_LCDC0,
-	.display = DISPLAY_MAIN,
-};
-
-#if defined(CONFIG_DEBUG_FS)
-static const struct rockchip_hdmiv2_reg_table hdmi_reg_table[] = {
-	{IDENTIFICATION_BASE, CONFIG3_ID},
-	{INTERRUPT_BASE, IH_MUTE},
-	{VIDEO_SAMPLER_BASE, TX_BCBDATA1},
-	{VIDEO_PACKETIZER_BASE, VP_MASK},
-	{FRAME_COMPOSER_BASE, FC_DBGTMDS2},
-	{HDMI_SOURCE_PHY_BASE, PHY_PLLCFGFREQ2},
-	{I2C_MASTER_PHY_BASE, PHY_I2CM_SDA_HOLD},
-	{AUDIO_SAMPLER_BASE, AHB_DMA_STPADDR_SET1_0},
-	{MAIN_CONTROLLER_BASE, MC_SWRSTZREQ_2},
-	{COLOR_SPACE_CONVERTER_BASE, CSC_SPARE_2},
-	{HDCP_ENCRYPTION_ENGINE_BASE, HDCP_REVOC_LIST},
-	{HDCP_BKSV_BASE, HDCPREG_BKSV4},
-	{HDCP_AN_BASE, HDCPREG_AN7},
-	{HDCP2REG_BASE, HDCP2REG_MUTE},
-	{ENCRYPTED_DPK_EMBEDDED_BASE, HDCPREG_DPK6},
-	{CEC_ENGINE_BASE, CEC_WKUPCTRL},
-	{I2C_MASTER_BASE, I2CM_SCDC_UPDATE1},
-};
-
-static int hdmi_regs_ctrl_show(struct seq_file *s, void *v)
-{
-	u32 i = 0, j = 0, val = 0;
-
-	seq_puts(s, "\n>>>hdmi_ctl reg ");
-	for (i = 0; i < 16; i++)
-		seq_printf(s, " %2x", i);
-	seq_puts(s, "\n-----------------------------------------------------------------");
-
-	for (i = 0; i < ARRAY_SIZE(hdmi_reg_table); i++) {
-		for (j = hdmi_reg_table[i].reg_base;
-		     j <= hdmi_reg_table[i].reg_end; j++) {
-			val = hdmi_readl(hdmi_dev, j);
-			if ((j - hdmi_reg_table[i].reg_base) % 16 == 0)
-				seq_printf(s, "\n>>>hdmi_ctl %04x:", j);
-			seq_printf(s, " %02x", val);
-		}
-	}
-	seq_puts(s, "\n-----------------------------------------------------------------\n");
-
-	return 0;
-}
-
-static ssize_t hdmi_regs_ctrl_write(struct file *file,
-				    const char __user *buf,
-				    size_t count, loff_t *ppos)
-{
-	u32 reg, val;
-	char kbuf[25];
-
-	if (copy_from_user(kbuf, buf, count))
-		return -EFAULT;
-	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
-		return -EFAULT;
-	if ((reg < 0) || (reg > I2CM_SCDC_UPDATE1)) {
-		dev_info(hdmi_dev->hdmi->dev, "it is no hdmi reg\n");
-		return count;
-	}
-	dev_info(hdmi_dev->hdmi->dev,
-		 "/**********hdmi reg config******/");
-	dev_info(hdmi_dev->hdmi->dev, "\n reg=%x val=%x\n", reg, val);
-	hdmi_writel(hdmi_dev, reg, val);
-
-	return count;
-}
-
-static int hdmi_regs_phy_show(struct seq_file *s, void *v)
-{
-	u32 i, count;
-
-	if (hdmi_dev->soctype == HDMI_SOC_RK322X)
-		count = 0xff;
-	else
-		count = 0x28;
-	seq_puts(s, "\n>>>hdmi_phy reg ");
-	for (i = 0; i < count; i++)
-		seq_printf(s, "regs %02x val %04x\n",
-			   i, rockchip_hdmiv2_read_phy(hdmi_dev, i));
-	return 0;
-}
-
-static ssize_t hdmi_regs_phy_write(struct file *file,
-				   const char __user *buf,
-				   size_t count, loff_t *ppos)
-{
-	u32 reg, val;
-	char kbuf[25];
-
-	if (copy_from_user(kbuf, buf, count))
-		return -EFAULT;
-	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
-		return -EFAULT;
-	dev_info(hdmi_dev->hdmi->dev,
-		 "/**********hdmi reg phy config******/");
-	dev_info(hdmi_dev->hdmi->dev, "\n reg=%x val=%x\n", reg, val);
-	rockchip_hdmiv2_write_phy(hdmi_dev, reg, val);
-	return count;
-}
-
-#define HDMI_DEBUG_ENTRY(name) \
-static int hdmi_##name##_open(struct inode *inode, struct file *file) \
-{ \
-	return single_open(file, hdmi_##name##_show, inode->i_private); \
-} \
-\
-static const struct file_operations hdmi_##name##_fops = { \
-	.owner = THIS_MODULE, \
-	.open = hdmi_##name##_open, \
-	.read = seq_read, \
-	.write = hdmi_##name##_write,	\
-	.llseek = seq_lseek, \
-	.release = single_release, \
-}
-
-HDMI_DEBUG_ENTRY(regs_phy);
-HDMI_DEBUG_ENTRY(regs_ctrl);
-#endif
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void rockchip_hdmiv2_early_suspend(struct early_suspend *h)
-{
-	struct hdmi *hdmi = hdmi_dev->hdmi;
-	struct pinctrl_state *gpio_state;
-
-	HDMIDBG(2, "hdmi enter early suspend\n");
-	hdmi_submit_work(hdmi, HDMI_SUSPEND_CTL, 0, 1);
-	/* iomux to gpio and pull down when suspend */
-	gpio_state = pinctrl_lookup_state(hdmi_dev->dev->pins->p, "gpio");
-	pinctrl_select_state(hdmi_dev->dev->pins->p, gpio_state);
-	rockchip_hdmiv2_clk_disable(hdmi_dev);
-}
-
-static void rockchip_hdmiv2_early_resume(struct early_suspend *h)
-{
-	struct hdmi *hdmi = hdmi_dev->hdmi;
-
-	HDMIDBG(2, "hdmi exit early resume\n");
-	/* iomux to default state for hdmi use when resume */
-	pinctrl_select_state(hdmi_dev->dev->pins->p,
-			     hdmi_dev->dev->pins->default_state);
-	rockchip_hdmiv2_clk_enable(hdmi_dev);
-	hdmi_dev_initial(hdmi_dev);
-	if (hdmi->ops->hdcp_power_on_cb)
-		hdmi->ops->hdcp_power_on_cb();
-	hdmi_submit_work(hdmi, HDMI_RESUME_CTL, 0, 0);
-}
-#endif
-
-void ext_pll_set_27m_out(void)
-{
-	if (!hdmi_dev || hdmi_dev->soctype != HDMI_SOC_RK322X)
-		return;
-	/* PHY PLL VCO is 1080MHz, output pclk is 27MHz */
-	rockchip_hdmiv2_write_phy(hdmi_dev,
-				  EXT_PHY_PLL_PRE_DIVIDER,
-				  1);
-	rockchip_hdmiv2_write_phy(hdmi_dev,
-				  EXT_PHY_PLL_FB_DIVIDER,
-				  45);
-	rockchip_hdmiv2_write_phy(hdmi_dev,
-				  EXT_PHY_PCLK_DIVIDER1,
-				  0x61);
-	rockchip_hdmiv2_write_phy(hdmi_dev,
-				  EXT_PHY_PCLK_DIVIDER2,
-				  0x64);
-	rockchip_hdmiv2_write_phy(hdmi_dev,
-				  EXT_PHY_TMDSCLK_DIVIDER,
-				  0x1d);
-}
-
-static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
-{
-	if ((hdmi_dev->clk_on & HDMI_PD_ON) == 0) {
-		pm_runtime_get_sync(hdmi_dev->dev);
-		hdmi_dev->clk_on |= HDMI_PD_ON;
-	}
-
-	if (hdmi_dev->soctype == HDMI_SOC_RK322X ||
-	    hdmi_dev->soctype == HDMI_SOC_RK3366 ||
-	    hdmi_dev->soctype == HDMI_SOC_RK3399) {
-		if ((hdmi_dev->clk_on & HDMI_EXT_PHY_CLK_ON) == 0) {
-			if (!hdmi_dev->pclk_phy) {
-				if (hdmi_dev->soctype == HDMI_SOC_RK322X)
-					hdmi_dev->pclk_phy =
-						devm_clk_get(hdmi_dev->dev,
-							     "pclk_hdmi_phy");
-				else
-					hdmi_dev->pclk_phy =
-						devm_clk_get(hdmi_dev->dev,
-							     "dclk_hdmi_phy");
-				if (IS_ERR(hdmi_dev->pclk_phy)) {
-					dev_err(hdmi_dev->dev,
-						"get hdmi phy pclk error\n");
-					return -1;
-				}
-			}
-			clk_prepare_enable(hdmi_dev->pclk_phy);
-			hdmi_dev->clk_on |= HDMI_EXT_PHY_CLK_ON;
-		}
-	}
-	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) {
-		if (!hdmi_dev->pclk) {
-			hdmi_dev->pclk =
-				devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
-			if (IS_ERR(hdmi_dev->pclk)) {
-				dev_err(hdmi_dev->dev,
-					"Unable to get hdmi pclk\n");
-				return -1;
-			}
-		}
-		clk_prepare_enable(hdmi_dev->pclk);
-		hdmi_dev->clk_on |= HDMI_PCLK_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) == 0) {
-		if (!hdmi_dev->hdcp_clk) {
-			hdmi_dev->hdcp_clk =
-				devm_clk_get(hdmi_dev->dev, "hdcp_clk_hdmi");
-			if (IS_ERR(hdmi_dev->hdcp_clk)) {
-				dev_err(hdmi_dev->dev,
-					"Unable to get hdmi hdcp_clk\n");
-				return -1;
-			}
-		}
-		clk_prepare_enable(hdmi_dev->hdcp_clk);
-		hdmi_dev->clk_on |= HDMI_HDCPCLK_ON;
-	}
-
-	if ((rk_hdmi_property.feature & SUPPORT_CEC) &&
-	    (hdmi_dev->clk_on & HDMI_CECCLK_ON) == 0) {
-		if (!hdmi_dev->cec_clk) {
-			hdmi_dev->cec_clk =
-				devm_clk_get(hdmi_dev->dev, "cec_clk_hdmi");
-			if (IS_ERR(hdmi_dev->cec_clk)) {
-				dev_err(hdmi_dev->dev,
-					"Unable to get hdmi cec_clk\n");
-				return -1;
-			}
-		}
-		clk_prepare_enable(hdmi_dev->cec_clk);
-		hdmi_dev->clk_on |= HDMI_CECCLK_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_SFRCLK_ON) == 0) {
-		if (!hdmi_dev->sfr_clk) {
-			hdmi_dev->sfr_clk =
-				devm_clk_get(hdmi_dev->dev, "sclk_hdmi_sfr");
-			if (IS_ERR(hdmi_dev->sfr_clk)) {
-				dev_err(hdmi_dev->dev,
-					"Unable to get hdmi sfr_clk\n");
-				return -1;
-			}
-		}
-		clk_prepare_enable(hdmi_dev->sfr_clk);
-		hdmi_dev->clk_on |= HDMI_SFRCLK_ON;
-	}
-
-	return 0;
-}
-
-static int rockchip_hdmiv2_clk_disable(struct hdmi_dev *hdmi_dev)
-{
-	if (hdmi_dev->clk_on == 0)
-		return 0;
-
-	if ((hdmi_dev->clk_on & HDMI_PD_ON)) {
-		pm_runtime_put(hdmi_dev->dev);
-		hdmi_dev->clk_on &= ~HDMI_PD_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) &&
-	    hdmi_dev->pclk) {
-		clk_disable_unprepare(hdmi_dev->pclk);
-		hdmi_dev->clk_on &= ~HDMI_PCLK_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) &&
-	    hdmi_dev->hdcp_clk) {
-		clk_disable_unprepare(hdmi_dev->hdcp_clk);
-		hdmi_dev->clk_on &= ~HDMI_HDCPCLK_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_EXT_PHY_CLK_ON) &&
-	    hdmi_dev->pclk_phy) {
-		clk_disable_unprepare(hdmi_dev->pclk_phy);
-		hdmi_dev->clk_on &= ~HDMI_EXT_PHY_CLK_ON;
-	}
-
-	if ((hdmi_dev->clk_on & HDMI_SFRCLK_ON) &&
-	    (hdmi_dev->sfr_clk)) {
-		clk_disable_unprepare(hdmi_dev->sfr_clk);
-		hdmi_dev->clk_on &= ~HDMI_SFRCLK_ON;
-	}
-
-
-	return 0;
-}
-
-static int rockchip_hdmiv2_fb_event_notify(struct notifier_block *self,
-					   unsigned long action, void *data)
-{
-	struct fb_event *event = data;
-	struct hdmi *hdmi = hdmi_dev->hdmi;
-	struct pinctrl_state *gpio_state;
-#ifdef CONFIG_PINCTRL
-	struct dev_pin_info *pins = hdmi_dev->dev->pins;
-#endif
-
-	if (action == FB_EARLY_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			break;
-		default:
-			HDMIDBG(2, "suspend hdmi\n");
-			if (!hdmi->sleep) {
-				hdmi_submit_work(hdmi,
-						 HDMI_SUSPEND_CTL,
-						 0, 1);
-				if (hdmi_dev->hdcp2_en)
-					hdmi_dev->hdcp2_en(0);
-				mutex_lock(&hdmi->pclk_lock);
-				rockchip_hdmiv2_clk_disable(hdmi_dev);
-				mutex_unlock(&hdmi->pclk_lock);
-				#ifdef CONFIG_PINCTRL
-				if (hdmi_dev->soctype == HDMI_SOC_RK3288)
-					gpio_state =
-					pinctrl_lookup_state(pins->p,
-							     "sleep");
-				else
-					gpio_state =
-					pinctrl_lookup_state(pins->p,
-							     "gpio");
-				pinctrl_select_state(pins->p,
-						     gpio_state);
-				#endif
-			}
-			break;
-		}
-	} else if (action == FB_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			HDMIDBG(2, "resume hdmi\n");
-			if (hdmi->sleep) {
-				#ifdef CONFIG_PINCTRL
-				pinctrl_select_state(pins->p,
-						     pins->default_state);
-				#endif
-				mutex_lock(&hdmi->pclk_lock);
-				rockchip_hdmiv2_clk_enable(hdmi_dev);
-				mutex_unlock(&hdmi->pclk_lock);
-				rockchip_hdmiv2_dev_initial(hdmi_dev);
-				if (hdmi->ops->hdcp_power_on_cb)
-					hdmi->ops->hdcp_power_on_cb();
-				if (hdmi_dev->hdcp2_reset)
-					hdmi_dev->hdcp2_reset();
-				if (hdmi_dev->hdcp2_en)
-					hdmi_dev->hdcp2_en(1);
-				hdmi_submit_work(hdmi, HDMI_RESUME_CTL,
-						 0, 0);
-			}
-			break;
-		default:
-			break;
-		}
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block rockchip_hdmiv2_fb_notifier = {
-	.notifier_call = rockchip_hdmiv2_fb_event_notify,
-};
-
-#ifdef HDMI_INT_USE_POLL
-static void rockchip_hdmiv2_irq_work_func(struct work_struct *work)
-{
-	if (hdmi_dev->enable) {
-		rockchip_hdmiv2_dev_irq(0, hdmi_dev);
-		queue_delayed_work(hdmi_dev->workqueue,
-				   &hdmi_dev->delay_work,
-				   msecs_to_jiffies(50));
-	}
-}
-#endif
-
-static struct hdmi_ops rk_hdmi_ops;
-
-#if defined(CONFIG_OF)
-static const struct of_device_id rk_hdmi_dt_ids[] = {
-	{.compatible = "rockchip,rk322x-hdmi",},
-	{.compatible = "rockchip,rk3288-hdmi",},
-	{.compatible = "rockchip,rk3366-hdmi",},
-	{.compatible = "rockchip,rk3368-hdmi",},
-	{.compatible = "rockchip,rk3399-hdmi",},
-	{}
-};
-
-static int hdmi_get_prop_dts(struct hdmi *hdmi, struct device_node *np)
-{
-	const struct property *prop;
-	int i = 0, nstates = 0;
-	const __be32 *val;
-	int value;
-	struct edid_prop_value *pval = NULL;
-
-	if (!hdmi || !np) {
-		pr_info("%s:line=%d hdmi or np is null\n", __func__, __LINE__);
-		return -1;
-	}
-
-	if (!of_property_read_u32(np, "hdmi_edid_auto_support", &value))
-		hdmi->edid_auto_support = value;
-
-	prop = of_find_property(np, "hdmi_edid_prop_value", NULL);
-	if (!prop || !prop->value) {
-		pr_info("%s:No edid-prop-value, %d\n", __func__, !prop);
-		return -1;
-	}
-
-	nstates = (prop->length / sizeof(struct edid_prop_value));
-	pval = kcalloc(nstates, sizeof(struct edid_prop_value), GFP_NOWAIT);
-
-	for (i = 0, val = prop->value; i < nstates; i++) {
-		pval[i].vid = be32_to_cpup(val++);
-		pval[i].pid = be32_to_cpup(val++);
-		pval[i].sn = be32_to_cpup(val++);
-		pval[i].xres = be32_to_cpup(val++);
-		pval[i].yres = be32_to_cpup(val++);
-		pval[i].vic = be32_to_cpup(val++);
-		pval[i].width = be32_to_cpup(val++);
-		pval[i].height = be32_to_cpup(val++);
-		pval[i].x_w = be32_to_cpup(val++);
-		pval[i].x_h = be32_to_cpup(val++);
-		pval[i].hwrotation = be32_to_cpup(val++);
-		pval[i].einit = be32_to_cpup(val++);
-		pval[i].vsync = be32_to_cpup(val++);
-		pval[i].panel = be32_to_cpup(val++);
-		pval[i].scan = be32_to_cpup(val++);
-
-		pr_info("%s: 0x%x 0x%x 0x%x %d %d %d %d %d %d %d %d %d %d %d %d\n",
-			__func__, pval[i].vid, pval[i].pid, pval[i].sn,
-			pval[i].width, pval[i].height, pval[i].xres,
-			pval[i].yres, pval[i].vic, pval[i].x_w,
-			pval[i].x_h, pval[i].hwrotation, pval[i].einit,
-			pval[i].vsync, pval[i].panel, pval[i].scan);
-	}
-
-	hdmi->pvalue = pval;
-	hdmi->nstates = nstates;
-
-	return 0;
-}
-
-static int rockchip_hdmiv2_parse_dt(struct hdmi_dev *hdmi_dev)
-{
-	int val = 0;
-	struct device_node *np = hdmi_dev->dev->of_node;
-	const struct of_device_id *match;
-
-	match = of_match_node(rk_hdmi_dt_ids, np);
-	if (!match)
-		return -EINVAL;
-
-	if (!strcmp(match->compatible, "rockchip,rk3288-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK3288;
-	} else if (!strcmp(match->compatible, "rockchip,rk3368-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK3368;
-	} else if (!strcmp(match->compatible, "rockchip,rk322x-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK322X;
-	} else if (!strcmp(match->compatible, "rockchip,rk3366-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK3366;
-	} else if (!strcmp(match->compatible, "rockchip,rk3399-hdmi")) {
-		hdmi_dev->soctype = HDMI_SOC_RK3399;
-	} else {
-		pr_err("It is not a valid rockchip soc!");
-		return -ENOMEM;
-	}
-
-	if (!of_property_read_u32(np, "rockchip,hdmi_video_source", &val))
-		rk_hdmi_property.videosrc = val;
-
-	if (!of_property_read_u32(np, "rockchip,hdmi_audio_source", &val))
-		hdmi_dev->audiosrc = val;
-
-	if (!of_property_read_u32(np, "rockchip,cec_enable", &val) &&
-	    (val == 1)) {
-		pr_debug("hdmi support cec\n");
-		rk_hdmi_property.feature |= SUPPORT_CEC;
-	}
-	if (!of_property_read_u32(np, "rockchip,hdcp_enable", &val) &&
-	    (val == 1)) {
-		pr_debug("hdmi support hdcp\n");
-		rk_hdmi_property.feature |= SUPPORT_HDCP;
-	}
-	if (!of_property_read_u32(np, "rockchip,defaultmode", &val) &&
-	    (val > 0)) {
-		pr_debug("default mode is %d\n", val);
-		rk_hdmi_property.defaultmode = val;
-	} else {
-		rk_hdmi_property.defaultmode = HDMI_VIDEO_DEFAULT_MODE;
-	}
-	if (!of_property_read_u32(np, "rockchip,defaultdepth", &val) &&
-	    (val > 0)) {
-		pr_info("default depth is %d\n", val);
-		rk_hdmi_property.defaultdepth = val;
-	} else {
-		rk_hdmi_property.defaultdepth = HDMI_VIDEO_DEFAULT_COLORDEPTH;
-	}
-	if (of_get_property(np, "rockchip,phy_table", &val)) {
-		hdmi_dev->phy_table = kmalloc(val, GFP_KERNEL);
-		if (!hdmi_dev->phy_table) {
-			pr_err("kmalloc phy table %d error\n", val);
-			return -ENOMEM;
-		}
-		hdmi_dev->phy_table_size =
-				val / sizeof(struct hdmi_dev_phy_para);
-		of_property_read_u32_array(np, "rockchip,phy_table",
-					   (u32 *)hdmi_dev->phy_table,
-					   val / sizeof(u32));
-	} else {
-		pr_info("hdmi phy_table not exist\n");
-	}
-
-	of_property_read_string(np, "rockchip,vendor",
-				&hdmi_dev->vendor_name);
-	of_property_read_string(np, "rockchip,product",
-				&hdmi_dev->product_name);
-	if (!of_property_read_u32(np, "rockchip,deviceinfo", &val))
-		hdmi_dev->deviceinfo = val & 0xff;
-
-	#ifdef CONFIG_MFD_SYSCON
-	hdmi_dev->grf_base =
-		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-	if (IS_ERR(hdmi_dev->grf_base))
-		hdmi_dev->grf_base = NULL;
-	#endif
-	return 0;
-}
-#endif
-
-static int rockchip_hdmiv2_probe(struct platform_device *pdev)
-{
-	int ret = -1;
-	struct resource *res;
-
-	HDMIDBG(2, "%s\n", __func__);
-	hdmi_dev = kmalloc(sizeof(*hdmi_dev), GFP_KERNEL);
-	if (!hdmi_dev) {
-		dev_err(&pdev->dev, ">>rockchip hdmiv2 kmalloc fail!");
-		return -ENOMEM;
-	}
-	memset(hdmi_dev, 0, sizeof(struct hdmi_dev));
-	platform_set_drvdata(pdev, hdmi_dev);
-	hdmi_dev->dev = &pdev->dev;
-
-	if (rockchip_hdmiv2_parse_dt(hdmi_dev))
-		goto failed;
-
-	/*request and remap iomem*/
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Unable to get register resource\n");
-		ret = -ENXIO;
-		goto failed;
-	}
-	hdmi_dev->regbase = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(hdmi_dev->regbase)) {
-		ret = PTR_ERR(hdmi_dev->regbase);
-		dev_err(&pdev->dev,
-			"cannot ioremap registers,err=%d\n", ret);
-		goto failed;
-	}
-	if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-		if (!res) {
-			dev_err(&pdev->dev,
-				"Unable to get phy register resource\n");
-			ret = -ENXIO;
-			goto failed;
-		}
-		hdmi_dev->phybase = devm_ioremap_resource(&pdev->dev, res);
-		if (IS_ERR(hdmi_dev->phybase)) {
-			ret = PTR_ERR(hdmi_dev->phybase);
-			dev_err(&pdev->dev,
-				"cannot ioremap registers,err=%d\n", ret);
-			goto failed;
-		}
-	}
-
-	hdmi_dev->reset = devm_reset_control_get(&pdev->dev, "hdmi");
-	if (IS_ERR(hdmi_dev->reset) &&
-	    hdmi_dev->soctype != HDMI_SOC_RK3288) {
-		ret = PTR_ERR(hdmi_dev->reset);
-		dev_err(&pdev->dev, "failed to get hdmi reset: %d\n", ret);
-		goto failed;
-	}
-	pm_runtime_enable(hdmi_dev->dev);
-	/*enable pd and clk*/
-	if (rockchip_hdmiv2_clk_enable(hdmi_dev) < 0) {
-		dev_err(&pdev->dev, "failed to enable hdmi clk\n");
-		ret = -ENXIO;
-		goto failed1;
-	}
-	rockchip_hdmiv2_dev_init_ops(&rk_hdmi_ops);
-	/* Register HDMI device */
-	rk_hdmi_property.name = (char *)pdev->name;
-	rk_hdmi_property.priv = hdmi_dev;
-	if (hdmi_dev->soctype == HDMI_SOC_RK3288) {
-		rk_hdmi_property.feature |= SUPPORT_DEEP_10BIT;
-		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
-			rk_hdmi_property.feature |=
-						SUPPORT_4K |
-						SUPPORT_TMDS_600M;
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3368) {
-		rk_hdmi_property.feature |=
-				SUPPORT_4K |
-				SUPPORT_4K_4096 |
-				SUPPORT_YUV420 |
-				SUPPORT_YCBCR_INPUT |
-				SUPPORT_VESA_DMT;
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
-		rk_hdmi_property.feature |=
-				SUPPORT_4K |
-				SUPPORT_4K_4096 |
-				SUPPORT_YCBCR_INPUT |
-				SUPPORT_1080I |
-				SUPPORT_480I_576I;
-		/*
-		 *if (rockchip_get_cpu_version())
-		 *	rk_hdmi_property.feature |=
-		 *		SUPPORT_YUV420 |
-		 *		SUPPORT_DEEP_10BIT;
-		 */
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3366) {
-		rk_hdmi_property.feature |=
-				SUPPORT_YCBCR_INPUT |
-				SUPPORT_1080I |
-				SUPPORT_480I_576I;
-		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
-			rk_hdmi_property.feature |=
-						SUPPORT_4K |
-						SUPPORT_4K_4096 |
-						SUPPORT_YUV420 |
-						SUPPORT_YCBCR_INPUT |
-						SUPPORT_TMDS_600M;
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
-		rk_hdmi_property.feature |=
-				SUPPORT_DEEP_10BIT |
-				SUPPORT_YCBCR_INPUT |
-				SUPPORT_1080I |
-				SUPPORT_480I_576I |
-				SUPPORT_VESA_DMT |
-				SUPPORT_RK_DISCRETE_VR;
-		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
-			rk_hdmi_property.feature |=
-						SUPPORT_4K |
-						SUPPORT_4K_4096 |
-						SUPPORT_YUV420 |
-						SUPPORT_YCBCR_INPUT |
-						SUPPORT_TMDS_600M;
-	} else {
-		ret = -ENXIO;
-		goto failed1;
-	}
-	hdmi_dev->hdmi =
-		rockchip_hdmi_register(&rk_hdmi_property, &rk_hdmi_ops);
-	if (!hdmi_dev->hdmi) {
-		dev_err(&pdev->dev, "register hdmi device failed\n");
-		ret = -ENOMEM;
-		goto failed1;
-	}
-
-	hdmi_get_prop_dts(hdmi_dev->hdmi, hdmi_dev->dev->of_node);
-	mutex_init(&hdmi_dev->ddc_lock);
-	hdmi_dev->hdmi->dev = &pdev->dev;
-	hdmi_dev->hdmi->soctype = hdmi_dev->soctype;
-	fb_register_client(&rockchip_hdmiv2_fb_notifier);
-	rockchip_hdmiv2_dev_initial(hdmi_dev);
-	pinctrl_select_state(hdmi_dev->dev->pins->p,
-			     hdmi_dev->dev->pins->default_state);
-#if defined(CONFIG_DEBUG_FS)
-	hdmi_dev->debugfs_dir = debugfs_create_dir("rockchip_hdmiv2", NULL);
-	if (IS_ERR(hdmi_dev->debugfs_dir))
-		dev_err(hdmi_dev->hdmi->dev,
-			"failed to create debugfs dir for rockchip hdmiv2!\n");
-	else {
-		debugfs_create_file("regs_ctrl", S_IRUSR,
-				    hdmi_dev->debugfs_dir,
-				    hdmi_dev, &hdmi_regs_ctrl_fops);
-		debugfs_create_file("regs_phy", S_IRUSR,
-				    hdmi_dev->debugfs_dir,
-				    hdmi_dev, &hdmi_regs_phy_fops);
-	}
-#endif
-
-#ifndef HDMI_INT_USE_POLL
-	/* get and request the IRQ */
-	hdmi_dev->irq = platform_get_irq(pdev, 0);
-	if (hdmi_dev->irq <= 0) {
-		dev_err(hdmi_dev->dev,
-			"failed to get hdmi irq resource (%d).\n",
-			hdmi_dev->irq);
-		ret = -ENXIO;
-		goto failed1;
-	}
-
-	ret = devm_request_irq(hdmi_dev->dev, hdmi_dev->irq,
-			       rockchip_hdmiv2_dev_irq,
-			       IRQF_TRIGGER_HIGH,
-			       dev_name(hdmi_dev->dev), hdmi_dev);
-	if (ret) {
-		dev_err(hdmi_dev->dev,
-			"hdmi request_irq failed (%d).\n",
-			ret);
-		goto failed1;
-	}
-#else
-	hdmi_dev->workqueue =
-		create_singlethread_workqueue("rockchip hdmiv2 irq");
-	INIT_DELAYED_WORK(&hdmi_dev->delay_work,
-			  rockchip_hdmiv2_irq_work_func);
-	rockchip_hdmiv2_irq_work_func(NULL);
-
-#endif
-	rk_display_device_enable(hdmi_dev->hdmi->ddev);
-	dev_info(&pdev->dev, "rockchip hdmiv2 probe success.\n");
-	return 0;
-
-failed1:
-	rockchip_hdmi_unregister(hdmi_dev->hdmi);
-failed:
-	kfree(hdmi_dev->phy_table);
-	kfree(hdmi_dev);
-	hdmi_dev = NULL;
-	dev_err(&pdev->dev, "rockchip hdmiv2 probe error.\n");
-	return ret;
-}
-
-static int rockchip_hdmiv2_suspend(struct platform_device *pdev,
-				   pm_message_t state)
-{
-	if (hdmi_dev &&
-	    hdmi_dev->grf_base &&
-	    hdmi_dev->soctype == HDMI_SOC_RK322X) {
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_POWER_DOWN);
-	}
-	return 0;
-}
-
-static int rockchip_hdmiv2_resume(struct platform_device *pdev)
-{
-	if (hdmi_dev &&
-	    hdmi_dev->grf_base &&
-	    hdmi_dev->soctype == HDMI_SOC_RK322X) {
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_POWER_UP);
-	}
-	return 0;
-}
-
-static int rockchip_hdmiv2_remove(struct platform_device *pdev)
-{
-	dev_info(&pdev->dev, "rk3288 hdmi driver removed.\n");
-	return 0;
-}
-
-static void rockchip_hdmiv2_shutdown(struct platform_device *pdev)
-{
-	struct hdmi *hdmi;
-
-	if (hdmi_dev) {
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi_dev->early_suspend);
-		#endif
-		hdmi = hdmi_dev->hdmi;
-		if (hdmi->hotplug == HDMI_HPD_ACTIVATED &&
-		    hdmi->ops->setmute)
-			hdmi->ops->setmute(hdmi, HDMI_VIDEO_MUTE);
-		pm_runtime_disable(hdmi_dev->dev);
-	}
-}
-
-static struct platform_driver rockchip_hdmiv2_driver = {
-	.probe		= rockchip_hdmiv2_probe,
-	.remove		= rockchip_hdmiv2_remove,
-	.driver		= {
-		.name	= "rockchip-hdmiv2",
-		.owner	= THIS_MODULE,
-		#if defined(CONFIG_OF)
-		.of_match_table = of_match_ptr(rk_hdmi_dt_ids),
-		#endif
-	},
-	.suspend	= rockchip_hdmiv2_suspend,
-	.resume		= rockchip_hdmiv2_resume,
-	.shutdown	= rockchip_hdmiv2_shutdown,
-};
-
-static int __init rockchip_hdmiv2_init(void)
-{
-	return platform_driver_register(&rockchip_hdmiv2_driver);
-}
-
-static void __exit rockchip_hdmiv2_exit(void)
-{
-	platform_driver_unregister(&rockchip_hdmiv2_driver);
-}
-
-module_init(rockchip_hdmiv2_init);
-module_exit(rockchip_hdmiv2_exit);
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h
deleted file mode 100644
index a8d4257c788f..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __RK32_HDMI_H__
-#define __RK32_HDMI_H__
-#include <linux/gpio.h>
-#include <linux/regmap.h>
-#include <linux/reset.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include "../rockchip-hdmi.h"
-
-#define HDMI_PD_ON		BIT(0)
-#define HDMI_PCLK_ON		BIT(1)
-#define HDMI_HDCPCLK_ON		BIT(2)
-#define HDMI_CECCLK_ON		BIT(3)
-#define HDMI_EXT_PHY_CLK_ON	BIT(4)
-#define HDMI_SFRCLK_ON		BIT(5)
-
-struct hdmi_dev_phy_para {
-	u32 maxfreq;
-	int pre_emphasis;
-	int slopeboost;
-	int clk_level;
-	int data0_level;
-	int data1_level;
-	int data2_level;
-};
-
-struct hdmi_dev {
-	void __iomem		*regbase;
-	void __iomem		*phybase;
-	struct regmap		*grf_base;
-	struct reset_control	*reset;
-	struct clk		*pd;
-	struct clk		*pclk;
-	struct clk		*hdcp_clk;
-	struct clk		*cec_clk;
-	struct clk		*pclk_phy;
-	struct clk		*sfr_clk;
-	struct hdmi		*hdmi;
-	struct device		*dev;
-	struct dentry		*debugfs_dir;
-	int			irq;
-
-	struct work_struct	irq_work;
-	struct delayed_work	delay_work;
-	struct workqueue_struct *workqueue;
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend	early_suspend;
-#endif
-	int			soctype;
-	int			audiosrc;
-	int			enable;
-	int			hdcp2_enable;
-	unsigned char		clk_disable;
-	unsigned char		clk_on;
-
-	unsigned long		pixelclk;
-	unsigned int		tmdsclk;
-	unsigned int		pixelrepeat;
-	unsigned char		colordepth;
-
-	bool			tmdsclk_ratio_change;
-	struct mutex		ddc_lock;	/*mutex for ddc operation */
-
-	void			(*hdcp2_en)(int);
-	void			(*hdcp2_reset)(void);
-	void			(*hdcp2_start)(void);
-
-	struct hdmi_dev_phy_para *phy_table;
-	int			phy_table_size;
-	const char		*vendor_name;
-	const char		*product_name;
-	unsigned char		deviceinfo;
-};
-
-void ext_pll_set_27m_out(void);
-
-#endif /*__RK32_HDMI_H__*/
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
deleted file mode 100644
index d50f7c2cd314..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/delay.h>
-#include "../rockchip-hdmi-cec.h"
-#include "rockchip_hdmiv2.h"
-#include "rockchip_hdmiv2_hw.h"
-
-/* static wait_queue_head_t	wait;*/
-static int init = 1;
-void rockchip_hdmiv2_cec_isr(struct hdmi_dev *hdmi_dev, char cec_int)
-{
-	HDMIDBG(1, "%s cec 0x%x\n", __func__, cec_int);
-	if (cec_int & m_EOM)
-		rockchip_hdmi_cec_submit_work(EVENT_RX_FRAME, 0, NULL);
-	if (cec_int & m_DONE)
-		HDMIDBG(1, "send frame success\n");
-}
-
-static int rockchip_hdmiv2_cec_readframe(struct hdmi *hdmi,
-					 struct cec_framedata *frame)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	int i, count;
-	u8 *data = (u8 *)frame;
-
-	if (((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) || !frame)
-		return -1;
-	count = hdmi_readl(hdmi_dev, CEC_RX_CNT);
-	HDMIDBG(1, "%s count %d\n", __func__, count);
-	for (i = 0; i < count; i++) {
-		data[i] = hdmi_readl(hdmi_dev, CEC_RX_DATA0 + i);
-		HDMIDBG(1, "%02x\n", data[i]);
-	}
-	frame->argcount = count - 2;
-	hdmi_writel(hdmi_dev, CEC_LOCK, 0x0);
-	return 0;
-}
-
-void rockchip_hdmiv2_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	short val;
-
-	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0)
-		return;
-	if (ceclgaddr < 0 || ceclgaddr > 16)
-		return;
-	val = 1 << ceclgaddr;
-	hdmi_writel(hdmi_dev, CEC_ADDR_L, val & 0xff);
-	hdmi_writel(hdmi_dev, CEC_ADDR_H, val >> 8);
-}
-
-static int rockchip_hdmiv2_cec_sendframe(struct hdmi *hdmi,
-					 struct cec_framedata *frame)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	int i, interrupt;
-
-	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0)
-		return CEC_SEND_NACK;
-	HDMIDBG(1, "TX srcdestaddr %02x opcode %02x ",
-		frame->srcdestaddr, frame->opcode);
-	if (frame->argcount) {
-		HDMIDBG(1, "args:");
-		for (i = 0; i < frame->argcount; i++)
-			HDMIDBG(1, "%02x ", frame->args[i]);
-	}
-	HDMIDBG(1, "\n");
-	if ((frame->srcdestaddr & 0x0f) == ((frame->srcdestaddr >> 4) & 0x0f)) {
-		/*it is a ping command*/
-		hdmi_writel(hdmi_dev, CEC_TX_DATA0, frame->srcdestaddr);
-		hdmi_writel(hdmi_dev, CEC_TX_CNT, 1);
-	} else {
-		hdmi_writel(hdmi_dev, CEC_TX_DATA0, frame->srcdestaddr);
-		hdmi_writel(hdmi_dev, CEC_TX_DATA0 + 1, frame->opcode);
-		for (i = 0; i < frame->argcount; i++)
-			hdmi_writel(hdmi_dev,
-				    CEC_TX_DATA0 + 2 + i, frame->args[i]);
-		hdmi_writel(hdmi_dev, CEC_TX_CNT, frame->argcount + 2);
-	}
-	/*Start TX*/
-	hdmi_msk_reg(hdmi_dev, CEC_CTRL, m_CEC_SEND, v_CEC_SEND(1));
-	i = 400;
-	/* time = 2.4(ms)*(1 + 16)(head + param)*11(bit)*/
-	/*11bit =  start bit(4.5ms) + data bit(2.4ms) */
-	while (i--) {
-		usleep_range(900, 1000);
-		interrupt = hdmi_readl(hdmi_dev, IH_CEC_STAT0);
-		if (interrupt & (m_ERR_INITIATOR | m_ARB_LOST |
-					m_NACK | m_DONE)) {
-			hdmi_writel(hdmi_dev, IH_CEC_STAT0,
-				    interrupt & (m_ERR_INITIATOR |
-				    m_ARB_LOST | m_NACK | m_DONE));
-			break;
-		}
-	}
-	HDMIDBG(1, "%s interrupt 0x%02x\n", __func__, interrupt);
-	if (interrupt & m_DONE)
-		return CEC_SEND_SUCCESS;
-	else if (interrupt & m_NACK)
-		return CEC_SEND_NACK;
-	else
-		return CEC_SEND_BUSY;
-}
-
-void rockchip_hdmiv2_cec_init(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (init) {
-		rockchip_hdmi_cec_init(hdmi,
-				       rockchip_hdmiv2_cec_sendframe,
-				       rockchip_hdmiv2_cec_readframe,
-				       rockchip_hdmiv2_cec_setcecla);
-		init = 0;
-		/* init_waitqueue_head(&wait); */
-	}
-
-	hdmi_writel(hdmi_dev, IH_MUTE_CEC_STAT0, m_ERR_INITIATOR |
-			m_ARB_LOST | m_NACK | m_DONE);
-	HDMIDBG(1, "%s", __func__);
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
deleted file mode 100644
index fb02ec9a8fed..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
+++ /dev/null
@@ -1,678 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/miscdevice.h>
-#include <linux/workqueue.h>
-#include <linux/firmware.h>
-#include <linux/delay.h>
-#include "rockchip_hdmiv2.h"
-#include "rockchip_hdmiv2_hw.h"
-
-#define	HDCP_KEY_SIZE		308
-#define HDCP_PRIVATE_KEY_SIZE	280
-#define HDCP_KEY_SHA_SIZE	20
-#define HDCP_KEY_SEED_SIZE	2
-
-#define KSV_LEN			5
-#define HEADER			10
-#define SHAMAX			20
-
-#define MAX_DOWNSTREAM_DEVICE_NUM	5
-
-struct hdcp_keys {
-	u8 KSV[8];
-	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
-	u8 sha1[HDCP_KEY_SHA_SIZE];
-};
-
-struct hdcp {
-	struct hdmi		*hdmi;
-	int			enable;
-	int			retry_times;
-	struct hdcp_keys	*keys;
-	char			*seeds;
-	int			invalidkey;
-	char			*invalidkeys;
-};
-
-struct sha_t {
-	u8 mlength[8];
-	u8 mblock[64];
-	int mindex;
-	int mcomputed;
-	int mcorrupted;
-	unsigned int mdigest[5];
-};
-
-static struct miscdevice mdev;
-static struct hdcp *hdcp;
-
-static void sha_reset(struct sha_t *sha)
-{
-	u32 i = 0;
-
-	sha->mindex = 0;
-	sha->mcomputed = false;
-	sha->mcorrupted = false;
-	for (i = 0; i < sizeof(sha->mlength); i++)
-		sha->mlength[i] = 0;
-
-	sha->mdigest[0] = 0x67452301;
-	sha->mdigest[1] = 0xEFCDAB89;
-	sha->mdigest[2] = 0x98BADCFE;
-	sha->mdigest[3] = 0x10325476;
-	sha->mdigest[4] = 0xC3D2E1F0;
-}
-
-#define shacircularshift(bits, word) ((((word) << (bits)) & 0xFFFFFFFF) | \
-				     ((word) >> (32 - (bits))))
-void sha_processblock(struct sha_t *sha)
-{
-	const unsigned int K[] = {
-	/* constants defined in SHA-1 */
-	0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6 };
-	unsigned int W[80]; /* word sequence */
-	unsigned int A, B, C, D, E; /* word buffers */
-	unsigned int temp = 0;
-	int t = 0;
-
-	/* Initialize the first 16 words in the array W */
-	for (t = 0; t < 80; t++) {
-		if (t < 16) {
-			W[t] = ((unsigned int)sha->mblock[t * 4 + 0]) << 24;
-			W[t] |= ((unsigned int)sha->mblock[t * 4 + 1]) << 16;
-			W[t] |= ((unsigned int)sha->mblock[t * 4 + 2]) << 8;
-			W[t] |= ((unsigned int)sha->mblock[t * 4 + 3]) << 0;
-		} else {
-			A = W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16];
-			W[t] = shacircularshift(1, A);
-		}
-	}
-
-	A = sha->mdigest[0];
-	B = sha->mdigest[1];
-	C = sha->mdigest[2];
-	D = sha->mdigest[3];
-	E = sha->mdigest[4];
-
-	for (t = 0; t < 80; t++) {
-		temp = shacircularshift(5, A);
-		if (t < 20)
-			temp += ((B & C) | ((~B) & D)) + E + W[t] + K[0];
-		else if (t < 40)
-			temp += (B ^ C ^ D) + E + W[t] + K[1];
-		else if (t < 60)
-			temp += ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
-		else
-			temp += (B ^ C ^ D) + E + W[t] + K[3];
-
-		E = D;
-		D = C;
-		C = shacircularshift(30, B);
-		B = A;
-		A = (temp & 0xFFFFFFFF);
-	}
-
-	sha->mdigest[0] = (sha->mdigest[0] + A) & 0xFFFFFFFF;
-	sha->mdigest[1] = (sha->mdigest[1] + B) & 0xFFFFFFFF;
-	sha->mdigest[2] = (sha->mdigest[2] + C) & 0xFFFFFFFF;
-	sha->mdigest[3] = (sha->mdigest[3] + D) & 0xFFFFFFFF;
-	sha->mdigest[4] = (sha->mdigest[4] + E) & 0xFFFFFFFF;
-
-	sha->mindex = 0;
-}
-
-static void sha_padmessage(struct sha_t *sha)
-{
-	/*
-	 *  Check to see if the current message block is too small to hold
-	 *  the initial padding bits and length.  If so, we will pad the
-	 *  block, process it, and then continue padding into a second
-	 *  block.
-	 */
-	if (sha->mindex > 55) {
-		sha->mblock[sha->mindex++] = 0x80;
-		while (sha->mindex < 64)
-			sha->mblock[sha->mindex++] = 0;
-
-		sha_processblock(sha);
-		while (sha->mindex < 56)
-			sha->mblock[sha->mindex++] = 0;
-	} else {
-		sha->mblock[sha->mindex++] = 0x80;
-		while (sha->mindex < 56)
-			sha->mblock[sha->mindex++] = 0;
-	}
-
-	/* Store the message length as the last 8 octets */
-	sha->mblock[56] = sha->mlength[7];
-	sha->mblock[57] = sha->mlength[6];
-	sha->mblock[58] = sha->mlength[5];
-	sha->mblock[59] = sha->mlength[4];
-	sha->mblock[60] = sha->mlength[3];
-	sha->mblock[61] = sha->mlength[2];
-	sha->mblock[62] = sha->mlength[1];
-	sha->mblock[63] = sha->mlength[0];
-
-	sha_processblock(sha);
-}
-
-static int sha_result(struct sha_t *sha)
-{
-	if (sha->mcorrupted)
-		return false;
-
-	if (sha->mcomputed == 0) {
-		sha_padmessage(sha);
-		sha->mcomputed = true;
-	}
-	return true;
-}
-
-static void sha_input(struct sha_t *sha, const u8 *data, u32 size)
-{
-	int i = 0;
-	unsigned j = 0;
-	int rc = true;
-
-	if (data == 0 || size == 0) {
-		pr_err("invalid input data");
-		return;
-	}
-	if (sha->mcomputed || sha->mcorrupted) {
-		sha->mcorrupted = true;
-		return;
-	}
-	while (size-- && !sha->mcorrupted) {
-		sha->mblock[sha->mindex++] = *data;
-
-		for (i = 0; i < 8; i++) {
-			rc = true;
-			for (j = 0; j < sizeof(sha->mlength); j++) {
-				sha->mlength[j]++;
-				if (sha->mlength[j] != 0) {
-					rc = false;
-					break;
-				}
-			}
-			sha->mcorrupted = (sha->mcorrupted  ||
-					   rc) ? true : false;
-		}
-		/* if corrupted then message is too long */
-		if (sha->mindex == 64)
-			sha_processblock(sha);
-		data++;
-	}
-}
-
-static int hdcpverify_ksv(const u8 *data, u32 size)
-{
-	u32 i = 0;
-	struct sha_t sha;
-
-	if ((!data) || (size < (HEADER + SHAMAX))) {
-		pr_err("invalid input data");
-		return false;
-	}
-
-	sha_reset(&sha);
-	sha_input(&sha, data, size - SHAMAX);
-	if (sha_result(&sha) == false) {
-		pr_err("cannot process SHA digest");
-		return false;
-	}
-
-	for (i = 0; i < SHAMAX; i++) {
-		if (data[size - SHAMAX + i] != (u8)(sha.mdigest[i / 4]
-				>> ((i % 4) * 8))) {
-			pr_err("SHA digest does not match");
-			return false;
-		}
-	}
-	return true;
-}
-
-static int rockchip_hdmiv2_hdcp_ksvsha1(struct hdmi_dev *hdmi_dev)
-{
-	int rc = 0, value, list, i;
-	char bstaus0, bstaus1;
-	char *ksvlistbuf;
-
-	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL, m_KSV_MEM_REQ, v_KSV_MEM_REQ(1));
-	list = 20;
-	do {
-		value = hdmi_readl(hdmi_dev, A_KSVMEMCTRL);
-		usleep_range(500, 1000);
-	} while ((value & m_KSV_MEM_ACCESS) == 0 && --list);
-
-	if ((value & m_KSV_MEM_ACCESS) == 0) {
-		pr_err("KSV memory can not access\n");
-		rc = -1;
-		goto out;
-	}
-
-	hdmi_readl(hdmi_dev, HDCP_BSTATUS_0);
-	bstaus0 = hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + 1);
-	bstaus1 = hdmi_readl(hdmi_dev, HDCP_BSTATUS_1 + 1);
-
-	if (bstaus0 & m_MAX_DEVS_EXCEEDED) {
-		pr_err("m_MAX_DEVS_EXCEEDED\n");
-		rc = -1;
-		goto out;
-	}
-	list = bstaus0 & m_DEVICE_COUNT;
-	if (list > MAX_DOWNSTREAM_DEVICE_NUM) {
-		pr_err("MAX_DOWNSTREAM_DEVICE_NUM\n");
-		rc = -1;
-		goto out;
-	}
-	if (bstaus1 & (1 << 3)) {
-		pr_err("MAX_CASCADE_EXCEEDED\n");
-		rc = -1;
-		goto out;
-	}
-	value = (list * KSV_LEN) + HEADER + SHAMAX;
-	ksvlistbuf = kmalloc(value, GFP_KERNEL);
-	if (!ksvlistbuf) {
-		pr_err("HDCP: kmalloc ksvlistbuf fail!\n");
-		rc = -ENOMEM;
-		goto out;
-	}
-	ksvlistbuf[(list * KSV_LEN)] = bstaus0;
-	ksvlistbuf[(list * KSV_LEN) + 1] = bstaus1;
-	for (i = 2; i < value; i++) {
-		if (i < HEADER)	/* BSTATUS & M0 */
-			ksvlistbuf[(list * KSV_LEN) + i] =
-				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
-		else if (i < (HEADER + (list * KSV_LEN))) /* KSV list */
-			ksvlistbuf[i - HEADER] =
-				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
-		else /* SHA */
-			ksvlistbuf[i] =
-				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
-	}
-	if (hdcpverify_ksv(ksvlistbuf, value) == true) {
-		rc = 0;
-		pr_info("ksv check valid\n");
-	} else {
-		pr_info("ksv check invalid\n");
-		rc = -1;
-	}
-	kfree(ksvlistbuf);
-out:
-	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL, m_KSV_MEM_REQ, v_KSV_MEM_REQ(0));
-	return rc;
-}
-
-static void rockchip_hdmiv2_hdcp_2nd_auth(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (rockchip_hdmiv2_hdcp_ksvsha1(hdmi_dev))
-		hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
-			     m_SHA1_FAIL | m_KSV_UPDATE,
-			     v_SHA1_FAIL(1) | v_KSV_UPDATE(1));
-	else
-		hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
-			     m_SHA1_FAIL | m_KSV_UPDATE,
-			     v_SHA1_FAIL(0) | v_KSV_UPDATE(1));
-}
-
-static void hdcp_load_key(struct hdmi *hdmi, struct hdcp_keys *key)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	int i, value;
-
-	/* Disable decryption logic */
-	hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 0);
-	/* Poll untile DPK write is allowed */
-	do {
-		value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
-	} while ((value & m_DPK_WR_OK_STS) == 0);
-
-	/* write unencryped AKSV */
-	hdmi_writel(hdmi_dev, HDCPREG_DPK6, 0);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK5, 0);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK4, key->KSV[4]);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK3, key->KSV[3]);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK2, key->KSV[2]);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK1, key->KSV[1]);
-	hdmi_writel(hdmi_dev, HDCPREG_DPK0, key->KSV[0]);
-	/* Poll untile DPK write is allowed */
-	do {
-		value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
-	} while ((value & m_DPK_WR_OK_STS) == 0);
-
-	if (hdcp->seeds) {
-		hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 1);
-		hdmi_writel(hdmi_dev, HDCPREG_SEED1, hdcp->seeds[0]);
-		hdmi_writel(hdmi_dev, HDCPREG_SEED0, hdcp->seeds[1]);
-	} else {
-		hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 0);
-	}
-
-	/* write private key */
-	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i += 7) {
-		hdmi_writel(hdmi_dev, HDCPREG_DPK6, key->devicekey[i + 6]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK5, key->devicekey[i + 5]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK4, key->devicekey[i + 4]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK3, key->devicekey[i + 3]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK2, key->devicekey[i + 2]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK1, key->devicekey[i + 1]);
-		hdmi_writel(hdmi_dev, HDCPREG_DPK0, key->devicekey[i]);
-
-		do {
-			value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
-		} while ((value & m_DPK_WR_OK_STS) == 0);
-	}
-
-	pr_info("%s success\n", __func__);
-}
-
-static void hdcp_load_keys_cb(const struct firmware *fw,
-			      void *context)
-{
-	struct hdmi *hdmi = (struct hdmi *)context;
-
-	if (!fw) {
-		pr_info("HDCP: firmware is not loaded\n");
-		return;
-	}
-	if (fw->size < HDCP_KEY_SIZE) {
-		pr_err("HDCP: firmware wrong size %d\n", (int)fw->size);
-		return;
-	}
-	hdcp->keys = kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
-	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
-
-	if (fw->size > HDCP_KEY_SIZE) {
-		if ((fw->size - HDCP_KEY_SIZE) < HDCP_KEY_SEED_SIZE) {
-			pr_err("HDCP: invalid seed key size\n");
-			return;
-		}
-		hdcp->seeds = kmalloc(HDCP_KEY_SEED_SIZE, GFP_KERNEL);
-		if (!hdcp->seeds)
-			return;
-
-		memcpy(hdcp->seeds, fw->data + HDCP_KEY_SIZE,
-		       HDCP_KEY_SEED_SIZE);
-	}
-	hdcp_load_key(hdmi, hdcp->keys);
-}
-
-void rockchip_hdmiv2_hdcp2_enable(int enable)
-{
-	struct hdmi_dev *hdmi_dev;
-
-	if (!hdcp) {
-		pr_err("rockchip hdmiv2 hdcp is not exist\n");
-		return;
-	}
-	hdmi_dev = hdcp->hdmi->property->priv;
-	if ((hdmi_readl(hdmi_dev, CONFIG1_ID) & m_HDCP22) == 0) {
-		pr_err("Don't support hdcp22\n");
-		return;
-	}
-	if (hdmi_dev->hdcp2_enable != enable) {
-		hdmi_dev->hdcp2_enable = enable;
-		if (hdmi_dev->hdcp2_enable == 0) {
-			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
-				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
-				     v_HDCP2_OVR_EN(1) | v_HDCP2_FORCE(0));
-			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0xff);
-			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0xff);
-		} else {
-			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
-				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
-				     v_HDCP2_OVR_EN(0) | v_HDCP2_FORCE(0));
-			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0x00);
-			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0x00);
-		}
-	}
-}
-EXPORT_SYMBOL(rockchip_hdmiv2_hdcp2_enable);
-
-void rockchip_hdmiv2_hdcp2_init(void (*hdcp2_enble)(int),
-				void (*hdcp2_reset)(void),
-				void (*hdcp2_start)(void))
-{
-	struct hdmi_dev *hdmi_dev;
-
-	if (!hdcp) {
-		pr_err("rockchip hdmiv2 hdcp is not exist\n");
-		return;
-	}
-	hdmi_dev = hdcp->hdmi->property->priv;
-	hdmi_dev->hdcp2_en = hdcp2_enble;
-	hdmi_dev->hdcp2_reset = hdcp2_reset;
-	hdmi_dev->hdcp2_start = hdcp2_start;
-}
-EXPORT_SYMBOL(rockchip_hdmiv2_hdcp2_init);
-
-static void rockchip_hdmiv2_hdcp_start(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (!hdcp->enable)
-		return;
-	if (hdmi_readl(hdmi_dev, CONFIG1_ID) & m_HDCP22) {
-		if (hdmi_dev->hdcp2_enable == 0) {
-			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
-				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
-				     v_HDCP2_OVR_EN(1) | v_HDCP2_FORCE(0));
-			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0xff);
-			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0xff);
-		} else {
-			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
-				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
-				     v_HDCP2_OVR_EN(0) | v_HDCP2_FORCE(0));
-			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0x00);
-			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0x00);
-		}
-	}
-
-	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
-		     m_FC_HDCP_KEEPOUT, v_FC_HDCP_KEEPOUT(1));
-	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0,
-		     m_HDMI_DVI, v_HDMI_DVI(hdmi->edid.sink_hdmi));
-	hdmi_writel(hdmi_dev, A_OESSWCFG, 0x40);
-	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0,
-		     m_ENCRYPT_BYPASS | m_FEATURE11_EN | m_SYNC_RI_CHECK,
-		     v_ENCRYPT_BYPASS(0) | v_FEATURE11_EN(0) |
-		     v_SYNC_RI_CHECK(1));
-	hdmi_msk_reg(hdmi_dev, A_HDCPCFG1,
-		     m_ENCRYPT_DISBALE | m_PH2UPSHFTENC,
-		     v_ENCRYPT_DISBALE(0) | v_PH2UPSHFTENC(1));
-	/* Reset HDCP Engine */
-	if (hdmi_readl(hdmi_dev, MC_CLKDIS) & m_HDCPCLK_DISABLE)
-		hdmi_msk_reg(hdmi_dev, A_HDCPCFG1,
-			     m_HDCP_SW_RST, v_HDCP_SW_RST(0));
-
-	hdmi_writel(hdmi_dev, A_APIINTMSK, 0x00);
-	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_RX_DETECT, v_RX_DETECT(1));
-
-	hdmi_msk_reg(hdmi_dev, MC_CLKDIS,
-		     m_HDCPCLK_DISABLE, v_HDCPCLK_DISABLE(0));
-	if (hdmi_dev->hdcp2_start)
-		hdmi_dev->hdcp2_start();
-	pr_info("%s success\n", __func__);
-}
-
-static void rockchip_hdmiv2_hdcp_stop(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	if (!hdcp->enable)
-		return;
-
-	hdmi_msk_reg(hdmi_dev, MC_CLKDIS,
-		     m_HDCPCLK_DISABLE, v_HDCPCLK_DISABLE(1));
-	hdmi_writel(hdmi_dev, A_APIINTMSK, 0xff);
-	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_RX_DETECT, v_RX_DETECT(0));
-	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
-		     m_SHA1_FAIL | m_KSV_UPDATE,
-		     v_SHA1_FAIL(0) | v_KSV_UPDATE(0));
-	rockchip_hdmiv2_hdcp2_enable(0);
-}
-
-void rockchip_hdmiv2_hdcp_isr(struct hdmi_dev *hdmi_dev, int hdcp_int)
-{
-	pr_info("hdcp_int is 0x%02x\n", hdcp_int);
-
-	if (hdcp_int & m_KSVSHA1_CALC_INT) {
-		pr_info("hdcp sink is a repeater\n");
-		hdmi_submit_work(hdcp->hdmi, HDMI_HDCP_AUTH_2ND, 0, 0);
-	}
-	if (hdcp_int & 0x40) {
-		pr_info("hdcp check failed\n");
-		rockchip_hdmiv2_hdcp_stop(hdmi_dev->hdmi);
-		hdmi_submit_work(hdcp->hdmi, HDMI_ENABLE_HDCP, 0, 0);
-	}
-}
-
-static ssize_t hdcp_enable_read(struct device *device,
-				struct device_attribute *attr, char *buf)
-{
-	int enable = 0;
-
-	if (hdcp)
-		enable = hdcp->enable;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
-}
-
-static ssize_t hdcp_enable_write(struct device *device,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	int enable;
-
-	if (!hdcp)
-		return -EINVAL;
-	if (!hdcp->keys) {
-		pr_err("HDCP: key is not loaded\n");
-		return -EINVAL;
-	}
-	if (kstrtoint(buf, 0, &enable))
-		return -EINVAL;
-
-	if (hdcp->enable != enable) {
-		if (!hdcp->enable)
-			hdmi_submit_work(hdcp->hdmi, HDMI_ENABLE_HDCP, 0, 0);
-		else
-			rockchip_hdmiv2_hdcp_stop(hdcp->hdmi);
-		hdcp->enable =	enable;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(enable, 0644, hdcp_enable_read, hdcp_enable_write);
-
-static ssize_t hdcp_trytimes_read(struct device *device,
-				  struct device_attribute *attr, char *buf)
-{
-	int trytimes = 0;
-
-	if (hdcp)
-		trytimes = hdcp->retry_times;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
-}
-
-static ssize_t hdcp_trytimes_wrtie(struct device *device,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	int trytimes;
-
-	if (!hdcp)
-		return -EINVAL;
-
-	if (kstrtoint(buf, 0, &trytimes))
-		return -EINVAL;
-
-	if (hdcp->retry_times != trytimes)
-		hdcp->retry_times = trytimes;
-
-	return count;
-}
-
-static DEVICE_ATTR(trytimes, 0644, hdcp_trytimes_read, hdcp_trytimes_wrtie);
-
-static int hdcp_init(struct hdmi *hdmi)
-{
-	int ret;
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	mdev.minor = MISC_DYNAMIC_MINOR;
-	mdev.name = "hdcp";
-	mdev.mode = 0666;
-	hdcp = kmalloc(sizeof(*hdcp), GFP_KERNEL);
-	if (!hdcp) {
-		pr_err("HDCP: kmalloc fail!\n");
-		ret = -ENOMEM;
-		goto error0;
-	}
-	memset(hdcp, 0, sizeof(struct hdcp));
-	hdcp->hdmi = hdmi;
-	if (misc_register(&mdev)) {
-		pr_err("HDCP: Could not add character driver\n");
-		ret = HDMI_ERROR_FALSE;
-		goto error1;
-	}
-	ret = device_create_file(mdev.this_device, &dev_attr_enable);
-	if (ret) {
-		pr_err("HDCP: Could not add sys file enable\n");
-		ret = -EINVAL;
-		goto error2;
-	}
-	ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
-	if (ret) {
-		pr_err("HDCP: Could not add sys file enable\n");
-		ret = -EINVAL;
-		goto error3;
-	}
-
-	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
-				      "hdcp", mdev.this_device, GFP_KERNEL,
-				      hdmi, hdcp_load_keys_cb);
-
-	if (ret < 0) {
-		pr_err("HDCP: request_firmware_nowait failed: %d\n", ret);
-		goto error4;
-	}
-	if ((hdmi_readl(hdmi_dev, MC_CLKDIS) & m_HDCPCLK_DISABLE) == 0)
-		hdcp->enable = 1;
-	hdmi->ops->hdcp_cb = rockchip_hdmiv2_hdcp_start;
-	hdmi->ops->hdcp_auth2nd = rockchip_hdmiv2_hdcp_2nd_auth;
-	hdmi->ops->hdcp_power_off_cb = rockchip_hdmiv2_hdcp_stop;
-	return 0;
-
-error4:
-	device_remove_file(mdev.this_device, &dev_attr_trytimes);
-error3:
-	device_remove_file(mdev.this_device, &dev_attr_enable);
-error2:
-	misc_deregister(&mdev);
-error1:
-	kfree(hdcp);
-error0:
-	return ret;
-}
-
-void rockchip_hdmiv2_hdcp_init(struct hdmi *hdmi)
-{
-	pr_info("%s", __func__);
-
-	if (!hdcp) {
-		hdcp_init(hdmi);
-	} else {
-		if (hdcp->keys)
-			hdcp_load_key(hdmi, hdcp->keys);
-		else
-			pr_info("hdcpkeys is no load\n");
-	}
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
deleted file mode 100644
index 62b475686a6a..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
+++ /dev/null
@@ -1,2310 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/rockchip/grf.h>
-#include "rockchip_hdmiv2.h"
-#include "rockchip_hdmiv2_hw.h"
-
-#define HDMI_SEL_LCDC(x, bit)	((((x) & 1) << bit) | (1 << (16 + bit)))
-#define RK3399_GRF_SOC_CON20 0x6250
-
-static const struct phy_mpll_config_tab PHY_MPLL_TABLE[] = {
-/*	tmdsclk = (pixclk / ref_cntrl ) * (fbdiv2 * fbdiv1) / nctrl / tmdsmhl
- *	opmode: 0:HDMI1.4	1:HDMI2.0
- *
- *	|pixclock|	tmdsclock|pixrepet|colordepth|prepdiv|tmdsmhl|opmode|
- *		fbdiv2|fbdiv1|ref_cntrl|nctrl|propctrl|intctrl|gmpctrl|
- */
-	{27000000,	27000000,	0,	8,	0,	0,	0,
-		2,	3,	0,	3,	3,	0,	0},
-	{27000000,	27000000,	1,	8,	0,	0,	0,
-		2,	3,	0,	3,	3,	0,	0},
-	{27000000,	33750000,	0,	10,	1,	0,	0,
-		5,	1,	0,	3,	3,	0,	0},
-	{27000000,	33750000,	1,	10,	1,	0,	0,
-		5,	1,	0,	3,	3,	0,	0},
-	{27000000,	40500000,	0,	12,	2,	0,	0,
-		3,	3,	0,	3,	3,	0,	0},
-	{27000000,	54000000,	0,	16,	3,	0,	0,
-		2,	3,	0,	2,	5,	0,	1},
-	{59400000,	59400000,	0,	8,	0,	0,	0,
-		1,	3,	0,	2,	5,	0,	1},
-	{59400000,	74250000,	0,	10,	1,	0,	0,
-		5,	0,	0,	2,	5,	0,	1},
-	{59400000,	89100000,	0,	12,	2,	0,	0,
-		2,	2,	0,	2,	5,	0,	1},
-	{59400000,	118800000,	0,	16,	3,	0,	0,
-		1,	3,	0,	1,	7,	0,	2},
-	{65000000,	65000000,	0,	8,	0,	0,	0,
-		1,	3,	0,	2,	5,	0,	1},
-	{74250000,      74250000,	0,      8,      0,      0,      0,
-		4,      3,      3,      2,      7,      0,      3},
-	{74250000,	92812500,	0,	10,	1,	0,	0,
-		5,	0,	1,	1,	7,	0,	2},
-	{74250000,	111375000,	0,	12,	2,	0,	0,
-		1,	2,	0,	1,	7,	0,	2},
-	{74250000,	148500000,	0,	16,	3,	0,	0,
-		1,	3,	0,	1,	7,	0,	2},
-	{83500000,	83500000,	0,	8,	0,	0,	0,
-		1,	3,	0,	2,	5,	0,	1},
-	{85500000,	85500000,	0,	8,	0,	0,	0,
-		1,	3,	0,	2,	5,	0,	1},
-	{106500000,	106500000,	0,	8,	0,	0,	0,
-		1,	1,	0,	1,	7,	0,	2},
-	{108000000,	108000000,	0,	8,	0,	0,	0,
-		1,	1,	0,	1,	7,	0,	2},
-	{146250000,	146250000,	0,	8,	0,	0,	0,
-		1,	1,	0,	1,	7,	0,	2},
-	{148500000,	74250000,	0,	8,	0,	0,	0,
-		1,	1,	1,	1,	0,	0,	3},
-	{148500000,	148500000,	0,	8,	0,	0,	0,
-		1,	1,	0,	1,	0,	0,	3},
-	{148500000,	185625000,	0,	10,	1,	0,	0,
-		5,	0,	3,	0,	7,	0,	3},
-	{148500000,	222750000,	0,	12,	2,	0,	0,
-		1,	2,	1,	0,	7,	0,	3},
-	{148500000,	297000000,	0,	16,	3,	0,	0,
-		1,	1,	0,	0,	7,	0,	3},
-	{148500000,	297000000,	0,	8,	0,	0,	0,
-		1,	1,	0,	0,	0,	0,	3},
-	{148500000,	594000000,	0,	8,	0,	3,	1,
-		1,	3,	0,	0,	0,	0,	3},
-	{269390000,	269390000,	0,	8,	0,	0,	0,
-		1,	0,	0,	0,	0,	0,	3},
-	{285000000,	285000000,	0,	8,	0,	0,	0,
-		1,	0,	0,	0,	0,	0,	3},
-	{297000000,	148500000,	0,	8,	0,	0,	0,
-		1,	0,	1,	0,	0,	0,	3},
-	{297000000,	297000000,	0,	8,	0,	0,	0,
-		1,	0,	0,	0,	0,	0,	3},
-	{297000000,	371250000,	0,	10,	1,	3,	1,
-		5,	1,	3,	1,	7,	0,	3},
-	{297000000,	445500000,	0,	12,	2,	3,	1,
-		1,	2,	0,	1,	7,	0,	3},
-	{297000000,	594000000,	0,	16,	3,	3,	1,
-		1,	3,	1,	0,	0,	0,	3},
-	{340000000,	340000000,	0,	8,	0,	0,	0,
-		1,	0,	0,	0,	0,	0,	3},
-	{403000000,	403000000,	0,	8,	0,	3,	1,
-		1,	3,	3,	0,	0,	0,	3},
-	{594000000,	297000000,	0,	8,	0,	0,	0,
-		1,	0,	1,	0,	0,	0,	3},
-	{594000000,	371250000,	0,	10,	1,	3,	1,
-		5,	0,	3,	1,	7,	0,	3},
-	{594000000,	445500000,	0,	12,	2,	3,	1,
-		1,	2,	1,	1,	7,	0,	3},
-	{594000000,	594000000,	0,	16,	3,	3,	1,
-		1,	3,	3,	0,	0,	0,	3},
-	{594000000,	594000000,	0,	8,	0,	3,	1,
-		1,	3,	3,	0,	0,	0,	3},
-};
-
-static const struct ext_pll_config_tab EXT_PLL_TABLE[] = {
-	{27000000,	27000000,	8,	1,	90,	3,	2,
-		2,	10,	3,	3,	4,	0,	1,	40,
-		8},
-	{27000000,	33750000,	10,	1,	90,	1,	3,
-		3,	10,	3,	3,	4,	0,	1,	40,
-		8},
-	{59400000,	59400000,	8,	1,	99,	3,	2,
-		2,	1,	3,	3,	4,	0,	1,	40,
-		8},
-	{59400000,	74250000,	10,	1,	99,	1,	2,
-		2,	1,	3,	3,	4,	0,	1,	40,
-		8},
-	{74250000,	74250000,	8,	1,	99,	1,	2,
-		2,	1,	2,	3,	4,	0,	1,	40,
-		8},
-	{74250000,	92812500,	10,	4,	495,	1,	2,
-		2,	1,	3,	3,	4,	0,	2,	40,
-		4},
-	{148500000,	148500000,	8,	1,	99,	1,	1,
-		1,	1,	2,	2,	2,	0,	2,	40,
-		4},
-	{148500000,	185625000,	10,	4,	495,	0,	2,
-		2,	1,	3,	2,	2,	0,	4,	40,
-		2},
-	{297000000,	297000000,	8,	1,	99,	0,	1,
-		1,	1,	0,	2,	2,	0,	4,	40,
-		2},
-	{297000000,	371250000,	10,	4,	495,	1,	2,
-		0,	1,	3,	1,	1,	0,	8,	40,
-		1},
-	{594000000,	297000000,	8,	1,	99,	0,	1,
-		1,	1,	0,	2,	1,	0,	4,	40,
-		2},
-	{594000000,	371250000,	10,	4,	495,	1,	2,
-		0,	1,	3,	1,	1,	1,	8,	40,
-		1},
-	{594000000,	594000000,	8,	1,	99,	0,	2,
-		0,	1,	0,	1,	1,	0,	8,	40,
-		1},
-};
-
-/* ddc i2c master reset */
-static void rockchip_hdmiv2_i2cm_reset(struct hdmi_dev *hdmi_dev)
-{
-	hdmi_msk_reg(hdmi_dev, I2CM_SOFTRSTZ,
-		     m_I2CM_SOFTRST, v_I2CM_SOFTRST(0));
-	usleep_range(90, 100);
-}
-
-/*set read/write offset,set read/write mode*/
-static void rockchip_hdmiv2_i2cm_write_request(struct hdmi_dev *hdmi_dev,
-					       u8 offset, u8 data)
-{
-	hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset);
-	hdmi_writel(hdmi_dev, I2CM_DATAO, data);
-	hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_WR, v_I2CM_WR(1));
-}
-
-static void rockchip_hdmiv2_i2cm_read_request(struct hdmi_dev *hdmi_dev,
-					      u8 offset)
-{
-	hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset);
-	hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_RD, v_I2CM_RD(1));
-}
-
-static void rockchip_hdmiv2_i2cm_write_data(struct hdmi_dev *hdmi_dev,
-					    u8 data, u8 offset)
-{
-	u8 interrupt = 0;
-	int trytime = 2;
-	int i = 20;
-
-	while (trytime-- > 0) {
-		rockchip_hdmiv2_i2cm_write_request(hdmi_dev, offset, data);
-		while (i--) {
-			usleep_range(900, 1000);
-			interrupt = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
-			if (interrupt)
-				hdmi_writel(hdmi_dev,
-					    IH_I2CM_STAT0, interrupt);
-
-			if (interrupt & (m_SCDC_READREQ |
-					 m_I2CM_DONE | m_I2CM_ERROR))
-				break;
-		}
-
-		if (interrupt & m_I2CM_DONE) {
-			dev_dbg(hdmi_dev->hdmi->dev,
-				"[%s] write offset %02x data %02x success\n",
-				__func__, offset, data);
-			trytime = 0;
-		} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
-			dev_err(hdmi_dev->hdmi->dev,
-				"[%s] write data error\n", __func__);
-			rockchip_hdmiv2_i2cm_reset(hdmi_dev);
-		}
-	}
-}
-
-static int rockchip_hdmiv2_i2cm_read_data(struct hdmi_dev *hdmi_dev, u8 offset)
-{
-	u8 interrupt = 0, val;
-	int trytime = 2;
-	int i = 20;
-
-	while (trytime-- > 0) {
-		rockchip_hdmiv2_i2cm_read_request(hdmi_dev, offset);
-		while (i--) {
-			usleep_range(900, 1000);
-			interrupt = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
-			if (interrupt)
-				hdmi_writel(hdmi_dev, IH_I2CM_STAT0, interrupt);
-
-			if (interrupt & (m_SCDC_READREQ |
-				m_I2CM_DONE | m_I2CM_ERROR))
-				break;
-		}
-
-		if (interrupt & m_I2CM_DONE) {
-			val = hdmi_readl(hdmi_dev, I2CM_DATAI);
-			trytime = 0;
-		} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
-			pr_err("[%s] read data error\n", __func__);
-			rockchip_hdmiv2_i2cm_reset(hdmi_dev);
-		}
-	}
-	return val;
-}
-
-static void rockchip_hdmiv2_i2cm_mask_int(struct hdmi_dev *hdmi_dev, int mask)
-{
-	if (!mask) {
-		hdmi_msk_reg(hdmi_dev, I2CM_INT,
-			     m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(0));
-		hdmi_msk_reg(hdmi_dev, I2CM_CTLINT,
-			     m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
-			     v_I2CM_NACK_MASK(0) | v_I2CM_ARB_MASK(0));
-	} else {
-		hdmi_msk_reg(hdmi_dev, I2CM_INT,
-			     m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(1));
-		hdmi_msk_reg(hdmi_dev, I2CM_CTLINT,
-			     m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
-			     v_I2CM_NACK_MASK(1) | v_I2CM_ARB_MASK(1));
-	}
-}
-
-#define I2C_DIV_FACTOR 1000000
-static u16 i2c_count(u16 sfrclock, u16 sclmintime)
-{
-	unsigned long tmp_scl_period = 0;
-
-	if (((sfrclock * sclmintime) % I2C_DIV_FACTOR) != 0)
-		tmp_scl_period = (unsigned long)((sfrclock * sclmintime) +
-				(I2C_DIV_FACTOR - ((sfrclock * sclmintime) %
-				I2C_DIV_FACTOR))) / I2C_DIV_FACTOR;
-	else
-		tmp_scl_period = (unsigned long)(sfrclock * sclmintime) /
-				I2C_DIV_FACTOR;
-
-	return (u16)(tmp_scl_period);
-}
-
-#define EDID_I2C_MIN_SS_SCL_HIGH_TIME	9625
-#define EDID_I2C_MIN_SS_SCL_LOW_TIME	10000
-
-static void rockchip_hdmiv2_i2cm_clk_init(struct hdmi_dev *hdmi_dev)
-{
-	int value;
-
-	/* Set DDC I2C CLK which divided from DDC_CLK. */
-	value = i2c_count(24000, EDID_I2C_MIN_SS_SCL_HIGH_TIME);
-	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_0_ADDR,
-		    value & 0xff);
-	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_1_ADDR,
-		    (value >> 8) & 0xff);
-	value = i2c_count(24000, EDID_I2C_MIN_SS_SCL_LOW_TIME);
-	hdmi_writel(hdmi_dev, I2CM_SS_SCL_LCNT_0_ADDR,
-		    value & 0xff);
-	hdmi_writel(hdmi_dev, I2CM_SS_SCL_LCNT_1_ADDR,
-		    (value >> 8) & 0xff);
-	hdmi_msk_reg(hdmi_dev, I2CM_DIV, m_I2CM_FAST_STD_MODE,
-		     v_I2CM_FAST_STD_MODE(STANDARD_MODE));
-}
-
-static int rockchip_hdmiv2_scdc_get_sink_version(struct hdmi_dev *hdmi_dev)
-{
-	return rockchip_hdmiv2_i2cm_read_data(hdmi_dev, SCDC_SINK_VER);
-}
-
-static void rockchip_hdmiv2_scdc_set_source_version(struct hdmi_dev *hdmi_dev,
-						    u8 version)
-{
-	rockchip_hdmiv2_i2cm_write_data(hdmi_dev, version, SCDC_SOURCE_VER);
-}
-
-static void rockchip_hdmiv2_scdc_read_request(struct hdmi_dev *hdmi_dev,
-					      int enable)
-{
-	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
-		     m_I2CM_READ_REQ_EN, v_I2CM_READ_REQ_EN(enable));
-	rockchip_hdmiv2_i2cm_write_data(hdmi_dev, enable, SCDC_CONFIG_0);
-}
-
-#ifdef HDMI_20_SCDC
-static void rockchip_hdmiv2_scdc_update_read(struct hdmi_dev *hdmi_dev)
-{
-	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
-		     m_I2CM_READ_UPDATE, v_I2CM_READ_UPDATE(1));
-}
-
-static int rockchip_hdmiv2_scdc_get_scambling_status(struct hdmi_dev *hdmi_dev)
-{
-	int val;
-
-	val = rockchip_hdmiv2_i2cm_read_data(hdmi_dev, SCDC_SCRAMBLER_STAT);
-	return val;
-}
-
-static void rockchip_hdmiv2_scdc_enable_polling(struct hdmi_dev *hdmi_dev,
-						int enable)
-{
-	rockchip_hdmiv2_scdc_read_request(hdmi_dev, enable);
-	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
-		     m_I2CM_UPRD_VSYNC_EN, v_I2CM_UPRD_VSYNC_EN(enable));
-}
-
-static int rockchip_hdmiv2_scdc_get_status_reg0(struct hdmi_dev *hdmi_dev)
-{
-	rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
-	rockchip_hdmiv2_scdc_update_read(hdmi_dev);
-	return hdmi_readl(hdmi_dev, I2CM_SCDC_UPDATE0);
-}
-
-static int rockchip_hdmiv2_scdc_get_status_reg1(struct hdmi_dev *hdmi_dev)
-{
-	rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
-	rockchip_hdmiv2_scdc_update_read(hdmi_dev);
-	return hdmi_readl(hdmi_dev, I2CM_SCDC_UPDATE1);
-}
-#endif
-
-static void rockchip_hdmiv2_scdc_init(struct hdmi_dev *hdmi_dev)
-{
-	rockchip_hdmiv2_i2cm_reset(hdmi_dev);
-	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 1);
-	rockchip_hdmiv2_i2cm_clk_init(hdmi_dev);
-	/* set scdc i2c addr */
-	hdmi_writel(hdmi_dev, I2CM_SLAVE, DDC_I2C_SCDC_ADDR);
-	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 0);/*enable interrupt*/
-}
-
-static void rockchip_hdmiv2_scdc_set_tmds_rate(struct hdmi_dev *hdmi_dev)
-{
-	int stat;
-
-	mutex_lock(&hdmi_dev->ddc_lock);
-	rockchip_hdmiv2_scdc_init(hdmi_dev);
-	stat = rockchip_hdmiv2_i2cm_read_data(hdmi_dev,
-					      SCDC_TMDS_CONFIG);
-	if (hdmi_dev->tmdsclk > 340000000)
-		stat |= 2;
-	else
-		stat &= 0x1;
-	rockchip_hdmiv2_i2cm_write_data(hdmi_dev,
-					stat, SCDC_TMDS_CONFIG);
-	mutex_unlock(&hdmi_dev->ddc_lock);
-}
-
-static int rockchip_hdmiv2_scrambling_enable(struct hdmi_dev *hdmi_dev,
-					     int enable)
-{
-	HDMIDBG(2, "%s enable %d\n", __func__, enable);
-	if (enable == 1) {
-		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
-		rockchip_hdmiv2_i2cm_write_data(hdmi_dev, 1, SCDC_TMDS_CONFIG);
-		/* TMDS software reset request */
-		hdmi_msk_reg(hdmi_dev, MC_SWRSTZREQ,
-			     m_TMDS_SWRST, v_TMDS_SWRST(0));
-		/* Enable/Disable Scrambling */
-		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
-			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(1));
-	} else {
-		/* Enable/Disable Scrambling */
-		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
-			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(0));
-		/* TMDS software reset request */
-		hdmi_msk_reg(hdmi_dev, MC_SWRSTZREQ,
-			     m_TMDS_SWRST, v_TMDS_SWRST(0));
-		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
-		rockchip_hdmiv2_i2cm_write_data(hdmi_dev, 0, SCDC_TMDS_CONFIG);
-	}
-	return 0;
-}
-
-static const struct ext_pll_config_tab *get_phy_ext_tab(
-		unsigned int pixclock, unsigned int tmdsclk,
-		char colordepth)
-{
-	int i;
-
-	if (pixclock == 0)
-		return NULL;
-	HDMIDBG(2, "%s pixClock %u tmdsclk %u colorDepth %d\n",
-		__func__, pixclock, tmdsclk, colordepth);
-	for (i = 0; i < ARRAY_SIZE(EXT_PLL_TABLE); i++) {
-		if ((EXT_PLL_TABLE[i].pix_clock == pixclock) &&
-		    (EXT_PLL_TABLE[i].tmdsclock == tmdsclk) &&
-		    (EXT_PLL_TABLE[i].color_depth == colordepth))
-			return &EXT_PLL_TABLE[i];
-	}
-	return NULL;
-}
-
-static const struct phy_mpll_config_tab *get_phy_mpll_tab(
-		unsigned int pixclock, unsigned int tmdsclk,
-		char pixrepet, char colordepth)
-{
-	int i;
-
-	if (pixclock == 0)
-		return NULL;
-	HDMIDBG(2, "%s pixClock %u tmdsclk %u pixRepet %d colorDepth %d\n",
-		__func__, pixclock, tmdsclk, pixrepet, colordepth);
-	for (i = 0; i < ARRAY_SIZE(PHY_MPLL_TABLE); i++) {
-		if ((PHY_MPLL_TABLE[i].pix_clock == pixclock) &&
-		    (PHY_MPLL_TABLE[i].tmdsclock == tmdsclk) &&
-		    (PHY_MPLL_TABLE[i].pix_repet == pixrepet) &&
-		    (PHY_MPLL_TABLE[i].color_depth == colordepth))
-			return &PHY_MPLL_TABLE[i];
-	}
-	return NULL;
-}
-
-static void rockchip_hdmiv2_powerdown(struct hdmi_dev *hdmi_dev)
-{
-	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(1));
-
-	if (hdmi_dev->soctype != HDMI_SOC_RK322X) {
-		hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-			     m_PDDQ_SIG | m_TXPWRON_SIG |
-			     m_ENHPD_RXSENSE_SIG | m_SVSRET_SIG,
-			     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0) |
-			     v_ENHPD_RXSENSE_SIG(1)) | v_SVSRET_SIG(0);
-	} else {
-		hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-			     m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
-			     v_TXPWRON_SIG(0) | v_ENHPD_RXSENSE_SIG(0));
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_PDATA_DEN);
-	}
-	hdmi_writel(hdmi_dev, MC_CLKDIS, 0x7f);
-}
-
-int rockchip_hdmiv2_write_phy(struct hdmi_dev *hdmi_dev,
-			      int reg_addr, int val)
-{
-	int trytime = 2, i = 0, op_status = 0;
-
-	if (hdmi_dev->phybase) {
-		writel_relaxed(val, hdmi_dev->phybase + (reg_addr) * 0x04);
-		return 0;
-	}
-	while (trytime--) {
-		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
-		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_1, (val >> 8) & 0xff);
-		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_0, val & 0xff);
-		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_WRITE);
-
-		i = 20;
-		while (i--) {
-			usleep_range(900, 1000);
-			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
-			if (op_status)
-				hdmi_writel(hdmi_dev,
-					    IH_I2CMPHY_STAT0,
-					    op_status);
-
-			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR))
-				break;
-		}
-
-		if (!(op_status & m_I2CMPHY_DONE))
-			dev_err(hdmi_dev->hdmi->dev,
-				"[%s] operation error,trytime=%d\n",
-				__func__, trytime);
-		else
-			return 0;
-		msleep(100);
-	}
-
-	return -1;
-}
-
-int rockchip_hdmiv2_read_phy(struct hdmi_dev *hdmi_dev,
-			     int reg_addr)
-{
-	int trytime = 2, i = 0, op_status = 0;
-	int val = 0;
-
-	if (hdmi_dev->phybase)
-		return readl_relaxed(hdmi_dev->phybase + (reg_addr) * 0x04);
-
-	while (trytime--) {
-		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
-		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_1, 0x00);
-		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_0, 0x00);
-		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_READ);
-
-		i = 20;
-		while (i--) {
-			usleep_range(900, 1000);
-			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
-			if (op_status)
-				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0,
-					    op_status);
-
-			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR))
-				break;
-		}
-
-		if (!(op_status & m_I2CMPHY_DONE)) {
-			pr_err("[%s] operation error,trytime=%d\n",
-			       __func__, trytime);
-		} else {
-			val = hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_1);
-			val = (val & 0xff) << 8;
-			val += (hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_0) & 0xff);
-			pr_debug("phy_reg0x%02x: 0x%04x",
-				 reg_addr, val);
-			return val;
-		}
-		msleep(100);
-	}
-
-	return -1;
-}
-
-#define PHY_TIMEOUT	10000
-
-static int ext_phy_config(struct hdmi_dev *hdmi_dev)
-{
-	int stat = 0, i = 0, temp;
-	const struct ext_pll_config_tab *phy_ext = NULL;
-
-	if (hdmi_dev->grf_base)
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_POWER_DOWN |
-			     RK322X_PLL_PDATA_DEN);
-	if (hdmi_dev->tmdsclk_ratio_change &&
-	    hdmi_dev->hdmi->edid.scdc_present == 1)
-		rockchip_hdmiv2_scdc_set_tmds_rate(hdmi_dev);
-
-	/* config the required PHY I2C register */
-	phy_ext = get_phy_ext_tab(hdmi_dev->pixelclk,
-				  hdmi_dev->tmdsclk,
-				  hdmi_dev->colordepth);
-	if (phy_ext) {
-		stat = ((phy_ext->pll_nf >> 1) & EXT_PHY_PLL_FB_BIT8_MASK) |
-		       ((phy_ext->vco_div_5 & 1) << 5) |
-		       (phy_ext->pll_nd & EXT_PHY_PLL_PRE_DIVIDER_MASK);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PLL_PRE_DIVIDER, stat);
-		stat = phy_ext->pll_nf & 0xff;
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PLL_FB_DIVIDER, stat);
-		stat = (phy_ext->pclk_divider_a & EXT_PHY_PCLK_DIVIDERA_MASK) |
-		       ((phy_ext->pclk_divider_b & 3) << 5);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PCLK_DIVIDER1, stat);
-		stat = (phy_ext->pclk_divider_d & EXT_PHY_PCLK_DIVIDERD_MASK) |
-		       ((phy_ext->pclk_divider_c & 3) << 5);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PCLK_DIVIDER2, stat);
-		stat = ((phy_ext->tmsd_divider_c & 3) << 4) |
-		       ((phy_ext->tmsd_divider_a & 3) << 2) |
-		       (phy_ext->tmsd_divider_b & 3);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_TMDSCLK_DIVIDER, stat);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PPLL_FB_DIVIDER,
-					  phy_ext->ppll_nf);
-
-		if (phy_ext->ppll_no == 1) {
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_PPLL_POST_DIVIDER,
-						  0);
-			stat = 0x20 | phy_ext->ppll_nd;
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_PPLL_PRE_DIVIDER,
-						  stat);
-		} else {
-			stat = ((phy_ext->ppll_no / 2) - 1) << 4;
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_PPLL_POST_DIVIDER,
-						  stat);
-			stat = 0xe0 | phy_ext->ppll_nd;
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_PPLL_PRE_DIVIDER,
-						  stat);
-		}
-	} else {
-		pr_err("%s no supported phy configuration.\n", __func__);
-		return -1;
-	}
-
-	if (hdmi_dev->phy_table) {
-		for (i = 0; i < hdmi_dev->phy_table_size; i++) {
-			temp = hdmi_dev->phy_table[i].maxfreq;
-			if (hdmi_dev->tmdsclk <= temp)
-				break;
-		}
-	}
-
-	if (i != hdmi_dev->phy_table_size && hdmi_dev->phy_table) {
-		if (hdmi_dev->phy_table[i].slopeboost) {
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_SIGNAL_CTRL, 0xff);
-			temp = hdmi_dev->phy_table[i].slopeboost - 1;
-			stat = ((temp & 3) << 6) | ((temp & 3) << 4) |
-			       ((temp & 3) << 2) | (temp & 3);
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_SLOPEBOOST, stat);
-		} else {
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  EXT_PHY_SIGNAL_CTRL, 0x0f);
-		}
-		stat = ((hdmi_dev->phy_table[i].pre_emphasis & 3) << 4) |
-		       ((hdmi_dev->phy_table[i].pre_emphasis & 3) << 2) |
-		       (hdmi_dev->phy_table[i].pre_emphasis & 3);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_PREEMPHASIS, stat);
-		stat = ((hdmi_dev->phy_table[i].clk_level & 0xf) << 4) |
-		       (hdmi_dev->phy_table[i].data2_level & 0xf);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_LEVEL1, stat);
-		stat = ((hdmi_dev->phy_table[i].data1_level & 0xf) << 4) |
-		       (hdmi_dev->phy_table[i].data0_level & 0xf);
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_LEVEL2, stat);
-	} else {
-		rockchip_hdmiv2_write_phy(hdmi_dev,
-					  EXT_PHY_SIGNAL_CTRL, 0x0f);
-	}
-	rockchip_hdmiv2_write_phy(hdmi_dev, 0xf3, 0x22);
-
-	stat = clk_get_rate(hdmi_dev->pclk_phy) / 100000;
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL,
-				  ((stat >> 8) & 0xff) | 0x80);
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL_DIV_L,
-				  stat & 0xff);
-	if (hdmi_dev->tmdsclk > 340000000)
-		stat = EXT_PHY_AUTO_R100_OHMS;
-	else if (hdmi_dev->tmdsclk > 200000000)
-		stat = EXT_PHY_AUTO_R50_OHMS;
-	else
-		stat = EXT_PHY_AUTO_ROPEN_CIRCUIT;
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_RESIS_AUTO,
-				  stat | 0x20);
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL,
-				  (stat >> 8) & 0xff);
-	if (hdmi_dev->tmdsclk > 200000000)
-		stat = 0;
-	else
-		stat = 0x11;
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_PLL_BW, stat);
-	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_PPLL_BW, 0x27);
-	if (hdmi_dev->grf_base)
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_POWER_UP);
-	if (hdmi_dev->tmdsclk_ratio_change)
-		msleep(100);
-	else
-		usleep_range(900, 1000);
-	hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-		     m_TXPWRON_SIG, v_TXPWRON_SIG(1));
-	i = 0;
-	while (i++ < PHY_TIMEOUT) {
-		if ((i % 10) == 0) {
-			temp = EXT_PHY_PPLL_POST_DIVIDER;
-			stat = rockchip_hdmiv2_read_phy(hdmi_dev, temp);
-			if (stat & EXT_PHY_PPLL_LOCK_STATUS_MASK)
-				break;
-			usleep_range(1000, 2000);
-		}
-	}
-	if ((stat & EXT_PHY_PPLL_LOCK_STATUS_MASK) == 0) {
-		stat = hdmi_readl(hdmi_dev, MC_LOCKONCLOCK);
-		dev_err(hdmi_dev->hdmi->dev,
-			"PHY PLL not locked: PCLK_ON=%ld,TMDSCLK_ON=%ld\n",
-			(stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
-		return -1;
-	}
-
-	if (hdmi_dev->grf_base)
-		regmap_write(hdmi_dev->grf_base,
-			     RK322X_GRF_SOC_CON2,
-			     RK322X_PLL_PDATA_EN);
-
-	return 0;
-}
-
-static int rockchip_hdmiv2_config_phy(struct hdmi_dev *hdmi_dev)
-{
-	int stat = 0, i = 0;
-	const struct phy_mpll_config_tab *phy_mpll = NULL;
-
-	if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
-		return ext_phy_config(hdmi_dev);
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3366) {
-		if (hdmi_dev->pixelclk > 148500000)
-			clk_set_rate(hdmi_dev->pclk_phy, 148500000);
-		else
-			clk_set_rate(hdmi_dev->pclk_phy, hdmi_dev->pixelclk);
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
-		clk_set_rate(hdmi_dev->pclk_phy, hdmi_dev->pixelclk);
-	}
-
-	hdmi_msk_reg(hdmi_dev, PHY_I2CM_DIV,
-		     m_PHY_I2CM_FAST_STD, v_PHY_I2CM_FAST_STD(0));
-	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(1));
-	/* power off PHY */
-	hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-		     m_PDDQ_SIG | m_TXPWRON_SIG | m_SVSRET_SIG,
-		     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0) | v_SVSRET_SIG(1));
-
-	if (hdmi_dev->tmdsclk_ratio_change &&
-	    hdmi_dev->hdmi->edid.scdc_present == 1)
-		rockchip_hdmiv2_scdc_set_tmds_rate(hdmi_dev);
-
-	/* reset PHY */
-	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(1));
-	usleep_range(1000, 2000);
-	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(0));
-
-	/* Set slave address as PHY GEN2 address */
-	hdmi_writel(hdmi_dev, PHY_I2CM_SLAVE, PHY_GEN2_ADDR);
-
-	/* config the required PHY I2C register */
-	if (hdmi_dev->soctype == HDMI_SOC_RK3366 &&
-	    hdmi_dev->pixelclk > 148500000)
-		phy_mpll = get_phy_mpll_tab(148500000,
-					    hdmi_dev->tmdsclk,
-					    hdmi_dev->pixelrepeat - 1,
-					    hdmi_dev->colordepth);
-	else
-		phy_mpll = get_phy_mpll_tab(hdmi_dev->pixelclk,
-					    hdmi_dev->tmdsclk,
-					    hdmi_dev->pixelrepeat - 1,
-					    hdmi_dev->colordepth);
-	if (phy_mpll) {
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_OPMODE_PLLCFG,
-					  v_PREP_DIV(phy_mpll->prep_div) |
-					  v_TMDS_CNTRL(
-					  phy_mpll->tmdsmhl_cntrl) |
-					  v_OPMODE(phy_mpll->opmode) |
-					  v_FBDIV2_CNTRL(
-					  phy_mpll->fbdiv2_cntrl) |
-					  v_FBDIV1_CNTRL(
-					  phy_mpll->fbdiv1_cntrl) |
-					  v_REF_CNTRL(phy_mpll->ref_cntrl) |
-					  v_MPLL_N_CNTRL(phy_mpll->n_cntrl));
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_PLLCURRCTRL,
-					  v_MPLL_PROP_CNTRL(
-					  phy_mpll->prop_cntrl) |
-					  v_MPLL_INT_CNTRL(
-					  phy_mpll->int_cntrl));
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_PLLGMPCTRL,
-					  v_MPLL_GMP_CNTRL(
-					  phy_mpll->gmp_cntrl));
-	}
-
-	if (hdmi_dev->phy_table) {
-		for (i = 0; i < hdmi_dev->phy_table_size; i++)
-			if (hdmi_dev->tmdsclk <= hdmi_dev->phy_table[i].maxfreq)
-				break;
-	}
-	if (i != hdmi_dev->phy_table_size && hdmi_dev->phy_table) {
-		stat = v_OVERRIDE(1) | v_TX_SYMON(1) | v_CLK_SYMON(1) |
-		       v_PREEMPHASIS(hdmi_dev->phy_table[i].pre_emphasis) |
-		       v_SLOPEBOOST(hdmi_dev->phy_table[i].slopeboost);
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL, stat);
-
-		stat = v_SUP_CLKLVL(hdmi_dev->phy_table[i].clk_level) |
-		       v_SUP_TXLVL(hdmi_dev->phy_table[i].data0_level);
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_VLEVCTRL, stat);
-	} else {
-		pr_info("%s use default phy settings\n", __func__);
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL,
-					  v_OVERRIDE(1) | v_SLOPEBOOST(0) |
-					  v_TX_SYMON(1) | v_CLK_SYMON(1) |
-					  v_PREEMPHASIS(0));
-		if (hdmi_dev->tmdsclk > 340000000)
-			rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_VLEVCTRL,
-						  v_SUP_TXLVL(9) |
-						  v_SUP_CLKLVL(17));
-		else if (hdmi_dev->tmdsclk > 165000000)
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  PHYTX_VLEVCTRL,
-						  v_SUP_TXLVL(14) |
-						  v_SUP_CLKLVL(17));
-		else
-			rockchip_hdmiv2_write_phy(hdmi_dev,
-						  PHYTX_VLEVCTRL,
-						  v_SUP_TXLVL(18) |
-						  v_SUP_CLKLVL(17));
-	}
-
-	if (hdmi_dev->tmdsclk > 340000000)
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
-					  v_TX_TERM(R50_OHMS));
-	else
-		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
-					  v_TX_TERM(R100_OHMS));
-	/* rockchip_hdmiv2_write_phy(hdmi_dev, 0x05, 0x8000); */
-	if (hdmi_dev->tmdsclk_ratio_change)
-		msleep(100);
-	/* power on PHY */
-	hdmi_writel(hdmi_dev, PHY_CONF0, 0x2e);
-
-	/* check if the PHY PLL is locked */
-
-	i = 0;
-	while (i++ < PHY_TIMEOUT) {
-		if ((i % 10) == 0) {
-			stat = hdmi_readl(hdmi_dev, PHY_STAT0);
-			if (stat & m_PHY_LOCK)
-				break;
-			usleep_range(1000, 2000);
-		}
-	}
-	if ((stat & m_PHY_LOCK) == 0) {
-		stat = hdmi_readl(hdmi_dev, MC_LOCKONCLOCK);
-		dev_err(hdmi_dev->hdmi->dev,
-			"PHY PLL not locked: PCLK_ON=%ld,TMDSCLK_ON=%ld\n",
-			(stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
-		return -1;
-	}
-	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(0));
-	return 0;
-}
-
-static int rockchip_hdmiv2_video_framecomposer(struct hdmi *hdmi_drv,
-					       struct hdmi_video *vpara)
-{
-	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
-	int value, vsync_pol, hsync_pol, de_pol;
-	struct hdmi_video_timing *timing = NULL;
-	struct fb_videomode *mode = NULL;
-	u32 sink_version, tmdsclk;
-
-	vsync_pol = hdmi_drv->lcdc->cur_screen->pin_vsync;
-	hsync_pol = hdmi_drv->lcdc->cur_screen->pin_hsync;
-	de_pol = (hdmi_drv->lcdc->cur_screen->pin_den == 0) ? 1 : 0;
-
-	hdmi_msk_reg(hdmi_dev, A_VIDPOLCFG,
-		     m_DATAEN_POL | m_VSYNC_POL | m_HSYNC_POL,
-		     v_DATAEN_POL(de_pol) |
-		     v_VSYNC_POL(vsync_pol) |
-		     v_HSYNC_POL(hsync_pol));
-
-	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
-	if (!timing) {
-		dev_err(hdmi_drv->dev,
-			"[%s] not found vic %d\n", __func__, vpara->vic);
-		return -ENOENT;
-	}
-	mode = &timing->mode;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		tmdsclk = mode->pixclock / 2;
-	else if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
-		tmdsclk = 2 * mode->pixclock;
-	else
-		tmdsclk = mode->pixclock;
-	if (vpara->color_output != HDMI_COLOR_YCBCR422) {
-		switch (vpara->color_output_depth) {
-		case 10:
-			tmdsclk += tmdsclk / 4;
-			break;
-		case 12:
-			tmdsclk += tmdsclk / 2;
-			break;
-		case 16:
-			tmdsclk += tmdsclk;
-			break;
-		case 8:
-		default:
-			break;
-		}
-	} else if (vpara->color_output_depth > 12) {
-		/* YCbCr422 mode only support up to 12bit */
-		vpara->color_output_depth = 12;
-	}
-	if ((tmdsclk > 594000000) ||
-	    (tmdsclk > 340000000 &&
-	     tmdsclk > hdmi_drv->edid.maxtmdsclock)) {
-		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
-			pr_err("3d frame packing mode out of max tmdsclk\n");
-			return -1;
-		} else if (vpara->color_output == HDMI_COLOR_YCBCR444 &&
-			   hdmi_drv->edid.ycbcr422) {
-			pr_warn("out of max tmdsclk, down to YCbCr422");
-			vpara->color_output = HDMI_COLOR_YCBCR422;
-			tmdsclk = mode->pixclock;
-		} else {
-			pr_warn("out of max tmds clock, limit to 8bit\n");
-			vpara->color_output_depth = 8;
-			if (vpara->color_input == HDMI_COLOR_YCBCR420)
-				tmdsclk = mode->pixclock / 2;
-			else
-				tmdsclk = mode->pixclock;
-		}
-	}
-
-	if ((tmdsclk > 340000000) ||
-	    (tmdsclk < 340000000 && hdmi_dev->tmdsclk > 340000000))
-		hdmi_dev->tmdsclk_ratio_change = true;
-	else
-		hdmi_dev->tmdsclk_ratio_change = false;
-
-	hdmi_dev->tmdsclk = tmdsclk;
-	if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
-		hdmi_dev->pixelclk = 2 * mode->pixclock;
-	else
-		hdmi_dev->pixelclk = mode->pixclock;
-	hdmi_dev->pixelrepeat = timing->pixelrepeat;
-	/* hdmi_dev->colordepth is used for find pll config.
-	 * For YCbCr422, tmdsclk is same on all color depth.
-	 */
-	if (vpara->color_output == HDMI_COLOR_YCBCR422)
-		hdmi_dev->colordepth = 8;
-	else
-		hdmi_dev->colordepth = vpara->color_output_depth;
-	pr_info("pixel clk is %lu tmds clk is %u\n",
-		hdmi_dev->pixelclk, hdmi_dev->tmdsclk);
-	/* Start/stop HDCP keepout window generation */
-	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
-		     m_FC_HDCP_KEEPOUT, v_FC_HDCP_KEEPOUT(1));
-	if (hdmi_drv->edid.scdc_present == 1 && !hdmi_drv->uboot) {
-		if (tmdsclk > 340000000 ||
-		    hdmi_drv->edid.lte_340mcsc_scramble) {
-			/* used for HDMI 2.0 TX */
-			mutex_lock(&hdmi_dev->ddc_lock);
-			rockchip_hdmiv2_scdc_init(hdmi_dev);
-			sink_version =
-			rockchip_hdmiv2_scdc_get_sink_version(hdmi_dev);
-			pr_info("sink scdc version is %d\n", sink_version);
-			sink_version = hdmi_drv->edid.hf_vsdb_version;
-			rockchip_hdmiv2_scdc_set_source_version(hdmi_dev,
-								sink_version);
-			if (hdmi_drv->edid.rr_capable == 1)
-				rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
-			rockchip_hdmiv2_scrambling_enable(hdmi_dev, 1);
-			mutex_unlock(&hdmi_dev->ddc_lock);
-		} else {
-			mutex_lock(&hdmi_dev->ddc_lock);
-			rockchip_hdmiv2_scdc_init(hdmi_dev);
-			rockchip_hdmiv2_scrambling_enable(hdmi_dev, 0);
-			mutex_unlock(&hdmi_dev->ddc_lock);
-		}
-	} else {
-		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
-			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(0));
-	}
-
-	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
-		     m_FC_VSYNC_POL | m_FC_HSYNC_POL | m_FC_DE_POL |
-		     m_FC_HDMI_DVI | m_FC_INTERLACE_MODE,
-		     v_FC_VSYNC_POL(vsync_pol) | v_FC_HSYNC_POL(hsync_pol) |
-		     v_FC_DE_POL(de_pol) | v_FC_HDMI_DVI(vpara->sink_hdmi) |
-		     v_FC_INTERLACE_MODE(mode->vmode));
-	if ((mode->vmode & FB_VMODE_INTERLACED) &&
-	    vpara->format_3d != HDMI_3D_FRAME_PACKING)
-		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
-			     m_FC_VBLANK, v_FC_VBLANK(1));
-	else
-		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
-			     m_FC_VBLANK, v_FC_VBLANK(0));
-
-	value = mode->xres;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		value = value / 2;
-	hdmi_writel(hdmi_dev, FC_INHACTIV1, v_FC_HACTIVE1(value >> 8));
-	hdmi_writel(hdmi_dev, FC_INHACTIV0, (value & 0xff));
-
-	if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
-		if (mode->vmode == 0)
-			value = 2 * mode->yres +
-				mode->upper_margin +
-				mode->lower_margin +
-				mode->vsync_len;
-		else
-			value = 2 * mode->yres +
-				3 * (mode->upper_margin +
-				     mode->lower_margin +
-				     mode->vsync_len) + 2;
-	} else {
-		value = mode->yres;
-	}
-	hdmi_writel(hdmi_dev, FC_INVACTIV1, v_FC_VACTIVE1(value >> 8));
-	hdmi_writel(hdmi_dev, FC_INVACTIV0, (value & 0xff));
-
-	value = mode->hsync_len + mode->left_margin + mode->right_margin;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		value = value / 2;
-	hdmi_writel(hdmi_dev, FC_INHBLANK1, v_FC_HBLANK1(value >> 8));
-	hdmi_writel(hdmi_dev, FC_INHBLANK0, (value & 0xff));
-
-	value = mode->vsync_len + mode->upper_margin + mode->lower_margin;
-	hdmi_writel(hdmi_dev, FC_INVBLANK, (value & 0xff));
-
-	value = mode->right_margin;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		value = value / 2;
-	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY1, v_FC_HSYNCINDEAY1(value >> 8));
-	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY0, (value & 0xff));
-
-	value = mode->lower_margin;
-	hdmi_writel(hdmi_dev, FC_VSYNCINDELAY, (value & 0xff));
-
-	value = mode->hsync_len;
-	if (vpara->color_input == HDMI_COLOR_YCBCR420)
-		value = value / 2;
-	hdmi_writel(hdmi_dev, FC_HSYNCINWIDTH1, v_FC_HSYNCWIDTH1(value >> 8));
-	hdmi_writel(hdmi_dev, FC_HSYNCINWIDTH0, (value & 0xff));
-
-	value = mode->vsync_len;
-	hdmi_writel(hdmi_dev, FC_VSYNCINWIDTH, (value & 0xff));
-
-	/* Set the control period minimum duration (min. of 12 pixel
-	 * clock cycles, refer to HDMI 1.4b specification)
-	 */
-	hdmi_writel(hdmi_dev, FC_CTRLDUR, 12);
-	hdmi_writel(hdmi_dev, FC_EXCTRLDUR, 32);
-
-	/* spacing < 256^2 * config / tmdsClock, spacing <= 50ms
-	 * worst case: tmdsClock == 25MHz => config <= 19
-	 */
-	hdmi_writel(hdmi_dev, FC_EXCTRLSPAC,
-		    (hdmi_dev->tmdsclk / 1000) * 50 / (256 * 512));
-
-	hdmi_writel(hdmi_dev, FC_PRCONF,
-		    v_FC_PR_FACTOR(timing->pixelrepeat) |
-		    v_FC_PR_FACTOR_OUT(timing->pixelrepeat - 1));
-
-	return 0;
-}
-
-static int rockchip_hdmiv2_video_packetizer(struct hdmi_dev *hdmi_dev,
-					    struct hdmi_video *vpara)
-{
-	unsigned char color_depth = COLOR_DEPTH_24BIT_DEFAULT;
-	unsigned char output_select = 0;
-	unsigned char remap_size = 0;
-
-	if (vpara->color_output == HDMI_COLOR_YCBCR422) {
-		switch (vpara->color_output_depth) {
-		case 8:
-			remap_size = YCC422_16BIT;
-			break;
-		case 10:
-			remap_size = YCC422_20BIT;
-			break;
-		case 12:
-			remap_size = YCC422_24BIT;
-			break;
-		default:
-			remap_size = YCC422_16BIT;
-			break;
-		}
-
-		output_select = OUT_FROM_YCC422_REMAP;
-		/*Config remap size for the different color Depth*/
-		hdmi_msk_reg(hdmi_dev, VP_REMAP,
-			     m_YCC422_SIZE, v_YCC422_SIZE(remap_size));
-	} else {
-		switch (vpara->color_output_depth) {
-		case 10:
-			color_depth = COLOR_DEPTH_30BIT;
-			output_select = OUT_FROM_PIXEL_PACKING;
-			break;
-		case 12:
-			color_depth = COLOR_DEPTH_36BIT;
-			output_select = OUT_FROM_PIXEL_PACKING;
-			break;
-		case 16:
-			color_depth = COLOR_DEPTH_48BIT;
-			output_select = OUT_FROM_PIXEL_PACKING;
-			break;
-		case 8:
-		default:
-			color_depth = COLOR_DEPTH_24BIT_DEFAULT;
-			output_select = OUT_FROM_8BIT_BYPASS;
-			break;
-		}
-	}
-	/*Config Color Depth*/
-	hdmi_msk_reg(hdmi_dev, VP_PR_CD,
-		     m_COLOR_DEPTH, v_COLOR_DEPTH(color_depth));
-	/*Config pixel repettion*/
-	hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_DESIRED_PR_FACTOR,
-		     v_DESIRED_PR_FACTOR(hdmi_dev->pixelrepeat - 1));
-	if (hdmi_dev->pixelrepeat > 1)
-		hdmi_msk_reg(hdmi_dev, VP_CONF,
-			     m_PIXEL_REPET_EN | m_BYPASS_SEL,
-			     v_PIXEL_REPET_EN(1) | v_BYPASS_SEL(0));
-	else
-		hdmi_msk_reg(hdmi_dev, VP_CONF,
-			     m_PIXEL_REPET_EN | m_BYPASS_SEL,
-			     v_PIXEL_REPET_EN(0) | v_BYPASS_SEL(1));
-
-	/*config output select*/
-	if (output_select == OUT_FROM_PIXEL_PACKING) { /* pixel packing */
-		hdmi_msk_reg(hdmi_dev, VP_CONF,
-			     m_BYPASS_EN | m_PIXEL_PACK_EN |
-			     m_YCC422_EN | m_OUTPUT_SEL,
-			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(1) |
-			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
-	} else if (output_select == OUT_FROM_YCC422_REMAP) { /* YCC422 */
-		hdmi_msk_reg(hdmi_dev, VP_CONF,
-			     m_BYPASS_EN | m_PIXEL_PACK_EN |
-			     m_YCC422_EN | m_OUTPUT_SEL,
-			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(0) |
-			     v_YCC422_EN(1) | v_OUTPUT_SEL(output_select));
-	} else if (output_select == OUT_FROM_8BIT_BYPASS ||
-		   output_select == 3) { /* bypass */
-		hdmi_msk_reg(hdmi_dev, VP_CONF,
-			     m_BYPASS_EN | m_PIXEL_PACK_EN |
-			     m_YCC422_EN | m_OUTPUT_SEL,
-			     v_BYPASS_EN(1) | v_PIXEL_PACK_EN(0) |
-			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
-	}
-
-#if defined(HDMI_VIDEO_STUFFING)
-	/* YCC422 and pixel packing stuffing*/
-	hdmi_msk_reg(hdmi_dev, VP_STUFF, m_PR_STUFFING, v_PR_STUFFING(1));
-	hdmi_msk_reg(hdmi_dev, VP_STUFF,
-		     m_YCC422_STUFFING | m_PP_STUFFING,
-		     v_YCC422_STUFFING(1) | v_PP_STUFFING(1));
-#endif
-	return 0;
-}
-
-static int rockchip_hdmiv2_video_sampler(struct hdmi_dev *hdmi_dev,
-					 struct hdmi_video *vpara)
-{
-	int map_code = 0;
-
-	if (vpara->color_input == HDMI_COLOR_YCBCR422) {
-		/* YCC422 mapping is discontinued - only map 1 is supported */
-		switch (vpara->color_output_depth) {
-		case 8:
-			map_code = VIDEO_YCBCR422_8BIT;
-			break;
-		case 10:
-			map_code = VIDEO_YCBCR422_10BIT;
-			break;
-		case 12:
-			map_code = VIDEO_YCBCR422_12BIT;
-			break;
-		default:
-			map_code = VIDEO_YCBCR422_8BIT;
-			break;
-		}
-	} else if (vpara->color_input == HDMI_COLOR_YCBCR420 ||
-		   vpara->color_input == HDMI_COLOR_YCBCR444) {
-		switch (vpara->color_output_depth) {
-		case 10:
-			map_code = VIDEO_YCBCR444_10BIT;
-			break;
-		case 12:
-			map_code = VIDEO_YCBCR444_12BIT;
-			break;
-		case 16:
-			map_code = VIDEO_YCBCR444_16BIT;
-			break;
-		case 8:
-		default:
-			map_code = VIDEO_YCBCR444_8BIT;
-			break;
-		}
-	} else {
-		switch (vpara->color_output_depth) {
-		case 10:
-			map_code = VIDEO_RGB444_10BIT;
-			break;
-		case 12:
-			map_code = VIDEO_RGB444_12BIT;
-			break;
-		case 16:
-			map_code = VIDEO_RGB444_16BIT;
-			break;
-		case 8:
-		default:
-			map_code = VIDEO_RGB444_8BIT;
-			break;
-		}
-	}
-
-	/* Set Data enable signal from external
-	 * and set video sample input mapping
-	 */
-	hdmi_msk_reg(hdmi_dev, TX_INVID0,
-		     m_INTERNAL_DE_GEN | m_VIDEO_MAPPING,
-		     v_INTERNAL_DE_GEN(0) | v_VIDEO_MAPPING(map_code));
-
-#if defined(HDMI_VIDEO_STUFFING)
-	hdmi_writel(hdmi_dev, TX_GYDATA0, 0x00);
-	hdmi_writel(hdmi_dev, TX_GYDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
-		     m_GYDATA_STUFF, v_GYDATA_STUFF(1));
-	hdmi_writel(hdmi_dev, TX_RCRDATA0, 0x00);
-	hdmi_writel(hdmi_dev, TX_RCRDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
-		     m_RCRDATA_STUFF, v_RCRDATA_STUFF(1));
-	hdmi_writel(hdmi_dev, TX_BCBDATA0, 0x00);
-	hdmi_writel(hdmi_dev, TX_BCBDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
-		     m_BCBDATA_STUFF, v_BCBDATA_STUFF(1));
-#endif
-	return 0;
-}
-
-static const char coeff_csc[][24] = {
-		/*   G		R	    B		Bias
-		 *   A1    |	A2     |    A3     |	A4    |
-		 *   B1    |    B2     |    B3     |    B4    |
-		 *   C1    |    C2     |    C3     |    C4    |
-		 */
-	{	/* CSC_BYPASS */
-		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
-		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
-		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
-	},
-	{	/* CSC_RGB_0_255_TO_RGB_16_235_8BIT */
-		0x36, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,		/*G*/
-		0x00, 0x00, 0x36, 0xf7, 0x00, 0x00, 0x00, 0x40,		/*R*/
-		0x00, 0x00, 0x00, 0x00, 0x36, 0xf7, 0x00, 0x40,		/*B*/
-	},
-	{	/* CSC_RGB_0_255_TO_RGB_16_235_10BIT */
-		0x36, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,		/*G*/
-		0x00, 0x00, 0x36, 0xf7, 0x00, 0x00, 0x01, 0x00,		/*R*/
-		0x00, 0x00, 0x00, 0x00, 0x36, 0xf7, 0x01, 0x00,		/*B*/
-	},
-	{	/* CSC_RGB_0_255_TO_ITU601_16_235_8BIT */
-		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x00, 0x40,		/*Y*/
-		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x02, 0x00,		/*Cr*/
-		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x02, 0x00,		/*Cb*/
-	},
-	{	/* CSC_RGB_0_255_TO_ITU601_16_235_10BIT */
-		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x01, 0x00,		/*Y*/
-		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x08, 0x00,		/*Cr*/
-		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x08, 0x00,		/*Cb*/
-	},
-	{	/* CSC_RGB_0_255_TO_ITU709_16_235_8BIT */
-		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x00, 0x40,		/*Y*/
-		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x02, 0x00,		/*Cr*/
-		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x02, 0x00,		/*Cb*/
-	},
-	{	/* CSC_RGB_0_255_TO_ITU709_16_235_10BIT */
-		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x01, 0x00,		/*Y*/
-		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x08, 0x00,		/*Cr*/
-		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x08, 0x00,		/*Cb*/
-	},
-		/* Y		Cr	    Cb		Bias */
-	{	/* CSC_ITU601_16_235_TO_RGB_0_255_8BIT */
-		0x20, 0x00, 0x69, 0x26, 0x74, 0xfd, 0x01, 0x0e,		/*G*/
-		0x20, 0x00, 0x2c, 0xdd, 0x00, 0x00, 0x7e, 0x9a,		/*R*/
-		0x20, 0x00, 0x00, 0x00, 0x38, 0xb4, 0x7e, 0x3b,		/*B*/
-	},
-	{	/* CSC_ITU709_16_235_TO_RGB_0_255_8BIT */
-		0x20, 0x00, 0x71, 0x06, 0x7a, 0x02, 0x00, 0xa7,		/*G*/
-		0x20, 0x00, 0x32, 0x64, 0x00, 0x00, 0x7e, 0x6d,		/*R*/
-		0x20, 0x00, 0x00, 0x00, 0x3b, 0x61, 0x7e, 0x25,		/*B*/
-	},
-};
-
-static int rockchip_hdmiv2_video_csc(struct hdmi_dev *hdmi_dev,
-				     struct hdmi_video *vpara)
-{
-	int i, mode, interpolation, decimation, csc_scale = 0;
-	const char *coeff = NULL;
-	unsigned char color_depth = 0;
-
-	if (vpara->color_input == vpara->color_output) {
-		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
-			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(0));
-		return 0;
-	}
-
-	if (vpara->color_input == HDMI_COLOR_YCBCR422 &&
-	    vpara->color_output != HDMI_COLOR_YCBCR422 &&
-	    vpara->color_output != HDMI_COLOR_YCBCR420) {
-		interpolation = 1;
-		hdmi_msk_reg(hdmi_dev, CSC_CFG,
-			     m_CSC_INTPMODE, v_CSC_INTPMODE(interpolation));
-	}
-
-	if ((vpara->color_input == HDMI_COLOR_RGB_0_255 ||
-	     vpara->color_input == HDMI_COLOR_YCBCR444) &&
-	     vpara->color_output == HDMI_COLOR_YCBCR422) {
-		decimation = 1;
-		hdmi_msk_reg(hdmi_dev, CSC_CFG,
-			     m_CSC_DECIMODE, v_CSC_DECIMODE(decimation));
-	}
-
-	mode = CSC_BYPASS;
-	csc_scale = 0;
-
-	switch (vpara->vic) {
-	case HDMI_720X480I_60HZ_4_3:
-	case HDMI_720X576I_50HZ_4_3:
-	case HDMI_720X480P_60HZ_4_3:
-	case HDMI_720X576P_50HZ_4_3:
-	case HDMI_720X480I_60HZ_16_9:
-	case HDMI_720X576I_50HZ_16_9:
-	case HDMI_720X480P_60HZ_16_9:
-	case HDMI_720X576P_50HZ_16_9:
-		if (vpara->color_input == HDMI_COLOR_RGB_0_255 &&
-		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
-			mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
-			csc_scale = 0;
-		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
-			   vpara->color_output == HDMI_COLOR_RGB_0_255) {
-			mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-			csc_scale = 1;
-		}
-		break;
-	default:
-		if (vpara->color_input == HDMI_COLOR_RGB_0_255 &&
-		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
-			mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
-			csc_scale = 0;
-		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
-			   vpara->color_output == HDMI_COLOR_RGB_0_255) {
-			mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
-			csc_scale = 1;
-		}
-		break;
-	}
-
-	if ((vpara->color_input == HDMI_COLOR_RGB_0_255) &&
-	    (vpara->color_output == HDMI_COLOR_RGB_16_235)) {
-		mode = CSC_RGB_0_255_TO_RGB_16_235_8BIT;
-		csc_scale = 0;
-	}
-	if (mode != CSC_BYPASS) {
-		switch (vpara->color_output_depth) {
-		case 10:
-			color_depth = COLOR_DEPTH_30BIT;
-			mode += 1;
-			break;
-		case 12:
-			color_depth = COLOR_DEPTH_36BIT;
-			mode += 2;
-			break;
-		case 16:
-			color_depth = COLOR_DEPTH_48BIT;
-			mode += 3;
-			break;
-		case 8:
-		default:
-			color_depth = COLOR_DEPTH_24BIT;
-			break;
-		}
-	}
-	coeff = coeff_csc[mode];
-	for (i = 0; i < 24; i++)
-		hdmi_writel(hdmi_dev, CSC_COEF_A1_MSB + i, coeff[i]);
-
-	hdmi_msk_reg(hdmi_dev, CSC_SCALE,
-		     m_CSC_SCALE, v_CSC_SCALE(csc_scale));
-	/*config CSC_COLOR_DEPTH*/
-	hdmi_msk_reg(hdmi_dev, CSC_SCALE,
-		     m_CSC_COLOR_DEPTH, v_CSC_COLOR_DEPTH(color_depth));
-
-	/* enable CSC */
-	if (mode == CSC_BYPASS)
-		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
-			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(0));
-	else
-		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
-			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(1));
-	return 0;
-}
-
-static int hdmi_dev_detect_hotplug(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	u32 value;
-
-	value = hdmi_readl(hdmi_dev, PHY_STAT0);
-	HDMIDBG(2, "[%s] reg%x value %02x\n", __func__, PHY_STAT0, value);
-	if (value & m_PHY_HPD)
-		return HDMI_HPD_ACTIVATED;
-
-	return HDMI_HPD_REMOVED;
-}
-
-static int hdmi_dev_read_edid(struct hdmi *hdmi, int block, unsigned char *buff)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	int i = 0, n = 0, index = 0, ret = -1, trytime = 5;
-	int offset = (block % 2) * 0x80;
-	int interrupt = 0;
-
-	HDMIDBG(2, "[%s] block %d\n", __func__, block);
-
-	rockchip_hdmiv2_i2cm_reset(hdmi_dev);
-
-	/* Set DDC I2C CLK which divided from DDC_CLK to 100KHz. */
-	rockchip_hdmiv2_i2cm_clk_init(hdmi_dev);
-
-	/* Enable I2C interrupt for reading edid */
-	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 0);
-
-	hdmi_writel(hdmi_dev, I2CM_SLAVE, DDC_I2C_EDID_ADDR);
-	hdmi_writel(hdmi_dev, I2CM_SEGADDR, DDC_I2C_SEG_ADDR);
-	hdmi_writel(hdmi_dev, I2CM_SEGPTR, block / 2);
-	for (n = 0; n < HDMI_EDID_BLOCK_SIZE / 8; n++) {
-		for (trytime = 0; trytime < 5; trytime++) {
-			hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset + 8 * n);
-			/* enable extend sequential read operation */
-			if (block == 0)
-				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
-					     m_I2CM_RD8, v_I2CM_RD8(1));
-			else
-				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
-					     m_I2CM_RD8_EXT,
-					     v_I2CM_RD8_EXT(1));
-
-			i = 20;
-			while (i--) {
-				usleep_range(900, 1000);
-				interrupt = hdmi_readl(hdmi_dev,
-						       IH_I2CM_STAT0);
-				if (interrupt)
-					hdmi_writel(hdmi_dev,
-						    IH_I2CM_STAT0, interrupt);
-
-				if (interrupt &
-				    (m_SCDC_READREQ | m_I2CM_DONE |
-				     m_I2CM_ERROR))
-					break;
-			}
-
-			if (interrupt & m_I2CM_DONE) {
-				for (index = 0; index < 8; index++)
-					buff[8 * n + index] =
-						hdmi_readl(hdmi_dev,
-							   I2CM_READ_BUFF0 +
-							   index);
-
-				if (n == HDMI_EDID_BLOCK_SIZE / 8 - 1) {
-					ret = 0;
-					goto exit;
-				}
-				break;
-			} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
-				dev_err(hdmi->dev,
-					"[%s] edid read %d error\n",
-					__func__, offset + 8 * n);
-			}
-		}
-		if (trytime == 5) {
-			dev_err(hdmi->dev,
-				"[%s] edid read error\n", __func__);
-			break;
-		}
-	}
-
-exit:
-	/* Disable I2C interrupt */
-	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 1);
-	return ret;
-}
-
-static void hdmi_dev_config_avi(struct hdmi *hdmi,
-				struct hdmi_video *vpara)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	unsigned char colorimetry, ext_colorimetry = 0, aspect_ratio, y1y0;
-	unsigned char rgb_quan_range = AVI_QUANTIZATION_RANGE_DEFAULT;
-
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO3, m_AVI_AUTO, v_AVI_AUTO(0));
-	hdmi_msk_reg(hdmi_dev, IH_FC_STAT1,
-		     m_AVI_INFOFRAME, v_AVI_INFOFRAME(1));
-	/* Set AVI infoFrame Data byte1 */
-	if (vpara->color_output == HDMI_COLOR_YCBCR444)
-		y1y0 = AVI_COLOR_MODE_YCBCR444;
-	else if (vpara->color_output == HDMI_COLOR_YCBCR422)
-		y1y0 = AVI_COLOR_MODE_YCBCR422;
-	else if (vpara->color_output == HDMI_COLOR_YCBCR420)
-		y1y0 = AVI_COLOR_MODE_YCBCR420;
-	else
-		y1y0 = AVI_COLOR_MODE_RGB;
-
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF0,
-		     m_FC_ACTIV_FORMAT | m_FC_RGC_YCC,
-		     v_FC_RGC_YCC(y1y0) | v_FC_ACTIV_FORMAT(1));
-
-	/* Set AVI infoFrame Data byte2 */
-	switch (vpara->vic) {
-	case HDMI_720X480I_60HZ_4_3:
-	case HDMI_720X576I_50HZ_4_3:
-	case HDMI_720X480P_60HZ_4_3:
-	case HDMI_720X576P_50HZ_4_3:
-		aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
-		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
-			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
-		break;
-	case HDMI_720X480I_60HZ_16_9:
-	case HDMI_720X576I_50HZ_16_9:
-	case HDMI_720X480P_60HZ_16_9:
-	case HDMI_720X576P_50HZ_16_9:
-		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
-			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
-		break;
-	default:
-		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
-			colorimetry = AVI_COLORIMETRY_ITU709;
-	}
-
-	if (vpara->colorimetry > HDMI_COLORIMETRY_ITU709) {
-		colorimetry = AVI_COLORIMETRY_EXTENDED;
-		ext_colorimetry = vpara->colorimetry -
-				HDMI_COLORIMETRY_EXTEND_XVYCC_601;
-	} else if (vpara->color_output == HDMI_COLOR_RGB_16_235 ||
-		 vpara->color_output == HDMI_COLOR_RGB_0_255) {
-		colorimetry = AVI_COLORIMETRY_NO_DATA;
-	} else if (vpara->colorimetry != HDMI_COLORIMETRY_NO_DATA) {
-		colorimetry = vpara->colorimetry;
-	}
-
-	hdmi_writel(hdmi_dev, FC_AVICONF1,
-		    v_FC_COLORIMETRY(colorimetry) |
-		    v_FC_PIC_ASPEC_RATIO(aspect_ratio) |
-		    v_FC_ACT_ASPEC_RATIO(ACTIVE_ASPECT_RATE_DEFAULT));
-
-	/* Set AVI infoFrame Data byte3 */
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF2,
-		     m_FC_EXT_COLORIMETRY | m_FC_QUAN_RANGE,
-		     v_FC_EXT_COLORIMETRY(ext_colorimetry) |
-		     v_FC_QUAN_RANGE(rgb_quan_range));
-
-	/* Set AVI infoFrame Data byte4 */
-	if ((vpara->vic > 92 && vpara->vic < 96) ||
-	    (vpara->vic == 98) ||
-	    (vpara->vic & HDMI_VIDEO_DMT) ||
-	    (vpara->vic & HDMI_VIDEO_DISCRETE_VR))
-		hdmi_writel(hdmi_dev, FC_AVIVID, 0);
-	else
-		hdmi_writel(hdmi_dev, FC_AVIVID, vpara->vic & 0xff);
-	/* Set AVI infoFrame Data byte5 */
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF3, m_FC_YQ | m_FC_CN,
-		     v_FC_YQ(YQ_LIMITED_RANGE) | v_FC_CN(CN_GRAPHICS));
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO3, m_AVI_AUTO, v_AVI_AUTO(1));
-}
-
-static int hdmi_dev_config_vsi(struct hdmi *hdmi,
-			       unsigned char vic_3d, unsigned char format)
-{
-	int i = 0, id = 0x000c03;
-	unsigned char data[3] = {0};
-
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "[%s] vic %d format %d.\n", __func__, vic_3d, format);
-
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(0));
-	hdmi_writel(hdmi_dev, FC_VSDIEEEID2, id & 0xff);
-	hdmi_writel(hdmi_dev, FC_VSDIEEEID1, (id >> 8) & 0xff);
-	hdmi_writel(hdmi_dev, FC_VSDIEEEID0, (id >> 16) & 0xff);
-
-	data[0] = format << 5;	/* PB4 --HDMI_Video_Format */
-	switch (format) {
-	case HDMI_VIDEO_FORMAT_4KX2K:
-		data[1] = vic_3d;	/* PB5--HDMI_VIC */
-		data[2] = 0;
-		break;
-	case HDMI_VIDEO_FORMAT_3D:
-		data[1] = vic_3d << 4;	/* PB5--3D_Structure field */
-		data[2] = 0;		/* PB6--3D_Ext_Data field */
-		break;
-	default:
-		data[1] = 0;
-		data[2] = 0;
-		break;
-	}
-
-	for (i = 0; i < 3; i++)
-		hdmi_writel(hdmi_dev, FC_VSDPAYLOAD0 + i, data[i]);
-	hdmi_writel(hdmi_dev, FC_VSDSIZE, 0x6);
-
-	hdmi_writel(hdmi_dev, FC_DATAUTO1, 0);
-	hdmi_writel(hdmi_dev, FC_DATAUTO2, 0x11);
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(1));
-	return 0;
-}
-
-#define HDR_LSB(n) ((n) & 0xff)
-#define HDR_MSB(n) (((n) & 0xff00) >> 8)
-
-static void hdmi_dev_config_hdr(struct hdmi *hdmi,
-				int eotf,
-				struct hdmi_hdr_metadata *hdr)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	/* hdr is supportted after disignid = 0x21 */
-	if (!hdmi_dev || hdmi_readl(hdmi_dev, DESIGN_ID) < 0x21)
-		return;
-
-	hdmi_writel(hdmi_dev, FC_DRM_HB, 1);/*verion = 0x1*/
-	hdmi_writel(hdmi_dev, (FC_DRM_HB + 1), 26);/*length of following data*/
-	hdmi_writel(hdmi_dev, FC_DRM_PB, eotf / 2);
-	hdmi_writel(hdmi_dev, FC_DRM_PB + 1, 0);
-
-	if (hdr) {
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 2, HDR_LSB(hdr->prim_x0));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 3, HDR_MSB(hdr->prim_x0));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 4, HDR_LSB(hdr->prim_y0));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 5, HDR_MSB(hdr->prim_y0));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 6, HDR_LSB(hdr->prim_x1));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 7, HDR_MSB(hdr->prim_x1));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 8, HDR_LSB(hdr->prim_y1));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 9, HDR_MSB(hdr->prim_y1));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 10, HDR_LSB(hdr->prim_x2));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 11, HDR_MSB(hdr->prim_x2));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 12, HDR_LSB(hdr->prim_y2));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 13, HDR_MSB(hdr->prim_y2));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 14, HDR_LSB(hdr->white_px));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 15, HDR_MSB(hdr->white_px));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 16, HDR_LSB(hdr->white_py));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 17, HDR_MSB(hdr->white_py));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 18, HDR_LSB(hdr->max_dml));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 19, HDR_MSB(hdr->max_dml));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 20, HDR_LSB(hdr->min_dml));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 21, HDR_MSB(hdr->min_dml));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 22, HDR_LSB(hdr->max_cll));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 23, HDR_MSB(hdr->max_cll));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 24, HDR_LSB(hdr->max_fall));
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 25, HDR_MSB(hdr->max_fall));
-	} else {
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 1, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 2, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 3, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 4, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 5, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 6, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 7, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 8, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 9, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 10, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 11, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 12, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 13, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 14, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 15, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 16, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 17, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 18, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 19, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 20, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 21, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 22, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 23, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 24, 0);
-		hdmi_writel(hdmi_dev, FC_DRM_PB + 25, 0);
-	}
-	if (eotf) {
-		hdmi_msk_reg(hdmi_dev, FC_PACK_TXE, m_DRM_TXEN, v_DRM_TXEN(1));
-		hdmi_msk_reg(hdmi_dev, FC_MASK2, m_DRM_MASK, v_DRM_MASK(0));
-		hdmi_msk_reg(hdmi_dev, FC_DRM_UP, m_DRM_PUPD, v_DRM_PUPD(1));
-	} else {
-		hdmi_msk_reg(hdmi_dev, FC_PACK_TXE, m_DRM_TXEN, v_DRM_TXEN(0));
-		hdmi_msk_reg(hdmi_dev, FC_MASK2, m_DRM_MASK, v_DRM_MASK(1));
-		hdmi_msk_reg(hdmi_dev, FC_DRM_UP, m_DRM_PUPD, v_DRM_PUPD(1));
-	}
-}
-
-static int hdmi_dev_config_spd(struct hdmi *hdmi, const char *vendor,
-			       const char *product, char deviceinfo)
-{
-	struct hdmi_dev *hdmi_dev;
-	int i, len;
-
-	if (!hdmi || !vendor || !product)
-		return -1;
-	hdmi_dev = hdmi->property->priv;
-
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_SPD_AUTO, v_SPD_AUTO(0));
-	len = strlen(vendor);
-	for (i = 0; i < 8; i++) {
-		if (i < len)
-			hdmi_writel(hdmi_dev, FC_SPDVENDORNAME0 + i,
-				    vendor[i]);
-		else
-			hdmi_writel(hdmi_dev, FC_SPDVENDORNAME0 + i,
-				    0);
-	}
-	len = strlen(product);
-	for (i = 0; i < 16; i++) {
-		if (i < len)
-			hdmi_writel(hdmi_dev, FC_SPDPRODUCTNAME0 + i,
-				    product[i]);
-		else
-			hdmi_writel(hdmi_dev, FC_SPDPRODUCTNAME0 + i,
-				    0);
-	}
-	hdmi_writel(hdmi_dev, FC_SPDDEVICEINF, deviceinfo);
-	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_SPD_AUTO, v_SPD_AUTO(1));
-	return 0;
-}
-
-static int hdmi_dev_config_video(struct hdmi *hdmi, struct hdmi_video *vpara)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "%s vic %d 3dformat %d color mode %d color depth %d\n",
-		__func__, vpara->vic, vpara->format_3d,
-		vpara->color_output, vpara->color_output_depth);
-
-	if (hdmi_dev->soctype == HDMI_SOC_RK3288)
-		vpara->color_input = HDMI_COLOR_RGB_0_255;
-
-	if (!hdmi->uboot) {
-		/* before configure video, we power off phy */
-		if (hdmi_dev->soctype != HDMI_SOC_RK322X) {
-			hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-				     m_PDDQ_SIG | m_TXPWRON_SIG,
-				     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0));
-		} else {
-			hdmi_msk_reg(hdmi_dev, PHY_CONF0,
-				     m_ENHPD_RXSENSE_SIG,
-				     v_ENHPD_RXSENSE_SIG(1));
-			regmap_write(hdmi_dev->grf_base,
-				     RK322X_GRF_SOC_CON2,
-				     RK322X_PLL_POWER_DOWN);
-		}
-		/* force output blue */
-		if (vpara->color_output == HDMI_COLOR_RGB_0_255) {
-			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00);	/*R*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00);	/*G*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x00);	/*B*/
-		} else if (vpara->color_output == HDMI_COLOR_RGB_16_235) {
-			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x10);	/*R*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x10);	/*G*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x10);	/*B*/
-		} else {
-			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x80);	/*Cr*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x10);	/*Y*/
-			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x80);	/*Cb*/
-		}
-		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE,
-			     m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(1));
-		hdmi_writel(hdmi_dev, MC_CLKDIS, m_HDCPCLK_DISABLE);
-	}
-
-	if (rockchip_hdmiv2_video_framecomposer(hdmi, vpara) < 0)
-		return -1;
-
-	if (rockchip_hdmiv2_video_packetizer(hdmi_dev, vpara) < 0)
-		return -1;
-	/* Color space convert */
-	if (rockchip_hdmiv2_video_csc(hdmi_dev, vpara) < 0)
-		return -1;
-	if (rockchip_hdmiv2_video_sampler(hdmi_dev, vpara) < 0)
-		return -1;
-
-	if (vpara->sink_hdmi == OUTPUT_HDMI) {
-		hdmi_dev_config_avi(hdmi, vpara);
-		hdmi_dev_config_spd(hdmi, hdmi_dev->vendor_name,
-				    hdmi_dev->product_name,
-				    hdmi_dev->deviceinfo);
-		if (vpara->format_3d != HDMI_3D_NONE) {
-			hdmi_dev_config_vsi(hdmi,
-					    vpara->format_3d,
-					    HDMI_VIDEO_FORMAT_3D);
-		} else if ((vpara->vic > 92 && vpara->vic < 96) ||
-			 (vpara->vic == 98)) {
-			vpara->vic = (vpara->vic == 98) ?
-				     4 : (96 - vpara->vic);
-			hdmi_dev_config_vsi(hdmi,
-					    vpara->vic,
-					    HDMI_VIDEO_FORMAT_4KX2K);
-		} else {
-			hdmi_dev_config_vsi(hdmi,
-					    vpara->vic,
-					    HDMI_VIDEO_FORMAT_NORMAL);
-		}
-		hdmi_dev_config_hdr(hdmi, vpara->eotf, &hdmi->hdr);
-		dev_info(hdmi->dev, "[%s] success output HDMI.\n", __func__);
-	} else {
-		dev_info(hdmi->dev, "[%s] success output DVI.\n", __func__);
-	}
-
-	if (!hdmi->uboot)
-		rockchip_hdmiv2_config_phy(hdmi_dev);
-	else
-		hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(0));
-	return 0;
-}
-
-static void hdmi_dev_config_aai(struct hdmi_dev *hdmi_dev,
-				struct hdmi_audio *audio)
-{
-	/* Refer to CEA861-E Audio infoFrame
-	 * Set both Audio Channel Count and Audio Coding
-	 * Type Refer to Stream Head for HDMI
-	 */
-	hdmi_msk_reg(hdmi_dev, FC_AUDICONF0,
-		     m_FC_CHN_CNT | m_FC_CODING_TYPE,
-		     v_FC_CHN_CNT(audio->channel - 1) | v_FC_CODING_TYPE(0));
-
-	/* Set both Audio Sample Size and Sample Frequency
-	 * Refer to Stream Head for HDMI
-	 */
-	hdmi_msk_reg(hdmi_dev, FC_AUDICONF1,
-		     m_FC_SAMPLE_SIZE | m_FC_SAMPLE_FREQ,
-		     v_FC_SAMPLE_SIZE(0) | v_FC_SAMPLE_FREQ(0));
-
-	/* Set Channel Allocation */
-	hdmi_writel(hdmi_dev, FC_AUDICONF2, 0x00);
-
-	/* Set LFEPBLDOWN-MIX INH and LSV */
-	hdmi_writel(hdmi_dev, FC_AUDICONF3, 0x00);
-}
-
-static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	int word_length = 0, channel = 0, mclk_fs;
-	unsigned int N = 0, CTS = 0;
-	int rate = 0;
-	char design_id;
-
-	HDMIDBG(2, "%s\n", __func__);
-
-	if (audio->channel < 3)
-		channel = I2S_CHANNEL_1_2;
-	else if (audio->channel < 5)
-		channel = I2S_CHANNEL_3_4;
-	else if (audio->channel < 7)
-		channel = I2S_CHANNEL_5_6;
-	else
-		channel = I2S_CHANNEL_7_8;
-
-	switch (audio->rate) {
-	case HDMI_AUDIO_FS_32000:
-		mclk_fs = FS_128;
-		rate = AUDIO_32K;
-		if (hdmi_dev->tmdsclk >= 594000000)
-			N = N_32K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_32K_MIDCLK;
-		else
-			N = N_32K_LOWCLK;
-		/*div a num to avoid the value is exceed 2^32(int)*/
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 32);
-		break;
-	case HDMI_AUDIO_FS_44100:
-		mclk_fs = FS_128;
-		rate = AUDIO_441K;
-		if (hdmi_dev->tmdsclk >= 594000000)
-			N = N_441K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_441K_MIDCLK;
-		else
-			N = N_441K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 441);
-		break;
-	case HDMI_AUDIO_FS_48000:
-		mclk_fs = FS_128;
-		rate = AUDIO_48K;
-		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
-			N = N_48K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_48K_MIDCLK;
-		else
-			N = N_48K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 48);
-		break;
-	case HDMI_AUDIO_FS_88200:
-		mclk_fs = FS_128;
-		rate = AUDIO_882K;
-		if (hdmi_dev->tmdsclk >= 594000000)
-			N = N_882K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_882K_MIDCLK;
-		else
-			N = N_882K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 882);
-		break;
-	case HDMI_AUDIO_FS_96000:
-		mclk_fs = FS_128;
-		rate = AUDIO_96K;
-		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
-			N = N_96K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_96K_MIDCLK;
-		else
-			N = N_96K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 96);
-		break;
-	case HDMI_AUDIO_FS_176400:
-		mclk_fs = FS_128;
-		rate = AUDIO_1764K;
-		if (hdmi_dev->tmdsclk >= 594000000)
-			N = N_1764K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_1764K_MIDCLK;
-		else
-			N = N_1764K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 1764);
-		break;
-	case HDMI_AUDIO_FS_192000:
-		mclk_fs = FS_128;
-		rate = AUDIO_192K;
-		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
-			N = N_192K_HIGHCLK;
-		else if (hdmi_dev->tmdsclk >= 297000000)
-			N = N_192K_MIDCLK;
-		else
-			N = N_192K_LOWCLK;
-
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 192);
-		break;
-	default:
-		dev_err(hdmi_dev->hdmi->dev,
-			"[%s] not support such sample rate %d\n",
-			__func__, audio->rate);
-		return -ENOENT;
-	}
-
-	switch (audio->word_length) {
-	case HDMI_AUDIO_WORD_LENGTH_16bit:
-		word_length = I2S_16BIT_SAMPLE;
-		break;
-	case HDMI_AUDIO_WORD_LENGTH_20bit:
-		word_length = I2S_20BIT_SAMPLE;
-		break;
-	case HDMI_AUDIO_WORD_LENGTH_24bit:
-		word_length = I2S_24BIT_SAMPLE;
-		break;
-	default:
-		word_length = I2S_16BIT_SAMPLE;
-	}
-
-	HDMIDBG(2, "rate = %d, tmdsclk = %u, N = %d, CTS = %d\n",
-		audio->rate, hdmi_dev->tmdsclk, N, CTS);
-	/* more than 2 channels => layout 1 else layout 0 */
-	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF,
-		     m_AUD_PACK_LAYOUT,
-		     v_AUD_PACK_LAYOUT((audio->channel > 2) ? 1 : 0));
-
-	if (hdmi_dev->audiosrc == HDMI_AUDIO_SRC_SPDIF) {
-		mclk_fs = FS_128;
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
-			     m_I2S_SEL, v_I2S_SEL(AUDIO_SPDIF_GPA));
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIF1,
-			     m_SET_NLPCM | m_SPDIF_WIDTH,
-			     v_SET_NLPCM(PCM_LINEAR) |
-			     v_SPDIF_WIDTH(word_length));
-		/*Mask fifo empty and full int and reset fifo*/
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIFINT,
-			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
-			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIF0,
-			     m_SW_SAUD_FIFO_RST, v_SW_SAUD_FIFO_RST(1));
-	} else {
-		/*Mask fifo empty and full int and reset fifo*/
-		hdmi_msk_reg(hdmi_dev, AUD_INT,
-			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
-			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
-			     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
-		hdmi_writel(hdmi_dev, MC_SWRSTZREQ, 0xF7);
-		design_id = hdmi_readl(hdmi_dev, DESIGN_ID);
-		if (design_id >= 0x21)
-			hdmi_writel(hdmi_dev, AUD_CONF2, 0x4);
-		else
-			hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
-		usleep_range(90, 100);
-		/*
-		 * when we try to use hdmi nlpcm mode
-		 * we should use set AUD_CONF2 to open this route and set
-		 * word_length to 24bit for b.p.c.u.v with 16bit raw data
-		 * when the bitstream data  up to 8 channel, we should use
-		 * the hdmi hbr mode
-		 * HBR Mode : Dolby TrueHD
-		 *            Dolby Atmos
-		 *            DTS-HDMA
-		 * NLPCM Mode :
-		 * FS_32000 FS_44100 FS_48000 : Dolby Digital &  DTS
-		 * FS_176400 FS_192000        : Dolby Digital Plus
-		 */
-		if (audio->type == HDMI_AUDIO_NLPCM) {
-			if (channel == I2S_CHANNEL_7_8) {
-				HDMIDBG(2, "hbr mode.\n");
-				hdmi_writel(hdmi_dev, AUD_CONF2, 0x1);
-				word_length = I2S_24BIT_SAMPLE;
-			} else if ((audio->rate == HDMI_AUDIO_FS_32000) ||
-				   (audio->rate == HDMI_AUDIO_FS_44100) ||
-				   (audio->rate == HDMI_AUDIO_FS_48000) ||
-				   (audio->rate == HDMI_AUDIO_FS_176400) ||
-				   (audio->rate == HDMI_AUDIO_FS_192000)) {
-				HDMIDBG(2, "nlpcm mode.\n");
-				hdmi_writel(hdmi_dev, AUD_CONF2, 0x2);
-				word_length = I2S_24BIT_SAMPLE;
-			} else {
-				hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
-			}
-		} else {
-			if (design_id >= 0x21)
-				hdmi_writel(hdmi_dev, AUD_CONF2, 0x4);
-			else
-				hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
-		}
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
-			     m_I2S_SEL | m_I2S_IN_EN,
-			     v_I2S_SEL(AUDIO_I2S) | v_I2S_IN_EN(channel));
-		hdmi_writel(hdmi_dev, AUD_CONF1,
-			    v_I2S_MODE(I2S_STANDARD_MODE) |
-			    v_I2S_WIDTH(word_length));
-	}
-
-	hdmi_msk_reg(hdmi_dev, AUD_INPUTCLKFS,
-		     m_LFS_FACTOR, v_LFS_FACTOR(mclk_fs));
-
-	/*Set N value*/
-	hdmi_msk_reg(hdmi_dev, AUD_N3, m_NCTS_ATOMIC_WR, v_NCTS_ATOMIC_WR(1));
-	/*Set CTS by manual*/
-	hdmi_msk_reg(hdmi_dev, AUD_CTS3,
-		     m_N_SHIFT | m_CTS_MANUAL | m_AUD_CTS3,
-		     v_N_SHIFT(N_SHIFT_1) |
-		     v_CTS_MANUAL(1) |
-		     v_AUD_CTS3(CTS >> 16));
-	hdmi_writel(hdmi_dev, AUD_CTS2, (CTS >> 8) & 0xff);
-	hdmi_writel(hdmi_dev, AUD_CTS1, CTS & 0xff);
-
-	hdmi_msk_reg(hdmi_dev, AUD_N3, m_AUD_N3, v_AUD_N3(N >> 16));
-	hdmi_writel(hdmi_dev, AUD_N2, (N >> 8) & 0xff);
-	hdmi_writel(hdmi_dev, AUD_N1, N & 0xff);
-
-	/* set channel status register */
-	hdmi_msk_reg(hdmi_dev, FC_AUDSCHNLS7,
-		     m_AUDIO_SAMPLE_RATE, v_AUDIO_SAMPLE_RATE(rate));
-	hdmi_writel(hdmi_dev, FC_AUDSCHNLS8, ((~rate) << 4) | 0x2);
-
-	hdmi_msk_reg(hdmi_dev, AUD_CONF0,
-		     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
-
-	hdmi_dev_config_aai(hdmi_dev, audio);
-
-	return 0;
-}
-
-static int hdmi_dev_control_output(struct hdmi *hdmi, int enable)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-	struct hdmi_video vpara;
-
-	HDMIDBG(2, "[%s] %d\n", __func__, enable);
-	if (enable == HDMI_AV_UNMUTE) {
-		hdmi_writel(hdmi_dev, FC_DBGFORCE, 0x00);
-		if (hdmi->edid.sink_hdmi == OUTPUT_HDMI)
-			hdmi_msk_reg(hdmi_dev, FC_GCP,
-				     m_FC_SET_AVMUTE | m_FC_CLR_AVMUTE,
-				     v_FC_SET_AVMUTE(0) | v_FC_CLR_AVMUTE(1));
-	} else {
-		if (enable & HDMI_VIDEO_MUTE) {
-			hdmi_msk_reg(hdmi_dev, FC_DBGFORCE,
-				     m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(1));
-			if (hdmi->edid.sink_hdmi == OUTPUT_HDMI) {
-				hdmi_msk_reg(hdmi_dev, FC_GCP,
-					     m_FC_SET_AVMUTE |
-					     m_FC_CLR_AVMUTE,
-					     v_FC_SET_AVMUTE(1) |
-					     v_FC_CLR_AVMUTE(0));
-				vpara.vic = hdmi->vic;
-				vpara.color_output = HDMI_COLOR_RGB_0_255;
-				hdmi_dev_config_avi(hdmi, &vpara);
-				while ((!hdmi_readl(hdmi_dev, IH_FC_STAT1)) &
-				       m_AVI_INFOFRAME) {
-					usleep_range(900, 1000);
-				}
-			}
-		}
-/*		if (enable & HDMI_AUDIO_MUTE) {
- *			hdmi_msk_reg(hdmi_dev, FC_AUDSCONF,
- *				     m_AUD_PACK_SAMPFIT,
- *				     v_AUD_PACK_SAMPFIT(0x0F));
- *		}
- */
-		if (enable == (HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE)) {
-			if (hdmi->ops->hdcp_power_off_cb)
-				hdmi->ops->hdcp_power_off_cb(hdmi);
-			rockchip_hdmiv2_powerdown(hdmi_dev);
-		}
-	}
-	return 0;
-}
-
-static int hdmi_dev_insert(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "%s\n", __func__);
-	if (!hdmi->uboot)
-		hdmi_writel(hdmi_dev, MC_CLKDIS, m_HDCPCLK_DISABLE);
-
-	return HDMI_ERROR_SUCCESS;
-}
-
-static int hdmi_dev_remove(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "%s\n", __func__);
-	if (hdmi->ops->hdcp_power_off_cb)
-		hdmi->ops->hdcp_power_off_cb(hdmi);
-	rockchip_hdmiv2_powerdown(hdmi_dev);
-	hdmi_dev->tmdsclk = 0;
-	return HDMI_ERROR_SUCCESS;
-}
-
-static int hdmi_dev_enable(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "%s\n", __func__);
-	if (!hdmi_dev->enable) {
-		hdmi_writel(hdmi_dev, IH_MUTE, 0x00);
-		hdmi_dev->enable = 1;
-	}
-	hdmi_submit_work(hdmi, HDMI_HPD_CHANGE, 10, 0);
-	return 0;
-}
-
-static int hdmi_dev_disable(struct hdmi *hdmi)
-{
-	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
-
-	HDMIDBG(2, "%s\n", __func__);
-	if (hdmi_dev->enable) {
-		hdmi_dev->enable = 0;
-		hdmi_writel(hdmi_dev, IH_MUTE, 0x1);
-	}
-	return 0;
-}
-
-void rockchip_hdmiv2_dev_init_ops(struct hdmi_ops *ops)
-{
-	if (ops) {
-		ops->enable	= hdmi_dev_enable;
-		ops->disable	= hdmi_dev_disable;
-		ops->getstatus	= hdmi_dev_detect_hotplug;
-		ops->insert	= hdmi_dev_insert;
-		ops->remove	= hdmi_dev_remove;
-		ops->getedid	= hdmi_dev_read_edid;
-		ops->setvideo	= hdmi_dev_config_video;
-		ops->setaudio	= hdmi_dev_config_audio;
-		ops->setmute	= hdmi_dev_control_output;
-		ops->setavi	= hdmi_dev_config_avi;
-		ops->setvsi	= hdmi_dev_config_vsi;
-		ops->sethdr	= hdmi_dev_config_hdr;
-	}
-}
-
-void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev)
-{
-	struct hdmi *hdmi = hdmi_dev->hdmi;
-
-	/*lcdc source select*/
-	if (hdmi_dev->soctype == HDMI_SOC_RK3288) {
-		regmap_write(hdmi_dev->grf_base,
-			     RK3288_GRF_SOC_CON6,
-			     HDMI_SEL_LCDC(hdmi->property->videosrc, 4));
-		/* select GPIO7_C0 as cec pin */
-		regmap_write(hdmi_dev->grf_base, RK3288_GRF_SOC_CON8,
-			     BIT(12) | BIT(28));
-	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
-		regmap_write(hdmi_dev->grf_base,
-			     RK3399_GRF_SOC_CON20,
-			     HDMI_SEL_LCDC(hdmi->property->videosrc, 6));
-	}
-
-	if (!hdmi->uboot) {
-		pr_info("reset hdmi\n");
-		if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
-			regmap_write(hdmi_dev->grf_base,
-				     RK322X_GRF_SOC_CON2,
-				     RK322X_DDC_MASK_EN);
-			regmap_write(hdmi_dev->grf_base,
-				     RK322X_GRF_SOC_CON6,
-				     RK322X_IO_3V_DOMAIN);
-		}
-		reset_control_assert(hdmi_dev->reset);
-		usleep_range(10, 20);
-		reset_control_deassert(hdmi_dev->reset);
-		rockchip_hdmiv2_powerdown(hdmi_dev);
-	} else {
-		hdmi->hotplug = hdmi_dev_detect_hotplug(hdmi);
-		if (hdmi->hotplug != HDMI_HPD_ACTIVATED)
-			hdmi->uboot = 0;
-	}
-	/*mute unnecessary interrupt, only enable hpd*/
-	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT1, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT2, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_AS_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_PHY_STAT0, 0xfc);
-	hdmi_writel(hdmi_dev, IH_MUTE_I2CM_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_CEC_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_VP_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_I2CMPHY_STAT0, 0xff);
-	hdmi_writel(hdmi_dev, IH_MUTE_AHBDMAAUD_STAT0, 0xff);
-
-	/* disable hdcp interrupt */
-	hdmi_writel(hdmi_dev, A_APIINTMSK, 0xff);
-	hdmi_writel(hdmi_dev, PHY_MASK, 0xf1);
-
-	if (hdmi->property->feature & SUPPORT_CEC)
-		rockchip_hdmiv2_cec_init(hdmi);
-	if (hdmi->property->feature & SUPPORT_HDCP)
-		rockchip_hdmiv2_hdcp_init(hdmi);
-}
-
-irqreturn_t rockchip_hdmiv2_dev_irq(int irq, void *priv)
-{
-	struct hdmi_dev *hdmi_dev = priv;
-	struct hdmi *hdmi = hdmi_dev->hdmi;
-	char phy_pol = hdmi_readl(hdmi_dev, PHY_POL0);
-	char phy_status = hdmi_readl(hdmi_dev, PHY_STAT0);
-	char phy_int0 = hdmi_readl(hdmi_dev, PHY_INI0);
-	/*read interrupt*/
-	char fc_stat0 = hdmi_readl(hdmi_dev, IH_FC_STAT0);
-	char fc_stat1 = hdmi_readl(hdmi_dev, IH_FC_STAT1);
-	char fc_stat2 = hdmi_readl(hdmi_dev, IH_FC_STAT2);
-	char aud_int = hdmi_readl(hdmi_dev, IH_AS_SATA0);
-	char phy_int = hdmi_readl(hdmi_dev, IH_PHY_STAT0);
-	char vp_stat0 = hdmi_readl(hdmi_dev, IH_VP_STAT0);
-	char cec_int = hdmi_readl(hdmi_dev, IH_CEC_STAT0);
-	char hdcp_int = hdmi_readl(hdmi_dev, A_APIINTSTAT);
-	u8 hdcp2_int = hdmi_readl(hdmi_dev, HDCP2REG_STAT);
-
-	/*clear interrupt*/
-	hdmi_writel(hdmi_dev, IH_FC_STAT0, fc_stat0);
-	hdmi_writel(hdmi_dev, IH_FC_STAT1, fc_stat1);
-	hdmi_writel(hdmi_dev, IH_FC_STAT2, fc_stat2);
-	hdmi_writel(hdmi_dev, IH_VP_STAT0, vp_stat0);
-
-	if (phy_int0 || phy_int) {
-		if ((phy_int0 & m_PHY_LOCK) &&
-		    (phy_pol & m_PHY_LOCK) == 0) {
-			pr_info("hdmi phy pll unlock\n");
-			hdmi_submit_work(hdmi, HDMI_SET_VIDEO, 0, 0);
-		}
-		phy_pol = (phy_int0 & (~phy_status)) | ((~phy_int0) & phy_pol);
-		hdmi_writel(hdmi_dev, PHY_POL0, phy_pol);
-		hdmi_writel(hdmi_dev, IH_PHY_STAT0, phy_int);
-		if ((phy_int & m_HPD) || ((phy_int & 0x3c) == 0x3c))
-			hdmi_submit_work(hdmi, HDMI_HPD_CHANGE, 20, 0);
-	}
-
-	/* Audio error */
-	if (aud_int) {
-		hdmi_writel(hdmi_dev, IH_AS_SATA0, aud_int);
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
-			     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
-		hdmi_writel(hdmi_dev, MC_SWRSTZREQ, 0xF7);
-	}
-	/* CEC */
-	if (cec_int) {
-		hdmi_writel(hdmi_dev, IH_CEC_STAT0, cec_int);
-		if (hdmi_dev->hdmi->property->feature & SUPPORT_CEC)
-			rockchip_hdmiv2_cec_isr(hdmi_dev, cec_int);
-	}
-	/* HDCP */
-	if (hdcp_int) {
-		hdmi_writel(hdmi_dev, A_APIINTCLR, hdcp_int);
-		rockchip_hdmiv2_hdcp_isr(hdmi_dev, hdcp_int);
-	}
-
-	/* HDCP2 */
-	if (hdcp2_int) {
-		hdmi_writel(hdmi_dev, HDCP2REG_STAT, hdcp2_int);
-		pr_info("hdcp2_int is 0x%02x\n", hdcp2_int);
-		if ((hdcp2_int & m_HDCP2_AUTH_FAIL ||
-		     hdcp2_int & m_HDCP2_AUTH_LOST) &&
-		    hdmi_dev->hdcp2_start) {
-			pr_info("hdcp2 failed or lost\n");
-			hdmi_dev->hdcp2_start();
-		}
-	}
-	return IRQ_HANDLED;
-}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
deleted file mode 100644
index 368322b7ebde..000000000000
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
+++ /dev/null
@@ -1,1756 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _RK3288_HDMI_HW_H
-#define _RK3288_HDMI_HW_H
-#include <linux/interrupt.h>
-#include "../rockchip-hdmi.h"
-
-/*#define HDMI_INT_USE_POLL 1*/
-
-enum PWR_MODE {
-	NORMAL,
-	LOWER_PWR,
-};
-
-enum {
-	OUTPUT_DVI = 0,
-	OUTPUT_HDMI,
-};
-
-/* Color Space Conversion Mode */
-enum {
-	CSC_BYPASS,
-	CSC_RGB_0_255_TO_RGB_16_235_8BIT,	/* RGB 0-255 input to RGB
-						 * 16-235 output that is 8bit
-						 * clolor depth
-						 */
-	CSC_RGB_0_255_TO_RGB_16_235_10BIT,	/* RGB 0-255 input to RGB
-						 * 16-235 output that is 8bit
-						 * clolor depth
-						 */
-	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,	/* RGB 0-255 input to YCbCr
-						 * 16-235 output according
-						 * BT601 that is 8bit clolor
-						 * depth
-						 */
-	CSC_RGB_0_255_TO_ITU601_16_235_10BIT,	/* RGB 0-255 input to YCbCr
-						 * 16-235 output according
-						 * BT601 that is 10bit clolor
-						 * depth
-						 */
-	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,	/* RGB 0-255 input to YCbCr
-						 * 16-235 output accroding
-						 * BT709 that is 8bit clolor
-						 * depth
-						 */
-	CSC_RGB_0_255_TO_ITU709_16_235_10BIT,	/* RGB 0-255 input to YCbCr
-						 * 16-235 output accroding
-						 * BT709 that is 10bit clolor
-						 * depth
-						 */
-	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,	/* YCbCr 16-235 input to RGB
-						 * 0-255 output according
-						 * BT601 that is 8bit clolor
-						 * depth
-						 */
-	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,	/* YCbCr 16-235 input to RGB
-						 * 0-255 output according
-						 * BT709 that is 8bit clolor
-						 * depth
-						 */
-	CSC_ITU601_16_235_TO_RGB_16_235_8BIT,	/* YCbCr 16-235 input to RGB
-						 * 16-235 output according
-						 * BT601 that is 8bit clolor
-						 * depth
-						 */
-	CSC_ITU709_16_235_TO_RGB_16_235_8BIT	/* YCbCr 16-235 input to RGB
-						 * 16-235 output according
-						 * BT709 that is 8bit clolor
-						 * depth
-						 */
-};
-
-#define HDMI_SCL_RATE		(100 * 1000)
-#define DDC_I2C_EDID_ADDR	0x50	/* 0xA0/2 = 0x50 */
-#define DDC_I2C_SEG_ADDR	0x30	/* 0x60/2 = 0x30 */
-#define DDC_I2C_SCDC_ADDR	0x54	/* 0xa8/2 = 0x54 */
-
-/* Register and Field Descriptions */
-/* Identification Registers */
-#define IDENTIFICATION_BASE		0x0000
-
-#define DESIGN_ID			0x0000
-#define REVISION_ID			0x0001
-#define PRODUCT_ID0			0x0002
-#define PRODUCT_ID1			0x0003
-
-#define CONFIG0_ID			0x0004
-#define m_PREPEN		BIT(7)
-#define m_AUDSPDIF		BIT(5)
-#define m_AUDI2S		BIT(4)
-#define m_HDMI14		BIT(3)
-#define m_CSC			BIT(2)
-#define m_CEC			BIT(1)
-#define m_HDCP			BIT(0)
-
-#define CONFIG1_ID			0x0005
-#define m_HDCP22		BIT(6)
-#define m_HDMI20		BIT(5)
-#define m_CONFAPB		BIT(1)
-
-#define CONFIG2_ID			0x0006
-enum PHYTYPE {
-	HDMI_TX_PHY = 0x00,
-	HDMI_MHL_WITH_HEAC_PHY = 0xb2,
-	HDMI_MHL_PHY = 0xc2,
-	HDMI_3D_TX_WITH_HEAC_PHY = 0xe2,
-	HDMI_3D_TX_PHY = 0xf2,
-	HDMI2_TX_PHY = 0xf3
-};
-
-#define CONFIG3_ID			0x0007
-#define m_AHB_AUD_DMA		BIT(1)
-#define m_GP_AUD		BIT(0)
-
-/* Interrupt Registers */
-#define INTERRUPT_BASE                  0x0100
-
-#define IH_FC_STAT0			0x0100
-#define m_AUD_INFOFRAME		BIT(7)
-#define m_AUD_CONTENT_PROTECT	BIT(6)
-#define m_AUD_HBR		BIT(5)
-#define m_AUD_SAMPLE		BIT(2)
-#define m_AUD_CLK_REGEN		BIT(1)
-#define m_NULL_PACKET		BIT(0)
-
-#define IH_FC_STAT1			0x0101
-#define m_GMD			BIT(7)
-#define m_ISCR1			BIT(6)
-#define m_ISCR2			BIT(5)
-#define m_VSD			BIT(4)
-#define m_SPD			BIT(3)
-#define m_AVI_INFOFRAME		BIT(1)
-#define m_GCP			BIT(0)
-
-#define v_AVI_INFOFRAME(n)	(((n) & 0x01) << 1)
-
-#define IH_FC_STAT2			0x0102
-#define m_LOWPRIO_OVERFLOW	BIT(1)
-#define m_HIGHPRIO_OVERFLOW	BIT(0)
-
-#define IH_AS_SATA0			0x0103
-#define m_FIFO_UNDERRUN		BIT(4)
-#define m_FIFO_OVERRUN		BIT(3)
-#define m_AUD_FIFO_UDFLOW_THR	BIT(2)
-#define m_AUD_FIFO_UDFLOW	BIT(1)
-#define m_AUD_FIFO_OVERFLOW	BIT(0)
-
-#define IH_PHY_STAT0			0x0104
-#define m_RX_SENSE3		BIT(5)
-#define m_RX_SENSE2		BIT(4)
-#define m_RX_SENSE1		BIT(3)
-#define m_RX_SENSE0		BIT(2)
-#define m_TX_PHY_LOCK		BIT(1)
-#define m_HPD			BIT(0)
-
-#define IH_I2CM_STAT0			0x0105
-#define m_SCDC_READREQ		BIT(2)
-#define m_I2CM_DONE		BIT(1)
-#define m_I2CM_ERROR		BIT(0)
-
-#define IH_CEC_STAT0			0x0106
-#define m_WAKEUP		BIT(6)
-#define m_ERR_FOLLOW		BIT(5)
-#define m_ERR_INITIATOR		BIT(4)
-#define m_ARB_LOST		BIT(3)
-#define m_NACK			BIT(2)
-#define m_EOM			BIT(1)
-#define m_DONE			BIT(0)
-
-#define IH_VP_STAT0			0x0107
-#define m_FIFOFULL_REPET	BIT(7)
-#define m_FIFOEMPTY_REPET	BIT(6)
-#define m_FIFOFULL_PACK		BIT(5)
-#define m_FIFOEMPTY_PACK	BIT(4)
-#define m_FIFOFULL_REMAP	BIT(3)
-#define m_FIFOEMPTY_REMAP	BIT(2)
-#define m_FIFOFULL_BYPASS	BIT(1)
-#define m_FIFOEMPTY_BYPASS	BIT(0)
-
-#define IH_I2CMPHY_STAT0		0x0108
-#define m_I2CMPHY_DONE		BIT(1)
-#define m_I2CMPHY_ERR		BIT(0)
-
-#define IH_AHBDMAAUD_STAT0		0x0109
-#define m_AUDDMA_INT_BUFOVERRUN	BIT(6)
-#define m_AUDDMA_INT_ERR	BIT(5)
-#define m_AUDDMA_INT_LOST	BIT(4)
-#define m_AUDDMA_INT_RETRYSPLIT BIT(3)
-#define m_AUDDMA_INT_DONE	BIT(2)
-#define m_AUDDMA_INT_BUFFULL	BIT(1)
-#define m_AUDDMA_INT_BUFEMPTY	BIT(0)
-
-#define IH_DECODE			0x0170
-#define m_IH_FC_STAT0		BIT(7)
-#define m_IH_FC_STAT1		BIT(6)
-#define m_IH_FC_STAT2_VP	BIT(5)
-#define m_IH_AS_STAT0		BIT(4)
-#define m_IH_PHY		BIT(3)
-#define m_IH_I2CM_STAT0		BIT(2)
-#define m_IH_CEC_STAT0		BIT(1)
-#define m_IH_AHBDMAAUD_STAT0	BIT(0)
-
-#define IH_MUTE_FC_STAT0		0x0180
-#define m_AUDI_MUTE		BIT(7)
-#define m_ACP_MUTE		BIT(6)
-#define m_DST_MUTE		BIT(4)
-#define m_OBA_MUTE		BIT(3)
-#define m_AUDS_MUTE		BIT(2)
-#define m_ACR_MUTE		BIT(1)
-#define m_NULL_MUTE		BIT(0)
-
-#define IH_MUTE_FC_STAT1		0x0181
-#define m_GMD_MUTE		BIT(7)
-#define m_ISCR1_MUTE		BIT(6)
-#define m_ISCR2_MUTE		BIT(5)
-#define m_VSD_MUTE		BIT(4)
-#define m_SPD_MUTE		BIT(3)
-#define m_AVI_MUTE		BIT(1)
-#define m_GCP_MUTE		BIT(0)
-
-#define IH_MUTE_FC_STAT2		0x0182
-#define m_LPRIO_OVERFLOW_MUTE	BIT(1)
-#define m_HPRIO_OVERFLOW_MUTE	BIT(0)
-
-#define IH_MUTE_AS_STAT0		0x0183
-#define m_FIFO_UNDERRUN_MUTE	BIT(4)
-#define m_FIFO_OVERRUN_MUTE	BIT(3)
-#define m_AUD_FIFO_UDF_THR_MUTE	BIT(2)
-#define m_AUD_FIFO_UDF_MUTE	BIT(1)
-#define m_AUD_FIFO_OVF_MUTE	BIT(0)
-
-#define IH_MUTE_PHY_STAT0		0x0184
-#define m_RX_SENSE3_MUTE	BIT(5)
-#define m_RX_SENSE2_MUTE	BIT(4)
-#define m_RX_SENSE1_MUTE	BIT(3)
-#define m_RX_SENSE0_MUTE	BIT(2)
-#define m_TX_PHY_LOCK_MUTE	BIT(1)
-#define m_HPD_MUTE		BIT(0)
-
-#define IH_MUTE_I2CM_STAT0		0x0185
-#define m_SCDC_READREQ_MUTE	BIT(2)
-#define v_SCDC_READREQ_MUTE(n)	(((n) & 0x01) << 2)
-#define m_I2CM_DONE_MUTE	BIT(1)
-#define v_I2CM_DONE_MUTE(n)	(((n) & 0x01) << 1)
-#define m_I2CM_ERR_MUTE		BIT(0)
-#define v_I2CM_ERR_MUTE(n)	(((n) & 0x01) << 0)
-
-#define IH_MUTE_CEC_STAT0		0x0186
-#define m_WAKEUP_MUTE		BIT(6)
-#define m_ERR_FOLLOW_MUTE	BIT(5)
-#define m_ERR_INITIATOR_MUTE	BIT(4)
-#define m_ARB_LOST_MUTE		BIT(3)
-#define m_NACK_MUTE		BIT(2)
-#define m_EOM_MUTE		BIT(1)
-#define m_DONE_MUTE		BIT(0)
-
-#define IH_MUTE_VP_STAT0		0x0187
-#define m_FIFOFULL_REP_MUTE	BIT(7)
-#define m_FIFOEMPTY_REP_MUTE	BIT(6)
-#define m_FIFOFULL_PACK_MUTE	BIT(5)
-#define m_FIFOEMPTY_PACK_MUTE	BIT(4)
-#define m_FIFOFULL_REMAP_MUTE	BIT(3)
-#define m_FIFOEMPTY_REMAP_MUTE	BIT(2)
-#define m_FIFOFULL_BYP_MUTE	BIT(1)
-#define m_FIFOEMPTY_BYP_MUTE	BIT(0)
-
-#define IH_MUTE_I2CMPHY_STAT0		0x0188
-#define m_I2CMPHY_DONE_MUTE	BIT(1)
-#define m_I2CMPHY_ERR_MUTE	BIT(0)
-
-#define IH_MUTE_AHBDMAAUD_STAT0		0x0189
-#define IH_MUTE				0x01ff
-
-/* Video Sampler Registers */
-#define VIDEO_SAMPLER_BASE		0x0200
-
-#define TX_INVID0			0x0200
-#define m_INTERNAL_DE_GEN	BIT(7)
-#define v_INTERNAL_DE_GEN(n)	(((n) & 0x01) << 7)
-enum VIDEO_MODE {
-	VIDEO_RGB444_8BIT = 0x01,
-	VIDEO_RGB444_10BIT = 0x03,
-	VIDEO_RGB444_12BIT = 0x05,
-	VIDEO_RGB444_16BIT = 0x07,
-	VIDEO_YCBCR444_8BIT = 0x09,	/* or YCbCr420 */
-	VIDEO_YCBCR444_10BIT = 0x0b,	/* or YCbCr420 */
-	VIDEO_YCBCR444_12BIT = 0x0d,	/* or YCbCr420 */
-	VIDEO_YCBCR444_16BIT = 0x0f,	/* or YCbCr420 */
-	VIDEO_YCBCR422_12BIT = 0x12,
-	VIDEO_YCBCR422_10BIT = 0x14,
-	VIDEO_YCBCR422_8BIT = 0x16
-};
-
-#define m_VIDEO_MAPPING		(0x1f << 0)
-#define v_VIDEO_MAPPING(n)	((n) & 0x1f)
-
-#define TX_INSTUFFING			0x0201
-#define m_BCBDATA_STUFF		BIT(2)
-#define v_BCBDATA_STUFF(n)	(((n) & 0x01) << 2)
-#define m_RCRDATA_STUFF		BIT(1)
-#define v_RCRDATA_STUFF(n)	(((n) & 0x01) << 1)
-#define m_GYDATA_STUFF		BIT(0)
-#define v_GYDATA_STUFF(n)	(((n) & 0x01) << 0)
-
-#define TX_GYDATA0			0x0202
-#define TX_GYDATA1			0x0203
-#define TX_RCRDATA0			0x0204
-#define TX_RCRDATA1			0x0205
-#define TX_BCBDATA0			0x0206
-#define TX_BCBDATA1			0x0207
-
-/* Video Packetizer Registers */
-#define VIDEO_PACKETIZER_BASE		0x0800
-
-#define VP_STATUS			0x0800
-#define m_PACKING_PHASE		(0x0f << 0)
-
-#define VP_PR_CD			0x0801
-enum COLOR_DEPTH {
-	COLOR_DEPTH_24BIT_DEFAULT = 0,
-	COLOR_DEPTH_24BIT = 0x04,
-	COLOR_DEPTH_30BIT,
-	COLOR_DEPTH_36BIT,
-	COLOR_DEPTH_48BIT
-};
-
-#define m_COLOR_DEPTH		(0x0f << 4)
-#define v_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
-enum PIXEL_REPET {
-	NO_PIXEL_REPET = 0,
-	PIXEL_SENT_2TIMES,
-	PIXEL_SENT_3TIMES,
-	PIXEL_SENT_4TIMES,
-	PIXEL_SENT_5TIMES,
-	PIXEL_SENT_6TIMES,
-	PIXEL_SENT_7TIMES,
-	PIXEL_SENT_8TIMES,
-	PIXEL_SENT_9TIMES,
-	PIXEL_SENT_10TIMES
-};
-
-#define m_DESIRED_PR_FACTOR	(0x0f << 0)
-#define v_DESIRED_PR_FACTOR(n)	(((n) & 0x0f) << 0)
-
-#define VP_STUFF			0x0802
-#define m_IDEFAULT_PHASE	BIT(5)
-#define v_IDEFAULT_PHASE(n)	(((n) & 0x01) << 5)
-#define m_IFIX_PP_TO_LAST	BIT(4)
-#define m_ICX_GOTO_P0_ST	BIT(3)
-enum {
-	DIRECT_MODE = 0,
-	STUFFING_MODE
-};
-
-#define m_YCC422_STUFFING	BIT(2)
-#define v_YCC422_STUFFING(n)	(((n) & 0x01) << 2)
-#define m_PP_STUFFING		BIT(1)
-#define v_PP_STUFFING(n)	(((n) & 0x01) << 1)
-#define m_PR_STUFFING		BIT(0)
-#define v_PR_STUFFING(n)	(((n) & 0x01) << 0)
-
-#define VP_REMAP			0x0803
-enum YCC422_SIZE {
-	YCC422_16BIT = 0,
-	YCC422_20BIT,
-	YCC422_24BIT
-};
-
-#define m_YCC422_SIZE		(0x03 << 0)
-#define v_YCC422_SIZE(n)	(((n) & 0x03) << 0)
-
-#define VP_CONF				0x0804
-#define m_BYPASS_EN		BIT(6)
-#define v_BYPASS_EN(n)		(((n) & 0x01) << 6)
-#define m_PIXEL_PACK_EN		BIT(5)
-#define v_PIXEL_PACK_EN(n)	(((n) & 0x01) << 5)
-#define m_PIXEL_REPET_EN	BIT(4)
-#define v_PIXEL_REPET_EN(n)	(((n) & 0x01) << 4)
-#define m_YCC422_EN		BIT(3)
-#define v_YCC422_EN(n)		(((n) & 0x01) << 3)
-#define m_BYPASS_SEL		BIT(2)
-#define v_BYPASS_SEL(n)		(((n) & 0x01) << 2)
-enum {
-	OUT_FROM_PIXEL_PACKING = 0,
-	OUT_FROM_YCC422_REMAP,
-	OUT_FROM_8BIT_BYPASS
-};
-
-#define m_OUTPUT_SEL		(0x03 << 0)
-#define v_OUTPUT_SEL(n)		(((n) & 0x03) << 0)
-
-#define VP_MASK				0x0807
-#define m_OINTFULL_REPET	BIT(7)
-#define m_OINTEMPTY_REPET	BIT(6)
-#define m_OINTFULL_PACK		BIT(5)
-#define m_OINTEMPTY_PACK	BIT(4)
-#define m_OINTFULL_REMAP	BIT(3)
-#define m_OINTEMPTY_REMAP	BIT(2)
-#define m_OINTFULL_BYPASS	BIT(1)
-#define m_OINTEMPTY_BYPASS	BIT(0)
-
-/* Frame Composer Registers */
-#define FRAME_COMPOSER_BASE		0x1000
-
-#define	FC_INVIDCONF			0x1000
-#define m_FC_HDCP_KEEPOUT	BIT(7)
-#define v_FC_HDCP_KEEPOUT(n)	(((n) & 0x01) << 7)
-#define m_FC_VSYNC_POL		BIT(6)
-#define v_FC_VSYNC_POL(n)	(((n) & 0x01) << 6)
-#define m_FC_HSYNC_POL		BIT(5)
-#define v_FC_HSYNC_POL(n)	(((n) & 0x01) << 5)
-#define m_FC_DE_POL		BIT(4)
-#define v_FC_DE_POL(n)		(((n) & 0x01) << 4)
-#define m_FC_HDMI_DVI		BIT(3)
-#define v_FC_HDMI_DVI(n)	(((n) & 0x01) << 3)
-#define m_FC_VBLANK		BIT(1)
-#define v_FC_VBLANK(n)		(((n) & 0x01) << 1)
-#define m_FC_INTERLACE_MODE	BIT(0)
-#define v_FC_INTERLACE_MODE(n)	(((n) & 0x01) << 0)
-
-#define	FC_INHACTIV0			0x1001
-
-#define	FC_INHACTIV1			0x1002
-#define v_FC_HACTIVE1(n)	((n) & 0x3f)
-#define m_FC_H_ACTIVE_13	BIT(5)
-#define v_FC_H_ACTIVE_13(n)	(((n) & 0x01) << 5)
-#define m_FC_H_ACTIVE_12	BIT(4)
-#define v_FC_H_ACTIVE_12(n)	(((n) & 0x01) << 4)
-#define m_FC_H_ACTIVE		(0x0f << 0)
-#define v_FC_H_ACTIVE(n)	(((n) & 0x0f) << 0)
-
-#define	FC_INHBLANK0			0x1003
-
-#define	FC_INHBLANK1			0x1004
-#define v_FC_HBLANK1(n)		((n) & 0x1f)
-#define m_FC_H_BLANK_12_11	(0x07 << 2)
-#define v_FC_H_BLANK_12_11(n)	(((n) & 0x07) << 2)
-#define m_FC_H_BLANK		(0x03 << 0)
-#define v_FC_H_BLANK(n)		(((n) & 0x03) << 0)
-
-#define	FC_INVACTIV0			0x1005
-
-#define	FC_INVACTIV1			0x1006
-#define v_FC_VACTIVE1(n)	((n) & 0x1f)
-#define m_FC_V_ACTIVE_12_11	(0x03 << 3)
-#define v_FC_V_ACTIVE_12_11(n)	(((n) & 0x03) << 3)
-#define m_FC_V_ACTIVE		(0x07 << 0)
-#define v_FC_V_ACTIVE(n)	(((n) & 0x07) << 0)
-
-#define	FC_INVBLANK			0x1007
-#define	FC_HSYNCINDELAY0		0x1008
-
-#define	FC_HSYNCINDELAY1		0x1009
-#define v_FC_HSYNCINDEAY1(n)	((n) & 0x1f)
-#define m_FC_H_SYNCFP_12_11	(0x03 << 3)
-#define v_FC_H_SYNCFP_12_11(n)	(((n) & 0x03) << 3)
-#define m_FC_H_SYNCFP		(0x07 << 0)
-#define v_FC_H_SYNCFP(n)	(((n) & 0x07) << 0)
-
-#define	FC_HSYNCINWIDTH0		0x100a
-
-#define	FC_HSYNCINWIDTH1		0x100b
-#define v_FC_HSYNCWIDTH1(n)	((n) & 0x03)
-#define m_FC_HSYNC_9		BIT(1)
-#define v_FC_HSYNC_9(n)		(((n) & 0x01) << 1)
-#define m_FC_HSYNC		BIT(0)
-#define v_FC_HSYNC(n)		(((n) & 0x01) << 0)
-
-#define	FC_VSYNCINDELAY			0x100c
-#define	FC_VSYNCINWIDTH			0x100d
-#define	FC_INFREQ0			0x100e
-#define	FC_INFREQ1			0x100f
-#define	FC_INFREQ2			0x1010
-#define	FC_CTRLDUR			0x1011
-#define	FC_EXCTRLDUR			0x1012
-#define	FC_EXCTRLSPAC			0x1013
-#define	FC_CH0PREAM			0x1014
-#define	FC_CH1PREAM			0x1015
-#define	FC_CH2PREAM			0x1016
-
-#define	FC_AVICONF3			0x1017
-enum YCC_QUAN_RANGE {
-	YQ_LIMITED_RANGE = 0,
-	YQ_FULL_RANGE,
-	RESERVED,
-};
-
-#define m_FC_YQ			(0x03 << 2)
-#define v_FC_YQ(n)		(((n) & 0x03) << 2)
-enum IT_CONTENT_TYPE {
-	CN_GRAPHICS = 0,
-	CN_PHOTO,
-	CN_CINEMA,
-	CN_GAME,
-};
-
-#define m_FC_CN			(0x03 << 0)
-#define v_FC_CN(n)		(((n) & 0x03) << 0)
-
-#define	FC_GCP				0x1018
-#define m_FC_DEFAULT_PHASE	BIT(2)
-#define v_FC_DEFAULT_PHASE(n)	(((n) & 0x01) << 2)
-#define m_FC_SET_AVMUTE		BIT(1)
-#define v_FC_SET_AVMUTE(n)	(((n) & 0x01) << 1)
-#define m_FC_CLR_AVMUTE		BIT(0)
-#define v_FC_CLR_AVMUTE(n)	(((n) & 0x01) << 0)
-
-enum {
-	AVI_COLOR_MODE_RGB = 0,
-	AVI_COLOR_MODE_YCBCR422,
-	AVI_COLOR_MODE_YCBCR444,
-	AVI_COLOR_MODE_YCBCR420
-};
-
-enum {
-	AVI_COLORIMETRY_NO_DATA = 0,
-	AVI_COLORIMETRY_SMPTE_170M,
-	AVI_COLORIMETRY_ITU709,
-	AVI_COLORIMETRY_EXTENDED
-};
-
-enum {
-	AVI_CODED_FRAME_ASPECT_NO_DATA,
-	AVI_CODED_FRAME_ASPECT_4_3,
-	AVI_CODED_FRAME_ASPECT_16_9
-};
-
-enum {
-	ACTIVE_ASPECT_RATE_DEFAULT = 0x08,
-	ACTIVE_ASPECT_RATE_4_3,
-	ACTIVE_ASPECT_RATE_16_9,
-	ACTIVE_ASPECT_RATE_14_9
-};
-
-enum {
-	AVI_QUANTIZATION_RANGE_DEFAULT = 0,
-	AVI_QUANTIZATION_RANGE_LIMITED,
-	AVI_QUANTIZATION_RANGE_FULL
-};
-
-#define	FC_AVICONF0			0x1019
-#define m_FC_RGC_YCC_2		BIT(7)	/* use for HDMI2.0 TX */
-#define v_FC_RGC_YCC_2(n)	(((n) & 0x01) << 7)
-#define m_FC_ACTIV_FORMAT	BIT(6)
-#define v_FC_ACTIV_FORMAT(n)	(((n) & 0x01) << 6)
-#define m_FC_SCAN_INFO		(0x03 << 4)
-#define v_FC_SCAN_INFO(n)	(((n) & 0x03) << 4)
-#define m_FC_BAR_FORMAT		(0x03 << 2)
-#define v_FC_BAR_FORMAT(n)	(((n) & 0x03) << 2)
-#define m_FC_RGC_YCC		(0x03 << 0)
-#define v_FC_RGC_YCC(n)		(((n) & 0x03) << 0)
-
-#define	FC_AVICONF1			0x101a
-#define m_FC_COLORIMETRY	(0x03 << 6)
-#define v_FC_COLORIMETRY(n)	(((n) & 0x03) << 6)
-#define m_FC_PIC_ASPEC_RATIO	(0x03 << 4)
-#define v_FC_PIC_ASPEC_RATIO(n)	(((n) & 0x03) << 4)
-#define m_FC_ACT_ASPEC_RATIO	(0x0f << 0)
-#define v_FC_ACT_ASPEC_RATIO(n)	(((n) & 0x0f) << 0)
-
-#define	FC_AVICONF2			0x101b
-#define m_FC_IT_CONTENT		BIT(7)
-#define v_FC_IT_CONTENT(n)	(((n) & 0x01) << 7)
-#define m_FC_EXT_COLORIMETRY	(0x07 << 4)
-#define v_FC_EXT_COLORIMETRY(n)	(((n) & 0x07) << 4)
-#define m_FC_QUAN_RANGE		(0x03 << 2)
-#define v_FC_QUAN_RANGE(n)	(((n) & 0x03) << 2)
-#define m_FC_NUN_PIC_SCALE	(0x03 << 0)
-#define v_FC_NUN_PIC_SCALE(n)	(((n) & 0x03) << 0)
-
-#define	FC_AVIVID			0x101c
-#define m_FC_AVIVID_H		BIT(7)	/* use for HDMI2.0 TX */
-#define v_FC_AVIVID_H(n)	(((n) & 0x01) << 7)
-#define m_FC_AVIVID		(0x7f << 0)
-#define v_FC_AVIVID(n)		(((n) & 0x7f) << 0)
-
-#define	FC_AVIETB0			0x101d
-#define	FC_AVIETB1			0x101e
-#define	FC_AVISBB0			0x101f
-#define	FC_AVISBB1			0x1020
-#define	FC_AVIELB0			0x1021
-#define	FC_AVIELB1			0x1022
-#define	FC_AVISRB0			0x1023
-#define	FC_AVISRB1			0x1024
-
-#define	FC_AUDICONF0			0x1025
-#define m_FC_CHN_CNT		(0x07 << 4)
-#define v_FC_CHN_CNT(n)		(((n) & 0x07) << 4)
-#define m_FC_CODING_TYPE	(0x0f << 0)
-#define v_FC_CODING_TYPE(n)	(((n) & 0x0f) << 0)
-
-#define	FC_AUDICONF1			0x1026
-#define m_FC_SAMPLE_SIZE	(0x03 << 4)
-#define v_FC_SAMPLE_SIZE(n)	(((n) & 0x03) << 4)
-#define m_FC_SAMPLE_FREQ	(0x07 << 0)
-#define v_FC_SAMPLE_FREQ(n)	(((n) & 0x07) << 0)
-
-#define	FC_AUDICONF2			0x1027
-
-#define	FC_AUDICONF3			0x1028
-#define m_FC_LFE_PBL		(0x03 << 5)	/*only use for HDMI1.4 TX*/
-#define v_FC_LFE_PBL(n)		(((n) & 0x03) << 5)
-#define m_FC_DM_INH		BIT(4)
-#define v_FC_DM_INH(n)		(((n) & 0x01) << 4)
-#define m_FC_LSV		(0x0f << 0)
-#define v_FC_LSV(n)		(((n) & 0x0f) << 0)
-
-#define	FC_VSDIEEEID2			0x1029
-#define	FC_VSDSIZE			0x102a
-#define	FC_VSDIEEEID1			0x1030
-#define	FC_VSDIEEEID0			0x1031
-#define	FC_VSDPAYLOAD0			0x1032	/* 0~23 */
-#define	FC_SPDVENDORNAME0		0x104a	/* 0~7 */
-#define	FC_SPDPRODUCTNAME0		0x1052	/* 0~15 */
-#define	FC_SPDDEVICEINF			0x1062
-
-#define	FC_AUDSCONF			0x1063
-#define m_AUD_PACK_SAMPFIT	(0x0f << 4)
-#define v_AUD_PACK_SAMPFIT(n)	(((n) & 0x0f) << 4)
-#define m_AUD_PACK_LAYOUT	BIT(0)
-#define v_AUD_PACK_LAYOUT(n)	(((n) & 0x01) << 0)
-
-#define	FC_AUDSSTAT			0x1064
-#define	FC_AUDSV			0x1065
-#define	FC_AUDSU			0x1066
-#define	FC_AUDSCHNLS0			0x1067	/*0~8*/
-#define	FC_AUDSCHNLS1			0x1068
-#define	FC_AUDSCHNLS2			0x1069
-#define	FC_AUDSCHNLS3			0x106a
-#define	FC_AUDSCHNLS4			0x106b
-#define	FC_AUDSCHNLS5			0x106c
-#define	FC_AUDSCHNLS6			0x106d
-#define	FC_AUDSCHNLS7			0x106e
-#define	FC_AUDSCHNLS8			0x106f
-
-enum {
-	AUDIO_32K	= 0x3,
-	AUDIO_441K	= 0x0,
-	AUDIO_48K	= 0x2,
-	AUDIO_882K	= 0x8,
-	AUDIO_96K	= 0xa,
-	AUDIO_1764K	= 0xc,
-	AUDIO_192K	= 0xe,
-	AUDIO_768K	= 0x9,
-};
-
-#define m_AUDIO_SAMPLE_RATE		(0x0f << 0)
-#define v_AUDIO_SAMPLE_RATE(n)	(((n) & 0x0f) << 0)
-#define m_AUDIO_ORI_SAMPLE_RATE		(0x0f << 4)
-#define v_AUDIO_ORI_SAMPLE_RATE(n)	(((~(n)) & 0x0f) << 4)
-
-#define m_AUDIO_WORD_LENGTH		(0x0f << 0)
-#define v_AUDIO_WORD_LENGTH(n)	(((n) & 0x0f) << 0)
-
-#define	FC_CTRLQHIGH			0x1073
-#define	FC_CTRLQLOW			0x1074
-#define	FC_ACP0				0x1075
-#define	FC_ACP16			0x1082	/* 16~1 */
-#define	FC_ISCR1_0			0x1092
-#define	FC_ISCR1_16			0x1093	/* 16~1 */
-#define	FC_ISCR2_15			0x10a3	/* 15~0 */
-
-#define	FC_DATAUTO0			0x10b3
-#define m_SPD_AUTO		BIT(4)
-#define v_SPD_AUTO(n)		(((n) & 0x01) << 4)
-#define m_VSD_AUTO		BIT(3)
-#define v_VSD_AUTO(n)		(((n) & 0x01) << 3)
-#define m_ISCR2_AUTO		BIT(2)
-#define v_ISCR2_AUTO(n)		(((n) & 0x01) << 2)
-#define m_ISCR1_AUTO		BIT(1)
-#define v_ISCR1_AUTO(n)		(((n) & 0x01) << 1)
-#define m_ACP_AUTO		BIT(0)
-#define v_ACP_AUTO(n)		(((n) & 0x01) << 0)
-
-#define	FC_DATAUTO1			0x10b4
-#define	FC_DATAUTO2			0x10b5
-
-#define	FC_DATMAN			0x10b6
-#define m_SPD_MAN		BIT(4)
-#define v_SPD_MAN(n)		(((n) & 0x01) << 4)
-#define m_VSD_MAN		BIT(3)
-#define v_VSD_MAN(n)		(((n) & 0x01) << 3)
-#define m_ISCR2_MAN		BIT(2)
-#define v_ISCR2_MAN(n)		(((n) & 0x01) << 2)
-#define m_ISCR1_MAN		BIT(1)
-#define v_ISCR1_MAN(n)		(((n) & 0x01) << 1)
-#define m_ACP_MAN		BIT(0)
-#define v_ACP_MAN(n)		(((n) & 0x01) << 0)
-
-#define	FC_DATAUTO3			0x10b7
-	#define m_AVI_AUTO		BIT(3)
-	#define v_AVI_AUTO(n)		(((n) & 0x01) << 3)
-	#define m_GCP_AUTO		BIT(2)
-	#define v_GCP_AUTO(n)		(((n) & 0x01) << 2)
-	#define m_AAI_AUTO		BIT(1)
-	#define v_AAI_AUTO(n)		(((n) & 0x01) << 1)
-	#define m_ACR_AUTO		BIT(0)
-	#define v_ACR_AUTO(n)		(((n) & 0x01) << 0)
-#define	FC_RDRB0			0x10b8
-#define	FC_RDRB1			0x10b9
-#define	FC_RDRB2			0x10ba
-#define	FC_RDRB3			0x10bb
-#define	FC_RDRB4			0x10bc
-#define	FC_RDRB5			0x10bd
-#define	FC_RDRB6			0x10be
-#define	FC_RDRB7			0x10bf
-	#define m_AVI_PACKETS_PER_FRAME		(0xf << 4)
-	#define m_AVI_PACKERS_LINE_SPACING	(0xf)
-	#define v_AVI_PACKETS_PER_FRAME(n)	(((n) & 0x0f) << 4)
-	#define v_AVI_PACKERS_LINE_SPACING(n)	(((n) & 0x0f) << 0)
-#define	FC_MASK0			0x10d2
-#define	FC_MASK1			0x10d6
-#define	FC_MASK2			0x10da
-
-#define	FC_PRCONF			0x10e0
-#define m_FC_PR_FACTOR		(0x0f << 4)
-#define v_FC_PR_FACTOR(n)	(((n) & 0x0f) << 4)
-#define m_FC_PR_FACTOR_OUT	(0x0f)
-#define v_FC_PR_FACTOR_OUT(n)	((n) & 0x0f)
-
-#define	FC_SCRAMBLER_CTRL		0x10e1
-#define m_FC_SCRAMBLE_UCP	BIT(4)
-#define v_FC_SCRAMBLE_UCP(n)	(((n) & 0x01) << 4)
-#define m_FC_SCRAMBLE_EN	BIT(0)
-#define v_FC_SCRAMBLE_EN(n)	(((n) & 0x01) << 0)
-
-#define	FC_GMD_STAT			0x1100
-#define	FC_GMD_EN			0x1101
-#define	FC_GMD_UP			0x1102
-#define	FC_GMD_CONF			0x1103
-#define	FC_GMD_HB			0x1104
-#define	FC_GMD_PB0			0x1105	/*0~27*/
-
-#define	FC_PACK_TXE			0x10e3
-	#define m_DRM_TXEN		BIT(7)
-	#define v_DRM_TXEN(n)		(((n) & 0x01) << 7)
-#define FC_DRM_UP			0x1167
-	#define m_DRM_PUPD		BIT(0)
-	#define v_DRM_PUPD(n)		(((n) & 0x01) << 0)
-#define FC_DRM_HB			0x1168
-#define FC_DRM_PB			0x116a
-#define m_DRM_MASK			BIT(4)
-#define v_DRM_MASK(n)			(((n) & 0x01) << 4)
-
-#define FC_DBGFORCE			0x1200
-#define m_FC_FORCEAUDIO		BIT(4)
-#define v_FC_FORCEAUDIO(n)	(((n) & 0x01) << 4)
-#define m_FC_FORCEVIDEO		BIT(0)
-#define v_FC_FORCEVIDEO(n)	(((n) & 0x01) << 0)
-
-#define	FC_DBGAUD0CH0			0x1201	/* aud0~aud2 ch0 */
-#define	FC_DBGAUD0CH1			0x1204	/* aud0~aud2 ch1 */
-#define	FC_DBGAUD0CH2			0x1207	/* aud0~aud2 ch2 */
-#define	FC_DBGAUD0CH3			0x120a	/* aud0~aud2 ch3 */
-#define	FC_DBGAUD0CH4			0x120d	/* aud0~aud2 ch4 */
-#define	FC_DBGAUD0CH5			0x1210	/* aud0~aud2 ch5 */
-#define	FC_DBGAUD0CH6			0x1213	/* aud0~aud2 ch6 */
-#define	FC_DBGAUD0CH7			0x1216	/* aud0~aud2 ch7 */
-#define	FC_DBGTMDS0			0x1219
-#define	FC_DBGTMDS1			0x121a
-#define	FC_DBGTMDS2			0x121b
-
-/* HDMI Source PHY Registers */
-#define HDMI_SOURCE_PHY_BASE		0x3000
-
-#define PHY_CONF0			0x3000
-#define m_POWER_DOWN_EN		BIT(7)/* no use */
-#define v_POWER_DOWN_EN(n)	(((n) & 0x01) << 7)
-#define m_TMDS_EN		BIT(6)/* no use */
-#define v_TMDS_EN(n)		(((n) & 0x01) << 6)
-#define	m_SVSRET_SIG		BIT(5)/* depend on PHY_MHL_COMB0=1 */
-#define v_SVSRET_SIG(n)		(((n) & 0x01) << 5)
-#define m_PDDQ_SIG		BIT(4)
-/*1: power down phy; 0: power on phy */
-#define v_PDDQ_SIG(n)		(((n) & 0x01) << 4)
-#define m_TXPWRON_SIG		BIT(3)
-/*1: power on transmitter; 0: power down transmitter */
-#define v_TXPWRON_SIG(n)	(((n) & 0x01) << 3)
-#define m_ENHPD_RXSENSE_SIG	BIT(2)
-/*1: enable detect hdp & rx sense */
-#define v_ENHPD_RXSENSE_SIG(n)	(((n) & 0x01) << 2)
-#define m_SEL_DATAEN_POL	BIT(1)
-#define v_SEL_DATAEN_POL(n)	(((n) & 0x01) << 1)
-#define m_SEL_INTERFACE		BIT(0)
-#define v_SEL_INTERFACE(n)	(((n) & 0x01) << 0)
-
-#define PHY_TST0			0x3001
-#define m_TEST_CLR_SIG		BIT(5)
-#define m_TEST_EN_SIG		BIT(4)
-#define m_TEST_CLK_SIG		BIT(0)
-
-#define PHY_TST1			0x3002
-#define PHY_TST2			0x3003
-#define PHY_STAT0			0x3004
-#define PHY_INI0			0x3005
-#define PHY_MASK			0x3006
-#define PHY_POL0			0x3007
-#define m_PHY_RX_SENSE3		BIT(7)
-#define v_PHY_TX_SENSE3(n)	(((n) & 0x01) << 7)
-#define m_PHY_RX_SENSE2		BIT(6)
-#define v_PHY_TX_SENSE2(n)      (((n) & 0x01) << 6)
-#define m_PHY_RX_SENSE1		BIT(5)
-#define v_PHY_TX_SENSE1(n)      (((n) & 0x01) << 5)
-#define m_PHY_RX_SENSE0		BIT(4)
-#define v_PHY_TX_SENSE0(n)      (((n) & 0x01) << 4)
-#define m_PHY_HPD		BIT(1)
-#define v_PHY_HPD		(((n) & 0x01) << 1)
-#define m_PHY_LOCK		BIT(0)
-#define v_PHY_LOCK(n)		(((n) & 0x01) << 0)
-
-#define PHY_PCLFREQ0			0x3008
-#define PHY_PCLFREQ1			0x3009
-#define PHY_PLLCFGFREQ0			0x300a
-#define PHY_PLLCFGFREQ1			0x300b
-#define PHY_PLLCFGFREQ2			0x300c
-
-/* I2C Master PHY Registers */
-#define I2C_MASTER_PHY_BASE		0x3020
-
-#define	PHY_I2CM_SLAVE			0x3020
-#define PHY_GEN2_ADDR		0x69
-#define PHY_HEAC_ADDR		0x49
-#define PHY_I2C_SLAVE_ADDR	0x54
-
-#define	PHY_I2CM_ADDRESS		0x3021
-#define	PHY_I2CM_DATAO_1		0x3022
-#define	PHY_I2CM_DATAO_0		0x3023
-#define	PHY_I2CM_DATAI_1		0x3024
-#define	PHY_I2CM_DATAI_0		0x3025
-
-#define	PHY_I2CM_OPERATION		0x3026
-#define m_PHY_I2CM_WRITE	BIT(4)
-#define m_PHY_I2CM_READ		BIT(0)
-
-#define	PHY_I2CM_INT			0x3027
-#define m_PHY_I2CM_DONE_INT_POL	BIT(3)
-#define v_PHY_I2CM_DONE_INT_POL(n) (((n) & 0x01) << 3)
-#define m_PHY_I2CM_DONE_MASK	BIT(2)
-#define v_PHY_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
-#define m_PHY_I2CM_DONE_INT	BIT(1)
-#define m_PHY_I2CM_DONE_STATUS	BIT(0)
-
-#define	PHY_I2CM_CTLINT			0x3028
-#define m_PHY_I2CM_NACK_POL	BIT(7)
-#define v_PHY_I2CM_NACK_POL(n)	(((n) & 0x01) << 7)
-#define m_PHY_I2CM_NACK_MASK	BIT(6)
-#define v_PHY_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
-#define m_PHY_I2CM_NACK_INT	BIT(5)
-#define m_PHY_I2CM_NACK_STATUS	BIT(4)
-#define m_PHY_I2CM_ARB_POL	BIT(3)
-#define v_PHY_I2CM_ARB_POL(n)	(((n) & 0x01) << 3)
-#define m_PHY_I2CM_ARB_MASK	BIT(2)
-#define v_PHY_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
-#define m_PHY_I2CM_ARB_INT	BIT(1)
-#define m_PHY_I2CM_ARB_STATUS	BIT(0)
-
-#define	PHY_I2CM_DIV			0x3029
-#define m_PHY_I2CM_FAST_STD	BIT(3)
-#define v_PHY_I2CM_FAST_STD(n)	(((n) & 0x01) << 3)
-
-#define	PHY_I2CM_SOFTRSTZ		0x302a
-#define m_PHY_I2CM_SOFTRST	BIT(0)
-#define v_PHY_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
-
-#define	PHY_I2CM_SS_SCL_HCNT_1_ADDR	0x302b
-#define	PHY_I2CM_SS_SCL_HCNT_0_ADDR	0x302c
-#define	PHY_I2CM_SS_SCL_LCNT_1_ADDR	0x302d
-#define	PHY_I2CM_SS_SCL_LCNT_0_ADDR	0x302e
-#define	PHY_I2CM_FS_SCL_HCNT_1_ADDR	0x302f
-#define	PHY_I2CM_FS_SCL_HCNT_0_ADDR	0x3030
-#define	PHY_I2CM_FS_SCL_LCNT_1_ADDR	0x3031
-#define	PHY_I2CM_FS_SCL_LCNT_0_ADDR	0x3032
-#define	PHY_I2CM_SDA_HOLD		0x3033
-
-/* Audio Sampler Registers */
-#define AUDIO_SAMPLER_BASE		0x3100
-
-#define AUD_CONF0			0x3100
-#define m_SW_AUD_FIFO_RST	BIT(7)
-#define v_SW_AUD_FIFO_RST(n)	(((n) & 0x01) << 7)
-enum {
-	AUDIO_SPDIF_GPA = 0,
-	AUDIO_I2S
-};
-
-#define m_I2S_SEL		BIT(5)
-#define v_I2S_SEL(n)		(((n) & 0x01) << 5)
-enum {
-	I2S_CHANNEL_1_2 = 1,
-	I2S_CHANNEL_3_4 = 3,
-	I2S_CHANNEL_5_6 = 7,
-	I2S_CHANNEL_7_8 = 0xf
-};
-
-#define m_I2S_IN_EN		(0x0f << 0)
-#define v_I2S_IN_EN(n)		(((n) & 0x0f) << 0)
-
-#define AUD_CONF1			0x3101
-enum I2S_MODE {
-	I2S_STANDARD_MODE = 0,
-	I2S_RIGHT_JUSTIFIED_MODE,
-	I2S_LEFT_JUSTIFIED_MODE,
-	I2S_BURST_1_MODE,
-	I2S_BURST_2_MODE
-};
-
-#define m_I2S_MODE		(0x07 << 5)
-#define v_I2S_MODE(n)		(((n) & 0x07) << 5)
-enum I2S_WIDTH {
-	I2S_16BIT_SAMPLE = 16,
-	I2S_17BIT_SAMPLE,
-	I2S_18BIT_SAMPLE,
-	I2S_19BIT_SAMPLE,
-	I2S_20BIT_SAMPLE,
-	I2S_21BIT_SAMPLE,
-	I2S_22BIT_SAMPLE,
-	I2S_23BIT_SAMPLE,
-	I2S_24BIT_SAMPLE,
-};
-
-#define m_I2S_WIDTH		(0x1f << 0)
-#define v_I2S_WIDTH(n)		(((n) & 0x1f) << 0)
-
-#define AUD_INT				0x3102
-#define AUD_SPDIFINT			0x3302
-#define m_FIFO_EMPTY_MASK	BIT(3)
-#define v_FIFO_EMPTY_MASK(n)	(((n) & 0x01) << 3)
-#define m_FIFO_FULL_MASK	BIT(2)
-#define v_FIFO_FULL_MASK(n)	(((n) & 0x01) << 2)
-
-#define AUD_CONF2			0x3103
-#define m_NLPCM_EN		BIT(1)
-#define v_NLPCM_EN(n)		(((n) & 0x01) << 1)
-#define m_HBR_EN		BIT(0)
-#define v_HBR_EN(n)		(((n) & 0x01) << 0)
-
-#define AUD_INT1			0x3104
-#define AUD_SPDIFINT1			0x3303
-#define m_FIFO_OVERRUN_MASK	BIT(4)
-#define v_FIFO_OVERRUN_MASK(n)	(((n) & 0x01) << 4)
-
-/***************N-CTS Table**************/
-/*	TMDS LOWCLK:	<=148.5M	*/
-/*	TMDS MIDCLK:	297M		*/
-/*	TMDS HIGHCLK:	594M		*/
-#define N_32K_LOWCLK		0x1000
-#define N_32K_MIDCLK		0x0c00
-#define N_32K_HIGHCLK		0x0c00
-#define N_441K_LOWCLK		0x1880
-#define N_441K_MIDCLK		0x1260
-#define N_441K_HIGHCLK		0x24c0
-#define N_48K_LOWCLK		0x1800
-#define N_48K_MIDCLK		0x1400
-#define N_48K_HIGHCLK		0x1800
-#define N_882K_LOWCLK		0x3100
-#define N_882K_MIDCLK		0x24c0
-#define N_882K_HIGHCLK		0x4980
-#define N_96K_LOWCLK		0x3000
-#define N_96K_MIDCLK		0x2800
-#define N_96K_HIGHCLK		0x3000
-#define N_1764K_LOWCLK		0x6200
-#define N_1764K_MIDCLK		0x4980
-#define N_1764K_HIGHCLK		0x9300
-#define N_192K_LOWCLK		0x6000
-#define N_192K_MIDCLK		0x5000
-#define N_192K_HIGHCLK		0x6000
-
-#define CALC_CTS(N, TMDSCLK, FS)	(((N) / 32) * (TMDSCLK) / ((FS) * 4))
-/****************************************/
-
-#define AUD_N1				0x3200
-#define AUD_N2				0x3201
-
-#define AUD_N3				0x3202
-#define m_NCTS_ATOMIC_WR	BIT(7)
-#define v_NCTS_ATOMIC_WR(n)	(((n) & 0x01) << 7)
-#define m_AUD_N3		(0x0f << 0)
-#define v_AUD_N3(n)		(((n) & 0x0f) << 0)
-
-#define AUD_CTS1			0x3203
-#define AUD_CTS2			0x3204
-
-#define AUD_CTS3			0x3205
-enum {
-	N_SHIFT_1 = 0,
-	N_SHIFT_16,
-	N_SHIFT_32,
-	N_SHIFT_64,
-	N_SHIFT_128,
-	N_SHIFT_256,
-	N_SHIFT_OTHERS_128
-};
-
-#define m_N_SHIFT		(0x07 << 5)
-#define v_N_SHIFT(n)		(((n) & 0x07) << 5)
-#define m_CTS_MANUAL		BIT(4)
-#define v_CTS_MANUAL(n)		(((n) & 0x01) << 4)
-#define m_AUD_CTS3		(0x0f << 0)
-#define v_AUD_CTS3(n)		(((n) & 0x0f) << 0)
-
-#define AUD_INPUTCLKFS			0x3206
-enum {
-	FS_128 = 0,
-	FS_256,
-	FS_512,
-	FS_64 = 4,
-	FS_OTHERS_128
-};
-
-#define m_LFS_FACTOR		(0x07 << 0)
-#define v_LFS_FACTOR(n)		(((n) & 0x07) << 0)
-
-#define AUD_SPDIF0			0x3300
-#define m_SW_SAUD_FIFO_RST	BIT(7)
-#define v_SW_SAUD_FIFO_RST(n)	(((n) & 0x01) << 7)
-
-#define AUD_SPDIF1			0x3301
-enum {
-	PCM_LINEAR = 0,
-	PCM_NONLINEAR
-};
-
-#define m_SET_NLPCM		BIT(7)
-#define v_SET_NLPCM(n)		(((n) & 0x01) << 7)
-#define m_SPDIF_HBR_MODE	BIT(6)
-#define v_SPDIF_HBR_MODE(n)	(((n) & 0x01) << 6)
-#define m_SPDIF_WIDTH		(0x1f << 0)
-#define v_SPDIF_WIDTH(n)	(((n) & 0x1f) << 0)
-
-/* Generic Parallel Audio Interface Registers */
-#define GP_AUDIO_INTERFACE_BASE		0x3500
-
-#define	GP_CONF0			0x3500
-#define	GP_CONF1			0x3501
-#define	GP_CONF2			0x3502
-#define	GP_MASK				0x3506
-
-/* Audio DMA Registers */
-#define AUDIO_DMA_BASE			0x3600
-
-#define	AHB_DMA_CONF0			0x3600
-#define	AHB_DMA_START			0x3601
-#define	AHB_DMA_STOP			0x3602
-#define	AHB_DMA_THRSLD			0x3603
-#define	AHB_DMA_STRADDR_SET0_0		0x3604	/* 0~3 */
-#define	AHB_DMA_STPADDR_SET0_0		0x3608	/* 0~3 */
-#define	AHB_DMA_BSTADDR0		0x360c	/* 0~3 */
-#define	AHB_DMA_MBLENGTH0		0x3610	/* 0~3 */
-#define	AHB_DMA_MASK			0x3614
-#define	AHB_DMA_CONF1			0x3616
-#define	AHB_DMA_BUFFMASK		0x3619
-#define	AHB_DMA_MASK1			0x361b
-#define	AHB_DMA_STATUS			0x361c
-#define	AHB_DMA_CONF2			0x361d
-#define	AHB_DMA_STRADDR_SET1_0		0x3620	/* 0~3 */
-#define	AHB_DMA_STPADDR_SET1_0		0x3624	/* 0~3 */
-
-/* Main Controller Registers */
-#define MAIN_CONTROLLER_BASE		0x4000
-
-#define MC_CLKDIS			0x4001
-#define m_HDCPCLK_DISABLE	BIT(6)
-#define v_HDCPCLK_DISABLE(n)	(((n) & 0x01) << 6)
-#define m_CECCLK_DISABLE	BIT(5)
-#define v_CECCLK_DISABLE(n)	(((n) & 0x01) << 5)
-#define m_CSCCLK_DISABLE	BIT(4)
-#define v_CSCCLK_DISABLE(n)	(((n) & 0x01) << 4)
-#define m_AUDCLK_DISABLE        BIT(3)
-#define v_AUDCLK_DISABLE(n)     (((n) & 0x01) << 3)
-#define m_PREPCLK_DISABLE	BIT(2)
-#define v_PREPCLK_DISABLE(n)	(((n) & 0x01) << 2)
-#define m_TMDSCLK_DISABLE	BIT(1)
-#define v_TMDSCLK_DISABLE(n)	(((n) & 0x01) << 1)
-#define m_PIXELCLK_DISABLE	BIT(0)
-#define v_PIXELCLK_DISABLE(n)	(((n) & 0x01) << 0)
-
-#define MC_SWRSTZREQ			0x4002
-#define m_IGPA_SWRST		BIT(7)
-#define v_IGPA_SWRST(n)		(((n) & 0x01) << 7)
-#define m_CEC_SWRST		BIT(6)
-#define v_CEC_SWRST(n)		(((n) & 0x01) << 6)
-#define m_ISPDIF_SWRST          BIT(4)
-#define v_ISPDIF_SWRST(n)       (((n) & 0x01) << 4)
-#define m_II2S_SWRST            BIT(3)
-#define v_II2S_SWRST(n)         (((n) & 0x01) << 3)
-#define m_PREP_SWRST            BIT(2)
-#define v_PREP_SWRST(n)         (((n) & 0x01) << 2)
-#define m_TMDS_SWRST		BIT(1)
-#define v_TMDS_SWRST(n)		(((n) & 0x01) << 1)
-#define m_PIXEL_SWRST           BIT(0)
-#define v_PIXEL_SWRST(n)        (((n) & 0x01) << 0)
-
-#define MC_OPCTRL			0x4003
-#define m_HDCP_BLOCK_BYP	BIT(0)
-#define v_HDCP_BLOCK_BYP(n)	(((n) & 0x01) << 0)
-
-#define MC_FLOWCTRL			0x4004
-#define m_FEED_THROUGH_OFF      BIT(0)
-#define v_FEED_THROUGH_OFF(n)   (((n) & 0x01) << 0)
-
-#define MC_PHYRSTZ			0x4005
-#define m_PHY_RSTZ		BIT(0)
-#define v_PHY_RSTZ(n)		(((n) & 0x01) << 0)
-
-#define MC_LOCKONCLOCK			0x4006
-#define m_IGPACLK_ON		BIT(7)
-#define v_IGPACLK_ON(n)		(((n) & 0x01) << 7)
-#define m_PCLK_ON		BIT(6)
-#define v_PCLK_ON(n)		(((n) & 0x01) << 6)
-#define m_TMDSCLK_ON            BIT(5)
-#define v_TMDSCLK_ON(n)         (((n) & 0x01) << 5)
-#define m_PREPCLK_ON            BIT(4)
-#define v_PREPCLK_ON(n)         (((n) & 0x01) << 4)
-#define m_I2SCLK_ON		BIT(3)
-#define v_I2SCLK_ON(n)		(((n) & 0x01) << 3)
-#define m_SPDIFCLK_ON           BIT(2)
-#define v_SPDIFCLK_ON(n)	(((n) & 0x01) << 2)
-#define m_CECCLK_ON		BIT(0)
-#define v_CECCLK_ON(n)		(((n) & 0x01) << 0)
-
-#define MC_HEACPHY_RST			0x4007
-#define m_HEAC_PHY_RST		BIT(0)
-#define v_HEAC_PHY_RST(n)	(((n) & 0x01) << 0)
-
-#define MC_LOCKONCLOCK_2		0x4009
-#define m_AHB_AUD_DMA_CLK       BIT(0)
-#define v_AHB_AUD_DMA_CLK(n)    (((n) & 0x01) << 0)
-
-#define MC_SWRSTZREQ_2			0x400a
-#define m_AHB_AUD_DMA_RST       BIT(7)
-#define v_AHB_AUD_DMA_RST(n)    (((n) & 0x01) << 7)
-
-/* Color Space Converter Registers */
-#define COLOR_SPACE_CONVERTER_BASE	0x4100
-
-#define	CSC_CFG				0x4100
-#define m_CSC_INTPMODE		(0x03 << 4)
-#define v_CSC_INTPMODE(n)	(((n) & 0x03) << 4)
-#define m_CSC_DECIMODE		(0x03 << 0)
-#define v_CSC_DECIMODE(n)	(((n) & 0x03) << 0)
-
-#define	CSC_SCALE			0x4101
-#define m_CSC_COLOR_DEPTH	(0x0f << 4)
-#define v_CSC_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
-#define m_CSC_SCALE		(0x03 << 0)
-#define v_CSC_SCALE(n)		(((n) & 0x03) << 0)
-
-#define	CSC_COEF_A1_MSB			0x4102
-#define	CSC_COEF_A1_LSB			0x4103
-#define	CSC_COEF_A2_MSB			0x4104
-#define	CSC_COEF_A2_LSB			0x4105
-#define	CSC_COEF_A3_MSB			0x4106
-#define	CSC_COEF_A3_LSB			0x4107
-#define	CSC_COEF_A4_MSB			0x4108
-#define	CSC_COEF_A4_LSB			0x4109
-#define	CSC_COEF_B1_MSB			0x410a
-#define	CSC_COEF_B1_LSB			0x410b
-#define	CSC_COEF_B2_MSB			0x410c
-#define	CSC_COEF_B2_LSB			0x410d
-#define	CSC_COEF_B3_MSB			0x410e
-#define	CSC_COEF_B3_LSB			0x410f
-#define	CSC_COEF_B4_MSB			0x4110
-#define	CSC_COEF_B4_LSB			0x4111
-#define	CSC_COEF_C1_MSB			0x4112
-#define	CSC_COEF_C1_LSB			0x4113
-#define	CSC_COEF_C2_MSB			0x4114
-#define	CSC_COEF_C2_LSB			0x4115
-#define	CSC_COEF_C3_MSB			0x4116
-#define	CSC_COEF_C3_LSB			0x4117
-#define	CSC_COEF_C4_MSB			0x4118
-#define	CSC_COEF_C4_LSB			0x4119
-#define	CSC_SPARE_1			0x411a
-#define	CSC_SPARE_2			0x411b
-
-/* HDCP Encryption Engine Registers */
-#define HDCP_ENCRYPTION_ENGINE_BASE	0x5000
-
-#define	A_HDCPCFG0			0x5000
-#define m_HDCP_ENHANCE_LIKE	BIT(7)
-#define v_HDCP_ENHANCE_LIKE(n)	(((n) & 0x01) << 7)
-#define m_I2C_FAST_MODE		BIT(6)
-#define v_I2C_FAST_MODE(n)	(((n) & 0x01) << 6)
-#define m_ENCRYPT_BYPASS	BIT(5)
-#define v_ENCRYPT_BYPASS(n)	(((n) & 0x01) << 5)
-#define m_SYNC_RI_CHECK		BIT(4)
-#define v_SYNC_RI_CHECK(n)	(((n) & 0x01) << 4)
-#define m_AVMUTE		BIT(3)
-#define m_RX_DETECT		BIT(2)
-#define v_RX_DETECT(n)		(((n) & 0x01) << 2)
-#define m_FEATURE11_EN		BIT(1)
-#define v_FEATURE11_EN(n)	(((n) & 0x01) << 1)
-#define m_HDMI_DVI		BIT(0)
-#define v_HDMI_DVI(n)		(((n) & 0x01) << 0)
-
-#define	A_HDCPCFG1			0x5001
-#define m_HDCP_LOCK		BIT(4)
-#define v_HDCP_LOCK(n)		(((n) & 0x01) << 4)
-#define m_SHA1_CHECK_DISABLE	BIT(3)
-#define v_SHA1_CHECK_DISBALE(n)	(((n) & 0x01) << 3)
-#define m_PH2UPSHFTENC		BIT(2)
-#define v_PH2UPSHFTENC(n)	(((n) & 0x01) << 2)
-#define m_ENCRYPT_DISBALE	BIT(1)
-#define v_ENCRYPT_DISBALE(n)	(((n) & 0x01) << 1)
-#define m_HDCP_SW_RST		BIT(0)
-#define v_HDCP_SW_RST(n)	(((n) & 0x01) << 0)
-
-#define	A_HDCPOBS0			0x5002
-#define m_STATE_AUTH		(0x0f << 4)
-#define m_SUB_STATE_AUTH	(0x07 << 1)
-#define m_STATE_HDCP_ENGAGED	BIT(0)
-
-#define	A_HDCPOBS1			0x5003
-#define m_STATE_OESS		(0x07 << 3)
-#define m_STATE_REVO		(0x07 << 0)
-
-#define	A_HDCPOBS2			0x5004
-#define m_STATE_CIPHER		(0x07 << 3)
-#define m_STATE_EESS		(0x07 << 0)
-
-#define	A_HDCPOBS3			0x5005
-#define m_BCAP_REPEATER		BIT(6)
-#define m_BCAP_KSVFIFO_READY	BIT(5)
-#define m_BCAP_FAST_I2C		BIT(4)
-#define m_BCAP_HDMI_MODE	BIT(2)
-#define m_BCAP_FEATURES11	BIT(1)
-#define m_BCAP_FAST_REAUTH	BIT(0)
-
-#define	A_APIINTCLR			0x5006
-#define	A_APIINTSTAT			0x5007
-#define	A_APIINTMSK			0x5008
-#define m_HDCP_ENGAGED		BIT(7)
-#define m_HDCP_FAILED		BIT(6)
-#define m_HDCP_I2C_NOACK	BIT(4)
-#define m_HDCP_LOST_ARBI	BIT(3)
-#define m_KEEP_ERR_INT		BIT(2)
-#define m_KSVSHA1_CALC_INT	BIT(1)
-#define m_KSV_ACCESS_INT	BIT(0)
-#define v_HDCP_ENGAGED(n)	(((n) & 0x01) << 7)
-#define v_HDCP_FAILED(n)	(((n) & 0x01) << 6)
-#define v_HDCP_I2C_NOACK(n)	(((n) & 0x01) << 4)
-#define v_HDCP_LOST_ARBI(n)	(((n) & 0x01) << 3)
-#define v_KEEP_ERR_INT(n)	(((n) & 0x01) << 1)
-#define v_KSVSHA1_CALC_INT(n)	(((n) & 0x01) << 1)
-#define v_KSV_ACCESS_INT(n)	(((n) & 0x01) << 0)
-
-#define	A_VIDPOLCFG			0x5009
-#define m_UNENCRYT_CONF		(0x03 << 5)
-#define v_UNENCRYT_CONF(n)	(((n) & 0x03) << 5)
-#define m_DATAEN_POL		BIT(4)
-#define v_DATAEN_POL(n)		(((n) & 0x01) << 4)
-#define m_VSYNC_POL		BIT(3)
-#define v_VSYNC_POL(n)		(((n) & 0x01) << 3)
-#define m_HSYNC_POL		BIT(1)
-#define v_HSYNC_POL(n)		(((n) & 0x01) << 1)
-
-#define	A_OESSWCFG			0x500a
-#define	A_COREVERLSB			0x5014
-#define	A_COREVERMSB			0x5015
-
-#define	A_KSVMEMCTRL			0x5016
-#define m_SHA1_FAIL		BIT(3)
-#define v_SHA1_FAIL(n)		(((n) & 0x01) << 3)
-#define m_KSV_UPDATE		BIT(2)
-#define v_KSV_UPDATE(n)		(((n) & 0x01) << 2)
-#define m_KSV_MEM_ACCESS	BIT(1)
-#define m_KSV_MEM_REQ		BIT(0)
-#define v_KSV_MEM_REQ(n)	(((n) & 0x01) << 0)
-
-#define	HDCP_BSTATUS_0			0x5020
-#define m_MAX_DEVS_EXCEEDED	BIT(7)
-#define m_DEVICE_COUNT		(0x7f << 0)
-
-#define	HDCP_BSTATUS_1			0x5021
-#define	HDCP_M0_0			0x5022
-#define	HDCP_M0_1			0x5023
-#define	HDCP_M0_2			0x5024
-#define	HDCP_M0_3			0x5025
-#define	HDCP_M0_4			0x5026
-#define	HDCP_M0_5			0x5027
-#define	HDCP_M0_6			0x5028
-#define	HDCP_M0_7			0x5029
-#define	HDCP_KSV			0x502a	/* 0~634 */
-#define	HDCP_VH				0x52a5	/* 0~19 */
-#define	HDCP_REVOC_SIZE_0		0x52b9
-#define	HDCP_REVOC_SIZE_1		0x52ba
-#define	HDCP_REVOC_LIST			0x52bb	/* 0~5059 */
-
-/* HDCP BKSV Registers */
-#define HDCP_BKSV_BASE			0x7800
-
-#define	HDCPREG_BKSV0			0x7800
-#define	HDCPREG_BKSV1			0x7801
-#define	HDCPREG_BKSV2			0x7802
-#define	HDCPREG_BKSV3			0x7803
-#define	HDCPREG_BKSV4			0x7804
-
-/* HDCP AN Registers */
-#define HDCP_AN_BASE			0x7805
-
-#define	HDCPREG_ANCONF			0x7805
-#define m_OAN_BYPASS		BIT(0)
-#define v_OAN_BYPASS(n)		(((n) & 0x01) << 0)
-
-#define	HDCPREG_AN0			0x7806
-#define	HDCPREG_AN1			0x7807
-#define	HDCPREG_AN2			0x7808
-#define	HDCPREG_AN3			0x7809
-#define	HDCPREG_AN4			0x780a
-#define	HDCPREG_AN5			0x780b
-#define	HDCPREG_AN6			0x780c
-#define	HDCPREG_AN7			0x780d
-
-/* Encrypted DPK Embedded Storage Registers */
-#define ENCRYPTED_DPK_EMBEDDED_BASE	0x780e
-
-#define	HDCPREG_RMCTL			0x780e
-#define m_DPK_DECRYPT_EN	BIT(0)
-#define v_DPK_DECRYPT_EN(n)	(((n) & 0x01) << 0)
-
-#define	HDCPREG_RMSTS			0x780f
-#define m_DPK_WR_OK_STS		BIT(6)
-#define m_DPK_DATA_INDEX	(0x3f << 6)
-
-#define	HDCPREG_SEED0			0x7810
-#define	HDCPREG_SEED1			0x7811
-#define	HDCPREG_DPK0			0x7812
-#define	HDCPREG_DPK1			0x7813
-#define	HDCPREG_DPK2			0x7814
-#define	HDCPREG_DPK3			0x7815
-#define	HDCPREG_DPK4			0x7816
-#define	HDCPREG_DPK5			0x7817
-#define	HDCPREG_DPK6			0x7818
-
-#define HDCP2REG_BASE			0x7900
-#define HDCP2REG_ID			0x7900
-#define HDCP2REG_CTRL			0x7904
-	#define m_HDCP2_HDP_OVR_VAL	BIT(5)
-	#define m_HDCP2_HDP_OVR_EN	BIT(4)
-	#define m_HDCP2_FORCE		BIT(2)
-	#define m_HDCP2_OVR_EN		BIT(1)
-	#define m_HDCP2_SWITCH_EN	BIT(0)
-
-	#define v_HDCP2_HDP_OVR_VAL(n)	(((n) & 0x01) << 5)
-	#define v_HDCP2_HDP_OVR_EN(n)	(((n) & 0x01) << 4)
-	#define v_HDCP2_FORCE(n)	(((n) & 0x01) << 2)
-	#define v_HDCP2_OVR_EN(n)	(((n) & 0x01) << 1)
-	#define v_HDCP2_SWITCH_EN(n)	(((n) & 0x01) << 0)
-#define HDCP2REG_CTRL1			0x7905
-	#define m_HDCP2_CD_VAL		(0xf << 4)
-	#define m_HDCP2_CD_EN		BIT(3)
-	#define m_HDCP2_AVMUTE_OVR_VAL	BIT(1)
-	#define m_HDCP2_AVMUTE_OVR_EN	BIT(0)
-
-	#define v_HDCP2_CD_VAL(n)		(((n) & 0x0f) << 4)
-	#define v_HDCP2_CD_EN(n)		(((n) & 0x01) << 3)
-	#define v_HDCP2_AVMUTE_OVR_VAL(n)	(((n) & 0x01) << 1)
-	#define v_HDCP2_AVMUTE_OVR_EN(n)	(((n) & 0x01) << 0)
-#define HDCP2REG_STAS			0x7908
-#define HDCP2REG_MASK			0x790c
-#define HDCP2REG_STAT			0x790d
-#define HDCP2REG_MUTE			0x790e
-	#define m_HDCP2_CAPABLE		BIT(0)
-	#define m_HDCP2_NOTCAPABLE	BIT(1)
-	#define m_HDCP2_AUTH_LOST	BIT(2)
-	#define m_HDCP2_AUTH_OK		BIT(3)
-	#define m_HDCP2_AUTH_FAIL	BIT(4)
-	#define m_HDCP2_DECRYPTED_CHG	BIT(5)
-
-/* CEC Engine Registers */
-#define CEC_ENGINE_BASE			0x7d00
-
-#define	CEC_CTRL			0x7d00
-	#define m_CEC_BC_S_NCK		BIT(5)	 /* Ignore ack of sending
-						  * broadcast message.
-						  */
-	#define m_CEC_STANBY		BIT(4)
-	#define m_CEC_BC_NCK		BIT(3)
-	#define m_CEC_FRAME_TYPE	(3 << 1)
-	#define m_CEC_SEND		BIT(0)
-	#define v_CEC_BC_S_NCK(n)	(((n) & 0x1) << 4)
-	#define v_CEC_STANBY(n)		((n & 0x1) << 4)
-	#define v_CEC_BC_NCK(n)		((n & 0x1) << 3)
-	#define v_CEC_FRAME_TYPE(n)	((n & 0x3) << 1)
-	#define v_CEC_SEND(n)		(n & 0x1)
-#define	CEC_MASK			0x7d02
-#define	CEC_ADDR_L			0x7d05
-#define	CEC_ADDR_H			0x7d06
-#define	CEC_TX_CNT			0x7d07
-#define	CEC_RX_CNT			0x7d08
-#define	CEC_TX_DATA0			0x7d10	/* txdata0~txdata15 */
-#define	CEC_RX_DATA0			0x7d20	/* rxdata0~rxdata15 */
-#define CEC_LOCK			0x7d30
-#define	CEC_WKUPCTRL			0x7d31
-
-/* I2C Master Registers */
-#define I2C_MASTER_BASE			0x7e00
-
-#define	I2CM_SLAVE			0x7e00
-#define	I2CM_ADDRESS			0x7e01
-#define	I2CM_DATAO			0x7e02
-#define	I2CM_DATAI			0x7e03
-
-#define I2CM_OPERATION			0x7e04
-#define m_I2CM_WR		BIT(4)
-#define v_I2CM_WR(n)		(((n) & 0x01) << 4)
-#define m_I2CM_RD8_EXT		BIT(3)
-#define v_I2CM_RD8_EXT(n)	(((n) & 0x01) << 3)
-#define m_I2CM_RD8		BIT(2)
-#define v_I2CM_RD8(n)		(((n) & 0x01) << 2)
-#define m_I2CM_RD_EXT		BIT(1)
-#define v_I2CM_RD_EXT(n)	(((n) & 0x01) << 1)
-#define m_I2CM_RD		BIT(0)
-#define v_I2CM_RD(n)		(((n) & 0x01) << 0)
-
-#define	I2CM_INT			0x7e05
-#define m_I2CM_RD_REQ_MASK	BIT(6)
-#define v_I2CM_RD_REQ_MASK(n)	(((n) & 0x01) << 6)
-#define m_I2CM_DONE_MASK	BIT(2)
-#define v_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
-
-#define	I2CM_CTLINT			0x7e06
-#define m_I2CM_NACK_MASK	BIT(6)
-#define v_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
-#define m_I2CM_ARB_MASK		BIT(2)
-#define v_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
-
-#define	I2CM_DIV			0x7e07
-enum {
-	STANDARD_MODE = 0,
-	FAST_MODE
-};
-
-#define m_I2CM_FAST_STD_MODE	BIT(3)
-#define v_I2CM_FAST_STD_MODE(n)	(((n) & 0x01) << 3)
-
-#define	I2CM_SEGADDR			0x7e08
-#define m_I2CM_SEG_ADDR		(0x7f << 0)
-#define v_I2CM_SEG_ADDR(n)	(((n) & 0x7f) << 0)
-
-#define	I2CM_SOFTRSTZ			0x7e09
-#define m_I2CM_SOFTRST		BIT(0)
-#define v_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
-
-#define	I2CM_SEGPTR			0x7e0a
-#define	I2CM_SS_SCL_HCNT_1_ADDR		0x7e0b
-#define	I2CM_SS_SCL_HCNT_0_ADDR		0x7e0c
-#define	I2CM_SS_SCL_LCNT_1_ADDR		0x7e0d
-#define	I2CM_SS_SCL_LCNT_0_ADDR		0x7e0e
-#define	I2CM_FS_SCL_HCNT_1_ADDR		0x7e0f
-#define	I2CM_FS_SCL_HCNT_0_ADDR		0x7e10
-#define	I2CM_FS_SCL_LCNT_1_ADDR		0x7e11
-#define	I2CM_FS_SCL_LCNT_0_ADDR		0x7e12
-#define	I2CM_SDA_HOLD			0x7e13
-
-#define	I2CM_SCDC_READ_UPDATE		0x7e14
-#define m_I2CM_UPRD_VSYNC_EN	BIT(5)
-#define v_I2CM_UPRD_VSYNC_EN(n) (((n) & 0x01) << 5)
-#define m_I2CM_READ_REQ_EN	BIT(4)
-#define v_I2CM_READ_REQ_EN(n)	(((n) & 0x01) << 4)
-#define m_I2CM_READ_UPDATE	BIT(0)
-#define v_I2CM_READ_UPDATE(n)	(((n) & 0x01) << 0)
-
-#define	I2CM_READ_BUFF0			0x7e20	/* buff0~buff7 */
-#define	I2CM_SCDC_UPDATE0		0x7e30
-#define	I2CM_SCDC_UPDATE1		0x7e31
-
-/*
-* HDMI TX PHY Define Start
-*/
-#define PHYTX_OPMODE_PLLCFG		0x06
-enum {
-	PREP_DIV_BY_2 = 0,	/* 16 bits */
-	PREP_DIV_BY_15,		/* 12 bits */
-	PREP_DIV_BY_125,	/* 10 bits */
-	PREP_DIV_BY_1,		/* 8 bits */
-};
-
-#define m_PREP_DIV		(0x03 << 13)
-#define v_PREP_DIV(n)		(((n) & 0x03) << 13)
-enum {
-	TMDS_DIV_BY_1 = 0,
-	TMDS_DIV_NOT_USED,
-	TMDS_DIV_BY_3,
-	TMDS_DIV_BY_4,
-};
-
-#define m_TMDS_CNTRL		(0x03 << 11)
-#define v_TMDS_CNTRL(n)		(((n) & 0x03) << 11)
-enum OPMODE {
-	OP_HDMI_14 = 0,
-	OP_HDMI_20,
-};
-
-#define m_OPMODE		(0x03 << 9)
-#define v_OPMODE(n)		(((n) & 0x03) << 9)
-enum {
-	FBDIV2_BY_1 = 1,
-	FBDIV2_BY_2,
-	FBDIV2_BY_3,
-	FBDIV2_BY_4,
-	FBDIV2_BY_5,
-	FBDIV2_BY_6,
-};
-
-#define m_FBDIV2_CNTRL		(0x07 << 6)
-#define v_FBDIV2_CNTRL(n)	(((n) & 0x07) << 6)
-enum {
-	FBDIV1_BY_1 = 0,
-	FBDIV1_BY_2,
-	FBDIV1_BY_3,
-	FBDIV1_BY_4,
-};
-
-#define m_FBDIV1_CNTRL		(0x03 << 4)
-#define v_FBDIV1_CNTRL(n)	(((n) & 0x03) << 4)
-enum {
-	REF_DIV_BY_1 = 0,
-	REF_DIV_BY_2,
-	REF_DIV_NOT_USED,
-	REF_DIV_BY_4,
-};
-
-#define m_REF_CNTRL		(0x03 << 2)
-#define v_REF_CNTRL(n)		(((n) & 0x03) << 2)
-#define m_MPLL_N_CNTRL		(0x03 << 0)
-#define v_MPLL_N_CNTRL(n)	(((n) & 0x03) << 0)
-
-#define PHYTX_CLKSYMCTRL		0x09
-#define v_OVERRIDE(n)		(0x01 << 15)
-#define m_SLOPEBOOST		(0x03 << 4)
-#define v_SLOPEBOOST(n)		(((n) & 0x03) << 4)
-#define m_TX_SYMON		(0x01 << 3)
-#define v_TX_SYMON(n)		(((n) & 0x01) << 3)
-#define m_PREEMPHASIS		(0x03 << 1)
-#define v_PREEMPHASIS(n)	(((n) & 0x03) << 1)
-#define m_CLK_SYMON		(0x01 << 0)
-#define v_CLK_SYMON(n)		(((n) & 0x01) << 0)
-
-#define PHYTX_VLEVCTRL			0x0e
-#define m_SUP_TXLVL		(0x1f << 5)
-#define v_SUP_TXLVL(n)		(((n) & 0x1f) << 5)
-#define m_SUP_CLKLVL		(0x1f << 0)
-#define v_SUP_CLKLVL(n)		(((n) & 0x1f) << 0)
-
-#define PHYTX_PLLCURRCTRL		0x10
-#define m_MPLL_PROP_CNTRL	(0x07 << 3)
-#define v_MPLL_PROP_CNTRL(n)	(((n) & 0x07) << 3)
-#define m_MPLL_INT_CNTRL	(0x07 << 0)
-#define v_MPLL_INT_CNTRL(n)	(((n) & 0x07) << 0)
-
-#define PHYTX_PLLGMPCTRL		0x15
-#define m_MPLL_GMP_CNTRL	(0x03 << 0)
-#define v_MPLL_GMP_CNTRL(n)	(((n) & 0x03) << 0)
-
-enum TERM_RESIS {
-	R50_OHMS = 0,
-	R5714_OHMS,
-	R6667_OHMS,
-	R80_OHMS,
-	R100_OHMS,
-	R13333_OHMS,
-	R200_OHMS,
-	ROPEN_CIRCUIT,
-};
-
-#define PHYTX_TERM_RESIS		0x19
-#define m_TX_TERM		(0x07 << 0)
-#define v_TX_TERM(n)		(((n) & 0x07) << 0)
-
-struct phy_mpll_config_tab {
-	u32 pix_clock;
-	u32 tmdsclock;
-	u8 pix_repet;
-	u8 color_depth;
-	u16 prep_div;
-	u16 tmdsmhl_cntrl;
-	u16 opmode;
-	u32 fbdiv2_cntrl;
-	u16 fbdiv1_cntrl;
-	u16 ref_cntrl;
-	u16 n_cntrl;
-	u32 prop_cntrl;
-	u32 int_cntrl;
-	u16 gmp_cntrl;
-};
-
-/* PHY Defined for RK322X */
-#define EXT_PHY_CONTROL		0
-	#define EXT_PHY_ANALOG_RESET_MASK		0x80
-	#define EXT_PHY_DIGITAL_RESET_MASK		0x40
-	#define EXT_PHY_PCLK_INVERT_MASK		0x08
-	#define EXT_PHY_PREPCLK_INVERT_MASK		0x04
-	#define EXT_PHY_TMDSCLK_INVERT_MASK		0x02
-	#define EXT_PHY_SRC_SELECT_MASK			0x01
-
-#define EXT_PHY_TERM_CAL		0x03
-	#define EXT_PHY_TERM_CAL_EN_MASK		0x80
-	#define EXT_PHY_TERM_CAL_DIV_H_MASK		0x7f
-
-#define EXT_PHY_TERM_CAL_DIV_L		0x04
-
-#define EXT_PHY_PLL_PRE_DIVIDER		0xe2
-	#define EXT_PHY_PLL_FB_BIT8_MASK		0x80
-	#define EXT_PHY_PLL_PCLK_DIV5_EN_MASK		0x20
-	#define EXT_PHY_PLL_PRE_DIVIDER_MASK		0x1f
-
-#define EXT_PHY_PLL_FB_DIVIDER		0xe3
-
-#define EXT_PHY_PCLK_DIVIDER1		0xe4
-	#define EXT_PHY_PCLK_DIVIDERB_MASK		0x60
-	#define EXT_PHY_PCLK_DIVIDERA_MASK		0x1f
-
-#define EXT_PHY_PCLK_DIVIDER2		0xe5
-	#define EXT_PHY_PCLK_DIVIDERC_MASK		0x60
-	#define EXT_PHY_PCLK_DIVIDERD_MASK		0x1f
-
-#define EXT_PHY_TMDSCLK_DIVIDER		0xe6
-	#define EXT_PHY_TMDSCLK_DIVIDERC_MASK		0x30
-	#define EXT_PHY_TMDSCLK_DIVIDERA_MASK		0x0c
-	#define EXT_PHY_TMDSCLK_DIVIDERB_MASK		0x03
-
-#define EXT_PHY_PLL_BW			0xe7
-
-#define EXT_PHY_PPLL_PRE_DIVIDER	0xe9
-	#define EXT_PHY_PPLL_ENABLE_MASK		0xc0
-	#define EXT_PHY_PPLL_PRE_DIVIDER_MASK		0x1f
-
-#define EXT_PHY_PPLL_FB_DIVIDER		0xea
-
-#define EXT_PHY_PPLL_POST_DIVIDER	0xeb
-	#define EXT_PHY_PPLL_FB_DIVIDER_BIT8_MASK	0x80
-	#define EXT_PHY_PPLL_POST_DIVIDER_MASK		0x30
-	#define EXT_PHY_PPLL_LOCK_STATUS_MASK		0x01
-
-#define EXT_PHY_PPLL_BW			0xec
-
-#define EXT_PHY_SIGNAL_CTRL		0xee
-	#define EXT_PHY_TRANSITION_CLK_EN_MASK		0x80
-	#define EXT_PHY_TRANSITION_D0_EN_MASK		0x40
-	#define EXT_PHY_TRANSITION_D1_EN_MASK		0x20
-	#define EXT_PHY_TRANSITION_D2_EN_MASK		0x10
-	#define EXT_PHY_LEVEL_CLK_EN_MASK		0x08
-	#define EXT_PHY_LEVEL_D0_EN_MASK		0x04
-	#define EXT_PHY_LEVEL_D1_EN_MASK		0x02
-	#define EXT_PHY_LEVEL_D2_EN_MASK		0x01
-
-#define EXT_PHY_SLOPEBOOST		0xef
-	#define EXT_PHY_SLOPEBOOST_CLK_MASK		0x03
-	#define EXT_PHY_SLOPEBOOST_D0_MASK		0x0c
-	#define EXT_PHY_SLOPEBOOST_D1_MASK		0x30
-	#define EXT_PHY_SLOPEBOOST_D2_MASK		0xc0
-
-#define EXT_PHY_PREEMPHASIS		0xf0
-	#define EXT_PHY_PREEMPHASIS_D0_MASK		0x03
-	#define EXT_PHY_PREEMPHASIS_D1_MASK		0x0c
-	#define EXT_PHY_PREEMPHASIS_D2_MASK		0x30
-
-#define EXT_PHY_LEVEL1			0xf1
-	#define EXT_PHY_LEVEL_CLK_MASK			0xf0
-	#define EXT_PHY_LEVEL_D2_MASK			0x0f
-
-#define EXT_PHY_LEVEL2			0xf2
-	#define EXT_PHY_LEVEL_D1_MASK			0xf0
-	#define EXT_PHY_LEVEL_D0_MASK			0x0f
-
-#define EXT_PHY_TERM_RESIS_AUTO		0xf4
-	#define EXT_PHY_AUTO_R50_OHMS			0
-	#define EXT_PHY_AUTO_R75_OHMS			BIT(2)
-	#define EXT_PHY_AUTO_R100_OHMS			(2 << 2)
-	#define EXT_PHY_AUTO_ROPEN_CIRCUIT		(3 << 2)
-
-#define EXT_PHY_TERM_RESIS_MANUAL_CLK	0xfb
-#define EXT_PHY_TERM_RESIS_MANUAL_D2	0xfc
-#define EXT_PHY_TERM_RESIS_MANUAL_D1	0xfd
-#define EXT_PHY_TERM_RESIS_MANUAL_D0	0xfe
-
-#define RK322X_DDC_MASK_EN	((3 << 13) | (3 << (13 + 16)))
-#define RK322X_IO_3V_DOMAIN	((7 << 4) | (7 << (4 + 16)))
-#define RK322X_PLL_POWER_DOWN	(BIT(12) | BIT(12 + 16))
-#define RK322X_PLL_POWER_UP	BIT(12 + 16)
-#define RK322X_PLL_PDATA_DEN	BIT(11 + 16)
-#define RK322X_PLL_PDATA_EN	(BIT(11) | BIT(11 + 16))
-
-#ifndef RK322X_GRF_SOC_CON2
-#define RK322X_GRF_SOC_CON2	RK3228_GRF_SOC_CON2
-#endif
-#ifndef RK322X_GRF_SOC_CON6
-#define RK322X_GRF_SOC_CON6	RK3228_GRF_SOC_CON6
-#endif
-
-struct ext_pll_config_tab {
-	u32	pix_clock;
-	u32	tmdsclock;
-	u8	color_depth;
-	u8	pll_nd;
-	u16	pll_nf;
-	u8	tmsd_divider_a;
-	u8	tmsd_divider_b;
-	u8	tmsd_divider_c;
-	u8	pclk_divider_a;
-	u8	pclk_divider_b;
-	u8	pclk_divider_c;
-	u8	pclk_divider_d;
-	u8	vco_div_5;
-	u8	ppll_nd;
-	u16	ppll_nf;
-	u8	ppll_no;
-};
-
-/*
-* HDMI TX PHY Define End
-*/
-
-struct rockchip_hdmiv2_reg_table {
-	int reg_base;
-	int reg_end;
-};
-
-static inline u32 hdmi_readl(struct hdmi_dev *hdmi_dev, u16 offset)
-{
-	return readl_relaxed(hdmi_dev->regbase + (offset) * 0x04);
-}
-
-static inline int hdmi_writel(struct hdmi_dev *hdmi_dev, u16 offset, u32 val)
-{
-	int ret = 0;
-
-	writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
-	return ret;
-}
-
-static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
-			       u16 offset, u32 msk, u32 val)
-{
-	int ret = 0;
-	u32 temp;
-
-	temp = readl_relaxed(hdmi_dev->regbase +
-			     (offset) * 0x04) & (0xFF - (msk));
-	writel_relaxed(temp | ((val) & (msk)),
-		       hdmi_dev->regbase + (offset) * 0x04);
-	return ret;
-}
-
-irqreturn_t rockchip_hdmiv2_dev_irq(int irq, void *priv);
-void rockchip_hdmiv2_dev_init_ops(struct hdmi_ops *ops);
-void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev);
-void rockchip_hdmiv2_cec_init(struct hdmi *hdmi);
-void rockchip_hdmiv2_cec_isr(struct hdmi_dev *hdmi_dev, char cec_int);
-void rockchip_hdmiv2_hdcp_init(struct hdmi *hdmi);
-void rockchip_hdmiv2_hdcp2_enable(int enable);
-void rockchip_hdmiv2_hdcp_isr(struct hdmi_dev *hdmi_dev, int hdcp_int);
-int rockchip_hdmiv2_write_phy(struct hdmi_dev *hdmi_dev,
-			      int reg_addr, int val);
-int rockchip_hdmiv2_read_phy(struct hdmi_dev *hdmi_dev,
-			     int reg_addr);
-#endif
-- 
2.35.3

