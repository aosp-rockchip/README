From 0ec6331708c89e39e4dc1ef6bcada6455d8e013f Mon Sep 17 00:00:00 2001
From: xxx <xxx@rock-chips.com>
Date: Mon, 14 Apr 2014 10:07:00 +0800
Subject: [PATCH] rk3288 support log deep idle

---
 arch/arm/boot/dts/rk3288-clocks.dtsi |   8 +-
 arch/arm/boot/dts/rk3288.dtsi        |   8 +-
 arch/arm/boot/dts/rk808.dtsi         |   2 +-
 arch/arm/mach-rockchip/pm-rk3288.c   | 687 ++++++++++++++++++---------
 arch/arm/mach-rockchip/pm.c          | 119 +++--
 arch/arm/mach-rockchip/pm.h          |  53 ++-
 arch/arm/mach-rockchip/rk3288.c      |  41 +-
 arch/arm/mach-rockchip/sleep.S       |  38 +-
 8 files changed, 631 insertions(+), 325 deletions(-)
 mode change 100644 => 100755 arch/arm/boot/dts/rk808.dtsi
 mode change 100755 => 100644 arch/arm/mach-rockchip/pm-rk3288.c
 mode change 100755 => 100644 arch/arm/mach-rockchip/pm.c
 mode change 100755 => 100644 arch/arm/mach-rockchip/pm.h
 mode change 100755 => 100644 arch/arm/mach-rockchip/rk3288.c
 mode change 100755 => 100644 arch/arm/mach-rockchip/sleep.S

diff --git a/arch/arm/boot/dts/rk3288-clocks.dtsi b/arch/arm/boot/dts/rk3288-clocks.dtsi
index befc71054243..cc0554064665 100755
--- a/arch/arm/boot/dts/rk3288-clocks.dtsi
+++ b/arch/arm/boot/dts/rk3288-clocks.dtsi
@@ -2376,7 +2376,9 @@
 
 						"g_aclk_dmac1",		"g_aclk_strc_sys",
 						"reserved",		"reserved";	/*"g_p_ddrupctl0",	"g_pclk_publ0";*/
-                                                rockchip,suspend-clkgating-setting=<0xe2f0 0xe2f0>;                                                
+                    
+                                                //rockchip,suspend-clkgating-setting=<0xe2f1 0xe2f1>;          // use sram  mem no gating                                                                                         
+                                                rockchip,suspend-clkgating-setting=<0xf2f1 0xf2f1>;       // pwm logic vol        
 
 					#clock-cells = <1>;
 				};
@@ -2508,7 +2510,9 @@
 
 						"g_p_alive_niu",		"reserved",
 						"reserved",		"reserved";
-                                                rockchip,suspend-clkgating-setting=<0xffff 0xffff>;
+                                                //rockchip,suspend-clkgating-setting=<0xffff 0xffff>;
+                                                
+                                                rockchip,suspend-clkgating-setting=<0x1801 0x1801>;
 
 					#clock-cells = <1>;
 				};
diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi
index 687f9e483aa2..07b9de0d6922 100755
--- a/arch/arm/boot/dts/rk3288.dtsi
+++ b/arch/arm/boot/dts/rk3288.dtsi
@@ -537,6 +537,10 @@
 
 				/*pclk_bus*/
 				<&clk_gates10 1>,/*pclk_timer*/
+                                <&clk_gates10 9>,/*rom*/
+                                <&clk_gates10 13>,/*aclk strc*/
+                             
+                                <&clk_gates12 8>,/*aclk strc*/
 
 				/*aclk_peri*/
 				<&clk_gates6 2>,/*aclk_peri_axi_matrix*/
@@ -1159,8 +1163,8 @@
                                             |RKPM_CTR_PLLS
                                             //|RKPM_CTR_SYSCLK_DIV
                                             //|RKPM_CTR_IDLEAUTO_MD
-                                            //|RKPM_CTR_ARMDP_LPMD
-                                            |RKPM_CTR_ARMOFF_LPMD
+                                           // |RKPM_CTR_ARMOFF_LPMD
+                                            |RKPM_CTR_ARMOFF_LOGDP_LPMD
                                             )
                                         >;              
                   rockchip,pmic-gpios=<
diff --git a/arch/arm/boot/dts/rk808.dtsi b/arch/arm/boot/dts/rk808.dtsi
old mode 100644
new mode 100755
index eecf5355ad17..2ecd864a5790
--- a/arch/arm/boot/dts/rk808.dtsi
+++ b/arch/arm/boot/dts/rk808.dtsi
@@ -29,7 +29,7 @@
 			regulator-initial-state = <3>;
 			regulator-state-mem {
 				regulator-state-mode = <0x2>;
-				regulator-state-enabled;
+				regulator-state-disabled;
 				regulator-state-uv = <900000>;
 			};		
 		};
diff --git a/arch/arm/mach-rockchip/pm-rk3288.c b/arch/arm/mach-rockchip/pm-rk3288.c
old mode 100755
new mode 100644
index 7ea0a54e0c98..a871a0a622ef
--- a/arch/arm/mach-rockchip/pm-rk3288.c
+++ b/arch/arm/mach-rockchip/pm-rk3288.c
@@ -25,9 +25,39 @@
 //#include "sram.h"
 #include "pm-pie.c"
 
+
+static void ddr_pin_set_pull(u8 port,u8 bank,u8 b_gpio,u8 fun);
+static void ddr_gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type);
+static void ddr_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun);
+
+
 /*************************cru define********************************************/
-#define RK3288_CRU_UNGATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(0,id%16,0x1),RK3288_CRU_GATEID_CONS(id))
-#define RK3288_CRU_GATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(1,id%16,0x1),RK3288_CRU_GATEID_CONS(id))
+
+
+#define RK3288_CRU_UNGATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(0,(id)%16,0x1),RK3288_CRU_GATEID_CONS((id)))
+#define RK3288_CRU_GATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(1,(id)%16,0x1),RK3288_CRU_GATEID_CONS((id)))
+
+enum rk_plls_id {
+	APLL_ID = 0,
+	DPLL_ID,
+	CPLL_ID,
+	GPLL_ID,
+	NPLL_ID,
+	END_PLL_ID,
+};
+
+#define RK3288_PLL_PWR_DN_MSK (0x1<<1)
+#define RK3288_PLL_PWR_DN CRU_W_MSK_SETBITS(1,1,0x1)
+#define RK3288_PLL_PWR_ON CRU_W_MSK_SETBITS(0,1,0x1)
+
+
+#define RK3288_PLL_RESET		CRU_W_MSK_SETBITS(1,5,0x1)
+#define RK3288_PLL_RESET_RESUME CRU_W_MSK_SETBITS(0,5,0x1)
+
+#define RK3288_PLL_BYPASS_MSK (0x1<<0)
+#define RK3288_PLL_BYPASS CRU_W_MSK_SETBITS(1,0,0x1)
+#define RK3288_PLL_NO_BYPASS CRU_W_MSK_SETBITS(0,0,0x1)
+
 
 /*******************************gpio define **********************************************/
 
@@ -47,16 +77,30 @@
 
 /***********************************sleep func*********************************************/
 
+#define RKPM_BOOTRAM_PHYS (RK3288_BOOTRAM_PHYS)
+#define RKPM_BOOTRAM_BASE (RK_BOOTRAM_VIRT)
+#define RKPM_BOOTRAM_SIZE (RK3288_BOOTRAM_SIZE)
+
+// sys resume code in boot ram
+#define  RKPM_BOOT_CODE_PHY  (RKPM_BOOTRAM_PHYS+RKPM_BOOT_CODE_OFFSET)
+#define  RKPM_BOOT_CODE_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_CODE_OFFSET)
+
+
 // sys resume data in boot ram
-#define SLP_DATA_SAVE_PHY  (RK3288_BOOTRAM_PHYS+PM_BOOT_CODE_OFFSET+PM_BOOT_CODE_SIZE)
-#define SLP_DATA_SAVE_BASE  (RK_BOOTRAM_VIRT+PM_BOOT_CODE_OFFSET+PM_BOOT_CODE_SIZE)
+#define  RKPM_BOOT_DATA_PHY  (RKPM_BOOTRAM_PHYS+RKPM_BOOT_DATA_OFFSET)
+#define  RKPM_BOOT_DATA_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_DATA_OFFSET)
 
 // ddr resume data in boot ram
-#define SLP_DDR_DATA_SAVE_PHY  (RK3288_BOOTRAM_PHYS + PM_BOOT_DDR_CODE_OFFSET)
-#define SLP_DDR_DATA_SAVE_BASE  (RK_BOOTRAM_VIRT+PM_BOOT_DDR_CODE_OFFSET)
+#define  RKPM_BOOT_DDRCODE_PHY   (RKPM_BOOTRAM_PHYS + RKPM_BOOT_DDRCODE_OFFSET)
+#define  RKPM_BOOT_DDRCODE_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_DDRCODE_OFFSET)
+
+#define RKPM_BOOT_CPUSP_PHY (RKPM_BOOTRAM_PHYS+((RKPM_BOOTRAM_SIZE-1)&~0x7))
+
+// the value is used to control cpu resume flow
+static u32 sleep_resume_data[RKPM_BOOTDATA_ARR_SIZE];
+static char *resume_data_base=(char *)( RKPM_BOOT_DATA_BASE);
+static char *resume_data_phy=  (char *)( RKPM_BOOT_DATA_PHY);
 
-#define PM_BOOT_DDR_CODE_OFFSET	(((PM_BOOT_CODE_OFFSET+PM_BOOT_CODE_SIZE+PM_BOOT_DATA_SIZE)/4+2)*4)
-#define PM_BOOT_CODE_SP (RK3288_BOOTRAM_PHYS+((RK3288_BOOTRAM_SIZE-1)&~0x7))
 
 
 #define BOOT_RAM_SIZE	(4*1024)
@@ -65,23 +109,8 @@
 static char boot_ram_data[BOOT_RAM_SIZE+4*10];
 static char int_ram_data[INT_RAM_SIZE];
 
-
-// the value is used to control cpu resume flow
-static u32 sleep_resume_data[SLPDATA_SLEEP_RES_CON_CNT];
-static char *resume_data_base=(char *)(SLP_DATA_SAVE_BASE);
-static char *resume_data_phy=  (char *)(SLP_DATA_SAVE_PHY);
-
-static void sram_code_reset(char *data, char *save, char* sram_base,char* sram_phy,u32 _size)
-{
-  char *addr_d=(char *)sram_base;
-
-  if(save)
-	  memcpy(save,addr_d, _size);
-	  
-  memcpy((char *)addr_d,(char *)data, _size);
-  flush_icache_range((unsigned long)addr_d, (unsigned long)addr_d + _size);
-  outer_clean_range((phys_addr_t) sram_phy, _size);
-}
+char * ddr_get_resume_code_info(u32 *size);
+char * ddr_get_resume_data_info(u32 *size);
 
 /**
 ddr code and data
@@ -91,15 +120,15 @@ ddr code and data
 ---code----
 ---data----
 */
-static void sram_data_for_sleep(char *boot_save, char *int_save)
+static void sram_data_for_sleep(char *boot_save, char *int_save,u32 flag)
 {	
  	
 	char *addr_base,*addr_phy,*data_src,*data_dst;
 	u32 sr_size,data_size;
 
-	addr_base=(char *)RK_BOOTRAM_VIRT;
-	addr_phy=(char *)RK3288_BOOTRAM_PHYS;
-	sr_size=RK3288_BOOTRAM_SIZE;
+	addr_base=(char *)RKPM_BOOTRAM_BASE;
+	addr_phy=(char *)RKPM_BOOTRAM_PHYS;
+	sr_size=RKPM_BOOTRAM_SIZE;
 
  	// save boot sram
 	 if(boot_save)
@@ -107,9 +136,9 @@ static void sram_data_for_sleep(char *boot_save, char *int_save)
 
 	// move resume code and date to boot sram
 	// move sys code
-	data_dst=(char *)RK_BOOTRAM_VIRT+PM_BOOT_CODE_OFFSET;
+	data_dst=(char *)RKPM_BOOT_CODE_BASE;
 	data_src=(char *)rkpm_slp_cpu_resume;
-	data_size=PM_BOOT_CODE_SIZE;
+	data_size=RKPM_BOOT_CODE_SIZE;
 	memcpy((char *)data_dst,(char *)data_src, data_size);
 
 	// move sys data
@@ -117,70 +146,74 @@ static void sram_data_for_sleep(char *boot_save, char *int_save)
 	data_src=(char *)sleep_resume_data;
 	data_size=sizeof(sleep_resume_data);
 	memcpy((char *)data_dst,(char *)data_src, data_size);
-#if 0
-	/*************************ddr code cpy*************************************/
-	// ddr code
-	data_dst=(char *)(char *)SLP_DDR_DATA_SAVE_BASE;
-	data_src=(char *)ddr_get_resume_code_info(&data_size);
-	
-	data_size=(data_size/4+1)*4;
-	
-	memcpy((char *)data_dst,(char *)data_src, data_size);
-
-	// ddr data
-	data_dst=(char *)(data_dst+data_size);
-	
-	data_src=(char *)ddr_get_resume_data_info(&data_size);
-	data_size=(data_size/4+1)*4;
-	memcpy((char *)data_dst,(char *)data_src, data_size);
-	
-	/*************************ddr code cpy  end*************************************/
-#endif	
-	flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-	 outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)(addr_phy)+sr_size);
-#if 0	 
-	 /*************************int mem bak*************************************/
-	// int mem
-	addr_base=(char *)rockchip_sram_virt;
-	//addr_phy=(char *)RK319X_IMEM_PHYS;
-	sr_size=rockchip_sram_size;
-        //mmap
-	if(int_save)
-	  memcpy(int_save,addr_base, sr_size);
-
-	 flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-	// outer_clean_range((phys_addr_t) addr_phy, sr_size);
-#endif
+            
+        if(flag)
+        {
+                /*************************ddr code cpy*************************************/
+                // ddr code
+                data_dst=(char *)(char *)RKPM_BOOT_DDRCODE_BASE;
+                data_src=(char *)ddr_get_resume_code_info(&data_size);
+
+                data_size=RKPM_ALIGN(data_size,4);
+
+                memcpy((char *)data_dst,(char *)data_src, data_size);
+
+                // ddr data
+                data_dst=(char *)(data_dst+data_size);
+
+                data_src=(char *)ddr_get_resume_data_info(&data_size);
+                data_size=RKPM_ALIGN(data_size,4);
+                memcpy((char *)data_dst,(char *)data_src, data_size);
+
+                /*************************ddr code cpy  end*************************************/
+                flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
+                outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)(addr_phy)+sr_size);
+                /*************************int mem bak*************************************/
+                // int mem
+                addr_base=(char *)rockchip_sram_virt;
+                addr_phy=(char *)pie_to_phys(rockchip_pie_chunk,(unsigned long )rockchip_sram_virt);
+                sr_size=rockchip_sram_size;
+                //  rkpm_ddr_printascii("piephy\n");
+                //rkpm_ddr_printhex(addr_phy);
+                //mmap
+                if(int_save)
+                    memcpy(int_save,addr_base, sr_size);
+
+                flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
+                outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)(addr_phy)+sr_size);
+        }    
+     
  }
 
-static void sram_data_resume(char *boot_save, char *int_save)
+static void sram_data_resume(char *boot_save, char *int_save,u32 flag)
 {  
  
     char *addr_base,*addr_phy;
     u32 sr_size;
-
-    addr_base=(char *)RK_BOOTRAM_VIRT;
-    addr_phy=(char *)RK3288_BOOTRAM_PHYS;
-    sr_size=RK3288_BOOTRAM_SIZE;
+    
+    addr_base=(char *)RKPM_BOOTRAM_BASE;
+    addr_phy=(char *)RKPM_BOOTRAM_PHYS;
+    sr_size=RKPM_BOOTRAM_SIZE;
     // save boot sram
     if(boot_save)
         memcpy(addr_base,boot_save, sr_size);
 
     flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
     outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)addr_phy+sr_size);
-     
-    #if 0
-    // int mem
-    addr_base=(char *)RK319X_IMEM_BASE;
-    addr_phy=(char *)RK319X_IMEM_PHYS;
-    sr_size=RK319X_IMEM_SIZE;
 
-     if(int_save)
-       memcpy(addr_base, int_save,sr_size);
+    if(flag)
+    {
+        // int mem
+        addr_base=(char *)rockchip_sram_virt;
+        addr_phy=(char *)pie_to_phys(rockchip_pie_chunk,(unsigned long )rockchip_sram_virt);
+        sr_size=rockchip_sram_size;
+
+        if(int_save)
+        memcpy(addr_base, int_save,sr_size);
 
-      flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-      outer_clean_range((phys_addr_t) addr_phy, sr_size);
-      #endif
+        flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
+        outer_clean_range((phys_addr_t) addr_phy,(unsigned long)addr_phy+sr_size);
+     }
 }
 
 /**************************************gic save and resume**************************/
@@ -227,6 +260,7 @@ static void rkpm_gic_disable(u32 irqs)
   
 static u32 slp_gic_save[260+50];
 
+
 static void rkpm_gic_dist_save(u32 *context)
 {
      int i = 0,j,irqstart=0;
@@ -306,6 +340,7 @@ static void rkpm_gic_dist_save(u32 *context)
      context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_CTRL);
     #endif	
     #if 0  //rk319x is not need
+    
      for (j = irqstart; j < gic_irqs; j += 32)
      {
     	 writel_relaxed(0xffffffff, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
@@ -321,6 +356,7 @@ static void rkpm_gic_dist_resume(u32 *context)
 
          int i = 0,j,irqstart=0;
          unsigned int gic_irqs;
+
          
          gic_irqs = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTR) & 0x1f;
          gic_irqs = (gic_irqs + 1) * 32;
@@ -440,9 +476,8 @@ static void rkpm_gic_dist_resume(u32 *context)
  
 }
 
-
- 
 /**************************************regs save and resume**************************/
+
 void slp_regs_save(u32 *data,void __iomem * base,u32 st_offset,u32 end_offset)
 {
      u32 i;
@@ -481,6 +516,8 @@ static void __iomem *slp_uart_base[RK3288_UART_NUM]={NULL};
 static u32 slp_uart_phy[RK3288_UART_NUM]={(0xff180000),(0xff190000),(0xff690000),(0xff1b0000)};
 
 static u32 slp_uart_data[RK3288_UART_NUM][10];
+static u32 slp_uart_data_flag[RK3288_UART_NUM];
+
  
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
@@ -499,6 +536,7 @@ static u32 slp_uart_data[RK3288_UART_NUM][10];
 	 u32 gate_reg;
 	 if(b_addr==NULL || ch>=RK3288_UART_NUM)
 	 	return;	
+     
         if(ch==2)
         {
             idx=RK3288_CLKGATE_PCLK_UART2;
@@ -533,12 +571,16 @@ static u32 slp_uart_data[RK3288_UART_NUM][10];
         int idx=RK3288_CLKGATE_PCLK_UART0+ch;
         u32 gate_reg;
         
+        //rkpm_ddr_printascii("\nch");
+     //   rkpm_ddr_printhex(b_addr);
+        
         if(b_addr==NULL || ch>=RK3288_UART_NUM)
             return;	
         
         if(ch==2)
             idx=RK3288_CLKGATE_PCLK_UART2;
 
+        //rkpm_ddr_printhex(ch);
 
         gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
         RK3288_CRU_UNGATING_OPS(idx); 
@@ -719,7 +761,13 @@ static void gpio_ddr_dump_reg(int ports)
         cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
  
  }
-
+ 
+ static inline u32 rkpm_l2_config(void)
+ {
+     u32 l2ctlr;
+     asm("mrc p15, 1, %0, c9, c0, 2" : "=r" (l2ctlr));
+         return l2ctlr;
+ }
 /**************************************sleep func**************************/
 
 void ddr_reg_save(uint32_t *pArg);
@@ -775,18 +823,7 @@ void inline pm_io_base_map(void)
             }
 	
 }	
-#if 0
-void pm_gpio_setting(void)
-{
-
-	//gpio wake up setting
-	gpio0_lp_wakeup_en(1,3);
-	gpio0s_lp_wakeup_type(1);
-	gpio0_lp_wakeup_en(6,3);
-	
-}
-#endif
- enum rk3288_pwr_mode_con {
+enum rk3288_pwr_mode_con {
 
         pmu_pwr_mode_en=0,
         pmu_clk_core_src_gate_en,
@@ -833,69 +870,122 @@ void pm_gpio_setting(void)
         pmu_clr_vio
   
 };
+ static u32 rk3288_powermode=0;
 
 static void ddr_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun);
 
 static u32 sgrf_soc_con0,pmu_pwr_mode_con0,pmu_pwr_mode_con1;
 
-static void  rkpm_slp_mode_set(u32 val)
+static u32  rkpm_slp_mode_set(u32 ctrbits)
 {
     u32 mode_set,mode_set1;
     
     // setting gpio0_a0 arm off pin
+
     ddr_pin_set_fun(0x0,0xa,0x0,0x1);
 
     sgrf_soc_con0=reg_readl(RK_SGRF_VIRT+RK3288_SGRF_SOC_CON0);
     pmu_pwr_mode_con0=pmu_readl(RK3288_PMU_PWRMODE_CON);  
     pmu_pwr_mode_con1=pmu_readl(RK3288_PMU_PWRMODE_CON1);
     
-    mode_set1=pmu_pwr_mode_con1;
-    mode_set=pmu_pwr_mode_con0;
-    
-
-    pmu_writel(0x1<<0,RK3188_PMU_WAKEUP_CFG1);  
+    //mode_set1=pmu_pwr_mode_con1;
+    //mode_set=pmu_pwr_mode_con0;
+  
+   //pmu_writel(0x1<<3,RK3188_PMU_WAKEUP_CFG1);  
+   pmu_writel(0x1<<0,RK3188_PMU_WAKEUP_CFG1);  
 
     // enable boot ram    
     reg_writel((0x1<<8)|(0x1<<(8+16)),RK_SGRF_VIRT+RK3288_SGRF_SOC_CON0);
-    reg_writel(RK3288_BOOTRAM_PHYS,RK_SGRF_VIRT+RK3288_SGRF_FAST_BOOT_ADDR);
-
-    mode_set|=  BIT(pmu_pwr_mode_en)|BIT(pmu_global_int_disable)
-                        | BIT(pmu_l2flush_en)
-                        |BIT(pmu_sref0_enter_en)|BIT(pmu_sref1_enter_en) |BIT(pmu_ddr0_gating_en)|BIT(pmu_ddr1_gating_en);
+    dsb();
+    
+    reg_writel(RKPM_BOOTRAM_PHYS,RK_SGRF_VIRT+RK3288_SGRF_FAST_BOOT_ADDR);
+    dsb();
 
+    mode_set=  BIT(pmu_pwr_mode_en) |BIT(pmu_global_int_disable) | BIT(pmu_l2flush_en);
+     mode_set1=0;
 
-    if(rkpm_chk_val_ctrbit(val,RKPM_CTR_IDLEAUTO_MD))
+    if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_IDLEAUTO_MD))
     {
         rkpm_ddr_printascii("-autoidle-");
-        mode_set|=BIT(pmu_clk_core_src_gate_en);
+        mode_set|=BIT(pmu_clk_core_src_gate_en);        
     }
-    else if(rkpm_chk_val_ctrbit(val,RKPM_CTR_ARMDP_LPMD))
+    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMDP_LPMD))
     {
         rkpm_ddr_printascii("-armdp-");            
-        //rkpm_ddr_printhex(cru_readl(RK3288_CRU_MODE_CON));       
-        
-       // pmu_writel(0x1<<3,RK3188_PMU_WAKEUP_CFG1);  
         mode_set|=BIT(pmu_a12_0_pd_en);
     }
-    else if(rkpm_chk_val_ctrbit(val,RKPM_CTR_ARMOFF_LPMD))
+    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMOFF_LPMD))
+    {   
+        rkpm_ddr_printascii("-armoff-");                         
+        mode_set|=BIT(pmu_scu_en)
+                            //|BIT(pmu_a12_0_pd_en) 
+                            |BIT(pmu_clk_core_src_gate_en) // »½ÐÑºóÒì³£
+                            |BIT(pmu_sref0_enter_en)|BIT(pmu_sref1_enter_en) 
+                            |BIT(pmu_ddr0_gating_en)|BIT(pmu_ddr1_gating_en)              
+                            //|BIT(pmu_ddr1io_ret_en)|BIT(pmu_ddr0io_ret_en)   
+                            |BIT(pmu_chip_pd_en);
+        mode_set1=BIT(pmu_clr_core)|BIT(pmu_clr_cpup)
+                                |BIT(pmu_clr_alive)
+                                |BIT(pmu_clr_peri)
+                                |BIT(pmu_clr_bus)
+                                |BIT(pmu_clr_dma)
+                                ;
+    } 
+    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMOFF_LOGDP_LPMD))
     {
     
-        rkpm_ddr_printascii("-armoff-");            
-        //rkpm_ddr_printhex(cru_readl(RK3288_CRU_MODE_CON)); 
+        rkpm_ddr_printascii("-armoff-logdp-");        
         
-        mode_set|=BIT(pmu_scu_en)|BIT(pmu_chip_pd_en);
-        mode_set1|=BIT(pmu_clr_core)|BIT(pmu_clr_cpup);
+        mode_set|=BIT(pmu_scu_en)|BIT(pmu_bus_pd_en)
+                            |BIT(pmu_chip_pd_en)
+                            |BIT(pmu_sref0_enter_en)|BIT(pmu_sref1_enter_en) 
+                            |BIT(pmu_ddr0_gating_en)|BIT(pmu_ddr1_gating_en)              
+                            |BIT(pmu_ddr1io_ret_en)|BIT(pmu_ddr0io_ret_en)   
+                            |BIT(pmu_osc_24m_dis)|BIT(pmu_pmu_use_lf)|BIT(pmu_alive_use_lf)
+                            ;
+        mode_set1=BIT(pmu_clr_core)|BIT(pmu_clr_cpup)
+                           |BIT(pmu_clr_alive)
+                           |BIT(pmu_clr_peri)
+                           |BIT(pmu_clr_bus) 
+                           |BIT(pmu_clr_dma)                                       
+                          ;
+     
     } 
     else
     {
-        mode_set=pmu_pwr_mode_con0;
-        mode_set1=pmu_pwr_mode_con1;
+        mode_set=0;
+        mode_set1=0;
+    }
+
+    
+    if(mode_set&BIT(pmu_osc_24m_dis))
+    {
+        rkpm_ddr_printascii("osc_off");        
+        pmu_writel(32*30,RK3288_PMU_OSC_CNT);  
+        pmu_writel(32*30,RK3288_PMU_STABL_CNT);  
+    }
+    else
+    {
+        pmu_writel(24*1000*10,RK3288_PMU_STABL_CNT);  
+        
+       // pmu_writel(24*1000*20,RK3288_PMU_CORE_PWRDWN_CNT);  
+    }
+
+    if(mode_set&BIT(pmu_ddr0io_ret_en))
+    {
+        rkpm_ddr_printascii("ddrc_off");  
+        ddr_pin_set_fun(0x0,0xa,0x1,0x1);
+        ddr_pin_set_fun(0x0,0xa,0x2,0x1);
+        ddr_pin_set_fun(0x0,0xa,0x3,0x1);
     }
 
-   
     pmu_writel(mode_set,RK3288_PMU_PWRMODE_CON);  
     pmu_writel(mode_set1,RK3288_PMU_PWRMODE_CON1);  
-
+    
+  //  rkpm_ddr_printhex(mode_set);
+  //  rkpm_ddr_printhex(pmu_readl(RK3288_PMU_PWRMODE_CON));
+  
+    return (pmu_readl(RK3288_PMU_PWRMODE_CON));  
 }
 
 static inline void  rkpm_slp_mode_set_resume(void)
@@ -907,57 +997,147 @@ static inline void  rkpm_slp_mode_set_resume(void)
     
 }
 
-static inline u32 rkpm_l2_config(void)
+static void sram_code_data_save(u32 pwrmode)
 {
-	u32 l2ctlr;
-	asm("mrc p15, 1, %0, c9, c0, 2" : "=r" (l2ctlr));
-        return l2ctlr;
+	char *code_src,*data_src;
+	u32 code_size,data_size;
+        u32 ddr_bits= RKPM_CTR_ARMLOGDP_LPMD|RKPM_CTR_ARMOFF_LOGDP_LPMD|RKPM_CTR_ARMLOGOFF_DLPMD;
+     
+	//u32 *p;
+        if(pwrmode&(BIT(pmu_scu_en)|BIT(pmu_a12_0_pd_en)))
+        {   
+            sleep_resume_data[RKPM_BOOTDATA_L2LTY_F]=1;
+            sleep_resume_data[RKPM_BOOTDATA_L2LTY]=rkpm_l2_config();// in sys resume ,ddr is need resume	
+            sleep_resume_data[RKPM_BOOTDATA_CPUSP]=RKPM_BOOT_CPUSP_PHY;// in sys resume ,ddr is need resume	
+            sleep_resume_data[RKPM_BOOTDATA_CPUCODE]=virt_to_phys(cpu_resume);// in sys resume ,ddr is need resume    
+        }
+        else
+        {
+            sleep_resume_data[RKPM_BOOTDATA_CPUCODE]=0;
+            return ;
+        }
+	
+        if(pwrmode&BIT(pmu_bus_pd_en))                
+        {   
+        	sleep_resume_data[RKPM_BOOTDATA_DDR_F]=1;// in sys resume ,ddr is need resume
+        	sleep_resume_data[RKPM_BOOTDATA_DPLL_F]=1;// in ddr resume ,dpll is need resume
+                code_src=(char *)ddr_get_resume_code_info(&code_size);
+                sleep_resume_data[RKPM_BOOTDATA_DDRCODE]=RKPM_BOOT_DDRCODE_PHY;
+                sleep_resume_data[RKPM_BOOTDATA_DDRDATA]=RKPM_BOOT_DDRCODE_PHY+RKPM_ALIGN(code_size,4);
+                data_src=(char *)ddr_get_resume_data_info(&data_size);
+                ddr_reg_save((u32 *)(resume_data_phy+RKPM_BOOTDATA_DPLL_F*4));
+       }
+        else
+        {
+            sleep_resume_data[RKPM_BOOTDATA_DDR_F]=0;
+        }
+        
+	sram_data_for_sleep(boot_ram_data,int_ram_data,sleep_resume_data[RKPM_BOOTDATA_DDR_F]);
+    
+        flush_cache_all();
+        outer_flush_all();
+        local_flush_tlb_all();
+
 }
 
+static inline void sram_code_data_resume(u32 pwrmode)
+{
+         if(pwrmode&(BIT(pmu_scu_en)|BIT(pmu_a12_0_pd_en)))
+        {
+             sram_data_resume(boot_ram_data,int_ram_data,sleep_resume_data[RKPM_BOOTDATA_DDR_F]);
+        }
+             
+}
 
-static int sleep_resume_all=0;
-void pm_sleep_func_save(void)
+static void  rkpm_peri_save(u32 power_mode)
 {
-	//char *data_src;
-	//u32 data_size;
-	//u32 *p;
-	
-	sleep_resume_data[SLPDATA_L2_CON]=rkpm_l2_config();// in sys resume ,ddr is need resume	
-	sleep_resume_data[SLPDATA_SP_ADDR]=PM_BOOT_CODE_SP;// in sys resume ,ddr is need resume	
-	sleep_resume_data[SLPDATA_SP_CPU_RESUME]=virt_to_phys(cpu_resume);// in sys resume ,ddr is need resume
-	sleep_resume_data[SLPDATA_DDR_NEED_RES]=0;// in sys resume ,ddr is need resume
-	sleep_resume_data[SLPDATA_DPLL_NEED_RES]=0;// in ddr resume ,dpll is need resume
-	//data_src=(char *)ddr_get_resume_code_info(&data_size);
-	//sleep_resume_data[SLPDATA_DDR_CODE_PHY]=SLP_DDR_DATA_SAVE_PHY;
-	//sleep_resume_data[SLPDATA_DDR_DATA_PHY]=SLP_DDR_DATA_SAVE_PHY+(data_size/4+1)*4;	
-	
-	//ddr_reg_save(resume_data_phy+SLP_DPLL_NEED_RES*4);
-	sram_data_for_sleep(boot_ram_data,int_ram_data);
-       rkpm_gic_dist_save(&slp_gic_save[0]);
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
+    u32 gpio_gate[2];
 
-	//slp_regs_save(slp_grf_iomux_data,(u32)RK_GRF_VIRT+0x10,16);
-	//slp_regs_save(slp_nandc_data,(u32)rk30_nandc_base,8);
- 
-	//slp_pin_gpio_save(1);
-	//slp_pin_gpio_save(2);
-	//slp_pin_gpio_save(3);
-	//slp_pin_gpio_save(4);
-	//slp_uart_save(2);
-	#if 0
-    	rkpm_ddr_printascii("l2-");
-        rkpm_ddr_printhex(sleep_resume_data[SLPDATA_L2_CON]);
-    	rkpm_ddr_printascii("\n");
+    if(power_mode&BIT(pmu_scu_en))
+    {
+        rkpm_gic_dist_save(&slp_gic_save[0]);   
+    }
+#if 0
+    gpio_gate[0]=cru_readl(RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO0));
+    gpio_gate[1]=cru_readl(RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
+    RK3288_CRU_UNGATING_OPS(RK3288_CLKGATE_PCLK_GPIO0);
+    cru_writel(0xff<<(RK3288_CLKGATE_PCLK_GPIO1%16+16),
+                         RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
+#endif
+    
+    if(power_mode&BIT(pmu_bus_pd_en))
+   {  
+       #if 0
+        //gpio7_c6
+        //gpio7_c7
+        ddr_pin_set_pull(7,0xc,0x6,RKPM_GPIO_PULL_UP);
+        ddr_gpio_set_in_output(7,0xc,0x6,RKPM_GPIO_INPUT);
+        ddr_pin_set_fun(7,0xc,0x6,0);
+        
+        ddr_pin_set_pull(7,0xc,0x7,RKPM_GPIO_PULL_UP);
+        ddr_gpio_set_in_output(7,0xc,0x7,RKPM_GPIO_INPUT);
+        ddr_pin_set_fun(7,0xc,0x7,0);
         #endif
+        slp_uart_save(2);
+    #if 0
+        ddr_pin_set_pull(0,0xb,0x7,RKPM_GPIO_PULL_UP);
+        ddr_gpio_set_in_output(0,0xb,0x7,RKPM_GPIO_INPUT);
+        ddr_pin_set_fun(0,0xb,0x7,0);
         
-	sleep_resume_all=0;
+        ddr_pin_set_pull(0,0xc,0x0,RKPM_GPIO_PULL_UP);
+        ddr_gpio_set_in_output(0,0xc,0x0,RKPM_GPIO_INPUT);
+        ddr_pin_set_fun(0,0xc,0x0,0);
+        #endif      
+        slp_i2c_save(0);// i2c pmu gpio0b7 gpio0_c0
+        //slp_i2c_save(2);//i2c audio
+    }
+
+#if 0
+        cru_writel((0xff<<(RK3288_CLKGATE_PCLK_GPIO1%16+16))|gpio_gate[0],
+                                      RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
+        cru_writel(gpio_gate[0]|CRU_W_MSK(RK3288_CLKGATE_PCLK_GPIO0%16,0x1),RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO0));         
+#endif
+
 }
-void pm_sleep_func_rusume_first(void)
+
+static inline void  rkpm_peri_resume(u32 power_mode)
 {
-    
-       // rkpm_ddr_printhex(cru_readl(RK3288_CRU_MODE_CON));
+    if(power_mode&BIT(pmu_scu_en))
+    {       
+        //fiq_glue_resume();
+        rkpm_gic_dist_resume(&slp_gic_save[0]);          
+        fiq_glue_resume();
+        //rkpm_ddr_printascii("gic res");       
+    }  
+    if(power_mode&BIT(pmu_bus_pd_en))
+   {
+        slp_i2c_resume(0);// i2c pmu
+        slp_i2c_resume(2);//i2c audio
+    }
+
+}
+
+static inline void  rkpm_peri_resume_first(u32 power_mode)
+{
+      if(power_mode&BIT(pmu_bus_pd_en))
+        slp_uart_resume(2);
+}
+
+static void rkpm_slp_setting(void)
+{
+   //rkpm_gic_disable(130);
+  //  rkpm_gic_disable(132);
+
+    //rkpm_ddr_printhex(pmu_readl(RK3288_PMU_WAKEUP_CFG1));
+    //rkpm_ddr_printhex(pmu_readl(RK3288_PMU_PWRMODE_CON));
+}
+
+
+static void rkpm_save_setting_resume_first(void)
+{
+        rkpm_peri_resume_first(rk3288_powermode);
+        
+        // rkpm_ddr_printhex(cru_readl(RK3288_CRU_MODE_CON));
         #if 0
 	//rk319x_pm_set_power_domain(PD_PERI,true);
 	//slp_regs_resume(slp_grf_io_pull_data,(u32)RK_GRF_VIRT+0x144,16,0xffff0000);
@@ -977,38 +1157,40 @@ void pm_sleep_func_rusume_first(void)
 	#endif
 	//sram_printch_uart_enable();
 	slp_uart_resume(2);
-    #endif
-    
-    sleep_resume_all=1;
-    
-
+       #endif
 }
 
-void pm_sleep_func_rusume_last(void)
+
+
+static u32 rk3288_ctrbits=0;
+
+static void rkpm_save_setting(u32 ctrbits)
 {
-    if(sleep_resume_all)
-    {
-  
-        // slp_uart_resume(0);
-        // slp_uart_resume(1);
-        // slp_uart_resume(3);
-        // slp_regs_resume(slp_nandc_data,(u32)rk30_nandc_base,8,0);
+        //rk3288_ctrbits=ctrbits;        
+        rk3288_powermode=rkpm_slp_mode_set(ctrbits);
+        if(rk3288_powermode&BIT(pmu_pwr_mode_en))
+       {
+                sram_code_data_save(rk3288_powermode);   
+                rkpm_peri_save(rk3288_powermode);                
+        }
+        else
+             return ;
 
-        //rkpm_ddr_printch('g');
-        rkpm_gic_dist_resume(&slp_gic_save[0]);
+}
+static void rkpm_save_setting_resume(void)
+{
+                   
+         if(rk3288_powermode&BIT(pmu_pwr_mode_en))
+        {
+            sram_code_data_resume(rk3288_powermode); 
+            rkpm_peri_resume(rk3288_powermode);
+        }
+         
+         rkpm_slp_mode_set_resume();       
 
-        fiq_glue_resume();
-        #if 0
-        rkpm_ddr_printascii("l2-");
-        rkpm_ddr_printhex(rkpm_l2_config());
-        rkpm_ddr_printascii("\n");
-        #endif
-        
-    }
-    rkpm_slp_mode_set_resume();
-    sram_data_resume(boot_ram_data,int_ram_data);  
 }
 
+
 /*******************************common code  for rkxxx*********************************/
 static void  inline uart_printch(char byte)
 {
@@ -1059,8 +1241,6 @@ static void  ddr_printch(char byte)
 //#define RK3288_PMU_GPIO0_B_IOMUX	0x0088
 //#define RK3288_PMU_GPIO0_C_IOMUX	0x008c
 //#define RK3288_PMU_GPIO0_D_IOMUX	0x0090
-
-
 //pin=0x0a21  gpio0a2,port=0,bank=a,b_gpio=2,fun=1
 static inline void pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun)
 { 
@@ -1159,7 +1339,7 @@ static inline u8 pin_get_pullset(u8 port,u8 bank,u8 b_gpio)
 //RKPM_GPIOS_INPUT
 static inline void gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type)
 {
-    u8 val;    
+    u32 val;    
     
     bank-=0xa;
     b_gpio=bank*8+b_gpio;//
@@ -1184,7 +1364,7 @@ static inline u8 gpio_get_in_outputset(u8 port,u8 bank,u8 b_gpio)
 //RKPM_GPIOS_OUT_L   RKPM_GPIOS_OUT_H
 static inline void gpio_set_output_level(u8 port,u8 bank,u8 b_gpio,u8 level)
 {
-    u8 val;    
+    u32 val;    
 
     bank-=0xa;
     b_gpio=bank*8+b_gpio;
@@ -1214,6 +1394,35 @@ static inline u8 gpio_get_input_level(u8 port,u8 bank,u8 b_gpio)
 
     return (reg_readl(RK_GPIO_VIRT(port)+GPIO_EXT_PORT)>>b_gpio)&0x1;
 }
+static inline void gpio_set_inten(u8 port,u8 bank,u8 b_gpio,u8 en)
+{
+    u32 val;    
+
+    bank-=0xa;
+    b_gpio=bank*8+b_gpio;
+        
+    val=reg_readl(RK_GPIO_VIRT(port)+GPIO_INTEN);
+    rkpm_ddr_printascii("\n inten:");
+    rkpm_ddr_printhex(val);
+    
+    rkpm_ddr_printascii("-");
+    if(en==1)
+        val|=(0x1<<b_gpio);
+    else //
+        val&=~(0x1<<b_gpio);
+
+    reg_writel(val,RK_GPIO_VIRT(port)+GPIO_INTEN);
+    dsb();
+     
+     rkpm_ddr_printhex(val);
+     rkpm_ddr_printascii("-");
+     
+     rkpm_ddr_printhex(reg_readl(RK_GPIO_VIRT(port)+GPIO_INTEN));
+    
+    rkpm_ddr_printascii("\n");
+
+     
+}
 
 static void __sramfunc sram_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun)
 { 
@@ -1587,12 +1796,45 @@ static void gtclks_suspend(void)
                                           //          ,RK3288_CRU_CLKGATES_CON(RK3288_CRU_CLKGATES_CON_CNT-1));
     for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
     {
-            clk_ungt_save[i]=cru_readl(RK3288_CRU_CLKGATES_CON(i));    
-           //if(RK3288_CRU_CLKGATES_CON(i)<0x170||RK3288_CRU_CLKGATES_CON(i)>0x194)
+            clk_ungt_save[i]=cru_readl(RK3288_CRU_CLKGATES_CON(i));   
+           // 160 1a8
+           #if 0
+           if(
+               // RK3288_CRU_CLKGATES_CON(i)==0x160 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x164 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x168 ||
+              //  RK3288_CRU_CLKGATES_CON(i)==0x16c ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x170 ||
+               // RK3288_CRU_CLKGATES_CON(i)==0x174 ||
+               // RK3288_CRU_CLKGATES_CON(i)==0x178 ||
+
+           
+                //RK3288_CRU_CLKGATES_CON(i)==0x17c ||
+               // RK3288_CRU_CLKGATES_CON(i)==0x180 ||
+               // RK3288_CRU_CLKGATES_CON(i)==0x184 ||
+               // RK3288_CRU_CLKGATES_CON(i)==0x188 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x18c ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x190 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x194 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x198 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x19c ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x1a0 ||
+                //RK3288_CRU_CLKGATES_CON(i)==0x1a4 ||      
+               // RK3288_CRU_CLKGATES_CON(i)==0x1a8
+               RK3288_CRU_CLKGATES_CON(i)==0xfff
+            )
             {
-                CLK_MSK_UNGATING(clk_ungt_msk[i],RK3288_CRU_CLKGATES_CON(i));
+            
+                 cru_writel(0xffff0000, RK3288_CRU_CLKGATES_CON(i));
+               // CLK_MSK_UNGATING(clk_ungt_msk[i],RK3288_CRU_CLKGATES_CON(i));
             
             }
+           else
+            #endif
+            {
+               // if(RK3288_CRU_CLKGATES_CON(i)!=0x188 )
+               CLK_MSK_UNGATING(clk_ungt_msk[i],RK3288_CRU_CLKGATES_CON(i));
+           }
            #if 0
             rkpm_ddr_printch('\n');   
             rkpm_ddr_printhex(RK3288_CRU_CLKGATES_CON(i));
@@ -1620,27 +1862,6 @@ static void gtclks_resume(void)
 }
 /********************************pll power down***************************************/
 
-enum rk_plls_id {
-	APLL_ID = 0,
-	DPLL_ID,
-	CPLL_ID,
-	GPLL_ID,
-	NPLL_ID,
-	END_PLL_ID,
-};
-
-#define RK3288_PLL_PWR_DN_MSK (0x1<<1)
-#define RK3288_PLL_PWR_DN CRU_W_MSK_SETBITS(1,1,0x1)
-#define RK3288_PLL_PWR_ON CRU_W_MSK_SETBITS(0,1,0x1)
-
-
-#define RK3288_PLL_RESET		CRU_W_MSK_SETBITS(1,5,0x1)
-#define RK3288_PLL_RESET_RESUME CRU_W_MSK_SETBITS(0,5,0x1)
-
-#define RK3288_PLL_BYPASS_MSK (0x1<<0)
-#define RK3288_PLL_BYPASS CRU_W_MSK_SETBITS(1,0,0x1)
-#define RK3288_PLL_NO_BYPASS CRU_W_MSK_SETBITS(0,0,0x1)
-
 static void pm_pll_wait_lock(u32 pll_idx)
 {
 	u32 delay = 600000U;
@@ -1780,6 +2001,8 @@ static void pm_plls_suspend(void)
                         |CRU_W_MSK_SETBITS(0,8,0x3) // 2   hclk 0 1:1,1 2:1 ,2 4:1
                         |CRU_W_MSK_SETBITS(0,12,0x3)// 2     0~3  1 2 4 8 div
                         , RK3288_CRU_CLKSELS_CON(10));
+    // pmu alive 
+    cru_writel(clk_sel33|CRU_W_MSK_SETBITS(0,0,0x1f)|CRU_W_MSK_SETBITS(0,8,0x1f), RK3288_CRU_CLKSELS_CON(33));
 
     plls_suspend(CPLL_ID);
     plls_suspend(GPLL_ID);
@@ -1800,11 +2023,21 @@ static void pm_plls_suspend(void)
                         |CRU_W_MSK_SETBITS(0,12,0x7)//core3
                       , RK3288_CRU_CLKSELS_CON(36));
     // l2ram atclk pclk
+    #if 1
     cru_writel(0
                     |CRU_W_MSK_SETBITS(3,0,0x7) // l2ram
                     |CRU_W_MSK_SETBITS(0xf,4,0x1f) // atclk
                      |CRU_W_MSK_SETBITS(0xf,9,0x1f) // pclk dbg
                      , RK3288_CRU_CLKSELS_CON(37));
+    #else
+    cru_writel(0
+                      |CRU_W_MSK_SETBITS(0,0,0x7) // l2ram
+                      |CRU_W_MSK_SETBITS(0x2,4,0x1f) // atclk
+                       |CRU_W_MSK_SETBITS(0x2,9,0x1f) // pclk dbg
+                       , RK3288_CRU_CLKSELS_CON(37));
+    #endif
+
+    
     plls_suspend(APLL_ID);
 
 }
@@ -1812,7 +2045,6 @@ static void pm_plls_suspend(void)
 static void pm_plls_resume(void)
 {
 
-        plls_resume(APLL_ID);    
 
         // core_m0 core_mp a12_core
         cru_writel(clk_sel0|(CRU_W_MSK(0,0xf)|CRU_W_MSK(4,0xf)|CRU_W_MSK(8,0xf)),RK3288_CRU_CLKSELS_CON(0));
@@ -1821,13 +2053,10 @@ static void pm_plls_resume(void)
                         , RK3288_CRU_CLKSELS_CON(36));
         // l2ram atclk pclk
         cru_writel(clk_sel37|(CRU_W_MSK(0,0x7)|CRU_W_MSK(4,0x1f)|CRU_W_MSK(9,0x1f)) , RK3288_CRU_CLKSELS_CON(37));
-
+        
+        plls_resume(APLL_ID);    
         cru_writel(cru_mode_con|(RK3288_PLL_MODE_MSK(APLL_ID)<<16), RK3288_CRU_MODE_CON);
-
         
-        plls_resume(GPLL_ID);       
-        plls_resume(CPLL_ID);      
-
         // peri aclk hclk pclk
         cru_writel(clk_sel10|(CRU_W_MSK(0,0x1f)|CRU_W_MSK(8,0x3)|CRU_W_MSK(12,0x3))
                                                                             , RK3288_CRU_CLKSELS_CON(10));
@@ -1843,8 +2072,11 @@ static void pm_plls_resume(void)
         
           // pmu alive 
         cru_writel(clk_sel33|CRU_W_MSK(0,0x1f)|CRU_W_MSK(8,0x1f), RK3288_CRU_CLKSELS_CON(33));
-          
+
+        plls_resume(GPLL_ID);   
         cru_writel(cru_mode_con|(RK3288_PLL_MODE_MSK(GPLL_ID)<<16), RK3288_CRU_MODE_CON);       
+        
+        plls_resume(CPLL_ID);    
         cru_writel(cru_mode_con|(RK3288_PLL_MODE_MSK(CPLL_ID)<<16), RK3288_CRU_MODE_CON);
         
         plls_resume(NPLL_ID);       
@@ -2048,7 +2280,8 @@ static void __init  rk3288_suspend_init(void)
             return ;
     }
     PM_LOG("%s: pm_ctrbits =%x\n",__FUNCTION__,pm_ctrbits);
-    
+    pm_io_base_map();
+    memset(&sleep_resume_data[0],0,sizeof(sleep_resume_data));
     rkpm_set_ctrbits(pm_ctrbits);
     
     clks_gating_suspend_init();
@@ -2056,10 +2289,14 @@ static void __init  rk3288_suspend_init(void)
     rkpm_set_ops_plls(pm_plls_suspend,pm_plls_resume);
     
     //rkpm_set_sram_ops_ddr(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_leakage_tst)),NULL);
+    
     rkpm_set_ops_prepare_finish(rkpm_prepare,rkpm_finish);
+    
     //rkpm_set_ops_regs_pread(interface_ctr_reg_pread);  
     
-    rkpm_set_ops_regs_sleep(pm_sleep_func_save,rkpm_slp_mode_set,pm_sleep_func_rusume_first,pm_sleep_func_rusume_last);
+     rkpm_set_ops_save_setting(rkpm_save_setting,rkpm_save_setting_resume);
+     rkpm_set_ops_regs_sleep(rkpm_slp_setting,rkpm_save_setting_resume_first);//rkpm_slp_setting
+
     if(rockchip_pie_chunk)
         rkpm_set_sram_ops_printch(fn_to_pie(rockchip_pie_chunk, &FUNC(sram_printch)));
     
diff --git a/arch/arm/mach-rockchip/pm.c b/arch/arm/mach-rockchip/pm.c
old mode 100755
new mode 100644
index e8bd3be53a45..0ae52e633ff6
--- a/arch/arm/mach-rockchip/pm.c
+++ b/arch/arm/mach-rockchip/pm.c
@@ -93,6 +93,14 @@ void rkpm_set_ops_gpios(rkpm_ops_void_callback gpios,rkpm_ops_void_callback re_g
 	pm_ops.gpios=gpios;	
 	pm_ops.re_gpios=re_gpios;
 }
+void rkpm_set_ops_save_setting(rkpm_ops_paramter_u32_cb save_setting,rkpm_ops_void_callback re_save_setting)
+{
+	pm_ops.save_setting=save_setting;	
+	pm_ops.re_save_setting=re_save_setting;
+}
+
+
+
 void rkpm_set_ops_printch(rkpm_ops_printch_callback printch)
 {
 	pm_ops.printch=printch;	
@@ -103,13 +111,12 @@ void rkpm_set_ops_regs_pread(rkpm_ops_void_callback regs_pread)
 	pm_ops.regs_pread=regs_pread;	
 }
 
-void rkpm_set_ops_regs_sleep(rkpm_ops_void_callback save,rkpm_ops_paramter_u32_cb setting
-                                                                ,rkpm_ops_void_callback re_first,rkpm_ops_void_callback re_last)
-{
-	pm_ops.slp_save=save;
-	pm_ops.slp_setting=setting;
-	pm_ops.slp_re_first=re_first;
-	pm_ops.slp_re_last=re_last;    
+void rkpm_set_ops_regs_sleep(rkpm_ops_void_callback slp_setting,rkpm_ops_void_callback re_last)
+{	
+
+	pm_ops.slp_setting=slp_setting;    
+
+	pm_ops.slp_re_first=re_last;    
 }
 
 
@@ -179,19 +186,16 @@ u32  inline rkpm_get_ctrbits(void)
 {	
 	return rkpm_ctrbits;
 }
-void inline  rkpm_add_ctrbit(int bit)
-{	
-	rkpm_ctrbits|=bit;
-}
-u32 inline  rkpm_chk_ctrbit(int bit)
+
+u32 inline  rkpm_chk_ctrbits(u32 bits)
 {	
-	return (rkpm_ctrbits&bit);
+	return (rkpm_ctrbits&bits);
 }
 
 //clear
-void inline rkpm_clr_ctrbit(int bit)
+void inline rkpm_clr_ctrbits(u32 bits)
 {
-	rkpm_ctrbits&=~bit;
+	rkpm_ctrbits&=~bits;
 }
 
 /****************** for pm.c************************/
@@ -206,21 +210,24 @@ static u32  inline rkpm_get_jdg_ctrbits(void)
 	return rkpm_jdg_ctrbits;
 }
 
-static void inline rkpm_add_jdg_ctrbit(int bit)
+static void inline rkpm_add_jdg_ctrbits(int bit)
 {	
 	rkpm_jdg_ctrbits|=bit;
 }
 
+#if 0
 static u32 inline rkpm_chk_jdg_ctrbit(int bit)
 {	
 	return (rkpm_jdg_ctrbits&bit);
 }
+#endif
+
 static u32 inline rkpm_chk_jdg_ctrbits(int bits)
 {	
 	return (rkpm_jdg_ctrbits&bits);
 }
 //clear
-static void inline rkpm_clr_jdg_ctrbit(int bit)
+static void inline rkpm_clr_jdg_ctrbits(int bit)
 {
 	rkpm_jdg_ctrbits&=~bit;
 }
@@ -230,16 +237,13 @@ static void inline rkpm_clr_jdg_ctrbit(int bit)
 	if(pm_ops.fun)\
 		(pm_ops.fun)()
 
-// fun with paramater
-#define  RKPM_DDR_PFUN(fun,fun_p) \
-        if(pm_ops.fun_p) \
-            {pm_ops.fun;} while(0)
-
-
-    
+// fun with paramater  param (p1,p2,p3)
+#define  RKPM_DDR_PFUN(fun,param) \
+        if(pm_ops.fun) \
+            {(pm_ops.fun)param;} while(0)
 
 #define  RKPM_BITCTR_DDR_FUN(ctr,fun) \
-	if(rkpm_chk_jdg_ctrbit(RKPM_CTR_##ctr)&&pm_ops.fun)\
+	if(rkpm_chk_jdg_ctrbits(RKPM_CTR_##ctr)&&pm_ops.fun)\
 		(pm_ops.fun)()
 
 #define  RKPM_BITSCTR_DDR_FUN(bits,fun) \
@@ -247,6 +251,17 @@ static void inline rkpm_clr_jdg_ctrbit(int bit)
             (pm_ops.fun)()
 
 
+        
+#define  RKPM_LPMD_BITSCTR_DDR_PFUN(bits,fun,param) \
+                if(rkpm_chk_jdg_ctrbits(RKPM_CTRBITS_SOC_DLPMD)&&pm_ops.fun)\
+                    (pm_ops.fun)param
+
+#define  RKPM_LPMD_BITSCTR_DDR_FUN(bits,fun) \
+                if(rkpm_chk_jdg_ctrbits(RKPM_CTRBITS_SOC_DLPMD)&&pm_ops.fun)\
+                        (pm_ops.fun)()
+
+
+
 void rkpm_ctrbits_prepare(void)
 {
 	
@@ -255,15 +270,15 @@ void rkpm_ctrbits_prepare(void)
 	rkpm_jdg_ctrbits=rkpm_ctrbits;
 
         //if plls is no pd,clk rate is high, volts can not setting low,so we need to judge ctrbits
-	//if(rkpm_chk_jdg_ctrbit(RKPM_CTR_VOLTS))
+	//if(rkpm_chk_jdg_ctrbits(RKPM_CTR_VOLTS))
 	{
-		//rkpm_clr_jdg_ctrbit(RKPM_CTR_VOLTS);
+		//rkpm_clr_jdg_ctrbits(RKPM_CTR_VOLTS);
 	}
     
         rkpm_jdg_sram_ctrbits=rkpm_jdg_ctrbits;
         
         //clk gating will gate ddr clk in sram
-        if(!rkpm_chk_val_ctrbit(rkpm_jdg_sram_ctrbits,RKPM_CTR_DDR))
+        if(!rkpm_chk_val_ctrbits(rkpm_jdg_sram_ctrbits,RKPM_CTR_DDR))
         {
            // rkpm_clr_val_ctrbit(rkpm_jdg_sram_ctrbits,RKPM_CTR_GTCLKS);
         }
@@ -373,8 +388,10 @@ void  rkpm_ddr_printhex(unsigned int hex)
 static int rk_lpmode_enter(unsigned long arg)
 {
 
-        RKPM_DDR_PFUN(slp_setting(rkpm_jdg_sram_ctrbits),slp_setting); 
-        
+        //RKPM_DDR_PFUN(slp_setting(rkpm_jdg_sram_ctrbits),slp_setting); 
+    
+        RKPM_DDR_FUN(slp_setting); 
+                
         local_flush_tlb_all();
         flush_cache_all();
         outer_flush_all();
@@ -386,6 +403,8 @@ static int rk_lpmode_enter(unsigned long arg)
         
         rkpm_ddr_printch('d');
 
+        //rkpm_udelay(3*10);
+
         dsb();
         wfi();  
         
@@ -400,15 +419,17 @@ static int rkpm_enter(suspend_state_t state)
 {
  
         printk("%s\n",__FUNCTION__);
+
+        
+        RKPM_DDR_FUN(prepare);   
+        
         printk(KERN_DEBUG "pm: ");
 
         rkpm_ctrbits_prepare();
-
-      //  if(rkpm_chk_jdg_ctrbit(RKPM_CTR_RET_DIRT))
+         
+      //  if(rkpm_chk_jdg_ctrbits(RKPM_CTR_RET_DIRT))
       //  return 0;
-
-        RKPM_DDR_FUN(prepare);
-
+      
         rkpm_ddr_printch('0');
 
         RKPM_BITCTR_DDR_FUN(PWR_DMNS,pwr_dmns);
@@ -416,10 +437,11 @@ static int rkpm_enter(suspend_state_t state)
         rkpm_ddr_printch('1');
 
         local_fiq_disable();
-
-        RKPM_BITSCTR_DDR_FUN(RKPM_CTRBITS_SOC_DLPMD,slp_save);
+    
+        RKPM_DDR_PFUN(save_setting,(rkpm_jdg_sram_ctrbits)); 
         
         rkpm_ddr_printch('2');
+        
         RKPM_BITCTR_DDR_FUN(GTCLKS,gtclks);
 
         rkpm_ddr_printch('3');
@@ -440,19 +462,13 @@ static int rkpm_enter(suspend_state_t state)
         {   
             if(cpu_suspend(0,rk_lpmode_enter)==0)
             {
-                rkpm_ddr_printch('d');
                 RKPM_DDR_FUN(slp_re_first);
+                rkpm_ddr_printch('D');
                 //rk_soc_pm_ctr_bits_prepare();
-            }	  	
-        }else if(rkpm_chk_jdg_ctrbit(RKPM_CTR_IDLEAUTO_MD))
-        {
-            RKPM_DDR_PFUN(slp_setting(rkpm_jdg_sram_ctrbits),slp_setting);
-            rkpm_ddr_printch('a');	
-            dsb();
-            wfi();  
-            rkpm_ddr_printch('a');	
+            }	  	              
+            rkpm_ddr_printch('d');          
         }
-        else if(rkpm_chk_jdg_ctrbit(RKPM_CTR_IDLESRAM_MD)&&p_suspend_pie_cb)
+        else if(rkpm_chk_jdg_ctrbits(RKPM_CTR_IDLESRAM_MD)&&p_suspend_pie_cb)
         {
             call_with_stack(p_suspend_pie_cb,&rkpm_jdg_sram_ctrbits, rockchip_sram_stack);
         }
@@ -478,16 +494,18 @@ static int rkpm_enter(suspend_state_t state)
         
         rkpm_ddr_printch('2');
         
-        RKPM_BITSCTR_DDR_FUN(RKPM_CTRBITS_SOC_DLPMD,slp_re_last);
+        RKPM_DDR_FUN(re_save_setting); 
 
         local_fiq_enable();
-
         rkpm_ddr_printch('1');
+        
+
 
         RKPM_BITCTR_DDR_FUN(PWR_DMNS,re_pwr_dmns);
 
         rkpm_ddr_printch('0');
 
+
         pm_log = false;
 
         printk(KERN_CONT "\n");
@@ -495,8 +513,7 @@ static int rkpm_enter(suspend_state_t state)
         rkpm_ddr_printch('\n');
 
         RKPM_DDR_FUN(finish);
-    
-  
+        
         return 0;
 }
 
diff --git a/arch/arm/mach-rockchip/pm.h b/arch/arm/mach-rockchip/pm.h
old mode 100755
new mode 100644
index 811526a227cf..be9b61048257
--- a/arch/arm/mach-rockchip/pm.h
+++ b/arch/arm/mach-rockchip/pm.h
@@ -4,22 +4,34 @@
 
 
 /******************************sleep data in bootram********************************/
-#define PM_BOOT_CODE_OFFSET (0x0)
-#define PM_BOOT_CODE_SIZE	(0x100)
+
+#define RKPM_ALIGN(size,n_byte) (((size+n_byte-1)/n_byte)*n_byte)
 
 // index data off in SLP_DATA_SAVE_BASE
 // it may be include in *.s ,so con't use enum type define
 
-#define SLPDATA_L2_CON                       (0)  //cpu resume sp
-#define SLPDATA_SP_ADDR                       (SLPDATA_L2_CON+1)  //cpu resume sp
-#define SLPDATA_SP_CPU_RESUME          (SLPDATA_SP_ADDR+1)  //cpu resume sp
-#define SLPDATA_DDR_NEED_RES            (SLPDATA_SP_CPU_RESUME+1)  //ddr ctrl is need to resume
-#define SLPDATA_DPLL_NEED_RES           (SLPDATA_DDR_NEED_RES+1) //ddr pll is need to resume
-#define SLPDATA_DDR_CODE_PHY            (SLPDATA_DPLL_NEED_RES+1) //ddr resume code phy
-#define SLPDATA_DDR_DATA_PHY            (SLPDATA_DDR_CODE_PHY+1) //ddr resume data phy
-#define SLPDATA_SLEEP_RES_CON_CNT	              (SLPDATA_DDR_DATA_PHY+1)
+#define RKPM_BOOTDATA_L2LTY_F             (0)  //save l2 latency val
+#define RKPM_BOOTDATA_L2LTY             (RKPM_BOOTDATA_L2LTY_F+1)
+#define RKPM_BOOTDATA_CPUSP            (RKPM_BOOTDATA_L2LTY+1)  //cpu sp addr
+#define RKPM_BOOTDATA_CPUCODE       (RKPM_BOOTDATA_CPUSP+1)  //cpu resume fun,phy base
+#define RKPM_BOOTDATA_DDR_F            (RKPM_BOOTDATA_CPUCODE+1)  //ddr flag , 1 need to resume ddr ctr
+#define RKPM_BOOTDATA_DPLL_F          (RKPM_BOOTDATA_DDR_F+1) //ddr pll flag, 1  need to resume dpll
+#define RKPM_BOOTDATA_DDRCODE       (RKPM_BOOTDATA_DPLL_F+1) //ddr resume code ,phy base
+#define RKPM_BOOTDATA_DDRDATA       (RKPM_BOOTDATA_DDRCODE+1) //ddr resume data ,phy base
+#define RKPM_BOOTDATA_ARR_SIZE  (RKPM_BOOTDATA_DDRDATA+1)
+
+
+
+#define RKPM_BOOT_CODE_OFFSET (0x0)
+#define RKPM_BOOT_CODE_SIZE	(0x100)
+
+#define RKPM_BOOT_DATA_OFFSET (RKPM_BOOT_CODE_OFFSET+RKPM_BOOT_CODE_SIZE)
+#define RKPM_BOOT_DATA_SIZE	(RKPM_BOOTDATA_ARR_SIZE*4)
+
+#define RKPM_BOOT_DDRCODE_OFFSET (RKPM_BOOT_DATA_OFFSET+RKPM_BOOT_DATA_SIZE)
+
+
 
-#define PM_BOOT_DATA_SIZE   (SLPDATA_SLEEP_RES_CON_CNT*4) // all index
 
 
 #define RKPM_CTRBITS_SOC_DLPMD RKPM_OR_5BITS(ARMDP_LPMD ,ARMOFF_LPMD ,ARMLOGDP_LPMD ,ARMOFF_LOGDP_LPMD,ARMLOGOFF_DLPMD)
@@ -62,11 +74,14 @@ struct rkpm_ops {
 	
 	rkpm_ops_void_callback  gpios;
 	rkpm_ops_void_callback  re_gpios;
+    
+        rkpm_ops_paramter_u32_cb save_setting;  //idle \ sleep mode save and setting
+	rkpm_ops_void_callback re_save_setting;
 
-        rkpm_ops_void_callback  slp_save;       
-        rkpm_ops_paramter_u32_cb  slp_setting;
+       
+        rkpm_ops_void_callback  slp_setting;
         rkpm_ops_void_callback  slp_re_first;
-        rkpm_ops_void_callback  slp_re_last;
+        //rkpm_ops_void_callback  slp_re_last;
     
         rkpm_ops_printch_callback printch;
 
@@ -104,7 +119,7 @@ struct rkpm_gpios_info_st{
 
 /******************ctr bits setting  ************************/
 
-#define rkpm_chk_val_ctrbit(val,bit) ((val)&(bit))//check bit
+//#define rkpm_chk_val_ctrbit(val,bit) ((val)&(bit))//check bit
 #define rkpm_chk_val_ctrbits(val,bits) ((val)&(bits))  //check bits
 
 /************************************reg ops*****************************************************/
@@ -148,8 +163,8 @@ extern void rkpm_set_ops_plls(rkpm_ops_void_callback plls,rkpm_ops_void_callback
 extern void rkpm_set_ops_gpios(rkpm_ops_void_callback gpios,rkpm_ops_void_callback re_gpios);
 extern void rkpm_set_ops_printch(rkpm_ops_printch_callback printch);
 extern void rkpm_set_ops_regs_pread(rkpm_ops_void_callback regs_pread);
-extern void rkpm_set_ops_regs_sleep(rkpm_ops_void_callback save,rkpm_ops_paramter_u32_cb setting
-                                                                ,rkpm_ops_void_callback re_first,rkpm_ops_void_callback re_last);
+extern void rkpm_set_ops_save_setting(rkpm_ops_paramter_u32_cb save_setting,rkpm_ops_void_callback re_save_setting);
+extern void rkpm_set_ops_regs_sleep(rkpm_ops_void_callback slp_setting,rkpm_ops_void_callback re_last);
 
 extern void rkpm_set_sram_ops_volt(rkpm_ops_void_callback volts,rkpm_ops_void_callback re_volts);
 extern void rkpm_set_sram_ops_gtclks(rkpm_ops_void_callback gtclks,rkpm_ops_void_callback re_gtclks);
@@ -160,9 +175,7 @@ extern void rkpm_set_sram_ops_printch(rkpm_ops_printch_callback printch);
 
 extern void inline rkpm_set_ctrbits(u32 bits);
 extern u32  inline rkpm_get_ctrbits(void);
-extern void inline  rkpm_set_ctrbit(int idxs);
-extern u32 inline  rkpm_get_ctrbit(int idxs);
-extern void inline rkpm_clr_ctrbit(int idxs);//clear
+extern void inline rkpm_clr_ctrbits(u32 bits);//clear
 
 extern void rkpm_ddr_printch(char byte);
 extern void rkpm_ddr_printascii(const char *s);
diff --git a/arch/arm/mach-rockchip/rk3288.c b/arch/arm/mach-rockchip/rk3288.c
old mode 100755
new mode 100644
index ec7c48f745cd..407f5112a8d5
--- a/arch/arm/mach-rockchip/rk3288.c
+++ b/arch/arm/mach-rockchip/rk3288.c
@@ -291,6 +291,10 @@ static int rk3288_pmu_set_power_domain(enum pmu_power_domain pd, bool on)
 			writel_relaxed(0x20002 << (pd - PD_CPU_1), RK_CRU_VIRT + RK3288_CRU_SOFTRSTS_CON(0));
 			dsb();
 		}
+                 else if (pd == PD_PERI) {
+			rk3288_pmu_set_idle_request(IDLE_REQ_PERI, true);
+		}
+        
 	}
 
 	rk3288_do_pmu_set_power_domain(pd, on);
@@ -327,6 +331,9 @@ static int rk3288_pmu_set_power_domain(enum pmu_power_domain pd, bool on)
 			writel_relaxed(0xDEADBEAF, RK3288_IMEM_VIRT + 4);
 			dsb_sev();
 		}
+                else if (pd == PD_PERI) {
+			rk3288_pmu_set_idle_request(IDLE_REQ_PERI, false);
+		}
 	}
 
 out:
@@ -545,25 +552,39 @@ static inline void rk_pm_soc_pd_resume(void)
     rkpm_ddr_printascii("\n");
 #endif    
 }
+void inline rkpm_periph_pd_dn(bool on)
+{
+    rk3288_sys_set_power_domain(PD_PERI, on);
+}
 
-extern bool console_suspend_enabled;
-
-static void rk3288_init_suspend(void)
+static void __init rk3288_init_suspend(void)
 {
     printk("%s\n",__FUNCTION__);
     rockchip_suspend_init();       
     //rkpm_pie_init();
     rk3288_suspend_init();
    rkpm_set_ops_pwr_dmns(rk_pm_soc_pd_suspend,rk_pm_soc_pd_resume);  
-    #if 0    
-    console_suspend_enabled=0;
-    do{
-        pm_suspend(PM_SUSPEND_MEM);
-    }
-    while(1);
-    #endif
 }
 
+
+extern bool console_suspend_enabled;
+
+static int  __init rk3288_pm_dbg(void)
+{
+#if 1    
+        console_suspend_enabled=0;
+        do{
+            pm_suspend(PM_SUSPEND_MEM);
+        }
+        while(1);
+        
+#endif
+
+}
+
+//late_initcall_sync(rk3288_pm_dbg);
+
+
 #endif
 #define sram_printascii(s) do {} while (0) /* FIXME */
 #include "ddr_rk32.c"
diff --git a/arch/arm/mach-rockchip/sleep.S b/arch/arm/mach-rockchip/sleep.S
old mode 100755
new mode 100644
index 41042428758c..f1cd0efb485c
--- a/arch/arm/mach-rockchip/sleep.S
+++ b/arch/arm/mach-rockchip/sleep.S
@@ -22,15 +22,14 @@ ENDPROC(rkpm_slp_cpu_while_tst)
 //65 A   48 0  97 a
 ENTRY(rkpm_slp_cpu_resume)
 9:	mov r1,r1 
-        //b 9b
+       // b 9b
+        mov r1,r1 
     #if 0    
 	ldr r4, = 0xFF690000
 	mov r5, #65
 	str r5,[r4]
     #endif
-       
-       
-	setmode	PSR_I_BIT | PSR_F_BIT | SVC_MODE, r1  @ set SVC, irqs off
+       	setmode	PSR_I_BIT | PSR_F_BIT | SVC_MODE, r1  @ set SVC, irqs off
 
 	MRC p15,0,R1,c0,c0,5
 	AND     R1,R1,#0xf
@@ -86,26 +85,37 @@ v7_invalidate_l1:
 	mov sp, r1	//setting sp
       #endif
       1:  mov r1,r1 
-        //b 1b
+         //b 1b
+
       
 	adr r1,9b     // boot ram base
-        ldr r2,2f     // resume data  offset ,from ram base
-        add r2,r2,r1 // resume data addr
+        ldr r5,8f     // resume data  offset ,from ram base
+        add r5,r5,r1 // resume data addr
         
         //l2
-        ldr r3 ,[r2,#(SLPDATA_L2_CON*4)]
+        ldr r3 ,[r5,#(RKPM_BOOTDATA_L2LTY*4)]
         mcr p15, 1, r3, c9, c0, 2
 
         //sp
-        ldr sp,[r2,#(SLPDATA_SP_ADDR*4)]   //sp      
+        ldr sp,[r5,#(RKPM_BOOTDATA_CPUSP*4)]   //sp      
         
-	ldr r3,[r2,#(SLPDATA_DDR_NEED_RES*4)]   //get SLP_DDR_NEED_RES ,if it is 1 ,ddr need to reusme	
+	ldr r3,[r5,#(RKPM_BOOTDATA_DDR_F*4)]   //get SLP_DDR_NEED_RES ,if it is 1 ,ddr need to reusme	
 	cmp r3,#1
 	bne res
-	ldr r1,[r2,#(SLPDATA_DDR_CODE_PHY*4)]  // ddr resume code
-	ldr r0,[r2,#(SLPDATA_DDR_DATA_PHY*4)]  //ddr resume data
+	ldr r1,[r5,#(RKPM_BOOTDATA_DDRCODE*4)]  // ddr resume code
+	ldr r0,[r5,#(RKPM_BOOTDATA_DDRDATA*4)]  //ddr resume data
 	blx r1
 res:	
-	ldr     pc, [r2,#(SLPDATA_SP_CPU_RESUME*4)]
-2:      .long (PM_BOOT_CODE_OFFSET+PM_BOOT_CODE_SIZE)
+        1:  mov r1,r1
+        //  b 1b
+       #if 0    
+        ldr r4, = (0xFF730000+0x18)
+        ldr r7,[r4]
+        ldr r6,=(0x3<<21)
+        orr r7, r7,r6
+        str r7,[r4]
+       #endif
+       
+	ldr     pc, [r5,#(RKPM_BOOTDATA_CPUCODE*4)]
+8:      .long (RKPM_BOOT_CODE_OFFSET+RKPM_BOOT_CODE_SIZE)
 ENDPROC(rkpm_slp_cpu_resume)
-- 
2.35.3

