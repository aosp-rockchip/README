From cd6122c33d97af78a32d538c51469fada52ca893 Mon Sep 17 00:00:00 2001
From: zyw <zyw@rock-chips.com>
Date: Wed, 10 Aug 2011 15:41:51 +0800
Subject: [PATCH] add oppo P91 config

---
 arch/arm/configs/rk29_p91_defconfig          | 2328 ++++++++++++++++
 arch/arm/mach-rk29/Kconfig                   |    7 +
 arch/arm/mach-rk29/Makefile                  |    1 +
 arch/arm/mach-rk29/board-rk29-p91-key.c      |  120 +
 arch/arm/mach-rk29/board-rk29-p91.c          | 1973 +++++++++++++
 arch/arm/mach-rk29/include/mach/board.h      |   10 +
 drivers/input/touchscreen/Kconfig            |   29 +
 drivers/input/touchscreen/Makefile           |    1 +
 drivers/input/touchscreen/atmel_mxt1386.c    | 2625 ++++++++++++++++++
 drivers/input/touchscreen/atmel_mxt1386.h    |  295 ++
 drivers/video/display/screen/Kconfig         |    2 +
 drivers/video/display/screen/Makefile        |    1 +
 drivers/video/display/screen/lcd_tx23d88vm.c |   78 +
 13 files changed, 7470 insertions(+)
 create mode 100644 arch/arm/configs/rk29_p91_defconfig
 create mode 100644 arch/arm/mach-rk29/board-rk29-p91-key.c
 create mode 100644 arch/arm/mach-rk29/board-rk29-p91.c
 create mode 100644 drivers/input/touchscreen/atmel_mxt1386.c
 create mode 100644 drivers/input/touchscreen/atmel_mxt1386.h
 create mode 100644 drivers/video/display/screen/lcd_tx23d88vm.c

diff --git a/arch/arm/configs/rk29_p91_defconfig b/arch/arm/configs/rk29_p91_defconfig
new file mode 100644
index 000000000000..2b8ab2111373
--- /dev/null
+++ b/arch/arm/configs/rk29_p91_defconfig
@@ -0,0 +1,2328 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.27
+# Mon Aug  1 17:24:26 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_LZO=y
+# CONFIG_SWAP is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_BCMRING is not set
+CONFIG_ARCH_RK29=y
+# CONFIG_MACH_RK29SDK is not set
+# CONFIG_MACH_RK29SDK_DDR3 is not set
+# CONFIG_MACH_RK29WINACCORD is not set
+# CONFIG_MACH_RK29FIH is not set
+# CONFIG_MACH_RK29_MALATA is not set
+# CONFIG_MACH_RK29_PHONESDK is not set
+# CONFIG_MACH_RK29_A22 is not set
+# CONFIG_MACH_RK29_PHONEPADSDK is not set
+# CONFIG_MACH_RK29_newton is not set
+CONFIG_MACH_RK29_OPPO=y
+# CONFIG_DDR_TYPE_DDRII is not set
+# CONFIG_DDR_TYPE_LPDDR is not set
+# CONFIG_DDR_TYPE_DDR3_800D is not set
+# CONFIG_DDR_TYPE_DDR3_800E is not set
+# CONFIG_DDR_TYPE_DDR3_1066E is not set
+# CONFIG_DDR_TYPE_DDR3_1066F is not set
+# CONFIG_DDR_TYPE_DDR3_1066G is not set
+# CONFIG_DDR_TYPE_DDR3_1333F is not set
+# CONFIG_DDR_TYPE_DDR3_1333G is not set
+# CONFIG_DDR_TYPE_DDR3_1333H is not set
+# CONFIG_DDR_TYPE_DDR3_1333J is not set
+# CONFIG_DDR_TYPE_DDR3_1600G is not set
+# CONFIG_DDR_TYPE_DDR3_1600H is not set
+# CONFIG_DDR_TYPE_DDR3_1600J is not set
+# CONFIG_DDR_TYPE_DDR3_1600K is not set
+# CONFIG_DDR_TYPE_DDR3_1866J is not set
+# CONFIG_DDR_TYPE_DDR3_1866K is not set
+# CONFIG_DDR_TYPE_DDR3_1866L is not set
+# CONFIG_DDR_TYPE_DDR3_1866M is not set
+# CONFIG_DDR_TYPE_DDR3_2133K is not set
+# CONFIG_DDR_TYPE_DDR3_2133L is not set
+# CONFIG_DDR_TYPE_DDR3_2133M is not set
+# CONFIG_DDR_TYPE_DDR3_2133N is not set
+CONFIG_DDR_TYPE_DDR3_DEFAULT=y
+CONFIG_RK29_MEM_SIZE_M=512
+CONFIG_DDR_SDRAM_FREQ=400
+# CONFIG_DDR_RECONFIG is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+
+#
+# RK29 VPU (Video Processing Unit) support
+#
+CONFIG_RK29_VPU=y
+CONFIG_RK29_VPU_SERVICE=y
+# CONFIG_RK29_VPU_DEBUG is not set
+CONFIG_RK29_JTAG=y
+CONFIG_RK29_LAST_LOG=y
+
+#
+# support for RK29 power manage 
+#
+# CONFIG_RK29_WORKING_POWER_MANAGEMENT is not set
+# CONFIG_RK29_CLK_SWITCH_TO_32K is not set
+# CONFIG_RK29_GPIO_SUSPEND is not set
+CONFIG_RK29_PWM_INSRAM=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_DEBUG=y
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_HCIBCM4325=y
+CONFIG_IDBLOCK=y
+# CONFIG_WIFI_MAC is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_PM is not set
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND is not set
+CONFIG_MTD_RKNAND=y
+CONFIG_MTD_NAND_RK29XX=y
+CONFIG_MTD_RKNAND_BUFFER=y
+# CONFIG_MTD_EMMC_CLK_POWER_SAVE is not set
+# CONFIG_MTD_NAND_RK29XX_DEBUG is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_ISL29003 is not set
+CONFIG_UID_STAT=y
+# CONFIG_WL127X_RFKILL is not set
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_STE is not set
+# CONFIG_MTK23D is not set
+# CONFIG_FM580X is not set
+# CONFIG_MU509 is not set
+# CONFIG_RK29_NEWTON is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_RK29_SUPPORT_MODEM=y
+CONFIG_MODEM_ROCKCHIP_DEMO=y
+# CONFIG_MODEM_LONGCHEER_U6300V is not set
+# CONFIG_MODEM_THINKWILL_MW100G is not set
+# CONFIG_RK29_GPS is not set
+
+#
+# Motion Sensors Support
+#
+# CONFIG_MPU_NONE is not set
+# CONFIG_SENSORS_MPU3050 is not set
+# CONFIG_SENSORS_MPU6000 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_RK29_VMAC=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_80211=y
+# CONFIG_WIFI_NONE is not set
+CONFIG_BCM4329=y
+# CONFIG_MV8686 is not set
+# CONFIG_BCM4319 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPPOLAC is not set
+# CONFIG_PPPOPNS is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYS_RK29=y
+# CONFIG_SYNAPTICS_SO340010 is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_WM831X_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ILI2102_IIC is not set
+# CONFIG_TOUCHSCREEN_IT7250 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_HANNSTAR_P1003 is not set
+# CONFIG_ATMEL_MXT224 is not set
+# CONFIG_SINTEK_3FA16 is not set
+# CONFIG_EETI_EGALAX is not set
+# CONFIG_TOUCHSCREEN_IT7260 is not set
+# CONFIG_TOUCHSCREEN_GT801_IIC is not set
+# CONFIG_TOUCHSCREEN_GT818_IIC is not set
+# CONFIG_D70_L3188A is not set
+# CONFIG_TOUCHSCREEN_GT819 is not set
+# CONFIG_TOUCHSCREEN_FT5406 is not set
+CONFIG_ATMEL_MXT1386=y
+CONFIG_ATMEL_MXT1386_MAX_X=4095
+CONFIG_ATMEL_MXT1386_MAX_Y=4095
+# CONFIG_ATMEL_MXT1386_DEBUG is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_LPSENSOR_ISL29028 is not set
+# CONFIG_INPUT_LPSENSOR_CM3602 is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_MAG_SENSORS is not set
+CONFIG_G_SENSOR_DEVICE=y
+# CONFIG_GS_MMA7660 is not set
+CONFIG_GS_MMA8452=y
+CONFIG_GS_L3G4200D=y
+# CONFIG_INPUT_JOGBALL is not set
+# CONFIG_LIGHT_SENSOR_DEVICE is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_RK29=y
+CONFIG_SERIAL_RK29_STANDARD=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_CTS_RTS_RK29=y
+# CONFIG_UART0_DMA_RK29 is not set
+CONFIG_UART1_RK29=y
+CONFIG_UART2_RK29=y
+CONFIG_UART2_CTS_RTS_RK29=y
+# CONFIG_UART2_DMA_RK29 is not set
+# CONFIG_UART3_RK29 is not set
+CONFIG_SERIAL_RK29_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_RK29=y
+
+#
+# Now, there are four I2C interfaces selected by developer.
+#
+CONFIG_I2C0_RK29=y
+CONFIG_RK29_I2C0_CONTROLLER=y
+# CONFIG_RK29_I2C0_GPIO is not set
+CONFIG_I2C1_RK29=y
+CONFIG_RK29_I2C1_CONTROLLER=y
+# CONFIG_RK29_I2C1_GPIO is not set
+CONFIG_I2C2_RK29=y
+CONFIG_RK29_I2C2_CONTROLLER=y
+# CONFIG_RK29_I2C2_GPIO is not set
+CONFIG_I2C3_RK29=y
+CONFIG_RK29_I2C3_CONTROLLER=y
+# CONFIG_RK29_I2C3_GPIO is not set
+CONFIG_I2C_DEV_RK29=y
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ADC=y
+# CONFIG_ADC_RK28 is not set
+CONFIG_ADC_RK29=y
+
+#
+# Headset device support
+#
+# CONFIG_RK_HEADSET_DET is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_GPIO_PCA9554 is not set
+# CONFIG_IOEXTEND_TCA6424 is not set
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+# CONFIG_EXPAND_GPIO_SOFT_INTERRUPT is not set
+CONFIG_SPI_FPGA_GPIO_NUM=96
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=16
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_STC3100 is not set
+CONFIG_BATTERY_BQ27510=y
+# CONFIG_BATTERY_BQ27541 is not set
+# CONFIG_BATTERY_BQ3060 is not set
+# CONFIG_CHECK_BATT_CAPACITY is not set
+CONFIG_NO_BATTERY_IC=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TPS65910_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_RK2818_REGULATOR_CHARGE is not set
+# CONFIG_RK2818_REGULATOR_LP8725 is not set
+CONFIG_RK29_PWM_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+# CONFIG_VIDEO_RK29XX_VOUT is not set
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9M112 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9T111 is not set
+# CONFIG_SOC_CAMERA_MT9P111 is not set
+# CONFIG_SOC_CAMERA_MT9D112 is not set
+# CONFIG_SOC_CAMERA_MT9D113 is not set
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV7675 is not set
+# CONFIG_SOC_CAMERA_OV2655 is not set
+CONFIG_SOC_CAMERA_OV2659=y
+# CONFIG_SOC_CAMERA_OV9650 is not set
+# CONFIG_SOC_CAMERA_OV2640 is not set
+# CONFIG_SOC_CAMERA_OV3640 is not set
+CONFIG_SOC_CAMERA_OV5642=y
+CONFIG_OV5642_AUTOFOCUS=y
+# CONFIG_OV5642_FIXEDFOCUS is not set
+# CONFIG_SOC_CAMERA_OV5640 is not set
+# CONFIG_SOC_CAMERA_S5K6AA is not set
+# CONFIG_SOC_CAMERA_GT2005 is not set
+# CONFIG_SOC_CAMERA_GC0308 is not set
+# CONFIG_SOC_CAMERA_GC0309 is not set
+# CONFIG_SOC_CAMERA_GC2015 is not set
+# CONFIG_SOC_CAMERA_HI253 is not set
+# CONFIG_SOC_CAMERA_HI704 is not set
+# CONFIG_SOC_CAMERA_SIV120B is not set
+# CONFIG_SOC_CAMERA_SID130B is not set
+# CONFIG_SOC_CAMERA_NT99250 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RK29_WORK_ONEFRAME=y
+# CONFIG_VIDEO_RK29_WORK_PINGPONG is not set
+CONFIG_VIDEO_RK29_WORK_IPP=y
+# CONFIG_VIDEO_RK29_WORK_NOT_IPP is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_RK2818 is not set
+CONFIG_FB_RK29=y
+CONFIG_FB_WORK_IPP=y
+# CONFIG_FB_SCALING_OSD is not set
+# CONFIG_FB_ROTATE_VIDEO is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_RK29_BL=y
+# CONFIG_FIH_TOUCHKEY_LED is not set
+# CONFIG_BACKLIGHT_AW9364 is not set
+# CONFIG_BUTTON_LIGHT is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=y
+
+#
+# Display hardware drivers
+#
+# CONFIG_LCD_NULL is not set
+# CONFIG_LCD_TD043MGEA1 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_TJ048NC01CA is not set
+# CONFIG_LCD_HL070VM4AU is not set
+# CONFIG_LCD_HSD070IDW1 is not set
+# CONFIG_LCD_RGB_TFT480800_25_E is not set
+# CONFIG_LCD_HSD100PXN is not set
+# CONFIG_LCD_HSD07PFW1 is not set
+# CONFIG_LCD_B101AW06 is not set
+# CONFIG_LCD_LS035Y8DX02A is not set
+# CONFIG_LCD_CPTCLAA038LA31XE is not set
+# CONFIG_LCD_A060SE02 is not set
+# CONFIG_LCD_S1D13521 is not set
+# CONFIG_LCD_NT35582 is not set
+# CONFIG_LCD_NT35580 is not set
+# CONFIG_LCD_IPS1P5680_V1_E is not set
+# CONFIG_LCD_MCU_TFT480800_25_E is not set
+# CONFIG_LCD_NT35510 is not set
+# CONFIG_LCD_ILI9803_CPT4_3 is not set
+# CONFIG_DEFAULT_OUT_HDMI is not set
+# CONFIG_LCD_AT070TNA2 is not set
+# CONFIG_LCD_AT070TN93 is not set
+CONFIG_LCD_TX23D88VM=y
+
+#
+# HDMI
+#
+CONFIG_HDMI=y
+CONFIG_ANX7150=y
+# CONFIG_ANX9030 is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_LOGO_CHARGER_CLUT224 is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_RK29_SOC_I2S=y
+# CONFIG_SND_RK29_SOC_I2S_2CH is not set
+CONFIG_SND_RK29_SOC_I2S_8CH=y
+# CONFIG_SND_RK29_SOC_WM8988 is not set
+CONFIG_SND_RK29_SOC_WM8900=y
+# CONFIG_SND_RK29_SOC_alc5621 is not set
+# CONFIG_SND_RK29_SOC_alc5631 is not set
+# CONFIG_SND_RK29_SOC_RT5625 is not set
+# CONFIG_SND_RK29_SOC_WM8994 is not set
+# CONFIG_SND_RK29_SOC_CS42L52 is not set
+# CONFIG_SND_RK29_CODEC_SOC_MASTER is not set
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM8900=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_OTG_BLACKLIST_HUB=y
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_DWC_OTG=y
+CONFIG_USB_DWC_OTG=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_ANDROID=y
+# CONFIG_USB_ANDROID_ACM is not set
+CONFIG_USB_ANDROID_ADB=y
+CONFIG_USB_ANDROID_MASS_STORAGE=y
+# CONFIG_USB_ANDROID_RNDIS is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB11_HOST is not set
+CONFIG_USB20_HOST=y
+CONFIG_USB20_HOST_EN=y
+CONFIG_USB20_OTG=y
+# CONFIG_DWC_OTG_HOST_ONLY is not set
+CONFIG_DWC_OTG_DEVICE_ONLY=y
+# CONFIG_DWC_OTG_BOTH_HOST_SLAVE is not set
+CONFIG_DWC_CONN_EN=y
+# CONFIG_DWC_OTG_DEBUG is not set
+# CONFIG_DWC_REMOTE_WAKEUP is not set
+CONFIG_DWC_OTG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_SDMMC_RK29=y
+
+#
+# Now, there are two SDMMC controllers selected, SDMMC0 and SDMMC1.
+#
+# CONFIG_SDMMC_RK29_OLD is not set
+CONFIG_SDMMC0_RK29=y
+CONFIG_SDMMC1_RK29=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_HYM8563=y
+# CONFIG_RTC_M41T66 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_S35392A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_DST is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_PLAN9AUTH is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_FB_UDL is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+
+#
+# GPU Vivante
+#
+CONFIG_VIVANTE=y
+
+#
+# IPP
+#
+CONFIG_RK29_IPP=y
+
+#
+# CMMB
+#
+# CONFIG_CMMB is not set
+# CONFIG_TEST_CODE is not set
+# CONFIG_RK29_SMC is not set
+
+#
+# CIR support
+#
+# CONFIG_RK_CIR is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/mach-rk29/Kconfig b/arch/arm/mach-rk29/Kconfig
index 0892d4c42f0b..a5c0611fe1a5 100755
--- a/arch/arm/mach-rk29/Kconfig
+++ b/arch/arm/mach-rk29/Kconfig
@@ -58,6 +58,13 @@ config MACH_RK29_newton
 		bool "ROCKCHIP Board Rk29 For project newton"
 		help
 		  Support for the ROCKCHIP Board For project newton.
+		  
+config MACH_RK29_P91
+	depends on ARCH_RK29
+	bool "ROCKCHIP Board Rk29 For P91"
+        help
+	  Support for the ROCKCHIP Board For Rk29 P91.
+	  
 endchoice
 
 choice DDR_TYPE
diff --git a/arch/arm/mach-rk29/Makefile b/arch/arm/mach-rk29/Makefile
index c55dae8d8550..44e0cf596c78 100755
--- a/arch/arm/mach-rk29/Makefile
+++ b/arch/arm/mach-rk29/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_RK29_VPU_SERVICE) += vpu_service.o
 obj-$(CONFIG_RK29_VPU_OLD) += vpu.o
 obj-$(CONFIG_RK29_PWM_INSRAM) += pwm_sram.o
 obj-$(CONFIG_MACH_RK29SDK) += board-rk29sdk.o board-rk29sdk-key.o board-rk29sdk-rfkill.o board-rk29sdk-power.o
+obj-$(CONFIG_MACH_RK29_P91) += board-rk29-p91.o board-rk29-p91-key.o board-rk29sdk-rfkill.o board-rk29sdk-power.o
 obj-$(CONFIG_MACH_RK29SDK_DDR3) += board-rk29-ddr3sdk.o board-rk29sdk-key.o board-rk29sdk-rfkill.o board-rk29sdk-power.o
 obj-$(CONFIG_MACH_RK29WINACCORD) += board-rk29-winaccord.o board-rk29sdk-key.o
 obj-$(CONFIG_MACH_RK29_MALATA) += board-malata.o board-rk29malata-key.o board-rk29sdk-rfkill.o
diff --git a/arch/arm/mach-rk29/board-rk29-p91-key.c b/arch/arm/mach-rk29/board-rk29-p91-key.c
new file mode 100644
index 000000000000..688319fafd33
--- /dev/null
+++ b/arch/arm/mach-rk29/board-rk29-p91-key.c
@@ -0,0 +1,120 @@
+#include <mach/key.h>
+#include <mach/gpio.h>
+#include <mach/board.h>
+
+#define EV_ENCALL				KEY_F4
+#define EV_MENU					KEY_F1
+
+#define PRESS_LEV_LOW			1
+#define PRESS_LEV_HIGH			0
+
+static struct rk29_keys_button key_button[] = {
+	{
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEDOWN,
+		//.gpio	= RK29_PIN6_PA0,
+		.gpio	= RK29_PIN6_PA1,//modify by xhh
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "menu",
+		.code	= EV_MENU,
+		//.gpio	= RK29_PIN6_PA1,
+		.gpio	= RK29_PIN6_PA0,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "home",
+		.code	= KEY_HOME,
+		//.gpio	= RK29_PIN6_PA2,
+		.gpio	= RK29_PIN6_PA3,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "vol+",
+		.code	= KEY_VOLUMEUP,
+		//.gpio	= RK29_PIN6_PA3,
+		.gpio	= RK29_PIN6_PA2,//modify by xhh
+		.active_low = PRESS_LEV_LOW,
+	},
+#if 0	
+	{
+		.desc	= "search",
+		.code	= KEY_SEARCH,
+		.gpio	= RK29_PIN6_PA4,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_BACK,
+		.gpio	= RK29_PIN6_PA5,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "sensor",
+		.code	= KEY_CAMERA,
+		.gpio	= RK29_PIN6_PA6,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif	
+	{
+		.desc	= "play",
+		.code	= KEY_POWER,
+		.gpio	= RK29_PIN6_PA7,
+		.active_low = PRESS_LEV_LOW,
+		//.code_long_press = EV_ENCALL,
+		.wakeup	= 1,
+	},
+#if 0
+	{
+		.desc	= "vol+",
+		.code	= KEY_VOLUMEDOWN,
+		.adc_value	= 95,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEUP,
+		.adc_value	= 249,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "menu",
+		.code	= EV_MENU,
+		.adc_value	= 406,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "home",
+		.code	= KEY_HOME,
+		.code_long_press = KEY_F4,
+		.adc_value	= 561,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_ESC,
+		.adc_value	= 726,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "adkey6",
+		.code	= KEY_BACK,
+		.code_long_press = EV_ENCALL,
+		.adc_value	= 899,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+};
+struct rk29_keys_platform_data rk29_keys_pdata = {
+	.buttons	= key_button,
+	.nbuttons	= ARRAY_SIZE(key_button),
+	.chn	= -1,  //chn: 0-7, if do not use ADC,set 'chn' -1
+};
+
diff --git a/arch/arm/mach-rk29/board-rk29-p91.c b/arch/arm/mach-rk29/board-rk29-p91.c
new file mode 100644
index 000000000000..cdaa93347a16
--- /dev/null
+++ b/arch/arm/mach-rk29/board-rk29-p91.c
@@ -0,0 +1,1973 @@
+/* arch/arm/mach-rk29/board-rk29.c
+ *
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/android_pmem.h>
+#include <linux/usb/android_composite.h>
+#include <linux/mpu.h> //add by xhh
+
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+
+#include <mach/iomux.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/rk29_iomap.h>
+#include <mach/board.h>
+#include <mach/rk29_nand.h>
+#include <media/soc_camera.h>                               /* ddl@rock-chips.com : camera support */
+#include <mach/rk29_camera.h>                               /* ddl@rock-chips.com : camera support */
+#include <mach/vpu_mem.h>
+#include <mach/sram.h>
+#include <mach/ddr.h>
+
+#include <linux/regulator/rk29-pwm-regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/atmel_maxtouch.h>
+
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/i2c-gpio.h>
+
+#include "devices.h"
+#include "../../../drivers/input/touchscreen/xpt2046_cbn_ts.h"
+
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642                      /* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0 	    0x78
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0    1
+#define CONFIG_SENSOR_POWER_PIN_0         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0       RK29_PIN6_PB7
+#define CONFIG_SENSOR_FALSH_PIN_0         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_1 	    0x60
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1    1
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1       RK29_PIN5_PD7
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk29_camera.c"
+/*---------------- Camera Sensor Macro Define End  ------------------------*/
+
+
+/* Set memory size of pmem */
+#ifdef CONFIG_RK29_MEM_SIZE_M
+#define SDRAM_SIZE          (CONFIG_RK29_MEM_SIZE_M * SZ_1M)
+#else
+#define SDRAM_SIZE          SZ_512M
+#endif
+#define PMEM_GPU_SIZE       SZ_64M
+#define PMEM_UI_SIZE        SZ_32M
+#define PMEM_VPU_SIZE       SZ_64M
+#define PMEM_CAM_SIZE       PMEM_CAM_NECESSARY
+#ifdef CONFIG_VIDEO_RK29_WORK_IPP
+#define MEM_CAMIPP_SIZE     SZ_4M
+#else
+#define MEM_CAMIPP_SIZE     0
+#endif
+//#define MEM_FB_SIZE         (3*SZ_2M)
+#define MEM_FB_SIZE         (4*SZ_2M)//xhh
+#ifdef CONFIG_FB_WORK_IPP
+#define MEM_FBIPP_SIZE      SZ_8M   //1920 x 1080 x 2 x 2  //RGB565 = x2;RGB888 = x4
+#else
+#define MEM_FBIPP_SIZE      0
+#endif
+#if SDRAM_SIZE > SZ_512M
+#define PMEM_GPU_BASE       (RK29_SDRAM_PHYS + SZ_512M - PMEM_GPU_SIZE)
+#else
+#define PMEM_GPU_BASE       (RK29_SDRAM_PHYS + SDRAM_SIZE - PMEM_GPU_SIZE)
+#endif
+#define PMEM_UI_BASE        (PMEM_GPU_BASE - PMEM_UI_SIZE)
+#define PMEM_VPU_BASE       (PMEM_UI_BASE - PMEM_VPU_SIZE)
+#define PMEM_CAM_BASE       (PMEM_VPU_BASE - PMEM_CAM_SIZE)
+#define MEM_CAMIPP_BASE     (PMEM_CAM_BASE - MEM_CAMIPP_SIZE)
+#define MEM_FB_BASE         (MEM_CAMIPP_BASE - MEM_FB_SIZE)
+#define MEM_FBIPP_BASE      (MEM_FB_BASE - MEM_FBIPP_SIZE)
+#define LINUX_SIZE          (MEM_FBIPP_BASE - RK29_SDRAM_PHYS)
+
+#define PREALLOC_WLAN_SEC_NUM           4
+#define PREALLOC_WLAN_BUF_NUM           160
+#define PREALLOC_WLAN_SECTION_HEADER    24
+
+#define WLAN_SECTION_SIZE_0     (PREALLOC_WLAN_BUF_NUM * 128)
+#define WLAN_SECTION_SIZE_1     (PREALLOC_WLAN_BUF_NUM * 128)
+#define WLAN_SECTION_SIZE_2     (PREALLOC_WLAN_BUF_NUM * 512)
+#define WLAN_SECTION_SIZE_3     (PREALLOC_WLAN_BUF_NUM * 1024)
+
+#define WLAN_SKB_BUF_NUM        16
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
+
+struct wifi_mem_prealloc {
+        void *mem_ptr;
+        unsigned long size;
+};
+
+extern struct sys_timer rk29_timer;
+
+static int rk29_nand_io_init(void)
+{
+    return 0;
+}
+
+struct rk29_nand_platform_data rk29_nand_data = {
+    .width      = 1,     /* data bus width in bytes */
+    .hw_ecc     = 1,     /* hw ecc 0: soft ecc */
+    .num_flash    = 1,
+    .io_init   = rk29_nand_io_init,
+};
+
+/*****************************************************************************************
+* touch screen devices
+* author: cf@rock-chips.com
+*****************************************************************************************/
+#define TOUCH_SCREEN_STANDBY_PIN          INVALID_GPIO
+#define TOUCH_SCREEN_STANDBY_VALUE        GPIO_HIGH
+#define TOUCH_SCREEN_DISPLAY_PIN          INVALID_GPIO
+#define TOUCH_SCREEN_DISPLAY_VALUE        GPIO_HIGH
+
+#ifdef CONFIG_FB_RK29
+/*****************************************************************************************
+ * lcd  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+#define LCD_TXD_PIN          INVALID_GPIO
+#define LCD_CLK_PIN          INVALID_GPIO
+#define LCD_CS_PIN           INVALID_GPIO
+/*****************************************************************************************
+* frame buffer devices pin define
+* author: zyw@rock-chips.com
+*****************************************************************************************/
+#define FB_ID                       0
+#define FB_DISPLAY_ON_PIN           RK29_PIN6_PD0
+#define FB_LCD_STANDBY_PIN          RK29_PIN6_PD1
+#define FB_LCD_CABC_EN_PIN          RK29_PIN6_PD2
+#define FB_MCU_FMK_PIN              INVALID_GPIO
+
+#define FB_DISPLAY_ON_VALUE         GPIO_HIGH
+#define FB_LCD_STANDBY_VALUE        GPIO_HIGH
+
+static int rk29_lcd_io_init(void)
+{
+    int ret = 0;
+    return ret;
+}
+
+static int rk29_lcd_io_deinit(void)
+{
+    int ret = 0;
+    return ret;
+}
+
+static struct rk29lcd_info rk29_lcd_info = {
+    .txd_pin  = LCD_TXD_PIN,
+    .clk_pin = LCD_CLK_PIN,
+    .cs_pin = LCD_CS_PIN,
+    .io_init   = rk29_lcd_io_init,
+    .io_deinit = rk29_lcd_io_deinit,
+};
+
+int rk29_fb_io_enable(void)
+{
+    if(FB_DISPLAY_ON_PIN != INVALID_GPIO)
+    {
+        gpio_direction_output(FB_DISPLAY_ON_PIN, 0);
+        gpio_set_value(FB_DISPLAY_ON_PIN, FB_DISPLAY_ON_VALUE);              
+    }
+    if(FB_LCD_STANDBY_PIN != INVALID_GPIO)
+    {
+        gpio_direction_output(FB_LCD_STANDBY_PIN, 0);
+        gpio_set_value(FB_LCD_STANDBY_PIN, FB_LCD_STANDBY_VALUE);             
+    }
+    return 0;
+}
+
+int rk29_fb_io_disable(void)
+{
+    if(FB_DISPLAY_ON_PIN != INVALID_GPIO)
+    {
+        gpio_direction_output(FB_DISPLAY_ON_PIN, 0);
+        gpio_set_value(FB_DISPLAY_ON_PIN, !FB_DISPLAY_ON_VALUE);              
+    }
+    if(FB_LCD_STANDBY_PIN != INVALID_GPIO)
+    {
+        gpio_direction_output(FB_LCD_STANDBY_PIN, 0);
+        gpio_set_value(FB_LCD_STANDBY_PIN, !FB_LCD_STANDBY_VALUE);             
+    }
+    return 0;
+}
+
+static int rk29_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+    int ret = 0;
+    if(fb_setting->mcu_fmk_en && (FB_MCU_FMK_PIN != INVALID_GPIO))
+    {
+        ret = gpio_request(FB_MCU_FMK_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_MCU_FMK_PIN);
+            printk(">>>>>> FB_MCU_FMK_PIN gpio_request err \n ");
+        }
+        gpio_direction_input(FB_MCU_FMK_PIN);
+    }
+    if(fb_setting->disp_on_en)
+    {
+        if(FB_DISPLAY_ON_PIN != INVALID_GPIO)
+        {
+            ret = gpio_request(FB_DISPLAY_ON_PIN, NULL);
+            if(ret != 0)
+            {
+                gpio_free(FB_DISPLAY_ON_PIN);
+                printk(">>>>>> FB_DISPLAY_ON_PIN gpio_request err \n ");
+            }
+        }
+        else
+        {
+             ret = gpio_request(TOUCH_SCREEN_DISPLAY_PIN, NULL);
+             if(ret != 0)
+             {
+                 gpio_free(TOUCH_SCREEN_DISPLAY_PIN);
+                 printk(">>>>>> TOUCH_SCREEN_DISPLAY_PIN gpio_request err \n ");
+             }
+             gpio_direction_output(TOUCH_SCREEN_DISPLAY_PIN, 0);
+             gpio_set_value(TOUCH_SCREEN_DISPLAY_PIN, TOUCH_SCREEN_DISPLAY_VALUE);
+        }
+    }
+
+    if(fb_setting->disp_on_en)
+    {
+        if(FB_LCD_STANDBY_PIN != INVALID_GPIO)
+        {
+             ret = gpio_request(FB_LCD_STANDBY_PIN, NULL);
+             if(ret != 0)
+             {
+                 gpio_free(FB_LCD_STANDBY_PIN);
+                 printk(">>>>>> FB_LCD_STANDBY_PIN gpio_request err \n ");
+             }
+        }
+        else
+        {
+             ret = gpio_request(TOUCH_SCREEN_STANDBY_PIN, NULL);
+             if(ret != 0)
+             {
+                 gpio_free(TOUCH_SCREEN_STANDBY_PIN);
+                 printk(">>>>>> TOUCH_SCREEN_STANDBY_PIN gpio_request err \n ");
+             }
+             gpio_direction_output(TOUCH_SCREEN_STANDBY_PIN, 0);
+             gpio_set_value(TOUCH_SCREEN_STANDBY_PIN, TOUCH_SCREEN_STANDBY_VALUE);
+         }
+    }
+
+    if(FB_LCD_CABC_EN_PIN != INVALID_GPIO)
+    {
+        ret = gpio_request(FB_LCD_CABC_EN_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_LCD_CABC_EN_PIN);
+            printk(">>>>>> FB_LCD_CABC_EN_PIN gpio_request err \n ");
+        }
+        gpio_direction_output(FB_LCD_CABC_EN_PIN, 0);
+        gpio_set_value(FB_LCD_CABC_EN_PIN, GPIO_LOW);
+    }
+
+    gpio_direction_output(FB_DISPLAY_ON_PIN, 0);
+    gpio_direction_output(FB_LCD_STANDBY_PIN, 0);    
+    gpio_direction_output(FB_LCD_CABC_EN_PIN, 0);
+    gpio_set_value(FB_DISPLAY_ON_PIN, GPIO_HIGH);//add by xhh    
+    gpio_set_value(FB_LCD_STANDBY_PIN, GPIO_HIGH);//add by xhh    
+    gpio_set_value(FB_LCD_CABC_EN_PIN, GPIO_HIGH);//add by xhh
+    
+	if(gpio_get_value(FB_LCD_STANDBY_PIN)) //add by xhh
+        {
+        printk(">>>>>> xhh FB_LCD_STANDBY_PIN 11111 \n ");
+        }
+    else
+        {
+        
+        printk(">>>>>> xhh FB_LCD_STANDBY_PIN 00000 \n ");
+        }
+    
+    rk29_fb_io_enable();   //enable it
+
+    return ret;
+}
+
+
+static struct rk29fb_info rk29_fb_info = {
+    .fb_id   = FB_ID,
+    .mcu_fmk_pin = FB_MCU_FMK_PIN,
+    .lcd_info = &rk29_lcd_info,
+    .io_init   = rk29_fb_io_init,
+    .io_enable = rk29_fb_io_enable,
+    .io_disable = rk29_fb_io_disable,
+};
+
+/* rk29 fb resource */
+static struct resource rk29_fb_resource[] = {
+	[0] = {
+        .name  = "lcdc reg",
+		.start = RK29_LCDC_PHYS,
+		.end   = RK29_LCDC_PHYS + RK29_LCDC_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+	    .name  = "lcdc irq",
+		.start = IRQ_LCDC,
+		.end   = IRQ_LCDC,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+	    .name   = "win1 buf",
+        .start  = MEM_FB_BASE,
+        .end    = MEM_FB_BASE + MEM_FB_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    #ifdef CONFIG_FB_WORK_IPP
+    [3] = {
+	    .name   = "win1 ipp buf",
+        .start  = MEM_FBIPP_BASE,
+        .end    = MEM_FBIPP_BASE + MEM_FBIPP_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    #endif
+};
+
+/*platform_device*/
+struct platform_device rk29_device_fb = {
+	.name		  = "rk29-fb",
+	.id		  = 4,
+	.num_resources	  = ARRAY_SIZE(rk29_fb_resource),
+	.resource	  = rk29_fb_resource,
+	.dev            = {
+		.platform_data  = &rk29_fb_info,
+	}
+};
+
+struct platform_device rk29_device_dma_cpy = {
+	.name		  = "dma_memcpy",
+	.id		  = 4,
+
+};
+
+#endif
+
+static struct android_pmem_platform_data android_pmem_pdata = {
+	.name		= "pmem",
+	.start		= PMEM_UI_BASE,
+	.size		= PMEM_UI_SIZE,
+	.no_allocator	= 0,
+	.cached		= 1,
+};
+
+static struct platform_device android_pmem_device = {
+	.name		= "android_pmem",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &android_pmem_pdata,
+	},
+};
+
+
+static struct vpu_mem_platform_data vpu_mem_pdata = {
+	.name		= "vpu_mem",
+	.start		= PMEM_VPU_BASE,
+	.size		= PMEM_VPU_SIZE,
+	.cached		= 1,
+};
+
+static struct platform_device rk29_vpu_mem_device = {
+	.name		= "vpu_mem",
+	.id		    = 2,
+	.dev		= {
+	.platform_data = &vpu_mem_pdata,
+	},
+};
+#ifdef CONFIG_VIDEO_RK29XX_VOUT
+static struct platform_device rk29_v4l2_output_devce = {
+	.name		= "rk29_vout",
+};
+#endif
+/*HANNSTAR_P1003 touch*/
+#if defined (CONFIG_HANNSTAR_P1003)
+#define TOUCH_RESET_PIN RK29_PIN6_PC3
+#define TOUCH_INT_PIN   RK29_PIN0_PA2
+
+int p1003_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+
+    return 0;
+}
+
+
+struct p1003_platform_data p1003_info = {
+  .model= 1003,
+  .init_platform_hw= p1003_init_platform_hw,
+
+};
+#endif
+#if defined (CONFIG_EETI_EGALAX)
+#define TOUCH_RESET_PIN RK29_PIN6_PC3
+#define TOUCH_INT_PIN   RK29_PIN0_PA2
+
+static int EETI_EGALAX_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+
+    return 0;
+}
+
+
+static struct eeti_egalax_platform_data eeti_egalax_info = {
+  .model= 1003,
+  .init_platform_hw= EETI_EGALAX_init_platform_hw,
+  .standby_pin = TOUCH_SCREEN_STANDBY_PIN,
+  .standby_value = TOUCH_SCREEN_STANDBY_VALUE,
+  .disp_on_pin = TOUCH_SCREEN_DISPLAY_PIN,
+  .disp_on_value = TOUCH_SCREEN_DISPLAY_VALUE,
+};
+#endif
+#if defined (CONFIG_ATMEL_MXT1386)
+#define TOUCH_RESET_PIN RK29_PIN6_PC3
+#define TOUCH_INT_PIN   RK29_PIN0_PA2
+
+static int atmel_mxt1386_init_platform_hw(void)
+{
+	printk(KERN_INFO "%s: atmel_mxt1386_init_platform_hw enter!\n", __func__);	/////////////////
+
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("atmel_mxt1386_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("atmel_mxt1386_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    //msleep(10);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(20);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+    msleep(500);
+    
+    return 0;    
+}
+
+u8 mxt_read_chg(void)
+{
+	if(gpio_get_value(TOUCH_INT_PIN))
+		return 1;
+	else
+		return 0;		
+}
+
+    
+static struct atmel_1386_platform_data atmel_mxt1386_platform_info = {
+  .init_platform_hw = atmel_mxt1386_init_platform_hw,
+  .read_chg = mxt_read_chg,
+};
+/*Atmel mxt224 touch*/
+#endif
+
+/**********************************************************************************************
+ *
+ * The virtual keys for android "back", "home", "menu", "search", these four keys are touch key
+ * on the touch screen panel. (added by hhb@rock-chips.com 2011.03.31)
+ *
+ ***********************************************************************************************/
+static ssize_t rk29xx_virtual_keys_show(struct kobject *kobj,
+			                              struct kobj_attribute *attr, char *buf)
+{
+	/* center: x: home: 50, menu: 184, back: 315, search 435, y: 830*/
+    /* centerx;centery;width;height; */
+	return sprintf(buf,
+		    __stringify(EV_KEY) ":" __stringify(KEY_BACK)	":4:2900:4:150"    
+		":" __stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":4:2350:4:150"  
+		":" __stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":4:1750:4:150" 
+		":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":4:1130:4:150"
+		"\n");
+}
+
+static struct kobj_attribute rk29xx_virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.maXTouch-touchscreen",		
+		.mode = S_IRUGO,
+	},
+	.show = &rk29xx_virtual_keys_show,
+};
+
+static struct attribute *rk29xx_properties_attrs[] = {
+	&rk29xx_virtual_keys_attr.attr,
+	NULL
+};
+
+static struct attribute_group rk29xx_properties_attr_group = {
+	.attrs = rk29xx_properties_attrs,
+};
+
+static int rk29xx_virtual_keys_init(void)
+{
+	int ret;
+	struct kobject *properties_kobj;
+	printk("rk29xx_virtual_keys_init \n");
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				&rk29xx_properties_attr_group);
+	if (!properties_kobj || ret)
+	{
+		pr_err("failed to create board_properties\n");
+	}
+	return ret;
+}
+
+
+/*MMA8452 gsensor*/
+#if defined (CONFIG_GS_MMA8452)
+#define MMA8452_INT_PIN   RK29_PIN0_PA3
+
+static int mma8452_init_platform_hw(void)
+{
+
+    if(gpio_request(MMA8452_INT_PIN,NULL) != 0){
+      gpio_free(MMA8452_INT_PIN);
+      printk("mma8452_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(MMA8452_INT_PIN, 1);
+    return 0;
+}
+
+
+static struct mma8452_platform_data mma8452_info = {
+  .model= 8452,
+  .swap_xy = 0,
+  .init_platform_hw= mma8452_init_platform_hw,
+
+};
+#endif
+
+//add by xhh
+#if defined (CONFIG_MPU_SENSORS_MPU3050)
+/*mpu3050*/
+static struct mpu3050_platform_data mpu3050_data = {
+	.int_config = 0x10,
+	//.orientation = { 1, 0, 0,0, -1, 0,0, 0, 1 },
+	//.orientation = { 0, 1, 0,-1, 0, 0,0, 0, -1 },
+	.orientation = { -1, 0, 0,0, -1, 0, 0, 0, -1 },
+	.level_shifter = 0,
+#if defined (CONFIG_SENSORS_KXTF9)
+    .accel = {
+        .get_slave_descr = get_accel_slave_descr ,
+        .adapt_num = 0, // The i2c bus to which the mpu device is
+        // connected
+        .irq = RK29_PIN6_PC4,
+        .bus = EXT_SLAVE_BUS_SECONDARY,  //The secondary I2C of MPU
+        .address = 0x0f,
+        //.orientation = { 1, 0, 0,0, 1, 0,0, 0, 1 },
+        //.orientation = { 0, -1, 0,-1, 0, 0,0, 0, -1 },
+        //.orientation = { 0, 1, 0,1, 0, 0,0, 0, -1 },
+        .orientation = {1, 0, 0, 0, -1, 0, 0, 0, -1},
+    },
+#endif
+
+#ifdef CONFIG_MPU_SENSORS_BMA150
+    .accel = {
+    	.get_slave_descr = get_accel_slave_descr ,			
+    	.adapt_num = 0, // The i2c bus to which the mpu device is
+    	// connected
+    	.irq = RK29_PIN0_PA3,
+    	.bus = EXT_SLAVE_BUS_SECONDARY,  //The secondary I2C of MPU
+    	.address = 0x38,//0x1c, //
+    	//.orientation = { 1, 0, 0,0, 1, 0,0, 0, 1 },
+    	.orientation = { 0, -1, 0,1, 0, 0,0, 0, -1 },
+    	//.orientation = { 0, 1, 0,1, 0, 0,0, 0, -1 },
+    	//.orientation = {1, 0, 0, 0, -1, 0, 0, 0, -1},
+    	},
+#endif
+
+#if defined (CONFIG_MPU_SENSORS_AK8975)
+	.compass = {
+		.get_slave_descr = get_compass_slave_descr,					
+    	.adapt_num = 0, // The i2c bus to which the compass device is. 
+    	// It can be difference with mpu
+    	// connected
+    	.irq = RK29_PIN0_PA4,
+    	.bus = EXT_SLAVE_BUS_PRIMARY,
+    	.address = 0x0d, //
+    	//.orientation = { -1, 0, 0,0, -1, 0,0, 0, 1 },
+    	//.orientation = { 0, -1, 0,-1, 0, 0,0, 0, -1 },
+    	.orientation = { 0, 1, 0,1, 0, 0,0, 0, -1 },
+    	},
+#endif
+};
+
+#endif
+
+
+#if defined (CONFIG_BATTERY_BQ27510)
+#define	DC_CHECK_PIN	RK29_PIN4_PA1
+#define	LI_LION_BAT_NUM	2
+static int bq27510_init_dc_check_pin(void){	
+	if(gpio_request(DC_CHECK_PIN,"dc_check") != 0){      
+		gpio_free(DC_CHECK_PIN);      
+		printk("bq27510 init dc check pin request error\n");      
+		return -EIO;    
+	}	
+	gpio_direction_input(DC_CHECK_PIN);	
+	return 0;
+}
+
+struct bq27510_platform_data bq27510_info = {	
+	.init_dc_check_pin = bq27510_init_dc_check_pin,	
+	.dc_check_pin =  DC_CHECK_PIN,		
+	.bat_num = LI_LION_BAT_NUM,
+};
+#endif
+
+
+/*****************************************************************************************
+ * i2c devices
+ * author: kfx@rock-chips.com
+*****************************************************************************************/
+static int rk29_i2c0_io_init(void)
+{
+#ifdef CONFIG_RK29_I2C0_CONTROLLER
+	rk29_mux_api_set(GPIO2B7_I2C0SCL_NAME, GPIO2L_I2C0_SCL);
+	rk29_mux_api_set(GPIO2B6_I2C0SDA_NAME, GPIO2L_I2C0_SDA);
+#else
+	rk29_mux_api_set(GPIO2B7_I2C0SCL_NAME, GPIO2L_GPIO2B7);
+	rk29_mux_api_set(GPIO2B6_I2C0SDA_NAME, GPIO2L_GPIO2B6);
+#endif
+	return 0;
+}
+
+static int rk29_i2c1_io_init(void)
+{
+#ifdef CONFIG_RK29_I2C1_CONTROLLER
+	rk29_mux_api_set(GPIO1A7_I2C1SCL_NAME, GPIO1L_I2C1_SCL);
+	rk29_mux_api_set(GPIO1A6_I2C1SDA_NAME, GPIO1L_I2C1_SDA);
+#else
+	rk29_mux_api_set(GPIO1A7_I2C1SCL_NAME, GPIO1L_GPIO1A7);
+	rk29_mux_api_set(GPIO1A6_I2C1SDA_NAME, GPIO1L_GPIO1A6);
+#endif
+	return 0;
+}
+static int rk29_i2c2_io_init(void)
+{
+#ifdef CONFIG_RK29_I2C2_CONTROLLER
+	rk29_mux_api_set(GPIO5D4_I2C2SCL_NAME, GPIO5H_I2C2_SCL);
+	rk29_mux_api_set(GPIO5D3_I2C2SDA_NAME, GPIO5H_I2C2_SDA);
+#else
+	rk29_mux_api_set(GPIO5D4_I2C2SCL_NAME, GPIO5H_GPIO5D4);
+	rk29_mux_api_set(GPIO5D3_I2C2SDA_NAME, GPIO5H_GPIO5D3);
+#endif
+	return 0;
+}
+
+static int rk29_i2c3_io_init(void)
+{
+#ifdef CONFIG_RK29_I2C3_CONTROLLER
+	rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME, GPIO2L_I2C3_SCL);
+	rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME, GPIO2L_I2C3_SDA);
+#else
+	rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME, GPIO2L_GPIO2B5);
+	rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME, GPIO2L_GPIO2B4);
+#endif
+	return 0;
+}
+#ifdef CONFIG_RK29_I2C0_CONTROLLER
+struct rk29_i2c_platform_data default_i2c0_data = {
+	.bus_num    = 0,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c0_io_init,
+};
+#else
+struct i2c_gpio_platform_data default_i2c0_data = {
+       .sda_pin = RK29_PIN2_PB6,
+       .scl_pin = RK29_PIN2_PB7,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(200),
+       .bus_num    = 0,
+       .io_init = rk29_i2c0_io_init,
+};
+#endif
+#ifdef CONFIG_RK29_I2C1_CONTROLLER
+struct rk29_i2c_platform_data default_i2c1_data = {
+	.bus_num    = 1,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c1_io_init,
+};
+#else
+struct i2c_gpio_platform_data default_i2c1_data = {
+       .sda_pin = RK29_PIN1_PA6,
+       .scl_pin = RK29_PIN1_PA7,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(200),
+       .bus_num    = 1,
+       .io_init = rk29_i2c1_io_init,
+};
+#endif
+#ifdef CONFIG_RK29_I2C2_CONTROLLER
+struct rk29_i2c_platform_data default_i2c2_data = {
+	.bus_num    = 2,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c2_io_init,
+};
+#else
+struct i2c_gpio_platform_data default_i2c2_data = {
+       .sda_pin = RK29_PIN5_PD3,
+       .scl_pin = RK29_PIN5_PD4,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(200),
+       .bus_num    = 2,
+       .io_init = rk29_i2c2_io_init,
+};
+#endif
+#ifdef CONFIG_RK29_I2C3_CONTROLLER
+struct rk29_i2c_platform_data default_i2c3_data = {
+	.bus_num    = 3,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c3_io_init,
+};
+#else
+struct i2c_gpio_platform_data default_i2c3_data = {
+       .sda_pin = RK29_PIN5_PB5,
+       .scl_pin = RK29_PIN5_PB4,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(200),
+       .bus_num    = 3,
+       .io_init = rk29_i2c3_io_init,
+};
+#endif
+#ifdef CONFIG_I2C0_RK29
+static struct i2c_board_info __initdata board_i2c0_devices[] = {
+#if defined (CONFIG_RK1000_CONTROL)
+	{
+		.type    		= "rk1000_control",
+		.addr           = 0x40,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_alc5621)
+        {
+                .type                   = "ALC5621",
+                .addr                   = 0x1a,
+                .flags                  = 0,
+        },
+#endif
+#if defined (CONFIG_SND_SOC_alc5631)
+        {
+                .type                   = "rt5631",
+                .addr                   = 0x1a,
+                .flags                  = 0,
+        },
+#endif
+#if defined (CONFIG_SND_SOC_RK1000)
+	{
+		.type    		= "rk1000_i2c_codec",
+		.addr           = 0x60,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_WM8900)
+	{
+		.type    		= "wm8900",
+		.addr           = 0x1A,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_BATTERY_STC3100)
+	{
+		.type    		= "stc3100",
+		.addr           = 0x70,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_BATTERY_BQ27510)
+	{
+		.type    		= "bq27510",
+		.addr           = 0x55,
+		.flags			= 0,
+		.platform_data  = &bq27510_info,
+	},
+#endif
+#if defined (CONFIG_RTC_HYM8563)
+	{
+		.type    		= "rtc_hym8563",
+		.addr           = 0x51,
+		.flags			= 0,
+		.irq            = RK29_PIN0_PA1,
+	},
+#endif
+#if defined (CONFIG_GS_MMA8452)
+    {
+      .type           = "gs_mma8452",
+      .addr           = 0x1c,
+      .flags          = 0,
+      .irq            = MMA8452_INT_PIN,
+      .platform_data  = &mma8452_info,
+    },
+#endif
+
+//add by xhh
+#if defined (CONFIG_MPU_SENSORS_MPU3050) 
+	{
+		.type = "mpu3050",
+		.addr = 0x68,
+		.flags = 0,
+		.irq = RK29_PIN5_PA3,
+		.platform_data = &mpu3050_data,
+	},
+#endif
+
+//add by xhh
+
+#if defined (CONFIG_COMPASS_AK8973)
+	{
+		.type    		= "ak8973",
+		.addr           = 0x1d,
+		.flags			= 0,
+		.irq			= RK29_PIN0_PA4,
+	},
+#endif
+#if defined (CONFIG_COMPASS_AK8975)
+	{
+		.type    		= "ak8975",
+		.addr           = 0x0d,
+		.flags			= 0,
+		.irq			= RK29_PIN0_PA4,
+	},
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C1_RK29
+static struct i2c_board_info __initdata board_i2c1_devices[] = {
+#if defined (CONFIG_RK1000_CONTROL1)
+	{
+		.type			= "rk1000_control",
+		.addr			= 0x40,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_ANX7150) || defined (CONFIG_ANX7150_NEW)
+    {
+		.type           = "anx7150",
+        .addr           = 0x39,             //0x39, 0x3d
+        .flags          = 0,
+        .irq            = RK29_PIN1_PD7,
+    },
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C2_RK29
+static struct i2c_board_info __initdata board_i2c2_devices[] = {
+#if defined (CONFIG_HANNSTAR_P1003)
+    {
+      .type           = "p1003_touch",
+      .addr           = 0x04,
+      .flags          = 0, //I2C_M_NEED_DELAY
+      .irq            = RK29_PIN0_PA2,
+      .platform_data  = &p1003_info,
+      //.udelay		  = 100
+    },
+#endif
+#if defined (CONFIG_EETI_EGALAX)
+    {
+      .type           = "egalax_i2c",
+      .addr           = 0x04,
+      .flags          = 0,
+      .irq            = RK29_PIN0_PA2,
+      .platform_data  = &eeti_egalax_info,
+    },
+#endif
+#if defined (CONFIG_ATMEL_MXT1386)
+    {
+      .type           = "mxc_ts_i2c",
+      .addr           = 0x4C,
+      .flags          = 0,
+      .irq            = RK29_PIN0_PA2,
+      .platform_data  = &atmel_mxt1386_platform_info,
+    },
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C3_RK29
+static struct i2c_board_info __initdata board_i2c3_devices[] = {
+};
+#endif
+
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR      0
+#define CONFIG_SENSOR_RESET_IOCTL_USR      0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR      0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR      0
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+    #error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+    #error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+    #error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+    #error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb  sensor_ioctl_cb = {
+    #if CONFIG_SENSOR_POWER_IOCTL_USR
+    .sensor_power_cb = sensor_power_usr_cb,
+    #else
+    .sensor_power_cb = NULL,
+    #endif
+
+    #if CONFIG_SENSOR_RESET_IOCTL_USR
+    .sensor_reset_cb = sensor_reset_usr_cb,
+    #else
+    .sensor_reset_cb = NULL,
+    #endif
+
+    #if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+    .sensor_powerdown_cb = sensor_powerdown_usr_cb,
+    #else
+    .sensor_powerdown_cb = NULL,
+    #endif
+
+    #if CONFIG_SENSOR_FLASH_IOCTL_USR
+    .sensor_flash_cb = sensor_flash_usr_cb,
+    #else
+    .sensor_flash_cb = NULL,
+    #endif
+};
+#include "../../../drivers/media/video/rk29_camera.c"
+#endif
+/*****************************************************************************************
+ * backlight  devices
+ * author: nzy@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+ /*
+ GPIO1B5_PWM0_NAME,       GPIO1L_PWM0
+ GPIO5D2_PWM1_UART1SIRIN_NAME,  GPIO5H_PWM1
+ GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME,   GPIO2L_PWM2
+ GPIO1A5_EMMCPWREN_PWM3_NAME,     GPIO1L_PWM3
+ */
+
+#define PWM_ID            0
+#define PWM_MUX_NAME      GPIO1B5_PWM0_NAME
+#define PWM_MUX_MODE      GPIO1L_PWM0
+#define PWM_MUX_MODE_GPIO GPIO1L_GPIO1B5
+#define PWM_GPIO RK29_PIN1_PB5
+#define PWM_EFFECT_VALUE  1
+
+#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+//#define BL_EN_MUX_NAME    GPIOF34_UART3_SEL_NAME
+//#define BL_EN_MUX_MODE    IOMUXB_GPIO1_B34
+
+#define BL_EN_PIN         RK29_PIN6_PD0
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+    int ret = 0;
+
+    rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+	#ifdef  LCD_DISP_ON_PIN
+   // rk29_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+
+    ret = gpio_request(BL_EN_PIN, NULL);
+    if(ret != 0)
+    {
+        gpio_free(BL_EN_PIN);
+    }
+
+    gpio_direction_output(BL_EN_PIN, 0);
+    gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+	#endif
+    return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+    int ret = 0;
+    #ifdef  LCD_DISP_ON_PIN
+    gpio_free(BL_EN_PIN);
+    #endif
+    rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+    
+    return ret;
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret = 0;
+	rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	if (gpio_request(PWM_GPIO, NULL)) {
+		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	gpio_direction_output(PWM_GPIO, GPIO_LOW);
+   #ifdef  LCD_DISP_ON_PIN
+    gpio_direction_output(BL_EN_PIN, 0);
+    gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+   #endif
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	gpio_free(PWM_GPIO);
+	rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+
+    #ifdef  LCD_DISP_ON_PIN
+    msleep(30);
+    gpio_direction_output(BL_EN_PIN, 1);
+    gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+    #endif
+	return 0;
+}
+
+struct rk29_bl_info rk29_bl_info = {
+    .pwm_id   = PWM_ID,
+    .bl_ref   = PWM_EFFECT_VALUE,
+    .io_init   = rk29_backlight_io_init,
+    .io_deinit = rk29_backlight_io_deinit,
+    .pwm_suspend = rk29_backlight_pwm_suspend,
+    .pwm_resume = rk29_backlight_pwm_resume,
+};
+#endif
+/*****************************************************************************************
+* pwm voltage regulator devices
+******************************************************************************************/
+#if defined (CONFIG_RK29_PWM_REGULATOR)
+
+#define REGULATOR_PWM_ID					2
+#define REGULATOR_PWM_MUX_NAME      		GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME
+#define REGULATOR_PWM_MUX_MODE      					GPIO2L_PWM2
+#define REGULATOR_PWM_MUX_MODE_GPIO 				GPIO2L_GPIO2A3
+#define REGULATOR_PWM_GPIO				RK29_PIN2_PA3
+
+static struct regulator_consumer_supply pwm_consumers[] = {
+	{
+		.supply = "vcore",
+	}
+};
+
+static struct regulator_init_data rk29_pwm_regulator_data = {
+	.constraints = {
+		.name = "PWM2",
+		.min_uV =  950000,
+		.max_uV = 1400000,
+		.apply_uV = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(pwm_consumers),
+	.consumer_supplies = pwm_consumers,
+};
+
+static struct pwm_platform_data rk29_regulator_pwm_platform_data = {
+	.pwm_id = REGULATOR_PWM_ID,
+	.pwm_gpio = REGULATOR_PWM_GPIO,
+	//.pwm_iomux_name[] = REGULATOR_PWM_MUX_NAME;
+	.pwm_iomux_name = REGULATOR_PWM_MUX_NAME,
+	.pwm_iomux_pwm = REGULATOR_PWM_MUX_MODE,
+	.pwm_iomux_gpio = REGULATOR_PWM_MUX_MODE_GPIO,
+	.init_data  = &rk29_pwm_regulator_data,
+};
+
+static struct platform_device rk29_device_pwm_regulator = {
+	.name = "pwm-voltage-regulator",
+	.id   = -1,
+	.dev  = {
+		.platform_data = &rk29_regulator_pwm_platform_data,
+	},
+};
+
+#endif
+
+/*****************************************************************************************
+ * SDMMC devices
+*****************************************************************************************/
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+	rk29_mux_api_set(GPIO1D1_SDMMC0CMD_NAME, GPIO1H_SDMMC0_CMD);
+	rk29_mux_api_set(GPIO1D0_SDMMC0CLKOUT_NAME, GPIO1H_SDMMC0_CLKOUT);
+	rk29_mux_api_set(GPIO1D2_SDMMC0DATA0_NAME, GPIO1H_SDMMC0_DATA0);
+	rk29_mux_api_set(GPIO1D3_SDMMC0DATA1_NAME, GPIO1H_SDMMC0_DATA1);
+	rk29_mux_api_set(GPIO1D4_SDMMC0DATA2_NAME, GPIO1H_SDMMC0_DATA2);
+	rk29_mux_api_set(GPIO1D5_SDMMC0DATA3_NAME, GPIO1H_SDMMC0_DATA3);
+
+#ifdef CONFIG_SDMMC_RK29_OLD	
+	rk29_mux_api_set(GPIO2A2_SDMMC0DETECTN_NAME, GPIO2L_GPIO2A2);
+#else
+	rk29_mux_api_set(GPIO2A2_SDMMC0DETECTN_NAME, GPIO2L_SDMMC0_DETECT_N);//Modifyed by xbw.
+#endif
+
+	rk29_mux_api_set(GPIO5D5_SDMMC0PWREN_NAME, GPIO5H_GPIO5D5);   ///GPIO5H_SDMMC0_PWR_EN);  ///GPIO5H_GPIO5D5);
+	gpio_request(RK29_PIN5_PD5,"sdmmc");
+#if 0
+	gpio_set_value(RK29_PIN5_PD5,GPIO_HIGH);
+	mdelay(100);
+	gpio_set_value(RK29_PIN5_PD5,GPIO_LOW);
+#else
+	gpio_direction_output(RK29_PIN5_PD5,GPIO_LOW);
+#endif
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail = (MMC_VDD_25_26|MMC_VDD_26_27|MMC_VDD_27_28|MMC_VDD_28_29|MMC_VDD_29_30|
+					   MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|
+					   MMC_VDD_33_34|MMC_VDD_34_35| MMC_VDD_35_36),
+	.host_caps 	= (MMC_CAP_4_BIT_DATA|MMC_CAP_MMC_HIGHSPEED|MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma  = 1,
+#else
+	.use_dma = 0,
+#endif
+	.detect_irq = RK29_PIN2_PA2, // INVALID_GPIO
+	.enable_sd_wakeup = 0,
+};
+#endif
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+	rk29_mux_api_set(GPIO1C2_SDMMC1CMD_NAME, GPIO1H_SDMMC1_CMD);
+	rk29_mux_api_set(GPIO1C7_SDMMC1CLKOUT_NAME, GPIO1H_SDMMC1_CLKOUT);
+	rk29_mux_api_set(GPIO1C3_SDMMC1DATA0_NAME, GPIO1H_SDMMC1_DATA0);
+	rk29_mux_api_set(GPIO1C4_SDMMC1DATA1_NAME, GPIO1H_SDMMC1_DATA1);
+	rk29_mux_api_set(GPIO1C5_SDMMC1DATA2_NAME, GPIO1H_SDMMC1_DATA2);
+	rk29_mux_api_set(GPIO1C6_SDMMC1DATA3_NAME, GPIO1H_SDMMC1_DATA3);
+	//rk29_mux_api_set(GPIO1C0_UART0CTSN_SDMMC1DETECTN_NAME, GPIO1H_SDMMC1_DETECT_N);
+	return 0;
+}
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+static int rk29sdk_wifi_status(struct device *dev);
+static int rk29sdk_wifi_status_register(void (*callback)(int card_presend, void *dev_id), void *dev_id);
+#endif
+
+#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK29_PIN1_PD6
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail = (MMC_VDD_25_26|MMC_VDD_26_27|MMC_VDD_27_28|MMC_VDD_28_29|
+					   MMC_VDD_29_30|MMC_VDD_30_31|MMC_VDD_31_32|
+					   MMC_VDD_32_33|MMC_VDD_33_34),
+	.host_caps 	= (MMC_CAP_4_BIT_DATA|MMC_CAP_SDIO_IRQ|
+				   MMC_CAP_MMC_HIGHSPEED|MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc1_cfg_gpio,
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma  = 1,
+#else
+	.use_dma = 0,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+        .status = rk29sdk_wifi_status,
+        .register_status_notify = rk29sdk_wifi_status_register,
+#endif
+#if 0
+        .detect_irq = RK29SDK_WIFI_SDIO_CARD_DETECT_N,
+#endif
+};
+#endif
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+#define RK29SDK_WIFI_BT_GPIO_POWER_N       RK29_PIN5_PD6
+#define RK29SDK_WIFI_GPIO_RESET_N          RK29_PIN6_PC0
+#define RK29SDK_BT_GPIO_RESET_N            RK29_PIN6_PC4
+
+static int rk29sdk_wifi_cd = 0;   /* wifi virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+int rk29sdk_wifi_power_state = 0;
+int rk29sdk_bt_power_state = 0;
+
+static int rk29sdk_wifi_status(struct device *dev)
+{
+        return rk29sdk_wifi_cd;
+}
+
+static int rk29sdk_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
+{
+        if(wifi_status_cb)
+                return -EAGAIN;
+        wifi_status_cb = callback;
+        wifi_status_cb_devid = dev_id;
+        return 0;
+}
+
+static int rk29sdk_wifi_bt_gpio_control_init(void)
+{
+    if (gpio_request(RK29SDK_WIFI_BT_GPIO_POWER_N, "wifi_bt_power")) {
+           pr_info("%s: request wifi_bt power gpio failed\n", __func__);
+           return -1;
+    }
+
+    if (gpio_request(RK29SDK_WIFI_GPIO_RESET_N, "wifi reset")) {
+           pr_info("%s: request wifi reset gpio failed\n", __func__);
+           gpio_free(RK29SDK_WIFI_BT_GPIO_POWER_N);
+           return -1;
+    }
+
+    if (gpio_request(RK29SDK_BT_GPIO_RESET_N, "bt reset")) {
+          pr_info("%s: request bt reset gpio failed\n", __func__);
+          gpio_free(RK29SDK_WIFI_GPIO_RESET_N);
+          return -1;
+    }
+
+    gpio_direction_output(RK29SDK_WIFI_BT_GPIO_POWER_N, GPIO_LOW);
+    gpio_direction_output(RK29SDK_WIFI_GPIO_RESET_N,    GPIO_LOW);
+    gpio_direction_output(RK29SDK_BT_GPIO_RESET_N,      GPIO_LOW);
+
+    pr_info("%s: init finished\n",__func__);
+
+    return 0;
+}
+
+static int rk29sdk_wifi_power(int on)
+{
+        pr_info("%s: %d\n", __func__, on);
+        if (on){
+                gpio_set_value(RK29SDK_WIFI_BT_GPIO_POWER_N, GPIO_HIGH);
+                gpio_set_value(RK29SDK_WIFI_GPIO_RESET_N, GPIO_HIGH);
+                mdelay(100);
+                pr_info("wifi turn on power\n");
+        }else{
+                if (!rk29sdk_bt_power_state){
+                        gpio_set_value(RK29SDK_WIFI_BT_GPIO_POWER_N, GPIO_LOW);
+                        mdelay(100);
+                        pr_info("wifi shut off power\n");
+                }else
+                {
+                        pr_info("wifi shouldn't shut off power, bt is using it!\n");
+                }
+                gpio_set_value(RK29SDK_WIFI_GPIO_RESET_N, GPIO_LOW);
+
+        }
+
+        rk29sdk_wifi_power_state = on;
+        return 0;
+}
+
+static int rk29sdk_wifi_reset_state;
+static int rk29sdk_wifi_reset(int on)
+{
+        pr_info("%s: %d\n", __func__, on);
+        gpio_set_value(RK29SDK_WIFI_GPIO_RESET_N, on);
+        mdelay(100);
+        rk29sdk_wifi_reset_state = on;
+        return 0;
+}
+
+int rk29sdk_wifi_set_carddetect(int val)
+{
+        pr_info("%s:%d\n", __func__, val);
+        rk29sdk_wifi_cd = val;
+        if (wifi_status_cb){
+                wifi_status_cb(val, wifi_status_cb_devid);
+        }else {
+                pr_warning("%s, nobody to notify\n", __func__);
+        }
+        return 0;
+}
+EXPORT_SYMBOL(rk29sdk_wifi_set_carddetect);
+
+static struct wifi_mem_prealloc wifi_mem_array[PREALLOC_WLAN_SEC_NUM] = {
+        {NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER)},
+        {NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER)},
+        {NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER)},
+        {NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER)}
+};
+
+static void *rk29sdk_mem_prealloc(int section, unsigned long size)
+{
+        if (section == PREALLOC_WLAN_SEC_NUM)
+                return wlan_static_skb;
+
+        if ((section < 0) || (section > PREALLOC_WLAN_SEC_NUM))
+                return NULL;
+
+        if (wifi_mem_array[section].size < size)
+                return NULL;
+
+        return wifi_mem_array[section].mem_ptr;
+}
+
+int __init rk29sdk_init_wifi_mem(void)
+{
+        int i;
+        int j;
+
+        for (i = 0 ; i < WLAN_SKB_BUF_NUM ; i++) {
+                wlan_static_skb[i] = dev_alloc_skb(
+                                ((i < (WLAN_SKB_BUF_NUM / 2)) ? 4096 : 8192));
+
+                if (!wlan_static_skb[i])
+                        goto err_skb_alloc;
+        }
+
+        for (i = 0 ; i < PREALLOC_WLAN_SEC_NUM ; i++) {
+                wifi_mem_array[i].mem_ptr =
+                                kmalloc(wifi_mem_array[i].size, GFP_KERNEL);
+
+                if (!wifi_mem_array[i].mem_ptr)
+                        goto err_mem_alloc;
+        }
+        return 0;
+
+err_mem_alloc:
+        pr_err("Failed to mem_alloc for WLAN\n");
+        for (j = 0 ; j < i ; j++)
+               kfree(wifi_mem_array[j].mem_ptr);
+
+        i = WLAN_SKB_BUF_NUM;
+
+err_skb_alloc:
+        pr_err("Failed to skb_alloc for WLAN\n");
+        for (j = 0 ; j < i ; j++)
+                dev_kfree_skb(wlan_static_skb[j]);
+
+        return -ENOMEM;
+}
+
+static struct wifi_platform_data rk29sdk_wifi_control = {
+        .set_power = rk29sdk_wifi_power,
+        .set_reset = rk29sdk_wifi_reset,
+        .set_carddetect = rk29sdk_wifi_set_carddetect,
+        .mem_prealloc   = rk29sdk_mem_prealloc,
+};
+static struct platform_device rk29sdk_wifi_device = {
+        .name = "bcm4329_wlan",
+        .id = 1,
+        .dev = {
+                .platform_data = &rk29sdk_wifi_control,
+         },
+};
+#endif
+
+
+/* bluetooth rfkill device */
+static struct platform_device rk29sdk_rfkill = {
+        .name = "rk29sdk_rfkill",
+        .id = -1,
+};
+
+
+#ifdef CONFIG_VIVANTE
+#define GPU_HIGH_CLOCK        552
+#define GPU_LOW_CLOCK         (periph_pll_default / 1000000) /* same as general pll clock rate below */
+static struct resource resources_gpu[] = {
+    [0] = {
+		.name 	= "gpu_irq",
+        .start 	= IRQ_GPU,
+        .end    = IRQ_GPU,
+        .flags  = IORESOURCE_IRQ,
+    },
+    [1] = {
+		.name   = "gpu_base",
+        .start  = RK29_GPU_PHYS,
+        .end    = RK29_GPU_PHYS + RK29_GPU_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [2] = {
+		.name   = "gpu_mem",
+        .start  = PMEM_GPU_BASE,
+        .end    = PMEM_GPU_BASE + PMEM_GPU_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [3] = {
+		.name 	= "gpu_clk",
+        .start 	= GPU_LOW_CLOCK,
+        .end    = GPU_HIGH_CLOCK,
+        .flags  = IORESOURCE_IO,
+    },
+};
+static struct platform_device rk29_device_gpu = {
+    .name             = "galcore",
+    .id               = 0,
+    .num_resources    = ARRAY_SIZE(resources_gpu),
+    .resource         = resources_gpu,
+};
+#endif
+
+#ifdef CONFIG_KEYS_RK29
+extern struct rk29_keys_platform_data rk29_keys_pdata;
+static struct platform_device rk29_device_keys = {
+	.name		= "rk29-keypad",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &rk29_keys_pdata,
+	},
+};
+#endif
+
+static void __init rk29_board_iomux_init(void)
+{
+	#ifdef CONFIG_RK29_PWM_REGULATOR
+	rk29_mux_api_set(REGULATOR_PWM_MUX_NAME,REGULATOR_PWM_MUX_MODE);
+	#endif
+}
+
+static struct platform_device *devices[] __initdata = {
+
+#ifdef CONFIG_RK29_WATCHDOG
+	&rk29_device_wdt,
+#endif
+
+#ifdef CONFIG_UART1_RK29
+	&rk29_device_uart1,
+#endif
+#ifdef CONFIG_UART0_RK29
+	&rk29_device_uart0,
+#endif
+#ifdef CONFIG_UART2_RK29
+	&rk29_device_uart2,
+#endif
+#ifdef CONFIG_UART3_RK29
+	&rk29_device_uart3,
+#endif
+
+#ifdef CONFIG_RK29_PWM_REGULATOR
+	&rk29_device_pwm_regulator,
+#endif
+#ifdef CONFIG_SPIM0_RK29
+    &rk29xx_device_spi0m,
+#endif
+#ifdef CONFIG_SPIM1_RK29
+    &rk29xx_device_spi1m,
+#endif
+#ifdef CONFIG_ADC_RK29
+	&rk29_device_adc,
+#endif
+#ifdef CONFIG_I2C0_RK29
+	&rk29_device_i2c0,
+#endif
+#ifdef CONFIG_I2C1_RK29
+	&rk29_device_i2c1,
+#endif
+#ifdef CONFIG_I2C2_RK29
+	&rk29_device_i2c2,
+#endif
+#ifdef CONFIG_I2C3_RK29
+	&rk29_device_i2c3,
+#endif
+
+#ifdef CONFIG_SND_RK29_SOC_I2S_2CH
+        &rk29_device_iis_2ch,
+#endif
+#ifdef CONFIG_SND_RK29_SOC_I2S_8CH
+        &rk29_device_iis_8ch,
+#endif
+
+#ifdef CONFIG_KEYS_RK29
+	&rk29_device_keys,
+#endif
+#ifdef CONFIG_SDMMC0_RK29
+	&rk29_device_sdmmc0,
+#endif
+#ifdef CONFIG_SDMMC1_RK29
+	&rk29_device_sdmmc1,
+#endif
+
+#ifdef CONFIG_MTD_NAND_RK29XX
+	&rk29xx_device_nand,
+#endif
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+        &rk29sdk_wifi_device,
+#endif
+
+#ifdef CONFIG_BT
+        &rk29sdk_rfkill,
+#endif
+
+#ifdef CONFIG_MTD_NAND_RK29
+	&rk29_device_nand,
+#endif
+
+#ifdef CONFIG_FB_RK29
+	&rk29_device_fb,
+	&rk29_device_dma_cpy,
+#endif
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	&rk29_device_backlight,
+#endif
+#ifdef CONFIG_RK29_VMAC
+	&rk29_device_vmac,
+#endif
+#ifdef CONFIG_VIVANTE
+	&rk29_device_gpu,
+#endif
+#ifdef CONFIG_VIDEO_RK29
+ 	&rk29_device_camera,      /* ddl@rock-chips.com : camera support  */
+ 	#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
+ 	&rk29_soc_camera_pdrv_0,
+ 	#endif
+ 	&rk29_soc_camera_pdrv_1,
+ 	&android_pmem_cam_device,
+#endif
+	&android_pmem_device,
+	&rk29_vpu_mem_device,
+#ifdef CONFIG_USB20_OTG
+	&rk29_device_usb20_otg,
+#endif
+#ifdef CONFIG_USB20_HOST
+	&rk29_device_usb20_host,
+#endif
+#ifdef CONFIG_USB11_HOST
+	&rk29_device_usb11_host,
+#endif
+#ifdef CONFIG_USB_ANDROID
+	&android_usb_device,
+	&usb_mass_storage_device,
+#endif
+#ifdef CONFIG_USB_ANDROID_RNDIS
+    &rk29_device_rndis,
+#endif
+#ifdef CONFIG_RK29_IPP
+	&rk29_device_ipp,
+#endif
+#ifdef CONFIG_VIDEO_RK29XX_VOUT
+	&rk29_v4l2_output_devce,
+#endif
+};
+
+/*****************************************************************************************
+ * spi devices
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+static int rk29_vmac_register_set(void)
+{
+	//config rk29 vmac as rmii, 100MHz
+	u32 value= readl(RK29_GRF_BASE + 0xbc);
+	value = (value & 0xfff7ff) | (0x400);
+	writel(value, RK29_GRF_BASE + 0xbc);
+	return 0;
+}
+
+static int rk29_rmii_io_init(void)
+{
+	int err;
+
+	//phy power gpio
+	err = gpio_request(RK29_PIN6_PB0, "phy_power_en");
+	if (err) {
+		gpio_free(RK29_PIN6_PB0);
+		printk("-------request RK29_PIN6_PB0 fail--------\n");
+		return -1;
+	}
+	//phy power down
+	gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+	gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+
+	return 0;
+}
+
+static int rk29_rmii_io_deinit(void)
+{
+	//phy power down
+	gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+	gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+	//free
+	gpio_free(RK29_PIN6_PB0);
+	return 0;
+}
+
+static int rk29_rmii_power_control(int enable)
+{
+	if (enable) {
+		//enable phy power
+		gpio_direction_output(RK29_PIN6_PB0, GPIO_HIGH);
+		gpio_set_value(RK29_PIN6_PB0, GPIO_HIGH);
+	}
+	else {
+		gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+		gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+	}
+	return 0;
+}
+
+struct rk29_vmac_platform_data rk29_vmac_pdata = {
+	.vmac_register_set = rk29_vmac_register_set,
+	.rmii_io_init = rk29_rmii_io_init,
+	.rmii_io_deinit = rk29_rmii_io_deinit,
+	.rmii_power_control = rk29_rmii_power_control,
+};
+
+/*****************************************************************************************
+ * spi devices
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+#define SPI_CHIPSELECT_NUM 2
+static struct spi_cs_gpio rk29xx_spi0_cs_gpios[SPI_CHIPSELECT_NUM] = {
+    {
+		.name = "spi0 cs0",
+		.cs_gpio = RK29_PIN2_PC1,
+		.cs_iomux_name = GPIO2C1_SPI0CSN0_NAME,
+		.cs_iomux_mode = GPIO2H_SPI0_CSN0,
+	},
+	{
+		.name = "spi0 cs1",
+		.cs_gpio = RK29_PIN1_PA4,
+		.cs_iomux_name = GPIO1A4_EMMCWRITEPRT_SPI0CS1_NAME,//if no iomux,set it NULL
+		.cs_iomux_mode = GPIO1L_SPI0_CSN1,
+	}
+};
+
+static struct spi_cs_gpio rk29xx_spi1_cs_gpios[SPI_CHIPSELECT_NUM] = {
+    {
+		.name = "spi1 cs0",
+		.cs_gpio = RK29_PIN2_PC5,
+		.cs_iomux_name = GPIO2C5_SPI1CSN0_NAME,
+		.cs_iomux_mode = GPIO2H_SPI1_CSN0,
+	},
+	{
+		.name = "spi1 cs1",
+		.cs_gpio = RK29_PIN1_PA3,
+		.cs_iomux_name = GPIO1A3_EMMCDETECTN_SPI1CS1_NAME,//if no iomux,set it NULL
+		.cs_iomux_mode = GPIO1L_SPI1_CSN1,
+	}
+};
+
+static int spi_io_init(struct spi_cs_gpio *cs_gpios, int cs_num)
+{
+#if 1
+	int i;
+	if (cs_gpios) {
+		for (i=0; i<cs_num; i++) {
+			rk29_mux_api_set(cs_gpios[i].cs_iomux_name, cs_gpios[i].cs_iomux_mode);
+		}
+	}
+#endif
+	return 0;
+}
+
+static int spi_io_deinit(struct spi_cs_gpio *cs_gpios, int cs_num)
+{
+	return 0;
+}
+
+static int spi_io_fix_leakage_bug(void)
+{
+#if 0
+	gpio_direction_output(RK29_PIN2_PC1, GPIO_LOW);
+#endif
+	return 0;
+}
+
+static int spi_io_resume_leakage_bug(void)
+{
+#if 0
+	gpio_direction_output(RK29_PIN2_PC1, GPIO_HIGH);
+#endif
+	return 0;
+}
+
+struct rk29xx_spi_platform_data rk29xx_spi0_platdata = {
+	.num_chipselect = SPI_CHIPSELECT_NUM,
+	.chipselect_gpios = rk29xx_spi0_cs_gpios,
+	.io_init = spi_io_init,
+	.io_deinit = spi_io_deinit,
+	.io_fix_leakage_bug = spi_io_fix_leakage_bug,
+	.io_resume_leakage_bug = spi_io_resume_leakage_bug,
+};
+
+struct rk29xx_spi_platform_data rk29xx_spi1_platdata = {
+	.num_chipselect = SPI_CHIPSELECT_NUM,
+	.chipselect_gpios = rk29xx_spi1_cs_gpios,
+	.io_init = spi_io_init,
+	.io_deinit = spi_io_deinit,
+	.io_fix_leakage_bug = spi_io_fix_leakage_bug,
+	.io_resume_leakage_bug = spi_io_resume_leakage_bug,
+};
+
+/*****************************************************************************************
+ * xpt2046 touch panel
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+#define XPT2046_GPIO_INT           RK29_PIN0_PA3
+#define DEBOUNCE_REPTIME  3
+
+#if defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 0,
+	.x_min			= 0,
+	.x_max			= 320,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_CBN_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 0,
+	.x_min			= 0,
+	.x_max			= 320,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 1,
+	.x_min			= 0,
+	.x_max			= 800,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 1,
+	.x_min			= 0,
+	.x_max			= 800,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+
+	.penirq_recheck_delay_usecs = 1,
+};
+#endif
+
+static struct spi_board_info board_spi_devices[] = {
+#if defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_SPI) || defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_CBN_SPI)\
+    ||defined(CONFIG_TOUCHSCREEN_XPT2046_SPI) || defined(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)
+	{
+		.modalias	= "xpt2046_ts",
+		.chip_select	= 0,
+		.max_speed_hz	= 125 * 1000 * 26,/* (max sample rate @ 3V) * (cmd + data + overhead) */
+		.bus_num	= 0,
+		.irq = XPT2046_GPIO_INT,
+		.platform_data = &xpt2046_info,
+	},
+#endif
+};
+
+
+static void __init rk29_gic_init_irq(void)
+{
+	gic_dist_init(0, (void __iomem *)RK29_GICPERI_BASE, 32);
+	gic_cpu_init(0, (void __iomem *)RK29_GICCPU_BASE);
+}
+
+static void __init machine_rk29_init_irq(void)
+{
+	rk29_gic_init_irq();
+	rk29_gpio_init();
+}
+
+static void __init machine_rk29_board_init(void)
+{
+	rk29_board_iomux_init();
+
+	board_power_init();
+
+		platform_add_devices(devices, ARRAY_SIZE(devices));
+#ifdef CONFIG_I2C0_RK29
+	i2c_register_board_info(default_i2c0_data.bus_num, board_i2c0_devices,
+			ARRAY_SIZE(board_i2c0_devices));
+#endif
+#ifdef CONFIG_I2C1_RK29
+	i2c_register_board_info(default_i2c1_data.bus_num, board_i2c1_devices,
+			ARRAY_SIZE(board_i2c1_devices));
+#endif
+#ifdef CONFIG_I2C2_RK29
+	i2c_register_board_info(default_i2c2_data.bus_num, board_i2c2_devices,
+			ARRAY_SIZE(board_i2c2_devices));
+#endif
+#ifdef CONFIG_I2C3_RK29
+	i2c_register_board_info(default_i2c3_data.bus_num, board_i2c3_devices,
+			ARRAY_SIZE(board_i2c3_devices));
+#endif
+
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+        
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	rk29sdk_wifi_bt_gpio_control_init();
+	rk29sdk_init_wifi_mem();
+#endif
+
+	board_usb_detect_init(RK29_PIN0_PA0);
+    //2011-6-29 add
+    rk29xx_virtual_keys_init();
+
+}
+
+static void __init machine_rk29_fixup(struct machine_desc *desc, struct tag *tags,
+					char **cmdline, struct meminfo *mi)
+{
+	mi->nr_banks = 1;
+	mi->bank[0].start = RK29_SDRAM_PHYS;
+	mi->bank[0].node = PHYS_TO_NID(RK29_SDRAM_PHYS);
+	mi->bank[0].size = LINUX_SIZE;
+#if SDRAM_SIZE > SZ_512M
+	mi->nr_banks = 2;
+	mi->bank[1].start = RK29_SDRAM_PHYS + SZ_512M;
+	mi->bank[1].size = SDRAM_SIZE - SZ_512M;
+#endif
+}
+
+static void __init machine_rk29_mapio(void)
+{
+	rk29_map_common_io();
+	rk29_setup_early_printk();
+	rk29_sram_init();
+	rk29_clock_init(periph_pll_default);
+	rk29_iomux_init();
+    ddr_init(DDR_TYPE,DDR_FREQ);  // DDR3_1333H, 400
+}
+
+MACHINE_START(RK29, "RK29board")
+	/* UART for LL DEBUG */
+	.phys_io	= RK29_UART1_PHYS & 0xfff00000,
+	.io_pg_offst	= ((RK29_UART1_BASE) >> 18) & 0xfffc,
+	.boot_params	= RK29_SDRAM_PHYS + 0x88000,
+	.fixup		= machine_rk29_fixup,
+	.map_io		= machine_rk29_mapio,
+	.init_irq	= machine_rk29_init_irq,
+	.init_machine	= machine_rk29_board_init,
+	.timer		= &rk29_timer,
+MACHINE_END
diff --git a/arch/arm/mach-rk29/include/mach/board.h b/arch/arm/mach-rk29/include/mach/board.h
index ea11f8be1e70..7c7f811cec88 100644
--- a/arch/arm/mach-rk29/include/mach/board.h
+++ b/arch/arm/mach-rk29/include/mach/board.h
@@ -192,6 +192,16 @@ struct eeti_egalax_platform_data{
     int     disp_on_value;
  
 };
+//added by zyw
+struct atmel_1386_platform_data {
+	u8    numtouch;	/* Number of touches to report	*/
+	int  (*init_platform_hw)(struct device *dev);
+	void  (*exit_platform_hw)(struct device *dev);
+	int   max_x;    /* The default reported X range   */  
+	int   max_y;    /* The default reported Y range   */
+	u8    (*valid_interrupt) (void);
+	u8    (*read_chg) (void);
+};
 
 /*sintex touch*/
 struct sintek_platform_data {
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 0cb933853a59..845c63510856 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -761,4 +761,33 @@ config TOUCHSCREEN_FT5406
 	  in its table of I2C devices.
 	  
 	  If unsure, say N(but it's safe to say "Y").
+config ATMEL_MXT1386
+        tristate "ATMEL_MXT1386 touchscreen panel support"
+        depends on I2C
+        help
+          Say Y here to enable support for I2C connected ATMEL_MXT1386 touch panels.
+
+          To compile this driver as a module, choose M here: the
+          module will be called atmel_mxt1386_ts.
+
+        config ATMEL_MXT1386_MAX_X
+                int "ATMEL_MXT1386_MAX_X"
+                depends on ATMEL_MXT1386
+                default 4095
+                help
+                  RK29 ATMEL_MXT1386 touch max X size
+
+        config ATMEL_MXT1386_MAX_Y
+                int "ATMEL_MXT1386_MAX_Y"
+                depends on ATMEL_MXT1386
+                default 4095
+                help
+                  RK29 ATMEL_MXT1386 touch max Y size
+
+        config ATMEL_MXT1386_DEBUG
+                bool "ATMEL_MXT1386 debug"
+                depends on ATMEL_MXT1386
+                default n
+                help
+                  RK29 ATMEL_MXT1386 touch debug
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 953241e881d3..e2a26d7000a8 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_TOUCHSCREEN_IT7260)	+= it7260_ts.o
 obj-$(CONFIG_SINTEK_3FA16)		+= sintek_3FA16.o
 obj-$(CONFIG_EETI_EGALAX)		+= eeti_egalax_i2c.o
 obj-$(CONFIG_ATMEL_MXT224)		+= atmel_maxtouch.o
+obj-$(CONFIG_ATMEL_MXT1386)		+= atmel_mxt1386.o
 obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ILI2102_IIC)	+= ili2102_ts.o
diff --git a/drivers/input/touchscreen/atmel_mxt1386.c b/drivers/input/touchscreen/atmel_mxt1386.c
new file mode 100644
index 000000000000..391db401056c
--- /dev/null
+++ b/drivers/input/touchscreen/atmel_mxt1386.c
@@ -0,0 +1,2625 @@
+/*
+ *  Atmel maXTouch Touchscreen Controller Driver
+ *
+ *  
+ *  Copyright (C) 2010 Atmel Corporation
+ *  Copyright (C) 2009 Raphael Derosso Pereira <raphaelpereira@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * 
+ * Driver for Atmel maXTouch family of touch controllers.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/debugfs.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+
+#include <asm/uaccess.h>
+
+#include <linux/workqueue.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <mach/board.h>
+#include "atmel_mxt1386.h"
+
+//#define YANSEN_DEBUG	//yansen 20101230 regulator is under control in kernel (sbl too)
+#ifdef YANSEN_DEBUG
+#include <linux/regulator/consumer.h>
+#endif
+
+#define DRIVER_VERSION "0.9a"
+#define CONFIG_ABS_MT_TRACKING_ID
+
+static int debug = 0;
+static int comms = 1;
+static int ts_irq = 0;
+static u32 last_key=0;
+
+module_param(debug, int, 0644);
+module_param(comms, int, 0644);
+
+MODULE_PARM_DESC(debug, "Activate debugging output");
+MODULE_PARM_DESC(comms, "Select communications mode");
+
+static int mxt_read_block(struct i2c_client *client, u16 addr, u16 length,
+			  u8 *value);
+static int mxt_write_byte(struct i2c_client *client, u16 addr, u8 value);
+static int mxt_write_block(struct i2c_client *client, u16 addr, u16 length,
+			   u8 *value);
+
+/* Device Info descriptor */
+/* Parsed from maXTouch "Id information" inside device */
+struct mxt_device_info {
+	u8   family_id;
+	u8   variant_id;
+	u8   major;
+	u8   minor;
+	u8   build;
+	u8   num_objs;
+	u8   x_size;
+	u8   y_size;
+	char family_name[16];	 /* Family name */
+	char variant_name[16];    /* Variant name */
+	u16  num_nodes;           /* Number of sensor nodes */
+};
+
+/* object descriptor table, parsed from maXTouch "object table" */
+struct mxt_object {
+	u16 chip_addr;
+	u8  type;
+	u8  size;
+	u8  instances;
+	u8  num_report_ids;
+};
+
+
+/* Mapping from report id to object type and instance */
+struct report_id_map {
+	u8  object;
+	u8  instance;
+/*
+ * This is the first report ID belonging to object. It enables us to
+ * find out easily the touch number: each touch has different report
+ * ID (which are assigned to touches in increasing order). By
+ * subtracting the first report ID from current, we get the touch
+ * number.
+ */
+	u8  first_rid;
+};
+
+/* Driver datastructure */
+struct mxt_data {
+	struct i2c_client    *client;
+	struct input_dev     *input;
+	char                 phys_name[32];
+	int                  irq;
+
+	u16                  last_read_addr;
+	bool                 new_msgs;
+	u8                   *last_message;
+
+	int                  valid_irq_counter;
+	int                  invalid_irq_counter;
+	int                  irq_counter;
+	int                  message_counter;
+	int                  read_fail_counter;
+
+	int                  bytes_to_read;
+
+	struct delayed_work  dwork;
+	struct work_struct   work;
+	struct workqueue_struct *queue;
+	
+	u8                   xpos_format;
+	u8                   ypos_format;
+
+	u8                   numtouch;
+
+	struct mxt_device_info	device_info;
+
+	u32		     info_block_crc;
+	u32                  configuration_crc;
+	u16                  report_id_count;
+	struct report_id_map *rid_map;
+	struct mxt_object    *object_table;
+
+	u16                  msg_proc_addr;
+	u8                   message_size;
+
+	u16                  max_x_val;
+	u16                  max_y_val;
+
+	int                 (*init_hw)(struct device *dev);
+	void                 (*exit_hw)(struct device *dev);
+	u8                   (*valid_interrupt)(void);
+	u8                   (*read_chg)(void);
+
+	/* debugfs variables */
+	struct dentry        *debug_dir;
+	int                  current_debug_datap;
+
+	struct mutex         debug_mutex;
+	u16                  *debug_data;
+
+        /* Character device variables */
+	struct cdev          cdev;
+	struct cdev          cdev_messages;  /* 2nd Char dev for messages */
+	dev_t                dev_num;
+	struct class         *mxt_class;
+
+	u16                  address_pointer;
+	bool                 valid_ap;
+
+	/* Message buffer & pointers */
+	char                 *messages;
+	int                  msg_buffer_startp, msg_buffer_endp;
+        /* Put only non-touch messages to buffer if this is set */
+	char                 nontouch_msg_only; 
+	struct mutex         msg_mutex;
+};
+
+static struct mxt_data          *atmel_mxt;
+
+
+#define I2C_RETRY_COUNT 5
+#define I2C_PAYLOAD_SIZE 254
+
+/* Returns the start address of object in mXT memory. */
+#define	MXT_BASE_ADDR(object_type, mxt)					\
+	get_object_address(object_type, 0, mxt->object_table,           \
+			   mxt->device_info.num_objs)
+
+/* Maps a report ID to an object type (object type number). */
+#define	REPORT_ID_TO_OBJECT(rid, mxt)			\
+	(((rid) == 0xff) ? 0 : mxt->rid_map[rid].object)
+
+/* Maps a report ID to an object type (string). */
+#define	REPORT_ID_TO_OBJECT_NAME(rid, mxt)			\
+	object_type_name[REPORT_ID_TO_OBJECT(rid, mxt)]
+
+/* Returns non-zero if given object is a touch object */
+#define IS_TOUCH_OBJECT(object) \
+	((object == MXT_TOUCH_MULTITOUCHSCREEN_T9) || \
+	 (object == MXT_TOUCH_KEYARRAY_T15) ||	\
+	 (object == MXT_TOUCH_PROXIMITY_T23) || \
+	 (object == MXT_TOUCH_SINGLETOUCHSCREEN_T10) || \
+	 (object == MXT_TOUCH_XSLIDER_T11) || \
+	 (object == MXT_TOUCH_YSLIDER_T12) || \
+	 (object == MXT_TOUCH_XWHEEL_T13) || \
+	 (object == MXT_TOUCH_YWHEEL_T14) || \
+	 (object == MXT_TOUCH_KEYSET_T31) || \
+	 (object == MXT_TOUCH_XSLIDERSET_T32) ? 1 : 0)
+
+#define print_ts(level, ...) \
+	do { \
+		if (debug >= (level)) \
+			printk(__VA_ARGS__); \
+	} while (0) 
+
+/* following are debug infomation switch, add by acgzx */
+#define TOUCH_RESET_PIN				RK29_PIN6_PC3
+#define TOUCH_INT_PIN				RK29_PIN0_PA2
+#define LCDC_STANDBY_PIN			RK29_PIN6_PD1
+//#define TS_PEN_IRQ_GPIO RK29_PIN0_PA2//61
+		
+#define WORKQ_RIGHTNOW		1
+#define TOUCH_KEY_EN	1
+
+/* macro switch for debug log */		 
+#define MXT1386_DEBUG_LOG_EN	0// 1		
+#if	MXT1386_DEBUG_LOG_EN
+#define MXT1386_LOG 	printk
+#else
+#define MXT1386_LOG
+#endif
+
+#define WRITE_MT_CONFIG		1//0
+
+struct mxt_key_info{
+    u32  start;
+    u32  end;
+    u32 virtual_x;
+    u32 virtual_y;
+    u32  code;
+};
+
+const struct mxt_key_info key_info[] = {
+	{980, 1280, 3100, 4200, KEY_SEARCH},
+    {1600, 1900, 3000, 4200, KEY_HOME},
+    {2200, 2500, 1100, 4200, KEY_MENU},
+    {2750, 3100, 1000, 4200, KEY_BACK},
+};
+
+/* 
+ * Check whether we have multi-touch enabled kernel; if not, report just the
+ * first touch (on mXT224, the maximum is 10 simultaneous touches).
+ * Because just the 1st one is reported, it might seem that the screen is not
+ * responding to touch if the first touch is removed while the screen is being
+ * touched by another finger, so beware. 
+ *
+ * TODO: investigate if there is any standard set of input events that uppper
+ * layers are expecting from a touchscreen? These can however be different for
+ * different platforms, and customers may have different opinions too about
+ * what should be interpreted as right-click, for example. 
+ *
+ */
+#ifdef EFFICIENT_REPORT
+static void report_sync(struct mxt_data *mxt)
+{
+	input_sync(mxt->input);
+}
+
+static inline void report_mt(int touch_number, int size, int x, int y, struct
+			mxt_data *mxt) {
+	input_report_abs(mxt->input, ABS_MT_TRACKING_ID, touch_number);
+
+	if(size != 0)
+	{
+		input_report_abs(mxt->input, ABS_MT_POSITION_X, x);
+		input_report_abs(mxt->input, ABS_MT_POSITION_Y, y);
+		input_report_abs(mxt->input, ABS_MT_TOUCH_MAJOR, 10);
+		input_report_abs(mxt->input, ABS_MT_WIDTH_MAJOR, 20);
+	}
+	else
+	{
+		input_report_abs(mxt->input, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(mxt->input, ABS_MT_WIDTH_MAJOR, 0);
+	}
+	input_mt_sync(mxt->input);
+}
+#else
+#define MAX_FINGERS		5
+struct finger {
+	int x;
+	int y;
+	int size;
+};
+
+static struct finger fingers[MAX_FINGERS] = {};
+
+static void report_mt(int touch_number, int size, int x, int y, struct
+		mxt_data *mxt) 
+{
+	MXT1386_LOG(KERN_INFO "report_mt touch_number=%d, size=%d, x=%d, t=%d\n", __func__, 
+			touch_number, size, x, y);
+	if (touch_number > MAX_FINGERS ||  touch_number < 0) {
+		return;
+	}
+	fingers[touch_number].x = x;
+	fingers[touch_number].y = y;
+	fingers[touch_number].size = size;
+	MXT1386_LOG(KERN_INFO "report_mt() OUT\n", __func__);
+}
+
+static void report_sync(struct mxt_data *mxt)
+{
+	int i;
+	int fin = 0;
+
+	MXT1386_LOG(KERN_INFO "report_sync() IN\n", __func__);
+
+	for (i = 0; i < MAX_FINGERS; i++) {
+		if (fingers[i].size != 0) {
+			fin++;
+			MXT1386_LOG(KERN_INFO "report_sync touch_number=%d, x=%d, y=%d, width=%d\n",
+					i, fingers[i].x, fingers[i].y, fingers[i].size);
+			input_report_abs(mxt->input, ABS_MT_POSITION_X, fingers[i].x);
+			input_report_abs(mxt->input, ABS_MT_POSITION_Y, fingers[i].y);
+			input_report_abs(mxt->input, ABS_MT_TOUCH_MAJOR, 10);
+			input_report_abs(mxt->input, ABS_MT_WIDTH_MAJOR, 20);
+			input_mt_sync(mxt->input);
+		}
+	}
+
+	if (fin == 0) {
+		MXT1386_LOG(KERN_INFO "report_sync no fingler\n", __func__);
+		input_report_abs(mxt->input, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(mxt->input, ABS_MT_WIDTH_MAJOR, 0);
+		input_mt_sync(mxt->input);
+	}
+
+	input_sync(mxt->input);
+	MXT1386_LOG(KERN_INFO "report_sync() OUT\n", __func__);
+}
+#endif
+
+static inline void report_gesture(int data, struct mxt_data *mxt)
+{
+	//input_event(mxt->input, EV_MSC, MSC_GESTURE, data); 
+}
+
+static const u8	*object_type_name[] = {
+	[0]  = "Reserved",
+	[5]  = "GEN_MESSAGEPROCESSOR_T5",
+	[6]  = "GEN_COMMANDPROCESSOR_T6",
+	[7]  = "GEN_POWERCONFIG_T7",
+	[8]  = "GEN_ACQUIRECONFIG_T8",
+	[9]  = "TOUCH_MULTITOUCHSCREEN_T9",
+	[15] = "TOUCH_KEYARRAY_T15",
+	[17] = "SPT_COMMSCONFIG_T18",
+	[19] = "SPT_GPIOPWM_T19",
+	[20] = "PROCI_GRIPFACESUPPRESSION_T20",
+	[22] = "PROCG_NOISESUPPRESSION_T22",
+	[23] = "TOUCH_PROXIMITY_T23",
+	[24] = "PROCI_ONETOUCHGESTUREPROCESSOR_T24",
+	[25] = "SPT_SELFTEST_T25",
+	[27] = "PROCI_TWOTOUCHGESTUREPROCESSOR_T27",
+	[28] = "SPT_CTECONFIG_T28",
+	[37] = "DEBUG_DIAGNOSTICS_T37",
+	[38] = "SPT_USER_DATA_T38",
+	[40] = "PROCI_GRIPSUPPRESSION_T40",
+	[41] = "PROCI_PALMSUPPRESSION_T41",
+	[42] = "PROCI_FACESUPPRESSION_T42",
+	[43] = "SPT_DIGITIZER_T43",
+	[44] = "SPT_MESSAGECOUNT_T44",
+};
+
+static u16 get_object_address(uint8_t object_type,
+			      uint8_t instance,
+			      struct mxt_object *object_table,
+			      int max_objs);
+
+int mxt_write_ap(struct mxt_data *mxt, u16 ap);
+
+static int mxt_read_block_wo_addr(struct i2c_client *client,
+			   u16 length,
+				u8 *value);
+
+#if WRITE_MT_CONFIG
+static const u8 atmel_1386_T7_config[] = {
+140,  //IDLEACQINT
+25, //ACTVACQINT
+60, //ACTV2IDLETO
+};
+
+static const u8 atmel_1386_T9_config[] = {
+0x03,  //CTRL 03
+0,  //XORIGIN
+0,  //YORIGIN
+28,  //XSIZE
+42,  //YSIZE
+0,  //AKSCFG
+32,  //BLEN
+60,  //TCHTHR
+3,  //TCHDI
+7, //1,//7,  //ORIENT//xhh
+0,  //MRGTIMEOUT
+5,  //MOVHYSTI
+5, //MOVHYSTN
+18,  //MOVFILTER
+10,  //NUMTOUCH
+10,  //MRGHYST
+10,  //MRGTHR
+10,  //AMPHYST
+0xff, //XRANGE low
+0x0f, //XRANGE high
+0xff, //YRANGE low
+0x0f, //YRANGE high
+0, //XLOCLIP
+0, //XHICLIP
+0, //YLOCLIP
+0, //YHICLIP
+0, //XEDGECTRL
+0, //XEDGEDIST
+0, //YEDGECTRL
+0, //YEDGEDIST
+0, //JUMPLIMIT
+0, //TCHHYST
+45, //XPITCH
+46, //YPITCH
+};
+
+static int atmel_1386_write_T7(struct mxt_data *mxt)
+{
+	int ret, i;
+	int size  = sizeof(atmel_1386_T7_config);
+	for(i = 0; i<size; i++)
+	{
+		ret = mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_POWERCONFIG_T7, mxt) +
+			      i,
+			      atmel_1386_T7_config[i]);
+		
+		if (ret < 0) {
+				MXT1386_LOG(KERN_INFO "%s, Error writing to atmel T7!\n", __func__);
+		}
+	}
+	return ret;
+}
+
+static int atmel_1386_write_T9(struct mxt_data *mxt)
+{
+	int ret, i;
+	int size  = sizeof(atmel_1386_T9_config);
+	
+	for(i = 0; i<size; i++)
+	{
+		ret = mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_TOUCH_MULTITOUCHSCREEN_T9, mxt) +
+			      i,
+			      atmel_1386_T9_config[i]);
+		
+		if (ret < 0) {
+				MXT1386_LOG(KERN_INFO "%s, Error writing to atmel T9!\n", __func__);				
+		}
+	}
+	return ret;
+}
+
+static int atmel_1386_write_config(struct mxt_data *mxt)
+{
+	atmel_1386_write_T7(mxt);
+	//atmel_1386_write_T9(mxt);
+
+	mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, mxt) +
+			      MXT_ADR_T6_BACKUPNV,
+			      MXT_CMD_T6_BACKUP);
+	/*		      
+	mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, mxt) +
+			      MXT_ADR_T6_RESET,
+			      1);
+	*/
+	return 0;
+}
+#endif
+
+static u8 mxt_valid_interrupt_dummy(void)
+{
+	return 0;
+}
+
+static int mxt_buf_test(const u8 *src, u8 length)
+{
+	u8 i;
+	u8 *pbuf = (u8*)src;
+
+	MXT1386_LOG(KERN_INFO "%s, buf test start..., length = %d\n", __func__, length);
+	for(i=0; i<length; i++) {
+		MXT1386_LOG("0x%02x  ", pbuf[i]);
+		if(0==(i+1)%10)
+			MXT1386_LOG("\n");
+	}
+	MXT1386_LOG(KERN_INFO "%s, buf test end...\n", __func__);
+
+	return 0;
+}
+
+ssize_t debug_data_read(struct mxt_data *mxt, char *buf, size_t count, 
+			loff_t *ppos, u8 debug_command){
+	int i;
+	u16 *data;
+	u16 diagnostics_reg;
+	int offset = 0;
+	int size;
+	int read_size;
+	int error;
+	char *buf_start;
+	u16 debug_data_addr;
+	u16 page_address;
+	u8 page;
+	u8 debug_command_reg;
+
+	data = mxt->debug_data;
+	if (data == NULL)
+		return -EIO;
+
+	/* If first read after open, read all data to buffer. */
+	if (mxt->current_debug_datap == 0){
+
+		diagnostics_reg = MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, 
+						mxt) + 
+			          MXT_ADR_T6_DIAGNOSTIC;
+		if (count > (mxt->device_info.num_nodes * 2))
+			count = mxt->device_info.num_nodes;
+	
+		debug_data_addr = MXT_BASE_ADDR(MXT_DEBUG_DIAGNOSTIC_T37, mxt)+ 
+			          MXT_ADR_T37_DATA;
+		page_address = MXT_BASE_ADDR(MXT_DEBUG_DIAGNOSTIC_T37, mxt) +
+			       MXT_ADR_T37_PAGE;
+		error = mxt_read_block(mxt->client, page_address, 1, &page);
+		if (error < 0)
+			return error;
+		MXT1386_LOG(KERN_INFO "debug data page = %d\n", __func__, page);		
+		while (page != 0) {
+			error = mxt_write_byte(mxt->client, 
+					diagnostics_reg, 
+					MXT_CMD_T6_PAGE_DOWN);
+			if (error < 0)
+				return error;
+			/* Wait for command to be handled; when it has, the
+			   register will be cleared. */
+			debug_command_reg = 1;
+			while (debug_command_reg != 0) {
+				error = mxt_read_block(mxt->client, 
+						diagnostics_reg, 1,
+						&debug_command_reg);
+				if (error < 0)
+					return error;
+				MXT1386_LOG(KERN_INFO "Waiting for debug diag command "
+					"to propagate...\n", __func__);
+
+			}
+		        error = mxt_read_block(mxt->client, page_address, 1, 
+					&page);
+			if (error < 0)
+				return error;
+			MXT1386_LOG(KERN_INFO "debug data page = %d\n", __func__, page);	
+		}
+
+		/*
+		 * Lock mutex to prevent writing some unwanted data to debug
+		 * command register. User can still write through the char 
+		 * device interface though. TODO: fix?
+		 */
+
+		mutex_lock(&mxt->debug_mutex);
+		/* Configure Debug Diagnostics object to show deltas/refs */
+		error = mxt_write_byte(mxt->client, diagnostics_reg,
+				debug_command);
+
+                /* Wait for command to be handled; when it has, the
+		 * register will be cleared. */
+		debug_command_reg = 1;
+		while (debug_command_reg != 0) {
+			error = mxt_read_block(mxt->client, 
+					diagnostics_reg, 1,
+					&debug_command_reg);
+			if (error < 0)
+				return error;
+			MXT1386_LOG(KERN_INFO "Waiting for debug diag command "
+				"to propagate...\n", __func__);
+
+		}	
+
+		if (error < 0) {
+			MXT1386_LOG(KERN_INFO "Error writing to maXTouch device!\n", __func__);
+			return error;
+		}
+	
+		size = mxt->device_info.num_nodes * sizeof(u16);
+
+		while (size > 0) {
+			read_size = size > 128 ? 128 : size;
+			MXT1386_LOG(KERN_INFO "Debug data read loop, reading %d bytes...\n", __func__,
+				read_size);
+			error = mxt_read_block(mxt->client, 
+					       debug_data_addr, 
+					       read_size, 
+					       (u8 *) &data[offset]);
+			if (error < 0) {
+				MXT1386_LOG(KERN_INFO "Error reading debug data\n", __func__);
+				goto error;
+			}
+			offset += read_size/2;
+			size -= read_size;
+
+			/* Select next page */
+			error = mxt_write_byte(mxt->client, diagnostics_reg, 
+					MXT_CMD_T6_PAGE_UP);
+			if (error < 0) {
+				MXT1386_LOG(KERN_INFO "Error writing to maXTouch device!\n", __func__);
+				goto error;
+			}
+		}
+		mutex_unlock(&mxt->debug_mutex);
+	}
+
+	buf_start = buf;
+	i = mxt->current_debug_datap;
+
+	while (((buf- buf_start) < (count - 6)) && 
+		(i < mxt->device_info.num_nodes)){
+
+		mxt->current_debug_datap++;
+		if (debug_command == MXT_CMD_T6_REFERENCES_MODE)
+			buf += sprintf(buf, "%d: %5d\n", i,
+				       (u16) le16_to_cpu(data[i]));
+		else if (debug_command == MXT_CMD_T6_DELTAS_MODE)
+			buf += sprintf(buf, "%d: %5d\n", i,
+				       (s16) le16_to_cpu(data[i]));
+		i++;
+	}
+
+	return (buf - buf_start);
+error:
+	mutex_unlock(&mxt->debug_mutex);
+	return error;
+}
+
+ssize_t deltas_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	return debug_data_read(file->private_data, buf, count, ppos, 
+			       MXT_CMD_T6_DELTAS_MODE);
+}
+
+ssize_t refs_read(struct file *file, char *buf, size_t count, 
+			loff_t *ppos)
+{
+	return debug_data_read(file->private_data, buf, count, ppos, 
+			       MXT_CMD_T6_REFERENCES_MODE);
+}
+
+int debug_data_open(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt;
+	int i;
+	mxt = inode->i_private;
+	if (mxt == NULL)
+		return -EIO;
+	mxt->current_debug_datap = 0;
+	mxt->debug_data = kmalloc(mxt->device_info.num_nodes * sizeof(u16),
+				  GFP_KERNEL);
+	if (mxt->debug_data == NULL)
+		return -ENOMEM;
+
+	
+	for (i = 0; i < mxt->device_info.num_nodes; i++)
+		mxt->debug_data[i] = 7777;
+	
+
+	file->private_data = mxt;
+	return 0;
+}
+
+int debug_data_release(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt;
+	mxt = file->private_data;
+	kfree(mxt->debug_data);
+	return 0;
+}
+
+static struct file_operations delta_fops = {
+	.owner = THIS_MODULE,
+	.open = debug_data_open,
+	.release = debug_data_release,
+	.read = deltas_read,
+};
+
+static struct file_operations refs_fops = {
+	.owner = THIS_MODULE,
+	.open = debug_data_open,
+	.release = debug_data_release,
+	.read = refs_read,
+};
+
+
+int mxt_memory_open(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt;
+	mxt = container_of(inode->i_cdev, struct mxt_data, cdev);
+	if (mxt == NULL)
+		return -EIO;
+	file->private_data = mxt;
+	return 0;
+}
+
+int mxt_message_open(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt;
+	mxt = container_of(inode->i_cdev, struct mxt_data, cdev_messages);
+	if (mxt == NULL)
+		return -EIO;
+	file->private_data = mxt;
+	return 0;
+}
+
+
+ssize_t mxt_memory_read(struct file *file, char *buf, size_t count, 
+			loff_t *ppos)
+{
+	int i;
+	struct mxt_data *mxt;
+
+	mxt = file->private_data;
+	if (mxt->valid_ap){
+		MXT1386_LOG(KERN_INFO "Reading %d bytes from current ap\n", __func__,
+			  (int) count);
+		i = mxt_read_block_wo_addr(mxt->client, count, (u8 *) buf);
+	} else {
+		MXT1386_LOG(KERN_INFO "Address pointer changed since set;"
+			  "writing AP (%d) before reading %d bytes", __func__, 
+			  mxt->address_pointer, (int) count);
+		i = mxt_read_block(mxt->client, mxt->address_pointer, count,
+			           buf);
+	}
+			
+	return i;
+}
+
+ssize_t mxt_memory_write(struct file *file, const char *buf, size_t count,
+			 loff_t *ppos)
+{
+	int i;
+	int whole_blocks;
+	int last_block_size;
+	struct mxt_data *mxt;
+	u16 address;
+	
+	mxt = file->private_data;
+	address = mxt->address_pointer;
+
+	MXT1386_LOG(KERN_INFO "mxt_memory_write entered\n", __func__);
+	whole_blocks = count / I2C_PAYLOAD_SIZE;
+	last_block_size = count % I2C_PAYLOAD_SIZE;
+
+	for (i = 0; i < whole_blocks; i++) {
+		MXT1386_LOG(KERN_INFO "About to write to %d...\n", __func__, 
+			address);
+		mxt_write_block(mxt->client, address, I2C_PAYLOAD_SIZE, 
+				(u8 *) buf);
+		address += I2C_PAYLOAD_SIZE;
+		buf += I2C_PAYLOAD_SIZE;
+	}
+
+	mxt_write_block(mxt->client, address, last_block_size, (u8 *) buf);
+
+	return count;
+}
+
+
+#define MXT_SET_ADDRESS  0
+#define MXT_RESET  1
+#define MXT_CALIBRATE  2
+#define MXT_BACKUP  3
+#define MXT_NONTOUCH_MSG  4
+#define MXT_ALL_MSG  5
+
+static int mxt_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg)
+{
+	int retval;
+	struct mxt_data *mxt;
+
+	retval = 0;
+	mxt = file->private_data;
+
+	switch (cmd) {
+	case MXT_SET_ADDRESS:
+		retval = mxt_write_ap(mxt, (u16) arg);
+		if (retval >= 0) {
+			mxt->address_pointer = (u16) arg;
+			mxt->valid_ap = 1;
+		}
+		break;
+	case MXT_RESET:
+		retval = mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, mxt) +
+			      MXT_ADR_T6_RESET,
+			      1);
+		break;
+	case MXT_CALIBRATE:
+		retval = mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, mxt) +
+			      MXT_ADR_T6_CALIBRATE,
+			      1);
+
+		break;
+	case MXT_BACKUP:
+		retval = mxt_write_byte(mxt->client,
+			      MXT_BASE_ADDR(MXT_GEN_COMMANDPROCESSOR_T6, mxt) +
+			      MXT_ADR_T6_BACKUPNV,
+			      MXT_CMD_T6_BACKUP);
+		break;
+	case MXT_NONTOUCH_MSG:
+		mxt->nontouch_msg_only = 1;
+		break;
+	case MXT_ALL_MSG:
+		mxt->nontouch_msg_only = 0;
+		break;
+	default:
+		return -EIO;
+	}
+
+	return retval;
+} 
+
+/*
+ * Copies messages from buffer to user space.
+ *
+ * NOTE: if less than (mxt->message_size * 5 + 1) bytes requested,
+ * this will return 0!
+ * 
+ */
+ssize_t mxt_message_read(struct file *file, char *buf, size_t count, 
+			 loff_t *ppos)
+{
+	int i;
+	struct mxt_data *mxt;
+	char *buf_start;
+	
+	mxt = file->private_data;
+	if (mxt == NULL)
+		return -EIO;
+	buf_start = buf;
+
+	mutex_lock(&mxt->msg_mutex);
+	/* Copy messages until buffer empty, or 'count' bytes written */
+	while ((mxt->msg_buffer_startp != mxt->msg_buffer_endp) &&
+	       ((buf - buf_start) < (count - 5 * mxt->message_size - 1))){
+
+		for (i = 0; i < mxt->message_size; i++){
+			buf += sprintf(buf, "[%2X] ",
+				*(mxt->messages + mxt->msg_buffer_endp *
+					mxt->message_size + i));
+		}
+		buf += sprintf(buf, "\n");
+		if (mxt->msg_buffer_endp < MXT_MESSAGE_BUFFER_SIZE)
+			mxt->msg_buffer_endp++;
+		else
+			mxt->msg_buffer_endp = 0;
+	}
+	mutex_unlock(&mxt->msg_mutex);
+	return (buf - buf_start);
+}
+
+static struct file_operations mxt_message_fops = {
+	.owner = THIS_MODULE,
+	.open = mxt_message_open,
+	.read = mxt_message_read,
+};
+
+static struct file_operations mxt_memory_fops = {
+	.owner = THIS_MODULE,
+	.open = mxt_memory_open,
+	.read = mxt_memory_read,
+	.write = mxt_memory_write,
+	.ioctl = mxt_ioctl,
+};
+
+
+/* Writes the address pointer (to set up following reads). */
+
+int mxt_write_ap(struct mxt_data *mxt, u16 ap)
+{
+	struct i2c_client *client;
+	__le16	le_ap = cpu_to_le16(ap);
+	client = mxt->client;
+	if (mxt != NULL)
+		mxt->last_read_addr = -1;
+	if (i2c_master_send(client, (u8 *) &le_ap, 2) == 2) {
+		MXT1386_LOG(KERN_INFO "Address pointer set to %d\n", __func__, ap);
+		return 0;
+	} else {
+		MXT1386_LOG(KERN_INFO "Error writing address pointer!\n", __func__);
+		return -EIO;
+	}
+}
+
+/* Calculates the 24-bit CRC sum. */
+static u32 CRC_24(u32 crc, u8 byte1, u8 byte2)
+{
+	static const u32 crcpoly = 0x80001B;
+	u32 result;
+	u32 data_word;
+
+	data_word = ((((u16) byte2) << 8u) | byte1);
+	result = ((crc << 1u) ^ data_word);
+	if (result & 0x1000000)
+		result ^= crcpoly;
+	return result;
+}
+
+/* Returns object address in mXT chip, or zero if object is not found */
+static u16 get_object_address(uint8_t object_type,
+			      uint8_t instance,
+			      struct mxt_object *object_table,
+			      int max_objs)
+{
+	uint8_t object_table_index = 0;
+	uint8_t address_found = 0;
+	uint16_t address = 0;
+	struct mxt_object *obj;
+
+	while ((object_table_index < max_objs) && !address_found) {
+		obj = &object_table[object_table_index];
+		if (obj->type == object_type) {
+			address_found = 1;
+			/* Are there enough instances defined in the FW? */
+			if (obj->instances >= instance) {
+				address = obj->chip_addr +
+					  (obj->size + 1) * instance;
+			} else {
+				return 0;
+			}
+		}
+		object_table_index++;
+	}
+	return address;
+}
+
+
+/*
+ * Reads a block of bytes from given address from mXT chip. If we are
+ * reading from message window, and previous read was from message window,
+ * there's no need to write the address pointer: the mXT chip will
+ * automatically set the address pointer back to message window start.
+ */
+
+static int mxt_read_block(struct i2c_client *client,
+		   u16 addr,
+		   u16 length,
+		   u8 *value)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	struct i2c_msg msg[2];
+	__le16	le_addr;
+	struct mxt_data *mxt;
+
+	mxt = i2c_get_clientdata(client);	
+	
+	if (mxt != NULL) {
+		MXT1386_LOG(KERN_INFO "%s: msg addr test, mxt->msg_proc_addr = 0x%x, mxt->last_read_addr = 0x%x, current addr = 0x%x\n", 
+		__func__, mxt->msg_proc_addr, mxt->last_read_addr, addr);
+		
+		if ((mxt->last_read_addr == addr) &&
+			(addr == mxt->msg_proc_addr)) {
+			if (i2c_master_recv(client, value, length) == length) {
+				MXT1386_LOG(KERN_INFO "%s: Host is reading from chip, addr = 0x%x, length = %d, *value = %d\n", 
+					__func__, addr, length, *value);
+				return length;
+			}				
+			else {
+				MXT1386_LOG(KERN_INFO "%s: Host read failed!\n", __func__);
+				return -EIO;
+			}				
+		} else {
+			mxt->last_read_addr = addr;
+		}
+	}
+
+	le_addr = cpu_to_le16(addr);
+	MXT1386_LOG(KERN_INFO "%s: Writing address pointer & reading, addr = 0x%02x, , le_addr = 0x%02x, length = %d, *value = %d\n", 
+			__func__, addr, le_addr, length, *value);
+	
+	msg[0].addr  = client->addr;
+	msg[0].flags = 0x00;
+	msg[0].len   = 2;
+	msg[0].buf   = (u8 *) &le_addr;
+
+	msg[1].addr  = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len   = length;
+	msg[1].buf   = (u8 *) value;
+	if  (i2c_transfer(adapter, msg, 2) == 2)
+		return length;
+	else
+		return -EIO;
+}
+
+/* Reads a block of bytes from current address from mXT chip. */
+static int mxt_read_block_wo_addr(struct i2c_client *client,
+			   u16 length,
+			   u8 *value)
+{
+	if  (i2c_master_recv(client, value, length) == length) {
+		MXT1386_LOG(KERN_INFO "%s: I2C block read ok\n", __func__);
+		return length;
+	} else {
+		MXT1386_LOG(KERN_INFO "%s: I2C block read failed\n", __func__);
+		return -EIO;
+	}
+}
+
+/* Writes one byte to given address in mXT chip. */
+static int mxt_write_byte(struct i2c_client *client, u16 addr, u8 value)
+{
+	struct {
+		__le16 le_addr;
+		u8 data;
+
+	} i2c_byte_transfer;
+
+	struct mxt_data *mxt;
+
+	mxt = i2c_get_clientdata(client);
+	if (mxt != NULL)
+		mxt->last_read_addr = -1;
+	i2c_byte_transfer.le_addr = cpu_to_le16(addr);
+	i2c_byte_transfer.data = value;
+	if  (i2c_master_send(client, (u8 *) &i2c_byte_transfer, 3) == 3)
+		return 0;
+	else
+		return -EIO;
+}
+
+/* Writes a block of bytes (max 256) to given address in mXT chip. */
+static int mxt_write_block(struct i2c_client *client,
+		    u16 addr,
+		    u16 length,
+		    u8 *value)
+{
+	int i;
+	struct {
+		__le16	le_addr;
+		u8	data[256];
+
+	} i2c_block_transfer;
+
+	struct mxt_data *mxt;
+
+	MXT1386_LOG("Writing %d bytes to %d...\n", length, addr);
+	if (length > 256)
+		return -EINVAL;
+	mxt = i2c_get_clientdata(client);
+	if (mxt != NULL)
+		mxt->last_read_addr = -1;
+	for (i = 0; i < length; i++)
+		i2c_block_transfer.data[i] = *value++;
+	i2c_block_transfer.le_addr = cpu_to_le16(addr);
+	i = i2c_master_send(client, (u8 *) &i2c_block_transfer, length + 2);
+	if (i == (length + 2))
+		return length;
+	else
+		return -EIO;
+}
+
+/* Calculates the CRC value for mXT infoblock. */
+int calculate_infoblock_crc(u32 *crc_result, u8 *data, int crc_area_size)
+{
+	u32 crc = 0;
+	int i;
+
+	for (i = 0; i < (crc_area_size - 1); i = i + 2)
+		crc = CRC_24(crc, *(data + i), *(data + i + 1));
+	/* If uneven size, pad with zero */
+	if (crc_area_size & 0x0001)
+		crc = CRC_24(crc, *(data + i), 0);
+	/* Return only 24 bits of CRC. */
+	*crc_result = (crc & 0x00FFFFFF);
+
+	return 0;
+}
+
+int find_touch_key_value( struct mxt_data *mxt, int status, u16 ypos)
+{
+    int i = 0;
+    for(i=0; i<ARRAY_SIZE(key_info); i++)
+    {
+        if((ypos > key_info[i].start) && (ypos < key_info[i].end))
+        {          
+           printk("%s key_code = %d \n",__func__,key_info[i].code);
+            if(status & MXT_MSGB_T9_DETECT)
+            {
+                input_report_key(mxt->input, key_info[i].code, 1);
+                input_sync(mxt->input);
+                last_key = key_info[i].code;
+            }
+            else
+            {
+                printk("%s key_code = %d relase\n",__func__,key_info[i].code);
+                input_report_key(mxt->input, key_info[i].code, 0);
+                input_sync(mxt->input);
+                last_key = 0;
+
+            }           
+            break;
+        }
+    }
+   
+
+    return 0;    
+}
+
+
+void process_T9_message(u8 *message, struct mxt_data *mxt)
+{
+	struct	input_dev *input;
+	u8  status;
+	u16 xpos = 0xFFFF;
+	u16 ypos = 0xFFFF;
+	u8  touch_size = 255;
+	u8  touch_number;
+	u8  amplitude;
+	u8  report_id;
+    u32 key_code = 0;
+    
+	input = mxt->input;
+	status = message[MXT_MSG_T9_STATUS];
+	report_id = message[0];
+
+	if (status & MXT_MSGB_T9_SUPPRESS) {
+		/* Touch has been suppressed by grip/face */
+		/* detection                              */
+		MXT1386_LOG(KERN_INFO "SUPRESS\n", __func__);
+	} else {
+		MXT1386_LOG("XPOSMSB = 0x%02x, YPOSMSB = 0x%02x, XYPOSLSB = 0x%02x\n",
+			message[MXT_MSG_T9_XPOSMSB], message[MXT_MSG_T9_YPOSMSB], message[MXT_MSG_T9_XYPOSLSB]);
+		
+		xpos = message[MXT_MSG_T9_XPOSMSB] * 16 +
+			((message[MXT_MSG_T9_XYPOSLSB] >> 4) & 0xF);
+		ypos = message[MXT_MSG_T9_YPOSMSB] * 16 +
+			((message[MXT_MSG_T9_XYPOSLSB] >> 0) & 0xF);
+
+		MXT1386_LOG("Before Reverse: xpos = %d, ypos = %d\n", xpos, ypos);
+		#if 0 //xhh
+		//X
+		if( xpos < CONFIG_ATMEL_MXT1386_MAX_X)
+			xpos = CONFIG_ATMEL_MXT1386_MAX_X - xpos;
+		else
+			xpos = 0;
+
+		//Y
+		if( ypos < CONFIG_ATMEL_MXT1386_MAX_Y)
+			ypos = CONFIG_ATMEL_MXT1386_MAX_Y - ypos;
+		else
+			ypos = 0;
+		#endif
+        
+        #if TOUCH_KEY_EN
+		if( xpos < 8 && xpos >= 0)
+		{
+            find_touch_key_value(mxt, status, ypos); 
+            return;
+        } 
+        else if(last_key)
+        {
+            
+            printk("%s key_code = %d relase\n",__func__,last_key);
+            input_report_key(mxt->input, last_key, 0);
+            input_sync(mxt->input);
+            last_key = 0;  
+        }
+		#endif	
+        
+		MXT1386_LOG("After Reverse: xpos = %d, ypos = %d\n", xpos, ypos);
+
+		touch_number = message[MXT_MSG_REPORTID] -
+			mxt->rid_map[report_id].first_rid;
+
+		if (status & MXT_MSGB_T9_DETECT) {
+			/*
+			 * TODO: more precise touch size calculation?
+			 * mXT224 reports the number of touched nodes,
+			 * so the exact value for touch ellipse major
+			 * axis length would be 2*sqrt(touch_size/pi)
+			 * (assuming round touch shape).
+			 */
+			MXT1386_LOG(KERN_INFO " ----process_T9_message --MXT_MSGB_T9_DETECT--- \n", __func__);
+			touch_size = message[MXT_MSG_T9_TCHAREA];
+			touch_size = touch_size >> 2;
+			if (!touch_size)
+				touch_size = 1;
+			report_mt(touch_number, touch_size, xpos, ypos, mxt);
+			if (status & MXT_MSGB_T9_AMP)
+				/* Amplitude of touch has changed */
+				amplitude = message[MXT_MSG_T9_TCHAMPLITUDE];
+		} else if (status & MXT_MSGB_T9_RELEASE) {
+			/* The previously reported touch has been removed.*/
+			MXT1386_LOG(KERN_INFO " ----process_T9_message --MXT_MSGB_T9_RELEASE--- \n", __func__);
+			report_mt(touch_number, 0, xpos, ypos, mxt);
+		}
+		#ifdef EFFICIENT_REPORT
+		#else
+		report_sync(mxt);
+		#endif
+	}
+	
+	if (status & MXT_MSGB_T9_SUPPRESS) {
+		MXT1386_LOG(KERN_INFO "SUPRESS", __func__);
+	} else {
+		if (status & MXT_MSGB_T9_DETECT) {
+			MXT1386_LOG(KERN_INFO "DETECT:%s%s%s%s", __func__, 
+				((status & MXT_MSGB_T9_PRESS) ? " PRESS" : ""), 
+				((status & MXT_MSGB_T9_MOVE) ? " MOVE" : ""), 
+				((status & MXT_MSGB_T9_AMP) ? " AMP" : ""), 
+				((status & MXT_MSGB_T9_VECTOR) ? " VECT" : ""));
+
+		} else if (status & MXT_MSGB_T9_RELEASE) {
+			MXT1386_LOG(KERN_INFO "RELEASE");
+		}
+	}
+	MXT1386_LOG(KERN_INFO "X=%d, Y=%d, TOUCHSIZE=%d", __func__,
+		xpos, ypos, touch_size);
+
+	return;
+}
+
+int process_message(u8 *message, u8 object, struct mxt_data *mxt)
+{
+	struct i2c_client *client;
+	u8  status;
+	u16 xpos = 0xFFFF;
+	u16 ypos = 0xFFFF;
+	u8  event;
+	u8  direction;
+	u16 distance;
+	u8  length;
+	u8  report_id;
+    int  keyIndex;
+
+	client = mxt->client;
+	length = mxt->message_size;
+	report_id = message[0];
+
+	if ((mxt->nontouch_msg_only == 0) ||
+	    (!IS_TOUCH_OBJECT(object))){
+		mutex_lock(&mxt->msg_mutex);
+		/* Copy the message to buffer */
+		if (mxt->msg_buffer_startp < MXT_MESSAGE_BUFFER_SIZE) {
+			mxt->msg_buffer_startp++;
+		} else {
+			mxt->msg_buffer_startp = 0;
+		}
+		
+		if (mxt->msg_buffer_startp == mxt->msg_buffer_endp) {
+			MXT1386_LOG(KERN_INFO "Message buf full, discarding last entry.\n", __func__);
+			if (mxt->msg_buffer_endp < MXT_MESSAGE_BUFFER_SIZE) {
+				mxt->msg_buffer_endp++;
+			} else {
+				mxt->msg_buffer_endp = 0;
+			}
+		}
+		memcpy((mxt->messages + mxt->msg_buffer_startp * length), 
+		       message,
+		       length);
+		mutex_unlock(&mxt->msg_mutex);
+	}
+
+	switch (object) {
+	case MXT_GEN_COMMANDPROCESSOR_T6:
+		status = message[1];
+		if (status & MXT_MSGB_T6_COMSERR) {
+			dev_err(&client->dev,
+				"maXTouch checksum error\n");
+		}
+		if (status & MXT_MSGB_T6_CFGERR) {
+			/* 
+			 * Configuration error. A proper configuration
+			 * needs to be written to chip and backed up. Refer
+			 * to protocol document for further info.
+			 */
+			dev_err(&client->dev,
+				"maXTouch configuration error\n");
+		}
+		if (status & MXT_MSGB_T6_CAL) {
+			/* Calibration in action, no need to react */
+			dev_info(&client->dev,
+				"maXTouch calibration in progress\n");
+		}
+		if (status & MXT_MSGB_T6_SIGERR) {
+			/* 
+			 * Signal acquisition error, something is seriously
+			 * wrong, not much we can in the driver to correct
+			 * this
+			 */
+			dev_err(&client->dev,
+				"maXTouch acquisition error\n");
+		}
+		if (status & MXT_MSGB_T6_OFL) {
+			/*
+			 * Cycle overflow, the acquisition is too short.
+			 * Can happen temporarily when there's a complex
+			 * touch shape on the screen requiring lots of
+			 * processing.
+			 */
+			dev_err(&client->dev,
+				"maXTouch cycle overflow\n");
+		}
+		if (status & MXT_MSGB_T6_RESET) {
+			/* Chip has reseted, no need to react. */
+			dev_info(&client->dev,
+				"maXTouch chip reset\n");
+		}
+		if (status == 0) {
+			/* Chip status back to normal. */
+			dev_info(&client->dev,
+				"maXTouch status normal\n");
+		}
+		break;
+
+	case MXT_TOUCH_MULTITOUCHSCREEN_T9:
+		process_T9_message(message, mxt);
+		break;
+
+	case MXT_SPT_GPIOPWM_T19:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving GPIO message\n");
+		break;
+
+	case MXT_PROCI_GRIPFACESUPPRESSION_T20:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving face suppression msg\n");
+		break;
+
+	case MXT_PROCG_NOISESUPPRESSION_T22:
+		printk("--------- MXT_PROCG_NOISESUPPRESSION_T22 enter! ---------\n");
+		//if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving noise suppression msg\n");
+		status = message[MXT_MSG_T22_STATUS];
+		if (status & MXT_MSGB_T22_FHCHG) {
+			//if (debug >= DEBUG_TRACE)
+				dev_info(&client->dev,
+					"maXTouch: Freq changed\n");
+		}
+		if (status & MXT_MSGB_T22_GCAFERR) {
+			//if (debug >= DEBUG_TRACE)
+				dev_info(&client->dev,
+					"maXTouch: High noise "
+					"level\n");
+		}
+		if (status & MXT_MSGB_T22_FHERR) {
+			//if (debug >= DEBUG_TRACE)
+				dev_info(&client->dev,
+					"maXTouch: Freq changed - "
+					"Noise level too high\n");
+		}
+		break;
+
+	case MXT_PROCI_ONETOUCHGESTUREPROCESSOR_T24:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving one-touch gesture msg\n");
+
+		event = message[MXT_MSG_T24_STATUS] & 0x0F;
+		xpos = message[MXT_MSG_T24_XPOSMSB] * 16 +
+			((message[MXT_MSG_T24_XYPOSLSB] >> 4) & 0x0F);
+		ypos = message[MXT_MSG_T24_YPOSMSB] * 16 +
+			((message[MXT_MSG_T24_XYPOSLSB] >> 0) & 0x0F);
+		xpos >>= 2;
+		ypos >>= 2;
+		direction = message[MXT_MSG_T24_DIR];
+		distance = message[MXT_MSG_T24_DIST] +
+			   (message[MXT_MSG_T24_DIST + 1] << 16);
+
+		report_gesture((event << 24) | (direction << 16) | distance,
+			mxt);
+		report_gesture((xpos << 16) | ypos, mxt);
+
+		break;
+
+	case MXT_SPT_SELFTEST_T25:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving Self-Test msg\n");
+
+		if (message[MXT_MSG_T25_STATUS] == MXT_MSGR_T25_OK) {
+			if (debug >= DEBUG_TRACE)
+				dev_info(&client->dev,
+					"maXTouch: Self-Test OK\n");
+
+		} else  {
+			dev_err(&client->dev,
+				"maXTouch: Self-Test Failed [%02x]:"
+				"{%02x,%02x,%02x,%02x,%02x}\n",
+				message[MXT_MSG_T25_STATUS],
+				message[MXT_MSG_T25_STATUS + 0],
+				message[MXT_MSG_T25_STATUS + 1],
+				message[MXT_MSG_T25_STATUS + 2],
+				message[MXT_MSG_T25_STATUS + 3],
+				message[MXT_MSG_T25_STATUS + 4]
+				);
+		}
+		break;
+
+	case MXT_PROCI_TWOTOUCHGESTUREPROCESSOR_T27:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving 2-touch gesture message\n");
+
+		event = message[MXT_MSG_T27_STATUS] & 0xF0;
+		xpos = message[MXT_MSG_T27_XPOSMSB] * 16 +
+			((message[MXT_MSG_T27_XYPOSLSB] >> 4) & 0x0F);
+		ypos = message[MXT_MSG_T27_YPOSMSB] * 16 +
+			((message[MXT_MSG_T27_XYPOSLSB] >> 0) & 0x0F);
+		xpos >>= 2;
+		ypos >>= 2;
+		direction = message[MXT_MSG_T27_ANGLE];
+		distance = message[MXT_MSG_T27_SEPARATION] +
+			   (message[MXT_MSG_T27_SEPARATION + 1] << 16);
+
+		report_gesture((event << 24) | (direction << 16) | distance,
+			mxt);
+		report_gesture((xpos << 16) | ypos, mxt);
+
+
+		break;
+
+	case MXT_SPT_CTECONFIG_T28:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"Receiving CTE message...\n");
+		status = message[MXT_MSG_T28_STATUS];
+		if (status & MXT_MSGB_T28_CHKERR)
+			dev_err(&client->dev,
+				"maXTouch: Power-Up CRC failure\n");
+
+		break;
+        
+	default:
+		if (debug >= DEBUG_TRACE)
+			dev_info(&client->dev,
+				"maXTouch: Unknown message!\n");
+
+		break;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Processes messages when the interrupt line (CHG) is asserted. Keeps
+ * reading messages until a message with report ID 0xFF is received,
+ * which indicates that there is no more new messages.
+ *
+ */
+
+static void ts_thread_1386(struct work_struct *work)
+{
+	struct	mxt_data *mxt;
+	struct	i2c_client *client;
+
+	u8	*message;
+	u16	message_length;
+	u16	message_addr;
+	u8	report_id = 0;
+	u8	object = 0;
+	#ifdef EFFICIENT_REPORT
+	u8 	has_multitouch_msg = 0;
+	#endif
+	int	error;
+	int	i;
+	char    *message_string;
+	char    *message_start;
+	static u32 count;
+
+	message = NULL;
+	//mxt = container_of(work, struct mxt_data, dwork.work);
+	mxt = atmel_mxt;
+	//disable_irq(mxt->irq);
+	client = mxt->client;
+	message_addr = 	mxt->msg_proc_addr;
+	message_length = mxt->message_size;
+
+	MXT1386_LOG(KERN_INFO "%s: ts_thread_1386 entry %d times!\n", __func__, ++count);
+
+	if (message_length < 256) {
+		message = kmalloc(message_length, GFP_KERNEL);
+		if (message == NULL) {
+			dev_err(&client->dev, "Error allocating memory\n");
+			return;
+		}
+	} else {
+		dev_err(&client->dev,
+			"Message length larger than 256 bytes not supported\n");
+		return;
+	}
+
+	do {
+		/* Read next message, reread on failure. */
+		mxt->message_counter++;
+		for (i = 1; i < I2C_RETRY_COUNT; i++) {
+			error = mxt_read_block(client,
+					       message_addr,
+					       message_length,
+					       message);
+			if (error >= 0)
+				break;
+			mxt->read_fail_counter++;
+			dev_err(&client->dev,
+				"Failure reading maxTouch device\n");
+		}
+		if (error < 0) {
+			kfree(message);
+			return;
+		}
+		
+		if (mxt->address_pointer != message_addr)
+			mxt->valid_ap = 0;
+		report_id = message[0];
+
+		if (debug >= DEBUG_RAW) {
+			MXT1386_LOG(KERN_INFO "%s: %s message [msg count: %08x]:", __func__,
+				  REPORT_ID_TO_OBJECT_NAME(report_id, mxt),
+				  mxt->message_counter
+			);
+			/* 5 characters per one byte */
+			message_string = kmalloc(message_length * 5, 
+						 GFP_KERNEL);
+			if (message_string == NULL) {
+				dev_err(&client->dev, 
+					"Error allocating memory\n");
+				kfree(message);
+				return;
+			}
+			message_start = message_string;
+			for (i = 0; i < message_length; i++) {
+				message_string += 
+					sprintf(message_string, 
+						"0x%02X ", message[i]);
+			}
+			MXT1386_LOG(KERN_INFO "%s", message_start, __func__);
+			kfree(message_start);
+		}
+
+		if ((report_id != MXT_END_OF_MESSAGES) && (report_id != 0)) {
+			memcpy(mxt->last_message, message, message_length);
+			mxt->new_msgs = 1;
+			smp_wmb();
+			/* Get type of object and process the message */
+			object = mxt->rid_map[report_id].object;
+			
+			MXT1386_LOG(KERN_INFO "current value: mxt->rid_map[%d].object = %d, object = %d\n",
+				__func__, report_id, mxt->rid_map[report_id].object, object);
+			mxt_buf_test(message, message_length);
+			
+			process_message(message, object, mxt);
+			MXT1386_LOG(KERN_INFO "trace 0\n", __func__);
+		}
+		
+		#ifdef EFFICIENT_REPORT
+		if(object == MXT_TOUCH_MULTITOUCHSCREEN_T9)
+		{
+			has_multitouch_msg = 1;
+		}
+		else if( has_multitouch_msg == 1)
+		{
+			has_multitouch_msg = 0;
+			report_sync(mxt);
+		}
+		object = 0;
+		#endif		
+
+	} while (comms ? (mxt->read_chg() == 0) : 
+		((report_id != MXT_END_OF_MESSAGES) && (report_id != 0)));
+	//} while ((report_id != MXT_END_OF_MESSAGES) && (report_id != 0));
+
+	/*
+	#ifdef EFFICIENT_REPORT
+	report_sync(mxt);
+	#endif
+	*/
+	
+	kfree(message);
+
+	MXT1386_LOG(KERN_INFO "%s: Now will enable the irq, ts_irq = %d\n", __func__, ts_irq);
+	enable_irq(mxt->irq);
+    //printk("%s, int_pin = %d \n",__func__,gpio_get_value(client->irq));
+}
+
+/*
+ * The maXTouch device will signal the host about a new message by asserting
+ * the CHG line. This ISR schedules a worker routine to read the message when
+ * that happens.
+ */
+ 
+//static struct workqueue_struct *queue = NULL;
+//static struct work_struct work;
+
+static irqreturn_t mxt_irq_handler(int irq, void *dev_id)
+{	
+	struct mxt_data *mxt = (struct mxt_data *)dev_id;
+    struct i2c_client *client = mxt->client;
+	int int_value = client->irq;
+	static u8 wakeup_flag;
+	static u32 counter;
+	/* TP: LCDstandbyLCDC_CSLCDC_CSDCtoDCTPVCC
+	TPVCCTPTPVCCTPISRTP 
+	LCDSwakeup_flag1*/
+	
+#if 0
+	MXT1386_LOG(KERN_INFO "mxt_irq_handler() IN\n");
+
+	mxt->irq_counter++;
+	if (mxt->valid_interrupt()) {
+		/* Send the signal only if falling edge generated the irq. */
+		cancel_delayed_work(&mxt->dwork);
+		schedule_delayed_work(&mxt->dwork, 0);
+		mxt->valid_irq_counter++;
+	} else {
+		mxt->invalid_irq_counter++;
+		return IRQ_NONE;
+	}
+
+	MXT1386_LOG(KERN_INFO "-------------- Be carefull MXC_touchscreen interrupt comes! --------------\n", __func__);
+	MXT1386_LOG(KERN_INFO "interrupt counter road\n");
+	disable_irq_nosync(mxt->irq);
+
+	queue_work(mxt->queue,&mxt->work);
+	
+#else
+
+	MXT1386_LOG(KERN_INFO "-------------- Be carefull MXC_touchscreen interrupt comes! --------------\n", __func__);
+	MXT1386_LOG(KERN_INFO "ts_irq = %d, irq = %d, mxt->irq = %d, TOUCH_INT_PIN = %d\n", __func__, ts_irq, irq, mxt->irq, int_value);
+
+	if(gpio_get_value(LCDC_STANDBY_PIN)) {
+		MXT1386_LOG(KERN_INFO "%s: LCDC_STANDBY_PIN test, value is high\n", __func__);
+
+		if (0==wakeup_flag) {
+			disable_irq_nosync(mxt->irq);
+		}
+		else {
+			wakeup_flag = 0;
+		}
+		
+#if WORKQ_RIGHTNOW
+		MXT1386_LOG(KERN_INFO "%s: queue_work start\n", __func__);
+		queue_work(mxt->queue,&mxt->work);
+#else
+		MXT1386_LOG(KERN_INFO "%s: queue_delayed_work start\n", __func__);
+		queue_delayed_work(mxt->queue, &mxt->dwork, 0);
+#endif
+	}
+	else {
+		MXT1386_LOG(KERN_INFO "%s: LCDC_STANDBY_PIN test, value is low\n", __func__);	
+		wakeup_flag = 1;
+		return IRQ_NONE;
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+/******************************************************************************/
+/* Initialization of driver                                                   */
+/******************************************************************************/
+
+static int __devinit mxt_identify(struct i2c_client *client,
+				  struct mxt_data *mxt,
+				  u8 *id_block_data)
+{
+	u8 buf[7];
+	int error;
+	int identified;
+
+	identified = 0;
+
+	/* Read Device info to check if chip is valid */
+	error = mxt_read_block(client, MXT_ADDR_INFO_BLOCK, MXT_ID_BLOCK_SIZE,
+			       (u8 *) buf);
+
+	if (error < 0) {
+		mxt->read_fail_counter++;
+		dev_err(&client->dev, "Failure accessing maXTouch device\n");
+		return -EIO;
+	}
+
+	memcpy(id_block_data, buf, MXT_ID_BLOCK_SIZE);
+
+	mxt->device_info.family_id  = buf[0];
+	mxt->device_info.variant_id = buf[1];
+	mxt->device_info.major	    = ((buf[2] >> 4) & 0x0F);
+	mxt->device_info.minor      = (buf[2] & 0x0F);
+	mxt->device_info.build	    = buf[3];
+	mxt->device_info.x_size	    = buf[4];
+	mxt->device_info.y_size	    = buf[5];
+	mxt->device_info.num_objs   = buf[6];
+	mxt->device_info.num_nodes  = mxt->device_info.x_size *
+				      mxt->device_info.y_size;
+
+	/*
+         * Check Family & Variant Info; warn if not recognized but
+         * still continue.
+         */
+
+	/* MXT224 */
+	if (mxt->device_info.family_id == MXT224_FAMILYID) {
+		strcpy(mxt->device_info.family_name, "mXT224");
+
+		if (mxt->device_info.variant_id == MXT224_CAL_VARIANTID) {
+			strcpy(mxt->device_info.variant_name, "Calibrated");
+		} else if (mxt->device_info.variant_id == 
+			MXT224_UNCAL_VARIANTID) {
+			strcpy(mxt->device_info.variant_name, "Uncalibrated");
+		} else {
+			dev_err(&client->dev,
+				"Warning: maXTouch Variant ID [%d] not "
+				"supported\n",
+				mxt->device_info.variant_id);
+			strcpy(mxt->device_info.variant_name, "UNKNOWN");
+			/* identified = -ENXIO; */
+		}
+
+	/* MXT1386 */
+	} else if (mxt->device_info.family_id == MXT1386_FAMILYID) {
+		strcpy(mxt->device_info.family_name, "mXT1386");
+
+		if (mxt->device_info.variant_id == MXT1386_CAL_VARIANTID) {
+			strcpy(mxt->device_info.variant_name, "Calibrated");
+		} else {
+			dev_err(&client->dev,
+				"Warning: maXTouch Variant ID [%d] not "
+				"supported\n",
+				mxt->device_info.variant_id);
+			strcpy(mxt->device_info.variant_name, "UNKNOWN");
+			/* identified = -ENXIO; */
+		}
+	/* Unknown family ID! */
+	} else {
+		dev_err(&client->dev,
+			"Warning: maXTouch Family ID [%d] not supported\n",
+			mxt->device_info.family_id);
+		strcpy(mxt->device_info.family_name, "UNKNOWN");
+		strcpy(mxt->device_info.variant_name, "UNKNOWN");
+		/* identified = -ENXIO; */
+	}
+
+	dev_info(
+		&client->dev,
+		"Atmel maXTouch (Family %s (%X), Variant %s (%X)) Firmware "
+		"version [%d.%d] Build %d, num_objs = %d\n",
+		mxt->device_info.family_name,
+		mxt->device_info.family_id,
+		mxt->device_info.variant_name,
+		mxt->device_info.variant_id,
+		mxt->device_info.major,
+		mxt->device_info.minor,
+		mxt->device_info.build,
+		mxt->device_info.num_objs
+	);
+	dev_info(
+		&client->dev,
+		"Atmel maXTouch Configuration "
+		"[X: %d] x [Y: %d]\n",
+		mxt->device_info.x_size,
+		mxt->device_info.y_size
+	);
+	return identified;
+}
+
+/*
+ * Reads the object table from maXTouch chip to get object data like
+ * address, size, report id. For Info Block CRC calculation, already read
+ * id data is passed to this function too (Info Block consists of the ID
+ * block and object table).
+ *
+ */
+static int __devinit mxt_read_object_table(struct i2c_client *client,
+					   struct mxt_data *mxt,
+					   u8 *raw_id_data)
+{
+	u16	report_id_count;
+	u8	buf[MXT_OBJECT_TABLE_ELEMENT_SIZE];
+	u8      *raw_ib_data;
+	u8	object_type;
+	u16	object_address;
+	u16	object_size;
+	u8	object_instances;
+	u8	object_report_ids;
+	u16	object_info_address;
+	u32	crc;
+	u32     calculated_crc;
+	int	i;
+	int	error;
+
+	u8	object_instance;
+	u8	object_report_id;
+	u8	report_id;
+	int     first_report_id;
+	int     ib_pointer;
+	struct mxt_object *object_table;
+
+	MXT1386_LOG(KERN_INFO "maXTouch driver reading configuration\n", __func__);
+
+	object_table = kzalloc(sizeof(struct mxt_object) *
+			       mxt->device_info.num_objs,
+			       GFP_KERNEL);
+	if (object_table == NULL) {
+		MXT1386_LOG(KERN_INFO "maXTouch: Memory allocation failed!\n", __func__);
+		error = -ENOMEM;
+		goto err_object_table_alloc;
+	}
+
+	raw_ib_data = kmalloc(MXT_OBJECT_TABLE_ELEMENT_SIZE *
+			mxt->device_info.num_objs + MXT_ID_BLOCK_SIZE,
+			GFP_KERNEL);
+	if (raw_ib_data == NULL) {
+		MXT1386_LOG(KERN_INFO "maXTouch: Memory allocation failed!\n", __func__);
+		error = -ENOMEM;
+		goto err_ib_alloc;
+	}
+
+	/* Copy the ID data for CRC calculation. */
+	memcpy(raw_ib_data, raw_id_data, MXT_ID_BLOCK_SIZE);
+	ib_pointer = MXT_ID_BLOCK_SIZE;
+
+	mxt->object_table = object_table;
+
+	MXT1386_LOG(KERN_INFO "maXTouch driver Memory allocated\n", __func__);
+
+	object_info_address = MXT_ADDR_OBJECT_TABLE;
+
+	report_id_count = 0;
+	for (i = 0; i < mxt->device_info.num_objs; i++) {
+		MXT1386_LOG(KERN_INFO "Reading maXTouch at [0x%04x]: ", __func__,
+			  object_info_address);
+
+		error = mxt_read_block(client, object_info_address,
+				       MXT_OBJECT_TABLE_ELEMENT_SIZE, buf);
+
+		if (error < 0) {
+			mxt->read_fail_counter++;
+			dev_err(&client->dev,
+				"maXTouch Object %d could not be read\n", __func__, i);
+			error = -EIO;
+			goto err_object_read;
+		}
+
+		memcpy(raw_ib_data + ib_pointer, buf, 
+		       MXT_OBJECT_TABLE_ELEMENT_SIZE);
+		ib_pointer += MXT_OBJECT_TABLE_ELEMENT_SIZE;
+
+		object_type       =  buf[0];
+		object_address    = (buf[2] << 8) + buf[1];
+		object_size       =  buf[3] + 1;
+		object_instances  =  buf[4] + 1;
+		object_report_ids =  buf[5];
+		MXT1386_LOG(KERN_INFO "Type=%03d, Address=0x%04x, "
+			  "Size=0x%02x, %d instances, %d report id's\n", __func__,
+			  object_type,
+			  object_address,
+			  object_size,
+			  object_instances,
+			  object_report_ids
+		);
+
+		/* TODO: check whether object is known and supported? */
+		
+		/* Save frequently needed info. */
+		if (object_type == MXT_GEN_MESSAGEPROCESSOR_T5) {
+			mxt->msg_proc_addr = object_address;
+			mxt->message_size = object_size;
+		}
+
+		object_table[i].type            = object_type;
+		object_table[i].chip_addr       = object_address;
+		object_table[i].size            = object_size;
+		object_table[i].instances       = object_instances;
+		object_table[i].num_report_ids  = object_report_ids;
+		report_id_count += object_instances * object_report_ids;
+
+		object_info_address += MXT_OBJECT_TABLE_ELEMENT_SIZE;
+	}
+
+	mxt->rid_map =
+		kzalloc(sizeof(struct report_id_map) * (report_id_count + 1),
+			/* allocate for report_id 0, even if not used */
+			GFP_KERNEL);
+	if (mxt->rid_map == NULL) {
+		MXT1386_LOG(KERN_INFO "maXTouch: Can't allocate memory!\n", __func__);
+		error = -ENOMEM;
+		goto err_rid_map_alloc;
+	}
+
+	mxt->messages = kzalloc(mxt->message_size * MXT_MESSAGE_BUFFER_SIZE,
+				GFP_KERNEL);
+	if (mxt->messages == NULL) {
+		MXT1386_LOG(KERN_INFO "maXTouch: Can't allocate memory!\n", __func__);
+		error = -ENOMEM;
+		goto err_msg_alloc;
+	}
+
+	mxt->last_message = kzalloc(mxt->message_size, GFP_KERNEL);
+	if (mxt->last_message == NULL) {
+		MXT1386_LOG(KERN_INFO "maXTouch: Can't allocate memory!\n", __func__);
+		error = -ENOMEM;
+		goto err_msg_alloc;
+	}
+
+	mxt->report_id_count = report_id_count;
+	if (report_id_count > 254) {	/* 0 & 255 are reserved */
+			dev_err(&client->dev,
+				"Too many maXTouch report id's [%d]\n",
+				report_id_count);
+			error = -ENXIO;
+			goto err_max_rid;
+	}
+
+	/* Create a mapping from report id to object type */
+	report_id = 1; /* Start from 1, 0 is reserved. */
+
+	/* Create table associating report id's with objects & instances */
+	for (i = 0; i < mxt->device_info.num_objs; i++) {
+		for (object_instance = 0;
+		     object_instance < object_table[i].instances;
+		     object_instance++){
+			first_report_id = report_id;
+			for (object_report_id = 0;
+			     object_report_id < object_table[i].num_report_ids;
+			     object_report_id++) {
+				mxt->rid_map[report_id].object =
+					object_table[i].type;
+				mxt->rid_map[report_id].instance =
+					object_instance;
+				mxt->rid_map[report_id].first_rid =
+					first_report_id;
+				report_id++;
+			}
+		}
+	}
+
+	/* Read 3 byte CRC */
+	error = mxt_read_block(client, object_info_address, 3, buf);
+	if (error < 0) {
+		mxt->read_fail_counter++;
+		dev_err(&client->dev, "Error reading CRC\n");
+	}
+
+	crc = (buf[2] << 16) | (buf[1] << 8) | buf[0];
+
+	if (calculate_infoblock_crc(&calculated_crc, raw_ib_data,
+				    ib_pointer)) {
+		MXT1386_LOG(KERN_INFO "Error while calculating CRC!\n");
+		calculated_crc = 0;
+	}
+	kfree(raw_ib_data);
+
+	MXT1386_LOG(KERN_INFO "Reported info block CRC = 0x%6X\n", __func__, crc);
+	MXT1386_LOG(KERN_INFO "Calculated info block CRC = 0x%6X\n\n", __func__, calculated_crc);
+	
+	if (crc == calculated_crc) {
+		mxt->info_block_crc = crc;
+	} else {
+		mxt->info_block_crc = 0;
+		MXT1386_LOG(KERN_INFO "maXTouch: Info block CRC invalid!\n"), __func__;
+	}
+
+	if (debug >= DEBUG_VERBOSE) {
+
+		dev_info(&client->dev, "maXTouch: %d Objects\n",
+				mxt->device_info.num_objs);
+
+		for (i = 0; i < mxt->device_info.num_objs; i++) {
+			dev_info(&client->dev, "Type:\t\t\t[%d]: %s\n",
+				 object_table[i].type,
+				 object_type_name[object_table[i].type]);
+			dev_info(&client->dev, "\tAddress:\t0x%04X\n",
+				object_table[i].chip_addr);
+			dev_info(&client->dev, "\tSize:\t\t%d Bytes\n",
+				 object_table[i].size);
+			dev_info(&client->dev, "\tInstances:\t%d\n",
+				 object_table[i].instances);
+			dev_info(&client->dev, "\tReport Id's:\t%d\n",
+				 object_table[i].num_report_ids);
+		}
+	}
+
+	return 0;
+
+err_max_rid:
+	kfree(mxt->last_message);
+err_msg_alloc:
+	kfree(mxt->rid_map);
+err_rid_map_alloc:
+err_object_read:
+	kfree(raw_ib_data);
+err_ib_alloc:
+	kfree(object_table);
+err_object_table_alloc:
+	return error;
+}
+
+//#define TS_PEN_IRQ_GPIO RK29_PIN0_PA2//61
+
+static int Gpio_TS_request_irq(struct mxt_data *mxt)
+{
+	int rc;
+    struct i2c_client *client = mxt->client;
+
+	MXT1386_LOG(KERN_INFO "Gpio_TS_request_irq enter!\n", __func__);	
+	MXT1386_LOG(KERN_INFO "%s: times 1 ts_irq value is %d\n", __func__, ts_irq);
+
+	if (gpio_get_value(client->irq)) {
+        MXT1386_LOG(KERN_INFO "%s: mxt1386 GPIO value is high\n", __func__);
+    }
+	else {
+		MXT1386_LOG(KERN_INFO "%s: mxt1386 GPIO value is low\n", __func__);
+	}
+
+	MXT1386_LOG(KERN_INFO "%s: times 2 ts_irq value is %d\n", __func__, ts_irq);
+	rc = request_irq(mxt->irq, mxt_irq_handler,
+				IRQF_TRIGGER_LOW,//IRQF_TRIGGER_FALLING,  //
+				"mxc_ts_i2c", mxt);
+	if (rc) {
+		pr_err("could not request irq\n");
+		goto error_req_irq_fail;
+	}
+
+	MXT1386_LOG(KERN_INFO "Gpio_TS_request_irq ok!\n", __func__);
+	return 0;
+
+error_req_irq_fail:
+error_irq_gpio_dir:
+	gpio_free(client->irq);
+error_irq_gpio_req:
+	if (client->irq >= 0)
+		gpio_free(client->irq);
+	return rc;
+}
+
+static int mxt1386_platform_data_init(struct atmel_1386_platform_data *pdata)
+{
+	MXT1386_LOG(KERN_INFO "%s: mxt1386_platform_data_init enter!\n", __func__);
+
+	pdata->max_x = CONFIG_ATMEL_MXT1386_MAX_X;
+	pdata->max_y = CONFIG_ATMEL_MXT1386_MAX_Y;
+
+	return 0;
+}
+
+static int __devinit mxt_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	struct atmel_1386_platform_data *pdata = (struct atmel_1386_platform_data *)client->dev.platform_data;
+	struct mxt_data          *mxt;
+	struct input_dev         *input;
+	u8 *id_data;
+	int error;
+	u8 buf[MXT_ACK_BUFFER_SIZE] = {0};
+	u8 buf_size = MXT_MAKE_HIGH_CHG_SIZE_MIN;
+    int index;
+    
+	MXT1386_LOG(" ---------------- mxt_probe start ------------ \n");
+	MXT1386_LOG(KERN_INFO "%s: mxt_probe enter, debug level is = %d\n", __func__, debug);
+
+	if (client == NULL) {
+		MXT1386_LOG("maXTouch: client == NULL\n");
+		return	-EINVAL;
+	} else if (client->adapter == NULL) {
+		MXT1386_LOG("maXTouch: client->adapter == NULL\n");
+		return	-EINVAL;
+	} else if (&client->dev == NULL) {
+		MXT1386_LOG("maXTouch: client->dev == NULL\n");
+		return	-EINVAL;
+	} else if (&client->adapter->dev == NULL) {
+		MXT1386_LOG("maXTouch: client->adapter->dev == NULL\n");
+		return	-EINVAL;
+	} else if (id == NULL) {
+		MXT1386_LOG("maXTouch: id == NULL\n");
+		return	-EINVAL;
+	}
+
+	mxt1386_platform_data_init(pdata);
+
+	MXT1386_LOG(KERN_INFO "%s: maXTouch driver v. %s\n", __func__, DRIVER_VERSION);
+	MXT1386_LOG(KERN_INFO "%s: \t \"%s\"\n", __func__, client->name);
+	MXT1386_LOG(KERN_INFO "%s: \taddr:\t0x%04x\n", __func__, client->addr);
+	MXT1386_LOG(KERN_INFO "%s: \tirq:\t%d\n", __func__, client->irq);
+	MXT1386_LOG(KERN_INFO "%s: \tflags:\t0x%04x\n", __func__, client->flags);
+	MXT1386_LOG(KERN_INFO "%s: \tadapter:\"%s\"\n", __func__, client->adapter->name);
+	MXT1386_LOG(KERN_INFO "%s: \tdevice:\t\"%s\"\n", __func__, client->dev.init_name);
+
+	if (!pdata) {
+		MXT1386_LOG("TS i2c_probe no platform data\n");
+	}
+	else {
+		MXT1386_LOG("TS i2c_probe platform data OK\n");
+	}
+
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {
+		MXT1386_LOG("TS i2c_probe I2C_FUNC_I2C Failed\n");
+	}
+	else {
+		MXT1386_LOG("TS i2c_probe I2C_FUNC_I2C OK\n");
+	}
+	
+	if (pdata->init_platform_hw != NULL) {
+		error = pdata->init_platform_hw(&(client->dev));
+		if (error < 0) {
+			MXT1386_LOG("TS i2c_probe power on Failed\n");
+			return error;
+		}
+		else {
+			MXT1386_LOG("TS i2c_probe power on OK\n");
+		}
+	}
+	else {			/* ---------------- add by acgzx test ---------------- */
+		MXT1386_LOG("TS init_platform_hw is NULL\n");
+	}		
+
+	/* Allocate structure - we need it to identify device */
+	mxt = kzalloc(sizeof(struct mxt_data), GFP_KERNEL);
+	if (mxt == NULL) {
+		dev_err(&client->dev, "insufficient memory\n");
+		error = -ENOMEM;
+		goto err_mxt_alloc;
+	}
+
+	id_data = kmalloc(MXT_ID_BLOCK_SIZE, GFP_KERNEL);
+	if (id_data == NULL) {
+		dev_err(&client->dev, "insufficient memory\n");
+		error = -ENOMEM;
+		goto err_id_alloc;
+	}
+
+	input = input_allocate_device();
+	if (!input) {
+		dev_err(&client->dev, "error allocating input device\n");
+		error = -ENOMEM;
+		goto err_input_dev_alloc;
+	}
+
+	atmel_mxt = mxt;
+
+	mxt->read_fail_counter = 0;
+	mxt->message_counter   = 0;
+	mxt->max_x_val         = pdata->max_x;
+	mxt->max_y_val         = pdata->max_y;
+
+	/* Get data that is defined in board specific code. */
+	mxt->init_hw = pdata->init_platform_hw;
+	mxt->exit_hw = pdata->exit_platform_hw;
+	mxt->read_chg = pdata->read_chg;
+
+	if (pdata->valid_interrupt != NULL)
+		mxt->valid_interrupt = pdata->valid_interrupt;
+	else
+	{
+		mxt->valid_interrupt = mxt_valid_interrupt_dummy;
+		MXT1386_LOG("TS valid_interrupt is dummy\n");		/* ---------------- add by acgzx test ---------------- */
+	}		
+
+	if (debug >= DEBUG_TRACE)
+		MXT1386_LOG("maXTouch driver identifying chip\n");
+
+	if (mxt_identify(client, mxt, id_data) < 0) {
+		dev_err(&client->dev, "Chip could not be identified\n");
+		error = -ENODEV;
+		goto err_identify;
+	}
+	/* Chip is valid and active. */
+	if (debug >= DEBUG_TRACE)
+		MXT1386_LOG("maXTouch driver allocating input device\n");
+
+	mxt->client = client;
+	mxt->input  = input;
+
+	mutex_init(&mxt->debug_mutex);
+	mutex_init(&mxt->msg_mutex);
+	MXT1386_LOG("maXTouch driver creating device name\n");
+
+	snprintf(
+		mxt->phys_name,
+		sizeof(mxt->phys_name),
+		"%s/input0",
+		dev_name(&client->dev)
+	);
+	input->name = "mxc_ts_i2c";	// "Atmel maXTouch Touchscreen controller";
+	input->phys = mxt->phys_name;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+
+	MXT1386_LOG("maXTouch name: \"%s\"\n", input->name);
+	MXT1386_LOG("maXTouch phys: \"%s\"\n", input->phys);
+	MXT1386_LOG("maXTouch driver setting abs parameters\n");
+
+	MXT1386_LOG(KERN_INFO "%s: mxt->max_x_val = %d\n", __func__, mxt->max_x_val);
+	MXT1386_LOG(KERN_INFO "%s: mxt->max_y_val = %d\n", __func__, mxt->max_y_val);
+	
+	/* Single touch */
+	input_set_abs_params(input, ABS_X, 0, mxt->max_x_val, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, mxt->max_y_val, 0, 0);
+	input_set_abs_params(input, ABS_PRESSURE, 0, MXT_MAX_REPORTED_PRESSURE,
+			     0, 0);
+	input_set_abs_params(input, ABS_TOOL_WIDTH, 0, MXT_MAX_REPORTED_WIDTH,
+			     0, 0);
+
+	/* Multitouch */
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, mxt->max_x_val, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, mxt->max_y_val, 0, 0);
+	input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, MXT_MAX_TOUCH_SIZE,
+			     0, 0);
+	input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, MXT_MAX_NUM_TOUCHES,
+			     0, 0);
+	
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(EV_SYN, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_MSC, input->evbit);
+
+#if TOUCH_KEY_EN
+	__set_bit(KEY_SEARCH, input->keybit);
+	__set_bit(KEY_HOME, input->keybit);
+	__set_bit(KEY_MENU, input->keybit);
+	__set_bit(KEY_BACK, input->keybit);
+#endif
+
+	input->mscbit[0] = BIT_MASK(MSC_GESTURE);
+
+	MXT1386_LOG("maXTouch driver setting client data\n");
+	i2c_set_clientdata(client, mxt);
+	MXT1386_LOG("maXTouch driver setting drv data\n");
+	input_set_drvdata(input, mxt);
+	MXT1386_LOG("maXTouch driver input register device\n");
+	error = input_register_device(mxt->input);
+	if (error < 0) {
+		dev_err(&client->dev,
+			"Failed to register input device\n");
+		goto err_register_device;
+	}
+
+	error = mxt_read_object_table(client, mxt, id_data);
+	if (error < 0)
+		goto err_read_ot;
+
+	/* Create debugfs entries. */
+	mxt->debug_dir = debugfs_create_dir("maXTouch", NULL);
+	if (mxt->debug_dir == ERR_PTR(-ENODEV)){
+		/* debugfs is not enabled. */
+		MXT1386_LOG("debugfs not enabled in kernel\n");
+	} else if (mxt->debug_dir == NULL) {
+		MXT1386_LOG("error creating debugfs dir\n");
+	} else {
+		MXT1386_LOG("created \"maXTouch\" debugfs dir\n");
+		
+		debugfs_create_file("deltas", S_IRUSR, mxt->debug_dir, mxt, 
+				    &delta_fops);
+		debugfs_create_file("refs", S_IRUSR, mxt->debug_dir, mxt,
+				    &refs_fops);
+	}
+
+    /* Create character device nodes for reading & writing registers */
+	mxt->mxt_class = class_create(THIS_MODULE, "maXTouch_memory");
+	/* 2 numbers; one for memory and one for messages */
+	error = alloc_chrdev_region(&mxt->dev_num, 0, 2, 
+				    "maXTouch_memory");
+	MXT1386_LOG("device number %d allocated!\n", MAJOR(mxt->dev_num));
+	if (error){
+		MXT1386_LOG("Error registering device\n");
+	}
+	cdev_init(&mxt->cdev, &mxt_memory_fops);
+	cdev_init(&mxt->cdev_messages, &mxt_message_fops);
+	
+	MXT1386_LOG("cdev initialized\n");
+	mxt->cdev.owner = THIS_MODULE;
+	mxt->cdev_messages.owner = THIS_MODULE;
+	
+	error = cdev_add(&mxt->cdev, mxt->dev_num, 1);
+	if (error){
+		MXT1386_LOG("Bad cdev\n");
+	}
+	
+	error = cdev_add(&mxt->cdev_messages, mxt->dev_num + 1, 1);
+	if (error){
+		MXT1386_LOG("Bad cdev\n");
+	}
+	
+	MXT1386_LOG("cdev added\n");
+	
+	device_create(mxt->mxt_class, NULL, MKDEV(MAJOR(mxt->dev_num), 0), NULL,
+		"maXTouch");
+
+	device_create(mxt->mxt_class, NULL, MKDEV(MAJOR(mxt->dev_num), 1), NULL,
+		"maXTouch_messages");
+
+	mxt->msg_buffer_startp = 0;
+	mxt->msg_buffer_endp = 0;
+
+	/* Allocate the interrupt */
+	MXT1386_LOG("maXTouch driver allocating interrupt...\n");
+	mxt->irq = gpio_to_irq(client->irq);
+    ts_irq = mxt->irq;
+	mxt->valid_irq_counter = 0;
+	mxt->invalid_irq_counter = 0;
+	mxt->irq_counter = 0;
+
+//WRITE_MT_CONFIG
+
+#if WORKQ_RIGHTNOW
+	MXT1386_LOG(KERN_INFO "%s: INIT_WORK set\n", __func__);
+	mxt->queue = create_singlethread_workqueue("mxc_ts_handler"); /**/
+	INIT_WORK(&mxt->work, ts_thread_1386);	
+#else
+	MXT1386_LOG(KERN_INFO "%s: INIT_DELAYED_WORK set\n", __func__);
+	mxt->queue = create_rt_workqueue("mxc_ts_handler");		/**/
+	INIT_DELAYED_WORK(&mxt->dwork, ts_thread_1386);
+#endif
+
+/*--------------------------------------------------------------------------------*/
+	/* Now the chip pull the irq pin to down waiting the host ack */
+	if(gpio_get_value(client->irq)) {
+		MXT1386_LOG(KERN_INFO "%s: TOUCH_INT_PIN test, value is high, error\n", __func__);
+		goto err_irq;
+	}
+	else {
+		MXT1386_LOG(KERN_INFO "%s: TOUCH_INT_PIN test, value is low, need host ack\n", __func__);
+	}
+
+	/* TP MCU INTT510bytes()MCUINT acgzx 2011.03.30 */
+	/* Read dummy message to make high CHG pin (Make CHG line high after the interrupts are enabled) */
+	error = mxt_read_block(client, mxt->msg_proc_addr, buf_size, (u8 *)buf);	/* ---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!--- */
+	if (error < 0) {
+		MXT1386_LOG(KERN_INFO "%s: host first ack msg err!\n", __func__);
+	}
+	else {
+		MXT1386_LOG(KERN_INFO "%s: host first ack msg ok!\n", __func__);
+	}
+	mxt_buf_test(buf, buf_size);
+    msleep(20);
+	
+	if(gpio_get_value(client->irq)) {
+        MXT1386_LOG(KERN_INFO "%s: TOUCH_INT_PIN test, value is high, host acked chip successively\n", __func__);
+    }
+	else {
+		MXT1386_LOG(KERN_INFO "%s: TOUCH_INT_PIN test, value is low, host acked chip fail\n", __func__);
+		goto err_irq;
+	}
+/*--------------------------------------------------------------------------------*/
+    atmel_1386_write_config(mxt);
+
+	error = Gpio_TS_request_irq(mxt);
+	if (error != 0) {
+		MXT1386_LOG("TS i2c_probe request irq failed\n");
+	       goto err_irq;
+	}
+	else {
+		MXT1386_LOG("TS i2c_probe request irq ok\n");
+	}
+
+#ifdef CONFIG_PM
+		device_init_wakeup(&client->dev, 0);
+#endif
+
+    if (debug > DEBUG_INFO)
+		dev_info(&client->dev, "touchscreen, irq %d\n", mxt->irq);
+		
+	kfree(id_data);
+	
+	MXT1386_LOG(KERN_INFO "%s: mxt_probe init ok\n", __func__);
+	MXT1386_LOG(" ---------------- mxt_probe end ------------ \n");
+	return 0;
+
+err_irq:
+	kfree(mxt->rid_map);
+	kfree(mxt->object_table);
+	kfree(mxt->last_message);
+err_read_ot:
+err_register_device:
+err_identify:
+err_input_dev_alloc:
+	kfree(id_data);
+err_id_alloc:
+	if (mxt->exit_hw != NULL)
+		mxt->exit_hw(&(client->dev));
+	kfree(mxt);
+err_mxt_alloc:
+	return error;
+}
+
+static int __devexit mxt_remove(struct i2c_client *client)
+{
+	struct mxt_data *mxt;
+
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_remove enter now -----------\n", __func__);
+
+	mxt = i2c_get_clientdata(client);
+
+	/* Remove debug dir entries */
+	debugfs_remove_recursive(mxt->debug_dir);
+
+	if (mxt != NULL) {
+		
+		if (mxt->exit_hw != NULL)
+			mxt->exit_hw(&(client->dev));
+
+		if (mxt->irq) {
+			free_irq(mxt->irq, mxt);
+		}
+
+#if (!WORKQ_RIGHTNOW)
+		if (cancel_delayed_work_sync(&mxt->dwork)) {
+		/*
+		 * Work was pending, therefore we need to enable
+		 * IRQ here to balance the disable_irq() done in the
+		 * interrupt handler.
+		 */
+		 	MXT1386_LOG(KERN_INFO "%s: cancel_delayed_work_sync set\n", __func__);
+			enable_irq(mxt->irq);
+		}
+#endif
+
+		unregister_chrdev_region(mxt->dev_num, 2);
+		device_destroy(mxt->mxt_class, MKDEV(MAJOR(mxt->dev_num), 0));
+		device_destroy(mxt->mxt_class, MKDEV(MAJOR(mxt->dev_num), 1));
+		cdev_del(&mxt->cdev);
+		cdev_del(&mxt->cdev_messages);
+		cancel_delayed_work_sync(&mxt->dwork);
+		input_unregister_device(mxt->input);
+		class_destroy(mxt->mxt_class);
+		debugfs_remove(mxt->debug_dir);
+
+		kfree(mxt->rid_map);
+		kfree(mxt->object_table);
+		kfree(mxt->last_message);
+	}
+	kfree(mxt);
+
+	i2c_set_clientdata(client, NULL);
+	if (debug >= DEBUG_TRACE)
+		dev_info(&client->dev, "Touchscreen unregistered\n");
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+static int mxt_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct mxt_data *mxt = i2c_get_clientdata(client);
+
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_suspend enter now -----------\n", __func__);
+
+#if 1
+	if (device_may_wakeup(&client->dev)) {
+		MXT1386_LOG(KERN_INFO "%s: mxt_suspend ok\n", __func__);
+		enable_irq_wake(mxt->irq);
+	} else {
+		MXT1386_LOG(KERN_INFO "%s: mxt_suspend failed\n", __func__);
+	}
+#else
+	disable_irq(mxt->irq);
+	cancel_work_sync(&mxt->work);
+	
+	if (device_may_wakeup(&client->dev)) {
+		printk(KERN_INFO "%s: mxt_suspend ok\n", __func__);
+		enable_irq_wake(mxt->irq);
+	} else {
+		printk(KERN_INFO "%s: mxt_suspend failed\n", __func__);
+	}
+#endif
+
+	return 0;
+}
+
+static int mxt_wakeup_controller(int gpio)
+{
+	int ret=0, i;
+
+	gpio_free(gpio);
+
+	if((ret = gpio_request(gpio, "mxc_irq_gpio"))!=0) {
+		MXT1386_LOG(KERN_INFO "Failed to request GPIO for mxc_irq_gpio. Err:%d\n", ret);
+		ret = -EFAULT;
+	} else	{
+		gpio_direction_output(gpio, 0);
+		
+		for(i=0; i<100; i++);
+			gpio_direction_input(gpio);
+		MXT1386_LOG(KERN_INFO "INT wakeup touch controller done\n");
+	}
+	
+	return ret;
+}
+
+
+static int mxt_resume(struct i2c_client *client)
+{
+	struct mxt_data *mxt = i2c_get_clientdata(client);
+
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_resume enter now ----------- \n", __func__);
+
+#if 1
+	if (device_may_wakeup(&client->dev)) {
+		MXT1386_LOG(KERN_INFO "%s: mxt_resume ok\n", __func__);
+		disable_irq_wake(mxt->irq);
+	} else {
+		MXT1386_LOG(KERN_INFO "%s: mxt_resume failed\n", __func__);
+	}
+#else
+	if (device_may_wakeup(&client->dev)) {
+		printk(KERN_INFO "%s: mxt_resume ok\n", __func__);
+		disable_irq_wake(mxt->irq);
+	} else {
+		printk(KERN_INFO "%s: mxt_resume failed\n", __func__);
+	}
+	mxt_wakeup_controller(irq_to_gpio(mxt->irq));
+	enable_irq(mxt->irq);
+#endif
+
+	return 0;
+}
+#else
+#define mxt_suspend NULL
+#define mxt_resume NULL
+#endif
+
+static const struct i2c_device_id mxt_idtable[] = {
+	{"mxc_ts_i2c", 0,},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, mxt_idtable);
+
+static struct i2c_driver mxt_driver = {
+	.driver = {
+		.name	= "mxc_ts_i2c",
+		.owner  = THIS_MODULE,
+	},
+
+	.id_table	= mxt_idtable,
+	.probe		= mxt_probe,
+	.remove		= __devexit_p(mxt_remove),
+	.suspend	= mxt_suspend,
+	.resume		= mxt_resume,
+
+};
+
+#if 0
+static void __init mxt_init_async(void *unused, async_cookie_t cookie)
+{
+	int err;
+	
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_init_async enter now ----------- \n", __func__);
+
+	err = i2c_add_driver(&mxt_driver);
+	if (err) {
+		MXT1386_LOG("Adding maXTouch driver failed "
+		       "(errno = %d)\n", err);
+	} else {
+		MXT1386_LOG(KERN_INFO "Successfully added driver %s\n", __func__,
+		          mxt_driver.driver.name);
+	}
+}
+static int __init mxt_init(void)
+{
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_init enter now ----------- \n", __func__);
+	
+	async_schedule(mxt_init_async, NULL);
+	return 0;
+}
+#else
+static int __init mxt_init(void)
+{
+	int err;
+
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_init enter now ----------- \n", __func__);
+	
+	err = i2c_add_driver(&mxt_driver);
+	if (err) {
+		MXT1386_LOG("Adding maXTouch driver failed "
+		       "(errno = %d)\n", err);
+	} else {
+		MXT1386_LOG(KERN_INFO "Successfully added driver %s\n", __func__,
+		          mxt_driver.driver.name);
+	}
+
+	MXT1386_LOG(KERN_INFO "Adding maXTouch driver  \n");
+	
+	return err;
+}
+#endif
+
+static void __exit mxt_cleanup(void)
+{
+	MXT1386_LOG(KERN_INFO "%s: ----------- mxt_cleanup enter now ----------- \n", __func__);
+	i2c_del_driver(&mxt_driver);
+}
+
+module_init(mxt_init);
+module_exit(mxt_cleanup);
+
+MODULE_AUTHOR("Iiro Valkonen");
+MODULE_DESCRIPTION("Driver for Atmel maXTouch Touchscreen Controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/atmel_mxt1386.h b/drivers/input/touchscreen/atmel_mxt1386.h
new file mode 100644
index 000000000000..251fb9ebdea2
--- /dev/null
+++ b/drivers/input/touchscreen/atmel_mxt1386.h
@@ -0,0 +1,295 @@
+/*
+ *  Atmel maXTouch header file
+ *  
+ *  Copyright (c) 2010 Atmel Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 or 3 as
+ *  published by the Free Software Foundation.
+ *  See the file "COPYING" in the main directory of this archive
+ *  for more details.
+ *
+ */
+  #include <linux/device.h>
+
+
+#define	MXT224_I2C_ADDR1				0x4A
+#define	MXT224_I2C_ADDR2				0x4B
+#define	MXT1386_I2C_ADDR1				0x4C
+#define	MXT1386_I2C_ADDR2				0x4D
+#define	MXT1386_I2C_ADDR3				0x5A
+#define	MXT1386_I2C_ADDR4				0x5B
+
+/*
+ * Select this address from above depending on what maXTouch
+ * chip you have and how it's address pins are configured;
+ * see datasheet.
+ */
+
+#define MXT_I2C_ADDRESS                                 MXT1386_I2C_ADDR1
+
+#define MXT_BL_ADDRESS                                  0x25
+
+#define	MXT224_FAMILYID				        0x80
+#define MXT1386_FAMILYID                                0xA0
+
+#define	MXT224_CAL_VARIANTID				0x01
+#define MXT224_UNCAL_VARIANTID                          0x00
+#define MXT1386_CAL_VARIANTID                           0x00
+
+#define MXT_MAX_REPORTED_WIDTH                          255
+#define MXT_MAX_REPORTED_PRESSURE                       255
+#define MXT_MAX_TOUCH_SIZE                              255
+#define MXT_MAX_NUM_TOUCHES                             10
+
+/* Fixed addresses inside maXTouch device */
+#define	MXT_ADDR_INFO_BLOCK				0
+#define	MXT_ADDR_OBJECT_TABLE				7
+#define MXT_ID_BLOCK_SIZE                               7
+#define	MXT_OBJECT_TABLE_ELEMENT_SIZE			6
+
+/* Object types */
+#define	MXT_DEBUG_DELTAS_T2				2
+#define	MXT_DEBUG_REFERENCES_T3				3
+#define	MXT_GEN_MESSAGEPROCESSOR_T5			5
+#define	MXT_GEN_COMMANDPROCESSOR_T6			6
+#define	MXT_GEN_POWERCONFIG_T7				7
+#define	MXT_GEN_ACQUIRECONFIG_T8			8
+#define	MXT_TOUCH_MULTITOUCHSCREEN_T9			9
+#define MXT_TOUCH_SINGLETOUCHSCREEN_T10                 10
+#define MXT_TOUCH_XSLIDER_T11                           11
+#define MXT_TOUCH_YSLIDER_T12                           12
+#define MXT_TOUCH_XWHEEL_T13                            13
+#define MXT_TOUCH_YWHEEL_T14                            14
+#define	MXT_TOUCH_KEYARRAY_T15				15
+#define	MXT_SPT_COMMSCONFIG_T18				18
+#define	MXT_SPT_GPIOPWM_T19				19
+#define	MXT_PROCI_GRIPFACESUPPRESSION_T20		20
+#define	MXT_PROCG_NOISESUPPRESSION_T22			22
+#define	MXT_TOUCH_PROXIMITY_T23				23
+#define	MXT_PROCI_ONETOUCHGESTUREPROCESSOR_T24		24
+#define	MXT_SPT_SELFTEST_T25				25
+#define MXT_DEBUG_CTERANGE_T26				26
+#define	MXT_PROCI_TWOTOUCHGESTUREPROCESSOR_T27		27
+#define	MXT_SPT_CTECONFIG_T28				28
+#define	MXT_TOUCH_KEYSET_T31				31
+#define	MXT_TOUCH_XSLIDERSET_T32			32
+#define	MXT_DEBUG_DIAGNOSTIC_T37			37
+#define	MXT_USER_INFO_T38				38
+#define	MXT_PROCI_GRIPSUPPRESSION_T40			40
+#define	MXT_PROCI_PALMSUPPRESSION_T41			41
+#define	MXT_SPT_DIGITIZER_T43				43
+
+
+
+/*
+ * If a message is read from mXT when there's no new messages available,
+ * the report ID of the message will be 0xFF.
+ */
+#define	MXT_END_OF_MESSAGES				0xFF
+
+
+/* GEN_COMMANDPROCESSOR_T6 Register offsets from T6 base address */
+#define	MXT_ADR_T6_RESET				0x00
+#define	MXT_ADR_T6_BACKUPNV				0x01
+#define	MXT_ADR_T6_CALIBRATE				0x02
+#define	MXT_ADR_T6_REPORTALL				0x03
+#define	MXT_ADR_T6_RESERVED				0x04
+#define	MXT_ADR_T6_DIAGNOSTIC				0x05
+
+/* T6 Debug Diagnostics Commands */
+#define	MXT_CMD_T6_PAGE_UP          0x01
+#define	MXT_CMD_T6_PAGE_DOWN        0x02
+#define	MXT_CMD_T6_DELTAS_MODE      0x10
+#define	MXT_CMD_T6_REFERENCES_MODE  0x11
+#define	MXT_CMD_T6_CTE_MODE         0x31
+
+/* T6 Backup Command */
+#define MXT_CMD_T6_BACKUP           0x55
+
+/* SPT_DEBUG_DIAGNOSTIC_T37 Register offsets from T37 base address */
+#define MXT_ADR_T37_PAGE                                0x01
+#define	MXT_ADR_T37_DATA				0x02
+
+
+
+/************************************************************************
+ * MESSAGE OBJECTS ADDRESS FIELDS
+ *
+ ************************************************************************/
+#define MXT_MSG_REPORTID                                0x00
+
+
+/* MXT_GEN_MESSAGEPROCESSOR_T5 Message address definitions		*/
+#define	MXT_MSG_T5_REPORTID				0x00
+#define	MXT_MSG_T5_MESSAGE				0x01
+#define	MXT_MSG_T5_CHECKSUM				0x08
+
+/* MXT_GEN_COMMANDPROCESSOR_T6 Message address definitions		*/
+#define	MXT_MSG_T6_STATUS				0x01
+#define		MXT_MSGB_T6_COMSERR		0x04
+#define		MXT_MSGB_T6_CFGERR		0x08
+#define		MXT_MSGB_T6_CAL			0x10
+#define		MXT_MSGB_T6_SIGERR		0x20
+#define		MXT_MSGB_T6_OFL			0x40
+#define		MXT_MSGB_T6_RESET		0x80
+/* Three bytes */
+#define	MXT_MSG_T6_CHECKSUM				0x02
+
+/* MXT_GEN_POWERCONFIG_T7 NO Message address definitions		*/
+/* MXT_GEN_ACQUIRECONFIG_T8 Message address definitions			*/
+/* MXT_TOUCH_MULTITOUCHSCREEN_T9 Message address definitions		*/
+
+#define	MXT_MSG_T9_STATUS				0x01
+/* Status bit field */
+#define		MXT_MSGB_T9_SUPPRESS		0x02
+#define		MXT_MSGB_T9_AMP			0x04
+#define		MXT_MSGB_T9_VECTOR		0x08
+#define		MXT_MSGB_T9_MOVE		0x10
+#define		MXT_MSGB_T9_RELEASE		0x20
+#define		MXT_MSGB_T9_PRESS		0x40
+#define		MXT_MSGB_T9_DETECT		0x80
+
+#define	MXT_MSG_T9_XPOSMSB				0x02
+#define	MXT_MSG_T9_YPOSMSB				0x03
+#define	MXT_MSG_T9_XYPOSLSB				0x04
+#define	MXT_MSG_T9_TCHAREA				0x05
+#define	MXT_MSG_T9_TCHAMPLITUDE				0x06
+#define	MXT_MSG_T9_TCHVECTOR				0x07
+
+
+/* MXT_SPT_GPIOPWM_T19 Message address definitions			*/
+#define	MXT_MSG_T19_STATUS				0x01
+
+/* MXT_PROCI_GRIPFACESUPPRESSION_T20 Message address definitions	*/
+#define	MXT_MSG_T20_STATUS				0x01
+#define		MXT_MSGB_T20_FACE_SUPPRESS	0x01
+/* MXT_PROCG_NOISESUPPRESSION_T22 Message address definitions		*/
+#define	MXT_MSG_T22_STATUS				0x01
+#define		MXT_MSGB_T22_FHCHG		0x01
+#define		MXT_MSGB_T22_GCAFERR		0x04
+#define		MXT_MSGB_T22_FHERR		0x08
+#define	MXT_MSG_T22_GCAFDEPTH				0x02
+
+/* MXT_TOUCH_PROXIMITY_T23 Message address definitions			*/
+#define	MXT_MSG_T23_STATUS				0x01
+#define		MXT_MSGB_T23_FALL		0x20
+#define		MXT_MSGB_T23_RISE		0x40
+#define		MXT_MSGB_T23_DETECT		0x80
+/* 16 bit */
+#define	MXT_MSG_T23_PROXDELTA				0x02
+
+/* MXT_PROCI_ONETOUCHGESTUREPROCESSOR_T24 Message address definitions	*/
+#define	MXT_MSG_T24_STATUS				0x01
+#define	MXT_MSG_T24_XPOSMSB				0x02
+#define	MXT_MSG_T24_YPOSMSB				0x03
+#define	MXT_MSG_T24_XYPOSLSB				0x04
+#define	MXT_MSG_T24_DIR					0x05
+/* 16 bit */
+#define	MXT_MSG_T24_DIST				0x06
+
+/* MXT_SPT_SELFTEST_T25 Message address definitions			*/
+#define	MXT_MSG_T25_STATUS				0x01
+/* 5 Bytes */
+#define		MXT_MSGR_T25_OK			0xFE
+#define		MXT_MSGR_T25_INVALID_TEST	0xFD
+#define		MXT_MSGR_T25_PIN_FAULT		0x11
+#define		MXT_MSGR_T25_SIGNAL_LIMIT_FAULT	0x17
+#define		MXT_MSGR_T25_GAIN_ERROR		0x20
+#define	MXT_MSG_T25_INFO				0x02
+
+/* MXT_PROCI_TWOTOUCHGESTUREPROCESSOR_T27 Message address definitions	*/
+#define	MXT_MSG_T27_STATUS			0x01
+#define		MXT_MSGB_T27_ROTATEDIR		0x10
+#define		MXT_MSGB_T27_PINCH		0x20
+#define		MXT_MSGB_T27_ROTATE		0x40
+#define		MXT_MSGB_T27_STRETCH		0x80
+#define	MXT_MSG_T27_XPOSMSB			0x02
+#define	MXT_MSG_T27_YPOSMSB			0x03
+#define	MXT_MSG_T27_XYPOSLSB			0x04
+#define	MXT_MSG_T27_ANGLE			0x05
+
+/* 16 bit */
+#define	MXT_MSG_T27_SEPARATION				0x06
+
+/* MXT_SPT_CTECONFIG_T28 Message address definitions			*/
+#define	MXT_MSG_T28_STATUS				0x01
+#define	MXT_MSGB_T28_CHKERR		0x01
+
+/* One Touch Events */
+#define	MXT_GESTURE_RESERVED		0x00
+#define	MXT_GESTURE_PRESS		0x01
+#define	MXT_GESTURE_RELEASE		0x02
+#define	MXT_GESTURE_TAP			0x03
+#define	MXT_GESTURE_DOUBLE_TAP		0x04
+#define	MXT_GESTURE_FLICK		0x05
+#define	MXT_GESTURE_DRAG		0x06
+#define	MXT_GESTURE_SHORT_PRESS		0x07
+#define	MXT_GESTURE_LONG_PRESS		0x08
+#define	MXT_GESTURE_REPEAT_PRESS	0x09
+#define	MXT_GESTURE_TAP_AND_PRESS	0x0a
+#define	MXT_GESTURE_THROW		0x0b
+
+/* Two-touch events */
+#define MXT_GESTURE_STRETCH             (1 << 7)
+#define MXT_GESTURE_ROTATE              (1 << 6)
+#define MXT_GESTURE_PINCH               (1 << 5)
+#define MXT_GESTURE_ROTATEDIR           (1 << 4)
+
+/* Bootloader states */
+#define WAITING_BOOTLOAD_COMMAND   0xC0
+#define WAITING_FRAME_DATA         0x80
+#define APP_CRC_FAIL               0x40
+#define FRAME_CRC_CHECK            0x02
+#define FRAME_CRC_PASS             0x04
+#define FRAME_CRC_FAIL             0x03
+
+#define MXT_MAX_FRAME_SIZE         276
+
+/* Debug levels */
+#define DEBUG_INFO     1
+#define DEBUG_VERBOSE  2
+#define DEBUG_MESSAGES 5
+#define DEBUG_RAW      8
+#define DEBUG_TRACE   10
+
+/* IOCTL commands */
+/* TODO: get correct numbers! */
+#define MXT_SET_ADDRESS_IOCTL ('x' + 1)  /* Sets the internal address pointer */
+#define MXT_RESET_IOCTL       ('x' + 2)  /* Resets the device */
+#define MXT_CALIBRATE_IOCTL   ('x' + 3)  /* Calibrates the device */
+#define MXT_BACKUP_IOCTL      ('x' + 4)  /* Backups the current state of registers to 
+				  NVM */
+#define MXT_NONTOUCH_MSG_IOCTL ('x' + 5)  /* Only non-touch messages can be read from
+                                  the message buffer (/dev/maXTouch_messages)*/
+#define MXT_ALL_MSG_IOCTL ('x' + 6)  /* All messages can be read from the message
+                                  buffer */
+
+/* Message buffer size. This is a ring buffer, and when full, the oldest entry
+   will be overwritten. */
+#define MXT_MESSAGE_BUFFER_SIZE  128
+
+/*-------------- following added by acgzx 2011.03.30 --------------*/
+
+/* Read dummy message to make high CHG pin of minimumvalue */
+#define MXT_MAKE_HIGH_CHG_SIZE_MIN	10
+#define MXT_ACK_BUFFER_SIZE		16
+
+
+/**
+ * struct mxt_platform_data - includes platform specific informatio
+ * related to Atmel maXTouch touchscreen controller.
+ * 
+ * @numtouch:           Number of simultaneous touches supported
+ * @init_platform_hw(): Initialization function, which can for example
+ *                      trigger a hardware reset by toggling a GPIO pin
+ * @exit_platform_hw(): Function to run when the driver is unloaded.
+ * @valid_interrupt():  Function that checks the validity of the interrupt -
+ *                      function that check the validity of a interrupt (by
+ *                      reading the changeline interrupt pin and checking that
+ *                      it really is low for example).
+ * @max_x:              Reported X range
+ * @max_y:              Reported Y range
+ */
+ 
+
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index 7a6066c90722..78a8b34365ed 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -58,6 +58,8 @@ config LCD_AT070TNA2
 	bool "RGB AT070TNA2"
 config LCD_AT070TN93
 	bool "RGB AT070TN93"
+config LCD_TX23D88VM
+	bool "HITACHI LVDS TX23D88VM (1200x800)"
 endchoice
 
 
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index edcac9d998bc..79b670c71d4e 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -29,4 +29,5 @@ obj-$(CONFIG_LCD_LS035Y8DX02A) += lcd_ls035y8dx02a.o
 obj-$(CONFIG_LCD_IPS1P5680_V1_E) += lcd_ips1p5680_v1_e.o
 obj-$(CONFIG_LCD_MCU_TFT480800_25_E) += lcd_mcu_tft480800_25_e.o
 obj-$(CONFIG_LCD_AT070TNA2)    += lcd_AT070TNA2.o
+obj-$(CONFIG_LCD_TX23D88VM) += lcd_tx23d88vm.o
 obj-$(CONFIG_LCD_AT070TN93)    += lcd_at070tn93.o
\ No newline at end of file
diff --git a/drivers/video/display/screen/lcd_tx23d88vm.c b/drivers/video/display/screen/lcd_tx23d88vm.c
new file mode 100644
index 000000000000..02486898609e
--- /dev/null
+++ b/drivers/video/display/screen/lcd_tx23d88vm.c
@@ -0,0 +1,78 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+
+//#define OUT_FACE		OUT_D888_P666
+#define OUT_FACE		OUT_P888//modify by xhh
+
+
+#define OUT_CLK			 66000000//64000000
+#define LCDC_ACLK        500000000           //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			10
+#define H_BP			20
+#define H_VD			1200
+#define H_FP			70
+
+#define V_PW			2
+#define V_BP			4
+#define V_VD			800
+#define V_FP			14
+
+#define LCD_WIDTH       188
+#define LCD_HEIGHT      125
+/* Other */
+#define DCLK_POL		0
+//#define DCLK_POL		1//xhh
+#define SWAP_RB			0
+
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = NULL;
+    screen->standby = NULL;
+}
-- 
2.35.3

