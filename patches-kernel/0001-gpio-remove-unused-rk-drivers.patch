From 717b50db3a6f1a7177cdb8d21d18f0918c5f50b5 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Thu, 25 Jan 2018 10:54:42 +0800
Subject: [PATCH] gpio: remove unused rk drivers

Change-Id: I5422c234f695874d7585db80c1d8d47629332852
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/gpio/expand_gpio_soft_interrupt.c | 445 ----------
 drivers/gpio/expand_gpio_soft_interrupt.h |  47 --
 drivers/gpio/gpio-rk29.c                  | 484 -----------
 drivers/gpio/gpio-rk30.c                  | 579 -------------
 drivers/gpio/pca9554.c                    | 970 ----------------------
 drivers/gpio/tca6424.c                    | 620 --------------
 include/linux/i2c/tca6424.h               |  47 --
 7 files changed, 3192 deletions(-)
 delete mode 100755 drivers/gpio/expand_gpio_soft_interrupt.c
 delete mode 100755 drivers/gpio/expand_gpio_soft_interrupt.h
 delete mode 100755 drivers/gpio/gpio-rk29.c
 delete mode 100755 drivers/gpio/gpio-rk30.c
 delete mode 100644 drivers/gpio/pca9554.c
 delete mode 100755 drivers/gpio/tca6424.c
 delete mode 100755 include/linux/i2c/tca6424.h

diff --git a/drivers/gpio/expand_gpio_soft_interrupt.c b/drivers/gpio/expand_gpio_soft_interrupt.c
deleted file mode 100755
index bbf7aa573142..000000000000
--- a/drivers/gpio/expand_gpio_soft_interrupt.c
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
- 
-/*******************************************************************/
-/*	  COPYRIGHT (C)  ROCK-CHIPS FUZHOU . ALL RIGHTS RESERVED.*/
-/*******************************************************************
-FILE			:	Soft_interrupt.c
-MODIFY		:	sxj
-DATE		:	2010-9-2
-NOTES		:
-********************************************************************/
-#include <asm/mach/time.h>
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <asm/mach-types.h>
-#include <linux/irq.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/rk2818_iomap.h>
-#include <mach/iomux.h>
-#include <linux/device.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-#include <mach/board.h>
-#include <linux/delay.h>
-#include <linux/i2c/tca6424.h>
-#include <linux/ktime.h>
-#include "../drivers/gpio/expand_gpio_soft_interrupt.h"
-
-#if 0
-#define DBG(x...)	printk(KERN_INFO x)
-#else
-#define DBG(x...)
-#endif
-#define DBGERR(x...)	printk(KERN_INFO x)
-
-
-#define EXTPAND_GPIO_GET_BIT(a,num) (((a)>>(num))&0x01)
-#define EXTPAND_GPIO_SET_BIT(a,num) ((a)|(0x01<<(num)))
-#define EXTPAND_GPIO_CLEAR_BIT(a,num) ((a)&(~(0x01<<(num))))
-#define MIN(x,y) (((x)<(y))?(x):(y)) 
-
-
-static int expand_gpio_irq_en = -1;
-static int expand_gpio_irq_ctrflag = 0;
-static unsigned int expand_gpio_irq_num = 0;
-
-static struct workqueue_struct *irqworkqueue;
-static struct lock_class_key gpio_lock_class;
-
-struct expand_gpio_soft_int expand_irq_data;
-
-void expand_gpio_irq_ctr_dis(int irq,int ctrflag)
-{
-		expand_gpio_irq_ctrflag=0;
-		if(expand_gpio_irq_en)
-		{	
-	 		expand_gpio_irq_en=0;
-	 		disable_irq_nosync(irq);
-			DBG("***********%s %d***********\n",__FUNCTION__,__LINE__);
-		}
-		if(ctrflag)
-		{
-			expand_gpio_irq_ctrflag=-1;
-		}
-}
-
-void expand_gpio_irq_ctr_en(int irq)
-{	
-		if(!expand_gpio_irq_en)
-		{	
-		     DBG("***********%s %d***********\n",__FUNCTION__,__LINE__);
-			 expand_gpio_irq_en = -1;
-			 enable_irq(irq);
-		}
-}
-
-static int expand_checkrange(int start,int num,int val)
-{
-   
-	if((val<(start+num))&&(val>=start))
-	{
-		return 0;
-	}
-	else 
-	{
-		return -1;
-	}
-
-}
-
-static void expand_gpio_irq_enable(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t expandpinnum;
-
-	if(!expand_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		expandpinnum = irq - pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else 
-	{
-		return;
-	}
-	gpioPortNum = expandpinnum/(pchip->expand_port_pinnum);
-	gpioPortPinNum= expandpinnum%(pchip->expand_port_pinnum);
-
-	if((gpioPortNum>=(pchip->expand_port_group))||(gpioPortPinNum>=(pchip->expand_port_pinnum)))
-		return;
-	//DBG("**%s**\n",__FUNCTION__);
-	pchip->interrupt_en[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->interrupt_en[gpioPortNum],gpioPortPinNum);	
-}
-static void expand_gpio_irq_disable(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t expandpinnum;
-
-	if(!expand_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		expandpinnum=irq - pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else 
-	{
-		return;
-	}
-	gpioPortNum = expandpinnum/(pchip->expand_port_pinnum);
-	gpioPortPinNum= expandpinnum%(pchip->expand_port_pinnum);
-
-	if((gpioPortNum>=(pchip->expand_port_group))||(gpioPortPinNum>=(pchip->expand_port_pinnum)))
-		return;
-	//DBG("**%s**\n",__FUNCTION__);
-	pchip->interrupt_en[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->interrupt_en[gpioPortNum],gpioPortPinNum);
-		
-}
-
-static void expand_gpio_irq_mask(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t expandpinnum;
-
-	if(!expand_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		expandpinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else 
-	{
-		return;
-	}
-	gpioPortNum = expandpinnum/(pchip->expand_port_pinnum);
-	gpioPortPinNum= expandpinnum%(pchip->expand_port_pinnum);
-	if((gpioPortNum>=(pchip->expand_port_group))||(gpioPortPinNum>=(pchip->expand_port_pinnum)))
-		return;
-	//DBG("**%s**\n",__FUNCTION__);
-	pchip->interrupt_mask[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->interrupt_mask[gpioPortNum],gpioPortPinNum);	
-}
-
-static void expand_gpio_irq_unmask(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t expandpinnum;
-
-    if(!expand_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-    {
-		expandpinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else 
-	{
-		return;
-	}
-	gpioPortNum = expandpinnum/(pchip->expand_port_pinnum);
-	gpioPortPinNum= expandpinnum%(pchip->expand_port_pinnum);
-	if((gpioPortNum>=(pchip->expand_port_group))||(gpioPortPinNum>=(pchip->expand_port_pinnum)))
-		return;
-	//DBG("**%s**\n",__FUNCTION__);
-	pchip->interrupt_mask[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->interrupt_mask[gpioPortNum],gpioPortPinNum);
-}
-
-static int expand_gpio_irq_type(unsigned int irq, unsigned int type)
-{
-	struct irq_desc *desc_irq=irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)desc_irq->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t expandpinnum;
-	if(!expand_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		expandpinnum = irq - pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else
-	{
-		return -1;
-	}
-
-	gpioPortNum = expandpinnum/(pchip->expand_port_pinnum);
-	gpioPortPinNum= expandpinnum%(pchip->expand_port_pinnum);
-	if((gpioPortNum>=(pchip->expand_port_group))||(gpioPortPinNum>=(pchip->expand_port_pinnum)))
-		return -1;
-	DBG("**%s %d PortNum=%d,PortPinNum=%d**\n",__FUNCTION__,__LINE__,gpioPortNum,gpioPortPinNum);
-	switch (type) {
-		case IRQ_TYPE_NONE:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_NONE**\n",__FUNCTION__);
-			break;
-		case IRQ_TYPE_EDGE_RISING:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->inttype[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype1[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-			break;
-		case IRQ_TYPE_EDGE_FALLING:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype1[gpioPortNum],gpioPortPinNum);	
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-			break;
-		case IRQ_TYPE_EDGE_BOTH:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=EXTPAND_GPIO_SET_BIT(pchip->inttype1[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-			break;
-		case IRQ_TYPE_LEVEL_HIGH:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("extern gpios does not support IRQ_TYPE_LEVEL_HIGH irq typ");
-			break;
-		case IRQ_TYPE_LEVEL_LOW:
-			pchip->inttype_set[gpioPortNum]=EXTPAND_GPIO_CLEAR_BIT(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("extern gpios does not support IRQ_TYPE_LEVEL_LOW irq typ");
-			break;
-		default:
-			return -EINVAL;
-	}
-	return 0;
-}
-
-static int expand_gpio_irq_set_wake(unsigned irq, unsigned state)
-{
-    //no irq wake
-	return 0;
-}
-static struct irq_chip expand_gpio_irqchip = {
-	.name		= "expand_gpio_expand ",
-	.enable 	= expand_gpio_irq_enable,
-	.disable	= expand_gpio_irq_disable,
-	.mask		= expand_gpio_irq_mask,
-	.unmask		= expand_gpio_irq_unmask,
-	.set_type	= expand_gpio_irq_type,	
-	.set_wake	= expand_gpio_irq_set_wake,
-};
-
-static irqreturn_t expand_gpio_irq_handler(int irq, void * dev_id)
-{
-	struct irq_desc *gpio_irq_desc = irq_to_desc(irq);
-	struct expand_gpio_soft_int *pchip=(struct expand_gpio_soft_int *)gpio_irq_desc->chip_data;
-	u8 oldintputreg[MAX_SUPPORT_PORT_GROUP]={0,0,0,0,0};
-	u8 tempintputreg[MAX_SUPPORT_PORT_GROUP]={0,0,0,0,0};
-	u8 tempallowint=0;			
-	u8 levelchg=0;			
-	u8 intbit[MAX_SUPPORT_PORT_GROUP]={0,0,0,0,0};			
-	u8 tempinttype=0;
-	u8 int_en_flag=0;
-	int i,j;
-
-	DBG("******************%s*******************\n",__FUNCTION__);
-	expand_gpio_irq_ctr_dis(pchip->irq_chain,0);
-	memcpy(&oldintputreg[0],&pchip->gvar->reg_input[0],pchip->expand_port_group);
-	if(pchip->irq_data.read_allinputreg(pchip->irq_data.data,&tempintputreg[0]))
-	{
-		expand_gpio_irq_ctr_dis(pchip->irq_chain,-1);
-		DBG("**%s[%d] reading reg is error\n",__FUNCTION__,__LINE__); 
-		queue_work(irqworkqueue,&pchip->irq_work);
-		return IRQ_HANDLED;
-	}
-	
-	memcpy(&pchip->gvar->reg_input[0],&tempintputreg[0],pchip->expand_port_group);
-	//DBG("**has run at %s**,input[0] = %x,input[1] = %x,input[2] = %x\n",__FUNCTION__,pchip->gvar.reg_input[0],pchip->gvar.reg_input[1],pchip->gvar.reg_input[2]);
-
-	//Handle for different expand_port_group 
-    for(i=0,int_en_flag=0;i<MIN(pchip->expand_port_group,MAX_SUPPORT_PORT_GROUP);i++)
-    {
-		int_en_flag|=pchip->interrupt_en[i];
-    }
-
-	if(!int_en_flag)
-	{		
-		if(expand_gpio_irq_num<0xFFFFFFFF)
-		{
-			expand_gpio_irq_num++;
-		}
-		else
-		{
-			expand_gpio_irq_num=0;
-		}
-		DBGERR("there are no pin reg irq\n"); 
-		expand_gpio_irq_ctr_en(pchip->irq_chain);
-		return IRQ_HANDLED;
-	}
-
-	for(i=0;i<pchip->expand_port_group;i++)
-	{
-		tempallowint=pchip->interrupt_en[i]&pchip->gvar->reg_direction[i]&(~pchip->interrupt_mask[i]);// 满足中断条件
-		levelchg=oldintputreg[i]^tempintputreg[i];// 找出前后状态不一样的pin
-		tempinttype=~(tempintputreg[i]^pchip->inttype[i]);// 找出触发状态和当前pin状态一样的pin，注意只支持low high两种pin触发
-
-	    tempinttype=(~pchip->inttype1[i])&tempinttype;// inttype1 为真的位对应的tempinttype位清零，因为该位只受inttype1控制
- 		tempinttype|=pchip->inttype1[i];//电平只要是变化就产生中断
- 		tempinttype&=pchip->inttype_set[i];//已经设置了type类型
-
-		intbit[i]=tempallowint&levelchg&tempinttype;
-		//DBG(" tempallowint=%x,levelchg=%x,tempinttype=%x,intbit=%d\n",tempallowint,levelchg,tempinttype,intbit[i]);
-	}
-	if(expand_gpio_irq_num<0xFFFFFFFF)
-	{
-		expand_gpio_irq_num++;
-	}
-	else
-	{
-		expand_gpio_irq_num=0;
-	}
-	for(i=0;i<pchip->expand_port_group;i++)
-	{
-		if(intbit[i])
-		{
-			for(j=0;j<pchip->expand_port_pinnum;j++)
-			{
-				if(EXTPAND_GPIO_GET_BIT(intbit[i],j))
-				{
-					irq=pchip->gpio_irq_start+pchip->expand_port_pinnum*i+j;
-					gpio_irq_desc = irq_to_desc(irq);
-					gpio_irq_desc->chip->mask(irq);
-					generic_handle_irq(irq);
-					gpio_irq_desc->chip->unmask(irq);
-					//DBG("expand_i2c_irq_handler port=%d,pin=%d,pinlevel=%d\n",i,j,EXTPAND_GPIO_GET_BIT(tempintputreg[i],j));
-				}
-			}
-		}
-	}
-	expand_gpio_irq_ctr_en(pchip->irq_chain);
-	return IRQ_HANDLED;
-}
-
-static void irq_call_back_handler(struct work_struct *work)
-{
-	struct expand_gpio_soft_int *pchip = container_of(work, struct expand_gpio_soft_int,irq_work);
-	//printk("irq_call_back_handle\n");
-	expand_gpio_irq_handler(pchip->irq_chain,NULL);
-}
-
-void expand_gpio_irq_setup(struct expand_gpio_soft_int *pchip)
-{
-    unsigned int pioc, irq_num;
-    int ret;
-	struct irq_desc *desc;
-    irq_num = pchip->gpio_irq_start;   //中断号，扩展io的中断号应该紧跟在内部io中断号的后面。如rk内部中断48个，加上内部gpio 16个虚拟中断，这里pin应该从48+16开始
-
-	DBG("**%s**\n",__FUNCTION__);
-    for (pioc = 0; pioc < pchip->irq_pin_num; pioc++,irq_num++)
-    {
-        lockdep_set_class(&irq_desc[irq_num].lock, &gpio_lock_class);
-	 /*
-         * Can use the "simple" and not "edge" handler since it's
-         * shorter, and the AIC handles interrupts sanely.
-        */
-		set_irq_chip(irq_num, &expand_gpio_irqchip);   
-		set_irq_handler(irq_num, handle_simple_irq);
-		set_irq_chip_data(irq_num,(void *)pchip);
-		desc = irq_to_desc(irq_num);
-		DBG("**%s line=%d,irq_num=%d**\n",__FUNCTION__,__LINE__,irq_num);
-		set_irq_flags(irq_num, IRQF_VALID);       
-    }
-	ret = gpio_request(pchip->irq_gpiopin,NULL);
-	if(ret!=0)
-	{
-		gpio_free(pchip->irq_gpiopin);
-		DBG("expand_gpio_irq_setup request gpio is err\n");
-	}
-	gpio_pull_updown(pchip->irq_gpiopin, pchip->rk_irq_gpio_pull_up_down);        //gpio 需要拉高irq_to_gpio(pchip->irq_chain)
-	irqworkqueue=create_rt_workqueue("irq workqueue");
-	INIT_WORK(&pchip->irq_work,irq_call_back_handler);
-	set_irq_chip_data(pchip->irq_chain, pchip);
-	if(request_irq(pchip->irq_chain,expand_gpio_irq_handler,pchip->rk_irq_mode, "expand", pchip)!=0)
-	{
-		DBG("**%s line=%d is err**\n",__FUNCTION__,__LINE__);
-	}
-}
-
-int wait_untill_input_reg_flash(void)
-{
-	unsigned int num = 0;
-    	unsigned int tempnum = expand_gpio_irq_num;
-
-	while(expand_gpio_irq_ctrflag&&(expand_gpio_irq_num==tempnum))
-	{
-		mdelay(1);
-		num++;
-		if(num>5)
-			return -1;
-	}
-	return 0;
-}
-
-void expand_irq_init(void *data,struct expand_gpio_global_variable *var,irq_read_inputreg handler)
-{
-	expand_irq_data.irq_data.data = data;
-	expand_irq_data.irq_data.read_allinputreg = handler;
-	expand_irq_data.gvar = var;
-	expand_gpio_irq_setup(&expand_irq_data);
-}
-
-
-
-
-
-
-
diff --git a/drivers/gpio/expand_gpio_soft_interrupt.h b/drivers/gpio/expand_gpio_soft_interrupt.h
deleted file mode 100755
index f04f6885b610..000000000000
--- a/drivers/gpio/expand_gpio_soft_interrupt.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef _SOFT_INTERRUPT_H
-#define _SOFT_INTERRUPT_H
-
-#define MAX_SUPPORT_PORT_GROUP 5
-
-typedef int (*irq_read_inputreg)(void *,char *);
-struct expand_gpio_irq_data
-{
-	void *data;
-	irq_read_inputreg read_allinputreg;
-};
-
-struct expand_gpio_global_variable
-{
-	uint8_t reg_input[MAX_SUPPORT_PORT_GROUP];
-	uint8_t reg_output[MAX_SUPPORT_PORT_GROUP];
-	uint8_t reg_direction[MAX_SUPPORT_PORT_GROUP];
-};
-struct expand_gpio_soft_int
-{
-	unsigned int gpio_irq_start;
-	unsigned int irq_pin_num;        				//中断的个数
-	unsigned int irq_gpiopin;            			//父中断的中断 脚
-	unsigned int irq_chain;            			//父中断的中断号
-
-	unsigned int expand_port_group;
-	unsigned int expand_port_pinnum;
-	unsigned int rk_irq_mode;
-	unsigned int rk_irq_gpio_pull_up_down;
-	
-	uint8_t interrupt_en[MAX_SUPPORT_PORT_GROUP];		// 0 dis
-	uint8_t interrupt_mask[MAX_SUPPORT_PORT_GROUP];		// 0 unmask
-	uint8_t inttype_set[MAX_SUPPORT_PORT_GROUP]; 		// Inttype  enable
-	uint8_t inttype[MAX_SUPPORT_PORT_GROUP]; 	
-	uint8_t inttype1[MAX_SUPPORT_PORT_GROUP];
-	
-    	struct expand_gpio_irq_data irq_data;
-	struct work_struct irq_work;
-	struct expand_gpio_global_variable *gvar;
-};
-
-extern struct expand_gpio_soft_int expand_irq_data;
-extern int wait_untill_input_reg_flash(void);
-extern void expand_irq_init(void *data,struct expand_gpio_global_variable *var,irq_read_inputreg handler);
-
-#endif
-
diff --git a/drivers/gpio/gpio-rk29.c b/drivers/gpio/gpio-rk29.c
deleted file mode 100755
index 9609618a5c24..000000000000
--- a/drivers/gpio/gpio-rk29.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/* arch/arm/mach-rk29/gpio.c
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/syscore_ops.h>
-
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/rk29_iomap.h>
-#include <mach/iomux.h>
-#include <asm/gpio.h>
-#include <asm/mach/irq.h>
-
-#define MAX_PIN	RK29_PIN6_PD7
-
-#define to_rk29_gpio_bank(c) container_of(c, struct rk29_gpio_bank, chip)
-
-struct rk29_gpio_bank {
-	struct gpio_chip chip;
-	unsigned short id;
-	short irq;
-	void __iomem *regbase;	/* Base of register bank */
-	struct clk *clk;
-	u32 suspend_wakeup;
-	u32 saved_wakeup;
-	spinlock_t lock;
-};
-
-static struct lock_class_key gpio_lock_class;
-
-static void rk29_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
-static void rk29_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
-static int rk29_gpiolib_get(struct gpio_chip *chip, unsigned offset);
-static int rk29_gpiolib_direction_output(struct gpio_chip *chip,unsigned offset, int val);
-static int rk29_gpiolib_direction_input(struct gpio_chip *chip,unsigned offset);
-static int rk29_gpiolib_pull_updown(struct gpio_chip *chip, unsigned offset, unsigned enable);
-static int rk29_gpiolib_to_irq(struct gpio_chip *chip,unsigned offset);
-
-#define RK29_GPIO_BANK(ID)			\
-	{								\
-		.chip = {						\
-			.label            = "gpio" #ID,			\
-			.direction_input  = rk29_gpiolib_direction_input, \
-			.direction_output = rk29_gpiolib_direction_output, \
-			.get              = rk29_gpiolib_get,		\
-			.set              = rk29_gpiolib_set,		\
-			.pull_updown      = rk29_gpiolib_pull_updown,	\
-			.dbg_show         = rk29_gpiolib_dbg_show,	\
-			.to_irq           = rk29_gpiolib_to_irq,	\
-			.base             = PIN_BASE + ID*NUM_GROUP,	\
-			.ngpio            = NUM_GROUP,			\
-		},							\
-		.id = ID, \
-		.irq = IRQ_GPIO##ID, \
-		.regbase = (unsigned char __iomem *) RK29_GPIO##ID##_BASE, \
-	}
-
-static struct rk29_gpio_bank rk29_gpio_banks[] = {
-	RK29_GPIO_BANK(0),
-	RK29_GPIO_BANK(1),
-	RK29_GPIO_BANK(2),
-	RK29_GPIO_BANK(3),
-	RK29_GPIO_BANK(4),
-	RK29_GPIO_BANK(5),
-	RK29_GPIO_BANK(6),
-};
-
-static inline void rk29_gpio_bit_op(void __iomem *regbase, unsigned int offset, u32 bit, unsigned char flag)
-{
-	u32 val = __raw_readl(regbase + offset);
-	if (flag)
-		val |= bit;
-	else
-		val &= ~bit;
-	__raw_writel(val, regbase + offset);
-}
-
-static inline struct gpio_chip *pin_to_gpio_chip(unsigned pin)
-{
-	if (pin < PIN_BASE || pin > MAX_PIN)
-		return NULL;
-
-	pin -= PIN_BASE;
-	pin /= NUM_GROUP;
-	if (likely(pin < ARRAY_SIZE(rk29_gpio_banks)))
-		return &(rk29_gpio_banks[pin].chip);
-	return NULL;
-}
-
-static inline unsigned gpio_to_bit(unsigned gpio)
-{
-	gpio -= PIN_BASE;
-	return 1u << (gpio % NUM_GROUP);
-}
-
-static inline unsigned offset_to_bit(unsigned offset)
-{
-	return 1u << offset;
-}
-
-static void GPIOSetPinLevel(void __iomem *regbase, unsigned int bit, eGPIOPinLevel_t level)
-{
-	rk29_gpio_bit_op(regbase, GPIO_SWPORT_DDR, bit, 1);
-	rk29_gpio_bit_op(regbase, GPIO_SWPORT_DR, bit, level);
-}
-
-static int GPIOGetPinLevel(void __iomem *regbase, unsigned int bit)
-{
-	return ((__raw_readl(regbase + GPIO_EXT_PORT) & bit) != 0);
-}
-
-static void GPIOSetPinDirection(void __iomem *regbase, unsigned int bit, eGPIOPinDirection_t direction)
-{
-	rk29_gpio_bit_op(regbase, GPIO_SWPORT_DDR, bit, direction);
-	/* Enable debounce may halt cpu on wfi, disable it by default */
-	//rk29_gpio_bit_op(regbase, GPIO_DEBOUNCE, bit, 1);
-}
-
-static void GPIOEnableIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk29_gpio_bit_op(regbase, GPIO_INTEN, bit, 1);
-}
-
-static void GPIODisableIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk29_gpio_bit_op(regbase, GPIO_INTEN, bit, 0);
-}
-
-static void GPIOAckIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk29_gpio_bit_op(regbase, GPIO_PORTS_EOI, bit, 1);
-}
-
-static void GPIOSetIntrType(void __iomem *regbase, unsigned int bit, eGPIOIntType_t type)
-{
-	switch (type) {
-	case GPIOLevelLow:
-		rk29_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 0);
-		rk29_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 0);
-		break;
-	case GPIOLevelHigh:
-		rk29_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 0);
-		rk29_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 1);
-		break;
-	case GPIOEdgelFalling:
-		rk29_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 1);
-		rk29_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 0);
-		break;
-	case GPIOEdgelRising:
-		rk29_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 1);
-		rk29_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 1);
-		break;
-	}
-}
-
-static int rk29_gpio_irq_set_type(struct irq_data *d, unsigned int type)
-{
-	struct rk29_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	eGPIOIntType_t int_type;
-	unsigned long flags;
-
-	switch (type) {
-	case IRQ_TYPE_EDGE_RISING:
-		int_type = GPIOEdgelRising;
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		int_type = GPIOEdgelFalling;
-		break;
-	case IRQ_TYPE_LEVEL_HIGH:
-		int_type = GPIOLevelHigh;
-		break;
-	case IRQ_TYPE_LEVEL_LOW:
-		int_type = GPIOLevelLow;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&bank->lock, flags);
-	//设置为中断之前，必须先设置为输入状态
-	GPIOSetPinDirection(bank->regbase, bit, GPIO_IN);
-	GPIOSetIntrType(bank->regbase, bit, int_type);
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	if (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))
-		__irq_set_handler_locked(d->irq, handle_level_irq);
-	else if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
-		__irq_set_handler_locked(d->irq, handle_edge_irq);
-
-	return 0;
-}
-
-static int rk29_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
-{
-	struct rk29_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	if (on)
-		bank->suspend_wakeup |= bit;
-	else
-		bank->suspend_wakeup &= ~bit;
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	return 0;
-}
-
-static void rk29_gpio_irq_unmask(struct irq_data *d)
-{
-	struct rk29_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOEnableIntr(bank->regbase, bit);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void rk29_gpio_irq_mask(struct irq_data *d)
-{
-	struct rk29_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIODisableIntr(bank->regbase, bit);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void rk29_gpio_irq_ack(struct irq_data *d)
-{
-	struct rk29_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-
-	GPIOAckIntr(bank->regbase, bit);
-}
-
-static int rk29_gpiolib_direction_output(struct gpio_chip *chip, unsigned offset, int val)
-{
-	struct rk29_gpio_bank *bank = to_rk29_gpio_bank(chip);
-	u32 bit = offset_to_bit(offset);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinDirection(bank->regbase, bit, GPIO_OUT);
-	GPIOSetPinLevel(bank->regbase, bit, val);
-	spin_unlock_irqrestore(&bank->lock, flags);
-	return 0;
-}
-
-static int rk29_gpiolib_direction_input(struct gpio_chip *chip,unsigned offset)
-{
-	struct rk29_gpio_bank *bank = to_rk29_gpio_bank(chip);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinDirection(bank->regbase, offset_to_bit(offset), GPIO_IN);
-	spin_unlock_irqrestore(&bank->lock, flags);
-	return 0;
-}
-
-
-static int rk29_gpiolib_get(struct gpio_chip *chip, unsigned offset)
-{
-	return GPIOGetPinLevel(to_rk29_gpio_bank(chip)->regbase, offset_to_bit(offset));
-}
-
-static void rk29_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
-{
-	struct rk29_gpio_bank *bank = to_rk29_gpio_bank(chip);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinLevel(bank->regbase, offset_to_bit(offset), val);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static int rk29_gpiolib_pull_updown(struct gpio_chip *chip, unsigned offset, unsigned enable)
-{
-	struct rk29_gpio_bank *bank = to_rk29_gpio_bank(chip);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	rk29_gpio_bit_op((void *__iomem) RK29_GRF_BASE, 0x78 + bank->id * 4, offset_to_bit(offset), !enable);
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	return 0;
-}
-
-static int rk29_gpiolib_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	return chip->base + offset;
-}
-
-static void rk29_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
-{
-#if 0
-	int i;
-
-	for (i = 0; i < chip->ngpio; i++) {
-		unsigned pin = chip->base + i;
-		struct gpio_chip *chip = pin_to_gpioChip(pin);
-		u32 bit = pin_to_bit(pin);
-		const char *gpio_label;
-		
-		if(!chip ||!bit)
-			return;
-		
-		gpio_label = gpiochip_is_requested(chip, i);
-		if (gpio_label) {
-			seq_printf(s, "[%s] GPIO%s%d: ",
-				   gpio_label, chip->label, i);
-			
-			if (!chip || !bit)
-			{
-				seq_printf(s, "!chip || !bit\t");
-				return;
-			}
-				
-			GPIOSetPinDirection(chip,bit,GPIO_IN);
-			seq_printf(s, "pin=%d,level=%d\t", pin,GPIOGetPinLevel(chip,bit));
-			seq_printf(s, "\t");
-		}
-	}
-#endif
-}
-
-static void rk29_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	struct rk29_gpio_bank *bank = irq_get_handler_data(irq);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	unsigned gpio_irq;
-	u32 isr, ilr;
-	unsigned pin;
-	unsigned unmasked = 0;
-
-	chained_irq_enter(chip, desc);
-
-	isr = __raw_readl(bank->regbase + GPIO_INT_STATUS);
-	ilr = __raw_readl(bank->regbase + GPIO_INTTYPE_LEVEL);
-
-	gpio_irq = gpio_to_irq(bank->chip.base);
-
-	while (isr) {
-		pin = fls(isr) - 1;
-		/* if gpio is edge triggered, clear condition
-		 * before executing the hander so that we don't
-		 * miss edges
-                 */
-		if (ilr & (1 << pin)) {
-			unmasked = 1;
-			chained_irq_exit(chip, desc);
-		}
-
-		generic_handle_irq(gpio_irq + pin);
-		isr &= ~(1 << pin);
-	}
-
-	if (!unmasked)
-		chained_irq_exit(chip, desc);
-}
-
-static struct irq_chip rk29_gpio_irq_chip = {
-	.name		= "GPIO",
-	.irq_ack 	= rk29_gpio_irq_ack,
-	.irq_disable	= rk29_gpio_irq_mask,
-	.irq_mask	= rk29_gpio_irq_mask,
-	.irq_unmask	= rk29_gpio_irq_unmask,
-	.irq_set_type	= rk29_gpio_irq_set_type,
-	.irq_set_wake	= rk29_gpio_irq_set_wake,
-};
-
-void __init rk29_gpio_init(void)
-{
-	unsigned int i, j, pin;
-	struct rk29_gpio_bank *bank;
-
-	bank = rk29_gpio_banks;
-	pin = PIN_BASE;
-
-	for (i = 0; i < ARRAY_SIZE(rk29_gpio_banks); i++, bank++, pin += 32) {
-		spin_lock_init(&bank->lock);
-		bank->clk = clk_get(NULL, bank->chip.label);
-		clk_enable(bank->clk);
-		gpiochip_add(&bank->chip);
-
-		__raw_writel(0, bank->regbase + GPIO_INTEN);
-		for (j = 0; j < 32; j++) {
-			unsigned int irq = gpio_to_irq(pin + j);
-			irq_set_lockdep_class(irq, &gpio_lock_class);
-			irq_set_chip_data(irq, bank);
-			irq_set_chip_and_handler(irq, &rk29_gpio_irq_chip, handle_level_irq);
-			set_irq_flags(irq, IRQF_VALID);
-		}
-
-		irq_set_handler_data(bank->irq, bank);
-		irq_set_chained_handler(bank->irq, rk29_gpio_irq_handler);
-	}
-	printk("%s: %d gpio irqs in %d banks\n", __func__, pin - PIN_BASE, ARRAY_SIZE(rk29_gpio_banks));
-}
-
-#ifdef CONFIG_PM
-__weak void rk29_setgpio_suspend_board(void)
-{
-}
-
-__weak void rk29_setgpio_resume_board(void)
-{
-}
-
-static int rk29_gpio_suspend(void)
-{
-	unsigned i;
-	
-	rk29_setgpio_suspend_board();
-
-	for (i = 0; i < ARRAY_SIZE(rk29_gpio_banks); i++) {
-		struct rk29_gpio_bank *bank = &rk29_gpio_banks[i];
-
-		bank->saved_wakeup = __raw_readl(bank->regbase + GPIO_INTEN);
-		__raw_writel(bank->suspend_wakeup, bank->regbase + GPIO_INTEN);
-
-		if (!bank->suspend_wakeup)
-			clk_disable(bank->clk);
-	}
-
-	return 0;
-}
-
-static void rk29_gpio_resume(void)
-{
-	unsigned i;
-
-	for (i = 0; i < ARRAY_SIZE(rk29_gpio_banks); i++) {
-		struct rk29_gpio_bank *bank = &rk29_gpio_banks[i];
-		u32 isr;
-
-		if (!bank->suspend_wakeup)
-			clk_enable(bank->clk);
-
-		/* keep enable for resume irq */
-		isr = __raw_readl(bank->regbase + GPIO_INT_STATUS);
-		__raw_writel(bank->saved_wakeup | (bank->suspend_wakeup & isr), bank->regbase + GPIO_INTEN);
-	}
-
-	rk29_setgpio_resume_board();
-}
-
-static struct syscore_ops rk29_gpio_syscore_ops = {
-	.suspend	= rk29_gpio_suspend,
-	.resume		= rk29_gpio_resume,
-};
-
-static int __init rk29_gpio_sysinit(void)
-{
-	register_syscore_ops(&rk29_gpio_syscore_ops);
-        return 0;
-}
-
-arch_initcall(rk29_gpio_sysinit);
-#endif
diff --git a/drivers/gpio/gpio-rk30.c b/drivers/gpio/gpio-rk30.c
deleted file mode 100755
index 2a170ce574ef..000000000000
--- a/drivers/gpio/gpio-rk30.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/* arch/arm/mach-rk29/gpio.c
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/syscore_ops.h>
-
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/io.h>
-#include <mach/iomux.h>
-#include <mach/pmu.h>
-#include <asm/gpio.h>
-#include <asm/mach/irq.h>
-
-#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188)
-#define MAX_PIN	RK30_PIN3_PD7
-#elif defined(CONFIG_ARCH_RK319X)
-#define MAX_PIN	RK30_PIN4_PD7
-#elif defined(CONFIG_ARCH_RK30)
-#define MAX_PIN	RK30_PIN6_PB7
-#elif defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)
-#define MAX_PIN	RK2928_PIN3_PD7
-#define RK30_GPIO0_PHYS	RK2928_GPIO0_PHYS
-#define RK30_GPIO0_BASE	RK2928_GPIO0_BASE
-#define RK30_GPIO0_SIZE	RK2928_GPIO0_SIZE
-#define RK30_GPIO1_PHYS	RK2928_GPIO1_PHYS
-#define RK30_GPIO1_BASE	RK2928_GPIO1_BASE
-#define RK30_GPIO1_SIZE	RK2928_GPIO1_SIZE
-#define RK30_GPIO2_PHYS	RK2928_GPIO2_PHYS
-#define RK30_GPIO2_BASE	RK2928_GPIO2_BASE
-#define RK30_GPIO2_SIZE	RK2928_GPIO2_SIZE
-#define RK30_GPIO3_PHYS	RK2928_GPIO3_PHYS
-#define RK30_GPIO3_BASE	RK2928_GPIO3_BASE
-#define RK30_GPIO3_SIZE	RK2928_GPIO3_SIZE
-#define RK30_GRF_BASE	RK2928_GRF_BASE
-#endif
-
-#define to_rk30_gpio_bank(c) container_of(c, struct rk30_gpio_bank, chip)
-
-struct rk30_gpio_bank {
-	struct gpio_chip chip;
-	unsigned short id;
-	short irq;
-	void __iomem *regbase;	/* Base of register bank */
-	struct clk *clk;
-	u32 suspend_wakeup;
-	u32 saved_wakeup;
-	spinlock_t lock;
-};
-
-static struct lock_class_key gpio_lock_class;
-
-static void rk30_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip);
-static void rk30_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val);
-static int rk30_gpiolib_get(struct gpio_chip *chip, unsigned offset);
-static int rk30_gpiolib_direction_output(struct gpio_chip *chip,unsigned offset, int val);
-static int rk30_gpiolib_direction_input(struct gpio_chip *chip,unsigned offset);
-static int rk30_gpiolib_pull_updown(struct gpio_chip *chip, unsigned offset, unsigned enable);
-static int rk30_gpiolib_to_irq(struct gpio_chip *chip,unsigned offset);
-static int rk30_gpiolib_request(struct gpio_chip *chip, unsigned offset);
-
-#define RK30_GPIO_BANK(ID)			\
-	{								\
-		.chip = {						\
-			.label            = "gpio" #ID,			\
-			.direction_input  = rk30_gpiolib_direction_input, \
-			.direction_output = rk30_gpiolib_direction_output, \
-			.get              = rk30_gpiolib_get,		\
-			.set              = rk30_gpiolib_set,		\
-			.request          = rk30_gpiolib_request,	\
-			.pull_updown      = rk30_gpiolib_pull_updown,	\
-			.dbg_show         = rk30_gpiolib_dbg_show,	\
-			.to_irq           = rk30_gpiolib_to_irq,	\
-			.base             = PIN_BASE + ID*NUM_GROUP,	\
-			.ngpio            = ID < 6 ? NUM_GROUP : 16,	\
-		},							\
-		.id = ID, \
-		.irq = IRQ_GPIO##ID, \
-		.regbase = (unsigned char __iomem *) RK30_GPIO##ID##_BASE, \
-	}
-
-static struct rk30_gpio_bank rk30_gpio_banks[] = {
-	RK30_GPIO_BANK(0),
-	RK30_GPIO_BANK(1),
-	RK30_GPIO_BANK(2),
-	RK30_GPIO_BANK(3),
-#if GPIO_BANKS > 4
-	RK30_GPIO_BANK(4),
-#endif
-#if GPIO_BANKS > 5
-	RK30_GPIO_BANK(6),
-#endif
-};
-
-static inline void rk30_gpio_bit_op(void __iomem *regbase, unsigned int offset, u32 bit, unsigned char flag)
-{
-	u32 val = __raw_readl(regbase + offset);
-	if (flag)
-		val |= bit;
-	else
-		val &= ~bit;
-	__raw_writel(val, regbase + offset);
-}
-
-static inline struct gpio_chip *pin_to_gpio_chip(unsigned pin)
-{
-	if (pin < PIN_BASE || pin > MAX_PIN)
-		return NULL;
-
-	pin -= PIN_BASE;
-	pin /= NUM_GROUP;
-	if (likely(pin < ARRAY_SIZE(rk30_gpio_banks)))
-		return &(rk30_gpio_banks[pin].chip);
-	return NULL;
-}
-
-static inline unsigned gpio_to_bit(unsigned gpio)
-{
-	gpio -= PIN_BASE;
-	return 1u << (gpio % NUM_GROUP);
-}
-
-static inline unsigned offset_to_bit(unsigned offset)
-{
-	return 1u << offset;
-}
-
-static void GPIOSetPinLevel(void __iomem *regbase, unsigned int bit, eGPIOPinLevel_t level)
-{
-	rk30_gpio_bit_op(regbase, GPIO_SWPORT_DDR, bit, 1);
-	rk30_gpio_bit_op(regbase, GPIO_SWPORT_DR, bit, level);
-}
-
-static int GPIOGetPinLevel(void __iomem *regbase, unsigned int bit)
-{
-	return ((__raw_readl(regbase + GPIO_EXT_PORT) & bit) != 0);
-}
-
-static void GPIOSetPinDirection(void __iomem *regbase, unsigned int bit, eGPIOPinDirection_t direction)
-{
-	rk30_gpio_bit_op(regbase, GPIO_SWPORT_DDR, bit, direction);
-	/* Enable debounce may halt cpu on wfi, disable it by default */
-	//rk30_gpio_bit_op(regbase, GPIO_DEBOUNCE, bit, 1);
-}
-
-static void GPIOEnableIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk30_gpio_bit_op(regbase, GPIO_INTEN, bit, 1);
-}
-
-static void GPIODisableIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk30_gpio_bit_op(regbase, GPIO_INTEN, bit, 0);
-}
-
-static void GPIOAckIntr(void __iomem *regbase, unsigned int bit)
-{
-	rk30_gpio_bit_op(regbase, GPIO_PORTS_EOI, bit, 1);
-}
-
-static void GPIOSetIntrType(void __iomem *regbase, unsigned int bit, eGPIOIntType_t type)
-{
-	switch (type) {
-	case GPIOLevelLow:
-		rk30_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 0);
-		rk30_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 0);
-		break;
-	case GPIOLevelHigh:
-		rk30_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 0);
-		rk30_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 1);
-		break;
-	case GPIOEdgelFalling:
-		rk30_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 1);
-		rk30_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 0);
-		break;
-	case GPIOEdgelRising:
-		rk30_gpio_bit_op(regbase, GPIO_INTTYPE_LEVEL, bit, 1);
-		rk30_gpio_bit_op(regbase, GPIO_INT_POLARITY, bit, 1);
-		break;
-	}
-}
-
-static int rk30_gpio_irq_set_type(struct irq_data *d, unsigned int type)
-{
-	struct rk30_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	eGPIOIntType_t int_type;
-	unsigned long flags;
-
-	switch (type) {
-	case IRQ_TYPE_EDGE_RISING:
-		int_type = GPIOEdgelRising;
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		int_type = GPIOEdgelFalling;
-		break;
-	case IRQ_TYPE_LEVEL_HIGH:
-		int_type = GPIOLevelHigh;
-		break;
-	case IRQ_TYPE_LEVEL_LOW:
-		int_type = GPIOLevelLow;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&bank->lock, flags);
-	//设置为中断之前，必须先设置为输入状态
-	GPIOSetPinDirection(bank->regbase, bit, GPIO_IN);
-	GPIOSetIntrType(bank->regbase, bit, int_type);
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	if (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))
-		__irq_set_handler_locked(d->irq, handle_level_irq);
-	else if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
-		__irq_set_handler_locked(d->irq, handle_edge_irq);
-
-	return 0;
-}
-
-static int rk30_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
-{
-	struct rk30_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	if (on)
-		bank->suspend_wakeup |= bit;
-	else
-		bank->suspend_wakeup &= ~bit;
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	return 0;
-}
-
-static void rk30_gpio_irq_unmask(struct irq_data *d)
-{
-	struct rk30_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOEnableIntr(bank->regbase, bit);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void rk30_gpio_irq_mask(struct irq_data *d)
-{
-	struct rk30_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIODisableIntr(bank->regbase, bit);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void rk30_gpio_irq_ack(struct irq_data *d)
-{
-	struct rk30_gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 bit = gpio_to_bit(irq_to_gpio(d->irq));
-
-	GPIOAckIntr(bank->regbase, bit);
-}
-
-static int rk30_gpiolib_direction_output(struct gpio_chip *chip, unsigned offset, int val)
-{
-	struct rk30_gpio_bank *bank = to_rk30_gpio_bank(chip);
-	u32 bit = offset_to_bit(offset);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinDirection(bank->regbase, bit, GPIO_OUT);
-	GPIOSetPinLevel(bank->regbase, bit, val);
-	spin_unlock_irqrestore(&bank->lock, flags);
-	return 0;
-}
-
-static int rk30_gpiolib_direction_input(struct gpio_chip *chip,unsigned offset)
-{
-	struct rk30_gpio_bank *bank = to_rk30_gpio_bank(chip);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinDirection(bank->regbase, offset_to_bit(offset), GPIO_IN);
-	spin_unlock_irqrestore(&bank->lock, flags);
-	return 0;
-}
-
-static int rk30_gpiolib_request(struct gpio_chip *chip, unsigned offset)
-{
-	iomux_set_gpio_mode(chip->base + offset);
-        return 0;
-}
-
-static int rk30_gpiolib_get(struct gpio_chip *chip, unsigned offset)
-{
-	return GPIOGetPinLevel(to_rk30_gpio_bank(chip)->regbase, offset_to_bit(offset));
-}
-
-static void rk30_gpiolib_set(struct gpio_chip *chip, unsigned offset, int val)
-{
-	struct rk30_gpio_bank *bank = to_rk30_gpio_bank(chip);
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	GPIOSetPinLevel(bank->regbase, offset_to_bit(offset), val);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static int rk30_gpiolib_pull_updown(struct gpio_chip *chip, unsigned offset, enum GPIOPullType type)
-{
-#if defined(CONFIG_ARCH_RK3066B)
-#else
-	struct rk30_gpio_bank *bank = to_rk30_gpio_bank(chip);
-	void __iomem *base;
-	u32 val;
-
-#if defined(CONFIG_ARCH_RK3188) || defined(CONFIG_ARCH_RK319X)
-	/*
-	 * pull setting
-	 * 2'b00: Z(Noraml operaton)
-	 * 2'b01: weak 1(pull-up)
-	 * 2'b10: weak 0(pull-down)
-	 * 2'b11: Repeater(Bus keeper)
-	 */
-	switch (type) {
-	case PullDisable:
-		val = 0;
-		break;
-	case GPIOPullUp:
-		val = 1;
-		break;
-	case GPIOPullDown:
-		val = 2;
-		break;
-	default:
-		WARN(1, "%s: unsupported pull type %d\n", __func__, type);
-		return -EINVAL;
-	}
-
-#if defined(CONFIG_ARCH_RK319X)
-	if (bank->id == 0) {
-		base = RK319X_BB_GRF_BASE + BB_GRF_GPIO0A_PULL + ((offset / 8) * 4);
-		offset = (offset % 8) * 2;
-		__raw_writel((0x3 << (16 + offset)) | (val << offset), base);
-	} else {
-		base = RK319X_GRF_BASE + GRF_GPIO1A_PULL + (bank->id - 1) * 16 + ((offset / 8) * 4);
-		offset = (7 - (offset % 8)) * 2;
-		__raw_writel((0x3 << (16 + offset)) | (val << offset), base);
-	}
-#else
-	if (bank->id == 0 && offset < 12) {
-		base = RK30_PMU_BASE + PMU_GPIO0A_PULL + ((offset / 8) * 4);
-		offset = (offset % 8) * 2;
-		__raw_writel((0x3 << (16 + offset)) | (val << offset), base);
-	} else {
-		base = RK30_GRF_BASE + GRF_GPIO0B_PULL - 4 + bank->id * 16 + ((offset / 8) * 4);
-		offset = (7 - (offset % 8)) * 2;
-		__raw_writel((0x3 << (16 + offset)) | (val << offset), base);
-	}
-#endif
-#else
-	/* RK30XX && RK292X */
-	/*
-	 * Values written to this register independently
-	 * control Pullup/Pulldown or not for the
-	 * corresponding data bit in GPIO.
-	 * 0: pull up/down enable, PAD type will decide
-	 * to be up or down, not related with this value
-	 * 1: pull up/down disable
-	*/
-	val = (type == PullDisable) ? 1 : 0;
-	base = RK30_GRF_BASE + GRF_GPIO0L_PULL + bank->id * 8 + ((offset / 16) * 4);
-	offset = offset % 16;
-	__raw_writel((1 << (16 + offset)) | (val << offset), base);
-#endif
-#endif
-	return 0;
-}
-
-static int rk30_gpiolib_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	return chip->base + offset;
-}
-
-static void rk30_gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)
-{
-#if 0
-	int i;
-
-	for (i = 0; i < chip->ngpio; i++) {
-		unsigned pin = chip->base + i;
-		struct gpio_chip *chip = pin_to_gpioChip(pin);
-		u32 bit = pin_to_bit(pin);
-		const char *gpio_label;
-		
-		if(!chip ||!bit)
-			return;
-		
-		gpio_label = gpiochip_is_requested(chip, i);
-		if (gpio_label) {
-			seq_printf(s, "[%s] GPIO%s%d: ",
-				   gpio_label, chip->label, i);
-			
-			if (!chip || !bit)
-			{
-				seq_printf(s, "!chip || !bit\t");
-				return;
-			}
-				
-			GPIOSetPinDirection(chip,bit,GPIO_IN);
-			seq_printf(s, "pin=%d,level=%d\t", pin,GPIOGetPinLevel(chip,bit));
-			seq_printf(s, "\t");
-		}
-	}
-#endif
-}
-
-static void rk30_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	struct rk30_gpio_bank *bank = irq_get_handler_data(irq);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	unsigned gpio_irq;
-	u32 isr, ilr;
-	unsigned pin;
-	unsigned unmasked = 0;
-
-	chained_irq_enter(chip, desc);
-
-	isr = __raw_readl(bank->regbase + GPIO_INT_STATUS);
-	ilr = __raw_readl(bank->regbase + GPIO_INTTYPE_LEVEL);
-
-	gpio_irq = gpio_to_irq(bank->chip.base);
-
-	while (isr) {
-		pin = fls(isr) - 1;
-		/* if gpio is edge triggered, clear condition
-		 * before executing the hander so that we don't
-		 * miss edges
-                 */
-		if (ilr & (1 << pin)) {
-			unmasked = 1;
-			chained_irq_exit(chip, desc);
-		}
-
-		generic_handle_irq(gpio_irq + pin);
-		isr &= ~(1 << pin);
-	}
-
-	if (!unmasked)
-		chained_irq_exit(chip, desc);
-}
-
-static struct irq_chip rk30_gpio_irq_chip = {
-	.name		= "GPIO",
-	.irq_ack 	= rk30_gpio_irq_ack,
-	.irq_disable	= rk30_gpio_irq_mask,
-	.irq_mask	= rk30_gpio_irq_mask,
-	.irq_unmask	= rk30_gpio_irq_unmask,
-	.irq_set_type	= rk30_gpio_irq_set_type,
-	.irq_set_wake	= rk30_gpio_irq_set_wake,
-};
-
-void __init rk30_gpio_init(void)
-{
-	unsigned int i, j, pin, irqs = 0;
-	struct rk30_gpio_bank *bank;
-
-	bank = rk30_gpio_banks;
-
-	for (i = 0; i < ARRAY_SIZE(rk30_gpio_banks); i++, bank++) {
-		spin_lock_init(&bank->lock);
-		bank->clk = clk_get(NULL, bank->chip.label);
-		clk_enable(bank->clk);
-		gpiochip_add(&bank->chip);
-
-		__raw_writel(0, bank->regbase + GPIO_INTEN);
-		pin = bank->chip.base;
-		for (j = 0; j < 32; j++) {
-			unsigned int irq = gpio_to_irq(pin);
-			if (pin > MAX_PIN)
-				break;
-			irq_set_lockdep_class(irq, &gpio_lock_class);
-			irq_set_chip_data(irq, bank);
-			irq_set_chip_and_handler(irq, &rk30_gpio_irq_chip, handle_level_irq);
-			set_irq_flags(irq, IRQF_VALID);
-			pin++;
-			irqs++;
-		}
-
-		irq_set_handler_data(bank->irq, bank);
-		irq_set_chained_handler(bank->irq, rk30_gpio_irq_handler);
-	}
-	printk("%s: %d gpio irqs in %d banks\n", __func__, irqs, ARRAY_SIZE(rk30_gpio_banks));
-}
-
-#ifdef CONFIG_PM
-__weak void rk30_setgpio_suspend_board(void)
-{
-}
-
-__weak void rk30_setgpio_resume_board(void)
-{
-}
-
-static int rk30_gpio_suspend(void)
-{
-	unsigned i;
-	
-	rk30_setgpio_suspend_board();
-
-	for (i = 0; i < ARRAY_SIZE(rk30_gpio_banks); i++) {
-		struct rk30_gpio_bank *bank = &rk30_gpio_banks[i];
-
-		bank->saved_wakeup = __raw_readl(bank->regbase + GPIO_INTEN);
-		__raw_writel(bank->suspend_wakeup, bank->regbase + GPIO_INTEN);
-
-		if (!bank->suspend_wakeup)
-			clk_disable(bank->clk);
-	}
-
-	return 0;
-}
-
-static void rk30_gpio_resume(void)
-{
-	unsigned i;
-
-	for (i = 0; i < ARRAY_SIZE(rk30_gpio_banks); i++) {
-		struct rk30_gpio_bank *bank = &rk30_gpio_banks[i];
-		u32 isr;
-
-		if (!bank->suspend_wakeup)
-			clk_enable(bank->clk);
-
-		/* keep enable for resume irq */
-		isr = __raw_readl(bank->regbase + GPIO_INT_STATUS);
-		__raw_writel(bank->saved_wakeup | (bank->suspend_wakeup & isr), bank->regbase + GPIO_INTEN);
-	}
-
-	rk30_setgpio_resume_board();
-}
-
-static struct syscore_ops rk30_gpio_syscore_ops = {
-	.suspend	= rk30_gpio_suspend,
-	.resume		= rk30_gpio_resume,
-};
-
-static int __init rk30_gpio_sysinit(void)
-{
-	register_syscore_ops(&rk30_gpio_syscore_ops);
-        return 0;
-}
-
-arch_initcall(rk30_gpio_sysinit);
-#endif
diff --git a/drivers/gpio/pca9554.c b/drivers/gpio/pca9554.c
deleted file mode 100644
index 6ff0a260c482..000000000000
--- a/drivers/gpio/pca9554.c
+++ /dev/null
@@ -1,970 +0,0 @@
-/* arch/arm/mach-rk2818/example.c
- *
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-/*******************************************************************/
-/*	  COPYRIGHT (C)  ROCK-CHIPS FUZHOU . ALL RIGHTS RESERVED.			  */
-/*******************************************************************
-FILE		:	  PCA9554.C
-DESC		:	  扩展GPIO 的驱动相关程序
-AUTHOR		:	  ZHONGYW  
-DATE		:	  2009-4-26
-NOTES		:
-$LOG: GPIO.C,V $
-REVISION 0.01
-********************************************************************/
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <asm/mach-types.h>
-#include <linux/irq.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/rk2818_iomap.h>
-#include <mach/iomux.h>
-#include <linux/device.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-#include <mach/board.h>
-#define PCA9554_GPIO_IRQNum 8
-#define PCA9554_PortNum 1
-#define PCA9554_PortPinNum 8
-#define PCA9554_TotalPortPinNum (PCA9554_PortNum*PCA9554_PortPinNum)
-
-#define PCA9554_InputLevel_Reg 0x0   //r only
-#define PCA9554_OutputLevel_Reg 0x1 // r/w  default ffff
-#define PCA9554_Invert_Reg 0x2  // r/w  default 0
-#define PCA9554_Config_Reg 0x3 // r/w  default ffff
-
-//#define PCA9554_INPUT_REG_IRQ_PIN  RK2818_PIN_PE2
-
-#define PCA9554_OUTREGLOCK
-#define PCA9554_INPUTREGLOCK
-#define PCA9554_CONFIGREGLOCK
-
-struct pca9554_chip {
-	/*  the first extern gpio number in all of gpio groups */
-	unsigned gpio_start;
-	unsigned	gpio_pin_num;
-		/*  the first gpio irq  number in all of irq source */
-
-	unsigned gpio_irq_start;
-	unsigned irq_pin_num;        //中断的个数
-	unsigned irq_gpiopin;            //父中断的中断号
-	unsigned irq_chain;            //父中断的中断号
-	uint8_t reg_input[PCA9554_PortNum];
-	uint8_t reg_output[PCA9554_PortNum];
-	uint8_t reg_direction[PCA9554_PortNum];
-	uint8_t interrupt_en[PCA9554_PortNum];// 0 dis
-	uint8_t interrupt_mask[PCA9554_PortNum];// 0 unmask
-	uint8_t inttype_set[PCA9554_PortNum]; // Inttype  enable
-	uint8_t inttype[PCA9554_PortNum]; // 
-	uint8_t inttype1[PCA9554_PortNum];
-
-
-#ifdef PCA9554_OUTREGLOCK
-	struct mutex outreglock;
-#endif
-#ifdef PCA9554_INPUTREGLOCK
-	struct mutex inputreglock;
-#endif
-#ifdef PCA9554_CONFIGREGLOCK
-	struct mutex configreglock;
-#endif
-
-	struct i2c_client *client;
-	struct pca9554_platform_data *dyn_pdata;
-	struct work_struct pca9554_work;
-
-	struct gpio_chip gpio_chip;
-	
-	char **names;
-};
-
-
-#if 0
-#define DBG(x...)	printk(KERN_INFO x)
-#else
-#define DBG(x...)
-#endif
-
-#if 1
-#define DBGERR(x...)	printk(KERN_INFO x)
-#else
-#define DBGERR(x...)
-#endif
-
-
-struct i2c_client *pca9554_client;
-#define pca9554getbit(a,num) (((a)>>(num))&0x01)
-#define pca9554setbit(a,num) ((a)|(0x01<<(num)))
-#define pca9554clearbit(a,num) ((a)&(~(0x01<<(num))))
-
-static short int portnum[PCA9554_PortNum]={PCA9554_PortPinNum};
-extern inline struct gpio_chip *gpio_to_chip(unsigned gpio);
-extern struct lock_class_key gpio_lock_class;
-extern struct lock_class_key gpio_lock_class;
-struct workqueue_struct *pca9554workqueue;
-
-static const struct i2c_device_id pca9554_id[] = 
-{
-     { "extend_gpio_pca9554", 8, }, 
-    { }
-};
-
-MODULE_DEVICE_TABLE(i2c, pca9554_id);
-
-
-static int pca9554_write_reg(struct i2c_client *client, uint8_t reg, uint8_t val)
-{
-	int ret=-1;
-	
-	struct i2c_adapter *adap;
-	struct i2c_msg msg;
-	char tx_buf[2];
-	if(!client)
-		return ret;    
-	adap = client->adapter;		
-	tx_buf[0] = reg;
-	tx_buf[1]=val;
-
-	msg.addr = client->addr;
-	msg.buf = &tx_buf[0];
-	msg.len = 1 +1;
-	msg.flags = client->flags;   
-	msg.scl_rate = 200*1000;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	return ret;    
-}
-
-static int pca9554_read_reg(struct i2c_client *client, uint8_t reg, uint8_t *val)
-{
-
-  int ret;
-    struct i2c_adapter *adap;
-    struct i2c_msg msgs[2];
-    if(!client)
-	return ret;    
-    adap = client->adapter;		
-    //发送寄存器地址
-    msgs[0].addr = client->addr;
-    msgs[0].buf = &reg;
-    msgs[0].flags = client->flags;
-    msgs[0].len = 1;
-    msgs[0].scl_rate = 200*1000;
-    //接收数据
-    msgs[1].buf = val;
-    msgs[1].addr = client->addr;
-    msgs[1].flags = client->flags | I2C_M_RD;
-    msgs[1].len = 1;
-    msgs[1].scl_rate = 200*1000;
-
-    ret = i2c_transfer(adap, msgs, 2);
-    //DBG("**has run at %s %d ret=%d**\n",__FUNCTION__,__LINE__,ret);
-
-    return ret;     
-}
-
-static int pca9554_gpio_direction_input(struct gpio_chip *gc, unsigned off)
-{
-	struct pca9554_chip *chip;
-
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t reg_val;    
-	int ret=-1;
-	DBG("**run in the %s**\n",__FUNCTION__);
-	chip = container_of(gc, struct pca9554_chip, gpio_chip);
-
-	gpioPortNum = off/8;
-	gpioPortPinNum= off%8;
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return ret;
-
-#ifdef PCA9554_CONFIGREGLOCK
-	if (!mutex_trylock(&chip->configreglock))
-	{
-		DBGERR("**%s[%d]Did not get the configreglock**\n",__FUNCTION__,__LINE__);
-		return ret;
-	}
-#endif
-
-	reg_val = pca9554setbit(chip->reg_direction[gpioPortNum], gpioPortPinNum);
-	ret = pca9554_write_reg(chip->client, PCA9554_Config_Reg, reg_val);
-	if(ret<0)
-		goto err;
-
-	chip->reg_direction[gpioPortNum] = reg_val;
-err:
-	
-	DBG("**%s[%d],reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-
-	#ifdef PCA9554_CONFIGREGLOCK
-	mutex_unlock(&chip->configreglock);
-	#endif
-
-	return (ret<0)?-1:0;
-}
-
-static int pca9554_gpio_direction_output(struct gpio_chip *gc,unsigned off, int val)
-{
-	struct pca9554_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t reg_val;
-	int ret=-1;
-	DBG("**run in the %s**\n",__FUNCTION__);
-
-	chip = container_of(gc, struct pca9554_chip, gpio_chip);
-
-	gpioPortNum = off/8;
-	gpioPortPinNum= off%8;
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-	return ret;
-	
-	#ifdef PCA9554_CONFIGREGLOCK
-	if (!mutex_trylock(&chip->configreglock))
-	{
-		DBGERR("**%s[%d]Did not get the configreglock**\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	#endif
-	/* then direction */
-	reg_val = pca9554clearbit(chip->reg_direction[gpioPortNum], gpioPortPinNum);
-	ret = pca9554_write_reg(chip->client, PCA9554_Config_Reg, reg_val);
-	if(ret<0)
-	{
-		#ifdef PCA9554_CONFIGREGLOCK
-		mutex_unlock(&chip->configreglock);
-		#endif
-		DBGERR("**%s[%d] set direction reg is error,reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-    		return ret;
-	}
-	chip->reg_direction[gpioPortNum] = reg_val;
-#ifdef PCA9554_CONFIGREGLOCK
-	mutex_unlock(&chip->configreglock);
-#endif
-    ret=-1;
-    #ifdef PCA9554_OUTREGLOCK
-	if (!mutex_trylock(&chip->outreglock))
-	{
-		DBGERR("**%s[%d] Did not get the outreglock**\n",__FUNCTION__,__LINE__);
-		return ret;
-	}
-	#endif
-	/* set output level */
-	if (val)
-		reg_val = pca9554setbit(chip->reg_output[gpioPortNum], gpioPortPinNum);
-	else
-		reg_val = pca9554clearbit(chip->reg_output[gpioPortNum], gpioPortPinNum);
-
-	ret = pca9554_write_reg(chip->client, PCA9554_OutputLevel_Reg, reg_val);
-	if (ret<0)
-	{
-	#ifdef PCA9554_OUTREGLOCK
-		mutex_unlock(&chip->outreglock);
-	#endif
-		DBGERR("**%s[%d] set out reg is error,reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-		return ret;
-	}
-	chip->reg_output[gpioPortNum] = reg_val;
-
-	#ifdef PCA9554_OUTREGLOCK
-		mutex_unlock(&chip->outreglock);
-	#endif
-    return (ret<0)?-1:0;
-}
-
-static int pca9554_gpio_get_value(struct gpio_chip *gc, unsigned off)
-{
-	struct pca9554_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t reg_val;
-	int ret=-1;
-	DBG("**run in the %s**\n",__FUNCTION__);
-
-	chip = container_of(gc, struct pca9554_chip, gpio_chip);
-	gpioPortNum = off/8;
-	gpioPortPinNum= off%8;
-
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return -1;
-
-	if(!pca9554getbit(chip->reg_direction[gpioPortNum],gpioPortPinNum))  //判断该pin是否设置成input
-		return -1;
-#ifdef PCA9554_INPUTREGLOCK
-	if (!mutex_trylock(&chip->inputreglock))
-	{
-		DBGERR("**%s[%d]Did not get the inputreglock**\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-#endif
-
-	ret = pca9554_read_reg(chip->client, PCA9554_InputLevel_Reg, &reg_val);
-	if (ret < 0) 
-		goto err;
-	chip->reg_input[gpioPortNum] = reg_val;
-err:
-#ifdef PCA9554_CONFIGREGLOCK
-	mutex_unlock(&chip->inputreglock);
-#endif
-	DBGERR("**%s[%d]reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-
-	return (ret < 0)?-1:((chip->reg_input[gpioPortNum] >> gpioPortPinNum) & 0x01);
-}
-
-static void pca9554_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
-{
-	struct pca9554_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t reg_val;
-	int ret=-1;
-	DBG("**run in the %s**\n",__FUNCTION__);
-
-	chip = container_of(gc, struct pca9554_chip, gpio_chip);
-
-	gpioPortNum = off/8;
-	gpioPortPinNum= off%8;
-
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-	return;// -1;
-	
-	if(pca9554getbit(chip->reg_direction[gpioPortNum],gpioPortPinNum)) // input state
-		return;// -1;
-
-#ifdef PCA9554_OUTREGLOCK
-	if (!mutex_trylock(&chip->outreglock))
-	{
-		DBGERR("**%s[%d] Did not get the outreglock**\n",__FUNCTION__,__LINE__);
-		return;// -1;
-	}
-#endif
-	if (val)
-		reg_val = pca9554setbit(chip->reg_output[gpioPortNum], gpioPortPinNum);
-	else
-		reg_val = pca9554clearbit(chip->reg_output[gpioPortNum], gpioPortPinNum);
-
-	ret = pca9554_write_reg(chip->client, PCA9554_OutputLevel_Reg, reg_val);
-	if (ret<0)
-		goto err;
-	chip->reg_output[gpioPortNum] = reg_val;
-err: 
-	#ifdef PCA9554_OUTREGLOCK
-		mutex_unlock(&chip->outreglock);
-	#endif
-	
-	DBG("**%s[%d],reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-
-	return;// (ret<0)?-1:0;
-	
-}
-static int pca9554_gpio_to_irq(struct gpio_chip *chip,unsigned offset)
-{
-     	struct pca9554_chip *pca_chip = container_of(chip, struct pca9554_chip, gpio_chip);
-	if(((pca_chip->gpio_start+offset)>=chip->base)&&((pca_chip->gpio_start+offset)<(chip->base+chip->ngpio)))
-	{
-  	//DBG("**%s,offset=%d,gpio_irq_start=%d,base=%d,ngpio=%d,gpio_irq_start=%d**\n",
-	//	__FUNCTION__,offset,pca_chip->gpio_irq_start,chip->base,chip->ngpio,pca_chip->gpio_irq_start);
-	return (offset+pca_chip->gpio_irq_start);
-	}
-	else
-		return -1;
-}
-static void pca9554_setup_gpio(struct pca9554_chip *chip, int gpios)
-{
-    struct gpio_chip *gc;
-
-    gc = &chip->gpio_chip;
-
-    gc->direction_input  = pca9554_gpio_direction_input;
-    gc->direction_output = pca9554_gpio_direction_output;
-    gc->get = pca9554_gpio_get_value;
-    gc->set = pca9554_gpio_set_value;
-    gc->to_irq =pca9554_gpio_to_irq;
-
-    gc->can_sleep = 1;
-
-    gc->base = chip->gpio_start;
-    gc->ngpio = chip->gpio_pin_num;
-    gc->label = chip->client->name;
-    gc->dev = &chip->client->dev;
-    gc->owner = THIS_MODULE;
-    gc->names = chip->names;
-}
-
-int pca9554_checkrange(int start,int num,int val)
-{
-   
-	if((val<(start+num))&&(val>=start))
-		return 0;
-	else return -1;
-
-}
-static void pca9554_gpio_irq_enable(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	//int gpiopinnum;
-	struct pca9554_chip *pchip=(struct pca9554_chip *)desc->chip_data;
-	//struct gpio_chip *chip_gpio;
-	unsigned gpio_num;
-
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t pca9554pinnum;
-
-
-	if(!pca9554_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		pca9554pinnum=irq-pchip->gpio_irq_start;
-	}
-	 else return;
-	gpioPortNum = pca9554pinnum/8;
-	gpioPortPinNum= pca9554pinnum%8;
-	gpio_num=pchip->gpio_start+pca9554pinnum;
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return;
-	DBG("**%s**\n",__FUNCTION__);
-	pchip->interrupt_en[gpioPortNum]=pca9554setbit(pchip->interrupt_en[gpioPortNum],gpioPortPinNum);	
-}
-static void pca9554_gpio_irq_disable(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct pca9554_chip *pchip=(struct pca9554_chip *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t pca9554pinnum;
-
-
-	if(!pca9554_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		pca9554pinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else return;
-	gpioPortNum = pca9554pinnum/8;
-	gpioPortPinNum= pca9554pinnum%8;
-
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return;
-	DBG("**%s**\n",__FUNCTION__);
-
-	pchip->interrupt_en[gpioPortNum]=pca9554clearbit(pchip->interrupt_en[gpioPortNum],gpioPortPinNum);
-		
-}
-
-
-static void pca9554_gpio_irq_mask(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct pca9554_chip *pchip=(struct pca9554_chip *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t pca9554pinnum;
-
-
-	if(!pca9554_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		pca9554pinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	else return;
-	gpioPortNum = pca9554pinnum/8;
-	gpioPortPinNum= pca9554pinnum%8;
-	
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return;
-
-	DBG("**%s**\n",__FUNCTION__);
-
-	pchip->interrupt_mask[gpioPortNum]=pca9554setbit(pchip->interrupt_mask[gpioPortNum],gpioPortPinNum);
-		
-}
-
-static void pca9554_gpio_irq_unmask(unsigned irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	//int gpiopinnum;//=irq_to_gpio(irq);
-	struct pca9554_chip *pchip=(struct pca9554_chip *)desc->chip_data;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t pca9554pinnum;
-
-	DBG("**%s**\n",__FUNCTION__);
-
-     if(!pca9554_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-     	{
-		pca9554pinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-	}
-	 else return;
-	gpioPortNum = pca9554pinnum/8;
-	gpioPortPinNum= pca9554pinnum%8;
-	
-	if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return;
-
-
-	pchip->interrupt_mask[gpioPortNum]=pca9554clearbit(pchip->interrupt_mask[gpioPortNum],gpioPortPinNum);
-}
-
-static int pca9554_gpio_irq_type(unsigned int irq, unsigned int type)
-{
-	struct irq_desc *desc_irq=irq_to_desc(irq);
-	struct pca9554_chip *pchip=(struct pca9554_chip *)desc_irq->chip_data;
-	//struct gpio_chip *chip_gpio;
-	int gpio_num;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t pca9554pinnum;
-	if(!pca9554_checkrange(pchip->gpio_irq_start,pchip->irq_pin_num,irq))
-	{
-		pca9554pinnum=irq-pchip->gpio_irq_start;//irq_to_gpio(irq)
-		gpio_num=pchip->gpio_start+pca9554pinnum;
-	}
-	else
-		return -1;
-
-	gpioPortNum = pca9554pinnum/8;
-	gpioPortPinNum= pca9554pinnum%8;
-	 //DBG("**%s %d gpio_num=%d,PortNum=%d,PortPinNum=%d**\n",__FUNCTION__,__LINE__,gpio_num,gpioPortNum,gpioPortPinNum);
-	switch (type) {
-		case IRQ_TYPE_NONE:
-			pchip->inttype_set[gpioPortNum]=pca9554clearbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_NONE**\n",__FUNCTION__);
-			break;
-		case IRQ_TYPE_EDGE_RISING:
-			pchip->inttype_set[gpioPortNum]=pca9554setbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype[gpioPortNum]=pca9554setbit(pchip->inttype[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=pca9554clearbit(pchip->inttype1[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-
-		break;
-		case IRQ_TYPE_EDGE_FALLING:
-			pchip->inttype_set[gpioPortNum]=pca9554setbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype[gpioPortNum]=pca9554clearbit(pchip->inttype[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=pca9554clearbit(pchip->inttype1[gpioPortNum],gpioPortPinNum);	
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-
-		break;
-		case IRQ_TYPE_EDGE_BOTH:
-			pchip->inttype_set[gpioPortNum]=pca9554setbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			pchip->inttype1[gpioPortNum]=pca9554setbit(pchip->inttype1[gpioPortNum],gpioPortPinNum);
-			DBG("**%s IRQ_TYPE_EDGE_RISING,inttype=%x,inttype1=%x**\n",__FUNCTION__,pchip->inttype[gpioPortNum],pchip->inttype1[gpioPortNum]);
-		break;
-		case IRQ_TYPE_LEVEL_HIGH:
-			pchip->inttype_set[gpioPortNum]=pca9554clearbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("extern gpios does not support IRQ_TYPE_LEVEL_HIGH irq typ");
-		break;
-		case IRQ_TYPE_LEVEL_LOW:
-			pchip->inttype_set[gpioPortNum]=pca9554clearbit(pchip->inttype_set[gpioPortNum],gpioPortPinNum);
-			DBG("extern gpios does not support IRQ_TYPE_LEVEL_LOW irq typ");
-		break;
-		default:
-		return -EINVAL;
-	}
-return 0;
-}
-
-static int pca9554_gpio_irq_set_wake(unsigned irq, unsigned state)
-{
-       //no irq wake
-	return 0;
-
-}
-static struct irq_chip pca9554_gpio_irqchip = {
-	.name		= "GPIO_EXT",
-	.enable 		= pca9554_gpio_irq_enable,
-	.disable		= pca9554_gpio_irq_disable,
-	.mask		= pca9554_gpio_irq_mask,
-	.unmask		= pca9554_gpio_irq_unmask,
-	.set_type	= pca9554_gpio_irq_type,	
-	.set_wake	= pca9554_gpio_irq_set_wake,
-};
-
-static void pca9554_extend_gpio_irq_handler(struct work_struct *work)
-{	
-     	struct pca9554_chip *pchip=container_of(work, struct pca9554_chip,pca9554_work);
-	u8 tempintputreg[PCA9554_PortNum]={0};
-	u8 tempallowint=0;			
-	u8 levelchg=0;			
-	u8 intbit=0;			
-	u8 tempinttype=0;
-	int i,j;
-	struct irq_desc *gpio_irq_desc;
-	unsigned int irq;
-	if(pca9554_read_reg(pchip->client,PCA9554_InputLevel_Reg,&tempintputreg[0])<0)
-	{
-	
-		DBG("**%s[%d] reading reg is error\n",__FUNCTION__,__LINE__); 
-		enable_irq(pchip->irq_chain);
-		return;
-	}
-
-	DBG("**has run at %s,intputreg=%x**\n",__FUNCTION__,tempintputreg[0]);
-	if((pchip->interrupt_en[0]==0))
-	{
-		memcpy(&pchip->reg_input[0],&tempintputreg[0],sizeof(tempintputreg));
-		DBGERR("there are no pin reg irq\n"); 
-		enable_irq(pchip->irq_chain);
-		return;
-	}
-
-	for(i=0;i<PCA9554_PortNum;i++)
-	{
-		tempallowint=pchip->interrupt_en[i]&pchip->reg_direction[i]&(~pchip->interrupt_mask[i]);// 满足中断条件
-		levelchg=pchip->reg_input[i]^tempintputreg[i];// 找出前后状态不一样的pin
-		tempinttype=~(tempintputreg[i]^pchip->inttype[i]);// 找出触发状态和当前pin状态一样的pin，注意只支持low high两种pin触发
-
-	       tempinttype=(~pchip->inttype1[i])&tempinttype;// inttype1 为真的位对应的tempinttype位清零，因为该位只受inttype1控制
- 		tempinttype|=pchip->inttype1[i];//电平只要是变化就产生中断
- 		tempinttype&=pchip->inttype_set[i];//已经设置了type类型
-
-		intbit=tempallowint&levelchg&tempinttype;
-		//DBG(" tempallowint=%x,levelchg=%x,tempinttype=%x,intbit=%d\n",tempallowint,levelchg,tempinttype,intbit);
-
-		if(intbit)
-		for(j=0;j<portnum[i];j++)
-		{
-			if(pca9554getbit(intbit,j))
-			{
-				irq=pchip->gpio_irq_start+PCA9554_PortPinNum*i+j;
-				gpio_irq_desc = irq_to_desc(irq);
-				gpio_irq_desc->chip->mask(irq);
-				generic_handle_irq(irq);
-				gpio_irq_desc->chip->unmask(irq);
-
-			}
-		}
-		
-		pchip->reg_input[i]=tempintputreg[i];
-
-	}
-	enable_irq(pchip->irq_chain);
-	return;
-}
-
-static irqreturn_t pca9554_gpio_irq_handler(int irq, void * dev_id)
-{
-
-	struct irq_desc *gpio_irq_desc = irq_to_desc(irq);
-	struct pca9554_chip *pchip=(struct pca9554_chip *)gpio_irq_desc->chip_data;
-
-	//DBG("**%s**\n",__FUNCTION__);
-	disable_irq_nosync(pchip->irq_chain);
-    	queue_work(pca9554workqueue,&pchip->pca9554_work);
-	return IRQ_HANDLED;
-}
-static void pca9554_gpio_irq_setup(struct pca9554_chip *pchip)
-{
-    unsigned        pioc, irq_num;
-    int ret;
-	struct irq_desc *desc;
-    irq_num = pchip->gpio_irq_start;   //中断号，扩展io的中断号应该紧跟在内部io中断号的后面。如rk内部中断48个，加上内部gpio 16个虚拟中断，这里pin应该从48+16开始
-
-    for (pioc = 0; pioc < pchip->irq_pin_num; pioc++,irq_num++)
-    {
-        lockdep_set_class(&irq_desc[irq_num].lock, &gpio_lock_class);
-	 /*
-         * Can use the "simple" and not "edge" handler since it's
-         * shorter, and the AIC handles interrupts sanely.
-         */
-	set_irq_chip(irq_num, &pca9554_gpio_irqchip);   
-	set_irq_handler(irq_num, handle_simple_irq);
-	set_irq_chip_data(irq_num,(void *)pchip);
-	desc = irq_to_desc(irq_num);
-	//DBG("**%s line=%d,desc=%x,chipdate=%x,pchip=%x,irq_num=%d**\n",__FUNCTION__,__LINE__,desc,desc->chip_data,pchip,irq_num);
-
-	set_irq_flags(irq_num, IRQF_VALID);       
-     }
-	ret=gpio_request(pchip->irq_gpiopin,NULL);
-	if(ret!=0)
-	{
-		gpio_free(pchip->irq_gpiopin);
-		DBG("pca9554_gpio_irq_setup request gpio is err\n");
-	}
-	
-	gpio_pull_updown(pchip->irq_gpiopin, GPIOPullUp);        //gpio 需要拉高irq_to_gpio(pchip->irq_chain)
-
-#if 0
-
-	set_irq_chip_data(pchip->irq_chain, pchip);
-	set_irq_chained_handler(pchip->irq_chain, gpio_irq_handlerxxx);
-	set_irq_type(pchip->irq_chain,IRQ_TYPE_LEVEL_LOW);
-	enable_irq(pchip->irq_chain);
-
-#else
-	pca9554workqueue=create_workqueue("pca9554 workqueue");
-	INIT_WORK(&pchip->pca9554_work,pca9554_extend_gpio_irq_handler);
-	
-	set_irq_chip_data(pchip->irq_chain, pchip);
-	if(request_irq(pchip->irq_chain,pca9554_gpio_irq_handler, IRQF_TRIGGER_LOW, "pca6424", pchip)!=0)
-	{
-		DBG("**%s line=%d is err**\n",__FUNCTION__,__LINE__);
-	}
-
-#endif
-}
-static irqreturn_t pca9554_gpio_irq_handler_test1(int irq, void * dev_id)
-{
-
-	DBG("***************************%s irq=%d***\n",__FUNCTION__,irq);
-	return IRQ_HANDLED;
-}
-static irqreturn_t pca9554_gpio_irq_handler_test2(int irq, void * dev_id)
-{
-	DBG("**************************%s irq=%d***\n",__FUNCTION__,irq);
-	return IRQ_HANDLED;
-}
-
-void pca9554_test(struct pca9554_chip *chip)
-{
-	struct i2c_client *client=chip->client;
- 	int ret;
-	int irq1,irq2;
-
-	
-	
-	
-	ret=gpio_request(RK2818_PIN_PI4,NULL);
-	if(ret!=0)
-		DBG("*gpio_request in %d ret=%d*\n",__LINE__,ret);
-
-	ret=gpio_request(RK2818_PIN_PI5,NULL);
-	if(ret!=0)
-		DBG("*gpio_request in %d ret=%d*\n",__LINE__,ret);
-	ret=gpio_request(RK2818_PIN_PI6,NULL);
-	if(ret!=0)
-		DBG("*gpio_request in %d ret=%d*\n",__LINE__,ret);
-	ret=gpio_request(RK2818_PIN_PI7,NULL);
-	if(ret!=0)
-		DBG("*gpio_request in %d ret=%d*\n",__LINE__,ret);
-	
-	irq1=gpio_to_irq(RK2818_PIN_PI4);
-	request_irq(irq1, pca9554_gpio_irq_handler_test1, IRQF_TRIGGER_LOW,"xxx1", chip);
-	
-	irq2=gpio_to_irq(RK2818_PIN_PI5);
-	request_irq(irq2, pca9554_gpio_irq_handler_test2, IRQF_TRIGGER_HIGH, "xxx2", chip);
-
-	ret=gpio_direction_output(RK2818_PIN_PI6,GPIO_HIGH);
-	ret=gpio_direction_output(RK2818_PIN_PI7,GPIO_LOW);
-
-	
-}
-
-int pca9554_init_pintype(struct pca9554_chip *chip,struct i2c_client *client)
-{
-       	int i;
-	struct pca9554_platform_data *platform_data=(struct pca9554_platform_data *)client->dev.platform_data;
-	struct rk2818_gpio_expander_info *pca9554_gpio_settinginfo;
-	uint8_t reg_output[PCA9554_PortNum]={0};
-	uint8_t reg_direction[PCA9554_PortNum]={0};
-	uint8_t pca9554_pin_num;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum,pca9554_settingpin_num=0;
-
-	if(platform_data)
-	{
-		pca9554_gpio_settinginfo=platform_data->settinginfo;
-		if(pca9554_gpio_settinginfo)
-		{
-			pca9554_settingpin_num=platform_data->settinginfolen;
-			for(i=0;i<pca9554_settingpin_num;i++)
-			{
-				if(!pca9554_checkrange(chip->gpio_start,chip->gpio_pin_num,pca9554_gpio_settinginfo[i].gpio_num))
-				{
-					pca9554_pin_num=pca9554_gpio_settinginfo[i].gpio_num-chip->gpio_start;
-					gpioPortNum = pca9554_pin_num/PCA9554_PortPinNum;
-					gpioPortPinNum= pca9554_pin_num%PCA9554_PortPinNum;
-					//DBG("gpioPortNum=%d,gpioPortNum=%d,pca9554_pin_num=%d,reg_direction=%x,reg_output=%x,reg_input=%x\n",gpioPortNum,gpioPortPinNum,pca9554_pin_num,reg_direction[i],reg_output[i]);
-					if((gpioPortNum>=PCA9554_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-						continue;
-					if(pca9554_gpio_settinginfo[i].pin_type==GPIO_IN)
-						reg_direction[gpioPortNum]=pca9554setbit(reg_direction[gpioPortNum],gpioPortPinNum);
-					else
-					{
-						if(pca9554_gpio_settinginfo[i].pin_value==GPIO_HIGH)
-						reg_output[gpioPortNum]=pca9554setbit(reg_output[gpioPortNum],gpioPortPinNum);
-					}
-				
-
-				}
-			}
-		}
-	}
-	#ifdef PCA9554_OUTREGLOCK
-	mutex_init(&chip->outreglock);
-       #endif 
-	#ifdef PCA9554_INPUTREGLOCK
-	mutex_init(&chip->inputreglock);
-	#endif
-	#ifdef PCA9554_OUTREGLOCK
-	mutex_init(&chip->configreglock);
-	#endif
-
-	for(i=0; i<PCA9554_PortNum; i++)
-	{
-	
-		if (pca9554_write_reg(client, PCA9554_Config_Reg, reg_direction[i])<0)
-		{
-			DBGERR("*%s %d* write reg err\n",__FUNCTION__,__LINE__);
-			return -1;
-		}
-		chip->reg_direction[i]=reg_direction[i];
-		if (pca9554_write_reg(client, PCA9554_OutputLevel_Reg, reg_output[i])<0)
-		{
-			DBGERR("*%s %d  write reg err*\n",__FUNCTION__,__LINE__);
-			return -1;
-		}
-		chip->reg_output[i]=reg_output[i];
-		
-		if(pca9554_read_reg(client, PCA9554_InputLevel_Reg, &chip->reg_input[i])<0)
-		{
-			DBGERR("*%s %d  read reg err*\n",__FUNCTION__,__LINE__);
-			return -1;
-		}	  
-		//DBG("reg_direction=%x,reg_output=%x,reg_input=%x\n",chip->reg_direction[i],chip->reg_output[i],chip->reg_input[i]);
-
-	}
-
-	return 0;
-}
-static int __devinit pca9554_probe(struct i2c_client *client,const struct i2c_device_id *id)
-{
-	struct pca9554_chip *chip;
-	struct pca9554_platform_data  *pdata;
-	int ret;
-
-	DBG("**gpio %s in %d line,dev adr is %x**\n",__FUNCTION__,__LINE__,client->addr);
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
-		return -EIO;
-
-	chip = kzalloc(sizeof(struct pca9554_chip), GFP_KERNEL);
-	if (chip == NULL)
-		return -ENOMEM;
-	pdata = client->dev.platform_data;
-	if (pdata == NULL) {
-		DBGERR(" %s no platform data\n",__FUNCTION__);
-		ret = -EINVAL;
-		goto out_failed;
-	}
-	
-	chip->gpio_start = pdata->gpio_base;
-	chip->gpio_irq_start =pdata->gpio_irq_start;
-	chip->gpio_pin_num=pdata->gpio_pin_num;
-	chip->irq_pin_num = pdata->irq_pin_num;
-	chip->irq_gpiopin=pdata->pca9954_irq_pin;
-	chip->irq_chain = gpio_to_irq(pdata->pca9954_irq_pin);
-	chip->names =pdata->names;
-	
-	//DBG("**%s in %d start=%d,irq_start=%d,pin_num=%d,irq_pin_num=%d,irq_gpiopin=%d,irq_chain=%d,**\n",
-	//	__FUNCTION__,__LINE__,chip->gpio_start,chip->gpio_irq_start,chip->gpio_pin_num,chip->irq_pin_num,chip->irq_gpiopin
-	//	,chip->irq_chain);
-
-	/* initialize cached registers from their original values.
-	* we can't share this chip with another i2c master.
-	*/
-	pca9554_setup_gpio(chip, id->driver_data);
-
-	ret = gpiochip_add(&chip->gpio_chip);
-	if (ret)
-	goto out_failed;
-	
-	if(pca9554_init_pintype(chip,client))
-		goto out_failed;
-
-	if (pdata->setup) {
-		ret = pdata->setup(client, chip->gpio_chip.base,
-				chip->gpio_chip.ngpio, pdata->context);
-		if (ret < 0)
-			DBGERR(" %s setup failed, %d\n",__FUNCTION__,ret);
-	}
-
-	
-	pca9554_gpio_irq_setup(chip);
-
-	i2c_set_clientdata(client, chip);
-
-	
-
-	chip->client = client;
-
-	//pca9554_test(chip);
-
-	return 0;
-
-	out_failed:
-
-	kfree(chip);
-    return 0;
-}
-
-static int pca9554_remove(struct i2c_client *client)
-{
-	struct pca9554_platform_data *pdata = client->dev.platform_data;
-	struct pca9554_chip *chip = i2c_get_clientdata(client);
-	int ret = 0;
-
-	if (pdata->teardown) {
-		ret = pdata->teardown(client, chip->gpio_chip.base,
-		chip->gpio_chip.ngpio, pdata->context);
-		if (ret < 0) {
-			DBGERR(" %s failed, %d\n",__FUNCTION__,ret);
-			return ret;
-		}
-	}
-
-	ret = gpiochip_remove(&chip->gpio_chip);
-	if (ret) {
-		dev_err(&client->dev, "%s failed, %d\n",
-		"gpiochip_remove()", ret);
-		return ret;
-	}
-	kfree(chip);
-	return 0;
-}
-
-static struct i2c_driver pca9554_driver = {
-    .driver = {
-		  .owner  = THIS_MODULE,
-        .name   = "extend_gpio_pca9554",
-    },
-    .probe      = pca9554_probe,
-    .remove     = pca9554_remove,
-    .id_table   = pca9554_id,
-};
-
-static int __init pca9554_init(void)
-{
-	DBG("**pca9554_init**\n");
-	return i2c_add_driver(&pca9554_driver);
-}
-static void __exit pca9554_exit(void)
-{
-    	i2c_del_driver(&pca9554_driver);
-}
-
-module_init(pca9554_init);
-module_exit(pca9554_exit);
-MODULE_AUTHOR(" XXX  XXX@rock-chips.com");
-MODULE_DESCRIPTION("Driver for rk2818 extend gpio device");
-MODULE_LICENSE("GPL");
-
-
diff --git a/drivers/gpio/tca6424.c b/drivers/gpio/tca6424.c
deleted file mode 100755
index 06e2ab9843db..000000000000
--- a/drivers/gpio/tca6424.c
+++ /dev/null
@@ -1,620 +0,0 @@
-/*
- * Copyright (C) 2010 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-/*******************************************************************/
-/*	  COPYRIGHT (C)  ROCK-CHIPS FUZHOU . ALL RIGHTS RESERVED.*/
-/*******************************************************************
-FILE			:	tca6424.c
-MODIFY		:	sxj
-DATE		:	2010-8-11
-NOTES		:
-********************************************************************/
-#include <asm/mach/time.h>
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <asm/mach-types.h>
-#include <linux/irq.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <mach/rk2818_iomap.h>
-#include <mach/iomux.h>
-#include <linux/device.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-#include <mach/board.h>
-#include <linux/delay.h>
-#include <linux/i2c/tca6424.h>
-#include <linux/ktime.h>
-#include "../drivers/gpio/expand_gpio_soft_interrupt.h"
-
-#if 0
-#define DBG(x...)	printk(KERN_INFO x)
-#else
-#define DBG(x...)
-#endif
-#define DBGERR(x...)	printk(KERN_INFO x)
-
-
-struct tca6424_chip {
-	
-	unsigned int gpio_start;
-	unsigned int gpio_pin_num;
-
-	#ifdef TCA6424_OUTREGLOCK
-		struct mutex outreglock;
-	#endif
-	#ifdef TCA6424_INPUTREGLOCK
-		struct mutex inputreglock;
-	#endif
-	#ifdef TCA6424_CONFIGREGLOCK
-		struct mutex configreglock;
-	#endif
-
-	struct i2c_client *client;
-	struct expand_gpio_soft_int *expand;
-	struct expand_gpio_global_variable gtca6424_struct;
-	struct gpio_chip gpio_chip;
-	char **names;
-};
-
-static const struct i2c_device_id tca6424_id[] = 
-{
-    {"extend_gpio_tca6424",8,}, 
-    { }
-};
-MODULE_DEVICE_TABLE(i2c, tca6424_id);
-
-static short int portnum[TCA6424_PortNum]={ TCA6424_Port0PinNum,
-                                            TCA6424_Port1PinNum,TCA6424_Port2PinNum};
-
-extern inline struct gpio_chip *gpio_to_chip(unsigned gpio);
-
-int tca6424_irq_read_inputreg(void *data,char *buf)
-{
-
-	struct tca6424_chip *tca6424data=(struct tca6424_chip *)data;
-	int ret = -1;
-	ret = i2c_master_reg8_recv(tca6424data->client, TCA6424_Auto_InputLevel_Reg, buf, 3, TCA6424_I2C_RATE);
-	return (ret>0)?0:ret;
-}
-
-static int tca6424_write_reg(struct i2c_client *client, uint8_t reg, uint8_t val)
-{
-	int ret=-1;
-	struct i2c_adapter *adap;
-	struct i2c_msg msg;
-	char tx_buf[2];
-	if(!client)
-		return ret;    
-	adap = client->adapter;		
-	tx_buf[0] = reg;
-	tx_buf[1]= val;
-
-	msg.addr = client->addr;
-	msg.buf = tx_buf;
-	msg.len = 1 +1;
-	msg.flags = client->flags;   
-	msg.scl_rate = TCA6424_I2C_RATE;
-	ret = i2c_transfer(adap, &msg, 1);
-	return ret;  
-}
-
-static int tca6424_read_reg(struct i2c_client *client, uint8_t reg, uint8_t *val)
-{
-  	int ret=-1;
-    struct i2c_adapter *adap;
-    struct i2c_msg msgs[2];
-	
-    if(!client)
-		return ret;    
-    adap = client->adapter;		
-    //发送寄存器地址
-    msgs[0].addr = client->addr;
-    msgs[0].buf = &reg;
-    msgs[0].flags = client->flags;
-    msgs[0].len = 1;
-    msgs[0].scl_rate = TCA6424_I2C_RATE;
-    //接收数据
-    msgs[1].buf = val;
-    msgs[1].addr = client->addr;
-    msgs[1].flags = client->flags | I2C_M_RD;
-    msgs[1].len = 1;
-    msgs[1].scl_rate = TCA6424_I2C_RATE;
-
-    ret = i2c_transfer(adap, msgs, 2);
-    return ret;   
-
-}
-
-static int tca6424_write_three_reg(struct i2c_client *client, const char reg, const char *buf, int count, int rate)
-{
-	int ret = -1;
-	ret = i2c_master_reg8_send(client, reg, buf, count, rate);
-	return (ret>0)?0:ret;
-}
-
-static int tca6424_read_three_reg(struct i2c_client *client, const char reg, char *buf, int count, int rate)
-{
-	int ret = -1;
-	ret = i2c_master_reg8_recv(client, reg, buf, count, rate);
-	return (ret>0)?0:ret;
-}
-
-static int tca6424_gpio_direction_input(struct gpio_chip *gc, unsigned pin_num)
-{
-	struct tca6424_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t reg_val; 
-	uint8_t Regaddr;
-	int ret = -1;
-	
-	chip = container_of(gc, struct tca6424_chip, gpio_chip);
-	gpioPortNum = pin_num/8;
-	gpioPortPinNum= pin_num%8;
-	if((gpioPortNum>=TCA6424_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return ret;
-	Regaddr = TCA6424_Config_Reg+gpioPortNum;	
-	
-	#ifdef TCA6424_CONFIGREGLOCK
-	if (!mutex_trylock(&chip->configreglock))
-	{
-		DBGERR("**%s[%d]Did not get the configreglock**\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	#endif
-
-	if(((chip->gtca6424_struct.reg_direction[gpioPortNum]>>gpioPortPinNum)& 0x01)==EXTGPIO_OUTPUT)
-	{
-		reg_val = tca6424setbit(chip->gtca6424_struct.reg_direction[gpioPortNum], gpioPortPinNum);
-		ret = tca6424_write_reg(chip->client, Regaddr, reg_val);
-		if(ret<0)
-			goto err;
-		chip->gtca6424_struct.reg_direction[gpioPortNum] = reg_val;
-		//DBG("**%s[%d],set config address[0x%2x]=%2x,ret=%d**\n",__FUNCTION__,__LINE__,Regaddr,reg_val,ret);	
-	}
-err:
-	#ifdef TCA6424_CONFIGREGLOCK
-		mutex_unlock(&chip->configreglock);
-	#endif
-	return (ret<0)?-1:0;
-}
-
-static int tca6424_gpio_direction_output(struct gpio_chip *gc, unsigned pin_num, int val)
-{
-	struct tca6424_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;    
-	uint8_t reg_val = 0;
-	uint8_t Regaddr = 0;
-	int ret = -1;
-	
-	chip = container_of(gc, struct tca6424_chip, gpio_chip);
-	gpioPortNum = pin_num/8;
-	gpioPortPinNum = pin_num%8;
-	if((gpioPortNum>=TCA6424_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return ret;
-	Regaddr = TCA6424_Config_Reg+gpioPortNum;	
-
-	#ifdef TCA6424_CONFIGREGLOCK
-	if (!mutex_trylock(&chip->configreglock))
-	{
-		DBGERR("**%s[%d]Did not get the configreglock**\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	#endif
-
-	if(((chip->gtca6424_struct.reg_direction[gpioPortNum]>>gpioPortPinNum)& 0x01)==EXTGPIO_INPUT)
-	{
-		reg_val = tca6424clearbit(chip->gtca6424_struct.reg_direction[gpioPortNum], gpioPortPinNum);
-		//DBG("**%s[%d],set config address[0x%2x]=%2x,**\n",__FUNCTION__,__LINE__,Regaddr,reg_val);	
-		ret = tca6424_write_reg(chip->client, Regaddr, reg_val);
-		if(ret<0)
-		{
-			#ifdef TCA6424_CONFIGREGLOCK
-			mutex_unlock(&chip->configreglock);
-			#endif
-			DBGERR("**%s[%d] set direction reg is error,reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-    		return ret;
-		}
-		chip->gtca6424_struct.reg_direction[gpioPortNum] = reg_val;
-	}
-	
-	#ifdef TCA6424_CONFIGREGLOCK
-	mutex_unlock(&chip->configreglock);
-	#endif
-    	
-	ret = -1;
-    #ifdef TCA6424_OUTREGLOCK
-	if (!mutex_trylock(&chip->outreglock))
-	{
-		DBGERR("**%s[%d] Did not get the outreglock**\n",__FUNCTION__,__LINE__);
-		return ret;
-	}
-	#endif
-
-	if(((chip->gtca6424_struct.reg_output[gpioPortNum]>>gpioPortPinNum)& 0x01) != val)
-	{
-		if (val)
-			reg_val = tca6424setbit(chip->gtca6424_struct.reg_output[gpioPortNum], gpioPortPinNum);
-		else
-			reg_val = tca6424clearbit(chip->gtca6424_struct.reg_output[gpioPortNum], gpioPortPinNum);
-
-		Regaddr = TCA6424_OutputLevel_Reg+gpioPortNum;	
-		ret = tca6424_write_reg(chip->client, Regaddr, reg_val);
-		if (ret<0)
-		{
-			#ifdef TCA6424_OUTREGLOCK
-				mutex_unlock(&chip->outreglock);
-			#endif
-			DBGERR("**%s[%d] set out reg is error,reg_val=%x,ret=%d**\n",__FUNCTION__,__LINE__,reg_val,ret);
-			return ret;
-		}
-		chip->gtca6424_struct.reg_output[gpioPortNum] = reg_val;
-	}
-
-	#ifdef TCA6424_OUTREGLOCK
-		mutex_unlock(&chip->outreglock);
-	#endif
-	//DBG("**%s[%d],set output address[0x%2x]=%2x,ret=%d**\n",__FUNCTION__,__LINE__,Regaddr,reg_val,ret);	
-    return (ret<0)?-1:0;
-}
-
-static int tca6424_gpio_get_value(struct gpio_chip *gc, unsigned pin_num)
-{
-	struct tca6424_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t Regaddr;
-	int ret;
-
-	chip = container_of(gc, struct tca6424_chip, gpio_chip);
-
-	#ifdef CONFIG_EXPAND_GPIO_SOFT_INTERRUPT
-	ret = wait_untill_input_reg_flash( );
-	if(ret<0)
-	{
-		return -1;
-		DBGERR("**********tca6424 get value error***************\n");
-	}
-	#endif
-	
-	gpioPortNum = pin_num/8;
-	gpioPortPinNum= pin_num%8;
-	Regaddr = TCA6424_OutputLevel_Reg+gpioPortNum;	
-	
-	if((gpioPortNum>=TCA6424_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return -1;
-
-	#ifndef CONFIG_EXPAND_GPIO_SOFT_INTERRUPT
-	uint8_t reg_val;
-	ret = tca6424_read_reg(chip->client, Regaddr, &reg_val);
-	if (ret < 0) 
-		return -1;
-	chip->gtca6424_struct.reg_input[gpioPortNum] = reg_val;
-	#endif
-
-	//DBG("**%s[%d] read input address[0x%2x]=%2x**\n",__FUNCTION__,__LINE__,Regaddr,chip->reg_input[gpioPortNum]);
-	return ((chip->gtca6424_struct.reg_input[gpioPortNum] >> gpioPortPinNum) & 0x01);
-}
-
-static void tca6424_gpio_set_value(struct gpio_chip *gc, unsigned pin_num, int val)
-{
-	struct tca6424_chip *chip;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum;
-	uint8_t reg_val;
-	uint8_t Regaddr;
-	int ret=-1;
-	
-	chip = container_of(gc, struct tca6424_chip, gpio_chip);
-	gpioPortNum = pin_num/8;
-	gpioPortPinNum= pin_num%8;
-	if((gpioPortNum>=TCA6424_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-		return;
-	Regaddr = TCA6424_OutputLevel_Reg+gpioPortNum;	
-	if(tca6424getbit(chip->gtca6424_struct.reg_direction[gpioPortNum],gpioPortPinNum)) // input state
-	{
-		return;
-	}
-		
-	#ifdef TCA6424_OUTREGLOCK
-	if (!mutex_trylock(&chip->outreglock))
-	{
-		DBGERR("**%s[%d] Did not get the outreglock**\n",__FUNCTION__,__LINE__);
-		return;
-	}
-	#endif
-	if(((chip->gtca6424_struct.reg_output[gpioPortNum]>>gpioPortPinNum)& 0x01) != val)
-	{
-		if(val)
-			reg_val = tca6424setbit(chip->gtca6424_struct.reg_output[gpioPortNum], gpioPortPinNum);
-		else
-			reg_val = tca6424clearbit(chip->gtca6424_struct.reg_output[gpioPortNum], gpioPortPinNum);
-
-		ret = tca6424_write_reg(chip->client, Regaddr, reg_val);
-		if (ret<0)
-			goto err;
-		chip->gtca6424_struct.reg_output[gpioPortNum] = reg_val;
-		//DBG("**%s[%d],set output address[0x%2x]=%2x,ret=%d**\n",__FUNCTION__,__LINE__,Regaddr,reg_val,ret);
-	}
-err: 
-	#ifdef TCA6424_OUTREGLOCK
-		mutex_unlock(&chip->outreglock);
-	#endif
-	return;
-}
-
-int tca6424_checkrange(int start,int num,int val)
-{   
-	if((val<(start+num))&&(val>=start))
-		return 0;
-	else 
-		return -1;
-}
-
-static int tca6424_gpio_to_irq(struct gpio_chip *chip,unsigned offset)
-{
-    struct tca6424_chip *pchip = container_of(chip, struct tca6424_chip, gpio_chip);
-	if(((pchip->gpio_start+offset)>=chip->base)&&((pchip->gpio_start+offset)<(chip->base+chip->ngpio)))
-	{
-  		//DBG("**%s,offset=%d,gpio_irq_start=%d,base=%d,ngpio=%d,gpio_irq_start=%d**\n",
-		//	__FUNCTION__,offset,pchip->expand->gpio_irq_start,chip->base,chip->ngpio,pchip->expand->gpio_irq_start);
-		return (offset+pchip->expand->gpio_irq_start);
-	}
-	else
-	{
-		return -1;
-	}
-}
-
-static void tca6424_setup_gpio(struct tca6424_chip *chip, int gpios)
-{
-    struct gpio_chip *gc;
-    gc = &chip->gpio_chip;
-    gc->direction_input  = tca6424_gpio_direction_input;
-    gc->direction_output = tca6424_gpio_direction_output;
-    gc->get = tca6424_gpio_get_value;
-    gc->set = tca6424_gpio_set_value;
-    gc->to_irq = tca6424_gpio_to_irq;
-    gc->can_sleep = 1;
-    gc->base = chip->gpio_start;
-    gc->ngpio = chip->gpio_pin_num;
-    gc->label = chip->client->name;
-    gc->dev = &chip->client->dev;
-    gc->owner = THIS_MODULE;
-    gc->names = chip->names;
-}
-
-int tca6424_init_pintype(struct tca6424_chip *chip,struct i2c_client *client)
-{
-	struct tca6424_platform_data *platform_data=(struct tca6424_platform_data *)client->dev.platform_data;
-	struct rk2818_gpio_expander_info *tca6424_gpio_settinginfo;
-	uint8_t reg_output[TCA6424_PortNum]={0,0,0};
-	uint8_t reg_direction[TCA6424_PortNum]={0,0,0};
-	uint8_t reg_invert[TCA6424_PortNum]={0,0,0};
-	uint8_t tca6424_pin_num;
-	uint8_t gpioPortNum;
-	uint8_t gpioPortPinNum,tca6424_settingpin_num=0;
-	int i = 0;
-	if(platform_data)
-	{
-		tca6424_gpio_settinginfo=platform_data->settinginfo;
-		if(tca6424_gpio_settinginfo)
-		{
-			tca6424_settingpin_num=platform_data->settinginfolen;
-			for(i=0;i<tca6424_settingpin_num;i++)
-			{
-				if(!tca6424_checkrange(chip->gpio_start,chip->gpio_pin_num,tca6424_gpio_settinginfo[i].gpio_num))
-				{
-					tca6424_pin_num=tca6424_gpio_settinginfo[i].gpio_num-chip->gpio_start;
-					gpioPortNum = tca6424_pin_num/ TCA6424_PortPinNum;
-					gpioPortPinNum= tca6424_pin_num% TCA6424_PortPinNum;
-					//DBG("gpioPortNum=%d,gpioPortNum=%d,tca6424_pin_num=%d,reg_direction=%x,reg_output=%x,reg_input=%x\n",gpioPortNum,gpioPortPinNum,tca6424_pin_num,reg_direction[i],reg_output[i]);
-					if((gpioPortNum>=TCA6424_PortNum)||(gpioPortPinNum>=portnum[gpioPortNum]))
-						continue;
-					if(tca6424_gpio_settinginfo[i].pin_type==GPIO_IN)
-					{
-						reg_direction[gpioPortNum]=tca6424setbit(reg_direction[gpioPortNum],gpioPortPinNum);
-					}
-					else
-					{
-						if(tca6424_gpio_settinginfo[i].pin_value==GPIO_HIGH)
-						{
-							reg_output[gpioPortNum]=tca6424setbit(reg_output[gpioPortNum],gpioPortPinNum);
-						}
-					}
-					
-				}
-			}
-		}
-	}
-	#ifdef TCA6424_OUTREGLOCK
-	mutex_init(&chip->outreglock);
-    #endif 
-	#ifdef TCA6424_INPUTREGLOCK
-	mutex_init(&chip->inputreglock);
-	#endif
-	#ifdef TCA6424_OUTREGLOCK
-	mutex_init(&chip->configreglock);
-	#endif
-
-	if(tca6424_write_three_reg(client, TCA6424_Auto_Config_Reg , &reg_direction[0], 3, TCA6424_I2C_RATE)<0)
-	{
-		DBGERR("*%s %d* write reg err\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	if (tca6424_write_three_reg(client, TCA6424_Auto_OutputLevel_Reg, &reg_output[0], 3, TCA6424_I2C_RATE)<0)
-	{
-		DBGERR("*%s %d* write reg err\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	if (tca6424_write_three_reg(client, TCA6424_Auto_Invert_Reg, &reg_invert[0], 3, TCA6424_I2C_RATE)<0)		//make sure this reg be 0
-	{
-		DBGERR("*%s %d* write reg err\n",__FUNCTION__,__LINE__);
-		return -1;
-	}
-	if(tca6424_read_three_reg(client, TCA6424_Auto_InputLevel_Reg, &chip->gtca6424_struct.reg_input[0], 3, TCA6424_I2C_RATE)<0)
-	{
-		DBGERR("*%s %d  read reg err*\n",__FUNCTION__,__LINE__);
-		return -1;
-	}	  
-	for(i=0; i<TCA6424_PortNum; i++)
-	{
-		chip->gtca6424_struct.reg_direction[i]=reg_direction[i];
-		chip->gtca6424_struct.reg_output[i]=reg_output[i];
-		DBG("reg_direction=%x,reg_output=%x,reg_input=%x\n",chip->gtca6424_struct.reg_direction[i],chip->gtca6424_struct.reg_output[i],chip->gtca6424_struct.reg_input[i]);
-	}
-	return 0;
-}
-
-static int __devinit tca6424_probe(struct i2c_client *client,const struct i2c_device_id *id)
-{
-	struct tca6424_chip *chip;
-	struct tca6424_platform_data  *pdata;
-	int ret;
-	DBG(KERN_ALERT"*******gpio %s in %d line,dev adr is %x**\n",__FUNCTION__,__LINE__,client->addr);
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
-		return -EIO;
-
-	chip = kzalloc(sizeof(struct tca6424_chip), GFP_KERNEL);
-	if (chip == NULL)
-		return -ENOMEM;
-	pdata = client->dev.platform_data;
-	if (pdata == NULL) {
-		DBGERR(" %s no platform data\n",__FUNCTION__);
-		ret = -EINVAL;
-		goto out_failed;
-	}
-	//used by old tca6424,it will remove later
-	client->adapter->dev.platform_data = pdata;
-	
-	chip->gpio_start = pdata->gpio_base;
-	chip->gpio_pin_num=pdata->gpio_pin_num;
-	chip->client = client;
-	chip->names = pdata->names;
-
-	#ifdef CONFIG_EXPAND_GPIO_SOFT_INTERRUPT
-	chip->expand = &expand_irq_data;
-	chip->expand->gpio_irq_start =pdata->gpio_irq_start;
-	chip->expand->irq_pin_num = pdata->irq_pin_num;
-	chip->expand->irq_gpiopin=pdata->tca6424_irq_pin;
-	chip->expand->irq_chain = gpio_to_irq(pdata->tca6424_irq_pin);
-	chip->expand->expand_port_group   = pdata->expand_port_group;
-	chip->expand->expand_port_pinnum = pdata->expand_port_pinnum;
-	chip->expand->rk_irq_mode =  pdata->rk_irq_mode;
-	chip->expand->rk_irq_gpio_pull_up_down = pdata->rk_irq_gpio_pull_up_down;
-	#endif
-	
-	/* initialize cached registers from their original values.
-	* we can't share this chip with another i2c master.
-	*/
-	tca6424_setup_gpio(chip, id->driver_data);
-	ret = gpiochip_add(&chip->gpio_chip);
-	if (ret)
-		goto out_failed;
-	if(tca6424_init_pintype(chip,client))
-		goto out_failed;
-	if (pdata->setup) {
-		ret = pdata->setup(client, chip->gpio_chip.base,
-				chip->gpio_chip.ngpio, pdata->context);
-		if (ret < 0)
-			DBGERR(" %s setup failed, %d\n",__FUNCTION__,ret);
-	}
-	i2c_set_clientdata(client, chip);
-
-	#ifdef CONFIG_EXPAND_GPIO_SOFT_INTERRUPT
-	expand_irq_init(chip,&chip->gtca6424_struct,tca6424_irq_read_inputreg);
-	#endif
-	return 0;
-out_failed:
-	kfree(chip);
-    return 0;
-}
-
-static int tca6424_remove(struct i2c_client *client)
-{
-	struct tca6424_platform_data *pdata = client->dev.platform_data;
-	struct tca6424_chip *chip = i2c_get_clientdata(client);
-	int ret = 0;
-
-	if (pdata->teardown) {
-		ret = pdata->teardown(client, chip->gpio_chip.base,
-		chip->gpio_chip.ngpio, pdata->context);
-		if (ret < 0) {
-			DBGERR(" %s failed, %d\n",__FUNCTION__,ret);
-			return ret;
-		}
-	}
-
-	ret = gpiochip_remove(&chip->gpio_chip);
-	if (ret) {
-		dev_err(&client->dev, "%s failed, %d\n",
-		"gpiochip_remove()", ret);
-		return ret;
-	}
-	kfree(chip);
-	return 0;
-}
-
-static int tca6424_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	DBG("*****************tca6424 suspend*******************");
-	return 0;
-}
-
-static int tca6424_resume(struct i2c_client *client)
-{
-	DBG("*****************tca6424 resume*******************");
-	return 0;
-}
-
-static struct i2c_driver tca6424_driver = {
-    .driver = {
-		.owner  = THIS_MODULE,
-        .name   = "extend_gpio_tca6424",
-    },
-    .probe      = tca6424_probe,
-    .remove     = tca6424_remove,
-    .id_table   = tca6424_id,
-    .resume = tca6424_resume,
-    .suspend = tca6424_suspend,
-};
-static int __init tca6424_init(void)
-{
-	int tmp;
-	DBG(KERN_ALERT"**********tca6424_init**********\n");
-	tmp=i2c_add_driver(&tca6424_driver);
-	return 0;
-}
-subsys_initcall(tca6424_init);
-
-static void __exit tca6424_exit(void)
-{
-    DBG(KERN_ALERT"**********tca6424_exit**********\n");
-	i2c_del_driver(&tca6424_driver);
-}
-module_exit(tca6424_exit);
-
-MODULE_AUTHOR(" XXX  XXX@rock-chips.com");
-MODULE_DESCRIPTION("Driver for rk2818 tca6424 device");
-MODULE_LICENSE("GPL");
-
diff --git a/include/linux/i2c/tca6424.h b/include/linux/i2c/tca6424.h
deleted file mode 100755
index 6ea4ef9a0db3..000000000000
--- a/include/linux/i2c/tca6424.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/******************************************************************/
-/*   Copyright (C) 2008 ROCK-CHIPS FUZHOU . All Rights Reserved.  */
-/*******************************************************************
-File    :  gpio.h
-Desc    :  定义gpio的寄存器结构体\寄存器位的宏定义\接口函数
-
-Author  : 
-Date    : 2008-11-20
-Modified:
-Revision:           1.00
-$Log: gpio.h,v $
-*********************************************************************/
-#ifndef _DRIVER_TCA6424_GPIO_H_
-#define _DRIVER_TCA6424_GPIO_H_
-
-#define TCA6424_PortNum 	3
-#define TCA6424_PortPinNum 	8
-#define TCA6424_Port0PinNum 8
-#define TCA6424_Port1PinNum 8
-#define TCA6424_Port2PinNum 8
-#define EXTGPIO_OUTPUT 	0
-#define EXTGPIO_INPUT	1
-
-#define TCA6424_TotalPortPinNum (TCA6424_Port0PinNum+TCA6424_Port1PinNum+TCA6424_Port2PinNum)
-
-#define TCA6424_InputLevel_Reg 	0x0   	//r only
-#define TCA6424_OutputLevel_Reg 0x4 	// r/w  default ffff
-#define TCA6424_Invert_Reg 		0x8  	// r/w  default 0
-#define TCA6424_Config_Reg 		0x0c 	// r/w  default ffff
-
-
-#define TCA6424_Auto_InputLevel_Reg 	0x80  
-#define TCA6424_Auto_OutputLevel_Reg 	0x84
-#define TCA6424_Auto_Invert_Reg 		0x88
-#define TCA6424_Auto_Config_Reg 		0x8c
-
-#define TCA6424_OUTREGLOCK
-#define TCA6424_INPUTREGLOCK
-#define TCA6424_CONFIGREGLOCK
-
-#define tca6424getbit(a,num) (((a)>>(num))&0x01)
-#define tca6424setbit(a,num) ((a)|(0x01<<(num)))
-#define tca6424clearbit(a,num) ((a)&(~(0x01<<(num))))
-
-#define TCA6424_I2C_RATE 400*1000
-
-#endif
-- 
2.35.3

