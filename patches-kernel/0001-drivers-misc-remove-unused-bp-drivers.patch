From a742ea8f7b9bb0a1191d30686d3cb39a163a73d2 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Sat, 3 Nov 2018 12:46:43 +0800
Subject: [PATCH] drivers/misc: remove unused bp drivers

Change-Id: I5a38a82e9d64d84e98935376f76591ed00d8e2f8
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/misc/bp/Kconfig         |   9 -
 drivers/misc/bp/Makefile        |   4 -
 drivers/misc/bp/bp-auto.c       | 661 --------------------------------
 drivers/misc/bp/chips/Kconfig   |  32 --
 drivers/misc/bp/chips/Makefile  |  15 -
 drivers/misc/bp/chips/a85xx.c   | 293 --------------
 drivers/misc/bp/chips/aw706.c   | 326 ----------------
 drivers/misc/bp/chips/c66a.c    | 268 -------------
 drivers/misc/bp/chips/e1230s.c  | 265 -------------
 drivers/misc/bp/chips/m51.c     | 306 ---------------
 drivers/misc/bp/chips/mi700.c   | 280 --------------
 drivers/misc/bp/chips/mt6229.c  | 304 ---------------
 drivers/misc/bp/chips/mtk6250.c | 290 --------------
 drivers/misc/bp/chips/mu509.c   | 339 ----------------
 drivers/misc/bp/chips/mw100.c   | 299 ---------------
 drivers/misc/bp/chips/sc6610.c  | 266 -------------
 drivers/misc/bp/chips/sew290.c  | 318 ---------------
 drivers/misc/bp/chips/u5501.c   | 349 -----------------
 drivers/misc/bp/chips/u7501.c   | 321 ----------------
 include/linux/bp-auto.h         | 148 -------
 20 files changed, 5093 deletions(-)
 delete mode 100644 drivers/misc/bp/Kconfig
 delete mode 100644 drivers/misc/bp/Makefile
 delete mode 100644 drivers/misc/bp/bp-auto.c
 delete mode 100644 drivers/misc/bp/chips/Kconfig
 delete mode 100644 drivers/misc/bp/chips/Makefile
 delete mode 100755 drivers/misc/bp/chips/a85xx.c
 delete mode 100755 drivers/misc/bp/chips/aw706.c
 delete mode 100644 drivers/misc/bp/chips/c66a.c
 delete mode 100755 drivers/misc/bp/chips/e1230s.c
 delete mode 100755 drivers/misc/bp/chips/m51.c
 delete mode 100755 drivers/misc/bp/chips/mi700.c
 delete mode 100755 drivers/misc/bp/chips/mt6229.c
 delete mode 100644 drivers/misc/bp/chips/mtk6250.c
 delete mode 100755 drivers/misc/bp/chips/mu509.c
 delete mode 100755 drivers/misc/bp/chips/mw100.c
 delete mode 100755 drivers/misc/bp/chips/sc6610.c
 delete mode 100644 drivers/misc/bp/chips/sew290.c
 delete mode 100755 drivers/misc/bp/chips/u5501.c
 delete mode 100644 drivers/misc/bp/chips/u7501.c
 delete mode 100644 include/linux/bp-auto.h

diff --git a/drivers/misc/bp/Kconfig b/drivers/misc/bp/Kconfig
deleted file mode 100644
index 1443491cbc30..000000000000
--- a/drivers/misc/bp/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# all auto modem control drivers configuration
-#
-
-config BP_AUTO
-	bool "voice modem support"
-	default n	
-
diff --git a/drivers/misc/bp/Makefile b/drivers/misc/bp/Makefile
deleted file mode 100644
index 5afb298e7fa1..000000000000
--- a/drivers/misc/bp/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-# auto modem control drivers
-obj-$(CONFIG_BP_AUTO)			+= chips/
-obj-$(CONFIG_BP_AUTO)			+= bp-auto.o
\ No newline at end of file
diff --git a/drivers/misc/bp/bp-auto.c b/drivers/misc/bp/bp-auto.c
deleted file mode 100644
index 94894c96f9e9..000000000000
--- a/drivers/misc/bp/bp-auto.c
+++ /dev/null
@@ -1,661 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-#include "../../mtd/rknand/api_flash.h"
-
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-struct bp_private_data *g_bp;
-static struct class *g_bp_class;
-static struct bp_operate *g_bp_ops[BP_ID_NUM]; 
-struct class *bp_class = NULL; 
-int get_current_bp_id(){
-	return g_bp->ops->bp_id;
-}
-static void ap_wakeup_bp(struct bp_private_data *bp, int wake)
-{
-	if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, wake);	
-	
-}
-
-static int bp_request_gpio(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->pdata->gpio_valid)
-	{
-		if(bp->pdata->bp_power > 0)
-		{
-			bp->ops->bp_power = bp->pdata->bp_power;
-		}
-
-		if(bp->pdata->bp_en > 0)
-		{
-			bp->ops->bp_en = bp->pdata->bp_en;
-		}
-
-		if(bp->pdata->bp_reset > 0)
-		{
-			bp->ops->bp_reset = bp->pdata->bp_reset;
-		}
-
-		if(bp->pdata->ap_ready > 0)
-		{
-			bp->ops->ap_ready = bp->pdata->ap_ready;
-		}
-
-		if(bp->pdata->bp_ready > 0)
-		{
-			bp->ops->bp_ready = bp->pdata->bp_ready;
-		}
-
-		if(bp->pdata->ap_wakeup_bp > 0)
-		{
-			bp->ops->ap_wakeup_bp = bp->pdata->ap_wakeup_bp;
-		}
-
-		if(bp->pdata->bp_wakeup_ap > 0)
-		{
-			bp->ops->bp_wakeup_ap = bp->pdata->bp_wakeup_ap;
-		}
-
-		if(bp->pdata->bp_usb_en > 0)
-		{
-			bp->ops->bp_usb_en = bp->pdata->bp_usb_en;
-		}
-		
-		if(bp->pdata->bp_uart_en > 0)
-		{
-			bp->ops->bp_uart_en = bp->pdata->bp_uart_en;
-		}		
-
-	}
-	
-	if(bp->ops->bp_assert != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_assert, "bp_assert");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_assert);
-			//return -1;
-		}
-	}
-	
-	if(bp->ops->bp_power != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_power, "bp_power");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_power);
-			//return -1;
-		}
-	}
-	
-	if(bp->ops->bp_en != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_en, "bp_en");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_en);
-			//return -1;
-		}
-	}
-
-
-	if(bp->ops->bp_reset != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_reset, "bp_reset");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_reset);
-			//return -1;
-		}
-	}
-
-
-	if(bp->ops->ap_ready != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->ap_ready, "ap_ready");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->ap_ready);
-			//return -1;
-		}
-	}
-
-
-	if(bp->ops->bp_ready != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_ready, "bp_ready");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_ready);
-			//return -1;
-		}
-	}
-
-
-	if(bp->ops->ap_wakeup_bp != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->ap_wakeup_bp, "ap_wakeup_bp");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->ap_wakeup_bp);
-			//return -1;
-		}
-	}
-
-	if(bp->ops->bp_wakeup_ap != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_wakeup_ap, "bp_wakeup_ap");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_wakeup_ap);
-			//return -1;
-		}
-	}
-
-	if(bp->ops->bp_usb_en != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_usb_en, "bp_usb_en");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_usb_en);
-			//return -1;
-		}
-	}
-
-	if(bp->ops->bp_uart_en != BP_UNKNOW_DATA)
-	{
-		result = gpio_request(bp->ops->bp_uart_en, "bp_uart_en");
-		if(result)
-		{
-			printk("%s:fail to request gpio %d\n",__func__, bp->ops->bp_uart_en);
-			//return -1;
-		}
-	}
-	
-	return result;
-}
-
-
-static irqreturn_t bp_wake_up_irq(int irq, void *dev_id)
-{
-	
-	struct bp_private_data *bp = dev_id;
-	//printk("<---%s:bp_id=%d--->\n",__FUNCTION__,bp->ops->bp_id);	
-	if(bp->ops->bp_wake_ap){
-		bp->ops->bp_wake_ap(bp);
-	}	
-	return IRQ_HANDLED;
-}
-
-static int bp_id_open(struct inode *inode, struct file *file)
-{
-	struct bp_private_data *bp = g_bp;
-	
-	return 0;
-}
-
-static int bp_id_release(struct inode *inode, struct file *file)
-{
-	
-	return 0;
-}
-
-static long bp_id_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct bp_private_data *bp = g_bp;
-	void __user *argp = (void __user *)arg;
-	int result = 0;
-
-	switch(cmd)
-	{	
-		case BP_IOCTL_SET_PVID:
-			
-			break;
-	
-		case BP_IOCTL_GET_BPID:
-			if (copy_to_user(argp, &bp->ops->bp_id, sizeof(bp->ops->bp_id)))
-			{
-	            		printk("%s:failed to copy status to user space.\n",__FUNCTION__);
-				return -EFAULT;
-			}
-			
-			break;
-			
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-
-static int bp_dev_open(struct inode *inode, struct file *file)
-{
-	struct bp_private_data *bp = g_bp;
-	printk("<---%s:bp_id=%d--->\n",__FUNCTION__,bp->ops->bp_id);	
-	device_init_wakeup(bp->dev, 1);	
-	return 0;
-}
-static ssize_t bp_dev_write(struct file *file, const char __user *buf,size_t len, loff_t *off)
-{	
-	static char cmd[2];
-	struct bp_private_data *bp = g_bp;
-	
-	int ret = 0;
-	if (len > 2) 
-	{
-		return -EINVAL;
-	}
-	ret = copy_from_user(&cmd, buf, len);
-	if (ret != 0) {
-		return -EFAULT;
-	}
-	printk(" received cmd = %c\n",cmd[0]);
-	switch(bp->ops->bp_id)
-	{
-		case BP_ID_MT6229:
-			if (cmd[0] == '0')
-			{
-				gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-			}	
-			if (cmd[0] == '1')
-			{
-				gpio_direction_output(bp->ops->ap_ready, GPIO_HIGH);
-			}
-			if (cmd[0] == '2')
-			{
-				gpio_direction_output(bp->ops->bp_uart_en, GPIO_LOW);
-			}
-			if (cmd[0] == '3')
-			{
-				gpio_direction_output(bp->ops->bp_uart_en, GPIO_HIGH);
-			}
-			if (cmd[0] == '4')
-			{
-				gpio_direction_output(bp->ops->bp_usb_en, GPIO_HIGH);
-			}if (cmd[0] == '5')
-			{
-				gpio_direction_output(bp->ops->bp_usb_en, GPIO_LOW);
-			}
-			break;
-		
-		case BP_ID_MU509:
-			break;
-
-		default:
-			break;
-
-	}
-	return len;
-}
-static int bp_dev_release(struct inode *inode, struct file *file)
-{
-	struct bp_private_data *bp = g_bp;
-	printk("<---%s:bp_id=%d--->\n",__FUNCTION__,bp->ops->bp_id);	
-	
-	return 0;
-}
-
-static long bp_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct bp_private_data *bp = g_bp;
-	void __user *argp = (void __user *)arg;
-	char SectorBuffer[512];
-	int result = 0;
-	printk("<---%s:bp_id=%d,cmd=%d--->\n",__FUNCTION__,bp->ops->bp_id,cmd);
-	switch(cmd)
-	{
-		case BP_IOCTL_RESET:	
-			if(bp->ops->reset)
-			{
-				bp->ops->reset(bp);
-			}
-			break;
-			
-		case BP_IOCTL_POWON:
-			if(bp->ops->active)
-			bp->ops->active(bp, 1);
-			bp->status = BP_ON;
-			break;
-			
-		case BP_IOCTL_POWOFF:
-			if(bp->ops->active)
-			bp->ops->active(bp, 0);
-			bp->status = BP_OFF;
-			break;
-	
-		case BP_IOCTL_WRITE_STATUS:
-			
-			break;
-	
-		case BP_IOCTL_GET_STATUS:
-			
-			break;
-
-		case BP_IOCTL_SET_PVID:
-			
-			break;
-	
-		case BP_IOCTL_GET_BPID:
-			if (copy_to_user(argp, &bp->ops->bp_id, sizeof(bp->ops->bp_id)))
-			{
-	            		printk("%s:failed to copy status to user space.\n",__FUNCTION__);
-				return -EFAULT;
-			}
-			
-			break;
-		case BP_IOCTL_GET_IMEI:
-			printk("BP_IMEI_READ\n");
-			GetSNSectorInfo(SectorBuffer); 
-			if(copy_to_user(argp, &(SectorBuffer[451]), 16))  // IMEIo：???：?451??：＜??a：o?|━?16bytes?┷?|━：2：＜???byte?a3?┬?：：1：???′?a15
-			{
-				printk("ERROR: copy_to_user---%s\n", __FUNCTION__);
-				return -EFAULT;
-			}
-			break;
-			
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-static ssize_t bp_status_read(struct class *cls, struct class_attribute *attr, char *_buf)
-{
-	struct bp_private_data *bp = g_bp;
-	
-	return sprintf(_buf, "%d\n", bp->status);
-	
-}
-
-static ssize_t bp_status_write(struct class *cls, struct class_attribute *attr, const char *_buf, size_t _count)
-{	
-	struct bp_private_data *bp = g_bp;
-	int result = 0;
-	int status = 0;
-	
-	status = simple_strtoul(_buf, NULL, 16);
-	printk("<<<<<<<<--%s:buf:%s,status=%d\n",__func__,_buf,status);
-	
-	if(status == bp->status) 
-		return _count;
-	
-	bp->status = status;
-	if(bp->ops->write_status){
-		result = bp->ops->write_status(bp);	
-	}else{
-		switch(status)
-		{		
-		case 1://modem power on
-			if(bp->ops->active)
-			bp->ops->active(bp, 1);
-			break;
-			
-		case 0: // modem power off
-			if(bp->ops->active)
-			bp->ops->active(bp, 0);
-			break;		
-		case 2://power en gpio low
-			if(bp->ops->active)
-			bp->ops->active(bp, 2);
-			break;
-		case 3://power en gpio high
-			if(bp->ops->active)
-			bp->ops->active(bp, 3);
-			break;
-		default:
-			break;
-		}
-	}	   
-	return result; 
-}
-static CLASS_ATTR(bp_status, 0777, bp_status_read, bp_status_write);
-static int bp_probe(struct platform_device *pdev)
-{
-	struct bp_platform_data *pdata = pdev->dev.platform_data;
-	struct bp_private_data *bp = NULL;
-	int i = 0, result,irq = 0;
-	if(!pdata)
-		return -1;
-	
-	DBG("%s:init start\n",__func__);
-	
-	if(pdata->init_platform_hw)
-		pdata->init_platform_hw();
-	if(pdata->get_bp_id())
-		pdata->bp_id = pdata->get_bp_id();
-	bp = kzalloc(sizeof(struct bp_private_data), GFP_KERNEL);
-	if(bp == NULL)
-	{
-		printk("%s:fail malloc bp data\n",__func__);
-		return -1;
-	}
-
-	bp->pdata = pdata;
-	bp->dev = &pdev->dev;
-	
-	//select modem acccording to pdata defaultly
-	if((pdata->bp_id > BP_ID_INVALID) && (pdata->bp_id < BP_ID_NUM))
-	{
-		if(g_bp_ops[pdata->bp_id])
-		{
-			bp->ops = g_bp_ops[pdata->bp_id];
-			printk("%s:bp_id=%d\n",__func__,bp->ops->bp_id);
-		}
-		else
-		{
-			printk("%s:error:g_bp_ops[%d] = 0x%p\n",__func__, pdata->bp_id, g_bp_ops[pdata->bp_id]);
-		}
-		
-	}
-	else
-	{
-		printk("%s:bp_id=%d is out of range\n",__func__, pdata->bp_id);
-		return -1;
-	}
-	
-	bp_request_gpio(bp);
-        if(bp->ops->init)
-                bp->ops->init(bp);
-	bp->ops->irq = 0;
-	wake_lock_init(&bp->bp_wakelock, WAKE_LOCK_SUSPEND, "bp_wakelock");
-	if((bp->ops->bp_wakeup_ap != BP_UNKNOW_DATA) && (bp->ops->trig != BP_UNKNOW_DATA))
-	{
-		irq = gpio_to_irq(bp->ops->bp_wakeup_ap);
-		result = request_irq(irq, bp_wake_up_irq, bp->ops->trig, "bp_wakeup_ap", bp);
-		if (result < 0) {
-			printk("%s: request_irq(%d) failed\n", __func__, bp->ops->bp_wakeup_ap);
-			gpio_free(pdata->bp_wakeup_ap);
-			return result;
-		}
-		bp->ops->irq = irq;
-	}
-	
-	
-	bp->status = BP_OFF;
-
-	if(!bp->ops->private_miscdev)
-	{
-		bp->fops.owner = THIS_MODULE;
-		bp->fops.open = bp_dev_open;
-		bp->fops.write = bp_dev_write;
-		bp->fops.release = bp_dev_release;	
-		bp->fops.unlocked_ioctl = bp_dev_ioctl;
-
-		bp->miscdev.minor = MISC_DYNAMIC_MINOR;
-		if(bp->ops->misc_name)
-		bp->miscdev.name = bp->ops->misc_name;
-		else	
-		bp->miscdev.name = BP_DEV_NAME;
-		bp->miscdev.fops = &bp->fops;
-	}
-	else
-	{
-		memcpy(&bp->miscdev, bp->ops->private_miscdev, sizeof(*bp->ops->private_miscdev));
-
-	}
-	
-	result = misc_register(&bp->miscdev);
-	if (result < 0) {
-		printk("misc_register err\n");
-		return result;
-	}
-
-	bp->id_fops.owner = THIS_MODULE;
-	bp->id_fops.open = bp_id_open;
-	bp->id_fops.release = bp_id_release;	
-	bp->id_fops.unlocked_ioctl = bp_id_ioctl;
-
-	bp->id_miscdev.minor = MISC_DYNAMIC_MINOR;
-	bp->id_miscdev.name = "bp_id";
-	bp->id_miscdev.fops = &bp->id_fops;
-	result = misc_register(&bp->id_miscdev);
-	if (result < 0) {
-		printk("misc_register err\n");
-		return result;
-	}
-	
-	g_bp = bp;
-
-	platform_set_drvdata(pdev, bp);	
-	
-	printk("%s:init success\n",__func__);
-	return result;
-
-}
-
-int bp_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct bp_private_data *bp = platform_get_drvdata(pdev);
-	
-	if(bp->ops->suspend)
-		bp->ops->suspend(bp);
-	enable_irq_wake(bp->ops->irq);
-	return 0;
-}
-
-int bp_resume(struct platform_device *pdev)
-{
-	struct bp_private_data *bp = platform_get_drvdata(pdev);
-
-	disable_irq_wake(bp->ops->irq);
-	if(bp->ops->resume)
-		bp->ops->resume(bp);
-
-	return 0;
-}
-
-void bp_shutdown(struct platform_device *pdev)
-{
-	struct bp_private_data *bp = platform_get_drvdata(pdev);
-
-	if(bp->ops->shutdown)
-		bp->ops->shutdown(bp);
-	if(bp->ops->irq){
-		free_irq(bp->ops->irq,bp);
-	}
-}
-
-
-int bp_register_slave(struct bp_private_data *bp,
-			struct bp_platform_data *slave_pdata,
-			struct bp_operate *(*get_bp_ops)(void))
-{
-	int result = 0;
-	struct bp_operate *ops = get_bp_ops();
-	if((ops->bp_id >= BP_ID_NUM) || (ops->bp_id <= BP_ID_INVALID))
-	{	
-		printk("%s:%s id is error %d\n", __func__, ops->name, ops->bp_id);
-		return -1;	
-	}
-	g_bp_ops[ops->bp_id] = ops;
-	printk("%s:%s,id=%d\n",__func__,g_bp_ops[ops->bp_id]->name, ops->bp_id);
-	return result;
-}
-
-
-int bp_unregister_slave(struct bp_private_data *bp,
-			struct bp_platform_data *slave_pdata,
-			struct bp_operate *(*get_bp_ops)(void))
-{
-	int result = 0;
-	struct bp_operate *ops = get_bp_ops();
-	if((ops->bp_id >= BP_ID_NUM) || (ops->bp_id <= BP_ID_INVALID))
-	{	
-		printk("%s:%s id is error %d\n", __func__, ops->name, ops->bp_id);
-		return -1;	
-	}
-	printk("%s:%s,id=%d\n",__func__,g_bp_ops[ops->bp_id]->name, ops->bp_id);
-	g_bp_ops[ops->bp_id] = NULL;	
-	return result;
-}
-
-
-static struct platform_driver bp_driver = {
-	.probe		= bp_probe,
-	.shutdown	= bp_shutdown,
-	.suspend  	= bp_suspend,
-	.resume		= bp_resume,
-	.driver	= {
-		.name	= "bp-auto",
-		.owner	= THIS_MODULE,
-	},
-};
-
-static int __init bp_init(void)
-{
-	int ret ;
-	bp_class = class_create(THIS_MODULE, "bp-auto");
-	ret =  class_create_file(bp_class, &class_attr_bp_status);
-	if (ret)
-	{
-		printk("Fail to create class bp-auto\n");
-	}
-	return platform_driver_register(&bp_driver);
-}
-
-static void __exit bp_exit(void)
-{
-	platform_driver_unregister(&bp_driver);
-	//class_remove_file(bp_class, &class_attr_bp_status);
-}
-
-module_init(bp_init);
-module_exit(bp_exit);
-
-MODULE_AUTHOR("ROCKCHIP Corporation:lw@rock-chips.com");
-MODULE_DESCRIPTION("device interface for auto modem driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/bp/chips/Kconfig b/drivers/misc/bp/chips/Kconfig
deleted file mode 100644
index 73a8951d2e64..000000000000
--- a/drivers/misc/bp/chips/Kconfig
+++ /dev/null
@@ -1,32 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config BP_AUTO_MT6229
-bool "modem mt6229"
-	default n
- 
-config BP_AUTO_MU509
-bool "modem mu509"
-	default n
-
-config BP_AUTO_MW100
-bool "modem mw100"
-	default n
-config BP_AUTO_MI700
-bool "modem mi700"
-	default n
-config BP_AUTO_C66A
-bool "modem c66a"
-        default n
-
-config BP_AUTO_SEW290
-bool "modem sew290"
-        default n
-config BP_AUTO_U7501
-bool "modem u7501"
-        default n
-	
-config BP_AUTO_U5501
-bool "modem u5501"
-
-config BP_AUTO_AW706
-bool "modem aw706"
-        default n
\ No newline at end of file
diff --git a/drivers/misc/bp/chips/Makefile b/drivers/misc/bp/chips/Makefile
deleted file mode 100644
index ba308b8573ed..000000000000
--- a/drivers/misc/bp/chips/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_BP_AUTO)                           += mw100.o
-obj-$(CONFIG_BP_AUTO)                           += mi700.o
-obj-$(CONFIG_BP_AUTO)				+= mt6229.o
-obj-$(CONFIG_BP_AUTO)				+= mu509.o
-obj-$(CONFIG_BP_AUTO)				+= sc6610.o
-obj-$(CONFIG_BP_AUTO)				+= m51.o
-obj-$(CONFIG_BP_AUTO)				+= mtk6250.o
-obj-$(CONFIG_BP_AUTO)                           += c66a.o
-obj-$(CONFIG_BP_AUTO)                           += sew290.o
-obj-$(CONFIG_BP_AUTO)                           += u7501.o
-obj-$(CONFIG_BP_AUTO)                           += a85xx.o
-obj-$(CONFIG_BP_AUTO)                           += u5501.o
-obj-$(CONFIG_BP_AUTO)                           += aw706.o
-obj-$(CONFIG_BP_AUTO)   			+= e1230s.o
\ No newline at end of file
diff --git a/drivers/misc/bp/chips/a85xx.c b/drivers/misc/bp/chips/a85xx.c
deleted file mode 100755
index 894fe1bfb2e3..000000000000
--- a/drivers/misc/bp/chips/a85xx.c
+++ /dev/null
@@ -1,293 +0,0 @@
-/* drivers/misc/bp/chips/a8500.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <zzc@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	switch(enable){
-		case 0:
-			printk("<-----a85xx power off-------->\n");
-			gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-			msleep(2500);
-			gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-			msleep(500);
-			gpio_set_value(bp->ops->bp_reset, GPIO_HIGH); 
-			gpio_set_value(bp->ops->bp_power, GPIO_LOW);	
-			break;
-		case 1:
-			printk("<-----a85xx power on-------->\n");	
-			gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			msleep(100);
-			gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-			//mdelay(100);
-			//gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-			mdelay(2500);
-			gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-			break;
-		case 2:
-			printk("<-----a85xx udate power_en low-------->\n");
-			gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			msleep(100);
-			
-			gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-			//mdelay(100);
-			//gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-			break;
-		case 3:
-			printk("<-----a85xx udate power_en high-------->\n");
-			gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-			break;
-		default:
-			break;
-	}	
-	return result;
-}
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;		
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	if(bp->pdata->gpio_valid ==0){		
-		
-	}
-	gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_reset, GPIO_HIGH);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_HIGH);   
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl a85xx reset !!! \n");
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(2000);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);	
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	
-	bp->suspend_status = 1;
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	
-	return 0;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);
-	
-	return 0;
-}
-
-
-struct bp_operate bp_a85xx_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "a85xx",
-	.bp_id			= BP_ID_A85XX,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN0_PB6,
-	.ap_ready		= RK2928_PIN0_PD0,	//
-	.bp_ready		= RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_RISING,//IRQF_TRIGGER_FALLING,//IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_SOC_RK3028)
-	.name			= "a85xx",
-	.bp_id			= BP_ID_A85XX,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC2,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK30_PIN3_PD0,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= RK30_PIN3_PC6,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK30_PIN0_PC1,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "a85xx",
-	.bp_id			= BP_ID_A85XX,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_a85xx_ops;
-}
-
-static int __init bp_a85xx_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_a85xx_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_a85xx_init);
-module_exit(bp_a85xx_exit);
-
diff --git a/drivers/misc/bp/chips/aw706.c b/drivers/misc/bp/chips/aw706.c
deleted file mode 100755
index 36ebf1cbd53a..000000000000
--- a/drivers/misc/bp/chips/aw706.c
+++ /dev/null
@@ -1,326 +0,0 @@
-/* drivers/misc/bp/chips/aw706.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	switch(enable){
-		case 0:
-			printk("<-----aw706 power off-------->\n");
-			//result = gpio_get_value(bp->ops->bp_assert);
-			//if(!result){ 
-			//printk("<-----aw706 is poweroff-------->\n");
-			//return result;}
-			gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-			msleep(2500);
-			gpio_set_value(bp->ops->bp_en, GPIO_HIGH);		
-			gpio_set_value(bp->ops->bp_power, GPIO_LOW);	
-			break;
-		case 1:
-			printk("<-----aw706 power on-------->\n");	
-			//result = gpio_get_value(bp->ops->bp_assert);
-			//if(result){
-			//	printk("<-----aw706 power bp_assert is high no need to power on again-------->\n");
-			//	return result;
-			//}
-        	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			mdelay(100);
-			gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-			gpio_set_value(bp->ops->ap_wakeup_bp,GPIO_HIGH);	
-        	mdelay(1000);		
-			gpio_set_value(bp->ops->ap_wakeup_bp,GPIO_LOW);
-			gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-			break;
-		case 2:
-			printk("<-----aw706 udate power_en low-------->\n");
-			gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			mdelay(50);
-			gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-			gpio_set_value(bp->ops->ap_wakeup_bp,GPIO_HIGH);
-			break;
-		case 3:
-			printk("<-----aw706 udate power_en high-------->\n");
-			gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-			gpio_set_value(bp->ops->ap_wakeup_bp,GPIO_LOW);
-			break;
-		default:
-			break;
-	}	
-	return result;
-}
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->suspend_status)
-	{
-		//iomux_set(UART1_RTSN);
-		//gpio_direction_output(RK30_PIN1_PA6, GPIO_LOW);
-		printk("bp_wake_ap aw706 done!!! \n");	
-		
-		bp->suspend_status = 0;		
-		wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	}
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-	//gpio_direction_output(bp->ops->bp_reset, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en, GPIO_HIGH);
-	//gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);   
-	//gpio_direction_input(bp->ops->bp_ready);	
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_direction_input(bp->ops->bp_assert);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	
-	//if(bp->ops->active)
-		//bp->ops->active(bp, 1);	
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl aw706 reset !!! \n");	
-	return 0;
-	gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-	mdelay(6000);
-	gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-	
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	int ret = 0;
-	printk("aw706 %s !!! \n",__func__);
-	bp->suspend_status = 1;
-	//gpio_set_value(bp->ops->ap_ready, GPIO_HIGH);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);
-	/*
-	iomux_set(GPIO1_A7);
-	ret = gpio_request(RK30_PIN1_PA7,"bp_auto");
-	if(ret < 0){
-		printk("%s rk30_pin1_pa7 request failed\n",__func__);
-		return result;
-	}	
-	gpio_direction_output(RK30_PIN1_PA7, GPIO_HIGH);
-	*/
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	bp->suspend_status = 0;	
-		
-	//iomux_set(UART1_RTSN);		
-	//gpio_direction_output(RK30_PIN1_PA7, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	return 0;
-}
-
-
-struct bp_operate bp_aw706_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "aw706",
-	.bp_id			= BP_ID_AW706,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN0_PB6,
-	.ap_ready		= RK2928_PIN0_PD0,	//
-	.bp_ready		= RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_SOC_RK3028)
-	.name			= "aw706",
-	.bp_id			= BP_ID_AW706,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC2,//BP_UNKNOW_DATA,// 3g_power
-#if defined(CONFIG_MACH_RK3028_PHONEPAD_780)
-	.bp_en			= RK30_PIN0_PC5,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-#else
-	.bp_en			= RK30_PIN3_PD0,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-#endif
-	.bp_reset		= BP_UNKNOW_DATA,//BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,//RK30_PIN1_PB5,//BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,//RK30_PIN3_PD0,//BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= RK30_PIN3_PC6,//BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK30_PIN0_PC1,//BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= RK30_PIN0_PC0,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "aw706",
-	.bp_id			= BP_ID_AW706,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_aw706_ops;
-}
-
-static int __init bp_aw706_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_aw706_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_aw706_init);
-module_exit(bp_aw706_exit);
-
diff --git a/drivers/misc/bp/chips/c66a.c b/drivers/misc/bp/chips/c66a.c
deleted file mode 100644
index ab7aba6f18ec..000000000000
--- a/drivers/misc/bp/chips/c66a.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/* drivers/misc/bp/chips/c66a.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{		
-		printk("<-----c66a power on-------->\n");
-		gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	}
-	else
-	{
-		printk("<-----c66a power on-------->\n");
-		gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-		msleep(500);
-	}
-	
-	return result;
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	printk("<-----c66a bp_wake_ap-------->\n");
-	bp->suspend_status = 0;		
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;	
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_direction_output(bp->ops->bp_power,GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp,GPIO_HIGH);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl c66a reset !!! \n");
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	msleep(2000);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);	
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	bp->suspend_status = 1;
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);		
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	printk("<-----c66a bp_resume-------->\n");
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_c66a_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "c66a",
-	.bp_id			= BP_ID_C66A,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "c66a",
-	.bp_id			= BP_ID_C66A,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "c66a",
-	.bp_id			= BP_ID_C66A,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-
-
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_c66a_ops;
-}
-
-static int __init bp_c66a_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_c66a_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_c66a_init);
-module_exit(bp_c66a_exit);
-
diff --git a/drivers/misc/bp/chips/e1230s.c b/drivers/misc/bp/chips/e1230s.c
deleted file mode 100755
index 71e3c21c6e75..000000000000
--- a/drivers/misc/bp/chips/e1230s.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/* drivers/misc/bp/chips/E1230S.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	  
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{		
-	return 0;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	printk("<-----E1230S ap_wake_bp-------->\n");
-	gpio_set_value(bp->ops->ap_wakeup_bp, wake);  
-	
-	return 0;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-	if(bp->suspend_status)
-	{
-		bp->suspend_status = 0;
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	printk("<-----E1230S bp_init-------->\n");
-	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	msleep(500);
-	bp->suspend_status = 0;
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	gpio_direction_output(bp->ops->bp_en, GPIO_HIGH);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return 0;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	msleep(3000);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);	
-
-	return 0;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	printk("<-----E1230S bp_wake_ap-------->\n");
-	
-	bp->suspend_status = 1;
-	schedule_delayed_work(&bp->wakeup_work, 2*HZ);
-	wake_lock_timeout(&bp->bp_wakelock, 10* HZ);	
-	
-	return 0;
-}
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-
-	return result;
-}
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	return 0;
-}
-
-static int bp_resume(struct bp_private_data *bp)
-{	
-	if(!bp->suspend_status){
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);	
-	}
-	return 0;
-}
-
-
-struct bp_operate bp_E1230S_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "E1230S",
-	.bp_id			= BP_ID_E1230S,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif (defined(CONFIG_SOC_RK3168) || defined(CONFIG_SOC_RK3188))
-	.name			= "E1230S",
-	.bp_id			= BP_ID_E1230S,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC6,// 3g_power
-	.bp_en			= RK30_PIN2_PD5,// 3g_en
-	.bp_reset			= RK30_PIN2_PD4,//BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK30_PIN0_PC4,
-	.bp_wakeup_ap		= RK30_PIN0_PC5,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "E1230S",
-	.bp_id			= BP_ID_E1230S,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_E1230S_ops;
-}
-
-static int __init bp_E1230S_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	return result;
-}
-
-static void __exit bp_E1230S_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_E1230S_init);
-module_exit(bp_E1230S_exit);
-
diff --git a/drivers/misc/bp/chips/m51.c b/drivers/misc/bp/chips/m51.c
deleted file mode 100755
index d2e29cb94f7a..000000000000
--- a/drivers/misc/bp/chips/m51.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/* drivers/misc/bp/chips/m51.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	switch(enable){
-		case 0:
-			printk("<-----m51 power off-------->\n");
-			gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-			msleep(2000);		
-			gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-			msleep(1000);
-			break;
-		case 1:
-			printk("<-----m51 power on-------->\n");
-			
-			gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			//msleep(100);		
-			//gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-			msleep(500);
-			gpio_set_value(bp->ops->bp_en, GPIO_HIGH);	
-			msleep(2500);
-			break;
-		case 2:
-			printk("<-----aw706 udate power_en low-------->\n");
-			gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-			msleep(100);		
-			gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-			msleep(1000);
-			gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-			break;
-		case 3:
-			printk("<-----aw706 udate power_en high-------->\n");
-			
-			break;
-		default:
-			break;
-	}	
-	return result;
-}
-
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;		
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	if(bp->pdata->gpio_valid ==0){		
-		
-	}
-	gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-//	gpio_direction_output(bp->ops->bp_reset, GPIO_HIGH);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	//gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	//if(bp->ops->active)
-		//bp->ops->active(bp, 1);	 
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl m51 reset !!! \n");
-//	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(500);
-	//gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);	
-	//if(bp->ops->active)
-		//bp->ops->active(bp, 0);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	printk("m51 bp_shutdown   !!! \n");
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	printk("m51 bp_suspend   !!! \n");
-	bp->suspend_status = 1;
-	//gpio_set_value(bp->ops->ap_ready, GPIO_HIGH);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);
-
-	
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	printk("m51 bp_resume   !!! \n");
-	bp->suspend_status = 0;	
-	//gpio_set_value(bp->ops->ap_ready, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_m51_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "m51",
-	.bp_id			= BP_ID_M51,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "m51",
-	.bp_id			= BP_ID_M51,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC2,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK30_PIN0_PC0,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,
-	.ap_wakeup_bp	= RK30_PIN3_PC6,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK30_PIN0_PC1,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "m51",
-	.bp_id			= BP_ID_M51,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_m51_ops;
-}
-
-static int __init bp_m51_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_m51_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_m51_init);
-module_exit(bp_m51_exit);
-
diff --git a/drivers/misc/bp/chips/mi700.c b/drivers/misc/bp/chips/mi700.c
deleted file mode 100755
index 2ce93e913a57..000000000000
--- a/drivers/misc/bp/chips/mi700.c
+++ /dev/null
@@ -1,280 +0,0 @@
-/* drivers/misc/bp/chips/mi700.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{
-		printk("mi700 power on \n");
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(1000);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		msleep(700);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	}
-	else
-	{
-		printk("mi700 power off \n");		
-
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(2500);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	}
-	
-	return result;
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;	
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);	
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl mi700 reset !!! \n");
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	msleep(1000);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	msleep(700);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	
-	if(!bp->suspend_status)
-	{
-		bp->suspend_status = 1;
-		//gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	bp->suspend_status = 0;	
-	//gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_mi700_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "mi700",
-	.bp_id			= BP_ID_MI700,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "mi700",
-	.bp_id			= BP_ID_MI700,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "mi700",
-	.bp_id			= BP_ID_MI700,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_mi700_ops;
-}
-
-static int __init bp_mi700_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_mi700_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_mi700_init);
-module_exit(bp_mi700_exit);
-
diff --git a/drivers/misc/bp/chips/mt6229.c b/drivers/misc/bp/chips/mt6229.c
deleted file mode 100755
index a4b3e243e980..000000000000
--- a/drivers/misc/bp/chips/mt6229.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/* drivers/misc/bp/chips/mt6229.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{
-		gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-		msleep(1000);
-		gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-		gpio_direction_output(bp->ops->bp_usb_en, GPIO_HIGH);
-		gpio_direction_output(bp->ops->bp_uart_en, GPIO_LOW);
-		
-		gpio_direction_output(bp->ops->ap_ready, GPIO_HIGH);
-	}
-	else
-	{
-		gpio_direction_output(bp->ops->bp_power, GPIO_LOW);	
-		msleep(10);
-		gpio_direction_output(bp->ops->bp_en, GPIO_HIGH);
-		gpio_direction_output(bp->ops->bp_usb_en, GPIO_LOW);
-		gpio_direction_output(bp->ops->bp_uart_en, GPIO_HIGH);
-		gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-	}
-	
-	return result;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	int result = 0;
-	if(wake)
-	{
-		gpio_direction_output(bp->ops->bp_uart_en,  GPIO_LOW);
-		msleep(2000);
-		gpio_direction_output(bp->ops->ap_ready, GPIO_HIGH);
-		gpio_direction_output(bp->ops->bp_usb_en, GPIO_HIGH);
-	}
-	else
-	{
-		gpio_direction_output(bp->ops->bp_usb_en, GPIO_LOW);
-		gpio_direction_output(bp->ops->bp_uart_en, GPIO_HIGH);	
-		gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-	}
-	
-	return result;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-
-	if(bp->suspend_status)
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-	}
-	else	
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 1);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	//gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	//msleep(1000);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);	
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-
-
-
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	
-	if(!bp->suspend_status)
-	{
-		bp->suspend_status = 1;	
-		if(bp->ops->ap_wake_bp)
-			bp->ops->ap_wake_bp(bp, 0);
-	}
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	bp->suspend_status = 0;
-	PREPARE_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	schedule_delayed_work(&bp->wakeup_work, 0);
-		
-	return 0;
-}
-
-
-struct bp_operate bp_mt6229_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "mt6229",
-	.bp_id			= BP_ID_MT6229,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "mt6229",
-	.bp_id			= BP_ID_MT6229,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "mt6229",
-	.bp_id			= BP_ID_MT6229,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_mt6229_ops;
-}
-
-static int __init bp_mt6229_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_mt6229_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_mt6229_init);
-module_exit(bp_mt6229_exit);
-
diff --git a/drivers/misc/bp/chips/mtk6250.c b/drivers/misc/bp/chips/mtk6250.c
deleted file mode 100644
index 0ba2e2a9fe6a..000000000000
--- a/drivers/misc/bp/chips/mtk6250.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/* drivers/misc/bp/chips/mt6250.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{		
-		printk("<-----mt6250 power on-------->\n");	
-		gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_en,GPIO_HIGH);
-		mdelay(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		mdelay(2500);
-		gpio_set_value(bp->ops->bp_en,GPIO_LOW);
-	}
-	else
-	{
-		printk("<-----mt6250 power on-------->\n");
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		msleep(2500);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(500);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH); 
-		gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	}
-	
-	return result;
-}
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;		
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	if(bp->pdata->gpio_valid ==0){		
-		
-	}
-	gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_reset, GPIO_HIGH);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_ready, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_HIGH);   
-	//gpio_direction_input(bp->ops->bp_ready);	
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	
-	//if(bp->ops->active)
-		//bp->ops->active(bp, 1);	
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl mt6250 reset !!! \n");
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(2000);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);	
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	
-	bp->suspend_status = 1;
-	gpio_set_value(bp->ops->ap_ready, GPIO_HIGH);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-
-	
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_ready, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);
-	msleep(100);	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_mt6250_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "mt6250",
-	.bp_id			= BP_ID_MT6250,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN0_PB6,
-	.ap_ready		= RK2928_PIN0_PD0,	//
-	.bp_ready		= RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "mt6250",
-	.bp_id			= BP_ID_MT6250,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "mt6250",
-	.bp_id			= BP_ID_MT6250,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,//BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,	// RK2928_PIN0_PB6,
-	.ap_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD0,	//
-	.bp_ready		= BP_UNKNOW_DATA,	// RK2928_PIN0_PD6,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_assert		= BP_UNKNOW_DATA,
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_mt6250_ops;
-}
-
-static int __init bp_mt6250_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_mt6250_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_mt6250_init);
-module_exit(bp_mt6250_exit);
-
diff --git a/drivers/misc/bp/chips/mu509.c b/drivers/misc/bp/chips/mu509.c
deleted file mode 100755
index b8c538406990..000000000000
--- a/drivers/misc/bp/chips/mu509.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/* drivers/misc/bp/chips/mu509.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{
-//		gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//		msleep(500);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		msleep(1000);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(700);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	else
-	{
-//		gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(2500);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	}
-	
-	return result;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	int result = 0;
-	
-	gpio_set_value(bp->ops->ap_wakeup_bp, wake);  
-	
-	return result;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-
-	if(bp->suspend_status)
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-		bp->suspend_status = 0;
-	}
-	else	
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 1);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	msleep(500);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	gpio_direction_output(bp->ops->bp_reset, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-//	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//	msleep(500);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	msleep(1000);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	msleep(700);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-
-	return 0;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-
-	return result;
-}
-
-
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	printk("<-----mu509 bp_suspend-------->\n");
-	#if defined(CONFIG_ARCH_RK29)
-		rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME, GPIO1H_GPIO1C1);
-	#elif defined(CONFIG_SOC_RK3066)
-		rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME, GPIO1A_GPIO1A7);
-	#endif
-	
-	if(!bp->suspend_status)
-	{
-		bp->suspend_status = 1;	
-		//printk("<-----mu509 bp_suspend----ap_wakeup_bp, GPIO_HIGH---->\n");
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	}
-	
-	return result;
-}
-
-
-
-
-static int bp_resume(struct bp_private_data *bp)
-{	
-	#if defined(CONFIG_ARCH_RK29)
-		rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME, GPIO1H_UART0_RTS_N);
-	#elif defined(CONFIG_SOC_RK3066)
-		rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME, GPIO1A_UART1_RTS_N);
-	#endif
-	
-	//bp->suspend_status = 0;	
-	//gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);	
-	schedule_delayed_work(&bp->wakeup_work, 4*HZ);
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_mu509_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "mu509",
-	.bp_id			= BP_ID_MU509,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "mu509",
-	.bp_id			= BP_ID_MU509,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "mu509",
-	.bp_id			= BP_ID_MU509,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_mu509_ops;
-}
-
-static int __init bp_mu509_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_mu509_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_mu509_init);
-module_exit(bp_mu509_exit);
-
diff --git a/drivers/misc/bp/chips/mw100.c b/drivers/misc/bp/chips/mw100.c
deleted file mode 100755
index 6305a36467b2..000000000000
--- a/drivers/misc/bp/chips/mw100.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/* drivers/misc/bp/chips/mw100.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{
-		printk("mw100 power on \n");
-/*		gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-		msleep(500);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);	
-		
-		mdelay(10);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);	
-		
-		mdelay(500);			
-		//gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		*/
-		gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-		msleep(500);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(1000);
-		//gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	}
-	else
-	{
-		printk("mw100 power off \n");	
-		gpio_set_value(bp->ops->bp_power, GPIO_LOW);	
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		msleep(500);
-		
-	}
-	
-	return result;
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;	
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	//if(!bp->pdata->gpio_valid){
-		//rk30_mux_api_set(GPIO1A3_I2S_LRCKTX_NAME,GPIO1A_GPIO1A3);
-	//}
-	gpio_direction_output(bp->ops->bp_power,GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en,GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_reset,GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp,GPIO_HIGH);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl mw100 reset !!! \n");
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);	
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	//gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);		
-	//mdelay(10);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	mdelay(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);	
-
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	
-	if(!bp->suspend_status)
-	{
-		bp->suspend_status = 1;
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_mw100_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "mw100",
-	.bp_id			= BP_ID_MW100,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= RK2928_PIN3_PC5,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "mw100",
-	.bp_id			= BP_ID_MW100,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "mw100",
-	.bp_id			= BP_ID_MW100,
-	.bp_bus			= BP_BUS_TYPE_USB,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,//RK2928_PIN3_PC5,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig				= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_mw100_ops;
-}
-
-static int __init bp_mw100_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_mw100_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_mw100_init);
-module_exit(bp_mw100_exit);
-
diff --git a/drivers/misc/bp/chips/sc6610.c b/drivers/misc/bp/chips/sc6610.c
deleted file mode 100755
index 4ae1cc571f6f..000000000000
--- a/drivers/misc/bp/chips/sc6610.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/* drivers/misc/bp/chips/sc6610.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{		
-		printk("<-----sc6610 power on-------->\n");
-		gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	}
-	else
-	{
-		printk("<-----sc6610 power off-------->\n");
-		gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-		msleep(500);
-	}
-	
-	return result;
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	return;
-}
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-		printk("<-----sc6610 bp_wake_ap-------->\n");
-		bp->suspend_status = 0;		
-		wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;	
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_direction_output(bp->ops->bp_power,GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp,GPIO_HIGH);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-	printk("ioctrl sc6610 reset !!! \n");
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	msleep(2000);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);	
-	return 0;
-}
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-		
-	return result;
-}
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	bp->suspend_status = 1;
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);		
-	
-	return result;
-}
-static int bp_resume(struct bp_private_data *bp)
-{
-	
-	printk("<-----sc6610 bp_resume-------->\n");
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_sc6610_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "sc6610",
-	.bp_id			= BP_ID_SC6610,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "sc6610",
-	.bp_id			= BP_ID_SC6610,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC2,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= RK30_PIN3_PC6,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= RK30_PIN0_PC1,	// RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= RK30_PIN0_PC0,	// RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "sc6610",
-	.bp_id			= BP_ID_SC6610,
-	.bp_bus			= BP_BUS_TYPE_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC4,
-	.bp_wakeup_ap	= BP_UNKNOW_DATA,	// RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.bp_assert		= BP_UNKNOW_DATA,	// RK2928_PIN3_PC5,
-	.trig				= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init				= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= NULL,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_sc6610_ops;
-}
-
-static int __init bp_sc6610_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_sc6610_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_sc6610_init);
-module_exit(bp_sc6610_exit);
-
diff --git a/drivers/misc/bp/chips/sew290.c b/drivers/misc/bp/chips/sew290.c
deleted file mode 100644
index 8e3d32638cca..000000000000
--- a/drivers/misc/bp/chips/sew290.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/* drivers/misc/bp/chips/mu509.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{		
-	printk("<-----SEW290 bp_active-------->\n");
-	if(enable)
-	{
-	        gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-                msleep(1000);
-                gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-                msleep(2500);
-                gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-                gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	else
-	{
-                gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-                msleep(4000);
-                gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-
-	}
-	
-	return 0;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	int result = 0;
-	
-	gpio_set_value(bp->ops->ap_wakeup_bp, wake);  
-	
-	return result;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-
-	if(bp->suspend_status)
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-	}
-	else	
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 1);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	printk("<-----SEW290 bp_init-------->\n");
-	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	msleep(500);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_direction_output(bp->ops->bp_reset, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_HIGH);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return 0;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-//	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//	msleep(500);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	msleep(1000);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	msleep(700);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-
-	return 0;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	printk("<-----SEW290 bp_wake_ap-------->\n");
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 20* HZ);
-	
-	return 0;
-}
-
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-
-	return result;
-}
-
-
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-
-	printk("<-----SEW290 bp_suspend-------->\n");
-	
-	bp->suspend_status = 1;
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);		
-	
-	return 0;
-}
-
-
-
-
-static int bp_resume(struct bp_private_data *bp)
-{	
-
-	printk("<-----SEW290 bp_resume-------->\n");
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_sew290_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "sew290",
-	.bp_id			= BP_ID_SEW290,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_SOC_RK3066)
-	.name			= "sew290",
-	.bp_id			= BP_ID_SEW290,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK30_PIN2_PC5,
-	.bp_wakeup_ap		= RK30_PIN2_PC4,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "sew290",
-	.bp_id			= BP_ID_SEW290,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_sew290_ops;
-}
-
-static int __init bp_sew290_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_sew290_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_sew290_init);
-module_exit(bp_sew290_exit);
-
diff --git a/drivers/misc/bp/chips/u5501.c b/drivers/misc/bp/chips/u5501.c
deleted file mode 100755
index e72461de9000..000000000000
--- a/drivers/misc/bp/chips/u5501.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/* drivers/misc/bp/chips/u5501.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-
-#if 0
-#define DBG(x...)  printk(x)
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{	
-	int result = 0;
-	if(enable)
-	{
-//		gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//		msleep(500);
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		msleep(1000);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(700);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	else
-	{
-//		gpio_direction_output(bp->ops->bp_power, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-		gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-		msleep(2500);
-		gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	}
-	
-	return result;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	int result = 0;
-	
-	gpio_set_value(bp->ops->ap_wakeup_bp, wake);  
-	
-	return result;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-
-	if(bp->suspend_status)
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-		bp->suspend_status = 0;
-	}
-	else	
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 1);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	int result = 0;
-	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	msleep(500);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	gpio_direction_output(bp->ops->bp_reset, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return result;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-//	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//	msleep(500);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	msleep(1000);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	msleep(700);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-
-	return 0;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 10 * HZ);
-	
-	return result;
-}
-
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-
-	return result;
-}
-
-
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-	int result = 0;
-	printk("<-----u5501 bp_suspend-------->\n");
-	#if defined(CONFIG_ARCH_RK29)
-		rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME, GPIO1H_GPIO1C1);
-	#elif defined(CONFIG_SOC_RK3066)
-		rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME, GPIO1A_GPIO1A7);
-	#endif
-	
-	if(!bp->suspend_status)
-	{
-		bp->suspend_status = 1;	
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	}
-	#if defined(CONFIG_ARCH_RK2928)
-	rk29_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_GPIO1B1);
-	gpio_set_value(RK2928_PIN1_PB1, GPIO_LOW);
-	#elif defined(CONFIG_SOC_RK3066)
-	rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME, GPIO1A_GPIO1A5);
-	gpio_set_value(RK30_PIN1_PA5, GPIO_LOW);
-	#endif
-	return result;
-}
-
-
-
-
-static int bp_resume(struct bp_private_data *bp)
-{	
-	#if defined(CONFIG_ARCH_RK29)
-		rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME, GPIO1H_UART0_RTS_N);
-	#elif defined(CONFIG_SOC_RK3066)
-		rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME, GPIO1A_UART1_RTS_N);
-	#endif
-	
-	#if defined(CONFIG_ARCH_RK2928)
-	rk29_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_UART1_SOUT);
-	#elif defined(CONFIG_SOC_RK3066)
-	rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME, GPIO1A_UART1_SOUT);
-	#endif
-	//bp->suspend_status = 0;	
-	//gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);	
-	schedule_delayed_work(&bp->wakeup_work, 4*HZ);
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_u5501_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "u5501",
-	.bp_id			= BP_ID_U5501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif defined(CONFIG_ARCH_RK30)
-	.name			= "u5501",
-	.bp_id			= BP_ID_U5501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "u5501",
-	.bp_id			= BP_ID_U5501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_u5501_ops;
-}
-
-static int __init bp_u5501_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_u5501_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_u5501_init);
-module_exit(bp_u5501_exit);
-
diff --git a/drivers/misc/bp/chips/u7501.c b/drivers/misc/bp/chips/u7501.c
deleted file mode 100644
index 2e0e5c21b93c..000000000000
--- a/drivers/misc/bp/chips/u7501.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/* drivers/misc/bp/chips/U7501.c
- *
- * Copyright (C) 2012-2015 ROCKCHIP.
- * Author: luowei <lw@rock-chips.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/input.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-#include <asm/gpio.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-#include <linux/slab.h>
-#include <linux/earlysuspend.h>
-
-#include <linux/bp-auto.h>
-	 
-	 
-#if 0
-#define DBG(x...)  printk(x)
-
-#else
-#define DBG(x...)
-#endif
-
-
-/****************operate according to bp chip:start************/
-static int bp_active(struct bp_private_data *bp, int enable)
-{		
-	if(enable)
-	{
-	printk("<-----U7501 bp_on-->\n");
-		gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-		msleep(100);
-		gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	        gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-                msleep(1000);
-                gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-                msleep(5000);
-                gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-                gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	}
-	else
-	{
-	printk("<-----U7501 bp_off----->\n");
-                gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-
-	}
-	
-	return 0;
-}
-
-static int ap_wake_bp(struct bp_private_data *bp, int wake)
-{
-	printk("<-----U7501 ap_wake_bp-------->\n");
-
-	
-	gpio_set_value(bp->ops->ap_wakeup_bp, wake);  
-	
-	return 0;
-
-}
-
-static void  ap_wake_bp_work(struct work_struct *work)
-{
-	struct delayed_work *wakeup_work = container_of(work, struct delayed_work, work);
-	struct bp_private_data *bp = container_of(wakeup_work, struct bp_private_data, wakeup_work);
-
-	if(bp->suspend_status)
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 0);
-	}
-	else	
-	{
-		if(bp->ops->ap_wake_bp)
-		bp->ops->ap_wake_bp(bp, 1);
-	}
-}
-
-
-static int bp_init(struct bp_private_data *bp)
-{
-	printk("<-----U7501 bp_init-------->\n");
-	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-	gpio_set_value(bp->ops->bp_power, GPIO_HIGH);
-	msleep(500);
-	//if(bp->ops->active)
-	//	bp->ops->active(bp, 1);
-	gpio_direction_input(bp->ops->bp_wakeup_ap);
-	gpio_pull_updown(bp->ops->bp_wakeup_ap, 1);	
-	gpio_direction_output(bp->ops->bp_reset, GPIO_LOW);
-	gpio_direction_output(bp->ops->bp_en, GPIO_LOW);
-	gpio_direction_output(bp->ops->ap_wakeup_bp, GPIO_LOW);
-	INIT_DELAYED_WORK(&bp->wakeup_work, ap_wake_bp_work);
-	return 0;
-}
-
-static int bp_reset(struct bp_private_data *bp)
-{
-//	gpio_direction_output(bp->ops->bp_power, GPIO_HIGH);
-//	msleep(500);
-	gpio_set_value(bp->ops->bp_reset, GPIO_HIGH);
-	msleep(100);
-	gpio_set_value(bp->ops->bp_reset, GPIO_LOW);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	msleep(1000);
-	gpio_set_value(bp->ops->bp_en, GPIO_HIGH);
-	msleep(700);
-	gpio_set_value(bp->ops->bp_en, GPIO_LOW);
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);
-
-	return 0;
-}
-
-static int bp_wake_ap(struct bp_private_data *bp)
-{
-	printk("<-----U7501 bp_wake_ap-------->\n");
-	
-	bp->suspend_status = 0;
-	wake_lock_timeout(&bp->bp_wakelock, 20* HZ);
-	
-	return 0;
-}
-
-
-static int bp_shutdown(struct bp_private_data *bp)
-{
-	int result = 0;
-	
-	if(bp->ops->active)
-		bp->ops->active(bp, 0);
-	gpio_set_value(bp->ops->bp_power, GPIO_LOW);
-	cancel_delayed_work_sync(&bp->wakeup_work);	
-
-	return result;
-}
-
-
-
-static int bp_suspend(struct bp_private_data *bp)
-{	
-
-	printk("<-----U7501 bp_suspend------->\n");
-	
-	bp->suspend_status = 1;
-		gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_HIGH);	
-	
-	return 0;
-}
-
-
-
-
-static int bp_resume(struct bp_private_data *bp)
-{	
-	printk("<-----U7501 bp_resume------>\n");
-	bp->suspend_status = 0;	
-	gpio_set_value(bp->ops->ap_wakeup_bp, GPIO_LOW);	
-	
-	
-	return 0;
-}
-
-
-struct bp_operate bp_U7501_ops = {
-#if defined(CONFIG_ARCH_RK2928)
-	.name			= "U7501",
-	.bp_id			= BP_ID_U7501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,//IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#elif (defined(CONFIG_SOC_RK3168) || defined(CONFIG_SOC_RK3188))
-	.name			= "U7501",
-	.bp_id			= BP_ID_U7501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= RK30_PIN0_PC6,// 3g_power
-	.bp_en			= RK30_PIN2_PD5,// 3g_en
-	.bp_reset			= RK30_PIN2_PD4,//BP_UNKNOW_DATA,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= RK30_PIN0_PC4,
-	.bp_wakeup_ap		= RK30_PIN0_PC5,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,//IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#else
-	.name			= "U7501",
-	.bp_id			= BP_ID_U7501,
-	.bp_bus			= BP_BUS_TYPE_USB_UART,		
-	.bp_pid			= 0,	
-	.bp_vid			= 0,	
-	.bp_power		= BP_UNKNOW_DATA,//RK2928_PIN3_PC2, 	// 3g_power
-	.bp_en			= BP_UNKNOW_DATA,	// 3g_en
-	.bp_reset			= BP_UNKNOW_DATA,//RK2928_PIN1_PA3,
-	.ap_ready		= BP_UNKNOW_DATA,	//
-	.bp_ready		= BP_UNKNOW_DATA,
-	.ap_wakeup_bp		= BP_UNKNOW_DATA,//RK2928_PIN3_PC4,
-	.bp_wakeup_ap		= BP_UNKNOW_DATA,//RK2928_PIN3_PC3,	//
-	.bp_uart_en		= BP_UNKNOW_DATA, 	//EINT9
-	.bp_usb_en		= BP_UNKNOW_DATA, 	//W_disable
-	.trig			= IRQF_TRIGGER_FALLING,//IRQF_TRIGGER_RISING,
-
-	.active			= bp_active,
-	.init			= bp_init,
-	.reset			= bp_reset,
-	.ap_wake_bp		= ap_wake_bp,
-	.bp_wake_ap		= bp_wake_ap,
-	.shutdown		= bp_shutdown,
-	.read_status		= NULL,
-	.write_status		= NULL,
-	.suspend 		= bp_suspend,
-	.resume			= bp_resume,
-	.misc_name		= NULL,
-	.private_miscdev	= NULL,
-#endif
-};
-
-/****************operate according to bp chip:end************/
-
-//function name should not be changed
-static struct bp_operate *bp_get_ops(void)
-{
-	return &bp_U7501_ops;
-}
-
-static int __init bp_U7501_init(void)
-{
-	struct bp_operate *ops = bp_get_ops();
-	int result = 0;
-	result = bp_register_slave(NULL, NULL, bp_get_ops);
-	if(result)
-	{	
-		return result;
-	}
-	
-	if(ops->private_miscdev)
-	{
-		result = misc_register(ops->private_miscdev);
-		if (result < 0) {
-			printk("%s:misc_register err\n",__func__);
-			return result;
-		}
-	}
-	
-	DBG("%s\n",__func__);
-	return result;
-}
-
-static void __exit bp_U7501_exit(void)
-{
-	//struct bp_operate *ops = bp_get_ops();
-	bp_unregister_slave(NULL, NULL, bp_get_ops);
-}
-
-
-subsys_initcall(bp_U7501_init);
-module_exit(bp_U7501_exit);
-
diff --git a/include/linux/bp-auto.h b/include/linux/bp-auto.h
deleted file mode 100644
index 40d91c7fd128..000000000000
--- a/include/linux/bp-auto.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _BP_AUTO_H
-#define _BP_AUTO_H
-#include <linux/miscdevice.h>
-#include <linux/wakelock.h>
-
-struct bp_private_data;
-#define BP_DEV_NAME	"voice_modem"
-#define BP_UNKNOW_DATA	-1
-#define BP_OFF		0
-#define BP_ON		1
-#define BP_SUSPEND	2
-#define BP_WAKE		3
-
-#define BP_IOCTL_BASE 0x1a
-
-#define BP_IOCTL_RESET 		_IOW(BP_IOCTL_BASE, 0x01, int)
-#define BP_IOCTL_POWOFF 	_IOW(BP_IOCTL_BASE, 0x02, int)
-#define BP_IOCTL_POWON 		_IOW(BP_IOCTL_BASE, 0x03, int)
-
-#define BP_IOCTL_WRITE_STATUS 	_IOW(BP_IOCTL_BASE, 0x04, int)
-#define BP_IOCTL_GET_STATUS 	_IOR(BP_IOCTL_BASE, 0x05, int)
-#define BP_IOCTL_SET_PVID 	_IOW(BP_IOCTL_BASE, 0x06, int)
-#define BP_IOCTL_GET_BPID 	_IOR(BP_IOCTL_BASE, 0x07, int)
-#define BP_IOCTL_GET_IMEI 	_IOR(BP_IOCTL_BASE, 0x08, int)
-
-enum bp_id{
-	BP_ID_INVALID = 0,//no bp
-		
-	BP_ID_MT6229,	//1 USI MT6229 WCDMA
-	BP_ID_MU509,	//2 huawei MU509 WCDMA
-	BP_ID_MI700,	//3 thinkwill MI700 WCDMA
-	BP_ID_MW100,	//4 thinkwill MW100 WCDMA
-	BP_ID_TD8801,	//5 spreadtrum SC8803 TD-SCDMA
-	BP_ID_SC6610,	//6 spreadtrum SC6610 GSM
-	BP_ID_M51,	//7 RDA GSM
-	BP_ID_MT6250,   //8 ZINN M50  EDGE
-	BP_ID_C66A,     //9 ZHIGUAN C66A GSM
-	BP_ID_SEW290,   //10 SCV SEW290 WCDMA
-	BP_ID_U5501,    //11 LONGSUNG U5501 WCDMA
-	BP_ID_U7501,    //12 LONGSUNG U7501 WCDMA/HSPA+
-	BP_ID_AW706,    //13 ANICARE AW706 EDGE
-	BP_ID_A85XX,    //14 LONGSUNG A8520/A8530 GSM
-    BP_ID_E1230S,    //15 huawei E1230S
-
-	BP_ID_NUM,  
-};
-
-
-
-enum bp_bus_type{
-	BP_BUS_TYPE_INVALID = 0,
-		
-	BP_BUS_TYPE_UART,
-	BP_BUS_TYPE_SPI,
-	BP_BUS_TYPE_USB,
-	BP_BUS_TYPE_SDIO,
-	BP_BUS_TYPE_USB_UART,
-	BP_BUS_TYPE_SPI_UART,
-	BP_BUS_TYPE_SDIO_UART,
-	
-	BP_BUS_TYPE_NUM_ID,
-};
-
-struct bp_platform_data {	
-	int board_id;
-	int bp_id;
-	int (*init_platform_hw)(void);		
-	int (*exit_platform_hw)(void);	
-	int (*get_bp_id)(void);
-	int bp_power;
-	int bp_en;
-	int bp_reset;
-	int ap_ready;
-	int bp_ready;
-	int ap_wakeup_bp;
-	int bp_wakeup_ap;
-	int bp_assert;
-	int bp_usb_en;
-	int bp_uart_en;
-	
-	int gpio_valid;
-};
-
-
-struct bp_operate {
-	char *name;	//bp name can be null
-	int bp_id;	//bp id the value must be one of enum bp_id
-	int bp_bus;	// bp bus the value must be one of enum bp_bus_type
-	
-	int bp_pid;	// the pid of usb device if used usb else the value is BP_UNKNOW_DATA
-	int bp_vid;	// the vid of usb device if used usb else the value is BP_UNKNOW_DATA
-	int bp_power;//bp power if used GPIO value else the  is BP_UNKNOW_DATA
-	int bp_en;//bp power key if used GPIO value else the  is BP_UNKNOW_DATA
-	int bp_reset;//bo reset if used GPIO value else the  is BP_UNKNOW_DATA
-	int ap_ready;//bp ready  if used GPIO value else the  is BP_UNKNOW_DATA
-	int bp_ready;// bp ready  if used GPIO value else the  is BP_UNKNOW_DATA
-	int ap_wakeup_bp; //ap wakeup bp  if used GPIO value else the  is BP_UNKNOW_DATA
-	int bp_wakeup_ap;// bp wakeup ap  if used GPIO value else the  is BP_UNKNOW_DATA
-	int bp_assert;
-	int bp_usb_en;//not used
-	int bp_uart_en;//not used
-	int trig;//if 1:used board gpio define else used bp driver
-	int irq;
-
-	int (*active)(struct bp_private_data *bp, int enable);
-	int (*init)(struct bp_private_data *bp);
-	int (*reset)(struct bp_private_data *bp);
-	int (*ap_wake_bp)(struct bp_private_data *bp, int wake);
-	int (*bp_wake_ap)(struct bp_private_data *bp);
-	int (*shutdown)(struct bp_private_data *bp);
-	int (*read_status)(struct bp_private_data *bp);
-	int (*write_status)(struct bp_private_data *bp);
-	int (*suspend)(struct bp_private_data *bp);
-	int (*resume)(struct bp_private_data *bp);		
-	char *misc_name;
-	struct miscdevice *private_miscdev;
-	
-};
-
-
-struct bp_private_data {	
-	struct device *dev;
-	int status;
-	int suspend_status;
-	struct wake_lock bp_wakelock;
-	struct delayed_work wakeup_work;	/*report second event*/
-	struct bp_platform_data *pdata;
-	struct bp_operate *ops; 
-	struct file_operations fops;
-	struct miscdevice miscdev;
-	struct file_operations id_fops;
-	struct miscdevice id_miscdev;
-
-};
-
-extern int bp_register_slave(struct bp_private_data *bp,
-			struct bp_platform_data *slave_pdata,
-			struct bp_operate *(*get_bp_ops)(void));
-
-
-extern int bp_unregister_slave(struct bp_private_data *bp,
-			struct bp_platform_data *slave_pdata,
-			struct bp_operate *(*get_bp_ops)(void));
-
-
-#endif
-
-- 
2.35.3

