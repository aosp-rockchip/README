From be1a420e93bc223ef06c59c3f1d48273f5a82a6b Mon Sep 17 00:00:00 2001
From: "lw@rock-chips.com" <lw@rock-chips.com>
Date: Sat, 31 Mar 2012 18:41:52 +0800
Subject: [PATCH] rk30:add smart phone support

---
 arch/arm/configs/rk30_phone_defconfig        |  419 ++++++
 arch/arm/mach-rk29/board-rk29-a22.c          |    9 +
 arch/arm/mach-rk30/Kconfig                   |    3 +
 arch/arm/mach-rk30/Makefile                  |    1 +
 arch/arm/mach-rk30/board-rk30-phone-key.c    |  117 ++
 arch/arm/mach-rk30/board-rk30-phone-rfkill.c |  303 ++++
 arch/arm/mach-rk30/board-rk30-phone.c        | 1409 ++++++++++++++++++
 arch/arm/mach-rk30/board-rk30-wm831x.c       |  722 +++++++++
 drivers/video/backlight/Kconfig              |    2 +-
 drivers/video/backlight/aw9364_bl.c          |    3 +
 drivers/video/display/screen/lcd_nt35510.c   |   52 -
 11 files changed, 2987 insertions(+), 53 deletions(-)
 create mode 100755 arch/arm/configs/rk30_phone_defconfig
 mode change 100644 => 100755 arch/arm/mach-rk30/Kconfig
 mode change 100644 => 100755 arch/arm/mach-rk30/Makefile
 create mode 100755 arch/arm/mach-rk30/board-rk30-phone-key.c
 create mode 100755 arch/arm/mach-rk30/board-rk30-phone-rfkill.c
 create mode 100755 arch/arm/mach-rk30/board-rk30-phone.c
 create mode 100755 arch/arm/mach-rk30/board-rk30-wm831x.c
 mode change 100644 => 100755 drivers/video/backlight/Kconfig

diff --git a/arch/arm/configs/rk30_phone_defconfig b/arch/arm/configs/rk30_phone_defconfig
new file mode 100755
index 000000000000..6fd6891a4ed1
--- /dev/null
+++ b/arch/arm/configs/rk30_phone_defconfig
@@ -0,0 +1,419 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_ARCH_RK30=y
+CONFIG_DDR_SDRAM_FREQ=456
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_MACH_RK30_PHONE=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_HOTPLUG=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_RKNAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MISC_DEVICES=y
+CONFIG_UID_STAT=y
+CONFIG_APANIC=y
+CONFIG_MPU_SENSORS_TIMERIRQ=y
+CONFIG_INV_SENSORS=y
+CONFIG_MPU_SENSORS_MMA845X=y
+CONFIG_MPU_SENSORS_AK8975=y
+# CONFIG_INV_SENSORS_PRESSURE is not set
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN_80211=y
+CONFIG_RKWIFI=y
+CONFIG_BCM4330=y
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_INPUT_TABLET=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ILI2102_IIC=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_WM831X_ON=y
+CONFIG_MAG_SENSORS=y
+CONFIG_G_SENSOR_DEVICE=y
+# CONFIG_GS_MMA7660 is not set
+# CONFIG_GS_MMA8452 is not set
+CONFIG_GYRO_SENSOR_DEVICE=y
+CONFIG_LIGHT_SENSOR_DEVICE=y
+# CONFIG_SERIO is not set
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_CTS_RTS_RK29=y
+CONFIG_UART3_RK29=y
+CONFIG_UART3_CTS_RTS_RK29=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C0_CONTROLLER_RK30=y
+CONFIG_I2C1_CONTROLLER_RK30=y
+CONFIG_I2C2_CONTROLLER_RK30=y
+CONFIG_I2C3_CONTROLLER_RK30=y
+CONFIG_I2C4_CONTROLLER_RK30=y
+CONFIG_SPI=y
+CONFIG_SPIM_RK29=y
+CONFIG_SPIM0_RK29=y
+CONFIG_SPIM1_RK29=y
+CONFIG_GPIO_WM831X=y
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+CONFIG_SPI_FPGA_GPIO_NUM=0
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
+CONFIG_POWER_SUPPLY=y
+CONFIG_WM831X_BACKUP=y
+CONFIG_WM831X_POWER=y
+CONFIG_TEST_POWER=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_WM831X_I2C=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_WM831X=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_OV2659=y
+CONFIG_SOC_CAMERA_OV5642=y
+CONFIG_VIDEO_RK29=y
+CONFIG_ION=y
+CONFIG_ION_ROCKCHIP=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_RK29_BL is not set
+CONFIG_BACKLIGHT_AW9364=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_LCD_NT35510=y
+CONFIG_FB_ROCKCHIP=y
+CONFIG_LCDC_RK30=y
+CONFIG_RGA_RK30=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_I2S_DMA_EVENT_STATIC=y
+CONFIG_SND_RK29_SOC_RT5631=y
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_OTG_BLACKLIST_HUB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB20_HOST=y
+CONFIG_USB20_OTG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_SDMMC_RK29=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_WM831X=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_CMMB is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/mach-rk29/board-rk29-a22.c b/arch/arm/mach-rk29/board-rk29-a22.c
index 30b8de40e986..5c01f1131b22 100755
--- a/arch/arm/mach-rk29/board-rk29-a22.c
+++ b/arch/arm/mach-rk29/board-rk29-a22.c
@@ -241,6 +241,15 @@ static int rk29_lcd_io_init(void)
 	rk29_mux_api_set(GPIO1A4_EMMCWRITEPRT_SPI0CS1_NAME,GPIO1L_GPIO1A4);
 	rk29_mux_api_set(GPIO2C0_SPI0CLK_NAME,GPIO2H_GPIO2C0);
 
+
+	gpio_request(RK29_PIN6_PC6, NULL);
+	gpio_direction_output(RK29_PIN6_PC6, 1);
+	gpio_direction_output(RK29_PIN6_PC6, 0);
+	usleep_range(5*1000, 5*1000);
+	gpio_set_value(RK29_PIN6_PC6, 1);
+	usleep_range(50*1000, 50*1000);
+	gpio_free(RK29_PIN6_PC6);
+
 	return ret;
 }
 
diff --git a/arch/arm/mach-rk30/Kconfig b/arch/arm/mach-rk30/Kconfig
old mode 100644
new mode 100755
index 363b105e1a09..6a61d8e8574e
--- a/arch/arm/mach-rk30/Kconfig
+++ b/arch/arm/mach-rk30/Kconfig
@@ -7,6 +7,9 @@ choice
 config MACH_RK30_SDK
 	bool "RK30 SDK board"
 
+config MACH_RK30_PHONE
+	bool "RK30 smart phone board"
+
 endchoice
 
 endif
diff --git a/arch/arm/mach-rk30/Makefile b/arch/arm/mach-rk30/Makefile
old mode 100644
new mode 100755
index 40e98fa0ed40..695f8b079af5
--- a/arch/arm/mach-rk30/Makefile
+++ b/arch/arm/mach-rk30/Makefile
@@ -17,3 +17,4 @@ obj-$(CONFIG_PM) += pm.o
 obj-$(CONFIG_CPU_IDLE) += cpuidle.o
 
 obj-$(CONFIG_MACH_RK30_SDK) += board-rk30-sdk.o board-rk30-sdk-key.o board-rk30-sdk-rfkill.o
+obj-$(CONFIG_MACH_RK30_PHONE) += board-rk30-phone.o board-rk30-phone-key.o board-rk30-phone-rfkill.o
diff --git a/arch/arm/mach-rk30/board-rk30-phone-key.c b/arch/arm/mach-rk30/board-rk30-phone-key.c
new file mode 100755
index 000000000000..ab2bc3b322c1
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk30-phone-key.c
@@ -0,0 +1,117 @@
+#include <mach/gpio.h>
+#include <plat/key.h>
+
+#define EV_ENCALL				KEY_F4
+#define EV_MENU					KEY_F1
+
+#define PRESS_LEV_LOW			1
+#define PRESS_LEV_HIGH			0
+
+static struct rk29_keys_button key_button[] = {
+#if 0
+	{
+		.desc	= "menu",
+		.code	= EV_MENU,
+		.gpio	= RK30_PIN6_PA0,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "vol+",
+		.code	= KEY_VOLUMEUP,
+		.gpio	= RK30_PIN6_PA1,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+	{
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEDOWN,
+		.gpio	= RK30_PIN4_PC5,
+		.active_low = PRESS_LEV_LOW,
+	},
+#if 0
+	{
+		.desc	= "home",
+		.code	= KEY_HOME,
+		.gpio	= RK30_PIN6_PA3,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "search",
+		.code	= KEY_SEARCH,
+		.gpio	= RK30_PIN6_PA4,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_BACK,
+		.gpio	= RK30_PIN6_PA5,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "sensor",
+		.code	= KEY_CAMERA,
+		.gpio	= RK30_PIN6_PA6,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+	{
+		.desc	= "play",
+		.code	= KEY_POWER,
+		.gpio	= RK30_PIN6_PA2,
+		.active_low = PRESS_LEV_LOW,
+		//.code_long_press = EV_ENCALL,
+		.wakeup	= 1,
+	},
+#if 1
+	{
+		.desc	= "vol+",
+		.code	= KEY_VOLUMEUP,
+		.adc_value	= 1,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#if 0
+	{
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEUP,
+		.adc_value	= 249,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+	{
+		.desc	= "menu",
+		.code	= EV_MENU,
+		.adc_value	= 155,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "home",
+		.code	= KEY_HOME,
+		.adc_value	= 630,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_BACK,
+		.adc_value	= 386,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "camera",
+		.code	= KEY_CAMERA,
+		.adc_value	= 827,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+};
+struct rk29_keys_platform_data rk29_keys_pdata = {
+	.buttons	= key_button,
+	.nbuttons	= ARRAY_SIZE(key_button),
+	.chn	= 1,  //chn: 0-7, if do not use ADC,set 'chn' -1
+};
+
diff --git a/arch/arm/mach-rk30/board-rk30-phone-rfkill.c b/arch/arm/mach-rk30/board-rk30-phone-rfkill.c
new file mode 100755
index 000000000000..de932c8dcdfe
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk30-phone-rfkill.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ * Author: roger_chen <cz@rock-chips.com>
+ *
+ * This program is the bluetooth device bcm4330's driver,
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <mach/gpio.h>
+#include <asm/irq.h>
+#include <mach/iomux.h>
+#include <linux/wakelock.h>
+#include <linux/timer.h>
+
+#if 0
+#define DBG(x...)   printk(KERN_INFO x)
+#else
+#define DBG(x...)
+#endif
+
+#define BT_WAKE_HOST_SUPPORT 0
+
+struct bt_ctrl
+{
+    struct rfkill *bt_rfk;
+#if BT_WAKE_HOST_SUPPORT
+    struct timer_list tl;
+    bool b_HostWake;
+    struct wake_lock bt_wakelock;
+#endif
+};
+
+//#define BT_GPIO_POWER           RK30_PIN3_PC7
+//#define IOMUX_BT_GPIO_POWER     rk29_mux_api_set(GPIO3C7_SDMMC1WRITEPRT_NAME, GPIO3C_GPIO3C7);
+#define BT_GPIO_POWER          	RK30_PIN3_PD1
+#define IOMUX_BT_GPIO_POWER     rk29_mux_api_set(GPIO3D1_SDMMC1BACKENDPWR_NAME, GPIO3D_GPIO3D1);
+
+#ifdef CONFIG_BT_HCIBCM4325
+#define BT_GPIO_WAKE_UP         RK30_PIN3_PC6
+#endif
+
+#if BT_WAKE_HOST_SUPPORT
+#define BT_GPIO_WAKE_UP_HOST    //RK2818_PIN_PA7
+#define IOMUX_BT_GPIO_WAKE_UP_HOST() //rk2818_mux_api_set(GPIOA7_FLASHCS3_SEL_NAME,0);
+
+#define BT_WAKE_LOCK_TIMEOUT    10 //s
+#endif
+
+static const char bt_name[] = "bcm4330";
+//extern int rk29sdk_bt_power_state;
+//extern int rk29sdk_wifi_power_state;
+
+struct bt_ctrl gBtCtrl;
+    
+#if BT_WAKE_HOST_SUPPORT
+void resetBtHostSleepTimer(void)
+{
+    mod_timer(&(gBtCtrl.tl),jiffies + BT_WAKE_LOCK_TIMEOUT*HZ);//再重新设置超时值。    
+}
+
+void btWakeupHostLock(void)
+{
+    if(gBtCtrl.b_HostWake == false){
+        DBG("*************************Lock\n");
+        wake_lock(&(gBtCtrl.bt_wakelock));
+        gBtCtrl.b_HostWake = true;
+    }
+}
+
+void btWakeupHostUnlock(void)
+{
+    if(gBtCtrl.b_HostWake == true){        
+        DBG("*************************UnLock\n");
+        wake_unlock(&(gBtCtrl.bt_wakelock));  //让系统睡眠    
+        gBtCtrl.b_HostWake = false;
+    }    
+}
+
+static void timer_hostSleep(unsigned long arg)
+{     
+	DBG("%s---b_HostWake=%d\n",__FUNCTION__,gBtCtrl.b_HostWake);
+    btWakeupHostUnlock();
+}
+
+
+#ifdef CONFIG_PM
+static int bcm4329_rfkill_suspend(struct platform_device *pdev, pm_message_t state)
+{   
+    DBG("%s\n",__FUNCTION__);  	
+    return 0;
+}
+
+static int bcm4329_rfkill_resume(struct platform_device *pdev)
+{  
+    DBG("%s\n",__FUNCTION__);     
+    btWakeupHostLock();
+    resetBtHostSleepTimer();
+    return 0;
+}
+#else
+#define bcm4329_rfkill_suspend NULL
+#define bcm4329_rfkill_resume  NULL
+#endif
+
+static irqreturn_t bcm4329_wake_host_irq(int irq, void *dev)
+{
+    btWakeupHostLock();
+    resetBtHostSleepTimer();
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_BT_HCIBCM4325
+int bcm4325_sleep(int bSleep)
+{
+    //printk("*************bt enter sleep***************\n");
+    if (bSleep)
+    gpio_set_value(BT_GPIO_WAKE_UP, GPIO_LOW);   //low represent bt device may enter sleep  
+    else
+    gpio_set_value(BT_GPIO_WAKE_UP, GPIO_HIGH);  //high represent bt device must be awake 
+    //printk("sleep=%d\n",bSleep);
+    return 0;
+}
+#endif
+  
+static int bcm4329_set_block(void *data, bool blocked)
+{
+    	DBG("%s---blocked :%d\n", __FUNCTION__, blocked);
+
+        IOMUX_BT_GPIO_POWER;
+//        IOMUX_BT_GPIO_RESET;
+
+    	if (false == blocked) {
+       		gpio_set_value(BT_GPIO_POWER, GPIO_HIGH);  /* bt power on */
+            
+//            gpio_set_value(BT_GPIO_RESET, GPIO_LOW);
+//            mdelay(20);
+//    		gpio_set_value(BT_GPIO_RESET, GPIO_HIGH);  /* bt reset deactive*/
+    		mdelay(20);
+        
+#if BT_WAKE_HOST_SUPPORT     
+            btWakeupHostLock();
+#endif         
+        	pr_info("bt turn on power\n");
+    	}
+    	else {
+#if BT_WAKE_HOST_SUPPORT     
+            btWakeupHostUnlock();
+#endif
+//    		if (!rk29sdk_wifi_power_state) {
+    			gpio_set_value(BT_GPIO_POWER, GPIO_LOW);  /* bt power off */
+        		mdelay(20);	
+        		pr_info("bt shut off power\n");
+//    		}else {
+//    			pr_info("bt shouldn't shut off power, wifi is using it!\n");
+//    		}
+
+//    		gpio_set_value(BT_GPIO_RESET, GPIO_LOW);  /* bt reset active*/
+//    		mdelay(20);
+    	}
+
+//    	rk29sdk_bt_power_state = !blocked;
+    	return 0;
+}
+
+
+static const struct rfkill_ops bcm4329_rfk_ops = {
+	.set_block = bcm4329_set_block,
+};
+
+static int __devinit bcm4329_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	bool default_state = true;
+	
+	DBG("Enter::%s,line=%d\n",__FUNCTION__,__LINE__);
+	
+	/* default to bluetooth off */
+ 	bcm4329_set_block(NULL, default_state); /* blocked -> bt off */
+	 
+	gBtCtrl.bt_rfk = rfkill_alloc(bt_name, 
+                NULL, 
+                RFKILL_TYPE_BLUETOOTH, 
+                &bcm4329_rfk_ops, 
+                NULL);
+
+	if (!gBtCtrl.bt_rfk)
+	{
+		printk("fail to rfkill_allocate************\n");
+		return -ENOMEM;
+	}
+	
+	rfkill_set_states(gBtCtrl.bt_rfk, default_state, false);
+
+	rc = rfkill_register(gBtCtrl.bt_rfk);
+	if (rc)
+	{
+		printk("failed to rfkill_register,rc=0x%x\n",rc);
+		rfkill_destroy(gBtCtrl.bt_rfk);
+	}
+	
+	gpio_request(BT_GPIO_POWER, NULL);
+//	gpio_request(BT_GPIO_RESET, NULL);
+#ifdef CONFIG_BT_HCIBCM4325
+	gpio_request(BT_GPIO_WAKE_UP, NULL);
+#endif
+
+#if BT_WAKE_HOST_SUPPORT
+    init_timer(&(gBtCtrl.tl));
+    gBtCtrl.tl.expires = jiffies + BT_WAKE_LOCK_TIMEOUT*HZ;        
+    gBtCtrl.tl.function = timer_hostSleep;        
+    add_timer(&(gBtCtrl.tl));
+    gBtCtrl.b_HostWake = false;
+    
+	wake_lock_init(&(gBtCtrl.bt_wakelock), WAKE_LOCK_SUSPEND, "bt_wake");
+	
+	rc = gpio_request(BT_GPIO_WAKE_UP_HOST, "bt_wake");
+	if (rc) {
+		printk("%s:failed to request RAHO_BT_WAKE_UP_HOST\n",__FUNCTION__);
+	}
+	
+	IOMUX_BT_GPIO_WAKE_UP_HOST();
+	gpio_pull_updown(BT_GPIO_WAKE_UP_HOST,GPIOPullUp);
+	rc = request_irq(gpio_to_irq(BT_GPIO_WAKE_UP_HOST),bcm4329_wake_host_irq,IRQF_TRIGGER_FALLING,NULL,NULL);
+	if(rc)
+	{
+		printk("%s:failed to request RAHO_BT_WAKE_UP_HOST irq\n",__FUNCTION__);
+		gpio_free(BT_GPIO_WAKE_UP_HOST);
+	}
+	enable_irq_wake(gpio_to_irq(BT_GPIO_WAKE_UP_HOST)); // so RAHO_BT_WAKE_UP_HOST can wake up system
+
+	printk(KERN_INFO "bcm4329 module has been initialized,rc=0x%x\n",rc);
+ #endif
+ 
+	return rc;
+}
+
+
+static int __devexit bcm4329_rfkill_remove(struct platform_device *pdev)
+{
+	if (gBtCtrl.bt_rfk)
+		rfkill_unregister(gBtCtrl.bt_rfk);
+	gBtCtrl.bt_rfk = NULL;
+#if BT_WAKE_HOST_SUPPORT	
+    del_timer(&(gBtCtrl.tl));//删掉定时器
+    btWakeupHostUnlock();
+    wake_lock_destroy(&(gBtCtrl.bt_wakelock));
+#endif    
+	platform_set_drvdata(pdev, NULL);
+
+	DBG("Enter::%s,line=%d\n",__FUNCTION__,__LINE__);
+	return 0;
+}
+
+static struct platform_driver bcm4329_rfkill_driver = {
+	.probe = bcm4329_rfkill_probe,
+	.remove = __devexit_p(bcm4329_rfkill_remove),
+	.driver = {
+		.name = "rk29sdk_rfkill", 
+		.owner = THIS_MODULE,
+	},	
+#if BT_WAKE_HOST_SUPPORT
+    .suspend = bcm4329_rfkill_suspend,
+    .resume = bcm4329_rfkill_resume,
+#endif
+};
+
+/*
+ * Module initialization
+ */
+static int __init bcm4329_mod_init(void)
+{
+	int ret;
+	DBG("Enter::%s,line=%d\n",__FUNCTION__,__LINE__);
+	ret = platform_driver_register(&bcm4329_rfkill_driver);
+    	printk("ret=0x%x\n", ret);
+	return ret;
+}
+
+static void __exit bcm4329_mod_exit(void)
+{
+	platform_driver_unregister(&bcm4329_rfkill_driver);
+}
+
+module_init(bcm4329_mod_init);
+module_exit(bcm4329_mod_exit);
+MODULE_DESCRIPTION("bcm4330 Bluetooth driver");
+MODULE_AUTHOR("roger_chen cz@rock-chips.com, cmy@rock-chips.com");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-rk30/board-rk30-phone.c b/arch/arm/mach-rk30/board-rk30-phone.c
new file mode 100755
index 000000000000..6f1c4dbba20c
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk30-phone.c
@@ -0,0 +1,1409 @@
+/* arch/arm/mach-rk30/board-rk30-sdk.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ion.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <linux/mpu.h>
+
+
+#if defined(CONFIG_SPIM_RK29)
+#include "../../../drivers/spi/rk29_spim.h"
+#endif
+#if defined(CONFIG_ANDROID_TIMED_GPIO)
+#include "../../../drivers/staging/android/timed_gpio.h"
+#endif
+#if defined(CONFIG_BACKLIGHT_AW9364)
+#include "../../../drivers/video/backlight/aw9364_bl.h"
+#endif
+
+
+#define RK30_FB0_MEM_SIZE 8*SZ_1M
+
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0x78
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  4
+#define CONFIG_SENSOR_CIF_INDEX_0                    1
+#define CONFIG_SENSOR_ORIENTATION_0 	  90
+#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK30_PIN1_PD6
+#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_01                    1
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       RK30_PIN1_PD6
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_02                    1
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       RK30_PIN1_PD6
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	    0x60
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK30_PIN1_PB7
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_11       270
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       RK30_PIN1_PB7
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       RK30_PIN1_PB7
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk30_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   0
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,//rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = NULL,//rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = 0,//sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+    },{
+        .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,//rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = NULL,//rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = 0,//sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+    }
+
+ };
+#include "../../../drivers/media/video/rk30_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
+
+#if defined(CONFIG_TOUCHSCREEN_ILI2102_IIC) 
+#include "../../../drivers/input/touchscreen/ili2102_ts.h"
+#define TOUCH_GPIO_INT      RK30_PIN4_PC2
+#define TOUCH_GPIO_RESET    RK30_PIN4_PD0
+static struct ili2102_platform_data ili2102_info = {
+	.model			= 2102,
+	.swap_xy		= 0,
+	.x_min			= 0,
+	.x_max			= 480,
+	.y_min			= 0,
+	.y_max			= 800,
+	.gpio_reset     = TOUCH_GPIO_RESET,
+	.gpio_reset_active_low = 1,
+	.gpio_pendown		= TOUCH_GPIO_RESET,
+	.pendown_iomux_name = GPIO4C2_SMCDATA2_TRACEDATA2_NAME,
+	.resetpin_iomux_name = GPIO4D0_SMCDATA8_TRACEDATA8_NAME,
+	.pendown_iomux_mode = GPIO4C_GPIO4C2,
+	.resetpin_iomux_mode = GPIO4D_GPIO4D0,
+};
+#endif
+
+
+#if defined(CONFIG_TOUCHSCREEN_GT8XX)
+#define TOUCH_RESET_PIN  RK30_PIN4_PD0
+#define TOUCH_PWR_PIN    INVALID_GPIO
+int goodix_init_platform_hw(void)
+{
+	int ret;
+	
+	rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME, GPIO4D_GPIO4D0);
+	rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME, GPIO4C_GPIO4C2);
+	printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO4D0_SMCDATA8_TRACEDATA8_NAME),rk30_mux_api_get(GPIO4C2_SMCDATA2_TRACEDATA2_NAME));
+
+	if (TOUCH_PWR_PIN != INVALID_GPIO) {
+		ret = gpio_request(TOUCH_PWR_PIN, "goodix power pin");
+		if (ret != 0) {
+			gpio_free(TOUCH_PWR_PIN);
+			printk("goodix power error\n");
+			return -EIO;
+		}
+		gpio_direction_output(TOUCH_PWR_PIN, 0);
+		gpio_set_value(TOUCH_PWR_PIN, GPIO_LOW);
+		msleep(100);
+	}
+
+	if (TOUCH_RESET_PIN != INVALID_GPIO) {
+		ret = gpio_request(TOUCH_RESET_PIN, "goodix reset pin");
+		if (ret != 0) {
+			gpio_free(TOUCH_RESET_PIN);
+			printk("goodix gpio_request error\n");
+			return -EIO;
+		}
+		gpio_direction_output(TOUCH_RESET_PIN, 0);
+		gpio_set_value(TOUCH_RESET_PIN, GPIO_LOW);
+		msleep(10);
+		gpio_set_value(TOUCH_RESET_PIN, GPIO_HIGH);
+		msleep(500);
+	}
+	return 0;
+}
+
+struct goodix_platform_data goodix_info = {
+	.model = 8105,
+	.irq_pin = RK30_PIN4_PC2,
+	.rest_pin = TOUCH_RESET_PIN,
+	.init_platform_hw = goodix_init_platform_hw,
+};
+#endif
+
+static struct spi_board_info board_spi_devices[] = {
+};
+
+/***********************************************************
+*	rk30  backlight
+************************************************************/
+#ifdef CONFIG_BACKLIGHT_AW9364
+static int aw9364_backlight_io_init(void)
+{
+	rk30_mux_api_set(GPIO4D2_SMCDATA10_TRACEDATA10_NAME, GPIO4D_GPIO4D2);
+	return 0;
+}
+
+static int aw9364_backlight_io_deinit(void)
+{
+	return 0;
+}
+struct aw9364_platform_data aw9364_bl_info = {
+	.pin_en   = RK30_PIN4_PD2,
+	.io_init   = aw9364_backlight_io_init,
+	.io_deinit = aw9364_backlight_io_deinit,
+};
+
+struct platform_device aw9364_device_backlight = {
+	.name = "aw9364_backlight",
+	.id = -1,		
+	.dev		= {
+	.platform_data = &aw9364_bl_info,	
+	}			
+};
+	
+#endif
+
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+#define PWM_ID            0
+#define PWM_MUX_NAME      GPIO0A3_PWM0_NAME
+#define PWM_MUX_MODE      GPIO0A_PWM0
+#define PWM_MUX_MODE_GPIO GPIO0A_GPIO0A3
+#define PWM_GPIO 	  RK30_PIN0_PA3
+#define PWM_EFFECT_VALUE  1
+
+#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+//#define BL_EN_MUX_NAME    GPIOF34_UART3_SEL_NAME
+//#define BL_EN_MUX_MODE    IOMUXB_GPIO1_B34
+
+#define BL_EN_PIN         RK30_PIN6_PB3
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+
+	ret = gpio_request(BL_EN_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(BL_EN_PIN);
+	}
+
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+	int ret = 0;
+#ifdef  LCD_DISP_ON_PIN
+	gpio_free(BL_EN_PIN);
+#endif
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	return ret;
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	if (gpio_request(PWM_GPIO, NULL)) {
+		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	gpio_direction_output(PWM_GPIO, GPIO_LOW);
+#ifdef  LCD_DISP_ON_PIN
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	gpio_free(PWM_GPIO);
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	msleep(30);
+	gpio_direction_output(BL_EN_PIN, 1);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return 0;
+}
+
+static struct rk29_bl_info rk29_bl_info = {
+	.pwm_id = PWM_ID,
+	.bl_ref = PWM_EFFECT_VALUE,
+	.io_init = rk29_backlight_io_init,
+	.io_deinit = rk29_backlight_io_deinit,
+	.pwm_suspend = rk29_backlight_pwm_suspend,
+	.pwm_resume = rk29_backlight_pwm_resume,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+
+#endif
+
+/*MMA8452 gsensor*/
+#if defined (CONFIG_GS_MMA8452)
+#define MMA8452_INT_PIN   RK30_PIN4_PC0
+
+static int mma8452_init_platform_hw(void)
+{
+	rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
+
+	if (gpio_request(MMA8452_INT_PIN, NULL) != 0) {
+		gpio_free(MMA8452_INT_PIN);
+		printk("mma8452_init_platform_hw gpio_request error\n");
+		return -EIO;
+	}
+	gpio_pull_updown(MMA8452_INT_PIN, 1);
+	return 0;
+}
+
+static struct mma8452_platform_data mma8452_info = {
+	.model = 8452,
+	.swap_xy = 0,
+	.swap_xyz = 1,
+	.init_platform_hw = mma8452_init_platform_hw,
+	.orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
+};
+#endif
+#if defined (CONFIG_COMPASS_AK8975)
+static struct akm8975_platform_data akm8975_info =
+{
+	.m_layout = 
+	{
+		{
+			{-1, 0, 0},
+			{0, 0, 1},
+			{0, -1, 0},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+
+		{
+			{1, 0, 0},
+			{0, 1, 0},
+			{0, 0, 1},
+		},
+	}
+};
+
+#endif
+
+/*mpu3050*/
+#if defined (CONFIG_MPU_SENSORS_MPU3050)
+static struct mpu_platform_data mpu3050_data = {
+	.int_config = 0x10,
+	.orientation = { 1, 0, 0,0, 1, 0, 0, 0, 1 },
+};
+#endif
+
+/* accel */
+#if defined (CONFIG_MPU_SENSORS_MMA845X)
+static struct ext_slave_platform_data inv_mpu_mma845x_data = {
+	.bus         = EXT_SLAVE_BUS_SECONDARY,
+	.adapt_num = 0,
+	.orientation = {1, 0, 0, 0, 1, 0, 0, 0, 1},
+};
+#endif
+
+/* compass */
+#if defined (CONFIG_MPU_SENSORS_AK8975)
+static struct ext_slave_platform_data inv_mpu_ak8975_data = {
+	.bus         = EXT_SLAVE_BUS_PRIMARY,
+	.adapt_num = 0,
+	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
+};
+#endif
+
+
+#if defined(CONFIG_GYRO_L3G4200D)
+
+#include <linux/l3g4200d.h>
+#define L3G4200D_INT_PIN  RK30_PIN4_PC3
+
+static int l3g4200d_init_platform_hw(void)
+{
+	if (gpio_request(L3G4200D_INT_PIN, NULL) != 0) {
+		gpio_free(L3G4200D_INT_PIN);
+		printk("%s: request l3g4200d int pin error\n", __func__);
+		return -EIO;
+	}
+	gpio_pull_updown(L3G4200D_INT_PIN, 1);
+	return 0;
+}
+
+static struct l3g4200d_platform_data l3g4200d_info = {
+	.fs_range = 1,
+
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+
+	.negate_x = 1,
+	.negate_y = 1,
+	.negate_z = 0,
+
+	.init = l3g4200d_init_platform_hw,
+};
+
+#endif
+
+
+
+#ifdef CONFIG_LS_CM3217
+
+#define CM3217_POWER_PIN 	INVALID_GPIO
+#define CM3217_IRQ_PIN		INVALID_GPIO
+static int cm3217_init_hw(void)
+{
+#if 0
+	if (gpio_request(CM3217_POWER_PIN, NULL) != 0) {
+		gpio_free(CM3217_POWER_PIN);
+		printk("%s: request cm3217 power pin error\n", __func__);
+		return -EIO;
+	}
+	gpio_pull_updown(CM3217_POWER_PIN, PullDisable);
+
+	if (gpio_request(CM3217_IRQ_PIN, NULL) != 0) {
+		gpio_free(CM3217_IRQ_PIN);
+		printk("%s: request cm3217 int pin error\n", __func__);
+		return -EIO;
+	}
+	gpio_pull_updown(CM3217_IRQ_PIN, PullDisable);
+#endif
+	return 0;
+}
+
+static void cm3217_exit_hw(void)
+{
+#if 0
+	gpio_free(CM3217_POWER_PIN);
+	gpio_free(CM3217_IRQ_PIN);
+#endif
+	return;
+}
+
+static struct cm3217_platform_data cm3217_info = {
+	.irq_pin = CM3217_IRQ_PIN,
+	.power_pin = CM3217_POWER_PIN,
+	.init_platform_hw = cm3217_init_hw,
+	.exit_platform_hw = cm3217_exit_hw,
+};
+#endif
+
+#ifdef CONFIG_FB_ROCKCHIP
+
+/*****************************************************************************************
+ * lcd  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+//#ifdef  CONFIG_LCD_TD043MGEA1
+
+#define LCD_TXD_PIN		RK30_PIN0_PB7
+#define LCD_CLK_PIN		RK30_PIN0_PB6
+#define LCD_CS_PIN		RK30_PIN0_PB5
+#define LCD_RST_PIN		RK30_PIN4_PC7
+
+/*****************************************************************************************
+* frame buffer  devices
+* author: zyw@rock-chips.com
+*****************************************************************************************/
+#define FB_ID                       0
+#define FB_DISPLAY_ON_PIN           INVALID_GPIO//RK29_PIN6_PD0
+#define FB_LCD_STANDBY_PIN          INVALID_GPIO//RK29_PIN6_PD1
+#define FB_LCD_CABC_EN_PIN          INVALID_GPIO//RK29_PIN6_PD2
+#define FB_MCU_FMK_PIN              INVALID_GPIO
+
+#define FB_DISPLAY_ON_VALUE         GPIO_HIGH
+#define FB_LCD_STANDBY_VALUE        GPIO_HIGH
+
+
+//#endif
+static int rk29_lcd_io_init(void)
+{
+	int ret = 0;
+	//printk("rk29_lcd_io_init\n");
+	//ret = gpio_request(LCD_RXD_PIN, NULL);
+	ret = gpio_request(LCD_TXD_PIN, NULL);
+	ret = gpio_request(LCD_CLK_PIN, NULL);
+	ret = gpio_request(LCD_CS_PIN, NULL);
+
+	rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME, GPIO0B_GPIO0B7);
+	rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME, GPIO0B_GPIO0B6);
+	rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME, GPIO0B_GPIO0B5);
+	
+
+	gpio_request(LCD_RST_PIN, NULL);
+	gpio_direction_output(LCD_RST_PIN, 1);
+	gpio_direction_output(LCD_RST_PIN, 0);
+	usleep_range(5*1000, 5*1000);
+	gpio_set_value(LCD_RST_PIN, 1);
+	usleep_range(50*1000, 50*1000);
+	gpio_free(LCD_RST_PIN);
+
+	return ret;
+}
+
+#if defined (CONFIG_RK29_WORKING_POWER_MANAGEMENT)
+static int rk29_lcd_io_deinit(void)
+{
+	int ret = 0;
+	
+	gpio_direction_output(LCD_TXD_PIN, 1);
+	gpio_direction_output(LCD_CLK_PIN, 1);
+
+	gpio_free(LCD_CS_PIN);
+	gpio_free(LCD_CLK_PIN);
+	gpio_free(LCD_TXD_PIN);
+
+	return ret;
+}
+#else
+static int rk29_lcd_io_deinit(void)
+{
+	int ret = 0;
+	//printk("rk29_lcd_io_deinit\n");
+	gpio_free(LCD_CS_PIN);
+	gpio_free(LCD_CLK_PIN);
+	gpio_free(LCD_TXD_PIN);
+	//gpio_free(LCD_RXD_PIN);
+
+	//rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME, GPIO0B_GPIO0B7);
+	//rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME, GPIO0B_GPIO0B6);
+	//rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME, GPIO0B_GPIO0B5);
+
+	return ret;
+}
+#endif
+
+
+static struct rk29lcd_info rk29_lcd_info = {
+    .txd_pin  = LCD_TXD_PIN,
+    .clk_pin = LCD_CLK_PIN,
+    .cs_pin = LCD_CS_PIN,
+    .io_init   = rk29_lcd_io_init,
+    .io_deinit = rk29_lcd_io_deinit,
+};
+
+
+
+#define LCD_EN_MUX_NAME    GPIO4C7_SMCDATA7_TRACEDATA7_NAME
+#define LCD_EN_PIN         RK30_PIN4_PC7
+#define LCD_EN_VALUE       GPIO_HIGH
+
+static int rk_fb_io_init(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(LCD_EN_MUX_NAME, GPIO4C_GPIO4C7);
+	ret = gpio_request(LCD_EN_PIN, NULL);
+	if (ret != 0)
+	{
+		gpio_free(LCD_EN_PIN);
+		printk(KERN_ERR "request lcd en pin fail!\n");
+		return -1;
+	}
+	else
+	{
+		gpio_direction_output(LCD_EN_PIN, 1);
+		gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+	}
+	return 0;
+}
+static int rk_fb_io_disable(void)
+{
+	gpio_set_value(LCD_EN_PIN, ~LCD_EN_VALUE);
+	return 0;
+}
+static int rk_fb_io_enable(void)
+{
+	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+	return 0;
+}
+
+
+static struct rk29fb_info rk_fb_info = {
+	.fb_id   = FB_ID,
+    	.mcu_fmk_pin = FB_MCU_FMK_PIN,
+    	.lcd_info = &rk29_lcd_info,
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+};
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+	.dev            = {
+		.platform_data  = &rk_fb_info,
+	}
+};
+#endif
+
+#ifdef CONFIG_ANDROID_TIMED_GPIO
+static struct timed_gpio timed_gpios[] = {
+	{
+		.name = "vibrator",
+		.gpio = RK30_PIN0_PA4,
+		.max_timeout = 1000,
+		.active_low = 0,
+		.adjust_time =20,      //adjust for diff product
+	},
+};
+
+static struct timed_gpio_platform_data rk29_vibrator_info = {
+	.num_gpios = 1,
+	.gpios = timed_gpios,
+};
+
+static struct platform_device rk29_device_vibrator = {
+	.name = "timed-gpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &rk29_vibrator_info,
+	},
+
+};
+#endif
+
+#ifdef CONFIG_LEDS_GPIO_PLATFORM
+static struct gpio_led rk29_leds[] = {
+	{
+		.name = "button-backlight",
+		.gpio = RK30_PIN4_PD7,
+		.default_trigger = "timer",
+		.active_low = 0,
+		.retain_state_suspended = 0,
+		.default_state = LEDS_GPIO_DEFSTATE_OFF,
+	},
+};
+
+static struct gpio_led_platform_data rk29_leds_pdata = {
+	.leds = rk29_leds,
+	.num_leds = ARRAY_SIZE(rk29_leds),
+};
+
+static struct platform_device rk29_device_gpio_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data  = &rk29_leds_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_RK_IRDA
+#define IRDA_IRQ_PIN           RK30_PIN6_PA1
+
+static int irda_iomux_init(void)
+{
+	int ret = 0;
+
+	//irda irq pin
+	ret = gpio_request(IRDA_IRQ_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(IRDA_IRQ_PIN);
+		printk(">>>>>> IRDA_IRQ_PIN gpio_request err \n ");
+	}
+	gpio_pull_updown(IRDA_IRQ_PIN, PullDisable);
+	gpio_direction_input(IRDA_IRQ_PIN);
+
+	return 0;
+}
+
+static int irda_iomux_deinit(void)
+{
+	gpio_free(IRDA_IRQ_PIN);
+	return 0;
+}
+
+static struct irda_info rk29_irda_info = {
+	.intr_pin = IRDA_IRQ_PIN,
+	.iomux_init = irda_iomux_init,
+	.iomux_deinit = irda_iomux_deinit,
+	//.irda_pwr_ctl = bu92747guw_power_ctl,
+};
+
+static struct platform_device irda_device = {
+#ifdef CONFIG_RK_IRDA_NET
+	.name = "rk_irda",
+#else
+	.name = "bu92747_irda",
+#endif
+	.id = -1,
+	.dev = {
+		.platform_data = &rk29_irda_info,
+	}
+};
+#endif
+
+#ifdef CONFIG_ION
+#define ION_RESERVE_SIZE        (80 * SZ_1M)
+static struct ion_platform_data rk30_ion_pdata = {
+	.nr = 1,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = ION_NOR_HEAP_ID,
+			.name = "norheap",
+			.size = ION_RESERVE_SIZE,
+		}
+	},
+};
+
+static struct platform_device device_ion = {
+	.name = "ion-rockchip",
+	.id = 0,
+	.dev = {
+		.platform_data = &rk30_ion_pdata,
+	},
+};
+#endif
+
+/**************************************************************************************************
+ * SDMMC devices,  include the module of SD,MMC,and sdio.noted by xbw at 2012-03-05
+**************************************************************************************************/
+#ifdef CONFIG_SDMMC_RK29
+#include "board-rk30-sdk-sdmmc.c"
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+#define SDMMC0_WRITE_PROTECT_PIN	RK30_PIN3_PB7	//According to your own project to set the value of write-protect-pin.
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+#define SDMMC1_WRITE_PROTECT_PIN	RK30_PIN3_PC7	//According to your own project to set the value of write-protect-pin.
+#endif
+
+#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK30_PIN6_PB2
+
+#endif //endif ---#ifdef CONFIG_SDMMC_RK29
+
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+#ifdef CONFIG_SDMMC_RK29_OLD
+	rk30_mux_api_set(GPIO3B1_SDMMC0CMD_NAME, GPIO3B_SDMMC0_CMD);
+	rk30_mux_api_set(GPIO3B0_SDMMC0CLKOUT_NAME, GPIO3B_SDMMC0_CLKOUT);
+	rk30_mux_api_set(GPIO3B2_SDMMC0DATA0_NAME, GPIO3B_SDMMC0_DATA0);
+	rk30_mux_api_set(GPIO3B3_SDMMC0DATA1_NAME, GPIO3B_SDMMC0_DATA1);
+	rk30_mux_api_set(GPIO3B4_SDMMC0DATA2_NAME, GPIO3B_SDMMC0_DATA2);
+	rk30_mux_api_set(GPIO3B5_SDMMC0DATA3_NAME, GPIO3B_SDMMC0_DATA3);
+
+	rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME, GPIO3B_GPIO3B6);
+
+	rk30_mux_api_set(GPIO3A7_SDMMC0PWREN_NAME, GPIO3A_GPIO3A7);
+	gpio_request(RK30_PIN3_PA7, "sdmmc-power");
+	gpio_direction_output(RK30_PIN3_PA7, GPIO_LOW);
+
+#else
+	rk29_sdmmc_set_iomux(0, 0xFFFF);
+
+	rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME, GPIO3B_SDMMC0_DETECT_N);
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
+	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+	.detect_irq = RK30_PIN3_PB6,	// INVALID_GPIO
+	.enable_sd_wakeup = 0,
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+};
+#endif // CONFIG_SDMMC0_RK29
+
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+#if defined(CONFIG_SDMMC_RK29_OLD)
+	rk30_mux_api_set(GPIO3C0_SMMC1CMD_NAME, GPIO3C_SMMC1_CMD);
+	rk30_mux_api_set(GPIO3C5_SDMMC1CLKOUT_NAME, GPIO3C_SDMMC1_CLKOUT);
+	rk30_mux_api_set(GPIO3C1_SDMMC1DATA0_NAME, GPIO3C_SDMMC1_DATA0);
+	rk30_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME, GPIO3C_SDMMC1_DATA1);
+	rk30_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME, GPIO3C_SDMMC1_DATA2);
+	rk30_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME, GPIO3C_SDMMC1_DATA3);
+	//rk30_mux_api_set(GPIO3C6_SDMMC1DETECTN_NAME, GPIO3C_SDMMC1_DETECT_N);
+
+#else
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
+	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34),
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
+		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#else
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#endif
+
+	.io_init = rk29_sdmmc1_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	.status = rk29sdk_wifi_status,
+	.register_status_notify = rk29sdk_wifi_status_register,
+#endif
+#if 0
+	.detect_irq = RK29SDK_WIFI_SDIO_CARD_DETECT_N,
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+#else
+	.detect_irq = INVALID_GPIO,
+	.enable_sd_wakeup = 0,
+#endif
+
+};
+#endif //endif--#ifdef CONFIG_SDMMC1_RK29
+
+/* bluetooth rfkill device */
+static struct platform_device rk29sdk_rfkill = {
+        .name = "rk29sdk_rfkill",
+        .id = -1,
+};
+
+/**************************************************************************************************
+ * the end of setting for SDMMC devices
+**************************************************************************************************/
+
+static struct platform_device *devices[] __initdata = {
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	&rk29_device_backlight,
+#endif
+#ifdef CONFIG_BACKLIGHT_AW9364
+	&aw9364_device_backlight,
+#endif
+#ifdef CONFIG_FB_ROCKCHIP
+	&device_fb,
+#endif
+#ifdef CONFIG_ION
+	&device_ion,
+#endif
+#ifdef CONFIG_ANDROID_TIMED_GPIO
+	&rk29_device_vibrator,
+#endif
+#ifdef CONFIG_LEDS_GPIO_PLATFORM
+	&rk29_device_gpio_leds,
+#endif
+#ifdef CONFIG_RK_IRDA
+	&irda_device,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	&rk29sdk_wifi_device,
+#endif
+#ifdef CONFIG_BT
+    &rk29sdk_rfkill,
+#endif
+};
+
+// i2c
+#ifdef CONFIG_I2C0_RK30
+static struct i2c_board_info __initdata i2c0_info[] = {
+#if defined (CONFIG_GS_MMA8452)
+	{
+		.type	        = "gs_mma8452",
+		.addr	        = 0x1d,
+		.flags	        = 0,
+		.irq	        = MMA8452_INT_PIN,
+		.platform_data = &mma8452_info,
+	},
+#endif
+#if defined (CONFIG_COMPASS_AK8975)
+	{
+		.type          = "ak8975",
+		.addr          = 0x0d,
+		.flags         = 0,
+		.irq           = RK30_PIN4_PC1,
+		.platform_data = &akm8975_info,
+	},
+#endif
+#if defined (CONFIG_GYRO_L3G4200D)
+	{
+		.type          = "l3g4200d_gryo",
+		.addr          = 0x69,
+		.flags         = 0,
+		.irq           = L3G4200D_INT_PIN,
+		.platform_data = &l3g4200d_info,
+	},
+#endif
+#if defined (CONFIG_MPU_SENSORS_MPU3050) 
+	{
+		.type			= "mpu3050",
+		.addr			= 0x68,
+		.flags			= 0,
+		.irq			= RK30_PIN4_PC3,
+		.platform_data	= &mpu3050_data,
+	},
+#endif
+#if defined (CONFIG_MPU_SENSORS_MMA845X)
+	{
+		.type    		= "mma845x",
+		.addr           = 0x1c,
+		.flags			= 0,	
+		.irq 			= RK30_PIN4_PC3,
+		.platform_data = &inv_mpu_mma845x_data,
+	},
+#endif
+#if defined (CONFIG_MPU_SENSORS_AK8975)
+	{
+		.type			= "ak8975",
+		.addr			= 0x0d,
+		.flags			= 0,	
+		.irq 			= RK30_PIN4_PC1,
+		.platform_data = &inv_mpu_ak8975_data,
+	},
+#endif
+
+#if defined (CONFIG_SND_SOC_RK1000)
+	{
+		.type          = "rk1000_i2c_codec",
+		.addr          = 0x60,
+		.flags         = 0,
+	},
+	{
+		.type          = "rk1000_control",
+		.addr          = 0x40,
+		.flags         = 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_RT5631)
+        {
+                .type                   = "rt5631",
+                .addr                   = 0x1a,
+                .flags                  = 0,
+        },
+#endif
+
+#ifdef CONFIG_MFD_RK610
+		{
+			.type			= "rk610_ctl",
+			.addr			= 0x40,
+			.flags			= 0,
+		},
+#ifdef CONFIG_RK610_TVOUT
+		{
+			.type			= "rk610_tvout",
+			.addr			= 0x42,
+			.flags			= 0,
+		},
+#endif
+#ifdef CONFIG_RK610_HDMI
+		{
+			.type			= "rk610_hdmi",
+			.addr			= 0x46,
+			.flags			= 0,
+			.irq			= RK29_PIN5_PA2,
+		},
+#endif
+#ifdef CONFIG_SND_SOC_RK610
+		{//RK610_CODEC addr  from 0x60 to 0x80 (0x60~0x80)
+			.type			= "rk610_i2c_codec",
+			.addr			= 0x60,
+			.flags			= 0,
+		},
+#endif
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C1_RK30
+#include "board-rk30-wm831x.c"
+
+static struct i2c_board_info __initdata i2c1_info[] = {
+#if defined (CONFIG_MFD_WM831X_I2C)
+	{
+		.type          = "wm8310",
+		.addr          = 0x34,
+		.flags         = 0,
+		.irq           = RK30_PIN6_PA4,
+		.platform_data = &wm831x_platdata,
+	},
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C2_RK30
+static struct i2c_board_info __initdata i2c2_info[] = {
+#if defined (CONFIG_TOUCHSCREEN_ILI2102_IIC)
+	{
+		.type			= "ili2102_ts",
+		.addr			= 0x41,
+		.flags			= I2C_M_NEED_DELAY,
+		.udelay 	 = 100,
+		.irq			= TOUCH_GPIO_INT,
+		.platform_data = &ili2102_info,
+	},	
+#endif
+
+#if defined (CONFIG_TOUCHSCREEN_GT8XX)
+	{
+		.type          = "Goodix-TS",
+		.addr          = 0x55,
+		.flags         = 0,
+		.irq           = RK30_PIN4_PC2,
+		.platform_data = &goodix_info,
+	},
+#endif
+#if defined (CONFIG_LS_CM3217)
+	{
+		.type          = "lightsensor",
+		.addr          = 0x10,
+		.flags         = 0,
+		.irq           = CM3217_IRQ_PIN,
+		.platform_data = &cm3217_info,
+	},
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C3_RK30
+static struct i2c_board_info __initdata i2c3_info[] = {
+};
+#endif
+
+#ifdef CONFIG_I2C4_RK30
+static struct i2c_board_info __initdata i2c4_info[] = {
+};
+#endif
+
+static void __init rk30_i2c_register_board_info(void)
+{
+#ifdef CONFIG_I2C0_RK30
+	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
+#endif
+#ifdef CONFIG_I2C1_RK30
+	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
+#endif
+#ifdef CONFIG_I2C2_RK30
+	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
+#endif
+#ifdef CONFIG_I2C3_RK30
+	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
+#endif
+#ifdef CONFIG_I2C4_RK30
+	i2c_register_board_info(4, i2c4_info, ARRAY_SIZE(i2c4_info));
+#endif
+}
+//end of i2c
+
+#define POWER_ON_PIN RK30_PIN6_PB0   //power_hold
+static void rk30_pm_power_off(void)
+{
+	printk(KERN_ERR "rk30_pm_power_off start...\n");
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+#if defined(CONFIG_MFD_WM831X)
+	wm831x_device_shutdown(Wm831x);//wm8326 shutdown
+#endif
+	while (1);
+}
+
+static void __init machine_rk30_board_init(void)
+{
+	gpio_request(POWER_ON_PIN, "poweronpin");
+	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+	
+	pm_power_off = rk30_pm_power_off;
+	
+	rk30_i2c_register_board_info();
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	board_usb_detect_init(RK30_PIN6_PA3);
+	
+#if defined (CONFIG_MPU_SENSORS_MPU3050)
+	rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME, GPIO4C_GPIO4C3);
+#endif
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	rk29sdk_wifi_bt_gpio_control_init();
+#endif
+}
+
+static void __init rk30_reserve(void)
+{
+#ifdef CONFIG_ION
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+#endif
+#ifdef CONFIG_FB_ROCKCHIP
+	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
+	resource_fb[0].end = resource_fb[0].start + RK30_FB0_MEM_SIZE - 1;
+	resource_fb[1].start = board_mem_reserve_add("ipp buf", RK30_FB0_MEM_SIZE);
+	resource_fb[1].end = resource_fb[1].start + RK30_FB0_MEM_SIZE - 1;
+	resource_fb[2].start = board_mem_reserve_add("fb2", RK30_FB0_MEM_SIZE);
+	resource_fb[2].end = resource_fb[2].start + RK30_FB0_MEM_SIZE - 1;
+#endif
+#ifdef CONFIG_VIDEO_RK29
+	rk30_camera_request_reserve_mem();
+#endif
+	board_mem_reserved();
+}
+
+void __init board_clock_init(void)
+{
+	rk30_clock_data_init(periph_pll_297mhz, codec_pll_360mhz, max_i2s_12288khz);
+}
+
+MACHINE_START(RK30, "RK30board")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
+	.fixup		= rk30_fixup,
+	.reserve	= &rk30_reserve,
+	.map_io		= rk30_map_io,
+	.init_irq	= rk30_init_irq,
+	.timer		= &rk30_timer,
+	.init_machine	= machine_rk30_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-rk30/board-rk30-wm831x.c b/arch/arm/mach-rk30/board-rk30-wm831x.c
new file mode 100755
index 000000000000..d33fa4ea9a55
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk30-wm831x.c
@@ -0,0 +1,722 @@
+#include <linux/regulator/machine.h>
+#include <linux/mfd/wm831x/pdata.h>
+#include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/gpio.h>
+
+/* wm8326 pmu*/
+#if defined(CONFIG_GPIO_WM831X)
+static struct rk29_gpio_expander_info wm831x_gpio_settinginfo[] = {
+	{
+		.gpio_num = WM831X_P01,	// tp3
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P02,	//tp4
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P03,	//tp2
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P04,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P05,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P06,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P07,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P08,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P09,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P10,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P11,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P12,
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+};
+#endif
+
+#if defined(CONFIG_MFD_WM831X)
+
+#define UNLOCK_SECURITY_KEY     ~(0x1<<5)
+#define LOCK_SECURITY_KEY       0x00
+#define PMU_POWER_SLEEP RK30_PIN6_PB1
+static struct wm831x *Wm831x;
+
+static int wm831x_pre_init(struct wm831x *parm)
+{
+	int ret;
+	Wm831x = parm;
+//	printk("%s\n", __func__);
+	gpio_request(PMU_POWER_SLEEP, "NULL");
+	gpio_direction_output(PMU_POWER_SLEEP, GPIO_HIGH);
+	
+	ret = wm831x_reg_read(parm, WM831X_POWER_STATE) & 0xffff;
+	wm831x_reg_write(parm, WM831X_POWER_STATE, (ret & 0xfff8) | 0x04);
+
+	//BATT_FET_ENA = 1
+	wm831x_reg_write(parm, WM831X_SECURITY_KEY, 0x9716);	// unlock security key
+	wm831x_set_bits(parm, WM831X_RESET_CONTROL, 0x1000, 0x1000);
+	ret = wm831x_reg_read(parm, WM831X_RESET_CONTROL) & 0xffff & UNLOCK_SECURITY_KEY;	// enternal reset active in sleep
+//	printk("%s:WM831X_RESET_CONTROL=0x%x\n", __func__, ret);
+	wm831x_reg_write(parm, WM831X_RESET_CONTROL, ret);
+
+	wm831x_set_bits(parm,WM831X_DC1_ON_CONFIG ,0x0300,0x0000); //set dcdc mode is FCCM
+	wm831x_set_bits(parm,WM831X_DC2_ON_CONFIG ,0x0300,0x0000);
+	wm831x_set_bits(parm,WM831X_DC3_ON_CONFIG ,0x0300,0x0000);
+	wm831x_set_bits(parm,0x4066,0x0300,0x0000);
+
+	wm831x_set_bits(parm,WM831X_LDO10_CONTROL ,0x0040,0x0040);// set ldo10 in switch mode
+
+	wm831x_set_bits(parm,WM831X_STATUS_LED_1 ,0xc300,0xc100);// set led1 on(in manual mode)
+	wm831x_set_bits(parm,WM831X_STATUS_LED_2 ,0xc300,0xc000);//set led2 off(in manual mode)
+
+	wm831x_reg_write(parm, WM831X_SECURITY_KEY, LOCK_SECURITY_KEY);	// lock security key
+
+	return 0;
+}
+
+int wm831x_post_init(struct wm831x *Wm831x)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+
+
+	ldo = regulator_get(NULL, "ldo6");	//vcc_33
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_set_suspend_voltage(ldo, 3300000);
+	regulator_enable(ldo);
+//	printk("%s set ldo6 vcc_33=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "ldo4");	// vdd_11
+	regulator_set_voltage(ldo, 1100000, 1100000);
+	regulator_set_suspend_voltage(ldo, 1100000);
+	regulator_enable(ldo);
+//	printk("%s set ldo4 vdd_11=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo5");	//vcc_25
+	regulator_set_voltage(ldo, 2500000, 2500000);
+	regulator_set_suspend_voltage(ldo, 2500000);
+	regulator_enable(ldo);
+//	printk("%s set ldo5 vcc_25=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+
+	dcdc = regulator_get(NULL, "dcdc4");	// vcc_io
+	regulator_set_voltage(dcdc, 3000000, 3000000);
+	regulator_set_suspend_voltage(dcdc, 3000000);
+	regulator_enable(dcdc);
+//	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	dcdc = regulator_get(NULL, "vdd_cpu");	// vdd_arm
+	regulator_set_voltage(dcdc, 1100000, 1100000);
+	regulator_set_suspend_voltage(dcdc, 1100000);
+	regulator_enable(dcdc);
+	printk("%s set dcdc2 vdd_cpu(vdd_arm)=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	dcdc = regulator_get(NULL, "vdd_core");	// vdd_log
+	regulator_set_voltage(dcdc, 1100000, 1100000);
+	regulator_set_suspend_voltage(dcdc, 1100000);
+	regulator_enable(dcdc);
+	printk("%s set dcdc1 vdd_core(vdd_log)=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	dcdc = regulator_get(NULL, "dcdc3");	// vcc_ddr
+	regulator_set_voltage(dcdc, 1150000, 1150000);
+	regulator_set_suspend_voltage(dcdc, 1150000);
+	regulator_enable(dcdc);
+//	printk("%s set dcdc3 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo7");	// vcc28_cif
+	regulator_set_voltage(ldo, 2800000, 2800000);
+	regulator_set_suspend_voltage(ldo, 2800000);
+	regulator_enable(ldo);
+//	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo1");	// vcc18_cif
+	regulator_set_voltage(ldo, 1800000, 1800000);
+	regulator_set_suspend_voltage(ldo, 1800000);
+	regulator_enable(ldo);
+//	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo8");	// vcca_33
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_set_suspend_voltage(ldo, 3300000);
+	regulator_enable(ldo);
+//	printk("%s set ldo8 vcca_33=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo2");	//vccio_wl
+	regulator_set_voltage(ldo, 1800000, 1800000);
+	regulator_set_suspend_voltage(ldo, 1800000);
+	regulator_enable(ldo);
+//	printk("%s set ldo2 vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo10");	//vcca_wl
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_set_suspend_voltage(ldo, 3300000);
+	regulator_enable(ldo);
+//	printk("%s set ldo10 vcca_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo3");	//vdd_12
+	regulator_set_voltage(ldo, 1200000, 1200000);
+	regulator_set_suspend_voltage(ldo, 1200000);
+	regulator_enable(ldo);
+//	printk("%s set ldo3 vdd_12=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo9");	//vcc_tp
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_set_suspend_voltage(ldo, 3300000);
+	regulator_enable(ldo);
+//	printk("%s set ldo9 vcc_tp=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	printk("wm831x_post_init end");
+	return 0;
+}
+
+static int wm831x_last_deinit(struct wm831x *Wm831x)
+{
+	struct regulator *ldo;
+
+	printk("%s\n", __func__);
+	ldo = regulator_get(NULL, "ldo1");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo2");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo3");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo4");
+	//regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo5");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo6");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo7");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo8");
+	//regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo9");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo10");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	return 0;
+}
+
+struct wm831x_status_pdata wm831x_status_platdata[WM831X_MAX_STATUS] = {
+	{
+		.default_src = WM831X_STATUS_OTP,
+		.name = "wm831x_status0",
+		.default_trigger = "wm831x_otp",
+	},
+	{
+		.default_src = WM831X_STATUS_POWER,
+		.name = "wm831x_status1",
+		.default_trigger = "wm831x_power",
+	},
+};
+
+static struct regulator_consumer_supply dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+static struct regulator_consumer_supply dcdc2_consumers[] = {
+	{
+		.supply = "vdd_cpu",
+	}
+	
+};
+
+static struct regulator_consumer_supply dcdc3_consumers[] = {
+	{
+		.supply = "dcdc3",
+	}
+};
+
+static struct regulator_consumer_supply dcdc4_consumers[] = {
+	{
+		.supply = "dcdc4",
+	}
+};
+
+#if 0
+static struct regulator_consumer_supply epe1_consumers[] = {
+	{
+		.supply = "epe1",
+	}
+};
+
+static struct regulator_consumer_supply epe2_consumers[] = {
+	{
+		.supply = "epe2",
+	}
+};
+#endif
+
+static struct regulator_consumer_supply ldo1_consumers[] = {
+	{
+		.supply = "ldo1",
+	}
+};
+
+static struct regulator_consumer_supply ldo2_consumers[] = {
+	{
+		.supply = "ldo2",
+	}
+};
+
+static struct regulator_consumer_supply ldo3_consumers[] = {
+	{
+		.supply = "ldo3",
+	}
+};
+
+static struct regulator_consumer_supply ldo4_consumers[] = {
+	{
+		.supply = "ldo4",
+	}
+};
+
+static struct regulator_consumer_supply ldo5_consumers[] = {
+	{
+		.supply = "ldo5",
+	}
+};
+
+static struct regulator_consumer_supply ldo6_consumers[] = {
+	{
+		.supply = "ldo6",
+	}
+};
+
+static struct regulator_consumer_supply ldo7_consumers[] = {
+	{
+		.supply = "ldo7",
+	}
+};
+
+static struct regulator_consumer_supply ldo8_consumers[] = {
+	{
+		.supply = "ldo8",
+	}
+};
+
+static struct regulator_consumer_supply ldo9_consumers[] = {
+	{
+		.supply = "ldo9",
+	}
+};
+
+static struct regulator_consumer_supply ldo10_consumers[] = {
+	{
+		.supply = "ldo10",
+	}
+};
+
+static struct regulator_consumer_supply ldo11_consumers[] = {
+	{
+		.supply = "ldo11",
+	}
+};
+
+struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
+	{
+		.constraints = {
+			.name = "DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc1_consumers),
+		.consumer_supplies = dcdc1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC2",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc2_consumers),
+		.consumer_supplies = dcdc2_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC3",
+			.min_uV = 850000,
+			.max_uV = 3400000,	//0.85-3.4V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc3_consumers),
+		.consumer_supplies = dcdc3_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC4",
+			.min_uV = 850000,
+			.max_uV = 3400000,	//0.85-3.4V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc4_consumers),
+		.consumer_supplies = dcdc4_consumers,
+	},
+};
+
+#if 0
+struct regulator_init_data wm831x_regulator_init_epe[WM831X_MAX_EPE] = {
+	{
+		.constraints = {
+			.name = "EPE1",
+			.min_uV = 1200000,
+			.max_uV = 3000000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(epe1_consumers),
+		.consumer_supplies = epe1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "EPE2",
+			.min_uV = 1200000,
+			.max_uV = 3000000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(epe2_consumers),
+		.consumer_supplies = epe2_consumers,
+	},
+};
+#endif
+
+struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
+	{
+		.constraints = {
+			.name = "LDO1",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_consumers),
+		.consumer_supplies = ldo1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO2",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_consumers),
+		.consumer_supplies = ldo2_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO3",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_consumers),
+		.consumer_supplies = ldo3_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO4",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_consumers),
+		.consumer_supplies = ldo4_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO5",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo5_consumers),
+		.consumer_supplies = ldo5_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO6",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo6_consumers),
+		.consumer_supplies = ldo6_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO7",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo7_consumers),
+		.consumer_supplies = ldo7_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO8",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo8_consumers),
+		.consumer_supplies = ldo8_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO9",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo9_consumers),
+		.consumer_supplies = ldo9_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO10",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo10_consumers),
+		.consumer_supplies = ldo10_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO11",
+			.min_uV = 800000,
+			.max_uV = 1550000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo11_consumers),
+		.consumer_supplies = ldo11_consumers,
+	},
+};
+
+static int wm831x_init_pin_type(struct wm831x *wm831x)
+{
+	struct wm831x_pdata *pdata;
+	struct rk29_gpio_expander_info *wm831x_gpio_settinginfo;
+	uint16_t wm831x_settingpin_num;
+	int i;
+
+	if (!wm831x || !wm831x->dev)
+		goto out;
+
+	pdata = wm831x->dev->platform_data;
+	if (!pdata)
+		goto out;
+
+	wm831x_gpio_settinginfo = pdata->settinginfo;
+	if (!wm831x_gpio_settinginfo)
+		goto out;
+
+	wm831x_settingpin_num = pdata->settinginfolen;
+	for (i = 0; i < wm831x_settingpin_num; i++) {
+		if (wm831x_gpio_settinginfo[i].pin_type == GPIO_IN) {
+			wm831x_set_bits(wm831x,
+					WM831X_GPIO1_CONTROL + i,
+					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
+					1 << WM831X_GPN_DIR_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
+
+			wm831x_set_bits(wm831x,
+					(WM831X_GPIO1_CONTROL + i),
+					WM831X_GPN_PULL_MASK, 1 << WM831X_GPN_PULL_SHIFT);	//pull down
+			if (i == 0 ) {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK,
+						WM831X_GPN_PWR_DOM);
+			}	// set gpiox power domain
+			else {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK,
+						~WM831X_GPN_PWR_DOM);
+			}
+					
+		} else {
+			wm831x_set_bits(wm831x,
+					WM831X_GPIO1_CONTROL + i,
+					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
+					1 << WM831X_GPN_TRI_SHIFT);
+			if (wm831x_gpio_settinginfo[i].pin_value == GPIO_HIGH) {
+				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 1 << i);
+			} else {
+				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 0 << i);
+			}
+			if (i == 2) {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK | WM831X_GPN_POL_MASK |WM831X_GPN_FN_MASK,
+						1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_PWR_DOM_SHIFT | 1 << 0);
+
+			}	// set gpio3 as clkout output 32.768K
+			else {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK,
+						~WM831X_GPN_PWR_DOM);
+			}
+		}
+	}
+
+#if 0
+	for (i = 0; i < pdata->gpio_pin_num; i++) {
+		wm831x_set_bits(wm831x,
+				WM831X_GPIO1_CONTROL + i,
+				WM831X_GPN_PULL_MASK | WM831X_GPN_POL_MASK | WM831X_GPN_OD_MASK | WM831X_GPN_TRI_MASK,
+				1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
+
+		ret = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + i);
+		printk("Gpio%d Pin Configuration = %x\n", i, ret);
+	}
+#endif
+
+out:
+	return 0;
+}
+
+static struct wm831x_pdata wm831x_platdata = {
+
+	/** Called before subdevices are set up */
+	.pre_init = wm831x_pre_init,
+	/** Called after subdevices are set up */
+	.post_init = wm831x_post_init,
+	/** Called before subdevices are power down */
+	.last_deinit = wm831x_last_deinit,
+
+#if defined(CONFIG_GPIO_WM831X)
+	.gpio_base = WM831X_GPIO_EXPANDER_BASE,
+	.gpio_pin_num = WM831X_TOTOL_GPIO_NUM,
+	.settinginfo = wm831x_gpio_settinginfo,
+	.settinginfolen = ARRAY_SIZE(wm831x_gpio_settinginfo),
+	.pin_type_init = wm831x_init_pin_type,
+	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
+#endif
+
+	/** LED1 = 0 and so on */
+	.status = { &wm831x_status_platdata[0], &wm831x_status_platdata[1] },
+
+	/** DCDC1 = 0 and so on */
+	.dcdc = {
+		&wm831x_regulator_init_dcdc[0],
+		&wm831x_regulator_init_dcdc[1],
+		&wm831x_regulator_init_dcdc[2],
+		&wm831x_regulator_init_dcdc[3],
+	},
+
+	/** EPE1 = 0 and so on */
+	//.epe = { &wm831x_regulator_init_epe[0], &wm831x_regulator_init_epe[1] },
+
+	/** LDO1 = 0 and so on */
+	.ldo = {
+		&wm831x_regulator_init_ldo[0],
+		&wm831x_regulator_init_ldo[1],
+		&wm831x_regulator_init_ldo[2],
+		&wm831x_regulator_init_ldo[3],
+		&wm831x_regulator_init_ldo[4],
+		&wm831x_regulator_init_ldo[5],
+		&wm831x_regulator_init_ldo[6],
+		&wm831x_regulator_init_ldo[7],
+		&wm831x_regulator_init_ldo[8],
+		&wm831x_regulator_init_ldo[9],
+		&wm831x_regulator_init_ldo[10],
+	},
+};
+#endif
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
old mode 100644
new mode 100755
index 235dbfd62eb4..81056931d8c6
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -318,7 +318,7 @@ config FIH_TOUCHKEY_LED
 
 config BACKLIGHT_AW9364
         bool "aw9364 backlight driver"
-	depends on BACKLIGHT_CLASS_DEVICE && ARCH_RK29
+	depends on BACKLIGHT_CLASS_DEVICE
 	help
 	  aw9364 backlight support.	 
 
diff --git a/drivers/video/backlight/aw9364_bl.c b/drivers/video/backlight/aw9364_bl.c
index c7be36bf38e8..cf3d9b35a76c 100755
--- a/drivers/video/backlight/aw9364_bl.c
+++ b/drivers/video/backlight/aw9364_bl.c
@@ -179,6 +179,9 @@ static int aw9364_backlight_probe(struct platform_device *pdev)
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
+	
+	if(pdata && pdata->io_init)
+	pdata->io_init();
 
 	data->current_brightness = 0;
 	data->pin_en = pdata->pin_en;
diff --git a/drivers/video/display/screen/lcd_nt35510.c b/drivers/video/display/screen/lcd_nt35510.c
index 90ba8a1cb7ae..c867d52bc182 100755
--- a/drivers/video/display/screen/lcd_nt35510.c
+++ b/drivers/video/display/screen/lcd_nt35510.c
@@ -169,37 +169,6 @@ void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
 	gLcd_info = lcd_info;
 }
 
-#define PIN_BL_SET          RK29_PIN6_PD2
-void set_backlight(int brightness)
-{
-#if 0
- 	if(gLcd_info)
-        gLcd_info->io_init();
-
-	printk("lcd_ili9803:set_backlight = %d\r\n", brightness);
-	if (brightness < 0)
-	{
-		brightness = 0;
-	}
-	if (brightness > 4)
-	{
-		brightness = 4;
-	}
-	spi_screenreg_cmd(0x51);
-	spi_screenreg_param(brightness<<5);
-		
-  	 if(gLcd_info)
-        gLcd_info->io_deinit();
-
-#endif
-
-	gpio_request(PIN_BL_SET, NULL);
-	if(brightness > 0)
-        gpio_direction_output(PIN_BL_SET,GPIO_HIGH);
-	else
-	gpio_direction_output(PIN_BL_SET,GPIO_LOW);	
-	printk("%s:brightness=%d\n",__FUNCTION__,brightness);
-}
 
 void WriteCommand( int  Command)
 {
@@ -1597,16 +1566,7 @@ static void lcd_resume(struct work_struct *work)
 	rk29_lcd_spim_spin_lock();
 	if(gLcd_info)
 		gLcd_info->io_init();
-
-	gpio_request(RK29_PIN6_PC6, NULL);
-	gpio_direction_output(RK29_PIN6_PC6, 1);
-	gpio_direction_output(RK29_PIN6_PC6, 0);
-	usleep_range(5*1000, 5*1000);
-	gpio_set_value(RK29_PIN6_PC6, 1);
-	usleep_range(50*1000, 50*1000);
-	gpio_free(RK29_PIN6_PC6);
 	init_nt35510();
-	//set_backlight(255);
 	//resume_nt35510();//may be fail to wake up LCD some time,so change to init lcd again
 	printk(KERN_DEBUG "%s\n",__FUNCTION__);
 
@@ -1634,15 +1594,6 @@ int init(void)
 { 
 	volatile u32 data;
 	printk("lcd init...\n");
-	/* reset lcd to start init lcd */
-	gpio_request(RK29_PIN6_PC6, NULL);
-	gpio_direction_output(RK29_PIN6_PC6, 1);
-	gpio_direction_output(RK29_PIN6_PC6, 0);
-	msleep(5);
-	gpio_set_value(RK29_PIN6_PC6, 1);
-	msleep(50);
-	gpio_free(RK29_PIN6_PC6);
-
 	if(gLcd_info)
 	gLcd_info->io_init();
 	init_nt35510();
@@ -1650,8 +1601,6 @@ int init(void)
 	if(gLcd_info)
 	gLcd_info->io_deinit();
 
-	//set_backlight(255);
-
 	lcd_resume_wq = create_singlethread_workqueue("lcd");
 	register_early_suspend(&lcd_early_suspend_desc);
     return 0;
@@ -1666,7 +1615,6 @@ int standby(u8 enable)	//***enable =1 means suspend, 0 means resume
 			gLcd_info->io_init();
 
 		WriteCommand(0X2800); 
-		//set_backlight(0);
 		WriteCommand(0X1100); 
 		msleep(5);
 		WriteCommand(0X4f00); 
-- 
2.35.3

