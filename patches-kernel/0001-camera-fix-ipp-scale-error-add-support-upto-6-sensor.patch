From f75671717f306f44d146f923599821fa855b55a8 Mon Sep 17 00:00:00 2001
From: ddl <ddl@rock-chips.com>
Date: Wed, 21 Mar 2012 18:34:32 +0800
Subject: [PATCH] camera: fix ipp scale error, add support upto 6 sensor
 detect, version update to v0.1.8

---
 arch/arm/mach-rk29/board-rk29-ddr3sdk.c       | 121 ++-
 arch/arm/mach-rk29/board-rk29-k97.c           |  27 +
 arch/arm/mach-rk29/include/mach/rk29_camera.h |   6 +-
 drivers/media/video/Kconfig                   |  13 +
 drivers/media/video/gc0307.c                  |  65 +-
 drivers/media/video/gc0308.c                  |  61 +-
 drivers/media/video/gc0309.c                  |  50 +-
 drivers/media/video/gc2015.c                  |  69 +-
 drivers/media/video/gt2005.c                  |  65 +-
 drivers/media/video/mt9d112.c                 |  87 ++-
 drivers/media/video/mt9d113.c                 |  17 +-
 drivers/media/video/mt9p111.c                 |  22 +-
 drivers/media/video/mt9t111.c                 |  17 +-
 drivers/media/video/ov2640_rk.c               |  75 +-
 drivers/media/video/ov2655.c                  |  67 +-
 drivers/media/video/ov2659.c                  |  75 +-
 drivers/media/video/ov5640.c                  |  19 +-
 drivers/media/video/ov5642.c                  |  96 ++-
 drivers/media/video/ov7675.c                  |  60 +-
 drivers/media/video/rk29_camera.c             | 734 +++++++++++++-----
 drivers/media/video/rk29_camera_oneframe.c    | 187 +++--
 drivers/media/video/sid130B.c                 |  85 +-
 drivers/media/video/siv120b.c                 |  49 +-
 drivers/media/video/soc_camera.c              |   9 +-
 24 files changed, 1678 insertions(+), 398 deletions(-)

diff --git a/arch/arm/mach-rk29/board-rk29-ddr3sdk.c b/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
index 1efc7f82f460..e2aa684824d9 100755
--- a/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
+++ b/arch/arm/mach-rk29/board-rk29-ddr3sdk.c
@@ -69,7 +69,7 @@
 #ifdef CONFIG_VIDEO_RK29
 /*---------------- Camera Sensor Macro Define Begin  ------------------------*/
 /*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
-#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642                      /* back camera sensor */
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642                      /* back camera sensor 0 */
 #define CONFIG_SENSOR_IIC_ADDR_0 	    0x78
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_0    1
 #define CONFIG_SENSOR_ORIENTATION_0       90
@@ -83,6 +83,7 @@
 #define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
 
 #define CONFIG_SENSOR_QCIF_FPS_FIXED_0      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
 #define CONFIG_SENSOR_QVGA_FPS_FIXED_0      15000
 #define CONFIG_SENSOR_CIF_FPS_FIXED_0       15000
 #define CONFIG_SENSOR_VGA_FPS_FIXED_0       15000
@@ -90,7 +91,51 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_0      15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_0      30000
 
-#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor */
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    1
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       RK29_PIN6_PB7
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    1
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       RK29_PIN6_PB7
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 0 */
 #define CONFIG_SENSOR_IIC_ADDR_1 	    0x60
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_1    1
 #define CONFIG_SENSOR_ORIENTATION_1       270
@@ -104,6 +149,7 @@
 #define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
 
 #define CONFIG_SENSOR_QCIF_FPS_FIXED_1      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
 #define CONFIG_SENSOR_QVGA_FPS_FIXED_1      15000
 #define CONFIG_SENSOR_CIF_FPS_FIXED_1       15000
 #define CONFIG_SENSOR_VGA_FPS_FIXED_1       15000
@@ -111,6 +157,51 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_1      15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_1      30000
 
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    1
+#define CONFIG_SENSOR_ORIENTATION_11       270
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       RK29_PIN5_PD7
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    1
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       RK29_PIN5_PD7
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
 #endif  //#ifdef CONFIG_VIDEO_RK29
 /*---------------- Camera Sensor Configuration Macro End------------------------*/
 #include "../../../drivers/media/video/rk29_camera.c"
@@ -2724,8 +2815,34 @@ static struct platform_device *devices[] __initdata = {
  	#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
  	&rk29_soc_camera_pdrv_0,
  	#endif
+    #if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
  	&rk29_soc_camera_pdrv_1,
+ 	#endif
+    #ifdef CONFIG_SENSOR_01
+    #if (CONFIG_SENSOR_IIC_ADDR_01 != 0x00)
+ 	&rk29_soc_camera_pdrv_01,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_02
+    #if (CONFIG_SENSOR_IIC_ADDR_02 != 0x00)
+ 	&rk29_soc_camera_pdrv_02,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_11
+    #if (CONFIG_SENSOR_IIC_ADDR_11 != 0x00)
+ 	&rk29_soc_camera_pdrv_11,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_12
+    #if (CONFIG_SENSOR_IIC_ADDR_12 != 0x00)
+ 	&rk29_soc_camera_pdrv_12,
+ 	#endif
+    #endif
+
+    #if (PMEM_CAM_SIZE > 0)
  	&android_pmem_cam_device,
+ 	#endif
+    
 #endif
 #if PMEM_SKYPE_SIZE > 0
 	&android_pmem_skype_device,
diff --git a/arch/arm/mach-rk29/board-rk29-k97.c b/arch/arm/mach-rk29/board-rk29-k97.c
index bfcc8592346e..619d810b8fcb 100755
--- a/arch/arm/mach-rk29/board-rk29-k97.c
+++ b/arch/arm/mach-rk29/board-rk29-k97.c
@@ -85,6 +85,7 @@
 #endif
 
 #define CONFIG_SENSOR_QCIF_FPS_FIXED_0      12504
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0      12504
 #define CONFIG_SENSOR_QVGA_FPS_FIXED_0      12504
 #define CONFIG_SENSOR_CIF_FPS_FIXED_0       12504
 #define CONFIG_SENSOR_VGA_FPS_FIXED_0       12504
@@ -119,6 +120,7 @@
 #define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
 
 #define CONFIG_SENSOR_QCIF_FPS_FIXED_1      12504
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1      12504
 #define CONFIG_SENSOR_QVGA_FPS_FIXED_1      12504
 #define CONFIG_SENSOR_CIF_FPS_FIXED_1       12504
 #define CONFIG_SENSOR_VGA_FPS_FIXED_1       12504
@@ -2781,8 +2783,33 @@ static struct platform_device *devices[] __initdata = {
  	#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
  	&rk29_soc_camera_pdrv_0,
  	#endif
+    #if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
  	&rk29_soc_camera_pdrv_1,
+ 	#endif
+    #ifdef CONFIG_SENSOR_01
+    #if (CONFIG_SENSOR_IIC_ADDR_01 != 0x00)
+ 	&rk29_soc_camera_pdrv_01,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_02
+    #if (CONFIG_SENSOR_IIC_ADDR_02 != 0x00)
+ 	&rk29_soc_camera_pdrv_02,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_11
+    #if (CONFIG_SENSOR_IIC_ADDR_11 != 0x00)
+ 	&rk29_soc_camera_pdrv_11,
+ 	#endif
+    #endif
+    #ifdef CONFIG_SENSOR_12
+    #if (CONFIG_SENSOR_IIC_ADDR_12 != 0x00)
+ 	&rk29_soc_camera_pdrv_12,
+ 	#endif
+    #endif
+
+    #if (PMEM_CAM_SIZE > 0)
  	&android_pmem_cam_device,
+ 	#endif
 #endif
 #if PMEM_SKYPE_SIZE > 0
 	&android_pmem_skype_device,
diff --git a/arch/arm/mach-rk29/include/mach/rk29_camera.h b/arch/arm/mach-rk29/include/mach/rk29_camera.h
index 2d78c35cda2b..c1cbc3289921 100755
--- a/arch/arm/mach-rk29/include/mach/rk29_camera.h
+++ b/arch/arm/mach-rk29/include/mach/rk29_camera.h
@@ -33,6 +33,8 @@
 #define RK29_CAM_EIO_INVALID -1
 #define RK29_CAM_EIO_REQUESTFAIL -2
 
+#define RK29_CAM_SUPPORT_NUMS   6
+
 /*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
 #define RK29_CAM_SENSOR_OV7675 ov7675
 #define RK29_CAM_SENSOR_OV9650 ov9650
@@ -183,9 +185,9 @@ struct rk29camera_platform_data {
     int (*io_init)(void);
     int (*io_deinit)(int sensor);
 	int (*sensor_ioctrl)(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
-    struct rk29camera_gpio_res gpio_res[2];
+    struct rk29camera_gpio_res gpio_res[RK29_CAM_SUPPORT_NUMS];
 	struct rk29camera_mem_res meminfo;
-    struct rk29camera_info info[2];
+    struct rk29camera_info info[RK29_CAM_SUPPORT_NUMS];
 };
 
 struct rk29camera_platform_ioctl_cb {
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 609f968c4039..e4e036d0f905 100755
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1185,6 +1185,19 @@ config VIDEO_RK29_DIGITALZOOM_IPP_OFF
 	bool "Digital zoom with IPP off"
 endchoice
 
+choice
+	prompt "RK29XX camera memory "
+	depends on VIDEO_RK29 
+	default VIDEO_RK29_CAMMEM_PMEM
+	---help---
+		where camera memory which is used for preview/raw/jpeg in android camera hal is alloced 
+config VIDEO_RK29_CAMMEM_PMEM
+	bool "Camera memory from pmem"
+
+config VIDEO_RK29_CAMMEM_ION
+	bool "Camera memory from ion"
+endchoice
+
 config VIDEO_MX2_HOSTSUPPORT
 	bool
 
diff --git a/drivers/media/video/gc0307.c b/drivers/media/video/gc0307.c
index 38f120d99f4c..baff822d39d7 100755
--- a/drivers/media/video/gc0307.c
+++ b/drivers/media/video/gc0307.c
@@ -2036,7 +2036,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2055,6 +2055,52 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg!=0xff)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg!=0xff)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg!=0xff)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg!=0xff)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg!=0xff)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 720)) && sensor_720p[0].reg!=0xff)
+    {
+        set_w = 1280;
+        set_h = 720;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg!=0xff)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+    }    
+
+    mf->width = set_w;
+    mf->height = set_h;    
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2824,12 +2870,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/gc0308.c b/drivers/media/video/gc0308.c
index 67669ac38f73..033f533780dc 100755
--- a/drivers/media/video/gc0308.c
+++ b/drivers/media/video/gc0308.c
@@ -1883,7 +1883,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -1902,6 +1902,48 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;		
+    }
+
+    mf->width = set_w;
+    mf->height = set_h; 
+    
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2666,12 +2708,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/gc0309.c b/drivers/media/video/gc0309.c
index dff2a47c92be..0ee641e8c7cf 100755
--- a/drivers/media/video/gc0309.c
+++ b/drivers/media/video/gc0309.c
@@ -1837,7 +1837,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -1856,6 +1856,37 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+    }    
+    mf->width = set_w;
+    mf->height = set_h; 
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2619,12 +2650,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/gc2015.c b/drivers/media/video/gc2015.c
index 4f9e18f7a1b8..b31ed13207be 100755
--- a/drivers/media/video/gc2015.c
+++ b/drivers/media/video/gc2015.c
@@ -2040,7 +2040,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2059,6 +2059,56 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800-32;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {		
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {    
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600-32;
+        set_h = 1200;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;	
+    }
+    mf->width = set_w;
+    mf->height = set_h;     
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2832,12 +2882,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/gt2005.c b/drivers/media/video/gt2005.c
index 607be6ed8a74..6ecc115b6b1f 100755
--- a/drivers/media/video/gt2005.c
+++ b/drivers/media/video/gt2005.c
@@ -2679,7 +2679,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2698,6 +2698,52 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+    }
+
+	mf->width = set_w;
+    mf->height = set_h;
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -3471,12 +3517,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/mt9d112.c b/drivers/media/video/mt9d112.c
index ce7e3b709e59..997657e0d71e 100755
--- a/drivers/media/video/mt9d112.c
+++ b/drivers/media/video/mt9d112.c
@@ -2185,7 +2185,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2204,6 +2204,72 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+	if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END))
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg!=SEQUENCE_END))
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && (sensor_xga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+	else if (((set_w <= 1280) && (set_h <= 720)) && (sensor_720p[0].reg!=SEQUENCE_END))
+    {
+        set_w = 1280;
+        set_h = 720;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else if (((set_w <= 1920) && (set_h <= 1080)) && (sensor_1080p[0].reg!=SEQUENCE_END))
+    {
+        set_w = 1920;
+        set_h = 1080;
+    }
+	else if (((set_w <= 2048) && (set_h <= 1536)) && (sensor_qxga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 2048;
+        set_h = 1536;
+    }
+	else if (((set_w <= 2592) && (set_h <= 1944)) && (sensor_qsxga[0].reg!=SEQUENCE_END))
+    {
+        set_w = 2592;
+        set_h = 1944;
+    }
+
+	mf->width = set_w;
+	mf->height = set_h;
+    
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -3119,14 +3185,19 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		}
 		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/mt9d113.c b/drivers/media/video/mt9d113.c
index 66f9c8ff8f37..191482da4d28 100755
--- a/drivers/media/video/mt9d113.c
+++ b/drivers/media/video/mt9d113.c
@@ -2935,12 +2935,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/mt9p111.c b/drivers/media/video/mt9p111.c
index d65188294379..b5bf570adf79 100644
--- a/drivers/media/video/mt9p111.c
+++ b/drivers/media/video/mt9p111.c
@@ -3702,7 +3702,10 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
         mf->width = SENSOR_MAX_WIDTH;
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
-
+    if (sensor_fmt_catch(mf->width, mf->height, &mf->width, &mf->height) == NULL) {
+		mf->width = 0;
+		mf->height = 0;
+	}
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -4640,12 +4643,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/mt9t111.c b/drivers/media/video/mt9t111.c
index 63cfb5fb4378..ce2575e0f327 100755
--- a/drivers/media/video/mt9t111.c
+++ b/drivers/media/video/mt9t111.c
@@ -8268,12 +8268,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/ov2640_rk.c b/drivers/media/video/ov2640_rk.c
index d6b1e385668a..d964b6d0e4aa 100755
--- a/drivers/media/video/ov2640_rk.c
+++ b/drivers/media/video/ov2640_rk.c
@@ -1998,7 +1998,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2016,7 +2016,59 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
         mf->width = SENSOR_MAX_WIDTH;
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
+
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+    }
 
+    mf->width = set_w;
+    mf->height = set_h;
+
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2785,20 +2837,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 
 		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
-            }
+            }
             /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
                for this project */
             #if CONFIG_SENSOR_Flash	
diff --git a/drivers/media/video/ov2655.c b/drivers/media/video/ov2655.c
index 7f7434f52f43..bca088c1c4ac 100755
--- a/drivers/media/video/ov2655.c
+++ b/drivers/media/video/ov2655.c
@@ -2129,7 +2129,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2148,6 +2148,52 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+
+    mf->width = set_w;
+    mf->height = set_h;
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2915,14 +2961,19 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 
 		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+            sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/ov2659.c b/drivers/media/video/ov2659.c
index 85f5c20e7b8f..b1830bb9fe68 100755
--- a/drivers/media/video/ov2659.c
+++ b/drivers/media/video/ov2659.c
@@ -1950,7 +1950,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -1969,6 +1969,62 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 720)) && sensor_720p[0].reg)
+    {
+        set_w = 1280;
+        set_h = 720;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {              /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;		
+    }
+
+    mf->width = set_w;
+    mf->height = set_h;
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2775,12 +2831,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/ov5640.c b/drivers/media/video/ov5640.c
index 055ab274d045..f1cf415c6fe8 100755
--- a/drivers/media/video/ov5640.c
+++ b/drivers/media/video/ov5640.c
@@ -3786,14 +3786,19 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		}
 		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+            sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/ov5642.c b/drivers/media/video/ov5642.c
index 98816754ee17..bfb407176b81 100755
--- a/drivers/media/video/ov5642.c
+++ b/drivers/media/video/ov5642.c
@@ -4742,7 +4742,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -4761,6 +4761,78 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
 
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+	else if (((set_w <= 1280) && (set_h <= 720)) && sensor_720p[0].reg)
+    {
+        set_w = 1280;
+        set_h = 720;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else if (((set_w <= 1920) && (set_h <= 1080)) && sensor_1080p[0].reg)
+    {
+        set_w = 1920;
+        set_h = 1080;
+    }
+	else if (((set_w <= 2048) && (set_h <= 1536)) && sensor_qxga[0].reg)
+    {
+        set_w = 2048;
+        set_h = 1536;
+    }
+	else if (((set_w <= 2592) && (set_h <= 1944)) && sensor_qsxga[0].reg)
+    {
+        set_w = 2592;
+        set_h = 1944;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+    }
+
+    mf->width = set_w;
+    mf->height = set_h;
+    
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -5702,16 +5774,20 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 			break;
 		}
 		case RK29_CAM_SUBDEV_IOREQUEST:
-		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;    
-            
+		{           
+            sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];          
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/ov7675.c b/drivers/media/video/ov7675.c
index 03d19f88929f..a94b2d1f8da4 100755
--- a/drivers/media/video/ov7675.c
+++ b/drivers/media/video/ov7675.c
@@ -1792,7 +1792,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -1810,7 +1810,48 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
         mf->width = SENSOR_MAX_WIDTH;
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
+    
+    set_w = mf->width;
+    set_h = mf->height;
 
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;		
+    }
+
+    mf->width = set_w;
+    mf->height = set_h;
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2571,12 +2612,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/rk29_camera.c b/drivers/media/video/rk29_camera.c
index 13ee3a968c8c..91ff7836ebc8 100755
--- a/drivers/media/video/rk29_camera.c
+++ b/drivers/media/video/rk29_camera.c
@@ -56,6 +56,12 @@
 #define PMEM_CAM_NECESSARY   0x1200000
 #define PMEM_CAMIPP_NECESSARY    0x800000
 #endif
+
+#if CONFIG_VIDEO_RK29_CAMMEM_ION
+#undef PMEM_CAM_NECESSARY
+#define PMEM_CAM_NECESSARY   0x00000000
+#endif
+
 /*---------------- Camera Sensor Fixed Macro End  ------------------------*/
 #else   //#ifdef CONFIG_VIDEO_RK29 
 #define PMEM_CAM_NECESSARY   0x00000000
@@ -68,7 +74,7 @@
  *****************************************************************************************/
 #ifdef CONFIG_VIDEO_RK29 
 static int camera_debug;
-module_param(camera_debug, int, S_IRUGO|S_IWUSR);
+module_param(camera_debug, int, S_IRUGO|S_IWUSR|S_IWGRP);
 
 #define ddprintk(level, fmt, arg...) do {			\
 	if (camera_debug >= level) 					\
@@ -76,10 +82,27 @@ module_param(camera_debug, int, S_IRUGO|S_IWUSR);
 
 #define dprintk(format, ...) ddprintk(1, format, ## __VA_ARGS__)    
 
-#define SENSOR_NAME_0 STR(CONFIG_SENSOR_0)			/* back camera sensor */
-#define SENSOR_NAME_1 STR(CONFIG_SENSOR_1)			/* front camera sensor */
+#define SENSOR_NAME_0 STR(CONFIG_SENSOR_0)			/* back camera sensor 0 */
 #define SENSOR_DEVICE_NAME_0  STR(CONS(CONFIG_SENSOR_0, _back))
+#ifdef CONFIG_SENSOR_01
+#define SENSOR_NAME_01 STR(CONFIG_SENSOR_01)			/* back camera sensor 1 */
+#define SENSOR_DEVICE_NAME_01  STR(CONS(CONFIG_SENSOR_01, _back_1))
+#endif
+#ifdef CONFIG_SENSOR_02
+#define SENSOR_NAME_02 STR(CONFIG_SENSOR_02)			/* back camera sensor 2 */
+#define SENSOR_DEVICE_NAME_02  STR(CONS(CONFIG_SENSOR_02, _back_2))
+#endif
+#define SENSOR_NAME_1 STR(CONFIG_SENSOR_1)			/* front camera sensor 0 */
 #define SENSOR_DEVICE_NAME_1  STR(CONS(CONFIG_SENSOR_1, _front))
+#ifdef CONFIG_SENSOR_11
+#define SENSOR_NAME_11 STR(CONFIG_SENSOR_11)			/* front camera sensor 1 */
+#define SENSOR_DEVICE_NAME_11  STR(CONS(CONFIG_SENSOR_11, _front_1))
+#endif
+#ifdef CONFIG_SENSOR_12
+#define SENSOR_NAME_12 STR(CONFIG_SENSOR_12)			/* front camera sensor 2 */
+#define SENSOR_DEVICE_NAME_12  STR(CONS(CONFIG_SENSOR_12, _front_2))
+#endif
+
 
 static int rk29_sensor_io_init(void);
 static int rk29_sensor_io_deinit(int sensor);
@@ -97,7 +120,43 @@ static struct rk29camera_platform_data rk29_camera_platform_data = {
             .gpio_flash = CONFIG_SENSOR_FALSH_PIN_0,
             .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_0|CONFIG_SENSOR_RESETACTIVE_LEVEL_0|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0|CONFIG_SENSOR_FLASHACTIVE_LEVEL_0),
             .gpio_init = 0,            
-            .dev_name = SENSOR_DEVICE_NAME_0,
+            .dev_name = SENSOR_DEVICE_NAME_0,        
+        }, {
+        #ifdef CONFIG_SENSOR_01
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_01,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_01,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_01,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_01,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_01|CONFIG_SENSOR_RESETACTIVE_LEVEL_01|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01|CONFIG_SENSOR_FLASHACTIVE_LEVEL_01),
+            .gpio_init = 0,            
+            .dev_name = SENSOR_DEVICE_NAME_01,
+        #else
+            .gpio_reset = INVALID_GPIO,
+            .gpio_power = INVALID_GPIO,
+            .gpio_powerdown = INVALID_GPIO,
+            .gpio_flash = INVALID_GPIO,
+            .gpio_flag = 0,
+            .gpio_init = 0,            
+            .dev_name = NULL,
+        #endif
+        }, {
+        #ifdef CONFIG_SENSOR_02
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_02,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_02,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_02,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_02,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_02|CONFIG_SENSOR_RESETACTIVE_LEVEL_02|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02|CONFIG_SENSOR_FLASHACTIVE_LEVEL_02),
+            .gpio_init = 0,            
+            .dev_name = SENSOR_DEVICE_NAME_02, 
+        #else
+            .gpio_reset = INVALID_GPIO,
+            .gpio_power = INVALID_GPIO,
+            .gpio_powerdown = INVALID_GPIO,
+            .gpio_flash = INVALID_GPIO,
+            .gpio_flag = 0,
+            .gpio_init = 0,            
+            .dev_name = NULL,
+        #endif
         }, {
             .gpio_reset = CONFIG_SENSOR_RESET_PIN_1,
             .gpio_power = CONFIG_SENSOR_POWER_PIN_1,
@@ -106,6 +165,42 @@ static struct rk29camera_platform_data rk29_camera_platform_data = {
             .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_1|CONFIG_SENSOR_RESETACTIVE_LEVEL_1|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1|CONFIG_SENSOR_FLASHACTIVE_LEVEL_1),
             .gpio_init = 0,
             .dev_name = SENSOR_DEVICE_NAME_1,
+        },{
+        #ifdef CONFIG_SENSOR_11
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_11,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_11,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_11,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_11,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_11|CONFIG_SENSOR_RESETACTIVE_LEVEL_11|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11|CONFIG_SENSOR_FLASHACTIVE_LEVEL_11),
+            .gpio_init = 0,
+            .dev_name = SENSOR_DEVICE_NAME_11,
+        #else
+            .gpio_reset = INVALID_GPIO,
+            .gpio_power = INVALID_GPIO,
+            .gpio_powerdown = INVALID_GPIO,
+            .gpio_flash = INVALID_GPIO,
+            .gpio_flag = 0,
+            .gpio_init = 0,            
+            .dev_name = NULL,
+        #endif        
+        }, {
+        #ifdef CONFIG_SENSOR_12
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_12,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_12,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_12,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_12,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_12|CONFIG_SENSOR_RESETACTIVE_LEVEL_12|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12|CONFIG_SENSOR_FLASHACTIVE_LEVEL_12),
+            .gpio_init = 0,
+            .dev_name = SENSOR_DEVICE_NAME_12,
+        #else
+            .gpio_reset = INVALID_GPIO,
+            .gpio_power = INVALID_GPIO,
+            .gpio_powerdown = INVALID_GPIO,
+            .gpio_flash = INVALID_GPIO,
+            .gpio_flag = 0,
+            .gpio_init = 0,            
+            .dev_name = NULL,
+        #endif
         }
     },
 	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
@@ -118,11 +213,47 @@ static struct rk29camera_platform_data rk29_camera_platform_data = {
     .info = {
         {
             .dev_name = SENSOR_DEVICE_NAME_0,
-            .orientation = CONFIG_SENSOR_ORIENTATION_0, 
+            .orientation = CONFIG_SENSOR_ORIENTATION_0,  
+        #ifdef CONFIG_SENSOR_01
+	    },{
+	        .dev_name = SENSOR_DEVICE_NAME_01,
+            .orientation = CONFIG_SENSOR_ORIENTATION_01, 
+        #else
+        },{
+	        .dev_name = NULL,
+            .orientation = 0x00, 
+        #endif
+        #ifdef CONFIG_SENSOR_02
 	    },{
+	        .dev_name = SENSOR_DEVICE_NAME_02,
+            .orientation = CONFIG_SENSOR_ORIENTATION_02, 
+        #else
+        },{
+	        .dev_name = NULL,
+            .orientation = 0x00, 
+        #endif
+        },{
             .dev_name = SENSOR_DEVICE_NAME_1,
             .orientation = CONFIG_SENSOR_ORIENTATION_1,
-        }
+        #ifdef CONFIG_SENSOR_11 
+        },{
+            .dev_name = SENSOR_DEVICE_NAME_11,
+            .orientation = CONFIG_SENSOR_ORIENTATION_11, 
+        #else
+        },{
+	        .dev_name = NULL,
+            .orientation = 0x00, 
+        #endif
+        #ifdef CONFIG_SENSOR_12
+	    },{
+	        .dev_name = SENSOR_DEVICE_NAME_12,
+            .orientation = CONFIG_SENSOR_ORIENTATION_12, 
+        #else
+        },{
+	        .dev_name = NULL,
+            .orientation = 0x00, 
+        #endif
+	    }
 	}
 };
 
@@ -1099,7 +1230,7 @@ static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
     int ret = 0;
     
     if (camera_power != INVALID_GPIO)  {
-		     if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
+		if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
             if (on) {
             	gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
     			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
@@ -1221,7 +1352,149 @@ static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
     return ret;
 }
 
-
+static void rk29_sensor_fps_get(int idx, unsigned int *val, int w, int h)
+{
+    switch (idx)
+    {
+        case 0:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_0;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_0
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_0;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_0;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_0;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_0;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_0;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_0;
+            }
+            break;
+        }
+        #ifdef CONFIG_SENSOR_01
+        case 1:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_01;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_01
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_01;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_01;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_01;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_01;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_01;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_01;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_02
+        case 2:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_02;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_02
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_02;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_02;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_02;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_02;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_02;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_02;
+            }
+            break;
+        }
+        #endif
+        
+        case 3:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_1;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_1
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_1;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_1;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_1;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_1;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_1;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_1;
+            }
+            break;
+        }
+        #ifdef CONFIG_SENSOR_11
+        case 4:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_11;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_11
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_11;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_11;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_11;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_11;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_11;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_11;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_12
+        case 5:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_12;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_12
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_12;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_12;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_12;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_12;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_12;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_12;
+            }
+            break;
+        }
+        #endif
+        default:
+            printk(KERN_ERR"rk29_cam_io: sensor-%d have not been define in board file!",idx);
+    }
+}
 static int rk29_sensor_io_init(void)
 {
     int ret = 0, i,j;
@@ -1238,7 +1511,10 @@ static int rk29_sensor_io_init(void)
     if (sensor_ioctl_cb.sensor_flash_cb == NULL)
         sensor_ioctl_cb.sensor_flash_cb = sensor_flash_default_cb;
     
-    for (i=0; i<2; i++) {
+    for (i=0; i<RK29_CAM_SUPPORT_NUMS; i++) {
+        if (rk29_camera_platform_data.gpio_res[i].dev_name == NULL)
+            continue;
+        
         camera_reset = rk29_camera_platform_data.gpio_res[i].gpio_reset;
         camera_power = rk29_camera_platform_data.gpio_res[i].gpio_power;
 		camera_powerdown = rk29_camera_platform_data.gpio_res[i].gpio_powerdown;
@@ -1253,7 +1529,11 @@ static int rk29_sensor_io_init(void)
                     printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
 				    goto sensor_io_int_loop_end;
                 } else {
-                    if (camera_power != rk29_camera_platform_data.gpio_res[0].gpio_power) {
+                    for (j=0; j<i; j++) {
+                        if (camera_power == rk29_camera_platform_data.gpio_res[j].gpio_power)
+                            break;
+                    }
+                    if (i==j) {
                         printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
                         goto sensor_io_int_loop_end;
                     }
@@ -1276,8 +1556,34 @@ static int rk29_sensor_io_init(void)
         if (camera_reset != INVALID_GPIO) {
             ret = gpio_request(camera_reset, "camera reset");
             if (ret) {
-                printk("%s..%s..reset pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
-                goto sensor_io_int_loop_end;
+                if (i==1) {
+                    if ((camera_reset == rk29_camera_platform_data.gpio_res[0].gpio_reset) 
+                        || (camera_reset == rk29_camera_platform_data.gpio_res[2].gpio_reset)) {
+                        ret = 0;
+                    }
+                }
+                if (i==2) {
+                    if ((camera_reset == rk29_camera_platform_data.gpio_res[0].gpio_reset) 
+                        || (camera_reset == rk29_camera_platform_data.gpio_res[1].gpio_reset)) {
+                        ret = 0;
+                    }
+                }
+                if (i==4) {
+                    if ((camera_reset == rk29_camera_platform_data.gpio_res[3].gpio_reset) 
+                        || (camera_reset == rk29_camera_platform_data.gpio_res[5].gpio_reset)) {
+                        ret = 0;
+                    }
+                }
+                if (i==5) {
+                    if ((camera_reset == rk29_camera_platform_data.gpio_res[3].gpio_reset) 
+                        || (camera_reset == rk29_camera_platform_data.gpio_res[4].gpio_reset)) {
+                        ret = 0;
+                    }
+                }
+                if (ret) {
+                    printk("%s..%s..reset pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
+                    goto sensor_io_int_loop_end;
+                }
             }
 
             if (rk29_sensor_iomux(camera_reset) < 0) {
@@ -1296,8 +1602,34 @@ static int rk29_sensor_io_init(void)
 		if (camera_powerdown != INVALID_GPIO) {
             ret = gpio_request(camera_powerdown, "camera powerdown");
             if (ret) {
-                printk("%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
-                goto sensor_io_int_loop_end;
+                if (i==1) {
+                    if ((camera_powerdown == rk29_camera_platform_data.gpio_res[0].gpio_powerdown) 
+                        || (camera_powerdown == rk29_camera_platform_data.gpio_res[2].gpio_powerdown)) {
+                        ret = 0;
+                    }
+                }
+                if (i==2) {
+                    if ((camera_powerdown == rk29_camera_platform_data.gpio_res[0].gpio_powerdown) 
+                        || (camera_powerdown == rk29_camera_platform_data.gpio_res[1].gpio_powerdown)) {
+                        ret = 0;
+                    }
+                }
+                if (i==4) {
+                    if ((camera_powerdown == rk29_camera_platform_data.gpio_res[3].gpio_powerdown) 
+                        || (camera_powerdown == rk29_camera_platform_data.gpio_res[5].gpio_powerdown)) {
+                        ret = 0;
+                    }
+                }
+                if (i==5) {
+                    if ((camera_powerdown == rk29_camera_platform_data.gpio_res[3].gpio_powerdown) 
+                        || (camera_powerdown == rk29_camera_platform_data.gpio_res[4].gpio_powerdown)) {
+                        ret = 0;
+                    }
+                }
+                if (ret) {
+                    printk("%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
+                    goto sensor_io_int_loop_end;
+                }
             }
 
             if (rk29_sensor_iomux(camera_powerdown) < 0) {
@@ -1316,8 +1648,34 @@ static int rk29_sensor_io_init(void)
 		if (camera_flash != INVALID_GPIO) {
             ret = gpio_request(camera_flash, "camera flash");
             if (ret) {
-                printk("%s..%s..flash pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);
-				goto sensor_io_int_loop_end;
+                if (i==1) {
+                    if ((camera_flash == rk29_camera_platform_data.gpio_res[0].gpio_flash) 
+                        || (camera_flash == rk29_camera_platform_data.gpio_res[2].gpio_flash)) {
+                        ret = 0;
+                    }
+                }
+                if (i==2) {
+                    if ((camera_flash == rk29_camera_platform_data.gpio_res[0].gpio_flash) 
+                        || (camera_flash == rk29_camera_platform_data.gpio_res[1].gpio_flash)) {
+                        ret = 0;
+                    }
+                }
+                if (i==4) {
+                    if ((camera_flash == rk29_camera_platform_data.gpio_res[3].gpio_flash) 
+                        || (camera_flash == rk29_camera_platform_data.gpio_res[5].gpio_flash)) {
+                        ret = 0;
+                    }
+                }
+                if (i==5) {
+                    if ((camera_flash == rk29_camera_platform_data.gpio_res[3].gpio_flash) 
+                        || (camera_flash == rk29_camera_platform_data.gpio_res[4].gpio_flash)) {
+                        ret = 0;
+                    }
+                }
+                if (ret) {
+                    printk("%s..%s..flash pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);
+    				goto sensor_io_int_loop_end;
+                }
             }
 
             if (rk29_sensor_iomux(camera_flash) < 0) {
@@ -1335,164 +1693,37 @@ static int rk29_sensor_io_init(void)
         
         for (j=0; j<10; j++) {
             memset(&rk29_camera_platform_data.info[i].fival[j],0x00,sizeof(struct v4l2_frmivalenum));
-        }
-        j=0;
-        if (strstr(rk29_camera_platform_data.info[i].dev_name,"_back")) {
-            
-            #if CONFIG_SENSOR_QCIF_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 176;
-            rk29_camera_platform_data.info[i].fival[j].height = 144;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_QVGA_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 320;
-            rk29_camera_platform_data.info[i].fival[j].height = 240;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_CIF_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 352;
-            rk29_camera_platform_data.info[i].fival[j].height = 288;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_VGA_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 640;
-            rk29_camera_platform_data.info[i].fival[j].height = 480;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_480P_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 720;
-            rk29_camera_platform_data.info[i].fival[j].height = 480;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif            
-
-            #if CONFIG_SENSOR_SVGA_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 800;
-            rk29_camera_platform_data.info[i].fival[j].height = 600;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
 
-            #if CONFIG_SENSOR_720P_FPS_FIXED_0
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_0;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 1280;
-            rk29_camera_platform_data.info[i].fival[j].height = 720;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-        } else {
-            #if CONFIG_SENSOR_QCIF_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 176;
-            rk29_camera_platform_data.info[i].fival[j].height = 144;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_QVGA_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 320;
-            rk29_camera_platform_data.info[i].fival[j].height = 240;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_CIF_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 352;
-            rk29_camera_platform_data.info[i].fival[j].height = 288;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_VGA_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 640;
-            rk29_camera_platform_data.info[i].fival[j].height = 480;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_480P_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 720;
-            rk29_camera_platform_data.info[i].fival[j].height = 480;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif 
-
-            #if CONFIG_SENSOR_SVGA_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 800;
-            rk29_camera_platform_data.info[i].fival[j].height = 600;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_720P_FPS_FIXED_1
-            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_1;
-            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
-            rk29_camera_platform_data.info[i].fival[j].index = 0;
-            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            rk29_camera_platform_data.info[i].fival[j].width = 1280;
-            rk29_camera_platform_data.info[i].fival[j].height = 720;
-            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
+            if (j==0) {
+                rk29_camera_platform_data.info[i].fival[j].width = 176;
+                rk29_camera_platform_data.info[i].fival[j].height = 144;
+            } else if (j==1) {
+                rk29_camera_platform_data.info[i].fival[j].width = 320;
+                rk29_camera_platform_data.info[i].fival[j].height = 240;
+            } else if (j==2) {
+                rk29_camera_platform_data.info[i].fival[j].width = 352;
+                rk29_camera_platform_data.info[i].fival[j].height = 288;
+            } else if (j==3) {
+                rk29_camera_platform_data.info[i].fival[j].width = 640;
+                rk29_camera_platform_data.info[i].fival[j].height = 480;
+            } else if (j==4) {
+                rk29_camera_platform_data.info[i].fival[j].width = 720;
+                rk29_camera_platform_data.info[i].fival[j].height = 480;
+            } else if (j==5) {
+                rk29_camera_platform_data.info[i].fival[j].width = 1280;
+                rk29_camera_platform_data.info[i].fival[j].height = 720;
+            } else if (j==6) {
+                rk29_camera_platform_data.info[i].fival[j].width = 240;
+                rk29_camera_platform_data.info[i].fival[j].height = 160;
+            }
+            if (rk29_camera_platform_data.info[i].fival[j].width && rk29_camera_platform_data.info[i].fival[j].height) {
+                rk29_sensor_fps_get(i,&rk29_camera_platform_data.info[i].fival[j].discrete.denominator,
+                    rk29_camera_platform_data.info[i].fival[j].width,rk29_camera_platform_data.info[i].fival[j].height);
+                rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+                rk29_camera_platform_data.info[i].fival[j].index = 0;
+                rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+                rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            }
         }
         
 		continue;
@@ -1550,13 +1781,14 @@ static int rk29_sensor_io_deinit(int sensor)
 static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on)
 {
     struct rk29camera_gpio_res *res = NULL;    
-	int ret = RK29_CAM_IO_SUCCESS;
+	int ret = RK29_CAM_IO_SUCCESS,i;
 
-    if(rk29_camera_platform_data.gpio_res[0].dev_name &&  (strcmp(rk29_camera_platform_data.gpio_res[0].dev_name, dev_name(dev)) == 0)) {
-		res = (struct rk29camera_gpio_res *)&rk29_camera_platform_data.gpio_res[0];
-    } else if (rk29_camera_platform_data.gpio_res[1].dev_name && (strcmp(rk29_camera_platform_data.gpio_res[1].dev_name, dev_name(dev)) == 0)) {
-    	res = (struct rk29camera_gpio_res *)&rk29_camera_platform_data.gpio_res[1];
-    } else {
+    for (i=0; i<RK29_CAM_SUPPORT_NUMS; i++) {
+        if(rk29_camera_platform_data.gpio_res[i].dev_name &&  (strcmp(rk29_camera_platform_data.gpio_res[i].dev_name, dev_name(dev)) == 0)) {
+    		res = (struct rk29camera_gpio_res *)&rk29_camera_platform_data.gpio_res[i];
+        } 
+    }
+    if (res == NULL) {
         printk(KERN_ERR "%s is not regisiterd in rk29_camera_platform_data!!\n",dev_name(dev));
         ret = RK29_CAM_EIO_INVALID;
         goto rk29_sensor_ioctrl_end;
@@ -1615,12 +1847,18 @@ static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd,
 rk29_sensor_ioctrl_end:
     return ret;
 }
+
+static int rk29_sensor_powerdown(struct device *dev, int on)
+{
+	return rk29_sensor_ioctrl(dev,Cam_PowerDown,on);
+}
 static int rk29_sensor_power(struct device *dev, int on)
 {
-	rk29_sensor_ioctrl(dev,Cam_Power,on);
+    if (!on)                        /* ddl@rock-chips.com : Ensure sensor enter standby or power off */
+        rk29_sensor_powerdown(dev,1);
+	rk29_sensor_ioctrl(dev,Cam_Power,on);    
     return 0;
 }
-#if (CONFIG_SENSOR_RESET_PIN_0 != INVALID_GPIO) || (CONFIG_SENSOR_RESET_PIN_1 != INVALID_GPIO)
 static int rk29_sensor_reset(struct device *dev)
 {
 	rk29_sensor_ioctrl(dev,Cam_Reset,1);
@@ -1628,11 +1866,7 @@ static int rk29_sensor_reset(struct device *dev)
 	rk29_sensor_ioctrl(dev,Cam_Reset,0);
 	return 0;
 }
-#endif
-static int rk29_sensor_powerdown(struct device *dev, int on)
-{
-	return rk29_sensor_ioctrl(dev,Cam_PowerDown,on);
-}
+
 #if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
 static struct i2c_board_info rk29_i2c_cam_info_0[] = {
 	{
@@ -1691,6 +1925,130 @@ static struct platform_device rk29_soc_camera_pdrv_1 = {
 	},
 };
 #endif
+#ifdef CONFIG_SENSOR_01
+#if (CONFIG_SENSOR_IIC_ADDR_01 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_01[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_01, CONFIG_SENSOR_IIC_ADDR_01>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_01 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_01 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif    
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_01[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_01,
+	.module_name	= SENSOR_NAME_01,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_01 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 8,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_01,
+		.platform_data = &rk29_iclink_01,
+	},
+};
+#endif
+#endif
+#ifdef CONFIG_SENSOR_02
+#if (CONFIG_SENSOR_IIC_ADDR_02 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_02[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_02, CONFIG_SENSOR_IIC_ADDR_02>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_02 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_02 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif    
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_02[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_02,
+	.module_name	= SENSOR_NAME_02,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_02 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 3,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_02,
+		.platform_data = &rk29_iclink_02,
+	},
+};
+#endif
+#endif
+#ifdef CONFIG_SENSOR_11
+#if (CONFIG_SENSOR_IIC_ADDR_11 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_11[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_11, CONFIG_SENSOR_IIC_ADDR_11>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_11 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_11 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif  	
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_11[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_11,
+	.module_name	= SENSOR_NAME_11,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_11 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 4,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_11,
+		.platform_data = &rk29_iclink_11,
+	},
+};
+#endif
+#endif
+#ifdef CONFIG_SENSOR_12
+#if (CONFIG_SENSOR_IIC_ADDR_12 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_12[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_12, CONFIG_SENSOR_IIC_ADDR_12>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_12 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_12 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif  	
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_12[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_12,
+	.module_name	= SENSOR_NAME_12,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_12 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 5,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_12,
+		.platform_data = &rk29_iclink_12,
+	},
+};
+#endif
+#endif
 
 static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
 static struct resource rk29_camera_resource[] = {
@@ -1718,7 +2076,7 @@ static struct platform_device rk29_device_camera = {
 		.platform_data  = &rk29_camera_platform_data,
 	}
 };
-
+#if (PMEM_CAM_SIZE > 0)
 static struct android_pmem_platform_data android_pmem_cam_pdata = {
 	.name		= "pmem_cam",
 	.start		= PMEM_CAM_BASE,
@@ -1734,7 +2092,7 @@ static struct platform_device android_pmem_cam_device = {
 		.platform_data = &android_pmem_cam_pdata,
 	},
 };
-
+#endif
 #endif
 
 #endif //#ifdef CONFIG_VIDEO_RK29
diff --git a/drivers/media/video/rk29_camera_oneframe.c b/drivers/media/video/rk29_camera_oneframe.c
index 53232ef559e1..dd7cd4534bd8 100755
--- a/drivers/media/video/rk29_camera_oneframe.c
+++ b/drivers/media/video/rk29_camera_oneframe.c
@@ -41,7 +41,7 @@
 
 
 static int debug;
-module_param(debug, int, S_IRUGO|S_IWUSR);
+module_param(debug, int, S_IRUGO|S_IWUSR|S_IWGRP);
 
 #define dprintk(level, fmt, arg...) do {			\
 	if (debug >= level) 					\
@@ -148,8 +148,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 *v0.x.4 : this driver support digital zoom;
 *v0.x.5 : this driver support test framerate and query framerate from board file configuration;
 *v0.x.6 : this driver improve test framerate method;
+*v0.x.7 : this driver product resolution by IPP crop and scale, which user request but sensor can't support;
+*         note: this version is only provide yifang client, which is not official version;
+*v0.x.8 : this driver and rk29_camera.c support upto 3 back-sensors and upto 3 front-sensors;
 */
-#define RK29_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 6)
+#define RK29_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 8)
 
 /* limit to rk29 hardware capabilities */
 #define RK29_CAM_BUS_PARAM   (SOCAM_MASTER |\
@@ -316,6 +319,8 @@ static int rk29_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
     struct rk29_camera_dev *pcdev = ici->priv;
     int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
+    int bytes_per_line_host = soc_mbus_bytes_per_line(pcdev->host_width,
+						icd->current_fmt->host_fmt);
 
     dev_dbg(&icd->dev, "count=%d, size=%d\n", *count, *size);
 
@@ -324,7 +329,7 @@ static int rk29_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 
 	/* planar capture requires Y, U and V buffers to be page aligned */
 	*size = PAGE_ALIGN(bytes_per_line*icd->user_height);       /* Y pages UV pages, yuv422*/
-	pcdev->vipmem_bsize = PAGE_ALIGN(bytes_per_line * pcdev->host_height);
+	pcdev->vipmem_bsize = PAGE_ALIGN(bytes_per_line_host * pcdev->host_height);
 
 
 	if (CAM_WORKQUEUE_IS_EN()) {
@@ -860,9 +865,8 @@ static int rk29_camera_add_device(struct soc_camera_device *icd)
         goto ebusy;
     }
 
-    dev_info(&icd->dev, "RK29 Camera driver attached to camera%d(%s)\n",
-             icd->devnum,dev_name(icd->pdev));
-
+    RK29CAMERA_DG("RK29 Camera driver attached to %s\n",dev_name(icd->pdev));
+    
 	pcdev->frame_inval = RK29_CAM_FRAME_INVAL_INIT;
     pcdev->active = NULL;
     pcdev->icd = NULL;
@@ -928,8 +932,7 @@ static void rk29_camera_remove_device(struct soc_camera_device *icd)
 	mutex_lock(&camera_lock);
     BUG_ON(icd != pcdev->icd);
 
-    dev_info(&icd->dev, "RK29 Camera driver detached from camera%d(%s)\n",
-             icd->devnum,dev_name(icd->pdev));
+    RK29CAMERA_DG("RK29 Camera driver detached from %s\n",dev_name(icd->pdev));
 
 	/* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
 	   stream may be turn on again before close device, if suspend and resume happened. */
@@ -1317,25 +1320,50 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
     		ret = -EINVAL;
             goto RK29_CAMERA_SET_FMT_END;
     	}
-		mf.width = usr_w;
-		mf.height = usr_h;
 	}
 	#endif
     icd->sense = NULL;
 
     if (!ret) {
-        rect.left = 0;
-        rect.top = 0;
-        rect.width = mf.width;
-        rect.height = mf.height;
+
+        if (mf.width*usr_h == mf.height*usr_w) {
+            rect.width = mf.width;
+            rect.height = mf.height;
+        } else {
+            int ratio;
+            if (usr_w > usr_h) {
+                if (mf.width > usr_w) {
+                    ratio = mf.width*10/usr_w;
+                    rect.width = usr_w*ratio/10;
+                    rect.height = usr_h*ratio/10;                    
+                } else {
+                    ratio = usr_w*10/mf.width + 1;
+                    rect.width = usr_w*10/ratio;
+                    rect.height = usr_h*10/ratio;
+                }                
+            } else {
+                if (mf.height > usr_h) {
+                    ratio = mf.height*10/usr_h;
+                    rect.width = usr_w*ratio/10;
+                    rect.height = usr_h*ratio/10;                    
+                } else {
+                    ratio = usr_h*10/mf.height + 1;
+                    rect.width = usr_w*10/ratio;
+                    rect.height = usr_h*10/ratio;
+                }
+            }
+        }
+
+        rect.left = (mf.width - rect.width)/2;
+        rect.top = (mf.height - rect.height)/2;
 
         down(&pcdev->zoominfo.sem);        
         pcdev->zoominfo.a.c.width = rect.width*100/pcdev->zoominfo.zoom_rate;
 		pcdev->zoominfo.a.c.width &= ~0x03;
 		pcdev->zoominfo.a.c.height = rect.height*100/pcdev->zoominfo.zoom_rate;
 		pcdev->zoominfo.a.c.height &= ~0x03;
-		pcdev->zoominfo.a.c.left = ((rect.width - pcdev->zoominfo.a.c.width)>>1)&(~0x01);
-		pcdev->zoominfo.a.c.top = ((rect.height - pcdev->zoominfo.a.c.height)>>1)&(~0x01);
+		pcdev->zoominfo.a.c.left = ((rect.width - pcdev->zoominfo.a.c.width)/2 + rect.left)&(~0x01);
+		pcdev->zoominfo.a.c.top = ((rect.height - pcdev->zoominfo.a.c.height)/2 + rect.top)&(~0x01);
         up(&pcdev->zoominfo.sem);
 
         /* ddl@rock-chips.com: IPP work limit check */
@@ -1355,9 +1383,17 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
             }
         }
         
-        RK29CAMERA_DG("%s..%s icd width:%d  host width:%d (zoom: %dx%d@(%d,%d)->%dx%d)\n",__FUNCTION__,xlate->host_fmt->name,
-			           rect.width, pix->width, pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height, pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,
+        /* ddl@rock-chips.com: Crop is doing by IPP, not by VIP in rk2918 */
+        rect.left = 0;
+        rect.top = 0;
+        rect.width = mf.width;
+        rect.height = mf.height;
+        
+        RK29CAMERA_DG("%s..%s Sensor output:%dx%d  VIP output:%dx%d (zoom: %dx%d@(%d,%d)->%dx%d)\n",__FUNCTION__,xlate->host_fmt->name,
+			           mf.width, mf.height,rect.width,rect.height, pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height, pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,
 			           pix->width, pix->height);
+
+                
         rk29_camera_setup_format(icd, pix->pixelformat, mf.code, &rect); 
         
 		if (CAM_IPPWORK_IS_EN()) {
@@ -1366,8 +1402,8 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
         pcdev->icd_width = icd_width;
         pcdev->icd_height = icd_height;
 
-        pix->width = mf.width;
-    	pix->height = mf.height;
+        pix->width = usr_w;
+    	pix->height = usr_h;
     	pix->field = mf.field;
     	pix->colorspace = mf.colorspace;
     	icd->current_fmt = xlate;        
@@ -1377,7 +1413,7 @@ static int rk29_camera_set_fmt(struct soc_camera_device *icd,
     if (stream_on & ENABLE_CAPTURE)
         write_vip_reg(RK29_VIP_CTRL, (read_vip_reg(RK29_VIP_CTRL) | ENABLE_CAPTURE));
 	if (ret)
-    	RK29CAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
+    	RK29CAMERA_TR("\n%s: Driver isn't support %dx%d resolution which user request!\n",__FUNCTION__,usr_w,usr_h);
     return ret;
 }
 static bool rk29_camera_fmt_capturechk(struct v4l2_format *f)
@@ -1413,7 +1449,8 @@ static int rk29_camera_try_fmt(struct soc_camera_device *icd,
 	bool is_capture = rk29_camera_fmt_capturechk(f);
 	bool vipmem_is_overflow = false;
     struct v4l2_mbus_framefmt mf;
-
+    int bytes_per_line_host;
+    
 	usr_w = pix->width;
 	usr_h = pix->height;
 	RK29CAMERA_DG("%s enter width:%d  height:%d\n",__FUNCTION__,usr_w,usr_h);
@@ -1454,13 +1491,14 @@ static int rk29_camera_try_fmt(struct soc_camera_device *icd,
 		goto RK29_CAMERA_TRY_FMT_END;
     RK29CAMERA_DG("%s mf.width:%d  mf.height:%d\n",__FUNCTION__,mf.width,mf.height);
 	#ifdef CONFIG_VIDEO_RK29_WORK_IPP       
-	if ((mf.width > usr_w) && (mf.height > usr_h)) {
+	if ((mf.width != usr_w) || (mf.height != usr_h)) {
+        bytes_per_line_host = soc_mbus_bytes_per_line(mf.width,icd->current_fmt->host_fmt); 
 		if (is_capture) {
-			vipmem_is_overflow = (PAGE_ALIGN(pix->bytesperline*pix->height) > pcdev->vipmem_size);
+			vipmem_is_overflow = (PAGE_ALIGN(bytes_per_line_host*mf.height) > pcdev->vipmem_size);
 		} else {
 			/* Assume preview buffer minimum is 4 */
-			vipmem_is_overflow = (PAGE_ALIGN(pix->bytesperline*pix->height)*4 > pcdev->vipmem_size);
-		}
+			vipmem_is_overflow = (PAGE_ALIGN(bytes_per_line_host*mf.height)*4 > pcdev->vipmem_size);
+		}        
 		if (vipmem_is_overflow == false) {
 			pix->width = usr_w;
 			pix->height = usr_h;
@@ -1469,26 +1507,14 @@ static int rk29_camera_try_fmt(struct soc_camera_device *icd,
             pix->width = mf.width;
             pix->height = mf.height;            
 		}
-	} else if ((mf.width < usr_w) && (mf.height < usr_h)) {
-		if (((usr_w>>1) < mf.width) && ((usr_h>>1) < mf.height)) {
-			if (is_capture) {
-				vipmem_is_overflow = (PAGE_ALIGN(pix->bytesperline*pix->height) > pcdev->vipmem_size);
-			} else {
-				vipmem_is_overflow = (PAGE_ALIGN(pix->bytesperline*pix->height)*4 > pcdev->vipmem_size);
-			}
-			if (vipmem_is_overflow == false) {
-				pix->width = usr_w;
-				pix->height = usr_h;
-			} else {
-				RK29CAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
+        
+        if ((mf.width < usr_w) || (mf.height < usr_h)) {
+            if (((usr_w>>1) > mf.width) || ((usr_h>>1) > mf.height)) {
+                RK29CAMERA_TR("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
                 pix->width = mf.width;
                 pix->height = mf.height;
-			}
-		} else {
-			RK29CAMERA_TR("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
-            pix->width = mf.width;
-            pix->height = mf.height;
-		}
+            }
+        }        
 	}
 	#else
     pix->width	= mf.width;
@@ -1497,15 +1523,15 @@ static int rk29_camera_try_fmt(struct soc_camera_device *icd,
     pix->colorspace	= mf.colorspace;    
 
     switch (mf.field) {
-	case V4L2_FIELD_ANY:
-	case V4L2_FIELD_NONE:
-		pix->field	= V4L2_FIELD_NONE;
-		break;
-	default:
-		/* TODO: support interlaced at least in pass-through mode */
-		dev_err(icd->dev.parent, "Field type %d unsupported.\n",
-			mf.field);
-		goto RK29_CAMERA_TRY_FMT_END;
+    	case V4L2_FIELD_ANY:
+    	case V4L2_FIELD_NONE:
+    		pix->field	= V4L2_FIELD_NONE;
+    		break;
+    	default:
+    		/* TODO: support interlaced at least in pass-through mode */
+    		dev_err(icd->dev.parent, "Field type %d unsupported.\n",
+    			mf.field);
+    		goto RK29_CAMERA_TRY_FMT_END;
 	}
 
 RK29_CAMERA_TRY_FMT_END:
@@ -1555,14 +1581,27 @@ static int rk29_camera_querycap(struct soc_camera_host *ici,
 {
     struct rk29_camera_dev *pcdev = ici->priv;
     char orientation[5];
+    int i;
 
-    strlcpy(cap->card, dev_name(pcdev->icd->pdev), sizeof(cap->card));    
-    if (strcmp(dev_name(pcdev->icd->pdev), pcdev->pdata->info[0].dev_name) == 0) {
-        sprintf(orientation,"-%d",pcdev->pdata->info[0].orientation);
+    strlcpy(cap->card, dev_name(pcdev->icd->pdev), sizeof(cap->card));
+
+    memset(orientation,0x00,sizeof(orientation));
+    for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+        if ((pcdev->pdata->info[i].dev_name!=NULL) && (strcmp(dev_name(pcdev->icd->pdev), pcdev->pdata->info[i].dev_name) == 0)) {
+            sprintf(orientation,"-%d",pcdev->pdata->info[i].orientation);
+        }
+    }
+    
+    if (orientation[0] != '-') {
+        RK29CAMERA_TR("%s: %s is not registered in rk29_camera_platform_data, orientation apply default value",__FUNCTION__,dev_name(pcdev->icd->pdev));
+        if (strstr(dev_name(pcdev->icd->pdev),"front")) 
+            strcat(cap->card,"-270");
+        else 
+            strcat(cap->card,"-90");
     } else {
-        sprintf(orientation,"-%d",pcdev->pdata->info[1].orientation);
+        strcat(cap->card,orientation); 
     }
-    strcat(cap->card,orientation); 
+    
     cap->version = RK29_CAM_VERSION_CODE;
     cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 
@@ -1773,7 +1812,7 @@ int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_f
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct rk29_camera_dev *pcdev = ici->priv;
     struct rk29_camera_frmivalenum *fival_list = NULL;
-    struct v4l2_frmivalenum *fival_head;
+    struct v4l2_frmivalenum *fival_head=NULL;
     int i,ret = 0,index;
     
     index = fival->index & 0x00ffffff;
@@ -1806,12 +1845,20 @@ int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_f
             RK29CAMERA_TR("%s: fival_list is NULL\n",__FUNCTION__);
             ret = -EINVAL;
         }
-    } else {
-        if (strcmp(dev_name(pcdev->icd->pdev),pcdev->pdata->info[0].dev_name) == 0) {
-            fival_head = pcdev->pdata->info[0].fival;
-        } else {
-            fival_head = pcdev->pdata->info[1].fival;
+    } else {  
+
+        for (i=0; i<RK29_CAM_SUPPORT_NUMS; i++) {
+            if (pcdev->pdata->info[i].dev_name && (strcmp(dev_name(pcdev->icd->pdev),pcdev->pdata->info[i].dev_name) == 0)) {
+                fival_head = pcdev->pdata->info[i].fival;
+            }
         }
+        
+        if (fival_head == NULL) {
+            RK29CAMERA_TR("%s: %s is not registered in rk29_camera_platform_data!!",__FUNCTION__,dev_name(pcdev->icd->pdev));
+            ret = -EINVAL;
+            goto rk29_camera_enum_frameintervals_end;
+        }
+        
         i = 0;
         while (fival_head->width && fival_head->height) {
             if ((fival->pixel_format == fival_head->pixel_format)
@@ -1827,20 +1874,20 @@ int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_f
 
         if ((i == index) && (fival->height == fival_head->height) && (fival->width == fival_head->width)) {
             memcpy(fival, fival_head, sizeof(struct v4l2_frmivalenum));
-            RK29CAMERA_DG("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(&rk29_camdev_info_ptr->icd->dev),
+            RK29CAMERA_DG("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(rk29_camdev_info_ptr->icd->pdev),
                 fival->width, fival->height,
                 fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
 			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
 			     fival->discrete.denominator,fival->discrete.numerator);			    
         } else {
             if (index == 0)
-                RK29CAMERA_TR("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&rk29_camdev_info_ptr->icd->dev),
+                RK29CAMERA_TR("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(rk29_camdev_info_ptr->icd->pdev),
                     fival->width,fival->height, 
                     fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
     			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
     			    index);
             else
-                RK29CAMERA_DG("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&rk29_camdev_info_ptr->icd->dev),
+                RK29CAMERA_DG("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(rk29_camdev_info_ptr->icd->pdev),
                     fival->width,fival->height, 
                     fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
     			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
@@ -1848,7 +1895,7 @@ int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_f
             ret = -EINVAL;
         }
     }
-
+rk29_camera_enum_frameintervals_end:
     return ret;
 }
 
@@ -1969,7 +2016,9 @@ static int rk29_camera_probe(struct platform_device *pdev)
     int irq,i;
     int err = 0;
 
-    RK29CAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
+    RK29CAMERA_TR("RK29 Camera driver version: v%d.%d.%d\n",(RK29_CAM_VERSION_CODE&0xff0000)>>16,
+        (RK29_CAM_VERSION_CODE&0xff00)>>8,RK29_CAM_VERSION_CODE&0xff);
+    
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     irq = platform_get_irq(pdev, 0);
     if (!res || irq < 0) {
diff --git a/drivers/media/video/sid130B.c b/drivers/media/video/sid130B.c
index ef1f427615a2..0827afef9d8d 100755
--- a/drivers/media/video/sid130B.c
+++ b/drivers/media/video/sid130B.c
@@ -2130,7 +2130,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -2148,7 +2148,57 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
         mf->width = SENSOR_MAX_WIDTH;
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
-
+
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) &&( sensor_qcif[0].reg!=0xff))
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg!=0xff))
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg!=0xff))
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) &&( sensor_vga[0].reg!=0xff))
+    {
+        set_w =640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg!=0xff))
+    {
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) &&( sensor_xga[0].reg!=0xff))
+    {
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg!=0xff))
+    {
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && (sensor_uxga[0].reg!=0xff))
+    {
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;		
+    }
+    mf->width = set_w;
+    mf->height = set_h;  
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2920,18 +2970,23 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
-            if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
-                }
-            } else {
-                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
-                ret = -EINVAL;
-                goto sensor_ioctl_end;
+            if (sensor->sensor_io_request != NULL) { 
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
+                }
+            } else {
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                ret = -EINVAL;
+                goto sensor_ioctl_end;
             }
             /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
                for this project */
@@ -3086,4 +3141,4 @@ module_exit(sensor_mod_exit);
 
 MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
 MODULE_AUTHOR("ddl <kernel@rock-chips>");
-MODULE_LICENSE("GPL");
\ No newline at end of file
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/siv120b.c b/drivers/media/video/siv120b.c
index a300398eaad4..bfea1e0d6827 100755
--- a/drivers/media/video/siv120b.c
+++ b/drivers/media/video/siv120b.c
@@ -1814,7 +1814,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
-    int ret = 0;
+    int ret = 0,set_w,set_h;
    
 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
 				   ARRAY_SIZE(sensor_colour_fmts));
@@ -1832,7 +1832,37 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
         mf->width = SENSOR_MAX_WIDTH;
     else if (mf->width < SENSOR_MIN_WIDTH)
         mf->width = SENSOR_MIN_WIDTH;
+    
+    set_w = mf->width;
+    set_h = mf->height;
 
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        set_w = 640;
+        set_h = 480;
+    }
+    else
+    {
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;		
+    }
+    mf->width = set_w;
+    mf->height = set_h;  
     mf->colorspace = fmt->colorspace;
     
     return ret;
@@ -2609,12 +2639,17 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		{
 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                sensor->sensor_gpio_res = NULL;
+                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
+                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
+                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
+                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
+                    }
+                }
+                if (sensor->sensor_gpio_res == NULL) {
+                    SENSOR_TR("%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n",SENSOR_NAME_STRING(),__FUNCTION__);
+                    ret = -EINVAL;
+                    goto sensor_ioctl_end;
                 }
             } else {
                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
diff --git a/drivers/media/video/soc_camera.c b/drivers/media/video/soc_camera.c
index 86ab89524d06..8e7219337450 100755
--- a/drivers/media/video/soc_camera.c
+++ b/drivers/media/video/soc_camera.c
@@ -1109,8 +1109,8 @@ static void scan_add_host(struct soc_camera_host *ici)
 		if (icd->iface == ici->nr) {
 			int ret;
 			icd->dev.parent = ici->v4l2_dev.dev;
-			dev_set_name(&icd->dev, "%u-%u", icd->iface,
-				     icd->devnum);
+			dev_set_name(&icd->dev, "%u-%u-%s", icd->iface,
+				     icd->devnum,dev_name(icd->pdev));
 			ret = device_register(&icd->dev);
 			if (ret < 0) {
 				icd->dev.parent = NULL;
@@ -1185,8 +1185,6 @@ static int soc_camera_probe(struct device *dev)
 	struct v4l2_mbus_framefmt mf;
 	int ret;
 
-	dev_info(dev, "Probing %s\n", dev_name(dev));
-
 	ret = regulator_bulk_get(icd->pdev, icl->num_regulators,
 				 icl->regulators);
 	if (ret < 0)
@@ -1278,7 +1276,7 @@ static int soc_camera_probe(struct device *dev)
 	soc_camera_power_set(icd, icl, 0);
 
 	mutex_unlock(&icd->video_lock);
-
+    dev_info(dev, "Probe %s success\n", dev_name(icd->pdev));
 	return 0;
 
 evidstart:
@@ -1301,6 +1299,7 @@ static int soc_camera_probe(struct device *dev)
 epower:
 	regulator_bulk_free(icl->num_regulators, icl->regulators);
 ereg:
+    dev_err(dev, "Probe %s failed\n", dev_name(icd->pdev));
 	return ret;
 }
 
-- 
2.35.3

