From 0b5a7949669192a377eb2caec126685b40539a93 Mon Sep 17 00:00:00 2001
From: Jacob Chen <jacob2.chen@rock-chips.com>
Date: Fri, 18 Nov 2016 14:20:59 +0800
Subject: [PATCH] ARM: rockchip: clean mach-rockchip folder

 We don't need those files from 3.10, so remove it to make it tidy

Change-Id: Iba08ac60d94e5dd014674a4b2c017020993abe60
Signed-off-by: Jacob Chen <jacob2.chen@rock-chips.com>
---
 arch/arm/mach-rockchip/Kconfig.common         |   60 -
 arch/arm/mach-rockchip/common.c               |  362 --
 arch/arm/mach-rockchip/cpu.c                  |   95 -
 arch/arm/mach-rockchip/cpuidle.c              |   64 -
 arch/arm/mach-rockchip/ddr_freq.c             | 1129 ----
 arch/arm/mach-rockchip/ddr_reg_resume.inc     |  433 --
 arch/arm/mach-rockchip/ddr_rk30.c             | 4032 --------------
 arch/arm/mach-rockchip/ddr_rk3036.c           | 2125 --------
 arch/arm/mach-rockchip/ddr_rk3126.c           | 2710 ----------
 arch/arm/mach-rockchip/ddr_rk3126b.c          | 2312 --------
 arch/arm/mach-rockchip/ddr_rk32.c             | 4674 -----------------
 arch/arm/mach-rockchip/ddr_test.c             |  296 --
 arch/arm/mach-rockchip/dma_memcpy_test.c      |  268 -
 arch/arm/mach-rockchip/dvfs.c                 | 2655 ----------
 arch/arm/mach-rockchip/efuse.c                |  365 --
 arch/arm/mach-rockchip/efuse.h                |   32 -
 arch/arm/mach-rockchip/fpga.c                 |   60 -
 arch/arm/mach-rockchip/hotplug.c              |  111 -
 arch/arm/mach-rockchip/last_log.c             |  143 -
 arch/arm/mach-rockchip/loader.h               |   23 -
 arch/arm/mach-rockchip/pm-pie.c               |  140 -
 arch/arm/mach-rockchip/pm-rk312x.c            | 1074 ----
 arch/arm/mach-rockchip/pm-rk3188.c            |  607 ---
 arch/arm/mach-rockchip/pm-rk3288.c            | 2524 ---------
 arch/arm/mach-rockchip/psci.c                 |  231 -
 arch/arm/mach-rockchip/pvtm.c                 |  334 --
 arch/arm/mach-rockchip/rk3036.c               |  703 ---
 arch/arm/mach-rockchip/rk30_camera.h          |   54 -
 arch/arm/mach-rockchip/rk3126b.c              |   82 -
 arch/arm/mach-rockchip/rk3126b.h              |    6 -
 arch/arm/mach-rockchip/rk312x.c               |  498 --
 arch/arm/mach-rockchip/rk312x_sleep.S         |  163 -
 arch/arm/mach-rockchip/rk3188.c               |  391 --
 arch/arm/mach-rockchip/rk3228.c               |  134 -
 arch/arm/mach-rockchip/rk3288.c               |  697 ---
 arch/arm/mach-rockchip/rk_camera.c            | 1280 -----
 arch/arm/mach-rockchip/rk_camera.h            |  269 -
 .../arm/mach-rockchip/rk_camera_sensor_info.h |  370 --
 arch/arm/mach-rockchip/rk_system_status.c     |   90 -
 arch/arm/mach-rockchip/rknandbase.c           |  376 --
 arch/arm/mach-rockchip/rockchip_pm.c          |  671 ---
 arch/arm/mach-rockchip/sram.h                 |   56 -
 42 files changed, 32699 deletions(-)
 delete mode 100644 arch/arm/mach-rockchip/Kconfig.common
 delete mode 100755 arch/arm/mach-rockchip/common.c
 delete mode 100644 arch/arm/mach-rockchip/cpu.c
 delete mode 100644 arch/arm/mach-rockchip/cpuidle.c
 delete mode 100644 arch/arm/mach-rockchip/ddr_freq.c
 delete mode 100755 arch/arm/mach-rockchip/ddr_reg_resume.inc
 delete mode 100755 arch/arm/mach-rockchip/ddr_rk30.c
 delete mode 100755 arch/arm/mach-rockchip/ddr_rk3036.c
 delete mode 100644 arch/arm/mach-rockchip/ddr_rk3126.c
 delete mode 100755 arch/arm/mach-rockchip/ddr_rk3126b.c
 delete mode 100755 arch/arm/mach-rockchip/ddr_rk32.c
 delete mode 100755 arch/arm/mach-rockchip/ddr_test.c
 delete mode 100644 arch/arm/mach-rockchip/dma_memcpy_test.c
 delete mode 100644 arch/arm/mach-rockchip/dvfs.c
 delete mode 100644 arch/arm/mach-rockchip/efuse.c
 delete mode 100644 arch/arm/mach-rockchip/efuse.h
 delete mode 100644 arch/arm/mach-rockchip/fpga.c
 delete mode 100644 arch/arm/mach-rockchip/hotplug.c
 delete mode 100644 arch/arm/mach-rockchip/last_log.c
 delete mode 100644 arch/arm/mach-rockchip/loader.h
 delete mode 100755 arch/arm/mach-rockchip/pm-pie.c
 delete mode 100644 arch/arm/mach-rockchip/pm-rk312x.c
 delete mode 100755 arch/arm/mach-rockchip/pm-rk3188.c
 delete mode 100755 arch/arm/mach-rockchip/pm-rk3288.c
 delete mode 100644 arch/arm/mach-rockchip/psci.c
 delete mode 100644 arch/arm/mach-rockchip/pvtm.c
 delete mode 100755 arch/arm/mach-rockchip/rk3036.c
 delete mode 100644 arch/arm/mach-rockchip/rk30_camera.h
 delete mode 100755 arch/arm/mach-rockchip/rk3126b.c
 delete mode 100644 arch/arm/mach-rockchip/rk3126b.h
 delete mode 100755 arch/arm/mach-rockchip/rk312x.c
 delete mode 100755 arch/arm/mach-rockchip/rk312x_sleep.S
 delete mode 100755 arch/arm/mach-rockchip/rk3188.c
 delete mode 100644 arch/arm/mach-rockchip/rk3228.c
 delete mode 100755 arch/arm/mach-rockchip/rk3288.c
 delete mode 100755 arch/arm/mach-rockchip/rk_camera.c
 delete mode 100644 arch/arm/mach-rockchip/rk_camera.h
 delete mode 100644 arch/arm/mach-rockchip/rk_camera_sensor_info.h
 delete mode 100644 arch/arm/mach-rockchip/rk_system_status.c
 delete mode 100755 arch/arm/mach-rockchip/rknandbase.c
 delete mode 100755 arch/arm/mach-rockchip/rockchip_pm.c
 delete mode 100644 arch/arm/mach-rockchip/sram.h

diff --git a/arch/arm/mach-rockchip/Kconfig.common b/arch/arm/mach-rockchip/Kconfig.common
deleted file mode 100644
index b5fc1e274364..000000000000
--- a/arch/arm/mach-rockchip/Kconfig.common
+++ /dev/null
@@ -1,60 +0,0 @@
-if ARCH_ROCKCHIP
-
-config RK_LAST_LOG
-	bool "Save the last kernel log on /proc/last_log"
-	depends on DEBUG_KERNEL && PRINTK
-	default y
-	help
-	  It is only intended for debugging.
-
-config RK_DEBUG_UART
-	int "Debug UART"
-	default 2
-	help
-	  Select a UART for debugging. -1 disable.
-
-config RK_USB_UART
-        bool "Support USB UART Bypass Function"
-        depends on (RK_DEBUG_UART = 2) 
-
-config RK_CONSOLE_THREAD
-	bool "Console write by thread"
-	default y
-	help
-	  Normal kernel printk will write out to UART by "kconsole" kthread
-
-config BLOCK_RKNAND
-	tristate "RK NAND Device Support"
-	default n
-	help
-	  RK NAND Device Support.
-
-config RK_FPGA
-	bool "FPGA Board"
-
-config DVFS
-        bool "Enable dvfs"
-	default y
-	select PM_OPP
-	select CPU_FREQ
-
-config RK_PM_TESTS
-	bool "/sys/pm_tests/ support"
-	default n
-	select DVFS
-	select WATCHDOG
-
-config DDR_TEST
-	bool "DDR Test"
-	select CRC32
-	default n
-
-config RK_VCODEC
-	tristate "VCODEC (VPU HEVC) service driver in kernel"
-	depends on ARCH_ROCKCHIP
-	default y
-
-config RK_PL330_DMA_TEST
-	bool "pl330 DMA memcpy test"
-
-endif
diff --git a/arch/arm/mach-rockchip/common.c b/arch/arm/mach-rockchip/common.c
deleted file mode 100755
index 510e4da5bc74..000000000000
--- a/arch/arm/mach-rockchip/common.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * Copyright (C) 2013-2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/genalloc.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/of_fdt.h>
-#include <asm/cputype.h>
-#ifdef CONFIG_CACHE_L2X0
-#include <asm/hardware/cache-l2x0.h>
-#endif
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/pmu.h>
-#include <linux/memblock.h>
-#include "loader.h"
-#include "sram.h"
-
-static int __init rockchip_cpu_axi_init(void)
-{
-	struct device_node *np, *gp, *cp;
-	void __iomem *base;
-
-	np = of_find_compatible_node(NULL, NULL, "rockchip,cpu_axi_bus");
-	if (!np)
-		return -ENODEV;
-
-#define MAP(base) if (!base) base = of_iomap(cp, 0); if (!base) continue;
-
-	gp = of_get_child_by_name(np, "qos");
-	if (gp) {
-		for_each_child_of_node(gp, cp) {
-			u32 priority[2], mode, bandwidth, saturation, extcontrol;
-			base = NULL;
-#ifdef DEBUG
-			{
-				struct resource r;
-				of_address_to_resource(cp, 0, &r);
-				pr_debug("qos: %s [%x ~ %x]\n", cp->name, r.start, r.end);
-			}
-#endif
-			if (!of_property_read_u32_array(cp, "rockchip,priority", priority, ARRAY_SIZE(priority))) {
-				MAP(base);
-				CPU_AXI_SET_QOS_PRIORITY(priority[0], priority[1], base);
-				pr_debug("qos: %s priority %x %x\n", cp->name, priority[0], priority[1]);
-			}
-			if (!of_property_read_u32(cp, "rockchip,mode", &mode)) {
-				MAP(base);
-				CPU_AXI_SET_QOS_MODE(mode, base);
-				pr_debug("qos: %s mode %x\n", cp->name, mode);
-			}
-			if (!of_property_read_u32(cp, "rockchip,bandwidth", &bandwidth)) {
-				MAP(base);
-				CPU_AXI_SET_QOS_BANDWIDTH(bandwidth, base);
-				pr_debug("qos: %s bandwidth %x\n", cp->name, bandwidth);
-			}
-			if (!of_property_read_u32(cp, "rockchip,saturation", &saturation)) {
-				MAP(base);
-				CPU_AXI_SET_QOS_SATURATION(saturation, base);
-				pr_debug("qos: %s saturation %x\n", cp->name, saturation);
-			}
-			if (!of_property_read_u32(cp, "rockchip,extcontrol", &extcontrol)) {
-				MAP(base);
-				CPU_AXI_SET_QOS_EXTCONTROL(extcontrol, base);
-				pr_debug("qos: %s extcontrol %x\n", cp->name, extcontrol);
-			}
-			if (base)
-				iounmap(base);
-		}
-	};
-
-	gp = of_get_child_by_name(np, "msch");
-	if (gp) {
-		for_each_child_of_node(gp, cp) {
-			u32 val;
-			base = NULL;
-#ifdef DEBUG
-			{
-				struct resource r;
-				of_address_to_resource(cp, 0, &r);
-				pr_debug("msch: %s [%x ~ %x]\n", cp->name, r.start, r.end);
-			}
-#endif
-			if (!of_property_read_u32(cp, "rockchip,read-latency", &val)) {
-				MAP(base);
-				writel_relaxed(val, base + 0x0014);	// memory scheduler read latency
-				pr_debug("msch: %s read latency %x\n", cp->name, val);
-			}
-			if (base)
-				iounmap(base);
-		}
-	}
-	dsb(sy);
-
-#undef MAP
-
-	return 0;
-}
-early_initcall(rockchip_cpu_axi_init);
-
-#ifdef CONFIG_CACHE_L2X0
-static int __init rockchip_pl330_l2_cache_init(void)
-{
-	struct device_node *np;
-	void __iomem *base;
-	u32 aux[2] = { 0, ~0 }, prefetch, power;
-
-	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9)
-		return -ENODEV;
-
-	np = of_find_compatible_node(NULL, NULL, "rockchip,pl310-cache");
-	if (!np)
-		return -ENODEV;
-
-	base = of_iomap(np, 0);
-	if (!base)
-		return -EINVAL;
-
-	if (!of_property_read_u32(np, "rockchip,prefetch-ctrl", &prefetch)) {
-		/* L2X0 Prefetch Control */
-		writel_relaxed(prefetch, base + L2X0_PREFETCH_CTRL);
-		pr_debug("l2c: prefetch %x\n", prefetch);
-	}
-
-	if (!of_property_read_u32(np, "rockchip,power-ctrl", &power)) {
-		/* L2X0 Power Control */
-		writel_relaxed(power, base + L2X0_POWER_CTRL);
-		pr_debug("l2c: power %x\n", power);
-	}
-
-	iounmap(base);
-
-	of_property_read_u32_array(np, "rockchip,aux-ctrl", aux, ARRAY_SIZE(aux));
-	pr_debug("l2c: aux %08x mask %08x\n", aux[0], aux[1]);
-
-	l2x0_of_init(aux[0], aux[1]);
-
-	return 0;
-}
-early_initcall(rockchip_pl330_l2_cache_init);
-#endif
-
-struct gen_pool *rockchip_sram_pool = NULL;
-struct pie_chunk *rockchip_pie_chunk = NULL;
-void *rockchip_sram_virt = NULL;
-size_t rockchip_sram_size = 0;
-char *rockchip_sram_stack = NULL;
-
-#ifdef CONFIG_PIE
-int __init rockchip_pie_init(void)
-{
-	struct device_node *np;
-
-	np = of_find_node_by_path("/");
-	if (!np)
-		return -ENODEV;
-
-	rockchip_sram_pool = of_get_named_gen_pool(np, "rockchip,sram", 0);
-	if (!rockchip_sram_pool) {
-		pr_err("%s: failed to get sram pool\n", __func__);
-		return -ENODEV;
-	}
-	rockchip_sram_size = gen_pool_size(rockchip_sram_pool);
-
-	return 0;
-}
-#endif
-
-static bool is_panic = false;
-extern void console_disable_suspend(void);
-
-static int panic_event(struct notifier_block *this, unsigned long event, void *ptr)
-{
-#if CONFIG_RK_DEBUG_UART >= 0
-	console_disable_suspend();
-#endif
-	is_panic = true;
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block panic_block = {
-	.notifier_call	= panic_event,
-};
-
-static int boot_mode;
-
-int rockchip_boot_mode(void)
-{
-	return boot_mode;
-}
-EXPORT_SYMBOL(rockchip_boot_mode);
-
-static inline const char *boot_flag_name(u32 flag)
-{
-	flag -= SYS_KERNRL_REBOOT_FLAG;
-	switch (flag) {
-	case BOOT_NORMAL: return "NORMAL";
-	case BOOT_LOADER: return "LOADER";
-	case BOOT_MASKROM: return "MASKROM";
-	case BOOT_RECOVER: return "RECOVER";
-	case BOOT_NORECOVER: return "NORECOVER";
-	case BOOT_SECONDOS: return "SECONDOS";
-	case BOOT_WIPEDATA: return "WIPEDATA";
-	case BOOT_WIPEALL: return "WIPEALL";
-	case BOOT_CHECKIMG: return "CHECKIMG";
-	case BOOT_FASTBOOT: return "FASTBOOT";
-	case BOOT_CHARGING: return "CHARGING";
-	default: return "";
-	}
-}
-
-static inline const char *boot_mode_name(u32 mode)
-{
-	switch (mode) {
-	case BOOT_MODE_NORMAL: return "NORMAL";
-	case BOOT_MODE_FACTORY2: return "FACTORY2";
-	case BOOT_MODE_RECOVERY: return "RECOVERY";
-	case BOOT_MODE_CHARGE: return "CHARGE";
-	case BOOT_MODE_POWER_TEST: return "POWER_TEST";
-	case BOOT_MODE_OFFMODE_CHARGING: return "OFFMODE_CHARGING";
-	case BOOT_MODE_REBOOT: return "REBOOT";
-	case BOOT_MODE_PANIC: return "PANIC";
-	case BOOT_MODE_WATCHDOG: return "WATCHDOG";
-	case BOOT_MODE_TSADC: return "TSADC";
-	default: return "";
-	}
-}
-
-void __init rockchip_boot_mode_init(u32 flag, u32 mode)
-{
-	boot_mode = mode;
-	if (mode || ((flag & 0xff) && ((flag & 0xffffff00) == SYS_KERNRL_REBOOT_FLAG)))
-		printk("Boot mode: %s (%d) flag: %s (0x%08x)\n", boot_mode_name(mode), mode, boot_flag_name(flag), flag);
-	atomic_notifier_chain_register(&panic_notifier_list, &panic_block);
-}
-
-void rockchip_restart_get_boot_mode(const char *cmd, u32 *flag, u32 *mode)
-{
-	*flag = SYS_LOADER_REBOOT_FLAG + BOOT_NORMAL;
-	*mode = BOOT_MODE_REBOOT;
-
-	if (cmd) {
-		if (!strcmp(cmd, "loader") || !strcmp(cmd, "bootloader"))
-			*flag = SYS_LOADER_REBOOT_FLAG + BOOT_LOADER;
-		else if(!strcmp(cmd, "recovery"))
-			*flag = SYS_LOADER_REBOOT_FLAG + BOOT_RECOVER;
-		else if (!strcmp(cmd, "fastboot"))
-			*flag = SYS_LOADER_REBOOT_FLAG + BOOT_FASTBOOT;
-		else if (!strcmp(cmd, "charge")) {
-			*flag = SYS_LOADER_REBOOT_FLAG + BOOT_CHARGING;
-			*mode = BOOT_MODE_CHARGE;
-		}
-	} else {
-		if (is_panic)
-			*mode = BOOT_MODE_PANIC;
-	}
-}
-
-struct rockchip_pmu_operations rockchip_pmu_ops;
-void (*ddr_bandwidth_get)(struct ddr_bw_info *ddr_bw_ch0,
-			  struct ddr_bw_info *ddr_bw_ch1);
-int (*ddr_change_freq)(uint32_t nMHz) = NULL;
-long (*ddr_round_rate)(uint32_t nMHz) = NULL;
-void (*ddr_set_auto_self_refresh)(bool en) = NULL;
-int (*ddr_recalc_rate)(void) = NULL;
-
-extern struct ion_platform_data ion_pdata;
-extern void __init ion_reserve(struct ion_platform_data *data);
-extern int __init rockchip_ion_find_heap(unsigned long node,
-				const char *uname, int depth, void *data);
-void __init rockchip_ion_reserve(void)
-{
-#ifdef CONFIG_ION_ROCKCHIP
-	printk("%s\n", __func__);
-	of_scan_flat_dt(rockchip_ion_find_heap, (void*)&ion_pdata);
-	ion_reserve(&ion_pdata);
-#endif
-}
-
-bool rockchip_jtag_enabled = false;
-static int __init rockchip_jtag_enable(char *__unused)
-{
-	rockchip_jtag_enabled = true;
-	printk("rockchip jtag enabled\n");
-	return 1;
-}
-__setup("rockchip_jtag", rockchip_jtag_enable);
-
-phys_addr_t uboot_logo_base=0;
-phys_addr_t uboot_logo_size=0;
-phys_addr_t uboot_logo_offset=0;
-
-void __init rockchip_uboot_mem_reserve(void)
-{
-	if (uboot_logo_size==0)
-		return;
-
-	if (!memblock_is_region_reserved(uboot_logo_base, uboot_logo_size)
-	    && !memblock_reserve(uboot_logo_base, uboot_logo_size)){
-		pr_info("%s: reserve %pa@%pa for uboot logo\n", __func__,
-			&uboot_logo_size, &uboot_logo_base);
-	} else {
-		pr_err("%s: reserve of %pa@%pa failed\n", __func__,
-		       &uboot_logo_size, &uboot_logo_base);
-	}
-}
-
-static int __init rockchip_uboot_logo_setup(char *p)
-{
-	char *endp;
-
-	uboot_logo_size = memparse(p, &endp);
-	if (*endp == '@') {
-		uboot_logo_base = memparse(endp + 1, &endp);
-		if (*endp == ':') {
-			uboot_logo_offset = memparse(endp + 1, NULL);
-		}
-	}
-
-	pr_info("%s: mem: %pa@%pa, offset:%pa\n", __func__,
-		&uboot_logo_size, &uboot_logo_base, &uboot_logo_offset);
-
-	return 0;
-}
-early_param("uboot_logo", rockchip_uboot_logo_setup);
-
-static int __init rockchip_uboot_mem_late_init(void)
-{
-	phys_addr_t addr = 0;
-	phys_addr_t end = 0;
-
-	if (uboot_logo_size) {
-		addr = PAGE_ALIGN(uboot_logo_base);
-		end = (uboot_logo_base+uboot_logo_size)&PAGE_MASK;
-
-		pr_info("%s: Freeing uboot logo memory: %pa@%pa\n", __func__,
-			&uboot_logo_size, &uboot_logo_base);
-
-		memblock_free(uboot_logo_base, uboot_logo_size);
-
-		for (; addr < end; addr += PAGE_SIZE)
-			free_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));
-	}
-
-	return 0;
-}
-late_initcall(rockchip_uboot_mem_late_init);
diff --git a/arch/arm/mach-rockchip/cpu.c b/arch/arm/mach-rockchip/cpu.c
deleted file mode 100644
index 69bed0f0c6f0..000000000000
--- a/arch/arm/mach-rockchip/cpu.c
+++ /dev/null
@@ -1,95 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/cpu.h>
-#include <linux/rockchip/cpu.h>
-
-unsigned long rockchip_soc_id;
-EXPORT_SYMBOL(rockchip_soc_id);
-
-static ssize_t type_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	const char *type;
-
-	if (cpu_is_rk3288())
-		type = "rk3288";
-	else if (cpu_is_rk319x())
-		type = "rk319x";
-	else if (cpu_is_rk3188())
-		type = "rk3188";
-	else if (cpu_is_rk3066b())
-		type = "rk3066b";
-	else if (cpu_is_rk3026())
-		type = "rk3026";
-	else if (cpu_is_rk30xx())
-		type = "rk30xx";
-	else if (cpu_is_rk2928())
-		type = "rk2928";
-	else if (cpu_is_rk312x())
-		type = "rk312x";
-	else
-		type = "";
-
-	if (rockchip_get_cpu_version())
-		return sprintf(buf, "%sv%lu\n", type,
-			       rockchip_get_cpu_version());
-
-	return sprintf(buf, "%s\n", type);
-}
-
-static struct device_attribute type_attr = __ATTR_RO(type);
-
-static ssize_t soc_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	const char *soc;
-
-	if (soc_is_rk3288())
-		soc = "rk3288";
-	else if (soc_is_rk3190())
-		soc = "rk3190";
-	else if (soc_is_rk3188plus())
-		soc = "rk3188+";
-	else if (soc_is_rk3188())
-		soc = "rk3188";
-	else if (soc_is_rk3168())
-		soc = "rk3168";
-	else if (soc_is_rk3028())
-		soc = "rk3028";
-	else if (soc_is_rk3066b())
-		soc = "rk3066b";
-	else if (soc_is_rk3028a())
-		soc = "rk3028a";
-	else if (soc_is_rk3026())
-		soc = "rk3026";
-	else if (soc_is_rk2928g())
-		soc = "rk2928g";
-	else if (soc_is_rk2928l())
-		soc = "rk2928l";
-	else if (soc_is_rk2926())
-		soc = "rk2926";
-	else if (soc_is_rk3066())
-		soc = "rk3066";
-	else if (soc_is_rk3068())
-		soc = "rk3068";
-	else if (soc_is_rk3000())
-		soc = "rk3000";
-	else if (soc_is_rk3126() || soc_is_rk3126b())
-		soc = "rk3126";
-	else if (soc_is_rk3128())
-		soc = "rk3128";
-	else
-		soc = "";
-
-	return sprintf(buf, "%s\n", soc);
-}
-
-static struct device_attribute soc_attr = __ATTR_RO(soc);
-
-static int __init rockchip_cpu_lateinit(void)
-{
-	int err;
-
-	err = device_create_file(cpu_subsys.dev_root, &type_attr);
-	err = device_create_file(cpu_subsys.dev_root, &soc_attr);
-
-	return err;
-}
-late_initcall(rockchip_cpu_lateinit);
diff --git a/arch/arm/mach-rockchip/cpuidle.c b/arch/arm/mach-rockchip/cpuidle.c
deleted file mode 100644
index 14317d7d1bed..000000000000
--- a/arch/arm/mach-rockchip/cpuidle.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2012-2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/cpuidle.h>
-#include <linux/export.h>
-#include <linux/suspend.h>
-#include <linux/err.h>
-#include <linux/irqchip/arm-gic.h>
-#include <asm/cpuidle.h>
-#include <asm/cputype.h>
-#include <asm/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/rockchip/cpu.h>
-
-static void __iomem *gic_cpu_base;
-
-static int rockchip_ca9_cpuidle_enter(struct cpuidle_device *dev,
-		struct cpuidle_driver *drv, int index)
-{
-	do {
-		cpu_do_idle();
-	} while (readl_relaxed(gic_cpu_base + GIC_CPU_HIGHPRI) == 0x3FF);
-	return 0;
-}
-
-static struct cpuidle_driver rockchip_ca9_cpuidle_driver = {
-	.name = "rockchip_ca9_cpuidle",
-	.owner = THIS_MODULE,
-	.states[0] = ARM_CPUIDLE_WFI_STATE,
-	.state_count = 1,
-};
-
-static int __init rockchip_ca9_cpuidle_init(void)
-{
-	struct device_node *np;
-	int ret;
-
-	if (!cpu_is_rockchip())
-		return -ENODEV;
-	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9)
-		return -ENODEV;
-	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-gic");
-	if (!np)
-		return -ENODEV;
-	gic_cpu_base = of_iomap(np, 1);
-	if (!gic_cpu_base) {
-		pr_err("%s: failed to map gic cpu registers\n", __func__);
-		return -EINVAL;
-	}
-	rockchip_ca9_cpuidle_driver.states[0].enter = rockchip_ca9_cpuidle_enter;
-	ret = cpuidle_register(&rockchip_ca9_cpuidle_driver, NULL);
-	if (ret)
-		pr_err("%s: failed to register cpuidle driver: %d\n", __func__, ret);
-
-	return ret;
-}
-
-device_initcall(rockchip_ca9_cpuidle_init);
diff --git a/arch/arm/mach-rockchip/ddr_freq.c b/arch/arm/mach-rockchip/ddr_freq.c
deleted file mode 100644
index ea229d7aeafd..000000000000
--- a/arch/arm/mach-rockchip/ddr_freq.c
+++ /dev/null
@@ -1,1129 +0,0 @@
-#define pr_fmt(fmt) "ddrfreq: " fmt
-#define DEBUG
-#include <linux/clk.h>
-#include <linux/fb.h>
-#include <linux/cpu.h>
-#include <linux/cpufreq.h>
-#include <linux/delay.h>
-#include <linux/freezer.h>
-#include <linux/fs.h>
-#include <linux/kthread.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/reboot.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-#include <linux/sched/rt.h>
-#include <linux/of.h>
-#include <linux/fb.h>
-#include <linux/input.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/vmalloc.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/dvfs.h>
-#include <dt-bindings/clock/ddr.h>
-#include <dt-bindings/clock/rk_system_status.h>
-#include <asm/io.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/clk-private.h>
-#include <linux/rockchip/cpu.h>
-#include "../../../drivers/clk/rockchip/clk-pd.h"
-
-static DECLARE_COMPLETION(ddrfreq_completion);
-static DEFINE_MUTEX(ddrfreq_mutex);
-
-#define VOP_REQ_BLOCK
-#ifdef VOP_REQ_BLOCK
-static DECLARE_COMPLETION(vop_req_completion);
-#endif
-
-static struct dvfs_node *clk_cpu_dvfs_node = NULL;
-static int ddr_boost = 0;
-static int print=0;
-static int watch=0;
-static int high_load = 70;
-static int low_load = 60;
-static int auto_freq_interval_ms = 20;
-static int down_rate_delay_ms = 500;
-static unsigned long *auto_freq_table = NULL;
-static int cur_freq_index;
-static int auto_freq_table_size;
-static unsigned long vop_bandwidth_update_jiffies = 0, vop_bandwidth = 0;
-static int vop_bandwidth_update_flag = 0;
-static struct ddr_bw_info ddr_bw_ch0 = {0}, ddr_bw_ch1 = {0};
-static struct cpufreq_frequency_table *bd_freq_table;
-
-enum {
-	DEBUG_DDR = 1U << 0,
-	DEBUG_VIDEO_STATE = 1U << 1,
-	DEBUG_SUSPEND = 1U << 2,
-	DEBUG_VERBOSE = 1U << 3,
-};
-static int debug_mask;
-
-module_param(debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
-#define dprintk(mask, fmt, ...) do { if (mask & debug_mask) pr_debug(fmt, ##__VA_ARGS__); } while (0)
-
-#define MHZ	(1000*1000)
-#define KHZ	1000
-
-struct video_info {
-	int width;
-	int height;
-	int ishevc;
-	int videoFramerate;
-	int streamBitrate;
-
-	struct list_head node;
-};
-struct vop_info {
-	int state;
-	int zone_num;
-	int reserve;
-	int reserve2;
-};
-
-struct bpvopinfo {
-	struct vop_info vopinfo[4];
-	int bp_size;
-	int bp_vop_size;
-};
-
-struct ddr {
-	struct dvfs_node *clk_dvfs_node;
-	struct list_head video_info_list;
-	unsigned long normal_rate;
-	unsigned long video_1080p_rate;
-	unsigned long video_4k_rate;
-	unsigned long performance_rate;
-	unsigned long dualview_rate;
-	unsigned long hdmi_rate;
-	unsigned long idle_rate;
-	unsigned long suspend_rate;
-	unsigned long reboot_rate;
-	unsigned long boost_rate;
-	unsigned long isp_rate;
-	bool auto_freq;
-	bool auto_self_refresh;
-	char *mode;
-	unsigned long sys_status;
-	struct task_struct *task;
-	wait_queue_head_t wait;
-};
-static struct ddr ddr;
-
-module_param_named(sys_status, ddr.sys_status, ulong, S_IRUGO);
-module_param_named(auto_self_refresh, ddr.auto_self_refresh, bool, S_IRUGO);
-module_param_named(mode, ddr.mode, charp, S_IRUGO);
-
-static unsigned long auto_freq_round(unsigned long freq)
-{
-	int i;
-
-	if (!auto_freq_table)
-		return -EINVAL;
-
-	for (i = 0; auto_freq_table[i] != 0; i++) {
-		if (auto_freq_table[i] >= freq) {
-			return auto_freq_table[i];
-		}
-	}
-
-	return auto_freq_table[i-1];
-}
-
-static unsigned long auto_freq_get_index(unsigned long freq)
-{
-	int i;
-
-	if (!auto_freq_table)
-		return 0;
-
-	for (i = 0; auto_freq_table[i] != 0; i++) {
-		if (auto_freq_table[i] >= freq) {
-			return i;
-		}
-	}
-	return i-1;
-}
-
-static unsigned int auto_freq_update_index(unsigned long freq)
-{
-	cur_freq_index = auto_freq_get_index(freq);
-
-	return cur_freq_index;
-}
-
-
-static unsigned long auto_freq_get_next_step(void)
-{
-	if (cur_freq_index < auto_freq_table_size-1) {
-			return auto_freq_table[cur_freq_index+1];
-	}
-
-	return auto_freq_table[cur_freq_index];
-}
-
-static void ddrfreq_mode(bool auto_self_refresh, unsigned long target_rate, char *name)
-{
-	unsigned int min_rate, max_rate;
-	int freq_limit_en;
-
-	ddr.mode = name;
-	if (auto_self_refresh != ddr.auto_self_refresh) {
-		ddr_set_auto_self_refresh(auto_self_refresh);
-		ddr.auto_self_refresh = auto_self_refresh;
-		dprintk(DEBUG_DDR, "change auto self refresh to %d when %s\n", auto_self_refresh, name);
-	}
-
-	if (target_rate != dvfs_clk_get_last_set_rate(ddr.clk_dvfs_node)) {
-		if (clk_cpu_dvfs_node) {
-			freq_limit_en = dvfs_clk_get_limit(clk_cpu_dvfs_node,
-							   &min_rate,
-							   &max_rate);
-
-			dvfs_clk_enable_limit(clk_cpu_dvfs_node, 600000000, -1);
-		}
-		if (dvfs_clk_set_rate(ddr.clk_dvfs_node, target_rate) == 0) {
-			target_rate = dvfs_clk_get_rate(ddr.clk_dvfs_node);
-			auto_freq_update_index(target_rate);
-			dprintk(DEBUG_DDR, "change freq to %lu MHz when %s\n", target_rate / MHZ, name);
-		}
-		if (clk_cpu_dvfs_node) {
-			if (freq_limit_en) {
-				dvfs_clk_enable_limit(clk_cpu_dvfs_node,
-						      min_rate, max_rate);
-			} else {
-				dvfs_clk_disable_limit(clk_cpu_dvfs_node);
-			}
-		}
-	}
-}
-
-unsigned long req_freq_by_vop(unsigned long bandwidth)
-{
-	unsigned int i = 0;
-
-	if (time_after(jiffies, vop_bandwidth_update_jiffies +
-		msecs_to_jiffies(down_rate_delay_ms)))
-		return 0;
-
-	if (bd_freq_table == NULL)
-		return 0;
-	for (i = 0; bd_freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		if (bandwidth >= bd_freq_table[i].index)
-			return bd_freq_table[i].frequency * 1000;
-	}
-
-	return 0;
-}
-
-static void ddr_auto_freq(void)
-{
-	unsigned long freq, new_freq=0, vop_req_freq=0, total_bw_req_freq=0;
-	u32 ddr_percent, target_load;
-	static unsigned long local_jiffies=0, max_ddr_percent=0;
-
-	if (!local_jiffies)
-		local_jiffies = jiffies;
-	freq = dvfs_clk_get_rate(ddr.clk_dvfs_node);
-
-        ddr_bandwidth_get(&ddr_bw_ch0, &ddr_bw_ch1);
-	ddr_percent = ddr_bw_ch0.ddr_percent;
-
-	if ((watch)||(print)) {
-		if((watch == 2)&& (ddr_bw_ch0.ddr_percent < max_ddr_percent)) {
-		    return;
-		} else if(watch == 2) {
-		    max_ddr_percent = ddr_bw_ch0.ddr_percent;
-		}
-		printk("Unit:MB/s total  use%%    rd    wr  cpum   gpu  peri video  vio0  vio1  vio2\n");
-		printk("%3u(ms): %5u %5u %5u %5u %5u %5u %5u %5u %5u %5u %5u\n",
-			ddr_bw_ch0.ddr_time,
-			ddr_bw_ch0.ddr_total,
-			ddr_bw_ch0.ddr_percent,
-			ddr_bw_ch0.ddr_rd,
-			ddr_bw_ch0.ddr_wr,
-			ddr_bw_ch0.cpum,
-			ddr_bw_ch0.gpu,
-			ddr_bw_ch0.peri,
-			ddr_bw_ch0.video,
-			ddr_bw_ch0.vio0,
-			ddr_bw_ch0.vio1,
-			ddr_bw_ch0.vio2);
-
-		if (watch)
-			return;
-	}
-
-	if (ddr_boost) {
-		ddr_boost = 0;
-		new_freq = max(ddr.boost_rate, new_freq);
-	}
-
-	if(ddr_percent > high_load){
-		total_bw_req_freq = auto_freq_get_next_step();
-	} else if (ddr_percent < low_load){
-		target_load = (low_load+high_load)/2;
-		total_bw_req_freq = ddr_percent*(freq/target_load);
-	}
-	new_freq = max(total_bw_req_freq, new_freq);
-
-	vop_req_freq = req_freq_by_vop(vop_bandwidth);
-	new_freq = max(vop_req_freq, new_freq);
-	if (new_freq == 0)
-		return;
-
-	new_freq = auto_freq_round(new_freq);
-
-	if (new_freq < freq) {
-		if (time_after(jiffies, local_jiffies+down_rate_delay_ms/10)) {
-			local_jiffies = jiffies;
-			ddrfreq_mode(false, new_freq, "auto down rate");
-		}
-	} else if(new_freq > freq){
-		local_jiffies = jiffies;
-		ddrfreq_mode(false, new_freq, "auto up rate");
-	}
-}
-
-static noinline long ddrfreq_work(unsigned long sys_status)
-{
-	long timeout = MAX_SCHEDULE_TIMEOUT;
-	unsigned long target_rate = 0;
-	unsigned long s = sys_status;
-	bool auto_self_refresh = false;
-	char *mode = NULL;
-
-	dprintk(DEBUG_VERBOSE, "sys_status %02lx\n", sys_status);
-
-	if (ddr.reboot_rate && (s & SYS_STATUS_REBOOT)) {
-		ddrfreq_mode(false, ddr.reboot_rate, "shutdown/reboot");
-
-		return timeout;
-	}
-
-	if (ddr.suspend_rate && (s & SYS_STATUS_SUSPEND)) {
-		if (ddr.suspend_rate > target_rate) {
-			target_rate = ddr.suspend_rate;
-			auto_self_refresh = true;
-			mode = "suspend";
-		}
-	}
-
-	if (ddr.performance_rate && (s & SYS_STATUS_PERFORMANCE)) {
-		if (ddr.performance_rate > target_rate) {
-			target_rate = ddr.performance_rate;
-			auto_self_refresh = false;
-			mode = "performance";
-		}
-	}
-
-	 if (ddr.dualview_rate &&
-		(s & SYS_STATUS_LCDC0) && (s & SYS_STATUS_LCDC1)) {
-		 if (ddr.dualview_rate > target_rate) {
-			 target_rate = ddr.dualview_rate;
-			 auto_self_refresh = false;
-			 mode = "dual-view";
-		 }
-	 }
-
-	 if (ddr.hdmi_rate &&
-		(s & SYS_STATUS_HDMI)) {
-		 if (ddr.hdmi_rate > target_rate) {
-			 target_rate = ddr.hdmi_rate;
-			 auto_self_refresh = false;
-			 mode = "hdmi";
-		 }
-	 }
-
-	if (ddr.video_4k_rate && (s & SYS_STATUS_VIDEO_4K) && !(s & SYS_STATUS_SUSPEND)) {
-		if (ddr.video_4k_rate > target_rate) {
-			target_rate = ddr.video_4k_rate;
-			auto_self_refresh = false;
-			mode = "video_4k";
-		}
-	}
-
-	if (ddr.video_1080p_rate && (s & SYS_STATUS_VIDEO_1080P)) {
-		if (ddr.video_1080p_rate > target_rate) {
-			target_rate = ddr.video_1080p_rate;
-			auto_self_refresh = false;
-			mode = "video_1080p";
-		}
-	}
-
-	if (ddr.isp_rate && (s & SYS_STATUS_ISP)) {
-		if (ddr.isp_rate > target_rate) {
-			target_rate = ddr.isp_rate;
-			auto_self_refresh = false;
-			mode = "isp";
-		}
-	}
-
-	if (target_rate > 0) {
-		ddrfreq_mode(auto_self_refresh, target_rate, mode);
-	} else {
-		if (ddr.auto_freq) {
-			ddr_auto_freq();
-			timeout = auto_freq_interval_ms/10;
-		}
-		else {
-			ddrfreq_mode(false, ddr.normal_rate, "normal");
-		}
-	}
-
-	return timeout;
-#if 0
-
-	if (ddr.reboot_rate && (s & SYS_STATUS_REBOOT)) {
-		ddrfreq_mode(false, &ddr.reboot_rate, "shutdown/reboot");
-		rockchip_cpufreq_reboot_limit_freq();
-		reboot_config_done = 1;
-	} else if (ddr.suspend_rate && (s & SYS_STATUS_SUSPEND)) {
-		ddrfreq_mode(true, &ddr.suspend_rate, "suspend");
-	} else if (ddr.dualview_rate && 
-		(s & SYS_STATUS_LCDC0) && (s & SYS_STATUS_LCDC1)) {
-		ddrfreq_mode(false, &ddr.dualview_rate, "dual-view");
-	} else if (ddr.video_1080p_rate && (s & SYS_STATUS_VIDEO_1080P)) {
-		ddrfreq_mode(false, &ddr.video_1080p_rate, "video_1080p");
-	} else if (ddr.video_4k_rate && (s & SYS_STATUS_VIDEO_4K)) {
-		ddrfreq_mode(false, &ddr.video_4k_rate, "video_4k");
-	} else if (ddr.performance_rate && (s & SYS_STATUS_PERFORMANCE)) {
-		ddrfreq_mode(false, &ddr.performance_rate, "performance");
-	}  else if (ddr.isp_rate && (s & SYS_STATUS_ISP)) {
-		ddrfreq_mode(false, &ddr.isp_rate, "isp");
-	} else if (ddr.idle_rate
-		&& !(s & SYS_STATUS_GPU)
-		&& !(s & SYS_STATUS_RGA)
-		&& !(s & SYS_STATUS_CIF0)
-		&& !(s & SYS_STATUS_CIF1)
-		&& (clk_get_rate(cpu) < 816 * MHZ)
-		&& (clk_get_rate(gpu) <= 200 * MHZ)
-		) {
-		ddrfreq_mode(false, &ddr.idle_rate, "idle");
-	} else {
-		if (ddr.auto_freq) {
-			ddr_auto_freq();
-			timeout = auto_freq_interval_ms;
-		}
-		else {
-			ddrfreq_mode(false, &ddr.normal_rate, "normal");
-		}
-	}
-
-
-
-	return timeout;
-#endif
-}
-
-static int ddrfreq_task(void *data)
-{
-	long timeout;
-	unsigned long status=ddr.sys_status, old_status=ddr.sys_status;
-
-	set_freezable();
-
-	do {
-		status = ddr.sys_status;
-		timeout = ddrfreq_work(status);
-		if (old_status != status)
-			complete(&ddrfreq_completion);
-		if (vop_bandwidth_update_flag) {
-			vop_bandwidth_update_flag = 0;
-#ifdef VOP_REQ_BLOCK
-			complete(&vop_req_completion);
-#endif
-		}
-		wait_event_freezable_timeout(ddr.wait, vop_bandwidth_update_flag || (status != ddr.sys_status) || kthread_should_stop(), timeout);
-		old_status = status;
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-
-void add_video_info(struct video_info *video_info)
-{
-	if (video_info)
-		list_add(&video_info->node, &ddr.video_info_list);
-}
-
-void del_video_info(struct video_info *video_info)
-{
-	if (video_info) {
-		list_del(&video_info->node);
-		kfree(video_info);
-	}
-}
-
-void clear_video_info(void)
-{
-	struct video_info *video_info, *next;
-
-	list_for_each_entry_safe(video_info, next, &ddr.video_info_list, node) {
-		del_video_info(video_info);
-	}
-}
-
-struct video_info *find_video_info(struct video_info *match_video_info)
-{
-	struct video_info *video_info;
-
-	if (!match_video_info)
-		return NULL;
-
-	list_for_each_entry(video_info, &ddr.video_info_list, node) {
-		if ((video_info->width == match_video_info->width)
-			&& (video_info->height == match_video_info->height)
-			&& (video_info->ishevc== match_video_info->ishevc)
-			&& (video_info->videoFramerate == match_video_info->videoFramerate)
-			&& (video_info->streamBitrate== match_video_info->streamBitrate)) {
-
-			return video_info;
-		}
-
-	}
-
-	return NULL;
-}
-
-void update_video_info(void)
-{
-	struct video_info *video_info, *max_res_video;
-	int max_res=0, res=0;
-
-	if (list_empty(&ddr.video_info_list)) {
-		rockchip_clear_system_status(SYS_STATUS_VIDEO_1080P|SYS_STATUS_VIDEO_4K);
-		return;
-	}
-
-	list_for_each_entry(video_info, &ddr.video_info_list, node) {
-		res = video_info->width * video_info->height;
-		if (res > max_res) {
-			max_res = res;
-			max_res_video = video_info;
-		}
-	}
-
-	if (max_res <= 1920*1080)
-		rockchip_set_system_status(SYS_STATUS_VIDEO_1080P);
-	else
-		rockchip_set_system_status(SYS_STATUS_VIDEO_4K);
-
-	return;
-}
-
-/***format: width=val,height=val,ishevc=val,videoFramerate=val,streamBitrate=val***/
-static long get_video_param(char **str)
-{
-	char *p;
-
-	strsep(str,"=");
-	p=strsep(str,",");
-	if (p)
-		return simple_strtol(p,NULL,10);
-
-	return 0;
-}
-
-static ssize_t video_state_write(struct file *file, const char __user *buffer,
-				 size_t count, loff_t *ppos)
-{
-	struct video_info *video_info = NULL;
-	char state, *cookie_pot, *buf = vzalloc(count);
-	cookie_pot = buf;
-
-	if(!buf)
-		return -ENOMEM;
-
-	if (count < 1){
-		vfree(buf);
-		return -EPERM;
-	}
-
-	if (copy_from_user(cookie_pot, buffer, count)) {
-		vfree(buf);
-		return -EFAULT;
-	}
-
-	dprintk(DEBUG_VIDEO_STATE, "%s: %s,len %zu\n", __func__, cookie_pot,count);
-
-	state=cookie_pot[0];
-	if( (count>=3) && (cookie_pot[2]=='w') )
-	{
-		video_info = kzalloc(sizeof(struct video_info), GFP_KERNEL);
-		if (!video_info){
-			vfree(buf);
-			return -ENOMEM;
-		}
-		INIT_LIST_HEAD(&video_info->node);
-
-		strsep(&cookie_pot,",");
-
-		video_info->width = get_video_param(&cookie_pot);
-		video_info->height = get_video_param(&cookie_pot);
-		video_info->ishevc = get_video_param(&cookie_pot);
-		video_info->videoFramerate = get_video_param(&cookie_pot);
-		video_info->streamBitrate = get_video_param(&cookie_pot);
-
-		dprintk(DEBUG_VIDEO_STATE, "%s: video_state=%c,width=%d,height=%d,ishevc=%d,videoFramerate=%d,streamBitrate=%d\n",
-			__func__, state,video_info->width,video_info->height,
-			video_info->ishevc, video_info->videoFramerate,
-			video_info->streamBitrate);
-
-	}
-	switch (state) {
-	case '0':
-		del_video_info(find_video_info(video_info));
-		kfree(video_info);
-		update_video_info();
-		break;
-	case '1':
-		add_video_info(video_info);
-		update_video_info();
-		break;
-	case 'p'://performance
-		rockchip_set_system_status(SYS_STATUS_PERFORMANCE);
-		break;
-	case 'n'://normal
-		rockchip_clear_system_status(SYS_STATUS_PERFORMANCE);
-		break;
-	default:
-		vfree(buf);
-		return -EINVAL;
-
-	}
-
-	vfree(buf);
-	return count;
-}
-
-static int video_state_release(struct inode *inode, struct file *file)
-{
-	dprintk(DEBUG_VIDEO_STATE, "video_state release\n");
-	clear_video_info();
-	update_video_info();
-	return 0;
-}
-
-
-static const struct file_operations video_state_fops = {
-	.owner	= THIS_MODULE,
-	.release= video_state_release,
-	.write	= video_state_write,
-};
-
-static struct miscdevice video_state_dev = {
-	.fops	= &video_state_fops,
-	.name	= "video_state",
-	.minor	= MISC_DYNAMIC_MINOR,
-};
-
-static long ddr_freq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct bpvopinfo *bpvinfo = (struct bpvopinfo *)arg;
-	unsigned long vop_req_freq;
-	int ret = -1;
-
-	vop_bandwidth = bpvinfo->bp_vop_size;
-	vop_bandwidth_update_jiffies = jiffies;
-	vop_req_freq = req_freq_by_vop(vop_bandwidth);
-	if (dvfs_clk_get_rate(ddr.clk_dvfs_node) >= vop_req_freq)
-		ret = 0;
-
-	vop_bandwidth_update_flag = 1;
-	wake_up(&ddr.wait);
-#ifdef VOP_REQ_BLOCK
-	wait_for_completion(&vop_req_completion);
-	if (dvfs_clk_get_rate(ddr.clk_dvfs_node) >= vop_req_freq)
-		ret = 0;
-#endif
-
-	return ret;
-}
-
-
-static const struct file_operations ddr_freq_fops = {
-	.owner	= THIS_MODULE,
-	.unlocked_ioctl = ddr_freq_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= ddr_freq_ioctl,
-#endif
-};
-
-static struct miscdevice ddr_freq_dev = {
-	.fops	= &ddr_freq_fops,
-	.name	= "ddr_freq",
-	.mode	= S_IRUGO | S_IWUSR | S_IWUGO,
-	.minor	= MISC_DYNAMIC_MINOR,
-};
-
-#ifdef CONFIG_INPUT
-static void ddr_freq_input_event(struct input_handle *handle, unsigned int type,
-		unsigned int code, int value)
-{
-	if (type == EV_ABS)
-		ddr_boost = 1;
-}
-
-static int ddr_freq_input_connect(struct input_handler *handler,
-		struct input_dev *dev, const struct input_device_id *id)
-{
-	struct input_handle *handle;
-	int error;
-
-	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
-	if (!handle)
-		return -ENOMEM;
-
-	handle->dev = dev;
-	handle->handler = handler;
-	handle->name = "ddr_freq";
-
-	error = input_register_handle(handle);
-	if (error)
-		goto err2;
-
-	error = input_open_device(handle);
-	if (error)
-		goto err1;
-
-	return 0;
-err1:
-	input_unregister_handle(handle);
-err2:
-	kfree(handle);
-	return error;
-}
-
-static void ddr_freq_input_disconnect(struct input_handle *handle)
-{
-	input_close_device(handle);
-	input_unregister_handle(handle);
-	kfree(handle);
-}
-
-static const struct input_device_id ddr_freq_ids[] = {
-	{
-		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
-			INPUT_DEVICE_ID_MATCH_ABSBIT,
-		.evbit = { BIT_MASK(EV_ABS) },
-		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
-			BIT_MASK(ABS_MT_POSITION_X) |
-			BIT_MASK(ABS_MT_POSITION_Y) },
-	},
-	{
-		.flags = INPUT_DEVICE_ID_MATCH_KEYBIT |
-			INPUT_DEVICE_ID_MATCH_ABSBIT,
-		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
-		.absbit = { [BIT_WORD(ABS_X)] =
-			BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },
-	},
-	{
-		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
-		.evbit = { BIT_MASK(EV_KEY) },
-	},
-	{ },
-};
-
-static struct input_handler ddr_freq_input_handler = {
-	.event		= ddr_freq_input_event,
-	.connect	= ddr_freq_input_connect,
-	.disconnect	= ddr_freq_input_disconnect,
-	.name		= "ddr_freq",
-	.id_table	= ddr_freq_ids,
-};
-#endif
-#if 0
-static int ddrfreq_clk_event(int status, unsigned long event)
-{
-	switch (event) {
-	case RK_CLK_PD_PREPARE:
-		ddrfreq_set_sys_status(status);
-		break;
-	case RK_CLK_PD_UNPREPARE:
-		ddrfreq_clear_sys_status(status);
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-#define CLK_NOTIFIER(name, status) \
-static int ddrfreq_clk_##name##_event(struct notifier_block *this, unsigned long event, void *ptr) \
-{ \
-	return ddrfreq_clk_event(SYS_STATUS_##status, event); \
-} \
-static struct notifier_block ddrfreq_clk_##name##_notifier = { .notifier_call = ddrfreq_clk_##name##_event };
-
-#define REGISTER_CLK_NOTIFIER(name) \
-do { \
-	struct clk *clk = clk_get(NULL, #name); \
-	rk_clk_pd_notifier_register(clk, &ddrfreq_clk_##name##_notifier); \
-	clk_put(clk); \
-} while (0)
-
-#define UNREGISTER_CLK_NOTIFIER(name) \
-do { \
-	struct clk *clk = clk_get(NULL, #name); \
-	rk_clk_pd_notifier_unregister(clk, &ddrfreq_clk_##name##_notifier); \
-	clk_put(clk); \
-} while (0)
-
-CLK_NOTIFIER(pd_isp, ISP)
-CLK_NOTIFIER(pd_vop0, LCDC0)
-CLK_NOTIFIER(pd_vop1, LCDC1)
-#endif
-
-static int ddr_freq_suspend_notifier_call(struct notifier_block *self,
-				unsigned long action, void *data)
-{
-	struct fb_event *event = data;
-
-	if (action == FB_EARLY_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			rockchip_clear_system_status(SYS_STATUS_SUSPEND);
-			break;
-		default:
-			break;
-		}
-	}
-	else if (action == FB_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_POWERDOWN:
-			rockchip_set_system_status(SYS_STATUS_SUSPEND);
-			break;
-		default:
-			break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block ddr_freq_suspend_notifier = {
-		.notifier_call = ddr_freq_suspend_notifier_call,
-};
-
-static int ddrfreq_system_status_notifier_call(struct notifier_block *nb,
-				unsigned long val, void *data)
-{
-	mutex_lock(&ddrfreq_mutex);
-	ddr.sys_status = val;
-	wake_up(&ddr.wait);
-	wait_for_completion(&ddrfreq_completion);
-	mutex_unlock(&ddrfreq_mutex);
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block ddrfreq_system_status_notifier = {
-		.notifier_call = ddrfreq_system_status_notifier_call,
-};
-
-static struct cpufreq_frequency_table
-	*of_get_bd_freq_table(struct device_node *np, const char *propname)
-{
-	struct cpufreq_frequency_table *freq_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(np, propname, NULL);
-	if (!prop)
-		return NULL;
-	if (!prop->value)
-		return NULL;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return NULL;
-	}
-
-	freq_table = kzalloc(sizeof(*freq_table) * (nr/2 + 1), GFP_KERNEL);
-
-	val = prop->value;
-
-	for (i = 0; i < nr/2; i++) {
-		freq_table[i].index = be32_to_cpup(val++);
-		freq_table[i].frequency = be32_to_cpup(val++);
-	}
-
-	freq_table[i].index = 0;
-	freq_table[i].frequency = CPUFREQ_TABLE_END;
-
-	return freq_table;
-}
-
-int of_init_ddr_freq_table(void)
-{
-	struct device_node *clk_ddr_dev_node;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i=0;
-	
-	clk_ddr_dev_node = of_find_node_by_name(NULL, "clk_ddr");
-	if (IS_ERR_OR_NULL(clk_ddr_dev_node)) {
-		pr_err("%s: get clk ddr dev node err\n", __func__);
-		return PTR_ERR(clk_ddr_dev_node);
-	}
-
-	prop = of_find_property(clk_ddr_dev_node, "auto-freq", NULL);
-	if (prop && prop->value)
-		ddr.auto_freq = be32_to_cpup(prop->value);
-
-	prop = of_find_property(clk_ddr_dev_node, "auto-freq-table", NULL);
-	if (prop && prop->value) {
-		nr = prop->length / sizeof(u32);
-		auto_freq_table = kzalloc((sizeof(u32) *(nr+1)), GFP_KERNEL);
-		val = prop->value;
-		while (nr) {
-			auto_freq_table[i++] =
-				dvfs_clk_round_rate(ddr.clk_dvfs_node, 1000 * be32_to_cpup(val++));
-			nr--;
-		}
-		cur_freq_index = 0;
-		auto_freq_table_size = i;
-	}
-
-	prop = of_find_property(clk_ddr_dev_node, "freq-table", NULL);
-	if (!prop)
-		return -ENODEV;
-	if (!prop->value)
-		return -ENODATA;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return -EINVAL;
-	}
-
-	val = prop->value;
-	while (nr) {
-		unsigned long status = be32_to_cpup(val++);
-		unsigned long rate =
-			dvfs_clk_round_rate(ddr.clk_dvfs_node, be32_to_cpup(val++) * 1000);
-
-		if (status & SYS_STATUS_NORMAL)
-			ddr.normal_rate = rate;
-		if (status & SYS_STATUS_SUSPEND)
-			ddr.suspend_rate = rate;
-		if (status & SYS_STATUS_VIDEO_1080P)
-			ddr.video_1080p_rate = rate;
-		if (status & SYS_STATUS_VIDEO_4K)
-			ddr.video_4k_rate = rate;
-		if (status & SYS_STATUS_PERFORMANCE)
-			ddr.performance_rate= rate;
-		if ((status & SYS_STATUS_LCDC0)&&(status & SYS_STATUS_LCDC1))
-			ddr.dualview_rate = rate;
-		if (status & SYS_STATUS_HDMI)
-			ddr.hdmi_rate = rate;
-		if (status & SYS_STATUS_IDLE)
-			ddr.idle_rate= rate;
-		if (status & SYS_STATUS_REBOOT)
-			ddr.reboot_rate= rate;
-		if (status & SYS_STATUS_BOOST)
-			ddr.boost_rate= rate;
-		if (status & SYS_STATUS_ISP)
-			ddr.isp_rate= rate;
-
-		nr -= 2;
-	}
-
-	bd_freq_table = of_get_bd_freq_table(clk_ddr_dev_node, "bd-freq-table");
-
-	of_property_read_u32_index(clk_ddr_dev_node, "high_load", 0,
-				   &high_load);
-	of_property_read_u32_index(clk_ddr_dev_node, "low_load", 0, &low_load);
-	of_property_read_u32_index(clk_ddr_dev_node, "auto_freq_interval", 0,
-				   &auto_freq_interval_ms);
-	of_property_read_u32_index(clk_ddr_dev_node, "down_rate_delay", 0,
-				   &down_rate_delay_ms);
-
-	return 0;
-}
-
-static int ddrfreq_scale_rate_for_dvfs(struct clk *clk, unsigned long rate)
-{
-	unsigned long real_rate;
-
-	real_rate = ddr_change_freq(rate/MHZ);
-	real_rate *= MHZ;
-	if (!real_rate)
-		return -EAGAIN;
-	if (cpu_is_rk312x()) {
-		clk->parent->rate = 2 * real_rate;
-		clk->rate = real_rate;
-	} else {
-		clk->rate = real_rate;
-		clk->parent->rate = real_rate;
-	}
-
-	return 0;
-}
-
-#if defined(CONFIG_RK_PM_TESTS)
-static void ddrfreq_tst_init(void);
-#endif
-
-static int ddrfreq_init(void)
-{
-	int ret, i;
-	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
-
-#if defined(CONFIG_RK_PM_TESTS)
-        ddrfreq_tst_init();
-#endif
-
-	clk_cpu_dvfs_node = clk_get_dvfs_node("clk_core");
-	memset(&ddr, 0x00, sizeof(ddr));
-	ddr.clk_dvfs_node = clk_get_dvfs_node("clk_ddr");
-	if (!ddr.clk_dvfs_node){
-		return -EINVAL;
-	}
-	clk_enable_dvfs(ddr.clk_dvfs_node);
-
-	dvfs_clk_register_set_rate_callback(ddr.clk_dvfs_node, ddrfreq_scale_rate_for_dvfs);
-	
-	init_waitqueue_head(&ddr.wait);
-	INIT_LIST_HEAD(&ddr.video_info_list);
-	ddr.mode = "normal";
-	ddr.normal_rate = dvfs_clk_get_rate(ddr.clk_dvfs_node);
-	ddr.sys_status = rockchip_get_system_status();
-
-	of_init_ddr_freq_table();
-
-	if (!ddr.reboot_rate)
-		ddr.reboot_rate = ddr.normal_rate;
-
-#ifdef CONFIG_INPUT
-	ret = input_register_handler(&ddr_freq_input_handler);
-	if (ret)
-		ddr.auto_freq = false;
-#endif
-
-	//REGISTER_CLK_NOTIFIER(pd_isp);
-	//REGISTER_CLK_NOTIFIER(pd_vop0);
-	//REGISTER_CLK_NOTIFIER(pd_vop1);
-
-	ret = misc_register(&video_state_dev);
-	ret = misc_register(&ddr_freq_dev);
-	if (unlikely(ret)) {
-		pr_err("failed to register video_state misc device! error %d\n", ret);
-		goto err;
-	}
-
-	ddr.task = kthread_create(ddrfreq_task, NULL, "ddrfreqd");
-	if (IS_ERR(ddr.task)) {
-		ret = PTR_ERR(ddr.task);
-		pr_err("failed to create kthread! error %d\n", ret);
-		goto err1;
-	}
-
-	sched_setscheduler_nocheck(ddr.task, SCHED_FIFO, &param);
-	get_task_struct(ddr.task);
-	kthread_bind(ddr.task, 0);
-	wake_up_process(ddr.task);
-
-	rockchip_register_system_status_notifier(&ddrfreq_system_status_notifier);
-	fb_register_client(&ddr_freq_suspend_notifier);
-
-	pr_info("verion 1.2 20140526\n");
-	pr_info("normal %luMHz video_1080p %luMHz video_4k %luMHz dualview %luMHz idle %luMHz suspend %luMHz reboot %luMHz\n",
-		ddr.normal_rate / MHZ,
-		ddr.video_1080p_rate / MHZ,
-		ddr.video_4k_rate / MHZ,
-		ddr.dualview_rate / MHZ,
-		ddr.idle_rate / MHZ,
-		ddr.suspend_rate / MHZ,
-		ddr.reboot_rate / MHZ);
-
-	pr_info("auto-freq=%d\n", ddr.auto_freq);
-	if (auto_freq_table) {
-		for (i = 0; i < auto_freq_table_size; i++) {
-			pr_info("auto-freq-table[%d] %luMHz\n", i, auto_freq_table[i] / MHZ);
-		}
-	} else {
-		pr_info("auto-freq-table epmty!\n");
-	}
-	return 0;
-
-err1:
-	misc_deregister(&video_state_dev);
-err:
-	return ret;
-}
-late_initcall(ddrfreq_init);
-/****************************ddr bandwith tst************************************/
-#if defined(CONFIG_RK_PM_TESTS)
-static ssize_t ddrbw_dyn_show(struct kobject *kobj, struct kobj_attribute *attr,
-		char *buf)
-{
-	char *str = buf;
-	str += sprintf(str, "print: %d\n", print);
-	str += sprintf(str, "watch: %d\n", watch);
-	str += sprintf(str, "high_load: %d\n", high_load);
-	str += sprintf(str, "low_load: %d\n", low_load);
-	str += sprintf(str, "auto_freq_interval_ms: %d\n", auto_freq_interval_ms);
-	str += sprintf(str, "down_rate_delay_ms: %d\n", down_rate_delay_ms);
-//	str += sprintf(str, "low_load_last_ms: %d\n", low_load_last_ms);
-	if (str != buf)
-		*(str - 1) = '\n';
-	return (str - buf);
-}
-
-static ssize_t ddrbw_dyn_store(struct kobject *kobj, struct kobj_attribute *attr,
-		const char *buf, size_t n)
-{
-	int value;
-	char var_name[64];
-
-	sscanf(buf, "%s %u", var_name, &value);
-
-	if((strncmp(buf, "print", strlen("print")) == 0)) {
-		print = value;
-	} else if((strncmp(buf, "watch", strlen("watch")) == 0)) {
-		watch = value;
-	} else if((strncmp(buf, "high", strlen("high")) == 0)) {
-		high_load = value;
-	} else if((strncmp(buf, "low", strlen("low")) == 0)) {
-		low_load = value;
-	} else if((strncmp(buf, "interval", strlen("interval")) == 0)) {
-		auto_freq_interval_ms = value;
-	} else if((strncmp(buf, "downdelay", strlen("downdelay")) == 0)) {
-		down_rate_delay_ms = value;
-	}
-	return n;
-}
-
-struct ddrfreq_attribute {
-	struct attribute	attr;
-	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
-			char *buf);
-	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
-			const char *buf, size_t n);
-};
-
-static struct ddrfreq_attribute ddrfreq_attrs[] = {
-	/*     node_name	permision		show_func	store_func */    
-	__ATTR(ddrfreq,	S_IRUSR|S_IRGRP|S_IWUSR,	ddrbw_dyn_show,	ddrbw_dyn_store),
-};
-int rk_pm_tests_kobj_atrradd(const struct attribute *attr);
-
-static void ddrfreq_tst_init(void)
-{
-	int ret;
-
-	ret = rk_pm_tests_kobj_atrradd(&ddrfreq_attrs[0].attr);
-
-	if (ret) {
-		printk("%s: create ddrfreq sysfs node error, ret: %d\n", __func__, ret);
-		return;
-	}
-}
-#endif
diff --git a/arch/arm/mach-rockchip/ddr_reg_resume.inc b/arch/arm/mach-rockchip/ddr_reg_resume.inc
deleted file mode 100755
index 530da3481216..000000000000
--- a/arch/arm/mach-rockchip/ddr_reg_resume.inc
+++ /dev/null
@@ -1,433 +0,0 @@
-    0xea0000a2 ,
-    0xe0801300 ,
-    0xe3010fff ,
-    0xe92d4008 ,
-    0xe0811181 ,
-    0xe0800181 ,
-    0xe1a006a0 ,
-    0xe58d0000 ,
-    0xe3500000 ,
-    0x159d0000 ,
-    0x12401001 ,
-    0x158d1000 ,
-    0x1afffffa ,
-    0xe8bd8008 ,
-    0xe92d4010 ,
-    0xe3a03000 ,
-    0xe1530002 ,
-    0x37914103 ,
-    0x37804103 ,
-    0x32833001 ,
-    0x3afffffa ,
-    0xe8bd8010 ,
-    0xe52de004 ,
-    0xe1a02000 ,
-    0xe5900004 ,
-    0xe3800010 ,
-    0xe38002f1 ,
-    0xe5820004 ,
-    0xe3a00001 ,
-    0xebffffe2 ,
-    0xe3a00007 ,
-    0xe592100c ,
-    0xe1d01001 ,
-    0x1afffffc ,
-    0xe49df004 ,
-    0xe52de004 ,
-    0xe1a02000 ,
-    0xe5900004 ,
-    0xe3800207 ,
-    0xe3800041 ,
-    0xe5820004 ,
-    0xe3a00001 ,
-    0xebffffd5 ,
-    0xe3a00009 ,
-    0xe592100c ,
-    0xe1d01001 ,
-    0x1afffffc ,
-    0xe49df004 ,
-    0xe92d4018 ,
-    0xe3a04004 ,
-    0xe3a02001 ,
-    0xe5913008 ,
-    0xe2033007 ,
-    0xe3530001 ,
-    0xe58d3000 ,
-    0xa000012 ,
-    0xe3530000 ,
-    0x13530003 ,
-    0xa000009 ,
-    0xe3530005 ,
-    0x5814004 ,
-    0x1afffff4 ,
-    0xe5913008 ,
-    0xe2033007 ,
-    0xe3530003 ,
-    0x1afffffb ,
-    0xe590300c ,
-    0xe3130002 ,
-    0xafffffc ,
-    0xe5812004 ,
-    0xe5913008 ,
-    0xe2033007 ,
-    0xe3530001 ,
-    0x1afffffb ,
-    0xeaffffe7 ,
-    0xe8bd8018 ,
-    0xe92d4008 ,
-    0xe5912008 ,
-    0xe2022007 ,
-    0xe3520003 ,
-    0xe58d2000 ,
-    0xa00002b ,
-    0xe5912008 ,
-    0xe7e22252 ,
-    0xe3520001 ,
-    0x5912008 ,
-    0x2022007 ,
-    0x3520005 ,
-    0xa000024 ,
-    0xe59d2000 ,
-    0xe3520000 ,
-    0x3a02001 ,
-    0x5812004 ,
-    0xa00000d ,
-    0xe3520001 ,
-    0xa00000f ,
-    0xe3520005 ,
-    0x3a02004 ,
-    0x5812004 ,
-    0x1affffe8 ,
-    0xe5912008 ,
-    0xe2022007 ,
-    0xe3520003 ,
-    0x1afffffb ,
-    0xe590200c ,
-    0xe3120002 ,
-    0xafffffc ,
-    0xeaffffe0 ,
-    0xe5912008 ,
-    0xe2022007 ,
-    0xe3520001 ,
-    0x1afffffb ,
-    0xe3a02002 ,
-    0xe5812004 ,
-    0xe5912008 ,
-    0xe2022007 ,
-    0xe3520003 ,
-    0xaffffd6 ,
-    0xe5912008 ,
-    0xe7e22252 ,
-    0xe3520001 ,
-    0x5912008 ,
-    0x2022007 ,
-    0x3520005 ,
-    0x1afffff4 ,
-    0xeaffffce ,
-    0xe8bd8008 ,
-    0xe52de004 ,
-    0xe1a02000 ,
-    0xe5900014 ,
-    0xe3c00101 ,
-    0xe5820014 ,
-    0xe59201cc ,
-    0xe3c00101 ,
-    0xe58201cc ,
-    0xe592020c ,
-    0xe3c00101 ,
-    0xe582020c ,
-    0xe592024c ,
-    0xe3c00101 ,
-    0xe582024c ,
-    0xe592028c ,
-    0xe3c00101 ,
-    0xe582028c ,
-    0xe3a0000a ,
-    0xebffff6e ,
-    0xe5920014 ,
-    0xe3800101 ,
-    0xe5820014 ,
-    0xe59201cc ,
-    0xe3800101 ,
-    0xe58201cc ,
-    0xe592020c ,
-    0xe3800101 ,
-    0xe582020c ,
-    0xe592024c ,
-    0xe3800101 ,
-    0xe582024c ,
-    0xe592028c ,
-    0xe3800101 ,
-    0xe582028c ,
-    0xe3a0000a ,
-    0xe49de004 ,
-    0xeaffff5c ,
-    0xe92d41f0 ,
-    0xe1a04000 ,
-    0xe5900274 ,
-    0xe3700001 ,
-    0xa000030 ,
-    0xe5900000 ,
-    0xe5941278 ,
-    0xe594227c ,
-    0xe0000001 ,
-    0xe1500002 ,
-    0x1a00002a ,
-    0xe5940280 ,
-    0xe3700001 ,
-    0x15941284 ,
-    0x15801000 ,
-    0xe594028c ,
-    0xe3700001 ,
-    0x15941290 ,
-    0x15801000 ,
-    0xe5941298 ,
-    0xe3710001 ,
-    0x13a00000 ,
-    0xa000005 ,
-    0xe0842100 ,
-    0xe592229c ,
-    0xe7812100 ,
-    0xe2800001 ,
-    0xe3500003 ,
-    0x3afffff9 ,
-    0xe3a00001 ,
-    0xebffff3d ,
-    0xe594028c ,
-    0xe3700001 ,
-    0x15941294 ,
-    0x15801000 ,
-    0xe3a00001 ,
-    0xebffff37 ,
-    0xe59402ac ,
-    0xe3700001 ,
-    0x159412b0 ,
-    0x159422b4 ,
-    0xa000003 ,
-    0xe5903000 ,
-    0xe0033001 ,
-    0xe1530002 ,
-    0x1afffffb ,
-    0xe59402b8 ,
-    0xe3700001 ,
-    0x159412bc ,
-    0x15801000 ,
-    0xe5940280 ,
-    0xe3700001 ,
-    0x15941288 ,
-    0x15801000 ,
-    0xe3a0c000 ,
-    0xe084810c ,
-    0xe5985004 ,
-    0xe3750001 ,
-    0x15986108 ,
-    0x13760001 ,
-    0xa00007b ,
-    0xe5940118 ,
-    0xe5860010 ,
-    0xe084730c ,
-    0xe594011c ,
-    0xe5860014 ,
-    0xe5970170 ,
-    0xe58601cc ,
-    0xe5970180 ,
-    0xe586020c ,
-    0xe5970190 ,
-    0xe586024c ,
-    0xe59701a0 ,
-    0xe586028c ,
-    0xe5940110 ,
-    0xe5860004 ,
-    0xe1a00006 ,
-    0xebffff8c ,
-    0xe3a02022 ,
-    0xe2841020 ,
-    0xe28500c0 ,
-    0xebffff17 ,
-    0xe594000c ,
-    0xe5850000 ,
-    0xe5940010 ,
-    0xe5850050 ,
-    0xe5940014 ,
-    0xe585007c ,
-    0xe5940018 ,
-    0xe5850080 ,
-    0xe59400a8 ,
-    0xe5850240 ,
-    0xe59400ac ,
-    0xe5850244 ,
-    0xe59400b0 ,
-    0xe5850248 ,
-    0xe59400b4 ,
-    0xe585024c ,
-    0xe59400b8 ,
-    0xe5850250 ,
-    0xe59400bc ,
-    0xe5850254 ,
-    0xe59400c0 ,
-    0xe5850260 ,
-    0xe59400c4 ,
-    0xe5850264 ,
-    0xe59400c8 ,
-    0xe5850270 ,
-    0xe59400cc ,
-    0xe5850274 ,
-    0xe59400d0 ,
-    0xe5850278 ,
-    0xe59400d4 ,
-    0xe585027c ,
-    0xe59400d8 ,
-    0xe5850280 ,
-    0xe59400dc ,
-    0xe5850284 ,
-    0xe59400e0 ,
-    0xe5850288 ,
-    0xe59400e4 ,
-    0xe5850290 ,
-    0xe59400e8 ,
-    0xe5850294 ,
-    0xe59400ec ,
-    0xe5850298 ,
-    0xe59400f0 ,
-    0xe58502c4 ,
-    0xe59400f4 ,
-    0xe58502c8 ,
-    0xe59400f8 ,
-    0xe58502d0 ,
-    0xe59400fc ,
-    0xe58502d4 ,
-    0xe5940100 ,
-    0xe58502d8 ,
-    0xe5940104 ,
-    0xe58502f0 ,
-    0xe3a02007 ,
-    0xe2841f4f ,
-    0xe2860034 ,
-    0xebfffedb ,
-    0xe5940114 ,
-    0xe5860008 ,
-    0xe5940120 ,
-    0xe5860018 ,
-    0xe5940124 ,
-    0xe586001c ,
-    0xe5940128 ,
-    0xe5860020 ,
-    0xe594012c ,
-    0xe5860024 ,
-    0xe5940130 ,
-    0xe5860028 ,
-    0xe5940134 ,
-    0xe586002c ,
-    0xe5940138 ,
-    0xe5860030 ,
-    0xe594015c ,
-    0xe5860050 ,
-    0xe5940160 ,
-    0xe5860054 ,
-    0xe597016c ,
-    0xe58601c0 ,
-    0xe597017c ,
-    0xe5860200 ,
-    0xe597018c ,
-    0xe5860240 ,
-    0xe597019c ,
-    0xe5860280 ,
-    0xe59801ec ,
-    0xe3700001 ,
-    0xa00000b ,
-    0xe59711fc ,
-    0xe5801008 ,
-    0xe5971200 ,
-    0xe580100c ,
-    0xe5971204 ,
-    0xe5801010 ,
-    0xe5971208 ,
-    0xe5801014 ,
-    0xe597122c ,
-    0xe5801038 ,
-    0xe5971230 ,
-    0xe580103c ,
-    0xe28cc001 ,
-    0xe35c0002 ,
-    0x23a00000 ,
-    0x3affff79 ,
-    0xe59412d4 ,
-    0xe1500001 ,
-    0x2a000006 ,
-    0xe0842180 ,
-    0xe59212d8 ,
-    0xe3710001 ,
-    0x159222dc ,
-    0x15812000 ,
-    0xe2800001 ,
-    0xeafffff5 ,
-    0xe2840fb6 ,
-    0xe7b02181 ,
-    0xe3720001 ,
-    0x13a01000 ,
-    0x12800004 ,
-    0xa000004 ,
-    0xe1510002 ,
-    0x38900028 ,
-    0x35835000 ,
-    0x32811001 ,
-    0x3afffffa ,
-    0xe3a06000 ,
-    0xe0840106 ,
-    0xe5907004 ,
-    0xe3770001 ,
-    0x15905108 ,
-    0x13750001 ,
-    0xa000023 ,
-    0xe1a00005 ,
-    0xebfffe96 ,
-    0xe3a00001 ,
-    0xe5870044 ,
-    0xe5970048 ,
-    0xe3100001 ,
-    0xafffffc ,
-    0xe5940164 ,
-    0xe5850180 ,
-    0xe5940168 ,
-    0xe5850190 ,
-    0xe1a00005 ,
-    0xebfffe98 ,
-    0xe1a01007 ,
-    0xe1a00005 ,
-    0xebfffea2 ,
-    0xe0840306 ,
-    0xe5901174 ,
-    0xe58511d0 ,
-    0xe5901178 ,
-    0xe58511d4 ,
-    0xe5901184 ,
-    0xe5851210 ,
-    0xe5901188 ,
-    0xe5851214 ,
-    0xe5901194 ,
-    0xe5851250 ,
-    0xe5901198 ,
-    0xe5851254 ,
-    0xe59011a4 ,
-    0xe5851290 ,
-    0xe59001a8 ,
-    0xe5850294 ,
-    0xe1a01007 ,
-    0xe1a00005 ,
-    0xebfffeaa ,
-    0xe2866001 ,
-    0xe3560002 ,
-    0x3affffd2 ,
-    0xe59402c0 ,
-    0xe3700001 ,
-    0xa000003 ,
-    0xe5901000 ,
-    0xe59422c4 ,
-    0xe1811002 ,
-    0xe5801000 ,
-    0xe59402c8 ,
-    0xe3700001 ,
-    0x8bd81f0 ,
-    0xe3a00001 ,
-    0xe8bd41f0 ,
-    0xeafffe4f ,
diff --git a/arch/arm/mach-rockchip/ddr_rk30.c b/arch/arm/mach-rockchip/ddr_rk30.c
deleted file mode 100755
index 000b07ec26e7..000000000000
--- a/arch/arm/mach-rockchip/ddr_rk30.c
+++ /dev/null
@@ -1,4032 +0,0 @@
-/*
- * Function Driver for DDR controller
- *
- * Copyright (C) 2011-2014 Fuzhou Rockchip Electronics Co.,Ltd
- * Author:
- * hcy@rock-chips.com
- * yk@rock-chips.com
- *
- * v1.00
- */
-
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/cpu.h>
-#include <dt-bindings/clock/ddr.h>
-
-#include <linux/rockchip/cru.h>
-
-typedef uint32_t uint32;
-
-/***********************************
- * Global Control Macro
- ***********************************/
-//#define ENABLE_DDR_CLCOK_GPLL_PATH  //for RK3188
-
-#define DDR3_DDR2_ODT_DISABLE_FREQ    (333)
-#define DDR3_DDR2_DLL_DISABLE_FREQ    (333)
-#define SR_IDLE                       (0x1)   //unit:32*DDR clk cycle, and 0 for disable auto self-refresh
-#define PD_IDLE                       (0X40)  //unit:DDR clk cycle, and 0 for disable auto power-down
-
-#if (DDR3_DDR2_ODT_DISABLE_FREQ > DDR3_DDR2_DLL_DISABLE_FREQ)
-#error
-#endif
-
-#define ddr_print(x...) printk( "DDR DEBUG: " x )
-
-/***********************************
- * ARCH Relative Macro and Struction
- ***********************************/
-#define PMU_BASE_ADDR           RK_PMU_VIRT
-#define SDRAMC_BASE_ADDR        RK30_DDR_PCTL_BASE
-#define DDR_PUBL_BASE           RK30_DDR_PUBL_BASE
-#define CRU_BASE_ADDR           RK_CRU_VIRT
-#define REG_FILE_BASE_ADDR      RK_GRF_VIRT
-#define SysSrv_DdrConf          (RK_CPU_AXI_BUS_VIRT+0x08)
-#define SysSrv_DdrTiming        (RK_CPU_AXI_BUS_VIRT+0x0c)
-#define SysSrv_DdrMode          (RK_CPU_AXI_BUS_VIRT+0x10)
-#define SysSrv_ReadLatency      (RK_CPU_AXI_BUS_VIRT+0x14)
-
-#define SRAM_CODE_OFFSET        rockchip_sram_virt
-#define SRAM_SIZE               rockchip_sram_size
-
-/*
- * PMU
- */
-//PMU_MISC_CON1
-#define idle_req_cpu_cfg    (1<<1)
-#define idle_req_peri_cfg   (1<<2)
-#define idle_req_gpu_cfg    (1<<3)
-#define idle_req_video_cfg  (1<<4)
-#define idle_req_vio_cfg    (1<<5)
-#define idle_req_core_cfg   (1<<14)
-#define idle_req_dma_cfg    (1<<16)
-
-//PMU_PWRDN_ST
-#define idle_cpu    (1<<26)
-#define idle_peri   (1<<25)
-#define idle_gpu    (1<<24)
-#define idle_video  (1<<23)
-#define idle_vio    (1<<22)
-#define idle_core    (1<<15)
-#define idle_dma    (1<<14)
-
-#define pd_a9_0_pwr_st    (1<<0)
-#define pd_a9_1_pwr_st    (1<<1)
-#define pd_peri_pwr_st    (1<<6)
-#define pd_vio_pwr_st    (1<<7)
-#define pd_video_pwr_st    (1<<8)
-#define pd_gpu_pwr_st    (1<<9)
-
-struct ddr_freq_t {
-    unsigned long screen_ft_us;
-    unsigned long long t0;
-    unsigned long long t1;
-    unsigned long t2;
-};
-
-//PMU registers
-typedef volatile struct tagPMU_FILE
-{
-    uint32 PMU_WAKEUP_CFG[2];
-    uint32 PMU_PWRDN_CON;
-    uint32 PMU_PWRDN_ST;
-    uint32 PMU_INT_CON;
-    uint32 PMU_INT_ST;
-    uint32 PMU_MISC_CON;
-    uint32 PMU_OSC_CNT;
-    uint32 PMU_PLL_CNT;
-    uint32 PMU_PMU_CNT;
-    uint32 PMU_DDRIO_PWRON_CNT;
-    uint32 PMU_WAKEUP_RST_CLR_CNT;
-    uint32 PMU_SCU_PWRDWN_CNT;
-    uint32 PMU_SCU_PWRUP_CNT;
-    uint32 PMU_MISC_CON1;
-    uint32 PMU_GPIO6_CON;
-    uint32 PMU_PMU_SYS_REG[4];
-} PMU_FILE, *pPMU_FILE;
-
-//PMU_NOC_REQ
-#define idle_req_bp2ap_rk319x      (1<<8)
-#define idle_req_dma_cfg_rk319x    (1<<7)
-#define idle_req_vio_cfg_rk319x    (1<<4)
-#define idle_req_video_cfg_rk319x  (1<<3)
-#define idle_req_gpu_cfg_rk319x    (1<<2)
-#define idle_req_peri_cfg_rk319x   (1<<1)
-
-//PMU_NOC_ST
-#define idle_bp2ap_rk319x  (1<<8)
-#define idle_dma_rk319x    (1<<7)
-#define idle_vio_rk319x    (1<<4)
-#define idle_video_rk319x  (1<<3)
-#define idle_gpu_rk319x    (1<<2)
-#define idle_peri_rk319x   (1<<1)
-
-//PMU_PWRDN_ST
-#define pd_peri_pwr_st_rk319x    (1<<10)
-#define pd_vio_pwr_st_rk319x     (1<<9)
-#define pd_video_pwr_st_rk319x   (1<<8)
-#define pd_gpu_pwr_st_rk319x     (1<<7)
-#define pd_a9_1_pwr_st_rk319x    (1<<1)
-#define pd_a9_0_pwr_st_rk319x    (1<<0)
-
-//PMU registers
-typedef volatile struct tagPMU_FILE_RK319X
-{
-    uint32 PMU_WAKEUP_CFG[3];
-    uint32 PMU_PWRDN_CON;
-    uint32 PMU_PWRDN_ST;
-    uint32 PMU_PWRMODE_CON;
-    uint32 PMU_SFT_CON;
-    uint32 PMU_INT_CON;
-    uint32 PMU_INT_ST;
-    uint32 PMU_GPIO_INT_ST;
-    uint32 PMU_GPIO_2EDGE_INT_ST;
-    uint32 PMU_NOC_REQ;
-    uint32 PMU_NOC_ST;
-    uint32 PMU_POWER_ST;
-    uint32 reserved1[3];
-    uint32 PMU_OSC_CNT;
-    uint32 PMU_PLLLOCK_CNT;
-    uint32 PMU_PLLRST_CNT;
-    uint32 PMU_STABLE_CNT;
-    uint32 PMU_DDRIO_PWRON_CNT;
-    uint32 reserved2[2];
-    uint32 PMU_WAKEUP_RST_CLR_CNT;
-    uint32 reserved3;
-    uint32 PMU_DDR_SREF_ST;
-    uint32 reserved4[2];
-    uint32 PMU_PMU_SYS_REG[4];
-} PMU_FILE_RK319X, *pPMU_FILE_RK319X;
-
-/*
- * CRU
- */
-typedef enum PLL_ID_Tag
-{
-    APLL=0,
-    DPLL,
-    CPLL,
-    GPLL,
-    PLL_MAX
-}PLL_ID;
-
-#define PLL_RESET  (((0x1<<5)<<16) | (0x1<<5))
-#define PLL_DE_RESET  (((0x1<<5)<<16) | (0x0<<5))
-#define NR(n)      ((0x3F<<(8+16)) | (((n)-1)<<8))
-#define NO(n)      ((0xF<<16) | ((n)-1))
-#define NF(n)      ((0x1FFF<<16) | ((n)-1))
-#define NB(n)      ((0xFFF<<16) | ((n)-1))
-
-//RK3066B
-#define PLL_RESET_RK3066B  (((0x1<<1)<<16) | (0x1<<1))
-#define PLL_DE_RESET_RK3066B  (((0x1<<1)<<16) | (0x0<<1))
-#define NR_RK3066B(n)      ((0x3F<<(8+16)) | (((n)-1)<<8))
-#define NO_RK3066B(n)      ((0x3F<<16) | ((n)-1))
-#define NF_RK3066B(n)      ((0xFFFF<<16) | ((n)-1))
-
- //CRU Registers
-typedef volatile struct tagCRU_STRUCT
-{
-    uint32 CRU_PLL_CON[4][4];
-    uint32 CRU_MODE_CON;
-    uint32 CRU_CLKSEL_CON[35];
-    uint32 CRU_CLKGATE_CON[10];
-    uint32 reserved1[2];
-    uint32 CRU_GLB_SRST_FST_VALUE;
-    uint32 CRU_GLB_SRST_SND_VALUE;
-    uint32 reserved2[2];
-    uint32 CRU_SOFTRST_CON[9];
-    uint32 CRU_MISC_CON;
-    uint32 reserved3[2];
-    uint32 CRU_GLB_CNT_TH;
-} CRU_REG, *pCRU_REG;
-
-typedef volatile struct tagCRU_STRUCT_RK319X 
-{
-    uint32 CRU_PLL_CON[4][4]; 
-    uint32 CRU_MODE_CON;
-    uint32 CRU_CLKSEL_CON[35];
-    uint32 CRU_CLKGATE_CON[16];
-    uint32 CRU_SOFTRST_CON[12];
-    uint32 CRU_GLB_CNT_TH;
-    uint32 CRU_MISC_CON;
-    uint32 CRU_TSADC_CON;
-    uint32 reserved1[(0x160-0x14c)/4];
-    uint32 CRU_GLB_SRST_FST_VALUE;
-    uint32 CRU_GLB_SRST_SND_VALUE;
-    uint32 CRU_GLB_BB_SRST_FST_VALUE;
-    uint32 CRU_GLB_BB_SRST_SND_VALUE;
-} CRU_REG_RK319X, *pCRU_REG_RK319X;
-
-/*
- * GRF
- */
-typedef struct tagGPIO_LH
-{
-    uint32 GPIOL;
-    uint32 GPIOH;
-}GPIO_LH_T;
-
-typedef struct tagGPIO_IOMUX
-{
-    uint32 GPIOA_IOMUX;
-    uint32 GPIOB_IOMUX;
-    uint32 GPIOC_IOMUX;
-    uint32 GPIOD_IOMUX;
-}GPIO_IOMUX_T;
-
-//REG FILE registers
-typedef volatile struct tagREG_FILE
-{
-    GPIO_LH_T GRF_GPIO_DIR[7];
-    GPIO_LH_T GRF_GPIO_DO[7];
-    GPIO_LH_T GRF_GPIO_EN[7];
-    GPIO_IOMUX_T GRF_GPIO_IOMUX[7];
-    GPIO_LH_T GRF_GPIO_PULL[7];
-    uint32 GRF_SOC_CON[3];
-    uint32 GRF_SOC_STATUS0;
-    uint32 GRF_DMAC1_CON[3];
-    uint32 GRF_DMAC2_CON[4];
-    uint32 GRF_UOC0_CON[3];
-    uint32 GRF_UOC1_CON[4];
-    uint32 GRF_DDRC_CON0;
-    uint32 GRF_DDRC_STAT;
-    uint32 reserved[(0x1c8-0x1a0)/4];
-    uint32 GRF_OS_REG[4];
-} REG_FILE, *pREG_FILE;
-
-//REG FILE registers
-typedef volatile struct tagREG_FILE_RK3066B
-{
-    GPIO_LH_T GRF_GPIO_DIR[4];
-    GPIO_LH_T GRF_GPIO_DO[4];
-    GPIO_LH_T GRF_GPIO_EN[4];
-    GPIO_IOMUX_T GRF_GPIO_IOMUX[4];
-    uint32 GRF_SOC_CON[3];
-    uint32 GRF_SOC_STATUS0;
-    uint32 GRF_DMAC0_CON[3];
-    uint32 GRF_DMAC1_CON[4];
-    uint32 reserved0[(0xec-0xcc)/4];
-    uint32 GRF_DDRC_CON0;
-    uint32 GRF_DDRC_STAT;
-    uint32 GRF_IO_CON[5];
-    uint32 reserved1;
-    uint32 GRF_UOC0_CON[4];
-    uint32 GRF_UOC1_CON[4];
-    uint32 GRF_UOC2_CON[2];
-    uint32 reserved2;
-    uint32 GRF_UOC3_CON[2];
-    uint32 GRF_EHCI_STAT;
-    uint32 GRF_OS_REG[8];
-} REG_FILE_RK3066B, *pREG_FILE_RK3066B;
-
-typedef struct tagGPIO
-{
-    uint32 GPIOA;
-    uint32 GPIOB;
-    uint32 GPIOC;
-    uint32 GPIOD;
-}GPIO_T;
-
-//REG FILE registers
-typedef volatile struct tagREG_FILE_RK319X
-{
-    GPIO_T GRF_GPIO_IOMUX[5]; // 0x0010
-    GPIO_T reserved1;
-    uint32 GRF_SOC_CON[5];          // 0x0060
-    uint32 GRF_SOC_STATUS0;
-    uint32 GRF_SOC_STATUS1;
-    uint32 GRF_SOC_STATUS2;
-    uint32 GRF_DMAC1_CON[3];
-    uint32 GRF_DMAC2_CON[4];
-    uint32 GRF_CPU_CON[6];
-    uint32 GRF_CPU_STATUS[2];
-    uint32 GRF_DDRC_CON0;
-    uint32 GRF_DDRC_STAT;
-    uint32 GRF_UOC0_CON[4];
-    uint32 GRF_U0C1_CON[4];
-    uint32 GRF_UOC2_CON[2];
-    uint32 GRF_UOC3_CON[2];
-    uint32 GRF_PVTM_CON[3];
-    uint32 GRF_PVTM_STATUS[3];
-    uint32 reserved2;
-    uint32 GRF_NIF_FIFO[4];
-    uint32 GRF_OS_REG[4];
-    uint32 GRF_SOC_CON5_8[4];
-    uint32 reserved3;
-    GPIO_T GRF_GPIO_PULL_1_4[4];
-    uint32 reserved4[2];
-    uint32 GRF_IO_VSEL;
-    uint32 reserved5[2];
-    uint32 GRF_GPIO1L_SR;
-    uint32 GRF_GPIO1H_SR;
-    uint32 GRF_GPIO2L_SR;
-    uint32 GRF_GPIO2H_SR;
-    uint32 GRF_GPIO3L_SR;
-    uint32 GRF_GPIO3H_SR;
-    uint32 GRF_GPIO4L_SR;
-    uint32 GRF_GPIO4H_SR;
-    GPIO_T GRF_GPIO_E[5];
-    uint32 reserved6[2];
-    uint32 GRF_FLASH_DATA_PULL;
-    uint32 GRF_FLASH_DATA_E;
-    uint32 GRF_FLASH_DATA_SR;
-    uint32 reserved7;
-    uint32 GRF_USBPHY_CON[12];
-    uint32 GRF_DFI_STAT[4];
-    uint32 reserved8[(0x300-0x260)/4];
-    uint32 GRF_SECURE_BOOT_STATUS;
-} REG_FILE_RK319X, *pREG_FILE_RK319X;
-
-/*
- * PCTL
- */
-//SCTL
-#define INIT_STATE                     (0)
-#define CFG_STATE                      (1)
-#define GO_STATE                       (2)
-#define SLEEP_STATE                    (3)
-#define WAKEUP_STATE                   (4)
-
-//STAT
-#define Init_mem                       (0)
-#define Config                         (1)
-#define Config_req                     (2)
-#define Access                         (3)
-#define Access_req                     (4)
-#define Low_power                      (5)
-#define Low_power_entry_req            (6)
-#define Low_power_exit_req             (7)
-
-//MCFG
-#define mddr_lpddr2_clk_stop_idle(n)   ((n)<<24)
-#define pd_idle(n)                     ((n)<<8)
-#define mddr_en                        (2<<22)
-#define lpddr2_en                      (3<<22)
-#define ddr2_en                        (0<<5)
-#define ddr3_en                        (1<<5)
-#define lpddr2_s2                      (0<<6)
-#define lpddr2_s4                      (1<<6)
-#define mddr_lpddr2_bl_2               (0<<20)
-#define mddr_lpddr2_bl_4               (1<<20)
-#define mddr_lpddr2_bl_8               (2<<20)
-#define mddr_lpddr2_bl_16              (3<<20)
-#define ddr2_ddr3_bl_4                 (0)
-#define ddr2_ddr3_bl_8                 (1)
-#define tfaw_cfg(n)                    (((n)-4)<<18)
-#define pd_exit_slow                   (0<<17)
-#define pd_exit_fast                   (1<<17)
-#define pd_type(n)                     ((n)<<16)
-#define two_t_en(n)                    ((n)<<3)
-#define bl8int_en(n)                   ((n)<<2)
-#define cke_or_en(n)                   ((n)<<1)
-
-//POWCTL
-#define power_up_start                 (1<<0)
-
-//POWSTAT
-#define power_up_done                  (1<<0)
-
-//DFISTSTAT0
-#define dfi_init_complete              (1<<0)
-
-//CMDTSTAT
-#define cmd_tstat                      (1<<0)
-
-//CMDTSTATEN
-#define cmd_tstat_en                   (1<<1)
-
-//MCMD
-#define Deselect_cmd                   (0)
-#define PREA_cmd                       (1)
-#define REF_cmd                        (2)
-#define MRS_cmd                        (3)
-#define ZQCS_cmd                       (4)
-#define ZQCL_cmd                       (5)
-#define RSTL_cmd                       (6)
-#define MRR_cmd                        (8)
-#define DPDE_cmd                       (9)
-
-#define lpddr2_op(n)                   ((n)<<12)
-#define lpddr2_ma(n)                   ((n)<<4)
-
-#define bank_addr(n)                   ((n)<<17)
-#define cmd_addr(n)                    ((n)<<4)
-
-#define start_cmd                      (1u<<31)
-
-typedef union STAT_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned ctl_stat : 3;
-        unsigned reserved3 : 1;
-        unsigned lp_trig : 3;
-        unsigned reserved7_31 : 25;
-    }b;
-}STAT_T;
-
-typedef union SCFG_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned hw_low_power_en : 1;
-        unsigned reserved1_5 : 5;
-        unsigned nfifo_nif1_dis : 1;
-        unsigned reserved7 : 1;
-        unsigned bbflags_timing : 4;
-        unsigned reserved12_31 : 20;
-    } b;
-}SCFG_T;
-
-/* DDR Controller register struct */
-typedef volatile struct DDR_REG_Tag
-{
-    //Operational State, Control, and Status Registers
-    SCFG_T SCFG;                   //State Configuration Register
-    volatile uint32 SCTL;                   //State Control Register
-    STAT_T STAT;                   //State Status Register
-    volatile uint32 INTRSTAT;               //Interrupt Status Register
-    uint32 reserved0[(0x40-0x10)/4];
-    //Initailization Control and Status Registers
-    volatile uint32 MCMD;                   //Memory Command Register
-    volatile uint32 POWCTL;                 //Power Up Control Registers
-    volatile uint32 POWSTAT;                //Power Up Status Register
-    volatile uint32 CMDTSTAT;               //Command Timing Status Register
-    volatile uint32 CMDTSTATEN;             //Command Timing Status Enable Register
-    uint32 reserved1[(0x60-0x54)/4];
-    volatile uint32 MRRCFG0;                //MRR Configuration 0 Register
-    volatile uint32 MRRSTAT0;               //MRR Status 0 Register
-    volatile uint32 MRRSTAT1;               //MRR Status 1 Register
-    uint32 reserved2[(0x7c-0x6c)/4];
-    //Memory Control and Status Registers
-    volatile uint32 MCFG1;                  //Memory Configuration 1 Register
-    volatile uint32 MCFG;                   //Memory Configuration Register
-    volatile uint32 PPCFG;                  //Partially Populated Memories Configuration Register
-    volatile uint32 MSTAT;                  //Memory Status Register
-    volatile uint32 LPDDR2ZQCFG;            //LPDDR2 ZQ Configuration Register
-    uint32 reserved3;
-    //DTU Control and Status Registers
-    volatile uint32 DTUPDES;                //DTU Status Register
-    volatile uint32 DTUNA;                  //DTU Number of Random Addresses Created Register
-    volatile uint32 DTUNE;                  //DTU Number of Errors Register
-    volatile uint32 DTUPRD0;                //DTU Parallel Read 0
-    volatile uint32 DTUPRD1;                //DTU Parallel Read 1
-    volatile uint32 DTUPRD2;                //DTU Parallel Read 2
-    volatile uint32 DTUPRD3;                //DTU Parallel Read 3
-    volatile uint32 DTUAWDT;                //DTU Address Width
-    uint32 reserved4[(0xc0-0xb4)/4];
-    //Memory Timing Registers
-    volatile uint32 TOGCNT1U;               //Toggle Counter 1U Register
-    volatile uint32 TINIT;                  //t_init Timing Register
-    volatile uint32 TRSTH;                  //Reset High Time Register
-    volatile uint32 TOGCNT100N;             //Toggle Counter 100N Register
-    volatile uint32 TREFI;                  //t_refi Timing Register
-    volatile uint32 TMRD;                   //t_mrd Timing Register
-    volatile uint32 TRFC;                   //t_rfc Timing Register
-    volatile uint32 TRP;                    //t_rp Timing Register
-    volatile uint32 TRTW;                   //t_rtw Timing Register
-    volatile uint32 TAL;                    //AL Latency Register
-    volatile uint32 TCL;                    //CL Timing Register
-    volatile uint32 TCWL;                   //CWL Register
-    volatile uint32 TRAS;                   //t_ras Timing Register
-    volatile uint32 TRC;                    //t_rc Timing Register
-    volatile uint32 TRCD;                   //t_rcd Timing Register
-    volatile uint32 TRRD;                   //t_rrd Timing Register
-    volatile uint32 TRTP;                   //t_rtp Timing Register
-    volatile uint32 TWR;                    //t_wr Timing Register
-    volatile uint32 TWTR;                   //t_wtr Timing Register
-    volatile uint32 TEXSR;                  //t_exsr Timing Register
-    volatile uint32 TXP;                    //t_xp Timing Register
-    volatile uint32 TXPDLL;                 //t_xpdll Timing Register
-    volatile uint32 TZQCS;                  //t_zqcs Timing Register
-    volatile uint32 TZQCSI;                 //t_zqcsi Timing Register
-    volatile uint32 TDQS;                   //t_dqs Timing Register
-    volatile uint32 TCKSRE;                 //t_cksre Timing Register
-    volatile uint32 TCKSRX;                 //t_cksrx Timing Register
-    volatile uint32 TCKE;                   //t_cke Timing Register
-    volatile uint32 TMOD;                   //t_mod Timing Register
-    volatile uint32 TRSTL;                  //Reset Low Timing Register
-    volatile uint32 TZQCL;                  //t_zqcl Timing Register
-    volatile uint32 TMRR;                   //t_mrr Timing Register
-    volatile uint32 TCKESR;                 //t_ckesr Timing Register
-    volatile uint32 TDPD;                   //t_dpd Timing Register
-    uint32 reserved5[(0x180-0x148)/4];
-    //ECC Configuration, Control, and Status Registers
-    volatile uint32 ECCCFG;                   //ECC Configuration Register
-    volatile uint32 ECCTST;                   //ECC Test Register
-    volatile uint32 ECCCLR;                   //ECC Clear Register
-    volatile uint32 ECCLOG;                   //ECC Log Register
-    uint32 reserved6[(0x200-0x190)/4];
-    //DTU Control and Status Registers
-    volatile uint32 DTUWACTL;                 //DTU Write Address Control Register
-    volatile uint32 DTURACTL;                 //DTU Read Address Control Register
-    volatile uint32 DTUCFG;                   //DTU Configuration Control Register
-    volatile uint32 DTUECTL;                  //DTU Execute Control Register
-    volatile uint32 DTUWD0;                   //DTU Write Data 0
-    volatile uint32 DTUWD1;                   //DTU Write Data 1
-    volatile uint32 DTUWD2;                   //DTU Write Data 2
-    volatile uint32 DTUWD3;                   //DTU Write Data 3
-    volatile uint32 DTUWDM;                   //DTU Write Data Mask
-    volatile uint32 DTURD0;                   //DTU Read Data 0
-    volatile uint32 DTURD1;                   //DTU Read Data 1
-    volatile uint32 DTURD2;                   //DTU Read Data 2
-    volatile uint32 DTURD3;                   //DTU Read Data 3
-    volatile uint32 DTULFSRWD;                //DTU LFSR Seed for Write Data Generation
-    volatile uint32 DTULFSRRD;                //DTU LFSR Seed for Read Data Generation
-    volatile uint32 DTUEAF;                   //DTU Error Address FIFO
-    //DFI Control Registers
-    volatile uint32 DFITCTRLDELAY;            //DFI tctrl_delay Register
-    volatile uint32 DFIODTCFG;                //DFI ODT Configuration Register
-    volatile uint32 DFIODTCFG1;               //DFI ODT Configuration 1 Register
-    volatile uint32 DFIODTRANKMAP;            //DFI ODT Rank Mapping Register
-    //DFI Write Data Registers
-    volatile uint32 DFITPHYWRDATA;            //DFI tphy_wrdata Register
-    volatile uint32 DFITPHYWRLAT;             //DFI tphy_wrlat Register
-    uint32 reserved7[(0x260-0x258)/4];
-    volatile uint32 DFITRDDATAEN;             //DFI trddata_en Register
-    volatile uint32 DFITPHYRDLAT;             //DFI tphy_rddata Register
-    uint32 reserved8[(0x270-0x268)/4];
-    //DFI Update Registers
-    volatile uint32 DFITPHYUPDTYPE0;          //DFI tphyupd_type0 Register
-    volatile uint32 DFITPHYUPDTYPE1;          //DFI tphyupd_type1 Register
-    volatile uint32 DFITPHYUPDTYPE2;          //DFI tphyupd_type2 Register
-    volatile uint32 DFITPHYUPDTYPE3;          //DFI tphyupd_type3 Register
-    volatile uint32 DFITCTRLUPDMIN;           //DFI tctrlupd_min Register
-    volatile uint32 DFITCTRLUPDMAX;           //DFI tctrlupd_max Register
-    volatile uint32 DFITCTRLUPDDLY;           //DFI tctrlupd_dly Register
-    uint32 reserved9;
-    volatile uint32 DFIUPDCFG;                //DFI Update Configuration Register
-    volatile uint32 DFITREFMSKI;              //DFI Masked Refresh Interval Register
-    volatile uint32 DFITCTRLUPDI;             //DFI tctrlupd_interval Register
-    uint32 reserved10[(0x2ac-0x29c)/4];
-    volatile uint32 DFITRCFG0;                //DFI Training Configuration 0 Register
-    volatile uint32 DFITRSTAT0;               //DFI Training Status 0 Register
-    volatile uint32 DFITRWRLVLEN;             //DFI Training dfi_wrlvl_en Register
-    volatile uint32 DFITRRDLVLEN;             //DFI Training dfi_rdlvl_en Register
-    volatile uint32 DFITRRDLVLGATEEN;         //DFI Training dfi_rdlvl_gate_en Register
-    //DFI Status Registers
-    volatile uint32 DFISTSTAT0;               //DFI Status Status 0 Register
-    volatile uint32 DFISTCFG0;                //DFI Status Configuration 0 Register
-    volatile uint32 DFISTCFG1;                //DFI Status configuration 1 Register
-    uint32 reserved11;
-    volatile uint32 DFITDRAMCLKEN;            //DFI tdram_clk_enalbe Register
-    volatile uint32 DFITDRAMCLKDIS;           //DFI tdram_clk_disalbe Register
-    volatile uint32 DFISTCFG2;                //DFI Status configuration 2 Register
-    volatile uint32 DFISTPARCLR;              //DFI Status Parity Clear Register
-    volatile uint32 DFISTPARLOG;              //DFI Status Parity Log Register
-    uint32 reserved12[(0x2f0-0x2e4)/4];
-    //DFI Low Power Registers
-    volatile uint32 DFILPCFG0;                //DFI Low Power Configuration 0 Register
-    uint32 reserved13[(0x300-0x2f4)/4];
-    //DFI Training 2 Registers
-    volatile uint32 DFITRWRLVLRESP0;          //DFI Training dif_wrlvl_resp Status 0 Register
-    volatile uint32 DFITRWRLVLRESP1;          //DFI Training dif_wrlvl_resp Status 1 Register
-    volatile uint32 DFITRWRLVLRESP2;          //DFI Training dif_wrlvl_resp Status 2 Register
-    volatile uint32 DFITRRDLVLRESP0;          //DFI Training dif_rdlvl_resp Status 0 Register
-    volatile uint32 DFITRRDLVLRESP1;          //DFI Training dif_rdlvl_resp Status 1 Register
-    volatile uint32 DFITRRDLVLRESP2;          //DFI Training dif_rdlvl_resp Status 2 Register
-    volatile uint32 DFITRWRLVLDELAY0;         //DFI Training dif_wrlvl_delay Configuration 0 Register
-    volatile uint32 DFITRWRLVLDELAY1;         //DFI Training dif_wrlvl_delay Configuration 1 Register
-    volatile uint32 DFITRWRLVLDELAY2;         //DFI Training dif_wrlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLDELAY0;         //DFI Training dif_rdlvl_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLDELAY1;         //DFI Training dif_rdlvl_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLDELAY2;         //DFI Training dif_rdlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLGATEDELAY0;     //DFI Training dif_rdlvl_gate_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLGATEDELAY1;     //DFI Training dif_rdlvl_gate_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLGATEDELAY2;     //DFI Training dif_rdlvl_gate_delay Configuration 2 Register
-    volatile uint32 DFITRCMD;                 //DFI Training Command Register
-    uint32 reserved14[(0x3f8-0x340)/4];
-    //IP Status Registers
-    volatile uint32 IPVR;                     //IP Version Register
-    volatile uint32 IPTR;                     //IP Type Register
-}DDR_REG_T, *pDDR_REG_T;
-
-#define pDDR_Reg ((pDDR_REG_T)SDRAMC_BASE_ADDR)
-
-/*
- * PUBL
- */
-//PIR
-#define INIT                 (1<<0)
-#define DLLSRST              (1<<1)
-#define DLLLOCK              (1<<2)
-#define ZCAL                 (1<<3)
-#define ITMSRST              (1<<4)
-#define DRAMRST              (1<<5)
-#define DRAMINIT             (1<<6)
-#define QSTRN                (1<<7)
-#define EYETRN               (1<<8)
-#define ICPC                 (1<<16)
-#define DLLBYP               (1<<17)
-#define CTLDINIT             (1<<18)
-#define CLRSR                (1<<28)
-#define LOCKBYP              (1<<29)
-#define ZCALBYP              (1<<30)
-#define INITBYP              (1u<<31)
-
-//PGCR
-#define DFTLMT(n)            ((n)<<3)
-#define DFTCMP(n)            ((n)<<2)
-#define DQSCFG(n)            ((n)<<1)
-#define ITMDMD(n)            ((n)<<0)
-#define RANKEN(n)            ((n)<<18)
-
-//PGSR
-#define IDONE                (1<<0)
-#define DLDONE               (1<<1)
-#define ZCDONE               (1<<2)
-#define DIDONE               (1<<3)
-#define DTDONE               (1<<4)
-#define DTERR                (1<<5)
-#define DTIERR               (1<<6)
-#define DFTERR               (1<<7)
-#define TQ                   (1u<<31)
-
-//PTR0
-#define tITMSRST(n)          ((n)<<18)
-#define tDLLLOCK(n)          ((n)<<6)
-#define tDLLSRST(n)          ((n)<<0)
-
-//PTR1
-#define tDINIT1(n)           ((n)<<19)
-#define tDINIT0(n)           ((n)<<0)
-
-//PTR2
-#define tDINIT3(n)           ((n)<<17)
-#define tDINIT2(n)           ((n)<<0)
-
-//DSGCR
-#define DQSGE(n)             ((n)<<8)
-#define DQSGX(n)             ((n)<<5)
-
-typedef union DCR_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned DDRMD : 3;
-        unsigned DDR8BNK : 1;
-        unsigned PDQ : 3;
-        unsigned MPRDQ : 1;
-        unsigned DDRTYPE : 2;
-        unsigned reserved10_26 : 17;
-        unsigned NOSRA : 1;
-        unsigned DDR2T : 1;
-        unsigned UDIMM : 1;
-        unsigned RDIMM : 1;
-        unsigned TPD : 1;
-    } b;
-}DCR_T;
-
-typedef volatile struct DATX8_REG_Tag
-{
-    volatile uint32 DXGCR;                 //DATX8 General Configuration Register
-    volatile uint32 DXGSR[2];              //DATX8 General Status Register
-    volatile uint32 DXDLLCR;               //DATX8 DLL Control Register
-    volatile uint32 DXDQTR;                //DATX8 DQ Timing Register
-    volatile uint32 DXDQSTR;               //DATX8 DQS Timing Register
-    uint32 reserved[0x80-0x76];
-}DATX8_REG_T;
-
-/* DDR PHY register struct */
-typedef volatile struct DDRPHY_REG_Tag
-{
-    volatile uint32 RIDR;                   //Revision Identification Register
-    volatile uint32 PIR;                    //PHY Initialization Register
-    volatile uint32 PGCR;                   //PHY General Configuration Register
-    volatile uint32 PGSR;                   //PHY General Status Register
-    volatile uint32 DLLGCR;                 //DLL General Control Register
-    volatile uint32 ACDLLCR;                //AC DLL Control Register
-    volatile uint32 PTR[3];                 //PHY Timing Registers 0-2
-    volatile uint32 ACIOCR;                 //AC I/O Configuration Register
-    volatile uint32 DXCCR;                  //DATX8 Common Configuration Register
-    volatile uint32 DSGCR;                  //DDR System General Configuration Register
-    DCR_T DCR;                    //DRAM Configuration Register
-    volatile uint32 DTPR[3];                //DRAM Timing Parameters Register 0-2
-    volatile uint32 MR[4];                    //Mode Register 0-3
-    volatile uint32 ODTCR;                  //ODT Configuration Register
-    volatile uint32 DTAR;                   //Data Training Address Register
-    volatile uint32 DTDR[2];                //Data Training Data Register 0-1
-
-    uint32 reserved1[0x30-0x18];
-    uint32 DCU[0x38-0x30];
-    uint32 reserved2[0x40-0x38];
-    uint32 BIST[0x51-0x40];
-    uint32 reserved3[0x60-0x51];
-
-    volatile uint32 ZQ0CR[2];               //ZQ 0 Impedance Control Register 0-1
-    volatile uint32 ZQ0SR[2];               //ZQ 0 Impedance Status Register 0-1
-    volatile uint32 ZQ1CR[2];               //ZQ 1 Impedance Control Register 0-1
-    volatile uint32 ZQ1SR[2];               //ZQ 1 Impedance Status Register 0-1
-    volatile uint32 ZQ2CR[2];               //ZQ 2 Impedance Control Register 0-1
-    volatile uint32 ZQ2SR[2];               //ZQ 2 Impedance Status Register 0-1
-    volatile uint32 ZQ3CR[2];               //ZQ 3 Impedance Control Register 0-1
-    volatile uint32 ZQ3SR[2];               //ZQ 3 Impedance Status Register 0-1
-
-    DATX8_REG_T     DATX8[9];               //DATX8 Register
-}DDRPHY_REG_T, *pDDRPHY_REG_T;
-
-#define pPHY_Reg ((pDDRPHY_REG_T)DDR_PUBL_BASE)
-
-#if defined(CONFIG_ARCH_RK30) && (!defined(CONFIG_ARCH_RK3066B))
-#define pPMU_Reg               ((pPMU_FILE)PMU_BASE_ADDR)
-#define pCRU_Reg               ((pCRU_REG)CRU_BASE_ADDR)
-#define pGRF_Reg               ((pREG_FILE)REG_FILE_BASE_ADDR)
-#define GET_DDR3_DS_ODT()      ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0xb<<5) | 0xb)
-#define GET_LPDDR2_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x8<<5) | 0x8)
-#define GET_3188_PLUS_STATUS() (false)
-#define GET_DPLL_STATUS()      (true)
-#define DDR_GET_RANK_2_ROW15() (pGRF_Reg->GRF_SOC_CON[2] &  (1<<1))
-#define DDR_GET_BANK_2_RANK()  (pGRF_Reg->GRF_SOC_CON[2] &  (1<<2))
-#define DDR_HW_WAKEUP(en)      do{pGRF_Reg->GRF_SOC_CON[2] = (1<<16 | en);}while(0)  
-#define READ_GRF_REG()         (pGRF_Reg->GRF_SOC_CON[2])
-#define GET_DPLL_LOCK_STATUS() (pGRF_Reg->GRF_SOC_STATUS0 & (1<<4))
-#define SET_DDR_PLL_SRC(src, div)   do{pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3|(0x1<<8))<<16)|(src<<8)| div;}while(0)
-#define GET_DDR_PLL_SRC()      (DPLL)
-#define SET_DDRPHY_CLKGATE(dis)  do{pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (dis<<2);}while(0)
-#elif defined(CONFIG_ARCH_RK30) && defined(CONFIG_ARCH_RK3066B)
-#define pPMU_Reg               ((pPMU_FILE)PMU_BASE_ADDR)
-#define pCRU_Reg               ((pCRU_REG)CRU_BASE_ADDR)
-#define pGRF_Reg               ((pREG_FILE_RK3066B)REG_FILE_BASE_ADDR)
-#define GET_DDR3_DS_ODT()      ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_LPDDR2_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_3188_PLUS_STATUS() (false)
-#define GET_DPLL_STATUS()      (true)
-#define DDR_GET_RANK_2_ROW15() (pGRF_Reg->GRF_SOC_CON[2] &  (1<<1))
-#define DDR_GET_BANK_2_RANK()  (pGRF_Reg->GRF_SOC_CON[2] &  (1<<2))
-#define DDR_HW_WAKEUP(en)      do{pGRF_Reg->GRF_SOC_CON[2] = (1<<16 | en);}while(0)
-#define READ_GRF_REG()         (pGRF_Reg->GRF_SOC_CON[2])
-#define GET_DPLL_LOCK_STATUS() (pGRF_Reg->GRF_SOC_STATUS0 & (1<<5))
-#define SET_DDR_PLL_SRC(src, div)   do{pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3|(0x1<<8))<<16)|(src<<8)| div;}while(0)
-#define GET_DDR_PLL_SRC()      (DPLL)
-#define DDR_GPLL_CLK_GATE(en)  do{pCRU_Reg->CRU_CLKGATE_CON[1] = 0x00800000 | (en<<7);}while(0)
-#define SET_DDRPHY_CLKGATE(dis)  do{pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (dis<<2);}while(0)
-#elif defined(CONFIG_ARCH_RK3188)
-#define pPMU_Reg               ((pPMU_FILE)PMU_BASE_ADDR)
-#define pCRU_Reg               ((pCRU_REG)CRU_BASE_ADDR)
-#define pGRF_Reg               ((pREG_FILE_RK3066B)REG_FILE_BASE_ADDR)
-#define GET_DDR3_DS_ODT()      ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_LPDDR2_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_3188_PLUS_STATUS() (soc_is_rk3188plus())
-#define GET_DPLL_STATUS()      ((rk_pll_flag() & 0x3) ? false : true)
-#define DDR_GET_RANK_2_ROW15() (pGRF_Reg->GRF_SOC_CON[2] &  (1<<1))
-#define DDR_GET_BANK_2_RANK()  (pGRF_Reg->GRF_SOC_CON[2] &  (1<<2))
-#define DDR_HW_WAKEUP(en)      do{pGRF_Reg->GRF_SOC_CON[2] = (1<<16 | en);}while(0)
-#define READ_GRF_REG()         (pGRF_Reg->GRF_SOC_CON[2])
-#define GET_DPLL_LOCK_STATUS() (pGRF_Reg->GRF_SOC_STATUS0 & (1<<5))
-#define SET_DDR_PLL_SRC(src, div)   do{pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3|(0x1<<8))<<16)|(src<<8)| div;}while(0)
-#define GET_DDR_PLL_SRC()      ((pCRU_Reg->CRU_CLKSEL_CON[26]&(1<<8)) ? GPLL : DPLL)
-#define DDR_GPLL_CLK_GATE(en)  do{pCRU_Reg->CRU_CLKGATE_CON[1] = 0x00800000 | (en<<7);}while(0)
-#define SET_DDRPHY_CLKGATE(dis)  do{pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (dis<<2);}while(0)
-#elif defined(CONFIG_ARCH_RK319X)
-#define pPMU_Reg               ((pPMU_FILE_RK319X)PMU_BASE_ADDR)
-#define pCRU_Reg               ((pCRU_REG_RK319X)CRU_BASE_ADDR)
-#define pGRF_Reg               ((pREG_FILE_RK319X)REG_FILE_BASE_ADDR)
-#define GET_DDR3_DS_ODT()      ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_LPDDR2_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_3188_PLUS_STATUS() (true)
-#define GET_DPLL_STATUS()      (true)
-#define DDR_GET_RANK_2_ROW15() (pGRF_Reg->GRF_SOC_CON[0] &  (1<<9))
-#define DDR_GET_BANK_2_RANK()  (pGRF_Reg->GRF_SOC_CON[0] &  (1<<10))
-#define DDR_HW_WAKEUP(en)      do{pGRF_Reg->GRF_SOC_CON[0] = (1<<(16+8)) | (en<<8);}while(0)
-#define READ_GRF_REG()         (pGRF_Reg->GRF_SOC_CON[0])
-#define GET_DPLL_LOCK_STATUS() (pGRF_Reg->GRF_SOC_STATUS0 & (1<<5))
-#define SET_DDR_PLL_SRC(src, div)   do{pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3|(0x1<<2))<<16)|(src<<2)| div;}while(0)
-#define GET_DDR_PLL_SRC()      ((pCRU_Reg->CRU_CLKSEL_CON[26]&(1<<2)) ? GPLL : DPLL)
-#define DDR_GPLL_CLK_GATE(en)  do{pCRU_Reg->CRU_CLKGATE_CON[0] = 0x02000000 | (en<<9);}while(0)
-#define SET_DDRPHY_CLKGATE(dis)  do{pCRU_Reg->CRU_CLKGATE_CON[10] = ((0x1<<12)<<16) | (dis<<12);}while(0)
-#else
-#arch defined error!!
-#endif
-#define SET_PLL_MODE(pll, mode) do{pCRU_Reg->CRU_MODE_CON = ((mode<<((pll)*4))|(0x3<<(16+(pll)*4)));}while(0)
-#define SET_PLL_PD(pll, pd)     do{pCRU_Reg->CRU_PLL_CON[pll][3] = ((0x1<<1)<<16) | (pd<<1);}while(0)
-
-#define DDR_SYS_REG()    (pPMU_Reg->PMU_PMU_SYS_REG[2])
-#define READ_CS_INFO()   ((((pPMU_Reg->PMU_PMU_SYS_REG[2])>>11)&0x1)+1)
-#define READ_BW_INFO()   (2>>(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>2)&0x3))
-#define READ_COL_INFO()  (9+(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>9)&0x3))
-#define READ_BK_INFO()   (3-(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>8)&0x1))
-#define READ_CS0_ROW_INFO()  (13+(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>6)&0x3))
-#define READ_CS1_ROW_INFO()  (13+(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>4)&0x3))
-#define READ_DIE_BW_INFO()   (2>>(pPMU_Reg->PMU_PMU_SYS_REG[2]&0x3))
-
-static const uint8_t  ddr_cfg_2_rbc[] =
-{
-    /****************************/
-    // [7:6]  bank(n:n bit bank)
-    // [5:4]  row(13+n)
-    // [3:2]  bank(n:n bit bank)
-    // [1:0]  col(9+n)
-    /****************************/
-    //bank, row,    bank,  col
-    ((3<<6)|(2<<4)|(0<<2)|2),  // 0 bank ahead
-    ((0<<6)|(2<<4)|(3<<2)|1),  // 1
-    ((0<<6)|(1<<4)|(3<<2)|1),  // 2
-    ((0<<6)|(0<<4)|(3<<2)|1),  // 3
-    ((0<<6)|(2<<4)|(3<<2)|2),  // 4
-    ((0<<6)|(1<<4)|(3<<2)|2),  // 5
-    ((0<<6)|(0<<4)|(3<<2)|2),  // 6
-    ((0<<6)|(1<<4)|(3<<2)|0),  // 7
-    ((0<<6)|(0<<4)|(3<<2)|0),  // 8
-    ((1<<6)|(2<<4)|(2<<2)|2),  // 9
-    ((1<<6)|(1<<4)|(2<<2)|2),  // 10
-    ((1<<6)|(2<<4)|(2<<2)|1),  // 11
-    ((1<<6)|(1<<4)|(2<<2)|1),  // 12
-    ((1<<6)|(2<<4)|(2<<2)|0),  // 13
-    ((1<<6)|(1<<4)|(2<<2)|0),  // 14
-    ((3<<6)|(2<<4)|(0<<2)|1),  // 15 bank ahead
-};
-
-/***********************************
- * LPDDR2 define
- ***********************************/
-//MR0 (Device Information)
-#define  LPDDR2_DAI    (0x1)        // 0:DAI complete, 1:DAI still in progress
-#define  LPDDR2_DI     (0x1<<1)     // 0:S2 or S4 SDRAM, 1:NVM
-#define  LPDDR2_DNVI   (0x1<<2)     // 0:DNV not supported, 1:DNV supported
-#define  LPDDR2_RZQI   (0x3<<3)     // 00:RZQ self test not supported, 01:ZQ-pin may connect to VDDCA or float
-                                    // 10:ZQ-pin may short to GND.     11:ZQ-pin self test completed, no error condition detected.
-
-//MR1 (Device Feature)
-#define LPDDR2_BL4     (0x2)
-#define LPDDR2_BL8     (0x3)
-#define LPDDR2_BL16    (0x4)
-#define LPDDR2_nWR(n)  (((n)-2)<<5)
-
-//MR2 (Device Feature 2)
-#define LPDDR2_RL3_WL1  (0x1)
-#define LPDDR2_RL4_WL2  (0x2)
-#define LPDDR2_RL5_WL2  (0x3)
-#define LPDDR2_RL6_WL3  (0x4)
-#define LPDDR2_RL7_WL4  (0x5)
-#define LPDDR2_RL8_WL4  (0x6)
-
-//MR3 (IO Configuration 1)
-#define LPDDR2_DS_34    (0x1)
-#define LPDDR2_DS_40    (0x2)
-#define LPDDR2_DS_48    (0x3)
-#define LPDDR2_DS_60    (0x4)
-#define LPDDR2_DS_80    (0x6)
-#define LPDDR2_DS_120   (0x7)   //optional
-
-//MR4 (Device Temperature)
-#define LPDDR2_tREF_MASK (0x7)
-#define LPDDR2_4_tREF    (0x1)
-#define LPDDR2_2_tREF    (0x2)
-#define LPDDR2_1_tREF    (0x3)
-#define LPDDR2_025_tREF  (0x5)
-#define LPDDR2_025_tREF_DERATE    (0x6)
-
-#define LPDDR2_TUF       (0x1<<7)
-
-//MR8 (Basic configuration 4)
-#define LPDDR2_S4        (0x0)
-#define LPDDR2_S2        (0x1)
-#define LPDDR2_N         (0x2)
-#define LPDDR2_Density(mr8)  (8<<(((mr8)>>2)&0xf))   // Unit:MB
-#define LPDDR2_IO_Width(mr8) (32>>(((mr8)>>6)&0x3))
-
-//MR10 (Calibration)
-#define LPDDR2_ZQINIT   (0xFF)
-#define LPDDR2_ZQCL     (0xAB)
-#define LPDDR2_ZQCS     (0x56)
-#define LPDDR2_ZQRESET  (0xC3)
-
-//MR16 (PASR Bank Mask)
-// S2 SDRAM Only
-#define LPDDR2_PASR_Full (0x0)
-#define LPDDR2_PASR_1_2  (0x1)
-#define LPDDR2_PASR_1_4  (0x2)
-#define LPDDR2_PASR_1_8  (0x3)
-
-//MR17 (PASR Segment Mask) 1Gb-8Gb S4 SDRAM only
-
-//MR32 (DQ Calibration Pattern A)
-
-//MR40 (DQ Calibration Pattern B)
-
-/***********************************
- * DDR3 define
- ***********************************/
-//mr0 for ddr3
-#define DDR3_BL8          (0)
-#define DDR3_BC4_8        (1)
-#define DDR3_BC4          (2)
-#define DDR3_CL(n)        (((((n)-4)&0x7)<<4)|((((n)-4)&0x8)>>1))
-#define DDR3_WR(n)        (((n)&0x7)<<9)
-#define DDR3_DLL_RESET    (1<<8)
-#define DDR3_DLL_DeRESET  (0<<8)
-
-//mr1 for ddr3
-#define DDR3_DLL_ENABLE    (0)
-#define DDR3_DLL_DISABLE   (1)
-#define DDR3_MR1_AL(n)  (((n)&0x3)<<3)
-
-#define DDR3_DS_40            (0)
-#define DDR3_DS_34            (1<<1)
-#define DDR3_Rtt_Nom_DIS      (0)
-#define DDR3_Rtt_Nom_60       (1<<2)
-#define DDR3_Rtt_Nom_120      (1<<6)
-#define DDR3_Rtt_Nom_40       ((1<<2)|(1<<6))
-
-    //mr2 for ddr3
-#define DDR3_MR2_CWL(n) ((((n)-5)&0x7)<<3)
-#define DDR3_Rtt_WR_DIS       (0)
-#define DDR3_Rtt_WR_60        (1<<9)
-#define DDR3_Rtt_WR_120       (2<<9)
-
-/***********************************
- * DDR2 define
- ***********************************/
-//MR;                     //Mode Register
-#define DDR2_BL4           (2)
-#define DDR2_BL8           (3)
-#define DDR2_CL(n)         (((n)&0x7)<<4)
-#define DDR2_WR(n)        ((((n)-1)&0x7)<<9)
-#define DDR2_DLL_RESET    (1<<8)
-#define DDR2_DLL_DeRESET  (0<<8)
-
-//EMR;                    //Extended Mode Register
-#define DDR2_DLL_ENABLE    (0)
-#define DDR2_DLL_DISABLE   (1)
-
-#define DDR2_STR_FULL     (0)
-#define DDR2_STR_REDUCE   (1<<1)
-#define DDR2_AL(n)        (((n)&0x7)<<3)
-#define DDR2_Rtt_Nom_DIS      (0)
-#define DDR2_Rtt_Nom_150      (0x40)
-#define DDR2_Rtt_Nom_75       (0x4)
-#define DDR2_Rtt_Nom_50       (0x44)
-
-/***********************************
- * LPDDR define
- ***********************************/
-#define mDDR_BL2           (1)
-#define mDDR_BL4           (2)
-#define mDDR_BL8           (3)
-#define mDDR_CL(n)         (((n)&0x7)<<4)
-
-#define mDDR_DS_Full       (0)
-#define mDDR_DS_1_2        (1<<5)
-#define mDDR_DS_1_4        (2<<5)
-#define mDDR_DS_1_8        (3<<5)
-#define mDDR_DS_3_4        (4<<5)
-
-static const uint8_t ddr3_cl_cwl[22][7]={
-/*speed   0~330         331~400       401~533        534~666       667~800        801~933      934~1066
- * tCK    >3            2.5~3         1.875~2.5      1.5~1.875     1.25~1.5       1.07~1.25    0.938~1.07
- *        cl<<4, cwl    cl<<4, cwl    cl<<4, cwl              */
-         {((5<<4)|5),   ((5<<4)|5),   0         ,    0,            0,             0,            0}, //DDR3_800D (5-5-5)
-         {((5<<4)|5),   ((6<<4)|5),   0         ,    0,            0,             0,            0}, //DDR3_800E (6-6-6)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    0,            0,             0,            0}, //DDR3_1066E (6-6-6)
-         {((5<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    0,            0,             0,            0}, //DDR3_1066F (7-7-7)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    0,            0,             0,            0}, //DDR3_1066G (8-8-8)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   0,             0,            0}, //DDR3_1333F (7-7-7)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((8<<4)|7),   0,             0,            0}, //DDR3_1333G (8-8-8)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((9<<4)|7),   0,             0,            0}, //DDR3_1333H (9-9-9)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  0,             0,            0}, //DDR3_1333J (10-10-10)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   ((8<<4)|8),    0,            0}, //DDR3_1600G (8-8-8)
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    0,            0}, //DDR3_1600H (9-9-9)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((10<<4)|8),   0,            0}, //DDR3_1600J (10-10-10)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   0,            0}, //DDR3_1600K (11-11-11)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    ((11<<4)|9),  0}, //DDR3_1866J (10-10-10)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((8<<4)|7),   ((10<<4)|8),   ((11<<4)|9),  0}, //DDR3_1866K (11-11-11)
-         {((6<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((11<<4)|8),   ((12<<4)|9),  0}, //DDR3_1866L (12-12-12)
-         {((6<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   ((13<<4)|9),  0}, //DDR3_1866M (13-13-13)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   ((9<<4)|8),    ((10<<4)|9),  ((11<<4)|10)}, //DDR3_2133K (11-11-11)
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    ((11<<4)|9),  ((12<<4)|10)}, //DDR3_2133L (12-12-12)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((10<<4)|8),   ((12<<4)|9),  ((13<<4)|10)}, //DDR3_2133M (13-13-13)
-         {((6<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((11<<4)|8),   ((13<<4)|9),  ((14<<4)|10)},  //DDR3_2133N (14-14-14)
-
-         {((6<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   ((13<<4)|9),  ((14<<4)|10)} //DDR3_DEFAULT
-};
-
-static const uint16_t ddr3_tRC_tFAW[22]={
-/**    tRC    tFAW   */
-    ((50<<8)|50), //DDR3_800D (5-5-5)
-    ((53<<8)|50), //DDR3_800E (6-6-6)
-
-    ((49<<8)|50), //DDR3_1066E (6-6-6)
-    ((51<<8)|50), //DDR3_1066F (7-7-7)
-    ((53<<8)|50), //DDR3_1066G (8-8-8)
-
-    ((47<<8)|45), //DDR3_1333F (7-7-7)
-    ((48<<8)|45), //DDR3_1333G (8-8-8)
-    ((50<<8)|45), //DDR3_1333H (9-9-9)
-    ((51<<8)|45), //DDR3_1333J (10-10-10)
-
-    ((45<<8)|40), //DDR3_1600G (8-8-8)
-    ((47<<8)|40), //DDR3_1600H (9-9-9)
-    ((48<<8)|40), //DDR3_1600J (10-10-10)
-    ((49<<8)|40), //DDR3_1600K (11-11-11)
-
-    ((45<<8)|35), //DDR3_1866J (10-10-10)
-    ((46<<8)|35), //DDR3_1866K (11-11-11)
-    ((47<<8)|35), //DDR3_1866L (12-12-12)
-    ((48<<8)|35), //DDR3_1866M (13-13-13)
-
-    ((44<<8)|35), //DDR3_2133K (11-11-11)
-    ((45<<8)|35), //DDR3_2133L (12-12-12)
-    ((46<<8)|35), //DDR3_2133M (13-13-13)
-    ((47<<8)|35), //DDR3_2133N (14-14-14)
-
-    ((53<<8)|50)  //DDR3_DEFAULT
-};
-
-typedef enum DRAM_TYPE_Tag
-{
-    LPDDR = 0,
-    DDR,
-    DDR2,
-    DDR3,
-    LPDDR2,
-
-    DRAM_MAX
-}DRAM_TYPE;
-
-typedef struct PCTRL_TIMING_Tag
-{
-    uint32 ddrFreq;
-    //Memory Timing Registers
-    uint32 togcnt1u;               //Toggle Counter 1U Register
-    uint32 tinit;                  //t_init Timing Register
-    uint32 trsth;                  //Reset High Time Register
-    uint32 togcnt100n;             //Toggle Counter 100N Register
-    uint32 trefi;                  //t_refi Timing Register
-    uint32 tmrd;                   //t_mrd Timing Register
-    uint32 trfc;                   //t_rfc Timing Register
-    uint32 trp;                    //t_rp Timing Register
-    uint32 trtw;                   //t_rtw Timing Register
-    uint32 tal;                    //AL Latency Register
-    uint32 tcl;                    //CL Timing Register
-    uint32 tcwl;                   //CWL Register
-    uint32 tras;                   //t_ras Timing Register
-    uint32 trc;                    //t_rc Timing Register
-    uint32 trcd;                   //t_rcd Timing Register
-    uint32 trrd;                   //t_rrd Timing Register
-    uint32 trtp;                   //t_rtp Timing Register
-    uint32 twr;                    //t_wr Timing Register
-    uint32 twtr;                   //t_wtr Timing Register
-    uint32 texsr;                  //t_exsr Timing Register
-    uint32 txp;                    //t_xp Timing Register
-    uint32 txpdll;                 //t_xpdll Timing Register
-    uint32 tzqcs;                  //t_zqcs Timing Register
-    uint32 tzqcsi;                 //t_zqcsi Timing Register
-    uint32 tdqs;                   //t_dqs Timing Register
-    uint32 tcksre;                 //t_cksre Timing Register
-    uint32 tcksrx;                 //t_cksrx Timing Register
-    uint32 tcke;                   //t_cke Timing Register
-    uint32 tmod;                   //t_mod Timing Register
-    uint32 trstl;                  //Reset Low Timing Register
-    uint32 tzqcl;                  //t_zqcl Timing Register
-    uint32 tmrr;                   //t_mrr Timing Register
-    uint32 tckesr;                 //t_ckesr Timing Register
-    uint32 tdpd;                   //t_dpd Timing Register
-}PCTL_TIMING_T;
-
-typedef union DTPR_0_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tMRD : 2;
-        unsigned tRTP : 3;
-        unsigned tWTR : 3;
-        unsigned tRP : 4;
-        unsigned tRCD : 4;
-        unsigned tRAS : 5;
-        unsigned tRRD : 4;
-        unsigned tRC : 6;
-        unsigned tCCD : 1;
-    } b;
-}DTPR_0_T;
-
-typedef union DTPR_1_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tAOND : 2;
-        unsigned tRTW : 1;
-        unsigned tFAW : 6;
-        unsigned tMOD : 2;
-        unsigned tRTODT : 1;
-        unsigned reserved12_15 : 4;
-        unsigned tRFC : 8;
-        unsigned tDQSCK : 3;
-        unsigned tDQSCKmax : 3;
-        unsigned reserved30_31 : 2;
-    } b;
-}DTPR_1_T;
-
-typedef union DTPR_2_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tXS : 10;
-        unsigned tXP : 5;
-        unsigned tCKE : 4;
-        unsigned tDLLK : 10;
-        unsigned reserved29_31 : 3;
-    } b;
-}DTPR_2_T;
-
-typedef struct PHY_TIMING_Tag
-{
-    DTPR_0_T  dtpr0;
-    DTPR_1_T  dtpr1;
-    DTPR_2_T  dtpr2;
-    uint32    mr[4];   //LPDDR2 no MR0, mr[2] is mDDR MR1
-}PHY_TIMING_T;
-
-typedef union NOC_TIMING_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned ActToAct : 6;
-        unsigned RdToMiss : 6;
-        unsigned WrToMiss : 6;
-        unsigned BurstLen : 3;
-        unsigned RdToWr : 5;
-        unsigned WrToRd : 5;
-        unsigned BwRatio : 1;
-    } b;
-}NOC_TIMING_T;
-
-typedef struct PCTL_REG_Tag
-{
-    uint32 SCFG;
-    uint32 CMDTSTATEN;
-    uint32 MCFG1;
-    uint32 MCFG;
-    PCTL_TIMING_T pctl_timing;
-    //DFI Control Registers
-    uint32 DFITCTRLDELAY;
-    uint32 DFIODTCFG;
-    uint32 DFIODTCFG1;
-    uint32 DFIODTRANKMAP;
-    //DFI Write Data Registers
-    uint32 DFITPHYWRDATA;
-    uint32 DFITPHYWRLAT;
-    //DFI Read Data Registers
-    uint32 DFITRDDATAEN;
-    uint32 DFITPHYRDLAT;
-    //DFI Update Registers
-    uint32 DFITPHYUPDTYPE0;
-    uint32 DFITPHYUPDTYPE1;
-    uint32 DFITPHYUPDTYPE2;
-    uint32 DFITPHYUPDTYPE3;
-    uint32 DFITCTRLUPDMIN;
-    uint32 DFITCTRLUPDMAX;
-    uint32 DFITCTRLUPDDLY;
-    uint32 DFIUPDCFG;
-    uint32 DFITREFMSKI;
-    uint32 DFITCTRLUPDI;
-    //DFI Status Registers
-    uint32 DFISTCFG0;
-    uint32 DFISTCFG1;
-    uint32 DFITDRAMCLKEN;
-    uint32 DFITDRAMCLKDIS;
-    uint32 DFISTCFG2;
-    //DFI Low Power Register
-    uint32 DFILPCFG0;
-}PCTL_REG_T;
-
-typedef struct PUBL_REG_Tag
-{
-    uint32 PIR;
-    uint32 PGCR;
-    uint32 DLLGCR;
-    uint32 ACDLLCR;
-    uint32 PTR[3];
-    uint32 ACIOCR;
-    uint32 DXCCR;
-    uint32 DSGCR;
-    uint32 DCR;
-    PHY_TIMING_T phy_timing;
-    uint32 ODTCR;
-    uint32 DTAR;
-    uint32 ZQ0CR0;
-    uint32 ZQ1CR0;
-
-    uint32 DX0GCR;
-    uint32 DX0DLLCR;
-    uint32 DX0DQTR;
-    uint32 DX0DQSTR;
-
-    uint32 DX1GCR;
-    uint32 DX1DLLCR;
-    uint32 DX1DQTR;
-    uint32 DX1DQSTR;
-
-    uint32 DX2GCR;
-    uint32 DX2DLLCR;
-    uint32 DX2DQTR;
-    uint32 DX2DQSTR;
-
-    uint32 DX3GCR;
-    uint32 DX3DLLCR;
-    uint32 DX3DQTR;
-    uint32 DX3DQSTR;
-}PUBL_REG_T;
-
-typedef struct BACKUP_REG_Tag
-{
-    PCTL_REG_T pctl;
-    PUBL_REG_T publ;
-    uint32 DdrConf;
-    NOC_TIMING_T noc_timing;
-    uint32 DdrMode;
-    uint32 ReadLatency;
-}BACKUP_REG_T;
-
-BACKUP_REG_T DEFINE_PIE_DATA(ddr_reg);
-static BACKUP_REG_T *p_ddr_reg;
-static __attribute__((aligned(4096))) uint32_t ddr_data_training_buf[32];
-uint32_t DEFINE_PIE_DATA(mem_type);    // 0:LPDDR, 1:DDR, 2:DDR2, 3:DDR3, 4:LPDDR2
-static uint32_t *p_mem_type;
-static uint32_t ddr_speed_bin;    // used for ddr3 only
-static uint32_t ddr_capability_per_die;  // one chip cs capability
-uint32_t DEFINE_PIE_DATA(ddr_freq);
-static uint32_t ddr_freq;
-uint32_t DEFINE_PIE_DATA(ddr_sr_idle);
-
-/***********************************
- * ARCH Relative Data and Function
- ***********************************/
-static __sramdata uint32_t clkr;
-static __sramdata uint32_t clkf;
-static __sramdata uint32_t clkod;
-static __sramdata uint32_t dpllvaluel=0,gpllvaluel=0;
-uint32_t DEFINE_PIE_DATA(ddr_select_gpll_div); // 0-Disable, 1-1:1, 2-2:1, 4-4:1
-static uint32_t *p_ddr_select_gpll_div;
-bool DEFINE_PIE_DATA(ddr_soc_is_rk3188_plus);
-static bool ddr_soc_is_rk3188_plus;
-bool DEFINE_PIE_DATA(ddr_rk3188_dpll_is_good);
-static bool ddr_rk3188_dpll_is_good;
-
-static void __sramfunc ddr_delayus(uint32_t us);
-
-static uint32_t __sramfunc ddr_get_pll_freq_sram(PLL_ID pll_id)   //APLL-1;CPLL-2;DPLL-3;GPLL-4
-{
-    uint32_t ret = 0;
-
-     // freq = (Fin/NR)*NF/OD
-    if(((pCRU_Reg->CRU_MODE_CON>>(pll_id*4))&3) == 1)             // DPLL Normal mode
-        ret= 24 *((pCRU_Reg->CRU_PLL_CON[pll_id][1]&0xffff)+1)    // NF = 2*(CLKF+1)
-                /((((pCRU_Reg->CRU_PLL_CON[pll_id][0]>>8)&0x3f)+1)           // NR = CLKR+1
-                *((pCRU_Reg->CRU_PLL_CON[pll_id][0]&0x3F)+1));             // OD = 2^CLKOD
-    else
-        ret = 24;
-
-    return ret;
-}
-
-static noinline uint32_t ddr_get_pll_freq(PLL_ID pll_id)   //APLL-1;CPLL-2;DPLL-3;GPLL-4
-{
-    uint32_t ret = 0;
-
-     // freq = (Fin/NR)*NF/OD
-    if(((pCRU_Reg->CRU_MODE_CON>>(pll_id*4))&3) == 1)             // DPLL Normal mode
-        ret= 24 *((pCRU_Reg->CRU_PLL_CON[pll_id][1]&0xffff)+1)    // NF = 2*(CLKF+1)
-                /((((pCRU_Reg->CRU_PLL_CON[pll_id][0]>>8)&0x3f)+1)           // NR = CLKR+1
-                *((pCRU_Reg->CRU_PLL_CON[pll_id][0]&0x3F)+1));             // OD = 2^CLKOD
-    else
-        ret = 24;
-
-    return ret;
-}
-
-#if defined(CONFIG_ARCH_RK30) && (!defined(CONFIG_ARCH_RK3066B))
-/*****************************************
-NR   NO     NF               Fout                       freq Step     finally use
-1    8      12.5 - 62.5      37.5MHz  - 187.5MHz        3MHz          50MHz   <= 150MHz
-1    6      12.5 - 62.5      50MHz    - 250MHz          4MHz          150MHz  <= 200MHz
-1    4      12.5 - 62.5      75MHz    - 375MHz          6MHz          200MHz  <= 300MHz
-1    2      12.5 - 62.5      150MHz   - 750MHz          12MHz         300MHz  <= 600MHz
-1    1      12.5 - 62.5      300MHz   - 1500MHz         24MHz         600MHz  <= 1200MHz
-******************************************/
-static uint32_t __sramfunc ddr_set_pll_3066(uint32_t nMHz, uint32_t set)
-{
-    uint32_t ret = 0;
-    int delay = 1000;
-    //NO,NRjitter
-
-    if(nMHz == 24)
-    {
-        ret = 24;
-        goto out;
-    }
-
-    if(!set)
-    {
-        if(nMHz <= 150)
-        {
-            clkod = 8;
-        }
-        else if(nMHz <= 200)
-        {
-            clkod = 6;
-        }
-        else if(nMHz <= 300)
-        {
-            clkod = 4;
-        }
-        else if(nMHz <= 600)
-        {
-            clkod = 2;
-        }
-        else
-        {
-            clkod = 1;
-        }
-        clkr = 1;
-        clkf=(nMHz*clkr*clkod)/24;
-        ret = (24*clkf)/(clkr*clkod);
-    }
-    else
-    {
-        SET_PLL_MODE(DPLL,0);            //PLL slow-mode
-        dsb();
-        pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_RESET;
-        pCRU_Reg->CRU_PLL_CON[DPLL][0] = NR(clkr) | NO(clkod);
-        pCRU_Reg->CRU_PLL_CON[DPLL][1] = NF(clkf);
-        pCRU_Reg->CRU_PLL_CON[DPLL][2] = NB(clkf>>1);
-        ddr_delayus(1);
-        pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_DE_RESET;
-        dsb();
-        while (delay > 0)
-        {
-            ddr_delayus(1);
-            if (GET_DPLL_LOCK_STATUS())
-            break;
-            delay--;
-        }
-        SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL, clk_ddr_src:clk_ddrphy = 1:1
-        SET_PLL_MODE(DPLL,1);            //PLL normal
-        dsb();
-    }
-out:
-    return ret;
-}
-#endif
-
-#if (defined(CONFIG_ARCH_RK30) && defined(CONFIG_ARCH_RK3066B)) || defined(CONFIG_ARCH_RK3188)
-/*****************************************
-RK3066B
-NR   NO     NF                      Fout                       freq Step     finally use
-1    14     46 - 91          78MHz  -   157MHz          1.7MHz        78MHz<= 150MHz
-1    8      46 - 91          137MHz  -  275MHz          3MHz          150MHz<= 200MHz
-1    6      46 - 91          183MHz   - 366MHz          4MHz          200MHz<= 300MHz
-1    4      46 - 91          275MHz   - 550MHz          6MHz          300MHz<= 550MHz
-1    2      46 - 91          550MHz   - 1100MHz         12MHz         550MHz<= 1100MHz
-1    1      46 - 91          1100MHz  - 2200MHz         24MHz         1100MHz<= 2200MHz
-******************************************/
-static uint32_t __sramfunc ddr_set_pll_rk3066b(uint32_t nMHz, uint32_t set)
-{
-    uint32_t ret = 0;
-    int delay = 1000;
-
-    if(nMHz == 24)
-    {
-        ret = 24;
-        goto out;
-    }
-
-    if(!set)
-    {
-        dpllvaluel = ddr_get_pll_freq_sram(DPLL);
-        gpllvaluel = ddr_get_pll_freq_sram(GPLL);
-
-        if(DATA(ddr_rk3188_dpll_is_good) == false)    //if rk3188 DPLL is bad,use GPLL
-        {
-            if( (gpllvaluel < 200) ||(gpllvaluel > 2000))
-            {
-                ///ddr_print("DPLL is bad and GPLL freq = %dMHz,Not suitable for ddr_clock\n",gpllvaluel);
-                return 0;
-            }
-
-            if(gpllvaluel > 1000)    //GPLL:1000MHz-2000MHz
-            {
-                DATA(ddr_select_gpll_div)=4;    //DDR_CLCOK:250MHz-500MHz
-            }
-            else if(gpllvaluel > 800)    //GPLL:800MHz-1000MHz
-            {
-                if(nMHz > 250)
-                    DATA(ddr_select_gpll_div)=2;    //DDR_CLCOK:400MHz-500MHz
-                else
-                    DATA(ddr_select_gpll_div)=4;    //DDR_CLCOK:200MHz-250MHz
-            }
-            else if(gpllvaluel > 500)    //GPLL:500MHz-800MHz
-            {
-                DATA(ddr_select_gpll_div)=2;    //DDR_CLCOK:250MHz-400MHz
-            }
-            else     //GPLL:200MHz-500MHz
-            {
-                DATA(ddr_select_gpll_div)=1;    //DDR_CLCOK:200MHz-500MHz
-            }
-        }
-
-        if(DATA(ddr_select_gpll_div) > 0)
-        {
-            ret=gpllvaluel/DATA(ddr_select_gpll_div);
-        }
-        else
-        {
-            if(nMHz <= 150)
-            {
-                clkod = 14;
-            }
-            else if(nMHz <= 200)
-            {
-                clkod = 8;
-            }
-            else if(nMHz <= 300)
-            {
-                clkod = 6;
-            }
-            else if(nMHz <= 550)
-            {
-                clkod = 4;
-            }
-            else if(nMHz <= 1100)
-            {
-                clkod = 2;
-            }
-            else
-            {
-                clkod = 1;
-            }
-            clkr = 1;
-            clkf=(nMHz*clkr*clkod)/24;
-            ret = (24*clkf)/(clkr*clkod);
-        }
-
-    }
-    else
-    {
-        if(DATA(ddr_select_gpll_div) > 0)
-        {
-            DDR_GPLL_CLK_GATE(0);
-            SET_DDR_PLL_SRC(1, (DATA(ddr_select_gpll_div)>>1));  //clk_ddr_src = G PLL, clk_ddr_src:clk_ddrphy = 4:1/2:1/1:1
-            dsb();
-        }
-        else if((nMHz==dpllvaluel) && (set == 1))
-        {
-            SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL,clk_ddr_src:clk_ddrphy = 1:1
-            dsb();
-        }
-        else
-        {
-            SET_PLL_MODE(DPLL,0);            //PLL slow-mode
-            dsb();
-
-            pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_RESET_RK3066B;
-             ddr_delayus(1);
-            pCRU_Reg->CRU_PLL_CON[DPLL][0] = NR_RK3066B(clkr) | NO_RK3066B(clkod);
-            pCRU_Reg->CRU_PLL_CON[DPLL][1] = NF_RK3066B(clkf);
-            //     pCRU_Reg->CRU_PLL_CON[pll_id][2] = NB(clkf>>1);
-            ddr_delayus(1);
-            pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_DE_RESET_RK3066B;
-            dsb();
-            while (delay > 0)
-            {
-                ddr_delayus(1);
-                if (GET_DPLL_LOCK_STATUS())
-                    break;
-                delay--;
-            }
-
-            if(set == 1)
-                SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL,clk_ddr_src:clk_ddrphy = 1:1
-            SET_PLL_MODE(DPLL,1);            //PLL normal
-            dsb();
-        }
-    }
-    dsb();
-out:
-    return ret;
-}
-#endif
-
-#if defined(CONFIG_ARCH_RK3188) || defined(CONFIG_ARCH_RK319X)
-/*****************************************
-NR   NO     NF               Fout                       freq Step     finally use
-1    8      12.5 - 62.5      37.5MHz  - 187.5MHz        3MHz          50MHz   <= 150MHz
-1    6      12.5 - 62.5      50MHz    - 250MHz          4MHz          150MHz  <= 200MHz
-1    4      12.5 - 62.5      75MHz    - 375MHz          6MHz          200MHz  <= 300MHz
-1    2      12.5 - 62.5      150MHz   - 750MHz          12MHz         300MHz  <= 600MHz
-1    1      12.5 - 62.5      300MHz   - 1500MHz         24MHz         600MHz  <= 1200MHz
-******************************************/
-static uint32_t __sramfunc ddr_set_pll_rk3188_plus(uint32_t nMHz, uint32_t set)
-{
-    uint32_t ret = 0;
-    int delay = 1000;
-
-    if(nMHz == 24)
-    {
-        ret = 24;
-        goto out;
-    }
-
-    if(!set)
-    {
-        dpllvaluel = ddr_get_pll_freq_sram(DPLL);
-        gpllvaluel = ddr_get_pll_freq_sram(GPLL);
-
-        if(DATA(ddr_select_gpll_div) > 0)
-        {
-            ret = gpllvaluel/DATA(ddr_select_gpll_div);
-        }
-        else
-        {
-            if(nMHz <= 150)
-            {
-                clkod = 8;
-            }
-            else if(nMHz <= 200)
-            {
-                clkod = 6;
-            }
-            else if(nMHz <= 300)
-            {
-                clkod = 4;
-            }
-            else if(nMHz <= 600)
-            {
-                clkod = 2;
-            }
-            else
-            {
-                clkod = 1;
-            }
-            clkr = 1;
-            clkf=(nMHz*clkr*clkod)/24;
-            ret = (24*clkf)/(clkr*clkod);
-        }
-
-    }
-    else
-    {
-        if(DATA(ddr_select_gpll_div) > 0)
-        {
-            DDR_GPLL_CLK_GATE(0);
-            SET_DDR_PLL_SRC(1, (DATA(ddr_select_gpll_div)>>1));  //clk_ddr_src = G PLL,clk_ddr_src:clk_ddrphy = 4:1/2:1/1:1
-            dsb();
-        }
-        else if((nMHz==dpllvaluel) && (set == 1))
-        {
-            SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL,clk_ddr_src:clk_ddrphy = 1:1
-            dsb();
-        }
-        else
-        {
-            SET_PLL_MODE(DPLL,0);            //PLL slow-mode
-            dsb();
-
-            pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_RESET;
-             ddr_delayus(1);
-            pCRU_Reg->CRU_PLL_CON[DPLL][0] = NR(clkr) | NO(clkod);
-            pCRU_Reg->CRU_PLL_CON[DPLL][1] = NF(clkf);
-            pCRU_Reg->CRU_PLL_CON[DPLL][2] = NB(clkf>>1);
-            ddr_delayus(1);
-            pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_DE_RESET;
-            dsb();
-            while (delay > 0)
-            {
-                ddr_delayus(1);
-                if (GET_DPLL_LOCK_STATUS())
-                    break;
-                delay--;
-            }
-
-            if(set == 1)
-                SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL,clk_ddr_src:clk_ddrphy = 1:1
-            SET_PLL_MODE(DPLL,1);            //PLL normal
-            dsb();
-        }
-    }
-    dsb();
-out:
-    return ret;
-}
-#endif
-
-uint32_t PIE_FUNC(ddr_set_pll)(uint32_t nMHz, uint32_t set)
-{
-#if defined(CONFIG_ARCH_RK3188)
-    if(DATA(ddr_soc_is_rk3188_plus) == true)
-        return ddr_set_pll_rk3188_plus(nMHz,set);
-    else
-        return ddr_set_pll_rk3066b(nMHz,set);
-#elif defined(CONFIG_ARCH_RK30) && defined(CONFIG_ARCH_RK3066B)
-    return ddr_set_pll_rk3066b(nMHz,set);
-#elif defined(CONFIG_ARCH_RK319X)
-    return ddr_set_pll_rk3188_plus(nMHz,set);
-#else
-    return ddr_set_pll_3066(nMHz,set);
-#endif
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_set_pll));
-static uint32_t (*p_ddr_set_pll)(uint32_t nMHz, uint32_t set);
-
-#ifdef CONFIG_ARCH_RK319X
-static void __sramfunc idle_port(void)
-{
-    int i;
-    uint32 clk_gate[16];
-
-    //save clock gate status
-    for(i=0;i<16;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<16;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    /*
-    pPMU_Reg->PMU_NOC_REQ |= idle_req_bp2ap_rk319x;
-    dsb();
-    while(((pPMU_Reg->PMU_NOC_ST) & idle_req_bp2ap_rk319x) == 0);
-    */
-
-    pPMU_Reg->PMU_NOC_REQ |= idle_req_dma_cfg_rk319x;
-    dsb();
-    while(((pPMU_Reg->PMU_NOC_ST) & idle_req_dma_cfg_rk319x) == 0);
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_peri_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ |= idle_req_peri_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_peri_rk319x) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_vio_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ |= idle_req_vio_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_vio_rk319x) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_video_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ |= idle_req_video_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_video_rk319x) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_gpu_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ |= idle_req_gpu_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_gpu_rk319x) == 0 );
-    }
-
-    //resume clock gate status
-    for(i=0;i<16;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-}
-
-static void __sramfunc deidle_port(void)
-{
-    int i;
-    uint32 clk_gate[16];
-
-    //save clock gate status
-    for(i=0;i<16;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<16;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    /*
-    pPMU_Reg->PMU_NOC_REQ &= ~idle_req_bp2ap_rk319x;
-    dsb();
-    while( (pPMU_Reg->PMU_NOC_ST & idle_bp2ap_rk319x) != 0 );
-    */
-    
-    pPMU_Reg->PMU_NOC_REQ &= ~idle_req_dma_cfg_rk319x;
-    dsb();
-    while( (pPMU_Reg->PMU_NOC_ST & idle_dma_rk319x) != 0 );
-    
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_peri_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ &= ~idle_req_peri_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_peri_rk319x) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_vio_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ &= ~idle_req_vio_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_vio_rk319x) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_video_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ &= ~idle_req_video_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_video_rk319x) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_gpu_pwr_st_rk319x) == 0 )
-    {
-        pPMU_Reg->PMU_NOC_REQ &= ~idle_req_gpu_cfg_rk319x;
-        dsb();
-        while( (pPMU_Reg->PMU_NOC_ST & idle_gpu_rk319x) != 0 );
-    }
-
-    //resume clock gate status
-    for(i=0;i<16;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-
-}
-#else
-static void __sramfunc idle_port(void)
-{
-    int i;
-    uint32 clk_gate[10];
-
-    //save clock gate status
-    for(i=0;i<10;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_a9_0_pwr_st) == 0 )
-    {
-#ifdef CONFIG_ARCH_RK3188
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_dma_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_dma) == 0 );
-#else
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_cpu_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_cpu) == 0 );
-#endif
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_peri_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_peri_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_peri) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_vio_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_vio_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_vio) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_video_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_video_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_video) == 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_gpu_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 |= idle_req_gpu_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_gpu) == 0 );
-    }
-
-    //resume clock gate status
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-}
-
-static void __sramfunc deidle_port(void)
-{
-    int i;
-    uint32 clk_gate[10];
-
-    //save clock gate status
-    for(i=0;i<10;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_a9_0_pwr_st) == 0 )
-    {
-
-#ifdef CONFIG_ARCH_RK3188
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_dma_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_dma) != 0 );
-#else
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_cpu_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_cpu) != 0 );
-#endif
-    }
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_peri_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_peri_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_peri) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_vio_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_vio_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_vio) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_video_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_video_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_video) != 0 );
-    }
-
-    if ( (pPMU_Reg->PMU_PWRDN_ST & pd_gpu_pwr_st) == 0 )
-    {
-        pPMU_Reg->PMU_MISC_CON1 &= ~idle_req_gpu_cfg;
-        dsb();
-        while( (pPMU_Reg->PMU_PWRDN_ST & idle_gpu) != 0 );
-    }
-
-    //resume clock gate status
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-
-}
-#endif
-
-/***********************************
- * Only DDR Relative Function
- ***********************************/
-
-/****************************************************************************
-Internal sram us delay function
-Cpu highest frequency is 1.6 GHz
-1 cycle = 1/1.6 ns
-1 us = 1000 ns = 1000 * 1.6 cycles = 1600 cycles
-*****************************************************************************/
-static __sramdata volatile uint32_t loops_per_us;
-
-#define LPJ_100MHZ  999456UL
-
-static void __sramfunc ddr_delayus(uint32_t us)
-{
-    do
-    {
-        unsigned int i = (loops_per_us*us);
-        if (i < 7) i = 7;
-        barrier();
-        asm volatile(".align 4; 1: subs %0, %0, #1; bne 1b;" : "+r" (i));
-    } while (0);
-}
-
-static __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-{
-    uint32 i;
-
-    for(i=0; i<words; i++)
-    {
-        pDest[i] = pSrc[i];
-    }
-}
-
-static uint32 ddr_get_row(void)
-{
-    uint32 i;
-    uint32 row;
-
-    if(DDR_SYS_REG())
-    {
-        row=READ_CS0_ROW_INFO();
-    }
-    else
-    {
-        i = *(volatile uint32*)SysSrv_DdrConf;
-        row = 13+((ddr_cfg_2_rbc[i]>>4)&0x3);
-        if(DDR_GET_RANK_2_ROW15())
-        {
-            row += 1;
-        }
-    }
-    return row;
-}
-
-static uint32 ddr_get_bank(void)
-{
-    uint32 i;
-    uint32 bank;
-
-    if(DDR_SYS_REG())
-    {
-        bank = READ_BK_INFO();
-    }
-    else
-    {
-        i = *(volatile uint32*)SysSrv_DdrConf;
-        bank = ((ddr_cfg_2_rbc[i]>>6)&0x3) + ((ddr_cfg_2_rbc[i]>>2)&0x3);
-        if(DDR_GET_BANK_2_RANK())
-        {
-            bank -= 1;
-        }
-    }
-    return bank;
-}
-
-static uint32 ddr_get_col(void)
-{
-    uint32 i;
-    uint32 col;
-
-    if(DDR_SYS_REG())
-    {
-        col=READ_COL_INFO();
-    }
-    else
-    {
-        i = *(volatile uint32*)SysSrv_DdrConf;
-        col = 9+(ddr_cfg_2_rbc[i]&0x3);
-        if(pDDR_Reg->PPCFG & 1)
-        {
-            col +=1;
-        }
-    }
-    return col;
-}
-
-static uint32 ddr_get_bw(void)
-{
-    uint32 bw;
-
-    if(pDDR_Reg->PPCFG & 1)
-    {
-        bw=1;
-    }
-    else
-    {
-        bw=2;
-    }
-    return bw;
-}
-
-static uint32 ddr_get_cs(void)
-{
-    uint32 cs;
-
-    switch((pPHY_Reg->PGCR>>18) & 0xF)
-    {
-        case 0xF:
-            cs = 4;
-        case 7:
-            cs = 3;
-            break;
-        case 3:
-            cs = 2;
-            break;
-        default:
-            cs = 1;
-            break;
-    }
-    return cs;
-}
-
-static uint32_t ddr_get_datatraing_addr(void)
-{
-    uint32_t          value=0;
-    uint32_t          addr;
-    uint32_t          col = 0;
-    uint32_t          row = 0;
-    uint32_t          bank = 0;
-    uint32_t          bw = 0;
-    uint32_t          i;
-
-    // caculate aglined physical address
-    addr =  __pa((unsigned long)ddr_data_training_buf);
-    if(addr&0x3F)
-    {
-        addr += (64-(addr&0x3F));
-    }
-    addr -= 0x60000000;
-    // find out colrowbank
-    row = ddr_get_row();
-    bank = ddr_get_bank();
-    col = ddr_get_col();
-    bw = ddr_get_bw();
-    // according different address mapping, caculate DTAR register value
-    i = (*(volatile uint32*)SysSrv_DdrConf);
-    value |= (addr>>bw) & ((0x1<<col)-1);  // col
-    if(row==16)
-    {
-        value |= ((addr>>(bw+col+((ddr_cfg_2_rbc[i]>>2)&0x3))) & 0x7FFF) << 12;  // row
-        value |= (((addr>>(bw+col+bank+15))&0x1)<<15)<<12;
-        row = 15;  //use for bank
-    }
-    else
-    {
-        value |= ((addr>>(bw+col+((ddr_cfg_2_rbc[i]>>2)&0x3))) & ((0x1<<row)-1)) << 12;  // row
-    }
-    if(((ddr_cfg_2_rbc[i]>>6)&0x3)==1)
-    {
-        value |= (((addr>>(bw+col)) & 0x3) << 28)
-                 | (((addr>>(bw+col+2+row)) & (bank-2))  << 30);  // bank
-    }
-    else if(((ddr_cfg_2_rbc[i]>>6)&0x3)==3)
-    {
-        value |= (((addr>>(bw+col+row)) & ((0x1<<bank)-1))  << 28);  // bank
-    }
-    else
-    {
-        value |= (((addr>>(bw+col)) & 0x7) << 28);  // bank
-    }
-
-    return value;
-}
-
-static __sramfunc void ddr_reset_dll(void)
-{
-    pPHY_Reg->ACDLLCR &= ~0x40000000;
-    pPHY_Reg->DATX8[0].DXDLLCR &= ~0x40000000;
-    pPHY_Reg->DATX8[1].DXDLLCR &= ~0x40000000;
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        pPHY_Reg->DATX8[2].DXDLLCR &= ~0x40000000;
-        pPHY_Reg->DATX8[3].DXDLLCR &= ~0x40000000;
-    }
-    ddr_delayus(1);
-    pPHY_Reg->ACDLLCR |= 0x40000000;
-    pPHY_Reg->DATX8[0].DXDLLCR |= 0x40000000;
-    pPHY_Reg->DATX8[1].DXDLLCR |= 0x40000000;
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x40000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x40000000;
-    }
-    ddr_delayus(1);
-}
-
-static __sramfunc void ddr_move_to_Lowpower_state(void)
-{
-    volatile uint32 value;
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Low_power)
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-            case Access:
-                pDDR_Reg->SCTL = SLEEP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Low_power);
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-static __sramfunc void ddr_move_to_Access_state(void)
-{
-    volatile uint32 value;
-
-    //set auto self-refresh idle
-    pDDR_Reg->MCFG1=(pDDR_Reg->MCFG1&0xffffff00) | DATA(ddr_sr_idle) | (1<<31);
-    dsb();
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if((value == Access)
-           || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power)))
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-                while((pPHY_Reg->PGSR & DLDONE) != DLDONE);  //wait DLL lock
-                break;
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while(!(((pDDR_Reg->STAT.b.ctl_stat) == Access)
-                      || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power))));
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-    /* de_hw_wakeup :enable auto sr if sr_idle != 0 */
-    DDR_HW_WAKEUP(0);
-}
-
-static __sramfunc void ddr_move_to_Config_state(void)
-{
-    volatile uint32 value;
-
-    /* hw_wakeup :disable auto sr */
-    DDR_HW_WAKEUP(1);
-	dsb();
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Config)
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-                while((pPHY_Reg->PGSR & DLDONE) != DLDONE);  //wait DLL lock
-            case Access:
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-//argbank_addrcmd_addr
-static void __sramfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-{
-    pDDR_Reg->MCMD = (start_cmd | (rank<<20) | arg | cmd);
-    dsb();
-    while(pDDR_Reg->MCMD & start_cmd);
-}
-
-//typeDDRcsDTT
-//0  DTT
-//!0 DTT
-static uint32_t __sramfunc ddr_data_training(void)
-{
-    uint32 value,cs,i,byte=2;
-
-    // disable auto refresh
-    value = pDDR_Reg->TREFI;
-    pDDR_Reg->TREFI = 0;
-    dsb();
-    if(DATA(mem_type) != LPDDR2)
-    {
-        // passive window
-        pPHY_Reg->PGCR |= (1<<1);
-    }
-    // clear DTDONE status
-    pPHY_Reg->PIR |= CLRSR;
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    pPHY_Reg->PGCR = (pPHY_Reg->PGCR & (~(0xF<<18))) | (1<<18);  //use cs0 dtt
-    // trigger DTT
-    pPHY_Reg->PIR |= INIT | QSTRN | LOCKBYP | ZCALBYP | CLRSR | ICPC;
-    dsb();
-    // wait echo byte DTDONE
-    while((pPHY_Reg->DATX8[0].DXGSR[0] & 1) != 1);
-    while((pPHY_Reg->DATX8[1].DXGSR[0] & 1) != 1);
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        while((pPHY_Reg->DATX8[2].DXGSR[0] & 1) != 1);
-        while((pPHY_Reg->DATX8[3].DXGSR[0] & 1) != 1);
-        byte=4;
-    }
-    pPHY_Reg->PGCR = (pPHY_Reg->PGCR & (~(0xF<<18))) | (cs<<18);  //restore cs
-    for(i=0;i<byte;i++)
-    {
-        pPHY_Reg->DATX8[i].DXDQSTR = (pPHY_Reg->DATX8[i].DXDQSTR & (~((0x7<<3)|(0x3<<14))))
-                                      | ((pPHY_Reg->DATX8[i].DXDQSTR & 0x7)<<3)
-                                      | (((pPHY_Reg->DATX8[i].DXDQSTR>>12) & 0x3)<<14);
-    }
-    // send some auto refresh to complement the lost while DTT//1CSDTT10.7us2
-    if(cs > 1)
-    {
-        ddr_send_command(cs, REF_cmd, 0);
-        ddr_send_command(cs, REF_cmd, 0);
-        ddr_send_command(cs, REF_cmd, 0);
-        ddr_send_command(cs, REF_cmd, 0);
-    }
-    else
-    {
-        ddr_send_command(cs, REF_cmd, 0);
-        ddr_send_command(cs, REF_cmd, 0);
-    }
-    if(DATA(mem_type) != LPDDR2)
-    {
-        // active window
-        pPHY_Reg->PGCR &= ~(1<<1);
-    }
-    // resume auto refresh
-    pDDR_Reg->TREFI = value;
-
-    if(pPHY_Reg->PGSR & DTERR)
-    {
-        return (-1);
-    }
-    else
-    {
-        return 0;
-    }
-}
-
-static void __sramfunc ddr_set_dll_bypass(uint32 freq)
-{
-    if(freq<=150)
-    {
-        pPHY_Reg->DLLGCR &= ~(1<<23);
-        pPHY_Reg->ACDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-        pPHY_Reg->PIR |= DLLBYP;
-    }
-    else if(freq<=250)
-    {
-        pPHY_Reg->DLLGCR |= (1<<23);
-        pPHY_Reg->ACDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-        pPHY_Reg->PIR |= DLLBYP;
-    }
-    else
-    {
-        pPHY_Reg->DLLGCR &= ~(1<<23);
-        pPHY_Reg->ACDLLCR &= ~0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR &= ~0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR &= ~0x80000000;
-        if(!(pDDR_Reg->PPCFG & 1))
-        {
-            pPHY_Reg->DATX8[2].DXDLLCR &= ~0x80000000;
-            pPHY_Reg->DATX8[3].DXDLLCR &= ~0x80000000;
-        }
-        pPHY_Reg->PIR &= ~DLLBYP;
-    }
-}
-
-static noinline uint32_t ddr_get_parameter(uint32_t nMHz)
-{
-    uint32_t tmp;
-    uint32_t ret = 0;
-    uint32_t al;
-    uint32_t bl,bl_tmp;
-    uint32_t cl;
-    uint32_t cwl;
-    PCTL_TIMING_T *p_pctl_timing=&(p_ddr_reg->pctl.pctl_timing);
-    PHY_TIMING_T  *p_publ_timing=&(p_ddr_reg->publ.phy_timing);
-    NOC_TIMING_T  *p_noc_timing=&(p_ddr_reg->noc_timing);
-
-    p_pctl_timing->togcnt1u = nMHz;
-    p_pctl_timing->togcnt100n = nMHz/10;
-    p_pctl_timing->tinit = 200;
-    p_pctl_timing->trsth = 500;
-
-    if(*p_mem_type == DDR3)
-    {
-        if(ddr_speed_bin > DDR3_DEFAULT){
-            ret = -1;
-            goto out;
-        }
-
-        #define DDR3_tREFI_7_8_us    (78)  //unit 100ns
-        #define DDR3_tMRD            (4)   //tCK
-        #define DDR3_tRFC_512Mb      (90)  //ns
-        #define DDR3_tRFC_1Gb        (110) //ns
-        #define DDR3_tRFC_2Gb        (160) //ns
-        #define DDR3_tRFC_4Gb        (300) //ns
-        #define DDR3_tRFC_8Gb        (350) //ns
-        #define DDR3_tRTW            (2)   //register min valid value
-        #define DDR3_tRAS            (37)  //ns
-        #define DDR3_tRRD            (10)  //ns
-        #define DDR3_tRTP            (7)   //ns
-        #define DDR3_tWR             (15)  //ns
-        #define DDR3_tWTR            (7)   //ns
-        #define DDR3_tXP             (7)   //ns
-        #define DDR3_tXPDLL          (24)  //ns
-        #define DDR3_tZQCS           (80)  //ns
-        #define DDR3_tZQCSI          (0)   //ns
-        #define DDR3_tDQS            (1)   //tCK
-        #define DDR3_tCKSRE          (10)  //ns
-        #define DDR3_tCKE_400MHz     (7)   //ns
-        #define DDR3_tCKE_533MHz     (6)   //ns
-        #define DDR3_tMOD            (15)  //ns
-        #define DDR3_tRSTL           (100) //ns
-        #define DDR3_tZQCL           (320) //ns
-        #define DDR3_tDLLK           (512) //tCK
-
-        al = 0;
-        bl = 8;
-        if(nMHz <= 330)
-        {
-            tmp = 0;
-        }
-        else if(nMHz<=400)
-        {
-            tmp = 1;
-        }
-        else if(nMHz<=533)
-        {
-            tmp = 2;
-        }
-        else if(nMHz<=666)
-        {
-            tmp = 3;
-        }
-        else if(nMHz<=800)
-        {
-            tmp = 4;
-        }
-        else if(nMHz<=933)
-        {
-            tmp = 5;
-        }
-        else
-        {
-            tmp = 6;
-        }
-        
-        if(nMHz < DDR3_DDR2_DLL_DISABLE_FREQ)       //when dll bypss cl = cwl = 6;
-        {
-            cl = 6;
-            cwl = 6;
-        }
-        else
-        {
-            cl = (ddr3_cl_cwl[ddr_speed_bin][tmp] >> 4)&0xf;
-            cwl = ddr3_cl_cwl[ddr_speed_bin][tmp] & 0xf;
-        }
-        if(cl == 0)
-            ret = -4;
-        if(nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ)
-        {
-            p_publ_timing->mr[1] = DDR3_DS_40 | DDR3_Rtt_Nom_DIS;
-        }
-        else
-        {
-            p_publ_timing->mr[1] = DDR3_DS_40 | DDR3_Rtt_Nom_120;
-        }
-        p_publ_timing->mr[2] = DDR3_MR2_CWL(cwl) /* | DDR3_Rtt_WR_60 */;
-        p_publ_timing->mr[3] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 7.8us
-         */
-        p_pctl_timing->trefi = DDR3_tREFI_7_8_us;
-        /*
-         * tMRD, 4 tCK
-         */
-        p_pctl_timing->tmrd = DDR3_tMRD & 0x7;
-        p_publ_timing->dtpr0.b.tMRD = DDR3_tMRD-4;
-        /*
-         * tRFC, 90ns(512Mb),110ns(1Gb),160ns(2Gb),300ns(4Gb),350ns(8Gb)
-         */
-        if(ddr_capability_per_die <= 0x4000000)         // 512Mb 90ns
-        {
-            tmp = DDR3_tRFC_512Mb;
-        }
-        else if(ddr_capability_per_die <= 0x8000000)    // 1Gb 110ns
-        {
-            tmp = DDR3_tRFC_1Gb;
-        }
-        else if(ddr_capability_per_die <= 0x10000000)   // 2Gb 160ns
-        {
-            tmp = DDR3_tRFC_2Gb;
-        }
-        else if(ddr_capability_per_die <= 0x20000000)   // 4Gb 300ns
-        {
-            tmp = DDR3_tRFC_4Gb;
-        }
-        else    // 8Gb  350ns
-        {
-            tmp = DDR3_tRFC_8Gb;
-        }
-        p_pctl_timing->trfc = (tmp*nMHz+999)/1000;
-        p_publ_timing->dtpr1.b.tRFC = ((tmp*nMHz+999)/1000)&0xFF;
-        /*
-         * tXSR, =tDLLK=512 tCK
-         */
-        p_pctl_timing->texsr = DDR3_tDLLK;
-        p_publ_timing->dtpr2.b.tXS = DDR3_tDLLK;
-        /*
-         * tRP=CL
-         */
-        p_pctl_timing->trp = cl;
-        p_publ_timing->dtpr0.b.tRP = cl;
-        /*
-         * WrToMiss=WL*tCK + tWR + tRP + tRCD
-         */
-        p_noc_timing->b.WrToMiss = ((cwl+((DDR3_tWR*nMHz+999)/1000)+cl+cl)&0x3F);
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000)&0x3F);
-        p_noc_timing->b.ActToAct = ((((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000)&0x3F);
-        p_publ_timing->dtpr0.b.tRC = (((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000)&0xF;
-
-        p_pctl_timing->trtw = (cl+2-cwl);//DDR3_tRTW;
-        p_publ_timing->dtpr1.b.tRTW = 0;
-        p_noc_timing->b.RdToWr = ((cl+2-cwl)&0x1F);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRAS, 37.5ns(400MHz)     37.5ns(533MHz)
-         */
-        p_pctl_timing->tras = (((DDR3_tRAS*nMHz+(nMHz>>1)+999)/1000)&0x3F);
-        p_publ_timing->dtpr0.b.tRAS = ((DDR3_tRAS*nMHz+(nMHz>>1)+999)/1000)&0x1F;
-        /*
-         * tRCD=CL
-         */
-        p_pctl_timing->trcd = cl;
-        p_publ_timing->dtpr0.b.tRCD = cl;
-        /*
-         * tRRD = max(4nCK, 7.5ns), DDR3-1066(1K), DDR3-1333(2K), DDR3-1600(2K)
-         *        max(4nCK, 10ns), DDR3-800(1K,2K), DDR3-1066(2K)
-         *        max(4nCK, 6ns), DDR3-1333(1K), DDR3-1600(1K)
-         *
-         */
-        tmp = ((DDR3_tRRD*nMHz+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        p_publ_timing->dtpr0.b.tRRD = tmp&0xF;
-        /*
-         * tRTP, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trtp = tmp&0xF;
-        p_publ_timing->dtpr0.b.tRTP = tmp;
-        /*
-         * RdToMiss=tRTP+tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = ((tmp+cl+cl-(bl>>1))&0x3F);
-        /*
-         * tWR, 15ns
-         */
-        tmp = ((DDR3_tWR*nMHz+999)/1000);
-        p_pctl_timing->twr = tmp&0x1F;
-        if(tmp<9)
-            tmp = tmp - 4;
-        else
-            tmp = tmp>>1;
-        bl_tmp = (bl == 8) ? DDR3_BL8 : DDR3_BC4;
-        p_publ_timing->mr[0] = bl_tmp | DDR3_CL(cl) | DDR3_WR(tmp);
-
-        /*
-         * tWTR, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tWTR*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_publ_timing->dtpr0.b.tWTR = tmp&0x7;
-        p_noc_timing->b.WrToRd = ((tmp+cwl)&0x1F);
-        /*
-         * tXP, max(3 tCK, 7.5ns)(<933MHz)
-         */
-        tmp = ((DDR3_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        /*
-         * tXPDLL, max(10 tCK,24ns)
-         */
-        tmp = ((DDR3_tXPDLL*nMHz+999)/1000);
-        if(tmp < 10)
-        {
-            tmp = 10;
-        }
-        p_pctl_timing->txpdll = tmp & 0x3F;
-        p_publ_timing->dtpr2.b.tXP = tmp&0x1F;
-        /*
-         * tZQCS, max(64 tCK, 80ns)
-         */
-        tmp = ((DDR3_tZQCS*nMHz+999)/1000);
-        if(tmp < 64)
-        {
-            tmp = 64;
-        }
-        p_pctl_timing->tzqcs = tmp&0x7F;
-        /*
-         * tZQCSI,
-         */
-        p_pctl_timing->tzqcsi = DDR3_tZQCSI;
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = DDR3_tDQS;
-        /*
-         * tCKSRE, max(5 tCK, 10ns)
-         */
-        tmp = ((DDR3_tCKSRE*nMHz+999)/1000);
-        if(tmp < 5)
-        {
-            tmp = 5;
-        }
-        p_pctl_timing->tcksre = tmp & 0x1F;
-        /*
-         * tCKSRX, max(5 tCK, 10ns)
-         */
-        p_pctl_timing->tcksrx = tmp & 0x1F;
-        /*
-         * tCKE, max(3 tCK,7.5ns)(400MHz) max(3 tCK,5.625ns)(533MHz)
-         */
-        if(nMHz>=533)
-        {
-            tmp = ((DDR3_tCKE_533MHz*nMHz+999)/1000);
-        }
-        else
-        {
-            tmp = ((DDR3_tCKE_400MHz*nMHz+(nMHz>>1)+999)/1000);
-        }
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tcke = tmp & 0x7;
-        p_publ_timing->dtpr2.b.tCKE = tmp;
-        /*
-         * tCKESR, =tCKE + 1tCK
-         */
-        p_pctl_timing->tckesr = (tmp+1)&0xF;
-        /*
-         * tMOD, max(12 tCK,15ns)
-         */
-        tmp = ((DDR3_tMOD*nMHz+999)/1000);
-        if(tmp < 12)
-        {
-            tmp = 12;
-        }
-        p_pctl_timing->tmod = tmp&0x1F;
-        p_publ_timing->dtpr1.b.tMOD = tmp;
-        /*
-         * tRSTL, 100ns
-         */
-        p_pctl_timing->trstl = ((DDR3_tRSTL*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCL, max(256 tCK, 320ns)
-         */
-        tmp = ((DDR3_tZQCL*nMHz+999)/1000);
-        if(tmp < 256)
-        {
-            tmp = 256;
-        }
-        p_pctl_timing->tzqcl = tmp&0x3FF;
-        /*
-         * tMRR, 0 tCK
-         */
-        p_pctl_timing->tmrr = 0;
-        /*
-         * tDPD, 0
-         */
-        p_pctl_timing->tdpd = 0;
-
-        /**************************************************
-         * PHY Timing
-         **************************************************/
-        /*
-         * tCCD, BL/2 for DDR2 and 4 for DDR3
-         */
-        p_publ_timing->dtpr0.b.tCCD = 0;
-        /*
-         * tDQSCKmax,5.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCKmax = 0;
-        /*
-         * tRTODT, 0:ODT may be turned on immediately after read post-amble
-         *         1:ODT may not be turned on until one clock after the read post-amble
-         */
-        p_publ_timing->dtpr1.b.tRTODT = 1;
-        /*
-         * tFAW,40ns(400MHz 1KB page) 37.5ns(533MHz 1KB page) 50ns(400MHz 2KB page)   50ns(533MHz 2KB page)
-         */
-        p_publ_timing->dtpr1.b.tFAW = (((ddr3_tRC_tFAW[ddr_speed_bin]&0x0ff)*nMHz+999)/1000)&0x7F;
-        /*
-         * tAOND_tAOFD
-         */
-        p_publ_timing->dtpr1.b.tAOND = 0;
-        /*
-         * tDLLK,512 tCK
-         */
-        p_publ_timing->dtpr2.b.tDLLK = DDR3_tDLLK;
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = ((bl>>1)&0x7);
-    }
-    else if(*p_mem_type == LPDDR2)
-    {
-        #define LPDDR2_tREFI_3_9_us    (38)  //unit 100ns
-        #define LPDDR2_tREFI_7_8_us    (78)  //unit 100ns
-        #define LPDDR2_tMRD            (5)   //tCK
-        #define LPDDR2_tRFC_8Gb        (210)  //ns
-        #define LPDDR2_tRFC_4Gb        (130)  //ns
-        #define LPDDR2_tRP_4_BANK               (24)  //ns
-        #define LPDDR2_tRPab_SUB_tRPpb_4_BANK   (0)
-        #define LPDDR2_tRP_8_BANK               (27)  //ns
-        #define LPDDR2_tRPab_SUB_tRPpb_8_BANK   (3)
-        #define LPDDR2_tRTW          (1)   //tCK register min valid value
-        #define LPDDR2_tRAS          (42)  //ns
-        #define LPDDR2_tRCD          (24)  //ns
-        #define LPDDR2_tRRD          (10)  //ns
-        #define LPDDR2_tRTP          (7)   //ns
-        #define LPDDR2_tWR           (15)  //ns
-        #define LPDDR2_tWTR_GREAT_200MHz         (7)  //ns
-        #define LPDDR2_tWTR_LITTLE_200MHz        (10) //ns
-        #define LPDDR2_tXP           (7)  //ns
-        #define LPDDR2_tXPDLL        (0)
-        #define LPDDR2_tZQCS         (90) //ns
-        #define LPDDR2_tZQCSI        (0)
-        #define LPDDR2_tDQS          (1)
-        #define LPDDR2_tCKSRE        (1)  //tCK
-        #define LPDDR2_tCKSRX        (2)  //tCK
-        #define LPDDR2_tCKE          (3)  //tCK
-        #define LPDDR2_tMOD          (0)
-        #define LPDDR2_tRSTL         (0)
-        #define LPDDR2_tZQCL         (360)  //ns
-        #define LPDDR2_tMRR          (2)    //tCK
-        #define LPDDR2_tCKESR        (15)   //ns
-        #define LPDDR2_tDPD_US       (500)
-        #define LPDDR2_tFAW_GREAT_200MHz    (50)  //ns
-        #define LPDDR2_tFAW_LITTLE_200MHz   (60)  //ns
-        #define LPDDR2_tDLLK         (2)  //tCK
-        #define LPDDR2_tDQSCK_MAX    (3)  //tCK
-        #define LPDDR2_tDQSCK_MIN    (0)  //tCK
-        #define LPDDR2_tDQSS         (1)  //tCK
-
-        uint32 trp_tmp;
-        uint32 trcd_tmp;
-        uint32 tras_tmp;
-        uint32 trtp_tmp;
-        uint32 twr_tmp;
-
-        al = 0;
-        if(nMHz>=200)
-        {
-            bl = 4;  //you can change burst here
-        }
-        else
-        {
-            bl = 8;  // freq < 200MHz, BL fixed 8
-        }
-        /*     1066 933 800 667 533 400 333
-         * RL,   8   7   6   5   4   3   3
-         * WL,   4   4   3   2   2   1   1
-         */
-        if(nMHz<=200)
-        {
-            cl = 3;
-            cwl = 1;
-            p_publ_timing->mr[2] = LPDDR2_RL3_WL1;
-        }
-        else if(nMHz<=266)
-        {
-            cl = 4;
-            cwl = 2;
-            p_publ_timing->mr[2] = LPDDR2_RL4_WL2;
-        }
-        else if(nMHz<=333)
-        {
-            cl = 5;
-            cwl = 2;
-            p_publ_timing->mr[2] = LPDDR2_RL5_WL2;
-        }
-        else if(nMHz<=400)
-        {
-            cl = 6;
-            cwl = 3;
-            p_publ_timing->mr[2] = LPDDR2_RL6_WL3;
-        }
-        else if(nMHz<=466)
-        {
-            cl = 7;
-            cwl = 4;
-            p_publ_timing->mr[2] = LPDDR2_RL7_WL4;
-        }
-        else //(nMHz<=1066)
-        {
-            cl = 8;
-            cwl = 4;
-            p_publ_timing->mr[2] = LPDDR2_RL8_WL4;
-        }
-        p_publ_timing->mr[3] = LPDDR2_DS_34;
-        p_publ_timing->mr[0] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 15.6us(<256Mb) 7.8us(256Mb-1Gb) 3.9us(2Gb-8Gb)
-         */
-        if(ddr_capability_per_die >= 0x10000000)   // 2Gb
-        {
-            p_pctl_timing->trefi = LPDDR2_tREFI_3_9_us;
-        }
-        else
-        {
-            p_pctl_timing->trefi = LPDDR2_tREFI_7_8_us;
-        }
-
-        /*
-         * tMRD, (=tMRW), 5 tCK
-         */
-        p_pctl_timing->tmrd = LPDDR2_tMRD & 0x7;
-        p_publ_timing->dtpr0.b.tMRD = 3;
-        /*
-         * tRFC, 90ns(<=512Mb) 130ns(1Gb-4Gb) 210ns(8Gb)
-         */
-        if(ddr_capability_per_die >= 0x40000000)   // 8Gb
-        {
-            p_pctl_timing->trfc = (LPDDR2_tRFC_8Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR2_tRFC_8Gb*nMHz+999)/1000)&0xFF;
-            /*
-             * tXSR, max(2tCK,tRFC+10ns)
-             */
-            tmp=(((LPDDR2_tRFC_8Gb+10)*nMHz+999)/1000);
-        }
-        else
-        {
-            p_pctl_timing->trfc = (LPDDR2_tRFC_4Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR2_tRFC_4Gb*nMHz+999)/1000)&0xFF;
-            tmp=(((LPDDR2_tRFC_4Gb+10)*nMHz+999)/1000);
-        }
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->texsr = tmp&0x3FF;
-        p_publ_timing->dtpr2.b.tXS = tmp&0x3FF;
-
-        /*
-         * tRP, max(3tCK, 4-bank:15ns(Fast) 18ns(Typ) 24ns(Slow), 8-bank:18ns(Fast) 21ns(Typ) 27ns(Slow))
-         */
-        if(pPHY_Reg->DCR.b.DDR8BNK)
-        {
-            trp_tmp = ((LPDDR2_tRP_8_BANK*nMHz+999)/1000);
-            if(trp_tmp<3)
-            {
-                trp_tmp=3;
-            }
-            p_pctl_timing->trp = ((((LPDDR2_tRPab_SUB_tRPpb_8_BANK*nMHz+999)/1000) & 0x3)<<16) | (trp_tmp&0xF);
-        }
-        else
-        {
-            trp_tmp = ((LPDDR2_tRP_4_BANK*nMHz+999)/1000);
-            if(trp_tmp<3)
-            {
-                trp_tmp=3;
-            }
-            p_pctl_timing->trp = (LPDDR2_tRPab_SUB_tRPpb_4_BANK<<16) | (trp_tmp&0xF);
-        }
-        p_publ_timing->dtpr0.b.tRP = trp_tmp;
-        /*
-         * tRAS, max(3tCK,42ns)
-         */
-        tras_tmp=((LPDDR2_tRAS*nMHz+999)/1000);
-        if(tras_tmp<3)
-        {
-            tras_tmp=3;
-        }
-        p_pctl_timing->tras = (tras_tmp&0x3F);
-        p_publ_timing->dtpr0.b.tRAS = tras_tmp&0x1F;
-
-        /*
-         * tRCD, max(3tCK, 15ns(Fast) 18ns(Typ) 24ns(Slow))
-         */
-        trcd_tmp = ((LPDDR2_tRCD*nMHz+999)/1000);
-        if(trcd_tmp<3)
-        {
-            trcd_tmp=3;
-        }
-        p_pctl_timing->trcd = (trcd_tmp&0xF);
-        p_publ_timing->dtpr0.b.tRCD = trcd_tmp&0xF;
-
-        /*
-         * tRTP, max(2tCK, 7.5ns)
-         */
-        trtp_tmp = ((LPDDR2_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(trtp_tmp<2)
-        {
-            trtp_tmp = 2;
-        }
-        p_pctl_timing->trtp = trtp_tmp&0xF;
-        p_publ_timing->dtpr0.b.tRTP = trtp_tmp;
-
-        /*
-         * tWR, max(3tCK,15ns)
-         */
-        twr_tmp=((LPDDR2_tWR*nMHz+999)/1000);
-        if(twr_tmp<3)
-        {
-            twr_tmp=3;
-        }
-        p_pctl_timing->twr = twr_tmp&0x1F;
-        bl_tmp = (bl == 16) ? LPDDR2_BL16 : ((bl == 8) ? LPDDR2_BL8 : LPDDR2_BL4);
-        p_publ_timing->mr[1] = bl_tmp | LPDDR2_nWR(twr_tmp);
-
-        /*
-         * WrToMiss=WL*tCK + tDQSS + tWR + tRP + tRCD
-         */
-        p_noc_timing->b.WrToMiss = ((cwl+LPDDR2_tDQSS+twr_tmp+trp_tmp+trcd_tmp)&0x3F);
-        /*
-         * RdToMiss=tRTP + tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = ((trtp_tmp+trp_tmp+trcd_tmp-(bl>>1))&0x3F);
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((tras_tmp+trp_tmp)&0x3F);
-        p_noc_timing->b.ActToAct = ((tras_tmp+trp_tmp)&0x3F);
-        p_publ_timing->dtpr0.b.tRC = (tras_tmp+trp_tmp)&0xF;
-
-        /*
-         * RdToWr=RL+tDQSCK-WL
-         */
-        p_pctl_timing->trtw = (cl+LPDDR2_tDQSCK_MAX+(bl/2)+1-cwl);//LPDDR2_tRTW;
-        p_publ_timing->dtpr1.b.tRTW = 0;
-        p_noc_timing->b.RdToWr = ((cl+LPDDR2_tDQSCK_MAX+1-cwl)&0x1F);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRRD, max(2tCK,10ns)
-         */
-        tmp=((LPDDR2_tRRD*nMHz+999)/1000);
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        p_publ_timing->dtpr0.b.tRRD = tmp&0xF;
-        /*
-         * tWTR, max(2tCK, 7.5ns(533-266MHz)  10ns(200-166MHz))
-         */
-        if(nMHz > 200)
-        {
-            tmp=((LPDDR2_tWTR_GREAT_200MHz*nMHz+(nMHz>>1)+999)/1000);
-        }
-        else
-        {
-            tmp=((LPDDR2_tWTR_LITTLE_200MHz*nMHz+999)/1000);
-        }
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_publ_timing->dtpr0.b.tWTR = tmp&0x7;
-        /*
-         * WrToRd=WL+tDQSS+tWTR
-         */
-        p_noc_timing->b.WrToRd = ((cwl+LPDDR2_tDQSS+tmp)&0x1F);
-        /*
-         * tXP, max(2tCK,7.5ns)
-         */
-        tmp=((LPDDR2_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        p_publ_timing->dtpr2.b.tXP = tmp&0x1F;
-        /*
-         * tXPDLL, 0ns
-         */
-        p_pctl_timing->txpdll = LPDDR2_tXPDLL;
-        /*
-         * tZQCS, 90ns
-         */
-        p_pctl_timing->tzqcs = ((LPDDR2_tZQCS*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCSI,
-         */
-        if(pDDR_Reg->MCFG &= lpddr2_s4)
-        {
-            p_pctl_timing->tzqcsi = LPDDR2_tZQCSI;
-        }
-        else
-        {
-            p_pctl_timing->tzqcsi = 0;
-        }
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = LPDDR2_tDQS;
-        /*
-         * tCKSRE, 1 tCK
-         */
-        p_pctl_timing->tcksre = LPDDR2_tCKSRE;
-        /*
-         * tCKSRX, 2 tCK
-         */
-        p_pctl_timing->tcksrx = LPDDR2_tCKSRX;
-        /*
-         * tCKE, 3 tCK
-         */
-        p_pctl_timing->tcke = LPDDR2_tCKE;
-        p_publ_timing->dtpr2.b.tCKE = LPDDR2_tCKE;
-        /*
-         * tMOD, 0 tCK
-         */
-        p_pctl_timing->tmod = LPDDR2_tMOD;
-        p_publ_timing->dtpr1.b.tMOD = LPDDR2_tMOD;
-        /*
-         * tRSTL, 0 tCK
-         */
-        p_pctl_timing->trstl = LPDDR2_tRSTL;
-        /*
-         * tZQCL, 360ns
-         */
-        p_pctl_timing->tzqcl = ((LPDDR2_tZQCL*nMHz+999)/1000)&0x3FF;
-        /*
-         * tMRR, 2 tCK
-         */
-        p_pctl_timing->tmrr = LPDDR2_tMRR;
-        /*
-         * tCKESR, max(3tCK,15ns)
-         */
-        tmp = ((LPDDR2_tCKESR*nMHz+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tckesr = tmp&0xF;
-        /*
-         * tDPD, 500us
-         */
-        p_pctl_timing->tdpd = LPDDR2_tDPD_US;
-
-        /**************************************************
-         * PHY Timing
-         **************************************************/
-        /*
-         * tCCD, BL/2 for DDR2 and 4 for DDR3
-         */
-        p_publ_timing->dtpr0.b.tCCD = 0;
-        /*
-         * tDQSCKmax,5.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCKmax = LPDDR2_tDQSCK_MAX;
-        /*
-         * tDQSCKmin,2.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCK = LPDDR2_tDQSCK_MIN;
-        /*
-         * tRTODT, 0:ODT may be turned on immediately after read post-amble
-         *         1:ODT may not be turned on until one clock after the read post-amble
-         */
-        p_publ_timing->dtpr1.b.tRTODT = 1;
-        /*
-         * tFAW,max(8tCK, 50ns(200-533MHz)  60ns(166MHz))
-         */
-        if(nMHz>=200)
-        {
-            tmp=((LPDDR2_tFAW_GREAT_200MHz*nMHz+999)/1000);
-        }
-        else
-        {
-            tmp=((LPDDR2_tFAW_LITTLE_200MHz*nMHz+999)/1000);
-        }
-        if(tmp<8)
-        {
-            tmp=8;
-        }
-        p_publ_timing->dtpr1.b.tFAW = tmp&0x7F;
-        /*
-         * tAOND_tAOFD
-         */
-        p_publ_timing->dtpr1.b.tAOND = 0;
-        /*
-         * tDLLK,0
-         */
-        p_publ_timing->dtpr2.b.tDLLK = LPDDR2_tDLLK;
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = ((bl>>1)&0x7);
-    }
-
-out:
-    return ret;
-}
-
-static uint32_t __sramfunc ddr_update_timing(void)
-{
-    uint32_t i,bl_tmp=0;
-    PCTL_TIMING_T *p_pctl_timing=&(DATA(ddr_reg).pctl.pctl_timing);
-    PHY_TIMING_T  *p_publ_timing=&(DATA(ddr_reg).publ.phy_timing);
-    NOC_TIMING_T  *p_noc_timing=&(DATA(ddr_reg).noc_timing);
-
-    ddr_copy((uint32_t *)&(pDDR_Reg->TOGCNT1U), (uint32_t*)&(p_pctl_timing->togcnt1u), 34);
-    ddr_copy((uint32_t *)&(pPHY_Reg->DTPR[0]), (uint32_t*)&(p_publ_timing->dtpr0), 3);
-    *(volatile uint32_t *)SysSrv_DdrTiming = p_noc_timing->d32;
-    // Update PCTL BL
-    if(DATA(mem_type) == DDR3)
-    {
-        bl_tmp = ((p_publ_timing->mr[0] & 0x3) == DDR3_BL8) ? ddr2_ddr3_bl_8 : ddr2_ddr3_bl_4;
-        pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~(0x1|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | bl_tmp | tfaw_cfg(5)|pd_exit_slow|pd_type(1);
-        if((DATA(ddr_freq) <= DDR3_DDR2_DLL_DISABLE_FREQ) && (true == DATA(ddr_soc_is_rk3188_plus)))
-        {
-            pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-3;
-        }
-        else
-        {
-            pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-2;
-        }
-        pDDR_Reg->DFITPHYWRLAT   = pDDR_Reg->TCWL-1;
-    }
-    else if(DATA(mem_type) == LPDDR2)
-    {
-        if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL8)
-        {
-            bl_tmp = mddr_lpddr2_bl_8;
-        }
-        else if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL4)
-        {
-            bl_tmp = mddr_lpddr2_bl_4;
-        }
-        else //if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL16)
-        {
-            bl_tmp = mddr_lpddr2_bl_16;
-        }
-        if(DATA(ddr_freq)>=200)
-        {
-            pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~((0x3<<20)|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | bl_tmp | tfaw_cfg(5)|pd_exit_fast|pd_type(1);
-        }
-        else
-        {
-            pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~((0x3<<20)|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | mddr_lpddr2_bl_8 | tfaw_cfg(6)|pd_exit_fast|pd_type(1);
-        }
-        i = ((pPHY_Reg->DTPR[1] >> 27) & 0x7) - ((pPHY_Reg->DTPR[1] >> 24) & 0x7);
-        pPHY_Reg->DSGCR = (pPHY_Reg->DSGCR & (~(0x3F<<5))) | (i<<5) | (i<<8);  //tDQSCKmax-tDQSCK
-        pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-1;
-        pDDR_Reg->DFITPHYWRLAT   = pDDR_Reg->TCWL;
-    }
-
-    return 0;
-}
-
-static uint32_t __sramfunc ddr_update_mr(void)
-{
-    PHY_TIMING_T  *p_publ_timing=&(DATA(ddr_reg).publ.phy_timing);
-    uint32_t cs,dll_off;
-
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    dll_off = (pPHY_Reg->MR[1] & DDR3_DLL_DISABLE) ? 1:0;
-    ddr_copy((uint32_t *)&(pPHY_Reg->MR[0]), (uint32_t*)&(p_publ_timing->mr[0]), 4);
-    if((DATA(mem_type) == DDR3) || (DATA(mem_type) == DDR2))
-    {
-        if(DATA(ddr_freq)>DDR3_DDR2_DLL_DISABLE_FREQ)
-        {
-            if(dll_off)  // off -> on
-            {
-                ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[1])));  //DLL enable
-                ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr(((p_publ_timing->mr[0]))| DDR3_DLL_RESET));  //DLL reset
-                ddr_delayus(2);  //at least 200 DDR cycle
-                ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-            }
-            else // on -> on
-            {
-                ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[1])));
-                ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-            }
-        }
-        else
-        {
-            pPHY_Reg->MR[1] = (((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE);
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr(((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE));  //DLL disable
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-        }
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x2) | cmd_addr((p_publ_timing->mr[2])));
-    }
-    else if(DATA(mem_type) == LPDDR2)
-    {
-        ddr_send_command(cs, MRS_cmd, lpddr2_ma(0x1) | lpddr2_op((p_publ_timing->mr[1])));
-        ddr_send_command(cs, MRS_cmd, lpddr2_ma(0x2) | lpddr2_op((p_publ_timing->mr[2])));
-        ddr_send_command(cs, MRS_cmd, lpddr2_ma(0x3) | lpddr2_op((p_publ_timing->mr[3])));
-    }
-    else //mDDR
-    {
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[2]))); //mr[2] is mDDR MR1
-    }
-    return 0;
-}
-
-static void __sramfunc ddr_update_odt(void)
-{
-    uint32_t cs,tmp;
-
-    //adjust DRV and ODT
-    if((DATA(mem_type) == DDR3) || (DATA(mem_type) == DDR2))
-    {
-        if(DATA(ddr_freq) <= DDR3_DDR2_ODT_DISABLE_FREQ)
-        {
-            pPHY_Reg->DATX8[0].DXGCR &= ~(0x3<<9);  //dynamic RTT disable
-            pPHY_Reg->DATX8[1].DXGCR &= ~(0x3<<9);
-            if(!(pDDR_Reg->PPCFG & 1))
-            {
-                pPHY_Reg->DATX8[2].DXGCR &= ~(0x3<<9);
-                pPHY_Reg->DATX8[3].DXGCR &= ~(0x3<<9);
-            }
-        }
-        else
-        {
-            pPHY_Reg->DATX8[0].DXGCR |= (0x3<<9);  //dynamic RTT enable
-            pPHY_Reg->DATX8[1].DXGCR |= (0x3<<9);
-            if(!(pDDR_Reg->PPCFG & 1))
-            {
-                pPHY_Reg->DATX8[2].DXGCR |= (0x3<<9);
-                pPHY_Reg->DATX8[3].DXGCR |= (0x3<<9);
-            }
-        }
-    }
-    else
-    {
-        pPHY_Reg->DATX8[0].DXGCR &= ~(0x3<<9);  //dynamic RTT disable
-        pPHY_Reg->DATX8[1].DXGCR &= ~(0x3<<9);
-        if(!(pDDR_Reg->PPCFG & 1))
-        {
-            pPHY_Reg->DATX8[2].DXGCR &= ~(0x3<<9);
-            pPHY_Reg->DATX8[3].DXGCR &= ~(0x3<<9);
-        }
-    }
-    if(DATA(mem_type) == LPDDR2)
-    {
-        tmp = GET_LPDDR2_DS_ODT();  //DS=34ohm,ODT=171ohm
-    }
-    else
-    {
-        tmp = GET_DDR3_DS_ODT();  //DS=34ohm,ODT=171ohm
-    }
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    if(cs > 1)
-    {
-        pPHY_Reg->ZQ1CR[0] = tmp;
-        dsb();
-    }
-    pPHY_Reg->ZQ0CR[0] = tmp;
-    dsb();
-}
-
-void PIE_FUNC(ddr_adjust_config)(void *arg)
-{
-    uint32 value = (uint32)arg;
-
-    //enter config state
-    ddr_move_to_Config_state();
-
-    //set data training address
-    pPHY_Reg->DTAR = value;
-
-    //set auto power down idle
-    pDDR_Reg->MCFG=(pDDR_Reg->MCFG&0xffff00ff)|(PD_IDLE<<8);
-
-    //CKDV=00
-    pPHY_Reg->PGCR &= ~(0x3<<12);
-
-    //enable the hardware low-power interface
-    pDDR_Reg->SCFG.b.hw_low_power_en = 1;
-
-    if(pDDR_Reg->PPCFG & 1)
-    {
-        pPHY_Reg->DATX8[2].DXGCR &= ~(1);          //disable byte
-        pPHY_Reg->DATX8[3].DXGCR &= ~(1);
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;  //disable DLL
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-    }
-
-    ddr_update_odt();
-
-    //enter access state
-    ddr_move_to_Access_state();
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_adjust_config));
-
-static void ddr_adjust_config(uint32_t dram_type)
-{
-    uint32 value;
-    u32 i;
-    volatile u32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-
-    //get data training address before idle port
-    value = ddr_get_datatraing_addr();
-
-    /** 1. Make sure there is no host access */
-    flush_cache_all();
-    outer_flush_all();
-    flush_tlb_all();
-    isb();
-
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->RIDR;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= *(volatile uint32_t *)SysSrv_DdrConf;
-    n= READ_GRF_REG();
-    dsb();
-
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_adjust_config)),
-                    (void *)value,
-                    rockchip_sram_stack);
-}
-
-static void __sramfunc ddr_selfrefresh_enter(uint32 nMHz)
-{
-    PHY_TIMING_T  *p_publ_timing=&(DATA(ddr_reg).publ.phy_timing);
-    uint32 cs;
-
-    ddr_move_to_Config_state();
-    pDDR_Reg->TZQCSI = 0;
-    if((nMHz<=DDR3_DDR2_DLL_DISABLE_FREQ) && ((DATA(mem_type) == DDR3) || (DATA(mem_type) == DDR2)))  // DLL disable
-    {
-        cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-        pPHY_Reg->MR[1] = (((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE);
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr(((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE));
-    }
-    ddr_move_to_Lowpower_state();
-
-    ddr_set_dll_bypass(0);  //dll bypass
-    SET_DDRPHY_CLKGATE(1);  //disable DDR PHY clock
-    ddr_delayus(1);
-}
-
-static void __sramfunc ddr_selfrefresh_exit(void)
-{
-    uint32 n;
-
-    SET_DDRPHY_CLKGATE(0);  //enable DDR PHY clock
-    dsb();
-    ddr_set_dll_bypass(DATA(ddr_freq));
-    ddr_reset_dll();
-    //ddr_delayus(10);   //wait DLL lock
-
-    ddr_move_to_Config_state();
-    ddr_update_timing();
-    ddr_update_mr();
-    ddr_update_odt();
-    n = ddr_data_training();
-    ddr_move_to_Access_state();
-    if(n!=0)
-    {
-        sram_printascii("DTT failed!\n");
-    }
-}
-
-#if defined(CONFIG_ARCH_RK3066B)
-static __sramdata uint32_t data8_dqstr[25][4];
-static __sramdata uint32_t min_ddr_freq,dqstr_flag=false;
-
-int ddr_get_datatraing_value_3168(bool end_flag,uint32_t dqstr_value,uint32_t min_freq)
-{
-    if(end_flag == true)
-    {
-        dqstr_flag = true;    //complete learn data training value flag
-        min_ddr_freq = min_freq;
-        return 0;
-    }
-
-    data8_dqstr[dqstr_value][0]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][1]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][2]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][3]=pPHY_Reg->DATX8[0].DXDQSTR;
-
-    ddr_print("training %luMhz[%d]:0x%x-0x%x-0x%x-0x%x\n",
-        clk_get_rate(clk_get(NULL, "ddr"))/1000000,dqstr_value,data8_dqstr[dqstr_value][0],data8_dqstr[dqstr_value][1],
-        data8_dqstr[dqstr_value][2],data8_dqstr[dqstr_value][3]);
-    return 0;
-}
-
-static void __sramfunc ddr_set_pll_enter_3168(uint32_t freq_slew)
-{
-    uint32_t value_1u,value_100n;
-    ddr_move_to_Config_state();
-
-    if(freq_slew == 1)
-    {
-        value_100n = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        value_1u = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt1u = pDDR_Reg->TOGCNT1U;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt100n = pDDR_Reg->TOGCNT100N;
-        ddr_update_timing();
-        ddr_update_mr();
-        DATA(ddr_reg).pctl.pctl_timing.togcnt100n = value_100n;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt1u = value_1u;
-    }
-    else
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-    }
-
-    pDDR_Reg->TZQCSI = 0;
-    ddr_move_to_Lowpower_state();
-
-    ddr_set_dll_bypass(0);  //dll bypass
-    SET_DDRPHY_CLKGATE(1);  //disable DDR PHY clock
-    dsb();
-}
-
-void __sramlocalfunc ddr_set_pll_exit_3168(uint32 freq_slew,uint32_t dqstr_value)
-{
-    SET_DDRPHY_CLKGATE(0);  //enable DDR PHY clock
-    dsb();
-    ddr_set_dll_bypass(DATA(ddr_freq));
-    ddr_reset_dll();
-
-    if(dqstr_flag==true)
-    {
-        pPHY_Reg->DATX8[0].DXDQSTR=data8_dqstr[dqstr_value][0];
-        pPHY_Reg->DATX8[1].DXDQSTR=data8_dqstr[dqstr_value][1];
-        pPHY_Reg->DATX8[2].DXDQSTR=data8_dqstr[dqstr_value][2];
-        pPHY_Reg->DATX8[3].DXDQSTR=data8_dqstr[dqstr_value][3];
-    }
-
-    ddr_update_odt();
-    ddr_move_to_Config_state();
-    if(freq_slew == 1)
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-        pDDR_Reg->TZQCSI = DATA(ddr_reg).pctl.pctl_timing.tzqcsi;
-    }
-    else
-    {
-        ddr_update_timing();
-        ddr_update_mr();
-    }
-    ddr_data_training();
-    ddr_move_to_Access_state();
-}
-#endif
-
-/* Make sure ddr_SRE_2_SRX paramter less than 4 */
-static void __sramfunc ddr_SRE_2_SRX(uint32 freq, uint32_t freq_slew,uint32_t dqstr_value)
-{
-    /** 2. ddr enter self-refresh mode or precharge power-down mode */
-    idle_port();
-#if defined(CONFIG_ARCH_RK3066B)
-    ddr_set_pll_enter_3168(freq_slew);
-#else
-    ddr_selfrefresh_enter(freq);
-#endif
-
-    /** 3. change frequence  */
-    FUNC(ddr_set_pll)(freq,1);
-    DATA(ddr_freq) = freq;
-
-    /** 5. Issues a Mode Exit command   */
-#if defined(CONFIG_ARCH_RK3066B)
-    ddr_set_pll_exit_3168(freq_slew,dqstr_value);
-#else
-    ddr_selfrefresh_exit();
-#endif
-    deidle_port();
-    dsb();
-}
-
-struct ddr_change_freq_sram_param {
-    uint32_t arm_freq;
-    uint32_t freq;
-    uint32_t freq_slew;
-    uint32_t dqstr_value;
-};
-
-void PIE_FUNC(ddr_change_freq_sram)(void *arg)
-{
-    struct ddr_change_freq_sram_param *param = arg;
-    loops_per_us = LPJ_100MHZ * param->arm_freq / 1000000;
-    /* Make sure ddr_SRE_2_SRX paramter less than 4 */
-    ddr_SRE_2_SRX(param->freq, param->freq_slew, param->dqstr_value);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_change_freq_sram));
-
-static noinline uint32_t ddr_change_freq_sram(uint32_t nMHz , struct ddr_freq_t ddr_freq_t)
-{
-    register uint32_t freq;
-    register uint32_t freq_slew=0;
-    register uint32_t dqstr_value=0;
-    unsigned long flags;
-    struct ddr_change_freq_sram_param param;
-    volatile u32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-    u32 i;
-
-#if defined(CONFIG_ARCH_RK3066B)
-    if(dqstr_flag==true)
-    {
-        dqstr_value=((nMHz-min_ddr_freq+1)/25 + 1) /2;
-        freq_slew = (nMHz>ddr_freq)? 1 : 0;
-    }
-#endif
-
-    freq=p_ddr_set_pll(nMHz,0);
-
-    ddr_get_parameter(freq);
-
-    /** 1. Make sure there is no host access */
-    local_irq_save(flags);
-    local_fiq_disable();
-    flush_cache_all();
-    outer_flush_all();
-    flush_tlb_all();
-    isb();
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-    if(ddr_freq_t.screen_ft_us > 0)
-    {
-        ddr_freq_t.t1 = cpu_clock(0);
-        ddr_freq_t.t2 = (u32)(ddr_freq_t.t1 - ddr_freq_t.t0);   //ns
-
-        //if test_count exceed maximum test times,ddr_freq_t.screen_ft_us == 0xfefefefe by ddr_freq.c
-        if( (ddr_freq_t.t2 > ddr_freq_t.screen_ft_us*1000) && (ddr_freq_t.screen_ft_us != 0xfefefefe))
-        {
-            freq = 0;
-            goto end;
-        }
-        else
-        {
-            rk_fb_poll_wait_frame_complete();
-        }
-    }
-#endif
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->RIDR;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= *(volatile uint32_t *)SysSrv_DdrConf;
-    n= READ_GRF_REG();
-    dsb();
-
-    param.arm_freq = ddr_get_pll_freq(APLL);
-    param.freq = freq;
-    param.freq_slew = freq_slew;
-    param.dqstr_value = dqstr_value;
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_change_freq_sram)),
-                    &param,
-                    rockchip_sram_stack-(NR_CPUS-1)*PAUSE_CPU_STACK_SIZE);
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-end:
-#endif
-    local_fiq_enable();
-    local_irq_restore(flags);
-    return freq;
-}
-
-#if defined(ENABLE_DDR_CLCOK_GPLL_PATH)
-static uint32_t ddr_change_freq_gpll_dpll(uint32_t nMHz)
-{
-    uint32_t gpll_freq,gpll_div;
-    struct ddr_freq_t ddr_freq_t;
-    ddr_freq_t.screen_ft_us = 0;
-
-    if(true == ddr_rk3188_dpll_is_good)
-    {
-        gpllvaluel = ddr_get_pll_freq(GPLL);
-
-        if((200 < gpllvaluel) ||( gpllvaluel <1600))      //GPLL:200MHz~1600MHz
-        {
-            gpll_div = (gpllvaluel+nMHz-1)/nMHz;
-            if( gpllvaluel > 800)     //800-1600MHz  /4:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel/4;
-                gpll_div = 4;
-            }
-            else if( gpllvaluel > 400)    //400-800MHz  /2:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel/2;
-                gpll_div = 2;
-            }
-            else        //200-400MHz  /1:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel;
-                gpll_div = 1;
-            }
-
-            *p_ddr_select_gpll_div=gpll_div;    //select GPLL
-            ddr_change_freq_sram(gpll_freq,ddr_freq_t);
-            *p_ddr_select_gpll_div=0;
-
-            p_ddr_set_pll(nMHz,0); //count DPLL
-            p_ddr_set_pll(nMHz,2); //lock DPLL only,but not select DPLL
-        }
-        else
-        {
-            ddr_print("GPLL frequency = %dMHz,Not suitable for ddr_clock \n",gpllvaluel);
-        }
-    }
-
-    return ddr_change_freq_sram(nMHz,ddr_freq_t);
-
-}
-#endif
-
-/*****************************************
-if rk3188 DPLL is bad,use GPLL
-            GPLL                   DDR_CLCOK
-1000MHz-2000MHz       4:250MHz-500MHz
-800MHz-1000MHz        4:200MHz-250MHz    2:400MHz-500MHz
-500MHz-800MHz          2:250MHz-400MHz
-200MHz-500MHz          1:200MHz-500MHz
-******************************************/
-#if 0
-static noinline uint32_t ddr_change_freq(uint32_t nMHz)
-{
-    struct ddr_freq_t ddr_freq_t;
-    ddr_freq_t.screen_ft_us = 0;
-    
-#if defined(ENABLE_DDR_CLCOK_GPLL_PATH) && (defined(CONFIG_ARCH_RK3188) || defined(CONFIG_ARCH_RK319X))
-    return ddr_change_freq_gpll_dpll(nMHz);
-#else
-    return ddr_change_freq_sram(nMHz,ddr_freq_t);
-#endif
-}
-#endif
-
-bool DEFINE_PIE_DATA(cpu_pause[NR_CPUS]);
-volatile bool *p_cpu_pause;
-static inline bool is_cpu0_paused(unsigned int cpu) { smp_rmb(); return DATA(cpu_pause)[0]; }
-static inline void set_cpuX_paused(unsigned int cpu, bool pause) { DATA(cpu_pause)[cpu] = pause; smp_wmb(); }
-static inline bool is_cpuX_paused(unsigned int cpu) { smp_rmb(); return p_cpu_pause[cpu]; }
-static inline void set_cpu0_paused(bool pause) { p_cpu_pause[0] = pause; smp_wmb();}
-
-#define MAX_TIMEOUT (16000000UL << 6) //>0.64s
-
-/* Do not use stack, safe on SMP */
-void PIE_FUNC(_pause_cpu)(void *arg)
-{	
-	unsigned int cpu = (unsigned int)arg;
-	
-	set_cpuX_paused(cpu, true);
-	while (is_cpu0_paused(cpu));
-	set_cpuX_paused(cpu, false);
-}
-
-static void pause_cpu(void *info)
-{
-	unsigned int cpu = raw_smp_processor_id();
-
-	call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(_pause_cpu)),
-			(void *)cpu,
-			rockchip_sram_stack-(cpu-1)*PAUSE_CPU_STACK_SIZE);
-}
-
-static void wait_cpu(void *info)
-{
-}
-
-static int __ddr_change_freq(uint32_t nMHz, struct ddr_freq_t ddr_freq_t)
-{
-	u32 timeout = MAX_TIMEOUT;
-	unsigned int cpu;
-	unsigned int this_cpu = smp_processor_id();
-	int ret = 0;
-
-	cpu_maps_update_begin();
-	local_bh_disable();
-	set_cpu0_paused(true);
-	smp_call_function((smp_call_func_t)pause_cpu, NULL, 0);
-
-	for_each_online_cpu(cpu) {
-		if (cpu == this_cpu)
-			continue;
-		while (!is_cpuX_paused(cpu) && --timeout);
-		if (timeout == 0) {
-			pr_err("pause cpu %d timeout\n", cpu);
-			goto out;
-		}
-	}
-
-	ret = ddr_change_freq_sram(nMHz, ddr_freq_t);
-
-out:
-	set_cpu0_paused(false);
-	local_bh_enable();
-	smp_call_function(wait_cpu, NULL, true);
-	cpu_maps_update_done();
-
-	return ret;
-}
-
-static int _ddr_change_freq(uint32_t nMHz)
-{
-	struct ddr_freq_t ddr_freq_t;
-	//int test_count=0;
-
-	ddr_freq_t.screen_ft_us = 0;
-	ddr_freq_t.t0 = 0;
-	ddr_freq_t.t1 = 0;
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	do
-	{
-		if(rk_fb_poll_wait_frame_complete() == true)
-		{
-			ddr_freq_t.t0 = cpu_clock(0);
-			ddr_freq_t.screen_ft_us = rk_fb_get_prmry_screen_ft();
-
-			test_count++;
-                        if(test_count > 10) //test 10 times
-                        {
-				ddr_freq_t.screen_ft_us = 0xfefefefe;
-				dprintk(DEBUG_DDR,"%s:test_count exceed maximum!\n",__func__);
-                        }
-			dprintk(DEBUG_VERBOSE,"%s:test_count=%d\n",__func__,test_count);
-			usleep_range(ddr_freq_t.screen_ft_us-test_count*1000,ddr_freq_t.screen_ft_us-test_count*1000);
-
-			flush_cache_all();
-			outer_flush_all();
-			flush_tlb_all();
-		}
-	}while(__ddr_change_freq(nMHz, ddr_freq_t)==0);
-#else
-	return __ddr_change_freq(nMHz, ddr_freq_t);
-#endif
-}
-
-static long _ddr_round_rate(uint32_t nMHz)
-{
-	return p_ddr_set_pll(nMHz, 0);
-}
-
-static void _ddr_set_auto_self_refresh(bool en)
-{
-    //set auto self-refresh idle
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = en ? SR_IDLE : 0;
-}
-
-#define PERI_ACLK_DIV_MASK 0x1f
-#define PERI_ACLK_DIV_OFF 0
-
-#define PERI_HCLK_DIV_MASK 0x3
-#define PERI_HCLK_DIV_OFF 8
-
-#define PERI_PCLK_DIV_MASK 0x3
-#define PERI_PCLK_DIV_OFF 12
-#if 0
-static __sramdata u32 cru_sel32_sram;
-static void __sramfunc ddr_suspend(void)
-{
-    u32 i;
-    volatile u32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-    int pll_id;
-
-	pll_id=GET_DDR_PLL_SRC();
-    /** 1. Make sure there is no host access */
-    flush_cache_all();
-    outer_flush_all();
-    //flush_tlb_all();
-
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->RIDR;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= *(volatile uint32_t *)SysSrv_DdrConf;
-    n= READ_GRF_REG();
-    dsb();
-
-    ddr_selfrefresh_enter(0);
-
-    SET_PLL_MODE(pll_id, 0);   //PLL slow-mode
-    dsb();
-    ddr_delayus(1);
-    SET_PLL_PD(pll_id, 1);         //PLL power-down
-    dsb();
-    ddr_delayus(1);
-    if(pll_id==GPLL)
-    {
-    	cru_sel32_sram=   pCRU_Reg->CRU_CLKSEL_CON[10];
-
-    	pCRU_Reg->CRU_CLKSEL_CON[10]=CRU_W_MSK_SETBITS(0, PERI_ACLK_DIV_OFF, PERI_ACLK_DIV_MASK)
-    				   | CRU_W_MSK_SETBITS(0, PERI_HCLK_DIV_OFF, PERI_HCLK_DIV_MASK)
-    				   |CRU_W_MSK_SETBITS(0, PERI_PCLK_DIV_OFF, PERI_PCLK_DIV_MASK);
-    }
-    pPHY_Reg->DSGCR = pPHY_Reg->DSGCR&(~((0x1<<28)|(0x1<<29)));  //CKOE
-}
-
-static void __sramfunc ddr_resume(void)
-{
-    int delay=1000;
-    int pll_id;
-
-    pll_id=GET_DDR_PLL_SRC();
-	pPHY_Reg->DSGCR = pPHY_Reg->DSGCR|((0x1<<28)|(0x1<<29));  //CKOE
-	dsb();
-
-	if(pll_id==GPLL)
-	pCRU_Reg->CRU_CLKSEL_CON[10]=0xffff0000|cru_sel32_sram;
-
-    SET_PLL_PD(pll_id, 0);         //PLL no power-down
-    dsb();
-    while (delay > 0)
-    {
-	    ddr_delayus(1);
-        if (GET_DPLL_LOCK_STATUS())
-            break;
-        delay--;
-    }
-
-    SET_PLL_MODE(pll_id, 1);   //PLL normal
-    dsb();
-
-    ddr_selfrefresh_exit();
-}
-#endif
-
-//
-static uint32 ddr_get_cap(void)
-{
-    uint32 cap;
-
-    if(DDR_SYS_REG())
-    {
-        cap = (1 << (READ_CS0_ROW_INFO()+READ_COL_INFO()+READ_BK_INFO()+READ_BW_INFO()));
-        if(READ_CS_INFO()>1)
-        {
-            cap +=(1 << (READ_CS1_ROW_INFO()+READ_COL_INFO()+READ_BK_INFO()+READ_BW_INFO()));
-        }
-    }
-    else
-    {
-        cap = (1 << (ddr_get_row()+ddr_get_col()+ddr_get_bank()+ddr_get_bw()))*ddr_get_cs();
-    }
-
-    return cap;
-}
-
-#if 0
-static void ddr_reg_save(void)
-{
-    //PCTLR
-    p_ddr_reg->pctl.SCFG = pDDR_Reg->SCFG.d32;
-    p_ddr_reg->pctl.CMDTSTATEN = pDDR_Reg->CMDTSTATEN;
-    p_ddr_reg->pctl.MCFG1 = pDDR_Reg->MCFG1;
-    p_ddr_reg->pctl.MCFG = pDDR_Reg->MCFG;
-    p_ddr_reg->pctl.pctl_timing.ddrFreq = ddr_freq;
-    p_ddr_reg->pctl.DFITCTRLDELAY = pDDR_Reg->DFITCTRLDELAY;
-    p_ddr_reg->pctl.DFIODTCFG = pDDR_Reg->DFIODTCFG;
-    p_ddr_reg->pctl.DFIODTCFG1 = pDDR_Reg->DFIODTCFG1;
-    p_ddr_reg->pctl.DFIODTRANKMAP = pDDR_Reg->DFIODTRANKMAP;
-    p_ddr_reg->pctl.DFITPHYWRDATA = pDDR_Reg->DFITPHYWRDATA;
-    p_ddr_reg->pctl.DFITPHYWRLAT = pDDR_Reg->DFITPHYWRLAT;
-    p_ddr_reg->pctl.DFITRDDATAEN = pDDR_Reg->DFITRDDATAEN;
-    p_ddr_reg->pctl.DFITPHYRDLAT = pDDR_Reg->DFITPHYRDLAT;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE0 = pDDR_Reg->DFITPHYUPDTYPE0;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE1 = pDDR_Reg->DFITPHYUPDTYPE1;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE2 = pDDR_Reg->DFITPHYUPDTYPE2;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE3 = pDDR_Reg->DFITPHYUPDTYPE3;
-    p_ddr_reg->pctl.DFITCTRLUPDMIN = pDDR_Reg->DFITCTRLUPDMIN;
-    p_ddr_reg->pctl.DFITCTRLUPDMAX = pDDR_Reg->DFITCTRLUPDMAX;
-    p_ddr_reg->pctl.DFITCTRLUPDDLY = pDDR_Reg->DFITCTRLUPDDLY;
-
-    p_ddr_reg->pctl.DFIUPDCFG = pDDR_Reg->DFIUPDCFG;
-    p_ddr_reg->pctl.DFITREFMSKI = pDDR_Reg->DFITREFMSKI;
-    p_ddr_reg->pctl.DFITCTRLUPDI = pDDR_Reg->DFITCTRLUPDI;
-    p_ddr_reg->pctl.DFISTCFG0 = pDDR_Reg->DFISTCFG0;
-    p_ddr_reg->pctl.DFISTCFG1 = pDDR_Reg->DFISTCFG1;
-    p_ddr_reg->pctl.DFITDRAMCLKEN = pDDR_Reg->DFITDRAMCLKEN;
-    p_ddr_reg->pctl.DFITDRAMCLKDIS = pDDR_Reg->DFITDRAMCLKDIS;
-    p_ddr_reg->pctl.DFISTCFG2 = pDDR_Reg->DFISTCFG2;
-    p_ddr_reg->pctl.DFILPCFG0 = pDDR_Reg->DFILPCFG0;
-
-    //PUBL
-    p_ddr_reg->publ.PIR = pPHY_Reg->PIR;
-    p_ddr_reg->publ.PGCR = pPHY_Reg->PGCR;
-    p_ddr_reg->publ.DLLGCR = pPHY_Reg->DLLGCR;
-    p_ddr_reg->publ.ACDLLCR = pPHY_Reg->ACDLLCR;
-    p_ddr_reg->publ.PTR[0] = pPHY_Reg->PTR[0];
-    p_ddr_reg->publ.PTR[1] = pPHY_Reg->PTR[1];
-    p_ddr_reg->publ.PTR[2] = pPHY_Reg->PTR[2];
-    p_ddr_reg->publ.ACIOCR = pPHY_Reg->ACIOCR;
-    p_ddr_reg->publ.DXCCR = pPHY_Reg->DXCCR;
-    p_ddr_reg->publ.DSGCR = pPHY_Reg->DSGCR;
-    p_ddr_reg->publ.DCR = pPHY_Reg->DCR.d32;
-    p_ddr_reg->publ.ODTCR = pPHY_Reg->ODTCR;
-    p_ddr_reg->publ.DTAR = pPHY_Reg->DTAR;
-    p_ddr_reg->publ.ZQ0CR0 = (pPHY_Reg->ZQ0SR[0] & 0x0FFFFFFF) | (0x1<<28);
-    p_ddr_reg->publ.ZQ1CR0 = (pPHY_Reg->ZQ1SR[0] & 0x0FFFFFFF) | (0x1<<28);
-
-    p_ddr_reg->publ.DX0GCR = pPHY_Reg->DATX8[0].DXGCR;
-    p_ddr_reg->publ.DX0DLLCR = pPHY_Reg->DATX8[0].DXDLLCR;
-    p_ddr_reg->publ.DX0DQTR = pPHY_Reg->DATX8[0].DXDQTR;
-    p_ddr_reg->publ.DX0DQSTR = pPHY_Reg->DATX8[0].DXDQSTR;
-
-    p_ddr_reg->publ.DX1GCR = pPHY_Reg->DATX8[1].DXGCR;
-    p_ddr_reg->publ.DX1DLLCR = pPHY_Reg->DATX8[1].DXDLLCR;
-    p_ddr_reg->publ.DX1DQTR = pPHY_Reg->DATX8[1].DXDQTR;
-    p_ddr_reg->publ.DX1DQSTR = pPHY_Reg->DATX8[1].DXDQSTR;
-
-    p_ddr_reg->publ.DX2GCR = pPHY_Reg->DATX8[2].DXGCR;
-    p_ddr_reg->publ.DX2DLLCR = pPHY_Reg->DATX8[2].DXDLLCR;
-    p_ddr_reg->publ.DX2DQTR = pPHY_Reg->DATX8[2].DXDQTR;
-    p_ddr_reg->publ.DX2DQSTR = pPHY_Reg->DATX8[2].DXDQSTR;
-
-    p_ddr_reg->publ.DX3GCR = pPHY_Reg->DATX8[3].DXGCR;
-    p_ddr_reg->publ.DX3DLLCR = pPHY_Reg->DATX8[3].DXDLLCR;
-    p_ddr_reg->publ.DX3DQTR = pPHY_Reg->DATX8[3].DXDQTR;
-    p_ddr_reg->publ.DX3DQSTR = pPHY_Reg->DATX8[3].DXDQSTR;
-
-    //NOC
-    p_ddr_reg->DdrConf = *(volatile uint32_t *)SysSrv_DdrConf;
-    p_ddr_reg->DdrMode = *(volatile uint32_t *)SysSrv_DdrMode;
-    p_ddr_reg->ReadLatency = *(volatile uint32_t *)SysSrv_ReadLatency;
-}
-
-static __attribute__((aligned(4))) __sramdata uint32 ddr_reg_resume[] =
-{
-#include "ddr_reg_resume.inc"
-};
-#endif
-
-static int ddr_init(uint32_t dram_speed_bin, uint32_t freq)
-{
-    volatile uint32_t value = 0;
-    uint32_t die=1;
-    uint32_t gsr,dqstr;
-    struct clk *clk;
-
-    ddr_print("version 1.00 20140228 \n");
-
-    p_ddr_reg = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-    p_ddr_select_gpll_div = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_select_gpll_div));
-    p_mem_type = kern_to_pie(rockchip_pie_chunk, &DATA(mem_type));
-    p_ddr_set_pll = fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_set_pll));
-    p_cpu_pause = kern_to_pie(rockchip_pie_chunk, &DATA(cpu_pause[0]));
-
-    *p_mem_type = pPHY_Reg->DCR.b.DDRMD;
-    ddr_speed_bin = dram_speed_bin;
-
-    if(freq != 0)
-        ddr_freq = freq;
-    else
-        ddr_freq = clk_get_rate(clk_get(NULL, "ddr"))/1000000;
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq)) = ddr_freq;
-
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = 0;
-    ddr_soc_is_rk3188_plus = GET_3188_PLUS_STATUS();
-    if(true == ddr_soc_is_rk3188_plus)
-    {
-        ddr_print("A\n");
-    }
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_soc_is_rk3188_plus)) = ddr_soc_is_rk3188_plus;
-    ddr_rk3188_dpll_is_good = GET_DPLL_STATUS();
-    if(false == ddr_rk3188_dpll_is_good)
-    {
-        ddr_print("T\n");
-    }
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_rk3188_dpll_is_good)) = ddr_rk3188_dpll_is_good;
-    switch(*p_mem_type)
-    {
-        case DDR3:
-            if(DDR_SYS_REG())
-            {
-                die = (8<<READ_BW_INFO())/(8<<READ_DIE_BW_INFO());
-            }
-            else
-            {
-                if(pDDR_Reg->PPCFG & 1)
-                {
-                        die=1;
-                }
-                else
-                {
-                        die = 2;
-                }
-            }
-            ddr_print("DDR3 Device\n");
-            break;
-        case LPDDR2:
-            ddr_print("LPDDR2 Device\n");
-            break;
-        case DDR2:
-            ddr_print("DDR2 Device\n");
-            break;
-        case DDR:
-            ddr_print("DDR Device\n");
-            break;
-        default:
-            ddr_print("LPDDR Device\n");
-            break;
-    }
-    //get capability per chip, not total size, used for calculate tRFC
-    ddr_capability_per_die = ddr_get_cap()/(ddr_get_cs()*die);
-    ddr_print("Bus Width=%d Col=%d Bank=%d Row=%d CS=%d Total Capability=%dMB\n",
-                                                                    ddr_get_bw()*16,\
-                                                                    ddr_get_col(), \
-                                                                    (0x1<<(ddr_get_bank())), \
-                                                                    ddr_get_row(), \
-                                                                    ddr_get_cs(), \
-                                                                    (ddr_get_cap()>>20));
-    ddr_adjust_config(*p_mem_type);
-
-    clk = clk_get(NULL, "clk_ddr");
-    if (IS_ERR(clk)) {
-        ddr_print("failed to get ddr clk\n");
-        clk = NULL;
-    }
-    if(ddr_rk3188_dpll_is_good == true)
-    {
-        if(freq != 0)
-            value = clk_set_rate(clk, 1000*1000*freq);
-        else
-            value = clk_set_rate(clk, clk_get_rate(clk));
-    }
-    ddr_print("init success!!! freq=%luMHz\n", clk ? clk_get_rate(clk)/1000000 : freq);
-
-    for(value=0;value<4;value++)
-    {
-        gsr = pPHY_Reg->DATX8[value].DXGSR[0];
-        dqstr = pPHY_Reg->DATX8[value].DXDQSTR;
-        ddr_print("DTONE=0x%x, DTERR=0x%x, DTIERR=0x%x, DTPASS=0x%x, DGSL=%d extra clock, DGPS=%d\n", \
-                   (gsr&0xF), ((gsr>>4)&0xF), ((gsr>>8)&0xF), ((gsr>>13)&0xFFF), (dqstr&0x7), ((((dqstr>>12)&0x3)+1)*90));
-    }
-    ddr_print("ZERR=%x, ZDONE=%x, ZPD=0x%x, ZPU=0x%x, OPD=0x%x, OPU=0x%x\n", \
-                                                (pPHY_Reg->ZQ0SR[0]>>30)&0x1, \
-                                                (pPHY_Reg->ZQ0SR[0]>>31)&0x1, \
-                                                pPHY_Reg->ZQ0SR[1]&0x3,\
-                                                (pPHY_Reg->ZQ0SR[1]>>2)&0x3,\
-                                                (pPHY_Reg->ZQ0SR[1]>>4)&0x3,\
-                                                (pPHY_Reg->ZQ0SR[1]>>6)&0x3);
-    ddr_print("DRV Pull-Up=0x%x, DRV Pull-Dwn=0x%x\n", pPHY_Reg->ZQ0SR[0]&0x1F, (pPHY_Reg->ZQ0SR[0]>>5)&0x1F);
-    ddr_print("ODT Pull-Up=0x%x, ODT Pull-Dwn=0x%x\n", (pPHY_Reg->ZQ0SR[0]>>10)&0x1F, (pPHY_Reg->ZQ0SR[0]>>15)&0x1F);
-
-    return 0;
-}
-
diff --git a/arch/arm/mach-rockchip/ddr_rk3036.c b/arch/arm/mach-rockchip/ddr_rk3036.c
deleted file mode 100755
index 3b0ee4ab1ff4..000000000000
--- a/arch/arm/mach-rockchip/ddr_rk3036.c
+++ /dev/null
@@ -1,2125 +0,0 @@
-/*
- * arch/arm/mach-rk2928/ddr.c-- for ddr3&ddr2
- *
- * Function Driver for DDR controller
- *
- * Copyright (C) 2012 Fuzhou Rockchip Electronics Co.,Ltd
- * Author: 
- * hcy@rock-chips.com
- * yk@rock-chips.com
- * typ@rock-chips.com
- * 
- * v1.00 
- */
- 
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/cpu.h>
-#include <dt-bindings/clock/ddr.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rk_fb.h>
-
-
-typedef uint32_t uint32 ;
-
-
-#define DDR3_DDR2_DLL_DISABLE_FREQ    (300)  // dll disable
-#define DDR3_DDR2_ODT_DISABLE_FREQ    (333)  //odt disable
-#define SR_IDLE                       (0x1)   //unit:32*DDR clk cycle, and 0 for disable auto self-refresh
-#define PD_IDLE                       (0x40)  //unit:DDR clk cycle, and 0 for disable auto power-down
-#define PHY_ODT_DISABLE_FREQ          (333)  //odt disable
-#define PHY_DLL_DISABLE_FREQ          (266)  //dll bypass
-
-#define ddr_print(x...) printk( "DDR DEBUG: " x )
-
-#define SRAM_CODE_OFFSET        rockchip_sram_virt
-#define SRAM_SIZE               rockchip_sram_size
-
-
-/***********************************
- * DDR3 define
- ***********************************/
-//mr0 for ddr3
-#define DDR3_BL8          (0)
-#define DDR3_BC4_8        (1)
-#define DDR3_BC4          (2)
-#define DDR3_CL(n)        (((((n)-4)&0x7)<<4)|((((n)-4)&0x8)>>1))
-#define DDR3_WR(n)        (((n)&0x7)<<9)
-#define DDR3_DLL_RESET    (1<<8)
-#define DDR3_DLL_DeRESET  (0<<8)
-    
-//mr1 for ddr3
-#define DDR3_DLL_ENABLE    (0)
-#define DDR3_DLL_DISABLE   (1)
-#define DDR3_MR1_AL(n)  (((n)&0x7)<<3)
-    
-#define DDR3_DS_40            (0)
-#define DDR3_DS_34            (1<<1)
-#define DDR3_Rtt_Nom_DIS      (0)
-#define DDR3_Rtt_Nom_60       (1<<2)
-#define DDR3_Rtt_Nom_120      (1<<6)
-#define DDR3_Rtt_Nom_40       ((1<<2)|(1<<6))
-    
-//mr2 for ddr3
-#define DDR3_MR2_CWL(n) ((((n)-5)&0x7)<<3)
-#define DDR3_Rtt_WR_DIS       (0)
-#define DDR3_Rtt_WR_60        (1<<9)
-#define DDR3_Rtt_WR_120       (2<<9)
-
-#define DDR_PLL_REFDIV  (1)
-#define FBDIV(n)        ((0xFFF<<16) | (n&0xfff))
-#define REFDIV(n)       ((0x3F<<16) | (n&0x3f))
-#define POSTDIV1(n)     ((0x7<<(12+16)) | ((n&0x7)<<12))
-#define POSTDIV2(n)     ((0x7<<(6+16)) | ((n&0x7)<<6))
-
-#define PLL_LOCK_STATUS  (0x1<<10)
- //CRU Registers
-typedef volatile struct tagCRU_STRUCT
-{
-    uint32 CRU_PLL_CON[4][4]; 
-    uint32 CRU_MODE_CON;
-    uint32 CRU_CLKSEL_CON[35];
-    uint32 CRU_CLKGATE_CON[10];
-    uint32 reserved1[2];
-    uint32 CRU_GLB_SRST_FST_VALUE;
-    uint32 CRU_GLB_SRST_SND_VALUE;
-    uint32 reserved2[2];
-    uint32 CRU_SOFTRST_CON[9];
-    uint32 CRU_MISC_CON;
-    uint32 reserved3[2];
-    uint32 CRU_GLB_CNT_TH;
-    uint32 CRU_SDMMC_CON[2];
-    uint32 CRU_SDIO_CON[2];
-    uint32 CRU_EMMC_CON[2];
-    uint32 reserved4;
-    uint32 CRU_RST_ST;
-    uint32 reserved5[(0x1f0-0x164)/4];
-    uint32 CRU_PLL_MASK_CON;
-} CRU_REG, *pCRU_REG;
-
-typedef struct tagGPIO_LH
-{
-    uint32 GPIOL;
-    uint32 GPIOH;
-}GPIO_LH_T;
-
-typedef struct tagGPIO_IOMUX
-{
-    uint32 GPIOA_IOMUX;
-    uint32 GPIOB_IOMUX;
-    uint32 GPIOC_IOMUX;
-    uint32 GPIOD_IOMUX;
-}GPIO_IOMUX_T;
-
-/********************************
-GRF GRF_OS_REG1 ddr ranktype
-GRF_SOC_CON2c_sysreqpctllow power 
-GRF_DDRC_STAT pctl low power 
-********************************/
-//REG FILE registers    
-//GRF_SOC_STATUS0
-#define sys_pwr_idle     (1<<27)
-#define gpu_pwr_idle     (1<<26)
-#define vpu_pwr_idle     (1<<25)
-#define vio_pwr_idle     (1<<24)
-#define peri_pwr_idle    (1<<23)
-#define core_pwr_idle     (1<<22)
-//GRF_SOC_CON2
-#define core_pwr_idlereq    (13)
-#define peri_pwr_idlereq    (12)
-#define vio_pwr_idlereq     (11)
-#define vpu_pwr_idlereq     (10)
-#define gpu_pwr_idlereq     (9)
-#define sys_pwr_idlereq     (8)
-
-typedef volatile struct tagREG_FILE
-{
-    uint32 reserved0[(0xa8-0x0)/4];
-    GPIO_IOMUX_T GRF_GPIO_IOMUX[3]; // 0x00a8
-    uint32 reserved1[(0x100-0xd8)/4];
-    uint32 GRF_GPIO_DS;             //0x100
-    uint32 reserved2[(0x118-0x104)/4];
-    GPIO_LH_T GRF_GPIO_PULL[3];     // 0x118
-    uint32 reserved3[(0x140-0x130)/4];
-    uint32 GRF_SOC_CON[3];          // 0x140
-    uint32 GRF_SOC_STATUS0;
-    //uint32 GRF_LVDS_CON0;
-    uint32 reserved4;               //0x150
-    uint32 GRF_SOC_CON3;
-    uint32 reserved5[(0x15c-0x158)/4];
-    uint32 GRF_DMAC_CON[3];        //0x15c
-    uint32 reserved6[(0x17c-0x168)/4];
-    uint32 GRF_UOC0_CON5;         //0x17c
-    uint32 reserved7[(0x190-0x180)/4];
-    uint32 GRF_UOC1_CON4;         //0x190
-    uint32 GRF_UOC1_COM5;
-    uint32 reserved8;
-    uint32 GRF_DDRC_STAT;
-    uint32 GRF_UOC_CON6;
-    uint32 GRF_SOC_STATUS1;
-    uint32 GRF_CPU_CON[4];
-    uint32 reserved9[(0x1c0-0x1b8)/4];
-    uint32 GRF_CPU_STATUS[2];
-    uint32 GRF_OS_REG[8];
-    uint32 reserved10[(0x200-0x1e8)/4];
-    uint32 GRF_DLL_CON[4];          //0X200
-    uint32 GRF_DLL_STATUS[4];
-    //uint32 reserved10[(0x220-0x214)/4];
-    uint32 GRF_DFI_WRNUM;           //0X220
-    uint32 GRF_DFI_RDNUM;
-    uint32 GRF_DFI_ACTNUM;
-    uint32 GRF_DFI_TIMERVAL;
-    uint32 GRF_NIF_FIFO[4];
-    uint32 reserved11[(0x280-0x240)/4];
-    uint32 GRF_USBPHY0_CON[8];
-    uint32 GRF_USBPHY1_CON[8];
-    uint32 reserved12[(0x300-0x2c0)/4];
-    uint32 GRF_CHIP_TAG;
-    uint32 GRF_SDMMC_DET_CNT;
-} REG_FILE, *pREG_FILE;
-
-//SCTL
-#define INIT_STATE                     (0)
-#define CFG_STATE                      (1)
-#define GO_STATE                       (2)
-#define SLEEP_STATE                    (3)
-#define WAKEUP_STATE                   (4)
-
-//STAT
-#define Init_mem                       (0)
-#define Config                         (1)
-#define Config_req                     (2)
-#define Access                         (3)
-#define Access_req                     (4)
-#define Low_power                      (5)
-#define Low_power_entry_req            (6)
-#define Low_power_exit_req             (7)
-
-//MCFG
-#define mddr_lpddr2_clk_stop_idle(n)   ((n)<<24)
-#define pd_idle(n)                     ((n)<<8)
-#define mddr_en                        (2<<22)
-#define lpddr2_en                      (3<<22)
-#define ddr2_en                        (0<<5)
-#define ddr3_en                        (1<<5)
-#define lpddr2_s2                      (0<<6)
-#define lpddr2_s4                      (1<<6)
-#define mddr_lpddr2_bl_2               (0<<20)
-#define mddr_lpddr2_bl_4               (1<<20)
-#define mddr_lpddr2_bl_8               (2<<20)
-#define mddr_lpddr2_bl_16              (3<<20)
-#define ddr2_ddr3_bl_4                 (0)
-#define ddr2_ddr3_bl_8                 (1)
-#define tfaw_cfg(n)                    (((n)-4)<<18)
-#define pd_exit_slow                   (0<<17)
-#define pd_exit_fast                   (1<<17)
-#define pd_type(n)                     ((n)<<16)
-#define two_t_en(n)                    ((n)<<3)
-#define bl8int_en(n)                   ((n)<<2)
-#define cke_or_en(n)                   ((n)<<1)
-
-//POWCTL
-#define power_up_start                 (1<<0)
-
-//POWSTAT
-#define power_up_done                  (1<<0)
-
-//DFISTSTAT0
-#define dfi_init_complete              (1<<0)
-
-//CMDTSTAT
-#define cmd_tstat                      (1<<0)
-
-//CMDTSTATEN
-#define cmd_tstat_en                   (1<<1)
-
-//MCMD
-#define Deselect_cmd                   (0)
-#define PREA_cmd                       (1)
-#define REF_cmd                        (2)
-#define MRS_cmd                        (3)
-#define ZQCS_cmd                       (4)
-#define ZQCL_cmd                       (5)
-#define RSTL_cmd                       (6)
-#define MRR_cmd                        (8)
-#define DPDE_cmd                       (9)
-
-#define lpddr2_op(n)                   ((n)<<12)
-#define lpddr2_ma(n)                   ((n)<<4)
-
-#define bank_addr(n)                   ((n)<<17)
-#define cmd_addr(n)                    ((n)<<4)
-
-#define start_cmd                      (1u<<31)
-
-typedef union STAT_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned ctl_stat : 3;
-        unsigned reserved3 : 1;
-        unsigned lp_trig : 3;
-        unsigned reserved7_31 : 25;
-    }b;
-}STAT_T;
-
-typedef union SCFG_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned hw_low_power_en : 1;
-        unsigned reserved1_5 : 5;
-        unsigned nfifo_nif1_dis : 1;
-        unsigned reserved7 : 1;
-        unsigned bbflags_timing : 4;
-        unsigned reserved12_31 : 20;
-    } b;
-}SCFG_T;
-
-/* DDR Controller register struct */
-typedef volatile struct DDR_REG_Tag
-{
-    //Operational State, Control, and Status Registers
-    SCFG_T SCFG;                   //State Configuration Register
-    volatile uint32 SCTL;                   //State Control Register
-    STAT_T STAT;                   //State Status Register
-    volatile uint32 INTRSTAT;               //Interrupt Status Register
-    uint32 reserved0[(0x40-0x10)/4];
-    //Initailization Control and Status Registers
-    volatile uint32 MCMD;                   //Memory Command Register
-    volatile uint32 POWCTL;                 //Power Up Control Registers
-    volatile uint32 POWSTAT;                //Power Up Status Register
-    volatile uint32 CMDTSTAT;               //Command Timing Status Register
-    volatile uint32 CMDTSTATEN;             //Command Timing Status Enable Register
-    uint32 reserved1[(0x60-0x54)/4];
-    volatile uint32 MRRCFG0;                //MRR Configuration 0 Register
-    volatile uint32 MRRSTAT0;               //MRR Status 0 Register
-    volatile uint32 MRRSTAT1;               //MRR Status 1 Register
-    uint32 reserved2[(0x7c-0x6c)/4];
-    //Memory Control and Status Registers
-    volatile uint32 MCFG1;                  //Memory Configuration 1 Register
-    volatile uint32 MCFG;                   //Memory Configuration Register
-    volatile uint32 PPCFG;                  //Partially Populated Memories Configuration Register
-    volatile uint32 MSTAT;                  //Memory Status Register
-    volatile uint32 LPDDR2ZQCFG;            //LPDDR2 ZQ Configuration Register
-    uint32 reserved3;
-    //DTU Control and Status Registers
-    volatile uint32 DTUPDES;                //DTU Status Register
-    volatile uint32 DTUNA;                  //DTU Number of Random Addresses Created Register
-    volatile uint32 DTUNE;                  //DTU Number of Errors Register
-    volatile uint32 DTUPRD0;                //DTU Parallel Read 0
-    volatile uint32 DTUPRD1;                //DTU Parallel Read 1
-    volatile uint32 DTUPRD2;                //DTU Parallel Read 2
-    volatile uint32 DTUPRD3;                //DTU Parallel Read 3
-    volatile uint32 DTUAWDT;                //DTU Address Width
-    uint32 reserved4[(0xc0-0xb4)/4];
-    //Memory Timing Registers
-    volatile uint32 TOGCNT1U;               //Toggle Counter 1U Register
-    volatile uint32 TINIT;                  //t_init Timing Register
-    volatile uint32 TRSTH;                  //Reset High Time Register
-    volatile uint32 TOGCNT100N;             //Toggle Counter 100N Register
-    volatile uint32 TREFI;                  //t_refi Timing Register
-    volatile uint32 TMRD;                   //t_mrd Timing Register
-    volatile uint32 TRFC;                   //t_rfc Timing Register
-    volatile uint32 TRP;                    //t_rp Timing Register
-    volatile uint32 TRTW;                   //t_rtw Timing Register
-    volatile uint32 TAL;                    //AL Latency Register
-    volatile uint32 TCL;                    //CL Timing Register
-    volatile uint32 TCWL;                   //CWL Register
-    volatile uint32 TRAS;                   //t_ras Timing Register
-    volatile uint32 TRC;                    //t_rc Timing Register
-    volatile uint32 TRCD;                   //t_rcd Timing Register
-    volatile uint32 TRRD;                   //t_rrd Timing Register
-    volatile uint32 TRTP;                   //t_rtp Timing Register
-    volatile uint32 TWR;                    //t_wr Timing Register
-    volatile uint32 TWTR;                   //t_wtr Timing Register
-    volatile uint32 TEXSR;                  //t_exsr Timing Register
-    volatile uint32 TXP;                    //t_xp Timing Register
-    volatile uint32 TXPDLL;                 //t_xpdll Timing Register
-    volatile uint32 TZQCS;                  //t_zqcs Timing Register
-    volatile uint32 TZQCSI;                 //t_zqcsi Timing Register
-    volatile uint32 TDQS;                   //t_dqs Timing Register
-    volatile uint32 TCKSRE;                 //t_cksre Timing Register
-    volatile uint32 TCKSRX;                 //t_cksrx Timing Register
-    volatile uint32 TCKE;                   //t_cke Timing Register
-    volatile uint32 TMOD;                   //t_mod Timing Register
-    volatile uint32 TRSTL;                  //Reset Low Timing Register
-    volatile uint32 TZQCL;                  //t_zqcl Timing Register
-    volatile uint32 TMRR;                   //t_mrr Timing Register
-    volatile uint32 TCKESR;                 //t_ckesr Timing Register
-    volatile uint32 TDPD;                   //t_dpd Timing Register
-    uint32 reserved5[(0x180-0x148)/4];
-    //ECC Configuration, Control, and Status Registers
-    volatile uint32 ECCCFG;                   //ECC Configuration Register
-    volatile uint32 ECCTST;                   //ECC Test Register
-    volatile uint32 ECCCLR;                   //ECC Clear Register
-    volatile uint32 ECCLOG;                   //ECC Log Register
-    uint32 reserved6[(0x200-0x190)/4];
-    //DTU Control and Status Registers
-    volatile uint32 DTUWACTL;                 //DTU Write Address Control Register
-    volatile uint32 DTURACTL;                 //DTU Read Address Control Register
-    volatile uint32 DTUCFG;                   //DTU Configuration Control Register
-    volatile uint32 DTUECTL;                  //DTU Execute Control Register
-    volatile uint32 DTUWD0;                   //DTU Write Data 0
-    volatile uint32 DTUWD1;                   //DTU Write Data 1
-    volatile uint32 DTUWD2;                   //DTU Write Data 2
-    volatile uint32 DTUWD3;                   //DTU Write Data 3
-    volatile uint32 DTUWDM;                   //DTU Write Data Mask
-    volatile uint32 DTURD0;                   //DTU Read Data 0
-    volatile uint32 DTURD1;                   //DTU Read Data 1
-    volatile uint32 DTURD2;                   //DTU Read Data 2
-    volatile uint32 DTURD3;                   //DTU Read Data 3
-    volatile uint32 DTULFSRWD;                //DTU LFSR Seed for Write Data Generation
-    volatile uint32 DTULFSRRD;                //DTU LFSR Seed for Read Data Generation
-    volatile uint32 DTUEAF;                   //DTU Error Address FIFO
-    //DFI Control Registers
-    volatile uint32 DFITCTRLDELAY;            //DFI tctrl_delay Register
-    volatile uint32 DFIODTCFG;                //DFI ODT Configuration Register
-    volatile uint32 DFIODTCFG1;               //DFI ODT Configuration 1 Register
-    volatile uint32 DFIODTRANKMAP;            //DFI ODT Rank Mapping Register
-    //DFI Write Data Registers
-    volatile uint32 DFITPHYWRDATA;            //DFI tphy_wrdata Register
-    volatile uint32 DFITPHYWRLAT;             //DFI tphy_wrlat Register
-    uint32 reserved7[(0x260-0x258)/4];
-    volatile uint32 DFITRDDATAEN;             //DFI trddata_en Register
-    volatile uint32 DFITPHYRDLAT;             //DFI tphy_rddata Register
-    uint32 reserved8[(0x270-0x268)/4];
-    //DFI Update Registers
-    volatile uint32 DFITPHYUPDTYPE0;          //DFI tphyupd_type0 Register
-    volatile uint32 DFITPHYUPDTYPE1;          //DFI tphyupd_type1 Register
-    volatile uint32 DFITPHYUPDTYPE2;          //DFI tphyupd_type2 Register
-    volatile uint32 DFITPHYUPDTYPE3;          //DFI tphyupd_type3 Register
-    volatile uint32 DFITCTRLUPDMIN;           //DFI tctrlupd_min Register
-    volatile uint32 DFITCTRLUPDMAX;           //DFI tctrlupd_max Register
-    volatile uint32 DFITCTRLUPDDLY;           //DFI tctrlupd_dly Register
-    uint32 reserved9;
-    volatile uint32 DFIUPDCFG;                //DFI Update Configuration Register
-    volatile uint32 DFITREFMSKI;              //DFI Masked Refresh Interval Register
-    volatile uint32 DFITCTRLUPDI;             //DFI tctrlupd_interval Register
-    uint32 reserved10[(0x2ac-0x29c)/4];
-    volatile uint32 DFITRCFG0;                //DFI Training Configuration 0 Register
-    volatile uint32 DFITRSTAT0;               //DFI Training Status 0 Register
-    volatile uint32 DFITRWRLVLEN;             //DFI Training dfi_wrlvl_en Register
-    volatile uint32 DFITRRDLVLEN;             //DFI Training dfi_rdlvl_en Register
-    volatile uint32 DFITRRDLVLGATEEN;         //DFI Training dfi_rdlvl_gate_en Register
-    //DFI Status Registers
-    volatile uint32 DFISTSTAT0;               //DFI Status Status 0 Register
-    volatile uint32 DFISTCFG0;                //DFI Status Configuration 0 Register
-    volatile uint32 DFISTCFG1;                //DFI Status configuration 1 Register
-    uint32 reserved11;
-    volatile uint32 DFITDRAMCLKEN;            //DFI tdram_clk_enalbe Register
-    volatile uint32 DFITDRAMCLKDIS;           //DFI tdram_clk_disalbe Register
-    volatile uint32 DFISTCFG2;                //DFI Status configuration 2 Register
-    volatile uint32 DFISTPARCLR;              //DFI Status Parity Clear Register
-    volatile uint32 DFISTPARLOG;              //DFI Status Parity Log Register
-    uint32 reserved12[(0x2f0-0x2e4)/4];
-    //DFI Low Power Registers
-    volatile uint32 DFILPCFG0;                //DFI Low Power Configuration 0 Register
-    uint32 reserved13[(0x300-0x2f4)/4];
-    //DFI Training 2 Registers
-    volatile uint32 DFITRWRLVLRESP0;          //DFI Training dif_wrlvl_resp Status 0 Register
-    volatile uint32 DFITRWRLVLRESP1;          //DFI Training dif_wrlvl_resp Status 1 Register
-    volatile uint32 DFITRWRLVLRESP2;          //DFI Training dif_wrlvl_resp Status 2 Register
-    volatile uint32 DFITRRDLVLRESP0;          //DFI Training dif_rdlvl_resp Status 0 Register
-    volatile uint32 DFITRRDLVLRESP1;          //DFI Training dif_rdlvl_resp Status 1 Register
-    volatile uint32 DFITRRDLVLRESP2;          //DFI Training dif_rdlvl_resp Status 2 Register
-    volatile uint32 DFITRWRLVLDELAY0;         //DFI Training dif_wrlvl_delay Configuration 0 Register
-    volatile uint32 DFITRWRLVLDELAY1;         //DFI Training dif_wrlvl_delay Configuration 1 Register
-    volatile uint32 DFITRWRLVLDELAY2;         //DFI Training dif_wrlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLDELAY0;         //DFI Training dif_rdlvl_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLDELAY1;         //DFI Training dif_rdlvl_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLDELAY2;         //DFI Training dif_rdlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLGATEDELAY0;     //DFI Training dif_rdlvl_gate_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLGATEDELAY1;     //DFI Training dif_rdlvl_gate_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLGATEDELAY2;     //DFI Training dif_rdlvl_gate_delay Configuration 2 Register
-    volatile uint32 DFITRCMD;                 //DFI Training Command Register
-    uint32 reserved14[(0x3f8-0x340)/4];
-    //IP Status Registers
-    volatile uint32 IPVR;                     //IP Version Register
-    volatile uint32 IPTR;                     //IP Type Register
-}DDR_REG_T, *pDDR_REG_T;
-
-//PHY_REG2
-#define PHY_AUTO_CALIBRATION (1<<0)
-#define PHY_SW_CALIBRATION   (1<<1)
-#define PHY_MEM_TYPE         (6)
-
-//PHY_REG22,25,26,27,28
-#define PHY_RON_DISABLE     (0)
-#define PHY_RON_309ohm      (1)
-#define PHY_RON_155ohm      (2)
-#define PHY_RON_103ohm      (3)
-#define PHY_RON_77ohm       (4)
-#define PHY_RON_63ohm       (5)
-#define PHY_RON_52ohm       (6)
-#define PHY_RON_45ohm       (7)
-//#define PHY_RON_77ohm       (8)
-#define PHY_RON_62ohm       (9)
-//#define PHY_RON_52ohm       (10)
-#define PHY_RON_44ohm       (11)
-#define PHY_RON_39ohm       (12)
-#define PHY_RON_34ohm       (13)
-#define PHY_RON_31ohm       (14)
-#define PHY_RON_28ohm       (15)
-
-#define PHY_RTT_DISABLE     (0)
-#define PHY_RTT_816ohm      (1)
-#define PHY_RTT_431ohm      (2)
-#define PHY_RTT_287ohm      (3)
-#define PHY_RTT_216ohm      (4)
-#define PHY_RTT_172ohm      (5)
-#define PHY_RTT_145ohm      (6)
-#define PHY_RTT_124ohm      (7)
-#define PHY_RTT_215ohm      (8)
-//#define PHY_RTT_172ohm      (9)
-#define PHY_RTT_144ohm      (10)
-#define PHY_RTT_123ohm      (11)
-#define PHY_RTT_108ohm      (12)
-#define PHY_RTT_96ohm       (13)
-#define PHY_RTT_86ohm       (14)
-#define PHY_RTT_78ohm       (15)
-
-/* DDR PHY register struct */
-typedef volatile struct DDRPHY_REG_Tag
-{
-    volatile uint32 PHY_REG1;               //PHY soft reset Register
-    volatile uint32 PHY_REG3;               //Burst type select Register
-    volatile uint32 PHY_REG2;               //PHY DQS squelch calibration Register
-    uint32 reserved1[(0x38-0x0a)/4];
-    volatile uint32 PHY_REG4a;              //CL,AL set register
-    volatile uint32 PHY_REG4b;              //dqs gata delay select bypass mode register
-    uint32 reserved2[(0x54-0x40)/4];
-    volatile uint32 PHY_REG16;              //
-    uint32 reserved3[(0x5c-0x58)/4];
-    volatile uint32 PHY_REG18;              //0x5c
-    volatile uint32 PHY_REG19;
-    uint32 reserved4[(0x68-0x64)/4];
-    volatile uint32 PHY_REG21;              //0x68
-    uint32 reserved5[(0x70-0x6c)/4];     
-    volatile uint32 PHY_REG22;              //0x70
-    uint32 reserved6[(0x80-0x74)/4];
-    volatile uint32 PHY_REG25;              //0x80
-    volatile uint32 PHY_REG26;
-    volatile uint32 PHY_REG27;
-    volatile uint32 PHY_REG28;
-    uint32 reserved7[(0xd4-0x90)/4];
-    volatile uint32 PHY_REG6;               //0xd4
-    volatile uint32 PHY_REG7;
-    uint32 reserved8[(0xe0-0xdc)/4];
-    volatile uint32 PHY_REG8;               //0xe0
-    volatile uint32 PHY_REG0e4;             //use for DQS ODT off
-    uint32 reserved9[(0x114-0xe8)/4];
-    volatile uint32 PHY_REG9;               //0x114
-    volatile uint32 PHY_REG10;
-    uint32 reserved10[(0x120-0x11c)/4];
-    volatile uint32 PHY_REG11;              //0x120
-    volatile uint32 PHY_REG124;             //use for DQS ODT off
-    uint32 reserved11[(0x1c0-0x128)/4];
-    volatile uint32 PHY_REG29;              //0x1c0
-    uint32 reserved12[(0x264-0x1c4)/4];
-	volatile uint32 PHY_REG264;             //use for phy soft reset
-	uint32 reserved13[(0x2b0-0x268)/4];
-    volatile uint32 PHY_REG2a;              //0x2b0
-    uint32 reserved14[(0x2c4-0x2b4)/4];
-//    volatile uint32 PHY_TX_DeSkew[24];        //0x2c4-0x320
-    volatile uint32 PHY_REG30;
-    volatile uint32 PHY_REG31;
-    volatile uint32 PHY_REG32;
-    volatile uint32 PHY_REG33;
-    volatile uint32 PHY_REG34;
-    volatile uint32 PHY_REG35;
-    volatile uint32 PHY_REG36;
-    volatile uint32 PHY_REG37;
-    volatile uint32 PHY_REG38;
-    volatile uint32 PHY_REG39;
-    volatile uint32 PHY_REG40;
-    volatile uint32 PHY_REG41;
-    volatile uint32 PHY_REG42;
-    volatile uint32 PHY_REG43;
-    volatile uint32 PHY_REG44;
-    volatile uint32 PHY_REG45;
-    volatile uint32 PHY_REG46;
-    volatile uint32 PHY_REG47;
-    volatile uint32 PHY_REG48;
-    volatile uint32 PHY_REG49;
-    volatile uint32 PHY_REG50;
-    volatile uint32 PHY_REG51;
-    volatile uint32 PHY_REG52;
-    volatile uint32 PHY_REG53;
-    uint32 reserved15[(0x328-0x324)/4];
-//    volatile uint32 PHY_RX_DeSkew[11];      //0x328-0x350
-    volatile uint32 PHY_REG54;
-    volatile uint32 PHY_REG55;
-    volatile uint32 PHY_REG56;
-    volatile uint32 PHY_REG57;
-    volatile uint32 PHY_REG58;
-    volatile uint32 PHY_REG59;
-    volatile uint32 PHY_REG5a;
-    volatile uint32 PHY_REG5b;
-    volatile uint32 PHY_REG5c;
-    volatile uint32 PHY_REG5d;
-    volatile uint32 PHY_REG5e;    
-    uint32 reserved16[(0x3c4-0x354)/4];
-    volatile uint32 PHY_REG5f;              //0x3c4
-    uint32 reserved17[(0x3e0-0x3c8)/4];
-    volatile uint32 PHY_REG60;
-    volatile uint32 PHY_REG61;
-    volatile uint32 PHY_REG62;            
-}DDRPHY_REG_T, *pDDRPHY_REG_T;
-
-#define pCRU_Reg               ((pCRU_REG)RK_CRU_VIRT)
-#define pGRF_Reg               ((pREG_FILE)RK_GRF_VIRT)
-#define pDDR_Reg               ((pDDR_REG_T)RK_DDR_VIRT)
-#define pPHY_Reg               ((pDDRPHY_REG_T)(RK_DDR_VIRT+RK3036_DDR_PCTL_SIZE))
-#define SysSrv_DdrTiming       (RK_CPU_AXI_BUS_VIRT+0xc)
-#define READ_CS_INFO()   ((((pGRF_Reg->GRF_OS_REG[1])>>11)&0x1)+1)
-#define READ_COL_INFO()  (9+(((pGRF_Reg->GRF_OS_REG[1])>>9)&0x3))
-#define READ_BK_INFO()   (3-(((pGRF_Reg->GRF_OS_REG[1])>>8)&0x1))
-#define READ_CS0_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>6)&0x3))
-#define READ_CS1_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>4)&0x3))
-#define READ_BW_INFO()   (2>>(((pGRF_Reg->GRF_OS_REG[1])&0xc)>>2))    // 0->8bit 1->16bit 2->32bit  grf
-#define READ_DIE_BW_INFO()   (2>>((pGRF_Reg->GRF_OS_REG[1])&0x3))
-
-typedef enum PLL_ID_Tag
-{
-    APLL=0,
-    DPLL,
-    CPLL,
-    GPLL,
-    PLL_MAX
-}PLL_ID;
-
-typedef enum DRAM_TYPE_Tag
-{
-    LPDDR = 0,
-    DDR,
-    DDR2,
-    DDR3,
-    LPDDR2_S2,
-    LPDDR2_S4,
-
-    DRAM_MAX
-}DRAM_TYPE;
-
-struct ddr_freq_t {
-    unsigned long screen_ft_us;
-    unsigned long long t0;
-    unsigned long long t1;
-    unsigned long t2;
-};
-
-
-typedef struct PCTRL_TIMING_Tag
-{
-    uint32 ddrFreq;
-    //Memory Timing Registers
-    uint32 togcnt1u;               //Toggle Counter 1U Register
-    uint32 tinit;                  //t_init Timing Register
-    uint32 trsth;                  //Reset High Time Register
-    uint32 togcnt100n;             //Toggle Counter 100N Register
-    uint32 trefi;                  //t_refi Timing Register
-    uint32 tmrd;                   //t_mrd Timing Register
-    uint32 trfc;                   //t_rfc Timing Register
-    uint32 trp;                    //t_rp Timing Register
-    uint32 trtw;                   //t_rtw Timing Register
-    uint32 tal;                    //AL Latency Register
-    uint32 tcl;                    //CL Timing Register
-    uint32 tcwl;                   //CWL Register
-    uint32 tras;                   //t_ras Timing Register
-    uint32 trc;                    //t_rc Timing Register
-    uint32 trcd;                   //t_rcd Timing Register
-    uint32 trrd;                   //t_rrd Timing Register
-    uint32 trtp;                   //t_rtp Timing Register
-    uint32 twr;                    //t_wr Timing Register
-    uint32 twtr;                   //t_wtr Timing Register
-    uint32 texsr;                  //t_exsr Timing Register
-    uint32 txp;                    //t_xp Timing Register
-    uint32 txpdll;                 //t_xpdll Timing Register
-    uint32 tzqcs;                  //t_zqcs Timing Register
-    uint32 tzqcsi;                 //t_zqcsi Timing Register
-    uint32 tdqs;                   //t_dqs Timing Register
-    uint32 tcksre;                 //t_cksre Timing Register
-    uint32 tcksrx;                 //t_cksrx Timing Register
-    uint32 tcke;                   //t_cke Timing Register
-    uint32 tmod;                   //t_mod Timing Register
-    uint32 trstl;                  //Reset Low Timing Register
-    uint32 tzqcl;                  //t_zqcl Timing Register
-    uint32 tmrr;                   //t_mrr Timing Register
-    uint32 tckesr;                 //t_ckesr Timing Register
-    uint32 tdpd;                   //t_dpd Timing Register
-}PCTL_TIMING_T;
-
-struct ddr_change_freq_sram_param {
-    uint32 freq;
-    uint32 freq_slew;
-};
-
-
-typedef union NOC_TIMING_Tag
-{
-    uint32 d32;
-    struct 
-    {
-        unsigned ActToAct : 6;
-        unsigned RdToMiss : 6;
-        unsigned WrToMiss : 6;
-        unsigned BurstLen : 3;
-        unsigned RdToWr : 5;
-        unsigned WrToRd : 5;
-        unsigned BwRatio : 1;
-    } b;
-}NOC_TIMING_T;
-
-typedef struct BACKUP_REG_Tag
-{
-    PCTL_TIMING_T pctl_timing;
-    NOC_TIMING_T noc_timing;
-    uint32 ddrMR[4];
-    uint32 mem_type;
-    uint32 ddr_speed_bin;
-    uint32 ddr_capability_per_die;
-}BACKUP_REG_T;
-
-BACKUP_REG_T DEFINE_PIE_DATA(ddr_reg);
-static BACKUP_REG_T *p_ddr_reg;
-
-uint32 DEFINE_PIE_DATA(ddr_freq);
-static uint32 *p_ddr_freq;
-uint32 DEFINE_PIE_DATA(ddr_sr_idle);
-uint32 DEFINE_PIE_DATA(ddr_dll_status);  // ddr dllselfrefresh exitdll reset
-
-
-
-static uint32_t  ddr3_cl_cwl[22][4]={
-/*   0~330           330~400         400~533        speed
-* tCK  >3             2.5~3          1.875~2.5     1.875~1.5
-*    cl<<16, cwl    cl<<16, cwl     cl<<16, cwl              */
-    {((5<<16)|5),   ((5<<16)|5),    0          ,   0}, //DDR3_800D
-    {((5<<16)|5),   ((6<<16)|5),    0          ,   0}, //DDR3_800E
-
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   0}, //DDR3_1066E
-    {((5<<16)|5),   ((6<<16)|5),    ((7<<16)|6),   0}, //DDR3_1066F
-    {((5<<16)|5),   ((6<<16)|5),    ((8<<16)|6),   0}, //DDR3_1066G
-
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((7<<16)|7)}, //DDR3_1333F
-    {((5<<16)|5),   ((5<<16)|5),    ((7<<16)|6),   ((8<<16)|7)}, //DDR3_1333G
-    {((5<<16)|5),   ((6<<16)|5),    ((7<<16)|6),   ((9<<16)|7)}, //DDR3_1333H
-    {((5<<16)|5),   ((6<<16)|5),    ((8<<16)|6),   ((10<<16)|7)}, //DDR3_1333J
-
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((7<<16)|7)}, //DDR3_1600G
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((8<<16)|7)}, //DDR3_1600H
-    {((5<<16)|5),   ((5<<16)|5),    ((7<<16)|6),   ((9<<16)|7)}, //DDR3_1600J
-    {((5<<16)|5),   ((6<<16)|5),    ((7<<16)|6),   ((10<<16)|7)}, //DDR3_1600K
-
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((8<<16)|7)}, //DDR3_1866J
-    {((5<<16)|5),   ((5<<16)|5),    ((7<<16)|6),   ((8<<16)|7)}, //DDR3_1866K
-    {((6<<16)|5),   ((6<<16)|5),    ((7<<16)|6),   ((9<<16)|7)}, //DDR3_1866L
-    {((6<<16)|5),   ((6<<16)|5),    ((8<<16)|6),   ((10<<16)|7)}, //DDR3_1866M
-
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((7<<16)|7)}, //DDR3_2133K
-    {((5<<16)|5),   ((5<<16)|5),    ((6<<16)|6),   ((8<<16)|7)}, //DDR3_2133L
-    {((5<<16)|5),   ((5<<16)|5),    ((7<<16)|6),   ((9<<16)|7)}, //DDR3_2133M
-    {((6<<16)|5),   ((6<<16)|5),    ((7<<16)|6),   ((9<<16)|7)},  //DDR3_2133N
-
-    {((6<<16)|5),   ((6<<16)|5),    ((8<<16)|6),   ((10<<16)|7)} //DDR3_DEFAULT
-
-};
-static uint32_t  ddr3_tRC_tFAW[22]={
-/**    tRC    tFAW   */
-    ((50<<16)|50), //DDR3_800D
-    ((53<<16)|50), //DDR3_800E
-
-    ((49<<16)|50), //DDR3_1066E
-    ((51<<16)|50), //DDR3_1066F
-    ((53<<16)|50), //DDR3_1066G
-
-    ((47<<16)|45), //DDR3_1333F
-    ((48<<16)|45), //DDR3_1333G
-    ((50<<16)|45), //DDR3_1333H
-    ((51<<16)|45), //DDR3_1333J
-
-    ((45<<16)|40), //DDR3_1600G
-    ((47<<16)|40), //DDR3_1600H
-    ((48<<16)|40), //DDR3_1600J
-    ((49<<16)|40), //DDR3_1600K
-
-    ((45<<16)|35), //DDR3_1866J
-    ((46<<16)|35), //DDR3_1866K
-    ((47<<16)|35), //DDR3_1866L
-    ((48<<16)|35), //DDR3_1866M
-
-    ((44<<16)|35), //DDR3_2133K
-    ((45<<16)|35), //DDR3_2133L
-    ((46<<16)|35), //DDR3_2133M
-    ((47<<16)|35), //DDR3_2133N
-
-    ((53<<16)|50)  //DDR3_DEFAULT
-};
-
-
-/****************************************************************************
-Internal sram us delay function
-Cpu highest frequency is 1.6 GHz
-1 cycle = 1/1.6 ns
-1 us = 1000 ns = 1000 * 1.6 cycles = 1600 cycles
-*****************************************************************************/
-//__sramdata volatile uint32 loops_per_us;
-volatile uint32 DEFINE_PIE_DATA(loops_per_us);
-#define LPJ_100MHZ  999456UL
-
-/*----------------------------------------------------------------------
-Name	: void __sramlocalfunc ddr_delayus(uint32_t us)
-Desc	: ddr 
-Params  : uint32_t us  --
-Return  : void
-Notes   : loops_per_us  arm freq
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_delayus(uint32 us)
-{
-    do
-    {
-        volatile unsigned int i = (DATA(loops_per_us)*us);
-        if (i < 7) i = 7;
-        barrier();
-        asm volatile(".align 4; 1: subs %0, %0, #1; bne 1b;" : "+r" (i));
-    } while (0);
-}
-
-
-/*----------------------------------------------------------------------
-Name	: __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-Desc	: ddr 
-Params  : pDest ->
-          pSrc  ->
-          words ->
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-
-static __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-{
-    uint32 i;
-
-    for(i=0; i<words; i++)
-    {
-        pDest[i] = pSrc[i];
-    }
-}
-
-/*----------------------------------------------------------------------
-Name	: __sramfunc void ddr_move_to_Lowpower_state(void)
-Desc	: pctl  lowpower state
-Params  : void
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Lowpower_state(void)
-{
-    volatile uint32 value;
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Low_power)
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-            case Access:
-                pDDR_Reg->SCTL = SLEEP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Low_power);
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-/*----------------------------------------------------------------------
-Name	: __sramfunc void ddr_move_to_Access_state(void)
-Desc	: pctl  Access state
-Params  : void
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Access_state(void)
-{
-    volatile uint32 value;
-
-    //set auto self-refresh idle
-    //pDDR_Reg->MCFG1=(pDDR_Reg->MCFG1&0xffffff00)| DATA(ddr_sr_idle) | (1<<31);
-	pDDR_Reg->MCFG1=(pDDR_Reg->MCFG1&0xffffff00)| 0 | (1<<31);
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if((value == Access)
-           || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power)))
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-                break;
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while(!(((pDDR_Reg->STAT.b.ctl_stat) == Access)
-                      || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power))));
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-    pGRF_Reg->GRF_SOC_CON[2] = (1<<16 | 0);//de_hw_wakeup :enable auto sr if sr_idle != 0
-}
-
-/*----------------------------------------------------------------------
-Name	: __sramfunc void ddr_move_to_Config_state(void)
-Desc	: pctl  config state
-Params  : void
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Config_state(void)
-{
-    volatile uint32 value;
-    pGRF_Reg->GRF_SOC_CON[2] = (1<<16 | 1); //hw_wakeup :disable auto sr
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Config)
-        {          
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-            case Access:
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-/*----------------------------------------------------------------------
-Name	: void __sramlocalfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-Desc	:  pctl MCMDddr
-Params  : rank ->ddr rank 
-          cmd  ->
-          arg  ->
-Return  : void 
-Notes   : argbank_addrcmd_addr
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-{
-    pDDR_Reg->MCMD = (start_cmd | (rank<<20) | arg | cmd);
-    dsb();
-    while(pDDR_Reg->MCMD & start_cmd);
-}
-
-__sramdata uint32 copy_data[8]={0xffffffff,0x00000000,0x55555555,0xAAAAAAAA,
-        			0xEEEEEEEE,0x11111111,0x22222222,0xDDDDDDDD};/**/
-EXPORT_PIE_SYMBOL(copy_data[8]);
-static uint32 * p_copy_data;
-
-/*----------------------------------------------------------------------
-Name	: uint32_t __sramlocalfunc ddr_data_training(void)
-Desc	: ddrdata training
-Params  : void
-Return  : void 
-Notes   : data training
-----------------------------------------------------------------------*/
-static uint32_t __sramfunc ddr_data_training(void)
-{
-    uint32 value;
-    value = pDDR_Reg->TREFI;
-    pDDR_Reg->TREFI = 0;
-    // trigger DTT
-    pPHY_Reg->PHY_REG2 = ((pPHY_Reg->PHY_REG2 & (~0x1)) | PHY_AUTO_CALIBRATION);
-    // wait echo byte DTDONE
-	dsb();
-//    ddr_delayus(1);
-    // stop DTT
-    while((pPHY_Reg->PHY_REG62 & 0x3)!=0x3);
-    pPHY_Reg->PHY_REG2 = (pPHY_Reg->PHY_REG2 & (~0x1));
-    // send some auto refresh to complement the lost while DTT
-    ddr_send_command(3, REF_cmd, 0);    
-    ddr_send_command(3, REF_cmd, 0);
-    ddr_send_command(3, REF_cmd, 0);    
-    ddr_send_command(3, REF_cmd, 0);
-
-    // resume auto refresh
-    pDDR_Reg->TREFI = value;
-
-    return(0);
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_set_dll_bypass(uint32 freq)
-Desc    : PHY dll 
-Params  : freq -> ddr
-Return  : void 
-Notes   : 
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_set_dll_bypass(uint32 freq)
-{
-    if(freq <= PHY_DLL_DISABLE_FREQ)
-    {
-        pPHY_Reg->PHY_REG2a = 0x1F;         //set cmd,left right dll bypass
-        pPHY_Reg->PHY_REG19 = 0x08;         //cmd slave dll
-        pPHY_Reg->PHY_REG6 = 0x18;          //left TX DQ DLL
-        pPHY_Reg->PHY_REG7 = 0x00;          //left TX DQS DLL
-        pPHY_Reg->PHY_REG9 = 0x18;          //right TX DQ DLL
-        pPHY_Reg->PHY_REG10 = 0x00;         //right TX DQS DLL
-        
-    }
-    else 
-    {
-        pPHY_Reg->PHY_REG2a = 0x03;         //set cmd,left right dll bypass
-        pPHY_Reg->PHY_REG19 = 0x08;         //cmd slave dll
-        pPHY_Reg->PHY_REG6 = 0x0c;          //left TX DQ DLL
-        pPHY_Reg->PHY_REG7 = 0x00;          //left TX DQS DLL
-        pPHY_Reg->PHY_REG9 = 0x0c;          //right TX DQ DLL
-        pPHY_Reg->PHY_REG10 = 0x00;         //right TX DQS DLL                
-    }
-    dsb();
-    //dll:REG8(RX DQS),REG11(RX DQS),REG18(CMD),REG21(CK) 
-}
-
-static noinline uint32 ddr_get_pll_freq(PLL_ID pll_id)   //APLL-1;CPLL-2;DPLL-3;GPLL-4
-{
-    uint32 ret = 0; 
-
-    // freq = (fin*fbdiv/(refdiv * postdiv1 * postdiv2))
-    if(((pCRU_Reg->CRU_MODE_CON>>(pll_id*4))&1) == 1)             // DPLL Normal mode
-        ret= 24 *((pCRU_Reg->CRU_PLL_CON[pll_id][0]&0xfff))    // NF = 2*(CLKF+1)
-                /((pCRU_Reg->CRU_PLL_CON[pll_id][1]&0x3f)
-                *((pCRU_Reg->CRU_PLL_CON[pll_id][0]>>12)&0x7)*((pCRU_Reg->CRU_PLL_CON[pll_id][1]>>6)&0x7));             // OD = 2^CLKOD
-    else
-        ret = 24;
-
-    return ret;
-}
-
-static __sramdata uint32 clkFbDiv;
-static __sramdata uint32 clkPostDiv1;
-static __sramdata uint32 clkPostDiv2;
-
-/*****************************************
-REFDIV   FBDIV     POSTDIV1/POSTDIV2      FOUTPOSTDIV           freq Step        FOUTPOSRDIV            finally use
-==================================================================================================================
-1        17 - 66   4                      100MHz - 400MHz          6MHz          200MHz  <= 300MHz             <= 150MHz
-1        17 - 66   3                      133MHz - 533MHz          8MHz             
-1        17 - 66   2                      200MHz - 800MHz          12MHz         300MHz  <= 600MHz      150MHz <= 300MHz
-1        17 - 66   1                      400MHz - 1600MHz         24MHz         600MHz  <= 1200MHz     300MHz <= 600MHz
-******************************************/
-//for minimum jitter operation, the highest VCO and FREF frequencies should be used.
-/*----------------------------------------------------------------------
-Name    : uint32_t __sramlocalfunc ddr_set_pll(uint32_t nMHz, uint32_t set)
-Desc    : ddr pll
-Params  : nMHZ -> ddr
-          set  ->0
-                 1ddr pll
-Return  :  
-Notes   : set=0ddr_set_pllset=1 ddr_set_pll
-----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_set_pll(uint32 nMHz, uint32 set)
-{
-    uint32 ret = 0;
-    int delay = 1000;
-    uint32 pll_id=1;  //DPLL     
-    
-    if(nMHz == 24)
-    {
-        ret = 24;
-        goto out;
-    }
-    if(!set)
-    {
-        if(nMHz <= 150) //<300
-        {
-            clkPostDiv1 = 6;
-        }
-        else if(nMHz <=200)
-        {
-            clkPostDiv1 = 4;
-        }
-        else if(nMHz <= 300)
-        {
-            clkPostDiv1 = 3;
-        }
-        else if(nMHz <=450)
-        {
-            clkPostDiv1 = 2;
-        }
-        else
-        {
-            clkPostDiv1 = 1;
-        }
-        clkPostDiv2 = 1;
-        clkFbDiv = (nMHz * 2 * DDR_PLL_REFDIV * clkPostDiv1 * clkPostDiv2)/24;//ddr2
-        ret = (24 * clkFbDiv)/(2 * DDR_PLL_REFDIV * clkPostDiv1 * clkPostDiv2);
-    }
-    else
-    {
-        pCRU_Reg->CRU_MODE_CON = (0x1<<((pll_id*4) +  16)) | (0x0<<(pll_id*4));            //PLL slow-mode
-    
-        pCRU_Reg->CRU_PLL_CON[pll_id][0] = FBDIV(clkFbDiv) | POSTDIV1(clkPostDiv1);
-        pCRU_Reg->CRU_PLL_CON[pll_id][1] = REFDIV(DDR_PLL_REFDIV) | POSTDIV2(clkPostDiv2) | (0x10001<<12);//interger mode
-
-        ddr_delayus(1);
-
-        while (delay > 0) 
-        {
-    	    ddr_delayus(1);
-    		if (pCRU_Reg->CRU_PLL_CON[pll_id][1] & (PLL_LOCK_STATUS))        // wait for pll locked
-    			break;
-    		delay--;
-    	}
-        
-        pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3<<16) | 0x0);           //clk_ddr_src:clk_ddrphy = 1:1       
-        pCRU_Reg->CRU_MODE_CON = (0x1<<((pll_id*4) +  16))  | (0x1<<(pll_id*4));            //PLL normal
-    }
-out:
-    return ret;
-}
-
-uint32 PIE_FUNC(ddr_set_pll)(uint32 nMHz, uint32 set)
-{
-    return ddr_set_pll(nMHz,set);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_set_pll));
-
-/*----------------------------------------------------------------------
-Name    : uint32_t ddr_get_parameter(uint32_t nMHz)
-Desc    : 
-Params  : nMHZ -> ddr     
-Return  : 0 
-          -1 
-          -4 
-Notes   : 
-----------------------------------------------------------------------*/
-static uint32 ddr_get_parameter(uint32 nMHz)
-{
-    uint32_t tmp;
-    uint32_t ret = 0;
-    uint32_t al;
-    uint32_t bl;
-    uint32_t cl;
-    uint32_t cwl;    
-    PCTL_TIMING_T *p_pctl_timing = &(p_ddr_reg->pctl_timing);
-    NOC_TIMING_T  *p_noc_timing=&(p_ddr_reg->noc_timing);
-
-    p_pctl_timing->togcnt1u = nMHz;
-    p_pctl_timing->togcnt100n = nMHz/10;
-    p_pctl_timing->tinit = 200;
-    p_pctl_timing->trsth = 500;
-
-    if(p_ddr_reg->mem_type == DDR3)
-    {
-        if(p_ddr_reg->ddr_speed_bin > DDR3_DEFAULT)
-        {
-            ret = -1;
-            goto out;
-        }
-
-        #define DDR3_tREFI_7_8_us    (78)
-        #define DDR3_tMRD            (4)
-        #define DDR3_tRFC_512Mb      (90)
-        #define DDR3_tRFC_1Gb        (110)
-        #define DDR3_tRFC_2Gb        (160)
-        #define DDR3_tRFC_4Gb        (300)
-        #define DDR3_tRFC_8Gb        (350)
-        #define DDR3_tRTW            (2)   //register min valid value
-        #define DDR3_tRAS            (37)
-        #define DDR3_tRRD            (10)
-        #define DDR3_tRTP            (7)
-        #define DDR3_tWR             (15)
-        #define DDR3_tWTR            (7)
-        #define DDR3_tXP             (7)
-        #define DDR3_tXPDLL          (24)
-        #define DDR3_tZQCS           (80)
-        #define DDR3_tZQCSI          (10000)
-        #define DDR3_tDQS            (1)
-        #define DDR3_tCKSRE          (10)
-        #define DDR3_tCKE_400MHz     (7)
-        #define DDR3_tCKE_533MHz     (6)
-        #define DDR3_tMOD            (15)
-        #define DDR3_tRSTL           (100)
-        #define DDR3_tZQCL           (320)
-        #define DDR3_tDLLK           (512)
-
-        al = 0;
-        bl = 8;
-        if(nMHz <= 330)
-        {
-            tmp = 0;
-        }
-        else if(nMHz<=400)
-        {
-            tmp = 1;
-        }
-        else if(nMHz<=533)
-        {
-            tmp = 2;
-        }
-        else //666MHz
-        {
-            tmp = 3;
-        }
-        if(nMHz < DDR3_DDR2_DLL_DISABLE_FREQ)       //when dll bypss cl = cwl = 6;
-        {
-            cl = 6;
-            cwl = 6;
-        }
-        else
-        {
-            cl = ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] >> 16;
-            cwl = ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] & 0x0ff;
-        }
-        if(cl == 0)
-        {
-            ret = -4; //
-        }
-        if(nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ)     
-        {
-            p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_DIS;
-        }
-        else
-        {
-            p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_120;
-        }
-        p_ddr_reg->ddrMR[2] = DDR3_MR2_CWL(cwl) /* | DDR3_Rtt_WR_60 */;
-        p_ddr_reg->ddrMR[3] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 7.8us
-         */
-        p_pctl_timing->trefi = DDR3_tREFI_7_8_us;
-        /*
-         * tMRD, 4 tCK
-         */
-        p_pctl_timing->tmrd = DDR3_tMRD & 0x7;
-        /*
-         * tRFC, 90ns(512Mb),110ns(1Gb),160ns(2Gb),300ns(4Gb),350ns(8Gb)
-         */
-        if(p_ddr_reg->ddr_capability_per_die <= 0x4000000)         // 512Mb 90ns
-        {
-            tmp = DDR3_tRFC_512Mb;
-        }
-        else if(p_ddr_reg->ddr_capability_per_die <= 0x8000000)    // 1Gb 110ns
-        {
-            tmp = DDR3_tRFC_1Gb;
-        }
-        else if(p_ddr_reg->ddr_capability_per_die <= 0x10000000)   // 2Gb 160ns
-        {
-            tmp = DDR3_tRFC_2Gb;
-        }
-        else if(p_ddr_reg->ddr_capability_per_die <= 0x20000000)   // 4Gb 300ns
-        {
-            tmp = DDR3_tRFC_4Gb;
-        }
-        else    // 8Gb  350ns
-        {
-            tmp = DDR3_tRFC_8Gb;
-        }
-        p_pctl_timing->trfc = (tmp*nMHz+999)/1000;
-        /*
-         * tXSR, =tDLLK=512 tCK
-         */
-        p_pctl_timing->texsr = DDR3_tDLLK;
-        /*
-         * tRP=CL
-         */
-        p_pctl_timing->trp = cl;
-        /*
-         * WrToMiss=WL*tCK + tWR + tRP + tRCD
-         */
-        p_noc_timing->b.WrToMiss = ((cwl+((DDR3_tWR*nMHz+999)/1000)+cl+cl)&0x3F);
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin]>>16)*nMHz+999)/1000)&0x3F);
-        p_noc_timing->b.ActToAct = ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin]>>16)*nMHz+999)/1000)&0x3F);
-
-        p_pctl_timing->trtw = (cl+2-cwl);//DDR3_tRTW;
-        p_noc_timing->b.RdToWr = ((cl+2-cwl)&0x1F);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRAS, 37.5ns(400MHz)     37.5ns(533MHz)
-         */
-        p_pctl_timing->tras = (((DDR3_tRAS*nMHz+(nMHz>>1)+999)/1000)&0x3F);
-        /*
-         * tRCD=CL
-         */
-        p_pctl_timing->trcd = cl;
-        /*
-         * tRRD = max(4nCK, 7.5ns), DDR3-1066(1K), DDR3-1333(2K), DDR3-1600(2K)
-         *        max(4nCK, 10ns), DDR3-800(1K,2K), DDR3-1066(2K)
-         *        max(4nCK, 6ns), DDR3-1333(1K), DDR3-1600(1K)
-         *
-         */
-        tmp = ((DDR3_tRRD*nMHz+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        /*
-         * tRTP, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trtp = tmp&0xF;
-        /*
-         * RdToMiss=tRTP+tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = ((tmp+cl+cl-(bl>>1))&0x3F);
-        /*
-         * tWR, 15ns
-         */
-        tmp = ((DDR3_tWR*nMHz+999)/1000);
-        p_pctl_timing->twr = tmp&0x1F;
-        if(tmp<9)
-            tmp = tmp - 4;
-        else
-            tmp = tmp>>1;
-        p_ddr_reg->ddrMR[0] = DDR3_BL8 | DDR3_CL(cl) | DDR3_WR(tmp);
-
-        /*
-         * tWTR, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tWTR*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_noc_timing->b.WrToRd = ((tmp+cwl)&0x1F);
-        /*
-         * tXP, max(3 tCK, 7.5ns)(<933MHz)
-         */
-        tmp = ((DDR3_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        /*
-         * tXPDLL, max(10 tCK,24ns)
-         */
-        tmp = ((DDR3_tXPDLL*nMHz+999)/1000);
-        if(tmp < 10)
-        {
-            tmp = 10;
-        }
-        p_pctl_timing->txpdll = tmp & 0x3F;
-        /*
-         * tZQCS, max(64 tCK, 80ns)
-         */
-        tmp = ((DDR3_tZQCS*nMHz+999)/1000);
-        if(tmp < 64)
-        {
-            tmp = 64;
-        }
-        p_pctl_timing->tzqcs = tmp&0x7F;
-        /*
-         * tZQCSI,
-         */
-        p_pctl_timing->tzqcsi = DDR3_tZQCSI;
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = DDR3_tDQS;
-        /*
-         * tCKSRE, max(5 tCK, 10ns)
-         */
-        tmp = ((DDR3_tCKSRE*nMHz+999)/1000);
-        if(tmp < 5)
-        {
-            tmp = 5;
-        }
-        p_pctl_timing->tcksre = tmp & 0x1F;
-        /*
-         * tCKSRX, max(5 tCK, 10ns)
-         */
-        p_pctl_timing->tcksrx = tmp & 0x1F;
-        /*
-         * tCKE, max(3 tCK,7.5ns)(400MHz) max(3 tCK,5.625ns)(533MHz)
-         */
-        if(nMHz>=533)
-        {
-            tmp = ((DDR3_tCKE_533MHz*nMHz+999)/1000);
-        }
-        else
-        {
-            tmp = ((DDR3_tCKE_400MHz*nMHz+(nMHz>>1)+999)/1000);
-        }
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tcke = tmp & 0x7;
-        /*
-         * tCKESR, =tCKE + 1tCK
-         */
-        p_pctl_timing->tckesr = (tmp+1)&0xF;
-        /*
-         * tMOD, max(12 tCK,15ns)
-         */
-        tmp = ((DDR3_tMOD*nMHz+999)/1000);
-        if(tmp < 12)
-        {
-            tmp = 12;
-        }
-        p_pctl_timing->tmod = tmp&0x1F;
-        /*
-         * tRSTL, 100ns
-         */
-        p_pctl_timing->trstl = ((DDR3_tRSTL*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCL, max(256 tCK, 320ns)
-         */
-        tmp = ((DDR3_tZQCL*nMHz+999)/1000);
-        if(tmp < 256)
-        {
-            tmp = 256;
-        }
-        p_pctl_timing->tzqcl = tmp&0x3FF;
-        /*
-         * tMRR, 0 tCK
-         */
-        p_pctl_timing->tmrr = 0;
-        /*
-         * tDPD, 0
-         */
-        p_pctl_timing->tdpd = 0;
-
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = ((bl>>1)&0x7);
-    }
-    else
-    {
-        ret = -1;
-    }
-        
-out:
-    return ret;
-}
-
-/*----------------------------------------------------------------------
-Name    : uint32_t __sramlocalfunc ddr_update_timing(void)
-Desc    : pctl phy timing
-Params  : void  
-Return  : 0 
-Notes   : 
-----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_timing(void)
-{
-    PCTL_TIMING_T *p_pctl_timing = &(DATA(ddr_reg).pctl_timing);
-    NOC_TIMING_T  *p_noc_timing = &(DATA(ddr_reg).noc_timing);
-
-    ddr_copy((uint32 *)&(pDDR_Reg->TOGCNT1U), (uint32*)&(p_pctl_timing->togcnt1u), 34);
-    pPHY_Reg->PHY_REG3 = (0x12 << 1) | (ddr2_ddr3_bl_8);   //0x12
-    pPHY_Reg->PHY_REG4a = ((p_pctl_timing->tcl << 4) | (p_pctl_timing->tal));
-    *(volatile uint32 *)SysSrv_DdrTiming = p_noc_timing->d32;
-    // Update PCTL BL
-//    if(DATA(ddr_reg).mem_type == DDR3)
-    {
-        pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~(0x1|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | ddr2_ddr3_bl_8 | tfaw_cfg(5)|pd_exit_slow|pd_type(1);
-        pDDR_Reg->DFITRDDATAEN   = (pDDR_Reg->TAL + pDDR_Reg->TCL)-3;  //trdata_en = rl-3
-        pDDR_Reg->DFITPHYWRLAT   = pDDR_Reg->TCWL-1;
-    }
-    return 0;
-}
-
-/*----------------------------------------------------------------------
-Name    : uint32_t __sramlocalfunc ddr_update_mr(void)
-Desc    : MR
-Params  : void  
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_mr(void)
-{
-    uint32 cs;
-
-    cs = READ_CS_INFO();
-    cs = cs + (1 << cs);                               //case 0:1rank cs=1; case 1:2rank cs =3;
-    if(DATA(ddr_freq) > DDR3_DDR2_DLL_DISABLE_FREQ)
-    {
-        if(DATA(ddr_dll_status) == DDR3_DLL_DISABLE)  // off -> on
-        {
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr((DATA(ddr_reg).ddrMR[1])));  //DLL enable
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr(((DATA(ddr_reg).ddrMR[0]))| DDR3_DLL_RESET));  //DLL reset
-            ddr_delayus(2);  //at least 200 DDR cycle
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((DATA(ddr_reg).ddrMR[0])));
-            DATA(ddr_dll_status) = DDR3_DLL_ENABLE;
-        }
-        else // on -> on
-        {
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr((DATA(ddr_reg).ddrMR[1])));
-            ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((DATA(ddr_reg).ddrMR[0])));
-        }
-    }
-    else
-    {
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x1) | cmd_addr(((DATA(ddr_reg).ddrMR[1])) | DDR3_DLL_DISABLE));  //DLL disable
-        ddr_send_command(cs, MRS_cmd, bank_addr(0x0) | cmd_addr((DATA(ddr_reg).ddrMR[0])));
-        DATA(ddr_dll_status) = DDR3_DLL_DISABLE;
-    }
-    ddr_send_command(cs, MRS_cmd, bank_addr(0x2) | cmd_addr((DATA(ddr_reg).ddrMR[2])));
-
-    return 0;
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_update_odt(void)
-Desc    : update PHY odt & PHY driver impedance
-Params  : void  
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_update_odt(void)
-{
-    uint32 tmp;
-    
-    //adjust DRV and ODT
-    if(DATA(ddr_freq) <= PHY_ODT_DISABLE_FREQ)
-    {
-        pPHY_Reg->PHY_REG27 = PHY_RTT_DISABLE;  //dynamic RTT disable, Left 8bit ODT
-        pPHY_Reg->PHY_REG28 = PHY_RTT_DISABLE;  //Right 8bit ODT
-        pPHY_Reg->PHY_REG0e4 = (0x0E & 0xc)|0x1;//off DQS ODT  bit[1:0]=2'b01 
-        pPHY_Reg->PHY_REG124 = (0x0E & 0xc)|0x1;//off DQS ODT  bit[1:0]=2'b01 
-    }
-    else
-    {
-        pPHY_Reg->PHY_REG27 = ((PHY_RTT_215ohm<<4) | PHY_RTT_215ohm);       
-        pPHY_Reg->PHY_REG28 = ((PHY_RTT_215ohm<<4) | PHY_RTT_215ohm);    
-        pPHY_Reg->PHY_REG0e4 = 0x0E;           //on DQS ODT default:0x0E
-        pPHY_Reg->PHY_REG124 = 0x0E;           //on DQS ODT default:0x0E
-    }
-
-    tmp = ((PHY_RON_45ohm<<4) | PHY_RON_45ohm);     
-    pPHY_Reg->PHY_REG16 = tmp;  //CMD driver strength
-    pPHY_Reg->PHY_REG22 = tmp;  //CK driver strength    
-    pPHY_Reg->PHY_REG25 = tmp;  //Left 8bit DQ driver strength
-    pPHY_Reg->PHY_REG26 = tmp;  //Right 8bit DQ driver strength
-    dsb();
-}
-
-/*----------------------------------------------------------------------
-Name    : __sramfunc void ddr_adjust_config(uint32_t dram_type)
-Desc    : 
-Params  : dram_type ->
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-#if 0
-__sramfunc void ddr_adjust_config(uint32_t dram_type)
-{
-//    uint32 value;
-    unsigned long save_sp;
-    uint32 i;
-    volatile uint32 n; 
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-
-    //get data training address before idle port
-//    value = ddr_get_datatraing_addr();    //Inno PHY training address
-
-    /** 1. Make sure there is no host access */
-    flush_cache_all();
-    outer_flush_all();
-    flush_tlb_all();
-    DDR_SAVE_SP(save_sp);
-
-    for(i=0;i<2;i++)        //8KB SRAM
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->PHY_REG1;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= *(volatile uint32_t *)SysSrv_DdrTiming;
-    dsb();
-    
-    //enter config state
-    ddr_move_to_Config_state();
-//    pDDR_Reg->DFIODTCFG = ((1<<3) | (1<<11));  //loader
-    pPHY_Reg->PHY_REG5d = 0X77;
-    pPHY_Reg->PHY_REG5e = 0X77;
-    //set auto power down idle
-    pDDR_Reg->MCFG=(pDDR_Reg->MCFG&0xffff00ff)|(PD_IDLE<<8);
-
-    //enable the hardware low-power interface
-    pDDR_Reg->SCFG.b.hw_low_power_en = 1;
-
-    ddr_update_odt();
-
-    //enter access state
-    ddr_move_to_Access_state();
-
-    DDR_RESTORE_SP(save_sp);
-}
-#endif 
-
-static void __sramfunc idle_port(void)
-{
-    int i;
-    uint32 clk_gate[10];
-
-    //save clock gate status
-    for(i=0;i<10;i++)
-    {
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-    }
-    //enable all clock gate for request idle
-    for(i=0;i<10;i++)
-    {
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-    }
-
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+peri_pwr_idlereq))+(1 << peri_pwr_idlereq);         //peri   bit 12
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & peri_pwr_idle) == 0);//   bit 23
-
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+vio_pwr_idlereq))+(1 << vio_pwr_idlereq);          //vio
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & vio_pwr_idle) == 0);
-  
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+vpu_pwr_idlereq))+(1 << vpu_pwr_idlereq);          //vpu
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & vpu_pwr_idle) == 0);
-      
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+gpu_pwr_idlereq))+(1 << gpu_pwr_idlereq);          //gpu
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & gpu_pwr_idle) == 0);
-    
-	//resume clock gate status
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-}
-
-
-static void __sramfunc deidle_port(void)
-{
-    int i;
-    uint32 clk_gate[10];
-
-    //save clock gate status
-    for(i=0;i<10;i++)
-    {
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-    }
-    //enable all clock gate for request idle
-    for(i=0;i<10;i++)
-    {
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-    }
-   
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+peri_pwr_idlereq))+(0 << peri_pwr_idlereq);         //peri   bit 12
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & peri_pwr_idle) != 0);
-
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+vio_pwr_idlereq))+(0 << vio_pwr_idlereq);          //vio
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & vio_pwr_idle) != 0);
-      
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+vpu_pwr_idlereq))+(0 << vpu_pwr_idlereq);          //vpu
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & vpu_pwr_idle) != 0);
-        
-    pGRF_Reg->GRF_SOC_CON[2] = (1 << (16+gpu_pwr_idlereq))+(0 << gpu_pwr_idlereq);          //gpu
-    dsb();
-    while( (pGRF_Reg->GRF_SOC_STATUS0 & gpu_pwr_idle) != 0);
-    
-    //resume clock gate status
-    for(i=0;i<10;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-
-}
-
-
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_selfrefresh_enter(uint32 nMHz)
-Desc    : 
-Params  : nMHz ->ddr
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-/*
-static void __sramfunc ddr_selfrefresh_enter(uint32 nMHz)
-{    
-    ddr_move_to_Config_state();
-    ddr_move_to_Lowpower_state();
-	pPHY_Reg->PHY_REG264 &= ~(1<<1);
-    pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 & (~(0x3<<2)));     //phy soft reset
-    dsb();
-    pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (1<<2);  //disable DDR PHY clock
-    ddr_delayus(1);
-}
-*/
-static uint32 dtt_buffer[8];
-
-/*----------------------------------------------------------------------
-Name    : void ddr_dtt_check(void)
-Desc    : data training check
-Params  : void
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static void ddr_dtt_check(void)
-{
-    uint32 i;
-    for(i=0;i<8;i++)
-    {
-        dtt_buffer[i] = p_copy_data[i];
-    }
-    dsb();
-    flush_cache_all();
-    outer_flush_all();
-    for(i=0;i<8;i++)
-    {
-        if(dtt_buffer[i] != p_copy_data[i])
-        {
-//            sram_printascii("DTT failed!\n");
-            break;
-        }
-        dtt_buffer[i] = 0;
-    }
-
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_selfrefresh_exit(void)
-Desc    : 
-Params  : void
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-#if 0
-static void __sramfunc ddr_selfrefresh_exit(void)
-{
-    pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (0<<2);  //enable DDR PHY clock
-    dsb();
-    ddr_delayus(1);
-	pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 | (0x3 << 2)); //phy soft de-reset
-	pPHY_Reg->PHY_REG264 |= (1<<1);
-	dsb();
-    ddr_move_to_Config_state();    
-    ddr_data_training(); 
-    ddr_move_to_Access_state();
-//    ddr_dtt_check();
-}
-#endif
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-Desc    : ddr plltimingmr
-Params  : freq_slew : 1  0
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-{
-    uint32 value_100n, value_1u;
-    
-    if(freq_slew == 1)
-    {
-        value_100n = DATA(ddr_reg).pctl_timing.togcnt100n;
-        value_1u = DATA(ddr_reg).pctl_timing.togcnt1u;
-        DATA(ddr_reg).pctl_timing.togcnt1u = pDDR_Reg->TOGCNT1U;
-        DATA(ddr_reg).pctl_timing.togcnt100n = pDDR_Reg->TOGCNT100N;
-        ddr_update_timing();                
-        ddr_update_mr();
-        DATA(ddr_reg).pctl_timing.togcnt100n = value_100n;
-        DATA(ddr_reg).pctl_timing.togcnt1u = value_1u;
-    }
-    else
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-    }
-
-    pDDR_Reg->TZQCSI = 0;    
-
-}
-
-
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-Desc    : ddr plltimingmr
-Params  : freq_slew : 1  0
-Return  : void
-Notes   : 
-----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-{
-    if(freq_slew == 1)
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-        pDDR_Reg->TZQCSI = DATA(ddr_reg).pctl_timing.tzqcsi;
-    }
-    else
-    {
-        ddr_update_timing();
-        ddr_update_mr();
-    }
-    ddr_data_training();
-}
-
-static void __sramfunc ddr_SRE_2_SRX(uint32 freq, uint32 freq_slew)
-{
-    idle_port();
-
-    ddr_move_to_Config_state(); 
-    DATA(ddr_freq) = freq;
-    ddr_change_freq_in(freq_slew);
-    ddr_move_to_Lowpower_state();
-    pPHY_Reg->PHY_REG264 &= ~(1<<1);
-    pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 & (~(0x3<<2)));     //phy soft reset
-    dsb();    
-    /** 3. change frequence  */
-    FUNC(ddr_set_pll)(freq,1);
-    ddr_set_dll_bypass(freq);    //set phy dll mode;
-	pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 | (0x3 << 2)); //phy soft de-reset
-	pPHY_Reg->PHY_REG264 |= (1<<1);
-	dsb();
-	ddr_update_odt();
-    ddr_move_to_Config_state();
-    ddr_change_freq_out(freq_slew);
-    ddr_move_to_Access_state();
-
-    deidle_port();
-}
-
-void PIE_FUNC(ddr_change_freq_sram)(void *arg)
-{
-    struct ddr_change_freq_sram_param *param = arg;  
-    /* Make sure ddr_SRE_2_SRX paramter less than 4 */
-    ddr_SRE_2_SRX(param->freq, param->freq_slew);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_change_freq_sram));
-
-/*----------------------------------------------------------------------
-Name    : uint32_t __sramfunc ddr_change_freq(uint32_t nMHz)
-Desc    : ddr
-Params  : nMHz -> 
-Return  : 
-Notes   :
-----------------------------------------------------------------------*/
-static uint32 ddr_change_freq_sram(uint32 nMHz, struct ddr_freq_t ddr_freq_t)
-{
-    uint32 ret;
-    uint32 i;
-    volatile uint32 n;	
-    unsigned long flags;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-
-    struct ddr_change_freq_sram_param param;
-    //uint32 freq;
-	uint32 freq_slew;
-	uint32 arm_freq;
-	
-    arm_freq= ddr_get_pll_freq(APLL);   
-    *kern_to_pie(rockchip_pie_chunk, &DATA(loops_per_us)) = LPJ_100MHZ*arm_freq/1000000;  
-    ret =(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_set_pll)))(nMHz,0);
-    if(ret == *p_ddr_freq)
-    {
-        goto out;
-    }
-    else 
-    {
-        freq_slew = (ret > *p_ddr_freq)? 1 : -1;
-    }    
-    ddr_get_parameter(ret);
-    //*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq))= ret;
-    /** 1. Make sure there is no host access */
-    local_irq_save(flags);
-	local_fiq_disable();
-    flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-	//DDR_SAVE_SP(save_sp);
-	
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)  
-        n = ddr_freq_t.screen_ft_us;
-        n = ddr_freq_t.t0;
-        dsb();
-    
-        if(ddr_freq_t.screen_ft_us > 0){
-    
-            ddr_freq_t.t1 = cpu_clock(0);
-            ddr_freq_t.t2 = (u32)(ddr_freq_t.t1 - ddr_freq_t.t0);   //ns
-    
-    
-            if( (ddr_freq_t.t2 > ddr_freq_t.screen_ft_us*1000) && (ddr_freq_t.screen_ft_us != 0xfefefefe)){
-            
-            //DDR_RESTORE_SP(save_sp);
-            local_fiq_enable();
-            local_irq_restore(flags);
-            return 0;
-            }else{                      
-                rk_fb_poll_wait_frame_complete();
-            }
-        }
-#endif
-
-	for(i=0;i<2;i++)    //8KB SRAM
-	{
-	    n=temp[1024*i];
-        barrier();
-	}
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->PHY_REG1;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= *(volatile uint32_t *)SysSrv_DdrTiming;
-    n= pGRF_Reg->GRF_SOC_STATUS0;
-    dsb();
-    param.freq = ret;
-    param.freq_slew = freq_slew;
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_change_freq_sram)),
-                    &param,
-                    rockchip_sram_stack-(NR_CPUS-1)*PAUSE_CPU_STACK_SIZE);
-    /** 5. Issues a Mode Exit command   */
-   // DDR_RESTORE_SP(save_sp);
-    ddr_dtt_check();
-    local_fiq_enable();
-    local_irq_restore(flags);
-//    clk_set_rate(clk_get(NULL, "ddr_pll"), 0);    
-out:
-    return ret;
-}
-
-static uint32 _ddr_change_freq_3036(uint32_t nMHz)
-{
-	struct ddr_freq_t ddr_freq_t;
-	ddr_freq_t.screen_ft_us = 0;
-
-	return ddr_change_freq_sram(nMHz,ddr_freq_t);
-}
-
-EXPORT_SYMBOL(_ddr_change_freq_3036);
-
-static void __sramlocalfunc ddr_selfrefresh_enter(uint32 nMHz)
-{    
-    ddr_move_to_Config_state();
-    ddr_move_to_Lowpower_state();
-	pPHY_Reg->PHY_REG264 &= ~(1<<1);
-    pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 & (~(0x3<<2)));     //phy soft reset
-    dsb();
-    pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (1<<2);  //disable DDR PHY clock
-    ddr_delayus(1);
-}
-
-static void __sramlocalfunc ddr_selfrefresh_exit(void)
-{
-    pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1<<2)<<16) | (0<<2);  //enable DDR PHY clock
-    dsb();
-    ddr_delayus(1);
-	pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 | (0x3 << 2)); //phy soft de-reset
-	pPHY_Reg->PHY_REG264 |= (1<<1);
-	dsb();
-    ddr_move_to_Config_state();    
-    ddr_data_training(); 
-    ddr_move_to_Access_state();
-    /*ddr_dtt_check();*/
-}
-
-void PIE_FUNC(ddr_suspend)(void)
-{
-	ddr_selfrefresh_enter(0);
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x0 << (1 * 4));	/*PLL slow-mode*/
-	dsb();
-	ddr_delayus(1);
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x1 << 13);	/*PLL power-down*/
-	dsb();
-	ddr_delayus(1);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_suspend));
-
-/*----------------------------------------------------------------------
-Name    : void __sramfunc ddr_suspend(void)
-Desc    : ddr suspend
-Params  : void
-Return  : void
-Notes   :  
-----------------------------------------------------------------------*/
-#if 0
-void ddr_suspend(void)
-{
-	uint32 i;
-	volatile uint32 n;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-	/** 1. Make sure there is no host access */
-	flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-
-	/*sram size = 8KB*/
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	n = pGRF_Reg->GRF_SOC_STATUS0;
-	dsb();
-
-	fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_suspend)) ();
-}
-EXPORT_SYMBOL(ddr_suspend);
-#endif 
-
-void PIE_FUNC(ddr_resume)(void)
-{
-	uint32 delay = 1000;
-
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x0 << 13);	/*PLL no power-down*/
-	dsb();
-	while (delay > 0) {
-		ddr_delayus(1);
-		if (pCRU_Reg->CRU_PLL_CON[1][1] & (0x1 << 10))
-			break;
-		delay--;
-	}
-
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x1 << (1 * 4));	/*PLL normal*/
-	dsb();
-
-	ddr_selfrefresh_exit();
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_resume));
-#if 0
-static uint32 ddr_get_cap(void)
-{
-    uint32 cs, bank, row, col,row1;
-
-    bank = READ_BK_INFO();
-    row = READ_CS0_ROW_INFO();
-    col = READ_COL_INFO();
-    cs = READ_CS_INFO(); 
-    if(cs>1)
-    {
-        row1 = READ_CS1_ROW_INFO();
-        return ((1 << (row + col + bank + 1))+(1 << (row1 + col + bank + 1)));
-    }
-    else
-    {
-        return (1 << (row + col + bank + 1));
-    }
-}
-#endif 
-#if 0
-/*----------------------------------------------------------------------
-Name    : int ddr_init(uint32_t dram_speed_bin, uint32_t freq)
-Desc    : ddr  
-Params  : dram_speed_bin ->ddr
-          freq ->
-Return  : 0 
-Notes   :  
-----------------------------------------------------------------------*/
-static int ddr_init(uint32_t dram_speed_bin, uint32 freq)
-{
-    volatile uint32_t value = 0;
-    uint32_t cs,die=1;
-
-    ddr_print("version 1.00 20140704 \n");
-    cs = READ_CS_INFO();    //case 0:1rank ; case 1:2rank ; 
-
-    p_ddr_reg = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-    p_ddr_freq =kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq)); 
-    p_ddr_reg->mem_type = ((pGRF_Reg->GRF_OS_REG[1] >> 13) &0x7);
-    p_ddr_reg->ddr_speed_bin = dram_speed_bin;
-    *p_ddr_freq= 0;
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = 0;
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_dll_status)) = DDR3_DLL_DISABLE;
-    p_copy_data = kern_to_pie(rockchip_pie_chunk, &copy_data[0]);
-    if(p_ddr_reg->mem_type != DDR3)
-    {        
-        ddr_print("ddr type error type=%d\n",(p_ddr_reg->mem_type));
-        return -1;
-    }
-    
-    switch(READ_DIE_BW_INFO())
-    {
-        case 0:         //8bit
-            die = 2;
-            break;
-		case 1:         //16bit 
-			die = 1;
-			break;
-        default:
-            ddr_print("ddr die BW error=%d\n",READ_DIE_BW_INFO());
-            break;
-    }
-	
-    
-    //get capability per chip, not total size, used for calculate tRFC
-    p_ddr_reg->ddr_capability_per_die = ddr_get_cap()/(cs * die);
-    ddr_print("%d CS, ROW=%d, Bank=%d, COL=%d, Total Capability=%dMB\n", 
-                                                                    cs, \
-                                                                    READ_CS0_ROW_INFO(), \
-                                                                    (0x1<<(READ_BK_INFO())), \
-                                                                    READ_COL_INFO(), \
-                                                                    (ddr_get_cap()>>20));/*
-*/                                                                    
-    //ddr_adjust_config(p_ddr_reg->mem_type);
-
-    if(freq != 0)
-        value=_ddr_change_freq(freq);
-
-    /*clk_set_rate(clk_get(NULL, "ddr"), 0);*/
-    ddr_print("init success!!! freq=%dMHz\n", (int)value);
-    return 0;
-}
-#endif
-
diff --git a/arch/arm/mach-rockchip/ddr_rk3126.c b/arch/arm/mach-rockchip/ddr_rk3126.c
deleted file mode 100644
index 952e2a826719..000000000000
--- a/arch/arm/mach-rockchip/ddr_rk3126.c
+++ /dev/null
@@ -1,2710 +0,0 @@
-/*
- * arch/arm/mach-rk2928/ddr.c-- for ddr3&ddr2
- *
- * Function Driver for DDR controller
- *
- * Copyright (C) 2012 Fuzhou Rockchip Electronics Co.,Ltd
- * Author:
- * hcy@rock-chips.com
- * yk@rock-chips.com
- * typ@rock-chips.com
- *
- * v1.00
- */
-
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/cpu.h>
-#include <dt-bindings/clock/ddr.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rk_fb.h>
-
-typedef uint32_t uint32;
-
-#define DDR3_DDR2_DLL_DISABLE_FREQ    (300)	/* dll disable*/
-#define DDR3_DDR2_ODT_DISABLE_FREQ    (333)	/*odt disable*/
-#define SR_IDLE                       (0x1)	/*unit:32*DDR clk cycle, and 0 for disable auto self-refresh*/
-#define PD_IDLE                       (0x40)	/*unit:DDR clk cycle, and 0 for disable auto power-down*/
-#define PHY_ODT_DISABLE_FREQ          (333)	/*odt disable*/
-#define PHY_DLL_DISABLE_FREQ          (266)	/*dll bypass*/
-
-#define ddr_print(x...) printk("DDR DEBUG: " x)
-
-#define SRAM_CODE_OFFSET        rockchip_sram_virt
-#define SRAM_SIZE               rockchip_sram_size
-
-#ifdef CONFIG_FB_ROCKCHIP
-#define DDR_CHANGE_FREQ_IN_LCDC_VSYNC
-#endif
-
-/*#define PHY_RX_PHASE_CAL*/
-#define PHY_DE_SKEW_STEP  (20)
-/***********************************
- * DDR3 define
- ***********************************/
-/*mr0 for ddr3*/
-#define DDR3_BL8          (0)
-#define DDR3_BC4_8        (1)
-#define DDR3_BC4          (2)
-#define DDR3_CL(n)        (((((n)-4)&0x7)<<4)|((((n)-4)&0x8)>>1))
-#define DDR3_WR(n)        (((n)&0x7)<<9)
-#define DDR3_DLL_RESET    (1<<8)
-#define DDR3_DLL_DeRESET  (0<<8)
-
-/*mr1 for ddr3*/
-#define DDR3_DLL_ENABLE    (0)
-#define DDR3_DLL_DISABLE   (1)
-#define DDR3_MR1_AL(n)  (((n)&0x7)<<3)
-
-#define DDR3_DS_40            (0)
-#define DDR3_DS_34            (1<<1)
-#define DDR3_Rtt_Nom_DIS      (0)
-#define DDR3_Rtt_Nom_60       (1<<2)
-#define DDR3_Rtt_Nom_120      (1<<6)
-#define DDR3_Rtt_Nom_40       ((1<<2)|(1<<6))
-
-/*mr2 for ddr3*/
-#define DDR3_MR2_CWL(n) ((((n)-5)&0x7)<<3)
-#define DDR3_Rtt_WR_DIS       (0)
-#define DDR3_Rtt_WR_60        (1<<9)
-#define DDR3_Rtt_WR_120       (2<<9)
-
-#define DDR_PLL_REFDIV  (1)
-#define FBDIV(n)        ((0xFFF<<16) | (n&0xfff))
-#define REFDIV(n)       ((0x3F<<16) | (n&0x3f))
-#define POSTDIV1(n)     ((0x7<<(12+16)) | ((n&0x7)<<12))
-#define POSTDIV2(n)     ((0x7<<(6+16)) | ((n&0x7)<<6))
-
-#define PLL_LOCK_STATUS  (0x1<<10)
- /*CRU Registers updated*/
-typedef volatile struct tagCRU_STRUCT {
-	uint32 CRU_PLL_CON[4][4];
-	uint32 CRU_MODE_CON;
-	uint32 CRU_CLKSEL_CON[35];
-	uint32 CRU_CLKGATE_CON[11];	/*0xd0*/
-	uint32 reserved1;	/*0xfc*/
-	uint32 CRU_GLB_SRST_FST_VALUE;	/*0x100*/
-	uint32 CRU_GLB_SRST_SND_VALUE;
-	uint32 reserved2[2];
-	uint32 CRU_SOFTRST_CON[9];	/*0x110*/
-	uint32 CRU_MISC_CON;	/*0x134*/
-	uint32 reserved3[2];
-	uint32 CRU_GLB_CNT_TH;	/*0x140*/
-	uint32 reserved4[3];
-	uint32 CRU_GLB_RST_ST;	/*0x150*/
-	uint32 reserved5[(0x1c0 - 0x154) / 4];
-	uint32 CRU_SDMMC_CON[2];	/*0x1c0*/
-	uint32 CRU_SDIO_CON[2];
-	uint32 reserved6[2];
-	uint32 CRU_EMMC_CON[2];	/*0x1d8*/
-	uint32 reserved7[(0x1f0 - 0x1e0) / 4];
-	uint32 CRU_PLL_PRG_EN;
-} CRU_REG, *pCRU_REG;
-
-typedef struct tagGPIO_LH {
-	uint32 GPIOL;
-	uint32 GPIOH;
-} GPIO_LH_T;
-
-typedef struct tagGPIO_IOMUX {
-	uint32 GPIOA_IOMUX;
-	uint32 GPIOB_IOMUX;
-	uint32 GPIOC_IOMUX;
-	uint32 GPIOD_IOMUX;
-} GPIO_IOMUX_T;
-
-/********************************
-*GRF GRF_OS_REG1 ddr ranktype
-*GRF_SOC_CON2c_sysreqpctllow power 
-*GRF_DDRC_STAT pctl low power
-********************************/
-/*REG FILE registers*/
-/*GRF_SOC_CON0*/
-#define DDR_MONITOR_EN  ((1<<(16+6))+(1<<6))
-#define DDR_MONITOR_DISB  ((1<<(16+6))+(0<<6))
-
-/*GRF_SOC_STATUS0*/
-#define sys_pwr_idle     (1<<27)
-#define gpu_pwr_idle     (1<<26)
-#define vpu_pwr_idle     (1<<25)
-#define vio_pwr_idle     (1<<24)
-#define peri_pwr_idle    (1<<23)
-#define core_pwr_idle     (1<<22)
-/*GRF_SOC_CON2*/
-#define core_pwr_idlereq    (13)
-#define peri_pwr_idlereq    (12)
-#define vio_pwr_idlereq     (11)
-#define vpu_pwr_idlereq     (10)
-#define gpu_pwr_idlereq     (9)
-#define sys_pwr_idlereq     (8)
-#define GRF_DDR_LP_EN     (0x1<<(2+16))
-#define GRF_DDR_LP_DISB     ((0x1<<(2+16))|(0x1<<2))
-
-/*grf updated*/
-typedef volatile struct tagREG_FILE {
-	uint32 reserved0[(0xa8 - 0x0) / 4];
-	GPIO_IOMUX_T GRF_GPIO_IOMUX[4];	/*0x00a8*/
-	uint32 GRF_GPIO2C_IOMUX2;	/*0xe8*/
-	uint32 GRF_CIF_IOMUX[2];
-	uint32 reserved1[(0x100 - 0xf4) / 4];
-	uint32 GRF_GPIO_DS;	/*0x100*/
-	uint32 reserved2[(0x118 - 0x104) / 4];
-	GPIO_LH_T GRF_GPIO_PULL[4];	/*0x118*/
-	uint32 reserved3[1];
-	uint32 GRF_ACODEC_CON;	/*0x13c*/
-	uint32 GRF_SOC_CON[3];	/*0x140*/
-	uint32 GRF_SOC_STATUS0;
-	uint32 GRF_LVDS_CON0;	/*0x150*/
-	uint32 reserved4[(0x15c - 0x154) / 4];
-	uint32 GRF_DMAC_CON[3];	/*0x15c*/
-	uint32 GRF_MAC_CON[2];
-	uint32 GRF_TVE_CON;	/*0x170*/
-	uint32 reserved5[(0x17c - 0x174) / 4];
-	uint32 GRF_UOC0_CON0;	/*0x17c*/
-	uint32 reserved6;
-	uint32 GRF_UOC1_CON[5];	/*0x184*/
-	uint32 reserved7;
-	uint32 GRF_DDRC_STAT;	/*0x19c*/
-	uint32 reserved8;
-	uint32 GRF_SOC_STATUS1;	/*0x1a4*/
-	uint32 GRF_CPU_CON[4];
-	uint32 reserved9[(0x1c0 - 0x1b8) / 4];
-	uint32 GRF_CPU_STATUS[2];	/*0x1c0*/
-	uint32 GRF_OS_REG[8];
-	uint32 reserved10[(0x200 - 0x1e8) / 4];
-	uint32 GRF_PVTM_CON[4];	/*0x200*/
-	uint32 GRF_PVTM_STATUS[4];
-	/*uint32 reserved10[(0x220-0x214)/4];*/
-	uint32 GRF_DFI_WRNUM;	/*0X220*/
-	uint32 GRF_DFI_RDNUM;
-	uint32 GRF_DFI_ACTNUM;
-	uint32 GRF_DFI_TIMERVAL;
-	uint32 GRF_NIF_FIFO[4];
-	uint32 reserved11[(0x280 - 0x240) / 4];
-	uint32 GRF_USBPHY0_CON[8];	/*0x280*/
-	uint32 GRF_USBPHY1_CON[8];
-	uint32 GRF_UOC_STATUS0;	/*0x2c0*/
-	uint32 reserved12[(0x300 - 0x2c4) / 4];
-	uint32 GRF_CHIP_TAG;
-	uint32 GRF_SDMMC_DET_CNT;
-	uint32 reserved13[(0x37c - 0x308) / 4];
-	uint32 GRF_EFUSE_PRG_EN;
-} REG_FILE, *pREG_FILE;
-
-/*SCTL*/
-#define INIT_STATE                     (0)
-#define CFG_STATE                      (1)
-#define GO_STATE                       (2)
-#define SLEEP_STATE                    (3)
-#define WAKEUP_STATE                   (4)
-
-/*STAT*/
-#define Init_mem                       (0)
-#define Config                         (1)
-#define Config_req                     (2)
-#define Access                         (3)
-#define Access_req                     (4)
-#define Low_power                      (5)
-#define Low_power_entry_req            (6)
-#define Low_power_exit_req             (7)
-
-/*MCFG*/
-#define mddr_lpddr2_clk_stop_idle(n)   ((n)<<24)
-#define pd_idle(n)                     ((n)<<8)
-#define mddr_en                        (2<<22)
-#define lpddr2_en                      (3<<22)
-#define ddr2_en                        (0<<5)
-#define ddr3_en                        (1<<5)
-#define lpddr2_s2                      (0<<6)
-#define lpddr2_s4                      (1<<6)
-#define mddr_lpddr2_bl_2               (0<<20)
-#define mddr_lpddr2_bl_4               (1<<20)
-#define mddr_lpddr2_bl_8               (2<<20)
-#define mddr_lpddr2_bl_16              (3<<20)
-#define ddr2_ddr3_bl_4                 (0)
-#define ddr2_ddr3_bl_8                 (1)
-#define tfaw_cfg(n)                    (((n)-4)<<18)
-#define pd_exit_slow                   (0<<17)
-#define pd_exit_fast                   (1<<17)
-#define pd_type(n)                     ((n)<<16)
-#define two_t_en(n)                    ((n)<<3)
-#define bl8int_en(n)                   ((n)<<2)
-#define cke_or_en(n)                   ((n)<<1)
-
-/*POWCTL*/
-#define power_up_start                 (1<<0)
-
-/*POWSTAT*/
-#define power_up_done                  (1<<0)
-
-/*DFISTSTAT0*/
-#define dfi_init_complete              (1<<0)
-
-/*CMDTSTAT*/
-#define cmd_tstat                      (1<<0)
-
-/*CMDTSTATEN*/
-#define cmd_tstat_en                   (1<<1)
-
-/*MCMD*/
-#define Deselect_cmd                   (0)
-#define PREA_cmd                       (1)
-#define REF_cmd                        (2)
-#define MRS_cmd                        (3)
-#define ZQCS_cmd                       (4)
-#define ZQCL_cmd                       (5)
-#define RSTL_cmd                       (6)
-#define MRR_cmd                        (8)
-#define DPDE_cmd                       (9)
-
-#define lpddr2_op(n)                   ((n)<<12)
-#define lpddr2_ma(n)                   ((n)<<4)
-
-#define bank_addr(n)                   ((n)<<17)
-#define cmd_addr(n)                    ((n)<<4)
-
-#define start_cmd                      (1u<<31)
-
-typedef union STAT_Tag {
-	uint32 d32;
-	struct {
-		unsigned ctl_stat:3;
-		unsigned reserved3:1;
-		unsigned lp_trig:3;
-		unsigned reserved7_31:25;
-	} b;
-} STAT_T;
-
-typedef union SCFG_Tag {
-	uint32 d32;
-	struct {
-		unsigned hw_low_power_en:1;
-		unsigned reserved1_5:5;
-		unsigned nfifo_nif1_dis:1;
-		unsigned reserved7:1;
-		unsigned bbflags_timing:4;
-		unsigned reserved12_31:20;
-	} b;
-} SCFG_T;
-
-/* DDR Controller register struct */
-typedef volatile struct DDR_REG_Tag {
-	/*Operational State, Control, and Status Registers*/
-	SCFG_T SCFG;		/*State Configuration Register*/
-	volatile uint32 SCTL;	/*State Control Register*/
-	STAT_T STAT;		/*State Status Register*/
-	volatile uint32 INTRSTAT;	/*Interrupt Status Register*/
-	uint32 reserved0[(0x40 - 0x10) / 4];
-	/*Initailization Control and Status Registers*/
-	volatile uint32 MCMD;	/*Memory Command Register*/
-	volatile uint32 POWCTL;	/*Power Up Control Registers*/
-	volatile uint32 POWSTAT;	/*Power Up Status Register*/
-	volatile uint32 CMDTSTAT;	/*Command Timing Status Register*/
-	volatile uint32 CMDTSTATEN;	/*Command Timing Status Enable Register*/
-	uint32 reserved1[(0x60 - 0x54) / 4];
-	volatile uint32 MRRCFG0;	/*MRR Configuration 0 Register*/
-	volatile uint32 MRRSTAT0;	/*MRR Status 0 Register*/
-	volatile uint32 MRRSTAT1;	/*MRR Status 1 Register*/
-	uint32 reserved2[(0x7c - 0x6c) / 4];
-	/*Memory Control and Status Registers*/
-	volatile uint32 MCFG1;	/*Memory Configuration 1 Register*/
-	volatile uint32 MCFG;	/*Memory Configuration Register*/
-	volatile uint32 PPCFG;	/*Partially Populated Memories Configuration Register*/
-	volatile uint32 MSTAT;	/*Memory Status Register*/
-	volatile uint32 LPDDR2ZQCFG;	/*LPDDR2 ZQ Configuration Register*/
-	uint32 reserved3;
-	/*DTU Control and Status Registers*/
-	volatile uint32 DTUPDES;	/*DTU Status Register*/
-	volatile uint32 DTUNA;	/*DTU Number of Random Addresses Created Register*/
-	volatile uint32 DTUNE;	/*DTU Number of Errors Register*/
-	volatile uint32 DTUPRD0;	/*DTU Parallel Read 0*/
-	volatile uint32 DTUPRD1;	/*DTU Parallel Read 1*/
-	volatile uint32 DTUPRD2;	/*DTU Parallel Read 2*/
-	volatile uint32 DTUPRD3;	/*DTU Parallel Read 3*/
-	volatile uint32 DTUAWDT;	/*DTU Address Width*/
-	uint32 reserved4[(0xc0 - 0xb4) / 4];
-	/*Memory Timing Registers*/
-	volatile uint32 TOGCNT1U;	/*Toggle Counter 1U Register*/
-	volatile uint32 TINIT;	/*t_init Timing Register*/
-	volatile uint32 TRSTH;	/*Reset High Time Register*/
-	volatile uint32 TOGCNT100N;	/*Toggle Counter 100N Register*/
-	volatile uint32 TREFI;	/*t_refi Timing Register*/
-	volatile uint32 TMRD;	/*t_mrd Timing Register*/
-	volatile uint32 TRFC;	/*t_rfc Timing Register*/
-	volatile uint32 TRP;	/*t_rp Timing Register*/
-	volatile uint32 TRTW;	/*t_rtw Timing Register*/
-	volatile uint32 TAL;	/*AL Latency Register*/
-	volatile uint32 TCL;	/*CL Timing Register*/
-	volatile uint32 TCWL;	/*CWL Register*/
-	volatile uint32 TRAS;	/*t_ras Timing Register*/
-	volatile uint32 TRC;	/*t_rc Timing Register*/
-	volatile uint32 TRCD;	/*t_rcd Timing Register*/
-	volatile uint32 TRRD;	/*t_rrd Timing Register*/
-	volatile uint32 TRTP;	/*t_rtp Timing Register*/
-	volatile uint32 TWR;	/*t_wr Timing Register*/
-	volatile uint32 TWTR;	/*t_wtr Timing Register*/
-	volatile uint32 TEXSR;	/*t_exsr Timing Register*/
-	volatile uint32 TXP;	/*t_xp Timing Register*/
-	volatile uint32 TXPDLL;	/*t_xpdll Timing Register*/
-	volatile uint32 TZQCS;	/*t_zqcs Timing Register*/
-	volatile uint32 TZQCSI;	/*t_zqcsi Timing Register*/
-	volatile uint32 TDQS;	/*t_dqs Timing Register*/
-	volatile uint32 TCKSRE;	/*t_cksre Timing Register*/
-	volatile uint32 TCKSRX;	/*t_cksrx Timing Register*/
-	volatile uint32 TCKE;	/*t_cke Timing Register*/
-	volatile uint32 TMOD;	/*t_mod Timing Register*/
-	volatile uint32 TRSTL;	/*Reset Low Timing Register*/
-	volatile uint32 TZQCL;	/*t_zqcl Timing Register*/
-	volatile uint32 TMRR;	/*t_mrr Timing Register*/
-	volatile uint32 TCKESR;	/*t_ckesr Timing Register*/
-	volatile uint32 TDPD;	/*t_dpd Timing Register*/
-	uint32 reserved5[(0x180 - 0x148) / 4];
-	/*ECC Configuration, Control, and Status Registers*/
-	volatile uint32 ECCCFG;	/*ECC Configuration Register*/
-	volatile uint32 ECCTST;	/*ECC Test Register*/
-	volatile uint32 ECCCLR;	/*ECC Clear Register*/
-	volatile uint32 ECCLOG;	/*ECC Log Register*/
-	uint32 reserved6[(0x200 - 0x190) / 4];
-	/*DTU Control and Status Registers*/
-	volatile uint32 DTUWACTL;	/*DTU Write Address Control Register*/
-	volatile uint32 DTURACTL;	/*DTU Read Address Control Register*/
-	volatile uint32 DTUCFG;	/*DTU Configuration Control Register*/
-	volatile uint32 DTUECTL;	/*DTU Execute Control Register*/
-	volatile uint32 DTUWD0;	/*DTU Write Data 0*/
-	volatile uint32 DTUWD1;	/*DTU Write Data 1*/
-	volatile uint32 DTUWD2;	/*DTU Write Data 2*/
-	volatile uint32 DTUWD3;	/*DTU Write Data 3*/
-	volatile uint32 DTUWDM;	/*DTU Write Data Mask*/
-	volatile uint32 DTURD0;	/*DTU Read Data 0*/
-	volatile uint32 DTURD1;	/*DTU Read Data 1*/
-	volatile uint32 DTURD2;	/*DTU Read Data 2*/
-	volatile uint32 DTURD3;	/*DTU Read Data 3*/
-	volatile uint32 DTULFSRWD;	/*DTU LFSR Seed for Write Data Generation*/
-	volatile uint32 DTULFSRRD;	/*DTU LFSR Seed for Read Data Generation*/
-	volatile uint32 DTUEAF;	/*DTU Error Address FIFO*/
-	/*DFI Control Registers*/
-	volatile uint32 DFITCTRLDELAY;	/*DFI tctrl_delay Register*/
-	volatile uint32 DFIODTCFG;	/*DFI ODT Configuration Register*/
-	volatile uint32 DFIODTCFG1;	/*DFI ODT Configuration 1 Register*/
-	volatile uint32 DFIODTRANKMAP;	/*DFI ODT Rank Mapping Register*/
-	/*DFI Write Data Registers*/
-	volatile uint32 DFITPHYWRDATA;	/*DFI tphy_wrdata Register*/
-	volatile uint32 DFITPHYWRLAT;	/*DFI tphy_wrlat Register*/
-	uint32 reserved7[(0x260 - 0x258) / 4];
-	volatile uint32 DFITRDDATAEN;	/*DFI trddata_en Register*/
-	volatile uint32 DFITPHYRDLAT;	/*DFI tphy_rddata Register*/
-	uint32 reserved8[(0x270 - 0x268) / 4];
-	/*DFI Update Registers*/
-	volatile uint32 DFITPHYUPDTYPE0;	/*DFI tphyupd_type0 Register*/
-	volatile uint32 DFITPHYUPDTYPE1;	/*DFI tphyupd_type1 Register*/
-	volatile uint32 DFITPHYUPDTYPE2;	/*DFI tphyupd_type2 Register*/
-	volatile uint32 DFITPHYUPDTYPE3;	/*DFI tphyupd_type3 Register*/
-	volatile uint32 DFITCTRLUPDMIN;	/*DFI tctrlupd_min Register*/
-	volatile uint32 DFITCTRLUPDMAX;	/*DFI tctrlupd_max Register*/
-	volatile uint32 DFITCTRLUPDDLY;	/*DFI tctrlupd_dly Register*/
-	uint32 reserved9;
-	volatile uint32 DFIUPDCFG;	/*DFI Update Configuration Register*/
-	volatile uint32 DFITREFMSKI;	/*DFI Masked Refresh Interval Register*/
-	volatile uint32 DFITCTRLUPDI;	/*DFI tctrlupd_interval Register*/
-	uint32 reserved10[(0x2ac - 0x29c) / 4];
-	volatile uint32 DFITRCFG0;	/*DFI Training Configuration 0 Register*/
-	volatile uint32 DFITRSTAT0;	/*DFI Training Status 0 Register*/
-	volatile uint32 DFITRWRLVLEN;	/*DFI Training dfi_wrlvl_en Register*/
-	volatile uint32 DFITRRDLVLEN;	/*DFI Training dfi_rdlvl_en Register*/
-	volatile uint32 DFITRRDLVLGATEEN;	/*DFI Training dfi_rdlvl_gate_en Register*/
-	/*DFI Status Registers*/
-	volatile uint32 DFISTSTAT0;	/*DFI Status Status 0 Register*/
-	volatile uint32 DFISTCFG0;	/*DFI Status Configuration 0 Register*/
-	volatile uint32 DFISTCFG1;	/*DFI Status configuration 1 Register*/
-	uint32 reserved11;
-	volatile uint32 DFITDRAMCLKEN;	/*DFI tdram_clk_enalbe Register*/
-	volatile uint32 DFITDRAMCLKDIS;	/*DFI tdram_clk_disalbe Register*/
-	volatile uint32 DFISTCFG2;	/*DFI Status configuration 2 Register*/
-	volatile uint32 DFISTPARCLR;	/*DFI Status Parity Clear Register*/
-	volatile uint32 DFISTPARLOG;	/*DFI Status Parity Log Register*/
-	uint32 reserved12[(0x2f0 - 0x2e4) / 4];
-	/*DFI Low Power Registers*/
-	volatile uint32 DFILPCFG0;	/*DFI Low Power Configuration 0 Register*/
-	uint32 reserved13[(0x300 - 0x2f4) / 4];
-	/*DFI Training 2 Registers*/
-	volatile uint32 DFITRWRLVLRESP0;	/*DFI Training dif_wrlvl_resp Status 0 Register*/
-	volatile uint32 DFITRWRLVLRESP1;	/*DFI Training dif_wrlvl_resp Status 1 Register*/
-	volatile uint32 DFITRWRLVLRESP2;	/*DFI Training dif_wrlvl_resp Status 2 Register*/
-	volatile uint32 DFITRRDLVLRESP0;	/*DFI Training dif_rdlvl_resp Status 0 Register*/
-	volatile uint32 DFITRRDLVLRESP1;	/*DFI Training dif_rdlvl_resp Status 1 Register*/
-	volatile uint32 DFITRRDLVLRESP2;	/*DFI Training dif_rdlvl_resp Status 2 Register*/
-	volatile uint32 DFITRWRLVLDELAY0;	/*DFI Training dif_wrlvl_delay Configuration 0 Register*/
-	volatile uint32 DFITRWRLVLDELAY1;	/*DFI Training dif_wrlvl_delay Configuration 1 Register*/
-	volatile uint32 DFITRWRLVLDELAY2;	/*DFI Training dif_wrlvl_delay Configuration 2 Register*/
-	volatile uint32 DFITRRDLVLDELAY0;	/*DFI Training dif_rdlvl_delay Configuration 0 Register*/
-	volatile uint32 DFITRRDLVLDELAY1;	/*DFI Training dif_rdlvl_delay Configuration 1 Register*/
-	volatile uint32 DFITRRDLVLDELAY2;	/*DFI Training dif_rdlvl_delay Configuration 2 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY0;	/*DFI Training dif_rdlvl_gate_delay Configuration 0 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY1;	/*DFI Training dif_rdlvl_gate_delay Configuration 1 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY2;	/*DFI Training dif_rdlvl_gate_delay Configuration 2 Register*/
-	volatile uint32 DFITRCMD;	/*DFI Training Command Register*/
-	uint32 reserved14[(0x3f8 - 0x340) / 4];
-	/*IP Status Registers*/
-	volatile uint32 IPVR;	/*IP Version Register*/
-	volatile uint32 IPTR;	/*IP Type Register*/
-} DDR_REG_T, *pDDR_REG_T;
-
-/*PHY_REG2*/
-#define PHY_AUTO_CALIBRATION (1<<0)
-#define PHY_SW_CALIBRATION   (1<<1)
-/*PHY_REG1*/
-#define PHY_DDR2             (1)
-#define PHY_DDR3             (0)
-#define PHY_LPDDR2           (2)
-#define PHY_Burst8           (1<<2)
-
-#define PHY_RON_DISABLE     (0)
-#define PHY_RON_309ohm      (1)
-#define PHY_RON_155ohm      (2)
-#define PHY_RON_103ohm      (3)
-#define PHY_RON_77ohm       (4)
-#define PHY_RON_63ohm       (5)
-#define PHY_RON_52ohm       (6)
-#define PHY_RON_45ohm       (7)
-/*#define PHY_RON_77ohm       (8)*/
-#define PHY_RON_62ohm       (9)
-/*#define PHY_RON_52ohm       (10)*/
-#define PHY_RON_44ohm       (11)
-#define PHY_RON_39ohm       (12)
-#define PHY_RON_34ohm       (13)
-#define PHY_RON_31ohm       (14)
-#define PHY_RON_28ohm       (15)
-
-#define PHY_RTT_DISABLE     (0)
-#define PHY_RTT_816ohm      (1)
-#define PHY_RTT_431ohm      (2)
-#define PHY_RTT_287ohm      (3)
-#define PHY_RTT_216ohm      (4)
-#define PHY_RTT_172ohm      (5)
-#define PHY_RTT_145ohm      (6)
-#define PHY_RTT_124ohm      (7)
-#define PHY_RTT_215ohm      (8)
-/*#define PHY_RTT_172ohm      (9)*/
-#define PHY_RTT_144ohm      (10)
-#define PHY_RTT_123ohm      (11)
-#define PHY_RTT_108ohm      (12)
-#define PHY_RTT_96ohm       (13)
-#define PHY_RTT_86ohm       (14)
-#define PHY_RTT_78ohm       (15)
-
-#define PHY_DRV_ODT_SET(n) ((n<<4)|n)
-
-/* DDR PHY register struct  updated */
-typedef volatile struct DDRPHY_REG_Tag {
-	volatile uint32 PHY_REG0;	/*PHY soft reset Register*/
-	volatile uint32 PHY_REG1;	/*phy working mode, burst length*/
-	volatile uint32 PHY_REG2;	/*PHY DQS squelch calibration Register*/
-	volatile uint32 PHY_REG3;	/*channel A read odt delay*/
-	volatile uint32 PHY_REG4;	/*channel B read odt dleay*/
-	uint32 reserved0[(0x2c - 0x14) / 4];
-	volatile uint32 PHY_REGb;	/*cl,al*/
-	volatile uint32 PHY_REGc;	/*CWL set register*/
-	uint32 reserved1[(0x44 - 0x34) / 4];
-	volatile uint32 PHY_REG11;	/*cmd drv*/
-	volatile uint32 PHY_REG12;	/*cmd weak pull up*/
-	volatile uint32 PHY_REG13;	/*cmd dll delay*/
-	volatile uint32 PHY_REG14;	/*CK dll delay*/
-	uint32 reserved2;	/*0x54*/
-	volatile uint32 PHY_REG16;	/*/CK drv*/
-	uint32 reserved3[(0x80 - 0x5c) / 4];
-	volatile uint32 PHY_REG20;	/*left channel a drv*/
-	volatile uint32 PHY_REG21;	/*left channel a odt*/
-	uint32 reserved4[(0x98 - 0x88) / 4];
-	volatile uint32 PHY_REG26;	/*left channel a dq write dll*/
-	volatile uint32 PHY_REG27;	/*left channel a dqs write dll*/
-	volatile uint32 PHY_REG28;	/*left channel a dqs read dll*/
-	uint32 reserved5[(0xc0 - 0xa4) / 4];
-	volatile uint32 PHY_REG30;	/*right channel a drv*/
-	volatile uint32 PHY_REG31;	/*right channel a odt*/
-	uint32 reserved6[(0xd8 - 0xc8) / 4];
-	volatile uint32 PHY_REG36;	/*right channel a dq write dll*/
-	volatile uint32 PHY_REG37;	/*right channel a dqs write dll*/
-	volatile uint32 PHY_REG38;	/*right channel a dqs read dll*/
-	uint32 reserved7[(0x100 - 0xe4) / 4];
-	volatile uint32 PHY_REG40;	/*left channel b drv*/
-	volatile uint32 PHY_REG41;	/*left channel b odt*/
-	uint32 reserved8[(0x118 - 0x108) / 4];
-	volatile uint32 PHY_REG46;	/*left channel b dq write dll*/
-	volatile uint32 PHY_REG47;	/*left channel b dqs write dll*/
-	volatile uint32 PHY_REG48;	/*left channel b dqs read dll*/
-	uint32 reserved9[(0x140 - 0x124) / 4];
-	volatile uint32 PHY_REG50;	/*right channel b drv*/
-	volatile uint32 PHY_REG51;	/*right channel b odt*/
-	uint32 reserved10[(0x158 - 0x148) / 4];
-	volatile uint32 PHY_REG56;	/*right channel b dq write dll*/
-	volatile uint32 PHY_REG57;	/*right channel b dqs write dll*/
-	volatile uint32 PHY_REG58;	/*right channel b dqs read dll*/
-	uint32 reserved11[(0x290 - 0x164) / 4];
-	volatile uint32 PHY_REGDLL;	/*dll bypass switch reg*/
-	uint32 reserved12[(0x2c0 - 0x294) / 4];
-	volatile uint32 PHY_REG_skew[(0x3b0 - 0x2c0) / 4];	/*de-skew*/
-	uint32 reserved13[(0x3e8 - 0x3b0) / 4];
-	volatile uint32 PHY_REGfa;	/*idqs*/
-	volatile uint32 PHY_REGfb;	/* left channel a calibration result*/
-	volatile uint32 PHY_REGfc;	/* right channel a calibration result*/
-	volatile uint32 PHY_REGfd;	/*left channel b calibration result*/
-	volatile uint32 PHY_REGfe;	/* right channel b calibration result*/
-	volatile uint32 PHY_REGff;	/*calibrationg done*/
-} DDRPHY_REG_T, *pDDRPHY_REG_T;
-
-#define pCRU_Reg               ((pCRU_REG)RK_CRU_VIRT)
-#define pGRF_Reg               ((pREG_FILE)RK_GRF_VIRT)
-#define pDDR_Reg               ((pDDR_REG_T)RK_DDR_VIRT)
-#define pPHY_Reg               ((pDDRPHY_REG_T)(RK_DDR_VIRT+RK3036_DDR_PCTL_SIZE))
-#define SysSrv_DdrTiming       (RK_CPU_AXI_BUS_VIRT+0xc)
-#define PMU_PWEDN_ST		(RK_PMU_VIRT + 0x8)
-#define READ_CS_INFO()   ((((pGRF_Reg->GRF_OS_REG[1])>>11)&0x1)+1)
-#define READ_COL_INFO()  (9+(((pGRF_Reg->GRF_OS_REG[1])>>9)&0x3))
-#define READ_BK_INFO()   (3-(((pGRF_Reg->GRF_OS_REG[1])>>8)&0x1))
-#define READ_CS0_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>6)&0x3))
-#define READ_CS1_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>4)&0x3))
-#define READ_BW_INFO()   (2>>(((pGRF_Reg->GRF_OS_REG[1])&0xc)>>2))	/* 0->8bit 1->16bit 2->32bit  grf*/
-#define READ_DIE_BW_INFO()   (2>>((pGRF_Reg->GRF_OS_REG[1])&0x3))
-
-/***********************************
- * LPDDR2 define
- ***********************************/
-/*MR0 (Device Information)*/
-#define  LPDDR2_DAI    (0x1)	/* 0:DAI complete, 1:DAI still in progress*/
-#define  LPDDR2_DI     (0x1<<1)	/* 0:S2 or S4 SDRAM, 1:NVM*/
-#define  LPDDR2_DNVI   (0x1<<2)	/* 0:DNV not supported, 1:DNV supported*/
-#define  LPDDR2_RZQI   (0x3<<3)	/*00:RZQ self test not supported, 01:ZQ-pin may connect to VDDCA or float*/
-				    /*10:ZQ-pin may short to GND.     11:ZQ-pin self test completed, no error condition detected.*/
-
-/*MR1 (Device Feature)*/
-#define LPDDR2_BL4     (0x2)
-#define LPDDR2_BL8     (0x3)
-#define LPDDR2_BL16    (0x4)
-#define LPDDR2_nWR(n)  (((n)-2)<<5)
-
-/*MR2 (Device Feature 2)*/
-#define LPDDR2_RL3_WL1  (0x1)
-#define LPDDR2_RL4_WL2  (0x2)
-#define LPDDR2_RL5_WL2  (0x3)
-#define LPDDR2_RL6_WL3  (0x4)
-#define LPDDR2_RL7_WL4  (0x5)
-#define LPDDR2_RL8_WL4  (0x6)
-
-/*MR3 (IO Configuration 1)*/
-#define LPDDR2_DS_34    (0x1)
-#define LPDDR2_DS_40    (0x2)
-#define LPDDR2_DS_48    (0x3)
-#define LPDDR2_DS_60    (0x4)
-#define LPDDR2_DS_80    (0x6)
-#define LPDDR2_DS_120   (0x7)	/*optional*/
-
-/*MR4 (Device Temperature)*/
-#define LPDDR2_tREF_MASK (0x7)
-#define LPDDR2_4_tREF    (0x1)
-#define LPDDR2_2_tREF    (0x2)
-#define LPDDR2_1_tREF    (0x3)
-#define LPDDR2_025_tREF  (0x5)
-#define LPDDR2_025_tREF_DERATE    (0x6)
-
-#define LPDDR2_TUF       (0x1<<7)
-
-/*MR8 (Basic configuration 4)*/
-#define LPDDR2_S4        (0x0)
-#define LPDDR2_S2        (0x1)
-#define LPDDR2_N         (0x2)
-#define LPDDR2_Density(mr8)  (8<<(((mr8)>>2)&0xf))	/*Unit:MB*/
-#define LPDDR2_IO_Width(mr8) (32>>(((mr8)>>6)&0x3))
-
-/*MR10 (Calibration)*/
-#define LPDDR2_ZQINIT   (0xFF)
-#define LPDDR2_ZQCL     (0xAB)
-#define LPDDR2_ZQCS     (0x56)
-#define LPDDR2_ZQRESET  (0xC3)
-
-/*MR16 (PASR Bank Mask)*/
-/*S2 SDRAM Only*/
-#define LPDDR2_PASR_Full (0x0)
-#define LPDDR2_PASR_1_2  (0x1)
-#define LPDDR2_PASR_1_4  (0x2)
-#define LPDDR2_PASR_1_8  (0x3)
-
-typedef enum PLL_ID_Tag {
-	APLL = 0,
-	DPLL,
-	CPLL,
-	GPLL,
-	PLL_MAX
-} PLL_ID;
-
-typedef enum DRAM_TYPE_Tag {
-	LPDDR = 0,
-	DDR,
-	DDR2,
-	DDR3,
-	LPDDR2S2,
-	LPDDR2,
-
-	DRAM_MAX
-} DRAM_TYPE;
-
-struct ddr_freq_t {
-	unsigned long screen_ft_us;
-	unsigned long long t0;
-	unsigned long long t1;
-	unsigned long t2;
-};
-
-typedef struct PCTRL_TIMING_Tag {
-	uint32 ddrFreq;
-	/*Memory Timing Registers*/
-	uint32 togcnt1u;	/*Toggle Counter 1U Register*/
-	uint32 tinit;		/*t_init Timing Register*/
-	uint32 trsth;		/*Reset High Time Register*/
-	uint32 togcnt100n;	/*Toggle Counter 100N Register*/
-	uint32 trefi;		/*t_refi Timing Register*/
-	uint32 tmrd;		/*t_mrd Timing Register*/
-	uint32 trfc;		/*t_rfc Timing Register*/
-	uint32 trp;		    /*t_rp Timing Register*/
-	uint32 trtw;		/*t_rtw Timing Register*/
-	uint32 tal;		    /*AL Latency Register*/
-	uint32 tcl;		    /*CL Timing Register*/
-	uint32 tcwl;		/*CWL Register*/
-	uint32 tras;		/*t_ras Timing Register*/
-	uint32 trc;		    /*t_rc Timing Register*/
-	uint32 trcd;		/*t_rcd Timing Register*/
-	uint32 trrd;		/*t_rrd Timing Register*/
-	uint32 trtp;		/*t_rtp Timing Register*/
-	uint32 twr;		    /*t_wr Timing Register*/
-	uint32 twtr;		/*t_wtr Timing Register*/
-	uint32 texsr;		/*t_exsr Timing Register*/
-	uint32 txp;		    /*t_xp Timing Register*/
-	uint32 txpdll;		/*t_xpdll Timing Register*/
-	uint32 tzqcs;		/*t_zqcs Timing Register*/
-	uint32 tzqcsi;		/*t_zqcsi Timing Register*/
-	uint32 tdqs;		/*t_dqs Timing Register*/
-	uint32 tcksre;		/*t_cksre Timing Register*/
-	uint32 tcksrx;		/*t_cksrx Timing Register*/
-	uint32 tcke;		/*t_cke Timing Register*/
-	uint32 tmod;		/*t_mod Timing Register*/
-	uint32 trstl;		/*Reset Low Timing Register*/
-	uint32 tzqcl;		/*t_zqcl Timing Register*/
-	uint32 tmrr;		/*t_mrr Timing Register*/
-	uint32 tckesr;		/*t_ckesr Timing Register*/
-	uint32 tdpd;		/*t_dpd Timing Register*/
-} PCTL_TIMING_T;
-
-struct ddr_change_freq_sram_param {
-	uint32 freq;
-	uint32 freq_slew;
-};
-
-typedef union NOC_TIMING_Tag {
-	uint32 d32;
-	struct {
-		unsigned ActToAct:6;
-		unsigned RdToMiss:6;
-		unsigned WrToMiss:6;
-		unsigned BurstLen:3;
-		unsigned RdToWr:5;
-		unsigned WrToRd:5;
-		unsigned BwRatio:1;
-	} b;
-} NOC_TIMING_T;
-
-typedef struct BACKUP_REG_Tag {
-	PCTL_TIMING_T pctl_timing;
-	NOC_TIMING_T noc_timing;
-	uint32 ddrMR[4];
-	uint32 mem_type;
-	uint32 ddr_speed_bin;
-	uint32 ddr_capability_per_die;
-} BACKUP_REG_T;
-
-BACKUP_REG_T DEFINE_PIE_DATA(ddr_reg);
-static BACKUP_REG_T *p_ddr_reg;
-
-uint32 DEFINE_PIE_DATA(ddr_freq);
-static uint32 *p_ddr_freq;
-uint32 DEFINE_PIE_DATA(ddr_sr_idle);
-uint32 DEFINE_PIE_DATA(ddr_dll_status);	/* ddr dllselfrefresh exitdll reset*/
-
-static const uint32_t ddr3_cl_cwl[22][4] = {
-/*   0~330           330~400         400~533        speed
-* tCK  >3             2.5~3          1.875~2.5     1.875~1.5
-*    cl<<16, cwl    cl<<16, cwl     cl<<16, cwl              */
-	{((5 << 16) | 5), ((5 << 16) | 5), 0, 0},	/*DDR3_800D*/
-	{((5 << 16) | 5), ((6 << 16) | 5), 0, 0},	/*DDR3_800E*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), 0},	/*DDR3_1066E*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), 0},	/*DDR3_1066F*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), 0},	/*DDR3_1066G*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_1333F*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1333G*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1333H*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1333J*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_1600G*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1600H*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1600J*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1600K*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1866J*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1866K*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1866L*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1866M*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_2133K*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_2133L*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_2133M*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_2133N*/
-
-	{((6 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)}	/*DDR3_DEFAULT*/
-};
-
-static const uint32_t ddr3_tRC_tFAW[22] = {
-/**    tRC    tFAW   */
-	((50 << 16) | 50),	/*DDR3_800D*/
-	((53 << 16) | 50),	/*DDR3_800E*/
-
-	((49 << 16) | 50),	/*DDR3_1066E*/
-	((51 << 16) | 50),	/*DDR3_1066F*/
-	((53 << 16) | 50),	/*DDR3_1066G*/
-
-	((47 << 16) | 45),	/*DDR3_1333F*/
-	((48 << 16) | 45),	/*DDR3_1333G*/
-	((50 << 16) | 45),	/*DDR3_1333H*/
-	((51 << 16) | 45),	/*DDR3_1333J*/
-
-	((45 << 16) | 40),	/*DDR3_1600G*/
-	((47 << 16) | 40),	/*DDR3_1600H*/
-	((48 << 16) | 40),	/*DDR3_1600J*/
-	((49 << 16) | 40),	/*DDR3_1600K*/
-
-	((45 << 16) | 35),	/*DDR3_1866J*/
-	((46 << 16) | 35),	/*DDR3_1866K*/
-	((47 << 16) | 35),	/*DDR3_1866L*/
-	((48 << 16) | 35),	/*DDR3_1866M*/
-
-	((44 << 16) | 35),	/*DDR3_2133K*/
-	((45 << 16) | 35),	/*DDR3_2133L*/
-	((46 << 16) | 35),	/*DDR3_2133M*/
-	((47 << 16) | 35),	/*DDR3_2133N*/
-
-	((53 << 16) | 50)	/*DDR3_DEFAULT*/
-};
-
-/****************************************************************************
-*Internal sram us delay function
-*Cpu highest frequency is 1.6 GHz
-*1 cycle = 1/1.6 ns
-*1 us = 1000 ns = 1000 * 1.6 cycles = 1600 cycles
-******************************************************************************/
-volatile uint32 DEFINE_PIE_DATA(loops_per_us);
-#define LPJ_100MHZ  999456UL
-
-/*----------------------------------------------------------------------
-*Name	: void __sramlocalfunc ddr_delayus(uint32_t us)
-*Desc	: ddr 
-*Params  : uint32_t us  --
-*Return  : void
-*Notes   : loops_per_us  arm freq
-*----------------------------------------------------------------------*/
-static void __sramfunc ddr_delayus(uint32 us)
-{
-	do {
-		volatile unsigned int i = (DATA(loops_per_us) * us);
-		if (i < 7)
-			i = 7;
-		barrier();
-		asm volatile (".align 4; 1: subs %0, %0, #1; bne 1b;":"+r" (i));
-	} while (0);
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-*Desc	: ddr 
-*Params  : pDest ->
-*          pSrc  ->
-*          words ->
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-
-static __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-{
-	uint32 i;
-
-	for (i = 0; i < words; i++) {
-		pDest[i] = pSrc[i];
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Lowpower_state(void)
-*Desc	: pctl  lowpower state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Lowpower_state(void)
-{
-	volatile uint32 value;
-
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if (value == Low_power) {
-			break;
-		}
-		switch (value) {
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Config)
-			;
-		case Config:
-			pDDR_Reg->SCTL = GO_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Access)
-			;
-		case Access:
-			pDDR_Reg->SCTL = SLEEP_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Low_power)
-			;
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Access_state(void)
-*Desc	: pctl  Access state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Access_state(void)
-{
-	volatile uint32 value;
-
-	/*set auto self-refresh idle*/
-	pDDR_Reg->MCFG1 =
-	    (pDDR_Reg->MCFG1 & 0xffffff00) | DATA(ddr_sr_idle) | (1 << 31);
-	pDDR_Reg->MCFG = (pDDR_Reg->MCFG & 0xffff00ff) | (PD_IDLE << 8);
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if ((value == Access)
-		    || ((pDDR_Reg->STAT.b.lp_trig == 1)
-			&& ((pDDR_Reg->STAT.b.ctl_stat) == Low_power))) {
-			break;
-		}
-		switch (value) {
-		case Low_power:
-			pDDR_Reg->SCTL = WAKEUP_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Access)
-			;
-			break;
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Config)
-			;
-		case Config:
-			pDDR_Reg->SCTL = GO_STATE;
-			dsb();
-			while (!(((pDDR_Reg->STAT.b.ctl_stat) == Access)
-				 || ((pDDR_Reg->STAT.b.lp_trig == 1)
-				     && ((pDDR_Reg->STAT.b.ctl_stat) ==
-					 Low_power))))
-		    ;
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-	pGRF_Reg->GRF_SOC_CON[2] = (1 << 16 | 0);	/*de_hw_wakeup :enable auto sr if sr_idle != 0*/
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Config_state(void)
-*Desc	: pctl  config state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Config_state(void)
-{
-	volatile uint32 value;
-	pGRF_Reg->GRF_SOC_CON[2] = (1 << 16 | 1);	/*hw_wakeup :disable auto sr*/
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if (value == Config) {
-			break;
-		}
-		switch (value) {
-		case Low_power:
-			pDDR_Reg->SCTL = WAKEUP_STATE;
-			dsb();
-		case Access:
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: void __sramlocalfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-*Desc	:  pctl MCMDddr
-*Params  : rank ->ddr rank 
-*          cmd  ->
-*          arg  ->
-*Return  : void
-*Notes   : argbank_addrcmd_addr
-*----------------------------------------------------------------------*/
-static void __sramfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-{
-	pDDR_Reg->MCMD = (start_cmd | (rank << 20) | arg | cmd);
-	dsb();
-	while (pDDR_Reg->MCMD & start_cmd)
-	;
-}
-
-__sramdata uint32 copy_data[8] = {
-     0xffffffff, 0x00000000, 0x55555555, 0xAAAAAAAA,
-	0xEEEEEEEE, 0x11111111, 0x22222222, 0xDDDDDDDD
-};
-
- EXPORT_PIE_SYMBOL(copy_data[8]);
-static uint32 *p_copy_data;
-
-/*----------------------------------------------------------------------
-Name	: uint32_t __sramlocalfunc ddr_data_training(void)
-Desc	: ddrdata training
-Params  : void
-Return  : void
-Notes   : data training
-----------------------------------------------------------------------*/
-static uint32_t __sramfunc ddr_data_training(void)
-{
-	uint32 value, dram_bw;
-	value = pDDR_Reg->TREFI;
-	pDDR_Reg->TREFI = 0;
-	dram_bw = (pPHY_Reg->PHY_REG0 >> 4) & 0xf;
-	pPHY_Reg->PHY_REG2 |= PHY_AUTO_CALIBRATION;
-	dsb();
-	/*wait echo byte DTDONE*/
-	ddr_delayus(1);
-	/*stop DTT*/
-	while ((pPHY_Reg->PHY_REGff & 0xf) != dram_bw)
-	;
-	pPHY_Reg->PHY_REG2 = (pPHY_Reg->PHY_REG2 & (~0x1));
-	/*send some auto refresh to complement the lost while DTT*/
-	ddr_send_command(3, PREA_cmd, 0);
-	ddr_send_command(3, REF_cmd, 0);
-	ddr_send_command(3, REF_cmd, 0);
-
-	/*resume auto refresh*/
-	pDDR_Reg->TREFI = value;
-	return 0;
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_set_dll_bypass(uint32 freq)
-Desc    : PHY dll 
-Params  : freq -> ddr
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_set_dll_bypass(uint32 freq)
-{
-#if defined (PHY_RX_PHASE_CAL)
-	uint32 phase_90, dll_set, de_skew;
-
-	phase_90 = 1000000 / freq / 4;
-	dll_set = (phase_90 - 300 + (0x7*PHY_DE_SKEW_STEP)) / (phase_90 / 4);
-	de_skew = (phase_90 - 300 + (0x7*PHY_DE_SKEW_STEP) - ((phase_90 / 4) * dll_set));
-	if (de_skew > PHY_DE_SKEW_STEP * 15) {
-		if (dll_set == 3) {
-			de_skew = 15;
-		} else {
-			dll_set += 1;
-			de_skew = 0;
-		}
-	} else {
-		de_skew = de_skew / PHY_DE_SKEW_STEP;
-	}
-
-	pPHY_Reg->PHY_REG28 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG38 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG48 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG58 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG_skew[(0x324-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x350-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x37c-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x3a8-0x2c0)/4] = 0x7 | (de_skew << 4);
-#else
-	uint32 phase;
-	if (freq < 350) {
-		phase = 3;
-	} else if (freq < 600) {
-		phase = 2;
-	} else
-		phase = 1;
-	pPHY_Reg->PHY_REG28 = phase;	/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG38 = phase;	/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG48 = phase;	/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG58 = phase;	/*rx dll 45delay*/
-#endif
-	if (freq <= PHY_DLL_DISABLE_FREQ) {
-		pPHY_Reg->PHY_REGDLL |= 0x1F;	/*TX DLL bypass */
-	} else {
-		pPHY_Reg->PHY_REGDLL &= ~0x1F;	/* TX DLL bypass*/
-	}
-
-	dsb();
-}
-
-static noinline uint32 ddr_get_pll_freq(PLL_ID pll_id)	/*APLL-1;CPLL-2;DPLL-3;GPLL-4*/
-{
-	uint32 ret = 0;
-
-	if (((pCRU_Reg->CRU_MODE_CON >> (pll_id * 4)) & 1) == 1)	/* DPLL Normal mode*/
-		ret = 24 * ((pCRU_Reg->CRU_PLL_CON[pll_id][0] & 0xfff))	/* NF = 2*(CLKF+1)*/
-		    / ((pCRU_Reg->CRU_PLL_CON[pll_id][1] & 0x3f)
-		       * ((pCRU_Reg->CRU_PLL_CON[pll_id][0] >> 12) & 0x7) * ((pCRU_Reg->CRU_PLL_CON[pll_id][1] >> 6) & 0x7));	/* OD = 2^CLKOD*/
-	else
-		ret = 24;
-
-	return ret;
-}
-
-static __sramdata uint32 clkFbDiv;
-static __sramdata uint32 clkPostDiv1;
-static __sramdata uint32 clkPostDiv2;
-
-/*****************************************
-*REFDIV   FBDIV     POSTDIV1/POSTDIV2      FOUTPOSTDIV           freq Step        FOUTPOSRDIV            finally use
-*==================================================================================================================
-*1        17 - 66   4                      100MHz - 400MHz          6MHz          200MHz  <= 300MHz             <= 150MHz
-*1        17 - 66   3                      133MHz - 533MHz          8MHz
-*1        17 - 66   2                      200MHz - 800MHz          12MHz         300MHz  <= 600MHz      150MHz <= 300MHz
-*1        17 - 66   1                      400MHz - 1600MHz         24MHz         600MHz  <= 1200MHz     300MHz <= 600MHz
-*******************************************/
-/*for minimum jitter operation, the highest VCO and FREF frequencies should be used.*/
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_set_pll(uint32_t nMHz, uint32_t set)
-*Desc    : ddr pll
-*Params  : nMHZ -> ddr
-*          set  ->0
-*                 1ddr pll
-*Return  : 
-*Notes   : set=0ddr_set_pllset=1 ddr_set_pll
--*---------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_set_pll(uint32 nMHz, uint32 set)
-{
-	uint32 ret = 0;
-	int delay = 1000;
-	uint32 pll_id = 1;	/*DPLL*/
-
-	if (nMHz == 24) {
-		ret = 24;
-		goto out;
-	}
-	if (!set) {
-		if (nMHz <= 150) {	/*<300*/
-			clkPostDiv1 = 6;
-		} else if (nMHz <= 200) {
-			clkPostDiv1 = 4;
-		} else if (nMHz <= 300) {
-			clkPostDiv1 = 3;
-		} else if (nMHz <= 450) {
-			clkPostDiv1 = 2;
-		} else {
-			clkPostDiv1 = 1;
-		}
-		clkPostDiv2 = 1;
-		clkFbDiv = (nMHz * 2 * DDR_PLL_REFDIV * clkPostDiv1 * clkPostDiv2) / 24;	/*ddr2*/
-		ret =
-		    (24 * clkFbDiv) / (2 * DDR_PLL_REFDIV * clkPostDiv1 *
-				       clkPostDiv2);
-	} else {
-		pCRU_Reg->CRU_MODE_CON = (0x1 << ((pll_id * 4) + 16)) | (0x0 << (pll_id * 4));	/*PLL slow-mode*/
-
-		pCRU_Reg->CRU_PLL_CON[pll_id][0] =
-		    FBDIV(clkFbDiv) | POSTDIV1(clkPostDiv1);
-		pCRU_Reg->CRU_PLL_CON[pll_id][1] = REFDIV(DDR_PLL_REFDIV) | POSTDIV2(clkPostDiv2) | (0x10001 << 12);	/*interger mode*/
-
-		ddr_delayus(1);
-
-		while (delay > 0) {
-			ddr_delayus(1);
-			if (pCRU_Reg->CRU_PLL_CON[pll_id][1] & (PLL_LOCK_STATUS))	/*wait for pll locked*/
-				break;
-			delay--;
-		}
-
-		pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3 << 16) | 0x0);	/*clk_ddr_src:clk_ddrphy = 1:1*/
-		pCRU_Reg->CRU_MODE_CON = (0x1 << ((pll_id * 4) + 16)) | (0x1 << (pll_id * 4));	/*PLL normal*/
-	}
-out:
-	return ret;
-}
-
-uint32 PIE_FUNC(ddr_set_pll)(uint32 nMHz, uint32 set)
-{
-	return ddr_set_pll(nMHz, set);
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_set_pll));
-static uint32(*p_ddr_set_pll) (uint32 nMHz, uint32 set);
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t ddr_get_parameter(uint32_t nMHz)
-*Desc    : 
-*Params  : nMHZ -> ddr
-*Return  : 0 
-*          -1 
-*          -4 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_get_parameter(uint32 nMHz)
-{
-	uint32_t tmp;
-	uint32_t ret = 0;
-	uint32_t al;
-	uint32_t bl;
-	uint32_t cl;
-	uint32_t cwl;
-	uint32_t bl_tmp;
-	PCTL_TIMING_T *p_pctl_timing = &(p_ddr_reg->pctl_timing);
-	NOC_TIMING_T *p_noc_timing = &(p_ddr_reg->noc_timing);
-
-	p_pctl_timing->togcnt1u = nMHz;
-	p_pctl_timing->togcnt100n = nMHz / 10;
-	p_pctl_timing->tinit = 200;
-
-	if (p_ddr_reg->mem_type == DDR3) {
-		if (p_ddr_reg->ddr_speed_bin > DDR3_DEFAULT) {
-			ret = -1;
-			goto out;
-		}
-#define DDR3_tREFI_7_8_us    (78)
-#define DDR3_tMRD            (4)
-#define DDR3_tRFC_512Mb      (90)
-#define DDR3_tRFC_1Gb        (110)
-#define DDR3_tRFC_2Gb        (160)
-#define DDR3_tRFC_4Gb        (300)
-#define DDR3_tRFC_8Gb        (350)
-#define DDR3_tRTW            (2)	/*register min valid value*/
-#define DDR3_tRAS            (37)
-#define DDR3_tRRD            (10)
-#define DDR3_tRTP            (7)
-#define DDR3_tWR             (15)
-#define DDR3_tWTR            (7)
-#define DDR3_tXP             (7)
-#define DDR3_tXPDLL          (24)
-#define DDR3_tZQCS           (80)
-#define DDR3_tZQCSI          (10000)
-#define DDR3_tDQS            (1)
-#define DDR3_tCKSRE          (10)
-#define DDR3_tCKE_400MHz     (7)
-#define DDR3_tCKE_533MHz     (6)
-#define DDR3_tMOD            (15)
-#define DDR3_tRSTL           (100)
-#define DDR3_tZQCL           (320)
-#define DDR3_tDLLK           (512)
-		p_pctl_timing->trsth = 500;
-		al = 0;
-		bl = 8;
-		if (nMHz <= 330) {
-			tmp = 0;
-		} else if (nMHz <= 400) {
-			tmp = 1;
-		} else if (nMHz <= 533) {
-			tmp = 2;
-		} else {	/*666MHz*/
-			tmp = 3;
-		}
-		if (nMHz <= DDR3_DDR2_DLL_DISABLE_FREQ) {	/*when dll bypss cl = cwl = 6*/
-			cl = 6;
-			cwl = 6;
-		} else {
-			cl = ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] >> 16;
-			cwl =
-			    ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] & 0x0ff;
-		}
-		if (cl == 0) {
-			ret = -4;	/**/
-		}
-		if (nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ) {
-			p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_DIS;
-		} else {
-			p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_120;
-		}
-		p_ddr_reg->ddrMR[2] = DDR3_MR2_CWL(cwl) /* | DDR3_Rtt_WR_60 */ ;
-		p_ddr_reg->ddrMR[3] = 0;
-		/**************************************************
-		* PCTL Timing
-		**************************************************/
-		/*
-		 * tREFI, average periodic refresh interval, 7.8us
-		 */
-		p_pctl_timing->trefi = DDR3_tREFI_7_8_us;
-		/*
-		 * tMRD, 4 tCK
-		 */
-		p_pctl_timing->tmrd = DDR3_tMRD & 0x7;
-		/*
-		 * tRFC, 90ns(512Mb),110ns(1Gb),160ns(2Gb),300ns(4Gb),350ns(8Gb)
-		 */
-		if (p_ddr_reg->ddr_capability_per_die <= 0x4000000) {	/*512Mb 90ns*/
-			tmp = DDR3_tRFC_512Mb;
-		} else if (p_ddr_reg->ddr_capability_per_die <= 0x8000000) {	/*1Gb 110ns*/
-			tmp = DDR3_tRFC_1Gb;
-		} else if (p_ddr_reg->ddr_capability_per_die <= 0x10000000) {	/*2Gb 160ns*/
-			tmp = DDR3_tRFC_2Gb;
-		} else if (p_ddr_reg->ddr_capability_per_die <= 0x20000000) {/*4Gb 300ns*/
-			tmp = DDR3_tRFC_4Gb;
-		} else{		/*8Gb  350ns*/
-			tmp = DDR3_tRFC_8Gb;
-		}
-		p_pctl_timing->trfc = (tmp * nMHz + 999) / 1000;
-		/*
-		 * tXSR, =tDLLK=512 tCK
-		 */
-		p_pctl_timing->texsr = DDR3_tDLLK;
-		/*
-		 * tRP=CL
-		 */
-		p_pctl_timing->trp = cl;
-		/*
-		 * WrToMiss=WL*tCK + tWR + tRP + tRCD
-		 */
-		p_noc_timing->b.WrToMiss =
-		    ((cwl + ((DDR3_tWR * nMHz + 999) / 1000) + cl + cl) & 0x3F);
-		/*
-		 * tRC=tRAS+tRP
-		 */
-		p_pctl_timing->trc =
-		    ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin] >> 16) * nMHz +
-		       999) / 1000) & 0x3F);
-		p_noc_timing->b.ActToAct =
-		    ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin] >> 16) * nMHz +
-		       999) / 1000) & 0x3F);
-
-		p_pctl_timing->trtw = (cl + 2 - cwl);	/*DDR3_tRTW*/
-		p_noc_timing->b.RdToWr = ((cl + 2 - cwl) & 0x1F);
-		p_pctl_timing->tal = al;
-		p_pctl_timing->tcl = cl;
-		p_pctl_timing->tcwl = cwl;
-		/*
-		 * tRAS, 37.5ns(400MHz)     37.5ns(533MHz)
-		 */
-		p_pctl_timing->tras =
-		    (((DDR3_tRAS * nMHz + (nMHz >> 1) + 999) / 1000) & 0x3F);
-		/*
-		 * tRCD=CL
-		 */
-		p_pctl_timing->trcd = cl;
-		/*
-		 * tRRD = max(4nCK, 7.5ns), DDR3-1066(1K), DDR3-1333(2K), DDR3-1600(2K)
-		 *        max(4nCK, 10ns), DDR3-800(1K,2K), DDR3-1066(2K)
-		 *        max(4nCK, 6ns), DDR3-1333(1K), DDR3-1600(1K)
-		 *
-		 */
-		tmp = ((DDR3_tRRD * nMHz + 999) / 1000);
-		if (tmp < 4) {
-			tmp = 4;
-		}
-		p_pctl_timing->trrd = (tmp & 0xF);
-		/*
-		 * tRTP, max(4 tCK,7.5ns)
-		 */
-		tmp = ((DDR3_tRTP * nMHz + (nMHz >> 1) + 999) / 1000);
-		if (tmp < 4) {
-			tmp = 4;
-		}
-		p_pctl_timing->trtp = tmp & 0xF;
-		/*
-		 * RdToMiss=tRTP+tRP + tRCD - (BL/2 * tCK)
-		 */
-		p_noc_timing->b.RdToMiss = ((tmp + cl + cl - (bl >> 1)) & 0x3F);
-		/*
-		 * tWR, 15ns
-		 */
-		tmp = ((DDR3_tWR * nMHz + 999) / 1000);
-		p_pctl_timing->twr = tmp & 0x1F;
-		if (tmp < 9)
-			tmp = tmp - 4;
-		else
-			tmp = tmp >> 1;
-		p_ddr_reg->ddrMR[0] = DDR3_BL8 | DDR3_CL(cl) | DDR3_WR(tmp);
-
-		/*
-		 * tWTR, max(4 tCK,7.5ns)
-		 */
-		tmp = ((DDR3_tWTR * nMHz + (nMHz >> 1) + 999) / 1000);
-		if (tmp < 4) {
-			tmp = 4;
-		}
-		p_pctl_timing->twtr = tmp & 0xF;
-		p_noc_timing->b.WrToRd = ((tmp + cwl) & 0x1F);
-		/*
-		 * tXP, max(3 tCK, 7.5ns)(<933MHz)
-		 */
-		tmp = ((DDR3_tXP * nMHz + (nMHz >> 1) + 999) / 1000);
-		if (tmp < 3) {
-			tmp = 3;
-		}
-		p_pctl_timing->txp = tmp & 0x7;
-		/*
-		 * tXPDLL, max(10 tCK,24ns)
-		 */
-		tmp = ((DDR3_tXPDLL * nMHz + 999) / 1000);
-		if (tmp < 10) {
-			tmp = 10;
-		}
-		p_pctl_timing->txpdll = tmp & 0x3F;
-		/*
-		 * tZQCS, max(64 tCK, 80ns)
-		 */
-		tmp = ((DDR3_tZQCS * nMHz + 999) / 1000);
-		if (tmp < 64) {
-			tmp = 64;
-		}
-		p_pctl_timing->tzqcs = tmp & 0x7F;
-		/*
-		 * tZQCSI,
-		 */
-		p_pctl_timing->tzqcsi = DDR3_tZQCSI;
-		/*
-		 * tDQS,
-		 */
-		p_pctl_timing->tdqs = DDR3_tDQS;
-		/*
-		 * tCKSRE, max(5 tCK, 10ns)
-		 */
-		tmp = ((DDR3_tCKSRE * nMHz + 999) / 1000);
-		if (tmp < 5) {
-			tmp = 5;
-		}
-		p_pctl_timing->tcksre = tmp & 0x1F;
-		/*
-		 * tCKSRX, max(5 tCK, 10ns)
-		 */
-		p_pctl_timing->tcksrx = tmp & 0x1F;
-		/*
-		 * tCKE, max(3 tCK,7.5ns)(400MHz) max(3 tCK,5.625ns)(533MHz)
-		 */
-		if (nMHz >= 533) {
-			tmp = ((DDR3_tCKE_533MHz * nMHz + 999) / 1000);
-		} else {
-			tmp =
-			    ((DDR3_tCKE_400MHz * nMHz + (nMHz >> 1) +
-			      999) / 1000);
-		}
-		if (tmp < 3) {
-			tmp = 3;
-		}
-		p_pctl_timing->tcke = tmp & 0x7;
-		/*
-		 * tCKESR, =tCKE + 1tCK
-		 */
-		p_pctl_timing->tckesr = (tmp + 1) & 0xF;
-		/*
-		 * tMOD, max(12 tCK,15ns)
-		 */
-		tmp = ((DDR3_tMOD * nMHz + 999) / 1000);
-		if (tmp < 12) {
-			tmp = 12;
-		}
-		p_pctl_timing->tmod = tmp & 0x1F;
-		/*
-		 * tRSTL, 100ns
-		 */
-		p_pctl_timing->trstl =
-		    ((DDR3_tRSTL * nMHz + 999) / 1000) & 0x7F;
-		/*
-		 * tZQCL, max(256 tCK, 320ns)
-		 */
-		tmp = ((DDR3_tZQCL * nMHz + 999) / 1000);
-		if (tmp < 256) {
-			tmp = 256;
-		}
-		p_pctl_timing->tzqcl = tmp & 0x3FF;
-		/*
-		 * tMRR, 0 tCK
-		 */
-		p_pctl_timing->tmrr = 0;
-		/*
-		 * tDPD, 0
-		 */
-		p_pctl_timing->tdpd = 0;
-
-		/**************************************************
-		*NOC Timing
-		**************************************************/
-		p_noc_timing->b.BurstLen = ((bl >> 1) & 0x7);
-	} else if (p_ddr_reg->mem_type == LPDDR2) {
-#define LPDDR2_tREFI_3_9_us    (38)	/*unit 100ns*/
-#define LPDDR2_tREFI_7_8_us    (78)	/*unit 100ns*/
-#define LPDDR2_tMRD            (5)	/*tCK*/
-#define LPDDR2_tRFC_8Gb        (210)	/*ns*/
-#define LPDDR2_tRFC_4Gb        (130)	/*ns*/
-#define LPDDR2_tRP_4_BANK               (24)	/*ns*/
-#define LPDDR2_tRPab_SUB_tRPpb_4_BANK   (0)
-#define LPDDR2_tRP_8_BANK               (27)	/*ns*/
-#define LPDDR2_tRPab_SUB_tRPpb_8_BANK   (3)
-#define LPDDR2_tRTW          (1)	/*tCK register min valid value*/
-#define LPDDR2_tRAS          (42)	/*ns*/
-#define LPDDR2_tRCD          (24)	/*ns*/
-#define LPDDR2_tRRD          (10)	/*ns*/
-#define LPDDR2_tRTP          (7)	/*ns*/
-#define LPDDR2_tWR           (15)	/*ns*/
-#define LPDDR2_tWTR_GREAT_200MHz         (7)	/*ns*/
-#define LPDDR2_tWTR_LITTLE_200MHz        (10)	/*ns*/
-#define LPDDR2_tXP           (7)	/*ns*/
-#define LPDDR2_tXPDLL        (0)
-#define LPDDR2_tZQCS         (90)	/*ns*/
-#define LPDDR2_tZQCSI        (0)
-#define LPDDR2_tDQS          (1)
-#define LPDDR2_tCKSRE        (1)	/*tCK*/
-#define LPDDR2_tCKSRX        (2)	/*tCK*/
-#define LPDDR2_tCKE          (3)	/*tCK*/
-#define LPDDR2_tMOD          (0)
-#define LPDDR2_tRSTL         (0)
-#define LPDDR2_tZQCL         (360)	/*ns*/
-#define LPDDR2_tMRR          (2)	/*tCK*/
-#define LPDDR2_tCKESR        (15)	/*ns*/
-#define LPDDR2_tDPD_US       (500)
-#define LPDDR2_tFAW_GREAT_200MHz    (50)	/*ns*/
-#define LPDDR2_tFAW_LITTLE_200MHz   (60)	/*ns*/
-#define LPDDR2_tDLLK         (2)	/*tCK*/
-#define LPDDR2_tDQSCK_MAX    (3)	/*tCK*/
-#define LPDDR2_tDQSCK_MIN    (0)	/*tCK*/
-#define LPDDR2_tDQSS         (1)	/*tCK*/
-
-		uint32 trp_tmp;
-		uint32 trcd_tmp;
-		uint32 tras_tmp;
-		uint32 trtp_tmp;
-		uint32 twr_tmp;
-
-		al = 0;
-		if (nMHz >= 200) {
-			bl = 4;	/*you can change burst here*/
-		} else {
-			bl = 8;	/* freq < 200MHz, BL fixed 8*/
-		}
-		/*     1066 933 800 667 533 400 333
-		 * RL,   8   7   6   5   4   3   3
-		 * WL,   4   4   3   2   2   1   1
-		 */
-		if (nMHz <= 200) {
-			cl = 3;
-			cwl = 1;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL3_WL1;
-		} else if (nMHz <= 266) {
-			cl = 4;
-			cwl = 2;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL4_WL2;
-		} else if (nMHz <= 333) {
-			cl = 5;
-			cwl = 2;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL5_WL2;
-		} else if (nMHz <= 400) {
-			cl = 6;
-			cwl = 3;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL6_WL3;
-		} else if (nMHz <= 466) {
-			cl = 7;
-			cwl = 4;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL7_WL4;
-		} else {		/*(nMHz<=1066)*/
-			cl = 8;
-			cwl = 4;
-			p_ddr_reg->ddrMR[2] = LPDDR2_RL8_WL4;
-		}
-		p_ddr_reg->ddrMR[3] = LPDDR2_DS_34;
-		p_ddr_reg->ddrMR[0] = 0;
-		/**************************************************
-		* PCTL Timing
-		**************************************************/
-		/*
-		 * tREFI, average periodic refresh interval, 15.6us(<256Mb) 7.8us(256Mb-1Gb) 3.9us(2Gb-8Gb)
-		 */
-		if (p_ddr_reg->ddr_capability_per_die >= 0x10000000) {	/*2Gb*/
-			p_pctl_timing->trefi = LPDDR2_tREFI_3_9_us;
-		} else {
-			p_pctl_timing->trefi = LPDDR2_tREFI_7_8_us;
-		}
-
-		/*
-		 * tMRD, (=tMRW), 5 tCK
-		 */
-		p_pctl_timing->tmrd = LPDDR2_tMRD & 0x7;
-		/*
-		 * tRFC, 90ns(<=512Mb) 130ns(1Gb-4Gb) 210ns(8Gb)
-		 */
-		if (p_ddr_reg->ddr_capability_per_die >= 0x40000000) {	/*8Gb*/
-			p_pctl_timing->trfc =
-			    (LPDDR2_tRFC_8Gb * nMHz + 999) / 1000;
-			/*
-			 * tXSR, max(2tCK,tRFC+10ns)
-			 */
-			tmp = (((LPDDR2_tRFC_8Gb + 10) * nMHz + 999) / 1000);
-		} else {
-			p_pctl_timing->trfc =
-			    (LPDDR2_tRFC_4Gb * nMHz + 999) / 1000;
-			tmp = (((LPDDR2_tRFC_4Gb + 10) * nMHz + 999) / 1000);
-		}
-		if (tmp < 2) {
-			tmp = 2;
-		}
-		p_pctl_timing->texsr = tmp & 0x3FF;
-		/*
-		 * tRP, max(3tCK, 4-bank:15ns(Fast) 18ns(Typ) 24ns(Slow), 8-bank:18ns(Fast) 21ns(Typ) 27ns(Slow))
-		 */
-		trp_tmp = ((LPDDR2_tRP_8_BANK * nMHz + 999) / 1000);
-		if (trp_tmp < 3) {
-			trp_tmp = 3;
-		}
-		p_pctl_timing->trp =
-		    ((((LPDDR2_tRPab_SUB_tRPpb_8_BANK * nMHz +
-			999) / 1000) & 0x3) << 16) | (trp_tmp & 0xF);
-
-		/*
-		 * tRAS, max(3tCK,42ns)
-		 */
-		tras_tmp = ((LPDDR2_tRAS * nMHz + 999) / 1000);
-		if (tras_tmp < 3) {
-			tras_tmp = 3;
-		}
-		p_pctl_timing->tras = (tras_tmp & 0x3F);
-
-		/*
-		 * tRCD, max(3tCK, 15ns(Fast) 18ns(Typ) 24ns(Slow))
-		 */
-		trcd_tmp = ((LPDDR2_tRCD * nMHz + 999) / 1000);
-		if (trcd_tmp < 3) {
-			trcd_tmp = 3;
-		}
-		p_pctl_timing->trcd = (trcd_tmp & 0xF);
-		/*
-		 * tRTP, max(2tCK, 7.5ns)
-		 */
-		trtp_tmp = ((LPDDR2_tRTP * nMHz + (nMHz >> 1) + 999) / 1000);
-		if (trtp_tmp < 2) {
-			trtp_tmp = 2;
-		}
-		p_pctl_timing->trtp = trtp_tmp & 0xF;
-		/*
-		 * tWR, max(3tCK,15ns)
-		 */
-		twr_tmp = ((LPDDR2_tWR * nMHz + 999) / 1000);
-		if (twr_tmp < 3) {
-			twr_tmp = 3;
-		}
-		p_pctl_timing->twr = twr_tmp & 0x1F;
-		bl_tmp =
-		    (bl ==
-		     16) ? LPDDR2_BL16 : ((bl == 8) ? LPDDR2_BL8 : LPDDR2_BL4);
-		p_ddr_reg->ddrMR[1] = bl_tmp | LPDDR2_nWR(twr_tmp);
-
-		/*
-		 * WrToMiss=WL*tCK + tDQSS + tWR + tRP + tRCD
-		 */
-		p_noc_timing->b.WrToMiss =
-		    ((cwl + LPDDR2_tDQSS + twr_tmp + trp_tmp +
-		      trcd_tmp) & 0x3F);
-		/*
-		 * RdToMiss=tRTP + tRP + tRCD - (BL/2 * tCK)
-		 */
-		p_noc_timing->b.RdToMiss =
-		    ((trtp_tmp + trp_tmp + trcd_tmp - (bl >> 1)) & 0x3F);
-		/*
-		 * tRC=tRAS+tRP
-		 */
-		p_pctl_timing->trc = ((tras_tmp + trp_tmp) & 0x3F);
-		p_noc_timing->b.ActToAct = ((tras_tmp + trp_tmp) & 0x3F);
-		/*
-		 * RdToWr=RL+tDQSCK-WL
-		 */
-		p_pctl_timing->trtw = (cl + LPDDR2_tDQSCK_MAX + (bl / 2) + 1 - cwl);	/*LPDDR2_tRTW*/
-		p_noc_timing->b.RdToWr =
-		    ((cl + LPDDR2_tDQSCK_MAX + 1 - cwl) & 0x1F);
-		p_pctl_timing->tal = al;
-		p_pctl_timing->tcl = cl;
-		p_pctl_timing->tcwl = cwl;
-		/*
-		 * tRRD, max(2tCK,10ns)
-		 */
-		tmp = ((LPDDR2_tRRD * nMHz + 999) / 1000);
-		if (tmp < 2) {
-			tmp = 2;
-		}
-		p_pctl_timing->trrd = (tmp & 0xF);
-		/*
-		 * tWTR, max(2tCK, 7.5ns(533-266MHz)  10ns(200-166MHz))
-		 */
-		if (nMHz > 200) {
-			tmp =
-			    ((LPDDR2_tWTR_GREAT_200MHz * nMHz + (nMHz >> 1) +
-			      999) / 1000);
-		} else {
-			tmp = ((LPDDR2_tWTR_LITTLE_200MHz * nMHz + 999) / 1000);
-		}
-		if (tmp < 2) {
-			tmp = 2;
-		}
-		p_pctl_timing->twtr = tmp & 0xF;
-		/*
-		 * WrToRd=WL+tDQSS+tWTR
-		 */
-		p_noc_timing->b.WrToRd = ((cwl + LPDDR2_tDQSS + tmp) & 0x1F);
-		/*
-		 * tXP, max(2tCK,7.5ns)
-		 */
-		tmp = ((LPDDR2_tXP * nMHz + (nMHz >> 1) + 999) / 1000);
-		if (tmp < 2) {
-			tmp = 2;
-		}
-		p_pctl_timing->txp = tmp & 0x7;
-		/*
-		 * tXPDLL, 0ns
-		 */
-		p_pctl_timing->txpdll = LPDDR2_tXPDLL;
-		/*
-		 * tZQCS, 90ns
-		 */
-		p_pctl_timing->tzqcs =
-		    ((LPDDR2_tZQCS * nMHz + 999) / 1000) & 0x7F;
-		/*
-		 * tZQCSI,
-		 */
-		/*if (pDDR_Reg->MCFG &= lpddr2_s4) {*/
-		if (1) {
-			p_pctl_timing->tzqcsi = LPDDR2_tZQCSI;
-		} else {
-			p_pctl_timing->tzqcsi = 0;
-		}
-		/*
-		 * tDQS,
-		 */
-		p_pctl_timing->tdqs = LPDDR2_tDQS;
-		/*
-		 * tCKSRE, 1 tCK
-		 */
-		p_pctl_timing->tcksre = LPDDR2_tCKSRE;
-		/*
-		 * tCKSRX, 2 tCK
-		 */
-		p_pctl_timing->tcksrx = LPDDR2_tCKSRX;
-		/*
-		 * tCKE, 3 tCK
-		 */
-		p_pctl_timing->tcke = LPDDR2_tCKE;
-		/*
-		 * tMOD, 0 tCK
-		 */
-		p_pctl_timing->tmod = LPDDR2_tMOD;
-		/*
-		 * tRSTL, 0 tCK
-		 */
-		p_pctl_timing->trstl = LPDDR2_tRSTL;
-		/*
-		 * tZQCL, 360ns
-		 */
-		p_pctl_timing->tzqcl =
-		    ((LPDDR2_tZQCL * nMHz + 999) / 1000) & 0x3FF;
-		/*
-		 * tMRR, 2 tCK
-		 */
-		p_pctl_timing->tmrr = LPDDR2_tMRR;
-		/*
-		 * tCKESR, max(3tCK,15ns)
-		 */
-		tmp = ((LPDDR2_tCKESR * nMHz + 999) / 1000);
-		if (tmp < 3) {
-			tmp = 3;
-		}
-		p_pctl_timing->tckesr = tmp & 0xF;
-		/*
-		 * tDPD, 500us
-		 */
-		p_pctl_timing->tdpd = LPDDR2_tDPD_US;
-
-		/*************************************************
-		* NOC Timing
-		**************************************************/
-		p_noc_timing->b.BurstLen = ((bl >> 1) & 0x7);
-	}
-
-out:
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_update_timing(void)
-*Desc    : pctl phy timing
-*Params  : void
-*Return  : 0 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_timing(void)
-{
-	uint32_t bl_tmp;
-	uint32_t ret = 0;
-
-	PCTL_TIMING_T *p_pctl_timing = &(DATA(ddr_reg).pctl_timing);
-	NOC_TIMING_T *p_noc_timing = &(DATA(ddr_reg).noc_timing);
-
-	ddr_copy((uint32 *)&(pDDR_Reg->TOGCNT1U),
-		 (uint32 *)&(p_pctl_timing->togcnt1u), 34);
-/*    pPHY_Reg->PHY_REG1 |= PHY_Burst8;*/    /*ddr3 burst length8*/
-	pPHY_Reg->PHY_REGb = ((p_pctl_timing->tcl << 4) | (p_pctl_timing->tal));
-	pPHY_Reg->PHY_REGc = p_pctl_timing->tcwl;
-	*(volatile uint32 *)SysSrv_DdrTiming = p_noc_timing->d32;
-	/*Update PCTL BL*/
-	if (DATA(ddr_reg).mem_type == DDR3) {
-		pDDR_Reg->MCFG =
-		    (pDDR_Reg->MCFG &
-		     (~(0x1 | (0x3 << 18) | (0x1 << 17) | (0x1 << 16))))
-		    | ddr2_ddr3_bl_8 | tfaw_cfg(5) | pd_exit_slow | pd_type(1);
-		pDDR_Reg->DFITRDDATAEN = (pDDR_Reg->TAL + pDDR_Reg->TCL) - 3;	/*trdata_en = rl-3*/
-		pDDR_Reg->DFITPHYWRLAT = pDDR_Reg->TCWL - 1;
-	} else if (DATA(ddr_reg).mem_type == LPDDR2) {
-		if ((DATA(ddr_reg).ddrMR[1] & 0x7) == LPDDR2_BL8) {
-			bl_tmp = mddr_lpddr2_bl_8;
-			pPHY_Reg->PHY_REG1 |= PHY_Burst8;
-		} else if ((DATA(ddr_reg).ddrMR[1] & 0x7) == LPDDR2_BL4) {
-			bl_tmp = mddr_lpddr2_bl_4;
-			pPHY_Reg->PHY_REG1 &= (~PHY_Burst8);
-		} else{		/*if((DATA(ddr_reg).ddrMR[1] & 0x7) == LPDDR2_BL16)*/
-			bl_tmp = mddr_lpddr2_bl_16;
-			ret = -1;
-		}
-		if (DATA(ddr_freq) >= 200) {
-			pDDR_Reg->MCFG =
-			    (pDDR_Reg->MCFG &
-			     (~
-			      ((0x3 << 20) | (0x3 << 18) | (0x1 << 17) |
-			       (0x1 << 16)))) | bl_tmp | tfaw_cfg(5) |
-			    pd_exit_fast | pd_type(1);
-		} else {
-			pDDR_Reg->MCFG =
-			    (pDDR_Reg->MCFG &
-			     (~
-			      ((0x3 << 20) | (0x3 << 18) | (0x1 << 17) |
-			       (0x1 << 16)))) | mddr_lpddr2_bl_8 | tfaw_cfg(6) |
-			    pd_exit_fast | pd_type(1);
-		}
-		pDDR_Reg->DFITRDDATAEN = pDDR_Reg->TCL - 3;
-		pDDR_Reg->DFITPHYWRLAT = pDDR_Reg->TCWL;
-
-	}
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_update_mr(void)
-*Desc    : MR
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_mr(void)
-{
-	/*uint32 cs;
-	cs = READ_CS_INFO();
-	cs = (1 << cs) - 1;	*/
-	if (DATA(ddr_reg).mem_type == DDR3) {
-		if (DATA(ddr_freq) > DDR3_DDR2_DLL_DISABLE_FREQ) {
-			if (DATA(ddr_dll_status) == DDR3_DLL_DISABLE) {	/*off -> on*/
-				ddr_send_command(3, MRS_cmd, bank_addr(0x1) | cmd_addr((DATA(ddr_reg).ddrMR[1])));	/*DLL enable*/
-				ddr_send_command(3, MRS_cmd, bank_addr(0x0) | cmd_addr(((DATA(ddr_reg).ddrMR[0])) | DDR3_DLL_RESET));	/*DLL reset*/
-				ddr_delayus(2);	/*at least 200 DDR cycle*/
-				ddr_send_command(3, MRS_cmd,
-						 bank_addr(0x0) |
-						 cmd_addr((DATA(ddr_reg).ddrMR
-							   [0])));
-				DATA(ddr_dll_status) = DDR3_DLL_ENABLE;
-			} else{  	/*on -> on*/
-				ddr_send_command(3, MRS_cmd,
-						 bank_addr(0x1) |
-						 cmd_addr((DATA(ddr_reg).ddrMR
-							   [1])));
-				ddr_send_command(3, MRS_cmd,
-						 bank_addr(0x0) |
-						 cmd_addr((DATA(ddr_reg).ddrMR
-							   [0])));
-			}
-		} else {
-			ddr_send_command(3, MRS_cmd, bank_addr(0x1) | cmd_addr(((DATA(ddr_reg).ddrMR[1])) | DDR3_DLL_DISABLE));	/*DLL disable*/
-			ddr_send_command(3, MRS_cmd,
-					 bank_addr(0x0) |
-					 cmd_addr((DATA(ddr_reg).ddrMR[0])));
-			DATA(ddr_dll_status) = DDR3_DLL_DISABLE;
-		}
-		ddr_send_command(3, MRS_cmd,
-				 bank_addr(0x2) |
-				 cmd_addr((DATA(ddr_reg).ddrMR[2])));
-	} else if (DATA(ddr_reg).mem_type == LPDDR2) {
-		ddr_send_command(3, MRS_cmd,
-				 lpddr2_ma(0x1) |
-				 lpddr2_op(DATA(ddr_reg).ddrMR[1]));
-		ddr_send_command(3, MRS_cmd,
-				 lpddr2_ma(0x2) |
-				 lpddr2_op(DATA(ddr_reg).ddrMR[2]));
-		ddr_send_command(3, MRS_cmd,
-				 lpddr2_ma(0x3) |
-				 lpddr2_op(DATA(ddr_reg).ddrMR[3]));
-	}
-	return 0;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_update_odt(void)
-*Desc    : update PHY odt & PHY driver impedance
-*Params  : void
-*Return  : void
-*Notes   :-------------------------------------------------*/
-static void __sramfunc ddr_update_odt(void)
-{
-	/*adjust DRV and ODT*/
-	uint32 phy_odt;
-	if (DATA(ddr_reg).mem_type == DDR3) {
-		if (DATA(ddr_freq) <= PHY_ODT_DISABLE_FREQ) {
-			phy_odt = PHY_RTT_DISABLE;
-		} else {
-			phy_odt = PHY_RTT_216ohm;
-		}
-	} else {
-		phy_odt = PHY_RTT_DISABLE;
-	}
-
-	pPHY_Reg->PHY_REG21 = PHY_DRV_ODT_SET(phy_odt);	/*DQS0 odt*/
-	pPHY_Reg->PHY_REG31 = PHY_DRV_ODT_SET(phy_odt);	/*DQS1 odt*/
-	pPHY_Reg->PHY_REG41 = PHY_DRV_ODT_SET(phy_odt);	/*DQS2 odt*/
-	pPHY_Reg->PHY_REG51 = PHY_DRV_ODT_SET(phy_odt);	/*DQS3 odt*/
-
-	pPHY_Reg->PHY_REG11 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*cmd drv*/
-	pPHY_Reg->PHY_REG16 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*clk drv*/
-
-	pPHY_Reg->PHY_REG20 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS0 drv*/
-	pPHY_Reg->PHY_REG30 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS1 drv*/
-	pPHY_Reg->PHY_REG40 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS2 drv*/
-	pPHY_Reg->PHY_REG50 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS3 drv*/
-
-	dsb();
-}
-
-#if 0
-void PIE_FUNC(ddr_adjust_config)(void)
-{
-	/*enter config state*/
-	ddr_move_to_Config_state();
-
-	/*set auto power down idle*/
-	pDDR_Reg->MCFG = (pDDR_Reg->MCFG & 0xffff00ff) | (PD_IDLE << 8);
-	/*enable the hardware low-power interface*/
-	pDDR_Reg->SCFG.b.hw_low_power_en = 1;
-	ddr_update_odt();
-	/*enter access state*/
-	ddr_move_to_Access_state();
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_adjust_config));
-
-/*----------------------------------------------------------------------
-Name    : __sramfunc void ddr_adjust_config(uint32_t dram_type)
-Desc    :
-Params  : dram_type ->
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-
-static void ddr_adjust_config(uint32_t dram_type)
-{
-	unsigned long save_sp;
-	uint32 i;
-	volatile uint32 n;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-
-    /** 1. Make sure there is no host access */
-	flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	dsb();
-
-	call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_adjust_config)),
-			(void *)0, rockchip_sram_stack);
-
-}
-#endif
-
-static void __sramfunc idle_port(void)
-{
-	int i;
-	uint32 clk_gate[11];
-	uint32 pd_status;
-	uint32 idle_req, idle_stus;
-	/*bit0:core bit1:gpu bit2:video bit3:vio 1:power off*/
-	pd_status = *(volatile uint32 *)PMU_PWEDN_ST;
-	/*save clock gate status*/
-	for (i = 0; i < 11; i++) {
-		clk_gate[i] = pCRU_Reg->CRU_CLKGATE_CON[i];
-	}
-	/*enable all clock gate for request idle*/
-	for (i = 0; i < 11; i++) {
-		pCRU_Reg->CRU_CLKGATE_CON[i] = 0xffff0000;
-	}
-
-	idle_req = (1 << peri_pwr_idlereq); /*peri*/
-	idle_stus = peri_pwr_idle;
-	if ((pd_status & (0x1<<3)) == 0) {/*pwr_vio*/
-		idle_req |= (1 << vio_pwr_idlereq);
-		idle_stus |= vio_pwr_idle;
-	}
-	if ((pd_status & (0x1<<2)) == 0) {/*pwr_vpu*/
-		idle_req |= (1 << vpu_pwr_idlereq);
-		idle_stus |= vpu_pwr_idle;
-	}
-	if ((pd_status & (0x1<<1)) == 0) {/*pwr_gpu*/
-		idle_req |= (1 << gpu_pwr_idlereq);
-		idle_stus |= gpu_pwr_idle;
-	}
-
-	pGRF_Reg->GRF_SOC_CON[2] = (idle_req << 16) | idle_req;
-	dsb();
-	while ((pGRF_Reg->GRF_SOC_STATUS0 & idle_stus) != idle_stus)
-	;
-
-	/*resume clock gate status*/
-	for (i = 0; i < 11; i++)
-		pCRU_Reg->CRU_CLKGATE_CON[i] = (clk_gate[i] | 0xffff0000);
-}
-
-static void __sramfunc deidle_port(void)
-{
-	int i;
-	uint32 clk_gate[11];
-	uint32 pd_status;
-	uint32 idle_req, idle_stus;
-	/*bit0:core bit1:gpu bit2:video bit3:vio 1:power off*/
-	pd_status = *(volatile uint32 *)PMU_PWEDN_ST;
-
-	/*save clock gate status*/
-	for (i = 0; i < 11; i++) {
-		clk_gate[i] = pCRU_Reg->CRU_CLKGATE_CON[i];
-	}
-	/*enable all clock gate for request idle*/
-	for (i = 0; i < 11; i++) {
-		pCRU_Reg->CRU_CLKGATE_CON[i] = 0xffff0000;
-	}
-
-	idle_req = (1 << peri_pwr_idlereq); /*peri*/
-	idle_stus = peri_pwr_idle;
-	if ((pd_status & (0x1<<3)) == 0) {/*pwr_vio*/
-		idle_req |= (1 << vio_pwr_idlereq);
-		idle_stus |= vio_pwr_idle;
-	}
-	if ((pd_status & (0x1<<2)) == 0) {/*pwr_vpu*/
-		idle_req |= (1 << vpu_pwr_idlereq);
-		idle_stus |= vpu_pwr_idle;
-	}
-	if ((pd_status & (0x1<<1)) == 0) {/*pwr_gpu*/
-		idle_req |= (1 << gpu_pwr_idlereq);
-		idle_stus |= gpu_pwr_idle;
-	}
-
-	pGRF_Reg->GRF_SOC_CON[2] = (idle_req << 16) | 0 ;
-	dsb();
-	while ((pGRF_Reg->GRF_SOC_STATUS0 & idle_stus) != 0)
-	;
-
-	/*resume clock gate status*/
-	for (i = 0; i < 11; i++)
-		pCRU_Reg->CRU_CLKGATE_CON[i] = (clk_gate[i] | 0xffff0000);
-
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_selfrefresh_enter(uint32 nMHz)
-*Desc    : 
-*Params  : nMHz ->ddr
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-#if 1
-static void __sramfunc ddr_selfrefresh_enter(uint32 nMHz)
-{
-	ddr_move_to_Config_state();
-	ddr_move_to_Lowpower_state();
-	pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_EN;
-	pPHY_Reg->PHY_REG0 = (pPHY_Reg->PHY_REG0 & (~(0x3 << 2)));	/*phy soft reset*/
-	dsb();
-	pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1 << 2) << 16) | (1 << 2);	/*disable DDR PHY clock*/
-	ddr_delayus(1);
-}
-#endif
-
-static uint32 dtt_buffer[8];
-
-/*----------------------------------------------------------------------
-*Name    : void ddr_dtt_check(void)
-*Desc    : data training check
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void ddr_dtt_check(void)
-{
-	uint32 i;
-	for (i = 0; i < 8; i++) {
-		dtt_buffer[i] = p_copy_data[i];
-	}
-	dsb();
-	flush_cache_all();
-	outer_flush_all();
-	for (i = 0; i < 8; i++) {
-		if (dtt_buffer[i] != p_copy_data[i]) {
-/*            sram_printascii("DTT failed!\n");*/
-			break;
-		}
-		dtt_buffer[i] = 0;
-	}
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_selfrefresh_exit(void)
-Desc    : 
-Params  : void
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-#if 1
-static void __sramfunc ddr_selfrefresh_exit(void)
-{
-	pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1 << 2) << 16) | (0 << 2);	/*enable DDR PHY clock*/
-	dsb();
-	ddr_delayus(1);
-	pPHY_Reg->PHY_REG0 |= (1 << 2); /*soft de-reset analogue(dll)*/
-	ddr_delayus(5);
-	pPHY_Reg->PHY_REG0 |= (1 << 3);/*soft de-reset digital*/
-	pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_DISB;
-	/*pPHY_Reg->PHY_REG264 |= (1<<1);*/
-	dsb();
-	ddr_move_to_Config_state();
-	ddr_data_training();
-	ddr_move_to_Access_state();
-/*    ddr_dtt_check();*/
-}
-
-#endif
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-*Desc    : ddr plltimingmr
-*Params  : freq_slew : 1  0
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-{
-	uint32 value_100n, value_1u;
-
-	if (freq_slew == 1) {
-		value_100n = DATA(ddr_reg).pctl_timing.togcnt100n;
-		value_1u = DATA(ddr_reg).pctl_timing.togcnt1u;
-		DATA(ddr_reg).pctl_timing.togcnt1u = pDDR_Reg->TOGCNT1U;
-		DATA(ddr_reg).pctl_timing.togcnt100n = pDDR_Reg->TOGCNT100N;
-		ddr_update_timing();
-		ddr_update_mr();
-		DATA(ddr_reg).pctl_timing.togcnt100n = value_100n;
-		DATA(ddr_reg).pctl_timing.togcnt1u = value_1u;
-	} else {
-		pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-		pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-	}
-
-	pDDR_Reg->TZQCSI = 0;
-
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-*Desc    : ddr plltimingmr
-*Params  : freq_slew : 1  0
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-{
-	if (freq_slew == 1) {
-		pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-		pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-		pDDR_Reg->TZQCSI = DATA(ddr_reg).pctl_timing.tzqcsi;
-	} else {
-		ddr_update_timing();
-		ddr_update_mr();
-	}
-	ddr_data_training();
-}
-
-static void __sramfunc ddr_SRE_2_SRX(uint32 freq, uint32 freq_slew)
-{
-	idle_port();
-
-	ddr_move_to_Config_state();
-	DATA(ddr_freq) = freq;
-	ddr_change_freq_in(freq_slew);
-	ddr_move_to_Lowpower_state();
-	pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_EN;
-	pPHY_Reg->PHY_REG0 = (pPHY_Reg->PHY_REG0 & (~(0x3 << 2)));	/*phy soft reset*/
-	dsb();
-    /* 3. change frequence  */
-	FUNC(ddr_set_pll) (freq, 1);
-	ddr_set_dll_bypass(freq);	/*set phy dll mode;*/
-	/*pPHY_Reg->PHY_REG0 = (pPHY_Reg->PHY_REG0 | (0x3 << 2)); */      /*phy soft de-reset */
-	pPHY_Reg->PHY_REG0 |= (1 << 2); /*soft de-reset analogue(dll)*/
-	ddr_delayus(5);
-	pPHY_Reg->PHY_REG0 |= (1 << 3);/*soft de-reset digital*/
-	pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_DISB;
-	dsb();
-	ddr_update_odt();
-	ddr_move_to_Config_state();
-	ddr_change_freq_out(freq_slew);
-	ddr_move_to_Access_state();
-
-	deidle_port();
-}
-
-void PIE_FUNC(ddr_change_freq_sram)(void *arg)
-{
-	struct ddr_change_freq_sram_param *param = arg;
-	/* Make sure ddr_SRE_2_SRX paramter less than 4 */
-	ddr_SRE_2_SRX(param->freq, param->freq_slew);
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_change_freq_sram));
-
-typedef struct freq_tag {
-	uint32_t nMHz;
-	struct ddr_freq_t *p_ddr_freq_t;
-} freq_t;
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramfunc ddr_change_freq(uint32_t nMHz)
-*Desc    : ddr
-*Params  : nMHz -> 
-*Return  : 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_change_freq_sram(void *arg)
-{
-	uint32 ret;
-	uint32 i;
-	volatile uint32 n;
-	unsigned long flags;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-	freq_t *p_freq_t = (freq_t *) arg;
-	uint32 nMHz = p_freq_t->nMHz;
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	struct ddr_freq_t *p_ddr_freq_t = p_freq_t->p_ddr_freq_t;
-#endif
-
-	struct ddr_change_freq_sram_param param;
-	/*uint32 freq;*/
-	uint32 freq_slew;
-	uint32 arm_freq;
-	arm_freq = ddr_get_pll_freq(APLL);
-	*kern_to_pie(rockchip_pie_chunk, &DATA(loops_per_us)) =
-	    LPJ_100MHZ * arm_freq / 1000000;
-	ret = p_ddr_set_pll(nMHz, 0);
-	if (ret == *p_ddr_freq) {
-		goto out;
-	} else {
-		freq_slew = (ret > *p_ddr_freq) ? 1 : -1;
-	}
-	ddr_get_parameter(ret);
-	/*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq))= ret;*/
-    /** 1. Make sure there is no host access */
-	local_irq_save(flags);
-	local_fiq_disable();
-	flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	if (p_ddr_freq_t->screen_ft_us > 0) {
-		p_ddr_freq_t->t1 = cpu_clock(0);
-		p_ddr_freq_t->t2 = (uint32)(p_ddr_freq_t->t1 - p_ddr_freq_t->t0);   /*ns*/
-
-		if ((p_ddr_freq_t->t2 > p_ddr_freq_t->screen_ft_us*1000) && (p_ddr_freq_t->screen_ft_us != 0xfefefefe)) {
-			ret = 0;
-			goto end;
-		} else {
-			rk_fb_poll_wait_frame_complete();
-		}
-	}
-#endif
-    /*8KB SRAM*/
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	n = pGRF_Reg->GRF_SOC_STATUS0;
-	dsb();
-	param.freq = ret;
-	param.freq_slew = freq_slew;
-	call_with_stack(fn_to_pie
-			(rockchip_pie_chunk, &FUNC(ddr_change_freq_sram)),
-			&param,
-			rockchip_sram_stack - (NR_CPUS -
-					       1) * PAUSE_CPU_STACK_SIZE);
-    /** 5. Issues a Mode Exit command   */
-	ddr_dtt_check();
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-end:
-#endif
-	local_fiq_enable();
-	local_irq_restore(flags);
-/*    clk_set_rate(clk_get(NULL, "ddr_pll"), 0);    */
-out:
-	return ret;
-}
-
-bool DEFINE_PIE_DATA(cpu_pause[NR_CPUS]);
-volatile bool *DATA(p_cpu_pause);
-static inline bool is_cpu0_paused(unsigned int cpu)
-{
-	smp_rmb();
-	return DATA(cpu_pause)[0];
-}
-
-static inline void set_cpuX_paused(unsigned int cpu, bool pause)
-{
-	DATA(cpu_pause)[cpu] = pause;
-	smp_wmb();
-}
-
-static inline bool is_cpuX_paused(unsigned int cpu)
-{
-	smp_rmb();
-	return DATA(p_cpu_pause)[cpu];
-}
-
-static inline void set_cpu0_paused(bool pause)
-{
-	DATA(p_cpu_pause)[0] = pause;
-	smp_wmb();
-}
-
-#define MAX_TIMEOUT (16000000UL << 6)	/*>0.64s*/
-
-/* Do not use stack, safe on SMP */
-void PIE_FUNC(_pause_cpu)(void *arg)
-{
-	unsigned int cpu = (unsigned int)arg;
-
-	set_cpuX_paused(cpu, true);
-	while (is_cpu0_paused(cpu))
-    ;
-	set_cpuX_paused(cpu, false);
-}
-
-static void pause_cpu(void *info)
-{
-	unsigned int cpu = raw_smp_processor_id();
-
-	call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(_pause_cpu)),
-			(void *)cpu,
-			rockchip_sram_stack - (cpu - 1) * PAUSE_CPU_STACK_SIZE);
-}
-
-static void wait_cpu(void *info)
-{
-}
-
-static int call_with_single_cpu(u32(*fn) (void *arg), void *arg)
-{
-	u32 timeout = MAX_TIMEOUT;
-	unsigned int cpu;
-	unsigned int this_cpu = smp_processor_id();	/*cpu*/
-	int ret = 0;
-	cpu_maps_update_begin();
-	local_bh_disable();	/*disable swi*/
-	set_cpu0_paused(true);
-	smp_call_function((smp_call_func_t) pause_cpu, NULL, 0);
-
-	for_each_online_cpu(cpu) {
-		if (cpu == this_cpu)
-			continue;
-		while (!is_cpuX_paused(cpu) && --timeout)
-		    ;
-		if (timeout == 0) {
-			pr_err("pause cpu %d timeout\n", cpu);
-			goto out;
-		}
-	}
-
-	ret = fn(arg);
-
-out:
-	set_cpu0_paused(false);
-	local_bh_enable();
-	smp_call_function(wait_cpu, NULL, true);
-	cpu_maps_update_done();
-
-	return ret;
-}
-
-static int __ddr_change_freq(uint32_t nMHz, struct ddr_freq_t ddr_freq_t)
-{
-	freq_t freq;
-	int ret = 0;
-
-	freq.nMHz = nMHz;
-	freq.p_ddr_freq_t = &ddr_freq_t;
-	ret = call_with_single_cpu(&ddr_change_freq_sram, (void *)&freq);
-	/*ret = ddr_change_freq_sram((void*)&freq);*/
-	return ret;
-}
-
-static int _ddr_change_freq(uint32 nMHz)
-{
-	struct ddr_freq_t ddr_freq_t;
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	unsigned long remain_t, vblank_t, pass_t;
-	static unsigned long reserve_t = 800;	/*us*/
-	unsigned long long tmp;
-	int test_count = 0;
-#endif
-	int ret;
-	/*ddr_print("ddr change freq to:%d\n",nMHz);*/
-	memset(&ddr_freq_t, 0x00, sizeof(ddr_freq_t));
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	do {
-		ddr_freq_t.screen_ft_us = rk_fb_get_prmry_screen_ft();
-		ddr_freq_t.t0 = rk_fb_get_prmry_screen_framedone_t();
-		if (!ddr_freq_t.screen_ft_us)
-			return __ddr_change_freq(nMHz, ddr_freq_t);
-
-		tmp = cpu_clock(0) - ddr_freq_t.t0;
-		do_div(tmp, 1000);
-		pass_t = tmp;
-		/*lost frame interrupt*/
-		while (pass_t > ddr_freq_t.screen_ft_us) {
-			int n = pass_t / ddr_freq_t.screen_ft_us;
-
-			/*printk("lost frame int, pass_t:%lu\n", pass_t);*/
-			pass_t -= n * ddr_freq_t.screen_ft_us;
-			ddr_freq_t.t0 += n * ddr_freq_t.screen_ft_us * 1000;
-		}
-
-		remain_t = ddr_freq_t.screen_ft_us - pass_t;
-		if (remain_t < reserve_t) {
-			/*printk("remain_t(%lu) < reserve_t(%lu)\n", remain_t, reserve_t);*/
-			vblank_t = rk_fb_get_prmry_screen_vbt();
-			usleep_range(remain_t + vblank_t, remain_t + vblank_t);
-			continue;
-		}
-		/*test 10 times*/
-		test_count++;
-		if (test_count > 10) {
-			ddr_freq_t.screen_ft_us = 0xfefefefe;
-		}
-		/*printk("ft:%lu, pass_t:%lu, remaint_t:%lu, reservet_t:%lu\n",
-		 *     ddr_freq_t.screen_ft_us, (unsigned long)pass_t, remain_t, reserve_t);*/
-		usleep_range(remain_t - reserve_t, remain_t - reserve_t);
-		flush_tlb_all();
-
-		ret = __ddr_change_freq(nMHz, ddr_freq_t);
-		if (ret) {
-			reserve_t = 800;
-			return ret;
-		} else {
-			if (reserve_t < 3000)
-				reserve_t += 200;
-		}
-	} while (1);
-#else
-	ret = __ddr_change_freq(nMHz, ddr_freq_t);
-#endif
-
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void ddr_set_auto_self_refresh(bool en)
-*Desc    :  selfrefesh 
-*Params  : en -> auto selfrefresh
-*Return  : 
-*Notes   : 1*32 cycle
-*----------------------------------------------------------------------*/
-static void _ddr_set_auto_self_refresh(bool en)
-{
-	/*set auto self-refresh idle    */
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = en ? SR_IDLE : 0;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramfunc ddr_suspend(void)
-*Desc    : ddr suspend
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-void PIE_FUNC(ddr_suspend)(void)
-{
-	ddr_selfrefresh_enter(0);
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x0 << (1 * 4));	/*PLL slow-mode*/
-	dsb();
-	ddr_delayus(1);
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x1 << 13);	/*PLL power-down*/
-	dsb();
-	ddr_delayus(1);
-
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_suspend));
-
-#if 0
-static void ddr_suspend(void)
-{
-	uint32 i;
-	volatile uint32 n;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-    /** 1. Make sure there is no host access */
-	flush_cache_all();
-	outer_flush_all();
-    /*flush_tlb_all();*/
-
-    /*sram size = 8KB*/
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	n = pGRF_Reg->GRF_SOC_STATUS0;
-	dsb();
-
-	fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_suspend)) ();
-}
-#endif
-
-/*----------------------------------------------------------------------
-*Name    : void __sramfunc ddr_resume(void)
-*Desc    : ddr resume
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-void PIE_FUNC(ddr_resume)(void)
-{
-	uint32 delay = 1000;
-
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x0 << 13);	/*PLL no power-down*/
-	dsb();
-	while (delay > 0) {
-		ddr_delayus(1);
-		if (pCRU_Reg->CRU_PLL_CON[1][1] & (0x1 << 10))
-			break;
-		delay--;
-	}
-
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x1 << (1 * 4));	/*PLL normal*/
-	dsb();
-
-	ddr_selfrefresh_exit();
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_resume));
-
-#if 0
-static void ddr_resume(void)
-{
-	fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_resume)) ();
-}
-#endif
-
-/*----------------------------------------------------------------------
-*Name    : uint32 ddr_get_cap(void)
-*Desc    : 
-*Params  : void
-*Return  : 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_get_cap(void)
-{
-	uint32 cs, bank, row, col, row1, bw;
-
-	bank = READ_BK_INFO();
-	row = READ_CS0_ROW_INFO();
-	col = READ_COL_INFO();
-	cs = READ_CS_INFO();
-	bw = READ_BW_INFO();
-	if (cs > 1) {
-		row1 = READ_CS1_ROW_INFO();
-		return ((1 << (row + col + bank + bw)) +
-			(1 << (row1 + col + bank + bw)));
-	} else {
-		return (1 << (row + col + bank + bw));
-	}
-}
-
-static long _ddr_round_rate(uint32 nMHz)
-{
-	return p_ddr_set_pll(nMHz, 0);
-}
-
-enum ddr_bandwidth_id{
-	ddrbw_wr_num = 0,
-	ddrbw_rd_num,
-	ddrbw_act_num,
-	ddrbw_time_num,
-	ddrbw_id_end
-};
-
-static void ddr_dfi_monitor_strat(void)
-{
-	pGRF_Reg->GRF_SOC_CON[0] = DDR_MONITOR_EN;
-}
-static void ddr_dfi_monitor_stop(void)
-{
-	pGRF_Reg->GRF_SOC_CON[0] = DDR_MONITOR_DISB;
-}
-
-static void _ddr_bandwidth_get(struct ddr_bw_info *ddr_bw_ch0, struct ddr_bw_info *ddr_bw_ch1)
-{
-	uint32 ddr_bw_val[ddrbw_id_end], ddr_freq;
-	u64 temp64;
-	uint32 i;
-	uint32 ddr_bw;
-	uint32 bl;
-
-	if (p_ddr_reg->mem_type == DDR3)
-		bl = 8;
-	else
-		bl = ((pDDR_Reg->MCFG >> 20) & 0x3) << 2;
-
-	ddr_bw = READ_BW_INFO();
-	ddr_dfi_monitor_stop();
-	for (i = 0; i < ddrbw_id_end; i++) {
-		ddr_bw_val[i] = *(uint32 *)(&(pGRF_Reg->GRF_DFI_WRNUM) + i);
-	}
-	if (!ddr_bw_val[ddrbw_time_num])
-		goto end;
-
-	ddr_freq = pDDR_Reg->TOGCNT1U;
-	temp64 = ((u64)ddr_bw_val[ddrbw_wr_num] + (u64)ddr_bw_val[ddrbw_rd_num])
-		 * bl / 2 * 100;
-	do_div(temp64, ddr_bw_val[ddrbw_time_num]);
-
-	ddr_bw_ch0->ddr_percent = (uint32)temp64;
-	ddr_bw_ch0->ddr_time = ddr_bw_val[ddrbw_time_num] / (ddr_freq * 1000);
-	temp64 = ((u64)ddr_bw_val[ddrbw_wr_num] * bl * ddr_bw * 2) * ddr_freq;
-	do_div(temp64, ddr_bw_val[ddrbw_time_num]);
-	ddr_bw_ch0->ddr_wr = (uint32)temp64;
-	temp64 = ((u64)ddr_bw_val[ddrbw_rd_num] * bl * ddr_bw * 2) * ddr_freq;
-	do_div(temp64, ddr_bw_val[ddrbw_time_num]);
-	ddr_bw_ch0->ddr_rd = (uint32)temp64;
-	ddr_bw_ch0->ddr_act = ddr_bw_val[ddrbw_act_num];
-	ddr_bw_ch0->ddr_total = ddr_freq * 2 * ddr_bw * 2;
-end:
-	ddr_dfi_monitor_strat();
-}
-
-/*----------------------------------------------------------------------
-*Name    : int ddr_init(uint32_t dram_speed_bin, uint32_t freq)
-*Desc    : ddr  
-*Params  : dram_speed_bin ->ddr
-*          freq ->
-*Return  : 0 
-*Notes   :
-*----------------------------------------------------------------------*/
-static int ddr_init(uint32_t dram_speed_bin, uint32 freq)
-{
-	uint32_t value = 0;
-	uint32_t cs, die = 1;
-	/*uint32_t calStatusLeft, calStatusRight*/
-	struct clk *clk;
-
-	ddr_print("version 1.02 20140828\n");
-	cs = READ_CS_INFO();	/*case 1:1rank ; case 2:2rank*/
-
-	p_ddr_reg = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-	p_ddr_freq = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq));
-	p_ddr_set_pll = fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_set_pll));
-	DATA(p_cpu_pause) =
-	    kern_to_pie(rockchip_pie_chunk, &DATA(cpu_pause[0]));
-	p_ddr_reg->mem_type = ((pGRF_Reg->GRF_OS_REG[1] >> 13) & 0x7);
-	p_ddr_reg->ddr_speed_bin = dram_speed_bin;
-	*p_ddr_freq = 0;
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = 0;
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_dll_status)) =
-	    DDR3_DLL_DISABLE;
-	p_copy_data = kern_to_pie(rockchip_pie_chunk, &copy_data[0]);
-
-	switch (p_ddr_reg->mem_type) {
-	case DDR3:
-		ddr_print("DRAM Type:DDR3\n");
-		break;
-	case LPDDR2:
-		ddr_print("DRAM Type:LPDDR2\n");
-		break;
-	default:
-		ddr_print("ddr type error type=%d\n", (p_ddr_reg->mem_type));
-	}
-	die = 1 << (READ_BW_INFO() - READ_DIE_BW_INFO());
-	p_ddr_reg->ddr_capability_per_die = ddr_get_cap() / (cs * die);
-	ddr_print("%d CS, ROW=%d, Bank=%d, COL=%d, Total Capability=%dMB\n",
-						cs, READ_CS0_ROW_INFO(),
-						(0x1 << (READ_BK_INFO())),
-						READ_COL_INFO(),
-						(ddr_get_cap() >> 20));
-
-	clk = clk_get(NULL, "clk_ddr");
-	if (IS_ERR(clk)) {
-		ddr_print("failed to get ddr clk\n");
-		clk = NULL;
-	}
-	if (freq != 0)
-		value = clk_set_rate(clk, 1000 * 1000 * freq);
-	else
-		value = clk_set_rate(clk, clk_get_rate(clk));
-	ddr_print("init success!!! freq=%luMHz\n",
-		  clk ? clk_get_rate(clk) / 1000000 : freq);
-
-	return 0;
-}
diff --git a/arch/arm/mach-rockchip/ddr_rk3126b.c b/arch/arm/mach-rockchip/ddr_rk3126b.c
deleted file mode 100755
index 9cba6f0fc722..000000000000
--- a/arch/arm/mach-rockchip/ddr_rk3126b.c
+++ /dev/null
@@ -1,2312 +0,0 @@
-/*
- * arch/arm/mach-rk2928/ddr.c-- for ddr3&ddr2
- *
- * Function Driver for DDR controller
- *
- * Copyright (C) 2012 Fuzhou Rockchip Electronics Co.,Ltd
- * Author:
- * hcy@rock-chips.com
- * yk@rock-chips.com
- * typ@rock-chips.com
- *
- * v1.00
- */
-
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/cpu.h>
-#include <dt-bindings/clock/ddr.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rk_fb.h>
-
-typedef uint32_t uint32;
-
-#define DDR3_DDR2_DLL_DISABLE_FREQ    (300)	/* dll disable*/
-#define DDR3_DDR2_ODT_DISABLE_FREQ    (333)	/*odt disable*/
-#define SR_IDLE                       (0x1)	/*unit:32*DDR clk cycle, and 0 for disable auto self-refresh*/
-#define PD_IDLE                       (0x40)	/*unit:DDR clk cycle, and 0 for disable auto power-down*/
-#define PHY_ODT_DISABLE_FREQ          (333)	/*odt disable*/
-#define PHY_DLL_DISABLE_FREQ          (266)	/*dll bypass*/
-
-#define ddr_print(x...) printk("DDR DEBUG: " x)
-
-#define SRAM_CODE_OFFSET        rockchip_sram_virt
-#define SRAM_SIZE               rockchip_sram_size
-
-#ifdef CONFIG_FB_ROCKCHIP
-#define DDR_CHANGE_FREQ_IN_LCDC_VSYNC
-#endif
-
-/*#define PHY_RX_PHASE_CAL*/
-#define PHY_DE_SKEW_STEP  (20)
-/***********************************
- * DDR3 define
- ***********************************/
-/*mr0 for ddr3*/
-#define DDR3_BL8          (0)
-#define DDR3_BC4_8        (1)
-#define DDR3_BC4          (2)
-#define DDR3_CL(n)        (((((n)-4)&0x7)<<4)|((((n)-4)&0x8)>>1))
-#define DDR3_WR(n)        (((n)&0x7)<<9)
-#define DDR3_DLL_RESET    (1<<8)
-#define DDR3_DLL_DeRESET  (0<<8)
-
-/*mr1 for ddr3*/
-#define DDR3_DLL_ENABLE    (0)
-#define DDR3_DLL_DISABLE   (1)
-#define DDR3_MR1_AL(n)  (((n)&0x7)<<3)
-
-#define DDR3_DS_40            (0)
-#define DDR3_DS_34            (1<<1)
-#define DDR3_Rtt_Nom_DIS      (0)
-#define DDR3_Rtt_Nom_60       (1<<2)
-#define DDR3_Rtt_Nom_120      (1<<6)
-#define DDR3_Rtt_Nom_40       ((1<<2)|(1<<6))
-
-/*mr2 for ddr3*/
-#define DDR3_MR2_CWL(n) ((((n)-5)&0x7)<<3)
-#define DDR3_Rtt_WR_DIS       (0)
-#define DDR3_Rtt_WR_60        (1<<9)
-#define DDR3_Rtt_WR_120       (2<<9)
-
-#define DDR_PLL_REFDIV  (1)
-#define FBDIV(n)        ((0xFFF<<16) | (n&0xfff))
-#define REFDIV(n)       ((0x3F<<16) | (n&0x3f))
-#define POSTDIV1(n)     ((0x7<<(12+16)) | ((n&0x7)<<12))
-#define POSTDIV2(n)     ((0x7<<(6+16)) | ((n&0x7)<<6))
-
-#define PLL_LOCK_STATUS  (0x1<<10)
- /*CRU Registers updated*/
-typedef volatile struct tagCRU_STRUCT {
-	uint32 CRU_PLL_CON[4][4];
-	uint32 CRU_MODE_CON;
-	uint32 CRU_CLKSEL_CON[35];
-	uint32 CRU_CLKGATE_CON[11];	/*0xd0*/
-	uint32 reserved1;	/*0xfc*/
-	uint32 CRU_GLB_SRST_FST_VALUE;	/*0x100*/
-	uint32 CRU_GLB_SRST_SND_VALUE;
-	uint32 reserved2[2];
-	uint32 CRU_SOFTRST_CON[9];	/*0x110*/
-	uint32 CRU_MISC_CON;	/*0x134*/
-	uint32 reserved3[2];
-	uint32 CRU_GLB_CNT_TH;	/*0x140*/
-	uint32 reserved4[3];
-	uint32 CRU_GLB_RST_ST;	/*0x150*/
-	uint32 reserved5[(0x1c0 - 0x154) / 4];
-	uint32 CRU_SDMMC_CON[2];	/*0x1c0*/
-	uint32 CRU_SDIO_CON[2];
-	uint32 reserved6[2];
-	uint32 CRU_EMMC_CON[2];	/*0x1d8*/
-	uint32 reserved7[(0x1f0 - 0x1e0) / 4];
-	uint32 CRU_PLL_PRG_EN;
-} CRU_REG, *pCRU_REG;
-
-typedef struct tagGPIO_LH {
-	uint32 GPIOL;
-	uint32 GPIOH;
-} GPIO_LH_T;
-
-typedef struct tagGPIO_IOMUX {
-	uint32 GPIOA_IOMUX;
-	uint32 GPIOB_IOMUX;
-	uint32 GPIOC_IOMUX;
-	uint32 GPIOD_IOMUX;
-} GPIO_IOMUX_T;
-
-/********************************
-*GRF GRF_OS_REG1 ddr ranktype
-*GRF_SOC_CON2c_sysreqpctllow power 
-*GRF_DDRC_STAT pctl low power
-********************************/
-/*REG FILE registers*/
-/*GRF_SOC_CON0*/
-#define DDR_MONITOR_EN  ((1<<(16+6))+(1<<6))
-#define DDR_MONITOR_DISB  ((1<<(16+6))+(0<<6))
-
-/*GRF_SOC_STATUS0*/
-#define sys_pwr_idle     (1<<27)
-#define gpu_pwr_idle     (1<<26)
-#define vpu_pwr_idle     (1<<25)
-#define vio_pwr_idle     (1<<24)
-#define peri_pwr_idle    (1<<23)
-#define core_pwr_idle     (1<<22)
-/*GRF_SOC_CON2*/
-#define core_pwr_idlereq    (13)
-#define peri_pwr_idlereq    (12)
-#define vio_pwr_idlereq     (11)
-#define vpu_pwr_idlereq     (10)
-#define gpu_pwr_idlereq     (9)
-#define sys_pwr_idlereq     (8)
-#define GRF_DDR_LP_EN     (0x1<<(2+16))
-#define GRF_DDR_LP_DISB     ((0x1<<(2+16))|(0x1<<2))
-
-/*grf updated*/
-typedef volatile struct tagREG_FILE {
-	uint32 reserved0[(0xa8 - 0x0) / 4];
-	GPIO_IOMUX_T GRF_GPIO_IOMUX[4];	/*0x00a8*/
-	uint32 GRF_GPIO2C_IOMUX2;	/*0xe8*/
-	uint32 GRF_CIF_IOMUX[2];
-	uint32 reserved1[(0x100 - 0xf4) / 4];
-	uint32 GRF_GPIO_DS;	/*0x100*/
-	uint32 reserved2[(0x118 - 0x104) / 4];
-	GPIO_LH_T GRF_GPIO_PULL[4];	/*0x118*/
-	uint32 reserved3[1];
-	uint32 GRF_ACODEC_CON;	/*0x13c*/
-	uint32 GRF_SOC_CON[3];	/*0x140*/
-	uint32 GRF_SOC_STATUS0;
-	uint32 GRF_LVDS_CON0;	/*0x150*/
-	uint32 reserved4[(0x15c - 0x154) / 4];
-	uint32 GRF_DMAC_CON[3];	/*0x15c*/
-	uint32 GRF_MAC_CON[2];
-	uint32 GRF_TVE_CON;	/*0x170*/
-	uint32 reserved5[(0x17c - 0x174) / 4];
-	uint32 GRF_UOC0_CON0;	/*0x17c*/
-	uint32 reserved6;
-	uint32 GRF_UOC1_CON[5];	/*0x184*/
-	uint32 reserved7;
-	uint32 GRF_DDRC_STAT;	/*0x19c*/
-	uint32 reserved8;
-	uint32 GRF_SOC_STATUS1;	/*0x1a4*/
-	uint32 GRF_CPU_CON[4];
-	uint32 reserved9[(0x1c0 - 0x1b8) / 4];
-	uint32 GRF_CPU_STATUS[2];	/*0x1c0*/
-	uint32 GRF_OS_REG[8];
-	uint32 reserved10[(0x200 - 0x1e8) / 4];
-	uint32 GRF_PVTM_CON[4];	/*0x200*/
-	uint32 GRF_PVTM_STATUS[4];
-	/*uint32 reserved10[(0x220-0x214)/4];*/
-	uint32 GRF_DFI_WRNUM;	/*0X220*/
-	uint32 GRF_DFI_RDNUM;
-	uint32 GRF_DFI_ACTNUM;
-	uint32 GRF_DFI_TIMERVAL;
-	uint32 GRF_NIF_FIFO[4];
-	uint32 reserved11[(0x280 - 0x240) / 4];
-	uint32 GRF_USBPHY0_CON[8];	/*0x280*/
-	uint32 GRF_USBPHY1_CON[8];
-	uint32 GRF_UOC_STATUS0;	/*0x2c0*/
-	uint32 reserved12[(0x300 - 0x2c4) / 4];
-	uint32 GRF_CHIP_TAG;
-	uint32 GRF_SDMMC_DET_CNT;
-	uint32 reserved13[(0x37c - 0x308) / 4];
-	uint32 GRF_EFUSE_PRG_EN;
-} REG_FILE, *pREG_FILE;
-
-/*SCTL*/
-#define INIT_STATE                     (0)
-#define CFG_STATE                      (1)
-#define GO_STATE                       (2)
-#define SLEEP_STATE                    (3)
-#define WAKEUP_STATE                   (4)
-
-/*STAT*/
-#define Init_mem                       (0)
-#define Config                         (1)
-#define Config_req                     (2)
-#define Access                         (3)
-#define Access_req                     (4)
-#define Low_power                      (5)
-#define Low_power_entry_req            (6)
-#define Low_power_exit_req             (7)
-
-/*MCFG*/
-#define mddr_lpddr2_clk_stop_idle(n)   ((n)<<24)
-#define pd_idle(n)                     ((n)<<8)
-#define mddr_en                        (2<<22)
-#define lpddr2_en                      (3<<22)
-#define ddr2_en                        (0<<5)
-#define ddr3_en                        (1<<5)
-#define lpddr2_s2                      (0<<6)
-#define lpddr2_s4                      (1<<6)
-#define mddr_lpddr2_bl_2               (0<<20)
-#define mddr_lpddr2_bl_4               (1<<20)
-#define mddr_lpddr2_bl_8               (2<<20)
-#define mddr_lpddr2_bl_16              (3<<20)
-#define ddr2_ddr3_bl_4                 (0)
-#define ddr2_ddr3_bl_8                 (1)
-#define tfaw_cfg(n)                    (((n)-4)<<18)
-#define pd_exit_slow                   (0<<17)
-#define pd_exit_fast                   (1<<17)
-#define pd_type(n)                     ((n)<<16)
-#define two_t_en(n)                    ((n)<<3)
-#define bl8int_en(n)                   ((n)<<2)
-#define cke_or_en(n)                   ((n)<<1)
-
-/*POWCTL*/
-#define power_up_start                 (1<<0)
-
-/*POWSTAT*/
-#define power_up_done                  (1<<0)
-
-/*DFISTSTAT0*/
-#define dfi_init_complete              (1<<0)
-
-/*CMDTSTAT*/
-#define cmd_tstat                      (1<<0)
-
-/*CMDTSTATEN*/
-#define cmd_tstat_en                   (1<<1)
-
-/*MCMD*/
-#define Deselect_cmd                   (0)
-#define PREA_cmd                       (1)
-#define REF_cmd                        (2)
-#define MRS_cmd                        (3)
-#define ZQCS_cmd                       (4)
-#define ZQCL_cmd                       (5)
-#define RSTL_cmd                       (6)
-#define MRR_cmd                        (8)
-#define DPDE_cmd                       (9)
-
-#define lpddr2_op(n)                   ((n)<<12)
-#define lpddr2_ma(n)                   ((n)<<4)
-
-#define bank_addr(n)                   ((n)<<17)
-#define cmd_addr(n)                    ((n)<<4)
-
-#define start_cmd                      (1u<<31)
-
-typedef union STAT_Tag {
-	uint32 d32;
-	struct {
-		unsigned ctl_stat:3;
-		unsigned reserved3:1;
-		unsigned lp_trig:3;
-		unsigned reserved7_31:25;
-	} b;
-} STAT_T;
-
-typedef union SCFG_Tag {
-	uint32 d32;
-	struct {
-		unsigned hw_low_power_en:1;
-		unsigned reserved1_5:5;
-		unsigned nfifo_nif1_dis:1;
-		unsigned reserved7:1;
-		unsigned bbflags_timing:4;
-		unsigned reserved12_31:20;
-	} b;
-} SCFG_T;
-
-/* DDR Controller register struct */
-typedef volatile struct DDR_REG_Tag {
-	/*Operational State, Control, and Status Registers*/
-	SCFG_T SCFG;		/*State Configuration Register*/
-	volatile uint32 SCTL;	/*State Control Register*/
-	STAT_T STAT;		/*State Status Register*/
-	volatile uint32 INTRSTAT;	/*Interrupt Status Register*/
-	uint32 reserved0[(0x40 - 0x10) / 4];
-	/*Initailization Control and Status Registers*/
-	volatile uint32 MCMD;	/*Memory Command Register*/
-	volatile uint32 POWCTL;	/*Power Up Control Registers*/
-	volatile uint32 POWSTAT;	/*Power Up Status Register*/
-	volatile uint32 CMDTSTAT;	/*Command Timing Status Register*/
-	volatile uint32 CMDTSTATEN;	/*Command Timing Status Enable Register*/
-	uint32 reserved1[(0x60 - 0x54) / 4];
-	volatile uint32 MRRCFG0;	/*MRR Configuration 0 Register*/
-	volatile uint32 MRRSTAT0;	/*MRR Status 0 Register*/
-	volatile uint32 MRRSTAT1;	/*MRR Status 1 Register*/
-	uint32 reserved2[(0x7c - 0x6c) / 4];
-	/*Memory Control and Status Registers*/
-	volatile uint32 MCFG1;	/*Memory Configuration 1 Register*/
-	volatile uint32 MCFG;	/*Memory Configuration Register*/
-	volatile uint32 PPCFG;	/*Partially Populated Memories Configuration Register*/
-	volatile uint32 MSTAT;	/*Memory Status Register*/
-	volatile uint32 LPDDR2ZQCFG;	/*LPDDR2 ZQ Configuration Register*/
-	uint32 reserved3;
-	/*DTU Control and Status Registers*/
-	volatile uint32 DTUPDES;	/*DTU Status Register*/
-	volatile uint32 DTUNA;	/*DTU Number of Random Addresses Created Register*/
-	volatile uint32 DTUNE;	/*DTU Number of Errors Register*/
-	volatile uint32 DTUPRD0;	/*DTU Parallel Read 0*/
-	volatile uint32 DTUPRD1;	/*DTU Parallel Read 1*/
-	volatile uint32 DTUPRD2;	/*DTU Parallel Read 2*/
-	volatile uint32 DTUPRD3;	/*DTU Parallel Read 3*/
-	volatile uint32 DTUAWDT;	/*DTU Address Width*/
-	uint32 reserved4[(0xc0 - 0xb4) / 4];
-	/*Memory Timing Registers*/
-	volatile uint32 TOGCNT1U;	/*Toggle Counter 1U Register*/
-	volatile uint32 TINIT;	/*t_init Timing Register*/
-	volatile uint32 TRSTH;	/*Reset High Time Register*/
-	volatile uint32 TOGCNT100N;	/*Toggle Counter 100N Register*/
-	volatile uint32 TREFI;	/*t_refi Timing Register*/
-	volatile uint32 TMRD;	/*t_mrd Timing Register*/
-	volatile uint32 TRFC;	/*t_rfc Timing Register*/
-	volatile uint32 TRP;	/*t_rp Timing Register*/
-	volatile uint32 TRTW;	/*t_rtw Timing Register*/
-	volatile uint32 TAL;	/*AL Latency Register*/
-	volatile uint32 TCL;	/*CL Timing Register*/
-	volatile uint32 TCWL;	/*CWL Register*/
-	volatile uint32 TRAS;	/*t_ras Timing Register*/
-	volatile uint32 TRC;	/*t_rc Timing Register*/
-	volatile uint32 TRCD;	/*t_rcd Timing Register*/
-	volatile uint32 TRRD;	/*t_rrd Timing Register*/
-	volatile uint32 TRTP;	/*t_rtp Timing Register*/
-	volatile uint32 TWR;	/*t_wr Timing Register*/
-	volatile uint32 TWTR;	/*t_wtr Timing Register*/
-	volatile uint32 TEXSR;	/*t_exsr Timing Register*/
-	volatile uint32 TXP;	/*t_xp Timing Register*/
-	volatile uint32 TXPDLL;	/*t_xpdll Timing Register*/
-	volatile uint32 TZQCS;	/*t_zqcs Timing Register*/
-	volatile uint32 TZQCSI;	/*t_zqcsi Timing Register*/
-	volatile uint32 TDQS;	/*t_dqs Timing Register*/
-	volatile uint32 TCKSRE;	/*t_cksre Timing Register*/
-	volatile uint32 TCKSRX;	/*t_cksrx Timing Register*/
-	volatile uint32 TCKE;	/*t_cke Timing Register*/
-	volatile uint32 TMOD;	/*t_mod Timing Register*/
-	volatile uint32 TRSTL;	/*Reset Low Timing Register*/
-	volatile uint32 TZQCL;	/*t_zqcl Timing Register*/
-	volatile uint32 TMRR;	/*t_mrr Timing Register*/
-	volatile uint32 TCKESR;	/*t_ckesr Timing Register*/
-	volatile uint32 TDPD;	/*t_dpd Timing Register*/
-	uint32 reserved5[(0x180 - 0x148) / 4];
-	/*ECC Configuration, Control, and Status Registers*/
-	volatile uint32 ECCCFG;	/*ECC Configuration Register*/
-	volatile uint32 ECCTST;	/*ECC Test Register*/
-	volatile uint32 ECCCLR;	/*ECC Clear Register*/
-	volatile uint32 ECCLOG;	/*ECC Log Register*/
-	uint32 reserved6[(0x200 - 0x190) / 4];
-	/*DTU Control and Status Registers*/
-	volatile uint32 DTUWACTL;	/*DTU Write Address Control Register*/
-	volatile uint32 DTURACTL;	/*DTU Read Address Control Register*/
-	volatile uint32 DTUCFG;	/*DTU Configuration Control Register*/
-	volatile uint32 DTUECTL;	/*DTU Execute Control Register*/
-	volatile uint32 DTUWD0;	/*DTU Write Data 0*/
-	volatile uint32 DTUWD1;	/*DTU Write Data 1*/
-	volatile uint32 DTUWD2;	/*DTU Write Data 2*/
-	volatile uint32 DTUWD3;	/*DTU Write Data 3*/
-	volatile uint32 DTUWDM;	/*DTU Write Data Mask*/
-	volatile uint32 DTURD0;	/*DTU Read Data 0*/
-	volatile uint32 DTURD1;	/*DTU Read Data 1*/
-	volatile uint32 DTURD2;	/*DTU Read Data 2*/
-	volatile uint32 DTURD3;	/*DTU Read Data 3*/
-	volatile uint32 DTULFSRWD;	/*DTU LFSR Seed for Write Data Generation*/
-	volatile uint32 DTULFSRRD;	/*DTU LFSR Seed for Read Data Generation*/
-	volatile uint32 DTUEAF;	/*DTU Error Address FIFO*/
-	/*DFI Control Registers*/
-	volatile uint32 DFITCTRLDELAY;	/*DFI tctrl_delay Register*/
-	volatile uint32 DFIODTCFG;	/*DFI ODT Configuration Register*/
-	volatile uint32 DFIODTCFG1;	/*DFI ODT Configuration 1 Register*/
-	volatile uint32 DFIODTRANKMAP;	/*DFI ODT Rank Mapping Register*/
-	/*DFI Write Data Registers*/
-	volatile uint32 DFITPHYWRDATA;	/*DFI tphy_wrdata Register*/
-	volatile uint32 DFITPHYWRLAT;	/*DFI tphy_wrlat Register*/
-	uint32 reserved7[(0x260 - 0x258) / 4];
-	volatile uint32 DFITRDDATAEN;	/*DFI trddata_en Register*/
-	volatile uint32 DFITPHYRDLAT;	/*DFI tphy_rddata Register*/
-	uint32 reserved8[(0x270 - 0x268) / 4];
-	/*DFI Update Registers*/
-	volatile uint32 DFITPHYUPDTYPE0;	/*DFI tphyupd_type0 Register*/
-	volatile uint32 DFITPHYUPDTYPE1;	/*DFI tphyupd_type1 Register*/
-	volatile uint32 DFITPHYUPDTYPE2;	/*DFI tphyupd_type2 Register*/
-	volatile uint32 DFITPHYUPDTYPE3;	/*DFI tphyupd_type3 Register*/
-	volatile uint32 DFITCTRLUPDMIN;	/*DFI tctrlupd_min Register*/
-	volatile uint32 DFITCTRLUPDMAX;	/*DFI tctrlupd_max Register*/
-	volatile uint32 DFITCTRLUPDDLY;	/*DFI tctrlupd_dly Register*/
-	uint32 reserved9;
-	volatile uint32 DFIUPDCFG;	/*DFI Update Configuration Register*/
-	volatile uint32 DFITREFMSKI;	/*DFI Masked Refresh Interval Register*/
-	volatile uint32 DFITCTRLUPDI;	/*DFI tctrlupd_interval Register*/
-	uint32 reserved10[(0x2ac - 0x29c) / 4];
-	volatile uint32 DFITRCFG0;	/*DFI Training Configuration 0 Register*/
-	volatile uint32 DFITRSTAT0;	/*DFI Training Status 0 Register*/
-	volatile uint32 DFITRWRLVLEN;	/*DFI Training dfi_wrlvl_en Register*/
-	volatile uint32 DFITRRDLVLEN;	/*DFI Training dfi_rdlvl_en Register*/
-	volatile uint32 DFITRRDLVLGATEEN;	/*DFI Training dfi_rdlvl_gate_en Register*/
-	/*DFI Status Registers*/
-	volatile uint32 DFISTSTAT0;	/*DFI Status Status 0 Register*/
-	volatile uint32 DFISTCFG0;	/*DFI Status Configuration 0 Register*/
-	volatile uint32 DFISTCFG1;	/*DFI Status configuration 1 Register*/
-	uint32 reserved11;
-	volatile uint32 DFITDRAMCLKEN;	/*DFI tdram_clk_enalbe Register*/
-	volatile uint32 DFITDRAMCLKDIS;	/*DFI tdram_clk_disalbe Register*/
-	volatile uint32 DFISTCFG2;	/*DFI Status configuration 2 Register*/
-	volatile uint32 DFISTPARCLR;	/*DFI Status Parity Clear Register*/
-	volatile uint32 DFISTPARLOG;	/*DFI Status Parity Log Register*/
-	uint32 reserved12[(0x2f0 - 0x2e4) / 4];
-	/*DFI Low Power Registers*/
-	volatile uint32 DFILPCFG0;	/*DFI Low Power Configuration 0 Register*/
-	uint32 reserved13[(0x300 - 0x2f4) / 4];
-	/*DFI Training 2 Registers*/
-	volatile uint32 DFITRWRLVLRESP0;	/*DFI Training dif_wrlvl_resp Status 0 Register*/
-	volatile uint32 DFITRWRLVLRESP1;	/*DFI Training dif_wrlvl_resp Status 1 Register*/
-	volatile uint32 DFITRWRLVLRESP2;	/*DFI Training dif_wrlvl_resp Status 2 Register*/
-	volatile uint32 DFITRRDLVLRESP0;	/*DFI Training dif_rdlvl_resp Status 0 Register*/
-	volatile uint32 DFITRRDLVLRESP1;	/*DFI Training dif_rdlvl_resp Status 1 Register*/
-	volatile uint32 DFITRRDLVLRESP2;	/*DFI Training dif_rdlvl_resp Status 2 Register*/
-	volatile uint32 DFITRWRLVLDELAY0;	/*DFI Training dif_wrlvl_delay Configuration 0 Register*/
-	volatile uint32 DFITRWRLVLDELAY1;	/*DFI Training dif_wrlvl_delay Configuration 1 Register*/
-	volatile uint32 DFITRWRLVLDELAY2;	/*DFI Training dif_wrlvl_delay Configuration 2 Register*/
-	volatile uint32 DFITRRDLVLDELAY0;	/*DFI Training dif_rdlvl_delay Configuration 0 Register*/
-	volatile uint32 DFITRRDLVLDELAY1;	/*DFI Training dif_rdlvl_delay Configuration 1 Register*/
-	volatile uint32 DFITRRDLVLDELAY2;	/*DFI Training dif_rdlvl_delay Configuration 2 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY0;	/*DFI Training dif_rdlvl_gate_delay Configuration 0 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY1;	/*DFI Training dif_rdlvl_gate_delay Configuration 1 Register*/
-	volatile uint32 DFITRRDLVLGATEDELAY2;	/*DFI Training dif_rdlvl_gate_delay Configuration 2 Register*/
-	volatile uint32 DFITRCMD;	/*DFI Training Command Register*/
-	uint32 reserved14[(0x3f8 - 0x340) / 4];
-	/*IP Status Registers*/
-	volatile uint32 IPVR;	/*IP Version Register*/
-	volatile uint32 IPTR;	/*IP Type Register*/
-} DDR_REG_T, *pDDR_REG_T;
-
-/*PHY_REG2*/
-#define PHY_AUTO_CALIBRATION (1<<0)
-#define PHY_SW_CALIBRATION   (1<<1)
-/*PHY_REG1*/
-#define PHY_DDR2             (1)
-#define PHY_DDR3             (0)
-#define PHY_LPDDR2           (2)
-#define PHY_Burst8           (1<<2)
-
-//PHY_REG4a
-#define PHY_CL(n)            (((n)&0xF)<<4)
-#define PHY_AL(n)            ((n)&0xF)
-
-#define PHY_RON_DISABLE     (0)
-#define PHY_RON_309ohm      (1)
-#define PHY_RON_155ohm      (2)
-#define PHY_RON_103ohm      (3)
-#define PHY_RON_77ohm       (4)
-#define PHY_RON_63ohm       (5)
-#define PHY_RON_52ohm       (6)
-#define PHY_RON_45ohm       (7)
-/*#define PHY_RON_77ohm       (8)*/
-#define PHY_RON_62ohm       (9)
-/*#define PHY_RON_52ohm       (10)*/
-#define PHY_RON_44ohm       (11)
-#define PHY_RON_39ohm       (12)
-#define PHY_RON_34ohm       (13)
-#define PHY_RON_31ohm       (14)
-#define PHY_RON_28ohm       (15)
-
-#define PHY_RTT_DISABLE     (0)
-#define PHY_RTT_816ohm      (1)
-#define PHY_RTT_431ohm      (2)
-#define PHY_RTT_287ohm      (3)
-#define PHY_RTT_216ohm      (4)
-#define PHY_RTT_172ohm      (5)
-#define PHY_RTT_145ohm      (6)
-#define PHY_RTT_124ohm      (7)
-#define PHY_RTT_215ohm      (8)
-/*#define PHY_RTT_172ohm      (9)*/
-#define PHY_RTT_144ohm      (10)
-#define PHY_RTT_123ohm      (11)
-#define PHY_RTT_108ohm      (12)
-#define PHY_RTT_96ohm       (13)
-#define PHY_RTT_86ohm       (14)
-#define PHY_RTT_78ohm       (15)
-
-#define PHY_DRV_ODT_SET(n) ((n<<4)|n)
-
-/* DDR PHY register struct */
-typedef volatile struct DDRPHY_REG_Tag
-{
-    volatile uint32 PHY_REG1;               //PHY soft reset Register
-    volatile uint32 PHY_REG3;               //Burst type select Register
-    volatile uint32 PHY_REG2;               //PHY DQS squelch calibration Register
-    uint32 reserved1[(0x38-0x0a)/4];
-    volatile uint32 PHY_REG4a;              //CL,AL set register
-    volatile uint32 PHY_REG4b;              //dqs gata delay select bypass mode register
-    uint32 reserved2[(0x54-0x40)/4];
-    volatile uint32 PHY_REG16;              //
-    uint32 reserved3[(0x5c-0x58)/4];
-    volatile uint32 PHY_REG18;              //0x5c
-    volatile uint32 PHY_REG19;
-    uint32 reserved4[(0x68-0x64)/4];
-    volatile uint32 PHY_REG21;              //0x68
-    uint32 reserved5[(0x70-0x6c)/4];     
-    volatile uint32 PHY_REG22;              //0x70
-    uint32 reserved6[(0x80-0x74)/4];
-    volatile uint32 PHY_REG25;              //0x80
-    volatile uint32 PHY_REG26;
-    volatile uint32 PHY_REG27;
-    volatile uint32 PHY_REG28;
-    uint32 reserved7[(0xd4-0x90)/4];
-    volatile uint32 PHY_REG6;               //0xd4
-    volatile uint32 PHY_REG7;
-    uint32 reserved8[(0xe0-0xdc)/4];
-    volatile uint32 PHY_REG8;               //0xe0
-    volatile uint32 PHY_REG0e4;             //use for DQS ODT off
-    uint32 reserved9[(0x114-0xe8)/4];
-    volatile uint32 PHY_REG9;               //0x114
-    volatile uint32 PHY_REG10;
-    uint32 reserved10[(0x120-0x11c)/4];
-    volatile uint32 PHY_REG11;              //0x120
-    volatile uint32 PHY_REG124;             //use for DQS ODT off
-    uint32 reserved11[(0x1c0-0x128)/4];
-    volatile uint32 PHY_REG29;              //0x1c0
-    uint32 reserved12[(0x264-0x1c4)/4];
-	volatile uint32 PHY_REG264;             //use for phy soft reset
-	uint32 reserved13[(0x2b0-0x268)/4];
-    volatile uint32 PHY_REG2a;              //0x2b0
-    uint32 reserved14[(0x2c4-0x2b4)/4];
-//    volatile uint32 PHY_TX_DeSkew[24];        //0x2c4-0x320
-    volatile uint32 PHY_REG30;
-    volatile uint32 PHY_REG31;
-    volatile uint32 PHY_REG32;
-    volatile uint32 PHY_REG33;
-    volatile uint32 PHY_REG34;
-    volatile uint32 PHY_REG35;
-    volatile uint32 PHY_REG36;
-    volatile uint32 PHY_REG37;
-    volatile uint32 PHY_REG38;
-    volatile uint32 PHY_REG39;
-    volatile uint32 PHY_REG40;
-    volatile uint32 PHY_REG41;
-    volatile uint32 PHY_REG42;
-    volatile uint32 PHY_REG43;
-    volatile uint32 PHY_REG44;
-    volatile uint32 PHY_REG45;
-    volatile uint32 PHY_REG46;
-    volatile uint32 PHY_REG47;
-    volatile uint32 PHY_REG48;
-    volatile uint32 PHY_REG49;
-    volatile uint32 PHY_REG50;
-    volatile uint32 PHY_REG51;
-    volatile uint32 PHY_REG52;
-    volatile uint32 PHY_REG53;
-    uint32 reserved15[(0x328-0x324)/4];
-//    volatile uint32 PHY_RX_DeSkew[11];      //0x328-0x350
-    volatile uint32 PHY_REG54;
-    volatile uint32 PHY_REG55;
-    volatile uint32 PHY_REG56;
-    volatile uint32 PHY_REG57;
-    volatile uint32 PHY_REG58;
-    volatile uint32 PHY_REG59;
-    volatile uint32 PHY_REG5a;
-    volatile uint32 PHY_REG5b;
-    volatile uint32 PHY_REG5c;
-    volatile uint32 PHY_REG5d;
-    volatile uint32 PHY_REG5e;    
-    uint32 reserved16[(0x3c4-0x354)/4];
-    volatile uint32 PHY_REG5f;              //0x3c4
-    uint32 reserved17[(0x3e0-0x3c8)/4];
-    volatile uint32 PHY_REG60;
-    volatile uint32 PHY_REG61;
-    volatile uint32 PHY_REG62;            
-}DDRPHY_REG_T, *pDDRPHY_REG_T;
-
-#define pCRU_Reg               ((pCRU_REG)RK_CRU_VIRT)
-#define pGRF_Reg               ((pREG_FILE)RK_GRF_VIRT)
-#define pDDR_Reg               ((pDDR_REG_T)RK_DDR_VIRT)
-#define pPHY_Reg               ((pDDRPHY_REG_T)(RK_DDR_VIRT+RK3036_DDR_PCTL_SIZE))
-#define SysSrv_DdrTiming       (RK_CPU_AXI_BUS_VIRT+0xc)
-#define PMU_PWEDN_ST		(RK_PMU_VIRT + 0x8)
-#define READ_CS_INFO()   ((((pGRF_Reg->GRF_OS_REG[1])>>11)&0x1)+1)
-#define READ_COL_INFO()  (9+(((pGRF_Reg->GRF_OS_REG[1])>>9)&0x3))
-#define READ_BK_INFO()   (3-(((pGRF_Reg->GRF_OS_REG[1])>>8)&0x1))
-#define READ_CS0_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>6)&0x3))
-#define READ_CS1_ROW_INFO()  (13+(((pGRF_Reg->GRF_OS_REG[1])>>4)&0x3))
-#define READ_BW_INFO()   (2>>(((pGRF_Reg->GRF_OS_REG[1])&0xc)>>2))	/* 0->8bit 1->16bit 2->32bit  grf*/
-#define READ_DIE_BW_INFO()   (2>>((pGRF_Reg->GRF_OS_REG[1])&0x3))
-
-
-typedef enum PLL_ID_Tag {
-	APLL = 0,
-	DPLL,
-	CPLL,
-	GPLL,
-	PLL_MAX
-} PLL_ID;
-
-typedef enum DRAM_TYPE_Tag {
-	LPDDR = 0,
-	DDR,
-	DDR2,
-	DDR3,
-	LPDDR2S2,
-	LPDDR2,
-
-	DRAM_MAX
-} DRAM_TYPE;
-
-struct ddr_freq_t {
-	unsigned long screen_ft_us;
-	unsigned long long t0;
-	unsigned long long t1;
-	unsigned long t2;
-};
-
-typedef struct PCTRL_TIMING_Tag {
-	uint32 ddrFreq;
-	/*Memory Timing Registers*/
-	uint32 togcnt1u;	/*Toggle Counter 1U Register*/
-	uint32 tinit;		/*t_init Timing Register*/
-	uint32 trsth;		/*Reset High Time Register*/
-	uint32 togcnt100n;	/*Toggle Counter 100N Register*/
-	uint32 trefi;		/*t_refi Timing Register*/
-	uint32 tmrd;		/*t_mrd Timing Register*/
-	uint32 trfc;		/*t_rfc Timing Register*/
-	uint32 trp;		    /*t_rp Timing Register*/
-	uint32 trtw;		/*t_rtw Timing Register*/
-	uint32 tal;		    /*AL Latency Register*/
-	uint32 tcl;		    /*CL Timing Register*/
-	uint32 tcwl;		/*CWL Register*/
-	uint32 tras;		/*t_ras Timing Register*/
-	uint32 trc;		    /*t_rc Timing Register*/
-	uint32 trcd;		/*t_rcd Timing Register*/
-	uint32 trrd;		/*t_rrd Timing Register*/
-	uint32 trtp;		/*t_rtp Timing Register*/
-	uint32 twr;		    /*t_wr Timing Register*/
-	uint32 twtr;		/*t_wtr Timing Register*/
-	uint32 texsr;		/*t_exsr Timing Register*/
-	uint32 txp;		    /*t_xp Timing Register*/
-	uint32 txpdll;		/*t_xpdll Timing Register*/
-	uint32 tzqcs;		/*t_zqcs Timing Register*/
-	uint32 tzqcsi;		/*t_zqcsi Timing Register*/
-	uint32 tdqs;		/*t_dqs Timing Register*/
-	uint32 tcksre;		/*t_cksre Timing Register*/
-	uint32 tcksrx;		/*t_cksrx Timing Register*/
-	uint32 tcke;		/*t_cke Timing Register*/
-	uint32 tmod;		/*t_mod Timing Register*/
-	uint32 trstl;		/*Reset Low Timing Register*/
-	uint32 tzqcl;		/*t_zqcl Timing Register*/
-	uint32 tmrr;		/*t_mrr Timing Register*/
-	uint32 tckesr;		/*t_ckesr Timing Register*/
-	uint32 tdpd;		/*t_dpd Timing Register*/
-} PCTL_TIMING_T;
-
-struct ddr_change_freq_sram_param {
-	uint32 freq;
-	uint32 freq_slew;
-};
-
-typedef union NOC_TIMING_Tag {
-	uint32 d32;
-	struct {
-		unsigned ActToAct:6;
-		unsigned RdToMiss:6;
-		unsigned WrToMiss:6;
-		unsigned BurstLen:3;
-		unsigned RdToWr:5;
-		unsigned WrToRd:5;
-		unsigned BwRatio:1;
-	} b;
-} NOC_TIMING_T;
-
-typedef struct BACKUP_REG_Tag {
-	PCTL_TIMING_T pctl_timing;
-	NOC_TIMING_T noc_timing;
-	uint32 ddrMR[4];
-	uint32 mem_type;
-	uint32 ddr_speed_bin;
-	uint32 ddr_capability_per_die;
-} BACKUP_REG_T;
-
-BACKUP_REG_T DEFINE_PIE_DATA(ddr_reg);
-static BACKUP_REG_T *p_ddr_reg;
-
-uint32 DEFINE_PIE_DATA(ddr_freq);
-static uint32 *p_ddr_freq;
-uint32 DEFINE_PIE_DATA(ddr_sr_idle);
-uint32 DEFINE_PIE_DATA(ddr_dll_status);	/* ddr dllselfrefresh exitdll reset*/
-
-static const uint32_t ddr3_cl_cwl[22][4] = {
-/*   0~330           330~400         400~533        speed
-* tCK  >3             2.5~3          1.875~2.5     1.875~1.5
-*    cl<<16, cwl    cl<<16, cwl     cl<<16, cwl              */
-	{((5 << 16) | 5), ((5 << 16) | 5), 0, 0},	/*DDR3_800D*/
-	{((5 << 16) | 5), ((6 << 16) | 5), 0, 0},	/*DDR3_800E*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), 0},	/*DDR3_1066E*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), 0},	/*DDR3_1066F*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), 0},	/*DDR3_1066G*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_1333F*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1333G*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1333H*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1333J*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_1600G*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1600H*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1600J*/
-	{((5 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1600K*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1866J*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_1866K*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_1866L*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)},	/*DDR3_1866M*/
-
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((7 << 16) | 7)},	/*DDR3_2133K*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((6 << 16) | 6), ((8 << 16) | 7)},	/*DDR3_2133L*/
-	{((5 << 16) | 5), ((5 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_2133M*/
-	{((6 << 16) | 5), ((6 << 16) | 5), ((7 << 16) | 6), ((9 << 16) | 7)},	/*DDR3_2133N*/
-
-	{((6 << 16) | 5), ((6 << 16) | 5), ((8 << 16) | 6), ((10 << 16) | 7)}	/*DDR3_DEFAULT*/
-};
-
-static const uint32_t ddr3_tRC_tFAW[22] = {
-/**    tRC    tFAW   */
-	((50 << 16) | 50),	/*DDR3_800D*/
-	((53 << 16) | 50),	/*DDR3_800E*/
-
-	((49 << 16) | 50),	/*DDR3_1066E*/
-	((51 << 16) | 50),	/*DDR3_1066F*/
-	((53 << 16) | 50),	/*DDR3_1066G*/
-
-	((47 << 16) | 45),	/*DDR3_1333F*/
-	((48 << 16) | 45),	/*DDR3_1333G*/
-	((50 << 16) | 45),	/*DDR3_1333H*/
-	((51 << 16) | 45),	/*DDR3_1333J*/
-
-	((45 << 16) | 40),	/*DDR3_1600G*/
-	((47 << 16) | 40),	/*DDR3_1600H*/
-	((48 << 16) | 40),	/*DDR3_1600J*/
-	((49 << 16) | 40),	/*DDR3_1600K*/
-
-	((45 << 16) | 35),	/*DDR3_1866J*/
-	((46 << 16) | 35),	/*DDR3_1866K*/
-	((47 << 16) | 35),	/*DDR3_1866L*/
-	((48 << 16) | 35),	/*DDR3_1866M*/
-
-	((44 << 16) | 35),	/*DDR3_2133K*/
-	((45 << 16) | 35),	/*DDR3_2133L*/
-	((46 << 16) | 35),	/*DDR3_2133M*/
-	((47 << 16) | 35),	/*DDR3_2133N*/
-
-	((53 << 16) | 50)	/*DDR3_DEFAULT*/
-};
-
-/****************************************************************************
-*Internal sram us delay function
-*Cpu highest frequency is 1.6 GHz
-*1 cycle = 1/1.6 ns
-*1 us = 1000 ns = 1000 * 1.6 cycles = 1600 cycles
-******************************************************************************/
-volatile uint32 DEFINE_PIE_DATA(loops_per_us);
-#define LPJ_100MHZ  999456UL
-
-/*----------------------------------------------------------------------
-*Name	: void __sramlocalfunc ddr_delayus(uint32_t us)
-*Desc	: ddr 
-*Params  : uint32_t us  --
-*Return  : void
-*Notes   : loops_per_us  arm freq
-*----------------------------------------------------------------------*/
-static void __sramfunc ddr_delayus(uint32 us)
-{
-	do {
-		volatile unsigned int i = (DATA(loops_per_us) * us);
-		if (i < 7)
-			i = 7;
-		barrier();
-		asm volatile (".align 4; 1: subs %0, %0, #1; bne 1b;":"+r" (i));
-	} while (0);
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-*Desc	: ddr 
-*Params  : pDest ->
-*          pSrc  ->
-*          words ->
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-
-static __sramfunc void ddr_copy(uint32 *pDest, uint32 *pSrc, uint32 words)
-{
-	uint32 i;
-
-	for (i = 0; i < words; i++) {
-		pDest[i] = pSrc[i];
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Lowpower_state(void)
-*Desc	: pctl  lowpower state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Lowpower_state(void)
-{
-	volatile uint32 value;
-
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if (value == Low_power) {
-			break;
-		}
-		switch (value) {
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Config)
-			;
-		case Config:
-			pDDR_Reg->SCTL = GO_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Access)
-			;
-		case Access:
-			pDDR_Reg->SCTL = SLEEP_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Low_power)
-			;
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Access_state(void)
-*Desc	: pctl  Access state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Access_state(void)
-{
-	volatile uint32 value;
-
-	/*set auto self-refresh idle*/
-	pDDR_Reg->MCFG1 =
-	    (pDDR_Reg->MCFG1 & 0xffffff00) | DATA(ddr_sr_idle) | (1 << 31);
-	pDDR_Reg->MCFG = (pDDR_Reg->MCFG & 0xffff00ff) | (PD_IDLE << 8);
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if ((value == Access)
-		    || ((pDDR_Reg->STAT.b.lp_trig == 1)
-			&& ((pDDR_Reg->STAT.b.ctl_stat) == Low_power))) {
-			break;
-		}
-		switch (value) {
-		case Low_power:
-			pDDR_Reg->SCTL = WAKEUP_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Access)
-			;
-			break;
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			while ((pDDR_Reg->STAT.b.ctl_stat) != Config)
-			;
-		case Config:
-			pDDR_Reg->SCTL = GO_STATE;
-			dsb();
-			while (!(((pDDR_Reg->STAT.b.ctl_stat) == Access)
-				 || ((pDDR_Reg->STAT.b.lp_trig == 1)
-				     && ((pDDR_Reg->STAT.b.ctl_stat) ==
-					 Low_power))))
-		    ;
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-	pGRF_Reg->GRF_SOC_CON[2] = (1 << 16 | 0);	/*de_hw_wakeup :enable auto sr if sr_idle != 0*/
-}
-
-/*----------------------------------------------------------------------
-*Name	: __sramfunc void ddr_move_to_Config_state(void)
-*Desc	: pctl  config state
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static __sramfunc void ddr_move_to_Config_state(void)
-{
-	volatile uint32 value;
-	pGRF_Reg->GRF_SOC_CON[2] = (1 << 16 | 1);	/*hw_wakeup :disable auto sr*/
-	while (1) {
-		value = pDDR_Reg->STAT.b.ctl_stat;
-		if (value == Config) {
-			break;
-		}
-		switch (value) {
-		case Low_power:
-			pDDR_Reg->SCTL = WAKEUP_STATE;
-			dsb();
-		case Access:
-		case Init_mem:
-			pDDR_Reg->SCTL = CFG_STATE;
-			dsb();
-			break;
-		default:	/*Transitional state*/
-			break;
-		}
-	}
-}
-
-/*----------------------------------------------------------------------
-*Name	: void __sramlocalfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-*Desc	:  pctl MCMDddr
-*Params  : rank ->ddr rank 
-*          cmd  ->
-*          arg  ->
-*Return  : void
-*Notes   : argbank_addrcmd_addr
-*----------------------------------------------------------------------*/
-static void __sramfunc ddr_send_command(uint32 rank, uint32 cmd, uint32 arg)
-{
-	while (pDDR_Reg->MCMD & start_cmd)
-	;
-	pDDR_Reg->MCMD = (start_cmd | (rank << 20) | arg | cmd);
-	dsb();
-}
-
-__sramdata uint32 copy_data[8] = {
-     0xffffffff, 0x00000000, 0x55555555, 0xAAAAAAAA,
-	0xEEEEEEEE, 0x11111111, 0x22222222, 0xDDDDDDDD
-};
-
- EXPORT_PIE_SYMBOL(copy_data[8]);
-static uint32 *p_copy_data;
-
-/*----------------------------------------------------------------------
-Name	: uint32_t __sramlocalfunc ddr_data_training(void)
-Desc	: ddrdata training
-Params  : void
-Return  : void
-Notes   : data training
-----------------------------------------------------------------------*/
-static uint32_t __sramfunc ddr_data_training(void)
-{
-	uint32 value;
-	value = pDDR_Reg->TREFI;
-	pDDR_Reg->TREFI = 0;
-	pPHY_Reg->PHY_REG2 |= PHY_AUTO_CALIBRATION;
-	dsb();
-	/*wait echo byte DTDONE*/
-	ddr_delayus(1);
-	/*stop DTT*/
-    while((pPHY_Reg->PHY_REG62 & 0x3)!=0x3)
-	;
-	pPHY_Reg->PHY_REG2 = (pPHY_Reg->PHY_REG2 & (~0x1));
-	/*send some auto refresh to complement the lost while DTT*/
-	ddr_send_command(3, PREA_cmd, 0);
-	ddr_send_command(3, REF_cmd, 0);
-	ddr_send_command(3, REF_cmd, 0);
-
-	/*resume auto refresh*/
-	pDDR_Reg->TREFI = value;
-	return 0;
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_set_dll_bypass(uint32 freq)
-Desc    : PHY dll 
-Params  : freq -> ddr
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-static void __sramfunc ddr_set_dll_bypass(uint32 freq)
-{
-#if defined (PHY_RX_PHASE_CAL)
-	uint32 phase_90, dll_set, de_skew;
-
-	phase_90 = 1000000 / freq / 4;
-	dll_set = (phase_90 - 300 + (0x7*PHY_DE_SKEW_STEP)) / (phase_90 / 4);
-	de_skew = (phase_90 - 300 + (0x7*PHY_DE_SKEW_STEP) - ((phase_90 / 4) * dll_set));
-	if (de_skew > PHY_DE_SKEW_STEP * 15) {
-		if (dll_set == 3) {
-			de_skew = 15;
-		} else {
-			dll_set += 1;
-			de_skew = 0;
-		}
-	} else {
-		de_skew = de_skew / PHY_DE_SKEW_STEP;
-	}
-
-	pPHY_Reg->PHY_REG28 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG38 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG48 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG58 = dll_set;/*rx dll 45delay*/
-	pPHY_Reg->PHY_REG_skew[(0x324-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x350-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x37c-0x2c0)/4] = 0x7 | (de_skew << 4);
-	pPHY_Reg->PHY_REG_skew[(0x3a8-0x2c0)/4] = 0x7 | (de_skew << 4);
-#else
-	uint32 phase;
-	if (freq < 350) {
-		phase = 3;
-	} else if (freq < 666) {
-		phase = 2;
-	} else
-		phase = 1;
-    pPHY_Reg->PHY_REG8 = phase;//rx dll 45delay
-    pPHY_Reg->PHY_REG11= phase;
-#endif
-	if (freq <= PHY_DLL_DISABLE_FREQ) {
-		pPHY_Reg->PHY_REG2a = 0x1F;	/*TX DLL bypass */
-	} else {
-		pPHY_Reg->PHY_REG2a = 0x3;	/* TX DLL bypass*/
-	}
-
-	dsb();
-}
-
-static noinline uint32 ddr_get_pll_freq(PLL_ID pll_id)	/*APLL-1;CPLL-2;DPLL-3;GPLL-4*/
-{
-	uint32 ret = 0;
-
-	if (((pCRU_Reg->CRU_MODE_CON >> (pll_id * 4)) & 1) == 1)	/* DPLL Normal mode*/
-		ret = 24 * ((pCRU_Reg->CRU_PLL_CON[pll_id][0] & 0xfff))	/* NF = 2*(CLKF+1)*/
-		    / ((pCRU_Reg->CRU_PLL_CON[pll_id][1] & 0x3f)
-		       * ((pCRU_Reg->CRU_PLL_CON[pll_id][0] >> 12) & 0x7) * ((pCRU_Reg->CRU_PLL_CON[pll_id][1] >> 6) & 0x7));	/* OD = 2^CLKOD*/
-	else
-		ret = 24;
-
-	return ret;
-}
-
-static __sramdata uint32 clkFbDiv;
-static __sramdata uint32 clkPostDiv1;
-static __sramdata uint32 clkPostDiv2;
-
-/*****************************************
-*REFDIV   FBDIV     POSTDIV1/POSTDIV2      FOUTPOSTDIV           freq Step        FOUTPOSRDIV            finally use
-*==================================================================================================================
-*1        17 - 66   4                      100MHz - 400MHz          6MHz          200MHz  <= 300MHz             <= 150MHz
-*1        17 - 66   3                      133MHz - 533MHz          8MHz
-*1        17 - 66   2                      200MHz - 800MHz          12MHz         300MHz  <= 600MHz      150MHz <= 300MHz
-*1        17 - 66   1                      400MHz - 1600MHz         24MHz         600MHz  <= 1200MHz     300MHz <= 600MHz
-*******************************************/
-/*for minimum jitter operation, the highest VCO and FREF frequencies should be used.*/
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_set_pll(uint32_t nMHz, uint32_t set)
-*Desc    : ddr pll
-*Params  : nMHZ -> ddr
-*          set  ->0
-*                 1ddr pll
-*Return  : 
-*Notes   : set=0ddr_set_pllset=1 ddr_set_pll
--*---------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_set_pll(uint32 nMHz, uint32 set)
-{
-	uint32 ret = 0;
-	int delay = 1000;
-	uint32 pll_id = 1;	/*DPLL*/
-
-	if (nMHz == 24) {
-		ret = 24;
-		goto out;
-	}
-	if (!set) {
-		if (nMHz <= 150) {	/*<300*/
-			clkPostDiv1 = 6;
-		} else if (nMHz <= 200) {
-			clkPostDiv1 = 4;
-		} else if (nMHz <= 300) {
-			clkPostDiv1 = 3;
-		} else if (nMHz <= 450) {
-			clkPostDiv1 = 2;
-		} else {
-			clkPostDiv1 = 1;
-		}
-		clkPostDiv2 = 1;
-		clkFbDiv = (nMHz * 2 * DDR_PLL_REFDIV * clkPostDiv1 * clkPostDiv2) / 24;	/*ddr2*/
-		ret =
-		    (24 * clkFbDiv) / (2 * DDR_PLL_REFDIV * clkPostDiv1 *
-				       clkPostDiv2);
-	} else {
-		pCRU_Reg->CRU_MODE_CON = (0x1 << ((pll_id * 4) + 16)) | (0x0 << (pll_id * 4));	/*PLL slow-mode*/
-
-		pCRU_Reg->CRU_PLL_CON[pll_id][0] =
-		    FBDIV(clkFbDiv) | POSTDIV1(clkPostDiv1);
-		pCRU_Reg->CRU_PLL_CON[pll_id][1] = REFDIV(DDR_PLL_REFDIV) | POSTDIV2(clkPostDiv2) | (0x10001 << 12);	/*interger mode*/
-
-		ddr_delayus(1);
-
-		while (delay > 0) {
-			ddr_delayus(1);
-			if (pCRU_Reg->CRU_PLL_CON[pll_id][1] & (PLL_LOCK_STATUS))	/*wait for pll locked*/
-				break;
-			delay--;
-		}
-
-		pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3 << 16) | 0x0);	/*clk_ddr_src:clk_ddrphy = 1:1*/
-		pCRU_Reg->CRU_MODE_CON = (0x1 << ((pll_id * 4) + 16)) | (0x1 << (pll_id * 4));	/*PLL normal*/
-	}
-out:
-	return ret;
-}
-
-uint32 PIE_FUNC(ddr_set_pll)(uint32 nMHz, uint32 set)
-{
-	return ddr_set_pll(nMHz, set);
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_set_pll));
-static uint32(*p_ddr_set_pll) (uint32 nMHz, uint32 set);
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t ddr_get_parameter(uint32_t nMHz)
-*Desc    : 
-*Params  : nMHZ -> ddr
-*Return  : 0 
-*          -1 
-*          -4 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_get_parameter(uint32 nMHz)
-{
-	uint32_t tmp;
-	uint32_t ret = 0;
-	uint32_t al;
-	uint32_t bl;
-	uint32_t cl;
-	uint32_t cwl;
-
-	PCTL_TIMING_T *p_pctl_timing = &(p_ddr_reg->pctl_timing);
-	NOC_TIMING_T *p_noc_timing = &(p_ddr_reg->noc_timing);
-
-	p_pctl_timing->togcnt1u = nMHz;
-	p_pctl_timing->togcnt100n = nMHz / 10;
-	p_pctl_timing->tinit = 200;
-
-	if (p_ddr_reg->ddr_speed_bin > DDR3_DEFAULT) {
-		ret = -1;
-		goto out;
-	}
-    #define DDR3_tREFI_7_8_us    (78)
-    #define DDR3_tMRD            (4)
-    #define DDR3_tRFC_512Mb      (90)
-    #define DDR3_tRFC_1Gb        (110)
-    #define DDR3_tRFC_2Gb        (160)
-    #define DDR3_tRFC_4Gb        (300)
-    #define DDR3_tRFC_8Gb        (350)
-    #define DDR3_tRTW            (2)	/*register min valid value*/
-    #define DDR3_tRAS            (37)
-    #define DDR3_tRRD            (10)
-    #define DDR3_tRTP            (7)
-    #define DDR3_tWR             (15)
-    #define DDR3_tWTR            (7)
-    #define DDR3_tXP             (7)
-    #define DDR3_tXPDLL          (24)
-    #define DDR3_tZQCS           (80)
-    #define DDR3_tZQCSI          (10000)
-    #define DDR3_tDQS            (1)
-    #define DDR3_tCKSRE          (10)
-    #define DDR3_tCKE_400MHz     (7)
-    #define DDR3_tCKE_533MHz     (6)
-    #define DDR3_tMOD            (15)
-    #define DDR3_tRSTL           (100)
-    #define DDR3_tZQCL           (320)
-    #define DDR3_tDLLK           (512)
-	p_pctl_timing->trsth = 500;
-	al = 0;
-	bl = 8;
-	if (nMHz <= 330) {
-		tmp = 0;
-	} else if (nMHz <= 400) {
-		tmp = 1;
-	} else if (nMHz <= 533) {
-		tmp = 2;
-	} else {	/*666MHz*/
-		tmp = 3;
-	}
-	if (nMHz <= DDR3_DDR2_DLL_DISABLE_FREQ) {	/*when dll bypss cl = cwl = 6*/
-		cl = 6;
-		cwl = 6;
-	} else {
-		cl = ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] >> 16;
-		cwl =
-		    ddr3_cl_cwl[p_ddr_reg->ddr_speed_bin][tmp] & 0x0ff;
-	}
-	if (cl == 0) {
-		ret = -4;	/**/
-	}
-	if (nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ) {
-		p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_DIS;
-	} else {
-		p_ddr_reg->ddrMR[1] = DDR3_DS_40 | DDR3_Rtt_Nom_120;
-	}
-	p_ddr_reg->ddrMR[2] = DDR3_MR2_CWL(cwl) /* | DDR3_Rtt_WR_60 */ ;
-	p_ddr_reg->ddrMR[3] = 0;
-	/**************************************************
-	* PCTL Timing
-	**************************************************/
-	/*
-	 * tREFI, average periodic refresh interval, 7.8us
-	 */
-	p_pctl_timing->trefi = DDR3_tREFI_7_8_us;
-	/*
-	 * tMRD, 4 tCK
-	 */
-	p_pctl_timing->tmrd = DDR3_tMRD & 0x7;
-	/*
-	 * tRFC, 90ns(512Mb),110ns(1Gb),160ns(2Gb),300ns(4Gb),350ns(8Gb)
-	 */
-	if (p_ddr_reg->ddr_capability_per_die <= 0x4000000) {	/*512Mb 90ns*/
-		tmp = DDR3_tRFC_512Mb;
-	} else if (p_ddr_reg->ddr_capability_per_die <= 0x8000000) {	/*1Gb 110ns*/
-		tmp = DDR3_tRFC_1Gb;
-	} else if (p_ddr_reg->ddr_capability_per_die <= 0x10000000) {	/*2Gb 160ns*/
-		tmp = DDR3_tRFC_2Gb;
-	} else if (p_ddr_reg->ddr_capability_per_die <= 0x20000000) {/*4Gb 300ns*/
-		tmp = DDR3_tRFC_4Gb;
-	} else{		/*8Gb  350ns*/
-		tmp = DDR3_tRFC_8Gb;
-	}
-	p_pctl_timing->trfc = (tmp * nMHz + 999) / 1000;
-	/*
-	 * tXSR, =tDLLK=512 tCK
-	 */
-	p_pctl_timing->texsr = DDR3_tDLLK;
-	/*
-	 * tRP=CL
-	 */
-	p_pctl_timing->trp = cl;
-	/*
-	 * WrToMiss=WL*tCK + tWR + tRP + tRCD
-	 */
-	p_noc_timing->b.WrToMiss =
-	    ((cwl + ((DDR3_tWR * nMHz + 999) / 1000) + cl + cl) & 0x3F);
-	/*
-	 * tRC=tRAS+tRP
-	 */
-	p_pctl_timing->trc =
-	    ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin] >> 16) * nMHz +
-	       999) / 1000) & 0x3F);
-	p_noc_timing->b.ActToAct =
-	    ((((ddr3_tRC_tFAW[p_ddr_reg->ddr_speed_bin] >> 16) * nMHz +
-	       999) / 1000) & 0x3F);
-
-	p_pctl_timing->trtw = (cl + 2 - cwl);	/*DDR3_tRTW*/
-	p_noc_timing->b.RdToWr = ((cl + 2 - cwl) & 0x1F);
-	p_pctl_timing->tal = al;
-	p_pctl_timing->tcl = cl;
-	p_pctl_timing->tcwl = cwl;
-	/*
-	 * tRAS, 37.5ns(400MHz)     37.5ns(533MHz)
-	 */
-	p_pctl_timing->tras =
-	    (((DDR3_tRAS * nMHz + (nMHz >> 1) + 999) / 1000) & 0x3F);
-	/*
-	 * tRCD=CL
-	 */
-	p_pctl_timing->trcd = cl;
-	/*
-	 * tRRD = max(4nCK, 7.5ns), DDR3-1066(1K), DDR3-1333(2K), DDR3-1600(2K)
-	 *        max(4nCK, 10ns), DDR3-800(1K,2K), DDR3-1066(2K)
-	 *        max(4nCK, 6ns), DDR3-1333(1K), DDR3-1600(1K)
-	 *
-	 */
-	tmp = ((DDR3_tRRD * nMHz + 999) / 1000);
-	if (tmp < 4) {
-		tmp = 4;
-	}
-	p_pctl_timing->trrd = (tmp & 0xF);
-	/*
-	 * tRTP, max(4 tCK,7.5ns)
-	 */
-	tmp = ((DDR3_tRTP * nMHz + (nMHz >> 1) + 999) / 1000);
-	if (tmp < 4) {
-		tmp = 4;
-	}
-	p_pctl_timing->trtp = tmp & 0xF;
-	/*
-	 * RdToMiss=tRTP+tRP + tRCD - (BL/2 * tCK)
-	 */
-	p_noc_timing->b.RdToMiss = ((tmp + cl + cl - (bl >> 1)) & 0x3F);
-	/*
-	 * tWR, 15ns
-	 */
-	tmp = ((DDR3_tWR * nMHz + 999) / 1000);
-	p_pctl_timing->twr = tmp & 0x1F;
-	if (tmp < 9)
-		tmp = tmp - 4;
-	else
-		tmp = tmp >> 1;
-	p_ddr_reg->ddrMR[0] = DDR3_BL8 | DDR3_CL(cl) | DDR3_WR(tmp);
-
-	/*
-	 * tWTR, max(4 tCK,7.5ns)
-	 */
-	tmp = ((DDR3_tWTR * nMHz + (nMHz >> 1) + 999) / 1000);
-	if (tmp < 4) {
-		tmp = 4;
-	}
-	p_pctl_timing->twtr = tmp & 0xF;
-	p_noc_timing->b.WrToRd = ((tmp + cwl) & 0x1F);
-	/*
-	 * tXP, max(3 tCK, 7.5ns)(<933MHz)
-	 */
-	tmp = ((DDR3_tXP * nMHz + (nMHz >> 1) + 999) / 1000);
-	if (tmp < 3) {
-		tmp = 3;
-	}
-	p_pctl_timing->txp = tmp & 0x7;
-	/*
-	 * tXPDLL, max(10 tCK,24ns)
-	 */
-	tmp = ((DDR3_tXPDLL * nMHz + 999) / 1000);
-	if (tmp < 10) {
-		tmp = 10;
-	}
-	p_pctl_timing->txpdll = tmp & 0x3F;
-	/*
-	 * tZQCS, max(64 tCK, 80ns)
-	 */
-	tmp = ((DDR3_tZQCS * nMHz + 999) / 1000);
-	if (tmp < 64) {
-		tmp = 64;
-	}
-	p_pctl_timing->tzqcs = tmp & 0x7F;
-	/*
-	 * tZQCSI,
-	 */
-	p_pctl_timing->tzqcsi = DDR3_tZQCSI;
-	/*
-	 * tDQS,
-	 */
-	p_pctl_timing->tdqs = DDR3_tDQS;
-	/*
-	 * tCKSRE, max(5 tCK, 10ns)
-	 */
-	tmp = ((DDR3_tCKSRE * nMHz + 999) / 1000);
-	if (tmp < 5) {
-		tmp = 5;
-	}
-	p_pctl_timing->tcksre = tmp & 0x1F;
-	/*
-	 * tCKSRX, max(5 tCK, 10ns)
-	 */
-	p_pctl_timing->tcksrx = tmp & 0x1F;
-	/*
-	 * tCKE, max(3 tCK,7.5ns)(400MHz) max(3 tCK,5.625ns)(533MHz)
-	 */
-	if (nMHz >= 533) {
-		tmp = ((DDR3_tCKE_533MHz * nMHz + 999) / 1000);
-	} else {
-		tmp =
-		    ((DDR3_tCKE_400MHz * nMHz + (nMHz >> 1) +
-		      999) / 1000);
-	}
-	if (tmp < 3) {
-		tmp = 3;
-	}
-	p_pctl_timing->tcke = tmp & 0x7;
-	/*
-	 * tCKESR, =tCKE + 1tCK
-	 */
-	p_pctl_timing->tckesr = (tmp + 1) & 0xF;
-	/*
-	 * tMOD, max(12 tCK,15ns)
-	 */
-	tmp = ((DDR3_tMOD * nMHz + 999) / 1000);
-	if (tmp < 12) {
-		tmp = 12;
-	}
-	p_pctl_timing->tmod = tmp & 0x1F;
-	/*
-	 * tRSTL, 100ns
-	 */
-	p_pctl_timing->trstl =
-	    ((DDR3_tRSTL * nMHz + 999) / 1000) & 0x7F;
-	/*
-	 * tZQCL, max(256 tCK, 320ns)
-	 */
-	tmp = ((DDR3_tZQCL * nMHz + 999) / 1000);
-	if (tmp < 256) {
-		tmp = 256;
-	}
-	p_pctl_timing->tzqcl = tmp & 0x3FF;
-	/*
-	 * tMRR, 0 tCK
-	 */
-	p_pctl_timing->tmrr = 0;
-	/*
-	 * tDPD, 0
-	 */
-	p_pctl_timing->tdpd = 0;
-
-	/**************************************************
-	*NOC Timing
-	**************************************************/
-	p_noc_timing->b.BurstLen = ((bl >> 1) & 0x7);
-out:
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_update_timing(void)
-*Desc    : pctl phy timing
-*Params  : void
-*Return  : 0 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_timing(void)
-{
-	uint32_t ret = 0;
-
-	PCTL_TIMING_T *p_pctl_timing = &(DATA(ddr_reg).pctl_timing);
-	NOC_TIMING_T *p_noc_timing = &(DATA(ddr_reg).noc_timing);
-
-	ddr_copy((uint32 *)&(pDDR_Reg->TOGCNT1U),
-		 (uint32 *)&(p_pctl_timing->togcnt1u), 34);
-/*    pPHY_Reg->PHY_REG3 |= PHY_Burst8;*/    /*ddr3 burst length8*/
-	pPHY_Reg->PHY_REG4a = ((p_pctl_timing->tcl << 4) | (p_pctl_timing->tal));
-	*(volatile uint32 *)SysSrv_DdrTiming = p_noc_timing->d32;
-	/*Update PCTL BL*/
-	pDDR_Reg->MCFG =(pDDR_Reg->MCFG &
-	     (~(0x1 | (0x3 << 18) | (0x1 << 17) | (0x1 << 16))))
-	    | ddr2_ddr3_bl_8 | tfaw_cfg(5) | pd_exit_slow | pd_type(1);
-	pDDR_Reg->DFITRDDATAEN = (pDDR_Reg->TAL + pDDR_Reg->TCL) - 3;	/*trdata_en = rl-3*/
-	pDDR_Reg->DFITPHYWRLAT = pDDR_Reg->TCWL - 1;
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramlocalfunc ddr_update_mr(void)
-*Desc    : MR
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 __sramfunc ddr_update_mr(void)
-{
-	/*uint32 cs;
-	cs = READ_CS_INFO();
-	cs = (1 << cs) - 1;	*/
-	if (DATA(ddr_freq) > DDR3_DDR2_DLL_DISABLE_FREQ) {
-		if (DATA(ddr_dll_status) == DDR3_DLL_DISABLE) {	/*off -> on*/
-			ddr_send_command(3, MRS_cmd, bank_addr(0x1) | cmd_addr((DATA(ddr_reg).ddrMR[1])));	/*DLL enable*/
-			ddr_send_command(3, MRS_cmd, bank_addr(0x0) | cmd_addr(((DATA(ddr_reg).ddrMR[0])) | DDR3_DLL_RESET));	/*DLL reset*/
-			ddr_delayus(2);	/*at least 200 DDR cycle*/
-			ddr_send_command(3, MRS_cmd, bank_addr(0x0) |
-					 cmd_addr((DATA(ddr_reg).ddrMR[0])));
-			DATA(ddr_dll_status) = DDR3_DLL_ENABLE;
-		} else{  	/*on -> on*/
-			ddr_send_command(3, MRS_cmd, bank_addr(0x1) |
-					          cmd_addr((DATA(ddr_reg).ddrMR[1])));
-			ddr_send_command(3, MRS_cmd, bank_addr(0x0) |
-					          cmd_addr((DATA(ddr_reg).ddrMR[0])));
-		}
-	} else {
-		ddr_send_command(3, MRS_cmd, bank_addr(0x1) | cmd_addr(((DATA(ddr_reg).ddrMR[1])) | DDR3_DLL_DISABLE));	/*DLL disable*/
-		ddr_send_command(3, MRS_cmd, bank_addr(0x0) |
-				         cmd_addr((DATA(ddr_reg).ddrMR[0])));
-		DATA(ddr_dll_status) = DDR3_DLL_DISABLE;
-	}
-	ddr_send_command(3, MRS_cmd, bank_addr(0x2) |
-			 cmd_addr((DATA(ddr_reg).ddrMR[2])));
-
-	return 0;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_update_odt(void)
-*Desc    : update PHY odt & PHY driver impedance
-*Params  : void
-*Return  : void
-*Notes   :-------------------------------------------------*/
-static void __sramfunc ddr_update_odt(void)
-{
-	/*adjust DRV and ODT*/
-	uint32 phy_odt;
-	if (DATA(ddr_freq) <= PHY_ODT_DISABLE_FREQ) {
-		phy_odt = PHY_RTT_DISABLE;
-	} else {
-		phy_odt = PHY_RTT_216ohm;
-	}
-
-	pPHY_Reg->PHY_REG27 = PHY_DRV_ODT_SET(phy_odt);	/*DQS0 odt*/
-	pPHY_Reg->PHY_REG28 = PHY_DRV_ODT_SET(phy_odt);	/*DQS1 odt*/
-
-	pPHY_Reg->PHY_REG16 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*cmd drv*/
-	pPHY_Reg->PHY_REG22 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*clk drv*/
-
-	pPHY_Reg->PHY_REG25 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS0 drv*/
-	pPHY_Reg->PHY_REG26 = PHY_DRV_ODT_SET(PHY_RON_44ohm);	/*DQS1 drv*/
-	dsb();
-}
-
-#if 0
-void PIE_FUNC(ddr_adjust_config)(void)
-{
-	/*enter config state*/
-	ddr_move_to_Config_state();
-
-	/*set auto power down idle*/
-	pDDR_Reg->MCFG = (pDDR_Reg->MCFG & 0xffff00ff) | (PD_IDLE << 8);
-	/*enable the hardware low-power interface*/
-	pDDR_Reg->SCFG.b.hw_low_power_en = 1;
-	ddr_update_odt();
-	/*enter access state*/
-	ddr_move_to_Access_state();
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_adjust_config));
-
-/*----------------------------------------------------------------------
-Name    : __sramfunc void ddr_adjust_config(uint32_t dram_type)
-Desc    :
-Params  : dram_type ->
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-
-static void ddr_adjust_config(uint32_t dram_type)
-{
-	unsigned long save_sp;
-	uint32 i;
-	volatile uint32 n;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-
-    /** 1. Make sure there is no host access */
-	flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	dsb();
-
-	call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_adjust_config)),
-			(void *)0, rockchip_sram_stack);
-
-}
-#endif
-
-static void __sramfunc idle_port(void)
-{
-	int i;
-	uint32 clk_gate[11];
-	uint32 pd_status;
-	uint32 idle_req, idle_stus;
-	/*bit0:core bit1:gpu bit2:video bit3:vio 1:power off*/
-	pd_status = *(volatile uint32 *)PMU_PWEDN_ST;
-	/*save clock gate status*/
-	for (i = 0; i < 11; i++) {
-		clk_gate[i] = pCRU_Reg->CRU_CLKGATE_CON[i];
-	}
-	/*enable all clock gate for request idle*/
-	for (i = 0; i < 11; i++) {
-		pCRU_Reg->CRU_CLKGATE_CON[i] = 0xffff0000;
-	}
-
-	idle_req = (1 << peri_pwr_idlereq); /*peri*/
-	idle_stus = peri_pwr_idle;
-	if ((pd_status & (0x1<<3)) == 0) {/*pwr_vio*/
-		idle_req |= (1 << vio_pwr_idlereq);
-		idle_stus |= vio_pwr_idle;
-	}
-	if ((pd_status & (0x1<<2)) == 0) {/*pwr_vpu*/
-		idle_req |= (1 << vpu_pwr_idlereq);
-		idle_stus |= vpu_pwr_idle;
-	}
-	if ((pd_status & (0x1<<1)) == 0) {/*pwr_gpu*/
-		idle_req |= (1 << gpu_pwr_idlereq);
-		idle_stus |= gpu_pwr_idle;
-	}
-
-	pGRF_Reg->GRF_SOC_CON[2] = (idle_req << 16) | idle_req;
-	dsb();
-	while ((pGRF_Reg->GRF_SOC_STATUS0 & idle_stus) != idle_stus)
-	;
-
-	/*resume clock gate status*/
-	for (i = 0; i < 11; i++)
-		pCRU_Reg->CRU_CLKGATE_CON[i] = (clk_gate[i] | 0xffff0000);
-}
-
-static void __sramfunc deidle_port(void)
-{
-	int i;
-	uint32 clk_gate[11];
-	uint32 pd_status;
-	uint32 idle_req, idle_stus;
-	/*bit0:core bit1:gpu bit2:video bit3:vio 1:power off*/
-	pd_status = *(volatile uint32 *)PMU_PWEDN_ST;
-
-	/*save clock gate status*/
-	for (i = 0; i < 11; i++) {
-		clk_gate[i] = pCRU_Reg->CRU_CLKGATE_CON[i];
-	}
-	/*enable all clock gate for request idle*/
-	for (i = 0; i < 11; i++) {
-		pCRU_Reg->CRU_CLKGATE_CON[i] = 0xffff0000;
-	}
-
-	idle_req = (1 << peri_pwr_idlereq); /*peri*/
-	idle_stus = peri_pwr_idle;
-	if ((pd_status & (0x1<<3)) == 0) {/*pwr_vio*/
-		idle_req |= (1 << vio_pwr_idlereq);
-		idle_stus |= vio_pwr_idle;
-	}
-	if ((pd_status & (0x1<<2)) == 0) {/*pwr_vpu*/
-		idle_req |= (1 << vpu_pwr_idlereq);
-		idle_stus |= vpu_pwr_idle;
-	}
-	if ((pd_status & (0x1<<1)) == 0) {/*pwr_gpu*/
-		idle_req |= (1 << gpu_pwr_idlereq);
-		idle_stus |= gpu_pwr_idle;
-	}
-
-	pGRF_Reg->GRF_SOC_CON[2] = (idle_req << 16) | 0 ;
-	dsb();
-	while ((pGRF_Reg->GRF_SOC_STATUS0 & idle_stus) != 0)
-	;
-
-	/*resume clock gate status*/
-	for (i = 0; i < 11; i++)
-		pCRU_Reg->CRU_CLKGATE_CON[i] = (clk_gate[i] | 0xffff0000);
-
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_selfrefresh_enter(uint32 nMHz)
-*Desc    : 
-*Params  : nMHz ->ddr
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-#if 1
-static void __sramfunc ddr_selfrefresh_enter(uint32 nMHz)
-{
-	ddr_move_to_Config_state();
-	ddr_move_to_Lowpower_state();
-	/*pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_EN;*/
-	pPHY_Reg->PHY_REG264 &= ~(1<<1);
-	pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 & (~(0x3 << 2)));	/*phy soft reset*/
-	dsb();
-	pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1 << 2) << 16) | (1 << 2);	/*disable DDR PHY clock*/
-	ddr_delayus(1);
-}
-#endif
-
-static uint32 dtt_buffer[8];
-
-/*----------------------------------------------------------------------
-*Name    : void ddr_dtt_check(void)
-*Desc    : data training check
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void ddr_dtt_check(void)
-{
-	uint32 i;
-	for (i = 0; i < 8; i++) {
-		dtt_buffer[i] = p_copy_data[i];
-	}
-	dsb();
-	flush_cache_all();
-	outer_flush_all();
-	for (i = 0; i < 8; i++) {
-		if (dtt_buffer[i] != p_copy_data[i]) {
-/*            sram_printascii("DTT failed!\n");*/
-			break;
-		}
-		dtt_buffer[i] = 0;
-	}
-}
-
-/*----------------------------------------------------------------------
-Name    : void __sramlocalfunc ddr_selfrefresh_exit(void)
-Desc    : 
-Params  : void
-Return  : void
-Notes   :
-----------------------------------------------------------------------*/
-#if 1
-static void __sramfunc ddr_selfrefresh_exit(void)
-{
-	pCRU_Reg->CRU_CLKGATE_CON[0] = ((0x1 << 2) << 16) | (0 << 2);	/*enable DDR PHY clock*/
-	dsb();
-	ddr_delayus(1);
-	pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 | (0x3 << 2));	/*phy soft de-reset*/
-	/*pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_DISB;*/
-	pPHY_Reg->PHY_REG264 |= (1<<1);
-	dsb();
-	ddr_move_to_Config_state();
-	ddr_data_training();
-	ddr_move_to_Access_state();
-/*    ddr_dtt_check();*/
-}
-
-#endif
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-*Desc    : ddr plltimingmr
-*Params  : freq_slew : 1  0
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_in(uint32 freq_slew)
-{
-	uint32 value_100n, value_1u;
-
-	if (freq_slew == 1) {
-		value_100n = DATA(ddr_reg).pctl_timing.togcnt100n;
-		value_1u = DATA(ddr_reg).pctl_timing.togcnt1u;
-		DATA(ddr_reg).pctl_timing.togcnt1u = pDDR_Reg->TOGCNT1U;
-		DATA(ddr_reg).pctl_timing.togcnt100n = pDDR_Reg->TOGCNT100N;
-		ddr_update_timing();
-		ddr_update_mr();
-		DATA(ddr_reg).pctl_timing.togcnt100n = value_100n;
-		DATA(ddr_reg).pctl_timing.togcnt1u = value_1u;
-	} else {
-		pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-		pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-	}
-
-	pDDR_Reg->TZQCSI = 0;
-
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-*Desc    : ddr plltimingmr
-*Params  : freq_slew : 1  0
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-static void __sramlocalfunc ddr_change_freq_out(uint32 freq_slew)
-{
-	if (freq_slew == 1) {
-		pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl_timing.togcnt100n;
-		pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl_timing.togcnt1u;
-		pDDR_Reg->TZQCSI = DATA(ddr_reg).pctl_timing.tzqcsi;
-	} else {
-		ddr_update_timing();
-		ddr_update_mr();
-	}
-	ddr_data_training();
-}
-
-static void __sramfunc ddr_SRE_2_SRX(uint32 freq, uint32 freq_slew)
-{
-	idle_port();
-
-	ddr_move_to_Config_state();
-	DATA(ddr_freq) = freq;
-	ddr_change_freq_in(freq_slew);
-	ddr_move_to_Lowpower_state();
-	/*pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_EN;*/
-	pPHY_Reg->PHY_REG264 &= ~(1<<1);
-    pPHY_Reg->PHY_REG1 = (pPHY_Reg->PHY_REG1 & (~(0x3<<2)));     //phy soft reset
-	dsb();
-    /* 3. change frequence  */
-	FUNC(ddr_set_pll) (freq, 1);
-	ddr_set_dll_bypass(freq);	/*set phy dll mode;*/
-	/*pPHY_Reg->PHY_REG0 = (pPHY_Reg->PHY_REG0 | (0x3 << 2)); */      /*phy soft de-reset */
-	pPHY_Reg->PHY_REG1 |= (1 << 2); /*soft de-reset analogue(dll)*/
-	ddr_delayus(3);
-	pPHY_Reg->PHY_REG1 |= (1 << 3);/*soft de-reset digital*/
-	/*pGRF_Reg->GRF_SOC_CON[2] = GRF_DDR_LP_DISB;*/
-	pPHY_Reg->PHY_REG264 |= (1<<1);
-	dsb();
-	ddr_update_odt();
-	ddr_move_to_Config_state();
-	ddr_change_freq_out(freq_slew);
-	ddr_move_to_Access_state();
-
-	deidle_port();
-}
-
-void PIE_FUNC(ddr_change_freq_sram)(void *arg)
-{
-	struct ddr_change_freq_sram_param *param = arg;
-	/* Make sure ddr_SRE_2_SRX paramter less than 4 */
-	ddr_SRE_2_SRX(param->freq, param->freq_slew);
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_change_freq_sram));
-
-typedef struct freq_tag {
-	uint32_t nMHz;
-	struct ddr_freq_t *p_ddr_freq_t;
-} freq_t;
-
-/*----------------------------------------------------------------------
-*Name    : uint32_t __sramfunc ddr_change_freq(uint32_t nMHz)
-*Desc    : ddr
-*Params  : nMHz -> 
-*Return  : 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_change_freq_sram(void *arg)
-{
-	uint32 ret;
-	uint32 i;
-	volatile uint32 n;
-	unsigned long flags;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-	freq_t *p_freq_t = (freq_t *) arg;
-	uint32 nMHz = p_freq_t->nMHz;
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	struct ddr_freq_t *p_ddr_freq_t = p_freq_t->p_ddr_freq_t;
-#endif
-
-	struct ddr_change_freq_sram_param param;
-	/*uint32 freq;*/
-	uint32 freq_slew;
-	uint32 arm_freq;
-	arm_freq = ddr_get_pll_freq(APLL);
-	*kern_to_pie(rockchip_pie_chunk, &DATA(loops_per_us)) =
-	    LPJ_100MHZ * arm_freq / 1000000;
-	ret = p_ddr_set_pll(nMHz, 0);
-	if (ret == *p_ddr_freq) {
-		goto out;
-	} else {
-		freq_slew = (ret > *p_ddr_freq) ? 1 : -1;
-	}
-	ddr_get_parameter(ret);
-	/*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq))= ret;*/
-    /** 1. Make sure there is no host access */
-	local_irq_save(flags);
-	local_fiq_disable();
-	flush_cache_all();
-	outer_flush_all();
-	flush_tlb_all();
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	if (p_ddr_freq_t->screen_ft_us > 0) {
-		p_ddr_freq_t->t1 = cpu_clock(0);
-		p_ddr_freq_t->t2 = (uint32)(p_ddr_freq_t->t1 - p_ddr_freq_t->t0);   /*ns*/
-
-		if ((p_ddr_freq_t->t2 > p_ddr_freq_t->screen_ft_us*1000) && (p_ddr_freq_t->screen_ft_us != 0xfefefefe)) {
-			ret = 0;
-			goto end;
-		} else {
-			rk_fb_poll_wait_frame_complete();
-		}
-	}
-#endif
-    /*8KB SRAM*/
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	n = pGRF_Reg->GRF_SOC_STATUS0;
-	dsb();
-	param.freq = ret;
-	param.freq_slew = freq_slew;
-	call_with_stack(fn_to_pie
-			(rockchip_pie_chunk, &FUNC(ddr_change_freq_sram)),
-			&param,
-			rockchip_sram_stack - (NR_CPUS -
-					       1) * PAUSE_CPU_STACK_SIZE);
-    /** 5. Issues a Mode Exit command   */
-	ddr_dtt_check();
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-end:
-#endif
-	local_fiq_enable();
-	local_irq_restore(flags);
-/*    clk_set_rate(clk_get(NULL, "ddr_pll"), 0);    */
-out:
-	return ret;
-}
-
-bool DEFINE_PIE_DATA(cpu_pause[NR_CPUS]);
-volatile bool *DATA(p_cpu_pause);
-static inline bool is_cpu0_paused(unsigned int cpu)
-{
-	smp_rmb();
-	return DATA(cpu_pause)[0];
-}
-
-static inline void set_cpuX_paused(unsigned int cpu, bool pause)
-{
-	DATA(cpu_pause)[cpu] = pause;
-	smp_wmb();
-}
-
-static inline bool is_cpuX_paused(unsigned int cpu)
-{
-	smp_rmb();
-	return DATA(p_cpu_pause)[cpu];
-}
-
-static inline void set_cpu0_paused(bool pause)
-{
-	DATA(p_cpu_pause)[0] = pause;
-	smp_wmb();
-}
-
-#define MAX_TIMEOUT (16000000UL << 6)	/*>0.64s*/
-
-/* Do not use stack, safe on SMP */
-void PIE_FUNC(_pause_cpu)(void *arg)
-{
-	unsigned int cpu = (unsigned int)arg;
-
-	set_cpuX_paused(cpu, true);
-	while (is_cpu0_paused(cpu))
-    ;
-	set_cpuX_paused(cpu, false);
-}
-
-static void pause_cpu(void *info)
-{
-	unsigned int cpu = raw_smp_processor_id();
-
-	call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(_pause_cpu)),
-			(void *)cpu,
-			rockchip_sram_stack - (cpu - 1) * PAUSE_CPU_STACK_SIZE);
-}
-
-static void wait_cpu(void *info)
-{
-}
-
-static int call_with_single_cpu(u32(*fn) (void *arg), void *arg)
-{
-	u32 timeout = MAX_TIMEOUT;
-	unsigned int cpu;
-	unsigned int this_cpu = smp_processor_id();	/*cpu*/
-	int ret = 0;
-	cpu_maps_update_begin();
-	local_bh_disable();	/*disable swi*/
-	set_cpu0_paused(true);
-	smp_call_function((smp_call_func_t) pause_cpu, NULL, 0);
-
-	for_each_online_cpu(cpu) {
-		if (cpu == this_cpu)
-			continue;
-		while (!is_cpuX_paused(cpu) && --timeout)
-		    ;
-		if (timeout == 0) {
-			pr_err("pause cpu %d timeout\n", cpu);
-			goto out;
-		}
-	}
-
-	ret = fn(arg);
-
-out:
-	set_cpu0_paused(false);
-	local_bh_enable();
-	smp_call_function(wait_cpu, NULL, true);
-	cpu_maps_update_done();
-
-	return ret;
-}
-
-static int __ddr_change_freq(uint32_t nMHz, struct ddr_freq_t ddr_freq_t)
-{
-	freq_t freq;
-	int ret = 0;
-
-	freq.nMHz = nMHz;
-	freq.p_ddr_freq_t = &ddr_freq_t;
-	ret = call_with_single_cpu(&ddr_change_freq_sram, (void *)&freq);
-	/*ret = ddr_change_freq_sram((void*)&freq);*/
-	return ret;
-}
-
-static int _ddr_change_freq(uint32 nMHz)
-{
-	struct ddr_freq_t ddr_freq_t;
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	unsigned long remain_t, vblank_t, pass_t;
-	static unsigned long reserve_t = 800;	/*us*/
-	unsigned long long tmp;
-	int test_count = 0;
-#endif
-	int ret;
-	/*ddr_print("ddr change freq to:%d\n",nMHz);*/
-	memset(&ddr_freq_t, 0x00, sizeof(ddr_freq_t));
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	do {
-		ddr_freq_t.screen_ft_us = rk_fb_get_prmry_screen_ft();
-		ddr_freq_t.t0 = rk_fb_get_prmry_screen_framedone_t();
-		if (!ddr_freq_t.screen_ft_us)
-			return __ddr_change_freq(nMHz, ddr_freq_t);
-
-		tmp = cpu_clock(0) - ddr_freq_t.t0;
-		do_div(tmp, 1000);
-		pass_t = tmp;
-		/*lost frame interrupt*/
-		while (pass_t > ddr_freq_t.screen_ft_us) {
-			int n = pass_t / ddr_freq_t.screen_ft_us;
-
-			/*printk("lost frame int, pass_t:%lu\n", pass_t);*/
-			pass_t -= n * ddr_freq_t.screen_ft_us;
-			ddr_freq_t.t0 += n * ddr_freq_t.screen_ft_us * 1000;
-		}
-
-		remain_t = ddr_freq_t.screen_ft_us - pass_t;
-		if (remain_t < reserve_t) {
-			/*printk("remain_t(%lu) < reserve_t(%lu)\n", remain_t, reserve_t);*/
-			vblank_t = rk_fb_get_prmry_screen_vbt();
-			usleep_range(remain_t + vblank_t, remain_t + vblank_t);
-			continue;
-		}
-		/*test 10 times*/
-		test_count++;
-		if (test_count > 10) {
-			ddr_freq_t.screen_ft_us = 0xfefefefe;
-		}
-		/*printk("ft:%lu, pass_t:%lu, remaint_t:%lu, reservet_t:%lu\n",
-		 *     ddr_freq_t.screen_ft_us, (unsigned long)pass_t, remain_t, reserve_t);*/
-		usleep_range(remain_t - reserve_t, remain_t - reserve_t);
-		flush_tlb_all();
-
-		ret = __ddr_change_freq(nMHz, ddr_freq_t);
-		if (ret) {
-			reserve_t = 800;
-			return ret;
-		} else {
-			if (reserve_t < 3000)
-				reserve_t += 200;
-		}
-	} while (1);
-#else
-	ret = __ddr_change_freq(nMHz, ddr_freq_t);
-#endif
-
-	return ret;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void ddr_set_auto_self_refresh(bool en)
-*Desc    :  selfrefesh 
-*Params  : en -> auto selfrefresh
-*Return  : 
-*Notes   : 1*32 cycle
-*----------------------------------------------------------------------*/
-static void _ddr_set_auto_self_refresh(bool en)
-{
-	/*set auto self-refresh idle    */
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = en ? SR_IDLE : 0;
-}
-
-/*----------------------------------------------------------------------
-*Name    : void __sramfunc ddr_suspend(void)
-*Desc    : ddr suspend
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-void PIE_FUNC(ddr_suspend)(void)
-{
-	ddr_selfrefresh_enter(0);
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x0 << (1 * 4));	/*PLL slow-mode*/
-	dsb();
-	ddr_delayus(1);
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x1 << 13);	/*PLL power-down*/
-	dsb();
-	ddr_delayus(1);
-
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_suspend));
-
-#if 0
-static void ddr_suspend(void)
-{
-	uint32 i;
-	volatile uint32 n;
-	volatile unsigned int *temp = (volatile unsigned int *)SRAM_CODE_OFFSET;
-    /** 1. Make sure there is no host access */
-	flush_cache_all();
-	outer_flush_all();
-    /*flush_tlb_all();*/
-
-    /*sram size = 8KB*/
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-	n = pDDR_Reg->SCFG.d32;
-	n = pPHY_Reg->PHY_REG1;
-	n = pCRU_Reg->CRU_PLL_CON[0][0];
-	n = *(volatile uint32_t *)SysSrv_DdrTiming;
-	n = pGRF_Reg->GRF_SOC_STATUS0;
-	dsb();
-
-	fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_suspend)) ();
-}
-#endif
-
-/*----------------------------------------------------------------------
-*Name    : void __sramfunc ddr_resume(void)
-*Desc    : ddr resume
-*Params  : void
-*Return  : void
-*Notes   :
-*----------------------------------------------------------------------*/
-void PIE_FUNC(ddr_resume)(void)
-{
-	uint32 delay = 1000;
-
-	pCRU_Reg->CRU_PLL_CON[1][1] = ((0x1 << 13) << 16) | (0x0 << 13);	/*PLL no power-down*/
-	dsb();
-	while (delay > 0) {
-		ddr_delayus(1);
-		if (pCRU_Reg->CRU_PLL_CON[1][1] & (0x1 << 10))
-			break;
-		delay--;
-	}
-
-	pCRU_Reg->CRU_MODE_CON = (0x1 << ((1 * 4) + 16)) | (0x1 << (1 * 4));	/*PLL normal*/
-	dsb();
-
-	ddr_selfrefresh_exit();
-}
-
-EXPORT_PIE_SYMBOL(FUNC(ddr_resume));
-
-#if 0
-static void ddr_resume(void)
-{
-	fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_resume)) ();
-}
-#endif
-
-/*----------------------------------------------------------------------
-*Name    : uint32 ddr_get_cap(void)
-*Desc    : 
-*Params  : void
-*Return  : 
-*Notes   :
-*----------------------------------------------------------------------*/
-static uint32 ddr_get_cap(void)
-{
-	uint32 cs, bank, row, col, row1, bw;
-
-	bank = READ_BK_INFO();
-	row = READ_CS0_ROW_INFO();
-	col = READ_COL_INFO();
-	cs = READ_CS_INFO();
-	bw = READ_BW_INFO();
-	if (cs > 1) {
-		row1 = READ_CS1_ROW_INFO();
-		return ((1 << (row + col + bank + bw)) +
-			(1 << (row1 + col + bank + bw)));
-	} else {
-		return (1 << (row + col + bank + bw));
-	}
-}
-
-static long _ddr_round_rate(uint32 nMHz)
-{
-	return p_ddr_set_pll(nMHz, 0);
-}
-
-enum ddr_bandwidth_id{
-	ddrbw_wr_num = 0,
-	ddrbw_rd_num,
-	ddrbw_act_num,
-	ddrbw_time_num,
-	ddrbw_id_end
-};
-
-static void ddr_dfi_monitor_strat(void)
-{
-	pGRF_Reg->GRF_SOC_CON[0] = DDR_MONITOR_EN;
-}
-static void ddr_dfi_monitor_stop(void)
-{
-	pGRF_Reg->GRF_SOC_CON[0] = DDR_MONITOR_DISB;
-}
-
-static void _ddr_bandwidth_get(struct ddr_bw_info *ddr_bw_ch0, struct ddr_bw_info *ddr_bw_ch1)
-{
-	uint32 ddr_bw_val[ddrbw_id_end], ddr_freq;
-	u64 temp64;
-	uint32 i;
-	uint32 ddr_bw;
-
-	ddr_bw = READ_BW_INFO();
-	ddr_dfi_monitor_stop();
-	for (i = 0; i < ddrbw_id_end; i++) {
-		ddr_bw_val[i] = *(uint32 *)(&(pGRF_Reg->GRF_DFI_WRNUM) + i);
-	}
-	if (!ddr_bw_val[ddrbw_time_num])
-		goto end;
-
-	ddr_freq = pDDR_Reg->TOGCNT1U;
-	temp64 = ((u64)ddr_bw_val[ddrbw_wr_num] + (u64)ddr_bw_val[ddrbw_rd_num])*4*100;
-	do_div(temp64, ddr_bw_val[ddrbw_time_num]);
-
-	ddr_bw_ch0->ddr_percent = (uint32)temp64;
-	ddr_bw_ch0->ddr_time = ddr_bw_val[ddrbw_time_num]/(ddr_freq*1000); /*ms*/
-	ddr_bw_ch0->ddr_wr = (ddr_bw_val[ddrbw_wr_num]*8*ddr_bw*2)*ddr_freq/ddr_bw_val[ddrbw_time_num];/*Byte/us,MB/s*/
-	ddr_bw_ch0->ddr_rd = (ddr_bw_val[ddrbw_rd_num]*8*ddr_bw*2)*ddr_freq/ddr_bw_val[ddrbw_time_num];
-	ddr_bw_ch0->ddr_act = ddr_bw_val[ddrbw_act_num];
-	ddr_bw_ch0->ddr_total = ddr_freq*2*ddr_bw*2;
-end:
-	ddr_dfi_monitor_strat();
-}
-
-/*----------------------------------------------------------------------
-*Name    : int ddr_init(uint32_t dram_speed_bin, uint32_t freq)
-*Desc    : ddr  
-*Params  : dram_speed_bin ->ddr
-*          freq ->
-*Return  : 0 
-*Notes   :
-*----------------------------------------------------------------------*/
-static int ddr_init(uint32_t dram_speed_bin, uint32 freq)
-{
-	uint32_t value = 0;
-	uint32_t cs, die = 1;
-	/*uint32_t calStatusLeft, calStatusRight*/
-	struct clk *clk;
-
-	ddr_print("version 1.02 20140828\n");
-	cs = READ_CS_INFO();	/*case 1:1rank ; case 2:2rank*/
-
-	p_ddr_reg = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-	p_ddr_freq = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq));
-	p_ddr_set_pll = fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_set_pll));
-	DATA(p_cpu_pause) =
-	    kern_to_pie(rockchip_pie_chunk, &DATA(cpu_pause[0]));
-	p_ddr_reg->mem_type = ((pGRF_Reg->GRF_OS_REG[1] >> 13) & 0x7);
-	p_ddr_reg->ddr_speed_bin = dram_speed_bin;
-	*p_ddr_freq = 0;
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = 0;
-	*kern_to_pie(rockchip_pie_chunk, &DATA(ddr_dll_status)) =
-	    DDR3_DLL_DISABLE;
-	p_copy_data = kern_to_pie(rockchip_pie_chunk, &copy_data[0]);
-
-	switch (p_ddr_reg->mem_type) {
-	case DDR3:
-		ddr_print("DRAM Type:DDR3\n");
-		break;
-	case LPDDR2:
-		ddr_print("DRAM Type:LPDDR2\n");
-		break;
-	default:
-		ddr_print("ddr type error type=%d\n", (p_ddr_reg->mem_type));
-	}
-	die = 1 << (READ_BW_INFO() - READ_DIE_BW_INFO());
-	p_ddr_reg->ddr_capability_per_die = ddr_get_cap() / (cs * die);
-	ddr_print("%d CS, ROW=%d, Bank=%d, COL=%d, Total Capability=%dMB\n",
-						cs, READ_CS0_ROW_INFO(),
-						(0x1 << (READ_BK_INFO())),
-						READ_COL_INFO(),
-						(ddr_get_cap() >> 20));
-
-	clk = clk_get(NULL, "clk_ddr");
-	if (IS_ERR(clk)) {
-		ddr_print("failed to get ddr clk\n");
-		clk = NULL;
-	}
-	if (freq != 0)
-		value = clk_set_rate(clk, 1000 * 1000 * freq);
-	else
-		value = clk_set_rate(clk, clk_get_rate(clk));
-	ddr_print("init success!!! freq=%luMHz\n",
-		  clk ? clk_get_rate(clk) / 1000000 : freq);
-
-	return 0;
-}
diff --git a/arch/arm/mach-rockchip/ddr_rk32.c b/arch/arm/mach-rockchip/ddr_rk32.c
deleted file mode 100755
index c11c2bbbb8da..000000000000
--- a/arch/arm/mach-rockchip/ddr_rk32.c
+++ /dev/null
@@ -1,4674 +0,0 @@
-/*
- * Function Driver for DDR controller
- *
- * Copyright (C) 2011-2014 Fuzhou Rockchip Electronics Co.,Ltd
- * Author:
- * hcy@rock-chips.com
- * yk@rock-chips.com
- *
- * v1.00
- */
-
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <linux/cpu.h>
-#include <dt-bindings/clock/ddr.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rk_fb.h>
-
-typedef uint32_t uint32;
-
-#ifdef CONFIG_FB_ROCKCHIP
-#define DDR_CHANGE_FREQ_IN_LCDC_VSYNC
-#endif
-/***********************************
- * Global Control Macro
- ***********************************/
-//#define ENABLE_DDR_CLCOK_GPLL_PATH  //for RK3188
-
-#define DDR3_DDR2_ODT_DISABLE_FREQ    (333)
-#define DDR3_DDR2_DLL_DISABLE_FREQ    (333)
-#define SR_IDLE                       (0x3)   //unit:32*DDR clk cycle, and 0 for disable auto self-refresh
-#define PD_IDLE                       (0X40)  //unit:DDR clk cycle, and 0 for disable auto power-down
-
-//#if (DDR3_DDR2_ODT_DISABLE_FREQ > DDR3_DDR2_DLL_DISABLE_FREQ)
-//#error
-//#endif
-
-#define ddr_print(x...) printk( "DDR DEBUG: " x )
-
-/***********************************
- * ARCH Relative Macro and Struction
- ***********************************/
-#define SRAM_CODE_OFFSET        rockchip_sram_virt
-#define SRAM_SIZE               rockchip_sram_size
-
-/*
- * PMU
- */
-//PMU_PWRDN_ST
-#define pd_scu_pwr_st       (1<<11)
-#define pd_hevc_pwr_st      (1<<10)
-#define pd_gpu_pwr_st       (1<<9)
-#define pd_video_pwr_st     (1<<8)
-#define pd_vio_pwr_st       (1<<7)
-#define pd_peri_pwr_st      (1<<6)
-#define pd_bus_pwr_st      (1<<5)
-//PMU_IDLE_REQ
-#define idle_req_hevc_cfg   (1<<9)
-#define idle_req_cpup_cfg   (1<<8)
-#define idle_req_dma_cfg    (1<<7)
-#define idle_req_alive_cfg  (1<<6)
-#define idle_req_core_cfg   (1<<5)
-#define idle_req_vio_cfg    (1<<4)
-#define idle_req_video_cfg  (1<<3)
-#define idle_req_gpu_cfg    (1<<2)
-#define idle_req_peri_cfg   (1<<1)
-#define idle_req_bus_cfg    (1<<0)
-
-//PMU_IDLE_ST
-#define idle_ack_hevc     (1<<25)
-#define idle_ack_cpup     (1<<24)
-#define idle_ack_dma      (1<<23)
-#define idle_ack_alive    (1<<22)
-#define idle_ack_core     (1<<21)
-#define idle_ack_vio      (1<<20)
-#define idle_ack_video    (1<<19)
-#define idle_ack_gpu      (1<<18)
-#define idle_ack_peir     (1<<17)
-#define idle_ack_bus      (1<<16)
-
-#define idle_hevc   (1<<9)
-#define idle_cpup   (1<<8)
-#define idle_dma    (1<<7)
-#define idle_alive  (1<<6)
-#define idle_core   (1<<5)
-#define idle_vio    (1<<4)
-#define idle_video  (1<<3)
-#define idle_gpu    (1<<2)
-#define idle_peri   (1<<1)
-#define idle_bus    (1<<0)
-
-//PMU_PWRMODE_CON
-/* ch=0, channel a
-   ch=1, channel b
- */
-#define ddrio_ret_de_req(ch)  (1<<(21+(ch)))
-#define ddrc_gating_en(ch)    (1<<(19+(ch)))
-#define ddrio_ret_en(ch)      (1<<(17+(ch)))
-#define sref_enter_en(ch)     (1<<(15+(ch)))
-
-//PMU_PWR_STATE
-#define SREF_EXIT             (1<<26)
-#define DDR_IO_PWRUP          (1<<25)
-
-//PMU registers
-typedef volatile struct tagPMU_FILE
-{
-    uint32 PMU_WAKEUP_CFG[2];
-    uint32 PMU_PWRDN_CON;
-    uint32 PMU_PWRDN_ST;
-    uint32 PMU_IDLE_REQ;
-    uint32 PMU_IDLE_ST;
-    uint32 PMU_PWRMODE_CON;
-    uint32 PMU_PWR_STATE;
-    uint32 PMU_OSC_CNT;
-    uint32 PMU_PLL_CNT;
-    uint32 PMU_STABL_CNT;
-    uint32 PMU_DDR0IO_PWRON_CNT;
-    uint32 PMU_DDR1IO_PWRON_CNT;
-    uint32 PMU_CORE_PWRDN_CNT;
-    uint32 PMU_CORE_PWRUP_CNT;
-    uint32 PMU_GPU_PWRDWN_CNT;
-    uint32 PMU_GPU_PWRUP_CNT;
-    uint32 PMU_WAKEUP_RST_CLR_CNT;
-    uint32 PMU_SFT_CON;
-    uint32 PMU_DDR_SREF_ST;
-    uint32 PMU_INT_CON;
-    uint32 PMU_INT_ST;
-    uint32 PMU_BOOT_ADDR_SEL;
-    uint32 PMU_GRF_CON;
-    uint32 PMU_GPIO_SR;
-    uint32 PMU_GPIO0_A_PULL;
-    uint32 PMU_GPIO0_B_PULL;
-    uint32 PMU_GPIO0_C_PULL;
-    uint32 PMU_GPIO0_A_DRV;
-    uint32 PMU_GPIO0_B_DRV;
-    uint32 PMU_GPIO0_C_DRV;
-    uint32 PMU_GPIO_OP;
-    uint32 PMU_GPIO0_SEL18;
-    uint32 PMU_GPIO0_A_IOMUX;
-    uint32 PMU_GPIO0_B_IOMUX;
-    uint32 PMU_GPIO0_C_IOMUX;
-    uint32 PMU_GPIO0_D_IOMUX;
-    uint32 PMU_PMU_SYS_REG[4];
-}PMU_FILE, *pPMU_FILE;
-
-/*
- * CRU
- */
-typedef enum PLL_ID_Tag
-{
-    APLL=0,
-    DPLL,
-    CPLL,
-    GPLL,
-    PLL_MAX
-}PLL_ID;
-
-#define PLL_RESET  (((0x1<<5)<<16) | (0x1<<5))
-#define PLL_DE_RESET  (((0x1<<5)<<16) | (0x0<<5))
-#define NR(n)      ((0x3F<<(8+16)) | (((n)-1)<<8))
-#define NO(n)      ((0xF<<16) | ((n)-1))
-#define NF(n)      ((0x1FFF<<16) | ((n)-1))
-#define NB(n)      ((0xFFF<<16) | ((n)-1))
-
- //CRU Registers
-typedef volatile struct tagCRU_STRUCT
-{
-    uint32 CRU_PLL_CON[5][4];
-    uint32 CRU_MODE_CON;
-    uint32 reserved1[(0x60-0x54)/4];
-    uint32 CRU_CLKSEL_CON[43];
-    uint32 reserved2[(0x160-0x10c)/4];
-    uint32 CRU_CLKGATE_CON[19];
-    uint32 reserved3[(0x1b0-0x1ac)/4];
-    uint32 CRU_GLB_SRST_FST_VALUE;
-    uint32 CRU_GLB_SRST_SND_VALUE;
-    uint32 CRU_SOFTRST_CON[12];
-    uint32 CRU_MISC_CON;
-    uint32 CRU_GLB_CNT_TH;
-    uint32 CRU_TSADC_RST_CON;
-    uint32 reserved4[(0x200-0x1f4)/4];
-    uint32 CRU_SDMMC_CON[2];
-    uint32 CRU_SDIO0_CON[2];
-    uint32 CRU_SDIO1_CON[2];
-    uint32 CRU_EMMC_CON[2];
-    // other regigster unused in boot
-} CRU_REG, *pCRU_REG;
-
-/*
- * GRF
- */
-//REG FILE registers
-typedef volatile struct tagREG_FILE
-{
-    uint32 GRF_GPIO1A_IOMUX;
-    uint32 GRF_GPIO1B_IOMUX;
-    uint32 GRF_GPIO1C_IOMUX;
-    uint32 GRF_GPIO1D_IOMUX;
-    uint32 GRF_GPIO2A_IOMUX;
-    uint32 GRF_GPIO2B_IOMUX;
-    uint32 GRF_GPIO2C_IOMUX;
-    uint32 GRF_GPIO2D_IOMUX;
-    uint32 GRF_GPIO3A_IOMUX;
-    uint32 GRF_GPIO3B_IOMUX;
-    uint32 GRF_GPIO3C_IOMUX;
-    uint32 GRF_GPIO3DL_IOMUX;
-    uint32 GRF_GPIO3DH_IOMUX;
-    uint32 GRF_GPIO4AL_IOMUX;
-    uint32 GRF_GPIO4AH_IOMUX;
-    uint32 GRF_GPIO4BL_IOMUX;
-    uint32 GRF_GPIO4BH_IOMUX;
-    uint32 GRF_GPIO4C_IOMUX;
-    uint32 GRF_GPIO4D_IOMUX;
-    uint32 GRF_GPIO5A_IOMUX;
-    uint32 GRF_GPIO5B_IOMUX;
-    uint32 GRF_GPIO5C_IOMUX;
-    uint32 GRF_GPIO5D_IOMUX;
-    uint32 GRF_GPIO6A_IOMUX;
-    uint32 GRF_GPIO6B_IOMUX;
-    uint32 GRF_GPIO6C_IOMUX;
-    uint32 GRF_GPIO6D_IOMUX;
-    uint32 GRF_GPIO7A_IOMUX;
-    uint32 GRF_GPIO7B_IOMUX;
-    uint32 GRF_GPIO7CL_IOMUX;
-    uint32 GRF_GPIO7CH_IOMUX;
-    uint32 GRF_GPIO7D_IOMUX;
-    uint32 GRF_GPIO8A_IOMUX;
-    uint32 GRF_GPIO8B_IOMUX;
-    uint32 GRF_GPIO8C_IOMUX;
-    uint32 GRF_GPIO8D_IOMUX;
-    uint32 reserved1[(0x100-0x90)/4];
-    uint32 GRF_GPIO1L_SR;
-    uint32 GRF_GPIO1H_SR;
-    uint32 GRF_GPIO2L_SR;
-    uint32 GRF_GPIO2H_SR;
-    uint32 GRF_GPIO3L_SR;
-    uint32 GRF_GPIO3H_SR;
-    uint32 GRF_GPIO4L_SR;
-    uint32 GRF_GPIO4H_SR;
-    uint32 GRF_GPIO5L_SR;
-    uint32 GRF_GPIO5H_SR;
-    uint32 GRF_GPIO6L_SR;
-    uint32 GRF_GPIO6H_SR;
-    uint32 GRF_GPIO7L_SR;
-    uint32 GRF_GPIO7H_SR;
-    uint32 GRF_GPIO8L_SR;
-    uint32 GRF_GPIO8H_SR;
-    uint32 GRF_GPIO1A_P;
-    uint32 GRF_GPIO1B_P;
-    uint32 GRF_GPIO1C_P;
-    uint32 GRF_GPIO1D_P;
-    uint32 GRF_GPIO2A_P;
-    uint32 GRF_GPIO2B_P;
-    uint32 GRF_GPIO2C_P;
-    uint32 GRF_GPIO2D_P;
-    uint32 GRF_GPIO3A_P;
-    uint32 GRF_GPIO3B_P;
-    uint32 GRF_GPIO3C_P;
-    uint32 GRF_GPIO3D_P;
-    uint32 GRF_GPIO4A_P;
-    uint32 GRF_GPIO4B_P;
-    uint32 GRF_GPIO4C_P;
-    uint32 GRF_GPIO4D_P;
-    uint32 GRF_GPIO5A_P;
-    uint32 GRF_GPIO5B_P;
-    uint32 GRF_GPIO5C_P;
-    uint32 GRF_GPIO5D_P;
-    uint32 GRF_GPIO6A_P;
-    uint32 GRF_GPIO6B_P;
-    uint32 GRF_GPIO6C_P;
-    uint32 GRF_GPIO6D_P;
-    uint32 GRF_GPIO7A_P;
-    uint32 GRF_GPIO7B_P;
-    uint32 GRF_GPIO7C_P;
-    uint32 GRF_GPIO7D_P;
-    uint32 GRF_GPIO8A_P;
-    uint32 GRF_GPIO8B_P;
-    uint32 GRF_GPIO8C_P;
-    uint32 GRF_GPIO8D_P;
-    uint32 GRF_GPIO1A_E;
-    uint32 GRF_GPIO1B_E;
-    uint32 GRF_GPIO1C_E;
-    uint32 GRF_GPIO1D_E;
-    uint32 GRF_GPIO2A_E;
-    uint32 GRF_GPIO2B_E;
-    uint32 GRF_GPIO2C_E;
-    uint32 GRF_GPIO2D_E;
-    uint32 GRF_GPIO3A_E;
-    uint32 GRF_GPIO3B_E;
-    uint32 GRF_GPIO3C_E;
-    uint32 GRF_GPIO3D_E;
-    uint32 GRF_GPIO4A_E;
-    uint32 GRF_GPIO4B_E;
-    uint32 GRF_GPIO4C_E;
-    uint32 GRF_GPIO4D_E;
-    uint32 GRF_GPIO5A_E;
-    uint32 GRF_GPIO5B_E;
-    uint32 GRF_GPIO5C_E;
-    uint32 GRF_GPIO5D_E;
-    uint32 GRF_GPIO6A_E;
-    uint32 GRF_GPIO6B_E;
-    uint32 GRF_GPIO6C_E;
-    uint32 GRF_GPIO6D_E;
-    uint32 GRF_GPIO7A_E;
-    uint32 GRF_GPIO7B_E;
-    uint32 GRF_GPIO7C_E;
-    uint32 GRF_GPIO7D_E;
-    uint32 GRF_GPIO8A_E;
-    uint32 GRF_GPIO8B_E;
-    uint32 GRF_GPIO8C_E;
-    uint32 GRF_GPIO8D_E;
-    uint32 GRF_GPIO_SMT;
-    uint32 GRF_SOC_CON[15];
-    uint32 GRF_SOC_STATUS[23];
-    uint32 reserved2[(0x2e0-0x2dc)/4];
-    uint32 GRF_DMAC2_CON[4];
-    uint32 GRF_DDRC0_CON0;
-    uint32 GRF_DDRC1_CON0;
-    uint32 GRF_CPU_CON[5];
-    uint32 reserved3[(0x318-0x30c)/4];
-    uint32 GRF_CPU_STATUS0;
-    uint32 reserved4[(0x320-0x31c)/4];
-    uint32 GRF_UOC0_CON[5];
-    uint32 GRF_UOC1_CON[5];
-    uint32 GRF_UOC2_CON[4];
-    uint32 GRF_UOC3_CON[2];
-    uint32 GRF_UOC4_CON[2];
-    uint32 GRF_DLL_CON[3];
-    uint32 GRF_DLL_STATUS[3];
-    uint32 GRF_IO_VSEL;
-    uint32 GRF_SARADC_TESTBIT;
-    uint32 GRF_TSADC_TESTBIT_L;
-    uint32 GRF_TSADC_TESTBIT_H;
-    uint32 GRF_OS_REG[4];
-    uint32 GRF_FAST_BOOT_ADDR;
-    uint32 GRF_SOC_CON15;
-    uint32 GRF_SOC_CON16;
-} REG_FILE, *pREG_FILE;
-
-/*
- * PCTL
- */
-//SCTL
-#define INIT_STATE                     (0)
-#define CFG_STATE                      (1)
-#define GO_STATE                       (2)
-#define SLEEP_STATE                    (3)
-#define WAKEUP_STATE                   (4)
-
-//STAT
-#define Init_mem                       (0)
-#define Config                         (1)
-#define Config_req                     (2)
-#define Access                         (3)
-#define Access_req                     (4)
-#define Low_power                      (5)
-#define Low_power_entry_req            (6)
-#define Low_power_exit_req             (7)
-
-//MCFG
-#define mddr_lpddr2_clk_stop_idle(n)   ((n)<<24)
-#define pd_idle(n)                     ((n)<<8)
-#define mddr_en                        (2<<22)
-#define lpddr2_en                      (3<<22)
-#define ddr2_en                        (0<<5)
-#define ddr3_en                        (1<<5)
-#define lpddr2_s2                      (0<<6)
-#define lpddr2_s4                      (1<<6)
-#define mddr_lpddr2_bl_2               (0<<20)
-#define mddr_lpddr2_bl_4               (1<<20)
-#define mddr_lpddr2_bl_8               (2<<20)
-#define mddr_lpddr2_bl_16              (3<<20)
-#define ddr2_ddr3_bl_4                 (0)
-#define ddr2_ddr3_bl_8                 (1)
-#define tfaw_cfg(n)                    (((n)-4)<<18)
-#define pd_exit_slow                   (0<<17)
-#define pd_exit_fast                   (1<<17)
-#define pd_type(n)                     ((n)<<16)
-#define two_t_en(n)                    ((n)<<3)
-#define bl8int_en(n)                   ((n)<<2)
-#define cke_or_en(n)                   ((n)<<1)
-
-//POWCTL
-#define power_up_start                 (1<<0)
-
-//POWSTAT
-#define power_up_done                  (1<<0)
-
-//DFISTSTAT0
-#define dfi_init_complete              (1<<0)
-
-//CMDTSTAT
-#define cmd_tstat                      (1<<0)
-
-//CMDTSTATEN
-#define cmd_tstat_en                   (1<<1)
-
-//MCMD
-#define Deselect_cmd                   (0)
-#define PREA_cmd                       (1)
-#define REF_cmd                        (2)
-#define MRS_cmd                        (3)
-#define ZQCS_cmd                       (4)
-#define ZQCL_cmd                       (5)
-#define RSTL_cmd                       (6)
-#define MRR_cmd                        (8)
-#define DPDE_cmd                       (9)
-
-#define lpddr2_op(n)                   ((n)<<12)
-#define lpddr2_ma(n)                   ((n)<<4)
-
-#define bank_addr(n)                   ((n)<<17)
-#define cmd_addr(n)                    ((n)<<4)
-
-#define start_cmd                      (1u<<31)
-
-typedef union STAT_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned ctl_stat : 3;
-        unsigned reserved3 : 1;
-        unsigned lp_trig : 3;
-        unsigned reserved7_31 : 25;
-    }b;
-}STAT_T;
-
-typedef union SCFG_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned hw_low_power_en : 1;
-        unsigned reserved1_5 : 5;
-        unsigned nfifo_nif1_dis : 1;
-        unsigned reserved7 : 1;
-        unsigned bbflags_timing : 4;
-        unsigned reserved12_31 : 20;
-    } b;
-}SCFG_T;
-
-/* DDR Controller register struct */
-typedef volatile struct DDR_REG_Tag
-{
-    //Operational State, Control, and Status Registers
-    SCFG_T SCFG;                   //State Configuration Register
-    volatile uint32 SCTL;                   //State Control Register
-    STAT_T STAT;                   //State Status Register
-    volatile uint32 INTRSTAT;               //Interrupt Status Register
-    uint32 reserved0[(0x40-0x10)/4];
-    //Initailization Control and Status Registers
-    volatile uint32 MCMD;                   //Memory Command Register
-    volatile uint32 POWCTL;                 //Power Up Control Registers
-    volatile uint32 POWSTAT;                //Power Up Status Register
-    volatile uint32 CMDTSTAT;               //Command Timing Status Register
-    volatile uint32 CMDTSTATEN;             //Command Timing Status Enable Register
-    uint32 reserved1[(0x60-0x54)/4];
-    volatile uint32 MRRCFG0;                //MRR Configuration 0 Register
-    volatile uint32 MRRSTAT0;               //MRR Status 0 Register
-    volatile uint32 MRRSTAT1;               //MRR Status 1 Register
-    uint32 reserved2[(0x7c-0x6c)/4];
-    //Memory Control and Status Registers
-    volatile uint32 MCFG1;                  //Memory Configuration 1 Register
-    volatile uint32 MCFG;                   //Memory Configuration Register
-    volatile uint32 PPCFG;                  //Partially Populated Memories Configuration Register
-    volatile uint32 MSTAT;                  //Memory Status Register
-    volatile uint32 LPDDR2ZQCFG;            //LPDDR2 ZQ Configuration Register
-    uint32 reserved3;
-    //DTU Control and Status Registers
-    volatile uint32 DTUPDES;                //DTU Status Register
-    volatile uint32 DTUNA;                  //DTU Number of Random Addresses Created Register
-    volatile uint32 DTUNE;                  //DTU Number of Errors Register
-    volatile uint32 DTUPRD0;                //DTU Parallel Read 0
-    volatile uint32 DTUPRD1;                //DTU Parallel Read 1
-    volatile uint32 DTUPRD2;                //DTU Parallel Read 2
-    volatile uint32 DTUPRD3;                //DTU Parallel Read 3
-    volatile uint32 DTUAWDT;                //DTU Address Width
-    uint32 reserved4[(0xc0-0xb4)/4];
-    //Memory Timing Registers
-    volatile uint32 TOGCNT1U;               //Toggle Counter 1U Register
-    volatile uint32 TINIT;                  //t_init Timing Register
-    volatile uint32 TRSTH;                  //Reset High Time Register
-    volatile uint32 TOGCNT100N;             //Toggle Counter 100N Register
-    volatile uint32 TREFI;                  //t_refi Timing Register
-    volatile uint32 TMRD;                   //t_mrd Timing Register
-    volatile uint32 TRFC;                   //t_rfc Timing Register
-    volatile uint32 TRP;                    //t_rp Timing Register
-    volatile uint32 TRTW;                   //t_rtw Timing Register
-    volatile uint32 TAL;                    //AL Latency Register
-    volatile uint32 TCL;                    //CL Timing Register
-    volatile uint32 TCWL;                   //CWL Register
-    volatile uint32 TRAS;                   //t_ras Timing Register
-    volatile uint32 TRC;                    //t_rc Timing Register
-    volatile uint32 TRCD;                   //t_rcd Timing Register
-    volatile uint32 TRRD;                   //t_rrd Timing Register
-    volatile uint32 TRTP;                   //t_rtp Timing Register
-    volatile uint32 TWR;                    //t_wr Timing Register
-    volatile uint32 TWTR;                   //t_wtr Timing Register
-    volatile uint32 TEXSR;                  //t_exsr Timing Register
-    volatile uint32 TXP;                    //t_xp Timing Register
-    volatile uint32 TXPDLL;                 //t_xpdll Timing Register
-    volatile uint32 TZQCS;                  //t_zqcs Timing Register
-    volatile uint32 TZQCSI;                 //t_zqcsi Timing Register
-    volatile uint32 TDQS;                   //t_dqs Timing Register
-    volatile uint32 TCKSRE;                 //t_cksre Timing Register
-    volatile uint32 TCKSRX;                 //t_cksrx Timing Register
-    volatile uint32 TCKE;                   //t_cke Timing Register
-    volatile uint32 TMOD;                   //t_mod Timing Register
-    volatile uint32 TRSTL;                  //Reset Low Timing Register
-    volatile uint32 TZQCL;                  //t_zqcl Timing Register
-    volatile uint32 TMRR;                   //t_mrr Timing Register
-    volatile uint32 TCKESR;                 //t_ckesr Timing Register
-    volatile uint32 TDPD;                   //t_dpd Timing Register
-    uint32 reserved5[(0x180-0x148)/4];
-    //ECC Configuration, Control, and Status Registers
-    volatile uint32 ECCCFG;                   //ECC Configuration Register
-    volatile uint32 ECCTST;                   //ECC Test Register
-    volatile uint32 ECCCLR;                   //ECC Clear Register
-    volatile uint32 ECCLOG;                   //ECC Log Register
-    uint32 reserved6[(0x200-0x190)/4];
-    //DTU Control and Status Registers
-    volatile uint32 DTUWACTL;                 //DTU Write Address Control Register
-    volatile uint32 DTURACTL;                 //DTU Read Address Control Register
-    volatile uint32 DTUCFG;                   //DTU Configuration Control Register
-    volatile uint32 DTUECTL;                  //DTU Execute Control Register
-    volatile uint32 DTUWD0;                   //DTU Write Data 0
-    volatile uint32 DTUWD1;                   //DTU Write Data 1
-    volatile uint32 DTUWD2;                   //DTU Write Data 2
-    volatile uint32 DTUWD3;                   //DTU Write Data 3
-    volatile uint32 DTUWDM;                   //DTU Write Data Mask
-    volatile uint32 DTURD0;                   //DTU Read Data 0
-    volatile uint32 DTURD1;                   //DTU Read Data 1
-    volatile uint32 DTURD2;                   //DTU Read Data 2
-    volatile uint32 DTURD3;                   //DTU Read Data 3
-    volatile uint32 DTULFSRWD;                //DTU LFSR Seed for Write Data Generation
-    volatile uint32 DTULFSRRD;                //DTU LFSR Seed for Read Data Generation
-    volatile uint32 DTUEAF;                   //DTU Error Address FIFO
-    //DFI Control Registers
-    volatile uint32 DFITCTRLDELAY;            //DFI tctrl_delay Register
-    volatile uint32 DFIODTCFG;                //DFI ODT Configuration Register
-    volatile uint32 DFIODTCFG1;               //DFI ODT Configuration 1 Register
-    volatile uint32 DFIODTRANKMAP;            //DFI ODT Rank Mapping Register
-    //DFI Write Data Registers
-    volatile uint32 DFITPHYWRDATA;            //DFI tphy_wrdata Register
-    volatile uint32 DFITPHYWRLAT;             //DFI tphy_wrlat Register
-    uint32 reserved7[(0x260-0x258)/4];
-    volatile uint32 DFITRDDATAEN;             //DFI trddata_en Register
-    volatile uint32 DFITPHYRDLAT;             //DFI tphy_rddata Register
-    uint32 reserved8[(0x270-0x268)/4];
-    //DFI Update Registers
-    volatile uint32 DFITPHYUPDTYPE0;          //DFI tphyupd_type0 Register
-    volatile uint32 DFITPHYUPDTYPE1;          //DFI tphyupd_type1 Register
-    volatile uint32 DFITPHYUPDTYPE2;          //DFI tphyupd_type2 Register
-    volatile uint32 DFITPHYUPDTYPE3;          //DFI tphyupd_type3 Register
-    volatile uint32 DFITCTRLUPDMIN;           //DFI tctrlupd_min Register
-    volatile uint32 DFITCTRLUPDMAX;           //DFI tctrlupd_max Register
-    volatile uint32 DFITCTRLUPDDLY;           //DFI tctrlupd_dly Register
-    uint32 reserved9;
-    volatile uint32 DFIUPDCFG;                //DFI Update Configuration Register
-    volatile uint32 DFITREFMSKI;              //DFI Masked Refresh Interval Register
-    volatile uint32 DFITCTRLUPDI;             //DFI tctrlupd_interval Register
-    uint32 reserved10[(0x2ac-0x29c)/4];
-    volatile uint32 DFITRCFG0;                //DFI Training Configuration 0 Register
-    volatile uint32 DFITRSTAT0;               //DFI Training Status 0 Register
-    volatile uint32 DFITRWRLVLEN;             //DFI Training dfi_wrlvl_en Register
-    volatile uint32 DFITRRDLVLEN;             //DFI Training dfi_rdlvl_en Register
-    volatile uint32 DFITRRDLVLGATEEN;         //DFI Training dfi_rdlvl_gate_en Register
-    //DFI Status Registers
-    volatile uint32 DFISTSTAT0;               //DFI Status Status 0 Register
-    volatile uint32 DFISTCFG0;                //DFI Status Configuration 0 Register
-    volatile uint32 DFISTCFG1;                //DFI Status configuration 1 Register
-    uint32 reserved11;
-    volatile uint32 DFITDRAMCLKEN;            //DFI tdram_clk_enalbe Register
-    volatile uint32 DFITDRAMCLKDIS;           //DFI tdram_clk_disalbe Register
-    volatile uint32 DFISTCFG2;                //DFI Status configuration 2 Register
-    volatile uint32 DFISTPARCLR;              //DFI Status Parity Clear Register
-    volatile uint32 DFISTPARLOG;              //DFI Status Parity Log Register
-    uint32 reserved12[(0x2f0-0x2e4)/4];
-    //DFI Low Power Registers
-    volatile uint32 DFILPCFG0;                //DFI Low Power Configuration 0 Register
-    uint32 reserved13[(0x300-0x2f4)/4];
-    //DFI Training 2 Registers
-    volatile uint32 DFITRWRLVLRESP0;          //DFI Training dif_wrlvl_resp Status 0 Register
-    volatile uint32 DFITRWRLVLRESP1;          //DFI Training dif_wrlvl_resp Status 1 Register
-    volatile uint32 DFITRWRLVLRESP2;          //DFI Training dif_wrlvl_resp Status 2 Register
-    volatile uint32 DFITRRDLVLRESP0;          //DFI Training dif_rdlvl_resp Status 0 Register
-    volatile uint32 DFITRRDLVLRESP1;          //DFI Training dif_rdlvl_resp Status 1 Register
-    volatile uint32 DFITRRDLVLRESP2;          //DFI Training dif_rdlvl_resp Status 2 Register
-    volatile uint32 DFITRWRLVLDELAY0;         //DFI Training dif_wrlvl_delay Configuration 0 Register
-    volatile uint32 DFITRWRLVLDELAY1;         //DFI Training dif_wrlvl_delay Configuration 1 Register
-    volatile uint32 DFITRWRLVLDELAY2;         //DFI Training dif_wrlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLDELAY0;         //DFI Training dif_rdlvl_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLDELAY1;         //DFI Training dif_rdlvl_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLDELAY2;         //DFI Training dif_rdlvl_delay Configuration 2 Register
-    volatile uint32 DFITRRDLVLGATEDELAY0;     //DFI Training dif_rdlvl_gate_delay Configuration 0 Register
-    volatile uint32 DFITRRDLVLGATEDELAY1;     //DFI Training dif_rdlvl_gate_delay Configuration 1 Register
-    volatile uint32 DFITRRDLVLGATEDELAY2;     //DFI Training dif_rdlvl_gate_delay Configuration 2 Register
-    volatile uint32 DFITRCMD;                 //DFI Training Command Register
-    uint32 reserved14[(0x3f8-0x340)/4];
-    //IP Status Registers
-    volatile uint32 IPVR;                     //IP Version Register
-    volatile uint32 IPTR;                     //IP Type Register
-}DDR_REG_T, *pDDR_REG_T;
-
-/*
- * PUBL
- */
-//PIR
-#define INIT                 (1<<0)
-#define DLLSRST              (1<<1)
-#define DLLLOCK              (1<<2)
-#define ZCAL                 (1<<3)
-#define ITMSRST              (1<<4)
-#define DRAMRST              (1<<5)
-#define DRAMINIT             (1<<6)
-#define QSTRN                (1<<7)
-#define EYETRN               (1<<8)
-#define ICPC                 (1<<16)
-#define DLLBYP               (1<<17)
-#define CTLDINIT             (1<<18)
-#define CLRSR                (1<<28)
-#define LOCKBYP              (1<<29)
-#define ZCALBYP              (1<<30)
-#define INITBYP              (1u<<31)
-
-//PGCR
-#define DFTLMT(n)            ((n)<<3)
-#define DFTCMP(n)            ((n)<<2)
-#define DQSCFG(n)            ((n)<<1)
-#define ITMDMD(n)            ((n)<<0)
-#define RANKEN(n)            ((n)<<18)
-
-//PGSR
-#define IDONE                (1<<0)
-#define DLDONE               (1<<1)
-#define ZCDONE               (1<<2)
-#define DIDONE               (1<<3)
-#define DTDONE               (1<<4)
-#define DTERR                (1<<5)
-#define DTIERR               (1<<6)
-#define DFTERR               (1<<7)
-#define TQ                   (1u<<31)
-
-//PTR0
-#define tITMSRST(n)          ((n)<<18)
-#define tDLLLOCK(n)          ((n)<<6)
-#define tDLLSRST(n)          ((n)<<0)
-
-//PTR1
-#define tDINIT1(n)           ((n)<<19)
-#define tDINIT0(n)           ((n)<<0)
-
-//PTR2
-#define tDINIT3(n)           ((n)<<17)
-#define tDINIT2(n)           ((n)<<0)
-
-//DSGCR
-#define DQSGE(n)             ((n)<<8)
-#define DQSGX(n)             ((n)<<5)
-
-typedef union DCR_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned DDRMD : 3;
-        unsigned DDR8BNK : 1;
-        unsigned PDQ : 3;
-        unsigned MPRDQ : 1;
-        unsigned DDRTYPE : 2;
-        unsigned reserved10_26 : 17;
-        unsigned NOSRA : 1;
-        unsigned DDR2T : 1;
-        unsigned UDIMM : 1;
-        unsigned RDIMM : 1;
-        unsigned TPD : 1;
-    } b;
-}DCR_T;
-
-typedef volatile struct DATX8_REG_Tag
-{
-    volatile uint32 DXGCR;                 //DATX8 General Configuration Register
-    volatile uint32 DXGSR[2];              //DATX8 General Status Register
-    volatile uint32 DXDLLCR;               //DATX8 DLL Control Register
-    volatile uint32 DXDQTR;                //DATX8 DQ Timing Register
-    volatile uint32 DXDQSTR;               //DATX8 DQS Timing Register
-    uint32 reserved[0x80-0x76];
-}DATX8_REG_T;
-
-/* DDR PHY register struct */
-typedef volatile struct DDRPHY_REG_Tag
-{
-    volatile uint32 RIDR;                   //Revision Identification Register
-    volatile uint32 PIR;                    //PHY Initialization Register
-    volatile uint32 PGCR;                   //PHY General Configuration Register
-    volatile uint32 PGSR;                   //PHY General Status Register
-    volatile uint32 DLLGCR;                 //DLL General Control Register
-    volatile uint32 ACDLLCR;                //AC DLL Control Register
-    volatile uint32 PTR[3];                 //PHY Timing Registers 0-2
-    volatile uint32 ACIOCR;                 //AC I/O Configuration Register
-    volatile uint32 DXCCR;                  //DATX8 Common Configuration Register
-    volatile uint32 DSGCR;                  //DDR System General Configuration Register
-    DCR_T DCR;                    //DRAM Configuration Register
-    volatile uint32 DTPR[3];                //DRAM Timing Parameters Register 0-2
-    volatile uint32 MR[4];                    //Mode Register 0-3
-    volatile uint32 ODTCR;                  //ODT Configuration Register
-    volatile uint32 DTAR;                   //Data Training Address Register
-    volatile uint32 DTDR[2];                //Data Training Data Register 0-1
-
-    uint32 reserved1[0x30-0x18];
-    uint32 DCU[0x38-0x30];
-    uint32 reserved2[0x40-0x38];
-    uint32 BIST[0x51-0x40];
-    uint32 reserved3[0x60-0x51];
-
-    volatile uint32 ZQ0CR[2];               //ZQ 0 Impedance Control Register 0-1
-    volatile uint32 ZQ0SR[2];               //ZQ 0 Impedance Status Register 0-1
-    volatile uint32 ZQ1CR[2];               //ZQ 1 Impedance Control Register 0-1
-    volatile uint32 ZQ1SR[2];               //ZQ 1 Impedance Status Register 0-1
-    volatile uint32 ZQ2CR[2];               //ZQ 2 Impedance Control Register 0-1
-    volatile uint32 ZQ2SR[2];               //ZQ 2 Impedance Status Register 0-1
-    volatile uint32 ZQ3CR[2];               //ZQ 3 Impedance Control Register 0-1
-    volatile uint32 ZQ3SR[2];               //ZQ 3 Impedance Status Register 0-1
-
-    DATX8_REG_T     DATX8[9];               //DATX8 Register
-}DDRPHY_REG_T, *pDDRPHY_REG_T;
-
-typedef union NOC_TIMING_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned ActToAct : 6;
-        unsigned RdToMiss : 6;
-        unsigned WrToMiss : 6;
-        unsigned BurstLen : 3;
-        unsigned RdToWr : 5;
-        unsigned WrToRd : 5;
-        unsigned BwRatio : 1;
-    } b;
-}NOC_TIMING_T;
-
-typedef union NOC_ACTIVATE_Tag
-{
-    uint32 d32;
-    struct 
-    {
-        unsigned Rrd : 4;  //bit[0:3]
-        unsigned Faw : 6;  //bit[4:9]
-        unsigned Fawbank : 1; //bit 10
-        unsigned reserved : 21;
-    } b;
-}NOC_ACTIVATE_T;
-
-typedef volatile struct MSCH_REG_Tag
-{
-    volatile uint32 coreid;
-    volatile uint32 revisionid;
-    volatile uint32 ddrconf;
-    volatile NOC_TIMING_T ddrtiming;
-    volatile uint32 ddrmode;
-    volatile uint32 readlatency;
-    uint32 reserved1[(0x38-0x18)/4];
-    volatile NOC_ACTIVATE_T activate;
-    volatile uint32 devtodev;
-}MSCH_REG, *pMSCH_REG;
-
-#define CH_MAX                 (2)
-#define DRAM_PHYS              (0)   //DRAM Channel a physical address start
-#define pPMU_Reg               ((pPMU_FILE)RK_PMU_VIRT)
-#define pCRU_Reg               ((pCRU_REG)RK_CRU_VIRT)
-#define pGRF_Reg               ((pREG_FILE)RK_GRF_VIRT)
-#define pDDR_REG(ch)           ((ch) ? ((pDDR_REG_T)(RK_DDR_VIRT + RK3288_DDR_PCTL_SIZE + RK3288_DDR_PUBL_SIZE)):((pDDR_REG_T)RK_DDR_VIRT))
-#define pPHY_REG(ch)           ((ch) ? ((pDDRPHY_REG_T)(RK_DDR_VIRT + 2 * RK3288_DDR_PCTL_SIZE + RK3288_DDR_PUBL_SIZE)) : ((pDDRPHY_REG_T)(RK_DDR_VIRT + RK3288_DDR_PCTL_SIZE)))
-#define pMSCH_REG(ch)          ((ch)? ((pMSCH_REG)(RK3288_SERVICE_BUS_VIRT+0x80)):((pMSCH_REG)(RK3288_SERVICE_BUS_VIRT)))
-#define GET_DDR3_DS_ODT()      ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_LPDDR2_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define GET_LPDDR3_DS_ODT()    ((0x1<<28) | (0x2<<15) | (0x2<<10) | (0x19<<5) | 0x19)
-#define DDR_GET_RANK_2_ROW15() (0)
-#define DDR_GET_BANK_2_RANK()  (0)
-#define DDR_HW_WAKEUP(ch,en)   do{pGRF_Reg->GRF_SOC_CON[0] = (1<<(16+5+ch)) | (en<<(5+ch));}while(0)
-#define READ_GRF_REG()         (pGRF_Reg->GRF_SOC_CON[0])
-#define GET_DPLL_LOCK_STATUS() (pGRF_Reg->GRF_SOC_STATUS[1] & (1<<5))
-#define SET_DDR_PLL_SRC(src, div)   do{pCRU_Reg->CRU_CLKSEL_CON[26] = ((0x3|(0x1<<2))<<16)|(src<<2)| div;}while(0)
-#define GET_DDR_PLL_SRC()           ((pCRU_Reg->CRU_CLKSEL_CON[26]&(1<<2)) ? GPLL : DPLL)
-#define DDR_GPLL_CLK_GATE(en)       do{pCRU_Reg->CRU_CLKGATE_CON[0] = 0x02000000 | (en<<9);}while(0)
-#define SET_DDRPHY_CLKGATE(ch,dis)  do{pCRU_Reg->CRU_CLKGATE_CON[4] = ((0x1<<(12+ch))<<16) | (dis<<(12+ch));}while(0)
-#define READ_DDR_STRIDE()           (readl_relaxed(RK_SGRF_VIRT+0x8) &0x1F)
-
-#define READ_CH_CNT()         (1+((pPMU_Reg->PMU_PMU_SYS_REG[2]>>12)&0x1))
-#define READ_CH_INFO()        ((pPMU_Reg->PMU_PMU_SYS_REG[2]>>28)&0x3) 
-#define READ_CH_ROW_INFO(ch)  ((pPMU_Reg->PMU_PMU_SYS_REG[2]>>(30+(ch)))&0x1)    //row_3_4:0=normal, 1=6Gb or 12Gb
-
-#define SET_PLL_MODE(pll, mode) do{pCRU_Reg->CRU_MODE_CON = ((mode<<((pll)*4))|(0x3<<(16+(pll)*4)));}while(0)
-#define SET_PLL_PD(pll, pd)     do{pCRU_Reg->CRU_PLL_CON[pll][3] = ((0x1<<1)<<16) | (pd<<1);}while(0)
-
-#define READ_DRAMTYPE_INFO()    ((pPMU_Reg->PMU_PMU_SYS_REG[2]>>13)&0x7)
-#define READ_CS_INFO(ch)        ((((pPMU_Reg->PMU_PMU_SYS_REG[2])>>(11+(ch)*16))&0x1)+1)
-#define READ_BW_INFO(ch)        (2>>(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>(2+(ch)*16))&0x3))
-#define READ_COL_INFO(ch)       (9+(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>(9+(ch)*16))&0x3))
-#define READ_BK_INFO(ch)        (3-(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>(8+(ch)*16))&0x1))
-#define READ_ROW_INFO(ch,cs)    (13+(((pPMU_Reg->PMU_PMU_SYS_REG[2])>>(6-(2*cs)+(ch)*16))&0x3))     
-#define READ_DIE_BW_INFO(ch)    (2>>((pPMU_Reg->PMU_PMU_SYS_REG[2]>>((ch)*16))&0x3))
-
-static const uint16_t  ddr_cfg_2_rbc[] =
-{
-    /****************************/
-    // [8:7]  bank(n:n bit bank)
-    // [6:4]  row(12+n)
-    // [3:2]  bank(n:n bit bank)
-    // [1:0]  col(9+n)
-    /****************************/
-    //all config have (13col,3bank,16row,1cs)
-    //bank,  row,   bank, col          col bank row(32bit)
-    ((3<<7)|(3<<4)|(0<<2)|2),  // 0     11   8   15
-    ((0<<7)|(1<<4)|(3<<2)|1),  // 1     10   8   13
-    ((0<<7)|(2<<4)|(3<<2)|1),  // 2     10   8   14
-    ((0<<7)|(3<<4)|(3<<2)|1),  // 3     10   8   15
-    ((0<<7)|(4<<4)|(3<<2)|1),  // 4     10   8   16
-    ((0<<7)|(1<<4)|(3<<2)|2),  // 5     11   8   13  // 32bit not use
-    ((0<<7)|(2<<4)|(3<<2)|2),  // 6     11   8   14
-    ((0<<7)|(3<<4)|(3<<2)|2),  // 7     11   8   15
-    ((0<<7)|(1<<4)|(3<<2)|0),  // 8     9    8   13
-    ((0<<7)|(2<<4)|(3<<2)|0),  // 9     9    8   14
-    ((0<<7)|(3<<4)|(3<<2)|0),  // 10    9    8   15
-    ((0<<7)|(2<<4)|(2<<2)|0),  // 11    9    4   14
-    ((0<<7)|(1<<4)|(2<<2)|1),  // 12    10   4   13
-    ((0<<7)|(0<<4)|(2<<2)|2),  // 13    11   4   12
-    ((3<<7)|(4<<4)|(0<<2)|1),  // 14    10   8   16 / 10, 4,15 / 10, 8, 15
-    ((0<<7)|(4<<4)|(3<<2)|2),  // 15    11   8   16
-};
-
-/***********************************
- * LPDDR2 define
- ***********************************/
-//MR0 (Device Information)
-#define  LPDDR2_DAI    (0x1)        // 0:DAI complete, 1:DAI still in progress
-#define  LPDDR2_DI     (0x1<<1)     // 0:S2 or S4 SDRAM, 1:NVM
-#define  LPDDR2_DNVI   (0x1<<2)     // 0:DNV not supported, 1:DNV supported
-#define  LPDDR2_RZQI   (0x3<<3)     // 00:RZQ self test not supported, 01:ZQ-pin may connect to VDDCA or float
-                                    // 10:ZQ-pin may short to GND.     11:ZQ-pin self test completed, no error condition detected.
-
-//MR1 (Device Feature)
-#define LPDDR2_BL4     (0x2)
-#define LPDDR2_BL8     (0x3)
-#define LPDDR2_BL16    (0x4)
-#define LPDDR2_nWR(n)  (((n)-2)<<5)
-
-//MR2 (Device Feature 2)
-#define LPDDR2_RL3_WL1  (0x1)
-#define LPDDR2_RL4_WL2  (0x2)
-#define LPDDR2_RL5_WL2  (0x3)
-#define LPDDR2_RL6_WL3  (0x4)
-#define LPDDR2_RL7_WL4  (0x5)
-#define LPDDR2_RL8_WL4  (0x6)
-
-//MR3 (IO Configuration 1)
-#define LPDDR2_DS_34    (0x1)
-#define LPDDR2_DS_40    (0x2)
-#define LPDDR2_DS_48    (0x3)
-#define LPDDR2_DS_60    (0x4)
-#define LPDDR2_DS_80    (0x6)
-#define LPDDR2_DS_120   (0x7)   //optional
-
-//MR4 (Device Temperature)
-#define LPDDR2_tREF_MASK (0x7)
-#define LPDDR2_4_tREF    (0x1)
-#define LPDDR2_2_tREF    (0x2)
-#define LPDDR2_1_tREF    (0x3)
-#define LPDDR2_025_tREF  (0x5)
-#define LPDDR2_025_tREF_DERATE    (0x6)
-
-#define LPDDR2_TUF       (0x1<<7)
-
-//MR8 (Basic configuration 4)
-#define LPDDR2_S4        (0x0)
-#define LPDDR2_S2        (0x1)
-#define LPDDR2_N         (0x2)
-#define LPDDR2_Density(mr8)  (8<<(((mr8)>>2)&0xf))   // Unit:MB
-#define LPDDR2_IO_Width(mr8) (32>>(((mr8)>>6)&0x3))
-
-//MR10 (Calibration)
-#define LPDDR2_ZQINIT   (0xFF)
-#define LPDDR2_ZQCL     (0xAB)
-#define LPDDR2_ZQCS     (0x56)
-#define LPDDR2_ZQRESET  (0xC3)
-
-//MR16 (PASR Bank Mask)
-// S2 SDRAM Only
-#define LPDDR2_PASR_Full (0x0)
-#define LPDDR2_PASR_1_2  (0x1)
-#define LPDDR2_PASR_1_4  (0x2)
-#define LPDDR2_PASR_1_8  (0x3)
-
-//MR17 (PASR Segment Mask) 1Gb-8Gb S4 SDRAM only
-
-//MR32 (DQ Calibration Pattern A)
-
-//MR40 (DQ Calibration Pattern B)
-
-/***********************************
- * LPDDR3 define
- ***********************************/
-//MR0 (Device Information)
-#define  LPDDR3_DAI    (0x1)        // 0:DAI complete, 1:DAI still in progress
-#define  LPDDR3_RZQI   (0x3<<3)     // 00:RZQ self test not supported, 01:ZQ-pin may connect to VDDCA or float
-                                    // 10:ZQ-pin may short to GND.     11:ZQ-pin self test completed, no error condition detected.
-#define  LPDDR3_WL_SUPOT (1<<6)     // 0:DRAM does not support WL(Set B), 1:DRAM support WL(Set B)
-#define  LPDDR3_RL3_SUPOT (1<<7)    // 0:DRAM does not support RL=3,nWR=3,WL=1; 1:DRAM supports RL=3,nWR=3,WL=1 for frequencies <=166
-
-//MR1 (Device Feature)
-#define LPDDR3_BL8     (0x3)
-#define LPDDR3_nWR(n)  ((n)<<5)
-
-//MR2 (Device Feature 2)
-//WL Set A,default
-#define LPDDR3_RL3_WL1   (0x1)       // <=166MHz,optional
-#define LPDDR3_RL6_WL3   (0x4)       // <=400MHz
-#define LPDDR3_RL8_WL4   (0x6)       // <=533MHz
-#define LPDDR3_RL9_WL5   (0x7)       // <=600MHz
-#define LPDDR3_RL10_WL6  (0x8)       // <=667MHz,default
-#define LPDDR3_RL11_WL6  (0x9)       // <=733MHz
-#define LPDDR3_RL12_WL6  (0xa)       // <=800MHz
-#define LPDDR3_RL14_WL8  (0xc)       // <=933MHz
-#define LPDDR3_RL16_WL8  (0xe)       // <=1066MHz
-//WL Set B, optional
-//#define LPDDR3_RL3_WL1   (0x1)       // <=166MHz,optional
-//#define LPDDR3_RL6_WL3   (0x4)       // <=400MHz
-//#define LPDDR3_RL8_WL4   (0x6)       // <=533MHz
-//#define LPDDR3_RL9_WL5   (0x7)       // <=600MHz
-#define LPDDR3_RL10_WL8  (0x8)       // <=667MHz,default
-#define LPDDR3_RL11_WL9  (0x9)       // <=733MHz
-#define LPDDR3_RL12_WL9  (0xa)       // <=800MHz
-#define LPDDR3_RL14_WL11 (0xc)       // <=933MHz
-#define LPDDR3_RL16_WL13 (0xe)       // <=1066MHz
-
-#define LPDDR3_nWRE      (1<<4)      // 1:enable nWR programming > 9(defualt)
-#define LPDDR3_WL_S      (1<<6)      // 1:Select WL Set B
-#define LPDDR3_WR_LEVEL  (1<<7)      // 1:enable
-
-//MR3 (IO Configuration 1)
-#define LPDDR3_DS_34    (0x1)
-#define LPDDR3_DS_40    (0x2)
-#define LPDDR3_DS_48    (0x3)
-#define LPDDR3_DS_60    (0x4)        //reserved
-#define LPDDR3_DS_80    (0x6)        //reserved
-#define LPDDR3_DS_34D_40U   (0x9)  
-#define LPDDR3_DS_40D_48U   (0xa)
-#define LPDDR3_DS_34D_48U   (0xb)
-
-//MR4 (Device Temperature)
-#define LPDDR3_tREF_MASK (0x7)
-#define LPDDR3_LT_EXED   (0x0)       // SDRAM Low temperature operating limit exceeded
-#define LPDDR3_4_tREF    (0x1)
-#define LPDDR3_2_tREF    (0x2)
-#define LPDDR3_1_tREF    (0x3)
-#define LPDDR3_05_tREF   (0x4)
-#define LPDDR3_025_tREF  (0x5)
-#define LPDDR3_025_tREF_DERATE    (0x6)
-#define LPDDR3_HT_EXED   (0x7)       // SDRAM High temperature operating limit exceeded
-
-#define LPDDR3_TUF       (0x1<<7)    // 1:value has changed since last read of MR4
-
-//MR8 (Basic configuration 4)
-#define LPDDR3_S8        (0x3)
-#define LPDDR3_Density(mr8)  (8<<((mr8>>2)&0xf))   // Unit:MB
-#define LPDDR3_IO_Width(mr8) (32>>((mr8>>6)&0x3))
-
-//MR10 (Calibration)
-#define LPDDR3_ZQINIT   (0xFF)
-#define LPDDR3_ZQCL     (0xAB)
-#define LPDDR3_ZQCS     (0x56)
-#define LPDDR3_ZQRESET  (0xC3)
-
-//MR11 (ODT Control)
-#define LPDDR3_ODT_60   (1)           //optional for 1333 and 1600
-#define LPDDR3_ODT_120  (2)
-#define LPDDR3_ODT_240  (3)
-#define LPDDR3_ODT_DIS  (0)
-
-//MR16 (PASR Bank Mask)
-
-//MR17 (PASR Segment Mask) 1Gb-8Gb S4 SDRAM only
-
-//MR32 (DQ Calibration Pattern A)
-
-//MR40 (DQ Calibration Pattern B)
-
-/***********************************
- * DDR3 define
- ***********************************/
-//mr0 for ddr3
-#define DDR3_BL8          (0)
-#define DDR3_BC4_8        (1)
-#define DDR3_BC4          (2)
-#define DDR3_CL(n)        (((((n)-4)&0x7)<<4)|((((n)-4)&0x8)>>1))
-#define DDR3_WR(n)        (((n)&0x7)<<9)
-#define DDR3_DLL_RESET    (1<<8)
-#define DDR3_DLL_DeRESET  (0<<8)
-
-//mr1 for ddr3
-#define DDR3_DLL_ENABLE    (0)
-#define DDR3_DLL_DISABLE   (1)
-#define DDR3_MR1_AL(n)  (((n)&0x3)<<3)
-
-#define DDR3_DS_40            (0)
-#define DDR3_DS_34            (1<<1)
-#define DDR3_Rtt_Nom_DIS      (0)
-#define DDR3_Rtt_Nom_60       (1<<2)
-#define DDR3_Rtt_Nom_120      (1<<6)
-#define DDR3_Rtt_Nom_40       ((1<<2)|(1<<6))
-
-    //mr2 for ddr3
-#define DDR3_MR2_CWL(n) ((((n)-5)&0x7)<<3)
-#define DDR3_Rtt_WR_DIS       (0)
-#define DDR3_Rtt_WR_60        (1<<9)
-#define DDR3_Rtt_WR_120       (2<<9)
-
-/***********************************
- * DDR2 define
- ***********************************/
-//MR;                     //Mode Register
-#define DDR2_BL4           (2)
-#define DDR2_BL8           (3)
-#define DDR2_CL(n)         (((n)&0x7)<<4)
-#define DDR2_WR(n)        ((((n)-1)&0x7)<<9)
-#define DDR2_DLL_RESET    (1<<8)
-#define DDR2_DLL_DeRESET  (0<<8)
-
-//EMR;                    //Extended Mode Register
-#define DDR2_DLL_ENABLE    (0)
-#define DDR2_DLL_DISABLE   (1)
-
-#define DDR2_STR_FULL     (0)
-#define DDR2_STR_REDUCE   (1<<1)
-#define DDR2_AL(n)        (((n)&0x7)<<3)
-#define DDR2_Rtt_Nom_DIS      (0)
-#define DDR2_Rtt_Nom_150      (0x40)
-#define DDR2_Rtt_Nom_75       (0x4)
-#define DDR2_Rtt_Nom_50       (0x44)
-
-/***********************************
- * LPDDR define
- ***********************************/
-#define mDDR_BL2           (1)
-#define mDDR_BL4           (2)
-#define mDDR_BL8           (3)
-#define mDDR_CL(n)         (((n)&0x7)<<4)
-
-#define mDDR_DS_Full       (0)
-#define mDDR_DS_1_2        (1<<5)
-#define mDDR_DS_1_4        (2<<5)
-#define mDDR_DS_1_8        (3<<5)
-#define mDDR_DS_3_4        (4<<5)
-
-static const uint8_t ddr3_cl_cwl[22][7]={
-/*speed   0~330         331~400       401~533        534~666       667~800        801~933      934~1066
- * tCK    >3            2.5~3         1.875~2.5      1.5~1.875     1.25~1.5       1.07~1.25    0.938~1.07
- *        cl<<4, cwl    cl<<4, cwl    cl<<4, cwl              */
-         {((5<<4)|5),   ((5<<4)|5),   0         ,    0,            0,             0,            0}, //DDR3_800D (5-5-5)
-         {((5<<4)|5),   ((6<<4)|5),   0         ,    0,            0,             0,            0}, //DDR3_800E (6-6-6)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    0,            0,             0,            0}, //DDR3_1066E (6-6-6)
-         {((5<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    0,            0,             0,            0}, //DDR3_1066F (7-7-7)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    0,            0,             0,            0}, //DDR3_1066G (8-8-8)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   0,             0,            0}, //DDR3_1333F (7-7-7)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((8<<4)|7),   0,             0,            0}, //DDR3_1333G (8-8-8)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((9<<4)|7),   0,             0,            0}, //DDR3_1333H (9-9-9)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  0,             0,            0}, //DDR3_1333J (10-10-10)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   ((8<<4)|8),    0,            0}, //DDR3_1600G (8-8-8)
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    0,            0}, //DDR3_1600H (9-9-9)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((10<<4)|8),   0,            0}, //DDR3_1600J (10-10-10)
-         {((5<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   0,            0}, //DDR3_1600K (11-11-11)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    ((11<<4)|9),  0}, //DDR3_1866J (10-10-10)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((8<<4)|7),   ((10<<4)|8),   ((11<<4)|9),  0}, //DDR3_1866K (11-11-11)
-         {((6<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((11<<4)|8),   ((12<<4)|9),  0}, //DDR3_1866L (12-12-12)
-         {((6<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   ((13<<4)|9),  0}, //DDR3_1866M (13-13-13)
-
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((7<<4)|7),   ((9<<4)|8),    ((10<<4)|9),  ((11<<4)|10)}, //DDR3_2133K (11-11-11)
-         {((5<<4)|5),   ((5<<4)|5),   ((6<<4)|6),    ((8<<4)|7),   ((9<<4)|8),    ((11<<4)|9),  ((12<<4)|10)}, //DDR3_2133L (12-12-12)
-         {((5<<4)|5),   ((5<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((10<<4)|8),   ((12<<4)|9),  ((13<<4)|10)}, //DDR3_2133M (13-13-13)
-         {((6<<4)|5),   ((6<<4)|5),   ((7<<4)|6),    ((9<<4)|7),   ((11<<4)|8),   ((13<<4)|9),  ((14<<4)|10)},  //DDR3_2133N (14-14-14)
-
-         {((6<<4)|5),   ((6<<4)|5),   ((8<<4)|6),    ((10<<4)|7),  ((11<<4)|8),   ((13<<4)|9),  ((14<<4)|10)} //DDR3_DEFAULT
-};
-
-static const uint16_t ddr3_tRC_tFAW[22]={
-/**    tRC    tFAW   */
-    ((50<<8)|50), //DDR3_800D (5-5-5)
-    ((53<<8)|50), //DDR3_800E (6-6-6)
-
-    ((49<<8)|50), //DDR3_1066E (6-6-6)
-    ((51<<8)|50), //DDR3_1066F (7-7-7)
-    ((53<<8)|50), //DDR3_1066G (8-8-8)
-
-    ((47<<8)|45), //DDR3_1333F (7-7-7)
-    ((48<<8)|45), //DDR3_1333G (8-8-8)
-    ((50<<8)|45), //DDR3_1333H (9-9-9)
-    ((51<<8)|45), //DDR3_1333J (10-10-10)
-
-    ((45<<8)|40), //DDR3_1600G (8-8-8)
-    ((47<<8)|40), //DDR3_1600H (9-9-9)
-    ((48<<8)|40), //DDR3_1600J (10-10-10)
-    ((49<<8)|40), //DDR3_1600K (11-11-11)
-
-    ((45<<8)|35), //DDR3_1866J (10-10-10)
-    ((46<<8)|35), //DDR3_1866K (11-11-11)
-    ((47<<8)|35), //DDR3_1866L (12-12-12)
-    ((48<<8)|35), //DDR3_1866M (13-13-13)
-
-    ((44<<8)|35), //DDR3_2133K (11-11-11)
-    ((45<<8)|35), //DDR3_2133L (12-12-12)
-    ((46<<8)|35), //DDR3_2133M (13-13-13)
-    ((47<<8)|35), //DDR3_2133N (14-14-14)
-
-    ((53<<8)|50)  //DDR3_DEFAULT
-};
-
-typedef enum DRAM_TYPE_Tag
-{
-    LPDDR = 0,
-    DDR,
-    DDR2,
-    DDR3,
-    LPDDR2,
-    LPDDR3,
-
-    DRAM_MAX
-}DRAM_TYPE;
-
-typedef struct PCTRL_TIMING_Tag
-{
-    uint32 ddrFreq;
-    //Memory Timing Registers
-    uint32 togcnt1u;               //Toggle Counter 1U Register
-    uint32 tinit;                  //t_init Timing Register
-    uint32 trsth;                  //Reset High Time Register
-    uint32 togcnt100n;             //Toggle Counter 100N Register
-    uint32 trefi;                  //t_refi Timing Register
-    uint32 tmrd;                   //t_mrd Timing Register
-    uint32 trfc;                   //t_rfc Timing Register
-    uint32 trp;                    //t_rp Timing Register
-    uint32 trtw;                   //t_rtw Timing Register
-    uint32 tal;                    //AL Latency Register
-    uint32 tcl;                    //CL Timing Register
-    uint32 tcwl;                   //CWL Register
-    uint32 tras;                   //t_ras Timing Register
-    uint32 trc;                    //t_rc Timing Register
-    uint32 trcd;                   //t_rcd Timing Register
-    uint32 trrd;                   //t_rrd Timing Register
-    uint32 trtp;                   //t_rtp Timing Register
-    uint32 twr;                    //t_wr Timing Register
-    uint32 twtr;                   //t_wtr Timing Register
-    uint32 texsr;                  //t_exsr Timing Register
-    uint32 txp;                    //t_xp Timing Register
-    uint32 txpdll;                 //t_xpdll Timing Register
-    uint32 tzqcs;                  //t_zqcs Timing Register
-    uint32 tzqcsi;                 //t_zqcsi Timing Register
-    uint32 tdqs;                   //t_dqs Timing Register
-    uint32 tcksre;                 //t_cksre Timing Register
-    uint32 tcksrx;                 //t_cksrx Timing Register
-    uint32 tcke;                   //t_cke Timing Register
-    uint32 tmod;                   //t_mod Timing Register
-    uint32 trstl;                  //Reset Low Timing Register
-    uint32 tzqcl;                  //t_zqcl Timing Register
-    uint32 tmrr;                   //t_mrr Timing Register
-    uint32 tckesr;                 //t_ckesr Timing Register
-    uint32 tdpd;                   //t_dpd Timing Register
-}PCTL_TIMING_T;
-
-typedef union DTPR_0_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tMRD : 2;
-        unsigned tRTP : 3;
-        unsigned tWTR : 3;
-        unsigned tRP : 4;
-        unsigned tRCD : 4;
-        unsigned tRAS : 5;
-        unsigned tRRD : 4;
-        unsigned tRC : 6;
-        unsigned tCCD : 1;
-    } b;
-}DTPR_0_T;
-
-typedef union DTPR_1_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tAOND : 2;
-        unsigned tRTW : 1;
-        unsigned tFAW : 6;
-        unsigned tMOD : 2;
-        unsigned tRTODT : 1;
-        unsigned reserved12_15 : 4;
-        unsigned tRFC : 8;
-        unsigned tDQSCK : 3;
-        unsigned tDQSCKmax : 3;
-        unsigned reserved30_31 : 2;
-    } b;
-}DTPR_1_T;
-
-typedef union DTPR_2_Tag
-{
-    uint32 d32;
-    struct
-    {
-        unsigned tXS : 10;
-        unsigned tXP : 5;
-        unsigned tCKE : 4;
-        unsigned tDLLK : 10;
-        unsigned reserved29_31 : 3;
-    } b;
-}DTPR_2_T;
-
-typedef struct PHY_TIMING_Tag
-{
-    DTPR_0_T  dtpr0;
-    DTPR_1_T  dtpr1;
-    DTPR_2_T  dtpr2;
-    uint32    mr[4];   //LPDDR2 no MR0, mr[2] is mDDR MR1
-    uint32    mr11;    //for LPDDR3 only
-}PHY_TIMING_T;
-
-typedef struct PCTL_REG_Tag
-{
-    uint32 SCFG;
-    uint32 CMDTSTATEN;
-    uint32 MCFG1;
-    uint32 MCFG;
-    PCTL_TIMING_T pctl_timing;
-    //DFI Control Registers
-    uint32 DFITCTRLDELAY;
-    uint32 DFIODTCFG;
-    uint32 DFIODTCFG1;
-    uint32 DFIODTRANKMAP;
-    //DFI Write Data Registers
-    uint32 DFITPHYWRDATA;
-    uint32 DFITPHYWRLAT;
-    //DFI Read Data Registers
-    uint32 DFITRDDATAEN;
-    uint32 DFITPHYRDLAT;
-    //DFI Update Registers
-    uint32 DFITPHYUPDTYPE0;
-    uint32 DFITPHYUPDTYPE1;
-    uint32 DFITPHYUPDTYPE2;
-    uint32 DFITPHYUPDTYPE3;
-    uint32 DFITCTRLUPDMIN;
-    uint32 DFITCTRLUPDMAX;
-    uint32 DFITCTRLUPDDLY;
-    uint32 DFIUPDCFG;
-    uint32 DFITREFMSKI;
-    uint32 DFITCTRLUPDI;
-    //DFI Status Registers
-    uint32 DFISTCFG0;
-    uint32 DFISTCFG1;
-    uint32 DFITDRAMCLKEN;
-    uint32 DFITDRAMCLKDIS;
-    uint32 DFISTCFG2;
-    //DFI Low Power Register
-    uint32 DFILPCFG0;
-}PCTL_REG_T;
-
-typedef struct PUBL_DQS_REG_Tag
-{
-    uint32 DX0GCR;
-    uint32 DX0DLLCR;
-    uint32 DX0DQTR;
-    uint32 DX0DQSTR;
-
-    uint32 DX1GCR;
-    uint32 DX1DLLCR;
-    uint32 DX1DQTR;
-    uint32 DX1DQSTR;
-
-    uint32 DX2GCR;
-    uint32 DX2DLLCR;
-    uint32 DX2DQTR;
-    uint32 DX2DQSTR;
-
-    uint32 DX3GCR;
-    uint32 DX3DLLCR;
-    uint32 DX3DQTR;
-    uint32 DX3DQSTR;
-}PUBL_DQS_REG;
-
-typedef struct PUBL_REG_Tag
-{
-    uint32 PIR;
-    uint32 PGCR;
-    uint32 DLLGCR;
-    uint32 ACDLLCR;
-    uint32 PTR[3];
-    uint32 ACIOCR;
-    uint32 DXCCR;
-    uint32 DSGCR;
-    uint32 DCR;
-    PHY_TIMING_T phy_timing;
-    uint32 ODTCR;
-    uint32 DTAR;
-    uint32 ZQ0CR0;
-    uint32 ZQ1CR0;
-}PUBL_REG_T;
-
-typedef struct SET_REG_Tag
-{
-    uint32 addr;
-    uint32 val;
-}SET_REG_T;
-
-typedef struct BACKUP_REG_Tag
-{
-    uint32 tag;
-    /* any addr = 0xFFFFFFFF, indicate invalid */
-    uint32 pctlAddr[CH_MAX];
-    PCTL_REG_T pctl;
-    uint32 publAddr[CH_MAX];
-    PUBL_REG_T publ;
-    PUBL_DQS_REG dqs[CH_MAX];
-    uint32 nocAddr[CH_MAX];
-    MSCH_REG   noc[CH_MAX];
-
-    uint32 pllpdAddr;
-    uint32 pllpdMask;
-    uint32 pllpdVal;
-
-    uint32 dpllmodeAddr;
-    uint32 dpllSlowMode;
-    uint32 dpllNormalMode;
-    uint32 dpllResetAddr;
-    uint32 dpllReset;
-    uint32 dpllDeReset;
-    uint32 dpllConAddr;
-    uint32 dpllCon[4];
-    uint32 dpllLockAddr;
-    uint32 dpllLockMask;
-    uint32 dpllLockVal;
-
-    uint32 ddrPllSrcDivAddr;
-    uint32 ddrPllSrcDiv;
-
-    uint32 retenDisAddr;
-    uint32 retenDisVal;
-    uint32 retenStAddr;
-    uint32 retenStMask;
-    uint32 retenStVal;
-
-    /* ddr relative grf register */
-    uint32 grfRegCnt;     //if no grf, set 0
-    SET_REG_T grf[3];        //SET_REG_T grf[grfRegCnt];
-
-    /* other ddr relative register */
-    //uint32 otherRegCnt; // if = 0xFFFFFFFF, indicate invalid
-    //SET_REG_T other[grfRegCnt];
-    uint32 endTag;         //must = 0xFFFFFFFF
-}BACKUP_REG_T;
-
-typedef struct CHANNEL_INFO_Tag
-{
-    //inited data
-    uint32        chNum;  //channel number,0:channel a; 1:channel b;
-    pDDR_REG_T    pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg;
-    pMSCH_REG     pMSCH_Reg;
-    //need init data
-    DRAM_TYPE     mem_type; // =DRAM_MAX, channel invalid
-    uint32        ddr_speed_bin;    // used for ddr3 only
-    uint32        ddr_capability_per_die;  // one chip cs capability
-    uint32        dtt_cs;  //data training cs
-}CH_INFO,*pCH_INFO;
-
-struct ddr_freq_t {
-    unsigned long screen_ft_us;
-    unsigned long long t0;
-    unsigned long long t1;
-    unsigned long t2;
-};
-
-typedef struct STRIDE_INFO_Tag
-{
-    uint32  size;
-    uint32  halfCap;
-}STRIDE_INFO;
-
-static const STRIDE_INFO   gStrideInfo[]={
-    {0x10000000,0x10000000},  // 256
-    {0x20000000,0x20000000},  // 512
-    {0x40000000,0x40000000},  // 1G
-    {0x80000000,0x80000000},  // 2G
-    
-    {128,0x20000000},
-    {256,0x20000000},
-    {512,0x20000000},
-    {4096,0x20000000},
-    
-    {128,0x40000000},
-    {256,0x40000000},
-    {512,0x40000000},
-    {4096,0x40000000},
-
-    {128,0x80000000},
-    {256,0x80000000},
-    {512,0x80000000},
-    {4096,0x80000000},
-
-    {128,0x60000000},
-    {256,0x60000000},
-    {512,0x60000000},
-    {4096,0x60000000},
-
-    {0,0x20000000},
-    {0,0x40000000},
-    {0,0x80000000},
-    {0,0x80000000},  // 4GB
-
-    {0,0},  //reserved
-    {0,0},  //reserved
-    
-    {0,0},
-    {128,0},
-};
-
-CH_INFO DEFINE_PIE_DATA(ddr_ch[2]);
-static pCH_INFO p_ddr_ch[2];    //only used in kern, not pie
-BACKUP_REG_T DEFINE_PIE_DATA(ddr_reg);
-static BACKUP_REG_T *p_ddr_reg;
-static __attribute__((aligned(4096))) uint32 ddr_data_training_buf[32+8192/4];  //data in two channel even use max stride
-uint32 DEFINE_PIE_DATA(ddr_freq);
-uint32 DEFINE_PIE_DATA(ddr_sr_idle);
-
-/***********************************
- * ARCH Relative Data and Function
- ***********************************/
-static __sramdata uint32 clkr;
-static __sramdata uint32 clkf;
-static __sramdata uint32 clkod;
-uint32 DEFINE_PIE_DATA(ddr_select_gpll_div); // 0-Disable, 1-1:1, 2-2:1, 4-4:1
-#if defined(ENABLE_DDR_CLCOK_GPLL_PATH)
-static uint32 *p_ddr_select_gpll_div;
-#endif
-
-static void __sramfunc ddr_delayus(uint32 us);
-
-static noinline uint32 ddr_get_pll_freq(PLL_ID pll_id)   //APLL-1;CPLL-2;DPLL-3;GPLL-4
-{
-    uint32 ret = 0;
-
-     // freq = (Fin/NR)*NF/OD
-    if(((pCRU_Reg->CRU_MODE_CON>>(pll_id*4))&3) == 1)             // DPLL Normal mode
-        ret= 24 *((pCRU_Reg->CRU_PLL_CON[pll_id][1]&0x1fff)+1)    // NF = 2*(CLKF+1)
-                /((((pCRU_Reg->CRU_PLL_CON[pll_id][0]>>8)&0x3f)+1)           // NR = CLKR+1
-                *((pCRU_Reg->CRU_PLL_CON[pll_id][0]&0xF)+1));             // OD = 2^CLKOD
-    else
-        ret = 24;
-
-    return ret;
-}
-
-/*****************************************
-NR   NO     NF               Fout                       freq Step     finally use
-1    8      12.5 - 62.5      37.5MHz  - 187.5MHz        3MHz          50MHz   <= 150MHz
-1    6      12.5 - 62.5      50MHz    - 250MHz          4MHz          150MHz  <= 200MHz
-1    4      12.5 - 62.5      75MHz    - 375MHz          6MHz          200MHz  <= 300MHz
-1    2      12.5 - 62.5      150MHz   - 750MHz          12MHz         300MHz  <= 600MHz
-1    1      12.5 - 62.5      300MHz   - 1500MHz         24MHz         600MHz  <= 1200MHz
-******************************************/
-static uint32 __sramfunc ddr_set_pll_rk3188_plus(uint32 nMHz, uint32 set)
-{
-    uint32 ret = 0;
-    int delay;
-
-    if(nMHz == 24)
-    {
-        ret = 24;
-        goto out;
-    }
-
-    if(set==0)
-    {
-        if(nMHz <= 150)
-        {
-            clkod = 8;
-        }
-        else if(nMHz <= 200)
-        {
-            clkod = 6;
-        }
-        else if(nMHz <= 300)
-        {
-            clkod = 4;
-        }
-        else if(nMHz <= 600)
-        {
-            clkod = 2;
-        }
-        else
-        {
-            clkod = 1;
-        }
-        clkr = 1;
-        clkf=(nMHz*clkr*clkod)/24;
-        ret = (24*clkf)/(clkr*clkod);
-    }
-    else if(set == 1)
-    {
-        SET_DDR_PLL_SRC(1, (DATA(ddr_select_gpll_div)-1));  //clk_ddr_src = GPLL
-        
-        SET_PLL_MODE(DPLL,0);            //PLL slow-mode
-        dsb();
-
-        pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_RESET;
-        ddr_delayus(1);
-        pCRU_Reg->CRU_PLL_CON[DPLL][0] = NR(clkr) | NO(clkod);
-        pCRU_Reg->CRU_PLL_CON[DPLL][1] = NF(clkf);
-        pCRU_Reg->CRU_PLL_CON[DPLL][2] = NB(clkf>>1);
-        ddr_delayus(1);
-        pCRU_Reg->CRU_PLL_CON[DPLL][3] = PLL_DE_RESET;
-        dsb();
-    }
-    else
-    {
-        delay = 1000;
-        while (delay > 0)
-        {
-            if (GET_DPLL_LOCK_STATUS())
-                break;
-            ddr_delayus(1);
-            delay--;
-        }
-
-        SET_DDR_PLL_SRC(0, 0);  //clk_ddr_src = DDR PLL,clk_ddr_src:clk_ddrphy = 1:1
-        SET_PLL_MODE(DPLL,1);            //PLL normal
-        dsb();
-    }
-    
-out:
-    return ret;
-}
-
-uint32 PIE_FUNC(ddr_set_pll)(uint32 nMHz, uint32 set)
-{
-    return ddr_set_pll_rk3188_plus(nMHz,set);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_set_pll));
-static uint32 (*p_ddr_set_pll)(uint32 nMHz, uint32 set);
-
-static void __sramfunc idle_port(void)
-{
-    register int i,j;
-    uint32 clk_gate[19];
-
-    pPMU_Reg->PMU_IDLE_REQ |= idle_req_core_cfg;
-    dsb();
-    while( (pPMU_Reg->PMU_IDLE_ST & idle_core) == 0 );
-
-    //save clock gate status
-    for(i=0;i<19;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<19;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    i = pPMU_Reg->PMU_PWRDN_ST;
-    j = idle_req_dma_cfg;
-    
-    if ( (i & pd_peri_pwr_st) == 0 )
-    {
-        j |= idle_req_peri_cfg;
-    }
-
-    if ( (i & pd_video_pwr_st) == 0 )
-    {
-        j |= idle_req_video_cfg;
-    }
-
-    if ( (i & pd_gpu_pwr_st) == 0 )
-    {
-        j |= idle_req_gpu_cfg;
-    }
-
-    if ( (i & pd_hevc_pwr_st) == 0 )
-    {
-        j |= idle_req_hevc_cfg;
-    }
-
-    if ( (i & pd_vio_pwr_st) == 0 )
-    {
-        j |= idle_req_vio_cfg;
-    }
-
-    pPMU_Reg->PMU_IDLE_REQ |= j;
-    dsb();
-    while( (pPMU_Reg->PMU_IDLE_ST & j) != j );
-
-    //resume clock gate status
-    for(i=0;i<19;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-}
-
-static void inline deidle_port(void)
-{
-    register int i,j;
-    uint32 clk_gate[19];
-
-    //save clock gate status
-    for(i=0;i<19;i++)
-        clk_gate[i]=pCRU_Reg->CRU_CLKGATE_CON[i];
-
-    //enable all clock gate for request idle
-    for(i=0;i<19;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=0xffff0000;
-
-    i = pPMU_Reg->PMU_PWRDN_ST;
-    j = idle_req_dma_cfg;
-    
-    if ( (i & pd_peri_pwr_st) == 0 )
-    {
-        j |= idle_req_peri_cfg;
-    }
-
-    if ( (i & pd_video_pwr_st) == 0 )
-    {
-        j |= idle_req_video_cfg;
-    }
-
-    if ( (i & pd_gpu_pwr_st) == 0 )
-    {
-        j |= idle_req_gpu_cfg;
-    }
-
-    if ( (i & pd_hevc_pwr_st) == 0 )
-    {
-        j |= idle_req_hevc_cfg;
-    }
-
-    if ( (i & pd_vio_pwr_st) == 0 )
-    {
-        j |= idle_req_vio_cfg;
-    }
-
-    pPMU_Reg->PMU_IDLE_REQ &= ~j;
-    dsb();
-    while( (pPMU_Reg->PMU_IDLE_ST & j) != 0 );
-
-    pPMU_Reg->PMU_IDLE_REQ &= ~idle_req_core_cfg;
-    dsb();
-    while( (pPMU_Reg->PMU_IDLE_ST & idle_core) != 0 );
-
-    //resume clock gate status
-    for(i=0;i<19;i++)
-        pCRU_Reg->CRU_CLKGATE_CON[i]=  (clk_gate[i] | 0xffff0000);
-
-}
-
-/***********************************
- * Only DDR Relative Function
- ***********************************/
-
-/****************************************************************************
-Internal sram us delay function
-Cpu highest frequency is 1.6 GHz
-1 cycle = 1/1.6 ns
-1 us = 1000 ns = 1000 * 1.6 cycles = 1600 cycles
-*****************************************************************************/
-__sramdata volatile uint32 loops_per_us;
-
-#define LPJ_100MHZ  999456UL
-
-static void __sramfunc ddr_delayus(uint32 us)
-{
-    do
-    {
-        volatile unsigned int i = (loops_per_us*us);
-        if (i < 7) i = 7;
-        barrier();
-        asm volatile(".align 4; 1: subs %0, %0, #1; bne 1b;" : "+r" (i));
-    } while (0);
-}
-
-void PIE_FUNC(ddr_copy)(uint64_t *pDest, uint64_t *pSrc, uint32 wword)
-{
-    uint32 i;
-
-    for(i=0; i<wword; i++)
-    {
-        pDest[i] = pSrc[i];
-    }
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_copy));
-
-static void ddr_get_datatraing_addr(uint32 *pdtar)
-{
-    uint32          addr;
-    uint32          stride;
-    uint32          strideSize;
-    uint32          halfCap;
-    uint32          ch,chCnt;
-    uint32          socAddr[2];
-    uint32          chAddr[2];
-    uint32          col;
-    uint32          row;
-    uint32          bank;
-    uint32          bw;
-    uint32          conf;
-    uint32          cap1;
-
-    for(ch=0,chCnt=0;ch<CH_MAX;ch++)
-    {
-        if(p_ddr_ch[ch]->mem_type != DRAM_MAX)
-        {
-            chCnt++;
-        }
-        p_ddr_ch[ch]->dtt_cs = 0;
-    }
-
-    // caculate aglined physical address
-    addr =  __pa((unsigned long)ddr_data_training_buf);
-    ddr_print("addr=0x%x\n",addr);
-    if(addr&0x3F)
-    {
-        addr += (64-(addr&0x3F));  // 64byte align
-    }
-    addr -= DRAM_PHYS;
-    if(chCnt > 1)
-    {
-        //find stride info
-        stride = READ_DDR_STRIDE(); 
-        strideSize = gStrideInfo[stride].size;
-        halfCap = gStrideInfo[stride].halfCap;
-        ddr_print("stride=%d, size=%d, halfcap=%x\n", stride,strideSize,halfCap);
-        //get soc addr
-        if(addr & strideSize)  // odd stride size
-        {
-            socAddr[0] = addr + strideSize;
-            socAddr[1] = addr;
-        }
-        else
-        {
-            socAddr[0] = addr;
-            socAddr[1] = addr + strideSize;
-        }
-        ddr_print("socAddr[0]=0x%x, socAddr[1]=0x%x\n", socAddr[0], socAddr[1]);
-	 if(stride < 4)
-	 {
-	 	 cap1 = (1 << (READ_ROW_INFO(1,0)+READ_COL_INFO(1)+READ_BK_INFO(1)+READ_BW_INFO(1)));
-	        if(READ_CS_INFO(1) > 1)
-	        {
-	            cap1 += cap1 >> (READ_ROW_INFO(1,0)-READ_ROW_INFO(1,1));
-	        }
-	        if(READ_CH_ROW_INFO(1))
-	        {
-	            cap1 = cap1*3/4;
-	        }
-		 chAddr[0] = addr;
-		 chAddr[1] = cap1 - PAGE_SIZE;
-		 if(READ_CS_INFO(1) > 1)
-		         p_ddr_ch[1]->dtt_cs = 1;
-	 }
-        else if((stride >= 0x10) && (stride <= 0x13))  // 3GB stride
-        {
-            //conver to ch addr
-            if(addr < 0x40000000)
-            {
-                chAddr[0] = socAddr[0];
-                chAddr[1] = socAddr[1] - strideSize;
-            }
-            else if(addr < 0x80000000)
-            {
-                chAddr[0] = socAddr[0] - 0x40000000 + strideSize;
-                chAddr[1] = socAddr[1] - 0x40000000;
-            }
-            else if(addr < 0xA0000000)
-            {
-                chAddr[0] = socAddr[0] - 0x40000000;
-                chAddr[1] = socAddr[1] - 0x40000000 - strideSize;
-            }
-            else
-            {
-                chAddr[0] = socAddr[0] - 0x60000000 + strideSize;
-                chAddr[1] = socAddr[1] - 0x60000000;
-            }
-        }
-        else
-        {
-            //conver to ch addr
-            if(addr <  halfCap)
-            {
-                chAddr[0] = socAddr[0];
-                chAddr[1] = socAddr[1] - strideSize;
-            }
-            else
-            {
-                chAddr[0] = socAddr[0] - halfCap + strideSize;
-                chAddr[1] = socAddr[1] - halfCap;
-            }
-        }
-    }
-    else
-    {
-        chAddr[0] = addr;
-        chAddr[1] = addr;
-    }
-    ddr_print("chAddr[0]=0x%x, chAddr[1]=0x%x\n", chAddr[0], chAddr[1]);
-
-    for(ch=0,chCnt=0;ch<CH_MAX;ch++)
-    {
-        if(p_ddr_ch[ch]->mem_type != DRAM_MAX)
-        {
-            // find out colrowbank,config
-            row = READ_ROW_INFO(ch,0);
-            bank = READ_BK_INFO(ch);
-            col = READ_COL_INFO(ch);
-            bw = READ_BW_INFO(ch);
-            conf = p_ddr_ch[ch]->pMSCH_Reg->ddrconf;
-            // according different address mapping, caculate DTAR register value
-            pdtar[ch] = 0;
-            pdtar[ch] |= ((chAddr[ch])>>bw) & ((0x1<<col)-1);  // col
-            pdtar[ch] |= (((chAddr[ch])>>(bw+col+((ddr_cfg_2_rbc[conf]>>2)&0x3))) & ((0x1<<row)-1)) << 12;  // row
-            if(((ddr_cfg_2_rbc[conf]>>7)&0x3)==3)
-            {
-                pdtar[ch] |= ((((chAddr[ch])>>(bw+col+row)) & ((0x1<<bank)-1))  << 28);  // bank
-            }
-            else
-            {
-                pdtar[ch] |= ((((chAddr[ch])>>(bw+col)) & 0x7) << 28);  // bank
-            }
-        }
-    }
-    ddr_print("dtar[0]=0x%x, dtar[1]=0x%x\n", pdtar[0], pdtar[1]);
-}
-
-static __sramfunc void ddr_reset_dll(uint32 ch)
-{
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-    
-    pPHY_Reg->ACDLLCR &= ~0x40000000;
-    pPHY_Reg->DATX8[0].DXDLLCR &= ~0x40000000;
-    pPHY_Reg->DATX8[1].DXDLLCR &= ~0x40000000;
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        pPHY_Reg->DATX8[2].DXDLLCR &= ~0x40000000;
-        pPHY_Reg->DATX8[3].DXDLLCR &= ~0x40000000;
-    }
-    ddr_delayus(1);
-    pPHY_Reg->ACDLLCR |= 0x40000000;
-    pPHY_Reg->DATX8[0].DXDLLCR |= 0x40000000;
-    pPHY_Reg->DATX8[1].DXDLLCR |= 0x40000000;
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x40000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x40000000;
-    }
-    ddr_delayus(1);
-}
-
-static __sramfunc void ddr_move_to_Lowpower_state(uint32 ch)
-{
-    register uint32 value;
-    register pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Low_power)
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-            case Access:
-                pDDR_Reg->SCTL = SLEEP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Low_power);
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-static __sramfunc void ddr_move_to_Access_state(uint32 ch)
-{
-    register uint32 value;
-    register pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    register pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    //set auto self-refresh idle
-    pDDR_Reg->MCFG1=(pDDR_Reg->MCFG1&0xffffff00) | DATA(ddr_sr_idle) | (1<<31);
-    dsb();
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if((value == Access)
-           || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power)))
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-                while((pPHY_Reg->PGSR & DLDONE) != DLDONE);  //wait DLL lock
-                break;
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-            case Config:
-                pDDR_Reg->SCTL = GO_STATE;
-                dsb();
-                while(!(((pDDR_Reg->STAT.b.ctl_stat) == Access)
-                      || ((pDDR_Reg->STAT.b.lp_trig == 1) && ((pDDR_Reg->STAT.b.ctl_stat) == Low_power))));
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-    /* de_hw_wakeup :enable auto sr if sr_idle != 0 */
-    DDR_HW_WAKEUP(ch,0);
-}
-
-static __sramfunc void ddr_move_to_Config_state(uint32 ch)
-{
-    register uint32 value;
-    register pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    register pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    /* hw_wakeup :disable auto sr */
-    DDR_HW_WAKEUP(ch,1);
-	dsb();
-
-    while(1)
-    {
-        value = pDDR_Reg->STAT.b.ctl_stat;
-        if(value == Config)
-        {
-            break;
-        }
-        switch(value)
-        {
-            case Low_power:
-                pDDR_Reg->SCTL = WAKEUP_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Access);
-                while((pPHY_Reg->PGSR & DLDONE) != DLDONE);  //wait DLL lock
-            case Access:
-            case Init_mem:
-                pDDR_Reg->SCTL = CFG_STATE;
-                dsb();
-                while((pDDR_Reg->STAT.b.ctl_stat) != Config);
-                break;
-            default:  //Transitional state
-                break;
-        }
-    }
-}
-
-//argbank_addrcmd_addr
-static void __sramfunc ddr_send_command(uint32 ch, uint32 rank, uint32 cmd, uint32 arg)
-{
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    
-    pDDR_Reg->MCMD = (start_cmd | (rank<<20) | arg | cmd);
-    dsb();
-    while(pDDR_Reg->MCMD & start_cmd);
-}
-
-//typeDDRcsDTT
-//0  DTT
-//!0 DTT
-static uint32 __sramfunc ddr_data_training_trigger(uint32 ch)
-{
-    uint32        cs;
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    // disable auto refresh
-    pDDR_Reg->TREFI = 0;
-    dsb();
-    if((DATA(ddr_ch[ch]).mem_type != LPDDR2)
-       && (DATA(ddr_ch[ch]).mem_type != LPDDR3))
-    {
-        // passive window
-        pPHY_Reg->PGCR |= (1<<1);
-    }
-    // clear DTDONE status
-    pPHY_Reg->PIR |= CLRSR;
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    if(DATA(ddr_ch[ch]).dtt_cs == 0)
-            pPHY_Reg->PGCR = (pPHY_Reg->PGCR & (~(0xF<<18))) | (1<<18);  //use cs0 dtt
-    else
-            pPHY_Reg->PGCR = (pPHY_Reg->PGCR & (~(0xF<<18))) | (2<<18);  //use cs1 dtt
-    // trigger DTT
-    pPHY_Reg->PIR |= INIT | QSTRN | LOCKBYP | ZCALBYP | CLRSR | ICPC;
-    return cs;
-}
-//typeDDRcsDTT
-//0  DTT
-//!0 DTT
-static uint32 __sramfunc ddr_data_training(uint32 ch, uint32 cs)
-{
-    uint32        i,byte=2,cs_msk;
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    if(DATA(ddr_ch[ch]).dtt_cs == 0){
-        cs_msk = 1;
-    }else{
-        cs_msk = 2;
-    }
-    // wait echo byte DTDONE
-    while((pPHY_Reg->DATX8[0].DXGSR[0] & cs_msk) != cs_msk);
-    while((pPHY_Reg->DATX8[1].DXGSR[0] & cs_msk) != cs_msk);
-    if(!(pDDR_Reg->PPCFG & 1))
-    {
-        while((pPHY_Reg->DATX8[2].DXGSR[0] & cs_msk) != cs_msk);
-        while((pPHY_Reg->DATX8[3].DXGSR[0] & cs_msk) != cs_msk);
-        byte=4;
-    }
-    pPHY_Reg->PGCR = (pPHY_Reg->PGCR & (~(0xF<<18))) | (cs<<18);  //restore cs
-    if(DATA(ddr_ch[ch]).dtt_cs == 0){
-        for(i=0;i<byte;i++)
-        {
-            pPHY_Reg->DATX8[i].DXDQSTR = (pPHY_Reg->DATX8[i].DXDQSTR & (~((0x7<<3)|(0x3<<14))))\
-                                          | ((pPHY_Reg->DATX8[i].DXDQSTR & 0x7)<<3)\
-                                          | (((pPHY_Reg->DATX8[i].DXDQSTR>>12) & 0x3)<<14);
-        }
-    }else{
-        for(i=0;i<byte;i++)
-        {
-            pPHY_Reg->DATX8[i].DXDQSTR = (pPHY_Reg->DATX8[i].DXDQSTR & (~((0x7<<0)|(0x3<<12))))\
-                                          | ((pPHY_Reg->DATX8[i].DXDQSTR>>3) & 0x7)\
-                                          | (((pPHY_Reg->DATX8[i].DXDQSTR>>14) & 0x3)<<12);
-        }
-    }
-    // send some auto refresh to complement the lost while DTT//1CSDTT10.7us2
-    if(cs > 1)
-    {
-        ddr_send_command(ch,cs, REF_cmd, 0);
-        ddr_send_command(ch,cs, REF_cmd, 0);
-        ddr_send_command(ch,cs, REF_cmd, 0);
-        ddr_send_command(ch,cs, REF_cmd, 0);
-    }
-    else
-    {
-        ddr_send_command(ch,cs, REF_cmd, 0);
-        ddr_send_command(ch,cs, REF_cmd, 0);
-    }
-    if((DATA(ddr_ch[ch]).mem_type != LPDDR2)
-       && (DATA(ddr_ch[ch]).mem_type != LPDDR3))
-    {
-        // active window
-        pPHY_Reg->PGCR &= ~(1<<1);
-    }
-    // resume auto refresh
-    pDDR_Reg->TREFI = DATA(ddr_reg).pctl.pctl_timing.trefi;
-
-    if(pPHY_Reg->PGSR & DTERR)
-    {
-        return (-1);
-    }
-    else
-    {
-        return 0;
-    }
-}
-
-
-static void __sramfunc ddr_set_dll_bypass(uint32 ch, uint32 freq)
-{
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-    
-    if(freq<=150)
-    {
-        pPHY_Reg->DLLGCR &= ~(1<<23);
-        pPHY_Reg->ACDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-        pPHY_Reg->PIR |= DLLBYP;
-    }
-    else if(freq<=250)
-    {
-        pPHY_Reg->DLLGCR |= (1<<23);
-        pPHY_Reg->ACDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;
-        pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-        pPHY_Reg->PIR |= DLLBYP;
-    }
-    else
-    {
-        pPHY_Reg->DLLGCR &= ~(1<<23);
-        pPHY_Reg->ACDLLCR &= ~0x80000000;
-        pPHY_Reg->DATX8[0].DXDLLCR &= ~0x80000000;
-        pPHY_Reg->DATX8[1].DXDLLCR &= ~0x80000000;
-        if(!(pDDR_Reg->PPCFG & 1))
-        {
-            pPHY_Reg->DATX8[2].DXDLLCR &= ~0x80000000;
-            pPHY_Reg->DATX8[3].DXDLLCR &= ~0x80000000;
-        }
-        pPHY_Reg->PIR &= ~DLLBYP;
-    }
-}
-
-static noinline uint32 ddr_get_parameter(uint32 nMHz)
-{
-    uint32 tmp;
-    uint32 ret = 0;
-    uint32 al;
-    uint32 bl,bl_tmp;
-    uint32 cl;
-    uint32 cwl;
-    PCTL_TIMING_T *p_pctl_timing=&(p_ddr_reg->pctl.pctl_timing);
-    PHY_TIMING_T  *p_publ_timing=&(p_ddr_reg->publ.phy_timing);
-    volatile NOC_TIMING_T  *p_noc_timing=&(p_ddr_reg->noc[0].ddrtiming);
-    volatile NOC_ACTIVATE_T  *p_noc_activate=&(p_ddr_reg->noc[0].activate);
-    uint32 ch;
-    uint32 mem_type;
-    uint32 ddr_speed_bin=DDR3_DEFAULT;
-    uint32 ddr_capability_per_die=0;
-
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(p_ddr_ch[ch]->mem_type != DRAM_MAX)
-        {
-            mem_type = p_ddr_ch[ch]->mem_type;
-            if(ddr_speed_bin == DDR3_DEFAULT)
-            {
-                ddr_speed_bin = p_ddr_ch[ch]->ddr_speed_bin;
-            }
-            else
-            {
-                ddr_speed_bin = (ddr_speed_bin > p_ddr_ch[ch]->ddr_speed_bin) ? ddr_speed_bin : p_ddr_ch[ch]->ddr_speed_bin;
-            }
-            if(ddr_capability_per_die == 0)
-            {
-                ddr_capability_per_die = p_ddr_ch[ch]->ddr_capability_per_die;
-            }
-            else
-            {
-                ddr_capability_per_die = (ddr_capability_per_die > p_ddr_ch[ch]->ddr_capability_per_die) ? ddr_capability_per_die : p_ddr_ch[ch]->ddr_capability_per_die;
-            }
-            break;
-        }
-    }
-
-    p_pctl_timing->togcnt1u = nMHz;
-    p_pctl_timing->togcnt100n = nMHz/10;
-    p_pctl_timing->tinit = 200;
-    p_pctl_timing->trsth = 500;
-
-    if(mem_type == DDR3)
-    {
-        if(ddr_speed_bin > DDR3_DEFAULT){
-            ret = -1;
-            goto out;
-        }
-
-        #define DDR3_tREFI_7_8_us    (78)  //unit 100ns
-        #define DDR3_tMRD            (4)   //tCK
-        #define DDR3_tRFC_512Mb      (90)  //ns
-        #define DDR3_tRFC_1Gb        (110) //ns
-        #define DDR3_tRFC_2Gb        (160) //ns
-        #define DDR3_tRFC_4Gb        (300) //ns
-        #define DDR3_tRFC_8Gb        (350) //ns
-        #define DDR3_tRTW            (2)   //register min valid value
-        #define DDR3_tRAS            (37)  //ns
-        #define DDR3_tRRD            (10)  //ns
-        #define DDR3_tRTP            (7)   //ns
-        #define DDR3_tWR             (15)  //ns
-        #define DDR3_tWTR            (7)   //ns
-        #define DDR3_tXP             (7)   //ns
-        #define DDR3_tXPDLL          (24)  //ns
-        #define DDR3_tZQCS           (80)  //ns
-        #define DDR3_tZQCSI          (0)   //ns
-        #define DDR3_tDQS            (1)   //tCK
-        #define DDR3_tCKSRE          (10)  //ns
-        #define DDR3_tCKE_400MHz     (7)   //ns
-        #define DDR3_tCKE_533MHz     (6)   //ns
-        #define DDR3_tMOD            (15)  //ns
-        #define DDR3_tRSTL           (100) //ns
-        #define DDR3_tZQCL           (320) //ns
-        #define DDR3_tDLLK           (512) //tCK
-
-        al = 0;
-        bl = 8;
-        if(nMHz <= 330)
-        {
-            tmp = 0;
-        }
-        else if(nMHz<=400)
-        {
-            tmp = 1;
-        }
-        else if(nMHz<=533)
-        {
-            tmp = 2;
-        }
-        else if(nMHz<=666)
-        {
-            tmp = 3;
-        }
-        else if(nMHz<=800)
-        {
-            tmp = 4;
-        }
-        else if(nMHz<=933)
-        {
-            tmp = 5;
-        }
-        else
-        {
-            tmp = 6;
-        }
-        
-        if(nMHz < 300)       //when dll bypss cl = cwl = 6;
-        {
-            cl = 6;
-            cwl = 6;
-        }
-        else
-        {
-            cl = (ddr3_cl_cwl[ddr_speed_bin][tmp] >> 4)&0xf;
-            cwl = ddr3_cl_cwl[ddr_speed_bin][tmp] & 0xf;
-        }
-        if(cl == 0)
-            ret = -4;
-        if(nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ)
-        {
-            p_publ_timing->mr[1] = DDR3_DS_40 | DDR3_Rtt_Nom_DIS;
-        }
-        else
-        {
-            p_publ_timing->mr[1] = DDR3_DS_40 | DDR3_Rtt_Nom_120;
-        }
-        p_publ_timing->mr[2] = DDR3_MR2_CWL(cwl) /* | DDR3_Rtt_WR_60 */;
-        p_publ_timing->mr[3] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 7.8us
-         */
-        p_pctl_timing->trefi = DDR3_tREFI_7_8_us;
-        /*
-         * tMRD, 4 tCK
-         */
-        p_pctl_timing->tmrd = DDR3_tMRD & 0x7;
-        p_publ_timing->dtpr0.b.tMRD = DDR3_tMRD-4;
-        /*
-         * tRFC, 90ns(512Mb),110ns(1Gb),160ns(2Gb),300ns(4Gb),350ns(8Gb)
-         */
-        if(ddr_capability_per_die <= 0x4000000)         // 512Mb 90ns
-        {
-            tmp = DDR3_tRFC_512Mb;
-        }
-        else if(ddr_capability_per_die <= 0x8000000)    // 1Gb 110ns
-        {
-            tmp = DDR3_tRFC_1Gb;
-        }
-        else if(ddr_capability_per_die <= 0x10000000)   // 2Gb 160ns
-        {
-            tmp = DDR3_tRFC_2Gb;
-        }
-        else if(ddr_capability_per_die <= 0x20000000)   // 4Gb 300ns
-        {
-            tmp = DDR3_tRFC_4Gb;
-        }
-        else    // 8Gb  350ns
-        {
-            tmp = DDR3_tRFC_8Gb;
-        }
-        p_pctl_timing->trfc = (tmp*nMHz+999)/1000;
-        p_publ_timing->dtpr1.b.tRFC = ((tmp*nMHz+999)/1000);
-        /*
-         * tXSR, =tDLLK=512 tCK
-         */
-        p_pctl_timing->texsr = DDR3_tDLLK;
-        p_publ_timing->dtpr2.b.tXS = DDR3_tDLLK;
-        /*
-         * tRP=CL
-         */
-        p_pctl_timing->trp = cl;
-        p_publ_timing->dtpr0.b.tRP = cl;
-        /*
-         * WrToMiss=WL*tCK + tWR + tRP + tRCD
-         */
-        p_noc_timing->b.WrToMiss = (cwl+((DDR3_tWR*nMHz+999)/1000)+cl+cl);
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000)&0x3F);
-        p_noc_timing->b.ActToAct = (((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000);
-        p_publ_timing->dtpr0.b.tRC = (((ddr3_tRC_tFAW[ddr_speed_bin]>>8)*nMHz+999)/1000);
-
-        p_pctl_timing->trtw = (cl+2-cwl);//DDR3_tRTW;
-        p_publ_timing->dtpr1.b.tRTW = 0;
-        p_noc_timing->b.RdToWr = (cl+2-cwl);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRAS, 37.5ns(400MHz)     37.5ns(533MHz)
-         */
-        p_pctl_timing->tras = (((DDR3_tRAS*nMHz+(nMHz>>1)+999)/1000)&0x3F);
-        p_publ_timing->dtpr0.b.tRAS = ((DDR3_tRAS*nMHz+(nMHz>>1)+999)/1000);
-        /*
-         * tRCD=CL
-         */
-        p_pctl_timing->trcd = cl;
-        p_publ_timing->dtpr0.b.tRCD = cl;
-        /*
-         * tRRD = max(4nCK, 7.5ns), DDR3-1066(1K), DDR3-1333(2K), DDR3-1600(2K)
-         *        max(4nCK, 10ns), DDR3-800(1K,2K), DDR3-1066(2K)
-         *        max(4nCK, 6ns), DDR3-1333(1K), DDR3-1600(1K)
-         *
-         */
-        tmp = ((DDR3_tRRD*nMHz+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        p_publ_timing->dtpr0.b.tRRD = tmp;
-        p_noc_activate->b.Rrd = tmp;
-        /*
-         * tRTP, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->trtp = tmp&0xF;
-        p_publ_timing->dtpr0.b.tRTP = tmp;
-        /*
-         * RdToMiss=tRTP+tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = (tmp+cl+cl-(bl>>1));
-        /*
-         * tWR, 15ns
-         */
-        tmp = ((DDR3_tWR*nMHz+999)/1000);
-        p_pctl_timing->twr = tmp&0x1F;
-        if(tmp<9)
-        {
-            tmp = tmp - 4;
-        }
-        else
-        {
-            tmp += (tmp&0x1) ? 1:0;
-            tmp = tmp>>1;
-        }
-        bl_tmp = (bl == 8) ? DDR3_BL8 : DDR3_BC4;
-        p_publ_timing->mr[0] = bl_tmp | DDR3_CL(cl) | DDR3_WR(tmp);
-
-        /*
-         * tWTR, max(4 tCK,7.5ns)
-         */
-        tmp = ((DDR3_tWTR*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 4)
-        {
-            tmp = 4;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_publ_timing->dtpr0.b.tWTR = tmp;
-        /*
-         * WrToRd=WL+tWTR
-         */
-        p_noc_timing->b.WrToRd = (tmp+cwl);
-        /*
-         * tXP, max(3 tCK, 7.5ns)(<933MHz)
-         */
-        tmp = ((DDR3_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        /*
-         * tXPDLL, max(10 tCK,24ns)
-         */
-        tmp = ((DDR3_tXPDLL*nMHz+999)/1000);
-        if(tmp < 10)
-        {
-            tmp = 10;
-        }
-        p_pctl_timing->txpdll = tmp & 0x3F;
-        p_publ_timing->dtpr2.b.tXP = tmp;
-        /*
-         * tZQCS, max(64 tCK, 80ns)
-         */
-        tmp = ((DDR3_tZQCS*nMHz+999)/1000);
-        if(tmp < 64)
-        {
-            tmp = 64;
-        }
-        p_pctl_timing->tzqcs = tmp&0x7F;
-        /*
-         * tZQCSI,
-         */
-        p_pctl_timing->tzqcsi = DDR3_tZQCSI;
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = DDR3_tDQS;
-        /*
-         * tCKSRE, max(5 tCK, 10ns)
-         */
-        tmp = ((DDR3_tCKSRE*nMHz+999)/1000);
-        if(tmp < 5)
-        {
-            tmp = 5;
-        }
-        p_pctl_timing->tcksre = tmp & 0x1F;
-        /*
-         * tCKSRX, max(5 tCK, 10ns)
-         */
-        p_pctl_timing->tcksrx = tmp & 0x1F;
-        /*
-         * tCKE, max(3 tCK,7.5ns)(400MHz) max(3 tCK,5.625ns)(533MHz)
-         */
-        if(nMHz>=533)
-        {
-            tmp = ((DDR3_tCKE_533MHz*nMHz+999)/1000);
-        }
-        else
-        {
-            tmp = ((DDR3_tCKE_400MHz*nMHz+(nMHz>>1)+999)/1000);
-        }
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tcke = tmp & 0x7;
-        /*
-         * tCKESR, =tCKE + 1tCK
-         */
-        p_pctl_timing->tckesr = (tmp+1)&0xF;
-        p_publ_timing->dtpr2.b.tCKE = tmp+1;
-        /*
-         * tMOD, max(12 tCK,15ns)
-         */
-        tmp = ((DDR3_tMOD*nMHz+999)/1000);
-        if(tmp < 12)
-        {
-            tmp = 12;
-        }
-        p_pctl_timing->tmod = tmp&0x1F;
-        p_publ_timing->dtpr1.b.tMOD = (tmp-12);
-        /*
-         * tRSTL, 100ns
-         */
-        p_pctl_timing->trstl = ((DDR3_tRSTL*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCL, max(256 tCK, 320ns)
-         */
-        tmp = ((DDR3_tZQCL*nMHz+999)/1000);
-        if(tmp < 256)
-        {
-            tmp = 256;
-        }
-        p_pctl_timing->tzqcl = tmp&0x3FF;
-        /*
-         * tMRR, 0 tCK
-         */
-        p_pctl_timing->tmrr = 0;
-        /*
-         * tDPD, 0
-         */
-        p_pctl_timing->tdpd = 0;
-
-        /**************************************************
-         * PHY Timing
-         **************************************************/
-        /*
-         * tCCD, BL/2 for DDR2 and 4 for DDR3
-         */
-        p_publ_timing->dtpr0.b.tCCD = 0;
-        /*
-         * tDQSCKmax,5.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCKmax = 0;
-        /*
-         * tRTODT, 0:ODT may be turned on immediately after read post-amble
-         *         1:ODT may not be turned on until one clock after the read post-amble
-         */
-        p_publ_timing->dtpr1.b.tRTODT = 1;
-        /*
-         * tFAW,40ns(400MHz 1KB page) 37.5ns(533MHz 1KB page) 50ns(400MHz 2KB page)   50ns(533MHz 2KB page)
-         */
-        tmp = (((ddr3_tRC_tFAW[ddr_speed_bin]&0x0ff)*nMHz+999)/1000);
-        p_publ_timing->dtpr1.b.tFAW = tmp;
-        p_noc_activate->b.Fawbank = 1;
-        p_noc_activate->b.Faw = tmp;
-        /*
-         * tAOND_tAOFD
-         */
-        p_publ_timing->dtpr1.b.tAOND = 0;
-        /*
-         * tDLLK,512 tCK
-         */
-        p_publ_timing->dtpr2.b.tDLLK = DDR3_tDLLK;
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = (bl>>1);
-    }
-    else if(mem_type == LPDDR2)
-    {
-        #define LPDDR2_tREFI_3_9_us    (39)  //unit 100ns
-        #define LPDDR2_tREFI_7_8_us    (78)  //unit 100ns
-        #define LPDDR2_tMRD            (5)   //tCK
-        #define LPDDR2_tRFC_8Gb        (210)  //ns
-        #define LPDDR2_tRFC_4Gb        (130)  //ns
-        #define LPDDR2_tRPpb_4_BANK             (24)  //ns
-        #define LPDDR2_tRPab_SUB_tRPpb_4_BANK   (0)   //ns
-        #define LPDDR2_tRPpb_8_BANK             (24)  //ns
-        #define LPDDR2_tRPab_SUB_tRPpb_8_BANK   (3)   //ns
-        #define LPDDR2_tRTW          (1)   //tCK register min valid value
-        #define LPDDR2_tRAS          (42)  //ns
-        #define LPDDR2_tRCD          (24)  //ns
-        #define LPDDR2_tRRD          (10)  //ns
-        #define LPDDR2_tRTP          (7)   //ns
-        #define LPDDR2_tWR           (15)  //ns
-        #define LPDDR2_tWTR_GREAT_200MHz         (7)  //ns
-        #define LPDDR2_tWTR_LITTLE_200MHz        (10) //ns
-        #define LPDDR2_tXP           (7)  //ns
-        #define LPDDR2_tXPDLL        (0)
-        #define LPDDR2_tZQCS         (90) //ns
-        #define LPDDR2_tZQCSI        (0)
-        #define LPDDR2_tDQS          (1)
-        #define LPDDR2_tCKSRE        (1)  //tCK
-        #define LPDDR2_tCKSRX        (2)  //tCK
-        #define LPDDR2_tCKE          (3)  //tCK
-        #define LPDDR2_tMOD          (0)
-        #define LPDDR2_tRSTL         (0)
-        #define LPDDR2_tZQCL         (360)  //ns
-        #define LPDDR2_tMRR          (2)    //tCK
-        #define LPDDR2_tCKESR        (15)   //ns
-        #define LPDDR2_tDPD_US       (500)  //us
-        #define LPDDR2_tFAW_GREAT_200MHz    (50)  //ns
-        #define LPDDR2_tFAW_LITTLE_200MHz   (60)  //ns
-        #define LPDDR2_tDLLK         (2)  //tCK
-        #define LPDDR2_tDQSCK_MAX    (3)  //tCK
-        #define LPDDR2_tDQSCK_MIN    (0)  //tCK
-        #define LPDDR2_tDQSS         (1)  //tCK
-
-        uint32 trp_tmp;
-        uint32 trcd_tmp;
-        uint32 tras_tmp;
-        uint32 trtp_tmp;
-        uint32 twr_tmp;
-
-        al = 0;
-        bl = 8;
-        /*     1066 933 800 667 533 400 333
-         * RL,   8   7   6   5   4   3   3
-         * WL,   4   4   3   2   2   1   1
-         */
-        if(nMHz<=200)
-        {
-            cl = 3;
-            cwl = 1;
-            p_publ_timing->mr[2] = LPDDR2_RL3_WL1;
-        }
-        else if(nMHz<=266)
-        {
-            cl = 4;
-            cwl = 2;
-            p_publ_timing->mr[2] = LPDDR2_RL4_WL2;
-        }
-        else if(nMHz<=333)
-        {
-            cl = 5;
-            cwl = 2;
-            p_publ_timing->mr[2] = LPDDR2_RL5_WL2;
-        }
-        else if(nMHz<=400)
-        {
-            cl = 6;
-            cwl = 3;
-            p_publ_timing->mr[2] = LPDDR2_RL6_WL3;
-        }
-        else if(nMHz<=466)
-        {
-            cl = 7;
-            cwl = 4;
-            p_publ_timing->mr[2] = LPDDR2_RL7_WL4;
-        }
-        else //(nMHz<=1066)
-        {
-            cl = 8;
-            cwl = 4;
-            p_publ_timing->mr[2] = LPDDR2_RL8_WL4;
-        }
-        p_publ_timing->mr[3] = LPDDR2_DS_34;
-        p_publ_timing->mr[0] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 15.6us(<256Mb) 7.8us(256Mb-1Gb) 3.9us(2Gb-8Gb)
-         */
-        if(ddr_capability_per_die >= 0x10000000)   // 2Gb
-        {
-            p_pctl_timing->trefi = LPDDR2_tREFI_3_9_us;
-        }
-        else
-        {
-            p_pctl_timing->trefi = LPDDR2_tREFI_7_8_us;
-        }
-
-        /*
-         * tMRD, (=tMRW), 5 tCK
-         */
-        p_pctl_timing->tmrd = LPDDR2_tMRD & 0x7;
-        p_publ_timing->dtpr0.b.tMRD = 3;
-        /*
-         * tRFC, 90ns(<=512Mb) 130ns(1Gb-4Gb) 210ns(8Gb)
-         */
-        if(ddr_capability_per_die >= 0x40000000)   // 8Gb
-        {
-            p_pctl_timing->trfc = (LPDDR2_tRFC_8Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR2_tRFC_8Gb*nMHz+999)/1000);
-            /*
-             * tXSR, max(2tCK,tRFC+10ns)
-             */
-            tmp=(((LPDDR2_tRFC_8Gb+10)*nMHz+999)/1000);
-        }
-        else
-        {
-            p_pctl_timing->trfc = (LPDDR2_tRFC_4Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR2_tRFC_4Gb*nMHz+999)/1000);
-            tmp=(((LPDDR2_tRFC_4Gb+10)*nMHz+999)/1000);
-        }
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->texsr = tmp&0x3FF;
-        p_publ_timing->dtpr2.b.tXS = tmp;
-
-        /*
-         * tRP, max(3tCK, 4-bank:15ns(Fast) 18ns(Typ) 24ns(Slow), 8-bank:18ns(Fast) 21ns(Typ) 27ns(Slow))
-         */
-        //if(pPHY_Reg->DCR.b.DDR8BNK)
-        if(1)
-        {
-            trp_tmp = ((LPDDR2_tRPpb_8_BANK*nMHz+999)/1000);
-            if(trp_tmp<3)
-            {
-                trp_tmp=3;
-            }
-            p_pctl_timing->trp = ((((LPDDR2_tRPab_SUB_tRPpb_8_BANK*nMHz+999)/1000) & 0x3)<<16) | (trp_tmp&0xF);
-        }
-        else
-        {
-            trp_tmp = ((LPDDR2_tRPpb_4_BANK*nMHz+999)/1000);
-            if(trp_tmp<3)
-            {
-                trp_tmp=3;
-            }
-            p_pctl_timing->trp = (LPDDR2_tRPab_SUB_tRPpb_4_BANK<<16) | (trp_tmp&0xF);
-        }
-        p_publ_timing->dtpr0.b.tRP = trp_tmp;
-        /*
-         * tRAS, max(3tCK,42ns)
-         */
-        tras_tmp=((LPDDR2_tRAS*nMHz+999)/1000);
-        if(tras_tmp<3)
-        {
-            tras_tmp=3;
-        }
-        p_pctl_timing->tras = (tras_tmp&0x3F);
-        p_publ_timing->dtpr0.b.tRAS = tras_tmp;
-
-        /*
-         * tRCD, max(3tCK, 15ns(Fast) 18ns(Typ) 24ns(Slow))
-         */
-        trcd_tmp = ((LPDDR2_tRCD*nMHz+999)/1000);
-        if(trcd_tmp<3)
-        {
-            trcd_tmp=3;
-        }
-        p_pctl_timing->trcd = (trcd_tmp&0xF);
-        p_publ_timing->dtpr0.b.tRCD = trcd_tmp;
-
-        /*
-         * tRTP, max(2tCK, 7.5ns)
-         */
-        trtp_tmp = ((LPDDR2_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(trtp_tmp<2)
-        {
-            trtp_tmp = 2;
-        }
-        p_pctl_timing->trtp = trtp_tmp&0xF;
-        p_publ_timing->dtpr0.b.tRTP = trtp_tmp;
-
-        /*
-         * tWR, max(3tCK,15ns)
-         */
-        twr_tmp=((LPDDR2_tWR*nMHz+999)/1000);
-        if(twr_tmp<3)
-        {
-            twr_tmp=3;
-        }
-        p_pctl_timing->twr = twr_tmp&0x1F;
-        bl_tmp = (bl == 16) ? LPDDR2_BL16 : ((bl == 8) ? LPDDR2_BL8 : LPDDR2_BL4);
-        p_publ_timing->mr[1] = bl_tmp | LPDDR2_nWR(twr_tmp);
-
-        /*         
-         * WrToMiss=WL*tCK + tWR + tRP + tRCD         
-         */
-        p_noc_timing->b.WrToMiss = (cwl+twr_tmp+trp_tmp+trcd_tmp);
-        /*
-         * RdToMiss=tRTP + tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = (trtp_tmp+trp_tmp+trcd_tmp-(bl>>1));
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((tras_tmp+trp_tmp)&0x3F);
-        p_noc_timing->b.ActToAct = (tras_tmp+trp_tmp);
-        p_publ_timing->dtpr0.b.tRC = (tras_tmp+trp_tmp);
-
-        /*
-         * RdToWr=(cl+2-cwl)
-         */
-        p_pctl_timing->trtw = (cl+2-cwl);//LPDDR2_tRTW;   
-        p_publ_timing->dtpr1.b.tRTW = 0;
-        p_noc_timing->b.RdToWr = (cl+2-cwl);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRRD, max(2tCK,10ns)
-         */
-        tmp=((LPDDR2_tRRD*nMHz+999)/1000);
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        p_publ_timing->dtpr0.b.tRRD = tmp;
-        p_noc_activate->b.Rrd = tmp;
-        /*
-         * tWTR, max(2tCK, 7.5ns(533-266MHz)  10ns(200-166MHz))
-         */
-        if(nMHz > 200)
-        {
-            tmp=((LPDDR2_tWTR_GREAT_200MHz*nMHz+(nMHz>>1)+999)/1000);
-        }
-        else
-        {
-            tmp=((LPDDR2_tWTR_LITTLE_200MHz*nMHz+999)/1000);
-        }
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_publ_timing->dtpr0.b.tWTR = tmp;
-        /*
-         * WrToRd=WL+tWTR
-         */
-        p_noc_timing->b.WrToRd = (cwl+tmp);
-        /*
-         * tXP, max(2tCK,7.5ns)
-         */
-        tmp=((LPDDR2_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        p_publ_timing->dtpr2.b.tXP = tmp;
-        /*
-         * tXPDLL, 0ns
-         */
-        p_pctl_timing->txpdll = LPDDR2_tXPDLL;
-        /*
-         * tZQCS, 90ns
-         */
-        p_pctl_timing->tzqcs = ((LPDDR2_tZQCS*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCSI,
-         */
-        //if(pDDR_Reg->MCFG &= lpddr2_s4)
-        if(1)
-        {
-            p_pctl_timing->tzqcsi = LPDDR2_tZQCSI;
-        }
-        else
-        {
-            p_pctl_timing->tzqcsi = 0;
-        }
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = LPDDR2_tDQS;
-        /*
-         * tCKSRE, 1 tCK
-         */
-        p_pctl_timing->tcksre = LPDDR2_tCKSRE;
-        /*
-         * tCKSRX, 2 tCK
-         */
-        p_pctl_timing->tcksrx = LPDDR2_tCKSRX;
-        /*
-         * tCKE, 3 tCK
-         */
-        p_pctl_timing->tcke = LPDDR2_tCKE;
-        p_publ_timing->dtpr2.b.tCKE = LPDDR2_tCKE;
-        /*
-         * tMOD, 0 tCK
-         */
-        p_pctl_timing->tmod = LPDDR2_tMOD;
-        p_publ_timing->dtpr1.b.tMOD = LPDDR2_tMOD;
-        /*
-         * tRSTL, 0 tCK
-         */
-        p_pctl_timing->trstl = LPDDR2_tRSTL;
-        /*
-         * tZQCL, 360ns
-         */
-        p_pctl_timing->tzqcl = ((LPDDR2_tZQCL*nMHz+999)/1000)&0x3FF;
-        /*
-         * tMRR, 2 tCK
-         */
-        p_pctl_timing->tmrr = LPDDR2_tMRR;
-        /*
-         * tCKESR, max(3tCK,15ns)
-         */
-        tmp = ((LPDDR2_tCKESR*nMHz+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tckesr = tmp&0xF;
-        /*
-         * tDPD, 500us
-         */
-        p_pctl_timing->tdpd = LPDDR2_tDPD_US;
-
-        /**************************************************
-         * PHY Timing
-         **************************************************/
-        /*
-         * tCCD, BL/2 for DDR2 and 4 for DDR3
-         */
-        p_publ_timing->dtpr0.b.tCCD = 0;
-        /*
-         * tDQSCKmax,5.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCKmax = LPDDR2_tDQSCK_MAX;
-        /*
-         * tDQSCKmin,2.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCK = LPDDR2_tDQSCK_MIN;
-        /*
-         * tRTODT, 0:ODT may be turned on immediately after read post-amble
-         *         1:ODT may not be turned on until one clock after the read post-amble
-         */
-        p_publ_timing->dtpr1.b.tRTODT = 1;
-        /*
-         * tFAW,max(8tCK, 50ns(200-533MHz)  60ns(166MHz))
-         */
-        if(nMHz>=200)
-        {
-            tmp=((LPDDR2_tFAW_GREAT_200MHz*nMHz+999)/1000);
-        }
-        else
-        {
-            tmp=((LPDDR2_tFAW_LITTLE_200MHz*nMHz+999)/1000);
-        }
-        if(tmp<8)
-        {
-            tmp=8;
-        }
-        p_publ_timing->dtpr1.b.tFAW = tmp;        
-        p_noc_activate->b.Fawbank = 1;
-        p_noc_activate->b.Faw = tmp;
-        /*
-         * tAOND_tAOFD
-         */
-        p_publ_timing->dtpr1.b.tAOND = 0;
-        /*
-         * tDLLK,0
-         */
-        p_publ_timing->dtpr2.b.tDLLK = LPDDR2_tDLLK;
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = (bl>>1);
-    }
-    else if(mem_type == LPDDR3)
-    {
-        #define LPDDR3_tREFI_3_9_us    (39)  //unit 100ns
-        #define LPDDR3_tMRD            (10)   //tCK
-        #define LPDDR3_tRFC_8Gb        (210)  //ns
-        #define LPDDR3_tRFC_4Gb        (130)  //ns
-        #define LPDDR3_tRPpb_8_BANK             (24)  //ns
-        #define LPDDR3_tRPab_SUB_tRPpb_8_BANK   (3)   //ns
-        #define LPDDR3_tRTW          (1)   //tCK register min valid value
-        #define LPDDR3_tRAS          (42)  //ns
-        #define LPDDR3_tRCD          (24)  //ns
-        #define LPDDR3_tRRD          (10)  //ns
-        #define LPDDR3_tRTP          (7)   //ns
-        #define LPDDR3_tWR           (15)  //ns
-        #define LPDDR3_tWTR          (7)  //ns
-        #define LPDDR3_tXP           (7)  //ns
-        #define LPDDR3_tXPDLL        (0)
-        #define LPDDR3_tZQCS         (90) //ns
-        #define LPDDR3_tZQCSI        (0)
-        #define LPDDR3_tDQS          (1)
-        #define LPDDR3_tCKSRE        (2)  //tCK
-        #define LPDDR3_tCKSRX        (2)  //tCK
-        #define LPDDR3_tCKE          (3)  //tCK
-        #define LPDDR3_tMOD          (0)
-        #define LPDDR3_tRSTL         (0)
-        #define LPDDR3_tZQCL         (360)  //ns
-        #define LPDDR3_tMRR          (4)    //tCK
-        #define LPDDR3_tCKESR        (15)   //ns
-        #define LPDDR3_tDPD_US       (500)   //us
-        #define LPDDR3_tFAW          (50)  //ns
-        #define LPDDR3_tDLLK         (2)  //tCK
-        #define LPDDR3_tDQSCK_MAX    (3)  //tCK
-        #define LPDDR3_tDQSCK_MIN    (0)  //tCK
-        #define LPDDR3_tDQSS         (1)  //tCK
-
-        uint32 trp_tmp;
-        uint32 trcd_tmp;
-        uint32 tras_tmp;
-        uint32 trtp_tmp;
-        uint32 twr_tmp;
-
-        al = 0;
-        bl = 8;
-        /* Only support Write Latency Set A here
-         *     1066 933 800 733 667 600 533 400 166
-         * RL,   16  14  12  11  10  9   8   6   3
-         * WL,   8   8   6   6   6   5   4   3   1
-         */
-        if(nMHz<=166)
-        {
-            cl = 3;
-            cwl = 1;
-            p_publ_timing->mr[2] = LPDDR3_RL3_WL1;
-        }
-        else if(nMHz<=400)
-        {
-            cl = 6;
-            cwl = 3;
-            p_publ_timing->mr[2] = LPDDR3_RL6_WL3;
-        }
-        else if(nMHz<=533)
-        {
-            cl = 8;
-            cwl = 4;
-            p_publ_timing->mr[2] = LPDDR3_RL8_WL4;
-        }
-        else if(nMHz<=600)
-        {
-            cl = 9;
-            cwl = 5;
-            p_publ_timing->mr[2] = LPDDR3_RL9_WL5;
-        }
-        else if(nMHz<=667)
-        {
-            cl = 10;
-            cwl = 6;
-            p_publ_timing->mr[2] = LPDDR3_RL10_WL6;
-        }
-        else if(nMHz<=733)
-        {
-            cl = 11;
-            cwl = 6;
-            p_publ_timing->mr[2] = LPDDR3_RL11_WL6;
-        }
-        else if(nMHz<=800)
-        {
-            cl = 12;
-            cwl = 6;
-            p_publ_timing->mr[2] = LPDDR3_RL12_WL6;
-        }
-        else if(nMHz<=933)
-        {
-            cl = 14;
-            cwl = 8;
-            p_publ_timing->mr[2] = LPDDR3_RL14_WL8;
-        }
-        else //(nMHz<=1066)
-        {
-            cl = 16;
-            cwl = 8;
-            p_publ_timing->mr[2] = LPDDR3_RL16_WL8;
-        }
-        p_publ_timing->mr[3] = LPDDR3_DS_34;
-        if(nMHz <= DDR3_DDR2_ODT_DISABLE_FREQ)
-        {
-            p_publ_timing->mr11 = LPDDR3_ODT_DIS;
-        }
-        else
-        {
-            p_publ_timing->mr11 = LPDDR3_ODT_240;
-        }
-        p_publ_timing->mr[0] = 0;
-        /**************************************************
-         * PCTL Timing
-         **************************************************/
-        /*
-         * tREFI, average periodic refresh interval, 3.9us(4Gb-16Gb)
-         */
-        p_pctl_timing->trefi = LPDDR3_tREFI_3_9_us;
-
-        /*
-         * tMRD, (=tMRW), 10 tCK
-         */
-        p_pctl_timing->tmrd = LPDDR3_tMRD & 0x7;
-        p_publ_timing->dtpr0.b.tMRD = 3;  //max value
-        /*
-         * tRFC, 130ns(4Gb) 210ns(>4Gb)
-         */
-        if(ddr_capability_per_die > 0x20000000)   // >4Gb
-        {
-            p_pctl_timing->trfc = (LPDDR3_tRFC_8Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR3_tRFC_8Gb*nMHz+999)/1000);
-            /*
-             * tXSR, max(2tCK,tRFC+10ns)
-             */
-            tmp=(((LPDDR3_tRFC_8Gb+10)*nMHz+999)/1000);
-        }
-        else
-        {
-            p_pctl_timing->trfc = (LPDDR3_tRFC_4Gb*nMHz+999)/1000;
-            p_publ_timing->dtpr1.b.tRFC = ((LPDDR3_tRFC_4Gb*nMHz+999)/1000);
-            tmp=(((LPDDR3_tRFC_4Gb+10)*nMHz+999)/1000);
-        }
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->texsr = tmp&0x3FF;
-        p_publ_timing->dtpr2.b.tXS = tmp;
-
-        /*
-         * tRP, max(3tCK, 18ns(Fast) 21ns(Typ) 27ns(Slow))
-         */
-        //if(pPHY_Reg->DCR.b.DDR8BNK)
-        if(1)
-        {
-            trp_tmp = ((LPDDR3_tRPpb_8_BANK*nMHz+999)/1000);
-            if(trp_tmp<3)
-            {
-                trp_tmp=3;
-            }
-            p_pctl_timing->trp = ((((LPDDR3_tRPab_SUB_tRPpb_8_BANK*nMHz+999)/1000) & 0x3)<<16) | (trp_tmp&0xF);
-        }
-        p_publ_timing->dtpr0.b.tRP = trp_tmp;
-        /*
-         * tRAS, max(3tCK,42ns)
-         */
-        tras_tmp=((LPDDR3_tRAS*nMHz+999)/1000);
-        if(tras_tmp<3)
-        {
-            tras_tmp=3;
-        }
-        p_pctl_timing->tras = (tras_tmp&0x3F);
-        p_publ_timing->dtpr0.b.tRAS = tras_tmp;
-
-        /*
-         * tRCD, max(3tCK, 15ns(Fast) 18ns(Typ) 24ns(Slow))
-         */
-        trcd_tmp = ((LPDDR3_tRCD*nMHz+999)/1000);
-        if(trcd_tmp<3)
-        {
-            trcd_tmp=3;
-        }
-        p_pctl_timing->trcd = (trcd_tmp&0xF);
-        p_publ_timing->dtpr0.b.tRCD = trcd_tmp;
-
-        /*
-         * tRTP, max(4tCK, 7.5ns)
-         */
-        trtp_tmp = ((LPDDR3_tRTP*nMHz+(nMHz>>1)+999)/1000);
-        if(trtp_tmp<4)
-        {
-            trtp_tmp = 4;
-        }
-        p_pctl_timing->trtp = trtp_tmp&0xF;
-        p_publ_timing->dtpr0.b.tRTP = trtp_tmp;
-
-        /*
-         * tWR, max(4tCK,15ns)
-         */
-        twr_tmp=((LPDDR3_tWR*nMHz+999)/1000);
-        if(twr_tmp<4)
-        {
-            twr_tmp=4;
-        }
-        p_pctl_timing->twr = twr_tmp&0x1F;
-        bl_tmp = LPDDR3_BL8;
-        p_publ_timing->mr[1] = bl_tmp | LPDDR2_nWR(twr_tmp);
-
-        /*
-         * WrToMiss=WL*tCK + tWR + tRP + tRCD
-         */
-        p_noc_timing->b.WrToMiss = (cwl+twr_tmp+trp_tmp+trcd_tmp);
-        /*
-         * RdToMiss=tRTP + tRP + tRCD - (BL/2 * tCK)
-         */
-        p_noc_timing->b.RdToMiss = (trtp_tmp+trp_tmp+trcd_tmp-(bl>>1));
-        /*
-         * tRC=tRAS+tRP
-         */
-        p_pctl_timing->trc = ((tras_tmp+trp_tmp)&0x3F);
-        p_noc_timing->b.ActToAct = (tras_tmp+trp_tmp);
-        p_publ_timing->dtpr0.b.tRC = (tras_tmp+trp_tmp);
-
-        /*
-         * RdToWr=(cl+2-cwl)
-         */
-        p_pctl_timing->trtw = (cl+2-cwl);//LPDDR2_tRTW;
-        p_publ_timing->dtpr1.b.tRTW = 0;
-        p_noc_timing->b.RdToWr = (cl+2-cwl);
-        p_pctl_timing->tal = al;
-        p_pctl_timing->tcl = cl;
-        p_pctl_timing->tcwl = cwl;
-        /*
-         * tRRD, max(2tCK,10ns)
-         */
-        tmp=((LPDDR3_tRRD*nMHz+999)/1000);
-        if(tmp<2)
-        {
-            tmp=2;
-        }
-        p_pctl_timing->trrd = (tmp&0xF);
-        p_publ_timing->dtpr0.b.tRRD = tmp;
-        p_noc_activate->b.Rrd = tmp;
-        /*
-         * tWTR, max(4tCK, 7.5ns)
-         */
-        tmp=((LPDDR3_tWTR*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp<4)
-        {
-            tmp=4;
-        }
-        p_pctl_timing->twtr = tmp&0xF;
-        p_publ_timing->dtpr0.b.tWTR = tmp;
-        /*
-         * WrToRd=WL+tWTR
-         */
-        p_noc_timing->b.WrToRd = (cwl+tmp);
-        /*
-         * tXP, max(3tCK,7.5ns)
-         */
-        tmp=((LPDDR3_tXP*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp<3)
-        {
-            tmp=3;
-        }
-        p_pctl_timing->txp = tmp&0x7;
-        p_publ_timing->dtpr2.b.tXP = tmp;
-        /*
-         * tXPDLL, 0ns
-         */
-        p_pctl_timing->txpdll = LPDDR3_tXPDLL;
-        /*
-         * tZQCS, 90ns
-         */
-        p_pctl_timing->tzqcs = ((LPDDR3_tZQCS*nMHz+999)/1000)&0x7F;
-        /*
-         * tZQCSI,
-         */
-        p_pctl_timing->tzqcsi = LPDDR3_tZQCSI;
-        /*
-         * tDQS,
-         */
-        p_pctl_timing->tdqs = LPDDR3_tDQS;
-        /*
-         * tCKSRE=tCPDED, 2 tCK
-         */
-        p_pctl_timing->tcksre = LPDDR3_tCKSRE;
-        /*
-         * tCKSRX, 2 tCK
-         */
-        p_pctl_timing->tcksrx = LPDDR3_tCKSRX;
-        /*
-         * tCKE, (max 7.5ns,3 tCK)
-         */
-        tmp=((7*nMHz+(nMHz>>1)+999)/1000);
-        if(tmp<LPDDR3_tCKE)
-        {
-            tmp=LPDDR3_tCKE;
-        }
-        p_pctl_timing->tcke = tmp;
-        p_publ_timing->dtpr2.b.tCKE = tmp;
-        /*
-         * tMOD, 0 tCK
-         */
-        p_pctl_timing->tmod = LPDDR3_tMOD;
-        p_publ_timing->dtpr1.b.tMOD = LPDDR3_tMOD;
-        /*
-         * tRSTL, 0 tCK
-         */
-        p_pctl_timing->trstl = LPDDR3_tRSTL;
-        /*
-         * tZQCL, 360ns
-         */
-        p_pctl_timing->tzqcl = ((LPDDR3_tZQCL*nMHz+999)/1000)&0x3FF;
-        /*
-         * tMRR, 4 tCK
-         */
-        p_pctl_timing->tmrr = LPDDR3_tMRR;
-        /*
-         * tCKESR, max(3tCK,15ns)
-         */
-        tmp = ((LPDDR3_tCKESR*nMHz+999)/1000);
-        if(tmp < 3)
-        {
-            tmp = 3;
-        }
-        p_pctl_timing->tckesr = tmp&0xF;
-        /*
-         * tDPD, 500us
-         */
-        p_pctl_timing->tdpd = LPDDR3_tDPD_US;
-
-        /**************************************************
-         * PHY Timing
-         **************************************************/
-        /*
-         * tCCD, BL/2 for DDR2 and 4 for DDR3
-         */
-        p_publ_timing->dtpr0.b.tCCD = 0;
-        /*
-         * tDQSCKmax,5.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCKmax = LPDDR3_tDQSCK_MAX;
-        /*
-         * tDQSCKmin,2.5ns
-         */
-        p_publ_timing->dtpr1.b.tDQSCK = LPDDR3_tDQSCK_MIN;
-        /*
-         * tRTODT, 0:ODT may be turned on immediately after read post-amble
-         *         1:ODT may not be turned on until one clock after the read post-amble
-         */
-        p_publ_timing->dtpr1.b.tRTODT = 1;
-        /*
-         * tFAW,max(8tCK, 50ns)
-         */
-        tmp=((LPDDR3_tFAW*nMHz+999)/1000);
-        if(tmp<8)
-        {
-            tmp=8;
-        }
-        p_publ_timing->dtpr1.b.tFAW = tmp;
-        p_noc_activate->b.Fawbank = 1;
-        p_noc_activate->b.Faw = tmp;
-        /*
-         * tAOND_tAOFD
-         */
-        p_publ_timing->dtpr1.b.tAOND = 0;
-        /*
-         * tDLLK,0
-         */
-        p_publ_timing->dtpr2.b.tDLLK = LPDDR3_tDLLK;
-        /**************************************************
-         * NOC Timing
-         **************************************************/
-        p_noc_timing->b.BurstLen = (bl>>1);
-    }
-
-out:
-    return ret;
-}
-
-static uint32 __sramfunc ddr_update_timing(uint32 ch)
-{
-    uint32 i,bl_tmp=0;
-    PCTL_TIMING_T *p_pctl_timing=&(DATA(ddr_reg).pctl.pctl_timing);
-    PHY_TIMING_T  *p_publ_timing=&(DATA(ddr_reg).publ.phy_timing);
-    volatile NOC_TIMING_T  *p_noc_timing=&(DATA(ddr_reg).noc[0].ddrtiming);
-    volatile NOC_ACTIVATE_T  *p_noc_activate=&(DATA(ddr_reg).noc[0].activate);
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-    pMSCH_REG     pMSCH_Reg= DATA(ddr_ch[ch]).pMSCH_Reg;
-
-    FUNC(ddr_copy)((uint64_t *)&(pDDR_Reg->TOGCNT1U), (uint64_t*)&(p_pctl_timing->togcnt1u), 17);
-    pPHY_Reg->DTPR[0] = p_publ_timing->dtpr0.d32;
-    pPHY_Reg->DTPR[1] = p_publ_timing->dtpr1.d32;
-    pPHY_Reg->DTPR[2] = p_publ_timing->dtpr2.d32;
-    pMSCH_Reg->ddrtiming.d32 = (pMSCH_Reg->ddrtiming.b.BwRatio) | p_noc_timing->d32;
-    pMSCH_Reg->activate.d32 = p_noc_activate->d32;
-    // Update PCTL BL
-    if(DATA(ddr_ch[ch]).mem_type == DDR3)
-    {
-        bl_tmp = ((p_publ_timing->mr[0] & 0x3) == DDR3_BL8) ? ddr2_ddr3_bl_8 : ddr2_ddr3_bl_4;
-        pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~(0x1|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | bl_tmp | tfaw_cfg(5)|pd_exit_slow|pd_type(1);
-        if(DATA(ddr_freq) <= DDR3_DDR2_DLL_DISABLE_FREQ)
-        {
-            pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-3;
-        }
-        else
-        {
-            pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-2;
-        }
-        pDDR_Reg->DFITPHYWRLAT   = pDDR_Reg->TCWL-1;
-    }    
-    else if((DATA(ddr_ch[ch]).mem_type == LPDDR2)||(DATA(ddr_ch[ch]).mem_type == LPDDR3))    
-    {
-        if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL8)
-        {
-            bl_tmp = mddr_lpddr2_bl_8;
-        }
-        else if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL4)
-        {
-            bl_tmp = mddr_lpddr2_bl_4;
-        }
-        else //if(((p_publ_timing->mr[1]) & 0x7) == LPDDR2_BL16)
-        {
-            bl_tmp = mddr_lpddr2_bl_16;
-        }        
-        if((DATA(ddr_freq)>=200)||(DATA(ddr_ch[ch]).mem_type == LPDDR3))        
-        {
-            pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~((0x3<<20)|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | bl_tmp | tfaw_cfg(5)|pd_exit_fast|pd_type(1);
-        }
-        else
-        {
-            pDDR_Reg->MCFG = (pDDR_Reg->MCFG & (~((0x3<<20)|(0x3<<18)|(0x1<<17)|(0x1<<16)))) | bl_tmp | tfaw_cfg(6)|pd_exit_fast|pd_type(1);
-        }
-        i = ((pPHY_Reg->DTPR[1] >> 27) & 0x7) - ((pPHY_Reg->DTPR[1] >> 24) & 0x7);
-        pPHY_Reg->DSGCR = (pPHY_Reg->DSGCR & (~(0x3F<<5))) | (i<<5) | (i<<8);  //tDQSCKmax-tDQSCK
-        pDDR_Reg->DFITRDDATAEN   = pDDR_Reg->TCL-1;
-        pDDR_Reg->DFITPHYWRLAT   = pDDR_Reg->TCWL;
-    }
-
-    return 0;
-}
-
-static uint32 __sramfunc ddr_update_mr(uint32 ch)
-{
-    PHY_TIMING_T  *p_publ_timing=&(DATA(ddr_reg).publ.phy_timing);
-    uint32         cs,dll_off;
-    pDDRPHY_REG_T  pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    dll_off = (pPHY_Reg->MR[1] & DDR3_DLL_DISABLE) ? 1:0;
-    FUNC(ddr_copy)((uint64_t *)&(pPHY_Reg->MR[0]), (uint64_t*)&(p_publ_timing->mr[0]), 2);
-    if(DATA(ddr_ch[ch]).mem_type == DDR3)
-    {
-        ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x2) | cmd_addr((p_publ_timing->mr[2])));
-        if(DATA(ddr_freq)>DDR3_DDR2_DLL_DISABLE_FREQ)
-        {
-            if(dll_off)  // off -> on
-            {
-                ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[1])));  //DLL enable
-                ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x0) | cmd_addr(((p_publ_timing->mr[0]))| DDR3_DLL_RESET));  //DLL reset
-                ddr_delayus(1);  //at least 200 DDR cycle
-                ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-            }
-            else // on -> on
-            {
-                ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[1])));
-                ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-            }
-        }
-        else
-        {
-            pPHY_Reg->MR[1] = (((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE);
-            ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x1) | cmd_addr(((p_publ_timing->mr[1])) | DDR3_DLL_DISABLE));  //DLL disable
-            ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-        }
-    }    
-    else if((DATA(ddr_ch[ch]).mem_type == LPDDR2)||(DATA(ddr_ch[ch]).mem_type == LPDDR3))    
-    {
-        ddr_send_command(ch,cs, MRS_cmd, lpddr2_ma(0x1) | lpddr2_op((p_publ_timing->mr[1])));
-        ddr_send_command(ch,cs, MRS_cmd, lpddr2_ma(0x2) | lpddr2_op((p_publ_timing->mr[2])));
-        ddr_send_command(ch,cs, MRS_cmd, lpddr2_ma(0x3) | lpddr2_op((p_publ_timing->mr[3])));        
-        if(DATA(ddr_ch[ch]).mem_type == LPDDR3)
-        {
-            ddr_send_command(ch,cs, MRS_cmd, lpddr2_ma(11) | lpddr2_op((p_publ_timing->mr11)));
-        }
-    }
-    else //mDDR
-    {
-        ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x0) | cmd_addr((p_publ_timing->mr[0])));
-        ddr_send_command(ch,cs, MRS_cmd, bank_addr(0x1) | cmd_addr((p_publ_timing->mr[2]))); //mr[2] is mDDR MR1
-    }
-    return 0;
-}
-
-static void __sramfunc ddr_update_odt(uint32 ch)
-{
-    uint32        cs,tmp;
-    pDDR_REG_T    pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-    //adjust DRV and ODT
-    if((DATA(ddr_ch[ch]).mem_type == DDR3) || (DATA(ddr_ch[ch]).mem_type == LPDDR3))
-    {
-        if(DATA(ddr_freq) <= DDR3_DDR2_ODT_DISABLE_FREQ)
-        {
-            pPHY_Reg->DATX8[0].DXGCR &= ~(0x3<<9);  //dynamic RTT disable
-            pPHY_Reg->DATX8[1].DXGCR &= ~(0x3<<9);
-            if(!(pDDR_Reg->PPCFG & 1))
-            {
-                pPHY_Reg->DATX8[2].DXGCR &= ~(0x3<<9);
-                pPHY_Reg->DATX8[3].DXGCR &= ~(0x3<<9);
-            }
-        }
-        else
-        {
-            pPHY_Reg->DATX8[0].DXGCR |= (0x3<<9);  //dynamic RTT enable
-            pPHY_Reg->DATX8[1].DXGCR |= (0x3<<9);
-            if(!(pDDR_Reg->PPCFG & 1))
-            {
-                pPHY_Reg->DATX8[2].DXGCR |= (0x3<<9);
-                pPHY_Reg->DATX8[3].DXGCR |= (0x3<<9);
-            }
-        }
-    }
-    else
-    {
-        pPHY_Reg->DATX8[0].DXGCR &= ~(0x3<<9);  //dynamic RTT disable
-        pPHY_Reg->DATX8[1].DXGCR &= ~(0x3<<9);
-        if(!(pDDR_Reg->PPCFG & 1))
-        {
-            pPHY_Reg->DATX8[2].DXGCR &= ~(0x3<<9);
-            pPHY_Reg->DATX8[3].DXGCR &= ~(0x3<<9);
-        }
-    }
-    if(DATA(ddr_ch[ch]).mem_type == LPDDR2)
-    {
-        tmp = GET_LPDDR2_DS_ODT();  //DS=34ohm,ODT=171ohm
-    }
-    else if(DATA(ddr_ch[ch]).mem_type == LPDDR3)
-    {
-        tmp = GET_LPDDR3_DS_ODT();  //DS=34ohm,ODT=171ohm
-    }
-    else
-    {
-        tmp = GET_DDR3_DS_ODT();  //DS=34ohm,ODT=171ohm
-    }
-    cs = ((pPHY_Reg->PGCR>>18) & 0xF);
-    if(cs > 1)
-    {
-        pPHY_Reg->ZQ1CR[0] = tmp;
-        dsb();
-    }
-    pPHY_Reg->ZQ0CR[0] = tmp;
-    dsb();
-}
-
-static void __sramfunc ddr_selfrefresh_enter(uint32 nMHz)
-{
-    uint32 ch;
-    pDDR_REG_T    pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg;
-
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-        pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-
-        if(DATA(ddr_ch[ch]).mem_type != DRAM_MAX)
-        {
-            ddr_move_to_Lowpower_state(ch);
-            pDDR_Reg->TZQCSI = 0;
-        }
-    }
-}
-
-#if defined(CONFIG_ARCH_RK3066B)
-static __sramdata uint32 data8_dqstr[25][4];
-static __sramdata uint32 min_ddr_freq,dqstr_flag=false;
-
-int ddr_get_datatraing_value_3168(bool end_flag,uint32 dqstr_value,uint32 min_freq)
-{
-    if(end_flag == true)
-    {
-        dqstr_flag = true;    //complete learn data training value flag
-        min_ddr_freq = min_freq;
-        return 0;
-    }
-
-    data8_dqstr[dqstr_value][0]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][1]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][2]=pPHY_Reg->DATX8[0].DXDQSTR;
-    data8_dqstr[dqstr_value][3]=pPHY_Reg->DATX8[0].DXDQSTR;
-
-    ddr_print("training %luMhz[%d]:0x%x-0x%x-0x%x-0x%x\n",
-        clk_get_rate(clk_get(NULL, "ddr"))/1000000,dqstr_value,data8_dqstr[dqstr_value][0],data8_dqstr[dqstr_value][1],
-        data8_dqstr[dqstr_value][2],data8_dqstr[dqstr_value][3]);
-    return 0;
-}
-
-static void __sramfunc ddr_set_pll_enter_3168(uint32 freq_slew)
-{
-    uint32 value_1u,value_100n;
-    ddr_move_to_Config_state();
-
-    if(freq_slew == 1)
-    {
-        value_100n = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        value_1u = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt1u = pDDR_Reg->TOGCNT1U;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt100n = pDDR_Reg->TOGCNT100N;
-        ddr_update_timing();
-        ddr_update_mr();
-        DATA(ddr_reg).pctl.pctl_timing.togcnt100n = value_100n;
-        DATA(ddr_reg).pctl.pctl_timing.togcnt1u = value_1u;
-    }
-    else
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-    }
-
-    pDDR_Reg->TZQCSI = 0;
-    ddr_move_to_Lowpower_state();
-
-    ddr_set_dll_bypass(0);  //dll bypass
-    SET_DDRPHY_CLKGATE(ch,1);  //disable DDR PHY clock
-    dsb();
-}
-
-void __sramlocalfunc ddr_set_pll_exit_3168(uint32 freq_slew,uint32 dqstr_value)
-{
-    SET_DDRPHY_CLKGATE(ch,0);  //enable DDR PHY clock
-    dsb();
-    ddr_set_dll_bypass(DATA(ddr_freq));
-    ddr_reset_dll();
-
-    if(dqstr_flag==true)
-    {
-        pPHY_Reg->DATX8[0].DXDQSTR=data8_dqstr[dqstr_value][0];
-        pPHY_Reg->DATX8[1].DXDQSTR=data8_dqstr[dqstr_value][1];
-        pPHY_Reg->DATX8[2].DXDQSTR=data8_dqstr[dqstr_value][2];
-        pPHY_Reg->DATX8[3].DXDQSTR=data8_dqstr[dqstr_value][3];
-    }
-
-    ddr_update_odt();
-    ddr_move_to_Config_state();
-    if(freq_slew == 1)
-    {
-        pDDR_Reg->TOGCNT100N = DATA(ddr_reg).pctl.pctl_timing.togcnt100n;
-        pDDR_Reg->TOGCNT1U = DATA(ddr_reg).pctl.pctl_timing.togcnt1u;
-        pDDR_Reg->TZQCSI = DATA(ddr_reg).pctl.pctl_timing.tzqcsi;
-    }
-    else
-    {
-        ddr_update_timing();
-        ddr_update_mr();
-    }
-    ddr_data_training();
-    ddr_move_to_Access_state();
-}
-#endif
-
-static void __sramfunc ddr_chb_update_timing_odt(void)
-{
-    ddr_set_dll_bypass(1,0); //always use dll bypass
-    ddr_update_timing(1);
-    ddr_update_odt(1);
-}
-
-/* Make sure ddr_SRE_2_SRX paramter less than 4 */
-static void __sramfunc ddr_SRE_2_SRX(uint32 freq, uint32 freq_slew,uint32 dqstr_value)
-{
-    uint32 n,ch;
-    uint32 cs[CH_MAX];
-    
-    /** 2. ddr enter self-refresh mode or precharge power-down mode */
-    idle_port();
-#if defined(CONFIG_ARCH_RK3066B)
-    ddr_set_pll_enter_3168(freq_slew);
-#else
-    ddr_selfrefresh_enter(freq);
-#endif
-
-    /** 3. change frequence  */
-    FUNC(ddr_set_pll)(freq,1);
-    DATA(ddr_freq) = freq;
-
-    /** 5. Issues a Mode Exit command   */
-#if defined(CONFIG_ARCH_RK3066B)
-    ddr_set_pll_exit_3168(freq_slew,dqstr_value);
-#else
-    //ddr_selfrefresh_exit();
-    if(DATA(ddr_ch[1]).mem_type != DRAM_MAX)
-    {
-        ddr_chb_update_timing_odt();
-    }
-    ddr_set_dll_bypass(0,0); //always use dll bypass
-    ddr_update_timing(0);
-    ddr_update_odt(0);
-    FUNC(ddr_set_pll)(freq,2);
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(DATA(ddr_ch[ch]).mem_type != DRAM_MAX)
-        {
-            ddr_set_dll_bypass(ch,DATA(ddr_freq));
-            ddr_reset_dll(ch);
-            //ddr_delayus(10);   //wait DLL lock
-
-            ddr_move_to_Config_state(ch);
-            ddr_update_mr(ch);
-            cs[ch] = ddr_data_training_trigger(ch);
-        }
-    }
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(DATA(ddr_ch[ch]).mem_type != DRAM_MAX)
-        {
-            n = ddr_data_training(ch,cs[ch]);
-            ddr_move_to_Access_state(ch);
-            if(n!=0)
-            {
-                sram_printascii("DTT failed!\n");
-            }
-        }
-    }
-#endif
-    deidle_port();
-    dsb();
-}
-
-struct ddr_change_freq_sram_param {
-    uint32 arm_freq;
-    uint32 freq;
-    uint32 freq_slew;
-    uint32 dqstr_value;
-};
-
-void PIE_FUNC(ddr_change_freq_sram)(void *arg)
-{
-    struct ddr_change_freq_sram_param *param = arg;
-    loops_per_us = LPJ_100MHZ * param->arm_freq / 1000000;
-    /* Make sure ddr_SRE_2_SRX paramter less than 4 */
-    ddr_SRE_2_SRX(param->freq, param->freq_slew, param->dqstr_value);
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_change_freq_sram));
-
-typedef struct freq_tag{
-    uint32_t nMHz;
-    struct ddr_freq_t *p_ddr_freq_t;
-}freq_t;
-
-static noinline uint32 ddr_change_freq_sram(void *arg)
-{
-    uint32 freq;
-    uint32 freq_slew=0;
-    uint32 dqstr_value=0;
-    unsigned long flags;
-    struct ddr_change_freq_sram_param param;
-    volatile uint32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-    uint32 i;
-    uint32 gpllvaluel;
-    freq_t *p_freq_t=(freq_t *)arg;    
-    uint32 nMHz=p_freq_t->nMHz;
-	static struct rk_screen screen;
-	static int dclk_div, down_dclk_div;
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-    struct ddr_freq_t *p_ddr_freq_t=p_freq_t->p_ddr_freq_t;
-#endif
-
-#if defined(CONFIG_ARCH_RK3066B)
-    if(dqstr_flag==true)
-    {
-        dqstr_value=((nMHz-min_ddr_freq+1)/25 + 1) /2;
-        freq_slew = (nMHz>ddr_freq)? 1 : 0;
-    }
-#endif
-	if (!screen.mode.pixclock) {
-		rk_fb_get_prmry_screen(&screen);
-		if (screen.lcdc_id == 0)
-			dclk_div = (cru_readl(RK3288_CRU_CLKSELS_CON(27)) >> 8) & 0xff;
-		else if (screen.lcdc_id == 1)
-			dclk_div = (cru_readl(RK3288_CRU_CLKSELS_CON(29)) >> 8) & 0xff;
-		down_dclk_div = 64*(dclk_div+1)-1;
-	}
-    param.arm_freq = ddr_get_pll_freq(APLL);
-    gpllvaluel = ddr_get_pll_freq(GPLL);
-    if((200 < gpllvaluel) ||( gpllvaluel <1600))      //GPLL:200MHz~1600MHz
-    {
-        if( gpllvaluel > 800)     //800-1600MHz  /4:200MHz-400MHz
-        {
-            *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_select_gpll_div)) = 4;
-        }
-        else if( gpllvaluel > 400)    //400-800MHz  /2:200MHz-400MHz
-        {
-            *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_select_gpll_div)) = 2;
-        }
-        else        //200-400MHz  /1:200MHz-400MHz
-        {
-            *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_select_gpll_div)) = 1;
-        }
-    }
-    else
-    {
-        ddr_print("GPLL frequency = %dMHz,Not suitable for ddr_clock \n",gpllvaluel);
-    }
-    freq=p_ddr_set_pll(nMHz,0);
-
-    ddr_get_parameter(freq);
-
-    /** 1. Make sure there is no host access */
-    local_irq_save(flags);
-    local_fiq_disable();
-    flush_tlb_all();
-    isb();
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-    if(p_ddr_freq_t->screen_ft_us > 0)
-    {
-        p_ddr_freq_t->t1 = cpu_clock(0);
-        p_ddr_freq_t->t2 = (uint32)(p_ddr_freq_t->t1 - p_ddr_freq_t->t0);   //ns
-
-        //if test_count exceed maximum test times,ddr_freq_t.screen_ft_us == 0xfefefefe by ddr_freq.c
-        if( (p_ddr_freq_t->t2 > p_ddr_freq_t->screen_ft_us*1000) && (p_ddr_freq_t->screen_ft_us != 0xfefefefe))
-        {
-            freq = 0;
-            goto end;
-        }
-        else
-        {
-	     rk_fb_poll_wait_frame_complete();
-        }
-    }
-#endif
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-
-    for(i=0;i<CH_MAX;i++)
-    {
-        if(p_ddr_ch[i]->mem_type != DRAM_MAX)
-        {
-            n= p_ddr_ch[i]->pDDR_Reg->SCFG.d32;
-            n= p_ddr_ch[i]->pPHY_Reg->RIDR;
-            n= p_ddr_ch[i]->pMSCH_Reg->ddrconf;
-        }
-    }
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= READ_GRF_REG();
-    dsb();
-
-    param.freq = freq;
-    param.freq_slew = freq_slew;
-    param.dqstr_value = dqstr_value;
-	rk_fb_set_prmry_screen_status(SCREEN_PREPARE_DDR_CHANGE);
-	if (screen.lcdc_id == 0)
-		cru_writel(0 | CRU_W_MSK_SETBITS(down_dclk_div, 8, 0xff),
-			   RK3288_CRU_CLKSELS_CON(27));
-	else if (screen.lcdc_id == 1)
-		cru_writel(0 | CRU_W_MSK_SETBITS(down_dclk_div, 8, 0xff),
-			   RK3288_CRU_CLKSELS_CON(29));
-
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_change_freq_sram)),
-                    &param,
-                    rockchip_sram_stack-(NR_CPUS-1)*PAUSE_CPU_STACK_SIZE);
-
-	if (screen.lcdc_id == 0)
-		cru_writel(0 | CRU_W_MSK_SETBITS(dclk_div, 8, 0xff),
-		RK3288_CRU_CLKSELS_CON(27));
-	else if (screen.lcdc_id == 1)
-		cru_writel(0 | CRU_W_MSK_SETBITS(dclk_div, 8, 0xff),
-		RK3288_CRU_CLKSELS_CON(29));
-	rk_fb_set_prmry_screen_status(SCREEN_UNPREPARE_DDR_CHANGE);
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-end:
-#endif
-    local_fiq_enable();
-    local_irq_restore(flags);
-    return freq;
-}
-
-#if defined(ENABLE_DDR_CLCOK_GPLL_PATH)
-static uint32 ddr_change_freq_gpll_dpll(uint32 nMHz)
-{
-    uint32 gpll_freq,gpll_div;
-    struct ddr_freq_t ddr_freq_t;
-    ddr_freq_t.screen_ft_us = 0;
-
-    if(true == ddr_rk3188_dpll_is_good)
-    {
-        gpllvaluel = ddr_get_pll_freq(GPLL);
-
-        if((200 < gpllvaluel) ||( gpllvaluel <1600))      //GPLL:200MHz~1600MHz
-        {
-            gpll_div = (gpllvaluel+nMHz-1)/nMHz;
-            if( gpllvaluel > 800)     //800-1600MHz  /4:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel/4;
-                gpll_div = 4;
-            }
-            else if( gpllvaluel > 400)    //400-800MHz  /2:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel/2;
-                gpll_div = 2;
-            }
-            else        //200-400MHz  /1:200MHz-400MHz
-            {
-                gpll_freq = gpllvaluel;
-                gpll_div = 1;
-            }
-
-            *p_ddr_select_gpll_div=gpll_div;    //select GPLL
-            ddr_change_freq_sram(gpll_freq,ddr_freq_t);
-            *p_ddr_select_gpll_div=0;
-
-            p_ddr_set_pll(nMHz,0); //count DPLL
-            p_ddr_set_pll(nMHz,2); //lock DPLL only,but not select DPLL
-        }
-        else
-        {
-            ddr_print("GPLL frequency = %dMHz,Not suitable for ddr_clock \n",gpllvaluel);
-        }
-    }
-
-    return ddr_change_freq_sram(nMHz,ddr_freq_t);
-
-}
-#endif
-
-bool DEFINE_PIE_DATA(cpu_pause[NR_CPUS]);
-volatile bool *DATA(p_cpu_pause);
-static inline bool is_cpu0_paused(unsigned int cpu) { smp_rmb(); return DATA(cpu_pause)[0]; }
-static inline void set_cpuX_paused(unsigned int cpu, bool pause) { DATA(cpu_pause)[cpu] = pause; smp_wmb(); }
-static inline bool is_cpuX_paused(unsigned int cpu) { smp_rmb(); return DATA(p_cpu_pause)[cpu]; }
-static inline void set_cpu0_paused(bool pause) { DATA(p_cpu_pause)[0] = pause; smp_wmb();}
-
-/* Do not use stack, safe on SMP */
-void PIE_FUNC(_pause_cpu)(void *arg)
-{       
-    unsigned int cpu = (unsigned int)arg;
-    
-    set_cpuX_paused(cpu, true);
-    while (is_cpu0_paused(cpu));
-    set_cpuX_paused(cpu, false);
-}
-
-static void pause_cpu(void *info)
-{
-    unsigned int cpu = raw_smp_processor_id();
-
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(_pause_cpu)),
-            (void *)cpu,
-            rockchip_sram_stack-(cpu-1)*PAUSE_CPU_STACK_SIZE);
-}
-
-static void wait_cpu(void *info)
-{
-}
-
-static int call_with_single_cpu(u32 (*fn)(void *arg), void *arg)
-{
-	s64 now_ns, timeout_ns;
-	unsigned int cpu;
-	unsigned int this_cpu = smp_processor_id();
-	int ret = 0;
-
-	cpu_maps_update_begin();
-	local_bh_disable();
-
-	/* It should take much less than 1s to pause the cpus. It typically
-	* takes around 20us. */
-	timeout_ns = ktime_to_ns(ktime_add_ns(ktime_get(), NSEC_PER_SEC));
-	now_ns = ktime_to_ns(ktime_get());
-	set_cpu0_paused(true);
-	smp_call_function((smp_call_func_t)pause_cpu, NULL, 0);
-	for_each_online_cpu(cpu) {
-		if (cpu == this_cpu)
-			continue;
-		while (!is_cpuX_paused(cpu) && (now_ns < timeout_ns))
-			now_ns = ktime_to_ns(ktime_get());
-		if (now_ns >= timeout_ns) {
-			pr_err("pause cpu %d timeout\n", cpu);
-			ret = -EPERM;
-			goto out;
-		}
-	}
-	ret = fn(arg);
-out:
-	set_cpu0_paused(false);
-	local_bh_enable();
-	smp_call_function(wait_cpu, NULL, true);
-	cpu_maps_update_done();
-
-	return ret;
-}
-
-void PIE_FUNC(ddr_adjust_config)(void *arg)
-{
-    uint32 value[CH_MAX];
-    uint32 ch;
-    pDDR_REG_T    pDDR_Reg;
-    pDDRPHY_REG_T pPHY_Reg;
-
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(DATA(ddr_ch[ch]).mem_type != DRAM_MAX)
-        {
-            value[ch] = ((uint32 *)arg)[ch];
-            pDDR_Reg = DATA(ddr_ch[ch]).pDDR_Reg;
-            pPHY_Reg = DATA(ddr_ch[ch]).pPHY_Reg;
-            
-            //enter config state
-            ddr_move_to_Config_state(ch);
-
-            //set data training address
-            pPHY_Reg->DTAR = value[ch];
-
-            //set auto power down idle
-            pDDR_Reg->MCFG=(pDDR_Reg->MCFG&0xffff00ff)|(PD_IDLE<<8);
-
-            //CKDV=00
-            pPHY_Reg->PGCR &= ~(0x3<<12);
-
-            //enable the hardware low-power interface
-            pDDR_Reg->SCFG.b.hw_low_power_en = 1;
-
-            if(pDDR_Reg->PPCFG & 1)
-            {
-                pPHY_Reg->DATX8[2].DXGCR &= ~(1);          //disable byte
-                pPHY_Reg->DATX8[3].DXGCR &= ~(1);
-                pPHY_Reg->DATX8[2].DXDLLCR |= 0x80000000;  //disable DLL
-                pPHY_Reg->DATX8[3].DXDLLCR |= 0x80000000;
-            }
-
-            ddr_update_odt(ch);
-
-            //enter access state
-            ddr_move_to_Access_state(ch);
-        }
-    }
-}
-EXPORT_PIE_SYMBOL(FUNC(ddr_adjust_config));
-
-static uint32 _ddr_adjust_config(void *dtar)
-{
-    uint32 i;
-    unsigned long flags;
-    volatile uint32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-    
-     /** 1. Make sure there is no host access */
-    local_irq_save(flags);
-    local_fiq_disable();
-    flush_tlb_all();
-    isb();
-
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-    for(i=0;i<CH_MAX;i++)
-    {
-        if(p_ddr_ch[i]->mem_type != DRAM_MAX)
-        {
-            n= p_ddr_ch[i]->pDDR_Reg->SCFG.d32;
-            n= p_ddr_ch[i]->pPHY_Reg->RIDR;
-            n= p_ddr_ch[i]->pMSCH_Reg->ddrconf;
-        }
-    }
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= READ_GRF_REG();
-    dsb();
-
-    call_with_stack(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_adjust_config)),
-                    (void *)dtar,
-                    rockchip_sram_stack-(NR_CPUS-1)*PAUSE_CPU_STACK_SIZE);
-    local_fiq_enable();
-    local_irq_restore(flags);
-    return 0;
-}
-
-static void ddr_adjust_config(void)
-{
-    uint32 dtar[CH_MAX];
-    uint32 i;
-
-    //get data training address before idle port
-    ddr_get_datatraing_addr(dtar);
-
-    call_with_single_cpu(&_ddr_adjust_config, (void*)dtar);
-    //_ddr_adjust_config(dtar);
-    //disable unused channel
-    for(i=0;i<CH_MAX;i++)
-    {
-        if(p_ddr_ch[i]->mem_type != DRAM_MAX)
-        {
-            //FIXME
-        }
-    }
-}
-
-static int __ddr_change_freq(uint32_t nMHz, struct ddr_freq_t ddr_freq_t)
-{
-    freq_t freq;
-    int ret = 0;
-
-    freq.nMHz = nMHz;
-    freq.p_ddr_freq_t = &ddr_freq_t;
-    ret = call_with_single_cpu(&ddr_change_freq_sram, 
-                               (void*)&freq);
-
-    return ret;
-}
-
-static int _ddr_change_freq(uint32 nMHz)
-{
-	struct ddr_freq_t ddr_freq_t;
-        #if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	unsigned long remain_t, vblank_t, pass_t;
-	static unsigned long reserve_t = 800;//us
-	unsigned long long tmp;
-	int test_count=0;
-        #endif
-        int ret;
-
-	memset(&ddr_freq_t, 0x00, sizeof(ddr_freq_t));
-
-#if defined (DDR_CHANGE_FREQ_IN_LCDC_VSYNC)
-	do
-	{
-		ddr_freq_t.screen_ft_us = rk_fb_get_prmry_screen_ft();
-		ddr_freq_t.t0 = rk_fb_get_prmry_screen_framedone_t();
-		if (!ddr_freq_t.screen_ft_us)
-			return __ddr_change_freq(nMHz, ddr_freq_t);
-
-		tmp = cpu_clock(0) - ddr_freq_t.t0;
-		do_div(tmp, 1000);
-		pass_t = tmp;
-		//lost frame interrupt
-		while (pass_t > ddr_freq_t.screen_ft_us){
-			int n = pass_t/ddr_freq_t.screen_ft_us;
-
-			//printk("lost frame int, pass_t:%lu\n", pass_t);
-			pass_t -= n*ddr_freq_t.screen_ft_us;
-			ddr_freq_t.t0 += n*ddr_freq_t.screen_ft_us*1000;
-		}
-
-		remain_t = ddr_freq_t.screen_ft_us - pass_t;
-		if (remain_t < reserve_t) {
-			//printk("remain_t(%lu) < reserve_t(%lu)\n", remain_t, reserve_t);
-			vblank_t = rk_fb_get_prmry_screen_vbt();
-			usleep_range(remain_t+vblank_t, remain_t+vblank_t);
-			continue;
-		}
-
-		//test 10 times
-		test_count++;
-                if(test_count > 10)
-                {
-			ddr_freq_t.screen_ft_us = 0xfefefefe;
-                }
-		//printk("ft:%lu, pass_t:%lu, remaint_t:%lu, reservet_t:%lu\n",
-		//	ddr_freq_t.screen_ft_us, (unsigned long)pass_t, remain_t, reserve_t);
-		usleep_range(remain_t-reserve_t, remain_t-reserve_t);
-		flush_tlb_all();
-
-		ret = __ddr_change_freq(nMHz, ddr_freq_t);
-		if (ret) {
-			reserve_t = 800;
-			return ret;
-		} else {
-			if (reserve_t < 3000)
-				reserve_t += 200;
-		}
-	}while(1);
-#else
-	ret = __ddr_change_freq(nMHz, ddr_freq_t);
-#endif
-
-	return ret;
-}
-
-static long _ddr_round_rate(uint32 nMHz)
-{
-	return p_ddr_set_pll(nMHz, 0);
-}
-
-static void _ddr_set_auto_self_refresh(bool en)
-{
-    //set auto self-refresh idle
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = en ? SR_IDLE : 0;
-}
-
-#define PERI_ACLK_DIV_MASK 0x1f
-#define PERI_ACLK_DIV_OFF 0
-
-#define PERI_HCLK_DIV_MASK 0x3
-#define PERI_HCLK_DIV_OFF 8
-
-#define PERI_PCLK_DIV_MASK 0x3
-#define PERI_PCLK_DIV_OFF 12
-#if 0
-static __sramdata u32 cru_sel32_sram;
-static void __sramfunc ddr_suspend(void)
-{
-    u32 i;
-    volatile u32 n;
-    volatile unsigned int * temp=(volatile unsigned int *)SRAM_CODE_OFFSET;
-    int pll_id;
-
-	pll_id=GET_DDR_PLL_SRC();
-    /** 1. Make sure there is no host access */
-    flush_cache_all();
-    outer_flush_all();
-    //flush_tlb_all();
-
-    for(i=0;i<SRAM_SIZE/4096;i++)
-    {
-        n=temp[1024*i];
-        barrier();
-    }
-
-    n= pDDR_Reg->SCFG.d32;
-    n= pPHY_Reg->RIDR;
-    n= pCRU_Reg->CRU_PLL_CON[0][0];
-    n= pPMU_Reg->PMU_WAKEUP_CFG[0];
-    n= *(volatile uint32_t *)SysSrv_DdrConf;
-    n= READ_GRF_REG();
-    dsb();
-
-    ddr_selfrefresh_enter(0);
-
-    SET_PLL_MODE(pll_id, 0);   //PLL slow-mode
-    dsb();
-    ddr_delayus(1);
-    SET_PLL_PD(pll_id, 1);         //PLL power-down
-    dsb();
-    ddr_delayus(1);
-    if(pll_id==GPLL)
-    {
-    	cru_sel32_sram=   pCRU_Reg->CRU_CLKSEL_CON[10];
-
-    	pCRU_Reg->CRU_CLKSEL_CON[10]=CRU_W_MSK_SETBITS(0, PERI_ACLK_DIV_OFF, PERI_ACLK_DIV_MASK)
-    				   | CRU_W_MSK_SETBITS(0, PERI_HCLK_DIV_OFF, PERI_HCLK_DIV_MASK)
-    				   |CRU_W_MSK_SETBITS(0, PERI_PCLK_DIV_OFF, PERI_PCLK_DIV_MASK);
-    }
-    pPHY_Reg->DSGCR = pPHY_Reg->DSGCR&(~((0x1<<28)|(0x1<<29)));  //CKOE
-}
-
-static void __sramfunc ddr_resume(void)
-{
-    int delay=1000;
-    int pll_id;
-
-    pll_id=GET_DDR_PLL_SRC();
-	pPHY_Reg->DSGCR = pPHY_Reg->DSGCR|((0x1<<28)|(0x1<<29));  //CKOE
-	dsb();
-
-	if(pll_id==GPLL)
-	pCRU_Reg->CRU_CLKSEL_CON[10]=0xffff0000|cru_sel32_sram;
-
-    SET_PLL_PD(pll_id, 0);         //PLL no power-down
-    dsb();
-    while (delay > 0)
-    {
-        if (GET_DPLL_LOCK_STATUS())
-            break;
-        ddr_delayus(1);
-        delay--;
-    }
-
-    SET_PLL_MODE(pll_id, 1);   //PLL normal
-    dsb();
-
-    ddr_selfrefresh_exit();
-}
-#endif
-
-//pArg:pll pd or not
-void ddr_reg_save(uint32 *pArg)
-{
-    uint32        ch;
-    pDDR_REG_T    pDDR_Reg=NULL;
-    pDDRPHY_REG_T pPHY_Reg=NULL;
-    pMSCH_REG     pMSCH_Reg;
-    
-    p_ddr_reg->tag = 0x56313031;
-    if(p_ddr_ch[0]->mem_type != DRAM_MAX)
-    {
-        p_ddr_reg->pctlAddr[0] = RK3288_DDR_PCTL0_PHYS;
-        p_ddr_reg->publAddr[0] = RK3288_DDR_PUBL0_PHYS;
-        p_ddr_reg->nocAddr[0] = RK3288_SERVICE_BUS_PHYS;
-        pDDR_Reg = p_ddr_ch[0]->pDDR_Reg;
-        pPHY_Reg = p_ddr_ch[0]->pPHY_Reg;
-    }
-    else
-    {
-        p_ddr_reg->pctlAddr[0] = 0xFFFFFFFF;
-        p_ddr_reg->publAddr[0] = 0xFFFFFFFF;
-        p_ddr_reg->nocAddr[0] = 0xFFFFFFFF;
-    }
-    if(p_ddr_ch[1]->mem_type != DRAM_MAX)
-    {
-        p_ddr_reg->pctlAddr[1] = RK3288_DDR_PCTL1_PHYS;
-        p_ddr_reg->publAddr[1] = RK3288_DDR_PUBL1_PHYS;
-        p_ddr_reg->nocAddr[1] = RK3288_SERVICE_BUS_PHYS+0x80;
-        if((pDDR_Reg == NULL) || (pPHY_Reg == NULL))
-        {
-            pDDR_Reg = p_ddr_ch[1]->pDDR_Reg;
-            pPHY_Reg = p_ddr_ch[1]->pPHY_Reg; 
-        }
-    }
-    else
-    {
-        p_ddr_reg->pctlAddr[1] = 0xFFFFFFFF;
-        p_ddr_reg->publAddr[1] = 0xFFFFFFFF;
-        p_ddr_reg->nocAddr[1] = 0xFFFFFFFF;
-    }
-    
-    //PCTLR    
-    (fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_copy)))((uint64_t*)&(p_ddr_reg->pctl.pctl_timing.togcnt1u), (uint64_t *)&(pDDR_Reg->TOGCNT1U), 17);
-    p_ddr_reg->pctl.SCFG = pDDR_Reg->SCFG.d32;
-    p_ddr_reg->pctl.CMDTSTATEN = pDDR_Reg->CMDTSTATEN;
-    p_ddr_reg->pctl.MCFG1 = pDDR_Reg->MCFG1;
-    p_ddr_reg->pctl.MCFG = pDDR_Reg->MCFG;
-    p_ddr_reg->pctl.pctl_timing.ddrFreq = *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq));
-    p_ddr_reg->pctl.DFITCTRLDELAY = pDDR_Reg->DFITCTRLDELAY;
-    p_ddr_reg->pctl.DFIODTCFG = pDDR_Reg->DFIODTCFG;
-    p_ddr_reg->pctl.DFIODTCFG1 = pDDR_Reg->DFIODTCFG1;
-    p_ddr_reg->pctl.DFIODTRANKMAP = pDDR_Reg->DFIODTRANKMAP;
-    p_ddr_reg->pctl.DFITPHYWRDATA = pDDR_Reg->DFITPHYWRDATA;
-    p_ddr_reg->pctl.DFITPHYWRLAT = pDDR_Reg->DFITPHYWRLAT;
-    p_ddr_reg->pctl.DFITRDDATAEN = pDDR_Reg->DFITRDDATAEN;
-    p_ddr_reg->pctl.DFITPHYRDLAT = pDDR_Reg->DFITPHYRDLAT;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE0 = pDDR_Reg->DFITPHYUPDTYPE0;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE1 = pDDR_Reg->DFITPHYUPDTYPE1;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE2 = pDDR_Reg->DFITPHYUPDTYPE2;
-    p_ddr_reg->pctl.DFITPHYUPDTYPE3 = pDDR_Reg->DFITPHYUPDTYPE3;
-    p_ddr_reg->pctl.DFITCTRLUPDMIN = pDDR_Reg->DFITCTRLUPDMIN;
-    p_ddr_reg->pctl.DFITCTRLUPDMAX = pDDR_Reg->DFITCTRLUPDMAX;
-    p_ddr_reg->pctl.DFITCTRLUPDDLY = pDDR_Reg->DFITCTRLUPDDLY;
-
-    p_ddr_reg->pctl.DFIUPDCFG = pDDR_Reg->DFIUPDCFG;
-    p_ddr_reg->pctl.DFITREFMSKI = pDDR_Reg->DFITREFMSKI;
-    p_ddr_reg->pctl.DFITCTRLUPDI = pDDR_Reg->DFITCTRLUPDI;
-    p_ddr_reg->pctl.DFISTCFG0 = pDDR_Reg->DFISTCFG0;
-    p_ddr_reg->pctl.DFISTCFG1 = pDDR_Reg->DFISTCFG1;
-    p_ddr_reg->pctl.DFITDRAMCLKEN = pDDR_Reg->DFITDRAMCLKEN;
-    p_ddr_reg->pctl.DFITDRAMCLKDIS = pDDR_Reg->DFITDRAMCLKDIS;
-    p_ddr_reg->pctl.DFISTCFG2 = pDDR_Reg->DFISTCFG2;
-    p_ddr_reg->pctl.DFILPCFG0 = pDDR_Reg->DFILPCFG0;
-
-    //PUBL  
-    p_ddr_reg->publ.phy_timing.dtpr0.d32 = pPHY_Reg->DTPR[0];
-    (fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_copy)))((uint64_t*)&(p_ddr_reg->publ.phy_timing.dtpr1), (uint64_t *)&(pPHY_Reg->DTPR[1]), 3);
-    p_ddr_reg->publ.PIR = pPHY_Reg->PIR;
-    p_ddr_reg->publ.PGCR = pPHY_Reg->PGCR;
-    p_ddr_reg->publ.DLLGCR = pPHY_Reg->DLLGCR;
-    p_ddr_reg->publ.ACDLLCR = pPHY_Reg->ACDLLCR;
-    p_ddr_reg->publ.PTR[0] = pPHY_Reg->PTR[0];
-    p_ddr_reg->publ.PTR[1] = pPHY_Reg->PTR[1];
-    p_ddr_reg->publ.PTR[2] = pPHY_Reg->PTR[2];
-    p_ddr_reg->publ.ACIOCR = pPHY_Reg->ACIOCR;
-    p_ddr_reg->publ.DXCCR = pPHY_Reg->DXCCR;
-    p_ddr_reg->publ.DSGCR = pPHY_Reg->DSGCR;
-    p_ddr_reg->publ.DCR = pPHY_Reg->DCR.d32;
-    p_ddr_reg->publ.ODTCR = pPHY_Reg->ODTCR;
-    p_ddr_reg->publ.DTAR = pPHY_Reg->DTAR;
-    p_ddr_reg->publ.ZQ0CR0 = (pPHY_Reg->ZQ0SR[0] & 0x0FFFFFFF) | (0x1<<28);
-    p_ddr_reg->publ.ZQ1CR0 = (pPHY_Reg->ZQ1SR[0] & 0x0FFFFFFF) | (0x1<<28);
-
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(p_ddr_ch[0]->mem_type != DRAM_MAX)
-        {
-            pPHY_Reg = p_ddr_ch[ch]->pPHY_Reg;         
-            p_ddr_reg->dqs[ch].DX0GCR = pPHY_Reg->DATX8[0].DXGCR;
-            p_ddr_reg->dqs[ch].DX0DLLCR = pPHY_Reg->DATX8[0].DXDLLCR;
-            p_ddr_reg->dqs[ch].DX0DQTR = pPHY_Reg->DATX8[0].DXDQTR;
-            p_ddr_reg->dqs[ch].DX0DQSTR = pPHY_Reg->DATX8[0].DXDQSTR;
-
-            p_ddr_reg->dqs[ch].DX1GCR = pPHY_Reg->DATX8[1].DXGCR;
-            p_ddr_reg->dqs[ch].DX1DLLCR = pPHY_Reg->DATX8[1].DXDLLCR;
-            p_ddr_reg->dqs[ch].DX1DQTR = pPHY_Reg->DATX8[1].DXDQTR;
-            p_ddr_reg->dqs[ch].DX1DQSTR = pPHY_Reg->DATX8[1].DXDQSTR;
-
-            p_ddr_reg->dqs[ch].DX2GCR = pPHY_Reg->DATX8[2].DXGCR;
-            p_ddr_reg->dqs[ch].DX2DLLCR = pPHY_Reg->DATX8[2].DXDLLCR;
-            p_ddr_reg->dqs[ch].DX2DQTR = pPHY_Reg->DATX8[2].DXDQTR;
-            p_ddr_reg->dqs[ch].DX2DQSTR = pPHY_Reg->DATX8[2].DXDQSTR;
-
-            p_ddr_reg->dqs[ch].DX3GCR = pPHY_Reg->DATX8[3].DXGCR;
-            p_ddr_reg->dqs[ch].DX3DLLCR = pPHY_Reg->DATX8[3].DXDLLCR;
-            p_ddr_reg->dqs[ch].DX3DQTR = pPHY_Reg->DATX8[3].DXDQTR;
-            p_ddr_reg->dqs[ch].DX3DQSTR = pPHY_Reg->DATX8[3].DXDQSTR;
-
-            //NOC
-            pMSCH_Reg= p_ddr_ch[ch]->pMSCH_Reg;        
-            p_ddr_reg->noc[ch].ddrconf = pMSCH_Reg->ddrconf;
-            p_ddr_reg->noc[ch].ddrtiming.d32 = pMSCH_Reg->ddrtiming.d32;
-            p_ddr_reg->noc[ch].ddrmode = pMSCH_Reg->ddrmode;
-            p_ddr_reg->noc[ch].readlatency = pMSCH_Reg->readlatency;
-            p_ddr_reg->noc[ch].activate.d32 = pMSCH_Reg->activate.d32;
-            p_ddr_reg->noc[ch].devtodev = pMSCH_Reg->devtodev;
-        }
-    }
-
-    //PLLPD
-    p_ddr_reg->pllpdAddr = (uint32_t)pArg;  //pll power-down tag addr
-    p_ddr_reg->pllpdMask = 1;
-    p_ddr_reg->pllpdVal = 1;
-
-    //DPLL
-    p_ddr_reg->dpllmodeAddr = RK3288_CRU_PHYS + 0x50;  //APCRU_MODE_CON
-    p_ddr_reg->dpllSlowMode = ((3<<4)<<16) | (0<<4);
-    p_ddr_reg->dpllNormalMode = ((3<<4)<<16) | (1<<4);
-    p_ddr_reg->dpllResetAddr = RK3288_CRU_PHYS + 0x1c; //APCRU_DPLL_CON3
-    p_ddr_reg->dpllReset = (((0x1<<5)<<16) | (0x1<<5));
-    p_ddr_reg->dpllDeReset = (((0x1<<5)<<16) | (0x0<<5));
-    p_ddr_reg->dpllConAddr = RK3288_CRU_PHYS + 0x10;   //APCRU_DPLL_CON0
-    p_ddr_reg->dpllCon[0] = pCRU_Reg->CRU_PLL_CON[DPLL][0] | (0xFFFF<<16);
-    p_ddr_reg->dpllCon[1] = pCRU_Reg->CRU_PLL_CON[DPLL][1] | (0xFFFF<<16);
-    p_ddr_reg->dpllCon[2] = pCRU_Reg->CRU_PLL_CON[DPLL][2] | (0xFFFF<<16);
-    p_ddr_reg->dpllCon[3] = pCRU_Reg->CRU_PLL_CON[DPLL][3] | (0xFFFF<<16);
-    p_ddr_reg->dpllLockAddr = RK3288_GRF_PHYS + 0x284;  //GRF_SOC_STATUS1
-    p_ddr_reg->dpllLockMask = (1<<5);
-    p_ddr_reg->dpllLockVal = (1<<5);
-
-    //SET_DDR_PLL_SRC
-    p_ddr_reg->ddrPllSrcDivAddr = RK3288_CRU_PHYS + 0xc8;
-    p_ddr_reg->ddrPllSrcDiv = (pCRU_Reg->CRU_CLKSEL_CON[26] & 0x7) | (0x7<<16);
-
-    p_ddr_reg->retenDisAddr = RK3288_PMU_PHYS+0x18;  //pmu_pwrmode_con
-    p_ddr_reg->retenDisVal = (3<<21);  //OR operation
-    p_ddr_reg->retenStAddr = RK3288_PMU_PHYS+0x1c;  //pmu_pwrmode_con
-    p_ddr_reg->retenStMask = (1<<6);
-    p_ddr_reg->retenStVal = (0<<6);
-
-    p_ddr_reg->grfRegCnt = 3;
-    //DDR_16BIT,DDR_HW_WAKEUP,DDR_TYPE
-    p_ddr_reg->grf[0].addr = RK3288_GRF_PHYS + 0x244;
-    p_ddr_reg->grf[0].val = (pGRF_Reg->GRF_SOC_CON[0] & ((0x3<<8)|(0x3<<5)|(0x3<<3))) | (((0x3<<8)|(0x3<<5)|(0x3<<3))<<16);
-    
-    //LPDDR_TYPE
-    p_ddr_reg->grf[1].addr = RK3288_GRF_PHYS + 0x24c;
-    p_ddr_reg->grf[1].val = (pGRF_Reg->GRF_SOC_CON[2] & (0x3f<<8)) | ((0x3f<<8)<<16);
-
-    //STRIDE
-    p_ddr_reg->grf[2].addr = RK3288_SGRF_PHYS + 0x8;
-    p_ddr_reg->grf[2].val = READ_DDR_STRIDE() | (0x1F<<16);
-
-    p_ddr_reg->endTag = 0xFFFFFFFF;
-}
-
-__attribute__((aligned(4)))   uint32 ddr_reg_resume[]=
-{
-#include "ddr_reg_resume.inc"
-};
-
-char * ddr_get_resume_code_info(u32 *size)
-{
-    *size=sizeof(ddr_reg_resume);
-    
-    return (char *)ddr_reg_resume;
-
-}
-EXPORT_SYMBOL(ddr_get_resume_code_info);
-
-char * ddr_get_resume_data_info(u32 *size)
-{
-    *size=sizeof(DATA(ddr_reg));
-    return (char *) kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-}
-EXPORT_SYMBOL(ddr_get_resume_data_info);
-
-/**********************ddr bandwidth calc*********************/
-enum ddr_bandwidth_id {
-	ddrbw_wr_num = 0,
-	ddrbw_rd_num,
-	ddrbw_act_num,
-	ddrbw_time_num,
-	ddrbw_eff,
-	ddrbw_id_end
-};
-
-#define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT + offset)
-#define grf_writel(v, offset) \
-	do { writel_relaxed(v, RK_GRF_VIRT + offset); dsb(); } while (0)
-
-#define noc_readl(offset)       readl_relaxed(RK3288_SERVICE_BUS_VIRT + offset)
-#define noc_writel(v, offset) \
-	do { writel_relaxed(v, RK3288_SERVICE_BUS_VIRT + offset); \
-		dsb(); } while (0)
-
-static void ddr_monitor_start(void)
-{
-	int i;
-
-	for (i = 1; i < 8; i++) {
-		noc_writel(0x8, (0x400*i+0x8));
-		noc_writel(0x1, (0x400*i+0xc));
-		noc_writel(0x6, (0x400*i+0x138));
-		noc_writel(0x10, (0x400*i+0x14c));
-		noc_writel(0x8, (0x400*i+0x160));
-		noc_writel(0x10, (0x400*i+0x174));
-	}
-
-	grf_writel((((readl_relaxed(RK_PMU_VIRT+0x9c)>>13)&7) == 3) ?
-			0xc000c000 : 0xe000e000, RK3288_GRF_SOC_CON4);
-
-	for (i = 1; i < 8; i++)
-		noc_writel(0x1, (0x400*i+0x28));
-}
-
-static void ddr_monitor_stop(void)
-{
-	grf_writel(0xc0000000, RK3288_GRF_SOC_CON4);
-}
-
-static void _ddr_bandwidth_get(struct ddr_bw_info *ddr_bw_ch0,
-			struct ddr_bw_info *ddr_bw_ch1)
-{
-	u32 ddr_bw_val[2][ddrbw_id_end], ddr_freq;
-	u64 temp64;
-	int i, j;
-
-	ddr_monitor_stop();
-	for (j = 0; j < 2; j++) {
-		for (i = 0; i < ddrbw_eff; i++)
-			ddr_bw_val[j][i] =
-				grf_readl(RK3288_GRF_SOC_STATUS11+i*4+j*16);
-	}
-	if (!ddr_bw_val[0][ddrbw_time_num])
-		goto end;
-
-	if (ddr_bw_ch0) {
-		ddr_freq = readl_relaxed(RK_DDR_VIRT + 0xc0);
-
-		temp64 = ((u64)ddr_bw_val[0][0]+ddr_bw_val[0][1])*4*100;
-		do_div(temp64, ddr_bw_val[0][ddrbw_time_num]);
-		ddr_bw_val[0][ddrbw_eff] = temp64;
-
-		ddr_bw_ch0->ddr_percent = temp64;
-		ddr_bw_ch0->ddr_time =
-			ddr_bw_val[0][ddrbw_time_num]/(ddr_freq*1000);
-		ddr_bw_ch0->ddr_wr =
-			(ddr_bw_val[0][ddrbw_wr_num]*8*4)*
-				ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->ddr_rd =
-			(ddr_bw_val[0][ddrbw_rd_num]*8*4)*
-				ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->ddr_act =
-			ddr_bw_val[0][ddrbw_act_num];
-		ddr_bw_ch0->ddr_total =
-			ddr_freq*2*4;
-
-		ddr_bw_ch0->cpum = (noc_readl(0x400+0x178)<<16)
-			+ (noc_readl(0x400+0x164));
-		ddr_bw_ch0->gpu = (noc_readl(0x800+0x178)<<16)
-			+ (noc_readl(0x800+0x164));
-		ddr_bw_ch0->peri = (noc_readl(0xc00+0x178)<<16)
-			+ (noc_readl(0xc00+0x164));
-		ddr_bw_ch0->video = (noc_readl(0x1000+0x178)<<16)
-			+ (noc_readl(0x1000+0x164));
-		ddr_bw_ch0->vio0 = (noc_readl(0x1400+0x178)<<16)
-			+ (noc_readl(0x1400+0x164));
-		ddr_bw_ch0->vio1 = (noc_readl(0x1800+0x178)<<16)
-			+ (noc_readl(0x1800+0x164));
-		ddr_bw_ch0->vio2 = (noc_readl(0x1c00+0x178)<<16)
-			+ (noc_readl(0x1c00+0x164));
-
-		ddr_bw_ch0->cpum =
-			ddr_bw_ch0->cpum*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->gpu =
-			ddr_bw_ch0->gpu*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->peri =
-			ddr_bw_ch0->peri*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->video =
-			ddr_bw_ch0->video*
-				ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->vio0 =
-			ddr_bw_ch0->vio0*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->vio1 =
-			ddr_bw_ch0->vio1*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-		ddr_bw_ch0->vio2 =
-			ddr_bw_ch0->vio2*ddr_freq/ddr_bw_val[0][ddrbw_time_num];
-	}
-end:
-	ddr_monitor_start();
-}
-
-/******************************************************************/
-
-static int ddr_init(uint32 dram_speed_bin, uint32 freq)
-{
-    uint32 tmp;
-    uint32 die=1;
-    uint32 gsr,dqstr;
-    struct clk *clk;
-    uint32 ch,cap=0,cs_cap;
-
-    ddr_print("version 1.00 20150126 \n");
-
-    p_ddr_reg = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_reg));
-    p_ddr_set_pll = fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_set_pll));
-    DATA(p_cpu_pause) = kern_to_pie(rockchip_pie_chunk, &DATA(cpu_pause[0]));
-
-    tmp = clk_get_rate(clk_get(NULL, "clk_ddr"))/1000000;
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_freq)) = tmp;
-    *kern_to_pie(rockchip_pie_chunk, &DATA(ddr_sr_idle)) = 0;
-    
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        p_ddr_ch[ch] = kern_to_pie(rockchip_pie_chunk, &DATA(ddr_ch[ch]));
-        
-        p_ddr_ch[ch]->chNum = ch;
-        p_ddr_ch[ch]->pDDR_Reg = pDDR_REG(ch);
-        p_ddr_ch[ch]->pPHY_Reg = pPHY_REG(ch);
-        p_ddr_ch[ch]->pMSCH_Reg = pMSCH_REG(ch);
-
-        if(!(READ_CH_INFO()&(1<<ch)))
-        {
-            p_ddr_ch[ch]->mem_type = DRAM_MAX;
-            continue;
-        }
-        else
-        {
-            if(ch)
-            {
-                ddr_print("Channel b: \n");
-            }
-            else
-            {
-                ddr_print("Channel a: \n");
-            }
-            tmp = p_ddr_ch[ch]->pPHY_Reg->DCR.b.DDRMD;
-            if((tmp ==  LPDDR2) && (READ_DRAMTYPE_INFO() == 6))
-            {
-                tmp = LPDDR3;
-            }
-            switch(tmp)
-            {
-                case DDR3:
-                    ddr_print("DDR3 Device\n");
-                    break;
-                case LPDDR3:
-                    ddr_print("LPDDR3 Device\n");
-                    break;
-                case LPDDR2:
-                    ddr_print("LPDDR2 Device\n");
-                    break;
-                default:
-                    ddr_print("Unkown Device\n");
-                    tmp = DRAM_MAX;
-                    break;
-            }
-            p_ddr_ch[ch]->mem_type = tmp;
-            if(tmp == DRAM_MAX)
-            {
-                p_ddr_ch[ch]->mem_type = DRAM_MAX;
-                continue;
-            }
-        }
-        
-        p_ddr_ch[ch]->ddr_speed_bin = dram_speed_bin;
-        //get capability per chip, not total size, used for calculate tRFC
-        die = (8<<READ_BW_INFO(ch))/(8<<READ_DIE_BW_INFO(ch));
-        cap = (1 << (READ_ROW_INFO(ch,0)+READ_COL_INFO(ch)+READ_BK_INFO(ch)+READ_BW_INFO(ch)));
-        cs_cap = cap;
-        if(READ_CS_INFO(ch) > 1)
-        {
-            cap += cap >> (READ_ROW_INFO(ch,0)-READ_ROW_INFO(ch,1));
-        }
-        if(READ_CH_ROW_INFO(ch))
-        {
-            cap = cap*3/4;
-        }
-        p_ddr_ch[ch]->ddr_capability_per_die = cs_cap/die;
-        ddr_print("Bus Width=%d Col=%d Bank=%d Row=%d CS=%d Total Capability=%dMB\n",
-                                                                        READ_BW_INFO(ch)*16,\
-                                                                        READ_COL_INFO(ch), \
-                                                                        (0x1<<(READ_BK_INFO(ch))), \
-                                                                        READ_ROW_INFO(ch,0), \
-                                                                        READ_CS_INFO(ch), \
-                                                                        (cap>>20));
-    }
-    
-    ddr_adjust_config();
-
-    clk = clk_get(NULL, "clk_ddr");
-    if (IS_ERR(clk)) {
-        ddr_print("failed to get ddr clk\n");
-        clk = NULL;
-    }
-    if(freq != 0)
-        tmp = clk_set_rate(clk, 1000*1000*freq);
-    else
-        tmp = clk_set_rate(clk, clk_get_rate(clk));
-    ddr_print("init success!!! freq=%luMHz\n", clk ? clk_get_rate(clk)/1000000 : freq);
-
-    for(ch=0;ch<CH_MAX;ch++)
-    {
-        if(p_ddr_ch[ch]->mem_type != DRAM_MAX)
-        {            
-            if(ch)
-            {
-                ddr_print("Channel b: \n");
-            }
-            else
-            {
-                ddr_print("Channel a: \n");
-            }
-            for(tmp=0;tmp<4;tmp++)
-            {
-                gsr = p_ddr_ch[ch]->pPHY_Reg->DATX8[tmp].DXGSR[0];
-                dqstr = p_ddr_ch[ch]->pPHY_Reg->DATX8[tmp].DXDQSTR;
-                ddr_print("DTONE=0x%x, DTERR=0x%x, DTIERR=0x%x, DTPASS=%d,%d, DGSL=%d,%d extra clock, DGPS=%d,%d\n", \
-                                                                    (gsr&0xF), ((gsr>>4)&0xF), ((gsr>>8)&0xF), \
-                                                                    ((gsr>>13)&0x7), ((gsr>>16)&0x7),\
-                                                                    (dqstr&0x7), ((dqstr>>3)&0x7),\
-                                                                    ((((dqstr>>12)&0x3)+1)*90), ((((dqstr>>14)&0x3)+1)*90));
-            }
-            ddr_print("ZERR=%x, ZDONE=%x, ZPD=0x%x, ZPU=0x%x, OPD=0x%x, OPU=0x%x\n", \
-                                                        (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]>>30)&0x1, \
-                                                        (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]>>31)&0x1, \
-                                                        p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[1]&0x3,\
-                                                        (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[1]>>2)&0x3,\
-                                                        (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[1]>>4)&0x3,\
-                                                        (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[1]>>6)&0x3);
-            ddr_print("DRV Pull-Up=0x%x, DRV Pull-Dwn=0x%x\n", p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]&0x1F, (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]>>5)&0x1F);
-            ddr_print("ODT Pull-Up=0x%x, ODT Pull-Dwn=0x%x\n", (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]>>10)&0x1F, (p_ddr_ch[ch]->pPHY_Reg->ZQ0SR[0]>>15)&0x1F);
-        }
-    }
-
-    return 0;
-}
-
diff --git a/arch/arm/mach-rockchip/ddr_test.c b/arch/arm/mach-rockchip/ddr_test.c
deleted file mode 100755
index 936e02bbd732..000000000000
--- a/arch/arm/mach-rockchip/ddr_test.c
+++ /dev/null
@@ -1,296 +0,0 @@
-#if defined(CONFIG_DDR_TEST)
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/cpu.h>
-#include <linux/delay.h>
-#include <linux/proc_fs.h>
-#include <linux/vmalloc.h>
-#include <linux/random.h>
-#include <linux/uaccess.h>
-#include <linux/clk.h>
-#include <linux/freezer.h>
-#include <linux/kthread.h>
-#include <linux/sched/rt.h>
-#include <linux/rockchip/dvfs.h>
-
-#include <dt-bindings/clock/ddr.h>
-
-struct ddrtest {
-    struct clk *pll;
-    struct clk *clk;
-	struct dvfs_node *clk_dvfs_node;
-    volatile unsigned int freq;
-    volatile bool change_end;
-    struct task_struct *task;
-    wait_queue_head_t wait;
-};
-static struct ddrtest ddrtest;
-
-static ssize_t ddr_proc_read(struct file *file, char __user *buffer,
-			     size_t len, loff_t *data)
-{
-    char version[]={"V100"};
-    u32 i;
-    
-    printk("ddr_test Version V1.0\n");
-    for(i=0;i<len;i++)
-    {
-        buffer[i] = version[i];
-    }
-    return 0;
-}
-
-static ssize_t ddr_proc_write(struct file *file, const char __user *buffer,
-			      size_t len, loff_t *data)
-{
-    char *cookie_pot;
-    char *p;
-    uint32_t value, value1, value2;
-    uint32_t count, total;
-    char tmp;
-    struct clk *clk_ddr = NULL;
-    int ret = len;
-    char *buf = vzalloc(len);
-
-    cookie_pot = buf;
-
-    if (!cookie_pot)
-    {
-        return -ENOMEM;
-    }
-    else
-    {
-        if (copy_from_user( cookie_pot, buffer, len )) {
-            ret = -EFAULT;
-            goto out;
-        }
-    }
-
-    clk_ddr = clk_get(NULL, "clk_ddr");
-    if (IS_ERR(clk_ddr)) {
-        ret = PTR_ERR(clk_ddr);
-        clk_ddr = NULL;
-        goto out;
-    }
-
-    switch(cookie_pot[0])
-    {
-        case 'c':
-        case 'C':
-            printk("change ddr freq:\n");
-            if(cookie_pot[1] ==':')
-            {
-                strsep(&cookie_pot,":");
-                p=strsep(&cookie_pot,"M");
-                value = simple_strtol(p,NULL,10);
-                printk("change!!! freq=%dMHz\n", value);
-                //clk_set_rate(clk_ddr, value * 1000000);
-                ddrtest.freq = value;
-                ddrtest.change_end = false;
-                wake_up(&ddrtest.wait);
-                while(ddrtest.change_end != true);  //wait change freq end
-                value = clk_get_rate(clk_ddr) / 1000000;
-                printk("success!!! freq=%dMHz\n", value);
-                msleep(64);
-                printk("\n");
-            }
-            else
-            {
-                printk("Error auto change ddr freq debug.\n");
-                printk("-->'c&&C' change freq,Example: echo 'c:400M' > ddr_test\n");
-            }
-            break;
-
-        case 'a':
-        case 'A':
-            printk("auto change ddr freq test (random):\n");
-            if(cookie_pot[1] ==':')
-            {
-                strsep(&cookie_pot,":");
-                p=strsep(&cookie_pot,"M");
-                value1 = simple_strtol(p,NULL,10);
-                strsep(&cookie_pot,"-");
-                p=strsep(&cookie_pot,"M");
-                value2 = simple_strtol(p,NULL,10);
-                strsep(&cookie_pot,"-");
-                p=strsep(&cookie_pot,"T");
-                total = simple_strtol(p,NULL,10);
-
-                count = 0;
-
-                while ( count < total )
-                {
-                    printk("auto change ddr freq test (random):[%d-%d]\n",count,total);
-                    do
-                    {
-                        value = value1 + prandom_u32();
-                        value %= value2;
-                    }while(value < value1);
-
-                    printk("change!!! freq=%dMHz\n", value);
-                    //clk_set_rate(clk_ddr, value * 1000000);
-                    ddrtest.freq = value;
-                    ddrtest.change_end = false;
-                    wake_up(&ddrtest.wait);
-                    while(ddrtest.change_end != true);  //wait change freq end
-                    value = clk_get_rate(clk_ddr) / 1000000;
-                    printk("success!!! freq=%dMHz\n", value);
-                    msleep(64);
-                    count++;
-                }
-
-            }
-            else
-            {
-                printk("Error auto change ddr freq test debug.\n");
-                printk("-->'a&&A' auto change ddr freq test (random),Example: echo 'a:200M-400M-1000T' > ddr_test\n");
-            }
-            break;
-
-        case 'b':
-        case 'B':
-            printk("auto change ddr freq test (specific):\n");
-            if(cookie_pot[1] ==':')
-            {
-                strsep(&cookie_pot,":");
-                p=strsep(&cookie_pot,"M");
-                value1 = simple_strtol(p,NULL,10);
-                strsep(&cookie_pot,"-");
-                p=strsep(&cookie_pot,"M");
-                value2 = simple_strtol(p,NULL,10);
-                strsep(&cookie_pot,"-");
-                p=strsep(&cookie_pot,"T");
-                total = simple_strtol(p,NULL,10);
-
-                count = 0;
-                tmp = 0;
-
-                while ( count < total )
-                {
-                    printk("auto change ddr freq test (specific):[%d-%d]\n",count,total);
-                    if(tmp == 1)
-                    {
-                        value = value1;
-                        tmp = 0;
-                    }
-                    else
-                    {
-                        value = value2;
-                        tmp = 1;
-                    }
-
-                    printk("change!!! freq=%dMHz\n", value);
-                    //clk_set_rate(clk_ddr, value * 1000000);
-                    ddrtest.freq = value;
-                    ddrtest.change_end = false;
-                    wake_up(&ddrtest.wait);
-                    while(ddrtest.change_end != true);  //wait change freq end
-                    value = clk_get_rate(clk_ddr) / 1000000;
-                    printk("success!!! freq=%dMHz\n", value);
-                    msleep(64);
-                    count++;
-                }
-
-            }
-            else
-            {
-                printk("Error auto change ddr freq test debug.\n");
-                printk("-->'b&&B' auto change ddr freq test (specific),Example: echo 'a:200M-400M-1000T' > ddr_test\n");
-            }
-            break;
-            
-        case 'h':
-        case 'H':
-        default:
-            printk("Help for ddr_ts .\n-->The Cmd list: \n");
-            printk("-->'a&&A' auto change ddr freq test (random),Example: echo 'a:200M-400M-100T' > ddr_test\n");
-            printk("-->'b&&B' auto change ddr freq test (specific),Example: echo 'b:200M-400M-100T' > ddr_test\n");
-            printk("-->'c&&C' change freq,Example: echo 'c:400M' > ddr_test\n");
-            break;
-    }
-
-out:
-    if (clk_ddr)
-        clk_put(clk_ddr);
-    vfree(buf);
-    return ret;
-}
-
-static const struct file_operations ddr_proc_fops = {
-    .owner		= THIS_MODULE,
-};
-
-static void ddrtest_work(unsigned int value)
-{
-	dvfs_clk_set_rate(ddrtest.clk_dvfs_node, value * 1000000);
-    ddrtest.change_end = true;
-}
-
-static int ddrtest_task(void *data)
-{
-    set_freezable();
-
-    do {
-        //unsigned long status = ddr.sys_status;
-        ddrtest_work(ddrtest.freq);
-        wait_event_freezable(ddrtest.wait, (ddrtest.change_end == false ) || kthread_should_stop());
-    } while (!kthread_should_stop());
-
-    return 0;
-}
-
-static const struct file_operations ddrtest_proc_fops = {
-    .owner = THIS_MODULE,
-    .read =  ddr_proc_read,
-    .write = ddr_proc_write,
-};
-
-static int ddr_proc_init(void)
-{
-    struct proc_dir_entry *ddr_proc_entry;
-    int ret=0;
-    struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
-    init_waitqueue_head(&ddrtest.wait);
-
-    //ddrtest.pll = clk_get(NULL, "ddr_pll");
-    ddrtest.clk = clk_get(NULL, "clk_ddr");
-    if (IS_ERR(ddrtest.clk)) {
-        ret = PTR_ERR(ddrtest.clk);
-        ddrtest.clk = NULL;
-        pr_err("failed to get ddr clk, error %d\n", ret);
-        goto err;
-    }
-    ddrtest.freq = clk_get_rate(ddrtest.clk)/1000000;
-
-	ddrtest.clk_dvfs_node = clk_get_dvfs_node("clk_ddr");
-	if (!ddrtest.clk_dvfs_node)
-		goto err;
-
-    ddr_proc_entry = proc_create("driver/ddr_ts",
-                           S_IRUGO | S_IWUGO | S_IWUSR | S_IRUSR,
-                           NULL,&ddrtest_proc_fops);
-    
-    if(ddr_proc_entry == NULL){
-        ret = -ENOMEM;
-        pr_err("failed to create proc entry, error %d\n", ret);
-        goto err;
-    }
-
-    ddrtest.task = kthread_create(ddrtest_task, NULL, "ddrtestd");
-    if (IS_ERR(ddrtest.task)) {
-        ret = PTR_ERR(ddrtest.task);
-        pr_err("failed to create kthread! error %d\n", ret);
-        goto err;
-    }
-    sched_setscheduler_nocheck(ddrtest.task,SCHED_FIFO, &param);
-    get_task_struct(ddrtest.task);
-    kthread_bind(ddrtest.task, 0);
-    wake_up_process(ddrtest.task);
-
-err:
-    return 0;
-}
-
-late_initcall_sync(ddr_proc_init);
-#endif // CONFIG_DDR_TEST 
-
diff --git a/arch/arm/mach-rockchip/dma_memcpy_test.c b/arch/arm/mach-rockchip/dma_memcpy_test.c
deleted file mode 100644
index 8db3ec358ee9..000000000000
--- a/arch/arm/mach-rockchip/dma_memcpy_test.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- *
- * arch/arm/plat-rk/dma_memcpy_test.c
- *
- * Copyright (C) 2012 Rochchip.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Author: hhb@rock-chips.com
- * Create Date: 2012.03.26
- * 
- * HOW TO USE IT?
- * enter the follow command at command line
- * echo 1 > sys/module/dma_memcpy_test/parameters/debug   enable log output,default is enable
- * echo 1000 > sys/module/dma_memcpy_test/parameters/interval   set dma transfer interval, default is 1000ms
- * echo 1 > /sys/devices/platform/dma_memcpy.0/dmamemcpy  to start the dma test
- *
- */
-
-/*
-*		Driver Version Note
-*
-*v1.0 : 1. add dam thread number from 2 to 8;
-*		
-*		
-*/
-#define VERSION_AND_TIME  "dma_memcpy_test.c v1.0 2012-08-13"
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/wait.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <asm/uaccess.h>
-#include <asm/current.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/amba/bus.h>
-#include <linux/amba/pl330.h>
-#include <linux/slab.h>
-
-
-#define DMA_TEST_BUFFER_SIZE 512
-#define DMA_THREAD  6
-
-struct Dma_MemToMem {
-	const char *name;
-	unsigned char* src;			//virtual address
-	unsigned char* dst;
-	int MenSize;
-    dma_cap_mask_t  cap_mask;
-	struct dma_chan *dma_chan;
-	struct dma_slave_config *config;
-	struct dma_async_tx_descriptor *tx;
-};
-
-//enable log output
-static int debug = 8;
-module_param(debug,int,S_IRUGO|S_IWUSR);
-#define MEMCPY_DMA_DBG(fmt...)  {if(debug > 0) printk(fmt);}
-
-static struct Dma_MemToMem DmaMemInfo[DMA_THREAD];
-
-static void dma_memtest_transfer(struct Dma_MemToMem *DmaMemInfo)
-{
-	dma_async_tx_descriptor_init(DmaMemInfo->tx, DmaMemInfo->dma_chan);
-	
-	dma_async_memcpy_buf_to_buf(DmaMemInfo->dma_chan, DmaMemInfo->dst,
-			DmaMemInfo->src, DMA_TEST_BUFFER_SIZE);
-
-	dma_wait_for_async_tx(DmaMemInfo->tx);
-
-	dmaengine_terminate_all(DmaMemInfo->dma_chan);
-}
-
-//int slecount = 0;
-static ssize_t memcpy_dma_read(struct device *device,struct device_attribute *attr, char *argv)
-{
-
-     return 0;
-}
-
-static ssize_t memcpy_dma_write(struct device *device, struct device_attribute *attr, const char *argv, size_t count)
-{
- 
-    int i,j;
-    printk("memcpy_dma_write\n");
-
-	for(j = DMA_THREAD; j > 0; j--)
-	{
-        memset(DmaMemInfo[j-1].src, ((j-1)<<4|(j-1)), DMA_TEST_BUFFER_SIZE);			
-		memset(DmaMemInfo[j-1].dst, 0x0, DMA_TEST_BUFFER_SIZE);
-	}
-
-	switch(DMA_THREAD) {		
-		case 8:			
-			dma_memtest_transfer(&DmaMemInfo[7]);		
-		case 7:			
-			dma_memtest_transfer(&DmaMemInfo[6]);	
-		case 6:			
-			dma_memtest_transfer(&DmaMemInfo[5]);
-		case 5:			
-			dma_memtest_transfer(&DmaMemInfo[4]);	
-		case 4:			
-			dma_memtest_transfer(&DmaMemInfo[3]);	
-		case 3:			
-			dma_memtest_transfer(&DmaMemInfo[2]);	
-		case 2:			
-			dma_memtest_transfer(&DmaMemInfo[1]);	
-		case 1:			
-			dma_memtest_transfer(&DmaMemInfo[0]);
-			break;		
-		default:			
-			printk("%s no channel\n", __func__);			
-		break;		
-	}
-	
-
-	for(i = 0; i < 16; i++) {	
-		for(j = DMA_THREAD; j > 0; j--)
-		{
-			printk("src%d:%2x",j,*(DmaMemInfo[j-1].src + i*(DMA_TEST_BUFFER_SIZE/16)));				
-			printk(" -> dst%d:%2x\n",j,*(DmaMemInfo[j-1].dst + i*(DMA_TEST_BUFFER_SIZE/16)));	
-		}
-	}	
-
-    return count;
-}
-
-static DEVICE_ATTR(dmamemcpy,  S_IRUGO|S_IALLUGO, memcpy_dma_read, memcpy_dma_write);
-
-
-static int dma_memtest_channel_setup_and_init(struct Dma_MemToMem *DmaMemInfo, const char *name,
-		u32 direction, u32 addr_width, u32 maxburst)
-{
-	DmaMemInfo->name = name;
-	dma_cap_set(DMA_MEMCPY, DmaMemInfo->cap_mask);
-	DmaMemInfo->dma_chan = dma_request_channel(DmaMemInfo->cap_mask,NULL,NULL);
-
-	if(DmaMemInfo->dma_chan==NULL)
-	{
-		printk("request dma_chan %s fail\n",DmaMemInfo->name);
-		return -1;
-	}else
-	{
-		printk("request dma_chan %s success\n",DmaMemInfo->name);
-	}
-
-	DmaMemInfo->config = kmalloc(sizeof(struct dma_slave_config *),GFP_KERNEL);
-	DmaMemInfo->tx = kmalloc(sizeof(struct dma_async_tx_descriptor *),GFP_KERNEL);
-	if(DmaMemInfo->config == NULL)
-	{
-		printk("struct config kmalloc memory %s fail\n",DmaMemInfo->name);
-		return -1;
-	}
-	else	
-	{
-		printk("struct config kmalloc memory %s sucess\n",DmaMemInfo->name);
-	}
-	
-
-	DmaMemInfo->src = kmalloc(DMA_TEST_BUFFER_SIZE, GFP_KERNEL);
-	DmaMemInfo->dst = kmalloc(DMA_TEST_BUFFER_SIZE, GFP_KERNEL);
-	if(DmaMemInfo->src == NULL || DmaMemInfo->dst == NULL)
-	{
-		printk("dma_alloc_coherent %s fail\n",DmaMemInfo->name);
-		return -1;
-	}
-	else						
-	{
-		printk("dma_alloc_coherent %s success\n",DmaMemInfo->name);
-	}
-
-	return 0;
-
-}
-
-
-static int dma_memcpy_probe(struct platform_device *pdev)
-{
-    int ret;
-
-    ret = device_create_file(&pdev->dev, &dev_attr_dmamemcpy);
-	printk(">>>>>>>>>>>>>>>>>>>>> dam_test_probe <<<<<<<<<<<<<<<<<<<<<<<<<<<\n");
-
-    switch(DMA_THREAD) {		
-		case 8:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[7], "DmaMemInfo[7]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);			
-		case 7:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[6], "DmaMemInfo[6]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);	
-		case 6:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[5], "DmaMemInfo[5]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);	
-		case 5:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[4], "DmaMemInfo[4]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);		
-		case 4:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[3], "DmaMemInfo[3]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);		
-		case 3:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[2], "DmaMemInfo[2]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);	
-		case 2:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[1], "DmaMemInfo[1]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);	
-		case 1:			
-			dma_memtest_channel_setup_and_init(&DmaMemInfo[0], "DmaMemInfo[0]",
-                DMA_MEM_TO_MEM, DMA_SLAVE_BUSWIDTH_8_BYTES, 16);
-			break;		
-		default:			
-			printk("%s no channel\n", __func__);			
-		break;		
-	}
-	
-	printk("dma_memcpy_probe sucess\n");
-    return 0;
-}
-
-static int dma_memcpy_remove(struct platform_device *pdev)
-{
-    device_remove_file(&pdev->dev, &dev_attr_dmamemcpy);
-
-    return 0;
-}
-
-static struct platform_driver dma_mempcy_driver = {
-        .driver = {
-                .name   = "dma_memcpy",
-                .owner  = THIS_MODULE,
-        },
-        .probe          = dma_memcpy_probe,
-        .remove         = dma_memcpy_remove,
-};
-
-struct platform_device rk29_device_dma_cpy = {
-	.name		  = "dma_memcpy",
-	.id		  = 0,
-
-};
-
-
-static int __init dma_test_init(void)
-{
-		platform_device_register(&rk29_device_dma_cpy);
-		return platform_driver_register(&dma_mempcy_driver);
-}
-
-static void __exit dma_test_exit(void)
-{
-		dma_release_channel(DmaMemInfo[0].dma_chan);
-		platform_driver_unregister(&dma_mempcy_driver);
-}
-
-late_initcall(dma_test_init);
-module_exit(dma_test_exit);
-
-MODULE_DESCRIPTION("RK29 PL330 Dma Test Deiver");
-MODULE_LICENSE("GPL V2");
-MODULE_AUTHOR("ZhenFu Fang <fzf@rock-chips.com>");
-MODULE_AUTHOR("Hong Huibin<hhb@rock-chips.com>");
diff --git a/arch/arm/mach-rockchip/dvfs.c b/arch/arm/mach-rockchip/dvfs.c
deleted file mode 100644
index 18d98e4dfccc..000000000000
--- a/arch/arm/mach-rockchip/dvfs.c
+++ /dev/null
@@ -1,2655 +0,0 @@
-/* arch/arm/mach-rk30/rk30_dvfs.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/regulator/consumer.h>
-#include <linux/delay.h>
-#include <linux/stat.h>
-#include <linux/of.h>
-#include <linux/opp.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/common.h>
-#include <linux/fb.h>
-#include <linux/reboot.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/tick.h>
-#include <dt-bindings/clock/rk_system_status.h>
-#include "../../../drivers/clk/rockchip/clk-pd.h"
-#include "efuse.h"
-
-#define MHz	(1000 * 1000)
-static LIST_HEAD(rk_dvfs_tree);
-static DEFINE_MUTEX(rk_dvfs_mutex);
-static struct workqueue_struct *dvfs_wq;
-static struct dvfs_node *clk_cpu_b_dvfs_node;
-static struct dvfs_node *clk_cpu_l_dvfs_node;
-static struct dvfs_node *clk_cpu_bl_dvfs_node;
-static struct dvfs_node *clk_cpu_dvfs_node;
-static struct dvfs_node *clk_gpu_dvfs_node;
-static int pd_gpu_off, early_suspend;
-static DEFINE_MUTEX(switch_vdd_gpu_mutex);
-struct regulator *vdd_gpu_regulator;
-static DEFINE_MUTEX(temp_limit_mutex);
-
-static int dvfs_get_temp(int chn)
-{
-	int temp = INVALID_TEMP;
-
-#if IS_ENABLED(CONFIG_ROCKCHIP_THERMAL)
-	int read_back = 0;
-
-	if (clk_cpu_bl_dvfs_node == NULL ||
-	    IS_ERR_OR_NULL(clk_cpu_bl_dvfs_node->vd->regulator))
-		return temp;
-
-	mutex_lock(&clk_cpu_bl_dvfs_node->vd->mutex);
-	read_back = dvfs_regulator_get_voltage(
-		clk_cpu_bl_dvfs_node->vd->regulator);
-	temp = rockchip_tsadc_get_temp(chn, read_back);
-	mutex_unlock(&clk_cpu_bl_dvfs_node->vd->mutex);
-#else
-	temp = rockchip_tsadc_get_temp(chn);
-#endif
-
-	return temp;
-}
-
-static int pvtm_get_temp(struct dvfs_node *dvfs_node, int chn)
-{
-	int temp = INVALID_TEMP;
-
-#if IS_ENABLED(CONFIG_ROCKCHIP_THERMAL)
-	int read_back = 0;
-
-	if (dvfs_node == NULL ||
-	    IS_ERR_OR_NULL(dvfs_node->vd->regulator))
-		return temp;
-	read_back = dvfs_regulator_get_voltage(
-		dvfs_node->vd->regulator);
-	temp = rockchip_tsadc_get_temp(chn, read_back);
-#else
-	temp = rockchip_tsadc_get_temp(chn);
-#endif
-
-	return temp;
-}
-
-
-static int vdd_gpu_reboot_notifier_event(struct notifier_block *this,
-	unsigned long event, void *ptr)
-{
-	int ret;
-
-	DVFS_DBG("%s: enable vdd_gpu\n", __func__);
-	mutex_lock(&switch_vdd_gpu_mutex);
-	if (!regulator_is_enabled(vdd_gpu_regulator))
-		ret = regulator_enable(vdd_gpu_regulator);
-	mutex_unlock(&switch_vdd_gpu_mutex);
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block vdd_gpu_reboot_notifier = {
-	.notifier_call = vdd_gpu_reboot_notifier_event,
-};
-
-static int clk_pd_gpu_notifier_call(struct notifier_block *nb,
-	unsigned long event, void *ptr)
-{
-	int ret;
-
-	switch (event) {
-	case RK_CLK_PD_PREPARE:
-		mutex_lock(&switch_vdd_gpu_mutex);
-		pd_gpu_off = 0;
-		if (early_suspend) {
-			if (!regulator_is_enabled(vdd_gpu_regulator))
-				ret = regulator_enable(vdd_gpu_regulator);
-		}
-		mutex_unlock(&switch_vdd_gpu_mutex);
-		break;
-	case RK_CLK_PD_UNPREPARE:
-		mutex_lock(&switch_vdd_gpu_mutex);
-		pd_gpu_off = 1;
-		if (early_suspend) {
-			if (regulator_is_enabled(vdd_gpu_regulator))
-				ret = regulator_disable(vdd_gpu_regulator);
-		}
-		mutex_unlock(&switch_vdd_gpu_mutex);
-		break;
-	default:
-		break;
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block clk_pd_gpu_notifier = {
-	.notifier_call = clk_pd_gpu_notifier_call,
-};
-
-
-static int early_suspend_notifier_call(struct notifier_block *self,
-				unsigned long action, void *data)
-{
-	struct fb_event *event = data;
-	int blank_mode = *((int *)event->data);
-	int ret;
-
-	mutex_lock(&switch_vdd_gpu_mutex);
-	if (action == FB_EARLY_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			early_suspend = 0;
-			if (pd_gpu_off) {
-				if (!regulator_is_enabled(vdd_gpu_regulator))
-					ret = regulator_enable(
-					vdd_gpu_regulator);
-			}
-			break;
-		default:
-			break;
-		}
-	} else if (action == FB_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_POWERDOWN:
-			early_suspend = 1;
-			if (pd_gpu_off) {
-				if (regulator_is_enabled(vdd_gpu_regulator))
-					ret = regulator_disable(
-					vdd_gpu_regulator);
-			}
-
-			break;
-		default:
-			break;
-		}
-	}
-	mutex_unlock(&switch_vdd_gpu_mutex);
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block early_suspend_notifier = {
-		.notifier_call = early_suspend_notifier_call,
-};
-
-#define DVFS_REGULATOR_MODE_STANDBY	1
-#define DVFS_REGULATOR_MODE_IDLE	2
-#define DVFS_REGULATOR_MODE_NORMAL	3
-#define DVFS_REGULATOR_MODE_FAST	4
-
-static const char* dvfs_regu_mode_to_string(unsigned int mode)
-{
-	switch (mode) {
-	case DVFS_REGULATOR_MODE_FAST:
-		return "FAST";
-	case DVFS_REGULATOR_MODE_NORMAL:
-		return "NORMAL";
-	case DVFS_REGULATOR_MODE_IDLE:
-		return "IDLE";
-	case DVFS_REGULATOR_MODE_STANDBY:
-		return "STANDBY";
-	default:
-		return "UNKNOWN";
-	}
-}
-
-static int dvfs_regu_mode_convert(unsigned int mode)
-{
-	switch (mode) {
-        case DVFS_REGULATOR_MODE_FAST:
-                return REGULATOR_MODE_FAST;
-        case DVFS_REGULATOR_MODE_NORMAL:
-                return REGULATOR_MODE_NORMAL;
-        case DVFS_REGULATOR_MODE_IDLE:
-                return REGULATOR_MODE_IDLE;
-        case DVFS_REGULATOR_MODE_STANDBY:
-                return REGULATOR_MODE_STANDBY;
-        default:
-                return -EINVAL;
-        }
-}
-
-static int dvfs_regu_mode_deconvert(unsigned int mode)
-{
-	switch (mode) {
-        case REGULATOR_MODE_FAST:
-                return DVFS_REGULATOR_MODE_FAST;
-        case REGULATOR_MODE_NORMAL:
-                return DVFS_REGULATOR_MODE_NORMAL;
-        case REGULATOR_MODE_IDLE:
-                return DVFS_REGULATOR_MODE_IDLE;
-        case REGULATOR_MODE_STANDBY:
-                return DVFS_REGULATOR_MODE_STANDBY;
-        default:
-                return -EINVAL;
-        }
-}
-
-static struct cpufreq_frequency_table *of_get_regu_mode_table(struct device_node *dev_node)
-{
-	struct cpufreq_frequency_table *regu_mode_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(dev_node, "regu-mode-table", NULL);
-	if (!prop)
-		return NULL;
-	if (!prop->value)
-		return NULL;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return NULL;
-	}
-
-	regu_mode_table = kzalloc(sizeof(struct cpufreq_frequency_table) *
-			     (nr/2+1), GFP_KERNEL);
-	if (!regu_mode_table) {
-		pr_err("%s: could not allocate regu_mode_table!\n", __func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	val = prop->value;
-
-	for (i=0; i<nr/2; i++){
-		regu_mode_table[i].frequency = be32_to_cpup(val++) * 1000;
-		regu_mode_table[i].index = be32_to_cpup(val++);
-	}
-
-	if (regu_mode_table[i-1].frequency != 0) {
-		pr_err("%s: Last freq of regu_mode_table is not 0!\n", __func__);
-		kfree(regu_mode_table);
-		return NULL;
-	}
-
-	regu_mode_table[i].index = 0;
-	regu_mode_table[i].frequency = CPUFREQ_TABLE_END;
-
-	return regu_mode_table;
-}
-
-static int dvfs_regu_mode_table_constrain(struct dvfs_node *clk_dvfs_node)
-{
-	int i, ret;
-	int mode, convert_mode, valid_mode;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	if (!clk_dvfs_node->regu_mode_table)
-		return -EINVAL;
-
-	if (!clk_dvfs_node->vd)
-		return -EINVAL;
-
-	if (IS_ERR_OR_NULL(clk_dvfs_node->vd->regulator))
-		return -EINVAL;
-
-	for (i = 0; (clk_dvfs_node->regu_mode_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-		mode = clk_dvfs_node->regu_mode_table[i].index;
-		convert_mode = dvfs_regu_mode_convert(mode);
-
-		ret = regulator_is_supported_mode(clk_dvfs_node->vd->regulator,
-						&convert_mode);
-		if (ret) {
-			DVFS_ERR("%s: find mode=%d unsupported\n", __func__,
-				mode);
-			kfree(clk_dvfs_node->regu_mode_table);
-			clk_dvfs_node->regu_mode_table = NULL;
-			return ret;
-		}
-
-		valid_mode = dvfs_regu_mode_deconvert(convert_mode);
-		if (valid_mode != mode) {
-			DVFS_ERR("%s: round mode=%d to valid mode=%d!\n",
-				__func__, mode, valid_mode);
-			clk_dvfs_node->regu_mode_table[i].index = valid_mode;
-		}
-
-	}
-
-	return 0;
-}
-
-static int clk_dvfs_node_get_regu_mode(struct dvfs_node *clk_dvfs_node,
-	unsigned long rate, unsigned int *mode)
-{
-	int i;
-
-
-	if ((!clk_dvfs_node) || (!clk_dvfs_node->regu_mode_table))
-		return -EINVAL;
-
-	for (i = 0; (clk_dvfs_node->regu_mode_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-		if (rate >= clk_dvfs_node->regu_mode_table[i].frequency) {
-			*mode = clk_dvfs_node->regu_mode_table[i].index;
-			return 0;
-		}
-	}
-
-	return -EINVAL;
-}
-
-static int dvfs_pd_get_newmode_byclk(struct pd_node *pd, struct dvfs_node *clk_dvfs_node)
-{
-	unsigned int mode_max = 0;
-
-
-	if (clk_dvfs_node->regu_mode_en && (clk_dvfs_node->regu_mode >= pd->regu_mode)) {
-		return clk_dvfs_node->regu_mode;
-	}
-
-	list_for_each_entry(clk_dvfs_node, &pd->clk_list, node) {
-		if (clk_dvfs_node->regu_mode_en)
-			mode_max = max(mode_max, (clk_dvfs_node->regu_mode));
-	}
-
-	return mode_max;
-}
-
-static void dvfs_update_clk_pds_mode(struct dvfs_node *clk_dvfs_node)
-{
-	struct pd_node *pd;
-
-	if (!clk_dvfs_node)
-		return;
-
-	pd = clk_dvfs_node->pd;
-	if (!pd)
-		return;
-
-	pd->regu_mode = dvfs_pd_get_newmode_byclk(pd, clk_dvfs_node);
-}
-
-static int dvfs_vd_get_newmode_bypd(struct vd_node *vd)
-{
-	unsigned int mode_max_vd = 0;
-	struct pd_node *pd;
-
-	if (!vd)
-		return -EINVAL;
-
-	list_for_each_entry(pd, &vd->pd_list, node) {
-		mode_max_vd = max(mode_max_vd, pd->regu_mode);
-	}
-
-	return mode_max_vd;
-}
-
-static int dvfs_vd_get_newmode_byclk(struct dvfs_node *clk_dvfs_node)
-{
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	dvfs_update_clk_pds_mode(clk_dvfs_node);
-
-	return  dvfs_vd_get_newmode_bypd(clk_dvfs_node->vd);
-}
-
-static int dvfs_regu_set_mode(struct vd_node *vd, unsigned int mode)
-{
-	int convert_mode;
-	int ret = 0;
-
-
-	if (IS_ERR_OR_NULL(vd)) {
-		DVFS_ERR("%s: vd_node error\n", __func__);
-		return -EINVAL;
-	}
-
-	DVFS_DBG("%s: mode=%d(old=%d)\n", __func__, mode, vd->regu_mode);
-
-	convert_mode = dvfs_regu_mode_convert(mode);
-	if (convert_mode < 0) {
-		DVFS_ERR("%s: mode %d convert error\n", __func__, mode);
-		return convert_mode;
-	}
-
-	if (!IS_ERR_OR_NULL(vd->regulator)) {
-		ret = dvfs_regulator_set_mode(vd->regulator, convert_mode);
-		if (ret < 0) {
-			DVFS_ERR("%s: %s set mode %d (was %d) error!\n", __func__,
-				vd->regulator_name, mode, vd->regu_mode);
-			return -EAGAIN;
-		}
-	} else {
-		DVFS_ERR("%s: invalid regulator\n", __func__);
-		return -EINVAL;
-	}
-
-	vd->regu_mode = mode;
-
-	return 0;
-}
-
-static int dvfs_regu_mode_target(struct dvfs_node *clk_dvfs_node, unsigned long rate)
-{
-	int ret;
-	int mode;
-
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	if (!clk_dvfs_node->regu_mode_en)
-		return 0;
-
-	ret = clk_dvfs_node_get_regu_mode(clk_dvfs_node, rate, &mode);
-	if (ret) {
-		DVFS_ERR("%s: clk(%s) rate %luhz get mode fail\n",
-			__func__, clk_dvfs_node->name, rate);
-		return ret;
-	}
-	clk_dvfs_node->regu_mode = mode;
-
-	mode = dvfs_vd_get_newmode_byclk(clk_dvfs_node);
-	if (mode < 0)
-		return mode;
-
-	ret = dvfs_regu_set_mode(clk_dvfs_node->vd, mode);
-
-	return ret;
-}
-
-static void dvfs_volt_up_delay(struct vd_node *vd, int new_volt, int old_volt)
-{
-	int u_time;
-	
-	if(new_volt <= old_volt)
-		return;
-	if(vd->volt_time_flag > 0)	
-		u_time = regulator_set_voltage_time(vd->regulator, old_volt, new_volt);
-	else
-		u_time = -1;		
-	if(u_time < 0) {// regulator is not suported time,useing default time
-		DVFS_DBG("%s:vd %s is not suported getting delay time,so we use default\n",
-				__func__, vd->name);
-		u_time = ((new_volt) - (old_volt)) >> 9;
-	}
-	
-	DVFS_DBG("%s: vd %s volt %d to %d delay %d us\n", 
-		__func__, vd->name, old_volt, new_volt, u_time);
-	
-	if (u_time >= 1000) {
-		mdelay(u_time / 1000);
-		udelay(u_time % 1000);
-		DVFS_WARNING("%s: regulator set vol delay is larger 1ms,old is %d,new is %d\n",
-			__func__, old_volt, new_volt);
-	} else if (u_time) {
-		udelay(u_time);
-	}			
-}
-
-static int dvfs_regulator_set_voltage_readback(struct regulator *regulator, int min_uV, int max_uV)
-{
-	int ret = 0, read_back = 0;
-	
-	ret = dvfs_regulator_set_voltage(regulator, max_uV, max_uV);
-	if (ret < 0) {
-		DVFS_ERR("%s: now read back to check voltage\n", __func__);
-
-		/* read back to judge if it is already effect */
-		mdelay(2);
-		read_back = dvfs_regulator_get_voltage(regulator);
-		if (read_back == max_uV) {
-			DVFS_ERR("%s: set ERROR but already effected, volt=%d\n", __func__, read_back);
-			ret = 0;
-		} else {
-			DVFS_ERR("%s: set ERROR AND NOT effected, volt=%d\n", __func__, read_back);
-		}
-	}
-	
-	return ret;
-}
-
-static int dvfs_scale_volt_direct(struct vd_node *vd_clk, int volt_new)
-{
-	int ret = 0;
-	
-	DVFS_DBG("%s: volt=%d(old=%d)\n", __func__, volt_new, vd_clk->cur_volt);
-	
-	if (IS_ERR_OR_NULL(vd_clk)) {
-		DVFS_ERR("%s: vd_node error\n", __func__);
-		return -EINVAL;
-	}
-
-	if (!IS_ERR_OR_NULL(vd_clk->regulator)) {
-		ret = dvfs_regulator_set_voltage_readback(vd_clk->regulator, volt_new, volt_new);
-		dvfs_volt_up_delay(vd_clk,volt_new, vd_clk->cur_volt);
-		if (ret < 0) {
-			vd_clk->volt_set_flag = DVFS_SET_VOLT_FAILURE;
-			DVFS_ERR("%s: %s set voltage up err ret = %d, Vnew = %d(was %d)mV\n",
-					__func__, vd_clk->name, ret, volt_new, vd_clk->cur_volt);
-			return -EAGAIN;
-		}
-
-	} else {
-		DVFS_ERR("%s: invalid regulator\n", __func__);
-		return -EINVAL;
-	}
-
-	vd_clk->volt_set_flag = DVFS_SET_VOLT_SUCCESS;
-	vd_clk->cur_volt = volt_new;
-
-	return 0;
-
-}
-
-static int dvfs_reset_volt(struct vd_node *dvfs_vd)
-{
-	int flag_set_volt_correct = 0;
-	if (!IS_ERR_OR_NULL(dvfs_vd->regulator))
-		flag_set_volt_correct = dvfs_regulator_get_voltage(dvfs_vd->regulator);
-	else {
-		DVFS_ERR("%s: invalid regulator\n", __func__);
-		return -EINVAL;
-	}
-	if (flag_set_volt_correct <= 0) {
-		DVFS_ERR("%s (vd:%s), try to reload volt ,by it is error again(%d)!!! stop scaling\n",
-				__func__, dvfs_vd->name, flag_set_volt_correct);
-		return -EAGAIN;
-	}
-	dvfs_vd->volt_set_flag = DVFS_SET_VOLT_SUCCESS;
-	DVFS_WARNING("%s:vd(%s) try to reload volt = %d\n",
-			__func__, dvfs_vd->name, flag_set_volt_correct);
-
-	/* Reset vd's voltage */
-	dvfs_vd->cur_volt = flag_set_volt_correct;
-
-	return dvfs_vd->cur_volt;
-}
-
-
-// for clk enable case to get vd regulator info
-static void clk_enable_dvfs_regulator_check(struct vd_node *vd)
-{
-	vd->cur_volt = dvfs_regulator_get_voltage(vd->regulator);
-	if(vd->cur_volt <= 0){
-		vd->volt_set_flag = DVFS_SET_VOLT_FAILURE;
-	}
-	vd->volt_set_flag = DVFS_SET_VOLT_SUCCESS;
-}
-
-static void dvfs_get_vd_regulator_volt_list(struct vd_node *vd)
-{
-	unsigned int i, selector = dvfs_regulator_count_voltages(vd->regulator);
-	int n = 0, sel_volt = 0;
-	
-	if(selector > VD_VOL_LIST_CNT)
-		selector = VD_VOL_LIST_CNT;
-
-	for (i = 0; i < selector; i++) {
-		sel_volt = dvfs_regulator_list_voltage(vd->regulator, i);
-		if(sel_volt <= 0){	
-			//DVFS_WARNING("%s: vd(%s) list volt selector=%u, but volt(%d) <=0\n",
-			//	__func__, vd->name, i, sel_volt);
-			continue;
-		}
-		vd->volt_list[n++] = sel_volt;	
-		DVFS_DBG("%s: vd(%s) list volt selector=%u, n=%d, volt=%d\n", 
-			__func__, vd->name, i, n, sel_volt);
-	}
-	
-	vd->n_voltages = n;
-}
-
-// >= volt
-static int vd_regulator_round_volt_max(struct vd_node *vd, int volt)
-{
-	int sel_volt;
-	int i;
-	
-	for (i = 0; i < vd->n_voltages; i++) {
-		sel_volt = vd->volt_list[i];
-		if(sel_volt <= 0){	
-			DVFS_WARNING("%s: selector=%u, but volt <=0\n", 
-				__func__, i);
-			continue;
-		}
-		if(sel_volt >= volt)
-			return sel_volt;	
-	}
-	return -EINVAL;
-}
-
-// >=volt
-static int vd_regulator_round_volt_min(struct vd_node *vd, int volt)
-{
-	int sel_volt;
-	int i;
-	
-	for (i = 0; i < vd->n_voltages; i++) {
-		sel_volt = vd->volt_list[i];
-		if(sel_volt <= 0){	
-			DVFS_WARNING("%s: selector=%u, but volt <=0\n", 
-				__func__, i);
-			continue;
-		}
-		if(sel_volt > volt){
-			if(i > 0)
-				return vd->volt_list[i-1];
-			else
-				return -EINVAL;
-		}	
-	}
-	
-	return -EINVAL;
-}
-
-// >=volt
-static int vd_regulator_round_volt(struct vd_node *vd, int volt, int flags)
-{
-	if(!vd->n_voltages)
-		return -EINVAL;
-	if(flags == VD_LIST_RELATION_L)
-		return vd_regulator_round_volt_min(vd, volt);
-	else
-		return vd_regulator_round_volt_max(vd, volt);	
-}
-
-static void dvfs_table_round_volt(struct dvfs_node *clk_dvfs_node)
-{
-	int i, test_volt;
-
-	if(!clk_dvfs_node->dvfs_table || !clk_dvfs_node->vd || 
-		IS_ERR_OR_NULL(clk_dvfs_node->vd->regulator))
-		return;
-
-	for (i = 0; (clk_dvfs_node->dvfs_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-
-		test_volt = vd_regulator_round_volt(clk_dvfs_node->vd, clk_dvfs_node->dvfs_table[i].index, VD_LIST_RELATION_H);
-		if(test_volt <= 0)
-		{	
-			DVFS_WARNING("%s: clk(%s) round volt(%d) but list <=0\n",
-				__func__, clk_dvfs_node->name, clk_dvfs_node->dvfs_table[i].index);
-			break;
-		}
-		DVFS_DBG("clk %s:round_volt %d to %d\n",
-			clk_dvfs_node->name, clk_dvfs_node->dvfs_table[i].index, test_volt);
-		
-		clk_dvfs_node->dvfs_table[i].index=test_volt;		
-	}
-}
-
-static void dvfs_vd_get_regulator_volt_time_info(struct vd_node *vd)
-{
-	if(vd->volt_time_flag <= 0){// check regulator support get uping vol timer
-		vd->volt_time_flag = dvfs_regulator_set_voltage_time(vd->regulator, vd->cur_volt, vd->cur_volt+200*1000);
-		if(vd->volt_time_flag < 0){
-			DVFS_DBG("%s,vd %s volt_time is no support\n",
-				__func__, vd->name);
-		}
-		else{
-			DVFS_DBG("%s,vd %s volt_time is support,up 200mv need delay %d us\n",
-				__func__, vd->name, vd->volt_time_flag);
-		}	
-	}
-}
-#if 0
-static void dvfs_vd_get_regulator_mode_info(struct vd_node *vd)
-{
-	//REGULATOR_MODE_FAST
-	if(vd->mode_flag <= 0){// check regulator support get uping vol timer{
-		vd->mode_flag = dvfs_regulator_get_mode(vd->regulator);
-		if(vd->mode_flag==REGULATOR_MODE_FAST || vd->mode_flag==REGULATOR_MODE_NORMAL
-			|| vd->mode_flag == REGULATOR_MODE_IDLE || vd->mode_flag==REGULATOR_MODE_STANDBY){
-			
-			if(dvfs_regulator_set_mode(vd->regulator, vd->mode_flag) < 0){
-				vd->mode_flag = 0;// check again
-			}
-		}
-		if(vd->mode_flag > 0){
-			DVFS_DBG("%s,vd %s mode(now is %d) support\n",
-				__func__, vd->name, vd->mode_flag);
-		}
-		else{
-			DVFS_DBG("%s,vd %s mode is not support now check\n",
-				__func__, vd->name);
-		}
-	}
-}
-#endif
-
-struct regulator *dvfs_get_regulator(char *regulator_name) 
-{
-	struct vd_node *vd;
-
-	mutex_lock(&rk_dvfs_mutex);
-	list_for_each_entry(vd, &rk_dvfs_tree, node) {
-		if (strcmp(regulator_name, vd->regulator_name) == 0) {
-			mutex_unlock(&rk_dvfs_mutex);
-			return vd->regulator;
-		}
-	}
-	mutex_unlock(&rk_dvfs_mutex);
-	return NULL;
-}
-
-static int dvfs_get_rate_range(struct dvfs_node *clk_dvfs_node)
-{
-	struct cpufreq_frequency_table *table;
-	int i = 0;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	clk_dvfs_node->min_rate = 0;
-	clk_dvfs_node->max_rate = 0;
-
-	table = clk_dvfs_node->dvfs_table;
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		clk_dvfs_node->max_rate = table[i].frequency / 1000 * 1000 * 1000;
-		if (i == 0)
-			clk_dvfs_node->min_rate = table[i].frequency / 1000 * 1000 * 1000;
-	}
-
-	DVFS_DBG("%s: clk %s, limit rate [min, max] = [%u, %u]\n",
-			__func__, clk_dvfs_node->name, clk_dvfs_node->min_rate, clk_dvfs_node->max_rate);
-
-	return 0;
-}
-
-static void dvfs_table_round_clk_rate(struct dvfs_node  *clk_dvfs_node)
-{
-	int i, rate, temp_rate, flags;
-	
-	if(!clk_dvfs_node || !clk_dvfs_node->dvfs_table || !clk_dvfs_node->clk)
-		return;
-
-	for (i = 0; (clk_dvfs_node->dvfs_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-		//ddr rate = real rate+flags
-		flags = clk_dvfs_node->dvfs_table[i].frequency%1000;
-		rate = (clk_dvfs_node->dvfs_table[i].frequency/1000)*1000;
-		temp_rate = __clk_round_rate(clk_dvfs_node->clk, rate*1000);
-		if(temp_rate <= 0){	
-			DVFS_WARNING("%s: clk(%s) rate %d round return %d\n",
-				__func__, clk_dvfs_node->name, clk_dvfs_node->dvfs_table[i].frequency, temp_rate);
-			continue;
-		}
-		
-		/* Set rate unit as MHZ */
-		if (temp_rate % MHz != 0)
-			temp_rate = (temp_rate / MHz + 1) * MHz;
-
-		temp_rate = (temp_rate / 1000) + flags;
-		
-		DVFS_DBG("clk %s round_clk_rate %d to %d\n",
-			clk_dvfs_node->name,clk_dvfs_node->dvfs_table[i].frequency, temp_rate);
-		
-		clk_dvfs_node->dvfs_table[i].frequency = temp_rate;		
-	}
-}
-
-static int clk_dvfs_node_get_ref_volt(struct dvfs_node *clk_dvfs_node, int rate_khz,
-		struct cpufreq_frequency_table *clk_fv)
-{
-	int i = 0;
-	
-	if (rate_khz == 0 || !clk_dvfs_node || !clk_dvfs_node->dvfs_table) {
-		/* since no need */
-		return -EINVAL;
-	}
-	clk_fv->frequency = rate_khz;
-	clk_fv->index = 0;
-
-	for (i = 0; (clk_dvfs_node->dvfs_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-		if (clk_dvfs_node->dvfs_table[i].frequency >= rate_khz) {
-			clk_fv->frequency = clk_dvfs_node->dvfs_table[i].frequency;
-			clk_fv->index = clk_dvfs_node->dvfs_table[i].index;
-			 //printk("%s,%s rate=%ukhz(vol=%d)\n",__func__,clk_dvfs_node->name,
-			 //clk_fv->frequency, clk_fv->index);
-			return 0;
-		}
-	}
-	clk_fv->frequency = 0;
-	clk_fv->index = 0;
-	//DVFS_DBG("%s get corresponding voltage error! out of bound\n", clk_dvfs_node->name);
-	return -EINVAL;
-}
-
-static int dvfs_pd_get_newvolt_byclk(struct pd_node *pd, struct dvfs_node *clk_dvfs_node)
-{
-	int volt_max = 0;
-
-	if (clk_dvfs_node->enable_count && (clk_dvfs_node->set_volt >= pd->cur_volt)) {
-		return clk_dvfs_node->set_volt;
-	}
-
-	list_for_each_entry(clk_dvfs_node, &pd->clk_list, node) {
-		if (clk_dvfs_node->enable_count)
-			volt_max = max(volt_max, clk_dvfs_node->set_volt);
-	}
-	return volt_max;
-}
-
-static void dvfs_update_clk_pds_volt(struct dvfs_node *clk_dvfs_node)
-{
-	struct pd_node *pd;
-	
-	if (!clk_dvfs_node)
-		return;
-	
-	pd = clk_dvfs_node->pd;
-	if (!pd)
-		return;
-	
-	pd->cur_volt = dvfs_pd_get_newvolt_byclk(pd, clk_dvfs_node);
-}
-
-static int dvfs_vd_get_newvolt_bypd(struct vd_node *vd)
-{
-	int volt_max_vd = 0;
-	struct pd_node *pd;
-
-	if (!vd)
-		return -EINVAL;
-	
-	list_for_each_entry(pd, &vd->pd_list, node) {
-		volt_max_vd = max(volt_max_vd, pd->cur_volt);
-	}
-
-	return volt_max_vd;
-}
-
-static int dvfs_vd_get_newvolt_byclk(struct dvfs_node *clk_dvfs_node)
-{
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	dvfs_update_clk_pds_volt(clk_dvfs_node);
-	return  dvfs_vd_get_newvolt_bypd(clk_dvfs_node->vd);
-}
-
-#if 0
-static void dvfs_temp_limit_work_func(struct work_struct *work)
-{
-	unsigned long delay = HZ / 10; // 100ms
-	struct vd_node *vd;
-	struct pd_node *pd;
-	struct dvfs_node *clk_dvfs_node;
-
-	queue_delayed_work_on(0, dvfs_wq, to_delayed_work(work), delay);
-
-	mutex_lock(&rk_dvfs_mutex);
-	list_for_each_entry(vd, &rk_dvfs_tree, node) {
-		mutex_lock(&vd->mutex);
-		list_for_each_entry(pd, &vd->pd_list, node) {
-			list_for_each_entry(clk_dvfs_node, &pd->clk_list, node) {
-				if (clk_dvfs_node->temp_limit_table) {
-					clk_dvfs_node->temp = rockchip_tsadc_get_temp(clk_dvfs_node->temp_channel);
-					clk_dvfs_node->vd->vd_dvfs_target(clk_dvfs_node, clk_dvfs_node->last_set_rate);
-				}
-			}
-		}
-		mutex_unlock(&vd->mutex);
-	}
-	mutex_unlock(&rk_dvfs_mutex);
-}
-#endif
-
-static struct cpufreq_frequency_table rk3288v0_arm_pvtm_table[] = {
-	{.frequency = 216000,  .index = 4006},
-	{.frequency = 408000,  .index = 6518},
-	{.frequency = 600000,  .index = 8345},
-	{.frequency = 816000,  .index = 11026},
-	{.frequency = 1008000,  .index = 12906},
-	{.frequency = 1200000,  .index = 15532},
-	{.frequency = 1416000,  .index = 18076},
-	{.frequency = 1608000,  .index = 21282},
-	{.frequency = CPUFREQ_TABLE_END, .index = 1},
-};
-
-static struct pvtm_info rk3288v0_arm_pvtm_info = {
-	.compatible = "rockchip,rk3288",
-	.pvtm_table = rk3288v0_arm_pvtm_table,
-	.channel = ARM_DVFS_CH,
-	.process_version = RK3288_PROCESS_V0,
-	.scan_rate_hz = 216000000,
-	.sample_time_us = 1000,
-	.volt_step_uv = 12500,
-	.delta_pvtm_by_volt = 400,
-	.delta_pvtm_by_temp = 14,
-	.volt_margin_uv = 25000,
-	.min_volt_uv = 850000,
-	.max_volt_uv = 1400000,
-	.cluster = 0,
-};
-
-static struct cpufreq_frequency_table rk3288v1_arm_pvtm_table[] = {
-	{.frequency = 216000,  .index = 4710},
-	{.frequency = 408000,  .index = 7200},
-	{.frequency = 600000,  .index = 9192},
-	{.frequency = 816000,  .index = 12560},
-	{.frequency = 1008000,  .index = 14741},
-	{.frequency = 1200000,  .index = 16886},
-	{.frequency = 1416000,  .index = 20081},
-	{.frequency = 1608000,  .index = 24061},
-	{.frequency = CPUFREQ_TABLE_END, .index = 1},
-};
-
-static struct pvtm_info rk3288v1_arm_pvtm_info = {
-	.compatible = "rockchip,rk3288",
-	.pvtm_table = rk3288v1_arm_pvtm_table,
-	.channel = ARM_DVFS_CH,
-	.process_version = RK3288_PROCESS_V1,
-	.scan_rate_hz = 216000000,
-	.sample_time_us = 1000,
-	.volt_step_uv = 12500,
-	.delta_pvtm_by_volt = 450,
-	.delta_pvtm_by_temp = 7,
-	.volt_margin_uv = 25000,
-	.min_volt_uv = 850000,
-	.max_volt_uv = 1400000,
-	.cluster = 0,
-};
-
-static struct cpufreq_frequency_table rk3288v2_arm_pvtm_table[] = {
-	{.frequency = 216000,  .index = 5369},
-	{.frequency = 408000,  .index = 6984},
-	{.frequency = 600000,  .index = 8771},
-	{.frequency = 816000,  .index = 11434},
-	{.frequency = 1008000,  .index = 14178},
-	{.frequency = 1200000,  .index = 16797},
-	{.frequency = 1416000,  .index = 20178},
-	{.frequency = 1608000,  .index = 23303},
-	{.frequency = CPUFREQ_TABLE_END, .index = 1},
-};
-
-static struct pvtm_info rk3288v2_arm_pvtm_info = {
-	.compatible = "rockchip,rk3288",
-	.pvtm_table = rk3288v2_arm_pvtm_table,
-	.channel = ARM_DVFS_CH,
-	.process_version = RK3288_PROCESS_V2,
-	.scan_rate_hz = 216000000,
-	.sample_time_us = 1000,
-	.volt_step_uv = 12500,
-	.delta_pvtm_by_volt = 430,
-	.delta_pvtm_by_temp = 12,
-	.volt_margin_uv = 25000,
-	.min_volt_uv = 900000,
-	.max_volt_uv = 1400000,
-	.cluster = 0,
-};
-
-static struct cpufreq_frequency_table rk3368v0_arm_b_pvtm_table[] = {
-	{.frequency = 216000,  .index = 9891},
-	{.frequency = 312000,  .index = 9891},
-	{.frequency = 408000,  .index = 9891},
-	{.frequency = 600000,  .index = 9891},
-	{.frequency = 696000,  .index = 10115},
-	{.frequency = 816000,  .index = 11014},
-	{.frequency = 1008000,  .index = 13650},
-	{.frequency = 1200000,  .index = 16520},
-	{.frequency = 1296000,  .index = 17856},
-	{.frequency = 1416000,  .index = 19662},
-	{.frequency = 1512000,  .index = 21069},
-	{.frequency = CPUFREQ_TABLE_END, .index = 1},
-};
-
-static struct pvtm_info rk3368v0_arm_b_pvtm_info = {
-	.compatible = "rockchip,rk3368",
-	.pvtm_table = rk3368v0_arm_b_pvtm_table,
-	.channel = ARM_DVFS_CH,
-	.process_version = 0,
-	.scan_rate_hz = 216000000,
-	.sample_time_us = 1000,
-	.volt_step_uv = 12500,
-	.delta_pvtm_by_volt = 350,
-	.delta_pvtm_by_temp = 12,
-	.volt_margin_uv = 50000,
-	.min_volt_uv = 925000,
-	.max_volt_uv = 1375000,
-	.cluster = 0,
-};
-
-static struct cpufreq_frequency_table rk3368v0_arm_l_pvtm_table[] = {
-	{.frequency = 216000,  .index = 9913},
-	{.frequency = 312000,  .index = 9913},
-	{.frequency = 408000,  .index = 9913},
-	{.frequency = 600000,  .index = 9913},
-	{.frequency = 696000,  .index = 11056},
-	{.frequency = 816000,  .index = 12816},
-	{.frequency = 1008000,  .index = 15613},
-	{.frequency = 1200000,  .index = 18329},
-	{.frequency = CPUFREQ_TABLE_END, .index = 1},
-};
-
-static struct pvtm_info rk3368v0_arm_l_pvtm_info = {
-	.compatible = "rockchip,rk3368",
-	.pvtm_table = rk3368v0_arm_l_pvtm_table,
-	.channel = ARM_DVFS_CH,
-	.process_version = 0,
-	.scan_rate_hz = 216000000,
-	.sample_time_us = 1000,
-	.volt_step_uv = 12500,
-	.delta_pvtm_by_volt = 350,
-	.delta_pvtm_by_temp = 12,
-	.volt_margin_uv = 50000,
-	.min_volt_uv = 925000,
-	.max_volt_uv = 1375000,
-	.cluster = 1,
-};
-
-
-static struct pvtm_info *pvtm_info_table[] = {
-	&rk3288v0_arm_pvtm_info,
-	&rk3288v1_arm_pvtm_info,
-	&rk3288v2_arm_pvtm_info,
-	&rk3368v0_arm_b_pvtm_info,
-	&rk3368v0_arm_l_pvtm_info
-};
-
-static int pvtm_set_single_dvfs(struct dvfs_node *dvfs_node, u32 idx,
-				struct pvtm_info *info, int *pvtm_list,
-				u32 min_pvtm)
-{
-	struct cpufreq_frequency_table *dvfs_table = dvfs_node->dvfs_table;
-	struct cpufreq_frequency_table *pvtm_table = dvfs_node->pvtm_table;
-	int target_pvtm, pvtm_margin, volt_margin;
-	unsigned int n_voltages = dvfs_node->vd->n_voltages;
-	int *volt_list = dvfs_node->vd->volt_list;
-	int n, temp;
-
-	volt_margin = info->volt_margin_uv + pvtm_table[idx].index;
-	n = volt_margin/info->volt_step_uv;
-	if (volt_margin%info->volt_step_uv)
-		n++;
-
-	pvtm_margin = n*info->delta_pvtm_by_volt;
-	if (cpu_is_rk3288())
-		temp = pvtm_get_temp(dvfs_node, 1);
-	else
-		temp = pvtm_get_temp(dvfs_node, 0);
-
-	if (temp < dvfs_node->pvtm_min_temp || temp == INVALID_TEMP)
-		temp = dvfs_node->pvtm_min_temp;
-
-	target_pvtm = min_pvtm+temp * info->delta_pvtm_by_temp + pvtm_margin;
-
-	DVFS_DBG("=====%s: temp:%d, freq:%d, target pvtm:%d=====\n",
-		 __func__, temp, dvfs_table[idx].frequency, target_pvtm);
-
-	for (n = 0; n < n_voltages; n++) {
-		if (pvtm_list[n] >= target_pvtm) {
-			dvfs_table[idx].index = volt_list[n];
-			DVFS_DBG("freq[%d]=%d, volt=%d\n",
-				 idx, dvfs_table[idx].frequency, volt_list[n]);
-
-			return 0;
-		}
-	}
-
-	return -EINVAL;
-
-	return 0;
-}
-
-static void pvtm_set_dvfs_table(struct dvfs_node *dvfs_node)
-{
-	struct cpufreq_frequency_table *dvfs_table = dvfs_node->dvfs_table;
-	struct pvtm_info *info = dvfs_node->pvtm_info;
-	struct regulator *regulator = dvfs_node->vd->regulator;
-	int i, j;
-	int ret = 0;
-	int pvtm_list[VD_VOL_LIST_CNT] = {0};
-	unsigned int n_voltages = dvfs_node->vd->n_voltages;
-	int *volt_list = dvfs_node->vd->volt_list;
-
-	if (!info)
-		return;
-
-	clk_set_rate(dvfs_node->clk, info->scan_rate_hz);
-	DVFS_DBG("%s:%lu\n", __func__, clk_get_rate(dvfs_node->clk));
-
-	for (i = 0; i < n_voltages; i++) {
-		if ((volt_list[i] >= info->min_volt_uv) &&
-		    (volt_list[i] <= info->max_volt_uv)) {
-			regulator_set_voltage(regulator, volt_list[i],
-					      volt_list[i]);
-			pvtm_list[i] = pvtm_get_value(info->channel,
-						      info->sample_time_us);
-		}
-	}
-
-	for (i = 0; dvfs_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		for (j = 0; info->pvtm_table[j].frequency !=
-		     CPUFREQ_TABLE_END; j++)
-			if (info->pvtm_table[j].frequency >=
-			    dvfs_table[i].frequency) {
-				int min_pvtm = info->pvtm_table[j].index;
-
-				ret = pvtm_set_single_dvfs(dvfs_node,
-							   i,
-							   info,
-							   pvtm_list,
-							   min_pvtm);
-				break;
-			}
-
-		if (ret) {
-			dvfs_node->max_limit_freq =
-				dvfs_table[i-1].frequency * 1000;
-			DVFS_WARNING("freq: %d can not reach target pvtm\n",
-				     dvfs_table[i].frequency);
-			DVFS_WARNING("max freq: %d\n",
-				     dvfs_node->max_limit_freq);
-			break;
-		}
-
-		if (info->pvtm_table[j].frequency == CPUFREQ_TABLE_END) {
-			DVFS_WARNING("not support freq :%d, max freq is %d\n",
-				     dvfs_table[i].frequency,
-				     info->pvtm_table[j-1].frequency);
-			break;
-		}
-	}
-}
-
-static void dvfs_virt_temp_limit_work_func(struct dvfs_node *dvfs_node)
-{
-	const struct cpufreq_frequency_table *limits_table = NULL;
-	unsigned int new_temp_limit_rate = -1;
-	unsigned int nr_cpus = num_online_cpus();
-	static bool in_perf;
-	int i;
-
-	if (!cpu_is_rk312x())
-		return;
-
-	if (rockchip_get_system_status() & SYS_STATUS_PERFORMANCE) {
-		in_perf = true;
-	} else if (in_perf) {
-		in_perf = false;
-	} else {
-		static u64 last_time_in_idle;
-		static u64 last_time_in_idle_timestamp;
-		u64 time_in_idle = 0, now;
-		u32 delta_idle;
-		u32 delta_time;
-		unsigned cpu, busy_cpus;
-
-		for_each_online_cpu(cpu) {
-			time_in_idle += get_cpu_idle_time_us(cpu, &now);
-		}
-		delta_time = now - last_time_in_idle_timestamp;
-		delta_idle = time_in_idle - last_time_in_idle;
-		last_time_in_idle = time_in_idle;
-		last_time_in_idle_timestamp = now;
-		delta_idle += delta_time >> 4; /* +6.25% */
-		if (delta_idle > (nr_cpus - 1)
-		    * delta_time && delta_idle < (nr_cpus + 1) * delta_time)
-			busy_cpus = 1;
-		else if (delta_idle > (nr_cpus - 2) * delta_time)
-			busy_cpus = 2;
-		else if (delta_idle > (nr_cpus - 3) * delta_time)
-			busy_cpus = 3;
-		else
-			busy_cpus = 4;
-
-		limits_table = dvfs_node->virt_temp_limit_table[busy_cpus-1];
-		DVFS_DBG("delta time %6u us idle %6u us %u cpus select table %d\n",
-			 delta_time, delta_idle, nr_cpus, busy_cpus);
-	}
-
-	if (limits_table) {
-		new_temp_limit_rate = limits_table[0].frequency;
-		for (i = 0; limits_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-			if (dvfs_node->target_temp >=
-				limits_table[i].index)
-				new_temp_limit_rate = limits_table[i].frequency;
-		}
-	}
-
-	if (dvfs_node->temp_limit_rate != new_temp_limit_rate) {
-		dvfs_node->temp_limit_rate = new_temp_limit_rate;
-		dvfs_clk_set_rate(dvfs_node, dvfs_node->last_set_rate);
-		DVFS_DBG("temp_limit_rate:%d\n",
-			 (int)dvfs_node->temp_limit_rate);
-	}
-}
-
-static void dvfs_temp_limit_performance(struct dvfs_node *dvfs_node, int temp)
-{
-	int i;
-
-	dvfs_node->temp_limit_rate = dvfs_node->max_rate;
-	for (i = 0; dvfs_node->per_temp_limit_table[i].frequency !=
-		CPUFREQ_TABLE_END; i++) {
-		if (temp > dvfs_node->per_temp_limit_table[i].index)
-			dvfs_node->temp_limit_rate =
-			dvfs_node->per_temp_limit_table[i].frequency;
-	}
-	dvfs_clk_set_rate(dvfs_node, dvfs_node->last_set_rate);
-}
-
-static void dvfs_temp_limit_normal(struct dvfs_node *dvfs_node, int temp)
-{
-	int delta_temp = 0;
-	unsigned long arm_rate_step = 0;
-	int i;
-
-	if (temp > dvfs_node->target_temp) {
-		if (temp > dvfs_node->old_temp) {
-			delta_temp = temp - dvfs_node->target_temp;
-			for (i = 0;
-			dvfs_node->nor_temp_limit_table[i].frequency !=
-				CPUFREQ_TABLE_END; i++) {
-				if (delta_temp >
-				dvfs_node->nor_temp_limit_table[i].index)
-					arm_rate_step =
-				dvfs_node->nor_temp_limit_table[i].frequency;
-			}
-			if (arm_rate_step &&
-			    (dvfs_node->temp_limit_rate > arm_rate_step)) {
-				dvfs_node->temp_limit_rate -= arm_rate_step;
-				if (dvfs_node->temp_limit_rate <
-					dvfs_node->min_temp_limit)
-					dvfs_node->temp_limit_rate =
-					dvfs_node->min_temp_limit;
-				dvfs_clk_set_rate(dvfs_node,
-						  dvfs_node->last_set_rate);
-			}
-		}
-	} else {
-		if (dvfs_node->temp_limit_rate < dvfs_node->max_rate) {
-			delta_temp = dvfs_node->target_temp - temp;
-			for (i = 0;
-			dvfs_node->nor_temp_limit_table[i].frequency !=
-				CPUFREQ_TABLE_END; i++) {
-				if (delta_temp >
-				dvfs_node->nor_temp_limit_table[i].index)
-					arm_rate_step =
-				dvfs_node->nor_temp_limit_table[i].frequency;
-			}
-
-			if (arm_rate_step) {
-				dvfs_node->temp_limit_rate += arm_rate_step;
-				if (dvfs_node->temp_limit_rate >
-					dvfs_node->max_rate)
-					dvfs_node->temp_limit_rate =
-					dvfs_node->max_rate;
-				dvfs_clk_set_rate(dvfs_node,
-						  dvfs_node->last_set_rate);
-			}
-		}
-	}
-}
-
-static void dvfs_temp_limit(struct dvfs_node *dvfs_node, int temp)
-{
-	int delta_temp = 0;
-
-	//debounce
-	delta_temp = (dvfs_node->old_temp > temp) ? (dvfs_node->old_temp-temp) :
-	(temp-dvfs_node->old_temp);
-	if (delta_temp <= 1)
-		return;
-
-	if (ROCKCHIP_PM_POLICY_PERFORMANCE == rockchip_pm_get_policy()) {
-		if (!dvfs_node->per_temp_limit_table)
-			return;
-		dvfs_temp_limit_performance(dvfs_node, temp);
-	} else if (ROCKCHIP_PM_POLICY_NORMAL == rockchip_pm_get_policy()){
-		if (!dvfs_node->nor_temp_limit_table)
-			return;
-		dvfs_temp_limit_normal(dvfs_node, temp);
-	}
-	dvfs_node->old_temp = temp;
-	DVFS_DBG("cur temp: %d, temp_limit_core_rate: %lu\n",
-		 temp, dvfs_node->temp_limit_rate);
-}
-
-static void dvfs_temp_limit_work_func(struct work_struct *work)
-{
-	unsigned long delay = HZ/10;
-	int temp = INVALID_TEMP;
-
-	queue_delayed_work_on(0, dvfs_wq, to_delayed_work(work), delay);
-
-	mutex_lock(&temp_limit_mutex);
-	if (clk_cpu_b_dvfs_node &&
-	    clk_cpu_b_dvfs_node->temp_limit_enable == 1) {
-		temp = dvfs_get_temp(0);
-		if (temp != INVALID_TEMP)
-			dvfs_temp_limit(clk_cpu_b_dvfs_node, temp);
-	}
-	if (clk_cpu_l_dvfs_node &&
-	    clk_cpu_l_dvfs_node->temp_limit_enable == 1) {
-		if (temp == INVALID_TEMP)
-			temp = dvfs_get_temp(0);
-		if (temp != INVALID_TEMP)
-			dvfs_temp_limit(clk_cpu_l_dvfs_node, temp);
-	}
-	if (clk_cpu_dvfs_node &&
-	    clk_cpu_dvfs_node->temp_limit_enable == 1) {
-		temp = dvfs_get_temp(1);
-		if (temp == INVALID_TEMP)
-			dvfs_virt_temp_limit_work_func(clk_cpu_dvfs_node);
-		else
-			dvfs_temp_limit(clk_cpu_dvfs_node, temp);
-	}
-	if (clk_gpu_dvfs_node &&
-	    clk_gpu_dvfs_node->temp_limit_enable == 1) {
-		temp = dvfs_get_temp(2);
-		if (temp != INVALID_TEMP)
-			dvfs_temp_limit(clk_gpu_dvfs_node, temp);
-	}
-	mutex_unlock(&temp_limit_mutex);
-}
-static DECLARE_DELAYED_WORK(dvfs_temp_limit_work, dvfs_temp_limit_work_func);
-
-int dvfs_clk_enable_limit(struct dvfs_node *clk_dvfs_node, unsigned int min_rate, unsigned int max_rate)
-{
-	u32 rate = 0, ret = 0;
-
-	if (!clk_dvfs_node || (min_rate > max_rate))
-		return -EINVAL;
-	
-	if (clk_dvfs_node->vd && clk_dvfs_node->vd->vd_dvfs_target){
-		mutex_lock(&clk_dvfs_node->vd->mutex);
-		
-		/* To reset clk_dvfs_node->min_rate/max_rate */
-		dvfs_get_rate_range(clk_dvfs_node);
-		clk_dvfs_node->freq_limit_en = 1;
-
-		if ((min_rate >= clk_dvfs_node->min_rate) && (min_rate <= clk_dvfs_node->max_rate)) {
-			clk_dvfs_node->min_rate = min_rate;
-		}
-		
-		if ((max_rate >= clk_dvfs_node->min_rate) && (max_rate <= clk_dvfs_node->max_rate)) {
-			clk_dvfs_node->max_rate = max_rate;
-		}
-
-		if (clk_dvfs_node->last_set_rate == 0)
-			rate = __clk_get_rate(clk_dvfs_node->clk);
-		else
-			rate = clk_dvfs_node->last_set_rate;
-		ret = clk_dvfs_node->vd->vd_dvfs_target(clk_dvfs_node, rate);
-
-		mutex_unlock(&clk_dvfs_node->vd->mutex);
-
-	}
-
-	DVFS_DBG("%s:clk(%s) last_set_rate=%lu; [min_rate, max_rate]=[%u, %u]\n",
-		 __func__, __clk_get_name(clk_dvfs_node->clk),
-		 clk_dvfs_node->last_set_rate,
-		 clk_dvfs_node->min_rate, clk_dvfs_node->max_rate);
-
-	return 0;
-}
-EXPORT_SYMBOL(dvfs_clk_enable_limit);
-
-int dvfs_clk_disable_limit(struct dvfs_node *clk_dvfs_node)
-{
-	u32 ret = 0;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-	
-	if (clk_dvfs_node->vd && clk_dvfs_node->vd->vd_dvfs_target){
-		mutex_lock(&clk_dvfs_node->vd->mutex);
-		
-		/* To reset clk_dvfs_node->min_rate/max_rate */
-		dvfs_get_rate_range(clk_dvfs_node);
-		clk_dvfs_node->freq_limit_en = 0;
-		ret = clk_dvfs_node->vd->vd_dvfs_target(clk_dvfs_node, clk_dvfs_node->last_set_rate);
-
-		mutex_unlock(&clk_dvfs_node->vd->mutex);
-	}
-
-	DVFS_DBG("%s: clk(%s) last_set_rate=%lu; [min_rate, max_rate]=[%u, %u]\n",
-		 __func__, __clk_get_name(clk_dvfs_node->clk),
-		 clk_dvfs_node->last_set_rate,
-		 clk_dvfs_node->min_rate, clk_dvfs_node->max_rate);
-
-	return 0;
-}
-EXPORT_SYMBOL(dvfs_clk_disable_limit);
-
-void dvfs_disable_temp_limit(void) {
-	if (clk_cpu_b_dvfs_node)
-		clk_cpu_b_dvfs_node->temp_limit_enable = 0;
-	if (clk_cpu_l_dvfs_node)
-		clk_cpu_l_dvfs_node->temp_limit_enable = 0;
-	if (clk_cpu_dvfs_node)
-		clk_cpu_dvfs_node->temp_limit_enable = 0;
-	if (clk_gpu_dvfs_node)
-		clk_gpu_dvfs_node->temp_limit_enable = 0;
-	cancel_delayed_work_sync(&dvfs_temp_limit_work);
-}
-
-int dvfs_clk_get_limit(struct dvfs_node *clk_dvfs_node, unsigned int *min_rate, unsigned int *max_rate) 
-{
-	int freq_limit_en;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-
-	*min_rate = clk_dvfs_node->min_rate;
-	*max_rate = clk_dvfs_node->max_rate;
-	freq_limit_en = clk_dvfs_node->freq_limit_en;
-
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-
-	return freq_limit_en;
-}
-EXPORT_SYMBOL(dvfs_clk_get_limit);
-
-int dvfs_clk_register_set_rate_callback(struct dvfs_node *clk_dvfs_node, clk_set_rate_callback clk_dvfs_target)
-{
-	if (!clk_dvfs_node)
-		return -EINVAL;
-			
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	clk_dvfs_node->clk_dvfs_target = clk_dvfs_target;
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL(dvfs_clk_register_set_rate_callback);
-
-struct cpufreq_frequency_table *dvfs_get_freq_volt_table(struct dvfs_node *clk_dvfs_node) 
-{
-	struct cpufreq_frequency_table *table;
-
-	if (!clk_dvfs_node)
-		return NULL;
-
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	table = clk_dvfs_node->dvfs_table;
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-	
-	return table;
-}
-EXPORT_SYMBOL(dvfs_get_freq_volt_table);
-
-int dvfs_set_freq_volt_table(struct dvfs_node *clk_dvfs_node, struct cpufreq_frequency_table *table)
-{
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	if (IS_ERR_OR_NULL(table)){
-		DVFS_ERR("%s:invalid table!\n", __func__);
-		return -EINVAL;
-	}
-	
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	clk_dvfs_node->dvfs_table = table;
-	dvfs_get_rate_range(clk_dvfs_node);
-	dvfs_table_round_clk_rate(clk_dvfs_node);
-	dvfs_table_round_volt(clk_dvfs_node);
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL(dvfs_set_freq_volt_table);
-
-static int get_adjust_volt_by_leakage(struct dvfs_node *dvfs_node)
-{
-	int leakage = 0;
-	int delta_leakage = 0;
-	int i = 0;
-	int adjust_volt = 0;
-
-	if (!dvfs_node->vd)
-		return 0;
-
-	if (dvfs_node->lkg_info.def_table_lkg == -1)
-		return 0;
-
-	leakage = rockchip_get_leakage(dvfs_node->channel);
-	if (!leakage || (leakage == 0xff))
-		return 0;
-
-	delta_leakage = leakage - dvfs_node->lkg_info.def_table_lkg;
-	if (delta_leakage <= 0) {
-		for (i = 0; (dvfs_node->lkg_info.table[i].dlt_volt !=
-			CPUFREQ_TABLE_END); i++) {
-			if (leakage > dvfs_node->lkg_info.table[i].lkg) {
-				adjust_volt =
-					dvfs_node->lkg_info.table[i].dlt_volt;
-			} else {
-				return adjust_volt;
-			}
-		}
-	} else if (delta_leakage > 0) {
-		for (i = 0; (dvfs_node->lkg_info.table[i].dlt_volt !=
-			CPUFREQ_TABLE_END); i++) {
-			if (leakage <= dvfs_node->lkg_info.table[i].lkg) {
-				adjust_volt =
-					-dvfs_node->lkg_info.table[i].dlt_volt;
-				return adjust_volt;
-			}
-		}
-	}
-	return adjust_volt;
-}
-
-static void adjust_table_by_leakage(struct dvfs_node *dvfs_node)
-{
-	int i, adjust_volt = get_adjust_volt_by_leakage(dvfs_node);
-
-	if (!adjust_volt)
-		return;
-
-	if (!dvfs_node->dvfs_table)
-		return;
-
-	if (dvfs_node->lkg_info.min_adjust_freq == -1)
-		return;
-
-	for (i = 0;
-	(dvfs_node->dvfs_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-		if (dvfs_node->dvfs_table[i].frequency >=
-			dvfs_node->lkg_info.min_adjust_freq)
-			dvfs_node->dvfs_table[i].index += adjust_volt;
-	}
-}
-
-int clk_enable_dvfs(struct dvfs_node *clk_dvfs_node)
-{
-	struct cpufreq_frequency_table clk_fv;
-	int volt_new;
-	unsigned int mode;
-	int ret;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-	
-	DVFS_DBG("%s: dvfs clk(%s) enable dvfs!\n", 
-		__func__, __clk_get_name(clk_dvfs_node->clk));
-
-	if (!clk_dvfs_node->vd) {
-		DVFS_ERR("%s: dvfs node(%s) has no vd node!\n", 
-			__func__, clk_dvfs_node->name);
-		return -EINVAL;
-	}
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	if (clk_dvfs_node->enable_count == 0) {
-		if (IS_ERR_OR_NULL(clk_dvfs_node->vd->regulator)) {
-			if (clk_dvfs_node->vd->regulator_name)
-				clk_dvfs_node->vd->regulator = dvfs_regulator_get(NULL, clk_dvfs_node->vd->regulator_name);
-			if (!IS_ERR_OR_NULL(clk_dvfs_node->vd->regulator)) {
-				DVFS_DBG("%s: vd(%s) get regulator(%s) ok\n",
-					__func__, clk_dvfs_node->vd->name, clk_dvfs_node->vd->regulator_name);
-				clk_enable_dvfs_regulator_check(clk_dvfs_node->vd);
-				dvfs_get_vd_regulator_volt_list(clk_dvfs_node->vd);
-				dvfs_vd_get_regulator_volt_time_info(clk_dvfs_node->vd);
-			} else {
-				clk_dvfs_node->vd->regulator = NULL;
-				clk_dvfs_node->enable_count = 0;
-				DVFS_ERR("%s: vd(%s) can't get regulator(%s)!\n", 
-					__func__, clk_dvfs_node->vd->name, clk_dvfs_node->vd->regulator_name);
-				mutex_unlock(&clk_dvfs_node->vd->mutex);
-				return -ENXIO;
-			}
-		} else {
-			clk_enable_dvfs_regulator_check(clk_dvfs_node->vd);
-		}
-		
-		DVFS_DBG("%s: vd(%s) cur volt=%d\n",
-			__func__, clk_dvfs_node->name, clk_dvfs_node->vd->cur_volt);
-
-		dvfs_table_round_clk_rate(clk_dvfs_node);
-		dvfs_get_rate_range(clk_dvfs_node);
-		clk_dvfs_node->freq_limit_en = 1;
-		clk_dvfs_node->max_limit_freq = clk_dvfs_node->max_rate;
-		if (clk_dvfs_node->lkg_adjust_volt_en)
-			adjust_table_by_leakage(clk_dvfs_node);
-		if (clk_dvfs_node->support_pvtm)
-			pvtm_set_dvfs_table(clk_dvfs_node);
-		dvfs_table_round_volt(clk_dvfs_node);
-		clk_dvfs_node->set_freq = clk_dvfs_node_get_rate_kz(clk_dvfs_node->clk);
-		clk_dvfs_node->last_set_rate = clk_dvfs_node->set_freq*1000;
-		
-		DVFS_DBG("%s: %s get freq %u!\n", 
-			__func__, clk_dvfs_node->name, clk_dvfs_node->set_freq);
-
-		if (clk_dvfs_node_get_ref_volt(clk_dvfs_node, clk_dvfs_node->set_freq, &clk_fv)) {
-			if (clk_dvfs_node->dvfs_table[0].frequency == CPUFREQ_TABLE_END) {
-				DVFS_ERR("%s: table empty\n", __func__);
-				clk_dvfs_node->enable_count = 0;
-				mutex_unlock(&clk_dvfs_node->vd->mutex);
-				return -EINVAL;
-			} else {
-				DVFS_WARNING("%s: clk(%s) freq table all value are smaller than default(%d), use default, just enable dvfs\n", 
-					__func__, clk_dvfs_node->name, clk_dvfs_node->set_freq);
-				clk_dvfs_node->enable_count++;
-				mutex_unlock(&clk_dvfs_node->vd->mutex);
-				return 0;
-			}
-		}
-		clk_dvfs_node->enable_count++;
-		clk_dvfs_node->set_volt = clk_fv.index;
-		volt_new = dvfs_vd_get_newvolt_byclk(clk_dvfs_node);
-		DVFS_DBG("%s: %s, freq %u(ref vol %u)\n",
-			__func__, clk_dvfs_node->name, clk_dvfs_node->set_freq, clk_dvfs_node->set_volt);
-#if 0
-		if (clk_dvfs_node->dvfs_nb) {
-			// must unregister when clk disable
-			clk_notifier_register(clk, clk_dvfs_node->dvfs_nb);
-		}
-#endif
-		if(clk_dvfs_node->vd->cur_volt != volt_new) {
-			ret = dvfs_regulator_set_voltage_readback(clk_dvfs_node->vd->regulator, volt_new, volt_new);
-			dvfs_volt_up_delay(clk_dvfs_node->vd,volt_new, clk_dvfs_node->vd->cur_volt);
-			if (ret < 0) {
-				clk_dvfs_node->vd->volt_set_flag = DVFS_SET_VOLT_FAILURE;
-				clk_dvfs_node->enable_count = 0;
-				DVFS_ERR("dvfs enable clk %s,set volt error \n", clk_dvfs_node->name);
-				mutex_unlock(&clk_dvfs_node->vd->mutex);
-				return -EAGAIN;
-			}
-			clk_dvfs_node->vd->cur_volt = volt_new;
-			clk_dvfs_node->vd->volt_set_flag = DVFS_SET_VOLT_SUCCESS;
-		}
-
-	} else {
-		DVFS_DBG("%s: dvfs already enable clk enable = %d!\n",
-			__func__, clk_dvfs_node->enable_count);
-		clk_dvfs_node->enable_count++;
-	}
-
-	if (clk_dvfs_node->regu_mode_en) {
-		ret = dvfs_regu_mode_table_constrain(clk_dvfs_node);
-		if (ret) {
-			DVFS_ERR("%s: clk(%s) regu_mode_table is unvalid, set regu_mode_en=0!\n",
-					__func__, clk_dvfs_node->name);
-			clk_dvfs_node->regu_mode_en = 0;
-			mutex_unlock(&clk_dvfs_node->vd->mutex);
-			return ret;
-		}
-
-		ret = clk_dvfs_node_get_regu_mode(clk_dvfs_node, clk_dvfs_node->set_freq*1000, &mode);
-		if (ret < 0) {
-			DVFS_ERR("%s: clk(%s) rate %dKhz get regu_mode fail\n",
-					__func__, clk_dvfs_node->name, clk_dvfs_node->set_freq);
-			mutex_unlock(&clk_dvfs_node->vd->mutex);
-			return ret;
-		} else
-			clk_dvfs_node->regu_mode = mode;
-
-		dvfs_update_clk_pds_mode(clk_dvfs_node);
-	}
-
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-	
-	return 0;
-}
-EXPORT_SYMBOL(clk_enable_dvfs);
-
-int clk_disable_dvfs(struct dvfs_node *clk_dvfs_node)
-{
-	int volt_new;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	DVFS_DBG("%s:dvfs clk(%s) disable dvfs!\n", 
-		__func__, __clk_get_name(clk_dvfs_node->clk));
-
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	if (!clk_dvfs_node->enable_count) {
-		DVFS_WARNING("%s:clk(%s) is already closed!\n", 
-			__func__, __clk_get_name(clk_dvfs_node->clk));
-		mutex_unlock(&clk_dvfs_node->vd->mutex);
-		return 0;
-	} else {
-		clk_dvfs_node->enable_count--;
-		if (0 == clk_dvfs_node->enable_count) {
-			DVFS_DBG("%s:dvfs clk(%s) disable dvfs ok!\n",
-				__func__, __clk_get_name(clk_dvfs_node->clk));
-			volt_new = dvfs_vd_get_newvolt_byclk(clk_dvfs_node);
-			dvfs_scale_volt_direct(clk_dvfs_node->vd, volt_new);
-
-#if 0
-			clk_notifier_unregister(clk, clk_dvfs_node->dvfs_nb);
-			DVFS_DBG("clk unregister nb!\n");
-#endif
-		}
-	}
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-	return 0;
-}
-EXPORT_SYMBOL(clk_disable_dvfs);
-
-static unsigned long dvfs_get_limit_rate(struct dvfs_node *clk_dvfs_node, unsigned long rate)
-{
-	unsigned long limit_rate;
-
-	limit_rate = rate;
-	if (clk_dvfs_node->freq_limit_en) {
-		//dvfs table limit
-		if (rate < clk_dvfs_node->min_rate) {
-			limit_rate = clk_dvfs_node->min_rate;
-		} else if (rate > clk_dvfs_node->max_rate) {
-			limit_rate = clk_dvfs_node->max_rate;
-		}
-		if (clk_dvfs_node->temp_limit_enable) {
-			if (limit_rate > clk_dvfs_node->temp_limit_rate) {
-				limit_rate = clk_dvfs_node->temp_limit_rate;
-			}
-		}
-		if (limit_rate > clk_dvfs_node->max_limit_freq)
-			limit_rate = clk_dvfs_node->max_limit_freq;
-	}
-
-	DVFS_DBG("%s: rate:%ld, limit_rate:%ld,\n", __func__, rate, limit_rate);
-
-	return limit_rate;
-}
-
-static int dvfs_target(struct dvfs_node *clk_dvfs_node, unsigned long rate)
-{
-	struct cpufreq_frequency_table clk_fv;
-	unsigned long old_rate = 0, new_rate = 0, volt_new = 0, clk_volt_store = 0;
-	struct clk *clk = clk_dvfs_node->clk;
-	int ret;
-
-	if (!clk)
-		return -EINVAL;
-
-	if (!clk_dvfs_node->enable_count) {
-		DVFS_ERR("%s: %s is disable, set rate error\n",
-			 __func__, clk_dvfs_node->name);
-		return 0;
-	}
-	
-	if (clk_dvfs_node->vd->volt_set_flag == DVFS_SET_VOLT_FAILURE) {
-		/* It means the last time set voltage error */
-		ret = dvfs_reset_volt(clk_dvfs_node->vd);
-		if (ret < 0) {
-			return -EAGAIN;
-		}
-	}
-
-	rate = dvfs_get_limit_rate(clk_dvfs_node, rate);
-	new_rate = __clk_round_rate(clk, rate);
-	old_rate = __clk_get_rate(clk);
-	if (new_rate == old_rate)
-		return 0;
-
-	DVFS_DBG("enter %s: clk(%s) new_rate = %lu Hz, old_rate =  %lu Hz\n", 
-		__func__, clk_dvfs_node->name, rate, old_rate);	
-
-	/* find the clk corresponding voltage */
-	ret = clk_dvfs_node_get_ref_volt(clk_dvfs_node, new_rate / 1000, &clk_fv);
-	if (ret) {
-		DVFS_ERR("%s:dvfs clk(%s) rate %luhz is not support\n",
-			__func__, clk_dvfs_node->name, new_rate);
-		return ret;
-	}
-	clk_volt_store = clk_dvfs_node->set_volt;
-	clk_dvfs_node->set_volt = clk_fv.index;
-	volt_new = dvfs_vd_get_newvolt_byclk(clk_dvfs_node);
-	DVFS_DBG("%s:%s new rate=%lu(was=%lu),new volt=%lu,(was=%d)\n",
-		__func__, clk_dvfs_node->name, new_rate, old_rate, volt_new,clk_dvfs_node->vd->cur_volt);
-
-
-	/* if up the rate */
-	if (new_rate > old_rate) {
-		ret = dvfs_regu_mode_target(clk_dvfs_node, new_rate);
-		if (ret)
-			DVFS_ERR("%s: dvfs clk(%s) rate %luhz set mode err\n",
-				__func__, clk_dvfs_node->name, new_rate);
-
-		ret = dvfs_scale_volt_direct(clk_dvfs_node->vd, volt_new);
-		if (ret)
-			goto fail_roll_back;
-	}
-
-	/* scale rate */
-	if (clk_dvfs_node->clk_dvfs_target) {
-		ret = clk_dvfs_node->clk_dvfs_target(clk, rate);
-	} else {
-		ret = clk_set_rate(clk, rate);
-	}
-
-	if (ret) {
-		DVFS_ERR("%s:clk(%s) set rate err\n", 
-			__func__, __clk_get_name(clk));
-		goto fail_roll_back;
-	}
-	clk_dvfs_node->set_freq = new_rate / 1000;
-
-	DVFS_DBG("%s:dvfs clk(%s) set rate %lu ok\n", 
-		__func__, clk_dvfs_node->name, __clk_get_rate(clk));
-
-	/* if down the rate */
-	if (new_rate < old_rate) {
-		ret = dvfs_scale_volt_direct(clk_dvfs_node->vd, volt_new);
-		if (ret)
-			goto out;
-
-		ret = dvfs_regu_mode_target(clk_dvfs_node, new_rate);
-		if (ret)
-			DVFS_ERR("%s:dvfs clk(%s) rate %luhz set mode err\n",
-			__func__, clk_dvfs_node->name, new_rate);
-	}
-
-	return 0;
-fail_roll_back:
-	clk_dvfs_node->set_volt = clk_volt_store;
-out:
-	return ret;
-}
-
-unsigned long dvfs_clk_round_rate(struct dvfs_node *clk_dvfs_node, unsigned long rate)
-{
-	return __clk_round_rate(clk_dvfs_node->clk, rate);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_round_rate);
-
-unsigned long dvfs_clk_get_rate(struct dvfs_node *clk_dvfs_node)
-{
-	return __clk_get_rate(clk_dvfs_node->clk);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_get_rate);
-
-unsigned long dvfs_clk_get_last_set_rate(struct dvfs_node *clk_dvfs_node)
-{
-	unsigned long last_set_rate;
-
-	mutex_lock(&clk_dvfs_node->vd->mutex);
-	last_set_rate = clk_dvfs_node->last_set_rate;
-	mutex_unlock(&clk_dvfs_node->vd->mutex);
-
-	return last_set_rate;
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_get_last_set_rate);
-
-
-int dvfs_clk_enable(struct dvfs_node *clk_dvfs_node)
-{
-	return clk_enable(clk_dvfs_node->clk);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_enable);
-
-void dvfs_clk_disable(struct dvfs_node *clk_dvfs_node)
-{
-	return clk_disable(clk_dvfs_node->clk);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_disable);
-
-struct dvfs_node *clk_get_dvfs_node(char *clk_name)
-{
-	struct vd_node *vd;
-	struct pd_node *pd;
-	struct dvfs_node *clk_dvfs_node;
-
-	mutex_lock(&rk_dvfs_mutex);
-	list_for_each_entry(vd, &rk_dvfs_tree, node) {
-		mutex_lock(&vd->mutex);
-		list_for_each_entry(pd, &vd->pd_list, node) {
-			list_for_each_entry(clk_dvfs_node, &pd->clk_list, node) {
-				if (0 == strcmp(clk_dvfs_node->name, clk_name)) {
-					mutex_unlock(&vd->mutex);
-					mutex_unlock(&rk_dvfs_mutex);
-					return clk_dvfs_node;
-				}
-			}
-		}
-		mutex_unlock(&vd->mutex);
-	}
-	mutex_unlock(&rk_dvfs_mutex);
-	
-	return NULL;	
-}
-EXPORT_SYMBOL_GPL(clk_get_dvfs_node);
-
-void clk_put_dvfs_node(struct dvfs_node *clk_dvfs_node)
-{
-	return;
-}
-EXPORT_SYMBOL_GPL(clk_put_dvfs_node);
-
-int dvfs_clk_prepare_enable(struct dvfs_node *clk_dvfs_node)
-{
-	return clk_prepare_enable(clk_dvfs_node->clk);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_prepare_enable);
-
-
-void dvfs_clk_disable_unprepare(struct dvfs_node *clk_dvfs_node)
-{
-	clk_disable_unprepare(clk_dvfs_node->clk);
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_disable_unprepare);
-
-int dvfs_clk_set_rate(struct dvfs_node *clk_dvfs_node, unsigned long rate)
-{
-	int ret = -EINVAL;
-	
-	if (!clk_dvfs_node)
-		return -EINVAL;
-	
-	DVFS_DBG("%s:dvfs node(%s) set rate(%lu)\n", 
-		__func__, clk_dvfs_node->name, rate);
-	
-	#if 0 // judge by reference func in rk
-	if (dvfs_support_clk_set_rate(dvfs_info)==false) {
-		DVFS_ERR("dvfs func:%s is not support!\n", __func__);
-		return ret;
-	}
-	#endif
-
-	if (clk_dvfs_node->vd && clk_dvfs_node->vd->vd_dvfs_target) {
-		mutex_lock(&clk_dvfs_node->vd->mutex);
-		ret = clk_dvfs_node->vd->vd_dvfs_target(clk_dvfs_node, rate);
-		clk_dvfs_node->last_set_rate = rate;
-		mutex_unlock(&clk_dvfs_node->vd->mutex);
-	} else {
-		DVFS_ERR("%s:dvfs node(%s) has no vd node or target callback!\n", 
-			__func__, clk_dvfs_node->name);
-	}
-		
-	return ret;	
-}
-EXPORT_SYMBOL_GPL(dvfs_clk_set_rate);
-
-
-int rk_regist_vd(struct vd_node *vd)
-{
-	if (!vd)
-		return -EINVAL;
-
-	vd->mode_flag=0;
-	vd->volt_time_flag=0;
-	vd->n_voltages=0;
-	INIT_LIST_HEAD(&vd->pd_list);
-	mutex_lock(&rk_dvfs_mutex);
-	list_add(&vd->node, &rk_dvfs_tree);
-	mutex_unlock(&rk_dvfs_mutex);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rk_regist_vd);
-
-int rk_regist_pd(struct pd_node *pd)
-{
-	struct vd_node	*vd;
-
-	if (!pd)
-		return -EINVAL;
-
-	vd = pd->vd;
-	if (!vd)
-		return -EINVAL;
-
-	INIT_LIST_HEAD(&pd->clk_list);
-	mutex_lock(&vd->mutex);
-	list_add(&pd->node, &vd->pd_list);
-	mutex_unlock(&vd->mutex);
-	
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rk_regist_pd);
-
-int rk_regist_clk(struct dvfs_node *clk_dvfs_node)
-{
-	struct vd_node	*vd;
-	struct pd_node	*pd;
-
-	if (!clk_dvfs_node)
-		return -EINVAL;
-
-	vd = clk_dvfs_node->vd;
-	pd = clk_dvfs_node->pd;
-	if (!vd || !pd)
-		return -EINVAL;
-
-	mutex_lock(&vd->mutex);
-	list_add(&clk_dvfs_node->node, &pd->clk_list);
-	mutex_unlock(&vd->mutex);
-	
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rk_regist_clk);
-
-static struct cpufreq_frequency_table *of_get_temp_limit_table(struct device_node *dev_node, const char *propname)
-{
-	struct cpufreq_frequency_table *temp_limt_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(dev_node, propname, NULL);
-	if (!prop)
-		return NULL;
-	if (!prop->value)
-		return NULL;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return NULL;
-	}
-
-	temp_limt_table = kzalloc(sizeof(struct cpufreq_frequency_table) *
-			     (nr/2 + 1), GFP_KERNEL);
-
-	val = prop->value;
-
-	for (i=0; i<nr/2; i++){
-		temp_limt_table[i].index = be32_to_cpup(val++);
-		temp_limt_table[i].frequency = be32_to_cpup(val++) * 1000;
-	}
-
-	temp_limt_table[i].index = 0;
-	temp_limt_table[i].frequency = CPUFREQ_TABLE_END;
-
-	return temp_limt_table;
-
-}
-
-static int of_get_dvfs_table(struct device_node *dev_node,
-			     struct cpufreq_frequency_table **dvfs_table)
-{
-	struct cpufreq_frequency_table *tmp_dvfs_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(dev_node, "operating-points", NULL);
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -EINVAL;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return -EINVAL;
-	}
-
-	tmp_dvfs_table = kzalloc(sizeof(*tmp_dvfs_table) *
-			     (nr/2 + 1), GFP_KERNEL);
-	val = prop->value;
-
-	for (i = 0; i < nr/2; i++) {
-		tmp_dvfs_table[i].frequency = be32_to_cpup(val++);
-		tmp_dvfs_table[i].index = be32_to_cpup(val++);
-	}
-
-	tmp_dvfs_table[i].index = 0;
-	tmp_dvfs_table[i].frequency = CPUFREQ_TABLE_END;
-
-	*dvfs_table = tmp_dvfs_table;
-
-	return 0;
-}
-
-
-static int of_get_dvfs_pvtm_table(struct device_node *dev_node,
-				  struct cpufreq_frequency_table **dvfs_table,
-				  struct cpufreq_frequency_table **pvtm_table)
-{
-	struct cpufreq_frequency_table *tmp_dvfs_table = NULL;
-	struct cpufreq_frequency_table *tmp_pvtm_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(dev_node, "pvtm-operating-points", NULL);
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -EINVAL;
-
-	nr = prop->length / sizeof(u32);
-	if (nr % 3) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return -EINVAL;
-	}
-
-	tmp_dvfs_table = kzalloc(sizeof(*tmp_dvfs_table) *
-			     (nr/3 + 1), GFP_KERNEL);
-
-	tmp_pvtm_table = kzalloc(sizeof(*tmp_pvtm_table) *
-			     (nr/3 + 1), GFP_KERNEL);
-
-	val = prop->value;
-
-	for (i = 0; i < nr/3; i++) {
-		tmp_dvfs_table[i].frequency = be32_to_cpup(val++);
-		tmp_dvfs_table[i].index = be32_to_cpup(val++);
-
-		tmp_pvtm_table[i].frequency = tmp_dvfs_table[i].frequency;
-		tmp_pvtm_table[i].index = be32_to_cpup(val++);
-	}
-
-	tmp_dvfs_table[i].index = 0;
-	tmp_dvfs_table[i].frequency = CPUFREQ_TABLE_END;
-
-	tmp_pvtm_table[i].index = 0;
-	tmp_pvtm_table[i].frequency = CPUFREQ_TABLE_END;
-
-	*dvfs_table = tmp_dvfs_table;
-	*pvtm_table = tmp_pvtm_table;
-
-	return 0;
-}
-
-static struct lkg_adjust_volt_table
-	*of_get_lkg_adjust_volt_table(struct device_node *np,
-	const char *propname)
-{
-	struct lkg_adjust_volt_table *lkg_adjust_volt_table = NULL;
-	const struct property *prop;
-	const __be32 *val;
-	int nr, i;
-
-	prop = of_find_property(np, propname, NULL);
-	if (!prop)
-		return NULL;
-	if (!prop->value)
-		return NULL;
-
-	nr = prop->length / sizeof(s32);
-	if (nr % 2) {
-		pr_err("%s: Invalid freq list\n", __func__);
-		return NULL;
-	}
-
-	lkg_adjust_volt_table =
-		kzalloc(sizeof(struct lkg_adjust_volt_table) *
-		(nr/2 + 1), GFP_KERNEL);
-
-	val = prop->value;
-
-	for (i = 0; i < nr/2; i++) {
-		lkg_adjust_volt_table[i].lkg = be32_to_cpup(val++);
-		lkg_adjust_volt_table[i].dlt_volt = be32_to_cpup(val++);
-	}
-
-	lkg_adjust_volt_table[i].lkg = 0;
-	lkg_adjust_volt_table[i].dlt_volt = CPUFREQ_TABLE_END;
-
-	return lkg_adjust_volt_table;
-}
-
-static int dvfs_node_parse_dt(struct device_node *np,
-			      struct dvfs_node *dvfs_node)
-{
-	int process_version = rockchip_process_version();
-	int i = 0;
-	int ret;
-
-	of_property_read_u32_index(np, "channel", 0, &dvfs_node->channel);
-
-	pr_info("channel:%d, lkg:%d\n",
-		dvfs_node->channel, rockchip_get_leakage(dvfs_node->channel));
-
-	of_property_read_u32_index(np, "regu-mode-en", 0,
-				   &dvfs_node->regu_mode_en);
-	if (dvfs_node->regu_mode_en)
-		dvfs_node->regu_mode_table = of_get_regu_mode_table(np);
-	else
-		dvfs_node->regu_mode_table = NULL;
-
-	of_property_read_u32_index(np, "temp-limit-enable", 0,
-				   &dvfs_node->temp_limit_enable);
-	if (dvfs_node->temp_limit_enable) {
-		of_property_read_u32_index(np, "min_temp_limit",
-					   0, &dvfs_node->min_temp_limit);
-		dvfs_node->min_temp_limit *= 1000;
-		of_property_read_u32_index(np, "target-temp",
-					   0, &dvfs_node->target_temp);
-		pr_info("target-temp:%d\n", dvfs_node->target_temp);
-		dvfs_node->nor_temp_limit_table =
-			of_get_temp_limit_table(np,
-						"normal-temp-limit");
-		dvfs_node->per_temp_limit_table =
-			of_get_temp_limit_table(np,
-						"performance-temp-limit");
-		dvfs_node->virt_temp_limit_table[0] =
-			of_get_temp_limit_table(np,
-						"virt-temp-limit-1-cpu-busy");
-		dvfs_node->virt_temp_limit_table[1] =
-			of_get_temp_limit_table(np,
-						"virt-temp-limit-2-cpu-busy");
-		dvfs_node->virt_temp_limit_table[2] =
-			of_get_temp_limit_table(np,
-						"virt-temp-limit-3-cpu-busy");
-		dvfs_node->virt_temp_limit_table[3] =
-			of_get_temp_limit_table(np,
-						"virt-temp-limit-4-cpu-busy");
-	}
-	dvfs_node->temp_limit_rate = -1;
-
-	dvfs_node->cluster = 0;
-	of_property_read_u32_index(np, "cluster", 0, &dvfs_node->cluster);
-
-	dvfs_node->pvtm_min_temp = 0;
-	of_property_read_u32_index(np, "pvtm_min_temp", 0,
-				   &dvfs_node->pvtm_min_temp);
-
-	ret = of_property_read_u32_index(np, "support-pvtm", 0,
-					 &dvfs_node->support_pvtm);
-	if (!ret) {
-		if (of_get_dvfs_pvtm_table(np, &dvfs_node->dvfs_table,
-					   &dvfs_node->pvtm_table))
-			return -EINVAL;
-
-		for (i = 0; i < ARRAY_SIZE(pvtm_info_table); i++) {
-			struct pvtm_info *pvtm_info = pvtm_info_table[i];
-
-			if ((pvtm_info->channel == dvfs_node->channel) &&
-			    (pvtm_info->process_version == process_version) &&
-			    (pvtm_info->cluster == dvfs_node->cluster) &&
-			     of_machine_is_compatible(pvtm_info->compatible)) {
-				dvfs_node->pvtm_info = pvtm_info;
-				break;
-			}
-		}
-
-		if (!dvfs_node->pvtm_info)
-			dvfs_node->support_pvtm = 0;
-	} else {
-		if (of_get_dvfs_table(np, &dvfs_node->dvfs_table))
-			return -EINVAL;
-	}
-
-	of_property_read_u32_index(np, "lkg_adjust_volt_en", 0,
-				   &dvfs_node->lkg_adjust_volt_en);
-	if (dvfs_node->lkg_adjust_volt_en) {
-		dvfs_node->lkg_info.def_table_lkg = -1;
-		of_property_read_u32_index(np, "def_table_lkg", 0,
-					   &dvfs_node->lkg_info.def_table_lkg);
-
-		dvfs_node->lkg_info.min_adjust_freq = -1;
-		of_property_read_u32_index(np, "min_adjust_freq", 0,
-					   &dvfs_node->lkg_info.min_adjust_freq
-					   );
-
-		dvfs_node->lkg_info.table =
-			of_get_lkg_adjust_volt_table(np,
-						     "lkg_adjust_volt_table");
-	}
-
-	return 0;
-}
-
-int of_dvfs_init(void)
-{
-	struct vd_node *vd;
-	struct pd_node *pd;
-	struct device_node *dvfs_dev_node, *clk_dev_node, *vd_dev_node, *pd_dev_node;
-	struct dvfs_node *dvfs_node;
-	struct clk *clk;
-	int ret;
-
-	DVFS_DBG("%s\n", __func__);
-	pr_info("process version: %d\n", rockchip_process_version());
-
-	dvfs_dev_node = of_find_node_by_name(NULL, "dvfs");
-	if (IS_ERR_OR_NULL(dvfs_dev_node)) {
-		DVFS_ERR("%s get dvfs dev node err\n", __func__);
-		return PTR_ERR(dvfs_dev_node);
-	}
-
-	for_each_available_child_of_node(dvfs_dev_node, vd_dev_node) {
-		vd = kzalloc(sizeof(struct vd_node), GFP_KERNEL);
-		if (!vd)
-			return -ENOMEM;
-
-		mutex_init(&vd->mutex);
-		vd->name = vd_dev_node->name;
-		ret = of_property_read_string(vd_dev_node, "regulator_name", &vd->regulator_name);
-		if (ret) {
-			DVFS_ERR("%s:vd(%s) get regulator_name err, ret:%d\n", 
-				__func__, vd_dev_node->name, ret);
-			kfree(vd);
-			continue;
-		}
-		
-		vd->suspend_volt = 0;
-		
-		vd->volt_set_flag = DVFS_SET_VOLT_FAILURE;
-		vd->vd_dvfs_target = dvfs_target;
-		ret = rk_regist_vd(vd);
-		if (ret){
-			DVFS_ERR("%s:vd(%s) register err:%d\n", __func__, vd->name, ret);
-			kfree(vd);
-			continue;
-		}
-
-		DVFS_DBG("%s:vd(%s) register ok, regulator name:%s,suspend volt:%d\n", 
-			__func__, vd->name, vd->regulator_name, vd->suspend_volt);
-		
-		for_each_available_child_of_node(vd_dev_node, pd_dev_node) {		
-			pd = kzalloc(sizeof(struct pd_node), GFP_KERNEL);
-			if (!pd)
-				return -ENOMEM;
-
-			pd->vd = vd;
-			pd->name = pd_dev_node->name;
-			
-			ret = rk_regist_pd(pd);
-			if (ret){
-				DVFS_ERR("%s:pd(%s) register err:%d\n", __func__, pd->name, ret);
-				kfree(pd);
-				continue;
-			}
-			DVFS_DBG("%s:pd(%s) register ok, parent vd:%s\n", 
-				__func__, pd->name, vd->name);			
-			for_each_available_child_of_node(pd_dev_node, clk_dev_node) {
-				if (!of_device_is_available(clk_dev_node))
-					continue;
-				
-				dvfs_node = kzalloc(sizeof(struct dvfs_node), GFP_KERNEL);
-				if (!dvfs_node)
-					return -ENOMEM;
-				
-				dvfs_node->name = clk_dev_node->name;
-				dvfs_node->pd = pd;
-				dvfs_node->vd = vd;
-
-				if (dvfs_node_parse_dt(clk_dev_node, dvfs_node))
-					continue;
-				
-				clk = clk_get(NULL, clk_dev_node->name);
-				if (IS_ERR(clk)){
-					DVFS_ERR("%s:get clk(%s) err:%ld\n", __func__, dvfs_node->name, PTR_ERR(clk));
-					kfree(dvfs_node);
-					continue;
-					
-				}
-				
-				dvfs_node->clk = clk;
-				ret = rk_regist_clk(dvfs_node);
-				if (ret){
-					DVFS_ERR("%s:dvfs_node(%s) register err:%d\n", __func__, dvfs_node->name, ret);
-					return ret;
-				}
-
-				DVFS_DBG("%s:dvfs_node(%s) register ok, parent pd:%s\n", 
-					__func__, clk_dev_node->name, pd->name);	
-
-			}
-		}	
-	}
-	return 0;
-}
-
-#ifdef CONFIG_ARM64
-arch_initcall_sync(of_dvfs_init);
-#endif
-
-/*********************************************************************************/
-/**
- * dump_dbg_map() : Draw all informations of dvfs while debug
- */
-static int dump_dbg_map(char *buf)
-{
-	int i;
-	struct vd_node	*vd;
-	struct pd_node	*pd;
-	struct dvfs_node	*clk_dvfs_node;
-	char *s = buf;
-	
-	mutex_lock(&rk_dvfs_mutex);
-	printk( "-------------DVFS TREE-----------\n\n\n");
-	printk( "DVFS TREE:\n");
-
-	list_for_each_entry(vd, &rk_dvfs_tree, node) {
-		mutex_lock(&vd->mutex);
-		printk( "|\n|- voltage domain:%s\n", vd->name);
-		printk( "|- current voltage:%d\n", vd->cur_volt);
-		printk( "|- current regu_mode:%s\n", dvfs_regu_mode_to_string(vd->regu_mode));
-
-		list_for_each_entry(pd, &vd->pd_list, node) {
-			printk( "|  |\n|  |- power domain:%s, status = %s, current volt = %d, current regu_mode = %s\n",
-					pd->name, (pd->pd_status == 1) ? "ON" : "OFF", pd->cur_volt,
-					dvfs_regu_mode_to_string(pd->regu_mode));
-
-			list_for_each_entry(clk_dvfs_node, &pd->clk_list, node) {
-				printk( "|  |  |\n|  |  |- clock: %s current: rate %d, volt = %d,"
-						" enable_dvfs = %s\n",
-						clk_dvfs_node->name, clk_dvfs_node->set_freq, clk_dvfs_node->set_volt,
-						clk_dvfs_node->enable_count == 0 ? "DISABLE" : "ENABLE");
-				printk( "|  |  |- clk limit(%s):[%u, %u]; last set rate = %lu\n",
-						clk_dvfs_node->freq_limit_en ? "enable" : "disable",
-						clk_dvfs_node->min_rate, clk_dvfs_node->max_rate,
-						clk_dvfs_node->last_set_rate/1000);
-				for (i = 0; (clk_dvfs_node->dvfs_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-					printk( "|  |  |  |- freq = %d, volt = %d\n",
-							clk_dvfs_node->dvfs_table[i].frequency,
-							clk_dvfs_node->dvfs_table[i].index);
-
-				}
-				printk( "|  |  |- clock: %s current: rate %d, regu_mode = %s,"
-						" regu_mode_en = %d\n",
-						clk_dvfs_node->name, clk_dvfs_node->set_freq,
-						dvfs_regu_mode_to_string(clk_dvfs_node->regu_mode),
-						clk_dvfs_node->regu_mode_en);
-				if (clk_dvfs_node->regu_mode_table) {
-					for (i = 0; (clk_dvfs_node->regu_mode_table[i].frequency != CPUFREQ_TABLE_END); i++) {
-						printk( "|  |  |  |- freq = %d, regu_mode = %s\n",
-								clk_dvfs_node->regu_mode_table[i].frequency/1000,
-								dvfs_regu_mode_to_string(clk_dvfs_node->regu_mode_table[i].index));
-					}
-				}
-			}
-		}
-		mutex_unlock(&vd->mutex);
-	}
-	
-	printk( "-------------DVFS TREE END------------\n");
-	mutex_unlock(&rk_dvfs_mutex);
-	
-	return s - buf;
-}
-
-/*********************************************************************************/
-static struct kobject *dvfs_kobj;
-struct dvfs_attribute {
-	struct attribute	attr;
-	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
-			char *buf);
-	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
-			const char *buf, size_t n);
-};
-
-static ssize_t dvfs_tree_store(struct kobject *kobj, struct kobj_attribute *attr,
-               const char *buf, size_t n)
-{
-       return n;
-}
-static ssize_t dvfs_tree_show(struct kobject *kobj, struct kobj_attribute *attr,
-               char *buf)
-{
-       return dump_dbg_map(buf);
-}
-
-static ssize_t cpu_temp_target_store(struct kobject *kobj,
-				     struct kobj_attribute *attr,
-				     const char *buf, size_t n)
-{
-	int ret = 0;
-
-	mutex_lock(&temp_limit_mutex);
-	if (clk_cpu_b_dvfs_node) {
-		ret = kstrtouint(buf, 0, &clk_cpu_b_dvfs_node->target_temp);
-		if (ret < 0)
-			goto error;
-	}
-	if (clk_cpu_l_dvfs_node) {
-		ret = kstrtouint(buf, 0, &clk_cpu_l_dvfs_node->target_temp);
-		if (ret < 0)
-			goto error;
-	}
-	if (clk_cpu_dvfs_node) {
-		ret = kstrtouint(buf, 0, &clk_cpu_dvfs_node->target_temp);
-		if (ret < 0)
-			goto error;
-	}
-error:
-	mutex_unlock(&temp_limit_mutex);
-	return n;
-}
-static ssize_t cpu_temp_target_show(struct kobject *kobj,
-				    struct kobj_attribute *attr, char *buf)
-{
-	int ret = 0;
-
-	if (clk_cpu_b_dvfs_node)
-		ret += sprintf(buf + ret, "cpu_b:%d\n",
-		clk_cpu_b_dvfs_node->target_temp);
-	if (clk_cpu_l_dvfs_node)
-		ret += sprintf(buf + ret, "cpu_l:%d\n",
-		clk_cpu_l_dvfs_node->target_temp);
-	if (clk_cpu_dvfs_node)
-		ret += sprintf(buf + ret, "cpu:%d\n",
-		clk_cpu_dvfs_node->target_temp);
-
-	return ret;
-}
-
-static ssize_t cpu_temp_enable_store(struct kobject *kobj,
-				     struct kobj_attribute *attr,
-				     const char *buf, size_t n)
-{
-	int ret = 0;
-
-	mutex_lock(&temp_limit_mutex);
-	if (clk_cpu_b_dvfs_node) {
-		ret = kstrtouint(buf, 0,
-				 &clk_cpu_b_dvfs_node->temp_limit_enable);
-		if (ret < 0)
-			goto error;
-		clk_cpu_b_dvfs_node->temp_limit_rate =
-			clk_cpu_b_dvfs_node->max_rate;
-	}
-	if (clk_cpu_l_dvfs_node) {
-		ret = kstrtouint(buf, 0,
-				 &clk_cpu_l_dvfs_node->temp_limit_enable);
-		if (ret < 0)
-			goto error;
-		clk_cpu_l_dvfs_node->temp_limit_rate =
-			clk_cpu_l_dvfs_node->max_rate;
-	}
-	if (clk_cpu_dvfs_node) {
-		ret = kstrtouint(buf, 0, &clk_cpu_dvfs_node->temp_limit_enable);
-		if (ret < 0)
-			goto error;
-		clk_cpu_dvfs_node->temp_limit_rate =
-			clk_cpu_dvfs_node->max_rate;
-	}
-error:
-	mutex_unlock(&temp_limit_mutex);
-	return n;
-}
-static ssize_t cpu_temp_enable_show(struct kobject *kobj,
-				    struct kobj_attribute *attr, char *buf)
-{
-	int ret = 0;
-
-	if (clk_cpu_b_dvfs_node)
-		ret += sprintf(buf + ret, "cpu_b:%d\n",
-		clk_cpu_b_dvfs_node->temp_limit_enable);
-	if (clk_cpu_l_dvfs_node)
-		ret += sprintf(buf + ret, "cpu_l:%d\n",
-		clk_cpu_l_dvfs_node->temp_limit_enable);
-	if (clk_cpu_dvfs_node)
-		ret += sprintf(buf + ret, "cpu:%d\n",
-		clk_cpu_dvfs_node->temp_limit_enable);
-
-	return ret;
-}
-
-static struct dvfs_attribute dvfs_attrs[] = {
-	/*     node_name	permision		show_func	store_func */
-//#ifdef CONFIG_RK_CLOCK_PROC
-	__ATTR(dvfs_tree,	S_IRUSR | S_IRGRP | S_IWUSR,
-	       dvfs_tree_show,	dvfs_tree_store),
-	__ATTR(cpu_temp_target,	S_IRUSR | S_IRGRP | S_IWUSR,
-	       cpu_temp_target_show,	cpu_temp_target_store),
-	__ATTR(cpu_temp_enable,	S_IRUSR | S_IRGRP | S_IWUSR,
-	       cpu_temp_enable_show,	cpu_temp_enable_store),
-//#endif
-};
-
-static int __init dvfs_init(void)
-{
-	int i, ret = 0;
-
-	dvfs_kobj = kobject_create_and_add("dvfs", NULL);
-	if (!dvfs_kobj)
-		return -ENOMEM;
-	for (i = 0; i < ARRAY_SIZE(dvfs_attrs); i++) {
-		ret = sysfs_create_file(dvfs_kobj, &dvfs_attrs[i].attr);
-		if (ret != 0) {
-			DVFS_ERR("create index %d error\n", i);
-			return ret;
-		}
-	}
-
-	clk_cpu_b_dvfs_node = clk_get_dvfs_node("clk_core_b");
-	if (clk_cpu_b_dvfs_node) {
-		clk_cpu_b_dvfs_node->temp_limit_rate =
-		clk_cpu_b_dvfs_node->max_rate;
-		if (clk_cpu_bl_dvfs_node == NULL)
-			clk_cpu_bl_dvfs_node = clk_cpu_b_dvfs_node;
-	}
-
-	clk_cpu_l_dvfs_node = clk_get_dvfs_node("clk_core_l");
-	if (clk_cpu_l_dvfs_node) {
-		clk_cpu_l_dvfs_node->temp_limit_rate =
-		clk_cpu_l_dvfs_node->max_rate;
-		if (clk_cpu_bl_dvfs_node == NULL)
-			clk_cpu_bl_dvfs_node = clk_cpu_l_dvfs_node;
-	}
-
-	clk_cpu_dvfs_node = clk_get_dvfs_node("clk_core");
-	if (clk_cpu_dvfs_node)
-		clk_cpu_dvfs_node->temp_limit_rate =
-		clk_cpu_dvfs_node->max_rate;
-
-	clk_gpu_dvfs_node = clk_get_dvfs_node("clk_gpu");
-	if (clk_gpu_dvfs_node)
-		clk_gpu_dvfs_node->temp_limit_rate =
-		clk_gpu_dvfs_node->max_rate;
-
-	if ((clk_cpu_b_dvfs_node && clk_cpu_b_dvfs_node->temp_limit_enable) ||
-	    (clk_cpu_l_dvfs_node && clk_cpu_l_dvfs_node->temp_limit_enable) ||
-	    (clk_gpu_dvfs_node && clk_gpu_dvfs_node->temp_limit_enable) ||
-	    (clk_cpu_dvfs_node && clk_cpu_dvfs_node->temp_limit_enable)) {
-		dvfs_wq = alloc_workqueue("dvfs", WQ_NON_REENTRANT |
-			WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_FREEZABLE, 1);
-		queue_delayed_work_on(0, dvfs_wq, &dvfs_temp_limit_work, 0*HZ);
-	}
-
-	vdd_gpu_regulator = dvfs_get_regulator("vdd_gpu");
-	if (!IS_ERR_OR_NULL(vdd_gpu_regulator)) {
-		struct clk *clk = clk_get(NULL, "pd_gpu");
-
-		if (clk)
-			rk_clk_pd_notifier_register(clk, &clk_pd_gpu_notifier);
-
-		fb_register_client(&early_suspend_notifier);
-		register_reboot_notifier(&vdd_gpu_reboot_notifier);
-	}
-
-	return ret;
-}
-
-late_initcall(dvfs_init);
diff --git a/arch/arm/mach-rockchip/efuse.c b/arch/arm/mach-rockchip/efuse.c
deleted file mode 100644
index 77afe8a4bcb5..000000000000
--- a/arch/arm/mach-rockchip/efuse.c
+++ /dev/null
@@ -1,365 +0,0 @@
-/*
- * Copyright (C) 2013-2015 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/crc32.h>
-#include <linux/delay.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <asm/compiler.h>
-#include <asm/psci.h>
-#include <asm/system_info.h>
-#include "efuse.h"
-
-#ifdef CONFIG_ARM
-#define efuse_readl(offset) readl_relaxed(RK_EFUSE_VIRT + offset)
-#define efuse_writel(val, offset) writel_relaxed(val, RK_EFUSE_VIRT + offset)
-#endif
-
-static u8 efuse_buf[32] = {};
-
-struct rockchip_efuse {
-	int (*get_leakage)(int ch);
-	int (*get_temp)(int ch);
-	int efuse_version;
-	int process_version;
-};
-
-static struct rockchip_efuse efuse;
-
-#ifdef CONFIG_ARM64
-/****************************secure reg access****************************/
-
-#define SEC_REG_RW_SHT (0x0)
-#define SEC_REG_RD (0x0)
-#define SEC_REG_WR (0x1)
-
-#define SEC_REG_BITS_SHT (0x1)
-#define SEC_REG_32 (0x0)
-#define SEC_REG_64 (0x2)
-
-#define SEC_REG_RD_32 (SEC_REG_RD | SEC_REG_32)
-#define SEC_REG_RD_64 (SEC_REG_RD | SEC_REG_64)
-#define SEC_REG_WR_32 (SEC_REG_WR | SEC_REG_32)
-#define SEC_REG_WR_64 (SEC_REG_WR | SEC_REG_64)
-
-#define PSCI_SIP_ACCESS_REG		(0x82000002)
-#define PSCI_SIP_RKTF_VER		(0x82000001)
-
-static phys_addr_t efuse_phys;
-
-/*
- * arg2: rd/wr control, bit[0] 0-rd 1-rt, bit[1] 0-32bit, 1-64bit
- * arg1: base addr
- * arg0: read or write val
- * function_id: return fail/succes
- */
-static u32 reg_wr_fn_smc(u64 function_id, u64 arg0, u64 arg1, u64 arg2)
-{
-	asm volatile(
-			__asmeq("%0", "x0")
-			__asmeq("%1", "x1")
-			__asmeq("%2", "x2")
-			__asmeq("%3", "x3")
-			"smc	#0\n"
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-	return function_id;
-}
-
-static u32 reg_rd_fn_smc(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
-			 u64 *val)
-{
-	asm volatile(
-			__asmeq("%0", "x0")
-			__asmeq("%1", "x1")
-			__asmeq("%2", "x2")
-			__asmeq("%3", "x3")
-			"smc	#0\n"
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-		*val = arg0;
-
-	return function_id;
-}
-
-static u32 (*reg_wr_fn)(u64, u64, u64, u64) = reg_wr_fn_smc;
-static u32 (*reg_rd_fn)(u64, u64, u64, u64, u64 *) = reg_rd_fn_smc;
-
-static u32 secure_regs_rd_32(u64 addr_phy)
-{
-	u64 val = 0;
-
-	reg_rd_fn(PSCI_SIP_ACCESS_REG, 0, addr_phy, SEC_REG_RD_32, &val);
-	return val;
-}
-
-static u32 secure_regs_wr_32(u64 addr_phy, u32 val)
-{
-	u64 val_64 = val;
-
-	return reg_wr_fn(PSCI_SIP_ACCESS_REG, val_64, addr_phy, SEC_REG_WR_32);
-}
-
-static u32 efuse_readl(u32 offset)
-{
-	return secure_regs_rd_32(efuse_phys + offset);
-}
-
-static void efuse_writel(u32 val, u32 offset)
-{
-	secure_regs_wr_32(efuse_phys + offset, val);
-}
-
-#define RKTF_VER_MAJOR(ver) (((ver) >> 16) & 0xffff)
-#define RKTF_VER_MINOR(ver) ((ver) & 0xffff)
-/* valid ver */
-#define RKTF_VLDVER_MAJOR (1)
-#define RKTF_VLDVER_MINOR (3)
-
-
-static int __init rockchip_tf_ver_check(void)
-{
-	u64 val;
-	u32 ver_val;
-
-	ver_val = reg_rd_fn(PSCI_SIP_RKTF_VER, 0, 0, 0, &val);
-	if (ver_val == 0xffffffff)
-		goto ver_error;
-
-	if ((RKTF_VER_MAJOR(ver_val) >= RKTF_VLDVER_MAJOR) &&
-		(RKTF_VER_MINOR(ver_val) >= RKTF_VLDVER_MINOR))
-		return 0;
-
-ver_error:
-
-	pr_err("read tf version 0x%x!\n", ver_val);
-
-	do {
-		mdelay(1000);
-		pr_err("trusted firmware need to update to(%d.%d) or is invaild!\n",
-			RKTF_VLDVER_MAJOR, RKTF_VLDVER_MINOR);
-	} while(1);
-
-	return 0;
-}
-device_initcall_sync(rockchip_tf_ver_check);
-#endif
-
-static int rk3288_efuse_readregs(u32 addr, u32 length, u8 *buf)
-{
-	int ret = length;
-
-	if (!length)
-		return 0;
-	if (!buf)
-		return 0;
-
-	efuse_writel(EFUSE_CSB, REG_EFUSE_CTRL);
-	efuse_writel(EFUSE_LOAD | EFUSE_PGENB, REG_EFUSE_CTRL);
-	udelay(2);
-	do {
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) &
-			(~(EFUSE_A_MASK << EFUSE_A_SHIFT)), REG_EFUSE_CTRL);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) |
-			((addr & EFUSE_A_MASK) << EFUSE_A_SHIFT),
-			REG_EFUSE_CTRL);
-		udelay(2);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) |
-				EFUSE_STROBE, REG_EFUSE_CTRL);
-		udelay(2);
-		*buf = efuse_readl(REG_EFUSE_DOUT);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) &
-				(~EFUSE_STROBE), REG_EFUSE_CTRL);
-		udelay(2);
-		buf++;
-		addr++;
-	} while (--length);
-	udelay(2);
-	efuse_writel(efuse_readl(REG_EFUSE_CTRL) | EFUSE_CSB, REG_EFUSE_CTRL);
-	udelay(1);
-
-	return ret;
-}
-
-static int __init rk3288_get_efuse_version(void)
-{
-	int ret = efuse_buf[4] & (~(0x1 << 3));
-	return ret;
-}
-
-static int __init rk3288_get_process_version(void)
-{
-	int ret = efuse_buf[6]&0x0f;
-
-	return ret;
-}
-
-static int rk3288_get_leakage(int ch)
-{
-	if ((ch < 0) || (ch > 2))
-		return 0;
-
-	return efuse_buf[23+ch];
-}
-
-static void __init rk3288_set_system_serial(void)
-{
-	int i;
-	u8 buf[16];
-
-	for (i = 0; i < 8; i++) {
-		buf[i] = efuse_buf[8 + (i << 1)];
-		buf[i + 8] = efuse_buf[7 + (i << 1)];
-	}
-
-	system_serial_low = crc32(0, buf, 8);
-	system_serial_high = crc32(system_serial_low, buf + 8, 8);
-}
-
-int rk312x_efuse_readregs(u32 addr, u32 length, u8 *buf)
-{
-	int ret = length;
-
-	if (!length)
-		return 0;
-
-	efuse_writel(EFUSE_LOAD, REG_EFUSE_CTRL);
-	udelay(2);
-	do {
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) &
-				(~(EFUSE_A_MASK << RK312X_EFUSE_A_SHIFT)),
-				REG_EFUSE_CTRL);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) |
-				((addr & EFUSE_A_MASK) << RK312X_EFUSE_A_SHIFT),
-				REG_EFUSE_CTRL);
-		udelay(2);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) |
-				EFUSE_STROBE, REG_EFUSE_CTRL);
-		udelay(2);
-		*buf = efuse_readl(REG_EFUSE_DOUT);
-		efuse_writel(efuse_readl(REG_EFUSE_CTRL) &
-				(~EFUSE_STROBE), REG_EFUSE_CTRL);
-		udelay(2);
-		buf++;
-		addr++;
-	} while (--length);
-	udelay(2);
-	efuse_writel(efuse_readl(REG_EFUSE_CTRL) &
-			(~EFUSE_LOAD) , REG_EFUSE_CTRL);
-	udelay(1);
-
-	return ret;
-}
-
-int rockchip_efuse_version(void)
-{
-	return efuse.efuse_version;
-}
-
-int rockchip_process_version(void)
-{
-	return efuse.process_version;
-}
-
-int rockchip_get_leakage(int ch)
-{
-	int ret = 0;
-
-	if (efuse.get_leakage) {
-		return efuse.get_leakage(ch);
-	} else {
-		ret = rk3288_efuse_readregs(0, 32, efuse_buf);
-		if (ret == 32)
-			return efuse_buf[23+ch];
-	}
-	return 0;
-}
-
-int rockchip_efuse_get_temp_adjust(int ch)
-{
-	int temp;
-
-	if (efuse_buf[31] & 0x80)
-		temp = -(efuse_buf[31] & 0x7f);
-	else
-		temp = efuse_buf[31];
-
-	return temp;
-}
-
-static void __init rk3288_efuse_init(void)
-{
-	int ret;
-
-	ret = rk3288_efuse_readregs(0, 32, efuse_buf);
-	if (ret == 32) {
-		efuse.get_leakage = rk3288_get_leakage;
-		efuse.efuse_version = rk3288_get_efuse_version();
-		efuse.process_version = rk3288_get_process_version();
-		rockchip_set_cpu_version((efuse_buf[6] >> 4) & 3);
-		rk3288_set_system_serial();
-	} else {
-		pr_err("failed to read eFuse, return %d\n", ret);
-	}
-}
-
-void __init rockchip_efuse_init(void)
-{
-	int ret;
-
-	if (cpu_is_rk3288() || cpu_is_rk3228()) {
-		rk3288_efuse_init();
-	} else if (cpu_is_rk312x()) {
-		ret = rk312x_efuse_readregs(0, 32, efuse_buf);
-		if (ret == 32)
-			efuse.get_leakage = rk3288_get_leakage;
-		else
-			pr_err("failed to read eFuse, return %d\n", ret);
-	}
-}
-
-#ifdef CONFIG_ARM64
-static int __init rockchip_efuse_probe(struct platform_device *pdev)
-{
-	struct resource *regs;
-
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!regs) {
-		dev_err(&pdev->dev, "failed to get I/O memory\n");
-		return -ENODEV;
-	}
-	efuse_phys = regs->start;
-
-	rk3288_efuse_init();
-	return 0;
-}
-
-static const struct of_device_id rockchip_efuse_of_match[] = {
-	{ .compatible = "rockchip,rk3368-efuse-256", .data = NULL, },
-	{},
-};
-
-static struct platform_driver rockchip_efuse_driver = {
-	.driver		= {
-		.name		= "efuse",
-		.owner		= THIS_MODULE,
-		.of_match_table	= of_match_ptr(rockchip_efuse_of_match),
-	},
-};
-
-static int __init rockchip_efuse_module_init(void)
-{
-	return platform_driver_probe(&rockchip_efuse_driver,
-				     rockchip_efuse_probe);
-}
-arch_initcall_sync(rockchip_efuse_module_init);
-#endif
diff --git a/arch/arm/mach-rockchip/efuse.h b/arch/arm/mach-rockchip/efuse.h
deleted file mode 100644
index 96193114aaa9..000000000000
--- a/arch/arm/mach-rockchip/efuse.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef _EFUSE_H_
-#define _EFUSE_H_
-
-#include <asm/types.h>
-
-/* eFuse controller register */
-#define EFUSE_A_SHIFT		(6)
-#define RK312X_EFUSE_A_SHIFT	(7)
-#define EFUSE_A_MASK		(0x3FF)
-//#define EFUSE_PD		(1 << 5)
-//#define EFUSE_PS		(1 << 4)
-#define EFUSE_PGENB		(1 << 3) //active low
-#define EFUSE_LOAD		(1 << 2)
-#define EFUSE_STROBE		(1 << 1)
-#define EFUSE_CSB		(1 << 0) //active low
-
-#define REG_EFUSE_CTRL		(0x0000)
-#define REG_EFUSE_DOUT		(0x0004)
-
-#define ARM_LEAKAGE_CH	0
-#define GPU_LEAKAGE_CH	1
-#define LOG_LEAKAGE_CH	2
-
-#define RK3288_PROCESS_V0	0
-#define RK3288_PROCESS_V1	1
-#define RK3288_PROCESS_V2	2
-
-int rockchip_efuse_version(void);
-int rockchip_process_version(void);
-int rockchip_get_leakage(int ch);
-int rockchip_efuse_get_temp_adjust(int ch);
-#endif
diff --git a/arch/arm/mach-rockchip/fpga.c b/arch/arm/mach-rockchip/fpga.c
deleted file mode 100644
index fc3e22290ad5..000000000000
--- a/arch/arm/mach-rockchip/fpga.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Device Tree support for Rockchip FPGA
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clocksource.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-
-static struct map_desc rk3288_io_desc[] __initdata = {
-	{
-		.virtual	= (unsigned long) RK_DEBUG_UART_VIRT,
-		.pfn		= __phys_to_pfn(RK3288_UART_DBG_PHYS),
-		.length		= RK3288_UART_SIZE,
-		.type		= MT_DEVICE,
-	},
-};
-
-static void __init rk3288_fpga_map_io(void)
-{
-	iotable_init(rk3288_io_desc, ARRAY_SIZE(rk3288_io_desc));
-	debug_ll_io_init();
-
-	rockchip_soc_id = ROCKCHIP_SOC_RK3288;
-}
-
-static void __init rk3288_fpga_init_timer(void)
-{
-	clocksource_of_init();
-}
-
-static const char * const rk3288_fpga_compat[] __initconst = {
-	"rockchip,rk3288-fpga",
-	NULL,
-};
-
-DT_MACHINE_START(RK3288_FPGA_DT, "Rockchip RK3288 FPGA (Flattened Device Tree)")
-	.map_io		= rk3288_fpga_map_io,
-	.init_time	= rk3288_fpga_init_timer,
-	.dt_compat	= rk3288_fpga_compat,
-MACHINE_END
diff --git a/arch/arm/mach-rockchip/hotplug.c b/arch/arm/mach-rockchip/hotplug.c
deleted file mode 100644
index bb2f7dcc6044..000000000000
--- a/arch/arm/mach-rockchip/hotplug.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2012-2014 ROCKCHIP, Inc.
- * Copyright (C) 2002 ARM Ltd.
- * All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/smp.h>
-#include <linux/delay.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/pmu.h>
-
-#include <asm/cacheflush.h>
-#include <asm/cp15.h>
-#include <asm/smp_plat.h>
-#include <asm/system.h>
-
-
-static cpumask_t dead_cpus;
-
-int rockchip_cpu_kill(unsigned int cpu)
-{
-	int k;
-
-	/* this function is running on another CPU than the offline target,
-	 * here we need wait for shutdown code in platform_cpu_die() to
-	 * finish before asking SoC-specific code to power off the CPU core.
-	 */
-	for (k = 0; k < 1000; k++) {
-		if (cpumask_test_cpu(cpu, &dead_cpus)) {
-			mdelay(1);
-			rockchip_pmu_ops.set_power_domain(PD_CPU_0 + cpu, false);
-			return 1;
-		}
-
-		mdelay(1);
-	}
-
-	return 0;
-}
-
-/*
- * platform-specific code to shutdown a CPU
- *
- * Called with IRQs disabled
- */
-void rockchip_cpu_die_a9(unsigned int cpu)
-{
-	unsigned int v;
-
-	/* hardware shutdown code running on the CPU that is being offlined */
-	flush_cache_all();
-	dsb();
-
-	/* notify platform_cpu_kill() that hardware shutdown is finished */
-	cpumask_set_cpu(cpu, &dead_cpus);
-	flush_cache_louis();
-
-	asm volatile(
-	"       mcr     p15, 0, %1, c7, c5, 0\n"
-	"       mcr     p15, 0, %1, c7, c10, 4\n"
-	/*
-	 * Turn off coherency
-	 */
-	"       mrc     p15, 0, %0, c1, c0, 1\n"
-	"       bic     %0, %0, %3\n"		// clear ACTLR.SMP | ACTLR.FW
-	"       mcr     p15, 0, %0, c1, c0, 1\n"
-	"       mrc     p15, 0, %0, c1, c0, 0\n"
-	"       bic     %0, %0, %2\n"
-	"       mcr     p15, 0, %0, c1, c0, 0\n"
-	  : "=&r" (v)
-	  : "r" (0), "Ir" (CR_C), "Ir" ((1 << 6) | (1 << 0))
-	  : "cc");
-
-	/* wait for SoC code in platform_cpu_kill() to shut off CPU core
-	 * power. CPU bring up starts from the reset vector.
-	 */
-	while (1) {
-		dsb();
-		wfi();
-	}
-}
-
-void rockchip_cpu_die(unsigned int cpu)
-{
-	/* notify platform_cpu_kill() that hardware shutdown is finished */
-	cpumask_set_cpu(cpu, &dead_cpus);
-	flush_cache_louis();
-
-	v7_exit_coherency_flush(louis);
-
-	while (1) {
-		dsb();
-		wfi();
-	}
-}
-
-int rockchip_cpu_disable(unsigned int cpu)
-{
-	cpumask_clear_cpu(cpu, &dead_cpus);
-	/*
-	 * we don't allow CPU 0 to be shutdown (it is still too special
-	 * e.g. clock tick interrupts)
-	 */
-	return cpu == 0 ? -EPERM : 0;
-}
diff --git a/arch/arm/mach-rockchip/last_log.c b/arch/arm/mach-rockchip/last_log.c
deleted file mode 100644
index c2824f253dcd..000000000000
--- a/arch/arm/mach-rockchip/last_log.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- *  arch/arm/mach-rockchip/last_log.c
- *
- *  Copyright (C) 2011-2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#define pr_fmt(fmt) "last_log: " fmt
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/proc_fs.h>
-#include <linux/vmalloc.h>
-#include <linux/rockchip/cpu.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-
-#define LOG_BUF_SHIFT	CONFIG_LOG_BUF_SHIFT
-#define LOG_BUF_LEN	(1 << LOG_BUF_SHIFT)
-#define LOG_BUF_PAGE_ORDER	(LOG_BUF_SHIFT - PAGE_SHIFT)
-static char *last_log_buf;
-static char *log_buf;
-static size_t log_pos;
-static char early_log_buf[8192];
-
-char *rk_last_log_get(unsigned *size)
-{
-	*size = LOG_BUF_LEN;
-	return last_log_buf;
-}
-
-static ssize_t last_log_read(struct file *file, char __user *buf,
-				    size_t len, loff_t *offset)
-{
-	loff_t pos = *offset;
-	ssize_t count;
-
-	if (pos >= LOG_BUF_LEN)
-		return 0;
-
-	count = min(len, (size_t)(LOG_BUF_LEN - pos));
-	if (copy_to_user(buf, &last_log_buf[pos], count))
-		return -EFAULT;
-
-	*offset += count;
-	return count;
-}
-
-static const struct file_operations last_log_fops = {
-	.owner = THIS_MODULE,
-	.read = last_log_read,
-};
-
-static void * __init last_log_vmap(phys_addr_t start, unsigned int page_count)
-{
-	struct page *pages[page_count + 1];
-	unsigned int i;
-	pgprot_t prot;
-
-	for (i = 0; i < page_count; i++) {
-		phys_addr_t addr = start + i * PAGE_SIZE;
-		pages[i] = pfn_to_page(addr >> PAGE_SHIFT);
-	}
-	pages[page_count] = pfn_to_page(start >> PAGE_SHIFT);
-#ifdef CONFIG_ARM64
-	prot = pgprot_writecombine(PAGE_KERNEL);
-#else
-	prot = pgprot_noncached(PAGE_KERNEL);
-#endif
-	return vmap(pages, page_count + 1, VM_MAP, prot);
-}
-
-static int __init rk_last_log_init(void)
-{
-	size_t early_log_size;
-	char *buf;
-	struct proc_dir_entry *entry;
-	phys_addr_t buf_phys;
-
-	buf = (char *)__get_free_pages(GFP_KERNEL, LOG_BUF_PAGE_ORDER);
-	if (!buf) {
-		pr_err("failed to __get_free_pages(%d)\n", LOG_BUF_PAGE_ORDER);
-		return 0;
-	}
-	buf_phys = virt_to_phys(buf);
-
-	log_buf = last_log_vmap(buf_phys, 1 << LOG_BUF_PAGE_ORDER);
-	if (!log_buf) {
-		pr_err("failed to map %d pages at %pa\n", 1 << LOG_BUF_PAGE_ORDER,
-		       &buf_phys);
-		return 0;
-	}
-
-	last_log_buf = (char *)vmalloc(LOG_BUF_LEN);
-	if (!last_log_buf) {
-		pr_err("failed to vmalloc(%d)\n", LOG_BUF_LEN);
-		return 0;
-	}
-
-	memcpy(last_log_buf, buf, LOG_BUF_LEN);
-	early_log_size = log_pos > sizeof(early_log_buf) ? sizeof(early_log_buf) : log_pos;
-	memcpy(log_buf, early_log_buf, early_log_size);
-	memset(log_buf + early_log_size, 0, LOG_BUF_LEN - early_log_size);
-
-	pr_info("%pa map to 0x%p and copy to 0x%p, size 0x%x early 0x%zx (version 3.1)\n", &buf_phys, log_buf, last_log_buf, LOG_BUF_LEN, early_log_size);
-
-	entry = proc_create("last_kmsg", S_IRUSR, NULL, &last_log_fops);
-	if (!entry) {
-		pr_err("failed to create proc entry\n");
-		return 0;
-	}
-	proc_set_size(entry, LOG_BUF_LEN);
-
-	proc_symlink("last_log", NULL, "last_kmsg");
-
-	return 0;
-}
-
-early_initcall(rk_last_log_init);
-
-void rk_last_log_text(char *text, size_t size)
-{
-	char *buf = log_buf ? log_buf : early_log_buf;
-	size_t log_size = log_buf ? LOG_BUF_LEN : sizeof(early_log_buf);
-	size_t pos;
-
-	/* Check overflow */
-	pos = log_pos & (log_size - 1);
-	if (likely(size + pos <= log_size))
-		memcpy(&buf[pos], text, size);
-	else {
-		size_t first = log_size - pos;
-		size_t second = size - first;
-		memcpy(&buf[pos], text, first);
-		memcpy(&buf[0], text + first, second);
-	}
-
-	log_pos += size;
-}
diff --git a/arch/arm/mach-rockchip/loader.h b/arch/arm/mach-rockchip/loader.h
deleted file mode 100644
index bf2cd47320e4..000000000000
--- a/arch/arm/mach-rockchip/loader.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef __MACH_ROCKCHIP_LOADER_H
-#define __MACH_ROCKCHIP_LOADER_H
-
-#define SYS_LOADER_REBOOT_FLAG   0x5242C300  //high 24 bits is tag, low 8 bits is type
-#define SYS_KERNRL_REBOOT_FLAG   0xC3524200  //high 24 bits is tag, low 8 bits is type
-
-enum {
-    BOOT_NORMAL = 0, /* normal boot */
-    BOOT_LOADER,     /* enter loader rockusb mode */
-    BOOT_MASKROM,    /* enter maskrom rockusb mode (not support now) */
-    BOOT_RECOVER,    /* enter recover */
-    BOOT_NORECOVER,  /* do not enter recover */
-    BOOT_SECONDOS,   /* boot second OS (not support now)*/
-    BOOT_WIPEDATA,   /* enter recover and wipe data. */
-    BOOT_WIPEALL,    /* enter recover and wipe all data. */
-    BOOT_CHECKIMG,   /* check firmware img with backup part(in loader mode)*/
-    BOOT_FASTBOOT,   /* enter fast boot mode */
-    BOOT_SECUREBOOT_DISABLE,
-    BOOT_CHARGING,   /* enter charge mode */
-    BOOT_MAX         /* MAX VALID BOOT TYPE.*/
-};
-
-#endif
diff --git a/arch/arm/mach-rockchip/pm-pie.c b/arch/arm/mach-rockchip/pm-pie.c
deleted file mode 100755
index c12fc014c0c0..000000000000
--- a/arch/arm/mach-rockchip/pm-pie.c
+++ /dev/null
@@ -1,140 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/suspend.h>
-#include "pm.h"
-//#include "sram.h"
-
-/*************************dump reg********************************************/
-
-#if 0 // not used
-
-static void __sramfunc rkpm_sram_regs_dump(u32 base_addr,u32 start_offset,u32 end_offset)
-{
-	u32 i;
-       /* 
-        rkpm_sram_printch('\n');
-        rkpm_sram_printhex(base_addr);
-        rkpm_sram_printch(':');
-        rkpm_sram_printch('\n');     
-     */
-	for(i=start_offset;i<=end_offset;)
-	{
-            rkpm_sram_printhex(i);	 
-            rkpm_sram_printch('-');
-            rkpm_sram_printhex(readl_relaxed((void *)(base_addr + i)));	 
-            if(!(i%5)&&i!=0)
-            rkpm_sram_printch('\n');
-            i+=4;
-	}
-    
-    rkpm_sram_printch('\n');
-
-}
-#endif
-
-struct rkpm_sram_ops DEFINE_PIE_DATA(pm_sram_ops);
-//for sram
-static __sramdata u32 rkpm_sram_ctrbits;
-
-/****************** for pm.c and in sram***************************************/
-//only usr in sram function
-#define rkpm_chk_sram_ctrbit(bit) (rkpm_sram_ctrbits&(bit))
-#define rkpm_chk_sram_ctrbits(bits) (rkpm_sram_ctrbits&(bits))
-
-#define  RKPM_SRAM_FUN(fun) \
-        if(DATA(pm_sram_ops).fun)\
-            (DATA(pm_sram_ops).fun)()
-		
-#define  RKPM_BITCTR_SRAM_FUN(ctr,fun) \
-	if(rkpm_chk_sram_ctrbit(RKPM_CTR_##ctr)&&DATA(pm_sram_ops).fun)\
-		(DATA(pm_sram_ops).fun)()   
-		
-// fun with paramater
-#define  RKPM_BITSCTR_SRAM_PFUN(bits,fun,fun_p) \
-    if(rkpm_chk_sram_ctrbits(bits)&&DATA(pm_sram_ops).fun_p) \
-        {DATA(pm_sram_ops).fun;} while(0)
-/********************************sram print**********************************/
-
-void PIE_FUNC(rkpm_sram_printch_pie)(char byte)
-{
-    if(DATA(pm_sram_ops).printch)
-           DATA(pm_sram_ops).printch(byte); 
-    
-   // if (byte == '\n')
-        //FUNC(rkpm_sram_printch_pie)('\r');
-}
-EXPORT_PIE_SYMBOL(FUNC(rkpm_sram_printch_pie));
-
-
-void  PIE_FUNC(rkpm_sram_printhex_pie)(unsigned int hex)
-{
-    int i = 8;
-     FUNC(rkpm_sram_printch_pie)('0');
-     FUNC(rkpm_sram_printch_pie)('x');
-    while (i--) {
-    	unsigned char c = (hex & 0xF0000000) >> 28;
-    	 FUNC(rkpm_sram_printch_pie)(c < 0xa ? c + '0' : c - 0xa + 'a');
-    	hex <<= 4;
-    }
-}
-EXPORT_PIE_SYMBOL(FUNC(rkpm_sram_printhex_pie));
-
-
-/******************************************pm main function******************************************/
-#define RKPM_CTR_SYSCLK RKPM_OR_3BITS(SYSCLK_DIV,SYSCLK_32K,SYSCLK_OSC_DIS)
-
-static void __sramfunc rkpm_sram_suspend(u32 ctrbits)
-{
-	rkpm_sram_printch('7');
-	RKPM_BITCTR_SRAM_FUN(VOLTS, volts);
-	rkpm_sram_printch('8');
-	RKPM_BITCTR_SRAM_FUN(BUS_IDLE, bus_idle_request);
-	RKPM_BITCTR_SRAM_FUN(DDR, ddr);
-
-	/*rkpm_sram_printch('8');*/
-	/*RKPM_BITCTR_SRAM_FUN(VOLTS,volts);*/
-	/*rkpm_sram_printch('9');*/
-	/* RKPM_BITCTR_SRAM_FUN(GTCLKS,gtclks);*/
-
-	RKPM_BITSCTR_SRAM_PFUN(RKPM_CTR_SYSCLK,sysclk(rkpm_sram_ctrbits),sysclk);
-	
-	RKPM_BITCTR_SRAM_FUN(PMIC,pmic);
-         
-        //  if(rkpm_chk_sram_ctrbit(RKPM_CTR_SRAM_NO_WFI))
-        {
-            dsb();
-            wfi();
-        }
-
-	RKPM_BITCTR_SRAM_FUN(PMIC,re_pmic);
-     
-	RKPM_BITSCTR_SRAM_PFUN(RKPM_CTR_SYSCLK,re_sysclk(rkpm_sram_ctrbits),re_sysclk);
-    
-	/*RKPM_BITCTR_SRAM_FUN(GTCLKS,re_gtclks);*/
-    
-	rkpm_sram_printch('9');
-	RKPM_BITCTR_SRAM_FUN(VOLTS,re_volts);
-    
-	rkpm_sram_printch('8');	
-	RKPM_BITCTR_SRAM_FUN(DDR,re_ddr);
-    
-	rkpm_sram_printch('7');	
-}
-
-void PIE_FUNC(rkpm_sram_suspend_arg)(void *arg)
-{
-    rkpm_sram_ctrbits=*((u32 *)arg);
-    
-   // rkpm_sram_printhex(rkpm_sram_ctrbits); 
-    //rkpm_sram_printhex(*((u32 *)arg));
-    rkpm_sram_suspend(rkpm_sram_ctrbits);    
-}
-EXPORT_PIE_SYMBOL(FUNC(rkpm_sram_suspend_arg));
-static void rkpm_pie_init(void)
-{
-    if(rockchip_pie_chunk)
-    {
-        rkpm_set_pie_info(kern_to_pie(rockchip_pie_chunk, &DATA(pm_sram_ops))
-                        ,fn_to_pie(rockchip_pie_chunk, &FUNC(rkpm_sram_suspend_arg)));
-    }
-}
diff --git a/arch/arm/mach-rockchip/pm-rk312x.c b/arch/arm/mach-rockchip/pm-rk312x.c
deleted file mode 100644
index 475f6d0e2b0c..000000000000
--- a/arch/arm/mach-rockchip/pm-rk312x.c
+++ /dev/null
@@ -1,1074 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/hardware/cache-l2x0.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/wakeup_reason.h>
-#include <linux/pm.h>
-#include <linux/suspend.h>
-#include <linux/of.h>
-#include <linux/io.h>
-#include <linux/of_address.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include "pm.h"
-#include <linux/irqchip/arm-gic.h>
-#include "pm-pie.c"
-
-__weak void rk_usb_power_down(void);
-__weak void rk_usb_power_up(void);
-
-#define GPIO_INTEN 0x30
-#define GPIO_INT_STATUS 0x40
-#define GIC_DIST_PENDING_SET 0x200
-#define DUMP_GPIO_INTEN(ID)\
-do { \
-	u32 en = readl_relaxed(RK_GPIO_VIRT(ID) + GPIO_INTEN);\
-	if (en) {\
-		rkpm_ddr_printascii("GPIO" #ID "_INTEN: "); \
-		rkpm_ddr_printhex(en); \
-		rkpm_ddr_printch('\n'); \
-	} \
-} while (0)
-#define RK312X_CRU_UNGATING_OPS(id) cru_writel(\
-	CRU_W_MSK_SETBITS(0,  (id) % 16, 0x1), RK312X_CRU_GATEID_CONS((id)))
-#define RK312X_CRU_GATING_OPS(id) cru_writel(\
-	CRU_W_MSK_SETBITS(1, (id) % 16, 0x1), RK312X_CRU_GATEID_CONS((id)))
-
-enum rk_plls_id {
-	APLL_ID = 0,
-	DPLL_ID,
-	CPLL_ID,
-	GPLL_ID,
-	END_PLL_ID,
-};
-
-static inline void  uart_printch(char bbyte)
-{
-	u32 reg_save[2];
-	u32 u_clk_id = (RK312X_CLKGATE_UART0_SRC + CONFIG_RK_DEBUG_UART * 2);
-	u32 u_pclk_id = (RK312X_CLKGATE_PCLK_UART0 + CONFIG_RK_DEBUG_UART);
-
-	reg_save[0] = cru_readl(RK312X_CRU_GATEID_CONS(u_clk_id));
-	reg_save[1] = cru_readl(RK312X_CRU_GATEID_CONS(u_pclk_id));
-	RK312X_CRU_UNGATING_OPS(u_clk_id);
-	RK312X_CRU_UNGATING_OPS(u_pclk_id);
-	rkpm_udelay(1);
-
-write_uart:
-	writel_relaxed(bbyte, RK_DEBUG_UART_VIRT);
-	dsb();
-
-	while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-		barrier();
-
-	if (bbyte == '\n') {
-		bbyte = '\r';
-		goto write_uart;
-	}
-
-	cru_writel(reg_save[0] | CRU_W_MSK(u_clk_id
-		% 16, 0x1), RK312X_CRU_GATEID_CONS(u_clk_id));
-	cru_writel(reg_save[1] | CRU_W_MSK(u_pclk_id
-		% 16, 0x1), RK312X_CRU_GATEID_CONS(u_pclk_id));
-
-	if (0) {
-write_uart1:
-		writel_relaxed(bbyte, RK_DEBUG_UART_VIRT);
-		dsb();
-
-		while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-			barrier();
-	if (bbyte == '\n') {
-		bbyte = '\r';
-		goto write_uart1;
-		}
-	}
-}
-
-void PIE_FUNC(sram_printch)(char byte)
-{
-	uart_printch(byte);
-}
-static void pll_udelay(u32 udelay)
-{
-	u32 mode;
-
-	mode = cru_readl(RK312X_CRU_MODE_CON);
-	cru_writel(RK312X_PLL_MODE_SLOW(APLL_ID), RK312X_CRU_MODE_CON);
-	rkpm_udelay(udelay * 5);
-	cru_writel(mode|(RK312X_PLL_MODE_MSK(APLL_ID)
-		<< 16), RK312X_CRU_MODE_CON);
-}
-
-#define RK312X_PLL_PWR_DN_MSK (0x01 << 1)
-#define RK312X_PLL_BYPASS CRU_W_MSK_SETBITS(1, 0xF, 0x01)
-#define RK312X_PLL_NOBYPASS CRU_W_MSK_SETBITS(0, 0xF, 0x01)
-#define RK312X_PLL_RESET CRU_W_MSK_SETBITS(1, 14, 0x01)
-#define RK312X_PLL_RESET_RESUME CRU_W_MSK_SETBITS(0, 14, 0x01)
-#define RK312X_PLL_POWERDOWN CRU_W_MSK_SETBITS(1, 0xD, 0x01)
-#define RK312X_PLL_POWERON CRU_W_MSK_SETBITS(0, 0xD, 0x01)
-
-static u32 plls_con0_save[END_PLL_ID];
-static u32 plls_con1_save[END_PLL_ID];
-static u32 plls_con2_save[END_PLL_ID];
-static u32 cru_mode_con;
-
-static void pm_pll_wait_lock(u32 pll_idx)
-{
-	u32 delay = 600000U;
-
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	while (delay > 0) {
-		if ((cru_readl(RK312X_PLL_CONS(pll_idx, 1)) & (0x1 << 10)))
-			break;
-		delay--;
-	}
-	if (delay == 0) {
-		rkpm_ddr_printascii("unlock-pll:");
-		rkpm_ddr_printhex(pll_idx);
-		rkpm_ddr_printch('\n');
-	}
-}
-
-static inline void plls_suspend(u32 pll_id)
-{
-	plls_con0_save[pll_id] = cru_readl(RK312X_PLL_CONS((pll_id), 0));
-	plls_con1_save[pll_id] = cru_readl(RK312X_PLL_CONS((pll_id), 1));
-	plls_con2_save[pll_id] = cru_readl(RK312X_PLL_CONS((pll_id), 2));
-
-	/*cru_writel(RK312X_PLL_BYPASS, RK312X_PLL_CONS((pll_id), 0));*/
-	cru_writel(RK312X_PLL_POWERDOWN, RK312X_PLL_CONS((pll_id), 1));
-}
-static inline void plls_resume(u32 pll_id)
-{
-	u32 pllcon0, pllcon1, pllcon2;
-
-	/*cru_writel(RK312X_PLL_MODE_SLOW(pll_id), RK312X_CRU_MODE_CON);*/
-	/*cru_writel(RK312X_PLL_NOBYPASS, RK312x_PLL_CONS((pll_id), 0));*/
-
-	pllcon0 = plls_con0_save[pll_id];
-	/*cru_readl(RK312x_PLL_CONS((pll_id),0));*/
-	pllcon1 = plls_con1_save[pll_id];
-	/*cru_readl(RK12x_PLL_CONS((pll_id),1));*/
-	pllcon2 = plls_con2_save[pll_id];
-	/*cru_readl(RK312x_PLL_CONS((pll_id),2));*/
-
-	cru_writel(RK312X_PLL_POWERON, RK312X_PLL_CONS((pll_id), 1));
-
-	pll_udelay(5);
-
-	/*return form rest*/
-	/*cru_writel(RK312X_PLL_RESET_RESUME, RK312X_PLL_CONS(pll_id, 1));*/
-
-	/*wating lock state*/
-	pll_udelay(168);
-	pm_pll_wait_lock(pll_id);
-
-}
-static u32 clk_sel0, clk_sel1, clk_sel10, clk_sel24, clk_sel29;
-static void pm_plls_suspend(void)
-{
-	clk_sel0 = cru_readl(RK312X_CRU_CLKSELS_CON(0));
-	clk_sel1 = cru_readl(RK312X_CRU_CLKSELS_CON(1));
-	clk_sel10 = cru_readl(RK312X_CRU_CLKSELS_CON(10));
-	clk_sel24 = cru_readl(RK312X_CRU_CLKSELS_CON(24));
-	clk_sel29 = cru_readl(RK312X_CRU_CLKSELS_CON(29));
-
-	cru_mode_con = cru_readl(RK312X_CRU_MODE_CON);
-
-	/*CPLL*/
-	cru_writel(RK312X_PLL_MODE_SLOW(CPLL_ID), RK312X_CRU_MODE_CON);
-
-	/*GPLL*/
-	cru_writel(RK312X_PLL_MODE_SLOW(GPLL_ID), RK312X_CRU_MODE_CON);
-
-	/*crypto*/
-	cru_writel(CRU_W_MSK_SETBITS(3, 0, 0x3), RK312X_CRU_CLKSELS_CON(24));
-
-	/* peri aclk hclk pclk*/
-	cru_writel(0
-		|CRU_W_MSK_SETBITS(0, 0, 0x1f)/*1 aclk*/
-		|CRU_W_MSK_SETBITS(0, 8, 0x3)/*2   hclk 0 1:1,1 2:1 ,2 4:1*/
-		|CRU_W_MSK_SETBITS(0, 12, 0x3)/* 2     0~3  1 2 4 8 div*/
-		, RK312X_CRU_CLKSELS_CON(10));
-
-	/* pmu*/
-	cru_writel(CRU_W_MSK_SETBITS(0, 8, 0x1f), RK312X_CRU_CLKSELS_CON(29));
-	plls_suspend(CPLL_ID);
-	plls_suspend(GPLL_ID);
-
-	/*apll*/
-	cru_writel(RK312X_PLL_MODE_SLOW(APLL_ID), RK312X_CRU_MODE_CON);
-	/*a7_core*/
-	cru_writel(0 | CRU_W_MSK_SETBITS(0, 0, 0x1f)
-	, RK312X_CRU_CLKSELS_CON(0));
-
-	/*pclk_dbg*/
-	cru_writel(0 | CRU_W_MSK_SETBITS(3, 0, 0x7)
-	, RK312X_CRU_CLKSELS_CON(1));
-	plls_suspend(APLL_ID);
-}
-
-static void pm_plls_resume(void)
-{
-	plls_resume(APLL_ID);
-	cru_writel(clk_sel0 | CRU_W_MSK(0, 0x1f), RK312X_CRU_CLKSELS_CON(0));
-	cru_writel(clk_sel1 | CRU_W_MSK(0, 0x7), RK312X_CRU_CLKSELS_CON(1));
-	cru_writel(cru_mode_con
-		|(RK312X_PLL_MODE_MSK(APLL_ID) << 16), RK312X_CRU_MODE_CON);
-
-	/* pmu alive */
-	plls_resume(GPLL_ID);
-	/*peri aclk hclk pclk*/
-	cru_writel(clk_sel10 | (CRU_W_MSK(0, 0x1f) | CRU_W_MSK(8, 0x3)
-	| CRU_W_MSK(12, 0x3)), RK312X_CRU_CLKSELS_CON(10));
-	/* crypto*/
-	cru_writel(clk_sel24 | CRU_W_MSK(0, 0x3), RK312X_CRU_CLKSELS_CON(24));
-	cru_writel(clk_sel29 | CRU_W_MSK(8, 0x1f), RK312X_CRU_CLKSELS_CON(29));
-	cru_writel(cru_mode_con | (RK312X_PLL_MODE_MSK(GPLL_ID) << 16)
-		, RK312X_CRU_MODE_CON);
-
-	plls_resume(CPLL_ID);
-	cru_writel(cru_mode_con | (RK312X_PLL_MODE_MSK(CPLL_ID) << 16)
-		, RK312X_CRU_MODE_CON);
-}
-#ifdef CONFIG_RK_LAST_LOG
-extern void rk_last_log_text(char *text, size_t size);
-#endif
-
-static void  ddr_printch(char byte)
-{
-	uart_printch(byte);
-#ifdef CONFIG_RK_LAST_LOG
-	rk_last_log_text(&byte, 1);
-
-	if (byte == '\n') {
-		byte = '\r';
-		rk_last_log_text(&byte, 1);
-	}
-#endif
-	pll_udelay(2);
-}
-
-static noinline void rk312x_pm_dump_inten(void)
-{
-	DUMP_GPIO_INTEN(0);
-	DUMP_GPIO_INTEN(1);
-	DUMP_GPIO_INTEN(2);
-	DUMP_GPIO_INTEN(3);
-}
-static noinline void rk312x_pm_dump_irq(void)
-{
-	u32 irq[4];
-	int i;
-
-	u32 irq_gpio = (readl_relaxed(RK_GIC_VIRT +
-GIC_DIST_PENDING_SET + 8) >> 4) & 0x0F;
-
-	for (i = 0; i < ARRAY_SIZE(irq); i++)
-		irq[i] = readl_relaxed(RK_GIC_VIRT +
-GIC_DIST_PENDING_SET + (1 + i) * 4);
-	for (i = 0; i < ARRAY_SIZE(irq); i++) {
-		if (irq[i])
-			log_wakeup_reason(32 * (i + 1) + fls(irq[i]) - 1);
-	}
-	for (i = 0; i <= 3; i++) {
-		if (irq_gpio & (1 << i)) {
-			pr_debug("wakeup gpio%d: %08x\n", i
-				, readl_relaxed(RK_GPIO_VIRT(i)
-				+ GPIO_INT_STATUS));
-			rkpm_ddr_printascii("wakeup gpio");
-			rkpm_ddr_printhex(i);
-			rkpm_ddr_printascii(":");
-			rkpm_ddr_printhex(readl_relaxed(RK_GPIO_VIRT(i)
-				+ GPIO_INT_STATUS));
-			rkpm_ddr_printch('\n');
-		}
-	}
-}
-
-static void rkpm_prepare(void)
-{
-	rk312x_pm_dump_inten();
-}
-static void rkpm_finish(void)
-{
-	rk312x_pm_dump_irq();
-}
-enum rk312x_pwr_mode_con {
-	pmu_power_mode_en = 0,
-	pmu_clk_core_src_gate_en,
-	pmu_clk_bus_src_gate_en,
-	pmu_global_int_disable,
-
-	pmu_core_pd_en,
-	pmu_use_if,
-	pmu_wait_osc_24m,
-	pmu_sref_enter_en,
-
-	pmu_ddr_gating_en,
-	pmu_int_en,
-	pmu_ddr0io_ret_de_req,
-
-	pmu_clr_crypto = 16,
-	pmu_clr_msch,
-	pmu_clr_sys,
-	pmu_clr_core,
-
-	pmu_clr_gpu,
-	pmu_clr_vio,
-	pmu_clr_video,
-	pmu_clr_peri,
-};
-#define SOC_REMAP 12
-#define GRF_SOC_CON0 0x140
-
-#define RK312X_IMEM_VIRT (RK_BOOTRAM_VIRT + SZ_32K)
-#define RKPM_BOOTRAM_PHYS (RK312X_IMEM_PHYS)
-#define RKPM_BOOTRAM_BASE (RK312X_IMEM_VIRT)
-#define RKPM_BOOTRAM_SIZE (RK312X_IMEM_SIZE)
-
-#define RKPM_BOOT_CODE_OFFSET (0x0)
-#define RK312XPM_BOOT_CODE_SIZE	(0x700)
-
-#define RK312XPM_BOOT_DATA_OFFSET (RKPM_BOOT_CODE_OFFSET \
-	+ RK312XPM_BOOT_CODE_SIZE)
-#define RKPM_BOOT_DATA_SIZE	(RKPM_BOOTDATA_ARR_SIZE*4)
-
-#define RK312XPM_BOOT_DDRCODE_OFFSET (RK312XPM_BOOT_DATA_OFFSET\
-	+RKPM_BOOT_DATA_SIZE)
-
-#define  RKPM_BOOT_CODE_PHY  (RKPM_BOOTRAM_PHYS + RKPM_BOOT_CODE_OFFSET)
-#define  RKPM_BOOT_CODE_BASE  (RKPM_BOOTRAM_BASE + RKPM_BOOT_CODE_OFFSET)
-
-#define  RKPM_BOOT_DATA_PHY  (RKPM_BOOTRAM_PHYS + RK312XPM_BOOT_DATA_OFFSET)
-#define  RKPM_BOOT_DATA_BASE  (RKPM_BOOTRAM_BASE + RK312XPM_BOOT_DATA_OFFSET)
-
-/*ddr resume data in boot ram*/
-#define  RKPM_BOOT_DDRCODE_PHY   (RKPM_BOOTRAM_PHYS \
-	+ RK312XPM_BOOT_DDRCODE_OFFSET)
-#define  RKPM_BOOT_DDRCODE_BASE  (RKPM_BOOTRAM_BASE \
-	+ RK312XPM_BOOT_DDRCODE_OFFSET)
-
-
-/*#define RKPM_BOOT_CPUSP_PHY (RKPM_BOOTRAM_PHYS+((RKPM_BOOTRAM_SIZE-1)&~0x7))*/
-#define RKPM_BOOT_CPUSP_PHY (0x00 + ((RKPM_BOOTRAM_SIZE - 1) & (~(0x7))))
-
-/*the value is used to control cpu resume flow*/
-static u32 sleep_resume_data[RKPM_BOOTDATA_ARR_SIZE];
-static char *resume_data_base = (char *)(RKPM_BOOT_DATA_BASE);
-/*static char *resume_data_phy=  (char *)( RKPM_BOOT_DATA_PHY);*/
-
-/*****save boot sram**********************/
-#define BOOT_RAM_SAVE_SIZE (RKPM_BOOTRAM_SIZE + 4 * 10)
-#define INT_RAM_SIZE (64 * 1024)
-static char boot_ram_data[BOOT_RAM_SAVE_SIZE];/*8K + 40byte*/
-static char int_ram_data[INT_RAM_SIZE];
-/******resume code *****************
-#define RKPM_BOOT_CODE_OFFSET (0x00)
-#define RKPM_BOOT_CODE_PHY (RKPM_BOOTRAM_PHYS + PM_BOOT_CODE_OFFSET)
-#define RKPM_BOOT_CODE_BASE (RKPM_BOOTRAM_BASE + PM_BOOT_CODE_OFFSET)
-#define RKPM_BOOT_CODE_SIZE (0x100)
-**************************************************/
-extern void rk312x_pm_slp_cpu_resume(void);
-
-static void sram_data_for_sleep(char *boot_save, char *int_save, u32 flag)
-{
-	char *addr_base, *addr_phy, *data_src, *data_dst;
-	u32 sr_size, data_size;
-
-	addr_base = (char *)RKPM_BOOTRAM_BASE;
-	addr_phy = (char *)RKPM_BOOTRAM_PHYS;
-	sr_size = RKPM_BOOTRAM_SIZE;  /*SZ8k*/
-	/**********save boot sarm***********************************/
-	if (boot_save)
-		memcpy(boot_save, addr_base, sr_size);
-	/**********move  resume code and data to boot sram*************/
-	data_dst = (char *)RKPM_BOOT_CODE_BASE;
-	data_src = (char *)rk312x_pm_slp_cpu_resume;
-	data_size = RK312XPM_BOOT_CODE_SIZE;
-
-	memcpy(data_dst, data_src, data_size);
-	data_dst = (char *)resume_data_base;
-	data_src = (char *)sleep_resume_data;
-	data_size = sizeof(sleep_resume_data);
-	memcpy((char *)data_dst, (char *)data_src, data_size);
-}
-static u32 rk312x_powermode;
-static u32 pmu_pwrmode_con;
-static u32 gpio_pmic_sleep_mode;
-static u32 grf_soc_con0;
-static u32 pmu_wakeup_conf;
-static u32 pmic_sleep_gpio;
-
-static u32 rkpm_slp_mode_set(u32 ctrbits)
-{
-	u32 pwr_mode_config;
-
-	if ((RKPM_CTR_ARMOFF_LPMD & ctrbits) == 0)
-		return 0;
-
-	pmu_wakeup_conf = pmu_readl(RK312X_PMU_WAKEUP_CFG);
-	/*grf_soc_con0 = grf_readl(GRF_SOC_CON0);*/
-	/*grf_writel((1 << SOC_REMAP)
-	| (1 << (SOC_REMAP + 16)), GRF_SOC_CON0);*/
-	/*grf_gpio1a_iomux = grf_readl(0x00b8);*/
-	/*grf_writel(0x00030003, 0xb8);*/
-
-	pmu_writel(0x01, RK312X_PMU_WAKEUP_CFG);
-	/* arm interrupt wake-up enable*/
-	/*grf_writel((1 << SOC_REMAP)
-	| (1 << (SOC_REMAP + 16)), GRF_SOC_CON0);*/
-	/*remap bit control, when soc_remap = 1, the bootrom is mapped to
-	 address 0x10100000,and internal memory is mapped to address 0x0.*/
-
-	/*grf_writel(0X00030002, 0xb4);
-	rk3126 GPIO1A1 : RK3128 GPIO3C1 iomux pmic-sleep*/
-	if (pmic_sleep_gpio == 0x1a10) {
-		ddr_printch('a');
-		gpio_pmic_sleep_mode = grf_readl(0xb8);
-		grf_writel(0X000C000C, 0xb8);
-	}
-	/*rk3126 GPIO1A1 : RK3128 GPIO3C1 iomux pmic-sleep*/
-	if (pmic_sleep_gpio == 0x3c10) {
-		ddr_printch('c');
-		gpio_pmic_sleep_mode = grf_readl(0xe0);
-		grf_writel(0X000C0008, 0xe0);
-	}
-	/*rk3126 GPIO3C1 : RK3128 GPIO3C1 iomux pmic-sleep*/
-
-	pwr_mode_config = BIT(pmu_power_mode_en) | BIT(pmu_global_int_disable);
-	pmu_pwrmode_con = pmu_readl(RK312X_PMU_PWRMODE_CON);
-	if (rkpm_chk_val_ctrbits(ctrbits, RKPM_CTR_IDLEAUTO_MD)) {
-		rkpm_ddr_printascii("-autoidle-");
-		pwr_mode_config |= BIT(pmu_clk_core_src_gate_en);
-	} else if (rkpm_chk_val_ctrbits(ctrbits, RKPM_CTR_ARMDP_LPMD)) {
-		rkpm_ddr_printascii("-armdp-");
-		pwr_mode_config |= BIT(pmu_core_pd_en);
-	} else if (rkpm_chk_val_ctrbits(ctrbits, RKPM_CTR_ARMOFF_LPMD)) {
-		rkpm_ddr_printascii("-armoff-");
-		/*arm power off */
-		pwr_mode_config |= 0
-				|BIT(pmu_clk_core_src_gate_en)
-				|BIT(pmu_clk_bus_src_gate_en)
-				| BIT(pmu_core_pd_en)
-			/*	| BIT(pmu_use_if)//aaa*/
-			/*	| BIT(pmu_sref_enter_en)*/
-				|BIT(pmu_int_en)
-			/*	| BIT(pmu_wait_osc_24m)*/
-			/*	| BIT(pmu_ddr_gating_en)*/
-			/*	| BIT(pmu_ddr0io_ret_de_req)*/
-				| BIT(pmu_clr_core)
-			/*	| BIT(pmu_clr_crypto)*/
-			/*	| BIT(pmu_clr_sys)*/
-				/*| BIT(pmu_clr_vio)*/
-				/*| BIT(pmu_clr_video)*/
-			/*| BIT(pmu_clr_peri)*/
-			/*	| BIT(pmu_clr_msch)*/
-				/*| BIT(pmu_clr_gpu) */
-				;
-	} else if (rkpm_chk_val_ctrbits(ctrbits, RKPM_CTR_ARMOFF_LPMD)) {
-		rkpm_ddr_printascii("-armoff ddr -");
-		/*arm power off */
-		pwr_mode_config |= 0
-				|BIT(pmu_clk_core_src_gate_en)
-				|BIT(pmu_clk_bus_src_gate_en)
-				| BIT(pmu_core_pd_en)
-			/*	| BIT(pmu_use_if)//aaa*/
-				| BIT(pmu_sref_enter_en)
-				|BIT(pmu_int_en)
-			/*	| BIT(pmu_wait_osc_24m)*/
-				| BIT(pmu_ddr_gating_en)
-				| BIT(pmu_ddr0io_ret_de_req)
-				| BIT(pmu_clr_core)
-				| BIT(pmu_clr_crypto)
-				| BIT(pmu_clr_sys)
-				/*| BIT(pmu_clr_vio)*/
-				/*| BIT(pmu_clr_video)*/
-				| BIT(pmu_clr_peri)
-				| BIT(pmu_clr_msch)
-				/*| BIT(pmu_clr_gpu) */
-				;
-	}
-	pmu_writel(32 * 30, RK312X_PMU_OSC_CNT);
-	pmu_writel(0xbb80, RK312X_PMU_CORE_PWRUP_CNT);
-	pmu_writel(pwr_mode_config, RK312X_PMU_PWRMODE_CON);
-	rk312x_powermode = pwr_mode_config;
-	return pmu_readl(RK312X_PMU_PWRMODE_CON);
-}
-
-static void sram_code_data_save(u32 pwrmode)
-{
-	sleep_resume_data[RKPM_BOOTDATA_L2LTY_F] = 0;
-	if (rkpm_chk_ctrbits(RKPM_CTR_VOL_PWM0))
-		sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325_F] |= 0x01;
-	if (rkpm_chk_ctrbits(RKPM_CTR_VOL_PWM1))
-		sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325_F] |= 0x02;
-	if (rkpm_chk_ctrbits(RKPM_CTR_VOL_PWM2))
-		sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325_F] |= 0x04;
-	sleep_resume_data[RKPM_BOOTDATA_DDR_F] = 0;
-	sleep_resume_data[RKPM_BOOTDATA_CPUSP] = RKPM_BOOT_CPUSP_PHY;
-	/*in sys resume ,ddr is need resume*/
-	sleep_resume_data[RKPM_BOOTDATA_CPUCODE] = virt_to_phys(cpu_resume);
-	/*in sys resume ,ddr is need resume*/
-
-	sram_data_for_sleep(boot_ram_data, int_ram_data, 1);
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
-}
-
-#define  RK_GICD_BASE (RK_GIC_VIRT)
-#define RK_GICC_BASE (RK_GIC_VIRT+RK312X_GIC_DIST_SIZE)
-#define PM_IRQN_START 32
-#define PM_IRQN_END	107
-#define gic_reg_dump(a, b, c)  {}
-static u32 slp_gic_save[260+50];
-
-static void rkpm_gic_dist_save(u32 *context)
-{
-	int i = 0, j, irqstart = 0;
-	unsigned int gic_irqs;
-
-	gic_irqs = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTR) & 0x1f;
-	gic_irqs = (gic_irqs + 1) * 32;
-	if (gic_irqs > 1020)
-		gic_irqs = 1020;
-
-	irqstart = PM_IRQN_START;
-
-	i = 0;
-
-	for (j = irqstart; j < gic_irqs; j += 16)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_CONFIG + (j * 4) / 16);
-	gic_reg_dump("gic level", j, RK_GICD_BASE + GIC_DIST_CONFIG);
-
-	/*
-	* Set all global interrupts to this CPU only.
-	*/
-	for (j = 0; j < gic_irqs; j += 4)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_TARGET +	(j * 4) / 4);
-	gic_reg_dump("gic trig", j, RK_GICD_BASE + GIC_DIST_TARGET);
-
-	for (j = 0; j < gic_irqs; j += 4)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_PRI + (j * 4) / 4);
-	gic_reg_dump("gic pri", j, RK_GICD_BASE + GIC_DIST_PRI);
-
-	for (j = 0; j < gic_irqs; j += 32)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_IGROUP + (j * 4) / 32);
-	gic_reg_dump("gic secure", j, RK_GICD_BASE + 0x80);
-
-	for (j = irqstart; j < gic_irqs; j += 32)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_PENDING_SET + (j * 4) / 32);
-	gic_reg_dump("gic PENDING",  j,  RK_GICD_BASE
-		+ GIC_DIST_PENDING_SET);
-
-	for (j = 0; j < gic_irqs; j += 32)
-		context[i++] = readl_relaxed(RK_GICD_BASE
-		+ GIC_DIST_ENABLE_SET + (j * 4) / 32);
-	gic_reg_dump("gic en", j, RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-	gic_reg_dump("gicc", 0x1c, RK_GICC_BASE);
-	gic_reg_dump("giccfc", 0,  RK_GICC_BASE + 0xfc);
-
-	context[i++] = readl_relaxed(RK_GICC_BASE + GIC_CPU_PRIMASK);
-	context[i++] = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTRL);
-	context[i++] = readl_relaxed(RK_GICC_BASE + GIC_CPU_CTRL);
-	/*
-	context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_BINPOINT);
-	context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_PRIMASK);
-	context[i++]=readl_relaxed(RK_GICC_BASE + GIC_DIST_SOFTINT);
-	context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_CTRL);
-	context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_CTRL);
-	*/
-	for (j = irqstart; j < gic_irqs; j += 32) {
-		writel_relaxed(0xffffffff, RK_GICD_BASE
-			+ GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-		dsb();
-	}
-	writel_relaxed(0xffff0000, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR);
-	writel_relaxed(0x0000ffff, RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-
-	writel_relaxed(0, RK_GICC_BASE + GIC_CPU_CTRL);
-	writel_relaxed(0, RK_GICD_BASE + GIC_DIST_CTRL);
-}
-static void  rkpm_peri_save(u32 power_mode)
-{
-	rkpm_gic_dist_save(&slp_gic_save[0]);
-}
-
-static void rkpm_save_setting(u32 ctrbits)
-{
-	u32 pd_cpu;
-
-	if ((RKPM_CTR_ARMOFF_LPMD & ctrbits) == 0)
-		return;
-
-	rkpm_slp_mode_set(ctrbits);
-	if (rk312x_powermode & BIT(pmu_power_mode_en)) {
-		sram_code_data_save(rk312x_powermode);
-		rkpm_peri_save(rk312x_powermode);
-	}
-	grf_soc_con0 = grf_readl(GRF_SOC_CON0);
-
-	grf_writel((1 << SOC_REMAP) | (1 << (SOC_REMAP + 16)), GRF_SOC_CON0);
-
-	for (pd_cpu = PD_CPU_1; pd_cpu <= PD_CPU_3; pd_cpu++) {
-		writel_relaxed(0x20000 << (pd_cpu - PD_CPU_1),
-			       RK_CRU_VIRT + RK312X_CRU_SOFTRSTS_CON(0));
-		dsb();
-		udelay(10);
-	}
-}
-
-#define UART_DLL	0	/* Out: Divisor Latch Low */
-#define UART_DLM	1	/* Out: Divisor Latch High */
-#define UART_IER	1
-#define UART_FCR	2
-#define UART_LCR	3	/* Out: Line Control Register */
-#define UART_MCR	4
-
-static void slp312x_uartdbg_resume(void)
-{
-	void __iomem *b_addr = RK_DEBUG_UART_VIRT;
-	u32 pclk_id = RK312X_CLKGATE_PCLK_UART2;
-	u32 clk_id = (RK312X_CLKGATE_UART0_SRC + 2 * 2);
-	u32 gate_reg[2];
-	u32 rfl_reg, lsr_reg;
-
-	gate_reg[0] = cru_readl(RK312X_CRU_GATEID_CONS(pclk_id));
-	gate_reg[1] = cru_readl(RK312X_CRU_GATEID_CONS(clk_id));
-
-	RK312X_CRU_UNGATING_OPS(pclk_id);
-	grf_writel(0x00f00000, 0x00c0);
-
-	do {
-		cru_writel(CRU_W_MSK_SETBITS(0x2, 8, 0x3)
-			, RK312X_CRU_CLKSELS_CON(16));
-		cru_writel(0|CRU_W_MSK_SETBITS(1, 9, 0x1)
-			, RK312X_CRU_SOFTRSTS_CON(2));
-		dsb();
-		dsb();
-		rkpm_udelay(10);
-		cru_writel(0 | CRU_W_MSK_SETBITS(0, 9, 0x1)
-			, RK312X_CRU_SOFTRSTS_CON(2));
-
-		reg_writel(0x83, b_addr + UART_LCR*4);
-
-		reg_writel(0xd, b_addr + UART_DLL*4);
-		reg_writel(0x0, b_addr + UART_DLM*4);
-
-		reg_writel(0x3, b_addr + UART_LCR*4);
-
-		reg_writel(0x5, b_addr + UART_IER*4);
-		reg_writel(0xc1, b_addr + UART_FCR*4);
-
-		rfl_reg = readl_relaxed(b_addr + 0x84);
-		lsr_reg = readl_relaxed(b_addr + 0x14);
-	} while ((rfl_reg & 0x1f) || (lsr_reg & 0xf));
-
-	cru_writel(CRU_W_MSK_SETBITS(0x2, 8, 0x3), RK312X_CRU_CLKSELS_CON(16));
-
-	grf_writel(0x00f000a0, 0x00c0);
-
-	cru_writel(gate_reg[0] | CRU_W_MSK(pclk_id % 16, 0x1)
-		, RK312X_CRU_GATEID_CONS(pclk_id));
-	cru_writel(gate_reg[1] | CRU_W_MSK(clk_id % 16, 0x1)
-		, RK312X_CRU_GATEID_CONS(clk_id));
-}
-
-static void rkpm_gic_dist_resume(u32 *context)
-{
-	int i = 0, j, irqstart = 0;
-	unsigned int gic_irqs;
-
-	gic_irqs = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTR) & 0x1f;
-	gic_irqs = (gic_irqs + 1) * 32;
-	if (gic_irqs > 1020)
-		gic_irqs = 1020;
-
-	irqstart = PM_IRQN_START;
-
-	writel_relaxed(0, RK_GICC_BASE + GIC_CPU_CTRL);
-	dsb();
-	writel_relaxed(0, RK_GICD_BASE + GIC_DIST_CTRL);
-	dsb();
-	for (j = irqstart; j < gic_irqs; j += 32) {
-		writel_relaxed(0xffffffff, RK_GICD_BASE
-			+ GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-		dsb();
-	}
-
-	i = 0;
-
-	for (j = irqstart; j < gic_irqs; j += 16) {
-		writel_relaxed(context[i++], RK_GICD_BASE
-			+ GIC_DIST_CONFIG + j * 4 / 16);
-		dsb();
-	}
-	gic_reg_dump("gic level",  j,  RK_GICD_BASE + GIC_DIST_CONFIG);
-
-	/*
-	* Set all global interrupts to this CPU only.
-	*/
-	for (j = 0; j < gic_irqs; j += 4) {
-		writel_relaxed(context[i++], RK_GICD_BASE
-			+ GIC_DIST_TARGET +  (j * 4) / 4);
-		dsb();
-	}
-	gic_reg_dump("gic target", j, RK_GICD_BASE + GIC_DIST_TARGET);
-
-	for (j = 0; j < gic_irqs; j += 4) {
-		writel_relaxed(context[i++], RK_GICD_BASE
-			+ GIC_DIST_PRI + (j * 4) / 4);
-		dsb();
-	}
-	gic_reg_dump("gic pri",  j,  RK_GICD_BASE + GIC_DIST_PRI);
-
-	for (j = 0; j < gic_irqs; j += 32) {
-		writel_relaxed(context[i++], RK_GICD_BASE
-			+ GIC_DIST_IGROUP + (j * 4) / 32);
-		dsb();
-	}
-	gic_reg_dump("gic secu",  j, RK_GICD_BASE + 0x80);
-
-	for (j = irqstart; j < gic_irqs; j += 32) {
-		/*writel_relaxed(context[i++],
-		RK_GICD_BASE + GIC_DIST_PENDING_SET + j * 4 / 32);*/
-		i++;
-		dsb();
-	}
-
-	gic_reg_dump("gic pending",  j,  RK_GICD_BASE + GIC_DIST_PENDING_SET);
-
-	if (0) {
-		for (j = 0; j < gic_irqs; j += 32) {
-			writel_relaxed(context[i++], RK_GICD_BASE
-				+ GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-			dsb();
-		}
-		gic_reg_dump("gic disable", j, RK_GICD_BASE
-			+ GIC_DIST_ENABLE_CLEAR);
-	} else {
-		for (j = irqstart; j < gic_irqs; j += 32)
-			writel_relaxed(0xffffffff, RK_GICD_BASE
-			+ GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-		writel_relaxed(0xffff0000,  RK_GICD_BASE
-			+ GIC_DIST_ENABLE_CLEAR);
-		writel_relaxed(0x0000ffff,  RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-	}
-
-	/*enable*/
-	for (j = 0; j < gic_irqs; j += 32) {
-		writel_relaxed(context[i++], RK_GICD_BASE
-			+ GIC_DIST_ENABLE_SET + (j * 4) / 32);
-		dsb();
-	}
-
-	gic_reg_dump("gic enable", j, RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-
-	writel_relaxed(context[i++], RK_GICC_BASE + GIC_CPU_PRIMASK);
-	writel_relaxed(context[i++], RK_GICD_BASE + GIC_DIST_CTRL);
-	writel_relaxed(context[i++], RK_GICC_BASE + GIC_CPU_CTRL);
-
-	gic_reg_dump("gicc", 0x1c, RK_GICC_BASE);
-	gic_reg_dump("giccfc", 0, RK_GICC_BASE + 0xfc);
-}
-
-static void sram_data_resume(char *boot_save, char *int_save, u32 flag)
-{
-	char *addr_base, *addr_phy;
-	u32 sr_size;
-
-	addr_base = (char *)RKPM_BOOTRAM_BASE;
-	addr_phy = (char *)RKPM_BOOTRAM_PHYS;
-	sr_size = RKPM_BOOTRAM_SIZE;
-	/* save boot sram*/
-	if (boot_save)
-		memcpy(addr_base, boot_save,  sr_size);
-
-	flush_icache_range((unsigned long)addr_base
-		, (unsigned long)addr_base + sr_size);
-	outer_clean_range((phys_addr_t) addr_phy
-		, (phys_addr_t)addr_phy+sr_size);
-}
-
-static inline void sram_code_data_resume(u32 pwrmode)
-{
-	sram_data_resume(boot_ram_data
-		, int_ram_data, sleep_resume_data[RKPM_BOOTDATA_DDR_F]);
-}
-
-static inline void  rkpm_slp_mode_set_resume(void)
-{
-	u32 pd_cpu;
-
-	pmu_writel(pmu_wakeup_conf, RK312X_PMU_WAKEUP_CFG);
-	/* arm interrupt wake-up enable*/
-	pmu_writel(pmu_pwrmode_con, RK312X_PMU_PWRMODE_CON);
-
-	for (pd_cpu = PD_CPU_1; pd_cpu <= PD_CPU_3; pd_cpu++) {
-		writel_relaxed(0x20002 << (pd_cpu - PD_CPU_1),
-			       RK_CRU_VIRT + RK312X_CRU_SOFTRSTS_CON(0));
-		dsb();
-		udelay(10);
-	}
-
-	grf_writel(grf_soc_con0 | (1 << (SOC_REMAP + 16)), GRF_SOC_CON0);
-
-	if ((pmic_sleep_gpio == 0) || (pmic_sleep_gpio == 0x1a10))
-		grf_writel(0X000C0000 | gpio_pmic_sleep_mode, 0xb8);
-	/*rk3126 GPIO1A1 : RK3128 GPIO3C1 iomux pmic-sleep*/
-	if (pmic_sleep_gpio == 0x3c10)
-		grf_writel(0X000C0000 | gpio_pmic_sleep_mode, 0xe0);
-}
-
-void fiq_glue_resume(void);
-
-static inline void  rkpm_peri_resume(u32 power_mode)
-{
-	rkpm_gic_dist_resume(&slp_gic_save[0]);
-#ifndef CONFIG_ARM_TRUSTZONE
-	fiq_glue_resume();
-#endif
-}
-
-static void rkpm_save_setting_resume(void)
-{
-	if (rk312x_powermode == 0)
-		return;
-
-	rkpm_slp_mode_set_resume();
-	if (rk312x_powermode & BIT(pmu_power_mode_en)) {
-		rkpm_peri_resume(rk312x_powermode);
-		sram_code_data_resume(rk312x_powermode);
-	}
-}
-static inline void  rkpm_peri_resume_first(u32 power_mode)
-{
-	slp312x_uartdbg_resume();
-}
-extern void rk_sram_suspend(void);
-static void rkpm_slp_setting(void)
-{
-	rk_usb_power_down();
-	rk_sram_suspend();
-}
-static void rkpm_save_setting_resume_first(void)
-{
-	rk_usb_power_up();
-	rkpm_peri_resume_first(pmu_pwrmode_con);
-}
-static u32 clk_ungt_msk[RK312X_CRU_CLKGATES_CON_CNT];
-/*first clk gating setting*/
-
-static u32 clk_ungt_msk_1[RK312X_CRU_CLKGATES_CON_CNT];
-/* first clk gating setting*/
-
-static u32 clk_ungt_save[RK312X_CRU_CLKGATES_CON_CNT];
-/*first clk gating value saveing*/
-
-static u32 *p_rkpm_clkgt_last_set;
-#define CLK_MSK_GATING(msk, con) cru_writel((msk << 16) | 0xffff, con)
-#define CLK_MSK_UNGATING(msk, con) cru_writel(((~msk) << 16) | 0xffff, con)
-
-static void gtclks_suspend(void)
-{
-	int i;
-
-	for (i = 0; i < RK312X_CRU_CLKGATES_CON_CNT; i++) {
-		clk_ungt_save[i] = cru_readl(RK312X_CRU_CLKGATES_CON(i));
-		CLK_MSK_UNGATING(clk_ungt_msk[i], RK312X_CRU_CLKGATES_CON(i));
-	}
-}
-
-static void gtclks_resume(void)
-{
-	int i;
-
-	for (i = 0; i < RK312X_CRU_CLKGATES_CON_CNT; i++)
-		cru_writel(clk_ungt_save[i] | 0xffff0000
-		, RK312X_CRU_CLKGATES_CON(i));
-}
-static void clks_gating_suspend_init(void)
-{
-	p_rkpm_clkgt_last_set = &clk_ungt_msk_1[0];
-	if (clk_suspend_clkgt_info_get(clk_ungt_msk, p_rkpm_clkgt_last_set
-		, RK312X_CRU_CLKGATES_CON_CNT) == RK312X_CRU_CLKGATES_CON(0))
-		rkpm_set_ops_gtclks(gtclks_suspend, gtclks_resume);
-}
-static void pmic_sleep_gpio_get_dts_info(struct device_node *parent)
-{
-	struct property *prop;
-
-	prop = of_find_property(parent, "rockchip,pmic-suspend_gpios", NULL);
-	if (!prop)
-		return;
-	if (!prop->value)
-		return;
-
-	of_property_read_u32_array(parent, "rockchip,pmic-suspend_gpios"
-		, &pmic_sleep_gpio, 1);
-}
-
-#define SRAM_LOOPS_PER_USEC     24
-#define SRAM_LOOP(loops)       \
-	do {\
-		unsigned int i = (loops);\
-		if (i < 7)\
-			i = 7;\
-	barrier();\
-	asm volatile(".align 4; 1: subs %0, %0, #1; bne 1b;" : "+r" (i));\
-	} while (0)
-/* delay on slow mode */
-#define sram_udelay(usecs)      SRAM_LOOP((usecs)*SRAM_LOOPS_PER_USEC)
-/* delay on deep slow mode */
-#define sram_32k_udelay(usecs)  SRAM_LOOP(((usecs)*\
-	SRAM_LOOPS_PER_USEC)/(24000000/32768))
-
-void PIE_FUNC(ddr_suspend)(void);
-void PIE_FUNC(ddr_resume)(void);
-
-#define PWM_VOLTAGE 0x600
-
-void PIE_FUNC(pwm_regulator_suspend)(void)
-{
-	int gpio0_inout;
-	int gpio0_ddr;
-
-	cru_writel(0x1e000000, 0xf0);
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM0)) {
-		grf_writel(0x00100000, 0xb4);/*iomux  gpio0d2*/
-		gpio0_inout = readl_relaxed(RK_GPIO_VIRT(0) + 0x04);
-		gpio0_ddr = readl_relaxed(RK_GPIO_VIRT(0));
-		writel_relaxed(gpio0_inout | 0x04000000
-			, RK_GPIO_VIRT(0) + 0x04);
-		dsb();
-		writel_relaxed(gpio0_ddr | 0x04000000, RK_GPIO_VIRT(0));
-	}
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM1)) {
-		grf_writel(0x00400000, 0xb4);/*iomux  gpio0d3*/
-		gpio0_inout = readl_relaxed(RK_GPIO_VIRT(0) + 0x04);
-		gpio0_ddr = readl_relaxed(RK_GPIO_VIRT(0));
-		writel_relaxed(gpio0_inout | 0x08000000
-			, RK_GPIO_VIRT(0) + 0x04);
-		dsb();
-		writel_relaxed(gpio0_ddr | 0x08000000, RK_GPIO_VIRT(0));
-	}
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM2)) {
-		grf_writel(0x01000000, 0xb4);/*iomux  gpio0d4*/
-		gpio0_inout = readl_relaxed(RK_GPIO_VIRT(0) + 0x04);
-		gpio0_ddr = readl_relaxed(RK_GPIO_VIRT(0));
-		writel_relaxed(gpio0_inout | 0x10000000
-			, RK_GPIO_VIRT(0) + 0x04);
-		dsb();
-		writel_relaxed(gpio0_ddr | 0x10000000, RK_GPIO_VIRT(0));
-	}
-
-}
-
-void PIE_FUNC(pwm_regulator_resume)(void)
-{
-
-}
-
-
-static void reg_pread(void)
-{
-	int i;
-	volatile u32 n;
-
-	volatile u32 *temp = (volatile unsigned int *)rockchip_sram_virt;
-
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
-
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-
-	n = readl_relaxed(RK_GPIO_VIRT(0));
-	n = readl_relaxed(RK_GPIO_VIRT(1));
-	n = readl_relaxed(RK_GPIO_VIRT(1) + 4);
-
-	n = readl_relaxed(RK_GPIO_VIRT(2));
-	n = readl_relaxed(RK_GPIO_VIRT(3));
-
-	n = readl_relaxed(RK_DEBUG_UART_VIRT);
-	n = readl_relaxed(RK_CPU_AXI_BUS_VIRT);
-	n = readl_relaxed(RK_DDR_VIRT);
-	n = readl_relaxed(RK_GRF_VIRT);
-	n = readl_relaxed(RK_CRU_VIRT);
-	n = readl_relaxed(RK_PMU_VIRT);
-	n = readl_relaxed(RK_PWM_VIRT);
-}
-void PIE_FUNC(msch_bus_idle_request)(void)
-{
-	u32 val;
-
-	rkpm_sram_printch('6');
-	val = pmu_readl(RK312X_PMU_IDLE_REQ);
-	val |= 0x40;
-	pmu_writel(val, RK312X_PMU_IDLE_REQ);
-	dsb();
-	while (((pmu_readl(RK312X_PMU_IDLE_ST) & 0x00400040) != 0x00400040))
-		;
-}
-static void __init rk312x_suspend_init(void)
-{
-	struct device_node *parent;
-	u32 pm_ctrbits;
-
-	pr_info("%s\n", __func__);
-	parent = of_find_node_by_name(NULL, "rockchip_suspend");
-
-	if (IS_ERR_OR_NULL(parent)) {
-		PM_ERR("%s dev node err\n",  __func__);
-		return;
-	}
-
-	if (of_property_read_u32_array(parent
-		, "rockchip,ctrbits", &pm_ctrbits, 1)) {
-		PM_ERR("%s:get pm ctr error\n", __func__);
-	return;
-	}
-	pmic_sleep_gpio_get_dts_info(parent);
-	rkpm_set_ctrbits(pm_ctrbits);
-	clks_gating_suspend_init();
-	rkpm_set_ops_prepare_finish(rkpm_prepare, rkpm_finish);
-	rkpm_set_ops_plls(pm_plls_suspend, pm_plls_resume);
-	rkpm_set_ops_save_setting(rkpm_save_setting
-		, rkpm_save_setting_resume);
-	rkpm_set_ops_regs_sleep(rkpm_slp_setting
-		, rkpm_save_setting_resume_first);
-	rkpm_set_ops_regs_pread(reg_pread);
-	rkpm_set_sram_ops_ddr(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(ddr_suspend))
-		, fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_resume)));
-	rkpm_set_sram_ops_bus(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(msch_bus_idle_request)));
-	rkpm_set_sram_ops_volt(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(pwm_regulator_suspend))
-		, fn_to_pie(rockchip_pie_chunk, &FUNC(pwm_regulator_resume)));
-	rkpm_set_sram_ops_printch(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(sram_printch)));
-	rkpm_set_ops_printch(ddr_printch);
-}
diff --git a/arch/arm/mach-rockchip/pm-rk3188.c b/arch/arm/mach-rockchip/pm-rk3188.c
deleted file mode 100755
index c59b509086ff..000000000000
--- a/arch/arm/mach-rockchip/pm-rk3188.c
+++ /dev/null
@@ -1,607 +0,0 @@
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/hardware/cache-l2x0.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-
-#include <linux/pm.h>
-#include <linux/suspend.h>
-#include <linux/of.h>
-#include <asm/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include "pm.h"
-
-#define CPU 3188
-//#include "sram.h"
-#include "pm-pie.c"
-
-#define RK3188_CLK_GATING_OPS(ID) cru_writel((0x1<<((ID%16)+16))|(0x1<<(ID%16)),RK3188_CRU_GATEID_CONS(ID))
-#define RK3188_CLK_UNGATING_OPS(ID) cru_writel(0x1<<((ID%16)+16),RK3188_CRU_GATEID_CONS(ID))
-
-/*************************cru define********************************************/
-/*******************CRU BITS*******************************/
-#define CRU_W_MSK(bits_shift, msk)	((msk) << ((bits_shift) + 16))
-#define CRU_SET_BITS(val, bits_shift, msk)	(((val)&(msk)) << (bits_shift))
-#define CRU_W_MSK_SETBITS(val, bits_shift,msk) \
-	(CRU_W_MSK(bits_shift, msk) | CRU_SET_BITS(val, bits_shift, msk))
-	
-#define RK3188_CRU_GET_REG_BITS_VAL(reg,bits_shift, msk)  (((reg) >> (bits_shift))&(msk))
-#define RK3188_CRU_W_MSK(bits_shift, msk)	((msk) << ((bits_shift) + 16))
-#define RK3188_CRU_SET_BITS(val,bits_shift, msk)	(((val)&(msk)) << (bits_shift))
-    
-#define RK3188_CRU_W_MSK_SETBITS(val,bits_shift,msk) \
-        (RK3188_CRU_W_MSK(bits_shift, msk)|RK3188_CRU_SET_BITS(val,bits_shift, msk))
-    
-    
-/*******************RK3188_PLL CON3 BITS***************************/
-
-#define RK3188_PLL_PWR_DN_MSK		(1 << 1)
-#define RK3188_PLL_PWR_DN_W_MSK	(RK3188_PLL_PWR_DN_MSK << 16)
-#define RK3188_PLL_PWR_DN		(1 << 1)
-#define RK3188_PLL_PWR_ON		(0 << 1)
-    
-
-
-/*******************CLKSEL0 BITS***************************/
-//RK3188_CORE_preiph div
-#define RK3188_CORE_PERIPH_W_MSK	(3 << 22)
-#define RK3188_CORE_PERIPH_MSK		(3 << 6)
-#define RK3188_CORE_PERIPH_2		(0 << 6)
-#define RK3188_CORE_PERIPH_4		(1 << 6)
-#define RK3188_CORE_PERIPH_8		(2 << 6)
-#define RK3188_CORE_PERIPH_16		(3 << 6)
-
-//clk_RK3188_CORE
-#define RK3188_CORE_SEL_PLL_MSK	(1 << 8)
-#define RK3188_CORE_SEL_PLL_W_MSK	(1 << 24)
-#define RK3188_CORE_SEL_APLL		(0 << 8)
-#define RK3188_CORE_SEL_GPLL		(1 << 8)
-
-#define RK3188_CORE_CLK_DIV_W_MSK	(0x1F << 25)
-#define RK3188_CORE_CLK_DIV_MSK	(0x1F << 9)
-#define RK3188_CORE_CLK_DIV(i)		((((i) - 1) & 0x1F) << 9)
-#define RK3188_CORE_CLK_MAX_DIV	32
-
-#define RK3188_CPU_SEL_PLL_MSK		(1 << 5)
-#define RK3188_CPU_SEL_PLL_W_MSK	(1 << 21)
-#define RK3188_CPU_SEL_APLL		(0 << 5)
-#define RK3188_CPU_SEL_GPLL		(1 << 5)
-
-#define RK3188_CPU_CLK_DIV_W_MSK	(0x1F << 16)
-#define RK3188_CPU_CLK_DIV_MSK		(0x1F)
-#define RK3188_CPU_CLK_DIV(i)		(((i) - 1) & 0x1F)
-
-/*******************CLKSEL1 BITS***************************/
-//aclk div
-#define RK3188_GET_CORE_ACLK_VAL(reg) ((reg)>=4 ?8:((reg)+1))
-
-#define RK3188_CORE_ACLK_W_MSK		(7 << 19)
-#define RK3188_CORE_ACLK_MSK		(7 << 3)
-#define RK3188_CORE_ACLK_11		(0 << 3)
-#define RK3188_CORE_ACLK_21		(1 << 3)
-#define RK3188_CORE_ACLK_31		(2 << 3)
-#define RK3188_CORE_ACLK_41		(3 << 3)
-#define RK3188_CORE_ACLK_81		(4 << 3)
-//hclk div
-#define RK3188_ACLK_HCLK_W_MSK		(3 << 24)
-#define RK3188_ACLK_HCLK_MSK		(3 << 8)
-#define RK3188_ACLK_HCLK_11		(0 << 8)
-#define RK3188_ACLK_HCLK_21		(1 << 8)
-#define RK3188_ACLK_HCLK_41		(2 << 8)
-// pclk div
-#define RK3188_ACLK_PCLK_W_MSK		(3 << 28)
-#define RK3188_ACLK_PCLK_MSK		(3 << 12)
-#define RK3188_ACLK_PCLK_11		(0 << 12)
-#define RK3188_ACLK_PCLK_21		(1 << 12)
-#define RK3188_ACLK_PCLK_41		(2 << 12)
-#define RK3188_ACLK_PCLK_81		(3 << 12)
-// ahb2apb div
-#define RK3188_AHB2APB_W_MSK		(3 << 30)
-#define RK3188_AHB2APB_MSK		(3 << 14)
-#define RK3188_AHB2APB_11		(0 << 14)
-#define RK3188_AHB2APB_21		(1 << 14)
-#define RK3188_AHB2APB_41		(2 << 14)
-
-/*******************clksel10***************************/
-
-#define RK3188_PERI_ACLK_DIV_MASK 0x1f
-#define RK3188_PERI_ACLK_DIV_W_MSK	(RK3188_PERI_ACLK_DIV_MASK << 16)
-#define RK3188_PERI_ACLK_DIV(i)	(((i) - 1) & RK3188_PERI_ACLK_DIV_MASK)
-#define RK3188_PERI_ACLK_DIV_OFF 0
-
-#define RK3188_PERI_HCLK_DIV_MASK 0x3
-#define RK3188_PERI_HCLK_DIV_OFF 8
-
-#define RK3188_PERI_PCLK_DIV_MASK 0x3
-#define RK3188_PERI_PCLK_DIV_OFF 12
-
-
-
-/*************************gate id**************************************/
-#define RK3188_CLK_GATEID(i)	(16 * (i))
-
-
-enum cru_clk_gate {
-	/* SCU CLK GATE 0 CON */
-	RK3188_CLKGATE_CORE_PERIPH = RK3188_CLK_GATEID(0),
-
-	RK3188_CLKGATE_TIMER0 = RK3188_CLK_GATEID(1),
-	RK3188_CLKGATE_UART0_SRC=RK3188_CLK_GATEID(1)+8,
-	RK3188_CLKGATE_UART0_FRAC_SRC,
-
-	RK3188_CLKGATE_PCLK_UART0 = RK3188_CLK_GATEID(8),
-	
-
-	RK3188_CLKGATE_CLK_CORE_DBG = RK3188_CLK_GATEID(9),
-
-	RK3188_CLKGATE_MAX= RK3188_CLK_GATEID(10),
-};
-/*******************************gpio define **********************************************/
-#define GPIO_INTEN			0x30
-#define GPIO_INTMASK		0x34
-#define GPIO_INTTYPE_LEVEL	0x38
-#define GPIO_INT_POLARITY	0x3c
-#define GPIO_INT_STATUS		0x40
-
-/*******************************common code  for rkxxx*********************************/
-
-static void  inline uart_printch(char byte)
-{
-        u32 reg_save[2];
-        u32 u_clk_id=(RK3188_CLKGATE_UART0_SRC+CONFIG_RK_DEBUG_UART);
-        u32 u_pclk_id=(RK3188_CLKGATE_PCLK_UART0+CONFIG_RK_DEBUG_UART);
-        
-        reg_save[0]=cru_readl(RK3188_CRU_GATEID_CONS(u_clk_id));
-        reg_save[1]=cru_readl(RK3188_CRU_GATEID_CONS(u_pclk_id));
-        RK3188_CLK_UNGATING_OPS(u_clk_id);
-        RK3188_CLK_UNGATING_OPS(u_pclk_id);
-        
-        rkpm_udelay(1);
-        
-write_uart:
-	writel_relaxed(byte, RK_DEBUG_UART_VIRT);
-	dsb();
-
-	/* loop check LSR[6], Transmitter Empty bit */
-	while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-		barrier();
-    
-	if (byte == '\n') {
-		byte = '\r';
-		goto write_uart;
-	}
-
-         cru_writel(reg_save[0]|0x1<<((u_pclk_id%16)+16),RK3188_CRU_GATEID_CONS(u_clk_id));         
-         cru_writel(reg_save[1]|0x1<<((u_pclk_id%16)+16),RK3188_CRU_GATEID_CONS(u_pclk_id));
-}
-
-void PIE_FUNC(sram_printch)(char byte)
-{
-	uart_printch(byte);
-}
-
-static void  ddr_printch(char byte)
-{
-	uart_printch(byte);
-}
-/*******************************clk gating config*******************************************/
-#define CLK_MSK_GATING(msk, con) cru_writel((msk << 16) | 0xffff, con)
-#define CLK_MSK_UNGATING(msk, con) cru_writel(((~msk) << 16) | 0xffff, con)
-
-
-static u32 clk_ungt_msk[RK3188_CRU_CLKGATES_CON_CNT];// first clk gating setting
-static u32 clk_ungt_save[RK3188_CRU_CLKGATES_CON_CNT]; //first clk gating value saveing
-
-
-u32 DEFINE_PIE_DATA(rkpm_clkgt_last_set[RK3188_CRU_CLKGATES_CON_CNT]);
-static u32 *p_rkpm_clkgt_last_set;
-
-u32 DEFINE_PIE_DATA(rkpm_clkgt_last_save[RK3188_CRU_CLKGATES_CON_CNT]);
-static u32 *p_rkpm_clkgt_last_save;
-
-void PIE_FUNC(gtclks_sram_suspend)(void)
-{
-    int i;
-   // u32 u_clk_id=(RK3188_CLKGATE_UART0_SRC+CONFIG_RK_DEBUG_UART);
-   // u32 u_pclk_id=(RK3188_CLKGATE_PCLK_UART0+CONFIG_RK_DEBUG_UART);
-
-    for(i=0;i<RK3188_CRU_CLKGATES_CON_CNT;i++)
-    {
-        DATA(rkpm_clkgt_last_save[i])=cru_readl(RK3188_CRU_CLKGATES_CON(i));     
-        CLK_MSK_UNGATING( DATA(rkpm_clkgt_last_set[i]), RK3188_CRU_CLKGATES_CON(i));      
-        #if 0
-        rkpm_sram_printch('\n');   
-        rkpm_sram_printhex(DATA(rkpm_clkgt_last_save[i]));
-        rkpm_sram_printch('-');   
-        rkpm_sram_printhex(DATA(rkpm_clkgt_last_set[i]));
-        rkpm_sram_printch('-');   
-        rkpm_sram_printhex(cru_readl(RK3188_CRU_CLKGATES_CON(i)));
-        if(i==(RK3188_CRU_CLKGATES_CON_CNT-1))         
-        rkpm_sram_printch('\n');   
-        #endif
-    }
-    
-        //RK3188_CLK_UNGATING_OPS(u_clk_id);
-        //RK3188_CLK_UNGATING_OPS(u_pclk_id);
- 
-}
-
-void PIE_FUNC(gtclks_sram_resume)(void)
-{
-    int i;
-    for(i=0;i<RK3188_CRU_CLKGATES_CON_CNT;i++)
-    {
-        cru_writel(DATA(rkpm_clkgt_last_save[i])|0xffff0000, RK3188_CRU_CLKGATES_CON(i));
-    }
-}
-
-static void gtclks_suspend(void)
-{
-    int i;
-    
-    for(i=0;i<RK3188_CRU_CLKGATES_CON_CNT;i++)
-    {
-    
-        clk_ungt_save[i]=cru_readl(RK3188_CRU_CLKGATES_CON(i));    
-        //if(i!=4||i!=0)
-        CLK_MSK_UNGATING(clk_ungt_msk[i],RK3188_CRU_CLKGATES_CON(i));
-       #if 0
-        rkpm_ddr_printch('\n');   
-        rkpm_ddr_printhex(clk_ungt_save[i]);
-        rkpm_ddr_printch('-');   
-        rkpm_ddr_printhex(clk_ungt_msk[i]);
-        rkpm_ddr_printch('-');   
-        rkpm_ddr_printhex(cru_readl(RK3188_CRU_CLKGATES_CON(i))) ;  
-        if(i==(RK3188_CRU_CLKGATES_CON_CNT-1))            
-            rkpm_ddr_printch('\n');   
-        #endif
-    }
-
-}
-
-static void gtclks_resume(void)
-{
-    int i;
-     for(i=0;i<RK3188_CRU_CLKGATES_CON_CNT;i++)
-    {
-       cru_writel(clk_ungt_save[i]|0xffff0000,RK3188_CRU_CLKGATES_CON(i));
-    }
-    
-}
-
-/********************************pll power down***************************************/
-
-#define power_off_pll(id) \
-	cru_writel(RK3188_PLL_PWR_DN_W_MSK | RK3188_PLL_PWR_DN, RK3188_PLL_CONS((id), 3))
-#if 0
-
-static void pm_pll_wait_lock(u32 pll_idx)
-{
-	u32 pll_state[4] = { 1, 0, 2, 3 };
-	u32 bit = 0x20u << pll_state[pll_idx];
-	u32 delay = pll_idx == RK3188_APLL_ID ? 600000U : 30000000U;
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	while (delay > 0) {
-		if (grf_readl(RK3188_GRF_SOC_STATUS0) & bit)
-			break;
-		delay--;
-	}
-	if (delay == 0) {
-		//CRU_PRINTK_ERR("wait pll bit 0x%x time out!\n", bit); 
-		rkpm_ddr_printch('p');
-		rkpm_ddr_printch('l');
-		rkpm_ddr_printch('l');
-		rkpm_ddr_printhex(pll_idx);
-		rkpm_ddr_printch('\n');
-	}
-}	
-static void power_on_pll(u32 pll_id)
-{
-        cru_writel(RK3188_PLL_PWR_DN_W_MSK | RK3188_PLL_PWR_ON, RK3188_PLL_CONS((pll_id), 3));
-        pm_pll_wait_lock((pll_id));
-}
-#endif
-static u32 clk_sel0, clk_sel1, clk_sel10;
-static u32 cpll_con3;
-static u32 cru_mode_con;
-
-static void plls_suspend(void)
-{
-    cru_mode_con = cru_readl(RK3188_CRU_MODE_CON);
-    cru_writel(RK3188_PLL_MODE_SLOW(RK3188_CPLL_ID), RK3188_CRU_MODE_CON);
-
-    cpll_con3 = cru_readl(RK3188_PLL_CONS(RK3188_CPLL_ID, 3));
-   //power_off_pll(RK3188_CPLL_ID);
-       
-
-       //apll
-       clk_sel0 = cru_readl(RK3188_CRU_CLKSELS_CON(0));
-       clk_sel1 = cru_readl(RK3188_CRU_CLKSELS_CON(1));
-
-       cru_writel(RK3188_PLL_MODE_SLOW(RK3188_APLL_ID), RK3188_CRU_MODE_CON);
-       
-       /* To make sure aclk_cpu select apll before div effect */
-       cru_writel(RK3188_CPU_SEL_PLL_W_MSK | RK3188_CPU_SEL_APLL
-                          | RK3188_CORE_SEL_PLL_W_MSK | RK3188_CORE_SEL_APLL
-                          , RK3188_CRU_CLKSELS_CON(0));
-       cru_writel(RK3188_CORE_PERIPH_W_MSK | RK3188_CORE_PERIPH_2
-              | RK3188_CORE_CLK_DIV_W_MSK | RK3188_CORE_CLK_DIV(1)
-              | RK3188_CPU_CLK_DIV_W_MSK | RK3188_CPU_CLK_DIV(1)
-              , RK3188_CRU_CLKSELS_CON(0));
-       cru_writel(RK3188_CORE_ACLK_W_MSK | RK3188_CORE_ACLK_11
-              | RK3188_ACLK_HCLK_W_MSK | RK3188_ACLK_HCLK_11
-              | RK3188_ACLK_PCLK_W_MSK | RK3188_ACLK_PCLK_11
-              | RK3188_AHB2APB_W_MSK | RK3188_AHB2APB_11
-              , RK3188_CRU_CLKSELS_CON(1));
-       //power_off_pll(RK3188_APLL_ID);
-    cru_writel(RK3188_PLL_MODE_SLOW(RK3188_GPLL_ID), RK3188_CRU_MODE_CON);
-
-       
-    clk_sel10 = cru_readl(RK3188_CRU_CLKSELS_CON(10));
-    cru_writel(RK3188_CRU_W_MSK_SETBITS(0, RK3188_PERI_ACLK_DIV_OFF, RK3188_PERI_ACLK_DIV_MASK)
-    | RK3188_CRU_W_MSK_SETBITS(0,RK3188_PERI_HCLK_DIV_OFF, RK3188_PERI_HCLK_DIV_MASK)
-    | RK3188_CRU_W_MSK_SETBITS(0, RK3188_PERI_PCLK_DIV_OFF, RK3188_PERI_PCLK_DIV_MASK)
-    , RK3188_CRU_CLKSELS_CON(10));
-    
-  //power_off_pll(RK3188_GPLL_ID);
-
-}
-
-static void plls_resume(void)
-{
-    //gpll
-       
-        cru_writel(0xffff0000 | clk_sel10, RK3188_CRU_CLKSELS_CON(10));
-    
-      // power_on_pll(RK3188_GPLL_ID);
-        cru_writel((RK3188_PLL_MODE_MSK(RK3188_GPLL_ID) << 16) 
-                        | (RK3188_PLL_MODE_MSK(RK3188_GPLL_ID) & cru_mode_con)
-                        ,  RK3188_CRU_MODE_CON);
-
-        //apll
-        cru_writel(0xffff0000 | clk_sel1, RK3188_CRU_CLKSELS_CON(1));
-        /* To make sure aclk_cpu select gpll after div effect */
-        cru_writel((0xffff0000 & ~RK3188_CPU_SEL_PLL_W_MSK & ~RK3188_CORE_SEL_PLL_W_MSK) 
-                         | clk_sel0
-                         , RK3188_CRU_CLKSELS_CON(0));
-        
-        cru_writel(RK3188_CPU_SEL_PLL_W_MSK 
-                        | RK3188_CORE_SEL_PLL_W_MSK 
-                        | clk_sel0
-                        , RK3188_CRU_CLKSELS_CON(0));
-        
-     //   power_on_pll(RK3188_APLL_ID);
-        cru_writel((RK3188_PLL_MODE_MSK(RK3188_APLL_ID) << 16)
-                        | (RK3188_PLL_MODE_MSK(RK3188_APLL_ID) & cru_mode_con)
-                        , RK3188_CRU_MODE_CON);
-
-    
-        // it was power off ,don't need to power up
-        if (((cpll_con3 & RK3188_PLL_PWR_DN_MSK) == RK3188_PLL_PWR_ON) 
-            &&((RK3188_PLL_MODE_NORM(RK3188_CPLL_ID) & RK3188_PLL_MODE_MSK(RK3188_CPLL_ID)) 
-            == (cru_mode_con & RK3188_PLL_MODE_MSK(RK3188_CPLL_ID)))) {
-       //     power_on_pll(RK3188_CPLL_ID);
-        }
-        cru_writel((RK3188_PLL_MODE_MSK(RK3188_CPLL_ID) << 16) 
-                        | (RK3188_PLL_MODE_MSK(RK3188_CPLL_ID) & cru_mode_con)
-                        , RK3188_CRU_MODE_CON);
-}
-
-u32  DEFINE_PIE_DATA(sysclk_cru_clksel0_con);
-u32  DEFINE_PIE_DATA(sysclk_cru_clksel10_con);
-u32  DEFINE_PIE_DATA(sysclk_cru_mode_con);
-
-void PIE_FUNC(sysclk_suspend)(u32 sel_clk)
-{
-      DATA(sysclk_cru_clksel0_con) = cru_readl(RK3188_CRU_CLKSELS_CON(0));
-      if(sel_clk&(RKPM_CTR_SYSCLK_32K))
-        {
-            DATA(sysclk_cru_mode_con) = cru_readl(RK3188_CRU_MODE_CON);
-            DATA(sysclk_cru_clksel10_con) = cru_readl(RK3188_CRU_CLKSELS_CON(10));
-            
-            cru_writel(RK3188_PERI_ACLK_DIV_W_MSK | RK3188_PERI_ACLK_DIV(4), RK3188_CRU_CLKSELS_CON(10));
-            cru_writel(RK3188_CORE_CLK_DIV_W_MSK | RK3188_CORE_CLK_DIV(4) 
-                            | RK3188_CPU_CLK_DIV_W_MSK | RK3188_CPU_CLK_DIV(4)
-                            , RK3188_CRU_CLKSELS_CON(0));
-            
-            cru_writel(0
-                            | RK3188_PLL_MODE_DEEP(RK3188_APLL_ID)
-                            //| RK3188_PLL_MODE_DEEP(RK3188_DPLL_ID)
-                            | RK3188_PLL_MODE_DEEP(RK3188_CPLL_ID)
-                            | RK3188_PLL_MODE_DEEP(RK3188_GPLL_ID)
-                            , RK3188_CRU_MODE_CON);
-            rkpm_sram_printch('8');
-        }
-        else if(sel_clk&(RKPM_CTR_SYSCLK_DIV))
-        {
-            //set core_clk_div and cpu_clk_div to the largest
-            cru_writel(RK3188_CORE_CLK_DIV_W_MSK | RK3188_CORE_CLK_DIV_MSK
-            		| RK3188_CPU_CLK_DIV_W_MSK | RK3188_CPU_CLK_DIV_MSK, RK3188_CRU_CLKSELS_CON(0));
-        }
-}
-
-void PIE_FUNC(sysclk_resume)(u32 sel_clk)
-{
-
-    if(sel_clk&(RKPM_CTR_SYSCLK_32K))
-    {
-        cru_writel((0xffff<<16) | DATA(sysclk_cru_mode_con), RK3188_CRU_MODE_CON);
-        cru_writel(RK3188_CORE_CLK_DIV_W_MSK | RK3188_CPU_CLK_DIV_W_MSK
-        		| DATA(sysclk_cru_clksel0_con), RK3188_CRU_CLKSELS_CON(0));
-        cru_writel(RK3188_PERI_ACLK_DIV_W_MSK | DATA(sysclk_cru_clksel10_con),
-        		RK3188_CRU_CLKSELS_CON(10));
-        
-        rkpm_sram_printch('8');
-    }
-    else if(sel_clk&(RKPM_CTR_SYSCLK_DIV))
-    {
-        cru_writel(RK3188_CORE_CLK_DIV_W_MSK | RK3188_CPU_CLK_DIV_W_MSK
-		        | DATA(sysclk_cru_clksel0_con), RK3188_CRU_CLKSELS_CON(0));
-    }
-
-}
-
-static void clks_gating_suspend_init(void)
-{
-    // get clk gating info
-    p_rkpm_clkgt_last_set= kern_to_pie(rockchip_pie_chunk, &DATA(rkpm_clkgt_last_set[0]));
-    p_rkpm_clkgt_last_save= kern_to_pie(rockchip_pie_chunk, &DATA(rkpm_clkgt_last_save[0]));
-    
-    if(clk_suspend_clkgt_info_get(clk_ungt_msk,p_rkpm_clkgt_last_set, RK3188_CRU_CLKGATES_CON_CNT) 
-        ==RK3188_CRU_CLKGATES_CON(0))
-    {
-        rkpm_set_ops_gtclks(gtclks_suspend,gtclks_resume);
-        rkpm_set_sram_ops_gtclks(fn_to_pie(rockchip_pie_chunk, &FUNC(gtclks_sram_suspend)), 
-                        fn_to_pie(rockchip_pie_chunk, &FUNC(gtclks_sram_resume)));
-        
-        PM_LOG("%s:clkgt info ok\n",__FUNCTION__);
-
-    }
-    rkpm_set_sram_ops_sysclk(fn_to_pie(rockchip_pie_chunk, &FUNC(sysclk_suspend))
-                                                ,fn_to_pie(rockchip_pie_chunk, &FUNC(sysclk_resume))); 
-}
-
-/***************************prepare and finish reg_pread***********************************/
-
-static noinline void rk30_pm_dump_irq(void)
-{
-#if 0
-	u32 irq_gpio = (readl_relaxed(RK30_GICD_BASE + GIC_DIST_PENDING_SET + 8) >> 22) & 0x7F;
-	printk("wakeup irq: %08x %08x %08x %08x\n",
-		readl_relaxed(RK30_GICD_BASE + GIC_DIST_PENDING_SET + 4),
-		readl_relaxed(RK30_GICD_BASE + GIC_DIST_PENDING_SET + 8),
-		readl_relaxed(RK30_GICD_BASE + GIC_DIST_PENDING_SET + 12),
-		readl_relaxed(RK30_GICD_BASE + GIC_DIST_PENDING_SET + 16));
-	DUMP_GPIO_INT_STATUS(0);
-	DUMP_GPIO_INT_STATUS(1);
-	DUMP_GPIO_INT_STATUS(2);
-	DUMP_GPIO_INT_STATUS(3);
-    #if GPIO_BANKS > 4
-	DUMP_GPIO_INT_STATUS(4);
-    #endif
-    #if GPIO_BANKS > 5
-	DUMP_GPIO_INT_STATUS(6);
-    #endif
-    #endif
-}
-
-
-#define DUMP_GPIO_INTEN(ID) \
-do { \
-	u32 en = readl_relaxed(RK_GPIO_VIRT(ID) + GPIO_INTEN); \
-	if (en) { \
-		rkpm_ddr_printascii("GPIO" #ID "_INTEN: "); \
-		rkpm_ddr_printhex(en); \
-		rkpm_ddr_printch('\n'); \
-		printk(KERN_DEBUG "GPIO%d_INTEN: %08x\n", ID, en); \
-	} \
-} while (0)
-static noinline void rk30_pm_dump_inten(void)
-{
-	DUMP_GPIO_INTEN(0);
-	DUMP_GPIO_INTEN(1);
-	DUMP_GPIO_INTEN(2);
-	DUMP_GPIO_INTEN(3);
-}
-
-
-static  void rkpm_prepare(void)
-{   
-    #if 1
-        u32 temp =reg_readl(RK_GPIO_VIRT(0)+0x30);
-
-       // rkpm_ddr_printhex(temp);
-        reg_writel(temp|0x1<<4,RK_GPIO_VIRT(0)+0x30);
-        temp =reg_readl(RK_GPIO_VIRT(0)+0x30);
-       // rkpm_ddr_printhex(temp);
-#endif
-        
-	// dump GPIO INTEN for debug
-	rk30_pm_dump_inten();
-        #ifdef CONFIG_DDR_TEST
-        // memory tester
-        //ddr_testmode();
-        #endif
-}
-
-static void rkpm_finish(void)
-{
-	rk30_pm_dump_irq();
-}
-
-
-static  void interface_ctr_reg_pread(void)
-{
-	//u32 addr;
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
-        #if 0  // do it in ddr suspend 
-	for (addr = (u32)SRAM_CODE_OFFSET; addr < (u32)(SRAM_CODE_OFFSET+rockchip_sram_size); addr += PAGE_SIZE)
-		readl_relaxed(addr);
-        #endif
-        readl_relaxed(RK_PMU_VIRT);
-        readl_relaxed(RK_GRF_VIRT);
-        readl_relaxed(RK_DDR_VIRT);
-        readl_relaxed(RK_GPIO_VIRT(0));     
-        //readl_relaxed(RK30_I2C1_BASE+SZ_4K);
-        //readl_relaxed(RK_GPIO_VIRT(3));
-}
-
-static u32 gpios_data[2];
-
-static void __init  rk3188_suspend_init(void)
-{
-    struct device_node *parent;
-    u32 pm_ctrbits;
-
-    PM_LOG("%s enter\n",__FUNCTION__);
-
-    parent = of_find_node_by_name(NULL, "rockchip_suspend");    
-
-    if (IS_ERR_OR_NULL(parent)) {
-		PM_ERR("%s dev node err\n", __func__);
-		return;
-	}
-
-
-    if(of_property_read_u32_array(parent,"rockchip,ctrbits",&pm_ctrbits,1))
-    {
-            PM_ERR("%s:get pm ctr error\n",__FUNCTION__);
-            return ;
-    }
-    PM_LOG("%s: pm_ctrbits =%x\n",__FUNCTION__,pm_ctrbits);
-
-    if(of_property_read_u32_array(parent,"rockchip,pmic-gpios",gpios_data,ARRAY_SIZE(gpios_data)))
-    {
-            PM_ERR("%s:get pm ctr error\n",__FUNCTION__);
-            return ;
-    }
-    rkpm_set_ctrbits(pm_ctrbits);
-    clks_gating_suspend_init();
-    rkpm_set_ops_plls(plls_suspend,plls_resume);
-    rkpm_set_ops_prepare_finish(rkpm_prepare,rkpm_finish);
-    rkpm_set_ops_regs_pread(interface_ctr_reg_pread); 
-    
-    //rkpm_set_sram_ops_ddr(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_suspend))
-                                   //     ,fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_resume)));
-                                   
-    rkpm_set_sram_ops_printch(fn_to_pie(rockchip_pie_chunk, &FUNC(sram_printch)));
-    rkpm_set_ops_printch(ddr_printch); 	
-    
-}
-
diff --git a/arch/arm/mach-rockchip/pm-rk3288.c b/arch/arm/mach-rockchip/pm-rk3288.c
deleted file mode 100755
index fcb6a7aa0c7b..000000000000
--- a/arch/arm/mach-rockchip/pm-rk3288.c
+++ /dev/null
@@ -1,2524 +0,0 @@
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/hardware/cache-l2x0.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/wakeup_reason.h>
-#include <linux/pm.h>
-#include <linux/suspend.h>
-#include <linux/of.h>
-#include <asm/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-
-#include <linux/rockchip/cpu.h>
-//#include <linux/rockchip/cru.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include "pm.h"
-#include <linux/irqchip/arm-gic.h>
-
-#define CPU 3288
-//#include "sram.h"
-#include "pm-pie.c"
-
-__weak void rk_usb_power_down(void);
-__weak void rk_usb_power_up(void);
-
-//static void ddr_pin_set_pull(u8 port,u8 bank,u8 b_gpio,u8 fun);
-//static void ddr_gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type);
-static void ddr_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun);
-
-/*************************cru define********************************************/
-
-
-#define RK3288_CRU_UNGATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(0,(id)%16,0x1),RK3288_CRU_GATEID_CONS((id)))
-#define RK3288_CRU_GATING_OPS(id) cru_writel(CRU_W_MSK_SETBITS(1,(id)%16,0x1),RK3288_CRU_GATEID_CONS((id)))
-
-enum rk_plls_id {
-	APLL_ID = 0,
-	DPLL_ID,
-	CPLL_ID,
-	GPLL_ID,
-	NPLL_ID,
-	END_PLL_ID,
-};
-
-#define RK3288_PLL_PWR_DN_MSK (0x1<<1)
-#define RK3288_PLL_PWR_DN CRU_W_MSK_SETBITS(1,1,0x1)
-#define RK3288_PLL_PWR_ON CRU_W_MSK_SETBITS(0,1,0x1)
-
-
-#define RK3288_PLL_RESET		CRU_W_MSK_SETBITS(1,5,0x1)
-#define RK3288_PLL_RESET_RESUME CRU_W_MSK_SETBITS(0,5,0x1)
-
-#define RK3288_PLL_BYPASS_MSK (0x1<<0)
-#define RK3288_PLL_BYPASS CRU_W_MSK_SETBITS(1,0,0x1)
-#define RK3288_PLL_NO_BYPASS CRU_W_MSK_SETBITS(0,0,0x1)
-
-/*******************************gpio define **********************************************/
-
-/* GPIO control registers */
-#define GPIO_SWPORT_DR		0x00
-#define GPIO_SWPORT_DDR		0x04
-#define GPIO_INTEN			0x30
-#define GPIO_INTMASK		0x34
-#define GPIO_INTTYPE_LEVEL	0x38
-#define GPIO_INT_POLARITY	0x3c
-#define GPIO_INT_STATUS		0x40
-#define GPIO_INT_RAWSTATUS	0x44
-#define GPIO_DEBOUNCE		0x48
-#define GPIO_PORTS_EOI		0x4c
-#define GPIO_EXT_PORT		0x50
-#define GPIO_LS_SYNC		0x60
-
-/***********************************sleep func*********************************************/
-
-#define RKPM_BOOTRAM_PHYS (RK3288_BOOTRAM_PHYS)
-#define RKPM_BOOTRAM_BASE (RK_BOOTRAM_VIRT)
-#define RKPM_BOOTRAM_SIZE (RK3288_BOOTRAM_SIZE)
-
-// sys resume code in boot ram
-#define  RKPM_BOOT_CODE_PHY  (RKPM_BOOTRAM_PHYS+RKPM_BOOT_CODE_OFFSET)
-#define  RKPM_BOOT_CODE_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_CODE_OFFSET)
-
-
-// sys resume data in boot ram
-#define  RKPM_BOOT_DATA_PHY  (RKPM_BOOTRAM_PHYS+RKPM_BOOT_DATA_OFFSET)
-#define  RKPM_BOOT_DATA_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_DATA_OFFSET)
-
-// ddr resume data in boot ram
-#define  RKPM_BOOT_DDRCODE_PHY   (RKPM_BOOTRAM_PHYS + RKPM_BOOT_DDRCODE_OFFSET)
-#define  RKPM_BOOT_DDRCODE_BASE  (RKPM_BOOTRAM_BASE+RKPM_BOOT_DDRCODE_OFFSET)
-
-#define RKPM_BOOT_CPUSP_PHY (RKPM_BOOTRAM_PHYS+((RKPM_BOOTRAM_SIZE-1)&~0x7))
-
-// the value is used to control cpu resume flow
-static u32 sleep_resume_data[RKPM_BOOTDATA_ARR_SIZE];
-static char *resume_data_base=(char *)( RKPM_BOOT_DATA_BASE);
-static char *resume_data_phy=  (char *)( RKPM_BOOT_DATA_PHY);
-
-
-
-#define BOOT_RAM_SIZE	(4*1024)
-#define INT_RAM_SIZE		(64*1024)
-
-static char boot_ram_data[BOOT_RAM_SIZE+4*10];
-static char int_ram_data[INT_RAM_SIZE];
-
-char * ddr_get_resume_code_info(u32 *size);
-char * ddr_get_resume_data_info(u32 *size);
-
-/**
-ddr code and data
-
-*** code start
----data offset-- 
----code----
----data----
-*/
-static void sram_data_for_sleep(char *boot_save, char *int_save,u32 flag)
-{	
- 	
-	char *addr_base,*addr_phy,*data_src,*data_dst;
-	u32 sr_size,data_size;
-
-	addr_base=(char *)RKPM_BOOTRAM_BASE;
-	addr_phy=(char *)RKPM_BOOTRAM_PHYS;
-	sr_size=RKPM_BOOTRAM_SIZE;
-
- 	// save boot sram
-	 if(boot_save)
-		 memcpy(boot_save,addr_base, sr_size);
-
-	// move resume code and date to boot sram
-	// move sys code
-	data_dst=(char *)RKPM_BOOT_CODE_BASE;
-	data_src=(char *)rkpm_slp_cpu_resume;
-	data_size=RKPM_BOOT_CODE_SIZE;
-	memcpy((char *)data_dst,(char *)data_src, data_size);
-
-	// move sys data
-	data_dst=(char *)resume_data_base;
-	data_src=(char *)sleep_resume_data;
-	data_size=sizeof(sleep_resume_data);
-	memcpy((char *)data_dst,(char *)data_src, data_size);
-            
-        if(flag)
-        {
-                /*************************ddr code cpy*************************************/
-                // ddr code
-                data_dst=(char *)(char *)RKPM_BOOT_DDRCODE_BASE;
-                data_src=(char *)ddr_get_resume_code_info(&data_size);
-
-                data_size=RKPM_ALIGN(data_size,4);
-
-                memcpy((char *)data_dst,(char *)data_src, data_size);
-
-                // ddr data
-                data_dst=(char *)(data_dst+data_size);
-
-                data_src=(char *)ddr_get_resume_data_info(&data_size);
-                data_size=RKPM_ALIGN(data_size,4);
-                memcpy((char *)data_dst,(char *)data_src, data_size);
-
-                /*************************ddr code cpy  end*************************************/
-                flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-                outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)(addr_phy)+sr_size);
-                /*************************int mem bak*************************************/
-                // int mem
-                addr_base=(char *)rockchip_sram_virt;
-                addr_phy=(char *)pie_to_phys(rockchip_pie_chunk,(unsigned long )rockchip_sram_virt);
-                sr_size=rockchip_sram_size;
-                //  rkpm_ddr_printascii("piephy\n");
-                //rkpm_ddr_printhex(addr_phy);
-                //mmap
-                if(int_save)
-                    memcpy(int_save,addr_base, sr_size);
-
-                flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-                outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)(addr_phy)+sr_size);
-        }    
-     
- }
-
-static void sram_data_resume(char *boot_save, char *int_save,u32 flag)
-{  
- 
-    char *addr_base,*addr_phy;
-    u32 sr_size;
-    
-    addr_base=(char *)RKPM_BOOTRAM_BASE;
-    addr_phy=(char *)RKPM_BOOTRAM_PHYS;
-    sr_size=RKPM_BOOTRAM_SIZE;
-    // save boot sram
-    if(boot_save)
-        memcpy(addr_base,boot_save, sr_size);
-
-    flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-    outer_clean_range((phys_addr_t) addr_phy, (phys_addr_t)addr_phy+sr_size);
-
-    if(flag)
-    {
-        // int mem
-        addr_base=(char *)rockchip_sram_virt;
-        addr_phy=(char *)pie_to_phys(rockchip_pie_chunk,(unsigned long )rockchip_sram_virt);
-        sr_size=rockchip_sram_size;
-
-        if(int_save)
-        memcpy(addr_base, int_save,sr_size);
-
-        flush_icache_range((unsigned long)addr_base, (unsigned long)addr_base + sr_size);
-        outer_clean_range((phys_addr_t) addr_phy,(unsigned long)addr_phy+sr_size);
-     }
-}
-
-/**************************************gic save and resume**************************/
-#define  RK_GICD_BASE (RK_GIC_VIRT)
-#define RK_GICC_BASE (RK_GIC_VIRT+RK3288_GIC_DIST_SIZE)
-
-#define PM_IRQN_START 32
-#define PM_IRQN_END	107//107
-#if 0 //funciton is ok ,but not used
-static void pm_gic_enable(u32 irqs)
-{
-
-        int irqstart=0;
-        u32 bit_off;
-        void __iomem *reg_off;
-        unsigned int gic_irqs;
-
-        gic_irqs = PM_IRQN_END;
-        irqstart=PM_IRQN_START;//PM_IRQN_START;
-
-        reg_off=(irqs/32)*4+GIC_DIST_ENABLE_SET+RK_GICD_BASE;
-        bit_off=irqs%32;
-        writel_relaxed(readl_relaxed(reg_off)|(1<<bit_off),reg_off);
-
-        dsb();
-}
-  
-static void rkpm_gic_disable(u32 irqs)
-{
-        int irqstart=0;
-        u32 bit_off;    
-        void __iomem *reg_off;
-        unsigned int gic_irqs;
-
-        gic_irqs = PM_IRQN_END;
-        irqstart=PM_IRQN_START;//PM_IRQN_START;
-
-        reg_off=(irqs/32)*4+GIC_DIST_ENABLE_CLEAR+RK_GICD_BASE;
-        bit_off=irqs%32;
-        writel_relaxed(readl_relaxed(reg_off)&~(1<<bit_off),reg_off);
-        dsb();
-}
-#endif
-#define gic_reg_dump(a,b,c)  {}//reg_dump((a),(b),(c))
-  
-static u32 slp_gic_save[260+50];
-
-
-static void rkpm_gic_dist_save(u32 *context)
-{
-     int i = 0,j,irqstart=0;
-     unsigned int gic_irqs;
-     
-     gic_irqs = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTR) & 0x1f;
-     gic_irqs = (gic_irqs + 1) * 32;
-     if (gic_irqs > 1020)
-     gic_irqs = 1020;
-     //printk("gic_irqs=%d\n",gic_irqs);
-     //gic_irqs = PM_IRQN_END;
-     irqstart=PM_IRQN_START;//PM_IRQN_START;
-     
-     i = 0;
-     //level
-     for (j = irqstart; j < gic_irqs; j += 16)
-      context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_CONFIG + (j * 4) / 16);
-     gic_reg_dump("gic level",j,RK_GICD_BASE + GIC_DIST_CONFIG);
-
-     /*
-     * Set all global interrupts to this CPU only.
-     */
-     for(j = 0; j < gic_irqs; j += 4)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_TARGET +	(j * 4) / 4);    
-     gic_reg_dump("gic trig",j,RK_GICD_BASE + GIC_DIST_TARGET);
-
-     //pri
-     for (j = 0; j < gic_irqs; j += 4)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE+ GIC_DIST_PRI + (j * 4) / 4);
-     gic_reg_dump("gic pri",j,RK_GICD_BASE + GIC_DIST_PRI);	 
-
-     //secure
-     for (j = 0; j < gic_irqs; j += 32)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_IGROUP + (j * 4) / 32);
-     gic_reg_dump("gic secure",j,RK_GICD_BASE + 0x80); 
-     	 
-     for (j = irqstart; j < gic_irqs; j += 32)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_PENDING_SET + (j * 4) / 32);    
-     gic_reg_dump("gic PENDING",j,RK_GICD_BASE + GIC_DIST_PENDING_SET);	 
-   
-    #if 0
-     //disable
-     for (j = 0; j < gic_irqs; j += 32)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + (j * 4) / 32);
-     gic_reg_dump("gic dis",j,RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR);
-    #endif
-    
-     //enable
-     for (j = 0; j < gic_irqs; j += 32)
-    	 context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_ENABLE_SET + (j * 4) / 32);
-     gic_reg_dump("gic en",j,RK_GICD_BASE + GIC_DIST_ENABLE_SET);  
-
-     
-     
-     gic_reg_dump("gicc",0x1c,RK_GICC_BASE);	 
-     gic_reg_dump("giccfc",0,RK_GICC_BASE+0xfc);
-
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_PRIMASK);  
-     context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_CTRL);
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_CTRL);
-   
-    #if 0
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_BINPOINT);
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_PRIMASK);
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_DIST_SOFTINT);
-     context[i++]=readl_relaxed(RK_GICC_BASE + GIC_CPU_CTRL);
-     context[i++]=readl_relaxed(RK_GICD_BASE + GIC_DIST_CTRL);
-    #endif	
-    
-    #if 1
-    for (j = irqstart; j < gic_irqs; j += 32)
-    {
-        writel_relaxed(0xffffffff, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-        dsb();
-    }     
-    writel_relaxed(0xffff0000, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR);
-    writel_relaxed(0x0000ffff, RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-
-    writel_relaxed(0, RK_GICC_BASE + GIC_CPU_CTRL);
-    writel_relaxed(0, RK_GICD_BASE + GIC_DIST_CTRL);  
-    #endif 
-
-}
-
-static void rkpm_gic_dist_resume(u32 *context)
-{
-
-         int i = 0,j,irqstart=0;
-         unsigned int gic_irqs;
-
-         
-         gic_irqs = readl_relaxed(RK_GICD_BASE + GIC_DIST_CTR) & 0x1f;
-         gic_irqs = (gic_irqs + 1) * 32;
-         if (gic_irqs > 1020)
-        	 gic_irqs = 1020;
-                 
-         //gic_irqs = PM_IRQN_END;
-         irqstart=PM_IRQN_START;//PM_IRQN_START;
-
-         writel_relaxed(0,RK_GICC_BASE + GIC_CPU_CTRL);
-         dsb();
-         writel_relaxed(0,RK_GICD_BASE + GIC_DIST_CTRL);
-         dsb();
-         for (j = irqstart; j < gic_irqs; j += 32)
-         {
-        	 writel_relaxed(0xffffffff, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-        	 dsb();
-         }
-
-         i = 0;
-
-         //trig
-         for (j = irqstart; j < gic_irqs; j += 16)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_CONFIG + j * 4 / 16);
-        	 dsb();
-         }
-         gic_reg_dump("gic level",j,RK_GICD_BASE + GIC_DIST_CONFIG);	 
-
-         /*
-         * Set all global interrupts to this CPU only.
-         */
-         for (j = 0; j < gic_irqs; j += 4)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_TARGET +  (j * 4) / 4);
-        	 dsb();
-         }
-         gic_reg_dump("gic target",j,RK_GICD_BASE + GIC_DIST_TARGET);  
-
-         //pri
-         for (j = 0; j < gic_irqs; j += 4)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE+ GIC_DIST_PRI + (j * 4) / 4);
-        	 
-        	 dsb();
-         }
-         gic_reg_dump("gic pri",j,RK_GICD_BASE + GIC_DIST_PRI);	 
-
-         
-         //secu
-         for (j = 0; j < gic_irqs; j += 32)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_IGROUP + (j * 4 )/ 32);        	 
-        	 dsb();
-         }
-         gic_reg_dump("gic secu",j,RK_GICD_BASE + 0x80);	 
-
-         //pending
-         for (j = irqstart; j < gic_irqs; j += 32)
-         {
-        	 //writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_PENDING_SET + j * 4 / 32);
-        	 i++;
-        	 dsb();
-         }
-         gic_reg_dump("gic pending",j,RK_GICD_BASE + GIC_DIST_PENDING_SET);	 
-
-         //disable
-#if 0
-         for (j = 0; j < gic_irqs; j += 32)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + j * 4 / 32);
-        	 dsb();
-         }
-         gic_reg_dump("gic disable",j,RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR);	 
-         
-#else
-        for (j = irqstart; j < gic_irqs; j += 32)
-            writel_relaxed(0xffffffff,RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR + j * 4 / 32);        
-        writel_relaxed(0xffff0000, RK_GICD_BASE + GIC_DIST_ENABLE_CLEAR);
-        writel_relaxed(0x0000ffff, RK_GICD_BASE + GIC_DIST_ENABLE_SET);
-#endif
-             	 
-         //enable
-         for (j = 0; j < gic_irqs; j += 32)
-         {
-        	 writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_ENABLE_SET + (j * 4) / 32);
-        	 
-        	 dsb();
-         }
-     
-         gic_reg_dump("gic enable",j,RK_GICD_BASE + GIC_DIST_ENABLE_SET);  
-      
-         writel_relaxed(context[i++],RK_GICC_BASE + GIC_CPU_PRIMASK);
-         writel_relaxed(context[i++],RK_GICD_BASE + GIC_DIST_CTRL);
-         writel_relaxed(context[i++],RK_GICC_BASE + GIC_CPU_CTRL);
-
-         gic_reg_dump("gicc",0x1c,RK_GICC_BASE);	 
-         gic_reg_dump("giccfc",0,RK_GICC_BASE+0xfc);	 
- 
-}
-
-/**************************************regs save and resume**************************/
-
-void slp_regs_save(u32 *data,void __iomem * base,u32 st_offset,u32 end_offset)
-{
-     u32 i;
-         u32 cnt=(end_offset-st_offset)/4+1;
-     for(i=0;i<cnt;i++)
-     {
-    	 data[i]=readl_relaxed(base+st_offset+i*4);
-     }	 
-}
-
-void slp_regs_resume(u32 *data,void __iomem * base,u32 st_offset,u32 end_offset,u32 w_msk)
-{
-     u32 i;
-     u32 cnt=(end_offset-st_offset)/4+1;
-     for(i=0;i<cnt;i++)
-     {		 
-    	 reg_writel(data[i]|w_msk,(base+st_offset+i*4));
-     }	 
-}
-
-void slp_regs_w_msk_resume(u32 *data,void __iomem * base,u32 st_offset,u32 end_offset,u32 *w_msk)
-{
-        u32 i;
-        u32 cnt=(end_offset-st_offset)/4+1;
-         for(i=0;i<cnt;i++)
-	 {		 
-		 reg_writel(data[i]|w_msk[i],(base+st_offset+i*4));
-	 }	 
-}
-
-/**************************************uarts save and resume**************************/
-
-#define RK3288_UART_NUM (4)
-
-static void __iomem *slp_uart_base[RK3288_UART_NUM]={NULL};
-static u32 slp_uart_phy[RK3288_UART_NUM]={(0xff180000),(0xff190000),(0xff690000),(0xff1b0000)};
- 
-#define UART_DLL	0	/* Out: Divisor Latch Low */
-#define UART_DLM	1	/* Out: Divisor Latch High */
-
-#define UART_IER	1
-#define UART_FCR	2
- 
-#define UART_LCR	3	/* Out: Line Control Register */
-#define UART_MCR	4
-
-#if 0 //
-static u32 slp_uart_data[RK3288_UART_NUM][10];
-static u32 slp_uart_data_flag[RK3288_UART_NUM];
-
- void slp_uart_save(int ch)
- {
-	 int i=0;
-	void __iomem *b_addr=slp_uart_base[ch];
-	 int idx=RK3288_CLKGATE_PCLK_UART0+ch;
-	 u32 gate_reg;
-	 if(b_addr==NULL || ch>=RK3288_UART_NUM)
-	 	return;	
-     
-        if(ch==2)
-        {
-            idx=RK3288_CLKGATE_PCLK_UART2;
-            b_addr=RK_DEBUG_UART_VIRT;
-        }
-
-        
-	gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-        RK3288_CRU_UNGATING_OPS(idx); 
-         i=0;
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_LCR*4); 
-	 writel_relaxed(readl_relaxed(b_addr+UART_LCR*4)|0x80,b_addr+UART_LCR*4);
-	 
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_DLL*4);
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_DLM*4);
-	 
-	 writel_relaxed(readl_relaxed(b_addr+UART_LCR*4)&(~0x80),b_addr+UART_LCR*4);
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_IER*4);
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_FCR*4);
-	 slp_uart_data[ch][i++]=readl_relaxed(b_addr+UART_MCR*4);
-	 
-        cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
- 
- }
- 
- void slp_uart_resume(int ch)
- {	 
-        int i=0;
-
-        u32 temp;
-        void __iomem *b_addr=slp_uart_base[ch];
-        int idx=RK3288_CLKGATE_PCLK_UART0+ch;
-        u32 gate_reg;
-        
-        //rkpm_ddr_printascii("\nch");
-     //   rkpm_ddr_printhex(b_addr);
-        
-        if(b_addr==NULL || ch>=RK3288_UART_NUM)
-            return;	
-        
-        if(ch==2)
-            idx=RK3288_CLKGATE_PCLK_UART2;
-
-        //rkpm_ddr_printhex(ch);
-
-        gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-        RK3288_CRU_UNGATING_OPS(idx); 
- 
-         i=0;
-	 temp=slp_uart_data[ch][i++];
-	 writel_relaxed(readl_relaxed(b_addr+UART_LCR*4)|0x80,b_addr+UART_LCR*4);
-	 
-	 writel_relaxed(slp_uart_data[ch][i++],b_addr+UART_DLL*4);
-	 writel_relaxed(slp_uart_data[ch][i++],b_addr+UART_DLM*4);
-	 
-	 writel_relaxed(readl_relaxed(b_addr+UART_LCR*4)&(~0x80),b_addr+UART_LCR*4);
- 
-	 writel_relaxed(slp_uart_data[ch][i++],b_addr+UART_IER*4);
-	 writel_relaxed(slp_uart_data[ch][i++],b_addr+UART_FCR*4);
-	 writel_relaxed(slp_uart_data[ch][i++],b_addr+UART_MCR*4);
-	 
-	 writel_relaxed(temp,b_addr+UART_LCR*4);
-	 
-         cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
- }
-#endif
- void slp_uartdbg_resume(void)
-{   
-    void __iomem *b_addr=RK_DEBUG_UART_VIRT;
-    u32 pclk_id=RK3288_CLKGATE_PCLK_UART2,clk_id=(RK3288_CLKGATE_UART0_SRC+2*2);
-    u32 gate_reg[2];
-    u32 rfl_reg,lsr_reg;
-
-    gate_reg[0]=cru_readl(RK3288_CRU_GATEID_CONS(pclk_id));        
-    gate_reg[1]=cru_readl(RK3288_CRU_GATEID_CONS(clk_id));     
-
-    RK3288_CRU_UNGATING_OPS(pclk_id); 
-    // 24M is no gating setting
-    ddr_pin_set_fun(0x7,0xc,0x6,0x0);
-    ddr_pin_set_fun(0x7,0xc,0x7,0x0);             
-
-    do{
-            // out clk sel 24M
-            cru_writel(CRU_W_MSK_SETBITS(0x2,8,0x3), RK3288_CRU_CLKSELS_CON(15));
-            
-            //uart2 dbg reset
-            cru_writel(0|CRU_W_MSK_SETBITS(1,5,0x1), RK3288_CRU_SOFTRSTS_CON(11));
-            dsb();
-            dsb();
-            rkpm_udelay(10);
-            cru_writel(0|CRU_W_MSK_SETBITS(0,5,0x1), RK3288_CRU_SOFTRSTS_CON(11));
-
-        #if 0
-            //out clk (form pll)  is gating 
-            RK3288_CRU_GATING_OPS(clk_id);
-            //out clk form pll gating to disable uart clk out
-            // div 12
-            cru_writel(CRU_W_MSK_SETBITS(11,0,0x7f), RK3288_CRU_CLKSELS_CON(15));
-            dsb();
-            dsb();   
-            dsb();
-            dsb();
-            cru_writel(CRU_W_MSK_SETBITS(0,8,0x3) , RK3288_CRU_CLKSELS_CON(15));
-         #endif
-
-
-            reg_writel(0x83,b_addr+UART_LCR*4);  
-
-            reg_writel(0xd,b_addr+UART_DLL*4);
-            reg_writel(0x0,b_addr+UART_DLM*4);
-
-            reg_writel(0x3,b_addr+UART_LCR*4);    
-
-            reg_writel(0x5,b_addr+UART_IER*4);
-            reg_writel(0xc1,b_addr+UART_FCR*4);
-
-            rfl_reg=readl_relaxed(b_addr+0x84);
-            lsr_reg=readl_relaxed(b_addr+0x14);
-       
-        }while((rfl_reg&0x1f)||(lsr_reg&0xf));
-                 
-        // out clk sel 24M
-        cru_writel(CRU_W_MSK_SETBITS(0x2,8,0x3), RK3288_CRU_CLKSELS_CON(15));
-
-        ddr_pin_set_fun(0x7,0xc,0x6,0x1);
-        ddr_pin_set_fun(0x7,0xc,0x7,0x1);
-        cru_writel(gate_reg[0]|CRU_W_MSK(pclk_id%16,0x1),RK3288_CRU_GATEID_CONS(pclk_id)); 
-        cru_writel(gate_reg[1]|CRU_W_MSK(clk_id%16,0x1),RK3288_CRU_GATEID_CONS(clk_id)); 
-}
- 
-/**************************************i2c save and resume**************************/
-
-//#define RK3288_I2C_REG_DUMP
-#define RK3288_I2C_NUM (6)
-static u32 slp_i2c_phy[RK3288_I2C_NUM]={(0xff650000),(0xff140000),(0xff660000),(0xff150000),(0xff160000),(0xff170000)};
-static void __iomem *slp_i2c_base[RK3288_I2C_NUM]={NULL};
-
-static u32 slp_i2c_data[RK3288_I2C_NUM][10];
-
-void slp_i2c_save(int ch)
-{
-
-	void __iomem *b_addr=slp_i2c_base[ch];
-	int idx= (ch>1) ? (RK3288_CLKGATE_PCLK_I2C2+ch-2):(RK3288_CLKGATE_PCLK_I2C0+ch);
-	u32 gate_reg;
-
-	if(!b_addr)
-		return;
-    
-        gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-        RK3288_CRU_UNGATING_OPS(idx); 
-        
-        #ifdef RK3288_I2C_REG_DUMP
-        rkpm_ddr_printascii("i2c save");
-        rkpm_ddr_printhex(ch);
-        rkpm_ddr_printch('\n');        
-        rkpm_ddr_regs_dump(b_addr,0x0,0xc);
-        #endif
-        
-        slp_regs_save(&slp_i2c_data[ch][0],b_addr,0x0,0xc);  
-        
-
-        cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
-
-}
-void slp_i2c_resume(int ch)
-{
-        void __iomem *b_addr=slp_i2c_base[ch];
-        int idx= (ch>1) ? (RK3288_CLKGATE_PCLK_I2C2+ch-2):(RK3288_CLKGATE_PCLK_I2C0+ch);
-	u32 gate_reg;
-	
-	if(!b_addr)
-		return;
-        gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-        RK3288_CRU_UNGATING_OPS(idx); 
-
-        slp_regs_resume(&slp_i2c_data[ch][0],b_addr,0x0,0xc,0x0);  
-
-        #ifdef RK3288_I2C_REG_DUMP
-        rkpm_ddr_printascii("i2c resume");
-        rkpm_ddr_printhex(ch);
-        rkpm_ddr_printch('\n');        
-        rkpm_ddr_regs_dump(b_addr,0x0,0xc);
-        #endif
-  
-        cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
-}
-
-/**************************************gpios save and resume**************************/
-#define RK3288_GPIO_CH (9)
-#if 0 //fun is ok ,not used
-
-static u32 slp_gpio_data[RK3288_GPIO_CH][10]; 
-static u32 slp_grf_iomux_data[RK3288_GPIO_CH*4];
-static u32 slp_grf_io_pull_data[RK3288_GPIO_CH*4];
-static void gpio_ddr_dump_reg(int ports)
-{
-    void __iomem *b_addr=RK_GPIO_VIRT(ports);
-    
-    rkpm_ddr_printascii("gpio-");
-    rkpm_ddr_printhex(ports);
-    rkpm_ddr_printhex('\n');      
-    
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_SWPORT_DR);
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_SWPORT_DDR);      
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_INTEN);  
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_INTMASK);     
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_INTTYPE_LEVEL);  
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_INT_POLARITY);   
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_DEBOUNCE);   
-    rkpm_ddr_reg_offset_dump(b_addr,GPIO_LS_SYNC);    
-    rkpm_ddr_printhex('\n');      
-
-    rkpm_ddr_printascii("iomux\n");
-    rkpm_ddr_regs_dump(RK_GRF_VIRT,0x0+ports*4*4,0x0+ports*4*4+3*4);
-
-    rkpm_ddr_printascii("iomux\n");
-    rkpm_ddr_regs_dump(RK_GRF_VIRT,0x130+ports*4*4,ports*4*4+3*4);
-
-}
- static void slp_pin_gpio_save(int ports)
- {
-        int i;
-        void __iomem *b_addr=RK_GPIO_VIRT(ports);
-        int idx=RK3288_CLKGATE_PCLK_GPIO1+ports-1;
-        u32 gate_reg;
-
-	if(ports==0||ports>=RK3288_GPIO_CH)
-		return;
-	
-         gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-         RK3288_CRU_UNGATING_OPS(idx); 
-         
-         //gpio_ddr_dump_reg(ports);          
-	 i=0;
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_SWPORT_DR);
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_SWPORT_DDR);
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_INTEN);	 
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_INTMASK);  
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_INTTYPE_LEVEL);	 
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_INT_POLARITY);
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_DEBOUNCE);
-	 slp_gpio_data[ports][i++]=readl_relaxed(b_addr+GPIO_LS_SYNC); 
-
-        if(ports>0)
-        {
-            slp_regs_save(&slp_grf_iomux_data[ports*4],RK_GRF_VIRT,0x0+ports*4*4,0x0+ports*4*4+3*4);  
-            slp_regs_save(&slp_grf_io_pull_data[ports*4],RK_GRF_VIRT,0x130+ports*4*4,ports*4*4+3*4);
-         }
-
-     
-        cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
- 
- }
-
- static void slp_pin_gpio_resume (int ports)
- {
-	 int i;
-        void __iomem *b_addr=RK_GPIO_VIRT(ports);
-        int idx=RK3288_CLKGATE_PCLK_GPIO1+ports-1;
-	 u32 gate_reg;
-	 
-	 if(ports==0||ports>=RK3288_GPIO_CH)
-		return;
-	  gate_reg=cru_readl(RK3288_CRU_GATEID_CONS(idx));     
-         RK3288_CRU_UNGATING_OPS(idx); 
-
-
-        if(ports>0)
-        {
-            slp_regs_resume(&slp_grf_iomux_data[ports*4],RK_GRF_VIRT,0x0+ports*4*4,0x0+ports*4*4+3*4,0xffff0000);  
-            slp_regs_resume(&slp_grf_io_pull_data[ports*4],RK_GRF_VIRT,0x130+ports*4*4,ports*4*4+3*4,0xffff0000);
-        }
- 
-        i=0;
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_SWPORT_DR);
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_SWPORT_DDR);
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_INTEN);	 
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_INTMASK); 
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_INTTYPE_LEVEL);	 
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_INT_POLARITY);
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_DEBOUNCE);
-        writel_relaxed(slp_gpio_data[ports][i++],b_addr+GPIO_LS_SYNC);	    
-        
-        //gpio_ddr_dump_reg(ports);	
-        cru_writel(gate_reg|CRU_W_MSK(idx%16,0x1),RK3288_CRU_GATEID_CONS(idx));         
- 
- }
- 
-#endif
- static inline u32 rkpm_l2_config(void)
- {
-     u32 l2ctlr;
-     asm("mrc p15, 1, %0, c9, c0, 2" : "=r" (l2ctlr));
-      return l2ctlr;
- }
-
-static inline u32 rkpm_armerrata_818325(void)
-{
-    u32 armerrata;
-    asm("mrc p15, 0, %0, c15, c0, 1" : "=r" (armerrata));
-    return armerrata;
-}
-
-
-
-/**************************************sleep func**************************/
-
-void ddr_reg_save(uint32_t *pArg);
-void fiq_glue_resume(void);
-void rk30_cpu_resume(void);
-void rk30_l2_cache_init_pm(void);
-//static void rk319x_pm_set_power_domain(enum pmu_power_domain pd, bool state);
-void ddr_cfg_to_lp_mode(void);
-void l2x0_inv_all_pm(void);
-void rk30_cpu_while_tst(void);
-
-#if 0
-static u32 slp_grf_soc_con_data[5];
-static u32 slp_grf_soc_con_w_msk[5]={0x70000,0x40ff0000,0xffff0000,0xffff0000,0xffff0000};
-
-static u32 slp_grf_cpu_con_data[5];
-static u32 slp_grf_cpu_con_w_msk[5]={0xefff0000,0xffff0000,0xcfff0000,0xffff0000,0x7fff0000};
-
-static u32 slp_grf_uoc0_con_data[4];
-static u32 slp_grf_uoc0_con_w_msk[4]={0xffff0000,0xffff0000,0x7dff0000,0x7fff0000};// uoc0_con4 bit 15?? 
-
-static u32 slp_grf_uoc1_con_data[2];
-static u32 slp_grf_uoc1_con_w_msk[2]={0x1fdc0000,0x047f0000};
-
-static u32 slp_grf_uoc2_con_data[2];
-static u32 slp_grf_uoc2_con_w_msk[2]={0x7fff0000,0x1f0000};
-
-static u32 slp_grf_uoc3_con_data[2];
-static u32 slp_grf_uoc3_con_w_msk[2]={0x3ff0000,0x0fff0000};
-
-#endif
-//static u32 slp_pmu_pwrmode_con_data[1];
-
-
-//static u32 slp_nandc_data[8];
-//static void __iomem *rk30_nandc_base=NULL;
-
-#define MS_37K (37)
-#define US_24M (24)
-
-void inline pm_io_base_map(void)
-{
-        int i;
-        for(i=0;i<RK3288_I2C_NUM;i++)
-            slp_i2c_base[i]  = ioremap(slp_i2c_phy[i], 0x1000);
-
-        for(i=0;i<RK3288_UART_NUM;i++)
-            {
-                if(i!=CONFIG_RK_DEBUG_UART)
-                    slp_uart_base[i]  = ioremap(slp_uart_phy[i], 0x1000);
-                else
-                    slp_uart_base[i] = RK_DEBUG_UART_VIRT;
-            }
-	
-}	
-enum rk3288_pwr_mode_con {
-
-        pmu_pwr_mode_en=0,
-        pmu_clk_core_src_gate_en,
-        pmu_global_int_disable,
-        pmu_l2flush_en,
-        
-        pmu_bus_pd_en,
-        pmu_a12_0_pd_en,
-        pmu_scu_en,
-        pmu_pll_pd_en,
-        
-        pmu_chip_pd_en, // power off pin enable
-        pmu_pwroff_comb,
-        pmu_alive_use_lf,
-        pmu_pmu_use_lf,
-        
-        pmu_osc_24m_dis,
-        pmu_input_clamp_en,
-        pmu_wakeup_reset_en,
-        pmu_sref0_enter_en,
-        
-        pmu_sref1_enter_en,       
-        pmu_ddr0io_ret_en,
-        pmu_ddr1io_ret_en,
-        pmu_ddr0_gating_en,
-        
-        pmu_ddr1_gating_en,
-        pmu_ddr0io_ret_de_req,
-        pmu_ddr1io_ret_de_req
-
-};
- enum rk3288_pwr_mode_con1 {
-
-        pmu_clr_bus=0,
-        pmu_clr_core,
-        pmu_clr_cpup,
-        pmu_clr_alive,
-        
-        pmu_clr_dma,
-        pmu_clr_peri,
-        pmu_clr_gpu,
-        pmu_clr_video,
-        pmu_clr_hevc,
-        pmu_clr_vio
-  
-};
- static u32 rk3288_powermode=0;
-static void ddr_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun);
-
-static u32 sgrf_soc_con0,pmu_wakeup_cfg0,pmu_wakeup_cfg1,pmu_pwr_mode_con0,pmu_pwr_mode_con1;
-
-static u32  rkpm_slp_mode_set(u32 ctrbits)
-{
-    u32 mode_set,mode_set1;
-    // setting gpio0_a0 arm off pin
-
-    sgrf_soc_con0=reg_readl(RK_SGRF_VIRT+RK3288_SGRF_SOC_CON0);
-    
-    pmu_wakeup_cfg0=pmu_readl(RK3288_PMU_WAKEUP_CFG0);  
-    pmu_wakeup_cfg1=pmu_readl(RK3288_PMU_WAKEUP_CFG1);
-    
-    pmu_pwr_mode_con0=pmu_readl(RK3288_PMU_PWRMODE_CON);  
-    pmu_pwr_mode_con1=pmu_readl(RK3288_PMU_PWRMODE_CON1);
-    
-    ddr_pin_set_fun(0x0,0xa,0x0,0x1);
-
-
-    
-    //mode_set1=pmu_pwr_mode_con1;
-    //mode_set=pmu_pwr_mode_con0;
-  
-   //pmu_writel(0x1<<3,RK3188_PMU_WAKEUP_CFG1);  
-   pmu_writel(0x1<<0,RK3188_PMU_WAKEUP_CFG1);  
-
-    // enable boot ram    
-    reg_writel((0x1<<8)|(0x1<<(8+16)),RK_SGRF_VIRT+RK3288_SGRF_SOC_CON0);
-    dsb();
-    
-    reg_writel(RKPM_BOOTRAM_PHYS,RK_SGRF_VIRT+RK3288_SGRF_FAST_BOOT_ADDR);
-    dsb();
-
-    mode_set=  BIT(pmu_pwr_mode_en) |BIT(pmu_global_int_disable) | BIT(pmu_l2flush_en);
-     mode_set1=0;
-
-    if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_IDLEAUTO_MD))
-    {
-        rkpm_ddr_printascii("-autoidle-");
-        mode_set|=BIT(pmu_clk_core_src_gate_en);        
-    }
-    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMDP_LPMD))
-    {
-	rkpm_ddr_printascii("-armdp-");
-	mode_set |= BIT(pmu_a12_0_pd_en)
-			| BIT(pmu_sref0_enter_en) | BIT(pmu_sref1_enter_en)
-			| BIT(pmu_ddr0_gating_en) | BIT(pmu_ddr1_gating_en)
-			| BIT(pmu_chip_pd_en);
-    }
-    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMOFF_LPMD))
-    {   
-        rkpm_ddr_printascii("-armoff-");                         
-        mode_set|=BIT(pmu_scu_en)
-                            //|BIT(pmu_a12_0_pd_en) 
-                            |BIT(pmu_clk_core_src_gate_en) // 
-                            |BIT(pmu_sref0_enter_en)|BIT(pmu_sref1_enter_en) 
-                            |BIT(pmu_ddr0_gating_en)|BIT(pmu_ddr1_gating_en)              
-                            //|BIT(pmu_ddr1io_ret_en)|BIT(pmu_ddr0io_ret_en)   
-                            |BIT(pmu_chip_pd_en);
-        mode_set1=BIT(pmu_clr_core)|BIT(pmu_clr_cpup)
-                                |BIT(pmu_clr_alive)
-                                |BIT(pmu_clr_peri)
-                                |BIT(pmu_clr_bus)
-                                |BIT(pmu_clr_dma)
-                                ;
-    } 
-    else if(rkpm_chk_val_ctrbits(ctrbits,RKPM_CTR_ARMOFF_LOGDP_LPMD))
-    {
-    
-        rkpm_ddr_printascii("-armoff-logdp-");        
-        
-        mode_set|=BIT(pmu_scu_en)|BIT(pmu_bus_pd_en)
-                            |BIT(pmu_chip_pd_en)
-                            |BIT(pmu_sref0_enter_en)|BIT(pmu_sref1_enter_en) 
-                            |BIT(pmu_ddr0_gating_en)|BIT(pmu_ddr1_gating_en)              
-                            |BIT(pmu_ddr1io_ret_en)|BIT(pmu_ddr0io_ret_en)   
-                            |BIT(pmu_osc_24m_dis)|BIT(pmu_pmu_use_lf)|BIT(pmu_alive_use_lf)|BIT(pmu_pll_pd_en)
-                            ;
-        mode_set1=BIT(pmu_clr_core)|BIT(pmu_clr_cpup)
-                           |BIT(pmu_clr_alive)
-                           |BIT(pmu_clr_peri)
-                           |BIT(pmu_clr_bus) 
-                           |BIT(pmu_clr_dma)                                       
-                          ;
-     
-    } 
-    else
-    {
-        mode_set=0;
-        mode_set1=0;
-    }
-
-    
-    if(mode_set&BIT(pmu_osc_24m_dis))
-    {
-        rkpm_ddr_printascii("osc_off");        
-        pmu_writel(32*30,RK3288_PMU_OSC_CNT);  
-        pmu_writel(32*30,RK3288_PMU_STABL_CNT);  
-    } else if (mode_set & BIT(pmu_a12_0_pd_en)) {
-	pmu_writel(0x0, RK3288_PMU_STABL_CNT);
-	pmu_writel(0x0, RK3288_PMU_OSC_CNT);
-	pmu_writel(0x0, RK3288_PMU_PLL_CNT);
-	pmu_writel(0x0, RK3288_PMU_DDR0IO_PWRON_CNT);
-	pmu_writel(0x0, RK3288_PMU_DDR1IO_PWRON_CNT);
-	pmu_writel(0x0, RK3288_PMU_GPU_PWRUP_CNT);
-	pmu_writel(0x0, RK3288_PMU_WAKEUP_RST_CLR_CNT);
-	/*pmu_writel(100,RK3288_PMU_CORE_PWRUP_CNT);*/
-	} else
-	pmu_writel(24*1000*10, RK3288_PMU_STABL_CNT);
-
-    if(mode_set&BIT(pmu_ddr0io_ret_en))
-    {
-        rkpm_ddr_printascii("ddrc_off");  
-        ddr_pin_set_fun(0x0,0xa,0x1,0x1);
-        ddr_pin_set_fun(0x0,0xa,0x2,0x1);
-        ddr_pin_set_fun(0x0,0xa,0x3,0x1);
-    }
-
-    pmu_writel(mode_set,RK3288_PMU_PWRMODE_CON);  
-    pmu_writel(mode_set1,RK3288_PMU_PWRMODE_CON1);  
-    
-  //  rkpm_ddr_printhex(mode_set);
-  //  rkpm_ddr_printhex(pmu_readl(RK3288_PMU_PWRMODE_CON));
-
-    return (pmu_readl(RK3288_PMU_PWRMODE_CON));  
-}
-
-static inline void  rkpm_slp_mode_set_resume(void)
-{
-
-    pmu_writel(pmu_wakeup_cfg0,RK3288_PMU_WAKEUP_CFG0);  
-    pmu_writel(pmu_wakeup_cfg1,RK3288_PMU_WAKEUP_CFG1);  
-    
-    pmu_writel(pmu_pwr_mode_con0,RK3288_PMU_PWRMODE_CON);  
-    pmu_writel(pmu_pwr_mode_con1,RK3288_PMU_PWRMODE_CON1);  
-    reg_writel(sgrf_soc_con0|(0x1<<(8+16)),RK_SGRF_VIRT+RK3288_SGRF_SOC_CON0);
-    
-}
-
-static void sram_code_data_save(u32 pwrmode)
-{
-	char *code_src,*data_src;
-	u32 code_size,data_size;
-      
-     
-	//u32 *p;
-        if(pwrmode&(BIT(pmu_scu_en)|BIT(pmu_a12_0_pd_en)))
-        {   
-            sleep_resume_data[RKPM_BOOTDATA_L2LTY_F]=1;
-            sleep_resume_data[RKPM_BOOTDATA_L2LTY]=rkpm_l2_config();// in sys resume ,ddr is need resume	
-            
-            sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325_F]=1;
-            sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325]=rkpm_armerrata_818325();//
-        
-            sleep_resume_data[RKPM_BOOTDATA_CPUSP]=RKPM_BOOT_CPUSP_PHY;// in sys resume ,ddr is need resume	            
-            sleep_resume_data[RKPM_BOOTDATA_CPUCODE]=virt_to_phys(cpu_resume);// in sys resume ,ddr is need resume  
-            #if 0
-            rkpm_ddr_printascii("l2&arm_errata--");   
-            rkpm_ddr_printhex(rkpm_l2_config());             
-            rkpm_ddr_printhex(rkpm_armerrata_818325());
-            rkpm_ddr_printascii("\n");  
-            #endif
-        }
-        else
-        {
-            sleep_resume_data[RKPM_BOOTDATA_L2LTY_F]=0;
-            sleep_resume_data[RKPM_BOOTDATA_ARM_ERRATA_818325_F]=0;       
-            sleep_resume_data[RKPM_BOOTDATA_CPUCODE]=0;
-            return ;
-        }
-	
-        if(pwrmode&BIT(pmu_bus_pd_en))                
-        {   
-        	sleep_resume_data[RKPM_BOOTDATA_DDR_F]=1;// in sys resume ,ddr is need resume
-        	sleep_resume_data[RKPM_BOOTDATA_DPLL_F]=1;// in ddr resume ,dpll is need resume
-                code_src=(char *)ddr_get_resume_code_info(&code_size);
-                sleep_resume_data[RKPM_BOOTDATA_DDRCODE]=RKPM_BOOT_DDRCODE_PHY;
-                sleep_resume_data[RKPM_BOOTDATA_DDRDATA]=RKPM_BOOT_DDRCODE_PHY+RKPM_ALIGN(code_size,4);
-                data_src=(char *)ddr_get_resume_data_info(&data_size);
-                ddr_reg_save((u32 *)(resume_data_phy+RKPM_BOOTDATA_DPLL_F*4));
-       }
-        else
-        {
-            sleep_resume_data[RKPM_BOOTDATA_DDR_F]=0;
-        }
-        
-	sram_data_for_sleep(boot_ram_data,int_ram_data,sleep_resume_data[RKPM_BOOTDATA_DDR_F]);
-    
-        flush_cache_all();
-        outer_flush_all();
-        local_flush_tlb_all();
-
-}
-
-static inline void sram_code_data_resume(u32 pwrmode)
-{
-         if(pwrmode&(BIT(pmu_scu_en)|BIT(pmu_a12_0_pd_en)))
-        {
-             sram_data_resume(boot_ram_data,int_ram_data,sleep_resume_data[RKPM_BOOTDATA_DDR_F]);
-        }
-             
-}
-
-static void  rkpm_peri_save(u32 power_mode)
-{
-//    u32 gpio_gate[2];
-
-	if (power_mode & (BIT(pmu_scu_en) | BIT(pmu_a12_0_pd_en)))
-		rkpm_gic_dist_save(&slp_gic_save[0]);
-#if 0
-    gpio_gate[0]=cru_readl(RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO0));
-    gpio_gate[1]=cru_readl(RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
-    RK3288_CRU_UNGATING_OPS(RK3288_CLKGATE_PCLK_GPIO0);
-    cru_writel(0xff<<(RK3288_CLKGATE_PCLK_GPIO1%16+16),
-                         RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
-#endif
-    
-    if(power_mode&BIT(pmu_bus_pd_en))
-   {  
-       #if 0
-        //gpio7_c6
-        //gpio7_c7
-        ddr_pin_set_pull(7,0xc,0x6,RKPM_GPIO_PULL_UP);
-        ddr_gpio_set_in_output(7,0xc,0x6,RKPM_GPIO_INPUT);
-        ddr_pin_set_fun(7,0xc,0x6,0);
-        
-        ddr_pin_set_pull(7,0xc,0x7,RKPM_GPIO_PULL_UP);
-        ddr_gpio_set_in_output(7,0xc,0x7,RKPM_GPIO_INPUT);
-        ddr_pin_set_fun(7,0xc,0x7,0);
-        #endif
-        //slp_uart_save(2);
-        #if 0
-        ddr_pin_set_pull(0,0xb,0x7,RKPM_GPIO_PULL_UP);
-        ddr_gpio_set_in_output(0,0xb,0x7,RKPM_GPIO_INPUT);
-        ddr_pin_set_fun(0,0xb,0x7,0);
-        
-        ddr_pin_set_pull(0,0xc,0x0,RKPM_GPIO_PULL_UP);
-        ddr_gpio_set_in_output(0,0xc,0x0,RKPM_GPIO_INPUT);
-        ddr_pin_set_fun(0,0xc,0x0,0);
-        #endif      
-        slp_i2c_save(0);// i2c pmu gpio0b7 gpio0_c0
-        slp_i2c_save(1);//i2c audio
-    }
-
-#if 0
-        cru_writel((0xff<<(RK3288_CLKGATE_PCLK_GPIO1%16+16))|gpio_gate[0],
-                                      RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO1));
-        cru_writel(gpio_gate[0]|CRU_W_MSK(RK3288_CLKGATE_PCLK_GPIO0%16,0x1),RK3288_CRU_GATEID_CONS(RK3288_CLKGATE_PCLK_GPIO0));         
-#endif
-
-}
-
-static inline void  rkpm_peri_resume(u32 power_mode)
-{
-	if (power_mode & (BIT(pmu_scu_en) | BIT(pmu_a12_0_pd_en))) {
-		/*fiq_glue_resume();*/
-		rkpm_gic_dist_resume(&slp_gic_save[0]);
-		fiq_glue_resume();
-		/*rkpm_ddr_printascii("gic res");*/
-	}
-    if(power_mode&BIT(pmu_bus_pd_en))
-   {
-        slp_i2c_resume(0);// i2c pmu
-        slp_i2c_resume(1);//i2c audio
-    }
-
-}
-
-static u32 pdbus_gate_reg[5];
-static inline void  rkpm_peri_resume_first(u32 power_mode)
-{
-    
-    if(power_mode&BIT(pmu_bus_pd_en))
-    {
-        cru_writel(0xffff0000|pdbus_gate_reg[0],RK3288_CRU_CLKGATES_CON(0));      
-        cru_writel(0xffff0000|pdbus_gate_reg[1],RK3288_CRU_CLKGATES_CON(4));       
-        cru_writel(0xffff0000|pdbus_gate_reg[2],RK3288_CRU_CLKGATES_CON(5));      
-        cru_writel(0xffff0000|pdbus_gate_reg[3],RK3288_CRU_CLKGATES_CON(10));     
-        cru_writel(0xffff0000|pdbus_gate_reg[4],RK3288_CRU_CLKGATES_CON(11));     
-    }
-
-
-      if(power_mode&BIT(pmu_bus_pd_en))
-        slp_uartdbg_resume();
-}
-
-static void rkpm_slp_setting(void)
-{
-    rk_usb_power_down();
-
-    if(rk3288_powermode&BIT(pmu_bus_pd_en))
-    {   
-        // pd bus will be power down ,but if it reup,ungating clk for its reset
-        // ungating pdbus clk
-        pdbus_gate_reg[0]=cru_readl(RK3288_CRU_CLKGATES_CON(0));
-        pdbus_gate_reg[1]=cru_readl(RK3288_CRU_CLKGATES_CON(4));
-        pdbus_gate_reg[2]=cru_readl(RK3288_CRU_CLKGATES_CON(5));
-        pdbus_gate_reg[3]=cru_readl(RK3288_CRU_CLKGATES_CON(10));
-        pdbus_gate_reg[4]=cru_readl(RK3288_CRU_CLKGATES_CON(11));
-        
-        cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(0));      
-        cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(4));       
-        cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(5));      
-        cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(10));     
-        cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(11));     
-
-        RK3288_CRU_UNGATING_OPS(RK3288_CLKGATE_PCLK_UART2); 
-       // RK3288_CRU_UNGATING_OPS((RK3288_CLKGATE_UART0_SRC+2*2)); 
-       //c2c host
-       RK3288_CRU_UNGATING_OPS(RK3288_CRU_CONS_GATEID(13)+8); 
-           
-    }
-
-}
-
-
-static void rkpm_save_setting_resume_first(void)
-{
-	rk_usb_power_up();
-        rkpm_peri_resume_first(rk3288_powermode);     
-        
-        // rkpm_ddr_printhex(cru_readl(RK3288_CRU_MODE_CON));
-        #if 0
-	//rk319x_pm_set_power_domain(PD_PERI,true);
-	//slp_regs_resume(slp_grf_io_pull_data,(u32)RK_GRF_VIRT+0x144,16,0xffff0000);
-	slp_pin_gpio_resume(1);
-	slp_pin_gpio_resume(2);
-	slp_pin_gpio_resume(3);
-	slp_pin_gpio_resume(4);
-
-	#if 0
-	slp_regs_w_msk_resume(slp_grf_soc_con_data,(u32)RK_GRF_VIRT+0x60,5,slp_grf_soc_con_w_msk);
-	slp_regs_w_msk_resume(slp_grf_cpu_con_data,(u32)RK_GRF_VIRT+0x9c,5,slp_grf_cpu_con_w_msk);
-
-	slp_regs_w_msk_resume(slp_grf_uoc0_con_data,(u32)RK_GRF_VIRT+0xc4,4,slp_grf_uoc0_con_w_msk);
-	slp_regs_w_msk_resume(slp_grf_uoc1_con_data,(u32)RK_GRF_VIRT+0xd4,2,slp_grf_uoc1_con_w_msk);
-	slp_regs_w_msk_resume(slp_grf_uoc2_con_data,(u32)RK_GRF_VIRT+0xe4,2,slp_grf_uoc2_con_w_msk);
-	slp_regs_w_msk_resume(slp_grf_uoc3_con_data,(u32)RK_GRF_VIRT+0xec,2,slp_grf_uoc3_con_w_msk);
-	#endif
-	//sram_printch_uart_enable();
-	slp_uart_resume(2);
-       #endif
-}
-
-static void rkpm_save_setting(u32 ctrbits)
-{
-
-#if 0
-    rkpm_ddr_regs_dump(RK_DDR_VIRT,0,0x3fc);
-    rkpm_ddr_regs_dump(RK_DDR_VIRT+RK3288_DDR_PCTL_SIZE,0,0x294);
-
-    rkpm_ddr_regs_dump(RK_DDR_VIRT+RK3288_DDR_PCTL_SIZE+RK3288_DDR_PUBL_SIZE,0,0x3fc);
-    rkpm_ddr_regs_dump(RK_DDR_VIRT+RK3288_DDR_PCTL_SIZE*2+RK3288_DDR_PUBL_SIZE,0,0x294);
-#endif
-    rk3288_powermode=rkpm_slp_mode_set(ctrbits);
-    if(rk3288_powermode&BIT(pmu_pwr_mode_en))
-    {
-            sram_code_data_save(rk3288_powermode);   
-            rkpm_peri_save(rk3288_powermode);                
-    }
-    else
-         return ;
-
-}
-static void rkpm_save_setting_resume(void)
-{
-#ifdef CONFIG_ARM_ERRATA_821420
-	u32 v;
-
-	asm volatile("mrc p15, 0, %0, c15, c0, 2" : "=r" (v));
-	v |= 1 << 1;
-	asm volatile("mcr p15, 0, %0, c15, c0, 2" : : "r" (v));
-	isb();
-#endif
-
-        #if 0
-        rkpm_ddr_printascii("l2&arm_errata--");   
-        rkpm_ddr_printhex(rkpm_l2_config());             
-        rkpm_ddr_printhex(rkpm_armerrata_818325());
-        rkpm_ddr_printascii("\n");            
-        #endif
-                   
-         if(rk3288_powermode&BIT(pmu_pwr_mode_en))
-        {
-            sram_code_data_resume(rk3288_powermode); 
-            rkpm_peri_resume(rk3288_powermode);
-        }         
-         rkpm_slp_mode_set_resume();       
-
-}
-
-/*******************************common code  for rkxxx*********************************/
-static void  inline uart_printch(char byte)
-{
-        u32 reg_save[2];
-        u32 u_clk_id=(RK3288_CLKGATE_UART0_SRC+CONFIG_RK_DEBUG_UART*2);
-        u32 u_pclk_id=(RK3288_CLKGATE_PCLK_UART0+CONFIG_RK_DEBUG_UART);
-        
-        if(CONFIG_RK_DEBUG_UART==4)
-            u_clk_id=RK3288_CLKGATE_UART4_SRC;
-        if(CONFIG_RK_DEBUG_UART==2)
-            u_pclk_id=RK3288_CLKGATE_PCLK_UART2;
-            
-        reg_save[0]=cru_readl(RK3288_CRU_GATEID_CONS(u_clk_id));
-        reg_save[1]=cru_readl(RK3288_CRU_GATEID_CONS(u_pclk_id));
-        RK3288_CRU_UNGATING_OPS(u_clk_id);
-        RK3288_CRU_UNGATING_OPS(u_pclk_id);
-        
-        rkpm_udelay(1);
-        
-write_uart:
-	writel_relaxed(byte, RK_DEBUG_UART_VIRT);
-	dsb();
-
-	/* loop check LSR[6], Transmitter Empty bit */
-	while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-		barrier();
-    
-	if (byte == '\n') {
-		byte = '\r';
-		goto write_uart;
-	}
-
-         cru_writel(reg_save[0]|CRU_W_MSK(u_clk_id%16,0x1),RK3288_CRU_GATEID_CONS(u_clk_id));         
-         cru_writel(reg_save[1]|CRU_W_MSK(u_pclk_id%16,0x1),RK3288_CRU_GATEID_CONS(u_pclk_id));
-}
-
-void PIE_FUNC(sram_printch)(char byte)
-{
-	uart_printch(byte);
-}
-
-static void pll_udelay(u32 udelay);
-
-#ifdef CONFIG_RK_LAST_LOG
-extern void rk_last_log_text(char *text, size_t size);
-#endif
-
-static void  ddr_printch(char byte)
-{
-	uart_printch(byte);  
-    
-#ifdef CONFIG_RK_LAST_LOG
-	rk_last_log_text(&byte, 1);
-
-	if (byte == '\n') {
-		byte = '\r';
-		rk_last_log_text(&byte, 1);
-	}
-#endif
-        pll_udelay(2);
-}
-/*******************************gpio func*******************************************/
-//#define RK3288_PMU_GPIO0_A_IOMUX	0x0084
-//#define RK3288_PMU_GPIO0_B_IOMUX	0x0088
-//#define RK3288_PMU_GPIO0_C_IOMUX	0x008c
-//#define RK3288_PMU_GPIO0_D_IOMUX	0x0090
-//pin=0x0a21  gpio0a2,port=0,bank=a,b_gpio=2,fun=1
-static inline void pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun)
-{ 
-        u32 off_set;
-        bank-=0xa;
-    
-        if(port==0)
-        { 
-            if(bank>2)
-                return;
-            off_set=RK3288_PMU_GPIO0_A_IOMUX+bank*4;
-            pmu_writel(RKPM_VAL_SETBITS(pmu_readl(off_set),fun,b_gpio*2,0x3),off_set);
-        }
-        else if(port==1||port==2)
-        {
-            off_set=port*(4*4)+bank*4;
-            reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-        }
-        else if(port==3)
-        {
-            if(bank<=2)
-            {
-                off_set=0x20+bank*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-
-            }
-            else
-            {
-                off_set=0x2c+(b_gpio/4)*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,(b_gpio%4)*4,0x3),RK_GRF_VIRT+0+off_set);
-            }
-
-        }
-        else if(port==4)
-        {
-            if(bank<=1)
-            {
-                off_set=0x34+bank*8+(b_gpio/4)*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,(b_gpio%4)*4,0x3),RK_GRF_VIRT+0+off_set);
-            }
-            else
-            {
-                off_set=0x44+(bank-2)*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-            }
-
-        }
-        else if(port==5||port==6)
-        {
-                off_set=0x4c+(port-5)*4*4+bank*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-        }
-        else if(port==7)
-        {
-            if(bank<=1)
-            {
-                off_set=0x6c+bank*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-            }
-            else
-            {
-                off_set=0x74+(bank-2)*8+(b_gpio/4)*4;
-                //rkpm_ddr_printascii("gpio");
-                //rkpm_ddr_printhex(off_set);                   
-                //rkpm_ddr_printascii("-");
-                //rkpm_ddr_printhex((b_gpio%4)*4);
-
-                reg_writel(RKPM_W_MSK_SETBITS(fun,(b_gpio%4)*4,0x3),RK_GRF_VIRT+0+off_set);
-
-                //rkpm_ddr_printhex(reg_readl(RK_GRF_VIRT+0+off_set));    
-                //rkpm_ddr_printascii("\n");        
-            }
-
-        }
-        else if(port==8)
-        {
-            if(bank<=1)
-            {
-                off_set=0x80+bank*4;
-                reg_writel(RKPM_W_MSK_SETBITS(fun,b_gpio*2,0x3),RK_GRF_VIRT+0+off_set);
-            }
-        }
-               
-}
-
-#if 0
-static inline u8 pin_get_funset(u8 port,u8 bank,u8 b_gpio)
-{ 
-           
-}
-#endif
-static inline void pin_set_pull(u8 port,u8 bank,u8 b_gpio,u8 pull)
-{ 
-    u32 off_set;
-    
-    bank-=0xa;
-
-    if(port > 0)
-    {
-        //gpio1_d st
-        //if(port==1&&bank<3)
-       //  return;   
-        //gpio1_d==0x14c ,form gpio0_a to gpio1_d offset 1*16+3*4= 0x1c
-        off_set=(0x14c-0x1c)+port*(4*4)+bank*4;    
-
-        #if 0
-        rkpm_ddr_printascii("gpio pull\n");
-        rkpm_ddr_printhex((u32)RK_GPIO_VIRT(port));
-        rkpm_ddr_printhex(b_gpio);
-        rkpm_ddr_printhex(pull);
-        rkpm_ddr_printhex(off_set);
-        rkpm_ddr_printhex(RKPM_W_MSK_SETBITS(pull,b_gpio*2,0x3));
-        #endif
-        
-        reg_writel(RKPM_W_MSK_SETBITS(pull,b_gpio*2,0x3),RK_GRF_VIRT+off_set);
-
-    }
-    else
-    {
-        if(bank>2)// gpio0_d is not support
-            return; 
-        pmu_writel(RKPM_VAL_SETBITS(pmu_readl(0x64+bank*4),pull,b_gpio*2,0x3),0x64+bank*4);
-    }
-        
-}
-
-static inline u8 pin_get_pullset(u8 port,u8 bank,u8 b_gpio)
-{ 
-    u32 off_set;
-    
-    bank-=0xa;
-
-    if(port > 0)
-    {
-        //gpio1_d st
-        if(port==1&&bank<3)
-            return 0;   
-        //gpio1_d==0x14c ,form gpio0_a to gpio1_d offset 1*16+3*4= 0x1c
-        off_set=0x14c-0x1c+port*(4*4)+bank*4;    
-        return RKPM_GETBITS(reg_readl(RK_GRF_VIRT+off_set),b_gpio*2,0x3);
-
-    }
-    else
-    {
-        if(bank>2)// gpio0_d is not support
-            return 0;         
-        return RKPM_GETBITS(pmu_readl(0x64+bank*4),b_gpio*2,0x3);
-    }
-        
-}
-
-
-//RKPM_GPIOS_INPUT
-static inline void gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type)
-{
-    u32 val;    
-    
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;//
-
-    val=reg_readl(RK_GPIO_VIRT(port)+GPIO_SWPORT_DDR);
-
-    if(type==RKPM_GPIO_OUTPUT)
-        val|=(0x1<<b_gpio);
-    else
-        val&=~(0x1<<b_gpio);
-    #if 0
-    rkpm_ddr_printascii("gpio out\n");
-    rkpm_ddr_printhex((u32)RK_GPIO_VIRT(port));
-    rkpm_ddr_printhex(b_gpio);
-
-    rkpm_ddr_printhex(type);
-    rkpm_ddr_printhex(val);
-    #endif
-    reg_writel(val,RK_GPIO_VIRT(port)+GPIO_SWPORT_DDR);
-
-    //rkpm_ddr_printhex(reg_readl(RK_GPIO_VIRT(port)+GPIO_SWPORT_DDR));
-
-    
-}
-
-static inline u8 gpio_get_in_outputset(u8 port,u8 bank,u8 b_gpio)
-{
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;
-    return reg_readl(RK_GPIO_VIRT(port)+GPIO_SWPORT_DDR)&(0x1<<b_gpio);
-}
-
-//RKPM_GPIOS_OUT_L   RKPM_GPIOS_OUT_H
-static inline void gpio_set_output_level(u8 port,u8 bank,u8 b_gpio,u8 level)
-{
-    u32 val;    
-
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;
-        
-    val=reg_readl(RK_GPIO_VIRT(port)+GPIO_SWPORT_DR);
-
-    if(level==RKPM_GPIO_OUT_H)
-        val|=(0x1<<b_gpio);
-    else //
-        val&=~(0x1<<b_gpio);
-
-     reg_writel(val,RK_GPIO_VIRT(port)+GPIO_SWPORT_DR);
-}
-
-static inline u8 gpio_get_output_levelset(u8 port,u8 bank,u8 b_gpio)
-{     
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;
-    return reg_readl(RK_GPIO_VIRT(port)+GPIO_SWPORT_DR)&(0x1<<b_gpio);
-}
-
-static inline u8 gpio_get_input_level(u8 port,u8 bank,u8 b_gpio)
-{
-
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;
-
-    return (reg_readl(RK_GPIO_VIRT(port)+GPIO_EXT_PORT)>>b_gpio)&0x1;
-}
-static inline void gpio_set_inten(u8 port,u8 bank,u8 b_gpio,u8 en)
-{
-    u32 val;    
-
-    bank-=0xa;
-    b_gpio=bank*8+b_gpio;
-        
-    val=reg_readl(RK_GPIO_VIRT(port)+GPIO_INTEN);
-    rkpm_ddr_printascii("\n inten:");
-    rkpm_ddr_printhex(val);
-    
-    rkpm_ddr_printascii("-");
-    if(en==1)
-        val|=(0x1<<b_gpio);
-    else //
-        val&=~(0x1<<b_gpio);
-
-    reg_writel(val,RK_GPIO_VIRT(port)+GPIO_INTEN);
-    dsb();
-     
-     rkpm_ddr_printhex(val);
-     rkpm_ddr_printascii("-");
-     
-     rkpm_ddr_printhex(reg_readl(RK_GPIO_VIRT(port)+GPIO_INTEN));
-    
-    rkpm_ddr_printascii("\n");
-
-     
-}
-#if 0
-static void __sramfunc sram_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun)
-{ 
-        pin_set_fun(port,bank,b_gpio,fun); 
-}
-static u8 __sramfunc sram_pin_get_funset(u8 port,u8 bank,u8 b_gpio)
-{ 
-    return pin_get_funset(port,bank,b_gpio); 
-}
-
-static void __sramfunc sram_pin_set_pull(u8 port,u8 bank,u8 b_gpio,u8 fun)
-{ 
-        pin_set_pull(port,bank,b_gpio,fun); 
-}
-static u8 __sramfunc sram_pin_get_pullset(u8 port,u8 bank,u8 b_gpio)
-{ 
-    return pin_get_pullset(port,bank,b_gpio); 
-}
-
-static void __sramfunc sram_gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type)
-{
-    gpio_set_in_output(port,bank,b_gpio,type);
-}
-
-static u8 __sramfunc sram_gpio_get_in_outputset(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_in_outputset(port,bank,b_gpio);
-}
-
-static void __sramfunc sram_gpio_set_output_level(u8 port,u8 bank,u8 b_gpio,u8 level)
-{
-    
-    gpio_set_output_level(port,bank,b_gpio,level);
-
-}
-
-static u8 __sramfunc sram_gpio_get_output_levelset(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_output_levelset(port,bank,b_gpio);
-}
-#endif
-#if 0
-static u8 __sramfunc sram_gpio_get_input_level(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_input_level(port,bank,b_gpio);
-}
-#endif
-//ddr
-static void ddr_pin_set_fun(u8 port,u8 bank,u8 b_gpio,u8 fun)
-{ 
-        pin_set_fun(port,bank,b_gpio,fun); 
-}
-#if 0
-static u8 ddr_pin_get_funset(u8 port,u8 bank,u8 b_gpio)
-{ 
-    return pin_get_funset(port,bank,b_gpio); 
-}
-static u8 ddr_pin_get_pullset(u8 port,u8 bank,u8 b_gpio)
-{ 
-    return pin_get_pullset(port,bank,b_gpio); 
-}
-static u8 ddr_gpio_get_in_outputset(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_in_outputset(port,bank,b_gpio);
-}
-
-static u8 ddr_gpio_get_output_levelset(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_output_levelset(port,bank,b_gpio);
-}
-static u8 ddr_gpio_get_input_level(u8 port,u8 bank,u8 b_gpio)
-{
-    return gpio_get_input_level(port,bank,b_gpio);
-}
-
-
-#endif
-
-
-static void ddr_pin_set_pull(u8 port,u8 bank,u8 b_gpio,u8 fun)
-{ 
-        pin_set_pull(port,bank,b_gpio,fun); 
-}
-
-static void ddr_gpio_set_in_output(u8 port,u8 bank,u8 b_gpio,u8 type)
-{
-    gpio_set_in_output(port,bank,b_gpio,type);
-}
-static void ddr_gpio_set_output_level(u8 port,u8 bank,u8 b_gpio,u8 level)
-{   
-    gpio_set_output_level(port,bank,b_gpio,level);
-}
-
-
-
-#define GPIO_DTS_NUM (20)
-static  u32 suspend_gpios[GPIO_DTS_NUM];
-static  u32 resume_gpios[GPIO_DTS_NUM];
-
-static int of_find_property_value_getsize(const struct device_node *np,const char *propname)
-{
-	struct property *prop = of_find_property(np, propname, NULL);
-
-	if (!prop)
-		return 0;
-	if (!prop->value)
-		return 0;
-	return prop->length;
-}
-
-static  void rkpm_pin_gpio_config(u32 pin_gpio_bits)
-{
-    
-    u32 pins;
-    u8 port,bank,b_gpio,fun,in_out, level, pull;
-   
-    pins=RKPM_PINGPIO_BITS_PIN(pin_gpio_bits);      
-    in_out=RKPM_PINGPIO_BITS_INOUT(pin_gpio_bits);       
-    pull=RKPM_PINGPIO_BITS_PULL(pin_gpio_bits);          
-    level=RKPM_PINGPIO_BITS_LEVEL(pin_gpio_bits);     
-
-    port=RKPM_PINBITS_PORT(pins);
-    bank=RKPM_PINBITS_BANK(pins);
-    b_gpio=RKPM_PINBITS_BGPIO(pins);
-    fun=RKPM_PINBITS_FUN(pins);
-    
-  
-    if(!fun)
-   {
-        if(in_out==RKPM_GPIO_OUTPUT)
-        {
-            if(level==RKPM_GPIO_OUT_L)
-                pull=RKPM_GPIO_PULL_DN;
-            else
-                pull=RKPM_GPIO_PULL_UP;
-            
-            ddr_gpio_set_output_level(port,bank,b_gpio,level);       
-        }            
-        //rkpm_ddr_printhex(pins);
-
-        ddr_gpio_set_in_output(port,bank,b_gpio,in_out);
-    }
-
-    ddr_pin_set_pull(port,bank,b_gpio,pull);                
-    ddr_pin_set_fun(port,bank,b_gpio,fun);
-    
-   
-    
-}
-
-#define RKPM_PINGPIO_BITS_PINTOPORT(pin_gpio_bits) RKPM_PINBITS_PORT(RKPM_PINGPIO_BITS_PIN((pin_gpio_bits)))
-#define  rkpm_gpio_pclk_idx(port) ((port)==0) ? RK3288_CLKGATE_PCLK_GPIO0 : (RK3288_CLKGATE_PCLK_GPIO1+(port)-1)
-
-//rk3288_powermode
-static void rkpm_pins_setting(u32 *gpios,u32 cnt)
-{
-       u32 i,clk_id; 
-       u32 gpio_clk_reg[9];
-       u8 port;
-       
-      // rkpm_ddr_printascii("\ngpios");
-       
-        for(i=0;i<9;i++)
-        {
-            gpio_clk_reg[i]=0xffff0000;
-        }
-       
-       for(i=0;i<cnt;i++)
-       {
-            if(gpios[i]!=0)
-           {
-                port=RKPM_PINGPIO_BITS_PINTOPORT(gpios[i]);
-                if(gpio_clk_reg[port]==0xffff0000)
-                {
-                    clk_id=rkpm_gpio_pclk_idx(port);
-                    gpio_clk_reg[port]=cru_readl(RK3288_CRU_GATEID_CONS(clk_id))&0xffff;
-                    RK3288_CRU_UNGATING_OPS(clk_id);
-                }
-               // rkpm_ddr_printhex(gpios[i]);
-                rkpm_pin_gpio_config(gpios[i]);
-           }           
-       }
-      // rkpm_ddr_printascii("\n");
-       
- #if 0       
-        for(i=0;i<9;i++)
-       {
-           rkpm_ddr_regs_dump(RK_GPIO_VIRT(i),0,0x4); 
-       }
-       //
-       rkpm_ddr_regs_dump(RK_GRF_VIRT,0xc,0x84); 
-       rkpm_ddr_regs_dump(RK_GRF_VIRT,0x14c,0x1b4);     
-     //  rkpm_ddr_regs_dump(RK_PMU_VIRT,0x64,0x6c);   
-       //rkpm_ddr_regs_dump(RK_PMU_VIRT,0x84,0x9c); 
-   #endif
-   
-        for(i=0;i<9;i++)
-       {
-            if(gpio_clk_reg[i]!=0xffff0000)
-            {          
-                clk_id=rkpm_gpio_pclk_idx(i);           
-                cru_writel(gpio_clk_reg[i]|CRU_W_MSK(clk_id%16,0x1),RK3288_CRU_GATEID_CONS(clk_id));    
-            }
-       }
-       
-}
-
-static void  rkpm_gpio_suspend(void)
-{
-    rkpm_pins_setting(&suspend_gpios[0],GPIO_DTS_NUM);
-}
-
-
-
-static void  rkpm_gpio_resume(void)
-{     
-     rkpm_pins_setting(&resume_gpios[0],GPIO_DTS_NUM);
-}
-
-#if 1
-static void gpio_get_dts_info(struct device_node *parent)
-{
-        int i;
-        size_t temp_len;
-    //return;
-
-        for(i=0;i<GPIO_DTS_NUM;i++)
-        {
-            suspend_gpios[i]=0;
-            resume_gpios[i]=0;
-        }
- 
-     #if 1   
-        temp_len=of_find_property_value_getsize(parent,"rockchip,pmic-suspend_gpios");
-        if(temp_len)
-        {
-            printk("%s suspend:%d\n",__FUNCTION__,temp_len);
-            if(temp_len)
-            {
-                if(of_property_read_u32_array(parent,"rockchip,pmic-suspend_gpios",&suspend_gpios[0],temp_len/4))
-                {
-                        suspend_gpios[0]=0;
-                       printk("%s:get pm ctr error\n",__FUNCTION__);
-                }
-            }
-        }
-
-       temp_len=of_find_property_value_getsize(parent,"rockchip,pmic-resume_gpios");
-       if(temp_len)
-       {
-           printk("%s resume:%d\n",__FUNCTION__,temp_len);
-           if(of_property_read_u32_array(parent,"rockchip,pmic-resume_gpios",&resume_gpios[0],temp_len/4))
-           {
-                    resume_gpios[0]=0;
-                   printk("%s:get pm ctr error\n",__FUNCTION__);
-           }
-        }  
-     #endif
-     
-     printk("rockchip,pmic-suspend_gpios:");
-     for(i=0;i<GPIO_DTS_NUM;i++)
-     {
-         printk("%x ",suspend_gpios[i]);
-         if(i==(GPIO_DTS_NUM-1))
-             printk("\n");
-     }
- 
-     printk("rockchip,pmic-resume_gpios:");
-     for(i=0;i<GPIO_DTS_NUM;i++)
-     {
-          printk("%x ",resume_gpios[i]);
-          if(i==(GPIO_DTS_NUM-1))
-              printk("\n");
-     }
-     
-   rkpm_set_ops_gpios(rkpm_gpio_suspend,rkpm_gpio_resume);
-
-}
-#endif
-
-/*******************************clk gating config*******************************************/
-#define CLK_MSK_GATING(msk, con) cru_writel((msk << 16) | 0xffff, con)
-#define CLK_MSK_UNGATING(msk, con) cru_writel(((~msk) << 16) | 0xffff, con)
-
-
-static u32 clk_ungt_msk[RK3288_CRU_CLKGATES_CON_CNT];// first clk gating setting
-static u32 clk_ungt_msk_1[RK3288_CRU_CLKGATES_CON_CNT];// first clk gating setting
-static u32 clk_ungt_save[RK3288_CRU_CLKGATES_CON_CNT]; //first clk gating value saveing
-
-
-u32 DEFINE_PIE_DATA(rkpm_clkgt_last_set[RK3288_CRU_CLKGATES_CON_CNT]);
-static u32 *p_rkpm_clkgt_last_set;
-
-static __sramdata u32 rkpm_clkgt_last_save[RK3288_CRU_CLKGATES_CON_CNT];
-
-void PIE_FUNC(gtclks_sram_suspend)(void)
-{
-    int i;
-   // u32 u_clk_id=(RK3188_CLKGATE_UART0_SRC+CONFIG_RK_DEBUG_UART);
-   // u32 u_pclk_id=(RK3188_CLKGATE_PCLK_UART0+CONFIG_RK_DEBUG_UART);
-
-    for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
-    {
-        rkpm_clkgt_last_save[i]=cru_readl(RK3288_CRU_CLKGATES_CON(i));     
-        CLK_MSK_UNGATING( DATA(rkpm_clkgt_last_set[i]), RK3288_CRU_CLKGATES_CON(i));      
-        #if 0
-        rkpm_sram_printch('\n');   
-        rkpm_sram_printhex(DATA(rkpm_clkgt_last_save[i]));
-        rkpm_sram_printch('-');   
-        rkpm_sram_printhex(DATA(rkpm_clkgt_last_set[i]));
-        rkpm_sram_printch('-');   
-        rkpm_sram_printhex(cru_readl(RK3188_CRU_CLKGATES_CON(i)));
-        if(i==(RK3288_CRU_CLKGATES_CON_CNT-1))         
-        rkpm_sram_printch('\n');   
-        #endif
-    }
-    
-        //RK3288_CRU_UNGATING_OPS(u_clk_id);
-        //RK3288_CRU_UNGATING_OPS(u_pclk_id);
- 
-}
-
-void PIE_FUNC(gtclks_sram_resume)(void)
-{
-    int i;
-    for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
-    {
-        cru_writel(rkpm_clkgt_last_save[i]|0xffff0000, RK3288_CRU_CLKGATES_CON(i));
-    }
-}
-#define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT + offset)
-#define grf_writel(v, offset)	do { writel_relaxed(v, RK_GRF_VIRT + offset); dsb(); } while (0)
-
-#define gpio7_readl(offset)	readl_relaxed(RK_GPIO_VIRT(7)+ offset)
-#define gpio7_writel(v, offset)	do { writel_relaxed(v, RK_GPIO_VIRT(7) + offset); dsb(); } while (0)
-
-int gpio7_pin_data1, gpio7_pin_dir1;
-int gpio7_pin_iomux1;
-
-static void gtclks_suspend(void)
-{
-	int i;
-
-	gpio7_pin_data1= gpio7_readl(0);
-	gpio7_pin_dir1 = gpio7_readl(0x04);
-	gpio7_pin_iomux1 =  gpio7_readl(0x6c);
-	grf_writel(0x00040000, 0x6c);
-	gpio7_writel(gpio7_pin_dir1|0x2, 0x04);
-	gpio7_writel((gpio7_pin_data1|2), 0x00);
-
-  // rkpm_ddr_regs_dump(RK_CRU_VIRT,RK3288_CRU_CLKGATES_CON(0)
-                                          //          ,RK3288_CRU_CLKGATES_CON(RK3288_CRU_CLKGATES_CON_CNT-1));
-
-    for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
-    {
-            clk_ungt_save[i]=cru_readl(RK3288_CRU_CLKGATES_CON(i));   
-           // 160 1a8
-           #if 0
-           if(
-               // RK3288_CRU_CLKGATES_CON(i)==0x160 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x164 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x168 ||
-              //  RK3288_CRU_CLKGATES_CON(i)==0x16c ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x170 ||
-               // RK3288_CRU_CLKGATES_CON(i)==0x174 ||
-               // RK3288_CRU_CLKGATES_CON(i)==0x178 ||
-
-           
-                //RK3288_CRU_CLKGATES_CON(i)==0x17c ||
-               // RK3288_CRU_CLKGATES_CON(i)==0x180 ||
-               // RK3288_CRU_CLKGATES_CON(i)==0x184 ||
-               // RK3288_CRU_CLKGATES_CON(i)==0x188 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x18c ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x190 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x194 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x198 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x19c ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x1a0 ||
-                //RK3288_CRU_CLKGATES_CON(i)==0x1a4 ||      
-               // RK3288_CRU_CLKGATES_CON(i)==0x1a8
-               RK3288_CRU_CLKGATES_CON(i)==0xfff
-            )
-            {
-            
-                 cru_writel(0xffff0000, RK3288_CRU_CLKGATES_CON(i));
-               // CLK_MSK_UNGATING(clk_ungt_msk[i],RK3288_CRU_CLKGATES_CON(i));
-            
-            }
-           else
-            #endif
-            {
-               // if(RK3288_CRU_CLKGATES_CON(i)!=0x188 )
-               CLK_MSK_UNGATING(clk_ungt_msk[i],RK3288_CRU_CLKGATES_CON(i));
-           }
-           #if 0
-            rkpm_ddr_printch('\n');   
-            rkpm_ddr_printhex(RK3288_CRU_CLKGATES_CON(i));
-            rkpm_ddr_printch('-');   
-            rkpm_ddr_printhex(clk_ungt_msk[i]);
-            rkpm_ddr_printch('-');   
-            rkpm_ddr_printhex(cru_readl(RK3288_CRU_CLKGATES_CON(i))) ;  
-            if(i==(RK3288_CRU_CLKGATES_CON_CNT-1))            
-            rkpm_ddr_printch('\n');   
-            #endif
-    }
-
-}
-
-static void gtclks_resume(void)
-{
-    int i;
-     for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
-    {
-       cru_writel(clk_ungt_save[i]|0xffff0000,RK3288_CRU_CLKGATES_CON(i));       
-     }
-     //rkpm_ddr_regs_dump(RK_CRU_VIRT,RK3288_CRU_CLKGATES_CON(0)
-                                                 //   ,RK3288_CRU_CLKGATES_CON(RK3288_CRU_CLKGATES_CON_CNT-1));
-	grf_writel(0x00040004, 0x6c);
-}
-/********************************pll power down***************************************/
-
-static void pm_pll_wait_lock(u32 pll_idx)
-{
-	u32 delay = 600000U;
-       // u32 mode;
-     //  mode=cru_readl(RK3288_CRU_MODE_CON);
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	while (delay > 0) {
-		if ((cru_readl(RK3288_PLL_CONS(pll_idx,1))&(0x1<<31)))
-			break;
-		delay--;
-	}
-	if (delay == 0) {
-		rkpm_ddr_printascii("unlock-pll:");
-		rkpm_ddr_printhex(pll_idx);
-		rkpm_ddr_printch('\n');
-	}
-    //cru_writel(mode|(RK3288_PLL_MODE_MSK(pll_idx)<<16), RK3288_CRU_MODE_CON);
-}	
-
-static void pll_udelay(u32 udelay)
-{
-    u32 mode;
-    mode=cru_readl(RK3288_CRU_MODE_CON);
-    // delay in 24m
-    cru_writel(RK3288_PLL_MODE_SLOW(APLL_ID), RK3288_CRU_MODE_CON);
-    
-    rkpm_udelay(udelay*5);
-    
-    cru_writel(mode|(RK3288_PLL_MODE_MSK(APLL_ID)<<16), RK3288_CRU_MODE_CON);
-}
-
-static u32 plls_con0_save[END_PLL_ID];
-static u32 plls_con1_save[END_PLL_ID];
-static u32 plls_con2_save[END_PLL_ID];
-static u32 plls_con3_save[END_PLL_ID];
-
-static u32 cru_mode_con;
-
-static inline void plls_suspend(u32 pll_id)
-{
-    plls_con0_save[pll_id]=cru_readl(RK3288_PLL_CONS((pll_id), 0));
-    plls_con1_save[pll_id]=cru_readl(RK3288_PLL_CONS((pll_id), 1));
-    plls_con2_save[pll_id]=cru_readl(RK3288_PLL_CONS((pll_id), 2));
-    plls_con3_save[pll_id]=cru_readl(RK3288_PLL_CONS((pll_id), 3));
- 
-    cru_writel(RK3288_PLL_PWR_DN, RK3288_PLL_CONS((pll_id), 3));
-    
-}
-static inline void plls_resume_pre(u32 pll_id)
-{
-	u32 pllcon0, pllcon1, pllcon2;
-
-	cru_writel(RK3288_PLL_MODE_SLOW(pll_id), RK3288_CRU_MODE_CON);
-
-	cru_writel(RK3288_PLL_PWR_ON, RK3288_PLL_CONS((pll_id), 3));
-	cru_writel(RK3288_PLL_NO_BYPASS, RK3288_PLL_CONS((pll_id), 3));
-
-	pllcon0 = plls_con0_save[pll_id];
-	pllcon1 = plls_con1_save[pll_id];
-	pllcon2 = plls_con2_save[pll_id];
-
-	/*enter rest*/
-	cru_writel(RK3288_PLL_RESET, RK3288_PLL_CONS(pll_id, 3));
-	cru_writel(pllcon0 | CRU_W_MSK(0, 0xf) | CRU_W_MSK(8, 0x3f)
-		, RK3288_PLL_CONS(pll_id, 0));
-	cru_writel(pllcon1, RK3288_PLL_CONS(pll_id, 1));
-	cru_writel(pllcon2, RK3288_PLL_CONS(pll_id, 2));
-}
-
-static inline void plls_resume(void)
-{
-	plls_resume_pre(APLL_ID);
-	plls_resume_pre(GPLL_ID);
-	plls_resume_pre(CPLL_ID);
-	plls_resume_pre(NPLL_ID);
-
-	pll_udelay(5);
-
-	/*return form rest*/
-	cru_writel(RK3288_PLL_RESET_RESUME, RK3288_PLL_CONS(APLL_ID, 3));
-	cru_writel(RK3288_PLL_RESET_RESUME, RK3288_PLL_CONS(GPLL_ID, 3));
-	cru_writel(RK3288_PLL_RESET_RESUME, RK3288_PLL_CONS(CPLL_ID, 3));
-	cru_writel(RK3288_PLL_RESET_RESUME, RK3288_PLL_CONS(NPLL_ID, 3));
-
-	/*wating lock state*/
-	pll_udelay(168);
-
-	pm_pll_wait_lock(APLL_ID);
-	pm_pll_wait_lock(GPLL_ID);
-	pm_pll_wait_lock(CPLL_ID);
-	pm_pll_wait_lock(NPLL_ID);
-
-
-	cru_writel(plls_con3_save[APLL_ID] | (RK3288_PLL_BYPASS_MSK << 16)
-		, RK3288_PLL_CONS(APLL_ID, 3));
-	cru_writel(plls_con3_save[GPLL_ID] | (RK3288_PLL_BYPASS_MSK << 16)
-		, RK3288_PLL_CONS(GPLL_ID, 3));
-	cru_writel(plls_con3_save[CPLL_ID] | (RK3288_PLL_BYPASS_MSK << 16)
-		, RK3288_PLL_CONS(CPLL_ID, 3));
-	cru_writel(plls_con3_save[NPLL_ID] | (RK3288_PLL_BYPASS_MSK << 16)
-		, RK3288_PLL_CONS(NPLL_ID, 3));
-}
-
-static u32 clk_sel0,clk_sel1, clk_sel10,clk_sel26,clk_sel33,clk_sel36, clk_sel37;
-
-static void pm_plls_suspend(void)
-{
-
-   // rkpm_ddr_regs_dump(RK_CRU_VIRT,RK3288_PLL_CONS((0), 0),RK3288_PLL_CONS((4), 3)); 
-   // rkpm_ddr_regs_dump(RK_CRU_VIRT,RK3288_CRU_MODE_CON,RK3288_CRU_MODE_CON);   
-   // rkpm_ddr_regs_dump(RK_CRU_VIRT,RK3288_CRU_CLKSELS_CON(0),RK3288_CRU_CLKSELS_CON(42));
-    
-    clk_sel0=cru_readl(RK3288_CRU_CLKSELS_CON(0));
-    clk_sel1=cru_readl(RK3288_CRU_CLKSELS_CON(1));
-    clk_sel10=cru_readl(RK3288_CRU_CLKSELS_CON(10));
-    clk_sel26=cru_readl(RK3288_CRU_CLKSELS_CON(26));    
-    clk_sel33=cru_readl(RK3288_CRU_CLKSELS_CON(33));
-    clk_sel36=cru_readl(RK3288_CRU_CLKSELS_CON(36));
-    clk_sel37=cru_readl(RK3288_CRU_CLKSELS_CON(37));
-    
-    cru_mode_con = cru_readl(RK3288_CRU_MODE_CON);
-
-
-    cru_writel(RK3288_PLL_MODE_SLOW(NPLL_ID), RK3288_CRU_MODE_CON);  
-    plls_suspend(NPLL_ID);
-    
-// cpll
-    cru_writel(RK3288_PLL_MODE_SLOW(CPLL_ID), RK3288_CRU_MODE_CON);
-  
-// gpll 
-    cru_writel(RK3288_PLL_MODE_SLOW(GPLL_ID), RK3288_CRU_MODE_CON); 
-
-    // set 1,pdbus pll is gpll
-    cru_writel(CRU_W_MSK_SETBITS(1,15,0x1), RK3288_CRU_CLKSELS_CON(1)); // 0 cpll 1gpll
-
-    // pd_bus clk 
-    cru_writel(0
-                        |CRU_W_MSK_SETBITS(0,0,0x7)  //  1  aclk
-                        |CRU_W_MSK_SETBITS(0,3,0x1f) //  1   aclk src
-                        |CRU_W_MSK_SETBITS(0,8,0x3) // 1   hclk 0~1 1 2 4
-                        |CRU_W_MSK_SETBITS(0,12,0x7) //  3   pclk
-                     , RK3288_CRU_CLKSELS_CON(1));
-    
-    //crypto for pd_bus
-    cru_writel(CRU_W_MSK_SETBITS(3,6,0x3), RK3288_CRU_CLKSELS_CON(26));
-
-    // peri aclk hclk pclk
-    cru_writel(0
-                        |CRU_W_MSK_SETBITS(0,0,0x1f) // 1 aclk
-                        |CRU_W_MSK_SETBITS(0,8,0x3) // 2   hclk 0 1:1,1 2:1 ,2 4:1
-                        |CRU_W_MSK_SETBITS(0,12,0x3)// 2     0~3  1 2 4 8 div
-                        , RK3288_CRU_CLKSELS_CON(10));
-    // pmu alive 
-    cru_writel(CRU_W_MSK_SETBITS(0,0,0x1f)|CRU_W_MSK_SETBITS(0,8,0x1f), RK3288_CRU_CLKSELS_CON(33));
-
-    plls_suspend(CPLL_ID);
-    plls_suspend(GPLL_ID);
-
-//apll 
-   cru_writel(RK3288_PLL_MODE_SLOW(APLL_ID), RK3288_CRU_MODE_CON);
-     // core_m0 core_mp a12_core
-    cru_writel(0
-                        |CRU_W_MSK_SETBITS(0,0,0xf) // 1   axi_mo
-                        |CRU_W_MSK_SETBITS(0,4,0xf) // 3  axi mp
-                        |CRU_W_MSK_SETBITS(0,8,0x1f) // 0 a12 core div
-                      , RK3288_CRU_CLKSELS_CON(0));
-    // core0 core1 core2 core3
-    cru_writel(0
-                        |CRU_W_MSK_SETBITS(0,0,0x7) //core 0 div
-                        |CRU_W_MSK_SETBITS(0,4,0x7) // core 1
-                        |CRU_W_MSK_SETBITS(0,8,0x7) // core2
-                        |CRU_W_MSK_SETBITS(0,12,0x7)//core3
-                      , RK3288_CRU_CLKSELS_CON(36));
-    // l2ram atclk pclk
-    #if 1
-    cru_writel(0
-                    |CRU_W_MSK_SETBITS(3,0,0x7) // l2ram
-                    |CRU_W_MSK_SETBITS(0xf,4,0x1f) // atclk
-                     |CRU_W_MSK_SETBITS(0xf,9,0x1f) // pclk dbg
-                     , RK3288_CRU_CLKSELS_CON(37));
-    #else
-    cru_writel(0
-                      |CRU_W_MSK_SETBITS(0,0,0x7) // l2ram
-                      |CRU_W_MSK_SETBITS(0x2,4,0x1f) // atclk
-                       |CRU_W_MSK_SETBITS(0x2,9,0x1f) // pclk dbg
-                       , RK3288_CRU_CLKSELS_CON(37));
-    #endif
-
-    
-    plls_suspend(APLL_ID);
-
-}
-
-static void pm_plls_resume(void)
-{
-	/* core_m0 core_mp a12_core*/
-	cru_writel(clk_sel0 | (CRU_W_MSK(0, 0xf) | CRU_W_MSK(4, 0xf)
-	| CRU_W_MSK(8, 0xf)), RK3288_CRU_CLKSELS_CON(0));
-	/*core0 core1 core2 core3*/
-	cru_writel(clk_sel36 | (CRU_W_MSK(0, 0x7) | CRU_W_MSK(4, 0x7)
-	| CRU_W_MSK(8, 0x7) | CRU_W_MSK(12, 0x7)), RK3288_CRU_CLKSELS_CON(36));
-	/* l2ram atclk pclk*/
-	cru_writel(clk_sel37 | (CRU_W_MSK(0, 0x7) | CRU_W_MSK(4, 0x1f)
-	| CRU_W_MSK(9, 0x1f)), RK3288_CRU_CLKSELS_CON(37));
-
-	/*resume APLL_ID GPLL_ID CPLL_ID NPLL_ID*/
-	plls_resume();
-
-	cru_writel(cru_mode_con | (RK3288_PLL_MODE_MSK(APLL_ID) << 16)
-		, RK3288_CRU_MODE_CON);
-
-	/*peri aclk hclk pclk*/
-	cru_writel(clk_sel10 | (CRU_W_MSK(0, 0x1f) | CRU_W_MSK(8, 0x3)
-	| CRU_W_MSK(12, 0x3)), RK3288_CRU_CLKSELS_CON(10));
-	/*pd bus gpll sel*/
-	cru_writel(clk_sel1 | CRU_W_MSK(15, 0x1), RK3288_CRU_CLKSELS_CON(1));
-	/*pd_bus clk 8*/
-	cru_writel(clk_sel1 | (CRU_W_MSK(0, 0x7) | CRU_W_MSK(3, 0x1f)
-	| CRU_W_MSK(8, 0x3) | CRU_W_MSK(12, 0x7)), RK3288_CRU_CLKSELS_CON(1));
-
-	/*crypto*/
-	cru_writel(clk_sel26 | CRU_W_MSK(6, 0x3), RK3288_CRU_CLKSELS_CON(26));
-
-	/*pmu alive */
-	cru_writel(clk_sel33 | CRU_W_MSK(0, 0x1f) | CRU_W_MSK(8, 0x1f)
-	, RK3288_CRU_CLKSELS_CON(33));
-	cru_writel(cru_mode_con | (RK3288_PLL_MODE_MSK(GPLL_ID) << 16)
-		, RK3288_CRU_MODE_CON);
-	cru_writel(cru_mode_con | (RK3288_PLL_MODE_MSK(CPLL_ID) << 16)
-		, RK3288_CRU_MODE_CON);
-	cru_writel(cru_mode_con | (RK3288_PLL_MODE_MSK(NPLL_ID) << 16)
-		, RK3288_CRU_MODE_CON);
-
-}
-
-static __sramdata u32  sysclk_clksel0_con,sysclk_clksel1_con,sysclk_clksel10_con,sysclk_mode_con;
-
-void PIE_FUNC(sysclk_suspend)(u32 sel_clk)
-{
-
-    int div;  
-    sysclk_clksel0_con = cru_readl(RK3288_CRU_CLKSELS_CON(0));
-    sysclk_clksel1_con = cru_readl(RK3288_CRU_CLKSELS_CON(1));
-    sysclk_clksel10_con= cru_readl(RK3288_CRU_CLKSELS_CON(10));
-
-
-    if(sel_clk&(RKPM_CTR_SYSCLK_32K))
-    {
-        div=3;
-        sysclk_mode_con= cru_readl(RK3288_CRU_MODE_CON);
-        cru_writel(0
-                |RK3288_PLL_MODE_DEEP(APLL_ID)| RK3288_PLL_MODE_DEEP(CPLL_ID)
-                | RK3288_PLL_MODE_DEEP(GPLL_ID)|RK3288_PLL_MODE_DEEP(NPLL_ID)
-                            , RK3288_CRU_MODE_CON);
-    }
-    else if(sel_clk&(RKPM_CTR_SYSCLK_DIV))
-    {      
-        div=31;
-    }
-
-    cru_writel(CRU_W_MSK_SETBITS(div,8,0x1f), RK3188_CRU_CLKSELS_CON(0)); //pd core
-    cru_writel(CRU_W_MSK_SETBITS(div,3,0x1f), RK3188_CRU_CLKSELS_CON(1));//pd bus
-    cru_writel(CRU_W_MSK_SETBITS(div,0,0x1f), RK3188_CRU_CLKSELS_CON(10));//pd peri
-    
-}
-
-void PIE_FUNC(sysclk_resume)(u32 sel_clk)
-{
-    
-    cru_writel(sysclk_clksel0_con|CRU_W_MSK(8,0x1f), RK3188_CRU_CLKSELS_CON(0)); //pd core
-    cru_writel(sysclk_clksel1_con|CRU_W_MSK(3,0x1f), RK3188_CRU_CLKSELS_CON(1));//pd bus
-    cru_writel(sysclk_clksel10_con|CRU_W_MSK(0,0x1f), RK3188_CRU_CLKSELS_CON(10));//pd peri
-    cru_writel(sysclk_mode_con|(RK3288_PLL_MODE_MSK(APLL_ID)<<16)
-                            |(RK3288_PLL_MODE_MSK(CPLL_ID)<<16)
-                            |(RK3288_PLL_MODE_MSK(GPLL_ID)<<16)
-                            |(RK3288_PLL_MODE_MSK(NPLL_ID)<<16), RK3288_CRU_MODE_CON);
-
-}
-
-
-static void clks_gating_suspend_init(void)
-{
-    // get clk gating info
-    if(rockchip_pie_chunk)
-        p_rkpm_clkgt_last_set= kern_to_pie(rockchip_pie_chunk, &DATA(rkpm_clkgt_last_set[0]));
-    else
-        p_rkpm_clkgt_last_set=&clk_ungt_msk_1[0];
-    if(clk_suspend_clkgt_info_get(clk_ungt_msk,p_rkpm_clkgt_last_set, RK3288_CRU_CLKGATES_CON_CNT) 
-        ==RK3288_CRU_CLKGATES_CON(0))
-    {
-        rkpm_set_ops_gtclks(gtclks_suspend,gtclks_resume);
-        if(rockchip_pie_chunk)
-            rkpm_set_sram_ops_gtclks(fn_to_pie(rockchip_pie_chunk, &FUNC(gtclks_sram_suspend)), 
-                                fn_to_pie(rockchip_pie_chunk, &FUNC(gtclks_sram_resume)));
-        
-        PM_LOG("%s:clkgt info ok\n",__FUNCTION__);
-
-    }
-    if(rockchip_pie_chunk)
-        rkpm_set_sram_ops_sysclk(fn_to_pie(rockchip_pie_chunk, &FUNC(sysclk_suspend))
-                                                ,fn_to_pie(rockchip_pie_chunk, &FUNC(sysclk_resume))); 
-}
-
-/***************************prepare and finish reg_pread***********************************/
-
-
-
-#define GIC_DIST_PENDING_SET		0x200
-static noinline void rk3288_pm_dump_irq(void)
-{
-	u32 irq_gpio = (readl_relaxed(RK_GIC_VIRT + GIC_DIST_PENDING_SET + 12) >> 17) & 0x1FF;
-	u32 irq[4];
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(irq); i++)
-		irq[i] = readl_relaxed(RK_GIC_VIRT + GIC_DIST_PENDING_SET + (1 + i) * 4);
-	for (i = 0; i < ARRAY_SIZE(irq); i++) {
-		if (irq[i])
-			log_wakeup_reason(32 * (i + 1) + fls(irq[i]) - 1);
-	}
-	printk("wakeup irq: %08x %08x %08x %08x\n", irq[0], irq[1], irq[2], irq[3]);
-	for (i = 0; i <= 8; i++) {
-		if (irq_gpio & (1 << i))
-			printk("wakeup gpio%d: %08x\n", i, readl_relaxed(RK_GPIO_VIRT(i) + GPIO_INT_STATUS));
-	}
-}
-
-#if 0
-#define DUMP_GPIO_INTEN(ID) \
-do { \
-	u32 en = readl_relaxed(RK_GPIO_VIRT(ID) + GPIO_INTEN); \
-	if (en) { \
-		rkpm_ddr_printascii("GPIO" #ID "_INTEN: "); \
-		rkpm_ddr_printhex(en); \
-		rkpm_ddr_printch('\n'); \
-		printk(KERN_DEBUG "GPIO%d_INTEN: %08x\n", ID, en); \
-	} \
-} while (0)
-#else
-
-#define DUMP_GPIO_INTEN(ID) \
-    do { \
-    	u32 en = readl_relaxed(RK_GPIO_VIRT(ID) + GPIO_INTEN); \
-    	if (en) { \
-    		printk("GPIO%d_INTEN: %08x\n", ID, en); \
-    	} \
-    } while (0)
-
-#endif
-
-
-//dump while irq is enable
-static noinline void rk3288_pm_dump_inten(void)
-{
-	DUMP_GPIO_INTEN(0);
-	DUMP_GPIO_INTEN(1);
-	DUMP_GPIO_INTEN(2);
-	DUMP_GPIO_INTEN(3);
-    	DUMP_GPIO_INTEN(4);
-	DUMP_GPIO_INTEN(5);
-	DUMP_GPIO_INTEN(6);
-	DUMP_GPIO_INTEN(7);    
-	DUMP_GPIO_INTEN(8);
-}
-
-static  void rkpm_prepare(void)
-{   
-
-        int i;
-         for(i=0;i<RK3288_CRU_CLKGATES_CON_CNT;i++)
-        {
-           //cru_writel(0xffff0000,RK3288_CRU_CLKGATES_CON(i));       
-         }
-
-        #if 0
-        u32 temp =reg_readl(RK_GPIO_VIRT(0)+0x30);
-
-       // rkpm_ddr_printhex(temp);
-        reg_writel(temp|0x1<<4,RK_GPIO_VIRT(0)+0x30);
-        temp =reg_readl(RK_GPIO_VIRT(0)+0x30);
-       // rkpm_ddr_printhex(temp);
-        #endif             
-	// dump GPIO INTEN for debug
-	rk3288_pm_dump_inten();
-}
-
-static void rkpm_finish(void)
-{
-	rk3288_pm_dump_irq();
-}
-
-#if 0
-static  void interface_ctr_reg_pread(void)
-{
-	//u32 addr;
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
-        #if 0  // do it in ddr suspend 
-	for (addr = (u32)SRAM_CODE_OFFSET; addr < (u32)(SRAM_CODE_OFFSET+rockchip_sram_size); addr += PAGE_SIZE)
-		readl_relaxed(addr);
-        #endif
-        readl_relaxed(RK_PMU_VIRT);
-        readl_relaxed(RK_GRF_VIRT);
-        readl_relaxed(RK_DDR_VIRT);
-        readl_relaxed(RK_GPIO_VIRT(0));     
-        //readl_relaxed(RK30_I2C1_BASE+SZ_4K);
-        //readl_relaxed(RK_GPIO_VIRT(3));
-}
-#endif
-void PIE_FUNC(ddr_leakage_tst)(void)
-{
-    cru_writel(RK3288_PLL_MODE_SLOW(DPLL_ID), RK3288_CRU_MODE_CON);    
-    rkpm_sram_printch('\n');   
-    rkpm_sram_printch('t');   
-    rkpm_sram_printch('e');   
-    rkpm_sram_printch('s');
-    rkpm_sram_printch('t');   
-    while(1);               
-}
-
-static void __init  rk3288_suspend_init(void)
-{
-    struct device_node *parent;
-    u32 pm_ctrbits;
-
-    PM_LOG("%s enter\n",__FUNCTION__);
-
-    parent = of_find_node_by_name(NULL, "rockchip_suspend");    
-
-    if (IS_ERR_OR_NULL(parent)) {
-		PM_ERR("%s dev node err\n", __func__);
-		return;
-	}
-
-
-    if(of_property_read_u32_array(parent,"rockchip,ctrbits",&pm_ctrbits,1))
-    {
-            PM_ERR("%s:get pm ctr error\n",__FUNCTION__);
-            return ;
-    }
-    PM_LOG("%s: pm_ctrbits =%x\n",__FUNCTION__,pm_ctrbits);
-    pm_io_base_map();
-    memset(&sleep_resume_data[0],0,sizeof(sleep_resume_data));
-    rkpm_set_ctrbits(pm_ctrbits);
-    
-    gpio_get_dts_info(parent);
-    clks_gating_suspend_init();
-
-    rkpm_set_ops_plls(pm_plls_suspend,pm_plls_resume);
-    
-    //rkpm_set_sram_ops_ddr(fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_leakage_tst)),NULL);
-    
-    rkpm_set_ops_prepare_finish(rkpm_prepare,rkpm_finish);
-    
-    //rkpm_set_ops_regs_pread(interface_ctr_reg_pread);  
-    
-     rkpm_set_ops_save_setting(rkpm_save_setting,rkpm_save_setting_resume);
-     rkpm_set_ops_regs_sleep(rkpm_slp_setting,rkpm_save_setting_resume_first);//rkpm_slp_setting
-
-    if(rockchip_pie_chunk)
-        rkpm_set_sram_ops_printch(fn_to_pie(rockchip_pie_chunk, &FUNC(sram_printch)));
-    
-    rkpm_set_ops_printch(ddr_printch); 	
-}
diff --git a/arch/arm/mach-rockchip/psci.c b/arch/arm/mach-rockchip/psci.c
deleted file mode 100644
index 3132c2d4c467..000000000000
--- a/arch/arm/mach-rockchip/psci.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * arch/arm/mach-rockchip/psci.c
- *
- * PSCI call interface for rockchip
- *
- * Copyright (C) 2015 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/of.h>
-#include <linux/types.h>
-#include <linux/rockchip/psci.h>
-#include <asm/compiler.h>
-#include <asm/smp_plat.h>
-#ifdef CONFIG_ARM
-#include <asm/opcodes-sec.h>
-#endif
-
-/*
- * SMC32 id call made from arch32 or arch64
- */
-static u32 reg_rd_fn_smc(u32 function_id, u32 arg0, u32 arg1,
-			 u32 arg2, u32 *val)
-{
-	asm volatile(
-#ifdef CONFIG_ARM
-			__asmeq("%0", "r0")
-			__asmeq("%1", "r1")
-			__asmeq("%2", "r2")
-			__asmeq("%3", "r3")
-			__SMC(0)
-#else
-			__asmeq("%w0", "w0")
-			__asmeq("%w1", "w1")
-			__asmeq("%w2", "w2")
-			__asmeq("%w3", "w3")
-			"smc	#0\n"
-#endif
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-
-		if (val)
-			*val = arg0;
-
-	return function_id;
-}
-
-/*
- * SMC32 id call made from arch32 or arch64
- */
-static u32 reg_wr_fn_smc(u32 function_id, u32 arg0,
-			 u32 arg1, u32 arg2)
-{
-	asm volatile(
-#ifdef CONFIG_ARM
-			__asmeq("%0", "r0")
-			__asmeq("%1", "r1")
-			__asmeq("%2", "r2")
-			__asmeq("%3", "r3")
-			__SMC(0)
-#else
-			__asmeq("%w0", "w0")
-			__asmeq("%w1", "w1")
-			__asmeq("%w2", "w2")
-			__asmeq("%w3", "w3")
-			"smc	#0\n"
-#endif
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-	return function_id;
-}
-
-static u32 (*reg_wr_fn)(u32, u32, u32, u32) = reg_wr_fn_smc;
-static u32 (*reg_rd_fn)(u32, u32, u32, u32, u32 *) = reg_rd_fn_smc;
-
-
-#ifdef CONFIG_ARM64
-
-/*
- * SMC64 id call only made from arch64
- */
-static u32 reg_rd_fn_smc64(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
-			   u64 *val)
-{
-	asm volatile(
-			__asmeq("%0", "x0")
-			__asmeq("%1", "x1")
-			__asmeq("%2", "x2")
-			__asmeq("%3", "x3")
-			"smc	#0\n"
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-		if (val)
-			*val = arg0;
-
-	return function_id;
-}
-
-/*
- * SMC64 id call only made from Arch64
- */
-static u32 reg_wr_fn_smc64(u64 function_id, u64 arg0, u64 arg1, u64 arg2)
-{
-	asm volatile(
-			__asmeq("%0", "x0")
-			__asmeq("%1", "x1")
-			__asmeq("%2", "x2")
-			__asmeq("%3", "x3")
-			"smc	#0\n"
-		: "+r" (function_id), "+r" (arg0)
-		: "r" (arg1), "r" (arg2));
-
-	return function_id;
-}
-
-static u32 (*reg_wr_fn64)(u64, u64, u64, u64) = reg_wr_fn_smc64;
-static u32 (*reg_rd_fn64)(u64, u64, u64, u64, u64 *) = reg_rd_fn_smc64;
-
-u32 rockchip_psci_smc_read64(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
-			     u64 *val)
-{
-	return reg_rd_fn64(function_id, arg0, arg1, arg2, val);
-}
-
-u32 rockchip_psci_smc_write64(u64 function_id, u64 arg0, u64 arg1, u64 arg2)
-{
-	return reg_wr_fn64(function_id, arg0, arg1, arg2);
-}
-
-u64 rockchip_secure_reg_read64(u64 addr_phy)
-{
-	u64 val;
-
-	reg_rd_fn64(PSCI_SIP_ACCESS_REG64, 0, addr_phy, SEC_REG_RD, &val);
-
-	return val;
-}
-
-u32 rockchip_secure_reg_write64(u64 addr_phy, u64 val)
-{
-	return reg_wr_fn64(PSCI_SIP_ACCESS_REG64, val, addr_phy, SEC_REG_WR);
-}
-
-#endif /*CONFIG_ARM64*/
-
-u32 rockchip_psci_smc_read(u32 function_id, u32 arg0, u32 arg1, u32 arg2,
-			   u32 *val)
-{
-	return reg_rd_fn(function_id, arg0, arg1, arg2, val);
-}
-
-u32 rockchip_psci_smc_write(u32 function_id, u32 arg0, u32 arg1, u32 arg2)
-{
-	return reg_wr_fn(function_id, arg0, arg1, arg2);
-}
-
-u32 rockchip_secure_reg_read(u32 addr_phy)
-{
-	u32 val = 0;
-
-	reg_rd_fn(PSCI_SIP_ACCESS_REG, 0, addr_phy, SEC_REG_RD, &val);
-
-	return val;
-}
-
-u32 rockchip_secure_reg_write(u32 addr_phy, u32 val)
-{
-	return reg_wr_fn(PSCI_SIP_ACCESS_REG, val, addr_phy, SEC_REG_WR);
-}
-
-/*
- * get trust firmware verison
- */
-u32 rockchip_psci_smc_get_tf_ver(void)
-{
-	return reg_rd_fn(PSCI_SIP_RKTF_VER, 0, 0, 0, NULL);
-}
-
-u32 psci_set_memory_secure(bool val)
-{
-	return reg_wr_fn(PSCI_SIP_SMEM_CONFIG, val, 0, 0);
-}
-
-/*************************** fiq debug *****************************/
-#ifdef CONFIG_ARM64
-static u64 ft_fiq_mem_phy;
-static void __iomem *ft_fiq_mem_base;
-static void (*psci_fiq_debugger_uart_irq_tf)(void *reg_base, u64 sp_el1);
-
-void psci_fiq_debugger_uart_irq_tf_cb(u64 sp_el1, u64 offset)
-{
-	psci_fiq_debugger_uart_irq_tf((char *)ft_fiq_mem_base + offset, sp_el1);
-	reg_wr_fn64(PSCI_SIP_UARTDBG_CFG64, 0, 0, UARTDBG_CFG_OSHDL_TO_OS);
-}
-
-void psci_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback)
-{
-	psci_fiq_debugger_uart_irq_tf = callback;
-	ft_fiq_mem_phy = reg_wr_fn64(PSCI_SIP_UARTDBG_CFG64, irq_id,
-				     (u64)psci_fiq_debugger_uart_irq_tf_cb,
-				     UARTDBG_CFG_INIT);
-	ft_fiq_mem_base = ioremap(ft_fiq_mem_phy, 8 * 1024);
-}
-
-u32 psci_fiq_debugger_switch_cpu(u32 cpu)
-{
-	return reg_wr_fn64(PSCI_SIP_UARTDBG_CFG64, cpu_logical_map(cpu),
-			   0, UARTDBG_CFG_OSHDL_CPUSW);
-}
-
-void psci_fiq_debugger_enable_debug(bool val)
-{
-	if (val)
-		reg_wr_fn64(PSCI_SIP_UARTDBG_CFG64, 0,
-			    0, UARTDBG_CFG_OSHDL_DEBUG_ENABLE);
-	else
-		reg_wr_fn64(PSCI_SIP_UARTDBG_CFG64, 0,
-			    0, UARTDBG_CFG_OSHDL_DEBUG_DISABLE);
-}
-#endif
diff --git a/arch/arm/mach-rockchip/pvtm.c b/arch/arm/mach-rockchip/pvtm.c
deleted file mode 100644
index e6c5ca2fe772..000000000000
--- a/arch/arm/mach-rockchip/pvtm.c
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright (C) 2013 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/mutex.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/of.h>
-#include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
-
-#define RK3288_PVTM_CON0 (0x368)
-#define RK3288_PVTM_CON1 (0x36c)
-#define RK3288_PVTM_CON2 (0x370)
-#define RK3288_PVTM_STATUS0 (0x374)
-#define RK3288_PVTM_STATUS1 (0x378)
-#define RK3288_PVTM_STATUS2 (0x37c)
-
-#define RK312X_PVTM_CON0 (0x200)
-#define RK312X_PVTM_CON1 (0x204)
-#define RK312X_PVTM_CON2 (0x208)
-#define RK312X_PVTM_CON3 (0x20c)
-#define RK312X_PVTM_STATUS0 (0x210)
-#define RK312X_PVTM_STATUS1 (0x214)
-#define RK312X_PVTM_STATUS2 (0x218)
-#define RK312X_PVTM_STATUS3 (0x21c)
-
-#define RK3368_PVTM_CON0 (0x800)
-#define RK3368_PVTM_CON1 (0x804)
-#define RK3368_PVTM_CON2 (0x808)
-#define RK3368_PVTM_STATUS0 (0x80c)
-#define RK3368_PVTM_STATUS1 (0x810)
-#define RK3368_PVTM_STATUS2 (0x814)
-
-#define RK3368_PMUPVTM_CON0 (0x180)
-#define RK3368_PMUPVTM_CON1 (0x184)
-#define RK3368_PMUPVTM_STATUS0 (0x190)
-#define RK3368_PMUPVTM_STATUS1 (0x194)
-
-#define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT+offset)
-#define grf_writel(val, offset)	writel_relaxed(val, RK_GRF_VIRT+offset)
-
-#define wr_msk_bit(v, off, msk)  ((v)<<(off)|(msk<<(16+(off))))
-
-static struct clk *ch_clk[3];
-
-struct rockchip_pvtm {
-	u32 (*get_value)(u32 ch , u32 time_us);
-};
-static struct rockchip_pvtm pvtm;
-
-static struct regmap *grf_regmap;
-static struct regmap *pmugrf_regmap;
-
-static DEFINE_MUTEX(pvtm_mutex);
-
-/* 0 core, 1 gpu, 2 pmu */
-static u32 rk3368_pvtm_get_value(u32 ch , u32 time_us)
-{
-	u32 val = 0, clk_cnt, check_cnt, pvtm_done_bit;
-	u32 sta = 0;
-
-	if (ch > 2)
-		return 0;
-	/* 24m clk ,24cnt=1us */
-	clk_cnt = time_us*24;
-
-	if (ch == 2) {
-		regmap_write(pmugrf_regmap, RK3368_PMUPVTM_CON1, clk_cnt);
-		regmap_write(pmugrf_regmap, RK3368_PMUPVTM_CON0,
-			     wr_msk_bit(3, 0, 0x3));
-	} else {
-		regmap_write(grf_regmap, RK3368_PVTM_CON0+(ch+1)*4, clk_cnt);
-		regmap_write(grf_regmap, RK3368_PVTM_CON0,
-			     wr_msk_bit(3, ch*8, 0x3));
-	}
-
-	if (time_us >= 1000)
-		mdelay(time_us / 1000);
-	udelay(time_us % 1000);
-
-	if (ch == 0)
-		pvtm_done_bit = 0;
-	else if (ch == 1)
-		pvtm_done_bit = 1;
-
-	check_cnt = 100;
-	if (ch == 2) {
-		while (check_cnt--) {
-			regmap_read(pmugrf_regmap, RK3368_PMUPVTM_STATUS0,
-				    &sta);
-			if (sta & 0x1)
-				break;
-			udelay(4);
-		}
-
-	} else {
-		while (check_cnt--) {
-			regmap_read(grf_regmap, RK3368_PVTM_STATUS0, &sta);
-			if (sta & (1 << pvtm_done_bit))
-				break;
-			udelay(4);
-		}
-	}
-
-	if (check_cnt)
-		if (ch == 2)
-			regmap_read(pmugrf_regmap, RK3368_PMUPVTM_STATUS1,
-				    &val);
-		else
-			regmap_read(grf_regmap, RK3368_PVTM_STATUS0+(ch+1)*4,
-				    &val);
-	else {
-		pr_err("%s: wait pvtm_done timeout!\n", __func__);
-		val = 0;
-	}
-
-	if (ch == 2)
-		regmap_write(pmugrf_regmap, RK3368_PMUPVTM_CON0,
-			     wr_msk_bit(0, 0, 0x3));
-	else
-		regmap_write(grf_regmap, RK3368_PVTM_CON0,
-			     wr_msk_bit(0, ch*8, 0x3));
-
-	return val;
-}
-
-/* 0 core, 1 gpu*/
-static u32 rk3288_pvtm_get_value(u32 ch , u32 time_us)
-{
-	u32 val = 0, clk_cnt, check_cnt, pvtm_done_bit;
-
-	if (ch > 1)
-		return 0;
-
-	/*24m clk ,24cnt=1us*/
-	clk_cnt = time_us*24;
-
-	grf_writel(clk_cnt, RK3288_PVTM_CON0+(ch+1)*4);
-	grf_writel(wr_msk_bit(3, ch*8, 0x3), RK3288_PVTM_CON0);
-
-	if (time_us >= 1000)
-		mdelay(time_us / 1000);
-	udelay(time_us % 1000);
-
-	if (ch == 0)
-		pvtm_done_bit = 1;
-	else if (ch == 1)
-		pvtm_done_bit = 0;
-
-	check_cnt = 100;
-	while (!(grf_readl(RK3288_PVTM_STATUS0) & (1 << pvtm_done_bit))) {
-		udelay(4);
-		check_cnt--;
-		if (!check_cnt)
-			break;
-	}
-
-	if (check_cnt)
-		val = grf_readl(RK3288_PVTM_STATUS0+(ch+1)*4);
-
-	grf_writel(wr_msk_bit(0, ch*8, 0x3), RK3288_PVTM_CON0);
-
-	return val;
-}
-
-/*0 core, 1 gpu, 2 func*/
-static u32 rk312x_pvtm_get_value(u32 ch , u32 time_us)
-{
-	u32 val = 0, clk_cnt, check_cnt, pvtm_done_bit;
-
-	if (ch > 2)
-		return 0;
-
-	/*24m clk ,24cnt=1us*/
-	clk_cnt = time_us*24;
-
-	grf_writel(clk_cnt, RK312X_PVTM_CON0+(ch+1)*4);
-	if ((ch == 0) || (ch == 1))
-		grf_writel(wr_msk_bit(3, ch*8, 0x3), RK312X_PVTM_CON0);
-	else if (ch == 2)
-		grf_writel(wr_msk_bit(3, 12, 0x3), RK312X_PVTM_CON0);
-
-	if (time_us >= 1000)
-		mdelay(time_us / 1000);
-	udelay(time_us % 1000);
-
-	if (ch == 0)
-		pvtm_done_bit = 1;
-	else if (ch == 1)
-		pvtm_done_bit = 0;
-	else if (ch == 2)
-		pvtm_done_bit = 2;
-
-	check_cnt = 100;
-	while (!(grf_readl(RK312X_PVTM_STATUS0) & (1 << pvtm_done_bit))) {
-		udelay(4);
-		check_cnt--;
-		if (!check_cnt)
-			break;
-	}
-
-	if (check_cnt)
-		val = grf_readl(RK312X_PVTM_STATUS0+(ch+1)*4);
-	if ((ch == 0) || (ch == 1))
-		grf_writel(wr_msk_bit(0, ch*8, 0x3), RK312X_PVTM_CON0);
-	else if (ch == 2)
-		grf_writel(wr_msk_bit(0, 12, 0x3), RK312X_PVTM_CON0);
-
-	return val;
-}
-
-u32 pvtm_get_value(u32 ch, u32 time_us)
-{
-	u32 val = 0;
-
-	if (IS_ERR_OR_NULL(ch_clk[ch]))
-		return 0;
-
-	clk_prepare_enable(ch_clk[ch]);
-	mutex_lock(&pvtm_mutex);
-	val = pvtm.get_value(ch, time_us);
-	mutex_unlock(&pvtm_mutex);
-	clk_disable_unprepare(ch_clk[ch]);
-
-	return val;
-}
-
-static int __init rk3368_pmupvtm_clk_init(void)
-{
-	u32 pvtm_cnt = 0, div, val, time_us;
-	unsigned long rate = 32;/* KHZ */
-	int ret = 0;
-
-	pr_info("%s\n", __func__);
-
-	time_us = 1000;
-	pvtm_cnt = pvtm_get_value(2, time_us);
-	pr_debug("get pvtm_cnt = %d\n", pvtm_cnt);
-
-	/* set pvtm_div to get rate */
-	div = DIV_ROUND_UP(1000*pvtm_cnt, time_us*rate);
-	val = DIV_ROUND_UP(div-1, 4);
-
-	if (val > 0x3f) {
-		pr_err("need pvtm_div out of bounary! set max instead\n");
-		val = 0x3f;
-	}
-
-	pr_debug("will set div %d, val %d, rate %luKHZ\n", div, val, rate);
-	ret = regmap_write(pmugrf_regmap, RK3368_PMUPVTM_CON0,
-			   wr_msk_bit(val, 2, 0x3f));
-	if (ret != 0)
-		goto out;
-
-	/* pvtm oscilator enable */
-	ret = regmap_write(pmugrf_regmap, RK3368_PMUPVTM_CON0,
-			   wr_msk_bit(1, 1, 0x1));
-out:
-	if (ret != 0)
-		pr_err("%s: fail to write register\n", __func__);
-
-	return ret;
-}
-
-static int __init pvtm_init(void)
-{
-	struct device_node *np;
-	int ret;
-	u32 clk_out;
-
-	np = of_find_node_by_name(NULL, "pvtm");
-	if (!IS_ERR_OR_NULL(np)) {
-		grf_regmap = syscon_regmap_lookup_by_phandle(np,
-							     "rockchip,grf");
-		if (IS_ERR(grf_regmap)) {
-			pr_err("pvtm: dts couldn't find grf regmap\n");
-			return PTR_ERR(grf_regmap);
-		}
-		pmugrf_regmap = syscon_regmap_lookup_by_phandle(np,
-								"rockchip,pmugrf");
-		if (IS_ERR(pmugrf_regmap)) {
-			pr_err("pvtm: dts couldn't find pmugrf regmap\n");
-			return PTR_ERR(pmugrf_regmap);
-		}
-
-		if (of_device_is_compatible(np, "rockchip,rk3368-pvtm")) {
-			ch_clk[0] = clk_get(NULL, "clk_pvtm_core");
-			ch_clk[1] = clk_get(NULL, "clk_pvtm_gpu");
-			ch_clk[2] = clk_get(NULL, "clk_pvtm_pmu");
-			pvtm.get_value = rk3368_pvtm_get_value;
-			ret = of_property_read_u32(np, "rockchip,pvtm-clk-out",
-						   &clk_out);
-			if (!ret && clk_out) {
-				ret = rk3368_pmupvtm_clk_init();
-				if (ret != 0) {
-					pr_err("rk3368_pmupvtm_clk_init failed\n");
-					return ret;
-				}
-			}
-		}
-
-		return 0;
-	}
-
-	if (cpu_is_rk3288() || cpu_is_rk312x()) {
-		ch_clk[0] = clk_get(NULL, "g_clk_pvtm_core");
-		ch_clk[1] = clk_get(NULL, "g_clk_pvtm_gpu");
-		ch_clk[2] = clk_get(NULL, "g_clk_pvtm_func");
-		if (cpu_is_rk3288())
-			pvtm.get_value = rk3288_pvtm_get_value;
-		else if (cpu_is_rk312x())
-			pvtm.get_value = rk312x_pvtm_get_value;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_ARM64
-arch_initcall_sync(pvtm_init);
-#else
-core_initcall(pvtm_init);
-#endif
-
diff --git a/arch/arm/mach-rockchip/rk3036.c b/arch/arm/mach-rockchip/rk3036.c
deleted file mode 100755
index 89b3850da268..000000000000
--- a/arch/arm/mach-rockchip/rk3036.c
+++ /dev/null
@@ -1,703 +0,0 @@
-/*
- * Device Tree support for Rockchip RK3036
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clocksource.h>
-#include <linux/cpuidle.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/wakeup_reason.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-#include <asm/cpuidle.h>
-#include <asm/cputype.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include "loader.h"
-#define CPU 3036
-#include "sram.h"
-#include "pm.h"
-
-#define RK3036_DEVICE(name) \
-	{ \
-		.virtual	= (unsigned long) RK_##name##_VIRT, \
-		.pfn		= __phys_to_pfn(RK3036_##name##_PHYS), \
-		.length		= RK3036_##name##_SIZE, \
-		.type		= MT_DEVICE, \
-	}
-
-#define RK3036_IMEM_VIRT (RK_BOOTRAM_VIRT + SZ_32K)
-#define RK3036_TIMER5_VIRT (RK_TIMER_VIRT + 0xa0)
-
-static struct map_desc rk3036_io_desc[] __initdata = {
-	RK3036_DEVICE(CRU),
-	RK3036_DEVICE(GRF),
-	RK3036_DEVICE(ROM),
-	RK3036_DEVICE(EFUSE),
-	RK3036_DEVICE(CPU_AXI_BUS),
-	RK_DEVICE(RK_DDR_VIRT, RK3036_DDR_PCTL_PHYS, RK3036_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK3036_DDR_PCTL_SIZE, RK3036_DDR_PHY_PHYS,
-		  RK3036_DDR_PHY_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(0), RK3036_GPIO0_PHYS, RK3036_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(1), RK3036_GPIO1_PHYS, RK3036_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(2), RK3036_GPIO2_PHYS, RK3036_GPIO_SIZE),
-	RK_DEVICE(RK_DEBUG_UART_VIRT, RK3036_UART2_PHYS, RK3036_UART_SIZE),
-	RK_DEVICE(RK_GIC_VIRT, RK3036_GIC_DIST_PHYS, RK3036_GIC_DIST_SIZE),
-	RK_DEVICE(RK_GIC_VIRT + RK3036_GIC_DIST_SIZE, RK3036_GIC_CPU_PHYS,
-		  RK3036_GIC_CPU_SIZE),
-	RK_DEVICE(RK3036_IMEM_VIRT, RK3036_IMEM_PHYS, SZ_4K),
-	RK_DEVICE(RK_TIMER_VIRT, RK3036_TIMER_PHYS, RK3036_TIMER_SIZE),
-	RK_DEVICE(RK_PWM_VIRT, RK3036_PWM_PHYS, RK3036_PWM_SIZE),
-};
-
-static void __init rk3036_boot_mode_init(void)
-{
-	u32 flag = readl_relaxed(RK_GRF_VIRT + RK3036_GRF_OS_REG4);
-	u32 mode = readl_relaxed(RK_GRF_VIRT + RK3036_GRF_OS_REG5);
-	u32 rst_st = readl_relaxed(RK_CRU_VIRT + RK3036_CRU_RST_ST);
-
-	if (flag == (SYS_KERNRL_REBOOT_FLAG | BOOT_RECOVER))
-		mode = BOOT_MODE_RECOVERY;
-	if (rst_st & ((1 << 2) | (1 << 3)))
-		mode = BOOT_MODE_WATCHDOG;
-	rockchip_boot_mode_init(flag, mode);
-}
-
-static void usb_uart_init(void)
-{
-#ifdef CONFIG_RK_USB_UART
-	u32 soc_status0 = readl_relaxed(RK_GRF_VIRT + RK3036_GRF_SOC_STATUS0);
-#endif
-	writel_relaxed(0x34000000, RK_GRF_VIRT + RK3036_GRF_UOC1_CON4);
-#ifdef CONFIG_RK_USB_UART
-	if (!(soc_status0 & (1 << 14)) && (soc_status0 & (1 << 17))) {
-		/* software control usb phy enable */
-		writel_relaxed(0x007f0055, RK_GRF_VIRT + RK3036_GRF_UOC0_CON5);
-		writel_relaxed(0x34003000, RK_GRF_VIRT + RK3036_GRF_UOC1_CON4);
-	}
-#endif
-
-	writel_relaxed(0x07, RK_DEBUG_UART_VIRT + 0x88);
-	writel_relaxed(0x00, RK_DEBUG_UART_VIRT + 0x04);
-	writel_relaxed(0x83, RK_DEBUG_UART_VIRT + 0x0c);
-	writel_relaxed(0x0d, RK_DEBUG_UART_VIRT + 0x00);
-	writel_relaxed(0x00, RK_DEBUG_UART_VIRT + 0x04);
-	writel_relaxed(0x03, RK_DEBUG_UART_VIRT + 0x0c);
-}
-
-static void __init rk3036_dt_map_io(void)
-{
-	rockchip_soc_id = ROCKCHIP_SOC_RK3036;
-
-	iotable_init(rk3036_io_desc, ARRAY_SIZE(rk3036_io_desc));
-	debug_ll_io_init();
-	usb_uart_init();
-
-	/* enable timer5 for core */
-	writel_relaxed(0, RK3036_TIMER5_VIRT + 0x10);
-	dsb();
-	writel_relaxed(0xFFFFFFFF, RK3036_TIMER5_VIRT + 0x00);
-	writel_relaxed(0xFFFFFFFF, RK3036_TIMER5_VIRT + 0x04);
-	dsb();
-	writel_relaxed(1, RK3036_TIMER5_VIRT + 0x10);
-	dsb();
-
-	rk3036_boot_mode_init();
-}
-
-extern void secondary_startup(void);
-static int rk3036_sys_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	if (on) {
-#ifdef CONFIG_SMP
-		if (PD_CPU_1 == pd) {
-			writel_relaxed(0x20000
-				, RK_CRU_VIRT + RK3036_CRU_SOFTRST0_CON);
-			dsb();
-			udelay(10);
-			writel_relaxed(virt_to_phys(secondary_startup),
-					   RK3036_IMEM_VIRT + 8);
-			writel_relaxed(0xDEADBEAF, RK3036_IMEM_VIRT + 4);
-			dsb_sev();
-		}
-#endif
-	} else {
-#ifdef CONFIG_SMP
-		if (PD_CPU_1 == pd) {
-			writel_relaxed(0x20002
-				, RK_CRU_VIRT + RK3036_CRU_SOFTRST0_CON);
-			dsb();
-		}
-#endif
-	}
-
-	return 0;
-}
-
-static bool rk3036_pmu_power_domain_is_on(enum pmu_power_domain pd)
-{
-	return 1;
-}
-
-static int rk3036_pmu_set_idle_request(enum pmu_idle_req req, bool idle)
-{
-	return 0;
-}
-
-static void __init rk3036_dt_init_timer(void)
-{
-	rockchip_pmu_ops.set_power_domain = rk3036_sys_set_power_domain;
-	rockchip_pmu_ops.power_domain_is_on = rk3036_pmu_power_domain_is_on;
-	rockchip_pmu_ops.set_idle_request = rk3036_pmu_set_idle_request;
-	of_clk_init(NULL);
-	clocksource_of_init();
-}
-
-#ifdef CONFIG_PM
-static inline void rk3036_uart_printch(char byte)
-{
-write_uart:
-	writel_relaxed(byte, RK_DEBUG_UART_VIRT);
-	dsb();
-
-	/* loop check LSR[6], Transmitter Empty bit */
-	while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-		barrier();
-
-	if (byte == '\n') {
-		byte = '\r';
-		goto write_uart;
-	}
-}
-
-static void rk3036_ddr_printch(char byte)
-{
-	rk3036_uart_printch(byte);
-
-	rk_last_log_text(&byte, 1);
-
-	if (byte == '\n') {
-		byte = '\r';
-		rk_last_log_text(&byte, 1);
-	}
-}
-
-enum rk_plls_id {
-	APLL_ID = 0,
-	DPLL_ID,
-	GPLL_ID,
-	RK3036_END_PLL_ID,
-};
-
-#define GPIO_INTEN 0x30
-#define GPIO_INT_STATUS 0x40
-#define GIC_DIST_PENDING_SET 0x200
-static void rk3036_pm_dump_irq(void)
-{
-	u32 irq_gpio = (readl_relaxed(RK_GIC_VIRT
-		+ GIC_DIST_PENDING_SET + 8) >> 4) & 7;
-	u32 irq[4];
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(irq); i++) {
-		irq[i] = readl_relaxed(RK_GIC_VIRT + GIC_DIST_PENDING_SET +
-					   (1 + i) * 4);
-		if (irq[i])
-			log_wakeup_reason(32 * (i + 1) + fls(irq[i]) - 1);
-	}
-	pr_info("wakeup irq: %08x %08x %08x %08x\n",
-		irq[0], irq[1], irq[2], irq[3]);
-	for (i = 0; i <= 2; i++) {
-		if (irq_gpio & (1 << i))
-			pr_info("wakeup gpio%d: %08x\n", i,
-				readl_relaxed(RK_GPIO_VIRT(i) +
-						  GPIO_INT_STATUS));
-	}
-}
-
-#define DUMP_GPIO_INTEN(ID) \
-	do { \
-		u32 en = readl_relaxed(RK_GPIO_VIRT(ID) + GPIO_INTEN); \
-		if (en) { \
-			pr_info("GPIO%d_INTEN: %08x\n", ID, en); \
-		} \
-	} while (0)
-
-static void rk3036_pm_dump_inten(void)
-{
-	DUMP_GPIO_INTEN(0);
-	DUMP_GPIO_INTEN(1);
-	DUMP_GPIO_INTEN(2);
-}
-
-static void rkpm_prepare(void)
-{
-	rk3036_pm_dump_inten();
-}
-static void rkpm_finish(void)
-{
-	rk3036_pm_dump_irq();
-}
-
-static u32 clk_ungt_msk[RK3036_CRU_CLKGATES_CON_CNT];
-/*first clk gating setting*/
-
-static u32 clk_ungt_msk_1[RK3036_CRU_CLKGATES_CON_CNT];
-/* first clk gating setting*/
-
-static u32 clk_ungt_save[RK3036_CRU_CLKGATES_CON_CNT];
-/*first clk gating value saveing*/
-
-static u32 *p_rkpm_clkgt_last_set;
-#define CLK_MSK_GATING(msk, con) cru_writel((msk << 16) | 0xffff, con)
-#define CLK_MSK_UNGATING(msk, con) cru_writel(((~msk) << 16) | 0xffff, con)
-
-static void gtclks_suspend(void)
-{
-	int i;
-
-	for (i = 0; i < RK3036_CRU_CLKGATES_CON_CNT; i++) {
-		clk_ungt_save[i] = cru_readl(RK3036_CRU_CLKGATES_CON(i));
-		if (i != 10)
-			CLK_MSK_UNGATING(clk_ungt_msk[i]
-			, RK3036_CRU_CLKGATES_CON(i));
-		else
-			cru_writel(clk_ungt_msk[i], RK3036_CRU_CLKGATES_CON(i));
-	}
-
-	/*gpio0_a1 clk gate should be disable for volt adjust*/
-	if (cru_readl(RK3036_CRU_CLKGATES_CON(8)) & 0x200)
-		cru_writel(0x02000000, RK3036_CRU_CLKGATES_CON(8));
-}
-
-static void gtclks_resume(void)
-{
-	int i;
-
-	for (i = 0; i < RK3036_CRU_CLKGATES_CON_CNT; i++) {
-		if (i != 10)
-			cru_writel(clk_ungt_save[i] | 0xffff0000
-				, RK3036_CRU_CLKGATES_CON(i));
-		else
-			cru_writel(clk_ungt_save[i]
-				, RK3036_CRU_CLKGATES_CON(i));
-	}
-}
-
-static void clks_gating_suspend_init(void)
-{
-	p_rkpm_clkgt_last_set = &clk_ungt_msk_1[0];
-	if (clk_suspend_clkgt_info_get(clk_ungt_msk, p_rkpm_clkgt_last_set
-		, RK3036_CRU_CLKGATES_CON_CNT) == RK3036_CRU_CLKGATES_CON(0))
-		rkpm_set_ops_gtclks(gtclks_suspend, gtclks_resume);
-}
-
-#define RK3036_PLL_BYPASS CRU_W_MSK_SETBITS(1, 0xF, 0x01)
-#define RK3036_PLL_NOBYPASS CRU_W_MSK_SETBITS(0, 0xF, 0x01)
-#define RK3036_PLL_POWERDOWN CRU_W_MSK_SETBITS(1, 0xD, 0x01)
-#define RK3036_PLL_POWERON CRU_W_MSK_SETBITS(0, 0xD, 0x01)
-
-#define grf_readl(offset) readl_relaxed(RK_GRF_VIRT + offset)
-#define grf_writel(v, offset) do { writel_relaxed(v, \
-	RK_GRF_VIRT + offset); dsb(); } while (0)
-
-#define gpio0_readl(offset) readl_relaxed(RK_GPIO_VIRT(0) + offset)
-#define gpio0_writel(v, offset) do { writel_relaxed(v, RK_GPIO_VIRT(0) \
-	+ offset); dsb(); } while (0)
-
-static u32 plls_con0_save[RK3036_END_PLL_ID];
-static u32 plls_con1_save[RK3036_END_PLL_ID];
-static u32 plls_con2_save[RK3036_END_PLL_ID];
-
-static u32 cru_mode_con;
-static u32 clk_sel0, clk_sel1, clk_sel10;
-static void pm_pll_wait_lock(u32 pll_idx)
-{
-	u32 delay = 600000U;
-
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	dsb();
-	while (delay > 0) {
-		if ((cru_readl(RK3036_PLL_CONS(pll_idx, 1)) & (0x1 << 10)))
-			break;
-		delay--;
-	}
-	if (delay == 0) {
-		rkpm_ddr_printascii("unlock-pll:");
-		rkpm_ddr_printhex(pll_idx);
-		rkpm_ddr_printch('\n');
-	}
-}
-
-static void pll_udelay(u32 udelay)
-{
-	u32 mode;
-
-	mode = cru_readl(RK3036_CRU_MODE_CON);
-	cru_writel(RK3036_PLL_MODE_SLOW(APLL_ID), RK3036_CRU_MODE_CON);
-	rkpm_udelay(udelay * 5);
-	cru_writel(mode|(RK3036_PLL_MODE_MSK(APLL_ID)
-		<< 16), RK3036_CRU_MODE_CON);
-}
-
-static inline void plls_suspend(u32 pll_id)
-{
-	plls_con0_save[pll_id] = cru_readl(RK3036_PLL_CONS((pll_id), 0));
-	plls_con1_save[pll_id] = cru_readl(RK3036_PLL_CONS((pll_id), 1));
-	plls_con2_save[pll_id] = cru_readl(RK3036_PLL_CONS((pll_id), 2));
-
-	/*cru_writel(RK3036_PLL_BYPASS, RK3036_PLL_CONS((pll_id), 0));*/
-	cru_writel(RK3036_PLL_POWERDOWN, RK3036_PLL_CONS((pll_id), 1));
-}
-static inline void plls_resume(u32 pll_id)
-{
-	u32 pllcon0, pllcon1, pllcon2;
-
-	pllcon0 = plls_con0_save[pll_id];
-	pllcon1 = plls_con1_save[pll_id];
-	pllcon2 = plls_con2_save[pll_id];
-/*
-	cru_writel(pllcon0 | 0xffff0000, RK3036_PLL_CONS(pll_id, 0));
-	cru_writel(pllcon1 | 0xf5ff0000, RK3036_PLL_CONS(pll_id, 1));
-	cru_writel(pllcon2, RK3036_PLL_CONS(pll_id, 2));
-*/
-	cru_writel(RK3036_PLL_POWERON, RK3036_PLL_CONS((pll_id), 1));
-
-	pll_udelay(5);
-
-	pll_udelay(168);
-	pm_pll_wait_lock(pll_id);
-}
-
-static void pm_plls_suspend(void)
-{
-	cru_mode_con  = cru_readl(RK3036_CRU_MODE_CON);
-
-	clk_sel0 = cru_readl(RK3036_CRU_CLKSELS_CON(0));
-	clk_sel1 = cru_readl(RK3036_CRU_CLKSELS_CON(1));
-	clk_sel10 = cru_readl(RK3036_CRU_CLKSELS_CON(10));
-
-	cru_writel(RK3036_PLL_MODE_SLOW(GPLL_ID), RK3036_CRU_MODE_CON);
-	cru_writel(0
-						|CRU_W_MSK_SETBITS(0, 0, 0x1f)
-						|CRU_W_MSK_SETBITS(0, 8, 0x3)
-						|CRU_W_MSK_SETBITS(0, 12, 0x3)
-						, RK3036_CRU_CLKSELS_CON(10));
-	plls_suspend(GPLL_ID);
-
-
-	cru_writel(RK3036_PLL_MODE_SLOW(APLL_ID), RK3036_CRU_MODE_CON);
-
-	cru_writel(0
-						|CRU_W_MSK_SETBITS(0, 0, 0x1f)
-						|CRU_W_MSK_SETBITS(0, 8, 0x1f)
-					  , RK3036_CRU_CLKSELS_CON(0));
-
-	cru_writel(0
-						|CRU_W_MSK_SETBITS(0, 0, 0xf)
-						|CRU_W_MSK_SETBITS(0, 4, 0x7)
-						|CRU_W_MSK_SETBITS(0, 8, 0x3)
-						|CRU_W_MSK_SETBITS(0, 12, 0x7)
-					 , RK3036_CRU_CLKSELS_CON(1));
-
-	plls_suspend(APLL_ID);
-}
-
-static void pm_plls_resume(void)
-{
-	plls_resume(APLL_ID);
-	cru_writel(clk_sel0 | (CRU_W_MSK(0, 0x1f) | CRU_W_MSK(8, 0x1f))
-		, RK3036_CRU_CLKSELS_CON(0));
-	cru_writel(clk_sel1 | (CRU_W_MSK(0, 0xf) | CRU_W_MSK(4, 0x7)
-		|CRU_W_MSK(8, 0x3) | CRU_W_MSK(12, 0x7))
-		, RK3036_CRU_CLKSELS_CON(1));
-	cru_writel(cru_mode_con | (RK3036_PLL_MODE_MSK(APLL_ID) << 16)
-		, RK3036_CRU_MODE_CON);
-
-	plls_resume(GPLL_ID);
-	cru_writel(clk_sel10 | (CRU_W_MSK(0, 0x1f) | CRU_W_MSK(8, 0x3)
-		| CRU_W_MSK(12, 0x3)), RK3036_CRU_CLKSELS_CON(10));
-	cru_writel(cru_mode_con | (RK3036_PLL_MODE_MSK(GPLL_ID)
-		<< 16), RK3036_CRU_MODE_CON);
-}
-
-#include "ddr_rk3036.c"
-#include "pm-pie.c"
-
-char PIE_DATA(sram_stack)[1024];
-EXPORT_PIE_SYMBOL(DATA(sram_stack));
-
-static int __init rk3036_pie_init(void)
-{
-	int err;
-
-	if (!cpu_is_rk3036())
-		return 0;
-
-	err = rockchip_pie_init();
-	if (err)
-		return err;
-
-	rockchip_pie_chunk = pie_load_sections(rockchip_sram_pool, rk3036);
-	if (IS_ERR(rockchip_pie_chunk)) {
-		err = PTR_ERR(rockchip_pie_chunk);
-		pr_err("%s: failed to load section %d\n", __func__, err);
-		rockchip_pie_chunk = NULL;
-		return err;
-	}
-
-	rockchip_sram_virt = kern_to_pie(rockchip_pie_chunk
-		, &__pie_common_start[0]);
-	rockchip_sram_stack = kern_to_pie(rockchip_pie_chunk
-		, (char *)DATA(sram_stack) + sizeof(DATA(sram_stack)));
-
-	return 0;
-}
-arch_initcall(rk3036_pie_init);
-
-static void reg_pread(void)
-{
-	volatile u32 n;
-	int i;
-
-	volatile u32 *temp = (volatile unsigned int *)rockchip_sram_virt;
-
-	flush_cache_all();
-	outer_flush_all();
-	local_flush_tlb_all();
-
-	for (i = 0; i < 2; i++) {
-		n = temp[1024 * i];
-		barrier();
-	}
-
-	n = readl_relaxed(RK_GPIO_VIRT(0));
-	n = readl_relaxed(RK_GPIO_VIRT(1));
-	n = readl_relaxed(RK_GPIO_VIRT(2));
-
-	n = readl_relaxed(RK_DEBUG_UART_VIRT);
-	n = readl_relaxed(RK_CPU_AXI_BUS_VIRT);
-	n = readl_relaxed(RK_DDR_VIRT);
-	n = readl_relaxed(RK_GRF_VIRT);
-	n = readl_relaxed(RK_CRU_VIRT);
-	n = readl_relaxed(RK_PWM_VIRT);
-}
-
-#define RK3036_CRU_UNGATING_OPS(id) cru_writel(\
-	CRU_W_MSK_SETBITS(0,  (id), 0x1), RK3036_CRU_UART_GATE)
-#define RK3036_CRU_GATING_OPS(id) cru_writel(\
-	CRU_W_MSK_SETBITS(1, (id), 0x1), RK3036_CRU_UART_GATE)
-
-static inline void  uart_printch(char bbyte)
-{
-	u32 reg_save;
-	u32 u_clk_id = (RK3036_CLKGATE_UART0_SRC + CONFIG_RK_DEBUG_UART * 2);
-	u32 u_pclk_id = (RK3036_CLKGATE_UART0_PCLK + CONFIG_RK_DEBUG_UART * 2);
-
-	reg_save = cru_readl(RK3036_CRU_UART_GATE);
-	RK3036_CRU_UNGATING_OPS(u_clk_id);
-	RK3036_CRU_UNGATING_OPS(u_pclk_id);
-	rkpm_udelay(1);
-
-
-write_uart:
-	writel_relaxed(bbyte, RK_DEBUG_UART_VIRT);
-	dsb();
-
-	while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-		barrier();
-
-	if (bbyte == '\n') {
-		bbyte = '\r';
-		goto write_uart;
-	}
-
-	cru_writel(reg_save | CRU_W_MSK(u_clk_id
-		, 0x1), RK3036_CRU_UART_GATE);
-	cru_writel(reg_save | CRU_W_MSK(u_pclk_id
-		, 0x1), RK3036_CRU_UART_GATE);
-
-
-	if (0) {
-write_uart1:
-		writel_relaxed(bbyte, RK_DEBUG_UART_VIRT);
-		dsb();
-
-		while (!(readl_relaxed(RK_DEBUG_UART_VIRT + 0x14) & 0x40))
-			barrier();
-	if (bbyte == '\n') {
-		bbyte = '\r';
-		goto write_uart1;
-		}
-	}
-}
-
-
-void PIE_FUNC(sram_printch)(char byte)
-{
-	uart_printch(byte);
-}
-
-static __sramdata u32 rkpm_pwm_duty0;
-static __sramdata u32 rkpm_pwm_duty1;
-static __sramdata u32 rkpm_pwm_duty2;
-#define PWM_VOLTAGE 0x600
-
-void PIE_FUNC(pwm_regulator_suspend)(void)
-{
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM0)) {
-		rkpm_pwm_duty0 = readl_relaxed(RK_PWM_VIRT + 0x08);
-		writel_relaxed(PWM_VOLTAGE, RK_PWM_VIRT + 0x08);
-	}
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM1)) {
-		rkpm_pwm_duty1 = readl_relaxed(RK_PWM_VIRT + 0x18);
-		writel_relaxed(PWM_VOLTAGE, RK_PWM_VIRT + 0x18);
-	}
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM2)) {
-		rkpm_pwm_duty2 = readl_relaxed(RK_PWM_VIRT + 0x28);
-		writel_relaxed(PWM_VOLTAGE, RK_PWM_VIRT + 0x28);
-	}
-	//rkpm_udelay(30);
-}
-
-void PIE_FUNC(pwm_regulator_resume)(void)
-{
-	rkpm_udelay(30);
-
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM0))
-		writel_relaxed(rkpm_pwm_duty0, RK_PWM_VIRT + 0x08);
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM1))
-		writel_relaxed(rkpm_pwm_duty1, RK_PWM_VIRT + 0x18);
-
-	if (rkpm_chk_sram_ctrbit(RKPM_CTR_VOL_PWM2))
-		writel_relaxed(rkpm_pwm_duty2, RK_PWM_VIRT + 0x28);
-	rkpm_udelay(30);
-}
-
-static void __init rk3036_suspend_init(void)
-{
-	struct device_node *parent;
-	u32 pm_ctrbits;
-
-	PM_LOG("%s enter\n", __func__);
-
-	parent = of_find_node_by_name(NULL, "rockchip_suspend");
-
-	if (IS_ERR_OR_NULL(parent)) {
-		PM_ERR("%s dev node err\n", __func__);
-		return;
-	}
-
-	if (of_property_read_u32_array(parent, "rockchip,ctrbits"
-		, &pm_ctrbits, 1)) {
-			PM_ERR("%s:get pm ctr error\n", __func__);
-			return;
-	}
-	PM_LOG("%s: pm_ctrbits =%x\n", __func__, pm_ctrbits);
-	rkpm_set_ctrbits(pm_ctrbits);
-
-	clks_gating_suspend_init();
-	rkpm_set_ops_prepare_finish(rkpm_prepare, rkpm_finish);
-	rkpm_set_ops_plls(pm_plls_suspend, pm_plls_resume);
-
-	rkpm_set_ops_regs_pread(reg_pread);
-	rkpm_set_sram_ops_ddr(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(ddr_suspend))
-		, fn_to_pie(rockchip_pie_chunk, &FUNC(ddr_resume)));
-
-	rkpm_set_sram_ops_volt(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(pwm_regulator_suspend))
-		, fn_to_pie(rockchip_pie_chunk, &FUNC(pwm_regulator_resume)));
-
-
-	rkpm_set_sram_ops_printch(fn_to_pie(rockchip_pie_chunk
-		, &FUNC(sram_printch)));
-	rkpm_set_ops_printch(rk3036_ddr_printch);
-}
-#endif
-
-static void __init rk3036_init_suspend(void)
-{
-	pr_info("%s\n", __func__);
-	rockchip_suspend_init();
-	rkpm_pie_init();
-	rk3036_suspend_init();
-}
-
-static void __init rk3036_init_late(void)
-{
-#ifdef CONFIG_PM
-	rk3036_init_suspend();
-#endif
-}
-
-static void __init rk3036_reserve(void)
-{
-	/* reserve memory for ION */
-	rockchip_ion_reserve();
-}
-
-static void rk3036_restart(char mode, const char *cmd)
-{
-	u32 boot_flag, boot_mode;
-
-	rockchip_restart_get_boot_mode(cmd, &boot_flag, &boot_mode);
-	/* for loader */
-	writel_relaxed(boot_flag, RK_GRF_VIRT + RK3036_GRF_OS_REG4);
-	/* for linux */
-	writel_relaxed(boot_mode, RK_GRF_VIRT + RK3036_GRF_OS_REG5);
-	dsb();
-
-	/* pll enter slow mode */
-	writel_relaxed(0x30110000, RK_CRU_VIRT + RK3036_CRU_MODE_CON);
-	dsb();
-	writel_relaxed(0xeca8, RK_CRU_VIRT + RK3036_CRU_GLB_SRST_SND_VALUE);
-	dsb();
-}
-
-static const char *const rk3036_dt_compat[] __initconst = {
-	"rockchip,rk3036",
-	NULL,
-};
-
-DT_MACHINE_START(RK3036_DT, "Rockchip RK3036")
-	.dt_compat	= rk3036_dt_compat,
-	.smp		= smp_ops(rockchip_smp_ops),
-	.reserve	= rk3036_reserve,
-	.map_io		= rk3036_dt_map_io,
-	.init_time	= rk3036_dt_init_timer,
-	.init_late	= rk3036_init_late,
-	.reserve	= rk3036_reserve,
-	.restart	= rk3036_restart,
-MACHINE_END
diff --git a/arch/arm/mach-rockchip/rk30_camera.h b/arch/arm/mach-rockchip/rk30_camera.h
deleted file mode 100644
index 230060068b8b..000000000000
--- a/arch/arm/mach-rockchip/rk30_camera.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-    camera.h - PXA camera driver header file
-
-    Copyright (C) 2003, Intel Corporation
-    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#ifndef __ASM_ARCH_CAMERA_RK30_H_
-#define __ASM_ARCH_CAMERA_RK30_H_
-
-#define RK29_CAM_DRV_NAME "rk312x-camera"
-#define RK_SUPPORT_CIF0   1
-#define RK_SUPPORT_CIF1   0
-#define RK_CIF_NAME "rk_cif"
-#define RK_SENSOR_NAME "rk_sensor"
-
-#include "rk_camera.h"
-#include <dt-bindings/pinctrl/rockchip-rk3288.h>
-
-#define CONFIG_CAMERA_INPUT_FMT_SUPPORT     (RK_CAM_INPUT_FMT_YUV422)
-#ifdef CONFIG_SOC_RK3028
-#define CONFIG_CAMERA_SCALE_CROP_MACHINE    RK_CAM_SCALE_CROP_ARM
-#else
-#define CONFIG_CAMERA_SCALE_CROP_MACHINE    RK_CAM_SCALE_CROP_IPP
-#endif
-
-#if (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_ARM)
-    #define CAMERA_SCALE_CROP_MACHINE  "arm"
-#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_IPP)
-    #define CAMERA_SCALE_CROP_MACHINE  "ipp"
-#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_RGA)
-    #define CAMERA_SCALE_CROP_MACHINE  "rga"
-#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_PP)
-    #define CAMERA_SCALE_CROP_MACHINE  "pp"
-#endif
-
-
-#define CAMERA_VIDEOBUF_ARM_ACCESS   0
-
-#endif
-
diff --git a/arch/arm/mach-rockchip/rk3126b.c b/arch/arm/mach-rockchip/rk3126b.c
deleted file mode 100755
index 7ecdce7014dc..000000000000
--- a/arch/arm/mach-rockchip/rk3126b.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-#include "rk3126b.h"
-#define CPU 3126b
-#include "sram.h"
-#include "pm.h"
-#include "pm-rk312x.c"
-
-char PIE_DATA(sram_stack)[1024];
-EXPORT_PIE_SYMBOL(DATA(sram_stack));
-
-static int __init rk3126b_pie_init(void)
-{
-	int err;
-
-	if (!soc_is_rk3126b())
-		return 0;
-
-	err = rockchip_pie_init();
-	if (err)
-		return err;
-
-	rockchip_pie_chunk = pie_load_sections(rockchip_sram_pool, rk3126b);
-	if (IS_ERR(rockchip_pie_chunk)) {
-		err = PTR_ERR(rockchip_pie_chunk);
-		pr_err("%s: failed to load section %d\n", __func__, err);
-		rockchip_pie_chunk = NULL;
-		return err;
-	}
-
-	rockchip_sram_virt = kern_to_pie(rockchip_pie_chunk, &__pie_common_start[0]);
-	rockchip_sram_stack = kern_to_pie(rockchip_pie_chunk, (char *)DATA(sram_stack) + sizeof(DATA(sram_stack)));
-
-	return 0;
-}
-arch_initcall(rk3126b_pie_init);
-
-#ifdef CONFIG_PM
-void __init rk3126b_init_suspend(void)
-{
-	pr_info("%s\n", __func__);
-	rkpm_pie_init();
-	rk312x_suspend_init();
-}
-#endif
-
-#include "ddr_rk3126b.c"
-static int __init rk3126b_ddr_init(void)
-{
-	if (!soc_is_rk3126b())
-		return 0;
-
-	ddr_change_freq = _ddr_change_freq;
-	ddr_round_rate = _ddr_round_rate;
-	ddr_set_auto_self_refresh = _ddr_set_auto_self_refresh;
-	ddr_bandwidth_get = _ddr_bandwidth_get;
-	ddr_init(DDR3_DEFAULT, 0);
-
-	return 0;
-}
-arch_initcall_sync(rk3126b_ddr_init);
diff --git a/arch/arm/mach-rockchip/rk3126b.h b/arch/arm/mach-rockchip/rk3126b.h
deleted file mode 100644
index 188561cd5773..000000000000
--- a/arch/arm/mach-rockchip/rk3126b.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef __MACH_ROCKCHIP_RK3126B_H
-#define __MACH_ROCKCHIP_RK3126B_H
-
-void __init rk3126b_init_suspend(void);
-
-#endif
diff --git a/arch/arm/mach-rockchip/rk312x.c b/arch/arm/mach-rockchip/rk312x.c
deleted file mode 100755
index 91255c901ca1..000000000000
--- a/arch/arm/mach-rockchip/rk312x.c
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clocksource.h>
-#include <linux/cpuidle.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-/*#include <asm/cpuidle.h>*/
-#include <asm/cputype.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include "loader.h"
-#include "rk3126b.h"
-#define CPU 312x
-#include "sram.h"
-#include "pm.h"
-#include "pm-rk312x.c"
-#include <linux/rockchip/cpu.h>
-#define RK312X_DEVICE(name) \
-	{ \
-		.virtual	= (unsigned long) RK_##name##_VIRT, \
-		.pfn		= __phys_to_pfn(RK312X_##name##_PHYS), \
-		.length		= RK312X_##name##_SIZE, \
-		.type		= MT_DEVICE, \
-	}
-
-static const char * const rk3126_dt_compat[] __initconst = {
-	"rockchip,rk3126",
-	NULL,
-};
-
-static const char * const rk3128_dt_compat[] __initconst = {
-	"rockchip,rk3128",
-	NULL,
-};
-
-#define RK312X_IMEM_VIRT (RK_BOOTRAM_VIRT + SZ_32K)
-#define RK312X_TIMER5_VIRT (RK_TIMER_VIRT + 0xa0)
-
-static struct map_desc rk312x_io_desc[] __initdata = {
-	RK312X_DEVICE(CRU),
-	RK312X_DEVICE(GRF),
-	RK312X_DEVICE(ROM),
-	RK312X_DEVICE(PMU),
-	RK312X_DEVICE(EFUSE),
-	RK312X_DEVICE(TIMER),
-	RK312X_DEVICE(CPU_AXI_BUS),
-	RK_DEVICE(RK_DEBUG_UART_VIRT, RK312X_UART2_PHYS, RK312X_UART_SIZE),
-	RK_DEVICE(RK_DDR_VIRT, RK312X_DDR_PCTL_PHYS, RK312X_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK312X_DDR_PCTL_SIZE, RK312X_DDR_PHY_PHYS, RK312X_DDR_PHY_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(0), RK312X_GPIO0_PHYS, RK312X_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(1), RK312X_GPIO1_PHYS, RK312X_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(2), RK312X_GPIO2_PHYS, RK312X_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(3), RK312X_GPIO3_PHYS, RK312X_GPIO_SIZE),
-	RK_DEVICE(RK_GIC_VIRT, RK312X_GIC_DIST_PHYS, RK312X_GIC_DIST_SIZE),
-	RK_DEVICE(RK_GIC_VIRT + RK312X_GIC_DIST_SIZE, RK312X_GIC_CPU_PHYS, RK312X_GIC_CPU_SIZE),
-	RK_DEVICE(RK312X_IMEM_VIRT, RK312X_IMEM_PHYS, RK312X_IMEM_SIZE),
-	RK_DEVICE(RK_PWM_VIRT, RK312X_PWM_PHYS, RK312X_PWM_SIZE),
-};
-
-static void __init rk312x_boot_mode_init(void)
-{
-	u32 flag = readl_relaxed(RK_PMU_VIRT + RK312X_PMU_SYS_REG0);
-	u32 mode = readl_relaxed(RK_PMU_VIRT + RK312X_PMU_SYS_REG1);
-	u32 rst_st = readl_relaxed(RK_CRU_VIRT + RK312X_CRU_GLB_RST_ST);
-
-	if (flag == (SYS_KERNRL_REBOOT_FLAG | BOOT_RECOVER))
-		mode = BOOT_MODE_RECOVERY;
-	if (rst_st & ((1 << 2) | (1 << 3)))
-		mode = BOOT_MODE_WATCHDOG;
-
-	rockchip_boot_mode_init(flag, mode);
-}
-
-static void usb_uart_init(void)
-{
-#ifdef CONFIG_RK_USB_UART
-	u32 soc_status0 = readl_relaxed(RK_GRF_VIRT + RK312X_GRF_SOC_STATUS0);
-#endif
-	writel_relaxed(0x34000000, RK_GRF_VIRT + RK312X_GRF_UOC1_CON4);
-#ifdef CONFIG_RK_USB_UART
-	if (!(soc_status0 & (1 << 5)) && (soc_status0 & (1 << 8))) {
-		/* software control usb phy enable */
-		writel_relaxed(0x007f0055, RK_GRF_VIRT + RK312X_GRF_UOC0_CON0);
-		writel_relaxed(0x34003000, RK_GRF_VIRT + RK312X_GRF_UOC1_CON4);
-	}
-#endif
-
-	writel_relaxed(0x07, RK_DEBUG_UART_VIRT + 0x88);
-	writel_relaxed(0x00, RK_DEBUG_UART_VIRT + 0x04);
-	writel_relaxed(0x83, RK_DEBUG_UART_VIRT + 0x0c);
-	writel_relaxed(0x0d, RK_DEBUG_UART_VIRT + 0x00);
-	writel_relaxed(0x00, RK_DEBUG_UART_VIRT + 0x04);
-	writel_relaxed(0x03, RK_DEBUG_UART_VIRT + 0x0c);
-}
-
-static void __init rk312x_dt_map_io(void)
-{
-	u32 v;
-
-	iotable_init(rk312x_io_desc, ARRAY_SIZE(rk312x_io_desc));
-	debug_ll_io_init();
-	usb_uart_init();
-
-	/* pmu reset by second global soft reset */
-	v = readl_relaxed(RK_CRU_VIRT + RK312X_CRU_GLB_CNT_TH);
-	v &= ~(3 << 12);
-	v |= 1 << 12;
-	writel_relaxed(v, RK_CRU_VIRT + RK312X_CRU_GLB_CNT_TH);
-
-	/* enable timer5 for core */
-	writel_relaxed(0, RK312X_TIMER5_VIRT + 0x10);
-	dsb();
-	writel_relaxed(0xFFFFFFFF, RK312X_TIMER5_VIRT + 0x00);
-	writel_relaxed(0xFFFFFFFF, RK312X_TIMER5_VIRT + 0x04);
-	dsb();
-	writel_relaxed(1, RK312X_TIMER5_VIRT + 0x10);
-	dsb();
-	writel_relaxed(0x80000000, RK_CRU_VIRT + RK312X_CRU_MISC_CON);
-	dsb();
-
-	rk312x_boot_mode_init();
-	rockchip_efuse_init();
-}
-
-static void __init rk3126_dt_map_io(void)
-{
-	rockchip_soc_id = ROCKCHIP_SOC_RK3126;
-
-	rk312x_dt_map_io();
-
-	if (readl_relaxed(RK_GRF_VIRT + RK312X_GRF_CHIP_TAG) == 0x3136)
-		rockchip_soc_id = ROCKCHIP_SOC_RK3126B;
-}
-
-static void __init rk3128_dt_map_io(void)
-{
-	rockchip_soc_id = ROCKCHIP_SOC_RK3128;
-
-	rk312x_dt_map_io();
-}
-static DEFINE_SPINLOCK(pmu_idle_lock);
-static const u8 pmu_idle_map[] = {
-	[IDLE_REQ_PERI] = 0,
-	[IDLE_REQ_VIDEO] = 1,
-	[IDLE_REQ_VIO] = 2,
-	[IDLE_REQ_GPU] = 3,
-	[IDLE_REQ_CORE] = 4,
-	[IDLE_REQ_SYS] = 5,
-	[IDLE_REQ_MSCH] = 6,
-	[IDLE_REQ_CRYPTO] = 7,
-
-};
-static int rk312x_pmu_set_idle_request(enum pmu_idle_req req, bool idle)
-{
-	u32 val;
-	unsigned long flags;
-	u32 bit = pmu_idle_map[req];
-	u32 idle_mask = BIT(bit) | BIT(bit + 16);
-	u32 idle_target = (idle << bit) | (idle << (bit + 16));
-	u32 mask = BIT(bit);
-
-	spin_lock_irqsave(&pmu_idle_lock, flags);
-	val = pmu_readl(RK312X_PMU_IDLE_REQ);
-	if (idle)
-		val |= mask;
-	else
-		val &= ~mask;
-	pmu_writel(val, RK312X_PMU_IDLE_REQ);
-	dsb();
-
-	while (((pmu_readl(RK312X_PMU_IDLE_ST) & idle_mask) != idle_target))
-		;
-	spin_unlock_irqrestore(&pmu_idle_lock, flags);
-	return 0;
-}
-static const u8 pmu_pd_map[] = {
-	[PD_GPU] = 1,
-	[PD_VIDEO] = 2,
-	[PD_VIO] = 3,
-};
-
-static const u8 pmu_st_map[] = {
-	[PD_GPU] = 1,
-	[PD_VIDEO] = 2,
-	[PD_VIO] = 3,
-};
-
-static noinline void rk312x_do_pmu_set_power_domain(enum pmu_power_domain domain
-	, bool on)
-{
-	u8 pd = pmu_pd_map[domain];
-	u32 val = pmu_readl(RK312X_PMU_PWRDN_CON);
-
-	if (on)
-		val &= ~BIT(pd);
-	else
-		val |=  BIT(pd);
-	pmu_writel(val, RK312X_PMU_PWRDN_CON);
-	dsb();
-
-	while ((pmu_readl(RK312X_PMU_PWRDN_ST) & BIT(pmu_st_map[domain])) == on)
-		;
-}
-
-static bool rk312x_pmu_power_domain_is_on(enum pmu_power_domain pd)
-{
-	/*1"b0: power on, 1'b1: power off*/
-	return !(pmu_readl(RK312X_PMU_PWRDN_ST) & BIT(pmu_st_map[pd]));
-}
-static DEFINE_SPINLOCK(pmu_pd_lock);
-static u32 rga_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 ebc_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 iep_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 lcdc0_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 vip0_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 gpu_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-static u32 video_qos[RK312X_CPU_AXI_QOS_NUM_REGS];
-
-#define SAVE_QOS(array, NAME) RK312X_CPU_AXI_SAVE_QOS(array, RK312X_CPU_AXI_##NAME##_QOS_VIRT)
-#define RESTORE_QOS(array, NAME) RK312X_CPU_AXI_RESTORE_QOS(array, RK312X_CPU_AXI_##NAME##_QOS_VIRT)
-
-static int rk312x_pmu_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&pmu_pd_lock, flags);
-	if (rk312x_pmu_power_domain_is_on(pd) == on)
-		goto out;
-	if (!on) {
-		if (pd == PD_GPU) {
-			SAVE_QOS(gpu_qos, GPU);
-			rk312x_pmu_set_idle_request(IDLE_REQ_GPU, true);
-		} else if (pd == PD_VIO) {
-			SAVE_QOS(rga_qos, VIO_RGA);
-			if (!soc_is_rk3126b())
-				SAVE_QOS(ebc_qos, VIO_EBC);
-			SAVE_QOS(iep_qos, VIO_IEP);
-			SAVE_QOS(lcdc0_qos, VIO_LCDC0);
-			SAVE_QOS(vip0_qos, VIO_VIP0);
-			rk312x_pmu_set_idle_request(IDLE_REQ_VIO, true);
-		} else if (pd == PD_VIDEO) {
-			SAVE_QOS(video_qos, VIDEO);
-			rk312x_pmu_set_idle_request(IDLE_REQ_VIDEO, true);
-		}
-	}
-
-	rk312x_do_pmu_set_power_domain(pd, on);
-
-	if (on) {
-		if (pd == PD_GPU) {
-			rk312x_pmu_set_idle_request(IDLE_REQ_GPU, false);
-			RESTORE_QOS(gpu_qos, GPU);
-		} else if (pd == PD_VIO) {
-			rk312x_pmu_set_idle_request(IDLE_REQ_VIO, false);
-			RESTORE_QOS(rga_qos, VIO_RGA);
-			if (!soc_is_rk3126b())
-				RESTORE_QOS(ebc_qos, VIO_EBC);
-			RESTORE_QOS(iep_qos, VIO_IEP);
-			RESTORE_QOS(lcdc0_qos, VIO_LCDC0);
-			RESTORE_QOS(vip0_qos, VIO_VIP0);
-		} else if (pd == PD_VIDEO) {
-			rk312x_pmu_set_idle_request(IDLE_REQ_VIDEO, false);
-			RESTORE_QOS(video_qos, VIDEO);
-		}
-	}
-out:
-	spin_unlock_irqrestore(&pmu_pd_lock, flags);
-
-	return 0;
-}
-extern void secondary_startup(void);
-static int rk312x_sys_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	u32 clks_save[RK312X_CRU_CLKGATES_CON_CNT];
-	u32 clks_ungating[RK312X_CRU_CLKGATES_CON_CNT];
-	u32 i, ret = 0;
-
-	for (i = 0; i < RK312X_CRU_CLKGATES_CON_CNT; i++) {
-		clks_save[i] = cru_readl(RK312X_CRU_CLKGATES_CON(i));
-		clks_ungating[i] = 0;
-	}
-	for (i = 0; i < RK312X_CRU_CLKGATES_CON_CNT; i++)
-		cru_writel(0xffff0000, RK312X_CRU_CLKGATES_CON(i));
-
-	if (on) {
-#ifdef CONFIG_SMP
-		if (pd >= PD_CPU_1 && pd <= PD_CPU_3) {
-			writel_relaxed(0x20000 << (pd - PD_CPU_1),
-				       RK_CRU_VIRT + RK312X_CRU_SOFTRSTS_CON(0));
-			dsb();
-			udelay(10);
-			writel_relaxed(virt_to_phys(secondary_startup),
-				       RK312X_IMEM_VIRT + 8);
-			writel_relaxed(0xDEADBEAF, RK312X_IMEM_VIRT + 4);
-			dsb_sev();
-		}
-#endif
-	} else {
-#ifdef CONFIG_SMP
-		if (pd >= PD_CPU_1 && pd <= PD_CPU_3) {
-			writel_relaxed(0x20002 << (pd - PD_CPU_1),
-				       RK_CRU_VIRT + RK312X_CRU_SOFTRSTS_CON(0));
-			dsb();
-		}
-#endif
-	}
-
-	if (((pd == PD_GPU) || (pd == PD_VIO) || (pd == PD_VIDEO)))
-		ret = rk312x_pmu_set_power_domain(pd, on);
-
-	for (i = 0; i < RK312X_CRU_CLKGATES_CON_CNT; i++) {
-		cru_writel(clks_save[i] | 0xffff0000
-			, RK312X_CRU_CLKGATES_CON(i));
-	}
-
-	return ret;
-}
-
-static void __init rk312x_dt_init_timer(void)
-{
-	rockchip_pmu_ops.set_power_domain = rk312x_sys_set_power_domain;
-	rockchip_pmu_ops.power_domain_is_on = rk312x_pmu_power_domain_is_on;
-	rockchip_pmu_ops.set_idle_request = rk312x_pmu_set_idle_request;
-	of_clk_init(NULL);
-	clocksource_of_init();
-	of_dvfs_init();
-}
-
-static void __init rk312x_reserve(void)
-{
-	/* reserve memory for uboot */
-	rockchip_uboot_mem_reserve();
-
-	/* reserve memory for ION */
-	rockchip_ion_reserve();
-}
-
-#ifdef CONFIG_PM
-static u32 rk_pmu_pwrdn_st;
-
-static void rk_pm_soc_pd_suspend(void)
-{
-	rk_pmu_pwrdn_st = pmu_readl(RK312X_PMU_PWRDN_ST);
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_GPU])))
-		rk312x_sys_set_power_domain(PD_GPU, false);
-
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_VIO])))
-		rk312x_sys_set_power_domain(PD_VIO, false);
-
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_VIDEO])))
-		rk312x_sys_set_power_domain(PD_VIDEO, false);
-}
-
-static void rk_pm_soc_pd_resume(void)
-{
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_VIDEO])))
-		rk312x_sys_set_power_domain(PD_VIDEO, true);
-
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_VIO])))
-		rk312x_sys_set_power_domain(PD_VIO, true);
-
-	if (!(rk_pmu_pwrdn_st & BIT(pmu_st_map[PD_GPU])))
-		rk312x_sys_set_power_domain(PD_GPU, true);
-}
-
-static void __init rk312x_init_suspend(void)
-{
-	pr_info("%s\n", __func__);
-	rkpm_pie_init();
-	rk312x_suspend_init();
-}
-#endif
-
-static void __init rk312x_init_late(void)
-{
-#ifdef CONFIG_PM
-	rockchip_suspend_init();
-	if (soc_is_rk3126b())
-		rk3126b_init_suspend();
-	else
-		rk312x_init_suspend();
-	rkpm_set_ops_pwr_dmns(rk_pm_soc_pd_suspend, rk_pm_soc_pd_resume);
-#endif
-	if (rockchip_jtag_enabled)
-		clk_prepare_enable(clk_get_sys(NULL, "clk_jtag"));
-}
-
-static void rk312x_restart(char mode, const char *cmd)
-{
-	u32 boot_flag, boot_mode;
-
-	rockchip_restart_get_boot_mode(cmd, &boot_flag, &boot_mode);
-
-	/* for loader */
-	writel_relaxed(boot_flag, RK_PMU_VIRT + RK312X_PMU_SYS_REG0);
-	/* for linux */
-	writel_relaxed(boot_mode, RK_PMU_VIRT + RK312X_PMU_SYS_REG1);
-
-	dsb();
-
-	/* pll enter slow mode */
-	writel_relaxed(0x11010000, RK_CRU_VIRT + RK312X_CRU_MODE_CON);
-	dsb();
-	writel_relaxed(0xeca8, RK_CRU_VIRT + RK312X_CRU_GLB_SRST_SND_VALUE);
-	dsb();
-}
-
-DT_MACHINE_START(RK3126_DT, "Rockchip RK3126")
-	.smp		= smp_ops(rockchip_smp_ops),
-	.map_io		= rk3126_dt_map_io,
-	.init_time	= rk312x_dt_init_timer,
-	.dt_compat	= rk3126_dt_compat,
-	.init_late	= rk312x_init_late,
-	.reserve	= rk312x_reserve,
-	.restart	= rk312x_restart,
-MACHINE_END
-
-DT_MACHINE_START(RK3128_DT, "Rockchip RK3128")
-	.smp		= smp_ops(rockchip_smp_ops),
-	.map_io		= rk3128_dt_map_io,
-	.init_time	= rk312x_dt_init_timer,
-	.dt_compat	= rk3128_dt_compat,
-	.init_late	= rk312x_init_late,
-	.reserve	= rk312x_reserve,
-	.restart	= rk312x_restart,
-MACHINE_END
-
-
-char PIE_DATA(sram_stack)[1024];
-EXPORT_PIE_SYMBOL(DATA(sram_stack));
-
-static int __init rk312x_pie_init(void)
-{
-	int err;
-
-	if (!cpu_is_rk312x())
-		return 0;
-	if (soc_is_rk3126b())
-		return 0;
-
-	err = rockchip_pie_init();
-	if (err)
-		return err;
-
-	rockchip_pie_chunk = pie_load_sections(rockchip_sram_pool, rk312x);
-	if (IS_ERR(rockchip_pie_chunk)) {
-		err = PTR_ERR(rockchip_pie_chunk);
-		pr_err("%s: failed to load section %d\n", __func__, err);
-		rockchip_pie_chunk = NULL;
-		return err;
-	}
-
-	rockchip_sram_virt = kern_to_pie(rockchip_pie_chunk, &__pie_common_start[0]);
-	rockchip_sram_stack = kern_to_pie(rockchip_pie_chunk, (char *)DATA(sram_stack) + sizeof(DATA(sram_stack)));
-
-	return 0;
-}
-arch_initcall(rk312x_pie_init);
-
-#include "ddr_rk3126.c"
-static int __init rk312x_ddr_init(void)
-{
-	if (soc_is_rk3128() || soc_is_rk3126()) {
-		ddr_change_freq = _ddr_change_freq;
-		ddr_round_rate = _ddr_round_rate;
-		ddr_set_auto_self_refresh = _ddr_set_auto_self_refresh;
-		ddr_bandwidth_get = _ddr_bandwidth_get;
-		ddr_init(DDR3_DEFAULT, 0);
-	}
-
-	return 0;
-}
-arch_initcall_sync(rk312x_ddr_init);
diff --git a/arch/arm/mach-rockchip/rk312x_sleep.S b/arch/arm/mach-rockchip/rk312x_sleep.S
deleted file mode 100755
index 01aa1ecfa5bf..000000000000
--- a/arch/arm/mach-rockchip/rk312x_sleep.S
+++ /dev/null
@@ -1,163 +0,0 @@
-#include <linux/linkage.h>
-#include <asm/assembler.h>
-#include <asm/memory.h>
-
-#define _RKPM_SEELP_S_INCLUDE_
-#include "pm.h"
-
-.text
-ENTRY(rk312x_pm_slp_cpu_while_tst)
-stmfd  sp!, { r3 - r12, lr }
-
-1: mov r3,r3
-	b 1b
-
-ldmfd  sp!, { r3 - r12, pc }
-
-.data
-.align
-ENTRY(rk312x_pm_slp_cpu_resume)
-9:	mov r1,r1
-
-#if 0
-	ldr r4, = 0x20068000
-	mov r5, #67
-	str r5,[r4]
-#endif
-	setmode	PSR_I_BIT | PSR_F_BIT | SVC_MODE, r1  @ set SVC, irqs off
-
-	MRC p15,0,R1,c0,c0,5
-	AND     R1,R1,#0xf
-	CMP     R1,#0
-	BEQ     cpu0Run
-
-cpu1loop:
-	mov r3, #50
-	//str r3,[r4]
-	WFENE                   // ; wait if it.s locked
-	B     cpu1loop           //  ; if any failure, loop
-
-cpu0Run:
-	1:  mov r1,r1
-
-	adr r1,9b     // boot ram base
-	ldr r5,8f     // resume data  offset ,from ram base
-	add r5,r5,r1 // resume data addr
-
-	ldr r3 ,[r5,#(RKPM_BOOTDATA_ARM_ERRATA_818325_F*4)]
-	ldr r4, = 0x200080b4 // armvoltage pwm resume
-	and r2, r3, #1
-	cmp r2, #0
-	beq pwm1
-	ldr r2, = 0x00100010  //pwm0
-	str r2, [r4]
-pwm1:
-	and r2, r3, #2
-	cmp r2, #0
-	beq pwm2
-	ldr r2, = 0x00400040 //pwm1
-	str r2, [r4]
-pwm2:
-	and r2, r3, #4
-	cmp r2, #0
-	beq sp_set
-	ldr r2, = 0x01000100//pwm2
-	str r2, [r4]
-
-sp_set:        //sp
-	ldr sp,[r5,#(RKPM_BOOTDATA_CPUSP*4)]   //sp
-
-	ldr r3,[r5,#(RKPM_BOOTDATA_DDR_F*4)]
-	//get SLP_DDR_NEED_RES ,if it is 1 ,ddr need to reusme
-	cmp r3,#1
-	bne res
-	ldr r1,[r5,#(RKPM_BOOTDATA_DDRCODE*4)]  // ddr resume code
-	ldr r0,[r5,#(RKPM_BOOTDATA_DDRDATA*4)]  //ddr resume data
-	blx r1
-res:
-	1:  mov r1,r1
-	//  b 1b
-/*****************************************************************************/
-dram_resume:
-	;//push {lr}
-	mov r2,#0x20000000 ;/*cru PA*/
-	mov r3,#0x20000000
-
-	str r3,[r2,#0x14];/*PLL no power-down*/
-
-	dsb sy
-	mov r2,r2
-	mov r2,r2
-
-dpll_lock:
-	ldr r3,[r2,#0x14]
-	tst r3,#400;/*DPLL lock*/
-
-	bne dpll_lock
-
-	ldr r3,=0x00100010;/*DPLL normal mode*/
-	str r3,[r2,#0x40]
-	dsb sy
-
-	mov r3,#0x40000
-	str r3,[r2,#0xd0];/*enable DDR PHY clock*/
-	mov r0,#1
-
-dealyus_uncache:
-	mov r1,#5
-	mul r0, r0, r1
-delay_loop:
-	subs r0, r0, #1
-	bne delay_loop
-
-	ldr r2,=0x2000a000
-	ldr r3,[r2,#0]
-	orr r3, r3, #0x4;/*phy soft de-reset dll*/
-	str r3,[r2,#0]
-	mov r0,#5
-	mov r1,#5
-	mul r0, r0, r1
-delay5us_loop:
-	subs r0, r0, #1
-	bne delay5us_loop
-	orr r3, r3, #0x8;/*phy soft de-reset*/
-	str r3,[r2,#0]
-
-	sub r2,r2,#0x2000;/*0x20008000*/
-	ldr r3,[r2,#0x300];/*get chip id*/
-	sub r3,r3,#0x3100
-	subs r3,r3,#0x12
-	bne rk3126b_buffer_en;/*RK3126B*/
-	ldr r3,=0x40004
- 	str r3,[r2,#0x148];/*buffer en*/
-	b move_access
-rk3126b_buffer_en:
- 	ldr r2,=0x2000a000
-	mov r3,#0x2
-	str r3,[r2,#0x264]
-
-move_access:
-	/*move to access status*/
-    	ldr r2,=0x20004000
-	mov r3, #4
-	str r3,[r2,#0x4];/*wake up */
-	dsb sy
-
-wait_access:
-	ldr r3,[r2,#0x8]
-	and r3, r3, #0x7
-	cmp r3, #3
-	bne wait_access
-
-
-	ldr r4, = 0x100a000c //printk
-	mov r1, #0x0e //msch ce xiao
-	str r1,[r4]
-
-	ldr r4, = 0x100a0010 //printk
-	mov r1, #0x0e //msch ce xiao
-
-	ldr     pc, [r5,#(RKPM_BOOTDATA_CPUCODE*4)]
-8:      .long (0x00+0x700)//RKPM_BOOT_CODE_OFFSET+RKPM_BOOT_CODE_SIZE
-ENDPROC(rk312x_pm_slp_cpu_resume)
-
diff --git a/arch/arm/mach-rockchip/rk3188.c b/arch/arm/mach-rockchip/rk3188.c
deleted file mode 100755
index 093dce7ef688..000000000000
--- a/arch/arm/mach-rockchip/rk3188.c
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Device Tree support for Rockchip RK3188
- *
- * Copyright (C) 2013-2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clocksource.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include "loader.h"
-#include "sram.h"
-
-#define RK3188_DEVICE(name) \
-	{ \
-		.virtual	= (unsigned long) RK_##name##_VIRT, \
-		.pfn		= __phys_to_pfn(RK3188_##name##_PHYS), \
-		.length		= RK3188_##name##_SIZE, \
-		.type		= MT_DEVICE, \
-	}
-
-static struct map_desc rk3188_io_desc[] __initdata = {
-	RK3188_DEVICE(CRU),
-	RK3188_DEVICE(GRF),
-	RK3188_DEVICE(PMU),
-	RK3188_DEVICE(ROM),
-	RK3188_DEVICE(EFUSE),
-	RK3188_DEVICE(CPU_AXI_BUS),
-	RK_DEVICE(RK_DDR_VIRT, RK3188_DDR_PCTL_PHYS, RK3188_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK3188_DDR_PCTL_SIZE, RK3188_DDR_PUBL_PHYS, RK3188_DDR_PUBL_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(0), RK3188_GPIO0_PHYS, RK3188_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(1), RK3188_GPIO1_PHYS, RK3188_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(2), RK3188_GPIO2_PHYS, RK3188_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(3), RK3188_GPIO3_PHYS, RK3188_GPIO_SIZE),
-	RK_DEVICE(RK_DEBUG_UART_VIRT, RK3188_UART2_PHYS, RK3188_UART_SIZE),
-};
-
-static void __init rk3188_boot_mode_init(void)
-{
-	u32 flag = readl_relaxed(RK_PMU_VIRT + RK3188_PMU_SYS_REG0);
-	u32 mode = readl_relaxed(RK_PMU_VIRT + RK3188_PMU_SYS_REG1);
-
-	if (flag == (SYS_KERNRL_REBOOT_FLAG | BOOT_RECOVER)) {
-		mode = BOOT_MODE_RECOVERY;
-	}
-	rockchip_boot_mode_init(flag, mode);
-#ifdef CONFIG_RK29_WATCHDOG
-	writel_relaxed(BOOT_MODE_WATCHDOG, RK_PMU_VIRT + RK3188_PMU_SYS_REG1);
-#endif
-}
-static void usb_uart_init(void)
-{
-	u32 soc_status0;
-
-	writel_relaxed(0x03100000, RK_GRF_VIRT + RK3188_GRF_UOC0_CON0);
-	soc_status0 = (readl_relaxed(RK_GRF_VIRT + RK3188_GRF_SOC_STATUS0));
-
-#ifdef CONFIG_RK_USB_UART
-	if (!(soc_status0 & (1<<10)) && (soc_status0 & (1<<13))) {
-		/* software control usb phy enable */
-		writel_relaxed(0x00040004, RK_GRF_VIRT + RK3188_GRF_UOC0_CON2);
-		/* usb phy enter suspend */
-		writel_relaxed(0x003f002a, RK_GRF_VIRT + RK3188_GRF_UOC0_CON3);
-		writel_relaxed(0x03000300, RK_GRF_VIRT + RK3188_GRF_UOC0_CON0);
-    }    
-#endif
-}
-
-static void __init rk3188_dt_map_io(void)
-{
-	iotable_init(rk3188_io_desc, ARRAY_SIZE(rk3188_io_desc));
-	debug_ll_io_init();
-	usb_uart_init();
-
-	rockchip_soc_id = ROCKCHIP_SOC_RK3188;
-	if (readl_relaxed(RK_ROM_VIRT + 0x27f0) == 0x33313042
-	 && readl_relaxed(RK_ROM_VIRT + 0x27f4) == 0x32303133
-	 && readl_relaxed(RK_ROM_VIRT + 0x27f8) == 0x30313331
-	 && readl_relaxed(RK_ROM_VIRT + 0x27fc) == 0x56313031)
-		rockchip_soc_id = ROCKCHIP_SOC_RK3188PLUS;
-
-	/* rki2c is used instead of old i2c */
-	writel_relaxed(0xF800F800, RK_GRF_VIRT + RK3188_GRF_SOC_CON1);
-
-	rk3188_boot_mode_init();
-}
-
-static const u8 pmu_pd_map[] = {
-	[PD_CPU_0] = 0,
-	[PD_CPU_1] = 1,
-	[PD_CPU_2] = 2,
-	[PD_CPU_3] = 3,
-	[PD_SCU] = 4,
-	[PD_BUS] = 5,
-	[PD_PERI] = 6,
-	[PD_VIO] = 7,
-	[PD_VIDEO] = 8,
-	[PD_GPU] = 9,
-	[PD_CS] = 10,
-};
-
-static bool rk3188_pmu_power_domain_is_on(enum pmu_power_domain pd)
-{
-	/* 1'b0: power on, 1'b1: power off */
-	return !(readl_relaxed(RK_PMU_VIRT + RK3188_PMU_PWRDN_ST) & BIT(pmu_pd_map[pd]));
-}
-
-static noinline void rk3188_do_pmu_set_power_domain(enum pmu_power_domain domain, bool on)
-{
-	u8 pd = pmu_pd_map[domain];
-	u32 val = readl_relaxed(RK_PMU_VIRT + RK3188_PMU_PWRDN_CON);
-	if (on)
-		val &= ~BIT(pd);
-	else
-		val |=  BIT(pd);
-	writel_relaxed(val, RK_PMU_VIRT + RK3188_PMU_PWRDN_CON);
-	dsb();
-
-	while ((readl_relaxed(RK_PMU_VIRT + RK3188_PMU_PWRDN_ST) & BIT(pd)) == on)
-		;
-}
-
-static DEFINE_SPINLOCK(pmu_misc_con1_lock);
-
-static const u8 pmu_req_map[] = {
-	[IDLE_REQ_BUS] = 1,
-	[IDLE_REQ_PERI] = 2,
-	[IDLE_REQ_GPU] = 3,
-	[IDLE_REQ_VIDEO] = 4,
-	[IDLE_REQ_VIO] = 5,
-};
-
-static const u8 pmu_idle_map[] = {
-	[IDLE_REQ_DMA] = 14,
-	[IDLE_REQ_CORE] = 15,
-	[IDLE_REQ_VIO] = 22,
-	[IDLE_REQ_VIDEO] = 23,
-	[IDLE_REQ_GPU] = 24,
-	[IDLE_REQ_PERI] = 25,
-	[IDLE_REQ_BUS] = 26,
-};
-
-static const u8 pmu_ack_map[] = {
-	[IDLE_REQ_DMA] = 17,
-	[IDLE_REQ_CORE] = 18,
-	[IDLE_REQ_VIO] = 27,
-	[IDLE_REQ_VIDEO] = 28,
-	[IDLE_REQ_GPU] = 29,
-	[IDLE_REQ_PERI] = 30,
-	[IDLE_REQ_BUS] = 31,
-};
-
-static int rk3188_pmu_set_idle_request(enum pmu_idle_req req, bool idle)
-{
-	u32 idle_mask = BIT(pmu_idle_map[req]);
-	u32 idle_target = idle << pmu_idle_map[req];
-	u32 ack_mask = BIT(pmu_ack_map[req]);
-	u32 ack_target = idle << pmu_ack_map[req];
-	u32 mask = BIT(pmu_req_map[req]);
-	u32 val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&pmu_misc_con1_lock, flags);
-	val = readl_relaxed(RK_PMU_VIRT + RK3188_PMU_MISC_CON1);
-	if (idle)
-		val |=  mask;
-	else
-		val &= ~mask;
-	writel_relaxed(val, RK_PMU_VIRT + RK3188_PMU_MISC_CON1);
-	dsb();
-
-	while ((readl_relaxed(RK_PMU_VIRT + RK3188_PMU_PWRDN_ST) & ack_mask) != ack_target)
-		;
-	while ((readl_relaxed(RK_PMU_VIRT + RK3188_PMU_PWRDN_ST) & idle_mask) != idle_target)
-		;
-	spin_unlock_irqrestore(&pmu_misc_con1_lock, flags);
-
-	return 0;
-}
-
-/*
- *  software should power down or power up power domain one by one. Power down or
- *  power up multiple power domains simultaneously will result in chip electric current
- *  change dramatically which will affect the chip function.
- */
-static DEFINE_SPINLOCK(pmu_pd_lock);
-static u32 lcdc0_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 lcdc1_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 cif0_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 cif1_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 ipp_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 rga_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 gpu_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vpu_qos[CPU_AXI_QOS_NUM_REGS];
-
-#define SAVE_QOS(array, NAME) CPU_AXI_SAVE_QOS(array, RK3188_CPU_AXI_##NAME##_QOS_VIRT)
-#define RESTORE_QOS(array, NAME) CPU_AXI_RESTORE_QOS(array, RK3188_CPU_AXI_##NAME##_QOS_VIRT)
-
-static int rk3188_pmu_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&pmu_pd_lock, flags);
-	if (rk3188_pmu_power_domain_is_on(pd) == on) {
-		spin_unlock_irqrestore(&pmu_pd_lock, flags);
-		return 0;
-	}
-	if (!on) {
-		/* if power down, idle request to NIU first */
-		if (pd == PD_VIO) {
-			SAVE_QOS(lcdc0_qos, LCDC0);
-			SAVE_QOS(lcdc1_qos, LCDC1);
-			SAVE_QOS(cif0_qos, CIF0);
-			SAVE_QOS(cif1_qos, CIF1);
-			SAVE_QOS(ipp_qos, IPP);
-			SAVE_QOS(rga_qos, RGA);
-			rk3188_pmu_set_idle_request(IDLE_REQ_VIO, true);
-		} else if (pd == PD_VIDEO) {
-			SAVE_QOS(vpu_qos, VPU);
-			rk3188_pmu_set_idle_request(IDLE_REQ_VIDEO, true);
-		} else if (pd == PD_GPU) {
-			SAVE_QOS(gpu_qos, GPU);
-			rk3188_pmu_set_idle_request(IDLE_REQ_GPU, true);
-		}
-	}
-	rk3188_do_pmu_set_power_domain(pd, on);
-	if (on) {
-		/* if power up, idle request release to NIU */
-		if (pd == PD_VIO) {
-			rk3188_pmu_set_idle_request(IDLE_REQ_VIO, false);
-			RESTORE_QOS(lcdc0_qos, LCDC0);
-			RESTORE_QOS(lcdc1_qos, LCDC1);
-			RESTORE_QOS(cif0_qos, CIF0);
-			RESTORE_QOS(cif1_qos, CIF1);
-			RESTORE_QOS(ipp_qos, IPP);
-			RESTORE_QOS(rga_qos, RGA);
-		} else if (pd == PD_VIDEO) {
-			rk3188_pmu_set_idle_request(IDLE_REQ_VIDEO, false);
-			RESTORE_QOS(vpu_qos, VPU);
-		} else if (pd == PD_GPU) {
-			rk3188_pmu_set_idle_request(IDLE_REQ_GPU, false);
-			RESTORE_QOS(gpu_qos, GPU);
-		}
-	}
-	spin_unlock_irqrestore(&pmu_pd_lock, flags);
-
-	return 0;
-}
-
-static void __init rk3188_dt_init_timer(void)
-{
-	rockchip_pmu_ops.set_power_domain = rk3188_pmu_set_power_domain;
-	rockchip_pmu_ops.power_domain_is_on = rk3188_pmu_power_domain_is_on;
-	rockchip_pmu_ops.set_idle_request = rk3188_pmu_set_idle_request;
-	of_clk_init(NULL);
-	clocksource_of_init();
-	of_dvfs_init();
-}
-
-static void __init rk3188_reserve(void)
-{
-	/* reserve memory for ION */
-	rockchip_ion_reserve();
-}
-
-static const char * const rk3188_dt_compat[] __initconst = {
-	"rockchip,rk3188",
-	NULL,
-};
-
-static void rk3188_restart(char mode, const char *cmd)
-{
-	u32 boot_flag, boot_mode;
-
-	rockchip_restart_get_boot_mode(cmd, &boot_flag, &boot_mode);
-
-	writel_relaxed(boot_flag, RK_PMU_VIRT + RK3188_PMU_SYS_REG0);	// for loader
-	writel_relaxed(boot_mode, RK_PMU_VIRT + RK3188_PMU_SYS_REG1);	// for linux
-	dsb();
-
-	/* disable remap */
-	writel_relaxed(1 << (12 + 16), RK_GRF_VIRT + RK3188_GRF_SOC_CON0);
-	/* pll enter slow mode */
-	writel_relaxed(RK3188_PLL_MODE_SLOW(RK3188_APLL_ID) |
-		       RK3188_PLL_MODE_SLOW(RK3188_CPLL_ID) |
-		       RK3188_PLL_MODE_SLOW(RK3188_GPLL_ID),
-		       RK_CRU_VIRT + RK3188_CRU_MODE_CON);
-	dsb();
-	writel_relaxed(0xeca8, RK_CRU_VIRT + RK3188_CRU_GLB_SRST_SND);
-	dsb();
-}
-#ifdef CONFIG_PM
-static void __init rk3188_init_suspend(void);
-#endif
-DT_MACHINE_START(RK3188_DT, "RK30board")
-	.smp		= smp_ops(rockchip_smp_ops),
-	.map_io		= rk3188_dt_map_io,
-	.init_time	= rk3188_dt_init_timer,
-	.dt_compat	= rk3188_dt_compat,
-#ifdef CONFIG_PM
-	.init_late	= rk3188_init_suspend,
-#endif
-	.reserve	= rk3188_reserve,
-	.restart	= rk3188_restart,
-MACHINE_END
-
-#define CPU 3188
-char PIE_DATA(sram_stack)[1024];
-EXPORT_PIE_SYMBOL(DATA(sram_stack));
-
-static int __init rk3188_pie_init(void)
-{
-	int err;
-
-	if (!cpu_is_rk3188())
-		return 0;
-
-	err = rockchip_pie_init();
-	if (err)
-		return err;
-
-	rockchip_pie_chunk = pie_load_sections(rockchip_sram_pool, rk3188);
-	if (IS_ERR(rockchip_pie_chunk)) {
-		err = PTR_ERR(rockchip_pie_chunk);
-		pr_err("%s: failed to load section %d\n", __func__, err);
-		rockchip_pie_chunk = NULL;
-		return err;
-	}
-
-	rockchip_sram_virt = kern_to_pie(rockchip_pie_chunk, &__pie_common_start[0]);
-	rockchip_sram_stack = kern_to_pie(rockchip_pie_chunk, (char *) DATA(sram_stack) + sizeof(DATA(sram_stack)));
-
-	return 0;
-}
-arch_initcall(rk3188_pie_init);
-
-#ifdef CONFIG_PM
-#include "pm-rk3188.c"
-static void __init rk3188_init_suspend(void)
-{
-        rockchip_suspend_init();
-        rkpm_pie_init();
-        rk3188_suspend_init();
-}
-#endif
-#define CONFIG_ARCH_RK3188
-#define RK30_DDR_PCTL_BASE RK_DDR_VIRT
-#define RK30_DDR_PUBL_BASE (RK_DDR_VIRT + RK3188_DDR_PCTL_SIZE)
-#define rk_pll_flag() 0 /* FIXME */
-#define sram_printascii(s) do {} while (0) /* FIXME */
-#include "ddr_rk30.c"
-
-static int __init rk3188_ddr_init(void)
-{
-	if (cpu_is_rk3188()) {
-
-		ddr_change_freq = _ddr_change_freq;
-		ddr_round_rate = _ddr_round_rate;
-		ddr_set_auto_self_refresh = _ddr_set_auto_self_refresh;
-
-		ddr_init(DDR3_DEFAULT, 300);
-	}
-
-	return 0;
-}
-arch_initcall_sync(rk3188_ddr_init);
-
-
diff --git a/arch/arm/mach-rockchip/rk3228.c b/arch/arm/mach-rockchip/rk3228.c
deleted file mode 100644
index bd5c434f9214..000000000000
--- a/arch/arm/mach-rockchip/rk3228.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2015 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clocksource.h>
-#include <linux/cpuidle.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-#include <asm/cputype.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include "loader.h"
-#define CPU 3228
-#include "sram.h"
-#include <linux/rockchip/cpu.h>
-
-#define RK3228_DEVICE(name) \
-	{ \
-		.virtual	= (unsigned long) RK_##name##_VIRT, \
-		.pfn		= __phys_to_pfn(RK3228_##name##_PHYS), \
-		.length		= RK3228_##name##_SIZE, \
-		.type		= MT_DEVICE, \
-	}
-
-static const char * const rk3228_dt_compat[] __initconst = {
-	"rockchip,rk3228",
-	NULL,
-};
-
-static struct map_desc rk3228_io_desc[] __initdata = {
-	RK3228_DEVICE(CRU),
-	RK3228_DEVICE(GRF),
-	RK3228_DEVICE(TIMER),
-	RK3228_DEVICE(EFUSE),
-	RK3228_DEVICE(CPU_AXI_BUS),
-	RK_DEVICE(RK_DEBUG_UART_VIRT, RK3228_UART2_PHYS, RK3228_UART_SIZE),
-	RK_DEVICE(RK_DDR_VIRT, RK3228_DDR_PCTL_PHYS, RK3228_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK3228_DDR_PCTL_SIZE, RK3228_DDR_PHY_PHYS,
-		  RK3228_DDR_PHY_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(0), RK3228_GPIO0_PHYS, RK3228_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(1), RK3228_GPIO1_PHYS, RK3228_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(2), RK3228_GPIO2_PHYS, RK3228_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(3), RK3228_GPIO3_PHYS, RK3228_GPIO_SIZE),
-	RK_DEVICE(RK_GIC_VIRT, RK3228_GIC_DIST_PHYS, RK3228_GIC_DIST_SIZE),
-	RK_DEVICE(RK_GIC_VIRT + RK3228_GIC_DIST_SIZE, RK3228_GIC_CPU_PHYS,
-		  RK3228_GIC_CPU_SIZE),
-	RK_DEVICE(RK_PWM_VIRT, RK3228_PWM_PHYS, RK3228_PWM_SIZE),
-};
-
-void __init rk3228_dt_map_io(void)
-{
-	rockchip_soc_id = ROCKCHIP_SOC_RK3228;
-
-	iotable_init(rk3228_io_desc, ARRAY_SIZE(rk3228_io_desc));
-	debug_ll_io_init();
-
-	rockchip_efuse_init();
-}
-
-static void __init rk3228_dt_init_timer(void)
-{
-	of_clk_init(NULL);
-	clocksource_of_init();
-	of_dvfs_init();
-}
-
-static void __init rk3228_reserve(void)
-{
-	/* reserve memory for uboot */
-	rockchip_uboot_mem_reserve();
-
-	/* reserve memory for ION */
-	rockchip_ion_reserve();
-}
-
-static void __init rk3228_init_late(void)
-{
-	if (rockchip_jtag_enabled)
-		clk_prepare_enable(clk_get_sys(NULL, "clk_jtag"));
-}
-
-static void rk3228_restart(char mode, const char *cmd)
-{
-	u32 boot_flag, boot_mode;
-
-	rockchip_restart_get_boot_mode(cmd, &boot_flag, &boot_mode);
-
-	/* for loader */
-	writel_relaxed(boot_flag, RK_PMU_VIRT + RK3228_GRF_OS_REG0);
-	/* for linux */
-	writel_relaxed(boot_mode, RK_PMU_VIRT + RK3228_GRF_OS_REG1);
-
-	dsb();
-
-	/* pll enter slow mode */
-	writel_relaxed(0x11010000, RK_CRU_VIRT + RK3228_CRU_MODE_CON);
-	dsb();
-	writel_relaxed(0xeca8, RK_CRU_VIRT + RK3228_CRU_GLB_SRST_SND_VALUE);
-	dsb();
-}
-
-DT_MACHINE_START(RK3228_DT, "Rockchip RK3228")
-	.smp		= smp_ops(rockchip_smp_ops),
-	.map_io		= rk3228_dt_map_io,
-	.init_time	= rk3228_dt_init_timer,
-	.dt_compat	= rk3228_dt_compat,
-	.init_late	= rk3228_init_late,
-	.reserve	= rk3228_reserve,
-	.restart	= rk3228_restart,
-MACHINE_END
-
diff --git a/arch/arm/mach-rockchip/rk3288.c b/arch/arm/mach-rockchip/rk3288.c
deleted file mode 100755
index ca1ccbc40728..000000000000
--- a/arch/arm/mach-rockchip/rk3288.c
+++ /dev/null
@@ -1,697 +0,0 @@
-/*
- * Device Tree support for Rockchip RK3288
- *
- * Copyright (C) 2014 ROCKCHIP, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clocksource.h>
-#include <linux/cpuidle.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/irqchip.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/rockchip/common.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/cpu_axi.h>
-#include <linux/rockchip/cru.h>
-#include <linux/rockchip/dvfs.h>
-#include <linux/rockchip/grf.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/pmu.h>
-#include <linux/fb.h>
-#include <asm/cpuidle.h>
-#include <asm/cputype.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include "loader.h"
-#define CPU 3288
-#include "sram.h"
-#include "pm.h"
-
-#define RK3288_DEVICE(name) \
-	{ \
-		.virtual	= (unsigned long) RK_##name##_VIRT, \
-		.pfn		= __phys_to_pfn(RK3288_##name##_PHYS), \
-		.length		= RK3288_##name##_SIZE, \
-		.type		= MT_DEVICE, \
-	}
-
-#define RK3288_SERVICE_DEVICE(name) \
-	RK_DEVICE(RK3288_SERVICE_##name##_VIRT, RK3288_SERVICE_##name##_PHYS, RK3288_SERVICE_##name##_SIZE)
-
-#define RK3288_IMEM_VIRT (RK_BOOTRAM_VIRT + SZ_32K)
-#define RK3288_TIMER7_VIRT (RK_TIMER_VIRT + 0x20)
-
-static struct map_desc rk3288_io_desc[] __initdata = {
-	RK3288_DEVICE(CRU),
-	RK3288_DEVICE(GRF),
-	RK3288_DEVICE(SGRF),
-	RK3288_DEVICE(PMU),
-	RK3288_DEVICE(ROM),
-	RK3288_DEVICE(EFUSE),
-	RK3288_SERVICE_DEVICE(CORE),
-	RK3288_SERVICE_DEVICE(DMAC),
-	RK3288_SERVICE_DEVICE(GPU),
-	RK3288_SERVICE_DEVICE(PERI),
-	RK3288_SERVICE_DEVICE(VIO),
-	RK3288_SERVICE_DEVICE(VIDEO),
-	RK3288_SERVICE_DEVICE(HEVC),
-	RK3288_SERVICE_DEVICE(BUS),
-	RK_DEVICE(RK_DDR_VIRT, RK3288_DDR_PCTL0_PHYS, RK3288_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK3288_DDR_PCTL_SIZE, RK3288_DDR_PUBL0_PHYS, RK3288_DDR_PUBL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + RK3288_DDR_PCTL_SIZE + RK3288_DDR_PUBL_SIZE, RK3288_DDR_PCTL1_PHYS, RK3288_DDR_PCTL_SIZE),
-	RK_DEVICE(RK_DDR_VIRT + 2 * RK3288_DDR_PCTL_SIZE + RK3288_DDR_PUBL_SIZE, RK3288_DDR_PUBL1_PHYS, RK3288_DDR_PUBL_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(0), RK3288_GPIO0_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(1), RK3288_GPIO1_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(2), RK3288_GPIO2_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(3), RK3288_GPIO3_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(4), RK3288_GPIO4_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(5), RK3288_GPIO5_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(6), RK3288_GPIO6_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(7), RK3288_GPIO7_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_GPIO_VIRT(8), RK3288_GPIO8_PHYS, RK3288_GPIO_SIZE),
-	RK_DEVICE(RK_DEBUG_UART_VIRT, RK3288_UART_DBG_PHYS, RK3288_UART_SIZE),
-	RK_DEVICE(RK_GIC_VIRT, RK3288_GIC_DIST_PHYS, RK3288_GIC_DIST_SIZE),
-	RK_DEVICE(RK_GIC_VIRT + RK3288_GIC_DIST_SIZE, RK3288_GIC_CPU_PHYS, RK3288_GIC_CPU_SIZE),
-	RK_DEVICE(RK_BOOTRAM_VIRT, RK3288_BOOTRAM_PHYS, RK3288_BOOTRAM_SIZE),
-	RK_DEVICE(RK3288_IMEM_VIRT, RK3288_IMEM_PHYS, SZ_4K),
-	RK_DEVICE(RK_TIMER_VIRT, RK3288_TIMER6_PHYS, RK3288_TIMER_SIZE),
-};
-
-static void __init rk3288_boot_mode_init(void)
-{
-	u32 flag = readl_relaxed(RK_PMU_VIRT + RK3288_PMU_SYS_REG0);
-	u32 mode = readl_relaxed(RK_PMU_VIRT + RK3288_PMU_SYS_REG1);
-	u32 rst_st = readl_relaxed(RK_CRU_VIRT + RK3288_CRU_GLB_RST_ST);
-
-	if (flag == (SYS_KERNRL_REBOOT_FLAG | BOOT_RECOVER))
-		mode = BOOT_MODE_RECOVERY;
-	if (rst_st & ((1 << 4) | (1 << 5)))
-		mode = BOOT_MODE_WATCHDOG;
-	else if (rst_st & ((1 << 2) | (1 << 3)))
-		mode = BOOT_MODE_TSADC;
-	rockchip_boot_mode_init(flag, mode);
-}
-
-static void usb_uart_init(void)
-{
-	u32 soc_status2;
-
-	writel_relaxed(0x00c00000, RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
-	soc_status2 = (readl_relaxed(RK_GRF_VIRT + RK3288_GRF_SOC_STATUS2));
-
-#ifdef CONFIG_RK_USB_UART
-	if (!(soc_status2 & (1<<14)) && (soc_status2 & (1<<17))) {
-		/* software control usb phy enable */
-		writel_relaxed(0x00040004, RK_GRF_VIRT + RK3288_GRF_UOC0_CON2);
-		/* usb phy enter suspend */
-		writel_relaxed(0x003f002a, RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
-		writel_relaxed(0x00c000c0, RK_GRF_VIRT + RK3288_GRF_UOC0_CON3);
-	}
-#endif
-}
-
-extern void secondary_startup(void);
-
-static void __init rk3288_dt_map_io(void)
-{
-	u32 v;
-
-	rockchip_soc_id = ROCKCHIP_SOC_RK3288;
-
-	iotable_init(rk3288_io_desc, ARRAY_SIZE(rk3288_io_desc));
-	debug_ll_io_init();
-	usb_uart_init();
-
-	/* pmu reset by second global soft reset */
-	v = readl_relaxed(RK_CRU_VIRT + RK3288_CRU_GLB_RST_CON);
-	v &= ~(3 << 2);
-	v |= 1 << 2;
-	writel_relaxed(v, RK_CRU_VIRT + RK3288_CRU_GLB_RST_CON);
-
-	/* rkpwm is used instead of old pwm */
-	writel_relaxed(0x00010001, RK_GRF_VIRT + RK3288_GRF_SOC_CON2);
-
-	/* disable address remap */
-#ifndef CONFIG_ARM_TRUSTZONE
-	writel_relaxed(0x08000000, RK_SGRF_VIRT + RK3288_SGRF_SOC_CON0);
-#endif
-
-	/* enable timer7 for core */
-	writel_relaxed(0, RK3288_TIMER7_VIRT + 0x10);
-	dsb();
-	writel_relaxed(0xFFFFFFFF, RK3288_TIMER7_VIRT + 0x00);
-	writel_relaxed(0xFFFFFFFF, RK3288_TIMER7_VIRT + 0x04);
-	dsb();
-	writel_relaxed(1, RK3288_TIMER7_VIRT + 0x10);
-	dsb();
-
-	/* power up/down GPU domain wait 1us */
-	writel_relaxed(24, RK_PMU_VIRT + RK3288_PMU_GPU_PWRDWN_CNT);
-	writel_relaxed(24, RK_PMU_VIRT + RK3288_PMU_GPU_PWRUP_CNT);
-
-	rk3288_boot_mode_init();
-#ifndef CONFIG_ARM_TRUSTZONE
-	rockchip_efuse_init();
-#endif
-}
-
-static const u8 pmu_st_map[] = {
-	[PD_CPU_0] = 0,
-	[PD_CPU_1] = 1,
-	[PD_CPU_2] = 2,
-	[PD_CPU_3] = 3,
-	[PD_BUS] = 5,
-	[PD_PERI] = 6,
-	[PD_VIO] = 7,
-	[PD_VIDEO] = 8,
-	[PD_GPU] = 9,
-	[PD_HEVC] = 10,
-	[PD_SCU] = 11,
-};
-
-static bool rk3288_pmu_power_domain_is_on(enum pmu_power_domain pd)
-{
-	/* 1'b0: power on, 1'b1: power off */
-	return !(readl_relaxed(RK_PMU_VIRT + RK3288_PMU_PWRDN_ST) & BIT(pmu_st_map[pd]));
-}
-
-static DEFINE_SPINLOCK(pmu_idle_lock);
-
-static const u8 pmu_idle_map[] = {
-	[IDLE_REQ_BUS] = 0,
-	[IDLE_REQ_PERI] = 1,
-	[IDLE_REQ_GPU] = 2,
-	[IDLE_REQ_VIDEO] = 3,
-	[IDLE_REQ_VIO] = 4,
-	[IDLE_REQ_CORE] = 5,
-	[IDLE_REQ_ALIVE] = 6,
-	[IDLE_REQ_DMA] = 7,
-	[IDLE_REQ_CPUP] = 8,
-	[IDLE_REQ_HEVC] = 9,
-};
-
-static int rk3288_pmu_set_idle_request(enum pmu_idle_req req, bool idle)
-{
-	u32 bit = pmu_idle_map[req];
-	u32 idle_mask = BIT(bit) | BIT(bit + 16);
-	u32 idle_target = (idle << bit) | (idle << (bit + 16));
-	u32 mask = BIT(bit);
-	u32 val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&pmu_idle_lock, flags);
-	val = readl_relaxed(RK_PMU_VIRT + RK3288_PMU_IDLE_REQ);
-	if (idle)
-		val |=  mask;
-	else
-		val &= ~mask;
-	writel_relaxed(val, RK_PMU_VIRT + RK3288_PMU_IDLE_REQ);
-	dsb();
-
-	while ((readl_relaxed(RK_PMU_VIRT + RK3288_PMU_IDLE_ST) & idle_mask) != idle_target)
-		;
-	spin_unlock_irqrestore(&pmu_idle_lock, flags);
-
-	return 0;
-}
-
-static const u8 pmu_pd_map[] = {
-	[PD_CPU_0] = 0,
-	[PD_CPU_1] = 1,
-	[PD_CPU_2] = 2,
-	[PD_CPU_3] = 3,
-	[PD_BUS] = 5,
-	[PD_PERI] = 6,
-	[PD_VIO] = 7,
-	[PD_VIDEO] = 8,
-	[PD_GPU] = 9,
-	[PD_SCU] = 11,
-	[PD_HEVC] = 14,
-};
-
-static DEFINE_SPINLOCK(pmu_pd_lock);
-
-static noinline void rk3288_do_pmu_set_power_domain(enum pmu_power_domain domain, bool on)
-{
-	u8 pd = pmu_pd_map[domain];
-	u32 val = readl_relaxed(RK_PMU_VIRT + RK3288_PMU_PWRDN_CON);
-	if (on)
-		val &= ~BIT(pd);
-	else
-		val |=  BIT(pd);
-	writel_relaxed(val, RK_PMU_VIRT + RK3288_PMU_PWRDN_CON);
-	dsb();
-
-	while ((readl_relaxed(RK_PMU_VIRT + RK3288_PMU_PWRDN_ST) & BIT(pmu_st_map[domain])) == on)
-		;
-}
-
-static u32 gpu_r_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 gpu_w_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio0_iep_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio0_vip_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio0_vop_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio1_isp_r_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio1_isp_w0_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio1_isp_w1_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio1_vop_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio2_rga_r_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 vio2_rga_w_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 video_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 hevc_r_qos[CPU_AXI_QOS_NUM_REGS];
-static u32 hevc_w_qos[CPU_AXI_QOS_NUM_REGS];
-
-#define SAVE_QOS(array, NAME) CPU_AXI_SAVE_QOS(array, RK3288_CPU_AXI_##NAME##_QOS_VIRT)
-#define RESTORE_QOS(array, NAME) CPU_AXI_RESTORE_QOS(array, RK3288_CPU_AXI_##NAME##_QOS_VIRT)
-
-static int rk3288_pmu_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&pmu_pd_lock, flags);
-	if (rk3288_pmu_power_domain_is_on(pd) == on)
-		goto out;
-
-	if (!on) {
-		/* if power down, idle request to NIU first */
-		if (pd == PD_VIO) {
-			SAVE_QOS(vio0_iep_qos, VIO0_IEP);
-			SAVE_QOS(vio0_vip_qos, VIO0_VIP);
-			SAVE_QOS(vio0_vop_qos, VIO0_VOP);
-			SAVE_QOS(vio1_isp_r_qos, VIO1_ISP_R);
-			SAVE_QOS(vio1_isp_w0_qos, VIO1_ISP_W0);
-			SAVE_QOS(vio1_isp_w1_qos, VIO1_ISP_W1);
-			SAVE_QOS(vio1_vop_qos, VIO1_VOP);
-			SAVE_QOS(vio2_rga_r_qos, VIO2_RGA_R);
-			SAVE_QOS(vio2_rga_w_qos, VIO2_RGA_W);
-			rk3288_pmu_set_idle_request(IDLE_REQ_VIO, true);
-		} else if (pd == PD_VIDEO) {
-			SAVE_QOS(video_qos, VIDEO);
-			rk3288_pmu_set_idle_request(IDLE_REQ_VIDEO, true);
-		} else if (pd == PD_GPU) {
-			SAVE_QOS(gpu_r_qos, GPU_R);
-			SAVE_QOS(gpu_w_qos, GPU_W);
-			rk3288_pmu_set_idle_request(IDLE_REQ_GPU, true);
-		} else if (pd == PD_HEVC) {
-			SAVE_QOS(hevc_r_qos, HEVC_R);
-			SAVE_QOS(hevc_w_qos, HEVC_W);
-			rk3288_pmu_set_idle_request(IDLE_REQ_HEVC, true);
-		} else if (pd >= PD_CPU_1 && pd <= PD_CPU_3) {
-			writel_relaxed(0x20002 << (pd - PD_CPU_1), RK_CRU_VIRT + RK3288_CRU_SOFTRSTS_CON(0));
-			dsb();
-		}
-                 else if (pd == PD_PERI) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_PERI, true);
-		}
-        
-	}
-
-	rk3288_do_pmu_set_power_domain(pd, on);
-
-	if (on) {
-		/* if power up, idle request release to NIU */
-		if (pd == PD_VIO) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_VIO, false);
-			RESTORE_QOS(vio0_iep_qos, VIO0_IEP);
-			RESTORE_QOS(vio0_vip_qos, VIO0_VIP);
-			RESTORE_QOS(vio0_vop_qos, VIO0_VOP);
-			RESTORE_QOS(vio1_isp_r_qos, VIO1_ISP_R);
-			RESTORE_QOS(vio1_isp_w0_qos, VIO1_ISP_W0);
-			RESTORE_QOS(vio1_isp_w1_qos, VIO1_ISP_W1);
-			RESTORE_QOS(vio1_vop_qos, VIO1_VOP);
-			RESTORE_QOS(vio2_rga_r_qos, VIO2_RGA_R);
-			RESTORE_QOS(vio2_rga_w_qos, VIO2_RGA_W);
-		} else if (pd == PD_VIDEO) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_VIDEO, false);
-			RESTORE_QOS(video_qos, VIDEO);
-		} else if (pd == PD_GPU) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_GPU, false);
-			RESTORE_QOS(gpu_r_qos, GPU_R);
-			RESTORE_QOS(gpu_w_qos, GPU_W);
-		} else if (pd == PD_HEVC) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_HEVC, false);
-			RESTORE_QOS(hevc_r_qos, HEVC_R);
-			RESTORE_QOS(hevc_w_qos, HEVC_W);
-		} else if (pd >= PD_CPU_1 && pd <= PD_CPU_3) {
-#ifdef CONFIG_SMP
-			writel_relaxed(0x20000 << (pd - PD_CPU_1), RK_CRU_VIRT + RK3288_CRU_SOFTRSTS_CON(0));
-			dsb();
-			udelay(10);
-			writel_relaxed(virt_to_phys(secondary_startup), RK3288_IMEM_VIRT + 8);
-			writel_relaxed(0xDEADBEAF, RK3288_IMEM_VIRT + 4);
-			dsb_sev();
-#endif
-		}
-                else if (pd == PD_PERI) {
-			rk3288_pmu_set_idle_request(IDLE_REQ_PERI, false);
-		}
-	}
-
-out:
-	spin_unlock_irqrestore(&pmu_pd_lock, flags);
-	return 0;
-}
-
-static int rk3288_sys_set_power_domain(enum pmu_power_domain pd, bool on)
-{
-	u32 clks_ungating[RK3288_CRU_CLKGATES_CON_CNT];
-	u32 clks_save[RK3288_CRU_CLKGATES_CON_CNT];
-	u32 i, ret;
-
-	for (i = 0; i < RK3288_CRU_CLKGATES_CON_CNT; i++) {
-		clks_save[i] = cru_readl(RK3288_CRU_CLKGATES_CON(i));
-		clks_ungating[i] = 0;
-	}
-
-	switch (pd) {
-	case PD_GPU:
-		/* gpu */
-		clks_ungating[5] = 1 << 7;
-		/* aclk_gpu */
-		clks_ungating[18] = 1 << 0;
-		break;
-	case PD_VIDEO:
-		/* aclk_vdpu_src hclk_vpu aclk_vepu_src */
-		clks_ungating[3] = 1 << 11 | 1 << 10 | 1 << 9;
-		/* hclk_video aclk_video */
-		clks_ungating[9] = 1 << 1 | 1 << 0;
-		break;
-	case PD_VIO:
-		/* aclk_lcdc0/1_src dclk_lcdc0/1_src rga_core aclk_rga_src */
-		/* edp_24m edp isp isp_jpeg */
-		clks_ungating[3] =
-		    1 << 0 | 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 |
-		    1 << 12 | 1 << 13 | 1 << 14 | 1 << 15;
-		clks_ungating[15] = 0xffff;
-		clks_ungating[16] = 0x0fff;
-		break;
-	case PD_HEVC:
-		/* hevc_core hevc_cabac aclk_hevc */
-		clks_ungating[13] = 1 << 15 | 1 << 14 | 1 << 13;
-		break;
-#if 0
-	case PD_CS:
-		clks_ungating[12] = 1 << 11 | 1 < 10 | 1 << 9 | 1 << 8;
-		break;
-#endif
-	default:
-		break;
-	}
-
-	for (i = 0; i < RK3288_CRU_CLKGATES_CON_CNT; i++) {
-		if (clks_ungating[i])
-			cru_writel(clks_ungating[i] << 16, RK3288_CRU_CLKGATES_CON(i));
-	}
-
-	ret = rk3288_pmu_set_power_domain(pd, on);
-
-	for (i = 0; i < RK3288_CRU_CLKGATES_CON_CNT; i++) {
-		if (clks_ungating[i])
-			cru_writel(clks_save[i] | 0xffff0000, RK3288_CRU_CLKGATES_CON(i));
-	}
-
-	return ret;
-}
-
-static void __init rk3288_dt_init_timer(void)
-{
-	rockchip_pmu_ops.set_power_domain = rk3288_sys_set_power_domain;
-	rockchip_pmu_ops.power_domain_is_on = rk3288_pmu_power_domain_is_on;
-	rockchip_pmu_ops.set_idle_request = rk3288_pmu_set_idle_request;
-	of_clk_init(NULL);
-	clocksource_of_init();
-	of_dvfs_init();
-}
-
-static void __init rk3288_reserve(void)
-{
-	/* reserve memory for uboot */
-	rockchip_uboot_mem_reserve();
-
-	/* reserve memory for ION */
-	rockchip_ion_reserve();
-}
-
-static const char * const rk3288_dt_compat[] __initconst = {
-	"rockchip,rk3288",
-	NULL,
-};
-
-static void rk3288_restart(char mode, const char *cmd)
-{
-	u32 boot_flag, boot_mode;
-
-	rockchip_restart_get_boot_mode(cmd, &boot_flag, &boot_mode);
-
-	writel_relaxed(boot_flag, RK_PMU_VIRT + RK3288_PMU_SYS_REG0);	// for loader
-	writel_relaxed(boot_mode, RK_PMU_VIRT + RK3288_PMU_SYS_REG1);	// for linux
-	dsb();
-
-	/* pll enter slow mode */
-	writel_relaxed(0xf3030000, RK_CRU_VIRT + RK3288_CRU_MODE_CON);
-	dsb();
-	writel_relaxed(0xeca8, RK_CRU_VIRT + RK3288_CRU_GLB_SRST_SND_VALUE);
-	dsb();
-}
-
-static struct cpuidle_driver rk3288_cpuidle_driver = {
-	.name = "rk3288_cpuidle",
-	.owner = THIS_MODULE,
-	.states[0] = ARM_CPUIDLE_WFI_STATE,
-	.state_count = 1,
-};
-
-static int rk3288_cpuidle_enter(struct cpuidle_device *dev,
-		struct cpuidle_driver *drv, int index)
-{
-	void *sel = RK_CRU_VIRT + RK3288_CRU_CLKSELS_CON(36);
-	u32 con = readl_relaxed(sel);
-	u32 cpu = MPIDR_AFFINITY_LEVEL(read_cpuid_mpidr(), 0);
-	writel_relaxed(0x70007 << (cpu << 2), sel);
-	cpu_do_idle();
-	writel_relaxed((0x70000 << (cpu << 2)) | con, sel);
-	dsb();
-	return index;
-}
-
-static void __init rk3288_init_cpuidle(void)
-{
-	int ret;
-
-	if (!rockchip_jtag_enabled)
-		rk3288_cpuidle_driver.states[0].enter = rk3288_cpuidle_enter;
-	ret = cpuidle_register(&rk3288_cpuidle_driver, NULL);
-	if (ret)
-		pr_err("%s: failed to register cpuidle driver: %d\n", __func__, ret);
-}
-
-static int rk3288_pll_early_suspend_notifier_call(struct notifier_block *self,
-				unsigned long action, void *data)
-{
-	struct fb_event *event = data;
-	static bool enable = false;
-
-	if (action == FB_EARLY_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_UNBLANK:
-			if (!enable) {
-				clk_prepare_enable(clk_get_sys(NULL, "clk_cpll"));
-				clk_prepare_enable(clk_get_sys(NULL, "clk_npll"));
-				enable = true;
-			}
-			break;
-		default:
-			break;
-		}
-	} else if (action == FB_EVENT_BLANK) {
-		switch (*((int *)event->data)) {
-		case FB_BLANK_POWERDOWN:
-			if (enable) {
-				clk_disable_unprepare(clk_get_sys(NULL, "clk_cpll"));
-				clk_disable_unprepare(clk_get_sys(NULL, "clk_npll"));
-				enable = false;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block rk3288_pll_early_suspend_notifier = {
-	.notifier_call = rk3288_pll_early_suspend_notifier_call,
-};
-
-#ifdef CONFIG_PM
-static void __init rk3288_init_suspend(void);
-#endif
-static void __init rk3288_init_late(void)
-{
-#ifdef CONFIG_PM
-	rk3288_init_suspend();
-#endif
-#ifdef CONFIG_CPU_IDLE
-	rk3288_init_cpuidle();
-#endif
-	if (rockchip_jtag_enabled)
-		clk_prepare_enable(clk_get_sys(NULL, "clk_jtag"));
-}
-
-DT_MACHINE_START(RK3288_DT, "Rockchip RK3288 (Flattened Device Tree)")
-	.smp		= smp_ops(rockchip_smp_ops),
-	.map_io		= rk3288_dt_map_io,
-	.init_time	= rk3288_dt_init_timer,
-	.dt_compat	= rk3288_dt_compat,
-	.init_late	= rk3288_init_late,
-	.reserve	= rk3288_reserve,
-	.restart	= rk3288_restart,
-MACHINE_END
-
-char PIE_DATA(sram_stack)[1024];
-EXPORT_PIE_SYMBOL(DATA(sram_stack));
-
-static int __init rk3288_pie_init(void)
-{
-	int err;
-	if (!cpu_is_rk3288())
-		return 0;
-
-	err = rockchip_pie_init();
-	if (err)
-		return err;
-
-	rockchip_pie_chunk = pie_load_sections(rockchip_sram_pool, rk3288);
-	if (IS_ERR(rockchip_pie_chunk)) {
-		err = PTR_ERR(rockchip_pie_chunk);
-		pr_err("%s: failed to load section %d\n", __func__, err);
-		rockchip_pie_chunk = NULL;
-		return err;
-	}
-
-	rockchip_sram_virt = kern_to_pie(rockchip_pie_chunk, &__pie_common_start[0]);
-	rockchip_sram_stack = kern_to_pie(rockchip_pie_chunk, (char *) DATA(sram_stack) + sizeof(DATA(sram_stack)));
-
-    return 0;
-}
-arch_initcall(rk3288_pie_init);
-#ifdef CONFIG_PM
-#include "pm-rk3288.c"
-
-static u32 rk_pmu_pwrdn_st;
-static inline void rk_pm_soc_pd_suspend(void)
-{
-    rk_pmu_pwrdn_st = pmu_readl(RK3288_PMU_PWRDN_ST);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_GPU])))
-    rk3288_sys_set_power_domain(PD_GPU, false);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_HEVC])))
-    rk3288_sys_set_power_domain(PD_HEVC, false);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_VIO])))
-    rk3288_sys_set_power_domain(PD_VIO, false);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_VIDEO])))
-    rk3288_sys_set_power_domain(PD_VIDEO, false);
-#if 0
-    rkpm_ddr_printascii("pd state:");
-    rkpm_ddr_printhex(rk_pmu_pwrdn_st);        
-    rkpm_ddr_printhex(pmu_readl(RK3288_PMU_PWRDN_ST));        
-    rkpm_ddr_printascii("\n");
- #endif  
-}
-static inline void rk_pm_soc_pd_resume(void)
-{
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_GPU])))
-        rk3288_sys_set_power_domain(PD_GPU, true);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_HEVC])))
-        rk3288_sys_set_power_domain(PD_HEVC, true);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_VIO])))
-     rk3288_sys_set_power_domain(PD_VIO, true);
-
-    if(!(rk_pmu_pwrdn_st&BIT(pmu_st_map[PD_VIDEO])))
-        rk3288_sys_set_power_domain(PD_VIDEO, true);
-
-#if 0
-    rkpm_ddr_printascii("pd state:");
-    rkpm_ddr_printhex(pmu_readl(RK3288_PMU_PWRDN_ST));        
-    rkpm_ddr_printascii("\n");
-#endif    
-}
-void inline rkpm_periph_pd_dn(bool on)
-{
-    rk3288_sys_set_power_domain(PD_PERI, on);
-}
-
-static void __init rk3288_init_suspend(void)
-{
-    printk("%s\n",__FUNCTION__);
-    fb_register_client(&rk3288_pll_early_suspend_notifier);
-    rockchip_suspend_init();       
-    rkpm_pie_init();
-    rk3288_suspend_init();
-   rkpm_set_ops_pwr_dmns(rk_pm_soc_pd_suspend,rk_pm_soc_pd_resume);
-}
-
-#if 0
-extern bool console_suspend_enabled;
-
-static int  __init rk3288_pm_dbg(void)
-{
-#if 1    
-        console_suspend_enabled=0;
-        do{
-            pm_suspend(PM_SUSPEND_MEM);
-        }
-        while(1);
-        
-#endif
-
-}
-
-//late_initcall_sync(rk3288_pm_dbg);
-#endif
-
-
-#endif
-#define sram_printascii(s) do {} while (0) /* FIXME */
-#include "ddr_rk32.c"
-
-static int __init rk3288_ddr_init(void)
-{
-    if (cpu_is_rk3288()
-#ifdef CONFIG_ARM_TRUSTZONE
-	&& false
-#endif
-	)
-    {
-	ddr_change_freq = _ddr_change_freq;
-	ddr_round_rate = _ddr_round_rate;
-	ddr_set_auto_self_refresh = _ddr_set_auto_self_refresh;
-	ddr_bandwidth_get = _ddr_bandwidth_get;
-
-	ddr_init(DDR3_DEFAULT, 0);
-    }
-
-    return 0;
-}
-arch_initcall_sync(rk3288_ddr_init);
-
diff --git a/arch/arm/mach-rockchip/rk_camera.c b/arch/arm/mach-rockchip/rk_camera.c
deleted file mode 100755
index 8813d3982098..000000000000
--- a/arch/arm/mach-rockchip/rk_camera.c
+++ /dev/null
@@ -1,1280 +0,0 @@
-#include "rk_camera.h"
-#include "rk30_camera.h"
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <linux/version.h>
-#include <linux/moduleparam.h>
-#include <linux/of_gpio.h>
-#include <linux/of.h>
-#include <linux/of_irq.h>
-#include <linux/kernel.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/of_fdt.h>
-#include <linux/module.h>
-#include <linux/regulator/consumer.h>
-
-
-static int camio_version = KERNEL_VERSION(0,1,9); 
-module_param(camio_version, int, S_IRUGO);
-
-static int camera_debug = 0; 
-module_param(camera_debug, int, S_IRUGO|S_IWUSR);    
-
-#undef  CAMMODULE_NAME
-#define CAMMODULE_NAME   "rk_cam_io"
-
-#define ddprintk(level, fmt, arg...) do {			\
-	if (camera_debug >= level) 					\
-	    printk(KERN_WARNING"%s(%d):" fmt"\n", CAMMODULE_NAME,__LINE__,## arg); } while (0)
-
-#define dprintk(format, ...) ddprintk(1, format, ## __VA_ARGS__)  
-#define eprintk(format, ...) printk(KERN_ERR "%s(%d):" format"\n",CAMMODULE_NAME,__LINE__,## __VA_ARGS__)  
-#define debug_printk(format, ...) ddprintk(3, format, ## __VA_ARGS__)  
-
-static int rk_sensor_io_init(void);
-static int rk_sensor_io_deinit(int sensor);
-static int rk_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on);
-static int rk_sensor_power(struct device *dev, int on);
-static int rk_sensor_register(void);
-/*static int rk_sensor_reset(struct device *dev);*/
-
-static int rk_dts_sensor_probe(struct platform_device *pdev);
-static int rk_dts_sensor_remove(struct platform_device *pdev);
-static int rk_dts_cif_probe(struct platform_device *pdev);
-static int rk_dts_cif_remove(struct platform_device *pdev);
-
-static int rk_sensor_powerdown(struct device *dev, int on);
-
-static struct rkcamera_platform_data *new_camera_head;	
-
-static struct rk29camera_platform_data rk_camera_platform_data = {
-    .io_init = rk_sensor_io_init,
-    .io_deinit = rk_sensor_io_deinit,
-    .sensor_ioctrl = rk_sensor_ioctrl,
-    .sensor_register = rk_sensor_register,
-
-};
-
-struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
-	.sensor_power_cb = NULL,
-	.sensor_reset_cb = NULL,
-	.sensor_powerdown_cb = NULL,
-	.sensor_flash_cb = NULL,
-	.sensor_af_cb = NULL,
-};
-
-
-static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
-#if RK_SUPPORT_CIF0
-static struct resource rk_camera_resource_host_0[2] = {};
-#endif
-#if RK_SUPPORT_CIF1
-static struct resource rk_camera_resource_host_1[2] = {};
-#endif
-
-#if RK_SUPPORT_CIF0
- struct platform_device rk_device_camera_host_0 = {
-	.name		  = RK29_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_0,				/* This is used to put cameras on this interface*/ 
-	.num_resources= 2,
-	.resource	  = rk_camera_resource_host_0,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data,
-	}
-};
-#endif
-
-#if RK_SUPPORT_CIF1
- struct platform_device rk_device_camera_host_1 = {
-	.name		  = RK29_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_1,				/* This is used to put cameras on this interface */
-	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_1),
-	.resource	  = rk_camera_resource_host_1,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data,
-	}
-};
-#endif
-
-
-
-static const struct of_device_id of_match_cif[] = {
-    { .compatible = "rockchip,cif" },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of,of_match_cif);
-static struct platform_driver rk_cif_driver =
-{
-    .driver 	= {
-        .name	= RK_CIF_NAME,              
-		.owner = THIS_MODULE,
-        .of_match_table = of_match_ptr(of_match_cif),
-    },
-    .probe		= rk_dts_cif_probe,
-    .remove		= rk_dts_cif_remove,
-};
-
-static const struct of_device_id of_match_sensor[] = {
-    { .compatible = "rockchip,sensor" },
-};
-MODULE_DEVICE_TABLE(of,of_match_sensor);
-static struct platform_driver rk_sensor_driver =
-{
-    .driver 	= {
-        .name	= RK_SENSOR_NAME,              
-		.owner  = THIS_MODULE,
-        .of_match_table = of_match_ptr(of_match_sensor),
-    },
-    .probe		= rk_dts_sensor_probe,
-    .remove		= rk_dts_sensor_remove,
-};
-
-unsigned long rk_cif_grf_base;
-unsigned long rk_cif_cru_base;
-
-static int rk_dts_sensor_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-static int	rk_dts_sensor_probe(struct platform_device *pdev)
-{
-	struct device_node *np, *cp;
-	int sensor_num = 0,err;
-	struct device *dev = &pdev->dev;
-	struct rkcamera_platform_data *new_camera_list;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-	
-	np = dev->of_node;
-	if (!np)
-		return -ENODEV;
-	for_each_child_of_node(np, cp) {
-		u32 flash_attach = 0,mir = 0,i2c_rata = 0,i2c_chl = 0,i2c_add = 0;
-		u32 cif_chl = 0, mclk_rate = 0, is_front = 0;
-		u32 resolution = 0, powerup_sequence = 0;
-		
-		u32	powerdown = INVALID_GPIO,power = INVALID_GPIO,reset = INVALID_GPIO;
-		u32 af = INVALID_GPIO,flash = INVALID_GPIO;
-
-		int pwr_active = 0, rst_active = 0, pwdn_active = 0,flash_active = 0;
-		int orientation = 0;
-		struct rkcamera_platform_data *new_camera; 
-		
-		char sensor_name[20] = {0};
-		char *name = NULL;
-		
-		strcpy(sensor_name,cp->name);
-		name = sensor_name;
-		if(strstr(sensor_name,"_") != NULL){			
-			name = strsep(&name,"_");
-		}
-
-		new_camera = kzalloc(sizeof(struct rkcamera_platform_data),GFP_KERNEL);
-		if(!sensor_num)
-		{			
-			new_camera_head = new_camera;
-			rk_camera_platform_data.register_dev_new = new_camera_head;
-			new_camera_list = new_camera;
-		}
-		sensor_num ++;
-		new_camera_list->next_camera = new_camera;
-		new_camera_list = new_camera;
-
-		if (of_property_read_u32(cp, "flash_attach", &flash_attach)) {
-			dprintk("%s:Get %s rockchip,flash_attach failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "mir", &mir)) {
-			dprintk("%s:Get %s rockchip,mir failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "i2c_rata", &i2c_rata)) {
-			dprintk("%s:Get %s rockchip,i2c_rata failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "i2c_chl", &i2c_chl)) {
-			dprintk("%s:Get %s rockchip,i2c_chl failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "cif_chl", &cif_chl)) {
-			dprintk("%s:Get %s rockchip,cif_chl failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "mclk_rate", &mclk_rate)) {
-			dprintk("%s:Get %s rockchip,mclk_rate failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "is_front", &is_front)) {
-			dprintk("%s:Get %s rockchip,is_front failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,powerdown", &powerdown)) {
-				printk("%s:Get %s rockchip,powerdown failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "pwdn_active", &pwdn_active)) {
-				dprintk("%s:Get %s pwdn_active failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,power", &power)) {
-				printk("%s:Get %s rockchip,power failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "pwr_active", &pwr_active)) {
-				dprintk("%s:Get %s pwr_active failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,reset", &reset)) {
-				dprintk("%s:Get %s rockchip,reset failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rst_active", &rst_active)) {
-				dprintk("%s:Get %s rst_active failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,af", &af)) {
-				dprintk("%s:Get %s rockchip,af failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,flash", &flash)) {
-				dprintk("%s:Get %s rockchip,flash failed!\n",__func__, cp->name);				
-		}		
-		if (of_property_read_u32(cp, "flash_active", &flash_active)) {
-				dprintk("%s:Get %s flash_active failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "i2c_add", &i2c_add)) {
-			printk("%s:Get %s rockchip,i2c_add failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "resolution", &resolution)) {
-			printk("%s:Get %s rockchip,resolution failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "powerup_sequence", &powerup_sequence)) {
-			printk("%s:Get %s rockchip,powerup_sequence failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "orientation", &orientation)) {
-			printk("%s:Get %s rockchip,orientation failed!\n",__func__, cp->name);				
-		}
-		
-		strcpy(new_camera->dev.i2c_cam_info.type, name);
-		new_camera->dev.i2c_cam_info.addr = i2c_add>>1;
-		new_camera->dev.desc_info.host_desc.bus_id = RK29_CAM_PLATFORM_DEV_ID+cif_chl;
-		new_camera->dev.desc_info.host_desc.i2c_adapter_id = i2c_chl;
-		new_camera->dev.desc_info.host_desc.module_name = name;
-		new_camera->dev.device_info.name = "soc-camera-pdrv";
-		if(is_front)
-			sprintf(new_camera->dev_name,"%s_%s",name,"front");
-		else
-			sprintf(new_camera->dev_name,"%s_%s",name,"back");
-		new_camera->dev.device_info.dev.init_name =(const char*)&new_camera->dev_name[0];
-		new_camera->io.gpio_reset = reset;
-		new_camera->io.gpio_powerdown = powerdown;
-		new_camera->io.gpio_power = power;
-		new_camera->io.gpio_af = af;
-		new_camera->io.gpio_flash = flash;
-		new_camera->io.gpio_flag = ((pwr_active&0x01)<<RK29_CAM_POWERACTIVE_BITPOS)
-									|((rst_active&0x01)<<RK29_CAM_RESETACTIVE_BITPOS)
-									|((pwdn_active&0x01)<<RK29_CAM_POWERDNACTIVE_BITPOS)
-									|((flash_active&0x01)<<RK29_CAM_FLASHACTIVE_BITPOS);
-		new_camera->orientation = orientation;
-		new_camera->resolution = resolution;
-		new_camera->mirror = mir;
-		new_camera->i2c_rate = i2c_rata;
-		new_camera->flash = flash_attach;
-		new_camera->pwdn_info = ((pwdn_active&0x10)|0x01);
-		new_camera->powerup_sequence = powerup_sequence;
-		new_camera->mclk_rate = mclk_rate;
-		new_camera->of_node = cp;
-		
-		new_camera->powerdown_pmu_name = NULL;
-		new_camera->power_pmu_name1 = NULL;
-		new_camera->power_pmu_name2 = NULL;
-		new_camera->powerdown_pmu_voltage = 0;
-		new_camera->power_pmu_name1 = 0;
-		new_camera->power_pmu_name2 = 0;
-		err = of_property_read_string(cp,"rockchip,powerdown_pmu",&(new_camera->powerdown_pmu_name));	
-		if(err < 0)	{
-			dprintk("Get rockchip,powerdown_pmu failed\n");
-		}
-		err = of_property_read_string(cp,"rockchip,power_pmu_name1",&(new_camera->power_pmu_name1));	
-		if(err < 0)	{
-			dprintk("Get rockchip,power_pmu_name1 failed\n");
-		}
-		err = of_property_read_string(cp,"rockchip,power_pmu_name2",&(new_camera->power_pmu_name2));	
-		if(err < 0){
-			dprintk("rockchip,power_pmu_name2 failed\n");
-		}
-		
-		if (of_property_read_u32(cp, "rockchip,powerdown_pmu_voltage", &(new_camera->powerdown_pmu_voltage))) {
-			dprintk("%s:Get %s rockchip,resolution failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,power_pmu_voltage1", &(new_camera->power_pmu_voltage1))) {
-			dprintk("%s:Get %s rockchip,resolution failed!\n",__func__, cp->name);				
-		}
-		if (of_property_read_u32(cp, "rockchip,power_pmu_voltage2", &(new_camera->power_pmu_voltage2))) {
-			dprintk("%s:Get %s rockchip,resolution failed!\n",__func__, cp->name);				
-		}
-			debug_printk( "******************* /n power = %x\n", power);
-			debug_printk( "******************* /n powerdown = %x\n", powerdown);
-			debug_printk( "******************* /n i2c_add = %x\n", new_camera->dev.i2c_cam_info.addr << 1);
-			debug_printk( "******************* /n i2c_chl = %d\n", new_camera->dev.desc_info.host_desc.i2c_adapter_id);
-			debug_printk( "******************* /n init_name = %s\n", new_camera->dev.device_info.dev.init_name);
-			debug_printk( "******************* /n dev_name = %s\n", new_camera->dev_name);
-			debug_printk( "******************* /n module_name = %s\n", new_camera->dev.desc_info.host_desc.module_name);
-	};
-	new_camera_list->next_camera = NULL;
-	return 0;
-}
-	
-static int rk_dts_cif_remove(struct platform_device *pdev)
-{
-	 return 0;
-}
-	
-static int rk_dts_cif_probe(struct platform_device *pdev)
-{
-	int irq,err;
-	struct device *dev = &pdev->dev;
-	const char *compatible = NULL;	
-	struct device_node * vpu_node =NULL;	
-    int vpu_iommu_enabled = 0;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-	
-	rk_camera_platform_data.cif_dev = &pdev->dev;
-	
-	err = of_address_to_resource(dev->of_node, 0, &rk_camera_resource_host_0[0]);
-	if (err < 0){
-		printk(KERN_EMERG "Get register resource from %s platform device failed!",pdev->name);
-		return -ENODEV;
-	}
-	rk_camera_resource_host_0[0].flags = IORESOURCE_MEM;
-	/*map irqs*/
-	irq = irq_of_parse_and_map(dev->of_node, 0);
-	if (irq < 0) {
-		printk(KERN_EMERG "Get irq resource from %s platform device failed!",pdev->name);
-		return -ENODEV;;
-	}
-	err = of_property_read_string(dev->of_node->parent,"compatible",&compatible);	
-	rk_camera_platform_data.rockchip_name = compatible;
-
-    vpu_node = of_find_node_by_name(NULL, "vpu_service");
-    if(vpu_node){
-        err = of_property_read_u32(vpu_node, "iommu_enabled", &vpu_iommu_enabled);
-		rk_camera_platform_data.iommu_enabled = vpu_iommu_enabled;
-    	of_node_put(vpu_node);
-	}else{
-		printk("get vpu_node failed,vpu_iommu_enabled == 0 !!!!!!\n");
-	}
-	
-	if(strstr(rk_camera_platform_data.rockchip_name,"3368")){
-		//get cru base
-	    vpu_node = of_parse_phandle(dev->of_node, "rockchip,cru", 0);
-	    rk_cif_cru_base = (unsigned long)of_iomap(vpu_node, 0);
-		debug_printk(">>>>>>>rk_cif_cru_base=0x%lx",rk_cif_cru_base);
-		
-		//get grf base
-	    vpu_node = of_parse_phandle(dev->of_node, "rockchip,grf", 0);
-	    rk_cif_grf_base = (unsigned long)of_iomap(vpu_node, 0);
-		debug_printk(">>>>>>>rk_cif_grf_base=0x%lx",rk_cif_grf_base);
-	}
-	
-	if (err < 0){
-		printk(KERN_EMERG "Get rockchip compatible failed!!!!!!");
-		return -ENODEV;
-	}
-	
-	//printk(KERN_ERR "***************%s*************\n", rk_camera_platform_data.rockchip_name);
-	rk_camera_resource_host_0[1].start = irq;
-	rk_camera_resource_host_0[1].end   = irq;
-	rk_camera_resource_host_0[1].flags = IORESOURCE_IRQ;
-	return 0;
-}
-	
-static int rk_cif_sensor_init(void)
-{
-	
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-	platform_driver_register(&rk_cif_driver);	
-		
-	platform_driver_register(&rk_sensor_driver);	
-
-	return 0;
-}
-
-static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
-{
-    int camera_power = res->gpio_power;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;    
-    int ret = 0;
-	
-    struct regulator *ldo_18,*ldo_28;
-	struct rkcamera_platform_data *dev = container_of(res,struct rkcamera_platform_data,io);
-	
-	int power_pmu_voltage1 = dev->power_pmu_voltage1;
-	int power_pmu_voltage2 = dev->power_pmu_voltage2;
-	const char *camera_power_pmu_name1 = dev->power_pmu_name1;
-    const char *camera_power_pmu_name2 = dev->power_pmu_name2;;
-	
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-	if(camera_power_pmu_name1 != NULL)	{
-		ldo_28 = regulator_get(NULL, camera_power_pmu_name1);	// vcc28_cif
-        if (on) {
-			regulator_set_voltage(ldo_28, power_pmu_voltage1, power_pmu_voltage1);
-			ret = regulator_enable(ldo_28);
-			//printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
-			regulator_put(ldo_28);
-			
-			msleep(10);
-		} else {
-			while(regulator_is_enabled(ldo_28)>0)	
-				regulator_disable(ldo_28);
-			regulator_put(ldo_28);
-		}		
-	}
-	
-	if(camera_power_pmu_name2 != NULL)	{		
-		ldo_18 = regulator_get(NULL, camera_power_pmu_name2);	// vcc18_cif
-        if (on) {
-			regulator_set_voltage(ldo_18, power_pmu_voltage2, power_pmu_voltage2);
-			//regulator_set_suspend_voltage(ldo, 1800000);
-			ret = regulator_enable(ldo_18);
-			//printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
-			regulator_put(ldo_18);
-			
-			msleep(10);
-		} else {
-			while(regulator_is_enabled(ldo_18)>0)
-				regulator_disable(ldo_18);
-			regulator_put(ldo_18);
-		}		
-	}
-	
-    if (camera_power != INVALID_GPIO)  {
-		if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
-            if (on) {
-            	gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-				dprintk("%s PowerPin=%d ..PinLevel = %x",res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-				msleep(10);
-    		} else {
-    			gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-				dprintk("%s PowerPin=%d ..PinLevel = %x",res->dev_name, camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-			}
-		} else {
-			ret = RK29_CAM_EIO_REQUESTFAIL;
-			eprintk("%s PowerPin=%d request failed!", res->dev_name,camera_power);
-	    }        
-    }
-	else {
-		ret = RK29_CAM_EIO_INVALID;
-    } 
-
-    return ret;
-}
-
-static int sensor_reset_default_cb (struct rk29camera_gpio_res *res, int on)
-{
-    int camera_reset = res->gpio_reset;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-    
-    if (camera_reset != INVALID_GPIO) {
-		if (camera_io_init & RK29_CAM_RESETACTIVE_MASK) {
-			if (on) {
-	        	gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-	        	dprintk("%s ResetPin=%d ..PinLevel = %x",res->dev_name,camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-			} else {
-				gpio_set_value(camera_reset,(((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-        		dprintk("%s ResetPin= %d..PinLevel = %x",res->dev_name, camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-			}
-		} else {
-			ret = RK29_CAM_EIO_REQUESTFAIL;
-			eprintk("%s ResetPin=%d request failed!", res->dev_name,camera_reset);
-		}
-    } else {
-		ret = RK29_CAM_EIO_INVALID;
-    }
-
-    return ret;
-}
-
-static int sensor_powerdown_default_cb (struct rk29camera_gpio_res *res, int on)
-{
-    int camera_powerdown = res->gpio_powerdown;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0; 
-	
-    struct regulator *powerdown_pmu;	
-	struct rkcamera_platform_data *dev = container_of(res,struct rkcamera_platform_data,io);
-	int powerdown_pmu_voltage = dev->powerdown_pmu_voltage;
-	const char *powerdown_pmu_name = dev->powerdown_pmu_name;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-	if(powerdown_pmu_name != NULL)	{		
-		powerdown_pmu = regulator_get(NULL, powerdown_pmu_name);
-		if (on) {
-			regulator_set_voltage(powerdown_pmu, powerdown_pmu_voltage, powerdown_pmu_voltage);
-			ret = regulator_enable(powerdown_pmu);
-			regulator_put(powerdown_pmu);
-		} else {
-			while(regulator_is_enabled(powerdown_pmu)>0)	
-				regulator_disable(powerdown_pmu);
-			regulator_put(powerdown_pmu);		
-		}		
-	}
-	
-    if (camera_powerdown != INVALID_GPIO) {
-		if (camera_io_init & RK29_CAM_POWERDNACTIVE_MASK) {
-			if (on) {
-	        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-	        	dprintk("%s PowerDownPin=%d ..PinLevel = %x" ,res->dev_name,camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-			} else {
-				gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-        		dprintk("%s PowerDownPin= %d..PinLevel = %x" ,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-			}
-		} else {
-			ret = RK29_CAM_EIO_REQUESTFAIL;
-			dprintk("%s PowerDownPin=%d request failed!", res->dev_name,camera_powerdown);
-		}
-    }else {
-		ret = RK29_CAM_EIO_INVALID;
-    }
-    return ret;
-}
-
-
-static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
-{
-    int camera_flash = res->gpio_flash;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0;    
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-    if (camera_flash != INVALID_GPIO) {
-		if (camera_io_init & RK29_CAM_FLASHACTIVE_MASK) {
-            switch (on)
-            {
-                case Flash_Off:
-                {
-                    gpio_set_value(camera_flash,(((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-        		    dprintk("%s FlashPin= %d..PinLevel = %x", res->dev_name, camera_flash, (((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS)); 
-        		    break;
-                }
-
-                case Flash_On:
-                {
-                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("%s FlashPin=%d ..PinLevel = %x", res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    break;
-                }
-
-                case Flash_Torch:
-                {
-                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("%s FlashPin=%d ..PinLevel = %x", res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-	        	    break;
-                }
-
-                default:
-                {
-                    eprintk("%s Flash command(%d) is invalidate", res->dev_name,on);
-                    break;
-                }
-            }
-		} else {
-			ret = RK29_CAM_EIO_REQUESTFAIL;
-			eprintk("%s FlashPin=%d request failed!", res->dev_name,camera_flash);
-		}
-    } else {
-		ret = RK29_CAM_EIO_INVALID;
-    }
-    return ret;
-}
-
-static int sensor_afpower_default_cb (struct rk29camera_gpio_res *res, int on)
-{
-	int ret = 0;   
-	int camera_af = res->gpio_af;
-	
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-	
-	if (camera_af != INVALID_GPIO) {
-		gpio_set_value(camera_af, on);
-	}
-
-	return ret;
-}
-
-static int _rk_sensor_io_init_(struct rk29camera_gpio_res *gpio_res,struct device_node *of_node)
-{
-    int ret = 0;
-    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
-	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
-	unsigned int camera_af = INVALID_GPIO,camera_ioflag;
-    struct rk29camera_gpio_res *io_res;
-    bool io_requested_in_camera;
-	enum of_gpio_flags flags;
-	
-	struct rkcamera_platform_data *new_camera;
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-
-    camera_reset = gpio_res->gpio_reset;
-	camera_power = gpio_res->gpio_power;
-	camera_powerdown = gpio_res->gpio_powerdown;
-	camera_flash = gpio_res->gpio_flash;
-	camera_af = gpio_res->gpio_af;	
-	camera_ioflag = gpio_res->gpio_flag;
-	gpio_res->gpio_init = 0;
-
-    if (camera_power != INVALID_GPIO) {
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_power  = %x\n", camera_power );
-
-		camera_power = of_get_named_gpio_flags(of_node,"rockchip,power",0,&flags);
-		gpio_res->gpio_power = camera_power;/* information back to the IO*/
-
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_power  = %x\n", camera_power );  
-
-		ret = gpio_request(camera_power, "camera power"); 
-        if (ret) {
-			
-            io_requested_in_camera = false;
-
-            if (io_requested_in_camera==false) {
-
-				new_camera = new_camera_head;
-                while (new_camera != NULL) {
-                    io_res = &new_camera->io;
-                    if (io_res->gpio_init & RK29_CAM_POWERACTIVE_MASK) {
-                        if (io_res->gpio_power == camera_power)
-                            io_requested_in_camera = true;    
-                    }
-                    new_camera = new_camera->next_camera;
-                }
-
-            }
-            
-            if (io_requested_in_camera==false) {
-                printk( "%s power pin(%d) init failed\n", gpio_res->dev_name,camera_power);
-                goto _rk_sensor_io_init_end_;
-            } else {
-                ret =0;
-            }
-        }
-      
-		gpio_res->gpio_init |= RK29_CAM_POWERACTIVE_MASK;
-        gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-        gpio_direction_output(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-
-		dprintk("%s power pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
-
-    }
-
-    if (camera_reset != INVALID_GPIO) {
-		
-		camera_power = of_get_named_gpio_flags(of_node,"rockchip,reset",0,&flags);
-		gpio_res->gpio_reset = camera_reset;/* information back to the IO*/
-        ret = gpio_request(camera_reset, "camera reset");
-        if (ret) {
-            io_requested_in_camera = false;
-
-            if (io_requested_in_camera==false) {
-				
-                new_camera = new_camera_head;
-                while (new_camera != NULL) {
-                    io_res = &new_camera->io;
-                    if (io_res->gpio_init & RK29_CAM_RESETACTIVE_MASK) {
-                        if (io_res->gpio_reset == camera_reset)
-                            io_requested_in_camera = true;    
-                    }
-                    new_camera = new_camera->next_camera;
-                }
-            }
-            
-            if (io_requested_in_camera==false) {
-                eprintk("%s reset pin(%d) init failed" ,gpio_res->dev_name,camera_reset);
-                goto _rk_sensor_io_init_end_;
-            } else {
-                ret =0;
-            }
-        }
-       
-		gpio_res->gpio_init |= RK29_CAM_RESETACTIVE_MASK;
-        gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-        gpio_direction_output(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-
-		dprintk("%s reset pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
-
-    }
-
-	if (camera_powerdown != INVALID_GPIO) {
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_powerdown  = %x\n", camera_powerdown );
-
-		camera_powerdown = of_get_named_gpio_flags(of_node,"rockchip,powerdown",0,&flags);
-		gpio_res->gpio_powerdown = camera_powerdown;/*information back to the IO*/
-
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_powerdown  = %x\n", camera_powerdown );  
-		ret = gpio_request(camera_powerdown, "camera powerdown");
-        if (ret) {
-            io_requested_in_camera = false;
-
-            if (io_requested_in_camera==false) {
-				
-                new_camera = new_camera_head;
-                while (new_camera != NULL) {
-                    io_res = &new_camera->io;
-                    if (io_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
-                        if (io_res->gpio_powerdown == camera_powerdown)
-                            io_requested_in_camera = true;    
-                    }
-                    new_camera = new_camera->next_camera;
-                }
-            }
-            
-            if (io_requested_in_camera==false) {
-                eprintk("%s powerdown pin(%d) init failed",gpio_res->dev_name,camera_powerdown);
-                goto _rk_sensor_io_init_end_;
-            } else {
-                ret =0;
-            }
-        }
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s(),iomux is ok\n", __FILE__, __LINE__,__FUNCTION__);
-        
-		gpio_res->gpio_init |= RK29_CAM_POWERDNACTIVE_MASK;
-        gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-        gpio_direction_output(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-
-		dprintk("%s powerdown pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
-
-    }
-
-	if (camera_flash != INVALID_GPIO) {
-
-		camera_flash = of_get_named_gpio_flags(of_node,"rockchip,flash",0,&flags);
-		gpio_res->gpio_flash = camera_flash;/* information back to the IO*/
-        ret = gpio_request(camera_flash, "camera flash");
-        if (ret) {
-            io_requested_in_camera = false;
-
-            if (io_requested_in_camera==false) {
-
-				new_camera = new_camera_head;
-                while (new_camera != NULL) {
-                    io_res = &new_camera->io;
-                    if (io_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
-                        if (io_res->gpio_powerdown == camera_powerdown)
-                            io_requested_in_camera = true;    
-                    }
-                    new_camera = new_camera->next_camera;
-                }
-            }
-            
-            ret = 0;        //ddl@rock-chips.com : flash is only a function, sensor is also run;
-            if (io_requested_in_camera==false) {
-                eprintk("%s flash pin(%d) init failed",gpio_res->dev_name,camera_flash);
-                goto _rk_sensor_io_init_end_;
-            }
-        }
-
-
-        
-		gpio_res->gpio_init |= RK29_CAM_FLASHACTIVE_MASK;
-        gpio_set_value(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));   //  falsh off 
-        gpio_direction_output(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-
-		dprintk("%s flash pin(%d) init success(0x%x)",gpio_res->dev_name, camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
-
-    }  
-
-	if (camera_af != INVALID_GPIO) {
-		
-		camera_af = of_get_named_gpio_flags(of_node,"rockchip,af",0,&flags);
-		gpio_res->gpio_af = camera_af;/* information back to the IO*/
-		ret = gpio_request(camera_af, "camera af");
-		if (ret) {
-			io_requested_in_camera = false;
-
-			if (io_requested_in_camera==false) {
-
-				new_camera = new_camera_head;
-				while (new_camera != NULL) {
-					io_res = &new_camera->io;
-					if (io_res->gpio_init & RK29_CAM_AFACTIVE_MASK) {
-						if (io_res->gpio_af == camera_af)
-							io_requested_in_camera = true;	  
-					}
-					new_camera = new_camera->next_camera;
-				}
-			}
-			
-			if (io_requested_in_camera==false) {
-				eprintk("%s af pin(%d) init failed",gpio_res->dev_name,camera_af);
-				goto _rk_sensor_io_init_end_;
-			} else {
-                ret =0;
-            }
-			
-		}
-		
-		gpio_res->gpio_init |= RK29_CAM_AFACTIVE_MASK;
-		//gpio_direction_output(camera_af, ((camera_ioflag&RK29_CAM_AFACTIVE_MASK)>>RK29_CAM_AFACTIVE_BITPOS));
-		dprintk("%s af pin(%d) init success",gpio_res->dev_name, camera_af);
-
-	}
-
-	
-_rk_sensor_io_init_end_:
-    return ret;
-
-}
-
-static int _rk_sensor_io_deinit_(struct rk29camera_gpio_res *gpio_res)
-{
-    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
-	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO,camera_af = INVALID_GPIO;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-    
-    camera_reset = gpio_res->gpio_reset;
-    camera_power = gpio_res->gpio_power;
-	camera_powerdown = gpio_res->gpio_powerdown;
-    camera_flash = gpio_res->gpio_flash;
-    camera_af = gpio_res->gpio_af;
-
-	if (gpio_res->gpio_init & RK29_CAM_POWERACTIVE_MASK) {
-	    if (camera_power != INVALID_GPIO) {
-	        gpio_direction_input(camera_power);
-	        gpio_free(camera_power);
-	    }
-	}
-
-	if (gpio_res->gpio_init & RK29_CAM_RESETACTIVE_MASK) {
-	    if (camera_reset != INVALID_GPIO)  {
-	        gpio_direction_input(camera_reset);
-	        gpio_free(camera_reset);
-	    }
-	}
-
-	if (gpio_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
-	    if (camera_powerdown != INVALID_GPIO)  {
-	        gpio_direction_input(camera_powerdown);
-	        gpio_free(camera_powerdown);
-	    }
-	}
-
-	if (gpio_res->gpio_init & RK29_CAM_FLASHACTIVE_MASK) {
-	    if (camera_flash != INVALID_GPIO)  {
-	        gpio_direction_input(camera_flash);
-	        gpio_free(camera_flash);
-	    }
-	}
-	if (gpio_res->gpio_init & RK29_CAM_AFACTIVE_MASK) {
-	    if (camera_af != INVALID_GPIO)  {
-	       /* gpio_direction_input(camera_af);*/
-	        gpio_free(camera_af);
-	    }
-	}	
-	gpio_res->gpio_init = 0;
-	
-    return 0;
-}
-
-static int rk_sensor_io_init(void)
-{
-	static bool is_init = false;
-	
-	struct rkcamera_platform_data *new_camera;
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-    if(is_init) {		
-		return 0;
-	} else {
-		is_init = true;
-	}
-    
-    if (sensor_ioctl_cb.sensor_power_cb == NULL)
-        sensor_ioctl_cb.sensor_power_cb = sensor_power_default_cb;
-    if (sensor_ioctl_cb.sensor_reset_cb == NULL)
-        sensor_ioctl_cb.sensor_reset_cb = sensor_reset_default_cb;
-    if (sensor_ioctl_cb.sensor_powerdown_cb == NULL)
-        sensor_ioctl_cb.sensor_powerdown_cb = sensor_powerdown_default_cb;
-    if (sensor_ioctl_cb.sensor_flash_cb == NULL)
-        sensor_ioctl_cb.sensor_flash_cb = sensor_flash_default_cb;
-    if (sensor_ioctl_cb.sensor_af_cb == NULL)
-        sensor_ioctl_cb.sensor_af_cb = sensor_afpower_default_cb;	
-
-	new_camera = new_camera_head;
-	while(new_camera != NULL)
-	{
-		if (_rk_sensor_io_init_(&new_camera->io,new_camera->of_node)<0)
-            _rk_sensor_io_deinit_(&new_camera->io);
-		new_camera = new_camera->next_camera;
-	}
-	return 0;
-}
-
-static int rk_sensor_io_deinit(int sensor)
-{
-	struct rkcamera_platform_data *new_camera;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-	new_camera = new_camera_head;
-	while(new_camera != NULL)
-	{
-		_rk_sensor_io_deinit_(&new_camera->io);
-		new_camera = new_camera->next_camera;
-	}
-
-    return 0;
-}
-static int rk_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on)
-{
-    struct rk29camera_gpio_res *res = NULL;
-    struct rkcamera_platform_data *new_cam_dev = NULL;
-	struct rk29camera_platform_data* plat_data = &rk_camera_platform_data;
-    int ret = RK29_CAM_IO_SUCCESS,i = 0;
-	struct soc_camera_desc *dev_icl = NULL;
-	struct rkcamera_platform_data *new_camera;
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-    if (res == NULL) {
-		new_camera = new_camera_head;
-		while(new_camera != NULL)
-		{
-            if (strcmp(new_camera->dev_name, dev_name(dev)) == 0) {
-                res = (struct rk29camera_gpio_res *)&new_camera->io; 
-                new_cam_dev = &new_camera[i];
-				 dev_icl = &new_camera->dev.desc_info;
-                break;
-            }
-            new_camera = new_camera->next_camera;;
-        }		
-    }
-    
-    if (res == NULL) {
-        eprintk("%s is not regisiterd in rk29_camera_platform_data!!",dev_name(dev));
-        ret = RK29_CAM_EIO_INVALID;
-        goto rk_sensor_ioctrl_end;
-    }
-	
-	switch (cmd)
- 	{
- 		case Cam_Power:
-		{
-			if (sensor_ioctl_cb.sensor_power_cb) {
-                ret = sensor_ioctl_cb.sensor_power_cb(res, on);   
-                ret = (ret != RK29_CAM_EIO_INVALID)?ret:0;     /* ddl@rock-chips.com: v0.1.1 */ 
-			} else {
-                eprintk("sensor_ioctl_cb.sensor_power_cb is NULL");
-                WARN_ON(1);
-			}
-
-			printk("ret: %d\n",ret);
-			break;
-		}
-		case Cam_Reset:
-		{
-			if (sensor_ioctl_cb.sensor_reset_cb) {
-                ret = sensor_ioctl_cb.sensor_reset_cb(res, on);
-
-                ret = (ret != RK29_CAM_EIO_INVALID)?ret:0;
-			} else {
-                eprintk( "sensor_ioctl_cb.sensor_reset_cb is NULL");
-                WARN_ON(1);
-			}
-			break;
-		}
-
-		case Cam_PowerDown:
-		{
-			if (sensor_ioctl_cb.sensor_powerdown_cb) {
-                ret = sensor_ioctl_cb.sensor_powerdown_cb(res, on);
-			} else {
-                eprintk( "sensor_ioctl_cb.sensor_powerdown_cb is NULL");
-                WARN_ON(1);
-			}
-			break;
-		}
-
-		case Cam_Flash:
-		{
-			if (sensor_ioctl_cb.sensor_flash_cb) {
-                ret = sensor_ioctl_cb.sensor_flash_cb(res, on);
-			} else {
-                eprintk( "sensor_ioctl_cb.sensor_flash_cb is NULL!");
-                WARN_ON(1);
-			}
-			break;
-		}
-		
-		case Cam_Af:
-		{
-			if (sensor_ioctl_cb.sensor_af_cb) {
-                ret = sensor_ioctl_cb.sensor_af_cb(res, on);
-			} else {
-                eprintk( "sensor_ioctl_cb.sensor_af_cb is NULL!");
-                WARN_ON(1);
-			}
-			break;
-		}
-
-        case Cam_Mclk:
-        {
-            if (plat_data->sensor_mclk && dev_icl) {
-				plat_data->sensor_mclk(dev_icl->host_desc.bus_id,(on!=0)?1:0,on);
-            } else { 
-                eprintk( "%s(%d): sensor_mclk(%p) or dev_icl(%p) is NULL",
-                    __FUNCTION__,__LINE__,plat_data->sensor_mclk,dev_icl);
-            }
-            break;
-        }
-        
-		default:
-		{
-			eprintk("%s cmd(0x%x) is unknown!",__FUNCTION__, cmd);
-			break;
-		}
- 	}
-rk_sensor_ioctrl_end:
-    return ret;
-}
-
-static int rk_sensor_pwrseq(struct device *dev,int powerup_sequence, int on, int mclk_rate)
-{
-    int ret =0;
-    int i,powerup_type;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-    
-    for (i=0; i<8; i++) {
-
-        if (on == 1)
-            powerup_type = SENSOR_PWRSEQ_GET(powerup_sequence,i);
-        else
-            powerup_type = SENSOR_PWRSEQ_GET(powerup_sequence,(7-i));
-        
-        switch (powerup_type)
-        {
-            case SENSOR_PWRSEQ_AVDD:
-            case SENSOR_PWRSEQ_DOVDD:
-            case SENSOR_PWRSEQ_DVDD:
-            case SENSOR_PWRSEQ_PWR:
-            {  
-                ret = rk_sensor_ioctrl(dev,Cam_Power, on);
-                if (ret<0) {
-                    eprintk("SENSOR_PWRSEQ_PWR failed");
-                } else { 
-                    msleep(10);
-                    dprintk("SensorPwrSeq-power: %d",on);
-                }
-                break;
-            }
-
-            case SENSOR_PWRSEQ_HWRST:
-            {
-                if(!on){
-                    rk_sensor_ioctrl(dev,Cam_Reset, 1);
-                }else{
-                    ret = rk_sensor_ioctrl(dev,Cam_Reset, 1);
-                    msleep(2);
-                    ret |= rk_sensor_ioctrl(dev,Cam_Reset, 0); 
-                }
-                if (ret<0) {
-                    eprintk("SENSOR_PWRSEQ_HWRST failed");
-                } else {
-                    dprintk("SensorPwrSeq-reset: %d",on);
-                }
-                break;
-            }
-
-            case SENSOR_PWRSEQ_PWRDN:
-            {     
-                ret = rk_sensor_ioctrl(dev,Cam_PowerDown, !on);
-                if (ret<0) {
-                    eprintk("SENSOR_PWRSEQ_PWRDN failed");
-                } else {
-                    dprintk("SensorPwrSeq-power down: %d",!on);
-                }
-                break;
-            }
-
-            case SENSOR_PWRSEQ_CLKIN:
-            {
-                ret = rk_sensor_ioctrl(dev,Cam_Mclk, (on?mclk_rate:on));
-                if (ret<0) {
-                    eprintk("SENSOR_PWRSEQ_CLKIN failed");
-                } else {
-                    dprintk("SensorPwrSeq-clock: %d",on);
-                }
-                break;
-            }
-
-            default:
-                break;
-        }
-        
-    } 
-
-    return ret;
-}
-
-static int rk_sensor_power(struct device *dev, int on)
-{
-    int powerup_sequence,mclk_rate;
-    
-    struct rk29camera_platform_data* plat_data = &rk_camera_platform_data;
-    struct rk29camera_gpio_res *dev_io = NULL;
-    struct rkcamera_platform_data *new_camera=NULL, *new_device=NULL;
-    bool real_pwroff = true;
-    int ret = 0;
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-    new_camera = plat_data->register_dev_new;
-    
-	while (new_camera != NULL) {
-
-        if (new_camera->io.gpio_powerdown != INVALID_GPIO) {		
-            gpio_direction_output(new_camera->io.gpio_powerdown,
-                ((new_camera->io.gpio_flag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));            
-        }
-
-		debug_printk( "new_camera->dev_name= %s \n", new_camera->dev_name);
-		debug_printk( "dev_name(dev)= %s \n", dev_name(dev));
-		
-        if (strcmp(new_camera->dev_name,dev_name(dev))) {		
-			debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);
-            if (sensor_ioctl_cb.sensor_powerdown_cb && on)
-            	{
-            		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);
-                	sensor_ioctl_cb.sensor_powerdown_cb(&new_camera->io,1);
-            	}
-        } else {
-            new_device = new_camera;
-            dev_io = &new_camera->io;
-            debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);
-            if (!Sensor_Support_DirectResume(new_camera->pwdn_info))
-                real_pwroff = true;			
-            else
-                real_pwroff = false;
-        }
-        new_camera = new_camera->next_camera;
-    }
-
-    if (new_device != NULL) {
-        powerup_sequence = new_device->powerup_sequence;
-        if ((new_device->mclk_rate == 24) || (new_device->mclk_rate == 48))
-            mclk_rate = new_device->mclk_rate*1000000;
-        else 
-            mclk_rate = 24000000;
-    } else {
-        powerup_sequence = sensor_PWRSEQ_DEFAULT;
-        mclk_rate = 24000000;
-    }
-        
-    if (on) {
-		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);
-        rk_sensor_pwrseq(dev, powerup_sequence, on,mclk_rate);  
-    } else {
-        if (real_pwroff) {
-            if (rk_sensor_pwrseq(dev, powerup_sequence, on,mclk_rate)<0)    /* ddl@rock-chips.com: v0.1.5 */
-                goto PowerDown;
-            
-            /*ddl@rock-chips.com: all power down switch to Hi-Z after power off*/
-            new_camera = plat_data->register_dev_new;
-			while (new_camera != NULL) {
-                if (new_camera->io.gpio_powerdown != INVALID_GPIO) {
-                    gpio_direction_input(new_camera->io.gpio_powerdown);            
-                }
-                new_camera->pwdn_info |= 0x01;
-                new_camera = new_camera->next_camera;
-            }
-        } else {  
-PowerDown:
-            rk_sensor_ioctrl(dev,Cam_PowerDown, !on);
-
-            rk_sensor_ioctrl(dev,Cam_Mclk, 0);
-        }
-
-        mdelay(10);/* ddl@rock-chips.com: v0.1.3 */
-    }
-    return ret;
-}
-#if 0
-static int rk_sensor_reset(struct device *dev)
-{
-#if 0
-	rk_sensor_ioctrl(dev,Cam_Reset,1);
-	msleep(2);
-	rk_sensor_ioctrl(dev,Cam_Reset,0);
-#else
-    /*
-    *ddl@rock-chips.com : the rest function invalidate, because this operate is put together in rk_sensor_power;
-    */
-#endif
-	return 0;
-}
-#endif
-static int rk_sensor_powerdown(struct device *dev, int on)
-{
-
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
-
-	return rk_sensor_ioctrl(dev,Cam_PowerDown,on);
-}
-
-int rk_sensor_register(void)
-{
-    int i;    
-	struct rkcamera_platform_data *new_camera;	
-	
-    i = 0;
-	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
-
-	new_camera = new_camera_head;
-	
-	while (new_camera != NULL) {	
-        if (new_camera->dev.i2c_cam_info.addr == INVALID_VALUE) {
-            WARN(1, 
-                KERN_ERR "%s(%d): new_camera[%d] i2c addr is invalidate!",
-                __FUNCTION__,__LINE__,i);
-            continue;
-        }
-        sprintf(new_camera->dev_name,"%s_%d",new_camera->dev.device_info.dev.init_name,i+3);
-        new_camera->dev.device_info.dev.init_name =(const char*)&new_camera->dev_name[0];
-        new_camera->io.dev_name =(const char*)&new_camera->dev_name[0];
-        if (new_camera->orientation == INVALID_VALUE) {
-            if (strstr(new_camera->dev_name,"back")) {		           
-                new_camera->orientation = 90;
-            } else {
-                new_camera->orientation = 270;
-            }
-        }
-        /* ddl@rock-chips.com: v0.1.3 */
-        if ((new_camera->fov_h <= 0) || (new_camera->fov_h>360))
-            new_camera->fov_h = 100;
-        
-        if ((new_camera->fov_v <= 0) || (new_camera->fov_v>360))
-            new_camera->fov_v = 100;        
-
-		new_camera->dev.desc_info.subdev_desc.power = rk_sensor_power;
-		new_camera->dev.desc_info.subdev_desc.powerdown = rk_sensor_powerdown;
-		new_camera->dev.desc_info.host_desc.board_info =&new_camera->dev.i2c_cam_info; 
-
-        new_camera->dev.device_info.id = i+6;
-		new_camera->dev.device_info.dev.platform_data = &new_camera->dev.desc_info;
-		new_camera->dev.desc_info.subdev_desc.drv_priv = &rk_camera_platform_data;
-
-        platform_device_register(&(new_camera->dev.device_info));
-		i++;
-        new_camera = new_camera->next_camera;
-    }
-	
-		return 0;
-}
-#include "../../../drivers/media/video/rk30_camera.c"
diff --git a/arch/arm/mach-rockchip/rk_camera.h b/arch/arm/mach-rockchip/rk_camera.h
deleted file mode 100644
index 784d1229eec3..000000000000
--- a/arch/arm/mach-rockchip/rk_camera.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
-    camera.h - PXA camera driver header file
-
-    Copyright (C) 2003, Intel Corporation
-    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef __ASM_ARCH_CAMERA_RK_H_
-#define __ASM_ARCH_CAMERA_RK_H_
-
-#include <linux/videodev2.h>
-#include <media/soc_camera.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include "rk_camera_sensor_info.h"
-
-#define RK29_CAM_PLATFORM_DEV_ID 33
-#define RK_CAM_PLATFORM_DEV_ID_0 RK29_CAM_PLATFORM_DEV_ID
-#define RK_CAM_PLATFORM_DEV_ID_1 (RK_CAM_PLATFORM_DEV_ID_0+1)
-#define INVALID_VALUE -1
-#ifndef INVALID_GPIO
-#define INVALID_GPIO INVALID_VALUE
-#endif
-#define RK29_CAM_IO_SUCCESS 0
-#define RK29_CAM_EIO_INVALID -3
-#define RK29_CAM_EIO_REQUESTFAIL -2
-
-#define RK29_CAM_POWERACTIVE_BITPOS	0x00
-#define RK29_CAM_RESETACTIVE_BITPOS	0x01
-#define RK29_CAM_POWERDNACTIVE_BITPOS 0x02
-#define RK29_CAM_FLASHACTIVE_BITPOS	0x03
-#define RK29_CAM_AFACTIVE_BITPOS	0x04
-
-#define RK_CAM_SUPPORT_RESOLUTION 0x800000
-
-#define _CONS(a,b) a##b
-#define CONS(a,b) _CONS(a,b)
-
-#define _CONS4(a,b,c,d) a##b##c##d
-#define CONS4(a,b,c,d) _CONS4(a,b,c,d)
-
-#define __STR(x) #x
-#define _STR(x) __STR(x)
-#define STR(x) _STR(x)
-
- 
-/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
-/*
- move to rk_camera_sensor_info.h   yzm                                    
-*/
-/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
-
-
-//#define RK29_CAM_POWERACTIVE_BITPOS	0x00
-#define RK29_CAM_POWERACTIVE_MASK	(1<<RK29_CAM_POWERACTIVE_BITPOS)
-#define RK29_CAM_POWERACTIVE_H	(0x01<<RK29_CAM_POWERACTIVE_BITPOS)
-#define RK29_CAM_POWERACTIVE_L	(0x00<<RK29_CAM_POWERACTIVE_BITPOS)
-
-//#define RK29_CAM_RESETACTIVE_BITPOS	0x01
-#define RK29_CAM_RESETACTIVE_MASK	(1<<RK29_CAM_RESETACTIVE_BITPOS)
-#define RK29_CAM_RESETACTIVE_H	(0x01<<RK29_CAM_RESETACTIVE_BITPOS)
-#define RK29_CAM_RESETACTIVE_L  (0x00<<RK29_CAM_RESETACTIVE_BITPOS)
-
-//#define RK29_CAM_POWERDNACTIVE_BITPOS	0x02
-#define RK29_CAM_POWERDNACTIVE_MASK	(1<<RK29_CAM_POWERDNACTIVE_BITPOS)
-#define RK29_CAM_POWERDNACTIVE_H	(0x01<<RK29_CAM_POWERDNACTIVE_BITPOS)
-#define RK29_CAM_POWERDNACTIVE_L	(0x00<<RK29_CAM_POWERDNACTIVE_BITPOS)
-
-//#define RK29_CAM_FLASHACTIVE_BITPOS	0x03
-#define RK29_CAM_FLASHACTIVE_MASK	(1<<RK29_CAM_FLASHACTIVE_BITPOS)
-#define RK29_CAM_FLASHACTIVE_H	(0x01<<RK29_CAM_FLASHACTIVE_BITPOS)
-#define RK29_CAM_FLASHACTIVE_L  (0x00<<RK29_CAM_FLASHACTIVE_BITPOS)
-
-
-//#define RK29_CAM_AFACTIVE_BITPOS	0x04
-#define RK29_CAM_AFACTIVE_MASK	(1<<RK29_CAM_AFACTIVE_BITPOS)
-#define RK29_CAM_AFACTIVE_H	(0x01<<RK29_CAM_AFACTIVE_BITPOS)
-#define RK29_CAM_AFACTIVE_L  (0x00<<RK29_CAM_AFACTIVE_BITPOS)
-
-
-
-#define RK_CAM_SCALE_CROP_ARM      0
-#define RK_CAM_SCALE_CROP_IPP      1
-#define RK_CAM_SCALE_CROP_RGA      2
-#define RK_CAM_SCALE_CROP_PP       3
-
-#define RK_CAM_INPUT_FMT_YUV422    (1<<0)
-#define RK_CAM_INPUT_FMT_RAW10     (1<<1)
-#define RK_CAM_INPUT_FMT_RAW12     (1<<2)
-
-/* v4l2_subdev_core_ops.ioctl  ioctl_cmd macro */
-#define RK29_CAM_SUBDEV_ACTIVATE            0x00
-#define RK29_CAM_SUBDEV_DEACTIVATE          0x01
-#define RK29_CAM_SUBDEV_IOREQUEST			0x02
-#define RK29_CAM_SUBDEV_CB_REGISTER         0x03
-
-#define Sensor_HasBeen_PwrOff(a)            (a&0x01)
-#define Sensor_Support_DirectResume(a)      ((a&0x10)==0x10)
-
-#define Sensor_CropSet(a,b)                  a->reserved[1] = b;
-#define Sensor_CropGet(a)                    a->reserved[1]
-
-#define RK29_CAM_SUBDEV_HDR_EXPOSURE        0x04
-
-#define RK_VIDEOBUF_HDR_EXPOSURE_MINUS_1        0x00
-#define RK_VIDEOBUF_HDR_EXPOSURE_NORMAL         0x01
-#define RK_VIDEOBUF_HDR_EXPOSURE_PLUS_1         0x02
-#define RK_VIDEOBUF_HDR_EXPOSURE_FINISH         0x03
-#define RK_VIDEOBUF_CODE_SET(rk_code,type)  rk_code = (('R'<<24)|('K'<<16)|type)
-#define RK_VIDEOBUF_CODE_CHK(rk_code)       ((rk_code&(('R'<<24)|('K'<<16)))==(('R'<<24)|('K'<<16)))
-
-enum rk29camera_ioctrl_cmd
-{
-	Cam_Power,
-	Cam_Reset,
-	Cam_PowerDown,
-	Cam_Flash,
-	Cam_Mclk,
-	Cam_Af
-};
-
-enum rk29sensor_power_cmd
-{
-    Sensor_Power,
-	Sensor_Reset,
-	Sensor_PowerDown,
-	Sensor_Flash,
-	Sensor_Af
-};
-
-enum rk29camera_flash_cmd
-{
-    Flash_Off,
-    Flash_On,
-    Flash_Torch
-};
-
-struct rk29camera_gpio_res {
-    unsigned int gpio_reset;
-    unsigned int gpio_power;
-	unsigned int gpio_powerdown;
-	unsigned int gpio_flash;
-	unsigned int gpio_af;
-	unsigned int gpio_flag;
-	unsigned int gpio_init;
-	const char *dev_name;
-};
-
-struct rk29camera_mem_res {
-	const char *name;
-	unsigned int start;
-	unsigned int size;
-    void __iomem *vbase;  //IO
-};
-struct rk29camera_info {
-    const char *dev_name;
-    unsigned int orientation;
-    struct v4l2_frmivalenum fival[10];
-};
-
-struct reginfo_t
-{
-	u16 reg;
-	u16 val;
-	u16 reg_len;
-	u16 rev;
-};
-typedef struct rk_sensor_user_init_data{
-	int rk_sensor_init_width;
-	int rk_sensor_init_height;
-	unsigned long rk_sensor_init_bus_param;
-	enum v4l2_mbus_pixelcode rk_sensor_init_pixelcode;
-	struct reginfo_t * rk_sensor_init_data;
-	int rk_sensor_winseq_size;
-	struct reginfo_t * rk_sensor_init_winseq;
-	int rk_sensor_init_data_size;
-}rk_sensor_user_init_data_s;
-
-typedef struct rk_camera_device_register_info {
-    struct i2c_board_info i2c_cam_info;
-	struct soc_camera_desc desc_info;/*yzm*/
-    struct platform_device device_info;
-}rk_camera_device_register_info_t;
-
-struct rkcamera_platform_data {
-    rk_camera_device_register_info_t dev;
-    char dev_name[32];
-    struct rk29camera_gpio_res io;
-    int orientation;
-    int resolution;   
-    int mirror;       /* bit0:  0: mirror off
-                                1: mirror on
-                         bit1:  0: flip off
-                                1: flip on
-                      */
-    int i2c_rate;     /* 100KHz = 100000  */                    
-    bool flash;       /* true:  the sensor attached flash;
-                         false: the sensor haven't attach flash;
-
-                      */
-    int pwdn_info;    /* bit4: 1: sensor isn't need to be init after exit stanby, it can streaming directly 
-                               0: sensor must be init after exit standby;
-
-                         bit0: 1: sensor power have been turn off;
-                               0: sensor power is always on;
-                      */
-
-    long powerup_sequence;       /*  
-                                    bit0-bit3 --- power up sequence first step;
-                                    bit4-bit7 --- power up sequence second step;
-                                     .....
-                                  */
-    int mclk_rate;       /* MHz : 24/48 */ 
-    int fov_h;           /* fied of view horizontal */
-    int fov_v;           /* fied of view vertical */
-	const char *power_pmu_name1;
-	const char *power_pmu_name2;
-	const char *powerdown_pmu_name;
-	int power_pmu_voltage1;
-	int power_pmu_voltage2;
-	int powerdown_pmu_voltage;
-	struct device_node *of_node;
-	struct rkcamera_platform_data *next_camera;/*yzm*/
-                      
-};
-
-struct rk29camera_platform_data {
-    int (*io_init)(void);
-    int (*io_deinit)(int sensor);
-	int (*sensor_ioctrl)(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
-
-    int (*sensor_register)(void);
-    int (*sensor_mclk)(int cif_idx, int on, int clk_rate);
-    
-    struct rkcamera_platform_data *register_dev_new;  //sensor   
-	struct device *cif_dev;/*yzm host*/  
-	const char *rockchip_name;
-	int iommu_enabled;
-};
-
-struct rk29camera_platform_ioctl_cb {
-    int (*sensor_power_cb)(struct rk29camera_gpio_res *res, int on);
-    int (*sensor_reset_cb)(struct rk29camera_gpio_res *res, int on);
-    int (*sensor_powerdown_cb)(struct rk29camera_gpio_res *res, int on);
-    int (*sensor_flash_cb)(struct rk29camera_gpio_res *res, int on);
-    int (*sensor_af_cb)(struct rk29camera_gpio_res *res, int on);	
-};
-
-typedef struct rk29_camera_sensor_cb {
-    int (*sensor_cb)(void *arg); 
-    int (*scale_crop_cb)(struct work_struct *work);
-}rk29_camera_sensor_cb_s;
-
-#endif /* __ASM_ARCH_CAMERA_H_ */
-
diff --git a/arch/arm/mach-rockchip/rk_camera_sensor_info.h b/arch/arm/mach-rockchip/rk_camera_sensor_info.h
deleted file mode 100644
index 7b5e380cd2d3..000000000000
--- a/arch/arm/mach-rockchip/rk_camera_sensor_info.h
+++ /dev/null
@@ -1,370 +0,0 @@
-#ifndef __RK_CAMERA_SENSOR_INFO_H_
-#define __RK_CAMERA_SENSOR_INFO_H_
-
-
-/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
-#define RK29_CAM_SENSOR_OV7675 ov7675
-#define RK29_CAM_SENSOR_OV9650 ov9650
-#define RK29_CAM_SENSOR_OV2640 ov2640
-#define RK29_CAM_SENSOR_OV2655 ov2655
-#define RK29_CAM_SENSOR_OV2659 ov2659
-#define RK29_CAM_SENSOR_OV7690 ov7690
-#define RK29_CAM_SENSOR_OV3640 ov3640
-#define RK29_CAM_SENSOR_OV3660 ov3660
-#define RK29_CAM_SENSOR_OV5640 ov5640
-#define RK29_CAM_SENSOR_OV5642 ov5642
-#define RK29_CAM_SENSOR_S5K6AA s5k6aa
-#define RK29_CAM_SENSOR_MT9D112 mt9d112
-#define RK29_CAM_SENSOR_MT9D113 mt9d113
-#define RK29_CAM_SENSOR_MT9P111 mt9p111
-#define RK29_CAM_SENSOR_MT9T111 mt9t111
-#define RK29_CAM_SENSOR_GT2005  gt2005
-#define RK29_CAM_SENSOR_GC0307  gc0307
-#define RK29_CAM_SENSOR_GC0308  gc0308
-#define RK29_CAM_SENSOR_GC0309  gc0309
-#define RK29_CAM_SENSOR_GC2015  gc2015
-#define RK29_CAM_SENSOR_GC0328  gc0328
-#define RK29_CAM_SENSOR_GC0329  gc0329
-#define RK29_CAM_SENSOR_GC2035	gc2035
-#define RK29_CAM_SENSOR_SIV120B  siv120b
-#define RK29_CAM_SENSOR_SIV121D  siv121d
-#define RK29_CAM_SENSOR_SID130B  sid130B
-#define RK29_CAM_SENSOR_HI253  hi253
-#define RK29_CAM_SENSOR_HI704  hi704
-#define RK29_CAM_SENSOR_NT99250 nt99250
-#define RK29_CAM_SENSOR_SP0718  sp0718
-#define RK29_CAM_SENSOR_SP0838  sp0838
-#define RK29_CAM_SENSOR_SP2518  sp2518
-#define RK29_CAM_SENSOR_S5K5CA  s5k5ca
-#define RK29_CAM_ISP_MTK9335	mtk9335isp
-#define RK29_CAM_SENSOR_HM2057  hm2057
-#define RK29_CAM_SENSOR_HM5065  hm5065
-#define RK29_CAM_SENSOR_NT99160 nt99160  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99240 nt99240  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99252 nt99252  //oyyf@rock-chips.com 
-#define RK29_CAM_SENSOR_NT99340 nt99340  //oyyf@rock-chips.com 
-#define RK29_CAM_ISP_ICATCH7002_MI1040  icatchmi1040   
-#define RK29_CAM_ISP_ICATCH7002_OV5693  icatchov5693
-#define RK29_CAM_ISP_ICATCH7002_OV8825  icatchov8825   //zyt
-#define RK29_CAM_ISP_ICATCH7002_OV2720  icatchov2720   //zyt
-
-#define RK29_CAM_SENSOR_NAME_OV7675 "ov7675"
-#define RK29_CAM_SENSOR_NAME_OV9650 "ov9650"
-#define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
-#define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
-#define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
-#define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
-#define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
-#define RK29_CAM_SENSOR_NAME_OV3660 "ov3660"
-#define RK29_CAM_SENSOR_NAME_OV5640 "ov5640"
-#define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
-#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
-#define RK29_CAM_SENSOR_NAME_MT9D112 "mt9d112"
-#define RK29_CAM_SENSOR_NAME_MT9D113 "mt9d113"
-#define RK29_CAM_SENSOR_NAME_MT9P111 "mt9p111"
-#define RK29_CAM_SENSOR_NAME_MT9T111 "mt9t111"
-#define RK29_CAM_SENSOR_NAME_GT2005  "gt2005"
-#define RK29_CAM_SENSOR_NAME_GC0307  "gc0307"
-#define RK29_CAM_SENSOR_NAME_GC0308  "gc0308"
-#define RK29_CAM_SENSOR_NAME_GC0309  "gc0309"
-#define RK29_CAM_SENSOR_NAME_GC2015  "gc2015"
-#define RK29_CAM_SENSOR_NAME_GC0328  "gc0328"
-#define RK29_CAM_SENSOR_NAME_GC2035  "gc2035"
-#define RK29_CAM_SENSOR_NAME_GC0329  "gc0329"
-#define RK29_CAM_SENSOR_NAME_SIV120B "siv120b"
-#define RK29_CAM_SENSOR_NAME_SIV121D "siv121d"
-#define RK29_CAM_SENSOR_NAME_SID130B "sid130B"
-#define RK29_CAM_SENSOR_NAME_HI253  "hi253"
-#define RK29_CAM_SENSOR_NAME_HI704  "hi704"
-#define RK29_CAM_SENSOR_NAME_NT99250 "nt99250"
-#define RK29_CAM_SENSOR_NAME_SP0718  "sp0718"
-#define RK29_CAM_SENSOR_NAME_SP0838  "sp0838"
-#define RK29_CAM_SENSOR_NAME_SP2518  "sp2518"
-#define RK29_CAM_SENSOR_NAME_S5K5CA  "s5k5ca"
-#define RK29_CAM_ISP_NAME_MTK9335ISP "mtk9335isp"
-#define RK29_CAM_SENSOR_NAME_HM2057  "hm2057"
-#define RK29_CAM_SENSOR_NAME_HM5065  "hm5065"
-#define RK29_CAM_ISP_NAME_ICATCH7002_MI1040 "icatchmi1040"
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV5693 "icatchov5693"
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV8825 "icatchov8825" //zyt
-#define RK29_CAM_ISP_NAME_ICATCH7002_OV2720 "icatchov2720" //zyt
-
-//Sensor full resolution define
-#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
-#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
-
-#define ov2660_FULL_RESOLUTION     0x200000           // 2 megapixel
-
-#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
-#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
-#define ov3660_FULL_RESOLUTION     0x300000           // 3 megapixel
-#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
-#if defined(CONFIG_SOC_CAMERA_OV5642_INTERPOLATION_8M)
-	#define ov5642_FULL_RESOLUTION     0x800000            // 8 megapixel
-#else	
-    #define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
-#endif
-#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
-#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
-#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
-#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
-#if defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_5M)
-	#define gc0308_FULL_RESOLUTION     0x500000            // 5 megapixel
-#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_3M)
-	#define gc0308_FULL_RESOLUTION     0x300000            // 3 megapixel
-#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_2M)
-	#define gc0308_FULL_RESOLUTION     0x200000            // 2 megapixel
-#else
-	#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel#endif
-#endif
-#define gc0328_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc0307_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define siv121d_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
-
-#if defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_5M) 
-	#define hi253_FULL_RESOLUTION       0x500000			// 5 megapixel
-#elif defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_3M)
-	#define hi253_FULL_RESOLUTION       0x300000           // 3 megapixel
-#else
-	#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
-#endif
-
-#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
-#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define sp0718_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define sp0838_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define sp2518_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define gc0329_FULL_RESOLUTION      0x30000            // 0.3 megapixel
-#define s5k5ca_FULL_RESOLUTION      0x300000            // 3 megapixel
-#define mtk9335isp_FULL_RESOLUTION  0x500000   		//5 megapixel
-#define gc2035_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define hm2057_FULL_RESOLUTION      0x200000            // 2 megapixel
-#define hm5065_FULL_RESOLUTION      0x500000            // 5 megapixel
-#define nt99160_FULL_RESOLUTION     0x100000           // oyyf@rock-chips.com:  1 megapixel 1280*720    
-#define nt99240_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
-#define nt99252_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
-#define nt99340_FULL_RESOLUTION     0x300000           // oyyf@rock-chips.com:  3 megapixel 2048*1536
-#define icatchmi1040_FULL_RESOLUTION 0x200000
-#define icatchov5693_FULL_RESOLUTION 0x500000
-#define icatchov8825_FULL_RESOLUTION 0x800000					//zyt
-#define icatchov2720_FULL_RESOLUTION 0x210000                   //zyt
-#define end_FULL_RESOLUTION         0x00
-
-//Sensor i2c addr define
-#define ov7675_I2C_ADDR             0x78            
-#define ov9650_I2C_ADDR             0x60           
-#define ov2640_I2C_ADDR             0x60
-#define ov2655_I2C_ADDR             0x60
-#define ov2659_I2C_ADDR             0x60
-#define ov7690_I2C_ADDR             0x42
-#define ov3640_I2C_ADDR             0x78
-#define ov3660_I2C_ADDR             0x78
-#define ov5640_I2C_ADDR             0x78
-#define ov5642_I2C_ADDR             0x78
-
-#define s5k6aa_I2C_ADDR             0x78           //0x5a
-#define s5k5ca_I2C_ADDR             0x78           //0x5a
-
-#define mt9d112_I2C_ADDR             0x78
-#define mt9d113_I2C_ADDR             0x78
-#define mt9t111_I2C_ADDR             0x78           // 0x7a 
-
-#define mt9p111_I2C_ADDR            0x78            //0x7a
-#define gt2005_I2C_ADDR             0x78           
-#define gc0307_I2C_ADDR             0x42
-#define gc0328_I2C_ADDR             0x42
-#define gc0308_I2C_ADDR             0x42
-#define gc0309_I2C_ADDR             0x42
-#define gc0329_I2C_ADDR             0x62           
-#define gc2015_I2C_ADDR             0x60
-#define gc2035_I2C_ADDR             0x78            
-
-#define siv120b_I2C_ADDR             INVALID_VALUE           
-#define siv121d_I2C_ADDR             INVALID_VALUE           
-#define sid130B_I2C_ADDR             0x37
-
-#define hi253_I2C_ADDR             0x40
-#define hi704_I2C_ADDR             0x60
-
-#define nt99160_I2C_ADDR             0x54
-#define nt99240_I2C_ADDR             0x6c
-#define nt99250_I2C_ADDR             0x6c
-#define nt99252_I2C_ADDR             0x6c
-#define nt99340_I2C_ADDR             0x76
-
-#define sp0718_I2C_ADDR             0x42
-#define sp0838_I2C_ADDR             0x30  
-#define sp0a19_I2C_ADDR             0x7a
-#define sp1628_I2C_ADDR             0x78
-#define sp2518_I2C_ADDR             0x60 
-#define mtk9335isp_I2C_ADDR         0x50 
-#define hm2057_I2C_ADDR             0x48
-#define hm5065_I2C_ADDR             0x3e
-#define icatchmi1040_I2C_ADDR		0x78
-#define icatchov5693_I2C_ADDR       0x78
-#define icatchov8825_I2C_ADDR       0x78  //zyt
-#define icatchov2720_I2C_ADDR       0x78  //zyt
-#define end_I2C_ADDR                INVALID_VALUE
-
-//Sensor power  active level define
-#define PWR_ACTIVE_HIGH                  0x01
-#define PWR_ACTIVE_LOW					 0x0
-
-//Sensor power down active level define
-#define ov7675_PWRDN_ACTIVE             0x01            
-#define ov9650_PWRDN_ACTIVE             0x01           
-#define ov2640_PWRDN_ACTIVE             0x01
-#define ov2655_PWRDN_ACTIVE             0x01
-#define ov2659_PWRDN_ACTIVE             0x01
-#define ov7690_PWRDN_ACTIVE             0x01
-#define ov3640_PWRDN_ACTIVE             0x01
-#define ov3660_PWRDN_ACTIVE             0x01
-#define ov5640_PWRDN_ACTIVE             0x01
-#define ov5642_PWRDN_ACTIVE             0x01
-
-#define s5k6aa_PWRDN_ACTIVE             0x00           
-#define s5k5ca_PWRDN_ACTIVE             0x00           
-
-#define mt9d112_PWRDN_ACTIVE             0x01
-#define mt9d113_PWRDN_ACTIVE             0x01
-#define mt9t111_PWRDN_ACTIVE             0x01  
-#define mt9p111_PWRDN_ACTIVE             0x01
-
-#define gt2005_PWRDN_ACTIVE             0x00           
-#define gc0307_PWRDN_ACTIVE             0x01
-#define gc0308_PWRDN_ACTIVE             0x01
-#define gc0328_PWRDN_ACTIVE             0x01
-#define gc0309_PWRDN_ACTIVE             0x01
-#define gc0329_PWRDN_ACTIVE             0x01           
-#define gc2015_PWRDN_ACTIVE             0x01
-#define gc2035_PWRDN_ACTIVE             0x01            
-
-#define siv120b_PWRDN_ACTIVE             INVALID_VALUE           
-#define siv121d_PWRDN_ACTIVE             INVALID_VALUE           
-#define sid130B_PWRDN_ACTIVE             0x37
-
-#define hi253_PWRDN_ACTIVE             0x01
-#define hi704_PWRDN_ACTIVE             0x01
-
-#define nt99160_PWRDN_ACTIVE             0x01
-#define nt99240_PWRDN_ACTIVE             0x01
-#define nt99250_PWRDN_ACTIVE             0x01
-#define nt99252_PWRDN_ACTIVE             0x01
-#define nt99340_PWRDN_ACTIVE             0x01
-
-#define sp0718_PWRDN_ACTIVE             0x01
-#define sp0838_PWRDN_ACTIVE             0x01  
-#define sp0a19_PWRDN_ACTIVE             0x01
-#define sp1628_PWRDN_ACTIVE             0x01
-#define sp2518_PWRDN_ACTIVE             0x01 
-#define hm2057_PWRDN_ACTIVE             0x01
-#define hm5065_PWRDN_ACTIVE             0x00
-#define mtk9335isp_PWRDN_ACTIVE         0x01 
-#define end_PWRDN_ACTIVE                INVALID_VALUE
-
-
-//Sensor power up sequence  define
-//type: bit0-bit4
-#define SENSOR_PWRSEQ_BEGIN         0x00
-#define SENSOR_PWRSEQ_AVDD          0x01
-#define SENSOR_PWRSEQ_DOVDD         0x02
-#define SENSOR_PWRSEQ_DVDD          0x03
-#define SENSOR_PWRSEQ_PWR           0x04
-#define SENSOR_PWRSEQ_HWRST         0x05
-#define SENSOR_PWRSEQ_PWRDN         0x06
-#define SENSOR_PWRSEQ_CLKIN         0x07
-#define SENSOR_PWRSEQ_END           0x0F
-
-#define SENSOR_PWRSEQ_SET(type,idx)    (type<<(idx*4))
-#define SENSOR_PWRSEQ_GET(seq,idx)     ((seq>>(idx*4))&0x0f)
-
-#define sensor_PWRSEQ_DEFAULT      (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,1)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
-
-#define ov7675_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
-#define ov9650_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
-#define ov2640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov2655_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov2659_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov7690_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov3640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov3660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov5640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define ov5642_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define s5k6aa_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define s5k5ca_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-
-#define mt9d112_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define mt9d113_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define mt9t111_PWRSEQ                   sensor_PWRSEQ_DEFAULT 
-#define mt9p111_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define gt2005_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-#define gc0307_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0308_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0328_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0309_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc0329_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
-#define gc2015_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define gc2035_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
-
-#define siv120b_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define siv121d_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
-#define sid130B_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define hi253_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hi704_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define nt99160_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99240_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99250_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99252_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define nt99340_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-
-#define sp0718_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp0838_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
-#define sp0a19_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp1628_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define sp2518_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hm2057_PWRSEQ                   sensor_PWRSEQ_DEFAULT
-#define hm5065_PWRSEQ                   (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,1)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,0)|\
-                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
-#define mtk9335isp_PWRSEQ               sensor_PWRSEQ_DEFAULT
-#define icatchov5693_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
-                                    
-#define icatchov8825_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt                                    
-                                    
-#define icatchov2720_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt 
-
-#define icatchmi1040_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
-                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
-
-#define end_PWRSEQ                      0xffffffff
-                                          
-
-
-/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
-
-#endif
-
diff --git a/arch/arm/mach-rockchip/rk_system_status.c b/arch/arm/mach-rockchip/rk_system_status.c
deleted file mode 100644
index d2944c4d211b..000000000000
--- a/arch/arm/mach-rockchip/rk_system_status.c
+++ /dev/null
@@ -1,90 +0,0 @@
-#include <linux/mutex.h>
-#include <linux/notifier.h>
-
-static unsigned long system_status = 0;
-static unsigned long ref_count[32] = {0};
-static DEFINE_MUTEX(system_status_mutex);
-
-static BLOCKING_NOTIFIER_HEAD(rk_system_status_chain_head);
-
-int rockchip_register_system_status_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&rk_system_status_chain_head, nb);
-}
-EXPORT_SYMBOL_GPL(rockchip_register_system_status_notifier);
-
-int rockchip_unregister_system_status_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&rk_system_status_chain_head, nb);
-}
-EXPORT_SYMBOL_GPL(rockchip_unregister_system_status_notifier);
-
-static int rockchip_system_status_notifier_call_chain(unsigned long val)
-{
-	int ret = blocking_notifier_call_chain(&rk_system_status_chain_head, val, NULL);
-
-	return notifier_to_errno(ret);
-}
-
-int rockchip_set_system_status(unsigned long status)
-{
-	unsigned long old_system_status;
-	unsigned int single_status_offset;
-
-	mutex_lock(&system_status_mutex);
-
-	old_system_status = system_status;
-
-	while (status) {
-		single_status_offset = fls(status) - 1;
-		status &= ~(1<<single_status_offset);
-		if (ref_count[single_status_offset] == 0) {
-			system_status |= 1 << single_status_offset;
-		}
-		ref_count[single_status_offset]++;
-	}
-	if (old_system_status != system_status)
-		rockchip_system_status_notifier_call_chain(system_status);
-
-	mutex_unlock(&system_status_mutex);
-	return 0;
-}
-
-int rockchip_clear_system_status(unsigned long status)
-{
-	unsigned long old_system_status;
-	unsigned int single_status_offset;
-	mutex_lock(&system_status_mutex);
-
-	old_system_status = system_status;
-
-	while (status) {
-		single_status_offset = fls(status) - 1;
-		status &= ~(1<<single_status_offset);
-		if (ref_count[single_status_offset] == 0) {
-			continue;
-		} else {
-			if (ref_count[single_status_offset] == 1) {
-				system_status &= ~(1<<single_status_offset);
-			}
-			ref_count[single_status_offset]--;
-		}
-	}
-	if (old_system_status != system_status)
-		rockchip_system_status_notifier_call_chain(system_status);
-
-	mutex_unlock(&system_status_mutex);
-
-	return 0;
-}
-
-unsigned long rockchip_get_system_status(void)
-{
-	unsigned long ret;
-
-	mutex_lock(&system_status_mutex);
-	ret = system_status;
-	mutex_unlock(&system_status_mutex);
-
-	return ret;
-}
diff --git a/arch/arm/mach-rockchip/rknandbase.c b/arch/arm/mach-rockchip/rknandbase.c
deleted file mode 100755
index bda37fab9b2f..000000000000
--- a/arch/arm/mach-rockchip/rknandbase.c
+++ /dev/null
@@ -1,376 +0,0 @@
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/bootmem.h>
-#include <asm/io.h>
-#include <asm/cacheflush.h>
-#include <linux/platform_device.h>
-#include <linux/semaphore.h>
-#include <linux/clk.h>
-
-#define RKNAND_VERSION_AND_DATE  "rknandbase v1.0 2014-03-31"
-
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#endif
-
-struct rknand_info {
-    int tag;
-    int enable;
-    int clk_rate[2];
-    int nand_suspend_state;
-    int nand_shutdown_state;
-    int reserved0[6];
-    
-    void (*rknand_suspend)(void);
-    void (*rknand_resume)(void);
-    void (*rknand_buffer_shutdown)(void);
-    int (*rknand_exit)(void);
-    
-    int (*ftl_read) (int lun,int Index, int nSec, void *buf);  
-    int (*ftl_write) (int lun,int Index, int nSec, void *buf);
-    void (*nand_timing_config)(unsigned long AHBnKHz);
-    void (*rknand_dev_cache_flush)(void);
-    
-    int reserved1[16];
-};
-
-struct rk_nandc_info 
-{
-    int             id;
-    void __iomem    * reg_base ;
-    int             irq;
-    int             clk_rate;
-	struct clk	    *clk;  // flash clk
-	struct clk	    *hclk; // nandc clk
-	struct clk	    *gclk; // flash clk gate
-};
-
-struct rknand_info * gpNandInfo = NULL;
-static struct rk_nandc_info  g_nandc_info[2];
-
-static char *cmdline=NULL;
-int rknand_get_part_info(char **s)
-{
-	*s = cmdline;
-    return 0;
-}
-EXPORT_SYMBOL(rknand_get_part_info); 
-
-static char nand_idb_data[2048];
-char GetSNSectorInfo(char * pbuf)
-{
-    memcpy(pbuf,&nand_idb_data[0x600],0x200);
-    return 0;
-}
-
-char GetSNSectorInfoBeforeNandInit(char * pbuf)
-{
-    memcpy(pbuf,&nand_idb_data[0x600],0x200);
-    return 0;
-} 
-
-char GetVendor0InfoBeforeNandInit(char * pbuf)
-{
-    memcpy(pbuf,&nand_idb_data[0x400+8],504);
-    return 0;
-}
-
-char* rknand_get_idb_data(void)
-{
-    return nand_idb_data;
-}
-EXPORT_SYMBOL(rknand_get_idb_data);
-
-int  GetParamterInfo(char * pbuf , int len)
-{
-    int ret = -1;
-	return ret;
-}
-
-void rknand_spin_lock_init(spinlock_t * p_lock)
-{
-    spin_lock_init(p_lock);
-}
-EXPORT_SYMBOL(rknand_spin_lock_init);
-
-void rknand_spin_lock(spinlock_t * p_lock)
-{
-    spin_lock_irq(p_lock);
-}
-EXPORT_SYMBOL(rknand_spin_lock);
-
-void rknand_spin_unlock(spinlock_t * p_lock)
-{
-    spin_unlock_irq(p_lock);
-}
-EXPORT_SYMBOL(rknand_spin_unlock);
-
-
-struct semaphore  g_rk_nand_ops_mutex;
-void rknand_device_lock_init(void)
-{
-	sema_init(&g_rk_nand_ops_mutex, 1);
-}
-EXPORT_SYMBOL(rknand_device_lock_init);
-void rknand_device_lock (void)
-{
-     down(&g_rk_nand_ops_mutex);
-}
-EXPORT_SYMBOL(rknand_device_lock);
-
-int rknand_device_trylock (void)
-{
-    return down_trylock(&g_rk_nand_ops_mutex);
-}
-EXPORT_SYMBOL(rknand_device_trylock);
-
-void rknand_device_unlock (void)
-{
-    up(&g_rk_nand_ops_mutex);
-}
-EXPORT_SYMBOL(rknand_device_unlock);
-
-
-int rk_nand_get_device(struct rknand_info ** prknand_Info)
-{
-    *prknand_Info = gpNandInfo;
-    return 0;     
-}
-EXPORT_SYMBOL(rk_nand_get_device);
-
-unsigned long rknand_dma_flush_dcache(unsigned long ptr,int size,int dir)
-{
-#ifdef CONFIG_ARM64
-	__flush_dcache_area((void *)ptr, size + 63);
-#else
-     __cpuc_flush_dcache_area((void*)ptr, size + 63);
-#endif
-    return ((unsigned long )virt_to_phys((void *)ptr));
-}
-EXPORT_SYMBOL(rknand_dma_flush_dcache);
-
-unsigned long rknand_dma_map_single(unsigned long ptr,int size,int dir)
-{
-#ifdef CONFIG_ARM64
-    __dma_map_area((void*)ptr, size, dir);
-    return ((unsigned long )virt_to_phys((void *)ptr));
-#else
-    return dma_map_single(NULL,(void*)ptr,size, dir?DMA_TO_DEVICE:DMA_FROM_DEVICE);
-#endif
-}
-EXPORT_SYMBOL(rknand_dma_map_single);
-
-void rknand_dma_unmap_single(unsigned long ptr,int size,int dir)
-{
-#ifdef CONFIG_ARM64
-    __dma_unmap_area(phys_to_virt(ptr), size, dir);
-#else
-    dma_unmap_single(NULL, (dma_addr_t)ptr,size, dir?DMA_TO_DEVICE:DMA_FROM_DEVICE);
-#endif
-}
-EXPORT_SYMBOL(rknand_dma_unmap_single);
-
-int rknand_flash_cs_init(int id)
-{
-    return 0;
-}
-EXPORT_SYMBOL(rknand_flash_cs_init);
-
-int rknand_get_reg_addr(unsigned long *pNandc0,unsigned long *pNandc1,unsigned long *pSDMMC0,unsigned long *pSDMMC1,unsigned long *pSDMMC2)
-{
-	*pNandc0 = (unsigned long)g_nandc_info[0].reg_base;
-	*pNandc1 = (unsigned long)g_nandc_info[1].reg_base;
-	return 0;
-}
-EXPORT_SYMBOL(rknand_get_reg_addr);
-
-int rknand_nandc_irq_init(int id,int mode,void * pfun)
-{
-    int ret = 0;
-    int irq= g_nandc_info[id].irq;
-
-    if(mode)
-    {
-        ret = request_irq(irq, pfun, 0, "nandc", g_nandc_info[id].reg_base);
-        //if(ret)
-        //printk("request IRQ_NANDC %x irq %x, ret=%x.........\n",id,irq, ret);
-    }
-    else //deinit
-    {
-        free_irq(irq,  NULL);
-    }
-    return ret;
-}
-EXPORT_SYMBOL(rknand_nandc_irq_init);
-
-/*1:flash 2:emmc 4:sdcard0 8:sdcard1*/
-static int rknand_boot_media = 2;
-int rknand_get_boot_media(void)
-{
-	return rknand_boot_media;
-}
-EXPORT_SYMBOL(rknand_get_boot_media);
-
-static int rknand_probe(struct platform_device *pdev)
-{
-	unsigned int id = 0;
-	int irq ;
-	struct resource		*mem;
-	void __iomem    *membase;
-
-    if(gpNandInfo == NULL)
-    {
-        gpNandInfo = kzalloc(sizeof(struct rknand_info), GFP_KERNEL);
-        if (!gpNandInfo)
-            return -ENOMEM;
-        gpNandInfo->nand_suspend_state = 0;
-        gpNandInfo->nand_shutdown_state = 0;
-	}
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	membase = devm_request_and_ioremap(&pdev->dev, mem);
-	if (membase == 0) 
-	{
-		dev_err(&pdev->dev, "no reg resource?\n");
-		return -1;
-	}
-	//printk("rknand_probe %d %x %x\n", pdev->id,(int)mem,(int)membase);
-#ifdef CONFIG_OF
-	if(0==of_property_read_u32(pdev->dev.of_node, "nandc_id", &id))
-	{
-	    ;
-	}
-    pdev->id = id;
-#endif
-    if(id == 0)
-	{
-        memcpy(nand_idb_data,membase+0x1000,0x800);
-		if (*(int *)(&nand_idb_data[0]) == 0x44535953) {
-			rknand_boot_media = *(int *)(&nand_idb_data[8]);
-			if (rknand_boot_media == 2) /*boot from emmc*/
-				return -1;
-		}
-	}
-	else if(id >= 2)
-	{
-		dev_err(&pdev->dev, "nandc id = %d error!\n",id);
-	}
-
-    irq = platform_get_irq(pdev, 0);
-	//printk("nand irq: %d\n",irq);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "no irq resource?\n");
-		return irq;
-	}
-    g_nandc_info[id].id = id;
-    g_nandc_info[id].irq = irq;
-    g_nandc_info[id].reg_base = membase;
-
-    g_nandc_info[id].hclk = devm_clk_get(&pdev->dev, "hclk_nandc");
-    g_nandc_info[id].clk = devm_clk_get(&pdev->dev, "clk_nandc");
-    g_nandc_info[id].gclk = devm_clk_get(&pdev->dev, "g_clk_nandc");
-
-	if (unlikely(IS_ERR(g_nandc_info[id].clk)) || unlikely(IS_ERR(g_nandc_info[id].hclk))
-	|| unlikely(IS_ERR(g_nandc_info[id].gclk))) {
-        printk("rknand_probe get clk error\n");
-        return -1;
-	}
-
-    clk_set_rate(g_nandc_info[id].clk,150*1000*1000);
-	g_nandc_info[id].clk_rate = clk_get_rate(g_nandc_info[id].clk );
-    printk("rknand_probe clk rate = %d\n",g_nandc_info[id].clk_rate);
-    gpNandInfo->clk_rate[id] = g_nandc_info[id].clk_rate;
-    
-	clk_prepare_enable( g_nandc_info[id].clk );
-	clk_prepare_enable( g_nandc_info[id].hclk);
-	clk_prepare_enable( g_nandc_info[id].gclk);
-	return 0;
-}
-
-static int rknand_suspend(struct platform_device *pdev, pm_message_t state)
-{
-    if(gpNandInfo->rknand_suspend  && gpNandInfo->nand_suspend_state == 0){
-       gpNandInfo->nand_suspend_state = 1;
-        gpNandInfo->rknand_suspend();
-        //TODO:nandc clk disable
-	}
-	return 0;
-}
-
-static int rknand_resume(struct platform_device *pdev)
-{
-    if(gpNandInfo->rknand_resume && gpNandInfo->nand_suspend_state == 1){
-       gpNandInfo->nand_suspend_state = 0;
-       //TODO:nandc clk enable
-       gpNandInfo->rknand_resume();  
-	}
-	return 0;
-}
-
-static void rknand_shutdown(struct platform_device *pdev)
-{
-    if(gpNandInfo->rknand_buffer_shutdown && gpNandInfo->nand_shutdown_state == 0){
-        gpNandInfo->nand_shutdown_state = 1;
-        gpNandInfo->rknand_buffer_shutdown();
-    }
-}
-
-void rknand_dev_cache_flush(void)
-{
-    if(gpNandInfo->rknand_dev_cache_flush)
-        gpNandInfo->rknand_dev_cache_flush();
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id of_rk_nandc_match[] = {
-	{ .compatible = "rockchip,rk-nandc" },
-	{ /* Sentinel */ }
-};
-#endif
-
-static struct platform_driver rknand_driver = {
-	.probe		= rknand_probe,
-	.suspend	= rknand_suspend,
-	.resume		= rknand_resume,
-	.shutdown   = rknand_shutdown,
-	.driver		= {
-	    .name	= "rknand",
-#ifdef CONFIG_OF
-    	.of_match_table	= of_rk_nandc_match,
-#endif
-		.owner	= THIS_MODULE,
-	},
-};
-
-static void __exit rknand_part_exit(void)
-{
-	printk("rknand_part_exit: \n");
-    platform_driver_unregister(&rknand_driver);
-    if(gpNandInfo->rknand_exit)
-        gpNandInfo->rknand_exit();    
-	if (gpNandInfo)
-	    kfree(gpNandInfo);
-}
-
-MODULE_ALIAS(DRIVER_NAME);
-static int __init rknand_part_init(void)
-{
-	int ret = 0;
-	printk("%s\n", RKNAND_VERSION_AND_DATE);
-
-	cmdline = strstr(saved_command_line, "mtdparts=") + 9;
-
-	gpNandInfo = NULL;
-    memset(g_nandc_info,0,sizeof(g_nandc_info));
-
-	ret = platform_driver_register(&rknand_driver);
-	printk("rknand_driver:ret = %x \n",ret);
-	return ret;
-}
-
-module_init(rknand_part_init);
-module_exit(rknand_part_exit);
diff --git a/arch/arm/mach-rockchip/rockchip_pm.c b/arch/arm/mach-rockchip/rockchip_pm.c
deleted file mode 100755
index 2ac0c61c44b2..000000000000
--- a/arch/arm/mach-rockchip/rockchip_pm.c
+++ /dev/null
@@ -1,671 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/suspend.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/suspend.h>
-#include <linux/delay.h>
-#include <linux/moduleparam.h>
-#include <linux/rockchip/common.h>
-#include <asm/psci.h>
-#include <asm/io.h>
-#include "pm.h"
-
-/*************************dump reg********************************************/
-
-void rkpm_ddr_reg_offset_dump(void __iomem * base_addr,u32 _offset)
-{
-    rkpm_ddr_printhex(_offset);     
-    rkpm_ddr_printch('-');
-    rkpm_ddr_printhex(readl_relaxed((base_addr + _offset)));  
-}
-
-void  rkpm_ddr_regs_dump(void __iomem * base_addr,u32 start_offset,u32 end_offset)
-{
-	u32 i;
-        //u32 line=0;
-
-        rkpm_ddr_printascii("start from:");     
-	rkpm_ddr_printhex((unsigned long)base_addr + start_offset);
-        rkpm_ddr_printch('\n');
-                   
-        
-	for(i=start_offset;i<=end_offset;)
-	{
-         
-            rkpm_ddr_printhex(reg_readl((base_addr + i)));  
-            if(i%16==12) 
-            {   
-                rkpm_ddr_printch('\n');
-            }
-            else
-            {
-                    if(i!=end_offset)
-                    rkpm_ddr_printch('-');
-                    else                        
-                    rkpm_ddr_printch('\n');
-            }
-            i=i+4;
-	} 
-    
-    
-}
-
-static struct rkpm_ops pm_ops={NULL};
-
-static struct rkpm_sram_ops *p_pm_sram_ops=NULL;//pie point for pm_sram_ops
-static rkpm_sram_suspend_arg_cb p_suspend_pie_cb=NULL;
-
-// for user setting
-static u32   rkpm_ctrbits=0;
-//for judging rkpm_ctrbits valid ,save ifself
-static u32   rkpm_jdg_ctrbits=0;
-static u32   rkpm_jdg_sram_ctrbits=0;
-
-/**************************************ddr callback setting***************************************/
-
-void rkpm_set_pie_info(struct rkpm_sram_ops *pm_sram_ops,rkpm_sram_suspend_arg_cb pie_cb)
-{
-
-    p_pm_sram_ops=pm_sram_ops;
-    p_suspend_pie_cb=pie_cb;
-
-
-}
-
-void rkpm_set_ops_prepare_finish(rkpm_ops_void_callback prepare,rkpm_ops_void_callback finish)
-{
-	pm_ops.prepare=prepare;	
-	pm_ops.finish=finish;	
-}
-
-void rkpm_set_ops_pwr_dmns(rkpm_ops_void_callback pwr_dmns,rkpm_ops_void_callback re_pwr_dmns)
-{
-	pm_ops.pwr_dmns=pwr_dmns;	
-	pm_ops.re_pwr_dmns=re_pwr_dmns;
-}
-
-void rkpm_set_ops_gtclks(rkpm_ops_void_callback gtclks,rkpm_ops_void_callback re_gtclks)
-{
-	pm_ops.gtclks=gtclks;	
-	pm_ops.re_gtclks=re_gtclks;
-}
-
-
-void rkpm_set_ops_plls(rkpm_ops_void_callback plls,rkpm_ops_void_callback re_plls)
-{
-	pm_ops.plls=plls;	
-	pm_ops.re_plls=re_plls;
-}
-
-
-void rkpm_set_ops_gpios(rkpm_ops_void_callback gpios,rkpm_ops_void_callback re_gpios)
-{
-	pm_ops.gpios=gpios;	
-	pm_ops.re_gpios=re_gpios;
-}
-void rkpm_set_ops_save_setting(rkpm_ops_paramter_u32_cb save_setting,rkpm_ops_void_callback re_save_setting)
-{
-	pm_ops.save_setting=save_setting;	
-	pm_ops.re_save_setting=re_save_setting;
-}
-
-
-
-void rkpm_set_ops_printch(rkpm_ops_printch_callback printch)
-{
-	pm_ops.printch=printch;	
-}
-
-void rkpm_set_ops_regs_pread(rkpm_ops_void_callback regs_pread)
-{
-	pm_ops.regs_pread=regs_pread;	
-}
-
-void rkpm_set_ops_regs_sleep(rkpm_ops_void_callback slp_setting,rkpm_ops_void_callback re_last)
-{	
-
-	pm_ops.slp_setting=slp_setting;    
-
-	pm_ops.slp_re_first=re_last;    
-}
-
-
-/**************************************sram callback setting***************************************/
-void rkpm_set_sram_ops_volt(rkpm_ops_void_callback volts,rkpm_ops_void_callback re_volts)
-{
-        if(p_pm_sram_ops)
-        {
-            p_pm_sram_ops->volts=volts;	
-            p_pm_sram_ops->re_volts=re_volts;
-        }
-}
-
-void rkpm_set_sram_ops_gtclks(rkpm_ops_void_callback gtclks,rkpm_ops_void_callback re_gtclks)
-{
-         if(p_pm_sram_ops)
-        {
-        	p_pm_sram_ops->gtclks=gtclks;	
-        	p_pm_sram_ops->re_gtclks=re_gtclks;
-        }
-}
-
-void rkpm_set_sram_ops_sysclk(rkpm_ops_paramter_u32_cb sysclk,rkpm_ops_paramter_u32_cb re_sysclk)
-{
-         if(p_pm_sram_ops)
-        {
-        	p_pm_sram_ops->sysclk=sysclk;	
-        	p_pm_sram_ops->re_sysclk=re_sysclk;
-        }
-}
-
-void rkpm_set_sram_ops_pmic(rkpm_ops_void_callback pmic,rkpm_ops_void_callback re_pmic)
-{
-     if(p_pm_sram_ops)
-    {
-        p_pm_sram_ops->pmic=pmic;	
-        p_pm_sram_ops->re_pmic=re_pmic;
-    }
-}
-
-void rkpm_set_sram_ops_ddr(rkpm_ops_void_callback ddr,rkpm_ops_void_callback re_ddr)
-{
-    if(p_pm_sram_ops)
-    {
-        p_pm_sram_ops->ddr=ddr;	
-        p_pm_sram_ops->re_ddr=re_ddr;
-    }
-}
-
-void rkpm_set_sram_ops_bus(rkpm_ops_void_callback bus_idle_request)
-{
-	if (p_pm_sram_ops)
-		p_pm_sram_ops->bus_idle_request = bus_idle_request;
-}
-void rkpm_set_sram_ops_printch(rkpm_ops_printch_callback printch)
-{  
-    if(p_pm_sram_ops)
-	p_pm_sram_ops->printch=printch;	
-}
-
-/******************for user ************************/
-void rkpm_set_ctrbits(u32 bits)
-{	
-	rkpm_ctrbits = bits;
-	
-}
-void rkpm_add_ctrbits(u32 bits)
-{	
-	rkpm_ctrbits |= bits;
-	
-}
-u32 rkpm_get_ctrbits(void)
-{	
-	return rkpm_ctrbits;
-}
-
-u32 rkpm_chk_ctrbits(u32 bits)
-{	
-	return (rkpm_ctrbits&bits);
-}
-
-//clear
-void rkpm_clr_ctrbits(u32 bits)
-{
-	rkpm_ctrbits&=~bits;
-}
-
-/****************** for pm.c************************/
-
-static void inline rkpm_set_jdg_ctrbits(u32 bits)
-{	
-	rkpm_jdg_ctrbits = bits;
-	
-}
-static u32  inline rkpm_get_jdg_ctrbits(void)
-{	
-	return rkpm_jdg_ctrbits;
-}
-
-static void inline rkpm_add_jdg_ctrbits(int bit)
-{	
-	rkpm_jdg_ctrbits|=bit;
-}
-
-#if 0
-static u32 inline rkpm_chk_jdg_ctrbit(int bit)
-{	
-	return (rkpm_jdg_ctrbits&bit);
-}
-#endif
-
-static u32 inline rkpm_chk_jdg_ctrbits(int bits)
-{	
-	return (rkpm_jdg_ctrbits&bits);
-}
-//clear
-static void inline rkpm_clr_jdg_ctrbits(int bit)
-{
-	rkpm_jdg_ctrbits&=~bit;
-}
-
-
-#define  RKPM_DDR_FUN(fun) \
-	if(pm_ops.fun)\
-		(pm_ops.fun)()
-
-// fun with paramater  param (p1,p2,p3)
-#define  RKPM_DDR_PFUN(fun,param) \
-        if(pm_ops.fun) \
-            {(pm_ops.fun)param;} while(0)
-
-#define  RKPM_BITCTR_DDR_FUN(ctr,fun) \
-	if(rkpm_chk_jdg_ctrbits(RKPM_CTR_##ctr)&&pm_ops.fun)\
-		(pm_ops.fun)()
-
-#define  RKPM_BITSCTR_DDR_FUN(bits,fun) \
-        if(rkpm_chk_jdg_ctrbits(bits)&&pm_ops.fun)\
-            (pm_ops.fun)()
-
-
-        
-#define  RKPM_LPMD_BITSCTR_DDR_PFUN(bits,fun,param) \
-                if(rkpm_chk_jdg_ctrbits(RKPM_CTRBITS_SOC_DLPMD)&&pm_ops.fun)\
-                    (pm_ops.fun)param
-
-#define  RKPM_LPMD_BITSCTR_DDR_FUN(bits,fun) \
-                if(rkpm_chk_jdg_ctrbits(RKPM_CTRBITS_SOC_DLPMD)&&pm_ops.fun)\
-                        (pm_ops.fun)()
-
-
-
-void rkpm_ctrbits_prepare(void)
-{
-	
-	//rkpm_sram_ctrbits=rkpm_ctrbits;
-	
-	rkpm_jdg_ctrbits=rkpm_ctrbits;
-
-        //if plls is no pd,clk rate is high, volts can not setting low,so we need to judge ctrbits
-	//if(rkpm_chk_jdg_ctrbits(RKPM_CTR_VOLTS))
-	{
-		//rkpm_clr_jdg_ctrbits(RKPM_CTR_VOLTS);
-	}
-    
-        rkpm_jdg_sram_ctrbits=rkpm_jdg_ctrbits;
-        
-        //clk gating will gate ddr clk in sram
-        if(!rkpm_chk_val_ctrbits(rkpm_jdg_sram_ctrbits,RKPM_CTR_DDR))
-        {
-           // rkpm_clr_val_ctrbit(rkpm_jdg_sram_ctrbits,RKPM_CTR_GTCLKS);
-        }
-    
-}
-
-struct rk_soc_pm_info_st {
-    int offset;
-    char *name;
-};
-
-#define RK_SOC_PM_HELP_(id,NAME)\
-        {\
-        .offset= RKPM_CTR_##id,\
-        .name= NAME,\
-        }
-    
-struct rk_soc_pm_info_st rk_soc_pm_helps[]={
-#if 0
-    RK_SOC_PM_HELP_(NO_PD,"pd is not power dn"),
-    RK_SOC_PM_HELP_(NO_CLK_GATING,"clk is not gating"),
-    RK_SOC_PM_HELP_(NO_PLL,"pll is not power dn"),
-    RK_SOC_PM_HELP_(NO_VOLT,"volt is not set suspend"),
-    RK_SOC_PM_HELP_(NO_GPIO,"gpio is not control "),
-    //RK_SOC_PM_HELP_(NO_SRAM,"not enter sram code"),
-    RK_SOC_PM_HELP_(NO_DDR,"ddr is not reflash"),
-    RK_SOC_PM_HELP_(NO_PMIC,"pmic is not suspend"),
-    RK_SOC_PM_HELP_(RET_DIRT,"sys return from pm_enter directly"),
-    RK_SOC_PM_HELP_(SRAM_NO_WFI,"sys is not runing wfi in sram"),
-    RK_SOC_PM_HELP_(WAKE_UP_KEY,"send a power key to wake up lcd"),
-#endif
-};
-    
-ssize_t rk_soc_pm_helps_sprintf(char *buf)
-{
-    char *s = buf;
-    int i;
-
-    for(i=0;i<ARRAY_SIZE(rk_soc_pm_helps);i++)
-    {
-        s += sprintf(s, "bit(%d): %s\n", rk_soc_pm_helps[i].offset,rk_soc_pm_helps[i].name);
-    }
-
-    return (s-buf);
-}   
-    
-void rk_soc_pm_helps_printk(void)
-{
-    int i;
-    printk("**************rkpm_ctr_bits bits help***********:\n");
-    for(i=0;i<ARRAY_SIZE(rk_soc_pm_helps);i++)
-    {
-        printk("bit(%d): %s\n", rk_soc_pm_helps[i].offset,rk_soc_pm_helps[i].name);
-    }
-}   
-
-#if 0
-static int __init early_param_rk_soc_pm_ctr(char *str)
-{
-    get_option(&str, &rkpm_ctrbits);
-    
-    printk("********rkpm_ctr_bits information is following:*********\n");
-    printk("rkpm_ctr_bits=%x\n",rkpm_ctrbits);
-    if(rkpm_ctrbits)
-    {
-        rk_soc_pm_helps_printk();
-    }
-    printk("********rkpm_ctr_bits information end*********\n");
-    return 0;
-}
-#endif
-
-/*******************************************log*********************************************/
-
-
-bool  pm_log;
-
-extern void pm_emit_log_char(char c);
-
-/********************************ddr print**********************************/
-void rkpm_ddr_printch(char byte)
-{
-        if(pm_ops.printch)
-            pm_ops.printch(byte);	
-	//if (byte == '\n')
-		//rkpm_ddr_printch('\r');
-}
-void rkpm_ddr_printascii(const char *s)
-{
-	while (*s) {
-		rkpm_ddr_printch(*s);
-		s++;
-	}
-}
-
-void  rkpm_ddr_printhex(unsigned int hex)
-{
-	int i = 8;
-	rkpm_ddr_printch('0');
-	rkpm_ddr_printch('x');
-	while (i--) {
-		unsigned char c = (hex & 0xF0000000) >> 28;
-		rkpm_ddr_printch(c < 0xa ? c + '0' : c - 0xa + 'a');
-		hex <<= 4;
-	}
-}
-
-#ifdef CONFIG_ARM_PSCI
-static bool psci_suspend_available(void)
-{
-	return (psci_ops.cpu_suspend != NULL);
-}
-#else
-static inline bool psci_suspend_available(void)
-{
-	return false;
-}
-#endif
-
-#ifdef CONFIG_ARM
-void rk_sram_suspend(void)
-{
-	RKPM_DDR_FUN(regs_pread);
-	rkpm_ddr_printascii("sram");
-	call_with_stack(p_suspend_pie_cb
-		, &rkpm_jdg_sram_ctrbits, rockchip_sram_stack);
-}
-
-static int rk_lpmode_enter(unsigned long arg)
-{
-#ifdef CONFIG_ARM_PSCI
-	const struct psci_power_state ps = {
-		.type = PSCI_POWER_STATE_TYPE_POWER_DOWN,
-	};
-
-	if (psci_suspend_available())
-		return psci_ops.cpu_suspend(ps, virt_to_phys(cpu_resume));
-#endif
-        //RKPM_DDR_PFUN(slp_setting(rkpm_jdg_sram_ctrbits),slp_setting); 
-    
-        RKPM_DDR_FUN(slp_setting); 
-
-        local_flush_tlb_all();
-        flush_cache_all();
-        outer_flush_all();
-        outer_disable();
-        cpu_proc_fin();
-        //outer_inv_all();// ???
-        //  l2x0_inv_all_pm(); //rk319x is not need
-        flush_cache_all();
-
-	 rkpm_ddr_printch('d');
-
-        //rkpm_udelay(3*10);
-
-        dsb();
-        wfi();  
-        
-        rkpm_ddr_printch('D');
-	return 0;
-}
-
-int cpu_suspend(unsigned long arg, int (*fn)(unsigned long));
-#endif /* CONFIG_ARM */
-
-static int rkpm_enter(suspend_state_t state)
-{
-	//static u32 test_count=0;
-        // printk(KERN_DEBUG"pm: ");
-        printk("%s:\n",__FUNCTION__);
-        //printk("pm test times=%d\n",++test_count);
-
-#ifdef CONFIG_ARM_PSCI
-	if (psci_suspend_available()) {
-		cpu_suspend(0, rk_lpmode_enter);
-		return 0;
-	}
-#endif
-        RKPM_DDR_FUN(prepare);   
-        
-        rkpm_ctrbits_prepare();
-         
-        //  if(rkpm_chk_jdg_ctrbits(RKPM_CTR_RET_DIRT))
-        //  return 0;
-      
-        rkpm_ddr_printch('0');
-
-        RKPM_BITCTR_DDR_FUN(PWR_DMNS,pwr_dmns);
-
-        rkpm_ddr_printch('1');
-
-        local_fiq_disable();
-    
-        RKPM_DDR_PFUN(save_setting,(rkpm_jdg_sram_ctrbits)); 
-        
-        rkpm_ddr_printch('2');
-        
-        RKPM_BITCTR_DDR_FUN(GTCLKS,gtclks);
-
-        rkpm_ddr_printch('3');
-
-        RKPM_BITCTR_DDR_FUN(PLLS,plls);
-
-        rkpm_ddr_printch('4');
-
-        RKPM_BITCTR_DDR_FUN(GPIOS,gpios);
-
-        RKPM_DDR_FUN(regs_pread);
-
-        rkpm_ddr_printch('5');
-
-#ifdef CONFIG_ARM
-        if(rkpm_chk_jdg_ctrbits(RKPM_CTRBITS_SOC_DLPMD))
-        {   
-            if(cpu_suspend(0,rk_lpmode_enter)==0)
-            {
-                RKPM_DDR_FUN(slp_re_first);
-		rkpm_ddr_printch('K');
-                //rk_soc_pm_ctr_bits_prepare();
-            }	  	              
-            rkpm_ddr_printch('d');          
-        }
-        else if(rkpm_chk_jdg_ctrbits(RKPM_CTR_IDLESRAM_MD)&&p_suspend_pie_cb)
-        {
-            call_with_stack(p_suspend_pie_cb,&rkpm_jdg_sram_ctrbits, rockchip_sram_stack);
-        }
-        else
-        {
-            dsb();
-            wfi();
-        }
-#else
-	flush_cache_all();
-	cpu_suspend(1);
-#endif
-
-        rkpm_ddr_printch('5');
-
-        RKPM_BITCTR_DDR_FUN(GPIOS,re_gpios);
-
-        rkpm_ddr_printch('4');
-
-        RKPM_BITCTR_DDR_FUN(PLLS,re_plls);
-
-        rkpm_ddr_printch('3');
-
-        RKPM_BITCTR_DDR_FUN(GTCLKS,re_gtclks);
-        
-        rkpm_ddr_printch('2');
-        
-        RKPM_DDR_FUN(re_save_setting); 
-
-        local_fiq_enable();
-        rkpm_ddr_printch('1');
-        
-        RKPM_BITCTR_DDR_FUN(PWR_DMNS,re_pwr_dmns);
-
-        rkpm_ddr_printch('0');
-        rkpm_ddr_printch('\n');
-        
-        RKPM_DDR_FUN(finish);           
-        return 0;
-}
-
-#if 0
-static int rkpm_enter_tst(void)
-{
-
-       return rkpm_enter(0);
-
-}
-#endif
-
-static int rkpm_suspend_prepare(void)
-{
-	/* disable entering idle by disable_hlt() */
-	//disable_hlt();
-	return 0;
-}
-
-static void rkpm_suspend_finish(void)
-{
-	//enable_hlt();
-	
-	#if 0 //def CONFIG_KEYS_RK29
-	if(rkpm_check_ctrbits(1<<RKPM_CTR_WAKE_UP_KEY))
-	{
-		rk28_send_wakeup_key();
-		printk("rk30_pm_finish rk28_send_wakeup_key\n");
-	}
-	#endif
-}
-
-
-static struct platform_suspend_ops rockchip_suspend_ops = {
-	.enter		= rkpm_enter,
-	.valid		= suspend_valid_only_mem,
-	.prepare 	= rkpm_suspend_prepare,
-	.finish		= rkpm_suspend_finish,
-};
-void __init rockchip_suspend_init(void)
-{
-    //printk("%s\n",__FUNCTION__);
-    suspend_set_ops(&rockchip_suspend_ops);
-    return;
-}
-
-#ifndef CONFIG_ARM
-static int __init rockchip_init_suspend(void)
-{
-	suspend_set_ops(&rockchip_suspend_ops);
-	return 0;
-}
-late_initcall_sync(rockchip_init_suspend);
-#endif /* CONFIG_ARM */
-
-static enum rockchip_pm_policy pm_policy;
-static BLOCKING_NOTIFIER_HEAD(policy_notifier_list);
-
-int rockchip_pm_policy_register_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&policy_notifier_list, nb);
-}
-
-int rockchip_pm_policy_unregister_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&policy_notifier_list, nb);
-}
-
-static int rockchip_pm_policy_notify(void)
-{
-	return blocking_notifier_call_chain(&policy_notifier_list,
-			pm_policy, NULL);
-}
-
-enum rockchip_pm_policy rockchip_pm_get_policy(void)
-{
-	return pm_policy;
-}
-
-int rockchip_pm_set_policy(enum rockchip_pm_policy policy)
-{
-	if (policy < ROCKCHIP_PM_NR_POLICYS && policy != pm_policy) {
-		printk(KERN_INFO "pm policy %d -> %d\n", pm_policy, policy);
-		pm_policy = policy;
-		rockchip_pm_policy_notify();
-	}
-
-	return 0;
-}
-
-static unsigned int policy;
-
-static int set_policy(const char *val, const struct kernel_param *kp)
-{
-	int ret;
-
-	ret = param_set_uint(val, kp);
-	if (ret < 0)
-		return ret;
-
-	rockchip_pm_set_policy(policy);
-	policy = rockchip_pm_get_policy();
-
-	return 0;
-}
-
-static struct kernel_param_ops policy_param_ops = {
-	.set = set_policy,
-	.get = param_get_uint,
-};
-
-module_param_cb(policy, &policy_param_ops, &policy, 0600);
diff --git a/arch/arm/mach-rockchip/sram.h b/arch/arm/mach-rockchip/sram.h
deleted file mode 100644
index f7863de25bda..000000000000
--- a/arch/arm/mach-rockchip/sram.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef __MACH_ROCKCHIP_SRAM_H
-#define __MACH_ROCKCHIP_SRAM_H
-
-#include <linux/pie.h>
-#ifdef CONFIG_PIE
-#include <asm/pie.h>
-#endif
-
-extern char __pie_common_start[];
-extern char __pie_common_end[];
-extern char __pie_overlay_start[];
-
-extern struct gen_pool *rockchip_sram_pool;
-extern struct pie_chunk *rockchip_pie_chunk;
-extern void *rockchip_sram_virt;
-extern size_t rockchip_sram_size;
-extern char *rockchip_sram_stack;
-extern char __pie_data(rk3188) __pie_rk3188_sram_stack[1024];
-
-#define RK_PIE_DATA3(x) __pie_data(rk##x)
-#define RK_PIE_DATA2(x) RK_PIE_DATA3(x)
-#define RK_PIE_DATA RK_PIE_DATA2(CPU)
-
-#define DATA3(x, y) __pie_rk##y##_##x
-#define DATA2(x, y) DATA3(x, y)
-#define DATA(x) DATA2(x, CPU)
-
-#define RK_PIE3(x) __pie(rk##x)
-#define RK_PIE2(x) RK_PIE3(x)
-#define RK_PIE RK_PIE2(CPU)
-
-#define FUNC3(x, y) __pie_rk##y##_##x
-#define FUNC2(x, y) FUNC3(x, y)
-#define FUNC(x) FUNC2(x, CPU)
-
-#define PIE_FUNC(x) RK_PIE FUNC(x)
-#define PIE_DATA(x) RK_PIE_DATA DATA(x)
-
-#define DEFINE_PIE_DATA(x) PIE_DATA(x); EXPORT_PIE_SYMBOL(DATA(x));
-
-/* Tag variables with this */
-#define __sramdata RK_PIE_DATA
-/* Tag functions inside SRAM called from outside SRAM with this */
-#define __sramfunc RK_PIE noinline
-/* Tag function inside SRAM called from inside SRAM  with this */
-#define __sramlocalfunc RK_PIE
-
-extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
-
-#ifdef CONFIG_PIE
-extern int __init rockchip_pie_init(void);
-#else
-static inline int rockchip_pie_init(void) { return -1; }
-#endif
-
-#endif
-- 
2.35.3

