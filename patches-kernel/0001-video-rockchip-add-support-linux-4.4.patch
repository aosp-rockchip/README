From 0493a6826b3492d749accd888c600d1316d9ef39 Mon Sep 17 00:00:00 2001
From: Huang Jiachai <hjc@rock-chips.com>
Date: Thu, 3 Dec 2015 15:03:26 +0800
Subject: [PATCH] video: rockchip: add support linux 4.4

Change-Id: I6c77124074d4810245610774475cc64c459e47b3
Signed-off-by: Huang Jiachai <hjc@rock-chips.com>
---
 drivers/video/Kconfig                         |   1 +
 drivers/video/Makefile                        |   1 +
 drivers/video/rockchip/Makefile               |   2 -
 drivers/video/rockchip/display-sys.c          |  98 +-
 drivers/video/rockchip/lcdc/rk3288_lcdc.c     |   3 -
 drivers/video/rockchip/lcdc/rk3368_lcdc.c     |  45 +-
 drivers/video/rockchip/rk_drm_fb.c            | 972 ------------------
 drivers/video/rockchip/rk_drm_fb.h            |  72 --
 drivers/video/rockchip/rk_fb.c                |  96 +-
 drivers/video/rockchip/rkfb_sysfs.c           |   4 +-
 drivers/video/rockchip/screen/rk_screen.c     |   2 +-
 .../video/rockchip/transmitter/dpcd_edid.h    |   2 +-
 .../video/rockchip/transmitter/rk31xx_lvds.c  |  13 +-
 include/linux/display-sys.h                   |   2 +-
 include/linux/rk_fb.h                         |   2 +-
 15 files changed, 157 insertions(+), 1158 deletions(-)
 mode change 100755 => 100644 drivers/video/rockchip/display-sys.c
 mode change 100755 => 100644 drivers/video/rockchip/lcdc/rk3368_lcdc.c
 delete mode 100755 drivers/video/rockchip/rk_drm_fb.c
 delete mode 100644 drivers/video/rockchip/rk_drm_fb.h
 mode change 100755 => 100644 drivers/video/rockchip/rk_fb.c
 mode change 100755 => 100644 drivers/video/rockchip/rkfb_sysfs.c
 mode change 100755 => 100644 drivers/video/rockchip/screen/rk_screen.c
 mode change 100755 => 100644 drivers/video/rockchip/transmitter/rk31xx_lvds.c

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e0606c01e8ac..7e0ac1996627 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -29,6 +29,7 @@ source "drivers/video/fbdev/Kconfig"
 endmenu
 
 source "drivers/video/backlight/Kconfig"
+source "drivers/video/rockchip/Kconfig"
 
 config VGASTATE
        tristate
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 9ad3c17d6456..6eb93e61e56f 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -4,6 +4,7 @@ obj-$(CONFIG_HDMI)                += hdmi.o
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
 obj-y				  += backlight/
+obj-$(CONFIG_FB_ROCKCHIP)	  += rockchip/
 
 obj-y				  += fbdev/
 
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 8f8f8ce307f7..4d899cbd9a69 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -1,9 +1,7 @@
 obj-$(CONFIG_ROCKCHIP_RGA) += rga/
 obj-$(CONFIG_ROCKCHIP_RGA2) += rga2/
 obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o bmp_helper.o screen/
-obj-$(CONFIG_DRM_ROCKCHIP)  += rk_drm_fb.o screen/
 obj-$(CONFIG_RK_TRSM) += transmitter/
-obj-$(CONFIG_DRM_ROCKCHIP)  += lcdc/
 obj-$(CONFIG_FB_ROCKCHIP) += display-sys.o lcdc/
 obj-$(CONFIG_RK_HDMI) += hdmi/
 obj-$(CONFIG_IEP) += iep/
diff --git a/drivers/video/rockchip/display-sys.c b/drivers/video/rockchip/display-sys.c
old mode 100755
new mode 100644
index df94268066b6..7b12b59a7c36
--- a/drivers/video/rockchip/display-sys.c
+++ b/drivers/video/rockchip/display-sys.c
@@ -8,7 +8,7 @@
 static struct list_head main_display_device_list;
 static struct list_head aux_display_device_list;
 
-static ssize_t display_show_name(struct device *dev,
+static ssize_t display_name_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -16,7 +16,9 @@ static ssize_t display_show_name(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->name);
 }
 
-static ssize_t display_show_type(struct device *dev,
+static DEVICE_ATTR_RO(display_name);
+
+static ssize_t display_type_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -24,7 +26,9 @@ static ssize_t display_show_type(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->type);
 }
 
-static ssize_t display_show_property(struct device *dev,
+static DEVICE_ATTR_RO(display_type);
+
+static ssize_t display_property_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -32,7 +36,9 @@ static ssize_t display_show_property(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%d\n", dsp->property);
 }
 
-static ssize_t display_show_enable(struct device *dev,
+static DEVICE_ATTR_RO(display_property);
+
+static ssize_t display_enable_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -45,7 +51,7 @@ static ssize_t display_show_enable(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
 }
 
-static ssize_t display_store_enable(struct device *dev,
+static ssize_t display_enable_store(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t size)
 {
@@ -59,7 +65,9 @@ static ssize_t display_store_enable(struct device *dev,
 	return size;
 }
 
-static ssize_t display_show_connect(struct device *dev,
+static DEVICE_ATTR_RW(display_enable);
+
+static ssize_t display_connect_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -72,6 +80,8 @@ static ssize_t display_show_connect(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%d\n", connect);
 }
 
+static DEVICE_ATTR_RO(display_connect);
+
 static int mode_string(char *buf, unsigned int offset,
 		       const struct fb_videomode *mode)
 {
@@ -105,7 +115,7 @@ static int mode_string(char *buf, unsigned int offset,
 				mode->xres, mode->yres, v, mode->refresh);
 }
 
-static ssize_t display_show_modes(struct device *dev,
+static ssize_t display_modes_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -139,7 +149,9 @@ static ssize_t display_show_modes(struct device *dev,
 	return i;
 }
 
-static ssize_t display_show_mode(struct device *dev,
+static DEVICE_ATTR_RO(display_modes);
+
+static ssize_t display_mode_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -151,7 +163,7 @@ static ssize_t display_show_mode(struct device *dev,
 	return 0;
 }
 
-static ssize_t display_store_mode(struct device *dev,
+static ssize_t display_mode_store(struct device *dev,
 				  struct device_attribute *attr,
 				  const char *buf, size_t count)
 {
@@ -195,7 +207,9 @@ static ssize_t display_store_mode(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_scale(struct device *dev,
+static DEVICE_ATTR_RW(display_mode);
+
+static ssize_t display_scale_show(struct device *dev,
 				  struct device_attribute *attr,
 				  char *buf)
 {
@@ -213,7 +227,7 @@ static ssize_t display_show_scale(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_store_scale(struct device *dev,
+static ssize_t display_scale_store(struct device *dev,
 				   struct device_attribute *attr,
 				   const char *buf, size_t count)
 {
@@ -246,7 +260,9 @@ static ssize_t display_store_scale(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_3dmode(struct device *dev,
+static DEVICE_ATTR_RW(display_scale);
+
+static ssize_t display_3dmode_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -312,7 +328,7 @@ static ssize_t display_show_3dmode(struct device *dev,
 	return i;
 }
 
-static ssize_t display_store_3dmode(struct device *dev,
+static ssize_t display_3dmode_store(struct device *dev,
 				    struct device_attribute *attr,
 				    const char *buf, size_t count)
 {
@@ -330,7 +346,9 @@ static ssize_t display_store_3dmode(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_color(struct device *dev,
+static DEVICE_ATTR_RW(display_3dmode);
+
+static ssize_t display_color_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -343,7 +361,7 @@ static ssize_t display_show_color(struct device *dev,
 	return ret;
 }
 
-static ssize_t display_store_color(struct device *dev,
+static ssize_t display_color_store(struct device *dev,
 				   struct device_attribute *attr,
 				   const char *buf, size_t count)
 {
@@ -360,7 +378,9 @@ static ssize_t display_store_color(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_sinkaudioinfo(struct device *dev,
+static DEVICE_ATTR_RW(display_color);
+
+static ssize_t display_sinkaudioinfo_show(struct device *dev,
 					  struct device_attribute *attr,
 					  char *buf)
 {
@@ -380,7 +400,9 @@ static ssize_t display_show_sinkaudioinfo(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_monspecs(struct device *dev,
+static DEVICE_ATTR_RO(display_sinkaudioinfo);
+
+static ssize_t display_monspecs_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -400,7 +422,9 @@ static ssize_t display_show_monspecs(struct device *dev,
 	return -EINVAL;
 }
 
-static ssize_t display_show_debug(struct device *dev,
+static DEVICE_ATTR_RO(display_monspecs);
+
+static ssize_t display_debug_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -413,7 +437,7 @@ static ssize_t display_show_debug(struct device *dev,
 	return ret;
 }
 
-static ssize_t display_store_debug(struct device *dev,
+static ssize_t display_debug_store(struct device *dev,
 				   struct device_attribute *attr,
 				   const char *buf, size_t count)
 {
@@ -430,23 +454,27 @@ static ssize_t display_store_debug(struct device *dev,
 	return ret;
 }
 
-static struct device_attribute display_attrs[] = {
-	__ATTR(name, S_IRUGO, display_show_name, NULL),
-	__ATTR(type, S_IRUGO, display_show_type, NULL),
-	__ATTR(property, S_IRUGO, display_show_property, NULL),
-	__ATTR(enable, 0666, display_show_enable, display_store_enable),
-	__ATTR(connect, S_IRUGO, display_show_connect, NULL),
-	__ATTR(modes, S_IRUGO, display_show_modes, NULL),
-	__ATTR(mode, 0666, display_show_mode, display_store_mode),
-	__ATTR(scale, 0666, display_show_scale, display_store_scale),
-	__ATTR(3dmode, 0666, display_show_3dmode, display_store_3dmode),
-	__ATTR(color, 0666, display_show_color, display_store_color),
-	__ATTR(audioinfo, S_IRUGO, display_show_sinkaudioinfo, NULL),
-	__ATTR(monspecs, S_IRUGO, display_show_monspecs, NULL),
-	__ATTR(debug, 0664, display_show_debug, display_store_debug),
-	__ATTR_NULL
+static DEVICE_ATTR_RW(display_debug);
+
+static struct attribute *display_device_attrs[] = {
+	&dev_attr_display_name.attr,
+	&dev_attr_display_type.attr,
+	&dev_attr_display_property.attr,
+	&dev_attr_display_enable.attr,
+	&dev_attr_display_connect.attr,
+	&dev_attr_display_modes.attr,
+	&dev_attr_display_mode.attr,
+	&dev_attr_display_scale.attr,
+	&dev_attr_display_3dmode.attr,
+	&dev_attr_display_color.attr,
+	&dev_attr_display_sinkaudioinfo.attr,
+	&dev_attr_display_monspecs.attr,
+	&dev_attr_display_debug.attr,
+	NULL,
 };
 
+ATTRIBUTE_GROUPS(display_device);
+
 static int display_suspend(struct device *dev, pm_message_t state)
 {
 	struct rk_display_device *dsp = dev_get_drvdata(dev);
@@ -733,7 +761,7 @@ static int __init rk_display_class_init(void)
 		display_class = NULL;
 		return -EINVAL;
 	}
-	display_class->dev_attrs = display_attrs;
+	display_class->dev_groups = display_device_groups;
 	display_class->suspend = display_suspend;
 	display_class->resume = display_resume;
 	mutex_init(&allocated_dsp_lock);
diff --git a/drivers/video/rockchip/lcdc/rk3288_lcdc.c b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
index 63c019339bd2..7e594a70aef6 100755
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
@@ -3958,9 +3958,6 @@ static irqreturn_t rk3288_lcdc_isr(int irq, void *dev_id)
 			complete(&(lcdc_dev->driver.frame_done));
 			spin_unlock(&(lcdc_dev->driver.cpl_lock));
 		}
-#ifdef CONFIG_DRM_ROCKCHIP
-		lcdc_dev->driver.irq_call_back(&lcdc_dev->driver);
-#endif 
 		lcdc_dev->driver.vsync_info.timestamp = timestamp;
 		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
 
diff --git a/drivers/video/rockchip/lcdc/rk3368_lcdc.c b/drivers/video/rockchip/lcdc/rk3368_lcdc.c
old mode 100755
new mode 100644
index 292121bd497b..35c116ce0f4c
--- a/drivers/video/rockchip/lcdc/rk3368_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3368_lcdc.c
@@ -81,6 +81,16 @@ static struct rk_lcdc_win lcdc_win[] = {
 
 static int rk3368_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
 
+void __weak rk_pwm_set(int bl_pwm_period, int bl_pwm_duty)
+{
+	pr_info("If you want to use CABC, this func need implement at pwm\n");
+}
+
+void __weak rk_pwm_get(int *bl_pwm_period, int *bl_pwm_duty)
+{
+	pr_info("If you want to use CABC, this func need implement at pwm\n");
+}
+
 /*#define WAIT_FOR_SYNC 1*/
 u32 rk3368_get_hard_ware_vskiplines(u32 srch, u32 dsth)
 {
@@ -153,7 +163,8 @@ static int rk3368_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
 		clk_prepare_enable(lcdc_dev->hclk);
 		clk_prepare_enable(lcdc_dev->dclk);
 		clk_prepare_enable(lcdc_dev->aclk);
-		clk_prepare_enable(lcdc_dev->pd);
+		if (lcdc_dev->pd)
+			clk_prepare_enable(lcdc_dev->pd);
 		spin_lock(&lcdc_dev->reg_lock);
 		lcdc_dev->clk_on = 1;
 		spin_unlock(&lcdc_dev->reg_lock);
@@ -176,7 +187,8 @@ static int rk3368_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
 		clk_disable_unprepare(lcdc_dev->dclk);
 		clk_disable_unprepare(lcdc_dev->hclk);
 		clk_disable_unprepare(lcdc_dev->aclk);
-		clk_disable_unprepare(lcdc_dev->pd);
+		if (lcdc_dev->pd)
+			clk_disable_unprepare(lcdc_dev->pd);
 	}
 
 	return 0;
@@ -429,13 +441,19 @@ static int rk3368_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
 	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
 	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
 	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
-	lcdc_dev->pd = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
-
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||
-	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+	if ((IS_ERR(lcdc_dev->aclk)) || (IS_ERR(lcdc_dev->dclk)) ||
+	    (IS_ERR(lcdc_dev->hclk))) {
 		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
 			lcdc_dev->id);
 	}
+
+	lcdc_dev->pd = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
+	if (IS_ERR(lcdc_dev->pd)) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d pdclk source\n",
+			lcdc_dev->id);
+		lcdc_dev->pd = NULL;
+	}
+
 	if (!support_uboot_display())
 		rk_disp_pwr_enable(dev_drv);
 	rk3368_lcdc_clk_enable(lcdc_dev);
@@ -1545,7 +1563,7 @@ static int __maybe_unused rk3368_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
 		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
 		return 0;
 	}
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 	if (dev_drv->iommu_enabled) {
 		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
 			if (likely(lcdc_dev->clk_on)) {
@@ -2213,7 +2231,7 @@ static int rk3368_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
 		rk3368_lcdc_pre_init(dev_drv);
 		rk3368_lcdc_clk_enable(lcdc_dev);
 		rk3368_lcdc_enable_irq(dev_drv);
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled) {
 			if (!dev_drv->mmu_dev) {
 				dev_drv->mmu_dev =
@@ -2263,7 +2281,7 @@ static int rk3368_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
 	/*if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
 	   rk3368_lcdc_disable_irq(lcdc_dev);
 	   rk3368_lcdc_reg_update(dev_drv);
-	   #if defined(CONFIG_ROCKCHIP_IOMMU)
+	   #if defined(CONFIG_RK_IOMMU)
 	   if (dev_drv->iommu_enabled) {
 	   if (dev_drv->mmu_dev)
 	   rockchip_iovmm_deactivate(dev_drv->dev);
@@ -4771,9 +4789,6 @@ static irqreturn_t rk3368_lcdc_isr(int irq, void *dev_id)
 			complete(&(lcdc_dev->driver.frame_done));
 			spin_unlock(&(lcdc_dev->driver.cpl_lock));
 		}
-#ifdef CONFIG_DRM_ROCKCHIP
-		lcdc_dev->driver.irq_call_back(&lcdc_dev->driver);
-#endif
 		lcdc_dev->driver.vsync_info.timestamp = timestamp;
 		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
 		if ((screen->mode.vmode & FB_VMODE_NONINTERLACED) ||
@@ -4907,7 +4922,7 @@ static int rk3368_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
 		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
 	}
 
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
 		dev_drv->iommu_enabled = 0;
 	else
@@ -4974,7 +4989,7 @@ static int rk3368_lcdc_probe(struct platform_device *pdev)
 		syscon_regmap_lookup_by_phandle(np, "rockchip,cru");
 	if (IS_ERR(lcdc_dev->cru_base)) {
 		dev_err(&pdev->dev, "can't find lcdc cru_base property\n");
-		return PTR_ERR(lcdc_dev->cru_base);
+		lcdc_dev->cru_base = NULL;
 	}
 
 	lcdc_dev->id = 0;
@@ -4996,7 +5011,7 @@ static int rk3368_lcdc_probe(struct platform_device *pdev)
 	}
 
 	ret = devm_request_irq(dev, lcdc_dev->irq, rk3368_lcdc_isr,
-			       IRQF_DISABLED | IRQF_SHARED,
+			       IRQF_SHARED,
 			       dev_name(dev), lcdc_dev);
 	if (ret) {
 		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
diff --git a/drivers/video/rockchip/rk_drm_fb.c b/drivers/video/rockchip/rk_drm_fb.c
deleted file mode 100755
index 6381615b41ce..000000000000
--- a/drivers/video/rockchip/rk_drm_fb.c
+++ /dev/null
@@ -1,972 +0,0 @@
-/*
- * drivers/video/rockchip/rk_fb.c
- *
- * Copyright (C) ROCKCHIP, Inc.
- * Author:yzq<yxj@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/kthread.h>
-#include <linux/fb.h>
-#include <linux/init.h>
-#include <asm/div64.h>
-#include <linux/uaccess.h>
-#include <linux/rk_fb.h>
-#include <linux/linux_logo.h>
-#include <linux/dma-mapping.h>
-#include <drm/drm_os_linux.h>
-#include <linux/of_gpio.h>
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <video/of_display_timing.h>
-#include <video/display_timing.h>
-#include <dt-bindings/rkfb/rk_fb.h>
-#endif
-
-#include <linux/display-sys.h>
-#include "rk_drm_fb.h"
-__weak int support_uboot_display(void)
-{
-	return 0;
-}
-static struct platform_device *drm_fb_pdev;
-static struct rk_fb_trsm_ops *trsm_lvds_ops;
-static struct rk_fb_trsm_ops *trsm_edp_ops;
-static struct rk_fb_trsm_ops *trsm_mipi_ops;
-static struct rk_display_device *disp_hdmi_devices;
-void rk_drm_display_register(struct rk_display_ops *extend_ops, void *displaydata,int type)
-{
-	switch(type) {
-		case SCREEN_HDMI:
-			disp_hdmi_devices = kzalloc(sizeof(struct rk_display_device), GFP_KERNEL);
-			disp_hdmi_devices->priv_data = displaydata;
-			disp_hdmi_devices->ops = extend_ops;
-			break;
-		default:
-			printk(KERN_WARNING "%s:un supported extend display:%d!\n",
-			__func__, type);
-		break;
-	}
-}
-int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)
-{
-	switch (type) {
-	case SCREEN_RGB:
-	case SCREEN_LVDS:
-	case SCREEN_DUAL_LVDS:
-		trsm_lvds_ops = ops;
-		break;
-	case SCREEN_EDP:
-		trsm_edp_ops = ops;
-		break;
-	case SCREEN_MIPI:
-	case SCREEN_DUAL_MIPI:
-		trsm_mipi_ops = ops;
-		break;
-	default:
-		printk(KERN_WARNING "%s:un supported transmitter:%d!\n",
-			__func__, type);
-		break;
-	}
-	return 0;
-}
-
-struct rk_display_device *rk_drm_extend_display_get(int type)
-{
-	struct rk_display_device *extend_display = NULL;
-	switch (type) {
-		case SCREEN_HDMI:
-			if(disp_hdmi_devices)
-				extend_display = disp_hdmi_devices;
-			else
-				printk(KERN_WARNING "%s:screen hdmi ops is NULL!\n",__func__);
-			break;
-		default:
-			printk(KERN_WARNING "%s:un supported extend display:%d!\n",
-			__func__, type);
-			break;
-	}
-	return extend_display;
-}
-#if 0
-struct void *get_extend_drv(void)
-{
-	struct rk_display_device *extend_display = rk_drm_extend_display_get(SCREEN_HDMI);
-	return extend_display->priv_data;
-}
-#endif
-struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type)
-{
-	struct rk_fb_trsm_ops *ops;
-	switch (type) {
-	case SCREEN_RGB:
-	case SCREEN_LVDS:
-	case SCREEN_DUAL_LVDS:
-		ops = trsm_lvds_ops;
-		break;
-	case SCREEN_EDP:
-		ops = trsm_edp_ops;
-		break;
-	case SCREEN_MIPI:
-	case SCREEN_DUAL_MIPI:
-		ops = trsm_mipi_ops;
-		break;
-	default:
-		ops = NULL;
-		printk(KERN_WARNING "%s:un supported transmitter:%d!\n",
-			__func__, type);
-		break;
-	}
-	return ops;
-}
-/* rk display power control parse from dts
- *
-*/
-int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)
-{
-	struct device_node *root  = of_get_child_by_name(dev_drv->dev->of_node,
-				"power_ctr");
-	struct device_node *child;
-	struct rk_disp_pwr_ctr_list *pwr_ctr;
-	struct list_head *pos;
-	enum of_gpio_flags flags;
-	u32 val = 0;
-	u32 debug = 0;
-	u32 mirror = 0;
-	int ret;
-
-	INIT_LIST_HEAD(&dev_drv->pwrlist_head);
-	if (!root) {
-		dev_err(dev_drv->dev, "can't find power_ctr node for lcdc%d\n",dev_drv->id);
-		return -ENODEV;
-	}
-
-	for_each_child_of_node(root, child) {
-		pwr_ctr = kmalloc(sizeof(struct rk_disp_pwr_ctr_list), GFP_KERNEL);
-		strcpy(pwr_ctr->pwr_ctr.name, child->name);
-		if (!of_property_read_u32(child, "rockchip,power_type", &val)) {
-			if (val == GPIO) {
-				pwr_ctr->pwr_ctr.type = GPIO;
-				pwr_ctr->pwr_ctr.gpio = of_get_gpio_flags(child, 0, &flags);
-				if (!gpio_is_valid(pwr_ctr->pwr_ctr.gpio)) {
-					dev_err(dev_drv->dev, "%s ivalid gpio\n", child->name);
-					return -EINVAL;
-				}
-				pwr_ctr->pwr_ctr.atv_val = !(flags & OF_GPIO_ACTIVE_LOW);
-				ret = gpio_request(pwr_ctr->pwr_ctr.gpio,child->name);
-				if (ret) {
-					dev_err(dev_drv->dev, "request %s gpio fail:%d\n",
-						child->name,ret);
-				}
-
-			} else {
-				pwr_ctr->pwr_ctr.type = REGULATOR;
-
-			}
-		};
-		of_property_read_u32(child, "rockchip,delay", &val);
-		pwr_ctr->pwr_ctr.delay = val;
-		list_add_tail(&pwr_ctr->list, &dev_drv->pwrlist_head);
-	}
-
-	of_property_read_u32(root, "rockchip,mirror", &mirror);
-
-	if (mirror == NO_MIRROR) {
-		dev_drv->screen0->x_mirror = 0;
-		dev_drv->screen0->y_mirror = 0;
-	} else if (mirror == X_MIRROR) {
-		dev_drv->screen0->x_mirror = 1;
-		dev_drv->screen0->y_mirror = 0;
-	} else if (mirror == Y_MIRROR) {
-		dev_drv->screen0->x_mirror = 0;
-		dev_drv->screen0->y_mirror = 1;
-	} else if(mirror == X_Y_MIRROR) {
-		dev_drv->screen0->x_mirror = 1;
-		dev_drv->screen0->y_mirror = 1;
-	}
-
-	of_property_read_u32(root, "rockchip,debug", &debug);
-
-	if (debug) {
-		list_for_each(pos, &dev_drv->pwrlist_head) {
-			pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
-			printk(KERN_INFO "pwr_ctr_name:%s\n"
-					 "pwr_type:%s\n"
-					 "gpio:%d\n"
-					 "atv_val:%d\n"
-					 "delay:%d\n\n",
-					 pwr_ctr->pwr_ctr.name,
-					 (pwr_ctr->pwr_ctr.type == GPIO) ? "gpio" : "regulator",
-					 pwr_ctr->pwr_ctr.gpio,
-					 pwr_ctr->pwr_ctr.atv_val,
-					 pwr_ctr->pwr_ctr.delay);
-		}
-	}
-
-	return 0;
-
-}
-
-int rk_fb_video_mode_from_timing(const struct display_timing *dt, 
-				struct rk_screen *screen)
-{
-	screen->mode.pixclock = dt->pixelclock.typ;
-	screen->mode.left_margin = dt->hback_porch.typ;
-	screen->mode.right_margin = dt->hfront_porch.typ;
-	screen->mode.xres = dt->hactive.typ;
-	screen->mode.hsync_len = dt->hsync_len.typ;
-	screen->mode.upper_margin = dt->vback_porch.typ;
-	screen->mode.lower_margin = dt->vfront_porch.typ;
-	screen->mode.yres = dt->vactive.typ;
-	screen->mode.vsync_len = dt->vsync_len.typ;
-	screen->type = dt->screen_type;
-	screen->lvds_format = dt->lvds_format;
-	screen->face = dt->face;
-
-	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
-		screen->pin_dclk = 1;
-	else
-		screen->pin_dclk = 0;
-	if(dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_DE_HIGH)
-		screen->pin_den = 1;
-	else
-		screen->pin_den = 0;
-	
-	return 0;
-	
-}
-
-int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
-{
-	struct display_timings *disp_timing;
-	struct display_timing *dt;
-	disp_timing = of_get_display_timings(np);
-	if (!disp_timing) {
-		pr_err("parse display timing err\n");
-		return -EINVAL;
-	}
-	dt = display_timings_get(disp_timing, 0);
-	rk_fb_video_mode_from_timing(dt, screen);
-	printk(KERN_ERR "dclk:%d\n"
-			 "hactive:%d\n"
-			 "hback_porch:%d\n"
-			 "hfront_porch:%d\n"
-			 "hsync_len:%d\n"
-			 "vactive:%d\n"
-			 "vback_porch:%d\n"
-			 "vfront_porch:%d\n"
-			 "vsync_len:%d\n"
-			 "screen_type:%d\n"
-			 "lvds_format:%d\n"
-			 "face:%d\n",
-			dt->pixelclock.typ,
-			dt->hactive.typ,
-			dt->hback_porch.typ,
-			dt->hfront_porch.typ,
-			dt->hsync_len.typ,
-			dt->vactive.typ,
-			dt->vback_porch.typ,
-			dt->vfront_porch.typ,
-			dt->vsync_len.typ,
-			dt->screen_type,
-			dt->lvds_format,
-			dt->face);
-	return 0;
-
-}
-static int init_lcdc_win(struct rk_lcdc_driver *dev_drv, struct rk_lcdc_win *def_win)
-{
-	int i;
-	int lcdc_win_num = dev_drv->lcdc_win_num;
-	for (i = 0; i < lcdc_win_num; i++) {
-		struct rk_lcdc_win *win = NULL;
-		win =  kzalloc(sizeof(struct rk_lcdc_win), GFP_KERNEL);
-		if (!win) {
-			dev_err(dev_drv->dev, "kzmalloc for win fail!");
-			return   -ENOMEM;
-		}
-
-		strcpy(win->name, def_win[i].name);
-		win->id = def_win[i].id;
-		win->support_3d = def_win[i].support_3d;
-		dev_drv->win[i] = win;
-	}
-
-	return 0;
-}
-
-static int init_lcdc_device_driver(struct rk_drm_screen_private *screen_priv,
-					struct rk_lcdc_win *def_win, int index)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_lcdc_driver *dev_drv = screen_priv->lcdc_dev_drv;
-	struct rk_screen *screen1 = NULL;
-	struct rk_screen *screen = devm_kzalloc(dev_drv->dev,
-				sizeof(struct rk_screen), GFP_KERNEL);
-	if (!screen) {
-		dev_err(dev_drv->dev, "malloc screen for lcdc%d fail!",
-					dev_drv->id);
-		goto fail_screen;
-	}
-	
-	screen->screen_id = 0;
-	screen->lcdc_id = dev_drv->id;
-	screen->overscan.left = 100;
-	screen->overscan.top = 100;
-	screen->overscan.right = 100;
-	screen->overscan.bottom = 100;
-	dev_drv->screen0 = screen;
-	dev_drv->cur_screen = screen;
-	/* devie use one lcdc + rk61x scaler for dual display*/
-	if (rk_drm_priv->disp_mode == ONE_DUAL) {
-		screen1 = devm_kzalloc(dev_drv->dev,
-						sizeof(struct rk_screen), GFP_KERNEL);
-		if (screen1) {
-			dev_err(dev_drv->dev, "malloc screen1 for lcdc%d fail!",
-						dev_drv->id);
-			goto fail_screen1;
-		}
-		screen1->screen_id = 1;
-		screen1->lcdc_id = 1;
-		dev_drv->screen1 = screen1;
-	}
-	sprintf(dev_drv->name, "lcdc%d", dev_drv->id);
-	init_lcdc_win(dev_drv, def_win);
-	init_completion(&dev_drv->frame_done);
-	spin_lock_init(&dev_drv->cpl_lock);
-	mutex_init(&dev_drv->fb_win_id_mutex);
-	dev_drv->ops->fb_win_remap(dev_drv, FB_DEFAULT_ORDER);
-	dev_drv->first_frame = 1;
-	rk_disp_pwr_ctr_parse_dt(dev_drv);
-	if (dev_drv->prop == PRMRY) {
-		rk_fb_set_prmry_screen(screen);
-		rk_fb_get_prmry_screen(screen);
-		dev_drv->trsm_ops = rk_fb_trsm_ops_get(screen->type);
-	}
-
-	return 0;
-
-fail_screen1:
-	devm_kfree(dev_drv->dev,screen);
-fail_screen:
-	
-	return -ENOMEM;
-}
-int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)
-{
-	struct list_head *pos;
-	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
-	struct pwr_ctr *pwr_ctr;
-	if (list_empty(&dev_drv->pwrlist_head))
-		return 0;
-	list_for_each(pos, &dev_drv->pwrlist_head) {
-		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
-		pwr_ctr = &pwr_ctr_list->pwr_ctr;
-		if (pwr_ctr->type == GPIO) {
-			gpio_direction_output(pwr_ctr->gpio,pwr_ctr->atv_val);
-			mdelay(pwr_ctr->delay);
-		}
-	}
-
-	return 0;
-}
-int  rk_fb_calc_fps(struct rk_screen * screen, u32 pixclock)
-{
-	int x, y;
-	unsigned long long hz;
-	if (!screen) {
-		printk(KERN_ERR "%s:null screen!\n", __func__);
-		return 0;
-	}
-	x = screen->mode.xres + screen->mode.left_margin + screen->mode.right_margin +
-	    screen->mode.hsync_len;
-	y = screen->mode.yres + screen->mode.upper_margin + screen->mode.lower_margin +
-	    screen->mode.vsync_len;
-
-	hz = 1000000000000ULL;	/* 1e12 picoseconds per second */
-
-	hz += (x * y) / 2;
-	do_div(hz, x * y);	/* divide by x * y with rounding */
-
-	hz += pixclock / 2;
-	do_div(hz, pixclock);	/* divide by pixclock with rounding */
-
-	return hz;
-}
-
-char *get_format_string(enum data_format format, char *fmt)
-{
-	if (!fmt)
-		return NULL;
-	switch (format) {
-	case ARGB888:
-		strcpy(fmt, "ARGB888");
-		break;
-	case RGB888:
-		strcpy(fmt, "RGB888");
-		break;
-	case RGB565:
-		strcpy(fmt, "RGB565");
-		break;
-	case YUV420:
-		strcpy(fmt, "YUV420");
-		break;
-	case YUV422:
-		strcpy(fmt, "YUV422");
-		break;
-	case YUV444:
-		strcpy(fmt, "YUV444");
-		break;
-	case XRGB888:
-		strcpy(fmt, "XRGB888");
-		break;
-	case XBGR888:
-		strcpy(fmt, "XBGR888");
-		break;
-	case ABGR888:
-		strcpy(fmt, "XBGR888");
-		break;
-	default:
-		strcpy(fmt, "invalid");
-		break;
-	}
-
-	return fmt;
-
-}
-int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)
-{
-	struct list_head *pos;
-	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
-	struct pwr_ctr *pwr_ctr;
-	if (list_empty(&dev_drv->pwrlist_head))
-		return 0;
-	list_for_each(pos, &dev_drv->pwrlist_head) {
-		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
-		pwr_ctr = &pwr_ctr_list->pwr_ctr;
-		if (pwr_ctr->type == GPIO) {
-			gpio_set_value(pwr_ctr->gpio,pwr_ctr->atv_val);
-		}
-	}
-
-	return 0;
-}
-/********************************
-*check if the primary lcdc has registerd,
-the primary lcdc mas register first
-*********************************/
-bool is_prmry_rk_lcdc_registered(void)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	if (rk_drm_priv->screen_priv[0].lcdc_dev_drv)
-		return  true;
-	else
-		return false;
-
-
-}
-static void rk_fb_update_regs_handler(struct kthread_work *work)
-{
-	struct rk_lcdc_driver * dev_drv =
-			container_of(work, struct rk_lcdc_driver, update_regs_work);
-	struct rk_fb_reg_data *data, *next;
-#if 0
-	//struct list_head saved_list;
-	mutex_lock(&dev_drv->update_regs_list_lock);
-	saved_list = dev_drv->update_regs_list;
-	list_replace_init(&dev_drv->update_regs_list, &saved_list);
-	mutex_unlock(&dev_drv->update_regs_list_lock);
-	
-	list_for_each_entry_safe(data, next, &saved_list, list) {
-		//rk_fb_update_reg(dev_drv,data);
-		list_del(&data->list);
-		kfree(data);
-	}
-#endif
-}
-static int rk_fb_wait_for_vsync_thread(void *data)
-{
-	struct rk_lcdc_driver  *dev_drv = data;
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv = NULL;
-	struct rk_drm_display *drm_display = NULL;
-
-	if(dev_drv->prop == PRMRY)
-		drm_screen_priv = &rk_drm_priv->screen_priv[0];
-	else if(dev_drv->prop == EXTEND)
-		drm_screen_priv = &rk_drm_priv->screen_priv[1];
-	if(drm_screen_priv == NULL)
-		return -1;
-	drm_display = &drm_screen_priv->drm_disp;
-
-	while (!kthread_should_stop()) {
-		ktime_t timestamp = dev_drv->vsync_info.timestamp;
-		int ret = wait_event_interruptible(dev_drv->vsync_info.wait,
-			!ktime_equal(timestamp, dev_drv->vsync_info.timestamp) &&
-			(dev_drv->vsync_info.active || dev_drv->vsync_info.irq_stop));
-#if 1
-		if(atomic_read(&drm_screen_priv->wait_vsync_done)){
-			atomic_set(&drm_screen_priv->wait_vsync_done,0);
-			DRM_WAKEUP(&drm_screen_priv->wait_vsync_queue);
-		}
-		if(!ret && drm_display->event_call_back)
-			drm_display->event_call_back(drm_display,0,RK_DRM_CALLBACK_VSYNC);
-#endif
-	}
-
-	return 0;
-}
-
-static void rk_drm_irq_handle(struct rk_lcdc_driver *dev_drv)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv = NULL;
-	struct rk_drm_display *drm_display = NULL;
-	if(dev_drv->prop == PRMRY)
-		drm_screen_priv = &rk_drm_priv->screen_priv[0];
-	else if(dev_drv->prop == EXTEND)
-		drm_screen_priv = &rk_drm_priv->screen_priv[1];
-	if(drm_screen_priv == NULL)
-		return -1;
-	drm_display = &drm_screen_priv->drm_disp;
-	if(atomic_read(&drm_screen_priv->wait_vsync_done)){
-			atomic_set(&drm_screen_priv->wait_vsync_done,0);
-			DRM_WAKEUP(&drm_screen_priv->wait_vsync_queue);
-	}
-
-	if(drm_display->event_call_back)
-			drm_display->event_call_back(drm_display,0,RK_DRM_CALLBACK_VSYNC);
-}
-int rk_fb_register(struct rk_lcdc_driver *dev_drv,
-		struct rk_lcdc_win *win, int id)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_display *drm_display = NULL;
-	struct rk_drm_screen_private *drm_screen_priv = NULL;
-	int i=0;
-
-	if (rk_drm_priv->num_screen == RK30_MAX_LCDC_SUPPORT)
-		return -ENXIO;
-	for (i = 0; i < RK_DRM_MAX_SCREEN_NUM; i++) {
-		if (!rk_drm_priv->screen_priv[i].lcdc_dev_drv) 
-			break;
-	}
-	rk_drm_priv->num_screen++;
-	drm_screen_priv = &rk_drm_priv->screen_priv[i];	
-	drm_screen_priv->lcdc_dev_drv = dev_drv;
-	drm_screen_priv->lcdc_dev_drv->id = id;
-
-	init_lcdc_device_driver(drm_screen_priv,win,i);
-	dev_drv->irq_call_back = rk_drm_irq_handle;
-	
-	drm_display = &drm_screen_priv->drm_disp;
-	drm_display->num_win = dev_drv->lcdc_win_num;
-	atomic_set(&drm_screen_priv->wait_vsync_done, 1);
-	DRM_INIT_WAITQUEUE(&drm_screen_priv->wait_vsync_queue);
-	if(dev_drv->prop == PRMRY){
-		struct fb_modelist *modelist_new;
-		struct fb_modelist *modelist;
-		struct fb_videomode *mode;
-		drm_display->modelist = kmalloc(sizeof(struct list_head),GFP_KERNEL);
-		INIT_LIST_HEAD(drm_display->modelist);
-		modelist_new = kmalloc(sizeof(struct fb_modelist),
-				  GFP_KERNEL);
-		drm_display->screen_type = RK_DRM_PRIMARY_SCREEN;
-		drm_display->num_videomode = 1;
-		drm_display->best_mode = 0;
-		drm_display->is_connected = 1;
-		memcpy(&modelist_new->mode,&dev_drv->cur_screen->mode,sizeof(struct fb_videomode));
-
-	//	printk("---->yzq mode xres=%d yres=%d \n",modelist_new->mode.xres,modelist_new->mode.yres);
-		list_add_tail(&modelist_new->list,drm_display->modelist);
-
-		modelist = list_first_entry(drm_display->modelist, struct fb_modelist, list);
-		mode=&modelist->mode;
-	//	printk("---->yzq 1mode xres=%d yres=%d \n",mode->xres,mode->yres);
-
-	}else if(dev_drv->prop == EXTEND){
-		struct list_head *modelist;
-		drm_screen_priv->ex_display = rk_drm_extend_display_get(SCREEN_HDMI);
-	//	printk("------>yzq ex_display=%x\n",drm_screen_priv->ex_display);
-		drm_display->screen_type = RK_DRM_EXTEND_SCREEN;
-		drm_display->is_connected = 0;
-#if 0
-		drm_screen_priv->ex_display->ops->getmodelist(drm_screen_priv->ex_display,&modelist);
-
-		memcpy(&drm_display->modelist,modelist,sizeof(struct list_head));
-		drm_display->is_connected = drm_screen_priv->ex_display->ops->getstatus(drm_screen_priv->ex_display);
-#endif
-	}
-	if (1){//dev_drv->prop == PRMRY) {
-		init_waitqueue_head(&dev_drv->vsync_info.wait);
-		dev_drv->vsync_info.thread = kthread_run(rk_fb_wait_for_vsync_thread,
-				dev_drv, "fb-vsync");
-		if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) {
-			printk( "failed to run vsync thread\n");
-			dev_drv->vsync_info.thread = NULL;
-		}
-		dev_drv->vsync_info.active = 1;
-
-		mutex_init(&dev_drv->output_lock);
-
-		INIT_LIST_HEAD(&dev_drv->update_regs_list);
-		mutex_init(&dev_drv->update_regs_list_lock);
-		init_kthread_worker(&dev_drv->update_regs_worker);
-
-		dev_drv->update_regs_thread = kthread_run(kthread_worker_fn,
-				&dev_drv->update_regs_worker, "rk-fb");
-		if (IS_ERR(dev_drv->update_regs_thread)) {
-			int err = PTR_ERR(dev_drv->update_regs_thread);
-			dev_drv->update_regs_thread = NULL;
-
-			printk("failed to run update_regs thread\n");
-			return err;
-		}
-		init_kthread_work(&dev_drv->update_regs_work, rk_fb_update_regs_handler);
-
-		dev_drv->timeline = sw_sync_timeline_create("fb-timeline");			dev_drv->timeline_max = 1;
-	}
-	return 0;
-}
-int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
-
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	int i = 0;
-
-	return 0;
-}
-
-struct rk_drm_display *rk_drm_get_info(int screen_type)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	int i=0;
-	for( i=0; i<rk_drm_priv->num_screen; i++){
-		if(rk_drm_priv->screen_priv[i].drm_disp.screen_type == screen_type)
-			break;
-	}
-	if(i==rk_drm_priv->num_screen){
-		printk("--->%s can not find match DISPLAY_TYPE %d\n",__func__,screen_type);
-		return NULL;
-	}
-	
-	return &rk_drm_priv->screen_priv[i].drm_disp;
-}
-
-static int rk_drm_screen_blank(struct rk_drm_display *drm_disp)
-{
-//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv =
-	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
-	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
-
-	lcdc_dev->ops->blank(lcdc_dev, 0,drm_disp->enable?FB_BLANK_UNBLANK:FB_BLANK_NORMAL);
-
-	return 0;
-}
-
-int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id)
-{
-	return 0;
-}
-/**********************************************************************
-this is for hdmi
-name: lcdc device name ,lcdc0 , lcdc1
-***********************************************************************/
-struct rk_lcdc_driver *rk_get_lcdc_drv(char *name)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	int i = 0;
-	for (i = 0; i < rk_drm_priv->num_screen; i++) {
-		if (!strcmp(rk_drm_priv->screen_priv[i].lcdc_dev_drv->name, name))
-			break;
-	}
-	return rk_drm_priv->screen_priv[i].lcdc_dev_drv;
-
-}
-int rk_fb_switch_screen(struct rk_screen *screen , int enable, int lcdc_id)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_lcdc_driver *dev_drv = NULL;
-	struct rk_drm_display *drm_disp = NULL;
-	char name[6];
-	int i;
-	
-	sprintf(name, "lcdc%d", lcdc_id);
-
-	if (rk_drm_priv->disp_mode != DUAL) {
-		dev_drv = rk_drm_priv->screen_priv[0].lcdc_dev_drv;
-	} else {
-
-		for (i = 0; i < rk_drm_priv->num_screen; i++) {
-			if (rk_drm_priv->screen_priv[i].lcdc_dev_drv->prop == EXTEND) {
-				drm_disp = &rk_drm_priv->screen_priv[i].drm_disp;
-				dev_drv = rk_drm_priv->screen_priv[i].lcdc_dev_drv;
-				break;
-			}
-		}
-
-		if (i == rk_drm_priv->num_screen) {
-			printk(KERN_ERR "%s driver not found!", name);
-			return -ENODEV;
-		}
-	}
-	printk("hdmi %s lcdc%d\n", enable ? "connect to" : "remove from", dev_drv->id);
-
-
-	if(enable && !drm_disp->is_connected ){
-		struct list_head *modelist;
-		struct fb_modelist *modelist1;
-		struct fb_videomode *mode;
-		struct rk_display_device *ex_display = rk_drm_priv->screen_priv[i].ex_display;
-		memcpy(dev_drv->cur_screen, screen, sizeof(struct rk_screen));
-		if(ex_display == NULL)
-			ex_display = rk_drm_extend_display_get(SCREEN_HDMI);
-		rk_drm_priv->screen_priv[i].ex_display = ex_display;
-		ex_display->ops->getmodelist(ex_display,&modelist);
-		
-		drm_disp->modelist = modelist;
-
-		drm_disp->is_connected = true;
-		drm_disp->event_call_back(drm_disp,0,RK_DRM_CALLBACK_HOTPLUG);
-	}else{
-//	printk("----->yzq %s %d \n",__func__,__LINE__);
-		drm_disp->is_connected = false;
-		drm_disp->event_call_back(drm_disp,0,RK_DRM_CALLBACK_HOTPLUG);
-//	printk("----->yzq %s %d \n",__func__,__LINE__);
-	}
-
-
-}
-static int rk_drm_screen_videomode_set(struct rk_drm_display *drm_disp)
-{
-//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv =
-	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
-	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
-	struct fb_videomode *mode = drm_disp->mode;
-	if(!mode){
-		printk(KERN_ERR"-->%s fb_video mode is NULL",__func__);
-		return -1;
-	}
-
-//	printk("----->yzq %s %d xres=%d yres=%d refresh=%d \n",__func__,__LINE__,mode->xres,mode->yres,mode->refresh);
-	if(lcdc_dev->prop == PRMRY){
-		if(mode != &lcdc_dev->cur_screen->mode)
-			memcpy(&lcdc_dev->cur_screen->mode,mode,sizeof(struct fb_videomode));
-
-	}else{
-		struct rk_display_device *ex_display = drm_screen_priv->ex_display;
-		if(ex_display == NULL)
-			ex_display = rk_drm_extend_display_get(SCREEN_HDMI);
-
-	//	printk("------>yzq ex_display=%x\n",ex_display);
-		if(ex_display == NULL){
-			printk(KERN_ERR"-->%s can not find extend display ops\n",__func__);
-			return -1;
-		}
-		ex_display->ops->setmode(ex_display, mode);
-	}
-	if(!lcdc_dev->atv_layer_cnt)
-		lcdc_dev->ops->open(lcdc_dev, 0,true);
-
-	lcdc_dev->ops->ovl_mgr(lcdc_dev, 3210, 1);
-	lcdc_dev->ops->load_screen(lcdc_dev,1);
-
-	return 0;
-}
-
-static int rk_drm_win_commit(struct rk_drm_display *drm_disp,unsigned int win_id)
-{
-//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv =
-	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
-	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
-
-	unsigned int i=0,j=0;
-	for( i=1; i < RK_DRM_WIN_MASK; i=i<<1){
-		if(i&win_id ){
-			struct rk_lcdc_win *lcdc_win = lcdc_dev->win[j];
-			struct rk_win_data *drm_win= &drm_disp->win[j];
-			if(!lcdc_win && !drm_win){
-				printk(KERN_ERR"---->%s can not find display win%d\n",__func__,j);
-				return -1;
-			}
-			lcdc_win->format = drm_win->format;
-			lcdc_win->area[0].xpos = drm_win->xpos;
-			lcdc_win->area[0].ypos = drm_win->ypos;
-			lcdc_win->area[0].xsize = drm_win->xsize;
-			lcdc_win->area[0].ysize = drm_win->ysize;
-			lcdc_win->area[0].xact = drm_win->xact;
-			lcdc_win->area[0].yact = drm_win->yact;
-			lcdc_win->area[0].xvir = drm_win->xvir;
-			lcdc_win->area[0].y_vir_stride = drm_win->xvir;
-			lcdc_win->area[0].smem_start = drm_win->yrgb_addr;
-			lcdc_win->area[0].cbr_start = drm_win->uv_addr;
-			lcdc_win->alpha_en = 1;
-			if(lcdc_win->state != drm_win->enabled){
-				lcdc_dev->ops->open(lcdc_dev, j,drm_win->enabled?true:false);
-			}
-			lcdc_dev->ops->set_par(lcdc_dev,j);
-			lcdc_dev->ops->pan_display(lcdc_dev,j);
-		}
-		j++;
-	}
-	return 0;
-}
-
-static int rk_drm_display_commit(struct rk_drm_display *drm_disp)
-{
-//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv =
-	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
-	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
-	lcdc_dev->ops->lcdc_reg_update(lcdc_dev);
-	return 0;
-}
-
-int rk_drm_disp_handle(struct rk_drm_display *drm_disp,unsigned int win_id,unsigned int cmd_id)
-{
-//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	struct rk_drm_screen_private *drm_screen_priv =
-	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
-	int i=0;
-	for( i=1; i<RK_DRM_CMD_MASK; i=i<<1){
-		switch(i&cmd_id){
-			case RK_DRM_SCREEN_SET:
-				rk_drm_screen_videomode_set(drm_disp);
-				break;
-			case RK_DRM_SCREEN_BLANK:
-				rk_drm_screen_blank(drm_disp);
-				break;
-			case RK_DRM_WIN_COMMIT:
-				rk_drm_win_commit(drm_disp, win_id);
-				break;
-			case RK_DRM_DISPLAY_COMMIT:
-				if(win_id & i){
-					if (!wait_event_timeout(drm_screen_priv->wait_vsync_queue,
-								!atomic_read(&drm_screen_priv->wait_vsync_done),
-								DRM_HZ/20))
-						printk("wait frame timed out.\n");
-				}
-
-				rk_drm_display_commit(drm_disp);
-				if(win_id & i){
-					atomic_set(&drm_screen_priv->wait_vsync_done,1);
-				}
-		}
-			
-	}
-	return 0;
-}
-
-struct rk_drm_display *rk_drm_get_diplay(int screen_type)
-{
-	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
-	int i=0;
-	for( i=0; i < rk_drm_priv->num_screen; i++){
-		if(rk_drm_priv->screen_priv[i].drm_disp.screen_type == screen_type)
-			return &rk_drm_priv->screen_priv[i].drm_disp;
-	}
-
-	return NULL;
-}
-
-
-static int rk_drm_fb_probe(struct platform_device *pdev)
-{
-	struct rk_drm_private  *rk_drm_priv= NULL;
-	struct device_node *np = pdev->dev.of_node;
-	u32 mode;
-
-	if (!np) {
-		dev_err(&pdev->dev, "Missing device tree node.\n");
-		return -EINVAL;
-	}
-
-	rk_drm_priv= devm_kzalloc(&pdev->dev, sizeof(struct rk_drm_private), GFP_KERNEL);
-	if (!rk_drm_priv) {
-		dev_err(&pdev->dev, "kmalloc for rk_drm_priv fail!");
-		return  -ENOMEM;
-	}
-	platform_set_drvdata(pdev, rk_drm_priv);
-
-	if (!of_property_read_u32(np, "rockchip,disp-mode", &mode)) {
-		rk_drm_priv->disp_mode = mode;
-	} else {
-		dev_err(&pdev->dev, "no disp-mode node found!");
-		return -ENODEV;
-	}
-	dev_set_name(&pdev->dev, "rockchip-drmfb");
-
-	drm_fb_pdev = pdev;
-	dev_info(&pdev->dev, "rockchip drm framebuffer driver probe\n");
-	return 0;
-}
-
-static int rk_drm_fb_remove(struct platform_device *pdev)
-{
-	struct rk_drm_private  *rk_drm_priv = platform_get_drvdata(pdev);
-	kfree(rk_drm_priv);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-static void rk_drm_fb_shutdown(struct platform_device *pdev)
-{
-	return;
-}
-
-
-static const struct of_device_id rk_drm_fb_dt_ids[] = {
-	{ .compatible = "rockchip,rk-fb", },
-	{}
-};
-
-static struct platform_driver rk_drm_fb_driver = {
-	.probe		= rk_drm_fb_probe,
-	.remove		= rk_drm_fb_remove,
-	.driver		= {
-		.name	= "rk-fb",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(rk_drm_fb_dt_ids),
-	},
-	.shutdown   = rk_drm_fb_shutdown,
-};
-
-static int __init rk_drm_fb_init(void)
-{
-	return platform_driver_register(&rk_drm_fb_driver);
-}
-
-static void __exit rk_drm_fb_exit(void)
-{
-	platform_driver_unregister(&rk_drm_fb_driver);
-}
-
-fs_initcall(rk_drm_fb_init);
-module_exit(rk_drm_fb_exit);
diff --git a/drivers/video/rockchip/rk_drm_fb.h b/drivers/video/rockchip/rk_drm_fb.h
deleted file mode 100644
index 4fb45ebcfdb3..000000000000
--- a/drivers/video/rockchip/rk_drm_fb.h
+++ /dev/null
@@ -1,72 +0,0 @@
-#include <linux/rk_fb.h>
-
-#define RK_DRM_WIN_MASK  0x7fff
-#define RK_DRM_CMD_MASK  0x7fff
-
-#define RK_DRM_CALLBACK_VSYNC     0x1
-#define RK_DRM_CALLBACK_HOTPLUG   0x2
-
-#define RK_DRM_SCREEN_SET 	1<<0
-#define	RK_DRM_SCREEN_BLANK 	1<<1
-#define	RK_DRM_WIN_COMMIT     	1<<2
-#define RK_DRM_DISPLAY_COMMIT 	1<<3
-
-enum drm_screen_type {
-	RK_DRM_PRIMARY_SCREEN = 0,
-	RK_DRM_EXTEND_SCREEN,
-	RK_DRM_MAX_SCREEN_NUM,
-};
-struct rk_win_data {
-	unsigned int		win_id;
-	enum data_format 	format;
-	unsigned int		xpos;
-	unsigned int		ypos;
-	unsigned int		xact;
-	unsigned int		yact;
-	unsigned int		xsize;
-	unsigned int		ysize;
-	unsigned int 		xvir;
-
-	dma_addr_t		yrgb_addr;
-	dma_addr_t		uv_addr;
-	
-	bool			enabled;
-};
-
-struct rk_drm_display {
-/***** hardware define *****/ 
-	enum drm_screen_type screen_type;
-
-	struct list_head *modelist;
-	int num_videomode;
-	int best_mode;
-	bool is_connected;
-
-/***** user fill info  *****/
-	struct fb_videomode *mode;
-	bool enable;
-	struct rk_win_data win[RK30_MAX_LAYER_SUPPORT]; 
-	int num_win;
-
-	void (*event_call_back)(struct rk_drm_display *drm_disp,int win_id,int event);
-};
-
-struct rk_drm_screen_private {
-	struct rk_drm_display drm_disp;
-	struct rk_screen screen;
-	atomic_t wait_vsync_done;
-	wait_queue_head_t wait_vsync_queue;
-	struct rk_fb_trsm_ops *trsm_ops;
-	struct rk_lcdc_driver *lcdc_dev_drv;
-
-	struct rk_display_device *ex_display;
-};
-struct rk_drm_private {
-	struct rk_drm_screen_private screen_priv[RK_DRM_MAX_SCREEN_NUM];
-	int num_screen;
-
-	int disp_mode;
-};
-
-extern struct rk_drm_display *rk_drm_get_diplay(int screen_type);
-extern int rk_drm_disp_handle(struct rk_drm_display *drm_disp,unsigned int win_id,unsigned int cmd_id);
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
old mode 100755
new mode 100644
index 3cadc34c24ad..c4739bdde591
--- a/drivers/video/rockchip/rk_fb.c
+++ b/drivers/video/rockchip/rk_fb.c
@@ -48,7 +48,6 @@
 #include <linux/of_gpio.h>
 #include <video/of_display_timing.h>
 #include <video/display_timing.h>
-#include <dt-bindings/rkfb/rk_fb.h>
 #endif
 
 #if defined(CONFIG_ION_ROCKCHIP)
@@ -82,7 +81,7 @@ static int rk_fb_iommu_debug;
 module_param(rk_fb_debug_lvl, int, S_IRUGO | S_IWUSR);
 module_param(rk_fb_iommu_debug, int, S_IRUGO | S_IWUSR);
 
-#define fb_dbg(level, x...) do {		\
+#define rk_fb_dbg(level, x...) do {		\
 	if (unlikely(rk_fb_debug_lvl >= level))	\
 		printk(KERN_INFO x);		\
 	} while (0)
@@ -1197,7 +1196,7 @@ static void win_copy_by_rga(struct rk_lcdc_win *dst_win,
 	Rga_Request.clip.ymin = 0;
 	Rga_Request.clip.ymax = dst_win->area[0].yact - 1;
 	Rga_Request.scale_mode = 0;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 	if (iommu_en) {
 		Rga_Request.mmu_info.mmu_en = 1;
 		Rga_Request.mmu_info.mmu_flag = 1;
@@ -1457,7 +1456,7 @@ static int rk_fb_copy_from_loader(struct fb_info *info)
 	return 0;
 }
 #endif
-#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 static int g_last_addr[5][4];
 static int g_now_config_addr[5][4];
 static int g_last_state[5][4];
@@ -1519,7 +1518,7 @@ void rk_fb_free_dma_buf(struct rk_lcdc_driver *dev_drv,
 	for (i = 0; i < reg_win_data->area_num; i++) {
 		area_data = &reg_win_data->reg_area_data[i];
 		index_buf = area_data->index_buf;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled) {
 			if (area_data->ion_handle != NULL)
 				ion_unmap_iommu(dev_drv->dev, rk_fb->ion_client,
@@ -1649,7 +1648,7 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
 				win->area[i].y_vir_stride =
 				    reg_win_data->reg_area_data[i].y_vir_stride;
 				win->area[i].state = 1;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 				if (dev_drv->iommu_enabled) {
 					g_now_config_addr[win->id][i] =
 						win->area[i].smem_start +
@@ -1659,7 +1658,7 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
 #endif
 			} else {
 				win->area[i].state = 0;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 				if (dev_drv->iommu_enabled) {
 					g_now_config_addr[win->id][i] = 0;
 					g_now_config_state[win->id][i] = 0;
@@ -1828,7 +1827,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 			win->state = 0;
 			for (j = 0; j < 4; j++)
 				win->area[j].state = 0;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 			if (dev_drv->iommu_enabled) {
 				for (j = 0; j < 4; j++) {
 					g_now_config_addr[i][j] = 0;
@@ -1863,7 +1862,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 #endif
 
 	if (dev_drv->front_regs) {
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled) {
 			if (dev_drv->ops->mmu_en)
 				dev_drv->ops->mmu_en(dev_drv);
@@ -1882,7 +1881,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 
 		mutex_unlock(&dev_drv->front_lock);
 
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled)
 			freed_addr[freed_index] = 0xfefefefe;
 #endif
@@ -1955,43 +1954,43 @@ static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
 	struct rk_fb_reg_win_data *reg_win_data;
 	struct rk_fb_reg_area_data *area_data;
 
-	fb_dbg(cmd, "-------------frame start-------------\n");
-	fb_dbg(cmd, "user config:\n");
+	rk_fb_dbg(cmd, "-------------frame start-------------\n");
+	rk_fb_dbg(cmd, "user config:\n");
 	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
 		win_par = &(win_data->win_par[i]);
 		if ((win_par->area_par[0].ion_fd <= 0) &&
 		    (win_par->area_par[0].phy_addr <= 0))
 			continue;
-		fb_dbg(cmd, "win[%d]:z_order=%d,galhpa_v=%d\n",
-		       win_par->win_id, win_par->z_order,
-		       win_par->g_alpha_val);
+		rk_fb_dbg(cmd, "win[%d]:z_order=%d,galhpa_v=%d\n",
+			  win_par->win_id, win_par->z_order,
+			  win_par->g_alpha_val);
 		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
 			area_par = &(win_par->area_par[j]);
 			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
 			    ((win_par->area_par[j].ion_fd <= 0) &&
 			     (win_par->area_par[j].phy_addr <= 0)))
 				continue;
-			fb_dbg(cmd, " area[%d]:fmt=%d,ion_fd=%d,phy_add=0x%x,xoff=%d,yoff=%d\n",
-			       j, area_par->data_format, area_par->ion_fd,
-			       area_par->phy_addr, area_par->x_offset,
-			       area_par->y_offset);
-			fb_dbg(cmd, " 	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
+			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion_fd=%d,phy_add=0x%x,xoff=%d,yoff=%d\n",
+				  j, area_par->data_format, area_par->ion_fd,
+				  area_par->phy_addr, area_par->x_offset,
+				  area_par->y_offset);
+			rk_fb_dbg(cmd, " 	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
 			       area_par->xpos, area_par->ypos,
 			       area_par->xsize, area_par->ysize);
-			fb_dbg(cmd, " 	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
-			       area_par->xact, area_par->yact,
-			       area_par->xvir, area_par->yvir);
+			rk_fb_dbg(cmd, " 	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
+				  area_par->xact, area_par->yact,
+				  area_par->xvir, area_par->yvir);
 		}
 	}
 
-	fb_dbg(cmd, "regs data:\n");
-	fb_dbg(cmd, "win_num=%d,buf_num=%d\n",
+	rk_fb_dbg(cmd, "regs data:\n");
+	rk_fb_dbg(cmd, "win_num=%d,buf_num=%d\n",
 	       regs->win_num, regs->buf_num);
 	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
 		reg_win_data = &(regs->reg_win_data[i]);
 		if (reg_win_data->reg_area_data[0].smem_start <= 0)
 			continue;
-		fb_dbg(cmd, "win[%d]:z_order=%d,area_num=%d,area_buf_num=%d\n",
+		rk_fb_dbg(cmd, "win[%d]:z_order=%d,area_num=%d,area_buf_num=%d\n",
 		       reg_win_data->win_id, reg_win_data->z_order,
 		       reg_win_data->area_num, reg_win_data->area_buf_num);
 		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
@@ -1999,20 +1998,20 @@ static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
 			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
 			    (area_data->smem_start <= 0))
 				continue;
-			fb_dbg(cmd, " area[%d]:fmt=%d,ion=%p,smem_star=0x%lx,cbr_star=0x%lx\n",
+			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion=%p,smem_star=0x%lx,cbr_star=0x%lx\n",
 			       j, area_data->data_format, area_data->ion_handle,
 			       area_data->smem_start, area_data->cbr_start);
-			fb_dbg(cmd, " 	   yoff=0x%x,coff=0x%x,area_data->buff_len=%x\n",
+			rk_fb_dbg(cmd, " 	   yoff=0x%x,coff=0x%x,area_data->buff_len=%x\n",
 			       area_data->y_offset, area_data->c_offset,area_data->buff_len);
-			fb_dbg(cmd, " 	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
+			rk_fb_dbg(cmd, " 	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
 			       area_data->xpos, area_data->ypos,
 			       area_data->xsize, area_data->ysize);
-			fb_dbg(cmd, " 	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
+			rk_fb_dbg(cmd, " 	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
 			       area_data->xact, area_data->yact,
 			       area_data->xvir, area_data->yvir);
 		}
 	}
-	fb_dbg(cmd, "-------------frame end---------------\n");
+	rk_fb_dbg(cmd, "-------------frame end---------------\n");
 
 	return 0;
 }
@@ -2088,7 +2087,7 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 					break;
 				}
 				reg_win_data->reg_area_data[i].ion_handle = hdl;
-#ifndef CONFIG_ROCKCHIP_IOMMU
+#ifndef CONFIG_RK_IOMMU
 				ret = ion_phys(rk_fb->ion_client, hdl, &phy_addr,
 						&len);
 #else
@@ -2429,7 +2428,7 @@ static int rk_fb_set_win_config(struct fb_info *info,
 
 	dev_drv->timeline_max++;
 #ifdef H_USE_FENCE
-	win_data->ret_fence_fd = get_unused_fd();
+	win_data->ret_fence_fd = get_unused_fd_flags(0);
 	if (win_data->ret_fence_fd < 0) {
 		pr_err("ret_fence_fd=%d\n", win_data->ret_fence_fd);
 		win_data->ret_fence_fd = -1;
@@ -2439,7 +2438,7 @@ static int rk_fb_set_win_config(struct fb_info *info,
 	for (i = 0; i < RK_MAX_BUF_NUM; i++) {
 		if (i < regs->buf_num) {
 			sprintf(fence_name, "fence%d", i);
-			win_data->rel_fence_fd[i] = get_unused_fd();
+			win_data->rel_fence_fd[i] = get_unused_fd_flags(0);
 			if (win_data->rel_fence_fd[i] < 0) {
 				printk(KERN_INFO "rel_fence_fd=%d\n",
 				       win_data->rel_fence_fd[i]);
@@ -2577,7 +2576,7 @@ int rk_get_real_fps(int before)
 EXPORT_SYMBOL(rk_get_real_fps);
 
 #endif
-#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 #define ION_MAX 10
 static struct ion_handle *ion_hanle[ION_MAX];
 static struct ion_handle *ion_hwc[1];
@@ -2609,11 +2608,11 @@ static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,
 		u32 hwc_phy[1];
 		if (copy_from_user(hwc_phy, argp, 4))
 			return -EFAULT;
-#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 		if (!dev_drv->iommu_enabled) {
 #endif
 			fix->smem_start = hwc_phy[0];
-#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 		} else {
 			int usr_fd;
 			struct ion_handle *hdl;
@@ -2660,12 +2659,12 @@ static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,
 
 			if (copy_from_user(yuv_phy, argp, 8))
 				return -EFAULT;
-			#ifdef CONFIG_ROCKCHIP_IOMMU
+			#ifdef CONFIG_RK_IOMMU
 			if (!dev_drv->iommu_enabled || !strcmp(info->fix.id, "fb0")) {
 			#endif
 				fix->smem_start = yuv_phy[0];
 				fix->mmio_start = yuv_phy[1];
-			#ifdef CONFIG_ROCKCHIP_IOMMU
+			#ifdef CONFIG_RK_IOMMU
 			} else {
 				int usr_fd, offset, tmp;
 				struct ion_handle *hdl;
@@ -3686,13 +3685,12 @@ static int rk_fb_alloc_buffer_by_ion(struct fb_info *fbi,
 	ion_phys_addr_t phy_addr;
 	size_t len;
 	int ret = 0;
-
 	if (dev_drv->iommu_enabled)
 		handle = ion_alloc(rk_fb->ion_client, (size_t) fb_mem_size, 0,
-				   ION_HEAP(ION_VMALLOC_HEAP_ID), 0);
+				   ION_HEAP_SYSTEM_MASK, 0);
 	else
 		handle = ion_alloc(rk_fb->ion_client, (size_t) fb_mem_size, 0,
-				   ION_HEAP(ION_CMA_HEAP_ID), 0);
+				   ION_HEAP_TYPE_DMA_MASK, 0);
 	if (IS_ERR(handle)) {
 		dev_err(fbi->device, "failed to ion_alloc:%ld\n",
 			PTR_ERR(handle));
@@ -3708,7 +3706,7 @@ static int rk_fb_alloc_buffer_by_ion(struct fb_info *fbi,
 	win->area[0].ion_hdl = handle;
         if (dev_drv->prop == PRMRY)
 	        fbi->screen_base = ion_map_kernel(rk_fb->ion_client, handle);
-#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 	if (dev_drv->iommu_enabled && dev_drv->mmu_dev)
 		ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, handle,
 					(unsigned long *)&phy_addr,
@@ -3795,7 +3793,7 @@ static int rk_fb_alloc_buffer(struct fb_info *fbi)
 						       fb_par->ion_hdl);
 				dev_drv->win[win_id]->area[0].ion_hdl =
 					fb_par->ion_hdl;
-	#ifdef CONFIG_ROCKCHIP_IOMMU
+#ifdef CONFIG_RK_IOMMU
 				if (dev_drv->mmu_dev)
 					ret = ion_map_iommu(dev_drv->dev,
 							    rk_fb->ion_client,
@@ -3806,7 +3804,7 @@ static int rk_fb_alloc_buffer(struct fb_info *fbi)
 					ret = ion_phys(rk_fb->ion_client,
 						       fb_par->ion_hdl,
 						       &phy_addr, &len);
-	#endif
+#endif
 				if (ret < 0) {
 					dev_err(fbi->dev, "ion map to get phy addr failed\n");
 					return -ENOMEM;
@@ -3993,6 +3991,10 @@ bool is_prmry_rk_lcdc_registered(void)
 		return false;
 }
 
+__weak phys_addr_t uboot_logo_base;
+__weak phys_addr_t uboot_logo_size;
+__weak phys_addr_t uboot_logo_offset;
+
 int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 		   struct rk_lcdc_win *win, int id)
 {
@@ -4117,7 +4119,7 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 		struct fb_info *main_fbi = rk_fb->fb[0];
 		main_fbi->fbops->fb_open(main_fbi, 1);
 		main_fbi->var.pixclock = dev_drv->pixclock;
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled) {
 			if (dev_drv->mmu_dev)
 				rockchip_iovmm_set_fault_handler(dev_drv->dev,
@@ -4268,7 +4270,7 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
                 struct fb_info *extend_fbi = rk_fb->fb[rk_fb->num_fb >> 1];
                 extend_fbi->var.pixclock = rk_fb->fb[0]->var.pixclock;
 		extend_fbi->fbops->fb_open(extend_fbi, 1);
-#if defined(CONFIG_ROCKCHIP_IOMMU)
+#if defined(CONFIG_RK_IOMMU)
 		if (dev_drv->iommu_enabled) {
 			if (dev_drv->mmu_dev)
 				rockchip_iovmm_set_fault_handler(dev_drv->dev,
diff --git a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
old mode 100755
new mode 100644
index 88148a8aa4a5..1bf795e08b3d
--- a/drivers/video/rockchip/rkfb_sysfs.c
+++ b/drivers/video/rockchip/rkfb_sysfs.c
@@ -551,10 +551,10 @@ static ssize_t set_dsp_buffer(struct device *dev,
 	mem_size = width * height * 4 * frame_num;
 	if (dev_drv->iommu_enabled)
 		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
-				   ION_HEAP(ION_VMALLOC_HEAP_ID), 0);
+				   ION_HEAP_SYSTEM_MASK, 0);
 	else
 		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
-				   ION_HEAP(ION_CMA_HEAP_ID), 0);
+				   ION_HEAP_TYPE_DMA_MASK, 0);
 	if (IS_ERR(handle)) {
 		pr_err("failed to ion_alloc:%ld\n", PTR_ERR(handle));
 		return -ENOMEM;
diff --git a/drivers/video/rockchip/screen/rk_screen.c b/drivers/video/rockchip/screen/rk_screen.c
old mode 100755
new mode 100644
index 8725d69cc6ba..d88b077d8154
--- a/drivers/video/rockchip/screen/rk_screen.c
+++ b/drivers/video/rockchip/screen/rk_screen.c
@@ -1,4 +1,4 @@
-
+#include <linux/module.h>
 #include <linux/rk_fb.h>
 #include <linux/device.h>
 #include "lcd.h"
diff --git a/drivers/video/rockchip/transmitter/dpcd_edid.h b/drivers/video/rockchip/transmitter/dpcd_edid.h
index 4fdbf6a1d696..5cf883d2f7a5 100644
--- a/drivers/video/rockchip/transmitter/dpcd_edid.h
+++ b/drivers/video/rockchip/transmitter/dpcd_edid.h
@@ -1,6 +1,6 @@
 #ifndef __DPCD_EDID_H
 #define __DPCD_EDID_H
-#include "../../edid.h"
+#include "../../fbdev/edid.h"
 
 #define DPCD_REV					0x00
 #define DPCD_MAX_LINK_RATE				0x01
diff --git a/drivers/video/rockchip/transmitter/rk31xx_lvds.c b/drivers/video/rockchip/transmitter/rk31xx_lvds.c
old mode 100755
new mode 100644
index 4b2d563ae1b5..c81fb7cf28e0
--- a/drivers/video/rockchip/transmitter/rk31xx_lvds.c
+++ b/drivers/video/rockchip/transmitter/rk31xx_lvds.c
@@ -13,6 +13,7 @@
  * GNU General Public License for more details.
  *
  */
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
@@ -60,9 +61,9 @@ static int rk31xx_lvds_clk_init(struct rk_lvds_device *lvds)
 		}
 	} else {
                 lvds->pd = devm_clk_get(lvds->dev, "pd_lvds");
-                if (IS_ERR(lvds->pd)) {
-                        dev_err(lvds->dev, "get pd_lvds failed\n");
-                        return PTR_ERR(lvds->pd);
+		if (IS_ERR(lvds->pd)) {
+			dev_err(lvds->dev, "get pd_lvds failed\n");
+			lvds->pd = NULL;
                 }
         }
 
@@ -76,8 +77,8 @@ static int rk31xx_lvds_clk_enable(struct rk_lvds_device *lvds)
 		clk_prepare_enable(lvds->ctrl_pclk);
 		if (lvds->data->soc_type == LVDS_SOC_RK312X)
 			clk_prepare_enable(lvds->ctrl_hclk);
-	        else
-	                clk_prepare_enable(lvds->pd);
+		if (lvds->pd)
+			clk_prepare_enable(lvds->pd);
 		lvds->clk_on = true;
 	}
 
@@ -90,7 +91,7 @@ static int rk31xx_lvds_clk_disable(struct rk_lvds_device *lvds)
 		clk_disable_unprepare(lvds->pclk);
 		if (lvds->data->soc_type == LVDS_SOC_RK312X)
 			clk_disable_unprepare(lvds->ctrl_hclk);
-		else
+		if (lvds->pd)
 		        clk_disable_unprepare(lvds->pd);
 		clk_disable_unprepare(lvds->ctrl_pclk);
 		lvds->clk_on = false;
diff --git a/include/linux/display-sys.h b/include/linux/display-sys.h
index 72a044ba5c1b..5ce29973c5dd 100755
--- a/include/linux/display-sys.h
+++ b/include/linux/display-sys.h
@@ -4,7 +4,7 @@
 #include <linux/device.h>
 #include <linux/fb.h>
 #include <linux/list.h>
-#include <dt-bindings/rkfb/rk_fb.h>
+#include <dt-bindings/display/rk_fb.h>
 
 struct rk_display_device;
 
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index cc2f1a76e944..0ad5319b80cb 100755
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -23,7 +23,7 @@
 #include <asm/atomic.h>
 #include <linux/rk_screen.h>
 #if defined(CONFIG_OF)
-#include <dt-bindings/rkfb/rk_fb.h>
+#include <dt-bindings/display/rk_fb.h>
 #endif
 #include "../../drivers/staging/android/sw_sync.h"
 #include <linux/file.h>
-- 
2.35.3

