From b9c889d03e6c97b54dbd84eb8835d914842511d4 Mon Sep 17 00:00:00 2001
From: hjc <hjc@rock-chips.com>
Date: Mon, 8 Dec 2014 11:53:47 +0800
Subject: [PATCH] rk fb: update fb config done info.        this commit depend
 on hwc update,        including the following directory:

       hardware/rk29/hwcomposer_rga/
       hardware/rk29/libgralloc_ump/
       hardware/libhardware/
---
 drivers/video/rockchip/lcdc/rk3036_lcdc.c |  50 +++----
 drivers/video/rockchip/lcdc/rk312x_lcdc.c |  52 +++----
 drivers/video/rockchip/lcdc/rk3188_lcdc.c |  68 +++++-----
 drivers/video/rockchip/lcdc/rk3288_lcdc.c | 157 ++++++++++++----------
 drivers/video/rockchip/lcdc/rk3288_lcdc.h |  12 +-
 drivers/video/rockchip/rk_fb.c            | 135 ++++++++++++-------
 drivers/video/rockchip/rkfb_sysfs.c       |   3 +-
 include/dt-bindings/rkfb/rk_fb.h          |   4 +-
 include/linux/rk_fb.h                     | 135 +++++++++++--------
 9 files changed, 354 insertions(+), 262 deletions(-)

diff --git a/drivers/video/rockchip/lcdc/rk3036_lcdc.c b/drivers/video/rockchip/lcdc/rk3036_lcdc.c
index aeb0b353af5b..da1b70bc5efd 100755
--- a/drivers/video/rockchip/lcdc/rk3036_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3036_lcdc.c
@@ -180,8 +180,8 @@ static int rk3036_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
 {
 	int win0_top = 0;
 	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->format;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
 
 	int win0_alpha_en = ((win0_format == ARGB888) ||
 				(win0_format == ABGR888)) ? 1 : 0;
@@ -252,8 +252,8 @@ static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
 		if (win->id == 0) {
 			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP;
 			val = v_WIN0_EN(win->state) |
-			      v_WIN0_FORMAT(win->fmt_cfg) |
-			      v_WIN0_RB_SWAP(win->swap_rb);
+			      v_WIN0_FORMAT(win->area[0].fmt_cfg) |
+			      v_WIN0_RB_SWAP(win->area[0].swap_rb);
 			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
 			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
 				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
@@ -282,8 +282,8 @@ static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
 		} else if (win->id == 1) {
 			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
 			val = v_WIN1_EN(win->state) |
-			      v_WIN1_FORMAT(win->fmt_cfg) |
-			      v_WIN1_RB_SWAP(win->swap_rb);
+			      v_WIN1_FORMAT(win->area[0].fmt_cfg) |
+			      v_WIN1_RB_SWAP(win->area[0].swap_rb);
 			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
 			lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB,
 				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
@@ -823,35 +823,35 @@ static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 	win->scale_yrgb_x = calscale(win->area[0].xact, win->post_cfg.xsize);
 	win->scale_yrgb_y = calscale(win->area[0].yact, win->post_cfg.ysize);
 
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case ARGB888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
 		break;
 	case XBGR888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 1;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
 		break;
 	case ABGR888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 1;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
 		break;
 	case RGB888:
-		win->fmt_cfg = VOP_FORMAT_RGB888;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 0;
 		break;
 	case RGB565:
-		win->fmt_cfg = VOP_FORMAT_RGB565;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 0;
 		break;
 	case YUV444:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR444;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
 			win->scale_cbcr_x = calscale(win->area[0].xact,
 						     win->post_cfg.xsize);
 			win->scale_cbcr_y = calscale(win->area[0].yact,
 						     win->post_cfg.ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n",
@@ -860,12 +860,12 @@ static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 		break;
 	case YUV422:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR422;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
 			win->scale_cbcr_x = calscale((win->area[0].xact / 2),
 						     win->post_cfg.xsize);
 			win->scale_cbcr_y = calscale(win->area[0].yact,
 						     win->post_cfg.ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n",
@@ -874,12 +874,12 @@ static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 		break;
 	case YUV420:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
 			win->scale_cbcr_x = calscale(win->area[0].xact / 2,
 						     win->post_cfg.xsize);
 			win->scale_cbcr_y = calscale(win->area[0].yact / 2,
 						     win->post_cfg.ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n",
@@ -896,7 +896,7 @@ static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 	DBG(2, "lcdc%d>>%s\n"
 		">>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->format, fmt),
+		__func__, get_format_string(win->area[0].format, fmt),
 		win->area[0].xact, win->area[0].yact, win->post_cfg.xsize,
 		win->post_cfg.ysize, win->area[0].xvir, win->area[0].yvir,
 		win->post_cfg.xpos, win->post_cfg.ypos);
@@ -1487,7 +1487,7 @@ static ssize_t rk3036_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
 	}
 
 	size = snprintf(buf, PAGE_SIZE, "win%d: %s\n", win_id,
-			get_format_string(win->format, fmt));
+			get_format_string(win->area[0].format, fmt));
 	size += snprintf(buf + size, PAGE_SIZE - size,
 			 "	xact %d yact %d xvir %d yvir %d\n",
 		win->area[0].xact, win->area[0].yact,
diff --git a/drivers/video/rockchip/lcdc/rk312x_lcdc.c b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
index 258177ba4821..82347910f19a 100755
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
@@ -285,8 +285,8 @@ static int rk312x_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
 {
 	int win0_top = 0;
 	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->format;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
 
 	int win0_alpha_en = ((win0_format == ARGB888) ||
 				(win0_format == ABGR888)) ? 1 : 0;
@@ -367,7 +367,7 @@ static void lcdc_layer_csc_mode(struct lcdc_device *lcdc_dev,
 	struct rk_screen *screen = dev_drv->cur_screen;
 
 	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
-		switch (win->fmt_cfg) {
+		switch (win->area[0].fmt_cfg) {
 		case VOP_FORMAT_ARGB888:
 		case VOP_FORMAT_RGB888:
 		case VOP_FORMAT_RGB565:
@@ -389,7 +389,7 @@ static void lcdc_layer_csc_mode(struct lcdc_device *lcdc_dev,
 				     v_WIN1_CSC_MODE(win->csc_mode));
 		}
 	} else if (dev_drv->overlay_mode == VOP_RGB_DOMAIN) {
-		switch (win->fmt_cfg) {
+		switch (win->area[0].fmt_cfg) {
 		case VOP_FORMAT_YCBCR420:
 			if (win->id  == 0) {
 				win->csc_mode = VOP_Y2R_CSC_MPEG;
@@ -418,8 +418,8 @@ static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
 		if (win->id == 0) {
 			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP;
 			val = v_WIN0_EN(win->state) |
-				v_WIN0_FORMAT(win->fmt_cfg) |
-				v_WIN0_RB_SWAP(win->swap_rb);
+				v_WIN0_FORMAT(win->area[0].fmt_cfg) |
+				v_WIN0_RB_SWAP(win->area[0].swap_rb);
 			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
 			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
 				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
@@ -449,8 +449,8 @@ static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
 		} else if (win->id == 1) {
 			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
 			val = v_WIN1_EN(win->state) |
-					v_WIN1_FORMAT(win->fmt_cfg) |
-					v_WIN1_RB_SWAP(win->swap_rb);
+					v_WIN1_FORMAT(win->area[0].fmt_cfg) |
+					v_WIN1_RB_SWAP(win->area[0].swap_rb);
 			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
 			/* rk312x unsupport win1 scale */
 			if (lcdc_dev->soc_type == VOP_RK3036) {
@@ -1482,35 +1482,35 @@ static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 	win->scale_yrgb_x = CalScale(win->area[0].xact, win->area[0].xsize);
 	win->scale_yrgb_y = CalScale(win->area[0].yact, win->area[0].ysize);
 
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case ARGB888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
 		break;
 	case XBGR888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 1;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
 		break;
 	case ABGR888:
-		win->fmt_cfg = VOP_FORMAT_ARGB888;
-		win->swap_rb = 1;
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
 		break;
 	case RGB888:
-		win->fmt_cfg = VOP_FORMAT_RGB888;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 0;
 		break;
 	case RGB565:
-		win->fmt_cfg = VOP_FORMAT_RGB565;
-		win->swap_rb = 0;
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 0;
 		break;
 	case YUV444:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR444;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
 			win->scale_cbcr_x =
 			    CalScale(win->area[0].xact, win->area[0].xsize);
 			win->scale_cbcr_y =
 			    CalScale(win->area[0].yact, win->area[0].ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n", __func__);
@@ -1518,12 +1518,12 @@ static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 		break;
 	case YUV422:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR422;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
 			win->scale_cbcr_x = CalScale((win->area[0].xact / 2),
 					    win->area[0].xsize);
 			win->scale_cbcr_y =
 			    CalScale(win->area[0].yact, win->area[0].ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n", __func__);
@@ -1531,12 +1531,12 @@ static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 		break;
 	case YUV420:
 		if (win_id == 0) {
-			win->fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
 			win->scale_cbcr_x =
 			    CalScale(win->area[0].xact / 2, win->area[0].xsize);
 			win->scale_cbcr_y =
 			    CalScale(win->area[0].yact / 2, win->area[0].ysize);
-			win->swap_rb = 0;
+			win->area[0].swap_rb = 0;
 		} else {
 			dev_err(lcdc_dev->driver.dev,
 				"%s:un supported format!\n", __func__);
@@ -1552,7 +1552,7 @@ static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
 	DBG(1,
 	    "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 	    ">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id, __func__,
-	    get_format_string(win->format, fmt), win->area[0].xact,
+	    get_format_string(win->area[0].format, fmt), win->area[0].xact,
 	    win->area[0].yact, win->area[0].xsize, win->area[0].ysize,
 	    win->area[0].xvir, win->area[0].yvir, win->area[0].xpos,
 	    win->area[0].ypos);
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.c b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
index ff2dcb638a2c..b1eb96793a4b 100755
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
@@ -173,10 +173,10 @@ static void rk3188_lcdc_read_reg_defalut_cfg(struct lcdc_device
 				lcdc_dev->atv_layer_cnt = win0->state;
 			else
 				lcdc_dev->atv_layer_cnt = win1->state;
-			win0->swap_rb = (value & m_WIN0_RB_SWAP) >> 15;
-			win1->swap_rb = (value & m_WIN1_RB_SWAP) >> 19;
-			win0->fmt_cfg = (value & m_WIN0_FORMAT) >> 3;
-			win1->fmt_cfg = (value & m_WIN1_FORMAT) >> 6;
+			win0->area[0].swap_rb = (value & m_WIN0_RB_SWAP) >> 15;
+			win1->area[0].swap_rb = (value & m_WIN1_RB_SWAP) >> 19;
+			win0->area[0].fmt_cfg = (value & m_WIN0_FORMAT) >> 3;
+			win1->area[0].fmt_cfg = (value & m_WIN1_FORMAT) >> 6;
 			break;
 		case WIN0_SCL_FACTOR_YRGB:
 			win0->scale_yrgb_x = (value >> 0) & 0xffff;
@@ -325,8 +325,8 @@ static int rk3188_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
 {
 	int win0_top = 0;
 	u32 mask, val;
-	enum data_format win0_format = lcdc_dev->driver.win[0]->format;
-	enum data_format win1_format = lcdc_dev->driver.win[1]->format;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
 
 	int win0_alpha_en = ((win0_format == ARGB888)
 			     || (win0_format == ABGR888)) ? 1 : 0;
@@ -376,15 +376,16 @@ static int rk3188_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
 			     m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP |
 			     m_WIN1_RB_SWAP,
 			     v_WIN0_EN(win0->state) | v_WIN1_EN(win1->state) |
-			     v_WIN0_RB_SWAP(win0->swap_rb) |
-			     v_WIN1_RB_SWAP(win1->swap_rb));
+			     v_WIN0_RB_SWAP(win0->area[0].swap_rb) |
+			     v_WIN1_RB_SWAP(win1->area[0].swap_rb));
 		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
 			    v_X_SCL_FACTOR(win0->scale_yrgb_x) |
 			    v_Y_SCL_FACTOR(win0->scale_yrgb_y));
 		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
 			    v_X_SCL_FACTOR(win0->scale_cbcr_x) |
 			    v_Y_SCL_FACTOR(win0->scale_cbcr_y));
-		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_FORMAT, v_WIN0_FORMAT(win0->fmt_cfg));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_FORMAT,
+			     v_WIN0_FORMAT(win0->area[0].fmt_cfg));
 		lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_ACT_WIDTH(win0->area[0].xact) |
 			    v_ACT_HEIGHT(win0->area[0].yact));
 		lcdc_writel(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(win0->area[0].dsp_stx) |
@@ -399,9 +400,10 @@ static int rk3188_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
 			    v_DSP_HEIGHT(win1->area[0].ysize));
 		lcdc_writel(lcdc_dev, WIN1_DSP_ST, v_DSP_STX(win1->area[0].dsp_stx) |
 			    v_DSP_STY(win1->area[0].dsp_sty));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR, ((win1->area[0].y_vir_stride)&0x1fff)<<16);
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
+			     ((win1->area[0].y_vir_stride)&0x1fff)<<16);
 		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_FORMAT,
-			     v_WIN1_FORMAT(win1->fmt_cfg));
+			     v_WIN1_FORMAT(win1->area[0].fmt_cfg));
 		lcdc_writel(lcdc_dev, WIN1_MST, win1->area[0].y_addr);
 		rk3188_lcdc_alpha_cfg(lcdc_dev);
 		lcdc_cfg_done(lcdc_dev);
@@ -758,7 +760,7 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 
 	ScaleYrgbX = CalScale(xact, win->area[0].xsize);
 	ScaleYrgbY = CalScale(yact, win->area[0].ysize);
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case ARGB888:
 	case XBGR888:
 	case ABGR888:
@@ -793,7 +795,7 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 
 	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->format, fmt), xact,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
 		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
 
 	spin_lock(&lcdc_dev->reg_lock);
@@ -802,28 +804,28 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 	win->scale_yrgb_y = ScaleYrgbY;
 	win->scale_cbcr_x = ScaleCbrX;
 	win->scale_cbcr_y = ScaleCbrY;
-	win->fmt_cfg = fmt_cfg;
+	win->area[0].fmt_cfg = fmt_cfg;
 	win->area[0].dsp_stx = xpos;
 	win->area[0].dsp_sty = ypos;
 	
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case XBGR888:
 	case ABGR888:
-		win->swap_rb = 1;
+		win->area[0].swap_rb = 1;
 		break;
 	case ARGB888:
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	case RGB888:
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	case RGB565:
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	case YUV422:
 	case YUV420:
 	case YUV444:
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	default:
 		dev_err(lcdc_dev->driver.dev,
@@ -842,7 +844,8 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 						v_DSP_HEIGHT(win->area[0].ysize));
 		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR, v_WIN0_VIR_VAL(win->area[0].y_vir_stride));
 		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN0_RB_SWAP,
-				v_WIN0_EN(win->state) | v_WIN0_RB_SWAP(win->swap_rb));
+			     v_WIN0_EN(win->state) |
+			     v_WIN0_RB_SWAP(win->area[0].swap_rb));
 		lcdc_msk_reg(lcdc_dev, WIN0_COLOR_KEY, m_COLOR_KEY_EN, v_COLOR_KEY_EN(0));
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
@@ -866,45 +869,48 @@ static int win1_set_par(struct lcdc_device *lcdc_dev,
 
 	DBG(1, "lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->format, fmt), xact, yact,
-		win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
+		__func__, get_format_string(win->area[0].format, fmt),
+		xact, yact, win->area[0].xsize, win->area[0].ysize,
+		xvir, yvir, xpos, ypos);
 
 	spin_lock(&lcdc_dev->reg_lock);
 	win->area[0].dsp_stx = xpos;
 	win->area[0].dsp_sty = ypos;
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case XBGR888:
 	case ABGR888:
 		fmt_cfg = 0;
-		win->swap_rb = 1;
+		win->area[0].swap_rb = 1;
 		break;
 	case ARGB888:
 		fmt_cfg = 0;
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 
 		break;
 	case RGB888:
 		fmt_cfg = 1;
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	case RGB565:
 		fmt_cfg = 2;
-		win->swap_rb = 0;
+		win->area[0].swap_rb = 0;
 		break;
 	default:
 		dev_err(lcdc_dev->driver.dev,
 			"%s:un supported format!\n", __func__);
 		break;
 	}
-	win->fmt_cfg = fmt_cfg;
+	win->area[0].fmt_cfg = fmt_cfg;
 	if (likely(lcdc_dev->clk_on)) {
 		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(win->area[0].xsize) |
 							v_DSP_HEIGHT(win->area[0].ysize));
 		lcdc_writel(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
 		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN | m_WIN1_RB_SWAP,
-				v_WIN1_EN(win->state) | v_WIN1_RB_SWAP(win->swap_rb));
+			     v_WIN1_EN(win->state) |
+			     v_WIN1_RB_SWAP(win->area[0].swap_rb));
 		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_WIN1_FORMAT, v_WIN1_FORMAT(fmt_cfg));
-		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR, ((win->area[0].y_vir_stride)&0x1fff)<<16);	
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
+			     ((win->area[0].y_vir_stride)&0x1fff)<<16);
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 
diff --git a/drivers/video/rockchip/lcdc/rk3288_lcdc.c b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
index a6b405e4294c..d2431abffef1 100755
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
@@ -312,22 +312,23 @@ static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
 				break;
 			case WIN0_CTRL0:
 				win0->state = val & m_WIN0_EN;
-				win0->fmt_cfg = (val & m_WIN0_DATA_FMT) >> 1;
+				win0->area[0].fmt_cfg =
+					(val & m_WIN0_DATA_FMT) >> 1;
 				win0->fmt_10 = (val & m_WIN0_FMT_10) >> 4;
-				win0->format = win0->fmt_cfg;
+				win0->area[0].format = win0->area[0].fmt_cfg;
 				break;
 			case WIN0_VIR:
 				win0->area[0].y_vir_stride =
 					val & m_WIN0_VIR_STRIDE;
 				win0->area[0].uv_vir_stride =
 					(val & m_WIN0_VIR_STRIDE_UV) >> 16;
-				if (win0->format == ARGB888)
+				if (win0->area[0].format == ARGB888)
 					win0->area[0].xvir =
 						win0->area[0].y_vir_stride;
-				else if (win0->format == RGB888)
+				else if (win0->area[0].format == RGB888)
 					win0->area[0].xvir =
 						win0->area[0].y_vir_stride * 4 / 3;
-				else if (win0->format == RGB565)
+				else if (win0->area[0].format == RGB565)
 					win0->area[0].xvir =
 						2 * win0->area[0].y_vir_stride;
 				else /* YUV */
@@ -376,6 +377,7 @@ static int rk3288_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
 
 	/*backup reg config at uboot*/
 	lcdc_read_reg_defalut_cfg(lcdc_dev);
+	v = 0;
 #ifndef CONFIG_RK_FPGA
 	if (lcdc_dev->pwr18 == true) {
 		v = 0x00010001;	/*bit14: 1,1.8v;0,3.3v*/
@@ -580,7 +582,8 @@ static int rk3288_lcdc_alpha_cfg(struct rk_lcdc_driver *dev_drv,int win_id)
 	u32 mask, val;
 	int ppixel_alpha,global_alpha;
 	u32 src_alpha_ctl,dst_alpha_ctl;
-	ppixel_alpha = ((win->format == ARGB888)||(win->format == ABGR888)) ? 1 : 0;
+	ppixel_alpha = ((win->area[0].format == ARGB888) ||
+			(win->area[0].format == ABGR888)) ? 1 : 0;
 	global_alpha = (win->g_alpha_val == 0) ? 0 : 1; 
 	alpha_config.src_global_alpha_val = win->g_alpha_val;
 	win->alpha_mode = AB_SRC_OVER;
@@ -765,10 +768,11 @@ static int rk3288_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
 	if(win->state == 1){
 		mask =  m_WIN0_EN | m_WIN0_DATA_FMT | m_WIN0_FMT_10 |
 			m_WIN0_LB_MODE | m_WIN0_RB_SWAP;
-		val  =  v_WIN0_EN(win->state) | v_WIN0_DATA_FMT(win->fmt_cfg) |
+		val  =  v_WIN0_EN(win->state) |
+			v_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
 			v_WIN0_FMT_10(win->fmt_10) | 
 			v_WIN0_LB_MODE(win->win_lb_mode) | 
-			v_WIN0_RB_SWAP(win->swap_rb);
+			v_WIN0_RB_SWAP(win->area[0].swap_rb);
 		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0+off, mask,val);	
 	
 		mask =	m_WIN0_BIC_COE_SEL |
@@ -850,8 +854,9 @@ static int rk3288_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
 	
 	if(win->state == 1){
 		mask =  m_WIN2_EN | m_WIN2_DATA_FMT | m_WIN2_RB_SWAP;
-		val  =  v_WIN2_EN(1) | v_WIN2_DATA_FMT(win->fmt_cfg) |
-			v_WIN2_RB_SWAP(win->swap_rb);	
+		val  =  v_WIN2_EN(1) |
+			v_WIN2_DATA_FMT(win->area[0].fmt_cfg) |
+			v_WIN2_RB_SWAP(win->area[0].swap_rb);
 		lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
 		/*area 0*/
 		if(win->area[0].state == 1){
@@ -1206,7 +1211,8 @@ static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 	rk3288_lcdc_set_dclk(dev_drv);
-	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+	if (screen->type != SCREEN_HDMI && dev_drv->trsm_ops &&
+	    dev_drv->trsm_ops->enable)
 		dev_drv->trsm_ops->enable();
 	if (screen->init)
 		screen->init();
@@ -1597,8 +1603,7 @@ static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
 	yrgb_srcH = srcH;
 	yrgb_dstW = dstW;
 	yrgb_dstH = dstH;
-	if ((yrgb_dstW >= yrgb_srcW*8) || (yrgb_dstH >= yrgb_srcH*8) ||
-		(yrgb_dstW*8 <= yrgb_srcW) || (yrgb_dstH*8 <= yrgb_srcH)) {
+	if ((yrgb_dstW*8 <= yrgb_srcW) || (yrgb_dstH*8 <= yrgb_srcH)) {
 		pr_err("ERROR: yrgb scale exceed 8,"
 		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
 		       yrgb_srcW,yrgb_srcH,yrgb_dstW,yrgb_dstH);
@@ -1620,7 +1625,7 @@ static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
     	}
 
 	/*cbcr scl mode*/
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case YUV422:
 	case YUV422_A:	
 		cbcr_srcW = srcW/2;
@@ -1654,8 +1659,7 @@ static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
 		break;
 	}		
 	if (yuv_fmt) {
-		if ((cbcr_dstW >= cbcr_srcW*8) || (cbcr_dstH >= cbcr_srcH*8) ||
-			(cbcr_dstW*8 <= cbcr_srcW)||(cbcr_dstH*8 <= cbcr_srcH)) {
+		if ((cbcr_dstW*8 <= cbcr_srcW) || (cbcr_dstH*8 <= cbcr_srcH)) {
 			pr_err("ERROR: cbcr scale exceed 8,"
 		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
 		       cbcr_srcW,cbcr_srcH,cbcr_dstW,cbcr_dstH);
@@ -1686,14 +1690,17 @@ static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
 		win->cbr_hor_scl_mode,win->cbr_ver_scl_mode);
 
     /*line buffer mode*/
-    	if((win->format == YUV422) || (win->format == YUV420) || (win->format == YUV422_A) || (win->format == YUV420_A)){
-        	if(win->cbr_hor_scl_mode == SCALE_DOWN){
+	if ((win->area[0].format == YUV422) ||
+	    (win->area[0].format == YUV420) ||
+	    (win->area[0].format == YUV422_A) ||
+	    (win->area[0].format == YUV420_A)) {
+		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
             		if ((cbcr_dstW > 3840) || (cbcr_dstW == 0)) {
                 		pr_err("ERROR cbcr_dstW = %d\n",cbcr_dstW);                
-            		}else if(cbcr_dstW > 2560){
+			} else if (cbcr_dstW > 2560) {
                 		win->win_lb_mode = LB_RGB_3840X2;
-            		}else if(cbcr_dstW > 1920){
-                		if(win->yrgb_hor_scl_mode == SCALE_DOWN){
+			} else if (cbcr_dstW > 1920) {
+				if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
                     			if(yrgb_dstW > 3840){
                         			pr_err("ERROR yrgb_dst_width exceeds 3840\n");
 		                    	}else if(yrgb_dstW > 2560){
@@ -1703,13 +1710,13 @@ static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
 		                    	}else{
 		                        	pr_err("ERROR never run here!yrgb_dstW<1920 ==> cbcr_dstW>1920\n");
 		                    	}
-		        	}
-            		}else if(cbcr_dstW > 1280){
+				}
+			} else if (cbcr_dstW > 1280) {
                 		win->win_lb_mode = LB_YUV_3840X5;
-            		}else{
+			} else {
                 		win->win_lb_mode = LB_YUV_2560X8;
             		}            
-        	} else { /*SCALE_UP or SCALE_NONE*/
+		} else { /*SCALE_UP or SCALE_NONE*/
             		if ((cbcr_srcW > 3840) || (cbcr_srcW == 0)) {
                 		pr_err("ERROR cbcr_srcW = %d\n",cbcr_srcW);
             		}else if(cbcr_srcW > 2560){                
@@ -1989,7 +1996,7 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 			struct rk_screen *screen, struct rk_lcdc_win *win)
 {
 	u32 xact,yact,xvir, yvir,xpos, ypos;
-	u8 fmt_cfg = 0;
+	u8 fmt_cfg = 0, swap_rb;
 	char fmt[9] = "NULL";
 
 	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
@@ -1998,55 +2005,55 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 	spin_lock(&lcdc_dev->reg_lock);
 	if(likely(lcdc_dev->clk_on)){
 		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
-		switch (win->format){
+		switch (win->area[0].format) {
 		case ARGB888:
 			fmt_cfg = 0;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case XBGR888:
 		case ABGR888:
 			fmt_cfg = 0;
-			win->swap_rb = 1;
+			swap_rb = 1;
 			win->fmt_10 = 0;
 			break;
 		case RGB888:
 			fmt_cfg = 1;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case RGB565:
 			fmt_cfg = 2;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV422:
 			fmt_cfg = 5;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV420:	
 			fmt_cfg = 4;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV444:	
 			fmt_cfg = 6;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 		case YUV422_A:
 			fmt_cfg = 5;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;
 		case YUV420_A:	
 			fmt_cfg = 4;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;
 		case YUV444_A:	
 			fmt_cfg = 6;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;
 		default:
@@ -2054,7 +2061,8 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 				__func__);
 			break;
 		}
-		win->fmt_cfg = fmt_cfg;
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
 		win->area[0].dsp_stx = xpos;
 		win->area[0].dsp_sty = ypos;
 		xact = win->area[0].xact;
@@ -2067,7 +2075,7 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 
 	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->format, fmt), xact,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
 		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
 	return 0;
 
@@ -2076,66 +2084,66 @@ static int win0_set_par(struct lcdc_device *lcdc_dev,
 static int win1_set_par(struct lcdc_device *lcdc_dev,
 			struct rk_screen *screen, struct rk_lcdc_win *win)
 {
-	u32 xact,yact,xvir, yvir,xpos, ypos;
-	u8 fmt_cfg = 0;
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u8 fmt_cfg = 0, swap_rb;
 	char fmt[9] = "NULL";
 
 	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
 	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on)){
+	if (likely(lcdc_dev->clk_on)) {
 		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
-		switch (win->format){
+		switch (win->area[0].format) {
 		case ARGB888:
 			fmt_cfg = 0;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case XBGR888:
 		case ABGR888:
 			fmt_cfg = 0;
-			win->swap_rb = 1;
+			swap_rb = 1;
 			win->fmt_10 = 0;
 			break;
 		case RGB888:
 			fmt_cfg = 1;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case RGB565:
 			fmt_cfg = 2;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV422:
 			fmt_cfg = 5;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV420:
 			fmt_cfg = 4;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV444:
 			fmt_cfg = 6;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 0;
 			break;
 		case YUV422_A:
 			fmt_cfg = 5;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;
 		case YUV420_A:	
 			fmt_cfg = 4;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;
 		case YUV444_A:	
 			fmt_cfg = 6;
-			win->swap_rb = 0;
+			swap_rb = 0;
 			win->fmt_10 = 1;
 			break;			
 		default:
@@ -2143,7 +2151,8 @@ static int win1_set_par(struct lcdc_device *lcdc_dev,
 				__func__);
 			break;
 		}
-		win->fmt_cfg = fmt_cfg;
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
 		win->area[0].dsp_stx = xpos;
 		win->area[0].dsp_sty = ypos;
 		xact = win->area[0].xact;
@@ -2156,7 +2165,7 @@ static int win1_set_par(struct lcdc_device *lcdc_dev,
 
 	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
 		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
-		__func__, get_format_string(win->format, fmt), xact,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
 		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
 	return 0;
 
@@ -2166,28 +2175,28 @@ static int win2_set_par(struct lcdc_device *lcdc_dev,
 			struct rk_screen *screen, struct rk_lcdc_win *win)
 {
 	int i;
-	u8 fmt_cfg;
+	u8 fmt_cfg, swap_rb;
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on)){
-		for(i=0;i<win->area_num;i++){
-			switch (win->format){
+	if (likely(lcdc_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
 			case ARGB888:
 				fmt_cfg = 0;
-				win->swap_rb = 0;
+				swap_rb = 0;
 				break;
 			case XBGR888:
 			case ABGR888:
 				fmt_cfg = 0;
-				win->swap_rb = 1;
+				swap_rb = 1;
 				break;
 			case RGB888:
 				fmt_cfg = 1;
-				win->swap_rb = 0;
+				swap_rb = 0;
 				break;
 			case RGB565:
 				fmt_cfg = 2;
-				win->swap_rb = 0;		
+				swap_rb = 0;
 				break;
 			default:
 				dev_err(lcdc_dev->driver.dev, 
@@ -2195,7 +2204,8 @@ static int win2_set_par(struct lcdc_device *lcdc_dev,
 					__func__);
 				break;
 			}			
-			win->fmt_cfg = fmt_cfg;
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
 			win->area[i].dsp_stx = win->area[i].xpos + 
 				screen->mode.left_margin +
 				screen->mode.hsync_len;
@@ -2222,28 +2232,28 @@ static int win3_set_par(struct lcdc_device *lcdc_dev,
 
 {
 	int i;
-	u8 fmt_cfg;
+	u8 fmt_cfg, swap_rb;
 
 	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on)){
-		for(i=0;i<win->area_num;i++){
-			switch (win->format){
+	if (likely(lcdc_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
 			case ARGB888:
 				fmt_cfg = 0;
-				win->swap_rb = 0;
+				swap_rb = 0;
 				break;
 			case XBGR888:
 			case ABGR888:
 				fmt_cfg = 0;
-				win->swap_rb = 1;
+				swap_rb = 1;
 				break;
 			case RGB888:
 				fmt_cfg = 1;
-				win->swap_rb = 0;
+				swap_rb = 0;
 				break;
 			case RGB565:
 				fmt_cfg = 2;
-				win->swap_rb = 0;		
+				swap_rb = 0;
 				break;
 			default:
 				dev_err(lcdc_dev->driver.dev, 
@@ -2251,7 +2261,8 @@ static int win3_set_par(struct lcdc_device *lcdc_dev,
 					__func__);
 				break;
 			}			
-			win->fmt_cfg = fmt_cfg;
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
 			win->area[i].dsp_stx = win->area[i].xpos + 
 				screen->mode.left_margin +
 				screen->mode.hsync_len;
diff --git a/drivers/video/rockchip/lcdc/rk3288_lcdc.h b/drivers/video/rockchip/lcdc/rk3288_lcdc.h
index bda23eec97f9..29372aef5b97 100755
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.h
+++ b/drivers/video/rockchip/lcdc/rk3288_lcdc.h
@@ -891,10 +891,10 @@
 
 #define HWC_MST 			(0x0158)
 #define HWC_DSP_ST 			(0x015c)
-#define v_HWC_DSP_XST3(x)		(((x)&0x1fff)<<0)
-#define v_HWC_DSP_YST3(x)		(((x)&0x1fff)<<16)
-#define m_HWC_DSP_XST3			(0x1fff<<0)
-#define m_HWC_DSP_YST3			(0x1fff<<16)
+#define v_HWC_DSP_XST(x)		(((x)&0x1fff)<<0)
+#define v_HWC_DSP_YST(x)		(((x)&0x1fff)<<16)
+#define m_HWC_DSP_XST			(0x1fff<<0)
+#define m_HWC_DSP_YST			(0x1fff<<16)
 
 #define HWC_SRC_ALPHA_CTRL		(0x0160)
 #define v_HWC_SRC_ALPHA_EN(x)		(((x)&1)<<0)
@@ -1350,8 +1350,8 @@ struct alpha_config{
 
 struct lcdc_cabc_mode {
 	u32 pixel_num;			/* pixel precent number */
-	char stage_up;			/* up stride */
-	char stage_down;		/* down stride */
+	u16 stage_up;			/* up stride */
+	u16 stage_down;		/* down stride */
 };
 
 static inline void lcdc_writel(struct lcdc_device *lcdc_dev,u32 offset,u32 v)
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
index 530f2089ac98..78b4b8695675 100755
--- a/drivers/video/rockchip/rk_fb.c
+++ b/drivers/video/rockchip/rk_fb.c
@@ -830,6 +830,10 @@ static int get_extend_fb_id(struct fb_info *info)
 		fb_id = 2;
 	else if (!strcmp(id, "fb3") && (dev_drv->lcdc_win_num > 3))
 		fb_id = 3;
+	else if (!strcmp(id, "fb4") && (dev_drv->lcdc_win_num > 4))
+		fb_id = 4;
+	else
+		dev_err(dev_drv->dev, "get_extend_fb_id info error\n");
 	return fb_id;
 }
 
@@ -1042,7 +1046,7 @@ static void rga_win_check(struct rk_lcdc_win *dst_win,
 {
 	int format = 0;
 
-	format = get_rga_format(src_win->format);
+	format = get_rga_format(src_win->area[0].format);
 	/* width and height must be even number */
 	if (format >= RK_FORMAT_YCbCr_422_SP &&
 	    format <= RK_FORMAT_YCrCb_420_P) {
@@ -1056,7 +1060,7 @@ static void rga_win_check(struct rk_lcdc_win *dst_win,
 	if (src_win->area[0].yvir < src_win->area[0].yact)
 		src_win->area[0].yvir = src_win->area[0].yact;
 
-	format = get_rga_format(dst_win->format);
+	format = get_rga_format(dst_win->area[0].format);
 	if (format >= RK_FORMAT_YCbCr_422_SP &&
 	    format <= RK_FORMAT_YCrCb_420_P) {
 		if ((dst_win->area[0].xact % 2) != 0)
@@ -1136,7 +1140,7 @@ static void win_copy_by_rga(struct rk_lcdc_win *dst_win,
 
 	Rga_Request.src.vir_w = src_win->area[0].xvir;
 	Rga_Request.src.vir_h = src_win->area[0].yvir;
-	Rga_Request.src.format = get_rga_format(src_win->format);
+	Rga_Request.src.format = get_rga_format(src_win->area[0].format);
 	Rga_Request.src.act_w = src_win->area[0].xact;
 	Rga_Request.src.act_h = src_win->area[0].yact;
 	Rga_Request.src.x_offset = 0;
@@ -1144,7 +1148,7 @@ static void win_copy_by_rga(struct rk_lcdc_win *dst_win,
 
 	Rga_Request.dst.vir_w = dst_win->area[0].xvir;
 	Rga_Request.dst.vir_h = dst_win->area[0].yvir;
-	Rga_Request.dst.format = get_rga_format(dst_win->format);
+	Rga_Request.dst.format = get_rga_format(dst_win->area[0].format);
 
 	Rga_Request.clip.xmin = 0;
 	Rga_Request.clip.xmax = dst_win->area[0].xact - 1;
@@ -1209,9 +1213,9 @@ static int rk_fb_rotate(struct fb_info *dst_info,
 	return 0;
 }
 
-static int rk_fb_win_rotate(struct rk_lcdc_win *dst_win,
-			    struct rk_lcdc_win *src_win,
-			    u16 rotate, int iommu_en)
+static int __maybe_unused rk_fb_win_rotate(struct rk_lcdc_win *dst_win,
+					    struct rk_lcdc_win *src_win,
+					    u16 rotate, int iommu_en)
 {
 #if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
 	win_copy_by_rga(dst_win, src_win, rotate, iommu_en);
@@ -1242,7 +1246,7 @@ static int rk_fb_set_ext_win_buffer(struct rk_lcdc_win *ext_win,
 	if (rk_fb->disp_mode != DUAL || ext_info == NULL)
 		return 0;
 
-	switch (ext_win->format) {
+	switch (ext_win->area[0].format) {
         case YUV422:
         case YUV420:
         case YUV444:
@@ -1376,13 +1380,13 @@ static int rk_fb_pan_display(struct fb_var_screeninfo *var,
 		extend_win = extend_dev_drv->win[extend_win_id];
 	}
 
-	pixel_width = rk_fb_pixel_width(win->format);
+	pixel_width = rk_fb_pixel_width(win->area[0].format);
 	vir_width_bit = pixel_width * xvir;
 	/* pixel_width = byte_num * 8 */
 	stride_32bit_1 = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
 	stride_32bit_2 = ALIGN_N_TIMES(vir_width_bit * 2, 32) / 8;
 
-	switch (win->format) {
+	switch (win->area[0].format) {
 	case YUV422:
 	case YUV422_A:
 		is_pic_yuv = 1;
@@ -1490,6 +1494,9 @@ static int rk_fb_pan_display(struct fb_var_screeninfo *var,
 		video_data_to_mirroring(info, NULL);
 #endif
 	dev_drv->ops->cfg_done(dev_drv);
+	/*msleep(1000);
+	dev_drv->ops->dump_reg(dev_drv);
+	while(1);*/
 	return 0;
 }
 
@@ -1662,15 +1669,19 @@ static int rk_fb_update_ext_win(struct rk_lcdc_driver *ext_dev_drv,
 	}
 
 	ext_win->area[0].state = win->area[0].state;
+	ext_win->area[0].format = win->area[0].format;
 	ext_win->area_num = win->area_num;
-	ext_win->format = win->format;
 	ext_win->fmt_10 = win->fmt_10;
 	ext_win->z_order = win->z_order;
 	ext_win->alpha_en = win->alpha_en;
 	ext_win->alpha_mode = win->alpha_mode;
 	ext_win->g_alpha_val = win->g_alpha_val;
+	ext_win->mirror_en = win->mirror_en;
+	ext_win->area[0].fbdc_en = win->area[0].fbdc_en;
+	ext_win->area[0].fbdc_cor_en = win->area[0].fbdc_cor_en;
+	ext_win->area[0].fbdc_data_format = win->area[0].fbdc_data_format;
 
-	switch (ext_win->format) {
+	switch (ext_win->area[0].format) {
 	case YUV422:
 	case YUV420:
 	case YUV444:
@@ -1690,7 +1701,7 @@ static int rk_fb_update_ext_win(struct rk_lcdc_driver *ext_dev_drv,
 		ext_win->area[0].xvir = win->area[0].yact;
 		ext_win->area[0].yvir = win->area[0].xact;
 
-		pixel_width = rk_fb_pixel_width(ext_win->format);
+		pixel_width = rk_fb_pixel_width(ext_win->area[0].format);
 		vir_width_bit = pixel_width * ext_win->area[0].xvir;
 		y_stride = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
 		ext_win->area[0].y_vir_stride = y_stride >> 2;
@@ -1786,14 +1797,12 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
         rk_fb_get_prmry_screen(&primary_screen);
 
 	win->area_num = reg_win_data->area_num;
-	win->format = reg_win_data->data_format;
 	win->id = reg_win_data->win_id;
 	win->z_order = reg_win_data->z_order;
 
 	if (reg_win_data->reg_area_data[0].smem_start > 0) {
 		win->state = 1;
 		win->area_num = reg_win_data->area_num;
-		win->format = reg_win_data->data_format;
 		win->id = reg_win_data->win_id;
 		win->z_order = reg_win_data->z_order;
 		win->area[0].uv_vir_stride =
@@ -1804,8 +1813,17 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
 		win->alpha_en = reg_win_data->alpha_en;
 		win->alpha_mode = reg_win_data->alpha_mode;
 		win->g_alpha_val = reg_win_data->g_alpha_val;
+		win->mirror_en = reg_win_data->mirror_en;
+		win->area[0].fbdc_en =
+			reg_win_data->reg_area_data[0].fbdc_en;
+		win->area[0].fbdc_cor_en =
+			reg_win_data->reg_area_data[0].fbdc_cor_en;
+		win->area[0].fbdc_data_format =
+			reg_win_data->reg_area_data[0].fbdc_data_format;
 		for (i = 0; i < RK_WIN_MAX_AREA; i++) {
 			if (reg_win_data->reg_area_data[i].smem_start > 0) {
+				win->area[i].format =
+					reg_win_data->reg_area_data[i].data_format;
 				if (inf->disp_policy != DISPLAY_POLICY_BOX)
 					win->area[i].ion_hdl =
 					reg_win_data->reg_area_data[i].ion_handle;
@@ -1866,6 +1884,10 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
 				    reg_win_data->reg_area_data[i].xvir;
 				win->area[i].yvir =
 				    reg_win_data->reg_area_data[i].yvir;
+				win->area[i].xoff =
+				    reg_win_data->reg_area_data[i].xoff;
+				win->area[i].yoff =
+				    reg_win_data->reg_area_data[i].yoff;
 				win->area[i].y_offset =
 				    reg_win_data->reg_area_data[i].y_offset;
 				win->area[i].y_vir_stride =
@@ -1905,8 +1927,10 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 	struct rk_lcdc_win *win;
 	ktime_t timestamp = dev_drv->vsync_info.timestamp;
 	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+#if defined(CONFIG_RK_HDMI)
 	struct rk_lcdc_driver *ext_dev_drv;
 	struct rk_lcdc_win *ext_win;
+#endif
 	struct rk_fb_reg_win_data *win_data;
 	bool wait_for_vsync;
 	int count = 100;
@@ -1929,8 +1953,8 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 		win_data = rk_fb_get_win_data(regs, i);
 		if (win_data) {
 			if (rk_fb->disp_policy == DISPLAY_POLICY_BOX &&
-			    (win_data->data_format == YUV420 ||
-			     win_data->data_format == YUV420_A))
+			    (win_data->reg_area_data[0].data_format == YUV420 ||
+			     win_data->reg_area_data[0].data_format == YUV420_A))
 				continue;
 			mutex_lock(&dev_drv->win_config);
 			rk_fb_update_win(dev_drv, win, win_data);
@@ -1952,6 +1976,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 	dev_drv->ops->ovl_mgr(dev_drv, 0, 1);
 	if (rk_fb->disp_policy == DISPLAY_POLICY_BOX)
 		dev_drv->ops->cfg_done(dev_drv);
+#if defined(CONFIG_RK_HDMI)
 	if ((rk_fb->disp_mode == DUAL)
 	    && (hdmi_get_hotplug() == HDMI_HPD_ACTIVED)
 	    && hdmi_switch_complete) {
@@ -1990,6 +2015,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 		ext_dev_drv->ops->cfg_done(ext_dev_drv);
 	}
 ext_win_exit:
+#endif
 	dev_drv->ops->cfg_done(dev_drv);
 
 	do {
@@ -1997,6 +2023,7 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 		timeout = wait_event_interruptible_timeout(dev_drv->vsync_info.wait,
 				ktime_compare(dev_drv->vsync_info.timestamp, timestamp) > 0,
 				msecs_to_jiffies(25));
+#if defined(CONFIG_RK_HDMI)
 		if ((rk_fb->disp_mode == DUAL) &&
 		    (hdmi_get_hotplug() == HDMI_HPD_ACTIVED) &&
 		    hdmi_switch_complete) {
@@ -2009,14 +2036,14 @@ static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
 					ktime_compare(ext_dev_drv->vsync_info.timestamp, timestamp) > 0,
 					msecs_to_jiffies(25));
 		}
-
+#endif
 		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
 		wait_for_vsync = false;
 		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
 			if (dev_drv->win[i]->state == 1) {
 				if (rk_fb->disp_policy == DISPLAY_POLICY_BOX &&
-				    (dev_drv->win[i]->format == YUV420 ||
-				     dev_drv->win[i]->format == YUV420_A ||
+				    (dev_drv->win[i]->area[0].format == YUV420 ||
+				     dev_drv->win[i]->area[0].format == YUV420_A ||
 				     !strcmp(dev_drv->win[i]->name, "hwc"))) {
 					continue;
 				} else {
@@ -2133,7 +2160,7 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
 	struct rk_screen *screen = dev_drv->cur_screen;
         struct rk_screen primary_screen;
-	struct fb_info *fbi = rk_fb->fb[0];
+	struct fb_info *fbi;
 	int i, ion_fd, acq_fence_fd;
 	u32 xvir, yvir;
 	u32 xoffset, yoffset;
@@ -2164,9 +2191,8 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 				    ion_import_dma_buf(rk_fb->ion_client,
 						       ion_fd);
 				if (IS_ERR(hdl)) {
-					pr_info
-					    ("%s: Could not import handle: %d\n",
-					     __func__, (int)hdl);
+					pr_info("%s: Could not import handle:"
+						" %ld\n", __func__, (long)hdl);
 					/*return -EINVAL; */
 					break;
 				}
@@ -2216,16 +2242,6 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 			    sync_fence_fdget(win_par->area_par[i].acq_fence_fd);
 		}
 	}
-	fb_data_fmt = rk_fb_data_fmt(win_par->data_format, 0);
-	reg_win_data->data_format = fb_data_fmt;
-	pixel_width = rk_fb_pixel_width(fb_data_fmt);
-
-	ppixel_a = ((fb_data_fmt == ARGB888) ||
-		    (fb_data_fmt == ABGR888)) ? 1 : 0;
-	global_a = (win_par->g_alpha_val == 0) ? 0 : 1;
-	reg_win_data->alpha_en = ppixel_a | global_a;
-	reg_win_data->g_alpha_val = win_par->g_alpha_val;
-	reg_win_data->alpha_mode = win_par->alpha_mode;
 	if (reg_win_data->reg_area_data[0].smem_start > 0) {
 		reg_win_data->z_order = win_par->z_order;
 		reg_win_data->win_id = win_par->win_id;
@@ -2235,11 +2251,24 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 	}
 
 	rk_fb_get_prmry_screen(&primary_screen);
+	reg_win_data->mirror_en = win_par->mirror_en;
+	reg_win_data->reg_area_data[0].fbdc_en = win_par->area_par[0].fbdc_en;
+	reg_win_data->reg_area_data[0].fbdc_cor_en =
+		win_par->area_par[0].fbdc_cor_en;
+	reg_win_data->reg_area_data[0].fbdc_data_format =
+		win_par->area_par[0].fbdc_data_format;
 	for (i = 0; i < reg_win_data->area_num; i++) {
 		if (rk_fb->disp_policy == DISPLAY_POLICY_BOX)
 			rk_fb_check_config_var(&win_par->area_par[i], screen);
 		else
 			rk_fb_check_config_var(&win_par->area_par[i], &primary_screen);
+
+		fb_data_fmt = rk_fb_data_fmt(win_par->area_par[i].data_format, 0);
+		reg_win_data->reg_area_data[i].data_format = fb_data_fmt;
+		pixel_width = rk_fb_pixel_width(fb_data_fmt);
+
+		ppixel_a |= ((fb_data_fmt == ARGB888) ||
+			     (fb_data_fmt == ABGR888)) ? 1 : 0;
 		/* visiable pos in panel */
 		reg_win_data->reg_area_data[i].xpos = win_par->area_par[i].xpos;
 		reg_win_data->reg_area_data[i].ypos = win_par->area_par[i].ypos;
@@ -2254,6 +2283,9 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 
 		xoffset = win_par->area_par[i].x_offset;	/* buf offset */
 		yoffset = win_par->area_par[i].y_offset;
+		reg_win_data->reg_area_data[i].xoff = xoffset;
+		reg_win_data->reg_area_data[i].yoff = yoffset;
+
 		xvir = win_par->area_par[i].xvir;
 		reg_win_data->reg_area_data[i].xvir = xvir;
 		yvir = win_par->area_par[i].yvir;
@@ -2272,7 +2304,7 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 		 * reg_win_data->reg_area_data[i].y_offset =
 		 *		yoffset*stride+xoffset*pixel_width/8;
 		 */
-		if (screen->y_mirror == 1) {
+		if ((screen->y_mirror == 1) || (reg_win_data->mirror_en)) {
 			if (screen->interlace == 1) {
 				reg_win_data->reg_area_data[i].y_offset =
 				    yoffset * stride * 2 +
@@ -2296,6 +2328,12 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 			}
 		}
 	}
+
+	global_a = (win_par->g_alpha_val == 0) ? 0 : 1;
+	reg_win_data->alpha_en = ppixel_a | global_a;
+	reg_win_data->g_alpha_val = win_par->g_alpha_val;
+	reg_win_data->alpha_mode = win_par->alpha_mode;
+
 	switch (fb_data_fmt) {
 	case YUV422:
 	case YUV422_A:
@@ -2334,7 +2372,7 @@ static int rk_fb_set_win_buffer(struct fb_info *info,
 		reg_win_data->reg_area_data[0].cbr_start =
 		    reg_win_data->reg_area_data[0].smem_start + xvir * yvir;
 		reg_win_data->reg_area_data[0].uv_vir_stride = uv_stride >> 2;
-		if (screen->y_mirror == 1) {
+		if ((screen->y_mirror == 1) || (reg_win_data->mirror_en)) {
 			if (screen->interlace == 1) {
 				reg_win_data->reg_area_data[0].c_offset =
 				    uv_y_off * uv_stride * 2 +
@@ -2919,9 +2957,9 @@ static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
 		win = dev_drv->win[win_id];
 
 	/* only read the current frame buffer */
-	if (win->format == RGB565) {
+	if (win->area[0].format == RGB565) {
 		total_size = win->area[0].y_vir_stride * win->area[0].yact << 1;
-	} else if (win->format == YUV420) {
+	} else if (win->area[0].format == YUV420) {
 		total_size =
 		    (win->area[0].y_vir_stride * win->area[0].yact * 6);
 	} else {
@@ -2984,7 +3022,7 @@ static ssize_t rk_fb_write(struct fb_info *info, const char __user *buf,
 		win = dev_drv->win[win_id];
 
 	/* write the current frame buffer */
-	if (win->format == RGB565)
+	if (win->area[0].format == RGB565)
 		total_size = win->area[0].xact * win->area[0].yact << 1;
 	else
 		total_size = win->area[0].xact * win->area[0].yact << 2;
@@ -3258,7 +3296,7 @@ static int rk_fb_set_par(struct fb_info *info)
 		}
 	}
 
-	win->format = fb_data_fmt;
+	win->area[0].format = fb_data_fmt;
 	win->area[0].y_vir_stride = stride >> 2;
 	win->area[0].uv_vir_stride = uv_stride >> 2;
 	win->area[0].xpos = xpos;
@@ -3269,15 +3307,17 @@ static int rk_fb_set_par(struct fb_info *info)
 	win->area[0].yact = var->yres;
 	win->area[0].xvir = var->xres_virtual;	/* virtual resolution  stride --->LCDC_WINx_VIR */
 	win->area[0].yvir = var->yres_virtual;
+	win->area[0].xoff = xoffset;
+	win->area[0].yoff = yoffset;
 
 	win->area_num = 1;
 	win->alpha_mode = 4;	/* AB_SRC_OVER; */
-	win->alpha_en = ((win->format == ARGB888) ||
-			 (win->format == ABGR888)) ? 1 : 0;
+	win->alpha_en = ((win->area[0].format == ARGB888) ||
+			 (win->area[0].format == ABGR888)) ? 1 : 0;
 	win->g_alpha_val = 0;
 
 	if (rk_fb->disp_policy == DISPLAY_POLICY_BOX &&
-	    (win->format == YUV420 || win->format == YUV420_A))
+	    (win->area[0].format == YUV420 || win->area[0].format == YUV420_A))
 	    win->state = 1;
 	if (rk_fb->disp_mode == DUAL) {
 		if (extend_win->state && hdmi_switch_complete) {
@@ -3527,6 +3567,9 @@ int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id)
 			dev_drv->ops->dsp_black(dev_drv, 1);
 		if (dev_drv->ops->set_screen_scaler)
 			dev_drv->ops->set_screen_scaler(dev_drv, dev_drv->screen0, 0);
+	} else if ((rk_fb->disp_mode == NO_DUAL) && (enable)) {
+		if (dev_drv->ops->dsp_black)
+			dev_drv->ops->dsp_black(dev_drv, 1);
 	}
 
 	if (!enable) {
@@ -3535,7 +3578,8 @@ int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id)
 			return 0;
 
 		/* if used one lcdc to dual disp, no need to close win */
-		if (rk_fb->disp_mode == ONE_DUAL) {
+		if ((rk_fb->disp_mode == ONE_DUAL) ||
+		    (rk_fb->disp_mode == NO_DUAL)) {
 			dev_drv->cur_screen = dev_drv->screen0;
 			dev_drv->ops->load_screen(dev_drv, 1);
 
@@ -3597,7 +3641,8 @@ int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id)
 					info->var.activate |= FB_ACTIVATE_FORCE;
 					if (rk_fb->disp_mode == DUAL) {
 						rk_fb_update_ext_info(info, pmy_info, 1);
-					} else if (rk_fb->disp_mode == ONE_DUAL) {
+					} else if ((rk_fb->disp_mode == ONE_DUAL) ||
+						   (rk_fb->disp_mode == NO_DUAL)) {
 						info->var.grayscale &= 0xff;
 						info->var.grayscale |=
 							(dev_drv->cur_screen->xsize << 8) +
diff --git a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
index 07d8ab6d6b53..cf9f8c9b7a1f 100755
--- a/drivers/video/rockchip/rkfb_sysfs.c
+++ b/drivers/video/rockchip/rkfb_sysfs.c
@@ -233,7 +233,8 @@ static ssize_t set_dump_info(struct device *dev, struct device_attribute *attr,
 		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
 			win_data = &front_regs->reg_win_data[i];
 			if (dump_win(rk_fb, &win_data->reg_area_data[j],
-				     win_data->data_format, i, j, is_img))
+				     win_data->reg_area_data[i].data_format,i,
+				     j, is_img))
 				continue;
 		}
 	}
diff --git a/include/dt-bindings/rkfb/rk_fb.h b/include/dt-bindings/rkfb/rk_fb.h
index 65190b00f8e5..36268e43b5ae 100755
--- a/include/dt-bindings/rkfb/rk_fb.h
+++ b/include/dt-bindings/rkfb/rk_fb.h
@@ -17,6 +17,7 @@
 #define OUT_CCIR656         6
 #define OUT_S888            8
 #define OUT_S888DUMY        12
+#define OUT_YUV_420	    14
 #define OUT_P16BPP4         24
 #define OUT_D888_P666       0x21	//18bit screen,connect to lcdc D2~D7, D10~D15, D18~D23
 #define OUT_D888_P565       0x22
@@ -57,7 +58,8 @@
 #define FB0_WIN0_FB1_WIN2_FB2_WIN1	120
 #define FB0_WIN0_FB1_WIN1_FB2_WIN2	210
 #define FB0_WIN1_FB1_WIN0_FB2_WIN2	201
-#define FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3	3210
+#define FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3	    3210
+#define FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC 43210
 
 #define DISPLAY_POLICY_SDK	0
 #define DISPLAY_POLICY_BOX	1
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index e9b7fedd2bcf..e6331e8b234e 100755
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -30,11 +30,11 @@
 #include <linux/kthread.h>
 
 
-#define RK30_MAX_LCDC_SUPPORT	4
-#define RK30_MAX_LAYER_SUPPORT	4
-#define RK_MAX_FB_SUPPORT       4
+#define RK30_MAX_LCDC_SUPPORT	2
+#define RK30_MAX_LAYER_SUPPORT	5
+#define RK_MAX_FB_SUPPORT       5
 #define RK_WIN_MAX_AREA		4
-#define RK_MAX_BUF_NUM       	10
+#define RK_MAX_BUF_NUM		11
 
 #define FB0_IOCTL_STOP_TIMER_FLUSH		0x6001
 #define FB0_IOCTL_SET_PANEL				0x6002
@@ -127,6 +127,7 @@ extern bool rk_fb_poll_wait_frame_complete(void);
 #define OUT_CCIR656         6
 #define OUT_S888            8
 #define OUT_S888DUMY        12
+#define OUT_YUV_420	    14
 #define OUT_RGB_AAA	    15
 #define OUT_P16BPP4         24
 #define OUT_D888_P666       0x21	//18bit screen,connect to lcdc D2~D7, D10~D15, D18~D23
@@ -293,7 +294,7 @@ typedef enum _TRSP_MODE {
 	TRSP_INVAL
 } TRSP_MODE;
 
-struct rk_lcdc_post_cfg{
+struct rk_lcdc_post_cfg {
 	u32 xpos;
 	u32 ypos;
 	u32 xsize;
@@ -309,18 +310,23 @@ struct rk_lcdc_bcsh {
 	u16 cos_hue;
 };
 
-struct rk_lcdc_win_area{
+struct rk_lcdc_win_area {
 	bool state;
+	enum data_format format;
+	u8 fmt_cfg;
+	u8 swap_rb;
 	u32 y_offset;		/*yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx*/
 	u32 c_offset;		/*cb cr offset--->LCDC_WINx_CBR_MSTx*/
-	u32 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u32 ypos;
+	u16 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
+	u16 ypos;
 	u16 xsize;		/* display window width/height  -->LCDC_WINx_DSP_INFO*/
 	u16 ysize;
 	u16 xact;		/*origin display window size -->LCDC_WINx_ACT_INFO*/
 	u16 yact;
 	u16 xvir;		/*virtual width/height     -->LCDC_WINx_VIR*/
 	u16 yvir;
+	u16 xoff;		/*mem offset*/
+	u16 yoff;
 	unsigned long smem_start;
 	unsigned long cbr_start;	/*Cbr memory start address*/
 #if defined(CONFIG_ION_ROCKCHIP)
@@ -328,13 +334,26 @@ struct rk_lcdc_win_area{
 		int dma_buf_fd;
 		struct dma_buf *dma_buf;
 #endif
-	u32 dsp_stx;
-	u32 dsp_sty;
-	u32 y_vir_stride;
-	u32 uv_vir_stride;
+	u16 dsp_stx;
+	u16 dsp_sty;
+	u16 y_vir_stride;
+	u16 uv_vir_stride;
 	u32 y_addr;
 	u32 uv_addr;
 
+	u8  fbdc_en;
+	u8  fbdc_cor_en;
+	u8  fbdc_data_format;
+	u8  fbdc_dsp_width_ratio;
+	u8  fbdc_fmt_cfg;
+	u16 fbdc_mb_vir_width;
+	u16 fbdc_mb_vir_height;
+	u16 fbdc_mb_width;
+	u16 fbdc_mb_height;
+	u16 fbdc_mb_xst;
+	u16 fbdc_mb_yst;
+	u16 fbdc_num_tiles;
+	u16 fbdc_cmp_index_init;
 };
 
 
@@ -344,11 +363,8 @@ struct rk_lcdc_win {
 	bool state;		/*on or off*/
 	bool last_state;		/*on or off*/
 	u32 pseudo_pal[16];
-	enum data_format format;
 	int z_order;		/*win sel layer*/
-	u8 fmt_cfg;
-	u8 fmt_10;;
-	u8 swap_rb;
+	u8 fmt_10;
 	u32 reserved;
 	u32 area_num;
 	u32 scale_yrgb_x;
@@ -376,8 +392,9 @@ struct rk_lcdc_win {
 	u8 vsd_cbr_gt2;
 
 	u8 alpha_en;
-	u32 alpha_mode;
-	u32 g_alpha_val;
+	u8 alpha_mode;
+	u16 g_alpha_val;
+	u8  mirror_en;
 	u32 color_key_val;
 	u8 csc_mode;
 
@@ -444,55 +461,64 @@ struct rk_lcdc_drv_ops {
 };
 
 struct rk_fb_area_par {
-	int ion_fd;
+	u8  data_format;        /*layer data fmt*/
+	short ion_fd;
 	unsigned long phy_addr;
-	int acq_fence_fd;
-	u32 x_offset;
-	u32 y_offset;
-	u32 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u32 ypos;
-	u32 xsize;		/* display window width/height  -->LCDC_WINx_DSP_INFO*/
-	u32 ysize;
-	u32 xact;		/*origin display window size -->LCDC_WINx_ACT_INFO*/
-	u32 yact;
-	u32 xvir;		/*virtual width/height     -->LCDC_WINx_VIR*/
-	u32 yvir;
+	short acq_fence_fd;
+	u16  x_offset;
+	u16  y_offset;
+	u16 xpos;	/*start point in panel  --->LCDC_WINx_DSP_ST*/
+	u16 ypos;
+	u16 xsize;	/* display window width/height  -->LCDC_WINx_DSP_INFO*/
+	u16 ysize;
+	u16 xact;	/*origin display window size -->LCDC_WINx_ACT_INFO*/
+	u16 yact;
+	u16 xvir;	/*virtual width/height     -->LCDC_WINx_VIR*/
+	u16 yvir;
+	u8  fbdc_en;
+	u8  fbdc_cor_en;
+	u8  fbdc_data_format;
+	u16 reserved0;
+	u32 reserved1;
 };
 
 
 struct rk_fb_win_par {
-	u8 data_format;        /*layer data fmt*/
-	u8 win_id;
-	u8 z_order;		/*win sel layer*/
+	u8  win_id;
+	u8  z_order;		/*win sel layer*/
+	u8  alpha_mode;
+	u16 g_alpha_val;
+	u8  mirror_en;
 	struct rk_fb_area_par area_par[RK_WIN_MAX_AREA];
-	u32 alpha_mode;
-	u32 g_alpha_val;
+	u32 reserved0;
 };
 
 struct rk_fb_win_cfg_data {
-	int ret_fence_fd;
-	int rel_fence_fd[RK_MAX_BUF_NUM];
+	u8  wait_fs;
+	short ret_fence_fd;
+	short rel_fence_fd[RK_MAX_BUF_NUM];
 	struct  rk_fb_win_par win_par[RK30_MAX_LAYER_SUPPORT];
 	struct  rk_lcdc_post_cfg post_cfg;
-	u8      wait_fs;
-	//u8      fence_begin;
 };
 
 struct rk_fb_reg_area_data {
 	struct sync_fence *acq_fence;
+	u8 data_format;        /*layer data fmt*/
 	u8  index_buf;          /*judge if the buffer is index*/
 	u32 y_offset;		/*yuv/rgb offset  -->LCDC_WINx_YRGB_MSTx*/
 	u32 c_offset;		/*cb cr offset--->LCDC_WINx_CBR_MSTx*/
 	u32 y_vir_stride;
 	u32 uv_vir_stride;
-	u32 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
-	u32 ypos;
+	u16 xpos;		/*start point in panel  --->LCDC_WINx_DSP_ST*/
+	u16 ypos;
 	u16 xsize;		/* display window width/height  -->LCDC_WINx_DSP_INFO*/
 	u16 ysize;
 	u16 xact;		/*origin display window size -->LCDC_WINx_ACT_INFO*/
 	u16 yact;
 	u16 xvir;		/*virtual width/height     -->LCDC_WINx_VIR*/
 	u16 yvir;
+	u16 xoff;		/*mem offset*/
+	u16 yoff;
 	unsigned long smem_start;
 	unsigned long cbr_start;	/*Cbr memory start address*/
 	u32 line_length;	
@@ -502,38 +528,38 @@ struct rk_fb_reg_area_data {
 	struct dma_buf_attachment *attachment;
 	struct sg_table *sg_table;
 	dma_addr_t dma_addr;
-#endif	
+#endif
+	u8  fbdc_en;
+	u8  fbdc_cor_en;
+	u8  fbdc_data_format;
 };
 
 struct rk_fb_reg_win_data {
-	u8 data_format;        /*layer data fmt*/
 	u8 win_id;
 	u8 z_order;		/*win sel layer*/
 	u32 area_num;		/*maybe two region have the same dma buff,*/
 	u32 area_buf_num;     /*so area_num  maybe not equal to area_buf_num*/
 	u8 alpha_en;
-	u32 alpha_mode;
-	u32 g_alpha_val;
-	u32 color_key_val;
+	u8 alpha_mode;
+	u16 g_alpha_val;
+	u8  mirror_en;
 
 	struct rk_fb_reg_area_data reg_area_data[RK_WIN_MAX_AREA];
 };
 
 struct rk_fb_reg_data {
 	struct list_head list;
-	int     win_num;
-	int     buf_num;
-	int 	acq_num;
+	int    win_num;
+	int    buf_num;
+	int    acq_num;
 	struct rk_fb_reg_win_data reg_win_data[RK30_MAX_LAYER_SUPPORT];
 	struct rk_lcdc_post_cfg post_cfg;
-	//struct sync_fence *acq_fence[RK_MAX_BUF_NUM];
-	//int     fence_wait_begin;
 };
 
 struct rk_lcdc_driver {
 	char name[6];
-	int id;
-	int prop;
+	int  id;
+	int  prop;
 	struct device *dev;
 
 	struct rk_lcdc_win *win[RK_MAX_FB_SUPPORT];
@@ -550,11 +576,12 @@ struct rk_lcdc_driver {
 	u16 overlay_mode;
 	u16 output_color;
 
-	u16 fb_win_map;
+	u16  fb_win_map;
 	char fb0_win_id;
 	char fb1_win_id;
 	char fb2_win_id;
 	char fb3_win_id;
+	char fb4_win_id;
 	
 	char mmu_dts_name[40];
 	struct device *mmu_dev;
-- 
2.35.3

