From 730fa523b85d85849c10863ebe5ef2ab5ecfbbc3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=AE=8B=E7=A7=80=E6=9D=B0?= <sxj@rock-chips.com>
Date: Tue, 21 Sep 2010 03:41:57 -0700
Subject: [PATCH] update pm control for raho, default close

---
 arch/arm/mach-rk2818/Kconfig                  |   3 +
 arch/arm/mach-rk2818/Makefile                 |   1 +
 arch/arm/mach-rk2818/board-raho.c             | 121 +++
 .../mach-rk2818/include/mach/rk2818-socpm.h   | 342 +++++++
 arch/arm/mach-rk2818/pm.c                     |  89 +-
 arch/arm/mach-rk2818/rk2818-socpm.c           | 906 ++++++++++++++++++
 6 files changed, 1424 insertions(+), 38 deletions(-)
 mode change 100644 => 100755 arch/arm/mach-rk2818/Kconfig
 mode change 100644 => 100755 arch/arm/mach-rk2818/Makefile
 create mode 100755 arch/arm/mach-rk2818/include/mach/rk2818-socpm.h
 create mode 100755 arch/arm/mach-rk2818/rk2818-socpm.c

diff --git a/arch/arm/mach-rk2818/Kconfig b/arch/arm/mach-rk2818/Kconfig
old mode 100644
new mode 100755
index 7e2dc38e020a..b948e9d689bf
--- a/arch/arm/mach-rk2818/Kconfig
+++ b/arch/arm/mach-rk2818/Kconfig
@@ -61,4 +61,7 @@ config WIFI_CONTROL_FUNC
         bool "Enable WiFi control function abstraction"
         help
           Enables Power/Reset/Carddetect function abstraction
+config RK2818_SOC_PM
+  bool "Enable soc power manager function"
+		default n
 endif
diff --git a/arch/arm/mach-rk2818/Makefile b/arch/arm/mach-rk2818/Makefile
old mode 100644
new mode 100755
index 6668289b73db..413de0ac435b
--- a/arch/arm/mach-rk2818/Makefile
+++ b/arch/arm/mach-rk2818/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_MACH_RK2818PHONE) += board-phonesdk.o
 obj-$(CONFIG_MACH_RAHO) += board-raho.o board-raho-rfkill.o
 obj-$(CONFIG_MACH_RK2818INFO) += board-infosdk.o board-infosdk-rfkill.o 
 obj-$(CONFIG_MACH_RK2818INFO_IT50) += board-infoit50.o board-infoit50-rfkill.o 
+obj-$(CONFIG_RK2818_SOC_PM) += rk2818-socpm.o
diff --git a/arch/arm/mach-rk2818/board-raho.c b/arch/arm/mach-rk2818/board-raho.c
index e8a51dfb519b..09c6b404ebe0 100755
--- a/arch/arm/mach-rk2818/board-raho.c
+++ b/arch/arm/mach-rk2818/board-raho.c
@@ -61,6 +61,8 @@
 #include "../../../drivers/staging/android/timed_gpio.h"
 #include "../../../sound/soc/codecs/wm8994.h"
 #include "../../../drivers/headset_observe/rk2818_headset.h"
+#include <mach/rk2818-socpm.h>
+#include <asm/tcm.h>
 
 /* --------------------------------------------------------------------
  *  声明了rk2818_gpioBank数组，并定义了GPIO寄存器组ID和寄存器基地址。
@@ -2006,7 +2008,122 @@ struct timed_gpio_platform_data rk28_vibrator_info = {
 	.gpios = timed_gpios,
 };
 #endif
+#if defined (CONFIG_RK2818_SOC_PM)
+void __tcmfunc rk2818_pm_scu_suspend(unsigned int *reg,int regoff)
+{
+
+	switch(regoff)
+	{
+		case PM_SCU_CLKGATE0_CON:
+			{
+			}
+
+
+	}
+		
+}
+
+
+
+void __tcmfunc rk2818_soc_general_reg_suspend(void)
+{
+	struct rk2818_pm_soc_st *general=rk2818_soc_pm.general;
+	
+	unsigned int *general_reg_addr=general->reg_base_addr;
+	#if 1
+	general->reg_ctrbit|=(0x1<<PM_GPIO0_AB_PU_CON);
+	general_reg_addr[PM_GPIO0_AB_PU_CON] =GPIO0_AB_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO0_CD_PU_CON);
+	general_reg_addr[PM_GPIO0_CD_PU_CON] = GPIO0_CD_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO1_AB_PU_CON);
+	general_reg_addr[PM_GPIO1_AB_PU_CON] = GPIO1_AB_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO1_CD_PU_CON);
+	general_reg_addr[PM_GPIO1_CD_PU_CON] = GPIO1_CD_NORMAL;
+	#endif
+	
+	general->reg_ctrbit|=(0x1<<PM_IOMUX_A_CON);
+	general->reg_ctrbit|=(0x1<<PM_IOMUX_B_CON);
 
+	rk2818_socpm_gpio_pullupdown(RK2818_PIN_PA3,GPIOPullDown);// 处理按键
+
+	#if 1  //set uart0 pin
+		
+		general_reg_addr[PM_IOMUX_A_CON] &=(~(0x3<<PM_UART0_OUT))&(~(0x3<<PM_UART0_IN));// 00 gpio 01uart
+		general_reg_addr[PM_IOMUX_B_CON] &=(~(0x1<<PM_UART0_RTS))&(~(0x1<<PM_UART0_CTS));//
+		rk2818_socpm_set_gpio(RK2818_PIN_PG0,0,0);//uart0 sin pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PG1,0,0);//uart0 sout pin
+		
+		rk2818_socpm_set_gpio(RK2818_PIN_PG0,0,0);//uart0 sin pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PG1,0,0);//uart0 sout pin
+
+		rk2818_socpm_set_gpio(RK2818_PIN_PB2,0,0);//uart0 cts pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PB3,0,0);//uart0 rts pin
+
+		rk2818_socpm_set_gpio(RK2818_PIN_PF7,0,0);//uart0 dtr pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PE0,0,0);//uart0 dsr pin
+
+		
+	#endif
+
+	#if 1  //set uart1 pin
+		
+		general_reg_addr[PM_IOMUX_A_CON] &=(~(0x3<<PM_UART1_OUT))&(~(0x3<<PM_UART1_IN));// 00 gpio 01uart
+		rk2818_socpm_set_gpio(RK2818_PIN_PF0,0,0);//uart0 sin pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PG1,0,0);//uart0 sout pin
+	#endif
+
+
+	#if 1  //set i2c0 pin
+		general_reg_addr[PM_IOMUX_A_CON] |=(0x1<<PM_I2C0);// 1 gpio;0 i2c
+		rk2818_socpm_set_gpio(RK2818_PIN_PE4,0,0);//sda pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PE5,0,0);//scl dsr pin
+	#endif
+
+	#if 1  //set i2c1 pin
+		general_reg_addr[PM_IOMUX_A_CON] &=(~(0x3<<PM_I2C1));// 0 gpio;1 i2c
+		rk2818_socpm_set_gpio(RK2818_PIN_PE6,0,0);//sda pin
+		rk2818_socpm_set_gpio(RK2818_PIN_PE7,0,0);//scl dsr pin
+	#endif
+	#if 1  // sdio0
+
+		general_reg_addr[PM_IOMUX_A_CON] &=(~(0x1<<PM_SDIO0_CMD))&(~(0x1<<PM_SDIO0_DATA));// 1 gpio;0 i2c
+		rk2818_socpm_set_gpio(RK2818_PIN_PH0,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PH1,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PH2,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PH3,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PH4,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PH5,0,0);
+
+		//rk2818_socpm_set_gpio(RK2818_PIN_PF3,0,0);
+
+
+	#endif
+	#if 1 // sdio1
+		general_reg_addr[PM_IOMUX_A_CON] &=(~(0x1<<PM_SDIO1_CMD))&(~(0x1<<PM_SDIO1_DATA));// 1 gpio;0 i2c
+		rk2818_socpm_set_gpio(RK2818_PIN_PG2,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PG3,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PG4,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PG5,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PG6,0,0);
+		rk2818_socpm_set_gpio(RK2818_PIN_PG7,0,0);
+	#endif
+}
+void __tcmfunc rk2818_pm_set_vol(void)
+{
+	rk2818_socpm_set_gpio(RK2818_PIN_PC2,1,0);
+}
+void __tcmfunc rk2818_pm_resume_vol(void)
+{
+	rk2818_socpm_set_gpio(RK2818_PIN_PC2,1,1);
+}
+#else
+#define	pm_set_general_cpu_reg(a)
+#define	rk2818_pm_set_vol()
+#define	rk2818_pm_resume_vol()
+#endif
 static void __init machine_rk2818_init_irq(void)
 {
 	rk2818_init_irq();
@@ -2016,6 +2133,10 @@ static void __init machine_rk2818_init_irq(void)
 
 static void __init machine_rk2818_board_init(void)
 {	
+	printk("3x machine_rk2818_board_init\n");
+	
+	rk2818_socpm_int( (pm_scu_suspend) rk2818_pm_scu_suspend,(pm_general_reg_suspend) rk2818_soc_general_reg_suspend,
+	(pm_set_suspendvol) rk2818_pm_set_vol,(pm_resume_vol) rk2818_pm_resume_vol);
 	rk2818_power_on();
 	pm_power_off = rk2818_power_off;
 #ifdef CONFIG_I2C0_RK2818
diff --git a/arch/arm/mach-rk2818/include/mach/rk2818-socpm.h b/arch/arm/mach-rk2818/include/mach/rk2818-socpm.h
new file mode 100755
index 000000000000..0f7d430402ef
--- /dev/null
+++ b/arch/arm/mach-rk2818/include/mach/rk2818-socpm.h
@@ -0,0 +1,342 @@
+/*
+ * rockchip-pcm.h - ALSA PCM interface for the Rockchip rk28 SoC
+ *
+ * Driver for rockchip iis audio
+ *  Copyright (C) 2009 lhh
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ROCKCHIP_SOC_PM_H
+#define _ROCKCHIP_SOC_PM_H
+
+#if defined (CONFIG_RK2818_SOC_PM)
+
+#include <asm/tcm.h>
+#include <mach/gpio.h>
+
+
+#define RK2818_PM_PRT_ORIGINAL_REG
+#define RK2818_PM_PRT_CHANGED_REG
+
+#define PM_SAVE_REG_NUM 4
+
+#define PM_NUM_BIT_MASK(b)	((0x1<<(b))-1)
+#define PM_BIT_OFF_MASK(off,numbit)	(PM_NUM_BIT_MASK(numbit)<<(off))
+#define PM_BIT_CLEAR(off,numbit)	(~(PM_BIT_OFF_MASK(off,numbit)))
+#define PM_BIT_SET(off,val,numbit)	((val&PM_NUM_BIT_MASK(numbit))<<off)
+#define PM_BIT_get(val,off,numbit)	((val&PM_NUM_BIT_MASK(numbit))>>off)
+
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+
+#define PM_SCU_ATTR_DBG_NUM 30
+#define PM_GENERAL_ATTR_DBG_NUM 10
+#define PM_GPIO0_ATTR_DBG_NUM 10
+#define PM_GPIO1_ATTR_DBG_NUM 10
+
+
+#define PM_DBG_CH_REG_INI 0
+#define PM_DBG_CH_REG_UPDATA	1
+
+
+
+#define PM_DBG_SET_ONCE 0xEE
+#define PM_DBG_SET_ALWAY 0x99
+#define PM_DBG_NOT_SET 0
+
+enum PM_DBG_USER_EN{
+
+	PM_DBG_USER_VALUE,
+	PM_DBG_USER_REGOFF,
+	PM_DBG_USER_BITS_OFF,
+	PM_DBG_USER_BITS_NUM,
+	PM_DBG_USER_FLAG,
+	PM_DBG_USER_END,
+};
+
+
+#define PM_ATTR_CTR_ONCE 0xEE
+#define PM_ATTR_CTR_ALWAY 0x99
+#define PM_ATTR_NO_CTR 0x0
+
+struct rk2818_pm_attr_dbg_st{
+	unsigned int value;
+	unsigned char regoff;
+	unsigned char regbits_off;
+	unsigned char bitsnum;
+	unsigned char flag;
+};
+
+bool rk2818_socpm_attr_store(int type,const char *buf, size_t n);
+ssize_t rk2818_socpm_attr_show(int type,char *buf);
+#endif
+
+typedef void (*pm_scu_suspend)(unsigned int *tempdata,int regoff);
+typedef void (*pm_general_reg_suspend)(void);
+typedef void (*pm_set_suspendvol)(void);
+typedef void (*pm_resume_vol)(void);
+
+struct rk2818_pm_soc_st{
+unsigned int *reg_save;
+unsigned int *reg_base_addr;
+u16 reg_ctrbit;
+u8 reg_num;
+#ifdef RK2818_PM_PRT_CHANGED_REG
+unsigned int *reg_ch;
+#endif
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+u8 attr_num;
+struct rk2818_pm_attr_dbg_st *attr_dbg;
+u8 attr_flag;
+#endif
+};
+
+struct rk2818_pm_callback_st{
+int data;
+pm_scu_suspend scu_suspend;
+pm_general_reg_suspend general_reg_suspend;
+pm_set_suspendvol set_suspendvol;
+pm_resume_vol resume_vol;
+};
+
+
+
+struct rk2818_pm_st{
+struct rk2818_pm_soc_st *scu;
+unsigned int *scu_tempreg;
+unsigned int scu_reg;
+struct rk2818_pm_soc_st *general;
+struct rk2818_pm_soc_st *gpio0;
+struct rk2818_pm_soc_st *gpio1;
+//struct rk2818_pm_callback_st *callback;
+unsigned int *save_reg;
+unsigned int *save_ch;
+pm_scu_suspend scu_suspend;
+pm_general_reg_suspend general_reg_suspend;
+pm_set_suspendvol set_suspendvol;
+pm_resume_vol resume_vol;
+};
+
+/***********************scu SCU_CLKSEL0 reg bit************************************/
+#define PM_RESUME_BIT	0
+#define PM_DEBUG_BIT	1
+#define PM_SET_BIT(b) (1<<b)
+#define PM_GET_BIT(val,b)	((val&(1<<b))>>b)
+
+
+
+
+
+
+/***********************scu SCU_CLKSEL0 reg bit************************************/
+
+#define SCU_GATE0CLK_ALL_EN 0
+#define SCU_GATE0CLK_ALL_DIS 0XFFFFFFFF
+#define DIS_TIMER_CLK (1<<25)
+#define DIS_UART1_CLK (1<<19)
+#define DIS_UART0_CLK (1<<18)
+#define DIS_GPIO1_CLK (1<<17)
+#define DIS_GPIO0_CLK (1<<16)
+#define DIS_INTC_CLK (1<<9)
+#define DIS_ARM_CLK (1<<0)
+/***********************scu SCU_CLKSEL1_CON reg bit************************************/
+
+#define SCU_GATE1CLK_ALL_EN 0
+//#define SCU_GATE1CLK_BASE_SET (0XFFFFFFFF&(~DIS_DDR_CLK)&(~DIS_DDR_HCLK)) // 注意AXI 位为1时为enable 
+
+#define SCU_GATE1CLK_BASE_SET (0XFFFF8001&(~EN_AXI_CLK)) // 注意AXI 位为1时为enable 
+//#define SCU_GATE1CLK_BASE_SET (0XFFFFFFFF)
+#define EN_AXI_CLK (1<<27)
+#define DIS_DDR_CLK (1<<23)
+#define DIS_DDR_HCLK (1<<22)
+#define DIS_MSDRAM_CTR_HCLK (1<<17)
+#define DIS_SDRAM_CTR_HCLK (1<<16)
+#define DIS_MAndSDRAM_CMM_HCLK (1<<15)
+/***********************scu SCU_CLKSEL2_CON reg bit************************************/
+#define SCU_GATE2CLK_ALL_EN 0
+#define SCU_GATE2CLK_ALL_DIS 0X3FF
+#define SCU_GATE2CLK_BASE_SET	(SCU_GATE2CLK_ALL_DIS&(~DIS_ARMIBUS_CLK)&(~DIS_ARMDBUS_CLK)&(~DIS_EXPAHBBUS_CLK)&(~DIS_APBBUS_CLK))
+
+#define DIS_ITCMBUS_CLK      (1<<8)
+#define DIS_DTCM0BUS_CLK      (1<<7)
+#define DIS_DTCM1BUS_CLK      (1<<6)
+
+#define DIS_APBBUS_CLK      (1<<4)
+#define DIS_EXPAHBBUS_CLK	(1<<3)
+#define DIS_ARMDBUS_CLK      (1<<1)
+#define DIS_ARMIBUS_CLK	(1<<0)
+/***********************scu SCU_APLL_CON reg bit************************************/
+#define ARMPLL_POERDOWN (1<<22)
+#define ARMPLL_BYPASSMODE (1<<0)
+/***********************scu SCU_DPLL_CON reg bit************************************/
+
+#define DSPPLL_POERDOWN (1<<22)
+
+/***********************scu SCU_CPLL_CON reg bit************************************/
+#define CPLL_POERDOWN (1<<22)
+
+/***********************scu PM_SCU_MODE_CON reg bit************************************/
+#define CPU_SLOW_MODE (~(3<<2))
+#define CPU_STOP_MODE (1<<4)
+
+
+
+/***********************scu SCU_PMU_CON reg bit************************************/
+
+#define LCDC_POWER_DOWN (1<<3)
+#define DSP_POWER_DOWN (1<<0)
+ #define DDR_POWER_DOWN (1<<2)
+
+
+/***********************scu PM_SCU_CLKSEL0_CON reg bit************************************/
+#define CLKSEL0_HCLK (0)
+#define CLKSEL0_PCLK (2)
+
+#define CLK_ARM1_H1 (0)
+#define CLK_ARM2_H1 (1)
+#define CLK_ARM3_H1 (2)
+#define CLK_ARM4_H1 (3)
+
+#define CLK_HCLK1_P1 (0)
+#define CLK_HCLK2_P1 (1)
+#define CLK_HCLK4_P1 (2)
+
+/***********************scu PM_SCU_SOFTRST_CON] reg bit************************************/
+#define RST_ALL 0xFFFFFFFF
+
+#define RST_DDR_BUS (1<<31)
+#define RST_DDR_CORE_LOGIC (1<<30)
+
+#define RST_ARM (1<<23)
+
+enum
+{
+	PM_SCU_APLL_CON,
+	PM_SCU_DPLL_CON,
+	PM_SCU_CPLL_CON,
+	PM_SCU_MODE_CON,
+	PM_SCU_PMU_CON,
+	PM_SCU_CLKSEL0_CON,
+	PM_SCU_CLKSEL1_CON,
+	PM_SCU_CLKGATE0_CON,
+	PM_SCU_CLKGATE1_CON,
+	PM_SCU_CLKGATE2_CON,
+	PM_SCU_SOFTRST_CON,
+	PM_SCU_CHIPCFG_CON,
+	PM_SCU_CPUPD,
+	PM_CLKSEL2_CON,
+	PM_SCU_REG_NUM
+};
+
+/***********************general cpu reg bit************************************/
+#define RK2818GPIO_TOTAL	(PIN_BASE+NUM_GROUP*MAX_GPIO_BANKS)
+
+/***********************general cpu reg  IOMUX_A bit************************************/
+
+#define PM_I2C0 (30)
+#define PM_I2C1 (28)
+#define PM_UART1_OUT (26)    
+#define PM_UART1_IN (24)
+#define PM_SDIO1_CMD (23)
+#define PM_SDIO1_DATA (22)
+#define PM_UART0_OUT (14)    
+#define PM_UART0_IN (12)
+
+#define PM_SDIO0_CMD (5)
+#define PM_SDIO0_DATA (4)
+
+
+
+/***********************general cpu reg  IOMUX_B bit************************************/
+
+#define PM_UART0_RTS (13)    
+#define PM_UART0_CTS (12)
+
+
+
+
+
+
+/***********************general cpu reg  PU bit************************************/
+#define PM_CLEAR_IO_PU(pin) (~((3)<<pin))
+#define PM_GPIO_NRO(pin) (0<<pin)
+#define PM_GPIO_UP(pin) (1<<pin)
+#define PM_GPIO_DN(pin) (2<<pin)
+
+#define GPIO0_AB_NORMAL (0X0)
+#define GPIO0_CD_NORMAL (0X0)
+#define GPIO1_AB_NORMAL (0X0)
+#define GPIO1_CD_NORMAL (0X0)
+
+#define GPIO0_A0 (0)
+#define GPIO0_A3 (3*2)
+
+enum
+{
+    PM_CPU_APB_REG0,
+    PM_CPU_APB_REG1,
+    PM_CPU_APB_REG2,
+    PM_CPU_APB_REG3,
+    PM_CPU_APB_REG4,
+    PM_CPU_APB_REG5,
+    PM_CPU_APB_REG6,
+    PM_CPU_APB_REG7,
+    PM_IOMUX_A_CON,
+    PM_IOMUX_B_CON,
+    PM_GPIO0_AB_PU_CON,
+    PM_GPIO0_CD_PU_CON,
+    PM_GPIO1_AB_PU_CON,
+    PM_GPIO1_CD_PU_CON,
+    PM_OTGPHY_CON0,
+    PM_OTGPHY_CON1,
+    PM_GENERAL_CPU_REG
+};
+/***********************gpio cpu reg bit************************************/
+
+enum
+{
+	PM_GPIO_SWPORTA_DR,
+	PM_GPIO_SWPORTA_DDR,
+	PM_GPIO_SWPORTA_NULL,
+	PM_GPIO_SWPORTB_DR,
+	PM_GPIO_SWPORTB_DDR,
+	PM_GPIO_SWPORTB_NULL,
+	PM_GPIO_SWPORTC_DR,
+	PM_GPIO_SWPORTC_DDR,
+	PM_GPIO_SWPORTC_NULL,
+	PM_GPIO_SWPORTD_DR,
+	PM_GPIO_SWPORTD_DDR,
+	PM_SCU_GPIO_SWPORTC_NUM
+};
+
+void rk2818_socpm_int(pm_scu_suspend scu,pm_general_reg_suspend general,
+	pm_set_suspendvol setvol,pm_resume_vol resumevol);
+	extern struct rk2818_pm_st __tcmdata rk2818_soc_pm;
+extern int  __tcmfunc rk2818_socpm_gpio_pullupdown(unsigned int gpio,eGPIOPullType_t GPIOPullUpDown);
+extern int  __tcmfunc rk2818_socpm_set_gpio(unsigned int gpio,unsigned int output,unsigned int level);
+
+
+
+void __tcmfunc rk2818_socpm_suspend_first(void);
+void __tcmfunc rk2818_socpm_suspend(void);
+
+void __tcmfunc rk2818_socpm_resume_first(void);
+void __tcmfunc rk2818_socpm_resume(void);
+void rk2818_socpm_print(void);
+#else
+#define rk2818_socpm_int(a,b,c,d)
+#define rk2818_socpm_gpio_pullupdown(a,b)
+#define rk2818_socpm_set_gpio(a,b,c)
+#define rk2818_socpm_suspend_first()
+#define rk2818_socpm_suspend()
+#define rk2818_socpm_resume_first()
+#define rk2818_socpm_resume()
+#define rk2818_socpm_print()
+
+#endif
+
+
+#endif
+
diff --git a/arch/arm/mach-rk2818/pm.c b/arch/arm/mach-rk2818/pm.c
index 1a39de4f905a..ed0c4af40d3c 100755
--- a/arch/arm/mach-rk2818/pm.c
+++ b/arch/arm/mach-rk2818/pm.c
@@ -11,7 +11,7 @@
 #include <mach/scu.h>
 #include <mach/iomux.h>
 #include <mach/gpio.h>
-#include <mach/rk2818_pm.h>
+#include <mach/rk2818-socpm.h>
 #include <linux/regulator/driver.h>
 
 extern void rockchip_timer_clocksource_suspend_resume(int suspend);
@@ -120,7 +120,8 @@ u32 __tcmfunc sdram_enter_self_refresh(void)
 	case MOBILE_DDR:
 		r = ddr_readl(CTRL_REG_62);
 		ddr_writel((r & ~MODE5_MASK) | MODE5_CNT(1), CTRL_REG_62);
-		//FIXME: 绛寰杩self-refresh
+	//	tcm_printascii("3x DDRII\n");
+
 		break;
 	}
 
@@ -168,6 +169,7 @@ void __tcmfunc sdram_exit_self_refresh(u32 ctrl_reg_62)
 	tcm_udelay(100, 24); //DRVDelayUs(100); 寤舵朵涓姣杈瀹锛淇璇哄绋冲
 }
 
+#if 0
 static void __tcmlocalfunc noinline tcm_printch(char byte)
 {
 	unsigned int timeout;
@@ -181,7 +183,6 @@ static void __tcmlocalfunc noinline tcm_printch(char byte)
 	if (byte == '\n')
 		tcm_printch('\r');
 }
-
 static void __tcmlocalfunc noinline tcm_printascii(const char *s)
 {
 	while (*s) {
@@ -201,6 +202,7 @@ static void __tcmlocalfunc noinline tcm_printhex(unsigned int hex)
 		hex <<= 4;
 	}
 }
+#endif
 
 //#define RK2818_MOBLIE_PM_CON
 #ifdef RK2818_MOBLIE_PM_CON
@@ -327,14 +329,14 @@ static void __tcmfunc rk2818_pm_suspend_first(void)
 	pm_save.gpio1_regbit=0x6db;
 	//pm_save.savereg[0]=rk2818_ddr_reg[82];
 	//rk2818_ddr_reg[82]=rk2818_ddr_reg[82]&(~(0xffff))&(~(0xf<<20));
-	//pm_set_gpio_pinstate(RK2818_PIN_PC2,1,0);
+	pm_set_gpio_pinstate(RK2818_PIN_PC2,1,0);
 	tcm_printascii("suspend frist\n");
 }
 
 static void __tcmfunc rk2818_pm_resume_first(void)
 {
 	//unsigned int *rk2818_ddr_reg=(unsigned int *)RK2818_SDRAMC_BASE;
-	//pm_set_gpio_pinstate(RK2818_PIN_PC2,1,1);
+	pm_set_gpio_pinstate(RK2818_PIN_PC2,1,1);
 	//rk2818_ddr_reg[82]=pm_save.savereg[0];
 }
 static void __tcmfunc rk2818_soc_scu_suspend(void)
@@ -489,12 +491,12 @@ static void __tcmfunc rk2818_soc_resume(unsigned int *pm_save_reg,unsigned int *
 		base_add[i]=pm_save_reg[i];
 	}
 }
-void __tcmfunc rk2818_pm_soc_suspend(void)
+static void __tcmfunc rk2818_pm_soc_suspend(void)
 { 
 	rk2818_soc_scu_suspend( );
 	//rk2818_soc_general_cpu_suspend( );
 }
-void __tcmfunc rk2818_pm_soc_resume(void)
+static void __tcmfunc rk2818_pm_soc_resume(void)
 {
 	rk2818_soc_resume(pm_save.pm_scu_reg,(unsigned int *)RK2818_SCU_BASE,pm_save.scu_regbit,PM_SCU_REG_NUM);
 	//rk2818_soc_resume(pm_save.pm_cpu_reg,(unsigned int *)RK2818_REGFILE_BASE,pm_save.cpu_regbit,PM_GENERAL_CPU_REG);
@@ -548,47 +550,56 @@ static int __tcmfunc rk2818_tcm_idle(void)
 	u32 scu_mode = scu_readl(SCU_MODE_CON);
 	u32 scu_apll = scu_readl(SCU_APLL_CON);
 	u32 scu_clksel0 = scu_readl(SCU_CLKSEL0_CON);
-	unsigned int *rk2818_scu_reg=(unsigned int *)RK2818_SCU_BASE;
-	
+
 	asm("b 1f; .align 5; 1:");
 	asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
 	
+
 	scu_writel(scu_mode & ~(3 << 2), SCU_MODE_CON); // slow
 	scu_writel(scu_apll | PLL_PD, SCU_APLL_CON); // powerdown
 
-	ctrl_reg_62 = sdram_enter_self_refresh();
-	rk2818_scu_reg[PM_SCU_CLKGATE2_CON]&=(~DIS_DTCM0BUS_CLK)&(~DIS_DTCM1BUS_CLK);
-	tcm_udelay(1, 24);
-	rk2818_pm_suspend_first( );
-	tcm_udelay(1, 24);
-	rk2818_pm_soc_suspend( );
-	tcm_udelay(1, 24);
-	asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
-	rk2818_pm_resume_first( );
-	tcm_udelay(1, 24);
-	rk2818_pm_soc_resume( );
-	tcm_udelay(1, 24);
-	sdram_exit_self_refresh(ctrl_reg_62);
 	
-	//regulator_set_voltage(buck1,1200000,1200000);
+	//tcm_printascii("3x pm ddr refresh\n");
+	//rk28_ddr_enter_self_refresh();
+	tcm_udelay(5, 24); //DRVDelayUs(100); 
+	ctrl_reg_62=sdram_enter_self_refresh();
+	tcm_udelay(200, 24); //DRVDelayUs(100); 
+
+	rk2818_socpm_suspend_first();
+	rk2818_socpm_suspend();
+	tcm_udelay(1, 24); //DRVDelayUs(100); 
 
+	asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+
+	tcm_udelay(1, 24); //DRVDelayUs(100); 
+	rk2818_socpm_resume_first();
+	rk2818_socpm_resume();
+	tcm_udelay(1, 24); //DRVDelayUs(100); 
+	sdram_exit_self_refresh(ctrl_reg_62);
+	//rk28_ddr_exit_self_refresh();
+	//tcm_printascii("3x pm re\n");
+	tcm_udelay(10, 24);
 	scu_writel(scu_apll, SCU_APLL_CON); // powerup
 	scu_writel(scu_clksel0 & (~3), SCU_CLKSEL0_CON);
-	
-	tcm_udelay(2, 24);
+	tcm_udelay(20, 24);
+	//tcm_printascii("3x pm re1\n");
 
 	unit = 7200;  /* 24m,0.3ms , 24*300*/
 	while (unit-- > 0) {
 		if (regfile_readl(CPU_APB_REG0) & 0x80)
 			break;
 	}
+	///tcm_printascii("3x pm re2\n");
 
 	tcm_udelay(5 << 8, 24);
 	scu_writel(scu_clksel0, SCU_CLKSEL0_CON);
 	tcm_udelay(5, 24);
+	//tcm_printascii("3x pm re3\n");
 
 	scu_writel(scu_mode, SCU_MODE_CON); // normal
-	//rk2818_pm_print( );
+
+	//tcm_printascii("3x pm re4\n");
+
 	return unit;
 }
 
@@ -601,8 +612,12 @@ static void rk2818_idle(void)
 	asm volatile ("mov sp, %0" :: "r" (tcm_sp));
 	rk2818_tcm_idle();
 	asm volatile ("mov sp, %0" :: "r" (old_sp));
+
+	printk("rk2818_idle\n");
+
 }
 
+#if 1
 static void dump_register(void)
 {
 #ifdef CONFIG_PM_DEBUG
@@ -631,21 +646,18 @@ static void dump_register(void)
 
 static int rk2818_pm_enter(suspend_state_t state)
 {
-	//struct clk *arm_clk = clk_get(NULL, "arm");
-	//unsigned long arm_rate = clk_get_rate(arm_clk);
-
 	int irq_val = 0;
-    	//struct regulator *buck1;
-	//u32 scu_mode = scu_readl(SCU_MODE_CON);
-	//u32 scu_apll = scu_readl(SCU_APLL_CON);
-	//u32 scu_clksel0 = scu_readl(SCU_CLKSEL0_CON);
+	struct clk *arm_clk = clk_get(NULL, "arm");
+	unsigned long arm_rate = clk_get_rate(arm_clk);
+
 	printk(KERN_DEBUG "before core halt\n");
 
-	//clk_set_rate(arm_clk, 24000000);
+	clk_set_rate(arm_clk, 24000000);
 	dump_register();
 
 #ifdef CONFIG_RK28_USB_WAKE
 	rockchip_timer_clocksource_suspend_resume(1);
+
 	while (!irq_val) {
 		rk28_usb_suspend(0);
 #endif
@@ -654,7 +666,7 @@ static int rk2818_pm_enter(suspend_state_t state)
 
 #ifdef CONFIG_RK28_USB_WAKE
 		rk28_usb_suspend(1);
-		__udelay(400);
+		udelay(400);
 
 		irq_val = rockchip_timer_clocksource_irq_checkandclear();
 		irq_val |= rk28_usb_check_vbus_change();
@@ -663,11 +675,14 @@ static int rk2818_pm_enter(suspend_state_t state)
 
 	rockchip_timer_clocksource_suspend_resume(0);
 #endif
+
 	dump_register();
-	//clk_set_rate(arm_clk, arm_rate);
+	clk_set_rate(arm_clk, arm_rate);
+	//rk2818_socpm_print();
 	printk(KERN_DEBUG "quit arm halt,irq_val=0x%x\n", irq_val);
 	return 0;
 }
+#endif
 
 static struct platform_suspend_ops rk2818_pm_ops = {
 	.enter		= rk2818_pm_enter,
@@ -679,6 +694,4 @@ static int __init rk2818_pm_init(void)
 	suspend_set_ops(&rk2818_pm_ops);
 	return 0;
 }
-
 __initcall(rk2818_pm_init);
-
diff --git a/arch/arm/mach-rk2818/rk2818-socpm.c b/arch/arm/mach-rk2818/rk2818-socpm.c
new file mode 100755
index 000000000000..80886d46dc6d
--- /dev/null
+++ b/arch/arm/mach-rk2818/rk2818-socpm.c
@@ -0,0 +1,906 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/tcm.h>
+#include <mach/rk2818_iomap.h>
+#include <mach/scu.h>
+#include <mach/iomux.h>
+#include <mach/gpio.h>
+#include <mach/rk2818-socpm.h>
+#include <linux/regulator/driver.h>
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+
+static struct rk2818_pm_attr_dbg_st __tcmdata pm_scu_attr_dbg[PM_SCU_ATTR_DBG_NUM];
+static struct rk2818_pm_attr_dbg_st __tcmdata pm_general_attr_dbg[PM_GENERAL_ATTR_DBG_NUM];
+static struct rk2818_pm_attr_dbg_st __tcmdata pm_gpio0_attr_dbg[PM_GPIO0_ATTR_DBG_NUM];
+static struct rk2818_pm_attr_dbg_st __tcmdata pm_gpio1_attr_dbg[PM_GPIO1_ATTR_DBG_NUM];
+//static void rk2818_socpm_attr_int(void);
+//static void setreg_form_socpm_attr(unsigned int *reg,int regoff,struct rk2818_pm_soc_st *soc);
+#else
+
+#define setreg_form_socpm_attr(a,b,c)
+#endif
+
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+static unsigned int __tcmdata pm_scu_reg_ch[PM_SCU_REG_NUM];
+static unsigned int __tcmdata pm_general_reg_ch[PM_GENERAL_CPU_REG];
+static unsigned int __tcmdata pm_gpio0_reg_ch[PM_SCU_GPIO_SWPORTC_NUM];
+static unsigned int __tcmdata pm_gpio1_reg_ch[PM_SCU_GPIO_SWPORTC_NUM];
+#endif
+static unsigned int __tcmdata pm_scu_reg_save[PM_SCU_REG_NUM];
+static unsigned int __tcmdata pm_scu_temp_reg[PM_SCU_REG_NUM];
+
+static struct rk2818_pm_soc_st __tcmdata pm_scu_ctr={
+.reg_save=&pm_scu_reg_save[0],
+.reg_base_addr=(unsigned int *)RK2818_SCU_BASE,
+.reg_ctrbit=0,
+.reg_num=PM_SCU_REG_NUM,
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+.reg_ch=&pm_scu_reg_ch[0],
+#endif
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+.attr_num=PM_SCU_ATTR_DBG_NUM,
+.attr_dbg=&pm_scu_attr_dbg[0],
+.attr_flag=0,
+#endif
+};
+
+
+static unsigned int __tcmdata pm_general_reg_save[PM_GENERAL_CPU_REG];
+
+static struct rk2818_pm_soc_st __tcmdata pm_general_ctr={
+.reg_save=&pm_general_reg_save[0],
+.reg_base_addr=(unsigned int *)RK2818_REGFILE_BASE,
+.reg_ctrbit=0,
+.reg_num=PM_GENERAL_CPU_REG,
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+.reg_ch=&pm_general_reg_ch[0],
+#endif
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+.attr_num=PM_GENERAL_ATTR_DBG_NUM,
+.attr_dbg=&pm_general_attr_dbg[0],
+.attr_flag=0,
+#endif
+};
+
+
+static unsigned int __tcmdata pm_gpio0_reg_save[PM_SCU_GPIO_SWPORTC_NUM];
+
+
+
+static struct rk2818_pm_soc_st __tcmdata pm_gpio0_ctr={
+.reg_save=&pm_gpio0_reg_save[0],
+.reg_base_addr=(unsigned int *)RK2818_GPIO0_BASE,
+.reg_ctrbit=0,
+.reg_num=PM_SCU_GPIO_SWPORTC_NUM,
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+.reg_ch=&pm_gpio0_reg_ch[0],
+#endif
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+.attr_num=PM_GPIO0_ATTR_DBG_NUM,
+.attr_dbg=&pm_gpio0_attr_dbg[0],
+.attr_flag=0,
+#endif
+};
+static unsigned int __tcmdata pm_gpio1_reg_save[PM_SCU_GPIO_SWPORTC_NUM];
+
+static struct rk2818_pm_soc_st __tcmdata pm_gpio1_ctr={
+.reg_save=&pm_gpio1_reg_save[0],
+.reg_base_addr=(unsigned int *)RK2818_GPIO1_BASE,
+.reg_ctrbit=0,
+.reg_num=PM_SCU_GPIO_SWPORTC_NUM,
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+.reg_ch=&pm_gpio1_reg_ch[0],
+#endif
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+.attr_num=PM_GPIO1_ATTR_DBG_NUM,
+.attr_dbg=&pm_gpio1_attr_dbg[0],
+.attr_flag=0,
+#endif
+};
+
+static unsigned int __tcmdata pm_savereg[PM_SAVE_REG_NUM];
+static unsigned int __tcmdata savereg_ch[PM_SAVE_REG_NUM];
+
+struct rk2818_pm_st __tcmdata rk2818_soc_pm={
+.scu=(struct rk2818_pm_soc_st *)&pm_scu_ctr.reg_save,
+.scu_tempreg=&pm_scu_temp_reg[0],
+.general=(struct rk2818_pm_soc_st *)&pm_general_ctr.reg_save,
+.gpio0=(struct rk2818_pm_soc_st *)&pm_gpio0_ctr.reg_save,
+.gpio1=(struct rk2818_pm_soc_st *)&pm_gpio1_ctr.reg_save,
+.save_reg=&pm_savereg[0],
+.save_ch=&savereg_ch[0],
+.scu_suspend=NULL,
+.general_reg_suspend=NULL,
+.set_suspendvol=NULL,
+.resume_vol=NULL,
+};
+
+int __tcmfunc rk2818_socpm_set_gpio(unsigned int gpio,unsigned int output,unsigned int level)
+{
+	unsigned int *rk2818_gpio_reg;
+	struct rk2818_pm_soc_st *gpioctr;
+	unsigned int regoff;
+
+	if(gpio>=RK2818GPIO_TOTAL)
+		return -1;
+	
+	if(gpio<32)
+	{
+		gpioctr=rk2818_soc_pm.gpio0;
+	}
+	else
+	{
+		gpioctr=rk2818_soc_pm.gpio1;
+		gpio-=32;
+	}
+	rk2818_gpio_reg=gpioctr->reg_base_addr;
+	switch(gpio/8)
+	{
+		case 0:
+			gpioctr->reg_ctrbit|=(0x1<<PM_GPIO_SWPORTA_DR)|(0x1<<PM_GPIO_SWPORTA_DDR);
+			regoff=PM_GPIO_SWPORTA_DR;
+			break;
+		case 1:
+			gpioctr->reg_ctrbit|=(0x1<<PM_GPIO_SWPORTB_DR)|(0x1<<PM_GPIO_SWPORTB_DDR);
+			regoff=PM_GPIO_SWPORTB_DR;
+			break;
+		case 2:
+			gpioctr->reg_ctrbit|=(0x1<<PM_GPIO_SWPORTC_DR)|(0x1<<PM_GPIO_SWPORTC_DDR);
+			regoff=PM_GPIO_SWPORTC_DR;
+			break;
+		case 3:
+			gpioctr->reg_ctrbit|=(0x1<<PM_GPIO_SWPORTD_DR)|(0x1<<PM_GPIO_SWPORTD_DDR);
+			regoff=PM_GPIO_SWPORTD_DR;
+		break;
+		default:
+			return -1;
+	}
+	gpio%=8;
+
+	if(output)
+	{
+		rk2818_gpio_reg[regoff+1]|=(1<<gpio);//ddr set dir
+		if(level==0)
+			rk2818_gpio_reg[regoff]&=(~(1<<gpio));//ddr set value
+		else
+			rk2818_gpio_reg[regoff]|=(1<<gpio);
+	}
+	else
+		rk2818_gpio_reg[regoff+1]&=(~(1<<gpio));//ddr set dir	
+	return 0;
+}
+
+int __tcmfunc rk2818_socpm_gpio_pullupdown(unsigned int gpio,eGPIOPullType_t GPIOPullUpDown)
+{
+	unsigned int *general_reg;
+	unsigned int regoff;
+	int gpionum=0;
+
+	if(gpio>=RK2818GPIO_TOTAL)
+		return -1;
+	general_reg=rk2818_soc_pm.general->reg_base_addr;
+	regoff=PM_GPIO0_AB_PU_CON+gpio/16;
+	rk2818_soc_pm.general->reg_ctrbit|=((0x1<<regoff));
+	gpionum=gpio%16;
+	general_reg[regoff]&=PM_BIT_CLEAR(gpionum*2,2)|PM_BIT_SET(gpionum*2,GPIOPullUpDown,2);
+	return 0;
+}
+
+#if 0
+static void __tcmlocalfunc noinline tcm_printch(char byte)
+{
+	unsigned int timeout;
+
+	timeout = 0xffffffff;
+	while (!(readl(RK2818_UART1_BASE + 0x7c) & (1<<1))) {
+		if (!timeout--) 
+			return;
+	}
+	writel(byte, RK2818_UART1_BASE);
+	if (byte == '\n')
+		tcm_printch('\r');
+}
+
+static void __tcmlocalfunc noinline tcm_printascii(const char *s)
+{
+	while (*s) {
+		tcm_printch(*s);
+		s++;
+	}
+}
+
+static void __tcmlocalfunc noinline tcm_printhex(unsigned int hex)
+{
+	//int i = 8;
+	tcm_printch('0');
+	tcm_printch('x');
+//	while (i--) 
+}
+#endif
+
+
+
+static void __tcmfunc rk2818_pm_save_reg(unsigned int *save,unsigned int *source,int num)
+{
+	int i;
+	if(save&&source)
+	for(i=0;i<num;i++)
+	{
+		save[i]=source[i];
+	}
+		
+}
+
+static void __tcmfunc rk2818_soc_updata_scureg(unsigned int *tempdata,int regoff,int flag)
+{
+	
+	if(rk2818_soc_pm.scu_suspend&&flag)
+	{
+		rk2818_soc_pm.scu_suspend(tempdata,regoff);
+	}
+	rk2818_soc_pm.scu->reg_base_addr[regoff]=*tempdata;
+	rk2818_soc_pm.scu->reg_ctrbit|=(0x1<<regoff);
+}
+
+#if 0
+static void __tcmfunc rk2818_soc_arm_stop(void)
+{
+	unsigned int *rk2818_scu_reg=rk2818_soc_pm.scu->reg_base_addr;
+	rk2818_scu_reg[PM_SCU_MODE_CON]|=CPU_STOP_MODE;
+	rk2818_scu_reg[PM_SCU_CPUPD]=0xdeedbabe;
+
+}
+#endif
+
+static void __tcmfunc rk2818_soc_scu_suspend(void)
+{
+	unsigned int *rk2818_scu_reg=rk2818_soc_pm.scu->reg_base_addr;
+	unsigned int *tempdata=&rk2818_soc_pm.scu_reg;
+
+	
+	*tempdata= SCU_GATE0CLK_ALL_DIS&(~DIS_ARM_CLK)&(~DIS_TIMER_CLK)
+		&(~DIS_GPIO0_CLK)&(~DIS_GPIO1_CLK)&(~DIS_INTC_CLK)/*&(~DIS_UART0_CLK)&(~DIS_UART1_CLK)*/;
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_CLKGATE0_CON,1);
+	tcm_udelay(1, 24);
+
+	*tempdata=SCU_GATE1CLK_BASE_SET/*|EN_AXI_CLK&(~DIS_DDR_CLK)&(~DIS_DDR_HCLK)*/;
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_CLKGATE1_CON,1);
+	tcm_udelay(1, 24);
+
+
+      *tempdata=SCU_GATE2CLK_BASE_SET&(~DIS_ITCMBUS_CLK)&(~DIS_DTCM0BUS_CLK)&(~DIS_DTCM1BUS_CLK);
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_CLKGATE2_CON,1);
+	tcm_udelay(1, 24);
+
+	*tempdata=rk2818_scu_reg[PM_SCU_DPLL_CON] |DSPPLL_POERDOWN;    //dsp pll power down
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_DPLL_CON,1);
+	tcm_udelay(1, 24);
+
+	*tempdata=rk2818_scu_reg[PM_SCU_CPLL_CON] |CPLL_POERDOWN;    //dsp pll power down
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_CPLL_CON,1);
+	tcm_udelay(1, 24);
+
+       
+	rk2818_scu_reg[PM_SCU_PMU_CON] |=LCDC_POWER_DOWN;
+	*tempdata=rk2818_scu_reg[PM_SCU_PMU_CON] |DSP_POWER_DOWN;
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_PMU_CON,1);
+
+
+
+	*tempdata=rk2818_scu_reg[PM_SCU_MODE_CON] &CPU_SLOW_MODE;	//general slow mode
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_MODE_CON,1);
+
+	*tempdata=rk2818_scu_reg[PM_SCU_APLL_CON] |ARMPLL_BYPASSMODE;//enable arm pll bypass
+	*tempdata=rk2818_scu_reg[PM_SCU_APLL_CON] | ARMPLL_POERDOWN;	//arm pll power down
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_APLL_CON,1);
+	tcm_udelay(2, 24);
+
+	*tempdata=(rk2818_scu_reg[PM_SCU_CLKSEL0_CON]&PM_BIT_CLEAR(CLKSEL0_HCLK,2)&PM_BIT_CLEAR(CLKSEL0_PCLK,2))
+		|PM_BIT_SET(CLKSEL0_HCLK,CLK_ARM1_H1,2)|PM_BIT_SET(CLKSEL0_PCLK,CLK_HCLK1_P1,2);
+	rk2818_soc_updata_scureg(tempdata,PM_SCU_CLKSEL0_CON,1);
+	tcm_udelay(2, 24);
+
+	
+	*tempdata=(rk2818_scu_reg[PM_CLKSEL2_CON]&(~0xf))|0xF;
+	rk2818_soc_updata_scureg(tempdata,PM_CLKSEL2_CON,1);
+
+	tcm_udelay(2, 24);
+
+	//*tempdata=rk2818_scu_reg[PM_SCU_PMU_CON] |DDR_POWER_DOWN;
+	//rk2818_soc_updata_scureg(tempdata,PM_SCU_PMU_CON,0);
+
+
+	//*tempdata=rk2818_scu_reg[PM_SCU_SOFTRST_CON]|(1<<RST_DDR_BUS)|(1<<RST_DDR_CORE_LOGIC);//RST_ALL&(~(1<<RST_ARM));
+	//rk2818_soc_updata_scureg(tempdata,PM_SCU_SOFTRST_CON,1);
+}
+
+
+
+#if 0
+
+
+static void __tcmfunc rk2818_soc_general_reg_suspend(void)
+{
+	struct rk2818_pm_soc_st *general=rk2818_soc_pm.general;
+	struct rk2818_pm_soc_st *gpio0=rk2818_soc_pm.gpio0;
+	struct rk2818_pm_soc_st *gpio1=rk2818_soc_pm.gpio1;
+
+	unsigned int *rk2818_general_reg=general->reg_ch;
+	unsigned int *rk2818_gpio0_reg=gpio0->reg_ch;
+	unsigned int *rk2818_gpio1_reg=gpio1->reg_ch;
+
+	int i;
+
+	#if 1
+	general->reg_ctrbit|=(0x1<<PM_GPIO0_AB_PU_CON);
+	rk2818_general_reg[PM_GPIO0_AB_PU_CON] =GPIO0_AB_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO0_CD_PU_CON);
+	rk2818_general_reg[PM_GPIO0_CD_PU_CON] = GPIO0_CD_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO1_AB_PU_CON);
+	rk2818_general_reg[PM_GPIO1_AB_PU_CON] = GPIO1_AB_NORMAL;
+	
+	general->reg_ctrbit|=(0x1<<PM_GPIO1_CD_PU_CON);
+	rk2818_general_reg[PM_GPIO1_CD_PU_CON] = GPIO1_CD_NORMAL;
+	#endif
+	general->reg_ctrbit|=(0x1<<PM_IOMUX_A_CON);
+	general->reg_ctrbit|=(0x1<<PM_IOMUX_B_CON);
+
+	if(rk2818_soc_pm.general_reg_callback)
+	{
+		rk2818_soc_pm.general_reg_callback(general->reg_ch);
+	}
+
+	rk2818_pm_save_reg(general->reg_base_addr,general->reg_ch,general->reg_num);
+
+	rk2818_pm_save_reg(gpio0->reg_base_addr,gpio0->reg_ch,gpio0->reg_num);
+	rk2818_pm_save_reg(gpio1->reg_base_addr,gpio1->reg_ch,gpio1->reg_num);
+
+}
+#endif
+static void rk2818_pm_reg_print(unsigned int *pm_save_reg,unsigned int *pm_ch_reg,int num,char *name)
+{
+
+	 int i;
+
+#ifdef RK2818_PM_PRT_ORIGINAL_REG
+	printk("***the follow inf is %s original reg***\n",name);
+	for(i=0;i<num;i++)
+	{
+	    printk(" %d,%x",i,pm_save_reg[i]);
+	}
+	printk("\n");
+#endif
+
+#ifdef RK2818_PM_PRT_CHANGED_REG
+	printk("***the follow inf is %s changed reg***\n",name);
+	for(i=0;i<num;i++)
+	{
+	    printk(" %d,%x",i,pm_ch_reg[i]);
+	}
+	printk("\n");
+#endif
+}
+static void __tcmfunc rk2818_soc_resume(unsigned int *pm_save_reg,unsigned int *base_add,u16 regbit,int num)
+{
+	int i;
+	for(i=0;i<num;i++)
+	{
+	       if((regbit>>i)&0x0001)
+		base_add[i]=pm_save_reg[i];
+	}
+}
+void __tcmfunc rk2818_socpm_suspend(void)
+{
+	tcm_udelay(1, 24); //DRVDelayUs(100); 
+	rk2818_soc_scu_suspend();
+	tcm_udelay(1, 24); //DRVDelayUs(100); 
+	
+	if(rk2818_soc_pm.general_reg_suspend)
+	{
+		rk2818_soc_pm.general_reg_suspend();
+	}
+#ifdef RK2818_PM_PRT_CHANGED_REG
+
+	rk2818_pm_save_reg(rk2818_soc_pm.scu->reg_ch,rk2818_soc_pm.scu->reg_base_addr,
+	rk2818_soc_pm.scu->reg_num);
+
+	rk2818_pm_save_reg(rk2818_soc_pm.general->reg_ch,rk2818_soc_pm.general->reg_base_addr,
+	rk2818_soc_pm.general->reg_num);
+
+	rk2818_pm_save_reg(rk2818_soc_pm.gpio0->reg_ch,rk2818_soc_pm.gpio0->reg_base_addr,
+	rk2818_soc_pm.gpio0->reg_num);
+	
+	rk2818_pm_save_reg(rk2818_soc_pm.gpio1->reg_ch,rk2818_soc_pm.gpio1->reg_base_addr,
+	rk2818_soc_pm.gpio1->reg_num);
+#endif
+	//rk2818_soc_arm_stop();
+		
+}
+void __tcmfunc rk2818_socpm_resume(void)
+{
+		tcm_udelay(1, 24); //DRVDelayUs(100); 
+		rk2818_soc_resume(rk2818_soc_pm.scu->reg_save,rk2818_soc_pm.scu->reg_base_addr,
+			rk2818_soc_pm.scu->reg_ctrbit,rk2818_soc_pm.scu->reg_num);
+		tcm_udelay(2, 24);
+		if(rk2818_soc_pm.general_reg_suspend)
+		{
+
+			rk2818_soc_resume(rk2818_soc_pm.general->reg_save,rk2818_soc_pm.general->reg_base_addr,
+				rk2818_soc_pm.general->reg_ctrbit,rk2818_soc_pm.general->reg_num);
+
+			rk2818_soc_resume(rk2818_soc_pm.gpio0->reg_save,rk2818_soc_pm.gpio0->reg_base_addr,
+				rk2818_soc_pm.gpio0->reg_ctrbit,rk2818_soc_pm.gpio0->reg_num);
+			
+			rk2818_soc_resume(rk2818_soc_pm.gpio1->reg_save,rk2818_soc_pm.gpio1->reg_base_addr,
+				rk2818_soc_pm.gpio1->reg_ctrbit,rk2818_soc_pm.gpio1->reg_num);
+		}
+
+	}
+
+void __tcmfunc rk2818_socpm_suspend_first(void)
+{
+	tcm_udelay(1, 24);
+	rk2818_pm_save_reg(rk2818_soc_pm.scu->reg_save,rk2818_soc_pm.scu->reg_base_addr,rk2818_soc_pm.scu->reg_num);
+	//rk2818_pm_save_reg(rk2818_soc_pm.scu_tempreg,rk2818_soc_pm.scu->reg_base_addr,rk2818_soc_pm.scu->reg_num);
+
+	rk2818_pm_save_reg(rk2818_soc_pm.general->reg_save,rk2818_soc_pm.general->reg_base_addr,rk2818_soc_pm.general->reg_num);
+	rk2818_pm_save_reg(rk2818_soc_pm.gpio0->reg_save,rk2818_soc_pm.gpio0->reg_base_addr,rk2818_soc_pm.gpio0->reg_num);
+	rk2818_pm_save_reg(rk2818_soc_pm.gpio1->reg_save,rk2818_soc_pm.gpio1->reg_base_addr,rk2818_soc_pm.gpio1->reg_num);
+	rk2818_soc_pm.scu->reg_ctrbit=0;
+	rk2818_soc_pm.general->reg_ctrbit=0;
+	rk2818_soc_pm.gpio0->reg_ctrbit=0x6db;
+	rk2818_soc_pm.gpio1->reg_ctrbit=0x6db;
+	
+	//rk2818_soc_pm.save_reg[0]=rk2818_ddr_reg[82];
+	//rk2818_ddr_reg[82]=rk2818_ddr_reg[82]&(~(0xffff))&(~(0xf<<20));
+	
+		if(rk2818_soc_pm.set_suspendvol)
+			rk2818_soc_pm.set_suspendvol();
+
+
+}
+
+void __tcmfunc rk2818_socpm_resume_first(void)
+{
+	//unsigned int *rk2818_ddr_reg=(unsigned int *)RK2818_SDRAMC_BASE;
+		if(rk2818_soc_pm.resume_vol)
+			rk2818_soc_pm.resume_vol();
+
+}
+
+
+void rk2818_socpm_print(void)
+{
+	rk2818_pm_reg_print(rk2818_soc_pm.scu->reg_save,rk2818_soc_pm.scu->reg_ch,
+		rk2818_soc_pm.scu->reg_num,"scu");
+	rk2818_pm_reg_print(rk2818_soc_pm.general->reg_save,rk2818_soc_pm.general->reg_ch,
+		rk2818_soc_pm.general->reg_num,"general_general");
+	rk2818_pm_reg_print(rk2818_soc_pm.gpio0->reg_save,rk2818_soc_pm.gpio0->reg_ch,
+		rk2818_soc_pm.gpio0->reg_num,"gpio0");
+	rk2818_pm_reg_print(rk2818_soc_pm.gpio1->reg_save,rk2818_soc_pm.gpio1->reg_ch,
+		rk2818_soc_pm.gpio1->reg_num,"gpio1");
+}
+
+
+
+void rk2818_socpm_int(pm_scu_suspend scu,pm_general_reg_suspend general,
+	pm_set_suspendvol setvol,pm_resume_vol resumevol)
+{
+		rk2818_soc_pm.scu_suspend=scu;
+		rk2818_soc_pm.general_reg_suspend=general;
+		rk2818_soc_pm.set_suspendvol=setvol;
+		rk2818_soc_pm.resume_vol=resumevol;
+
+}
+
+
+
+
+
+
+#if defined (CONFIG_RK2818_SOC_PM_DBG)
+
+static bool check_attr_dbg_value(struct rk2818_pm_attr_dbg_st *attr)
+{
+	if((attr->flag!=PM_DBG_SET_ONCE)&&(attr->flag!=PM_DBG_SET_ALWAY))
+		return false;
+	if(attr->bitsnum==0||attr->bitsnum>32)
+		return false;
+
+	if(attr->regbits_off>31)
+		return false;
+	if((attr->regbits_off+attr->bitsnum)>32)
+		return false;
+
+	return true;
+}
+
+
+#if 0
+static void setreg_form_socpm_attr(unsigned int *reg,int regoff,struct rk2818_pm_soc_st *soc)
+{
+	struct rk2818_pm_attr_dbg_st *attr=soc->attr_dbg;
+	int i;
+	for(i=0;i<soc->attr_num;i++)
+	{
+	
+		if(check_attr_dbg_value(attr))
+		{
+			if(attr->regoff==regoff)
+			{
+
+				*reg=(*reg)&PM_BIT_CLEAR(attr->regbits_off,attr->bitsnum)|PM_BIT_SET(attr->regbits_off,attr->value,attr->bitsnum);
+
+			}
+		}
+	}
+
+}
+
+static void rk2818_socpm_attr_int(void)
+{
+	struct rk2818_pm_soc_st *scu=rk2818_soc_pm.scu;
+	struct rk2818_pm_soc_st *general=rk2818_soc_pm.general;
+	struct rk2818_pm_soc_st *gpio0=rk2818_soc_pm.gpio0;
+	struct rk2818_pm_soc_st *gpio1=rk2818_soc_pm.gpio1;
+
+
+
+	memset(scu->attr_dbg,0,sizeof(struct rk2818_pm_attr_dbg_st)*scu->attr_num);
+	memset(general->attr_dbg,0,sizeof(struct rk2818_pm_attr_dbg_st)*general->attr_num);
+	memset(gpio0->attr_dbg,0,sizeof(struct rk2818_pm_attr_dbg_st)*gpio0->attr_num);
+	memset(gpio1->attr_dbg,0,sizeof(struct rk2818_pm_attr_dbg_st)*gpio1->attr_num);
+}
+
+#endif
+static u32 rk2818_socpm_attr_atoh(const unsigned char *in, unsigned int len)
+{
+	u32 sum = 0;
+	unsigned int mult = 1;
+	unsigned char c;
+
+	while (len) {
+		c = in[len - 1];
+		if ((c >= '0') && (c <= '9'))
+			sum += mult * (c - '0');
+		else if ((c >= 'A') && (c <= 'F'))
+			sum += mult * (c - ('A' - 10));
+		else if ((c >= 'a') && (c <= 'f'))
+			sum += mult * (c - ('a' - 10));
+		mult *= 16;
+		--len;
+	}
+	return sum;
+}
+
+
+static bool rk2818_socpm_attr_is_number(char *p)
+{
+	if((*p>='0'&&*p<='9')||(*p>='a'&&*p<='f')||(*p>='A'&&*p<='F'))
+		return true;
+	else
+		return false;
+
+}
+
+#if 0
+static bool rk2818_socpm_attr_check_value(unsigned int *info)
+{
+	if((info[PM_DBG_USER_FLAG]!=PM_DBG_SET_ONCE)&&(info[PM_DBG_USER_FLAG]!=PM_DBG_SET_ALWAY))
+		return false;
+	if(info[PM_DBG_USER_BITS_NUM]==0||info[PM_DBG_USER_BITS_NUM]>32)
+		return false;
+	if((info[PM_DBG_USER_BITS_NUM]+info[PM_DBG_USER_BITS_OFF])>31)
+		return false;
+
+	return true;
+}
+#endif
+
+static bool rk2818_socpm_attr_reset_samesituation(struct rk2818_pm_attr_dbg_st *dbg,int num,unsigned int *info)
+{
+
+	int i;
+	for (i=0;i<num;i++)
+	{
+
+		if((dbg[i].regoff==info[PM_DBG_USER_REGOFF])&&
+			((dbg[i].regbits_off==info[PM_DBG_USER_BITS_OFF])))
+		{
+
+			dbg[i].value=info[PM_DBG_USER_VALUE];
+			dbg[i].bitsnum=info[PM_DBG_USER_BITS_NUM];
+			dbg[i].flag=info[PM_DBG_USER_FLAG];
+				
+				return true;
+		}
+	}
+	return false;
+}
+
+
+static bool rk2818_socpm_attr_set_value(struct rk2818_pm_attr_dbg_st *attr_dbg,int num,unsigned int *info)
+{
+	int i;
+	if(rk2818_socpm_attr_reset_samesituation(attr_dbg,num,info))
+		return true;
+	for (i=0;i<num;i++)
+	{
+
+		if(attr_dbg[i].flag==PM_DBG_NOT_SET)
+		{
+			attr_dbg[i].regoff=info[PM_DBG_USER_REGOFF];
+			attr_dbg[i].regbits_off=info[PM_DBG_USER_BITS_OFF];
+			attr_dbg[i].value=info[PM_DBG_USER_VALUE];
+			attr_dbg[i].bitsnum=info[PM_DBG_USER_BITS_NUM];
+			attr_dbg[i].flag=info[PM_DBG_USER_FLAG];
+			return true;
+		}
+	}
+	return false;
+}
+
+static bool rk2818_socpm_attr_parse_settinginf(struct rk2818_pm_soc_st *socpm,const char *buf, size_t n)
+{
+	const char *p=buf;
+	char *e;
+	//int len;
+ 	int i=0;
+	unsigned int info[PM_DBG_USER_END];//regoff bitsoff value bitsnum user once
+ 	//int oneline=-1;
+	
+	printk("3x pm dbg %s\n",p);
+
+	memset(&info[0],0,4*PM_DBG_USER_END);
+
+
+	for(;p<(buf+n);p++)
+	{
+		if(*p=='s'||*p=='S')
+		{
+			if(*p!=' ')
+			continue;
+			
+			while(*p==' ')
+			{
+				if(p>=(buf+n))
+					return true;
+				p++;
+			}
+			for(i=0;i<PM_DBG_USER_END;)
+			{
+				if(rk2818_socpm_attr_is_number((char*)p))
+				{
+					e= memchr(p, ' ', n-(p-buf));
+					if(e==NULL)
+					{
+						return true;
+					}
+					if(e>=(buf+n))
+						return true;
+					info[i]=rk2818_socpm_attr_atoh(p,e-p);
+					i++;
+					p=e;
+					if(i==(PM_DBG_USER_END-1))
+					{
+						if(rk2818_socpm_attr_set_value(socpm->attr_dbg,socpm->attr_num,&info[0])==true)
+							return true;
+
+						printk("value is%x, regoff is%x bitsoff is%x bitsnum is%x ctr is%x\n",  
+						info[PM_DBG_USER_VALUE],info[PM_DBG_USER_REGOFF],info[PM_DBG_USER_BITS_OFF], 
+						info[PM_DBG_USER_BITS_NUM], info[PM_DBG_USER_FLAG]);
+
+						memset(&info[0],0,sizeof(int)*PM_DBG_USER_END);
+					}
+				}
+				else
+				{
+					if((*p==' '))
+					{
+						while(*p==' ')
+						{
+							if(p>=(buf+n))
+								return false;
+							p++;
+						}
+					continue;
+					}
+					else
+					{
+						break;
+					}
+				}
+				
+			}
+		}
+		
+	}
+	
+return true;
+}
+
+
+#if 0
+static char * rk2818_socpm_attr_show_userinfo(struct rk2818_pm_soc_st *socpm,unsigned char regoff,char *buf)
+{
+	int i;
+	struct rk2818_pm_attr_dbg_st *attr_dbg;
+	for(i=0;i<socpm->attr_num;i++)
+	{
+		if((attr_dbg[i].regoff==regoff)&&(attr_dbg[i].flag!=PM_ATTR_NO_CTR)&&attr_dbg[i].bitsnum)
+			buf += sprintf(buf, "value is%x, regoff is%x bitsoff is%x bitsnum is%x ctr is%x\n",  
+			attr_dbg[i].value,attr_dbg[i].regoff,attr_dbg[i].regbits_off, attr_dbg[i].bitsnum, attr_dbg[i].flag);
+	}
+
+	return buf;
+
+
+}
+
+static ssize_t rk2818_socpm_attr_show_info(struct rk2818_pm_soc_st *socpm,char *name,char *buf)
+{
+
+	char *s = buf;
+	int i;
+	s += sprintf(s, "this is the %s reg value,when system enter suspend lately\n",name);
+	for(i=0;i<socpm->reg_num;i++)
+	{
+		s += sprintf(s, "reg[%d] is %x,user seting is in follow\n", i,socpm->reg_ch[i]);
+		s=rk2818_socpm_attr_show_userinfo(socpm,s,i);
+
+	}
+	
+	if (s != buf)
+		/* convert the last space to a newline */
+		*(s-1) = '\n';
+	return (s - buf);
+
+
+}
+
+
+ssize_t rk2818_socpm_attr_show(int type,char *buf)
+{
+	struct rk2818_pm_soc_st *socpm;
+	char name[4][8]={"scu","general","gpio0","gpio1"};
+
+	switch(type)
+	{
+		case 0:
+			socpm=rk2818_soc_pm.scu;
+		break;
+		case 1:
+			socpm=rk2818_soc_pm.general;
+		break;
+			case 2:
+			socpm=rk2818_soc_pm.gpio0;
+		break;
+			case 3:
+			socpm=rk2818_soc_pm.gpio1;
+		break;
+		default:
+			return false;
+
+
+
+	}
+	return rk2818_socpm_attr_show_info(socpm,name[type],buf);
+	
+}
+#endif
+
+
+
+bool rk2818_socpm_attr_store(int type,const char *buf, size_t n)
+{
+	struct rk2818_pm_soc_st *socpm;
+
+	switch(type)
+	{
+		case 0:
+			socpm=rk2818_soc_pm.scu;
+		break;
+		case 1:
+			socpm=rk2818_soc_pm.general;
+		break;
+			case 2:
+			socpm=rk2818_soc_pm.gpio0;
+		break;
+			case 3:
+			socpm=rk2818_soc_pm.gpio1;
+		break;
+		default:
+			return false;
+
+
+
+	}
+	return rk2818_socpm_attr_parse_settinginf(socpm,buf,n);
+	
+}
+#endif
+
+#if 0
+void rk2818_pm_updata_scu_reg(int regoff)
+{
+	if(0)//(rk2818_soc_pm.scu_suspend)
+	{
+		rk2818_soc_pm.scu_suspend(rk2818_soc_pm.scu_tempreg[regoff],regoff);
+	}
+	rk2818_soc_pm.scu->reg_base_addr[regoff]=rk2818_soc_pm.scu_tempreg[regoff];
+	rk2818_soc_pm.scu->reg_ctrbit|=(0x1<<regoff);
+		tcm_printascii("3x scu");
+
+}
+
+static void __tcmfunc rk2818_soc_scu_suspend(void)
+{
+	//unsigned int *rk2818_scu_reg=scu->reg_base_addr;
+	unsigned int *rk2818_scu_reg=rk2818_soc_pm.scu_tempreg;
+
+
+		
+	rk2818_scu_reg[PM_SCU_CLKGATE0_CON] = SCU_GATE0CLK_ALL_DIS&(~DIS_ARM_CLK)&(~DIS_TIMER_CLK)
+		&(~DIS_GPIO0_CLK)&(~DIS_GPIO1_CLK)&(~DIS_INTC_CLK)/*&(~DIS_UART0_CLK)&(~DIS_UART1_CLK)*/;
+	rk2818_pm_updata_scu_reg(PM_SCU_CLKGATE0_CON);
+	
+	rk2818_scu_reg[PM_SCU_CLKGATE1_CON] =SCU_GATE1CLK_BASE_SET/*|EN_AXI_CLK&(~DIS_DDR_CLK)&(~DIS_DDR_HCLK)*/;
+	rk2818_pm_updata_scu_reg(PM_SCU_CLKGATE1_CON);
+
+
+        rk2818_scu_reg[PM_SCU_CLKGATE2_CON] =SCU_GATE2CLK_BASE_SET&(~DIS_ITCMBUS_CLK)&(~DIS_DTCM0BUS_CLK)&(~DIS_DTCM1BUS_CLK);
+	rk2818_pm_updata_scu_reg(PM_SCU_CLKGATE2_CON);
+
+
+
+	rk2818_scu_reg[PM_SCU_CLKSEL0_CON]&=PM_BIT_CLEAR(CLKSEL0_HCLK,2)&PM_BIT_CLEAR(CLKSEL0_PCLK,2)
+		|PM_BIT_SET(CLKSEL0_HCLK,CLK_ARM1_H1,2)|PM_BIT_SET(CLKSEL0_PCLK,CLK_HCLK1_P1,2);
+	rk2818_pm_updata_scu_reg(PM_SCU_CLKSEL0_CON);
+
+	rk2818_scu_reg[PM_SCU_DPLL_CON] |= DSPPLL_POERDOWN;    //dsp pll power down
+	rk2818_pm_updata_scu_reg(PM_SCU_DPLL_CON);
+	
+	rk2818_scu_reg[PM_SCU_CPLL_CON] |= CPLL_POERDOWN;    //dsp pll power down
+	rk2818_pm_updata_scu_reg(PM_SCU_CPLL_CON);
+
+	rk2818_scu_reg[PM_SCU_PMU_CON] |=LCDC_POWER_DOWN;
+	rk2818_scu_reg[PM_SCU_PMU_CON] |=DSP_POWER_DOWN;
+	
+	
+		rk2818_scu_reg[PM_SCU_MODE_CON] &= CPU_SLOW_MODE;	//general slow mode
+	rk2818_pm_updata_scu_reg(PM_SCU_MODE_CON);
+
+	rk2818_scu_reg[PM_SCU_APLL_CON] |= ARMPLL_BYPASSMODE;//enable arm pll bypass
+	rk2818_scu_reg[PM_SCU_APLL_CON] |= ARMPLL_POERDOWN;	//arm pll power down
+	rk2818_pm_updata_scu_reg(PM_SCU_APLL_CON);
+	
+	rk2818_scu_reg[PM_CLKSEL2_CON] =(rk2818_scu_reg[PM_CLKSEL2_CON]&(~0xf))|0xF;
+	rk2818_pm_updata_scu_reg(PM_CLKSEL2_CON);
+
+
+
+
+
+	rk2818_pm_updata_scu_reg(PM_SCU_PMU_CON);
+	//rk2818_scu_reg[PM_SCU_PMU_CON] |=DDR_POWER_DOWN;
+	//rk2818_pm_updata_scu_reg(PM_SCU_PMU_CON);
+
+	//scu->reg_ctrbit|=(0x1<<PM_SCU_SOFTRST_CON);
+	//rk2818_scu_reg[PM_SCU_SOFTRST_CON]|=(1<<RST_DDR_BUS)|(1<<RST_DDR_CORE_LOGIC);//RST_ALL&(~(1<<RST_ARM));
+	//rk2818_pm_updata_scu_reg(PM_SCU_SOFTRST_CON);
+}
+#endif
+
-- 
2.35.3

