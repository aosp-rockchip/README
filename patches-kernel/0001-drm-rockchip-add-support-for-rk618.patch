From 6d51582d571167a84f8cd70545260fd401028924 Mon Sep 17 00:00:00 2001
From: Wyon Bi <bivvy.bi@rock-chips.com>
Date: Fri, 1 Dec 2017 15:58:32 +0800
Subject: [PATCH] drm/rockchip: add support for rk618

RK618 provides a complete set of display interface to support
very flexible applications as follows:
- 2 RGB display input interface with double data rate
- 1 LVDS display output interface with double channels
- 1 MIPI display output interface with 4 data lanes
- 1 HDMI display output interface
- 1 RGB display output interface shared with LVDS
- 1 RGB display output interface shared with RGB display input interface

VIF is used to LCDC SDR/DDR timing reconstruction.

SCALER is a synchronous parallel RGB frame converter for different
resolution. It is used to realize dual display function from
one display source. It can be used like VIF for LCDC SDR timing
reconstruction only.

DITHER is used for converting 24bit RGB888 to 18bit RGB666 with FRC
dither down.

Change-Id: I5b25e64c283bd84f85d7d7686bee6d940df44910
Signed-off-by: Wyon Bi <bivvy.bi@rock-chips.com>
---
 .../display/rockchip/rockchip,rk618.txt       |  61 ++++
 drivers/gpu/drm/rockchip/Kconfig              |   2 +
 drivers/gpu/drm/rockchip/Makefile             |   1 +
 drivers/gpu/drm/rockchip/rk618/Kconfig        |   9 +
 drivers/gpu/drm/rockchip/rk618/Makefile       |  10 +
 drivers/gpu/drm/rockchip/rk618/rk618_dither.c |  45 +++
 drivers/gpu/drm/rockchip/rk618/rk618_lvds.c   | 220 ++++++++++++
 drivers/gpu/drm/rockchip/rk618/rk618_output.c | 339 ++++++++++++++++++
 drivers/gpu/drm/rockchip/rk618/rk618_output.h | 151 ++++++++
 drivers/gpu/drm/rockchip/rk618/rk618_scaler.c | 228 ++++++++++++
 drivers/gpu/drm/rockchip/rk618/rk618_vif.c    |  93 +++++
 11 files changed, 1159 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/display/rockchip/rockchip,rk618.txt
 create mode 100644 drivers/gpu/drm/rockchip/rk618/Kconfig
 create mode 100644 drivers/gpu/drm/rockchip/rk618/Makefile
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_dither.c
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_lvds.c
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_output.c
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_output.h
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_scaler.c
 create mode 100644 drivers/gpu/drm/rockchip/rk618/rk618_vif.c

diff --git a/Documentation/devicetree/bindings/display/rockchip/rockchip,rk618.txt b/Documentation/devicetree/bindings/display/rockchip/rockchip,rk618.txt
new file mode 100644
index 000000000000..7a38b0826e48
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/rockchip/rockchip,rk618.txt
@@ -0,0 +1,61 @@
+Rockchip RK618 display bridge bindings
+======================================
+
+LVDS Encoder
+------------
+
+Required properties:
+- compatible: value should be one of the following:
+   "rockchip,rk618-lvds"
+- clocks: must include clock specifiers corresponding to entries in the
+	  clock-names property.
+	  See ../clocks/clock-bindings.txt for details.
+- clock-names: list of clock names sorted in the same order as the clocks
+	       property. Must contain "lvds", "dither", "vif", "scaler".
+
+The LVDS has two video ports. Their connections are modeled using the OF
+graph bindings specified in Documentation/devicetree/bindings/graph.txt.
+
+- Video port 0 for DPI input
+- Video port 1 for LVDS output
+
+&rk618 {
+	status = "okay";
+
+	lvds {
+		compatible = "rockchip,rk618-lvds";
+		clocks = <&CRU LVDS_CLK>, <&CRU DITHER_CLK>,
+			 <&CRU VIF0_CLK>, <&CRU SCALER_CLK>;
+		clock-names = "lvds", "dither", "vif", "scaler";
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				lvds_input_vop: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vop_output_lvds>;
+				};
+
+				lvds_input_bridge: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&hdmi_output_bridge>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				lvds_output_panel: endpoint {
+					remote-endpoint = <&panel_input_lvds>;
+				};
+			};
+		};
+	};
+};
diff --git a/drivers/gpu/drm/rockchip/Kconfig b/drivers/gpu/drm/rockchip/Kconfig
index a1627d3e60e5..d9950333cdd7 100644
--- a/drivers/gpu/drm/rockchip/Kconfig
+++ b/drivers/gpu/drm/rockchip/Kconfig
@@ -106,3 +106,5 @@ config ROCKCHIP_RK3066_HDMI
 	  This selects support for Rockchip SoC specific extensions
 	  for the Innosilicon HDMI driver. If you want to enable
 	  HDMI on RK3066 based SoC, you should select this option.
+
+source "drivers/gpu/drm/rockchip/rk618/Kconfig"
diff --git a/drivers/gpu/drm/rockchip/Makefile b/drivers/gpu/drm/rockchip/Makefile
index bd41cceeb068..1aef3c0e22da 100644
--- a/drivers/gpu/drm/rockchip/Makefile
+++ b/drivers/gpu/drm/rockchip/Makefile
@@ -20,3 +20,4 @@ obj-$(CONFIG_DRM_ROCKCHIP) += rockchip_vop_reg.o rockchipdrm.o
 obj-$(CONFIG_ROCKCHIP_DRM_TVE) += rockchip_drm_tve.o
 
 obj-$(CONFIG_ROCKCHIP_RK3066_HDMI) += rk3066_hdmi.o
+obj-$(CONFIG_DRM_ROCKCHIP_RK618) += rk618/
diff --git a/drivers/gpu/drm/rockchip/rk618/Kconfig b/drivers/gpu/drm/rockchip/rk618/Kconfig
new file mode 100644
index 000000000000..02e7fcb3c348
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/Kconfig
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config DRM_ROCKCHIP_RK618
+	tristate "Rockchip rk618 display bridge driver"
+	depends on DRM_ROCKCHIP
+	depends on MFD_RK618
+	select DRM_PANEL
+	---help---
+	  Rockchip rk618 display bridge chips driver.
diff --git a/drivers/gpu/drm/rockchip/rk618/Makefile b/drivers/gpu/drm/rockchip/rk618/Makefile
new file mode 100644
index 000000000000..417549328823
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Rockchip RK618 display bridge driver.
+#
+
+obj-$(CONFIG_DRM_ROCKCHIP_RK618) += rk618_output.o \
+				    rk618_scaler.o \
+				    rk618_vif.o \
+				    rk618_dither.o \
+				    rk618_lvds.o \
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_dither.c b/drivers/gpu/drm/rockchip/rk618/rk618_dither.c
new file mode 100644
index 000000000000..a7d944aa0454
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_dither.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rk618_output.h"
+
+#define RK618_FRC_REG			0x0054
+#define FRC_DEN_INV			HIWORD_UPDATE(1, 6, 6)
+#define FRC_SYNC_INV			HIWORD_UPDATE(1, 5, 5)
+#define FRC_DCLK_INV			HIWORD_UPDATE(1, 4, 4)
+#define FRC_OUT_ZERO			HIWORD_UPDATE(1, 3, 3)
+#define FRC_OUT_MODE_RGB666		HIWORD_UPDATE(1, 2, 2)
+#define FRC_OUT_MODE_RGB888		HIWORD_UPDATE(0, 2, 2)
+#define FRC_DITHER_MODE_HI_FRC		HIWORD_UPDATE(1, 1, 1)
+#define FRC_DITHER_MODE_FRC		HIWORD_UPDATE(0, 1, 1)
+#define FRC_DITHER_ENABLE		HIWORD_UPDATE(1, 0, 0)
+#define FRC_DITHER_DISABLE		HIWORD_UPDATE(0, 0, 0)
+
+void rk618_dither_disable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_FRC_REG, FRC_DITHER_DISABLE);
+}
+EXPORT_SYMBOL_GPL(rk618_dither_disable);
+
+void rk618_dither_enable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_FRC_REG, FRC_DITHER_ENABLE);
+}
+EXPORT_SYMBOL_GPL(rk618_dither_enable);
+
+void rk618_dither_frc_dclk_invert(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_FRC_REG, FRC_DCLK_INV);
+}
+EXPORT_SYMBOL_GPL(rk618_dither_frc_dclk_invert);
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_lvds.c b/drivers/gpu/drm/rockchip/rk618/rk618_lvds.c
new file mode 100644
index 000000000000..08e12c784cc3
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_lvds.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rk618_output.h"
+
+#define RK618_LVDS_CON			0x0084
+#define LVDS_CON_START_PHASE(x)		HIWORD_UPDATE(x, 14, 14)
+#define LVDS_DCLK_INV			HIWORD_UPDATE(1, 13, 13)
+#define LVDS_CON_CHADS_10PF		HIWORD_UPDATE(3, 12, 11)
+#define LVDS_CON_CHADS_5PF		HIWORD_UPDATE(2, 12, 11)
+#define LVDS_CON_CHADS_7PF		HIWORD_UPDATE(1, 12, 11)
+#define LVDS_CON_CHADS_3PF		HIWORD_UPDATE(0, 12, 11)
+#define LVDS_CON_CHA1TTL_ENABLE		HIWORD_UPDATE(1, 10, 10)
+#define LVDS_CON_CHA1TTL_DISABLE	HIWORD_UPDATE(0, 10, 10)
+#define LVDS_CON_CHA0TTL_ENABLE		HIWORD_UPDATE(1, 9, 9)
+#define LVDS_CON_CHA0TTL_DISABLE	HIWORD_UPDATE(0, 9, 9)
+#define LVDS_CON_CHA1_POWER_UP		HIWORD_UPDATE(1, 8, 8)
+#define LVDS_CON_CHA1_POWER_DOWN	HIWORD_UPDATE(0, 8, 8)
+#define LVDS_CON_CHA0_POWER_UP		HIWORD_UPDATE(1, 7, 7)
+#define LVDS_CON_CHA0_POWER_DOWN	HIWORD_UPDATE(0, 7, 7)
+#define LVDS_CON_CBG_POWER_UP		HIWORD_UPDATE(1, 6, 6)
+#define LVDS_CON_CBG_POWER_DOWN		HIWORD_UPDATE(0, 6, 6)
+#define LVDS_CON_PLL_POWER_DOWN		HIWORD_UPDATE(1, 5, 5)
+#define LVDS_CON_PLL_POWER_UP		HIWORD_UPDATE(0, 5, 5)
+#define LVDS_CON_START_SEL_EVEN_PIXEL	HIWORD_UPDATE(1, 4, 4)
+#define LVDS_CON_START_SEL_ODD_PIXEL	HIWORD_UPDATE(0, 4, 4)
+#define LVDS_CON_CHASEL_DOUBLE_CHANNEL	HIWORD_UPDATE(1, 3, 3)
+#define LVDS_CON_CHASEL_SINGLE_CHANNEL	HIWORD_UPDATE(0, 3, 3)
+#define LVDS_CON_MSBSEL_D7		HIWORD_UPDATE(1, 2, 2)
+#define LVDS_CON_MSBSEL_D0		HIWORD_UPDATE(0, 2, 2)
+#define LVDS_CON_SELECT(x)		HIWORD_UPDATE(x, 1, 0)
+#define LVDS_CON_SELECT_6BIT_MODE	HIWORD_UPDATE(3, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_3	HIWORD_UPDATE(2, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_2	HIWORD_UPDATE(1, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_1	HIWORD_UPDATE(0, 1, 0)
+
+#define IS_DOUBLE_CHANNEL(lvds)	((lvds)->channels == 2)
+
+enum {
+	LVDS_8BIT_MODE_FORMAT_1,
+	LVDS_8BIT_MODE_FORMAT_2,
+	LVDS_8BIT_MODE_FORMAT_3,
+	LVDS_6BIT_MODE,
+};
+
+struct rk618_lvds {
+	struct rk618_output base;
+	struct device *dev;
+	struct regmap *regmap;
+	struct clk *clock;
+	u32 channels;
+	u32 format;
+};
+
+static inline struct rk618_lvds *to_lvds(struct rk618_output *output)
+{
+	return container_of(output, struct rk618_lvds, base);
+}
+
+static void rk618_lvds_enable(struct rk618_output *output)
+{
+	struct rk618_lvds *lvds = to_lvds(output);
+	u32 value;
+
+	clk_prepare_enable(lvds->clock);
+
+	value = LVDS_CON_CHA0TTL_DISABLE | LVDS_CON_CHA1TTL_DISABLE |
+		LVDS_CON_CHA0_POWER_UP | LVDS_CON_CBG_POWER_UP |
+		LVDS_CON_PLL_POWER_UP | LVDS_CON_SELECT(lvds->format);
+
+	if (IS_DOUBLE_CHANNEL(lvds))
+		value |= LVDS_CON_CHA1_POWER_UP | LVDS_DCLK_INV |
+			 LVDS_CON_CHASEL_DOUBLE_CHANNEL;
+	else
+		value |= LVDS_CON_CHA1_POWER_DOWN |
+			 LVDS_CON_CHASEL_SINGLE_CHANNEL;
+
+	regmap_write(lvds->regmap, RK618_LVDS_CON, value);
+}
+
+static void rk618_lvds_disable(struct rk618_output *output)
+{
+	struct rk618_lvds *lvds = to_lvds(output);
+
+	regmap_write(lvds->regmap, RK618_LVDS_CON,
+		     LVDS_CON_CHA0_POWER_DOWN | LVDS_CON_CHA1_POWER_DOWN |
+		     LVDS_CON_CBG_POWER_DOWN | LVDS_CON_PLL_POWER_DOWN);
+
+	clk_disable_unprepare(lvds->clock);
+}
+
+static void rk618_lvds_mode_set(struct rk618_output *output,
+				const struct drm_display_mode *mode)
+{
+	struct rk618_lvds *lvds = to_lvds(output);
+
+	if (mode->hdisplay > 1366 || mode->vdisplay > 1366)
+		lvds->channels = 2;
+	else
+		lvds->channels = 1;
+
+	switch (output->bus_format) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:	/* jeida-18 */
+		lvds->format = LVDS_6BIT_MODE;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:	/* jeida-24 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:	/* vesa-24 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_1;
+		break;
+	default:
+		lvds->format = LVDS_8BIT_MODE_FORMAT_3;
+		break;
+	}
+}
+
+static const struct rk618_output_funcs rk618_lvds_funcs = {
+	.enable = rk618_lvds_enable,
+	.disable = rk618_lvds_disable,
+	.mode_set = rk618_lvds_mode_set,
+};
+
+static int rk618_lvds_bind(struct device *dev, struct device *master,
+			   void *data)
+{
+	struct drm_device *drm = data;
+	struct rk618_lvds *lvds = dev_get_drvdata(dev);
+
+	return rk618_output_bind(&lvds->base, drm, DRM_MODE_ENCODER_LVDS,
+				 DRM_MODE_CONNECTOR_LVDS);
+}
+
+static void rk618_lvds_unbind(struct device *dev, struct device *master,
+			      void *data)
+{
+	struct rk618_lvds *lvds = dev_get_drvdata(dev);
+
+	rk618_output_unbind(&lvds->base);
+}
+
+static const struct component_ops rk618_lvds_component_ops = {
+	.bind = rk618_lvds_bind,
+	.unbind = rk618_lvds_unbind,
+};
+
+static int rk618_lvds_probe(struct platform_device *pdev)
+{
+	struct rk618 *rk618 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct rk618_lvds *lvds;
+	int ret;
+
+	if (!of_device_is_available(dev->of_node))
+		return -ENODEV;
+
+	lvds = devm_kzalloc(dev, sizeof(*lvds), GFP_KERNEL);
+	if (!lvds)
+		return -ENOMEM;
+
+	lvds->dev = dev;
+	lvds->regmap = rk618->regmap;
+	platform_set_drvdata(pdev, lvds);
+
+	lvds->clock = devm_clk_get(dev, "lvds");
+	if (IS_ERR(lvds->clock)) {
+		ret = PTR_ERR(lvds->clock);
+		dev_err(dev, "failed to get lvds clock: %d\n", ret);
+		return ret;
+	}
+
+	lvds->base.parent = rk618;
+	lvds->base.dev = dev;
+	lvds->base.funcs = &rk618_lvds_funcs;
+	ret = rk618_output_register(&lvds->base);
+	if (ret)
+		return ret;
+
+	return component_add(dev, &rk618_lvds_component_ops);
+}
+
+static int rk618_lvds_remove(struct platform_device *pdev)
+{
+	struct rk618_lvds *lvds = platform_get_drvdata(pdev);
+
+	component_del(lvds->dev, &rk618_lvds_component_ops);
+
+	return 0;
+}
+
+static const struct of_device_id rk618_lvds_of_match[] = {
+	{ .compatible = "rockchip,rk618-lvds", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk618_lvds_of_match);
+
+static struct platform_driver rk618_lvds_driver = {
+	.driver = {
+		.name = "rk618-lvds",
+		.of_match_table = of_match_ptr(rk618_lvds_of_match),
+	},
+	.probe = rk618_lvds_probe,
+	.remove = rk618_lvds_remove,
+};
+module_platform_driver(rk618_lvds_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip RK618 LVDS driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_output.c b/drivers/gpu/drm/rockchip/rk618/rk618_output.c
new file mode 100644
index 000000000000..503425b894f3
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_output.c
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rk618_output.h"
+
+static inline struct rk618_output *encoder_to_output(struct drm_encoder *e)
+{
+	return container_of(e, struct rk618_output, encoder);
+}
+
+static inline
+struct rk618_output *connector_to_output(struct drm_connector *c)
+{
+	return container_of(c, struct rk618_output, connector);
+}
+
+static inline struct rk618_output *bridge_to_output(struct drm_bridge *b)
+{
+	return container_of(b, struct rk618_output, bridge);
+}
+
+static struct drm_encoder *
+rk618_output_connector_best_encoder(struct drm_connector *connector)
+{
+	struct rk618_output *output = connector_to_output(connector);
+
+	return &output->encoder;
+}
+
+static int rk618_output_connector_get_modes(struct drm_connector *connector)
+{
+	struct rk618_output *output = connector_to_output(connector);
+	struct drm_display_info *info = &connector->display_info;
+	struct drm_display_mode *mode;
+	int num_modes;
+
+	num_modes = drm_panel_get_modes(output->panel);
+
+	list_for_each_entry(mode, &connector->probed_modes, head) {
+		if (mode->type & DRM_MODE_TYPE_PREFERRED)
+			drm_mode_copy(&output->panel_mode, mode);
+	}
+
+	if (info->num_bus_formats)
+		output->bus_format = info->bus_formats[0];
+
+	return num_modes;
+}
+
+static const struct drm_connector_helper_funcs
+rk618_output_connector_helper_funcs = {
+	.get_modes = rk618_output_connector_get_modes,
+	.best_encoder = rk618_output_connector_best_encoder,
+};
+
+static enum drm_connector_status
+rk618_output_connector_detect(struct drm_connector *connector, bool force)
+{
+	return connector_status_connected;
+}
+
+static void rk618_output_connector_destroy(struct drm_connector *connector)
+{
+	struct rk618_output *output = connector_to_output(connector);
+
+	drm_panel_detach(output->panel);
+	drm_connector_cleanup(connector);
+}
+
+static const struct drm_connector_funcs rk618_output_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.detect = rk618_output_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = rk618_output_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static void rk618_output_encoder_enable(struct drm_encoder *encoder)
+{
+	struct rk618_output *output = encoder_to_output(encoder);
+
+	rk618_dither_frc_dclk_invert(output->parent);
+
+	clk_set_parent(output->dither_clk, output->vif_clk);
+
+	if (output->funcs->pre_enable)
+		output->funcs->pre_enable(output);
+
+	drm_panel_prepare(output->panel);
+
+	if (output->funcs->enable)
+		output->funcs->enable(output);
+
+	drm_panel_enable(output->panel);
+}
+
+static void rk618_output_encoder_disable(struct drm_encoder *encoder)
+{
+	struct rk618_output *output = encoder_to_output(encoder);
+
+	drm_panel_disable(output->panel);
+
+	if (output->funcs->disable)
+		output->funcs->disable(output);
+
+	drm_panel_unprepare(output->panel);
+
+	if (output->funcs->post_disable)
+		output->funcs->post_disable(output);
+}
+
+static void rk618_output_encoder_mode_set(struct drm_encoder *encoder,
+					  struct drm_display_mode *mode,
+					  struct drm_display_mode *adjusted)
+{
+	struct rk618_output *output = encoder_to_output(encoder);
+
+	drm_mode_copy(&output->panel_mode, adjusted);
+
+	if (output->funcs->mode_set)
+		output->funcs->mode_set(output, adjusted);
+}
+
+static int
+rk618_output_encoder_atomic_check(struct drm_encoder *encoder,
+				  struct drm_crtc_state *crtc_state,
+				  struct drm_connector_state *conn_state)
+{
+	struct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);
+
+	s->output_mode = ROCKCHIP_OUT_MODE_P888;
+	s->output_type = DRM_MODE_CONNECTOR_LVDS;
+
+	return 0;
+}
+
+static const struct drm_encoder_helper_funcs
+rk618_output_encoder_helper_funcs = {
+	.enable = rk618_output_encoder_enable,
+	.disable = rk618_output_encoder_disable,
+	.mode_set = rk618_output_encoder_mode_set,
+	.atomic_check = rk618_output_encoder_atomic_check,
+};
+
+static const struct drm_encoder_funcs rk618_output_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static void rk618_output_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct rk618_output *output = bridge_to_output(bridge);
+	const struct drm_display_mode *src = &output->scale_mode;
+	const struct drm_display_mode *dst = &output->panel_mode;
+	unsigned long sclk_rate, dclk_rate = src->clock * 1000;
+	long rate;
+
+	sclk_rate = dclk_rate * dst->vdisplay * dst->htotal;
+	do_div(sclk_rate, src->vdisplay * src->htotal);
+
+	dev_dbg(output->dev, "dclk rate: %ld, sclk rate: %ld\n",
+		dclk_rate, sclk_rate);
+
+	clk_set_parent(output->dither_clk, output->scaler_clk);
+
+	rate = clk_round_rate(output->scaler_clk, sclk_rate);
+	clk_set_rate(output->scaler_clk, rate);
+
+	clk_prepare_enable(output->scaler_clk);
+
+	rk618_scaler_configure(output->parent,
+			       &output->scale_mode, &output->panel_mode);
+	rk618_scaler_enable(output->parent);
+
+	if (output->funcs->pre_enable)
+		output->funcs->pre_enable(output);
+
+	drm_panel_prepare(output->panel);
+}
+
+static void rk618_output_bridge_enable(struct drm_bridge *bridge)
+{
+	struct rk618_output *output = bridge_to_output(bridge);
+
+	if (output->funcs->enable)
+		output->funcs->enable(output);
+
+	drm_panel_enable(output->panel);
+}
+
+static void rk618_output_bridge_disable(struct drm_bridge *bridge)
+{
+	struct rk618_output *output = bridge_to_output(bridge);
+
+	drm_panel_disable(output->panel);
+
+	if (output->funcs->disable)
+		output->funcs->disable(output);
+}
+
+static void rk618_output_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct rk618_output *output = bridge_to_output(bridge);
+
+	drm_panel_unprepare(output->panel);
+
+	if (output->funcs->post_disable)
+		output->funcs->post_disable(output);
+
+	rk618_scaler_disable(output->parent);
+	clk_disable_unprepare(output->scaler_clk);
+}
+
+static void rk618_output_bridge_mode_set(struct drm_bridge *bridge,
+					 struct drm_display_mode *mode,
+					 struct drm_display_mode *adjusted)
+{
+	struct rk618_output *output = bridge_to_output(bridge);
+
+	drm_mode_copy(&output->scale_mode, adjusted);
+
+	if (output->funcs->mode_set)
+		output->funcs->mode_set(output, &output->panel_mode);
+}
+
+static const struct drm_bridge_funcs rk618_output_bridge_funcs = {
+	.pre_enable = rk618_output_bridge_pre_enable,
+	.enable = rk618_output_bridge_enable,
+	.disable = rk618_output_bridge_disable,
+	.post_disable = rk618_output_bridge_post_disable,
+	.mode_set = rk618_output_bridge_mode_set,
+};
+
+int rk618_output_register(struct rk618_output *output)
+{
+	struct device *dev = output->dev;
+	struct device_node *endpoint, *remote;
+	int ret;
+
+	output->dither_clk = devm_clk_get(dev, "dither");
+	if (IS_ERR(output->dither_clk)) {
+		ret = PTR_ERR(output->dither_clk);
+		dev_err(dev, "failed to get dither clock: %d\n", ret);
+		return ret;
+	}
+
+	output->vif_clk = devm_clk_get(dev, "vif");
+	if (IS_ERR(output->vif_clk)) {
+		ret = PTR_ERR(output->vif_clk);
+		dev_err(dev, "failed to get vif clock: %d\n", ret);
+		return ret;
+	}
+
+	output->scaler_clk = devm_clk_get(dev, "scaler");
+	if (IS_ERR(output->scaler_clk)) {
+		ret = PTR_ERR(output->scaler_clk);
+		dev_err(dev, "failed to get scaler clock: %d\n", ret);
+		return ret;
+	}
+
+	endpoint = of_graph_get_endpoint_by_regs(dev->of_node, 1, -1);
+	if (!endpoint) {
+		dev_err(dev, "no valid endpoint\n");
+		return -ENODEV;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint);
+	of_node_put(endpoint);
+	if (!remote) {
+		dev_err(dev, "no valid remote node\n");
+		return -ENODEV;
+	}
+
+	output->panel_node = remote;
+
+	return 0;
+}
+EXPORT_SYMBOL(rk618_output_register);
+
+int rk618_output_bind(struct rk618_output *output, struct drm_device *drm,
+		      int encoder_type, int connector_type)
+{
+	struct device *dev = output->dev;
+	struct drm_encoder *encoder = &output->encoder;
+	struct drm_connector *connector = &output->connector;
+	struct drm_bridge *bridge = &output->bridge;
+	int ret;
+
+	output->panel = of_drm_find_panel(output->panel_node);
+	if (!output->panel)
+		return -EPROBE_DEFER;
+
+	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm,
+							     dev->of_node);
+	drm_encoder_init(drm, encoder, &rk618_output_encoder_funcs,
+			 encoder_type, NULL);
+	drm_encoder_helper_add(encoder, &rk618_output_encoder_helper_funcs);
+
+	connector->port = dev->of_node;
+	drm_connector_init(drm, connector, &rk618_output_connector_funcs,
+			   connector_type);
+	drm_connector_helper_add(connector,
+				 &rk618_output_connector_helper_funcs);
+
+	drm_mode_connector_attach_encoder(connector, encoder);
+
+	drm_panel_attach(output->panel, connector);
+
+	bridge->funcs = &rk618_output_bridge_funcs;
+	bridge->of_node = dev->of_node;
+	ret = drm_bridge_add(bridge);
+	if (ret) {
+		DRM_ERROR("failed to add bridge\n");
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rk618_output_bind);
+
+void rk618_output_unbind(struct rk618_output *output)
+{
+	drm_bridge_remove(&output->bridge);
+	drm_connector_cleanup(&output->connector);
+	drm_encoder_cleanup(&output->encoder);
+}
+EXPORT_SYMBOL(rk618_output_unbind);
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_output.h b/drivers/gpu/drm/rockchip/rk618/rk618_output.h
new file mode 100644
index 000000000000..1e136ce521a6
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_output.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _RK618_OUTPUT_
+#define _RK618_OUTPUT_
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <video/of_display_timing.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mfd/rk618.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_of.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_mipi_dsi.h>
+
+#include <video/videomode.h>
+
+#include "../rockchip_drm_drv.h"
+#include "../rockchip_drm_vop.h"
+
+#define UPDATE(x, h, l)		(((x) << (l)) & GENMASK((h), (l)))
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK((h), (l)) << 16))
+
+#define RK618_IO_CON0			0x0088
+#define VIF1_SYNC_MODE_ENABLE		HIWORD_UPDATE(1, 15, 15)
+#define VIF1_SYNC_MODE_DISABLE		HIWORD_UPDATE(0, 15, 15)
+#define VIF0_SYNC_MODE_ENABLE		HIWORD_UPDATE(1, 14, 14)
+#define VIF0_SYNC_MODE_DISABLE		HIWORD_UPDATE(0, 14, 14)
+#define PORT2_OUTPUT_LVDS		HIWORD_UPDATE(1, 11, 11)
+#define PORT2_OUTPUT_TTL		HIWORD_UPDATE(0, 11, 11)
+#define PORT1_OUTPUT_TTL_DISABLE	HIWORD_UPDATE(1, 10, 10)
+#define PORT1_OUTPUT_TTL_ENABLE		HIWORD_UPDATE(0, 10, 10)
+#define PORT2_IO_PULL_DOWN_DISABLE	HIWORD_UPDATE(1, 9, 9)
+#define PORT2_IO_PULL_DOWN_ENABLE	HIWORD_UPDATE(0, 9, 9)
+#define PORT1_IO_PULL_DOWN_DISABLE	HIWORD_UPDATE(1, 8, 8)
+#define PORT1_IO_PULL_DOWN_ENABLE	HIWORD_UPDATE(0, 8, 8)
+#define PORT0_IO_PULL_DOWN_DISABLE	HIWORD_UPDATE(1, 7, 7)
+#define PORT0_IO_PULL_DOWN_ENABLE	HIWORD_UPDATE(0, 7, 7)
+#define HDMI_IO_PULL_UP_DISABLE		HIWORD_UPDATE(1, 6, 6)
+#define HDMI_IO_PULL_UP_ENABLE		HIWORD_UPDATE(0, 6, 6)
+#define I2C_IO_PULL_UP_DISABLE		HIWORD_UPDATE(1, 2, 2)
+#define I2C_IO_PULL_UP_ENABLE		HIWORD_UPDATE(0, 2, 2)
+#define INT_IO_PULL_UP			HIWORD_UPDATE(1, 1, 1)
+#define INT_IO_PULL_DOWN		HIWORD_UPDATE(0, 1, 1)
+#define CLKIN_IO_PULL_UP		HIWORD_UPDATE(1, 0, 0)
+#define CLKIN_IO_PULL_DOWN		HIWORD_UPDATE(0, 0, 0)
+#define RK618_IO_CON1			0x008c
+#define PORT2_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 9, 9)
+#define PORT2_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 9, 9)
+#define PORT1_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 8, 8)
+#define PORT1_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 8, 8)
+#define PORT0_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 7, 7)
+#define PORT0_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 7, 7)
+#define HDMI_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 6, 6)
+#define HDMI_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 6, 6)
+#define I2C_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 2, 2)
+#define I2C_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 2, 2)
+#define INT_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 1, 1)
+#define INT_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 1, 1)
+#define CLKIN_IO_SCHMITT_INPUT_ENABLE	HIWORD_UPDATE(1, 0, 0)
+#define CLKIN_IO_SCHMITT_INPUT_DISABLE	HIWORD_UPDATE(0, 0, 0)
+#define RK618_MISC_CON			0x009c
+#define HDMI_INT_STATUS			BIT(20)
+#define MIPI_INT_STATUS			BIT(19)
+#define MIPI_EDPI_HALT			BIT(16)
+#define HDMI_HSYNC_POL_INV		BIT(15)
+#define HDMI_VSYNC_POL_INV		BIT(14)
+#define HDMI_CLK_SEL_VIDEO_INF0_CLK	UPDATE(2, 13, 12)
+#define HDMI_CLK_SEL_SCALER_CLK		UPDATE(1, 13, 12)
+#define HDMI_CLK_SEL_VIDEO_INF1_CLK	0
+#define INT_ACTIVE_LOW			BIT(5)
+#define INT_ACTIVE_HIGH			0
+#define DOUBLE_CH_LVDS_DEN_POLARITY	BIT(4)
+#define DOUBLE_CH_LVDS_DEN_LOW		BIT(4)
+#define DOUBLE_CH_LVDS_DEN_HIGH		0
+#define DOUBLE_CH_LVDS_HSYNC_POLARITY	BIT(3)
+#define DOUBLE_CH_LVDS_HSYNC_LOW	BIT(3)
+#define DOUBLE_CH_LVDS_HSYNC_HIGH	0
+#define MIPI_DPICOLOM			BIT(2)
+#define MIPI_DPISHUTDN			BIT(1)
+
+struct rk618_output;
+
+struct rk618_output_funcs {
+	void (*pre_enable)(struct rk618_output *output);
+	void (*enable)(struct rk618_output *output);
+	void (*post_disable)(struct rk618_output *output);
+	void (*disable)(struct rk618_output *output);
+	void (*mode_set)(struct rk618_output *output,
+			 const struct drm_display_mode *mode);
+};
+
+struct rk618_output {
+	struct drm_encoder encoder;
+	struct drm_connector connector;
+	struct drm_bridge bridge;
+	struct drm_panel *panel;
+	struct drm_display_mode panel_mode;
+	struct drm_display_mode scale_mode;
+	u32 bus_format;
+
+	struct device *dev;
+	struct device_node *panel_node;
+	struct rk618 *parent;
+	struct clk *dither_clk;
+	struct clk *vif_clk;
+	struct clk *scaler_clk;
+
+	const struct rk618_output_funcs *funcs;
+};
+
+int rk618_output_register(struct rk618_output *output);
+int rk618_output_bind(struct rk618_output *output, struct drm_device *drm,
+			  int encoder_type, int connector_type);
+void rk618_output_unbind(struct rk618_output *output);
+
+void rk618_vif_enable(struct rk618 *rk618);
+void rk618_vif_disable(struct rk618 *rk618);
+void rk618_vif_configure(struct rk618 *rk618,
+			 const struct drm_display_mode *mode);
+
+void rk618_scaler_enable(struct rk618 *rk618);
+void rk618_scaler_disable(struct rk618 *rk618);
+void rk618_scaler_configure(struct rk618 *rk618,
+			    const struct drm_display_mode *scale_mode,
+			    const struct drm_display_mode *panel_mode);
+
+void rk618_dither_enable(struct rk618 *rk618);
+void rk618_dither_disable(struct rk618 *rk618);
+void rk618_dither_frc_dclk_invert(struct rk618 *rk618);
+
+#endif
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_scaler.c b/drivers/gpu/drm/rockchip/rk618/rk618_scaler.c
new file mode 100644
index 000000000000..f3322355c1fd
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_scaler.c
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rk618_output.h"
+
+#define RK618_SCALER_REG0		0x0030
+#define SCL_VER_DOWN_MODE(x)		HIWORD_UPDATE(x, 8, 8)
+#define SCL_HOR_DOWN_MODE(x)		HIWORD_UPDATE(x, 7, 7)
+#define SCL_BIC_COE_SEL(x)		HIWORD_UPDATE(x, 6, 5)
+#define SCL_VER_MODE(x)			HIWORD_UPDATE(x, 4, 3)
+#define SCL_HOR_MODE(x)			HIWORD_UPDATE(x, 2, 1)
+#define SCL_ENABLE			HIWORD_UPDATE(1, 0, 0)
+#define SCL_DISABLE			HIWORD_UPDATE(0, 0, 0)
+#define RK618_SCALER_REG1		0x0034
+#define SCL_V_FACTOR(x)			UPDATE(x, 31, 16)
+#define SCL_H_FACTOR(x)			UPDATE(x, 15, 0)
+#define RK618_SCALER_REG2		0x0038
+#define DSP_FRAME_VST(x)		UPDATE(x, 27, 16)
+#define DSP_FRAME_HST(x)		UPDATE(x, 11, 0)
+#define RK618_SCALER_REG3		0x003c
+#define DSP_HS_END(x)			UPDATE(x, 23, 16)
+#define DSP_HTOTAL(x)			UPDATE(x, 11, 0)
+#define RK618_SCALER_REG4		0x0040
+#define DSP_HACT_END(x)			UPDATE(x, 27, 16)
+#define DSP_HACT_ST(x)			UPDATE(x, 11, 0)
+#define RK618_SCALER_REG5		0x0044
+#define DSP_VS_END(x)			UPDATE(x, 23, 16)
+#define DSP_VTOTAL(x)			UPDATE(x, 11, 0)
+#define RK618_SCALER_REG6		0x0048
+#define DSP_VACT_END(x)			UPDATE(x, 27, 16)
+#define DSP_VACT_ST(x)			UPDATE(x, 11, 0)
+#define RK618_SCALER_REG7		0x004c
+#define DSP_HBOR_END(x)			UPDATE(x, 27, 16)
+#define DSP_HBOR_ST(x)			UPDATE(x, 11, 0)
+#define RK618_SCALER_REG8		0x0050
+#define DSP_VBOR_END(x)			UPDATE(x, 27, 16)
+#define DSP_VBOR_ST(x)			UPDATE(x, 11, 0)
+
+void rk618_scaler_enable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_SCALER_REG0, SCL_ENABLE);
+}
+EXPORT_SYMBOL(rk618_scaler_enable);
+
+void rk618_scaler_disable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_SCALER_REG0, SCL_DISABLE);
+}
+EXPORT_SYMBOL(rk618_scaler_disable);
+
+static void calc_dsp_frm_hst_vst(const struct videomode *src,
+				 const struct videomode *dst,
+				 u32 *dsp_frame_hst, u32 *dsp_frame_vst)
+{
+	u32 bp_in, bp_out;
+	u32 v_scale_ratio;
+	long long t_frm_st;
+	u64 t_bp_in, t_bp_out, t_delta, tin;
+	u32 src_pixclock, dst_pixclock;
+	u32 dsp_htotal, dsp_vtotal, src_htotal, src_vtotal;
+
+	src_pixclock = div_u64(1000000000000llu, src->pixelclock);
+	dst_pixclock = div_u64(1000000000000llu, dst->pixelclock);
+
+	src_htotal = src->hsync_len + src->hback_porch + src->hactive +
+		     src->hfront_porch;
+	src_vtotal = src->vsync_len + src->vback_porch + src->vactive +
+		     src->vfront_porch;
+	dsp_htotal = dst->hsync_len + dst->hback_porch + dst->hactive +
+		     dst->hfront_porch;
+	dsp_vtotal = dst->vsync_len + dst->vback_porch + dst->vactive +
+		     dst->vfront_porch;
+
+	bp_in = (src->vback_porch + src->vsync_len) * src_htotal +
+		src->hsync_len + src->hback_porch;
+	bp_out = (dst->vback_porch + dst->vsync_len) * dsp_htotal +
+		 dst->hsync_len + dst->hback_porch;
+
+	t_bp_in = bp_in * src_pixclock;
+	t_bp_out = bp_out * dst_pixclock;
+	tin = src_vtotal * src_htotal * src_pixclock;
+
+	v_scale_ratio = src->vactive / dst->vactive;
+	if (v_scale_ratio <= 2)
+		t_delta = 5 * src_htotal * src_pixclock;
+	else
+		t_delta = 12 * src_htotal * src_pixclock;
+
+	if (t_bp_in + t_delta > t_bp_out)
+		t_frm_st = (t_bp_in + t_delta - t_bp_out);
+	else
+		t_frm_st = tin - (t_bp_out - (t_bp_in + t_delta));
+
+	do_div(t_frm_st, src_pixclock);
+	*dsp_frame_hst = do_div(t_frm_st, src_htotal) - 1;
+	*dsp_frame_vst = t_frm_st;
+}
+
+void rk618_scaler_configure(struct rk618 *rk618,
+			    const struct drm_display_mode *scale_mode,
+			    const struct drm_display_mode *panel_mode)
+{
+	struct device *dev = rk618->dev;
+	struct videomode src, dst;
+	u32 dsp_frame_hst, dsp_frame_vst;
+	u32 scl_hor_mode, scl_ver_mode;
+	u32 scl_v_factor, scl_h_factor;
+	u32 src_htotal, src_vtotal;
+	u32 dsp_htotal, dsp_hs_end, dsp_hact_st, dsp_hact_end;
+	u32 dsp_vtotal, dsp_vs_end, dsp_vact_st, dsp_vact_end;
+	u32 dsp_hbor_end, dsp_hbor_st, dsp_vbor_end, dsp_vbor_st;
+	u16 bor_right = 0, bor_left = 0, bor_up = 0, bor_down = 0;
+	u8 hor_down_mode = 0, ver_down_mode = 0;
+
+	drm_display_mode_to_videomode(scale_mode, &src);
+	drm_display_mode_to_videomode(panel_mode, &dst);
+
+	src_htotal = src.hsync_len + src.hback_porch + src.hactive +
+		     src.hfront_porch;
+	src_vtotal = src.vsync_len + src.vback_porch + src.vactive +
+		     src.vfront_porch;
+	dsp_htotal = dst.hsync_len + dst.hback_porch + dst.hactive +
+		     dst.hfront_porch;
+	dsp_vtotal = dst.vsync_len + dst.vback_porch + dst.vactive +
+		     dst.vfront_porch;
+	dsp_hs_end = dst.hsync_len;
+	dsp_vs_end = dst.vsync_len;
+	dsp_hbor_end = dst.hsync_len + dst.hback_porch + dst.hactive;
+	dsp_hbor_st = dst.hsync_len + dst.hback_porch;
+	dsp_vbor_end = dst.vsync_len + dst.vback_porch + dst.vactive;
+	dsp_vbor_st = dst.vsync_len + dst.vback_porch;
+	dsp_hact_st = dsp_hbor_st + bor_left;
+	dsp_hact_end = dsp_hbor_end - bor_right;
+	dsp_vact_st = dsp_vbor_st + bor_up;
+	dsp_vact_end = dsp_vbor_end - bor_down;
+
+	calc_dsp_frm_hst_vst(&src, &dst, &dsp_frame_hst, &dsp_frame_vst);
+	dev_dbg(dev, "dsp_frame_vst=%d, dsp_frame_hst=%d\n",
+		dsp_frame_vst, dsp_frame_hst);
+
+	if (src.hactive > dst.hactive) {
+		scl_hor_mode = 2;
+
+		if (hor_down_mode == 0) {
+			if ((src.hactive - 1) / (dst.hactive - 1) > 2)
+				scl_h_factor = ((src.hactive - 1) << 14) /
+					       (dst.hactive - 1);
+			else
+				scl_h_factor = ((src.hactive - 2) << 14) /
+					       (dst.hactive - 1);
+		} else {
+			scl_h_factor = (dst.hactive << 16) /
+				       (src.hactive - 1);
+		}
+
+		dev_dbg(rk618->dev, "horizontal scale down\n");
+	} else if (src.hactive == dst.hactive) {
+		scl_hor_mode = 0;
+		scl_h_factor = 0;
+
+		dev_dbg(rk618->dev, "horizontal no scale\n");
+	} else {
+		scl_hor_mode = 1;
+		scl_h_factor = ((src.hactive - 1) << 16) / (dst.hactive - 1);
+
+		dev_dbg(rk618->dev, "horizontal scale up\n");
+	}
+
+	if (src.vactive > dst.vactive) {
+		scl_ver_mode = 2;
+
+		if (ver_down_mode == 0) {
+			if ((src.vactive - 1) / (dst.vactive - 1) > 2)
+				scl_v_factor = ((src.vactive - 1) << 14) /
+					       (dst.vactive - 1);
+			else
+				scl_v_factor = ((src.vactive - 2) << 14) /
+					       (dst.vactive - 1);
+		} else {
+			scl_v_factor = (dst.vactive << 16) /
+				       (src.vactive - 1);
+		}
+
+		dev_dbg(rk618->dev, "vertical scale down\n");
+	} else if (src.vactive == dst.vactive) {
+		scl_ver_mode = 0;
+		scl_v_factor = 0;
+
+		dev_dbg(rk618->dev, "vertical no scale\n");
+	} else {
+		scl_ver_mode = 1;
+		scl_v_factor = ((src.vactive - 1) << 16) / (dst.vactive - 1);
+
+		dev_dbg(rk618->dev, "vertical scale up\n");
+	}
+
+	regmap_write(rk618->regmap, RK618_SCALER_REG0,
+		     SCL_VER_MODE(scl_ver_mode) | SCL_HOR_MODE(scl_hor_mode));
+	regmap_write(rk618->regmap, RK618_SCALER_REG1,
+		     SCL_V_FACTOR(scl_v_factor) | SCL_H_FACTOR(scl_h_factor));
+	regmap_write(rk618->regmap, RK618_SCALER_REG2,
+		     DSP_FRAME_VST(dsp_frame_vst) |
+		     DSP_FRAME_HST(dsp_frame_hst));
+	regmap_write(rk618->regmap, RK618_SCALER_REG3,
+		     DSP_HS_END(dsp_hs_end) | DSP_HTOTAL(dsp_htotal));
+	regmap_write(rk618->regmap, RK618_SCALER_REG4,
+		     DSP_HACT_END(dsp_hact_end) | DSP_HACT_ST(dsp_hact_st));
+	regmap_write(rk618->regmap, RK618_SCALER_REG5,
+		     DSP_VS_END(dsp_vs_end) | DSP_VTOTAL(dsp_vtotal));
+	regmap_write(rk618->regmap, RK618_SCALER_REG6,
+		     DSP_VACT_END(dsp_vact_end) | DSP_VACT_ST(dsp_vact_st));
+	regmap_write(rk618->regmap, RK618_SCALER_REG7,
+		     DSP_HBOR_END(dsp_hbor_end) | DSP_HBOR_ST(dsp_hbor_st));
+	regmap_write(rk618->regmap, RK618_SCALER_REG8,
+		     DSP_VBOR_END(dsp_vbor_end) | DSP_VBOR_ST(dsp_vbor_st));
+}
+EXPORT_SYMBOL(rk618_scaler_configure);
diff --git a/drivers/gpu/drm/rockchip/rk618/rk618_vif.c b/drivers/gpu/drm/rockchip/rk618/rk618_vif.c
new file mode 100644
index 000000000000..e8221443a0d1
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rk618/rk618_vif.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rk618_output.h"
+
+#define RK618_VIF0_REG0			0x0000
+#define VIF_ENABLE			HIWORD_UPDATE(1, 0, 0)
+#define VIF_DISABLE			HIWORD_UPDATE(0, 0, 0)
+#define RK618_VIF0_REG1			0x0004
+#define VIF_FRAME_VST(x)		UPDATE(x, 27, 16)
+#define VIF_FRAME_HST(x)		UPDATE(x, 11, 0)
+#define RK618_VIF0_REG2			0x0008
+#define VIF_HS_END(x)			UPDATE(x, 23, 16)
+#define VIF_HTOTAL(x)			UPDATE(x, 11, 0)
+#define RK618_VIF0_REG3			0x000c
+#define VIF_HACT_END(x)			UPDATE(x, 27, 16)
+#define VIF_HACT_ST(x)			UPDATE(x, 11, 0)
+#define RK618_VIF0_REG4			0x0010
+#define VIF_VS_END(x)			UPDATE(x, 23, 16)
+#define VIF_VTOTAL(x)			UPDATE(x, 11, 0)
+#define RK618_VIF0_REG5			0x0014
+#define VIF_VACT_END(x)			UPDATE(x, 27, 16)
+#define VIF_VACT_ST(x)			UPDATE(x, 11, 0)
+#define RK618_VIF1_REG0			0x0018
+#define RK618_VIF1_REG1			0x001c
+#define RK618_VIF1_REG2			0x0020
+#define RK618_VIF1_REG3			0x0024
+#define RK618_VIF1_REG4			0x0028
+#define RK618_VIF1_REG5			0x002c
+
+void rk618_vif_enable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_VIF0_REG0, VIF_ENABLE);
+}
+EXPORT_SYMBOL(rk618_vif_enable);
+
+void rk618_vif_disable(struct rk618 *rk618)
+{
+	regmap_write(rk618->regmap, RK618_VIF0_REG0, VIF_DISABLE);
+}
+EXPORT_SYMBOL(rk618_vif_disable);
+
+void rk618_vif_configure(struct rk618 *rk618,
+			 const struct drm_display_mode *mode)
+{
+	struct videomode vm;
+	u32 vif_frame_vst, vif_frame_hst;
+	u32 vif_hs_end, vif_htotal, vif_hact_end, vif_hact_st;
+	u32 vif_vs_end, vif_vtotal, vif_vact_end, vif_vact_st;
+
+	drm_display_mode_to_videomode(mode, &vm);
+
+	/* XXX */
+	vif_frame_vst = 1;
+	vif_frame_hst = 207;
+
+	vif_hs_end = vm.hsync_len;
+	vif_htotal = vm.hsync_len + vm.hback_porch + vm.hfront_porch +
+		     vm.hactive;
+	vif_hact_end = vm.hsync_len + vm.hback_porch + vm.hactive;
+	vif_hact_st = vm.hsync_len + vm.hback_porch;
+	vif_vs_end = vm.vsync_len;
+	vif_vtotal = vm.vsync_len + vm.vback_porch + vm.vfront_porch +
+		     vm.vactive;
+	vif_vact_end = vm.vsync_len + vm.vback_porch + vm.vactive;
+	vif_vact_st = vm.vsync_len + vm.vback_porch;
+
+	regmap_write(rk618->regmap, RK618_VIF0_REG1,
+		     VIF_FRAME_VST(vif_frame_vst) |
+		     VIF_FRAME_HST(vif_frame_hst));
+	regmap_write(rk618->regmap, RK618_VIF0_REG2,
+		     VIF_HS_END(vif_hs_end) | VIF_HTOTAL(vif_htotal));
+	regmap_write(rk618->regmap, RK618_VIF0_REG3,
+		     VIF_HACT_END(vif_hact_end) | VIF_HACT_ST(vif_hact_st));
+	regmap_write(rk618->regmap, RK618_VIF0_REG4,
+		     VIF_VS_END(vif_vs_end) | VIF_VTOTAL(vif_vtotal));
+	regmap_write(rk618->regmap, RK618_VIF0_REG5,
+		     VIF_VACT_END(vif_vact_end) | VIF_VACT_ST(vif_vact_st));
+	regmap_write(rk618->regmap, RK618_IO_CON0,
+		     VIF0_SYNC_MODE_ENABLE);
+}
+EXPORT_SYMBOL(rk618_vif_configure);
-- 
2.35.3

