From a14e8087e917c724a660be325baf53c284a2b6b2 Mon Sep 17 00:00:00 2001
From: hxy <hxy@rock-chips.com>
Date: Fri, 24 Aug 2012 16:31:59 +0800
Subject: [PATCH] RK3066B:update board iomux config and add two pmu (wm8326 &
 tps65910) support

---
 arch/arm/configs/rk3066b_sdk_defconfig        |  10 +-
 arch/arm/mach-rk30/board-rk3066b-sdk-sdmmc.c  |  10 +-
 .../mach-rk30/board-rk3066b-sdk-tps65910.c    | 630 ++++++++++++++++++
 arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c | 146 +++-
 arch/arm/mach-rk30/board-rk3066b-sdk.c        | 163 ++++-
 drivers/media/video/rk30_camera_oneframe.c    |  11 +
 drivers/regulator/rk30-pwm-regulator.c        |   6 +-
 drivers/usb/dwc_otg/dwc_otg_driver.c          |   4 +-
 sound/soc/rk29/rk30_i2s.c                     |  14 +-
 9 files changed, 946 insertions(+), 48 deletions(-)
 create mode 100644 arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c

diff --git a/arch/arm/configs/rk3066b_sdk_defconfig b/arch/arm/configs/rk3066b_sdk_defconfig
index 5370231af3f3..19dbf78abf67 100644
--- a/arch/arm/configs/rk3066b_sdk_defconfig
+++ b/arch/arm/configs/rk3066b_sdk_defconfig
@@ -270,7 +270,7 @@ CONFIG_I2C1_CONTROLLER_RK30=y
 CONFIG_I2C2_CONTROLLER_RK30=y
 CONFIG_I2C3_CONTROLLER_RK30=y
 CONFIG_I2C4_CONTROLLER_RK30=y
-CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_WM831X=y
 CONFIG_EXPANDED_GPIO_NUM=0
 CONFIG_EXPANDED_GPIO_IRQ_NUM=0
 CONFIG_SPI_FPGA_GPIO_NUM=0
@@ -278,7 +278,13 @@ CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
 CONFIG_POWER_SUPPLY=y
 CONFIG_TEST_POWER=y
 # CONFIG_HWMON is not set
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_WM831X_I2C=y
+CONFIG_MFD_TPS65090=y
 CONFIG_REGULATOR=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_WM831X=y
+CONFIG_RK30_PWM_REGULATOR=y
 CONFIG_MEDIA_SUPPORT=y
 CONFIG_VIDEO_DEV=y
 CONFIG_SOC_CAMERA=y
@@ -391,6 +397,8 @@ CONFIG_LEDS_GPIO=y
 CONFIG_SWITCH=y
 CONFIG_SWITCH_GPIO=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_WM831X=y
+CONFIG_TPS65910_RTC=y
 CONFIG_STAGING=y
 CONFIG_ANDROID=y
 CONFIG_ANDROID_BINDER_IPC=y
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-sdmmc.c b/arch/arm/mach-rk30/board-rk3066b-sdk-sdmmc.c
index 56455828db8a..e8e6a7be1b54 100644
--- a/arch/arm/mach-rk30/board-rk3066b-sdk-sdmmc.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk-sdmmc.c
@@ -303,8 +303,7 @@ static int __init rk29sdk_wifi_bt_gpio_control_init(void)
 {
     rk29sdk_init_wifi_mem();
     
-#ifndef CONFIG_ARCH_RK3066B
-    rk29_mux_api_set(GPIO3D0_SDMMC1PWREN_NAME, GPIO3D_GPIO3D0);
+    rk29_mux_api_set(GPIO3D0_SDMMC1PWREN_MIIMD_NAME, GPIO3D_GPIO3D0);
     
     if (gpio_request(RK30SDK_WIFI_GPIO_POWER_N, "wifi_power")) {
            pr_info("%s: request wifi power gpio failed\n", __func__);
@@ -329,20 +328,19 @@ static int __init rk29sdk_wifi_bt_gpio_control_init(void)
 
     #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
     
-    rk29_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME, GPIO3C_GPIO3C2);
+    rk29_mux_api_set(GPIO3C2_SDMMC1DATA1_RMIITXD0_NAME, GPIO3C_GPIO3C2);
     gpio_request(RK30_PIN3_PC2, "mmc1-data1");
     gpio_direction_output(RK30_PIN3_PC2,GPIO_LOW);//set mmc1-data1 to low.
 
-    rk29_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME, GPIO3C_GPIO3C3);
+    rk29_mux_api_set(GPIO3C3_SDMMC1DATA2_RMIIRXD0_NAME, GPIO3C_GPIO3C3);
     gpio_request(RK30_PIN3_PC3, "mmc1-data2");
     gpio_direction_output(RK30_PIN3_PC3,GPIO_LOW);//set mmc1-data2 to low.
 
-    rk29_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME, GPIO3C_GPIO3C4);
+    rk29_mux_api_set(GPIO3C4_SDMMC1DATA3_RMIIRXD1_NAME, GPIO3C_GPIO3C4);
     gpio_request(RK30_PIN3_PC4, "mmc1-data3");
     gpio_direction_output(RK30_PIN3_PC4,GPIO_LOW);//set mmc1-data3 to low.
     
     rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
-    #endif    
 #endif
     pr_info("%s: init finished\n",__func__);
 
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c b/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
new file mode 100644
index 000000000000..d61ef3f69c36
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
@@ -0,0 +1,630 @@
+#include <linux/regulator/machine.h>
+#include <linux/i2c/twl.h>
+#include <linux/mfd/tps65910.h>
+#include <mach/sram.h>
+#include <linux/platform_device.h>
+
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+
+#define CRU_CLKGATE5_CON_ADDR 0x00e4
+#define GRF_GPIO6L_DIR_ADDR 0x0030
+#define GRF_GPIO6L_DO_ADDR 0x0068
+#define GRF_GPIO6L_EN_ADDR 0x00a0
+#define GPIO6_PB3_DIR_OUT  0x08000800
+#define GPIO6_PB3_DO_LOW  0x08000000
+#define GPIO6_PB3_DO_HIGH  0x08000800
+#define GPIO6_PB3_EN_MASK  0x08000800
+#define GPIO6_PB3_UNEN_MASK  0x08000000
+#define GPIO6_PB1_DIR_OUT  0x02000200
+#define GPIO6_PB1_DO_LOW  0x02000000
+#define GPIO6_PB1_DO_HIGH  0x02000200
+#define GPIO6_PB1_EN_MASK  0x02000200
+#define GPIO6_PB1_UNEN_MASK  0x02000000
+
+#ifdef CONFIG_MFD_TPS65910
+#define PMU_POWER_SLEEP RK30_PIN6_PB1	
+extern int platform_device_register(struct platform_device *pdev);
+
+int tps65910_pre_init(struct tps65910 *tps65910){
+
+	int val = 0;
+	int i 	= 0;
+	int err = -1;
+		
+	printk("%s,line=%d\n", __func__,__LINE__);	
+	//gpio_request(PMU_POWER_SLEEP, "NULL");
+	//gpio_direction_output(PMU_POWER_SLEEP, GPIO_HIGH);
+	
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_DEVCTRL2 reg\n");
+		return val;
+	}
+	/* Set sleep state active high and allow device turn-off after PWRON long press */
+	val |= (DEVCTRL2_SLEEPSIG_POL_MASK | DEVCTRL2_PWON_LP_OFF_MASK);
+
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL2 reg\n");
+		return err;
+	}
+	
+	 #if 1
+	/* set PSKIP=0 */
+        val = tps65910_reg_read(tps65910, TPS65910_DCDCCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+
+	val &= ~DEVCTRL_DEV_OFF_MASK;
+	val &= ~DEVCTRL_DEV_SLP_MASK;
+        err = tps65910_reg_write(tps65910, TPS65910_DCDCCTRL, val);
+        if (err) {
+                printk(KERN_ERR "Unable to write TPS65910_DCDCCTRL reg\n");
+                return err;
+        }
+	#endif
+	/* Set the maxinum load current */
+	/* VDD1 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD1);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD1 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	val |= (0x07<<2);	//TSTEP[2:0] = 111 : 2.5 mV/¦Ìs(sampling 3 Mhz/5)
+	err = tps65910_reg_write(tps65910, TPS65910_VDD1, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD1 reg\n");
+		return err;
+	}
+
+	/* VDD2 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD2 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	err = tps65910_reg_write(tps65910, TPS65910_VDD2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD2 reg\n");
+		return err;
+	}
+
+	/* VIO */
+	val = tps65910_reg_read(tps65910, TPS65910_VIO);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VIO reg\n");
+		return -EIO;
+	}
+
+	val |= (1<<6);	//when 01: 1.0 A
+	err = tps65910_reg_write(tps65910, TPS65910_VIO, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VIO reg\n");
+		return err;
+	}
+	#if 1
+	/* Mask ALL interrupts */
+	err = tps65910_reg_write(tps65910,TPS65910_INT_MSK, 0xFF);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK reg\n");
+		return err;
+	}
+	
+	err = tps65910_reg_write(tps65910, TPS65910_INT_MSK2, 0x03);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK2 reg\n");
+		return err;
+	}
+
+	/* Set RTC Power, disable Smart Reflex in DEVCTRL_REG */
+	#if 1
+	val = 0;
+	val |= (DEVCTRL_SR_CTL_I2C_SEL_MASK);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL reg\n");
+		return err;
+	}
+	printk(KERN_INFO "TPS65910 Set default voltage.\n");
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%04x\n",__FUNCTION__,val);
+	}
+	#endif
+
+	#if 1
+	//sleep control register
+	/*set func when in sleep mode */
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= (1 << 1);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/* open ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_LDO_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val &= 0;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_LDO_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+		
+	/*set dc mode when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_RES_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val  |= 0xff;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_RES_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/*close ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_SET_LDO_OFF);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= 0x0b;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_SET_LDO_OFF, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%4x\n",__FUNCTION__,val);
+	}
+	#endif
+	#endif
+	printk("%s,line=%d\n", __func__,__LINE__);
+	return 0;
+
+}
+int tps65910_post_init(struct tps65910 *tps65910)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	printk("%s,line=%d\n", __func__,__LINE__);
+
+	g_pmic_type = PMIC_TYPE_TPS65910;
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+
+	#ifdef CONFIG_RK30_PWM_REGULATOR
+	platform_device_register(&pwm_regulator_device[0]);
+	#endif
+	
+	dcdc = regulator_get(NULL, "vio");	//vcc_io
+	regulator_set_voltage(dcdc, 3000000, 3000000);
+	regulator_enable(dcdc);
+	printk("%s set vio vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vpll");	// vcc25
+	regulator_set_voltage(ldo, 2500000, 2500000);
+	regulator_enable(ldo);
+	printk("%s set vpll vdd11=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vdig2");	// vdd11
+	regulator_set_voltage(ldo, 1100000, 1100000);
+	regulator_enable(ldo);
+	printk("%s set vdig2 vdd11=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vaux33");	 //vcc_tp
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_enable(ldo);
+	printk("%s set vaux33 vcc_tp=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vdd_cpu");	//vdd_cpu
+	regulator_set_voltage(dcdc, 1200000, 1200000);
+	regulator_enable(dcdc);
+	printk("%s set vdd1 vdd_cpu=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vdd2");	//vcc_ddr 
+	regulator_set_voltage(dcdc, 1200000, 1200000);	// 1.5*4/5 = 1.2 and Vout=1.5v
+	regulator_enable(dcdc);
+	printk("%s set vdd2 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "vdig1");	//vcc18_cif
+	regulator_set_voltage(ldo, 1800000, 1800000);
+	regulator_enable(ldo);
+	printk("%s set vdig1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	dcdc = regulator_get(NULL, "vaux1"); //vcc25_hdmi
+	regulator_set_voltage(dcdc,2500000,2500000);
+	regulator_enable(dcdc); 
+	printk("%s set vaux1 vcc25_hdmi=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vaux2");	//vcca33
+	regulator_set_voltage(ldo, 3300000, 3300000);
+	regulator_enable(ldo);
+	printk("%s set vaux2 vcca33=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vdac"); // vccio_wl
+	regulator_set_voltage(ldo,1800000,1800000);
+	regulator_enable(ldo); 
+	printk("%s set vdac vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "vmmc");  //vcc28_cif
+	regulator_set_voltage(ldo,2800000,2800000);
+	regulator_enable(ldo); 
+	printk("%s set vmmc vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	udelay(100);
+	
+	printk("%s,line=%d END\n", __func__,__LINE__);
+	
+	return 0;
+}
+
+static struct regulator_consumer_supply tps65910_smps1_supply[] = {
+	{
+		.supply = "vdd1",
+	},
+	{
+		.supply = "vdd_cpu",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps2_supply[] = {
+	{
+		.supply = "vdd2",
+	},
+	
+};
+static struct regulator_consumer_supply tps65910_smps3_supply[] = {
+	{
+		.supply = "vdd3",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps4_supply[] = {
+	{
+		.supply = "vio",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo1_supply[] = {
+	{
+		.supply = "vdig1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo2_supply[] = {
+	{
+		.supply = "vdig2",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo3_supply[] = {
+	{
+		.supply = "vaux1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo4_supply[] = {
+	{
+		.supply = "vaux2",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo5_supply[] = {
+	{
+		.supply = "vaux33",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo6_supply[] = {
+	{
+		.supply = "vmmc",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo7_supply[] = {
+	{
+		.supply = "vdac",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo8_supply[] = {
+	{
+		.supply = "vpll",
+	},
+};
+
+static struct regulator_init_data tps65910_smps1 = {
+	.constraints = {
+		.name           = "VDD1",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps1_supply),
+	.consumer_supplies =  tps65910_smps1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps2 = {
+	.constraints = {
+		.name           = "VDD2",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps2_supply),
+	.consumer_supplies =  tps65910_smps2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps3 = {
+	.constraints = {
+		.name           = "VDD3",
+		.min_uV			= 1000000,
+		.max_uV			= 1400000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps3_supply),
+	.consumer_supplies =  tps65910_smps3_supply,
+};
+
+static struct regulator_init_data tps65910_smps4 = {
+	.constraints = {
+		.name           = "VIO",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps4_supply),
+	.consumer_supplies =  tps65910_smps4_supply,
+};
+static struct regulator_init_data tps65910_ldo1 = {
+	.constraints = {
+		.name           = "VDIG1",
+		.min_uV			= 1200000,
+		.max_uV			= 2700000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo1_supply),
+	.consumer_supplies =  tps65910_ldo1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo2 = {
+	.constraints = {
+		.name           = "VDIG2",
+		.min_uV			= 1000000,
+		.max_uV			= 1800000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo2_supply),
+	.consumer_supplies =  tps65910_ldo2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo3 = {
+	.constraints = {
+		.name           = "VAUX1",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo3_supply),
+	.consumer_supplies =  tps65910_ldo3_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo4 = {
+	.constraints = {
+		.name           = "VAUX2",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo4_supply),
+	.consumer_supplies =  tps65910_ldo4_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo5 = {
+	.constraints = {
+		.name           = "VAUX33",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo5_supply),
+	.consumer_supplies =  tps65910_ldo5_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo6 = {
+	.constraints = {
+		.name           = "VMMC",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo6_supply),
+	.consumer_supplies =  tps65910_ldo6_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo7 = {
+	.constraints = {
+		.name           = "VDAC",
+		.min_uV			= 1800000,
+		.max_uV			= 2850000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo7_supply),
+	.consumer_supplies =  tps65910_ldo7_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo8 = {
+	.constraints = {
+		.name           = "VPLL",
+		.min_uV			= 1000000,
+		.max_uV			= 2500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo8_supply),
+	.consumer_supplies =  tps65910_ldo8_supply,
+};
+
+void __sramfunc board_pmu_tps65910_suspend(void)
+{	
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+}
+void __sramfunc board_pmu_tps65910_resume(void)
+{
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+	#ifdef CONFIG_CLK_SWITCH_TO_32K                 //switch clk to 24M
+	sram_32k_udelay(10000);
+	#else
+	sram_udelay(2000);
+	#endif
+}
+
+static struct tps65910_board tps65910_data = {
+	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
+	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
+	.gpio_base = TPS65910_GPIO_EXPANDER_BASE,
+	
+	.pre_init = tps65910_pre_init,
+	.post_init = tps65910_post_init,
+
+	//TPS65910_NUM_REGS = 13
+	// Regulators
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC] = NULL,		
+	.tps65910_pmic_init_data[TPS65910_REG_VIO] = &tps65910_smps4,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1] = &tps65910_smps1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2] = &tps65910_smps2,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3] = &tps65910_smps3,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1] = &tps65910_ldo1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2] = &tps65910_ldo2,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL] = &tps65910_ldo8,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC] = &tps65910_ldo7,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1] = &tps65910_ldo3,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2] = &tps65910_ldo4,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33] = &tps65910_ldo5,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC] = &tps65910_ldo6,
+
+ 
+};
+
+#endif
+
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c b/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
index bd79715161c0..e4783766aa11 100644
--- a/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk-wm8326.c
@@ -5,6 +5,7 @@
 #include <linux/mfd/wm831x/pmu.h>
 
 #include <mach/sram.h>
+#include <linux/earlysuspend.h>
 
 #define cru_readl(offset)	readl_relaxed(RK30_CRU_BASE + offset)
 #define cru_writel(v, offset)	do { writel_relaxed(v, RK30_CRU_BASE + offset); dsb(); } while (0)
@@ -182,7 +183,10 @@ int wm831x_post_init(struct wm831x *Wm831x)
 	struct regulator *dcdc;
 	struct regulator *ldo;
 
-
+	
+	g_pmic_type = PMIC_TYPE_WM8326;
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+	
 	ldo = regulator_get(NULL, "ldo6");	//vcc_33
 	regulator_set_voltage(ldo, 3300000, 3300000);
 	regulator_set_suspend_voltage(ldo, 3300000);
@@ -495,7 +499,8 @@ struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
 			.min_uV = 600000,
 			.max_uV = 1800000,	//0.6-1.8V
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(dcdc1_consumers),
 		.consumer_supplies = dcdc1_consumers,
@@ -506,7 +511,8 @@ struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
 			.min_uV = 600000,
 			.max_uV = 1800000,	//0.6-1.8V
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(dcdc2_consumers),
 		.consumer_supplies = dcdc2_consumers,
@@ -517,7 +523,8 @@ struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
 			.min_uV = 850000,
 			.max_uV = 3400000,	//0.85-3.4V
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(dcdc3_consumers),
 		.consumer_supplies = dcdc3_consumers,
@@ -528,7 +535,8 @@ struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
 			.min_uV = 850000,
 			.max_uV = 3400000,	//0.85-3.4V
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(dcdc4_consumers),
 		.consumer_supplies = dcdc4_consumers,
@@ -569,7 +577,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo1_consumers),
 		.consumer_supplies = ldo1_consumers,
@@ -580,7 +589,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo2_consumers),
 		.consumer_supplies = ldo2_consumers,
@@ -591,7 +601,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo3_consumers),
 		.consumer_supplies = ldo3_consumers,
@@ -602,7 +613,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo4_consumers),
 		.consumer_supplies = ldo4_consumers,
@@ -613,7 +625,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo5_consumers),
 		.consumer_supplies = ldo5_consumers,
@@ -624,7 +637,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 900000,
 			.max_uV = 3300000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo6_consumers),
 		.consumer_supplies = ldo6_consumers,
@@ -635,7 +649,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 1000000,
 			.max_uV = 3500000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo7_consumers),
 		.consumer_supplies = ldo7_consumers,
@@ -646,7 +661,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 1000000,
 			.max_uV = 3500000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo8_consumers),
 		.consumer_supplies = ldo8_consumers,
@@ -657,7 +673,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 1000000,
 			.max_uV = 3500000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo9_consumers),
 		.consumer_supplies = ldo9_consumers,
@@ -668,7 +685,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 1000000,
 			.max_uV = 3500000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo10_consumers),
 		.consumer_supplies = ldo10_consumers,
@@ -679,7 +697,8 @@ struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
 			.min_uV = 800000,
 			.max_uV = 1550000,
 			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
 		},
 		.num_consumer_supplies = ARRAY_SIZE(ldo11_consumers),
 		.consumer_supplies = ldo11_consumers,
@@ -774,15 +793,105 @@ static int wm831x_init_pin_type(struct wm831x *wm831x)
 	return 0;
 }
 
-void __sramfunc board_pmu_suspend(void)
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	printk("%s\n", __func__);
+	
+	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
+	regulator_set_voltage(dcdc, 2800000, 2800000);
+	regulator_set_mode(dcdc, REGULATOR_MODE_STANDBY);
+	regulator_enable(dcdc);
+	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo1");	//
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "ldo4");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "ldo6");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo8");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);	
+		
+}
+void wm831x_pmu_early_resume(struct regulator_dev *rdev)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	printk("%s\n", __func__);
+	
+	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
+	regulator_set_voltage(dcdc, 3000000, 3000000);
+	regulator_set_mode(dcdc, REGULATOR_MODE_FAST);
+	regulator_enable(dcdc);
+	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo1");	//
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo4");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo6");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo8");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);	
+}
+#else
+void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
+{
+}
+void wm831x_pmu_early_resume(struct regulator_dev *rdev)
+{
+}
+#endif
+
+void __sramfunc board_pmu_wm8326_suspend(void)
 {	
+#if 0
 	cru_writel(CRU_CLKGATE5_GRFCLK_ON,CRU_CLKGATE5_CON_ADDR); //open grf clk
 	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
 	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
 	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+#endif
 }
-void __sramfunc board_pmu_resume(void)
+void __sramfunc board_pmu_wm8326_resume(void)
 {
+#if 0
 	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
 	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);     //set gpio6_b1 output high
 	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
@@ -791,6 +900,7 @@ void __sramfunc board_pmu_resume(void)
 #else
 	sram_udelay(10000);
 #endif
+#endif
 }
 static struct wm831x_pdata wm831x_platdata = {
 
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk.c b/arch/arm/mach-rk30/board-rk3066b-sdk.c
index 3878f61ec2ff..cc892ce90110 100644
--- a/arch/arm/mach-rk30/board-rk3066b-sdk.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk.c
@@ -44,6 +44,8 @@
 #include <linux/regulator/machine.h>
 #include <linux/rfkill-rk.h>
 #include <linux/sensor-dev.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/regulator/rk29-pwm-regulator.h>
 #if defined(CONFIG_HDMI_RK30)
 	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
 #endif
@@ -80,11 +82,9 @@ static int goodix_init_platform_hw(void)
 {
 	int ret;
 	
-#ifndef CONFIG_ARCH_RK3066B
-	rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME, GPIO4D_GPIO4D0);
-	rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME, GPIO4C_GPIO4C2);
-	printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO4D0_SMCDATA8_TRACEDATA8_NAME),rk30_mux_api_get(GPIO4C2_SMCDATA2_TRACEDATA2_NAME));
-#endif
+	rk30_mux_api_set(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME, GPIO2C_GPIO2C0);
+	rk30_mux_api_set(GPIO0D4_SPI1RXD_NAME, GPIO0D_GPIO0D4);
+	printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME),rk30_mux_api_get(GPIO0D4_SPI1RXD_NAME));
 
 	if (TOUCH_PWR_PIN != INVALID_GPIO) {
 		ret = gpio_request(TOUCH_PWR_PIN, "goodix power pin");
@@ -353,10 +353,6 @@ struct platform_device rk29_device_mt6229 = {
 
 static int mma8452_init_platform_hw(void)
 {
-#ifndef CONFIG_ARCH_RK3066B
-	rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
-#endif
-
 	return 0;
 }
 
@@ -373,9 +369,6 @@ static struct sensor_platform_data mma8452_info = {
 
 static int lis3dh_init_platform_hw(void)
 {
-#ifndef CONFIG_ARCH_RK3066B
-        rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
-#endif
 
         return 0;
 }
@@ -431,10 +424,6 @@ static struct sensor_platform_data akm8975_info =
 
 static int l3g4200d_init_platform_hw(void)
 {
-#ifndef CONFIG_ARCH_RK3066B
-	rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME, GPIO4C_GPIO4C3);
-#endif
-	
 	return 0;
 }
 
@@ -855,6 +844,59 @@ static struct platform_device rk30_device_adc_battery = {
         },
 };
 #endif
+#ifdef CONFIG_RK30_PWM_REGULATOR
+const static int pwm_voltage_map[] = {
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
+};
+
+static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+struct regulator_init_data pwm_regulator_init_dcdc[1] =
+{
+	{
+		.constraints = {
+			.name = "PWM_DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
+		.consumer_supplies = pwm_dcdc1_consumers,
+	},
+};
+
+static struct pwm_platform_data pwm_regulator_info[1] = {
+	{
+		.pwm_id = 3,
+		.pwm_gpio = RK30_PIN3_PD6,
+		.pwm_iomux_name = GPIO3D6_PWM3_JTAGTMS_HOSTDRVVBUS_NAME,
+		.pwm_iomux_pwm = GPIO3D_PWM3,
+		.pwm_iomux_gpio = GPIO3D_GPIO3D6,
+		.pwm_voltage = 1100000,
+		.suspend_voltage = 1050000,
+		.min_uV = 1000000,
+		.max_uV	= 1400000,
+		.coefficient = 455,	//45.5%
+		.pwm_voltage_map = pwm_voltage_map,
+		.init_data	= &pwm_regulator_init_dcdc[0],
+	},
+};
+
+struct platform_device pwm_regulator_device[1] = {
+	{
+		.name = "pwm-voltage-regulator",
+		.id = 0,
+		.dev		= {
+			.platform_data = &pwm_regulator_info[0],
+		}
+	},
+};
+#endif
 
 #ifdef CONFIG_RK29_VMAC
 #define PHY_PWR_EN_GPIO	RK30_PIN1_PD6
@@ -1057,8 +1099,17 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 };
 #endif
 
+#define PMIC_TYPE_WM8326	1
+#define PMIC_TYPE_TPS65910	2
+int __sramdata g_pmic_type =  0;
 #ifdef CONFIG_I2C1_RK30
+#ifdef CONFIG_MFD_WM831X_I2C
 #include "board-rk3066b-sdk-wm8326.c"
+#endif
+#ifdef CONFIG_MFD_TPS65910
+#define TPS65910_HOST_IRQ        RK30_PIN6_PA4
+#include "board-rk3066b-sdk-tps65910.c"
+#endif
 
 static struct i2c_board_info __initdata i2c1_info[] = {
 #if defined (CONFIG_MFD_WM831X_I2C)
@@ -1070,9 +1121,89 @@ static struct i2c_board_info __initdata i2c1_info[] = {
 		.platform_data = &wm831x_platdata,
 	},
 #endif
+#if defined (CONFIG_MFD_TPS65910)
+	{
+        .type           = "tps65910",
+        .addr           = TPS65910_I2C_ID0,
+        .flags          = 0,
+        .irq            = TPS65910_HOST_IRQ,
+    	.platform_data = &tps65910_data,
+	},
+#endif
 };
 #endif
 
+void __sramfunc board_pmu_suspend(void)
+{      
+	#if defined (CONFIG_MFD_WM831X_I2C)
+       if(g_pmic_type == PMIC_TYPE_WM8326)
+       board_pmu_wm8326_suspend();
+	#endif
+	#if defined (CONFIG_MFD_TPS65910)
+       if(g_pmic_type == PMIC_TYPE_TPS65910)
+       board_pmu_tps65910_suspend(); 
+    #endif   
+}
+
+void __sramfunc board_pmu_resume(void)
+{      
+	#if defined (CONFIG_MFD_WM831X_I2C)
+       if(g_pmic_type == PMIC_TYPE_WM8326)
+       board_pmu_wm8326_resume();
+	#endif
+	#if defined (CONFIG_MFD_TPS65910)
+       if(g_pmic_type == PMIC_TYPE_TPS65910)
+       board_pmu_tps65910_resume(); 
+	#endif
+}
+
+ int __sramdata gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+
+void __sramfunc rk30_pwm_logic_suspend_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+
+//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+	sram_udelay(10000);
+	gpio0d7_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
+	gpio0d7_do = grf_readl(GRF_GPIO0H_DO);
+	gpio0d7_dir = grf_readl(GRF_GPIO0H_DIR);
+	gpio0d7_en = grf_readl(GRF_GPIO0H_EN);
+
+	writel_relaxed((1<<30), GRF_GPIO0D_IOMUX);
+	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DIR);
+	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DO);
+	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_EN);
+#endif 
+}
+void __sramfunc rk30_pwm_logic_resume_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	writel_relaxed((1<<30)|gpio0d7_iomux, GRF_GPIO0D_IOMUX);
+	grf_writel((1<<31)|gpio0d7_en, GRF_GPIO0H_EN);
+	grf_writel((1<<31)|gpio0d7_dir, GRF_GPIO0H_DIR);
+	grf_writel((1<<31)|gpio0d7_do, GRF_GPIO0H_DO);
+	sram_udelay(10000);
+
+#endif
+
+}
+extern void pwm_suspend_voltage(void);
+extern void pwm_resume_voltage(void);
+void  rk30_pwm_suspend_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_suspend_voltage();
+#endif
+}
+void  rk30_pwm_resume_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_resume_voltage();
+#endif
+}
+
+
 #ifdef CONFIG_I2C2_RK30
 static struct i2c_board_info __initdata i2c2_info[] = {
 #if defined (CONFIG_TOUCHSCREEN_GT8XX)
diff --git a/drivers/media/video/rk30_camera_oneframe.c b/drivers/media/video/rk30_camera_oneframe.c
index 9e6e84efc9b4..d9a28406cc4c 100755
--- a/drivers/media/video/rk30_camera_oneframe.c
+++ b/drivers/media/video/rk30_camera_oneframe.c
@@ -2824,6 +2824,17 @@ static struct soc_camera_host_ops rk_soc_camera_host_ops =
 static void rk_camera_cif_iomux(int cif_index)
 {
 #if defined(CONFIG_ARCH_RK3066B)
+    switch(cif_index){
+        case 0:
+            rk30_mux_api_set(GPIO3B3_CIFCLKOUT_NAME, GPIO3B_CIFCLKOUT);
+	    rk30_mux_api_set(GPIO3B4_CIFDATA0_HSADCDATA8_NAME, GPIO3B_CIFDATA0);
+	    rk30_mux_api_set(GPIO3B5_CIFDATA1_HSADCDATA9_NAME, GPIO3B_CIFDATA1);
+	    rk30_mux_api_set(GPIO3B6_CIFDATA10_I2C3SDA_NAME, GPIO3B_CIFDATA10);
+	    rk30_mux_api_set(GPIO3B7_CIFDATA11_I2C3SCL_NAME, GPIO3B_CIFDATA11);
+            break;
+        default:
+            printk("cif index is erro!!!\n");
+        }
 #elif defined(CONFIG_ARCH_RK30)
     switch(cif_index){
         case 0:
diff --git a/drivers/regulator/rk30-pwm-regulator.c b/drivers/regulator/rk30-pwm-regulator.c
index ff459c706ea9..2c0e46ed02fe 100755
--- a/drivers/regulator/rk30-pwm-regulator.c
+++ b/drivers/regulator/rk30-pwm-regulator.c
@@ -61,7 +61,7 @@ struct rk_pwm_dcdc {
 };
 
 
-#if defined(CONFIG_ARCH_RK30)
+#if defined(CONFIG_ARCH_RK30) |defined(CONFIG_ARCH_RK3066B)
 #define pwm_write_reg(id, addr, val)        __raw_writel(val, addr+(RK30_PWM01_BASE+(id>>1)*0x20000)+id*0x10)
 #define pwm_read_reg(id, addr)              __raw_readl(addr+(RK30_PWM01_BASE+(id>>1)*0x20000+id*0x10))
 #elif defined(CONFIG_ARCH_RK29)
@@ -87,7 +87,7 @@ static int pwm_set_rate(struct pwm_platform_data *pdata,int nHz,u32 rate)
 
 #if defined(CONFIG_ARCH_RK29) || defined(CONFIG_ARCH_RK2928)
 	clkrate = clk_get_rate(pwm_clk[0]);
-#elif defined(CONFIG_ARCH_RK30)
+#elif defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK3066B)
 	if (id == 0 || id == 1) {
 		clkrate = clk_get_rate(pwm_clk[0]);
 	} else if (id== 2 || id == 3) {
@@ -315,7 +315,7 @@ static int __devinit pwm_regulator_probe(struct platform_device *pdev)
 	
 #if defined(CONFIG_ARCH_RK29)
 		pwm_clk[0] = clk_get(NULL, "pwm");
-#elif defined(CONFIG_ARCH_RK30)
+#elif defined(CONFIG_ARCH_RK30) |defined(CONFIG_ARCH_RK3066B)
 		if (pwm_id == 0 || pwm_id == 1)
 		{
 			pwm_clk[0] = clk_get(NULL, "pwm01");	
diff --git a/drivers/usb/dwc_otg/dwc_otg_driver.c b/drivers/usb/dwc_otg/dwc_otg_driver.c
index 6bbdcdf21e40..021c73df598a 100755
--- a/drivers/usb/dwc_otg/dwc_otg_driver.c
+++ b/drivers/usb/dwc_otg/dwc_otg_driver.c
@@ -1584,6 +1584,7 @@ static __devinit int dwc_otg_driver_probe(struct platform_device *pdev)
     USB_IOMUX_INIT(GPIO4A5_OTG0DRVVBUS_NAME, GPIO4L_OTG0_DRV_VBUS);
 #endif
 #if defined(CONFIG_ARCH_RK3066B)
+    USB_IOMUX_INIT(GPIO3D5_PWM2_JTAGTCK_OTGDRVVBUS_NAME, GPIO3D_OTGDRVVBUS);
 #elif defined(CONFIG_ARCH_RK30)
     USB_IOMUX_INIT(GPIO0A5_OTGDRVVBUS_NAME, GPIO0A_OTG_DRV_VBUS);    
 #endif
@@ -2170,7 +2171,7 @@ static __devinit int host20_driver_probe(struct platform_device *pdev)
 #ifdef CONFIG_ARCH_RK29  
     ahbclk = clk_get(NULL, "usbotg1");
 #endif
-#ifdef CONFIG_ARCH_RK30  
+#if defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK3066B)  
     ahbclk = clk_get(NULL, "hclk_otg1");
 #endif    
 #ifdef CONFIG_ARCH_RK2928
@@ -2280,6 +2281,7 @@ static __devinit int host20_driver_probe(struct platform_device *pdev)
     USB_IOMUX_INIT(GPIO4A6_OTG1DRVVBUS_NAME, GPIO4L_OTG1_DRV_VBUS);
 #endif    
 #if defined(CONFIG_ARCH_RK3066B)
+    USB_IOMUX_INIT(GPIO3D6_PWM3_JTAGTMS_HOSTDRVVBUS_NAME, GPIO3D_HOSTDRVVBUS);
 #elif defined(CONFIG_ARCH_RK30)
     USB_IOMUX_INIT(GPIO0A6_HOSTDRVVBUS_NAME, GPIO0A_HOST_DRV_VBUS);    
 #endif
diff --git a/sound/soc/rk29/rk30_i2s.c b/sound/soc/rk29/rk30_i2s.c
index ad474d44d4ae..f4ee6770f381 100755
--- a/sound/soc/rk29/rk30_i2s.c
+++ b/sound/soc/rk29/rk30_i2s.c
@@ -491,6 +491,14 @@ static int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)
 	I2S_DBG("Enter %s, %d >>>>>>>>>>>\n", __func__, __LINE__);
 	switch(dai->id) {
 #if defined(CONFIG_ARCH_RK3066B)
+        case 1:
+                        rk30_mux_api_set(GPIO1C0_I2SCLK_NAME, GPIO1C_I2SCLK);
+                        rk30_mux_api_set(GPIO1C1_I2SSCLK_NAME, GPIO1C_I2SSCLK);
+                        rk30_mux_api_set(GPIO1C2_I2SLRCLKRX_NAME, GPIO1C_I2SLRCLKRX);
+                        rk30_mux_api_set(GPIO1C3_I2SLRCLKTX_NAME, GPIO1C_I2SLRCLKTX);
+                        rk30_mux_api_set(GPIO1C4_I2SSDI_NAME, GPIO1C_I2SSDI);
+                        rk30_mux_api_set(GPIO1C5_I2SSDO_NAME, GPIO1C_I2SSDO);
+                        break;
 #elif defined(CONFIG_ARCH_RK30)
         case 0:
 			rk30_mux_api_set(GPIO0A7_I2S8CHSDI_NAME, GPIO0A_I2S_8CH_SDI);		
@@ -516,9 +524,9 @@ static int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)
 			rk30_mux_api_set(GPIO0D1_I2S22CHSCLK_SMCWEN_NAME, GPIO0D_I2S2_2CH_SCLK);
 			rk30_mux_api_set(GPIO0D2_I2S22CHLRCKRX_SMCOEN_NAME, GPIO0D_I2S2_2CH_LRCK_RX);
 			rk30_mux_api_set(GPIO0D3_I2S22CHLRCKTX_SMCADVN_NAME, GPIO0D_I2S2_2CH_LRCK_TX);				
-            rk30_mux_api_set(GPIO0D4_I2S22CHSDI_SMCADDR0_NAME, GPIO0D_I2S2_2CH_SDI);
-            rk30_mux_api_set(GPIO0D5_I2S22CHSDO_SMCADDR1_NAME, GPIO0D_I2S2_2CH_SDO);
-            break;				
+            		rk30_mux_api_set(GPIO0D4_I2S22CHSDI_SMCADDR0_NAME, GPIO0D_I2S2_2CH_SDI);
+            		rk30_mux_api_set(GPIO0D5_I2S22CHSDO_SMCADDR1_NAME, GPIO0D_I2S2_2CH_SDO);
+           		break;				
 #endif
 #ifdef CONFIG_ARCH_RK2928
         case 0:
-- 
2.35.3

