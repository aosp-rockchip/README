From 8b7fa397aeeb558383718a313b1948d1ee89b719 Mon Sep 17 00:00:00 2001
From: Shawn Lin <shawn.lin@rock-chips.com>
Date: Wed, 3 Jun 2015 17:16:03 +0800
Subject: [PATCH] mmc: rk_sdmmc: local reversion and code regulation

Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
---
 drivers/mmc/card/block.c        |   18 +-
 drivers/mmc/core/core.c         |  174 ++--
 drivers/mmc/core/host.c         |   37 +-
 drivers/mmc/host/dw_mmc-pltfm.c |   17 +-
 drivers/mmc/host/dw_mmc-pltfm.h |    5 +-
 drivers/mmc/host/rk_sdmmc.c     | 1348 ++++++++++++++-----------------
 drivers/mmc/host/rk_sdmmc.h     |  163 +++-
 include/linux/mmc/rk_mmc.h      |   16 +-
 8 files changed, 875 insertions(+), 903 deletions(-)

diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 355c18f4aa39..e4aa64d5d958 100755
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -2431,12 +2431,12 @@ static int mmc_blk_probe(struct mmc_card *card)
 	mmc_set_bus_resume_policy(card->host, 1);
 #endif
 #if defined(CONFIG_MMC_DW_ROCKCHIP)
-    if(card->host->restrict_caps & RESTRICT_CARD_TYPE_EMMC){
-        this_card = card;
-        md->disk->emmc_disk = 1;
-    }else {
-        md->disk->emmc_disk = 0;
-    }
+	if (card->host->restrict_caps & RESTRICT_CARD_TYPE_EMMC) {
+		this_card = card;
+		md->disk->emmc_disk = 1;
+	} else {
+		md->disk->emmc_disk = 0;
+	}
 #endif
 	if (mmc_add_disk(md))
 		goto out;
@@ -2469,10 +2469,10 @@ static int mmc_blk_probe(struct mmc_card *card)
 static void mmc_blk_remove(struct mmc_card *card)
 {
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
-	
+
 #if defined(CONFIG_MMC_DW_ROCKCHIP)
-    if(card->host->restrict_caps & RESTRICT_CARD_TYPE_EMMC)
-        this_card = NULL;
+	if (card->host->restrict_caps & RESTRICT_CARD_TYPE_EMMC)
+		this_card = NULL;
 #endif
 	mmc_blk_remove_parts(card, md);
 	pm_runtime_get_sync(&card->dev);
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index df838e526748..e487872795ad 100755
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -167,22 +167,22 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 		led_trigger_event(host->led, LED_OFF);
 
 		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
-			mmc_hostname(host), cmd->opcode, err,
-			cmd->resp[0], cmd->resp[1],
-			cmd->resp[2], cmd->resp[3]);
+			 mmc_hostname(host), cmd->opcode, err,
+			 cmd->resp[0], cmd->resp[1],
+			 cmd->resp[2], cmd->resp[3]);
 
 		if (mrq->data) {
 			pr_debug("%s:     %d bytes transferred: %d\n",
-				mmc_hostname(host),
-				mrq->data->bytes_xfered, mrq->data->error);
+				 mmc_hostname(host),
+				 mrq->data->bytes_xfered, mrq->data->error);
 		}
 
 		if (mrq->stop) {
 			pr_debug("%s:     (CMD%u): %d: %08x %08x %08x %08x\n",
-				mmc_hostname(host), mrq->stop->opcode,
-				mrq->stop->error,
-				mrq->stop->resp[0], mrq->stop->resp[1],
-				mrq->stop->resp[2], mrq->stop->resp[3]);
+				 mmc_hostname(host), mrq->stop->opcode,
+				 mrq->stop->error,
+				 mrq->stop->resp[0], mrq->stop->resp[1],
+				 mrq->stop->resp[2], mrq->stop->resp[3]);
 		}
 
 		if (mrq->done)
@@ -191,7 +191,6 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 		mmc_host_clk_release(host);
 	}
 }
-
 EXPORT_SYMBOL(mmc_request_done);
 
 static void
@@ -213,12 +212,11 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		 mrq->cmd->arg, mrq->cmd->flags);
 
 	if (mrq->data) {
-		pr_debug("%s:     blksz %d blocks %d flags %08x "
-			"tsac %d ms nsac %d\n",
-			mmc_hostname(host), mrq->data->blksz,
-			mrq->data->blocks, mrq->data->flags,
-			mrq->data->timeout_ns / 1000000,
-			mrq->data->timeout_clks);
+		pr_debug("%s:     blksz %d blocks %d flags %08x tsac %d ms nsac %d\n",
+			 mmc_hostname(host), mrq->data->blksz,
+			 mrq->data->blocks, mrq->data->flags,
+			 mrq->data->timeout_ns / 1000000,
+			 mrq->data->timeout_clks);
 	}
 
 	if (mrq->stop) {
@@ -303,7 +301,8 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	}
 
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal, true);
+			   EXT_CSD_BKOPS_START, 1,
+			   timeout, use_busy_signal, true);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",
 			mmc_hostname(card->host), err);
@@ -398,8 +397,8 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 
 	while (1) {
 		wait_event_interruptible(context_info->wait,
-				(context_info->is_done_rcv ||
-				 context_info->is_new_req));
+					 (context_info->is_done_rcv ||
+					 context_info->is_new_req));
 		spin_lock_irqsave(&context_info->lock, flags);
 		context_info->is_waiting_last_req = false;
 		spin_unlock_irqrestore(&context_info->lock, flags);
@@ -437,9 +436,9 @@ static void mmc_get_req_timeout(struct mmc_request *mrq, u32 *timeout)
 {
 	if (!mrq->cmd->data) {
 		if (mrq->cmd->opcode == MMC_ERASE ||
-			(mrq->cmd->opcode == MMC_ERASE_GROUP_START) ||
-			(mrq->cmd->opcode == MMC_ERASE_GROUP_END) ||
-			(mrq->cmd->opcode == MMC_SEND_STATUS))
+		    (mrq->cmd->opcode == MMC_ERASE_GROUP_START) ||
+		    (mrq->cmd->opcode == MMC_ERASE_GROUP_END) ||
+		    (mrq->cmd->opcode == MMC_SEND_STATUS))
 			*timeout = 2500000;
 		else
 			*timeout = 500;
@@ -452,7 +451,7 @@ static void mmc_get_req_timeout(struct mmc_request *mrq, u32 *timeout)
 	}
 
 	if ((mrq->cmd->opcode == SD_IO_RW_DIRECT) ||
-		(mrq->cmd->opcode == SD_IO_RW_EXTENDED))
+	    (mrq->cmd->opcode == SD_IO_RW_EXTENDED))
 		*timeout = 8000;
 }
 
@@ -466,7 +465,7 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 
 	while (1) {
 		if (!wait_for_completion_timeout(&mrq->completion,
-			msecs_to_jiffies(timeout))) {
+						 msecs_to_jiffies(timeout))) {
 			cmd = mrq->cmd;
 			cmd->error = -ETIMEDOUT;
 			host->ops->post_tmo(host);
@@ -487,8 +486,8 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 		 */
 		if (cmd->sanitize_busy && cmd->error == -ETIMEDOUT) {
 			if (!mmc_interrupt_hpi(host->card)) {
-				pr_warning("%s: %s: Interrupted sanitize\n",
-					   mmc_hostname(host), __func__);
+				pr_warn("%s: %s: Interrupted sanitize\n",
+					mmc_hostname(host), __func__);
 				cmd->error = 0;
 				break;
 			} else {
@@ -520,7 +519,7 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
  *	performed while another request is running on the host.
  */
 static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
-		 bool is_first_req)
+			bool is_first_req)
 {
 	if (host->ops->pre_req) {
 		mmc_host_clk_hold(host);
@@ -596,9 +595,8 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 			mmc_start_bkops(host->card, true);
 	}
 
-	if (!err && areq) {
+	if (!err && areq)
 		start_err = __mmc_start_data_req(host, areq->mrq);
-	}
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
@@ -676,7 +674,7 @@ int mmc_interrupt_hpi(struct mmc_card *card)
 	default:
 		/* In all other states, it's illegal to issue HPI */
 		pr_debug("%s: HPI cannot be sent. Card state=%d\n",
-			mmc_hostname(card->host), R1_CURRENT_STATE(status));
+			 mmc_hostname(card->host), R1_CURRENT_STATE(status));
 		err = -EINVAL;
 		goto out;
 	}
@@ -711,7 +709,9 @@ EXPORT_SYMBOL(mmc_interrupt_hpi);
  *	to complete.  Return any error that occurred while the command
  *	was executing.  Do not attempt to parse the response.
  */
-int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
+int mmc_wait_for_cmd(struct mmc_host *host,
+		     struct mmc_command *cmd,
+		     int retries)
 {
 	struct mmc_request mrq = {NULL};
 
@@ -727,7 +727,6 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 
 	return cmd->error;
 }
-
 EXPORT_SYMBOL(mmc_wait_for_cmd);
 
 /**
@@ -947,15 +946,16 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		host->claimed = 1;
 		host->claimer = current;
 		host->claim_cnt += 1;
-	} else
+	} else {
 		wake_up(&host->wq);
+	}
+
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
 	if (host->ops->enable && !stop && host->claim_cnt == 1)
 		host->ops->enable(host);
 	return stop;
 }
-
 EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
@@ -1018,8 +1018,7 @@ static inline void mmc_set_ios(struct mmc_host *host)
 {
 	struct mmc_ios *ios = &host->ios;
 
-	pr_debug("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u "
-		"width %u timing %u\n",
+	pr_debug("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u width %u timing %u\n",
 		 mmc_hostname(host), ios->clock, ios->bus_mode,
 		 ios->power_mode, ios->chip_select, ios->vdd,
 		 ios->bus_width, ios->timing);
@@ -1244,7 +1243,7 @@ int mmc_of_parse_voltage(struct device_node *np, u32 *mask)
 				be32_to_cpu(voltage_ranges[j + 1]));
 		if (!ocr_mask) {
 			pr_err("%s: voltage-range #%d is invalid\n",
-				np->full_name, i);
+			       np->full_name, i);
 			return -EINVAL;
 		}
 		*mask |= ocr_mask;
@@ -1306,8 +1305,8 @@ EXPORT_SYMBOL_GPL(mmc_regulator_get_ocrmask);
  * set_ios() method.
  */
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
-			struct regulator *supply,
-			unsigned short vdd_bit)
+			  struct regulator *supply,
+			  unsigned short vdd_bit)
 {
 	int			result = 0;
 	int			min_uV, max_uV;
@@ -1337,8 +1336,10 @@ int mmc_regulator_set_ocr(struct mmc_host *mmc,
 		 */
 		voltage = regulator_get_voltage(supply);
 
-		if (!regulator_can_change_voltage(supply))
-			min_uV = max_uV = voltage;
+		if (!regulator_can_change_voltage(supply)) {
+			max_uV = voltage;
+			min_uV = max_uV;
+		}
 
 		if (voltage < 0)
 			result = voltage;
@@ -1404,7 +1405,7 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 	 */
 	if (ocr & 0x7F) {
 		dev_warn(mmc_dev(host),
-		"card claims to support voltages below defined range\n");
+			 "card claims to support voltages below defined range\n");
 		ocr &= ~0x7F;
 	}
 
@@ -1444,7 +1445,6 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 		host->ios.signal_voltage = old_signal_voltage;
 
 	return err;
-
 }
 
 int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
@@ -1469,8 +1469,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 	if (!host->ops->start_signal_voltage_switch)
 		return -EPERM;
 	if (!host->ops->card_busy)
-		pr_warning("%s: cannot verify signal voltage switch\n",
-				mmc_hostname(host));
+		pr_warn("%s: cannot verify signal voltage switch\n",
+			mmc_hostname(host));
 
 	cmd.opcode = SD_SWITCH_VOLTAGE;
 	cmd.arg = 0;
@@ -1527,8 +1527,8 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
 
 power_cycle:
 	if (err) {
-		pr_debug("%s: Signal voltage switch failed, "
-			"power cycling card\n", mmc_hostname(host));
+		pr_debug("%s: Signal voltage switch failed, power cycling card\n",
+			 mmc_hostname(host));
 		mmc_power_cycle(host, ocr);
 	}
 
@@ -1766,10 +1766,11 @@ void mmc_detach_bus(struct mmc_host *host)
 }
 
 static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
-				bool cd_irq)
+			       bool cd_irq)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
+
 	spin_lock_irqsave(&host->lock, flags);
 	WARN_ON(host->removed);
 	spin_unlock_irqrestore(&host->lock, flags);
@@ -1780,7 +1781,7 @@ static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
 	 * 5 s to give provision for user space to consume the event.
 	 */
 	if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL) &&
-		device_can_wakeup(mmc_dev(host)))
+	    device_can_wakeup(mmc_dev(host)))
 		pm_wakeup_event(mmc_dev(host), 5000);
 
 	host->detect_change = 1;
@@ -1842,9 +1843,9 @@ void mmc_init_erase(struct mmc_card *card)
 			card->pref_erase = 2 * 1024 * 1024 / 512;
 		else
 			card->pref_erase = 4 * 1024 * 1024 / 512;
-		if (card->pref_erase < card->erase_size)
+		if (card->pref_erase < card->erase_size) {
 			card->pref_erase = card->erase_size;
-		else {
+		} else {
 			sz = card->pref_erase % card->erase_size;
 			if (sz)
 				card->pref_erase += card->erase_size - sz;
@@ -1853,7 +1854,7 @@ void mmc_init_erase(struct mmc_card *card)
 }
 
 static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
-				          unsigned int arg, unsigned int qty)
+					  unsigned int arg, unsigned int qty)
 {
 	unsigned int erase_timeout;
 
@@ -2001,8 +2002,8 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
-		pr_err("mmc_erase: group start error %d, "
-		       "status %#x\n", err, cmd.resp[0]);
+		pr_err("mmc_erase: group start error %d, status %#x\n",
+		       err, cmd.resp[0]);
 		err = -EIO;
 		goto out;
 	}
@@ -2048,7 +2049,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		err = mmc_wait_for_cmd(card->host, &cmd, 0);
 		if (err || (cmd.resp[0] & 0xFDF92000)) {
 			pr_err("error %d requesting status %#x\n",
-				err, cmd.resp[0]);
+			       err, cmd.resp[0]);
 			err = -EIO;
 			goto out;
 		}
@@ -2058,7 +2059,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		 */
 		if (time_after(jiffies, timeout)) {
 			pr_err("%s: Card stuck in programming state! %s\n",
-				mmc_hostname(card->host), __func__);
+			       mmc_hostname(card->host), __func__);
 			err =  -EIO;
 			goto out;
 		}
@@ -2287,7 +2288,7 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 EXPORT_SYMBOL(mmc_set_blocklen);
 
 int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
-			bool is_rel_write)
+		       bool is_rel_write)
 {
 	struct mmc_command cmd = {0};
 
@@ -2409,7 +2410,7 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	 * if the card is being re-initialized, just send it.  CMD52
 	 * should be ignored by SD/eMMC cards.
 	 */
-#if 0
+#ifdef MMC_STANDARD_PROBE
 	sdio_reset(host);
 	mmc_go_idle(host);
 
@@ -2423,27 +2424,27 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	if (!mmc_attach_mmc(host))
 		return 0;
 #else
-    /*
-    * Simplifying the process of initializing the card.
-    * modifyed by xbw, at 2014-03-14
-    */
-	if(host->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
-	    sdio_reset(host);
+	/*
+	* Simplifying initialization process.
+	*/
+	if (host->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
+		sdio_reset(host);
 
 	mmc_go_idle(host);
-	
-	if(host->restrict_caps & (RESTRICT_CARD_TYPE_SDIO |RESTRICT_CARD_TYPE_SD))
-	    mmc_send_if_cond(host, host->ocr_avail);
 
-        /* Order's important: probe SDIO, then SD, then MMC */
+	if (host->restrict_caps &
+	    (RESTRICT_CARD_TYPE_SDIO | RESTRICT_CARD_TYPE_SD))
+		mmc_send_if_cond(host, host->ocr_avail);
+
+	/* Order's important: probe SDIO, then SD, then MMC */
 	if ((host->restrict_caps & RESTRICT_CARD_TYPE_SDIO) &&
-		!mmc_attach_sdio(host))
+	    !mmc_attach_sdio(host))
 		return 0;
 	if ((host->restrict_caps & RESTRICT_CARD_TYPE_SD) &&
-		!mmc_attach_sd(host))
+	    !mmc_attach_sd(host))
 		return 0;
 	if ((host->restrict_caps & RESTRICT_CARD_TYPE_EMMC) &&
-		!mmc_attach_mmc(host))
+	    !mmc_attach_mmc(host))
 		return 0;
 #endif
 
@@ -2539,8 +2540,8 @@ void mmc_rescan(struct work_struct *work)
 	 * if there is a _removable_ card registered, check whether it is
 	 * still present
 	 */
-	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
-	    && !(host->caps & MMC_CAP_NONREMOVABLE))
+	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead &&
+	    !(host->caps & MMC_CAP_NONREMOVABLE))
 		host->bus_ops->detect(host);
 
 	host->detect_change = 0;
@@ -2571,7 +2572,7 @@ void mmc_rescan(struct work_struct *work)
 	mmc_bus_put(host);
 
 	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->get_cd &&
-			host->ops->get_cd(host) == 0) {
+	    host->ops->get_cd(host) == 0) {
 		mmc_claim_host(host);
 		mmc_power_off(host);
 		mmc_release_host(host);
@@ -2615,6 +2616,7 @@ void mmc_stop_host(struct mmc_host *host)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
+
 	spin_lock_irqsave(&host->lock, flags);
 	host->removed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
@@ -2708,13 +2710,13 @@ int mmc_flush_cache(struct mmc_card *card)
 		return err;
 
 	if (mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0) &&
-			(card->ext_csd.cache_ctrl & 1)) {
+	    (card->ext_csd.cache_size > 0) &&
+	    (card->ext_csd.cache_ctrl & 1)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_FLUSH_CACHE, 1, 0);
+				 EXT_CSD_FLUSH_CACHE, 1, 0);
 		if (err)
 			pr_err("%s: cache flush error %d\n",
-					mmc_hostname(card->host), err);
+			       mmc_hostname(card->host), err);
 	}
 
 	return err;
@@ -2734,22 +2736,22 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 	int err = 0;
 
 	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
-			mmc_card_is_removable(host))
+	    mmc_card_is_removable(host))
 		return err;
 
 	if (card && mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0)) {
+	    (card->ext_csd.cache_size > 0)) {
 		enable = !!enable;
 
 		if (card->ext_csd.cache_ctrl ^ enable) {
 			timeout = enable ? card->ext_csd.generic_cmd6_time : 0;
 			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CACHE_CTRL, enable, timeout);
+					 EXT_CSD_CACHE_CTRL, enable, timeout);
 			if (err)
 				pr_err("%s: cache %s error %d\n",
-						mmc_hostname(card->host),
-						enable ? "on" : "off",
-						err);
+				       mmc_hostname(card->host),
+				       enable ? "on" : "off",
+				       err);
 			else
 				card->ext_csd.cache_ctrl = enable;
 		}
@@ -2766,7 +2768,7 @@ EXPORT_SYMBOL(mmc_cache_ctrl);
    to sync the card.
 */
 int mmc_pm_notify(struct notifier_block *notify_block,
-					unsigned long mode, void *unused)
+		  unsigned long mode, void *unused)
 {
 	struct mmc_host *host = container_of(
 		notify_block, struct mmc_host, pm_notify);
@@ -2816,7 +2818,6 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
 		_mmc_detect_change(host, 0, false);
-
 	}
 
 	return 0;
@@ -2852,7 +2853,6 @@ void mmc_set_embedded_sdio_data(struct mmc_host *host,
 	host->embedded_sdio_data.funcs = funcs;
 	host->embedded_sdio_data.num_funcs = num_funcs;
 }
-
 EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
 #endif
 
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 4d3d02d9b568..2385b6f33c3e 100755
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -35,6 +35,7 @@
 static void mmc_host_classdev_release(struct device *dev)
 {
 	struct mmc_host *host = cls_dev_to_mmc_host(dev);
+
 	mutex_destroy(&host->slot.lock);
 	kfree(host);
 }
@@ -59,14 +60,16 @@ static DEFINE_SPINLOCK(mmc_host_lock);
 
 #ifdef CONFIG_MMC_CLKGATE
 static ssize_t clkgate_delay_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+				  struct device_attribute *attr, char *buf)
 {
 	struct mmc_host *host = cls_dev_to_mmc_host(dev);
+
 	return snprintf(buf, PAGE_SIZE, "%lu\n", host->clkgate_delay);
 }
 
 static ssize_t clkgate_delay_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
 {
 	struct mmc_host *host = cls_dev_to_mmc_host(dev);
 	unsigned long flags, value;
@@ -279,7 +282,7 @@ static inline void mmc_host_clk_sysfs_init(struct mmc_host *host)
 	host->clkgate_delay_attr.attr.mode = S_IRUGO | S_IWUSR;
 	if (device_create_file(&host->class_dev, &host->clkgate_delay_attr))
 		pr_err("%s: Failed to create clkgate_delay sysfs entry\n",
-				mmc_hostname(host));
+		       mmc_hostname(host));
 }
 #else
 
@@ -436,7 +439,6 @@ int mmc_of_parse(struct mmc_host *host)
 	mmc_gpio_free_cd(host);
 	return ret;
 }
-
 EXPORT_SYMBOL(mmc_of_parse);
 
 /**
@@ -451,7 +453,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	int err;
 	struct mmc_host *host;
 
-	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
+	host = kzalloc(sizeof(*host) + extra, GFP_KERNEL);
 	if (!host)
 		return NULL;
 
@@ -482,7 +484,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
 	wake_lock_init(&host->detect_wake_lock, WAKE_LOCK_SUSPEND,
-		kasprintf(GFP_KERNEL, "%s_detect", mmc_hostname(host)));
+		       kasprintf(GFP_KERNEL, "%s_detect", mmc_hostname(host)));
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 #ifdef CONFIG_PM
 	host->pm_notify.notifier_call = mmc_pm_notify;
@@ -505,7 +507,6 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	kfree(host);
 	return NULL;
 }
-
 EXPORT_SYMBOL(mmc_alloc_host);
 
 /**
@@ -539,12 +540,11 @@ int mmc_add_host(struct mmc_host *host)
 	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
 		register_pm_notifier(&host->pm_notify);
 
-    if(host->restrict_caps & RESTRICT_CARD_TYPE_SDIO) 
-        primary_sdio_host = host;
-        
+	if (host->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
+		primary_sdio_host = host;
+
 	return 0;
 }
-
 EXPORT_SYMBOL(mmc_add_host);
 
 
@@ -573,7 +573,6 @@ void mmc_remove_host(struct mmc_host *host)
 
 	mmc_host_clk_exit(host);
 }
-
 EXPORT_SYMBOL(mmc_remove_host);
 
 /**
@@ -591,7 +590,6 @@ void mmc_free_host(struct mmc_host *host)
 
 	put_device(&host->class_dev);
 }
-
 EXPORT_SYMBOL(mmc_free_host);
 
 /**
@@ -607,19 +605,20 @@ EXPORT_SYMBOL(mmc_free_host);
 int mmc_host_rescan(struct mmc_host *host, int val, int is_cap_sdio_irq)
 {
 	if (NULL != primary_sdio_host) {
-		if(!host)
+		if (!host)
 			host = primary_sdio_host;
 		else
-			printk("%s: mmc_host_rescan pass in host from argument!\n", mmc_hostname(host));
+			pr_info("%s: mmc_host_rescan pass in host from argument!\n",
+				mmc_hostname(host));
 	} else {
-		printk("sdio: host isn't  initialization successfully.\n");
+		pr_err("sdio: host isn't  initialization successfully.\n");
 		return -ENOMEDIUM;
 	}
 
-	printk("%s:mmc host rescan start!\n", mmc_hostname(host));
+	pr_info("%s:mmc host rescan start!\n", mmc_hostname(host));
 
 	/*  0: oob  1:cap-sdio-irq */
-	if (is_cap_sdio_irq == 1) { 
+	if (is_cap_sdio_irq == 1) {
 		host->caps |= MMC_CAP_SDIO_IRQ;
 	} else if (is_cap_sdio_irq == 0) {
 		host->caps &= ~MMC_CAP_SDIO_IRQ;
@@ -630,7 +629,7 @@ int mmc_host_rescan(struct mmc_host *host, int val, int is_cap_sdio_irq)
 
 	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->set_sdio_status)
 		host->ops->set_sdio_status(host, val);
-	
+
 	return 0;
 }
 EXPORT_SYMBOL(mmc_host_rescan);
diff --git a/drivers/mmc/host/dw_mmc-pltfm.c b/drivers/mmc/host/dw_mmc-pltfm.c
index 501db7858610..d7a4e9a48e9a 100755
--- a/drivers/mmc/host/dw_mmc-pltfm.c
+++ b/drivers/mmc/host/dw_mmc-pltfm.c
@@ -21,12 +21,11 @@
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/rk_mmc.h>
 #include <linux/of.h>
-
+#include "dw_mmc-pltfm.h"
 #include "rk_sdmmc.h"
 
-
 int dw_mci_pltfm_register(struct platform_device *pdev,
-				const struct dw_mci_drv_data *drv_data)
+			  const struct dw_mci_drv_data *drv_data)
 {
 	struct dw_mci *host;
 	struct resource	*regs;
@@ -49,9 +48,9 @@ int dw_mci_pltfm_register(struct platform_device *pdev,
 	host->irq_flags = 0;
 	host->pdata = pdev->dev.platform_data;
 	host->regs = devm_ioremap_resource(&pdev->dev, regs);
-        #ifdef CONFIG_MMC_DW_IDMAC
-        host->phy_regs = (void *)(regs->start);
-        #endif
+	#ifdef CONFIG_MMC_DW_IDMAC
+	host->phy_regs = (void *)(regs->start);
+	#endif
 	if (IS_ERR(host->regs))
 		return PTR_ERR(host->regs);
 
@@ -72,7 +71,7 @@ static int dw_mci_pltfm_probe(struct platform_device *pdev)
 	return dw_mci_pltfm_register(pdev, NULL);
 }
 
-static int dw_mci_pltfm_remove(struct platform_device *pdev)
+int dw_mci_pltfm_remove(struct platform_device *pdev)
 {
 	struct dw_mci *host = platform_get_drvdata(pdev);
 
@@ -114,7 +113,9 @@ static int dw_mci_pltfm_resume(struct device *dev)
 #define dw_mci_pltfm_resume	NULL
 #endif /* CONFIG_PM_SLEEP */
 
-SIMPLE_DEV_PM_OPS(dw_mci_pltfm_pmops, dw_mci_pltfm_suspend, dw_mci_pltfm_resume);
+SIMPLE_DEV_PM_OPS(dw_mci_pltfm_pmops,
+		  dw_mci_pltfm_suspend,
+		  dw_mci_pltfm_resume);
 EXPORT_SYMBOL_GPL(dw_mci_pltfm_pmops);
 
 static const struct of_device_id dw_mci_pltfm_match[] = {
diff --git a/drivers/mmc/host/dw_mmc-pltfm.h b/drivers/mmc/host/dw_mmc-pltfm.h
index 68e7fd2f6148..2a6685faec7e 100644
--- a/drivers/mmc/host/dw_mmc-pltfm.h
+++ b/drivers/mmc/host/dw_mmc-pltfm.h
@@ -16,5 +16,8 @@ extern int dw_mci_pltfm_register(struct platform_device *pdev,
 				const struct dw_mci_drv_data *drv_data);
 extern int dw_mci_pltfm_remove(struct platform_device *pdev);
 extern const struct dev_pm_ops dw_mci_pltfm_pmops;
-
+extern int dw_mci_probe(struct dw_mci *host);
+extern void dw_mci_remove(struct dw_mci *host);
 #endif /* _DW_MMC_PLTFM_H_ */
+
+
diff --git a/drivers/mmc/host/rk_sdmmc.c b/drivers/mmc/host/rk_sdmmc.c
index 1b20b431275e..6621ea9ec1b7 100755
--- a/drivers/mmc/host/rk_sdmmc.c
+++ b/drivers/mmc/host/rk_sdmmc.c
@@ -5,7 +5,7 @@
  * Copyright (C) 2009 NXP Semiconductors
  * Copyright (C) 2009, 2010 Imagination Technologies Ltd.
  *
- * Copyright (C) 2014 Fuzhou Rockchip Electronics Co.Ltd.
+ * Copyright (C) 2014 - 2015 Fuzhou Rockchip Electronics Co.Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -54,11 +54,11 @@
 #include <linux/regulator/rockchip_io_vol_domain.h>
 #include "../../clk/rockchip/clk-ops.h"
 
-#define RK_SDMMC_DRIVER_VERSION "Ver 1.13 2014-09-05"
+#define RK_SDMMC_DRIVER_VERSION "Ver 2.00 2015-06-10"
 
 /* Common flag combinations */
 #define DW_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DRTO | SDMMC_INT_DCRC | \
-				 /*SDMMC_INT_HTO | */SDMMC_INT_SBE  | \
+				 SDMMC_INT_SBE  | \
 				 SDMMC_INT_EBE)
 #define DW_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | \
 				 SDMMC_INT_RESP_ERR)
@@ -67,15 +67,13 @@
 #define DW_MCI_SEND_STATUS	1
 #define DW_MCI_RECV_STATUS	2
 #define DW_MCI_DMA_THRESHOLD	16
+#define DW_MCI_FREQ_MAX		50000000	/* unit: HZ */
+#define DW_MCI_FREQ_MIN		300000		/* unit: HZ */
 
-#define DW_MCI_FREQ_MAX	50000000//200000000	/* unit: HZ */
-#define DW_MCI_FREQ_MIN	300000//400000		/* unit: HZ */
-
-/*max is 250ms showed in Spec; Maybe adapt the value for the sick card.*/
+/* Max is 250ms showed in Spec */
 #define SDMMC_DATA_TIMEOUT_SD	500
 #define SDMMC_DATA_TIMEOUT_SDIO	250
 #define SDMMC_DATA_TIMEOUT_EMMC	2500
-
 #define SDMMC_CMD_RTO_MAX_HOLD  200
 #define SDMMC_WAIT_FOR_UNBUSY	2500
 
@@ -108,101 +106,12 @@ struct idmac_desc {
 };
 #endif /* CONFIG_MMC_DW_IDMAC */
 
-static const u8 tuning_blk_pattern_4bit[] = {
-	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
-	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
-	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
-	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
-	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
-	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
-	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
-	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
-};
-
-static const u8 tuning_blk_pattern_8bit[] = {
-	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
-	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
-	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
-	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
-	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
-	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
-	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
-	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
-	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
-	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
-	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
-	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
-	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
-	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
-	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
-	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
-};
-
-
-static struct sdmmc_reg dw_mci_regs[] =
-{
-  { 0x0000, "CTRL" },
-  { 0x0004, "PWREN" },
-  { 0x0008, "CLKDIV" },
-  { 0x000C, "CLKSRC" },
-  { 0x0010, "CLKENA" },
-  { 0x0014, "TMOUT" },
-  { 0x0018, "CTYPE" },
-  { 0x001C, "BLKSIZ" },
-  { 0x0020, "BYTCNT" },
-  { 0x0024, "INTMASK" },
-  { 0x0028, "CMDARG" },
-  { 0x002C, "CMD" },
-  { 0x0030, "RESP0" },
-  { 0x0034, "RESP1" },
-  { 0x0038, "RESP2" },
-  { 0x003C, "RESP3" },
-  { 0x0040, "MINSTS" },
-  { 0x0044, "RINTSTS" },
-  { 0x0048, "STATUS" },
-  { 0x004C, "FIFOTH" },
-  { 0x0050, "CDETECT" },
-  { 0x0054, "WRTPRT" },
-  { 0x0058, "GPIO" },
-  { 0x005C, "TCBCNT" },
-  { 0x0060, "TBBCNT" },
-  { 0x0064, "DEBNCE" },
-  { 0x0068, "USRID" },
-  { 0x006C, "VERID" },
-  { 0x0070, "HCON" },
-  { 0x0074, "UHS_REG" },
-  { 0x0078, "RST_n" },
-  { 0x0080, "BMOD" },
-  { 0x0084, "PLDMND" },
-  { 0x0088, "DBADDR" },
-  { 0x008C, "IDSTS" },
-  { 0x0090, "IDINTEN" },
-  { 0x0094, "DSCADDR" },
-  { 0x0098, "BUFADDR" },
-  { 0x0100, "CARDTHRCTL" },
-  { 0x0104, "BackEndPwr" },
-  { 0, 0 }
-};
 
 static inline bool dw_mci_fifo_reset(struct dw_mci *host);
 static inline bool dw_mci_ctrl_all_reset(struct dw_mci *host);
 static bool dw_mci_ctrl_reset(struct dw_mci *host, u32 reset);
 static void dw_mci_disable_low_power(struct dw_mci_slot *slot);
-
-/*printk the all register of current host*/
-#if 0
-static int dw_mci_regs_printk(struct dw_mci *host)
-{
-    struct sdmmc_reg *regs = dw_mci_regs;
-
-    while( regs->name != 0 ){
-        printk("%s: (0x%04x) = 0x%08x\n", regs->name, regs->addr, mci_readreg(host,regs->addr));
-        regs++;
-    }
-    printk("=======printk %s-register end =========\n", mmc_hostname(host->mmc));
-    return 0;
-}
-#endif
+extern void rk_send_wakeup_key(void);
 
 #if defined(CONFIG_DEBUG_FS)
 static int dw_mci_req_show(struct seq_file *s, void *v)
@@ -371,46 +280,10 @@ static u32 dw_mci_prepare_command(struct mmc_host *mmc, struct mmc_command *cmd)
 	return cmdr;
 }
 
-#if 0
-static u32 dw_mci_prep_stop_abort(struct dw_mci *host, struct mmc_command *cmd)
-{
-	struct mmc_command *stop;
-	u32 cmdr;
-
-	if (!cmd->data)
-		return 0;
-
-	stop = &host->stop_abort;
-	cmdr = cmd->opcode;
-	memset(stop, 0, sizeof(struct mmc_command));
-
-	if (cmdr == MMC_READ_SINGLE_BLOCK ||
-	    cmdr == MMC_READ_MULTIPLE_BLOCK ||
-	    cmdr == MMC_WRITE_BLOCK ||
-	    cmdr == MMC_WRITE_MULTIPLE_BLOCK) {
-		stop->opcode = MMC_STOP_TRANSMISSION;
-		stop->arg = 0;
-		stop->flags = MMC_RSP_R1B | MMC_CMD_AC;
-	} else if (cmdr == SD_IO_RW_EXTENDED) {
-		stop->opcode = SD_IO_RW_DIRECT;
-		stop->arg |= (1 << 31) | (0 << 28) | (SDIO_CCCR_ABORT << 9) |
-			     ((cmd->arg >> 28) & 0x7);
-		stop->flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
-	} else {
-		return 0;
-	}
-
-	cmdr = stop->opcode | SDMMC_CMD_STOP |
-		SDMMC_CMD_RESP_CRC | SDMMC_CMD_RESP_EXP;
-
-	return cmdr;
-}
-#endif
 static void dw_mci_start_command(struct dw_mci *host,
 				 struct mmc_command *cmd, u32 cmd_flags)
 {
 	struct dw_mci_slot *slot = host->slot[0];
-	/*temporality fix slot[0] due to host->num_slots equal to 1*/
 
 	host->pre_cmd = host->cmd;
 	host->cmd = cmd;
@@ -432,7 +305,7 @@ static void dw_mci_start_command(struct dw_mci *host,
 	mci_writel(host, CMDARG, cmd->arg);
 	wmb();
 	
-	/* fix the value to 1 in some Soc,for example RK3188. */
+	/* Fix the value to 1 in current soc */
 	if(host->mmc->hold_reg_flag)
 		cmd_flags |= SDMMC_CMD_USE_HOLD_REG;
 
@@ -512,12 +385,6 @@ static void dw_mci_idmac_complete_dma(void *arg)
 
         dev_vdbg(host->dev, "DMA complete\n");
 
-        /*
-        MMC_DBG_CMD_FUNC(host->mmc," DMA complete cmd=%d(arg=0x%x), blocks=%d,blksz=%d[%s]", \
-                host->mrq->cmd->opcode,host->mrq->cmd->arg,
-                data->blocks,data->blksz,mmc_hostname(host->mmc));
-        */
-
         host->dma_ops->cleanup(host);
 
 	/*
@@ -685,7 +552,7 @@ static void dw_mci_edmac_start_dma(struct dw_mci *host, unsigned int sg_len)
 	fifoth_val = mci_readl(host, FIFOTH);
 	mburst = mszs[(fifoth_val >> 28) & 0x7];
 
-	/* edmac limit burst to 16, but work around for rk3036 to 8 */
+	/* Edmac limit burst to 16, but work around for rk3036 to 8 */
 	if (unlikely(cpu_is_rk3036()))
 		burst_limit = 8;
 	else
@@ -709,16 +576,19 @@ static void dw_mci_edmac_start_dma(struct dw_mci *host, unsigned int sg_len)
 		slave_config.direction = DMA_MEM_TO_DEV;
 		ret = dmaengine_slave_config(host->dms->ch, &slave_config);
 		if(ret){
-			dev_err(host->dev, "error in dw_mci edma configuration.\n");
+			dev_err(host->dev,
+				"Error in dw_mci edmac write configuration.\n");
 			return;
 		}
 
 		desc = dmaengine_prep_slave_sg(host->dms->ch, sgl, sg_len,
 					DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 		if (!desc) {
-			dev_err(host->dev, "We cannot prepare for the dw_mci slave edma!\n");
+			dev_err(host->dev,
+				"Cannot prepare slave write sg the dw_mci edmac!\n");
 			return;
 		}
+
 		/* Set dw_mci_edmac_complete_dma as callback */
 		desc->callback = dw_mci_edmac_complete_dma;
 		desc->callback_param = (void *)host;
@@ -733,13 +603,15 @@ static void dw_mci_edmac_start_dma(struct dw_mci *host, unsigned int sg_len)
 		slave_config.direction = DMA_DEV_TO_MEM;
 		ret = dmaengine_slave_config(host->dms->ch, &slave_config);
 		if (ret) {
-			dev_err(host->dev, "error in dw_mci edma configuration.\n");
+			dev_err(host->dev,
+				"Error in dw_mci edmac read configuration.\n");
 			return;
 		}
 		desc = dmaengine_prep_slave_sg(host->dms->ch, sgl, sg_len,
 					DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 		if (!desc) {
-			dev_err(host->dev, "We cannot prepare for the dw_mci slave edma!\n");
+			dev_err(host->dev,
+				"Cannot prepare slave read sg for the dw_mci edmac!\n");
 			return;
 		}
 		/* set dw_mci_edmac_complete_dma as callback */
@@ -752,31 +624,28 @@ static void dw_mci_edmac_start_dma(struct dw_mci *host, unsigned int sg_len)
 
 static int dw_mci_edmac_init(struct dw_mci *host)
 {
+	int ret = 0;
+
         /* Request external dma channel, SHOULD decide chn in dts */
         host->dms = NULL;
-        host->dms = (struct dw_mci_dma_slave *)kmalloc
+        host->dms = (struct dw_mci_dma_slave *)kzalloc
                                 (sizeof(struct dw_mci_dma_slave), GFP_KERNEL);
         if (NULL == host->dms) {
                 dev_err(host->dev, "No enough memory to alloc dms.\n");
-                goto err_exit;
+                return -ENOMEM;
         }
 
         host->dms->ch = dma_request_slave_channel(host->dev, "dw_mci");
         if (!host->dms->ch) {
-                dev_err(host->dev, "Failed to get external DMA channel: channel id = %d\n",
-                                host->dms->ch->chan_id);
-                goto err_exit;
-        }
-
-        return 0;
-
-err_exit:
-        if (NULL != host->dms) {
-                kfree(host->dms);
-                host->dms = NULL;
+                dev_err(host->dev,
+			"Failed to get external DMA channel %d\n",
+			host->dms->ch->chan_id);
+		kfree(host->dms);
+		host->dms = NULL;
+		return -ENXIO;
         }
-        return -ENXIO;
 
+        return ret;
 }
 
 static void dw_mci_edmac_exit(struct dw_mci *host)
@@ -986,7 +855,7 @@ static int dw_mci_submit_data_dma(struct dw_mci *host, struct mmc_data *data)
 		dw_mci_adjust_fifoth(host, data);
 
     	/* Reset DMA FIFO*/
-	dw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET);// | SDMMC_CTRL_FIFO_RESET); //dange to fifo-reset; noted by xbw,at 2014-03-28
+	dw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET);
 
 	/* Enable the DMA interface */
 	temp = mci_readl(host, CTRL);
@@ -1017,7 +886,7 @@ static void dw_mci_submit_data(struct dw_mci *host, struct mmc_data *data)
 	host->data = data;
 
 	/* Reset FIFO*/
-	dw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET);// | SDMMC_CTRL_FIFO_RESET);//dange to fifo-reset; noted by xbw,at 2014-03-28
+	dw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET);
 
 	if (data->flags & MMC_DATA_READ) {
 		host->dir_status = DW_MCI_RECV_STATUS;
@@ -1026,8 +895,9 @@ static void dw_mci_submit_data(struct dw_mci *host, struct mmc_data *data)
 		host->dir_status = DW_MCI_SEND_STATUS;
 	}
 	
-    MMC_DBG_INFO_FUNC(host->mmc," dw_mci_submit_data,blocks=%d,blksz=%d [%s]",\
-         data->blocks, data->blksz, mmc_hostname(host->mmc));
+	MMC_DBG_INFO_FUNC(host->mmc,
+			"Dw_mci_submit_data, blocks = %d, blksz = %d [%s]",
+			data->blocks, data->blksz, mmc_hostname(host->mmc));
 
 	if (dw_mci_submit_data_dma(host, data)) {
 		int flags = SG_MITER_ATOMIC;
@@ -1072,24 +942,30 @@ static void dw_mci_submit_data(struct dw_mci *host, struct mmc_data *data)
 static void mci_send_cmd(struct dw_mci_slot *slot, u32 cmd, u32 arg)
 {
 	struct dw_mci *host = slot->host;	
-	unsigned long timeout = jiffies + msecs_to_jiffies(500);//msecs_to_jiffies(5000);
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
 	unsigned int cmd_status = 0;
+
 #ifdef SDMMC_WAIT_FOR_UNBUSY
 	bool ret = true;
 	timeout = jiffies + msecs_to_jiffies(SDMMC_WAIT_FOR_UNBUSY);
 	
-    if(test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {
-        while (ret) {
-		ret =  time_before(jiffies, timeout);
-        	cmd_status = mci_readl(host, STATUS);
-        	if (!(cmd_status & (SDMMC_STAUTS_DATA_BUSY|SDMMC_STAUTS_MC_BUSY)))
-        		break;
-        } ;
-        if(false == ret)
-            printk("%d..%s:  wait for unbusy timeout.......[%s]\n", \
-                __LINE__, __FUNCTION__, mmc_hostname(host->mmc));
-    }
-#endif    
+	if (test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {
+		while (ret) {
+			ret =  time_before(jiffies, timeout);
+			cmd_status = mci_readl(host, STATUS);
+			if (!(cmd_status &
+				(SDMMC_STAUTS_DATA_BUSY |
+				SDMMC_STAUTS_MC_BUSY)))
+				break;
+		};
+
+		if(false == ret)
+			MMC_DBG_ERR_FUNC(host->mmc,
+				"mci_send_cmd: wait for unbusy timeout! [%s]",
+				mmc_hostname(host->mmc));
+	}
+#endif
+ 
 	mci_writel(host, CMDARG, arg);
 	wmb();
 	mci_writel(host, CMD, SDMMC_CMD_START | cmd);
@@ -1097,11 +973,13 @@ static void mci_send_cmd(struct dw_mci_slot *slot, u32 cmd, u32 arg)
 		timeout = jiffies + msecs_to_jiffies(50);
 	else
 		timeout = jiffies + msecs_to_jiffies(500);
+
 	while (time_before(jiffies, timeout)) {
 		cmd_status = mci_readl(host, CMD);
 		if (!(cmd_status & SDMMC_CMD_START))
-			return ;
+			return;
 	}
+
 	dev_err(&slot->mmc->class_dev,
 		"Timeout sending command (cmd %#x arg %#x status %#x)\n",
 		cmd, arg, cmd_status);
@@ -1115,8 +993,10 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 	u32 clk_en_a;
 	u32 sdio_int;
 
-	MMC_DBG_INFO_FUNC(host->mmc,"%d..%s: clock=%d, current_speed=%d, bus_hz=%d,forc=%d[%s]\n", 
-                __LINE__, __FUNCTION__, clock, host->current_speed,host->bus_hz,force_clkinit,mmc_hostname(host->mmc));
+	MMC_DBG_INFO_FUNC(host->mmc,
+			"%s: clock=%d, current_speed=%d, bus_hz=%d, forc=%d[%s]\n",
+			__FUNCTION__, clock, host->current_speed, host->bus_hz,
+			force_clkinit, mmc_hostname(host->mmc));
 
 	if (!clock) {
 		mci_writel(host, CLKENA, 0);
@@ -1248,12 +1128,14 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 
 	host->current_speed = clock;
 
-    if(slot->ctype != slot->pre_ctype)
-        MMC_DBG_BOOT_FUNC(host->mmc, "Bus speed=%dHz,Bus width=%s.[%s]", 
-            host->set_speed,
-            (slot->ctype == SDMMC_CTYPE_4BIT)?"4bits":"8bits", 
-            mmc_hostname(host->mmc));
-    slot->pre_ctype = slot->ctype;
+	if(slot->ctype != slot->pre_ctype)
+		MMC_DBG_BOOT_FUNC(host->mmc,
+				"Bus speed=%dHz,Bus width=%s.[%s]",
+				host->set_speed,
+				(slot->ctype == SDMMC_CTYPE_4BIT) ? "4bits" : "8bits",
+				mmc_hostname(host->mmc));
+
+	slot->pre_ctype = slot->ctype;
 
 	/* Set the current slot bus width */
 	mci_writel(host, CTYPE, (slot->ctype << slot->id));
@@ -1262,26 +1144,27 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 extern struct mmc_card *this_card;
 static void dw_mci_wait_unbusy(struct dw_mci *host)
 {
-   
-        unsigned int    timeout= SDMMC_DATA_TIMEOUT_SDIO;
-        unsigned long   time_loop;
-        unsigned int    status;
-        u32 se_flag = 0;
-
-        MMC_DBG_INFO_FUNC(host->mmc, "dw_mci_wait_unbusy, status=0x%x ", mci_readl(host, STATUS));
+        unsigned int timeout = SDMMC_DATA_TIMEOUT_SDIO;
+        unsigned long time_loop;
+        unsigned int status;
+        unsigned int tmo = 300000;
+	/* Secure erase flag */
+	u32 se_flag = 0;
+
+        MMC_DBG_INFO_FUNC(host->mmc,
+		"dw_mci_wait_unbusy, status=0x%x ", mci_readl(host, STATUS));
     
         if (host->mmc->restrict_caps & RESTRICT_CARD_TYPE_EMMC) {
-                if (host->cmd && (host->cmd->opcode == MMC_ERASE)) {
+                if (host->cmd && (host->cmd->opcode == MMC_ERASE) && this_card) {
                 /* Special care for (secure)erase timeout calculation */
-                        if(this_card){
-                                if((host->cmd->arg & (0x1 << 31)) == 1) /* secure erase */
-                                        se_flag = 0x1;
-
-                                if (((this_card->ext_csd.erase_group_def) & 0x1) == 1)
-                                        se_flag ? (timeout = (this_card->ext_csd.hc_erase_timeout) *
-                                                        300000 * (this_card->ext_csd.sec_erase_mult)) :
-                                                        (timeout = (this_card->ext_csd.hc_erase_timeout) * 300000);
-                        }
+			if ((host->cmd->arg & (0x1 << 31)) == 1)
+				se_flag = 0x1;
+
+			if (((this_card->ext_csd.erase_group_def) & 0x1) == 1)
+				se_flag ?
+				(timeout = (this_card->ext_csd.hc_erase_timeout) *
+				tmo * (this_card->ext_csd.sec_erase_mult)) :
+				(timeout = (this_card->ext_csd.hc_erase_timeout) * tmo);
                 }
         
                 if(timeout < SDMMC_DATA_TIMEOUT_EMMC)
@@ -1298,8 +1181,6 @@ static void dw_mci_wait_unbusy(struct dw_mci *host)
         } while (time_before(jiffies, time_loop));
 }
 
-
-
 #ifdef CONFIG_MMC_DW_ROCKCHIP_SWITCH_VOLTAGE
 /*
 *   result: 
@@ -1379,8 +1260,9 @@ static void dw_mci_start_request(struct dw_mci *host,
 	struct mmc_request *mrq = slot->mrq;
 	struct mmc_command *cmd;
 
-	MMC_DBG_INFO_FUNC(host->mmc, " Begin to start the new request. cmd=%d(arg=0x%x)[%s]", \
-                mrq->cmd->opcode, mrq->cmd->arg, mmc_hostname(host->mmc));
+	MMC_DBG_INFO_FUNC(host->mmc,
+		" Begin to start the new request. cmd=%d(arg=0x%x)[%s]",
+		mrq->cmd->opcode, mrq->cmd->arg, mmc_hostname(host->mmc));
         
 	cmd = mrq->sbc ? mrq->sbc : mrq->cmd;
 	__dw_mci_start_request(host, slot, cmd);
@@ -1420,15 +1302,16 @@ static void dw_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	if (!test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {
 		spin_unlock_bh(&host->lock);
 		mrq->cmd->error = -ENOMEDIUM;		
-		MMC_DBG_CMD_FUNC(host->mmc, "%d..%s: no card,so reqeuest done, cmd=%d [%s]",\
-		    __LINE__, __FUNCTION__, mrq->cmd->opcode, mmc_hostname(host->mmc));
+		MMC_DBG_CMD_FUNC(host->mmc, "%s: no card,so reqeuest done, cmd=%d [%s]",
+				__FUNCTION__, mrq->cmd->opcode, mmc_hostname(host->mmc));
             
 		mmc_request_done(mmc, mrq);
 		return;
 	}
 
-	MMC_DBG_CMD_FUNC(host->mmc, "======>\n    pull a new request from MMC-frame to dw_mci_queue. cmd=%d(arg=0x%x)[%s]", \
-                                mrq->cmd->opcode, mrq->cmd->arg, mmc_hostname(host->mmc));
+	MMC_DBG_CMD_FUNC(host->mmc,
+		"======>\n    pull a new request from MMC-frame to dw_mci_queue. cmd=%d(arg=0x%x)[%s]",
+		mrq->cmd->opcode, mrq->cmd->arg, mmc_hostname(host->mmc));
 
 	dw_mci_queue_request(host, slot, mrq);
 
@@ -1466,7 +1349,8 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	while (ret) {
 		ret = time_before(jiffies, time_loop);
 		regs = mci_readl(slot->host, STATUS);
-		if (!(regs & (SDMMC_STAUTS_DATA_BUSY|SDMMC_STAUTS_MC_BUSY)))
+		if (!(regs & (SDMMC_STAUTS_DATA_BUSY |
+			SDMMC_STAUTS_MC_BUSY)))
     			break;
 	};
 	
@@ -1476,9 +1360,9 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		#ifdef CONFIG_MMC_DW_ROCKCHIP_SWITCH_VOLTAGE
                 if(host->svi_flags != 1)
                 #endif
-                        dump_stack();
-		printk("%d..%s:  wait for unbusy timeout....... STATUS = 0x%x [%s]\n", \
-			__LINE__, __FUNCTION__, regs, mmc_hostname(mmc));
+			dump_stack();
+		printk("%s:  wait for unbusy timeout....... STATUS = 0x%x [%s]\n",
+			 __FUNCTION__, regs, mmc_hostname(mmc));
 	}
         #endif
         
@@ -1521,25 +1405,25 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 EXIT_POWER:
 	switch (ios->power_mode) {
-	        case MMC_POWER_UP:
-                        set_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);
-                        /* Power up slot */
-		        if (slot->host->pdata->setpower)
-			        slot->host->pdata->setpower(slot->id, mmc->ocr_avail);
-		        regs = mci_readl(slot->host, PWREN);
-		        regs |= (1 << slot->id);
-		        mci_writel(slot->host, PWREN, regs);
-		        break;
-                case MMC_POWER_OFF:
-		        /* Power down slot */
-		        if(slot->host->pdata->setpower)
-			        slot->host->pdata->setpower(slot->id, 0);
-		        regs = mci_readl(slot->host, PWREN);
-		        regs &= ~(1 << slot->id);
-		        mci_writel(slot->host, PWREN, regs);		
-		        break;
-	        default:
-		        break;
+	case MMC_POWER_UP:
+	/* Power up slot */
+		set_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);
+		if (slot->host->pdata->setpower)
+			slot->host->pdata->setpower(slot->id, mmc->ocr_avail);
+		regs = mci_readl(slot->host, PWREN);
+		regs |= (1 << slot->id);
+		mci_writel(slot->host, PWREN, regs);
+		break;
+	case MMC_POWER_OFF:
+	/* Power down slot */
+		if(slot->host->pdata->setpower)
+			slot->host->pdata->setpower(slot->id, 0);
+		regs = mci_readl(slot->host, PWREN);
+		regs &= ~(1 << slot->id);
+		mci_writel(slot->host, PWREN, regs);
+		break;
+	default:
+		break;
 	}
 }
 
@@ -1568,57 +1452,56 @@ static int dw_mci_get_ro(struct mmc_host *mmc)
 
 static int dw_mci_set_sdio_status(struct mmc_host *mmc, int val)
 {
-        struct dw_mci_slot *slot = mmc_priv(mmc);
-        struct dw_mci *host = slot->host;
-	/*struct dw_mci_board *brd = slot->host->pdata;*/
+	struct dw_mci_slot *slot = mmc_priv(mmc);
+	struct dw_mci *host = slot->host;
 
 	if (!(mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO))
-                return 0;
+		return 0;
                 
-        spin_lock_bh(&host->lock);
+	spin_lock_bh(&host->lock);
 
-        if(val)
-                set_bit(DW_MMC_CARD_PRESENT, &slot->flags);
-        else
-                clear_bit(DW_MMC_CARD_PRESENT, &slot->flags);
+	if(val)
+		set_bit(DW_MMC_CARD_PRESENT, &slot->flags);
+	else
+		clear_bit(DW_MMC_CARD_PRESENT, &slot->flags);
 
-        spin_unlock_bh(&host->lock);
+	spin_unlock_bh(&host->lock);
 
-        if (test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {
+	if (test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {
 		if (__clk_is_enabled(host->hclk_mmc) == false)
-                        clk_prepare_enable(host->hclk_mmc);
+			clk_prepare_enable(host->hclk_mmc);
 		if (__clk_is_enabled(host->clk_mmc) == false)
-                        clk_prepare_enable(host->clk_mmc);
-        } else {
+			clk_prepare_enable(host->clk_mmc);
+	} else {
 		if (__clk_is_enabled(host->clk_mmc) == true)
-                        clk_disable_unprepare(slot->host->clk_mmc);
+			clk_disable_unprepare(slot->host->clk_mmc);
 		if (__clk_is_enabled(host->hclk_mmc) == true)
-                        clk_disable_unprepare(slot->host->hclk_mmc);
-        }
+			clk_disable_unprepare(slot->host->hclk_mmc);
+	}
 
-        mmc_detect_change(slot->mmc, 20);
-        return 0;
+	mmc_detect_change(slot->mmc, 20);
+	return 0;
 }
 
 
 
 static int dw_mci_get_cd(struct mmc_host *mmc)
 {
-        int present;
-        struct dw_mci_slot *slot = mmc_priv(mmc);
-        struct dw_mci_board *brd = slot->host->pdata;
-        struct dw_mci *host = slot->host;
-        int gpio_cd = mmc_gpio_get_cd(mmc);
+	int present;
+	struct dw_mci_slot *slot = mmc_priv(mmc);
+	struct dw_mci_board *brd = slot->host->pdata;
+	struct dw_mci *host = slot->host;
+	int gpio_cd = mmc_gpio_get_cd(mmc);
 	int force_jtag_bit, force_jtag_reg;
-        int gpio_val;
+	int gpio_val;
 	int irq;
 
-        if ((soc_is_rk3126() || soc_is_rk3126b() || soc_is_rk3036()) &&
-                (mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
+	if ((soc_is_rk3126() || soc_is_rk3126b() || soc_is_rk3036()) &&
+		(mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
 		gpio_cd = slot->cd_gpio;
 		irq = gpio_to_irq(gpio_cd);
 		if (gpio_is_valid(gpio_cd)) {
-                        gpio_val = gpio_get_value(gpio_cd);
+			gpio_val = gpio_get_value(gpio_cd);
 			if (soc_is_rk3036()) {
 				force_jtag_bit = 11;
 				force_jtag_reg = RK312X_GRF_SOC_CON0;
@@ -1626,37 +1509,36 @@ static int dw_mci_get_cd(struct mmc_host *mmc)
 				force_jtag_reg = RK312X_GRF_SOC_CON0;
 				force_jtag_bit = 8;
 			}
-                        msleep(10);
-                        if (gpio_val == gpio_get_value(gpio_cd)) {
-                                gpio_cd = (gpio_val == 0 ? 1 : 0);
-                                if (gpio_cd == 0) {
-                                        irq_set_irq_type(irq, IRQF_TRIGGER_LOW | IRQF_ONESHOT);
+			msleep(10);
+			if (gpio_val == gpio_get_value(gpio_cd)) {
+				gpio_cd = (gpio_val == 0 ? 1 : 0);
+				if (gpio_cd == 0) {
+					irq_set_irq_type(irq, IRQF_TRIGGER_LOW | IRQF_ONESHOT);
 					/* Enable force_jtag wihtout card in slot, ONLY for NCD-package */
 					grf_writel((0x1 << (force_jtag_bit + 16)) | (1 << force_jtag_bit), 
 							force_jtag_reg);
-
-                                        dw_mci_ctrl_all_reset(host);
-                                } else {
+					dw_mci_ctrl_all_reset(host);
+				} else {
 					irq_set_irq_type(irq, IRQF_TRIGGER_HIGH | IRQF_ONESHOT);
-                                        /* Really card detected: SHOULD disable force_jtag */
-                                        grf_writel((0x1 << (force_jtag_bit + 16)) | (0 << force_jtag_bit),
+					/* Really card detected: SHOULD disable force_jtag */
+					grf_writel((0x1 << (force_jtag_bit + 16)) | (0 << force_jtag_bit),
 							force_jtag_reg);
-                                }
-                        } else {
-                                /* Jitter */
+				}
+			} else {
+				/* Jitter */
 				gpio_val = gpio_get_value(gpio_cd);
 				(gpio_val == 0) ? 
 					irq_set_irq_type(irq, IRQF_TRIGGER_HIGH  | IRQF_ONESHOT) :
 					irq_set_irq_type(irq, IRQF_TRIGGER_LOW  | IRQF_ONESHOT);
                                 return slot->last_detect_state;
                         }
-                } else {
-                        dev_err(host->dev, "dw_mci_get_cd: invalid gpio_cd!\n");
-                }
-        }
+		} else {
+			dev_err(host->dev, "dw_mci_get_cd: invalid gpio_cd!\n");
+		}
+	}
 
-        if (mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
-                return test_bit(DW_MMC_CARD_PRESENT, &slot->flags);
+	if (mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
+		return test_bit(DW_MMC_CARD_PRESENT, &slot->flags);
 
 	/* Use platform get_cd function, else try onboard card detect */
 	if (brd->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)
@@ -1666,8 +1548,8 @@ static int dw_mci_get_cd(struct mmc_host *mmc)
 	else if (!IS_ERR_VALUE(gpio_cd))
 		present = gpio_cd;
 	else
-		present = (mci_readl(slot->host, CDETECT) & (1 << slot->id))
-			== 0 ? 1 : 0;
+		present = ((mci_readl(slot->host, CDETECT) & (1 << slot->id))
+			== 0) ? 1 : 0;
 
 	spin_lock_bh(&host->lock);
 	if (present) {
@@ -1815,12 +1697,12 @@ static void dw_mci_enable_sdio_irq(struct mmc_host *mmc, int enb)
 	u32 int_mask;
 	u32 sdio_int;
 
-        spin_lock_irqsave(&host->slock, flags);
+	spin_lock_irqsave(&host->slock, flags);
 
 	/* Enable/disable Slot Specific SDIO interrupt */
 	int_mask = mci_readl(host, INTMASK);
 
-        if (host->verid < DW_MMC_240A)
+	if (host->verid < DW_MMC_240A)
 		sdio_int = SDMMC_INT_SDIO(slot->id);
 	else
 		sdio_int = SDMMC_INT_SDIO((slot->id) + 8);
@@ -1846,43 +1728,46 @@ static void dw_mci_enable_sdio_irq(struct mmc_host *mmc, int enb)
 
 #ifdef CONFIG_MMC_DW_ROCKCHIP_SWITCH_VOLTAGE
 enum{
-        IO_DOMAIN_12 = 1200,
-        IO_DOMAIN_18 = 1800,
-        IO_DOMAIN_33 = 3300,
+	IO_DOMAIN_12 = 1200,
+	IO_DOMAIN_18 = 1800,
+	IO_DOMAIN_33 = 3300,
 };
 static void dw_mci_do_grf_io_domain_switch(struct dw_mci *host, u32 voltage)
 {
-        switch(voltage){
-                case IO_DOMAIN_33:
-                        voltage = 0;
-                        break;
-                case IO_DOMAIN_18:
-                        voltage = 1;
-                        break;
-                case IO_DOMAIN_12:
-                        MMC_DBG_ERR_FUNC(host->mmc,"%s : Not support io domain voltage [%s]\n",
-                                                        __FUNCTION__, mmc_hostname(host->mmc));
-                        break;
-                default:
-                        MMC_DBG_ERR_FUNC(host->mmc,"%s : Err io domain voltage [%s]\n",
-                                                        __FUNCTION__, mmc_hostname(host->mmc));
-                        break;
-        }
+	switch(voltage){
+	case IO_DOMAIN_33:
+		voltage = 0;
+		break;
+	case IO_DOMAIN_18:
+		voltage = 1;
+		break;
+	case IO_DOMAIN_12:
+		MMC_DBG_ERR_FUNC(host->mmc,
+			"%s : Not support io domain voltage [%s]\n",
+			__FUNCTION__, mmc_hostname(host->mmc));
+		break;
+	default:
+		MMC_DBG_ERR_FUNC(host->mmc,
+			"%s : Err io domain voltage [%s]\n",
+			__FUNCTION__, mmc_hostname(host->mmc));
+		break;
+	}
 
-        if (cpu_is_rk3288()) {
-                if(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)	   
-                        grf_writel((voltage << 7) | (1 << 23), RK3288_GRF_IO_VSEL);
-                else
-                        return ;
-        } else if (host->cid == DW_MCI_TYPE_RK3368) {
+	if (cpu_is_rk3288()) {
+		if(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)
+			grf_writel((voltage << 7) | (1 << 23), RK3288_GRF_IO_VSEL);
+		else
+			return ;
+	} else if (host->cid == DW_MCI_TYPE_RK3368) {
 		if(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)
 			 regmap_write(host->grf, 0x900, (voltage << 6) | (1 << 22));	
 		else
 			return;
 	} else {
-                MMC_DBG_ERR_FUNC(host->mmc,"%s : unknown chip [%s]\n",
-                                        __FUNCTION__, mmc_hostname(host->mmc));
-        }
+		MMC_DBG_ERR_FUNC(host->mmc,
+			"%s : unknown chip [%s]\n",
+			__FUNCTION__, mmc_hostname(host->mmc));
+	}
 }
 
 static int dw_mci_do_start_signal_voltage_switch(struct dw_mci *host,
@@ -1899,114 +1784,117 @@ static int dw_mci_do_start_signal_voltage_switch(struct dw_mci *host,
 		return 0;
 
 	uhs_reg = mci_readl(host, UHS_REG);
-	MMC_DBG_SW_VOL_FUNC(host->mmc,"%d..%s: vol=%d.[%s]\n",
-	        __LINE__, __FUNCTION__,ios->signal_voltage, mmc_hostname(host->mmc));
+	MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: vol=%d.[%s]\n",
+		 __FUNCTION__, ios->signal_voltage, mmc_hostname(host->mmc));
 
 	switch (ios->signal_voltage) {
-        case MMC_SIGNAL_VOLTAGE_330:
-        	/* Set 1.8V Signal Enable in the Host Control2 register to 0 */
+	case MMC_SIGNAL_VOLTAGE_330:
+	/* Set 1.8V Signal Enable in the Host Control2 register to 0 */
         	if (host->vmmc) {
 			if (cpu_is_rk3288())
 				ret = io_domain_regulator_set_voltage(
 						host->vmmc, 3300000, 3300000);
 			else
-				ret = regulator_set_voltage(host->vmmc, 3300000, 3300000);
-
-			/* regulator_put(host->vmmc); //to be done in remove function. */
+				ret = regulator_set_voltage(host->vmmc,
+							3300000, 3300000);
 
-        		MMC_DBG_SW_VOL_FUNC(host->mmc,"%s   =%dmV  set 3.3end, ret=%d  \n", 
-        		    __func__, regulator_get_voltage(host->vmmc), ret);
+			/* regulator_put(host->vmmc); */
+			MMC_DBG_SW_VOL_FUNC(host->mmc,"%s =%dmV set 3.3 end, ret = %d\n",
+				__func__, regulator_get_voltage(host->vmmc), ret);
         		if (ret) {
-        			MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: Switching to 3.3V signalling voltage "
-        					" failed\n", mmc_hostname(host->mmc));
-        			return -EIO;
+				MMC_DBG_SW_VOL_FUNC(host->mmc,
+					"%s: Switching to 3.3V signalling voltage "
+					" failed\n", mmc_hostname(host->mmc));
+				return -EIO;
         		}
-        		dw_mci_do_grf_io_domain_switch(host, IO_DOMAIN_33);
-        	}
-        	MMC_DBG_SW_VOL_FUNC(host->mmc,"%d..%s: [%s]\n",__LINE__, 
-        	                        __FUNCTION__, mmc_hostname(host->mmc));
-
-        	/* set High-power mode */
-        	value = mci_readl(host, CLKENA);
-        	value &= ~SDMMC_CLKEN_LOW_PWR;
-        	mci_writel(host,CLKENA , value);
-        	/* SDMMC_UHS_REG */
-        	uhs_reg &= ~SDMMC_UHS_VOLT_REG_18; 
-        	mci_writel(host,UHS_REG , uhs_reg);
-        	
-        	/* Wait for 5ms */
-        	usleep_range(5000, 5500);
-
-        	/* 3.3V regulator output should be stable within 5 ms */
-        	uhs_reg = mci_readl(host, UHS_REG);
-        	if( !(uhs_reg & SDMMC_UHS_VOLT_REG_18))
-                        return 0;	
-
-        	MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: 3.3V regulator output did not became stable\n",
-        			mmc_hostname(host->mmc));
-
-        	return -EAGAIN;
-        case MMC_SIGNAL_VOLTAGE_180:
-        	if (host->vmmc) {
+			dw_mci_do_grf_io_domain_switch(host, IO_DOMAIN_33);
+		}
+
+		MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: [%s]\n",
+				__FUNCTION__, mmc_hostname(host->mmc));
+
+		/* set High-power mode */
+		value = mci_readl(host, CLKENA);
+		value &= ~SDMMC_CLKEN_LOW_PWR;
+		mci_writel(host,CLKENA , value);
+		/* SDMMC_UHS_REG */
+		uhs_reg &= ~SDMMC_UHS_VOLT_REG_18;
+		mci_writel(host,UHS_REG , uhs_reg);
+
+		/* Wait for 5ms */
+		usleep_range(5000, 5500);
+
+		/* 3.3V regulator output should be stable within 5 ms */
+		uhs_reg = mci_readl(host, UHS_REG);
+		if( !(uhs_reg & SDMMC_UHS_VOLT_REG_18))
+			return 0;
+
+		MMC_DBG_SW_VOL_FUNC(host->mmc,
+			"%s: 3.3V regulator output did not became stable\n",
+			mmc_hostname(host->mmc));
+
+		return -EAGAIN;
+	case MMC_SIGNAL_VOLTAGE_180:
+		if (host->vmmc) {
 			if (cpu_is_rk3288())
 				ret = io_domain_regulator_set_voltage(
-							host->vmmc,
-							1800000, 1800000);
+					host->vmmc, 1800000, 1800000);
 			else
 				ret = regulator_set_voltage(
-							host->vmmc,
-							1800000, 1800000);
-                        /* regulator_put(host->vmmc);//to be done in remove function. */
+						host->vmmc, 1800000, 1800000);
+			/* regulator_put(host->vmmc); */
+			MMC_DBG_SW_VOL_FUNC(host->mmc,
+					"%s   =%dmV  set 1.8end, ret=%d . \n",
+					__func__, regulator_get_voltage(host->vmmc), ret);
+			if (ret) {
+				MMC_DBG_SW_VOL_FUNC(host->mmc,
+					"%s: Switching to 1.8V signalling voltage "
+					" failed\n", mmc_hostname(host->mmc));
+				return -EIO;
+			}
+			dw_mci_do_grf_io_domain_switch(host, IO_DOMAIN_18);
+		}
 
-        		MMC_DBG_SW_VOL_FUNC(host->mmc,"%d..%s   =%dmV  set 1.8end, ret=%d . \n",
-        		    __LINE__, __func__, regulator_get_voltage(host->vmmc), ret);
-        		if (ret) {
-        			MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: Switching to 1.8V signalling voltage "
-        					" failed\n", mmc_hostname(host->mmc));
-        			return -EIO;
-        		}
-        		dw_mci_do_grf_io_domain_switch(host, IO_DOMAIN_18);
-        	}
-
-        	/*
-        	 * Enable 1.8V Signal Enable in the Host Control2
-        	 * register
-        	 */
-                mci_writel(host,UHS_REG , uhs_reg | SDMMC_UHS_VOLT_REG_18);
-
-        	/* Wait for 5ms */
-        	usleep_range(5000, 5500);
-                MMC_DBG_SW_VOL_FUNC(host->mmc,"%d..%s: .[%s]\n",__LINE__, 
-                                        __FUNCTION__,mmc_hostname(host->mmc));
-
-        	/* 1.8V regulator output should be stable within 5 ms */
-        	uhs_reg = mci_readl(host, UHS_REG);
-        	if(uhs_reg & SDMMC_UHS_VOLT_REG_18)
-        	        return 0;
-      
-        	MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: 1.8V regulator output did not became stable\n",
-        			mmc_hostname(host->mmc));
-
-        	return -EAGAIN;
-        case MMC_SIGNAL_VOLTAGE_120:
-        	if (host->vmmc) {
+		/*
+		* Enable 1.8V Signal Enable in the Host Control2
+		* register
+		*/
+		mci_writel(host,UHS_REG , uhs_reg | SDMMC_UHS_VOLT_REG_18);
+
+		/* Wait for 5ms */
+		usleep_range(5000, 5500);
+		MMC_DBG_SW_VOL_FUNC(host->mmc, "%d..%s: .[%s]\n",__LINE__,
+				__FUNCTION__, mmc_hostname(host->mmc));
+
+		/* 1.8V regulator output should be stable within 5 ms */
+		uhs_reg = mci_readl(host, UHS_REG);
+		if (uhs_reg & SDMMC_UHS_VOLT_REG_18)
+			return 0;
+
+		MMC_DBG_SW_VOL_FUNC(host->mmc,
+			"%s: 1.8V regulator output did not became stable\n",
+			mmc_hostname(host->mmc));
+
+		return -EAGAIN;
+	case MMC_SIGNAL_VOLTAGE_120:
+		if (host->vmmc) {
 			if (cpu_is_rk3288())
 				ret = io_domain_regulator_set_voltage(
-							host->vmmc,
-							1200000, 1200000);
+					host->vmmc, 1200000, 1200000);
 			else
 				ret = regulator_set_voltage(host->vmmc,
-							1200000, 1200000);
-        		if (ret) {
-        			MMC_DBG_SW_VOL_FUNC(host->mmc, "%s: Switching to 1.2V signalling voltage "
-        					" failed\n", mmc_hostname(host->mmc));
-        			return -EIO;
-        		}
-        	}
-        	return 0;
-        default:
-        	/* No signal voltage switch required */
-        	return 0;
+					1200000, 1200000);
+			if (ret) {
+				MMC_DBG_SW_VOL_FUNC(host->mmc,
+					"%s: Switching to 1.2V signalling voltage "
+					" failed\n", mmc_hostname(host->mmc));
+				return -EIO;
+			}
+		}
+		return 0;
+	default:
+		/* No signal voltage switch required */
+		return 0;
 	}
 }
 
@@ -2174,7 +2062,6 @@ static void dw_mci_post_tmo(struct mmc_host *mmc)
 
 	printk("[%s] -- Timeout recovery procedure finished --\n",
 		mmc_hostname(host->mmc));
-
 }
 
 static const struct mmc_host_ops dw_mci_ops = {
@@ -2184,60 +2071,25 @@ static const struct mmc_host_ops dw_mci_ops = {
 	.set_ios		= dw_mci_set_ios,
 	.get_ro			= dw_mci_get_ro,
 	.get_cd			= dw_mci_get_cd,
-	.set_sdio_status    = dw_mci_set_sdio_status,
-	.hw_reset       = dw_mci_hw_reset,
+	.set_sdio_status	= dw_mci_set_sdio_status,
+	.hw_reset		= dw_mci_hw_reset,
 	.enable_sdio_irq	= dw_mci_enable_sdio_irq,
 	.execute_tuning		= dw_mci_execute_tuning,
         .post_tmo		= dw_mci_post_tmo,
 	#ifdef CONFIG_MMC_DW_ROCKCHIP_SWITCH_VOLTAGE
-        .start_signal_voltage_switch	= dw_mci_start_signal_voltage_switch,
-        .card_busy  = dw_mci_card_busy,
+        .start_signal_voltage_switch
+				= dw_mci_start_signal_voltage_switch,
+        .card_busy		= dw_mci_card_busy,
         #endif
 };
 
-#if 0
-static void dw_mci_enable_irq(struct dw_mci *host, bool irqflag)
-{
-	unsigned long flags;
-
-    if(!host)
-        return;
-    
-	local_irq_save(flags);
-	if(host->irq_state != irqflag)
-	{
-	    host->irq_state = irqflag;
-	    if(irqflag)
-	    {
-	        enable_irq(host->irq);
-	    }
-	    else
-	    {
-	        disable_irq(host->irq);
-	    }
-	}
-	local_irq_restore(flags);
-}
-#endif
-
 static void dw_mci_deal_data_end(struct dw_mci *host, struct mmc_request *mrq)
 	__releases(&host->lock)
 	__acquires(&host->lock)
 {
-        if(DW_MCI_SEND_STATUS == host->dir_status){
-	    #if 0
-	    if( MMC_BUS_TEST_W != host->cmd->opcode){
-	        if(host->data_status & SDMMC_INT_DCRC)
-	            host->data->error = -EILSEQ;
-	        else if(host->data_status & SDMMC_INT_EBE)
-	            host->data->error = -ETIMEDOUT;
-	    } else {
-	        dw_mci_wait_unbusy(host); 
-	    }
-	    #else
-	    dw_mci_wait_unbusy(host);
-	    #endif
-        }
+	if (DW_MCI_SEND_STATUS == host->dir_status){
+		dw_mci_wait_unbusy(host);
+	}
 }
 
 static void dw_mci_request_end(struct dw_mci *host, struct mmc_request *mrq)
@@ -2249,14 +2101,20 @@ static void dw_mci_request_end(struct dw_mci *host, struct mmc_request *mrq)
 
 	//WARN_ON(host->cmd || host->data);
 
-        dw_mci_deal_data_end(host, mrq);
-
-        if(mrq->cmd)
-                MMC_DBG_CMD_FUNC(host->mmc, " reqeust end--reqeuest done, cmd=%d, cmderr=%d, host->state=%d [%s]",\
-                        mrq->cmd->opcode,mrq->cmd->error, host->state,mmc_hostname(host->mmc));
-        if(mrq->data)
-                MMC_DBG_CMD_FUNC(host->mmc, " reqeust end--reqeuest done, cmd=%d, dataerr=%d, host->state=%d [%s]",\
-                        mrq->cmd->opcode,mrq->data->error, host->state, mmc_hostname(host->mmc));
+	dw_mci_deal_data_end(host, mrq);
+
+	if(mrq->cmd)
+		MMC_DBG_CMD_FUNC(host->mmc,
+			" reqeust end--reqeuest done, cmd=%d, "
+			"cmderr=%d, host->state=%d [%s]",
+			mrq->cmd->opcode, mrq->cmd->error,
+			host->state,mmc_hostname(host->mmc));
+	if(mrq->data)
+		MMC_DBG_CMD_FUNC(host->mmc,
+			" reqeust end--reqeuest done, cmd=%d, "
+			"dataerr=%d, host->state=%d [%s]",
+			mrq->cmd->opcode,mrq->data->error,
+			host->state, mmc_hostname(host->mmc));
 
 	host->cur_slot->mrq = NULL;
 	host->mrq = NULL;
@@ -2267,14 +2125,16 @@ static void dw_mci_request_end(struct dw_mci *host, struct mmc_request *mrq)
 		dev_vdbg(host->dev, "list not empty: %s is next\n",
 			 mmc_hostname(slot->mmc));
 		host->state = STATE_SENDING_CMD;
-		MMC_DBG_CMD_FUNC(host->mmc, " list is not empty. run the request in list. [%s]", mmc_hostname(host->mmc));
+		MMC_DBG_CMD_FUNC(host->mmc,
+			" list is not empty. run the request in list. [%s]",
+			mmc_hostname(host->mmc));
 		dw_mci_start_request(host, slot);
 	} else {
 		dev_vdbg(host->dev, "list empty\n");
 		host->state = STATE_IDLE;
 	}
 
-        spin_unlock(&host->lock);
+	spin_unlock(&host->lock);
 	mmc_request_done(prev_mmc, mrq);
 	spin_lock(&host->lock);
 }
@@ -2293,24 +2153,28 @@ static void dw_mci_command_complete(struct dw_mci *host, struct mmc_command *cmd
 			cmd->resp[1] = mci_readl(host, RESP2);
 			cmd->resp[0] = mci_readl(host, RESP3);
 			
-            MMC_DBG_INFO_FUNC(host->mmc,"Line%d: command complete cmd=%d,resp[3]=0x%x, resp[2]=0x%x,resp[1]=0x%x,resp[0]=0x%x.[%s]", \
-                    __LINE__,cmd->opcode,cmd->resp[3], cmd->resp[2], cmd->resp[1], cmd->resp[0], mmc_hostname(host->mmc));
-		} else {
-			cmd->resp[0] = mci_readl(host, RESP0);
-			cmd->resp[1] = 0;
-			cmd->resp[2] = 0;
-			cmd->resp[3] = 0;			
-            MMC_DBG_INFO_FUNC(host->mmc, "Line%d: command complete cmd=%d,resp[0]=0x%x. [%s]",\
-                    __LINE__,cmd->opcode, cmd->resp[0], mmc_hostname(host->mmc));
+            MMC_DBG_INFO_FUNC(host->mmc,
+		"Command complete cmd=%d, "
+		"resp[3]=0x%x, resp[2]=0x%x,resp[1]=0x%x,resp[0]=0x%x.[%s]",
+		cmd->opcode,cmd->resp[3], cmd->resp[2], cmd->resp[1], cmd->resp[0],
+		mmc_hostname(host->mmc));
+	} else {
+		cmd->resp[0] = mci_readl(host, RESP0);
+		cmd->resp[1] = 0;
+		cmd->resp[2] = 0;
+		cmd->resp[3] = 0;
+		MMC_DBG_INFO_FUNC(host->mmc,
+			"Command complete cmd=%d,resp[0]=0x%x. [%s]",
+			cmd->opcode, cmd->resp[0], mmc_hostname(host->mmc));
 		}
 	}
 
 	if (status & SDMMC_INT_RTO)
 	{
-	    if(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
-	        host->cmd_rto += 1;
+		if(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO)
+			host->cmd_rto += 1;
 
-	        cmd->error = -ETIMEDOUT;
+		cmd->error = -ETIMEDOUT;
 	}else if ((cmd->flags & MMC_RSP_CRC) && (status & SDMMC_INT_RCRC)){
 		cmd->error = -EILSEQ;
         }else if (status & SDMMC_INT_RESP_ERR){
@@ -2318,22 +2182,24 @@ static void dw_mci_command_complete(struct dw_mci *host, struct mmc_command *cmd
         }else{
 		cmd->error = 0;
 	}
-        MMC_DBG_CMD_FUNC(host->mmc, " command complete, cmd=%d,cmdError=%d [%s]",
-                                cmd->opcode, cmd->error,mmc_hostname(host->mmc));
+
+        MMC_DBG_CMD_FUNC(host->mmc,
+			"Command complete, cmd=%d,cmdError=%d [%s]",
+			cmd->opcode, cmd->error, mmc_hostname(host->mmc));
 
 	if (cmd->error) {
-	    if(MMC_SEND_STATUS != cmd->opcode)
-	        if(host->cmd_rto >= SDMMC_CMD_RTO_MAX_HOLD){
-	                MMC_DBG_CMD_FUNC(host->mmc, " command complete, cmd=%d,cmdError=%d [%s]",\
-                                cmd->opcode, cmd->error,mmc_hostname(host->mmc));
-                        host->cmd_rto = 0;
-    	        }
-	        
+		if(MMC_SEND_STATUS != cmd->opcode)
+			if(host->cmd_rto >= SDMMC_CMD_RTO_MAX_HOLD){
+				MMC_DBG_CMD_FUNC(host->mmc,
+					"Command complete, cmd=%d,cmdError=%d [%s]",
+					cmd->opcode, cmd->error, mmc_hostname(host->mmc));
+				host->cmd_rto = 0;
+			}
+
 		/* newer ip versions need a delay between retries */
 		if (host->quirks & DW_MCI_QUIRK_RETRY_DELAY)
 			mdelay(20);
 	}
-
 }
 
 static void dw_mci_tasklet_func(unsigned long priv)
@@ -2403,38 +2269,42 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			/* fall through */
 
 		case STATE_SENDING_DATA:
-			if (test_and_clear_bit(EVENT_DATA_ERROR, &host->pending_events)) {
+			if (test_and_clear_bit(EVENT_DATA_ERROR,
+				&host->pending_events)) {
 				dw_mci_stop_dma(host);
 				#if 1
 				if (data->stop){
 					send_stop_cmd(host, data);
 				}else{
-                                        /*single block read/write, send stop cmd manually to prevent host controller halt*/
-                                        MMC_DBG_INFO_FUNC(host->mmc, "%s status 1 0x%08x [%s]\n",
-                                                        __func__, mci_readl(host, STATUS), mmc_hostname(host->mmc));
+                                        /*single block read/write, send stop cmd
+					manually to prevent host controller halt*/
+                                        MMC_DBG_INFO_FUNC(host->mmc,
+						"%s status 1 0x%08x [%s]\n",
+						__func__, mci_readl(host, STATUS),
+						mmc_hostname(host->mmc));
                         
 					mci_writel(host, CMDARG, 0);
                                         wmb();
-                                        cmd_flags = SDMMC_CMD_STOP | SDMMC_CMD_RESP_CRC 
-                                                        | SDMMC_CMD_RESP_EXP | MMC_STOP_TRANSMISSION;
+                                        cmd_flags = SDMMC_CMD_STOP | SDMMC_CMD_RESP_CRC |
+						SDMMC_CMD_RESP_EXP | MMC_STOP_TRANSMISSION;
 
-                                        if(host->mmc->hold_reg_flag)
-                                                cmd_flags |= SDMMC_CMD_USE_HOLD_REG;
-				
-                                        mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);
-                                        wmb();
-                                        timeout = jiffies + msecs_to_jiffies(500);
-                        
-                                        while(ret){
-                                                ret = time_before(jiffies, timeout);
-                                                if(!(mci_readl(host, CMD) & SDMMC_CMD_START))
-                                                        break;
-                                        }
-                                        if(false == ret)
-                                                MMC_DBG_ERR_FUNC(host->mmc,
-                                                        "%s EVENT_DATA_ERROR recovery failed!!! [%s]\n",
-                                                        __func__, mmc_hostname(host->mmc));
-                                }
+					if(host->mmc->hold_reg_flag)
+						cmd_flags |= SDMMC_CMD_USE_HOLD_REG;
+
+					mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);
+					wmb();
+					timeout = jiffies + msecs_to_jiffies(500);
+
+					while(ret) {
+						ret = time_before(jiffies, timeout);
+						if (!(mci_readl(host, CMD) & SDMMC_CMD_START))
+							break;
+					}
+					if(false == ret)
+						MMC_DBG_ERR_FUNC(host->mmc,
+							"%s EVENT_DATA_ERROR recovery failed!!! [%s]\n",
+							__func__, mmc_hostname(host->mmc));
+				}
 				#else
 				send_stop_abort(host, data);
 				#endif
@@ -2443,16 +2313,18 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			}
 
 			MMC_DBG_CMD_FUNC(host->mmc, 
-				"Pre-state[%d]-->NowState[%d]: STATE_SENDING_DATA, wait for EVENT_XFER_COMPLETE.[%s]",\
-                        prev_state,state, mmc_hostname(host->mmc));
+				"Pre-state[%d]-->NowState[%d]: STATE_SENDING_DATA, "
+				"wait for EVENT_XFER_COMPLETE.[%s]",
+				prev_state, state, mmc_hostname(host->mmc));
 
 			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
-						&host->pending_events))
+				&host->pending_events))
 				break;
-			MMC_DBG_INFO_FUNC(host->mmc, 
-				"Pre-state[%d]-->NowState[%d]:  STATE_SENDING_DATA, wait for EVENT_DATA_COMPLETE. [%s]",\
-                                          prev_state,state,mmc_hostname(host->mmc));
-            
+			MMC_DBG_INFO_FUNC(host->mmc,
+				"Pre-state[%d]-->NowState[%d]: STATE_SENDING_DATA, "
+				"wait for EVENT_DATA_COMPLETE. [%s]",
+				prev_state, state, mmc_hostname(host->mmc));
+
 			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
 			prev_state = state = STATE_DATA_BUSY;
 			/* fall through */
@@ -2461,23 +2333,26 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
 						&host->pending_events))
 				break;
-				
+
 			dw_mci_deal_data_end(host, host->mrq);			
                         MMC_DBG_INFO_FUNC(host->mmc, 
-				"Pre-state[%d]-->NowState[%d]: STATE_DATA_BUSY, after EVENT_DATA_COMPLETE. [%s]", \
-                                          prev_state,state,mmc_hostname(host->mmc));
+				"Pre-state[%d]-->NowState[%d]: STATE_DATA_BUSY, "
+				"after EVENT_DATA_COMPLETE. [%s]",
+				prev_state, state, mmc_hostname(host->mmc));
 
 			/* host->data = NULL; */
 			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
 			status = host->data_status;
 
-			if (status & DW_MCI_DATA_ERROR_FLAGS) {	
-			    if((SDMMC_CTYPE_1BIT != slot->ctype)&&(MMC_SEND_EXT_CSD == host->mrq->cmd->opcode))
-				MMC_DBG_ERR_FUNC(host->mmc, 
-					"Pre-state[%d]-->NowState[%d]: DW_MCI_DATA_ERROR_FLAGS,datastatus=0x%x [%s]",\
-                            prev_state,state, status, mmc_hostname(host->mmc));
-                            
-		        if (status & SDMMC_INT_DRTO) {
+			if (status & DW_MCI_DATA_ERROR_FLAGS) {
+				if((SDMMC_CTYPE_1BIT != slot->ctype) &&
+					(MMC_SEND_EXT_CSD == host->mrq->cmd->opcode))
+					MMC_DBG_ERR_FUNC(host->mmc,
+					"Pre-state[%d]-->NowState[%d]: DW_MCI_DATA_ERROR_FLAGS,"
+					"datastatus=0x%x [%s]",
+					prev_state, state, status, mmc_hostname(host->mmc));
+
+			if (status & SDMMC_INT_DRTO) {
 					data->error = -ETIMEDOUT;
 				} else if (status & SDMMC_INT_DCRC) {
 					data->error = -EILSEQ;
@@ -2510,19 +2385,23 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			}
 
 			if (!data->stop) {
-		                MMC_DBG_CMD_FUNC(host->mmc, "Pre-state[%d]-->NowState[%d]: no stop and no dataerr, exit. [%s]", \
-                                      prev_state,state,mmc_hostname(host->mmc));
+				MMC_DBG_CMD_FUNC(host->mmc,
+					"Pre-state[%d]-->NowState[%d]: "
+					"no stop and no dataerr, exit [%s]",
+					prev_state, state, mmc_hostname(host->mmc));
 				dw_mci_request_end(host, host->mrq);
 				goto unlock;
 			}
-                        MMC_DBG_CMD_FUNC(host->mmc, "Pre-state[%d]-->NowState[%d]: begin to stop . [%s]", \
-                                                prev_state,state,mmc_hostname(host->mmc));
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"Pre-state[%d]-->NowState[%d]: begin to stop [%s]",
+				prev_state, state, mmc_hostname(host->mmc));
 
 			if (host->mrq->sbc && !data->error) {
 				data->stop->error = 0;
-				
-                        MMC_DBG_CMD_FUNC(host->mmc, "Pre-state[%d]-->NowState[%d]: have stop and sbc, exit. [%s]", \
-                                                prev_state,state,mmc_hostname(host->mmc));
+
+				MMC_DBG_CMD_FUNC(host->mmc,
+					"Pre-state[%d]-->NowState[%d]: have stop and sbc, exit [%s]",
+					prev_state,state,mmc_hostname(host->mmc));
 
 				dw_mci_request_end(host, host->mrq);
 				goto unlock;
@@ -2530,35 +2409,33 @@ static void dw_mci_tasklet_func(unsigned long priv)
 
 			prev_state = state = STATE_SENDING_STOP;
 			if (!data->error)
-			    send_stop_cmd(host, data);
-			#if 0
-			if (data->stop && !data->error) {
-				/* stop command for open-ended transfer*/
-				
-				send_stop_abort(host, data);
-			}
-			#endif
+				send_stop_cmd(host, data);
 			/* fall through */
-                        MMC_DBG_CMD_FUNC(host->mmc, "Pre-state[%d]-->NowState[%d]: begin to STATE_SENDING_STOP . [%s]", \
-                                                prev_state,state,mmc_hostname(host->mmc));
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"Pre-state[%d]-->NowState[%d]: begin to STATE_SENDING_STOP [%s]",
+				prev_state, state, mmc_hostname(host->mmc));
 
 		case STATE_SENDING_STOP:
-			if (!test_and_clear_bit(EVENT_CMD_COMPLETE, &host->pending_events))
+			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
+				&host->pending_events))
 				break;
 
-                        MMC_DBG_CMD_FUNC(host->mmc, "Pre-state[%d]-->NowState[%d]: begin to send cmd12 . [%s]", \
-                                                prev_state, state, mmc_hostname(host->mmc));
-                        
-                        /* CMD error in data command */
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"Pre-state[%d]-->NowState[%d]: begin to send cmd12 [%s]",
+				prev_state, state, mmc_hostname(host->mmc));
+
+			/* CMD error in data command */
 			if (host->mrq->cmd->error && host->mrq->data) {
 				dw_mci_fifo_reset(host);
 			}
 
-			/*host->cmd = NULL;
-			host->data = NULL; */
-                        #if 1
-                        dw_mci_command_complete(host, host->mrq->stop);
-                        #else
+			/*
+			host->cmd = NULL;
+			host->data = NULL;
+			*/
+			#if 1
+			dw_mci_command_complete(host, host->mrq->stop);
+			#else
 			if (host->mrq->stop)
 				dw_mci_command_complete(host, host->mrq->stop);
 			else
@@ -2581,7 +2458,6 @@ static void dw_mci_tasklet_func(unsigned long priv)
 	host->state = state;
 unlock:
 	spin_unlock(&host->lock);
-
 }
 
 /* push final bytes to part_buf, only use during push */
@@ -2957,7 +2833,7 @@ static void dw_mci_write_data_pio(struct dw_mci *host)
 	unsigned int fifo_depth = host->fifo_depth;
 	unsigned int remain, fcnt;
 	
-	if(!host->mmc->bus_refs){
+	if (!host->mmc->bus_refs){
 		printk("Note: %s host->mmc->bus_refs is 0!!!\n", __func__);
 		goto host_put;
 	}
@@ -3042,8 +2918,10 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 			mci_writel(host, RINTSTS, DW_MCI_CMD_ERROR_FLAGS);
 			host->cmd_status = pending;
 			smp_wmb();
-			MMC_DBG_INFO_FUNC(host->mmc,"Line%d..%s cmd_status INT=0x%x,[%s]",
-                                          __LINE__, __FUNCTION__,host->cmd_status,mmc_hostname(host->mmc));
+			MMC_DBG_INFO_FUNC(host->mmc,
+				"%s cmd_status INT=0x%x,[%s]",
+				__FUNCTION__, host->cmd_status,
+				mmc_hostname(host->mmc));
             
 			set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
 		}
@@ -3055,14 +2933,18 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 			smp_wmb();
 			set_bit(EVENT_DATA_ERROR, &host->pending_events);
 
-			MMC_DBG_INFO_FUNC(host->mmc,"Line%d..%s data_status INT=0x%x,[%s]",
-                                          __LINE__, __FUNCTION__,host->data_status,mmc_hostname(host->mmc));
+			MMC_DBG_INFO_FUNC(host->mmc,
+				"%s data_status INT=0x%x,[%s]",
+				 __FUNCTION__, host->data_status,
+				 mmc_hostname(host->mmc));
 			tasklet_schedule(&host->tasklet);
 		}
 
 		if (pending & SDMMC_INT_DATA_OVER) {
 			mci_writel(host, RINTSTS, SDMMC_INT_DATA_OVER);
-			MMC_DBG_CMD_FUNC(host->mmc, "SDMMC_INT_DATA_OVER, INT-pending=0x%x. [%s]",pending,mmc_hostname(host->mmc));
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"SDMMC_INT_DATA_OVER, INT-pending=0x%x [%s]",
+				pending, mmc_hostname(host->mmc));
 			if (!host->data_status)
 				host->data_status = pending;
 			smp_wmb();
@@ -3087,27 +2969,35 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 		}
 
 		if (pending & SDMMC_INT_VSI) {
-    		        MMC_DBG_SW_VOL_FUNC(host->mmc, "SDMMC_INT_VSI, INT-pending=0x%x. [%s]",pending,mmc_hostname(host->mmc));
+			MMC_DBG_SW_VOL_FUNC(host->mmc,
+				"SDMMC_INT_VSI, INT-pending=0x%x. [%s]",
+				pending, mmc_hostname(host->mmc));
 			mci_writel(host, RINTSTS, SDMMC_INT_VSI);
 			dw_mci_cmd_interrupt(host, pending);
 		}
 
 		if (pending & SDMMC_INT_CMD_DONE) {
-    			MMC_DBG_CMD_FUNC(host->mmc, "SDMMC_INT_CMD_DONE, CMD = 0x%x, INT-pending=0x%x. [%s]",mci_readl(host, CMD),pending,mmc_hostname(host->mmc));
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"SDMMC_INT_CMD_DONE, CMD = 0x%x, INT-pending=0x%x. [%s]",
+				mci_readl(host, CMD), pending, mmc_hostname(host->mmc));
 			mci_writel(host, RINTSTS, SDMMC_INT_CMD_DONE);
 			dw_mci_cmd_interrupt(host, pending);
 		}
 
 		if (pending & SDMMC_INT_CD) {
 			mci_writel(host, RINTSTS, SDMMC_INT_CD);
-			MMC_DBG_INFO_FUNC(host->mmc, "SDMMC_INT_CD, INT-pending=0x%x. [%s]", pending, mmc_hostname(host->mmc)); 
+			MMC_DBG_INFO_FUNC(host->mmc,
+				"SDMMC_INT_CD, INT-pending=0x%x. [%s]",
+				pending, mmc_hostname(host->mmc));
 			wake_lock_timeout(&host->mmc->detect_wake_lock, 5 * HZ);
 			queue_work(host->card_workqueue, &host->card_work);
 		}
 		
 		if (pending & SDMMC_INT_HLE) {
 			mci_writel(host, RINTSTS, SDMMC_INT_HLE);
-			MMC_DBG_CMD_FUNC(host->mmc, "SDMMC_INT_HLE INT-pending=0x%x. [%s]\n",pending,mmc_hostname(host->mmc));
+			MMC_DBG_CMD_FUNC(host->mmc,
+				"SDMMC_INT_HLE INT-pending=0x%x. [%s]\n",
+				pending, mmc_hostname(host->mmc));
 			
 		}
 
@@ -3129,16 +3019,16 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 	}
 
 #ifdef CONFIG_MMC_DW_IDMAC
-        /* External DMA Soc platform NOT need to ack interrupt IDSTS */
-        if(!(cpu_is_rk3036() || cpu_is_rk312x())){
-                /* Handle DMA interrupts */
-                pending = mci_readl(host, IDSTS);
-                if (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {
-                        mci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI);
-                        mci_writel(host, IDSTS, SDMMC_IDMAC_INT_NI);
-                        host->dma_ops->complete((void *)host);
-                }
-        }
+	/* External DMA Soc platform NOT need to ack interrupt IDSTS */
+	if (!(cpu_is_rk3036() || cpu_is_rk312x())){
+		/* Handle DMA interrupts */
+		pending = mci_readl(host, IDSTS);
+		if (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {
+			mci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI);
+			mci_writel(host, IDSTS, SDMMC_IDMAC_INT_NI);
+			host->dma_ops->complete((void *)host);
+		}
+	}
 #endif
 
 	return IRQ_HANDLED;
@@ -3157,20 +3047,25 @@ static void dw_mci_work_routine_card(struct work_struct *work)
 
 		present = dw_mci_get_cd(mmc);
 
-                /* Card insert, switch data line to uart function, and vice verse.
-            eONLY audi chip need switched by software, using udbg tag in dts!
-                 */
-                if (!(IS_ERR(host->pins_udbg)) && !(IS_ERR(host->pins_default))) {
-                         if (present) {
-                                if (pinctrl_select_state(host->pinctrl, host->pins_default) < 0)
-                                        dev_err(host->dev, "%s: Default pinctrl setting failed!\n",
-                                                mmc_hostname(host->mmc));
-                         } else {
-                                if (pinctrl_select_state(host->pinctrl, host->pins_udbg) < 0)
-                                        dev_err(host->dev, "%s: Udbg pinctrl setting failed!\n",
-                                                mmc_hostname(host->mmc));
-                        }
-                }
+		/* Card insert, switch data line to uart function, and vice verse.
+		ONLY audi chip need switched by software, using udbg tag in dts!
+		*/
+                if (!(IS_ERR(host->pins_udbg)) &&
+			!(IS_ERR(host->pins_default))) {
+			if (present) {
+				if (pinctrl_select_state(host->pinctrl,
+					host->pins_default) < 0)
+                                        dev_err(host->dev,
+						"%s: Default pinctrl setting failed!\n",
+						mmc_hostname(host->mmc));
+			} else {
+				if (pinctrl_select_state(host->pinctrl,
+					host->pins_udbg) < 0)
+					dev_err(host->dev,
+						"%s: Udbg pinctrl setting failed!\n",
+						mmc_hostname(host->mmc));
+			}
+		}
 
 		while (present != slot->last_detect_state) {
 			dev_dbg(&slot->mmc->class_dev, "card %s\n",
@@ -3228,9 +3123,10 @@ static void dw_mci_work_routine_card(struct work_struct *work)
 						mrq->data->error = -ENOMEDIUM;
 					if (mrq->stop)
 						mrq->stop->error = -ENOMEDIUM;
-						
-                                        MMC_DBG_CMD_FUNC(host->mmc, "dw_mci_work--reqeuest done, cmd=%d [%s]",
-                                                        mrq->cmd->opcode, mmc_hostname(mmc));
+
+					MMC_DBG_CMD_FUNC(host->mmc,
+						"dw_mci_work--reqeuest done, cmd=%d [%s]",
+						mrq->cmd->opcode, mmc_hostname(mmc));
 
 					spin_unlock(&host->lock);
 					mmc_request_done(slot->mmc, mrq);
@@ -3243,10 +3139,9 @@ static void dw_mci_work_routine_card(struct work_struct *work)
 				/* Clear down the FIFO */
 				dw_mci_fifo_reset(host);
 #ifdef CONFIG_MMC_DW_IDMAC
-                                if(!(cpu_is_rk3036() || cpu_is_rk312x()))
-				        dw_mci_idmac_reset(host);
+				if (!(cpu_is_rk3036() || cpu_is_rk312x()))
+					dw_mci_idmac_reset(host);
 #endif
-
 			}
 
 			spin_unlock_bh(&host->lock);
@@ -3255,7 +3150,7 @@ static void dw_mci_work_routine_card(struct work_struct *work)
 		}
 
 		mmc_detect_change(slot->mmc,
-                msecs_to_jiffies(host->pdata->detect_delay_ms));
+			msecs_to_jiffies(host->pdata->detect_delay_ms));
 	}
 }
 
@@ -3429,16 +3324,18 @@ static void dw_mci_of_set_cd_gpio_irq(struct device *dev, u32 gpio,
 
 	irq = gpio_to_irq(gpio);
 	if (irq >= 0) {
-		ret = devm_request_threaded_irq(&mmc->class_dev, irq,
-						NULL, dw_mci_gpio_cd_irqt,
-						IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-						"dw_mci_cd", mmc);
+		ret = devm_request_threaded_irq(
+					&mmc->class_dev, irq,
+					NULL, dw_mci_gpio_cd_irqt,
+					IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+					"dw_mci_cd", mmc);
 		if (ret < 0) {
 			irq = ret;
-			dev_err(host->dev, "Request cd-gpio %d interrupt error!\n", gpio);
+			dev_err(host->dev,
+				"Request cd-gpio %d interrupt error!\n", gpio);
 		} else{
-		        /* enable wakeup event for gpio-cd in idle or deep suspend*/
-		        enable_irq_wake(irq);
+			/* enable wakeup event for gpio-cd in idle or deep suspend*/
+			enable_irq_wake(irq);
 		}
 	} else {
 		dev_err(host->dev, "Cannot convert gpio %d to irq!\n", gpio);
@@ -3487,55 +3384,57 @@ static void dw_mci_of_get_cd_gpio(struct device *dev, u8 slot,
  */
 static void dw_mci_init_pinctrl(struct dw_mci *host)
 {
-        /* Fixme: DON'T TOUCH EMMC SETTING! */
-        if (host->mmc->restrict_caps & RESTRICT_CARD_TYPE_EMMC)
-                return;
+	/* Fixme: DON'T TOUCH EMMC SETTING! */
+	if (host->mmc->restrict_caps & RESTRICT_CARD_TYPE_EMMC)
+		return;
 
-        /* Get pinctrl for DTS */
-        host->pinctrl = devm_pinctrl_get(host->dev);
-        if (IS_ERR(host->pinctrl)) {
-                dev_err(host->dev, "%s: No pinctrl used!\n",
-                        mmc_hostname(host->mmc));
-                return;
-        }
+	/* Get pinctrl for DTS */
+	host->pinctrl = devm_pinctrl_get(host->dev);
+	if (IS_ERR(host->pinctrl)) {
+		dev_err(host->dev, "%s: No pinctrl used!\n",
+				mmc_hostname(host->mmc));
+		return;
+	}
 
-        /* Lookup idle state */
-        host->pins_idle = pinctrl_lookup_state(host->pinctrl,
-                                                PINCTRL_STATE_IDLE);
-        if (IS_ERR(host->pins_idle)) {
-                dev_err(host->dev, "%s: No idle tag found!\n",
-                        mmc_hostname(host->mmc));
-        } else {
-                if (pinctrl_select_state(host->pinctrl, host->pins_idle) < 0)
-                        dev_err(host->dev, "%s: Idle pinctrl setting failed!\n",
-                                mmc_hostname(host->mmc));
-        }
+	/* Lookup idle state */
+	host->pins_idle =
+		pinctrl_lookup_state(host->pinctrl, PINCTRL_STATE_IDLE);
+	if (IS_ERR(host->pins_idle)) {
+		dev_err(host->dev, "%s: No idle tag found!\n",
+				mmc_hostname(host->mmc));
+	} else {
+		if (pinctrl_select_state(host->pinctrl, host->pins_idle) < 0)
+			dev_err(host->dev,
+				"%s: Idle pinctrl setting failed!\n",
+				mmc_hostname(host->mmc));
+	}
 
-        /* Lookup default state */
-        host->pins_default = pinctrl_lookup_state(host->pinctrl,
-                                                        PINCTRL_STATE_DEFAULT);
-        if (IS_ERR(host->pins_default)) {
-                dev_err(host->dev, "%s: No default pinctrl found!\n",
-                        mmc_hostname(host->mmc));
-        } else {
-                if (pinctrl_select_state(host->pinctrl, host->pins_default) < 0)
-                        dev_err(host->dev, "%s:  Default pinctrl setting failed!\n",
-                                mmc_hostname(host->mmc));
-        }
+	/* Lookup default state */
+	host->pins_default =
+		pinctrl_lookup_state(host->pinctrl, PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(host->pins_default)) {
+		dev_err(host->dev, "%s: No default pinctrl found!\n",
+		mmc_hostname(host->mmc));
+	} else {
+		if (pinctrl_select_state(host->pinctrl, host->pins_default) < 0)
+			dev_err(host->dev,
+				"%s:  Default pinctrl setting failed!\n",
+				mmc_hostname(host->mmc));
+	}
 
-        /* Sd card data0/1 may be used for uart_dbg, so were data2/3 for Jtag */
-        if ((host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
-                host->pins_udbg = pinctrl_lookup_state(host->pinctrl, "udbg");
-                if (IS_ERR(host->pins_udbg)) {
-                        dev_warn(host->dev, "%s: No udbg pinctrl found!\n",
-                                        mmc_hostname(host->mmc));
-                } else {
-                        if (!dw_mci_get_cd(host->mmc))
+	/* Sd card data0/1 may be used for uart_dbg, so were data2/3 for Jtag */
+	if ((host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
+		host->pins_udbg = pinctrl_lookup_state(host->pinctrl, "udbg");
+		if (IS_ERR(host->pins_udbg)) {
+			dev_warn(host->dev, "%s: No udbg pinctrl found!\n",
+				mmc_hostname(host->mmc));
+		} else {
+			if (!dw_mci_get_cd(host->mmc))
 				if (pinctrl_select_state(host->pinctrl, host->pins_udbg) < 0)
 					dev_err(host->dev, "%s: Udbg pinctrl setting failed!\n",
 						mmc_hostname(host->mmc));
-                }
-        }
+		}
+	}
 }
 
 static int dw_mci_pm_notify(struct notifier_block *notify_block,
@@ -3548,7 +3447,8 @@ static int dw_mci_pm_notify(struct notifier_block *notify_block,
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
-	        dev_err(host->parent, "dw_mci_pm_notify:  suspend prepare\n");
+	        dev_err(host->parent,
+			"dw_mci_pm_notify:  suspend prepare\n");
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
 		spin_unlock_irqrestore(&host->lock, flags);
@@ -3559,7 +3459,8 @@ static int dw_mci_pm_notify(struct notifier_block *notify_block,
 	case PM_POST_SUSPEND:
 	case PM_POST_HIBERNATION:
 	case PM_POST_RESTORE:
-	        dev_err(host->parent, "dw_mci_pm_notify:  post suspend\n");
+	        dev_err(host->parent,
+			"dw_mci_pm_notify:  post suspend\n");
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
@@ -3598,18 +3499,18 @@ static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 		mmc->f_min = DW_MCI_FREQ_MIN;
 		mmc->f_max = DW_MCI_FREQ_MAX;
 		
-                printk("%d..%s: fmin=%d, fmax=%d [%s]\n", __LINE__, __FUNCTION__,
-                        mmc->f_min, mmc->f_max, mmc_hostname(mmc));
+                printk("%s: fmin=%d, fmax=%d [%s]\n",
+			 __FUNCTION__, mmc->f_min,
+			 mmc->f_max, mmc_hostname(mmc));
 	} else {
 		mmc->f_min = freq[0];
 		mmc->f_max = freq[1];
 		
-                printk("%d..%s: fmin=%d, fmax=%d [%s]\n", __LINE__, __FUNCTION__,
-                        mmc->f_min, mmc->f_max,  mmc_hostname(mmc));
+                printk("%s: fmin=%d, fmax=%d [%s]\n",
+			 __FUNCTION__, mmc->f_min,
+			 mmc->f_max, mmc_hostname(mmc));
 	}
 
-	printk("%s : Rockchip specific MHSC: %s\n", mmc_hostname(mmc), RK_SDMMC_DRIVER_VERSION);
-        
 	if (of_find_property(host->dev->of_node, "supports-sd", NULL))
 		mmc->restrict_caps |= RESTRICT_CARD_TYPE_SD;	
 	if (of_find_property(host->dev->of_node, "supports-sdio", NULL))
@@ -3617,13 +3518,13 @@ static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 	if (of_find_property(host->dev->of_node, "supports-emmc", NULL))
 		mmc->restrict_caps |= RESTRICT_CARD_TYPE_EMMC;
 
-        if (mmc->restrict_caps & RESTRICT_CARD_TYPE_SD) {
-                mmc->pm_notify.notifier_call = dw_mci_pm_notify;
-                if (register_pm_notifier(&mmc->pm_notify)) {
-                        printk(KERN_ERR "dw_mci: register_pm_notifier failed\n");
-                        goto err_pm_notifier;
-                }
-        }
+	if (mmc->restrict_caps & RESTRICT_CARD_TYPE_SD) {
+		mmc->pm_notify.notifier_call = dw_mci_pm_notify;
+		if (register_pm_notifier(&mmc->pm_notify)) {
+			pr_err("dw_mci: register_pm_notifier failed\n");
+			goto err_pm_notifier;
+		}
+	}
 
 	if (host->cid == DW_MCI_TYPE_RK3368) {
 		if (IS_ERR(host->grf))
@@ -3635,28 +3536,29 @@ static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 		grf_writel(((1 << 12) << 16) | (0 << 12), RK3288_GRF_SOC_CON0);
 	}
 
-
-        /* We assume only low-level chip use gpio_cd */
-        if ((soc_is_rk3126() || soc_is_rk3126b() || soc_is_rk3036()) &&
-                (host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
-                slot->cd_gpio = of_get_named_gpio(host->dev->of_node, "cd-gpios", 0);
-                if (gpio_is_valid(slot->cd_gpio)) {
-                        /* Request gpio int for card detection */
-                        dw_mci_of_set_cd_gpio_irq(host->dev, slot->cd_gpio,host->mmc);
-                } else {
-                        slot->cd_gpio = -ENODEV;
-                        dev_err(host->dev, "failed to get your cd-gpios!\n");
-                }
-        }
+	/* We assume only low-level chip use gpio_cd */
+	if ((soc_is_rk3126() || soc_is_rk3126b() || soc_is_rk3036()) &&
+		(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SD)) {
+		slot->cd_gpio = of_get_named_gpio(host->dev->of_node, "cd-gpios", 0);
+		if (gpio_is_valid(slot->cd_gpio)) {
+			/* Request gpio int for card detection */
+			dw_mci_of_set_cd_gpio_irq(host->dev, slot->cd_gpio,host->mmc);
+		} else {
+			slot->cd_gpio = -ENODEV;
+			dev_err(host->dev, "failed to get your cd-gpios!\n");
+		}
+	}
 
 	if (host->pdata->get_ocr)
 		mmc->ocr_avail = host->pdata->get_ocr(id);
 	else
 	{
-		mmc->ocr_avail =  MMC_VDD_27_28| MMC_VDD_28_29| MMC_VDD_29_30| MMC_VDD_30_31
-                        | MMC_VDD_31_32| MMC_VDD_32_33| MMC_VDD_33_34| MMC_VDD_34_35| MMC_VDD_35_36
-                        | MMC_VDD_26_27| MMC_VDD_25_26| MMC_VDD_24_25| MMC_VDD_23_24
-                        | MMC_VDD_22_23| MMC_VDD_21_22| MMC_VDD_20_21| MMC_VDD_165_195;
+		mmc->ocr_avail = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+				MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33|
+				MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36 |
+				MMC_VDD_26_27 | MMC_VDD_25_26 | MMC_VDD_24_25 |
+				MMC_VDD_23_24 | MMC_VDD_22_23 | MMC_VDD_21_22 |
+				MMC_VDD_20_21 | MMC_VDD_165_195;
 	}
 
 	/*
@@ -3983,12 +3885,6 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 				"assuming 1 slot is available\n");
 		pdata->num_slots = 1;
 	}
-#if 0
-	/* get quirks */
-	for (idx = 0; idx < ARRAY_SIZE(of_quirks); idx++)
-		if (of_get_property(np, of_quirks[idx].quirk, NULL))
-			pdata->quirks |= of_quirks[idx].id;
-#endif
 
 	if (of_property_read_u32(np, "fifo-depth", &pdata->fifo_depth))
 		dev_info(dev, "fifo-depth property not found, using "
@@ -4013,14 +3909,14 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 
 	if (of_find_property(np, "supports-highspeed", NULL))
 		pdata->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
-		
-    if (of_find_property(np, "supports-UHS_SDR104", NULL))
+
+	if (of_find_property(np, "supports-UHS_SDR104", NULL))
 		pdata->caps |= MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_SDR50;
 
-    if (of_find_property(np, "supports-DDR_MODE", NULL))
+	if (of_find_property(np, "supports-DDR_MODE", NULL))
 		pdata->caps |= MMC_CAP_1_8V_DDR | MMC_CAP_1_2V_DDR;
 
-    if (of_find_property(np, "caps2-mmc-hs200", NULL))
+	if (of_find_property(np, "caps2-mmc-hs200", NULL))
 		pdata->caps2 |= MMC_CAP2_HS200;
 
 	if (of_find_property(np, "caps2-mmc-hs200-1_8v", NULL))
@@ -4099,57 +3995,57 @@ int dw_mci_probe(struct dw_mci *host)
 		clk_prepare_enable(host->hpclk_mmc);
 	}
 
-        //hclk enable
-        host->hclk_mmc= devm_clk_get(host->dev, "hclk_mmc");
-        if (IS_ERR(host->hclk_mmc)) {
-                dev_err(host->dev, "failed to get hclk_mmc\n");
-                ret = PTR_ERR(host->hclk_mmc);
-                goto err_hclk_mmc;
-        }
+	//hclk enable
+	host->hclk_mmc= devm_clk_get(host->dev, "hclk_mmc");
+	if (IS_ERR(host->hclk_mmc)) {
+		dev_err(host->dev, "failed to get hclk_mmc\n");
+		ret = PTR_ERR(host->hclk_mmc);
+		goto err_hclk_mmc;
+	}
 
-        clk_prepare_enable(host->hclk_mmc);
+	clk_prepare_enable(host->hclk_mmc);
 
-        //mmc clk enable
-        host->clk_mmc = devm_clk_get(host->dev, "clk_mmc");
-        if (IS_ERR(host->clk_mmc)) {
-                dev_err(host->dev, "failed to get clk mmc_per\n");
-                ret = PTR_ERR(host->clk_mmc);
-                goto err_clk_mmc;
-        }
-    
-        host->bus_hz = host->pdata->bus_hz;   
-        if (!host->bus_hz) {
-                dev_err(host->dev,"Platform data must supply bus speed\n");
-                ret = -ENODEV;
-                goto err_clk_mmc;
-        }
+	//mmc clk enable
+	host->clk_mmc = devm_clk_get(host->dev, "clk_mmc");
+	if (IS_ERR(host->clk_mmc)) {
+		dev_err(host->dev, "failed to get clk mmc_per\n");
+		ret = PTR_ERR(host->clk_mmc);
+		goto err_clk_mmc;
+	}
+
+	host->bus_hz = host->pdata->bus_hz;
+	if (!host->bus_hz) {
+		dev_err(host->dev, "Platform data must supply bus speed\n");
+		ret = -ENODEV;
+		goto err_clk_mmc;
+	}
 
-        if (host->verid < DW_MMC_240A)
-	        ret = clk_set_rate(host->clk_mmc, host->bus_hz);
+	if (host->verid < DW_MMC_240A)
+		ret = clk_set_rate(host->clk_mmc, host->bus_hz);
 	else
-                //rockchip: fix divider 2 in clksum before controlller
-	        ret = clk_set_rate(host->clk_mmc, host->bus_hz * 2);
+		//rockchip: fix divider 2 in clksum before controlller
+		ret = clk_set_rate(host->clk_mmc, host->bus_hz * 2);
 	        
 	if(ret < 0) {
-	    dev_err(host->dev, "failed to set clk mmc\n");
-	    goto err_clk_mmc;
+		dev_err(host->dev, "failed to set clk mmc\n");
+		goto err_clk_mmc;
 	}
-        clk_prepare_enable(host->clk_mmc);
+	clk_prepare_enable(host->clk_mmc);
 
 	if (drv_data && drv_data->setup_clock) {
-        ret = drv_data->setup_clock(host);
-        if (ret) {
-            dev_err(host->dev,
-                "implementation specific clock setup failed\n");
-            goto err_clk_mmc;
-        }
-    }
+		ret = drv_data->setup_clock(host);
+		if (ret) {
+			dev_err(host->dev,
+			"implementation specific clock setup failed\n");
+			goto err_clk_mmc;
+		}
+	}
 
-        host->quirks = host->pdata->quirks;
-        host->irq_state = true;
-        host->set_speed = 0;
-        host->set_div = 0;
-        host->svi_flags = 0;
+	host->quirks = host->pdata->quirks;
+	host->irq_state = true;
+	host->set_speed = 0;
+	host->set_div = 0;
+	host->svi_flags = 0;
 
 	spin_lock_init(&host->lock);
 	spin_lock_init(&host->slock);
@@ -4252,11 +4148,11 @@ int dw_mci_probe(struct dw_mci *host)
 	 * receive ready and error such as transmit, receive timeout, crc error
 	 */
 	mci_writel(host, RINTSTS, 0xFFFFFFFF);
-	regs = SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_VSI |
-	       SDMMC_INT_RXDR | DW_MCI_ERROR_FLAGS;
-	if(!(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO) 
-	    && !(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_EMMC))
-	    regs |= SDMMC_INT_CD; 
+	regs = SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR |
+		SDMMC_INT_VSI | SDMMC_INT_RXDR | DW_MCI_ERROR_FLAGS;
+	if (!(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_SDIO) &&
+		!(host->mmc->restrict_caps & RESTRICT_CARD_TYPE_EMMC))
+		regs |= SDMMC_INT_CD;
 
 	mci_writel(host, INTMASK, regs);
 
@@ -4518,6 +4414,7 @@ EXPORT_SYMBOL(dw_mci_resume);
 static int __init dw_mci_init(void)
 {
 	pr_info("Synopsys Designware Multimedia Card Interface Driver\n");
+	pr_info("MHSC version = %s\n", RK_SDMMC_DRIVER_VERSION);
 	return 0;
 }
 
@@ -4529,8 +4426,5 @@ module_init(dw_mci_init);
 module_exit(dw_mci_exit);
 
 MODULE_DESCRIPTION("Rockchip specific DW Multimedia Card Interface driver");
-MODULE_AUTHOR("NXP Semiconductor VietNam");
-MODULE_AUTHOR("Imagination Technologies Ltd");
 MODULE_AUTHOR("Shawn Lin <lintao@rock-chips.com>");
-MODULE_AUTHOR("Bangwang Xie <xbw@rock-chips.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/rk_sdmmc.h b/drivers/mmc/host/rk_sdmmc.h
index d06c3a8d3746..2e0012924822 100755
--- a/drivers/mmc/host/rk_sdmmc.h
+++ b/drivers/mmc/host/rk_sdmmc.h
@@ -61,6 +61,37 @@
 #define SDMMC_CDTHRCTL          0x100
 #define SDMMC_DATA(x)           (x)
 
+
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
 /*
  * Data offset is difference according to Version
  * Lower than 2.40a : data register offest is 0x100
@@ -77,6 +108,50 @@ u32   addr;
 char    *name;
 };
 
+static const struct sdmmc_reg dw_mci_regs[] = {
+{ 0x0000, "CTRL" },
+{ 0x0004, "PWREN" },
+{ 0x0008, "CLKDIV" },
+{ 0x000C, "CLKSRC" },
+{ 0x0010, "CLKENA" },
+{ 0x0014, "TMOUT" },
+{ 0x0018, "CTYPE" },
+{ 0x001C, "BLKSIZ" },
+{ 0x0020, "BYTCNT" },
+{ 0x0024, "INTMASK" },
+{ 0x0028, "CMDARG" },
+{ 0x002C, "CMD" },
+{ 0x0030, "RESP0" },
+{ 0x0034, "RESP1" },
+{ 0x0038, "RESP2" },
+{ 0x003C, "RESP3" },
+{ 0x0040, "MINSTS" },
+{ 0x0044, "RINTSTS" },
+{ 0x0048, "STATUS" },
+{ 0x004C, "FIFOTH" },
+{ 0x0050, "CDETECT" },
+{ 0x0054, "WRTPRT" },
+{ 0x0058, "GPIO" },
+{ 0x005C, "TCBCNT" },
+{ 0x0060, "TBBCNT" },
+{ 0x0064, "DEBNCE" },
+{ 0x0068, "USRID" },
+{ 0x006C, "VERID" },
+{ 0x0070, "HCON" },
+{ 0x0074, "UHS_REG" },
+{ 0x0078, "RST_n" },
+{ 0x0080, "BMOD" },
+{ 0x0084, "PLDMND" },
+{ 0x0088, "DBADDR" },
+{ 0x008C, "IDSTS" },
+{ 0x0090, "IDINTEN" },
+{ 0x0094, "DSCADDR" },
+{ 0x0098, "BUFADDR" },
+{ 0x0100, "CARDTHRCTL" },
+{ 0x0104, "BackEndPwr" },
+{ 0, 0 }
+};
+
 
 /* Control register defines */
 #define SDMMC_CTRL_USE_IDMAC		BIT(25)
@@ -111,7 +186,7 @@ char    *name;
 #define SDMMC_INT_HLE			BIT(12)
 #define SDMMC_INT_FRUN			BIT(11)
 #define SDMMC_INT_HTO			BIT(10)
-#define SDMMC_INT_VSI                   SDMMC_INT_HTO   // VSI => Voltage Switch Interrupt,Volt_Switch_int
+#define SDMMC_INT_VSI                   SDMMC_INT_HTO
 #define SDMMC_INT_DRTO			BIT(9)
 #define SDMMC_INT_RTO			BIT(8)
 #define SDMMC_INT_DCRC			BIT(7)
@@ -126,12 +201,11 @@ char    *name;
 /* Command register defines */
 #define SDMMC_CMD_START                 BIT(31)
 #define SDMMC_CMD_USE_HOLD_REG          BIT(29)
-#define SDMMC_CMD_VOLT_SWITCH           BIT(28)      //Voltage switch bit
-#define SDMMC_CMD_VOLT_SWITCH           BIT(28)      //Voltage switch bit
-#define SDMMC_CMD_BOOT_MODE             BIT(27)      //set boot mode.
-#define SDMMC_CMD_DISABLE_BOOT          BIT(26)      //disable boot.
-#define SDMMC_CMD_EXPECT_BOOT_ACK       BIT(25)      //Expect Boot Acknowledge.
-#define SDMMC_CMD_ENABLE_BOOT           BIT(24)      //be set only for mandatory boot mode.
+#define SDMMC_CMD_VOLT_SWITCH           BIT(28)
+#define SDMMC_CMD_BOOT_MODE             BIT(27)
+#define SDMMC_CMD_DISABLE_BOOT          BIT(26)
+#define SDMMC_CMD_EXPECT_BOOT_ACK       BIT(25)
+#define SDMMC_CMD_ENABLE_BOOT           BIT(24)
 #define SDMMC_CMD_CCS_EXP		BIT(23)
 #define SDMMC_CMD_CEATA_RD		BIT(22)
 #define SDMMC_CMD_UPD_CLK		BIT(21)
@@ -149,15 +223,15 @@ char    *name;
 /* Status register defines */
 #define SDMMC_GET_FCNT(x)               (((x)>>17) & 0x1FFF)
 #define SDMMC_STAUTS_MC_BUSY            BIT(10)
-#define SDMMC_STAUTS_DATA_BUSY          BIT(9)          //Card busy
-#define SDMMC_CMD_FSM_MASK              (0x0F << 4)	    //Command FSM status mask
-#define SDMMC_CMD_FSM_IDLE              (0x00)			//CMD FSM is IDLE
-#define SDMMC_STAUTS_FIFO_FULL          BIT(3)          //FIFO is full status
-#define SDMMC_STAUTS_FIFO_EMPTY         BIT(2)          //FIFO is empty status
+#define SDMMC_STAUTS_DATA_BUSY          BIT(9)
+#define SDMMC_CMD_FSM_MASK              (0x0F << 4)
+#define SDMMC_CMD_FSM_IDLE              (0x00)
+#define SDMMC_STAUTS_FIFO_FULL          BIT(3)
+#define SDMMC_STAUTS_FIFO_EMPTY         BIT(2)
 
 /* Control SDMMC_UHS_REG defines (base+ 0x74)*/
-#define SDMMC_UHS_DDR_MODE              BIT(16)     // 0--Non DDR Mode; 1--DDR mode 
-#define SDMMC_UHS_VOLT_REG_18           BIT(0)      // 0--3.3v; 1--1.8V
+#define SDMMC_UHS_DDR_MODE              BIT(16)
+#define SDMMC_UHS_VOLT_REG_18           BIT(0)
 
 /* FIFOTH register defines */
 #define SDMMC_SET_FIFOTH(m, r, t)	(((m) & 0x7) << 28 | \
@@ -186,9 +260,9 @@ char    *name;
 #define mci_writel(dev, reg, value)			\
 	__raw_writel((value), (dev)->regs + SDMMC_##reg)
 #define mci_readreg(dev, addr)			\
-        __raw_readl((dev)->regs + addr)
+	__raw_readl((dev)->regs + addr)
 #define mci_writereg(dev, addr, value)		\
-  __raw_writel((value), (dev)->regs + addr)
+	__raw_writel((value), (dev)->regs + addr)
 
 
 /* 16-bit FIFO access macros */
@@ -213,17 +287,15 @@ char    *name;
  * rest of the code free from ifdefs.
  */
 #define mci_readq(dev, reg)			\
-	(*(volatile u64 __force *)((dev)->regs + SDMMC_##reg))
+	(*(u64 __force *)((dev)->regs + SDMMC_##reg))
 #define mci_writeq(dev, reg, value)			\
-	(*(volatile u64 __force *)((dev)->regs + SDMMC_##reg) = (value))
+	(*(u64 __force *)((dev)->regs + SDMMC_##reg) = (value))
 #endif
-extern void rk_send_wakeup_key(void);
-extern int dw_mci_probe(struct dw_mci *host);
-extern void dw_mci_remove(struct dw_mci *host);
 #ifdef CONFIG_PM
 extern int dw_mci_suspend(struct dw_mci *host);
 extern int dw_mci_resume(struct dw_mci *host);
 #endif
+static const struct dw_mci_rst_ops dw_mci_pdrst_ops;
 
 /**
  * struct dw_mci_slot - MMC slot state
@@ -245,27 +317,26 @@ extern int dw_mci_resume(struct dw_mci *host);
  * @last_detect_state: Most recently observed card detect state.
  */
 struct dw_mci_slot {
-	struct mmc_host		*mmc;
-	struct dw_mci		*host;
-
-	int			quirks;
-	int			wp_gpio;
-	int                     cd_gpio;
-        int                     pwr_en_gpio;
-	u32			ctype;
-	u32         pre_ctype;
+struct mmc_host		*mmc;
+struct dw_mci		*host;
+int			quirks;
+int			wp_gpio;
+int                     cd_gpio;
+int			pwr_en_gpio;
+u32			ctype;
+u32         pre_ctype;
 
-	struct mmc_request	*mrq;
-	struct list_head	queue_node;
+struct mmc_request	*mrq;
+struct list_head	queue_node;
 
-	unsigned int		clock;
-	unsigned int		__clk_old;
+unsigned int		clock;
+unsigned int		__clk_old;
 
-	unsigned long		flags;
+unsigned long		flags;
 #define DW_MMC_CARD_PRESENT	0
 #define DW_MMC_CARD_NEED_INIT	1
-	int			id;
-	int			last_detect_state;
+int			id;
+int			last_detect_state;
 };
 
 struct dw_mci_tuning_data {
@@ -290,25 +361,29 @@ struct dw_mci_tuning_data {
  * data structure is fully optional and usage of each member in this structure
  * is optional as well.
  */
+
 struct dw_mci_drv_data {
 	unsigned long	*caps;
 	unsigned int    *hold_reg_flag;
+
 	int		(*init)(struct dw_mci *host);
 	int		(*setup_clock)(struct dw_mci *host);
 	void		(*prepare_command)(struct dw_mci *host, u32 *cmdr);
 	void		(*set_ios)(struct dw_mci *host, struct mmc_ios *ios);
 	int		(*parse_dt)(struct dw_mci *host);
-	int		(*execute_tuning)(struct dw_mci_slot *slot, u32 opcode,
-					struct dw_mci_tuning_data *tuning_data);
+	int		(*execute_tuning)(struct dw_mci_slot *slot,
+					  u32 opcode,
+					  struct dw_mci_tuning_data
+					  *tuning_data);
 };
 
 /* Variations in Rockchip specific dw-mshc controller */
 enum dw_mci_rockchip_type {
-         DW_MCI_TYPE_RK3188,
-         DW_MCI_TYPE_RK3288,
-         DW_MCI_TYPE_RK3036,
-         DW_MCI_TYPE_RK312X,
-         DW_MCI_TYPE_RK3368,
+DW_MCI_TYPE_RK3188,
+DW_MCI_TYPE_RK3288,
+DW_MCI_TYPE_RK3036,
+DW_MCI_TYPE_RK312X,
+DW_MCI_TYPE_RK3368,
 };
 
 #endif /* _DW_MMC_H_ */
diff --git a/include/linux/mmc/rk_mmc.h b/include/linux/mmc/rk_mmc.h
index aa17cc7469e9..6492a4764dfa 100755
--- a/include/linux/mmc/rk_mmc.h
+++ b/include/linux/mmc/rk_mmc.h
@@ -127,8 +127,8 @@ struct mmc_data;
  * using barriers.
  */
 struct dw_mci {
-	spinlock_t		lock;
-	spinlock_t		slock;
+	spinlock_t		lock; /* Spinlock for control flow */
+	spinlock_t		slock; /* Spinlock for sdio int sync */
 	void __iomem		*regs;
 
 	struct scatterlist	*sg;
@@ -152,7 +152,7 @@ struct dw_mci {
 	const struct dw_mci_dma_ops	*dma_ops;
 #ifdef CONFIG_MMC_DW_IDMAC
 	unsigned int		ring_size;
-        struct dw_mci_dma_slave *dms;
+	struct dw_mci_dma_slave *dms;
 	void                    *phy_regs;
 #else
 	struct dw_mci_dma_data	*dma_data;
@@ -186,8 +186,8 @@ struct dw_mci {
 	struct dw_mci_slot	*slot[MAX_MCI_SLOTS];
 	struct mmc_host		*mmc;
 	struct mmc_command	*pre_cmd;
-        /* Fix the hold_reg value */
-        unsigned int    hold_reg_flag;
+	/* Fix the hold_reg value */
+	unsigned int    hold_reg_flag;
 	/* FIFO push and pull */
 	int			fifo_depth;
 	int			data_shift;
@@ -273,7 +273,7 @@ struct dw_mci_board {
 	u32 caps;	/* Capabilities */
 	u32 caps2;	/* More capabilities */
 	u32 pm_caps;	/* PM capabilities */
-	u32 cardtype_restrict;	/*restrict the SDMMC controller to support card type;1--SD card; 2--sdio; 4--eMMC */
+	u32 cardtype_restrict;
 	/*
 	 * Override fifo depth. If 0, autodetect it from the FIFOTH register,
 	 * but note that this may not be reliable after a bootloader has used
@@ -303,7 +303,7 @@ struct dw_mci_board {
 	struct block_settings *blk_settings;
 };
 #define grf_writel(v, offset)   do \
-        { writel_relaxed(v, RK_GRF_VIRT + offset); dsb(sy); } \
-                while (0)
+{ writel_relaxed(v, RK_GRF_VIRT + offset); dsb(sy); } \
+while (0)
 
 #endif /* LINUX_MMC_DW_MMC_H */
-- 
2.35.3

