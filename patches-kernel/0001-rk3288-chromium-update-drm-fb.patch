From 966b5dfe147d78fbbb99f23933fe2b8410e00d41 Mon Sep 17 00:00:00 2001
From: yzq <yzq@rock-chips.com>
Date: Mon, 31 Mar 2014 15:42:15 +0800
Subject: [PATCH] rk3288 chromium: update drm fb

---
 arch/arm/configs/rockchip_chromium_defconfig  |   10 +-
 drivers/gpu/drm/rockchip/Kconfig              |   24 +-
 drivers/gpu/drm/rockchip/Makefile             |    7 +-
 drivers/gpu/drm/rockchip/rk3188_drm_fimd.c    | 1170 -------------
 drivers/gpu/drm/rockchip/rk3288_drm_fimd.c    | 1480 -----------------
 drivers/gpu/drm/rockchip/rockchip_drm_drv.c   |   37 +-
 drivers/gpu/drm/rockchip/rockchip_drm_drv.h   |    2 +-
 .../gpu/drm/rockchip/rockchip_drm_primary.c   |  659 ++++++++
 .../gpu/drm/rockchip/rockchip_drm_primary.h   |   34 +
 drivers/video/Makefile                        |    1 +
 drivers/video/of_display_timing.c             |    2 +-
 drivers/video/rockchip/Makefile               |    5 +-
 drivers/video/rockchip/lcdc/Kconfig           |   10 +-
 drivers/video/rockchip/rk_drm_fb.c            |  776 +++++++++
 drivers/video/rockchip/rk_drm_fb.h            |   66 +
 include/video/display_timing.h                |    2 +-
 16 files changed, 1568 insertions(+), 2717 deletions(-)
 delete mode 100644 drivers/gpu/drm/rockchip/rk3188_drm_fimd.c
 delete mode 100644 drivers/gpu/drm/rockchip/rk3288_drm_fimd.c
 create mode 100644 drivers/gpu/drm/rockchip/rockchip_drm_primary.c
 create mode 100644 drivers/gpu/drm/rockchip/rockchip_drm_primary.h
 create mode 100755 drivers/video/rockchip/rk_drm_fb.c
 create mode 100644 drivers/video/rockchip/rk_drm_fb.h

diff --git a/arch/arm/configs/rockchip_chromium_defconfig b/arch/arm/configs/rockchip_chromium_defconfig
index 3c1f8a8ce260..79d715af2b58 100644
--- a/arch/arm/configs/rockchip_chromium_defconfig
+++ b/arch/arm/configs/rockchip_chromium_defconfig
@@ -327,28 +327,26 @@ CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_DRM=y
 CONFIG_DRM_ROCKCHIP=y
 CONFIG_DRM_ROCKCHIP_DMABUF=y
-CONFIG_DRM_RK3288_FIMD=y
+CONFIG_DRM_RK_PRIMARY=y
 CONFIG_MALI_T6XX=y
-CONFIG_MALI_GATOR_SUPPORT=y
 CONFIG_MALI_T6XX_DVFS=y
 CONFIG_MALI_T6XX_RT_PM=y
-CONFIG_MALI_T6XX_ENABLE_TRACE=y
 CONFIG_MALI_T6XX_DEBUG_SYS=y
 CONFIG_MALI_EXPERT=y
 CONFIG_MALI_DEBUG_SHADER_SPLIT_FS=y
 CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="rk"
-CONFIG_MALI_DEBUG=y
-CONFIG_MALI_TRACE_TIMELINE=y
-CONFIG_MALI_SYSTEM_TRACE=y
+
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_BACKLIGHT_PWM=y
+CONFIG_LCDC_RK3288=y
 CONFIG_LCD_GENERAL=y
 CONFIG_RK_TRSM=y
 CONFIG_RK32_LVDS=y
 CONFIG_ROCKCHIP_RGA2=y
+# CONFIG_IEP is not set
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
diff --git a/drivers/gpu/drm/rockchip/Kconfig b/drivers/gpu/drm/rockchip/Kconfig
index 19ccbb1b7ddc..f38aa4224200 100644
--- a/drivers/gpu/drm/rockchip/Kconfig
+++ b/drivers/gpu/drm/rockchip/Kconfig
@@ -22,23 +22,13 @@ config DRM_ROCKCHIP_DMABUF
 	help
 	  Choose this option if you want to use DMABUF feature for DRM.
 
-config DRM_RK3188_FIMD
-	bool "RK3188 DRM FIMD"
-	depends on OF && DRM_ROCKCHIP 
-	select FB_MODE_HELPERS
-	select VIDEOMODE_HELPERS
-	help
-	  Choose this option if you want to use Rockchip FIMD for DRM.
-
-config DRM_RK3288_FIMD
-	bool "RK3288 DRM FIMD"
-	depends on OF && DRM_ROCKCHIP 
-	select FB_MODE_HELPERS
-	select VIDEOMODE_HELPERS
-	help
-	  Choose this option if you want to use Rockchip FIMD for DRM.
-
-
+config DRM_RK_PRIMARY
+	  bool "RK DRM PRIMARY"
+	  depends on OF && DRM_ROCKCHIP 
+	  select FB_MODE_HELPERS
+	  select VIDEOMODE_HELPERS
+	  help
+	  Choose this option if you want to use Rockchip PRIMARY DISPLAY for DRM.
 config DRM_ROCKCHIP_HDMI
 	bool "Rockchip DRM HDMI"
 	depends on DRM_ROCKCHIP 
diff --git a/drivers/gpu/drm/rockchip/Makefile b/drivers/gpu/drm/rockchip/Makefile
index 0af2aa51c44b..99aba1a9a093 100644
--- a/drivers/gpu/drm/rockchip/Makefile
+++ b/drivers/gpu/drm/rockchip/Makefile
@@ -6,17 +6,14 @@ ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/rockchip
 rockchipdrm-y := rockchip_drm_drv.o rockchip_drm_encoder.o rockchip_drm_connector.o \
 		rockchip_drm_crtc.o rockchip_drm_fbdev.o rockchip_drm_fb.o \
 		rockchip_drm_buf.o rockchip_drm_gem.o rockchip_drm_core.o \
-		rockchip_drm_plane.o
+		rockchip_drm_plane.o 
 
 rockchipdrm-$(CONFIG_DRM_ROCKCHIP_IOMMU) += rockchip_drm_iommu.o
 rockchipdrm-$(CONFIG_DRM_ROCKCHIP_DMABUF) += rockchip_drm_dmabuf.o
-rockchipdrm-$(CONFIG_DRM_RK3188_FIMD)	+= rk3188_drm_fimd.o
-rockchipdrm-$(CONFIG_DRM_RK3288_FIMD)	+= rk3288_drm_fimd.o
+rockchipdrm-$(CONFIG_DRM_RK_PRIMARY)	+= rockchip_drm_primary.o
 rockchipdrm-$(CONFIG_DRM_ROCKCHIP_HDMI)	+= rockchip_hdmi.o rockchip_mixer.o \
 					   rockchip_ddc.o rockchip_hdmiphy.o \
 					   rockchip_drm_hdmi.o
 rockchipdrm-$(CONFIG_DRM_ROCKCHIP_VIDI)	+= rockchip_drm_vidi.o
 
 obj-$(CONFIG_DRM_ROCKCHIP)		+= rockchipdrm.o
-obj-$(CONFIG_DRM_ROCKCHIP) += ../../../video/rockchip/screen/
-obj-$(CONFIG_DRM_ROCKCHIP) += ../../../video/rockchip/transmitter/
diff --git a/drivers/gpu/drm/rockchip/rk3188_drm_fimd.c b/drivers/gpu/drm/rockchip/rk3188_drm_fimd.c
deleted file mode 100644
index bbcd12a96490..000000000000
--- a/drivers/gpu/drm/rockchip/rk3188_drm_fimd.c
+++ /dev/null
@@ -1,1170 +0,0 @@
-/*
- * rk3188_drm_fimd.c
- *
- * Copyright (C) ROCKCHIP, Inc.
- * Author:yzq<yzq@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <drm/drmP.h>
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
-
-#include <video/of_display_timing.h>
-#include <drm/rockchip_drm.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rk_fb.h>
-#include <video/display_timing.h>
-
-#include "rockchip_drm_drv.h"
-#include "rockchip_drm_fbdev.h"
-#include "rockchip_drm_crtc.h"
-#include "rockchip_drm_iommu.h"
-
-/*
- * FIMD is stand for Fully Interactive Mobile Display and
- * as a display controller, it transfers contents drawn on memory
- * to a LCD Panel through Display Interfaces such as RGB or
- * CPU Interface.
- */
-
-/* position control register for hardware window 0, 2 ~ 4.*/
-#define VIDOSD_A(win)		(VIDOSD_BASE + 0x00 + (win) * 16)
-#define VIDOSD_B(win)		(VIDOSD_BASE + 0x04 + (win) * 16)
-/*
- * size control register for hardware windows 0 and alpha control register
- * for hardware windows 1 ~ 4
- */
-#define VIDOSD_C(win)		(VIDOSD_BASE + 0x08 + (win) * 16)
-/* size control register for hardware windows 1 ~ 2. */
-#define VIDOSD_D(win)		(VIDOSD_BASE + 0x0C + (win) * 16)
-
-#define VIDWx_BUF_START(win, buf)	(VIDW_BUF_START(buf) + (win) * 8)
-#define VIDWx_BUF_END(win, buf)		(VIDW_BUF_END(buf) + (win) * 8)
-#define VIDWx_BUF_SIZE(win, buf)	(VIDW_BUF_SIZE(buf) + (win) * 4)
-
-/* color key control register for hardware window 1 ~ 4. */
-#define WKEYCON0_BASE(x)		((WKEYCON0 + 0x140) + ((x - 1) * 8))
-/* color key value register for hardware window 1 ~ 4. */
-#define WKEYCON1_BASE(x)		((WKEYCON1 + 0x140) + ((x - 1) * 8))
-
-/* FIMD has totally five hardware windows. */
-#define WINDOWS_NR	4
-
-#define get_fimd_context(dev)	platform_get_drvdata(to_platform_device(dev))
-
-struct fimd_driver_data {
-	unsigned int timing_base;
-};
-
-static struct fimd_driver_data rockchip4_fimd_driver_data = {
-	.timing_base = 0x0,
-};
-
-static struct fimd_driver_data rockchip5_fimd_driver_data = {
-	.timing_base = 0x20000,
-};
-
-struct fimd_win_data {
-	unsigned int		offset_x;
-	unsigned int		offset_y;
-	unsigned int		ovl_width;
-	unsigned int		ovl_height;
-	unsigned int		fb_width;
-	unsigned int		fb_height;
-	unsigned int		bpp;
-	dma_addr_t		dma_addr;
-	unsigned int		buf_offsize;
-	unsigned int		line_size;	/* bytes */
-	bool			enabled;
-	bool			resume;
-};
-
-struct fimd_context {
-	struct rockchip_drm_subdrv	subdrv;
-	int				irq;
-	struct drm_crtc			*crtc;
-	struct clk			*pd;				//lcdc power domain
-	struct clk			*hclk;				//lcdc AHP clk
-	struct clk			*dclk;				//lcdc dclk
-	struct clk			*aclk;				//lcdc share memory frequency
-	void __iomem			*regs;
-	struct fimd_win_data		win_data[WINDOWS_NR];
-	unsigned int			clkdiv;
-	unsigned int			default_win;
-	unsigned long			irq_flags;
-	u32				vidcon0;
-	u32				vidcon1;
-	int 				lcdc_id;
-	bool				suspended;
-	struct mutex			lock;
-	wait_queue_head_t		wait_vsync_queue;
-	atomic_t			wait_vsync_event;
-
-	int clkon;
-	void *regsbak;			//back up reg
-	struct rockchip_drm_panel_info *panel;
-	struct rk_screen *screen;
-};
-
-#include "rk3188_drm_fimd.h"
-static int rk3188_lcdc_get_id(u32 phy_base)
-{
-	if (cpu_is_rk319x()) {
-		if (phy_base == 0xffc40000)
-			return 0;
-		else if (phy_base == 0xffc50000)
-			return 1;
-		else
-			return -EINVAL;
-	} else if (cpu_is_rk3188()) {
-		if (phy_base == 0x1010c000)
-			return 0;
-		else if (phy_base == 0x1010e000)
-			return 1;
-		else
-			return -EINVAL;
-	} else if (cpu_is_rk3026()) {
-		if (phy_base == 0x1010e000)
-			return 0;
-		else if (phy_base == 0x01110000)
-			return 1;
-		else
-			return -EINVAL;
-	} else {
-		pr_err("un supported platform \n");
-		return -EINVAL;
-	}
-
-}
-
-
-static bool fimd_display_is_connected(struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO. */
-
-	return true;
-}
-
-static void *fimd_get_panel(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return ctx->panel;
-}
-
-static int fimd_check_timing(struct device *dev, void *timing)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO. */
-
-	return 0;
-}
-
-static int fimd_display_power_on(struct device *dev, int mode)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO */
-
-	return 0;
-}
-
-static struct rockchip_drm_display_ops fimd_display_ops = {
-	.type = ROCKCHIP_DISPLAY_TYPE_LCD,
-	.is_connected = fimd_display_is_connected,
-	.get_panel = fimd_get_panel,
-	.check_timing = fimd_check_timing,
-	.power_on = fimd_display_power_on,
-};
-
-static void fimd_dpms(struct device *subdrv_dev, int mode)
-{
-	struct fimd_context *ctx = get_fimd_context(subdrv_dev);
-
-	DRM_DEBUG_KMS("%s, %d\n", __FILE__, mode);
-
-	mutex_lock(&ctx->lock);
-
-	switch (mode) {
-	case DRM_MODE_DPMS_ON:
-		/*
-		 * enable fimd hardware only if suspended status.
-		 *
-		 * P.S. fimd_dpms function would be called at booting time so
-		 * clk_enable could be called double time.
-		 */
-		if (ctx->suspended)
-			pm_runtime_get_sync(subdrv_dev);
-		break;
-	case DRM_MODE_DPMS_STANDBY:
-	case DRM_MODE_DPMS_SUSPEND:
-	case DRM_MODE_DPMS_OFF:
-		if (!ctx->suspended)
-			pm_runtime_put_sync(subdrv_dev);
-		break;
-	default:
-		DRM_DEBUG_KMS("unspecified mode %d\n", mode);
-		break;
-	}
-
-	mutex_unlock(&ctx->lock);
-}
-
-static void fimd_apply(struct device *subdrv_dev)
-{
-	struct fimd_context *ctx = get_fimd_context(subdrv_dev);
-	struct rockchip_drm_manager *mgr = ctx->subdrv.manager;
-	struct rockchip_drm_manager_ops *mgr_ops = mgr->ops;
-	struct rockchip_drm_overlay_ops *ovl_ops = mgr->overlay_ops;
-	struct fimd_win_data *win_data;
-	int i;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		if (win_data->enabled && (ovl_ops && ovl_ops->commit))
-			ovl_ops->commit(subdrv_dev, i);
-	}
-
-	if (mgr_ops && mgr_ops->commit)
-		mgr_ops->commit(subdrv_dev);
-}
-
-static void fimd_commit(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct rockchip_drm_panel_info *panel = ctx->panel;
-	struct rk_screen *screen = ctx->screen;
-	u16 right_margin = screen->mode.right_margin;
-	u16 left_margin = screen->mode.left_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	int face;
-
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if (ctx->suspended)
-		return;
-
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if(!ctx->clkon)
-		return;
-#if 1
-	switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
-			lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-			break;
-		default:
-			printk( "un supported interface!\n");
-			break;
-	}
-	mask = m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
-		m_DEN_POL | m_DCLK_POL;
-	val = v_DSP_OUT_FORMAT(face) | v_HSYNC_POL(screen->pin_hsync) |
-		v_VSYNC_POL(screen->pin_vsync) | v_DEN_POL(screen->pin_den) |
-		v_DCLK_POL(screen->pin_dclk);
-	lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-
-	mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
-		m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		m_DSP_DUMMY_SWAP | m_BLANK_EN;
-	val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
-		v_DSP_RB_SWAP(screen->swap_rb) | v_DSP_RG_SWAP(screen->
-				swap_rg) |
-		v_DSP_DELTA_SWAP(screen->
-				swap_delta) | v_DSP_DUMMY_SWAP(screen->
-					swap_dumy) |
-				v_BLANK_EN(0) | v_BLACK_EN(0);
-	lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-	val =
-		v_HSYNC(screen->mode.hsync_len) | v_HORPRD(screen->mode.
-				hsync_len +
-				left_margin +
-				x_res +
-				right_margin);
-	lcdc_writel(ctx, DSP_HTOTAL_HS_END, val);
-	val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
-		v_HASP(screen->mode.hsync_len + left_margin);
-	lcdc_writel(ctx, DSP_HACT_ST_END, val);
-
-	val =
-		v_VSYNC(screen->mode.vsync_len) | v_VERPRD(screen->mode.
-				vsync_len +
-				upper_margin +
-				y_res +
-				lower_margin);
-	lcdc_writel(ctx, DSP_VTOTAL_VS_END, val);
-
-	val = v_VAEP(screen->mode.vsync_len + upper_margin + y_res) |
-		v_VASP(screen->mode.vsync_len + screen->mode.upper_margin);
-	lcdc_writel(ctx, DSP_VACT_ST_END, val);
-
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-	lcdc_msk_reg(ctx, SYS_CTRL, m_LCDC_STANDBY,
-			v_LCDC_STANDBY(0));
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-	lcdc_msk_reg(ctx, SYS_CTRL,
-			m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP |
-			m_WIN1_RB_SWAP,
-			v_WIN0_EN(1) | v_WIN1_EN(0) |
-			v_WIN0_RB_SWAP(screen->swap_rb) |
-			v_WIN1_RB_SWAP(screen->swap_rb));
-	lcdc_cfg_done(ctx);
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-#endif
-}
-
-static int fimd_enable_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	u32 val,mask;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (ctx->suspended)
-		return -EPERM;
-
-	if (!test_and_set_bit(0, &ctx->irq_flags)) {
-#if 1
-		mask = m_HS_INT_CLEAR | m_HS_INT_EN | m_FS_INT_CLEAR |
-			m_FS_INT_EN | m_LF_INT_EN | m_LF_INT_CLEAR |
-			m_LF_INT_NUM | m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN;
-		val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1) | v_HS_INT_CLEAR(0) |
-			v_HS_INT_EN(0) | v_LF_INT_CLEAR(0) | v_LF_INT_EN(0);
-		lcdc_msk_reg(ctx, INT_STATUS, mask, val);
-		lcdc_cfg_done(ctx);
-#endif
-	}
-
-	return 0;
-}
-
-static void fimd_disable_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	u32 val,mask;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (ctx->suspended)
-		return;
-
-	if (test_and_clear_bit(0, &ctx->irq_flags)) {
-#if 1
-		lcdc_msk_reg(ctx, INT_STATUS, m_FS_INT_CLEAR,
-				v_FS_INT_CLEAR(1));
-		mask = m_HS_INT_EN | m_FS_INT_EN | m_LF_INT_EN |
-			m_BUS_ERR_INT_EN;
-		val = v_HS_INT_EN(0) | v_FS_INT_EN(0) |
-			v_LF_INT_EN(0) | v_BUS_ERR_INT_EN(0);
-		lcdc_msk_reg(ctx, INT_STATUS, mask, val);
-#endif
-
-	}
-}
-
-static void fimd_wait_for_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	if (ctx->suspended)
-		return;
-
-	atomic_set(&ctx->wait_vsync_event, 1);
-
-	/*
-	 * wait for FIMD to signal VSYNC interrupt or return after
-	 * timeout which is set to 50ms (refresh rate of 20).
-	 */
-	if (!wait_event_timeout(ctx->wait_vsync_queue,
-				!atomic_read(&ctx->wait_vsync_event),
-				DRM_HZ/20))
-		DRM_DEBUG_KMS("vblank wait timed out.\n");
-}
-
-static struct rockchip_drm_manager_ops fimd_manager_ops = {
-	.dpms = fimd_dpms,
-	.apply = fimd_apply,
-	.commit = fimd_commit,
-	.enable_vblank = fimd_enable_vblank,
-	.disable_vblank = fimd_disable_vblank,
-	.wait_for_vblank = fimd_wait_for_vblank,
-};
-
-static void fimd_win_mode_set(struct device *dev,
-			      struct rockchip_drm_overlay *overlay)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int win;
-	unsigned long offset;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (!overlay) {
-		dev_err(dev, "overlay is NULL\n");
-		return;
-	}
-
-	win = overlay->zpos;
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	offset = overlay->fb_x * (overlay->bpp >> 3);
-	offset += overlay->fb_y * overlay->pitch;
-
-	DRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);
-
-	win_data = &ctx->win_data[win];
-
-	win_data->offset_x = overlay->crtc_x;
-	win_data->offset_y = overlay->crtc_y;
-	win_data->ovl_width = overlay->crtc_width;
-	win_data->ovl_height = overlay->crtc_height;
-	win_data->fb_width = overlay->fb_width;
-	win_data->fb_height = overlay->fb_height;
-	win_data->dma_addr = overlay->dma_addr[0] + offset;
-	win_data->bpp = overlay->bpp;
-	win_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *
-				(overlay->bpp >> 3);
-	win_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);
-
-	DRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",
-			win_data->offset_x, win_data->offset_y);
-	DRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",
-			win_data->ovl_width, win_data->ovl_height);
-	DRM_DEBUG_KMS("paddr = 0x%lx\n", (unsigned long)win_data->dma_addr);
-	DRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",
-			overlay->fb_width, overlay->crtc_width);
-}
-
-static void fimd_win_set_pixfmt(struct device *dev, unsigned int win)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data = &ctx->win_data[win];
-	u8 fmt_cfg = 0;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-	switch(win_data->bpp){
-		case 32:
-			fmt_cfg = 0;
-			break;
-		case 24:
-			fmt_cfg = 1;
-			break;
-		case 16:
-			fmt_cfg = 2;
-			break;
-		default:
-			printk("not support format %d\n",win_data->bpp);
-			break;
-	}
-
-
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-	lcdc_msk_reg(ctx , SYS_CTRL, m_WIN0_FORMAT, v_WIN0_FORMAT(fmt_cfg));
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-}
-
-static void fimd_win_set_colkey(struct device *dev, unsigned int win)
-{
-//	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-}
-
-static void fimd_win_commit(struct device *dev, int zpos)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	struct rk_screen *screen = ctx->screen;
-	int win = zpos;
-	unsigned long val,  size;
-	u32 xpos, ypos;
-
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-
-	if (ctx->suspended)
-		return;
-
-	if (!ctx->clkon)
-		return;
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	win_data = &ctx->win_data[win];
-#if 1
-	/*
-	 * SHADOWCON register is used for enabling timing.
-	 *
-	 * for example, once only width value of a register is set,
-	 * if the dma is started then fimd hardware could malfunction so
-	 * with protect window setting, the register fields with prefix '_F'
-	 * wouldn't be updated at vsync also but updated once unprotect window
-	 * is set.
-	 */
-	
-	/* buffer end address */
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	size = win_data->fb_width * win_data->ovl_height * (win_data->bpp >> 3);
-	val = (unsigned long)(win_data->dma_addr + size);
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	printk(KERN_ERR"ctx->regs=%x\n", __func__,__LINE__,ctx->regs);
-	printk(KERN_ERR"-->yzq dma_addr=%x buf_offsize=%x win_data->fb_width=%d \nwin_data->fb_height=%d win_data->ovl_height=%d  win_data->ovl_width=%d \n win_data->offset_x=%d win_data->offset_y=%d win_data->line_size=%d\n win_data->bpp=%d ",win_data->dma_addr,win_data->buf_offsize,win_data->fb_width,win_data->fb_height,win_data->ovl_height, win_data->ovl_width,win_data->offset_x,win_data->offset_y,win_data->line_size,win_data->bpp);
-	xpos = win_data->offset_x + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win_data->offset_y + screen->mode.upper_margin + screen->mode.vsync_len;
-
-	lcdc_writel(ctx, WIN0_YRGB_MST0, win_data->dma_addr +win_data->buf_offsize );
-	//lcdc_writel(ctx, WIN0_CBR_MST0, win0->area[0].uv_addr);
-
-//	lcdc_writel(ctx, WIN0_SCL_FACTOR_YRGB,
-//			v_X_SCL_FACTOR(win0->scale_yrgb_x) |
-//			v_Y_SCL_FACTOR(win0->scale_yrgb_y));
-//	lcdc_writel(ctx, WIN0_SCL_FACTOR_CBR,
-//			v_X_SCL_FACTOR(win0->scale_cbcr_x) |
-//			v_Y_SCL_FACTOR(win0->scale_cbcr_y));
-	lcdc_writel(ctx, WIN0_ACT_INFO, v_ACT_WIDTH(win_data->ovl_width) |
-			v_ACT_HEIGHT(win_data->ovl_height));
-	lcdc_writel(ctx, WIN0_DSP_ST, v_DSP_STX(xpos) |
-			v_DSP_STY(ypos));
-	lcdc_writel(ctx, WIN0_DSP_INFO, v_DSP_WIDTH(win_data->fb_width) |
-			v_DSP_HEIGHT(win_data->fb_height));
-	lcdc_msk_reg(ctx, WIN_VIR, m_WIN0_VIR,
-			v_WIN0_VIR_VAL(win_data->line_size/(win_data->bpp>>3)));
-	lcdc_cfg_done(ctx);
-
-#if 0
-	/* protect windows */
-	val = readl(ctx->regs + SHADOWCON);
-	val |= SHADOWCON_WINx_PROTECT(win);
-	writel(val, ctx->regs + SHADOWCON);
-
-	/* buffer start address */
-	val = (unsigned long)win_data->dma_addr;
-	writel(val, ctx->regs + VIDWx_BUF_START(win, 0));
-
-
-	DRM_DEBUG_KMS("start addr = 0x%lx, end addr = 0x%lx, size = 0x%lx\n",
-			(unsigned long)win_data->dma_addr, val, size);
-	DRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",
-			win_data->ovl_width, win_data->ovl_height);
-
-	/* buffer size */
-	val = VIDW_BUF_SIZE_OFFSET(win_data->buf_offsize) |
-		VIDW_BUF_SIZE_PAGEWIDTH(win_data->line_size) |
-		VIDW_BUF_SIZE_OFFSET_E(win_data->buf_offsize) |
-		VIDW_BUF_SIZE_PAGEWIDTH_E(win_data->line_size);
-	writel(val, ctx->regs + VIDWx_BUF_SIZE(win, 0));
-
-	/* OSD position */
-	val = VIDOSDxA_TOPLEFT_X(win_data->offset_x) |
-		VIDOSDxA_TOPLEFT_Y(win_data->offset_y) |
-		VIDOSDxA_TOPLEFT_X_E(win_data->offset_x) |
-		VIDOSDxA_TOPLEFT_Y_E(win_data->offset_y);
-	writel(val, ctx->regs + VIDOSD_A(win));
-
-	last_x = win_data->offset_x + win_data->ovl_width;
-	if (last_x)
-		last_x--;
-	last_y = win_data->offset_y + win_data->ovl_height;
-	if (last_y)
-		last_y--;
-
-	val = VIDOSDxB_BOTRIGHT_X(last_x) | VIDOSDxB_BOTRIGHT_Y(last_y) |
-		VIDOSDxB_BOTRIGHT_X_E(last_x) | VIDOSDxB_BOTRIGHT_Y_E(last_y);
-
-	writel(val, ctx->regs + VIDOSD_B(win));
-
-	DRM_DEBUG_KMS("osd pos: tx = %d, ty = %d, bx = %d, by = %d\n",
-			win_data->offset_x, win_data->offset_y, last_x, last_y);
-
-	/* hardware window 0 doesn't support alpha channel. */
-	if (win != 0) {
-		/* OSD alpha */
-		alpha = VIDISD14C_ALPHA1_R(0xf) |
-			VIDISD14C_ALPHA1_G(0xf) |
-			VIDISD14C_ALPHA1_B(0xf);
-
-		writel(alpha, ctx->regs + VIDOSD_C(win));
-	}
-
-	/* OSD size */
-	if (win != 3 && win != 4) {
-		u32 offset = VIDOSD_D(win);
-		if (win == 0)
-			offset = VIDOSD_C(win);
-		val = win_data->ovl_width * win_data->ovl_height;
-		writel(val, ctx->regs + offset);
-
-		DRM_DEBUG_KMS("osd size = 0x%x\n", (unsigned int)val);
-	}
-
-	fimd_win_set_pixfmt(dev, win);
-
-	/* hardware window 0 doesn't support color key. */
-	if (win != 0)
-		fimd_win_set_colkey(dev, win);
-
-	/* wincon */
-	val = readl(ctx->regs + WINCON(win));
-	val |= WINCONx_ENWIN;
-	writel(val, ctx->regs + WINCON(win));
-
-	/* Enable DMA channel and unprotect windows */
-	val = readl(ctx->regs + SHADOWCON);
-	val |= SHADOWCON_CHx_ENABLE(win);
-	val &= ~SHADOWCON_WINx_PROTECT(win);
-	writel(val, ctx->regs + SHADOWCON);
-#endif
-#endif
-	win_data->enabled = true;
-
-}
-
-static void fimd_win_disable(struct device *dev, int zpos)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int win = zpos;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	win_data = &ctx->win_data[win];
-
-	if (ctx->suspended) {
-		/* do not resume this window*/
-		win_data->resume = false;
-		return;
-	}
-
-	win_data->enabled = false;
-}
-
-static struct rockchip_drm_overlay_ops fimd_overlay_ops = {
-	.mode_set = fimd_win_mode_set,
-	.commit = fimd_win_commit,
-	.disable = fimd_win_disable,
-};
-
-static struct rockchip_drm_manager fimd_manager = {
-	.pipe		= -1,
-	.ops		= &fimd_manager_ops,
-	.overlay_ops	= &fimd_overlay_ops,
-	.display_ops	= &fimd_display_ops,
-};
-
-static irqreturn_t fimd_irq_handler(int irq, void *dev_id)
-{
-	struct fimd_context *ctx = (struct fimd_context *)dev_id;
-	struct rockchip_drm_subdrv *subdrv = &ctx->subdrv;
-	struct drm_device *drm_dev = subdrv->drm_dev;
-	struct rockchip_drm_manager *manager = subdrv->manager;
-	u32 int_reg = lcdc_readl(ctx, INT_STATUS);
-
-	if (int_reg & m_FS_INT_STA) {
-		lcdc_msk_reg(ctx, INT_STATUS, m_FS_INT_CLEAR,
-			     v_FS_INT_CLEAR(1));
-	}
-
-	/* check the crtc is detached already from encoder */
-	if (manager->pipe < 0)
-		goto out;
-
-	drm_handle_vblank(drm_dev, manager->pipe);
-	rockchip_drm_crtc_finish_pageflip(drm_dev, manager->pipe);
-
-	/* set wait vsync event to zero and wake up queue. */
-	if (atomic_read(&ctx->wait_vsync_event)) {
-		atomic_set(&ctx->wait_vsync_event, 0);
-		DRM_WAKEUP(&ctx->wait_vsync_queue);
-	}
-out:
-	return IRQ_HANDLED;
-}
-
-static int fimd_subdrv_probe(struct drm_device *drm_dev, struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/*
-	 * enable drm irq mode.
-	 * - with irq_enabled = 1, we can use the vblank feature.
-	 *
-	 * P.S. note that we wouldn't use drm irq handler but
-	 *	just specific driver own one instead because
-	 *	drm framework supports only one irq handler.
-	 */
-	drm_dev->irq_enabled = 1;
-
-	/*
-	 * with vblank_disable_allowed = 1, vblank interrupt will be disabled
-	 * by drm timer once a current process gives up ownership of
-	 * vblank event.(after drm_vblank_put function is called)
-	 */
-	drm_dev->vblank_disable_allowed = 1;
-
-	/* attach this sub driver to iommu mapping if supported. */
-	if (is_drm_iommu_supported(drm_dev))
-		drm_iommu_attach_device(drm_dev, dev);
-
-	return 0;
-}
-
-static void fimd_subdrv_remove(struct drm_device *drm_dev, struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* detach this sub driver from iommu mapping if supported. */
-	if (is_drm_iommu_supported(drm_dev))
-		drm_iommu_detach_device(drm_dev, dev);
-}
-
-
-static void fimd_clear_win(struct fimd_context *ctx, int win)
-{
-	u32 val;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-}
-
-static int fimd_clock(struct fimd_context *ctx, bool enable)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-printk(KERN_ERR"---->yzq %s %d \n",__func__,__LINE__);
-	if (enable) {
-		if(ctx->clkon)
-			return 0;
-		int ret;
-
-		ret = clk_prepare_enable(ctx->hclk);
-		if (ret < 0)
-			return ret;
-
-		ret = clk_prepare_enable(ctx->dclk);
-		if (ret < 0)
-			return ret;
-		
-		ret = clk_prepare_enable(ctx->aclk);
-		if (ret < 0)
-			return ret;
-		ctx->clkon=1;
-	} else {
-		if(!ctx->clkon)
-			return 0;
-		clk_disable_unprepare(ctx->aclk);
-		clk_disable_unprepare(ctx->dclk);
-		clk_disable_unprepare(ctx->hclk);
-		ctx->clkon=0;
-	}
-
-	return 0;
-}
-
-static void fimd_window_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int i;
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		win_data->resume = win_data->enabled;
-		fimd_win_disable(dev, i);
-	}
-	fimd_wait_for_vblank(dev);
-}
-
-static void fimd_window_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int i;
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		win_data->enabled = win_data->resume;
-		win_data->resume = false;
-	}
-}
-
-static int fimd_activate(struct fimd_context *ctx, bool enable)
-{
-	struct device *dev = ctx->subdrv.dev;
-	if (enable) {
-		int ret;
-
-		ret = fimd_clock(ctx, true);
-		if (ret < 0)
-			return ret;
-
-		ctx->suspended = false;
-
-		/* if vblank was enabled status, enable it again. */
-		if (test_and_clear_bit(0, &ctx->irq_flags))
-			fimd_enable_vblank(dev);
-
-		fimd_window_resume(dev);
-	} else {
-		fimd_window_suspend(dev);
-
-		fimd_clock(ctx, false);
-		ctx->suspended = true;
-	}
-
-	return 0;
-}
-
-int rk_fb_video_mode_from_timing(const struct display_timing *dt, 
-				struct rk_screen *screen)
-{
-	screen->mode.pixclock = dt->pixelclock.typ;
-	screen->mode.left_margin = dt->hback_porch.typ;
-	screen->mode.right_margin = dt->hfront_porch.typ;
-	screen->mode.xres = dt->hactive.typ;
-	screen->mode.hsync_len = dt->hsync_len.typ;
-	screen->mode.upper_margin = dt->vback_porch.typ;
-	screen->mode.lower_margin = dt->vfront_porch.typ;
-	screen->mode.yres = dt->vactive.typ;
-	screen->mode.vsync_len = dt->vsync_len.typ;
-	screen->type = dt->screen_type;
-	screen->lvds_format = dt->lvds_format;
-	screen->face = dt->face;
-
-	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
-		screen->pin_dclk = 1;
-	else
-		screen->pin_dclk = 0;
-	if(dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_DE_HIGH)
-		screen->pin_den = 1;
-	else
-		screen->pin_den = 0;
-	
-	return 0;
-	
-}
-
-int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
-{
-	struct display_timings *disp_timing;
-	struct display_timing *dt;
-	disp_timing = of_get_display_timings(np);
-	if (!disp_timing) {
-		pr_err("parse display timing err\n");
-		return -EINVAL;
-	}
-	dt = display_timings_get(disp_timing, 0);
-	rk_fb_video_mode_from_timing(dt, screen);
-	printk(KERN_DEBUG "dclk:%d\n"
-			 "hactive:%d\n"
-			 "hback_porch:%d\n"
-			 "hfront_porch:%d\n"
-			 "hsync_len:%d\n"
-			 "vactive:%d\n"
-			 "vback_porch:%d\n"
-			 "vfront_porch:%d\n"
-			 "vsync_len:%d\n"
-			 "screen_type:%d\n"
-			 "lvds_format:%d\n"
-			 "face:%d\n",
-			dt->pixelclock.typ,
-			dt->hactive.typ,
-			dt->hback_porch.typ,
-			dt->hfront_porch.typ,
-			dt->hsync_len.typ,
-			dt->vactive.typ,
-			dt->vback_porch.typ,
-			dt->vfront_porch.typ,
-			dt->vsync_len.typ,
-			dt->screen_type,
-			dt->lvds_format,
-			dt->face);
-	return 0;
-
-}
-
-static int fimd_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fimd_context *ctx;
-	struct rockchip_drm_subdrv *subdrv;
-	struct rockchip_drm_fimd_pdata *pdata;
-	struct rockchip_drm_panel_info *panel;
-	struct device_node *np = pdev->dev.of_node;
-	struct rk_screen *screen;
-	int prop;
-	int reg_len;
-	struct resource *res;
-	int win;
-	int ret = -EINVAL;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		printk("---->%s not support lcdc EXTEND\n");
-			return 0;
-	}
-	printk("------>yzq dev=%x \n",dev);
-	if (dev->of_node) {
-		printk("------>yzq %s %d \n",__func__,__LINE__);
-		panel = devm_kzalloc(dev, sizeof(struct rockchip_drm_panel_info), GFP_KERNEL);
-		screen = devm_kzalloc(dev, sizeof(struct rk_screen), GFP_KERNEL);
-		rk_fb_get_prmry_screen(screen);
-		memcpy(&panel->timing,&screen->mode,sizeof(struct fb_videomode)); 
-	} else {
-		DRM_ERROR("no platform data specified\n");
-		return -EINVAL;
-	}
-
-	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
-	if (!ctx)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	ctx->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(ctx->regs))
-		return PTR_ERR(ctx->regs);
-	reg_len = resource_size(res);
-	ctx->regsbak = devm_kzalloc(dev,reg_len,GFP_KERNEL);
-	ctx->lcdc_id = rk3188_lcdc_get_id(res->start);	
-	ctx->screen = screen;
-	if(ctx->lcdc_id == 0){
-		ctx->hclk = clk_get(NULL, "g_h_lcdc0");
-		ctx->aclk = clk_get(NULL, "aclk_lcdc0");
-		ctx->dclk = clk_get(NULL, "dclk_lcdc0");
-	}else{
-		ctx->hclk = clk_get(NULL, "g_h_lcdc1");
-		ctx->aclk = clk_get(NULL, "aclk_lcdc1");
-		ctx->dclk = clk_get(NULL, "dclk_lcdc1");
-	}
-
-	ctx->irq = platform_get_irq(pdev, 0);
-	if (ctx->irq < 0) {
-		dev_err(dev, "cannot find IRQ for lcdc%d\n",
-			ctx->lcdc_id);
-		return -ENXIO;
-	}
-	ret = devm_request_irq(dev, ctx->irq, fimd_irq_handler,
-							0, "drm_fimd", ctx);
-	if (ret) {
-		dev_err(dev, "irq request failed.\n");
-		return ret;
-	}
-
-	ctx->default_win = 0;// pdata->default_win;
-	ctx->panel = panel;
-	DRM_INIT_WAITQUEUE(&ctx->wait_vsync_queue);
-	atomic_set(&ctx->wait_vsync_event, 0);
-
-	subdrv = &ctx->subdrv;
-
-	subdrv->dev = dev;
-	subdrv->manager = &fimd_manager;
-	subdrv->probe = fimd_subdrv_probe;
-	subdrv->remove = fimd_subdrv_remove;
-
-	mutex_init(&ctx->lock);
-
-	platform_set_drvdata(pdev, ctx);
-
-	pm_runtime_enable(dev);
-	pm_runtime_get_sync(dev);
-	
-	ret = clk_set_rate(ctx->dclk, ctx->screen->mode.pixclock);
-	if (ret)
-		printk( "set lcdc%d dclk failed\n", ctx->lcdc_id);
-	
-	fimd_activate(ctx, true);
-
-	memcpy(ctx->regsbak,ctx->regs,reg_len);
-	rockchip_drm_subdrv_register(subdrv);
-
-	return 0;
-}
-
-static int fimd_remove(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fimd_context *ctx = platform_get_drvdata(pdev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	rockchip_drm_subdrv_unregister(&ctx->subdrv);
-
-	if (ctx->suspended)
-		goto out;
-
-	pm_runtime_set_suspended(dev);
-	pm_runtime_put_sync(dev);
-
-out:
-	pm_runtime_disable(dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int fimd_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	/*
-	 * do not use pm_runtime_suspend(). if pm_runtime_suspend() is
-	 * called here, an error would be returned by that interface
-	 * because the usage_count of pm runtime is more than 1.
-	 */
-	if (!pm_runtime_suspended(dev))
-		return fimd_activate(ctx, false);
-
-	return 0;
-}
-
-static int fimd_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	/*
-	 * if entered to sleep when lcd panel was on, the usage_count
-	 * of pm runtime would still be 1 so in this case, fimd driver
-	 * should be on directly not drawing on pm runtime interface.
-	 */
-	if (!pm_runtime_suspended(dev)) {
-		int ret;
-
-		ret = fimd_activate(ctx, true);
-		if (ret < 0)
-			return ret;
-
-		/*
-		 * in case of dpms on(standby), fimd_apply function will
-		 * be called by encoder's dpms callback to update fimd's
-		 * registers but in case of sleep wakeup, it's not.
-		 * so fimd_apply function should be called at here.
-		 */
-		fimd_apply(dev);
-	}
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
-static int fimd_runtime_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return fimd_activate(ctx, false);
-}
-
-static int fimd_runtime_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return fimd_activate(ctx, true);
-}
-#endif
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3188_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3188-lcdc",},
-	{}
-};
-#endif
-
-static const struct dev_pm_ops fimd_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(fimd_suspend, fimd_resume)
-	SET_RUNTIME_PM_OPS(fimd_runtime_suspend, fimd_runtime_resume, NULL)
-};
-
-struct platform_driver fimd_driver = {
-	.probe		= fimd_probe,
-	.remove		= fimd_remove,
-	.id_table       = rk3188_lcdc_dt_ids,
-	.driver		= {
-		.name	= "rk3188-lcdc",
-		.owner	= THIS_MODULE,
-		.pm	= &fimd_pm_ops,
-		.of_match_table = of_match_ptr(rk3188_lcdc_dt_ids),
-	},
-};
diff --git a/drivers/gpu/drm/rockchip/rk3288_drm_fimd.c b/drivers/gpu/drm/rockchip/rk3288_drm_fimd.c
deleted file mode 100644
index 2028371aa4ca..000000000000
--- a/drivers/gpu/drm/rockchip/rk3288_drm_fimd.c
+++ /dev/null
@@ -1,1480 +0,0 @@
-/*
- * rk3288_drm_fimd.c
- *
- * Copyright (C) ROCKCHIP, Inc.
- * Author:yzq<yzq@rock-chips.com>
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <drm/drmP.h>
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
-
-#include <video/of_display_timing.h>
-#include <drm/rockchip_drm.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rk_fb.h>
-#include <video/display_timing.h>
-#include <linux/rockchip/cpu.h>
-#include <linux/rockchip/iomap.h>
-#include <linux/rockchip/grf.h>
-#include "rockchip_drm_drv.h"
-#include "rockchip_drm_fbdev.h"
-#include "rockchip_drm_crtc.h"
-#include "rockchip_drm_iommu.h"
-
-/*
- * FIMD is stand for Fully Interactive Mobile Display and
- * as a display controller, it transfers contents drawn on memory
- * to a LCD Panel through Display Interfaces such as RGB or
- * CPU Interface.
- */
-
-/* position control register for hardware window 0, 2 ~ 4.*/
-#define VIDOSD_A(win)		(VIDOSD_BASE + 0x00 + (win) * 16)
-#define VIDOSD_B(win)		(VIDOSD_BASE + 0x04 + (win) * 16)
-/*
- * size control register for hardware windows 0 and alpha control register
- * for hardware windows 1 ~ 4
- */
-#define VIDOSD_C(win)		(VIDOSD_BASE + 0x08 + (win) * 16)
-/* size control register for hardware windows 1 ~ 2. */
-#define VIDOSD_D(win)		(VIDOSD_BASE + 0x0C + (win) * 16)
-
-#define VIDWx_BUF_START(win, buf)	(VIDW_BUF_START(buf) + (win) * 8)
-#define VIDWx_BUF_END(win, buf)		(VIDW_BUF_END(buf) + (win) * 8)
-#define VIDWx_BUF_SIZE(win, buf)	(VIDW_BUF_SIZE(buf) + (win) * 4)
-
-/* color key control register for hardware window 1 ~ 4. */
-#define WKEYCON0_BASE(x)		((WKEYCON0 + 0x140) + ((x - 1) * 8))
-/* color key value register for hardware window 1 ~ 4. */
-#define WKEYCON1_BASE(x)		((WKEYCON1 + 0x140) + ((x - 1) * 8))
-
-/* FIMD has totally five hardware windows. */
-#define WINDOWS_NR	4
-/*****************************************************************************************************/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
-#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
-
-#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
-#define SCALE_FACTOR_AVRG_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
-#define SCALE_FACTOR_BIC_FIXPOINT(x)       ((INT32)((x)*(1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
-
-#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
-#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
-
-/*****************************************************************************************************/
-
-/*#define GET_SCALE_FACTOR_BILI(src, dst) ((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*#define GET_SCALE_FACTOR_BIC(src, dst)  ((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
-/*modified by hpz*/
-#define GET_SCALE_FACTOR_BILI_DN(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-#define GET_SCALE_FACTOR_BILI_UP(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-#define GET_SCALE_FACTOR_BIC(src, dst)      ((((src)*2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT-1)) / ((dst) - 1))
-
-#define get_fimd_context(dev)	platform_get_drvdata(to_platform_device(dev))
-
-static struct rk_fb_trsm_ops *trsm_lvds_ops;
-static struct rk_fb_trsm_ops *trsm_edp_ops;
-static struct rk_fb_trsm_ops *trsm_mipi_ops;
-
-int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)
-{
-	switch (type) {
-	case SCREEN_RGB:
-	case SCREEN_LVDS:
-	case SCREEN_DUAL_LVDS:
-		trsm_lvds_ops = ops;
-		break;
-	case SCREEN_EDP:
-		trsm_edp_ops = ops;
-		break;
-	case SCREEN_MIPI:
-	case SCREEN_DUAL_MIPI:
-		trsm_mipi_ops = ops;
-		break;
-	default:
-		printk(KERN_WARNING "%s:un supported transmitter:%d!\n",
-			__func__, type);
-		break;
-	}
-	return 0;
-}
-struct fimd_driver_data {
-	unsigned int timing_base;
-};
-
-static struct fimd_driver_data rockchip4_fimd_driver_data = {
-	.timing_base = 0x0,
-};
-
-static struct fimd_driver_data rockchip5_fimd_driver_data = {
-	.timing_base = 0x20000,
-};
-
-struct fimd_win_data {
-	unsigned int		offset_x;
-	unsigned int		offset_y;
-	unsigned int		ovl_width;
-	unsigned int		ovl_height;
-	unsigned int		fb_width;
-	unsigned int		fb_height;
-	unsigned int		bpp;
-	dma_addr_t		dma_addr;
-	unsigned int		buf_offsize;
-	unsigned int		line_size;	/* bytes */
-	bool			enabled;
-	bool			resume;
-};
-
-struct fimd_context {
-	struct rockchip_drm_subdrv	subdrv;
-	int				irq;
-	struct drm_crtc			*crtc;
-	struct clk			*pd;				//lcdc power domain
-	struct clk			*hclk;				//lcdc AHP clk
-	struct clk			*dclk;				//lcdc dclk
-	struct clk			*aclk;				//lcdc share memory frequency
-	void __iomem			*regs;
-	struct fimd_win_data		win_data[WINDOWS_NR];
-	unsigned int			clkdiv;
-	unsigned int			default_win;
-	unsigned long			irq_flags;
-	u32				vidcon0;
-	u32				vidcon1;
-	int 				lcdc_id;
-	bool				suspended;
-	struct mutex			lock;
-	wait_queue_head_t		wait_vsync_queue;
-	atomic_t			wait_vsync_event;
-
-	int clkon;
-	void *regsbak;			//back up reg
-	struct rockchip_drm_panel_info *panel;
-	struct rk_screen *screen;
-};
-
-#include "rk3288_drm_fimd.h"
-static int rk3288_lcdc_get_id(u32 phy_base)
-{
-	if (cpu_is_rk3288()) {
-		if (phy_base == 0xff930000)/*vop big*/
-			return 0;
-		else if (phy_base == 0xff940000)/*vop lit*/	
-			return 1;
-		else
-			return -EINVAL;
-	} else {
-		pr_err("un supported platform \n");
-		return -EINVAL;
-	}
-}
-
-
-static bool fimd_display_is_connected(struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO. */
-
-	return true;
-}
-
-static void *fimd_get_panel(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return ctx->panel;
-}
-
-static int fimd_check_timing(struct device *dev, void *timing)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO. */
-
-	return 0;
-}
-
-static int fimd_display_power_on(struct device *dev, int mode)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* TODO */
-
-	return 0;
-}
-
-static struct rockchip_drm_display_ops fimd_display_ops = {
-	.type = ROCKCHIP_DISPLAY_TYPE_LCD,
-	.is_connected = fimd_display_is_connected,
-	.get_panel = fimd_get_panel,
-	.check_timing = fimd_check_timing,
-	.power_on = fimd_display_power_on,
-};
-
-static void fimd_dpms(struct device *subdrv_dev, int mode)
-{
-	struct fimd_context *ctx = get_fimd_context(subdrv_dev);
-
-	DRM_DEBUG_KMS("%s, %d\n", __FILE__, mode);
-
-	mutex_lock(&ctx->lock);
-
-	switch (mode) {
-	case DRM_MODE_DPMS_ON:
-		/*
-		 * enable fimd hardware only if suspended status.
-		 *
-		 * P.S. fimd_dpms function would be called at booting time so
-		 * clk_enable could be called double time.
-		 */
-
-		if(trsm_lvds_ops != NULL){
-			printk(KERN_ERR"------>yzq enable lvds\n");	
-			trsm_lvds_ops->enable();
-		}
-		if (ctx->suspended)
-			pm_runtime_get_sync(subdrv_dev);
-		break;
-	case DRM_MODE_DPMS_STANDBY:
-	case DRM_MODE_DPMS_SUSPEND:
-	case DRM_MODE_DPMS_OFF:
-		if (!ctx->suspended)
-			pm_runtime_put_sync(subdrv_dev);
-		break;
-	default:
-		DRM_DEBUG_KMS("unspecified mode %d\n", mode);
-		break;
-	}
-
-	mutex_unlock(&ctx->lock);
-}
-
-static void fimd_apply(struct device *subdrv_dev)
-{
-	struct fimd_context *ctx = get_fimd_context(subdrv_dev);
-	struct rockchip_drm_manager *mgr = ctx->subdrv.manager;
-	struct rockchip_drm_manager_ops *mgr_ops = mgr->ops;
-	struct rockchip_drm_overlay_ops *ovl_ops = mgr->overlay_ops;
-	struct fimd_win_data *win_data;
-	int i;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		if (win_data->enabled && (ovl_ops && ovl_ops->commit))
-			ovl_ops->commit(subdrv_dev, i);
-	}
-
-	if (mgr_ops && mgr_ops->commit)
-		mgr_ops->commit(subdrv_dev);
-}
-
-static int rk3288_lcdc_alpha_cfg(struct fimd_context *ctx,int win_id)
-{
-	struct alpha_config alpha_config;
-	struct fimd_win_data *win_data;
-	enum alpha_mode alpha_mode;
-	u32 mask, val;
-	int ppixel_alpha,global_alpha;
-	u32 src_alpha_ctl,dst_alpha_ctl;
-	int g_alpha_val=0;
-
-	win_data = &ctx->win_data[win_id];
-	ppixel_alpha = (win_data->bpp==32) ? 1 : 0;
-	global_alpha = 1; 
-	alpha_config.src_global_alpha_val = 1;
-	alpha_mode = AB_SRC_OVER;
-	global_alpha = (g_alpha_val == 0) ? 0 : 1; 
-	alpha_config.src_global_alpha_val = g_alpha_val;
-	/*printk("%s,alpha_mode=%d,alpha_en=%d,ppixel_a=%d,gla_a=%d\n",
-		__func__,win->alpha_mode,win->alpha_en,ppixel_alpha,global_alpha);*/
-	switch(alpha_mode){
-	case AB_USER_DEFINE:
-		break;
- 	case AB_CLEAR:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_ZERO;		
-		break;
- 	case AB_SRC:
-		alpha_config.src_factor_mode=AA_ONE;
-		alpha_config.dst_factor_mode=AA_ZERO;
-		break;
- 	case AB_DST:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_ONE;
-		break;
- 	case AB_SRC_OVER:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_ONE;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
-		break;
- 	case AB_DST_OVER:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_ONE;
-		break;
- 	case AB_SRC_IN:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC;
-		alpha_config.dst_factor_mode=AA_ZERO;
-		break;
- 	case AB_DST_IN:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_SRC;
-		break;
- 	case AB_SRC_OUT:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_ZERO;		
-		break;
- 	case AB_DST_OUT:
-		alpha_config.src_factor_mode=AA_ZERO;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;	
-		break;
- 	case AB_SRC_ATOP:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
-		break;
- 	case AB_DST_ATOP:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_SRC;		
-		break;
- 	case XOR:
-		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_INVERSE;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;			
-		break;	
- 	case AB_SRC_OVER_GLOBAL:	
-		alpha_config.src_global_alpha_mode=AA_PER_PIX_GLOBAL;
-		alpha_config.src_color_mode=AA_SRC_NO_PRE_MUL;
-		alpha_config.src_factor_mode=AA_SRC_GLOBAL;
-		alpha_config.dst_factor_mode=AA_SRC_INVERSE;
-		break;
-	default:
-	    	pr_err("alpha mode error\n");
-      		break;		
-	}
-	if((ppixel_alpha == 1)&&(global_alpha == 1)){
-		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
-	}else if(ppixel_alpha == 1){
-		alpha_config.src_global_alpha_mode = AA_PER_PIX;
-	}else if(global_alpha == 1){
-		alpha_config.src_global_alpha_mode = AA_GLOBAL;
-	}else{
-		pr_err("alpha_en should be 0\n");
-	}
-	alpha_config.src_alpha_mode = AA_STRAIGHT;
-	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
-
-	switch(win_id){
-	case 0:
-		src_alpha_ctl = 0x60;
-		dst_alpha_ctl = 0x64;
-		break;
-	case 1:
-		src_alpha_ctl = 0xa0;
-		dst_alpha_ctl = 0xa4;
-		break;
-	case 2:
-		src_alpha_ctl = 0xdc;
-		dst_alpha_ctl = 0xec;
-		break;
-	case 3:
-		src_alpha_ctl = 0x12c;
-		dst_alpha_ctl = 0x13c;
-		break;
-	}
-	mask = m_WIN0_DST_FACTOR_M0;
-	val  = v_WIN0_DST_FACTOR_M0(alpha_config.dst_factor_mode);
-	lcdc_msk_reg(ctx, dst_alpha_ctl, mask, val);
-	mask = m_WIN0_SRC_ALPHA_EN | m_WIN0_SRC_COLOR_M0 |
-		m_WIN0_SRC_ALPHA_M0 | m_WIN0_SRC_BLEND_M0 |
-		m_WIN0_SRC_ALPHA_CAL_M0 | m_WIN0_SRC_FACTOR_M0|
-		m_WIN0_SRC_GLOBAL_ALPHA;
-	val = v_WIN0_SRC_ALPHA_EN(1) | 
-		v_WIN0_SRC_COLOR_M0(alpha_config.src_color_mode) |
-		v_WIN0_SRC_ALPHA_M0(alpha_config.src_alpha_mode) |
-		v_WIN0_SRC_BLEND_M0(alpha_config.src_global_alpha_mode) |
-		v_WIN0_SRC_ALPHA_CAL_M0(alpha_config.src_alpha_cal_m0) |
-		v_WIN0_SRC_FACTOR_M0(alpha_config.src_factor_mode) |
-		v_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
-	lcdc_msk_reg(ctx, src_alpha_ctl, mask, val);
-
-	return 0;
-}
-static int rk3288_win_0_1_reg_update(struct fimd_context *ctx,int win_id)
-{
-	struct fimd_win_data *win_data;
-	unsigned int mask, val, off;
-	struct rk_screen *screen = ctx->screen;
-	u8 fmt_cfg = 0;
-	u32 xpos, ypos;
-	off = win_id * 0x40;
-	win_data = &ctx->win_data[win_id];
-	switch(win_data->bpp){
-		case 32:
-			fmt_cfg = 0;
-			break;
-		case 24:
-			fmt_cfg = 1;
-			break;
-		case 16:
-			fmt_cfg = 2;
-			break;
-		default:
-			printk("not support format %d\n",win_data->bpp);
-			break;
-	}
-
-	xpos = win_data->offset_x + screen->mode.left_margin + screen->mode.hsync_len;
-	ypos = win_data->offset_y + screen->mode.upper_margin + screen->mode.vsync_len;
-	mask =  m_WIN0_EN | m_WIN0_DATA_FMT ;
-	val  =  v_WIN0_EN(1) | v_WIN0_DATA_FMT(fmt_cfg);
-	lcdc_msk_reg(ctx, WIN0_CTRL0+off, mask,val);	
-
-	val =	v_WIN0_VIR_STRIDE(win_data->fb_width);
-	lcdc_writel(ctx, WIN0_VIR+off, val);	
-	val =	v_WIN0_ACT_WIDTH(win_data->fb_width) |
-		v_WIN0_ACT_HEIGHT(win_data->fb_height);
-	lcdc_writel(ctx, WIN0_ACT_INFO+off, val); 
-
-	val =	v_WIN0_DSP_WIDTH(win_data->ovl_width) |
-		v_WIN0_DSP_HEIGHT(win_data->ovl_height);
-	lcdc_writel(ctx, WIN0_DSP_INFO+off, val); 
-
-	val =	v_WIN0_DSP_XST(xpos) |
-		v_WIN0_DSP_YST(ypos);
-	lcdc_writel(ctx, WIN0_DSP_ST+off, val); 
-	lcdc_writel(ctx, WIN0_YRGB_MST+off, win_data->dma_addr );
-
-	if(win_id == 1)
-		rk3288_lcdc_alpha_cfg(ctx,win_id);
-	lcdc_cfg_done(ctx);
-	return 0;
-}
-
-static int rk3288_lcdc_post_cfg(struct fimd_context *ctx)
-{
-	struct rk_screen *screen = ctx->screen;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	u16 h_total,v_total;
-	u16 post_hsd_en,post_vsd_en;
-	u16 post_dsp_hact_st,post_dsp_hact_end;	
-	u16 post_dsp_vact_st,post_dsp_vact_end;
-	u16 post_dsp_vact_st_f1,post_dsp_vact_end_f1;
-	u16 post_h_fac,post_v_fac;
-
-	h_total = screen->mode.hsync_len+screen->mode.left_margin +
-		  x_res + screen->mode.right_margin;
-	v_total = screen->mode.vsync_len+screen->mode.upper_margin +
-		  y_res + screen->mode.lower_margin;
-
-	if(screen->post_dsp_stx + screen->post_xsize > x_res){		
-		printk(KERN_ERR"post:stx[%d] + xsize[%d] > x_res[%d]\n",
-			screen->post_dsp_stx,screen->post_xsize,x_res);
-		screen->post_dsp_stx = x_res - screen->post_xsize;
-	}
-	if(screen->x_mirror == 0){
-		post_dsp_hact_st=screen->post_dsp_stx + 
-			screen->mode.hsync_len+screen->mode.left_margin;
-		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
-	}else{
-		post_dsp_hact_end = h_total - screen->mode.right_margin -
-					screen->post_dsp_stx;
-		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
-	}	
-	if((screen->post_xsize < x_res)&&(screen->post_xsize != 0)){
-		post_hsd_en = 1;
-		post_h_fac = 
-			GET_SCALE_FACTOR_BILI_DN(x_res , screen->post_xsize); 
-	}else{
-		post_hsd_en = 0;
-		post_h_fac = 0x1000;
-	}
-
-
-	if(screen->post_dsp_sty + screen->post_ysize > y_res){
-		printk(KERN_ERR "post:sty[%d] + ysize[%d] > y_res[%d]\n",
-			screen->post_dsp_sty,screen->post_ysize,y_res);
-		screen->post_dsp_sty = y_res - screen->post_ysize;	
-	}
-	
-	if(screen->y_mirror == 0){
-		post_dsp_vact_st = screen->post_dsp_sty + 
-			screen->mode.vsync_len+screen->mode.upper_margin;
-		post_dsp_vact_end = post_dsp_vact_st + screen->post_ysize;
-	}else{
-		post_dsp_vact_end = v_total - screen->mode.lower_margin -
-					- screen->post_dsp_sty;
-		post_dsp_hact_st = post_dsp_vact_end - screen->post_ysize;
-	}
-	if((screen->post_ysize < y_res)&&(screen->post_ysize != 0)){
-		post_vsd_en = 1;
-		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res, screen->post_ysize);		
-	}else{
-		post_vsd_en = 0;
-		post_v_fac = 0x1000;
-	}
-
-	if(screen->interlace == 1){
-		post_dsp_vact_st_f1  = v_total + post_dsp_vact_st;
-		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 + screen->post_ysize;
-	}else{
-		post_dsp_vact_st_f1  = 0;
-		post_dsp_vact_end_f1 = 0;
-	}
-	printk(KERN_ERR"post:xsize=%d,ysize=%d,xpos=%d,ypos=%d,"
-	      "hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
-		screen->post_xsize,screen->post_ysize,screen->xpos,screen->ypos,
-		post_hsd_en,post_h_fac,post_vsd_en,post_v_fac);
-	mask = m_DSP_HACT_END_POST | m_DSP_HACT_ST_POST;
-	val = v_DSP_HACT_END_POST(post_dsp_hact_end) | 
-	      v_DSP_HACT_ST_POST(post_dsp_hact_st);
-	lcdc_msk_reg(ctx, POST_DSP_HACT_INFO, mask, val);
-
-	mask = m_DSP_VACT_END_POST | m_DSP_VACT_ST_POST;
-	val = v_DSP_VACT_END_POST(post_dsp_vact_end) | 
-	      v_DSP_VACT_ST_POST(post_dsp_vact_st);
-	lcdc_msk_reg(ctx, POST_DSP_VACT_INFO, mask, val);
-
-	mask = m_POST_HS_FACTOR_YRGB | m_POST_VS_FACTOR_YRGB;
-	val = v_POST_HS_FACTOR_YRGB(post_h_fac) |
-		v_POST_VS_FACTOR_YRGB(post_v_fac);
-	lcdc_msk_reg(ctx, POST_SCL_FACTOR_YRGB, mask, val);
-
-	mask = m_DSP_VACT_END_POST_F1 | m_DSP_VACT_ST_POST_F1;
-	val = v_DSP_VACT_END_POST_F1(post_dsp_vact_end_f1) |
-		v_DSP_VACT_ST_POST_F1(post_dsp_vact_st_f1);
-	lcdc_msk_reg(ctx, POST_DSP_VACT_INFO_F1, mask, val);
-
-	mask = m_POST_HOR_SD_EN | m_POST_VER_SD_EN;
-	val = v_POST_HOR_SD_EN(post_hsd_en) | v_POST_VER_SD_EN(post_vsd_en);
-	lcdc_msk_reg(ctx, POST_SCL_CTRL, mask, val);
-	return 0;
-}
-static void fimd_commit(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct rockchip_drm_panel_info *panel = ctx->panel;
-	struct rk_screen *screen = ctx->screen;
-	u16 hsync_len = screen->mode.hsync_len;
-	u16 left_margin = screen->mode.left_margin;
-	u16 right_margin = screen->mode.right_margin;
-	u16 vsync_len = screen->mode.vsync_len;
-	u16 upper_margin = screen->mode.upper_margin;
-	u16 lower_margin = screen->mode.lower_margin;
-	u16 x_res = screen->mode.xres;
-	u16 y_res = screen->mode.yres;
-	u32 mask, val;
-	int face;
-	u32 v=0;
-	u16 h_total,v_total;
-	h_total = hsync_len + left_margin  + x_res + right_margin;
-	v_total = vsync_len + upper_margin + y_res + lower_margin;
-	screen->post_dsp_stx=0;
-	screen->post_dsp_sty=0;
-	screen->post_xsize =x_res;
-	screen->post_ysize = y_res;
-
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if (ctx->suspended)
-		return;
-
-	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if(!ctx->clkon)
-		return;
-#if 1
-	switch (screen->face) {
-		case OUT_P565:
-			face = OUT_P565;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P666:
-			face = OUT_P666;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P565:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			break;
-		case OUT_D888_P666:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
-				m_DITHER_DOWN_SEL;
-			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
-				v_DITHER_DOWN_SEL(1);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			break;
-		case OUT_P888:
-			face = OUT_P888;
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			break;
-		default:
-			printk("un supported interface!\n");
-			break;
-	}
-	switch(screen->type){
-		case SCREEN_RGB:
-		case SCREEN_LVDS:
-		case SCREEN_DUAL_LVDS:			
-			mask = m_RGB_OUT_EN;
-			val = v_RGB_OUT_EN(1);
-			v = 1 << (3+16);
-			v |= (ctx->lcdc_id << 3);
-			break;
-		case SCREEN_HDMI:
-			mask = m_HDMI_OUT_EN;
-			val = v_HDMI_OUT_EN(1);
-			/*v = 1 << (4+16);
-			  v |= (ctx->id << 4);*/	
-			break;
-		case SCREEN_MIPI:
-			mask = m_MIPI_OUT_EN;
-			val = v_MIPI_OUT_EN(1);
-			/*v = (1 << (6+16))||(1 << (9+16));
-			  v |= (ctx->id << 6);
-			  v |= (ctx->id << 9);*/		
-			break;
-		case SCREEN_DUAL_MIPI:
-			mask = m_MIPI_OUT_EN | m_DOUB_CHANNEL_EN;
-			val = v_MIPI_OUT_EN(1) | v_DOUB_CHANNEL_EN(1);
-			/*v = (1 << (6+16))||(1 << (9+16));
-			  v |= (ctx->id << 6);
-			  v |= (ctx->id << 9);*/	
-			break;
-		case SCREEN_EDP:
-			face = OUT_RGB_AAA;  /*RGB AAA output*/
-			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
-			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
-			lcdc_msk_reg(ctx, DSP_CTRL1, mask, val);
-			mask = m_EDP_OUT_EN;
-			val = v_EDP_OUT_EN(1);
-			/*v = 1 << (5+16);
-			  v |= (ctx->id << 5);*/		
-			break;
-	}
-	lcdc_msk_reg(ctx, SYS_CTRL, mask, val);
-#ifdef USE_ION_MMU
-	mask = m_MMU_EN;
-	val = v_MMU_EN(1);
-	lcdc_msk_reg(ctx, SYS_CTRL, mask, val);
-	mask = m_AXI_MAX_OUTSTANDING_EN | m_AXI_OUTSTANDING_MAX_NUM;
-	val = v_AXI_OUTSTANDING_MAX_NUM(31) | v_AXI_MAX_OUTSTANDING_EN(1);
-	lcdc_msk_reg(ctx, SYS_CTRL1, mask, val);		
-#endif	
-	writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
-	mask = m_DSP_OUT_MODE | m_DSP_HSYNC_POL | m_DSP_VSYNC_POL |
-		m_DSP_DEN_POL | m_DSP_DCLK_POL | m_DSP_BG_SWAP | 
-		m_DSP_RB_SWAP | m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
-		m_DSP_DUMMY_SWAP | m_DSP_OUT_ZERO | m_DSP_BLANK_EN | 
-		m_DSP_BLACK_EN | m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN;
-	val = v_DSP_OUT_MODE(face) | v_DSP_HSYNC_POL(screen->pin_hsync) |
-		v_DSP_VSYNC_POL(screen->pin_vsync) | 
-		v_DSP_DEN_POL(screen->pin_den) | v_DSP_DCLK_POL(screen->pin_dclk) |
-		v_DSP_BG_SWAP(screen->swap_gb) | v_DSP_RB_SWAP(screen->swap_rb) | 
-		v_DSP_RG_SWAP(screen->swap_rg) | 
-		v_DSP_DELTA_SWAP(screen->swap_delta) |
-		v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_DSP_OUT_ZERO(0) | 
-		v_DSP_BLANK_EN(0) | v_DSP_BLACK_EN(0) |
-		v_DSP_X_MIR_EN(screen->x_mirror) | v_DSP_Y_MIR_EN(screen->y_mirror);
-	lcdc_msk_reg(ctx, DSP_CTRL0, mask, val);
-
-	mask = m_DSP_BG_BLUE | m_DSP_BG_GREEN | m_DSP_BG_RED;
-	val  = v_DSP_BG_BLUE(0x3ff) | v_DSP_BG_GREEN(0) | v_DSP_BG_RED(0);
-	lcdc_msk_reg(ctx, DSP_BG, mask, val);
-
-	mask = m_DSP_HS_PW | m_DSP_HTOTAL;
-	val = v_DSP_HS_PW(hsync_len) | v_DSP_HTOTAL(h_total);
-	lcdc_msk_reg(ctx, DSP_HTOTAL_HS_END, mask, val);
-
-	mask = m_DSP_HACT_END | m_DSP_HACT_ST;
-	val = v_DSP_HACT_END(hsync_len + left_margin + x_res) |
-		v_DSP_HACT_ST(hsync_len + left_margin);
-	lcdc_msk_reg(ctx, DSP_HACT_ST_END, mask, val);
-
-	mask = m_DSP_VS_PW | m_DSP_VTOTAL;
-	val = v_DSP_VS_PW(vsync_len) | v_DSP_VTOTAL(v_total);
-	lcdc_msk_reg(ctx, DSP_VTOTAL_VS_END, mask, val);
-
-	mask = m_DSP_VACT_END | m_DSP_VACT_ST;
-	val = v_DSP_VACT_END(vsync_len + upper_margin + y_res) |
-		v_DSP_VACT_ST(vsync_len + upper_margin);
-	lcdc_msk_reg(ctx, DSP_VACT_ST_END, mask, val);
-
-	rk3288_lcdc_post_cfg(ctx);
-#endif
-}
-
-static int fimd_enable_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	u32 val,mask;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (ctx->suspended)
-		return -EPERM;
-
-	if (!test_and_set_bit(0, &ctx->irq_flags)) {
-		mask = m_FS_INTR_CLR | m_FS_INTR_EN | m_LINE_FLAG_INTR_CLR |
-		    m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_CLR | 
-		    m_BUS_ERROR_INTR_EN | m_DSP_LINE_FLAG_NUM;
-		val = v_FS_INTR_CLR(1) | v_FS_INTR_EN(1) | v_LINE_FLAG_INTR_CLR(0) |
-		    v_LINE_FLAG_INTR_EN(0) | v_BUS_ERROR_INTR_CLR(0) | v_BUS_ERROR_INTR_EN(0) ;
-		lcdc_msk_reg(ctx, INTR_CTRL0, mask, val);
-		lcdc_cfg_done(ctx);
-	}
-
-	return 0;
-}
-
-static void fimd_disable_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	u32 val,mask;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (ctx->suspended)
-		return;
-
-	if (test_and_clear_bit(0, &ctx->irq_flags)) {
-		mask = m_DSP_HOLD_VALID_INTR_EN | m_FS_INTR_EN |
-			m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_EN;
-		val = v_DSP_HOLD_VALID_INTR_EN(0) | v_FS_INTR_EN(0) |
-			v_LINE_FLAG_INTR_EN(0) | v_BUS_ERROR_INTR_EN(0);
-		lcdc_msk_reg(ctx, INTR_CTRL0, mask, val);
-
-		mask = m_DSP_HOLD_VALID_INTR_CLR | m_FS_INTR_CLR |
-			m_LINE_FLAG_INTR_CLR | m_LINE_FLAG_INTR_CLR;
-		val = v_DSP_HOLD_VALID_INTR_CLR(0) | v_FS_INTR_CLR(0) |
-			v_LINE_FLAG_INTR_CLR(0) | v_BUS_ERROR_INTR_CLR(0);
-		lcdc_msk_reg(ctx, INTR_CTRL0, mask, val);
-
-		mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
-			m_WIN2_EMPTY_INTR_EN | m_WIN3_EMPTY_INTR_EN |
-			m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
-			m_POST_BUF_EMPTY_INTR_EN;
-		val = v_WIN0_EMPTY_INTR_EN(0) | v_WIN1_EMPTY_INTR_EN(0) |
-			v_WIN2_EMPTY_INTR_EN(0) | v_WIN3_EMPTY_INTR_EN(0) |
-			v_HWC_EMPTY_INTR_EN(0) | v_POST_BUF_EMPTY_INTR_EN(0) |
-			v_PWM_GEN_INTR_EN(0);
-		lcdc_msk_reg(ctx, INTR_CTRL1, mask, val);
-
-		mask = m_WIN0_EMPTY_INTR_CLR | m_WIN1_EMPTY_INTR_CLR |
-			m_WIN2_EMPTY_INTR_CLR | m_WIN3_EMPTY_INTR_CLR |
-			m_HWC_EMPTY_INTR_CLR | m_POST_BUF_EMPTY_INTR_CLR |
-			m_POST_BUF_EMPTY_INTR_CLR;
-		val = v_WIN0_EMPTY_INTR_CLR(0) | v_WIN1_EMPTY_INTR_CLR(0) |
-			v_WIN2_EMPTY_INTR_CLR(0) | v_WIN3_EMPTY_INTR_CLR(0) |
-			v_HWC_EMPTY_INTR_CLR(0) | v_POST_BUF_EMPTY_INTR_CLR(0) |
-			v_PWM_GEN_INTR_CLR(0);
-		lcdc_msk_reg(ctx, INTR_CTRL1, mask, val);		
-		lcdc_cfg_done(ctx);
-
-
-	}
-}
-
-static void fimd_wait_for_vblank(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	if (ctx->suspended)
-		return;
-
-	atomic_set(&ctx->wait_vsync_event, 1);
-
-	/*
-	 * wait for FIMD to signal VSYNC interrupt or return after
-	 * timeout which is set to 50ms (refresh rate of 20).
-	 */
-	if (!wait_event_timeout(ctx->wait_vsync_queue,
-				!atomic_read(&ctx->wait_vsync_event),
-				DRM_HZ/20))
-		DRM_DEBUG_KMS("vblank wait timed out.\n");
-}
-
-static struct rockchip_drm_manager_ops fimd_manager_ops = {
-	.dpms = fimd_dpms,
-	.apply = fimd_apply,
-	.commit = fimd_commit,
-	.enable_vblank = fimd_enable_vblank,
-	.disable_vblank = fimd_disable_vblank,
-	.wait_for_vblank = fimd_wait_for_vblank,
-};
-
-static void fimd_win_mode_set(struct device *dev,
-			      struct rockchip_drm_overlay *overlay)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int win;
-	unsigned long offset;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (!overlay) {
-		dev_err(dev, "overlay is NULL\n");
-		return;
-	}
-
-	win = overlay->zpos;
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	offset = overlay->fb_x * (overlay->bpp >> 3);
-	offset += overlay->fb_y * overlay->pitch;
-
-	DRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);
-
-	win_data = &ctx->win_data[win];
-
-	win_data->offset_x = overlay->crtc_x;
-	win_data->offset_y = overlay->crtc_y;
-	win_data->ovl_width = overlay->crtc_width;
-	win_data->ovl_height = overlay->crtc_height;
-	win_data->fb_width = overlay->fb_width;
-	win_data->fb_height = overlay->fb_height;
-	win_data->dma_addr = overlay->dma_addr[0] + offset;
-	win_data->bpp = overlay->bpp;
-	win_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *
-				(overlay->bpp >> 3);
-	win_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);
-
-	DRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",
-			win_data->offset_x, win_data->offset_y);
-	DRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",
-			win_data->ovl_width, win_data->ovl_height);
-	DRM_DEBUG_KMS("paddr = 0x%lx\n", (unsigned long)win_data->dma_addr);
-	DRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",
-			overlay->fb_width, overlay->crtc_width);
-}
-
-static void fimd_win_set_pixfmt(struct device *dev, unsigned int win)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data = &ctx->win_data[win];
-	u8 fmt_cfg = 0;
-
-#if 0
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-	switch(win_data->bpp){
-		case 32:
-			fmt_cfg = 0;
-			break;
-		case 24:
-			fmt_cfg = 1;
-			break;
-		case 16:
-			fmt_cfg = 2;
-			break;
-		default:
-			printk("not support format %d\n",win_data->bpp);
-			break;
-	}
-
-
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-	lcdc_msk_reg(ctx , SYS_CTRL, m_WIN0_FORMAT, v_WIN0_FORMAT(fmt_cfg));
-	printk(KERN_ERR"------>yzq %d  SYS_CTRL=%x \n",__LINE__,lcdc_readl(ctx,SYS_CTRL));
-#endif
-}
-
-static void fimd_win_set_colkey(struct device *dev, unsigned int win)
-{
-//	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-}
-
-static void fimd_win_commit(struct device *dev, int zpos)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	struct rk_screen *screen = ctx->screen;
-	int win = zpos;
-	unsigned long val,  size;
-	u32 xpos, ypos;
-
-//	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-
-	if (ctx->suspended)
-		return;
-
-	if (!ctx->clkon)
-		return;
-//	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	win_data = &ctx->win_data[win];
-	switch(win){
-		case 0:
-			rk3288_win_0_1_reg_update(ctx,0);
-			break;
-		case 1:
-//	printk(KERN_ERR"-->yzq dma_addr=%x buf_offsize=%x win_data->fb_width=%d \nwin_data->fb_height=%d win_data->ovl_height=%d  win_data->ovl_width=%d \n win_data->offset_x=%d win_data->offset_y=%d win_data->line_size=%d\n win_data->bpp=%d ",win_data->dma_addr,win_data->buf_offsize,win_data->fb_width,win_data->fb_height,win_data->ovl_height, win_data->ovl_width,win_data->offset_x,win_data->offset_y,win_data->line_size,win_data->bpp);
-			rk3288_win_0_1_reg_update(ctx,1);
-			break;
-		case 2:
-			printk("----->yzq not support now win_id=%d\n",win);
-		//	rk3288_win_2_3_reg_update(ctx,2);
-			break;
-		case 3:
-			printk("----->yzq not support now win_id=%d\n",win);
-		//	rk3288_win_2_3_reg_update(ctx,3);
-			break;
-		default:
-			printk("----->yzq not support now win_id=%d\n",win);
-			break;
-	}
-//	printk("----->yzq now win_id=%d\n",win);
-
-	//rk3288_lcdc_post_cfg(screen);
-	win_data->enabled = true;
-
-}
-
-static void fimd_win_disable(struct device *dev, int zpos)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int win = zpos;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	if (win == DEFAULT_ZPOS)
-		win = ctx->default_win;
-
-	if (win < 0 || win > WINDOWS_NR)
-		return;
-
-	win_data = &ctx->win_data[win];
-
-	if (ctx->suspended) {
-		/* do not resume this window*/
-		win_data->resume = false;
-		return;
-	}
-
-	win_data->enabled = false;
-}
-
-static struct rockchip_drm_overlay_ops fimd_overlay_ops = {
-	.mode_set = fimd_win_mode_set,
-	.commit = fimd_win_commit,
-	.disable = fimd_win_disable,
-};
-
-static struct rockchip_drm_manager fimd_manager = {
-	.pipe		= -1,
-	.ops		= &fimd_manager_ops,
-	.overlay_ops	= &fimd_overlay_ops,
-	.display_ops	= &fimd_display_ops,
-};
-
-static irqreturn_t fimd_irq_handler(int irq, void *dev_id)
-{
-	struct fimd_context *ctx = (struct fimd_context *)dev_id;
-	struct rockchip_drm_subdrv *subdrv = &ctx->subdrv;
-	struct drm_device *drm_dev = subdrv->drm_dev;
-	struct rockchip_drm_manager *manager = subdrv->manager;
-	u32 intr0_reg;
-
-	intr0_reg = lcdc_readl(ctx, INTR_CTRL0);
-
-	if(intr0_reg & m_FS_INTR_STS){
-		lcdc_msk_reg(ctx, INTR_CTRL0, m_FS_INTR_CLR,
-			     v_FS_INTR_CLR(1));
-
-	}
-
-	/* check the crtc is detached already from encoder */
-	if (manager->pipe < 0)
-		goto out;
-
-	drm_handle_vblank(drm_dev, manager->pipe);
-	rockchip_drm_crtc_finish_pageflip(drm_dev, manager->pipe);
-
-	/* set wait vsync event to zero and wake up queue. */
-	if (atomic_read(&ctx->wait_vsync_event)) {
-		atomic_set(&ctx->wait_vsync_event, 0);
-		DRM_WAKEUP(&ctx->wait_vsync_queue);
-	}
-out:
-	return IRQ_HANDLED;
-}
-
-static int fimd_subdrv_probe(struct drm_device *drm_dev, struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/*
-	 * enable drm irq mode.
-	 * - with irq_enabled = 1, we can use the vblank feature.
-	 *
-	 * P.S. note that we wouldn't use drm irq handler but
-	 *	just specific driver own one instead because
-	 *	drm framework supports only one irq handler.
-	 */
-	drm_dev->irq_enabled = 1;
-
-	/*
-	 * with vblank_disable_allowed = 1, vblank interrupt will be disabled
-	 * by drm timer once a current process gives up ownership of
-	 * vblank event.(after drm_vblank_put function is called)
-	 */
-	drm_dev->vblank_disable_allowed = 1;
-
-	/* attach this sub driver to iommu mapping if supported. */
-	if (is_drm_iommu_supported(drm_dev))
-		drm_iommu_attach_device(drm_dev, dev);
-
-	return 0;
-}
-
-static void fimd_subdrv_remove(struct drm_device *drm_dev, struct device *dev)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	/* detach this sub driver from iommu mapping if supported. */
-	if (is_drm_iommu_supported(drm_dev))
-		drm_iommu_detach_device(drm_dev, dev);
-}
-
-
-static void fimd_clear_win(struct fimd_context *ctx, int win)
-{
-	u32 val;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-}
-
-static int fimd_clock(struct fimd_context *ctx, bool enable)
-{
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-printk(KERN_ERR"---->yzq %s %d \n",__func__,__LINE__);
-	if (enable) {
-		if(ctx->clkon)
-			return 0;
-		int ret;
-
-		ret = clk_prepare_enable(ctx->hclk);
-		if (ret < 0)
-			return ret;
-
-		ret = clk_prepare_enable(ctx->dclk);
-		if (ret < 0)
-			return ret;
-		
-		ret = clk_prepare_enable(ctx->aclk);
-		if (ret < 0)
-			return ret;
-		ctx->clkon=1;
-	} else {
-		if(!ctx->clkon)
-			return 0;
-		clk_disable_unprepare(ctx->aclk);
-		clk_disable_unprepare(ctx->dclk);
-		clk_disable_unprepare(ctx->hclk);
-		ctx->clkon=0;
-	}
-
-	return 0;
-}
-
-static void fimd_window_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int i;
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		win_data->resume = win_data->enabled;
-		fimd_win_disable(dev, i);
-	}
-	fimd_wait_for_vblank(dev);
-}
-
-static void fimd_window_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-	struct fimd_win_data *win_data;
-	int i;
-
-	for (i = 0; i < WINDOWS_NR; i++) {
-		win_data = &ctx->win_data[i];
-		win_data->enabled = win_data->resume;
-		win_data->resume = false;
-	}
-}
-
-static int fimd_activate(struct fimd_context *ctx, bool enable)
-{
-	struct device *dev = ctx->subdrv.dev;
-	if (enable) {
-		int ret;
-
-		ret = fimd_clock(ctx, true);
-		if (ret < 0)
-			return ret;
-
-		ctx->suspended = false;
-
-		/* if vblank was enabled status, enable it again. */
-		if (test_and_clear_bit(0, &ctx->irq_flags))
-			fimd_enable_vblank(dev);
-
-		fimd_window_resume(dev);
-	} else {
-		fimd_window_suspend(dev);
-
-		fimd_clock(ctx, false);
-		ctx->suspended = true;
-	}
-
-	return 0;
-}
-
-int rk_fb_video_mode_from_timing(const struct display_timing *dt, 
-				struct rk_screen *screen)
-{
-	screen->mode.pixclock = dt->pixelclock.typ;
-	screen->mode.left_margin = dt->hback_porch.typ;
-	screen->mode.right_margin = dt->hfront_porch.typ;
-	screen->mode.xres = dt->hactive.typ;
-	screen->mode.hsync_len = dt->hsync_len.typ;
-	screen->mode.upper_margin = dt->vback_porch.typ;
-	screen->mode.lower_margin = dt->vfront_porch.typ;
-	screen->mode.yres = dt->vactive.typ;
-	screen->mode.vsync_len = dt->vsync_len.typ;
-	screen->type = SCREEN_LVDS;
-	screen->lvds_format = LVDS_8BIT_2;
-	screen->face = OUT_D888_P666;
-
-	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
-		screen->pin_dclk = 1;
-	else
-		screen->pin_dclk = 0;
-	if(dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-	if(dt->flags & DISPLAY_FLAGS_DE_HIGH)
-		screen->pin_den = 1;
-	else
-		screen->pin_den = 0;
-	
-	return 0;
-	
-}
-
-int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
-{
-	struct display_timings *disp_timing;
-	struct display_timing *dt;
-	disp_timing = of_get_display_timings(np);
-	if (!disp_timing) {
-		pr_err("parse display timing err\n");
-		return -EINVAL;
-	}
-	dt = display_timings_get(disp_timing, 0);
-	rk_fb_video_mode_from_timing(dt, screen);
-	printk(KERN_ERR "dclk:%d\n"
-			 "hactive:%d\n"
-			 "hback_porch:%d\n"
-			 "hfront_porch:%d\n"
-			 "hsync_len:%d\n"
-			 "vactive:%d\n"
-			 "vback_porch:%d\n"
-			 "vfront_porch:%d\n"
-			 "vsync_len:%d\n"
-			 "screen_type:%d\n"
-			 "lvds_format:%d\n"
-			 "face:%d\n",
-			dt->pixelclock.typ,
-			dt->hactive.typ,
-			dt->hback_porch.typ,
-			dt->hfront_porch.typ,
-			dt->hsync_len.typ,
-			dt->vactive.typ,
-			dt->vback_porch.typ,
-			dt->vfront_porch.typ,
-			dt->vsync_len.typ,
-			dt->screen_type,
-			dt->lvds_format,
-			dt->face);
-	return 0;
-
-}
-
-static int fimd_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fimd_context *ctx;
-	struct rockchip_drm_subdrv *subdrv;
-	struct rockchip_drm_fimd_pdata *pdata;
-	struct rockchip_drm_panel_info *panel;
-	struct device_node *np = pdev->dev.of_node;
-	struct rk_screen *screen;
-	int prop;
-	int reg_len;
-	struct resource *res;
-	int win;
-	int val;
-	int ret = -EINVAL;
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-	of_property_read_u32(np, "rockchip,prop", &prop);
-	if (prop == EXTEND) {
-		printk("---->%s not support lcdc EXTEND now\n",__func__);
-			return 0;
-	}
-	if (of_property_read_u32(np, "rockchip,pwr18", &val))
-	{
-		printk("----->%s default set it as 3.xv power supply",__func__);
-	}
-	else{
-		if(val){
-			printk("----->%s lcdc pwr is 1.8, not supply now",__func__);
-		}else{
-			printk("----->%s lcdc pwr is 3.3v",__func__);
-		}
-	}
-
-	if (dev->of_node) {
-		panel = devm_kzalloc(dev, sizeof(struct rockchip_drm_panel_info), GFP_KERNEL);
-		screen = devm_kzalloc(dev, sizeof(struct rk_screen), GFP_KERNEL);
-		rk_fb_get_prmry_screen(screen);
-		memcpy(&panel->timing,&screen->mode,sizeof(struct fb_videomode)); 
-	} else {
-		DRM_ERROR("no platform data specified\n");
-		return -EINVAL;
-	}
-
-	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
-	if (!ctx)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	ctx->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(ctx->regs))
-		return PTR_ERR(ctx->regs);
-	reg_len = resource_size(res);
-	ctx->regsbak = devm_kzalloc(dev,reg_len,GFP_KERNEL);
-	ctx->lcdc_id = rk3288_lcdc_get_id(res->start);	
-	ctx->screen = screen;
-	ctx->hclk = devm_clk_get(dev, "hclk_lcdc");
-	ctx->aclk = devm_clk_get(dev, "aclk_lcdc");
-	ctx->dclk = devm_clk_get(dev, "dclk_lcdc");
-
-	ctx->irq = platform_get_irq(pdev, 0);
-	if (ctx->irq < 0) {
-		dev_err(dev, "cannot find IRQ for lcdc%d\n",
-			ctx->lcdc_id);
-		return -ENXIO;
-	}
-	ret = devm_request_irq(dev, ctx->irq, fimd_irq_handler,
-							0, "drm_fimd", ctx);
-	if (ret) {
-		dev_err(dev, "irq request failed.\n");
-		return ret;
-	}
-
-	ctx->default_win = 0;// pdata->default_win;
-	ctx->panel = panel;
-	DRM_INIT_WAITQUEUE(&ctx->wait_vsync_queue);
-	atomic_set(&ctx->wait_vsync_event, 0);
-
-	subdrv = &ctx->subdrv;
-
-	subdrv->dev = dev;
-	subdrv->manager = &fimd_manager;
-	subdrv->probe = fimd_subdrv_probe;
-	subdrv->remove = fimd_subdrv_remove;
-
-	mutex_init(&ctx->lock);
-
-	platform_set_drvdata(pdev, ctx);
-
-	pm_runtime_enable(dev);
-	pm_runtime_get_sync(dev);
-	
-	ret = clk_set_rate(ctx->dclk, ctx->screen->mode.pixclock);
-	if (ret)
-		printk( "set lcdc%d dclk failed\n", ctx->lcdc_id);
-	
-	fimd_activate(ctx, true);
-
-	if(trsm_lvds_ops != NULL){
-		printk(KERN_ERR"------>yzq enable lvds\n");	
-		trsm_lvds_ops->enable();
-	}
-	memcpy(ctx->regsbak,ctx->regs,reg_len);
-	rockchip_drm_subdrv_register(subdrv);
-
-	return 0;
-}
-
-static int fimd_remove(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fimd_context *ctx = platform_get_drvdata(pdev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	rockchip_drm_subdrv_unregister(&ctx->subdrv);
-
-	if (ctx->suspended)
-		goto out;
-
-	pm_runtime_set_suspended(dev);
-	pm_runtime_put_sync(dev);
-
-out:
-	pm_runtime_disable(dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int fimd_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	/*
-	 * do not use pm_runtime_suspend(). if pm_runtime_suspend() is
-	 * called here, an error would be returned by that interface
-	 * because the usage_count of pm runtime is more than 1.
-	 */
-	if (!pm_runtime_suspended(dev))
-		return fimd_activate(ctx, false);
-
-	return 0;
-}
-
-static int fimd_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	/*
-	 * if entered to sleep when lcd panel was on, the usage_count
-	 * of pm runtime would still be 1 so in this case, fimd driver
-	 * should be on directly not drawing on pm runtime interface.
-	 */
-	if (!pm_runtime_suspended(dev)) {
-		int ret;
-
-		ret = fimd_activate(ctx, true);
-		if (ret < 0)
-			return ret;
-
-		/*
-		 * in case of dpms on(standby), fimd_apply function will
-		 * be called by encoder's dpms callback to update fimd's
-		 * registers but in case of sleep wakeup, it's not.
-		 * so fimd_apply function should be called at here.
-		 */
-		fimd_apply(dev);
-	}
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
-static int fimd_runtime_suspend(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return fimd_activate(ctx, false);
-}
-
-static int fimd_runtime_resume(struct device *dev)
-{
-	struct fimd_context *ctx = get_fimd_context(dev);
-
-	DRM_DEBUG_KMS("%s\n", __FILE__);
-
-	return fimd_activate(ctx, true);
-}
-#endif
-#if defined(CONFIG_OF)
-static const struct of_device_id rk3288_lcdc_dt_ids[] = {
-	{.compatible = "rockchip,rk3288-lcdc",},
-	{}
-};
-#endif
-
-static const struct dev_pm_ops fimd_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(fimd_suspend, fimd_resume)
-	SET_RUNTIME_PM_OPS(fimd_runtime_suspend, fimd_runtime_resume, NULL)
-};
-
-struct platform_driver fimd_driver = {
-	.probe		= fimd_probe,
-	.remove		= fimd_remove,
-	.id_table       = rk3288_lcdc_dt_ids,
-	.driver		= {
-		.name	= "rk3288-lcdc",
-		.owner	= THIS_MODULE,
-		.pm	= &fimd_pm_ops,
-		.of_match_table = of_match_ptr(rk3288_lcdc_dt_ids),
-	},
-};
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
index 581d99f1a4c2..0c7923491fe5 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
@@ -43,7 +43,6 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 	int ret;
 	int nr;
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	DRM_DEBUG_DRIVER("%s\n", __FILE__);
 
 	private = kzalloc(sizeof(struct rockchip_drm_private), GFP_KERNEL);
@@ -52,7 +51,6 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 		return -ENOMEM;
 	}
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	INIT_LIST_HEAD(&private->pageflip_event_list);
 	dev->dev_private = (void *)private;
 
@@ -62,14 +60,12 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 	 * also this iommu_mapping can be used to check if iommu is supported
 	 * or not.
 	 */
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	ret = drm_create_iommu_mapping(dev);
 	if (ret < 0) {
 		DRM_ERROR("failed to create iommu mapping.\n");
 		goto err_crtc;
 	}
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	drm_mode_config_init(dev);
 
 	/* init kms poll for handling hpd */
@@ -81,14 +77,12 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 	 * ROCKCHIP4 is enough to have two CRTCs and each crtc would be used
 	 * without dependency of hardware.
 	 */
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	for (nr = 0; nr < MAX_CRTC; nr++) {
 		ret = rockchip_drm_crtc_create(dev, nr);
 		if (ret)
 			goto err_release_iommu_mapping;
 	}
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	for (nr = 0; nr < MAX_PLANE; nr++) {
 		struct drm_plane *plane;
 		unsigned int possible_crtcs = (1 << MAX_CRTC) - 1;
@@ -98,7 +92,6 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 			goto err_release_iommu_mapping;
 	}
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	ret = drm_vblank_init(dev, MAX_CRTC);
 	if (ret)
 		goto err_release_iommu_mapping;
@@ -108,7 +101,6 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 	 * that were registered at probe() of platform driver
 	 * to the sub driver and create encoder and connector for them.
 	 */
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	ret = rockchip_drm_device_register(dev);
 	if (ret)
 		goto err_vblank;
@@ -116,12 +108,10 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 	/* setup possible_clones. */
 	rockchip_drm_encoder_setup(dev);
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	/*
 	 * create and configure fb helper and also rockchip specific
 	 * fbdev object.
 	 */
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	ret = rockchip_drm_fbdev_init(dev);
 	if (ret) {
 		DRM_ERROR("failed to initialize drm fbdev\n");
@@ -130,7 +120,6 @@ static int rockchip_drm_load(struct drm_device *dev, unsigned long flags)
 
 	drm_vblank_offdelay = VBLANK_OFF_DELAY;
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	return 0;
 
 err_drm_device:
@@ -168,7 +157,6 @@ static int rockchip_drm_open(struct drm_device *dev, struct drm_file *file)
 {
 	struct drm_rockchip_file_private *file_priv;
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	DRM_DEBUG_DRIVER("%s\n", __FILE__);
 
 	file_priv = kzalloc(sizeof(*file_priv), GFP_KERNEL);
@@ -286,7 +274,6 @@ static struct drm_driver rockchip_drm_driver = {
 static int rockchip_drm_platform_probe(struct platform_device *pdev)
 {
 	DRM_DEBUG_DRIVER("%s\n", __FILE__);
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	rockchip_drm_driver.num_ioctls = DRM_ARRAY_SIZE(rockchip_ioctls);
@@ -297,7 +284,6 @@ static int rockchip_drm_platform_probe(struct platform_device *pdev)
 static int rockchip_drm_platform_remove(struct platform_device *pdev)
 {
 	DRM_DEBUG_DRIVER("%s\n", __FILE__);
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 
 	drm_platform_exit(&rockchip_drm_driver, pdev);
 
@@ -319,24 +305,20 @@ static int __init rockchip_drm_init(void)
 
 	DRM_DEBUG_DRIVER("%s\n", __FILE__);
 
-#ifdef CONFIG_DRM_RK3288_FIMD
-	ret = platform_driver_register(&fimd_driver);
-	if (ret < 0)
-		goto out_fimd;
-#endif
-#ifdef CONFIG_DRM_RK3188_FIMD
-	ret = platform_driver_register(&fimd_driver);
+
+#ifdef CONFIG_DRM_RK_PRIMARY
+	ret = platform_driver_register(&primary_platform_driver);
 	if (ret < 0)
 		goto out_fimd;
+	platform_device_register_simple("primary-display", -1,
+			NULL, 0);
 #endif
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	ret = platform_driver_register(&rockchip_drm_platform_driver);
 	if (ret < 0)
 		goto out_drm;
 
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	rockchip_drm_pdev = platform_device_register_simple("rockchip-drm", -1,
 				NULL, 0);
 	if (IS_ERR(rockchip_drm_pdev)) {
@@ -344,18 +326,13 @@ static int __init rockchip_drm_init(void)
 		goto out;
 	}
 
-	printk(KERN_ERR"----->yzq %s %d\n",__func__,__LINE__);
 	return 0;
 
 out:
 	platform_driver_unregister(&rockchip_drm_platform_driver);
 out_drm:
-#ifdef CONFIG_DRM_RK3188_FIMD
-	platform_driver_unregister(&fimd_driver);
-out_fimd:
-#endif
-#ifdef CONFIG_DRM_RK3288_FIMD
-	platform_driver_unregister(&fimd_driver);
+#ifdef CONFIG_DRM_RK_PRIMARY
+	platform_driver_unregister(&primary_platform_driver);
 out_fimd:
 #endif
 	return ret;
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_drv.h b/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
index 2e60df5ebb01..d0d63cfe8410 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
@@ -337,7 +337,7 @@ int rockchip_platform_device_ipp_register(void);
  */
 void rockchip_platform_device_ipp_unregister(void);
 
-extern struct platform_driver fimd_driver;
+extern struct platform_driver primary_platform_driver;
 extern struct platform_driver hdmi_driver;
 extern struct platform_driver mixer_driver;
 extern struct platform_driver rockchip_drm_common_hdmi_driver;
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_primary.c b/drivers/gpu/drm/rockchip/rockchip_drm_primary.c
new file mode 100644
index 000000000000..3fa19ea35b06
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_primary.c
@@ -0,0 +1,659 @@
+/*
+ * rk3288_drm_fimd.c
+ *
+ * Copyright (C) ROCKCHIP, Inc.
+ * Author:yzq<yzq@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <drm/drmP.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+
+#include <video/of_display_timing.h>
+#include <drm/rockchip_drm.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rk_fb.h>
+#include <video/display_timing.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include "rockchip_drm_drv.h"
+#include "rockchip_drm_fbdev.h"
+#include "rockchip_drm_crtc.h"
+#include "rockchip_drm_iommu.h"
+#include "rockchip_drm_primary.h"
+static struct device *g_dev = NULL;
+
+static bool primary_display_is_connected(struct device *dev)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/* TODO. */
+
+	return true;
+}
+
+static void *primary_get_panel(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	return ctx->panel;
+}
+
+static int primary_check_timing(struct device *dev, void *timing)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/* TODO. */
+
+	return 0;
+}
+
+static int primary_display_power_on(struct device *dev, int mode)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/* TODO */
+
+	return 0;
+}
+
+static struct rockchip_drm_display_ops primary_display_ops = {
+	.type = ROCKCHIP_DISPLAY_TYPE_LCD,
+	.is_connected = primary_display_is_connected,
+	.get_panel = primary_get_panel,
+	.check_timing = primary_check_timing,
+	.power_on = primary_display_power_on,
+};
+
+static void primary_dpms(struct device *subdrv_dev, int mode)
+{
+	struct primary_context *ctx = get_primary_context(subdrv_dev);
+
+	DRM_DEBUG_KMS("%s, %d\n", __FILE__, mode);
+
+	mutex_lock(&ctx->lock);
+
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		/*
+		 * enable primary hardware only if suspended status.
+		 *
+		 * P.S. primary_dpms function would be called at booting time so
+		 * clk_enable could be called double time.
+		 */
+
+		if (ctx->suspended)
+			pm_runtime_get_sync(subdrv_dev);
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	case DRM_MODE_DPMS_OFF:
+		if (!ctx->suspended)
+			pm_runtime_put_sync(subdrv_dev);
+		break;
+	default:
+		DRM_DEBUG_KMS("unspecified mode %d\n", mode);
+		break;
+	}
+
+	mutex_unlock(&ctx->lock);
+}
+
+static void primary_apply(struct device *subdrv_dev)
+{
+	struct primary_context *ctx = get_primary_context(subdrv_dev);
+	struct rockchip_drm_manager *mgr = ctx->subdrv.manager;
+	struct rockchip_drm_manager_ops *mgr_ops = mgr->ops;
+	struct rockchip_drm_overlay_ops *ovl_ops = mgr->overlay_ops;
+	struct primary_win_data *win_data;
+	int i;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	for (i = 0; i < WINDOWS_NR; i++) {
+		win_data = &ctx->win_data[i];
+		if (win_data->enabled && (ovl_ops && ovl_ops->commit))
+			ovl_ops->commit(subdrv_dev, i);
+	}
+
+	if (mgr_ops && mgr_ops->commit)
+		mgr_ops->commit(subdrv_dev);
+}
+
+static void primary_commit(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct rk_drm_display *drm_disp = ctx->drm_disp;
+
+	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
+	if (ctx->suspended)
+		return;
+
+	drm_disp->mode_id = drm_disp->best_mode;
+	drm_disp->enable = true;
+	rk_drm_disp_handle(drm_disp,0,RK_DRM_SCREEN_SET);
+}
+
+static int primary_enable_vblank(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (ctx->suspended)
+		return -EPERM;
+
+	return 0;
+}
+
+static void primary_disable_vblank(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (ctx->suspended)
+		return;
+}
+
+static void primary_wait_for_vblank(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	if (ctx->suspended)
+		return;
+
+	atomic_set(&ctx->wait_vsync_event, 1);
+
+	if (!wait_event_timeout(ctx->wait_vsync_queue,
+				!atomic_read(&ctx->wait_vsync_event),
+				DRM_HZ/20))
+		DRM_DEBUG_KMS("vblank wait timed out.\n");
+}
+
+static void primary_event_call_back_handle(struct rk_drm_display *drm_disp,int win_id,int event)
+{
+	struct primary_context *ctx = get_primary_context(g_dev);
+	struct rockchip_drm_subdrv *subdrv = &ctx->subdrv;
+	struct rockchip_drm_manager *manager = subdrv->manager;
+	struct drm_device *drm_dev = subdrv->drm_dev;
+	switch(event){
+		case RK_DRM_CALLBACK_VSYNC:
+			/* check the crtc is detached already from encoder */
+			if (manager->pipe < 0)
+				return;
+
+			drm_handle_vblank(drm_dev, manager->pipe);
+			rockchip_drm_crtc_finish_pageflip(drm_dev, manager->pipe);
+
+			/* set wait vsync event to zero and wake up queue. */
+			if (atomic_read(&ctx->wait_vsync_event)) {
+				atomic_set(&ctx->wait_vsync_event, 0);
+				DRM_WAKEUP(&ctx->wait_vsync_queue);
+			}
+			break;
+		default:
+			printk(KERN_ERR"-->%s unhandle event %d\n",__func__,event);
+			break;
+	}
+}
+static struct rockchip_drm_manager_ops primary_manager_ops = {
+	.dpms = primary_dpms,
+	.apply = primary_apply,
+	.commit = primary_commit,
+	.enable_vblank = primary_enable_vblank,
+	.disable_vblank = primary_disable_vblank,
+	.wait_for_vblank = primary_wait_for_vblank,
+};
+
+static void primary_win_mode_set(struct device *dev,
+			      struct rockchip_drm_overlay *overlay)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct primary_win_data *win_data;
+	int win;
+	unsigned long offset;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (!overlay) {
+		dev_err(dev, "overlay is NULL\n");
+		return;
+	}
+
+	win = overlay->zpos;
+	if (win == DEFAULT_ZPOS)
+		win = ctx->default_win;
+
+	if (win < 0 || win > WINDOWS_NR)
+		return;
+
+	offset = overlay->fb_x * (overlay->bpp >> 3);
+	offset += overlay->fb_y * overlay->pitch;
+
+//	printk("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);
+//	printk("crtc_x=%d crtc_y=%d crtc_width=%d crtc_height=%d\n",overlay->crtc_x,overlay->crtc_y,overlay->crtc_width,overlay->crtc_height);
+//	printk("fb_width=%d fb_height=%d dma_addr=%x offset=%x\n",overlay->fb_width,overlay->fb_height,overlay->dma_addr[0],offset);
+
+	win_data = &ctx->win_data[win];
+
+	win_data->offset_x = overlay->crtc_x;
+	win_data->offset_y = overlay->crtc_y;
+	win_data->ovl_width = overlay->crtc_width;
+	win_data->ovl_height = overlay->crtc_height;
+	win_data->fb_width = overlay->fb_width;
+	win_data->fb_height = overlay->fb_height;
+	win_data->dma_addr = overlay->dma_addr[0] + offset;
+	win_data->bpp = overlay->bpp;
+	win_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *
+				(overlay->bpp >> 3);
+	win_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);
+
+}
+
+static void primary_win_set_pixfmt(struct device *dev, unsigned int win)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct primary_win_data *win_data = &ctx->win_data[win];
+}
+
+static void primary_win_set_colkey(struct device *dev, unsigned int win)
+{
+//	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+}
+
+static void primary_win_commit(struct device *dev, int zpos)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct rk_drm_display *drm_disp = ctx->drm_disp;
+	struct rk_win_data *rk_win = NULL; 
+	struct primary_win_data *win_data;
+	int win = zpos;
+	unsigned long val,  size;
+	u32 xpos, ypos;
+
+//	printk(KERN_ERR"%s %d\n", __func__,__LINE__);
+
+	if (ctx->suspended)
+		return;
+
+	if (win == DEFAULT_ZPOS)
+		win = ctx->default_win;
+
+	if (win < 0 || win > WINDOWS_NR)
+		return;
+	rk_win = &drm_disp->win[win];
+	win_data = &ctx->win_data[win];
+	switch(win_data->bpp){
+		case 32:
+			rk_win->format = ARGB888;
+			break;
+		case 24:
+			rk_win->format = RGB888;
+			break;
+		case 16:
+			rk_win->format = RGB565;
+			break;
+		default:
+			printk("not support format %d\n",win_data->bpp);
+			break;
+	}
+
+	rk_win->xpos = win_data->offset_x;
+	rk_win->ypos = win_data->offset_y;
+	rk_win->xact = win_data->ovl_width;
+	rk_win->yact = win_data->ovl_height;
+	rk_win->xsize = win_data->ovl_width;
+	rk_win->ysize = win_data->ovl_height;
+	rk_win->xvir = win_data->fb_width;
+	rk_win->yrgb_addr = win_data->dma_addr;
+	rk_win->enabled = true;
+
+	rk_drm_disp_handle(drm_disp,1<<win,RK_DRM_WIN_COMMIT | RK_DRM_DISPLAY_COMMIT);
+		
+	win_data->enabled = true;
+
+}
+
+static void primary_win_disable(struct device *dev, int zpos)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct rk_drm_display *drm_disp = ctx->drm_disp;
+	struct primary_win_data *win_data;
+	int win = zpos;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (win == DEFAULT_ZPOS)
+		win = ctx->default_win;
+
+	if (win < 0 || win > WINDOWS_NR)
+		return;
+
+	win_data = &ctx->win_data[win];
+
+	if (ctx->suspended) {
+		/* do not resume this window*/
+		win_data->resume = false;
+		return;
+	}
+	drm_disp->win[win].enabled = false;
+	rk_drm_disp_handle(drm_disp,1<<win,RK_DRM_WIN_COMMIT | RK_DRM_DISPLAY_COMMIT);
+
+	win_data->enabled = false;
+}
+
+static struct rockchip_drm_overlay_ops primary_overlay_ops = {
+	.mode_set = primary_win_mode_set,
+	.commit = primary_win_commit,
+	.disable = primary_win_disable,
+};
+
+static struct rockchip_drm_manager primary_manager = {
+	.pipe		= -1,
+	.ops		= &primary_manager_ops,
+	.overlay_ops	= &primary_overlay_ops,
+	.display_ops	= &primary_display_ops,
+};
+#if 0
+static irqreturn_t primary_irq_handler(int irq, void *dev_id)
+{
+	struct primary_context *ctx = (struct primary_context *)dev_id;
+	struct rockchip_drm_subdrv *subdrv = &ctx->subdrv;
+	struct drm_device *drm_dev = subdrv->drm_dev;
+	struct rockchip_drm_manager *manager = subdrv->manager;
+	u32 intr0_reg;
+
+
+
+	/* check the crtc is detached already from encoder */
+	if (manager->pipe < 0)
+		goto out;
+
+	drm_handle_vblank(drm_dev, manager->pipe);
+	rockchip_drm_crtc_finish_pageflip(drm_dev, manager->pipe);
+
+	/* set wait vsync event to zero and wake up queue. */
+	if (atomic_read(&ctx->wait_vsync_event)) {
+		atomic_set(&ctx->wait_vsync_event, 0);
+		DRM_WAKEUP(&ctx->wait_vsync_queue);
+	}
+out:
+	return IRQ_HANDLED;
+}
+#endif
+static int primary_subdrv_probe(struct drm_device *drm_dev, struct device *dev)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/*
+	 * enable drm irq mode.
+	 * - with irq_enabled = 1, we can use the vblank feature.
+	 *
+	 * P.S. note that we wouldn't use drm irq handler but
+	 *	just specific driver own one instead because
+	 *	drm framework supports only one irq handler.
+	 */
+	drm_dev->irq_enabled = 1;
+
+	/*
+	 * with vblank_disable_allowed = 1, vblank interrupt will be disabled
+	 * by drm timer once a current process gives up ownership of
+	 * vblank event.(after drm_vblank_put function is called)
+	 */
+	drm_dev->vblank_disable_allowed = 1;
+
+	/* attach this sub driver to iommu mapping if supported. */
+	if (is_drm_iommu_supported(drm_dev))
+		drm_iommu_attach_device(drm_dev, dev);
+
+	return 0;
+}
+
+static void primary_subdrv_remove(struct drm_device *drm_dev, struct device *dev)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/* detach this sub driver from iommu mapping if supported. */
+	if (is_drm_iommu_supported(drm_dev))
+		drm_iommu_detach_device(drm_dev, dev);
+}
+
+
+static void primary_clear_win(struct primary_context *ctx, int win)
+{
+	u32 val;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+}
+
+
+static void primary_window_suspend(struct device *dev)
+{
+	struct primary_win_data *win_data = NULL;
+	struct primary_context *ctx = get_primary_context(dev);
+	int i;
+
+	for (i = 0; i < WINDOWS_NR; i++) {
+		win_data = &ctx->win_data[i];
+		win_data->resume = win_data->enabled;
+		primary_win_disable(dev, i);
+	}
+	primary_wait_for_vblank(dev);
+}
+
+static void primary_window_resume(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+	struct primary_win_data *win_data;
+	int i;
+
+	for (i = 0; i < WINDOWS_NR; i++) {
+		win_data = &ctx->win_data[i];
+		win_data->enabled = win_data->resume;
+		win_data->resume = false;
+	}
+}
+
+static int primary_activate(struct primary_context *ctx, bool enable)
+{
+	struct device *dev = ctx->subdrv.dev;
+	struct rk_drm_display *drm_disp = ctx->drm_disp;
+	if (enable) {
+		int ret;
+
+		ctx->suspended = false;
+
+		drm_disp->enable = true;
+
+		rk_drm_disp_handle(drm_disp,0,RK_DRM_SCREEN_BLANK);
+
+		/* if vblank was enabled status, enable it again. */
+		if (ctx->vblank_en)
+			primary_enable_vblank(dev);
+
+		primary_window_resume(dev);
+	} else {
+		primary_window_suspend(dev);
+
+		drm_disp->enable = false;
+
+		rk_drm_disp_handle(drm_disp,0,RK_DRM_SCREEN_BLANK);
+
+		ctx->suspended = true;
+	}
+
+	return 0;
+}
+
+static int primary_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct primary_context *ctx;
+	struct rockchip_drm_subdrv *subdrv;
+	struct rockchip_drm_panel_info *panel;
+	struct rk_drm_display *drm_display = NULL;
+	int ret = -EINVAL;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	g_dev = dev;
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	panel = devm_kzalloc(dev, sizeof(struct rockchip_drm_panel_info), GFP_KERNEL);
+	ctx->panel = panel;
+
+	drm_display = rk_drm_get_diplay(RK_DRM_PRIMARY_SCREEN);
+	ctx->drm_disp = drm_display;
+	ctx->default_win = 0;
+	memcpy(&panel->timing,drm_display->mode,sizeof(struct fb_videomode));
+
+	drm_display->event_call_back = primary_event_call_back_handle;
+
+	DRM_INIT_WAITQUEUE(&ctx->wait_vsync_queue);
+	atomic_set(&ctx->wait_vsync_event, 0);
+
+	subdrv = &ctx->subdrv;
+
+	subdrv->dev = dev;
+	subdrv->manager = &primary_manager;
+	subdrv->probe = primary_subdrv_probe;
+	subdrv->remove = primary_subdrv_remove;
+
+	mutex_init(&ctx->lock);
+
+	platform_set_drvdata(pdev, ctx);
+
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+	
+	primary_commit(dev);
+	primary_activate(ctx, true);
+
+	rockchip_drm_subdrv_register(subdrv);
+
+	return 0;
+}
+
+static int primary_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct primary_context *ctx = platform_get_drvdata(pdev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	rockchip_drm_subdrv_unregister(&ctx->subdrv);
+
+	if (ctx->suspended)
+		goto out;
+
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_sync(dev);
+
+out:
+	pm_runtime_disable(dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int primary_suspend(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	/*
+	 * do not use pm_runtime_suspend(). if pm_runtime_suspend() is
+	 * called here, an error would be returned by that interface
+	 * because the usage_count of pm runtime is more than 1.
+	 */
+	if (!pm_runtime_suspended(dev))
+		return primary_activate(ctx, false);
+
+	return 0;
+}
+
+static int primary_resume(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	/*
+	 * if entered to sleep when lcd panel was on, the usage_count
+	 * of pm runtime would still be 1 so in this case, fimd driver
+	 * should be on directly not drawing on pm runtime interface.
+	 */
+	if (!pm_runtime_suspended(dev)) {
+		int ret;
+
+		ret = primary_activate(ctx, true);
+		if (ret < 0)
+			return ret;
+
+		/*
+		 * in case of dpms on(standby), primary_apply function will
+		 * be called by encoder's dpms callback to update fimd's
+		 * registers but in case of sleep wakeup, it's not.
+		 * so primary_apply function should be called at here.
+		 */
+		primary_apply(dev);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int primary_runtime_suspend(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	return primary_activate(ctx, false);
+}
+
+static int primary_runtime_resume(struct device *dev)
+{
+	struct primary_context *ctx = get_primary_context(dev);
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	return primary_activate(ctx, true);
+}
+#endif
+
+static const struct dev_pm_ops primary_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(primary_suspend, primary_resume)
+	SET_RUNTIME_PM_OPS(primary_runtime_suspend, primary_runtime_resume, NULL)
+};
+
+struct platform_driver primary_platform_driver = {
+	.probe		= primary_probe,
+	.remove		= primary_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "primary-display",
+		.pm	= &primary_pm_ops,
+	},
+};
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_primary.h b/drivers/gpu/drm/rockchip/rockchip_drm_primary.h
new file mode 100644
index 000000000000..6a3579166bf9
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_primary.h
@@ -0,0 +1,34 @@
+#include "../../../video/rockchip/rk_drm_fb.h"
+#define WINDOWS_NR	4
+
+#define get_primary_context(dev)	platform_get_drvdata(to_platform_device(dev))
+
+struct primary_win_data {
+	unsigned int		offset_x;
+	unsigned int		offset_y;
+	unsigned int		ovl_width;
+	unsigned int		ovl_height;
+	unsigned int		fb_width;
+	unsigned int		fb_height;
+	unsigned int		bpp;
+	dma_addr_t		dma_addr;
+	unsigned int		buf_offsize;
+	unsigned int		line_size;	/* bytes */
+	bool			enabled;
+	bool			resume;
+};
+
+struct primary_context {
+	struct rockchip_drm_subdrv	subdrv;
+	int 				vblank_en;
+	struct drm_crtc			*crtc;
+	struct rk_drm_display 		*drm_disp;
+	struct primary_win_data		win_data[WINDOWS_NR];
+	unsigned int			default_win;
+	bool				suspended;
+	struct mutex			lock;
+	wait_queue_head_t		wait_vsync_queue;
+	atomic_t			wait_vsync_event;
+	
+	struct rockchip_drm_panel_info *panel;
+};
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 64048533ae2f..65a5cf70438e 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -153,6 +153,7 @@ obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
 obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
 obj-$(CONFIG_FB_ROCKCHIP)         += rockchip/
+obj-$(CONFIG_DRM_ROCKCHIP)         += rockchip/
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 26443ef3d7db..1e7ea6318cb8 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -98,7 +98,7 @@ static struct display_timing *of_get_display_timing(struct device_node *np)
 	if (of_property_read_bool(np, "doublescan"))
 		dt->flags |= DISPLAY_FLAGS_DOUBLESCAN;
 
-#if defined(CONFIG_FB_ROCKCHIP)
+#if defined(CONFIG_FB_ROCKCHIP) || defined(CONFIG_DRM_ROCKCHIP)
 	if (!of_property_read_u32(np, "swap-rg", &val))
 		dt->flags |= val ? DISPLAY_FLAGS_SWAP_RG : 0;
 	if (!of_property_read_u32(np, "swap-gb", &val))
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 40b81fcf3093..e03c30460300 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -1,7 +1,10 @@
-obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o screen/ 
+obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o screen/
+obj-$(CONFIG_DRM_ROCKCHIP)  += rk_drm_fb.o screen/
 obj-$(CONFIG_RK_TRSM) += transmitter/
+obj-$(CONFIG_DRM_ROCKCHIP)  += lcdc/
 obj-$(CONFIG_FB_ROCKCHIP) += lcdc/
 obj-$(CONFIG_ROCKCHIP_RGA) += rga/
 obj-$(CONFIG_ROCKCHIP_RGA2) += rga2/
 obj-$(CONFIG_RK_HDMI) += display-sys.o hdmi/
 obj-$(CONFIG_IEP) += iep/
+
diff --git a/drivers/video/rockchip/lcdc/Kconfig b/drivers/video/rockchip/lcdc/Kconfig
index 57b69439b96b..04bff9588cb4 100755
--- a/drivers/video/rockchip/lcdc/Kconfig
+++ b/drivers/video/rockchip/lcdc/Kconfig
@@ -1,19 +1,19 @@
 config LCDC_RK2928
         tristate "rk2928 lcdc support"
-        depends on FB_ROCKCHIP && ARCH_RK2928
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK2928
         help
           Driver for rk2928 lcdc .
 
 config LCDC_RK30
         tristate "rk30 lcdc support"
-        depends on FB_ROCKCHIP && ARCH_RK30XX
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK30XX
         help
           Driver for rk30 lcdc .There are two lcd controllers on rk30
 
 
 config LCDC_RK3066B
         tristate "rk3066b lcdc support"
-        depends on FB_ROCKCHIP && ARCH_RK3066B
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK3066B
         help
           Driver for rk3066b  lcdc.
 
@@ -21,13 +21,13 @@ config LCDC_RK3066B
 
 config LCDC_RK3188
         bool "rk3188 lcdc support"
-        depends on FB_ROCKCHIP 
+        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
         help
           Driver for rk3188/rk302x/rk319x lcdc.There are two lcd controllers on rk3188
 
 
 config LCDC_RK3288
         bool "rk3288 lcdc support"
-        depends on FB_ROCKCHIP 
+        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
         help
           Driver for rk3288 lcdc.There are two lcd controllers on rk3288
diff --git a/drivers/video/rockchip/rk_drm_fb.c b/drivers/video/rockchip/rk_drm_fb.c
new file mode 100755
index 000000000000..eb99fa6188d2
--- /dev/null
+++ b/drivers/video/rockchip/rk_drm_fb.c
@@ -0,0 +1,776 @@
+/*
+ * drivers/video/rockchip/rk_fb.c
+ *
+ * Copyright (C) ROCKCHIP, Inc.
+ * Author:yzq<yxj@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rk_fb.h>
+#include <linux/linux_logo.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_gpio.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <video/of_display_timing.h>
+#include <video/display_timing.h>
+#include <dt-bindings/rkfb/rk_fb.h>
+#endif
+
+#include "rk_drm_fb.h"
+__weak int support_uboot_display(void)
+{
+	return 0;
+}
+static struct platform_device *drm_fb_pdev;
+static struct rk_fb_trsm_ops *trsm_lvds_ops;
+static struct rk_fb_trsm_ops *trsm_edp_ops;
+static struct rk_fb_trsm_ops *trsm_mipi_ops;
+int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)
+{
+	switch (type) {
+	case SCREEN_RGB:
+	case SCREEN_LVDS:
+	case SCREEN_DUAL_LVDS:
+		trsm_lvds_ops = ops;
+		break;
+	case SCREEN_EDP:
+		trsm_edp_ops = ops;
+		break;
+	case SCREEN_MIPI:
+	case SCREEN_DUAL_MIPI:
+		trsm_mipi_ops = ops;
+		break;
+	default:
+		printk(KERN_WARNING "%s:un supported transmitter:%d!\n",
+			__func__, type);
+		break;
+	}
+	return 0;
+}
+
+struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type)
+{
+	struct rk_fb_trsm_ops *ops;
+	switch (type) {
+	case SCREEN_RGB:
+	case SCREEN_LVDS:
+	case SCREEN_DUAL_LVDS:
+		ops = trsm_lvds_ops;
+		break;
+	case SCREEN_EDP:
+		ops = trsm_edp_ops;
+		break;
+	case SCREEN_MIPI:
+	case SCREEN_DUAL_MIPI:
+		ops = trsm_mipi_ops;
+		break;
+	default:
+		ops = NULL;
+		printk(KERN_WARNING "%s:un supported transmitter:%d!\n",
+			__func__, type);
+		break;
+	}
+	return ops;
+}
+/* rk display power control parse from dts
+ *
+*/
+int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)
+{
+	struct device_node *root  = of_get_child_by_name(dev_drv->dev->of_node,
+				"power_ctr");
+	struct device_node *child;
+	struct rk_disp_pwr_ctr_list *pwr_ctr;
+	struct list_head *pos;
+	enum of_gpio_flags flags;
+	u32 val = 0;
+	u32 debug = 0;
+	u32 mirror = 0;
+	int ret;
+
+	INIT_LIST_HEAD(&dev_drv->pwrlist_head);
+	if (!root) {
+		dev_err(dev_drv->dev, "can't find power_ctr node for lcdc%d\n",dev_drv->id);
+		return -ENODEV;
+	}
+
+	for_each_child_of_node(root, child) {
+		pwr_ctr = kmalloc(sizeof(struct rk_disp_pwr_ctr_list), GFP_KERNEL);
+		strcpy(pwr_ctr->pwr_ctr.name, child->name);
+		if (!of_property_read_u32(child, "rockchip,power_type", &val)) {
+			if (val == GPIO) {
+				pwr_ctr->pwr_ctr.type = GPIO;
+				pwr_ctr->pwr_ctr.gpio = of_get_gpio_flags(child, 0, &flags);
+				if (!gpio_is_valid(pwr_ctr->pwr_ctr.gpio)) {
+					dev_err(dev_drv->dev, "%s ivalid gpio\n", child->name);
+					return -EINVAL;
+				}
+				pwr_ctr->pwr_ctr.atv_val = !(flags & OF_GPIO_ACTIVE_LOW);
+				ret = gpio_request(pwr_ctr->pwr_ctr.gpio,child->name);
+				if (ret) {
+					dev_err(dev_drv->dev, "request %s gpio fail:%d\n",
+						child->name,ret);
+				}
+
+			} else {
+				pwr_ctr->pwr_ctr.type = REGULATOR;
+
+			}
+		};
+		of_property_read_u32(child, "rockchip,delay", &val);
+		pwr_ctr->pwr_ctr.delay = val;
+		list_add_tail(&pwr_ctr->list, &dev_drv->pwrlist_head);
+	}
+
+	of_property_read_u32(root, "rockchip,mirror", &mirror);
+
+	if (mirror == NO_MIRROR) {
+		dev_drv->screen0->x_mirror = 0;
+		dev_drv->screen0->y_mirror = 0;
+	} else if (mirror == X_MIRROR) {
+		dev_drv->screen0->x_mirror = 1;
+		dev_drv->screen0->y_mirror = 0;
+	} else if (mirror == Y_MIRROR) {
+		dev_drv->screen0->x_mirror = 0;
+		dev_drv->screen0->y_mirror = 1;
+	} else if(mirror == X_Y_MIRROR) {
+		dev_drv->screen0->x_mirror = 1;
+		dev_drv->screen0->y_mirror = 1;
+	}
+
+	of_property_read_u32(root, "rockchip,debug", &debug);
+
+	if (debug) {
+		list_for_each(pos, &dev_drv->pwrlist_head) {
+			pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+			printk(KERN_INFO "pwr_ctr_name:%s\n"
+					 "pwr_type:%s\n"
+					 "gpio:%d\n"
+					 "atv_val:%d\n"
+					 "delay:%d\n\n",
+					 pwr_ctr->pwr_ctr.name,
+					 (pwr_ctr->pwr_ctr.type == GPIO) ? "gpio" : "regulator",
+					 pwr_ctr->pwr_ctr.gpio,
+					 pwr_ctr->pwr_ctr.atv_val,
+					 pwr_ctr->pwr_ctr.delay);
+		}
+	}
+
+	return 0;
+
+}
+
+int rk_fb_video_mode_from_timing(const struct display_timing *dt, 
+				struct rk_screen *screen)
+{
+	screen->mode.pixclock = dt->pixelclock.typ;
+	screen->mode.left_margin = dt->hback_porch.typ;
+	screen->mode.right_margin = dt->hfront_porch.typ;
+	screen->mode.xres = dt->hactive.typ;
+	screen->mode.hsync_len = dt->hsync_len.typ;
+	screen->mode.upper_margin = dt->vback_porch.typ;
+	screen->mode.lower_margin = dt->vfront_porch.typ;
+	screen->mode.yres = dt->vactive.typ;
+	screen->mode.vsync_len = dt->vsync_len.typ;
+	screen->type = dt->screen_type;
+	screen->lvds_format = dt->lvds_format;
+	screen->face = dt->face;
+
+	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+		screen->pin_dclk = 1;
+	else
+		screen->pin_dclk = 0;
+	if(dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if(dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+	if(dt->flags & DISPLAY_FLAGS_DE_HIGH)
+		screen->pin_den = 1;
+	else
+		screen->pin_den = 0;
+	
+	return 0;
+	
+}
+
+int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
+{
+	struct display_timings *disp_timing;
+	struct display_timing *dt;
+	disp_timing = of_get_display_timings(np);
+	if (!disp_timing) {
+		pr_err("parse display timing err\n");
+		return -EINVAL;
+	}
+	dt = display_timings_get(disp_timing, 0);
+	rk_fb_video_mode_from_timing(dt, screen);
+	printk(KERN_ERR "dclk:%d\n"
+			 "hactive:%d\n"
+			 "hback_porch:%d\n"
+			 "hfront_porch:%d\n"
+			 "hsync_len:%d\n"
+			 "vactive:%d\n"
+			 "vback_porch:%d\n"
+			 "vfront_porch:%d\n"
+			 "vsync_len:%d\n"
+			 "screen_type:%d\n"
+			 "lvds_format:%d\n"
+			 "face:%d\n",
+			dt->pixelclock.typ,
+			dt->hactive.typ,
+			dt->hback_porch.typ,
+			dt->hfront_porch.typ,
+			dt->hsync_len.typ,
+			dt->vactive.typ,
+			dt->vback_porch.typ,
+			dt->vfront_porch.typ,
+			dt->vsync_len.typ,
+			dt->screen_type,
+			dt->lvds_format,
+			dt->face);
+	return 0;
+
+}
+static int init_lcdc_win(struct rk_lcdc_driver *dev_drv, struct rk_lcdc_win *def_win)
+{
+	int i;
+	int lcdc_win_num = dev_drv->lcdc_win_num;
+	for (i = 0; i < lcdc_win_num; i++) {
+		struct rk_lcdc_win *win = NULL;
+		win =  kzalloc(sizeof(struct rk_lcdc_win), GFP_KERNEL);
+		if (!win) {
+			dev_err(dev_drv->dev, "kzmalloc for win fail!");
+			return   -ENOMEM;
+		}
+
+		strcpy(win->name, def_win[i].name);
+		win->id = def_win[i].id;
+		win->support_3d = def_win[i].support_3d;
+		dev_drv->win[i] = win;
+	}
+
+	return 0;
+}
+
+static int init_lcdc_device_driver(struct rk_drm_screen_private *screen_priv,
+					struct rk_lcdc_win *def_win, int index)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_lcdc_driver *dev_drv = screen_priv->lcdc_dev_drv;
+	struct rk_screen *screen1 = NULL;
+	struct rk_screen *screen = devm_kzalloc(dev_drv->dev,
+				sizeof(struct rk_screen), GFP_KERNEL);
+	if (!screen) {
+		dev_err(dev_drv->dev, "malloc screen for lcdc%d fail!",
+					dev_drv->id);
+		goto fail_screen;
+	}
+	
+	screen->screen_id = 0;
+	screen->lcdc_id = dev_drv->id;
+	dev_drv->screen0 = screen;
+	dev_drv->cur_screen = screen;
+	/* devie use one lcdc + rk61x scaler for dual display*/
+	if (rk_drm_priv->disp_mode == ONE_DUAL) {
+		screen1 = devm_kzalloc(dev_drv->dev,
+						sizeof(struct rk_screen), GFP_KERNEL);
+		if (screen1) {
+			dev_err(dev_drv->dev, "malloc screen1 for lcdc%d fail!",
+						dev_drv->id);
+			goto fail_screen1;
+		}
+		screen1->screen_id = 1;
+		screen1->lcdc_id = 1;
+		dev_drv->screen1 = screen1;
+	}
+	sprintf(dev_drv->name, "lcdc%d", dev_drv->id);
+	init_lcdc_win(dev_drv, def_win);
+	init_completion(&dev_drv->frame_done);
+	spin_lock_init(&dev_drv->cpl_lock);
+	mutex_init(&dev_drv->fb_win_id_mutex);
+	dev_drv->ops->fb_win_remap(dev_drv, FB_DEFAULT_ORDER);
+	dev_drv->first_frame = 1;
+	rk_disp_pwr_ctr_parse_dt(dev_drv);
+	if (dev_drv->prop == PRMRY) {
+		rk_fb_set_prmry_screen(screen);
+		rk_fb_get_prmry_screen(screen);
+	}
+	dev_drv->trsm_ops = rk_fb_trsm_ops_get(screen->type);
+
+	return 0;
+
+fail_screen1:
+	devm_kfree(dev_drv->dev,screen);
+fail_screen:
+	
+	return -ENOMEM;
+}
+int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)
+{
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	if (list_empty(&dev_drv->pwrlist_head))
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_direction_output(pwr_ctr->gpio,pwr_ctr->atv_val);
+			mdelay(pwr_ctr->delay);
+		}
+	}
+
+	return 0;
+}
+int  rk_fb_calc_fps(struct rk_screen * screen, u32 pixclock)
+{
+	int x, y;
+	unsigned long long hz;
+	if (!screen) {
+		printk(KERN_ERR "%s:null screen!\n", __func__);
+		return 0;
+	}
+	x = screen->mode.xres + screen->mode.left_margin + screen->mode.right_margin +
+	    screen->mode.hsync_len;
+	y = screen->mode.yres + screen->mode.upper_margin + screen->mode.lower_margin +
+	    screen->mode.vsync_len;
+
+	hz = 1000000000000ULL;	/* 1e12 picoseconds per second */
+
+	hz += (x * y) / 2;
+	do_div(hz, x * y);	/* divide by x * y with rounding */
+
+	hz += pixclock / 2;
+	do_div(hz, pixclock);	/* divide by pixclock with rounding */
+
+	return hz;
+}
+
+char *get_format_string(enum data_format format, char *fmt)
+{
+	if (!fmt)
+		return NULL;
+	switch (format) {
+	case ARGB888:
+		strcpy(fmt, "ARGB888");
+		break;
+	case RGB888:
+		strcpy(fmt, "RGB888");
+		break;
+	case RGB565:
+		strcpy(fmt, "RGB565");
+		break;
+	case YUV420:
+		strcpy(fmt, "YUV420");
+		break;
+	case YUV422:
+		strcpy(fmt, "YUV422");
+		break;
+	case YUV444:
+		strcpy(fmt, "YUV444");
+		break;
+	case XRGB888:
+		strcpy(fmt, "XRGB888");
+		break;
+	case XBGR888:
+		strcpy(fmt, "XBGR888");
+		break;
+	case ABGR888:
+		strcpy(fmt, "XBGR888");
+		break;
+	default:
+		strcpy(fmt, "invalid");
+		break;
+	}
+
+	return fmt;
+
+}
+int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)
+{
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	if (list_empty(&dev_drv->pwrlist_head))
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_set_value(pwr_ctr->gpio,pwr_ctr->atv_val);
+		}
+	}
+
+	return 0;
+}
+/********************************
+*check if the primary lcdc has registerd,
+the primary lcdc mas register first
+*********************************/
+bool is_prmry_rk_lcdc_registered(void)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	if (rk_drm_priv->screen_priv[0].lcdc_dev_drv)
+		return  true;
+	else
+		return false;
+
+
+}
+static void rk_fb_update_regs_handler(struct kthread_work *work)
+{
+	struct rk_lcdc_driver * dev_drv =
+			container_of(work, struct rk_lcdc_driver, update_regs_work);
+	struct rk_fb_reg_data *data, *next;
+#if 0
+	//struct list_head saved_list;
+	mutex_lock(&dev_drv->update_regs_list_lock);
+	saved_list = dev_drv->update_regs_list;
+	list_replace_init(&dev_drv->update_regs_list, &saved_list);
+	mutex_unlock(&dev_drv->update_regs_list_lock);
+	
+	list_for_each_entry_safe(data, next, &saved_list, list) {
+		//rk_fb_update_reg(dev_drv,data);
+		list_del(&data->list);
+		kfree(data);
+	}
+#endif
+}
+static int rk_fb_wait_for_vsync_thread(void *data)
+{
+	struct rk_lcdc_driver  *dev_drv = data;
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_screen_private *drm_screen_priv = NULL;
+	struct rk_drm_display *drm_display = NULL;
+
+	if(dev_drv->prop == PRMRY)
+		drm_screen_priv = &rk_drm_priv->screen_priv[0];
+	else if(dev_drv->prop == EXTEND)
+		drm_screen_priv = &rk_drm_priv->screen_priv[1];
+	if(drm_screen_priv == NULL)
+		return -1;
+	drm_display = &drm_screen_priv->drm_disp;
+
+	while (!kthread_should_stop()) {
+		ktime_t timestamp = dev_drv->vsync_info.timestamp;
+		int ret = wait_event_interruptible(dev_drv->vsync_info.wait,
+			!ktime_equal(timestamp, dev_drv->vsync_info.timestamp) &&
+			(dev_drv->vsync_info.active || dev_drv->vsync_info.irq_stop));
+
+		if(!ret && drm_display->event_call_back)
+			drm_display->event_call_back(drm_display,0,RK_DRM_CALLBACK_VSYNC);
+	}
+
+	return 0;
+}
+int rk_fb_register(struct rk_lcdc_driver *dev_drv,
+		struct rk_lcdc_win *win, int id)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_display *drm_display = NULL;
+	struct rk_win_data *win_data = NULL;
+	int i=0;
+
+	if (rk_drm_priv->num_screen == RK30_MAX_LCDC_SUPPORT)
+		return -ENXIO;
+	for (i = 0; i < RK_DRM_MAX_SCREEN_NUM; i++) {
+		if (!rk_drm_priv->screen_priv[i].lcdc_dev_drv) 
+			break;
+	}
+	
+	rk_drm_priv->num_screen++;
+	rk_drm_priv->screen_priv[i].lcdc_dev_drv = dev_drv;
+	rk_drm_priv->screen_priv[i].lcdc_dev_drv->id = id;
+
+	init_lcdc_device_driver(&rk_drm_priv->screen_priv[i],win,i);
+	
+	drm_display = &rk_drm_priv->screen_priv[i].drm_disp;
+	drm_display->num_win = dev_drv->lcdc_win_num;
+	if(dev_drv->prop == PRMRY){
+		drm_display->screen_type = RK_DRM_PRIMARY_SCREEN;
+		drm_display->num_videomode = 1;
+		drm_display->best_mode = 0;
+		drm_display->is_connected = 1;
+		drm_display->mode = &dev_drv->cur_screen->mode;
+		printk("----->yzq mode dclk=%d\n",drm_display->mode->pixclock);
+	}else if(dev_drv->prop == EXTEND){
+		drm_display->screen_type = RK_DRM_EXTEND_SCREEN;
+		drm_display->num_videomode = 1;
+		drm_display->best_mode = 0;
+		drm_display->is_connected = 0;
+	}
+	if (dev_drv->prop == PRMRY) {
+		init_waitqueue_head(&dev_drv->vsync_info.wait);
+		dev_drv->vsync_info.thread = kthread_run(rk_fb_wait_for_vsync_thread,
+				dev_drv, "fb-vsync");
+		if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) {
+			printk( "failed to run vsync thread\n");
+			dev_drv->vsync_info.thread = NULL;
+		}
+		dev_drv->vsync_info.active = 1;
+
+		mutex_init(&dev_drv->output_lock);
+
+		INIT_LIST_HEAD(&dev_drv->update_regs_list);
+		mutex_init(&dev_drv->update_regs_list_lock);
+		init_kthread_worker(&dev_drv->update_regs_worker);
+
+		dev_drv->update_regs_thread = kthread_run(kthread_worker_fn,
+				&dev_drv->update_regs_worker, "rk-fb");
+		if (IS_ERR(dev_drv->update_regs_thread)) {
+			int err = PTR_ERR(dev_drv->update_regs_thread);
+			dev_drv->update_regs_thread = NULL;
+
+			printk("failed to run update_regs thread\n");
+			return err;
+		}
+		init_kthread_work(&dev_drv->update_regs_work, rk_fb_update_regs_handler);
+
+		dev_drv->timeline = sw_sync_timeline_create("fb-timeline");			dev_drv->timeline_max = 1;
+	}
+	return 0;
+}
+int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
+
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	int i = 0;
+
+	return 0;
+}
+
+struct rk_drm_display *rk_drm_get_info(int screen_type)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	int i=0;
+	for( i=0; i<rk_drm_priv->num_screen; i++){
+		if(rk_drm_priv->screen_priv[i].drm_disp.screen_type == screen_type)
+			break;
+	}
+	if(i==rk_drm_priv->num_screen){
+		printk("--->%s can not find match DISPLAY_TYPE %d\n",__func__,screen_type);
+		return NULL;
+	}
+	
+	return &rk_drm_priv->screen_priv[i].drm_disp;
+}
+
+static int rk_drm_screen_blank(struct rk_drm_display *drm_disp)
+{
+//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_screen_private *drm_screen_priv =
+	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
+	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
+
+	lcdc_dev->ops->blank(lcdc_dev, 0,drm_disp->enable?FB_BLANK_UNBLANK:FB_BLANK_NORMAL);
+
+	return 0;
+}
+static int rk_drm_screen_videomode_set(struct rk_drm_display *drm_disp)
+{
+//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_screen_private *drm_screen_priv =
+	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
+	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
+	struct fb_videomode *mode = drm_disp->mode;
+	if(!mode){
+		printk(KERN_ERR"-->%s fb_video mode is NULL",__func__);
+		return -1;
+	}
+
+	if(mode != &lcdc_dev->cur_screen->mode)
+		memcpy(&lcdc_dev->cur_screen->mode,mode,sizeof(struct fb_videomode));
+	
+	if(!lcdc_dev->atv_layer_cnt)
+		lcdc_dev->ops->open(lcdc_dev, 0,true);
+	
+	lcdc_dev->ops->ovl_mgr(lcdc_dev, 3210, 1);
+	lcdc_dev->ops->load_screen(lcdc_dev,1);
+	return 0;
+}
+
+static int rk_drm_win_commit(struct rk_drm_display *drm_disp,unsigned int win_id)
+{
+//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_screen_private *drm_screen_priv =
+	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
+	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
+
+	unsigned int i=0,j=0;
+	for( i=1; i < RK_DRM_WIN_MASK; i=i<<1){
+		if(i&win_id ){
+			struct rk_lcdc_win *lcdc_win = lcdc_dev->win[j];
+			struct rk_win_data *drm_win= &drm_disp->win[j];
+			if(!lcdc_win && !drm_win){
+				printk(KERN_ERR"---->%s can not find display win%d\n",__func__,j);
+				return -1;
+			}
+			lcdc_win->format = drm_win->format;
+			lcdc_win->area[0].xpos = drm_win->xpos;
+			lcdc_win->area[0].ypos = drm_win->ypos;
+			lcdc_win->area[0].xsize = drm_win->xsize;
+			lcdc_win->area[0].ysize = drm_win->ysize;
+			lcdc_win->area[0].xact = drm_win->xact;
+			lcdc_win->area[0].yact = drm_win->yact;
+			lcdc_win->area[0].xvir = drm_win->xvir;
+			lcdc_win->area[0].y_vir_stride = drm_win->xvir;
+			lcdc_win->area[0].smem_start = drm_win->yrgb_addr;
+			lcdc_win->area[0].cbr_start = drm_win->uv_addr;
+			lcdc_win->alpha_en = 1;
+			if(lcdc_win->state != drm_win->enabled){
+				lcdc_dev->ops->open(lcdc_dev, j,drm_win->enabled?true:false);
+			}
+			lcdc_dev->ops->set_par(lcdc_dev,j);
+			lcdc_dev->ops->pan_display(lcdc_dev,j);
+		}
+		j++;
+	}
+	return 0;
+}
+
+static int rk_drm_display_commit(struct rk_drm_display *drm_disp)
+{
+//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_drm_screen_private *drm_screen_priv =
+	     	container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
+	struct rk_lcdc_driver *lcdc_dev = drm_screen_priv->lcdc_dev_drv;
+	lcdc_dev->ops->lcdc_reg_update(lcdc_dev);
+	return 0;
+}
+int rk_drm_disp_handle(struct rk_drm_display *drm_disp,unsigned int win_id,unsigned int cmd_id)
+{
+//	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	int i=0;
+	for( i=1; i<RK_DRM_CMD_MASK; i=i<<1){
+		switch(i&cmd_id){
+			case RK_DRM_SCREEN_SET:
+				rk_drm_screen_videomode_set(drm_disp);
+				break;
+			case RK_DRM_SCREEN_BLANK:
+				rk_drm_screen_blank(drm_disp);
+				break;
+			case RK_DRM_WIN_COMMIT:
+				rk_drm_win_commit(drm_disp, win_id);
+				break;
+			case RK_DRM_DISPLAY_COMMIT:
+				rk_drm_display_commit(drm_disp);
+				break;
+		}
+			
+	}
+	return 0;
+}
+
+struct rk_drm_display *rk_drm_get_diplay(int screen_type)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	int i=0;
+	for( i=0; i < rk_drm_priv->num_screen; i++){
+		if(rk_drm_priv->screen_priv[i].drm_disp.screen_type == screen_type)
+			return &rk_drm_priv->screen_priv[i].drm_disp;
+	}
+
+	return NULL;
+}
+
+
+static int rk_drm_fb_probe(struct platform_device *pdev)
+{
+	struct rk_drm_private  *rk_drm_priv= NULL;
+	struct device_node *np = pdev->dev.of_node;
+	u32 mode;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+
+	rk_drm_priv= devm_kzalloc(&pdev->dev, sizeof(struct rk_drm_private), GFP_KERNEL);
+	if (!rk_drm_priv) {
+		dev_err(&pdev->dev, "kmalloc for rk_drm_priv fail!");
+		return  -ENOMEM;
+	}
+	platform_set_drvdata(pdev, rk_drm_priv);
+
+	if (!of_property_read_u32(np, "rockchip,disp-mode", &mode)) {
+		rk_drm_priv->disp_mode = mode;
+	} else {
+		dev_err(&pdev->dev, "no disp-mode node found!");
+		return -ENODEV;
+	}
+	dev_set_name(&pdev->dev, "rockchip-drmfb");
+
+	drm_fb_pdev = pdev;
+	dev_info(&pdev->dev, "rockchip drm framebuffer driver probe\n");
+	return 0;
+}
+
+static int rk_drm_fb_remove(struct platform_device *pdev)
+{
+	struct rk_drm_private  *rk_drm_priv = platform_get_drvdata(pdev);
+	kfree(rk_drm_priv);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void rk_drm_fb_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+
+static const struct of_device_id rk_drm_fb_dt_ids[] = {
+	{ .compatible = "rockchip,rk-fb", },
+	{}
+};
+
+static struct platform_driver rk_drm_fb_driver = {
+	.probe		= rk_drm_fb_probe,
+	.remove		= rk_drm_fb_remove,
+	.driver		= {
+		.name	= "rk-fb",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(rk_drm_fb_dt_ids),
+	},
+	.shutdown   = rk_drm_fb_shutdown,
+};
+
+static int __init rk_drm_fb_init(void)
+{
+	return platform_driver_register(&rk_drm_fb_driver);
+}
+
+static void __exit rk_drm_fb_exit(void)
+{
+	platform_driver_unregister(&rk_drm_fb_driver);
+}
+
+fs_initcall(rk_drm_fb_init);
+module_exit(rk_drm_fb_exit);
diff --git a/drivers/video/rockchip/rk_drm_fb.h b/drivers/video/rockchip/rk_drm_fb.h
new file mode 100644
index 000000000000..a24a925dfae0
--- /dev/null
+++ b/drivers/video/rockchip/rk_drm_fb.h
@@ -0,0 +1,66 @@
+#include <linux/rk_fb.h>
+
+#define RK_DRM_WIN_MASK  0x7fff
+#define RK_DRM_CMD_MASK  0x7fff
+
+#define RK_DRM_CALLBACK_VSYNC   0x1
+
+#define RK_DRM_SCREEN_SET 	1<<0
+#define	RK_DRM_SCREEN_BLANK 	1<<1
+#define	RK_DRM_WIN_COMMIT     	1<<2
+#define RK_DRM_DISPLAY_COMMIT 	1<<3
+
+enum drm_screen_type {
+	RK_DRM_PRIMARY_SCREEN = 0,
+	RK_DRM_EXTEND_SCREEN,
+	RK_DRM_MAX_SCREEN_NUM,
+};
+struct rk_win_data {
+	unsigned int		win_id;
+	enum data_format 	format;
+	unsigned int		xpos;
+	unsigned int		ypos;
+	unsigned int		xact;
+	unsigned int		yact;
+	unsigned int		xsize;
+	unsigned int		ysize;
+	unsigned int 		xvir;
+
+	dma_addr_t		yrgb_addr;
+	dma_addr_t		uv_addr;
+	
+	bool			enabled;
+};
+
+struct rk_drm_display {
+/***** hardware define *****/ 
+	enum drm_screen_type screen_type;
+	struct fb_videomode *mode;
+	int num_videomode;
+	int best_mode;
+	bool is_connected;
+
+/***** user fill info  *****/
+	int mode_id;
+	bool enable;
+	struct rk_win_data win[RK30_MAX_LAYER_SUPPORT]; 
+	int num_win;
+
+	void (*event_call_back)(struct rk_drm_display *drm_disp,int win_id,int event);
+};
+
+struct rk_drm_screen_private {
+	struct rk_drm_display drm_disp;
+	struct rk_screen screen;
+	struct rk_fb_trsm_ops *trsm_ops;
+	struct rk_lcdc_driver *lcdc_dev_drv;
+};
+struct rk_drm_private {
+	struct rk_drm_screen_private screen_priv[RK_DRM_MAX_SCREEN_NUM];
+	int num_screen;
+
+	int disp_mode;
+};
+
+extern struct rk_drm_display *rk_drm_get_diplay(int screen_type);
+extern int rk_drm_disp_handle(struct rk_drm_display *drm_disp,unsigned int win_id,unsigned int cmd_id);
diff --git a/include/video/display_timing.h b/include/video/display_timing.h
index 3e64b4144c79..bf2bd657e0c4 100644
--- a/include/video/display_timing.h
+++ b/include/video/display_timing.h
@@ -27,7 +27,7 @@ enum display_flags {
 	DISPLAY_FLAGS_PIXDATA_NEGEDGE	= BIT(7),
 	DISPLAY_FLAGS_INTERLACED	= BIT(8),
 	DISPLAY_FLAGS_DOUBLESCAN	= BIT(9),
-#if defined(CONFIG_FB_ROCKCHIP)
+#if defined(CONFIG_FB_ROCKCHIP) || defined(CONFIG_DRM_ROCKCHIP)
 	DISPLAY_FLAGS_SWAP_GB		= BIT(10),
 	DISPLAY_FLAGS_SWAP_RG		= BIT(11),
 	DISPLAY_FLAGS_SWAP_RB		= BIT(12),
-- 
2.35.3

