From 8e8dcb7e5ef15bbbea9075e070f8080135e2528d Mon Sep 17 00:00:00 2001
From: kfx <kfx@rock-chips.com>
Date: Mon, 22 Oct 2012 15:41:15 +0800
Subject: [PATCH] rk2928_defconfig: support 'rk2926 top board'

---
 arch/arm/configs/rk2928_defconfig             |  19 +-
 arch/arm/mach-rk2928/board-rk2928-config.c    | 317 ++++++++
 arch/arm/mach-rk2928/board-rk2928-key.c       |  65 ++
 .../mach-rk2928/board-rk2928-sdk-tps65910.c   |   4 +
 arch/arm/mach-rk2928/board-rk2928.c           | 752 +++++++++++-------
 arch/arm/mach-rk2928/include/mach/config.h    | 228 ++++++
 arch/arm/plat-rk/config.c                     |  10 +-
 arch/arm/plat-rk/include/plat/board.h         |   2 +-
 arch/arm/plat-rk/include/plat/gpio.h          |   5 +
 drivers/input/touchscreen/eeti_egalax_i2c.c   |  95 ++-
 drivers/input/touchscreen/rk_tp.c             |  37 +
 drivers/video/display/screen/Kconfig          |   4 +-
 drivers/video/display/screen/Makefile         |   1 +
 drivers/video/display/screen/lcd_rk2928.c     |  78 ++
 include/linux/rk_fb.h                         |  10 +-
 15 files changed, 1324 insertions(+), 303 deletions(-)
 create mode 100644 arch/arm/mach-rk2928/board-rk2928-config.c
 create mode 100755 arch/arm/mach-rk2928/board-rk2928-key.c
 create mode 100644 arch/arm/mach-rk2928/include/mach/config.h
 create mode 100755 drivers/input/touchscreen/rk_tp.c
 create mode 100755 drivers/video/display/screen/lcd_rk2928.c

diff --git a/arch/arm/configs/rk2928_defconfig b/arch/arm/configs/rk2928_defconfig
index a38b2020964c..eb939d032d0a 100644
--- a/arch/arm/configs/rk2928_defconfig
+++ b/arch/arm/configs/rk2928_defconfig
@@ -22,6 +22,7 @@ CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
 CONFIG_ARCH_RK2928=y
+CONFIG_DDR_FREQ=y
 CONFIG_RK_CLOCK_PROC=y
 CONFIG_RK_USB_UART=y
 CONFIG_MACH_RK2928=y
@@ -234,11 +235,15 @@ CONFIG_TABLET_USB_HANWANG=y
 CONFIG_TABLET_USB_KBTAB=y
 CONFIG_TABLET_USB_WACOM=y
 CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_EETI_EGALAX=y
+CONFIG_EETI_EGALAX_MAX_X=1087
+CONFIG_EETI_EGALAX_MAX_Y=800
 CONFIG_TOUCHSCREEN_SITRONIX_A720=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_KEYCHORD=y
 CONFIG_INPUT_UINPUT=y
 CONFIG_GS_MMA7660=y
+CONFIG_GS_MMA8452=y
 CONFIG_SENSOR_DEVICE=y
 CONFIG_GSENSOR_DEVICE=y
 # CONFIG_SERIO is not set
@@ -247,16 +252,21 @@ CONFIG_GSENSOR_DEVICE=y
 # CONFIG_HW_RANDOM is not set
 CONFIG_I2C=y
 # CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
 CONFIG_I2C0_CONTROLLER_RK30=y
 CONFIG_I2C1_CONTROLLER_RK30=y
 CONFIG_I2C2_CONTROLLER_RK30=y
 CONFIG_ADC_RK30=y
+CONFIG_GPIO_SYSFS=y
 CONFIG_EXPANDED_GPIO_NUM=0
 CONFIG_EXPANDED_GPIO_IRQ_NUM=0
 CONFIG_SPI_FPGA_GPIO_NUM=0
 CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
 CONFIG_POWER_SUPPLY=y
-CONFIG_TEST_POWER=y
+CONFIG_BATTERY_RK30_ADC_FAC=y
+CONFIG_BATTERY_RK30_AC_CHARGE=y
+CONFIG_BATTERY_RK30_VOL3V8=y
+CONFIG_POWER_ON_CHARGER_DISPLAY=y
 # CONFIG_HWMON is not set
 CONFIG_MFD_TPS65910=y
 CONFIG_MFD_TPS65090=y
@@ -279,7 +289,7 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_DISPLAY_SUPPORT=y
-CONFIG_LCD_RK2928_A720=y
+CONFIG_LCD_RK2928=y
 CONFIG_FB_ROCKCHIP=y
 CONFIG_LCDC_RK2928=y
 CONFIG_RK_HDMI=y
@@ -289,6 +299,8 @@ CONFIG_RK_LVDS=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_LINUX_800x480_CLUT224=y
 CONFIG_SOUND=y
 CONFIG_SND=y
 # CONFIG_SND_SUPPORT_OLD_API is not set
@@ -366,15 +378,18 @@ CONFIG_USB_SERIAL_OPTION=y
 CONFIG_USB_GADGET=y
 CONFIG_USB20_HOST=y
 CONFIG_USB20_OTG=y
+CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
 CONFIG_MMC=y
 CONFIG_MMC_UNSAFE_RESUME=y
 CONFIG_MMC_EMBEDDED_SDIO=y
 CONFIG_MMC_PARANOID_SD_INIT=y
 CONFIG_SDMMC_RK29=y
+CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO=y
 # CONFIG_SDMMC1_RK29 is not set
 CONFIG_SWITCH=y
 CONFIG_SWITCH_GPIO=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_HYM8563=y
 CONFIG_TPS65910_RTC=y
 CONFIG_STAGING=y
 CONFIG_ANDROID=y
diff --git a/arch/arm/mach-rk2928/board-rk2928-config.c b/arch/arm/mach-rk2928/board-rk2928-config.c
new file mode 100644
index 000000000000..0b1d38b90bc9
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-config.c
@@ -0,0 +1,317 @@
+#if 1
+#define CONFIG_ERR(v, name)     do { printk("%s: Invalid parameter: %s(%d)\n", __func__, (name), (v)); } while(0)
+#else
+#define CONFIG_ERR(v, name)
+#endif
+#include <mach/config.h>
+int __sramdata g_pmic_type =  0;
+
+struct pwm_io_config{
+        int id;
+        int gpio;
+        char *mux_name;
+        unsigned int io_mode;
+        unsigned int pwm_mode;
+};
+static struct pwm_io_config pwm_cfg[] = {
+        {
+                .id = 0,
+                .gpio = RK2928_PIN0_PD2,
+                .mux_name = GPIO0D2_PWM_0_NAME,
+                .io_mode = GPIO0D_GPIO0D2,
+                .pwm_mode = GPIO0D_PWM_0,
+        },
+        {
+                .id = 1,
+                .gpio = RK2928_PIN0_PD3,
+                .mux_name = GPIO0D3_PWM_1_NAME,
+                .io_mode = GPIO0D_GPIO0D3,
+                .pwm_mode = GPIO0D_PWM_1,
+        },
+        {
+                .id = 2,
+                .gpio = RK2928_PIN0_PD4,
+                .mux_name = GPIO0D4_PWM_2_NAME,
+                .io_mode = GPIO0D_GPIO0D4,
+                .pwm_mode = GPIO0D_PWM_2,
+        },
+};
+
+/*************************************** parameter ******************************************/
+/* keyboard */
+uint key_adc = DEF_KEY_ADC;
+uint key_val_size = 7;
+uint key_val[] = {DEF_PLAY_KEY, DEF_VOLDN_KEY, DEF_VOLUP_KEY, DEF_MENU_KEY, DEF_ESC_KEY, DEF_HOME_KEY, DEF_CAM_KEY};
+module_param_array(key_val, uint, &key_val_size, 0644);
+
+static inline int check_key_param(void)
+{
+        return 0;
+}
+/* backlight */
+static uint bl_pwm = DEF_BL_PWM;
+module_param(bl_pwm, uint, 0644);
+static uint bl_ref = DEF_BL_REF; 
+module_param(bl_ref, uint, 0644);
+static uint bl_min = DEF_BL_MIN;
+module_param(bl_min, uint, 0644);
+static int bl_en = DEF_BL_EN;
+module_param(bl_en, int, 0644);
+
+static inline int check_bl_param(void)
+{
+        if(bl_pwm < 0 || bl_pwm >= ARRAY_SIZE(pwm_cfg)){
+                CONFIG_ERR(bl_pwm, "bl_pwm");
+                return -EINVAL;
+        }
+        if(bl_ref != 0 && bl_ref != 1){
+                CONFIG_ERR(bl_ref, "bl_ref");
+                return -EINVAL;
+        }
+        if(bl_min > 100){
+                CONFIG_ERR(bl_min, "bl_min");
+                return -EINVAL;
+        }
+        return 0;
+}
+
+/* lcd */
+static int lcd_cabc = DEF_LCD_CABC;
+module_param(lcd_cabc, int, 0644);
+static int lcd_en = DEF_LCD_EN;
+module_param(lcd_en, int, 0644);
+static int lcd_std = DEF_LCD_STD;
+module_param(lcd_std, int, 0644);
+
+static inline int check_lcd_param(void)
+{
+        return 0;
+
+}
+
+/* gsensor */
+static int gs_type = DEF_GS_TYPE;
+
+static int gs_i2c = DEF_GS_I2C;
+module_param(gs_i2c, int, 0644);
+static int gs_addr = DEF_GS_ADDR;
+module_param(gs_addr, int, 0644);
+static int gs_irq = DEF_GS_IRQ;
+module_param(gs_irq, int, 0644);
+static int gs_pwr = DEF_GS_PWR;
+module_param(gs_pwr, int, 0644);
+static int gs_orig[9] = DEF_GS_ORIG;
+module_param_array(gs_orig, int, NULL, 0644);
+
+static inline int check_gs_param(void)
+{
+        int i;
+
+        if(gs_type <= GS_TYPE_NONE || gs_type > GS_TYPE_MAX){
+                CONFIG_ERR(gs_type, "gs_type");
+                return -EINVAL;
+        }
+        if(gs_i2c < 0 || gs_i2c > 3){
+                CONFIG_ERR(gs_i2c, "gs_i2c");
+                return -EINVAL;
+        }
+        if(gs_addr < 0 || gs_addr > 0x7f){
+                CONFIG_ERR(gs_i2c, "gs_addr");
+                return -EINVAL;
+        }
+        for(i = 0; i < 9; i++){
+                if(gs_orig[i] != 1 && gs_orig[i] != 0 && gs_orig[i] != -1){
+                        CONFIG_ERR(gs_orig[i], "gs_orig[x]");
+                        return -EINVAL;
+                }
+        }
+        return 0;
+}
+
+/* pwm regulator */
+static int __sramdata reg_pwm = DEF_REG_PWM;
+module_param(reg_pwm, int, 0644);
+static inline int check_reg_pwm_param(void)
+{
+        if(reg_pwm < 0 || reg_pwm >= ARRAY_SIZE(pwm_cfg)){  
+                CONFIG_ERR(reg_pwm, "reg_pwm");
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+/* pmic */
+static uint pmic_type = DEF_PMIC_TYPE;
+module_param(pmic_type, uint, 0644);
+static __sramdata int pmic_slp = DEF_PMIC_SLP;
+module_param(pmic_slp, int, 0644);
+static int pmic_irq = DEF_PMIC_IRQ;
+module_param(pmic_irq, int, 0644);
+static int pmic_i2c = DEF_PMIC_I2C;
+module_param(pmic_i2c, int, 0644);
+static int pmic_addr = DEF_PMIC_ADDR;
+module_param(pmic_addr, int, 0644);
+
+static inline int check_pmic_param(void)
+{
+        if(pmic_type <= PMIC_TYPE_WM8326 || pmic_type >= PMIC_TYPE_MAX){
+                CONFIG_ERR(pmic_type, "pmic_type");
+                return -EINVAL;
+        }
+        if(pmic_i2c < 0 || pmic_i2c > 3){
+                CONFIG_ERR(pmic_i2c, "pmic_i2c");
+                return -EINVAL;
+        }
+        if(pmic_addr < 0 || pmic_addr > 0x7f){
+                CONFIG_ERR(pmic_i2c, "pmic_addr");
+                return -EINVAL;
+        }
+
+        g_pmic_type = pmic_type;
+
+        return 0;
+}
+/* ion */
+static uint ion_size = DEF_ION_SIZE; 
+module_param(ion_size, uint, 0644);
+
+static inline int check_ion_param(void)
+{
+        return 0;
+}
+/* codec */
+static int spk_ctl = DEF_SPK_CTL;
+module_param(spk_ctl, int, 0644);
+static int hp_det = DEF_HP_DET;
+module_param(hp_det, int, 0644);
+static inline int check_codec_param(void)
+{
+        return 0;
+}
+/* sdmmc */
+static int sd_det = -1;
+module_param(sd_det, int, 0644);
+static inline int check_sdmmc_param(void)
+{
+        return 0;
+}
+/* wifi */
+static int wifi_rst = DEF_WIFI_RST;
+module_param(wifi_rst, int, 0644);
+static int wifi_pwr = DEF_WIFI_PWR;
+module_param(wifi_pwr, int, 0644);
+static uint wifi_type = DEF_WIFI_TYPE;
+module_param(wifi_type, uint, 0644);
+static inline int check_wifi_param(void)
+{
+        if(wifi_type != WIFI_NONE){
+                if(wifi_type <= WIFI_USB_NONE || wifi_type >= WIFI_USB_MAX || wifi_type <= WIFI_SDIO_NONE || wifi_type >= WIFI_SDIO_MAX){
+                        CONFIG_ERR(wifi_type, "wifi_type");
+                        return -EINVAL;
+                }
+        }
+
+        return 0;
+        
+}
+/* rtc */
+static int rtc_i2c = DEF_RTC_I2C;
+module_param(rtc_i2c, int, 0644);
+static int rtc_addr = DEF_RTC_ADDR;
+module_param(rtc_addr, int, 0644);
+static int rtc_irq = DEF_RTC_IRQ;
+module_param(rtc_irq, int, 0644);
+static inline int check_rtc_param(void)
+{
+        if(rtc_i2c < 0 || rtc_i2c > 3){
+                CONFIG_ERR(rtc_i2c, "rtc_i2c");
+                return -EINVAL;
+        }
+        if(rtc_addr < 0 || rtc_addr > 0x7f){
+                CONFIG_ERR(rtc_i2c, "rtc_addr");
+                return -EINVAL;
+        }
+        return 0;
+}
+
+/* charge */
+static int chg_adc = DEF_CHG_ADC;
+module_param(chg_adc, int, 0644);
+
+static int dc_det = -1;
+module_param(dc_det, int, 0644);
+static int bat_low = -1;
+module_param(bat_low, int, 0644);
+static int chg_ok = -1;
+module_param(chg_ok, int, 0644);
+static int chg_set = -1;
+module_param(chg_set, int, 0644);
+static int chg_sel = -1;
+module_param(chg_sel, int, 0644);
+static inline int check_charge_param(void)
+{
+        return 0;
+}
+
+/* dvfs */
+static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
+#if defined(RK2926_TB_DEFAULT_CONFIG)
+        {.frequency = 216 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 312 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 408 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 504 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 600 * 1000, .cpu_volt = 1250 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 696 * 1000, .cpu_volt = 1350 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 816 * 1000, .cpu_volt = 1400 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 912 * 1000, .cpu_volt = 1450 * 1000, .logic_volt = 1200 * 1000},
+        {.frequency = 1008 * 1000,.cpu_volt = 1500 * 1000, .logic_volt = 1200 * 1000},
+#else
+	{ .frequency = 216 * 1000, .cpu_volt = 850 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 312 * 1000, .cpu_volt = 900 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 408 * 1000, .cpu_volt = 950 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 504 * 1000, .cpu_volt = 1000 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 600 * 1000, .cpu_volt = 1100 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 696 * 1000, .cpu_volt = 1175 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 816 * 1000, .cpu_volt = 1250 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency = 912 * 1000, .cpu_volt = 1350 * 1000, .logic_volt = 1200 * 1000 },
+	{ .frequency =1008 * 1000, .cpu_volt = 1450 * 1000, .logic_volt = 1200 * 1000 },
+#endif
+	{ .frequency = CPUFREQ_TABLE_END },
+};
+static unsigned int dvfs_cpu_logic[ARRAY_SIZE(dvfs_cpu_logic_table) * 3];
+static unsigned int dvfs_cpu_logic_num;
+module_param_array(dvfs_cpu_logic, uint, &dvfs_cpu_logic_num, 0400);
+
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{ .frequency = 266 * 1000, .index = 1050 * 1000 },
+	{ .frequency = 400 * 1000, .index = 1275 * 1000 },
+	{ .frequency = CPUFREQ_TABLE_END },
+};
+static unsigned int dvfs_gpu[ARRAY_SIZE(dvfs_gpu_table) * 2];
+static unsigned int dvfs_gpu_num;
+module_param_array(dvfs_gpu, uint, &dvfs_gpu_num, 0400);
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 300 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1125 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+static unsigned int dvfs_ddr[ARRAY_SIZE(dvfs_ddr_table) * 2];
+static unsigned int dvfs_ddr_num;
+module_param_array(dvfs_ddr, uint, &dvfs_ddr_num, 0400);
+
+
+/* global */
+static int pwr_on = DEF_PWR_ON;
+module_param(pwr_on, int, 0644);
+
+static inline int rk2928_power_on(void)
+{
+        return port_output_init(pwr_on, 1, "pwr_on");
+}
+static inline void rk2928_power_off(void)
+{
+        port_output_off(pwr_on);
+        port_deinit(pwr_on);
+}
diff --git a/arch/arm/mach-rk2928/board-rk2928-key.c b/arch/arm/mach-rk2928/board-rk2928-key.c
new file mode 100755
index 000000000000..8f494c93e793
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-key.c
@@ -0,0 +1,65 @@
+#include <mach/gpio.h>
+#include <plat/key.h>
+
+#define EV_ENCALL				KEY_F4
+#define EV_MENU					KEY_F1
+
+#define PRESS_LEV_LOW			1
+#define PRESS_LEV_HIGH			0
+
+static struct rk29_keys_button key_button[] = {
+	{
+		.desc	= "play",
+		.code	= KEY_POWER,
+		.wakeup	= 1,
+	},
+	{
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEDOWN,
+	},
+	{
+		.desc	= "vol+",
+		.code	= KEY_VOLUMEUP,
+	},
+	{
+		.desc	= "menu",
+		.code	= EV_MENU,
+	},
+	{
+		.desc	= "esc",
+		.code	= KEY_BACK,
+	},
+	{
+		.desc	= "home",
+		.code	= KEY_HOME,
+	},
+	{
+		.desc	= "camera",
+		.code	= KEY_CAMERA,
+	},
+};
+struct rk29_keys_platform_data rk29_keys_pdata = {
+	.buttons	= key_button,
+	.chn	= -1,  //chn: 0-7, if do not use ADC,set 'chn' -1
+};
+static int __init key_board_init(void)
+{
+        int i;
+        struct port_config port;
+
+        for(i = 0; i < key_val_size; i++){
+                if(key_val[i] & (1<<31)){
+                        key_button[i].adc_value = key_val[i] & 0xffff;
+                        key_button[i].gpio = INVALID_GPIO;
+                }else{
+                        port = get_port_config(key_val[i]);
+                        key_button[i].gpio = port.gpio;
+                        key_button[i].active_low = port.io.active_low;
+                }
+        }
+        rk29_keys_pdata.nbuttons = key_val_size;
+        rk29_keys_pdata.chn = key_adc;
+
+        return 0;
+}
+
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
index d64688fff922..2db393e157cd 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
@@ -63,7 +63,11 @@ int tps65910_pre_init(struct tps65910 *tps65910){
 	int err = -1;
 		
 	printk("%s,line=%d\n", __func__,__LINE__);	
+#ifdef CONFIG_RK_CONFIG
+        if(sram_gpio_init(get_port_config(pmic_slp).gpio, &pmic_sleep) < 0){
+#else
         if(sram_gpio_init(PMU_POWER_SLEEP, &pmic_sleep) < 0){
+#endif
                 printk(KERN_ERR "PMU_POWER_SLEEP is invalid gpio\n");
                 return -EINVAL;
         }
diff --git a/arch/arm/mach-rk2928/board-rk2928.c b/arch/arm/mach-rk2928/board-rk2928.c
index eb919103866f..f8a2ea665b5d 100755
--- a/arch/arm/mach-rk2928/board-rk2928.c
+++ b/arch/arm/mach-rk2928/board-rk2928.c
@@ -48,6 +48,9 @@
 #include <linux/mfd/tps65910.h>
 #include <linux/regulator/act8931.h>
 #include <linux/regulator/rk29-pwm-regulator.h>
+
+#include "board-rk2928-config.c" 
+
 #if defined(CONFIG_HDMI_RK30)
 	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
 #endif
@@ -56,10 +59,9 @@
 #include "../../../drivers/spi/rk29_spim.h"
 #endif
 
-#include "board-rk2928-a720-camera.c" 
-#include "board-rk2928-a720-key.c"
+#include "board-rk2928-sdk-camera.c" 
+#include "board-rk2928-key.c"
 
-int __sramdata g_pmic_type =  0;
 
 #ifdef  CONFIG_THREE_FB_BUFFER
 #define RK30_FB0_MEM_SIZE 12*SZ_1M
@@ -74,93 +76,66 @@ static struct spi_board_info board_spi_devices[] = {
 *	rk30  backlight
 ************************************************************/
 #ifdef CONFIG_BACKLIGHT_RK29_BL
-#define PWM_ID            0
-#define PWM_MUX_NAME      GPIO0D2_PWM_0_NAME
-#define PWM_MUX_MODE      GPIO0D_PWM_0
-#define PWM_MUX_MODE_GPIO GPIO0D_GPIO0D2
-#define PWM_GPIO 	  RK2928_PIN0_PD2
-#define PWM_EFFECT_VALUE  0
-
-#define LCD_DISP_ON_PIN
-
-#ifdef  LCD_DISP_ON_PIN
-
-#define BL_EN_PIN         RK2928_PIN1_PB0
-#define BL_EN_VALUE       GPIO_HIGH
-#endif
 static int rk29_backlight_io_init(void)
 {
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
-	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+        int ret = 0;
+        struct pwm_io_config *cfg = &pwm_cfg[bl_pwm];
 
-	ret = gpio_request(BL_EN_PIN, NULL);
-	if (ret != 0) {
-		gpio_free(BL_EN_PIN);
-	}
+        ret = gpio_request(cfg->gpio, "bl_pwm");
+        if(ret < 0){
+                printk("%s: request gpio(bl_pwm) failed\n", __func__);
+                return ret;
+        }
+        rk30_mux_api_set(cfg->mux_name, cfg->pwm_mode);
+
+        if(bl_en == -1)
+                return 0;
+        ret = port_output_init(bl_en, 0, "bl_en");
+        if(ret < 0){
+                printk("%s: port output init faild\n", __func__);
+                return ret;
+        }
+        port_output_on(bl_en);
 
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
-	return ret;
+        return 0;
 }
-
 static int rk29_backlight_io_deinit(void)
 {
-	int ret = 0;
-#ifdef  LCD_DISP_ON_PIN
-	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
-	gpio_free(BL_EN_PIN);
-#endif
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	return ret;
+        struct pwm_io_config *cfg = &pwm_cfg[bl_pwm];
+
+        port_output_off(bl_en);
+        if(bl_en != -1)
+                port_deinit(bl_en);
+        rk30_mux_api_set(cfg->mux_name, cfg->io_mode);
+        gpio_free(cfg->gpio);
+
+        return 0;
 }
 
 static int rk29_backlight_pwm_suspend(void)
 {
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	if (gpio_request(PWM_GPIO, NULL)) {
-		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
-		return -1;
-	}
-	#if defined(CONFIG_MFD_TPS65910)	
-	if(pmic_is_tps65910())
-	{
-		gpio_direction_output(PWM_GPIO, GPIO_LOW);
-	}
-	#endif
-	#if defined(CONFIG_REGULATOR_ACT8931)
-	if(pmic_is_act8931())
-	{
-		gpio_direction_output(PWM_GPIO, GPIO_HIGH);
-	}
-	#endif
-#ifdef  LCD_DISP_ON_PIN
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
-#endif
+        struct pwm_io_config *cfg = &pwm_cfg[bl_pwm];
 
-	return ret;
+        rk30_mux_api_set(cfg->mux_name, cfg->io_mode);
+
+	gpio_direction_output(cfg->gpio, GPIO_HIGH);
+
+        port_output_off(bl_en);
+
+	return 0;
 }
 
 static int rk29_backlight_pwm_resume(void)
 {
-	gpio_free(PWM_GPIO);
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
+        struct pwm_io_config *cfg = &pwm_cfg[bl_pwm];
+
+        rk30_mux_api_set(cfg->mux_name, cfg->pwm_mode);
 	msleep(30);
-	gpio_direction_output(BL_EN_PIN, 1);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
+        port_output_on(bl_en);
 	return 0;
 }
 
 static struct rk29_bl_info rk29_bl_info = {
-	.pwm_id = PWM_ID,
-        .min_brightness = 80,
-	.bl_ref = PWM_EFFECT_VALUE,
 	.io_init = rk29_backlight_io_init,
 	.io_deinit = rk29_backlight_io_deinit,
 	.pwm_suspend = rk29_backlight_pwm_suspend,
@@ -175,66 +150,56 @@ static struct platform_device rk29_device_backlight = {
 	}
 };
 
-#endif
+static int __init bl_board_init(void)
+{
+        int ret = check_bl_param();
 
-#ifdef CONFIG_FB_ROCKCHIP
+        if(ret < 0)
+                return ret;
 
-#define LCD_MUX_NAME  GPIO0C2_UART0_RTSN_NAME
-#define LCD_GPIO_MODE GPIO0C_GPIO0C2
+        rk29_bl_info.pwm_id = bl_pwm;
+        rk29_bl_info.bl_ref = bl_ref;
+        rk29_bl_info.min_brightness = bl_min;
 
-#define LCD_EN        RK2928_PIN0_PC2
-#define LCD_EN_VALUE  GPIO_LOW
+        return 0;
+}
 
+#else
+static int __init bl_board_init(void)
+{
+        return 0;
+}
+#endif
+
+#ifdef CONFIG_FB_ROCKCHIP
 static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
 {
 	int ret = 0;
 
-        rk30_mux_api_set(LCD_MUX_NAME, LCD_GPIO_MODE);
+        if(lcd_cabc != -1){
+                ret = port_output_init(lcd_en, 0, "lcd_cabc");
+                if(ret < 0)
+                        printk("%s: port output init faild\n", __func__);
+        }
+        if(lcd_en == -1)
+                return 0;
+        ret = port_output_init(lcd_en, 1, "lcd_en");
+        if(ret < 0)
+                printk("%s: port output init faild\n", __func__);
 
-	ret = gpio_request(LCD_EN, NULL);
-	if (ret != 0)
-	{
-		gpio_free(LCD_EN);
-		printk(KERN_ERR "request lcd en pin fail!\n");
-		return -1;
-	}
-	else
-	{
-		gpio_direction_output(LCD_EN, LCD_EN_VALUE); //disable
-	}
-	return 0;
+	return ret;
 }
 static int rk_fb_io_disable(void)
 {
+        if(lcd_en != -1)
+                port_output_off(lcd_en);
 
-	#if 0//defined(CONFIG_REGULATOR_ACT8931)
-	if(pmic_is_act8931())
-	{
-		struct regulator *ldo;
-		ldo = regulator_get(NULL, "act_ldo4");	 //vcc_lcd
-		regulator_disable(ldo);
-		regulator_put(ldo);
-		udelay(100);
-	}
-	#endif
-        gpio_set_value(LCD_EN, !LCD_EN_VALUE);
 	return 0;
 }
 static int rk_fb_io_enable(void)
 {
-	#if 0//defined(CONFIG_REGULATOR_ACT8931)
-	if(pmic_is_act8931())
-	{
-		struct regulator *ldo;
-		ldo = regulator_get(NULL, "act_ldo4");	 //vcc_lcd
-		regulator_enable(ldo);
-		regulator_put(ldo);
-		udelay(100);
-		msleep(300);	// wait for powering on LED circuit
-	}
-	#endif
-
-        gpio_set_value(LCD_EN, LCD_EN_VALUE);
+        if(lcd_en != -1)
+                port_output_on(lcd_en);
 	return 0;
 }
 
@@ -275,6 +240,16 @@ static struct platform_device device_fb = {
 	.num_resources	= ARRAY_SIZE(resource_fb),
 	.resource	= resource_fb,
 };
+
+static int __init lcd_board_init(void)
+{
+        return check_lcd_param();
+}
+#else
+static int __init lcd_board_init(void)
+{
+        return 0;
+}
 #endif
 
 //LCDC
@@ -307,7 +282,6 @@ static struct platform_device device_lcdc = {
 #endif
 
 #ifdef CONFIG_ION
-#define ION_RESERVE_SIZE        (80 * SZ_1M)
 static struct ion_platform_data rk30_ion_pdata = {
 	.nr = 1,
 	.heaps = {
@@ -315,7 +289,6 @@ static struct ion_platform_data rk30_ion_pdata = {
 			.type = ION_HEAP_TYPE_CARVEOUT,
 			.id = ION_NOR_HEAP_ID,
 			.name = "norheap",
-			.size = ION_RESERVE_SIZE,
 		}
 	},
 };
@@ -327,67 +300,23 @@ static struct platform_device device_ion = {
 		.platform_data = &rk30_ion_pdata,
 	},
 };
-#endif
-
-
-#if defined(CONFIG_TOUCHSCREEN_SITRONIX_A720)
-
-#define TOUCH_RESET_PIN	 RK2928_PIN1_PA3
-#define TOUCH_INT_PIN 	 RK2928_PIN1_PB3
-int ft5306_init_platform_hw(void)
+static int __init ion_board_init(void)
 {
+        int ret = check_ion_param();
 
-        //printk("ft5306_init_platform_hw\n");
-        if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
-                gpio_free(TOUCH_RESET_PIN);
-                printk("ft5306_init_platform_hw gpio_request error\n");
-                return -EIO;
-        }
+        if(ret < 0)
+                return ret;
+        rk30_ion_pdata.heaps[0].size = ion_size;
 
-        if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
-                gpio_free(TOUCH_INT_PIN);
-                printk("ift5306_init_platform_hw gpio_request error\n");
-                return -EIO;
-        }
-        gpio_direction_output(TOUCH_RESET_PIN, GPIO_HIGH);
-        mdelay(10);
-        gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
-        mdelay(10);
-        gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
-        msleep(300);
         return 0;
-
 }
-
-struct ft5x0x_platform_data sitronix_info = {
-        .model = 5007,
-        .init_platform_hw= ft5306_init_platform_hw,
-};
-
-#endif
-
-
-/*MMA7660 gsensor*/
-#if defined (CONFIG_GS_MMA7660)
-#define MMA7660_INT_PIN   RK2928_PIN1_PB1
-
-static int mma7660_init_platform_hw(void)
+#else
+static int __init ion_board_init(void)
 {
-	rk30_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_GPIO1B1);
-
-	return 0;
+        return 0;
 }
-
-static struct sensor_platform_data mma7660_info = {
-	.type = SENSOR_TYPE_ACCEL,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-        .init_platform_hw = mma7660_init_platform_hw,
-        .orientation = {-1, 0, 0, 0, 0, -1, 0, 1, 0},
-};
 #endif
 
-
 #if CONFIG_RK30_PWM_REGULATOR
 static int pwm_voltage_map[] = {
 	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
@@ -416,11 +345,6 @@ struct regulator_init_data pwm_regulator_init_dcdc[1] =
 
 static struct pwm_platform_data pwm_regulator_info[1] = {
 	{
-		.pwm_id = 2,
-		.pwm_gpio = RK2928_PIN0_PD4,
-		.pwm_iomux_name = GPIO0D4_PWM_2_NAME,
-		.pwm_iomux_pwm = GPIO0D_PWM_2, 
-		.pwm_iomux_gpio = GPIO0D_GPIO0D4,
 		.pwm_voltage = 1200000,
 		.suspend_voltage = 1050000,
 		.min_uV = 1000000,
@@ -440,16 +364,38 @@ struct platform_device pwm_regulator_device[1] = {
 		}
 	},
 };
-#endif
 
+static int __init pwm_reg_board_init(void)
+{
+        struct pwm_io_config *cfg;
+        int ret = check_reg_pwm_param();
+
+        if(ret < 0)
+                return ret;
+
+        cfg = &pwm_cfg[reg_pwm];
+        pwm_regulator_info[0].pwm_id = reg_pwm;
+        pwm_regulator_info[0].pwm_iomux_name = cfg->mux_name;
+        pwm_regulator_info[0].pwm_iomux_pwm = cfg->pwm_mode;
+        pwm_regulator_info[0].pwm_iomux_gpio = cfg->io_mode;
+        pwm_regulator_info[0].pwm_gpio = cfg->gpio;
+
+        return 0;
+}
+#else
+static int __init pwm_reg_board_init(void)
+{
+        return 0;
+}
+#endif
 /***********************************************************
 *	usb wifi
 ************************************************************/
 #if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
-
 static void rkusb_wifi_power(int on) {
 	struct regulator *ldo = NULL;
 	
+#ifndef RK2926_TB_DEFAULT_CONFIG
 #if defined(CONFIG_MFD_TPS65910)	
 	if(pmic_is_tps65910()) {
 		ldo = regulator_get(NULL, "vmmc");  //vccio_wl
@@ -471,8 +417,8 @@ static void rkusb_wifi_power(int on) {
 	
 	regulator_put(ldo);
 	udelay(100);
+#endif
 }
-
 #endif
 
 /**************************************************************************************************
@@ -491,6 +437,10 @@ static void rkusb_wifi_power(int on) {
 
 #define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK2928_PIN0_PB2
 
+#define RK29SDK_SD_CARD_DETECT_N        RK2928_PIN2_PA7  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL    GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+
+
 #endif //endif ---#ifdef CONFIG_SDMMC_RK29
 
 #ifdef CONFIG_SDMMC0_RK29
@@ -498,7 +448,13 @@ static int rk29_sdmmc0_cfg_gpio(void)
 {
 	rk29_sdmmc_set_iomux(0, 0xFFFF);
 
+#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+    rk30_mux_api_set(GPIO1C1_MMC0_DETN_NAME, GPIO1C_GPIO1C1);
+   // gpio_request(RK29SDK_SD_CARD_DETECT_N, "sd-detect");
+   // gpio_direction_output(RK29SDK_SD_CARD_DETECT_N,GPIO_HIGH);//set mmc0-data1 to high.
+#else
 	rk30_mux_api_set(GPIO1C1_MMC0_DETN_NAME, GPIO1C_MMC0_DETN);
+#endif	
 
 #if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
 	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
@@ -528,7 +484,14 @@ struct rk29_sdmmc_platform_data default_sdmmc0_data = {
 #else
 	.use_dma = 0,
 #endif
-	.detect_irq = RK2928_PIN1_PC1,	// INVALID_GPIO
+
+#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+    .detect_irq = RK29SDK_SD_CARD_DETECT_N,
+    .insert_card_level = RK29SDK_SD_CARD_INSERT_LEVEL,
+#else
+	.detect_irq = INVALID_GPIO,
+#endif
+
 	.enable_sd_wakeup = 0,
 
 #if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
@@ -539,6 +502,29 @@ struct rk29_sdmmc_platform_data default_sdmmc0_data = {
 };
 #endif // CONFIG_SDMMC0_RK29
 
+#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+static int __init sdmmc_board_init(void)
+{
+        struct port_config port;
+        int ret = check_sdmmc_param();
+
+        if(ret < 0)
+                return ret;
+        if(sd_det == -1)
+                return 0;
+        port = get_port_config(sd_det);
+
+        default_sdmmc0_data.detect_irq = port.gpio;
+        default_sdmmc0_data.insert_card_level = !port.io.active_low;
+        return 0;
+}
+#else
+static int __init sdmmc_board_init(void)
+{
+        return 0;
+}
+#endif
+
 #ifdef CONFIG_SND_SOC_RK2928
 static struct resource resources_acodec[] = {
 	{
@@ -547,8 +533,6 @@ static struct resource resources_acodec[] = {
 		.flags 	= IORESOURCE_MEM,
 	},
 	{
-		.start	= RK2928_PIN1_PA0,
-		.end	= RK2928_PIN1_PA0,
 		.flags	= IORESOURCE_IO,
 	},
 };
@@ -559,6 +543,77 @@ static struct platform_device device_acodec = {
 	.num_resources	= ARRAY_SIZE(resources_acodec),
 	.resource	= resources_acodec,
 };
+
+static int __init codec_board_init(void)
+{
+        int gpio;
+        int ret = check_codec_param();
+
+        if(ret < 0)
+                return ret;
+        gpio = get_port_config(spk_ctl).gpio;
+        resources_acodec[1].start = gpio;
+        resources_acodec[1].end = gpio;
+        return 0;
+}
+#else
+static int __init codec_board_init(void)
+{
+        return 0;
+}
+#endif
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+#if defined(CONFIG_REGULATOR_ACT8931)
+extern  int act8931_charge_det;
+extern  int act8931_charge_ok;
+
+int rk30_battery_adc_io_init(void){
+	int ret = 0;
+		
+        if(dc_det == -1)
+                return 0;
+
+        ret = port_input_init(dc_det, "dc_det");
+    	if (ret) {
+                printk("%s: port(%d) input init faild\n", __func__, dc_det);
+    		return ret ;
+    	}
+
+	return 0;
+}
+
+int rk30_battery_adc_is_dc_charging( ){
+        return  act8931_charge_det  ;  
+}
+int rk30_battery_adc_charging_ok( ){
+       return act8931_charge_ok ;
+}
+#endif
+
+static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
+        .dc_det_pin      = INVALID_GPIO,
+        .batt_low_pin    = INVALID_GPIO,
+        .charge_set_pin  = INVALID_GPIO,
+        .charge_ok_pin   = INVALID_GPIO,
+        
+        //.io_init = rk30_battery_adc_io_init,
+        #if defined(CONFIG_REGULATOR_ACT8931)
+        .is_dc_charging  = rk30_battery_adc_is_dc_charging,
+	.charging_ok     = rk30_battery_adc_charging_ok ,
+        #endif
+        
+        .charging_sleep   = 0 ,
+        .save_capacity   = 1 ,
+        .adc_channel      = 0 ,
+};
+
+static struct platform_device rk30_device_adc_battery = {
+        .name   = "rk30-battery",
+        .id     = -1,
+        .dev = {
+                .platform_data = &rk30_adc_battery_platdata,
+        },
+};
 #endif
 
 static struct platform_device *devices[] __initdata = {
@@ -577,73 +632,85 @@ static struct platform_device *devices[] __initdata = {
 #ifdef CONFIG_SND_SOC_RK2928
 	&device_acodec,
 #endif
-};
-//i2c
-#ifdef CONFIG_I2C0_RK30
-#ifdef CONFIG_MFD_TPS65910
-#define TPS65910_HOST_IRQ        RK2928_PIN1_PB2
-#include "board-rk2928-a720-tps65910.c"
-#endif
-#ifdef CONFIG_REGULATOR_ACT8931
-#include "board-rk2928-sdk-act8931.c"
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+	&rk30_device_adc_battery,
 #endif
+};
 
-static struct i2c_board_info __initdata i2c0_info[] = {
-#if defined (CONFIG_MFD_TPS65910)
-	{
-        .type           = "tps65910",
-        .addr           = TPS65910_I2C_ID0,
-        .flags          = 0,
-        .irq            = TPS65910_HOST_IRQ,
-    	.platform_data = &tps65910_data,
-	},
-#endif
-#if defined (CONFIG_REGULATOR_ACT8931)
-	{
-		.type    		= "act8931",
-		.addr           = 0x5b, 
-		.flags			= 0,
-		.platform_data=&act8931_data,
-	},
-#endif
+#if defined (CONFIG_MFD_TPS65910) && defined (CONFIG_REGULATOR_ACT8931)
+#define TPS65910_HOST_IRQ INVALID_GPIO
 
+#include "board-rk2928-sdk-tps65910.c"
+#include "board-rk2928-sdk-act8931.c"
+static struct i2c_board_info __initdata pmic_info = {
+        .flags = 0,
 };
-#endif
+static int __init pmic_board_init(void)
+{
+        int ret = 0;
+        struct port_config port;
+
+        ret = check_pmic_param();
+        if(ret < 0)
+                return ret;
+        if(pmic_irq != -1){
+                port = get_port_config(pmic_irq);
+                pmic_info.irq = port.gpio;
+        }
+        if(pmic_type == PMIC_TYPE_TPS65910){
+                strcpy(pmic_info.type, "tps65910");
+                pmic_info.platform_data = &tps65910_data;
 
-int __sramdata gpio0d4_iomux,gpio0d4_do,gpio0d4_dir;
+                tps65910_data.irq = port.gpio;
+        }
+        if(pmic_type == PMIC_TYPE_ACT8931){
+                strcpy(pmic_info.type, "act8931");
+                pmic_info.platform_data = &act8931_data;
+        }
+        pmic_info.addr = pmic_addr;
+	i2c_register_board_info(pmic_i2c, &pmic_info, 1);
 
-#ifndef gpio_readl
-#define gpio_readl(offset)	readl_relaxed(RK2928_GPIO0_BASE + offset)
-#define gpio_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO0_BASE + offset); dsb(); } while (0)
+        return 0;
+}
+#else
+static int __init pmic_board_init(void)
+{
+        return 0;
+}
 #endif
 
+#define GPIO_SWPORTA_DR   0x0000
+#define GPIO_SWPORTA_DDR  0x0004
+#define PWM_MUX_REG       (GRF_GPIO0D_IOMUX)
+#define PWM_DDR_REG       (RK2928_GPIO0_BASE + GPIO_SWPORTA_DDR)
+#define PWM_DR_REG        (RK2928_GPIO0_BASE + GPIO_SWPORTA_DR)
+
+#define mux_set_gpio_mode(id)  do { writel_relaxed( 1 << (20 + (id) * 2), PWM_MUX_REG); dsb(); } while (0)
+#define mux_set_pwm_mode(id)  do { writel_relaxed( (1 << (20 + (id) * 2)) | (1 << (4 + (id) * 2)), PWM_MUX_REG); dsb(); } while (0)
+
+#define pwm_output_high(id) do {\
+                                writel_relaxed(readl_relaxed(PWM_DDR_REG) | (1 << (26 + (id))), PWM_DDR_REG); \
+                                writel_relaxed(readl_relaxed(PWM_DR_REG) | (1 << (26 + (id))), PWM_DR_REG); \
+                                dsb(); \
+                                } while (0)
+
 void __sramfunc rk30_pwm_logic_suspend_voltage(void)
 {
 #ifdef CONFIG_RK30_PWM_REGULATOR
 
-//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
 	sram_udelay(10000);
-	gpio0d4_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
-	gpio0d4_do = gpio_readl(GPIO_SWPORTA_DR);
-	gpio0d4_dir = gpio_readl(GPIO_SWPORTA_DDR);
-
-	writel_relaxed((gpio0d4_iomux |(1<<24)) & (~(1<<8)), GRF_GPIO0D_IOMUX);
-	gpio_writel(gpio0d4_dir |(1<<28), GPIO_SWPORTA_DDR);
-	gpio_writel(gpio0d4_do |(1<<28), GPIO_SWPORTA_DR);
-	
+        mux_set_gpio_mode(reg_pwm);
+        pwm_output_high(reg_pwm);
 #endif 
 }
 void __sramfunc rk30_pwm_logic_resume_voltage(void)
 {
 #ifdef CONFIG_RK30_PWM_REGULATOR
-	writel_relaxed((1<<24)|gpio0d4_iomux, GRF_GPIO0D_IOMUX);
-	gpio_writel(gpio0d4_dir, GPIO_SWPORTA_DDR);
-	gpio_writel(gpio0d4_do, GPIO_SWPORTA_DR);
+        mux_set_pwm_mode(reg_pwm);
 	sram_udelay(10000);
-
 #endif
-
 }
+
 extern void pwm_suspend_voltage(void);
 extern void pwm_resume_voltage(void);
 void  rk30_pwm_suspend_voltage_set(void)
@@ -659,31 +726,17 @@ void  rk30_pwm_resume_voltage_set(void)
 #endif
 }
 
+//i2c
+#ifdef CONFIG_I2C0_RK30
+static struct i2c_board_info __initdata i2c0_info[] = {
+};
+#endif
 #ifdef CONFIG_I2C1_RK30
 static struct i2c_board_info __initdata i2c1_info[] = {
-#if defined (CONFIG_GS_MMA7660)
-		{
-			.type		= "gs_mma7660",
-			.addr		= 0x4c,
-			.flags		= 0,
-			.irq		= MMA7660_INT_PIN,
-			.platform_data = &mma7660_info,
-		},
-#endif
-
 };
 #endif
 #ifdef CONFIG_I2C2_RK30
 static struct i2c_board_info __initdata i2c2_info[] = {
-#if defined (CONFIG_TOUCHSCREEN_SITRONIX_A720)
-{
-        .type	        ="sitronix",
-	.addr           = 0x38,
-	.flags          = 0,
-	.irq            = TOUCH_INT_PIN,
-	.platform_data = &sitronix_info,
-},
-#endif
 };
 #endif
 #ifdef CONFIG_I2C3_RK30
@@ -730,10 +783,177 @@ static void __init rk30_i2c_register_board_info(void)
 }
 //end of i2c
 
-#define POWER_ON_PIN RK2928_PIN1_PA2   //power_hold
+/**************** gsensor ****************/
+// kxtik
+static int kxtik_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data kxtik_data = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+	.init_platform_hw = kxtik_init_platform_hw,
+};
+struct i2c_board_info __initdata kxtik_info = {
+        .type = "gs_kxtik",
+        .flags = 0,
+        .platform_data = &kxtik_data,
+};
+#if defined (CONFIG_GS_MMA8452)
+static int mma8452_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data mma8452_data = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma8452_init_platform_hw,
+};
+struct i2c_board_info __initdata mma8452_info = {
+        .type = "gs_mma8452",
+        .flags = 0,
+        .platform_data = &mma8452_data,
+};
+#endif
+#if defined (CONFIG_GS_MMA7660)
+static int mma7660_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data mma7660_data = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma7660_init_platform_hw,
+};
+struct i2c_board_info __initdata mma7660_info = {
+        .type = "gs_mma7660",
+        .flags = 0,
+        .platform_data = &mma7660_data,
+};
+#endif
+static int __init gs_board_init(void)
+{
+        int i;
+        struct port_config port;
+        int ret = check_gs_param();
+
+        if(ret < 0)
+                return ret;
+        port = get_port_config(gs_irq);
+        //kxtik
+        kxtik_info.irq = port.gpio;
+        kxtik_info.addr = gs_addr;
+        for(i = 0; i < 9; i++)
+                kxtik_data.orientation[i] = gs_orig[i];
+	i2c_register_board_info(gs_i2c, &kxtik_info, 1);
+        //mma7660
+#if defined (CONFIG_GS_MMA7660)
+        if(gs_type == GS_TYPE_MMA7660){
+                mma7660_info.irq = port.gpio;
+                mma7660_info.addr = gs_addr;
+                for(i = 0; i < 9; i++)
+                        mma7660_data.orientation[i] = gs_orig[i];
+	        i2c_register_board_info(gs_i2c, &mma7660_info, 1);
+        }
+#endif
+#if defined (CONFIG_GS_MMA8452)
+        if(gs_type == GS_TYPE_MMA8452){
+                mma8452_info.irq = port.gpio;
+                mma8452_info.addr = gs_addr;
+                for(i = 0; i < 9; i++)
+                        mma8452_data.orientation[i] = gs_orig[i];
+	        i2c_register_board_info(gs_i2c, &mma8452_info, 1);
+        }
+#endif
+        
+        return 0;
+}
+
+#if defined (CONFIG_RTC_HYM8563)
+struct i2c_board_info __initdata rtc_info = {
+        .type = "rtc_hym8563",
+        .flags = 0,
+};
+static int __init rtc_board_init(void)
+{
+        struct port_config port;
+        int ret;
+
+        if(pmic_type == PMIC_TYPE_TPS65910)
+                return 0;
+                
+        ret = check_rtc_param();
+        if(ret < 0)
+                return ret;
+        port = get_port_config(rtc_irq);
+        rtc_info.irq = port.gpio;
+        rtc_info.addr = rtc_addr;
+	i2c_register_board_info(rtc_i2c, &rtc_info, 1);
+        
+        return 0;
+}
+#else
+static int __init rtc_board_init(void)
+{
+        return 0;
+}
+#endif
+
+static int __init rk2928_config_init(void)
+{
+        int ret = 0;
+
+        ret = key_board_init();
+        if(ret < 0)
+                return ret;
+        ret = bl_board_init();
+        if(ret < 0)
+                return ret;
+        ret = lcd_board_init();
+        if(ret < 0)
+                return ret;
+        ret = ion_board_init();
+        if(ret < 0)
+                return ret;
+        ret = pwm_reg_board_init();
+        if(ret < 0)
+                return ret;
+        ret = gs_board_init();
+        if(ret < 0)
+                return ret;
+        ret = rtc_board_init();
+        if(ret < 0)
+                return ret;
+        ret = pmic_board_init();
+        if(ret < 0)
+                return ret;
+        ret = codec_board_init();
+        if(ret < 0)
+                return ret;
+        ret = sdmmc_board_init();
+        if(ret < 0)
+                return ret;
+        return 0;
+}
+#if defined(CONFIG_REGULATOR_ACT8931)
+extern  int act8931_charge_det;
+#endif
 static void rk2928_pm_power_off(void)
 {
 	printk(KERN_ERR "rk2928_pm_power_off start...\n");
+        #if defined(CONFIG_REGULATOR_ACT8931)
+        if(pmic_type == PMIC_TYPE_ACT8931)
+        {
+              if(act8931_charge_det)
+                   arm_pm_restart(0, NULL);
+        }
+        #endif
 	
 	#if defined(CONFIG_MFD_TPS65910)	
 	if(pmic_is_tps65910())
@@ -741,7 +961,7 @@ static void rk2928_pm_power_off(void)
 		tps65910_device_shutdown();//tps65910 shutdown
 	}
 	#endif
-	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+        rk2928_power_off();
 	
 };
 
@@ -752,42 +972,6 @@ static void rk2928_pm_power_off(void)
  * @logic_volt	: logic voltage arm requests depend on frequency
  * comments	: min arm/logic voltage
  */
-static struct dvfs_arm_table dvfs_cpu_logic_table[16] = {
-	{ .frequency = 216 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 312 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 408 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 504 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 600 * 1000, .cpu_volt = 1200 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 696 * 1000, .cpu_volt = 1400 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = 816 * 1000, .cpu_volt = 1400 * 1000, .logic_volt = 1200 * 1000 },
-//	{ .frequency = 912 * 1000, .cpu_volt = 1400 * 1000, .logic_volt = 1200 * 1000 },
-//	{ .frequency =1008 * 1000, .cpu_volt = 1400 * 1000, .logic_volt = 1200 * 1000 },
-	{ .frequency = CPUFREQ_TABLE_END },
-};
-static unsigned int dvfs_cpu_logic[ARRAY_SIZE(dvfs_cpu_logic_table) * 3];
-static unsigned int dvfs_cpu_logic_num;
-module_param_array(dvfs_cpu_logic, uint, &dvfs_cpu_logic_num, 0400);
-
-static struct cpufreq_frequency_table dvfs_gpu_table[4] = {
-	{ .frequency = 266 * 1000, .index = 1050 * 1000 },
-	{ .frequency = 400 * 1000, .index = 1275 * 1000 },
-	{ .frequency = CPUFREQ_TABLE_END },
-};
-static unsigned int dvfs_gpu[ARRAY_SIZE(dvfs_gpu_table) * 2];
-static unsigned int dvfs_gpu_num;
-module_param_array(dvfs_gpu, uint, &dvfs_gpu_num, 0400);
-
-#if 0
-static struct cpufreq_frequency_table dvfs_ddr_table[4] = {
-	{ .frequency = 300 * 1000, .index = 1050 * 1000 },
-	{ .frequency = 400 * 1000, .index = 1125 * 1000 },
-	{ .frequency = CPUFREQ_TABLE_END },
-};
-static unsigned int dvfs_ddr[ARRAY_SIZE(dvfs_ddr_table) * 2];
-static unsigned int dvfs_ddr_num;
-module_param_array(dvfs_ddr, uint, &dvfs_ddr_num, 0400);
-#endif
-
 #define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
 static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
 static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
@@ -829,22 +1013,22 @@ static noinline __init void board_init_dvfs(void)
 
 static void __init rk2928_board_init(void)
 {
-	gpio_request(POWER_ON_PIN, "poweronpin");
-	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+        rk2928_power_on();
+        rk2928_config_init();
  
 	pm_power_off = rk2928_pm_power_off;
 
 	board_init_dvfs();
+
 	rk30_i2c_register_board_info();
 	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 
 }
-
 static void __init rk2928_reserve(void)
 {
 #ifdef CONFIG_ION
-	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ion_size);
 #endif
 #ifdef CONFIG_FB_ROCKCHIP
 	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
diff --git a/arch/arm/mach-rk2928/include/mach/config.h b/arch/arm/mach-rk2928/include/mach/config.h
new file mode 100644
index 000000000000..c597f6e6b8c5
--- /dev/null
+++ b/arch/arm/mach-rk2928/include/mach/config.h
@@ -0,0 +1,228 @@
+#ifndef __MACH_CONFIG_H
+#define __MACH_CONFIG_H
+#include <mach/board.h>
+
+#define RK2926_TB_DEFAULT_CONFIG
+
+#if defined(RK2926_TB_DEFAULT_CONFIG)
+/* keyboard */
+enum{
+        DEF_KEY_ADC = 1,
+        DEF_PLAY_KEY = 0x000101a4,
+        DEF_VOLDN_KEY = 0x000102b4,
+        DEF_VOLUP_KEY = 1  | (1<<31),
+        DEF_MENU_KEY = 135 | (1<<31),
+        DEF_ESC_KEY = 334  | (1<<31),
+        DEF_HOME_KEY = 550 | (1<<31),
+        DEF_CAM_KEY = 700  | (1<<31),
+};
+/* backlight */
+enum{
+        DEF_BL_PWM = 0,
+        DEF_BL_REF = 1,
+        DEF_BL_MIN = 60,
+        DEF_BL_EN = 0x000002c1,
+};
+/* lcd */
+enum {
+        DEF_LCD_CABC = 0x000002c3,
+        DEF_LCD_EN = -1,
+        DEF_LCD_STD = -1,
+};
+
+#define DEF_LCD_PARAM {SCREEN_LVDS, OUT_D888_P666, \
+                        65000000, 30000000, \
+                        10, 100, 1024, 210, \
+                        10, 10, 768, 18, \
+                        202, 102, \
+                        1, 0 }
+/* gsensor */
+enum { 
+        GS_TYPE_NONE = 0,
+        GS_TYPE_MMA8452,
+        GS_TYPE_MMA7660,
+        GS_TYPE_MAX,
+};
+
+enum {
+        DEF_GS_TYPE = GS_TYPE_MMA8452,
+        DEF_GS_I2C = 0,
+        DEF_GS_ADDR = 0x1d,
+        DEF_GS_IRQ = 0x008001b2,
+        DEF_GS_PWR = -1,
+};
+#define DEF_GS_ORIG {-1, 0, 0, 0, 0, 1, 0,-1, 0}
+/* pwm regulator */
+enum {
+        DEF_REG_PWM = 1,
+};
+/* pmic */
+enum {
+        DEF_PMIC_TYPE = PMIC_TYPE_TPS65910,
+        DEF_PMIC_SLP = 0x000001a1,
+        DEF_PMIC_IRQ = 0x000001b1,
+        DEF_PMIC_I2C = 1,
+        DEF_PMIC_ADDR = 0x2d, 
+};
+/* ion */
+enum {
+        DEF_ION_SIZE = 80 * 1024 * 1024,
+};
+/* codec */
+enum {
+        DEF_SPK_CTL = 0x000001a0,
+        DEF_HP_DET = -1,
+};
+/* sdmmc */
+enum {
+        DEF_SD_DET = 0x000102a7,
+};
+/* wifi */
+enum {
+        WIFI_NONE = 0,
+        WIFI_USB_NONE = 1<<4,
+        //here: add usb wifi type
+        WIFI_USB_MAX,
+        WIFI_SDIO_NONE = 1<<8,
+        //here: add sdio wifi type
+        WIFI_SDIO_MAX,
+};
+
+enum {
+        DEF_WIFI_RST = -1,
+        DEF_WIFI_PWR = -1,
+        DEF_WIFI_TYPE = WIFI_NONE, 
+};
+/* rtc */
+enum {
+        DEF_RTC_I2C = 0,
+        DEF_RTC_ADDR = 0x51,
+        DEF_RTC_IRQ = -1,
+};
+/* charge */
+enum {
+        DEF_CHG_ADC = 0,
+        DEF_DC_DET = -1,
+        DEF_BAT_LOW = -1,
+        DEF_CHG_OK = -1,
+        DEF_CHG_SET = -1,
+        DEF_CHG_SEL = -1,
+};
+
+/* global */
+enum {
+        DEF_PWR_ON = 0x000001a2,
+};
+#else
+/* keyboard */
+enum{
+        DEF_KEY_ADC = -1,
+        DEF_PLAY_KEY = -1,
+        DEF_VOLDN_KEY = -1,
+        DEF_VOLUP_KEY = 0,
+        DEF_MENU_KEY = 0,
+        DEF_ESC_KEY = 0,
+        DEF_HOME_KEY = 0,
+        DEF_CAM_KEY = 0,
+};
+/* backlight */
+enum{
+        DEF_BL_PWM = -1,
+        DEF_BL_REF = 0,
+        DEF_BL_MIN = 0,
+        DEF_BL_EN = -1,
+};
+/* lcd */
+enum {
+        DEF_LCD_CABC = -1,
+        DEF_LCD_EN = -1,
+        DEF_LCD_STD = -1,
+};
+
+#define DEF_LCD_PARAM {0, 0, \
+                        0, 0, \
+                        0, 0, 0, 0, \
+                        0, 0, 0, 0, \
+                        0, 0, \
+                        0, 0 }
+/* gsensor */
+enum { 
+        GS_TYPE_NONE = 0,
+        GS_TYPE_MMA8452,
+        GS_TYPE_MMA7660,
+        GS_TYPE_MAX,
+};
+
+enum {
+        DEF_GS_TYPE = GS_TYPE_NONE,
+        DEF_GS_I2C = -1,
+        DEF_GS_ADDR = -1,
+        DEF_GS_IRQ = -1,
+        DEF_GS_PWR = -1,
+};
+#define DEF_GS_ORIG {0, 0, 0, 0, 0, 0, 0, 0, 0}
+/* pwm regulator */
+enum {
+        DEF_REG_PWM = -1,
+};
+/* pmic */
+enum {
+        DEF_PMIC_TYPE = PMIC_TYPE_NONE,
+        DEF_PMIC_SLP = -1,
+        DEF_PMIC_IRQ = -1,
+        DEF_PMIC_I2C = -1,
+        DEF_PMIC_ADDR = -1, 
+};
+/* ion */
+enum {
+        DEF_ION_SIZE = 80 * 1024 * 1024,
+};
+/* codec */
+enum {
+        DEF_SPK_CTL = -1,
+        DEF_HP_DET = -1,
+};
+/* sdmmc */
+enum {
+        DEF_SD_DET = -1,
+};
+/* wifi */
+enum {
+        WIFI_NONE = 0,
+        WIFI_USB_NONE = 1<<4,
+        //here: add usb wifi type
+        WIFI_USB_MAX,
+        WIFI_SDIO_NONE = 1<<8,
+        //here: add sdio wifi type
+        WIFI_SDIO_MAX,
+};
+
+enum {
+        DEF_WIFI_RST = -1,
+        DEF_WIFI_PWR = -1,
+        DEF_WIFI_TYPE = WIFI_NONE, 
+};
+/* rtc */
+enum {
+        DEF_RTC_I2C = -1,
+        DEF_RTC_ADDR = -1,
+        DEF_RTC_IRQ = -1,
+};
+/* charge */
+enum {
+        DEF_CHG_ADC = -1,
+        DEF_DC_DET = -1,
+        DEF_BAT_LOW = -1,
+        DEF_CHG_OK = -1,
+        DEF_CHG_SET = -1,
+        DEF_CHG_SEL = -1,
+};
+
+/* global */
+enum {
+        DEF_PWR_ON = -1,
+};
+
+#endif
+
+#endif
diff --git a/arch/arm/plat-rk/config.c b/arch/arm/plat-rk/config.c
index 50cc300c6c5f..d5cec84f7d8b 100644
--- a/arch/arm/plat-rk/config.c
+++ b/arch/arm/plat-rk/config.c
@@ -10,7 +10,10 @@ int port_output_init(unsigned int value, int on, char *name)
         ret = gpio_request(port.gpio, name);
         if(ret < 0)
                 return ret;
-        gpio_pull_updown(port.gpio, port.io.pull_mode);
+        if(port.io.pull_mode == PULL_MODE_DISABLE)
+                gpio_pull_updown(port.gpio, 0);
+        if(port.io.pull_mode == PULL_MODE_ENABLE)
+                gpio_pull_updown(port.gpio, 1);
         gpio_direction_output(port.gpio, (on)? !port.io.active_low: !!port.io.active_low);
 
         return 0;
@@ -49,7 +52,10 @@ int port_input_init(unsigned int value, char *name)
         ret = gpio_request(port.gpio, name);
         if(ret < 0)
                 return ret;
-        gpio_pull_updown(port.gpio, port.io.pull_mode);
+        if(port.io.pull_mode == PULL_MODE_DISABLE)
+                gpio_pull_updown(port.gpio, 0);
+        if(port.io.pull_mode == PULL_MODE_ENABLE)
+                gpio_pull_updown(port.gpio, 1);
         gpio_direction_input(port.gpio);
 
         return 0;
diff --git a/arch/arm/plat-rk/include/plat/board.h b/arch/arm/plat-rk/include/plat/board.h
index 0225079bb81d..7e6e65e4aff6 100755
--- a/arch/arm/plat-rk/include/plat/board.h
+++ b/arch/arm/plat-rk/include/plat/board.h
@@ -63,7 +63,7 @@ struct rk29_io_t {
 };
 
 enum {
-	PMIC_TYPE_NOE =0,
+	PMIC_TYPE_NONE =0,
 	PMIC_TYPE_WM8326 =1,
 	PMIC_TYPE_TPS65910 =2,
 	PMIC_TYPE_ACT8931 =3,
diff --git a/arch/arm/plat-rk/include/plat/gpio.h b/arch/arm/plat-rk/include/plat/gpio.h
index d9846f46d696..fea57db44d88 100644
--- a/arch/arm/plat-rk/include/plat/gpio.h
+++ b/arch/arm/plat-rk/include/plat/gpio.h
@@ -7,6 +7,11 @@
  * gpio = RKXX_PIN(bank)_P(goff)(off)
  * e.g.  bank=2, goff=A, off=3 ==>gpio is RKXX_PIN2_PA3
  */
+enum {
+        PULL_MODE_NONE = 0,
+        PULL_MODE_DISABLE,
+        PULL_MODE_ENABLE,
+};
 struct irq_config{
         unsigned int off:4,  //bit[3:0]
                      goff:4,
diff --git a/drivers/input/touchscreen/eeti_egalax_i2c.c b/drivers/input/touchscreen/eeti_egalax_i2c.c
index 1714f18157ed..9373d0b3ffcf 100755
--- a/drivers/input/touchscreen/eeti_egalax_i2c.c
+++ b/drivers/input/touchscreen/eeti_egalax_i2c.c
@@ -41,11 +41,67 @@
 #include <linux/irq.h>
 #include <linux/async.h>
 #include <mach/board.h>
+#include <mach/config.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 #endif
 
+#define TP_MODULE_NAME  "egalax_i2c"
+#ifdef CONFIG_RK_CONFIG
+
+enum {
+#ifdef RK2926_TB_DEFAULT_CONFIG
+        DEF_EN = 1,
+#else
+        DEF_EN = 0,
+#endif
+        DEF_IRQ = 0x008001b0,
+        DEF_RST = 0X000002b0,
+        DEF_I2C = 2, 
+        DEF_ADDR = 0x04,
+        DEF_X_MAX = 1087,
+        DEF_Y_MAX = 800,
+};
+static int en = DEF_EN;
+module_param(en, int, 0644);
+
+static int irq = DEF_IRQ;
+module_param(irq, int, 0644);
+static int rst =DEF_RST;
+module_param(rst, int, 0644);
+
+static int i2c = DEF_I2C;            // i2c channel
+module_param(i2c, int, 0644);
+static int addr = DEF_ADDR;           // i2c addr
+module_param(addr, int, 0644);
+static int x_max = DEF_X_MAX;
+module_param(x_max, int, 0644);
+static int y_max = DEF_Y_MAX;
+module_param(y_max, int, 0644);
+
+static int tp_hw_init(void)
+{
+        int ret = 0;
+
+        ret = gpio_request(get_port_config(irq).gpio, "tp_irq");
+        if(ret < 0){
+                printk("%s: gpio_request(irq gpio) failed\n", __func__);
+                return ret;
+        }
+
+        ret = port_output_init(rst, 0, "tp_rst");
+        if(ret < 0){
+                printk("%s: port(rst) output init faild\n", __func__);
+                return ret;
+        }
+        port_output_on(rst);
+
+         return 0;
+}
+#include "rk_tp.c"
+#endif
+
 //#define DEBUG
 #ifdef CONFIG_EETI_EGALAX_DEBUG
 	#define TS_DEBUG(fmt,args...)  printk( KERN_DEBUG "[egalax_i2c]: " fmt, ## args)
@@ -55,6 +111,7 @@
 	#define DBG()
 #endif
 
+
 //#define _NON_INPUT_DEV // define this to disable register input device	
 
 static int global_major = 0; // dynamic major by default 
@@ -416,8 +473,13 @@ static struct input_dev * allocate_Input_Dev(void)
 	__set_bit(EV_ABS, pInputDev->evbit);
 
 	input_mt_init_slots(pInputDev, MAX_SUPPORT_POINT);
+#ifdef CONFIG_RK_CONFIG
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_X, 0, x_max, 0, 0);
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_Y, 0, y_max, 0, 0);
+#else
 	input_set_abs_params(pInputDev, ABS_MT_POSITION_X, 0, CONFIG_EETI_EGALAX_MAX_X, 0, 0);
 	input_set_abs_params(pInputDev, ABS_MT_POSITION_Y, 0, CONFIG_EETI_EGALAX_MAX_Y, 0, 0);
+#endif
 	input_set_abs_params(pInputDev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
 
 	ret = input_register_device(pInputDev);
@@ -538,13 +600,13 @@ static irqreturn_t egalax_i2c_interrupt(int irq, void *dev_id)
 
 void egalax_i2c_set_standby(struct i2c_client *client, int enable)
 {
+#ifndef CONFIG_RK_CONFIG
         struct eeti_egalax_platform_data *mach_info = client->dev.platform_data;
 	unsigned display_on = mach_info->disp_on_pin;
 	unsigned lcd_standby = mach_info->standby_pin;
 
 	int display_on_pol = mach_info->disp_on_value;
 	int lcd_standby_pol = mach_info->standby_value;
-#ifndef CONFIG_ARCH_RK2928
         printk("%s : %s, enable = %d", __FILE__, __FUNCTION__,enable);
     if(display_on != INVALID_GPIO)
     {
@@ -652,10 +714,19 @@ static struct suspend_info suspend_info = {
 static int __devinit egalax_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	int ret;
-	int gpio = client->irq;
-	struct eeti_egalax_platform_data *pdata = pdata = client->dev.platform_data;
+	int gpio;
+#ifdef CONFIG_RK_CONFIG
+        struct port_config irq_cfg = get_port_config(irq);
 
+        client->irq = irq_cfg.gpio;
+        tp_hw_init();
+#else
+	struct eeti_egalax_platform_data *pdata = pdata = client->dev.platform_data;
+        if (pdata->init_platform_hw)
+		pdata->init_platform_hw();
+#endif
 	printk(KERN_DEBUG "[egalax_i2c]: start probe\n");
+        gpio = client->irq;
 
 	p_egalax_i2c_dev = (struct _egalax_i2c *)kzalloc(sizeof(struct _egalax_i2c), GFP_KERNEL);
 	if (!p_egalax_i2c_dev) 
@@ -677,8 +748,6 @@ static int __devinit egalax_i2c_probe(struct i2c_client *client, const struct i2
 	memset(PointBuf, 0, sizeof(struct point_data)*MAX_SUPPORT_POINT);
 #endif //#ifndef _NON_INPUT_DEV
 
-if (pdata->init_platform_hw)
-		pdata->init_platform_hw();
 
 	p_egalax_i2c_dev->client = client;
 	mutex_init(&p_egalax_i2c_dev->mutex_wq);
@@ -696,9 +765,13 @@ if (pdata->init_platform_hw)
 	p_egalax_i2c_dev->work_state = 1;
 	
 	p_egalax_i2c_dev->irq = gpio_to_irq(client->irq);
-	
+#ifdef CONFIG_RK_CONFIG
+	ret = request_irq(p_egalax_i2c_dev->irq, egalax_i2c_interrupt, irq_cfg.irq.irq_flags,
+		 client->name, p_egalax_i2c_dev);
+#else
 	ret = request_irq(p_egalax_i2c_dev->irq, egalax_i2c_interrupt, IRQF_TRIGGER_LOW,
 		 client->name, p_egalax_i2c_dev);
+#endif
 	if( ret ) 
 	{
 		printk(KERN_ERR "[egalax_i2c]: request irq(%d) failed\n", p_egalax_i2c_dev->irq);
@@ -772,7 +845,7 @@ static int __devexit egalax_i2c_remove(struct i2c_client *client)
 }
 
 static struct i2c_device_id egalax_i2c_idtable[] = { 
-	{ "egalax_i2c", 0 }, 
+	{ TP_MODULE_NAME, 0 }, 
 	{ } 
 }; 
 
@@ -780,7 +853,7 @@ MODULE_DEVICE_TABLE(i2c, egalax_i2c_idtable);
 
 static struct i2c_driver egalax_i2c_driver = {
 	.driver = {
-		.name 	= "egalax_i2c",
+		.name 	= TP_MODULE_NAME,
 	},
 	.id_table	= egalax_i2c_idtable,
 	.probe		= egalax_i2c_probe,
@@ -939,6 +1012,12 @@ static void __init egalax_i2c_ts_init_async(void *unused, async_cookie_t cookie)
 
 static int __init egalax_i2c_ts_init(void)
 {
+#ifdef CONFIG_RK_CONFIG
+        int ret = tp_board_init();
+
+        if(ret < 0)
+                return ret;
+#endif
 	async_schedule(egalax_i2c_ts_init_async, NULL);
 	return 0;
 }
diff --git a/drivers/input/touchscreen/rk_tp.c b/drivers/input/touchscreen/rk_tp.c
new file mode 100755
index 000000000000..7dc8359ba2c3
--- /dev/null
+++ b/drivers/input/touchscreen/rk_tp.c
@@ -0,0 +1,37 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+
+
+static int check_tp_param(void)
+{
+        if(en == 0 || i2c == -1 || addr == -1 || x_max == -1 || y_max == -1){
+                printk("touchpad: en: %d, i2c: %d, addr: 0x%x, x_max: %d, y_max: %d\n",
+                                en, i2c, addr, x_max, y_max);
+                return -EINVAL;
+        }else{
+                return 0;
+        }
+}
+
+struct i2c_board_info __initdata tp_info = {
+        .type = TP_MODULE_NAME,
+        .flags = 0,
+};
+
+static int tp_board_init(void)
+{
+        int ret = 0;
+
+        ret = check_tp_param();
+        if(ret < 0)
+                return ret;
+
+        tp_info.addr = addr;
+        ret = i2c_add_device(i2c, &tp_info);
+
+        return ret;
+}
+
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index f482e78ac80a..f4e6c555804f 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -3,6 +3,9 @@ choice
 	prompt  "LCD Panel Select"
 config LCD_NULL
 	bool "NULL"
+config LCD_RK2928
+	bool "RK2928 LCD"
+        depends on MACH_RK2928
 config LCD_LG_LP097X02
 	bool "RGB LCD_LG_LP097X02 1024X768"
 config LCD_TD043MGEA1
@@ -109,7 +112,6 @@ config LCD_HSD07PFW1
 
 config LCD_I30_800X480
         bool "lcd I30"
-
 endchoice
 
 
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index 43e3c71dc5d6..5e25916477c5 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -1,5 +1,6 @@
 obj-$(CONFIG_LCD_NULL) += lcd_null.o
 
+obj-$(CONFIG_LCD_RK2928) += lcd_rk2928.o
 
 obj-$(CONFIG_LCD_TD043MGEA1) += lcd_td043mgea1.o
 obj-$(CONFIG_LCD_HSD070IDW1) += lcd_hsd800x480.o
diff --git a/drivers/video/display/screen/lcd_rk2928.c b/drivers/video/display/screen/lcd_rk2928.c
new file mode 100755
index 000000000000..92c09b11b707
--- /dev/null
+++ b/drivers/video/display/screen/lcd_rk2928.c
@@ -0,0 +1,78 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include <mach/config.h>
+#include "../../rockchip/hdmi/rk_hdmi.h"
+#include "screen.h"
+
+enum {
+        OUT_TYPE_INDEX = 0,
+        OUT_FACE_INDEX,
+        OUT_CLK_INDEX,
+        LCDC_ACLK_INDEX,
+        H_PW_INDEX,
+        H_BP_INDEX,
+        H_VD_INDEX,
+        H_FP_INDEX,
+        V_PW_INDEX,
+        V_BP_INDEX,
+        V_VD_INDEX,
+        V_FP_INDEX,
+        LCD_WIDTH_INDEX,
+        LCD_HEIGHT_INDEX,
+        DCLK_POL_INDEX,
+        SWAP_RB_INDEX,
+        LCD_PARAM_MAX,
+};
+uint lcd_param[LCD_PARAM_MAX] = DEF_LCD_PARAM;
+module_param_array(lcd_param, uint, NULL, 0644);
+
+#define set_scaler_info	 NULL
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+	/* screen type & face */
+	screen->type = lcd_param[OUT_TYPE_INDEX];
+	screen->face = lcd_param[OUT_FACE_INDEX];
+	screen->hw_format = 1;
+
+	/* Screen size */
+	screen->x_res = lcd_param[H_VD_INDEX];
+	screen->y_res = lcd_param[V_VD_INDEX];
+
+	screen->width = lcd_param[LCD_WIDTH_INDEX];
+	screen->height = lcd_param[LCD_HEIGHT_INDEX];
+
+	/* Timing */
+	screen->lcdc_aclk = lcd_param[LCDC_ACLK_INDEX];
+	screen->pixclock = lcd_param[OUT_CLK_INDEX];
+	screen->left_margin = lcd_param[H_BP_INDEX];
+	screen->right_margin = lcd_param[H_FP_INDEX];
+	screen->hsync_len = lcd_param[H_PW_INDEX];
+	screen->upper_margin = lcd_param[V_BP_INDEX];
+	screen->lower_margin = lcd_param[V_FP_INDEX];
+	screen->vsync_len = lcd_param[V_PW_INDEX];
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = lcd_param[DCLK_POL_INDEX];
+
+	/* Swap rule */
+	screen->swap_rb = lcd_param[SWAP_RB_INDEX];
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+}
+
+
+
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index efda1ac2943a..1ab21b6f1d11 100644
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -56,15 +56,15 @@
 ********************************************************************/
 /* */
 #define OUT_P888            0
-#define OUT_P666            1    //
-#define OUT_P565            2    //
+#define OUT_P666            1
+#define OUT_P565            2 
 #define OUT_S888x           4
 #define OUT_CCIR656         6
 #define OUT_S888            8
 #define OUT_S888DUMY        12
-#define OUT_P16BPP4         24  //
-#define OUT_D888_P666       0x21  //
-#define OUT_D888_P565       0x22  //
+#define OUT_P16BPP4         24
+#define OUT_D888_P666       0x21
+#define OUT_D888_P565       0x22
 
 
 /**
-- 
2.35.3

