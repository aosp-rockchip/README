From 09e9591d15b821bd262a3478b35a4c94c6468420 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Mon, 5 Nov 2018 09:42:31 +0800
Subject: [PATCH] drivers/input: remove unused magnetometer drivers

Change-Id: I724a03bc90fc424b406a1a3721a8e7178f1c51f6
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/input/magnetometer/Kconfig   |   48 --
 drivers/input/magnetometer/Makefile  |    7 -
 drivers/input/magnetometer/ak8973.c  |  751 -------------------
 drivers/input/magnetometer/ak8973.h  |   54 --
 drivers/input/magnetometer/ak8975.c  | 1007 --------------------------
 drivers/input/magnetometer/ak8975.h  |   97 ---
 drivers/input/magnetometer/magnet.h  |   32 -
 drivers/input/magnetometer/mmc328x.c |  348 ---------
 drivers/input/magnetometer/mmc328x.h |   68 --
 9 files changed, 2412 deletions(-)
 delete mode 100644 drivers/input/magnetometer/Kconfig
 delete mode 100644 drivers/input/magnetometer/Makefile
 delete mode 100755 drivers/input/magnetometer/ak8973.c
 delete mode 100644 drivers/input/magnetometer/ak8973.h
 delete mode 100755 drivers/input/magnetometer/ak8975.c
 delete mode 100644 drivers/input/magnetometer/ak8975.h
 delete mode 100644 drivers/input/magnetometer/magnet.h
 delete mode 100755 drivers/input/magnetometer/mmc328x.c
 delete mode 100755 drivers/input/magnetometer/mmc328x.h

diff --git a/drivers/input/magnetometer/Kconfig b/drivers/input/magnetometer/Kconfig
deleted file mode 100644
index fd4e66029d64..000000000000
--- a/drivers/input/magnetometer/Kconfig
+++ /dev/null
@@ -1,48 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Magnetometer sensors
-#
-
-menuconfig MAG_SENSORS
-	bool "Magnetometer sensors"
-	help
-	  Say Y here, and a list of Magnetometer sensors drivers will be displayed.
-	  Everything that didn't fit into the other categories is here. This option
-	  doesn't affect the kernel.
-
-	  If unsure, say Y.
-
-if MAG_SENSORS
-
-config COMPASS_AK8975
-  tristate "Asahi Kasei AK8975 3-Axis Magnetometer"
-  depends on I2C
-  help
-  Say yes here to build support for Asahi Kasei AK8975 3-Axis
-  Magnetometer.
-
-  To compile this driver as a module, choose M here: the module
-  will be called ak8975.
-
-config COMPASS_AK8973
-  tristate "Asahi Kasei AK8973 3-Axis Magnetometer"
-  depends on I2C
-  help
-  Say yes here to build support for Asahi Kasei AK8973 3-Axis
-  Magnetometer.
-
-  To compile this driver as a module, choose M here: the module
-  will be called ak8973.
-
- config COMPASS_MMC328X
-  tristate "Mmc328x 3-Axis Magnetometer"
-  depends on I2C
-  help
-  Say yes here to build support for mmc3280 3-Axis
-  Magnetometer.
-
-  To compile this driver as a module, choose M here: the module
-  will be called mmc3280. 
-
-endif
-
diff --git a/drivers/input/magnetometer/Makefile b/drivers/input/magnetometer/Makefile
deleted file mode 100644
index ecbb23867cd2..000000000000
--- a/drivers/input/magnetometer/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for industrial I/O Magnetometer sensors
-#
-obj-$(CONFIG_COMPASS_AK8975) := ak8975.o 
-obj-$(CONFIG_COMPASS_AK8973) := ak8973.o 
-obj-$(CONFIG_COMPASS_MMC328X) := mmc328x.o 
\ No newline at end of file
diff --git a/drivers/input/magnetometer/ak8973.c b/drivers/input/magnetometer/ak8973.c
deleted file mode 100755
index 6d0b2ca5fabf..000000000000
--- a/drivers/input/magnetometer/ak8973.c
+++ /dev/null
@@ -1,751 +0,0 @@
-/*
- * drivers/i2c/chips/ak8973.c - ak8973 compass driver
- *
- *  Copyright (C) 2008 viral wang <viralwang@gmail.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- */
-
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <asm/gpio.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/freezer.h>
-#include "ak8973.h"
-#include<linux/earlysuspend.h>
-
-#define DEBUG 0
-#define MAX_FAILURE_COUNT 3
-
-static struct i2c_client *this_client;
-
-struct akm8973_data {
-	struct input_dev *input_dev;
-	struct work_struct work;
-#ifdef CONFIG_HAS_EARLYSUSPEND	
-	struct early_suspend early_suspend_akm;
-#endif	
-};
-
-/* Addresses to scan -- protected by sense_data_mutex */
-static char sense_data[RBUFF_SIZE + 1];
-static struct mutex sense_data_mutex;
-#define AKM8973_RETRY_COUNT 10
-static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
-static DECLARE_WAIT_QUEUE_HEAD(open_wq);
-
-static atomic_t data_ready;
-static atomic_t open_count;
-static atomic_t open_flag;
-static atomic_t reserve_open_flag;
-
-static atomic_t m_flag;
-static atomic_t a_flag;
-static atomic_t t_flag;
-static atomic_t mv_flag;
-
-static int failure_count = 0;
-
-static short akmd_delay = 0;
-#ifdef CONFIG_HAS_EARLYSUSPEND  
-static atomic_t suspend_flag = ATOMIC_INIT(0);
-#endif
-
-static int AKI2C_RxData(char *rxData, int length)
-{
-	uint8_t loop_i;
-	struct i2c_msg msgs[] = {
-		{
-		 .addr = this_client->addr,
-		 .flags = 0,
-		 .len = 1,
-		 .buf = rxData,
-		 },
-		{
-		 .addr = this_client->addr,
-		 .flags = I2C_M_RD,
-		 .len = length,
-		 .buf = rxData,
-		 },
-	};
-
-	for (loop_i = 0; loop_i < AKM8973_RETRY_COUNT; loop_i++) {
-		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
-			break;
-		}
-		mdelay(10);
-	}
-
-	if (loop_i >= AKM8973_RETRY_COUNT) {
-		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8973_RETRY_COUNT);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int AKI2C_TxData(char *txData, int length)
-{
-	uint8_t loop_i;
-	struct i2c_msg msg[] = {
-		{
-		 .addr = this_client->addr,
-		 .flags = 0,
-		 .len = length,
-		 .buf = txData,
-		 },
-	};
-	
-	for (loop_i = 0; loop_i < AKM8973_RETRY_COUNT; loop_i++) {
-		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
-			break;
-		}
-		mdelay(10);
-	}
-
-	if (loop_i >= AKM8973_RETRY_COUNT) {
-		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8973_RETRY_COUNT);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int AKECS_StartMeasure(void)
-{
-	char buffer[2];
-
-	/* Set measure mode */
-	buffer[0] = AKECS_REG_MS1;
-	buffer[1] = AKECS_MODE_MEASURE;
-
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_PowerDown(void)
-{
-	char buffer[2];
-	int ret;
-
-	/* Set powerdown mode */
-	buffer[0] = AKECS_REG_MS1;
-	buffer[1] = AKECS_MODE_POWERDOWN;
-	/* Set data */
-	ret = AKI2C_TxData(buffer, 2);
-	if (ret < 0)
-		return ret;
-
-	/* Dummy read for clearing INT pin */
-	buffer[0] = AKECS_REG_TMPS;
-	/* Read data */
-	ret = AKI2C_RxData(buffer, 1);
-	if (ret < 0)
-		return ret;
-	return ret;
-}
-
-static int AKECS_StartE2PRead(void)
-{
-	char buffer[2];
-
-	/* Set measure mode */
-	buffer[0] = AKECS_REG_MS1;
-	buffer[1] = AKECS_MODE_E2P_READ;
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_GetData(void)
-{
-	char buffer[RBUFF_SIZE + 1];
-	int ret;
-
-	memset(buffer, 0, RBUFF_SIZE + 1);
-	buffer[0] = AKECS_REG_ST;
-	ret = AKI2C_RxData(buffer, RBUFF_SIZE+1);
-	if (ret < 0)
-		return ret;
-
-	mutex_lock(&sense_data_mutex);
-	memcpy(sense_data, buffer, sizeof(buffer));
-	atomic_set(&data_ready, 1);
-	wake_up(&data_ready_wq);
-	mutex_unlock(&sense_data_mutex);
-
-	return 0;
-}
-
-static int AKECS_SetMode(char mode)
-{
-	int ret;
-
-	switch (mode) {
-	case AKECS_MODE_MEASURE:
-		ret = AKECS_StartMeasure();
-		break;
-	case AKECS_MODE_E2P_READ:
-		ret = AKECS_StartE2PRead();
-		break;
-	case AKECS_MODE_POWERDOWN:
-		ret = AKECS_PowerDown();
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* wait at least 300us after changing mode */
-	msleep(1);
-	return ret;
-}
-
-static int AKECS_TransRBuff(char *rbuf, int size)
-{
-	wait_event_interruptible_timeout(data_ready_wq,
-					 atomic_read(&data_ready), 1000);
-	if (!atomic_read(&data_ready)) {
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		if (!atomic_read(&suspend_flag)) {
-			printk(KERN_ERR
-				"AKM8973 AKECS_TransRBUFF: Data not ready\n");
-			failure_count++;
-			if (failure_count >= MAX_FAILURE_COUNT) {
-				printk(KERN_ERR
-				       "AKM8973 AKECS_TransRBUFF: successive %d failure.\n",
-				       failure_count);
-				atomic_set(&open_flag, -1);
-				wake_up(&open_wq);
-				failure_count = 0;
-			}
-		}
-		#endif
-		return -1;
-	}
-
-	mutex_lock(&sense_data_mutex);
-	memcpy(&rbuf[1], &sense_data[1], size);
-	atomic_set(&data_ready, 0);
-	mutex_unlock(&sense_data_mutex);
-
-	failure_count = 0;
-	return 0;
-}
-
-
-static void AKECS_Report_Value(short *rbuf)
-{
-	struct akm8973_data *data = i2c_get_clientdata(this_client);
-#if DEBUG
-	printk(KERN_INFO"AKECS_Report_Value: yaw = %d, pitch = %d, roll = %d\n", rbuf[0],
-	       rbuf[1], rbuf[2]);
-	printk(KERN_INFO"                    tmp = %d, m_stat= %d, g_stat=%d\n", rbuf[3],
-	       rbuf[4], rbuf[5]);
-	printk(KERN_INFO"          G_Sensor:   x = %d LSB, y = %d LSB, z = %d LSB\n",
-	       rbuf[6], rbuf[7], rbuf[8]);
-#endif
-	/* Report magnetic sensor information */
-	if (atomic_read(&m_flag)) {
-		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
-		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
-		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
-		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
-	}
-
-	/* Report acceleration sensor information */
-	if (atomic_read(&a_flag)) {
-		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
-		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
-		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
-		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
-	}
-
-	/* Report temperature information */
-	if (atomic_read(&t_flag))
-		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
-
-	if (atomic_read(&mv_flag)) {
-		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
-		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
-		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
-	}
-
-	input_sync(data->input_dev);
-}
-
-static int AKECS_GetOpenStatus(void)
-{
-	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
-	return atomic_read(&open_flag);
-}
-
-static int AKECS_GetCloseStatus(void)
-{
-	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
-	return atomic_read(&open_flag);
-}
-
-static void AKECS_CloseDone(void)
-{
-	atomic_set(&m_flag, 1);
-	atomic_set(&a_flag, 1);
-	atomic_set(&t_flag, 1);
-	atomic_set(&mv_flag, 1);
-}
-
-static int akm_aot_open(struct inode *inode, struct file *file)
-{
-	int ret = -1;
-	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
-		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
-			atomic_set(&reserve_open_flag, 1);
-			wake_up(&open_wq);
-			ret = 0;
-		}
-	}
-	return ret;
-}
-
-static int akm_aot_release(struct inode *inode, struct file *file)
-{
-	atomic_set(&reserve_open_flag, 0);
-	atomic_set(&open_flag, 0);
-	atomic_set(&open_count, 0);
-	wake_up(&open_wq);
-	return 0;
-}
-
-static int
-akm_aot_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	short flag;
-
-	switch (cmd) {
-	case ECS_IOCTL_APP_SET_MFLAG:
-	case ECS_IOCTL_APP_SET_AFLAG:
-	case ECS_IOCTL_APP_SET_TFLAG:
-	case ECS_IOCTL_APP_SET_MVFLAG:
-		if (copy_from_user(&flag, argp, sizeof(flag)))
-			return -EFAULT;
-		if (flag < 0 || flag > 1)
-			return -EINVAL;
-		break;
-	case ECS_IOCTL_APP_SET_DELAY:
-		if (copy_from_user(&flag, argp, sizeof(flag)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	switch (cmd) {
-	case ECS_IOCTL_APP_SET_MFLAG:
-		atomic_set(&m_flag, flag);
-		break;
-	case ECS_IOCTL_APP_GET_MFLAG:
-		flag = atomic_read(&m_flag);
-		break;
-	case ECS_IOCTL_APP_SET_AFLAG:
-		atomic_set(&a_flag, flag);
-		break;
-	case ECS_IOCTL_APP_GET_AFLAG:
-		flag = atomic_read(&a_flag);
-		break;
-	case ECS_IOCTL_APP_SET_TFLAG:
-		atomic_set(&t_flag, flag);
-		break;
-	case ECS_IOCTL_APP_GET_TFLAG:
-		flag = atomic_read(&t_flag);
-		break;
-	case ECS_IOCTL_APP_SET_MVFLAG:
-		atomic_set(&mv_flag, flag);
-		break;
-	case ECS_IOCTL_APP_GET_MVFLAG:
-		flag = atomic_read(&mv_flag);
-		break;
-	case ECS_IOCTL_APP_SET_DELAY:
-		akmd_delay = flag;
-		break;
-	case ECS_IOCTL_APP_GET_DELAY:
-		flag = akmd_delay;
-		break;
-	default:
-		return -ENOTTY;
-	}
-
-	switch (cmd) {
-	case ECS_IOCTL_APP_GET_MFLAG:
-	case ECS_IOCTL_APP_GET_AFLAG:
-	case ECS_IOCTL_APP_GET_TFLAG:
-	case ECS_IOCTL_APP_GET_MVFLAG:
-	case ECS_IOCTL_APP_GET_DELAY:
-		if (copy_to_user(argp, &flag, sizeof(flag)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int akmd_open(struct inode *inode, struct file *file)
-{
-	return nonseekable_open(inode, file);
-}
-
-static int akmd_release(struct inode *inode, struct file *file)
-{
-	AKECS_CloseDone();
-	return 0;
-}
-
-static int
-akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-	   unsigned long arg)
-{
-
-	void __user *argp = (void __user *)arg;
-
-	char msg[RBUFF_SIZE + 1], rwbuf[5];
-	int ret = -1, status;
-	short mode, value[12], delay;
-
-	switch (cmd) {
-	case ECS_IOCTL_WRITE:
-	case ECS_IOCTL_READ:
-		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_SET_MODE:
-		if (copy_from_user(&mode, argp, sizeof(mode)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_SET_YPR:
-		if (copy_from_user(&value, argp, sizeof(value)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	switch (cmd) {
-	case ECS_IOCTL_WRITE:
-		if (rwbuf[0] < 2)
-			return -EINVAL;
-		ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
-		if (ret < 0)
-			return ret;
-		break;
-	case ECS_IOCTL_READ:
-		if (rwbuf[0] < 1)
-			return -EINVAL;
-		ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
-		if (ret < 0)
-			return ret;
-		break;
-	case ECS_IOCTL_SET_MODE:
-		ret = AKECS_SetMode((char)mode);
-		if (ret < 0)
-			return ret;
-		break;
-	case ECS_IOCTL_GETDATA:
-		ret = AKECS_TransRBuff(msg, RBUFF_SIZE);
-		if (ret < 0)
-			return ret;
-		break;
-	case ECS_IOCTL_SET_YPR:
-		AKECS_Report_Value(value);
-		break;
-	case ECS_IOCTL_GET_OPEN_STATUS:
-		status = AKECS_GetOpenStatus();
-		break;
-	case ECS_IOCTL_GET_CLOSE_STATUS:
-		status = AKECS_GetCloseStatus();
-		break;
-	case ECS_IOCTL_GET_DELAY:
-		delay = akmd_delay;
-		break;
-	default:
-		return -ENOTTY;
-	}
-
-	switch (cmd) {
-	case ECS_IOCTL_READ:
-		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_GETDATA:
-		if (copy_to_user(argp, &msg, sizeof(msg)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_GET_OPEN_STATUS:
-	case ECS_IOCTL_GET_CLOSE_STATUS:
-		if (copy_to_user(argp, &status, sizeof(status)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_GET_DELAY:
-		if (copy_to_user(argp, &delay, sizeof(delay)))
-			return -EFAULT;
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static void akm_work_func(struct work_struct *work)
-{
-	if (AKECS_GetData() < 0)
-		printk(KERN_ERR "AKM8973 akm_work_func: Get data failed\n");
-	enable_irq(this_client->irq);
-}
-
-static irqreturn_t akm8973_interrupt(int irq, void *dev_id)
-{
-	struct akm8973_data *data = dev_id;
-	disable_irq(this_client->irq);
-	schedule_work(&data->work);
-	return IRQ_HANDLED;
-}
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void akm8973_early_suspend(struct early_suspend *handler)
-{
-	atomic_set(&suspend_flag, 1);
-	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
-	atomic_set(&open_flag, 0);
-	wake_up(&open_wq);
-	disable_irq(this_client->irq);
-}
-
-static void akm8973_early_resume(struct early_suspend *handler)
-{
-	enable_irq(this_client->irq);
-	atomic_set(&suspend_flag, 0);
-	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
-	wake_up(&open_wq);
-}
-#endif
-static struct file_operations akmd_fops = {
-	.owner = THIS_MODULE,
-	.open = akmd_open,
-	.release = akmd_release,
-	.ioctl = akmd_ioctl,
-};
-
-static struct file_operations akm_aot_fops = {
-	.owner = THIS_MODULE,
-	.open = akm_aot_open,
-	.release = akm_aot_release,
-	.ioctl = akm_aot_ioctl,
-};
-
-
-static struct miscdevice akm_aot_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "akm8973_aot",
-	.fops = &akm_aot_fops,
-};
-
-
-static struct miscdevice akmd_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "akm8973_daemon",
-	.fops = &akmd_fops,
-};
-
-static ssize_t compass_reset_store(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	int val;
-
-	val = -1;
-	sscanf(buf, "%u", &val);
-	if (val != 1)
-		return -EINVAL;
-
-	return count;
-}
-
-static DEVICE_ATTR(reset, 0644, NULL, compass_reset_store);
-
-int akm8973_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct akm8973_data *akm;
-	int err = 0;
-
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		err = -ENODEV;
-		goto exit_check_functionality_failed;
-	}
-
-	akm = kzalloc(sizeof(struct akm8973_data), GFP_KERNEL);
-	if (!akm) {
-		err = -ENOMEM;
-		goto exit_alloc_data_failed;
-	}
-
-	INIT_WORK(&akm->work, akm_work_func);
-	i2c_set_clientdata(client, akm);
-
-	this_client = client;
-
-	err = AKECS_PowerDown();
-	if (err < 0) {
-		printk(KERN_ERR"AKM8973 akm8973_probe: set power down mode error\n");
-		goto exit_set_mode_failed;
-	}
-
-	err = request_irq(client->irq, akm8973_interrupt, IRQF_TRIGGER_HIGH,
-			  "akm8973", akm);
-
-	if (err < 0) {
-		printk(KERN_ERR"AKM8973 akm8973_probe: request irq failed\n");
-		goto exit_irq_request_failed;
-	}
-
-	akm->input_dev = input_allocate_device();
-
-	if (!akm->input_dev) {
-		err = -ENOMEM;
-		printk(KERN_ERR
-		       "AKM8973 akm8973_probe: Failed to allocate input device\n");
-		goto exit_input_dev_alloc_failed;
-	}
-
-	set_bit(EV_ABS, akm->input_dev->evbit);
-	/* yaw */
-	input_set_abs_params(akm->input_dev, ABS_RX, 0, 360, 0, 0);
-	/* pitch */
-	input_set_abs_params(akm->input_dev, ABS_RY, -180, 180, 0, 0);
-	/* roll */
-	input_set_abs_params(akm->input_dev, ABS_RZ, -90, 90, 0, 0);
-	/* x-axis acceleration */
-	input_set_abs_params(akm->input_dev, ABS_X, -1872, 1872, 0, 0);
-	/* y-axis acceleration */
-	input_set_abs_params(akm->input_dev, ABS_Y, -1872, 1872, 0, 0);
-	/* z-axis acceleration */
-	input_set_abs_params(akm->input_dev, ABS_Z, -1872, 1872, 0, 0);
-	/* temparature */
-	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
-	/* status of magnetic sensor */
-	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
-	/* status of acceleration sensor */
-	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
-	/* step count */
-	input_set_abs_params(akm->input_dev, ABS_GAS, 0, 65535, 0, 0);
-	/* x-axis of raw magnetic vector */
-	input_set_abs_params(akm->input_dev, ABS_HAT0X, -2048, 2032, 0, 0);
-	/* y-axis of raw magnetic vector */
-	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -2048, 2032, 0, 0);
-	/* z-axis of raw magnetic vector */
-	input_set_abs_params(akm->input_dev, ABS_BRAKE, -2048, 2032, 0, 0);
-
-	akm->input_dev->name = "compass";
-
-	err = input_register_device(akm->input_dev);
-
-	if (err) {
-		printk(KERN_ERR
-		       "AKM8973 akm8973_probe: Unable to register input device: %s\n",
-		       akm->input_dev->name);
-		goto exit_input_register_device_failed;
-	}
-
-	err = misc_register(&akmd_device);
-	if (err) {
-		printk(KERN_ERR "AKM8973 akm8973_probe: akmd_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-
-	err = misc_register(&akm_aot_device);
-	if (err) {
-		printk(KERN_ERR
-		       "AKM8973 akm8973_probe: akm_aot_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-
-	mutex_init(&sense_data_mutex);
-
-	init_waitqueue_head(&data_ready_wq);
-	init_waitqueue_head(&open_wq);
-
-	/* As default, report all information */
-	atomic_set(&m_flag, 1);
-	atomic_set(&a_flag, 1);
-	atomic_set(&t_flag, 1);
-	atomic_set(&mv_flag, 1);
-#ifdef CONFIG_HAS_EARLYSUSPEND  
-	akm->early_suspend_akm.suspend = akm8973_early_suspend;
-	akm->early_suspend_akm.resume = akm8973_early_resume;
-	register_early_suspend(&akm->early_suspend_akm);
-#endif
-	err = device_create_file(&client->dev, &dev_attr_reset);
-	if (err)
-		printk(KERN_ERR
-		"AKM8973 akm8973_probe: create dev_attr_reset failed\n");
-
-	return 0;
-
-exit_misc_device_register_failed:
-exit_input_register_device_failed:
-	input_free_device(akm->input_dev);
-exit_input_dev_alloc_failed:
-	free_irq(client->irq, akm);
-exit_irq_request_failed:
-exit_set_mode_failed:
-	kfree(akm);
-exit_alloc_data_failed:
-exit_check_functionality_failed:
-	return err;
-
-}
-
-static int akm8973_remove(struct i2c_client *client)
-{
-	struct akm8973_data *akm = i2c_get_clientdata(client);
-	free_irq(client->irq, akm);
-	input_unregister_device(akm->input_dev);
-	kfree(akm);
-	return 0;
-}
-static const struct i2c_device_id akm8973_id[] = {
-	{ AKM8973_I2C_NAME, 0 },
-	{ }
-};
-
-static struct i2c_driver akm8973_driver = {
-	.probe 	= akm8973_probe,
-	.remove 	= akm8973_remove,
-	.id_table	= akm8973_id,
-	.driver = {
-		   .name = AKM8973_I2C_NAME,
-		},
-};
-
-static int __init akm8973_init(void)
-{
-	printk(KERN_INFO "AKM8973 compass driver: init\n");
-	return i2c_add_driver(&akm8973_driver);
-}
-
-static void __exit akm8973_exit(void)
-{
-	i2c_del_driver(&akm8973_driver);
-}
-
-module_init(akm8973_init);
-module_exit(akm8973_exit);
-
-MODULE_AUTHOR("viral wang <viral_wang@htc.com>");
-MODULE_DESCRIPTION("AKM8973 compass driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/input/magnetometer/ak8973.h b/drivers/input/magnetometer/ak8973.h
deleted file mode 100644
index 6f5c1ce06515..000000000000
--- a/drivers/input/magnetometer/ak8973.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Definitions for ak8973 compass chip.
- */
-#ifndef AKM8973_H
-#define AKM8973_H
-
-#include <linux/ioctl.h>
-
-#define AKM8973_I2C_NAME "ak8973"
-
-/* Compass device dependent definition */
-#define AKECS_MODE_MEASURE	0x00	/* Starts measurement. Please use AKECS_MODE_MEASURE_SNG */
-					/* or AKECS_MODE_MEASURE_SEQ instead of this. */
-#define AKECS_MODE_E2P_READ	0x02	/* E2P access mode (read). */
-#define AKECS_MODE_POWERDOWN	0x03	/* Power down mode */
-
-#define RBUFF_SIZE		4	/* Rx buffer size */
-
-/* AK8973 register address */
-#define AKECS_REG_ST			0xC0
-#define AKECS_REG_TMPS			0xC1
-#define AKECS_REG_MS1			0xE0
-
-#define AKMIO				0xA1
-
-/* IOCTLs for AKM library */
-#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x01, char[5])
-#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x02, char[5])
-#define ECS_IOCTL_RESET      	          _IO(AKMIO, 0x03)
-#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x04, short)
-#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x05, char[RBUFF_SIZE+1])
-#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x06, short[12])
-#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x07, int)
-#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x08, int)
-#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
-
-/* IOCTLs for APPs */
-#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
-#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
-#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
-#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
-#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
-#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)
-#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)
-#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)
-#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
-#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
-#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)	/* Set raw magnetic vector flag */
-#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)	/* Get raw magnetic vector flag */
-
-
-#endif
-
diff --git a/drivers/input/magnetometer/ak8975.c b/drivers/input/magnetometer/ak8975.c
deleted file mode 100755
index 7057207fb7f9..000000000000
--- a/drivers/input/magnetometer/ak8975.c
+++ /dev/null
@@ -1,1007 +0,0 @@
-/* drivers/i2c/chips/akm8975.c - akm8975 compass driver
- *
- * Copyright (C) 2007-2008 HTC Corporation.
- * Author: Hou-Kun Chen <houkun.chen@gmail.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-/*
- * Revised by AKM 2009/04/02
- * 
- */
-
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <linux/gpio.h>
-#include <linux/uaccess.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/freezer.h>
-#include <linux/earlysuspend.h>
-#include "ak8975.h"
-
-#define AKM8975_DEBUG		1
-#define AKM8975_DEBUG_MSG	0
-#define AKM8975_DEBUG_FUNC	0
-#define AKM8975_DEBUG_DATA	0
-#define MAX_FAILURE_COUNT	3
-#define AKM8975_RETRY_COUNT	10
-#define AKM8975_DEFAULT_DELAY	100
-
-#if AKM8975_DEBUG_MSG
-#define AKMDBG(format, ...)	printk(KERN_INFO "AKM8975 " format "\n", ## __VA_ARGS__)
-#else
-#define AKMDBG(format, ...)
-#endif
-
-#if AKM8975_DEBUG_FUNC
-#define AKMFUNC(func) printk(KERN_INFO "AKM8975 " func " is called\n")
-#else
-#define AKMFUNC(func)
-#endif
-
-static struct i2c_client *this_client;
-
-struct akm8975_data {
-	struct i2c_client *client; 
-	struct input_dev *input_dev;
-	struct work_struct work;
-	struct early_suspend akm_early_suspend;
-	int eoc_irq; 
-	struct akm8975_platform_data *pdata;
-};
-
-/* Addresses to scan -- protected by sense_data_mutex */
-static char sense_data[SENSOR_DATA_SIZE];
-static struct mutex sense_data_mutex;
-static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
-static DECLARE_WAIT_QUEUE_HEAD(open_wq);
-
-static atomic_t data_ready;
-static atomic_t open_count;
-static atomic_t open_flag;
-static atomic_t reserve_open_flag;
-
-static atomic_t m_flag;
-static atomic_t a_flag;
-static atomic_t mv_flag;
-
-static int failure_count = 0;
-
-static short akmd_delay = AKM8975_DEFAULT_DELAY;
-
-static atomic_t suspend_flag = ATOMIC_INIT(0);
-
-//static struct akm8975_platform_data *pdata;
-
-#define AKM_I2C_RATE 100*1000
-
-static int AKI2C_RxData(char *rxData, int length)
-{
-	uint8_t loop_i;
-	struct i2c_msg msgs[] = {
-		{
-			.addr = this_client->addr,
-			.flags = 0,
-			.len = 1,
-			.buf = rxData,
-			.scl_rate = AKM_I2C_RATE,
-		},
-		{
-			.addr = this_client->addr,
-			.flags = I2C_M_RD,
-			.len = length,
-			.buf = rxData,
-			.scl_rate = AKM_I2C_RATE,
-		},
-	};
-#if AKM8975_DEBUG_DATA
-	int i;
-	char addr = rxData[0];
-#endif
-#ifdef AKM8975_DEBUG
-	/* Caller should check parameter validity.*/
-	if ((rxData == NULL) || (length < 1)) {
-		return -EINVAL;
-	}
-#endif
-	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
-		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
-			break;
-		}
-		mdelay(10);
-	}
-	
-	if (loop_i >= AKM8975_RETRY_COUNT) {
-		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
-		return -EIO;
-	}
-#if AKM8975_DEBUG_DATA
-	printk(KERN_INFO "RxData: len=%02x, addr=%02x\n  data=", length, addr);
-	for (i = 0; i < length; i++) {
-		printk(KERN_INFO " %02x", rxData[i]);
-	}
-    printk(KERN_INFO "\n");
-#endif
-	return 0;
-}
-
-static int AKI2C_TxData(char *txData, int length)
-{
-	uint8_t loop_i;
-	struct i2c_msg msg[] = {
-		{
-			.addr = this_client->addr,
-			.flags = 0,
-			.len = length,
-			.buf = txData,
-			.scl_rate = AKM_I2C_RATE,
-		},
-	};
-#if AKM8975_DEBUG_DATA
-	int i;
-#endif
-#ifdef AKM8975_DEBUG
-	/* Caller should check parameter validity.*/
-	if ((txData == NULL) || (length < 2)) {
-		return -EINVAL;
-	}
-#endif	
-	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
-		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
-			break;
-		}
-		mdelay(10);
-	}
-	
-	if (loop_i >= AKM8975_RETRY_COUNT) {
-		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
-		return -EIO;
-	}
-#if AKM8975_DEBUG_DATA
-	printk(KERN_INFO "TxData: len=%02x, addr=%02x\n  data=", length, txData[0]);
-	for (i = 0; i < (length-1); i++) {
-		printk(KERN_INFO " %02x", txData[i + 1]);
-	}
-	printk(KERN_INFO "\n");
-#endif
-	return 0;
-}
-
-static int AKECS_SetMode_SngMeasure(void)
-{
-	char buffer[2];
-	
-	AKMDBG("enter %s\n", __func__);
-	
-	atomic_set(&data_ready, 0);
-	
-	/* Set measure mode */
-	buffer[0] = AK8975_REG_CNTL;
-	buffer[1] = AK8975_MODE_SNG_MEASURE;
-	
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_SetMode_SelfTest(void)
-{
-	char buffer[2];
-	AKMDBG("enter %s\n", __func__);
-	
-	/* Set measure mode */
-	buffer[0] = AK8975_REG_CNTL;
-	buffer[1] = AK8975_MODE_SELF_TEST;
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_SetMode_FUSEAccess(void)
-{
-	char buffer[2];
-	AKMDBG("enter %s\n", __func__);
-	
-	/* Set measure mode */
-	buffer[0] = AK8975_REG_CNTL;
-	buffer[1] = AK8975_MODE_FUSE_ACCESS;
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_SetMode_PowerDown(void)
-{
-	char buffer[2];
-	AKMDBG("enter %s\n", __func__);
-	
-	/* Set powerdown mode */
-	buffer[0] = AK8975_REG_CNTL;
-	buffer[1] = AK8975_MODE_POWERDOWN;
-	/* Set data */
-	return AKI2C_TxData(buffer, 2);
-}
-
-static int AKECS_SetMode(char mode)
-{
-	int ret;
-	AKMDBG("enter %s\n", __func__);
-	
-	switch (mode) {
-		case AK8975_MODE_SNG_MEASURE:
-			ret = AKECS_SetMode_SngMeasure();
-			break;
-		case AK8975_MODE_SELF_TEST:
-			ret = AKECS_SetMode_SelfTest();
-			break;
-		case AK8975_MODE_FUSE_ACCESS:
-			ret = AKECS_SetMode_FUSEAccess();
-			break;
-		case AK8975_MODE_POWERDOWN:
-			ret = AKECS_SetMode_PowerDown();
-			/* wait at least 100us after changing mode */
-			udelay(100);
-			break;
-		default:
-			AKMDBG("%s: Unknown mode(%d)", __func__, mode);
-			return -EINVAL;
-	}
-
-	return ret;
-}
-
-static int AKECS_CheckDevice(void)
-{
-	char buffer[2];
-	int ret;
-	AKMDBG("enter %s\n", __func__);
-	
-	/* Set measure mode */
-	buffer[0] = AK8975_REG_WIA;
-	
-	/* Read data */
-	ret = AKI2C_RxData(buffer, 1);
-	if (ret < 0) {
-		return ret;
-	}
-	/* Check read data */
-	if (buffer[0] != 0x48) {
-		return -ENXIO;
-	}
-	
-	return 0;
-}
-
-static int AKECS_GetData(char *rbuf, int size)
-{
-#ifdef AKM8975_DEBUG
-	/* This function is not exposed, so parameters 
-	 should be checked internally.*/
-	if ((rbuf == NULL) || (size < SENSOR_DATA_SIZE)) {
-		return -EINVAL;
-	}
-#endif
-	AKMDBG("enter %s\n", __func__);
-	wait_event_interruptible_timeout(data_ready_wq,
-									 atomic_read(&data_ready), 1000);
-	if (!atomic_read(&data_ready)) {
-		AKMDBG("%s: data_ready is not set.", __func__);
-		if (!atomic_read(&suspend_flag)) {
-			AKMDBG("%s: suspend_flag is not set.", __func__);
-			failure_count++;
-			if (failure_count >= MAX_FAILURE_COUNT) {
-				printk(KERN_ERR
-				       "AKM8975 AKECS_GetData: successive %d failure.\n",
-				       failure_count);
-				atomic_set(&open_flag, -1);
-				wake_up(&open_wq);
-				failure_count = 0;
-			}
-		}
-		return -1;
-	}
-	
-	mutex_lock(&sense_data_mutex);
-	memcpy(rbuf, sense_data, size);
-	atomic_set(&data_ready, 0);
-	mutex_unlock(&sense_data_mutex);
-	
-	failure_count = 0;
-	return 0;
-}
-
-static void AKECS_SetYPR(short *rbuf)
-{
-	struct akm8975_data *data = i2c_get_clientdata(this_client);
-#if AKM8975_DEBUG_DATA
-	printk(KERN_INFO "AKM8975 %s:\n", __func__);
-	printk(KERN_INFO "  yaw =%6d, pitch =%6d, roll =%6d\n",
-		   rbuf[0], rbuf[1], rbuf[2]);
-	printk(KERN_INFO "  tmp =%6d, m_stat =%6d, g_stat =%6d\n",
-		   rbuf[3], rbuf[4], rbuf[5]);
-	printk(KERN_INFO "  Acceleration[LSB]: %6d,%6d,%6d\n",
-	       rbuf[6], rbuf[7], rbuf[8]);
-	printk(KERN_INFO "  Geomagnetism[LSB]: %6d,%6d,%6d\n",
-	       rbuf[9], rbuf[10], rbuf[11]);
-#endif
-	AKMDBG("enter %s\n", __func__);
-	/* Report magnetic sensor information */
-	if (atomic_read(&m_flag)) {
-		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
-		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
-		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
-		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
-	}
-	
-	/* Report acceleration sensor information */
-	if (atomic_read(&a_flag)) {
-		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
-		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
-		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
-		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
-	}
-	
-	/* Report magnetic vector information */
-	if (atomic_read(&mv_flag)) {
-		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
-		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
-		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
-	}
-	
-	input_sync(data->input_dev);
-}
-
-static int AKECS_GetOpenStatus(void)
-{
-	AKMDBG("enter %s\n", __func__);
-	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
-	return atomic_read(&open_flag);
-}
-
-static int AKECS_GetCloseStatus(void)
-{
-	AKMDBG("enter %s\n", __func__);
-	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
-	return atomic_read(&open_flag);
-}
-
-static void AKECS_CloseDone(void)
-{
-	AKMDBG("enter %s\n", __func__);
-	atomic_set(&m_flag, 1);
-	atomic_set(&a_flag, 1);
-	atomic_set(&mv_flag, 1);
-}
-
-/***** akm_aot functions ***************************************/
-static int akm_aot_open(struct inode *inode, struct file *file)
-{
-	int ret = -1;
-
-	AKMFUNC("akm_aot_open");
-	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
-		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
-			atomic_set(&reserve_open_flag, 1);
-			wake_up(&open_wq);
-			ret = 0;
-		}
-	}
-	return ret;
-}
-
-static int akm_aot_release(struct inode *inode, struct file *file)
-{
-	AKMFUNC("akm_aot_release");
-	atomic_set(&reserve_open_flag, 0);
-	atomic_set(&open_flag, 0);
-	atomic_set(&open_count, 0);
-	wake_up(&open_wq);
-	return 0;
-}
-
-//static int
-//akm_aot_ioctl(struct inode *inode, struct file *file,
-//			  unsigned int cmd, unsigned long arg)
-static long akm_aot_ioctl(struct file *file,unsigned int cmd, unsigned long arg)			  
-{
-	void __user *argp = (void __user *)arg;
-	short flag;
-	AKMDBG("enter %s\n", __func__);
-	
-	switch (cmd) {
-		case ECS_IOCTL_APP_SET_MFLAG:
-		case ECS_IOCTL_APP_SET_AFLAG:
-		case ECS_IOCTL_APP_SET_MVFLAG:
-			if (copy_from_user(&flag, argp, sizeof(flag))) {
-				return -EFAULT;
-			}
-			if (flag < 0 || flag > 1) {
-				return -EINVAL;
-			}
-			break;
-		case ECS_IOCTL_APP_SET_DELAY:
-			if (copy_from_user(&flag, argp, sizeof(flag))) {
-				return -EFAULT;
-			}
-			break;
-		default:
-			break;
-	}
-	
-	switch (cmd) {
-		case ECS_IOCTL_APP_SET_MFLAG:
-			atomic_set(&m_flag, flag);
-			AKMDBG("MFLAG is set to %d", flag);
-			break;
-		case ECS_IOCTL_APP_GET_MFLAG:
-			flag = atomic_read(&m_flag);
-			break;
-		case ECS_IOCTL_APP_SET_AFLAG:
-			atomic_set(&a_flag, flag);
-			AKMDBG("AFLAG is set to %d", flag);
-			break;
-		case ECS_IOCTL_APP_GET_AFLAG:
-			flag = atomic_read(&a_flag);
-			break;
-		case ECS_IOCTL_APP_SET_MVFLAG:
-			atomic_set(&mv_flag, flag);
-			AKMDBG("MVFLAG is set to %d", flag);
-			break;
-		case ECS_IOCTL_APP_GET_MVFLAG:
-			flag = atomic_read(&mv_flag);
-			break;
-		case ECS_IOCTL_APP_SET_DELAY:
-			akmd_delay = flag;
-			AKMDBG("Delay is set to %d", flag);
-			break;
-		case ECS_IOCTL_APP_GET_DELAY:
-			flag = akmd_delay;
-			break;
-		default:
-			return -ENOTTY;
-	}
-	
-	switch (cmd) {
-		case ECS_IOCTL_APP_GET_MFLAG:
-		case ECS_IOCTL_APP_GET_AFLAG:
-		case ECS_IOCTL_APP_GET_MVFLAG:
-		case ECS_IOCTL_APP_GET_DELAY:
-			if (copy_to_user(argp, &flag, sizeof(flag))) {
-				return -EFAULT;
-			}
-			break;
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-/***** akmd functions ********************************************/
-static int akmd_open(struct inode *inode, struct file *file)
-{
-	AKMFUNC("akmd_open");
-	return nonseekable_open(inode, file);
-}
-
-static int akmd_release(struct inode *inode, struct file *file)
-{
-	AKMFUNC("akmd_release");
-	AKECS_CloseDone();
-	return 0;
-}
-
-
-static int akm_get_platform_data(struct akm8975_platform_data __user *arg)
-{	
-	struct akm8975_data *data = (struct akm8975_data *)i2c_get_clientdata(this_client);	
-	struct akm8975_platform_data *pdata_slave;
-//	struct akm8975_platform_data local_pdata_slave;
-
-//	if (copy_from_user(&local_pdata_slave, arg, sizeof(local_pdata_slave)))
-//		return -EFAULT;
-	pdata_slave = data->pdata;
-	if (!pdata_slave)
-		return -ENODEV;
-	if (copy_to_user(arg, pdata_slave, sizeof(*pdata_slave)))
-		return -EFAULT;
-	
-	return 0;
-}
-
-
-
-//static int akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-//		   unsigned long arg)
-
-static long akmd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	AKMDBG("enter %s\n", __func__);
-	
-	/* NOTE: In this function the size of "char" should be 1-byte. */
-	char sData[SENSOR_DATA_SIZE];/* for GETDATA */
-	char rwbuf[RWBUF_SIZE];		/* for READ/WRITE */
-	char mode;					/* for SET_MODE*/
-	short value[12];			/* for SET_YPR */
-	short delay;				/* for GET_DELAY */
-	int status;					/* for OPEN/CLOSE_STATUS */
-	int ret = -1;				/* Return value. */
-	/*AKMDBG("%s (0x%08X).", __func__, cmd);*/
-	
-	switch (cmd) {
-		case ECS_IOCTL_WRITE:
-		case ECS_IOCTL_READ:
-			if (argp == NULL) {
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			if (copy_from_user(&rwbuf, argp, sizeof(rwbuf))) {
-				AKMDBG("copy_from_user failed.");
-				return -EFAULT;
-			}
-			break;
-		case ECS_IOCTL_SET_MODE:
-			if (argp == NULL) {
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			if (copy_from_user(&mode, argp, sizeof(mode))) {
-				AKMDBG("copy_from_user failed.");
-				return -EFAULT;
-			}
-			break;
-		case ECS_IOCTL_SET_YPR:
-			if (argp == NULL) {
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			if (copy_from_user(&value, argp, sizeof(value))) {
-				AKMDBG("copy_from_user failed.");
-				return -EFAULT;
-			}
-			break;
-		default:
-			break;
-	}
-	
-	switch (cmd) {
-		case ECS_IOCTL_WRITE:
-			AKMFUNC("IOCTL_WRITE");
-			if ((rwbuf[0] < 2) || (rwbuf[0] > (RWBUF_SIZE-1))) {
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
-			if (ret < 0) {
-				return ret;
-			}
-			break;
-		case ECS_IOCTL_READ:
-			AKMFUNC("IOCTL_READ");
-			if ((rwbuf[0] < 1) || (rwbuf[0] > (RWBUF_SIZE-1))) {
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
-			if (ret < 0) {
-				return ret;
-			}
-			break;
-		case ECS_IOCTL_SET_MODE:
-			AKMFUNC("IOCTL_SET_MODE");
-			ret = AKECS_SetMode(mode);
-			if (ret < 0) {
-				return ret;
-			}
-			break;
-		case ECS_IOCTL_GETDATA:
-			AKMFUNC("IOCTL_GET_DATA");
-			ret = AKECS_GetData(sData, SENSOR_DATA_SIZE);
-			if (ret < 0) {
-				return ret;
-			}
-			break;
-		case ECS_IOCTL_SET_YPR:
-			AKECS_SetYPR(value);
-			break;
-		case ECS_IOCTL_GET_OPEN_STATUS:
-			AKMFUNC("IOCTL_GET_OPEN_STATUS");
-			status = AKECS_GetOpenStatus();
-			AKMDBG("AKECS_GetOpenStatus returned (%d)", status);
-			break;
-		case ECS_IOCTL_GET_CLOSE_STATUS:
-			AKMFUNC("IOCTL_GET_CLOSE_STATUS");
-			status = AKECS_GetCloseStatus();
-			AKMDBG("AKECS_GetCloseStatus returned (%d)", status);
-			break;
-		case ECS_IOCTL_GET_DELAY:
-			AKMFUNC("IOCTL_GET_DELAY");
-			delay = akmd_delay;
-			break;
-		case ECS_IOCTL_GET_PLATFORM_DATA:
-			ret = akm_get_platform_data((struct akm8975_platform_data __user *)arg);
-			if(ret < 0)
-			{
-				printk("%s:error,ret=%d\n",__FUNCTION__, ret);
-				return ret;
-			}
-			break;
-			
-		default:
-			return -ENOTTY;
-	}
-	
-	switch (cmd) {
-		case ECS_IOCTL_READ:
-			if (copy_to_user(argp, &rwbuf, rwbuf[0]+1)) {
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
-			break;
-		case ECS_IOCTL_GETDATA:
-			if (copy_to_user(argp, &sData, sizeof(sData))) {
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
-			break;
-		case ECS_IOCTL_GET_OPEN_STATUS:
-		case ECS_IOCTL_GET_CLOSE_STATUS:
-			if (copy_to_user(argp, &status, sizeof(status))) {
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
-			break;
-		case ECS_IOCTL_GET_DELAY:
-			if (copy_to_user(argp, &delay, sizeof(delay))) {
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
-			break;
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-static void akm8975_work_func(struct work_struct *work)
-{
-	char buffer[SENSOR_DATA_SIZE];
-	int ret;
-	AKMDBG("enter %s\n", __func__);
-	
-	memset(buffer, 0, SENSOR_DATA_SIZE);
-	buffer[0] = AK8975_REG_ST1;
-	ret = AKI2C_RxData(buffer, SENSOR_DATA_SIZE);
-	if (ret < 0) {
-		printk(KERN_ERR "AKM8975 akm8975_work_func: I2C failed\n");
-		return;
-	}
-	/* Check ST bit */
-	if ((buffer[0] & 0x01) != 0x01) {
-		printk(KERN_ERR "AKM8975 akm8975_work_func: ST is not set\n");
-		return;
-	}
-	
-	mutex_lock(&sense_data_mutex);
-	memcpy(sense_data, buffer, SENSOR_DATA_SIZE);
-	atomic_set(&data_ready, 1);
-	wake_up(&data_ready_wq);
-	mutex_unlock(&sense_data_mutex);
-	
-	enable_irq(this_client->irq);
-	
-	AKMFUNC("akm8975_work_func");
-}
-
-static irqreturn_t akm8975_interrupt(int irq, void *dev_id)
-{
-	struct akm8975_data *data = dev_id;
-	AKMFUNC("akm8975_interrupt");
-	disable_irq_nosync(this_client->irq);
-	schedule_work(&data->work);
-	AKMDBG("exit %s\n", __func__);
-	return IRQ_HANDLED;
-}
-
-static void akm8975_early_suspend(struct early_suspend *handler)
-{
-	AKMFUNC("akm8975_early_suspend");
-	atomic_set(&suspend_flag, 1);
-	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
-	atomic_set(&open_flag, 0);
-	wake_up(&open_wq);
-	disable_irq(this_client->irq);
-	AKMDBG("suspended with flag=%d", 
-	       atomic_read(&reserve_open_flag));
-}
-
-static void akm8975_early_resume(struct early_suspend *handler)
-{
-	AKMFUNC("akm8975_early_resume");
-	enable_irq(this_client->irq);
-	atomic_set(&suspend_flag, 0);
-	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
-	wake_up(&open_wq);
-	AKMDBG("resumed with flag=%d", 
-	       atomic_read(&reserve_open_flag));
-}
-static int akm8975_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	AKMFUNC("akm8975_early_suspend");
-	atomic_set(&suspend_flag, 1);
-	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
-	atomic_set(&open_flag, 0);
-	wake_up(&open_wq);
-	disable_irq(this_client->irq);
-	AKMDBG("suspended with flag=%d", 
-	       atomic_read(&reserve_open_flag));
-	return 0;
-}
-
-static int akm8975_resume(struct i2c_client *client)
-{
-	AKMFUNC("akm8975_early_resume");
-	enable_irq(this_client->irq);
-	atomic_set(&suspend_flag, 0);
-	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
-	wake_up(&open_wq);
-	AKMDBG("resumed with flag=%d", 
-	       atomic_read(&reserve_open_flag));
-	return 0;
-}
-/*********************************************/
-static struct file_operations akmd_fops = {
-	.owner = THIS_MODULE,
-	.open = akmd_open,
-	.release = akmd_release,
-	.unlocked_ioctl = akmd_ioctl,
-};
-
-static struct file_operations akm_aot_fops = {
-	.owner = THIS_MODULE,
-	.open = akm_aot_open,
-	.release = akm_aot_release,
-	.unlocked_ioctl = akm_aot_ioctl,
-};
-
-static struct miscdevice akmd_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "akm8975_dev",
-	.fops = &akmd_fops,
-};
-
-static struct miscdevice akm_aot_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "akm8975_aot",
-	.fops = &akm_aot_fops,
-};
-
-/*********************************************/
-int akm8975_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct akm8975_data *akm;
-	int err = 0;
-	
-	AKMFUNC("akm8975_probe");
-	
-	if (client->dev.platform_data == NULL) {
-		dev_err(&client->dev, "platform data is NULL. exiting.\n");
-		err = -ENODEV;
-		goto exit0;
-	}
-	
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		printk(KERN_ERR "AKM8975 akm8975_probe: check_functionality failed.\n");
-		err = -ENODEV;
-		goto exit0;
-	}
-	
-	/* Allocate memory for driver data */
-	akm = kzalloc(sizeof(struct akm8975_data), GFP_KERNEL);
-	if (!akm) {
-		printk(KERN_ERR "AKM8975 akm8975_probe: memory allocation failed.\n");
-		err = -ENOMEM;
-		goto exit1;
-	}
-
-	akm->pdata = client->dev.platform_data;
-	
-	INIT_WORK(&akm->work, akm8975_work_func);
-	i2c_set_clientdata(client, akm);
-	
-	this_client = client;
-	
-	/* Check connection */
-	err = AKECS_CheckDevice();
-	if (err < 0) {
-		printk(KERN_ERR "AKM8975 akm8975_probe: set power down mode error\n");
-		goto exit3;
-	}
-	akm->eoc_irq = client->irq; 
-	if (!akm->eoc_irq) {
-		dev_dbg(&akm->client->dev, "no IRQ?\n");
-		return -ENODEV;
-	}else{
-		AKMDBG("gpio %d to irq %d\n", akm->eoc_irq, gpio_to_irq(akm->eoc_irq));
-		akm->eoc_irq = gpio_to_irq(akm->eoc_irq);
-	} 
-	err = gpio_request(client->irq, "ak_8975"); 
-	if (err < 0) { 
-		dev_err(&client->dev, "failed to request GPIO, error %d\n", err); 
-		goto exit3; 
-	}
-
-	err = gpio_direction_input(client->irq);
-	if (err) {
-		dev_err(&client->dev, "failed to set GPIO direction, error %d\n", err); 
-		goto exit3; 
-	}
-	gpio_pull_updown(client->irq, GPIOPullDown);
-	
-	/* IRQ */
-	err = request_irq(akm->eoc_irq, akm8975_interrupt, IRQ_TYPE_EDGE_RISING,
-					  "akm8975_DRDY", akm);
-	if (err < 0) {
-		printk(KERN_ERR "AKM8975 akm8975_probe: request irq failed\n");
-		goto exit4;
-	}
-	
-	client->irq = akm->eoc_irq;
-	
-	/* Declare input device */
-	akm->input_dev = input_allocate_device();
-	if (!akm->input_dev) {
-		err = -ENOMEM;
-		printk(KERN_ERR
-		       "AKM8975 akm8975_probe: Failed to allocate input device\n");
-		goto exit5;
-	}
-	/* Setup input device */
-	set_bit(EV_ABS, akm->input_dev->evbit);
-	/* yaw (0, 360) */
-	input_set_abs_params(akm->input_dev, ABS_RX, 0, 23040, 0, 0);
-	/* pitch (-180, 180) */
-	input_set_abs_params(akm->input_dev, ABS_RY, -11520, 11520, 0, 0);
-	/* roll (-90, 90) */
-	input_set_abs_params(akm->input_dev, ABS_RZ, -5760, 5760, 0, 0);
-	/* x-axis acceleration (720 x 8G) */
-	input_set_abs_params(akm->input_dev, ABS_X, -5760, 5760, 0, 0);
-	/* y-axis acceleration (720 x 8G) */
-	input_set_abs_params(akm->input_dev, ABS_Y, -5760, 5760, 0, 0);
-	/* z-axis acceleration (720 x 8G) */
-	input_set_abs_params(akm->input_dev, ABS_Z, -5760, 5760, 0, 0);
-	/* temparature */
-	/*
-	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
-	 */
-	/* status of magnetic sensor */
-	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
-	/* status of acceleration sensor */
-	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
-	/* x-axis of raw magnetic vector (-4096, 4095) */
-	input_set_abs_params(akm->input_dev, ABS_HAT0X, -20480, 20479, 0, 0);
-	/* y-axis of raw magnetic vector (-4096, 4095) */
-	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -20480, 20479, 0, 0);
-	/* z-axis of raw magnetic vector (-4096, 4095) */
-	input_set_abs_params(akm->input_dev, ABS_BRAKE, -20480, 20479, 0, 0);
-	/* Set name */
-	akm->input_dev->name = "compass";
-	
-	/* Register */
-	err = input_register_device(akm->input_dev);
-	if (err) {
-		printk(KERN_ERR
-		       "AKM8975 akm8975_probe: Unable to register input device\n");
-		goto exit6;
-	}
-	
-	err = misc_register(&akmd_device);
-	if (err) {
-		printk(KERN_ERR
-			   "AKM8975 akm8975_probe: akmd_device register failed\n");
-		goto exit7;
-	}
-	
-	err = misc_register(&akm_aot_device);
-	if (err) {
-		printk(KERN_ERR
-		       "AKM8975 akm8975_probe: akm_aot_device register failed\n");
-		goto exit8;
-	}
-	
-	mutex_init(&sense_data_mutex);
-	
-	init_waitqueue_head(&data_ready_wq);
-	init_waitqueue_head(&open_wq);
-	
-	/* As default, report all information */
-	atomic_set(&m_flag, 1);
-	atomic_set(&a_flag, 1);
-	atomic_set(&mv_flag, 1);
-	
-	//akm->akm_early_suspend.suspend = akm8975_early_suspend;
-	//akm->akm_early_suspend.resume = akm8975_early_resume;
-	//register_early_suspend(&akm->akm_early_suspend);
-	
-	AKMDBG("successfully probed.");
-	return 0;
-	
-exit8:
-	misc_deregister(&akmd_device);
-exit7:
-	input_unregister_device(akm->input_dev);
-exit6:
-	input_free_device(akm->input_dev);
-exit5:
-	free_irq(client->irq, akm);
-exit4:
-exit3:
-	kfree(akm);
-exit1:
-exit0:
-	return err;
-	
-}
-
-static int akm8975_remove(struct i2c_client *client)
-{
-	struct akm8975_data *akm = i2c_get_clientdata(client);
-	AKMFUNC("akm8975_remove");
-	unregister_early_suspend(&akm->akm_early_suspend);
-	misc_deregister(&akm_aot_device);
-	misc_deregister(&akmd_device);
-	input_unregister_device(akm->input_dev);
-	free_irq(client->irq, akm);
-	kfree(akm);
-	AKMDBG("successfully removed.");
-	return 0;
-}
-
-static const struct i2c_device_id akm8975_id[] = {
-	{AKM8975_I2C_NAME, 0 },
-	{ }
-};
-
-static struct i2c_driver akm8975_driver = {
-	.probe		= akm8975_probe,
-	.remove 	= akm8975_remove,
-	.suspend = akm8975_suspend,
-	.resume = akm8975_resume,
-	.id_table	= akm8975_id,
-	.driver = {
-		.name = AKM8975_I2C_NAME,
-	},
-};
-
-static int __init akm8975_init(void)
-{
-	printk(KERN_INFO "AKM8975 compass driver: initialize\n");
-	return i2c_add_driver(&akm8975_driver);
-}
-
-static void __exit akm8975_exit(void)
-{
-	printk(KERN_INFO "AKM8975 compass driver: release\n");
-	i2c_del_driver(&akm8975_driver);
-}
-
-module_init(akm8975_init);
-module_exit(akm8975_exit);
-
-MODULE_AUTHOR("viral wang <viral_wang@htc.com>");
-MODULE_DESCRIPTION("AKM8975 compass driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/input/magnetometer/ak8975.h b/drivers/input/magnetometer/ak8975.h
deleted file mode 100644
index ba7f22a54d7b..000000000000
--- a/drivers/input/magnetometer/ak8975.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Definitions for akm8975 compass chip.
- */
-#ifndef AKM8975_H
-#define AKM8975_H
-
-#include <linux/ioctl.h>
-
-#define AKM8975_I2C_NAME "ak8975"
-
-/*! \name AK8975 operation mode
- \anchor AK8975_Mode
- Defines an operation mode of the AK8975.*/
-/*! @{*/
-#define AK8975_MODE_SNG_MEASURE	0x01
-#define	AK8975_MODE_SELF_TEST	0x08
-#define	AK8975_MODE_FUSE_ACCESS	0x0F
-#define	AK8975_MODE_POWERDOWN	0x00
-/*! @}*/
-
-#define SENSOR_DATA_SIZE		8	/* Rx buffer size, i.e from ST1 to ST2 */
-#define RWBUF_SIZE				16	/* Read/Write buffer size.*/
-
-
-/*! \name AK8975 register address
-\anchor AK8975_REG
-Defines a register address of the AK8975.*/
-/*! @{*/
-#define AK8975_REG_WIA		0x00
-#define AK8975_REG_INFO		0x01
-#define AK8975_REG_ST1		0x02
-#define AK8975_REG_HXL		0x03
-#define AK8975_REG_HXH		0x04
-#define AK8975_REG_HYL		0x05
-#define AK8975_REG_HYH		0x06
-#define AK8975_REG_HZL		0x07
-#define AK8975_REG_HZH		0x08
-#define AK8975_REG_ST2		0x09
-#define AK8975_REG_CNTL		0x0A
-#define AK8975_REG_RSV		0x0B
-#define AK8975_REG_ASTC		0x0C
-#define AK8975_REG_TS1		0x0D
-#define AK8975_REG_TS2		0x0E
-#define AK8975_REG_I2CDIS	0x0F
-/*! @}*/
-
-/*! \name AK8975 fuse-rom address
-\anchor AK8975_FUSE
-Defines a read-only address of the fuse ROM of the AK8975.*/
-/*! @{*/
-#define AK8975_FUSE_ASAX	0x10
-#define AK8975_FUSE_ASAY	0x11
-#define AK8975_FUSE_ASAZ	0x12
-/*! @}*/
-
-#define AKMIO                   0xA1
-
-/* IOCTLs for AKM library */
-#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x01, char*)
-#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x02, char*)
-#define ECS_IOCTL_RESET      	        _IO(AKMIO, 0x03) /* NOT used in AK8975 */
-#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x04, short)
-#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x05, char[SENSOR_DATA_SIZE])
-#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x06, short[12])
-#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x07, int)
-#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x08, int)
-#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
-#define ECS_IOCTL_GET_PROJECT_NAME      _IOR(AKMIO, 0x0D, char[64])
-#define ECS_IOCTL_GET_MATRIX            _IOR(AKMIO, 0x0E, short [4][3][3])
-#define ECS_IOCTL_GET_PLATFORM_DATA     _IOR(AKMIO, 0x0E, struct akm8975_platform_data)
-
-
-/* IOCTLs for APPs */
-#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
-#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
-#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
-#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
-#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
-#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)/* NOT use */
-#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)/* NOT use */
-#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)	/* NOT use */
-#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
-#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
-#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)
-#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)
-
-struct akm8975_platform_data {
-	short m_layout[4][3][3];
-	char project_name[64];
-	int gpio_DRDY;
-};
-
-
-
-#endif
-
diff --git a/drivers/input/magnetometer/magnet.h b/drivers/input/magnetometer/magnet.h
deleted file mode 100644
index b7a7dda1396e..000000000000
--- a/drivers/input/magnetometer/magnet.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#include "../sysfs.h"
-
-/* Magnetometer types of attribute */
-
-#define IIO_DEV_ATTR_MAGN_X_OFFSET(_mode, _show, _store, _addr)	\
-	IIO_DEVICE_ATTR(magn_x_offset, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Y_OFFSET(_mode, _show, _store, _addr)	\
-	IIO_DEVICE_ATTR(magn_y_offset, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Z_OFFSET(_mode, _show, _store, _addr)	\
-	IIO_DEVICE_ATTR(magn_z_offset, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_X_GAIN(_mode, _show, _store, _addr)		\
-	IIO_DEVICE_ATTR(magn_x_gain, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Y_GAIN(_mode, _show, _store, _addr)		\
-	IIO_DEVICE_ATTR(magn_y_gain, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Z_GAIN(_mode, _show, _store, _addr)		\
-	IIO_DEVICE_ATTR(magn_z_gain, _mode, _show, _store, _addr)
-
-#define IIO_DEV_ATTR_MAGN_X(_show, _addr)				\
-	IIO_DEVICE_ATTR(magn_x_raw, S_IRUGO, _show, NULL, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Y(_show, _addr)				\
-	IIO_DEVICE_ATTR(magn_y_raw, S_IRUGO, _show, NULL, _addr)
-
-#define IIO_DEV_ATTR_MAGN_Z(_show, _addr)				\
-	IIO_DEVICE_ATTR(magn_z_raw, S_IRUGO, _show, NULL, _addr)
diff --git a/drivers/input/magnetometer/mmc328x.c b/drivers/input/magnetometer/mmc328x.c
deleted file mode 100755
index 234a642e7270..000000000000
--- a/drivers/input/magnetometer/mmc328x.c
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Copyright (C) 2010 MEMSIC, Inc.
- *
- * Initial Code:
- *	Robbie Cao
- * 	Dale Hou
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/jiffies.h>
-#include <linux/i2c.h>
-#include <linux/i2c-dev.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/mm.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/delay.h>
-#include <linux/sysctl.h>
-#include <asm/uaccess.h>
-
-#include "mmc328x.h"
-
-#define DEBUG			0
-#define MAX_FAILURE_COUNT	3
-#define READMD			1
-
-#define MMC328X_DELAY_TM	10	/* ms */
-#define MMC328X_DELAY_RM	10	/* ms */
-#define MMC328X_DELAY_STDN	1	/* ms */
-
-#define MMC328X_RETRY_COUNT	3
-#define MMC328X_RESET_INTV	10
-
-#define MMC328X_DEV_NAME	"mmc328x"
-
-static u32 read_idx = 0;
-
-static struct i2c_client *this_client;
-
-static int mmc328x_i2c_rx_data(char *buf, int len)
-{
-	uint8_t i;
-	struct i2c_msg msgs[] = {
-		{
-			.addr	= this_client->addr,
-			.flags	= 0,
-			.len	= 1,
-			.buf	= buf,
-			.scl_rate = 200*1000,
-			.udelay = 100,
-		},
-		{
-			.addr	= this_client->addr,
-			.flags	= I2C_M_RD,
-			.len	= len,
-			.buf	= buf,
-			.scl_rate = 200*1000,
-			.udelay = 100,
-		}
-	};
-
-	for (i = 0; i < MMC328X_RETRY_COUNT; i++) {
-		if (i2c_transfer(this_client->adapter, msgs, 2) >= 0) {
-			break;
-		}
-		mdelay(10);
-	}
-
-	if (i >= MMC328X_RETRY_COUNT) {
-		pr_err("%s: retry over %d\n", __FUNCTION__, MMC328X_RETRY_COUNT);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static int mmc328x_i2c_tx_data(char *buf, int len)
-{
-	uint8_t i;
-	struct i2c_msg msg[] = {
-		{
-			.addr	= this_client->addr,
-			.flags	= 0,
-			.len	= len,
-			.buf	= buf,
-		}
-	};
-	
-	for (i = 0; i < MMC328X_RETRY_COUNT; i++) {
-		if (i2c_transfer(this_client->adapter, msg, 1) >= 0) {
-			break;
-		}
-		mdelay(10);
-	}
-
-	if (i >= MMC328X_RETRY_COUNT) {
-		pr_err("%s: retry over %d\n", __FUNCTION__, MMC328X_RETRY_COUNT);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int mmc328x_open(struct inode *inode, struct file *file)
-{
-	return nonseekable_open(inode, file);
-}
-
-static int mmc328x_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int mmc328x_ioctl(struct inode *inode, struct file *file, 
-	unsigned int cmd, unsigned long arg)
-{
-	void __user *pa = (void __user *)arg;
-	unsigned char data[16] = {0};
-	int vec[3] = {0};
-	int MD_times = 0;
-
-	switch (cmd) {
-	case MMC328X_IOC_TM:
-		data[0] = MMC328X_REG_CTRL;
-		data[1] = MMC328X_CTRL_TM;
-		if (mmc328x_i2c_tx_data(data, 2) < 0) {
-			return -EFAULT;
-		}
-		/* wait TM done for coming data read */
-		msleep(MMC328X_DELAY_TM);
-		break;
-	case MMC328X_IOC_RM:
-		data[0] = MMC328X_REG_CTRL;
-		data[1] = MMC328X_CTRL_RM;
-		if (mmc328x_i2c_tx_data(data, 2) < 0) {
-			return -EFAULT;
-		}
-		/* wait external capacitor charging done for next SET/RESET */
-		msleep(MMC328X_DELAY_RM);
-		break;
-	case MMC328X_IOC_READ:
-		data[0] = MMC328X_REG_DATA;
-		if (mmc328x_i2c_rx_data(data, 6) < 0) {
-			return -EFAULT;
-		}
-		vec[0] = data[1] << 8 | data[0];
-		vec[1] = data[3] << 8 | data[2];
-		vec[2] = data[5] << 8 | data[4];
-	#if DEBUG
-		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
-			vec[0], vec[1], vec[2]);
-	#endif
-		if (copy_to_user(pa, vec, sizeof(vec))) {
-			return -EFAULT;
-		}
-		break;
-	case MMC328X_IOC_READXYZ:
-		/* do RM every MMC328X_RESET_INTV times read */
-		if (!(read_idx % MMC328X_RESET_INTV)) {
-			/* RM */
-			data[0] = MMC328X_REG_CTRL;
-			data[1] = MMC328X_CTRL_RM;
-			/* not check return value here, assume it always OK */
-			mmc328x_i2c_tx_data(data, 2);
-			/* wait external capacitor charging done for next RM */
-			msleep(MMC328X_DELAY_RM);
-		}
-		/* send TM cmd before read */
-		data[0] = MMC328X_REG_CTRL;
-		data[1] = MMC328X_CTRL_TM;
-		/* not check return value here, assume it always OK */
-		mmc328x_i2c_tx_data(data, 2);
-		/* wait TM done for coming data read */
-		msleep(MMC328X_DELAY_TM);
-#if READMD
-		/* Read MD */
-		data[0] = MMC328X_REG_DS;
-		if (mmc328x_i2c_rx_data(data, 1) < 0) {
-			return -EFAULT;
-		}
-		while (!(data[0] & 0x01)) {
-			msleep(1);
-			/* Read MD again*/
-			data[0] = MMC328X_REG_DS;
-			if (mmc328x_i2c_rx_data(data, 1) < 0) {
-				return -EFAULT;
-			}
-			if (data[0] & 0x01) break;
-			MD_times++;
-			if (MD_times > 2) {
-		#if DEBUG
-				printk("TM not work!!");
-		#endif
-				return -EFAULT;
-			}
-		}
-#endif		
-		/* read xyz raw data */
-		read_idx++;
-		data[0] = MMC328X_REG_DATA;
-		if (mmc328x_i2c_rx_data(data, 6) < 0) {
-			return -EFAULT;
-		}
-		vec[0] = data[1] << 8 | data[0];
-		vec[1] = data[3] << 8 | data[2];
-		vec[2] = data[5] << 8 | data[4];
-	#if DEBUG
-		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
-			vec[0], vec[1], vec[2]);
-	#endif
-		if (copy_to_user(pa, vec, sizeof(vec))) {
-			return -EFAULT;
-		}
-
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static ssize_t mmc328x_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	ssize_t ret = 0;
-
-	sprintf(buf, "MMC328X");
-	ret = strlen(buf) + 1;
-
-	return ret;
-}
-
-static DEVICE_ATTR(mmc328x, S_IRUGO, mmc328x_show, NULL);
-
-static struct file_operations mmc328x_fops = {
-	.owner		= THIS_MODULE,
-	.open		= mmc328x_open,
-	.release	= mmc328x_release,
-	.ioctl		= mmc328x_ioctl,
-};
-
-static struct miscdevice mmc328x_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = MMC328X_DEV_NAME,
-	.fops = &mmc328x_fops,
-};
-
-static int mmc328x_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	unsigned char data[16] = {0};
-	int res = 0;
-
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		pr_err("%s: functionality check failed\n", __FUNCTION__);
-		res = -ENODEV;
-		goto out;
-	}
-	this_client = client;
-
-	res = misc_register(&mmc328x_device);
-	if (res) {
-		pr_err("%s: mmc328x_device register failed\n", __FUNCTION__);
-		goto out;
-	}
-	res = device_create_file(&client->dev, &dev_attr_mmc328x);
-	if (res) {
-		pr_err("%s: device_create_file failed\n", __FUNCTION__);
-		goto out_deregister;
-	}
-
-	/* send ST cmd to mag sensor first of all */
-	data[0] = MMC328X_REG_CTRL;
-	data[1] = MMC328X_CTRL_RM;
-	if (mmc328x_i2c_tx_data(data, 2) < 0) {
-		/* assume RM always success */
-	}
-	/* wait external capacitor charging done for next RM */
-	msleep(MMC328X_DELAY_RM);
-
-	return 0;
-
-out_deregister:
-	misc_deregister(&mmc328x_device);
-out:
-	return res;
-}
-
-static int mmc328x_remove(struct i2c_client *client)
-{
-	device_remove_file(&client->dev, &dev_attr_mmc328x);
-	misc_deregister(&mmc328x_device);
-
-	return 0;
-}
-
-static const struct i2c_device_id mmc328x_id[] = {
-	{ MMC328X_I2C_NAME, 0 },
-	{ }
-};
-
-static struct i2c_driver mmc328x_driver = {
-	.probe 		= mmc328x_probe,
-	.remove 	= mmc328x_remove,
-	.id_table	= mmc328x_id,
-	.driver 	= {
-		.owner	= THIS_MODULE,
-		.name	= MMC328X_I2C_NAME,
-	},
-};
-
-
-static int __init mmc328x_init(void)
-{
-	pr_info("mmc328x driver: init\n");
-	return i2c_add_driver(&mmc328x_driver);
-}
-
-static void __exit mmc328x_exit(void)
-{
-	pr_info("mmc328x driver: exit\n");
-	i2c_del_driver(&mmc328x_driver);
-}
-
-module_init(mmc328x_init);
-module_exit(mmc328x_exit);
-
-MODULE_AUTHOR("Dale Hou<byhou@memsic.com>");
-MODULE_DESCRIPTION("MEMSIC MMC328X Magnetic Sensor Driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/input/magnetometer/mmc328x.h b/drivers/input/magnetometer/mmc328x.h
deleted file mode 100755
index 3d21498a1e4a..000000000000
--- a/drivers/input/magnetometer/mmc328x.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2010 MEMSIC, Inc.
- *
- * Initial Code:
- *	Robbie Cao
- *	Dale Hou
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-/*
- * Definitions for mmc328x magnetic sensor chip.
- */
-#ifndef __MMC328X_H__
-#define __MMC328X_H__
-
-#include <linux/ioctl.h>
-
-#define MMC328X_I2C_NAME		"mmc328x"
-
-/*
- * This address comes must match the part# on your target.
- * Address to the sensor part# support as following list:
- *	MMC3280MS - 0110000b
- *	MMC3281MS - 0110001b
- *	MMC3282MS - 0110010b
- *	MMC3283MS - 0110011b
- *	MMC3284MS - 0110100b
- *	MMC3285MS - 0110101b
- *	MMC3286MS - 0110110b
- *	MMC3287MS - 0110111b
- * Please refer to sensor datasheet for detail.
- */
-#define MMC328X_I2C_ADDR		0x30
-
-/* MMC328X register address */
-#define MMC328X_REG_CTRL		0x07
-#define MMC328X_REG_DATA		0x00
-#define MMC328X_REG_DS			0x06
-
-/* MMC328X control bit */
-#define MMC328X_CTRL_TM			0x01
-#define MMC328X_CTRL_RM			0x20
-
-/* Use 'm' as magic number */
-#define MMC328X_IOM			'm'
-
-/* IOCTLs for MMC328X device */
-#define MMC328X_IOC_TM			_IO (MMC328X_IOM, 0x00)
-#define MMC328X_IOC_RM			_IO (MMC328X_IOM, 0x01)
-#define MMC328X_IOC_READ		_IOR(MMC328X_IOM, 0x02, int[3])
-#define MMC328X_IOC_READXYZ		_IOR(MMC328X_IOM, 0x03, int[3])
-
-#endif /* __MMC328X_H__ */
-
-- 
2.35.3

