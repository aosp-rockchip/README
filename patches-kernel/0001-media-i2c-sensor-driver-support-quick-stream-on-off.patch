From 97365bb2d2c821314238a208f3afdc8a6a43de73 Mon Sep 17 00:00:00 2001
From: Zefa Chen <zefa.chen@rock-chips.com>
Date: Thu, 29 Oct 2020 20:16:03 +0800
Subject: [PATCH] media: i2c: sensor driver support quick stream on/off

Signed-off-by: Zefa Chen <zefa.chen@rock-chips.com>
Change-Id: Ic22acdf7617458d3a27eeb040e14ed60e05e1c90
---
 drivers/media/i2c/ar0230.c   | 19 ++++++++++++++++-
 drivers/media/i2c/bf3925.c   | 17 ++++++++++++++-
 drivers/media/i2c/gc0312.c   | 19 ++++++++++++++++-
 drivers/media/i2c/gc0329.c   | 16 +++++++++++++-
 drivers/media/i2c/gc032a.c   | 20 +++++++++++++++++-
 drivers/media/i2c/gc0403.c   | 24 ++++++++++++++++++++-
 drivers/media/i2c/gc2035.c   | 16 +++++++++++++-
 drivers/media/i2c/gc2053.c   | 21 +++++++++++++++++-
 drivers/media/i2c/gc2093.c   | 18 ++++++++++++++++
 drivers/media/i2c/gc2145.c   | 16 +++++++++++++-
 drivers/media/i2c/gc2355.c   | 26 ++++++++++++++++++++++-
 drivers/media/i2c/gc2375h.c  | 26 ++++++++++++++++++++++-
 drivers/media/i2c/gc2385.c   | 28 +++++++++++++++++++++++-
 drivers/media/i2c/gc4c33.c   | 19 ++++++++++++++++-
 drivers/media/i2c/gc5024.c   | 26 ++++++++++++++++++++++-
 drivers/media/i2c/gc5025.c   | 30 +++++++++++++++++++++++++-
 drivers/media/i2c/gc5035.c   | 30 +++++++++++++++++++++++++-
 drivers/media/i2c/gc8034.c   | 30 +++++++++++++++++++++++++-
 drivers/media/i2c/imx258.c   | 25 +++++++++++++++++++++-
 drivers/media/i2c/imx307.c   | 25 +++++++++++++++++++++-
 drivers/media/i2c/imx317.c   | 21 +++++++++++++++++-
 drivers/media/i2c/imx323.c   | 21 +++++++++++++++++-
 drivers/media/i2c/imx327.c   | 25 +++++++++++++++++++++-
 drivers/media/i2c/imx334.c   | 41 ++++++++++++++++++++++++++----------
 drivers/media/i2c/imx335.c   | 21 +++++++++++++++++-
 drivers/media/i2c/imx378.c   | 41 ++++++++++++++++++++++++++----------
 drivers/media/i2c/imx415.c   | 10 ++-------
 drivers/media/i2c/jx_h65.c   | 21 +++++++++++++++++-
 drivers/media/i2c/os04a10.c  | 21 +++++++++++++++++-
 drivers/media/i2c/ov02k10.c  | 21 +++++++++++++++++-
 drivers/media/i2c/ov13850.c  | 25 +++++++++++++++++++++-
 drivers/media/i2c/ov2680.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov2685.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov2718.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov2735.c   | 22 ++++++++++++++++++-
 drivers/media/i2c/ov4689.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov5648.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov5670.c   | 23 ++++++++++++++++++--
 drivers/media/i2c/ov5695.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov7251.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov7750.c   | 25 +++++++++++++++++++++-
 drivers/media/i2c/ov8858.c   | 25 +++++++++++++++++++++-
 drivers/media/i2c/ov9281.c   | 21 +++++++++++++++++-
 drivers/media/i2c/ov9750.c   | 21 +++++++++++++++++-
 drivers/media/i2c/sc031gs.c  | 21 +++++++++++++++++-
 drivers/media/i2c/sc132gs.c  | 21 +++++++++++++++++-
 drivers/media/i2c/sc200ai.c  | 21 +++++++++++++++++-
 drivers/media/i2c/sc210iot.c | 23 +++++++++++++++++++-
 drivers/media/i2c/sc2239.c   |  3 +--
 drivers/media/i2c/sc4238.c   | 21 +++++++++++++++++-
 50 files changed, 1035 insertions(+), 78 deletions(-)

diff --git a/drivers/media/i2c/ar0230.c b/drivers/media/i2c/ar0230.c
index b66226b19cd8..dae7096f3273 100644
--- a/drivers/media/i2c/ar0230.c
+++ b/drivers/media/i2c/ar0230.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -23,7 +24,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x01)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1017,11 +1018,21 @@ static long ar0230_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ar0230 *ar0230 = to_ar0230(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ar0230_get_module_inf(ar0230, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		stream = *((u32 *)arg);
+		if (stream)
+			ret = ar0230_write_reg(ar0230->client, AR0230_REG_CTRL_MODE,
+				AR0230_REG_VALUE_16BIT, AR0230_MODE_STREAMING);
+		else
+			ret = ar0230_write_reg(ar0230->client, AR0230_REG_CTRL_MODE,
+				AR0230_REG_VALUE_16BIT, AR0230_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1037,6 +1048,7 @@ static long ar0230_compat_ioctl32(struct v4l2_subdev *sd,
 	void __user *up = compat_ptr(arg);
 	struct rkmodule_inf *inf;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1051,6 +1063,11 @@ static long ar0230_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = copy_to_user(up, inf, sizeof(*inf));
 		kfree(inf);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ar0230_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/bf3925.c b/drivers/media/i2c/bf3925.c
index f220f0bd7f6b..ca58e5282164 100644
--- a/drivers/media/i2c/bf3925.c
+++ b/drivers/media/i2c/bf3925.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -37,7 +38,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 #define DRIVER_NAME "bf3925"
 #define BF3925_PIXEL_RATE		(120 * 1000 * 1000)
 
@@ -1041,11 +1042,19 @@ static long bf3925_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct bf3925 *bf3925 = to_bf3925(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		bf3925_get_module_inf(bf3925, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		stream = *((u32 *)arg);
+		if (stream)
+			bf3925_set_streaming(bf3925, 0x00);
+		else
+			bf3925_set_streaming(bf3925, 0x02);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1062,6 +1071,7 @@ static long bf3925_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1088,6 +1098,11 @@ static long bf3925_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = bf3925_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = bf3925_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc0312.c b/drivers/media/i2c/gc0312.c
index df933405599f..acf52fbbfe5b 100644
--- a/drivers/media/i2c/gc0312.c
+++ b/drivers/media/i2c/gc0312.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 #define DRIVER_NAME "gc0312"
 #define GC0312_PIXEL_RATE		(96 * 1000 * 1000)
 
@@ -747,11 +748,21 @@ static long gc0312_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc0312 *gc0312 = to_gc0312(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc0312_get_module_inf(gc0312, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			gc0312_set_streaming(gc0312, 0xff);
+		else
+			gc0312_set_streaming(gc0312, 0x00);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -768,6 +779,7 @@ static long gc0312_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -794,6 +806,11 @@ static long gc0312_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc0312_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc0312_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc0329.c b/drivers/media/i2c/gc0329.c
index 45fa4b6296e5..266c18ae157a 100644
--- a/drivers/media/i2c/gc0329.c
+++ b/drivers/media/i2c/gc0329.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 #define DRIVER_NAME "gc0329"
 #define GC0329_PIXEL_RATE		(24 * 1000 * 1000)
 
@@ -680,11 +681,18 @@ static long gc0329_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc0329 *gc0329 = to_gc0329(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc0329_get_module_inf(gc0329, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		gc0329_set_streaming(gc0329, !!stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -701,6 +709,7 @@ static long gc0329_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -727,6 +736,11 @@ static long gc0329_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc0329_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc0329_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc032a.c b/drivers/media/i2c/gc032a.c
index 2b7c6f710294..01caa179fe33 100644
--- a/drivers/media/i2c/gc032a.c
+++ b/drivers/media/i2c/gc032a.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 init driver.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 #define DRIVER_NAME "gc032a"
 #define GC032A_PIXEL_RATE		(96 * 1000 * 1000)
 //#define GC032A_AUTO_FPS
@@ -752,11 +753,21 @@ static long gc032a_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc032a *gc032a = to_gc032a(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc032a_get_module_inf(gc032a, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			gc032a_set_streaming(gc032a, 0xff);
+		else
+			gc032a_set_streaming(gc032a, 0x00);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -773,6 +784,7 @@ static long gc032a_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -799,6 +811,11 @@ static long gc032a_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc032a_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc032a_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -824,6 +841,7 @@ static int gc032a_s_stream(struct v4l2_subdev *sd, int on)
 		/* Stop Streaming Sequence */
 		gc032a_set_streaming(gc032a, 0x00);
 		gc032a->streaming = on;
+		goto unlock;
 	}
 
 	gc032a_set_streaming(gc032a, 0xFF);
diff --git a/drivers/media/i2c/gc0403.c b/drivers/media/i2c/gc0403.c
index cfdb119a53ee..5664719daf89 100644
--- a/drivers/media/i2c/gc0403.c
+++ b/drivers/media/i2c/gc0403.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2019 Fuzhou Rockchip Electronics Co.,Ltd.
  * V0.0X01.0X02 add enum_frame_interval function.
+ * V0.0X01.0X03 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -69,7 +70,7 @@
 #define GC0403_EXPOSURE_MIN		1
 
 #define GC0403_NAME			"gc0403"
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
 
 #define GC0403_XVCLK_FREQ		24000000
 #define GC0403_LINK_FREQ		96000000
@@ -631,11 +632,26 @@ static long gc0403_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc0403 *gc0403 = to_gc0403(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc0403_get_module_inf(gc0403, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc0403_write_reg(gc0403->client, PAGE_SELECT_REG, 0x03);
+			ret |= gc0403_write_reg(gc0403->client, GC0403_REG_MIPI_EN, 0x90);
+			ret |= gc0403_write_reg(gc0403->client, PAGE_SELECT_REG, 0x00);
+		} else {
+			ret = gc0403_write_reg(gc0403->client, PAGE_SELECT_REG, 0x03);
+			ret |= gc0403_write_reg(gc0403->client, GC0403_REG_MIPI_EN, 0x80);
+			ret |= gc0403_write_reg(gc0403->client, PAGE_SELECT_REG, 0x00);
+		}
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -652,6 +668,7 @@ static long gc0403_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -685,6 +702,11 @@ static long gc0403_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = -EFAULT;
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc0403_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2035.c b/drivers/media/i2c/gc2035.c
index 7fae387d76cf..706c2ecbc5c8 100644
--- a/drivers/media/i2c/gc2035.c
+++ b/drivers/media/i2c/gc2035.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 #define DRIVER_NAME "gc2035"
 #define GC2035_PIXEL_RATE		(70 * 1000 * 1000)
 
@@ -1217,11 +1218,18 @@ static long gc2035_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc2035 *gc2035 = to_gc2035(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc2035_get_module_inf(gc2035, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		gc2035_set_streaming(gc2035, !!stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1238,6 +1246,7 @@ static long gc2035_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1264,6 +1273,11 @@ static long gc2035_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2035_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2035_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2053.c b/drivers/media/i2c/gc2053.c
index f24f19111b8e..3af9e6f0e71f 100644
--- a/drivers/media/i2c/gc2053.c
+++ b/drivers/media/i2c/gc2053.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
  *
  * V0.0X01.0X00 first version.
+ * V0.0X01.0X01 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -34,7 +35,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION          KERNEL_VERSION(0, 0x01, 0x00)
+#define DRIVER_VERSION          KERNEL_VERSION(0, 0x01, 0x01)
 #define GC2053_NAME             "gc2053"
 #define GC2053_MEDIA_BUS_FMT    MEDIA_BUS_FMT_SGRBG10_1X10
 
@@ -882,6 +883,7 @@ static long gc2053_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct gc2053 *gc2053 = to_gc2053(sd);
 	long ret = 0;
 	struct rkmodule_hdr_cfg *hdr_cfg;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_HDR_CFG:
@@ -901,6 +903,17 @@ static long gc2053_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_LSC_CFG:
 		gc2053_set_lsc_cfg(gc2053, (struct rkmodule_lsc_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = gc2053_write_reg(gc2053->client, GC2053_REG_CTRL_MODE,
+					       GC2053_MODE_STREAMING);
+		else
+			ret = gc2053_write_reg(gc2053->client, GC2053_REG_CTRL_MODE,
+					       GC2053_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -919,6 +932,7 @@ static long gc2053_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	long ret = 0;
 	u32 cg = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -986,6 +1000,11 @@ static long gc2053_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = gc2053_ioctl(sd, cmd, &cg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2053_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/gc2093.c b/drivers/media/i2c/gc2093.c
index 635a9b568f36..9bc4c81a04ed 100644
--- a/drivers/media/i2c/gc2093.c
+++ b/drivers/media/i2c/gc2093.c
@@ -758,6 +758,7 @@ static long gc2093_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr_cfg;
 	long ret = 0;
 	u32 i, h, w;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -813,6 +814,17 @@ static long gc2093_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_GET_MODULE_INFO:
 		gc2093_get_module_inf(gc2093, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = gc2093_write_reg(gc2093, GC2093_REG_CTRL_MODE,
+				GC2093_MODE_STREAMING);
+		else
+			ret = gc2093_write_reg(gc2093, GC2093_REG_CTRL_MODE,
+				GC2093_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -864,6 +876,7 @@ static long gc2093_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -914,6 +927,11 @@ static long gc2093_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2093_ioctl(sd, cmd, hdrae);
 		kfree(hdrae);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2093_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2145.c b/drivers/media/i2c/gc2145.c
index 283618ce3397..bb7388e0821f 100644
--- a/drivers/media/i2c/gc2145.c
+++ b/drivers/media/i2c/gc2145.c
@@ -10,6 +10,7 @@
  * V0.0X01.0X03 fix gc2145 exposure issues.
  * V0.0X01.0X04 add enum_frame_interval function.
  * V0.0X01.0X05 reduce rkisp1: CIF_ISP_PIC_SIZE_ERROR 0x00000001.
+ * V0.0X01.0X06 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -41,7 +42,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x5)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x6)
 #define DRIVER_NAME "gc2145"
 #define GC2145_PIXEL_RATE		(120 * 1000 * 1000)
 
@@ -2543,11 +2544,18 @@ static long gc2145_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc2145 *gc2145 = to_gc2145(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc2145_get_module_inf(gc2145, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		gc2145_set_streaming(gc2145, !!stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -2564,6 +2572,7 @@ static long gc2145_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -2590,6 +2599,11 @@ static long gc2145_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2145_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2145_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2355.c b/drivers/media/i2c/gc2355.c
index ef4d0fbd749d..33873b6cd727 100644
--- a/drivers/media/i2c/gc2355.c
+++ b/drivers/media/i2c/gc2355.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 #define DEBUG 1
 #include <linux/clk.h>
@@ -25,7 +26,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x3)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x4)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -538,11 +539,28 @@ static long gc2355_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc2355 *gc2355 = to_gc2355(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc2355_get_module_inf(gc2355, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc2355_write_reg(gc2355->client, GC2355_PAGE_SELECT, 0x03);
+			ret |= gc2355_write_reg(gc2355->client, GC2355_MODE_SELECT,
+						GC2355_MODE_STREAMING);
+			ret |= gc2355_write_reg(gc2355->client, GC2355_PAGE_SELECT, 0x00);
+		} else {
+			ret = gc2355_write_reg(gc2355->client, GC2355_PAGE_SELECT, 0x03);
+			ret |= gc2355_write_reg(gc2355->client, GC2355_MODE_SELECT,
+						GC2355_MODE_SW_STANDBY);
+			ret |= gc2355_write_reg(gc2355->client, GC2355_PAGE_SELECT, 0x00);
+		}
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -559,6 +577,7 @@ static long gc2355_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -585,6 +604,11 @@ static long gc2355_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2355_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2355_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2375h.c b/drivers/media/i2c/gc2375h.c
index 8ab7b6025439..ec7f9acf03aa 100644
--- a/drivers/media/i2c/gc2375h.c
+++ b/drivers/media/i2c/gc2375h.c
@@ -8,6 +8,7 @@
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
  * TODO: add OTP function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 //#define DEBUG 1
@@ -33,7 +34,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x3)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x4)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -671,11 +672,28 @@ static long gc2375h_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc2375h *gc2375h = to_gc2375h(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc2375h_get_module_inf(gc2375h, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc2375h_write_reg(gc2375h->client, GC2375H_PAGE_SELECT, 0x00);
+			ret |= gc2375h_write_reg(gc2375h->client, GC2375H_MODE_SELECT,
+						 GC2375H_MODE_STREAMING);
+			ret |= gc2375h_write_reg(gc2375h->client, GC2375H_PAGE_SELECT, 0x00);
+		} else {
+			ret = gc2375h_write_reg(gc2375h->client, GC2375H_PAGE_SELECT, 0x00);
+			ret |= gc2375h_write_reg(gc2375h->client, GC2375H_MODE_SELECT,
+						 GC2375H_MODE_SW_STANDBY);
+			ret |= gc2375h_write_reg(gc2375h->client, GC2375H_PAGE_SELECT, 0x00);
+		}
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -692,6 +710,7 @@ static long gc2375h_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -718,6 +737,11 @@ static long gc2375h_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2375h_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2375h_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc2385.c b/drivers/media/i2c/gc2385.c
index 67fd8c518887..4de65b7d5c97 100644
--- a/drivers/media/i2c/gc2385.c
+++ b/drivers/media/i2c/gc2385.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -461,11 +462,30 @@ static long gc2385_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc2385 *gc2385 = to_gc2385(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc2385_get_module_inf(gc2385, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc2385_write_reg(gc2385->client,
+				 GC2385_REG_SET_PAGE,
+				 GC2385_SET_PAGE_ONE);
+			ret |= gc2385_write_reg(gc2385->client,
+				 GC2385_REG_CTRL_MODE,
+				 GC2385_MODE_STREAMING);
+		} else {
+			ret = gc2385_write_reg(gc2385->client,
+				 GC2385_REG_SET_PAGE, GC2385_SET_PAGE_ONE);
+			ret |= gc2385_write_reg(gc2385->client,
+				 GC2385_REG_CTRL_MODE, GC2385_MODE_SW_STANDBY);
+		}
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -482,6 +502,7 @@ static long gc2385_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -508,6 +529,11 @@ static long gc2385_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc2385_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc2385_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc4c33.c b/drivers/media/i2c/gc4c33.c
index 484a80fc72e9..01f0cd2f58df 100644
--- a/drivers/media/i2c/gc4c33.c
+++ b/drivers/media/i2c/gc4c33.c
@@ -12,6 +12,7 @@
  * V0.0X01.0X06 add set dpc cfg.
  * V0.0X01.0X07 support enum sensor fmt
  * V0.0X01.0X08 support mirror and flip
+ * V0.0X01.0X09 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -33,7 +34,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x08)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x09)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1546,6 +1547,7 @@ static long gc4c33_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_nr_switch_threshold *nr_switch;
 	u32 i, h, w;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1598,6 +1600,15 @@ static long gc4c33_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		nr_switch->div_coeff = 100;
 		ret = 0;
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		stream = *((u32 *)arg);
+		if (stream)
+			ret = gc4c33_write_reg(gc4c33->client, GC4C33_REG_CTRL_MODE,
+				GC4C33_REG_VALUE_08BIT, GC4C33_MODE_STREAMING);
+		else
+			ret = gc4c33_write_reg(gc4c33->client, GC4C33_REG_CTRL_MODE,
+				GC4C33_REG_VALUE_08BIT, GC4C33_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1618,6 +1629,7 @@ static long gc4c33_compat_ioctl32(struct v4l2_subdev *sd,
 	struct preisp_hdrae_exp_s *hdrae;
 	struct rkmodule_nr_switch_threshold *nr_switch;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1704,6 +1716,11 @@ static long gc4c33_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = copy_to_user(up, nr_switch, sizeof(*nr_switch));
 		kfree(nr_switch);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc4c33_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc5024.c b/drivers/media/i2c/gc5024.c
index ff64af7532bc..c2d751e855bb 100644
--- a/drivers/media/i2c/gc5024.c
+++ b/drivers/media/i2c/gc5024.c
@@ -8,6 +8,7 @@
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
  * TODO: add OTP function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -32,7 +33,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 //#define IMAGE_NORMAL
 #define IMAGE_H_MIRROR
@@ -565,11 +566,28 @@ static long gc5024_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc5024 *gc5024 = to_gc5024(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		gc5024_get_module_inf(gc5024, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc5024_write_reg(gc5024->client, GC5024_PAGE_SELECT, 0x03);
+			ret |= gc5024_write_reg(gc5024->client, GC5024_MODE_SELECT,
+						GC5024_MODE_STREAMING);
+			ret = gc5024_write_reg(gc5024->client, GC5024_PAGE_SELECT, 0x00);
+		} else {
+			ret = gc5024_write_reg(gc5024->client, GC5024_PAGE_SELECT, 0x03);
+			ret |= gc5024_write_reg(gc5024->client, GC5024_MODE_SELECT,
+						GC5024_MODE_SW_STANDBY);
+			ret |= gc5024_write_reg(gc5024->client, GC5024_PAGE_SELECT, 0x00);
+		}
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -586,6 +604,7 @@ static long gc5024_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -612,6 +631,11 @@ static long gc5024_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc5024_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc5024_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/gc5025.c b/drivers/media/i2c/gc5025.c
index 8f59bcd00060..e0716c71676d 100644
--- a/drivers/media/i2c/gc5025.c
+++ b/drivers/media/i2c/gc5025.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -968,6 +969,7 @@ static long gc5025_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc5025 *gc5025 = to_gc5025(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -976,6 +978,26 @@ static long gc5025_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_AWB_CFG:
 		gc5025_set_module_inf(gc5025, (struct rkmodule_awb_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc5025_write_reg(gc5025->client,
+					       GC5025_REG_SET_PAGE,
+					       GC5025_SET_PAGE_ONE);
+			ret |= gc5025_write_reg(gc5025->client,
+						GC5025_REG_CTRL_MODE,
+						GC5025_MODE_STREAMING);
+		} else {
+			ret = gc5025_write_reg(gc5025->client,
+					       GC5025_REG_SET_PAGE,
+					       GC5025_SET_PAGE_ONE);
+			ret |= gc5025_write_reg(gc5025->client,
+						GC5025_REG_CTRL_MODE,
+						GC5025_MODE_SW_STANDBY);
+		}
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -992,6 +1014,7 @@ static long gc5025_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1018,6 +1041,11 @@ static long gc5025_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc5025_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc5025_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/gc5035.c b/drivers/media/i2c/gc5035.c
index c869230c1eb6..d3e0cf144406 100644
--- a/drivers/media/i2c/gc5035.c
+++ b/drivers/media/i2c/gc5035.c
@@ -9,6 +9,7 @@
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
  * V0.0X01.0X04 fix vb and gain set issues.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -33,7 +34,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -641,6 +642,7 @@ static long gc5035_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc5035 *gc5035 = to_gc5035(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -649,6 +651,26 @@ static long gc5035_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_AWB_CFG:
 		gc5035_set_module_inf(gc5035, (struct rkmodule_awb_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc5035_write_reg(gc5035->client,
+					       GC5035_REG_SET_PAGE,
+					       GC5035_SET_PAGE_ONE);
+			ret |= gc5035_write_reg(gc5035->client,
+						GC5035_REG_CTRL_MODE,
+						GC5035_MODE_STREAMING);
+		} else {
+			ret = gc5035_write_reg(gc5035->client,
+					       GC5035_REG_SET_PAGE,
+					       GC5035_SET_PAGE_ONE);
+			ret |= gc5035_write_reg(gc5035->client,
+						GC5035_REG_CTRL_MODE,
+						GC5035_MODE_SW_STANDBY);
+		}
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -665,6 +687,7 @@ static long gc5035_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -691,6 +714,11 @@ static long gc5035_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc5035_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc5035_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/gc8034.c b/drivers/media/i2c/gc8034.c
index e636625a5e81..1f14e289edea 100644
--- a/drivers/media/i2c/gc8034.c
+++ b/drivers/media/i2c/gc8034.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1207,6 +1208,7 @@ static long gc8034_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct gc8034 *gc8034 = to_gc8034(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1215,6 +1217,26 @@ static long gc8034_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_AWB_CFG:
 		gc8034_set_module_inf(gc8034, (struct rkmodule_awb_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = gc8034_write_reg(gc8034->client,
+					       GC8034_REG_SET_PAGE,
+					       GC8034_SET_PAGE_ZERO);
+			ret |= gc8034_write_reg(gc8034->client,
+						GC8034_REG_CTRL_MODE,
+						GC8034_MODE_STREAMING);
+		} else {
+			ret = gc8034_write_reg(gc8034->client,
+					       GC8034_REG_SET_PAGE,
+					       GC8034_SET_PAGE_ZERO);
+			ret |= gc8034_write_reg(gc8034->client,
+						GC8034_REG_CTRL_MODE,
+						GC8034_MODE_SW_STANDBY);
+		}
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -1231,6 +1253,7 @@ static long gc8034_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1257,6 +1280,11 @@ static long gc8034_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = gc8034_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = gc8034_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/imx258.c b/drivers/media/i2c/imx258.c
index f3cd44566d0d..3135a09725f4 100644
--- a/drivers/media/i2c/imx258.c
+++ b/drivers/media/i2c/imx258.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <linux/pinctrl/consumer.h>
 #include "imx258_eeprom_head.h"
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -989,6 +990,7 @@ static long imx258_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct imx258 *imx258 = to_imx258(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1000,6 +1002,21 @@ static long imx258_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_LSC_CFG:
 		imx258_set_lsc_cfg(imx258, (struct rkmodule_lsc_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx258_write_reg(imx258->client,
+					       IMX258_REG_CTRL_MODE,
+					       IMX258_REG_VALUE_08BIT,
+					       IMX258_MODE_STREAMING);
+		else
+			ret = imx258_write_reg(imx258->client,
+					       IMX258_REG_CTRL_MODE,
+					       IMX258_REG_VALUE_08BIT,
+					       IMX258_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -1017,6 +1034,7 @@ static long imx258_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_awb_cfg *awb_cfg;
 	struct rkmodule_lsc_cfg *lsc_cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1055,6 +1073,11 @@ static long imx258_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = imx258_ioctl(sd, cmd, lsc_cfg);
 		kfree(lsc_cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx258_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/imx307.c b/drivers/media/i2c/imx307.c
index 4f75c3b81eec..fb00488e93ad 100644
--- a/drivers/media/i2c/imx307.c
+++ b/drivers/media/i2c/imx307.c
@@ -11,6 +11,7 @@
  * v1.0x01.0x03 update frame rate from 25fps to 30fps
  * v1.0x01.0x04 update max exposure and formula
  *	shs1 = vts - (line + 1)
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
 #endif
@@ -1116,6 +1117,7 @@ static long imx307_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	long ret = 0;
 	s64 dst_pixel_rate = 0;
 	s32 dst_link_freq = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1177,6 +1179,21 @@ static long imx307_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		else
 			ret = -ENOIOCTLCMD;
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx307_write_reg(imx307->client,
+					       IMX307_REG_CTRL_MODE,
+					       IMX307_REG_VALUE_08BIT,
+					       0);
+		else
+			ret = imx307_write_reg(imx307->client,
+					       IMX307_REG_CTRL_MODE,
+					       IMX307_REG_VALUE_08BIT,
+					       1);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1195,6 +1212,7 @@ static long imx307_compat_ioctl32(struct v4l2_subdev *sd,
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
 	u32 cg = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1261,6 +1279,11 @@ static long imx307_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = imx307_ioctl(sd, cmd, &cg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx307_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx317.c b/drivers/media/i2c/imx317.c
index 176f1ce756cb..22eb4bdd2fc5 100644
--- a/drivers/media/i2c/imx317.c
+++ b/drivers/media/i2c/imx317.c
@@ -8,6 +8,7 @@
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
  * V0.0X01.0X04 adjust exposue and gain control issues.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -31,7 +32,7 @@
 #include <linux/of_graph.h>
 #include <media/v4l2-fwnode.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -864,11 +865,23 @@ static long imx317_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct imx317 *imx317 = to_imx317(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		imx317_get_module_inf(imx317, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			imx317_write_reg(imx317->client, IMX317_REG_CTRL_MODE,
+				IMX317_REG_VALUE_08BIT, IMX317_MODE_STREAMING);
+		else
+			imx317_write_reg(imx317->client, IMX317_REG_CTRL_MODE,
+				IMX317_REG_VALUE_08BIT, IMX317_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -885,6 +898,7 @@ static long imx317_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -911,6 +925,11 @@ static long imx317_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = imx317_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx317_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx323.c b/drivers/media/i2c/imx323.c
index 16315ca5d34e..a30acb6d2e10 100644
--- a/drivers/media/i2c/imx323.c
+++ b/drivers/media/i2c/imx323.c
@@ -6,6 +6,7 @@
  *
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 add enum_frame_interval function.
+ * V0.0X01.0X03 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -25,7 +26,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -402,11 +403,23 @@ static long imx323_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct imx323 *imx323 = to_imx323(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		imx323_get_module_inf(imx323, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			imx323_write_reg(imx323->client, IMX323_REG_CTRL_MODE,
+				IMX323_REG_VALUE_08BIT, IMX323_MODE_STREAMING);
+		else
+			imx323_write_reg(imx323->client, IMX323_REG_CTRL_MODE,
+				IMX323_REG_VALUE_08BIT, IMX323_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -423,6 +436,7 @@ static long imx323_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -449,6 +463,11 @@ static long imx323_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = imx323_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx323_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx327.c b/drivers/media/i2c/imx327.c
index 371d5af169f9..5ee75c6ca32b 100644
--- a/drivers/media/i2c/imx327.c
+++ b/drivers/media/i2c/imx327.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
  * V0.0X01.0X03 add enum_frame_interval function.
  * V0.0X01.0X04 support lvds interface.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -29,7 +30,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
 #endif
@@ -1087,6 +1088,7 @@ static long imx327_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	long ret = 0;
 	s64 dst_pixel_rate = 0;
 	s32 dst_link_freq = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1148,6 +1150,21 @@ static long imx327_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		else
 			ret = -ENOIOCTLCMD;
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx327_write_reg(imx327->client,
+					       IMX327_REG_CTRL_MODE,
+					       IMX327_REG_VALUE_08BIT,
+					       0);
+		else
+			ret = imx327_write_reg(imx327->client,
+					       IMX327_REG_CTRL_MODE,
+					       IMX327_REG_VALUE_08BIT,
+					       1);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1166,6 +1183,7 @@ static long imx327_compat_ioctl32(struct v4l2_subdev *sd,
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
 	u32 cg = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1232,6 +1250,11 @@ static long imx327_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = imx327_ioctl(sd, cmd, &cg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx327_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx334.c b/drivers/media/i2c/imx334.c
index 4d81eab99efc..6565b70fdea1 100644
--- a/drivers/media/i2c/imx334.c
+++ b/drivers/media/i2c/imx334.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X04
  *	1.add parse mclk pinctrl.
  *	2.add set flip ctrl.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -35,7 +36,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1023,6 +1024,7 @@ static long imx334_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	u32 i, h, w;
 	s64 dst_pixel_rate = 0;
 	const struct imx334_mode *mode;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -1083,6 +1085,17 @@ static long imx334_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 			}
 		}
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx334_write_reg(imx334->client, IMX334_REG_CTRL_MODE,
+				IMX334_REG_VALUE_08BIT, 0);
+		else
+			ret = imx334_write_reg(imx334->client, IMX334_REG_CTRL_MODE,
+				IMX334_REG_VALUE_08BIT, 1);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1101,6 +1114,7 @@ static long imx334_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1152,17 +1166,22 @@ static long imx334_compat_ioctl32(struct v4l2_subdev *sd,
 		kfree(hdr);
 		break;
 	case PREISP_CMD_SET_HDRAE_EXP:
-			hdrae = kzalloc(sizeof(*hdrae), GFP_KERNEL);
-			if (!hdrae) {
-				ret = -ENOMEM;
-				return ret;
-			}
+		hdrae = kzalloc(sizeof(*hdrae), GFP_KERNEL);
+		if (!hdrae) {
+			ret = -ENOMEM;
+			return ret;
+		}
 
-			ret = copy_from_user(hdrae, up, sizeof(*hdrae));
-			if (!ret)
-				ret = imx334_ioctl(sd, cmd, hdrae);
-			kfree(hdrae);
-			break;
+		ret = copy_from_user(hdrae, up, sizeof(*hdrae));
+		if (!ret)
+			ret = imx334_ioctl(sd, cmd, hdrae);
+		kfree(hdrae);
+		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx334_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx335.c b/drivers/media/i2c/imx335.c
index 0d7513fbf34c..30f6cbdf9ba3 100644
--- a/drivers/media/i2c/imx335.c
+++ b/drivers/media/i2c/imx335.c
@@ -9,6 +9,7 @@
  * V0.0X01.0X02 fix set sensor vertical invert failed
  * V0.0X01.0X03 add hdr_mode in enum frame interval
  * V0.0X01.0X04 fix hdr ae error
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #define DEBUG
@@ -31,7 +32,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1244,6 +1245,7 @@ static long imx335_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr;
 	u32 i, h, w;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -1286,6 +1288,17 @@ static long imx335_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 				1, h);
 		}
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			imx335_write_reg(imx335->client, IMX335_REG_CTRL_MODE,
+				IMX335_REG_VALUE_08BIT, 0);
+		else
+			imx335_write_reg(imx335->client, IMX335_REG_CTRL_MODE,
+				IMX335_REG_VALUE_08BIT, 1);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1304,6 +1317,7 @@ static long imx335_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1366,6 +1380,11 @@ static long imx335_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = imx335_ioctl(sd, cmd, hdrae);
 		kfree(hdrae);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx335_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx378.c b/drivers/media/i2c/imx378.c
index 3fec122b36f0..8a0715a3edb3 100644
--- a/drivers/media/i2c/imx378.c
+++ b/drivers/media/i2c/imx378.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
  * V0.0X01.0X01 add imx378 driver.
  * V0.0X01.0X02 add imx378 support mirror and flip.
+ * V0.0X01.0X03 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -33,7 +34,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -2137,6 +2138,7 @@ static long imx378_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr;
 	long ret = 0;
 	u32 i, h, w;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -2195,6 +2197,17 @@ static long imx378_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 					   imx378->cur_link_freq);
 		}
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx378_write_reg(imx378->client, IMX378_REG_CTRL_MODE,
+				IMX378_REG_VALUE_08BIT, IMX378_MODE_STREAMING);
+		else
+			ret = imx378_write_reg(imx378->client, IMX378_REG_CTRL_MODE,
+				IMX378_REG_VALUE_08BIT, IMX378_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -2213,6 +2226,7 @@ static long imx378_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -2264,17 +2278,22 @@ static long imx378_compat_ioctl32(struct v4l2_subdev *sd,
 		kfree(hdr);
 		break;
 	case PREISP_CMD_SET_HDRAE_EXP:
-			hdrae = kzalloc(sizeof(*hdrae), GFP_KERNEL);
-			if (!hdrae) {
-				ret = -ENOMEM;
-				return ret;
-			}
+		hdrae = kzalloc(sizeof(*hdrae), GFP_KERNEL);
+		if (!hdrae) {
+			ret = -ENOMEM;
+			return ret;
+		}
 
-			ret = copy_from_user(hdrae, up, sizeof(*hdrae));
-			if (!ret)
-				ret = imx378_ioctl(sd, cmd, hdrae);
-			kfree(hdrae);
-			break;
+		ret = copy_from_user(hdrae, up, sizeof(*hdrae));
+		if (!ret)
+			ret = imx378_ioctl(sd, cmd, hdrae);
+		kfree(hdrae);
+		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx378_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/imx415.c b/drivers/media/i2c/imx415.c
index 8fbbb1195eb4..9e9c6a6ac6d2 100644
--- a/drivers/media/i2c/imx415.c
+++ b/drivers/media/i2c/imx415.c
@@ -1616,14 +1616,8 @@ static long imx415_compat_ioctl32(struct v4l2_subdev *sd,
 	case RKMODULE_SET_QUICK_STREAM:
 
 		ret = copy_from_user(&stream, up, sizeof(u32));
-		if (!ret) {
-			if (stream)
-				ret = imx415_write_reg(imx415->client, IMX415_REG_CTRL_MODE,
-					IMX415_REG_VALUE_08BIT, IMX415_MODE_STREAMING);
-			else
-				ret = imx415_write_reg(imx415->client, IMX415_REG_CTRL_MODE,
-					IMX415_REG_VALUE_08BIT, IMX415_MODE_SW_STANDBY);
-		}
+		if (!ret)
+			ret = imx415_ioctl(sd, cmd, &stream);
 		break;
 
 	default:
diff --git a/drivers/media/i2c/jx_h65.c b/drivers/media/i2c/jx_h65.c
index 61747bdd9536..e256a6613198 100644
--- a/drivers/media/i2c/jx_h65.c
+++ b/drivers/media/i2c/jx_h65.c
@@ -6,6 +6,7 @@
  *
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 add enum_frame_interval function.
+ * V0.0X01.0X03 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -24,7 +25,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/version.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -598,11 +599,23 @@ static long jx_h65_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct jx_h65 *jx_h65 = to_jx_h65(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		jx_h65_get_module_inf(jx_h65, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = jx_h65_write_reg(jx_h65->client, JX_H65_REG_CTRL_MODE,
+				JX_H65_MODE_STREAMING);
+		else
+			ret = jx_h65_write_reg(jx_h65->client, JX_H65_REG_CTRL_MODE,
+				JX_H65_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -619,6 +632,7 @@ static long jx_h65_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -645,6 +659,11 @@ static long jx_h65_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = jx_h65_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = jx_h65_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/os04a10.c b/drivers/media/i2c/os04a10.c
index a4d63133c997..99a1f3d1382c 100644
--- a/drivers/media/i2c/os04a10.c
+++ b/drivers/media/i2c/os04a10.c
@@ -8,6 +8,7 @@
  * V0.0X01.0X01 support conversion gain switch.
  * V0.0X01.0X02 add debug interface for conversion gain switch.
  * V0.0X01.0X03 support enum sensor fmt
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -30,7 +31,7 @@
 #include <linux/rk-preisp.h>
 #include "../platform/rockchip/isp/rkisp_tb_helper.h"
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1446,6 +1447,7 @@ static long os04a10_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr_cfg;
 	long ret = 0;
 	u32 i, h, w;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -1490,6 +1492,17 @@ static long os04a10_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_SET_CONVERSION_GAIN:
 		ret = os04a10_set_conversion_gain(os04a10, (u32 *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = os04a10_write_reg(os04a10->client, OS04A10_REG_CTRL_MODE,
+				OS04A10_REG_VALUE_08BIT, OS04A10_MODE_STREAMING);
+		else
+			ret = os04a10_write_reg(os04a10->client, OS04A10_REG_CTRL_MODE,
+				OS04A10_REG_VALUE_08BIT, OS04A10_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1509,6 +1522,7 @@ static long os04a10_compat_ioctl32(struct v4l2_subdev *sd,
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
 	u32 cg = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1576,6 +1590,11 @@ static long os04a10_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = os04a10_ioctl(sd, cmd, &cg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = os04a10_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov02k10.c b/drivers/media/i2c/ov02k10.c
index 0871ae5bf81f..8bdcd065813a 100644
--- a/drivers/media/i2c/ov02k10.c
+++ b/drivers/media/i2c/ov02k10.c
@@ -6,6 +6,7 @@
  *
  * V0.0X01.0X00 first version, only linear mode ready.
  * V0.0X01.0X01 both linear and HDR modes are ready.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x01)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1090,6 +1091,7 @@ static long ov02k10_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	u32 i, h, w;
 	u64 dst_link_freq = 0;
 	u64 dst_pixel_rate = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -1147,6 +1149,17 @@ static long ov02k10_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_SET_CONVERSION_GAIN:
 		ret = ov02k10_set_conversion_gain(ov02k10, (u32 *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov02k10_write_reg(ov02k10->client, OV02K10_REG_CTRL_MODE,
+				OV02K10_REG_VALUE_08BIT, OV02K10_MODE_STREAMING);
+		else
+			ret = ov02k10_write_reg(ov02k10->client, OV02K10_REG_CTRL_MODE,
+				OV02K10_REG_VALUE_08BIT, OV02K10_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1166,6 +1179,7 @@ static long ov02k10_compat_ioctl32(struct v4l2_subdev *sd,
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
 	u32 cg = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1233,6 +1247,11 @@ static long ov02k10_compat_ioctl32(struct v4l2_subdev *sd,
 		if (!ret)
 			ret = ov02k10_ioctl(sd, cmd, &cg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov02k10_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov13850.c b/drivers/media/i2c/ov13850.c
index ae6a88d63342..87548a194201 100644
--- a/drivers/media/i2c/ov13850.c
+++ b/drivers/media/i2c/ov13850.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -921,11 +922,27 @@ static long ov13850_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov13850 *ov13850 = to_ov13850(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov13850_get_module_inf(ov13850, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov13850_write_reg(ov13850->client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_STREAMING);
+		else
+			ret = ov13850_write_reg(ov13850->client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -942,6 +959,7 @@ static long ov13850_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -968,6 +986,11 @@ static long ov13850_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov13850_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov13850_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov2680.c b/drivers/media/i2c/ov2680.c
index 600d892eda44..df0379df8b4b 100644
--- a/drivers/media/i2c/ov2680.c
+++ b/drivers/media/i2c/ov2680.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -36,7 +37,7 @@
 /* verify default register values */
 //#define CHECK_REG_VALUE
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x3)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x4)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -584,11 +585,23 @@ static long ov2680_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov2680 *ov2680 = to_ov2680(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov2680_get_module_inf(ov2680, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov2680_write_reg(ov2680->client, OV2680_REG_CTRL_MODE,
+				OV2680_REG_VALUE_08BIT, OV2680_MODE_STREAMING);
+		else
+			ret = ov2680_write_reg(ov2680->client, OV2680_REG_CTRL_MODE,
+				OV2680_REG_VALUE_08BIT, OV2680_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -605,6 +618,7 @@ static long ov2680_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -631,6 +645,11 @@ static long ov2680_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov2680_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov2680_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov2685.c b/drivers/media/i2c/ov2685.c
index 1c3d56601b52..18cd9a370286 100644
--- a/drivers/media/i2c/ov2685.c
+++ b/drivers/media/i2c/ov2685.c
@@ -8,6 +8,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  * V0.0X01.0X01 add enum_frame_interval function.
+ * V0.0X01.0X02 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x1)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x2)
 
 #define CHIP_ID				0x2685
 #define OV2685_REG_CHIP_ID		0x300a
@@ -505,11 +506,23 @@ static long ov2685_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov2685 *ov2685 = to_ov2685(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov2685_get_module_inf(ov2685, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov2685_write_reg(ov2685->client, REG_SC_CTRL_MODE,
+				OV2685_REG_VALUE_08BIT, SC_CTRL_MODE_STREAMING);
+		else
+			ret = ov2685_write_reg(ov2685->client, REG_SC_CTRL_MODE,
+				OV2685_REG_VALUE_08BIT, SC_CTRL_MODE_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -526,6 +539,7 @@ static long ov2685_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -552,6 +566,11 @@ static long ov2685_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov2685_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov2685_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov2718.c b/drivers/media/i2c/ov2718.c
index ffc673647127..fd2008c1279d 100644
--- a/drivers/media/i2c/ov2718.c
+++ b/drivers/media/i2c/ov2718.c
@@ -14,6 +14,7 @@
  *	4.support raw12bit linear/hdr mode
  *	5.implement RKMODULE_SET/GET_HDR_CFG
  * V0.0X01.0X05 group hold launch immediately when set hdr ae.
+ * V0.0X01.0X06 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -42,7 +43,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/rk-preisp.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x06)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -8039,6 +8040,7 @@ static long ov2718_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	u32 s_again, s_dgain, l_again, l_dgain;
 	u32 again, i, h, w;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -8172,6 +8174,17 @@ static long ov2718_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 				ov2718->cur_mode->hdr_mode, i);
 		}
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov2718_write_reg(ov2718->client, OV2718_REG_CTRL_MODE,
+				OV2718_REG_VALUE_08BIT, OV2718_MODE_STREAMING);
+		else
+			ret = ov2718_write_reg(ov2718->client, OV2718_REG_CTRL_MODE,
+				OV2718_REG_VALUE_08BIT, OV2718_MODE_SW_STANDBY);
+		break;
 	default:
 		return -ENOIOCTLCMD;
 	}
@@ -8189,6 +8202,7 @@ static long ov2718_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -8251,6 +8265,11 @@ static long ov2718_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov2718_ioctl(sd, cmd, hdrae);
 		kfree(hdrae);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov2718_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov2735.c b/drivers/media/i2c/ov2735.c
index 61c7528e8520..3170fbc79ff1 100644
--- a/drivers/media/i2c/ov2735.c
+++ b/drivers/media/i2c/ov2735.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -537,11 +538,24 @@ static long ov2735_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov2735 *ov2735 = to_ov2735(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov2735_get_module_inf(ov2735, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream) {
+			ret = ov2735_write_reg(ov2735->client, PAGE_SELECT_REG, PAGE_ONE);
+			ret |= ov2735_write_reg(ov2735->client, STREAM_CTRL_REG, STREAM_ON);
+		} else {
+			ret = ov2735_write_reg(ov2735->client, PAGE_SELECT_REG, PAGE_ONE);
+			ret |= ov2735_write_reg(ov2735->client, STREAM_CTRL_REG, STREAM_OFF);
+		}
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -558,6 +572,7 @@ static long ov2735_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -584,6 +599,11 @@ static long ov2735_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov2735_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov2735_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov4689.c b/drivers/media/i2c/ov4689.c
index 2ec2e3fe3116..71ffee780d45 100644
--- a/drivers/media/i2c/ov4689.c
+++ b/drivers/media/i2c/ov4689.c
@@ -10,6 +10,7 @@
  * V0.0X01.0X04 add enum_frame_interval function.
  * V0.0X01.0X05 add hdr config
  * V0.0X01.0X06 support enum sensor fmt
+ * V0.0X01.0X07 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -31,7 +32,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x06)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x07)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -860,6 +861,7 @@ static long ov4689_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr;
 	u32 i, h, w;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -897,6 +899,17 @@ static long ov4689_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		break;
 	case PREISP_CMD_SET_HDRAE_EXP:
 		return ov4689_set_hdrae(ov4689, arg);
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov4689_write_reg(ov4689->client, OV4689_REG_CTRL_MODE,
+				OV4689_REG_VALUE_08BIT, OV4689_MODE_STREAMING);
+		else
+			ret = ov4689_write_reg(ov4689->client, OV4689_REG_CTRL_MODE,
+				OV4689_REG_VALUE_08BIT, OV4689_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -915,6 +928,7 @@ static long ov4689_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -977,6 +991,11 @@ static long ov4689_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov4689_ioctl(sd, cmd, hdrae);
 		kfree(hdrae);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov4689_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov5648.c b/drivers/media/i2c/ov5648.c
index 3a6995718515..a87dba191770 100644
--- a/drivers/media/i2c/ov5648.c
+++ b/drivers/media/i2c/ov5648.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -38,7 +39,7 @@
 /* verify default register values */
 //#define CHECK_REG_VALUE
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -755,11 +756,23 @@ static long ov5648_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov5648 *ov5648 = to_ov5648(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov5648_get_module_inf(ov5648, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov5648_write_reg(ov5648->client, OV5648_REG_CTRL_MODE,
+				OV5648_REG_VALUE_08BIT, OV5648_MODE_STREAMING);
+		else
+			ret = ov5648_write_reg(ov5648->client, OV5648_REG_CTRL_MODE,
+				OV5648_REG_VALUE_08BIT, OV5648_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -776,6 +789,7 @@ static long ov5648_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -802,6 +816,11 @@ static long ov5648_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov5648_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov5648_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov5670.c b/drivers/media/i2c/ov5670.c
index 790679af7b72..37aaaf6a777e 100644
--- a/drivers/media/i2c/ov5670.c
+++ b/drivers/media/i2c/ov5670.c
@@ -7,7 +7,8 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add otp function.
- * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add enum_frame_interval function.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -39,7 +40,7 @@
 /* verify default register values */
 //#define CHECK_REG_VALUE
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -997,6 +998,7 @@ static long ov5670_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov5670 *ov5670 = to_ov5670(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1005,6 +1007,17 @@ static long ov5670_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_AWB_CFG:
 		ov5670_set_awb_cfg(ov5670, (struct rkmodule_awb_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov5670_write_reg(ov5670->client, OV5670_REG_CTRL_MODE,
+				OV5670_REG_VALUE_08BIT, OV5670_MODE_STREAMING);
+		else
+			ret = ov5670_write_reg(ov5670->client, OV5670_REG_CTRL_MODE,
+				OV5670_REG_VALUE_08BIT, OV5670_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1021,6 +1034,7 @@ static long ov5670_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *awb_cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1047,6 +1061,11 @@ static long ov5670_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov5670_ioctl(sd, cmd, awb_cfg);
 		kfree(awb_cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov5670_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov5695.c b/drivers/media/i2c/ov5695.c
index 79eaa98447c7..8ce85b90dfdc 100644
--- a/drivers/media/i2c/ov5695.c
+++ b/drivers/media/i2c/ov5695.c
@@ -6,6 +6,7 @@
  *
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 add enum_frame_interval function.
+ * V0.0X01.0X03 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -25,7 +26,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x02)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -860,11 +861,23 @@ static long ov5695_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov5695 *ov5695 = to_ov5695(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov5695_get_module_inf(ov5695, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov5695_write_reg(ov5695->client, OV5695_REG_CTRL_MODE,
+				OV5695_REG_VALUE_08BIT, OV5695_MODE_STREAMING);
+		else
+			ret = ov5695_write_reg(ov5695->client, OV5695_REG_CTRL_MODE,
+				OV5695_REG_VALUE_08BIT, OV5695_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -881,6 +894,7 @@ static long ov5695_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -907,6 +921,11 @@ static long ov5695_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov5695_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov5695_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov7251.c b/drivers/media/i2c/ov7251.c
index dcd7720e28ab..94182b5ebadd 100644
--- a/drivers/media/i2c/ov7251.c
+++ b/drivers/media/i2c/ov7251.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -543,11 +544,23 @@ static long ov7251_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov7251 *ov7251 = to_ov7251(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov7251_get_module_inf(ov7251, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov7251_write_reg(ov7251->client, OV7251_REG_CTRL_MODE,
+				OV7251_REG_VALUE_08BIT, OV7251_MODE_STREAMING);
+		else
+			ret = ov7251_write_reg(ov7251->client, OV7251_REG_CTRL_MODE,
+				OV7251_REG_VALUE_08BIT, OV7251_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -564,6 +577,7 @@ static long ov7251_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -590,6 +604,11 @@ static long ov7251_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov7251_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov7251_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov7750.c b/drivers/media/i2c/ov7750.c
index 308606e4a0e7..576d878aad37 100644
--- a/drivers/media/i2c/ov7750.c
+++ b/drivers/media/i2c/ov7750.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -630,11 +631,27 @@ static long ov7750_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov7750 *ov7750 = to_ov7750(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov7750_get_module_inf(ov7750, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov7750_write_reg(ov7750->client,
+				 OV7750_REG_CTRL_MODE,
+				 OV7750_REG_VALUE_08BIT,
+				 OV7750_MODE_STREAMING);
+		else
+			ret = ov7750_write_reg(ov7750->client,
+				 OV7750_REG_CTRL_MODE,
+				 OV7750_REG_VALUE_08BIT,
+				 OV7750_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -651,6 +668,7 @@ static long ov7750_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -677,6 +695,11 @@ static long ov7750_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov7750_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov7750_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov8858.c b/drivers/media/i2c/ov8858.c
index d0961c6c72fb..1c07f6fd592b 100644
--- a/drivers/media/i2c/ov8858.c
+++ b/drivers/media/i2c/ov8858.c
@@ -5,6 +5,7 @@
  * v0.1.0x00 : 1. create file.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -34,7 +35,7 @@
 #include <media/v4l2-mediabus.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1799,6 +1800,7 @@ static long ov8858_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov8858 *ov8858 = to_ov8858(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1810,6 +1812,21 @@ static long ov8858_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	case RKMODULE_LSC_CFG:
 		ov8858_set_lsc_cfg(ov8858, (struct rkmodule_lsc_cfg *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov8858_write_reg(ov8858->client,
+				OV8858_REG_CTRL_MODE,
+				OV8858_REG_VALUE_08BIT,
+				OV8858_MODE_STREAMING);
+		else
+			ret = ov8858_write_reg(ov8858->client,
+				OV8858_REG_CTRL_MODE,
+				OV8858_REG_VALUE_08BIT,
+				OV8858_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
@@ -1827,6 +1844,7 @@ static long ov8858_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_awb_cfg *awb_cfg;
 	struct rkmodule_lsc_cfg *lsc_cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1865,6 +1883,11 @@ static long ov8858_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov8858_ioctl(sd, cmd, lsc_cfg);
 		kfree(lsc_cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov8858_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOTTY;
 		break;
diff --git a/drivers/media/i2c/ov9281.c b/drivers/media/i2c/ov9281.c
index d74e08cc2c49..aae5be3385d1 100644
--- a/drivers/media/i2c/ov9281.c
+++ b/drivers/media/i2c/ov9281.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -25,7 +26,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/version.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x3)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x4)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -508,11 +509,23 @@ static long ov9281_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov9281 *ov9281 = to_ov9281(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov9281_get_module_inf(ov9281, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov9281_write_reg(ov9281->client, OV9281_REG_CTRL_MODE,
+				OV9281_REG_VALUE_08BIT, OV9281_MODE_STREAMING);
+		else
+			ret = ov9281_write_reg(ov9281->client, OV9281_REG_CTRL_MODE,
+				OV9281_REG_VALUE_08BIT, OV9281_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -529,6 +542,7 @@ static long ov9281_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -555,6 +569,11 @@ static long ov9281_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = ov9281_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov9281_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/ov9750.c b/drivers/media/i2c/ov9750.c
index a458eaa6f8ed..1b4f585684c7 100644
--- a/drivers/media/i2c/ov9750.c
+++ b/drivers/media/i2c/ov9750.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -25,7 +26,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/version.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x3)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x4)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -642,11 +643,23 @@ static long ov9750_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct ov9750 *ov9750 = to_ov9750(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		ov9750_get_module_inf(ov9750, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = ov9750_write_reg(ov9750->client, OV9750_REG_CTRL_MODE,
+				OV9750_REG_VALUE_08BIT, OV9750_MODE_STREAMING);
+		else
+			ret = ov9750_write_reg(ov9750->client, OV9750_REG_CTRL_MODE,
+				OV9750_REG_VALUE_08BIT, OV9750_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -662,6 +675,7 @@ static long ov9750_compat_ioctl32(struct v4l2_subdev *sd,
 	void __user *up = compat_ptr(arg);
 	struct rkmodule_inf *inf;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -675,6 +689,11 @@ static long ov9750_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = copy_to_user(up, inf, sizeof(*inf));
 		kfree(inf);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = ov9750_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/sc031gs.c b/drivers/media/i2c/sc031gs.c
index 31e1a009fa6e..3b82e9b29167 100644
--- a/drivers/media/i2c/sc031gs.c
+++ b/drivers/media/i2c/sc031gs.c
@@ -7,6 +7,7 @@
  * V0.0X01.0X01 add poweron function.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -565,11 +566,23 @@ static long sc031gs_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct sc031gs *sc031gs = to_sc031gs(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		sc031gs_get_module_inf(sc031gs, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = sc031gs_write_reg(sc031gs->client, SC031GS_REG_CTRL_MODE,
+				SC031GS_REG_VALUE_08BIT, SC031GS_MODE_STREAMING);
+		else
+			ret = sc031gs_write_reg(sc031gs->client, SC031GS_REG_CTRL_MODE,
+				SC031GS_REG_VALUE_08BIT, SC031GS_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -586,6 +599,7 @@ static long sc031gs_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -612,6 +626,11 @@ static long sc031gs_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = sc031gs_ioctl(sd, cmd, cfg);
 		kfree(cfg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = sc031gs_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/sc132gs.c b/drivers/media/i2c/sc132gs.c
index d2fb761e6afc..ff2b955c34ef 100644
--- a/drivers/media/i2c/sc132gs.c
+++ b/drivers/media/i2c/sc132gs.c
@@ -6,6 +6,7 @@
  * V0.1.0: MIPI is ok.
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 add enum_frame_interval function.
+ * V0.0X01.0X04 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
 #endif
@@ -500,11 +501,23 @@ static long sc132gs_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct sc132gs *sc132gs = to_sc132gs(sd);
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		sc132gs_get_module_inf(sc132gs, (struct rkmodule_inf *)arg);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = sc132gs_write_reg(sc132gs->client, SC132GS_REG_CTRL_MODE,
+				SC132GS_REG_VALUE_08BIT, SC132GS_MODE_STREAMING);
+		else
+			ret = sc132gs_write_reg(sc132gs->client, SC132GS_REG_CTRL_MODE,
+				SC132GS_REG_VALUE_08BIT, SC132GS_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -520,6 +533,7 @@ static long sc132gs_compat_ioctl32(struct v4l2_subdev *sd,
 	void __user *up = compat_ptr(arg);
 	struct rkmodule_inf *inf;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -534,6 +548,11 @@ static long sc132gs_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = copy_to_user(up, inf, sizeof(*inf));
 		kfree(inf);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = sc132gs_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/sc200ai.c b/drivers/media/i2c/sc200ai.c
index 066fe68538c9..9a47abdd8e03 100644
--- a/drivers/media/i2c/sc200ai.c
+++ b/drivers/media/i2c/sc200ai.c
@@ -8,6 +8,7 @@
  * V0.0X01.0X02 fix mclk issue when probe multiple camera.
  * V0.0X01.0X03 fix gain range.
  * V0.0X01.0X04 add enum_frame_interval function.
+ * V0.0X01.0X05 add quick stream on/off
  */
 
 #include <linux/clk.h>
@@ -29,7 +30,7 @@
 #include <media/v4l2-subdev.h>
 #include <linux/pinctrl/consumer.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x04)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x05)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1138,6 +1139,7 @@ static long sc200ai_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr;
 	u32 i, h, w;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1178,6 +1180,17 @@ static long sc200ai_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		break;
 	case RKMODULE_GET_NR_SWITCH_THRESHOLD:
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = sc200ai_write_reg(sc200ai->client, SC200AI_REG_CTRL_MODE,
+				 SC200AI_REG_VALUE_08BIT, SC200AI_MODE_STREAMING);
+		else
+			ret = sc200ai_write_reg(sc200ai->client, SC200AI_REG_CTRL_MODE,
+				 SC200AI_REG_VALUE_08BIT, SC200AI_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1196,6 +1209,7 @@ static long sc200ai_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1270,6 +1284,11 @@ static long sc200ai_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = copy_to_user(up, nr_switch, sizeof(*nr_switch));
 		kfree(nr_switch);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = sc200ai_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/sc210iot.c b/drivers/media/i2c/sc210iot.c
index cfeab642aab8..cd7265b770da 100644
--- a/drivers/media/i2c/sc210iot.c
+++ b/drivers/media/i2c/sc210iot.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
  *
  * V0.0X01.0X00 first version.
+ * V0.0X01.0X01 add quick stream on/off
  */
 #include <linux/clk.h>
 #include <linux/delay.h>
@@ -26,7 +27,7 @@
 #include <media/v4l2-fwnode.h>
 #include <media/v4l2-subdev.h>
 
-#define DRIVER_VERSION		KERNEL_VERSION(0, 0x01, 0x00)
+#define DRIVER_VERSION		KERNEL_VERSION(0, 0x01, 0x01)
 
 #define OF_CAMERA_PINCTRL_STATE_DEFAULT	"rockchip,camera_default"
 #define OF_CAMERA_PINCTRL_STATE_SLEEP	"rockchip,camera_sleep"
@@ -577,6 +578,7 @@ static long sc210iot_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct sc210iot *sc210iot = to_sc210iot(sd);
 	struct rkmodule_hdr_cfg *hdr_cfg;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_HDR_CFG:
@@ -589,6 +591,19 @@ static long sc210iot_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		break;
 	case RKMODULE_SET_HDR_CFG:
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = sc210iot_write_reg(sc210iot,
+						 SC210IOT_REG_CTRL_MODE,
+						 SC210IOT_MODE_STREAMING);
+		else
+			ret = sc210iot_write_reg(sc210iot,
+						 SC210IOT_REG_CTRL_MODE,
+						 SC210IOT_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -623,6 +638,7 @@ static long sc210iot_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_inf *inf;
 	struct rkmodule_hdr_cfg *hdr;
 	long ret = 0;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -649,6 +665,11 @@ static long sc210iot_compat_ioctl32(struct v4l2_subdev *sd,
 		break;
 	case RKMODULE_SET_HDR_CFG:
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = sc210iot_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
diff --git a/drivers/media/i2c/sc2239.c b/drivers/media/i2c/sc2239.c
index ed32f742d371..38eead6a47be 100644
--- a/drivers/media/i2c/sc2239.c
+++ b/drivers/media/i2c/sc2239.c
@@ -560,9 +560,8 @@ static long sc2239_compat_ioctl32(struct v4l2_subdev *sd,
 		break;
 	case RKMODULE_SET_QUICK_STREAM:
 		ret = copy_from_user(&stream, up, sizeof(u32));
-		if (!ret) {
+		if (!ret)
 			ret = sc2239_ioctl(sd, cmd, &stream);
-		}
 		break;
 	default:
 		ret = -ENOIOCTLCMD;
diff --git a/drivers/media/i2c/sc4238.c b/drivers/media/i2c/sc4238.c
index 92bae8a15a63..e84678f138ae 100644
--- a/drivers/media/i2c/sc4238.c
+++ b/drivers/media/i2c/sc4238.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
  *
  * V0.0X01.0X00 first version.
+ * V0.0X01.0X01 add quick stream on/off
  */
 //#define DEBUG
 #include <linux/clk.h>
@@ -27,7 +28,7 @@
 #include <linux/rk-preisp.h>
 #include "../platform/rockchip/isp/rkisp_tb_helper.h"
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x00)
+#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x01)
 
 #ifndef V4L2_CID_DIGITAL_GAIN
 #define V4L2_CID_DIGITAL_GAIN		V4L2_CID_GAIN
@@ -1561,6 +1562,7 @@ static long sc4238_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	struct rkmodule_hdr_cfg *hdr_cfg;
 	long ret = 0;
 	u32 i, h, w;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case PREISP_CMD_SET_HDRAE_EXP:
@@ -1606,6 +1608,17 @@ static long sc4238_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 		hdr_cfg->esp.mode = HDR_NORMAL_VC;
 		hdr_cfg->hdr_mode = sc4238->cur_mode->hdr_mode;
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = sc4238_write_reg(sc4238->client, SC4238_REG_CTRL_MODE,
+				SC4238_REG_VALUE_08BIT, SC4238_MODE_STREAMING);
+		else
+			ret = sc4238_write_reg(sc4238->client, SC4238_REG_CTRL_MODE,
+				SC4238_REG_VALUE_08BIT, SC4238_MODE_SW_STANDBY);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1624,6 +1637,7 @@ static long sc4238_compat_ioctl32(struct v4l2_subdev *sd,
 	struct rkmodule_hdr_cfg *hdr;
 	struct preisp_hdrae_exp_s *hdrae;
 	long ret;
+	u32 stream = 0;
 
 	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
@@ -1686,6 +1700,11 @@ static long sc4238_compat_ioctl32(struct v4l2_subdev *sd,
 			ret = sc4238_ioctl(sd, cmd, hdrae);
 		kfree(hdrae);
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = sc4238_ioctl(sd, cmd, &stream);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
-- 
2.35.3

