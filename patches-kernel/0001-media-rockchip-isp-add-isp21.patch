From 70b1a4c5858e54b6df3c30a3f812b823352b686e Mon Sep 17 00:00:00 2001
From: Cai YiWei <cyw@rock-chips.com>
Date: Fri, 30 Oct 2020 15:49:45 +0800
Subject: [PATCH] media: rockchip: isp: add isp21

Change-Id: I811d691d5aa3cfe2ced91c2044ec920a53ca6d89
Signed-off-by: Cai YiWei <cyw@rock-chips.com>
---
 drivers/media/platform/rockchip/isp/Makefile  |    1 +
 drivers/media/platform/rockchip/isp/capture.c |   13 +-
 .../media/platform/rockchip/isp/capture_v20.c |   24 +-
 .../media/platform/rockchip/isp/capture_v21.c | 1522 +++++++++++++++++
 .../media/platform/rockchip/isp/capture_v2x.h |    5 +
 drivers/media/platform/rockchip/isp/common.h  |    1 +
 drivers/media/platform/rockchip/isp/csi.c     |    8 +-
 drivers/media/platform/rockchip/isp/dev.c     |   27 +-
 drivers/media/platform/rockchip/isp/dmarx.c   |   26 +-
 drivers/media/platform/rockchip/isp/hw.c      |   20 +-
 .../media/platform/rockchip/isp/regs_v2x.h    |   79 +-
 drivers/media/platform/rockchip/isp/rkisp.c   |   25 +-
 12 files changed, 1681 insertions(+), 70 deletions(-)
 create mode 100644 drivers/media/platform/rockchip/isp/capture_v21.c

diff --git a/drivers/media/platform/rockchip/isp/Makefile b/drivers/media/platform/rockchip/isp/Makefile
index 53dd0f1a4687..4fa377f69e17 100644
--- a/drivers/media/platform/rockchip/isp/Makefile
+++ b/drivers/media/platform/rockchip/isp/Makefile
@@ -15,6 +15,7 @@ video_rkisp-objs += rkisp.o \
 			capture.o \
 			capture_v1x.o \
 			capture_v20.o \
+			capture_v21.o \
 			dmarx.o \
 			csi.o \
 			bridge.o \
diff --git a/drivers/media/platform/rockchip/isp/capture.c b/drivers/media/platform/rockchip/isp/capture.c
index f1ca9234526b..0a16cb0b46f5 100644
--- a/drivers/media/platform/rockchip/isp/capture.c
+++ b/drivers/media/platform/rockchip/isp/capture.c
@@ -83,7 +83,7 @@ int rkisp_mbus_code_xysubs(u32 code, u32 *xsubs, u32 *ysubs)
 static const struct capture_fmt mp_fmts[] = {
 	/* yuv422 */
 	{
-		.fourcc = V4L2_PIX_FMT_YUYV,
+		.fourcc = V4L2_PIX_FMT_UYVY,
 		.fmt_type = FMT_YUV,
 		.bpp = { 16 },
 		.cplanes = 1,
@@ -254,7 +254,7 @@ static const struct capture_fmt mp_fmts[] = {
 static const struct capture_fmt sp_fmts[] = {
 	/* yuv422 */
 	{
-		.fourcc = V4L2_PIX_FMT_YUYV,
+		.fourcc = V4L2_PIX_FMT_UYVY,
 		.fmt_type = FMT_YUV,
 		.bpp = { 16 },
 		.cplanes = 1,
@@ -599,7 +599,8 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 			height = pixm->height / ysubs;
 		}
 
-		if (dev->isp_ver == ISP_V20 &&
+		if ((dev->isp_ver == ISP_V20 ||
+		     dev->isp_ver == ISP_V21) &&
 		    !dev->csi_dev.memory &&
 		    stream->id != RKISP_STREAM_MP &&
 		    stream->id != RKISP_STREAM_SP)
@@ -1053,6 +1054,8 @@ int rkisp_register_stream_vdevs(struct rkisp_device *dev)
 		ret = rkisp_register_stream_v1x(dev);
 	else if (dev->isp_ver == ISP_V20)
 		ret = rkisp_register_stream_v20(dev);
+	else if (dev->isp_ver == ISP_V21)
+		ret = rkisp_register_stream_v21(dev);
 	return ret;
 }
 
@@ -1062,6 +1065,8 @@ void rkisp_unregister_stream_vdevs(struct rkisp_device *dev)
 		rkisp_unregister_stream_v1x(dev);
 	else if (dev->isp_ver == ISP_V20)
 		rkisp_unregister_stream_v20(dev);
+	else if (dev->isp_ver == ISP_V21)
+		rkisp_unregister_stream_v21(dev);
 }
 
 void rkisp_mi_isr(u32 mis_val, struct rkisp_device *dev)
@@ -1070,4 +1075,6 @@ void rkisp_mi_isr(u32 mis_val, struct rkisp_device *dev)
 		rkisp_mi_v1x_isr(mis_val, dev);
 	else if (dev->isp_ver == ISP_V20)
 		rkisp_mi_v20_isr(mis_val, dev);
+	else if (dev->isp_ver == ISP_V21)
+		rkisp_mi_v21_isr(mis_val, dev);
 }
diff --git a/drivers/media/platform/rockchip/isp/capture_v20.c b/drivers/media/platform/rockchip/isp/capture_v20.c
index e42e9301d29d..3909c6134242 100644
--- a/drivers/media/platform/rockchip/isp/capture_v20.c
+++ b/drivers/media/platform/rockchip/isp/capture_v20.c
@@ -339,7 +339,7 @@ int hdr_update_dmatx_buf(struct rkisp_device *dev)
 	void __iomem *base = dev->base_addr;
 	struct rkisp_stream *dmatx;
 	struct rkisp_dummy_buffer *buf;
-	u8 index;
+	u8 i, index;
 
 	if (!dev->active_sensor ||
 	    (dev->active_sensor &&
@@ -347,14 +347,11 @@ int hdr_update_dmatx_buf(struct rkisp_device *dev)
 	    (dev->isp_inp & INP_CIF))
 		return 0;
 
-	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
-	dmatx->ops->frame_end(dmatx);
-
-	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX1];
-	dmatx->ops->frame_end(dmatx);
-
-	dmatx = &dev->cap_dev.stream[RKISP_STREAM_DMATX2];
-	dmatx->ops->frame_end(dmatx);
+	for (i = RKISP_STREAM_DMATX0; i <= RKISP_STREAM_DMATX2; i++) {
+		dmatx = &dev->cap_dev.stream[i];
+		if (dmatx->ops && dmatx->ops->frame_end)
+			dmatx->ops->frame_end(dmatx);
+	}
 
 	if (dev->dmarx_dev.trigger)
 		goto end;
@@ -424,19 +421,22 @@ int hdr_config_dmatx(struct rkisp_device *dev)
 	    dev->hdr.op_mode == HDR_RDBK_FRAME2 ||
 	    dev->hdr.op_mode == HDR_RDBK_FRAME3) {
 		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX0];
-		stream->ops->config_mi(stream);
+		if (stream->ops && stream->ops->config_mi)
+			stream->ops->config_mi(stream);
 	}
 	if (dev->hdr.op_mode == HDR_FRAMEX3_DDR ||
 	    dev->hdr.op_mode == HDR_LINEX3_DDR ||
 	    dev->hdr.op_mode == HDR_RDBK_FRAME3) {
 		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX1];
-		stream->ops->config_mi(stream);
+		if (stream->ops && stream->ops->config_mi)
+			stream->ops->config_mi(stream);
 	}
 	if (dev->hdr.op_mode == HDR_RDBK_FRAME1 ||
 	    dev->hdr.op_mode == HDR_RDBK_FRAME2 ||
 	    dev->hdr.op_mode == HDR_RDBK_FRAME3) {
 		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX2];
-		stream->ops->config_mi(stream);
+		if (stream->ops && stream->ops->config_mi)
+			stream->ops->config_mi(stream);
 	}
 
 	if (IS_HDR_RDBK(dev->hdr.op_mode) && !dev->dmarx_dev.trigger) {
diff --git a/drivers/media/platform/rockchip/isp/capture_v21.c b/drivers/media/platform/rockchip/isp/capture_v21.c
new file mode 100644
index 000000000000..ad964618a15a
--- /dev/null
+++ b/drivers/media/platform/rockchip/isp/capture_v21.c
@@ -0,0 +1,1522 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 Rockchip Electronics Co., Ltd. */
+
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-dma-contig.h>
+#include "dev.h"
+#include "regs.h"
+
+#define CIF_ISP_REQ_BUFS_MIN			0
+
+static int mi_frame_end(struct rkisp_stream *stream);
+static void rkisp_buf_queue(struct vb2_buffer *vb);
+static int rkisp_create_dummy_buf(struct rkisp_stream *stream);
+
+static bool is_rdbk_stream(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	bool en = false;
+
+	if ((dev->hdr.op_mode == HDR_RDBK_FRAME1 &&
+	     stream->id == RKISP_STREAM_DMATX2) ||
+	    (dev->hdr.op_mode == HDR_RDBK_FRAME2 &&
+	     (stream->id == RKISP_STREAM_DMATX2 ||
+	      stream->id == RKISP_STREAM_DMATX0)))
+		en = true;
+	return en;
+}
+
+/* configure dual-crop unit */
+static int rkisp_stream_config_dcrop(struct rkisp_stream *stream, bool async)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_rect *dcrop = &stream->dcrop;
+	struct v4l2_rect *input_win;
+
+	/* dual-crop unit get data from isp */
+	input_win = rkisp_get_isp_sd_win(&dev->isp_sdev);
+
+	if (dcrop->width == input_win->width &&
+	    dcrop->height == input_win->height &&
+	    dcrop->left == 0 && dcrop->top == 0) {
+		rkisp_disable_dcrop(stream, async);
+		v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+			 "stream %d crop disabled\n", stream->id);
+		return 0;
+	}
+
+	rkisp_config_dcrop(stream, dcrop, async);
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "stream %d crop: %dx%d -> %dx%d\n", stream->id,
+		 input_win->width, input_win->height,
+		 dcrop->width, dcrop->height);
+
+	return 0;
+}
+
+/* configure scale unit */
+static int rkisp_stream_config_rsz(struct rkisp_stream *stream, bool async)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_pix_format_mplane output_fmt = stream->out_fmt;
+	struct capture_fmt *output_isp_fmt = &stream->out_isp_fmt;
+	struct ispsd_out_fmt *input_isp_fmt =
+			rkisp_get_ispsd_out_fmt(&dev->isp_sdev);
+	struct v4l2_rect in_y, in_c, out_y, out_c;
+	u32 xsubs_in = 1, ysubs_in = 1;
+	u32 xsubs_out = 1, ysubs_out = 1;
+
+	if (input_isp_fmt->fmt_type == FMT_BAYER)
+		goto disable;
+
+	/* set input and output sizes for scale calculation */
+	in_y.width = stream->dcrop.width;
+	in_y.height = stream->dcrop.height;
+	out_y.width = output_fmt.width;
+	out_y.height = output_fmt.height;
+
+	/* The size of Cb,Cr are related to the format */
+	if (rkisp_mbus_code_xysubs(input_isp_fmt->mbus_code, &xsubs_in, &ysubs_in)) {
+		v4l2_err(&dev->v4l2_dev, "Not xsubs/ysubs found\n");
+		return -EINVAL;
+	}
+	in_c.width = in_y.width / xsubs_in;
+	in_c.height = in_y.height / ysubs_in;
+
+	if (output_isp_fmt->fmt_type == FMT_YUV) {
+		rkisp_fcc_xysubs(output_isp_fmt->fourcc, &xsubs_out, &ysubs_out);
+		out_c.width = out_y.width / xsubs_out;
+		out_c.height = out_y.height / ysubs_out;
+	} else {
+		out_c.width = out_y.width / xsubs_in;
+		out_c.height = out_y.height / ysubs_in;
+	}
+
+	if (in_c.width == out_c.width && in_c.height == out_c.height)
+		goto disable;
+
+	/* set RSZ input and output */
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "stream %d rsz/scale: %dx%d -> %dx%d\n",
+		 stream->id, stream->dcrop.width, stream->dcrop.height,
+		 output_fmt.width, output_fmt.height);
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "chroma scaling %dx%d -> %dx%d\n",
+		 in_c.width, in_c.height, out_c.width, out_c.height);
+
+	/* calculate and set scale */
+	rkisp_config_rsz(stream, &in_y, &in_c, &out_y, &out_c, async);
+
+	if (rkisp_debug)
+		rkisp_dump_rsz_regs(stream);
+
+	return 0;
+
+disable:
+	rkisp_disable_rsz(stream, async);
+
+	return 0;
+}
+
+/***************************** stream operations*******************************/
+
+/*
+ * memory base addresses should be with respect
+ * to the burst alignment restriction for AXI.
+ */
+static u32 calc_burst_len(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	u32 y_size = stream->out_fmt.plane_fmt[0].bytesperline *
+		stream->out_fmt.height;
+	u32 cb_size = stream->out_fmt.plane_fmt[1].sizeimage;
+	u32 cr_size = stream->out_fmt.plane_fmt[2].sizeimage;
+	u32 cb_offs, cr_offs;
+	u32 bus = 16, burst;
+	int i;
+
+	/* y/c base addr: burstN * bus alignment */
+	cb_offs = y_size;
+	cr_offs = cr_size ? (cb_size + cb_offs) : 0;
+
+	if (!(cb_offs % (bus * 16)) &&
+		!(cr_offs % (bus * 16)))
+		burst = CIF_MI_CTRL_BURST_LEN_LUM_16 |
+			CIF_MI_CTRL_BURST_LEN_CHROM_16;
+	else if (!(cb_offs % (bus * 8)) &&
+		!(cr_offs % (bus * 8)))
+		burst = CIF_MI_CTRL_BURST_LEN_LUM_8 |
+			CIF_MI_CTRL_BURST_LEN_CHROM_8;
+	else
+		burst = CIF_MI_CTRL_BURST_LEN_LUM_4 |
+			CIF_MI_CTRL_BURST_LEN_CHROM_4;
+
+	if (cb_offs % (bus * 4) ||
+		cr_offs % (bus * 4))
+		v4l2_warn(&dev->v4l2_dev,
+			"%dx%d fmt:0x%x not support, should be %d aligned\n",
+			stream->out_fmt.width,
+			stream->out_fmt.height,
+			stream->out_fmt.pixelformat,
+			(cr_offs == 0) ? bus * 4 : bus * 16);
+
+	stream->burst = burst;
+	for (i = 0; i < RKISP_MAX_STREAM; i++)
+		if (burst > dev->cap_dev.stream[i].burst)
+			burst = dev->cap_dev.stream[i].burst;
+
+	if (stream->interlaced) {
+		if (!stream->out_fmt.width % (bus * 16))
+			stream->burst = CIF_MI_CTRL_BURST_LEN_LUM_16 |
+				CIF_MI_CTRL_BURST_LEN_CHROM_16;
+		else if (!stream->out_fmt.width % (bus * 8))
+			stream->burst = CIF_MI_CTRL_BURST_LEN_LUM_8 |
+				CIF_MI_CTRL_BURST_LEN_CHROM_8;
+		else
+			stream->burst = CIF_MI_CTRL_BURST_LEN_LUM_4 |
+				CIF_MI_CTRL_BURST_LEN_CHROM_4;
+		if (stream->out_fmt.width % (bus * 4))
+			v4l2_warn(&dev->v4l2_dev,
+				"interlaced: width should be %d aligned\n",
+				bus * 4);
+		burst = min(stream->burst, burst);
+		stream->burst = burst;
+	}
+
+	return burst;
+}
+
+/*
+ * configure memory interface for mainpath
+ * This should only be called when stream-on
+ */
+static int mp_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+       /*
+	* NOTE: plane_fmt[0].sizeimage is total size of all planes for single
+	* memory plane formats, so calculate the size explicitly.
+	*/
+	mi_set_y_size(stream, stream->out_fmt.plane_fmt[0].bytesperline *
+			 stream->out_fmt.height);
+	mi_set_cb_size(stream, stream->out_fmt.plane_fmt[1].sizeimage);
+	mi_set_cr_size(stream, stream->out_fmt.plane_fmt[2].sizeimage);
+	mi_frame_end_int_enable(stream);
+	if (stream->out_isp_fmt.uv_swap)
+		mp_set_uv_swap(base);
+
+	config_mi_ctrl(stream, calc_burst_len(stream));
+	mp_mi_ctrl_set_format(base, stream->out_isp_fmt.write_format);
+	mp_mi_ctrl_autoupdate_en(base);
+
+	/* set up first buffer */
+	mi_frame_end(stream);
+	return 0;
+}
+
+static int mbus_code_sp_in_fmt(u32 in_mbus_code, u32 out_fourcc, u32 *format)
+{
+	switch (in_mbus_code) {
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		*format = MI_CTRL_SP_INPUT_YUV422;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * Only SP can support output format of YCbCr4:0:0,
+	 * and the input format of SP must be YCbCr4:0:0
+	 * when outputting YCbCr4:0:0.
+	 * The output format of isp is YCbCr4:2:2,
+	 * so the CbCr data is discarded here.
+	 */
+	if (out_fourcc == V4L2_PIX_FMT_GREY)
+		*format = MI_CTRL_SP_INPUT_YUV400;
+
+	return 0;
+}
+
+/*
+ * configure memory interface for selfpath
+ * This should only be called when stream-on
+ */
+static int sp_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct capture_fmt *output_isp_fmt = &stream->out_isp_fmt;
+	struct ispsd_out_fmt *input_isp_fmt =
+			rkisp_get_ispsd_out_fmt(&dev->isp_sdev);
+	u32 sp_in_fmt;
+
+	if (mbus_code_sp_in_fmt(input_isp_fmt->mbus_code,
+				output_isp_fmt->fourcc, &sp_in_fmt)) {
+		v4l2_err(&dev->v4l2_dev, "Can't find the input format\n");
+		return -EINVAL;
+	}
+
+       /*
+	* NOTE: plane_fmt[0].sizeimage is total size of all planes for single
+	* memory plane formats, so calculate the size explicitly.
+	*/
+	mi_set_y_size(stream, stream->out_fmt.plane_fmt[0].bytesperline *
+		      stream->out_fmt.height);
+	mi_set_cb_size(stream, stream->out_fmt.plane_fmt[1].sizeimage);
+	mi_set_cr_size(stream, stream->out_fmt.plane_fmt[2].sizeimage);
+
+	sp_set_y_width(base, stream->out_fmt.width);
+	if (stream->interlaced) {
+		stream->u.sp.vir_offs =
+			stream->out_fmt.plane_fmt[0].bytesperline;
+		sp_set_y_height(base, stream->out_fmt.height / 2);
+		sp_set_y_line_length(base, stream->u.sp.y_stride * 2);
+	} else {
+		sp_set_y_height(base, stream->out_fmt.height);
+		sp_set_y_line_length(base, stream->u.sp.y_stride);
+	}
+
+	mi_frame_end_int_enable(stream);
+	if (output_isp_fmt->uv_swap)
+		sp_set_uv_swap(base);
+
+	config_mi_ctrl(stream, calc_burst_len(stream));
+	sp_mi_ctrl_set_format(base, stream->out_isp_fmt.write_format |
+			      sp_in_fmt | output_isp_fmt->output_format);
+
+	sp_mi_ctrl_autoupdate_en(base);
+
+	/* set up first buffer */
+	mi_frame_end(stream);
+	return 0;
+}
+
+static int dmatx3_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	u32 in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH4 - 1].linked ||
+	    stream->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		v4l2_err(&dev->v4l2_dev,
+			 "only mipi sensor support rawwr3\n");
+		return -EINVAL;
+	}
+	atomic_set(&stream->sequence, 0);
+	in_size = stream->out_fmt.plane_fmt[0].sizeimage;
+	raw_wr_set_pic_size(stream,
+			    stream->out_fmt.width,
+			    stream->out_fmt.height);
+	raw_wr_set_pic_offs(stream, 0);
+
+	vc = csi->sink[CSI_SRC_CH4 - 1].index;
+	raw_wr_ctrl(stream,
+		SW_CSI_RAW_WR_CH_EN(vc) |
+		csi->memory |
+		SW_CSI_RAW_WR_EN_ORG);
+	mi_set_y_size(stream, in_size);
+	mi_frame_end(stream);
+	mi_frame_end_int_enable(stream);
+	mi_wr_ctrl2(base, SW_RAW3_WR_AUTOUPD);
+	mi_raw_length(stream);
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "rawwr3 %dx%d ctrl:0x%x\n",
+		 stream->out_fmt.width,
+		 stream->out_fmt.height,
+		 readl(base + CSI2RX_RAW3_WR_CTRL));
+	return 0;
+}
+
+static int dmatx2_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	u32 val, in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH3 - 1].linked ||
+	    stream->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		v4l2_err(&dev->v4l2_dev,
+			 "only mipi sensor support rawwr2 path\n");
+		return -EINVAL;
+	}
+
+	if (!stream->u.dmatx.is_config) {
+		atomic_set(&stream->sequence, 0);
+		in_size = stream->out_fmt.plane_fmt[0].sizeimage;
+		raw_wr_set_pic_size(stream,
+				    stream->out_fmt.width,
+				    stream->out_fmt.height);
+		raw_wr_set_pic_offs(stream, 0);
+		raw_rd_set_pic_size(stream);
+		vc = csi->sink[CSI_SRC_CH3 - 1].index;
+		val = SW_CSI_RAW_WR_CH_EN(vc);
+		val |= csi->memory;
+		if (dev->hdr.op_mode != HDR_NORMAL)
+			val |= SW_CSI_RAW_WR_EN_ORG;
+		raw_wr_ctrl(stream, val);
+		mi_set_y_size(stream, in_size);
+		mi_frame_end(stream);
+		mi_frame_end_int_enable(stream);
+		mi_wr_ctrl2(base, SW_RAW1_WR_AUTOUPD);
+		mi_raw_length(stream);
+		stream->u.dmatx.is_config = true;
+	}
+	return 0;
+}
+
+static int dmatx0_config_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_csi_device *csi = &dev->csi_dev;
+	struct rkisp_stream *dmatx =
+		&dev->cap_dev.stream[RKISP_STREAM_DMATX0];
+	u32 val, in_size;
+	u8 vc;
+
+	if (!csi->sink[CSI_SRC_CH1 - 1].linked ||
+	    dmatx->streaming)
+		return -EBUSY;
+
+	if (!dev->active_sensor ||
+	    (dev->active_sensor &&
+	     dev->active_sensor->mbus.type != V4L2_MBUS_CSI2)) {
+		if (stream->id == RKISP_STREAM_DMATX0)
+			v4l2_err(&dev->v4l2_dev,
+				 "only mipi sensor support rawwr0 path\n");
+		return -EINVAL;
+	}
+
+	in_size = dmatx->out_fmt.plane_fmt[0].sizeimage;
+	if (!stream->u.dmatx.is_config) {
+		if (dmatx->u.dmatx.is_config)
+			return 0;
+		atomic_set(&dmatx->sequence, 0);
+		raw_wr_set_pic_size(dmatx,
+				    dmatx->out_fmt.width,
+				    dmatx->out_fmt.height);
+		raw_wr_set_pic_offs(dmatx, 0);
+		vc = csi->sink[CSI_SRC_CH1 - 1].index;
+		val = SW_CSI_RAW_WR_CH_EN(vc);
+		val |= csi->memory;
+		if (dev->hdr.op_mode != HDR_NORMAL)
+			val |= SW_CSI_RAW_WR_EN_ORG;
+		raw_wr_ctrl(dmatx, val);
+		mi_set_y_size(dmatx, in_size);
+		mi_frame_end(dmatx);
+		mi_frame_end_int_enable(dmatx);
+		mi_wr_ctrl2(base, SW_RAW0_WR_AUTOUPD);
+		mi_raw_length(stream);
+		dmatx->u.dmatx.is_config = true;
+	}
+
+	return 0;
+}
+
+static void mp_enable_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct capture_fmt *isp_fmt = &stream->out_isp_fmt;
+
+	mi_ctrl_mp_disable(base);
+	if (isp_fmt->fmt_type == FMT_BAYER)
+		mi_ctrl_mpraw_enable(base);
+	else if (isp_fmt->fmt_type == FMT_YUV)
+		mi_ctrl_mpyuv_enable(base);
+}
+
+static void sp_enable_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+	mi_ctrl_spyuv_enable(base);
+}
+
+static void dmatx_enable_mi(struct rkisp_stream *stream)
+{
+	raw_wr_enable(stream);
+}
+
+static void mp_disable_mi(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
+
+	mi_ctrl_mp_disable(base);
+}
+
+static void sp_disable_mi(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+
+	mi_ctrl_spyuv_disable(base);
+}
+
+static void update_dmatx_v2(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	void __iomem *base = dev->base_addr;
+	struct rkisp_dummy_buffer *buf = NULL;
+	u8 index;
+
+	if (stream->next_buf) {
+		mi_set_y_addr(stream,
+			      stream->next_buf->buff_addr[RKISP_PLANE_Y]);
+	} else {
+		if (stream->id == RKISP_STREAM_DMATX0)
+			index = dev->hdr.index[HDR_DMA0];
+		else if (stream->id == RKISP_STREAM_DMATX2)
+			index = dev->hdr.index[HDR_DMA2];
+
+		if ((stream->id == RKISP_STREAM_DMATX0 ||
+		     stream->id == RKISP_STREAM_DMATX2)) {
+			buf = hdr_dqbuf(&dev->hdr.q_tx[index]);
+			if (IS_HDR_RDBK(dev->hdr.op_mode) &&
+			    !dev->dmarx_dev.trigger)
+				hdr_qbuf(&dev->hdr.q_rx[index], buf);
+			else
+				hdr_qbuf(&dev->hdr.q_tx[index], buf);
+		}
+		if (!buf && stream->dummy_buf.mem_priv)
+			buf = &stream->dummy_buf;
+		if (buf)
+			mi_set_y_addr(stream, buf->dma_addr);
+	}
+	v4l2_dbg(2, rkisp_debug, &dev->v4l2_dev,
+		 "%s stream:%d Y:0x%x SHD:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + stream->config->mi.y_base_ad_init),
+		 readl(base + stream->config->mi.y_base_ad_shd));
+}
+
+/* Update buffer info to memory interface, it's called in interrupt */
+static void update_mi(struct rkisp_stream *stream)
+{
+	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
+	void __iomem *base = stream->ispdev->base_addr;
+
+	/* The dummy space allocated by dma_alloc_coherent is used, we can
+	 * throw data to it if there is no available buffer.
+	 */
+	if (stream->next_buf) {
+		mi_set_y_addr(stream,
+			stream->next_buf->buff_addr[RKISP_PLANE_Y]);
+		mi_set_cb_addr(stream,
+			stream->next_buf->buff_addr[RKISP_PLANE_CB]);
+		mi_set_cr_addr(stream,
+			stream->next_buf->buff_addr[RKISP_PLANE_CR]);
+	} else {
+		mi_set_y_addr(stream, dummy_buf->dma_addr);
+		mi_set_cb_addr(stream, dummy_buf->dma_addr);
+		mi_set_cr_addr(stream, dummy_buf->dma_addr);
+	}
+
+	mi_set_y_offset(stream, 0);
+	mi_set_cb_offset(stream, 0);
+	mi_set_cr_offset(stream, 0);
+	v4l2_dbg(2, rkisp_debug, &stream->ispdev->v4l2_dev,
+		 "%s stream:%d Y:0x%x CB:0x%x CR:0x%x\n",
+		 __func__, stream->id,
+		 readl(base + stream->config->mi.y_base_ad_init),
+		 readl(base + stream->config->mi.cb_base_ad_init),
+		 readl(base + stream->config->mi.cr_base_ad_init));
+}
+
+static void mp_stop_mi(struct rkisp_stream *stream)
+{
+	if (!stream->streaming)
+		return;
+	mi_frame_end_int_clear(stream);
+	stream->ops->disable_mi(stream);
+}
+
+static void sp_stop_mi(struct rkisp_stream *stream)
+{
+	if (!stream->streaming)
+		return;
+	mi_frame_end_int_clear(stream);
+	stream->ops->disable_mi(stream);
+}
+
+static void dmatx_stop_mi(struct rkisp_stream *stream)
+{
+	raw_wr_disable(stream);
+	stream->u.dmatx.is_config = false;
+}
+
+static struct streams_ops rkisp_mp_streams_ops = {
+	.config_mi = mp_config_mi,
+	.enable_mi = mp_enable_mi,
+	.disable_mi = mp_disable_mi,
+	.stop_mi = mp_stop_mi,
+	.set_data_path = mp_set_data_path,
+	.is_stream_stopped = mp_is_stream_stopped,
+	.update_mi = update_mi,
+	.frame_end = mi_frame_end,
+};
+
+static struct streams_ops rkisp_sp_streams_ops = {
+	.config_mi = sp_config_mi,
+	.enable_mi = sp_enable_mi,
+	.disable_mi = sp_disable_mi,
+	.stop_mi = sp_stop_mi,
+	.set_data_path = sp_set_data_path,
+	.is_stream_stopped = sp_is_stream_stopped,
+	.update_mi = update_mi,
+	.frame_end = mi_frame_end,
+};
+
+static struct streams_ops rkisp2_dmatx0_streams_ops = {
+	.config_mi = dmatx0_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx0_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+	.frame_end = mi_frame_end,
+};
+
+static struct streams_ops rkisp2_dmatx2_streams_ops = {
+	.config_mi = dmatx2_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx2_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+	.frame_end = mi_frame_end,
+};
+
+static struct streams_ops rkisp2_dmatx3_streams_ops = {
+	.config_mi = dmatx3_config_mi,
+	.enable_mi = dmatx_enable_mi,
+	.stop_mi = dmatx_stop_mi,
+	.is_stream_stopped = dmatx3_is_stream_stopped,
+	.update_mi = update_dmatx_v2,
+	.frame_end = mi_frame_end,
+};
+
+static void rdbk_frame_end(struct rkisp_stream *stream)
+{
+	struct rkisp_device *isp_dev = stream->ispdev;
+	struct rkisp_capture_device *cap = &isp_dev->cap_dev;
+	struct rkisp_sensor_info *sensor = isp_dev->active_sensor;
+	u32 denominator = sensor->fi.interval.denominator;
+	u32 numerator = sensor->fi.interval.numerator;
+	u64 l_ts, s_ts;
+	int ret, fps = -1, time = 30000000;
+
+	if (stream->id != RKISP_STREAM_DMATX2)
+		return;
+
+	if (isp_dev->hdr.op_mode == HDR_RDBK_FRAME1) {
+		vb2_buffer_done(&cap->rdbk_buf[RDBK_S]->vb.vb2_buf, VB2_BUF_STATE_DONE);
+		cap->rdbk_buf[RDBK_S] = NULL;
+		return;
+	}
+
+	if (denominator && numerator)
+		time = numerator * 1000 / denominator * 1000 * 1000;
+
+	if (cap->rdbk_buf[RDBK_L] && cap->rdbk_buf[RDBK_S]) {
+		l_ts = cap->rdbk_buf[RDBK_L]->vb.vb2_buf.timestamp;
+		s_ts = cap->rdbk_buf[RDBK_S]->vb.vb2_buf.timestamp;
+
+		if ((s_ts - l_ts) > time) {
+			ret = v4l2_subdev_call(sensor->sd,
+				video, g_frame_interval, &sensor->fi);
+			if (!ret) {
+				denominator = sensor->fi.interval.denominator;
+				numerator = sensor->fi.interval.numerator;
+				time = numerator * 1000 / denominator * 1000 * 1000;
+				if (numerator)
+					fps = denominator / numerator;
+			}
+			if ((s_ts - l_ts) > time) {
+				v4l2_err(&isp_dev->v4l2_dev,
+					 "timestamp no match, s:%lld l:%lld, fps:%d\n",
+					 s_ts, l_ts, fps);
+				goto RDBK_FRM_UNMATCH;
+			}
+		}
+
+		if (s_ts < l_ts) {
+			v4l2_err(&isp_dev->v4l2_dev,
+				 "s/l frame err, timestamp s:%lld l:%lld\n",
+				 s_ts, l_ts);
+			goto RDBK_FRM_UNMATCH;
+		}
+
+		cap->rdbk_buf[RDBK_S]->vb.sequence =
+			cap->rdbk_buf[RDBK_L]->vb.sequence;
+		vb2_buffer_done(&cap->rdbk_buf[RDBK_L]->vb.vb2_buf,
+			VB2_BUF_STATE_DONE);
+		vb2_buffer_done(&cap->rdbk_buf[RDBK_S]->vb.vb2_buf,
+			VB2_BUF_STATE_DONE);
+	} else {
+		v4l2_err(&isp_dev->v4l2_dev, "lost long frames\n");
+		goto RDBK_FRM_UNMATCH;
+	}
+
+	cap->rdbk_buf[RDBK_L] = NULL;
+	cap->rdbk_buf[RDBK_S] = NULL;
+	return;
+
+RDBK_FRM_UNMATCH:
+	if (cap->rdbk_buf[RDBK_L])
+		rkisp_buf_queue(&cap->rdbk_buf[RDBK_L]->vb.vb2_buf);
+	if (cap->rdbk_buf[RDBK_S])
+		rkisp_buf_queue(&cap->rdbk_buf[RDBK_S]->vb.vb2_buf);
+
+	cap->rdbk_buf[RDBK_L] = NULL;
+	cap->rdbk_buf[RDBK_S] = NULL;
+}
+
+/*
+ * This function is called when a frame end come. The next frame
+ * is processing and we should set up buffer for next-next frame,
+ * otherwise it will overflow.
+ */
+static int mi_frame_end(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_capture_device *cap = &dev->cap_dev;
+	struct capture_fmt *isp_fmt = &stream->out_isp_fmt;
+	bool interlaced = stream->interlaced;
+	unsigned long lock_flags = 0;
+	int i = 0;
+
+	if (!stream->next_buf && stream->streaming &&
+	    dev->dmarx_dev.trigger == T_MANUAL &&
+	    is_rdbk_stream(stream))
+		v4l2_info(&dev->v4l2_dev,
+			  "tx stream:%d lose frame:%d, isp state:0x%x frame:%d\n",
+			  stream->id, atomic_read(&stream->sequence) - 1,
+			  dev->isp_state, dev->dmarx_dev.cur_frame.id);
+
+	if (stream->curr_buf &&
+	    (!interlaced ||
+	     (stream->u.sp.field_rec == RKISP_FIELD_ODD &&
+	      stream->u.sp.field == RKISP_FIELD_EVEN))) {
+		struct vb2_buffer *vb2_buf = &stream->curr_buf->vb.vb2_buf;
+		u64 ns = 0;
+
+		/* Dequeue a filled buffer */
+		for (i = 0; i < isp_fmt->mplanes; i++) {
+			u32 payload_size =
+				stream->out_fmt.plane_fmt[i].sizeimage;
+			vb2_set_plane_payload(vb2_buf, i, payload_size);
+		}
+		if (stream->id == RKISP_STREAM_MP ||
+		    stream->id == RKISP_STREAM_SP)
+			rkisp_dmarx_get_frame(dev,
+					      &stream->curr_buf->vb.sequence,
+					      &ns, false);
+		else
+			stream->curr_buf->vb.sequence =
+				atomic_read(&stream->sequence) - 1;
+		if (!ns)
+			ns = ktime_get_ns();
+		vb2_buf->timestamp = ns;
+
+		if (is_rdbk_stream(stream) &&
+		    dev->dmarx_dev.trigger == T_MANUAL) {
+			if (stream->id == RKISP_STREAM_DMATX0) {
+				if (cap->rdbk_buf[RDBK_L]) {
+					v4l2_err(&dev->v4l2_dev,
+						 "multiple long data in hdr frame\n");
+					rkisp_buf_queue(&cap->rdbk_buf[RDBK_L]->vb.vb2_buf);
+				}
+				cap->rdbk_buf[RDBK_L] = stream->curr_buf;
+			} else {
+				if (cap->rdbk_buf[RDBK_S]) {
+					v4l2_err(&dev->v4l2_dev,
+						 "multiple short data in hdr frame\n");
+					rkisp_buf_queue(&cap->rdbk_buf[RDBK_S]->vb.vb2_buf);
+				}
+				cap->rdbk_buf[RDBK_S] = stream->curr_buf;
+				rdbk_frame_end(stream);
+			}
+		} else {
+			vb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);
+		}
+
+		stream->curr_buf = NULL;
+	}
+
+	if (!interlaced ||
+		(stream->curr_buf == stream->next_buf &&
+		stream->u.sp.field == RKISP_FIELD_ODD)) {
+		/* Next frame is writing to it
+		 * Interlaced: odd field next buffer address
+		 */
+		stream->curr_buf = stream->next_buf;
+		stream->next_buf = NULL;
+
+		/* Set up an empty buffer for the next-next frame */
+		spin_lock_irqsave(&stream->vbq_lock, lock_flags);
+		if (!list_empty(&stream->buf_queue)) {
+			stream->next_buf =
+				list_first_entry(&stream->buf_queue,
+						 struct rkisp_buffer,
+						 queue);
+			list_del(&stream->next_buf->queue);
+		}
+		spin_unlock_irqrestore(&stream->vbq_lock, lock_flags);
+	} else if (stream->u.sp.field_rec == RKISP_FIELD_ODD &&
+		stream->u.sp.field == RKISP_FIELD_EVEN) {
+		/* Interlaced: event field next buffer address */
+		if (stream->next_buf) {
+			stream->next_buf->buff_addr[RKISP_PLANE_Y] +=
+				stream->u.sp.vir_offs;
+			stream->next_buf->buff_addr[RKISP_PLANE_CB] +=
+				stream->u.sp.vir_offs;
+			stream->next_buf->buff_addr[RKISP_PLANE_CR] +=
+				stream->u.sp.vir_offs;
+		}
+		stream->curr_buf = stream->next_buf;
+	}
+
+	stream->ops->update_mi(stream);
+
+	if (interlaced)
+		stream->u.sp.field_rec = stream->u.sp.field;
+
+	return 0;
+}
+
+/***************************** vb2 operations*******************************/
+
+/*
+ * Set flags and wait, it should stop in interrupt.
+ * If it didn't, stop it by force.
+ */
+static void rkisp_stream_stop(struct rkisp_stream *stream)
+{
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	int ret = 0;
+
+	if (!dev->dmarx_dev.trigger &&
+	    is_rdbk_stream(stream)) {
+		stream->streaming = false;
+		return;
+	}
+
+	stream->stopping = true;
+	stream->ops->stop_mi(stream);
+	if (atomic_read(&dev->cap_dev.refcnt) ==  1)
+		hdr_stop_dmatx(dev);
+	if ((dev->isp_state & ISP_START) &&
+	    dev->isp_inp != INP_DMARX_ISP) {
+		ret = wait_event_timeout(stream->done,
+					 !stream->streaming,
+					 msecs_to_jiffies(1000));
+		if (!ret)
+			v4l2_warn(v4l2_dev, "%s id:%d timeout\n",
+				  __func__, stream->id);
+	}
+
+	stream->stopping = false;
+	stream->streaming = false;
+
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
+		rkisp_disable_dcrop(stream, true);
+		rkisp_disable_rsz(stream, true);
+	}
+
+	stream->burst =
+		CIF_MI_CTRL_BURST_LEN_LUM_16 |
+		CIF_MI_CTRL_BURST_LEN_CHROM_16;
+	stream->interlaced = false;
+}
+
+/*
+ * Most of registers inside rockchip isp1 have shadow register since
+ * they must be not changed during processing a frame.
+ * Usually, each sub-module updates its shadow register after
+ * processing the last pixel of a frame.
+ */
+static int rkisp_start(struct rkisp_stream *stream)
+{
+	void __iomem *base = stream->ispdev->base_addr;
+	struct rkisp_device *dev = stream->ispdev;
+	bool is_update = false;
+	int ret;
+
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
+		is_update = (stream->id == RKISP_STREAM_MP) ?
+			!dev->cap_dev.stream[RKISP_STREAM_SP].streaming :
+			!dev->cap_dev.stream[RKISP_STREAM_MP].streaming;
+	}
+
+	if (stream->ops->set_data_path)
+		stream->ops->set_data_path(base);
+	ret = stream->ops->config_mi(stream);
+	if (ret)
+		return ret;
+
+	stream->ops->enable_mi(stream);
+	/* It's safe to config ACTIVE and SHADOW regs for the
+	 * first stream. While when the second is starting, do NOT
+	 * force_cfg_update() because it also update the first one.
+	 *
+	 * The latter case would drop one more buf(that is 2) since
+	 * there's not buf in shadow when the second FE received. This's
+	 * also required because the second FE maybe corrupt especially
+	 * when run at 120fps.
+	 */
+	if (is_update) {
+		hdr_config_dmatx(dev);
+		force_cfg_update(dev);
+		mi_frame_end(stream);
+		hdr_update_dmatx_buf(dev);
+	}
+	stream->streaming = true;
+
+	return 0;
+}
+
+static int rkisp_queue_setup(struct vb2_queue *queue,
+			      unsigned int *num_buffers,
+			      unsigned int *num_planes,
+			      unsigned int sizes[],
+			      struct device *alloc_ctxs[])
+{
+	struct rkisp_stream *stream = queue->drv_priv;
+	struct rkisp_device *dev = stream->ispdev;
+	const struct v4l2_pix_format_mplane *pixm = NULL;
+	const struct capture_fmt *isp_fmt = NULL;
+	u32 i;
+
+	pixm = &stream->out_fmt;
+	isp_fmt = &stream->out_isp_fmt;
+	*num_planes = isp_fmt->mplanes;
+
+	for (i = 0; i < isp_fmt->mplanes; i++) {
+		const struct v4l2_plane_pix_format *plane_fmt;
+
+		plane_fmt = &pixm->plane_fmt[i];
+		/* height to align with 16 when allocating memory
+		 * so that Rockchip encoder can use DMA buffer directly
+		 */
+		sizes[i] = (isp_fmt->fmt_type == FMT_YUV) ?
+			plane_fmt->sizeimage / pixm->height *
+			ALIGN(pixm->height, 16) :
+			plane_fmt->sizeimage;
+	}
+
+	rkisp_chk_tb_over(dev);
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev, "%s count %d, size %d\n",
+		 v4l2_type_names[queue->type], *num_buffers, sizes[0]);
+
+	return rkisp_create_dummy_buf(stream);
+}
+
+/*
+ * The vb2_buffer are stored in rkisp_buffer, in order to unify
+ * mplane buffer and none-mplane buffer.
+ */
+static void rkisp_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct rkisp_buffer *ispbuf = to_rkisp_buffer(vbuf);
+	struct vb2_queue *queue = vb->vb2_queue;
+	struct rkisp_stream *stream = queue->drv_priv;
+	unsigned long lock_flags = 0;
+	struct v4l2_pix_format_mplane *pixm = &stream->out_fmt;
+	struct capture_fmt *isp_fmt = &stream->out_isp_fmt;
+	int i;
+
+	memset(ispbuf->buff_addr, 0, sizeof(ispbuf->buff_addr));
+	for (i = 0; i < isp_fmt->mplanes; i++)
+		ispbuf->buff_addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);
+
+	/*
+	 * NOTE: plane_fmt[0].sizeimage is total size of all planes for single
+	 * memory plane formats, so calculate the size explicitly.
+	 */
+	if (isp_fmt->mplanes == 1) {
+		for (i = 0; i < isp_fmt->cplanes - 1; i++) {
+			ispbuf->buff_addr[i + 1] = (i == 0) ?
+				ispbuf->buff_addr[i] +
+				pixm->plane_fmt[i].bytesperline *
+				pixm->height :
+				ispbuf->buff_addr[i] +
+				pixm->plane_fmt[i].sizeimage;
+		}
+	}
+
+	v4l2_dbg(2, rkisp_debug, &stream->ispdev->v4l2_dev,
+		 "stream:%d queue buf:0x%x\n",
+		 stream->id, ispbuf->buff_addr[0]);
+
+	spin_lock_irqsave(&stream->vbq_lock, lock_flags);
+
+	/* XXX: replace dummy to speed up  */
+	if (stream->streaming &&
+	    !stream->next_buf &&
+	    !stream->interlaced &&
+	    stream->id != RKISP_STREAM_DMATX0 &&
+	    stream->id != RKISP_STREAM_DMATX1 &&
+	    stream->id != RKISP_STREAM_DMATX2 &&
+	    stream->id != RKISP_STREAM_DMATX3 &&
+	    atomic_read(&stream->ispdev->isp_sdev.frm_sync_seq) == 0) {
+		stream->next_buf = ispbuf;
+		stream->ops->update_mi(stream);
+	} else {
+		list_add_tail(&ispbuf->queue, &stream->buf_queue);
+	}
+	spin_unlock_irqrestore(&stream->vbq_lock, lock_flags);
+}
+
+static int rkisp_create_dummy_buf(struct rkisp_stream *stream)
+{
+	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
+	struct rkisp_device *dev = stream->ispdev;
+	u32 size = max3(stream->out_fmt.plane_fmt[0].bytesperline *
+			stream->out_fmt.height,
+			stream->out_fmt.plane_fmt[1].sizeimage,
+			stream->out_fmt.plane_fmt[2].sizeimage);
+
+	if (dummy_buf->mem_priv) {
+		if (dummy_buf->size >= size)
+			return 0;
+		rkisp_free_buffer(dev, dummy_buf);
+	}
+
+	dummy_buf->size = size;
+	if (rkisp_alloc_buffer(dev, dummy_buf) < 0) {
+		v4l2_err(&dev->v4l2_dev,
+			 "Failed to allocate the memory for dummy buffer\n");
+		return -ENOMEM;
+	}
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "stream:%d dummy buf:0x%x\n",
+		 stream->id, (u32)dummy_buf->dma_addr);
+	return 0;
+}
+
+static void rkisp_destroy_dummy_buf(struct rkisp_stream *stream)
+{
+	struct rkisp_dummy_buffer *dummy_buf = &stream->dummy_buf;
+	struct rkisp_device *dev = stream->ispdev;
+
+	rkisp_free_buffer(dev, dummy_buf);
+	hdr_destroy_buf(dev);
+}
+
+static void destroy_buf_queue(struct rkisp_stream *stream,
+			      enum vb2_buffer_state state)
+{
+	struct rkisp_device *isp_dev = stream->ispdev;
+	struct rkisp_capture_device *cap = &isp_dev->cap_dev;
+	unsigned long lock_flags = 0;
+	struct rkisp_buffer *buf;
+
+	spin_lock_irqsave(&stream->vbq_lock, lock_flags);
+	if (cap->rdbk_buf[RDBK_L] && stream->id == RKISP_STREAM_DMATX0) {
+		list_add_tail(&cap->rdbk_buf[RDBK_L]->queue,
+			&stream->buf_queue);
+		if (cap->rdbk_buf[RDBK_L] == stream->curr_buf)
+			stream->curr_buf = NULL;
+		if (cap->rdbk_buf[RDBK_L] == stream->next_buf)
+			stream->next_buf = NULL;
+		cap->rdbk_buf[RDBK_L] = NULL;
+	}
+	if (cap->rdbk_buf[RDBK_S] && stream->id == RKISP_STREAM_DMATX2) {
+		list_add_tail(&cap->rdbk_buf[RDBK_S]->queue,
+			&stream->buf_queue);
+		if (cap->rdbk_buf[RDBK_S] == stream->curr_buf)
+			stream->curr_buf = NULL;
+		if (cap->rdbk_buf[RDBK_S] == stream->next_buf)
+			stream->next_buf = NULL;
+		cap->rdbk_buf[RDBK_S] = NULL;
+	}
+	if (stream->curr_buf) {
+		list_add_tail(&stream->curr_buf->queue, &stream->buf_queue);
+		if (stream->curr_buf == stream->next_buf)
+			stream->next_buf = NULL;
+		stream->curr_buf = NULL;
+	}
+	if (stream->next_buf) {
+		list_add_tail(&stream->next_buf->queue, &stream->buf_queue);
+		stream->next_buf = NULL;
+	}
+	while (!list_empty(&stream->buf_queue)) {
+		buf = list_first_entry(&stream->buf_queue,
+			struct rkisp_buffer, queue);
+		list_del(&buf->queue);
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+	}
+	spin_unlock_irqrestore(&stream->vbq_lock, lock_flags);
+}
+
+static void rkisp_stop_streaming(struct vb2_queue *queue)
+{
+	struct rkisp_stream *stream = queue->drv_priv;
+	struct rkisp_vdev_node *node = &stream->vnode;
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	int ret;
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s %d\n", __func__, stream->id);
+
+	if (!stream->streaming)
+		return;
+
+	rkisp_stream_stop(stream);
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
+		/* call to the other devices */
+		media_pipeline_stop(&node->vdev.entity);
+		ret = dev->pipe.set_stream(&dev->pipe, false);
+		if (ret < 0)
+			v4l2_err(v4l2_dev,
+				 "pipeline stream-off failed:%d\n", ret);
+	}
+
+	/* release buffers */
+	destroy_buf_queue(stream, VB2_BUF_STATE_ERROR);
+
+	ret = dev->pipe.close(&dev->pipe);
+	if (ret < 0)
+		v4l2_err(v4l2_dev, "pipeline close failed error:%d\n", ret);
+	rkisp_destroy_dummy_buf(stream);
+	atomic_dec(&dev->cap_dev.refcnt);
+}
+
+static int rkisp_stream_start(struct rkisp_stream *stream)
+{
+	struct v4l2_device *v4l2_dev = &stream->ispdev->v4l2_dev;
+	struct rkisp_device *dev = stream->ispdev;
+	struct rkisp_stream *other = &dev->cap_dev.stream[stream->id ^ 1];
+	bool async = false;
+	int ret;
+
+	/* STREAM DMATX don't have rsz and dcrop */
+	if (stream->id == RKISP_STREAM_DMATX0 ||
+	    stream->id == RKISP_STREAM_DMATX1 ||
+	    stream->id == RKISP_STREAM_DMATX2 ||
+	    stream->id == RKISP_STREAM_DMATX3)
+		goto end;
+
+	if (other->streaming)
+		async = true;
+
+	ret = rkisp_stream_config_rsz(stream, async);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "config rsz failed with error %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * can't be async now, otherwise the latter started stream fails to
+	 * produce mi interrupt.
+	 */
+	ret = rkisp_stream_config_dcrop(stream, false);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "config dcrop failed with error %d\n", ret);
+		return ret;
+	}
+
+end:
+	return rkisp_start(stream);
+}
+
+static int
+rkisp_start_streaming(struct vb2_queue *queue, unsigned int count)
+{
+	struct rkisp_stream *stream = queue->drv_priv;
+	struct rkisp_vdev_node *node = &stream->vnode;
+	struct rkisp_device *dev = stream->ispdev;
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	int ret = -1;
+
+	v4l2_dbg(1, rkisp_debug, &dev->v4l2_dev,
+		 "%s %d\n", __func__, stream->id);
+
+	if (WARN_ON(stream->streaming))
+		return -EBUSY;
+
+	atomic_inc(&dev->cap_dev.refcnt);
+	if (!dev->isp_inp || !stream->linked) {
+		v4l2_err(v4l2_dev, "check video link or isp input\n");
+		goto buffer_done;
+	}
+
+	if (atomic_read(&dev->cap_dev.refcnt) == 1 &&
+	    (dev->isp_inp & INP_CSI || dev->isp_inp & INP_DVP)) {
+		/* update sensor info when first streaming */
+		ret = rkisp_update_sensor_info(dev);
+		if (ret < 0) {
+			v4l2_err(v4l2_dev,
+				 "update sensor info failed %d\n",
+				 ret);
+			goto buffer_done;
+		}
+	}
+
+	if (dev->active_sensor &&
+	    dev->active_sensor->fmt[0].format.field == V4L2_FIELD_INTERLACED) {
+		if (stream->id != RKISP_STREAM_SP) {
+			v4l2_err(v4l2_dev,
+				"only selfpath support interlaced\n");
+			ret = -EINVAL;
+			goto buffer_done;
+		}
+		stream->interlaced = true;
+		stream->u.sp.field = RKISP_FIELD_INVAL;
+		stream->u.sp.field_rec = RKISP_FIELD_INVAL;
+	}
+
+	/* enable clocks/power-domains */
+	ret = dev->pipe.open(&dev->pipe, &node->vdev.entity, true);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "open cif pipeline failed %d\n", ret);
+		goto destroy_dummy_buf;
+	}
+
+	/* configure stream hardware to start */
+	ret = rkisp_stream_start(stream);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "start streaming failed\n");
+		goto close_pipe;
+	}
+
+	if (stream->id == RKISP_STREAM_MP ||
+	    stream->id == RKISP_STREAM_SP) {
+		/* start sub-devices */
+		ret = dev->pipe.set_stream(&dev->pipe, true);
+		if (ret < 0)
+			goto stop_stream;
+
+		ret = media_pipeline_start(&node->vdev.entity, &dev->pipe.pipe);
+		if (ret < 0) {
+			v4l2_err(&dev->v4l2_dev,
+				 "start pipeline failed %d\n", ret);
+			goto pipe_stream_off;
+		}
+	}
+
+	return 0;
+
+pipe_stream_off:
+	dev->pipe.set_stream(&dev->pipe, false);
+stop_stream:
+	rkisp_stream_stop(stream);
+close_pipe:
+	dev->pipe.close(&dev->pipe);
+destroy_dummy_buf:
+	rkisp_destroy_dummy_buf(stream);
+buffer_done:
+	destroy_buf_queue(stream, VB2_BUF_STATE_QUEUED);
+	atomic_dec(&dev->cap_dev.refcnt);
+	stream->streaming = false;
+	return ret;
+}
+
+static struct vb2_ops rkisp_vb2_ops = {
+	.queue_setup = rkisp_queue_setup,
+	.buf_queue = rkisp_buf_queue,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.stop_streaming = rkisp_stop_streaming,
+	.start_streaming = rkisp_start_streaming,
+};
+
+static int rkisp_init_vb2_queue(struct vb2_queue *q,
+				struct rkisp_stream *stream,
+				enum v4l2_buf_type buf_type)
+{
+	q->type = buf_type;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	q->drv_priv = stream;
+	q->ops = &rkisp_vb2_ops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->buf_struct_size = sizeof(struct rkisp_buffer);
+	q->min_buffers_needed = CIF_ISP_REQ_BUFS_MIN;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->lock = &stream->ispdev->apilock;
+	q->dev = stream->ispdev->hw_dev->dev;
+	q->allow_cache_hints = 1;
+	q->bidirectional = 1;
+
+	return vb2_queue_init(q);
+}
+
+static int rkisp_stream_init(struct rkisp_device *dev, u32 id)
+{
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
+	struct rkisp_stream *stream;
+	struct video_device *vdev;
+	struct rkisp_vdev_node *node;
+	int ret = 0;
+
+	stream = &cap_dev->stream[id];
+	stream->id = id;
+	stream->ispdev = dev;
+	vdev = &stream->vnode.vdev;
+
+	INIT_LIST_HEAD(&stream->buf_queue);
+	init_waitqueue_head(&stream->done);
+	spin_lock_init(&stream->vbq_lock);
+	stream->linked = MEDIA_LNK_FL_ENABLED;
+
+	switch (id) {
+	case RKISP_STREAM_SP:
+		strlcpy(vdev->name, SP_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp_sp_streams_ops;
+		stream->config = &rkisp_sp_stream_config;
+		break;
+	case RKISP_STREAM_DMATX0:
+		strlcpy(vdev->name, DMATX0_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx0_streams_ops;
+		stream->config = &rkisp2_dmatx0_stream_config;
+		break;
+	case RKISP_STREAM_DMATX2:
+		strlcpy(vdev->name, DMATX2_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx2_streams_ops;
+		stream->config = &rkisp2_dmatx1_stream_config;
+		break;
+	case RKISP_STREAM_DMATX3:
+		strlcpy(vdev->name, DMATX3_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp2_dmatx3_streams_ops;
+		stream->config = &rkisp2_dmatx3_stream_config;
+		break;
+	default:
+		strlcpy(vdev->name, MP_VDEV_NAME,
+			sizeof(vdev->name));
+		stream->ops = &rkisp_mp_streams_ops;
+		stream->config = &rkisp_mp_stream_config;
+	}
+
+	node = vdev_to_node(vdev);
+	rkisp_init_vb2_queue(&node->buf_queue, stream,
+			     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	ret = rkisp_register_stream_vdev(stream);
+	if (ret < 0)
+		return ret;
+
+	stream->streaming = false;
+	stream->interlaced = false;
+	stream->burst =
+		CIF_MI_CTRL_BURST_LEN_LUM_16 |
+		CIF_MI_CTRL_BURST_LEN_CHROM_16;
+	atomic_set(&stream->sequence, 0);
+	return 0;
+}
+
+int rkisp_register_stream_v21(struct rkisp_device *dev)
+{
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
+	int ret;
+
+	ret = rkisp_stream_init(dev, RKISP_STREAM_MP);
+	if (ret < 0)
+		goto err;
+	ret = rkisp_stream_init(dev, RKISP_STREAM_SP);
+	if (ret < 0)
+		goto err_free_mp;
+	ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX0);
+	if (ret < 0)
+		goto err_free_sp;
+	ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX2);
+	if (ret < 0)
+		goto err_free_tx0;
+	ret = rkisp_stream_init(dev, RKISP_STREAM_DMATX3);
+	if (ret < 0)
+		goto err_free_tx2;
+
+	return 0;
+err_free_tx2:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_DMATX2]);
+err_free_tx0:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_DMATX0]);
+err_free_sp:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_SP]);
+err_free_mp:
+	rkisp_unregister_stream_vdev(&cap_dev->stream[RKISP_STREAM_MP]);
+err:
+	return ret;
+}
+
+void rkisp_unregister_stream_v21(struct rkisp_device *dev)
+{
+	struct rkisp_capture_device *cap_dev = &dev->cap_dev;
+	struct rkisp_stream *stream;
+
+	stream = &cap_dev->stream[RKISP_STREAM_MP];
+	rkisp_unregister_stream_vdev(stream);
+	stream = &cap_dev->stream[RKISP_STREAM_SP];
+	rkisp_unregister_stream_vdev(stream);
+	stream = &cap_dev->stream[RKISP_STREAM_DMATX0];
+	rkisp_unregister_stream_vdev(stream);
+	stream = &cap_dev->stream[RKISP_STREAM_DMATX2];
+	rkisp_unregister_stream_vdev(stream);
+	stream = &cap_dev->stream[RKISP_STREAM_DMATX3];
+	rkisp_unregister_stream_vdev(stream);
+}
+
+/****************  Interrupter Handler ****************/
+
+static void rawrd_frame_end(struct rkisp_device *dev)
+{
+	u32 val = 0;
+
+	if (IS_HDR_RDBK(dev->csi_dev.rd_mode)) {
+		switch (dev->csi_dev.rd_mode) {
+		case HDR_RDBK_FRAME2://for rd0 rd2
+			val |= RAW0_RD_FRAME;
+			/* FALLTHROUGH */
+		default:// for rd2
+			val |= RAW2_RD_FRAME;
+			/* FALLTHROUGH */
+		}
+		rkisp2_rawrd_isr(val, dev);
+	}
+}
+
+void rkisp_mi_v21_isr(u32 mis_val, struct rkisp_device *dev)
+{
+	struct rkisp_stream *stream;
+	unsigned int i;
+	static u8 end_tx0, end_tx2;
+
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "mi isr:0x%x\n", mis_val);
+
+	if (mis_val & CIF_MI_DMA_READY)
+		rkisp_dmarx_isr(mis_val, dev);
+
+	for (i = 0; i < RKISP_MAX_STREAM; ++i) {
+		stream = &dev->cap_dev.stream[i];
+
+		if (!(mis_val & CIF_MI_FRAME(stream)))
+			continue;
+
+		if (i == RKISP_STREAM_DMATX0)
+			end_tx0 = true;
+		if (i == RKISP_STREAM_DMATX2)
+			end_tx2 = true;
+
+		mi_frame_end_int_clear(stream);
+
+		if (stream->stopping) {
+			/*
+			 * Make sure stream is actually stopped, whose state
+			 * can be read from the shadow register, before
+			 * wake_up() thread which would immediately free all
+			 * frame buffers. stop_mi() takes effect at the next
+			 * frame end that sync the configurations to shadow
+			 * regs.
+			 */
+			if (stream->ops->is_stream_stopped(dev->base_addr)) {
+				stream->stopping = false;
+				stream->streaming = false;
+				wake_up(&stream->done);
+			}
+			if (i == RKISP_STREAM_MP) {
+				end_tx0 = false;
+				end_tx2 = false;
+			}
+		} else {
+			mi_frame_end(stream);
+			if (dev->dmarx_dev.trigger == T_AUTO &&
+			    ((dev->hdr.op_mode == HDR_RDBK_FRAME1 && end_tx2) ||
+			     (dev->hdr.op_mode == HDR_RDBK_FRAME2 && end_tx2 && end_tx0))) {
+				end_tx0 = false;
+				end_tx2 = false;
+				rkisp_trigger_read_back(&dev->csi_dev, false, false);
+			}
+		}
+	}
+
+	if (mis_val & (CIF_MI_MP_FRAME | CIF_MI_SP_FRAME)) {
+		rawrd_frame_end(dev);
+		if (dev->dmarx_dev.trigger == T_MANUAL)
+			rkisp_csi_trigger_event(dev, T_CMD_END, NULL);
+	}
+}
+
+void rkisp_mipi_v21_isr(unsigned int phy, unsigned int packet,
+			unsigned int overflow, unsigned int state,
+			struct rkisp_device *dev)
+{
+	struct v4l2_device *v4l2_dev = &dev->v4l2_dev;
+	struct rkisp_stream *stream;
+	int i;
+
+	v4l2_dbg(3, rkisp_debug, &dev->v4l2_dev,
+		 "csi state:0x%x\n", state);
+	if (phy && (dev->isp_inp & INP_CSI))
+		v4l2_warn(v4l2_dev, "MIPI error: phy: 0x%08x\n", phy);
+	if (packet && (dev->isp_inp & INP_CSI))
+		v4l2_warn(v4l2_dev, "MIPI error: packet: 0x%08x\n", packet);
+	if (overflow)
+		v4l2_warn(v4l2_dev, "MIPI error: overflow: 0x%08x\n", overflow);
+	if (state & 0xeff00)
+		v4l2_warn(v4l2_dev, "MIPI error: size: 0x%08x\n", state);
+	if (state & ISP21_MIPI_DROP_FRM)
+		v4l2_warn(v4l2_dev, "MIPI drop frame\n");
+
+	/* first Y_STATE irq as csi sof event */
+	if (state & (RAW0_Y_STATE | RAW1_Y_STATE)) {
+		for (i = 0; i < HDR_DMA_MAX - 1; i++) {
+			if (!((RAW0_Y_STATE << i) & state) ||
+			    dev->csi_dev.tx_first[i])
+				continue;
+			if (i)
+				i++;
+			dev->csi_dev.tx_first[i] = true;
+			rkisp_csi_sof(dev, i);
+			stream = &dev->cap_dev.stream[i + RKISP_STREAM_DMATX0];
+			atomic_inc(&stream->sequence);
+		}
+	}
+	if (state & (RAW0_WR_FRAME | RAW1_WR_FRAME)) {
+		for (i = 0; i < HDR_DMA_MAX - 1; i++) {
+			if (!((RAW0_WR_FRAME << i) & state))
+				continue;
+			if (i)
+				i++;
+			if (!dev->csi_dev.tx_first[i]) {
+				stream = &dev->cap_dev.stream[i + RKISP_STREAM_DMATX0];
+				atomic_inc(&stream->sequence);
+			}
+			dev->csi_dev.tx_first[i] = false;
+		}
+	}
+	if (state & ISP21_RAW3_WR_FRAME) {
+		stream = &dev->cap_dev.stream[RKISP_STREAM_DMATX3];
+		atomic_inc(&stream->sequence);
+	}
+}
diff --git a/drivers/media/platform/rockchip/isp/capture_v2x.h b/drivers/media/platform/rockchip/isp/capture_v2x.h
index 41a1ae54a89c..b9b7d1966eed 100644
--- a/drivers/media/platform/rockchip/isp/capture_v2x.h
+++ b/drivers/media/platform/rockchip/isp/capture_v2x.h
@@ -20,4 +20,9 @@ int rkisp_register_stream_v20(struct rkisp_device *dev);
 void rkisp_unregister_stream_v20(struct rkisp_device *dev);
 void rkisp_mi_v20_isr(u32 mis_val, struct rkisp_device *dev);
 void rkisp_mipi_v20_isr(u32 phy, u32 packet, u32 overflow, u32 state, struct rkisp_device *dev);
+
+int rkisp_register_stream_v21(struct rkisp_device *dev);
+void rkisp_unregister_stream_v21(struct rkisp_device *dev);
+void rkisp_mi_v21_isr(u32 mis_val, struct rkisp_device *dev);
+void rkisp_mipi_v21_isr(u32 phy, u32 packet, u32 overflow, u32 state, struct rkisp_device *dev);
 #endif
diff --git a/drivers/media/platform/rockchip/isp/common.h b/drivers/media/platform/rockchip/isp/common.h
index b6c14698716f..1d793bc30b43 100644
--- a/drivers/media/platform/rockchip/isp/common.h
+++ b/drivers/media/platform/rockchip/isp/common.h
@@ -75,6 +75,7 @@ enum rkisp_isp_ver {
 	ISP_V12 = 0x20,
 	ISP_V13 = 0x30,
 	ISP_V20 = 0x40,
+	ISP_V21 = 0x50,
 };
 
 enum rkisp_sd_type {
diff --git a/drivers/media/platform/rockchip/isp/csi.c b/drivers/media/platform/rockchip/isp/csi.c
index 43c9c77053ff..7a920a5f547d 100644
--- a/drivers/media/platform/rockchip/isp/csi.c
+++ b/drivers/media/platform/rockchip/isp/csi.c
@@ -316,7 +316,7 @@ static int csi_config(struct rkisp_csi_device *csi)
 			 rkisp_read(dev, CIF_ISP_CSI0_CTRL1, true),
 			 rkisp_read(dev, CIF_ISP_CSI0_DATA_IDS_1, true),
 			 rkisp_read(dev, CIF_ISP_CSI0_MASK3, true));
-	} else if (dev->isp_ver == ISP_V20) {
+	} else if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		struct rkmodule_hdr_cfg hdr_cfg;
 		u32 val;
 
@@ -736,11 +736,7 @@ int rkisp_register_csi_subdev(struct rkisp_device *dev,
 		MEDIA_PAD_FL_SOURCE | MEDIA_PAD_FL_MUST_CONNECT;
 
 	csi_dev->max_pad = CSI_SRC_CH0 + 1;
-	if (dev->isp_ver == ISP_V12 ||
-	    dev->isp_ver == ISP_V13) {
-		csi_dev->max_pad = CSI_SRC_CH1 + 1;
-		csi_dev->pads[CSI_SRC_CH1].flags = MEDIA_PAD_FL_SOURCE;
-	} else if (dev->isp_ver == ISP_V20) {
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		csi_dev->max_pad = CSI_PAD_MAX;
 		csi_dev->pads[CSI_SRC_CH1].flags = MEDIA_PAD_FL_SOURCE;
 		csi_dev->pads[CSI_SRC_CH2].flags = MEDIA_PAD_FL_SOURCE;
diff --git a/drivers/media/platform/rockchip/isp/dev.c b/drivers/media/platform/rockchip/isp/dev.c
index 5dcb43afd969..341dba77daf7 100644
--- a/drivers/media/platform/rockchip/isp/dev.c
+++ b/drivers/media/platform/rockchip/isp/dev.c
@@ -394,28 +394,33 @@ static int _set_pipeline_default_fmt(struct rkisp_device *dev)
 	if (dev->isp_ver != ISP_V10_1)
 		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_SP,
 					 width, height, V4L2_PIX_FMT_YUYV);
-	if ((dev->isp_ver == ISP_V12 ||
-	     dev->isp_ver == ISP_V13 ||
-	     dev->isp_ver == ISP_V20) &&
+	if ((dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) &&
 	    dev->active_sensor->mbus.type == V4L2_MBUS_CSI2) {
 		width = dev->active_sensor->fmt[1].format.width;
 		height = dev->active_sensor->fmt[1].format.height;
 		code = dev->active_sensor->fmt[1].format.code;
 		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX0,
 			width, height, rkisp_mbus_pixelcode_to_v4l2(code));
+
+		width = dev->active_sensor->fmt[3].format.width;
+		height = dev->active_sensor->fmt[3].format.height;
+		code = dev->active_sensor->fmt[3].format.code;
+		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX2,
+			width, height, rkisp_mbus_pixelcode_to_v4l2(code));
+
+		width = dev->active_sensor->fmt[4].format.width;
+		height = dev->active_sensor->fmt[4].format.height;
+		code = dev->active_sensor->fmt[4].format.code;
+		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX3,
+			width, height, rkisp_mbus_pixelcode_to_v4l2(code));
 	}
-	if (dev->isp_ver == ISP_V20 &&
-	    dev->active_sensor->mbus.type == V4L2_MBUS_CSI2) {
+
+	if (dev->isp_ver == ISP_V20) {
 		width = dev->active_sensor->fmt[2].format.width;
 		height = dev->active_sensor->fmt[2].format.height;
 		code = dev->active_sensor->fmt[2].format.code;
 		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX1,
 			width, height, rkisp_mbus_pixelcode_to_v4l2(code));
-		width = dev->active_sensor->fmt[3].format.width;
-		height = dev->active_sensor->fmt[3].format.height;
-		code = dev->active_sensor->fmt[3].format.code;
-		rkisp_set_stream_def_fmt(dev, RKISP_STREAM_DMATX2,
-			width, height, rkisp_mbus_pixelcode_to_v4l2(code));
 	}
 	return 0;
 }
@@ -714,7 +719,7 @@ static int rkisp_plat_probe(struct platform_device *pdev)
 	isp_dev->pipe.close = rkisp_pipeline_close;
 	isp_dev->pipe.set_stream = rkisp_pipeline_set_stream;
 
-	if (isp_dev->isp_ver == ISP_V20) {
+	if (isp_dev->isp_ver == ISP_V20 || isp_dev->isp_ver == ISP_V21) {
 		atomic_set(&isp_dev->hdr.refcnt, 0);
 		for (i = 0; i < HDR_DMA_MAX; i++) {
 			INIT_LIST_HEAD(&isp_dev->hdr.q_tx[i]);
diff --git a/drivers/media/platform/rockchip/isp/dmarx.c b/drivers/media/platform/rockchip/isp/dmarx.c
index b4083559454f..1c91daf4dbb2 100644
--- a/drivers/media/platform/rockchip/isp/dmarx.c
+++ b/drivers/media/platform/rockchip/isp/dmarx.c
@@ -666,7 +666,8 @@ static int rkisp_set_fmt(struct rkisp_stream *stream,
 			height = pixm->height / ysubs;
 		}
 
-		if (stream->ispdev->isp_ver == ISP_V20 &&
+		if ((stream->ispdev->isp_ver == ISP_V20 ||
+		     stream->ispdev->isp_ver == ISP_V21) &&
 		    !stream->ispdev->csi_dev.memory &&
 		    stream->id != RKISP_STREAM_DMARX)
 			bytesperline = ALIGN(width * fmt->bpp[i] / 8, 256);
@@ -988,21 +989,23 @@ int rkisp_register_dmarx_vdev(struct rkisp_device *dev)
 	if (ret < 0)
 		goto err;
 #endif
-	if (dev->isp_ver == ISP_V20) {
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		ret = dmarx_init(dev, RKISP_STREAM_RAWRD0);
 		if (ret < 0)
 			goto err_free_dmarx;
-		ret = dmarx_init(dev, RKISP_STREAM_RAWRD1);
+		ret = dmarx_init(dev, RKISP_STREAM_RAWRD2);
 		if (ret < 0)
 			goto err_free_dmarx0;
-		ret = dmarx_init(dev, RKISP_STREAM_RAWRD2);
+	}
+	if (dev->isp_ver == ISP_V20) {
+		ret = dmarx_init(dev, RKISP_STREAM_RAWRD1);
 		if (ret < 0)
-			goto err_free_dmarx1;
+			goto err_free_dmarx2;
 	}
 
 	return 0;
-err_free_dmarx1:
-	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_RAWRD1]);
+err_free_dmarx2:
+	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_RAWRD2]);
 err_free_dmarx0:
 	rkisp_unregister_dmarx_video(&dmarx_dev->stream[RKISP_STREAM_RAWRD0]);
 err_free_dmarx:
@@ -1023,14 +1026,15 @@ void rkisp_unregister_dmarx_vdev(struct rkisp_device *dev)
 	rkisp_unregister_dmarx_video(stream);
 #endif
 
-	if (dev->isp_ver == ISP_V20) {
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD0];
 		rkisp_unregister_dmarx_video(stream);
 
-		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD1];
-		rkisp_unregister_dmarx_video(stream);
-
 		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD2];
 		rkisp_unregister_dmarx_video(stream);
 	}
+	if (dev->isp_ver == ISP_V20) {
+		stream = &dmarx_dev->stream[RKISP_STREAM_RAWRD1];
+		rkisp_unregister_dmarx_video(stream);
+	}
 }
diff --git a/drivers/media/platform/rockchip/isp/hw.c b/drivers/media/platform/rockchip/isp/hw.c
index e90656992fcf..94ccf4d7385b 100644
--- a/drivers/media/platform/rockchip/isp/hw.c
+++ b/drivers/media/platform/rockchip/isp/hw.c
@@ -105,15 +105,19 @@ static irqreturn_t mipi_irq_hdl(int irq, void *ctx)
 
 		if (err1 || err2 || err3)
 			rkisp_mipi_v13_isr(err1, err2, err3, isp);
-	} else if (hw_dev->isp_ver == ISP_V20) {
+	} else if (hw_dev->isp_ver == ISP_V20 || hw_dev->isp_ver == ISP_V21) {
 		u32 phy, packet, overflow, state;
 
 		state = readl(hw_dev->base_addr + CSI2RX_ERR_STAT);
 		phy = readl(hw_dev->base_addr + CSI2RX_ERR_PHY);
 		packet = readl(hw_dev->base_addr + CSI2RX_ERR_PACKET);
 		overflow = readl(hw_dev->base_addr + CSI2RX_ERR_OVERFLOW);
-		if (phy | packet | overflow | state)
-			rkisp_mipi_v20_isr(phy, packet, overflow, state, isp);
+		if (phy | packet | overflow | state) {
+			if (hw_dev->isp_ver == ISP_V20)
+				rkisp_mipi_v20_isr(phy, packet, overflow, state, isp);
+			else
+				rkisp_mipi_v21_isr(phy, packet, overflow, state, isp);
+		}
 	} else {
 		u32 mis_val = readl(hw_dev->base_addr + CIF_MIPI_MIS);
 
@@ -158,7 +162,7 @@ static irqreturn_t isp_irq_hdl(int irq, void *ctx)
 		return IRQ_HANDLED;
 
 	mis_val = readl(hw_dev->base_addr + CIF_ISP_MIS);
-	if (hw_dev->isp_ver == ISP_V20)
+	if (hw_dev->isp_ver == ISP_V20 || hw_dev->isp_ver == ISP_V21)
 		mis_3a = readl(hw_dev->base_addr + ISP_ISP3A_MIS);
 	if (mis_val || mis_3a)
 		rkisp_isp_isr(mis_val, mis_3a, isp);
@@ -174,7 +178,7 @@ static irqreturn_t irq_handler(int irq, void *ctx)
 	unsigned int mis_val, mis_3a = 0;
 
 	mis_val = readl(hw_dev->base_addr + CIF_ISP_MIS);
-	if (hw_dev->isp_ver == ISP_V20)
+	if (hw_dev->isp_ver == ISP_V20 || hw_dev->isp_ver == ISP_V21)
 		mis_3a = readl(hw_dev->base_addr + ISP_ISP3A_MIS);
 	if (mis_val || mis_3a)
 		rkisp_isp_isr(mis_val, mis_3a, isp);
@@ -511,7 +515,7 @@ static void isp_config_clk(struct rkisp_hw_dev *dev, int on)
 		      CIF_CLK_CTRL_CP | CIF_CLK_CTRL_IE;
 
 		writel(val, dev->base_addr + CIF_VI_ISP_CLK_CTRL_V12);
-	} else if (dev->isp_ver == ISP_V20) {
+	} else if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		val = !on ? 0 :
 		      CLK_CTRL_MI_LDC | CLK_CTRL_MI_MP |
 		      CLK_CTRL_MI_JPEG | CLK_CTRL_MI_DP |
@@ -655,10 +659,8 @@ static int rkisp_hw_probe(struct platform_device *pdev)
 	hw_dev->is_mi_update = false;
 	if (!is_iommu_enable(dev)) {
 		ret = of_reserved_mem_device_init(dev);
-		if (ret) {
+		if (ret)
 			dev_err(dev, "No reserved memory region\n");
-			goto err;
-		}
 	}
 
 	pm_runtime_enable(dev);
diff --git a/drivers/media/platform/rockchip/isp/regs_v2x.h b/drivers/media/platform/rockchip/isp/regs_v2x.h
index 647683a80cf8..562cec191353 100644
--- a/drivers/media/platform/rockchip/isp/regs_v2x.h
+++ b/drivers/media/platform/rockchip/isp/regs_v2x.h
@@ -487,6 +487,14 @@
 #define MI_GAIN_WR_BASE2			(MI_BASE + 0x0058c)
 #define MI_GAIN_WR_BASE_SHD			(MI_BASE + 0x00590)
 
+#define ISP21_MI_BAY3D_WR_BASE			(MI_BASE + 0x005a0)
+#define ISP21_MI_BAY3D_WR_SIZE			(MI_BASE + 0x005a4)
+#define ISP21_MI_BAY3D_WR_LENGTH		(MI_BASE + 0x005a8)
+#define ISP21_MI_BAY3D_WR_BASE_SHD		(MI_BASE + 0x005ac)
+#define ISP21_MI_BAY3D_RD_BASE			(MI_BASE + 0x005b0)
+#define ISP21_MI_BAY3D_RD_LENGTH		(MI_BASE + 0x005b4)
+#define ISP21_MI_BAY3D_RD_BASE_SHD		(MI_BASE + 0x005b8)
+
 #define ISP_MPFBC_BASE				0x000018C0
 #define ISP_MPFBC_CTRL				(ISP_MPFBC_BASE + 0x00000)
 #define ISP_MPFBC_VIR_WIDTH			(ISP_MPFBC_BASE + 0x00004)
@@ -2021,32 +2029,78 @@
 #define ISP_ISP_LSC_TABLE_DATA(v0, v1)	\
 	(((v0) & 0x1FFF) | (((v1) & 0x1FFF) << 16))
 
+/* ISP21 ISP CTRL0 */
+#define ISP21_CGC_RATIO_EN		BIT(29)
+#define ISP21_CGC_YUV_LIMIT		BIT(28)
+#define ISP21_NOC_HURRY_W1_MODE(a)	(((a) & 0x7) << 24)
+
+/* ISP CTRL1 */
+#define ISP21_BIGMODE_MODE		BIT(29)
+#define ISP21_BIGMODE_FORCE_EN		BIT(28)
+#define ISP21_RAW3D_FST_FRAME		BIT(27)
+#define ISP21_CNR_FST_FRAME		BIT(26)
+#define ISP21_DHAZ_FST_FRAME		BIT(25)
+#define ISP21_ADRC_FST_FRAME		BIT(24)
+#define ISP21_YNR_FST_FRAME		BIT(23)
+#define ISP21_BT1120_YC_SWAP		BIT(22)
+#define ISP21_DUALEDGE_EN		BIT(21)
+#define ISP21_BI1120_EN			BIT(20)
+#define ISP21_FIELD_INV			BIT(11)
+
+/* ISP21 ACQ_H_OFFS */
+#define ISP21_SENSOR_MODE(a)		(((a) & 3) << 30)
+#define ISP21_SENSOR_INDEX(a)		(((a) & 3) << 28)
+#define ISP21_ACQ_H_OFFS(a)		((a) & 0x7fff)
+
+/* ISP21 ACQ_H_SIZE */
+#define ISP21_ACQ_H_SIZE_BAY3DMI(a)	(((a) & 0xffff) << 16)
+#define ISP21_ACQ_H_SIZE(a)		((a) & 0x7fff)
+
+/* ISP21 MI_WR_INIT */
+#define ISP21_SP_FORCE_UPD		BIT(21)
+#define ISP21_MP_FORCE_UPD		BIT(20)
+
+/* ISP21 MI_WR_CTRL2*/
+#define ISP21_BAY3D_FORCE_UPD		BIT(22)
+#define ISP21_GAIN_FORCE_UPD		BIT(21)
+#define ISP21_DBR_FORCE_UPD		BIT(20)
+#define ISP21_BAY3D_WR_AUTO_UPD		BIT(16)
+
+/* ISP21 CSI2RX */
+#define ISP21_CSI_2PIX_MODE		BIT(1)
+
+#define ISP21_MIPI_DROP_FRM		BIT(31)
+
+#define ISP21_RAW3_WR_FRAME		BIT(3)
+
+#define ISP21_RAW_FORCE_UPD		BIT(31)
+
 static inline bool dmatx0_is_stream_stopped(void __iomem *base)
 {
 	u32 ret = readl(base + CSI2RX_RAW0_WR_CTRL);
 
-	return !(ret & SW_CSI2RX_EN);
+	return !(ret & SW_CSI_RAW_WR_EN_SHD);
 }
 
 static inline bool dmatx1_is_stream_stopped(void __iomem *base)
 {
 	u32 ret = readl(base + CSI2RX_RAW1_WR_CTRL);
 
-	return !(ret & SW_CSI2RX_EN);
+	return !(ret & SW_CSI_RAW_WR_EN_SHD);
 }
 
 static inline bool dmatx2_is_stream_stopped(void __iomem *base)
 {
 	u32 ret = readl(base + CSI2RX_RAW2_WR_CTRL);
 
-	return !(ret & SW_CSI2RX_EN);
+	return !(ret & SW_CSI_RAW_WR_EN_SHD);
 }
 
 static inline bool dmatx3_is_stream_stopped(void __iomem *base)
 {
 	u32 ret = readl(base + CSI2RX_RAW3_WR_CTRL);
 
-	return !(ret & SW_CSI2RX_EN);
+	return !(ret & SW_CSI_RAW_WR_EN_SHD);
 }
 
 static inline bool is_mpfbc_stopped(void __iomem *base)
@@ -2090,16 +2144,20 @@ static inline void raw_wr_enable(struct rkisp_stream *stream)
 {
 	void __iomem *base = stream->ispdev->base_addr;
 	void __iomem *addr = base + stream->config->dma.ctrl;
+	u32 val = readl(addr);
 
-	writel(SW_CSI_RAW_WR_EN_ORG | readl(addr), addr);
+	val |= ISP21_RAW_FORCE_UPD | SW_CSI_RAW_WR_EN_ORG;
+	writel(val, addr);
 }
 
 static inline void raw_wr_disable(struct rkisp_stream *stream)
 {
 	void __iomem *base = stream->ispdev->base_addr;
 	void __iomem *addr = base + stream->config->dma.ctrl;
+	u32 val = readl(addr);
 
-	writel(~SW_CSI_RAW_WR_EN_ORG & readl(addr), addr);
+	val &= ~(ISP21_RAW_FORCE_UPD | SW_CSI_RAW_WR_EN_ORG);
+	writel(val, addr);
 }
 
 static inline void mi_raw0_rd_set_addr(void __iomem *base, u32 val)
@@ -2142,6 +2200,15 @@ static inline void mi_raw_length(struct rkisp_stream *stream)
 		is_direct = false;
 	rkisp_write(stream->ispdev, stream->config->mi.length,
 		    stream->out_fmt.plane_fmt[0].bytesperline, is_direct);
+	if (stream->ispdev->isp_ver == ISP_V21)
+		rkisp_set_bits(stream->ispdev, MI_RD_CTRL2, 0, BIT(30), false);
+}
+
+static inline void rx_force_upd(void __iomem *base)
+{
+	void __iomem *addr = base + CSI2RX_RAW_RD_CTRL;
+
+	writel(ISP21_RAW_FORCE_UPD | readl(addr), addr);
 }
 
 #endif /* _RKISP_REGS_V2X_H */
diff --git a/drivers/media/platform/rockchip/isp/rkisp.c b/drivers/media/platform/rockchip/isp/rkisp.c
index 8236017cd0aa..1f07a539dd4e 100644
--- a/drivers/media/platform/rockchip/isp/rkisp.c
+++ b/drivers/media/platform/rockchip/isp/rkisp.c
@@ -467,7 +467,7 @@ static void rkisp_config_ism(struct rkisp_device *dev)
 	u32 val;
 
 	/* isp2.0 no ism */
-	if (dev->isp_ver == ISP_V20)
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 		return;
 
 	writel(0, base + CIF_ISP_IS_RECENTER);
@@ -523,14 +523,14 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 			if (in_fmt->mbus_code == MEDIA_BUS_FMT_Y8_1X8 ||
 			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y10_1X10 ||
 			    in_fmt->mbus_code == MEDIA_BUS_FMT_Y12_1X12) {
-				if (dev->isp_ver == ISP_V20)
+				if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 					rkisp_write(dev, ISP_DEBAYER_CONTROL, 0, false);
 				else
 					rkisp_write(dev, CIF_ISP_DEMOSAIC,
 						CIF_ISP_DEMOSAIC_BYPASS |
 						CIF_ISP_DEMOSAIC_TH(0xc), false);
 			} else {
-				if (dev->isp_ver == ISP_V20)
+				if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 					rkisp_write(dev, ISP_DEBAYER_CONTROL,
 						SW_DEBAYER_EN |
 						SW_DEBAYER_FILTER_G_EN |
@@ -611,11 +611,12 @@ static int rkisp_config_isp(struct rkisp_device *dev)
 	/* interrupt mask */
 	irq_mask |= CIF_ISP_FRAME | CIF_ISP_V_START | CIF_ISP_PIC_SIZE_ERROR |
 		    CIF_ISP_FRAME_IN;
-	if (dev->isp_ver == ISP_V20)
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 		irq_mask |= ISP2X_LSC_LUT_ERR;
 	rkisp_write(dev, CIF_ISP_IMSC, irq_mask, true);
 
-	if (dev->isp_ver == ISP_V20 && IS_HDR_RDBK(dev->hdr.op_mode)) {
+	if ((dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) &&
+	    IS_HDR_RDBK(dev->hdr.op_mode)) {
 		irq_mask = ISP2X_3A_RAWAE_BIG;
 		rkisp_write(dev, ISP_ISP3A_IMSC, irq_mask, true);
 	}
@@ -867,7 +868,7 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		readl(base + CIF_ISP_CSI0_ERR1);
 		readl(base + CIF_ISP_CSI0_ERR2);
 		readl(base + CIF_ISP_CSI0_ERR3);
-	} else if (dev->isp_ver == ISP_V20) {
+	} else if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		writel(0, base + CSI2RX_MASK_PHY);
 		writel(0, base + CSI2RX_MASK_PACKET);
 		writel(0, base + CSI2RX_MASK_OVERFLOW);
@@ -884,7 +885,7 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 	writel(0, base + CIF_ISP_IMSC);
 	writel(~0, base + CIF_ISP_ICR);
 
-	if (dev->isp_ver == ISP_V20) {
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		writel(0, base + ISP_ISP3A_IMSC);
 		writel(~0, base + ISP_ISP3A_ICR);
 	}
@@ -940,7 +941,7 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 		writel(0, base + CIF_ISP_CSI0_MASK1);
 		writel(0, base + CIF_ISP_CSI0_MASK2);
 		writel(0, base + CIF_ISP_CSI0_MASK3);
-	} else if (dev->isp_ver == ISP_V20) {
+	} else if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 		writel(0, base + CSI2RX_CSI2_RESETN);
 	}
 
@@ -949,7 +950,7 @@ static int rkisp_isp_stop(struct rkisp_device *dev)
 end:
 	rkisp_set_state(dev, ISP_STOP);
 
-	if (dev->isp_ver == ISP_V20)
+	if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 		kfifo_reset(&dev->csi_dev.rdbk_kfifo);
 	if (dev->emd_vc <= CIF_ISP_ADD_DATA_VC_MAX) {
 		for (i = 0; i < RKISP_EMDDATA_FIFO_MAX; i++)
@@ -1520,14 +1521,14 @@ static int rkisp_isp_sd_set_selection(struct v4l2_subdev *sd,
 	if (sel->pad == RKISP_ISP_PAD_SINK) {
 		isp_sd->in_crop = *crop;
 		/* ISP20 don't have out crop */
-		if (dev->isp_ver == ISP_V20) {
+		if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21) {
 			isp_sd->out_crop = *crop;
 			isp_sd->out_crop.left = 0;
 			isp_sd->out_crop.top = 0;
 			dev->br_dev.crop = isp_sd->out_crop;
 		}
 	} else {
-		if (dev->isp_ver == ISP_V20)
+		if (dev->isp_ver == ISP_V20 || dev->isp_ver == ISP_V21)
 			*crop = isp_sd->out_crop;
 		isp_sd->out_crop = *crop;
 	}
@@ -1619,7 +1620,7 @@ static int rkisp_isp_sd_s_power(struct v4l2_subdev *sd, int on)
 		 "%s on:%d\n", __func__, on);
 
 	if (on) {
-		if (isp_dev->isp_ver == ISP_V20)
+		if (isp_dev->isp_ver == ISP_V20 || isp_dev->isp_ver == ISP_V21)
 			kfifo_reset(&isp_dev->csi_dev.rdbk_kfifo);
 		ret = pm_runtime_get_sync(isp_dev->dev);
 	} else {
-- 
2.35.3

