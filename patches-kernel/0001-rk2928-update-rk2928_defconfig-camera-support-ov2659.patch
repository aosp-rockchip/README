From 46a7341368769edbaab9a241f8d504f8a3651702 Mon Sep 17 00:00:00 2001
From: kfx <kfx@rock-chips.com>
Date: Sat, 3 Nov 2012 15:28:56 +0800
Subject: [PATCH] rk2928: update rk2928_defconfig: camera: support: ov2659,
 gc0308, hi704

---
 arch/arm/configs/rk2928_defconfig             |   3 +
 arch/arm/mach-rk2928/board-phonepad.c         |  64 +++
 arch/arm/mach-rk2928/board-rk2928-camera.c    | 471 ++++++++++++++++++
 arch/arm/mach-rk2928/board-rk2928-config.c    | 111 +++++
 .../mach-rk2928/board-rk2928-sdk-act8931.c    |  27 +-
 arch/arm/mach-rk2928/board-rk2928-sdk-sdmmc.c |  33 +-
 .../mach-rk2928/board-rk2928-sdk-tps65910.c   |  26 +-
 arch/arm/mach-rk2928/board-rk2928.c           | 250 ++++------
 arch/arm/mach-rk2928/include/mach/config.h    | 179 ++++++-
 arch/arm/plat-rk/include/plat/rk_camera.h     |   2 +
 arch/arm/plat-rk/rk_camera.c                  |  43 ++
 drivers/input/touchscreen/i30_ts.c            |  10 +-
 drivers/input/touchscreen/sitronix_ts_a720.c  |   2 +-
 13 files changed, 1036 insertions(+), 185 deletions(-)
 create mode 100755 arch/arm/mach-rk2928/board-rk2928-camera.c

diff --git a/arch/arm/configs/rk2928_defconfig b/arch/arm/configs/rk2928_defconfig
index 9ac8ea5c6916..33390033ffd5 100644
--- a/arch/arm/configs/rk2928_defconfig
+++ b/arch/arm/configs/rk2928_defconfig
@@ -251,6 +251,7 @@ CONFIG_GS_MMA7660=y
 CONFIG_GS_MMA8452=y
 CONFIG_SENSOR_DEVICE=y
 CONFIG_GSENSOR_DEVICE=y
+CONFIG_GS_KXTIK=y
 CONFIG_LIGHT_DEVICE=y
 CONFIG_LS_AP321XX=y
 CONFIG_PROXIMITY_DEVICE=y
@@ -287,8 +288,10 @@ CONFIG_RK30_PWM_REGULATOR=y
 CONFIG_MEDIA_SUPPORT=y
 CONFIG_VIDEO_DEV=y
 CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_OV2659=y
 CONFIG_SOC_CAMERA_GC0308=y
 CONFIG_GC0308_USER_DEFINED_SERIES=y
+CONFIG_SOC_CAMERA_HI704=y
 CONFIG_VIDEO_RK29=y
 CONFIG_VIDEO_RK29_CAMMEM_ION=y
 CONFIG_ION=y
diff --git a/arch/arm/mach-rk2928/board-phonepad.c b/arch/arm/mach-rk2928/board-phonepad.c
index 96540a4fdf40..8d955364db5a 100644
--- a/arch/arm/mach-rk2928/board-phonepad.c
+++ b/arch/arm/mach-rk2928/board-phonepad.c
@@ -26,6 +26,9 @@ enum {
 enum {
         DEF_SPKCTL_IO = 0x000003d4,
 };
+enum {
+        DEF_RDA_I2C = 0,
+};
 /*************************************************************/
 
 /* Android Parameter */
@@ -69,6 +72,13 @@ int check_mdm_sound_param(void)
 {
         return 0;
 }
+/* rda5990 */
+static int rda_i2c = DEF_RDA_I2C;
+module_param(rda_i2c, int, 0644);
+int check_rda_param(void)
+{
+        return 0;
+}
 
 #if defined(CONFIG_SC6610)
 static int sc6610_io_init(void)
@@ -204,6 +214,59 @@ static int __init mdm_sound_board_init(void)
 }
 
 #endif
+#ifdef CONFIG_RDA5990
+#define RDA_WIFI_CORE_ADDR (0x13)
+#define RDA_WIFI_RF_ADDR (0x14) //correct add is 0x14
+#define RDA_BT_CORE_ADDR (0x15)
+#define RDA_BT_RF_ADDR (0x16)
+
+#define RDA_WIFI_RF_I2C_DEVNAME "rda_wifi_rf_i2c"
+#define RDA_WIFI_CORE_I2C_DEVNAME "rda_wifi_core_i2c"
+#define RDA_BT_RF_I2C_DEVNAME "rda_bt_rf_i2c"
+#define RDA_BT_CORE_I2C_DEVNAME "rda_bt_core_i2c"
+static struct i2c_board_info __initdata rda_info[] = {
+        {
+		.type          = RDA_WIFI_CORE_I2C_DEVNAME,
+		.addr          = RDA_WIFI_CORE_ADDR,
+	        .flags         = 0,
+
+	},
+	{
+		.type          = RDA_WIFI_RF_I2C_DEVNAME,
+		.addr          = RDA_WIFI_RF_ADDR,
+	        .flags         = 0,
+
+	},
+	{
+		.type          = RDA_BT_CORE_I2C_DEVNAME,
+		.addr          = RDA_BT_CORE_ADDR,
+	        .flags         = 0,
+
+	},
+	{
+		.type          = RDA_BT_RF_I2C_DEVNAME,
+		.addr          = RDA_BT_RF_ADDR,
+	        .flags         = 0,
+
+	},
+};
+static int __init rda_board_init(void)
+{
+        int ret;
+
+        ret = check_rda_param();
+
+        if(ret < 0)
+                return ret;
+        i2c_register_board_info(rda_i2c, rda_info, ARRAY_SIZE(rda_info));
+        return 0;
+}
+#else
+static int __init rda_board_init(void)
+{
+        return 0;
+}
+#endif
 
 
 static struct platform_device *phonepad_devices[] __initdata = {
@@ -222,6 +285,7 @@ static void __init phonepad_board_init(void)
         sc_board_init();
         hd_board_init();
         mdm_sound_board_init();
+        rda_board_init();
         platform_add_devices(phonepad_devices, ARRAY_SIZE(phonepad_devices));
 }
 
diff --git a/arch/arm/mach-rk2928/board-rk2928-camera.c b/arch/arm/mach-rk2928/board-rk2928-camera.c
new file mode 100755
index 000000000000..0ffe64dd0bbc
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-camera.c
@@ -0,0 +1,471 @@
+#include <mach/config.h>
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0                         BACK_SENSOR_0 /* back camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_0                BACK_SENSOR_0_ADDR
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0          0
+#define CONFIG_SENSOR_CIF_INDEX_0               0
+#define CONFIG_SENSOR_ORIENTATION_0             90
+#define CONFIG_SENSOR_POWER_PIN_0               INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0               INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0             INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_0               INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0       RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0       RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0     RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0       RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0       15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01                        BACK_SENSOR_1 /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	        BACK_SENSOR_1_ADDR
+#define CONFIG_SENSOR_CIF_INDEX_01              0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01         0
+#define CONFIG_SENSOR_ORIENTATION_01            90
+#define CONFIG_SENSOR_POWER_PIN_01              INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01              INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01            INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_01              INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01      RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01      RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01    RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01      RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01         15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01         15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01          15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01          15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01         15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01         15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01         30000
+
+#define CONFIG_SENSOR_02                        BACK_SENSOR_2 /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02               BACK_SENSOR_2_ADDR
+#define CONFIG_SENSOR_CIF_INDEX_02              0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02         0
+#define CONFIG_SENSOR_ORIENTATION_02            90
+#define CONFIG_SENSOR_POWER_PIN_02              INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02              INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02            INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_02              INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02      RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02      RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02    RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02      RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02         15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02         15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02          15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02          15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02         15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02         15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02         30000
+
+#define CONFIG_SENSOR_1                         FRONT_SENSOR_0 /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	        FRONT_SENSOR_0_ADDR
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	        0
+#define CONFIG_SENSOR_CIF_INDEX_1	        0
+#define CONFIG_SENSOR_ORIENTATION_1             270
+#define CONFIG_SENSOR_POWER_PIN_1               INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1               INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	        INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_1               INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1       RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1       RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1     RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1       RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1       15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11                        FRONT_SENSOR_1 /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	        FRONT_SENSOR_1_ADDR
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11         0
+#define CONFIG_SENSOR_CIF_INDEX_11	        0
+#define CONFIG_SENSOR_ORIENTATION_11            270
+#define CONFIG_SENSOR_POWER_PIN_11              INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11              INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11            INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_11              INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11      RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11      RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11    RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11      RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11         15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11         15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11          15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11          15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11         15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11         15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11         30000
+
+#define CONFIG_SENSOR_12                        FRONT_SENSOR_2 /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	        FRONT_SENSOR_2_ADDR
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12         0
+#define CONFIG_SENSOR_CIF_INDEX_12		0
+#define CONFIG_SENSOR_ORIENTATION_12            270
+#define CONFIG_SENSOR_POWER_PIN_12              INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12              INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12            INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_12              INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12      RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12      RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12    RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12      RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12         15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12         15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12          15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12          15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12         15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12         15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12         30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk2928_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   0 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+
+static void rk_cif_power(int on)
+{
+    struct regulator *ldo_18,*ldo_28;
+	ldo_28 = regulator_get(NULL, "ldo7");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "ldo1");	// vcc18_cif
+	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
+        printk("get cif ldo failed!\n");
+		return;
+	    }
+    if(on == 0){	
+    	regulator_disable(ldo_28);
+    	regulator_put(ldo_28);
+    	regulator_disable(ldo_18);
+    	regulator_put(ldo_18);
+    	mdelay(500);
+        }
+    else{
+    	regulator_set_voltage(ldo_28, 2800000, 2800000);
+    	regulator_enable(ldo_28);
+   // 	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
+    	regulator_put(ldo_28);
+
+    	regulator_set_voltage(ldo_18, 1800000, 1800000);
+    //	regulator_set_suspend_voltage(ldo, 1800000);
+    	regulator_enable(ldo_18);
+    //	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
+    	regulator_put(ldo_18);
+        }
+}
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+    rk_cif_power(on);
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+
+ };
+#include "../../../drivers/media/video/rk2928_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
+#ifdef CONFIG_RK_CONFIG
+static int __init cam_board_init(void)
+{
+        int ret = check_cam_param();
+
+        if(ret < 0)
+                return ret;
+                
+        camera_set_platform_param(back_cam_id,back_cam_i2c,get_port_config(back_cam_pwr).gpio);
+        camera_set_platform_param(front_cam_id,front_cam_i2c,get_port_config(front_cam_pwr).gpio);
+
+        return ret;
+}
+#else
+static int __init cam_board_init(void)
+{
+
+        return 0;
+}
+#endif
+
+
diff --git a/arch/arm/mach-rk2928/board-rk2928-config.c b/arch/arm/mach-rk2928/board-rk2928-config.c
index b16d609a8514..1e36aabd77ac 100644
--- a/arch/arm/mach-rk2928/board-rk2928-config.c
+++ b/arch/arm/mach-rk2928/board-rk2928-config.c
@@ -37,6 +37,35 @@ static struct pwm_io_config pwm_cfg[] = {
         },
 };
 
+#define TPS65910_HOST_IRQ INVALID_GPIO
+static struct pmu_info tps65910_dcdc_info[] = {
+        {.name = "vdd_cpu"},
+        {.name = "vdd2"},
+        {.name = "vdd3"},
+        {.name = "vio"},
+};
+static struct pmu_info tps65910_ldo_info[] = {
+        {.name = "vdig1"},
+        {.name = "vdig2"},
+        {.name = "vaux1"},
+        {.name = "vaux2"},
+        {.name = "vaux33"},
+        {.name = "vmmc"},
+        {.name = "vdac"},
+        {.name = "vpll"},
+};
+static struct pmu_info act8931_dcdc_info[] = {
+        {.name = "act_dcdc1"},
+        {.name = "act_dcdc2"},
+        {.name = "vdd_cpu"},
+};
+static struct pmu_info act8931_ldo_info[] = {
+        {.name = "act_ldo1"},
+        {.name = "act_ldo2"},
+        {.name = "act_ldo3"},
+        {.name = "act_ldo4"},
+};
+
 /*************************************** parameter ******************************************/
 /* keyboard */
 uint key_adc = DEF_KEY_ADC;
@@ -223,6 +252,25 @@ static inline int check_ps_param(void)
         }
         return 0;
 }
+/* camera */
+static int front_cam_i2c = DEF_FRONT_CAM_I2C;
+module_param(front_cam_i2c, int, 0644);
+static int front_cam_id = DEF_FRONT_CAM_ID;
+module_param(front_cam_id, uint, 0644);
+static int front_cam_pwr = DEF_FRONT_CAM_PWR;
+module_param(front_cam_pwr, int, 0644);
+
+static int back_cam_i2c = DEF_BACK_CAM_I2C;
+module_param(back_cam_i2c, int, 0644);
+static int back_cam_id = DEF_BACK_CAM_ID;
+module_param(back_cam_id, uint, 0644);
+static int back_cam_pwr = DEF_BACK_CAM_PWR;
+module_param(back_cam_pwr, int, 0644);
+
+static inline int check_cam_param(void)
+{
+        return 0;
+}
 
 /* pwm regulator */
 static int __sramdata reg_pwm = DEF_REG_PWM;
@@ -249,6 +297,16 @@ module_param(pmic_i2c, int, 0644);
 static int pmic_addr = DEF_PMIC_ADDR;
 module_param(pmic_addr, int, 0644);
 
+static int tps65910_dcdc[] = DEF_TPS65910_DCDC;
+module_param_array(tps65910_dcdc, int, NULL, 0644);
+static int tps65910_ldo[] = DEF_TPS65910_LDO;
+module_param_array(tps65910_ldo, int, NULL, 0644);
+
+static int act8931_dcdc[] = DEF_ACT8931_DCDC;
+module_param_array(act8931_dcdc, int, NULL, 0644);
+static int act8931_ldo[] = DEF_ACT8931_LDO;
+module_param_array(act8931_ldo, int, NULL, 0644);
+
 static inline int check_pmic_param(void)
 {
         if(pmic_type <= PMIC_TYPE_WM8326 || pmic_type >= PMIC_TYPE_MAX){
@@ -268,6 +326,54 @@ static inline int check_pmic_param(void)
 
         return 0;
 }
+int pmic_dcdc_set(int index, int on)
+{
+        struct regulator *dcdc = NULL;
+
+        if(index < 0)
+                return -EINVAL;
+
+        if(pmic_is_tps65910()) {
+                dcdc = regulator_get(NULL, tps65910_dcdc_info[index].name); 
+        }
+        if(pmic_is_act8931()) {
+                dcdc = regulator_get(NULL, act8931_dcdc_info[index].name); 
+        }
+        if(IS_ERR_OR_NULL(dcdc))
+                return -EINVAL;
+        if(on)
+                regulator_enable(dcdc);
+        else
+                regulator_disable(dcdc);
+        regulator_put(dcdc);
+        return 0;
+
+}
+EXPORT_SYNBOL(pmic_dcdc_set);
+int pmic_ldo_set(int index, int on)
+{
+        struct regulator *ldo = NULL;
+
+        if(index < 0)
+                return -EINVAL;
+
+        if(pmic_is_tps65910()) {
+                ldo = regulator_get(NULL, tps65910_ldo_info[index].name); 
+        }
+        if(pmic_is_act8931()) {
+                ldo = regulator_get(NULL, act8931_ldo_info[index].name); 
+        }
+        if(IS_ERR_OR_NULL(ldo))
+                return -EINVAL;
+        if(on)
+                regulator_enable(ldo);
+        else
+                regulator_disable(ldo);
+        regulator_put(ldo);
+        return 0;
+
+}
+EXPORT_SYNBOL(pmic_ldo_set);
 /* ion */
 static uint ion_size = DEF_ION_SIZE; 
 module_param(ion_size, uint, 0644);
@@ -299,6 +405,8 @@ static int wifi_pwr = DEF_WIFI_PWR;
 module_param(wifi_pwr, int, 0644);
 static uint wifi_type = DEF_WIFI_TYPE;
 module_param(wifi_type, uint, 0644);
+static int wifi_ldo = DEF_WIFI_LDO;
+module_param(wifi_ldo, int, 0644);
 static inline int check_wifi_param(void)
 {
         if(wifi_type != WIFI_NONE){
@@ -400,6 +508,8 @@ module_param_array(dvfs_ddr, uint, &dvfs_ddr_num, 0400);
 
 
 /* global */
+static int is_phonepad = DEF_IS_PHONEPAD;
+module_param(is_phonepad, int, 0644);
 static int pwr_on = DEF_PWR_ON;
 module_param(pwr_on, int, 0644);
 
@@ -412,3 +522,4 @@ static inline void rk2928_power_off(void)
         port_output_off(pwr_on);
         port_deinit(pwr_on);
 }
+
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c b/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
index c644cdda3a46..ce63eb569c01 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
@@ -29,21 +29,26 @@ static int act8931_set_init(struct act8931 *act8931)
 	
 	for(i = 0; i < ARRAY_SIZE(act8931_dcdc_info); i++)
 	{
-	dcdc =regulator_get(NULL, act8931_dcdc_info[i].name);
-	regulator_set_voltage(dcdc, act8931_dcdc_info[i].min_uv, act8931_dcdc_info[i].max_uv);
-	regulator_enable(dcdc);
-	printk("%s  %s =%dmV end\n", __func__,act8931_dcdc_info[i].name, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
+
+                if(act8931_dcdc_info[i].min_uv == 0 && act8931_dcdc_info[i].max_uv == 0)
+                        continue;
+	        dcdc =regulator_get(NULL, act8931_dcdc_info[i].name);
+	        regulator_set_voltage(dcdc, act8931_dcdc_info[i].min_uv, act8931_dcdc_info[i].max_uv);
+	        regulator_enable(dcdc);
+	        printk("%s  %s =%dmV end\n", __func__,act8931_dcdc_info[i].name, regulator_get_voltage(dcdc));
+	        regulator_put(dcdc);
+	        udelay(100);
 	}
 	
 	for(i = 0; i < ARRAY_SIZE(act8931_ldo_info); i++)
 	{
-	ldo =regulator_get(NULL, act8931_ldo_info[i].name);
-	regulator_set_voltage(ldo, act8931_ldo_info[i].min_uv, act8931_ldo_info[i].max_uv);
-	regulator_enable(ldo);
-	//printk("%s  %s =%dmV end\n", __func__,act8931_ldo_info[i].name, regulator_get_voltage(ldo));
-	regulator_put(ldo);
+                if(act8931_ldo_info[i].min_uv == 0 && act8931_ldo_info[i].max_uv == 0)
+                        continue;
+	        ldo =regulator_get(NULL, act8931_ldo_info[i].name);
+	        regulator_set_voltage(ldo, act8931_ldo_info[i].min_uv, act8931_ldo_info[i].max_uv);
+	        regulator_enable(ldo);
+	        printk("%s  %s =%dmV end\n", __func__,act8931_ldo_info[i].name, regulator_get_voltage(ldo));
+	        regulator_put(ldo);
 	}
 
 	printk("%s,line=%d END\n", __func__,__LINE__);
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-sdmmc.c b/arch/arm/mach-rk2928/board-rk2928-sdk-sdmmc.c
index aeac6fe3c112..7ee45973c698 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-sdmmc.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-sdmmc.c
@@ -71,11 +71,22 @@ static void rk29_sdmmc_gpio_open(int device_id, int on)
             #ifdef CONFIG_SDMMC1_RK29
             if(on)
             {
+                gpio_request(RK2928_PIN0_PB1, "mmc1-clk");
                 gpio_direction_output(RK2928_PIN0_PB1,GPIO_HIGH);//set mmc1-clk to high
+
+                gpio_request(RK2928_PIN0_PB0, "mmc1-cmd");
                 gpio_direction_output(RK2928_PIN0_PB0,GPIO_HIGH);//set mmc1-cmd to high.
+
+                gpio_request(RK2928_PIN0_PB3, "mmc1-data0");
                 gpio_direction_output(RK2928_PIN0_PB3,GPIO_HIGH);//set mmc1-data0 to high.
+
+				gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
                 gpio_direction_output(RK2928_PIN0_PB4,GPIO_HIGH);//set mmc1-data1 to high.
+
+				gpio_request(RK2928_PIN0_PB5, "mmc1-data2");
                 gpio_direction_output(RK2928_PIN0_PB5,GPIO_HIGH);//set mmc1-data2 to high.
+
+				gpio_request(RK2928_PIN0_PB6, "mmc1-data3");
                 gpio_direction_output(RK2928_PIN0_PB6,GPIO_HIGH);//set mmc1-data3 to high.
                 mdelay(100);
             }
@@ -93,6 +104,22 @@ static void rk29_sdmmc_gpio_open(int device_id, int on)
                 gpio_request(RK2928_PIN0_PB3, "mmc1-data0");
                 gpio_direction_output(RK2928_PIN0_PB3,GPIO_LOW);//set mmc1-data0 to low.
 
+				#if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
+				rk29_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_GPIO0B4);
+				gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
+				gpio_direction_output(RK2928_PIN0_PB4,GPIO_LOW);//set mmc1-data1 to low.
+
+				rk29_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_GPIO0B5);
+				gpio_request(RK2928_PIN0_PB5, "mmc1-data2");
+				gpio_direction_output(RK2928_PIN0_PB5,GPIO_LOW);//set mmc1-data2 to low.
+
+				rk29_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_GPIO0B6);
+				gpio_request(RK2928_PIN0_PB6, "mmc1-data3");
+				gpio_direction_output(RK2928_PIN0_PB6,GPIO_LOW);//set mmc1-data3 to low.
+
+				//rk29_sdmmc_gpio_open(1, 0); //added by xbw at 2011-10-13
+				#endif
+
                 mdelay(100);
             }
             #endif
@@ -349,7 +376,7 @@ static int __init rk29sdk_wifi_bt_gpio_control_init(void)
     gpio_direction_output(RK30SDK_WIFI_GPIO_RESET_N, !RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE);
 #endif    
 
-    #if defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
+    #if 0//defined(CONFIG_SDMMC1_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
     
     rk29_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_GPIO0B4);
     gpio_request(RK2928_PIN0_PB4, "mmc1-data1");
@@ -376,10 +403,10 @@ int rk29sdk_wifi_power(int on)
 {
         pr_info("%s: %d\n", __func__, on);
          if (on){
-                if(usbwifi_power_status == 1) {
+                /*if(usbwifi_power_status == 1) {
                     rkusb_wifi_power(0);
                     mdelay(50);
-                }
+                }*/
                 rkusb_wifi_power(1);
                 usbwifi_power_status = 1;
                  pr_info("wifi turn on power\n");  	
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
index e07bbe3e472c..495f013c9609 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
@@ -264,21 +264,25 @@ int tps65910_post_init(struct tps65910 *tps65910)
 
 	for(i = 0; i < ARRAY_SIZE(tps65910_dcdc_info); i++)
 	{
-	dcdc =regulator_get(NULL, tps65910_dcdc_info[i].name);
-	regulator_set_voltage(dcdc, tps65910_dcdc_info[i].min_uv, tps65910_dcdc_info[i].max_uv);
-	regulator_enable(dcdc);
-	printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
+                if(tps65910_dcdc_info[i].min_uv == 0 && tps65910_dcdc_info[i].max_uv == 0)
+                        continue;
+	        dcdc =regulator_get(NULL, tps65910_dcdc_info[i].name);
+	        regulator_set_voltage(dcdc, tps65910_dcdc_info[i].min_uv, tps65910_dcdc_info[i].max_uv);
+	        regulator_enable(dcdc);
+	        printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(dcdc));
+	        regulator_put(dcdc);
+	        udelay(100);
 	}
 	
 	for(i = 0; i < ARRAY_SIZE(tps65910_ldo_info); i++)
 	{
-	ldo =regulator_get(NULL, tps65910_ldo_info[i].name);
-	regulator_set_voltage(ldo, tps65910_ldo_info[i].min_uv, tps65910_ldo_info[i].max_uv);
-	regulator_enable(ldo);
-	//printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(ldo));
-	regulator_put(ldo);
+                if(tps65910_ldo_info[i].min_uv == 0 && tps65910_ldo_info[i].max_uv == 0)
+                        continue;
+	        ldo =regulator_get(NULL, tps65910_ldo_info[i].name);
+	        regulator_set_voltage(ldo, tps65910_ldo_info[i].min_uv, tps65910_ldo_info[i].max_uv);
+	        regulator_enable(ldo);
+	        printk("%s  %s =%dmV end\n", __func__,tps65910_ldo_info[i].name, regulator_get_voltage(ldo));
+	        regulator_put(ldo);
 	}
 
 	printk("%s,line=%d END\n", __func__,__LINE__);
diff --git a/arch/arm/mach-rk2928/board-rk2928.c b/arch/arm/mach-rk2928/board-rk2928.c
index 19134f74a0e4..af5a6dea927d 100755
--- a/arch/arm/mach-rk2928/board-rk2928.c
+++ b/arch/arm/mach-rk2928/board-rk2928.c
@@ -60,7 +60,7 @@
 #include "../../../drivers/spi/rk29_spim.h"
 #endif
 
-#include "board-rk2928-sdk-camera.c" 
+#include "board-rk2928-camera.c" 
 #include "board-rk2928-key.c"
 
 
@@ -119,7 +119,10 @@ static int rk29_backlight_pwm_suspend(void)
 
         rk30_mux_api_set(cfg->mux_name, cfg->io_mode);
 
-	gpio_direction_output(cfg->gpio, GPIO_HIGH);
+        if(bl_ref)
+	        gpio_direction_output(cfg->gpio, GPIO_LOW);
+        else
+	        gpio_direction_output(cfg->gpio, GPIO_HIGH);
 
         port_output_off(bl_en);
 
@@ -178,7 +181,7 @@ static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
 	int ret = 0;
 
         if(lcd_cabc != -1){
-                ret = port_output_init(lcd_en, 0, "lcd_cabc");
+                ret = port_output_init(lcd_cabc, 0, "lcd_cabc");
                 if(ret < 0)
                         printk("%s: port output init faild\n", __func__);
         }
@@ -394,31 +397,9 @@ static int __init pwm_reg_board_init(void)
 ************************************************************/
 #if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
 static void rkusb_wifi_power(int on) {
-	struct regulator *ldo = NULL;
-	
-#ifndef RK2926_TB_DEFAULT_CONFIG
-#if defined(CONFIG_MFD_TPS65910)	
-	if(pmic_is_tps65910()) {
-		ldo = regulator_get(NULL, "vmmc");  //vccio_wl
-	}
-#endif
-#if defined(CONFIG_REGULATOR_ACT8931)
-	if(pmic_is_act8931()) {
-		ldo = regulator_get(NULL, "act_ldo4");  //vccio_wl
-	}
-#endif	
-	
-	if(on) {
-		regulator_enable(ldo);
-		printk("%s: vccio_wl enable\n", __func__);
-	} else {
-		printk("%s: vccio_wl disable\n", __func__);
-		regulator_disable(ldo);
-	}
-	
-	regulator_put(ldo);
+
+        pmic_ldo_set(wifi_ldo, on);
 	udelay(100);
-#endif
 }
 #endif
 
@@ -526,6 +507,81 @@ static int __init sdmmc_board_init(void)
 }
 #endif
 
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+#if defined(CONFIG_SDMMC_RK29_OLD)
+	rk30_mux_api_set(GPIO0B0_MMC1_CMD_NAME, GPIO0B_MMC1_CMD);
+	rk30_mux_api_set(GPIO0B1_MMC1_CLKOUT_NAME, GPIO0B_MMC1_CLKOUT);
+	rk30_mux_api_set(GPIO0B3_MMC1_D0_NAME, GPIO0B_MMC1_D0);
+	rk30_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_MMC1_D1);
+	rk30_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_MMC1_D2);
+	rk30_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_MMC1_D3);
+	//rk30_mux_api_set(GPIO0B2_MMC1_DETN_NAME, GPIO0B_MMC1_DETN);
+
+#else
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
+	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
+#endif
+
+#endif
+
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34),
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
+		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#else
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#endif
+
+	.io_init = rk29_sdmmc1_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	.status = rk29sdk_wifi_status,
+	.register_status_notify = rk29sdk_wifi_status_register,
+#endif
+#if 1
+	.detect_irq = INVALID_GPIO,//RK29SDK_WIFI_SDIO_CARD_DETECT_N,
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+#else
+	.detect_irq = INVALID_GPIO,
+	.enable_sd_wakeup = 0,
+#endif
+
+};
+#endif //endif--#ifdef CONFIG_SDMMC1_RK29
+
 #ifdef CONFIG_SND_SOC_RK2928
 static struct resource resources_acodec[] = {
 	{
@@ -657,120 +713,7 @@ static struct platform_device *devices[] __initdata = {
 	&rk30_device_adc_battery,
 #endif
 };
-
 #if defined (CONFIG_MFD_TPS65910) && defined (CONFIG_REGULATOR_ACT8931)
-#define TPS65910_HOST_IRQ INVALID_GPIO
-
-static struct pmu_info  tps65910_dcdc_info[] = {
-	{
-		.name          = "vdd_cpu",   //arm
-		.min_uv          = 1200000,
-		.max_uv         = 1200000,
-	},
-	{
-		.name          = "vdd2",    //ddr
-		.min_uv          = 1200000,
-		.max_uv         = 1200000,
-	},
-	{
-		.name          = "vio",   //vcc_io
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-	
-};
-static  struct pmu_info  tps65910_ldo_info[] = {
-#if defined(RK2928_TB_DEFAULT_CONFIG) || defined(RK2926_TB_DEFAULT_CONFIG)
-	{
-		.name          = "vpll",   //vcc25
-		.min_uv          = 2500000,
-		.max_uv         = 2500000,
-	},
-	{
-		.name          = "vdig1",    //vcc18_cif
-		.min_uv          = 1800000,
-		.max_uv         = 1800000,
-	},
-	{
-		.name          = "vdac",   //vccio_wl
-		.min_uv          = 1800000,
-		.max_uv         = 1800000,
-	},
-#else
-	{
-		.name          = "vdig1",    //vcc18_cif
-		.min_uv          = 1500000,
-		.max_uv         = 1500000,
-	},
-
-	{
-		.name          = "vdig2",   //vdd11
-		.min_uv          = 1200000,
-		.max_uv         = 1200000,
-	},
-	{
-		.name          = "vaux1",   //vcc28_cif
-		.min_uv          = 2800000,
-		.max_uv         = 2800000,
-	},
-	{
-		.name          = "vaux2",   //vcca33
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-	{
-		.name          = "vaux33",   //vcc_tp
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-	{
-		.name          = "vmmc",   //
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-#endif
- };
-static struct pmu_info  act8931_dcdc_info[] = {
-	{
-		.name          = "act_dcdc1",   //vcc_io
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-	{
-		.name          = "act_dcdc2",    //ddr
-		.min_uv          = 1500000,
-		.max_uv         = 1500000,
-	},
-	{
-		.name          = "vdd_cpu",   //vdd_arm
-		.min_uv          = 1200000,
-		.max_uv         = 1200000,
-	},
-	
-};
-static  struct pmu_info  act8931_ldo_info[] = {
-	{
-		.name          = "act_ldo1",   //vcc28_cif
-		.min_uv          = 2800000,
-		.max_uv         = 2800000,
-	},
-	{
-		.name          = "act_ldo2",    //vcc18_cif
-		.min_uv          = 1800000,
-		.max_uv         = 1800000,
-	},
-	{
-		.name          = "act_ldo3",    //vcca30
-		.min_uv          = 3000000,
-		.max_uv         = 3000000,
-	},
-	{
-		.name          = "act_ldo4",    //vcc_wl
-		.min_uv          = 3300000,
-		.max_uv         = 3300000,
-	},
-};
-
 #include "board-rk2928-sdk-tps65910.c"
 #include "board-rk2928-sdk-act8931.c"
 static struct i2c_board_info __initdata pmic_info = {
@@ -778,7 +721,7 @@ static struct i2c_board_info __initdata pmic_info = {
 };
 static int __init pmic_board_init(void)
 {
-        int ret = 0;
+        int ret = 0, i;
         struct port_config port;
 
         ret = check_pmic_param();
@@ -793,10 +736,26 @@ static int __init pmic_board_init(void)
                 pmic_info.platform_data = &tps65910_data;
 
                 tps65910_data.irq = port.gpio;
+                for(i = 0; i < ARRAY_SIZE(tps65910_dcdc_info); i++){
+                        tps65910_dcdc_info[i].min_uv = tps65910_dcdc[2*i];
+                        tps65910_dcdc_info[i].max_uv = tps65910_dcdc[2*i + 1];
+                }
+                for(i = 0; i < ARRAY_SIZE(tps65910_ldo_info); i++){
+                        tps65910_ldo_info[i].min_uv = tps65910_ldo[2*i];
+                        tps65910_ldo_info[i].max_uv = tps65910_ldo[2*i + 1];
+                }
         }
         if(pmic_type == PMIC_TYPE_ACT8931){
                 strcpy(pmic_info.type, "act8931");
                 pmic_info.platform_data = &act8931_data;
+                for(i = 0; i < ARRAY_SIZE(act8931_dcdc_info); i++){
+                        act8931_dcdc_info[i].min_uv = act8931_dcdc[2*i];
+                        act8931_dcdc_info[i].max_uv = act8931_dcdc[2*i + 1];
+                }
+                for(i = 0; i < ARRAY_SIZE(act8931_ldo_info); i++){
+                        act8931_ldo_info[i].min_uv = act8931_ldo[2*i];
+                        act8931_ldo_info[i].max_uv = act8931_ldo[2*i + 1];
+                }
         }
         pmic_info.addr = pmic_addr;
 	i2c_register_board_info(pmic_i2c, &pmic_info, 1);
@@ -1128,6 +1087,9 @@ static int __init rk2928_config_init(void)
         if(ret < 0)
                 return ret;
         ret = ls_board_init();
+        if(ret < 0)
+                return ret;
+        ret = cam_board_init();
         if(ret < 0)
                 return ret;
         ret = ps_board_init();
@@ -1232,10 +1194,8 @@ static void __init rk2928_board_init(void)
 	rk30_i2c_register_board_info();
 	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
 	platform_add_devices(devices, ARRAY_SIZE(devices));
-#if defined(RK2928_PHONEPAD_DEFAULT_CONFIG)
-        phonepad_board_init();
-#endif
-
+        if(is_phonepad)
+                phonepad_board_init();
 }
 static void __init rk2928_reserve(void)
 {
diff --git a/arch/arm/mach-rk2928/include/mach/config.h b/arch/arm/mach-rk2928/include/mach/config.h
index cc698dfa93ea..587d754a0a1f 100644
--- a/arch/arm/mach-rk2928/include/mach/config.h
+++ b/arch/arm/mach-rk2928/include/mach/config.h
@@ -2,11 +2,36 @@
 #define __MACH_CONFIG_H
 #include <mach/board.h>
 
-#define RK2926_TB_DEFAULT_CONFIG
+//#define RK2926_TB_DEFAULT_CONFIG
 //#define RK2928_TB_DEFAULT_CONFIG
 //#define RK2926_SDK_DEFAULT_CONFIG
 //#define RK2928_SDK_DEFAULT_CONFIG
-//#define RK2928_PHONEPAD_DEFAULT_CONFIG
+#define RK2928_PHONEPAD_DEFAULT_CONFIG
+
+
+/* camera id */
+#define BACK_SENSOR_0           NONE
+#define BACK_SENSOR_0_ADDR      0x00
+#define BACK_SENSOR_1           NONE
+#define BACK_SENSOR_1_ADDR      0x00
+#define BACK_SENSOR_2           NONE
+#define BACK_SENSOR_2_ADDR      0x00
+
+#define FRONT_SENSOR_0          RK29_CAM_SENSOR_GC0308
+#define FRONT_SENSOR_0_ADDR     0x42
+#define FRONT_SENSOR_1          RK29_CAM_SENSOR_OV2659
+#define FRONT_SENSOR_1_ADDR     0x60
+#define FRONT_SENSOR_2          RK29_CAM_SENSOR_HI704
+#define FRONT_SENSOR_2_ADDR     0x60
+
+enum {
+        CAM_ID_BACK_SENSOR_0 = 0,
+        CAM_ID_BACK_SENSOR_1,
+        CAM_ID_BACK_SENSOR_2,
+        CAM_ID_FRONT_SENSOR_0,
+        CAM_ID_FRONT_SENSOR_1,
+        CAM_ID_FRONT_SENSOR_2,
+};
 
 enum { 
         GS_TYPE_NONE = 0,
@@ -35,6 +60,9 @@ enum {
         WIFI_SDIO_MAX,
 };
 
+int pmic_dcdc_set(int index, int on);
+int pmic_ldo_set(int index, int on);
+
 /****************************  rk2926 top board ******************************/
 #if defined(RK2926_TB_DEFAULT_CONFIG)
 /* keyboard */
@@ -92,13 +120,23 @@ enum {
 };
 /* psensor */
 enum {
-        DEF_PS_TYPE = LS_TYPE_NONE,
+        DEF_PS_TYPE = PS_TYPE_NONE,
         DEF_PS_I2C = -1,
         DEF_PS_ADDR = -1,
         DEF_PS_IRQ = -1,
         DEF_PS_PWR = -1,
 };
-
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = CAM_ID_FRONT_SENSOR_1,
+        DEF_FRONT_CAM_I2C = 0,
+        DEF_FRONT_CAM_PWR = 0x000003b3,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 /* pwm regulator */
 enum {
         DEF_REG_PWM = 1,
@@ -111,6 +149,16 @@ enum {
         DEF_PMIC_I2C = 1,
         DEF_PMIC_ADDR = 0x2d, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {1200000,1200000,1200000,1200000,0,0,3300000,3300000}
+#define DEF_TPS65910_LDO {1800000,1800000,0,0,0,0,0,0,0,0,0,0,1800000,1800000,2500000,2500000}
+#define DEF_ACT8931_DCDC {0,0,0,0,0,0}
+#define DEF_ACT8931_LDO {0,0,0,0,0,0,0,0}
+
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -129,6 +177,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = 5,
 };
 /* rtc */
 enum {
@@ -148,6 +197,7 @@ enum {
 
 /* global */
 enum {
+        DEF_IS_PHONEPAD = 0,
         DEF_PWR_ON = 0x000001a2,
 };
 /****************************  rk2928 top board ******************************/
@@ -207,13 +257,24 @@ enum {
 };
 /* psensor */
 enum {
-        DEF_PS_TYPE = LS_TYPE_NONE,
+        DEF_PS_TYPE = PS_TYPE_NONE,
         DEF_PS_I2C = -1,
         DEF_PS_ADDR = -1,
         DEF_PS_IRQ = -1,
         DEF_PS_PWR = -1,
 };
 
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = CAM_ID_FRONT_SENSOR_1,
+        DEF_FRONT_CAM_I2C = 0,
+        DEF_FRONT_CAM_PWR = 0x000003b3,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 
 /* pwm regulator */
 enum {
@@ -227,6 +288,15 @@ enum {
         DEF_PMIC_I2C = 1,
         DEF_PMIC_ADDR = 0x2d, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {1200000,1200000,1200000,1200000,0,0,3300000,3300000}
+#define DEF_TPS65910_LDO {1800000,1800000,0,0,0,0,0,0,0,0,0,0,1800000,1800000,2500000,2500000}
+#define DEF_ACT8931_DCDC {0,0,0,0,0,0}
+#define DEF_ACT8931_LDO {0,0,0,0,0,0,0,0}
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -245,6 +315,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = 5,
 };
 /* rtc */
 enum {
@@ -325,13 +396,24 @@ enum {
 };
 /* psensor */
 enum {
-        DEF_PS_TYPE = LS_TYPE_NONE,
+        DEF_PS_TYPE = PS_TYPE_NONE,
         DEF_PS_I2C = -1,
         DEF_PS_ADDR = -1,
         DEF_PS_IRQ = -1,
         DEF_PS_PWR = -1,
 };
 
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = CAM_ID_FRONT_SENSOR_0,
+        DEF_FRONT_CAM_I2C = 1,
+        DEF_FRONT_CAM_PWR = 0x000003b3,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 
 /* pwm regulator */
 enum {
@@ -345,6 +427,15 @@ enum {
         DEF_PMIC_I2C = 0,
         DEF_PMIC_ADDR = 0x5b, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {1200000,1200000,1200000,1200000,0,0,3300000,3300000}
+#define DEF_TPS65910_LDO {1500000,1500000,1200000,1200000,2800000,2800000,3300000,3300000,3300000,3300000,3300000,3300000,0,0,0,0}
+#define DEF_ACT8931_DCDC {3300000,3300000,1500000,1500000,1200000,1200000}
+#define DEF_ACT8931_LDO {2800000,2800000,1800000,1800000,3000000,3000000,3300000,3300000}
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -363,6 +454,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = 3,
 };
 /* rtc */
 enum {
@@ -382,6 +474,7 @@ enum {
 
 /* global */
 enum {
+        DEF_IS_PHONEPAD = 0,
         DEF_PWR_ON = 0x000001a2,
 };
 /****************************  rk2928 sdk ******************************/
@@ -441,13 +534,24 @@ enum {
 };
 /* psensor */
 enum {
-        DEF_PS_TYPE = LS_TYPE_NONE,
+        DEF_PS_TYPE = PS_TYPE_NONE,
         DEF_PS_I2C = -1,
         DEF_PS_ADDR = -1,
         DEF_PS_IRQ = -1,
         DEF_PS_PWR = -1,
 };
 
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = CAM_ID_FRONT_SENSOR_0,
+        DEF_FRONT_CAM_I2C = 1,
+        DEF_FRONT_CAM_PWR = 0x000003d7,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 
 /* pwm regulator */
 enum {
@@ -461,6 +565,15 @@ enum {
         DEF_PMIC_I2C = 0,
         DEF_PMIC_ADDR = 0x5b, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {1200000,1200000,1200000,1200000,0,0,3300000,3300000}
+#define DEF_TPS65910_LDO {1500000,1500000,1200000,1200000,2800000,2800000,3300000,3300000,3300000,3300000,3300000,3300000,0,0,0,0}
+#define DEF_ACT8931_DCDC {3300000,3300000,1500000,1500000,1200000,1200000}
+#define DEF_ACT8931_LDO {2800000,2800000,1800000,1800000,3000000,3000000,3300000,3300000}
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -479,6 +592,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = 3,
 };
 /* rtc */
 enum {
@@ -498,6 +612,7 @@ enum {
 
 /* global */
 enum {
+        DEF_IS_PHONEPAD = 0,
         DEF_PWR_ON = 0x000001a1,
 };
 /****************************  rk2928 phonepad ******************************/
@@ -516,7 +631,7 @@ enum{
 /* backlight */
 enum{
         DEF_BL_PWM = 0,
-        DEF_BL_REF = 0,
+        DEF_BL_REF = 1,
         DEF_BL_MIN = 80,
         DEF_BL_EN = 0x000001b0,
 };
@@ -564,6 +679,17 @@ enum {
         DEF_PS_PWR = -1,
 };
 
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = CAM_ID_FRONT_SENSOR_2,
+        DEF_FRONT_CAM_I2C = 1,
+        DEF_FRONT_CAM_PWR = 0x000003b3,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 
 /* pwm regulator */
 enum {
@@ -575,8 +701,17 @@ enum {
         DEF_PMIC_SLP = 0x000001a1,
         DEF_PMIC_IRQ = 0x000003c6,
         DEF_PMIC_I2C = 0,
-        DEF_PMIC_ADDR = 0x5b, 
+        DEF_PMIC_ADDR = 0x2d, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {1200000,1200000,1200000,1200000,0,0,3300000,3300000}
+#define DEF_TPS65910_LDO {1500000,1500000,1200000,1200000,2800000,2800000,3300000,3300000,3300000,3300000,3300000,3300000,0,0,0,0}
+#define DEF_ACT8931_DCDC {0,0,0,0,0,0}
+#define DEF_ACT8931_LDO {0,0,0,0,0,0,0,0}
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -595,6 +730,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = -1,
 };
 /* rtc */
 enum {
@@ -614,6 +750,7 @@ enum {
 
 /* global */
 enum {
+        DEF_IS_PHONEPAD = 1,
         DEF_PWR_ON = 0x000001a2,
 };
 
@@ -675,13 +812,24 @@ enum {
 };
 /* psensor */
 enum {
-        DEF_PS_TYPE = LS_TYPE_NONE,
+        DEF_PS_TYPE = PS_TYPE_NONE,
         DEF_PS_I2C = -1,
         DEF_PS_ADDR = -1,
         DEF_PS_IRQ = -1,
         DEF_PS_PWR = -1,
 };
 
+/* camera */
+enum {
+        DEF_FRONT_CAM_ID = -1,
+        DEF_FRONT_CAM_I2C = -1,
+        DEF_FRONT_CAM_PWR = -1,
+};
+enum {
+        DEF_BACK_CAM_ID = -1,
+        DEF_BACK_CAM_I2C = -1,
+        DEF_BACK_CAM_PWR = -1,
+};
 
 /* pwm regulator */
 enum {
@@ -695,6 +843,15 @@ enum {
         DEF_PMIC_I2C = -1,
         DEF_PMIC_ADDR = -1, 
 };
+/* tps656910_dcdc: vdd_cpu, vdd2, vdd3, vio 
+ * tps65910_ldo: vdig1, vdig2, vaux1, vaux2, vaux33, vmmc, vdac, vpll 
+ * act8931_dcdc: act_dcdc1, act_dcdc2, vdd_cpu
+ * act8931_ldo: act_ldo1, act_ldo2, act_ldo3, act_ldo4
+ */
+#define DEF_TPS65910_DCDC {0,0,0,0,0,0,0,0}
+#define DEF_TPS65910_LDO {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
+#define DEF_ACT8931_DCDC {0,0,0,0,0,0}
+#define DEF_ACT8931_LDO {0,0,0,0,0,0,0,0}
 /* ion */
 enum {
         DEF_ION_SIZE = 80 * 1024 * 1024,
@@ -713,6 +870,7 @@ enum {
         DEF_WIFI_RST = -1,
         DEF_WIFI_PWR = -1,
         DEF_WIFI_TYPE = WIFI_NONE, 
+        DEF_WIFI_LDO = -1,
 };
 /* rtc */
 enum {
@@ -732,6 +890,7 @@ enum {
 
 /* global */
 enum {
+        DEF_IS_PHONEPAD = 0,
         DEF_PWR_ON = -1,
 };
 #endif
diff --git a/arch/arm/plat-rk/include/plat/rk_camera.h b/arch/arm/plat-rk/include/plat/rk_camera.h
index b658e238149e..42f363983715 100755
--- a/arch/arm/plat-rk/include/plat/rk_camera.h
+++ b/arch/arm/plat-rk/include/plat/rk_camera.h
@@ -284,5 +284,7 @@ typedef struct rk29_camera_sensor_cb {
     int (*sensor_cb)(void *arg); 
     int (*scale_crop_cb)(struct work_struct *work);
 }rk29_camera_sensor_cb_s;
+
+int camera_set_platform_param(int id, int i2c, int gpio);
 #endif /* __ASM_ARCH_CAMERA_H_ */
 
diff --git a/arch/arm/plat-rk/rk_camera.c b/arch/arm/plat-rk/rk_camera.c
index 18f6556189d0..1a73ad4d48e5 100755
--- a/arch/arm/plat-rk/rk_camera.c
+++ b/arch/arm/plat-rk/rk_camera.c
@@ -1317,6 +1317,49 @@ static struct platform_device android_pmem_cam_device = {
 	},
 };
 #endif
+#ifdef CONFIG_RK_CONFIG
+int camera_set_platform_param(int id, int i2c, int gpio)
+{
+        int i;
+        char *dev_name[] = {
+                SENSOR_DEVICE_NAME_0, 
+                SENSOR_DEVICE_NAME_01, 
+                SENSOR_DEVICE_NAME_02, 
+                SENSOR_DEVICE_NAME_1, 
+                SENSOR_DEVICE_NAME_11, 
+                SENSOR_DEVICE_NAME_12
+        };
+        char *module_name[] = {
+                SENSOR_NAME_0,
+                SENSOR_NAME_01,
+                SENSOR_NAME_02,
+                SENSOR_NAME_1,
+                SENSOR_NAME_11,
+                SENSOR_NAME_12
+        };
+
+        if(id < 0 || id >= 6)
+                return -EINVAL;
+        for(i = 0; i < 6; i++){
+                if(i == id){
+                        printk("%s: id = %d, i2c = %d, gpio = %d\n", __func__, id, i2c, gpio);
+                }
+                if(rk_camera_platform_data.gpio_res[i].dev_name &&
+                   strcmp(rk_camera_platform_data.gpio_res[i].dev_name, dev_name[id]) == 0)
+                        rk_camera_platform_data.gpio_res[i].gpio_powerdown = gpio;
+                if(rk_camera_platform_data.register_dev[i].link_info.module_name &&
+                   strcmp(rk_camera_platform_data.register_dev[i].link_info.module_name, module_name[id]) == 0)
+                        rk_camera_platform_data.register_dev[i].link_info.i2c_adapter_id = i2c;
+        }
+
+        return 0;
+}
+#else
+int camera_set_platform_param(int id, int i2c, int gpio)
+{
+        return 0;
+}
+#endif
 
 #endif
 
diff --git a/drivers/input/touchscreen/i30_ts.c b/drivers/input/touchscreen/i30_ts.c
index 82652144fe30..3d1a18cc7d48 100755
--- a/drivers/input/touchscreen/i30_ts.c
+++ b/drivers/input/touchscreen/i30_ts.c
@@ -105,6 +105,7 @@ enum {
         DEF_ADDR = 0x38,
         DEF_X_MAX = 800,
         DEF_Y_MAX = 480,
+        DEF_TP_LDO = 4,
 };
 static int en = DEF_EN;
 module_param(en, int, 0644);
@@ -122,13 +123,15 @@ static int x_max = DEF_X_MAX;
 module_param(x_max, int, 0644);
 static int y_max = DEF_Y_MAX;
 module_param(y_max, int, 0644);
+static int tp_ldo = DEF_TP_LDO;
+module_param(tp_ldo, int, 0644);
 
 static int tp_hw_init(void)
 {
         int ret = 0;
-        struct regulator *ldo = regulator_get(NULL, "vaux33");
 
-	regulator_disable(ldo);
+        pmic_ldo_set(tp_ldo, 0);
+
         ret = gpio_request(get_port_config(irq).gpio, "tp_irq");
         if(ret < 0){
                 printk("%s: gpio_request(irq gpio) failed\n", __func__);
@@ -141,8 +144,7 @@ static int tp_hw_init(void)
                 return ret;
         }
         msleep(50);
-        regulator_enable(ldo);
-	regulator_put(ldo);
+        pmic_ldo_set(tp_ldo, 1);
         msleep(300);
 
          return 0;
diff --git a/drivers/input/touchscreen/sitronix_ts_a720.c b/drivers/input/touchscreen/sitronix_ts_a720.c
index f4e4a7a9f0c3..e79be5338493 100755
--- a/drivers/input/touchscreen/sitronix_ts_a720.c
+++ b/drivers/input/touchscreen/sitronix_ts_a720.c
@@ -1255,7 +1255,7 @@ static struct file_operations nc_fops = {
 };
 #endif // SITRONIX_FW_UPGRADE_FEATURE
 
-static int __devinit sitronix_ts_init(void)
+static int __init sitronix_ts_init(void)
 {
 #ifdef SITRONIX_FW_UPGRADE_FEATURE
 	int result;
-- 
2.35.3

