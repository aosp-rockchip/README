From db009dd476c510102d9a7354216382dcfd3cbb08 Mon Sep 17 00:00:00 2001
From: xxx <xxx@rock-chips.com>
Date: Wed, 5 Sep 2012 19:18:35 -0700
Subject: [PATCH] correct bugs for 'cpu hclk and pclk is 1:1'

---
 arch/arm/configs/rk3066b_m701_defconfig       |  436 -----
 arch/arm/mach-rk29/include/mach/rk29_camera.h |    2 +-
 arch/arm/mach-rk2928/board-rk2928-a720.c      |   13 -
 .../mach-rk2928/board-rk2928-sdk-act8931.c    |  297 ---
 arch/arm/mach-rk30/Kconfig                    |    2 -
 arch/arm/mach-rk30/Makefile                   |    1 -
 arch/arm/mach-rk30/board-rk3066b-m701-key.c   |   66 -
 arch/arm/mach-rk30/board-rk3066b-m701.c       | 1628 -----------------
 .../mach-rk30/board-rk3066b-sdk-tps65910.c    |    4 +-
 arch/arm/mach-rk30/board-rk3066b-sdk.c        |    1 -
 arch/arm/mach-rk30/clock_data.c               |    3 +
 arch/arm/mach-rk30/devices.c                  |   20 +-
 arch/arm/mach-rk30/include/mach/rk30_camera.h |    5 +-
 arch/arm/plat-rk/include/plat/board.h         |    7 -
 arch/arm/plat-rk/include/plat/rk_camera.h     |    4 -
 arch/arm/plat-rk/rk_camera.c                  |   20 -
 drivers/media/video/rk30_camera_oneframe.c    |  104 +-
 drivers/media/video/soc_camera.c              |    2 +-
 drivers/mfd/rk610-core.c                      |   21 +-
 drivers/regulator/Kconfig                     |    6 -
 drivers/regulator/Makefile                    |    1 -
 drivers/regulator/act8931.c                   |  637 -------
 drivers/usb/dwc_otg/dwc_otg_cil.c             |    2 +
 drivers/usb/dwc_otg/dwc_otg_cil.h             |    5 +-
 drivers/usb/dwc_otg/dwc_otg_driver.c          |   70 +-
 drivers/usb/dwc_otg/dwc_otg_hcd.c             |   12 +-
 drivers/usb/dwc_otg/dwc_otg_pcd.c             |   28 +-
 drivers/usb/dwc_otg/usbdev_rk30.c             |   16 +-
 include/linux/regulator/act8931.h             |   79 -
 29 files changed, 128 insertions(+), 3364 deletions(-)
 delete mode 100644 arch/arm/configs/rk3066b_m701_defconfig
 delete mode 100755 arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
 delete mode 100644 arch/arm/mach-rk30/board-rk3066b-m701-key.c
 delete mode 100644 arch/arm/mach-rk30/board-rk3066b-m701.c
 mode change 100644 => 100755 arch/arm/mach-rk30/clock_data.c
 delete mode 100755 drivers/regulator/act8931.c
 delete mode 100755 include/linux/regulator/act8931.h

diff --git a/arch/arm/configs/rk3066b_m701_defconfig b/arch/arm/configs/rk3066b_m701_defconfig
deleted file mode 100644
index 439d6e724e13..000000000000
--- a/arch/arm/configs/rk3066b_m701_defconfig
+++ /dev/null
@@ -1,436 +0,0 @@
-CONFIG_EXPERIMENTAL=y
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_KERNEL_LZO=y
-CONFIG_LOG_BUF_SHIFT=19
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_PANIC_TIMEOUT=1
-# CONFIG_SYSCTL_SYSCALL is not set
-# CONFIG_ELF_CORE is not set
-CONFIG_ASHMEM=y
-# CONFIG_AIO is not set
-CONFIG_EMBEDDED=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_ARCH_RK30=y
-# CONFIG_DDR_TEST is not set
-CONFIG_ARCH_RK3066B=y
-CONFIG_MACH_RK3066B_M701=y
-CONFIG_FIQ_DEBUGGER=y
-CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
-CONFIG_FIQ_DEBUGGER_CONSOLE=y
-CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SMP=y
-# CONFIG_SMP_ON_UP is not set
-CONFIG_NR_CPUS=2
-CONFIG_PREEMPT=y
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_HIGHMEM=y
-CONFIG_COMPACTION=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
-CONFIG_CPU_IDLE=y
-CONFIG_VFP=y
-CONFIG_NEON=y
-CONFIG_WAKELOCK=y
-CONFIG_PM_RUNTIME=y
-CONFIG_PM_DEBUG=y
-CONFIG_SUSPEND_TIME=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_XFRM_USER=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_INET_ESP=y
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_NETFILTER=y
-# CONFIG_BRIDGE_NETFILTER is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CONNTRACK_EVENTS=y
-CONFIG_NF_CT_PROTO_DCCP=y
-CONFIG_NF_CT_PROTO_SCTP=y
-CONFIG_NF_CT_PROTO_UDPLITE=y
-CONFIG_NF_CONNTRACK_AMANDA=y
-CONFIG_NF_CONNTRACK_FTP=y
-CONFIG_NF_CONNTRACK_H323=y
-CONFIG_NF_CONNTRACK_IRC=y
-CONFIG_NF_CONNTRACK_NETBIOS_NS=y
-CONFIG_NF_CONNTRACK_PPTP=y
-CONFIG_NF_CONNTRACK_SANE=y
-CONFIG_NF_CONNTRACK_SIP=y
-CONFIG_NF_CONNTRACK_TFTP=y
-CONFIG_NF_CT_NETLINK=y
-CONFIG_NETFILTER_TPROXY=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
-CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_TPROXY=y
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_POLICY=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
-CONFIG_NETFILTER_XT_MATCH_SOCKET=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP_NF_TARGET_LOG=y
-CONFIG_NF_NAT=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_MANGLE=y
-CONFIG_IP_NF_RAW=y
-CONFIG_IP_NF_ARPTABLES=y
-CONFIG_IP_NF_ARPFILTER=y
-CONFIG_IP_NF_ARP_MANGLE=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_BRIDGE=y
-# CONFIG_BRIDGE_IGMP_SNOOPING is not set
-CONFIG_PHONET=y
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_HTB=y
-CONFIG_NET_SCH_INGRESS=y
-CONFIG_NET_CLS_U32=y
-CONFIG_NET_EMATCH=y
-CONFIG_NET_EMATCH_U32=y
-CONFIG_NET_CLS_ACT=y
-CONFIG_NET_ACT_POLICE=y
-CONFIG_NET_ACT_GACT=y
-CONFIG_NET_ACT_MIRRED=y
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-CONFIG_BT_HIDP=y
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-CONFIG_BT_HCIUART_LL=y
-CONFIG_BT_HCIBCM4325=y
-CONFIG_BT_AUTOSLEEP=y
-CONFIG_RFKILL=y
-CONFIG_RFKILL_RK=y
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_NAND_IDS=y
-CONFIG_MTD_RKNAND=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_MISC_DEVICES=y
-CONFIG_UID_STAT=y
-CONFIG_APANIC=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_CRYPT=y
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_PHYLIB=y
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-CONFIG_WLAN_80211=y
-CONFIG_RKWIFI=y
-CONFIG_USB_USBNET=y
-CONFIG_PPP=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_SYNC_TTY=y
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-CONFIG_INPUT_KEYRESET=y
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_JOYSTICK=y
-CONFIG_JOYSTICK_XPAD=y
-CONFIG_JOYSTICK_XPAD_FF=y
-CONFIG_JOYSTICK_XPAD_LEDS=y
-CONFIG_INPUT_TABLET=y
-CONFIG_TABLET_USB_ACECAD=y
-CONFIG_TABLET_USB_AIPTEK=y
-CONFIG_TABLET_USB_GTCO=y
-CONFIG_TABLET_USB_HANWANG=y
-CONFIG_TABLET_USB_KBTAB=y
-CONFIG_TABLET_USB_WACOM=y
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_FT5306=y
-CONFIG_INPUT_MISC=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_UINPUT=y
-CONFIG_COMPASS_AK8975=y
-CONFIG_GS_MMA8452=y
-CONFIG_GS_LIS3DH=y
-CONFIG_GYRO_L3G4200D=y
-CONFIG_LS_CM3217=y
-CONFIG_SENSOR_DEVICE=y
-CONFIG_GSENSOR_DEVICE=y
-CONFIG_GS_KXTIK=y
-CONFIG_COMPASS_DEVICE=y
-CONFIG_GYROSCOPE_DEVICE=y
-CONFIG_LIGHT_DEVICE=y
-CONFIG_LS_AL3006=y
-CONFIG_LS_STK3171=y
-CONFIG_PROXIMITY_DEVICE=y
-CONFIG_PS_AL3006=y
-CONFIG_PS_STK3171=y
-# CONFIG_SERIO is not set
-# CONFIG_CONSOLE_TRANSLATIONS is not set
-# CONFIG_LEGACY_PTYS is not set
-CONFIG_SERIAL_RK29=y
-CONFIG_UART0_RK29=y
-CONFIG_UART0_CTS_RTS_RK29=y
-CONFIG_UART3_RK29=y
-CONFIG_UART3_CTS_RTS_RK29=y
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-# CONFIG_I2C_COMPAT is not set
-CONFIG_I2C0_CONTROLLER_RK30=y
-CONFIG_I2C1_CONTROLLER_RK30=y
-CONFIG_I2C2_CONTROLLER_RK30=y
-CONFIG_I2C3_CONTROLLER_RK30=y
-CONFIG_I2C4_CONTROLLER_RK30=y
-CONFIG_GPIO_WM831X=y
-CONFIG_EXPANDED_GPIO_NUM=0
-CONFIG_EXPANDED_GPIO_IRQ_NUM=0
-CONFIG_SPI_FPGA_GPIO_NUM=0
-CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
-CONFIG_POWER_SUPPLY=y
-CONFIG_TEST_POWER=y
-# CONFIG_HWMON is not set
-CONFIG_MFD_TPS65910=y
-CONFIG_MFD_WM831X_I2C=y
-CONFIG_MFD_TPS65090=y
-CONFIG_MFD_RK610=y
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_TPS65910=y
-CONFIG_REGULATOR_WM831X=y
-CONFIG_RK30_PWM_REGULATOR=y
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-CONFIG_SOC_CAMERA=y
-CONFIG_SOC_CAMERA_OV2659=y
-CONFIG_SOC_CAMERA_OV5642=y
-CONFIG_VIDEO_RK29=y
-CONFIG_VIDEO_RK29_CAMMEM_ION=y
-CONFIG_ION=y
-CONFIG_ION_ROCKCHIP=y
-CONFIG_FB=y
-CONFIG_BACKLIGHT_LCD_SUPPORT=y
-# CONFIG_LCD_CLASS_DEVICE is not set
-CONFIG_BACKLIGHT_CLASS_DEVICE=y
-# CONFIG_BACKLIGHT_GENERIC is not set
-CONFIG_DISPLAY_SUPPORT=y
-CONFIG_LCD_B101EW05=y
-CONFIG_FB_ROCKCHIP=y
-CONFIG_LCDC_RK31=y
-CONFIG_LCDC1_RK31=y
-CONFIG_RGA_RK30=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=y
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_VERBOSE_PROCFS is not set
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_ARM is not set
-CONFIG_SND_SOC=y
-CONFIG_SND_RK29_SOC=y
-CONFIG_SND_RK29_SOC_I2S_2CH=y
-CONFIG_SND_I2S_DMA_EVENT_STATIC=y
-CONFIG_SND_RK29_SOC_RK610=y
-CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_ACRUX=y
-CONFIG_HID_ACRUX_FF=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_DRAGONRISE=y
-CONFIG_DRAGONRISE_FF=y
-CONFIG_HID_EMS_FF=y
-CONFIG_HID_ELECOM=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_KEYTOUCH=y
-CONFIG_HID_KYE=y
-CONFIG_HID_UCLOGIC=y
-CONFIG_HID_WALTOP=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_TWINHAN=y
-CONFIG_HID_KENSINGTON=y
-CONFIG_HID_LCPOWER=y
-CONFIG_HID_LOGITECH=y
-CONFIG_LOGITECH_FF=y
-CONFIG_LOGIRUMBLEPAD2_FF=y
-CONFIG_LOGIG940_FF=y
-CONFIG_LOGIWII_FF=y
-CONFIG_HID_MAGICMOUSE=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_MULTITOUCH=y
-CONFIG_HID_NTRIG=y
-CONFIG_HID_ORTEK=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_PANTHERLORD_FF=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_PICOLCD=y
-CONFIG_HID_QUANTA=y
-CONFIG_HID_ROCCAT_ARVO=y
-CONFIG_HID_ROCCAT_KONE=y
-CONFIG_HID_ROCCAT_KONEPLUS=y
-CONFIG_HID_ROCCAT_KOVAPLUS=y
-CONFIG_HID_ROCCAT_PYRA=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_HID_GREENASIA=y
-CONFIG_GREENASIA_FF=y
-CONFIG_HID_SMARTJOYPLUS=y
-CONFIG_SMARTJOYPLUS_FF=y
-CONFIG_HID_TOPSEED=y
-CONFIG_HID_THRUSTMASTER=y
-CONFIG_THRUSTMASTER_FF=y
-CONFIG_HID_WACOM=y
-CONFIG_HID_ZEROPLUS=y
-CONFIG_ZEROPLUS_FF=y
-CONFIG_HID_ZYDACRON=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_DEVICEFS=y
-CONFIG_USB_OTG_BLACKLIST_HUB=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_SERIAL=y
-CONFIG_USB_SERIAL_GENERIC=y
-CONFIG_USB_SERIAL_OPTION=y
-CONFIG_USB_GADGET=y
-CONFIG_USB20_HOST=y
-CONFIG_USB20_OTG=y
-CONFIG_MMC=y
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-CONFIG_SDMMC_RK29=y
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_LEDS_GPIO=y
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_WM831X=y
-CONFIG_TPS65910_RTC=y
-CONFIG_STAGING=y
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_TIMED_GPIO=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_CMMB is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_FS_XATTR is not set
-CONFIG_EXT4_FS=y
-# CONFIG_EXT4_FS_XATTR is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_FUSE_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_EFI_PARTITION=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_PRINTK_TIME=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_SCHEDSTATS=y
-CONFIG_SLUB_DEBUG_ON=y
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/mach-rk29/include/mach/rk29_camera.h b/arch/arm/mach-rk29/include/mach/rk29_camera.h
index 9397ac5de299..1e4fc5fad006 100755
--- a/arch/arm/mach-rk29/include/mach/rk29_camera.h
+++ b/arch/arm/mach-rk29/include/mach/rk29_camera.h
@@ -21,7 +21,7 @@
 #ifndef __ASM_ARCH_CAMERA_RK29_H_
 
 #define __ASM_ARCH_CAMERA_RK29_H_
-#define RK29_CAM_DRV_NAME "rk29-camera"
+#define RK29_CAM_DRV_NAME "rk-camera-rk29"
 
 #include <plat/rk_camera.h>
 
diff --git a/arch/arm/mach-rk2928/board-rk2928-a720.c b/arch/arm/mach-rk2928/board-rk2928-a720.c
index 4399b569b848..4ab211558542 100755
--- a/arch/arm/mach-rk2928/board-rk2928-a720.c
+++ b/arch/arm/mach-rk2928/board-rk2928-a720.c
@@ -512,10 +512,6 @@ static struct platform_device *devices[] __initdata = {
 #define TPS65910_HOST_IRQ        RK2928_PIN1_PB2
 #include "board-rk2928-a720-tps65910.c"
 #endif
-#ifdef CONFIG_REGULATOR_ACT8931
-#include "board-rk2928-sdk-act8931.c"
-#endif
-
 static struct i2c_board_info __initdata i2c0_info[] = {
 #if defined (CONFIG_MFD_TPS65910)
 	{
@@ -526,15 +522,6 @@ static struct i2c_board_info __initdata i2c0_info[] = {
     	.platform_data = &tps65910_data,
 	},
 #endif
-#if defined (CONFIG_REGULATOR_ACT8931)
-	{
-		.type    		= "act8931",
-		.addr           = 0x5b, 
-		.flags			= 0,
-		.platform_data=&act8931_data,
-	},
-#endif
-
 };
 #endif
 #ifdef CONFIG_I2C1_RK30
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c b/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
deleted file mode 100755
index 9eec5f9eb930..000000000000
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
+++ /dev/null
@@ -1,297 +0,0 @@
-#include <linux/regulator/machine.h>
-#include <linux/regulator/act8931.h>
-#include <mach/sram.h>
-#include <linux/platform_device.h>
-
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-
-#define gpio_readl(offset)	readl_relaxed(RK2928_GPIO3_BASE + offset)
-#define gpio_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO3_BASE + offset); dsb(); } while (0)
-
-#define GPIO_SWPORTA_DR  0x0000
-#define GPIO_SWPORTA_DDR 0x0004
-
-#define GPIO3_D2_OUTPUT  (1<<26)
-#define GPIO3_D2_OUTPUT_HIGH  (1<<26)
-#define GPIO3_D2_OUTPUT_LOW  (~(1<<26))
-
-#ifdef CONFIG_REGULATOR_ACT8931
-#define PMU_POWER_SLEEP RK2928_PIN3_PD2	
-extern int platform_device_register(struct platform_device *pdev);
-
-int act8931_pre_init(struct act8931 *act8931){
-
-	int val = 0;
-	int i 	= 0;
-	int err = -1;
-		
-	printk("%s,line=%d\n", __func__,__LINE__);	
-	
-
-}
-int act8931_set_init(struct act8931 *act8931)
-{
-	struct regulator *dcdc;
-	struct regulator *ldo;
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-	#ifdef CONFIG_RK30_PWM_REGULATOR
-	platform_device_register(&pwm_regulator_device[0]);
-	#endif
-	
-	ldo = regulator_get(NULL, "act_ldo1");	//vcc28_cif
-	regulator_set_voltage(ldo, 2800000, 2800000);
-	regulator_enable(ldo);
-	printk("%s set ldo1 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "act_ldo2");	// vcc18_cif
-	regulator_set_voltage(ldo, 1800000, 1800000);
-	regulator_enable(ldo);
-	printk("%s set ldo2 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "act_ldo3");	// vcca_30
-	regulator_set_voltage(ldo, 3000000, 3000000);
-	regulator_enable(ldo);
-	printk("%s set ldo3 vcca_30=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-
-	ldo = regulator_get(NULL, "act_ldo4");	 //vcc_lcd
-	regulator_set_voltage(ldo, 3300000, 3300000);
-	regulator_enable(ldo);
-	printk("%s set ldo4 vcc_lcd=%dmV end\n", __func__, regulator_get_voltage(ldo));
-	regulator_put(ldo);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "act_dcdc1");	//vcc_io
-	regulator_set_voltage(dcdc, 3000000, 3000000);
-	regulator_enable(dcdc);
-	printk("%s set dcdc1 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "act_dcdc2");	//vcc_ddr 
-	regulator_set_voltage(dcdc, 1500000, 1500000);	// 1.5*4/5 = 1.2 and Vout=1.5v
-	regulator_enable(dcdc);
-	printk("%s set dcdc2 vcc_ddr=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-	
-	dcdc = regulator_get(NULL, "vdd_cpu");	//vdd_arm
-	regulator_set_voltage(dcdc, 1200000, 1200000);
-	regulator_enable(dcdc);
-	printk("%s set dcdc3 vdd_arm=%dmV end\n", __func__, regulator_get_voltage(dcdc));
-	regulator_put(dcdc);
-	udelay(100);
-	
-
-	printk("%s,line=%d END\n", __func__,__LINE__);
-	
-	return 0;
-}
-
-static struct regulator_consumer_supply act8931_buck1_supply[] = {
-	{
-		.supply = "act_dcdc1",
-	},
-
-};
-static struct regulator_consumer_supply act8931_buck2_supply[] = {
-	{
-		.supply = "act_dcdc2",
-	},
-	
-};
-static struct regulator_consumer_supply act8931_buck3_supply[] = {
-	{
-		.supply = "act_dcdc3",
-	},
-	{
-		.supply = "vdd_cpu",
-	},
-};
-
-static struct regulator_consumer_supply act8931_ldo1_supply[] = {
-	{
-		.supply = "act_ldo1",
-	},
-};
-static struct regulator_consumer_supply act8931_ldo2_supply[] = {
-	{
-		.supply = "act_ldo2",
-	},
-};
-
-static struct regulator_consumer_supply act8931_ldo3_supply[] = {
-	{
-		.supply = "act_ldo3",
-	},
-};
-static struct regulator_consumer_supply act8931_ldo4_supply[] = {
-	{
-		.supply = "act_ldo4",
-	},
-};
-
-static struct regulator_init_data act8931_buck1 = {
-	.constraints = {
-		.name           = "ACT_DCDC1",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_buck1_supply),
-	.consumer_supplies =  act8931_buck1_supply,
-};
-
-/* */
-static struct regulator_init_data act8931_buck2 = {
-	.constraints = {
-		.name           = "ACT_DCDC2",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_buck2_supply),
-	.consumer_supplies =  act8931_buck2_supply,
-};
-
-/* */
-static struct regulator_init_data act8931_buck3 = {
-	.constraints = {
-		.name           = "ACT_DCDC3",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		.always_on = 1,
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_buck3_supply),
-	.consumer_supplies =  act8931_buck3_supply,
-};
-
-static struct regulator_init_data act8931_ldo1 = {
-	.constraints = {
-		.name           = "ACT_LDO1",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_ldo1_supply),
-	.consumer_supplies =  act8931_ldo1_supply,
-};
-
-/* */
-static struct regulator_init_data act8931_ldo2 = {
-	.constraints = {
-		.name           = "ACT_LDO2",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_ldo2_supply),
-	.consumer_supplies =  act8931_ldo2_supply,
-};
-
-/* */
-static struct regulator_init_data act8931_ldo3 = {
-	.constraints = {
-		.name           = "ACT_LDO3",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_ldo3_supply),
-	.consumer_supplies =  act8931_ldo3_supply,
-};
-
-/* */
-static struct regulator_init_data act8931_ldo4 = {
-	.constraints = {
-		.name           = "ACT_LDO1",
-		.min_uV			= 600000,
-		.max_uV			= 3900000,
-		.apply_uV		= 1,
-		
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
-		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
-
-	},
-	.num_consumer_supplies = ARRAY_SIZE(act8931_ldo4_supply),
-	.consumer_supplies =  act8931_ldo4_supply,
-};
-
-struct act8931_regulator_subdev act8931_regulator_subdev_id[] = {
-	{
-		.id=0,
-		.initdata=&act8931_ldo1,		
-	 },
-
-	{
-		.id=1,
-		.initdata=&act8931_ldo2,		
-	 },
-
-	{
-		.id=2,
-		.initdata=&act8931_ldo3,		
-	 },
-
-	{
-		.id=3,
-		.initdata=&act8931_ldo4,		
-	 },
-
-	{
-		.id=4,
-		.initdata=&act8931_buck1,		
-	 },
-
-	{
-		.id=5,
-		.initdata=&act8931_buck2,		
-	 },
-	{
-		.id=6,
-		.initdata=&act8931_buck3,		
-	 },
-
-};
-
-struct act8931_platform_data act8931_data={
-	.set_init=act8931_set_init,
-	.num_regulators=7,
-	.regulators=act8931_regulator_subdev_id,
-	
-};
-
-
-#endif
-
diff --git a/arch/arm/mach-rk30/Kconfig b/arch/arm/mach-rk30/Kconfig
index 9ce0820221bc..f028bbc3c126 100755
--- a/arch/arm/mach-rk30/Kconfig
+++ b/arch/arm/mach-rk30/Kconfig
@@ -52,8 +52,6 @@ config MACH_RK3066B_FPGA
 
 config MACH_RK3066B_SDK
 	bool "RK3066B SDK board"
-config MACH_RK3066B_M701
-	bool "RK3066B M701 board"
 
 endchoice
 
diff --git a/arch/arm/mach-rk30/Makefile b/arch/arm/mach-rk30/Makefile
index 24f2b0122997..01752c8326ae 100755
--- a/arch/arm/mach-rk30/Makefile
+++ b/arch/arm/mach-rk30/Makefile
@@ -37,4 +37,3 @@ obj-$(CONFIG_MACH_RK30_PHONE_A22) += board-rk30-phone-a22.o board-rk30-phone-a22
 
 obj-$(CONFIG_MACH_RK3066B_FPGA) += board-rk3066b-fpga.o
 obj-$(CONFIG_MACH_RK3066B_SDK) += board-rk3066b-sdk.o
-obj-$(CONFIG_MACH_RK3066B_M701) += board-rk3066b-m701.o
diff --git a/arch/arm/mach-rk30/board-rk3066b-m701-key.c b/arch/arm/mach-rk30/board-rk3066b-m701-key.c
deleted file mode 100644
index 2e8d87268a0e..000000000000
--- a/arch/arm/mach-rk30/board-rk3066b-m701-key.c
+++ /dev/null
@@ -1,66 +0,0 @@
-#include <mach/gpio.h>
-#include <plat/key.h>
-
-#define EV_ENCALL				KEY_F4
-#define EV_MENU					KEY_F1
-
-#define PRESS_LEV_LOW			1
-#define PRESS_LEV_HIGH			0
-
-static struct rk29_keys_button key_button[] = {
-	{
-		.desc	= "vol-",
-		.code	= KEY_VOLUMEDOWN,
-		.adc_value	= 1,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "play",
-		.code	= KEY_POWER,
-		.gpio	= RK30_PIN0_PA4, 
-		.active_low = PRESS_LEV_LOW,
-		.wakeup	= 1,
-	},
-	{
-		.desc	= "vol+",
-		.code	= KEY_VOLUMEUP,
-		.adc_value	= 630,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "menu",
-		.code	= EV_MENU,
-		.adc_value	= 155,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "home",
-		.code	= KEY_HOME,
-		.adc_value	= 550,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "esc",
-		.code	= KEY_BACK,
-		.adc_value	= 386,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "camera",
-		.code	= KEY_CAMERA,
-		.adc_value	= 827,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-};
-struct rk29_keys_platform_data rk29_keys_pdata = {
-	.buttons	= key_button,
-	.nbuttons	= ARRAY_SIZE(key_button),
-	.chn	= 1,  //chn: 0-7, if do not use ADC,set 'chn' -1
-};
-
diff --git a/arch/arm/mach-rk30/board-rk3066b-m701.c b/arch/arm/mach-rk30/board-rk3066b-m701.c
deleted file mode 100644
index b7965198dbe1..000000000000
--- a/arch/arm/mach-rk30/board-rk3066b-m701.c
+++ /dev/null
@@ -1,1628 +0,0 @@
-/*
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/skbuff.h>
-#include <linux/spi/spi.h>
-#include <linux/mmc/host.h>
-#include <linux/ion.h>
-#include <linux/cpufreq.h>
-#include <linux/clk.h>
-#include <mach/dvfs.h>
-
-#include <asm/setup.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/hardware/gic.h>
-
-#include <mach/board.h>
-#include <mach/hardware.h>
-#include <mach/io.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <linux/fb.h>
-#include <linux/regulator/machine.h>
-#include <linux/rfkill-rk.h>
-#include <linux/sensor-dev.h>
-#include <linux/mfd/tps65910.h>
-#include <linux/regulator/rk29-pwm-regulator.h>
-#if defined(CONFIG_HDMI_RK30)
-	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
-#endif
-
-#if defined(CONFIG_SPIM_RK29)
-#include "../../../drivers/spi/rk29_spim.h"
-#endif
-#if defined(CONFIG_MU509)
-#include <linux/mu509.h>
-#endif
-#if defined(CONFIG_MW100)
-#include <linux/mw100.h>
-#endif
-#if defined(CONFIG_MT6229)
-#include <linux/mt6229.h>
-#endif
-#if defined(CONFIG_SEW868)
-#include <linux/sew868.h>
-#endif
-#if defined(CONFIG_ANDROID_TIMED_GPIO)
-#include "../../../drivers/staging/android/timed_gpio.h"
-#endif
-
-#ifdef  CONFIG_THREE_FB_BUFFER
-#define RK30_FB0_MEM_SIZE 12*SZ_1M
-#else
-#define RK30_FB0_MEM_SIZE 8*SZ_1M
-#endif
-
-#include "board-rk3066b-sdk-camera.c"
-#include "board-rk3066b-m701-key.c"
-
-#if defined(CONFIG_TOUCHSCREEN_GT8XX)
-#define TOUCH_RESET_PIN  RK30_PIN2_PC0
-#define TOUCH_PWR_PIN    RK30_PIN2_PB4
-static int goodix_init_platform_hw(void)
-{
-	int ret;
-	
-	rk30_mux_api_set(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME, GPIO2C_GPIO2C0);
-	rk30_mux_api_set(GPIO2B4_LCDC1DATA12_SMCDATA12_TRACEDATA12_NAME, GPIO2B_GPIO2B4);
-	printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME),rk30_mux_api_get(GPIO2B4_LCDC1DATA12_SMCDATA12_TRACEDATA12_NAME));
-
-	if (TOUCH_PWR_PIN != INVALID_GPIO) {
-		ret = gpio_request(TOUCH_PWR_PIN, "goodix power pin");
-		if (ret != 0) {
-			gpio_free(TOUCH_PWR_PIN);
-			printk("goodix power error\n");
-			return -EIO;
-		}
-		gpio_direction_output(TOUCH_PWR_PIN, 0);
-		gpio_set_value(TOUCH_PWR_PIN, GPIO_LOW);
-		msleep(100);
-	}
-
-	if (TOUCH_RESET_PIN != INVALID_GPIO) {
-		ret = gpio_request(TOUCH_RESET_PIN, "goodix reset pin");
-		if (ret != 0) {
-			gpio_free(TOUCH_RESET_PIN);
-			printk("goodix gpio_request error\n");
-			return -EIO;
-		}
-		gpio_direction_output(TOUCH_RESET_PIN, 1);
-                msleep(100);
-		//gpio_set_value(TOUCH_RESET_PIN, GPIO_LOW);
-		//msleep(100);
-		//gpio_set_value(TOUCH_RESET_PIN, GPIO_HIGH);
-		//msleep(500);
-	}
-	return 0;
-}
-
-struct goodix_platform_data goodix_info = {
-	.model = 8105,
-	.irq_pin = RK30_PIN0_PD4,
-	.rest_pin = TOUCH_RESET_PIN,
-	.init_platform_hw = goodix_init_platform_hw,
-};
-#endif
-
-#if defined (CONFIG_TOUCHSCREEN_FT5306)
-
-#define TOUCH_RESET_PIN  RK30_PIN2_PC0
-#define TOUCH_INT_PIN	 RK30_PIN0_PD4
-#define TOUCH_PWR_PIN    RK30_PIN2_PB4
-
-static int ft5x0x_init_platform_hw(void)
-{
-
-	rk30_mux_api_set(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME, GPIO2C_GPIO2C0);
-        rk30_mux_api_set(GPIO2B4_LCDC1DATA12_SMCDATA12_TRACEDATA12_NAME, GPIO2B_GPIO2B4);
-       //printk("%s:0x%x,0x%x\n",__func__,rk30_mux_api_get(GPIO2C0_LCDC1DATA16_SMCADDR0_TRACECLK_NAME),rk30_mux_api_get(GPIO2B4_LCDC1DATA12_SMCDATA12_TRACEDATA12_NAME));
-
-	printk("==ft5x0x_init_platform_hw =\n");
-	if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
-	  gpio_free(TOUCH_RESET_PIN);
-	  printk("ft5606_init_platform_hw gpio_request error\n");
-	  return -EIO;
-	}
-
-	if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
-	  gpio_free(TOUCH_INT_PIN);
-	  printk("ift5606_init_platform_hw gpio_request error\n");
-	  return -EIO;
-	}
-
-	gpio_direction_output(TOUCH_RESET_PIN, 0);
-	gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
-	mdelay(50);
-	gpio_direction_input(TOUCH_INT_PIN);
-	mdelay(10);
-	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
-	msleep(300);
-	return 0;
-}
-
-void ft5x0x_exit_platform_hw(void)
-{
-	printk("ft5606_exit_platform_hw\n");
-	gpio_free(TOUCH_RESET_PIN);
-	gpio_free(TOUCH_INT_PIN);
-}
-
-int ft5x0x_platform_sleep(void)
-{
-	printk("ft5606_platform_sleep\n");
-	gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
-	return 0;
-}
-
-int ft5x0x_platform_wakeup(void)
-{
-	printk("ft5606_platform_wakeup\n");
-	gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
-	msleep(300);
-	return 0;
-}
-
-static struct ft5606_platform_data ft5x0x_info = {
-	.init_platform_hw= ft5x0x_init_platform_hw,
-	.exit_platform_hw= ft5x0x_exit_platform_hw,
-	.platform_sleep  = ft5x0x_platform_sleep,
-	.platform_wakeup = ft5x0x_platform_wakeup,
-};
-#endif
-
-
-static struct spi_board_info board_spi_devices[] = {
-};
-
-/***********************************************************
-*	rk30  backlight
-************************************************************/
-#ifdef CONFIG_BACKLIGHT_RK29_BL
-#define PWM_ID            2
-#define PWM_MUX_NAME      GPIO3D5_PWM2_JTAGTCK_OTGDRVVBUS_NAME
-#define PWM_MUX_MODE      GPIO3D_PWM2
-#define PWM_MUX_MODE_GPIO GPIO3D_GPIO3D5
-#define PWM_GPIO 	  RK30_PIN3_PD5
-#define PWM_EFFECT_VALUE  0
-
-#define LCD_DISP_ON_PIN
-
-#ifdef  LCD_DISP_ON_PIN
-#define BL_EN_PIN         RK30_PIN0_PA2
-#define BL_EN_VALUE       GPIO_HIGH
-#endif
-static int rk29_backlight_io_init(void)
-{
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
-	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
-
-	ret = gpio_request(BL_EN_PIN, NULL);
-	if (ret != 0) {
-		gpio_free(BL_EN_PIN);
-	}
-
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
-	return ret;
-}
-
-static int rk29_backlight_io_deinit(void)
-{
-	int ret = 0;
-#ifdef  LCD_DISP_ON_PIN
-	gpio_free(BL_EN_PIN);
-#endif
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	return ret;
-}
-
-static int rk29_backlight_pwm_suspend(void)
-{
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	if (gpio_request(PWM_GPIO, NULL)) {
-		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
-		return -1;
-	}
-	gpio_direction_output(PWM_GPIO, GPIO_LOW);
-#ifdef  LCD_DISP_ON_PIN
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
-#endif
-	return ret;
-}
-
-static int rk29_backlight_pwm_resume(void)
-{
-	gpio_free(PWM_GPIO);
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
-	msleep(30);
-	gpio_direction_output(BL_EN_PIN, 1);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
-	return 0;
-}
-
-static struct rk29_bl_info rk29_bl_info = {
-	.pwm_id = PWM_ID,
-	.bl_ref = PWM_EFFECT_VALUE,
-	.io_init = rk29_backlight_io_init,
-	.io_deinit = rk29_backlight_io_deinit,
-	.pwm_suspend = rk29_backlight_pwm_suspend,
-	.pwm_resume = rk29_backlight_pwm_resume,
-};
-
-static struct platform_device rk29_device_backlight = {
-	.name	= "rk29_backlight",
-	.id 	= -1,
-	.dev	= {
-		.platform_data  = &rk29_bl_info,
-	}
-};
-
-#endif
-
-#ifdef CONFIG_RK29_SUPPORT_MODEM
-
-#define RK30_MODEM_POWER        RK30_PIN2_PB0
-#define RK30_MODEM_POWER_IOMUX  rk29_mux_api_set(GPIO2B0_LCDC1DATA8_SMCDATA8_TRACEDATA8_NAME, GPIO2B_GPIO2B0)
-
-static int rk30_modem_io_init(void)
-{
-    printk("%s\n", __FUNCTION__);
-    RK30_MODEM_POWER_IOMUX;
-
-	return 0;
-}
-
-static struct rk29_io_t rk30_modem_io = {
-    .io_addr    = RK30_MODEM_POWER,
-    .enable     = GPIO_HIGH,
-    .disable    = GPIO_LOW,
-    .io_init    = rk30_modem_io_init,
-};
-
-static struct platform_device rk30_device_modem = {
-	.name	= "rk30_modem",
-	.id 	= -1,
-	.dev	= {
-		.platform_data  = &rk30_modem_io,
-	}
-};
-#endif
-#if defined(CONFIG_MU509)
-static int mu509_io_init(void)
-{
-
-	rk30_mux_api_set(GPIO2B0_LCDC1DATA8_SMCDATA8_TRACEDATA8_NAME, GPIO2B_GPIO2B0);
-       rk30_mux_api_set(GPIO2D1_LCDC1DEN_SMCWEN_NAME, GPIO2D_GPIO2D1);
-	rk30_mux_api_set(GPIO2B7_LCDC1DATA15_SMCADDR19_HSADCDATA7_NAME, GPIO2B_GPIO2B7);
-	rk30_mux_api_set(GPIO2C0_LCDCDATA16_GPSCLK_HSADCCLKOUT_NAME, GPIO2C_GPIO2C0);
-	return 0;
-}
-
-static int mu509_io_deinit(void)
-{
-	
-	return 0;
-}
- 
-struct rk29_mu509_data rk29_mu509_info = {
-	.io_init = mu509_io_init,
-  	.io_deinit = mu509_io_deinit,
-	.modem_power_en = RK30_PIN2_PB0,
-	.bp_power = RK30_PIN2_PB0,
-	.bp_reset = RK30_PIN2_PD1,
-	.ap_wakeup_bp = RK30_PIN2_PB7,
-	.bp_wakeup_ap = RK30_PIN6_PA0, 
-};
-struct platform_device rk29_device_mu509 = {	
-        .name = "mu509",	
-    	.id = -1,	
-	.dev		= {
-		.platform_data = &rk29_mu509_info,
-	}    	
-    };
-#endif
-#if defined(CONFIG_MW100)
-static int mw100_io_init(void)
-{
-	 rk30_mux_api_set(GPIO2B0_LCDC1DATA8_SMCDATA8_TRACEDATA8_NAME, GPIO2B_GPIO2B0);
-	 rk30_mux_api_set(GPIO2D1_LCDC1DEN_SMCWEN_NAME, GPIO2D_GPIO2D1);
-	 rk30_mux_api_set(GPIO2B7_LCDC1DATA15_SMCADDR19_HSADCDATA7_NAME, GPIO2B_GPIO2B7);
-	 rk30_mux_api_set(GPIO2C0_LCDCDATA16_GPSCLK_HSADCCLKOUT_NAME, GPIO2C_GPIO2C0);
-	return 0;
-}
-
-static int mw100_io_deinit(void)
-{
-	
-	return 0;
-}
- 
-struct rk29_mw100_data rk29_mw100_info = {
-	.io_init = mw100_io_init,
-  	.io_deinit = mw100_io_deinit,
-	.modem_power_en = RK30_PIN6_PB0,
-	.bp_power = RK30_PIN2_PB0,
-	.bp_reset = RK30_PIN2_PD1,
-	.ap_wakeup_bp = RK30_PIN2_PB7,
-	.bp_wakeup_ap = RK30_PIN6_PA0,
-};
-struct platform_device rk29_device_mw100 = {	
-        .name = "mw100",	
-    	.id = -1,	
-	.dev		= {
-		.platform_data = &rk29_mw100_info,
-	}    	
-    };
-#endif
-#if defined(CONFIG_MT6229)
-static int mt6229_io_init(void)
-{
-	 rk30_mux_api_set(GPIO2B0_LCDC1DATA8_SMCDATA8_TRACEDATA8_NAME, GPIO2B_GPIO2B0);
-	 rk30_mux_api_set(GPIO2D1_LCDC1DEN_SMCWEN_NAME, GPIO2D_GPIO2D1);
-	 rk30_mux_api_set(GPIO2B7_LCDC1DATA15_SMCADDR19_HSADCDATA7_NAME, GPIO2B_GPIO2B7);
-	 rk30_mux_api_set(GPIO2C0_LCDCDATA16_GPSCLK_HSADCCLKOUT_NAME, GPIO2C_GPIO2C0);
-	return 0;
-}
-
-static int mt6229_io_deinit(void)
-{
-	
-	return 0;
-}
- 
-struct rk29_mt6229_data rk29_mt6229_info = {
-	.io_init = mt6229_io_init,
-  	.io_deinit = mt6229_io_deinit,
-	.modem_power_en = RK30_PIN2_PB0,
-	.bp_power = RK30_PIN2_PB0,//RK30_PIN2_PB6,
-	.bp_reset = RK30_PIN2_PD1,
-	.ap_wakeup_bp = RK30_PIN2_PC0,
-	.bp_wakeup_ap = RK30_PIN6_PA0,
-};
-struct platform_device rk29_device_mt6229 = {	
-        .name = "mt6229",	
-    	.id = -1,	
-	.dev		= {
-		.platform_data = &rk29_mt6229_info,
-	}    	
-    };
-#endif
-#if defined(CONFIG_SEW868)
-static int sew868_io_init(void)
-{
-	rk30_mux_api_set(GPIO2B6_LCDC1DATA14_SMCADDR18_TSSYNC_NAME, GPIO2B_GPIO2B6);
-    rk30_mux_api_set(GPIO4D2_SMCDATA10_TRACEDATA10_NAME, GPIO4D_GPIO4D2);
-	rk30_mux_api_set(GPIO4D4_SMCDATA12_TRACEDATA12_NAME, GPIO4D_GPIO4D4);
-	return 0;
-}
-static int sew868_io_deinit(void)
-{
-	return 0;
-}
-struct rk30_sew868_data rk30_sew868_info = {
-	.io_init = sew868_io_init,
-  	.io_deinit = sew868_io_deinit,
-	.bp_power = RK30_PIN6_PB2, 
-	.bp_power_active_low = 1,
-	.bp_sys = RK30_PIN2_PB6, 
-	.bp_reset = RK30_PIN4_PD2, 
-	.bp_reset_active_low = 1,
-	.bp_wakeup_ap = RK30_PIN4_PD4, 
-	.ap_wakeup_bp = NULL,
-};
-
-struct platform_device rk30_device_sew868 = {	
-        .name = "sew868",	
-    	.id = -1,	
-	.dev		= {
-		.platform_data = &rk30_sew868_info,
-	}    	
-    };
-#endif
-
-
-#if defined (CONFIG_GS_MMA7660)
-#define MMA7660_INT_PIN                      	RK30_PIN4_PC0
-static int gs_init_platform_hw(void)
-{
-	rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME, GPIO4C_GPIO4C0);
-    if(gpio_request(MMA7660_INT_PIN, NULL) != 0){
-      gpio_free(MMA7660_INT_PIN);
-      printk("gsensor gpio_request error\n");
-      return -EIO;
-    }
-	//gpio_direction_input(MMA7660_INT_PIN);
-    gpio_pull_updown(MMA7660_INT_PIN, 1);
-    return 0;
-}
-
-
-static struct gs_platform_data mma7660_info = {
-  .model= 7660,
-  .swap_xy = 0,
-  .init_platform_hw= gs_init_platform_hw,
-};
-#endif
-
-
-/*MMA8452 gsensor*/
-#if defined (CONFIG_GS_MMA8452)
-#define MMA8452_INT_PIN   RK30_PIN3_PD7
-
-static int mma8452_init_platform_hw(void)
-{
-	return 0;
-}
-
-static struct sensor_platform_data mma8452_info = {
-	.type = SENSOR_TYPE_ACCEL,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-        .init_platform_hw = mma8452_init_platform_hw,
-        .orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
-};
-#endif
-#if defined (CONFIG_GS_LIS3DH)
-#define LIS3DH_INT_PIN   RK30_PIN3_PD7
-
-static int lis3dh_init_platform_hw(void)
-{
-
-        return 0;
-}
-
-static struct sensor_platform_data lis3dh_info = {
-	.type = SENSOR_TYPE_ACCEL,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-        .init_platform_hw = lis3dh_init_platform_hw,
-	.orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
-};
-#endif
-#if defined (CONFIG_COMPASS_AK8975)
-static struct sensor_platform_data akm8975_info =
-{
-	.type = SENSOR_TYPE_COMPASS,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-	.m_layout = 
-	{
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-	}
-};
-
-#endif
-
-#if defined(CONFIG_GYRO_L3G4200D)
-
-#include <linux/l3g4200d.h>
-#define L3G4200D_INT_PIN  RK30_PIN0_PB4
-
-static int l3g4200d_init_platform_hw(void)
-{
-	return 0;
-}
-
-static struct sensor_platform_data l3g4200d_info = {
-	.type = SENSOR_TYPE_GYROSCOPE,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
-	.init_platform_hw = l3g4200d_init_platform_hw,
-	.x_min = 40,//x_min,y_min,z_min = (0-100) according to hardware
-	.y_min = 40,
-	.z_min = 20,
-};
-
-#endif
-
-#ifdef CONFIG_LS_CM3217
-static struct sensor_platform_data cm3217_info = {
-	.type = SENSOR_TYPE_LIGHT,
-	.irq_enable = 0,
-	.poll_delay_ms = 500,
-};
-
-#endif
-
-#ifdef CONFIG_FB_ROCKCHIP
-
-#define LCD_CS_PIN         INVALID_GPIO
-#define LCD_CS_VALUE       GPIO_HIGH
-
-#define LCD_EN_PIN         RK30_PIN0_PB0
-#define LCD_EN_VALUE       GPIO_HIGH
-
-static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
-{
-	int ret = 0;
-
-	if(LCD_CS_PIN !=INVALID_GPIO)
-	{
-		ret = gpio_request(LCD_CS_PIN, NULL);
-		if (ret != 0)
-		{
-			gpio_free(LCD_CS_PIN);
-			printk(KERN_ERR "request lcd cs pin fail!\n");
-			return -1;
-		}
-		else
-		{
-			gpio_direction_output(LCD_CS_PIN, LCD_CS_VALUE);
-		}
-	}
-
-	if(LCD_EN_PIN !=INVALID_GPIO)
-	{
-		ret = gpio_request(LCD_EN_PIN, NULL);
-		if (ret != 0)
-		{
-			gpio_free(LCD_EN_PIN);
-			printk(KERN_ERR "request lcd en pin fail!\n");
-			return -1;
-		}
-		else
-		{
-			gpio_direction_output(LCD_EN_PIN, LCD_EN_VALUE);
-		}
-	}
-	return 0;
-}
-static int rk_fb_io_disable(void)
-{
-	if(LCD_CS_PIN !=INVALID_GPIO)
-	{
-		gpio_set_value(LCD_CS_PIN, !LCD_CS_VALUE);
-	}
-	if(LCD_EN_PIN !=INVALID_GPIO)
-	{
-		gpio_set_value(LCD_EN_PIN, !LCD_EN_VALUE);
-	}
-	return 0;
-}
-static int rk_fb_io_enable(void)
-{
-	if(LCD_CS_PIN !=INVALID_GPIO)
-	{
-		gpio_set_value(LCD_CS_PIN, LCD_CS_VALUE);
-	}
-	if(LCD_EN_PIN !=INVALID_GPIO)
-	{
-		gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
-	}
-	return 0;
-}
-
-#if defined(CONFIG_LCDC0_RK31)
-struct rk29fb_info lcdc0_screen_info = {
-	.prop	   = PRMRY,		//primary display device
-	.io_init   = rk_fb_io_init,
-	.io_disable = rk_fb_io_disable,
-	.io_enable = rk_fb_io_enable,
-	.set_screen_info = set_lcd_info,
-};
-#endif
-
-#if defined(CONFIG_LCDC1_RK31)
-struct rk29fb_info lcdc1_screen_info = {
-	#if defined(CONFIG_HDMI_RK30)
-	.prop		= EXTEND,	//extend display device
-	.lcd_info  = NULL,
-	.set_screen_info = hdmi_init_lcdc,
-	#endif
-};
-#endif
-
-static struct resource resource_fb[] = {
-	[0] = {
-		.name  = "fb0 buf",
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.name  = "ipp buf",  //for rotate
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[2] = {
-		.name  = "fb2 buf",
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device device_fb = {
-	.name		= "rk-fb",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(resource_fb),
-	.resource	= resource_fb,
-};
-#endif
-
-#if defined(CONFIG_LCDC0_RK31)
-static struct resource resource_lcdc0[] = {
-	[0] = {
-		.name  = "lcdc0 reg",
-		.start = RK30_LCDC0_PHYS,
-		.end   = RK30_LCDC0_PHYS + RK30_LCDC0_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	
-	[1] = {
-		.name  = "lcdc0 irq",
-		.start = IRQ_LCDC0,
-		.end   = IRQ_LCDC0,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device device_lcdc0 = {
-	.name		  = "rk30-lcdc",
-	.id		  = 0,
-	.num_resources	  = ARRAY_SIZE(resource_lcdc0),
-	.resource	  = resource_lcdc0,
-	.dev 		= {
-		.platform_data = &lcdc0_screen_info,
-	},
-};
-#endif
-#if defined(CONFIG_LCDC1_RK31) 
-static struct resource resource_lcdc1[] = {
-	[0] = {
-		.name  = "lcdc1 reg",
-		.start = RK30_LCDC1_PHYS,
-		.end   = RK30_LCDC1_PHYS + RK30_LCDC1_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.name  = "lcdc1 irq",
-		.start = IRQ_LCDC1,
-		.end   = IRQ_LCDC1,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device device_lcdc1 = {
-	.name		  = "rk30-lcdc",
-	.id		  = 1,
-	.num_resources	  = ARRAY_SIZE(resource_lcdc1),
-	.resource	  = resource_lcdc1,
-	.dev 		= {
-		.platform_data = &lcdc1_screen_info,
-	},
-};
-#endif
-
-#ifdef CONFIG_ANDROID_TIMED_GPIO
-static struct timed_gpio timed_gpios[] = {
-	{
-		.name = "vibrator",
-		.gpio = RK30_PIN3_PD3,
-		.max_timeout = 1000,
-		.active_low = 0,
-		.adjust_time =20,      //adjust for diff product
-	},
-};
-
-static struct timed_gpio_platform_data rk29_vibrator_info = {
-	.num_gpios = 1,
-	.gpios = timed_gpios,
-};
-
-static struct platform_device rk29_device_vibrator = {
-	.name = "timed-gpio",
-	.id = -1,
-	.dev = {
-		.platform_data = &rk29_vibrator_info,
-	},
-
-};
-#endif
-
-#ifdef CONFIG_LEDS_GPIO_PLATFORM
-static struct gpio_led rk29_leds[] = {
-	{
-		.name = "button-backlight",
-		.gpio = RK30_PIN2_PB3,
-		.default_trigger = "timer",
-		.active_low = 0,
-		.retain_state_suspended = 0,
-		.default_state = LEDS_GPIO_DEFSTATE_OFF,
-	},
-};
-
-static struct gpio_led_platform_data rk29_leds_pdata = {
-	.leds = rk29_leds,
-	.num_leds = ARRAY_SIZE(rk29_leds),
-};
-
-static struct platform_device rk29_device_gpio_leds = {
-	.name	= "leds-gpio",
-	.id	= -1,
-	.dev	= {
-		.platform_data  = &rk29_leds_pdata,
-	},
-};
-#endif
-
-#ifdef CONFIG_RK_IRDA
-#define IRDA_IRQ_PIN           RK30_PIN0_PA3
-
-static int irda_iomux_init(void)
-{
-	int ret = 0;
-
-	//irda irq pin
-	ret = gpio_request(IRDA_IRQ_PIN, NULL);
-	if (ret != 0) {
-		gpio_free(IRDA_IRQ_PIN);
-		printk(">>>>>> IRDA_IRQ_PIN gpio_request err \n ");
-	}
-	gpio_pull_updown(IRDA_IRQ_PIN, PullDisable);
-	gpio_direction_input(IRDA_IRQ_PIN);
-
-	return 0;
-}
-
-static int irda_iomux_deinit(void)
-{
-	gpio_free(IRDA_IRQ_PIN);
-	return 0;
-}
-
-static struct irda_info rk29_irda_info = {
-	.intr_pin = IRDA_IRQ_PIN,
-	.iomux_init = irda_iomux_init,
-	.iomux_deinit = irda_iomux_deinit,
-	//.irda_pwr_ctl = bu92747guw_power_ctl,
-};
-
-static struct platform_device irda_device = {
-#ifdef CONFIG_RK_IRDA_NET
-	.name = "rk_irda",
-#else
-	.name = "bu92747_irda",
-#endif
-	.id = -1,
-	.dev = {
-		.platform_data = &rk29_irda_info,
-	}
-};
-#endif
-
-#ifdef CONFIG_ION
-#define ION_RESERVE_SIZE        (80 * SZ_1M)
-static struct ion_platform_data rk30_ion_pdata = {
-	.nr = 1,
-	.heaps = {
-		{
-			.type = ION_HEAP_TYPE_CARVEOUT,
-			.id = ION_NOR_HEAP_ID,
-			.name = "norheap",
-			.size = ION_RESERVE_SIZE,
-		}
-	},
-};
-
-static struct platform_device device_ion = {
-	.name = "ion-rockchip",
-	.id = 0,
-	.dev = {
-		.platform_data = &rk30_ion_pdata,
-	},
-};
-#endif
-
-/**************************************************************************************************
- * SDMMC devices,  include the module of SD,MMC,and sdio.noted by xbw at 2012-03-05
-**************************************************************************************************/
-#ifdef CONFIG_SDMMC_RK29
-#include "board-rk3066b-sdk-sdmmc.c"
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-#define SDMMC0_WRITE_PROTECT_PIN	RK30_PIN3_PB7	//According to your own project to set the value of write-protect-pin.
-#endif
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-#define SDMMC1_WRITE_PROTECT_PIN	RK30_PIN3_PC7	//According to your own project to set the value of write-protect-pin.
-#endif
-
-#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK30_PIN6_PB2
-
-#endif //endif ---#ifdef CONFIG_SDMMC_RK29
-
-#ifdef CONFIG_SDMMC0_RK29
-static int rk29_sdmmc0_cfg_gpio(void)
-{
-#ifdef CONFIG_SDMMC_RK29_OLD
-	rk30_mux_api_set(GPIO3B1_SDMMC0CMD_NAME, GPIO3B_SDMMC0_CMD);
-	rk30_mux_api_set(GPIO3B0_SDMMC0CLKOUT_NAME, GPIO3B_SDMMC0_CLKOUT);
-	rk30_mux_api_set(GPIO3B2_SDMMC0DATA0_NAME, GPIO3B_SDMMC0_DATA0);
-	rk30_mux_api_set(GPIO3B3_SDMMC0DATA1_NAME, GPIO3B_SDMMC0_DATA1);
-	rk30_mux_api_set(GPIO3B4_SDMMC0DATA2_NAME, GPIO3B_SDMMC0_DATA2);
-	rk30_mux_api_set(GPIO3B5_SDMMC0DATA3_NAME, GPIO3B_SDMMC0_DATA3);
-
-	rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME, GPIO3B_GPIO3B6);
-
-	rk30_mux_api_set(GPIO3A7_SDMMC0PWREN_NAME, GPIO3A_GPIO3A7);
-	gpio_request(RK30_PIN3_PA7, "sdmmc-power");
-	gpio_direction_output(RK30_PIN3_PA7, GPIO_LOW);
-
-#else
-	rk29_sdmmc_set_iomux(0, 0xFFFF);
-
-	rk30_mux_api_set(GPIO3B0_SDMMC0DETECTN_NAME, GPIO3B_SDMMC0DETECTN);
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
-	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
-#endif
-
-#endif
-
-	return 0;
-}
-
-#define CONFIG_SDMMC0_USE_DMA
-struct rk29_sdmmc_platform_data default_sdmmc0_data = {
-	.host_ocr_avail =
-	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
-	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
-	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
-	.host_caps =
-	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-	.io_init = rk29_sdmmc0_cfg_gpio,
-
-#if !defined(CONFIG_SDMMC_RK29_OLD)
-	.set_iomux = rk29_sdmmc_set_iomux,
-#endif
-
-	.dma_name = "sd_mmc",
-#ifdef CONFIG_SDMMC0_USE_DMA
-	.use_dma = 1,
-#else
-	.use_dma = 0,
-#endif
-	.detect_irq = RK30_PIN3_PB6,	// INVALID_GPIO
-	.enable_sd_wakeup = 0,
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
-#else
-	.write_prt = INVALID_GPIO,
-#endif
-};
-#endif // CONFIG_SDMMC0_RK29
-
-#ifdef CONFIG_SDMMC1_RK29
-#define CONFIG_SDMMC1_USE_DMA
-static int rk29_sdmmc1_cfg_gpio(void)
-{
-#if defined(CONFIG_SDMMC_RK29_OLD)
-	rk30_mux_api_set(GPIO3C0_SMMC1CMD_NAME, GPIO3C_SMMC1_CMD);
-	rk30_mux_api_set(GPIO3C5_SDMMC1CLKOUT_NAME, GPIO3C_SDMMC1_CLKOUT);
-	rk30_mux_api_set(GPIO3C1_SDMMC1DATA0_NAME, GPIO3C_SDMMC1_DATA0);
-	rk30_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME, GPIO3C_SDMMC1_DATA1);
-	rk30_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME, GPIO3C_SDMMC1_DATA2);
-	rk30_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME, GPIO3C_SDMMC1_DATA3);
-	//rk30_mux_api_set(GPIO3C6_SDMMC1DETECTN_NAME, GPIO3C_SDMMC1_DETECT_N);
-
-#else
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
-	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
-#endif
-
-#endif
-
-	return 0;
-}
-
-struct rk29_sdmmc_platform_data default_sdmmc1_data = {
-	.host_ocr_avail =
-	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
-	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
-	     MMC_VDD_33_34),
-
-#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
-	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
-		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-#else
-	.host_caps =
-	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-#endif
-
-	.io_init = rk29_sdmmc1_cfg_gpio,
-
-#if !defined(CONFIG_SDMMC_RK29_OLD)
-	.set_iomux = rk29_sdmmc_set_iomux,
-#endif
-
-	.dma_name = "sdio",
-#ifdef CONFIG_SDMMC1_USE_DMA
-	.use_dma = 1,
-#else
-	.use_dma = 0,
-#endif
-
-#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	.status = rk29sdk_wifi_status,
-	.register_status_notify = rk29sdk_wifi_status_register,
-#endif
-#if 0
-	.detect_irq = RK29SDK_WIFI_SDIO_CARD_DETECT_N,
-#endif
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
-#else
-	.write_prt = INVALID_GPIO,
-#endif
-
-#else
-	.detect_irq = INVALID_GPIO,
-	.enable_sd_wakeup = 0,
-#endif
-
-};
-#endif //endif--#ifdef CONFIG_SDMMC1_RK29
-
-/**************************************************************************************************
- * the end of setting for SDMMC devices
-**************************************************************************************************/
-
-#ifdef CONFIG_BATTERY_RK30_ADC
-static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
-        .dc_det_pin      = RK30_PIN0_PB2,
-        .batt_low_pin    = RK30_PIN0_PB1, 
-        .charge_set_pin  = INVALID_GPIO,
-        .charge_ok_pin   = RK30_PIN0_PA6,
-        .dc_det_level    = GPIO_LOW,
-        .charge_ok_level = GPIO_HIGH,
-};
-
-static struct platform_device rk30_device_adc_battery = {
-        .name   = "rk30-battery",
-        .id     = -1,
-        .dev = {
-                .platform_data = &rk30_adc_battery_platdata,
-        },
-};
-#endif
-#ifdef CONFIG_RK30_PWM_REGULATOR
-const static int pwm_voltage_map[] = {
-	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
-};
-
-static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
-	{
-		.supply = "vdd_core",
-	}
-};
-
-struct regulator_init_data pwm_regulator_init_dcdc[1] =
-{
-	{
-		.constraints = {
-			.name = "PWM_DCDC1",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
-		.consumer_supplies = pwm_dcdc1_consumers,
-	},
-};
-
-static struct pwm_platform_data pwm_regulator_info[1] = {
-	{
-		.pwm_id = 3,
-		.pwm_gpio = RK30_PIN3_PD6,
-		.pwm_iomux_name = GPIO3D6_PWM3_JTAGTMS_HOSTDRVVBUS_NAME,
-		.pwm_iomux_pwm = GPIO3D_PWM3,
-		.pwm_iomux_gpio = GPIO3D_GPIO3D6,
-		.pwm_voltage = 1000000,
-		.suspend_voltage = 1050000,
-		.min_uV = 1000000,
-		.max_uV	= 1400000,
-		.coefficient = 455,	//45.5%
-		.pwm_voltage_map = pwm_voltage_map,
-		.init_data	= &pwm_regulator_init_dcdc[0],
-	},
-};
-
-struct platform_device pwm_regulator_device[1] = {
-	{
-		.name = "pwm-voltage-regulator",
-		.id = 0,
-		.dev		= {
-			.platform_data = &pwm_regulator_info[0],
-		}
-	},
-};
-#endif
-
-#ifdef CONFIG_RK29_VMAC
-#define PHY_PWR_EN_GPIO	RK30_PIN1_PD6
-#include "board-rk30-sdk-vmac.c"
-#endif
-
-#ifdef CONFIG_RFKILL_RK
-// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
-static struct rfkill_rk_platform_data rfkill_rk_platdata = {
-    .type               = RFKILL_TYPE_BLUETOOTH,
-
-    .poweron_gpio       = { // BT_REG_ON
-        .io             = RK30_PIN3_PC7,
-        .enable         = GPIO_HIGH,
-        .iomux          = {
-            .name       = GPIO3C7_SDMMC1WRITEPRT_RMIICRS_NAME,
-            .fgpio      = GPIO3C_GPIO3C7,
-        },
-    },
-
-    .reset_gpio         = { // BT_RST
-        .io             = RK30_PIN3_PD1, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_LOW,
-        .iomux          = {
-            .name       = GPIO3D1_SDMMC1BACKENDPWR_MIIMDCLK_NAME,
-            .fgpio      = GPIO3D_GPIO3D1,
-       },
-   }, 
-
-    .wake_gpio          = { // BT_WAKE, use to control bt's sleep and wakeup
-        .io             = RK30_PIN3_PC6, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_HIGH,
-        .iomux          = {
-            .name       = GPIO3C6_SDMMC1DETECTN_RMIIRXERR_NAME,
-            .fgpio      = GPIO3C_GPIO3C6,
-        },
-    },
-
-    .wake_host_irq      = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
-        .gpio           = {
-            .io         = RK30_PIN0_PA5, // set io to INVALID_GPIO for disable it
-            .enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
-            .iomux      = {
-                .name   = NULL,
-            },
-        },
-    },
-
-    .rts_gpio           = { // UART_RTS, enable or disable BT's data coming
-        .io             = RK30_PIN1_PA3, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_LOW,
-        .iomux          = {
-            .name       = GPIO1A3_UART0RTSN_NAME,
-            .fgpio      = GPIO1A_GPIO1A3,
-            .fmux       = GPIO1A_UART0RTSN,
-        },
-    },
-};
-
-static struct platform_device device_rfkill_rk = {
-    .name   = "rfkill_rk",
-    .id     = -1,
-    .dev    = {
-        .platform_data = &rfkill_rk_platdata,
-    },
-};
-#endif
-
-static struct platform_device *devices[] __initdata = {
-#ifdef CONFIG_FB_ROCKCHIP
-	&device_fb,
-#endif
-#if defined(CONFIG_LCDC0_RK31)
-	&device_lcdc0,
-#endif
-#if defined(CONFIG_LCDC1_RK31)
-	&device_lcdc1,
-#endif
-		
-#ifdef CONFIG_BACKLIGHT_RK29_BL
-	&rk29_device_backlight,
-#endif
-
-#ifdef CONFIG_ION
-	&device_ion,
-#endif
-#ifdef CONFIG_ANDROID_TIMED_GPIO
-	&rk29_device_vibrator,
-#endif
-#ifdef CONFIG_LEDS_GPIO_PLATFORM
-	&rk29_device_gpio_leds,
-#endif
-#ifdef CONFIG_RK_IRDA
-	&irda_device,
-#endif
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	&rk29sdk_wifi_device,
-#endif
-#ifdef CONFIG_RK29_SUPPORT_MODEM
-	&rk30_device_modem,
-#endif
-#if defined(CONFIG_MU509)
-	&rk29_device_mu509,
-#endif
-#if defined(CONFIG_MW100)
-	&rk29_device_mw100,
-#endif
-#if defined(CONFIG_MT6229)
-	&rk29_device_mt6229,
-#endif
-#if defined(CONFIG_SEW868)
-	&rk30_device_sew868,
-#endif
-#ifdef CONFIG_BATTERY_RK30_ADC
- 	&rk30_device_adc_battery,
-#endif
-#ifdef CONFIG_RFKILL_RK
-	&device_rfkill_rk,
-#endif
-};
-
-// i2c
-#ifdef CONFIG_I2C0_RK30
-static struct i2c_board_info __initdata i2c0_info[] = {
-#if defined (CONFIG_GS_MMA7660)
-	{
-	  .type 		  = "gs_mma7660",
-	  .addr 		  = 0x4c,
-	  .flags		  = 0,
-	  .irq			  = MMA7660_INT_PIN,
-	  .platform_data  = &mma7660_info,
-	},
-#endif
-#if defined (CONFIG_GS_MMA8452)
-	{
-		.type	        = "gs_mma8452",
-		.addr	        = 0x1d,
-		.flags	        = 0,
-		.irq	        = MMA8452_INT_PIN,
-		.platform_data = &mma8452_info,
-	},
-#endif
-#if defined (CONFIG_GS_LIS3DH)
-	{
-		.type	        = "gs_lis3dh",
-		.addr	        = 0x19,   //0x19(SA0-->VCC), 0x18(SA0-->GND)
-		.flags	        = 0,
-		.irq	        = LIS3DH_INT_PIN,
-		.platform_data = &lis3dh_info,
-	},
-#endif
-#if defined (CONFIG_COMPASS_AK8975)
-	{
-		.type          = "ak8975",
-		.addr          = 0x0d,
-		.flags         = 0,
-		.irq           = RK30_PIN0_PD5,
-		.platform_data = &akm8975_info,
-	},
-#endif
-#if defined (CONFIG_GYRO_L3G4200D)
-	{
-		.type          = "l3g4200d_gryo",
-		.addr          = 0x69,
-		.flags         = 0,
-		.irq           = L3G4200D_INT_PIN,
-		.platform_data = &l3g4200d_info,
-	},
-#endif
-#if defined (CONFIG_SND_SOC_RK1000)
-	{
-		.type          = "rk1000_i2c_codec",
-		.addr          = 0x60,
-		.flags         = 0,
-	},
-	{
-		.type          = "rk1000_control",
-		.addr          = 0x40,
-		.flags         = 0,
-	},
-#endif
-#if defined (CONFIG_SND_SOC_RT5631)
-        {
-                .type                   = "rt5631",
-                .addr                   = 0x1a,
-                .flags                  = 0,
-        },
-#endif
-#if defined (CONFIG_SND_SOC_ES8323)
-        {
-                .type                   = "es8323",
-                .addr                   = 0x10,
-                .flags                  = 0,
-        },
-#endif
-#ifdef CONFIG_MFD_RK610
-		{
-			.type			= "rk610_ctl",
-			.addr			= 0x40,
-			.flags			= 0,
-		},
-#ifdef CONFIG_RK610_TVOUT
-		{
-			.type			= "rk610_tvout",
-			.addr			= 0x42,
-			.flags			= 0,
-		},
-#endif
-#ifdef CONFIG_RK610_HDMI
-		{
-			.type			= "rk610_hdmi",
-			.addr			= 0x46,
-			.flags			= 0,
-			.irq			= RK29_PIN5_PA2,
-		},
-#endif
-#ifdef CONFIG_SND_SOC_RK610
-		{//RK610_CODEC addr  from 0x60 to 0x80 (0x60~0x80)
-			.type			= "rk610_i2c_codec",
-			.addr			= 0x60,
-			.flags			= 0,
-		},
-#endif
-#endif
-
-};
-#endif
-
-#define PMIC_TYPE_WM8326	1
-#define PMIC_TYPE_TPS65910	2
-int __sramdata g_pmic_type =  0;
-#ifdef CONFIG_I2C1_RK30
-#ifdef CONFIG_MFD_WM831X_I2C
-#include "board-rk3066b-sdk-wm8326.c"
-#endif
-#ifdef CONFIG_MFD_TPS65910
-#define TPS65910_HOST_IRQ        RK30_PIN6_PA4
-#include "board-rk3066b-sdk-tps65910.c"
-#endif
-
-static struct i2c_board_info __initdata i2c1_info[] = {
-#if defined (CONFIG_MFD_WM831X_I2C)
-	{
-		.type          = "wm8326",
-		.addr          = 0x34,
-		.flags         = 0,
-		.irq           = RK30_PIN0_PB3,
-		.platform_data = &wm831x_platdata,
-	},
-#endif
-#if defined (CONFIG_MFD_TPS65910)
-	{
-        .type           = "tps65910",
-        .addr           = TPS65910_I2C_ID0,
-        .flags          = 0,
-        .irq            = TPS65910_HOST_IRQ,
-    	.platform_data = &tps65910_data,
-	},
-#endif
-};
-#endif
-
-void __sramfunc board_pmu_suspend(void)
-{      
-	#if defined (CONFIG_MFD_WM831X_I2C)
-       if(g_pmic_type == PMIC_TYPE_WM8326)
-       board_pmu_wm8326_suspend();
-	#endif
-	#if defined (CONFIG_MFD_TPS65910)
-       if(g_pmic_type == PMIC_TYPE_TPS65910)
-       board_pmu_tps65910_suspend(); 
-    #endif   
-}
-
-void __sramfunc board_pmu_resume(void)
-{      
-	#if defined (CONFIG_MFD_WM831X_I2C)
-       if(g_pmic_type == PMIC_TYPE_WM8326)
-       board_pmu_wm8326_resume();
-	#endif
-	#if defined (CONFIG_MFD_TPS65910)
-       if(g_pmic_type == PMIC_TYPE_TPS65910)
-       board_pmu_tps65910_resume(); 
-	#endif
-}
-
- int __sramdata gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
-
-void __sramfunc rk30_pwm_logic_suspend_voltage(void)
-{
-#ifdef CONFIG_RK30_PWM_REGULATOR
-
-//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
-	sram_udelay(10000);
-	gpio0d7_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
-	gpio0d7_do = grf_readl(GRF_GPIO0H_DO);
-	gpio0d7_dir = grf_readl(GRF_GPIO0H_DIR);
-	gpio0d7_en = grf_readl(GRF_GPIO0H_EN);
-
-	writel_relaxed((1<<30), GRF_GPIO0D_IOMUX);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DIR);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_DO);
-	grf_writel((1<<31)|(1<<15), GRF_GPIO0H_EN);
-#endif 
-}
-void __sramfunc rk30_pwm_logic_resume_voltage(void)
-{
-#ifdef CONFIG_RK30_PWM_REGULATOR
-	writel_relaxed((1<<30)|gpio0d7_iomux, GRF_GPIO0D_IOMUX);
-	grf_writel((1<<31)|gpio0d7_en, GRF_GPIO0H_EN);
-	grf_writel((1<<31)|gpio0d7_dir, GRF_GPIO0H_DIR);
-	grf_writel((1<<31)|gpio0d7_do, GRF_GPIO0H_DO);
-	sram_udelay(10000);
-
-#endif
-
-}
-extern void pwm_suspend_voltage(void);
-extern void pwm_resume_voltage(void);
-void  rk30_pwm_suspend_voltage_set(void)
-{
-#ifdef CONFIG_RK30_PWM_REGULATOR
-	pwm_suspend_voltage();
-#endif
-}
-void  rk30_pwm_resume_voltage_set(void)
-{
-#ifdef CONFIG_RK30_PWM_REGULATOR
-	pwm_resume_voltage();
-#endif
-}
-
-
-#ifdef CONFIG_I2C2_RK30
-static struct i2c_board_info __initdata i2c2_info[] = {
-#if defined (CONFIG_TOUCHSCREEN_GT8XX)
-	{
-		.type          = "Goodix-TS",
-		.addr          = 0x55,
-		.flags         = 0,
-		.irq           = RK30_PIN0_PD4,
-		.platform_data = &goodix_info,
-	},
-#endif
-#if defined (CONFIG_TOUCHSCREEN_FT5306)
-		{
-			.type			= "ft5x0x_ts",
-			.addr			= 0x38,
-			.flags			= 0,
-			.irq			= RK30_PIN0_PD4,
-			.platform_data	= &ft5x0x_info,
-		},
-#endif
-#if defined (CONFIG_LS_CM3217)
-	{
-		.type          = "lightsensor",
-		.addr          = 0x10,
-		.flags         = 0,
-		.platform_data = &cm3217_info,
-	},
-#endif
-};
-#endif
-
-#ifdef CONFIG_I2C3_RK30
-static struct i2c_board_info __initdata i2c3_info[] = {
-};
-#endif
-
-#ifdef CONFIG_I2C4_RK30
-static struct i2c_board_info __initdata i2c4_info[] = {
-};
-#endif
-
-#ifdef CONFIG_I2C_GPIO_RK30
-#define I2C_SDA_PIN     INVALID_GPIO// RK30_PIN2_PD6   //set sda_pin here
-#define I2C_SCL_PIN     INVALID_GPIO//RK30_PIN2_PD7   //set scl_pin here
-static int rk30_i2c_io_init(void)
-{
-        //set iomux (gpio) here
-        //rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME, GPIO2D_GPIO2D7);
-        //rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME, GPIO2D_GPIO2D6);
-
-        return 0;
-}
-struct i2c_gpio_platform_data default_i2c_gpio_data = {
-       .sda_pin = I2C_SDA_PIN,
-       .scl_pin = I2C_SCL_PIN,
-       .udelay = 5, // clk = 500/udelay = 100Khz
-       .timeout = 100,//msecs_to_jiffies(100),
-       .bus_num    = 5,
-       .io_init = rk30_i2c_io_init,
-};
-static struct i2c_board_info __initdata i2c_gpio_info[] = {
-};
-#endif
-
-static void __init rk30_i2c_register_board_info(void)
-{
-#ifdef CONFIG_I2C0_RK30
-	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
-#endif
-#ifdef CONFIG_I2C1_RK30
-	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
-#endif
-#ifdef CONFIG_I2C2_RK30
-	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
-#endif
-#ifdef CONFIG_I2C3_RK30
-	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
-#endif
-#ifdef CONFIG_I2C4_RK30
-	i2c_register_board_info(4, i2c4_info, ARRAY_SIZE(i2c4_info));
-#endif
-#ifdef CONFIG_I2C_GPIO_RK30
-	i2c_register_board_info(5, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
-#endif
-}
-//end of i2c
-
-#define POWER_ON_PIN RK30_PIN0_PA0   //power_hold
-static void rk30_pm_power_off(void)
-{
-	printk(KERN_ERR "rk30_pm_power_off start...\n");
-	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
-#if defined(CONFIG_MFD_WM831X)
-	wm831x_set_bits(Wm831x,WM831X_GPIO_LEVEL,0x0001,0x0000);  //set sys_pwr 0
-	wm831x_device_shutdown(Wm831x);//wm8326 shutdown
-#endif
-	while (1);
-}
-
-static void __init machine_rk30_board_init(void)
-{
-	//avs_init();
-	gpio_request(POWER_ON_PIN, "poweronpin");
-	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
-	
-	pm_power_off = rk30_pm_power_off;
-	
-	rk30_i2c_register_board_info();
-	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-	board_usb_detect_init(RK30_PIN0_PA7);
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	rk29sdk_wifi_bt_gpio_control_init();
-#endif
-}
-
-static void __init rk30_reserve(void)
-{
-#ifdef CONFIG_ION
-	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
-#endif
-#ifdef CONFIG_FB_ROCKCHIP
-	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
-	resource_fb[0].end = resource_fb[0].start + RK30_FB0_MEM_SIZE - 1;
-	#if 0
-	resource_fb[1].start = board_mem_reserve_add("ipp buf", RK30_FB0_MEM_SIZE);
-	resource_fb[1].end = resource_fb[1].start + RK30_FB0_MEM_SIZE - 1;
-	resource_fb[2].start = board_mem_reserve_add("fb2", RK30_FB0_MEM_SIZE);
-	resource_fb[2].end = resource_fb[2].start + RK30_FB0_MEM_SIZE - 1;
-	#endif
-#endif
-#ifdef CONFIG_VIDEO_RK29
-	rk30_camera_request_reserve_mem();
-#endif
-	board_mem_reserved();
-}
-
-/**
- * dvfs_cpu_logic_table: table for arm and logic dvfs 
- * @frequency	: arm frequency
- * @cpu_volt	: arm voltage depend on frequency
- * @logic_volt	: logic voltage arm requests depend on frequency
- * comments	: min arm/logic voltage
- */
-static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
-#if 0
-	{.frequency = 252 * 1000,	.cpu_volt = 1075 * 1000,	.logic_volt = 1125 * 1000},//0.975V/1.000V
-#endif
-	{.frequency = 504 * 1000,	.cpu_volt = 975 * 1000,		.logic_volt = 1000 * 1000},//0.975V/1.000V
-	{.frequency = 816 * 1000,	.cpu_volt = 1000 * 1000,	.logic_volt = 1000 * 1000},//1.000V/1.025V
-	{.frequency = 1200 * 1000,	.cpu_volt = 1025 * 1000,	.logic_volt = 1000 * 1000},//1.100V/1.050V
-#if 0
-	{.frequency = 1008 * 1000,	.cpu_volt = 1125 * 1000,	.logic_volt = 1150 * 1000},//1.025V/1.050V
-	{.frequency = 1272 * 1000,	.cpu_volt = 1225 * 1000,	.logic_volt = 1200 * 1000},//1.150V/1.100V
-	{.frequency = 1416 * 1000,	.cpu_volt = 1300 * 1000,	.logic_volt = 1200 * 1000},//1.225V/1.100V
-	{.frequency = 1512 * 1000,	.cpu_volt = 1350 * 1000,	.logic_volt = 1250 * 1000},//1.300V/1.150V
-	{.frequency = 1608 * 1000,	.cpu_volt = 1425 * 1000,	.logic_volt = 1300 * 1000},//1.325V/1.175V
-#endif
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-static struct cpufreq_frequency_table dvfs_gpu_table[] = {
-	{.frequency = 266 * 1000,	.index = 1000 * 1000},
-	{.frequency = 400 * 1000,	.index = 1000 * 1000},
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-static struct cpufreq_frequency_table dvfs_ddr_table[] = {
-	{.frequency = 300 * 1000,	.index = 1000 * 1000},
-	{.frequency = 400 * 1000,	.index = 1000 * 1000},
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-#define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
-static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
-static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
-
-void __init board_clock_init(void)
-{
-	rk30_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
-	dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
-	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
-	dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
-}
-
-MACHINE_START(RK30, "RK30board")
-	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
-	.fixup		= rk30_fixup,
-	.reserve	= &rk30_reserve,
-	.map_io		= rk30_map_io,
-	.init_irq	= rk30_init_irq,
-	.timer		= &rk30_timer,
-	.init_machine	= machine_rk30_board_init,
-MACHINE_END
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c b/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
index dbe91bca1c92..d61ef3f69c36 100644
--- a/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk-tps65910.c
@@ -259,7 +259,7 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	udelay(100);
 
 	ldo = regulator_get(NULL, "vdig2");	// vdd11
-	regulator_set_voltage(ldo, 1000000, 1000000);
+	regulator_set_voltage(ldo, 1100000, 1100000);
 	regulator_enable(ldo);
 	printk("%s set vdig2 vdd11=%dmV end\n", __func__, regulator_get_voltage(ldo));
 	regulator_put(ldo);
@@ -273,7 +273,7 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	udelay(100);
 	
 	dcdc = regulator_get(NULL, "vdd_cpu");	//vdd_cpu
-	regulator_set_voltage(dcdc, 1000000, 1000000);
+	regulator_set_voltage(dcdc, 1200000, 1200000);
 	regulator_enable(dcdc);
 	printk("%s set vdd1 vdd_cpu=%dmV end\n", __func__, regulator_get_voltage(dcdc));
 	regulator_put(dcdc);
diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk.c b/arch/arm/mach-rk30/board-rk3066b-sdk.c
index b6e28e9eaf61..81c59f7fd5e5 100644
--- a/arch/arm/mach-rk30/board-rk3066b-sdk.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk.c
@@ -168,7 +168,6 @@ static int rk29_backlight_io_deinit(void)
 	gpio_free(BL_EN_PIN);
 #endif
 	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	gpio_request(PWM_GPIO, NULL);
 	gpio_direction_output(PWM_GPIO, GPIO_LOW);
 	return ret;
 }
diff --git a/arch/arm/mach-rk30/clock_data.c b/arch/arm/mach-rk30/clock_data.c
old mode 100644
new mode 100755
index 4f84d7f6ecab..b20896242309
--- a/arch/arm/mach-rk30/clock_data.c
+++ b/arch/arm/mach-rk30/clock_data.c
@@ -981,6 +981,9 @@ static int arm_pll_clk_set_rate(struct clk *clk, unsigned long rate)
 	{	
 		ps_clksel1=force_cpu_hpclk_11(ps->clksel1);
 	}
+	else{
+		ps_clksel1=ps->clksel1;
+	}
 	//return form slow
 	//cru_writel(PLL_MODE_NORM(APLL_ID), CRU_MODE_CON);
 	//a/h/p clk sel
diff --git a/arch/arm/mach-rk30/devices.c b/arch/arm/mach-rk30/devices.c
index 9cf7314d12a4..94112b6ac41d 100755
--- a/arch/arm/mach-rk30/devices.c
+++ b/arch/arm/mach-rk30/devices.c
@@ -580,11 +580,7 @@ static int i2c_check_idle(int id)
 #ifdef CONFIG_I2C0_RK30
 static struct rk30_i2c_platform_data default_i2c0_data = {
 	.bus_num = 0,
-#if defined(CONFIG_ARCH_RK3066B)
-	.is_div_from_arm = 0,
-#else
 	.is_div_from_arm = 1,
-#endif
 	.adap_type = I2C0_ADAP_TYPE,
         .check_idle = &i2c_check_idle,
 };
@@ -616,11 +612,7 @@ static struct platform_device device_i2c0 = {
 #ifdef CONFIG_I2C1_RK30
 static struct rk30_i2c_platform_data default_i2c1_data = {
 	.bus_num = 1,
-#if defined(CONFIG_ARCH_RK3066B)
-	.is_div_from_arm = 0,
-#else
 	.is_div_from_arm = 1,
-#endif
 	.adap_type = I2C1_ADAP_TYPE,
         .check_idle = &i2c_check_idle,
 };
@@ -1315,6 +1307,12 @@ static int __init rk30_init_devices(void)
 	rk30_init_uart();
 	rk30_init_i2c();
 	rk30_init_spim();
+#ifdef CONFIG_MTD_NAND_RK29XX
+	platform_device_register(&device_nand);
+#endif
+#ifdef CONFIG_KEYS_RK29
+	platform_device_register(&device_keys);
+#endif
 #ifdef CONFIG_RGA_RK30
 	platform_device_register(&device_rga);
 #endif
@@ -1328,9 +1326,6 @@ static int __init rk30_init_devices(void)
 #ifdef CONFIG_ADC_RK30
 	platform_device_register(&device_adc);
 #endif
-#ifdef CONFIG_KEYS_RK29
-	platform_device_register(&device_keys);
-#endif
 #if !defined(CONFIG_ARCH_RK3066B)
 	platform_device_register(&device_tsadc);
 #endif
@@ -1346,9 +1341,6 @@ static int __init rk30_init_devices(void)
 	platform_device_register(&device_wdt);
 #endif
 	platform_device_register(&device_arm_pmu);
-#ifdef CONFIG_MTD_NAND_RK29XX
-	platform_device_register(&device_nand);
-#endif
 
 	return 0;
 }
diff --git a/arch/arm/mach-rk30/include/mach/rk30_camera.h b/arch/arm/mach-rk30/include/mach/rk30_camera.h
index 9ba83825861d..7cc7cb23e2d0 100755
--- a/arch/arm/mach-rk30/include/mach/rk30_camera.h
+++ b/arch/arm/mach-rk30/include/mach/rk30_camera.h
@@ -22,18 +22,17 @@
 #define __ASM_ARCH_CAMERA_RK30_H_
 
 #if defined(CONFIG_ARCH_RK3066B)
-#define RK29_CAM_DRV_NAME "rk3066b-camera"
+#define RK29_CAM_DRV_NAME "rk-camera-rk3066b"
 #define RK_SUPPORT_CIF0   1
 #define RK_SUPPORT_CIF1   0
 #elif defined(CONFIG_ARCH_RK30)
-#define RK29_CAM_DRV_NAME "rk30-camera"
+#define RK29_CAM_DRV_NAME "rk-camera-rk30"
 #define RK_SUPPORT_CIF0   1
 #define RK_SUPPORT_CIF1   1
 #endif
 
 #include <plat/rk_camera.h>
 
-#define CONFIG_CAMERA_INPUT_FMT_SUPPORT     (RK_CAM_INPUT_FMT_YUV422)
 #define CONFIG_CAMERA_SCALE_CROP_MACHINE    RK_CAM_SCALE_CROP_IPP
 
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_ARM)
diff --git a/arch/arm/plat-rk/include/plat/board.h b/arch/arm/plat-rk/include/plat/board.h
index 4d98dfd23e33..30a43455e1d5 100755
--- a/arch/arm/plat-rk/include/plat/board.h
+++ b/arch/arm/plat-rk/include/plat/board.h
@@ -111,13 +111,6 @@ struct gsensor_platform_data {
 	void (*exit_platform_hw)(void);
 };
 
-struct ft5606_platform_data {
-    int     (*get_pendown_state)(void);
-    int     (*init_platform_hw)(void);
-    int     (*platform_sleep)(void);
-    int     (*platform_wakeup)(void);
-    void    (*exit_platform_hw)(void);
-};
 
 struct akm8975_platform_data {
 	short m_layout[4][3][3];
diff --git a/arch/arm/plat-rk/include/plat/rk_camera.h b/arch/arm/plat-rk/include/plat/rk_camera.h
index 94cbdb2af1ec..57e5da2d43c7 100755
--- a/arch/arm/plat-rk/include/plat/rk_camera.h
+++ b/arch/arm/plat-rk/include/plat/rk_camera.h
@@ -160,10 +160,6 @@
 #define RK_CAM_SCALE_CROP_RGA      2
 #define RK_CAM_SCALE_CROP_PP       3
 
-#define RK_CAM_INPUT_FMT_YUV422    (1<<0)
-#define RK_CAM_INPUT_FMT_RAW10     (1<<1)
-#define RK_CAM_INPUT_FMT_RAW12     (1<<2)
-
 /* v4l2_subdev_core_ops.ioctl  ioctl_cmd macro */
 #define RK29_CAM_SUBDEV_ACTIVATE            0x00
 #define RK29_CAM_SUBDEV_DEACTIVATE          0x01
diff --git a/arch/arm/plat-rk/rk_camera.c b/arch/arm/plat-rk/rk_camera.c
index f8b8062ab8af..2347ca0fb5d6 100755
--- a/arch/arm/plat-rk/rk_camera.c
+++ b/arch/arm/plat-rk/rk_camera.c
@@ -311,7 +311,6 @@ static struct rk29camera_platform_data rk_camera_platform_data = {
     
     .gpio_res = {
         {
-    #if CONFIG_SENSOR_IIC_ADDR_0            
             .gpio_reset = CONFIG_SENSOR_RESET_PIN_0,
             .gpio_power = CONFIG_SENSOR_POWER_PIN_0,
             .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_0,
@@ -319,17 +318,7 @@ static struct rk29camera_platform_data rk_camera_platform_data = {
             .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_0|CONFIG_SENSOR_RESETACTIVE_LEVEL_0|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0|CONFIG_SENSOR_FLASHACTIVE_LEVEL_0),
             .gpio_init = 0,            
             .dev_name = SENSOR_DEVICE_NAME_0,
-   #else
-            .gpio_reset = INVALID_GPIO,
-            .gpio_power = INVALID_GPIO,
-            .gpio_powerdown = INVALID_GPIO,
-            .gpio_flash = INVALID_GPIO,
-            .gpio_flag = 0,
-            .gpio_init = 0,            
-            .dev_name = NULL,
-   #endif
         }, {
-   #if CONFIG_SENSOR_IIC_ADDR_1  
             .gpio_reset = CONFIG_SENSOR_RESET_PIN_1,
             .gpio_power = CONFIG_SENSOR_POWER_PIN_1,
             .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_1,
@@ -337,15 +326,6 @@ static struct rk29camera_platform_data rk_camera_platform_data = {
             .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_1|CONFIG_SENSOR_RESETACTIVE_LEVEL_1|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1|CONFIG_SENSOR_FLASHACTIVE_LEVEL_1),
             .gpio_init = 0,
             .dev_name = SENSOR_DEVICE_NAME_1,
-   #else
-            .gpio_reset = INVALID_GPIO,
-            .gpio_power = INVALID_GPIO,
-            .gpio_powerdown = INVALID_GPIO,
-            .gpio_flash = INVALID_GPIO,
-            .gpio_flag = 0,
-            .gpio_init = 0,            
-            .dev_name = NULL,
-   #endif
         }, 
         #ifdef CONFIG_SENSOR_01
         {
diff --git a/drivers/media/video/rk30_camera_oneframe.c b/drivers/media/video/rk30_camera_oneframe.c
index 9ea8180d3e36..2944951f344b 100755
--- a/drivers/media/video/rk30_camera_oneframe.c
+++ b/drivers/media/video/rk30_camera_oneframe.c
@@ -147,16 +147,6 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define ENABLE_32BIT_BYPASS                (0x01<<6)
 #define DISABLE_32BIT_BYPASS               (0x00<<6)
 
-
-#define MIN(x,y)   ((x<y) ? x: y)
-#define MAX(x,y)    ((x>y) ? x: y)
-#define RK_SENSOR_24MHZ      24*1000*1000          /* MHz */
-#define RK_SENSOR_48MHZ      48
-
-#define write_cif_reg(base,addr, val)  __raw_writel(val, addr+(base))
-#define read_cif_reg(base,addr) __raw_readl(addr+(base))
-#define mask_cif_reg(addr, msk, val)    write_cif_reg(addr, (val)|((~(msk))&read_cif_reg(addr)))
-
 #if defined(CONFIG_ARCH_RK30)
 //CRU,PIXCLOCK
 #define CRU_PCLK_REG30                     0xbc
@@ -170,34 +160,23 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MASK_RST_CIF1                      (0x01 << 31)
 #define RQUEST_RST_CIF0                    (0x01 << 14)
 #define RQUEST_RST_CIF1                    (0x01 << 15)
+#endif
 
+#define MIN(x,y)   ((x<y) ? x: y)
+#define MAX(x,y)    ((x>y) ? x: y)
+#define RK_SENSOR_24MHZ      24*1000*1000          /* MHz */
+#define RK_SENSOR_48MHZ      48
+
+#define write_cif_reg(base,addr, val)  __raw_writel(val, addr+(base))
+#define read_cif_reg(base,addr) __raw_readl(addr+(base))
+#define mask_cif_reg(addr, msk, val)    write_cif_reg(addr, (val)|((~(msk))&read_cif_reg(addr)))
+
+#if defined(CONFIG_ARCH_RK30)
 #define write_cru_reg(addr, val)  __raw_writel(val, addr+RK30_CRU_BASE)
 #define read_cru_reg(addr) __raw_readl(addr+RK30_CRU_BASE)
 #define mask_cru_reg(addr, msk, val)	write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
 #endif
 
-#if defined(CONFIG_ARCH_RK3066B)
-//GRF_IO_CON3                        0x100
-#define CIF_DRIVER_STRENGTH_2MA            (0x00 << 12)
-#define CIF_DRIVER_STRENGTH_4MA            (0x01 << 12)
-#define CIF_DRIVER_STRENGTH_8MA            (0x02 << 12)
-#define CIF_DRIVER_STRENGTH_12MA           (0x03 << 12)
-#define CIF_DRIVER_STRENGTH_MASK           (0x03 << 28)
-
-//GRF_IO_CON4                        0x104
-#define CIF_CLKOUT_AMP_3V3                 (0x00 << 10)
-#define CIF_CLKOUT_AMP_1V8                 (0x01 << 10)
-#define CIF_CLKOUT_AMP_MASK                (0x01 << 26)
-
-#define write_grf_reg(addr, val)  __raw_writel(val, addr+RK30_GRF_BASE)
-#define read_grf_reg(addr) __raw_readl(addr+RK30_GRF_BASE)
-#define mask_grf_reg(addr, msk, val)	write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
-#else
-#define write_grf_reg(addr, val)  
-#define read_grf_reg(addr)                0
-#define mask_grf_reg(addr, msk, val)	
-#endif
-
 #if defined(CONFIG_ARCH_RK2928)
 #define write_cru_reg(addr, val)  
 #define read_cru_reg(addr)                 0 
@@ -269,11 +248,9 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 		  3.fix bug in prob func:request mem twice. 
 		  4.video_vq may be null when reinit work,fix it
 		  5.arm scale algorithm has something wrong(may exceed the bound of width or height) ,fix it.
-*v0.x.15: 
-*         1. support rk3066b;
 
 */
-#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 2, 0x15)
+#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 2, 0x13)
 
 /* limit to rk29 hardware capabilities */
 #define RK_CAM_BUS_PARAM   (SOCAM_MASTER |\
@@ -649,9 +626,7 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
     struct soc_camera_device *icd = vq->priv_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct rk_camera_dev *pcdev = ici->priv;
-#if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
-#endif
 
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -1265,10 +1240,7 @@ static void rk_videobuf_release(struct videobuf_queue *vq,
     struct soc_camera_device *icd = vq->priv_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct rk_camera_dev *pcdev = ici->priv;
-#if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info =NULL;
-#endif
-
 #ifdef DEBUG
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -1413,7 +1385,6 @@ static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
 	clk_disable(pcdev->cif_clk_out);
     
 	clk_disable(pcdev->pd_cif);
- 
     return;
 }
 
@@ -1435,7 +1406,8 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
         goto ebusy;
     }
 
-    RKCAMERA_DG("%s driver attached to %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
+    dev_info(&icd->dev, "RK Camera driver attached to camera%d(%s)\n",
+             icd->devnum,dev_name(icd->pdev));
 
 	pcdev->frame_inval = RK_CAM_FRAME_INVAL_INIT;
     pcdev->active = NULL;
@@ -1496,15 +1468,14 @@ static void rk_camera_remove_device(struct soc_camera_device *icd)
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
     struct rk_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-#if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
     unsigned int i;
-#endif    
 
 	mutex_lock(&camera_lock);
     BUG_ON(icd != pcdev->icd);
 
-    RKCAMERA_DG("%s driver detached from %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
+    dev_info(&icd->dev, "RK Camera driver detached from camera%d(%s)\n",
+             icd->devnum,dev_name(icd->pdev));
 
 	/* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
 	   stream may be turn on again before close device, if suspend and resume happened. */
@@ -2712,9 +2683,8 @@ static int rk_camera_set_digit_zoom(struct soc_camera_device *icd,
 	struct v4l2_crop a;
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
 	struct rk_camera_dev *pcdev = ici->priv;
-#if CIF_DO_CROP    
 	unsigned long tmp_cifctrl; 
-#endif	
+	int flags;
 
 	//change the crop and scale parameters
 	
@@ -2860,35 +2830,18 @@ static void rk_camera_cif_iomux(int cif_index)
     switch(cif_index){
         case 0:
             rk30_mux_api_set(GPIO3B3_CIFCLKOUT_NAME, GPIO3B_CIFCLKOUT);
-            write_grf_reg(GRF_IO_CON3, (CIF_DRIVER_STRENGTH_MASK|CIF_DRIVER_STRENGTH_8MA));
-            write_grf_reg(GRF_IO_CON4, (CIF_CLKOUT_AMP_MASK|CIF_CLKOUT_AMP_1V8));
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        rk30_mux_api_set(GPIO3B4_CIFDATA0_HSADCDATA8_NAME, GPIO3B_CIFDATA0);
-	        rk30_mux_api_set(GPIO3B5_CIFDATA1_HSADCDATA9_NAME, GPIO3B_CIFDATA1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        rk30_mux_api_set(GPIO3B6_CIFDATA10_I2C3SDA_NAME, GPIO3B_CIFDATA10);
-	        rk30_mux_api_set(GPIO3B7_CIFDATA11_I2C3SCL_NAME, GPIO3B_CIFDATA11);
-            RKCAMERA_TR("%s(%d): WARNING: Cif 0 is configurated that support RAW 12bit, so I2C3 is invalidate!!\n",__FUNCTION__,__LINE__);
-            #endif
-            
+	    rk30_mux_api_set(GPIO3B4_CIFDATA0_HSADCDATA8_NAME, GPIO3B_CIFDATA0);
+	    rk30_mux_api_set(GPIO3B5_CIFDATA1_HSADCDATA9_NAME, GPIO3B_CIFDATA1);
+	    rk30_mux_api_set(GPIO3B6_CIFDATA10_I2C3SDA_NAME, GPIO3B_CIFDATA10);
+	    rk30_mux_api_set(GPIO3B7_CIFDATA11_I2C3SCL_NAME, GPIO3B_CIFDATA11);
             break;
         default:
-            RKCAMERA_TR("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
-    }
+            printk("cif index is erro!!!\n");
+        }
 #elif defined(CONFIG_ARCH_RK30)
     switch(cif_index){
         case 0:
             rk30_mux_api_set(GPIO1B3_CIF0CLKOUT_NAME, GPIO1B_CIF0_CLKOUT);
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        rk30_mux_api_set(GPIO1B4_CIF0DATA0_NAME, GPIO1B_CIF0_DATA0);
-	        rk30_mux_api_set(GPIO1B5_CIF0DATA1_NAME, GPIO1B_CIF0_DATA1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        rk30_mux_api_set(GPIO1B6_CIFDATA10_NAME, GPIO1B_CIF_DATA10);
-	        rk30_mux_api_set(GPIO1B7_CIFDATA11_NAME, GPIO1B_CIF_DATA11);
-            #endif
             break;
         case 1:
             rk30_mux_api_set(GPIO1C0_CIF1DATA2_RMIICLKOUT_RMIICLKIN_NAME,GPIO1C_CIF1_DATA2);
@@ -2910,9 +2863,9 @@ static void rk_camera_cif_iomux(int cif_index)
             rk30_mux_api_set(GPIO1D7_CIF1CLKOUT_NAME,GPIO1D_CIF1_CLKOUT);
             break;
         default:
-            RKCAMERA_TR("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
+            printk("cif index is erro!!!\n");
         }
+#else
 #endif
                 
             
@@ -2925,9 +2878,9 @@ static int rk_camera_probe(struct platform_device *pdev)
     struct rk29camera_mem_res *meminfo_ptr,*meminfo_ptrr;
     int irq,i;
     int err = 0;
+    static int ipp_mem = 0;
 
-    printk("%s version: v%d.%d.%d  Zoom by %s\n",RK29_CAM_DRV_NAME,(RK_CAM_VERSION_CODE&0xff0000)>>16,
-        (RK_CAM_VERSION_CODE&0xff00)>>8,RK_CAM_VERSION_CODE&0xff,CAMERA_SCALE_CROP_MACHINE);    
+    RKCAMERA_DG("%s(%d) Enter..\n",__FUNCTION__,__LINE__);    
 
     if ((pdev->id == RK_CAM_PLATFORM_DEV_ID_1) && (RK_SUPPORT_CIF1 == 0)) {
         RKCAMERA_TR("%s(%d): This chip is not support CIF1!!\n",__FUNCTION__,__LINE__);
@@ -3004,7 +2957,7 @@ static int rk_camera_probe(struct platform_device *pdev)
             }
             meminfo_ptr->vbase = pcdev->vipmem_virbase = ioremap_cached(meminfo_ptr->start,meminfo_ptr->size);
             if (pcdev->vipmem_virbase == NULL) {
-                RKCAMERA_TR("%s(%d): ioremap of CIF internal memory(Ex:IPP process/raw process) failed\n",__FUNCTION__,__LINE__);
+                dev_err(pcdev->dev, "ioremap() of vip internal memory(Ex:IPP process/raw process) failed\n");
                 err = -ENXIO;
                 goto exit_ioremap_vipmem;
             }
@@ -3203,6 +3156,7 @@ static struct platform_driver rk_camera_driver =
 
 static int rk_camera_init_async(void *unused)
 {
+    RKCAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
     platform_driver_register(&rk_camera_driver);
     return 0;
 }
diff --git a/drivers/media/video/soc_camera.c b/drivers/media/video/soc_camera.c
index 3f066f713a26..8e7219337450 100755
--- a/drivers/media/video/soc_camera.c
+++ b/drivers/media/video/soc_camera.c
@@ -1276,7 +1276,7 @@ static int soc_camera_probe(struct device *dev)
 	soc_camera_power_set(icd, icl, 0);
 
 	mutex_unlock(&icd->video_lock);
-    printk("Probe %s success\n", dev_name(icd->pdev));
+    dev_info(dev, "Probe %s success\n", dev_name(icd->pdev));
 	return 0;
 
 evidstart:
diff --git a/drivers/mfd/rk610-core.c b/drivers/mfd/rk610-core.c
index e83f2de8823e..d82e62783d30 100755
--- a/drivers/mfd/rk610-core.c
+++ b/drivers/mfd/rk610-core.c
@@ -10,9 +10,7 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 
-#if defined(CONFIG_ARCH_RK3066B)
-#define RK610_RESET_PIN   RK30_PIN2_PC5
-#elif defined(CONFIG_ARCH_RK30)
+#ifdef CONFIG_ARCH_RK30
 #define RK610_RESET_PIN   RK30_PIN0_PC6
 #else
 #define RK610_RESET_PIN   RK29_PIN6_PC1
@@ -221,13 +219,8 @@ static int rk610_control_probe(struct i2c_client *client,
         return -ENOMEM;
     }
     memset(core_info, 0, sizeof(struct rk610_core_info));
-		#if defined(CONFIG_SND_RK29_SOC_I2S_8CH)        
-        	iis_clk = clk_get_sys("rk29_i2s.0", "i2s");
-		#elif defined(CONFIG_SND_RK29_SOC_I2S_2CH)
-		iis_clk = clk_get_sys("rk29_i2s.1", "i2s");
-		#else
-        	iis_clk = clk_get_sys("rk29_i2s.2", "i2s");
-		#endif
+    
+		iis_clk = clk_get_sys("rk29_i2s.0", "i2s");
 		if (IS_ERR(iis_clk)) {
 			printk("failed to get i2s clk\n");
 			ret = PTR_ERR(iis_clk);
@@ -235,12 +228,10 @@ static int rk610_control_probe(struct i2c_client *client,
 			DBG("got i2s clk ok!\n");
 			clk_enable(iis_clk);
 			clk_set_rate(iis_clk, 11289600);
-			#if defined(CONFIG_ARCH_RK29)
+			#ifdef CONFIG_ARCH_RK29
 			rk29_mux_api_set(GPIO2D0_I2S0CLK_MIIRXCLKIN_NAME, GPIO2H_I2S0_CLK);
-			#elif defined(CONFIG_ARCH_RK3066B)
-			rk30_mux_api_set(GPIO1C0_I2SCLK_NAME, GPIO1C_I2SCLK);
-			#elif defined(CONFIG_ARCH_RK30)
-                        rk30_mux_api_set(GPIO0B0_I2S8CHCLK_NAME, GPIO0B_I2S_8CH_CLK);
+			#else
+			rk30_mux_api_set(GPIO0B0_I2S8CHCLK_NAME, GPIO0B_I2S_8CH_CLK);
 			#endif
 			clk_put(iis_clk);
 		}
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index ff84dfd8d9f5..b425fd61c4b2 100755
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -276,12 +276,6 @@ config REGULATOR_ACT8891
 	help
 	  Support the voltage and current regulators of the ACT8891 series of PMIC devices.
 
-config REGULATOR_ACT8931
-	tristate "Active Semi ACT8931 PMIC regulators"
-	depends on I2C
-	help
-	  Support the voltage and current regulators of the ACT8931 series of PMIC devices.
-
 config RK29_PWM_REGULATOR
 	tristate "rk2918 pwm voltage regulator"
 	help
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 6478b5be0d88..d4f86bae7bf9 100755
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -51,6 +51,5 @@ obj-$(CONFIG_REGULATOR_DB8500_PRCMU) += db8500-prcmu.o
 obj-$(CONFIG_REGULATOR_TPS65910) += tps65910-regulator.o
 obj-$(CONFIG_REGULATOR_TPS65912) += tps65912-regulator.o
 obj-$(CONFIG_REGULATOR_ACT8891) += act8891.o
-obj-$(CONFIG_REGULATOR_ACT8931) += act8931.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/act8931.c b/drivers/regulator/act8931.c
deleted file mode 100755
index ae0b45168aeb..000000000000
--- a/drivers/regulator/act8931.c
+++ /dev/null
@@ -1,637 +0,0 @@
-/*
- * Regulator driver for Active-semi act8931 PMIC chip for rk29xx
- *
- * Copyright (C) 2010, 2011 ROCKCHIP, Inc.
-
- * Based on act8891.c that is work by zhangqing<zhangqing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-#include <linux/bug.h>
-#include <linux/err.h>
-#include <linux/i2c.h>
-#include <linux/kernel.h>
-#include <linux/regulator/driver.h>
-#include <linux/regulator/act8931.h>
-#include <mach/gpio.h>
-#include <linux/delay.h>
-#include <mach/iomux.h>
-#include <linux/slab.h>
-
-#if 0
-#define DBG(x...)	printk(KERN_INFO x)
-#else
-#define DBG(x...)
-#endif
-#if 1
-#define DBG_INFO(x...)	printk(KERN_INFO x)
-#else
-#define DBG_INFO(x...)
-#endif
-#define PM_CONTROL
-
-struct act8931 {
-	struct device *dev;
-	struct mutex io_lock;
-	struct i2c_client *i2c;
-	int num_regulators;
-	struct regulator_dev **rdev;
-};
-
-static u8 act8931_reg_read(struct act8931 *act8931, u8 reg);
-static int act8931_set_bits(struct act8931 *act8931, u8 reg, u16 mask, u16 val);
-
-
-#define act8931_BUCK1_SET_VOL_BASE 0x20
-#define act8931_BUCK2_SET_VOL_BASE 0x30
-#define act8931_BUCK3_SET_VOL_BASE 0x40
-#define act8931_LDO1_SET_VOL_BASE 0x50
-#define act8931_LDO2_SET_VOL_BASE 0x54
-#define act8931_LDO3_SET_VOL_BASE 0x60
-#define act8931_LDO4_SET_VOL_BASE 0x64
-
-#define act8931_BUCK1_CONTR_BASE 0x22
-#define act8931_BUCK2_CONTR_BASE 0x32
-#define act8931_BUCK3_CONTR_BASE 0x42
-#define act8931_LDO1_CONTR_BASE 0x51
-#define act8931_LDO2_CONTR_BASE 0x55
-#define act8931_LDO3_CONTR_BASE 0x61
-#define act8931_LDO4_CONTR_BASE 0x65
-
-#define BUCK_VOL_MASK 0x3f
-#define LDO_VOL_MASK 0x3f
-
-#define VOL_MIN_IDX 0x00
-#define VOL_MAX_IDX 0x3f
-
-const static int buck_set_vol_base_addr[] = {
-	act8931_BUCK1_SET_VOL_BASE,
-	act8931_BUCK2_SET_VOL_BASE,
-	act8931_BUCK3_SET_VOL_BASE,
-};
-const static int buck_contr_base_addr[] = {
-	act8931_BUCK1_CONTR_BASE,
- 	act8931_BUCK2_CONTR_BASE,
- 	act8931_BUCK3_CONTR_BASE,
-};
-#define act8931_BUCK_SET_VOL_REG(x) (buck_set_vol_base_addr[x])
-#define act8931_BUCK_CONTR_REG(x) (buck_contr_base_addr[x])
-
-
-const static int ldo_set_vol_base_addr[] = {
-	act8931_LDO1_SET_VOL_BASE,
-	act8931_LDO2_SET_VOL_BASE,
-	act8931_LDO3_SET_VOL_BASE,
-	act8931_LDO4_SET_VOL_BASE, 
-};
-const static int ldo_contr_base_addr[] = {
-	act8931_LDO1_CONTR_BASE,
-	act8931_LDO2_CONTR_BASE,
-	act8931_LDO3_CONTR_BASE,
-	act8931_LDO4_CONTR_BASE,
-};
-#define act8931_LDO_SET_VOL_REG(x) (ldo_set_vol_base_addr[x])
-#define act8931_LDO_CONTR_REG(x) (ldo_contr_base_addr[x])
-
-const static int buck_voltage_map[] = {
-	 600, 625, 650, 675, 700, 725, 750, 775,
-	 800, 825, 850, 875, 900, 925, 950, 975,
-	 1000, 1025, 1050, 1075, 1100, 1125, 1150,
-	 1175, 1200, 1250, 1300, 1350, 1400, 1450,
-	 1500, 1550, 1600, 1650, 1700, 1750, 1800, 
-	 1850, 1900, 1950, 2000, 2050, 2100, 2150, 
-	 2200, 2250, 2300, 2350, 2400, 2500, 2600, 
-	 2700, 2800, 2850, 2900, 3000, 3100, 3200,
-	 3300, 3400, 3500, 3600, 3700, 3800, 3900,
-};
-
-const static int ldo_voltage_map[] = {
-	 600, 625, 650, 675, 700, 725, 750, 775,
-	 800, 825, 850, 875, 900, 925, 950, 975,
-	 1000, 1025, 1050, 1075, 1100, 1125, 1150,
-	 1175, 1200, 1250, 1300, 1350, 1400, 1450,
-	 1500, 1550, 1600, 1650, 1700, 1750, 1800, 
-	 1850, 1900, 1950, 2000, 2050, 2100, 2150, 
-	 2200, 2250, 2300, 2350, 2400, 2500, 2600, 
-	 2700, 2800, 2850, 2900, 3000, 3100, 3200,
-	 3300, 3400, 3500, 3600, 3700, 3800, 3900,
-};
-
-static int act8931_ldo_list_voltage(struct regulator_dev *dev, unsigned index)
-{
-	return 1000 * ldo_voltage_map[index];
-}
-static int act8931_ldo_is_enabled(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo = rdev_get_id(dev) -ACT8931_LDO1;
-	u16 val;
-	u16 mask=0x80;
-	val = act8931_reg_read(act8931, act8931_LDO_CONTR_REG(ldo));	 
-	if (val < 0)
-		return val;
-	val=val&~0x7f;
-	if (val & mask)
-		return 1;
-	else
-		return 0; 	
-}
-static int act8931_ldo_enable(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) -ACT8931_LDO1;
-	u16 mask=0x80;	
-	int ret;
-	return act8931_set_bits(act8931, act8931_LDO_CONTR_REG(ldo), mask, 0x80);
-	
-}
-static int act8931_ldo_disable(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) -ACT8931_LDO1;
-	u16 mask=0x80;
-	int ret;
-	return act8931_set_bits(act8931, act8931_LDO_CONTR_REG(ldo), mask, 0);
-
-}
-static int act8931_ldo_get_voltage(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) -ACT8931_LDO1;
-	u16 reg = 0;
-	int val;
-	reg = act8931_reg_read(act8931,act8931_LDO_SET_VOL_REG(ldo));
-	reg &= LDO_VOL_MASK;
-	val = 1000 * ldo_voltage_map[reg];	
-	return val;
-}
-static int act8931_ldo_set_voltage(struct regulator_dev *dev,
-				  int min_uV, int max_uV)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) -ACT8931_LDO1;
-	int min_vol = min_uV / 1000, max_vol = max_uV / 1000;
-	const int *vol_map =ldo_voltage_map;
-	u16 val;
-	int ret = 0;
-	if (min_vol < vol_map[VOL_MIN_IDX] ||
-	    min_vol > vol_map[VOL_MAX_IDX])
-		return -EINVAL;
-
-	for (val = VOL_MIN_IDX; val <= VOL_MAX_IDX;
-	     val++){
-		if (vol_map[val] >= min_vol)
-			break;	}
-		
-	if (vol_map[val] > max_vol)
-		return -EINVAL;
-
-	ret = act8931_set_bits(act8931, act8931_LDO_SET_VOL_REG(ldo),
-	       	LDO_VOL_MASK, val);
-	if (ret)
-		return ret;
-
-}
-static int act8931_ldo_get_mode(struct regulator_dev *dev, unsigned index)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo = rdev_get_id(dev) -ACT8931_LDO1 ;
-	u16 mask = 0xcf;
-	u16 val;
-	val = act8931_reg_read(act8931, act8931_LDO_CONTR_REG(ldo));
-	val=val|mask;
-	if (val== mask)
-		return REGULATOR_MODE_NORMAL;
-	else
-		return REGULATOR_MODE_STANDBY;
-
-}
-static int act8931_ldo_set_mode(struct regulator_dev *dev, unsigned int mode)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int ldo = rdev_get_id(dev) -ACT8931_LDO1 ;
-	u16 mask = 0x20;
-	switch(mode)
-	{
-	case REGULATOR_MODE_NORMAL:
-		return act8931_set_bits(act8931, act8931_LDO_CONTR_REG(ldo), mask, 0);		
-	case REGULATOR_MODE_STANDBY:
-		return act8931_set_bits(act8931, act8931_LDO_CONTR_REG(ldo), mask, mask);
-	default:
-		printk("error:pmu_act8931 only lowpower and nomal mode\n");
-		return -EINVAL;
-	}
-
-
-}
-static struct regulator_ops act8931_ldo_ops = {
-	.set_voltage = act8931_ldo_set_voltage,
-	.get_voltage = act8931_ldo_get_voltage,
-	.list_voltage = act8931_ldo_list_voltage,
-	.is_enabled = act8931_ldo_is_enabled,
-	.enable = act8931_ldo_enable,
-	.disable = act8931_ldo_disable,
-	.get_mode = act8931_ldo_get_mode,
-	.set_mode = act8931_ldo_set_mode,
-	
-};
-
-static int act8931_dcdc_list_voltage(struct regulator_dev *dev, unsigned index)
-{
-	return 1000 * buck_voltage_map[index];
-}
-static int act8931_dcdc_is_enabled(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1;
-	u16 val;
-	u16 mask=0x80;	
-	val = act8931_reg_read(act8931, act8931_BUCK_CONTR_REG(buck));
-	if (val < 0)
-		return val;
-	 val=val&~0x7f;
-	if (val & mask)
-		return 1;
-	else
-		return 0; 	
-}
-static int act8931_dcdc_enable(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	u16 mask=0x80;	
-	return act8931_set_bits(act8931, act8931_BUCK_CONTR_REG(buck), mask, 0x80);
-
-}
-static int act8931_dcdc_disable(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	u16 mask=0x80;
-	 return act8931_set_bits(act8931, act8931_BUCK_CONTR_REG(buck), mask, 0);
-}
-static int act8931_dcdc_get_voltage(struct regulator_dev *dev)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	u16 reg = 0;
-	int val;
-	reg = act8931_reg_read(act8931,act8931_BUCK_SET_VOL_REG(buck));
-	reg &= BUCK_VOL_MASK;
-        DBG("%d\n", reg);
-	val = 1000 * buck_voltage_map[reg];	
-        DBG("%d\n", val);
-	return val;
-}
-static int act8931_dcdc_set_voltage(struct regulator_dev *dev,
-				  int min_uV, int max_uV)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	int min_vol = min_uV / 1000, max_vol = max_uV / 1000;
-	const int *vol_map = buck_voltage_map;
-	u16 val;
-	int ret = 0;
-
-        DBG("%s, min_uV = %d, max_uV = %d!\n", __func__, min_uV, max_uV);
-	if (min_vol < vol_map[VOL_MIN_IDX] ||
-	    min_vol > vol_map[VOL_MAX_IDX])
-		return -EINVAL;
-
-	for (val = VOL_MIN_IDX; val <= VOL_MAX_IDX;
-	     val++){
-		if (vol_map[val] >= min_vol)
-			break;}
-
-	if (vol_map[val] > max_vol)
-		return -EINVAL;
-	ret = act8931_set_bits(act8931, act8931_BUCK_SET_VOL_REG(buck),
-	       	BUCK_VOL_MASK, val);
-	ret = act8931_set_bits(act8931, act8931_BUCK_SET_VOL_REG(buck) + 0x01,
-	       	BUCK_VOL_MASK, val);
-	//if (ret)
-		return ret;
-}
-static int act8931_dcdc_get_mode(struct regulator_dev *dev, unsigned index)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	u16 mask = 0xcf;
-	u16 val;
-	val = act8931_reg_read(act8931, act8931_BUCK_CONTR_REG(buck));
-	val=val|mask;
-	if (val== mask)
-		return REGULATOR_MODE_STANDBY;
-	else
-		return REGULATOR_MODE_NORMAL;
-
-}
-static int act8931_dcdc_set_mode(struct regulator_dev *dev, unsigned int mode)
-{
-	struct act8931 *act8931 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) -ACT8931_DCDC1 ;
-	u16 mask = 0x20;
-	switch(mode)
-	{
-	case REGULATOR_MODE_STANDBY:
-		return act8931_set_bits(act8931, act8931_BUCK_CONTR_REG(buck), mask, 0);
-	case REGULATOR_MODE_NORMAL:
-		return act8931_set_bits(act8931, act8931_BUCK_CONTR_REG(buck), mask, mask);
-	default:
-		printk("error:pmu_act8931 only powersave and pwm mode\n");
-		return -EINVAL;
-	}
-
-
-}
-static struct regulator_ops act8931_dcdc_ops = { 
-	.set_voltage = act8931_dcdc_set_voltage,
-	.get_voltage = act8931_dcdc_get_voltage,
-	.list_voltage= act8931_dcdc_list_voltage,
-	.is_enabled = act8931_dcdc_is_enabled,
-	.enable = act8931_dcdc_enable,
-	.disable = act8931_dcdc_disable,
-	.get_mode = act8931_dcdc_get_mode,
-	.set_mode = act8931_dcdc_set_mode,
-};
-static struct regulator_desc regulators[] = {
-	{
-		.name = "ACT_LDO1",
-		.id =0,
-		.ops = &act8931_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "ACT_LDO2",
-		.id = 1,
-		.ops = &act8931_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "ACT_LDO3",
-		.id = 2,
-		.ops = &act8931_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "ACT_LDO4",
-		.id = 3,
-		.ops = &act8931_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-
-	{
-		.name = "ACT_DCDC1",
-		.id = 4,
-		.ops = &act8931_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "ACT_DCDC2",
-		.id = 5,
-		.ops = &act8931_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "ACT_DCDC3",
-		.id = 6,
-		.ops = &act8931_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	
-};
-
-/*
- *
- */
-static int act8931_i2c_read(struct i2c_client *i2c, char reg, int count,	u16 *dest)
-{
-      int ret;
-    struct i2c_adapter *adap;
-    struct i2c_msg msgs[2];
-
-    if(!i2c)
-		return ret;
-
-	if (count != 1)
-		return -EIO;  
-  
-    adap = i2c->adapter;		
-    
-    msgs[0].addr = i2c->addr;
-    msgs[0].buf = &reg;
-    msgs[0].flags = i2c->flags;
-    msgs[0].len = 1;
-    msgs[0].scl_rate = 200*1000;
-    
-    msgs[1].buf = dest;
-    msgs[1].addr = i2c->addr;
-    msgs[1].flags = i2c->flags | I2C_M_RD;
-    msgs[1].len = 1;
-    msgs[1].scl_rate = 200*1000;
-    ret = i2c_transfer(adap, msgs, 2);
-
-	DBG("***run in %s %d msgs[1].buf = %d\n",__FUNCTION__,__LINE__,*(msgs[1].buf));
-
-	return 0;   
-}
-
-static int act8931_i2c_write(struct i2c_client *i2c, char reg, int count, const u16 src)
-{
-	int ret=-1;
-	
-	struct i2c_adapter *adap;
-	struct i2c_msg msg;
-	char tx_buf[2];
-
-	if(!i2c)
-		return ret;
-	if (count != 1)
-		return -EIO;
-    
-	adap = i2c->adapter;		
-	tx_buf[0] = reg;
-	tx_buf[1] = src;
-	
-	msg.addr = i2c->addr;
-	msg.buf = &tx_buf[0];
-	msg.len = 1 +1;
-	msg.flags = i2c->flags;   
-	msg.scl_rate = 200*1000;	
-
-	ret = i2c_transfer(adap, &msg, 1);
-	return 0;	
-}
-
-static u8 act8931_reg_read(struct act8931 *act8931, u8 reg)
-{
-	u16 val = 0;
-
-	mutex_lock(&act8931->io_lock);
-
-	act8931_i2c_read(act8931->i2c, reg, 1, &val);
-
-	DBG("reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)val&0xff);
-
-	mutex_unlock(&act8931->io_lock);
-
-	return val & 0xff;	
-}
-
-static int act8931_set_bits(struct act8931 *act8931, u8 reg, u16 mask, u16 val)
-{
-	u16 tmp;
-	int ret;
-
-	mutex_lock(&act8931->io_lock);
-
-	ret = act8931_i2c_read(act8931->i2c, reg, 1, &tmp);
-	DBG("1 reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)tmp&0xff);
-	tmp = (tmp & ~mask) | val;
-	if (ret == 0) {
-		ret = act8931_i2c_write(act8931->i2c, reg, 1, tmp);
-		DBG("reg write 0x%02x -> 0x%02x\n", (int)reg, (unsigned)val&0xff);
-	}
-	act8931_i2c_read(act8931->i2c, reg, 1, &tmp);
-	DBG("2 reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)tmp&0xff);
-	mutex_unlock(&act8931->io_lock);
-
-	return ret;	
-}
-static int __devinit setup_regulators(struct act8931 *act8931, struct act8931_platform_data *pdata)
-{	
-	int i, err;
-
-	act8931->num_regulators = pdata->num_regulators;
-	act8931->rdev = kcalloc(pdata->num_regulators,
-			       sizeof(struct regulator_dev *), GFP_KERNEL);
-	if (!act8931->rdev) {
-		return -ENOMEM;
-	}
-	/* Instantiate the regulators */
-	for (i = 0; i < pdata->num_regulators; i++) {
-		int id = pdata->regulators[i].id;
-		act8931->rdev[i] = regulator_register(&regulators[id],
-			act8931->dev, pdata->regulators[i].initdata, act8931);
-/*
-		if (IS_ERR(act8931->rdev[i])) {
-			err = PTR_ERR(act8931->rdev[i]);
-			dev_err(act8931->dev, "regulator init failed: %d\n",
-				err);
-			goto error;
-		}*/
-	}
-
-	return 0;
-error:
-	while (--i >= 0)
-		regulator_unregister(act8931->rdev[i]);
-	kfree(act8931->rdev);
-	act8931->rdev = NULL;
-	return err;
-}
-
-static int __devinit act8931_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
-{
-	struct act8931 *act8931;	
-	struct act8931_platform_data *pdata = i2c->dev.platform_data;
-	int ret;
-	act8931 = kzalloc(sizeof(struct act8931), GFP_KERNEL);
-	if (act8931 == NULL) {
-		ret = -ENOMEM;		
-		goto err;
-	}
-	act8931->i2c = i2c;
-	act8931->dev = &i2c->dev;
-	i2c_set_clientdata(i2c, act8931);
-	mutex_init(&act8931->io_lock);	
-	
-	if (pdata) {
-		ret = setup_regulators(act8931, pdata);
-		if (ret < 0)		
-			goto err;
-	} else
-		dev_warn(act8931->dev, "No platform init data supplied\n");
-	
-	pdata->set_init(act8931);
-
-	return 0;
-
-err:
-	return ret;	
-
-}
-
-static int __devexit act8931_i2c_remove(struct i2c_client *i2c)
-{
-	struct act8931 *act8931 = i2c_get_clientdata(i2c);
-	int i;
-
-	for (i = 0; i < act8931->num_regulators; i++)
-		if (act8931->rdev[i])
-			regulator_unregister(act8931->rdev[i]);
-	kfree(act8931->rdev);
-	i2c_set_clientdata(i2c, NULL);
-	kfree(act8931);
-
-	return 0;
-}
-
-static const struct i2c_device_id act8931_i2c_id[] = {
-       { "act8931", 0 },
-       { }
-};
-
-MODULE_DEVICE_TABLE(i2c, act8931_i2c_id);
-
-static struct i2c_driver act8931_i2c_driver = {
-	.driver = {
-		.name = "act8931",
-		.owner = THIS_MODULE,
-	},
-	.probe    = act8931_i2c_probe,
-	.remove   = __devexit_p(act8931_i2c_remove),
-	.id_table = act8931_i2c_id,
-};
-
-static int __init act8931_module_init(void)
-{
-	int ret;
-	ret = i2c_add_driver(&act8931_i2c_driver);
-	if (ret != 0)
-		pr_err("Failed to register I2C driver: %d\n", ret);
-	return ret;
-}
-//module_init(act8931_module_init);
-//subsys_initcall(act8931_module_init);
-//rootfs_initcall(act8931_module_init);
-subsys_initcall_sync(act8931_module_init);
-
-static void __exit act8931_module_exit(void)
-{
-	i2c_del_driver(&act8931_i2c_driver);
-}
-module_exit(act8931_module_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("xhc <xhc@rock-chips.com>");
-MODULE_DESCRIPTION("act8931 PMIC driver");
-
-
diff --git a/drivers/usb/dwc_otg/dwc_otg_cil.c b/drivers/usb/dwc_otg/dwc_otg_cil.c
index fefde8c8749f..87c0319494ca 100755
--- a/drivers/usb/dwc_otg/dwc_otg_cil.c
+++ b/drivers/usb/dwc_otg/dwc_otg_cil.c
@@ -211,6 +211,7 @@ dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t *_reg_base_addr,
 	core_if->srp_success = 0;
 	core_if->srp_timer_started = 0;
 
+	core_if->usb_wakeup = 0;
 //	if(dwc_core_if  ==  NULL)
              dwc_core_if = core_if;
 	return core_if;
@@ -3302,6 +3303,7 @@ void dwc_otg_dump_flags(dwc_otg_core_if_t *_core_if)
     DWC_PRINT("_______________________dwc_otg flags_______________________________\n");
 	DWC_PRINT("core_if->op_state = %x\n",_core_if->op_state);
 	DWC_PRINT("core_if->usb_mode = %x\n",_core_if->usb_mode);
+	DWC_PRINT("core_if->usb_wakeup = %x\n",_core_if->usb_wakeup);
 }
 
 #ifndef CONFIG_DWC_OTG_HOST_ONLY
diff --git a/drivers/usb/dwc_otg/dwc_otg_cil.h b/drivers/usb/dwc_otg/dwc_otg_cil.h
index f102c5919526..6dadebf09ad8 100755
--- a/drivers/usb/dwc_otg/dwc_otg_cil.h
+++ b/drivers/usb/dwc_otg/dwc_otg_cil.h
@@ -609,7 +609,10 @@ typedef struct dwc_otg_core_if
 	uint16_t rx_fifo_size;
 	/** Size of Non-periodic Tx FIFO (Bytes) */
 	uint16_t nperio_tx_fifo_size;
-
+		
+	/** 1 if wakeup in system sleep mode, 0 otherwise */
+	uint8_t usb_wakeup;
+	
 	/** 1 if DMA is enabled, 0 otherwise. */
 	uint8_t dma_enable;
 
diff --git a/drivers/usb/dwc_otg/dwc_otg_driver.c b/drivers/usb/dwc_otg/dwc_otg_driver.c
index d1b18821f0f9..df0d9bd40cb0 100755
--- a/drivers/usb/dwc_otg/dwc_otg_driver.c
+++ b/drivers/usb/dwc_otg/dwc_otg_driver.c
@@ -356,6 +356,8 @@ void dwc_otg_force_host(dwc_otg_core_if_t *core_if)
     	printk("dwc_otg_force_host,already in A_HOST mode,everest\n");
     	return;
     }
+    if(pldata->phy_suspend)
+        pldata->phy_suspend(pldata,USB_PHY_ENABLED);
     del_timer(&otg_dev->pcd->check_vbus_timer);
     // force disconnect 
     /* soft disconnect */
@@ -392,6 +394,7 @@ void dwc_otg_force_device(dwc_otg_core_if_t *core_if)
     otg_dev->core_if->op_state = B_PERIPHERAL;
 	/* Reset the Controller */
 	dwc_otg_core_reset( core_if );
+    //otg_dev->pcd->phy_suspend = 1;
     otg_dev->pcd->vbus_status = 0;
     dwc_otg_pcd_start_vbus_timer( otg_dev->pcd );
 	
@@ -431,11 +434,6 @@ static ssize_t force_usb_mode_store(struct device_driver *_drv, const char *_buf
     {
     	return _count;
     }
-    
-    if(pldata->phy_status==USB_PHY_SUSPEND){
-        pldata->clock_enable(pldata, 1);
-        pldata->phy_suspend(pldata,USB_PHY_ENABLED);
-    }
 
 	switch(new_mode)
 	{
@@ -484,6 +482,8 @@ static ssize_t force_usb_mode_store(struct device_driver *_drv, const char *_buf
 			if(USB_MODE_FORCE_DEVICE == core_if->usb_mode)
 			{
 				core_if->usb_mode = new_mode;
+                if(pldata->phy_suspend)
+                    pldata->phy_suspend(pldata,USB_PHY_ENABLED);
 				del_timer(&otg_dev->pcd->check_vbus_timer);
 				dwc_otg_set_gusbcfg(core_if, new_mode);
 				msleep(50);
@@ -502,6 +502,8 @@ static ssize_t force_usb_mode_store(struct device_driver *_drv, const char *_buf
 			}
 			else if(USB_MODE_FORCE_HOST == core_if->usb_mode)
 			{
+                if(pldata->phy_suspend)
+                    pldata->phy_suspend(pldata,USB_PHY_ENABLED);
 				core_if->usb_mode = new_mode;
 				dwc_otg_set_gusbcfg(core_if, new_mode);
 				msleep(100);
@@ -554,19 +556,16 @@ static ssize_t dwc_otg_enable_store( struct device *_dev,
         if (_core_if->hcd_cb && _core_if->hcd_cb->stop) {
                 _core_if->hcd_cb->stop( _core_if->hcd_cb->p );
         }
-        if(pldata->phy_status==USB_PHY_ENABLED){
+        if(pldata->phy_suspend)
             pldata->phy_suspend(pldata,USB_PHY_SUSPEND);
-            udelay(3);
-            pldata->clock_enable(pldata, 0);
-        }
+        udelay(3);
+        pldata->clock_enable(pldata, 0);
 	}
 	else if(val == 1)
 	{
 	    DWC_PRINT("enable host controller:%s\n",pdev->name);
-        if( pldata->phy_status == USB_PHY_SUSPEND ){ 
-            pldata->clock_enable( pldata, 1);		
-            pldata->phy_suspend(pldata, USB_PHY_ENABLED);
-        }
+        pldata->clock_enable(pldata, 1);
+        pldata->phy_suspend(pldata,USB_PHY_ENABLED);
         mdelay(5);
         if (_core_if->hcd_cb && _core_if->hcd_cb->start) {
                 _core_if->hcd_cb->start( _core_if->hcd_cb->p );
@@ -1160,9 +1159,6 @@ static __devinit int dwc_otg_driver_probe(struct platform_device *pdev)
 	struct dwc_otg_platform_data *pldata = dev->platform_data;
 
     // clock and hw init
-    if(pldata->hw_init)
-        pldata->hw_init();
-        
     if(pldata->soft_reset)
         pldata->soft_reset();
     
@@ -1171,6 +1167,8 @@ static __devinit int dwc_otg_driver_probe(struct platform_device *pdev)
         pldata->clock_enable(pldata, 1);
         }
 
+    if(pldata->hw_init)
+        pldata->hw_init();
     if(pldata->phy_suspend)
         pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 
@@ -1371,13 +1369,8 @@ static int dwc_otg_driver_suspend(struct platform_device *_dev , pm_message_t st
     /* Clear any pending interrupts */
     dwc_write_reg32( &core_if->core_global_regs->gintsts, 0xFFFFFFFF);
     dwc_otg_disable_global_interrupts(core_if);
-    if( pldata->phy_status == 0 ){ 
-        /* no vbus detect here , close usb phy  */
-        pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
-        udelay(3);
-        pldata->clock_enable( pldata, 0);		
-    }
-//    del_timer(&otg_dev->pcd->check_vbus_timer); 
+    pldata->phy_suspend(pldata,USB_PHY_SUSPEND);
+    del_timer(&otg_dev->pcd->check_vbus_timer); 
 	
     return 0;
 }
@@ -1403,6 +1396,32 @@ static int dwc_otg_driver_resume(struct platform_device *_dev )
     	DWC_PRINT("%s,A_HOST mode\n", __func__);
     	return 0;
     }
+#ifndef CONFIG_DWC_OTG_HOST_ONLY
+
+    pldata->phy_suspend(pldata,USB_PHY_ENABLED);
+
+    /* soft disconnect */
+    /* 20100226,HSL@RK,if not disconnect,when usb cable in,will auto reconnect 
+     *  besause now USB PHY is enable,and get USB RESET irq.
+    */
+    /* soft disconnect */
+    dctl.d32 = dwc_read_reg32( &core_if->dev_if->dev_global_regs->dctl );
+    dctl.b.sftdiscon = 1;
+    dwc_write_reg32( &core_if->dev_if->dev_global_regs->dctl, dctl.d32 );
+    
+    /* Clear any pending interrupts */
+    dwc_write_reg32( &global_regs->gintsts, 0xeFFFFFFF); 
+    
+    dwc_otg_enable_global_interrupts(core_if);
+    mod_timer(&otg_dev->pcd->check_vbus_timer , jiffies + HZ);
+
+//sendwakeup:        
+    if(core_if->usb_wakeup)
+    {
+        core_if->usb_wakeup = 0;
+    }
+    DWC_PRINT("%s gahbcfg:0x%x\n", __func__, global_regs->gahbcfg);
+#endif    
     return 0;
 }
 
@@ -1527,9 +1546,6 @@ static __devinit int host20_driver_probe(struct platform_device *pdev)
 	struct dwc_otg_platform_data *pldata = dev->platform_data;
     
     // clock and hw init
-    if(pldata->hw_init)
-        pldata->hw_init();
-        
     if(pldata->soft_reset)
         pldata->soft_reset();
     
@@ -1538,6 +1554,8 @@ static __devinit int host20_driver_probe(struct platform_device *pdev)
         pldata->clock_enable(pldata, 1);
         }
 
+    if(pldata->hw_init)
+        pldata->hw_init();
     if(pldata->phy_suspend)
         pldata->phy_suspend(pldata, USB_PHY_ENABLED);
 	/*
diff --git a/drivers/usb/dwc_otg/dwc_otg_hcd.c b/drivers/usb/dwc_otg/dwc_otg_hcd.c
index 5018584f64d8..acee5e211251 100755
--- a/drivers/usb/dwc_otg/dwc_otg_hcd.c
+++ b/drivers/usb/dwc_otg/dwc_otg_hcd.c
@@ -70,7 +70,7 @@ static int dwc_otg_hcd_suspend(struct usb_hcd *hcd)
     	DWC_PRINT("%s, usb device mode\n", __func__);
     	return 0;
     }
-    if(!(dwc_otg_hcd->host_enabled&1))
+    if(!dwc_otg_hcd->host_enabled)
         return 0;
     hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0);
 #ifdef CONFIG_USB_SUSPEND    
@@ -136,7 +136,7 @@ static int dwc_otg_hcd_resume(struct usb_hcd *hcd)
     	return 0;
     }
 //#ifdef CONFIG_USB_SUSPEND    
-    if(!(dwc_otg_hcd->host_enabled&1))
+    if(!dwc_otg_hcd->host_enabled)
         return 0;
 //#endif
 #ifndef CONFIG_DWC_REMOTE_WAKEUP
@@ -650,7 +650,7 @@ static void dwc_otg_hcd_enable(struct work_struct *work)
 	}
 	    
 	dwc_otg_hcd->host_enabled = dwc_otg_hcd->host_setenable;
-	if(dwc_otg_hcd->host_setenable == 2)    // enable -> disable
+	if(dwc_otg_hcd->host_setenable == 0)    // enable -> disable
 	{
 	    DWC_PRINT("%s, disable host controller\n", __func__);
 	    #if 1
@@ -698,11 +698,11 @@ static void dwc_otg_hcd_connect_detect(unsigned long pdata)
     else{
     // no device, suspend host
         if((dwc_read_reg32(core_if->host_if->hprt0) & 1) == 0)
-            dwc_otg_hcd->host_setenable = 2;
+            dwc_otg_hcd->host_setenable = 0;
     
     }
-    if((dwc_otg_hcd->host_enabled)&&(dwc_otg_hcd->host_setenable != dwc_otg_hcd->host_enabled)){
-        schedule_delayed_work(&dwc_otg_hcd->host_enable_work, 8);
+    if(dwc_otg_hcd->host_setenable != dwc_otg_hcd->host_enabled){
+    schedule_delayed_work(&dwc_otg_hcd->host_enable_work, 8);
     }
 //    dwc_otg_hcd->connect_detect_timer.expires = jiffies + (HZ<<1); /* 1 s */
     mod_timer(&dwc_otg_hcd->connect_detect_timer,jiffies + (HZ<<1)); 
diff --git a/drivers/usb/dwc_otg/dwc_otg_pcd.c b/drivers/usb/dwc_otg/dwc_otg_pcd.c
index 25dfd65c35e0..334882818001 100755
--- a/drivers/usb/dwc_otg/dwc_otg_pcd.c
+++ b/drivers/usb/dwc_otg/dwc_otg_pcd.c
@@ -1766,10 +1766,9 @@ static void dwc_otg_pcd_check_vbus_timer( unsigned long data )
 	local_irq_save(flags);
     _pcd->check_vbus_timer.expires = jiffies + (HZ); /* 1 s */
     if(!pldata->get_status(USB_STATUS_ID)){  // id low
-        if( pldata->phy_status){ 
-            pldata->clock_enable( pldata, 1);		
-            pldata->phy_suspend(pldata, USB_PHY_ENABLED);
-        } 
+    
+        if( pldata->phy_status) 
+             pldata->phy_suspend(pldata, USB_PHY_ENABLED);
     }
 	else if(pldata->get_status(USB_STATUS_BVABLID)){  // bvalid
         /* if usb not connect before ,then start connect */
@@ -1778,7 +1777,7 @@ static void dwc_otg_pcd_check_vbus_timer( unsigned long data )
     	    _pcd->vbus_status = 1;
             if(_pcd->conn_en)
                 goto connect;
-            else if( pldata->phy_status == USB_PHY_ENABLED ){
+            else{
                 // not connect, suspend phy
                 pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
                 udelay(3);
@@ -1797,11 +1796,9 @@ static void dwc_otg_pcd_check_vbus_timer( unsigned long data )
                 _pcd->vbus_status = 2;
                 
             // not connect, suspend phy
-            if( pldata->phy_status == USB_PHY_ENABLED ){
-                pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
-                udelay(3);
-                pldata->clock_enable( pldata, 0);
-            }
+            pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
+            udelay(3);
+            pldata->clock_enable( pldata, 0);
         }
 	}else {
         _pcd->vbus_status = 0;
@@ -1809,7 +1806,8 @@ static void dwc_otg_pcd_check_vbus_timer( unsigned long data )
              _pcd->conn_status = 0;
              dwc_otg_msc_unlock(_pcd);
         }
-        else if( pldata->phy_status == USB_PHY_ENABLED ){ 
+        /* every 500 ms open usb phy power and start 1 jiffies timer to get vbus */
+        else if( pldata->phy_status == 0 ){ 
             /* no vbus detect here , close usb phy  */
             pldata->phy_suspend(pldata, USB_PHY_SUSPEND);
             udelay(3);
@@ -1823,10 +1821,8 @@ static void dwc_otg_pcd_check_vbus_timer( unsigned long data )
 connect:
     if(_pcd->conn_status==0)
         dwc_otg_msc_lock(_pcd);
-    if( pldata->phy_status){
-        pldata->clock_enable( pldata, 1);	
-        pldata->phy_suspend(pldata, USB_PHY_ENABLED);
-    }
+    pldata->clock_enable( pldata, 1);	
+    pldata->phy_suspend(pldata, USB_PHY_ENABLED);
     schedule_delayed_work( &_pcd->reconnect , 8 ); /* delay 1 jiffies */
     _pcd->check_vbus_timer.expires = jiffies + (HZ<<1); /* 1 s */
     add_timer(&_pcd->check_vbus_timer); 
@@ -1972,7 +1968,7 @@ int dwc_otg_pcd_init(struct device *dev)
     pcd->vbus_status  = 0;
     pcd->phy_suspend  = 0;
     if(dwc_otg_is_device_mode(core_if))
-        mod_timer(&pcd->check_vbus_timer, jiffies+(HZ<<4)); // delay 16 S  
+        mod_timer(&pcd->check_vbus_timer, jiffies+(HZ<<2)); // delay 16 S  
 	return 0;
 }
 /**
diff --git a/drivers/usb/dwc_otg/usbdev_rk30.c b/drivers/usb/dwc_otg/usbdev_rk30.c
index 2c3adc8dd965..acf5e4d798f4 100755
--- a/drivers/usb/dwc_otg/usbdev_rk30.c
+++ b/drivers/usb/dwc_otg/usbdev_rk30.c
@@ -145,9 +145,11 @@ void usb20otg_phy_suspend(void* pdata, int suspend)
             usbpdata->phy_status = 0;
         }
 #endif
+
 }
 void usb20otg_soft_reset(void)
 {
+#if 1
     cru_set_soft_reset(SOFT_RST_USBOTG0, true);
     cru_set_soft_reset(SOFT_RST_USBPHY0, true);
     cru_set_soft_reset(SOFT_RST_OTGC0, true);
@@ -157,6 +159,7 @@ void usb20otg_soft_reset(void)
     cru_set_soft_reset(SOFT_RST_USBPHY0, false);
     cru_set_soft_reset(SOFT_RST_OTGC0, false);
     mdelay(1);
+#endif
 }
 void usb20otg_clock_init(void* pdata)
 {
@@ -170,7 +173,7 @@ void usb20otg_clock_init(void* pdata)
 void usb20otg_clock_enable(void* pdata, int enable)
 {
     struct dwc_otg_platform_data *usbpdata=pdata;
-
+    #if 1
     if(enable){
         clk_enable(usbpdata->ahbclk);
         clk_enable(usbpdata->phyclk);
@@ -179,6 +182,7 @@ void usb20otg_clock_enable(void* pdata, int enable)
         clk_disable(usbpdata->phyclk);
         clk_disable(usbpdata->ahbclk);
     }
+    #endif
 }
 int usb20otg_get_status(int id)
 {
@@ -254,9 +258,8 @@ struct dwc_otg_platform_data usb20otg_pdata = {
     .clock_init=usb20otg_clock_init,
     .clock_enable=usb20otg_clock_enable,
     .get_status=usb20otg_get_status,
-#ifdef CONFIG_ARCH_RK3066B
     .power_enable=usb20otg_power_enable,
-#endif    
+    
 };
 
 struct platform_device device_usb20_otg = {
@@ -328,6 +331,7 @@ void usb20host_phy_suspend(void* pdata, int suspend)
 }
 void usb20host_soft_reset(void)
 {
+#if 1
     cru_set_soft_reset(SOFT_RST_USBOTG1, true);
     cru_set_soft_reset(SOFT_RST_USBPHY1, true);
     cru_set_soft_reset(SOFT_RST_OTGC1, true);
@@ -337,6 +341,7 @@ void usb20host_soft_reset(void)
     cru_set_soft_reset(SOFT_RST_USBPHY1, false);
     cru_set_soft_reset(SOFT_RST_OTGC1, false);
     mdelay(1);
+#endif
 }
 void usb20host_clock_init(void* pdata)
 {
@@ -350,7 +355,7 @@ void usb20host_clock_init(void* pdata)
 void usb20host_clock_enable(void* pdata, int enable)
 {
     struct dwc_otg_platform_data *usbpdata=pdata;
-    
+    #if 1
     if(enable){
         clk_enable(usbpdata->ahbclk);
         clk_enable(usbpdata->phyclk);
@@ -359,6 +364,7 @@ void usb20host_clock_enable(void* pdata, int enable)
         clk_disable(usbpdata->phyclk);
         clk_disable(usbpdata->ahbclk);
     }
+    #endif
 }
 int usb20host_get_status(int id)
 {
@@ -435,9 +441,7 @@ struct dwc_otg_platform_data usb20host_pdata = {
     .clock_init=usb20host_clock_init,
     .clock_enable=usb20host_clock_enable,
     .get_status=usb20host_get_status,
-#ifdef CONFIG_ARCH_RK3066B
     .power_enable=usb20host_power_enable,
-#endif    
 };
 
 struct platform_device device_usb20_host = {
diff --git a/include/linux/regulator/act8931.h b/include/linux/regulator/act8931.h
deleted file mode 100755
index 2c1a34a2e181..000000000000
--- a/include/linux/regulator/act8931.h
+++ /dev/null
@@ -1,79 +0,0 @@
-
-/* include/linux/regulator/act8931.h
- *
- * Copyright (C) 2011 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#ifndef __LINUX_REGULATOR_act8931_H
-#define __LINUX_REGULATOR_act8931_H
-
-#include <linux/regulator/machine.h>
-
-//#define ACT8931_START 30
-
-#define ACT8931_LDO1  0                     //(0+ACT8931_START)
-#define ACT8931_LDO2  1                    // (1+ACT8931_START)
-#define ACT8931_LDO3  2                  //(2+ACT8931_START)
-#define ACT8931_LDO4  3                //(3+ACT8931_START)
-
-
-#define ACT8931_DCDC1 4                //(4+ACT8931_START)
-#define ACT8931_DCDC2 5                //(5+ACT8931_START)
-#define ACT8931_DCDC3 6                //(6+ACT8931_START)
-
-
-#define act8931_NUM_REGULATORS 7
-struct act8931;
-
-/*
- * Register definitions to all subdrivers
- */
-static u8 act8931_reg_read(struct act8931 *act8931, u8 reg);
-static int act8931_set_bits(struct act8931 *act8931, u8 reg, u16 mask, u16 val);
-
-
-#define act8931_BUCK1_SET_VOL_BASE 0x20
-#define act8931_BUCK2_SET_VOL_BASE 0x30
-#define act8931_BUCK3_SET_VOL_BASE 0x40
-#define act8931_LDO1_SET_VOL_BASE 0x50
-#define act8931_LDO2_SET_VOL_BASE 0x54
-#define act8931_LDO3_SET_VOL_BASE 0x60
-#define act8931_LDO4_SET_VOL_BASE 0x64
-
-#define act8931_BUCK1_CONTR_BASE 0x22
-#define act8931_BUCK2_CONTR_BASE 0x32
-#define act8931_BUCK3_CONTR_BASE 0x42
-#define act8931_LDO1_CONTR_BASE 0x51
-#define act8931_LDO2_CONTR_BASE 0x55
-#define act8931_LDO3_CONTR_BASE 0x61
-#define act8931_LDO4_CONTR_BASE 0x65
-
-#define BUCK_VOL_MASK 0x3f
-#define LDO_VOL_MASK 0x3f
-
-#define VOL_MIN_IDX 0x00
-#define VOL_MAX_IDX 0x3f
-
-struct act8931_regulator_subdev {
-	int id;
-	struct regulator_init_data *initdata;
-};
-
-struct act8931_platform_data {
-	int num_regulators;
-	int (*set_init)(struct act8931 *act8931);
-	struct act8931_regulator_subdev *regulators;
-};
-
-
-#endif
-
-- 
2.35.3

