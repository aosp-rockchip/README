From 41c28fac5bc816a3db51b7e5380b3d8c33061f6b Mon Sep 17 00:00:00 2001
From: Yao Xiao <xiaoyao@rock-chips.com>
Date: Fri, 20 Nov 2020 10:15:56 +0800
Subject: [PATCH] net: rockchip_wlan: update bcmdhd_indep_power to
 "1.579.77.41.26(r-20200429-2.3)(20201113-3)"

Signed-off-by: Yao Xiao <xiaoyao@rock-chips.com>
Change-Id: Icd686dae1fc089838dd03d721ad7b4fca41aa429
---
 .../rkwifi/bcmdhd_indep_power/Makefile        |   13 +-
 .../rkwifi/bcmdhd_indep_power/bcmsdh.c        |    9 +
 .../rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc.c  |   20 +-
 .../bcmdhd_indep_power/bcmsdh_sdmmc_linux.c   |    5 +-
 .../rkwifi/bcmdhd_indep_power/bcmstdlib_s.c   |  307 +
 .../rkwifi/bcmdhd_indep_power/dhd.h           |    9 +
 .../rkwifi/bcmdhd_indep_power/dhd_bus.h       |    5 +
 .../rkwifi/bcmdhd_indep_power/dhd_ccode.c     |  468 +-
 .../rkwifi/bcmdhd_indep_power/dhd_common.c    |  101 +-
 .../rkwifi/bcmdhd_indep_power/dhd_config.c    | 7763 +++++++++--------
 .../rkwifi/bcmdhd_indep_power/dhd_config.h    |   32 +-
 .../rkwifi/bcmdhd_indep_power/dhd_csi.c       |  221 +
 .../rkwifi/bcmdhd_indep_power/dhd_csi.h       |   78 +
 .../rkwifi/bcmdhd_indep_power/dhd_gpio.c      |    2 +-
 .../rkwifi/bcmdhd_indep_power/dhd_linux.c     |  170 +-
 .../bcmdhd_indep_power/dhd_linux_platdev.c    |    7 +
 .../rkwifi/bcmdhd_indep_power/dhd_pcie.c      |    2 +-
 .../bcmdhd_indep_power/dhd_pcie_linux.c       |    2 +-
 .../rkwifi/bcmdhd_indep_power/dhd_sdio.c      |  202 +-
 .../rkwifi/bcmdhd_indep_power/dhd_wlfc.c      |   39 +
 .../rkwifi/bcmdhd_indep_power/dhd_wlfc.h      |    7 +
 .../bcmdhd_indep_power/include/bcmevent.h     |    4 +
 .../bcmdhd_indep_power/include/bcmsdbus.h     |    4 +
 .../bcmdhd_indep_power/include/bcmsdh.h       |    3 +
 .../bcmdhd_indep_power/include/bcmsdh_sdmmc.h |    1 +
 .../bcmdhd_indep_power/include/bcmsdpcm.h     |    4 +
 .../bcmdhd_indep_power/include/bcmstdlib_s.h  |   46 +
 .../rkwifi/bcmdhd_indep_power/include/dbus.h  |    2 +-
 .../bcmdhd_indep_power/include/epivers.h      |    2 +-
 .../bcmdhd_indep_power/include/linux_osl.h    |    2 +-
 .../bcmdhd_indep_power/include/usbrdl.h       |    1 -
 .../bcmdhd_indep_power/include/wlioctl.h      |   89 +-
 .../bcmdhd_indep_power/include/wlioctl_defs.h |    4 +-
 .../rkwifi/bcmdhd_indep_power/linux_osl.c     |   13 +
 .../rkwifi/bcmdhd_indep_power/wl_android.h    |   24 +
 .../bcmdhd_indep_power/wl_android_ext.c       | 1197 ++-
 .../rkwifi/bcmdhd_indep_power/wl_cfg80211.c   | 1321 ++-
 .../rkwifi/bcmdhd_indep_power/wl_cfg80211.h   |   41 +-
 .../rkwifi/bcmdhd_indep_power/wl_cfgp2p.c     |   10 +-
 .../rkwifi/bcmdhd_indep_power/wl_cfgvendor.c  |    5 +
 .../rkwifi/bcmdhd_indep_power/wl_escan.c      |   84 +-
 .../rkwifi/bcmdhd_indep_power/wl_escan.h      |   13 +-
 .../rkwifi/bcmdhd_indep_power/wl_iw.c         |  187 +-
 43 files changed, 7536 insertions(+), 4983 deletions(-)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmstdlib_s.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmstdlib_s.h

diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/Makefile b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/Makefile
index 161880bd855d..d9e6f2da0ecd 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/Makefile
@@ -32,7 +32,7 @@ DHDCFLAGS = -Wall -Wstrict-prototypes -Dlinux -DBCMDRIVER                 \
 
 DHDOFILES = aiutils.o siutils.o sbutils.o bcmutils.o bcmwifi_channels.o   \
 	dhd_linux.o dhd_linux_platdev.o dhd_linux_sched.o dhd_pno.o           \
-	dhd_common.o dhd_ip.o dhd_linux_wq.o dhd_custom_gpio.o                \
+	dhd_common.o dhd_ip.o dhd_linux_wq.o dhd_custom_gpio.o bcmstdlib_s.o  \
 	bcmevent.o hndpmu.o linux_osl.o wldev_common.o wl_android.o bcmxtlv.o \
 	dhd_debug_linux.o dhd_debug.o dhd_mschdbg.o hnd_pktq.o hnd_pktpool.o  \
 	dhd_config.o dhd_ccode.o wl_event.o wl_android_ext.o wl_escan.o
@@ -54,6 +54,7 @@ ifneq ($(CONFIG_CFG80211),)
 	DHDCFLAGS += -DWLTDLS -DMIRACAST_AMPDU_SIZE=8
 	DHDCFLAGS += -DWL_VIRTUAL_APSTA
 	DHDCFLAGS += -DPNO_SUPPORT -DEXPLICIT_DISCIF_CLEANUP
+#	DHDCFLAGS += -DWL_CLIENT_SAE
 #	DHDCFLAGS += -DWL_SAE
 endif
 
@@ -63,7 +64,7 @@ DHDCFLAGS += -DBCMSDIO -DMMC_SDIO_ABORT -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR \
 	-DSDTEST -DBDC -DDHD_USE_IDLECOUNT -DCUSTOM_SDIO_F2_BLKSIZE=256       \
 	-DBCMSDIOH_TXGLOM -DBCMSDIOH_TXGLOM_EXT -DRXFRAME_THREAD              \
 	-DDHDENABLE_TAILPAD -DSUPPORT_P2P_GO_PS                               \
-	-DBCMSDIO_RXLIM_POST -DCONSOLE_DPC
+	-DBCMSDIO_RXLIM_POST -DBCMSDIO_TXSEQ_SYNC -DCONSOLE_DPC
 ifeq ($(CONFIG_BCMDHD_OOB),y)
 	DHDCFLAGS += -DOOB_INTR_ONLY -DCUSTOMER_OOB -DHW_OOB
 ifeq ($(CONFIG_BCMDHD_DISABLE_WOWLAN),y)
@@ -110,7 +111,7 @@ ifneq ($(CONFIG_BCMDHD_USB),)
 	DHDCFLAGS += -DPROP_TXSTATUS
 endif
 ifneq ($(CONFIG_BCMDHD_SDIO),)
-	DHDCFLAGS += -DPROP_TXSTATUS
+	DHDCFLAGS += -DPROP_TXSTATUS -DPROPTX_MAXCOUNT
 endif
 ifneq ($(CONFIG_CFG80211),)
 	DHDCFLAGS += -DPROP_TXSTATUS_VSDB
@@ -142,6 +143,12 @@ endif
 	DHDCFLAGS :=$(filter-out -DSET_RANDOM_MAC_SOFTAP,$(DHDCFLAGS))
 endif
 
+#CSI_SUPPORT
+ifneq ($(CONFIG_CSI_SUPPORT),)
+	DHDCFLAGS += -DCSI_SUPPORT
+	DHDOFILES += dhd_csi.o
+endif
+
 ifeq ($(CONFIG_LOAD_CHIPALIVE),y)
 	DHDCFLAGS += -DDHD_LOAD_CHIPALIVE -DISAM_PREINIT -DIDHCP -DGTK_OFFLOAD_SUPPORT
 	DHDCFLAGS += -DWL_EXT_TCPKA -DWL_EXT_WOWL -DSDIO_ISO_EXT
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh.c
index eafc2a014971..8cf899e457dc 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh.c
@@ -847,6 +847,15 @@ bcmsdh_set_mode(void *sdh, uint mode)
 	return (sdioh_set_mode(bcmsdh->sdioh, mode));
 }
 
+#ifdef PKT_STATICS
+uint32
+bcmsdh_get_spend_time(void *sdh) 
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *)sdh;
+	return (sdioh_get_spend_time(bcmsdh->sdioh));
+}
+#endif
+
 #ifdef DHD_LOAD_CHIPALIVE
 bool
 bcmsdh_get_sdmmc_sleep(void *sdh)
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc.c
index 026b3ab51306..7a93750107da 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc.c
@@ -1022,6 +1022,14 @@ sdioh_set_mode(sdioh_info_t *sd, uint mode)
 	return (sd->txglom_mode);
 }
 
+#ifdef PKT_STATICS
+uint32
+sdioh_get_spend_time(sdioh_info_t *sd)
+{
+	return (sd->sdio_spent_time_us);
+}
+#endif
+
 #ifdef DHD_LOAD_CHIPALIVE
 bool
 sdioh_get_sdmmc_sleep(sdioh_info_t *sd)
@@ -1153,7 +1161,9 @@ sdioh_request_packet_chain(sdioh_info_t *sd, uint fix_inc, uint write, uint func
 	DHD_PM_RESUME_WAIT(sdioh_request_packet_wait);
 	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
 
+#ifndef PKT_STATICS
 	if (sd_msglevel & SDH_COST_VAL)
+#endif
 		osl_do_gettimeofday(&before);
 
 	blk_size = sd->client_block_size[func];
@@ -1319,12 +1329,20 @@ sdioh_request_packet_chain(sdioh_info_t *sd, uint fix_inc, uint write, uint func
 	if (localbuf)
 		MFREE(sd->osh, localbuf, ttl_len);
 
-	if (sd_msglevel & SDH_COST_VAL) {
+#ifndef PKT_STATICS
+	if (sd_msglevel & SDH_COST_VAL)
+#endif
+	{
 		osl_do_gettimeofday(&now);
 		sd_cost(("%s: rw=%d, ttl_len=%d, cost=%lds %luus\n", __FUNCTION__,
 			write, ttl_len, now.tv_sec-before.tv_sec, now.tv_nsec/1000-before.tv_nsec/1000));
 	}
 
+#ifdef PKT_STATICS
+	if (write && (func == 2))
+		sd->sdio_spent_time_us = osl_do_gettimediff(&now, &before);
+#endif
+
 	sd_trace(("%s: Exit\n", __FUNCTION__));
 	return SDIOH_API_RC_SUCCESS;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc_linux.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc_linux.c
index 0286a8b9e3d9..2c54e390ae01 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmsdh_sdmmc_linux.c
@@ -194,10 +194,11 @@ static int bcmsdh_sdmmc_probe(struct sdio_func *func,
 	/* 4318 doesn't have function 2 */
 	if ((func->num == 2) || (func->num == 1 && func->device == 0x4)) {
 #ifdef DHD_LOAD_CHIPALIVE
-		if (!dhd_chip_alive)
-			dhd_chip_alive = func->card_alive;
+		dhd_chip_alive = func->card_alive;
 		printf("%s dhd_chip_alive=%d, id->alive=%d, func->num=%d\n", __FUNCTION__,
 			dhd_chip_alive, func->card_alive, func->num);
+		if (dhd_chip_alive)
+			dhd_download_fw_on_driverload = TRUE;
 #endif
 		ret = sdioh_probe(func);
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmstdlib_s.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmstdlib_s.c
new file mode 100644
index 000000000000..ba16e5a1537c
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/bcmstdlib_s.c
@@ -0,0 +1,307 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Broadcom Secure Standard Library.
+ *
+ * Copyright (C) 1999-2019, Broadcom.
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * $Id $
+ */
+
+#include <bcm_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#ifdef BCMDRIVER
+#include <osl.h>
+#else /* BCMDRIVER */
+#include <stddef.h>
+#include <string.h>
+#endif /* else BCMDRIVER */
+
+#include <bcmstdlib_s.h>
+#include <bcmutils.h>
+
+/*
+ * __SIZE_MAX__ value is depending on platform:
+ * Firmware Dongle: RAMSIZE (Dongle Specific Limit).
+ * LINUX NIC/Windows/MACOSX/Application: OS Native or
+ * 0xFFFFFFFFu if not defined.
+ */
+#ifndef SIZE_MAX
+#ifndef __SIZE_MAX__
+#define __SIZE_MAX__ 0xFFFFFFFFu
+#endif /* __SIZE_MAX__ */
+#define SIZE_MAX __SIZE_MAX__
+#endif /* SIZE_MAX */
+#define RSIZE_MAX (SIZE_MAX >> 1u)
+
+#if !defined(__STDC_WANT_SECURE_LIB__) && !(defined(__STDC_LIB_EXT1__) && \
+	defined(__STDC_WANT_LIB_EXT1__))
+/*
+ * memmove_s - secure memmove
+ * dest : pointer to the object to copy to
+ * destsz : size of the destination buffer
+ * src : pointer to the object to copy from
+ * n : number of bytes to copy
+ * Return Value : zero on success and non-zero on error
+ * Also on error, if dest is not a null pointer and destsz not greater
+ * than RSIZE_MAX, writes destsz zero bytes into the dest object.
+ */
+int
+memmove_s(void *dest, size_t destsz, const void *src, size_t n)
+{
+	int err = BCME_OK;
+
+	if ((!dest) || (((char *)dest + destsz) < (char *)dest)) {
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	if (destsz > RSIZE_MAX) {
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	if (destsz < n) {
+		memset(dest, 0, destsz);
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	if ((!src) || (((const char *)src + n) < (const char *)src)) {
+		memset(dest, 0, destsz);
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	memmove(dest, src, n);
+exit:
+	return err;
+}
+
+/*
+ * memcpy_s - secure memcpy
+ * dest : pointer to the object to copy to
+ * destsz : size of the destination buffer
+ * src : pointer to the object to copy from
+ * n : number of bytes to copy
+ * Return Value : zero on success and non-zero on error
+ * Also on error, if dest is not a null pointer and destsz not greater
+ * than RSIZE_MAX, writes destsz zero bytes into the dest object.
+ */
+int
+memcpy_s(void *dest, size_t destsz, const void *src, size_t n)
+{
+	int err = BCME_OK;
+	char *d = dest;
+	const char *s = src;
+
+	if ((!d) || ((d + destsz) < d)) {
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	if (destsz > RSIZE_MAX) {
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	if (destsz < n) {
+		memset(dest, 0, destsz);
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	if ((!s) || ((s + n) < s)) {
+		memset(dest, 0, destsz);
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	/* overlap checking between dest and src */
+	if (!(((d + destsz) <= s) || (d >= (s + n)))) {
+		memset(dest, 0, destsz);
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	(void)memcpy(dest, src, n);
+exit:
+	return err;
+}
+
+/*
+ * memset_s - secure memset
+ * dest : pointer to the object to be set
+ * destsz : size of the destination buffer
+ * c : byte value
+ * n : number of bytes to be set
+ * Return Value : zero on success and non-zero on error
+ * Also on error, if dest is not a null pointer and destsz not greater
+ * than RSIZE_MAX, writes destsz bytes with value c into the dest object.
+ */
+int
+memset_s(void *dest, size_t destsz, int c, size_t n)
+{
+	int err = BCME_OK;
+	if ((!dest) || (((char *)dest + destsz) < (char *)dest)) {
+		err = BCME_BADARG;
+		goto exit;
+	}
+
+	if (destsz > RSIZE_MAX) {
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	if (destsz < n) {
+		(void)memset(dest, c, destsz);
+		err = BCME_BADLEN;
+		goto exit;
+	}
+
+	(void)memset(dest, c, n);
+exit:
+	return err;
+}
+#endif /* !__STDC_WANT_SECURE_LIB__ && !(__STDC_LIB_EXT1__ && __STDC_WANT_LIB_EXT1__) */
+
+#if 0
+/**
+ * strlcpy - Copy a %NUL terminated string into a sized buffer
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @size: size of destination buffer 0 if input parameters are NOK
+ * return: string leng of src (assume src is NUL terminated)
+ *
+ * Compatible with *BSD: the result is always a valid
+ * NUL-terminated string that fits in the buffer (unless,
+ * of course, the buffer size is zero). It does not pad
+ * out the result like strncpy() does.
+ */
+size_t strlcpy(char *dest, const char *src, size_t size)
+{
+	const char *s = src;
+	size_t n;
+
+	if (dest == NULL) {
+		return 0;
+	}
+
+	/* terminate dest if src is NULL and return 0 as only NULL was added */
+	if (s == NULL) {
+		*dest = '\0';
+		return 0;
+	}
+
+	/* allows us to handle size 0 */
+	if (size == 0) {
+		n = 0;
+	} else {
+		n = size - 1u;
+	}
+
+	/* perform copy */
+	while (*s && n != 0) {
+		*dest++ = *s++;
+		n--;
+	}
+
+	*dest = '\0';
+
+	/* count to end of s or compensate for NULL */
+	if (n == 0) {
+		while (*s++)
+			;
+	} else {
+		s++;
+	}
+
+	/* return bytes copied not accounting NUL */
+	return (s - src - 1u);
+}
+#endif // endif
+
+/**
+ * strlcat_s - Concatenate a %NUL terminated string with a sized buffer
+ * @dest: Where to concatenate the string to
+ * @src: Where to copy the string from
+ * @size: size of destination buffer
+ * return: string length of created string (i.e. the initial length of dest plus the length of src)
+ *         not including the NUL char, up until size
+ *
+ * Unlike strncat(), strlcat() take the full size of the buffer (not just the number of bytes to
+ * copy) and guarantee to NUL-terminate the result (even when there's nothing to concat).
+ * If the length of dest string concatinated with the src string >= size, truncation occurs.
+ *
+ * Compatible with *BSD: the result is always a valid NUL-terminated string that fits in the buffer
+ * (unless, of course, the buffer size is zero).
+ *
+ * If either src or dest is not NUL-terminated, dest[size-1] will be set to NUL.
+ * If size < strlen(dest) + strlen(src), dest[size-1] will be set to NUL.
+ * If size == 0, dest[0] will be set to NUL.
+ */
+size_t
+strlcat_s(char *dest, const char *src, size_t size)
+{
+	char *d = dest;
+	const char *s = src;	/* point to the start of the src string */
+	size_t n = size;
+	size_t dlen;
+	size_t bytes_to_copy = 0;
+
+	if (dest == NULL) {
+		return 0;
+	}
+
+	/* set d to point to the end of dest string (up to size) */
+	while (n != 0 && *d != '\0') {
+		d++;
+		n--;
+	}
+	dlen = (size_t)(d - dest);
+
+	if (s != NULL) {
+		size_t slen = 0;
+
+		/* calculate src len in case it's not null-terminated */
+		n = size;
+		while (n-- != 0 && *(s + slen) != '\0') {
+			++slen;
+		}
+
+		n = size - dlen;	/* maximum num of chars to copy */
+		if (n != 0) {
+			/* copy relevant chars (until end of src buf or given size is reached) */
+			bytes_to_copy = MIN(slen - (size_t)(s - src), n - 1);
+			(void)memcpy(d, s, bytes_to_copy);
+			d += bytes_to_copy;
+		}
+	}
+	if (n == 0 && dlen != 0) {
+		--d;	/* nothing to copy, but NUL-terminate dest anyway */
+	}
+	*d = '\0';	/* NUL-terminate dest */
+
+	return (dlen + bytes_to_copy);
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd.h
index 1613d74cd458..a6367151f533 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd.h
@@ -1038,6 +1038,10 @@ typedef struct dhd_pub {
 #if defined(STAT_REPORT)
 	void *stat_report_info;
 #endif
+#ifdef CSI_SUPPORT
+	struct list_head csi_list;
+	int csi_count;
+#endif /* CSI_SUPPORT */
 	char *clm_path;		/* module_param: path to clm vars file */
 	char *conf_path;		/* module_param: path to config vars file */
 	struct dhd_conf *conf;	/* Bus module handle */
@@ -1059,6 +1063,11 @@ typedef struct dhd_pub {
 #ifdef SENDPROB
 	bool recv_probereq;
 #endif
+#ifdef HOST_TPUT_TEST
+	struct osl_timespec bus_ts;
+	struct osl_timespec net_ts;
+	uint32 net_len;
+#endif
 } dhd_pub_t;
 
 typedef struct {
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_bus.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_bus.h
index 15d441c09bd8..879a45380e6f 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_bus.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_bus.h
@@ -116,6 +116,11 @@ extern void dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf);
 /* Clear any bus counters */
 extern void dhd_bus_clearcounts(dhd_pub_t *dhdp);
 
+#if defined(BCMSDIO) && defined(PKT_STATICS)
+extern void dhd_bus_dump_txpktstatics(struct dhd_bus *bus);
+extern void dhd_bus_clear_txpktstatics(struct dhd_bus *bus);
+#endif
+
 /* return the dongle chipid */
 extern uint dhd_bus_chip(struct dhd_bus *bus);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_ccode.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_ccode.c
index d504b1fbcec1..9741c6ecdece 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_ccode.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_ccode.c
@@ -1,235 +1,235 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-
-#ifdef CCODE_LIST
-#ifdef CONFIG_COMPAT
-#include <linux/compat.h>
-#endif /* CONFIG COMPAT */
-#include <typedefs.h>
-#include <dhd_config.h>
-
-#ifdef BCMSDIO
-#define CCODE_43438
-#define CCODE_43455C0
-#define CCODE_43456C5
-#endif
-#if defined(BCMSDIO) || defined(BCMPCIE)
-#define CCODE_4356A2
-#define CCODE_4359C0
-#endif
-#ifdef BCMDBUS
-#define CCODE_4358U
-#endif
-
-#ifdef BCMSDIO
-#ifdef CCODE_43438
-const char ccode_43438[] = "RU/13";
-#else
-const char ccode_43438 = "";
-#endif
-
-#ifdef CCODE_43455C0
-const char ccode_43455c0[] = \
-"AE/6 AG/2 AI/1 AL/2 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
-"BA/2 BD/1 BE/4 BG/4 BH/4 BM/12 BN/4 BR/2 BS/2 BY/3 "\
-"CA/2 CA/31 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
-"DE/3 DE/7 DK/4 "\
-"EC/21 EE/4 EG/13 ES/4 ET/2 "\
-"FI/4 FR/5 "\
-"GB/1 GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/30 "\
-"HK/2 HR/4 HU/4 "\
-"ID/1 IE/5 IL/14 IN/3 IS/4 IT/4 "\
-"JO/3 JP/45 JP/58 "\
-"KH/2 KR/45 KR/48 KR/49 KR/70 KR/71 KR/96 KW/5 KY/3 "\
-"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
-"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MQ/2 MR/2 MT/4 MU/2 MV/3 MW/1 MX/44 MY/3 "\
-"NI/2 NL/4 NO/4 NZ/4 "\
-"OM/4 "\
-"PA/17 PE/20 PH/5 PL/4 PR/38 PT/4 PY/2 "\
-"Q2/993 "\
-"RE/2 RO/4 RS/2 RU/13 "\
-"SE/4 SI/4 SK/4 SV/25 "\
-"TH/5 TN/1 TR/7 TT/3 TW/1 "\
-"UA/8 US/988 "\
-"VA/2 VE/3 VG/2 VN/4 "\
-"XZ/11 "\
-"YT/2 "\
-"ZA/6";
-#else
-const char ccode_43455c0[] = "";
-#endif
-
-#ifdef CCODE_43456C5
-const char ccode_43456c5[] = \
-"AE/6 AG/2 AI/1 AL/2 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
-"BA/2 BD/1 BE/4 BG/4 BH/4 BM/12 BN/4 BR/4 BS/2 BY/3 "\
-"CA/2 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
-"DE/7 DK/4 "\
-"EC/21 EE/4 EG/13 ES/4 ET/2 "\
-"FI/4 FR/5 "\
-"GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/30 "\
-"HK/2 HR/4 HU/4 "\
-"ID/1 IE/5 IL/14 IN/3 IS/4 IT/4 "\
-"JO/3 JP/58 "\
-"KH/2 KR/96 KW/5 KY/3 "\
-"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
-"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MQ/2 MR/2 MT/4 MU/2 MV/3 MW/1 MX/44 MY/3 "\
-"NI/2 NL/4 NO/4 NZ/4 "\
-"OM/4 "\
-"PA/17 PE/20 PH/5 PL/4 PR/38 PT/4 PY/2 "\
-"Q2/993 "\
-"RE/2 RO/4 RS/2 RU/13 "\
-"SE/4 SI/4 SK/4 SV/25 "\
-"TH/5 TN/1 TR/7 TT/3 TW/65 "\
-"UA/8 US/988 "\
-"VA/2 VE/3 VG/2 VN/4 "\
-"XZ/11 "\
-"YT/2 "\
-"ZA/6";
-#else
-const char ccode_43456c5[] = "";
-#endif
-#endif
-
-#ifdef CCODE_4356A2
-const char ccode_4356a2[] = \
-"AE/6 AG/2 AI/1 AL/2 AN/2 AR/21 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
-"BA/2 BD/2 BE/4 BG/4 BH/4 BM/12 BN/4 BR/4 BS/2 BY/3 "\
-"CA/31 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
-"DE/7 DK/4 DZ/1 "\
-"EC/21 EE/4 ES/4 ET/2 "\
-"FI/4 FR/5 "\
-"GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/12 "\
-"HK/2 HR/4 HU/4 "\
-"ID/13 IE/5 IL/7 IN/28 IS/4 IT/4 "\
-"JO/3 JP/58 "\
-"KH/2 KR/57 KW/5 KY/3 "\
-"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
-"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MO/2 MR/2 MT/4 MQ/2 MU/2 MV/3 MW/1 MX/20 MY/16 "\
-"NI/2 NL/4 NO/4 NP/3 NZ/4 "\
-"OM/4 "\
-"PA/17 PE/20 PG/2 PH/5 PL/4 PR/20 PT/4 PY/2 "\
-"RE/2 RO/4 RS/2 RU/986 "\
-"SE/4 SG/4 SG/19 SI/4 SK/4 SN/2 SV/19 "\
-"TH/9 TN/1 TR/7 TT/3 TW/1 "\
-"UA/8 UG/2 US/1 UY/1 "\
-"VA/2 UA/16 VE/3 VG/2 VI/13 VN/4 "\
-"XZ/11 "\
-"YT/2 "\
-"ZM/2 "\
-"E0/32";
-#else
-const char ccode_4356a2[] = "";
-#endif
-
-#ifdef CCODE_4359C0
-const char ccode_4359c0[] = \
-"AD/1 AE/6 AG/2 AI/1 AL/3 AS/12 AT/21 AU/6 AW/2 AZ/8 "\
-"BA/4 BD/1 BE/19 BG/18 BH/4 BM/12 BN/4 BR/2 BS/2 BY/3 "\
-"CN/38 CO/17 CR/17 CY/18 CZ/18 "\
-"DE/30 DK/19 "\
-"E0/32 EC/21 EE/18 EG/13 ES/21 ET/2 "\
-"FI/19 FR/21 "\
-"GB/996 GD/2 GE/1 GF/2 GP/2 GR/18 GT/1 GU/30 "\
-"HK/2 HR/18 HU/18 "\
-"ID/1 IE/21 IL/14 IN/3 IS/17 IT/20 "\
-"JO/3 JP/967 "\
-"KH/2 KR/70 KW/5 KY/3 "\
-"LA/2 LB/5 LI/17 LI/4 LK/1 LS/2 LT/18 LU/18 LV/18 "\
-"MA/2 MC/2 MD/3 ME/5 MK/4 MN/1 MQ/2 MR/2 MT/18 MU/2 MV/3 MW/1 MX/44 MY/3 "\
-"NI/2 NL/19 NO/18 NZ/4 "\
-"OM/4 "\
-"PA/17 PE/20 PH/5 PL/18 PR/38 PT/20 PY/2 "\
-"Q1/947 Q2/993 "\
-"RE/2 RO/18 RS/4 RU/986 "\
-"SE/19 SI/18 SK/18 SM/1 SV/25 "\
-"TH/5 TN/1 TR/18 TT/3 TW/1 "\
-"UA/16 US/988 "\
-"VA/3 VE/3 VG/2 VN/4 "\
-"XZ/11 "\
-"YT/2 "\
-"ZA/6";
-#else
-const char ccode_4359c0[] = "";
-#endif
-
-#ifdef CCODE_4358U
-const char ccode_4358u[] = \
-"BE/4 BR/4 CA/2 CH/4 CN/38 CY/4 DE/7 DK/4 ES/4 "\
-"FI/4 FR/5 GB/6 GR/4 HK/2 HU/4 IE/5 IL/7 IS/4 "\
-"IT/4 JP/72 KE/0 MY/3 NL/4 PT/4 SA/5 SE/4 SG/0 "\
-"SZ/0 TH/5 TR/7 TW/230 US/0 VN/4";
-#else
-const char ccode_4358u[] = "";
-#endif
-
-typedef struct ccode_list_map_t {
-	uint chip;
-	uint chiprev;
-	const char *ccode_list;
-	const char *ccode_ww;
-} ccode_list_map_t;
-
-extern const char ccode_43438[];
-extern const char ccode_43455c0[];
-extern const char ccode_43456c5[];
-extern const char ccode_4356a2[];
-extern const char ccode_4359c0[];
-extern const char ccode_4358u[];
-
-const ccode_list_map_t ccode_list_map[] = {
-	/* ChipID		Chiprev		ccode  */
-#ifdef BCMSDIO
-	{BCM43430_CHIP_ID,	0,	ccode_43438, ""},
-	{BCM43430_CHIP_ID,	1,	ccode_43438, ""},
-	{BCM4345_CHIP_ID,	6,	ccode_43455c0, "XZ/11"},
-	{BCM43454_CHIP_ID,	6,	ccode_43455c0, "XZ/11"},
-	{BCM4345_CHIP_ID,	9,	ccode_43456c5, "XZ/11"},
-	{BCM43454_CHIP_ID,	9,	ccode_43456c5, "XZ/11"},
-	{BCM4354_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
-	{BCM4356_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
-	{BCM4371_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
-	{BCM4359_CHIP_ID,	9,	ccode_4359c0, "XZ/11"},
-#endif
-#ifdef BCMPCIE
-	{BCM4354_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
-	{BCM4356_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
-	{BCM4359_CHIP_ID,	9,	ccode_4359c0, "XZ/11"},
-#endif
-#ifdef BCMDBUS
-	{BCM43569_CHIP_ID,	2,	ccode_4358u, "XW/0"},
-#endif
-};
-
-int
-dhd_ccode_map_country_list(dhd_pub_t *dhd, wl_country_t *cspec)
-{
-	int bcmerror = -1, i;
-	uint chip = dhd->conf->chip, chiprev = dhd->conf->chiprev; 
-	const char *ccode_list = NULL, *ccode_ww = NULL;
-	char *pch;
-
-	for (i=0;  i<sizeof(ccode_list_map)/sizeof(ccode_list_map[0]);  i++) {
-		const ccode_list_map_t* row = &ccode_list_map[i];
-		if (row->chip == chip && row->chiprev == chiprev) {
-			ccode_list = row->ccode_list;
-			ccode_ww = row->ccode_ww;
-			break;
-		}
-	}
-
-	if (ccode_list) {
-		pch = strstr(ccode_list, cspec->ccode);
-		if (pch) {
-			cspec->rev = (int)simple_strtol(pch+strlen(cspec->ccode)+1, NULL, 0);
-			bcmerror = 0;
-		}
-	}
-
-	if (bcmerror && ccode_ww && strlen(ccode_ww)>=4) {
-		memcpy(cspec->ccode, ccode_ww, 2);
-		cspec->rev = (int)simple_strtol(ccode_ww+3, NULL, 0);
-	}
-
-	return bcmerror;
-}
-#endif
+
+#ifdef CCODE_LIST
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif /* CONFIG COMPAT */
+#include <typedefs.h>
+#include <dhd_config.h>
+
+#ifdef BCMSDIO
+#define CCODE_43438
+#define CCODE_43455C0
+#define CCODE_43456C5
+#endif
+#if defined(BCMSDIO) || defined(BCMPCIE)
+#define CCODE_4356A2
+#define CCODE_4359C0
+#endif
+#ifdef BCMDBUS
+#define CCODE_4358U
+#endif
+
+#ifdef BCMSDIO
+#ifdef CCODE_43438
+const char ccode_43438[] = "RU/13";
+#else
+const char ccode_43438 = "";
+#endif
+
+#ifdef CCODE_43455C0
+const char ccode_43455c0[] = \
+"AE/6 AG/2 AI/1 AL/2 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
+"BA/2 BD/1 BE/4 BG/4 BH/4 BM/12 BN/4 BR/2 BS/2 BY/3 "\
+"CA/2 CA/31 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
+"DE/3 DE/7 DK/4 "\
+"EC/21 EE/4 EG/13 ES/4 ET/2 "\
+"FI/4 FR/5 "\
+"GB/1 GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/30 "\
+"HK/2 HR/4 HU/4 "\
+"ID/1 IE/5 IL/14 IN/3 IS/4 IT/4 "\
+"JO/3 JP/45 JP/58 "\
+"KH/2 KR/45 KR/48 KR/49 KR/70 KR/71 KR/96 KW/5 KY/3 "\
+"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
+"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MQ/2 MR/2 MT/4 MU/2 MV/3 MW/1 MX/44 MY/3 "\
+"NI/2 NL/4 NO/4 NZ/4 "\
+"OM/4 "\
+"PA/17 PE/20 PH/5 PL/4 PR/38 PT/4 PY/2 "\
+"Q2/993 "\
+"RE/2 RO/4 RS/2 RU/13 "\
+"SE/4 SI/4 SK/4 SV/25 "\
+"TH/5 TN/1 TR/7 TT/3 TW/65 "\
+"UA/8 US/988 "\
+"VA/2 VE/3 VG/2 VN/4 "\
+"XZ/11 "\
+"YT/2 "\
+"ZA/6";
+#else
+const char ccode_43455c0[] = "";
+#endif
+
+#ifdef CCODE_43456C5
+const char ccode_43456c5[] = \
+"AE/6 AG/2 AI/1 AL/2 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
+"BA/2 BD/1 BE/4 BG/4 BH/4 BM/12 BN/4 BR/4 BS/2 BY/3 "\
+"CA/2 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
+"DE/7 DK/4 "\
+"EC/21 EE/4 EG/13 ES/4 ET/2 "\
+"FI/4 FR/5 "\
+"GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/30 "\
+"HK/2 HR/4 HU/4 "\
+"ID/1 IE/5 IL/14 IN/3 IS/4 IT/4 "\
+"JO/3 JP/58 "\
+"KH/2 KR/96 KW/5 KY/3 "\
+"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
+"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MQ/2 MR/2 MT/4 MU/2 MV/3 MW/1 MX/44 MY/3 "\
+"NI/2 NL/4 NO/4 NZ/4 "\
+"OM/4 "\
+"PA/17 PE/20 PH/5 PL/4 PR/38 PT/4 PY/2 "\
+"Q2/993 "\
+"RE/2 RO/4 RS/2 RU/13 "\
+"SE/4 SI/4 SK/4 SV/25 "\
+"TH/5 TN/1 TR/7 TT/3 TW/65 "\
+"UA/8 US/988 "\
+"VA/2 VE/3 VG/2 VN/4 "\
+"XZ/11 "\
+"YT/2 "\
+"ZA/6";
+#else
+const char ccode_43456c5[] = "";
+#endif
+#endif
+
+#ifdef CCODE_4356A2
+const char ccode_4356a2[] = \
+"AE/6 AG/2 AI/1 AL/2 AN/2 AR/21 AS/12 AT/4 AU/6 AW/2 AZ/2 "\
+"BA/2 BD/2 BE/4 BG/4 BH/4 BM/12 BN/4 BR/4 BS/2 BY/3 "\
+"CA/31 CH/4 CN/38 CO/17 CR/17 CY/4 CZ/4 "\
+"DE/7 DK/4 DZ/1 "\
+"EC/21 EE/4 ES/4 ET/2 "\
+"FI/4 FR/5 "\
+"GB/6 GD/2 GF/2 GP/2 GR/4 GT/1 GU/12 "\
+"HK/2 HR/4 HU/4 "\
+"ID/13 IE/5 IL/7 IN/28 IS/4 IT/4 "\
+"JO/3 JP/58 "\
+"KH/2 KR/57 KW/5 KY/3 "\
+"LA/2 LB/5 LI/4 LK/1 LS/2 LT/4 LU/3 LV/4 "\
+"MA/2 MC/1 MD/2 ME/2 MK/2 MN/1 MO/2 MR/2 MT/4 MQ/2 MU/2 MV/3 MW/1 MX/20 MY/16 "\
+"NI/2 NL/4 NO/4 NP/3 NZ/4 "\
+"OM/4 "\
+"PA/17 PE/20 PG/2 PH/5 PL/4 PR/20 PT/4 PY/2 "\
+"RE/2 RO/4 RS/2 RU/986 "\
+"SE/4 SG/4 SG/19 SI/4 SK/4 SN/2 SV/19 "\
+"TH/9 TN/1 TR/7 TT/3 TW/1 "\
+"UA/8 UG/2 US/1 UY/1 "\
+"VA/2 UA/16 VE/3 VG/2 VI/13 VN/4 "\
+"XZ/11 "\
+"YT/2 "\
+"ZM/2 "\
+"E0/32";
+#else
+const char ccode_4356a2[] = "";
+#endif
+
+#ifdef CCODE_4359C0
+const char ccode_4359c0[] = \
+"AD/1 AE/6 AG/2 AI/1 AL/3 AS/12 AT/21 AU/6 AW/2 AZ/8 "\
+"BA/4 BD/1 BE/19 BG/18 BH/4 BM/12 BN/4 BR/2 BS/2 BY/3 "\
+"CN/38 CO/17 CR/17 CY/18 CZ/18 "\
+"DE/30 DK/19 "\
+"E0/32 EC/21 EE/18 EG/13 ES/21 ET/2 "\
+"FI/19 FR/21 "\
+"GB/996 GD/2 GE/1 GF/2 GP/2 GR/18 GT/1 GU/30 "\
+"HK/2 HR/18 HU/18 "\
+"ID/1 IE/21 IL/14 IN/3 IS/17 IT/20 "\
+"JO/3 JP/967 "\
+"KH/2 KR/70 KW/5 KY/3 "\
+"LA/2 LB/5 LI/17 LI/4 LK/1 LS/2 LT/18 LU/18 LV/18 "\
+"MA/2 MC/2 MD/3 ME/5 MK/4 MN/1 MQ/2 MR/2 MT/18 MU/2 MV/3 MW/1 MX/44 MY/3 "\
+"NI/2 NL/19 NO/18 NZ/4 "\
+"OM/4 "\
+"PA/17 PE/20 PH/5 PL/18 PR/38 PT/20 PY/2 "\
+"Q1/947 Q2/993 "\
+"RE/2 RO/18 RS/4 RU/986 "\
+"SE/19 SI/18 SK/18 SM/1 SV/25 "\
+"TH/5 TN/1 TR/18 TT/3 TW/1 "\
+"UA/16 US/988 "\
+"VA/3 VE/3 VG/2 VN/4 "\
+"XZ/11 "\
+"YT/2 "\
+"ZA/6";
+#else
+const char ccode_4359c0[] = "";
+#endif
+
+#ifdef CCODE_4358U
+const char ccode_4358u[] = \
+"BE/4 BR/4 CA/2 CH/4 CN/38 CY/4 DE/7 DK/4 ES/4 "\
+"FI/4 FR/5 GB/6 GR/4 HK/2 HU/4 IE/5 IL/7 IS/4 "\
+"IT/4 JP/72 KE/0 MY/3 NL/4 PT/4 SA/5 SE/4 SG/0 "\
+"SZ/0 TH/5 TR/7 TW/230 US/0 VN/4";
+#else
+const char ccode_4358u[] = "";
+#endif
+
+typedef struct ccode_list_map_t {
+	uint chip;
+	uint chiprev;
+	const char *ccode_list;
+	const char *ccode_ww;
+} ccode_list_map_t;
+
+extern const char ccode_43438[];
+extern const char ccode_43455c0[];
+extern const char ccode_43456c5[];
+extern const char ccode_4356a2[];
+extern const char ccode_4359c0[];
+extern const char ccode_4358u[];
+
+const ccode_list_map_t ccode_list_map[] = {
+	/* ChipID		Chiprev		ccode  */
+#ifdef BCMSDIO
+	{BCM43430_CHIP_ID,	0,	ccode_43438, ""},
+	{BCM43430_CHIP_ID,	1,	ccode_43438, ""},
+	{BCM4345_CHIP_ID,	6,	ccode_43455c0, "XZ/11"},
+	{BCM43454_CHIP_ID,	6,	ccode_43455c0, "XZ/11"},
+	{BCM4345_CHIP_ID,	9,	ccode_43456c5, "XZ/11"},
+	{BCM43454_CHIP_ID,	9,	ccode_43456c5, "XZ/11"},
+	{BCM4354_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
+	{BCM4356_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
+	{BCM4371_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
+	{BCM4359_CHIP_ID,	9,	ccode_4359c0, "XZ/11"},
+#endif
+#ifdef BCMPCIE
+	{BCM4354_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
+	{BCM4356_CHIP_ID,	2,	ccode_4356a2, "XZ/11"},
+	{BCM4359_CHIP_ID,	9,	ccode_4359c0, "XZ/11"},
+#endif
+#ifdef BCMDBUS
+	{BCM43569_CHIP_ID,	2,	ccode_4358u, "XW/0"},
+#endif
+};
+
+int
+dhd_ccode_map_country_list(dhd_pub_t *dhd, wl_country_t *cspec)
+{
+	int bcmerror = -1, i;
+	uint chip = dhd->conf->chip, chiprev = dhd->conf->chiprev; 
+	const char *ccode_list = NULL, *ccode_ww = NULL;
+	char *pch;
+
+	for (i=0;  i<sizeof(ccode_list_map)/sizeof(ccode_list_map[0]);  i++) {
+		const ccode_list_map_t* row = &ccode_list_map[i];
+		if (row->chip == chip && row->chiprev == chiprev) {
+			ccode_list = row->ccode_list;
+			ccode_ww = row->ccode_ww;
+			break;
+		}
+	}
+
+	if (ccode_list) {
+		pch = strstr(ccode_list, cspec->ccode);
+		if (pch) {
+			cspec->rev = (int)simple_strtol(pch+strlen(cspec->ccode)+1, NULL, 0);
+			bcmerror = 0;
+		}
+	}
+
+	if (bcmerror && ccode_ww && strlen(ccode_ww)>=4) {
+		memcpy(cspec->ccode, ccode_ww, 2);
+		cspec->rev = (int)simple_strtol(ccode_ww+3, NULL, 0);
+	}
+
+	return bcmerror;
+}
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_common.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_common.c
index b489ce2d46e1..8073b2a07db2 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_common.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_common.c
@@ -138,6 +138,10 @@ int dhd_msg_level = DHD_ERROR_VAL | DHD_MSGTRACE_VAL | DHD_FWLOG_VAL;
 #include <sdiovar.h>
 #endif /* DHD_DEBUG */
 
+#ifdef CSI_SUPPORT
+#include <dhd_csi.h>
+#endif /* CSI_SUPPORT */
+
 #ifdef SOFTAP
 char fw_path2[MOD_PARAM_PATHLEN];
 extern bool softap_enabled;
@@ -1183,11 +1187,6 @@ dhd_mw_list_delete(dhd_pub_t *dhd, dll_t *list_head)
 }
 #endif /* DHD_DEBUG */
 
-#ifdef PKT_STATICS
-extern pkt_statics_t tx_statics;
-extern void dhdsdio_txpktstatics(void);
-#endif
-
 static int
 dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const char *name,
             void *params, int plen, void *arg, int len, int val_size)
@@ -1215,8 +1214,8 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 		if (bus_api_rev_len)
 			bcm_strncat_s((char*)arg + dhd_ver_len, bus_api_rev_len, bus_api_revision,
 				bus_api_rev_len);
-#ifdef PKT_STATICS
-		memset((uint8*) &tx_statics, 0, sizeof(pkt_statics_t));
+#if defined(BCMSDIO) && defined(PKT_STATICS)
+		dhd_bus_clear_txpktstatics(dhd_pub->bus);
 #endif
 		break;
 
@@ -1260,8 +1259,8 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 	case IOV_GVAL(IOV_MSGLEVEL):
 		int_val = (int32)dhd_msg_level;
 		bcopy(&int_val, arg, val_size);
-#ifdef PKT_STATICS
-		dhdsdio_txpktstatics();
+#if defined(BCMSDIO) && defined(PKT_STATICS)
+		dhd_bus_dump_txpktstatics(dhd_pub->bus);
 #endif
 		break;
 
@@ -1281,8 +1280,23 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 
 #ifndef BCMDBUS
 	case IOV_GVAL(IOV_WDTICK):
+#ifdef HOST_TPUT_TEST
+		if (dhd_pub->net_ts.tv_sec == 0 && dhd_pub->net_ts.tv_nsec == 0) {
+			osl_do_gettimeofday(&dhd_pub->net_ts);
+		} else {
+			struct osl_timespec cur_ts;
+			uint32 diff_ms;
+			osl_do_gettimeofday(&cur_ts);
+			diff_ms = osl_do_gettimediff(&cur_ts, &dhd_pub->net_ts)/1000;
+			int_val = (int32)((dhd_pub->net_len/1024/1024)*8)*1000/diff_ms;
+			dhd_pub->net_len = 0;
+			memcpy(&dhd_pub->net_ts, &cur_ts, sizeof(struct osl_timespec));
+			bcopy(&int_val, arg, sizeof(int_val));
+		}
+#else
 		int_val = (int32)dhd_watchdog_ms;
 		bcopy(&int_val, arg, val_size);
+#endif
 		break;
 #endif /* !BCMDBUS */
 
@@ -1349,8 +1363,23 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 
 
 	case IOV_GVAL(IOV_IOCTLTIMEOUT): {
+#ifdef HOST_TPUT_TEST
+		if (dhd_pub->bus_ts.tv_sec == 0 && dhd_pub->bus_ts.tv_nsec == 0) {
+			osl_do_gettimeofday(&dhd_pub->bus_ts);
+		} else {
+			struct osl_timespec cur_ts;
+			uint32 diff_ms;
+			osl_do_gettimeofday(&cur_ts);
+			diff_ms = osl_do_gettimediff(&cur_ts, &dhd_pub->bus_ts)/1000;
+			int_val = (int32)((dhd_pub->dstats.tx_bytes/1024/1024)*8)*1000/diff_ms;
+			dhd_pub->dstats.tx_bytes = 0;
+			memcpy(&dhd_pub->bus_ts, &cur_ts, sizeof(struct osl_timespec));
+			bcopy(&int_val, arg, sizeof(int_val));
+		}
+#else
 		int_val = (int32)dhd_os_get_ioctl_resp_timeout();
 		bcopy(&int_val, arg, sizeof(int_val));
+#endif
 		break;
 	}
 
@@ -3156,6 +3185,11 @@ wl_process_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, uint pktlen
 			(void *)(event->addr.octet), (void*) event_data);
 		break;
 #endif
+#if defined(CSI_SUPPORT)
+	case WLC_E_CSI:
+		dhd_csi_event_handler(dhd_pub, event, (void *)event_data);
+		break;
+#endif /* CSI_SUPPORT */
 	case WLC_E_LINK:
 #ifdef PCIE_FULL_DONGLE
 		DHD_EVENT(("%s: Link event %d, flags %x, status %x\n",
@@ -5022,58 +5056,61 @@ void dhd_free_download_buffer(dhd_pub_t	*dhd, void *buffer, int length)
 #endif /* DHD_8021X_DUMP */
 /* Parse EAPOL 4 way handshake messages */
 void
-dhd_dump_eapol_4way_message(dhd_pub_t *dhd, char *ifname,
+dhd_dump_eapol_4way_message(dhd_pub_t *dhd, int ifidx,
 	char *dump_data, bool tx)
 {
 	unsigned char type;
 	int pair, ack, mic, kerr, req, sec, install;
 	unsigned short us_tmp, key_len;
+	char *ifname;
 	char seabuf[ETHER_ADDR_STR_LEN]="";
 	char deabuf[ETHER_ADDR_STR_LEN]="";
 
 	bcm_ether_ntoa((struct ether_addr *)dump_data, deabuf);
 	bcm_ether_ntoa((struct ether_addr *)(dump_data+6), seabuf);
 
+	ifname = dhd_ifname(dhd, ifidx);
+
 	type = dump_data[15];
 	if (type == 0) {
 		if ((dump_data[22] == 1) && (dump_data[18] == 1)) {
-			dhd->conf->eapol_status = EAPOL_STATUS_REQID;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_REQID);
 			EAP_PRINT("Request, Identity");
 		} else if ((dump_data[22] == 1) && (dump_data[18] == 2)) {
-			dhd->conf->eapol_status = EAPOL_STATUS_RSPID;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_RSPID);
 			EAP_PRINT("Response, Identity");
 		} else if (dump_data[22] == 254) {
 			if (dump_data[30] == 1) {
-				dhd->conf->eapol_status = EAPOL_STATUS_WSC_START;
+				wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WSC_START);
 				EAP_PRINT("WSC Start");
 			} else if (dump_data[30] == 4) {
 				if (dump_data[41] == 4) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M1;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M1);
 					EAP_PRINT("WPS M1");
 				} else if (dump_data[41] == 5) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M2;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M2);
 					EAP_PRINT("WPS M2");
 				} else if (dump_data[41] == 7) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M3;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M3);
 					EAP_PRINT("WPS M3");
 				} else if (dump_data[41] == 8) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M4;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M4);
 					EAP_PRINT("WPS M4");
 				} else if (dump_data[41] == 9) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M5;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M5);
 					EAP_PRINT("WPS M5");
 				} else if (dump_data[41] == 10) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M6;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M6);
 					EAP_PRINT("WPS M6");
 				} else if (dump_data[41] == 11) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M7;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M7);
 					EAP_PRINT("WPS M7");
 				} else if (dump_data[41] == 12) {
-					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M8;
+					wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WPS_M8);
 					EAP_PRINT("WPS M8");
 				}
 			} else if (dump_data[30] == 5) {
-				dhd->conf->eapol_status = EAPOL_STATUS_WSC_DONE;
+				wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_WSC_DONE);
 				EAP_PRINT("WSC Done");
 			}
 		} else {
@@ -5092,16 +5129,16 @@ dhd_dump_eapol_4way_message(dhd_pub_t *dhd, char *ifname,
 		install  = 0 != (us_tmp & 0x40);
 
 		if (!req && !kerr && !sec && !mic && ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M1;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M1);
 			EAP_PRINT("WPA2 4-way M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M2;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M2);
 			EAP_PRINT("WPA2 4-way M2(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && ack && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M3;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M3);
 			EAP_PRINT("WPA2 4-way M3(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M4;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M4);
 			EAP_PRINT("WPA2 4-way M4(0x%04x)", us_tmp);
 		} else {
 			EAP_PRINT("ver %d, type %d, key_info 0x%x, replay %d",
@@ -5120,22 +5157,22 @@ dhd_dump_eapol_4way_message(dhd_pub_t *dhd, char *ifname,
 		key_len = (dump_data[111] << 8) | dump_data[112];
 
 		if (!req && !kerr && !sec && !mic && ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M1;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M1);
 			EAP_PRINT("WPA 4-way M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair && key_len) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M2;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M2);
 			EAP_PRINT("WPA 4-way M2(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && ack && install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M3;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M3);
 			EAP_PRINT("WPA 4-way M3(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M4;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_4WAY_M4);
 			EAP_PRINT("WPA 4-way M4(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && ack && !install && !pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_GROUPKEY_M1;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_GROUPKEY_M1);
 			EAP_PRINT("GROUP Key M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && !ack && !install && !pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_GROUPKEY_M2;
+			wl_ext_update_eapol_status(dhd, ifidx, EAPOL_STATUS_GROUPKEY_M2);
 			EAP_PRINT("GROUP Key M2(0x%04x)", us_tmp);
 		} else {
 			EAP_PRINT("ver %d, type %d, key_type %d, key_info 0x%x, replay %d",
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.c
index 514a072d04fe..b43fa490dbde 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.c
@@ -1,3863 +1,3902 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#include <typedefs.h>
-#include <osl.h>
-
-#include <bcmendian.h>
-#include <bcmutils.h>
-#include <hndsoc.h>
-#include <bcmsdbus.h>
-#if defined(HW_OOB) || defined(FORCE_WOWLAN)
-#include <bcmdefs.h>
-#include <bcmsdh.h>
-#include <sdio.h>
-#include <sbchipc.h>
-#endif
-#ifdef WL_CFG80211
-#include <wl_cfg80211.h>
-#endif
-
-#include <dhd_config.h>
-#include <dhd_dbg.h>
-#include <wl_android.h>
-
-/* message levels */
-#define CONFIG_ERROR_LEVEL	(1 << 0)
-#define CONFIG_TRACE_LEVEL	(1 << 1)
-#define CONFIG_MSG_LEVEL	(1 << 0)
-
-uint config_msg_level = 0xffff; //CONFIG_ERROR_LEVEL | CONFIG_MSG_LEVEL;
-uint dump_msg_level = 0;
-
-#define CONFIG_MSG(x, args...) \
-	do { \
-		if (config_msg_level & CONFIG_MSG_LEVEL) { \
-			DHD_PRINT("[dhd] %s : " x, __func__, ## args); \
-		} \
-	} while (0)
-#define CONFIG_ERROR(x, args...) \
-	do { \
-		if (config_msg_level & CONFIG_ERROR_LEVEL) { \
-			printk(KERN_ERR "[dhd] CONFIG-ERROR) %s : " x, __func__, ## args); \
-		} \
-	} while (0)
-#define CONFIG_TRACE(x, args...) \
-	do { \
-		if (config_msg_level & CONFIG_TRACE_LEVEL) { \
-			printk(KERN_INFO "[dhd] CONFIG-TRACE) %s : " x, __func__, ## args); \
-		} \
-	} while (0)
-
-#define MAXSZ_BUF		4096
-#define MAXSZ_CONFIG	8192
-
-#ifndef WL_CFG80211
-#define htod32(i) i
-#define htod16(i) i
-#define dtoh32(i) i
-#define dtoh16(i) i
-#define htodchanspec(i) i
-#define dtohchanspec(i) i
-#endif
-
-#if defined(SUSPEND_EVENT) && defined(PROP_TXSTATUS)
-#if defined(BCMSDIO) || defined(BCMDBUS)
-#include <dhd_wlfc.h>
-#endif /* BCMSDIO || BCMDBUS */
-#endif /* SUSPEND_EVENT && PROP_TXSTATUS */
-
-#define MAX_EVENT_BUF_NUM 16
-typedef struct eventmsg_buf {
-	u16 num;
-	struct {
-		u16 type;
-		bool set;
-	} event [MAX_EVENT_BUF_NUM];
-} eventmsg_buf_t;
-
-typedef struct cihp_name_map_t {
-	uint chip;
-	uint chiprev;
-	uint ag_type;
-	char *chip_name;
-	char *module_name;
-} cihp_name_map_t;
-
-/* Map of WLC_E events to connection failure strings */
-#define DONT_CARE	9999
-const cihp_name_map_t chip_name_map[] = {
-	/* ChipID			Chiprev	AG	 	ChipName	ModuleName  */
-#ifdef BCMSDIO
-	{BCM43362_CHIP_ID,	0,	DONT_CARE,	"RK901a0",			""},
-	//{BCM43362_CHIP_ID,	1,	DONT_CARE,	"RK901a2",			"AP6210"},
-	{BCM43362_CHIP_ID,	1,	DONT_CARE,	"bcm40181a2",			"ap6181"},
-	{BCM4330_CHIP_ID,	4,	FW_TYPE_G,	"RK903b2",			""},
-	{BCM4330_CHIP_ID,	4,	FW_TYPE_AG,	"RK903_ag",			"AP6330"},
-	{BCM43430_CHIP_ID,	0,	DONT_CARE,	"bcm43438a0",		"ap6212"},
-	{BCM43430_CHIP_ID,	1,	DONT_CARE,	"bcm43438a1",		"ap6212a"},
-	{BCM43430_CHIP_ID,	2,	DONT_CARE,	"bcm43436b0",		"ap6236"},
-	{BCM43012_CHIP_ID,	1,	FW_TYPE_G,	"bcm43013b0",		""},
-	{BCM43012_CHIP_ID,	1,	FW_TYPE_AG,	"bcm43013c0_ag",	""},
-	{BCM43012_CHIP_ID,	2,	DONT_CARE,	"bcm43013c1_ag",	"ap6203bm"},
-	{BCM4334_CHIP_ID,	3,	DONT_CARE,	"bcm4334b1_ag",		""},
-	{BCM43340_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
-	{BCM43341_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
-	{BCM4324_CHIP_ID,	5,	DONT_CARE,	"bcm43241b4_ag",	"ap62x2"},
-	{BCM4335_CHIP_ID,	2,	DONT_CARE,	"bcm4339a0_ag",		"AP6335"},
-	{BCM4339_CHIP_ID,	1,	DONT_CARE,	"bcm4339a0_ag",		"AP6335"},
-	{BCM4345_CHIP_ID,	6,	DONT_CARE,	"bcm43455c0_ag",	"ap6255"},
-	{BCM43454_CHIP_ID,	6,	DONT_CARE,	"bcm43455c0_ag",	""},
-	{BCM4345_CHIP_ID,	9,	DONT_CARE,	"bcm43456c5_ag",	"ap6256"},
-	{BCM43454_CHIP_ID,	9,	DONT_CARE,	"bcm43456c5_ag",	""},
-	{BCM4354_CHIP_ID,	1,	DONT_CARE,	"bcm4354a1_ag",		"ap6354"},
-	{BCM4354_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		"ap6356"},
-	{BCM4356_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		"ap6356"},
-	{BCM4371_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		""},
-	{BCM43569_CHIP_ID,	3,	DONT_CARE,	"bcm4358a3_ag",		""},
-	{BCM4359_CHIP_ID,	5,	DONT_CARE,	"bcm4359b1_ag",		""},
-	{BCM4359_CHIP_ID,	9,	DONT_CARE,	"bcm4359c0_ag",		"ap6398s"},
-#endif
-#ifdef BCMPCIE
-	{BCM4354_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_pcie_ag",	""},
-	{BCM4356_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_pcie_ag",	""},
-	{BCM4359_CHIP_ID,	9,	DONT_CARE,	"bcm4359c0_pcie_ag",	""},
-#endif
-#ifdef BCMDBUS
-	{BCM43143_CHIP_ID,	2,	DONT_CARE,	"bcm43143b0",		""},
-	{BCM43242_CHIP_ID,	1,	DONT_CARE,	"bcm43242a1_ag",	""},
-	{BCM43569_CHIP_ID,	2,	DONT_CARE,	"bcm4358u_ag",		""},
-#endif
-};
-
-void
-dhd_conf_free_chip_nv_path_list(wl_chip_nv_path_list_ctrl_t *chip_nv_list)
-{
-	CONFIG_TRACE("called\n");
-
-	if (chip_nv_list->m_chip_nv_path_head) {
-		CONFIG_TRACE("Free %p\n", chip_nv_list->m_chip_nv_path_head);
-		kfree(chip_nv_list->m_chip_nv_path_head);
-	}
-	chip_nv_list->count = 0;
-}
-
-#ifdef BCMSDIO
-void
-dhd_conf_free_mac_list(wl_mac_list_ctrl_t *mac_list)
-{
-	int i;
-
-	CONFIG_TRACE("called\n");
-	if (mac_list->m_mac_list_head) {
-		for (i=0; i<mac_list->count; i++) {
-			if (mac_list->m_mac_list_head[i].mac) {
-				CONFIG_TRACE("Free mac %p\n", mac_list->m_mac_list_head[i].mac);
-				kfree(mac_list->m_mac_list_head[i].mac);
-			}
-		}
-		CONFIG_TRACE("Free m_mac_list_head %p\n", mac_list->m_mac_list_head);
-		kfree(mac_list->m_mac_list_head);
-	}
-	mac_list->count = 0;
-}
-
-#if defined(HW_OOB) || defined(FORCE_WOWLAN)
-void
-dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip)
-{
-	uint32 gpiocontrol, addr;
-
-	if (CHIPID(chip) == BCM43362_CHIP_ID) {
-		CONFIG_MSG("Enable HW OOB for 43362\n");
-		addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, gpiocontrol);
-		gpiocontrol = bcmsdh_reg_read(sdh, addr, 4);
-		gpiocontrol |= 0x2;
-		bcmsdh_reg_write(sdh, addr, 4, gpiocontrol);
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10005, 0xf, NULL);
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10006, 0x0, NULL);
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10007, 0x2, NULL);
-	}
-}
-#endif
-
-#define SBSDIO_CIS_SIZE_LIMIT		0x200
-#define F0_BLOCK_SIZE 32
-int
-dhd_conf_set_blksize(bcmsdh_info_t *sdh)
-{
-	int err = 0;
-	uint fn, numfn;
-	int32 blksize = 0, cur_blksize = 0;
-	uint8 cisd;
-
-	numfn = bcmsdh_query_iofnum(sdh);
-
-	for (fn = 0; fn <= numfn; fn++) {
-		if (!fn)
-			blksize = F0_BLOCK_SIZE;
-		else {
-			bcmsdh_cisaddr_read(sdh, fn, &cisd, 24);
-			blksize = cisd;
-			bcmsdh_cisaddr_read(sdh, fn, &cisd, 25);
-			blksize |= cisd << 8;
-		}
-#ifdef CUSTOM_SDIO_F2_BLKSIZE
-		if (fn == 2 && blksize > CUSTOM_SDIO_F2_BLKSIZE) {
-			blksize = CUSTOM_SDIO_F2_BLKSIZE;
-		}
-#endif
-		bcmsdh_iovar_op(sdh, "sd_blocksize", &fn, sizeof(int32),
-			&cur_blksize, sizeof(int32), FALSE);
-		if (cur_blksize != blksize) {
-			CONFIG_MSG("fn=%d, blksize=%d, cur_blksize=%d\n",
-				fn, blksize, cur_blksize);
-			blksize |= (fn<<16);
-			if (bcmsdh_iovar_op(sdh, "sd_blocksize", NULL, 0, &blksize,
-				sizeof(blksize), TRUE) != BCME_OK) {
-				CONFIG_ERROR("fail on get sd_blocksize");
-				err = -1;
-			}
-		}
-	}
-
-	return err;
-}
-
-void
-dhd_conf_get_otp(dhd_pub_t *dhd, bcmsdh_info_t *sdh)
-{
-	int i, err = -1;
-	uint8 *ptr = 0, *ptpl_code = NULL;
-	unsigned char tpl_code, tpl_link='\0';
-	uint8 mac_header[3] = {0x80, 0x07, 0x19};
-	uint8 *cis;
-
-	if (!(cis = MALLOC(dhd->osh, SBSDIO_CIS_SIZE_LIMIT))) {
-		CONFIG_ERROR("cis malloc failed\n");
-	}
-	bzero(cis, SBSDIO_CIS_SIZE_LIMIT);
-
-	if ((err = bcmsdh_cis_read(sdh, 0, cis, SBSDIO_CIS_SIZE_LIMIT))) {
-		CONFIG_ERROR("cis read err %d\n", err);
-		MFREE(dhd->osh, cis, SBSDIO_CIS_SIZE_LIMIT);
-		return;
-	}
-	ptr = cis;
-	do {
-		/* 0xff means we're done */
-		tpl_code = *ptr;
-		ptpl_code = ptr;
-		ptr++;
-		if (tpl_code == 0xff)
-			break;
-
-		/* null entries have no link field or data */
-		if (tpl_code == 0x00)
-			continue;
-
-		tpl_link = *ptr;
-		ptr++;
-		/* a size of 0xff also means we're done */
-		if (tpl_link == 0xff)
-			break;
-		if (config_msg_level & CONFIG_TRACE_LEVEL) {
-			prhex("TPL", ptpl_code, tpl_link+2);
-		}
-
-		if (tpl_code == 0x80 && tpl_link == 0x07 && *ptr == 0x19) {
-			memcpy(&dhd->conf->otp_mac, ptr+1, 6);
-		}
-#ifdef GET_OTP_MODULE_NAME
-		else if (tpl_code == 0x8e && *ptr == 0x41) {
-			int len = tpl_link - 1;
-			if (len <= sizeof(dhd->conf->module_name) - 1) {
-				strncpy(dhd->conf->module_name, ptr+1, len);
-				CONFIG_MSG("module_name=%s\n", dhd->conf->module_name);
-			} else {
-				CONFIG_ERROR("len is too long %d >= %d\n",
-					len, (int)sizeof(dhd->conf->module_name) - 1);
-			}
-		}
-#endif
-
-		ptr += tpl_link;
-	} while (1);
-
-	if (!memcmp(&ether_null, &dhd->conf->otp_mac, ETHER_ADDR_LEN)) {
-		ptr = cis;
-		/* Special OTP */
-		if (bcmsdh_reg_read(sdh, SI_ENUM_BASE, 4) == 0x16044330) {
-			for (i=0; i<SBSDIO_CIS_SIZE_LIMIT; i++) {
-				if (!memcmp(mac_header, ptr, 3)) {
-					memcpy(&dhd->conf->otp_mac, ptr+3, 6);
-					break;
-				}
-				ptr++;
-			}
-		}
-	}
-
-	ASSERT(cis);
-	MFREE(dhd->osh, cis, SBSDIO_CIS_SIZE_LIMIT);
-}
-
-void
-dhd_conf_set_fw_name_by_mac(dhd_pub_t *dhd, char *fw_path)
-{
-	int i, j;
-	uint8 *mac = (uint8 *)&dhd->conf->otp_mac;
-	int fw_num=0, mac_num=0;
-	uint32 oui, nic;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	int fw_type, fw_type_new;
-	char *name_ptr;
-
-	mac_list = dhd->conf->fw_by_mac.m_mac_list_head;
-	fw_num = dhd->conf->fw_by_mac.count;
-	if (!mac_list || !fw_num)
-		return;
-
-	oui = (mac[0] << 16) | (mac[1] << 8) | (mac[2]);
-	nic = (mac[3] << 16) | (mac[4] << 8) | (mac[5]);
-
-	/* find out the last '/' */
-	i = strlen(fw_path);
-	while (i > 0) {
-		if (fw_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	name_ptr = &fw_path[i];
-
-	if (strstr(name_ptr, "_apsta"))
-		fw_type = FW_TYPE_APSTA;
-	else if (strstr(name_ptr, "_p2p"))
-		fw_type = FW_TYPE_P2P;
-	else if (strstr(name_ptr, "_mesh"))
-		fw_type = FW_TYPE_MESH;
-	else if (strstr(name_ptr, "_es"))
-		fw_type = FW_TYPE_ES;
-	else if (strstr(name_ptr, "_mfg"))
-		fw_type = FW_TYPE_MFG;
-	else
-		fw_type = FW_TYPE_STA;
-
-	for (i=0; i<fw_num; i++) {
-		mac_num = mac_list[i].count;
-		mac_range = mac_list[i].mac;
-		if (strstr(mac_list[i].name, "_apsta"))
-			fw_type_new = FW_TYPE_APSTA;
-		else if (strstr(mac_list[i].name, "_p2p"))
-			fw_type_new = FW_TYPE_P2P;
-		else if (strstr(mac_list[i].name, "_mesh"))
-			fw_type_new = FW_TYPE_MESH;
-		else if (strstr(mac_list[i].name, "_es"))
-			fw_type_new = FW_TYPE_ES;
-		else if (strstr(mac_list[i].name, "_mfg"))
-			fw_type_new = FW_TYPE_MFG;
-		else
-			fw_type_new = FW_TYPE_STA;
-		if (fw_type != fw_type_new) {
-			CONFIG_MSG("fw_typ=%d != fw_type_new=%d\n", fw_type, fw_type_new);
-			continue;
-		}
-		for (j=0; j<mac_num; j++) {
-			if (oui == mac_range[j].oui) {
-				if (nic >= mac_range[j].nic_start && nic <= mac_range[j].nic_end) {
-					strcpy(name_ptr, mac_list[i].name);
-					CONFIG_MSG("matched oui=0x%06X, nic=0x%06X\n", oui, nic);
-					CONFIG_MSG("fw_path=%s\n", fw_path);
-					return;
-				}
-			}
-		}
-	}
-}
-
-void
-dhd_conf_set_nv_name_by_mac(dhd_pub_t *dhd, char *nv_path)
-{
-	int i, j;
-	uint8 *mac = (uint8 *)&dhd->conf->otp_mac;
-	int nv_num=0, mac_num=0;
-	uint32 oui, nic;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	char *pnv_name;
-
-	mac_list = dhd->conf->nv_by_mac.m_mac_list_head;
-	nv_num = dhd->conf->nv_by_mac.count;
-	if (!mac_list || !nv_num)
-		return;
-
-	oui = (mac[0] << 16) | (mac[1] << 8) | (mac[2]);
-	nic = (mac[3] << 16) | (mac[4] << 8) | (mac[5]);
-
-	/* find out the last '/' */
-	i = strlen(nv_path);
-	while (i > 0) {
-		if (nv_path[i] == '/') break;
-		i--;
-	}
-	pnv_name = &nv_path[i+1];
-
-	for (i=0; i<nv_num; i++) {
-		mac_num = mac_list[i].count;
-		mac_range = mac_list[i].mac;
-		for (j=0; j<mac_num; j++) {
-			if (oui == mac_range[j].oui) {
-				if (nic >= mac_range[j].nic_start && nic <= mac_range[j].nic_end) {
-					strcpy(pnv_name, mac_list[i].name);
-					CONFIG_MSG("matched oui=0x%06X, nic=0x%06X\n", oui, nic);
-					CONFIG_MSG("nv_path=%s\n", nv_path);
-					return;
-				}
-			}
-		}
-	}
-}
-#endif
-
-void
-dhd_conf_free_country_list(struct dhd_conf *conf)
-{
-	country_list_t *country = conf->country_head;
-	int count = 0;
-
-	CONFIG_TRACE("called\n");
-	while (country) {
-		CONFIG_TRACE("Free cspec %s\n", country->cspec.country_abbrev);
-		conf->country_head = country->next;
-		kfree(country);
-		country = conf->country_head;
-		count++;
-	}
-	CONFIG_TRACE("%d country released\n", count);
-}
-
-void
-dhd_conf_free_mchan_list(struct dhd_conf *conf)
-{
-	mchan_params_t *mchan = conf->mchan;
-	int count = 0;
-
-	CONFIG_TRACE("called\n");
-	while (mchan) {
-		CONFIG_TRACE("Free cspec %p\n", mchan);
-		conf->mchan = mchan->next;
-		kfree(mchan);
-		mchan = conf->mchan;
-		count++;
-	}
-	CONFIG_TRACE("%d mchan released\n", count);
-}
-
-int
-dhd_conf_set_fw_name_by_chip(dhd_pub_t *dhd, char *fw_path)
-{
-	int fw_type, ag_type;
-	uint chip, chiprev;
-	int i;
-	char *name_ptr;
-
-	chip = dhd->conf->chip;
-	chiprev = dhd->conf->chiprev;
-
-	if (fw_path[0] == '\0') {
-#ifdef CONFIG_BCMDHD_FW_PATH
-		bcm_strncpy_s(fw_path, MOD_PARAM_PATHLEN-1, CONFIG_BCMDHD_FW_PATH, MOD_PARAM_PATHLEN-1);
-		if (fw_path[0] == '\0')
-#endif
-		{
-			CONFIG_MSG("firmware path is null\n");
-			return 0;
-		}
-	}
-#ifndef FW_PATH_AUTO_SELECT
-	return DONT_CARE;
-#endif
-
-	/* find out the last '/' */
-	i = strlen(fw_path);
-	while (i > 0) {
-		if (fw_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	name_ptr = &fw_path[i];
-#ifdef BAND_AG
-	ag_type = FW_TYPE_AG;
-#else
-	ag_type = strstr(name_ptr, "_ag") ? FW_TYPE_AG : FW_TYPE_G;
-#endif
-	if (strstr(name_ptr, "_apsta"))
-		fw_type = FW_TYPE_APSTA;
-	else if (strstr(name_ptr, "_p2p"))
-		fw_type = FW_TYPE_P2P;
-	else if (strstr(name_ptr, "_mesh"))
-		fw_type = FW_TYPE_MESH;
-	else if (strstr(name_ptr, "_es"))
-		fw_type = FW_TYPE_ES;
-	else if (strstr(name_ptr, "_mfg"))
-		fw_type = FW_TYPE_MFG;
-	else
-		fw_type = FW_TYPE_STA;
-
-	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
-		const cihp_name_map_t* row = &chip_name_map[i];
-		if (row->chip == chip && row->chiprev == chiprev &&
-				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
-			strcpy(name_ptr, "fw_");
-			strcat(fw_path, row->chip_name);
-#ifdef BCMUSBDEV_COMPOSITE
-			strcat(fw_path, "_cusb");
-#endif
-			if (fw_type == FW_TYPE_APSTA)
-				strcat(fw_path, "_apsta.bin");
-			else if (fw_type == FW_TYPE_P2P)
-				strcat(fw_path, "_p2p.bin");
-			else if (fw_type == FW_TYPE_MESH)
-				strcat(fw_path, "_mesh.bin");
-			else if (fw_type == FW_TYPE_ES)
-				strcat(fw_path, "_es.bin");
-			else if (fw_type == FW_TYPE_MFG)
-				strcat(fw_path, "_mfg.bin");
-			else
-				strcat(fw_path, ".bin");
-		}
-	}
-
-	dhd->conf->fw_type = fw_type;
-
-	CONFIG_TRACE("firmware_path=%s\n", fw_path);
-	return ag_type;
-}
-
-void
-dhd_conf_set_clm_name_by_chip(dhd_pub_t *dhd, char *clm_path, int ag_type)
-{
-	uint chip, chiprev;
-	int i;
-	char *name_ptr;
-
-	chip = dhd->conf->chip;
-	chiprev = dhd->conf->chiprev;
-
-	if (clm_path[0] == '\0') {
-		CONFIG_MSG("clm path is null\n");
-		return;
-	}
-
-	/* find out the last '/' */
-	i = strlen(clm_path);
-	while (i > 0) {
-		if (clm_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	name_ptr = &clm_path[i];
-
-	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
-		const cihp_name_map_t* row = &chip_name_map[i];
-		if (row->chip == chip && row->chiprev == chiprev &&
-				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
-			strcpy(name_ptr, "clm_");
-			strcat(clm_path, row->chip_name);
-			strcat(clm_path, ".blob");
-		}
-	}
-
-	CONFIG_TRACE("clm_path=%s\n", clm_path);
-}
-
-void
-dhd_conf_set_nv_name_by_chip(dhd_pub_t *dhd, char *nv_path, int ag_type)
-{
-	uint chip, chiprev;
-	int i;
-	char *name_ptr;
-
-	chip = dhd->conf->chip;
-	chiprev = dhd->conf->chiprev;
-
-	if (nv_path[0] == '\0') {
-#ifdef CONFIG_BCMDHD_NVRAM_PATH
-		bcm_strncpy_s(nv_path, MOD_PARAM_PATHLEN-1, CONFIG_BCMDHD_NVRAM_PATH, MOD_PARAM_PATHLEN-1);
-		if (nv_path[0] == '\0')
-#endif
-		{
-			CONFIG_MSG("nvram path is null\n");
-			return;
-		}
-	}
-
-	/* find out the last '/' */
-	i = strlen(nv_path);
-	while (i > 0) {
-		if (nv_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	name_ptr = &nv_path[i];
-
-	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
-		const cihp_name_map_t* row = &chip_name_map[i];
-		if (row->chip == chip && row->chiprev == chiprev &&
-				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
-#ifdef GET_OTP_MODULE_NAME
-			if (strlen(dhd->conf->module_name)) {
-				strcpy(name_ptr, "nvram_");
-				strcat(name_ptr, dhd->conf->module_name);
-			} else
-#endif
-			if (strlen(row->module_name)){
-				strcpy(name_ptr, "nvram_");
-				strcat(name_ptr, row->module_name);
-			} else
-				continue;
-#ifdef BCMUSBDEV_COMPOSITE
-			strcat(name_ptr, "_cusb");
-#endif
-			strcat(name_ptr, ".txt");
-		}
-	}
-
-	for (i=0; i<dhd->conf->nv_by_chip.count; i++) {
-		if (chip==dhd->conf->nv_by_chip.m_chip_nv_path_head[i].chip &&
-				chiprev==dhd->conf->nv_by_chip.m_chip_nv_path_head[i].chiprev) {
-			strcpy(name_ptr, dhd->conf->nv_by_chip.m_chip_nv_path_head[i].name);
-			break;
-		}
-	}
-
-	CONFIG_TRACE("nvram_path=%s\n", nv_path);
-}
-
-void
-dhd_conf_copy_path(dhd_pub_t *dhd, char *dst_name, char *dst_path, char *src_path)
-{
-	int i;
-
-	if (src_path[0] == '\0') {
-		CONFIG_MSG("src_path is null\n");
-		return;
-	} else
-		strcpy(dst_path, src_path);
-
-	/* find out the last '/' */
-	i = strlen(dst_path);
-	while (i > 0) {
-		if (dst_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	strcpy(&dst_path[i], dst_name);
-
-	CONFIG_TRACE("dst_path=%s\n", dst_path);
-}
-
-#ifdef CONFIG_PATH_AUTO_SELECT
-void
-dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path)
-{
-	uint chip, chiprev;
-	int i;
-	char *name_ptr;
-
-	chip = dhd->conf->chip;
-	chiprev = dhd->conf->chiprev;
-
-	if (conf_path[0] == '\0') {
-		CONFIG_MSG("config path is null\n");
-		return;
-	}
-
-	/* find out the last '/' */
-	i = strlen(conf_path);
-	while (i > 0) {
-		if (conf_path[i] == '/') {
-			i++;
-			break;
-		}
-		i--;
-	}
-	name_ptr = &conf_path[i];
-
-	for (i = 0;  i < sizeof(chip_name_map)/sizeof(chip_name_map[0]);  i++) {
-		const cihp_name_map_t* row = &chip_name_map[i];
-		if (row->chip == chip && row->chiprev == chiprev) {
-			strcpy(name_ptr, "config_");
-			strcat(conf_path, row->chip_name);
-			strcat(conf_path, ".txt");
-		}
-	}
-
-	CONFIG_TRACE("config_path=%s\n", conf_path);
-}
-#endif
-
-void
-dhd_conf_set_path_params(dhd_pub_t *dhd, char *fw_path, char *nv_path)
-{
-	int ag_type;
-
-	/* External conf takes precedence if specified */
-	dhd_conf_preinit(dhd);
-
-	if (dhd->conf_path[0] == '\0') {
-		dhd_conf_copy_path(dhd, "config.txt", dhd->conf_path, nv_path);
-	}
-	if (dhd->clm_path[0] == '\0') {
-		dhd_conf_copy_path(dhd, "clm.blob", dhd->clm_path, fw_path);
-	}
-#ifdef CONFIG_PATH_AUTO_SELECT
-	dhd_conf_set_conf_name_by_chip(dhd, dhd->conf_path);
-#endif
-
-	dhd_conf_read_config(dhd, dhd->conf_path);
-
-	ag_type = dhd_conf_set_fw_name_by_chip(dhd, fw_path);
-	dhd_conf_set_nv_name_by_chip(dhd, nv_path, ag_type);
-	dhd_conf_set_clm_name_by_chip(dhd, dhd->clm_path, ag_type);
-#ifdef BCMSDIO
-	dhd_conf_set_fw_name_by_mac(dhd, fw_path);
-	dhd_conf_set_nv_name_by_mac(dhd, nv_path);
-#endif
-
-	CONFIG_MSG("Final fw_path=%s\n", fw_path);
-	CONFIG_MSG("Final nv_path=%s\n", nv_path);
-	CONFIG_MSG("Final clm_path=%s\n", dhd->clm_path);
-	CONFIG_MSG("Final conf_path=%s\n", dhd->conf_path);
-}
-
-int
-dhd_conf_set_intiovar(dhd_pub_t *dhd, uint cmd, char *name, int val,
-	int def, bool down)
-{
-	int ret = -1;
-	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
-
-	if (val >= def) {
-		if (down) {
-			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
-				CONFIG_ERROR("WLC_DOWN setting failed %d\n", ret);
-		}
-		if (cmd == WLC_SET_VAR) {
-			CONFIG_TRACE("set %s %d\n", name, val);
-			bcm_mkiovar(name, (char *)&val, sizeof(val), iovbuf, sizeof(iovbuf));
-			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
-				CONFIG_ERROR("%s setting failed %d\n", name, ret);
-		} else {
-			CONFIG_TRACE("set %s %d %d\n", name, cmd, val);
-			if ((ret = dhd_wl_ioctl_cmd(dhd, cmd, &val, sizeof(val), TRUE, 0)) < 0)
-				CONFIG_ERROR("%s setting failed %d\n", name, ret);
-		}
-	}
-
-	return ret;
-}
-
-int
-dhd_conf_set_bufiovar(dhd_pub_t *dhd, int ifidx, uint cmd, char *name,
-	char *buf, int len, bool down)
-{
-	char iovbuf[WLC_IOCTL_SMLEN];
-	s32 iovar_len;
-	int ret = -1;
-
-	if (down) {
-		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, ifidx)) < 0)
-			CONFIG_ERROR("WLC_DOWN setting failed %d\n", ret);
-	}
-
-	if (cmd == WLC_SET_VAR) {
-		iovar_len = bcm_mkiovar(name, buf, len, iovbuf, sizeof(iovbuf));
-		if (iovar_len > 0)
-			ret = dhd_wl_ioctl_cmd(dhd, cmd, iovbuf, iovar_len, TRUE, ifidx);
-		else
-			ret = BCME_BUFTOOSHORT;
-		if (ret < 0)
-			CONFIG_ERROR("%s setting failed %d, len=%d\n", name, ret, len);
-	} else {
-		if ((ret = dhd_wl_ioctl_cmd(dhd, cmd, buf, len, TRUE, ifidx)) < 0)
-			CONFIG_ERROR("%s setting failed %d\n", name, ret);
-	}
-
-	return ret;
-}
-
-int
-dhd_conf_get_iovar(dhd_pub_t *dhd, int ifidx, int cmd, char *name,
-	char *buf, int len)
-{
-	char iovbuf[WLC_IOCTL_SMLEN];
-	int ret = -1;
-
-	if (cmd == WLC_GET_VAR) {
-		if (bcm_mkiovar(name, NULL, 0, iovbuf, sizeof(iovbuf))) {
-			ret = dhd_wl_ioctl_cmd(dhd, cmd, iovbuf, sizeof(iovbuf), FALSE, ifidx);
-			if (!ret) {
-				memcpy(buf, iovbuf, len);
-			} else {
-				CONFIG_ERROR("get iovar %s failed %d\n", name, ret);
-			}
-		} else {
-			CONFIG_ERROR("mkiovar %s failed\n", name);
-		}
-	} else {
-		ret = dhd_wl_ioctl_cmd(dhd, cmd, buf, len, FALSE, 0);
-		if (ret < 0)
-			CONFIG_ERROR("get iovar %s failed %d\n", name, ret);
-	}
-
-	return ret;
-}
-
-static int
-dhd_conf_rsdb_mode(dhd_pub_t *dhd, char *buf)
-{
-	wl_config_t rsdb_mode_cfg = {1, 0};
-
-	if (buf) {
-		rsdb_mode_cfg.config = (int)simple_strtol(buf, NULL, 0);
-		CONFIG_MSG("rsdb_mode %d\n", rsdb_mode_cfg.config);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "rsdb_mode", (char *)&rsdb_mode_cfg,
-			sizeof(rsdb_mode_cfg), TRUE);
-	}
-
-	return 0;
-}
-
-typedef int (tpl_parse_t)(dhd_pub_t *dhd, char *buf);
-
-typedef struct iovar_tpl_t {
-	int cmd;
-	char *name;
-	tpl_parse_t *parse;
-} iovar_tpl_t;
-
-const iovar_tpl_t iovar_tpl_list[] = {
-	{WLC_SET_VAR,	"rsdb_mode",	dhd_conf_rsdb_mode},
-};
-
-static int iovar_tpl_parse(const iovar_tpl_t *tpl, int tpl_count,
-	dhd_pub_t *dhd, int cmd, char *name, char *buf)
-{
-	int i, ret = 0;
-
-	/* look for a matching code in the table */
-	for (i = 0; i < tpl_count; i++, tpl++) {
-		if (tpl->cmd == cmd && !strcmp(tpl->name, name))
-			break;
-	}
-	if (i < tpl_count && tpl->parse) {
-		ret = tpl->parse(dhd, buf);
-	} else {
-		ret = -1;
-	}
-
-	return ret;
-}
-
-bool
-dhd_conf_set_wl_cmd(dhd_pub_t *dhd, char *data, bool down)
-{
-	int cmd, val, ret = 0, len;
-	char name[32], *pch, *pick_tmp, *pick_tmp2, *pdata = NULL;
-
-	/* Process wl_preinit:
-	 * wl_preinit=[cmd]=[val], [cmd]=[val]
-	 * Ex: wl_preinit=86=0, mpc=0
-	 */
-
-	if (data == NULL)
-		return FALSE;
-
-	len = strlen(data);
-	pdata = kmalloc(len+1, GFP_KERNEL);
-	if (pdata == NULL) {
-		CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", len+1);
-		goto exit;
-	}
-	memset(pdata, 0, len+1);
-	strcpy(pdata, data);
-
-	pick_tmp = pdata;
-	while (pick_tmp && (pick_tmp2 = bcmstrtok(&pick_tmp, ",", 0)) != NULL) {
-		pch = bcmstrtok(&pick_tmp2, "=", 0);
-		if (!pch)
-			break;
-		if (*pch == ' ') {
-			pch++;
-		}
-		memset(name, 0 , sizeof (name));
-		cmd = (int)simple_strtol(pch, NULL, 0);
-		if (cmd == 0) {
-			cmd = WLC_SET_VAR;
-			strcpy(name, pch);
-		}
-		pch = bcmstrtok(&pick_tmp2, ",", 0);
-		if (!pch) {
-			break;
-		}
-		ret = iovar_tpl_parse(iovar_tpl_list, ARRAY_SIZE(iovar_tpl_list),
-			dhd, cmd, name, pch);
-		if (ret) {
-			val = (int)simple_strtol(pch, NULL, 0);
-			dhd_conf_set_intiovar(dhd, cmd, name, val, -1, down);
-		}
-	}
-
-exit:
-	if (pdata)
-		kfree(pdata);
-	return true;
-}
-
-int
-dhd_conf_get_band(dhd_pub_t *dhd)
-{
-	int band = -1;
-
-	if (dhd && dhd->conf)
-		band = dhd->conf->band;
-	else
-		CONFIG_ERROR("dhd or conf is NULL\n");
-
-	return band;
-}
-
-int
-dhd_conf_get_country(dhd_pub_t *dhd, wl_country_t *cspec)
-{
-	int bcmerror = -1;
-
-	memset(cspec, 0, sizeof(wl_country_t));
-	bcm_mkiovar("country", NULL, 0, (char*)cspec, sizeof(wl_country_t));
-	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, cspec, sizeof(wl_country_t),
-			FALSE, 0)) < 0)
-		CONFIG_ERROR("country code getting failed %d\n", bcmerror);
-
-	return bcmerror;
-}
-
-int
-dhd_conf_map_country_list(dhd_pub_t *dhd, wl_country_t *cspec)
-{
-	int bcmerror = -1;
-	struct dhd_conf *conf = dhd->conf;
-	country_list_t *country = conf->country_head;
-
-#ifdef CCODE_LIST
-	bcmerror = dhd_ccode_map_country_list(dhd, cspec);
-#endif
-
-	while (country != NULL) {
-		if (!strncmp("**", country->cspec.country_abbrev, 2)) {
-			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
-			cspec->rev = country->cspec.rev;
-			bcmerror = 0;
-			break;
-		} else if (!strncmp(cspec->country_abbrev,
-				country->cspec.country_abbrev, 2)) {
-			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
-			cspec->rev = country->cspec.rev;
-			bcmerror = 0;
-			break;
-		}
-		country = country->next;
-	}
-
-	if (!bcmerror)
-		CONFIG_MSG("%s/%d\n", cspec->ccode, cspec->rev);
-
-	return bcmerror;
-}
-
-int
-dhd_conf_set_country(dhd_pub_t *dhd, wl_country_t *cspec)
-{
-	int bcmerror = -1;
-
-	memset(&dhd->dhd_cspec, 0, sizeof(wl_country_t));
-
-	CONFIG_MSG("set country %s, revision %d\n", cspec->ccode, cspec->rev);
-	bcmerror = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "country", (char *)cspec,
-		sizeof(wl_country_t), FALSE);
-	dhd_conf_get_country(dhd, cspec);
-	CONFIG_MSG("Country code: %s (%s/%d)\n",
-		cspec->country_abbrev, cspec->ccode, cspec->rev);
-
-	return bcmerror;
-}
-
-int
-dhd_conf_fix_country(dhd_pub_t *dhd)
-{
-	int bcmerror = -1;
-	int band;
-	wl_uint32_list_t *list;
-	u8 valid_chan_list[sizeof(u32)*(WL_NUMCHANNELS + 1)];
-	wl_country_t cspec;
-
-	if (!(dhd && dhd->conf)) {
-		return bcmerror;
-	}
-
-	memset(valid_chan_list, 0, sizeof(valid_chan_list));
-	list = (wl_uint32_list_t *)(void *) valid_chan_list;
-	list->count = htod32(WL_NUMCHANNELS);
-	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VALID_CHANNELS, valid_chan_list,
-			sizeof(valid_chan_list), FALSE, 0)) < 0) {
-		CONFIG_ERROR("get channels failed with %d\n", bcmerror);
-	}
-
-	band = dhd_conf_get_band(dhd);
-
-	if (bcmerror || ((band==WLC_BAND_AUTO || band==WLC_BAND_2G || band==-1) &&
-			dtoh32(list->count)<11)) {
-		CONFIG_ERROR("bcmerror=%d, # of channels %d\n",
-			bcmerror, dtoh32(list->count));
-		dhd_conf_map_country_list(dhd, &dhd->conf->cspec);
-		if ((bcmerror = dhd_conf_set_country(dhd, &dhd->conf->cspec)) < 0) {
-			strcpy(cspec.country_abbrev, "US");
-			cspec.rev = 0;
-			strcpy(cspec.ccode, "US");
-			dhd_conf_map_country_list(dhd, &cspec);
-			dhd_conf_set_country(dhd, &cspec);
-		}
-	}
-
-	return bcmerror;
-}
-
-bool
-dhd_conf_match_channel(dhd_pub_t *dhd, uint32 channel)
-{
-	int i;
-	bool match = false;
-
-	if (dhd && dhd->conf) {
-		if (dhd->conf->channels.count == 0)
-			return true;
-		for (i=0; i<dhd->conf->channels.count; i++) {
-			if (channel == dhd->conf->channels.channel[i])
-				match = true;
-		}
-	} else {
-		match = true;
-		CONFIG_ERROR("dhd or conf is NULL\n");
-	}
-
-	return match;
-}
-
-int
-dhd_conf_set_roam(dhd_pub_t *dhd)
-{
-	int bcmerror = -1;
-	struct dhd_conf *conf = dhd->conf;
-
-	dhd_roam_disable = conf->roam_off;
-	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off", dhd->conf->roam_off, 0, FALSE);
-
-	if (!conf->roam_off || !conf->roam_off_suspend) {
-		CONFIG_MSG("set roam_trigger %d\n", conf->roam_trigger[0]);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_TRIGGER, "WLC_SET_ROAM_TRIGGER",
-			(char *)conf->roam_trigger, sizeof(conf->roam_trigger), FALSE);
-
-		CONFIG_MSG("set roam_scan_period %d\n", conf->roam_scan_period[0]);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_SCAN_PERIOD, "WLC_SET_ROAM_SCAN_PERIOD",
-			(char *)conf->roam_scan_period, sizeof(conf->roam_scan_period), FALSE);
-
-		CONFIG_MSG("set roam_delta %d\n", conf->roam_delta[0]);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_DELTA, "WLC_SET_ROAM_DELTA",
-			(char *)conf->roam_delta, sizeof(conf->roam_delta), FALSE);
-
-		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "fullroamperiod",
-			dhd->conf->fullroamperiod, 1, FALSE);
-	}
-
-	return bcmerror;
-}
-
-void
-dhd_conf_add_to_eventbuffer(struct eventmsg_buf *ev, u16 event, bool set)
-{
-	if (!ev || (event > WLC_E_LAST))
-		return;
-
-	if (ev->num < MAX_EVENT_BUF_NUM) {
-		ev->event[ev->num].type = event;
-		ev->event[ev->num].set = set;
-		ev->num++;
-	} else {
-		CONFIG_ERROR("evenbuffer doesn't support > %u events. Update"
-			" the define MAX_EVENT_BUF_NUM \n", MAX_EVENT_BUF_NUM);
-		ASSERT(0);
-	}
-}
-
-s32
-dhd_conf_apply_eventbuffer(dhd_pub_t *dhd, eventmsg_buf_t *ev)
-{
-	char eventmask[WL_EVENTING_MASK_LEN];
-	int i, ret = 0;
-
-	if (!ev || (!ev->num))
-		return -EINVAL;
-
-	/* Read event_msgs mask */
-	ret = dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "event_msgs", eventmask,
-		sizeof(eventmask));
-	if (unlikely(ret)) {
-		CONFIG_ERROR("Get event_msgs error (%d)\n", ret);
-		goto exit;
-	}
-
-	/* apply the set bits */
-	for (i = 0; i < ev->num; i++) {
-		if (ev->event[i].set)
-			setbit(eventmask, ev->event[i].type);
-		else
-			clrbit(eventmask, ev->event[i].type);
-	}
-
-	/* Write updated Event mask */
-	ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs", eventmask,
-		sizeof(eventmask), FALSE);
-	if (unlikely(ret)) {
-		CONFIG_ERROR("Set event_msgs error (%d)\n", ret);
-	}
-
-exit:
-	return ret;
-}
-
-int
-dhd_conf_enable_roam_offload(dhd_pub_t *dhd, int enable)
-{
-	int err;
-	eventmsg_buf_t ev_buf;
-
-	if (dhd->conf->roam_off_suspend)
-		return 0;
-
-	err = dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_offload", enable, 0, FALSE);
-	if (err)
-		return err;
-
-	bzero(&ev_buf, sizeof(eventmsg_buf_t));
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_PSK_SUP, !enable);
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ASSOC_REQ_IE, !enable);
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ASSOC_RESP_IE, !enable);
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_REASSOC, !enable);
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_JOIN, !enable);
-	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ROAM, !enable);
-	err = dhd_conf_apply_eventbuffer(dhd, &ev_buf);
-
-	CONFIG_TRACE("roam_offload %d\n", enable);
-
-	return err;
-}
-
-void
-dhd_conf_set_bw_cap(dhd_pub_t *dhd)
-{
-	struct {
-		u32 band;
-		u32 bw_cap;
-	} param = {0, 0};
-
-	if (dhd->conf->bw_cap[0] >= 0) {
-		memset(&param, 0, sizeof(param));
-		param.band = WLC_BAND_2G;
-		param.bw_cap = (uint)dhd->conf->bw_cap[0];
-		CONFIG_MSG("set bw_cap 2g 0x%x\n", param.bw_cap);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "bw_cap", (char *)&param,
-			sizeof(param), TRUE);
-	}
-
-	if (dhd->conf->bw_cap[1] >= 0) {
-		memset(&param, 0, sizeof(param));
-		param.band = WLC_BAND_5G;
-		param.bw_cap = (uint)dhd->conf->bw_cap[1];
-		CONFIG_MSG("set bw_cap 5g 0x%x\n", param.bw_cap);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "bw_cap", (char *)&param,
-			sizeof(param), TRUE);
-	}
-}
-
-void
-dhd_conf_get_wme(dhd_pub_t *dhd, int ifidx, int mode, edcf_acparam_t *acp)
-{
-	int bcmerror = -1;
-	char iovbuf[WLC_IOCTL_SMLEN];
-	edcf_acparam_t *acparam;
-
-	bzero(iovbuf, sizeof(iovbuf));
-
-	/*
-	 * Get current acparams, using buf as an input buffer.
-	 * Return data is array of 4 ACs of wme params.
-	 */
-	if (mode == 0)
-		bcm_mkiovar("wme_ac_sta", NULL, 0, iovbuf, sizeof(iovbuf));
-	else
-		bcm_mkiovar("wme_ac_ap", NULL, 0, iovbuf, sizeof(iovbuf));
-	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf),
-			FALSE, ifidx)) < 0) {
-		CONFIG_ERROR("wme_ac_sta getting failed %d\n", bcmerror);
-		return;
-	}
-	memcpy((char*)acp, iovbuf, sizeof(edcf_acparam_t)*AC_COUNT);
-
-	acparam = &acp[AC_BK];
-	CONFIG_TRACE("BK: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
-		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
-		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
-		acparam->TXOP);
-	acparam = &acp[AC_BE];
-	CONFIG_TRACE("BE: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
-		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
-		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
-		acparam->TXOP);
-	acparam = &acp[AC_VI];
-	CONFIG_TRACE("VI: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
-		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
-		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
-		acparam->TXOP);
-	acparam = &acp[AC_VO];
-	CONFIG_TRACE("VO: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
-		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
-		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
-		acparam->TXOP);
-
-	return;
-}
-
-void
-dhd_conf_update_wme(dhd_pub_t *dhd, int ifidx, int mode,
-	edcf_acparam_t *acparam_cur, int aci)
-{
-	int aifsn, ecwmin, ecwmax, txop;
-	edcf_acparam_t *acp;
-	struct dhd_conf *conf = dhd->conf;
-	wme_param_t *wme;
-
-	if (mode == 0)
-		wme = &conf->wme_sta;
-	else
-		wme = &conf->wme_ap;
-
-	/* Default value */
-	aifsn = acparam_cur->ACI&EDCF_AIFSN_MASK;
-	ecwmin = acparam_cur->ECW&EDCF_ECWMIN_MASK;
-	ecwmax = (acparam_cur->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT;
-	txop = acparam_cur->TXOP;
-
-	/* Modified value */
-	if (wme->aifsn[aci] > 0)
-		aifsn = wme->aifsn[aci];
-	if (wme->ecwmin[aci] > 0)
-		ecwmin = wme->ecwmin[aci];
-	if (wme->ecwmax[aci] > 0)
-		ecwmax = wme->ecwmax[aci];
-	if (wme->txop[aci] > 0)
-		txop = wme->txop[aci];
-
-	if (!(wme->aifsn[aci] || wme->ecwmin[aci] ||
-			wme->ecwmax[aci] || wme->txop[aci]))
-		return;
-
-	/* Update */
-	acp = acparam_cur;
-	acp->ACI = (acp->ACI & ~EDCF_AIFSN_MASK) | (aifsn & EDCF_AIFSN_MASK);
-	acp->ECW = ((ecwmax << EDCF_ECWMAX_SHIFT) & EDCF_ECWMAX_MASK) | (acp->ECW & EDCF_ECWMIN_MASK);
-	acp->ECW = ((acp->ECW & EDCF_ECWMAX_MASK) | (ecwmin & EDCF_ECWMIN_MASK));
-	acp->TXOP = txop;
-
-	CONFIG_MSG("wme_ac %s aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
-		mode?"ap":"sta", acp->ACI, acp->ACI&EDCF_AIFSN_MASK,
-		acp->ECW&EDCF_ECWMIN_MASK, (acp->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
-		acp->TXOP);
-
-	/*
-	* Now use buf as an output buffer.
-	* Put WME acparams after "wme_ac\0" in buf.
-	* NOTE: only one of the four ACs can be set at a time.
-	*/
-	if (mode == 0)
-		dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "wme_ac_sta", (char *)acp,
-			sizeof(edcf_acparam_t), FALSE);
-	else
-		dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "wme_ac_ap", (char *)acp,
-			sizeof(edcf_acparam_t), FALSE);
-
-}
-
-void
-dhd_conf_set_wme(dhd_pub_t *dhd, int ifidx, int mode)
-{
-	edcf_acparam_t acparam_cur[AC_COUNT];
-
-	if (dhd && dhd->conf) {
-		if (!dhd->conf->force_wme_ac) {
-			CONFIG_TRACE("force_wme_ac is not enabled %d\n",
-				dhd->conf->force_wme_ac);
-			return;
-		}
-
-		CONFIG_TRACE("Before change:\n");
-		dhd_conf_get_wme(dhd, ifidx, mode, acparam_cur);
-
-		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_BK], AC_BK);
-		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_BE], AC_BE);
-		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_VI], AC_VI);
-		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_VO], AC_VO);
-
-		CONFIG_TRACE("After change:\n");
-		dhd_conf_get_wme(dhd, ifidx, mode, acparam_cur);
-	} else {
-		CONFIG_ERROR("dhd or conf is NULL\n");
-	}
-
-	return;
-}
-
-void
-dhd_conf_set_mchan_bw(dhd_pub_t *dhd, int p2p_mode, int miracast_mode)
-{
-	struct dhd_conf *conf = dhd->conf;
-	mchan_params_t *mchan = conf->mchan;
-	bool set = true;
-
-	while (mchan != NULL) {
-		set = true;
-		set &= (mchan->bw >= 0);
-		set &= ((mchan->p2p_mode == -1) | (mchan->p2p_mode == p2p_mode));
-		set &= ((mchan->miracast_mode == -1) | (mchan->miracast_mode == miracast_mode));
-		if (set) {
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "mchan_bw", mchan->bw, 0, FALSE);
-		}
-		mchan = mchan->next;
-	}
-
-	return;
-}
-
-#ifdef PKT_FILTER_SUPPORT
-void
-dhd_conf_add_pkt_filter(dhd_pub_t *dhd)
-{
-	int i, j;
-	char str[16];
-#define MACS "%02x%02x%02x%02x%02x%02x"
-
-	/*
-	 * Filter in less pkt: ARP(0x0806, ID is 105), BRCM(0x886C), 802.1X(0x888E)
-	 *   1) dhd_master_mode=1
-	 *   2) pkt_filter_delete=100, 102, 103, 104, 105, 106, 107
-	 *   3) pkt_filter_add=131 0 0 12 0xFFFF 0x886C, 132 0 0 12 0xFFFF 0x888E
-	 *   4) magic_pkt_filter_add=141 0 1 12
-	 */
-	for(i=0; i<dhd->conf->pkt_filter_add.count; i++) {
-		dhd->pktfilter[i+dhd->pktfilter_count] = dhd->conf->pkt_filter_add.filter[i];
-		CONFIG_MSG("%s\n", dhd->pktfilter[i+dhd->pktfilter_count]);
-	}
-	dhd->pktfilter_count += i;
-
-	if (dhd->conf->magic_pkt_filter_add) {
-		strcat(dhd->conf->magic_pkt_filter_add, " 0x");
-		strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
-		for (j=0; j<16; j++)
-			strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
-		strcat(dhd->conf->magic_pkt_filter_add, " 0x");
-		strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
-		sprintf(str, MACS, MAC2STRDBG(dhd->mac.octet));
-		for (j=0; j<16; j++)
-			strncat(dhd->conf->magic_pkt_filter_add, str, 12);
-		dhd->pktfilter[dhd->pktfilter_count] = dhd->conf->magic_pkt_filter_add;
-		dhd->pktfilter_count += 1;
-	}
-}
-
-bool
-dhd_conf_del_pkt_filter(dhd_pub_t *dhd, uint32 id)
-{
-	int i;
-
-	if (dhd && dhd->conf) {
-		for (i=0; i<dhd->conf->pkt_filter_del.count; i++) {
-			if (id == dhd->conf->pkt_filter_del.id[i]) {
-				CONFIG_MSG("%d\n", dhd->conf->pkt_filter_del.id[i]);
-				return true;
-			}
-		}
-		return false;
-	}
-	return false;
-}
-
-void
-dhd_conf_discard_pkt_filter(dhd_pub_t *dhd)
-{
-	dhd->pktfilter_count = 6;
-	dhd->pktfilter[DHD_UNICAST_FILTER_NUM] = NULL;
-	dhd->pktfilter[DHD_BROADCAST_FILTER_NUM] = "101 0 0 0 0xFFFFFFFFFFFF 0xFFFFFFFFFFFF";
-	dhd->pktfilter[DHD_MULTICAST4_FILTER_NUM] = "102 0 0 0 0xFFFFFF 0x01005E";
-	dhd->pktfilter[DHD_MULTICAST6_FILTER_NUM] = "103 0 0 0 0xFFFF 0x3333";
-	dhd->pktfilter[DHD_MDNS_FILTER_NUM] = NULL;
-	/* Do not enable ARP to pkt filter if dhd_master_mode is false.*/
-	dhd->pktfilter[DHD_ARP_FILTER_NUM] = NULL;
-
-	/* IPv4 broadcast address XXX.XXX.XXX.255 */
-	dhd->pktfilter[dhd->pktfilter_count] = "110 0 0 12 0xFFFF00000000000000000000000000000000000000FF 0x080000000000000000000000000000000000000000FF";
-	dhd->pktfilter_count++;
-	/* discard IPv4 multicast address 224.0.0.0/4 */
-	dhd->pktfilter[dhd->pktfilter_count] = "111 0 0 12 0xFFFF00000000000000000000000000000000F0 0x080000000000000000000000000000000000E0";
-	dhd->pktfilter_count++;
-	/* discard IPv6 multicast address FF00::/8 */
-	dhd->pktfilter[dhd->pktfilter_count] = "112 0 0 12 0xFFFF000000000000000000000000000000000000000000000000FF 0x86DD000000000000000000000000000000000000000000000000FF";
-	dhd->pktfilter_count++;
-	/* discard Netbios pkt */
-	dhd->pktfilter[dhd->pktfilter_count] = "121 0 0 12 0xFFFF000000000000000000FF000000000000000000000000FFFF 0x0800000000000000000000110000000000000000000000000089";
-	dhd->pktfilter_count++;
-
-}
-#endif /* PKT_FILTER_SUPPORT */
-
-int
-dhd_conf_get_pm(dhd_pub_t *dhd)
-{
-	if (dhd && dhd->conf) {
-		return dhd->conf->pm;
-	}
-	return -1;
-}
-
-int
-dhd_conf_check_hostsleep(dhd_pub_t *dhd, int cmd, void *buf, int len,
-	int *hostsleep_set, int *hostsleep_val, int *ret)
-{
-	if (dhd->conf->insuspend & (NO_TXCTL_IN_SUSPEND | WOWL_IN_SUSPEND)) {
-		if (cmd == WLC_SET_VAR) {
-			char *psleep = NULL;
-			psleep = strstr(buf, "hostsleep");
-			if (psleep) {
-				*hostsleep_set = 1;
-				memcpy(hostsleep_val, psleep+strlen("hostsleep")+1, sizeof(int));
-			}
-		}
-		if (dhd->hostsleep && (!*hostsleep_set || *hostsleep_val)) {
-			CONFIG_TRACE("block all none hostsleep clr cmd\n");
-			*ret = BCME_EPERM;
-			goto exit;
-		} else if (*hostsleep_set && *hostsleep_val) {
-			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
-			dhd->hostsleep = *hostsleep_val;
-			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
-				dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
-			}
-			if (dhd->hostsleep == 2) {
-				*ret = 0;
-				goto exit;
-			}
-		} else if (dhd->hostsleep == 2 && !*hostsleep_val) {
-			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
-			dhd->hostsleep = *hostsleep_val;
-			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
-				dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
-			}
-			*ret = 0;
-			goto exit;
-		}
-	}
-
-	return 0;
-exit:
-	return -1;
-}
-
-void
-dhd_conf_get_hostsleep(dhd_pub_t *dhd,
-	int hostsleep_set, int hostsleep_val, int ret)
-{
-	if (dhd->conf->insuspend & (NO_TXCTL_IN_SUSPEND | WOWL_IN_SUSPEND)) {
-		if (hostsleep_set) {
-			if (hostsleep_val && ret) {
-				CONFIG_TRACE("reset hostsleep %d => 0\n", dhd->hostsleep);
-				dhd->hostsleep = 0;
-				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
-					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
-				}
-			} else if (!hostsleep_val && !ret) {
-				CONFIG_TRACE("set hostsleep %d => 0\n", dhd->hostsleep);
-				dhd->hostsleep = 0;
-				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
-					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
-				}
-			}
-		}
-	}
-}
-
-#ifdef WL_EXT_WOWL
-#define WL_WOWL_TCPFIN	(1 << 26)
-typedef struct wl_wowl_pattern2 {
-	char cmd[4];
-	wl_wowl_pattern_t wowl_pattern;
-} wl_wowl_pattern2_t;
-static int
-dhd_conf_wowl_pattern(dhd_pub_t *dhd, bool add, char *data)
-{
-	uint buf_len = 0;
-	int	id, type, polarity, offset;
-	char cmd[4]="\0", mask[128]="\0", pattern[128]="\0", mask_tmp[128]="\0", *pmask_tmp;
-	uint32 masksize, patternsize, pad_len = 0;
-	wl_wowl_pattern2_t *wowl_pattern2 = NULL;
-	char *mask_and_pattern;
-	int ret = 0, i, j, v;
-
-	if (data) {
-		if (add)
-			strcpy(cmd, "add");
-		else
-			strcpy(cmd, "clr");
-		if (!strcmp(cmd, "clr")) {
-			CONFIG_TRACE("wowl_pattern clr\n");
-			ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_pattern", cmd,
-				sizeof(cmd), FALSE);
-			goto exit;
-		}
-		sscanf(data, "%d %d %d %d %s %s", &id, &type, &polarity, &offset,
-			mask_tmp, pattern);
-		masksize = strlen(mask_tmp) -2;
-		CONFIG_TRACE("0 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
-
-		// add pading
-		if (masksize % 16)
-			pad_len = (16 - masksize % 16);
-		for (i=0; i<pad_len; i++)
-			strcat(mask_tmp, "0");
-		masksize += pad_len;
-		CONFIG_TRACE("1 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
-
-		// translate 0x00 to 0, others to 1
-		j = 0;
-		pmask_tmp = &mask_tmp[2];
-		for (i=0; i<masksize/2; i++) {
-			if(strncmp(&pmask_tmp[i*2], "00", 2))
-				pmask_tmp[j] = '1';
-			else
-				pmask_tmp[j] = '0';
-			j++;
-		}
-		pmask_tmp[j] = '\0';
-		masksize = masksize / 2;
-		CONFIG_TRACE("2 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
-
-		// reorder per 8bits
-		pmask_tmp = &mask_tmp[2];
-		for (i=0; i<masksize/8; i++) {
-			char c;
-			for (j=0; j<4; j++) {
-				c = pmask_tmp[i*8+j];
-				pmask_tmp[i*8+j] = pmask_tmp[(i+1)*8-j-1];
-				pmask_tmp[(i+1)*8-j-1] = c;
-			}
-		}
-		CONFIG_TRACE("3 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
-
-		// translate 8bits to 1byte
-		j = 0; v = 0;
-		pmask_tmp = &mask_tmp[2];
-		strcpy(mask, "0x");
-		for (i=0; i<masksize; i++) {
-			v = (v<<1) | (pmask_tmp[i]=='1');
-			if (((i+1)%4) == 0) {
-				if (v < 10)
-					mask[j+2] = v + '0';
-				else
-					mask[j+2] = (v-10) + 'a';
-				j++;
-				v = 0;
-			}
-		}
-		mask[j+2] = '\0';
-		masksize = j/2;
-		CONFIG_TRACE("4 mask=%s, masksize=%d\n", mask, masksize);
-
-		patternsize = (strlen(pattern)-2)/2;
-		buf_len = sizeof(wl_wowl_pattern2_t) + patternsize + masksize;
-		wowl_pattern2 = kmalloc(buf_len, GFP_KERNEL);
-		if (wowl_pattern2 == NULL) {
-			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", buf_len);
-			goto exit;
-		}
-		memset(wowl_pattern2, 0, sizeof(wl_wowl_pattern2_t));
-
-		strncpy(wowl_pattern2->cmd, cmd, sizeof(cmd));
-		wowl_pattern2->wowl_pattern.id = id;
-		wowl_pattern2->wowl_pattern.type = 0;
-		wowl_pattern2->wowl_pattern.offset = offset;
-		mask_and_pattern = (char*)wowl_pattern2 + sizeof(wl_wowl_pattern2_t);
-
-		wowl_pattern2->wowl_pattern.masksize = masksize;
-		ret = wl_pattern_atoh(mask, mask_and_pattern);
-		if (ret == -1) {
-			CONFIG_ERROR("rejecting mask=%s\n", mask);
-			goto exit;
-		}
-
-		mask_and_pattern += wowl_pattern2->wowl_pattern.masksize;
-		wowl_pattern2->wowl_pattern.patternoffset = sizeof(wl_wowl_pattern_t) +
-			wowl_pattern2->wowl_pattern.masksize;
-
-		wowl_pattern2->wowl_pattern.patternsize = patternsize;
-		ret = wl_pattern_atoh(pattern, mask_and_pattern);
-		if (ret == -1) {
-			CONFIG_ERROR("rejecting pattern=%s\n", pattern);
-			goto exit;
-		}
-
-		CONFIG_TRACE("%s %d %s %s\n", cmd, offset, mask, pattern);
-
-		ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_pattern",
-			(char *)wowl_pattern2, buf_len, FALSE);
-	}
-
-exit:
-	if (wowl_pattern2)
-		kfree(wowl_pattern2);
-	return ret;
-}
-
-static int
-dhd_conf_wowl_wakeind(dhd_pub_t *dhd, bool clear)
-{
-	s8 iovar_buf[WLC_IOCTL_SMLEN];
-	wl_wowl_wakeind_t *wake = NULL;
-	int ret = -1;
-	char clr[6]="clear", wakeind_str[32]="\0";
-
-	if (clear) {
-		CONFIG_TRACE("wowl_wakeind clear\n");
-		ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_wakeind",
-			clr, sizeof(clr), 0);
-	} else {
-		ret = dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "wowl_wakeind",
-			iovar_buf, sizeof(iovar_buf));
-		if (!ret) {
-			wake = (wl_wowl_wakeind_t *) iovar_buf;
-			if (wake->ucode_wakeind & WL_WOWL_MAGIC)
-				strcpy(wakeind_str, "(MAGIC packet)");
-			if (wake->ucode_wakeind & WL_WOWL_NET)
-				strcpy(wakeind_str, "(Netpattern)");
-			if (wake->ucode_wakeind & WL_WOWL_DIS)
-				strcpy(wakeind_str, "(Disassoc/Deauth)");
-			if (wake->ucode_wakeind & WL_WOWL_BCN)
-				strcpy(wakeind_str, "(Loss of beacon)");
-			if (wake->ucode_wakeind & WL_WOWL_TCPKEEP_TIME)
-				strcpy(wakeind_str, "(TCPKA timeout)");
-			if (wake->ucode_wakeind & WL_WOWL_TCPKEEP_DATA)
-				strcpy(wakeind_str, "(TCPKA data)");
-			if (wake->ucode_wakeind & WL_WOWL_TCPFIN)
-				strcpy(wakeind_str, "(TCP FIN)");
-			CONFIG_MSG("wakeind=0x%x %s\n", wake->ucode_wakeind, wakeind_str);
-		}
-	}
-
-	return ret;
-}
-#endif
-
-int
-dhd_conf_mkeep_alive(dhd_pub_t *dhd, int ifidx, int id, int period,
-	char *packet, bool bcast)
-{
-	wl_mkeep_alive_pkt_t *mkeep_alive_pktp;
-	int ret = 0, len_bytes=0, buf_len=0;
-	char *buf = NULL, *iovar_buf = NULL;
-	uint8 *pdata;
-
-	CONFIG_TRACE("id=%d, period=%d, packet=%s\n", id, period, packet);
-	if (period >= 0) {
-		buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
-		if (buf == NULL) {
-			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
-			goto exit;
-		}
-		iovar_buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
-		if (iovar_buf == NULL) {
-			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
-			goto exit;
-		}
-		mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *)buf;
-		mkeep_alive_pktp->version = htod16(WL_MKEEP_ALIVE_VERSION);
-		mkeep_alive_pktp->length = htod16(WL_MKEEP_ALIVE_FIXED_LEN);
-		mkeep_alive_pktp->keep_alive_id = id;
-		buf_len += WL_MKEEP_ALIVE_FIXED_LEN;
-		mkeep_alive_pktp->period_msec = period;
-		if (packet && strlen(packet)) {
-			len_bytes = wl_pattern_atoh(packet, (char *)mkeep_alive_pktp->data);
-			buf_len += len_bytes;
-			if (bcast) {
-				memcpy(mkeep_alive_pktp->data, &ether_bcast, ETHER_ADDR_LEN);
-			}
-			ret = dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr",
-				iovar_buf, WLC_IOCTL_SMLEN);
-			if (!ret) {
-				pdata = mkeep_alive_pktp->data;
-				memcpy(pdata+6, iovar_buf, ETHER_ADDR_LEN);
-			}
-		}
-		mkeep_alive_pktp->len_bytes = htod16(len_bytes);
-		ret = dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "mkeep_alive",
-			buf, buf_len, FALSE);
-	}
-
-exit:
-	if (buf)
-		kfree(buf);
-	if (iovar_buf)
-		kfree(iovar_buf);
-	return ret;
-}
-
-#ifdef ARP_OFFLOAD_SUPPORT
-void
-dhd_conf_set_garp(dhd_pub_t *dhd, int ifidx, uint32 ipa, bool enable)
-{
-	int i, len = 0, total_len = WLC_IOCTL_SMLEN;
-	char *iovar_buf = NULL, *packet = NULL;
-
-	if (!dhd->conf->garp || ifidx != 0 || !(dhd->op_mode & DHD_FLAG_STA_MODE))
-		return;
-
-	CONFIG_TRACE("enable=%d\n", enable);
-
-	if (enable) {
-		iovar_buf = kmalloc(total_len, GFP_KERNEL);
-		if (iovar_buf == NULL) {
-			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
-			goto exit;
-		}
-		packet = kmalloc(total_len, GFP_KERNEL);
-		if (packet == NULL) {
-			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
-			goto exit;
-		}
-		dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr", iovar_buf, total_len);
-
-		len += snprintf(packet+len, total_len, "0xffffffffffff");
-		for (i=0; i<ETHER_ADDR_LEN; i++)
-			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
-		len += snprintf(packet+len, total_len, "08060001080006040001");
-		for (i=0; i<ETHER_ADDR_LEN; i++)
-			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
-		len += snprintf(packet+len, total_len, "%02x%02x%02x%02x",
-			ipa&0xff, (ipa>>8)&0xff, (ipa>>16)&0xff, (ipa>>24)&0xff);
-		len += snprintf(packet+len, total_len, "ffffffffffff");
-		len += snprintf(packet+len, total_len, "%02x%02x%02x%02x",
-			ipa&0xff, (ipa>>8)&0xff, (ipa>>16)&0xff, (ipa>>24)&0xff);
-		len += snprintf(packet+len, total_len, "000000000000000000000000000000000000");
-	}
-
-	dhd_conf_mkeep_alive(dhd, ifidx, 0, dhd->conf->keep_alive_period, packet, TRUE);
-
-exit:
-	if (iovar_buf)
-		kfree(iovar_buf);
-	if (packet)
-		kfree(packet);
-	return;
-}
-#endif
-
-uint
-dhd_conf_get_insuspend(dhd_pub_t *dhd, uint mask)
-{
-	uint insuspend = 0;
-
-	if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-		insuspend = dhd->conf->insuspend &
-			(NO_EVENT_IN_SUSPEND | NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND |
-			ROAM_OFFLOAD_IN_SUSPEND | WOWL_IN_SUSPEND);
-	} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
-		insuspend = dhd->conf->insuspend &
-			(NO_EVENT_IN_SUSPEND | NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND |
-			AP_DOWN_IN_SUSPEND | AP_FILTER_IN_SUSPEND);
-	}
-
-	return (insuspend & mask);
-}
-
-#ifdef SUSPEND_EVENT
-void
-dhd_conf_set_suspend_event(dhd_pub_t *dhd, int suspend)
-{
-	struct dhd_conf *conf = dhd->conf;
-	struct ether_addr bssid;
-	char suspend_eventmask[WL_EVENTING_MASK_LEN];
-	wl_event_msg_t msg;
-	int pm;
-#ifdef WL_CFG80211
-	struct net_device *net;
-#endif /* defined(WL_CFG80211) */
-
-	CONFIG_TRACE("Enter\n");
-	if (suspend) {
-#ifdef PROP_TXSTATUS
-#if defined(BCMSDIO) || defined(BCMDBUS)
-		if (dhd->wlfc_enabled) {
-			dhd_wlfc_deinit(dhd);
-			conf->wlfc = TRUE;
-		} else {
-			conf->wlfc = FALSE;
-		}
-#endif /* BCMSDIO || BCMDBUS */
-#endif /* PROP_TXSTATUS */
-		dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "event_msgs",
-			conf->resume_eventmask, sizeof(conf->resume_eventmask));
-		memset(suspend_eventmask, 0, sizeof(suspend_eventmask));
-		setbit(suspend_eventmask, WLC_E_ESCAN_RESULT);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs",
-			suspend_eventmask, sizeof(suspend_eventmask), FALSE);
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			memset(&bssid, 0, ETHER_ADDR_LEN);
-			dhd_wl_ioctl_cmd(dhd, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, FALSE, 0);
-			if (memcmp(&ether_null, &bssid, ETHER_ADDR_LEN))
-				memcpy(&conf->bssid_insuspend, &bssid, ETHER_ADDR_LEN);
-			else
-				memset(&conf->bssid_insuspend, 0, ETHER_ADDR_LEN);
-		}
-	}
-	else {
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs",
-			conf->resume_eventmask, sizeof(conf->resume_eventmask), FALSE);
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			if (memcmp(&ether_null, &conf->bssid_insuspend, ETHER_ADDR_LEN)) {
-				memset(&bssid, 0, ETHER_ADDR_LEN);
-				dhd_wl_ioctl_cmd(dhd, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN,
-					FALSE, 0);
-				if (memcmp(&ether_null, &bssid, ETHER_ADDR_LEN)) {
-					dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", 0, 0, FALSE);
-					dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "send_nulldata",
-						(char *)&bssid, ETHER_ADDR_LEN, FALSE);
-					OSL_SLEEP(100);
-					if (conf->pm >= 0)
-						pm = conf->pm;
-					else
-						pm = PM_FAST;
-					dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
-				} else {
-					CONFIG_TRACE("send WLC_E_DEAUTH_IND event\n");
-					bzero(&msg, sizeof(wl_event_msg_t));
-					memcpy(&msg.addr, &conf->bssid_insuspend, ETHER_ADDR_LEN);
-					msg.event_type = hton32(WLC_E_DEAUTH_IND);
-					msg.status = 0;
-					msg.reason = hton32(DOT11_RC_DEAUTH_LEAVING);
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
-					wl_ext_event_send(dhd->event_params, &msg, NULL);
-#endif
-#ifdef WL_CFG80211
-					net = dhd_idx2net(dhd, 0);
-					if (net) {
-						wl_cfg80211_event(net, &msg, NULL);
-					}
-#endif /* defined(WL_CFG80211) */
-				}
-			}
-#ifdef PROP_TXSTATUS
-#if defined(BCMSDIO) || defined(BCMDBUS)
-			if (conf->wlfc) {
-				dhd_wlfc_init(dhd);
-				dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
-			}
-#endif
-#endif /* PROP_TXSTATUS */
-		}
-	}
-
-}
-#endif
-
-#if defined(WL_CFG80211) || defined(WL_ESCAN)
-static void
-dhd_conf_wait_event_complete(struct dhd_pub *dhd, int ifidx)
-{
-	s32 timeout = -1;
-
-	timeout = wait_event_interruptible_timeout(dhd->conf->event_complete,
-		wl_ext_event_complete(dhd, ifidx), msecs_to_jiffies(10000));
-	if (timeout <= 0 || !wl_ext_event_complete(dhd, ifidx)) {
-		wl_ext_event_complete(dhd, ifidx);
-		CONFIG_ERROR("timeout\n");
-	}
-}
-#endif
-
-int
-dhd_conf_set_suspend_resume(dhd_pub_t *dhd, int suspend)
-{
-	struct dhd_conf *conf = dhd->conf;
-	uint insuspend = 0;
-	int pm;
-#ifdef BCMSDIO
-	uint32 intstatus = 0;
-	int ret = 0;
-#endif
-#ifdef WL_EXT_WOWL
-	int i;
-#endif
-
-	insuspend = dhd_conf_get_insuspend(dhd, ALL_IN_SUSPEND);
-	if (insuspend)
-		CONFIG_MSG("op_mode %d, suspend %d, suspended %d, insuspend 0x%x, suspend_mode=%d\n",
-			dhd->op_mode, suspend, conf->suspended, insuspend, conf->suspend_mode);
-
-#ifdef DHD_LOAD_CHIPALIVE
-	if ((conf->suspended == suspend || !dhd->up) && dhd_chip_alive == 0)
-#else
-	if (conf->suspended == suspend || !dhd->up)
-#endif
-	{
-		return 0;
-	}
-
-	if (suspend) {
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
-				dhd->conf->roam_off_suspend, 0, FALSE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim",
-				dhd->conf->suspend_bcn_li_dtim, 0, FALSE);
-			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
-				dhd_conf_enable_roam_offload(dhd, 2);
-		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
-			if (insuspend & AP_DOWN_IN_SUSPEND) {
-				dhd_conf_set_intiovar(dhd, WLC_DOWN, "WLC_DOWN", 1, 0, FALSE);
-			}
-		}
-#if defined(WL_CFG80211) || defined(WL_ESCAN)
-		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
-			if (conf->suspend_mode == PM_NOTIFIER)
-				dhd_conf_wait_event_complete(dhd, 0);
-		}
-#endif
-		if (insuspend & NO_TXDATA_IN_SUSPEND) {
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
-		}
-#if defined(WL_CFG80211) || defined(WL_ESCAN)
-		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
-			if (conf->suspend_mode == PM_NOTIFIER)
-				wl_ext_user_sync(dhd, 0, TRUE);
-		}
-#endif
-#ifdef SUSPEND_EVENT
-		if (insuspend & NO_EVENT_IN_SUSPEND) {
-			dhd_conf_set_suspend_event(dhd, suspend);
-		}
-#endif
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			if (conf->pm_in_suspend >= 0)
-				pm = conf->pm_in_suspend;
-			else if (conf->pm >= 0)
-				pm = conf->pm;
-			else
-				pm = PM_FAST;
-			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
-		}
-		dhd_conf_set_wl_cmd(dhd, conf->wl_suspend, FALSE);
-#ifdef WL_EXT_WOWL
-		if ((insuspend & WOWL_IN_SUSPEND) && dhd_master_mode) {
-			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
-			for(i=0; i<conf->pkt_filter_add.count; i++) {
-				dhd_conf_wowl_pattern(dhd, TRUE, conf->pkt_filter_add.filter[i]);
-			}
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl", conf->wowl, 0, FALSE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl_activate", 1, 0, FALSE);
-			dhd_conf_wowl_wakeind(dhd, TRUE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 1, 0, FALSE);
-#ifdef BCMSDIO
-			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
-			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
-#endif
-		} else
-#endif
-		if (insuspend & NO_TXCTL_IN_SUSPEND) {
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 2, 0, FALSE);
-#ifdef BCMSDIO
-			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
-			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
-#endif
-		}
-		conf->suspended = TRUE;
-	} else {
-		if (insuspend & (WOWL_IN_SUSPEND | NO_TXCTL_IN_SUSPEND)) {
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 0, 0, FALSE);
-		}
-#ifdef WL_EXT_WOWL
-		if (insuspend & WOWL_IN_SUSPEND) {
-			dhd_conf_wowl_wakeind(dhd, FALSE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl_activate", 0, 0, FALSE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl", 0, 0, FALSE);
-			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
-		}
-#endif
-		dhd_conf_set_wl_cmd(dhd, conf->wl_resume, FALSE);
-		dhd_conf_get_iovar(dhd, 0, WLC_GET_PM, "WLC_GET_PM", (char *)&pm, sizeof(pm));
-		CONFIG_TRACE("PM in suspend = %d\n", pm);
-#ifdef SUSPEND_EVENT
-		if (insuspend & NO_EVENT_IN_SUSPEND) {
-			dhd_conf_set_suspend_event(dhd, suspend);
-		}
-#endif
-#if defined(WL_CFG80211) || defined(WL_ESCAN)
-		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
-			if (conf->suspend_mode == PM_NOTIFIER)
-				wl_ext_user_sync(dhd, 0, FALSE);
-		}
-#endif
-		if (insuspend & NO_TXDATA_IN_SUSPEND) {
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
-		}
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
-				dhd_conf_enable_roam_offload(dhd, 0);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim", 0, 0, FALSE);
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
-				dhd->conf->roam_off, 0, FALSE);
-		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
-			if (insuspend & AP_DOWN_IN_SUSPEND) {
-				dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
-			}
-		}
-		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
-			if (conf->pm >= 0)
-				pm = conf->pm;
-			else
-				pm = PM_FAST;
-			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
-		}
-		conf->suspended = FALSE;
-	}
-
-	return 0;
-}
-
-#ifdef PROP_TXSTATUS
-int
-dhd_conf_get_disable_proptx(dhd_pub_t *dhd)
-{
-	struct dhd_conf *conf = dhd->conf;
-	int disable_proptx = -1;
-	int fw_proptx = 0;
-
-	/* check fw proptx priority:
-	  * 1st: check fw support by wl cap
-	  * 2nd: 4334/43340/43341/43241 support proptx but not show in wl cap, so enable it by default
-	  * 	   if you would like to disable it, please set disable_proptx=1 in config.txt
-	  * 3th: disable when proptxstatus not support in wl cap
-	  */
-	if (FW_SUPPORTED(dhd, proptxstatus)) {
-		fw_proptx = 1;
-	} else if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
-			dhd->conf->chip == BCM43340_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		fw_proptx = 1;
-	} else {
-		fw_proptx = 0;
-	}
-
-	/* returned disable_proptx value:
-	  * -1: disable in STA and enable in P2P(follow original dhd settings when PROP_TXSTATUS_VSDB enabled)
-	  * 0: depend on fw support
-	  * 1: always disable proptx
-	  */
-	if (conf->disable_proptx == 0) {
-		// check fw support as well
-		if (fw_proptx)
-			disable_proptx = 0;
-		else
-			disable_proptx = 1;
-	} else if (conf->disable_proptx >= 1) {
-		disable_proptx = 1;
-	} else {
-		// check fw support as well
-		if (fw_proptx)
-			disable_proptx = -1;
-		else
-			disable_proptx = 1;
-	}
-
-	CONFIG_MSG("fw_proptx=%d, disable_proptx=%d\n", fw_proptx, disable_proptx);
-
-	return disable_proptx;
-}
-#endif
-
-uint
-pick_config_vars(char *varbuf, uint len, uint start_pos, char *pickbuf, int picklen)
-{
-	bool findNewline, changenewline=FALSE, pick=FALSE;
-	int column;
-	uint n, pick_column=0;
-
-	findNewline = FALSE;
-	column = 0;
-
-	if (start_pos >= len) {
-		CONFIG_ERROR("wrong start pos\n");
-		return 0;
-	}
-
-	for (n = start_pos; n < len; n++) {
-		if (varbuf[n] == '\r')
-			continue;
-		if ((findNewline || changenewline) && varbuf[n] != '\n')
-			continue;
-		findNewline = FALSE;
-		if (varbuf[n] == '#') {
-			findNewline = TRUE;
-			continue;
-		}
-		if (varbuf[n] == '\\') {
-			changenewline = TRUE;
-			continue;
-		}
-		if (!changenewline && varbuf[n] == '\n') {
-			if (column == 0)
-				continue;
-			column = 0;
-			continue;
-		}
-		if (changenewline && varbuf[n] == '\n') {
-			changenewline = FALSE;
-			continue;
-		}
-
-		if (column==0 && !pick) { // start to pick
-			pick = TRUE;
-			column++;
-			pick_column = 0;
-		} else {
-			if (pick && column==0) { // stop to pick
-				pick = FALSE;
-				break;
-			} else
-				column++;
-		}
-		if (pick) {
-			if (varbuf[n] == 0x9)
-				continue;
-			if (pick_column >= picklen)
-				break;
-			pickbuf[pick_column] = varbuf[n];
-			pick_column++;
-		}
-	}
-
-	return n; // return current position
-}
-
-bool
-dhd_conf_read_chiprev(dhd_pub_t *dhd, int *chip_match,
-	char *full_param, uint len_param)
-{
-	char *data = full_param+len_param, *pick_tmp, *pch;
-	uint chip = 0, rev = 0;
-
-	/* Process chip, regrev:
-	 * chip=[chipid], rev==[rev]
-	 * Ex: chip=0x4359, rev=9
-	 */
-	if (!strncmp("chip=", full_param, len_param)) {
-		chip = (int)simple_strtol(data, NULL, 0);
-		pick_tmp = data;
-		pch = bcmstrstr(pick_tmp, "rev=");
-		if (pch) {
-			rev = (int)simple_strtol(pch+strlen("rev="), NULL, 0);
-		}
-		if (chip == dhd->conf->chip && rev == dhd->conf->chiprev)
-			*chip_match = 1;
-		else
-			*chip_match = 0;
-		CONFIG_MSG("chip=0x%x, rev=%d, chip_match=%d\n", chip, rev, *chip_match);
-	}
-
-	return TRUE;
-}
-
-bool
-dhd_conf_read_log_level(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	char *data = full_param+len_param;
-
-	if (!strncmp("dhd_msg_level=", full_param, len_param)) {
-		dhd_msg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("dhd_msg_level = 0x%X\n", dhd_msg_level);
-	}
-	else if (!strncmp("dump_msg_level=", full_param, len_param)) {
-		dump_msg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("dump_msg_level = 0x%X\n", dump_msg_level);
-	}
-#ifdef BCMSDIO
-	else if (!strncmp("sd_msglevel=", full_param, len_param)) {
-		sd_msglevel = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("sd_msglevel = 0x%X\n", sd_msglevel);
-	}
-#endif
-#ifdef BCMDBUS
-	else if (!strncmp("dbus_msglevel=", full_param, len_param)) {
-		dbus_msglevel = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("dbus_msglevel = 0x%X\n", dbus_msglevel);
-	}
-#endif
-	else if (!strncmp("android_msg_level=", full_param, len_param)) {
-		android_msg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("android_msg_level = 0x%X\n", android_msg_level);
-	}
-	else if (!strncmp("config_msg_level=", full_param, len_param)) {
-		config_msg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("config_msg_level = 0x%X\n", config_msg_level);
-	}
-#ifdef WL_CFG80211
-	else if (!strncmp("wl_dbg_level=", full_param, len_param)) {
-		wl_dbg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("wl_dbg_level = 0x%X\n", wl_dbg_level);
-	}
-#endif
-#if defined(WL_WIRELESS_EXT)
-	else if (!strncmp("iw_msg_level=", full_param, len_param)) {
-		iw_msg_level = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("iw_msg_level = 0x%X\n", iw_msg_level);
-	}
-#endif
-#if defined(DHD_DEBUG)
-	else if (!strncmp("dhd_console_ms=", full_param, len_param)) {
-		dhd_console_ms = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("dhd_console_ms = 0x%X\n", dhd_console_ms);
-	}
-#endif
-	else
-		return false;
-
-	return true;
-}
-
-void
-dhd_conf_read_wme_ac_value(wme_param_t *wme, char *pick, int ac_val)
-{
-	char *pick_tmp, *pch;
-
-	pick_tmp = pick;
-	pch = bcmstrstr(pick_tmp, "aifsn ");
-	if (pch) {
-		wme->aifsn[ac_val] = (int)simple_strtol(pch+strlen("aifsn "), NULL, 0);
-		CONFIG_MSG("ac_val=%d, aifsn=%d\n", ac_val, wme->aifsn[ac_val]);
-	}
-	pick_tmp = pick;
-	pch = bcmstrstr(pick_tmp, "ecwmin ");
-	if (pch) {
-		wme->ecwmin[ac_val] = (int)simple_strtol(pch+strlen("ecwmin "), NULL, 0);
-		CONFIG_MSG("ac_val=%d, ecwmin=%d\n", ac_val, wme->ecwmin[ac_val]);
-	}
-	pick_tmp = pick;
-	pch = bcmstrstr(pick_tmp, "ecwmax ");
-	if (pch) {
-		wme->ecwmax[ac_val] = (int)simple_strtol(pch+strlen("ecwmax "), NULL, 0);
-		CONFIG_MSG("ac_val=%d, ecwmax=%d\n", ac_val, wme->ecwmax[ac_val]);
-	}
-	pick_tmp = pick;
-	pch = bcmstrstr(pick_tmp, "txop ");
-	if (pch) {
-		wme->txop[ac_val] = (int)simple_strtol(pch+strlen("txop "), NULL, 0);
-		CONFIG_MSG("ac_val=%d, txop=0x%x\n", ac_val, wme->txop[ac_val]);
-	}
-
-}
-
-bool
-dhd_conf_read_wme_ac_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	// wme_ac_sta_be=aifsn 1 ecwmin 2 ecwmax 3 txop 0x5e
-	// wme_ac_sta_vo=aifsn 1 ecwmin 1 ecwmax 1 txop 0x5e
-
-	if (!strncmp("force_wme_ac=", full_param, len_param)) {
-		conf->force_wme_ac = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("force_wme_ac = %d\n", conf->force_wme_ac);
-	}
-	else if (!strncmp("wme_ac_sta_be=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_BE);
-	}
-	else if (!strncmp("wme_ac_sta_bk=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_BK);
-	}
-	else if (!strncmp("wme_ac_sta_vi=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_VI);
-	}
-	else if (!strncmp("wme_ac_sta_vo=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_VO);
-	}
-	else if (!strncmp("wme_ac_ap_be=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_BE);
-	}
-	else if (!strncmp("wme_ac_ap_bk=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_BK);
-	}
-	else if (!strncmp("wme_ac_ap_vi=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_VI);
-	}
-	else if (!strncmp("wme_ac_ap_vo=", full_param, len_param)) {
-		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_VO);
-	}
-	else
-		return false;
-
-	return true;
-}
-
-#ifdef BCMSDIO
-bool
-dhd_conf_read_fw_by_mac(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	int i, j;
-	char *pch, *pick_tmp;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	/* Process fw_by_mac:
-	 * fw_by_mac=[fw_mac_num] \
-	 *  [fw_name1] [mac_num1] [oui1-1] [nic_start1-1] [nic_end1-1] \
-	 *                                    [oui1-1] [nic_start1-1] [nic_end1-1]... \
-	 *                                    [oui1-n] [nic_start1-n] [nic_end1-n] \
-	 *  [fw_name2] [mac_num2] [oui2-1] [nic_start2-1] [nic_end2-1] \
-	 *                                    [oui2-1] [nic_start2-1] [nic_end2-1]... \
-	 *                                    [oui2-n] [nic_start2-n] [nic_end2-n] \
-	 * Ex: fw_by_mac=2 \
-	 *  fw_bcmdhd1.bin 2 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
-	 *  fw_bcmdhd2.bin 3 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
-	 *                           0x983B16 0x916157 0x916487
-	 */
-
-	if (!strncmp("fw_by_mac=", full_param, len_param)) {
-		dhd_conf_free_mac_list(&conf->fw_by_mac);
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->fw_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->fw_by_mac.count,
-				GFP_KERNEL))) {
-			conf->fw_by_mac.count = 0;
-			CONFIG_ERROR("kmalloc failed\n");
-		}
-		CONFIG_MSG("fw_count=%d\n", conf->fw_by_mac.count);
-		conf->fw_by_mac.m_mac_list_head = mac_list;
-		for (i=0; i<conf->fw_by_mac.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(mac_list[i].name, pch);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
-			CONFIG_MSG("name=%s, mac_count=%d\n",
-				mac_list[i].name, mac_list[i].count);
-			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count,
-					GFP_KERNEL))) {
-				mac_list[i].count = 0;
-				CONFIG_ERROR("kmalloc failed\n");
-				break;
-			}
-			mac_list[i].mac = mac_range;
-			for (j=0; j<mac_list[i].count; j++) {
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
-				CONFIG_MSG("oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
-					mac_range[j].oui, mac_range[j].nic_start, mac_range[j].nic_end);
-			}
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-
-bool
-dhd_conf_read_nv_by_mac(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	int i, j;
-	char *pch, *pick_tmp;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	/* Process nv_by_mac:
-	 * [nv_by_mac]: The same format as fw_by_mac
-	 */
-	if (!strncmp("nv_by_mac=", full_param, len_param)) {
-		dhd_conf_free_mac_list(&conf->nv_by_mac);
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->nv_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_mac.count,
-				GFP_KERNEL))) {
-			conf->nv_by_mac.count = 0;
-			CONFIG_ERROR("kmalloc failed\n");
-		}
-		CONFIG_MSG("nv_count=%d\n", conf->nv_by_mac.count);
-		conf->nv_by_mac.m_mac_list_head = mac_list;
-		for (i=0; i<conf->nv_by_mac.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(mac_list[i].name, pch);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
-			CONFIG_MSG("name=%s, mac_count=%d\n",
-				mac_list[i].name, mac_list[i].count);
-			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count,
-					GFP_KERNEL))) {
-				mac_list[i].count = 0;
-				CONFIG_ERROR("kmalloc failed\n");
-				break;
-			}
-			mac_list[i].mac = mac_range;
-			for (j=0; j<mac_list[i].count; j++) {
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
-				CONFIG_MSG("oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
-					mac_range[j].oui, mac_range[j].nic_start, mac_range[j].nic_end);
-			}
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-bool
-dhd_conf_read_nv_by_chip(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	int i;
-	char *pch, *pick_tmp;
-	wl_chip_nv_path_t *chip_nv_path;
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	/* Process nv_by_chip:
-	 * nv_by_chip=[nv_chip_num] \
-	 *  [chip1] [chiprev1] [nv_name1] [chip2] [chiprev2] [nv_name2] \
-	 * Ex: nv_by_chip=2 \
-	 *  43430 0 nvram_ap6212.txt 43430 1 nvram_ap6212a.txt \
-	 */
-	if (!strncmp("nv_by_chip=", full_param, len_param)) {
-		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->nv_by_chip.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(chip_nv_path = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_chip.count,
-				GFP_KERNEL))) {
-			conf->nv_by_chip.count = 0;
-			CONFIG_ERROR("kmalloc failed\n");
-		}
-		CONFIG_MSG("nv_by_chip_count=%d\n", conf->nv_by_chip.count);
-		conf->nv_by_chip.m_chip_nv_path_head = chip_nv_path;
-		for (i=0; i<conf->nv_by_chip.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			chip_nv_path[i].chip = (uint32)simple_strtol(pch, NULL, 0);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			chip_nv_path[i].chiprev = (uint32)simple_strtol(pch, NULL, 0);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(chip_nv_path[i].name, pch);
-			CONFIG_MSG("chip=0x%x, chiprev=%d, name=%s\n",
-				chip_nv_path[i].chip, chip_nv_path[i].chiprev, chip_nv_path[i].name);
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-
-bool
-dhd_conf_read_roam_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	if (!strncmp("roam_off=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->roam_off = 0;
-		else
-			conf->roam_off = 1;
-		CONFIG_MSG("roam_off = %d\n", conf->roam_off);
-	}
-	else if (!strncmp("roam_off_suspend=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->roam_off_suspend = 0;
-		else
-			conf->roam_off_suspend = 1;
-		CONFIG_MSG("roam_off_suspend = %d\n", conf->roam_off_suspend);
-	}
-	else if (!strncmp("roam_trigger=", full_param, len_param)) {
-		conf->roam_trigger[0] = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("roam_trigger = %d\n", conf->roam_trigger[0]);
-	}
-	else if (!strncmp("roam_scan_period=", full_param, len_param)) {
-		conf->roam_scan_period[0] = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("roam_scan_period = %d\n", conf->roam_scan_period[0]);
-	}
-	else if (!strncmp("roam_delta=", full_param, len_param)) {
-		conf->roam_delta[0] = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("roam_delta = %d\n", conf->roam_delta[0]);
-	}
-	else if (!strncmp("fullroamperiod=", full_param, len_param)) {
-		conf->fullroamperiod = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("fullroamperiod = %d\n", conf->fullroamperiod);
-	} else
-		return false;
-
-	return true;
-}
-
-bool
-dhd_conf_read_country(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	country_list_t *country_next = NULL, *country;
-	int i, count = 0;
-	char *pch, *pick_tmp, *pick_tmp2;
-	char *data = full_param+len_param;
-	uint len_data = strlen(data);
-
-	/* Process country_list:
-	 * country_list=[country1]:[ccode1]/[regrev1],
-	 * [country2]:[ccode2]/[regrev2] \
-	 * Ex: country_list=US:US/0, TW:TW/1
-	 */
-	if (!strncmp("ccode=", full_param, len_param)) {
-		len_data = min((uint)WLC_CNTRY_BUF_SZ, len_data);
-		memset(&conf->cspec, 0, sizeof(wl_country_t));
-		memcpy(conf->cspec.country_abbrev, data, len_data);
-		memcpy(conf->cspec.ccode, data, len_data);
-		CONFIG_MSG("ccode = %s\n", conf->cspec.ccode);
-	}
-	else if (!strncmp("regrev=", full_param, len_param)) {
-		conf->cspec.rev = (int32)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("regrev = %d\n", conf->cspec.rev);
-	}
-	else if (!strncmp("country_list=", full_param, len_param)) {
-		dhd_conf_free_country_list(conf);
-		pick_tmp = data;
-		for (i=0; i<CONFIG_COUNTRY_LIST_SIZE; i++) {
-			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
-			if (!pick_tmp2)
-				break;
-			pch = bcmstrtok(&pick_tmp2, ":", 0);
-			if (!pch)
-				break;
-			country = NULL;
-			if (!(country = kmalloc(sizeof(country_list_t), GFP_KERNEL))) {
-				CONFIG_ERROR("kmalloc failed\n");
-				break;
-			}
-			memset(country, 0, sizeof(country_list_t));
-
-			memcpy(country->cspec.country_abbrev, pch, 2);
-			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch) {
-				kfree(country);
-				break;
-			}
-			memcpy(country->cspec.ccode, pch, 2);
-			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch) {
-				kfree(country);
-				break;
-			}
-			country->cspec.rev = (int32)simple_strtol(pch, NULL, 10);
-			count++;
-			if (!conf->country_head) {
-				conf->country_head = country;
-				country_next = country;
-			} else {
-				country_next->next = country;
-				country_next = country;
-			}
-			CONFIG_TRACE("abbrev=%s, ccode=%s, regrev=%d\n",
-				country->cspec.country_abbrev, country->cspec.ccode, country->cspec.rev);
-		}
-		CONFIG_MSG("%d country in list\n", count);
-	}
-	else
-		return false;
-
-	return true;
-}
-
-bool
-dhd_conf_read_mchan_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	int i;
-	char *pch, *pick_tmp, *pick_tmp2;
-	struct dhd_conf *conf = dhd->conf;
-	mchan_params_t *mchan_next = NULL, *mchan;
-	char *data = full_param+len_param;
-
-	/* Process mchan_bw:
-	 * mchan_bw=[val]/[any/go/gc]/[any/source/sink]
-	 * Ex: mchan_bw=80/go/source, 30/gc/sink
-	 */
-	if (!strncmp("mchan_bw=", full_param, len_param)) {
-		dhd_conf_free_mchan_list(conf);
-		pick_tmp = data;
-		for (i=0; i<MCHAN_MAX_NUM; i++) {
-			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
-			if (!pick_tmp2)
-				break;
-			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch)
-				break;
-
-			mchan = NULL;
-			if (!(mchan = kmalloc(sizeof(mchan_params_t), GFP_KERNEL))) {
-				CONFIG_ERROR("kmalloc failed\n");
-				break;
-			}
-			memset(mchan, 0, sizeof(mchan_params_t));
-
-			mchan->bw = (int)simple_strtol(pch, NULL, 0);
-			if (mchan->bw < 0 || mchan->bw > 100) {
-				CONFIG_ERROR("wrong bw %d\n", mchan->bw);
-				kfree(mchan);
-				break;
-			}
-
-			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch) {
-				kfree(mchan);
-				break;
-			} else {
-				if (bcmstrstr(pch, "any")) {
-					mchan->p2p_mode = -1;
-				} else if (bcmstrstr(pch, "go")) {
-					mchan->p2p_mode = WL_P2P_IF_GO;
-				} else if (bcmstrstr(pch, "gc")) {
-					mchan->p2p_mode = WL_P2P_IF_CLIENT;
-				}
-			}
-			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch) {
-				kfree(mchan);
-				break;
-			} else {
-				if (bcmstrstr(pch, "any")) {
-					mchan->miracast_mode = -1;
-				} else if (bcmstrstr(pch, "source")) {
-					mchan->miracast_mode = MIRACAST_SOURCE;
-				} else if (bcmstrstr(pch, "sink")) {
-					mchan->miracast_mode = MIRACAST_SINK;
-				}
-			}
-			if (!conf->mchan) {
-				conf->mchan = mchan;
-				mchan_next = mchan;
-			} else {
-				mchan_next->next = mchan;
-				mchan_next = mchan;
-			}
-			CONFIG_TRACE("mchan_bw=%d/%d/%d\n", mchan->bw,mchan->p2p_mode,
-				mchan->miracast_mode);
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-
-#ifdef PKT_FILTER_SUPPORT
-bool
-dhd_conf_read_pkt_filter(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-	char *pch, *pick_tmp;
-	int i;
-
-	/* Process pkt filter:
-	 * 1) pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
-	 * 2) pkt_filter_delete=100, 102, 103, 104, 105
-	 * 3) magic_pkt_filter_add=141 0 1 12
-	 */
-	if (!strncmp("dhd_master_mode=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			dhd_master_mode = FALSE;
-		else
-			dhd_master_mode = TRUE;
-		CONFIG_MSG("dhd_master_mode = %d\n", dhd_master_mode);
-	}
-	else if (!strncmp("pkt_filter_add=", full_param, len_param)) {
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, ",.-", 0);
-		i=0;
-		while (pch != NULL && i<DHD_CONF_FILTER_MAX) {
-			strcpy(&conf->pkt_filter_add.filter[i][0], pch);
-			CONFIG_MSG("pkt_filter_add[%d][] = %s\n",
-				i, &conf->pkt_filter_add.filter[i][0]);
-			pch = bcmstrtok(&pick_tmp, ",.-", 0);
-			i++;
-		}
-		conf->pkt_filter_add.count = i;
-	}
-	else if (!strncmp("pkt_filter_delete=", full_param, len_param) ||
-			!strncmp("pkt_filter_del=", full_param, len_param)) {
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-		i=0;
-		while (pch != NULL && i<DHD_CONF_FILTER_MAX) {
-			conf->pkt_filter_del.id[i] = (uint32)simple_strtol(pch, NULL, 10);
-			pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-			i++;
-		}
-		conf->pkt_filter_del.count = i;
-		CONFIG_MSG("pkt_filter_del id = ");
-		for (i=0; i<conf->pkt_filter_del.count; i++)
-			printf("%d ", conf->pkt_filter_del.id[i]);
-		printf("\n");
-	}
-	else if (!strncmp("magic_pkt_filter_add=", full_param, len_param)) {
-		if (conf->magic_pkt_filter_add) {
-			kfree(conf->magic_pkt_filter_add);
-			conf->magic_pkt_filter_add = NULL;
-		}
-		if (!(conf->magic_pkt_filter_add = kmalloc(MAGIC_PKT_FILTER_LEN, GFP_KERNEL))) {
-			CONFIG_ERROR("kmalloc failed\n");
-		} else {
-			memset(conf->magic_pkt_filter_add, 0, MAGIC_PKT_FILTER_LEN);
-			strcpy(conf->magic_pkt_filter_add, data);
-			CONFIG_MSG("magic_pkt_filter_add = %s\n", conf->magic_pkt_filter_add);
-		}
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-#ifdef ISAM_PREINIT
-#if !defined(WL_EXT_IAPSTA)
-#error "WL_EXT_IAPSTA should be defined to enable ISAM_PREINIT"
-#endif /* !WL_EXT_IAPSTA */
-/*
- * isam_init=mode [sta|ap|apsta|dualap] vifname [wlan1]
- * isam_config=ifname [wlan0|wlan1] ssid [xxx] chan [x]
-		 hidden [y|n] maxassoc [x]
-		 amode [open|shared|wpapsk|wpa2psk|wpawpa2psk]
-		 emode [none|wep|tkip|aes|tkipaes]
-		 key [xxxxx]
- * isam_enable=ifname [wlan0|wlan1]
-*/
-bool
-dhd_conf_read_isam(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	if (!strncmp("isam_init=", full_param, len_param)) {
-		sprintf(conf->isam_init, "isam_init %s", data);
-		CONFIG_MSG("isam_init=%s\n", conf->isam_init);
-	}
-	else if (!strncmp("isam_config=", full_param, len_param)) {
-		sprintf(conf->isam_config, "isam_config %s", data);
-		CONFIG_MSG("isam_config=%s\n", conf->isam_config);
-	}
-	else if (!strncmp("isam_enable=", full_param, len_param)) {
-		sprintf(conf->isam_enable, "isam_enable %s", data);
-		CONFIG_MSG("isam_enable=%s\n", conf->isam_enable);
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-#ifdef IDHCP
-bool
-dhd_conf_read_dhcp_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-	struct ipv4_addr ipa_set;
-
-	if (!strncmp("dhcpc_enable=", full_param, len_param)) {
-		conf->dhcpc_enable = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhcpc_enable = %d\n", conf->dhcpc_enable);
-	}
-	else if (!strncmp("dhcpd_enable=", full_param, len_param)) {
-		conf->dhcpd_enable = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhcpd_enable = %d\n", conf->dhcpd_enable);
-	}
-	else if (!strncmp("dhcpd_ip_addr=", full_param, len_param)) {
-		if (!bcm_atoipv4(data, &ipa_set)) {
-			CONFIG_ERROR("dhcpd_ip_addr adress setting failed.n");
-			return false;
-		}
-		memcpy(&conf->dhcpd_ip_addr, &ipa_set, sizeof(struct ipv4_addr));
-		CONFIG_MSG("dhcpd_ip_addr = %s\n", data);
-	}
-	else if (!strncmp("dhcpd_ip_mask=", full_param, len_param)) {
-		if (!bcm_atoipv4(data, &ipa_set)) {
-			CONFIG_ERROR("dhcpd_ip_mask adress setting failed\n");
-			return false;
-		}
-		memcpy(&conf->dhcpd_ip_mask, &ipa_set, sizeof(struct ipv4_addr));
-		CONFIG_MSG("dhcpd_ip_mask = %s\n", data);
-	}
-	else if (!strncmp("dhcpd_ip_start=", full_param, len_param)) {
-		if (!bcm_atoipv4(data, &ipa_set)) {
-			CONFIG_ERROR("dhcpd_ip_start adress setting failed\n");
-			return false;
-		}
-		memcpy(&conf->dhcpd_ip_start, &ipa_set, sizeof(struct ipv4_addr));
-		CONFIG_MSG("dhcpd_ip_start = %s\n", data);
-	}
-	else if (!strncmp("dhcpd_ip_end=", full_param, len_param)) {
-		if (!bcm_atoipv4(data, &ipa_set)) {
-			CONFIG_ERROR("dhcpd_ip_end adress setting failed\n");
-			return false;
-		}
-		memcpy(&conf->dhcpd_ip_end, &ipa_set, sizeof(struct ipv4_addr));
-		CONFIG_MSG("dhcpd_ip_end = %s\n", data);
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-#ifdef BCMSDIO
-bool
-dhd_conf_read_sdio_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	if (!strncmp("dhd_doflow=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			dhd_doflow = FALSE;
-		else
-			dhd_doflow = TRUE;
-		CONFIG_MSG("dhd_doflow = %d\n", dhd_doflow);
-	}
-	else if (!strncmp("dhd_slpauto=", full_param, len_param) ||
-			!strncmp("kso_enable=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			dhd_slpauto = FALSE;
-		else
-			dhd_slpauto = TRUE;
-		CONFIG_MSG("dhd_slpauto = %d\n", dhd_slpauto);
-	}
-	else if (!strncmp("use_rxchain=", full_param, len_param)) {
-		conf->use_rxchain = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("use_rxchain = %d\n", conf->use_rxchain);
-	}
-	else if (!strncmp("dhd_txminmax=", full_param, len_param)) {
-		conf->dhd_txminmax = (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhd_txminmax = %d\n", conf->dhd_txminmax);
-	}
-	else if (!strncmp("txinrx_thres=", full_param, len_param)) {
-		conf->txinrx_thres = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("txinrx_thres = %d\n", conf->txinrx_thres);
-	}
-#if defined(HW_OOB)
-	else if (!strncmp("oob_enabled_later=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->oob_enabled_later = FALSE;
-		else
-			conf->oob_enabled_later = TRUE;
-		CONFIG_MSG("oob_enabled_later = %d\n", conf->oob_enabled_later);
-	}
-#endif
-	else if (!strncmp("dpc_cpucore=", full_param, len_param)) {
-		conf->dpc_cpucore = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dpc_cpucore = %d\n", conf->dpc_cpucore);
-	}
-	else if (!strncmp("rxf_cpucore=", full_param, len_param)) {
-		conf->rxf_cpucore = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("rxf_cpucore = %d\n", conf->rxf_cpucore);
-	}
-#if defined(BCMSDIOH_TXGLOM)
-	else if (!strncmp("txglomsize=", full_param, len_param)) {
-		conf->txglomsize = (uint)simple_strtol(data, NULL, 10);
-		if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
-			conf->txglomsize = SDPCM_MAXGLOM_SIZE;
-		CONFIG_MSG("txglomsize = %d\n", conf->txglomsize);
-	}
-	else if (!strncmp("txglom_ext=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->txglom_ext = FALSE;
-		else
-			conf->txglom_ext = TRUE;
-		CONFIG_MSG("txglom_ext = %d\n", conf->txglom_ext);
-		if (conf->txglom_ext) {
-			if ((conf->chip == BCM43362_CHIP_ID) || (conf->chip == BCM4330_CHIP_ID))
-				conf->txglom_bucket_size = 1680;
-			else if (conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-					conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID)
-				conf->txglom_bucket_size = 1684;
-		}
-		CONFIG_MSG("txglom_bucket_size = %d\n", conf->txglom_bucket_size);
-	}
-	else if (!strncmp("bus:rxglom=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->bus_rxglom = FALSE;
-		else
-			conf->bus_rxglom = TRUE;
-		CONFIG_MSG("bus:rxglom = %d\n", conf->bus_rxglom);
-	}
-	else if (!strncmp("deferred_tx_len=", full_param, len_param)) {
-		conf->deferred_tx_len = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("deferred_tx_len = %d\n", conf->deferred_tx_len);
-	}
-	else if (!strncmp("txctl_tmo_fix=", full_param, len_param)) {
-		conf->txctl_tmo_fix = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("txctl_tmo_fix = %d\n", conf->txctl_tmo_fix);
-	}
-	else if (!strncmp("tx_max_offset=", full_param, len_param)) {
-		conf->tx_max_offset = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("tx_max_offset = %d\n", conf->tx_max_offset);
-	}
-	else if (!strncmp("txglom_mode=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->txglom_mode = FALSE;
-		else
-			conf->txglom_mode = TRUE;
-		CONFIG_MSG("txglom_mode = %d\n", conf->txglom_mode);
-	}
-#if defined(SDIO_ISR_THREAD)
-	else if (!strncmp("intr_extn=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->intr_extn = FALSE;
-		else
-			conf->intr_extn = TRUE;
-		CONFIG_MSG("intr_extn = %d\n", conf->intr_extn);
-	}
-#endif
-#ifdef BCMSDIO_RXLIM_POST
-	else if (!strncmp("rxlim_en=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->rxlim_en = FALSE;
-		else
-			conf->rxlim_en = TRUE;
-		CONFIG_MSG("rxlim_en = %d\n", conf->rxlim_en);
-	}
-#endif
-#endif
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-#ifdef BCMPCIE
-bool
-dhd_conf_read_pcie_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	if (!strncmp("bus:deepsleep_disable=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->bus_deepsleep_disable = 0;
-		else
-			conf->bus_deepsleep_disable = 1;
-		CONFIG_MSG("bus:deepsleep_disable = %d\n", conf->bus_deepsleep_disable);
-	}
-	else
-		return false;
-
-	return true;
-}
-#endif
-
-bool
-dhd_conf_read_pm_params(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-
-	if (!strncmp("deepsleep=", full_param, len_param)) {
-		if (!strncmp(data, "1", 1))
-			conf->deepsleep = TRUE;
-		else
-			conf->deepsleep = FALSE;
-		CONFIG_MSG("deepsleep = %d\n", conf->deepsleep);
-	}
-	else if (!strncmp("PM=", full_param, len_param)) {
-		conf->pm = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("PM = %d\n", conf->pm);
-	}
-	else if (!strncmp("pm_in_suspend=", full_param, len_param)) {
-		conf->pm_in_suspend = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("pm_in_suspend = %d\n", conf->pm_in_suspend);
-	}
-	else if (!strncmp("suspend_mode=", full_param, len_param)) {
-		conf->suspend_mode = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("suspend_mode = %d\n", conf->suspend_mode);
-		if (conf->suspend_mode == PM_NOTIFIER)
-			conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
-	}
-	else if (!strncmp("suspend_bcn_li_dtim=", full_param, len_param)) {
-		conf->suspend_bcn_li_dtim = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("suspend_bcn_li_dtim = %d\n", conf->suspend_bcn_li_dtim);
-	}
-	else if (!strncmp("xmit_in_suspend=", full_param, len_param)) {
-		if (!strncmp(data, "1", 1))
-			conf->insuspend &= ~NO_TXDATA_IN_SUSPEND;
-		else
-			conf->insuspend |= NO_TXDATA_IN_SUSPEND;
-		CONFIG_MSG("insuspend = 0x%x\n", conf->insuspend);
-	}
-	else if (!strncmp("insuspend=", full_param, len_param)) {
-		conf->insuspend = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("insuspend = 0x%x\n", conf->insuspend);
-	}
-#ifdef WL_EXT_WOWL
-	else if (!strncmp("wowl=", full_param, len_param)) {
-		conf->wowl = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("wowl = 0x%x\n", conf->wowl);
-	}
-#endif
-	else
-		return false;
-
-	return true;
-}
-
-#ifdef GET_CUSTOM_MAC_FROM_CONFIG
-int
-bcm_str2hex(const char *p, char *ea, int size)
-{
-	int i = 0;
-	char *ep;
-
-	for (;;) {
-		ea[i++] = (char) bcm_strtoul(p, &ep, 16);
-		p = ep;
-		if (!*p++ || i == size)
-			break;
-	}
-
-	return (i == size);
-}
-#endif
-
-bool
-dhd_conf_read_others(dhd_pub_t *dhd, char *full_param, uint len_param)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char *data = full_param+len_param;
-	char *pch, *pick_tmp;
-	int i;
-#ifdef GET_CUSTOM_MAC_FROM_CONFIG
-	struct ether_addr ea_addr;
-	char macpad[56];
-#endif
-
-	if (!strncmp("dhd_poll=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->dhd_poll = 0;
-		else
-			conf->dhd_poll = 1;
-		CONFIG_MSG("dhd_poll = %d\n", conf->dhd_poll);
-	}
-	else if (!strncmp("dhd_watchdog_ms=", full_param, len_param)) {
-		dhd_watchdog_ms = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhd_watchdog_ms = %d\n", dhd_watchdog_ms);
-	}
-	else if (!strncmp("band=", full_param, len_param)) {
-		/* Process band:
-		 * band=a for 5GHz only and band=b for 2.4GHz only
-		 */
-		if (!strcmp(data, "b"))
-			conf->band = WLC_BAND_2G;
-		else if (!strcmp(data, "a"))
-			conf->band = WLC_BAND_5G;
-		else
-			conf->band = WLC_BAND_AUTO;
-		CONFIG_MSG("band = %d\n", conf->band);
-	}
-	else if (!strncmp("bw_cap_2g=", full_param, len_param)) {
-		conf->bw_cap[0] = (uint)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("bw_cap_2g = %d\n", conf->bw_cap[0]);
-	}
-	else if (!strncmp("bw_cap_5g=", full_param, len_param)) {
-		conf->bw_cap[1] = (uint)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("bw_cap_5g = %d\n", conf->bw_cap[1]);
-	}
-	else if (!strncmp("bw_cap=", full_param, len_param)) {
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-		if (pch != NULL) {
-			conf->bw_cap[0] = (uint32)simple_strtol(pch, NULL, 0);
-			CONFIG_MSG("bw_cap 2g = %d\n", conf->bw_cap[0]);
-		}
-		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-		if (pch != NULL) {
-			conf->bw_cap[1] = (uint32)simple_strtol(pch, NULL, 0);
-			CONFIG_MSG("bw_cap 5g = %d\n", conf->bw_cap[1]);
-		}
-	}
-	else if (!strncmp("channels=", full_param, len_param)) {
-		pick_tmp = data;
-		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-		i=0;
-		while (pch != NULL && i<WL_NUMCHANNELS) {
-			conf->channels.channel[i] = (uint32)simple_strtol(pch, NULL, 10);
-			pch = bcmstrtok(&pick_tmp, " ,.-", 0);
-			i++;
-		}
-		conf->channels.count = i;
-		CONFIG_MSG("channels = ");
-		for (i=0; i<conf->channels.count; i++)
-			printf("%d ", conf->channels.channel[i]);
-		printf("\n");
-	}
-	else if (!strncmp("keep_alive_period=", full_param, len_param)) {
-		conf->keep_alive_period = (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("keep_alive_period = %d\n", conf->keep_alive_period);
-	}
-#ifdef ARP_OFFLOAD_SUPPORT
-	else if (!strncmp("garp=", full_param, len_param)) {
-		if (!strncmp(data, "0", 1))
-			conf->garp = FALSE;
-		else
-			conf->garp = TRUE;
-		CONFIG_MSG("garp = %d\n", conf->garp);
-	}
-#endif
-	else if (!strncmp("srl=", full_param, len_param)) {
-		conf->srl = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("srl = %d\n", conf->srl);
-	}
-	else if (!strncmp("lrl=", full_param, len_param)) {
-		conf->lrl = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("lrl = %d\n", conf->lrl);
-	}
-	else if (!strncmp("bcn_timeout=", full_param, len_param)) {
-		conf->bcn_timeout= (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("bcn_timeout = %d\n", conf->bcn_timeout);
-	}
-	else if (!strncmp("frameburst=", full_param, len_param)) {
-		conf->frameburst = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("frameburst = %d\n", conf->frameburst);
-	}
-	else if (!strncmp("disable_proptx=", full_param, len_param)) {
-		conf->disable_proptx = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("disable_proptx = %d\n", conf->disable_proptx);
-	}
-#ifdef DHDTCPACK_SUPPRESS
-	else if (!strncmp("tcpack_sup_mode=", full_param, len_param)) {
-		conf->tcpack_sup_mode = (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("tcpack_sup_mode = %d\n", conf->tcpack_sup_mode);
-	}
-#endif
-	else if (!strncmp("pktprio8021x=", full_param, len_param)) {
-		conf->pktprio8021x = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("pktprio8021x = %d\n", conf->pktprio8021x);
-	}
-#if defined(BCMSDIO) || defined(BCMPCIE)
-	else if (!strncmp("dhd_txbound=", full_param, len_param)) {
-		dhd_txbound = (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhd_txbound = %d\n", dhd_txbound);
-	}
-	else if (!strncmp("dhd_rxbound=", full_param, len_param)) {
-		dhd_rxbound = (uint)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhd_rxbound = %d\n", dhd_rxbound);
-	}
-#endif
-	else if (!strncmp("orphan_move=", full_param, len_param)) {
-		conf->orphan_move = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("orphan_move = %d\n", conf->orphan_move);
-	}
-	else if (!strncmp("tsq=", full_param, len_param)) {
-		conf->tsq = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("tsq = %d\n", conf->tsq);
-	}
-	else if (!strncmp("ctrl_resched=", full_param, len_param)) {
-		conf->ctrl_resched = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("ctrl_resched = %d\n", conf->ctrl_resched);
-	}
-	else if (!strncmp("in4way=", full_param, len_param)) {
-		conf->in4way = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("in4way = 0x%x\n", conf->in4way);
-	}
-	else if (!strncmp("wl_preinit=", full_param, len_param)) {
-		if (conf->wl_preinit) {
-			kfree(conf->wl_preinit);
-			conf->wl_preinit = NULL;
-		}
-		if (!(conf->wl_preinit = kmalloc(len_param+1, GFP_KERNEL))) {
-			CONFIG_ERROR("kmalloc failed\n");
-		} else {
-			memset(conf->wl_preinit, 0, len_param+1);
-			strcpy(conf->wl_preinit, data);
-			CONFIG_MSG("wl_preinit = %s\n", conf->wl_preinit);
-		}
-	}
-	else if (!strncmp("wl_suspend=", full_param, len_param)) {
-		if (conf->wl_suspend) {
-			kfree(conf->wl_suspend);
-			conf->wl_suspend = NULL;
-		}
-		if (!(conf->wl_suspend = kmalloc(len_param+1, GFP_KERNEL))) {
-			CONFIG_ERROR("kmalloc failed\n");
-		} else {
-			memset(conf->wl_suspend, 0, len_param+1);
-			strcpy(conf->wl_suspend, data);
-			CONFIG_MSG("wl_suspend = %s\n", conf->wl_suspend);
-		}
-	}
-	else if (!strncmp("wl_resume=", full_param, len_param)) {
-		if (conf->wl_resume) {
-			kfree(conf->wl_resume);
-			conf->wl_resume = NULL;
-		}
-		if (!(conf->wl_resume = kmalloc(len_param+1, GFP_KERNEL))) {
-			CONFIG_ERROR("kmalloc failed\n");
-		} else {
-			memset(conf->wl_resume, 0, len_param+1);
-			strcpy(conf->wl_resume, data);
-			CONFIG_MSG("wl_resume = %s\n", conf->wl_resume);
-		}
-	}
-#ifdef GET_CUSTOM_MAC_FROM_CONFIG
-	else if (!strncmp("mac=", full_param, len_param)) {
-		if (!bcm_ether_atoe(data, &ea_addr)) {
-			CONFIG_ERROR("mac adress read error");
-			return false;
-		}
-		memcpy(&conf->hw_ether, &ea_addr, ETHER_ADDR_LEN);
-		CONFIG_MSG("mac = %s\n", data);
-	}
-	else if (!strncmp("macpad=", full_param, len_param)) {
-		if (!bcm_str2hex(data, macpad, sizeof(macpad))) {
-			CONFIG_ERROR("macpad adress read error");
-			return false;
-		}
-		memcpy(&conf->hw_ether[ETHER_ADDR_LEN], macpad, sizeof(macpad));
-		if (config_msg_level & CONFIG_TRACE_LEVEL) {
-			printf("macpad =\n");
-			for (i=0; i<sizeof(macpad); i++) {
-				printf("0x%02x, ", conf->hw_ether[ETHER_ADDR_LEN+i]);
-				if ((i+1)%8 == 0)
-					printf("\n");
-			}
-		}
-	}
-#endif
-	else
-		return false;
-
-	return true;
-}
-
-int
-dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path)
-{
-	int bcmerror = -1, chip_match = -1;
-	uint len = 0, start_pos=0, end_pos=0;
-	void *image = NULL;
-	char *memblock = NULL;
-	char *bufp, *pick = NULL, *pch;
-	bool conf_file_exists;
-	uint len_param;
-
-	conf_file_exists = ((conf_path != NULL) && (conf_path[0] != '\0'));
-	if (!conf_file_exists) {
-		CONFIG_MSG("config path %s\n", conf_path);
-		return (0);
-	}
-
-	if (conf_file_exists) {
-		image = dhd_os_open_image(conf_path);
-		if (image == NULL) {
-			CONFIG_MSG("Ignore config file %s\n", conf_path);
-			goto err;
-		}
-	}
-
-	memblock = MALLOC(dhd->osh, MAXSZ_CONFIG);
-	if (memblock == NULL) {
-		CONFIG_ERROR("Failed to allocate memory %d bytes\n", MAXSZ_CONFIG);
-		goto err;
-	}
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR("Failed to allocate memory %d bytes\n", MAXSZ_BUF);
-		goto err;
-	}
-
-	/* Read variables */
-	if (conf_file_exists) {
-		len = dhd_os_get_image_block(memblock, MAXSZ_CONFIG, image);
-	}
-	if (len > 0 && len < MAXSZ_CONFIG) {
-		bufp = (char *)memblock;
-		bufp[len] = 0;
-
-		while (start_pos < len) {
-			memset(pick, 0, MAXSZ_BUF);
-			end_pos = pick_config_vars(bufp, len, start_pos, pick, MAXSZ_BUF);
-			if (end_pos - start_pos >= MAXSZ_BUF)
-				CONFIG_ERROR("out of buf to read MAXSIZ_BUF=%d\n", MAXSZ_BUF);
-			start_pos = end_pos;
-			pch = strchr(pick, '=');
-			if (pch != NULL) {
-				len_param = pch-pick+1;
-				if (len_param == strlen(pick)) {
-					CONFIG_ERROR("not a right parameter %s\n", pick);
-					continue;
-				}
-			} else {
-				CONFIG_ERROR("not a right parameter %s\n", pick);
-				continue;
-			}
-
-			dhd_conf_read_chiprev(dhd, &chip_match, pick, len_param);
-			if (!chip_match)
-				continue;
-
-			if (dhd_conf_read_log_level(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_roam_params(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_wme_ac_params(dhd, pick, len_param))
-				continue;
-#ifdef BCMSDIO
-			else if (dhd_conf_read_fw_by_mac(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_nv_by_mac(dhd, pick, len_param))
-				continue;
-#endif
-			else if (dhd_conf_read_nv_by_chip(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_country(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_mchan_params(dhd, pick, len_param))
-				continue;
-#ifdef PKT_FILTER_SUPPORT
-			else if (dhd_conf_read_pkt_filter(dhd, pick, len_param))
-				continue;
-#endif /* PKT_FILTER_SUPPORT */
-#ifdef ISAM_PREINIT
-			else if (dhd_conf_read_isam(dhd, pick, len_param))
-				continue;
-#endif /* ISAM_PREINIT */
-#ifdef IDHCP
-			else if (dhd_conf_read_dhcp_params(dhd, pick, len_param))
-				continue;
-#endif /* IDHCP */
-#ifdef BCMSDIO
-			else if (dhd_conf_read_sdio_params(dhd, pick, len_param))
-				continue;
-#endif /* BCMSDIO */
-#ifdef BCMPCIE
-			else if (dhd_conf_read_pcie_params(dhd, pick, len_param))
-				continue;
-#endif /* BCMPCIE */
-			else if (dhd_conf_read_pm_params(dhd, pick, len_param))
-				continue;
-			else if (dhd_conf_read_others(dhd, pick, len_param))
-				continue;
-			else
-				continue;
-		}
-
-		bcmerror = 0;
-	} else {
-		CONFIG_ERROR("error reading config file: %d\n", len);
-		bcmerror = BCME_SDIO_ERROR;
-	}
-
-err:
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-
-	if (memblock)
-		MFREE(dhd->osh, memblock, MAXSZ_CONFIG);
-
-	if (image)
-		dhd_os_close_image(image);
-
-	return bcmerror;
-}
-
-int
-dhd_conf_set_chiprev(dhd_pub_t *dhd, uint chip, uint chiprev)
-{
-	CONFIG_MSG("chip=0x%x, chiprev=%d\n", chip, chiprev);
-	dhd->conf->chip = chip;
-	dhd->conf->chiprev = chiprev;
-	return 0;
-}
-
-uint
-dhd_conf_get_chip(void *context)
-{
-	dhd_pub_t *dhd = context;
-
-	if (dhd && dhd->conf)
-		return dhd->conf->chip;
-	return 0;
-}
-
-uint
-dhd_conf_get_chiprev(void *context)
-{
-	dhd_pub_t *dhd = context;
-
-	if (dhd && dhd->conf)
-		return dhd->conf->chiprev;
-	return 0;
-}
-
-#ifdef BCMSDIO
-void
-dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable)
-{
-	struct dhd_conf *conf = dhd->conf;
-
-	if (enable) {
-#if defined(BCMSDIOH_TXGLOM_EXT)
-		if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
-				conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-				conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-			conf->txglom_mode = SDPCM_TXGLOM_CPY;
-		}
-#endif
-		// other parameters set in preinit or config.txt
-		if (conf->txglom_ext)
-			CONFIG_MSG("txglom_ext=%d, txglom_bucket_size=%d\n",
-				conf->txglom_ext, conf->txglom_bucket_size);
-		CONFIG_MSG("txglom_mode=%s\n",
-	 		conf->txglom_mode==SDPCM_TXGLOM_MDESC?"multi-desc":"copy");
-		CONFIG_MSG("txglomsize=%d, deferred_tx_len=%d\n",
-			conf->txglomsize, conf->deferred_tx_len);
-		CONFIG_MSG("txinrx_thres=%d, dhd_txminmax=%d\n",
-			conf->txinrx_thres, conf->dhd_txminmax);
-		CONFIG_MSG("tx_max_offset=%d, txctl_tmo_fix=%d\n",
-			conf->tx_max_offset, conf->txctl_tmo_fix);
-	} else {
-		// clear txglom parameters
-		conf->txglom_ext = FALSE;
-		conf->txglom_bucket_size = 0;
-		conf->txglomsize = 0;
-		conf->deferred_tx_len = 0;
-	}
-
-}
-#endif
-
-void
-dhd_conf_postinit_ioctls(dhd_pub_t *dhd)
-{
-	struct dhd_conf *conf = dhd->conf;
-	char wl_preinit[] = "assoc_retry_max=20";
-
-	dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
-	dhd_conf_map_country_list(dhd, &conf->cspec);
-	dhd_conf_set_country(dhd, &conf->cspec);
-	dhd_conf_fix_country(dhd);
-	dhd_conf_get_country(dhd, &dhd->dhd_cspec);
-
-	dhd_conf_set_intiovar(dhd, WLC_SET_BAND, "WLC_SET_BAND", conf->band, 0, FALSE);
-	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_timeout", conf->bcn_timeout, 0, FALSE);
-	dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", conf->pm, 0, FALSE);
-	dhd_conf_set_intiovar(dhd, WLC_SET_SRL, "WLC_SET_SRL", conf->srl, 0, FALSE);
-	dhd_conf_set_intiovar(dhd, WLC_SET_LRL, "WLC_SET_LRL", conf->lrl, 0, FALSE);
-	dhd_conf_set_bw_cap(dhd);
-	dhd_conf_set_roam(dhd);
-
-#if defined(BCMPCIE)
-	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bus:deepsleep_disable",
-		conf->bus_deepsleep_disable, 0, FALSE);
-#endif /* defined(BCMPCIE) */
-
-#ifdef IDHCP
-	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "dhcpc_enable", conf->dhcpc_enable,
-		0, FALSE);
-	if (conf->dhcpd_enable >= 0) {
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_addr",
-			(char *)&conf->dhcpd_ip_addr, sizeof(conf->dhcpd_ip_addr), FALSE);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_mask",
-			(char *)&conf->dhcpd_ip_mask, sizeof(conf->dhcpd_ip_mask), FALSE);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_start",
-			(char *)&conf->dhcpd_ip_start, sizeof(conf->dhcpd_ip_start), FALSE);
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_end",
-			(char *)&conf->dhcpd_ip_end, sizeof(conf->dhcpd_ip_end), FALSE);
-		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "dhcpd_enable",
-			conf->dhcpd_enable, 0, FALSE);
-	}
-#endif
-	dhd_conf_set_intiovar(dhd, WLC_SET_FAKEFRAG, "WLC_SET_FAKEFRAG",
-		conf->frameburst, 0, FALSE);
-
-	dhd_conf_set_wl_cmd(dhd, wl_preinit, TRUE);
-#if defined(BCMSDIO)
-	{
-		char ampdu_mpdu[] = "ampdu_mpdu=16";
-		dhd_conf_set_wl_cmd(dhd, ampdu_mpdu, TRUE);
-	}
-#endif
-	if (conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
-			conf->chip == BCM4371_CHIP_ID || conf->chip == BCM4359_CHIP_ID ||
-			conf->chip == BCM43569_CHIP_ID) {
-		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "txbf", 1, 0, FALSE);
-	}
-	dhd_conf_set_wl_cmd(dhd, conf->wl_preinit, TRUE);
-
-#ifndef WL_CFG80211
-	dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
-#endif
-
-}
-
-int
-dhd_conf_preinit(dhd_pub_t *dhd)
-{
-	struct dhd_conf *conf = dhd->conf;
-
-	CONFIG_TRACE("Enter\n");
-
-#ifdef BCMSDIO
-	dhd_conf_free_mac_list(&conf->fw_by_mac);
-	dhd_conf_free_mac_list(&conf->nv_by_mac);
-#endif
-	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
-	dhd_conf_free_country_list(conf);
-	dhd_conf_free_mchan_list(conf);
-	if (conf->magic_pkt_filter_add) {
-		kfree(conf->magic_pkt_filter_add);
-		conf->magic_pkt_filter_add = NULL;
-	}
-	if (conf->wl_preinit) {
-		kfree(conf->wl_preinit);
-		conf->wl_preinit = NULL;
-	}
-	if (conf->wl_suspend) {
-		kfree(conf->wl_suspend);
-		conf->wl_suspend = NULL;
-	}
-	if (conf->wl_resume) {
-		kfree(conf->wl_resume);
-		conf->wl_resume = NULL;
-	}
-	conf->band = -1;
-	memset(&conf->bw_cap, -1, sizeof(conf->bw_cap));
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
-		strcpy(conf->cspec.country_abbrev, "ALL");
-		strcpy(conf->cspec.ccode, "ALL");
-		conf->cspec.rev = 0;
-	} else if (conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
-			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
-			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
-			conf->chip == BCM43569_CHIP_ID || conf->chip == BCM4359_CHIP_ID) {
-		strcpy(conf->cspec.country_abbrev, "CN");
-		strcpy(conf->cspec.ccode, "CN");
-		conf->cspec.rev = 38;
-	} else {
-		strcpy(conf->cspec.country_abbrev, "CN");
-		strcpy(conf->cspec.ccode, "CN");
-		conf->cspec.rev = 0;
-	}
-	memset(&conf->channels, 0, sizeof(wl_channel_list_t));
-	conf->roam_off = 1;
-	conf->roam_off_suspend = 1;
-	conf->roam_trigger[0] = -65;
-	conf->roam_trigger[1] = WLC_BAND_ALL;
-	conf->roam_scan_period[0] = 10;
-	conf->roam_scan_period[1] = WLC_BAND_ALL;
-	conf->roam_delta[0] = 10;
-	conf->roam_delta[1] = WLC_BAND_ALL;
-	conf->fullroamperiod = 20;
-	conf->keep_alive_period = 30000;
-#ifdef ARP_OFFLOAD_SUPPORT
-	conf->garp = FALSE;
-#endif
-	conf->force_wme_ac = 0;
-	memset(&conf->wme_sta, 0, sizeof(wme_param_t));
-	memset(&conf->wme_ap, 0, sizeof(wme_param_t));
-#ifdef PKT_FILTER_SUPPORT
-	memset(&conf->pkt_filter_add, 0, sizeof(conf_pkt_filter_add_t));
-	memset(&conf->pkt_filter_del, 0, sizeof(conf_pkt_filter_del_t));
-#endif
-	conf->srl = -1;
-	conf->lrl = -1;
-	conf->bcn_timeout = 16;
-	conf->disable_proptx = -1;
-	conf->dhd_poll = -1;
-#ifdef BCMSDIO
-	conf->use_rxchain = 0;
-	conf->bus_rxglom = TRUE;
-	conf->txglom_ext = FALSE;
-	conf->tx_max_offset = 0;
-	conf->txglomsize = SDPCM_DEFGLOM_SIZE;
-	conf->txctl_tmo_fix = 300;
-	conf->txglom_mode = SDPCM_TXGLOM_CPY;
-	conf->deferred_tx_len = 0;
-	conf->dhd_txminmax = 1;
-	conf->txinrx_thres = -1;
-#if defined(SDIO_ISR_THREAD)
-	conf->intr_extn = FALSE;
-#endif
-#ifdef BCMSDIO_RXLIM_POST
-	conf->rxlim_en = TRUE;
-#endif
-#if defined(HW_OOB)
-	conf->oob_enabled_later = FALSE;
-#endif
-#endif
-#ifdef BCMPCIE
-	conf->bus_deepsleep_disable = 1;
-#endif
-	conf->dpc_cpucore = -1;
-	conf->rxf_cpucore = -1;
-	conf->frameburst = -1;
-	conf->deepsleep = FALSE;
-	conf->pm = -1;
-	conf->pm_in_suspend = -1;
-	conf->insuspend = 0;
-	conf->suspend_mode = EARLY_SUSPEND;
-	conf->suspend_bcn_li_dtim = -1;
-#ifdef WL_EXT_WOWL
-	dhd_master_mode = TRUE;
-	conf->wowl = WL_WOWL_NET|WL_WOWL_DIS|WL_WOWL_BCN;
-	conf->insuspend |= (WOWL_IN_SUSPEND | NO_TXDATA_IN_SUSPEND);
-#endif
-	if (conf->suspend_mode == PM_NOTIFIER)
-		conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
-#ifdef DHD_LOAD_CHIPALIVE
-	conf->insuspend |= NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND;
-#endif
-	conf->suspended = FALSE;
-#ifdef SUSPEND_EVENT
-	memset(&conf->resume_eventmask, 0, sizeof(conf->resume_eventmask));
-	memset(&conf->bssid_insuspend, 0, ETHER_ADDR_LEN);
-	conf->wlfc = FALSE;
-#endif
-#ifdef GET_CUSTOM_MAC_FROM_CONFIG
-	memset(&conf->hw_ether, 0, sizeof(conf->hw_ether));
-#endif
-#ifdef IDHCP
-	conf->dhcpc_enable = -1;
-	conf->dhcpd_enable = -1;
-#endif
-	conf->orphan_move = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
-	conf->tsq = 10;
-#else
-	conf->tsq = 0;
-#endif
-#ifdef DHDTCPACK_SUPPRESS
-#ifdef BCMPCIE
-	conf->tcpack_sup_mode = TCPACK_SUP_DEFAULT;
-#else
-	conf->tcpack_sup_mode = TCPACK_SUP_OFF;
-#endif
-#endif
-	conf->pktprio8021x = -1;
-	conf->ctrl_resched = 2;
-	conf->in4way = NO_SCAN_IN4WAY | DONT_DELETE_GC_AFTER_WPS | WAIT_DISCONNECTED;
-#ifdef ISAM_PREINIT
-	memset(conf->isam_init, 0, sizeof(conf->isam_init));
-	memset(conf->isam_config, 0, sizeof(conf->isam_config));
-	memset(conf->isam_enable, 0, sizeof(conf->isam_enable));
-#endif
-#if defined(SDIO_ISR_THREAD)
-	if (conf->chip == BCM43012_CHIP_ID ||
-			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
-			conf->chip == BCM43454_CHIP_ID || conf->chip == BCM4345_CHIP_ID ||
-			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
-			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
-			conf->chip == BCM4359_CHIP_ID) {
-		conf->intr_extn = TRUE;
-	}
-#endif
-	if ((conf->chip == BCM43430_CHIP_ID && conf->chiprev == 2) ||
-			conf->chip == BCM43012_CHIP_ID ||
-			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
-			conf->chip == BCM43454_CHIP_ID || conf->chip == BCM4345_CHIP_ID ||
-			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
-			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
-			conf->chip == BCM43569_CHIP_ID || conf->chip == BCM4359_CHIP_ID) {
-#ifdef DHDTCPACK_SUPPRESS
-#ifdef BCMSDIO
-		conf->tcpack_sup_mode = TCPACK_SUP_REPLACE;
-#endif
-#endif
-#if defined(BCMSDIO) || defined(BCMPCIE)
-		dhd_rxbound = 128;
-		dhd_txbound = 64;
-#endif
-		conf->frameburst = 1;
-#ifdef BCMSDIO
-		conf->dhd_txminmax = -1;
-		conf->txinrx_thres = 128;
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
-		conf->orphan_move = 1;
-#else
-		conf->orphan_move = 0;
-#endif
-	}
-
-#ifdef BCMSDIO
-#if defined(BCMSDIOH_TXGLOM_EXT)
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
-			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		conf->txglom_ext = TRUE;
-	} else {
-		conf->txglom_ext = FALSE;
-	}
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
-		conf->txglom_bucket_size = 1680; // fixed value, don't change
-		conf->txglomsize = 6;
-	}
-	if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
-			conf->chip == BCM43341_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		conf->txglom_bucket_size = 1684; // fixed value, don't change
-		conf->txglomsize = 16;
-	}
-#endif
-	if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
-		conf->txglomsize = SDPCM_MAXGLOM_SIZE;
-#endif
-	init_waitqueue_head(&conf->event_complete);
-
-	return 0;
-}
-
-int
-dhd_conf_reset(dhd_pub_t *dhd)
-{
-	struct dhd_conf *conf = dhd->conf;
-
-#ifdef BCMSDIO
-	dhd_conf_free_mac_list(&conf->fw_by_mac);
-	dhd_conf_free_mac_list(&conf->nv_by_mac);
-#endif
-	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
-	dhd_conf_free_country_list(conf);
-	dhd_conf_free_mchan_list(conf);
-	if (conf->magic_pkt_filter_add) {
-		kfree(conf->magic_pkt_filter_add);
-		conf->magic_pkt_filter_add = NULL;
-	}
-	if (conf->wl_preinit) {
-		kfree(conf->wl_preinit);
-		conf->wl_preinit = NULL;
-	}
-	if (conf->wl_suspend) {
-		kfree(conf->wl_suspend);
-		conf->wl_suspend = NULL;
-	}
-	if (conf->wl_resume) {
-		kfree(conf->wl_resume);
-		conf->wl_resume = NULL;
-	}
-	memset(conf, 0, sizeof(dhd_conf_t));
-	return 0;
-}
-
-int
-dhd_conf_attach(dhd_pub_t *dhd)
-{
-	dhd_conf_t *conf;
-
-	CONFIG_TRACE("Enter\n");
-
-	if (dhd->conf != NULL) {
-		CONFIG_MSG("config is attached before!\n");
-		return 0;
-	}
-	/* Allocate private bus interface state */
-	if (!(conf = MALLOC(dhd->osh, sizeof(dhd_conf_t)))) {
-		CONFIG_ERROR("MALLOC failed\n");
-		goto fail;
-	}
-	memset(conf, 0, sizeof(dhd_conf_t));
-
-	dhd->conf = conf;
-
-	return 0;
-
-fail:
-	if (conf != NULL)
-		MFREE(dhd->osh, conf, sizeof(dhd_conf_t));
-	return BCME_NOMEM;
-}
-
-void
-dhd_conf_detach(dhd_pub_t *dhd)
-{
-	struct dhd_conf *conf = dhd->conf;
-
-	CONFIG_TRACE("Enter\n");
-	if (dhd->conf) {
-#ifdef BCMSDIO
-		dhd_conf_free_mac_list(&conf->fw_by_mac);
-		dhd_conf_free_mac_list(&conf->nv_by_mac);
-#endif
-		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
-		dhd_conf_free_country_list(conf);
-		dhd_conf_free_mchan_list(conf);
-		if (conf->magic_pkt_filter_add) {
-			kfree(conf->magic_pkt_filter_add);
-			conf->magic_pkt_filter_add = NULL;
-		}
-		if (conf->wl_preinit) {
-			kfree(conf->wl_preinit);
-			conf->wl_preinit = NULL;
-		}
-		if (conf->wl_suspend) {
-			kfree(conf->wl_suspend);
-			conf->wl_suspend = NULL;
-		}
-		if (conf->wl_resume) {
-			kfree(conf->wl_resume);
-			conf->wl_resume = NULL;
-		}
-		MFREE(dhd->osh, conf, sizeof(dhd_conf_t));
-	}
-	dhd->conf = NULL;
-}
+#include <typedefs.h>
+#include <osl.h>
+
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <bcmsdbus.h>
+#if defined(HW_OOB) || defined(FORCE_WOWLAN)
+#include <bcmdefs.h>
+#include <bcmsdh.h>
+#include <sdio.h>
+#include <sbchipc.h>
+#endif
+#ifdef WL_CFG80211
+#include <wl_cfg80211.h>
+#endif
+
+#include <dhd_config.h>
+#include <dhd_dbg.h>
+#include <wl_android.h>
+
+/* message levels */
+#define CONFIG_ERROR_LEVEL	(1 << 0)
+#define CONFIG_TRACE_LEVEL	(1 << 1)
+#define CONFIG_MSG_LEVEL	(1 << 0)
+
+uint config_msg_level = CONFIG_ERROR_LEVEL | CONFIG_MSG_LEVEL | CONFIG_TRACE_LEVEL | CONFIG_CHIPALIVE_LEVEL;
+uint dump_msg_level = 0;
+
+#define CONFIG_MSG(x, args...) \
+	do { \
+		if (config_msg_level & CONFIG_MSG_LEVEL) { \
+			DHD_PRINT("[dhd] %s : " x, __func__, ## args); \
+		} \
+	} while (0)
+#define CONFIG_ERROR(x, args...) \
+	do { \
+		if (config_msg_level & CONFIG_ERROR_LEVEL) { \
+			printk(KERN_ERR "[dhd] CONFIG-ERROR) %s : " x, __func__, ## args); \
+		} \
+	} while (0)
+#define CONFIG_TRACE(x, args...) \
+	do { \
+		if (config_msg_level & CONFIG_TRACE_LEVEL) { \
+			printk(KERN_INFO "[dhd] CONFIG-TRACE) %s : " x, __func__, ## args); \
+		} \
+	} while (0)
+
+#define MAXSZ_BUF		4096
+#define MAXSZ_CONFIG	8192
+
+#ifndef WL_CFG80211
+#define htod32(i) i
+#define htod16(i) i
+#define dtoh32(i) i
+#define dtoh16(i) i
+#define htodchanspec(i) i
+#define dtohchanspec(i) i
+#endif
+
+#if defined(PROP_TXSTATUS)
+#include <dhd_wlfc.h>
+#endif /* PROP_TXSTATUS */
+
+#define MAX_EVENT_BUF_NUM 16
+typedef struct eventmsg_buf {
+	u16 num;
+	struct {
+		u16 type;
+		bool set;
+	} event [MAX_EVENT_BUF_NUM];
+} eventmsg_buf_t;
+
+typedef struct cihp_name_map_t {
+	uint chip;
+	uint chiprev;
+	uint ag_type;
+	char *chip_name;
+	char *module_name;
+} cihp_name_map_t;
+
+/* Map of WLC_E events to connection failure strings */
+#define DONT_CARE	9999
+const cihp_name_map_t chip_name_map[] = {
+	/* ChipID			Chiprev	AG	 	ChipName	ModuleName  */
+#ifdef BCMSDIO
+	{BCM43362_CHIP_ID,	0,	DONT_CARE,	"RK901a0",			""},
+	//{BCM43362_CHIP_ID,	1,	DONT_CARE,	"RK901a2",			"AP6210"},
+	{BCM43362_CHIP_ID,	1,	DONT_CARE,	"bcm40181a2",			"ap6181"},
+	{BCM4330_CHIP_ID,	4,	FW_TYPE_G,	"RK903b2",			""},
+	{BCM4330_CHIP_ID,	4,	FW_TYPE_AG,	"RK903_ag",			"AP6330"},
+	{BCM43430_CHIP_ID,	0,	DONT_CARE,	"bcm43438a0",		"ap6212"},
+	{BCM43430_CHIP_ID,	1,	DONT_CARE,	"bcm43438a1",		"ap6212a"},
+	{BCM43430_CHIP_ID,	2,	DONT_CARE,	"bcm43436b0",		"ap6236"},
+	{BCM43012_CHIP_ID,	1,	FW_TYPE_G,	"bcm43013b0",		""},
+	{BCM43012_CHIP_ID,	1,	FW_TYPE_AG,	"bcm43013c0_ag",	""},
+	{BCM43012_CHIP_ID,	2,	DONT_CARE,	"bcm43013c1_ag",	"ap6203bm"},
+	{BCM4334_CHIP_ID,	3,	DONT_CARE,	"bcm4334b1_ag",		""},
+	{BCM43340_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
+	{BCM43341_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
+	{BCM4324_CHIP_ID,	5,	DONT_CARE,	"bcm43241b4_ag",	"ap62x2"},
+	{BCM4335_CHIP_ID,	2,	DONT_CARE,	"bcm4339a0_ag",		"AP6335"},
+	{BCM4339_CHIP_ID,	1,	DONT_CARE,	"bcm4339a0_ag",		"AP6335"},
+	{BCM4345_CHIP_ID,	6,	DONT_CARE,	"bcm43455c0_ag",	"ap6255"},
+	{BCM43454_CHIP_ID,	6,	DONT_CARE,	"bcm43455c0_ag",	""},
+	{BCM4345_CHIP_ID,	9,	DONT_CARE,	"bcm43456c5_ag",	"ap6256"},
+	{BCM43454_CHIP_ID,	9,	DONT_CARE,	"bcm43456c5_ag",	""},
+	{BCM4354_CHIP_ID,	1,	DONT_CARE,	"bcm4354a1_ag",		"ap6354"},
+	{BCM4354_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		"ap6356"},
+	{BCM4356_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		"ap6356"},
+	{BCM4371_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_ag",		""},
+	{BCM43569_CHIP_ID,	3,	DONT_CARE,	"bcm4358a3_ag",		""},
+	{BCM4359_CHIP_ID,	5,	DONT_CARE,	"bcm4359b1_ag",		""},
+	{BCM4359_CHIP_ID,	9,	DONT_CARE,	"bcm4359c0_ag",		"ap6398s"},
+#endif
+#ifdef BCMPCIE
+	{BCM4354_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_pcie_ag",	""},
+	{BCM4356_CHIP_ID,	2,	DONT_CARE,	"bcm4356a2_pcie_ag",	""},
+	{BCM4359_CHIP_ID,	9,	DONT_CARE,	"bcm4359c0_pcie_ag",	""},
+#endif
+#ifdef BCMDBUS
+	{BCM43143_CHIP_ID,	2,	DONT_CARE,	"bcm43143b0",		""},
+	{BCM43242_CHIP_ID,	1,	DONT_CARE,	"bcm43242a1_ag",	""},
+	{BCM43569_CHIP_ID,	2,	DONT_CARE,	"bcm4358u_ag",		""},
+#endif
+};
+
+void
+dhd_conf_free_chip_nv_path_list(wl_chip_nv_path_list_ctrl_t *chip_nv_list)
+{
+	CONFIG_TRACE("called\n");
+
+	if (chip_nv_list->m_chip_nv_path_head) {
+		CONFIG_TRACE("Free %p\n", chip_nv_list->m_chip_nv_path_head);
+		kfree(chip_nv_list->m_chip_nv_path_head);
+	}
+	chip_nv_list->count = 0;
+}
+
+#ifdef BCMSDIO
+void
+dhd_conf_free_mac_list(wl_mac_list_ctrl_t *mac_list)
+{
+	int i;
+
+	CONFIG_TRACE("called\n");
+	if (mac_list->m_mac_list_head) {
+		for (i=0; i<mac_list->count; i++) {
+			if (mac_list->m_mac_list_head[i].mac) {
+				CONFIG_TRACE("Free mac %p\n", mac_list->m_mac_list_head[i].mac);
+				kfree(mac_list->m_mac_list_head[i].mac);
+			}
+		}
+		CONFIG_TRACE("Free m_mac_list_head %p\n", mac_list->m_mac_list_head);
+		kfree(mac_list->m_mac_list_head);
+	}
+	mac_list->count = 0;
+}
+
+#if defined(HW_OOB) || defined(FORCE_WOWLAN)
+void
+dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip)
+{
+	uint32 gpiocontrol, addr;
+
+	if (CHIPID(chip) == BCM43362_CHIP_ID) {
+		CONFIG_MSG("Enable HW OOB for 43362\n");
+		addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, gpiocontrol);
+		gpiocontrol = bcmsdh_reg_read(sdh, addr, 4);
+		gpiocontrol |= 0x2;
+		bcmsdh_reg_write(sdh, addr, 4, gpiocontrol);
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10005, 0xf, NULL);
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10006, 0x0, NULL);
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, 0x10007, 0x2, NULL);
+	}
+}
+#endif
+
+#define SBSDIO_CIS_SIZE_LIMIT		0x200
+void
+dhd_conf_get_otp(dhd_pub_t *dhd, bcmsdh_info_t *sdh)
+{
+	int i, err = -1;
+	uint8 *ptr = 0, *ptpl_code = NULL;
+	unsigned char tpl_code, tpl_link='\0';
+	uint8 mac_header[3] = {0x80, 0x07, 0x19};
+	uint8 *cis;
+
+	if (!(cis = MALLOC(dhd->osh, SBSDIO_CIS_SIZE_LIMIT))) {
+		CONFIG_ERROR("cis malloc failed\n");
+	}
+	bzero(cis, SBSDIO_CIS_SIZE_LIMIT);
+
+	if ((err = bcmsdh_cis_read(sdh, 0, cis, SBSDIO_CIS_SIZE_LIMIT))) {
+		CONFIG_ERROR("cis read err %d\n", err);
+		MFREE(dhd->osh, cis, SBSDIO_CIS_SIZE_LIMIT);
+		return;
+	}
+	ptr = cis;
+	do {
+		/* 0xff means we're done */
+		tpl_code = *ptr;
+		ptpl_code = ptr;
+		ptr++;
+		if (tpl_code == 0xff)
+			break;
+
+		/* null entries have no link field or data */
+		if (tpl_code == 0x00)
+			continue;
+
+		tpl_link = *ptr;
+		ptr++;
+		/* a size of 0xff also means we're done */
+		if (tpl_link == 0xff)
+			break;
+		if (config_msg_level & CONFIG_TRACE_LEVEL) {
+			prhex("TPL", ptpl_code, tpl_link+2);
+		}
+
+		if (tpl_code == 0x80 && tpl_link == 0x07 && *ptr == 0x19) {
+			memcpy(&dhd->conf->otp_mac, ptr+1, 6);
+		}
+#ifdef GET_OTP_MODULE_NAME
+		else if (tpl_code == 0x8e && *ptr == 0x41) {
+			int len = tpl_link - 1;
+			if (len <= sizeof(dhd->conf->module_name) - 1) {
+				strncpy(dhd->conf->module_name, ptr+1, len);
+				CONFIG_MSG("module_name=%s\n", dhd->conf->module_name);
+			} else {
+				CONFIG_ERROR("len is too long %d >= %d\n",
+					len, (int)sizeof(dhd->conf->module_name) - 1);
+			}
+		}
+#endif
+
+		ptr += tpl_link;
+	} while (1);
+
+	if (!memcmp(&ether_null, &dhd->conf->otp_mac, ETHER_ADDR_LEN)) {
+		ptr = cis;
+		/* Special OTP */
+		if (bcmsdh_reg_read(sdh, SI_ENUM_BASE, 4) == 0x16044330) {
+			for (i=0; i<SBSDIO_CIS_SIZE_LIMIT; i++) {
+				if (!memcmp(mac_header, ptr, 3)) {
+					memcpy(&dhd->conf->otp_mac, ptr+3, 6);
+					break;
+				}
+				ptr++;
+			}
+		}
+	}
+
+	ASSERT(cis);
+	MFREE(dhd->osh, cis, SBSDIO_CIS_SIZE_LIMIT);
+}
+
+void
+dhd_conf_set_fw_name_by_mac(dhd_pub_t *dhd, char *fw_path)
+{
+	int i, j;
+	uint8 *mac = (uint8 *)&dhd->conf->otp_mac;
+	int fw_num=0, mac_num=0;
+	uint32 oui, nic;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	int fw_type, fw_type_new;
+	char *name_ptr;
+
+	mac_list = dhd->conf->fw_by_mac.m_mac_list_head;
+	fw_num = dhd->conf->fw_by_mac.count;
+	if (!mac_list || !fw_num)
+		return;
+
+	oui = (mac[0] << 16) | (mac[1] << 8) | (mac[2]);
+	nic = (mac[3] << 16) | (mac[4] << 8) | (mac[5]);
+
+	/* find out the last '/' */
+	i = strlen(fw_path);
+	while (i > 0) {
+		if (fw_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	name_ptr = &fw_path[i];
+
+	if (strstr(name_ptr, "_apsta"))
+		fw_type = FW_TYPE_APSTA;
+	else if (strstr(name_ptr, "_p2p"))
+		fw_type = FW_TYPE_P2P;
+	else if (strstr(name_ptr, "_mesh"))
+		fw_type = FW_TYPE_MESH;
+	else if (strstr(name_ptr, "_es"))
+		fw_type = FW_TYPE_ES;
+	else if (strstr(name_ptr, "_mfg"))
+		fw_type = FW_TYPE_MFG;
+	else
+		fw_type = FW_TYPE_STA;
+
+	for (i=0; i<fw_num; i++) {
+		mac_num = mac_list[i].count;
+		mac_range = mac_list[i].mac;
+		if (strstr(mac_list[i].name, "_apsta"))
+			fw_type_new = FW_TYPE_APSTA;
+		else if (strstr(mac_list[i].name, "_p2p"))
+			fw_type_new = FW_TYPE_P2P;
+		else if (strstr(mac_list[i].name, "_mesh"))
+			fw_type_new = FW_TYPE_MESH;
+		else if (strstr(mac_list[i].name, "_es"))
+			fw_type_new = FW_TYPE_ES;
+		else if (strstr(mac_list[i].name, "_mfg"))
+			fw_type_new = FW_TYPE_MFG;
+		else
+			fw_type_new = FW_TYPE_STA;
+		if (fw_type != fw_type_new) {
+			CONFIG_MSG("fw_typ=%d != fw_type_new=%d\n", fw_type, fw_type_new);
+			continue;
+		}
+		for (j=0; j<mac_num; j++) {
+			if (oui == mac_range[j].oui) {
+				if (nic >= mac_range[j].nic_start && nic <= mac_range[j].nic_end) {
+					strcpy(name_ptr, mac_list[i].name);
+					CONFIG_MSG("matched oui=0x%06X, nic=0x%06X\n", oui, nic);
+					CONFIG_MSG("fw_path=%s\n", fw_path);
+					return;
+				}
+			}
+		}
+	}
+}
+
+void
+dhd_conf_set_nv_name_by_mac(dhd_pub_t *dhd, char *nv_path)
+{
+	int i, j;
+	uint8 *mac = (uint8 *)&dhd->conf->otp_mac;
+	int nv_num=0, mac_num=0;
+	uint32 oui, nic;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	char *pnv_name;
+
+	mac_list = dhd->conf->nv_by_mac.m_mac_list_head;
+	nv_num = dhd->conf->nv_by_mac.count;
+	if (!mac_list || !nv_num)
+		return;
+
+	oui = (mac[0] << 16) | (mac[1] << 8) | (mac[2]);
+	nic = (mac[3] << 16) | (mac[4] << 8) | (mac[5]);
+
+	/* find out the last '/' */
+	i = strlen(nv_path);
+	while (i > 0) {
+		if (nv_path[i] == '/') break;
+		i--;
+	}
+	pnv_name = &nv_path[i+1];
+
+	for (i=0; i<nv_num; i++) {
+		mac_num = mac_list[i].count;
+		mac_range = mac_list[i].mac;
+		for (j=0; j<mac_num; j++) {
+			if (oui == mac_range[j].oui) {
+				if (nic >= mac_range[j].nic_start && nic <= mac_range[j].nic_end) {
+					strcpy(pnv_name, mac_list[i].name);
+					CONFIG_MSG("matched oui=0x%06X, nic=0x%06X\n", oui, nic);
+					CONFIG_MSG("nv_path=%s\n", nv_path);
+					return;
+				}
+			}
+		}
+	}
+}
+#endif
+
+void
+dhd_conf_free_country_list(struct dhd_conf *conf)
+{
+	country_list_t *country = conf->country_head;
+	int count = 0;
+
+	CONFIG_TRACE("called\n");
+	while (country) {
+		CONFIG_TRACE("Free cspec %s\n", country->cspec.country_abbrev);
+		conf->country_head = country->next;
+		kfree(country);
+		country = conf->country_head;
+		count++;
+	}
+	CONFIG_TRACE("%d country released\n", count);
+}
+
+void
+dhd_conf_free_mchan_list(struct dhd_conf *conf)
+{
+	mchan_params_t *mchan = conf->mchan;
+	int count = 0;
+
+	CONFIG_TRACE("called\n");
+	while (mchan) {
+		CONFIG_TRACE("Free cspec %p\n", mchan);
+		conf->mchan = mchan->next;
+		kfree(mchan);
+		mchan = conf->mchan;
+		count++;
+	}
+	CONFIG_TRACE("%d mchan released\n", count);
+}
+
+int
+dhd_conf_set_fw_name_by_chip(dhd_pub_t *dhd, char *fw_path)
+{
+	int fw_type, ag_type;
+	uint chip, chiprev;
+	int i;
+	char *name_ptr;
+
+	chip = dhd->conf->chip;
+	chiprev = dhd->conf->chiprev;
+
+	if (fw_path[0] == '\0') {
+#ifdef CONFIG_BCMDHD_FW_PATH
+		bcm_strncpy_s(fw_path, MOD_PARAM_PATHLEN-1, CONFIG_BCMDHD_FW_PATH, MOD_PARAM_PATHLEN-1);
+		if (fw_path[0] == '\0')
+#endif
+		{
+			CONFIG_MSG("firmware path is null\n");
+			return 0;
+		}
+	}
+#ifndef FW_PATH_AUTO_SELECT
+	return DONT_CARE;
+#endif
+
+	/* find out the last '/' */
+	i = strlen(fw_path);
+	while (i > 0) {
+		if (fw_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	name_ptr = &fw_path[i];
+#ifdef BAND_AG
+	ag_type = FW_TYPE_AG;
+#else
+	ag_type = strstr(name_ptr, "_ag") ? FW_TYPE_AG : FW_TYPE_G;
+#endif
+	if (strstr(name_ptr, "_apsta"))
+		fw_type = FW_TYPE_APSTA;
+	else if (strstr(name_ptr, "_p2p"))
+		fw_type = FW_TYPE_P2P;
+	else if (strstr(name_ptr, "_mesh"))
+		fw_type = FW_TYPE_MESH;
+	else if (strstr(name_ptr, "_es"))
+		fw_type = FW_TYPE_ES;
+	else if (strstr(name_ptr, "_mfg"))
+		fw_type = FW_TYPE_MFG;
+	else if (strstr(name_ptr, "_minime"))
+		fw_type = FW_TYPE_MINIME;
+	else
+		fw_type = FW_TYPE_STA;
+
+	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
+		const cihp_name_map_t* row = &chip_name_map[i];
+		if (row->chip == chip && row->chiprev == chiprev &&
+				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
+			strcpy(name_ptr, "fw_");
+			strcat(fw_path, row->chip_name);
+#ifdef BCMUSBDEV_COMPOSITE
+			strcat(fw_path, "_cusb");
+#endif
+			if (fw_type == FW_TYPE_APSTA)
+				strcat(fw_path, "_apsta.bin");
+			else if (fw_type == FW_TYPE_P2P)
+				strcat(fw_path, "_p2p.bin");
+			else if (fw_type == FW_TYPE_MESH)
+				strcat(fw_path, "_mesh.bin");
+			else if (fw_type == FW_TYPE_ES)
+				strcat(fw_path, "_es.bin");
+			else if (fw_type == FW_TYPE_MFG)
+				strcat(fw_path, "_mfg.bin");
+			else if (fw_type == FW_TYPE_MINIME)
+				strcat(fw_path, "_minime.bin");
+			else
+				strcat(fw_path, ".bin");
+		}
+	}
+
+	dhd->conf->fw_type = fw_type;
+
+#ifndef MINIME
+	if (fw_type == FW_TYPE_MINIME)
+		CONFIG_ERROR("***** Please enable MINIME in Makefile *****\n");
+#endif
+
+	CONFIG_TRACE("firmware_path=%s\n", fw_path);
+	return ag_type;
+}
+
+void
+dhd_conf_set_clm_name_by_chip(dhd_pub_t *dhd, char *clm_path, int ag_type)
+{
+	uint chip, chiprev;
+	int i;
+	char *name_ptr;
+
+	chip = dhd->conf->chip;
+	chiprev = dhd->conf->chiprev;
+
+	if (clm_path[0] == '\0') {
+		CONFIG_MSG("clm path is null\n");
+		return;
+	}
+
+	/* find out the last '/' */
+	i = strlen(clm_path);
+	while (i > 0) {
+		if (clm_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	name_ptr = &clm_path[i];
+
+	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
+		const cihp_name_map_t* row = &chip_name_map[i];
+		if (row->chip == chip && row->chiprev == chiprev &&
+				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
+			strcpy(name_ptr, "clm_");
+			strcat(clm_path, row->chip_name);
+			strcat(clm_path, ".blob");
+		}
+	}
+
+	CONFIG_TRACE("clm_path=%s\n", clm_path);
+}
+
+void
+dhd_conf_set_nv_name_by_chip(dhd_pub_t *dhd, char *nv_path, int ag_type)
+{
+	uint chip, chiprev;
+	int i;
+	char *name_ptr;
+
+	chip = dhd->conf->chip;
+	chiprev = dhd->conf->chiprev;
+
+	if (nv_path[0] == '\0') {
+#ifdef CONFIG_BCMDHD_NVRAM_PATH
+		bcm_strncpy_s(nv_path, MOD_PARAM_PATHLEN-1, CONFIG_BCMDHD_NVRAM_PATH, MOD_PARAM_PATHLEN-1);
+		if (nv_path[0] == '\0')
+#endif
+		{
+			CONFIG_MSG("nvram path is null\n");
+			return;
+		}
+	}
+
+	/* find out the last '/' */
+	i = strlen(nv_path);
+	while (i > 0) {
+		if (nv_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	name_ptr = &nv_path[i];
+
+	for (i = 0; i < sizeof(chip_name_map)/sizeof(chip_name_map[0]); i++) {
+		const cihp_name_map_t* row = &chip_name_map[i];
+		if (row->chip == chip && row->chiprev == chiprev &&
+				(row->ag_type == ag_type || row->ag_type == DONT_CARE)) {
+#ifdef GET_OTP_MODULE_NAME
+			if (strlen(dhd->conf->module_name)) {
+				strcpy(name_ptr, "nvram_");
+				strcat(name_ptr, dhd->conf->module_name);
+			} else
+#endif
+			if (strlen(row->module_name)){
+				strcpy(name_ptr, "nvram_");
+				strcat(name_ptr, row->module_name);
+			} else
+				continue;
+#ifdef BCMUSBDEV_COMPOSITE
+			strcat(name_ptr, "_cusb");
+#endif
+			strcat(name_ptr, ".txt");
+		}
+	}
+
+	for (i=0; i<dhd->conf->nv_by_chip.count; i++) {
+		if (chip==dhd->conf->nv_by_chip.m_chip_nv_path_head[i].chip &&
+				chiprev==dhd->conf->nv_by_chip.m_chip_nv_path_head[i].chiprev) {
+			strcpy(name_ptr, dhd->conf->nv_by_chip.m_chip_nv_path_head[i].name);
+			break;
+		}
+	}
+
+	CONFIG_TRACE("nvram_path=%s\n", nv_path);
+}
+
+void
+dhd_conf_copy_path(dhd_pub_t *dhd, char *dst_name, char *dst_path, char *src_path)
+{
+	int i;
+
+	if (src_path[0] == '\0') {
+		CONFIG_MSG("src_path is null\n");
+		return;
+	} else
+		strcpy(dst_path, src_path);
+
+	/* find out the last '/' */
+	i = strlen(dst_path);
+	while (i > 0) {
+		if (dst_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	strcpy(&dst_path[i], dst_name);
+
+	CONFIG_TRACE("dst_path=%s\n", dst_path);
+}
+
+#ifdef CONFIG_PATH_AUTO_SELECT
+void
+dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path)
+{
+	uint chip, chiprev;
+	int i;
+	char *name_ptr;
+
+	chip = dhd->conf->chip;
+	chiprev = dhd->conf->chiprev;
+
+	if (conf_path[0] == '\0') {
+		CONFIG_MSG("config path is null\n");
+		return;
+	}
+
+	/* find out the last '/' */
+	i = strlen(conf_path);
+	while (i > 0) {
+		if (conf_path[i] == '/') {
+			i++;
+			break;
+		}
+		i--;
+	}
+	name_ptr = &conf_path[i];
+
+	for (i = 0;  i < sizeof(chip_name_map)/sizeof(chip_name_map[0]);  i++) {
+		const cihp_name_map_t* row = &chip_name_map[i];
+		if (row->chip == chip && row->chiprev == chiprev) {
+			strcpy(name_ptr, "config_");
+			strcat(conf_path, row->chip_name);
+			strcat(conf_path, ".txt");
+		}
+	}
+
+	CONFIG_TRACE("config_path=%s\n", conf_path);
+}
+#endif
+
+void
+dhd_conf_set_path_params(dhd_pub_t *dhd, char *fw_path, char *nv_path)
+{
+	int ag_type;
+
+	/* External conf takes precedence if specified */
+	dhd_conf_preinit(dhd);
+
+	if (dhd->conf_path[0] == '\0') {
+		dhd_conf_copy_path(dhd, "config.txt", dhd->conf_path, nv_path);
+	}
+	if (dhd->clm_path[0] == '\0') {
+		dhd_conf_copy_path(dhd, "clm.blob", dhd->clm_path, fw_path);
+	}
+#ifdef CONFIG_PATH_AUTO_SELECT
+	dhd_conf_set_conf_name_by_chip(dhd, dhd->conf_path);
+#endif
+
+	dhd_conf_read_config(dhd, dhd->conf_path);
+
+	ag_type = dhd_conf_set_fw_name_by_chip(dhd, fw_path);
+	dhd_conf_set_nv_name_by_chip(dhd, nv_path, ag_type);
+	dhd_conf_set_clm_name_by_chip(dhd, dhd->clm_path, ag_type);
+#ifdef BCMSDIO
+	dhd_conf_set_fw_name_by_mac(dhd, fw_path);
+	dhd_conf_set_nv_name_by_mac(dhd, nv_path);
+#endif
+
+	CONFIG_MSG("Final fw_path=%s\n", fw_path);
+	CONFIG_MSG("Final nv_path=%s\n", nv_path);
+	CONFIG_MSG("Final clm_path=%s\n", dhd->clm_path);
+	CONFIG_MSG("Final conf_path=%s\n", dhd->conf_path);
+}
+
+int
+dhd_conf_set_intiovar(dhd_pub_t *dhd, uint cmd, char *name, int val,
+	int def, bool down)
+{
+	int ret = -1;
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
+
+	if (val >= def) {
+		if (down) {
+			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
+				CONFIG_ERROR("WLC_DOWN setting failed %d\n", ret);
+		}
+		if (cmd == WLC_SET_VAR) {
+			CONFIG_TRACE("set %s %d\n", name, val);
+			bcm_mkiovar(name, (char *)&val, sizeof(val), iovbuf, sizeof(iovbuf));
+			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+				CONFIG_ERROR("%s setting failed %d\n", name, ret);
+		} else {
+			CONFIG_TRACE("set %s %d %d\n", name, cmd, val);
+			if ((ret = dhd_wl_ioctl_cmd(dhd, cmd, &val, sizeof(val), TRUE, 0)) < 0)
+				CONFIG_ERROR("%s setting failed %d\n", name, ret);
+		}
+	}
+
+	return ret;
+}
+
+int
+dhd_conf_set_bufiovar(dhd_pub_t *dhd, int ifidx, uint cmd, char *name,
+	char *buf, int len, bool down)
+{
+	char iovbuf[WLC_IOCTL_SMLEN];
+	s32 iovar_len;
+	int ret = -1;
+
+	if (down) {
+		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, ifidx)) < 0)
+			CONFIG_ERROR("WLC_DOWN setting failed %d\n", ret);
+	}
+
+	if (cmd == WLC_SET_VAR) {
+		iovar_len = bcm_mkiovar(name, buf, len, iovbuf, sizeof(iovbuf));
+		if (iovar_len > 0)
+			ret = dhd_wl_ioctl_cmd(dhd, cmd, iovbuf, iovar_len, TRUE, ifidx);
+		else
+			ret = BCME_BUFTOOSHORT;
+		if (ret < 0)
+			CONFIG_ERROR("%s setting failed %d, len=%d\n", name, ret, len);
+	} else {
+		if ((ret = dhd_wl_ioctl_cmd(dhd, cmd, buf, len, TRUE, ifidx)) < 0)
+			CONFIG_ERROR("%s setting failed %d\n", name, ret);
+	}
+
+	return ret;
+}
+
+int
+dhd_conf_get_iovar(dhd_pub_t *dhd, int ifidx, int cmd, char *name,
+	char *buf, int len)
+{
+	char iovbuf[WLC_IOCTL_SMLEN];
+	int ret = -1;
+
+	if (cmd == WLC_GET_VAR) {
+		if (bcm_mkiovar(name, NULL, 0, iovbuf, sizeof(iovbuf))) {
+			ret = dhd_wl_ioctl_cmd(dhd, cmd, iovbuf, sizeof(iovbuf), FALSE, ifidx);
+			if (!ret) {
+				memcpy(buf, iovbuf, len);
+			} else {
+				CONFIG_ERROR("get iovar %s failed %d\n", name, ret);
+			}
+		} else {
+			CONFIG_ERROR("mkiovar %s failed\n", name);
+		}
+	} else {
+		ret = dhd_wl_ioctl_cmd(dhd, cmd, buf, len, FALSE, 0);
+		if (ret < 0)
+			CONFIG_ERROR("get iovar %s failed %d\n", name, ret);
+	}
+
+	return ret;
+}
+
+static int
+dhd_conf_rsdb_mode(dhd_pub_t *dhd, char *buf)
+{
+	wl_config_t rsdb_mode_cfg = {1, 0};
+
+	if (buf) {
+		rsdb_mode_cfg.config = (int)simple_strtol(buf, NULL, 0);
+		CONFIG_MSG("rsdb_mode %d\n", rsdb_mode_cfg.config);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "rsdb_mode", (char *)&rsdb_mode_cfg,
+			sizeof(rsdb_mode_cfg), TRUE);
+	}
+
+	return 0;
+}
+
+typedef int (tpl_parse_t)(dhd_pub_t *dhd, char *buf);
+
+typedef struct iovar_tpl_t {
+	int cmd;
+	char *name;
+	tpl_parse_t *parse;
+} iovar_tpl_t;
+
+const iovar_tpl_t iovar_tpl_list[] = {
+	{WLC_SET_VAR,	"rsdb_mode",	dhd_conf_rsdb_mode},
+};
+
+static int iovar_tpl_parse(const iovar_tpl_t *tpl, int tpl_count,
+	dhd_pub_t *dhd, int cmd, char *name, char *buf)
+{
+	int i, ret = 0;
+
+	/* look for a matching code in the table */
+	for (i = 0; i < tpl_count; i++, tpl++) {
+		if (tpl->cmd == cmd && !strcmp(tpl->name, name))
+			break;
+	}
+	if (i < tpl_count && tpl->parse) {
+		ret = tpl->parse(dhd, buf);
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+}
+
+bool
+dhd_conf_set_wl_cmd(dhd_pub_t *dhd, char *data, bool down)
+{
+	int cmd, val, ret = 0, len;
+	char name[32], *pch, *pick_tmp, *pick_tmp2, *pdata = NULL;
+
+	/* Process wl_preinit:
+	 * wl_preinit=[cmd]=[val], [cmd]=[val]
+	 * Ex: wl_preinit=86=0, mpc=0
+	 */
+
+	if (data == NULL)
+		return FALSE;
+
+	len = strlen(data);
+	pdata = kmalloc(len+1, GFP_KERNEL);
+	if (pdata == NULL) {
+		CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", len+1);
+		goto exit;
+	}
+	memset(pdata, 0, len+1);
+	strcpy(pdata, data);
+
+	pick_tmp = pdata;
+	while (pick_tmp && (pick_tmp2 = bcmstrtok(&pick_tmp, ",", 0)) != NULL) {
+		pch = bcmstrtok(&pick_tmp2, "=", 0);
+		if (!pch)
+			break;
+		if (*pch == ' ') {
+			pch++;
+		}
+		memset(name, 0 , sizeof (name));
+		cmd = (int)simple_strtol(pch, NULL, 0);
+		if (cmd == 0) {
+			cmd = WLC_SET_VAR;
+			strcpy(name, pch);
+		}
+		pch = bcmstrtok(&pick_tmp2, ",", 0);
+		if (!pch) {
+			break;
+		}
+		ret = iovar_tpl_parse(iovar_tpl_list, ARRAY_SIZE(iovar_tpl_list),
+			dhd, cmd, name, pch);
+		if (ret) {
+			val = (int)simple_strtol(pch, NULL, 0);
+			dhd_conf_set_intiovar(dhd, cmd, name, val, -1, down);
+		}
+	}
+
+exit:
+	if (pdata)
+		kfree(pdata);
+	return true;
+}
+
+int
+dhd_conf_get_band(dhd_pub_t *dhd)
+{
+	int band = -1;
+
+	if (dhd && dhd->conf)
+		band = dhd->conf->band;
+	else
+		CONFIG_ERROR("dhd or conf is NULL\n");
+
+	return band;
+}
+
+int
+dhd_conf_get_country(dhd_pub_t *dhd, wl_country_t *cspec)
+{
+	int bcmerror = -1;
+
+	memset(cspec, 0, sizeof(wl_country_t));
+	bcm_mkiovar("country", NULL, 0, (char*)cspec, sizeof(wl_country_t));
+	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, cspec, sizeof(wl_country_t),
+			FALSE, 0)) < 0)
+		CONFIG_ERROR("country code getting failed %d\n", bcmerror);
+
+	return bcmerror;
+}
+
+int
+dhd_conf_map_country_list(dhd_pub_t *dhd, wl_country_t *cspec)
+{
+	int bcmerror = -1;
+	struct dhd_conf *conf = dhd->conf;
+	country_list_t *country = conf->country_head;
+
+#ifdef CCODE_LIST
+	bcmerror = dhd_ccode_map_country_list(dhd, cspec);
+#endif
+
+	while (country != NULL) {
+		if (!strncmp("**", country->cspec.country_abbrev, 2)) {
+			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
+			cspec->rev = country->cspec.rev;
+			bcmerror = 0;
+			break;
+		} else if (!strncmp(cspec->country_abbrev,
+				country->cspec.country_abbrev, 2)) {
+			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
+			cspec->rev = country->cspec.rev;
+			bcmerror = 0;
+			break;
+		}
+		country = country->next;
+	}
+
+	if (!bcmerror)
+		CONFIG_MSG("%s/%d\n", cspec->ccode, cspec->rev);
+
+	return bcmerror;
+}
+
+int
+dhd_conf_set_country(dhd_pub_t *dhd, wl_country_t *cspec)
+{
+	int bcmerror = -1;
+
+	memset(&dhd->dhd_cspec, 0, sizeof(wl_country_t));
+
+	CONFIG_MSG("set country %s, revision %d\n", cspec->ccode, cspec->rev);
+	bcmerror = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "country", (char *)cspec,
+		sizeof(wl_country_t), FALSE);
+	dhd_conf_get_country(dhd, cspec);
+	CONFIG_MSG("Country code: %s (%s/%d)\n",
+		cspec->country_abbrev, cspec->ccode, cspec->rev);
+
+	return bcmerror;
+}
+
+int
+dhd_conf_fix_country(dhd_pub_t *dhd)
+{
+	int bcmerror = -1;
+	int band;
+	wl_uint32_list_t *list;
+	u8 valid_chan_list[sizeof(u32)*(WL_NUMCHANNELS + 1)];
+	wl_country_t cspec;
+
+	if (!(dhd && dhd->conf)) {
+		return bcmerror;
+	}
+
+	memset(valid_chan_list, 0, sizeof(valid_chan_list));
+	list = (wl_uint32_list_t *)(void *) valid_chan_list;
+	list->count = htod32(WL_NUMCHANNELS);
+	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VALID_CHANNELS, valid_chan_list,
+			sizeof(valid_chan_list), FALSE, 0)) < 0) {
+		CONFIG_ERROR("get channels failed with %d\n", bcmerror);
+	}
+
+	band = dhd_conf_get_band(dhd);
+
+	if (bcmerror || ((band==WLC_BAND_AUTO || band==WLC_BAND_2G || band==-1) &&
+			dtoh32(list->count)<11)) {
+		CONFIG_ERROR("bcmerror=%d, # of channels %d\n",
+			bcmerror, dtoh32(list->count));
+		dhd_conf_map_country_list(dhd, &dhd->conf->cspec);
+		if ((bcmerror = dhd_conf_set_country(dhd, &dhd->conf->cspec)) < 0) {
+			strcpy(cspec.country_abbrev, "US");
+			cspec.rev = 0;
+			strcpy(cspec.ccode, "US");
+			dhd_conf_map_country_list(dhd, &cspec);
+			dhd_conf_set_country(dhd, &cspec);
+		}
+	}
+
+	return bcmerror;
+}
+
+bool
+dhd_conf_match_channel(dhd_pub_t *dhd, uint32 channel)
+{
+	int i;
+	bool match = false;
+
+	if (dhd && dhd->conf) {
+		if (dhd->conf->channels.count == 0)
+			return true;
+		for (i=0; i<dhd->conf->channels.count; i++) {
+			if (channel == dhd->conf->channels.channel[i])
+				match = true;
+		}
+	} else {
+		match = true;
+		CONFIG_ERROR("dhd or conf is NULL\n");
+	}
+
+	return match;
+}
+
+int
+dhd_conf_set_roam(dhd_pub_t *dhd)
+{
+	int bcmerror = -1;
+	struct dhd_conf *conf = dhd->conf;
+
+	dhd_roam_disable = conf->roam_off;
+	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off", dhd->conf->roam_off, 0, FALSE);
+
+	if (!conf->roam_off || !conf->roam_off_suspend) {
+		CONFIG_MSG("set roam_trigger %d\n", conf->roam_trigger[0]);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_TRIGGER, "WLC_SET_ROAM_TRIGGER",
+			(char *)conf->roam_trigger, sizeof(conf->roam_trigger), FALSE);
+
+		CONFIG_MSG("set roam_scan_period %d\n", conf->roam_scan_period[0]);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_SCAN_PERIOD, "WLC_SET_ROAM_SCAN_PERIOD",
+			(char *)conf->roam_scan_period, sizeof(conf->roam_scan_period), FALSE);
+
+		CONFIG_MSG("set roam_delta %d\n", conf->roam_delta[0]);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_ROAM_DELTA, "WLC_SET_ROAM_DELTA",
+			(char *)conf->roam_delta, sizeof(conf->roam_delta), FALSE);
+
+		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "fullroamperiod",
+			dhd->conf->fullroamperiod, 1, FALSE);
+	}
+
+	return bcmerror;
+}
+
+void
+dhd_conf_add_to_eventbuffer(struct eventmsg_buf *ev, u16 event, bool set)
+{
+	if (!ev || (event > WLC_E_LAST))
+		return;
+
+	if (ev->num < MAX_EVENT_BUF_NUM) {
+		ev->event[ev->num].type = event;
+		ev->event[ev->num].set = set;
+		ev->num++;
+	} else {
+		CONFIG_ERROR("evenbuffer doesn't support > %u events. Update"
+			" the define MAX_EVENT_BUF_NUM \n", MAX_EVENT_BUF_NUM);
+		ASSERT(0);
+	}
+}
+
+s32
+dhd_conf_apply_eventbuffer(dhd_pub_t *dhd, eventmsg_buf_t *ev)
+{
+	char eventmask[WL_EVENTING_MASK_LEN];
+	int i, ret = 0;
+
+	if (!ev || (!ev->num))
+		return -EINVAL;
+
+	/* Read event_msgs mask */
+	ret = dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "event_msgs", eventmask,
+		sizeof(eventmask));
+	if (unlikely(ret)) {
+		CONFIG_ERROR("Get event_msgs error (%d)\n", ret);
+		goto exit;
+	}
+
+	/* apply the set bits */
+	for (i = 0; i < ev->num; i++) {
+		if (ev->event[i].set)
+			setbit(eventmask, ev->event[i].type);
+		else
+			clrbit(eventmask, ev->event[i].type);
+	}
+
+	/* Write updated Event mask */
+	ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs", eventmask,
+		sizeof(eventmask), FALSE);
+	if (unlikely(ret)) {
+		CONFIG_ERROR("Set event_msgs error (%d)\n", ret);
+	}
+
+exit:
+	return ret;
+}
+
+int
+dhd_conf_enable_roam_offload(dhd_pub_t *dhd, int enable)
+{
+	int err;
+	eventmsg_buf_t ev_buf;
+
+	if (dhd->conf->roam_off_suspend)
+		return 0;
+
+	err = dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_offload", enable, 0, FALSE);
+	if (err)
+		return err;
+
+	bzero(&ev_buf, sizeof(eventmsg_buf_t));
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_PSK_SUP, !enable);
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ASSOC_REQ_IE, !enable);
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ASSOC_RESP_IE, !enable);
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_REASSOC, !enable);
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_JOIN, !enable);
+	dhd_conf_add_to_eventbuffer(&ev_buf, WLC_E_ROAM, !enable);
+	err = dhd_conf_apply_eventbuffer(dhd, &ev_buf);
+
+	CONFIG_TRACE("roam_offload %d\n", enable);
+
+	return err;
+}
+
+void
+dhd_conf_set_bw_cap(dhd_pub_t *dhd)
+{
+	struct {
+		u32 band;
+		u32 bw_cap;
+	} param = {0, 0};
+
+	if (dhd->conf->bw_cap[0] >= 0) {
+		memset(&param, 0, sizeof(param));
+		param.band = WLC_BAND_2G;
+		param.bw_cap = (uint)dhd->conf->bw_cap[0];
+		CONFIG_MSG("set bw_cap 2g 0x%x\n", param.bw_cap);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "bw_cap", (char *)&param,
+			sizeof(param), TRUE);
+	}
+
+	if (dhd->conf->bw_cap[1] >= 0) {
+		memset(&param, 0, sizeof(param));
+		param.band = WLC_BAND_5G;
+		param.bw_cap = (uint)dhd->conf->bw_cap[1];
+		CONFIG_MSG("set bw_cap 5g 0x%x\n", param.bw_cap);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "bw_cap", (char *)&param,
+			sizeof(param), TRUE);
+	}
+}
+
+void
+dhd_conf_get_wme(dhd_pub_t *dhd, int ifidx, int mode, edcf_acparam_t *acp)
+{
+	int bcmerror = -1;
+	char iovbuf[WLC_IOCTL_SMLEN];
+	edcf_acparam_t *acparam;
+
+	bzero(iovbuf, sizeof(iovbuf));
+
+	/*
+	 * Get current acparams, using buf as an input buffer.
+	 * Return data is array of 4 ACs of wme params.
+	 */
+	if (mode == 0)
+		bcm_mkiovar("wme_ac_sta", NULL, 0, iovbuf, sizeof(iovbuf));
+	else
+		bcm_mkiovar("wme_ac_ap", NULL, 0, iovbuf, sizeof(iovbuf));
+	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf),
+			FALSE, ifidx)) < 0) {
+		CONFIG_ERROR("wme_ac_sta getting failed %d\n", bcmerror);
+		return;
+	}
+	memcpy((char*)acp, iovbuf, sizeof(edcf_acparam_t)*AC_COUNT);
+
+	acparam = &acp[AC_BK];
+	CONFIG_TRACE("BK: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
+		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
+		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
+		acparam->TXOP);
+	acparam = &acp[AC_BE];
+	CONFIG_TRACE("BE: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
+		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
+		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
+		acparam->TXOP);
+	acparam = &acp[AC_VI];
+	CONFIG_TRACE("VI: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
+		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
+		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
+		acparam->TXOP);
+	acparam = &acp[AC_VO];
+	CONFIG_TRACE("VO: aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
+		acparam->ACI, acparam->ACI&EDCF_AIFSN_MASK,
+		acparam->ECW&EDCF_ECWMIN_MASK, (acparam->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
+		acparam->TXOP);
+
+	return;
+}
+
+void
+dhd_conf_update_wme(dhd_pub_t *dhd, int ifidx, int mode,
+	edcf_acparam_t *acparam_cur, int aci)
+{
+	int aifsn, ecwmin, ecwmax, txop;
+	edcf_acparam_t *acp;
+	struct dhd_conf *conf = dhd->conf;
+	wme_param_t *wme;
+
+	if (mode == 0)
+		wme = &conf->wme_sta;
+	else
+		wme = &conf->wme_ap;
+
+	/* Default value */
+	aifsn = acparam_cur->ACI&EDCF_AIFSN_MASK;
+	ecwmin = acparam_cur->ECW&EDCF_ECWMIN_MASK;
+	ecwmax = (acparam_cur->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT;
+	txop = acparam_cur->TXOP;
+
+	/* Modified value */
+	if (wme->aifsn[aci] > 0)
+		aifsn = wme->aifsn[aci];
+	if (wme->ecwmin[aci] > 0)
+		ecwmin = wme->ecwmin[aci];
+	if (wme->ecwmax[aci] > 0)
+		ecwmax = wme->ecwmax[aci];
+	if (wme->txop[aci] > 0)
+		txop = wme->txop[aci];
+
+	if (!(wme->aifsn[aci] || wme->ecwmin[aci] ||
+			wme->ecwmax[aci] || wme->txop[aci]))
+		return;
+
+	/* Update */
+	acp = acparam_cur;
+	acp->ACI = (acp->ACI & ~EDCF_AIFSN_MASK) | (aifsn & EDCF_AIFSN_MASK);
+	acp->ECW = ((ecwmax << EDCF_ECWMAX_SHIFT) & EDCF_ECWMAX_MASK) | (acp->ECW & EDCF_ECWMIN_MASK);
+	acp->ECW = ((acp->ECW & EDCF_ECWMAX_MASK) | (ecwmin & EDCF_ECWMIN_MASK));
+	acp->TXOP = txop;
+
+	CONFIG_MSG("wme_ac %s aci %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",
+		mode?"ap":"sta", acp->ACI, acp->ACI&EDCF_AIFSN_MASK,
+		acp->ECW&EDCF_ECWMIN_MASK, (acp->ECW&EDCF_ECWMAX_MASK)>>EDCF_ECWMAX_SHIFT,
+		acp->TXOP);
+
+	/*
+	* Now use buf as an output buffer.
+	* Put WME acparams after "wme_ac\0" in buf.
+	* NOTE: only one of the four ACs can be set at a time.
+	*/
+	if (mode == 0)
+		dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "wme_ac_sta", (char *)acp,
+			sizeof(edcf_acparam_t), FALSE);
+	else
+		dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "wme_ac_ap", (char *)acp,
+			sizeof(edcf_acparam_t), FALSE);
+
+}
+
+void
+dhd_conf_set_wme(dhd_pub_t *dhd, int ifidx, int mode)
+{
+	edcf_acparam_t acparam_cur[AC_COUNT];
+
+	if (dhd && dhd->conf) {
+		if (!dhd->conf->force_wme_ac) {
+			CONFIG_TRACE("force_wme_ac is not enabled %d\n",
+				dhd->conf->force_wme_ac);
+			return;
+		}
+
+		CONFIG_TRACE("Before change:\n");
+		dhd_conf_get_wme(dhd, ifidx, mode, acparam_cur);
+
+		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_BK], AC_BK);
+		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_BE], AC_BE);
+		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_VI], AC_VI);
+		dhd_conf_update_wme(dhd, ifidx, mode, &acparam_cur[AC_VO], AC_VO);
+
+		CONFIG_TRACE("After change:\n");
+		dhd_conf_get_wme(dhd, ifidx, mode, acparam_cur);
+	} else {
+		CONFIG_ERROR("dhd or conf is NULL\n");
+	}
+
+	return;
+}
+
+void
+dhd_conf_set_mchan_bw(dhd_pub_t *dhd, int p2p_mode, int miracast_mode)
+{
+	struct dhd_conf *conf = dhd->conf;
+	mchan_params_t *mchan = conf->mchan;
+	bool set = true;
+
+	while (mchan != NULL) {
+		set = true;
+		set &= (mchan->bw >= 0);
+		set &= ((mchan->p2p_mode == -1) | (mchan->p2p_mode == p2p_mode));
+		set &= ((mchan->miracast_mode == -1) | (mchan->miracast_mode == miracast_mode));
+		if (set) {
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "mchan_bw", mchan->bw, 0, FALSE);
+		}
+		mchan = mchan->next;
+	}
+
+	return;
+}
+
+#ifdef PKT_FILTER_SUPPORT
+void
+dhd_conf_add_pkt_filter(dhd_pub_t *dhd)
+{
+	int i, j;
+	char str[16];
+#define MACS "%02x%02x%02x%02x%02x%02x"
+
+	/*
+	 * Filter in less pkt: ARP(0x0806, ID is 105), BRCM(0x886C), 802.1X(0x888E)
+	 *   1) dhd_master_mode=1
+	 *   2) pkt_filter_delete=100, 102, 103, 104, 105, 106, 107
+	 *   3) pkt_filter_add=131 0 0 12 0xFFFF 0x886C, 132 0 0 12 0xFFFF 0x888E
+	 *   4) magic_pkt_filter_add=141 0 1 12
+	 */
+	for(i=0; i<dhd->conf->pkt_filter_add.count; i++) {
+		dhd->pktfilter[i+dhd->pktfilter_count] = dhd->conf->pkt_filter_add.filter[i];
+		CONFIG_MSG("%s\n", dhd->pktfilter[i+dhd->pktfilter_count]);
+	}
+	dhd->pktfilter_count += i;
+
+	if (dhd->conf->magic_pkt_filter_add) {
+		strcat(dhd->conf->magic_pkt_filter_add, " 0x");
+		strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
+		for (j=0; j<16; j++)
+			strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
+		strcat(dhd->conf->magic_pkt_filter_add, " 0x");
+		strcat(dhd->conf->magic_pkt_filter_add, "FFFFFFFFFFFF");
+		sprintf(str, MACS, MAC2STRDBG(dhd->mac.octet));
+		for (j=0; j<16; j++)
+			strncat(dhd->conf->magic_pkt_filter_add, str, 12);
+		dhd->pktfilter[dhd->pktfilter_count] = dhd->conf->magic_pkt_filter_add;
+		dhd->pktfilter_count += 1;
+	}
+}
+
+bool
+dhd_conf_del_pkt_filter(dhd_pub_t *dhd, uint32 id)
+{
+	int i;
+
+	if (dhd && dhd->conf) {
+		for (i=0; i<dhd->conf->pkt_filter_del.count; i++) {
+			if (id == dhd->conf->pkt_filter_del.id[i]) {
+				CONFIG_MSG("%d\n", dhd->conf->pkt_filter_del.id[i]);
+				return true;
+			}
+		}
+		return false;
+	}
+	return false;
+}
+
+void
+dhd_conf_discard_pkt_filter(dhd_pub_t *dhd)
+{
+	dhd->pktfilter_count = 6;
+	dhd->pktfilter[DHD_UNICAST_FILTER_NUM] = NULL;
+	dhd->pktfilter[DHD_BROADCAST_FILTER_NUM] = "101 0 0 0 0xFFFFFFFFFFFF 0xFFFFFFFFFFFF";
+	dhd->pktfilter[DHD_MULTICAST4_FILTER_NUM] = "102 0 0 0 0xFFFFFF 0x01005E";
+	dhd->pktfilter[DHD_MULTICAST6_FILTER_NUM] = "103 0 0 0 0xFFFF 0x3333";
+	dhd->pktfilter[DHD_MDNS_FILTER_NUM] = NULL;
+	/* Do not enable ARP to pkt filter if dhd_master_mode is false.*/
+	dhd->pktfilter[DHD_ARP_FILTER_NUM] = NULL;
+
+	/* IPv4 broadcast address XXX.XXX.XXX.255 */
+	dhd->pktfilter[dhd->pktfilter_count] = "110 0 0 12 0xFFFF00000000000000000000000000000000000000FF 0x080000000000000000000000000000000000000000FF";
+	dhd->pktfilter_count++;
+	/* discard IPv4 multicast address 224.0.0.0/4 */
+	dhd->pktfilter[dhd->pktfilter_count] = "111 0 0 12 0xFFFF00000000000000000000000000000000F0 0x080000000000000000000000000000000000E0";
+	dhd->pktfilter_count++;
+	/* discard IPv6 multicast address FF00::/8 */
+	dhd->pktfilter[dhd->pktfilter_count] = "112 0 0 12 0xFFFF000000000000000000000000000000000000000000000000FF 0x86DD000000000000000000000000000000000000000000000000FF";
+	dhd->pktfilter_count++;
+	/* discard Netbios pkt */
+	dhd->pktfilter[dhd->pktfilter_count] = "121 0 0 12 0xFFFF000000000000000000FF000000000000000000000000FFFF 0x0800000000000000000000110000000000000000000000000089";
+	dhd->pktfilter_count++;
+
+}
+#endif /* PKT_FILTER_SUPPORT */
+
+int
+dhd_conf_get_pm(dhd_pub_t *dhd)
+{
+	if (dhd && dhd->conf) {
+		return dhd->conf->pm;
+	}
+	return -1;
+}
+
+int
+dhd_conf_check_hostsleep(dhd_pub_t *dhd, int cmd, void *buf, int len,
+	int *hostsleep_set, int *hostsleep_val, int *ret)
+{
+	if (dhd->conf->insuspend & (NO_TXCTL_IN_SUSPEND | WOWL_IN_SUSPEND)) {
+		if (cmd == WLC_SET_VAR) {
+			char *psleep = NULL;
+			psleep = strstr(buf, "hostsleep");
+			if (psleep) {
+				*hostsleep_set = 1;
+				memcpy(hostsleep_val, psleep+strlen("hostsleep")+1, sizeof(int));
+			}
+		}
+		if (dhd->hostsleep && (!*hostsleep_set || *hostsleep_val)) {
+			CONFIG_TRACE("block all none hostsleep clr cmd\n");
+			*ret = BCME_EPERM;
+			goto exit;
+		} else if (*hostsleep_set && *hostsleep_val) {
+			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
+			dhd->hostsleep = *hostsleep_val;
+			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+				dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+			}
+			if (dhd->hostsleep == 2) {
+				*ret = 0;
+				goto exit;
+			}
+		} else if (dhd->hostsleep == 2 && !*hostsleep_val) {
+			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
+			dhd->hostsleep = *hostsleep_val;
+			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+				dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+			}
+			*ret = 0;
+			goto exit;
+		}
+	}
+#ifdef NO_POWER_SAVE
+	if (cmd == WLC_SET_PM) {
+		if (*(const u32*)buf != 0) {
+			CONFIG_TRACE("skip PM\n");
+			*ret = BCME_OK;
+			goto exit;
+		}
+	} else if (cmd == WLC_SET_VAR) {
+		int cmd_len = strlen("mpc");
+		if (!strncmp(buf, "mpc", cmd_len)) {
+			if (*((u32 *)((u8*)buf+cmd_len+1)) != 0) {
+				CONFIG_TRACE("skip mpc\n");
+				*ret = BCME_OK;
+				goto exit;
+			}
+		}
+	}
+#endif
+
+	return 0;
+exit:
+	return -1;
+}
+
+void
+dhd_conf_get_hostsleep(dhd_pub_t *dhd,
+	int hostsleep_set, int hostsleep_val, int ret)
+{
+	if (dhd->conf->insuspend & (NO_TXCTL_IN_SUSPEND | WOWL_IN_SUSPEND)) {
+		if (hostsleep_set) {
+			if (hostsleep_val && ret) {
+				CONFIG_TRACE("reset hostsleep %d => 0\n", dhd->hostsleep);
+				dhd->hostsleep = 0;
+				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				}
+			} else if (!hostsleep_val && !ret) {
+				CONFIG_TRACE("set hostsleep %d => 0\n", dhd->hostsleep);
+				dhd->hostsleep = 0;
+				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				}
+			}
+		}
+	}
+}
+
+#ifdef WL_EXT_WOWL
+#define WL_WOWL_TCPFIN	(1 << 26)
+typedef struct wl_wowl_pattern2 {
+	char cmd[4];
+	wl_wowl_pattern_t wowl_pattern;
+} wl_wowl_pattern2_t;
+static int
+dhd_conf_wowl_pattern(dhd_pub_t *dhd, bool add, char *data)
+{
+	uint buf_len = 0;
+	int	id, type, polarity, offset;
+	char cmd[4]="\0", mask[128]="\0", pattern[128]="\0", mask_tmp[128]="\0", *pmask_tmp;
+	uint32 masksize, patternsize, pad_len = 0;
+	wl_wowl_pattern2_t *wowl_pattern2 = NULL;
+	char *mask_and_pattern;
+	int ret = 0, i, j, v;
+
+	if (data) {
+		if (add)
+			strcpy(cmd, "add");
+		else
+			strcpy(cmd, "clr");
+		if (!strcmp(cmd, "clr")) {
+			CONFIG_TRACE("wowl_pattern clr\n");
+			ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_pattern", cmd,
+				sizeof(cmd), FALSE);
+			goto exit;
+		}
+		sscanf(data, "%d %d %d %d %s %s", &id, &type, &polarity, &offset,
+			mask_tmp, pattern);
+		masksize = strlen(mask_tmp) -2;
+		CONFIG_TRACE("0 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
+
+		// add pading
+		if (masksize % 16)
+			pad_len = (16 - masksize % 16);
+		for (i=0; i<pad_len; i++)
+			strcat(mask_tmp, "0");
+		masksize += pad_len;
+		CONFIG_TRACE("1 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
+
+		// translate 0x00 to 0, others to 1
+		j = 0;
+		pmask_tmp = &mask_tmp[2];
+		for (i=0; i<masksize/2; i++) {
+			if(strncmp(&pmask_tmp[i*2], "00", 2))
+				pmask_tmp[j] = '1';
+			else
+				pmask_tmp[j] = '0';
+			j++;
+		}
+		pmask_tmp[j] = '\0';
+		masksize = masksize / 2;
+		CONFIG_TRACE("2 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
+
+		// reorder per 8bits
+		pmask_tmp = &mask_tmp[2];
+		for (i=0; i<masksize/8; i++) {
+			char c;
+			for (j=0; j<4; j++) {
+				c = pmask_tmp[i*8+j];
+				pmask_tmp[i*8+j] = pmask_tmp[(i+1)*8-j-1];
+				pmask_tmp[(i+1)*8-j-1] = c;
+			}
+		}
+		CONFIG_TRACE("3 mask_tmp=%s, masksize=%d\n", mask_tmp, masksize);
+
+		// translate 8bits to 1byte
+		j = 0; v = 0;
+		pmask_tmp = &mask_tmp[2];
+		strcpy(mask, "0x");
+		for (i=0; i<masksize; i++) {
+			v = (v<<1) | (pmask_tmp[i]=='1');
+			if (((i+1)%4) == 0) {
+				if (v < 10)
+					mask[j+2] = v + '0';
+				else
+					mask[j+2] = (v-10) + 'a';
+				j++;
+				v = 0;
+			}
+		}
+		mask[j+2] = '\0';
+		masksize = j/2;
+		CONFIG_TRACE("4 mask=%s, masksize=%d\n", mask, masksize);
+
+		patternsize = (strlen(pattern)-2)/2;
+		buf_len = sizeof(wl_wowl_pattern2_t) + patternsize + masksize;
+		wowl_pattern2 = kmalloc(buf_len, GFP_KERNEL);
+		if (wowl_pattern2 == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", buf_len);
+			goto exit;
+		}
+		memset(wowl_pattern2, 0, sizeof(wl_wowl_pattern2_t));
+
+		strncpy(wowl_pattern2->cmd, cmd, sizeof(cmd));
+		wowl_pattern2->wowl_pattern.id = id;
+		wowl_pattern2->wowl_pattern.type = 0;
+		wowl_pattern2->wowl_pattern.offset = offset;
+		mask_and_pattern = (char*)wowl_pattern2 + sizeof(wl_wowl_pattern2_t);
+
+		wowl_pattern2->wowl_pattern.masksize = masksize;
+		ret = wl_pattern_atoh(mask, mask_and_pattern);
+		if (ret == -1) {
+			CONFIG_ERROR("rejecting mask=%s\n", mask);
+			goto exit;
+		}
+
+		mask_and_pattern += wowl_pattern2->wowl_pattern.masksize;
+		wowl_pattern2->wowl_pattern.patternoffset = sizeof(wl_wowl_pattern_t) +
+			wowl_pattern2->wowl_pattern.masksize;
+
+		wowl_pattern2->wowl_pattern.patternsize = patternsize;
+		ret = wl_pattern_atoh(pattern, mask_and_pattern);
+		if (ret == -1) {
+			CONFIG_ERROR("rejecting pattern=%s\n", pattern);
+			goto exit;
+		}
+
+		CONFIG_TRACE("%s %d %s %s\n", cmd, offset, mask, pattern);
+
+		ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_pattern",
+			(char *)wowl_pattern2, buf_len, FALSE);
+	}
+
+exit:
+	if (wowl_pattern2)
+		kfree(wowl_pattern2);
+	return ret;
+}
+
+static int
+dhd_conf_wowl_wakeind(dhd_pub_t *dhd, bool clear)
+{
+	s8 iovar_buf[WLC_IOCTL_SMLEN];
+	wl_wowl_wakeind_t *wake = NULL;
+	int ret = -1;
+	char clr[6]="clear", wakeind_str[32]="\0";
+
+	if (clear) {
+		CONFIG_TRACE("wowl_wakeind clear\n");
+		ret = dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "wowl_wakeind",
+			clr, sizeof(clr), 0);
+	} else {
+		ret = dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "wowl_wakeind",
+			iovar_buf, sizeof(iovar_buf));
+		if (!ret) {
+			wake = (wl_wowl_wakeind_t *) iovar_buf;
+			if (wake->ucode_wakeind & WL_WOWL_MAGIC)
+				strcpy(wakeind_str, "(MAGIC packet)");
+			if (wake->ucode_wakeind & WL_WOWL_NET)
+				strcpy(wakeind_str, "(Netpattern)");
+			if (wake->ucode_wakeind & WL_WOWL_DIS)
+				strcpy(wakeind_str, "(Disassoc/Deauth)");
+			if (wake->ucode_wakeind & WL_WOWL_BCN)
+				strcpy(wakeind_str, "(Loss of beacon)");
+			if (wake->ucode_wakeind & WL_WOWL_TCPKEEP_TIME)
+				strcpy(wakeind_str, "(TCPKA timeout)");
+			if (wake->ucode_wakeind & WL_WOWL_TCPKEEP_DATA)
+				strcpy(wakeind_str, "(TCPKA data)");
+			if (wake->ucode_wakeind & WL_WOWL_TCPFIN)
+				strcpy(wakeind_str, "(TCP FIN)");
+			CONFIG_MSG("wakeind=0x%x %s\n", wake->ucode_wakeind, wakeind_str);
+		}
+	}
+
+	return ret;
+}
+#endif
+
+int
+dhd_conf_mkeep_alive(dhd_pub_t *dhd, int ifidx, int id, int period,
+	char *packet, bool bcast)
+{
+	wl_mkeep_alive_pkt_t *mkeep_alive_pktp;
+	int ret = 0, len_bytes=0, buf_len=0;
+	char *buf = NULL, *iovar_buf = NULL;
+	uint8 *pdata;
+
+	CONFIG_TRACE("id=%d, period=%d, packet=%s\n", id, period, packet);
+	if (period >= 0) {
+		buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		iovar_buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (iovar_buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *)buf;
+		mkeep_alive_pktp->version = htod16(WL_MKEEP_ALIVE_VERSION);
+		mkeep_alive_pktp->length = htod16(WL_MKEEP_ALIVE_FIXED_LEN);
+		mkeep_alive_pktp->keep_alive_id = id;
+		buf_len += WL_MKEEP_ALIVE_FIXED_LEN;
+		mkeep_alive_pktp->period_msec = period;
+		if (packet && strlen(packet)) {
+			len_bytes = wl_pattern_atoh(packet, (char *)mkeep_alive_pktp->data);
+			buf_len += len_bytes;
+			if (bcast) {
+				memcpy(mkeep_alive_pktp->data, &ether_bcast, ETHER_ADDR_LEN);
+			}
+			ret = dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr",
+				iovar_buf, WLC_IOCTL_SMLEN);
+			if (!ret) {
+				pdata = mkeep_alive_pktp->data;
+				memcpy(pdata+6, iovar_buf, ETHER_ADDR_LEN);
+			}
+		}
+		mkeep_alive_pktp->len_bytes = htod16(len_bytes);
+		ret = dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "mkeep_alive",
+			buf, buf_len, FALSE);
+	}
+
+exit:
+	if (buf)
+		kfree(buf);
+	if (iovar_buf)
+		kfree(iovar_buf);
+	return ret;
+}
+
+#ifdef ARP_OFFLOAD_SUPPORT
+void
+dhd_conf_set_garp(dhd_pub_t *dhd, int ifidx, uint32 ipa, bool enable)
+{
+	int i, len = 0, total_len = WLC_IOCTL_SMLEN;
+	char *iovar_buf = NULL, *packet = NULL;
+
+	if (!dhd->conf->garp || ifidx != 0 || !(dhd->op_mode & DHD_FLAG_STA_MODE))
+		return;
+
+	CONFIG_TRACE("enable=%d\n", enable);
+
+	if (enable) {
+		iovar_buf = kmalloc(total_len, GFP_KERNEL);
+		if (iovar_buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
+			goto exit;
+		}
+		packet = kmalloc(total_len, GFP_KERNEL);
+		if (packet == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
+			goto exit;
+		}
+		dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr", iovar_buf, total_len);
+
+		len += snprintf(packet+len, total_len, "0xffffffffffff");
+		for (i=0; i<ETHER_ADDR_LEN; i++)
+			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
+		len += snprintf(packet+len, total_len, "08060001080006040001");
+		 // Sender Hardware Addr.
+		for (i=0; i<ETHER_ADDR_LEN; i++)
+			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
+		 // Sender IP Addr.
+		len += snprintf(packet+len, total_len, "%02x%02x%02x%02x",
+			ipa&0xff, (ipa>>8)&0xff, (ipa>>16)&0xff, (ipa>>24)&0xff);
+		 // Target Hardware Addr.
+		len += snprintf(packet+len, total_len, "ffffffffffff");
+		 // Target IP Addr.
+		len += snprintf(packet+len, total_len, "%02x%02x%02x%02x",
+			ipa&0xff, (ipa>>8)&0xff, (ipa>>16)&0xff, (ipa>>24)&0xff);
+		len += snprintf(packet+len, total_len, "000000000000000000000000000000000000");
+	}
+
+	dhd_conf_mkeep_alive(dhd, ifidx, 0, dhd->conf->keep_alive_period, packet, TRUE);
+
+exit:
+	if (iovar_buf)
+		kfree(iovar_buf);
+	if (packet)
+		kfree(packet);
+	return;
+}
+#endif
+
+uint
+dhd_conf_get_insuspend(dhd_pub_t *dhd, uint mask)
+{
+	uint insuspend = 0;
+
+	if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+		insuspend = dhd->conf->insuspend &
+			(NO_EVENT_IN_SUSPEND | NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND |
+			ROAM_OFFLOAD_IN_SUSPEND | WOWL_IN_SUSPEND);
+	} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+		insuspend = dhd->conf->insuspend &
+			(NO_EVENT_IN_SUSPEND | NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND |
+			AP_DOWN_IN_SUSPEND | AP_FILTER_IN_SUSPEND);
+	}
+
+	return (insuspend & mask);
+}
+
+#ifdef SUSPEND_EVENT
+void
+dhd_conf_set_suspend_event(dhd_pub_t *dhd, int suspend)
+{
+	struct dhd_conf *conf = dhd->conf;
+	struct ether_addr bssid;
+	char suspend_eventmask[WL_EVENTING_MASK_LEN];
+	wl_event_msg_t msg;
+	int pm;
+#ifdef WL_CFG80211
+	struct net_device *net;
+#endif /* defined(WL_CFG80211) */
+
+	CONFIG_TRACE("Enter\n");
+	if (suspend) {
+#ifdef PROP_TXSTATUS
+#if defined(BCMSDIO) || defined(BCMDBUS)
+		if (dhd->wlfc_enabled) {
+			dhd_wlfc_deinit(dhd);
+			conf->wlfc = TRUE;
+		} else {
+			conf->wlfc = FALSE;
+		}
+#endif /* BCMSDIO || BCMDBUS */
+#endif /* PROP_TXSTATUS */
+		dhd_conf_get_iovar(dhd, 0, WLC_GET_VAR, "event_msgs",
+			conf->resume_eventmask, sizeof(conf->resume_eventmask));
+		memset(suspend_eventmask, 0, sizeof(suspend_eventmask));
+		setbit(suspend_eventmask, WLC_E_ESCAN_RESULT);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs",
+			suspend_eventmask, sizeof(suspend_eventmask), FALSE);
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			memset(&bssid, 0, ETHER_ADDR_LEN);
+			dhd_wl_ioctl_cmd(dhd, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, FALSE, 0);
+			if (memcmp(&ether_null, &bssid, ETHER_ADDR_LEN))
+				memcpy(&conf->bssid_insuspend, &bssid, ETHER_ADDR_LEN);
+			else
+				memset(&conf->bssid_insuspend, 0, ETHER_ADDR_LEN);
+		}
+	}
+	else {
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "event_msgs",
+			conf->resume_eventmask, sizeof(conf->resume_eventmask), FALSE);
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (memcmp(&ether_null, &conf->bssid_insuspend, ETHER_ADDR_LEN)) {
+				memset(&bssid, 0, ETHER_ADDR_LEN);
+				dhd_wl_ioctl_cmd(dhd, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN,
+					FALSE, 0);
+				if (memcmp(&ether_null, &bssid, ETHER_ADDR_LEN)) {
+					dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", 0, 0, FALSE);
+					dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "send_nulldata",
+						(char *)&bssid, ETHER_ADDR_LEN, FALSE);
+					OSL_SLEEP(100);
+					if (conf->pm >= 0)
+						pm = conf->pm;
+					else
+						pm = PM_FAST;
+					dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
+				} else {
+					CONFIG_TRACE("send WLC_E_DEAUTH_IND event\n");
+					bzero(&msg, sizeof(wl_event_msg_t));
+					memcpy(&msg.addr, &conf->bssid_insuspend, ETHER_ADDR_LEN);
+					msg.event_type = hton32(WLC_E_DEAUTH_IND);
+					msg.status = 0;
+					msg.reason = hton32(DOT11_RC_DEAUTH_LEAVING);
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
+					wl_ext_event_send(dhd->event_params, &msg, NULL);
+#endif
+#ifdef WL_CFG80211
+					net = dhd_idx2net(dhd, 0);
+					if (net) {
+						wl_cfg80211_event(net, &msg, NULL);
+					}
+#endif /* defined(WL_CFG80211) */
+				}
+			}
+#ifdef PROP_TXSTATUS
+#if defined(BCMSDIO) || defined(BCMDBUS)
+			if (conf->wlfc) {
+				dhd_wlfc_init(dhd);
+				dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
+			}
+#endif
+#endif /* PROP_TXSTATUS */
+		}
+	}
+
+}
+#endif
+
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+static void
+dhd_conf_wait_event_complete(struct dhd_pub *dhd, int ifidx)
+{
+	s32 timeout = -1;
+
+	timeout = wait_event_interruptible_timeout(dhd->conf->event_complete,
+		wl_ext_event_complete(dhd, ifidx), msecs_to_jiffies(10000));
+	if (timeout <= 0 || !wl_ext_event_complete(dhd, ifidx)) {
+		wl_ext_event_complete(dhd, ifidx);
+		CONFIG_ERROR("timeout\n");
+	}
+}
+#endif
+
+int
+dhd_conf_set_suspend_resume(dhd_pub_t *dhd, int suspend)
+{
+	struct dhd_conf *conf = dhd->conf;
+	uint insuspend = 0;
+	int pm;
+#ifdef BCMSDIO
+	uint32 intstatus = 0;
+	int ret = 0;
+#endif
+#ifdef WL_EXT_WOWL
+	int i;
+#endif
+
+	insuspend = dhd_conf_get_insuspend(dhd, ALL_IN_SUSPEND);
+	if (insuspend)
+		CONFIG_MSG("op_mode %d, suspend %d, suspended %d, insuspend 0x%x, suspend_mode=%d\n",
+			dhd->op_mode, suspend, conf->suspended, insuspend, conf->suspend_mode);
+
+#ifdef DHD_LOAD_CHIPALIVE
+	if ((conf->suspended == suspend || !dhd->up) && dhd_chip_alive == 0)
+#else
+	if (conf->suspended == suspend || !dhd->up)
+#endif
+	{
+		return 0;
+	}
+
+	if (suspend) {
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
+				dhd->conf->roam_off_suspend, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim",
+				dhd->conf->suspend_bcn_li_dtim, 0, FALSE);
+			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
+				dhd_conf_enable_roam_offload(dhd, 2);
+		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+			if (insuspend & AP_DOWN_IN_SUSPEND) {
+				dhd_conf_set_intiovar(dhd, WLC_DOWN, "WLC_DOWN", 1, 0, FALSE);
+			}
+		}
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				dhd_conf_wait_event_complete(dhd, 0);
+		}
+#endif
+		if (insuspend & NO_TXDATA_IN_SUSPEND) {
+			dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+		}
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				wl_ext_user_sync(dhd, 0, TRUE);
+		}
+#endif
+#ifdef SUSPEND_EVENT
+		if (insuspend & NO_EVENT_IN_SUSPEND) {
+			dhd_conf_set_suspend_event(dhd, suspend);
+		}
+#endif
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (conf->pm_in_suspend >= 0)
+				pm = conf->pm_in_suspend;
+			else if (conf->pm >= 0)
+				pm = conf->pm;
+			else
+				pm = PM_FAST;
+			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
+		}
+		dhd_conf_set_wl_cmd(dhd, conf->wl_suspend, FALSE);
+#ifdef WL_EXT_WOWL
+		if ((insuspend & WOWL_IN_SUSPEND) && dhd_master_mode) {
+			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
+			for(i=0; i<conf->pkt_filter_add.count; i++) {
+				dhd_conf_wowl_pattern(dhd, TRUE, conf->pkt_filter_add.filter[i]);
+			}
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl", conf->wowl, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl_activate", 1, 0, FALSE);
+			dhd_conf_wowl_wakeind(dhd, TRUE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 1, 0, FALSE);
+#ifdef BCMSDIO
+			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
+			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
+#endif
+		} else
+#endif
+		if (insuspend & NO_TXCTL_IN_SUSPEND) {
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 2, 0, FALSE);
+#ifdef BCMSDIO
+			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
+			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
+#endif
+		}
+		conf->suspended = TRUE;
+	} else {
+		if (insuspend & (WOWL_IN_SUSPEND | NO_TXCTL_IN_SUSPEND)) {
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 0, 0, FALSE);
+		}
+#ifdef WL_EXT_WOWL
+		if (insuspend & WOWL_IN_SUSPEND) {
+			dhd_conf_wowl_wakeind(dhd, FALSE);
+// 			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl_activate", 0, 0, FALSE); // To avoid clear wowl_wakeind wakeup reason
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl", 0, 0, FALSE);
+			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
+		}
+#endif
+		dhd_conf_set_wl_cmd(dhd, conf->wl_resume, FALSE);
+		dhd_conf_get_iovar(dhd, 0, WLC_GET_PM, "WLC_GET_PM", (char *)&pm, sizeof(pm));
+		CONFIG_TRACE("PM in suspend = %d\n", pm);
+#ifdef SUSPEND_EVENT
+		if (insuspend & NO_EVENT_IN_SUSPEND) {
+			dhd_conf_set_suspend_event(dhd, suspend);
+		}
+#endif
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				wl_ext_user_sync(dhd, 0, FALSE);
+		}
+#endif
+		if (insuspend & NO_TXDATA_IN_SUSPEND) {
+			dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+		}
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
+				dhd_conf_enable_roam_offload(dhd, 0);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim", 0, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
+				dhd->conf->roam_off, 0, FALSE);
+		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+			if (insuspend & AP_DOWN_IN_SUSPEND) {
+				dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
+			}
+		}
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (conf->pm >= 0)
+				pm = conf->pm;
+			else
+				pm = PM_FAST;
+			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
+		}
+		conf->suspended = FALSE;
+	}
+
+	return 0;
+}
+
+#ifdef PROP_TXSTATUS
+int
+dhd_conf_get_disable_proptx(dhd_pub_t *dhd)
+{
+	struct dhd_conf *conf = dhd->conf;
+	int disable_proptx = -1;
+	int fw_proptx = 0;
+
+	/* check fw proptx priority:
+	  * 1st: check fw support by wl cap
+	  * 2nd: 4334/43340/43341/43241 support proptx but not show in wl cap, so enable it by default
+	  * 	   if you would like to disable it, please set disable_proptx=1 in config.txt
+	  * 3th: disable when proptxstatus not support in wl cap
+	  */
+	if (FW_SUPPORTED(dhd, proptxstatus)) {
+		fw_proptx = 1;
+	} else if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
+			dhd->conf->chip == BCM43340_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		fw_proptx = 1;
+	} else {
+		fw_proptx = 0;
+	}
+
+	/* returned disable_proptx value:
+	  * -1: disable in STA and enable in P2P(follow original dhd settings when PROP_TXSTATUS_VSDB enabled)
+	  * 0: depend on fw support
+	  * 1: always disable proptx
+	  */
+	if (conf->disable_proptx == 0) {
+		// check fw support as well
+		if (fw_proptx)
+			disable_proptx = 0;
+		else
+			disable_proptx = 1;
+	} else if (conf->disable_proptx >= 1) {
+		disable_proptx = 1;
+	} else {
+		// check fw support as well
+		if (fw_proptx)
+			disable_proptx = -1;
+		else
+			disable_proptx = 1;
+	}
+
+	CONFIG_MSG("fw_proptx=%d, disable_proptx=%d\n", fw_proptx, disable_proptx);
+
+	return disable_proptx;
+}
+#endif
+
+uint
+pick_config_vars(char *varbuf, uint len, uint start_pos, char *pickbuf, int picklen)
+{
+	bool findNewline, changenewline=FALSE, pick=FALSE;
+	int column;
+	uint n, pick_column=0;
+
+	findNewline = FALSE;
+	column = 0;
+
+	if (start_pos >= len) {
+		CONFIG_ERROR("wrong start pos\n");
+		return 0;
+	}
+
+	for (n = start_pos; n < len; n++) {
+		if (varbuf[n] == '\r')
+			continue;
+		if ((findNewline || changenewline) && varbuf[n] != '\n')
+			continue;
+		findNewline = FALSE;
+		if (varbuf[n] == '#') {
+			findNewline = TRUE;
+			continue;
+		}
+		if (varbuf[n] == '\\') {
+			changenewline = TRUE;
+			continue;
+		}
+		if (!changenewline && varbuf[n] == '\n') {
+			if (column == 0)
+				continue;
+			column = 0;
+			continue;
+		}
+		if (changenewline && varbuf[n] == '\n') {
+			changenewline = FALSE;
+			continue;
+		}
+
+		if (column==0 && !pick) { // start to pick
+			pick = TRUE;
+			column++;
+			pick_column = 0;
+		} else {
+			if (pick && column==0) { // stop to pick
+				pick = FALSE;
+				break;
+			} else
+				column++;
+		}
+		if (pick) {
+			if (varbuf[n] == 0x9)
+				continue;
+			if (pick_column >= picklen)
+				break;
+			pickbuf[pick_column] = varbuf[n];
+			pick_column++;
+		}
+	}
+
+	return n; // return current position
+}
+
+bool
+dhd_conf_read_chiprev(dhd_pub_t *dhd, int *chip_match,
+	char *full_param, uint len_param)
+{
+	char *data = full_param+len_param, *pick_tmp, *pch;
+	uint chip = 0, rev = 0;
+
+	/* Process chip, regrev:
+	 * chip=[chipid], rev==[rev]
+	 * Ex: chip=0x4359, rev=9
+	 */
+	if (!strncmp("chip=", full_param, len_param)) {
+		chip = (int)simple_strtol(data, NULL, 0);
+		pick_tmp = data;
+		pch = bcmstrstr(pick_tmp, "rev=");
+		if (pch) {
+			rev = (int)simple_strtol(pch+strlen("rev="), NULL, 0);
+		}
+		if (chip == dhd->conf->chip && rev == dhd->conf->chiprev)
+			*chip_match = 1;
+		else
+			*chip_match = 0;
+		CONFIG_MSG("chip=0x%x, rev=%d, chip_match=%d\n", chip, rev, *chip_match);
+	}
+
+	return TRUE;
+}
+
+bool
+dhd_conf_read_log_level(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	char *data = full_param+len_param;
+
+	if (!strncmp("dhd_msg_level=", full_param, len_param)) {
+		dhd_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("dhd_msg_level = 0x%X\n", dhd_msg_level);
+	}
+	else if (!strncmp("dump_msg_level=", full_param, len_param)) {
+		dump_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("dump_msg_level = 0x%X\n", dump_msg_level);
+	}
+#ifdef BCMSDIO
+	else if (!strncmp("sd_msglevel=", full_param, len_param)) {
+		sd_msglevel = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("sd_msglevel = 0x%X\n", sd_msglevel);
+	}
+#endif
+#ifdef BCMDBUS
+	else if (!strncmp("dbus_msglevel=", full_param, len_param)) {
+		dbus_msglevel = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("dbus_msglevel = 0x%X\n", dbus_msglevel);
+	}
+#endif
+	else if (!strncmp("android_msg_level=", full_param, len_param)) {
+		android_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("android_msg_level = 0x%X\n", android_msg_level);
+	}
+	else if (!strncmp("config_msg_level=", full_param, len_param)) {
+		config_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("config_msg_level = 0x%X\n", config_msg_level);
+	}
+#ifdef WL_CFG80211
+	else if (!strncmp("wl_dbg_level=", full_param, len_param)) {
+		wl_dbg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("wl_dbg_level = 0x%X\n", wl_dbg_level);
+	}
+#endif
+#if defined(WL_WIRELESS_EXT)
+	else if (!strncmp("iw_msg_level=", full_param, len_param)) {
+		iw_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("iw_msg_level = 0x%X\n", iw_msg_level);
+	}
+#endif
+#if defined(DHD_DEBUG)
+	else if (!strncmp("dhd_console_ms=", full_param, len_param)) {
+		dhd_console_ms = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("dhd_console_ms = 0x%X\n", dhd_console_ms);
+	}
+#endif
+	else
+		return false;
+
+	return true;
+}
+
+void
+dhd_conf_read_wme_ac_value(wme_param_t *wme, char *pick, int ac_val)
+{
+	char *pick_tmp, *pch;
+
+	pick_tmp = pick;
+	pch = bcmstrstr(pick_tmp, "aifsn ");
+	if (pch) {
+		wme->aifsn[ac_val] = (int)simple_strtol(pch+strlen("aifsn "), NULL, 0);
+		CONFIG_MSG("ac_val=%d, aifsn=%d\n", ac_val, wme->aifsn[ac_val]);
+	}
+	pick_tmp = pick;
+	pch = bcmstrstr(pick_tmp, "ecwmin ");
+	if (pch) {
+		wme->ecwmin[ac_val] = (int)simple_strtol(pch+strlen("ecwmin "), NULL, 0);
+		CONFIG_MSG("ac_val=%d, ecwmin=%d\n", ac_val, wme->ecwmin[ac_val]);
+	}
+	pick_tmp = pick;
+	pch = bcmstrstr(pick_tmp, "ecwmax ");
+	if (pch) {
+		wme->ecwmax[ac_val] = (int)simple_strtol(pch+strlen("ecwmax "), NULL, 0);
+		CONFIG_MSG("ac_val=%d, ecwmax=%d\n", ac_val, wme->ecwmax[ac_val]);
+	}
+	pick_tmp = pick;
+	pch = bcmstrstr(pick_tmp, "txop ");
+	if (pch) {
+		wme->txop[ac_val] = (int)simple_strtol(pch+strlen("txop "), NULL, 0);
+		CONFIG_MSG("ac_val=%d, txop=0x%x\n", ac_val, wme->txop[ac_val]);
+	}
+
+}
+
+bool
+dhd_conf_read_wme_ac_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	// wme_ac_sta_be=aifsn 1 ecwmin 2 ecwmax 3 txop 0x5e
+	// wme_ac_sta_vo=aifsn 1 ecwmin 1 ecwmax 1 txop 0x5e
+
+	if (!strncmp("force_wme_ac=", full_param, len_param)) {
+		conf->force_wme_ac = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("force_wme_ac = %d\n", conf->force_wme_ac);
+	}
+	else if (!strncmp("wme_ac_sta_be=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_BE);
+	}
+	else if (!strncmp("wme_ac_sta_bk=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_BK);
+	}
+	else if (!strncmp("wme_ac_sta_vi=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_VI);
+	}
+	else if (!strncmp("wme_ac_sta_vo=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_sta, data, AC_VO);
+	}
+	else if (!strncmp("wme_ac_ap_be=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_BE);
+	}
+	else if (!strncmp("wme_ac_ap_bk=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_BK);
+	}
+	else if (!strncmp("wme_ac_ap_vi=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_VI);
+	}
+	else if (!strncmp("wme_ac_ap_vo=", full_param, len_param)) {
+		dhd_conf_read_wme_ac_value(&conf->wme_ap, data, AC_VO);
+	}
+	else
+		return false;
+
+	return true;
+}
+
+#ifdef BCMSDIO
+bool
+dhd_conf_read_fw_by_mac(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	int i, j;
+	char *pch, *pick_tmp;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	/* Process fw_by_mac:
+	 * fw_by_mac=[fw_mac_num] \
+	 *  [fw_name1] [mac_num1] [oui1-1] [nic_start1-1] [nic_end1-1] \
+	 *                                    [oui1-1] [nic_start1-1] [nic_end1-1]... \
+	 *                                    [oui1-n] [nic_start1-n] [nic_end1-n] \
+	 *  [fw_name2] [mac_num2] [oui2-1] [nic_start2-1] [nic_end2-1] \
+	 *                                    [oui2-1] [nic_start2-1] [nic_end2-1]... \
+	 *                                    [oui2-n] [nic_start2-n] [nic_end2-n] \
+	 * Ex: fw_by_mac=2 \
+	 *  fw_bcmdhd1.bin 2 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
+	 *  fw_bcmdhd2.bin 3 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
+	 *                           0x983B16 0x916157 0x916487
+	 */
+
+	if (!strncmp("fw_by_mac=", full_param, len_param)) {
+		dhd_conf_free_mac_list(&conf->fw_by_mac);
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->fw_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->fw_by_mac.count,
+				GFP_KERNEL))) {
+			conf->fw_by_mac.count = 0;
+			CONFIG_ERROR("kmalloc failed\n");
+		}
+		CONFIG_MSG("fw_count=%d\n", conf->fw_by_mac.count);
+		conf->fw_by_mac.m_mac_list_head = mac_list;
+		for (i=0; i<conf->fw_by_mac.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(mac_list[i].name, pch);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
+			CONFIG_MSG("name=%s, mac_count=%d\n",
+				mac_list[i].name, mac_list[i].count);
+			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count,
+					GFP_KERNEL))) {
+				mac_list[i].count = 0;
+				CONFIG_ERROR("kmalloc failed\n");
+				break;
+			}
+			mac_list[i].mac = mac_range;
+			for (j=0; j<mac_list[i].count; j++) {
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
+				CONFIG_MSG("oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
+					mac_range[j].oui, mac_range[j].nic_start, mac_range[j].nic_end);
+			}
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+
+bool
+dhd_conf_read_nv_by_mac(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	int i, j;
+	char *pch, *pick_tmp;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	/* Process nv_by_mac:
+	 * [nv_by_mac]: The same format as fw_by_mac
+	 */
+	if (!strncmp("nv_by_mac=", full_param, len_param)) {
+		dhd_conf_free_mac_list(&conf->nv_by_mac);
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->nv_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_mac.count,
+				GFP_KERNEL))) {
+			conf->nv_by_mac.count = 0;
+			CONFIG_ERROR("kmalloc failed\n");
+		}
+		CONFIG_MSG("nv_count=%d\n", conf->nv_by_mac.count);
+		conf->nv_by_mac.m_mac_list_head = mac_list;
+		for (i=0; i<conf->nv_by_mac.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(mac_list[i].name, pch);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
+			CONFIG_MSG("name=%s, mac_count=%d\n",
+				mac_list[i].name, mac_list[i].count);
+			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count,
+					GFP_KERNEL))) {
+				mac_list[i].count = 0;
+				CONFIG_ERROR("kmalloc failed\n");
+				break;
+			}
+			mac_list[i].mac = mac_range;
+			for (j=0; j<mac_list[i].count; j++) {
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
+				CONFIG_MSG("oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
+					mac_range[j].oui, mac_range[j].nic_start, mac_range[j].nic_end);
+			}
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+bool
+dhd_conf_read_nv_by_chip(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	int i;
+	char *pch, *pick_tmp;
+	wl_chip_nv_path_t *chip_nv_path;
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	/* Process nv_by_chip:
+	 * nv_by_chip=[nv_chip_num] \
+	 *  [chip1] [chiprev1] [nv_name1] [chip2] [chiprev2] [nv_name2] \
+	 * Ex: nv_by_chip=2 \
+	 *  43430 0 nvram_ap6212.txt 43430 1 nvram_ap6212a.txt \
+	 */
+	if (!strncmp("nv_by_chip=", full_param, len_param)) {
+		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->nv_by_chip.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(chip_nv_path = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_chip.count,
+				GFP_KERNEL))) {
+			conf->nv_by_chip.count = 0;
+			CONFIG_ERROR("kmalloc failed\n");
+		}
+		CONFIG_MSG("nv_by_chip_count=%d\n", conf->nv_by_chip.count);
+		conf->nv_by_chip.m_chip_nv_path_head = chip_nv_path;
+		for (i=0; i<conf->nv_by_chip.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			chip_nv_path[i].chip = (uint32)simple_strtol(pch, NULL, 0);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			chip_nv_path[i].chiprev = (uint32)simple_strtol(pch, NULL, 0);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(chip_nv_path[i].name, pch);
+			CONFIG_MSG("chip=0x%x, chiprev=%d, name=%s\n",
+				chip_nv_path[i].chip, chip_nv_path[i].chiprev, chip_nv_path[i].name);
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+
+bool
+dhd_conf_read_roam_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	if (!strncmp("roam_off=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->roam_off = 0;
+		else
+			conf->roam_off = 1;
+		CONFIG_MSG("roam_off = %d\n", conf->roam_off);
+	}
+	else if (!strncmp("roam_off_suspend=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->roam_off_suspend = 0;
+		else
+			conf->roam_off_suspend = 1;
+		CONFIG_MSG("roam_off_suspend = %d\n", conf->roam_off_suspend);
+	}
+	else if (!strncmp("roam_trigger=", full_param, len_param)) {
+		conf->roam_trigger[0] = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("roam_trigger = %d\n", conf->roam_trigger[0]);
+	}
+	else if (!strncmp("roam_scan_period=", full_param, len_param)) {
+		conf->roam_scan_period[0] = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("roam_scan_period = %d\n", conf->roam_scan_period[0]);
+	}
+	else if (!strncmp("roam_delta=", full_param, len_param)) {
+		conf->roam_delta[0] = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("roam_delta = %d\n", conf->roam_delta[0]);
+	}
+	else if (!strncmp("fullroamperiod=", full_param, len_param)) {
+		conf->fullroamperiod = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("fullroamperiod = %d\n", conf->fullroamperiod);
+	} else
+		return false;
+
+	return true;
+}
+
+bool
+dhd_conf_read_country(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	country_list_t *country_next = NULL, *country;
+	int i, count = 0;
+	char *pch, *pick_tmp, *pick_tmp2;
+	char *data = full_param+len_param;
+	uint len_data = strlen(data);
+
+	/* Process country_list:
+	 * country_list=[country1]:[ccode1]/[regrev1],
+	 * [country2]:[ccode2]/[regrev2] \
+	 * Ex: country_list=US:US/0, TW:TW/1
+	 */
+	if (!strncmp("ccode=", full_param, len_param)) {
+		len_data = min((uint)WLC_CNTRY_BUF_SZ, len_data);
+		memset(&conf->cspec, 0, sizeof(wl_country_t));
+		memcpy(conf->cspec.country_abbrev, data, len_data);
+		memcpy(conf->cspec.ccode, data, len_data);
+		CONFIG_MSG("ccode = %s\n", conf->cspec.ccode);
+	}
+	else if (!strncmp("regrev=", full_param, len_param)) {
+		conf->cspec.rev = (int32)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("regrev = %d\n", conf->cspec.rev);
+	}
+	else if (!strncmp("country_list=", full_param, len_param)) {
+		dhd_conf_free_country_list(conf);
+		pick_tmp = data;
+		for (i=0; i<CONFIG_COUNTRY_LIST_SIZE; i++) {
+			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
+			if (!pick_tmp2)
+				break;
+			pch = bcmstrtok(&pick_tmp2, ":", 0);
+			if (!pch)
+				break;
+			country = NULL;
+			if (!(country = kmalloc(sizeof(country_list_t), GFP_KERNEL))) {
+				CONFIG_ERROR("kmalloc failed\n");
+				break;
+			}
+			memset(country, 0, sizeof(country_list_t));
+
+			memcpy(country->cspec.country_abbrev, pch, 2);
+			pch = bcmstrtok(&pick_tmp2, "/", 0);
+			if (!pch) {
+				kfree(country);
+				break;
+			}
+			memcpy(country->cspec.ccode, pch, 2);
+			pch = bcmstrtok(&pick_tmp2, "/", 0);
+			if (!pch) {
+				kfree(country);
+				break;
+			}
+			country->cspec.rev = (int32)simple_strtol(pch, NULL, 10);
+			count++;
+			if (!conf->country_head) {
+				conf->country_head = country;
+				country_next = country;
+			} else {
+				country_next->next = country;
+				country_next = country;
+			}
+			CONFIG_TRACE("abbrev=%s, ccode=%s, regrev=%d\n",
+				country->cspec.country_abbrev, country->cspec.ccode, country->cspec.rev);
+		}
+		CONFIG_MSG("%d country in list\n", count);
+	}
+	else
+		return false;
+
+	return true;
+}
+
+bool
+dhd_conf_read_mchan_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	int i;
+	char *pch, *pick_tmp, *pick_tmp2;
+	struct dhd_conf *conf = dhd->conf;
+	mchan_params_t *mchan_next = NULL, *mchan;
+	char *data = full_param+len_param;
+
+	/* Process mchan_bw:
+	 * mchan_bw=[val]/[any/go/gc]/[any/source/sink]
+	 * Ex: mchan_bw=80/go/source, 30/gc/sink
+	 */
+	if (!strncmp("mchan_bw=", full_param, len_param)) {
+		dhd_conf_free_mchan_list(conf);
+		pick_tmp = data;
+		for (i=0; i<MCHAN_MAX_NUM; i++) {
+			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
+			if (!pick_tmp2)
+				break;
+			pch = bcmstrtok(&pick_tmp2, "/", 0);
+			if (!pch)
+				break;
+
+			mchan = NULL;
+			if (!(mchan = kmalloc(sizeof(mchan_params_t), GFP_KERNEL))) {
+				CONFIG_ERROR("kmalloc failed\n");
+				break;
+			}
+			memset(mchan, 0, sizeof(mchan_params_t));
+
+			mchan->bw = (int)simple_strtol(pch, NULL, 0);
+			if (mchan->bw < 0 || mchan->bw > 100) {
+				CONFIG_ERROR("wrong bw %d\n", mchan->bw);
+				kfree(mchan);
+				break;
+			}
+
+			pch = bcmstrtok(&pick_tmp2, "/", 0);
+			if (!pch) {
+				kfree(mchan);
+				break;
+			} else {
+				if (bcmstrstr(pch, "any")) {
+					mchan->p2p_mode = -1;
+				} else if (bcmstrstr(pch, "go")) {
+					mchan->p2p_mode = WL_P2P_IF_GO;
+				} else if (bcmstrstr(pch, "gc")) {
+					mchan->p2p_mode = WL_P2P_IF_CLIENT;
+				}
+			}
+			pch = bcmstrtok(&pick_tmp2, "/", 0);
+			if (!pch) {
+				kfree(mchan);
+				break;
+			} else {
+				if (bcmstrstr(pch, "any")) {
+					mchan->miracast_mode = -1;
+				} else if (bcmstrstr(pch, "source")) {
+					mchan->miracast_mode = MIRACAST_SOURCE;
+				} else if (bcmstrstr(pch, "sink")) {
+					mchan->miracast_mode = MIRACAST_SINK;
+				}
+			}
+			if (!conf->mchan) {
+				conf->mchan = mchan;
+				mchan_next = mchan;
+			} else {
+				mchan_next->next = mchan;
+				mchan_next = mchan;
+			}
+			CONFIG_TRACE("mchan_bw=%d/%d/%d\n", mchan->bw,mchan->p2p_mode,
+				mchan->miracast_mode);
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+
+#ifdef PKT_FILTER_SUPPORT
+bool
+dhd_conf_read_pkt_filter(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+	char *pch, *pick_tmp;
+	int i;
+
+	/* Process pkt filter:
+	 * 1) pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
+	 * 2) pkt_filter_delete=100, 102, 103, 104, 105
+	 * 3) magic_pkt_filter_add=141 0 1 12
+	 */
+	if (!strncmp("dhd_master_mode=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			dhd_master_mode = FALSE;
+		else
+			dhd_master_mode = TRUE;
+		CONFIG_MSG("dhd_master_mode = %d\n", dhd_master_mode);
+	}
+	else if (!strncmp("pkt_filter_add=", full_param, len_param)) {
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, ",.-", 0);
+		i=0;
+		while (pch != NULL && i<DHD_CONF_FILTER_MAX) {
+			strcpy(&conf->pkt_filter_add.filter[i][0], pch);
+			CONFIG_MSG("pkt_filter_add[%d][] = %s\n",
+				i, &conf->pkt_filter_add.filter[i][0]);
+			pch = bcmstrtok(&pick_tmp, ",.-", 0);
+			i++;
+		}
+		conf->pkt_filter_add.count = i;
+	}
+	else if (!strncmp("pkt_filter_delete=", full_param, len_param) ||
+			!strncmp("pkt_filter_del=", full_param, len_param)) {
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+		i=0;
+		while (pch != NULL && i<DHD_CONF_FILTER_MAX) {
+			conf->pkt_filter_del.id[i] = (uint32)simple_strtol(pch, NULL, 10);
+			pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+			i++;
+		}
+		conf->pkt_filter_del.count = i;
+		CONFIG_MSG("pkt_filter_del id = ");
+		for (i=0; i<conf->pkt_filter_del.count; i++)
+			printf("%d ", conf->pkt_filter_del.id[i]);
+		printf("\n");
+	}
+	else if (!strncmp("magic_pkt_filter_add=", full_param, len_param)) {
+		if (conf->magic_pkt_filter_add) {
+			kfree(conf->magic_pkt_filter_add);
+			conf->magic_pkt_filter_add = NULL;
+		}
+		if (!(conf->magic_pkt_filter_add = kmalloc(MAGIC_PKT_FILTER_LEN, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->magic_pkt_filter_add, 0, MAGIC_PKT_FILTER_LEN);
+			strcpy(conf->magic_pkt_filter_add, data);
+			CONFIG_MSG("magic_pkt_filter_add = %s\n", conf->magic_pkt_filter_add);
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+#ifdef ISAM_PREINIT
+#if !defined(WL_EXT_IAPSTA)
+#error "WL_EXT_IAPSTA should be defined to enable ISAM_PREINIT"
+#endif /* !WL_EXT_IAPSTA */
+/*
+ * isam_init=mode [sta|ap|apsta|dualap] vifname [wlan1]
+ * isam_config=ifname [wlan0|wlan1] ssid [xxx] chan [x]
+		 hidden [y|n] maxassoc [x]
+		 amode [open|shared|wpapsk|wpa2psk|wpawpa2psk]
+		 emode [none|wep|tkip|aes|tkipaes]
+		 key [xxxxx]
+ * isam_enable=ifname [wlan0|wlan1]
+*/
+bool
+dhd_conf_read_isam(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	if (!strncmp("isam_init=", full_param, len_param)) {
+		sprintf(conf->isam_init, "isam_init %s", data);
+		CONFIG_MSG("isam_init=%s\n", conf->isam_init);
+	}
+	else if (!strncmp("isam_config=", full_param, len_param)) {
+		sprintf(conf->isam_config, "isam_config %s", data);
+		CONFIG_MSG("isam_config=%s\n", conf->isam_config);
+	}
+	else if (!strncmp("isam_enable=", full_param, len_param)) {
+		sprintf(conf->isam_enable, "isam_enable %s", data);
+		CONFIG_MSG("isam_enable=%s\n", conf->isam_enable);
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+#ifdef IDHCP
+bool
+dhd_conf_read_dhcp_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+	struct ipv4_addr ipa_set;
+
+	if (!strncmp("dhcpc_enable=", full_param, len_param)) {
+		conf->dhcpc_enable = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhcpc_enable = %d\n", conf->dhcpc_enable);
+	}
+	else if (!strncmp("dhcpd_enable=", full_param, len_param)) {
+		conf->dhcpd_enable = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhcpd_enable = %d\n", conf->dhcpd_enable);
+	}
+	else if (!strncmp("dhcpd_ip_addr=", full_param, len_param)) {
+		if (!bcm_atoipv4(data, &ipa_set)) {
+			CONFIG_ERROR("dhcpd_ip_addr adress setting failed.n");
+			return false;
+		}
+		memcpy(&conf->dhcpd_ip_addr, &ipa_set, sizeof(struct ipv4_addr));
+		CONFIG_MSG("dhcpd_ip_addr = %s\n", data);
+	}
+	else if (!strncmp("dhcpd_ip_mask=", full_param, len_param)) {
+		if (!bcm_atoipv4(data, &ipa_set)) {
+			CONFIG_ERROR("dhcpd_ip_mask adress setting failed\n");
+			return false;
+		}
+		memcpy(&conf->dhcpd_ip_mask, &ipa_set, sizeof(struct ipv4_addr));
+		CONFIG_MSG("dhcpd_ip_mask = %s\n", data);
+	}
+	else if (!strncmp("dhcpd_ip_start=", full_param, len_param)) {
+		if (!bcm_atoipv4(data, &ipa_set)) {
+			CONFIG_ERROR("dhcpd_ip_start adress setting failed\n");
+			return false;
+		}
+		memcpy(&conf->dhcpd_ip_start, &ipa_set, sizeof(struct ipv4_addr));
+		CONFIG_MSG("dhcpd_ip_start = %s\n", data);
+	}
+	else if (!strncmp("dhcpd_ip_end=", full_param, len_param)) {
+		if (!bcm_atoipv4(data, &ipa_set)) {
+			CONFIG_ERROR("dhcpd_ip_end adress setting failed\n");
+			return false;
+		}
+		memcpy(&conf->dhcpd_ip_end, &ipa_set, sizeof(struct ipv4_addr));
+		CONFIG_MSG("dhcpd_ip_end = %s\n", data);
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+#ifdef BCMSDIO
+bool
+dhd_conf_read_sdio_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	if (!strncmp("dhd_doflow=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			dhd_doflow = FALSE;
+		else
+			dhd_doflow = TRUE;
+		CONFIG_MSG("dhd_doflow = %d\n", dhd_doflow);
+	}
+	else if (!strncmp("dhd_slpauto=", full_param, len_param) ||
+			!strncmp("kso_enable=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			dhd_slpauto = FALSE;
+		else
+			dhd_slpauto = TRUE;
+		CONFIG_MSG("dhd_slpauto = %d\n", dhd_slpauto);
+	}
+	else if (!strncmp("use_rxchain=", full_param, len_param)) {
+		conf->use_rxchain = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("use_rxchain = %d\n", conf->use_rxchain);
+	}
+	else if (!strncmp("dhd_txminmax=", full_param, len_param)) {
+		conf->dhd_txminmax = (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhd_txminmax = %d\n", conf->dhd_txminmax);
+	}
+	else if (!strncmp("txinrx_thres=", full_param, len_param)) {
+		conf->txinrx_thres = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("txinrx_thres = %d\n", conf->txinrx_thres);
+	}
+#if defined(HW_OOB)
+	else if (!strncmp("oob_enabled_later=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->oob_enabled_later = FALSE;
+		else
+			conf->oob_enabled_later = TRUE;
+		CONFIG_MSG("oob_enabled_later = %d\n", conf->oob_enabled_later);
+	}
+#endif
+	else if (!strncmp("dpc_cpucore=", full_param, len_param)) {
+		conf->dpc_cpucore = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dpc_cpucore = %d\n", conf->dpc_cpucore);
+	}
+	else if (!strncmp("rxf_cpucore=", full_param, len_param)) {
+		conf->rxf_cpucore = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("rxf_cpucore = %d\n", conf->rxf_cpucore);
+	}
+#if defined(BCMSDIOH_TXGLOM)
+	else if (!strncmp("txglomsize=", full_param, len_param)) {
+		conf->txglomsize = (uint)simple_strtol(data, NULL, 10);
+		if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
+			conf->txglomsize = SDPCM_MAXGLOM_SIZE;
+		CONFIG_MSG("txglomsize = %d\n", conf->txglomsize);
+	}
+	else if (!strncmp("txglom_ext=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->txglom_ext = FALSE;
+		else
+			conf->txglom_ext = TRUE;
+		CONFIG_MSG("txglom_ext = %d\n", conf->txglom_ext);
+		if (conf->txglom_ext) {
+			if ((conf->chip == BCM43362_CHIP_ID) || (conf->chip == BCM4330_CHIP_ID))
+				conf->txglom_bucket_size = 1680;
+			else if (conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+					conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID)
+				conf->txglom_bucket_size = 1684;
+		}
+		CONFIG_MSG("txglom_bucket_size = %d\n", conf->txglom_bucket_size);
+	}
+	else if (!strncmp("bus:rxglom=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->bus_rxglom = FALSE;
+		else
+			conf->bus_rxglom = TRUE;
+		CONFIG_MSG("bus:rxglom = %d\n", conf->bus_rxglom);
+	}
+	else if (!strncmp("deferred_tx_len=", full_param, len_param)) {
+		conf->deferred_tx_len = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("deferred_tx_len = %d\n", conf->deferred_tx_len);
+	}
+	else if (!strncmp("txctl_tmo_fix=", full_param, len_param)) {
+		conf->txctl_tmo_fix = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("txctl_tmo_fix = %d\n", conf->txctl_tmo_fix);
+	}
+	else if (!strncmp("tx_max_offset=", full_param, len_param)) {
+		conf->tx_max_offset = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("tx_max_offset = %d\n", conf->tx_max_offset);
+	}
+	else if (!strncmp("txglom_mode=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->txglom_mode = FALSE;
+		else
+			conf->txglom_mode = TRUE;
+		CONFIG_MSG("txglom_mode = %d\n", conf->txglom_mode);
+	}
+#if defined(SDIO_ISR_THREAD)
+	else if (!strncmp("intr_extn=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->intr_extn = FALSE;
+		else
+			conf->intr_extn = TRUE;
+		CONFIG_MSG("intr_extn = %d\n", conf->intr_extn);
+	}
+#endif
+#ifdef BCMSDIO_RXLIM_POST
+	else if (!strncmp("rxlim_en=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->rxlim_en = FALSE;
+		else
+			conf->rxlim_en = TRUE;
+		CONFIG_MSG("rxlim_en = %d\n", conf->rxlim_en);
+	}
+#endif
+#ifdef BCMSDIO_TXSEQ_SYNC
+	else if (!strncmp("txseq_sync=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->txseq_sync = FALSE;
+		else
+			conf->txseq_sync = TRUE;
+		CONFIG_MSG("txseq_sync = %d\n", conf->txseq_sync);
+	}
+#endif
+#endif
+#ifdef MINIME
+	else if (!strncmp("ramsize=", full_param, len_param)) {
+		conf->ramsize = (uint32)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("ramsize = %d\n", conf->ramsize);
+	}
+#endif
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+#ifdef BCMPCIE
+bool
+dhd_conf_read_pcie_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	if (!strncmp("bus:deepsleep_disable=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->bus_deepsleep_disable = 0;
+		else
+			conf->bus_deepsleep_disable = 1;
+		CONFIG_MSG("bus:deepsleep_disable = %d\n", conf->bus_deepsleep_disable);
+	}
+	else
+		return false;
+
+	return true;
+}
+#endif
+
+bool
+dhd_conf_read_pm_params(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+
+	if (!strncmp("deepsleep=", full_param, len_param)) {
+		if (!strncmp(data, "1", 1))
+			conf->deepsleep = TRUE;
+		else
+			conf->deepsleep = FALSE;
+		CONFIG_MSG("deepsleep = %d\n", conf->deepsleep);
+	}
+	else if (!strncmp("PM=", full_param, len_param)) {
+		conf->pm = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("PM = %d\n", conf->pm);
+	}
+	else if (!strncmp("pm_in_suspend=", full_param, len_param)) {
+		conf->pm_in_suspend = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("pm_in_suspend = %d\n", conf->pm_in_suspend);
+	}
+	else if (!strncmp("suspend_mode=", full_param, len_param)) {
+		conf->suspend_mode = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("suspend_mode = %d\n", conf->suspend_mode);
+		if (conf->suspend_mode == PM_NOTIFIER)
+			conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
+	}
+	else if (!strncmp("suspend_bcn_li_dtim=", full_param, len_param)) {
+		conf->suspend_bcn_li_dtim = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("suspend_bcn_li_dtim = %d\n", conf->suspend_bcn_li_dtim);
+	}
+	else if (!strncmp("xmit_in_suspend=", full_param, len_param)) {
+		if (!strncmp(data, "1", 1))
+			conf->insuspend &= ~NO_TXDATA_IN_SUSPEND;
+		else
+			conf->insuspend |= NO_TXDATA_IN_SUSPEND;
+		CONFIG_MSG("insuspend = 0x%x\n", conf->insuspend);
+	}
+	else if (!strncmp("insuspend=", full_param, len_param)) {
+		conf->insuspend = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("insuspend = 0x%x\n", conf->insuspend);
+	}
+#ifdef WL_EXT_WOWL
+	else if (!strncmp("wowl=", full_param, len_param)) {
+		conf->wowl = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("wowl = 0x%x\n", conf->wowl);
+	}
+#endif
+	else
+		return false;
+
+	return true;
+}
+
+#ifdef GET_CUSTOM_MAC_FROM_CONFIG
+int
+bcm_str2hex(const char *p, char *ea, int size)
+{
+	int i = 0;
+	char *ep;
+
+	for (;;) {
+		ea[i++] = (char) bcm_strtoul(p, &ep, 16);
+		p = ep;
+		if (!*p++ || i == size)
+			break;
+	}
+
+	return (i == size);
+}
+#endif
+
+bool
+dhd_conf_read_others(dhd_pub_t *dhd, char *full_param, uint len_param)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char *data = full_param+len_param;
+	char *pch, *pick_tmp;
+	int i;
+#ifdef GET_CUSTOM_MAC_FROM_CONFIG
+	struct ether_addr ea_addr;
+	char macpad[56];
+#endif
+
+	if (!strncmp("dhd_poll=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->dhd_poll = 0;
+		else
+			conf->dhd_poll = 1;
+		CONFIG_MSG("dhd_poll = %d\n", conf->dhd_poll);
+	}
+	else if (!strncmp("dhd_watchdog_ms=", full_param, len_param)) {
+		dhd_watchdog_ms = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhd_watchdog_ms = %d\n", dhd_watchdog_ms);
+	}
+	else if (!strncmp("band=", full_param, len_param)) {
+		/* Process band:
+		 * band=a for 5GHz only and band=b for 2.4GHz only
+		 */
+		if (!strcmp(data, "b"))
+			conf->band = WLC_BAND_2G;
+		else if (!strcmp(data, "a"))
+			conf->band = WLC_BAND_5G;
+		else
+			conf->band = WLC_BAND_AUTO;
+		CONFIG_MSG("band = %d\n", conf->band);
+	}
+	else if (!strncmp("bw_cap_2g=", full_param, len_param)) {
+		conf->bw_cap[0] = (uint)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("bw_cap_2g = %d\n", conf->bw_cap[0]);
+	}
+	else if (!strncmp("bw_cap_5g=", full_param, len_param)) {
+		conf->bw_cap[1] = (uint)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("bw_cap_5g = %d\n", conf->bw_cap[1]);
+	}
+	else if (!strncmp("bw_cap=", full_param, len_param)) {
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+		if (pch != NULL) {
+			conf->bw_cap[0] = (uint32)simple_strtol(pch, NULL, 0);
+			CONFIG_MSG("bw_cap 2g = %d\n", conf->bw_cap[0]);
+		}
+		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+		if (pch != NULL) {
+			conf->bw_cap[1] = (uint32)simple_strtol(pch, NULL, 0);
+			CONFIG_MSG("bw_cap 5g = %d\n", conf->bw_cap[1]);
+		}
+	}
+	else if (!strncmp("channels=", full_param, len_param)) {
+		pick_tmp = data;
+		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+		i=0;
+		while (pch != NULL && i<WL_NUMCHANNELS) {
+			conf->channels.channel[i] = (uint32)simple_strtol(pch, NULL, 10);
+			pch = bcmstrtok(&pick_tmp, " ,.-", 0);
+			i++;
+		}
+		conf->channels.count = i;
+		CONFIG_MSG("channels = ");
+		for (i=0; i<conf->channels.count; i++)
+			printf("%d ", conf->channels.channel[i]);
+		printf("\n");
+	}
+	else if (!strncmp("keep_alive_period=", full_param, len_param)) {
+		conf->keep_alive_period = (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("keep_alive_period = %d\n", conf->keep_alive_period);
+	}
+#ifdef ARP_OFFLOAD_SUPPORT
+	else if (!strncmp("garp=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->garp = FALSE;
+		else
+			conf->garp = TRUE;
+		CONFIG_MSG("garp = %d\n", conf->garp);
+	}
+#endif
+	else if (!strncmp("srl=", full_param, len_param)) {
+		conf->srl = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("srl = %d\n", conf->srl);
+	}
+	else if (!strncmp("lrl=", full_param, len_param)) {
+		conf->lrl = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("lrl = %d\n", conf->lrl);
+	}
+	else if (!strncmp("bcn_timeout=", full_param, len_param)) {
+		conf->bcn_timeout= (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("bcn_timeout = %d\n", conf->bcn_timeout);
+	}
+	else if (!strncmp("frameburst=", full_param, len_param)) {
+		conf->frameburst = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("frameburst = %d\n", conf->frameburst);
+	}
+	else if (!strncmp("disable_proptx=", full_param, len_param)) {
+		conf->disable_proptx = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("disable_proptx = %d\n", conf->disable_proptx);
+	}
+#ifdef DHDTCPACK_SUPPRESS
+	else if (!strncmp("tcpack_sup_mode=", full_param, len_param)) {
+		conf->tcpack_sup_mode = (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("tcpack_sup_mode = %d\n", conf->tcpack_sup_mode);
+	}
+#endif
+	else if (!strncmp("pktprio8021x=", full_param, len_param)) {
+		conf->pktprio8021x = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("pktprio8021x = %d\n", conf->pktprio8021x);
+	}
+#if defined(BCMSDIO) || defined(BCMPCIE)
+	else if (!strncmp("dhd_txbound=", full_param, len_param)) {
+		dhd_txbound = (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhd_txbound = %d\n", dhd_txbound);
+	}
+	else if (!strncmp("dhd_rxbound=", full_param, len_param)) {
+		dhd_rxbound = (uint)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("dhd_rxbound = %d\n", dhd_rxbound);
+	}
+#endif
+	else if (!strncmp("orphan_move=", full_param, len_param)) {
+		conf->orphan_move = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("orphan_move = %d\n", conf->orphan_move);
+	}
+	else if (!strncmp("tsq=", full_param, len_param)) {
+		conf->tsq = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("tsq = %d\n", conf->tsq);
+	}
+	else if (!strncmp("ctrl_resched=", full_param, len_param)) {
+		conf->ctrl_resched = (int)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("ctrl_resched = %d\n", conf->ctrl_resched);
+	}
+	else if (!strncmp("in4way=", full_param, len_param)) {
+		conf->in4way = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("in4way = 0x%x\n", conf->in4way);
+	}
+	else if (!strncmp("wl_preinit=", full_param, len_param)) {
+		if (conf->wl_preinit) {
+			kfree(conf->wl_preinit);
+			conf->wl_preinit = NULL;
+		}
+		if (!(conf->wl_preinit = kmalloc(len_param+1, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->wl_preinit, 0, len_param+1);
+			strcpy(conf->wl_preinit, data);
+			CONFIG_MSG("wl_preinit = %s\n", conf->wl_preinit);
+		}
+	}
+	else if (!strncmp("wl_suspend=", full_param, len_param)) {
+		if (conf->wl_suspend) {
+			kfree(conf->wl_suspend);
+			conf->wl_suspend = NULL;
+		}
+		if (!(conf->wl_suspend = kmalloc(len_param+1, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->wl_suspend, 0, len_param+1);
+			strcpy(conf->wl_suspend, data);
+			CONFIG_MSG("wl_suspend = %s\n", conf->wl_suspend);
+		}
+	}
+	else if (!strncmp("wl_resume=", full_param, len_param)) {
+		if (conf->wl_resume) {
+			kfree(conf->wl_resume);
+			conf->wl_resume = NULL;
+		}
+		if (!(conf->wl_resume = kmalloc(len_param+1, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->wl_resume, 0, len_param+1);
+			strcpy(conf->wl_resume, data);
+			CONFIG_MSG("wl_resume = %s\n", conf->wl_resume);
+		}
+	}
+#ifdef GET_CUSTOM_MAC_FROM_CONFIG
+	else if (!strncmp("mac=", full_param, len_param)) {
+		if (!bcm_ether_atoe(data, &ea_addr)) {
+			CONFIG_ERROR("mac adress read error");
+			return false;
+		}
+		memcpy(&conf->hw_ether, &ea_addr, ETHER_ADDR_LEN);
+		CONFIG_MSG("mac = %s\n", data);
+	}
+	else if (!strncmp("macpad=", full_param, len_param)) {
+		if (!bcm_str2hex(data, macpad, sizeof(macpad))) {
+			CONFIG_ERROR("macpad adress read error");
+			return false;
+		}
+		memcpy(&conf->hw_ether[ETHER_ADDR_LEN], macpad, sizeof(macpad));
+		if (config_msg_level & CONFIG_TRACE_LEVEL) {
+			printf("macpad =\n");
+			for (i=0; i<sizeof(macpad); i++) {
+				printf("0x%02x, ", conf->hw_ether[ETHER_ADDR_LEN+i]);
+				if ((i+1)%8 == 0)
+					printf("\n");
+			}
+		}
+	}
+#endif
+#ifdef PROPTX_MAXCOUNT
+	else if (!strncmp("proptx_maxcnt_2g=", full_param, len_param)) {
+		conf->proptx_maxcnt_2g = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("proptx_maxcnt_2g = 0x%x\n", conf->proptx_maxcnt_2g);
+	}
+	else if (!strncmp("proptx_maxcnt_5g=", full_param, len_param)) {
+		conf->proptx_maxcnt_5g = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("proptx_maxcnt_5g = 0x%x\n", conf->proptx_maxcnt_5g);
+	}
+#endif
+#ifdef HOST_TPUT_TEST
+	else if (!strncmp("data_drop_mode=", full_param, len_param)) {
+		conf->data_drop_mode = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("data_drop_mode = 0x%x\n", conf->data_drop_mode);
+	}
+#endif
+	else
+		return false;
+
+	return true;
+}
+
+int
+dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path)
+{
+	int bcmerror = -1, chip_match = -1;
+	uint len = 0, start_pos=0, end_pos=0;
+	void *image = NULL;
+	char *memblock = NULL;
+	char *bufp, *pick = NULL, *pch;
+	bool conf_file_exists;
+	uint len_param;
+
+	conf_file_exists = ((conf_path != NULL) && (conf_path[0] != '\0'));
+	if (!conf_file_exists) {
+		CONFIG_MSG("config path %s\n", conf_path);
+		return (0);
+	}
+
+	if (conf_file_exists) {
+		image = dhd_os_open_image(conf_path);
+		if (image == NULL) {
+			CONFIG_MSG("Ignore config file %s\n", conf_path);
+			goto err;
+		}
+	}
+
+	memblock = MALLOC(dhd->osh, MAXSZ_CONFIG);
+	if (memblock == NULL) {
+		CONFIG_ERROR("Failed to allocate memory %d bytes\n", MAXSZ_CONFIG);
+		goto err;
+	}
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR("Failed to allocate memory %d bytes\n", MAXSZ_BUF);
+		goto err;
+	}
+
+	/* Read variables */
+	if (conf_file_exists) {
+		len = dhd_os_get_image_block(memblock, MAXSZ_CONFIG, image);
+	}
+	if (len > 0 && len < MAXSZ_CONFIG) {
+		bufp = (char *)memblock;
+		bufp[len] = 0;
+
+		while (start_pos < len) {
+			memset(pick, 0, MAXSZ_BUF);
+			end_pos = pick_config_vars(bufp, len, start_pos, pick, MAXSZ_BUF);
+			if (end_pos - start_pos >= MAXSZ_BUF)
+				CONFIG_ERROR("out of buf to read MAXSIZ_BUF=%d\n", MAXSZ_BUF);
+			start_pos = end_pos;
+			pch = strchr(pick, '=');
+			if (pch != NULL) {
+				len_param = pch-pick+1;
+				if (len_param == strlen(pick)) {
+					CONFIG_ERROR("not a right parameter %s\n", pick);
+					continue;
+				}
+			} else {
+				CONFIG_ERROR("not a right parameter %s\n", pick);
+				continue;
+			}
+
+			dhd_conf_read_chiprev(dhd, &chip_match, pick, len_param);
+			if (!chip_match)
+				continue;
+
+			if (dhd_conf_read_log_level(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_roam_params(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_wme_ac_params(dhd, pick, len_param))
+				continue;
+#ifdef BCMSDIO
+			else if (dhd_conf_read_fw_by_mac(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_nv_by_mac(dhd, pick, len_param))
+				continue;
+#endif
+			else if (dhd_conf_read_nv_by_chip(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_country(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_mchan_params(dhd, pick, len_param))
+				continue;
+#ifdef PKT_FILTER_SUPPORT
+			else if (dhd_conf_read_pkt_filter(dhd, pick, len_param))
+				continue;
+#endif /* PKT_FILTER_SUPPORT */
+#ifdef ISAM_PREINIT
+			else if (dhd_conf_read_isam(dhd, pick, len_param))
+				continue;
+#endif /* ISAM_PREINIT */
+#ifdef IDHCP
+			else if (dhd_conf_read_dhcp_params(dhd, pick, len_param))
+				continue;
+#endif /* IDHCP */
+#ifdef BCMSDIO
+			else if (dhd_conf_read_sdio_params(dhd, pick, len_param))
+				continue;
+#endif /* BCMSDIO */
+#ifdef BCMPCIE
+			else if (dhd_conf_read_pcie_params(dhd, pick, len_param))
+				continue;
+#endif /* BCMPCIE */
+			else if (dhd_conf_read_pm_params(dhd, pick, len_param))
+				continue;
+			else if (dhd_conf_read_others(dhd, pick, len_param))
+				continue;
+			else
+				continue;
+		}
+
+		bcmerror = 0;
+	} else {
+		CONFIG_ERROR("error reading config file: %d\n", len);
+		bcmerror = BCME_SDIO_ERROR;
+	}
+
+err:
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+
+	if (memblock)
+		MFREE(dhd->osh, memblock, MAXSZ_CONFIG);
+
+	if (image)
+		dhd_os_close_image(image);
+
+	return bcmerror;
+}
+
+int
+dhd_conf_set_chiprev(dhd_pub_t *dhd, uint chip, uint chiprev)
+{
+	CONFIG_MSG("chip=0x%x, chiprev=%d\n", chip, chiprev);
+	dhd->conf->chip = chip;
+	dhd->conf->chiprev = chiprev;
+	return 0;
+}
+
+uint
+dhd_conf_get_chip(void *context)
+{
+	dhd_pub_t *dhd = context;
+
+	if (dhd && dhd->conf)
+		return dhd->conf->chip;
+	return 0;
+}
+
+uint
+dhd_conf_get_chiprev(void *context)
+{
+	dhd_pub_t *dhd = context;
+
+	if (dhd && dhd->conf)
+		return dhd->conf->chiprev;
+	return 0;
+}
+
+#ifdef BCMSDIO
+void
+dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable)
+{
+	struct dhd_conf *conf = dhd->conf;
+
+	if (enable) {
+#if defined(BCMSDIOH_TXGLOM_EXT)
+		if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
+				conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+				conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+			conf->txglom_mode = SDPCM_TXGLOM_CPY;
+		}
+#endif
+		// other parameters set in preinit or config.txt
+		if (conf->txglom_ext)
+			CONFIG_MSG("txglom_ext=%d, txglom_bucket_size=%d\n",
+				conf->txglom_ext, conf->txglom_bucket_size);
+		CONFIG_MSG("txglom_mode=%s\n",
+	 		conf->txglom_mode==SDPCM_TXGLOM_MDESC?"multi-desc":"copy");
+		CONFIG_MSG("txglomsize=%d, deferred_tx_len=%d\n",
+			conf->txglomsize, conf->deferred_tx_len);
+		CONFIG_MSG("txinrx_thres=%d, dhd_txminmax=%d\n",
+			conf->txinrx_thres, conf->dhd_txminmax);
+		CONFIG_MSG("tx_max_offset=%d, txctl_tmo_fix=%d\n",
+			conf->tx_max_offset, conf->txctl_tmo_fix);
+	} else {
+		// clear txglom parameters
+		conf->txglom_ext = FALSE;
+		conf->txglom_bucket_size = 0;
+		conf->txglomsize = 0;
+		conf->deferred_tx_len = 0;
+	}
+
+}
+#endif
+
+void
+dhd_conf_postinit_ioctls(dhd_pub_t *dhd)
+{
+	struct dhd_conf *conf = dhd->conf;
+	char wl_preinit[] = "assoc_retry_max=20";
+#ifdef NO_POWER_SAVE
+	char wl_no_power_save[] = "mpc=0, 86=0";
+	dhd_conf_set_wl_cmd(dhd, wl_no_power_save, FALSE);
+#endif
+
+	dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
+	dhd_conf_map_country_list(dhd, &conf->cspec);
+	dhd_conf_set_country(dhd, &conf->cspec);
+	dhd_conf_fix_country(dhd);
+	dhd_conf_get_country(dhd, &dhd->dhd_cspec);
+
+	dhd_conf_set_intiovar(dhd, WLC_SET_BAND, "WLC_SET_BAND", conf->band, 0, FALSE);
+	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_timeout", conf->bcn_timeout, 0, FALSE);
+	dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", conf->pm, 0, FALSE);
+	dhd_conf_set_intiovar(dhd, WLC_SET_SRL, "WLC_SET_SRL", conf->srl, 0, FALSE);
+	dhd_conf_set_intiovar(dhd, WLC_SET_LRL, "WLC_SET_LRL", conf->lrl, 0, FALSE);
+	dhd_conf_set_bw_cap(dhd);
+	dhd_conf_set_roam(dhd);
+
+#if defined(BCMPCIE)
+	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bus:deepsleep_disable",
+		conf->bus_deepsleep_disable, 0, FALSE);
+#endif /* defined(BCMPCIE) */
+
+#ifdef IDHCP
+	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "dhcpc_enable", conf->dhcpc_enable,
+		0, FALSE);
+	if (conf->dhcpd_enable >= 0) {
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_addr",
+			(char *)&conf->dhcpd_ip_addr, sizeof(conf->dhcpd_ip_addr), FALSE);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_mask",
+			(char *)&conf->dhcpd_ip_mask, sizeof(conf->dhcpd_ip_mask), FALSE);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_start",
+			(char *)&conf->dhcpd_ip_start, sizeof(conf->dhcpd_ip_start), FALSE);
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "dhcpd_ip_end",
+			(char *)&conf->dhcpd_ip_end, sizeof(conf->dhcpd_ip_end), FALSE);
+		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "dhcpd_enable",
+			conf->dhcpd_enable, 0, FALSE);
+	}
+#endif
+	dhd_conf_set_intiovar(dhd, WLC_SET_FAKEFRAG, "WLC_SET_FAKEFRAG",
+		conf->frameburst, 0, FALSE);
+
+	dhd_conf_set_wl_cmd(dhd, wl_preinit, TRUE);
+#if defined(BCMSDIO)
+	{
+		char ampdu_mpdu[] = "ampdu_mpdu=16";
+		dhd_conf_set_wl_cmd(dhd, ampdu_mpdu, TRUE);
+	}
+#endif
+	if (conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4371_CHIP_ID || conf->chip == BCM4359_CHIP_ID ||
+			conf->chip == BCM43569_CHIP_ID) {
+		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "txbf", 1, 0, FALSE);
+	}
+	dhd_conf_set_wl_cmd(dhd, conf->wl_preinit, TRUE);
+
+#ifndef WL_CFG80211
+	dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
+#endif
+
+}
+
+int
+dhd_conf_preinit(dhd_pub_t *dhd)
+{
+	struct dhd_conf *conf = dhd->conf;
+
+	CONFIG_TRACE("Enter\n");
+
+#ifdef BCMSDIO
+	dhd_conf_free_mac_list(&conf->fw_by_mac);
+	dhd_conf_free_mac_list(&conf->nv_by_mac);
+#endif
+	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+	dhd_conf_free_country_list(conf);
+	dhd_conf_free_mchan_list(conf);
+	if (conf->magic_pkt_filter_add) {
+		kfree(conf->magic_pkt_filter_add);
+		conf->magic_pkt_filter_add = NULL;
+	}
+	if (conf->wl_preinit) {
+		kfree(conf->wl_preinit);
+		conf->wl_preinit = NULL;
+	}
+	if (conf->wl_suspend) {
+		kfree(conf->wl_suspend);
+		conf->wl_suspend = NULL;
+	}
+	if (conf->wl_resume) {
+		kfree(conf->wl_resume);
+		conf->wl_resume = NULL;
+	}
+	conf->band = -1;
+	memset(&conf->bw_cap, -1, sizeof(conf->bw_cap));
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
+		strcpy(conf->cspec.country_abbrev, "ALL");
+		strcpy(conf->cspec.ccode, "ALL");
+		conf->cspec.rev = 0;
+	} else if (conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
+			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
+			conf->chip == BCM43569_CHIP_ID || conf->chip == BCM4359_CHIP_ID) {
+		strcpy(conf->cspec.country_abbrev, "CN");
+		strcpy(conf->cspec.ccode, "CN");
+		conf->cspec.rev = 38;
+	} else {
+		strcpy(conf->cspec.country_abbrev, "CN");
+		strcpy(conf->cspec.ccode, "CN");
+		conf->cspec.rev = 0;
+	}
+	memset(&conf->channels, 0, sizeof(wl_channel_list_t));
+	conf->roam_off = 1;
+	conf->roam_off_suspend = 1;
+	conf->roam_trigger[0] = -65;
+	conf->roam_trigger[1] = WLC_BAND_ALL;
+	conf->roam_scan_period[0] = 10;
+	conf->roam_scan_period[1] = WLC_BAND_ALL;
+	conf->roam_delta[0] = 10;
+	conf->roam_delta[1] = WLC_BAND_ALL;
+	conf->fullroamperiod = 20;
+	conf->keep_alive_period = 30000;
+#ifdef ARP_OFFLOAD_SUPPORT
+	conf->garp = FALSE;
+#endif
+	conf->force_wme_ac = 0;
+	memset(&conf->wme_sta, 0, sizeof(wme_param_t));
+	memset(&conf->wme_ap, 0, sizeof(wme_param_t));
+#ifdef PKT_FILTER_SUPPORT
+	memset(&conf->pkt_filter_add, 0, sizeof(conf_pkt_filter_add_t));
+	memset(&conf->pkt_filter_del, 0, sizeof(conf_pkt_filter_del_t));
+#endif
+	conf->srl = -1;
+	conf->lrl = -1;
+	conf->bcn_timeout = 16;
+	conf->disable_proptx = -1;
+	conf->dhd_poll = -1;
+#ifdef BCMSDIO
+	conf->use_rxchain = 0;
+	conf->bus_rxglom = TRUE;
+	conf->txglom_ext = FALSE;
+	conf->tx_max_offset = 0;
+	conf->txglomsize = SDPCM_DEFGLOM_SIZE;
+	conf->txctl_tmo_fix = 300;
+	conf->txglom_mode = SDPCM_TXGLOM_CPY;
+	conf->deferred_tx_len = 0;
+	conf->dhd_txminmax = 1;
+	conf->txinrx_thres = -1;
+#ifdef MINIME
+	conf->ramsize = 0x80000;
+#endif
+#if defined(SDIO_ISR_THREAD)
+	conf->intr_extn = FALSE;
+#endif
+#ifdef BCMSDIO_RXLIM_POST
+	conf->rxlim_en = FALSE;
+#endif
+#ifdef BCMSDIO_TXSEQ_SYNC
+#ifdef DHD_LOAD_CHIPALIVE
+	conf->txseq_sync = TRUE;
+#else
+	conf->txseq_sync = FALSE;
+#endif
+#endif
+#if defined(HW_OOB)
+	conf->oob_enabled_later = FALSE;
+#endif
+#endif
+#ifdef BCMPCIE
+	conf->bus_deepsleep_disable = 1;
+#endif
+	conf->dpc_cpucore = -1;
+	conf->rxf_cpucore = -1;
+	conf->frameburst = -1;
+	conf->deepsleep = FALSE;
+	conf->pm = -1;
+	conf->pm_in_suspend = -1;
+	conf->insuspend = 0;
+	conf->suspend_mode = EARLY_SUSPEND;
+	conf->suspend_bcn_li_dtim = -1;
+#ifdef WL_EXT_WOWL
+	dhd_master_mode = TRUE;
+	conf->wowl = WL_WOWL_NET|WL_WOWL_DIS|WL_WOWL_BCN;
+	conf->insuspend |= (WOWL_IN_SUSPEND | NO_TXDATA_IN_SUSPEND);
+#endif
+	if (conf->suspend_mode == PM_NOTIFIER)
+		conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
+#ifdef DHD_LOAD_CHIPALIVE
+	conf->insuspend |= NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND;
+#endif
+	conf->suspended = FALSE;
+#ifdef SUSPEND_EVENT
+	memset(&conf->resume_eventmask, 0, sizeof(conf->resume_eventmask));
+	memset(&conf->bssid_insuspend, 0, ETHER_ADDR_LEN);
+	conf->wlfc = FALSE;
+#endif
+#ifdef GET_CUSTOM_MAC_FROM_CONFIG
+	memset(&conf->hw_ether, 0, sizeof(conf->hw_ether));
+#endif
+#ifdef IDHCP
+	conf->dhcpc_enable = -1;
+	conf->dhcpd_enable = -1;
+#endif
+	conf->orphan_move = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+	conf->tsq = 10;
+#else
+	conf->tsq = 0;
+#endif
+#ifdef DHDTCPACK_SUPPRESS
+#ifdef BCMPCIE
+	conf->tcpack_sup_mode = TCPACK_SUP_DEFAULT;
+#else
+	conf->tcpack_sup_mode = TCPACK_SUP_OFF;
+#endif
+#endif
+	conf->pktprio8021x = -1;
+	conf->ctrl_resched = 2;
+	conf->in4way = STA_NO_SCAN_IN4WAY | STA_WAIT_DISCONNECTED | AP_WAIT_STA_RECONNECT;
+#ifdef PROPTX_MAXCOUNT
+	conf->proptx_maxcnt_2g = 46;
+	conf->proptx_maxcnt_5g = WL_TXSTATUS_FREERUNCTR_MASK;
+#endif /* DYNAMIC_PROPTX_MAXCOUNT */
+#ifdef HOST_TPUT_TEST
+	conf->data_drop_mode = 0;
+#endif
+#ifdef ISAM_PREINIT
+	memset(conf->isam_init, 0, sizeof(conf->isam_init));
+	memset(conf->isam_config, 0, sizeof(conf->isam_config));
+	memset(conf->isam_enable, 0, sizeof(conf->isam_enable));
+#endif
+#if defined(SDIO_ISR_THREAD)
+	if (conf->chip == BCM43012_CHIP_ID ||
+			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
+			conf->chip == BCM43454_CHIP_ID || conf->chip == BCM4345_CHIP_ID ||
+			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
+			conf->chip == BCM4359_CHIP_ID) {
+		conf->intr_extn = TRUE;
+	}
+#endif
+	if ((conf->chip == BCM43430_CHIP_ID && conf->chiprev == 2) ||
+			conf->chip == BCM43012_CHIP_ID ||
+			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
+			conf->chip == BCM43454_CHIP_ID || conf->chip == BCM4345_CHIP_ID ||
+			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
+			conf->chip == BCM43569_CHIP_ID || conf->chip == BCM4359_CHIP_ID) {
+#ifdef DHDTCPACK_SUPPRESS
+#ifdef BCMSDIO
+		conf->tcpack_sup_mode = TCPACK_SUP_REPLACE;
+#endif
+#endif
+#if defined(BCMSDIO) || defined(BCMPCIE)
+		dhd_rxbound = 128;
+		dhd_txbound = 64;
+#endif
+		conf->frameburst = 1;
+#ifdef BCMSDIO
+		conf->dhd_txminmax = -1;
+		conf->txinrx_thres = 128;
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+		conf->orphan_move = 1;
+#else
+		conf->orphan_move = 0;
+#endif
+	}
+
+#ifdef BCMSDIO
+#if defined(BCMSDIOH_TXGLOM_EXT)
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
+			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		conf->txglom_ext = TRUE;
+	} else {
+		conf->txglom_ext = FALSE;
+	}
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
+		conf->txglom_bucket_size = 1680; // fixed value, don't change
+		conf->txglomsize = 6;
+	}
+	if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
+			conf->chip == BCM43341_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		conf->txglom_bucket_size = 1684; // fixed value, don't change
+		conf->txglomsize = 16;
+	}
+#endif
+	if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
+		conf->txglomsize = SDPCM_MAXGLOM_SIZE;
+#endif
+	init_waitqueue_head(&conf->event_complete);
+
+	return 0;
+}
+
+int
+dhd_conf_reset(dhd_pub_t *dhd)
+{
+	struct dhd_conf *conf = dhd->conf;
+
+#ifdef BCMSDIO
+	dhd_conf_free_mac_list(&conf->fw_by_mac);
+	dhd_conf_free_mac_list(&conf->nv_by_mac);
+#endif
+	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+	dhd_conf_free_country_list(conf);
+	dhd_conf_free_mchan_list(conf);
+	if (conf->magic_pkt_filter_add) {
+		kfree(conf->magic_pkt_filter_add);
+		conf->magic_pkt_filter_add = NULL;
+	}
+	if (conf->wl_preinit) {
+		kfree(conf->wl_preinit);
+		conf->wl_preinit = NULL;
+	}
+	if (conf->wl_suspend) {
+		kfree(conf->wl_suspend);
+		conf->wl_suspend = NULL;
+	}
+	if (conf->wl_resume) {
+		kfree(conf->wl_resume);
+		conf->wl_resume = NULL;
+	}
+	memset(conf, 0, sizeof(dhd_conf_t));
+	return 0;
+}
+
+int
+dhd_conf_attach(dhd_pub_t *dhd)
+{
+	dhd_conf_t *conf;
+
+	CONFIG_TRACE("Enter\n");
+
+	if (dhd->conf != NULL) {
+		CONFIG_MSG("config is attached before!\n");
+		return 0;
+	}
+	/* Allocate private bus interface state */
+	if (!(conf = MALLOC(dhd->osh, sizeof(dhd_conf_t)))) {
+		CONFIG_ERROR("MALLOC failed\n");
+		goto fail;
+	}
+	memset(conf, 0, sizeof(dhd_conf_t));
+
+	dhd->conf = conf;
+
+	return 0;
+
+fail:
+	if (conf != NULL)
+		MFREE(dhd->osh, conf, sizeof(dhd_conf_t));
+	return BCME_NOMEM;
+}
+
+void
+dhd_conf_detach(dhd_pub_t *dhd)
+{
+	struct dhd_conf *conf = dhd->conf;
+
+	CONFIG_TRACE("Enter\n");
+	if (dhd->conf) {
+#ifdef BCMSDIO
+		dhd_conf_free_mac_list(&conf->fw_by_mac);
+		dhd_conf_free_mac_list(&conf->nv_by_mac);
+#endif
+		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+		dhd_conf_free_country_list(conf);
+		dhd_conf_free_mchan_list(conf);
+		if (conf->magic_pkt_filter_add) {
+			kfree(conf->magic_pkt_filter_add);
+			conf->magic_pkt_filter_add = NULL;
+		}
+		if (conf->wl_preinit) {
+			kfree(conf->wl_preinit);
+			conf->wl_preinit = NULL;
+		}
+		if (conf->wl_suspend) {
+			kfree(conf->wl_suspend);
+			conf->wl_suspend = NULL;
+		}
+		if (conf->wl_resume) {
+			kfree(conf->wl_resume);
+			conf->wl_resume = NULL;
+		}
+		MFREE(dhd->osh, conf, sizeof(dhd_conf_t));
+	}
+	dhd->conf = NULL;
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.h
index c8c263bb8321..6917e1743feb 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_config.h
@@ -14,6 +14,7 @@
 #define FW_TYPE_MESH    3
 #define FW_TYPE_ES      4
 #define FW_TYPE_MFG     5
+#define FW_TYPE_MINIME  6
 #define FW_TYPE_G       0
 #define FW_TYPE_AG      1
 
@@ -103,10 +104,10 @@ typedef struct mchan_params {
 } mchan_params_t;
 
 enum in4way_flags {
-	NO_SCAN_IN4WAY	= (1 << (0)),
-	NO_BTC_IN4WAY	= (1 << (1)),
-	DONT_DELETE_GC_AFTER_WPS	= (1 << (2)),
-	WAIT_DISCONNECTED	= (1 << (3)),
+	STA_NO_SCAN_IN4WAY	= (1 << (0)),
+	STA_NO_BTC_IN4WAY	= (1 << (1)),
+	STA_WAIT_DISCONNECTED	= (1 << (2)),
+	AP_WAIT_STA_RECONNECT	= (1 << (3)),
 };
 
 enum in_suspend_flags {
@@ -125,6 +126,14 @@ enum in_suspend_mode {
 	PM_NOTIFIER = 1
 };
 
+#ifdef HOST_TPUT_TEST
+enum data_drop_mode {
+	NO_DATA_DROP = 0,
+	TXPKT_DROP = 1,
+	XMIT_DROP = 2
+};
+#endif
+
 enum eapol_status {
 	EAPOL_STATUS_NONE = 0,
 	EAPOL_STATUS_REQID = 1,
@@ -212,12 +221,18 @@ typedef struct dhd_conf {
 	int txinrx_thres;
 	int dhd_txminmax; // -1=DATABUFCNT(bus)
 	bool oob_enabled_later;
+#ifdef MINIME
+	uint32 ramsize;
+#endif
 #if defined(SDIO_ISR_THREAD)
 	bool intr_extn;
 #endif
 #ifdef BCMSDIO_RXLIM_POST
 	bool rxlim_en;
 #endif
+#ifdef BCMSDIO_TXSEQ_SYNC
+	bool txseq_sync;
+#endif
 #endif
 #ifdef BCMPCIE
 	int bus_deepsleep_disable;
@@ -261,7 +276,6 @@ typedef struct dhd_conf {
 	char *wl_resume;
 	int tsq;
 	int orphan_move;
-	uint eapol_status;
 	uint in4way;
 #ifdef WL_EXT_WOWL
 	uint wowl;
@@ -270,6 +284,13 @@ typedef struct dhd_conf {
 	char hw_ether[62];
 #endif
 	wait_queue_head_t event_complete;
+#ifdef PROPTX_MAXCOUNT
+	int proptx_maxcnt_2g;
+	int proptx_maxcnt_5g;
+#endif /* DYNAMIC_PROPTX_MAXCOUNT */
+#ifdef HOST_TPUT_TEST
+	int data_drop_mode;
+#endif
 } dhd_conf_t;
 
 #ifdef BCMSDIO
@@ -278,7 +299,6 @@ void dhd_conf_get_otp(dhd_pub_t *dhd, bcmsdh_info_t *sdh);
 void dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip);
 #endif
 void dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable);
-int dhd_conf_set_blksize(bcmsdh_info_t *sdh);
 #endif
 void dhd_conf_set_path_params(dhd_pub_t *dhd, char *fw_path, char *nv_path);
 int dhd_conf_set_intiovar(dhd_pub_t *dhd, uint cmd, char *name, int val,
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.c
new file mode 100644
index 000000000000..10db0cf56b74
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.c
@@ -0,0 +1,221 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Broadcom Dongle Host Driver (DHD)
+ *
+ * Copyright (C) 1999-2018, Broadcom.
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * $Id: dhd_csi.c 606280 2015-12-15 05:28:25Z $
+ */
+#include <osl.h>
+
+#include <bcmutils.h>
+
+#include <bcmendian.h>
+#include <linuxver.h>
+#include <linux/list.h>
+#include <linux/sort.h>
+#include <dngl_stats.h>
+#include <wlioctl.h>
+
+#include <bcmevent.h>
+#include <dhd.h>
+#include <dhd_dbg.h>
+#include <dhd_csi.h>
+
+#define NULL_CHECK(p, s, err)  \
+	do { \
+		if (!(p)) { \
+			printf("NULL POINTER (%s) : %s\n", __FUNCTION__, (s)); \
+			err = BCME_ERROR; \
+			return err; \
+		} \
+	} while (0)
+
+#define TIMESPEC_TO_US(ts)  (((uint64)(ts).tv_sec * USEC_PER_SEC) + \
+						(ts).tv_nsec / NSEC_PER_USEC)
+
+#define NULL_ADDR	"\x00\x00\x00\x00\x00\x00"
+
+int
+dhd_csi_event_handler(dhd_pub_t *dhd, wl_event_msg_t *event, void *event_data)
+{
+	int ret = BCME_OK;
+	bool is_new = TRUE;
+	cfr_dump_data_t *p_event;
+	cfr_dump_list_t *ptr, *next, *new;
+
+	NULL_CHECK(dhd, "dhd is NULL", ret);
+
+	DHD_TRACE(("Enter %s\n", __FUNCTION__));
+
+	if (!event_data) {
+		DHD_ERROR(("%s: event_data is NULL\n", __FUNCTION__));
+		return -EINVAL;
+	}
+	p_event = (cfr_dump_data_t *)event_data;
+
+	/* check if this addr exist */
+	if (!list_empty(&dhd->csi_list)) {
+		list_for_each_entry_safe(ptr, next, &dhd->csi_list, list) {
+			if (bcmp(&ptr->entry.header.peer_macaddr, &p_event->header.peer_macaddr,
+					ETHER_ADDR_LEN) == 0) {
+				int pos = 0, dump_len = 0, remain = 0;
+				is_new = FALSE;
+				DHD_INFO(("CSI data exist\n"));
+				if (p_event->header.status == 0) {
+					bcopy(&p_event->header, &ptr->entry.header, sizeof(cfr_dump_header_t));
+					dump_len = p_event->header.cfr_dump_length;
+					if (dump_len < MAX_EVENT_SIZE) {
+						bcopy(&p_event->data, &ptr->entry.data, dump_len);
+					} else {
+						/* for big csi data */
+						uint8 *p = (uint8 *)&ptr->entry.data;
+						remain = p_event->header.remain_length;
+						if (remain) {
+							pos = dump_len - remain - MAX_EVENT_SIZE;
+							p += pos;
+							bcopy(&p_event->data, p, MAX_EVENT_SIZE);
+						}
+						/* copy rest of csi data */
+						else {
+							pos = dump_len - (dump_len % MAX_EVENT_SIZE);
+							p += pos;
+							bcopy(&p_event->data, p, (dump_len % MAX_EVENT_SIZE));
+						}
+					}
+					return BCME_OK;
+				}
+			}
+		}
+	}
+	if (is_new) {
+		if (dhd->csi_count < MAX_CSI_NUM) {
+			new = (cfr_dump_list_t *)MALLOCZ(dhd->osh, sizeof(cfr_dump_list_t));
+			if (!new){
+				DHD_ERROR(("Malloc cfr dump list error\n"));
+				return BCME_NOMEM;
+			}
+			bcopy(&p_event->header, &new->entry.header, sizeof(cfr_dump_header_t));
+			DHD_INFO(("New entry data size %d\n", p_event->header.cfr_dump_length));
+			/* for big csi data */
+			if (p_event->header.remain_length) {
+				DHD_TRACE(("remain %d\n", p_event->header.remain_length));
+				bcopy(&p_event->data, &new->entry.data, MAX_EVENT_SIZE);
+			}
+			else
+				bcopy(&p_event->data, &new->entry.data, p_event->header.cfr_dump_length);
+			INIT_LIST_HEAD(&(new->list));
+			list_add_tail(&(new->list), &dhd->csi_list);
+			dhd->csi_count++;
+		}
+		else {
+			DHD_TRACE(("Over maximum CSI Number 8. SKIP it.\n"));
+		}
+	}
+	return ret;
+}
+
+int
+dhd_csi_init(dhd_pub_t *dhd)
+{
+	int err = BCME_OK;
+
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	INIT_LIST_HEAD(&dhd->csi_list);
+	dhd->csi_count = 0;
+
+	return err;
+}
+
+int
+dhd_csi_deinit(dhd_pub_t *dhd)
+{
+	int err = BCME_OK;
+	cfr_dump_list_t *ptr, *next;
+
+	NULL_CHECK(dhd, "dhd is NULL", err);
+
+	if (!list_empty(&dhd->csi_list)) {
+		list_for_each_entry_safe(ptr, next, &dhd->csi_list, list) {
+			list_del(&ptr->list);
+			MFREE(dhd->osh, ptr, sizeof(cfr_dump_list_t));
+		}
+	}
+	return err;
+}
+
+void
+dhd_csi_clean_list(dhd_pub_t *dhd)
+{
+	cfr_dump_list_t *ptr, *next;
+	int num = 0;
+
+	if (!dhd) {
+		DHD_ERROR(("NULL POINTER: %s\n", __FUNCTION__));
+		return;
+	}
+
+	if (!list_empty(&dhd->csi_list)) {
+		list_for_each_entry_safe(ptr, next, &dhd->csi_list, list) {
+			if (0 == ptr->entry.header.remain_length) {
+				list_del(&ptr->list);
+				num++;
+				MFREE(dhd->osh, ptr, sizeof(cfr_dump_list_t));
+			}
+		}
+	}
+	dhd->csi_count = 0;
+	DHD_TRACE(("Clean up %d record\n", num));
+}
+
+int
+dhd_csi_dump_list(dhd_pub_t *dhd, char *buf)
+{
+	int ret = BCME_OK;
+	cfr_dump_list_t *ptr, *next;
+	uint8 * pbuf = buf;
+	int num = 0;
+	int length = 0;
+
+	NULL_CHECK(dhd, "dhd is NULL", ret);
+
+	/* check if this addr exist */
+	if (!list_empty(&dhd->csi_list)) {
+		list_for_each_entry_safe(ptr, next, &dhd->csi_list, list) {
+			if (ptr->entry.header.remain_length) {
+				DHD_ERROR(("data not ready %d\n", ptr->entry.header.remain_length));
+				continue;
+			}
+			bcopy(&ptr->entry.header, pbuf, sizeof(cfr_dump_header_t));
+			length += sizeof(cfr_dump_header_t);
+			pbuf += sizeof(cfr_dump_header_t);
+			DHD_TRACE(("Copy data size %d\n", ptr->entry.header.cfr_dump_length));
+			bcopy(&ptr->entry.data, pbuf, ptr->entry.header.cfr_dump_length);
+			length += ptr->entry.header.cfr_dump_length;
+			pbuf += ptr->entry.header.cfr_dump_length;
+			num++;
+		}
+	}
+	DHD_TRACE(("dump %d record %d bytes\n", num, length));
+
+	return length;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.h
new file mode 100644
index 000000000000..b4e5aac848e9
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_csi.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Broadcom Dongle Host Driver (DHD), CSI
+ *
+ * Copyright (C) 1999-2018, Broadcom.
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * $Id: dhd_csi.h 558438 2015-05-22 06:05:11Z $
+ */
+#ifndef __DHD_CSI_H__
+#define __DHD_CSI_H__
+
+/* Maxinum csi file dump size */
+#define MAX_CSI_FILESZ		(32 * 1024)
+/* Maxinum subcarrier number */
+#define MAXINUM_CFR_DATA	256 * 4
+#define CSI_DUMP_PATH		"/sys/bcm-dhd/csi"
+#define MAX_EVENT_SIZE		1400
+/* maximun csi number stored at dhd */
+#define MAX_CSI_NUM		8
+
+typedef struct cfr_dump_header {
+	/* 0 - successful; 1 - Failed */
+	uint8 status;
+	/* Peer MAC address */
+	uint8 peer_macaddr[6];
+	/* Number of Space Time Streams */
+	uint8 sts;
+	/* Number of RX chain */
+	uint8 num_rx;
+	/* Number of subcarrier */
+	uint16 num_carrier;
+	/* Length of the CSI dump */
+	uint32 cfr_dump_length;
+	/* remain unsend CSI data length */
+	uint32 remain_length;
+	/* RSSI */
+	int8 rssi;
+} __attribute__((packed)) cfr_dump_header_t;
+
+typedef struct cfr_dump_data {
+	cfr_dump_header_t header;
+	uint32 data[MAXINUM_CFR_DATA];
+} cfr_dump_data_t;
+
+typedef struct {
+	struct list_head list;
+	cfr_dump_data_t entry;
+} cfr_dump_list_t;
+
+int dhd_csi_event_handler(dhd_pub_t *dhd, wl_event_msg_t *event, void *event_data);
+
+int dhd_csi_init(dhd_pub_t *dhd);
+
+int dhd_csi_deinit(dhd_pub_t *dhd);
+
+void dhd_csi_clean_list(dhd_pub_t *dhd);
+
+int dhd_csi_dump_list(dhd_pub_t *dhd, char *buf);
+#endif /* __DHD_CSI_H__ */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_gpio.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_gpio.c
index 9cf966163a97..4bd20da047e0 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_gpio.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_gpio.c
@@ -68,7 +68,7 @@ dhd_wlan_set_power(int on
 #endif /* BCMPCIE */
 #endif /* BUS_POWER_RESTORE */
 		/* Lets customer power to get stable */
-		mdelay(100);
+//		mdelay(100);
 	} else {
 #if defined(BUS_POWER_RESTORE)
 #if defined(BCMSDIO) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0))
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux.c
index 8bfd439e96b9..157ec3b5f5e1 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux.c
@@ -4,13 +4,13 @@
  * Basically selected code segments from usb-cdc.c and usb-rndis.c
  *
  * Copyright (C) 1999-2017, Broadcom Corporation
- * 
+ *
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
  * under the terms of the GNU General Public License version 2 (the "GPL"),
  * available at http://www.broadcom.com/licenses/GPLv2.php, with the
  * following added to such license:
- * 
+ *
  *      As a special exception, the copyright holders of this software give you
  * permission to link this software with independent modules, and to copy and
  * distribute the resulting executable under terms of your choice, provided that
@@ -18,7 +18,7 @@
  * the license of that module.  An independent module is a module which is not
  * derived from this software.  The special exception does not apply to any
  * modifications of the software.
- * 
+ *
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
@@ -106,6 +106,10 @@
 #include <dhd_timesync.h>
 #endif /* DHD_TIMESYNC */
 
+#ifdef CSI_SUPPORT
+#include <dhd_csi.h>
+#endif /* CSI_SUPPORT */
+
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 #endif
@@ -261,7 +265,7 @@ extern bool ap_cfg_running;
 extern bool ap_fw_loaded;
 #endif
 
-extern void dhd_dump_eapol_4way_message(dhd_pub_t *dhd, char *ifname,
+extern void dhd_dump_eapol_4way_message(dhd_pub_t *dhd, int ifidx,
 	char *dump_data, bool direction);
 
 #ifdef FIX_CPU_MIN_CLOCK
@@ -338,10 +342,10 @@ DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
 
 #if defined(OOB_INTR_ONLY) || defined(FORCE_WOWLAN)
 extern void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable);
-#endif 
+#endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 static void dhd_hang_process(void *dhd_info, void *event_data, u8 event);
-#endif 
+#endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 MODULE_LICENSE("GPL and additional rights");
 #endif /* LinuxVer */
@@ -350,7 +354,7 @@ MODULE_LICENSE("GPL and additional rights");
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
 DEFINE_MUTEX(_dhd_mutex_lock_);
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
-#endif 
+#endif
 static int dhd_suspend_resume_helper(struct dhd_info *dhd, int val, int force);
 
 #ifdef CONFIG_BCM_DETECT_CONSECUTIVE_HANG
@@ -447,7 +451,7 @@ extern void wl_android_set_wifi_on_flag(bool enable);
 
 #if defined(TRAFFIC_MGMT_DWM)
 void traffic_mgmt_pkt_set_prio(dhd_pub_t *dhdp, void * pktbuf);
-#endif 
+#endif
 
 #ifdef DHD_FW_COREDUMP
 static void dhd_mem_dump(void *dhd_info, void *event_info, u8 event);
@@ -690,7 +694,7 @@ typedef struct dhd_info {
 #if defined(PKT_FILTER_SUPPORT) && defined(APF)
 	struct mutex dhd_apf_mutex;
 #endif /* PKT_FILTER_SUPPORT && APF */
-#endif 
+#endif
 	spinlock_t wakelock_spinlock;
 	spinlock_t wakelock_evt_spinlock;
 	uint32 wakelock_counter;
@@ -4685,8 +4689,8 @@ dhd_trx_dump(struct net_device *ndev, uint8 *dump_data, uint datalen, bool tx)
 	ifname = ndev ? ndev->name : "N/A";
 
 	if (protocol != ETHER_TYPE_BRCM) {
-		DHD_ERROR(("[dhd-%s] %s DUMP - %s\n", ifname, tx?"Tx":"Rx",
-			_get_packet_type_str(protocol)));
+		printk("[dhd-%s] %s DUMP - %s\n", ifname, tx?"Tx":"Rx",
+			_get_packet_type_str(protocol));
 #if defined(DHD_TX_FULL_DUMP) || defined(DHD_RX_FULL_DUMP)
 		prhex("Data", dump_data, datalen);
 #endif /* DHD_TX_FULL_DUMP || DHD_RX_FULL_DUMP */
@@ -4777,7 +4781,7 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 	struct ether_header *eh = NULL;
 #if defined(DHD_L2_FILTER)
 	dhd_if_t *ifp = dhd_get_ifp(dhdp, ifidx);
-#endif 
+#endif
 
 	/* Reject if down */
 	if (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN)) {
@@ -4852,7 +4856,7 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 #endif /* DHD_LOSSLESS_ROAMING */
 			DBG_EVENT_LOG(dhdp, WIFI_EVENT_DRIVER_EAPOL_FRAME_TRANSMIT_REQUESTED);
 			atomic_inc(&dhd->pend_8021x_cnt);
-			dhd_dump_eapol_4way_message(dhdp, dhd_ifname(dhdp, ifidx), pktdata, TRUE);
+			dhd_dump_eapol_4way_message(dhdp, ifidx, pktdata, TRUE);
 		}
 
 		if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
@@ -4895,7 +4899,7 @@ __dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 #ifdef BCM_GMAC3
 	DHD_PKT_SET_DATAOFF(pktbuf, 0);
 #endif /* BCM_GMAC3 */
-#endif 
+#endif
 
 #ifdef PCIE_FULL_DONGLE
 	/*
@@ -5065,7 +5069,7 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 	uint8 htsfdlystat_sz = dhd->pub.htsfdlystat_sz;
 #else
 	uint8 htsfdlystat_sz = 0;
-#endif 
+#endif
 #ifdef DHD_WMF
 	struct ether_header *eh;
 	uint8 *iph;
@@ -5195,6 +5199,16 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 
 	datalen  = PKTLEN(dhd->pub.osh, skb);
 
+#ifdef HOST_TPUT_TEST
+	dhd_os_sdlock_txq(&dhd->pub);
+	dhd->pub.net_len += datalen;
+	dhd_os_sdunlock_txq(&dhd->pub);
+	if ((dhd->pub.conf->data_drop_mode == XMIT_DROP) &&
+			(PKTLEN(dhd->pub.osh, skb) > 500)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+#endif
 	/* Make sure there's enough room for any header */
 	if (skb_headroom(skb) < dhd->pub.hdrlen + htsfdlystat_sz) {
 		struct sk_buff *skb2;
@@ -5242,7 +5256,7 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 			eh->ether_type = hton16(ETHER_TYPE_BRCM_PKTDLYSTATS);
 		}
 	}
-#endif 
+#endif
 #ifdef DHD_WET
 	/* wet related packet proto manipulation should be done in DHD
 	   since dongle doesn't have complete payload
@@ -5919,7 +5933,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 		protocol = (skb->data[12] << 8) | skb->data[13];
 		if (protocol == ETHER_TYPE_802_1X) {
 			DBG_EVENT_LOG(dhdp, WIFI_EVENT_DRIVER_EAPOL_FRAME_RECEIVED);
-			dhd_dump_eapol_4way_message(dhdp, dhd_ifname(dhdp, ifidx), dump_data, FALSE);
+			dhd_dump_eapol_4way_message(dhdp, ifidx, dump_data, FALSE);
 		}
 
 		if (protocol != ETHER_TYPE_BRCM && protocol == ETHER_TYPE_IP) {
@@ -6008,7 +6022,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 			 * DHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT is defined
 			 */
 			if (event_type == WLC_E_TRACE) {
-				DHD_TRACE(("%s: WLC_E_TRACE\n", __FUNCTION__));
+				DHD_EVENT(("%s: WLC_E_TRACE\n", __FUNCTION__));
 				dhd_event_logtrace_enqueue(dhdp, ifidx, pktbuf);
 				continue;
 			}
@@ -8362,7 +8376,7 @@ dhd_stop(struct net_device *net)
 
 #if defined(WL_CFG80211) && defined(USE_INITIAL_SHORT_DWELL_TIME)
 extern bool g_first_broadcast_scan;
-#endif 
+#endif
 
 #ifdef WL11U
 static int dhd_interworking_enable(dhd_pub_t *dhd)
@@ -8511,7 +8525,7 @@ dhd_open(struct net_device *net)
 #endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 #if defined(USE_INITIAL_SHORT_DWELL_TIME)
 			g_first_broadcast_scan = TRUE;
-#endif 
+#endif
 #ifdef DHD_LOAD_CHIPALIVE
 fail_retry:
 #endif
@@ -8746,6 +8760,12 @@ dhd_open(struct net_device *net)
 #endif
 
 exit:
+#ifdef ENABLE_INSMOD_NO_FW_LOAD
+	if (dhd_chip_alive) {
+		dhd_download_fw_on_driverload = FALSE;
+		dhd_driver_init_done = TRUE;
+	}
+#endif
 	if (ret) {
 		dhd_stop(net);
 	}
@@ -9437,7 +9457,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen
 	/* will implement get_ids for DBUS later */
 #if defined(BCMSDIO)
 	dhd_bus_get_ids(bus, &bus_type, &bus_num, &slot_num);
-#endif 
+#endif
 #if defined(BCMSDIO) || defined(BCMPCIE)
 	adapter = dhd_wifi_platform_get_adapter(bus_type, bus_num, slot_num);
 #endif
@@ -9624,7 +9644,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen
 #if defined(PKT_FILTER_SUPPORT) && defined(APF)
 	mutex_init(&dhd->dhd_apf_mutex);
 #endif /* PKT_FILTER_SUPPORT && APF */
-#endif 
+#endif
 	dhd_state |= DHD_ATTACH_STATE_WAKELOCKS_INIT;
 
 	/* Attach and link in the protocol */
@@ -9924,6 +9944,10 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen
 	dhd->dhd_state = dhd_state;
 
 	dhd_found++;
+	
+#ifdef CSI_SUPPORT
+	dhd_csi_init(&dhd->pub);
+#endif /* CSI_SUPPORT */
 
 	return &dhd->pub;
 
@@ -10403,7 +10427,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 #elif defined(FORCE_WOWLAN)
 	/* Enable oob at firmware */
 	dhd_enable_oob_intr(dhd->pub.bus, TRUE);
-#endif 
+#endif
 #ifdef PCIE_FULL_DONGLE
 	{
 		/* max_h2d_rings includes H2D common rings */
@@ -10484,7 +10508,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 #if defined(TRAFFIC_MGMT_DWM)
 	bzero(&dhd->pub.dhd_tm_dwm_tbl, sizeof(dhd_trf_mgmt_dwm_tbl_t));
-#endif 
+#endif
 	DHD_PERIM_UNLOCK(dhdp);
 	return 0;
 }
@@ -10662,7 +10686,7 @@ int dhd_tdls_update_peer_info(dhd_pub_t *dhdp, wl_event_msg_t *event)
 	return BCME_OK;
 }
 #endif /* PCIE_FULL_DONGLE */
-#endif 
+#endif
 
 bool dhd_is_concurrent_mode(dhd_pub_t *dhd)
 {
@@ -10734,7 +10758,7 @@ dhd_get_concurrent_capabilites(dhd_pub_t *dhd)
 	}
 	return 0;
 }
-#endif 
+#endif
 
 #ifdef SUPPORT_AP_POWERSAVE
 #define RXCHAIN_PWRSAVE_PPS			10
@@ -10851,7 +10875,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	uint32 wnm_cap = 0;
 #if defined(CUSTOM_AMPDU_BA_WSIZE)
 	uint32 ampdu_ba_wsize = 0;
-#endif 
+#endif
 #if defined(CUSTOM_AMPDU_MPDU)
 	int32 ampdu_mpdu = 0;
 #endif
@@ -10965,7 +10989,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #endif /* PROP_TXSTATUS */
 #if defined(SUPPORT_5G_1024QAM_VHT)
 	uint32 vht_features = 0; /* init to 0, will be set based on each support */
-#endif 
+#endif
 #ifdef DISABLE_11N_PROPRIETARY_RATES
 	uint32 ht_features = 0;
 #endif /* DISABLE_11N_PROPRIETARY_RATES */
@@ -11228,12 +11252,12 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 		}
 #else
 	(void)concurrent_mode;
-#endif 
+#endif
 	}
 
 #if defined(RSDB_MODE_FROM_FILE)
 	(void)dhd_rsdb_mode_from_file(dhd);
-#endif 
+#endif
 
 #ifdef DISABLE_PRUNED_SCAN
 	if (FW_SUPPORTED(dhd, rsdb)) {
@@ -11417,7 +11441,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	if (ap_fw_loaded == TRUE) {
 		dhd_wl_ioctl_cmd(dhd, WLC_SET_DTIMPRD, (char *)&dtim, sizeof(dtim), TRUE, 0);
 	}
-#endif 
+#endif
 
 #if defined(KEEP_ALIVE)
 	{
@@ -11426,7 +11450,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 
 #if defined(SOFTAP)
 	if (ap_fw_loaded == FALSE)
-#endif 
+#endif
 		if (!(dhd->op_mode &
 			(DHD_FLAG_HOSTAP_MODE | DHD_FLAG_MFG_MODE))) {
 			if ((res = dhd_keep_alive_onoff(dhd)) < 0)
@@ -11500,7 +11524,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 				__FUNCTION__, ampdu_ba_wsize, ret));
 		}
 	}
-#endif 
+#endif
 
 #ifdef ENABLE_TEMP_THROTTLING
 	if (dhd->op_mode & DHD_FLAG_STA_MODE) {
@@ -11578,7 +11602,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 			}
 		}
 	}
-#endif 
+#endif
 #ifdef DISABLE_11N_PROPRIETARY_RATES
 	ret = dhd_iovar(dhd, 0, "ht_features", (char *)&ht_features, sizeof(ht_features), NULL, 0,
 			TRUE);
@@ -11676,6 +11700,9 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #ifdef WL_ESCAN
 	setbit(eventmask, WLC_E_ESCAN_RESULT);
 #endif /* WL_ESCAN */
+#ifdef CSI_SUPPORT
+	setbit(eventmask, WLC_E_CSI);
+#endif /* CSI_SUPPORT */
 #ifdef RTT_SUPPORT
 	setbit(eventmask, WLC_E_PROXD);
 #endif /* RTT_SUPPORT */
@@ -11765,6 +11792,9 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #ifdef ENABLE_TEMP_THROTTLING
 		setbit(eventmask_msg->mask, WLC_E_TEMP_THROTTLE);
 #endif /* ENABLE_TEMP_THROTTLING */
+#ifdef WL_CLIENT_SAE
+		setbit(eventmask_msg->mask, WLC_E_JOIN_START);
+#endif /* WL_CLIENT_SAE */
 
 		/* Write updated Event mask */
 		eventmask_msg->ver = EVENTMSGS_VER;
@@ -13092,7 +13122,7 @@ dhd_bus_detach(dhd_pub_t *dhdp)
 
 #if defined(OOB_INTR_ONLY) || defined(BCMPCIE_OOB_HOST_WAKE)
 			dhd_bus_oob_intr_unregister(dhdp);
-#endif 
+#endif
 		}
 	}
 }
@@ -13352,6 +13382,10 @@ void dhd_detach(dhd_pub_t *dhdp)
 	}
 #endif /* DHD_LB */
 
+#ifdef CSI_SUPPORT
+	dhd_csi_deinit(dhdp);
+#endif /* CSI_SUPPORT */
+
 	DHD_SSSR_MEMPOOL_DEINIT(&dhd->pub);
 
 #ifdef DHD_LOG_DUMP
@@ -15478,7 +15512,7 @@ dhd_dev_pno_get_gscan(struct net_device *dev, dhd_pno_gscan_cmd_cfg_t type,
 	return (dhd_pno_get_gscan(&dhd->pub, type, info, len));
 }
 #endif /* GSCAN_SUPPORT || DHD_GET_VALID_CHANNELS */
-#endif 
+#endif
 
 #ifdef  RSSI_MONITOR_SUPPORT
 int
@@ -16200,7 +16234,7 @@ static void dhd_hang_process(void *dhd_info, void *event_info, u8 event)
 		rtnl_lock();
 		dev_close(dev);
 		rtnl_unlock();
-#endif 
+#endif
 #if defined(WL_WIRELESS_EXT)
 		wl_iw_send_priv_event(dev, "HANG");
 #endif
@@ -16404,7 +16438,7 @@ int dhd_net_set_fw_path(struct net_device *dev, char *fw)
 		DHD_INFO(("GOT STA FIRMWARE\n"));
 		ap_fw_loaded = FALSE;
 	}
-#endif 
+#endif
 	return 0;
 }
 
@@ -16538,7 +16572,7 @@ dhd_wait_pend8021x(struct net_device *dev)
 	if (ntimes == 0)
 	{
 		atomic_set(&dhd->pend_8021x_cnt, 0);
-		DHD_ERROR(("%s: TIMEOUT\n", __FUNCTION__));
+		WL_MSG(dev->name, "TIMEOUT\n");
 	}
 	return pend;
 }
@@ -16591,7 +16625,7 @@ int write_file(const char * file_name, uint32 flags, uint8 *buf, int size)
 
 	return ret;
 }
-#endif 
+#endif
 
 #ifdef DHD_DEBUG
 static void
@@ -18712,7 +18746,7 @@ void traffic_mgmt_pkt_set_prio(dhd_pub_t *dhdp, void * pktbuf)
 		}
 	}
 }
-#endif 
+#endif
 
 bool dhd_sta_associated(dhd_pub_t *dhdp, uint32 bssidx, uint8 *mac)
 {
@@ -19011,7 +19045,7 @@ void custom_rps_map_clear(struct netdev_rx_queue *queue)
 		DHD_INFO(("%s : rps_cpus map clear.\n", __FUNCTION__));
 	}
 }
-#endif 
+#endif
 
 
 
@@ -19074,18 +19108,18 @@ dhd_linux_get_primary_netdev(dhd_pub_t *dhdp)
 #ifdef DHD_ARP_DUMP
 #define ARP_PRINT(str) \
 	do { \
-		DHD_ERROR(("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s)\n", \
+		printk("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s)\n", \
 			ifname, tx?"TX":"RX", \
 			tx?sabuf:dabuf, tx?seabuf:deabuf, \
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf); \
 	} while (0)
 
 #define ARP_PRINT_OTHER(str) \
 	do { \
-		DHD_ERROR(("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s) op_code=%d\n", \
+		printk("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s) op_code=%d\n", \
 			ifname, tx?"TX":"RX", \
 			tx?sabuf:dabuf, tx?seabuf:deabuf, \
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, opcode)); \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, opcode); \
 	} while (0)
 
 static void
@@ -19235,11 +19269,11 @@ dhd_tcp_dump(char *ifname, uint8 *pktdata, bool tx)
 #ifdef DHD_DHCP_DUMP
 #define DHCP_PRINT(str) \
 	do { \
-		DHD_ERROR(("[dhd-%s] " str " %8s, %8s [%s] : %s(%s) %s %s(%s)\n", \
+		printk("[dhd-%s] " str " %8s, %8s [%s] : %s(%s) %s %s(%s)\n", \
 			ifname, dhcp_types[dhcp_type], dhcp_ops[b->op], \
 			tx?"TX":"RX", \
 			tx?sabuf:dabuf, tx?seabuf:deabuf, \
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf); \
 	} while (0)
 static void
 dhd_dhcp_dump(char *ifname, uint8 *pktdata, bool tx)
@@ -19315,15 +19349,15 @@ dhd_dhcp_dump(char *ifname, uint8 *pktdata, bool tx)
 #define ICMP_ECHO_SEQ(h) (*(uint16 *)((uint8 *)(h) + (ICMP_ECHO_SEQ_OFFSET)))
 #define ICMP_PING_PRINT(str) \
 	do { \
-		DHD_ERROR(("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s) SEQNUM=%d\n", \
+		printk("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s) SEQNUM=%d\n", \
 			ifname, tx?"TX":"RX", tx?sabuf:dabuf, tx?seabuf:deabuf, \
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, seqnum)); \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, seqnum); \
 	} while (0)
 #define ICMP_PRINT(str) \
 	do { \
-		DHD_ERROR(("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s)\n", \
+		printk("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s)\n", \
 			ifname, tx?"TX":"RX", tx?sabuf:dabuf, tx?seabuf:deabuf, \
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf); \
 	} while (0)
 static void
 dhd_icmp_dump(char *ifname, uint8 *pktdata, bool tx)
@@ -20029,6 +20063,29 @@ static struct kobj_type dhd_ktype = {
 	.default_attrs = default_attrs,
 };
 
+#ifdef CSI_SUPPORT
+/* Function to show current ccode */
+static ssize_t read_csi_data(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)
+{
+	dhd_info_t *dhd = to_dhd(kobj);
+	int n = 0;
+
+	n = dhd_csi_dump_list(&dhd->pub, buf);
+	DHD_INFO(("Dump data to file, size %d\n", n));
+	dhd_csi_clean_list(&dhd->pub);
+
+	return n;
+}
+
+static struct bin_attribute dhd_attr_csi = {
+	.attr = { .name = "csi",
+		  .mode = 0660, },
+	.size = MAX_CSI_FILESZ,
+	.read = read_csi_data,
+};
+#endif /* CSI_SUPPORT */
+
 /* Create a kobject and attach to sysfs interface */
 static int dhd_sysfs_init(dhd_info_t *dhd)
 {
@@ -20047,6 +20104,15 @@ static int dhd_sysfs_init(dhd_info_t *dhd)
 		return ret;
 	}
 
+#ifdef CSI_SUPPORT
+	ret = sysfs_create_bin_file(&dhd->dhd_kobj, &dhd_attr_csi);
+	if (ret) {
+		DHD_ERROR(("%s: can't create %s\n", __FUNCTION__, dhd_attr_csi.attr.name));
+		kobject_put(&dhd->dhd_kobj);
+		return ret;
+	}
+#endif /* CSI_SUPPORT */
+
 	/*
 	 * We are always responsible for sending the uevent that the kobject
 	 * was added to the system.
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux_platdev.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux_platdev.c
index 74fa42130f9e..14f0c317eb43 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux_platdev.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_linux_platdev.c
@@ -218,6 +218,10 @@ int wifi_platform_set_power(wifi_adapter_info_t *adapter, bool on, unsigned long
 	}
 	plat_data = adapter->wifi_plat_data;
 
+#ifdef DHD_LOAD_CHIPALIVE
+	if (dhd_chip_alive)
+		msec = 0;
+#endif
 	DHD_PRINT("%s = %d, delay: %lu msec\n", __FUNCTION__, on, msec);
 	if (plat_data->set_power) {
 #ifdef ENABLE_4335BT_WAR
@@ -855,6 +859,9 @@ static int dhd_wifi_platform_load_sdio(void)
 				break;
 			}
 
+#ifdef DHD_LOAD_CHIPALIVE
+			dhd_chip_alive = 0;
+#endif
 			DHD_ERROR(("failed to power up %s, %d retry left\n", adapter->name, retry));
 			dhd_bus_unreg_sdio_notify();
 			wifi_platform_set_power(adapter, FALSE, WIFI_TURNOFF_DELAY);
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie.c
index 6dbd8a6a8131..330507619b9e 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie.c
@@ -1680,7 +1680,7 @@ dhdpcie_download_firmware(struct dhd_bus *bus, osl_t *osh)
 
 	DHD_OS_WAKE_LOCK(bus->dhd);
 
-	dhd_conf_set_path_params(bus->dhd, NULL, bus->fw_path, bus->nv_path);
+	dhd_conf_set_path_params(bus->dhd, bus->fw_path, bus->nv_path);
 	dhd_set_bus_params(bus);
 
 	ret = _dhdpcie_download_firmware(bus);
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie_linux.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie_linux.c
index a7c36fe1ec07..86de3a439b60 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_pcie_linux.c
@@ -1971,7 +1971,7 @@ int dhdpcie_oob_intr_register(dhd_bus_t *bus)
 
 	dhdpcie_osinfo->oob_irq_registered = TRUE;
 
-	return err;
+	return 0;
 }
 
 void dhdpcie_oob_intr_unregister(dhd_bus_t *bus)
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_sdio.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_sdio.c
index 3496d32f95e4..ac3fb703132b 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_sdio.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_sdio.c
@@ -3,13 +3,13 @@
  * DHD Bus Module for SDIO
  *
  * Copyright (C) 1999-2017, Broadcom Corporation
- * 
+ *
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
  * under the terms of the GNU General Public License version 2 (the "GPL"),
  * available at http://www.broadcom.com/licenses/GPLv2.php, with the
  * following added to such license:
- * 
+ *
  *      As a special exception, the copyright holders of this software give you
  * permission to link this software with independent modules, and to copy and
  * distribute the resulting executable under terms of your choice, provided that
@@ -17,7 +17,7 @@
  * the license of that module.  An independent module is a module which is not
  * derived from this software.  The special exception does not apply to any
  * modifications of the software.
- * 
+ *
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
@@ -184,11 +184,8 @@ static int dhdsdio_resume(void *context);
 					PKTFREE(bus->dhd->osh, pkt, FALSE);
 DHD_SPINWAIT_SLEEP_INIT(sdioh_spinwait_sleep);
 
-#ifdef PKT_STATICS
-pkt_statics_t tx_statics = {0};
-#endif
 #ifdef DHD_LOAD_CHIPALIVE
-uint dhd_chip_alive = 0;
+uint dhd_chip_alive = 1;
 module_param(dhd_chip_alive, uint, 0);
 void dhdsdio_isr(void *arg);
 #endif
@@ -451,6 +448,9 @@ typedef struct dhd_bus {
 #endif /* defined (BT_OVER_SDIO) */
 	uint		txglomframes;	/* Number of tx glom frames (superframes) */
 	uint		txglompkts;		/* Number of packets from tx glom frames */
+#ifdef PKT_STATICS
+	struct pkt_statics tx_statics;
+#endif
 	uint8		*membuf;		/* Buffer for dhdsdio_membytes */
 #ifdef CONSOLE_DPC
 	char		cons_cmd[16];
@@ -1143,7 +1143,6 @@ dhdsdio_clk_kso_disable(dhd_bus_t *bus)
 	//mmc_retune_disable(host);
 
 	KSO_DBG(("%s> op:%s\n", __FUNCTION__, (on ? "KSO_SET" : "KSO_CLR")));
-	pr_err("%s> op:%s\n", __FUNCTION__, "KSO_CLR");
 
 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
 
@@ -1156,8 +1155,8 @@ dhdsdio_clk_kso_disable(dhd_bus_t *bus)
 		cmp_val = 0;
 		bmask = SBSDIO_FUNC1_SLEEPCSR_KSO_MASK;
 		if (((rd_val & bmask) == cmp_val) && !err) {
-			DHD_ERROR(("[%s]: rd_val=%d, err=%d, try_cnt=%d, max=%d\n", __func__,
-						(rd_val & bmask), err, try_cnt, KSO_CLR_RETRY));
+			//DHD_ERROR(("[%s]: rd_val=%d, err=%d, try_cnt=%d, max=%d\n", __func__,
+			//			(rd_val & bmask), err, try_cnt, KSO_CLR_RETRY));
 			break;
 		}
 		wr_val = 0;
@@ -1166,7 +1165,8 @@ dhdsdio_clk_kso_disable(dhd_bus_t *bus)
 	} while (try_cnt++ < KSO_CLR_RETRY);
 
 	if (err || (try_cnt >= KSO_CLR_RETRY))
-		DHD_ERROR(("%s KSO_CLR over retry, err %d\n", __func__, err));
+		DHD_ERROR(("%s KSO_CLR over retry, err %d, KSO_CLR_WAIT_MS=%d, KSO_CLR_RETRY=%d\n",
+			__func__, err, KSO_CLR_WAIT_MS, KSO_CLR_RETRY));
 
 	//mmc_retune_enable(host);
 	return err;
@@ -2038,11 +2038,9 @@ dhdsdio_bussleep1(dhd_bus_t *bus, bool sleep)
 			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
 				devctl, NULL);
 #endif
-
 			/* Leave interrupts enabled since device can exit sleep and
 			 * interrupt host
 			 */
-
 			if (bus->sih->chip == BCM43012_CHIP_ID) {
 				err = dhdsdio_clk_devsleep1(bus);
 			} else {
@@ -2260,7 +2258,7 @@ dhd_enable_oob_intr(struct dhd_bus *bus, bool enable)
 	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
 #endif /* !defined(HW_OOB) */
 }
-#endif 
+#endif
 
 int
 dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
@@ -2472,24 +2470,24 @@ static int dhdsdio_txpkt_preprocess(dhd_bus_t *bus, void *pkt, int chan, int txs
 	len = (uint16)PKTLEN(osh, pkt);
 	switch(chan) {
 		case SDPCM_CONTROL_CHANNEL:
-			tx_statics.ctrl_count++;
-			tx_statics.ctrl_size += len;
+			bus->tx_statics.ctrl_count++;
+			bus->tx_statics.ctrl_size += len;
 			break;
 		case SDPCM_DATA_CHANNEL:
-			tx_statics.data_count++;
-			tx_statics.data_size += len;
+			bus->tx_statics.data_count++;
+			bus->tx_statics.data_size += len;
 			break;
 		case SDPCM_GLOM_CHANNEL:
-			tx_statics.glom_count++;
-			tx_statics.glom_size += len;
+			bus->tx_statics.glom_count++;
+			bus->tx_statics.glom_size += len;
 			break;
 		case SDPCM_EVENT_CHANNEL:
-			tx_statics.event_count++;
-			tx_statics.event_size += len;
+			bus->tx_statics.event_count++;
+			bus->tx_statics.event_size += len;
 			break;
 		case SDPCM_TEST_CHANNEL:
-			tx_statics.test_count++;
-			tx_statics.test_size += len;
+			bus->tx_statics.test_count++;
+			bus->tx_statics.test_size += len;
 			break;
 
 		default:
@@ -2667,14 +2665,14 @@ static int dhdsdio_txpkt_preprocess(dhd_bus_t *bus, void *pkt, int chan, int txs
 			real_pad = pkt_len - act_len;
 
 			if (PKTTAILROOM(osh, pkt) < real_pad) {
-				DHD_INFO(("%s : insufficient tailroom %d for %d real_pad\n", 
+				DHD_INFO(("%s : insufficient tailroom %d for %d real_pad\n",
 					__func__, (int)PKTTAILROOM(osh, pkt), real_pad));
 				if (PKTPADTAILROOM(osh, pkt, real_pad)) {
 					DHD_ERROR(("CHK1: padding error size %d\n", real_pad));
 				} else
 					frame = (uint8 *)PKTDATA(osh, pkt);
 			}
-		} else 
+		} else
 #endif
 		{
 			swhdr_offset += SDPCM_HWEXT_LEN;
@@ -2824,10 +2822,21 @@ static int dhdsdio_txpkt(dhd_bus_t *bus, uint chan, void** pkts, int num_pkt, bo
 	 * so it will take the aligned length and buffer pointer.
 	 */
 	pkt_chain = PKTNEXT(osh, head_pkt) ? head_pkt : NULL;
+#ifdef HOST_TPUT_TEST
+	if ((bus->dhd->conf->data_drop_mode == TXPKT_DROP) && (total_len > 500)) {
+		ret = BCME_OK;
+	} else {
+		ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
+			PKTDATA(osh, head_pkt), total_len, pkt_chain, NULL, NULL, TXRETRIES);
+		if (ret == BCME_OK)
+			bus->tx_seq = (bus->tx_seq + num_pkt) % SDPCM_SEQUENCE_WRAP;
+	}
+#else
 	ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
 		PKTDATA(osh, head_pkt), total_len, pkt_chain, NULL, NULL, TXRETRIES);
 	if (ret == BCME_OK)
 		bus->tx_seq = (bus->tx_seq + num_pkt) % SDPCM_SEQUENCE_WRAP;
+#endif
 
 	/* if a padding packet was needed, remove it from the link list as it not a data pkt */
 	if (pad_pkt_len && pkt)
@@ -2877,7 +2886,6 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 	uint32 intstatus = 0;
 	uint retries = 0;
 	osl_t *osh;
-	uint datalen = 0;
 	dhd_pub_t *dhd = bus->dhd;
 	sdpcmd_regs_t *regs = bus->regs;
 #ifdef DHD_LOSSLESS_ROAMING
@@ -2902,6 +2910,7 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 		int num_pkt = 1;
 		void *pkts[MAX_TX_PKTCHAIN_CNT];
 		int prec_out;
+		uint datalen = 0;
 
 		dhd_os_sdlock_txq(bus->dhd);
 		if (bus->txglom_enable) {
@@ -2953,13 +2962,18 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 			dhd->dstats.tx_bytes += datalen;
 			bus->txglomframes++;
 			bus->txglompkts += num_pkt;
+#ifdef PKT_STATICS
+			bus->tx_statics.glom_cnt_us[num_pkt-1] =
+				(bus->tx_statics.glom_cnt[num_pkt-1]*bus->tx_statics.glom_cnt_us[num_pkt-1]
+				+ bcmsdh_get_spend_time(bus->sdh))/(bus->tx_statics.glom_cnt[num_pkt-1] + 1);
+#endif
 		}
 		cnt += i;
 #ifdef PKT_STATICS
 		if (num_pkt) {
-			tx_statics.glom_cnt[num_pkt-1]++;
-			if (num_pkt > tx_statics.glom_max)
-				tx_statics.glom_max = num_pkt;
+			bus->tx_statics.glom_cnt[num_pkt-1]++;
+			if (num_pkt > bus->tx_statics.glom_max)
+				bus->tx_statics.glom_max = num_pkt;
 		}
 #endif
 
@@ -3190,8 +3204,8 @@ dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 		}
 #endif
 #ifdef PKT_STATICS
-		tx_statics.ctrl_count++;
-		tx_statics.ctrl_size += len;
+		bus->tx_statics.ctrl_count++;
+		bus->tx_statics.ctrl_size += len;
 #endif
 		ret = dhd_bcmsdh_send_buffer(bus, frame, len);
 	}
@@ -3823,6 +3837,27 @@ dhdsdio_readshared(dhd_bus_t *bus, sdpcm_shared_t *sh)
 	}
 #endif /* BCMSDIO_RXLIM_POST */
 
+#ifdef BCMSDIO_TXSEQ_SYNC
+	if (dhd_chip_alive && bus->dhd->conf->txseq_sync) {
+		sh->txseq_sync_addr = ltoh32(sh->txseq_sync_addr);
+		if (sh->flags & SDPCM_SHARED_TXSEQ_SYNC) {
+			uint8 val = 0;
+			DHD_INFO(("%s: TXSEQ_SYNC enabled in fw\n", __FUNCTION__));
+			if (0 == dhdsdio_membytes(bus, FALSE, sh->txseq_sync_addr, (uint8 *)&val, 1)) {
+				if (bus->tx_seq != val) {
+					DHD_INFO(("%s: Sync tx_seq from %d to %d\n",
+						__FUNCTION__, bus->tx_seq, val));
+					bus->tx_seq = val;
+					bus->tx_max = bus->tx_seq + 4;
+				}
+			}
+			sh->flags &= ~SDPCM_SHARED_TXSEQ_SYNC;
+		} else {
+			bus->dhd->conf->txseq_sync = FALSE;
+		}
+	}
+#endif /* BCMSDIO_TXSEQ_SYNC */
+
 	if ((sh->flags & SDPCM_SHARED_VERSION_MASK) == 3 && SDPCM_SHARED_VERSION == 1)
 		return BCME_OK;
 
@@ -4288,7 +4323,7 @@ dhd_serialconsole(dhd_bus_t *bus, bool set, bool enable, int *bcmerror)
 
 	return (int_val & uart_enab);
 }
-#endif 
+#endif
 
 static int
 dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const char *name,
@@ -4680,7 +4715,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
 			((uint8)mesbusyctrl | 0x80), NULL);
 		break;
-#endif 
+#endif
 
 
 	case IOV_GVAL(IOV_DONGLEISOLATION):
@@ -4875,7 +4910,11 @@ dhdsdio_write_vars(dhd_bus_t *bus)
 		MFREE(bus->dhd->osh, vbuffer, varsize);
 	}
 
+#ifdef MINIME
+	phys_size = bus->ramsize;
+#else
 	phys_size = REMAP_ENAB(bus) ? bus->ramsize : bus->orig_ramsize;
+#endif
 
 	phys_size += bus->dongle_ram_base;
 
@@ -7356,42 +7395,69 @@ dhdsdio_isr(void *arg)
 }
 
 #ifdef PKT_STATICS
-void dhdsdio_txpktstatics(void)
+void dhd_bus_dump_txpktstatics(struct dhd_bus *bus)
 {
-	uint i, total = 0;
+	uint i;
+	uint32 total = 0;
 
 	printf("%s: TYPE EVENT: %d pkts (size=%d) transfered\n",
-		__FUNCTION__, tx_statics.event_count, tx_statics.event_size);
+		__FUNCTION__, bus->tx_statics.event_count, bus->tx_statics.event_size);
 	printf("%s: TYPE CTRL:  %d pkts (size=%d) transfered\n",
-		__FUNCTION__, tx_statics.ctrl_count, tx_statics.ctrl_size);
+		__FUNCTION__, bus->tx_statics.ctrl_count, bus->tx_statics.ctrl_size);
 	printf("%s: TYPE DATA:  %d pkts (size=%d) transfered\n",
-		__FUNCTION__, tx_statics.data_count, tx_statics.data_size);
+		__FUNCTION__, bus->tx_statics.data_count, bus->tx_statics.data_size);
 	printf("%s: Glom size distribution:\n", __FUNCTION__);
-	for (i=0;i<tx_statics.glom_max;i++) {
-		total += tx_statics.glom_cnt[i];
+	for (i=0;i<bus->tx_statics.glom_max;i++) {
+		total += bus->tx_statics.glom_cnt[i];
 	}
-	for (i=0;i<tx_statics.glom_max;i++) {
-		printf("%02d: %d", i+1, tx_statics.glom_cnt[i]);
+	printk(KERN_CONT "[dhd] ");
+	for (i=0;i<bus->tx_statics.glom_max;i++) {
+		printk(KERN_CONT "%02d: %5d", i+1, bus->tx_statics.glom_cnt[i]);
 		if ((i+1)%8)
-			printf(", ");
-		else
-			printf("\n");
+			printk(KERN_CONT ", ");
+		else {
+			printk("\n");
+			printk(KERN_CONT "[dhd] ");
+		}
+ 	}
+	printk("\n");
+	printk(KERN_CONT "[dhd] ");
+	for (i=0;i<bus->tx_statics.glom_max;i++) {
+		printk(KERN_CONT "%02d:%5d%%", i+1, (bus->tx_statics.glom_cnt[i]*100)/total);
+		if ((i+1)%8)
+			printk(KERN_CONT ", ");
+		else {
+			printk("\n");
+			printk(KERN_CONT "[dhd] ");
+		}
 	}
-	printf("\n");
-	for (i=0;i<tx_statics.glom_max;i++) {
-		printf("%02d:%3d%%", i+1, (tx_statics.glom_cnt[i]*100)/total);
+	printk("\n");
+	printf("%s: Glom spend time distribution(us):\n", __FUNCTION__);
+	printk(KERN_CONT "[dhd] ");
+	for (i=0;i<bus->tx_statics.glom_max;i++) {
+		printk(KERN_CONT "%02d: %5u", i+1, bus->tx_statics.glom_cnt_us[i]);
 		if ((i+1)%8)
-			printf(", ");
-		else
-			printf("\n");
+			printk(KERN_CONT ", ");
+		else {
+			printk("\n");
+			printk(KERN_CONT "[dhd] ");
+		}
+ 	}
+	printk("\n");
+	if (total) {
+		printf("%s: data(%d)/glom(%d)=%d, glom_max=%d\n",
+			__FUNCTION__, bus->tx_statics.data_count, total,
+			bus->tx_statics.data_count/total, bus->tx_statics.glom_max);
 	}
-	printf("\n");
-	printf("%s: data/glom=%d, glom_max=%d\n",
-		__FUNCTION__, tx_statics.data_count/total, tx_statics.glom_max);
 	printf("%s: TYPE RX GLOM: %d pkts (size=%d) transfered\n",
-		__FUNCTION__, tx_statics.glom_count, tx_statics.glom_size);
-	printf("%s: TYPE TEST: %d pkts (size=%d) transfered\n\n\n",
-		__FUNCTION__, tx_statics.test_count, tx_statics.test_size);
+		__FUNCTION__, bus->tx_statics.glom_count, bus->tx_statics.glom_size);
+	printf("%s: TYPE TEST: %d pkts (size=%d) transfered\n",
+		__FUNCTION__, bus->tx_statics.test_count, bus->tx_statics.test_size);
+}
+
+void dhd_bus_clear_txpktstatics(struct dhd_bus *bus)
+{
+	memset((uint8*) &bus->tx_statics, 0, sizeof(pkt_statics_t));
 }
 #endif
 
@@ -8791,7 +8857,7 @@ dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
 	bus->dotxinrx = TRUE;
 
 #ifdef PKT_STATICS
-	memset((uint8*) &tx_statics, 0, sizeof(pkt_statics_t));
+	dhd_bus_clear_txpktstatics(bus);
 #endif
 
 	return TRUE;
@@ -8832,6 +8898,12 @@ dhd_set_bus_params(struct dhd_bus *bus)
 	if (bus->dhd->conf->txglomsize >= 0) {
 		bus->txglomsize = bus->dhd->conf->txglomsize;
 	}
+#ifdef MINIME
+	if (bus->dhd->conf->fw_type == FW_TYPE_MINIME) {
+		bus->ramsize = bus->dhd->conf->ramsize;
+		printf("%s: set ramsize 0x%x\n", __FUNCTION__, bus->ramsize);
+	}
+#endif
 }
 
 static int
@@ -9095,7 +9167,7 @@ dhdsdio_resume(void *context)
 #if defined(OOB_INTR_ONLY)
 	if (dhd_os_check_if_up(bus->dhd))
 		bcmsdh_oob_intr_set(bus->sdh, TRUE);
-#endif 
+#endif
 
 	DHD_LINUX_GENERAL_LOCK(bus->dhd, flags);
 	DHD_BUS_BUSY_CLEAR_RESUME_IN_PROGRESS(bus->dhd);
@@ -9819,7 +9891,7 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 			dhd_enable_oob_intr(bus, FALSE);
 			bcmsdh_oob_intr_set(bus->sdh, FALSE);
 			bcmsdh_oob_intr_unregister(bus->sdh);
-#endif 
+#endif
 
 			/* Clean tx/rx buffer pointers, detach from the dongle */
 			dhdsdio_release_dongle(bus, bus->dhd->osh, TRUE, TRUE);
@@ -9870,7 +9942,7 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 						bcmsdh_oob_intr_set(bus->sdh, TRUE);
 #elif defined(FORCE_WOWLAN)
 						dhd_enable_oob_intr(bus, TRUE);
-#endif 
+#endif
 
 						bus->dhd->dongle_reset = FALSE;
 						bus->dhd->up = TRUE;
@@ -9878,7 +9950,7 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 #if !defined(IGNORE_ETH0_DOWN)
 						/* Restore flow control  */
 						dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, OFF);
-#endif 
+#endif
 						dhd_os_wd_timer(dhdp, dhd_watchdog_ms);
 
 						DHD_TRACE(("%s: WLAN ON DONE\n", __FUNCTION__));
@@ -9915,7 +9987,7 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 	}
 
 #ifdef PKT_STATICS
-	memset((uint8*) &tx_statics, 0, sizeof(pkt_statics_t));
+	dhd_bus_clear_txpktstatics(bus);
 #endif
 	return bcmerror;
 }
@@ -10497,7 +10569,7 @@ dhd_bus_ulp_reinit_fw(dhd_bus_t *bus)
 #if defined(OOB_INTR_ONLY)
 			dhd_enable_oob_intr(bus, TRUE);
 			bcmsdh_oob_intr_set(bus->sdh, TRUE);
-#endif 
+#endif
 #ifdef DHD_DEBUG
 		/* Re-enable the console messages on FW redownload to default value */
 		dhd_ulp_restore_console_interval(bus->dhd);
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.c
index 9ee9890ca505..4936285b7d73 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.c
@@ -43,6 +43,7 @@
 
 #include <dhd_dbg.h>
 #include <dhd_config.h>
+#include <wl_android.h>
 
 #ifdef PROP_TXSTATUS /* a form of flow control between host and dongle */
 #include <wlfc_proto.h>
@@ -1322,6 +1323,9 @@ _dhd_wlfc_deque_delayedq(athost_wl_status_info_t* ctx, int prec,
 		ASSERT(entry);
 
 		if (entry->occupied && _dhd_wlfc_is_destination_open(ctx, entry, prec) &&
+#ifdef PROPTX_MAXCOUNT
+			(entry->transit_count < entry->transit_maxcount) &&
+#endif /* PROPTX_MAXCOUNT */
 			(entry->transit_count < WL_TXSTATUS_FREERUNCTR_MASK) &&
 			(!entry->suppressed)) {
 			*ac_credit_spent = credit_spent;
@@ -1823,6 +1827,9 @@ _dhd_wlfc_mac_entry_update(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t*
 		if (action == eWLFC_MAC_ENTRY_ACTION_ADD) {
 			entry->suppressed = FALSE;
 			entry->transit_count = 0;
+#ifdef PROPTX_MAXCOUNT
+			entry->transit_maxcount = wl_ext_get_wlfc_maxcount(ctx->dhdp, ifid);
+#endif /* PROPTX_MAXCOUNT */
 			entry->suppr_transit_count = 0;
 			entry->onbus_pkts_count = 0;
 		}
@@ -4629,4 +4636,36 @@ int dhd_wlfc_set_rxpkt_chk(dhd_pub_t *dhd, int val)
 	return BCME_OK;
 }
 
+#ifdef PROPTX_MAXCOUNT
+int dhd_wlfc_update_maxcount(dhd_pub_t *dhdp, uint8 ifid, int maxcount)
+{
+	athost_wl_status_info_t* ctx;
+	int rc = 0;
+
+	if (dhdp == NULL) {
+		DHD_ERROR(("%s: dhdp is NULL\n", __FUNCTION__));
+		return BCME_BADARG;
+	}
+
+	dhd_os_wlfc_block(dhdp);
+
+	if (!dhdp->wlfc_state || (dhdp->proptxstatus_mode == WLFC_FCMODE_NONE)) {
+		rc = WLFC_UNSUPPORTED;
+		goto exit;
+	}
+
+	if (ifid >= WLFC_MAX_IFNUM) {
+		DHD_ERROR(("%s: bad ifid\n", __FUNCTION__));
+		rc = BCME_BADARG;
+		goto exit;
+	}
+
+	ctx = (athost_wl_status_info_t*)dhdp->wlfc_state;
+	ctx->destination_entries.interfaces[ifid].transit_maxcount = maxcount;
+exit:
+	dhd_os_wlfc_unblock(dhdp);
+	return rc;
+}
+#endif /* PROPTX_MAXCOUNT */
+
 #endif /* PROP_TXSTATUS */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.h
index 5ba54cb618f6..70be6e157419 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/dhd_wlfc.h
@@ -169,6 +169,10 @@ typedef struct wlfc_mac_descriptor {
 	uint32 opened_ct;
 	uint32 closed_ct;
 #endif
+#ifdef PROPTX_MAXCOUNT
+	/** Max Number of packets at dongle for this entry. */
+	int transit_maxcount;
+#endif /* PROPTX_MAXCOUNT */
 	struct wlfc_mac_descriptor* prev;
 	struct wlfc_mac_descriptor* next;
 } wlfc_mac_descriptor_t;
@@ -559,5 +563,8 @@ int dhd_wlfc_set_txstatus_ignore(dhd_pub_t *dhd, int val);
 
 int dhd_wlfc_get_rxpkt_chk(dhd_pub_t *dhd, int *val);
 int dhd_wlfc_set_rxpkt_chk(dhd_pub_t *dhd, int val);
+#ifdef PROPTX_MAXCOUNT
+int dhd_wlfc_update_maxcount(dhd_pub_t *dhdp, uint8 ifid, int maxcount);
+#endif /* PROPTX_MAXCOUNT */
 
 #endif /* __wlfc_host_driver_definitions_h__ */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmevent.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmevent.h
index 8034cd8b701a..a7b6f34a631d 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmevent.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmevent.h
@@ -176,7 +176,11 @@ typedef union bcm_event_msg_u {
 #define WLC_E_ACTION_FRAME_COMPLETE	60	/* Action frame Tx complete */
 #define WLC_E_PRE_ASSOC_IND	61	/* assoc request received */
 #define WLC_E_PRE_REASSOC_IND	62	/* re-assoc request received */
+#ifdef CSI_SUPPORT
+#define WLC_E_CSI		63
+#else
 #define WLC_E_CHANNEL_ADOPTED	63
+#endif /* CSI_SUPPORT */
 #define WLC_E_AP_STARTED	64	/* AP started */
 #define WLC_E_DFS_AP_STOP	65	/* AP stopped due to DFS */
 #define WLC_E_DFS_AP_RESUME	66	/* AP resumed due to DFS */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdbus.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdbus.h
index 930f5cb8151b..7bd18e48e40d 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdbus.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdbus.h
@@ -90,6 +90,7 @@ typedef struct pkt_statics {
 	uint32	glom_size;
 	uint16	test_count;
 	uint32	test_size;
+	uint32	glom_cnt_us[SDPCM_MAXGLOM_SIZE];
 } pkt_statics_t;
 #endif
 
@@ -170,6 +171,9 @@ extern bool sdioh_gpioin(sdioh_info_t *sd, uint32 gpio);
 extern SDIOH_API_RC sdioh_gpioouten(sdioh_info_t *sd, uint32 gpio);
 extern SDIOH_API_RC sdioh_gpioout(sdioh_info_t *sd, uint32 gpio, bool enab);
 extern uint sdioh_set_mode(sdioh_info_t *sd, uint mode);
+#ifdef PKT_STATICS
+extern uint32 sdioh_get_spend_time(sdioh_info_t *sd);
+#endif
 #ifdef DHD_LOAD_CHIPALIVE
 extern bool sdioh_get_sdmmc_sleep(sdioh_info_t *sd);
 extern void sdioh_set_sdmmc_sleep(sdioh_info_t *sd, bool sleep);
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh.h
index a05047e6b8e6..8d25c086c26e 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh.h
@@ -173,6 +173,9 @@ extern bool bcmsdh_get_sdmmc_sleep(void *sdh);
 extern void bcmsdh_set_sdmmc_sleep(void *sdh, bool sleep);
 #endif
 extern bool bcmsdh_glom_enabled(void);
+#ifdef PKT_STATICS
+extern uint32 bcmsdh_get_spend_time(void *sdh) ;
+#endif
 /* Flags bits */
 #define SDIO_REQ_4BYTE	0x1	/* Four-byte target (backplane) width (vs. two-byte) */
 #define SDIO_REQ_FIXED	0x2	/* Fixed address (FIFO) (vs. incrementing address) */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh_sdmmc.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh_sdmmc.h
index 33674a1ee52b..dc95dbcc0ee9 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh_sdmmc.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdh_sdmmc.h
@@ -88,6 +88,7 @@ struct sdioh_info {
 	struct sdio_func	*func[SDIOD_MAX_IOFUNCS];
 	uint		sd_clk_rate;
 	uint	txglom_mode;		/* Txglom mode: 0 - copy, 1 - multi-descriptor */
+	uint32	sdio_spent_time_us;
 #ifdef DHD_LOAD_CHIPALIVE
 	bool sdmmc_sleep;
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdpcm.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdpcm.h
index 62fce268cd54..537ebbff810d 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdpcm.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmsdpcm.h
@@ -285,6 +285,7 @@ typedef volatile struct {
 #define SDPCM_SHARED_PENDING_BRPT  0x2000
 #define SDPCM_SHARED_FATAL_LOGBUF_VALID	0x100000
 #define SDPCM_SHARED_RXLIM_POST    0x4000
+#define SDPCM_SHARED_TXSEQ_SYNC    0x4000
 
 typedef struct {
 	uint32	flags;
@@ -296,6 +297,9 @@ typedef struct {
 	uint32  msgtrace_addr;
 	uint32  fwid;
 	uint32  device_fatal_logbuf_start;
+#ifdef BCMSDIO_TXSEQ_SYNC
+	uint32	txseq_sync_addr;
+#endif /* TXSEQ_SYNC */
 } sdpcm_shared_t;
 
 extern sdpcm_shared_t sdpcm_shared;
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmstdlib_s.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmstdlib_s.h
new file mode 100644
index 000000000000..2d4abbcb82fc
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/bcmstdlib_s.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Broadcom Secure Standard Library.
+ *
+ * Copyright (C) 1999-2019, Broadcom.
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ *
+ * <<Broadcom-WL-IPTag/Open:>>
+ *
+ * * $Id $
+ */
+
+#ifndef	_bcmstdlib_s_h_
+#define	_bcmstdlib_s_h_
+
+#ifndef BWL_NO_INTERNAL_STDLIB_SUPPORT
+#if !defined(__STDC_WANT_SECURE_LIB__) && !(defined(__STDC_LIB_EXT1__) && \
+	defined(__STDC_WANT_LIB_EXT1__))
+extern int memmove_s(void *dest, size_t destsz, const void *src, size_t n);
+extern int memcpy_s(void *dest, size_t destsz, const void *src, size_t n);
+extern int memset_s(void *dest, size_t destsz, int c, size_t n);
+#endif /* !__STDC_WANT_SECURE_LIB__ && !(__STDC_LIB_EXT1__ && __STDC_WANT_LIB_EXT1__) */
+#if !defined(FREEBSD) && !defined(BCM_USE_PLATFORM_STRLCPY)
+extern size_t strlcpy(char *dest, const char *src, size_t size);
+#endif // endif
+extern size_t strlcat_s(char *dest, const char *src, size_t size);
+#endif /* !BWL_NO_INTERNAL_STDLIB_SUPPORT */
+#endif /* _bcmstdlib_s_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/dbus.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/dbus.h
index d33e96dd3045..7fcc53f3c231 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/dbus.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/dbus.h
@@ -288,7 +288,7 @@ typedef struct dbus_pub {
 	int ntxq, nrxq, rxsize;
 	void *bus;
 	struct shared_info *sh;
-    void *dev_info;
+	void *dev_info;
 } dbus_pub_t;
 
 #define BUS_INFO(bus, type) (((type *) bus)->pub->bus)
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/epivers.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/epivers.h
index e6d7e8486d11..f11cb6fd701e 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/epivers.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/epivers.h
@@ -47,6 +47,6 @@
 #define EPI_VERSION_DEV		1.579.77.41
 
 /* Driver Version String, ASCII, 32 chars max */
-#define	EPI_VERSION_STR		"1.579.77.41.26 (r-20200429-2.3)(20200909-1)"
+#define	EPI_VERSION_STR		"1.579.77.41.28 (r-20200910-1)(20201119-1)"
 
 #endif /* _epivers_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/linux_osl.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/linux_osl.h
index 89238c12c9ed..6969e9b88510 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/linux_osl.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/linux_osl.h
@@ -1174,5 +1174,5 @@ typedef struct osl_timespec {
 } osl_timespec_t;
 extern void osl_do_gettimeofday(struct osl_timespec *ts);
 extern void osl_get_monotonic_boottime(struct osl_timespec *ts);
-
+extern uint32 osl_do_gettimediff(struct osl_timespec *cur_ts, struct osl_timespec *old_ts);
 #endif	/* _linux_osl_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/usbrdl.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/usbrdl.h
index bce6fe814400..f15fbd697cea 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/usbrdl.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/usbrdl.h
@@ -1,5 +1,4 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Broadcom USB remote download definitions
  *
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl.h
index c09043f3475f..1e42a5ab893c 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl.h
@@ -1112,15 +1112,85 @@ typedef struct wl_auth_event {
 
 #define WL_AUTH_EVENT_FIXED_LEN_V1	OFFSETOF(wl_auth_event_t, xtlvs)
 
-typedef struct _pmkid {
+#define WL_PMKSA_EVENT_DATA_V1	1u
+
+/* tlv ids for PMKSA event */
+#define WL_PMK_TLV_ID		1u
+#define WL_PMKID_TLV_ID		2u
+#define WL_PEER_ADDR_TLV_ID	3u
+
+/* PMKSA event data structure */
+typedef struct wl_pmksa_event {
+	uint16 version;
+	uint16 length;
+	uint8 xtlvs[];
+} wl_pmksa_event_t;
+
+#define WL_PMKSA_EVENT_FIXED_LEN_V1	OFFSETOF(wl_pmksa_event_t, xtlvs)
+
+#define FILS_CACHE_ID_LEN	2u
+#define PMK_LEN_MAX		48u
+
+typedef struct _pmkid_v1 {
 	struct ether_addr	BSSID;
-	uint8			PMKID[WPA2_PMKID_LEN];
-} pmkid_t;
+	uint8				PMKID[WPA2_PMKID_LEN];
+} pmkid_v1_t;
 
-typedef struct _pmkid_list {
+#define PMKID_ELEM_V2_LENGTH (sizeof(struct ether_addr) + WPA2_PMKID_LEN + PMK_LEN_MAX + \
+	sizeof(ssid_info_t) + FILS_CACHE_ID_LEN)
+
+typedef struct _pmkid_v2 {
+	uint16				length; /* Should match PMKID_ELEM_VX_LENGTH */
+	struct ether_addr	BSSID;
+	uint8				PMKID[WPA2_PMKID_LEN];
+	uint8				pmk[PMK_LEN_MAX]; /* for FILS key deriviation */
+	uint16				pmk_len;
+	ssid_info_t			ssid;
+	uint8				fils_cache_id[FILS_CACHE_ID_LEN];
+} pmkid_v2_t;
+
+#define PMKID_LIST_VER_2	2
+
+typedef struct _pmkid_v3 {
+	struct ether_addr	bssid;
+	uint8			pmkid[WPA2_PMKID_LEN];
+	uint8			pmkid_len;
+	uint8			pmk[PMK_LEN_MAX];
+	uint8			pmk_len;
+	uint16			fils_cache_id; /* 2-byte length */
+	uint8			pad;
+	uint8			ssid_len;
+	uint8			ssid[DOT11_MAX_SSID_LEN]; /* For FILS, to save ESSID */
+							  /* one pmkid used in whole ESS */
+	uint32			time_left; /* remaining time until expirary in sec. */
+					   /* 0 means expired, all 0xFF means never expire */
+} pmkid_v3_t;
+
+#define PMKID_LIST_VER_3	3
+typedef struct _pmkid_list_v1 {
 	uint32	npmkid;
-	pmkid_t	pmkid[1];
-} pmkid_list_t;
+	pmkid_v1_t	pmkid[1];
+} pmkid_list_v1_t;
+
+typedef struct _pmkid_list_v2 {
+	uint16  version;
+	uint16	length;
+	pmkid_v2_t	pmkid[1];
+} pmkid_list_v2_t;
+
+typedef struct _pmkid_list_v3 {
+	uint16		version;
+	uint16		length;
+	uint16		count;
+	uint16          pad;
+	pmkid_v3_t	pmkid[];
+} pmkid_list_v3_t;
+
+#ifndef PMKID_VERSION_ENABLED
+/* pmkid structure before versioning. legacy. DONOT update anymore here */
+typedef pmkid_v1_t pmkid_t;
+typedef pmkid_list_v1_t pmkid_list_t;
+#endif /* PMKID_VERSION_ENABLED */
 
 typedef struct _pmkid_cand {
 	struct ether_addr	BSSID;
@@ -13826,4 +13896,11 @@ typedef struct csa_event_data {
 	uint8 PAD;
 } csa_event_data_t;
 
+typedef struct wl_ext_auth_evt {
+	wlc_ssid_t ssid;
+	struct ether_addr bssid;
+	unsigned int key_mgmt_suite;
+	int status;
+} wl_ext_auth_evt_t;
+
 #endif /* _wlioctl_h_ */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl_defs.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl_defs.h
index b1c2c6b0bf24..2ddacdbb92fc 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl_defs.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/include/wlioctl_defs.h
@@ -861,7 +861,8 @@
 #define WLC_GET_RSSI_QDB			321 /* qdB portion of the RSSI */
 #define WLC_DUMP_RATESET			322
 #define WLC_ECHO				323
-#define WLC_LAST				324
+#define WLC_SCB_AUTHENTICATE	325
+#define WLC_LAST				326
 #define WLC_SPEC_FLAG			0x80000000 /* For some special IOCTL */
 #ifndef EPICTRL_COOKIE
 #define EPICTRL_COOKIE		0xABADCEDE
@@ -924,6 +925,7 @@
 #define WL_AUTH_OPEN_SYSTEM		0	/* d11 open authentication */
 #define WL_AUTH_SHARED_KEY		1	/* d11 shared authentication */
 #define WL_AUTH_OPEN_SHARED		2	/* try open, then shared if open failed w/rc 13 */
+#define WL_AUTH_SAE_KEY			3	/* d11 sae authentication */
 
 /* a large TX Power as an init value to factor out of MIN() calculations,
  * keep low enough to fit in an int8, units are .25 dBm
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/linux_osl.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/linux_osl.c
index b85bc6914c1a..60dcef346577 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/linux_osl.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/linux_osl.c
@@ -2816,6 +2816,19 @@ osl_do_gettimeofday(struct osl_timespec *ts)
 	ts->tv_sec = curtime.tv_sec;
 }
 
+uint32
+osl_do_gettimediff(struct osl_timespec *cur_ts, struct osl_timespec *old_ts)
+{
+	uint32 diff_s, diff_us, total_diff_us;
+	bool pgc_g = FALSE;
+
+	diff_s = (uint32)cur_ts->tv_sec - (uint32)old_ts->tv_sec;
+	pgc_g = (cur_ts->tv_usec > old_ts->tv_usec) ? TRUE : FALSE;
+	diff_us = pgc_g ? (cur_ts->tv_usec - old_ts->tv_usec) : (old_ts->tv_usec - cur_ts->tv_usec);
+	total_diff_us = pgc_g ? (diff_s * 1000000 + diff_us) : (diff_s * 1000000 - diff_us);
+	return total_diff_us;
+}
+
 void
 osl_get_monotonic_boottime(struct osl_timespec *ts)
 {
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android.h
index 1b25d762dfe7..ea5f424d22fe 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android.h
@@ -122,6 +122,10 @@ int wl_ext_iapsta_attach_netdev(struct net_device *net, int ifidx, uint8 bssidx)
 int wl_ext_iapsta_attach_name(struct net_device *net, int ifidx);
 int wl_ext_iapsta_dettach_netdev(struct net_device *net, int ifidx);
 int wl_ext_iapsta_update_net_device(struct net_device *net, int ifidx);
+#ifdef PROPTX_MAXCOUNT
+void wl_ext_update_wlfc_maxcount(struct dhd_pub *dhd);
+int wl_ext_get_wlfc_maxcount(struct dhd_pub *dhd, int ifidx);
+#endif /* PROPTX_MAXCOUNT */
 int wl_ext_iapsta_alive_preinit(struct net_device *dev);
 int wl_ext_iapsta_alive_postinit(struct net_device *dev);
 int wl_ext_iapsta_attach(dhd_pub_t *pub);
@@ -129,6 +133,7 @@ void wl_ext_iapsta_dettach(dhd_pub_t *pub);
 #ifdef WL_CFG80211
 u32 wl_ext_iapsta_update_channel(dhd_pub_t *dhd, struct net_device *dev, u32 channel);
 void wl_ext_iapsta_update_iftype(struct net_device *net, int ifidx, int wl_iftype);
+bool wl_ext_iapsta_iftype_enabled(struct net_device *net, int wl_iftype);
 void wl_ext_iapsta_ifadding(struct net_device *net, int ifidx);
 bool wl_ext_iapsta_mesh_creating(struct net_device *net);
 #endif
@@ -167,6 +172,9 @@ bool wl_ext_check_scan(struct net_device *dev, dhd_pub_t *dhdp);
 void wl_ext_user_sync(struct dhd_pub *dhd, int ifidx, bool lock);
 bool wl_ext_event_complete(struct dhd_pub *dhd, int ifidx);
 #endif
+#if defined(WL_CFG80211)
+void wl_ext_bss_iovar_war(struct net_device *dev, s32 *val);
+#endif
 enum wl_ext_status {
 	WL_EXT_STATUS_DISCONNECTING = 0,
 	WL_EXT_STATUS_DISCONNECTED,
@@ -180,6 +188,22 @@ enum wl_ext_status {
 	WL_EXT_STATUS_STA_CONNECTED,
 	WL_EXT_STATUS_AP_DISABLED
 };
+#if defined(WL_EXT_IAPSTA) && defined(WL_CFG80211)
+int wl_ext_in4way_sync(struct net_device *dev, uint action,
+	enum wl_ext_status status, void *context);
+#endif /* WL_EXT_IAPSTA && WL_CFG80211 */
+#if defined(WL_EXT_IAPSTA) && defined(WL_WIRELESS_EXT)
+int wl_ext_in4way_sync_wext(struct net_device *dev, uint action,
+	enum wl_ext_status status, void *context);
+#endif /* WL_EXT_IAPSTA && WL_WIRELESS_EXT */
+#if defined(WL_EXT_IAPSTA)
+void wl_ext_update_eapol_status(dhd_pub_t *dhd, int ifidx,
+	uint eapol_status);
+#else
+static INLINE void wl_ext_update_eapol_status(dhd_pub_t *dhd, int ifidx,
+	uint eapol_status) { }
+#endif /* WL_EXT_IAPSTA */
+
 typedef struct wl_conn_info {
 	uint8 bssidx;
 	wlc_ssid_t ssid;
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android_ext.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android_ext.c
index 810f8dc2af7c..62970b0293bc 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_android_ext.c
@@ -1,5 +1,4 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <net/netlink.h>
@@ -96,10 +95,11 @@
 #define CMD_ISAM_ENABLE			"ISAM_ENABLE"
 #define CMD_ISAM_DISABLE		"ISAM_DISABLE"
 #define CMD_ISAM_STATUS			"ISAM_STATUS"
+#define CMD_ISAM_PEER_PATH		"ISAM_PEER_PATH"
 #define CMD_ISAM_PARAM			"ISAM_PARAM"
 #ifdef PROP_TXSTATUS
-#ifdef PROP_TXSTATUS_VSDB
 #include <dhd_wlfc.h>
+#ifdef PROP_TXSTATUS_VSDB
 extern int disable_proptx;
 #endif /* PROP_TXSTATUS_VSDB */
 #endif /* PROP_TXSTATUS */
@@ -192,6 +192,12 @@ typedef struct wl_if_info {
 	struct wl_escan_info *escan;
 	timer_list_compat_t delay_scan;
 #endif /* WLMESH && WL_ESCAN */
+	struct delayed_work pm_enable_work;
+	struct mutex pm_sync;
+#ifdef PROPTX_MAXCOUNT
+	int transit_maxcount;
+#endif /* PROPTX_MAXCOUNT */
+	uint eapol_status;
 } wl_if_info_t;
 
 #define CSA_FW_BIT		(1<<0)
@@ -214,6 +220,14 @@ typedef struct wl_apsta_params {
 	int macs;
 	struct wl_mesh_params mesh_info;
 #endif /* WLMESH && WL_ESCAN */
+	struct mutex in4way_sync;
+	uint sta_handshaking;
+	int sta_btc_mode;
+	struct osl_timespec sta_disc_ts;
+	bool ap_recon_sta;
+	wait_queue_head_t ap_recon_sta_event;
+	struct ether_addr ap_disc_sta_bssid;
+	struct osl_timespec ap_disc_sta_ts;
 } wl_apsta_params_t;
 
 #define MAX_AP_LINK_WAIT_TIME   3000
@@ -241,6 +255,7 @@ static int wl_ext_disable_iface(struct net_device *dev, char *ifname);
 #if defined(WLMESH) && defined(WL_ESCAN)
 static int wl_mesh_escan_attach(dhd_pub_t *dhd, struct wl_if_info *cur_if);
 #endif /* WLMESH && WL_ESCAN */
+void wl_ext_add_remove_pm_enable_work(struct net_device *dev, bool add);
 #endif /* WL_EXT_IAPSTA */
 
 #ifdef IDHCP
@@ -574,6 +589,10 @@ wl_ext_event_complete(struct dhd_pub *dhd, int ifidx)
 #ifdef WL_ESCAN
 	struct wl_escan_info *escan = dhd->escan;
 #endif /* WL_ESCAN */
+#ifdef WL_EXT_IAPSTA
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL;
+#endif /* WL_EXT_IAPSTA */
 	bool complete = TRUE;
 
 #ifdef WL_CFG80211
@@ -596,11 +615,17 @@ wl_ext_event_complete(struct dhd_pub *dhd, int ifidx)
 		complete = FALSE;
 	}
 #endif /* WL_ESCAN */
-	if (dhd->conf->eapol_status >= EAPOL_STATUS_4WAY_START &&
-			dhd->conf->eapol_status < EAPOL_STATUS_4WAY_DONE) {
+#ifdef WL_EXT_IAPSTA
+	if (ifidx < MAX_IF_NUM) {
+		cur_if = &apsta_params->if_info[ifidx];
+	}
+	if (cur_if && cur_if->ifmode == ISTA_MODE &&
+			cur_if->eapol_status >= EAPOL_STATUS_4WAY_START &&
+			cur_if->eapol_status < EAPOL_STATUS_4WAY_DONE) {
 		AEXT_INFO(dev->name, "4-WAY handshaking\n");
 		complete = FALSE;
 	}
+#endif /* WL_EXT_IAPSTA */
 
 	return complete;
 }
@@ -628,6 +653,40 @@ wl_ext_get_ioctl_ver(struct net_device *dev, int *ioctl_ver)
 	return ret;
 }
 
+void
+wl_ext_bss_iovar_war(struct net_device *ndev, s32 *val)
+{
+	dhd_pub_t *dhd = dhd_get_pub(ndev);
+	uint chip;
+	bool need_war = false;
+
+	chip = dhd_conf_get_chip(dhd);
+
+	if (chip == BCM43362_CHIP_ID || chip == BCM4330_CHIP_ID ||
+		chip == BCM43430_CHIP_ID || chip == BCM43012_CHIP_ID ||
+		chip == BCM4345_CHIP_ID || chip == BCM4356_CHIP_ID ||
+		chip == BCM4359_CHIP_ID ||
+		chip == BCM43143_CHIP_ID || chip == BCM43242_CHIP_ID ||
+		chip == BCM43569_CHIP_ID) {
+		need_war = true;
+	}
+
+	if (need_war) {
+		/* Few firmware branches have issues in bss iovar handling and
+		 * that can't be changed since they are in production.
+		 */
+		if (*val == WLC_AP_IOV_OP_MANUAL_AP_BSSCFG_CREATE) {
+			*val = WLC_AP_IOV_OP_MANUAL_STA_BSSCFG_CREATE;
+		} else if (*val == WLC_AP_IOV_OP_MANUAL_STA_BSSCFG_CREATE) {
+			*val = WLC_AP_IOV_OP_MANUAL_AP_BSSCFG_CREATE;
+		} else {
+			/* Ignore for other bss enums */
+			return;
+		}
+		AEXT_TRACE(ndev->name, "wl bss %d\n", *val);
+	}
+}
+
 static int
 wl_ext_set_chanspec(struct net_device *dev, int ioctl_ver,
 	uint16 channel, chanspec_t *ret_chspec)
@@ -1011,6 +1070,10 @@ wl_ext_connect(struct net_device *dev, struct wl_conn_info *conn_info)
 	err = wl_ext_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size, 1);
 
 exit:
+#ifdef WL_EXT_IAPSTA
+	if (!err)
+		wl_ext_add_remove_pm_enable_work(dev, TRUE);
+#endif /* WL_EXT_IAPSTA */
 	if (iovar_buf)
 		kfree(iovar_buf);
 	if (ext_join_params)
@@ -1052,7 +1115,11 @@ wl_ext_get_sec(struct net_device *dev, int ifmode, char *sec, int total_len)
 			bytes_written += snprintf(sec+bytes_written, total_len, "wpapsk");
 		} else if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA2_AUTH_PSK) {
 			bytes_written += snprintf(sec+bytes_written, total_len, "wpa2psk");
-		} else if (auth == WL_AUTH_OPEN_SHARED && wpa_auth == WPA3_AUTH_SAE_PSK) {
+		} else if ((auth == WL_AUTH_OPEN_SYSTEM || auth == WL_AUTH_SAE_KEY) &&
+				wpa_auth == WPA3_AUTH_SAE_PSK) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "wpa3");
+		} else if ((auth == WL_AUTH_OPEN_SYSTEM || auth == WL_AUTH_SAE_KEY) &&
+				wpa_auth == 0x20) {
 			bytes_written += snprintf(sec+bytes_written, total_len, "wpa3");
 		} else {
 			bytes_written += snprintf(sec+bytes_written, total_len, "%d/0x%x",
@@ -1204,6 +1271,111 @@ wl_ext_add_del_ie(struct net_device *dev, uint pktflag, char *ie_data, const cha
 #endif /* SENDPROB || (WLMESH && WL_ESCAN) */
 
 #ifdef WL_EXT_IAPSTA
+#define WL_PM_ENABLE_TIMEOUT 10000
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
+	4 && __GNUC_MINOR__ >= 6))
+#define BCM_SET_CONTAINER_OF(entry, ptr, type, member) \
+_Pragma("GCC diagnostic push") \
+_Pragma("GCC diagnostic ignored \"-Wcast-qual\"") \
+entry = container_of((ptr), type, member); \
+_Pragma("GCC diagnostic pop")
+#else
+#define BCM_SET_CONTAINER_OF(entry, ptr, type, member) \
+entry = container_of((ptr), type, member);
+#endif /* STRICT_GCC_WARNINGS */
+
+static void
+wl_ext_pm_work_handler(struct work_struct *work)
+{
+	struct wl_if_info *cur_if;
+	s32 pm = PM_FAST;
+	dhd_pub_t *dhd;
+
+	BCM_SET_CONTAINER_OF(cur_if, work, struct wl_if_info, pm_enable_work.work);
+
+	AEXT_TRACE("wlan", "%s: Enter\n", __FUNCTION__);
+
+	if (cur_if->dev == NULL)
+		return;
+
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
+	4 && __GNUC_MINOR__ >= 6))
+_Pragma("GCC diagnostic push")
+_Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
+#endif
+
+	dhd = dhd_get_pub(cur_if->dev);
+
+	if (!dhd || !dhd->up) {
+		AEXT_TRACE(cur_if->ifname, "dhd is null or not up\n");
+		return;
+	}
+	if (dhd_conf_get_pm(dhd) >= 0)
+		pm = dhd_conf_get_pm(dhd);
+	wl_ext_ioctl(cur_if->dev, WLC_SET_PM, &pm, sizeof(pm), 1);
+#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
+	4 && __GNUC_MINOR__ >= 6))
+_Pragma("GCC diagnostic pop")
+#endif
+	DHD_PM_WAKE_UNLOCK(dhd);
+
+}
+
+void
+wl_ext_add_remove_pm_enable_work(struct net_device *dev, bool add)
+{
+	dhd_pub_t *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL, *tmp_if = NULL;
+	u16 wq_duration = 0;
+	s32 pm = PM_OFF;
+	int i;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->dev == dev) {
+			cur_if = tmp_if;
+			break;
+		}
+	}
+
+	if (!cur_if)
+		return;
+
+	mutex_lock(&cur_if->pm_sync);
+	/*
+	 * Make cancel and schedule work part mutually exclusive
+	 * so that while cancelling, we are sure that there is no
+	 * work getting scheduled.
+	 */
+
+	if (delayed_work_pending(&cur_if->pm_enable_work)) {
+		cancel_delayed_work_sync(&cur_if->pm_enable_work);
+		DHD_PM_WAKE_UNLOCK(dhd);
+	}
+
+	if (add) {
+		wq_duration = (WL_PM_ENABLE_TIMEOUT);
+	}
+
+	/* It should schedule work item only if driver is up */
+	if (dhd->up) {
+		if (dhd_conf_get_pm(dhd) >= 0)
+			pm = dhd_conf_get_pm(dhd);
+		wl_ext_ioctl(cur_if->dev, WLC_SET_PM, &pm, sizeof(pm), 1);
+		if (wq_duration) {
+			if (schedule_delayed_work(&cur_if->pm_enable_work,
+					msecs_to_jiffies((const unsigned int)wq_duration))) {
+				DHD_PM_WAKE_LOCK_TIMEOUT(dhd, wq_duration);
+			} else {
+				AEXT_ERROR(cur_if->ifname, "Can't schedule pm work handler\n");
+			}
+		}
+	}
+	mutex_unlock(&cur_if->pm_sync);
+
+}
+
 static int
 wl_ext_parse_wep(char *key, struct wl_wsec_key *wsec_key)
 {
@@ -1581,6 +1753,152 @@ wl_ext_radar_detect(struct net_device *dev)
 	return radar;
 }
 
+#if defined(WL_CFG80211) || (defined(WLMESH) && defined(WL_ESCAN))
+static struct wl_if_info *
+wl_ext_if_enabled(struct wl_apsta_params *apsta_params, ifmode_t ifmode)
+{
+	struct wl_if_info *tmp_if, *target_if = NULL;
+	int i;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if && tmp_if->ifmode == ifmode &&
+				wl_get_isam_status(tmp_if, IF_READY)) {
+			if (wl_ext_get_chan(apsta_params, tmp_if->dev)) {
+				target_if = tmp_if;
+				break;
+			}
+		}
+	}
+
+	return target_if;
+}
+#endif
+
+s32
+wl_ext_add_del_bss(struct net_device *ndev, s32 bsscfg_idx,
+	int iftype, s32 del, u8 *addr)
+{
+	s32 ret = BCME_OK;
+	s32 val = 0;
+	u8 ioctl_buf[WLC_IOCTL_SMLEN];
+	struct {
+		s32 cfg;
+		s32 val;
+		struct ether_addr ea;
+	} bss_setbuf;
+
+	AEXT_TRACE(ndev->name, "wl_iftype:%d del:%d \n", iftype, del);
+
+	bzero(&bss_setbuf, sizeof(bss_setbuf));
+
+	/* AP=2, STA=3, up=1, down=0, val=-1 */
+	if (del) {
+		val = WLC_AP_IOV_OP_DELETE;
+	} else if (iftype == WL_INTERFACE_CREATE_AP) {
+		/* Add/role change to AP Interface */
+		AEXT_TRACE(ndev->name, "Adding AP Interface\n");
+		val = WLC_AP_IOV_OP_MANUAL_AP_BSSCFG_CREATE;
+	} else if (iftype == WL_INTERFACE_CREATE_STA) {
+		/* Add/role change to STA Interface */
+		AEXT_TRACE(ndev->name, "Adding STA Interface\n");
+		val = WLC_AP_IOV_OP_MANUAL_STA_BSSCFG_CREATE;
+	} else {
+		AEXT_ERROR(ndev->name, "add_del_bss NOT supported for IFACE type:0x%x", iftype);
+		return -EINVAL;
+	}
+
+	if (!del) {
+		wl_ext_bss_iovar_war(ndev, &val);
+	}
+
+	bss_setbuf.cfg = htod32(bsscfg_idx);
+	bss_setbuf.val = htod32(val);
+
+	if (addr) {
+		memcpy(&bss_setbuf.ea.octet, addr, ETH_ALEN);
+	}
+
+	AEXT_INFO(ndev->name, "wl bss %d bssidx:%d\n", val, bsscfg_idx);
+	ret = wl_ext_iovar_setbuf(ndev, "bss", &bss_setbuf, sizeof(bss_setbuf),
+		ioctl_buf, WLC_IOCTL_SMLEN, NULL);
+	if (ret != 0)
+		AEXT_ERROR(ndev->name, "'bss %d' failed with %d\n", val, ret);
+
+	return ret;
+}
+
+static int
+wl_ext_interface_ops(struct net_device *dev,
+	struct wl_apsta_params *apsta_params, int iftype, u8 *addr)
+{
+	s32 ret;
+	struct wl_interface_create_v2 iface;
+	wl_interface_create_v3_t iface_v3;
+	struct wl_interface_info_v1 *info;
+	wl_interface_info_v2_t *info_v2;
+	uint32 ifflags = 0;
+	bool use_iface_info_v2 = false;
+	u8 ioctl_buf[WLC_IOCTL_SMLEN];
+	wl_wlc_version_t wlc_ver;
+
+	/* Interface create */
+	bzero(&iface, sizeof(iface));
+
+	if (addr) {
+		ifflags |= WL_INTERFACE_MAC_USE;
+	}
+
+	ret = wldev_iovar_getbuf(dev, "wlc_ver", NULL, 0,
+		&wlc_ver, sizeof(wl_wlc_version_t), NULL);
+	if ((ret == BCME_OK) && (wlc_ver.wlc_ver_major >= 5)) {
+		ret = wldev_iovar_getbuf(dev, "interface_create",
+			&iface, sizeof(struct wl_interface_create_v2),
+			ioctl_buf, sizeof(ioctl_buf), NULL);
+		if ((ret == BCME_OK) && (*((uint32 *)ioctl_buf) == WL_INTERFACE_CREATE_VER_3)) {
+			use_iface_info_v2 = true;
+			bzero(&iface_v3, sizeof(wl_interface_create_v3_t));
+			iface_v3.ver = WL_INTERFACE_CREATE_VER_3;
+			iface_v3.iftype = iftype;
+			iface_v3.flags = ifflags;
+			if (addr) {
+				memcpy(&iface_v3.mac_addr.octet, addr, ETH_ALEN);
+			}
+			ret = wl_ext_iovar_getbuf(dev, "interface_create",
+				&iface_v3, sizeof(wl_interface_create_v3_t),
+				ioctl_buf, sizeof(ioctl_buf), NULL);
+			if (unlikely(ret)) {
+				AEXT_ERROR(dev->name, "Interface v3 create failed!! ret %d\n", ret);
+				return ret;
+			}
+		}
+	}
+
+	/* success case */
+	if (use_iface_info_v2 == true) {
+		info_v2 = (wl_interface_info_v2_t *)ioctl_buf;
+		ret = info_v2->bsscfgidx;
+	} else {
+		/* Use v1 struct */
+		iface.ver = WL_INTERFACE_CREATE_VER_2;
+		iface.iftype = iftype;
+		iface.flags = ifflags;
+		if (addr) {
+			memcpy(&iface.mac_addr.octet, addr, ETH_ALEN);
+		}
+		ret = wldev_iovar_getbuf(dev, "interface_create",
+			&iface, sizeof(struct wl_interface_create_v2),
+			ioctl_buf, sizeof(ioctl_buf), NULL);
+		if (ret == BCME_OK) {
+			info = (struct wl_interface_info_v1 *)ioctl_buf;
+			ret = info->bsscfgidx;
+		}
+	}
+
+	AEXT_INFO(dev->name, "wl interface create success!! bssidx:%d \n", ret);
+	return ret;
+}
+
 static void
 wl_ext_wait_netif_change(struct wl_apsta_params *apsta_params,
 	struct wl_if_info *cur_if)
@@ -1596,21 +1914,13 @@ static void
 wl_ext_interface_create(struct net_device *dev, struct wl_apsta_params *apsta_params,
 	struct wl_if_info *cur_if, int iftype, u8 *addr)
 {
-	wl_interface_create_t iface;
-	u8 iovar_buf[WLC_IOCTL_SMLEN];
+	s32 ret;
 
-	bzero(&iface, sizeof(iface));
-	if (addr) {
-		iftype |= WL_INTERFACE_MAC_USE;
-	}
-	iface.ver = WL_INTERFACE_CREATE_VER;
-	iface.flags = iftype;
-	if (addr) {
-		memcpy(&iface.mac_addr.octet, addr, ETH_ALEN);
-	}
 	wl_set_isam_status(cur_if, IF_ADDING);
-	wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-		iovar_buf, WLC_IOCTL_SMLEN, NULL);
+	ret = wl_ext_interface_ops(dev, apsta_params, iftype, addr);
+	if (ret == BCME_UNSUPPORTED) {
+		wl_ext_add_del_bss(dev, 1, iftype, 0, addr);
+	}
 	wl_ext_wait_netif_change(apsta_params, cur_if);
 }
 
@@ -1620,7 +1930,6 @@ wl_ext_iapsta_intf_add(struct net_device *dev, struct wl_apsta_params *apsta_par
 	struct dhd_pub *dhd;
 	apstamode_t apstamode = apsta_params->apstamode;
 	struct wl_if_info *cur_if;
-	wlc_ssid_t ssid = { 0, {0} };
 	s8 iovar_buf[WLC_IOCTL_SMLEN];
 	wl_p2p_if_t ifreq;
 	struct ether_addr mac_addr;
@@ -1630,14 +1939,7 @@ wl_ext_iapsta_intf_add(struct net_device *dev, struct wl_apsta_params *apsta_par
 
 	if (apstamode == ISTAAP_MODE) {
 		cur_if = &apsta_params->if_info[IF_VIF];
-		if (FW_SUPPORTED(dhd, rsdb)) {
-			wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
-		} else {
-			wl_set_isam_status(cur_if, IF_ADDING);
-			wl_ext_iovar_setbuf_bsscfg(dev, "ssid", &ssid, sizeof(ssid),
-				iovar_buf, WLC_IOCTL_SMLEN, 1, NULL);
-			wl_ext_wait_netif_change(apsta_params, cur_if);
-		}
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
 	}
 	else if (apstamode == ISTAGO_MODE) {
 		bzero(&ifreq, sizeof(wl_p2p_if_t));
@@ -2442,26 +2744,6 @@ wl_mesh_set_timer(struct wl_if_info *mesh_if, uint timeout)
 	}
 }
 
-static struct wl_if_info *
-wl_ext_if_enabled(struct wl_apsta_params *apsta_params, ifmode_t ifmode)
-{
-	struct wl_if_info *tmp_if, *target_if = NULL;
-	int i;
-
-	for (i=0; i<MAX_IF_NUM; i++) {
-		tmp_if = &apsta_params->if_info[i];
-		if (tmp_if && tmp_if->ifmode == ifmode &&
-				wl_get_isam_status(tmp_if, IF_READY)) {
-			if (wl_ext_get_chan(apsta_params, tmp_if->dev)) {
-				target_if = tmp_if;
-				break;
-			}
-		}
-	}
-
-	return target_if;
-}
-
 static int
 wl_mesh_clear_vndr_ie(struct net_device *dev, uchar *oui)
 {
@@ -2554,42 +2836,59 @@ wl_mesh_update_vndr_ie(struct wl_apsta_params *apsta_params,
 	struct wl_if_info *mesh_if)
 {
 	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
-	char vndr_ie[64];
+	char *vndr_ie;
 	uchar mesh_oui[]={0x00, 0x22, 0xf4};
 	int bytes_written = 0;
-	int ret;
+	int ret = 0, i, vndr_ie_len;
+	uint8 *peer_bssid;
 
 	wl_mesh_clear_vndr_ie(mesh_if->dev, mesh_oui);
 
-	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+	vndr_ie_len = WLC_IOCTL_MEDLEN;
+	vndr_ie = kmalloc(vndr_ie_len, GFP_KERNEL);
+	if (vndr_ie == NULL) {
+		AEXT_ERROR(mesh_if->dev->name, "Failed to allocate buffer of %d bytes\n",
+			WLC_IOCTL_MEDLEN); 
+		ret = -1;
+		goto exit;
+	}
+
+	bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
 		"0x%02x%02x%02x", mesh_oui[0], mesh_oui[1], mesh_oui[2]);
 
-	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
-		"%02d%02d%02x%02x%02x%02x%02x%02x", MESH_INFO_MASTER_BSSID, ETHER_ADDR_LEN,
+	bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
+		"%02x%02x%02x%02x%02x%02x%02x%02x", MESH_INFO_MASTER_BSSID, ETHER_ADDR_LEN,
 		((u8 *)(&mesh_info->master_bssid))[0], ((u8 *)(&mesh_info->master_bssid))[1],
 		((u8 *)(&mesh_info->master_bssid))[2], ((u8 *)(&mesh_info->master_bssid))[3],
 		((u8 *)(&mesh_info->master_bssid))[4], ((u8 *)(&mesh_info->master_bssid))[5]);
 
-	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+	bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
 		"%02x%02x%02x", MESH_INFO_MASTER_CHANNEL, 1, mesh_info->master_channel);
 
-	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+	bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
 		"%02x%02x%02x", MESH_INFO_HOP_CNT, 1, mesh_info->hop_cnt);
 
-	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
-		"%02d%02d%02x%02x%02x%02x%02x%02x", MESH_INFO_PEER_BSSID, ETHER_ADDR_LEN,
-		((u8 *)(&mesh_info->peer_bssid))[0], ((u8 *)(&mesh_info->peer_bssid))[1],
-		((u8 *)(&mesh_info->peer_bssid))[2], ((u8 *)(&mesh_info->peer_bssid))[3],
-		((u8 *)(&mesh_info->peer_bssid))[4], ((u8 *)(&mesh_info->peer_bssid))[5]);
+	bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
+		"%02x%02x", MESH_INFO_PEER_BSSID, mesh_info->hop_cnt*ETHER_ADDR_LEN);
+	for (i=0; i<mesh_info->hop_cnt && i<MAX_HOP_LIST; i++) {
+		peer_bssid = (uint8 *)&mesh_info->peer_bssid[i];
+		bytes_written += snprintf(vndr_ie+bytes_written, vndr_ie_len,
+			"%02x%02x%02x%02x%02x%02x",
+ 			peer_bssid[0], peer_bssid[1], peer_bssid[2],
+			peer_bssid[3], peer_bssid[4], peer_bssid[5]);
+	}
 
 	ret = wl_ext_add_del_ie(mesh_if->dev, VNDR_IE_BEACON_FLAG|VNDR_IE_PRBRSP_FLAG,
 		vndr_ie, "add");
 	if (!ret) {
 		AEXT_INFO(mesh_if->dev->name, "mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM\n",
 			&mesh_info->master_bssid, mesh_info->master_channel, mesh_info->hop_cnt,
-			&mesh_info->peer_bssid); 
+			mesh_info->peer_bssid); 
 	}
 
+exit:
+	if (vndr_ie)
+		kfree(vndr_ie);
 	return ret;
 }
 
@@ -2606,16 +2905,16 @@ wl_mesh_update_master_info(struct wl_apsta_params *apsta_params,
 		wldev_ioctl(mesh_if->dev, WLC_GET_BSSID, &mesh_info->master_bssid,
 			ETHER_ADDR_LEN, 0);
 		mesh_info->master_channel = wl_ext_get_chan(apsta_params, mesh_if->dev);
-		mesh_info->hop_cnt = 1;
-		memcpy(&mesh_info->peer_bssid, &mesh_info->master_bssid, ETHER_ADDR_LEN);
-		wl_mesh_update_vndr_ie(apsta_params, mesh_if);
-		updated = TRUE;
+		mesh_info->hop_cnt = 0;
+		memset(mesh_info->peer_bssid, 0, MAX_HOP_LIST*ETHER_ADDR_LEN);
+		if (!wl_mesh_update_vndr_ie(apsta_params, mesh_if))
+			updated = TRUE;
 	}
 
 	return updated;
 }
 
-static uint
+static bool
 wl_mesh_update_mesh_info(struct wl_apsta_params *apsta_params,
 	struct wl_if_info *mesh_if)
 {
@@ -2625,7 +2924,7 @@ wl_mesh_update_mesh_info(struct wl_apsta_params *apsta_params,
 	mesh_peer_info_dump_t *peer_results;
 	mesh_peer_info_ext_t *mpi_ext;
 	struct ether_addr bssid;
-	bool updated = FALSE;
+	bool updated = FALSE, bss_found = FALSE;
 	uint16 cur_chan;
 
 	dump_buf = kmalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
@@ -2636,35 +2935,43 @@ wl_mesh_update_mesh_info(struct wl_apsta_params *apsta_params,
 	}
 	count = wl_mesh_get_peer_results(mesh_if->dev, dump_buf, WLC_IOCTL_MAXLEN);
 	if (count > 0) {
-		memset(&bssid, 0 , ETHER_ADDR_LEN);
+		memset(&bssid, 0, ETHER_ADDR_LEN);
 		wldev_ioctl(mesh_if->dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, 0);
 		peer_results = (mesh_peer_info_dump_t *)dump_buf;
 		mpi_ext = (mesh_peer_info_ext_t *)peer_results->mpi_ext;
 		for (count = 0; count < peer_results->count; count++) {
 			if (mpi_ext->entry_state != MESH_SELF_PEER_ENTRY_STATE_TIMEDOUT &&
 					mpi_ext->peer_info.state == MESH_PEERING_ESTAB) {
-				memset(&peer_mesh_info, 0 , sizeof(struct wl_mesh_params));
-				wl_escan_mesh_info(mesh_if->dev, mesh_if->escan,
+				memset(&peer_mesh_info, 0, sizeof(struct wl_mesh_params));
+				bss_found = wl_escan_mesh_info(mesh_if->dev, mesh_if->escan,
 					&mpi_ext->ea, &peer_mesh_info);
-				if ((memcmp(&peer_mesh_info.peer_bssid, &bssid, ETHER_ADDR_LEN)) &&
-						peer_mesh_info.hop_cnt && (mesh_info->hop_cnt == 0 ||
-						peer_mesh_info.hop_cnt <= mesh_info->hop_cnt)) {
+				if (bss_found && (mesh_info->master_channel == 0 ||
+						peer_mesh_info.hop_cnt <= mesh_info->hop_cnt) &&
+						memcmp(&peer_mesh_info.peer_bssid, &bssid, ETHER_ADDR_LEN)) {
 					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
 						ETHER_ADDR_LEN);
 					mesh_info->master_channel = peer_mesh_info.master_channel;
 					mesh_info->hop_cnt = peer_mesh_info.hop_cnt+1;
+					memset(mesh_info->peer_bssid, 0, MAX_HOP_LIST*ETHER_ADDR_LEN);
 					memcpy(&mesh_info->peer_bssid, &mpi_ext->ea, ETHER_ADDR_LEN);
-					mesh_info->channel = peer_mesh_info.channel;
+					memcpy(&mesh_info->peer_bssid[1], peer_mesh_info.peer_bssid,
+						(MAX_HOP_LIST-1)*ETHER_ADDR_LEN);
 					updated = TRUE;
 				}
 			}
 			mpi_ext++;
 		}
-		if (updated)
-			wl_mesh_update_vndr_ie(apsta_params, mesh_if);
+		if (updated) {
+			if (wl_mesh_update_vndr_ie(apsta_params, mesh_if)) {
+				AEXT_ERROR(mesh_if->dev->name, "update failed\n");
+				mesh_info->master_channel = 0;
+				updated = FALSE;
+				goto exit;
+			}
+		}
 	}
 
-	if (!mesh_info->hop_cnt) {
+	if (!mesh_info->master_channel) {
 		wlc_ssid_t cur_ssid;
 		char sec[32];
 		bool sae = FALSE;
@@ -2674,22 +2981,23 @@ wl_mesh_update_mesh_info(struct wl_apsta_params *apsta_params,
 		if (strnicmp(sec, "sae/sae", strlen("sae/sae")) == 0)
 			sae = TRUE;
 		cur_chan = wl_ext_get_chan(apsta_params, mesh_if->dev);
-		wl_escan_mesh_peer(mesh_if->dev, mesh_if->escan, &cur_ssid, cur_chan,
+		bss_found = wl_escan_mesh_peer(mesh_if->dev, mesh_if->escan, &cur_ssid, cur_chan,
 			sae, &peer_mesh_info);
 
-		if (peer_mesh_info.hop_cnt && peer_mesh_info.channel &&
-				(cur_chan != peer_mesh_info.channel)) {
+		if (bss_found && peer_mesh_info.master_channel&&
+				(cur_chan != peer_mesh_info.master_channel)) {
 			WL_MSG(mesh_if->ifname, "moving channel %d -> %d\n",
-				cur_chan, peer_mesh_info.channel);
+				cur_chan, peer_mesh_info.master_channel);
 			wl_ext_disable_iface(mesh_if->dev, mesh_if->ifname);
-			mesh_if->channel = peer_mesh_info.channel;
+			mesh_if->channel = peer_mesh_info.master_channel;
 			wl_ext_enable_iface(mesh_if->dev, mesh_if->ifname, 500);
 		}
 	}
 
+exit:
 	if (dump_buf)
 		kfree(dump_buf);
-	return mesh_info->hop_cnt;
+	return updated;
 }
 
 static void
@@ -2775,6 +3083,107 @@ wl_mesh_escan_attach(dhd_pub_t *dhd, struct wl_if_info *mesh_if)
 
 	return 0;
 }
+
+static uint
+wl_mesh_update_peer_path(struct wl_if_info *mesh_if, char *command,
+	int total_len)
+{
+	struct wl_mesh_params peer_mesh_info;
+	uint32 count = 0;
+	char *dump_buf = NULL;
+	mesh_peer_info_dump_t *peer_results;
+	mesh_peer_info_ext_t *mpi_ext;
+	int bytes_written = 0, j, k;
+	bool bss_found = FALSE;
+
+	dump_buf = kmalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
+	if (dump_buf == NULL) {
+		AEXT_ERROR(mesh_if->dev->name, "Failed to allocate buffer of %d bytes\n",
+			WLC_IOCTL_MAXLEN); 
+		return FALSE;
+	}
+	count = wl_mesh_get_peer_results(mesh_if->dev, dump_buf, WLC_IOCTL_MAXLEN);
+	if (count > 0) {
+		peer_results = (mesh_peer_info_dump_t *)dump_buf;
+		mpi_ext = (mesh_peer_info_ext_t *)peer_results->mpi_ext;
+		for (count = 0; count < peer_results->count; count++) {
+			if (mpi_ext->entry_state != MESH_SELF_PEER_ENTRY_STATE_TIMEDOUT &&
+					mpi_ext->peer_info.state == MESH_PEERING_ESTAB) {
+				memset(&peer_mesh_info, 0, sizeof(struct wl_mesh_params));
+				bss_found = wl_escan_mesh_info(mesh_if->dev, mesh_if->escan,
+					&mpi_ext->ea, &peer_mesh_info);
+				if (bss_found) {
+					bytes_written += snprintf(command+bytes_written, total_len,
+						"\npeer=%pM, hop=%d",
+						&mpi_ext->ea, peer_mesh_info.hop_cnt);
+					for (j=1; j<peer_mesh_info.hop_cnt; j++) {
+						bytes_written += snprintf(command+bytes_written,
+							total_len, "\n");
+						for (k=0; k<j; k++) {
+							bytes_written += snprintf(command+bytes_written,
+								total_len, " ");
+						}
+						bytes_written += snprintf(command+bytes_written, total_len,
+							"%pM", &peer_mesh_info.peer_bssid[j]);
+					}
+				}
+			}
+			mpi_ext++;
+		}
+	}
+
+	if (dump_buf)
+		kfree(dump_buf);
+	return bytes_written;
+}
+
+static int
+wl_ext_isam_peer_path(struct net_device *dev, char *command, int total_len)
+{
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
+	struct wl_if_info *tmp_if;
+	uint16 chan = 0;
+	char *dump_buf = NULL;
+	int dump_len = WLC_IOCTL_MEDLEN;
+	int dump_written = 0;
+	int i;
+
+	if (command || android_msg_level & ANDROID_INFO_LEVEL) {
+		if (command) {
+			dump_buf = command;
+			dump_len = total_len;
+		} else {
+			dump_buf = kmalloc(dump_len, GFP_KERNEL);
+			if (dump_buf == NULL) {
+				AEXT_ERROR(dev->name, "Failed to allocate buffer of %d bytes\n",
+					dump_len); 
+				return -1;
+			}
+		}
+		for (i=0; i<MAX_IF_NUM; i++) {
+			tmp_if = &apsta_params->if_info[i];
+			if (tmp_if->dev && tmp_if->ifmode == IMESH_MODE && apsta_params->macs) {
+				chan = wl_ext_get_chan(apsta_params, tmp_if->dev);
+				if (chan) {
+					dump_written += snprintf(dump_buf+dump_written, dump_len,
+						"[dhd-%s-%c] mbssid=%pM, mchan=%d, hop=%d, pbssid=%pM",
+						tmp_if->ifname, tmp_if->prefix, &mesh_info->master_bssid,
+						mesh_info->master_channel, mesh_info->hop_cnt,
+						&mesh_info->peer_bssid);
+					dump_written += wl_mesh_update_peer_path(tmp_if,
+						dump_buf+dump_written, dump_len-dump_written);
+				}
+			}
+		}
+		AEXT_INFO(dev->name, "%s\n", dump_buf);
+	}
+
+	if (!command && dump_buf)
+		kfree(dump_buf);
+	return dump_written;
+}
 #endif /* WL_ESCAN */
 #endif /* WLMESH */
 
@@ -2997,6 +3406,7 @@ wl_ext_disable_iface(struct net_device *dev, char *ifname)
 
 	if (cur_if->ifmode == ISTA_MODE) {
 		wl_ext_ioctl(cur_if->dev, WLC_DISASSOC, NULL, 0, 1);
+		wl_ext_add_remove_pm_enable_work(dev, FALSE);
 	} else if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
 		// deauthenticate all STA first
 		memcpy(scbval.ea.octet, &ether_bcast, ETHER_ADDR_LEN);
@@ -3775,6 +4185,84 @@ wl_ext_iapsta_enable(struct net_device *dev, char *command, int total_len)
 	return ret;
 }
 
+#ifdef PROPTX_MAXCOUNT
+int
+wl_ext_get_wlfc_maxcount(struct dhd_pub *dhd, int ifidx)
+{
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *tmp_if, *cur_if = NULL;
+	int i, maxcount = WL_TXSTATUS_FREERUNCTR_MASK;
+
+	if (!apsta_params->rsdb)
+		return maxcount;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->ifidx == ifidx) {
+			cur_if = tmp_if;
+			maxcount = cur_if->transit_maxcount;
+		}
+	}
+
+	if (cur_if)
+		AEXT_INFO(cur_if->ifname, "update maxcount %d\n", maxcount);
+	else
+		AEXT_INFO("wlan", "update maxcount %d for ifidx %d\n", maxcount, ifidx);
+	return maxcount;
+}
+
+#define CH_MIN_2G_CHANNEL 1
+void
+wl_ext_update_wlfc_maxcount(struct dhd_pub *dhd)
+{
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *tmp_if;
+	bool band_5g = FALSE;
+	uint16 chan = 0;
+	int i, ret;
+
+	if (!apsta_params->rsdb)
+		return;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev) {
+			chan = wl_ext_get_chan(apsta_params, tmp_if->dev);
+			if (chan > CH_MAX_2G_CHANNEL) {
+				tmp_if->transit_maxcount = dhd->conf->proptx_maxcnt_5g;
+				ret = dhd_wlfc_update_maxcount(dhd, tmp_if->ifidx,
+					tmp_if->transit_maxcount);
+				if (ret == 0)
+					AEXT_INFO(tmp_if->ifname, "updated maxcount %d\n",
+						tmp_if->transit_maxcount);
+				band_5g = TRUE;
+			}
+		}
+	}
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev) {
+			chan = wl_ext_get_chan(apsta_params, tmp_if->dev);
+			if ((chan == 0) || (chan <= CH_MAX_2G_CHANNEL && chan >= CH_MIN_2G_CHANNEL)) {
+				if (chan == 0) {
+					tmp_if->transit_maxcount = WL_TXSTATUS_FREERUNCTR_MASK;
+				} else if (band_5g) {
+					tmp_if->transit_maxcount = dhd->conf->proptx_maxcnt_2g;
+				} else {
+					tmp_if->transit_maxcount = dhd->conf->proptx_maxcnt_5g;
+				}
+				ret = dhd_wlfc_update_maxcount(dhd, tmp_if->ifidx,
+					tmp_if->transit_maxcount);
+				if (ret == 0)
+					AEXT_INFO(tmp_if->ifname, "updated maxcount %d\n",
+						tmp_if->transit_maxcount);
+			}
+		}
+	}
+}
+#endif /* PROPTX_MAXCOUNT */
+
 static int
 wl_ext_iapsta_event(struct net_device *dev,
 	struct wl_apsta_params *apsta_params, wl_event_msg_t *e, void* data)
@@ -3810,7 +4298,7 @@ wl_ext_iapsta_event(struct net_device *dev,
 		return -1;
 	}
 
-	if (cur_if->ifmode == ISTA_MODE) {
+	if (cur_if->ifmode == ISTA_MODE || cur_if->ifmode == IGC_MODE) {
 		if (event_type == WLC_E_LINK) {
 			if (!(flags & WLC_EVENT_MSG_LINK)) {
 				WL_MSG(cur_if->ifname,
@@ -3833,8 +4321,10 @@ wl_ext_iapsta_event(struct net_device *dev,
 			}
 			wl_clr_isam_status(cur_if, STA_CONNECTING);
 			wake_up_interruptible(&apsta_params->netif_change_event);
-		}
-		else if (event_type == WLC_E_SET_SSID && status != WLC_E_STATUS_SUCCESS) {
+#ifdef PROPTX_MAXCOUNT
+			wl_ext_update_wlfc_maxcount(apsta_params->dhd);
+#endif /* PROPTX_MAXCOUNT */
+		} else if (event_type == WLC_E_SET_SSID && status != WLC_E_STATUS_SUCCESS) {
 			WL_MSG(cur_if->ifname,
 				"connect failed event=%d, reason=%d, status=%d\n",
 				event_type, reason, status);
@@ -3844,8 +4334,10 @@ wl_ext_iapsta_event(struct net_device *dev,
 			if (mesh_if && apsta_params->macs)
 				wl_mesh_clear_mesh_info(apsta_params, mesh_if, TRUE);
 #endif /* WLMESH && WL_ESCAN */
-		}
-		else if (event_type == WLC_E_DEAUTH || event_type == WLC_E_DEAUTH_IND ||
+#ifdef PROPTX_MAXCOUNT
+			wl_ext_update_wlfc_maxcount(apsta_params->dhd);
+#endif /* PROPTX_MAXCOUNT */
+		} else if (event_type == WLC_E_DEAUTH || event_type == WLC_E_DEAUTH_IND ||
 				event_type == WLC_E_DISASSOC || event_type == WLC_E_DISASSOC_IND) {
 			WL_MSG(cur_if->ifname, "[%c] Link down with %pM, %s(%d), reason %d\n",
 				cur_if->prefix, &e->addr, bcmevent_get_name(event_type),
@@ -3870,6 +4362,9 @@ wl_ext_iapsta_event(struct net_device *dev,
 				WL_MSG(cur_if->ifname, "[%c] Link up w/o creating? (etype=%d)\n",
 					cur_if->prefix, event_type);
 			}
+#ifdef PROPTX_MAXCOUNT
+			wl_ext_update_wlfc_maxcount(apsta_params->dhd);
+#endif /* PROPTX_MAXCOUNT */
 		}
 		else if ((event_type == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS) ||
 				(event_type == WLC_E_LINK && status == WLC_E_STATUS_SUCCESS &&
@@ -3877,6 +4372,9 @@ wl_ext_iapsta_event(struct net_device *dev,
 			wl_clr_isam_status(cur_if, AP_CREATED);
 			WL_MSG(cur_if->ifname, "[%c] Link down, reason=%d\n",
 				cur_if->prefix, reason);
+#ifdef PROPTX_MAXCOUNT
+			wl_ext_update_wlfc_maxcount(apsta_params->dhd);
+#endif /* PROPTX_MAXCOUNT */
 		}
 		else if ((event_type == WLC_E_ASSOC_IND || event_type == WLC_E_REASSOC_IND) &&
 				reason == DOT11_SC_SUCCESS) {
@@ -3937,6 +4435,29 @@ wl_ext_iapsta_update_channel(dhd_pub_t *dhd, struct net_device *dev,
 	return channel;
 }
 
+static int
+wl_ext_iftype_to_ifmode(struct net_device *net, int wl_iftype, ifmode_t *ifmode)
+{	
+	switch (wl_iftype) {
+		case WLC_E_IF_ROLE_STA:
+			*ifmode = ISTA_MODE;
+			break;
+		case WLC_E_IF_ROLE_AP:
+			*ifmode = IAP_MODE;
+			break;
+		case WLC_E_IF_ROLE_P2P_GO:
+			*ifmode = IGO_MODE;
+			break;
+		case WLC_E_IF_ROLE_P2P_CLIENT:
+			*ifmode = IGC_MODE;
+			break;
+		default:
+			AEXT_ERROR(net->name, "Unknown interface wl_iftype:0x%x\n", wl_iftype);
+			return BCME_ERROR;
+	}
+	return BCME_OK;
+}
+
 void
 wl_ext_iapsta_update_iftype(struct net_device *net, int ifidx, int wl_iftype)
 {
@@ -3988,6 +4509,22 @@ wl_ext_iapsta_ifadding(struct net_device *net, int ifidx)
 	}
 }
 
+bool
+wl_ext_iapsta_iftype_enabled(struct net_device *net, int wl_iftype)
+{
+	struct dhd_pub *dhd = dhd_get_pub(net);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL;
+	ifmode_t ifmode = 0;
+
+	wl_ext_iftype_to_ifmode(net, wl_iftype, &ifmode);
+	cur_if = wl_ext_if_enabled(apsta_params, ifmode);
+	if (cur_if)
+		return TRUE;
+
+	return FALSE;
+}
+
 bool
 wl_ext_iapsta_mesh_creating(struct net_device *net)
 {
@@ -4007,6 +4544,358 @@ wl_ext_iapsta_mesh_creating(struct net_device *net)
 }
 #endif /* WL_CFG80211 */
 
+int
+wl_ext_in4way_sync_sta(dhd_pub_t *dhd, struct wl_if_info *cur_if,
+	uint action, enum wl_ext_status status, void *context)
+{
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct net_device *dev = cur_if->dev;
+	struct osl_timespec cur_ts, *sta_disc_ts = &apsta_params->sta_disc_ts;
+	int ret = 0, err, cur_eapol_status;
+	int max_wait_time, max_wait_cnt;
+	int suppressed = 0, wpa_auth = 0;
+
+	action = action & dhd->conf->in4way;
+	cur_eapol_status = cur_if->eapol_status;
+	AEXT_TRACE(dev->name, "status=%d, action=0x%x, in4way=0x%x\n",
+		status, action, dhd->conf->in4way);
+
+	switch (status) {
+		case WL_EXT_STATUS_SCAN:
+			wldev_ioctl(dev, WLC_GET_SCANSUPPRESS, &suppressed, sizeof(int), false);
+			if (suppressed) {
+				AEXT_ERROR(dev->name, "scan suppressed\n");
+				ret = -EBUSY;
+				break;
+			}
+			if (action & STA_NO_SCAN_IN4WAY) {
+				if (apsta_params->sta_handshaking > 0 && apsta_params->sta_handshaking <= 3) {
+					AEXT_ERROR(dev->name, "return -EBUSY cnt %d\n",
+						apsta_params->sta_handshaking);
+					apsta_params->sta_handshaking++;
+					ret = -EBUSY;
+					break;
+				}
+			}
+			break;
+ 		case WL_EXT_STATUS_DISCONNECTING:
+			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
+				AEXT_ERROR(dev->name, "WPA failed at %d\n", cur_eapol_status);
+				cur_if->eapol_status = EAPOL_STATUS_NONE;
+			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
+				AEXT_ERROR(dev->name, "WPS failed at %d\n", cur_eapol_status);
+				cur_if->eapol_status = EAPOL_STATUS_NONE;
+			}
+			if (action & (STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY)) {
+				if (apsta_params->sta_handshaking) {
+					if ((action & STA_NO_BTC_IN4WAY) && apsta_params->sta_btc_mode) {
+						AEXT_INFO(dev->name, "status=%d, restore sta_btc_mode %d\n",
+							status, apsta_params->sta_btc_mode);
+						wldev_iovar_setint(dev, "sta_btc_mode", apsta_params->sta_btc_mode);
+					}
+					apsta_params->sta_handshaking = 0;
+				}
+			}
+			if (action & STA_WAIT_DISCONNECTED) {
+				uint32 diff_ms;
+				max_wait_time = 200;
+				max_wait_cnt = 20;
+				osl_do_gettimeofday(sta_disc_ts);
+				osl_do_gettimeofday(&cur_ts);
+				diff_ms = osl_do_gettimediff(&cur_ts, sta_disc_ts)/1000;
+				while (diff_ms < max_wait_time && max_wait_cnt) {
+					AEXT_INFO(dev->name, "status=%d, max_wait_cnt=%d waiting...\n",
+						status, max_wait_cnt);
+					mutex_unlock(&apsta_params->in4way_sync);
+					OSL_SLEEP(50);
+					mutex_lock(&apsta_params->in4way_sync);
+					max_wait_cnt--;
+					osl_do_gettimeofday(&cur_ts);
+					diff_ms = osl_do_gettimediff(&cur_ts, sta_disc_ts)/1000;
+				}
+				wake_up_interruptible(&dhd->conf->event_complete);
+			}
+			break;
+		case WL_EXT_STATUS_CONNECTING:
+			wl_ext_iovar_getint(dev, "wpa_auth", &wpa_auth);
+			if (wpa_auth >= 2)
+				cur_if->eapol_status = EAPOL_STATUS_4WAY_START;
+			else
+				cur_if->eapol_status = EAPOL_STATUS_NONE;
+			if (action & (STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY)) {
+				if (wpa_auth >= 2 && cur_if->bssidx == 0) {
+					apsta_params->sta_handshaking = 1;
+					if (action & STA_NO_BTC_IN4WAY) {
+						err = wldev_iovar_getint(dev, "sta_btc_mode", &apsta_params->sta_btc_mode);
+						if (!err && apsta_params->sta_btc_mode) {
+							AEXT_INFO(dev->name, "status=%d, disable current sta_btc_mode %d\n",
+								status, apsta_params->sta_btc_mode);
+							wldev_iovar_setint(dev, "sta_btc_mode", 0);
+						}
+					}
+				}
+			}
+			if (action & STA_WAIT_DISCONNECTED) {
+				uint32 diff_ms;
+				max_wait_time = 200;
+				max_wait_cnt = 10;
+				osl_do_gettimeofday(&cur_ts);
+				diff_ms = osl_do_gettimediff(&cur_ts, sta_disc_ts)/1000;
+				while (diff_ms < max_wait_time && max_wait_cnt) {
+					AEXT_INFO(dev->name, "status=%d, max_wait_cnt=%d waiting...\n",
+						status, max_wait_cnt);
+					mutex_unlock(&apsta_params->in4way_sync);
+					OSL_SLEEP(50);
+					mutex_lock(&apsta_params->in4way_sync);
+					max_wait_cnt--;
+					osl_do_gettimeofday(&cur_ts);
+					diff_ms = osl_do_gettimediff(&cur_ts, sta_disc_ts)/1000;
+				}
+				wake_up_interruptible(&dhd->conf->event_complete);
+			}
+			break;
+		case WL_EXT_STATUS_CONNECTED:
+			if (cur_if->ifmode == ISTA_MODE) {
+				dhd_conf_set_wme(dhd, cur_if->ifidx, 0);
+				wake_up_interruptible(&dhd->conf->event_complete);
+			}
+			else if (cur_if->ifmode == IGC_MODE) {
+				dhd_conf_set_mchan_bw(dhd, WL_P2P_IF_CLIENT, -1);
+			}
+			break;
+		case WL_EXT_STATUS_DISCONNECTED:
+			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
+				AEXT_ERROR(dev->name, "WPA failed at %d\n", cur_eapol_status);
+				cur_if->eapol_status = EAPOL_STATUS_NONE;
+			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
+				AEXT_ERROR(dev->name, "WPS failed at %d\n", cur_eapol_status);
+				cur_if->eapol_status = EAPOL_STATUS_NONE;
+			}
+			if (action & (STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY)) {
+				if (apsta_params->sta_handshaking) {
+					if ((action & STA_NO_BTC_IN4WAY) && apsta_params->sta_btc_mode) {
+						AEXT_INFO(dev->name, "status=%d, restore sta_btc_mode %d\n",
+							status, apsta_params->sta_btc_mode);
+						wldev_iovar_setint(dev, "sta_btc_mode", apsta_params->sta_btc_mode);
+					}
+					apsta_params->sta_handshaking = 0;
+				}
+			}
+			if (action & STA_WAIT_DISCONNECTED) {
+				osl_do_gettimeofday(sta_disc_ts);
+			}
+			wake_up_interruptible(&dhd->conf->event_complete);
+			break;
+		case WL_EXT_STATUS_ADD_KEY:
+			cur_if->eapol_status = EAPOL_STATUS_4WAY_DONE;
+			if (action & (STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY)) {
+				if (apsta_params->sta_handshaking) {
+					if ((action & STA_NO_BTC_IN4WAY) && apsta_params->sta_btc_mode) {
+						AEXT_INFO(dev->name, "status=%d, restore sta_btc_mode %d\n",
+							status, apsta_params->sta_btc_mode);
+						wldev_iovar_setint(dev, "sta_btc_mode", apsta_params->sta_btc_mode);
+					}
+					apsta_params->sta_handshaking = 0;
+				}
+			}
+			wake_up_interruptible(&dhd->conf->event_complete);
+			break;
+		default:
+			AEXT_INFO(dev->name, "Unknown action=0x%x, status=%d\n", action, status);
+	}
+
+	return ret;
+}
+
+int
+wl_ext_in4way_sync_ap(dhd_pub_t *dhd, struct wl_if_info *cur_if,
+	uint action, enum wl_ext_status status, void *context)
+{
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct net_device *dev = cur_if->dev;
+	struct osl_timespec cur_ts, *ap_disc_sta_ts = &apsta_params->ap_disc_sta_ts;
+	u8 *ap_disc_sta_bssid = (u8*)&apsta_params->ap_disc_sta_bssid;
+	uint32 diff_ms, timeout, max_wait_time = 300;
+	int ret = 0, suppressed = 0;
+	u8* mac_addr = context;
+	bool wait = FALSE;
+
+	action = action & dhd->conf->in4way;
+	AEXT_TRACE(dev->name, "status=%d, action=0x%x, in4way=0x%x\n",
+		status, action, dhd->conf->in4way);
+
+	switch (status) {
+		case WL_EXT_STATUS_SCAN:
+			wldev_ioctl(dev, WLC_GET_SCANSUPPRESS, &suppressed, sizeof(int), false);
+			if (suppressed) {
+				AEXT_ERROR(dev->name, "scan suppressed\n");
+				ret = -EBUSY;
+				break;
+			}
+			break;
+		case WL_EXT_STATUS_AP_ENABLED:
+			if (cur_if->ifmode == IAP_MODE)
+				dhd_conf_set_wme(dhd, cur_if->ifidx, 1);
+			else if (cur_if->ifmode == IGO_MODE)
+				dhd_conf_set_mchan_bw(dhd, WL_P2P_IF_GO, -1);
+			break;
+		case WL_EXT_STATUS_DELETE_STA:
+			if (action & AP_WAIT_STA_RECONNECT) {
+				osl_do_gettimeofday(&cur_ts);
+				diff_ms = osl_do_gettimediff(&cur_ts, ap_disc_sta_ts)/1000;
+				if (mac_addr && diff_ms < max_wait_time) {
+					if (cur_if->ifmode == IAP_MODE &&
+							!memcmp(ap_disc_sta_bssid, mac_addr, ETHER_ADDR_LEN)) {
+						wait = TRUE;
+					} else if (cur_if->ifmode == IGO_MODE &&
+							cur_if->eapol_status == EAPOL_STATUS_WSC_DONE &&
+							memcmp(&ether_bcast, mac_addr, ETHER_ADDR_LEN)) {
+						wait = TRUE;
+					}
+				}
+				if (wait) {
+					AEXT_INFO(dev->name, "status=%d, ap_recon_sta=%d, waiting %dms ...\n",
+						status, apsta_params->ap_recon_sta, max_wait_time);
+					mutex_unlock(&apsta_params->in4way_sync);
+					timeout = wait_event_interruptible_timeout(apsta_params->ap_recon_sta_event,
+						apsta_params->ap_recon_sta, msecs_to_jiffies(max_wait_time));
+					mutex_lock(&apsta_params->in4way_sync);
+					AEXT_INFO(dev->name, "status=%d, ap_recon_sta=%d, timeout=%d\n",
+						status, apsta_params->ap_recon_sta, timeout);
+					if (timeout > 0) {
+						AEXT_INFO(dev->name, "skip delete STA %pM\n", mac_addr);
+						ret = -1;
+						break;
+					}
+				} else {
+					AEXT_INFO(dev->name, "status=%d, ap_recon_sta=%d => 0\n",
+						status, apsta_params->ap_recon_sta);
+					apsta_params->ap_recon_sta = FALSE;
+					if (cur_if->ifmode == IGO_MODE)
+						cur_if->eapol_status = EAPOL_STATUS_NONE;
+				}
+			}
+			break;
+		case WL_EXT_STATUS_STA_DISCONNECTED:
+			if (action & AP_WAIT_STA_RECONNECT) {
+				AEXT_INFO(dev->name, "latest disc STA %pM ap_recon_sta=%d\n",
+					ap_disc_sta_bssid, apsta_params->ap_recon_sta);
+				osl_do_gettimeofday(ap_disc_sta_ts);
+				memcpy(ap_disc_sta_bssid, mac_addr, ETHER_ADDR_LEN);
+				apsta_params->ap_recon_sta = FALSE;
+			}
+			break;
+		case WL_EXT_STATUS_STA_CONNECTED:
+			if (action & AP_WAIT_STA_RECONNECT) {
+				osl_do_gettimeofday(&cur_ts);
+				diff_ms = osl_do_gettimediff(&cur_ts, ap_disc_sta_ts)/1000;
+				if (diff_ms < max_wait_time &&
+						!memcmp(ap_disc_sta_bssid, mac_addr, ETHER_ADDR_LEN)) {
+					AEXT_INFO(dev->name, "status=%d, ap_recon_sta=%d => 1\n",
+						status, apsta_params->ap_recon_sta);
+					apsta_params->ap_recon_sta = TRUE;
+					wake_up_interruptible(&apsta_params->ap_recon_sta_event);
+				} else {
+					apsta_params->ap_recon_sta = FALSE;
+				}
+			}
+			break;
+		default:
+			AEXT_INFO(dev->name, "Unknown action=0x%x, status=%d\n", action, status);
+	}
+
+	return ret;
+}
+
+#ifdef WL_CFG80211
+int
+wl_ext_in4way_sync(struct net_device *dev, uint action,
+	enum wl_ext_status status, void *context)
+{
+	dhd_pub_t *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL, *tmp_if = NULL;
+	int ret = 0, i;
+
+	mutex_lock(&apsta_params->in4way_sync);
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->dev == dev) {
+			cur_if = tmp_if;
+			break;
+		}
+	}
+
+	if (cur_if) {
+		if (cur_if->ifmode == ISTA_MODE || cur_if->ifmode == IGC_MODE)
+			ret = wl_ext_in4way_sync_sta(dhd, cur_if, action, status, context);
+		else if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IGO_MODE)
+			ret = wl_ext_in4way_sync_ap(dhd, cur_if, action, status, context);
+		else
+			AEXT_INFO(dev->name, "Unknown mode %d\n", cur_if->ifmode);
+	}
+	mutex_unlock(&apsta_params->in4way_sync);
+
+	return ret;
+}
+#endif /* WL_CFG80211 */
+
+#ifdef WL_WIRELESS_EXT
+int
+wl_ext_in4way_sync_wext(struct net_device *dev, uint action,
+	enum wl_ext_status status, void *context)
+{
+	int ret = 0;
+#ifndef WL_CFG80211
+	dhd_pub_t *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params;
+	struct wl_if_info *cur_if = NULL, *tmp_if = NULL;
+	int i;
+
+	if (!dhd)
+		return 0;
+
+	apsta_params = dhd->iapsta_params;
+
+	mutex_lock(&apsta_params->in4way_sync);
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->dev == dev) {
+			cur_if = tmp_if;
+			break;
+		}
+	}
+
+	if (cur_if && cur_if->ifmode == ISTA_MODE) {
+		if (status == WL_EXT_STATUS_DISCONNECTING) {
+			wl_ext_add_remove_pm_enable_work(dev, FALSE);
+		} else if (status == WL_EXT_STATUS_CONNECTING) {
+			wl_ext_add_remove_pm_enable_work(dev, TRUE);
+		}
+		ret = wl_ext_in4way_sync_sta(dhd, cur_if, 0, status, NULL);
+	}
+	mutex_unlock(&apsta_params->in4way_sync);
+#endif
+	return ret;
+}
+#endif /* WL_WIRELESS_EXT */
+
+void
+wl_ext_update_eapol_status(dhd_pub_t *dhd, int ifidx, uint eapol_status)
+{
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL;
+
+	if (ifidx < MAX_IF_NUM) {
+		cur_if = &apsta_params->if_info[ifidx];
+		cur_if->eapol_status = eapol_status;
+	}
+}
+
 int
 wl_ext_iapsta_alive_preinit(struct net_device *dev)
 {
@@ -4145,6 +5034,9 @@ wl_ext_iapsta_postinit(struct net_device *net, struct wl_if_info *cur_if)
 		}
 #endif /* WLMESH */
 	}
+#ifdef PROPTX_MAXCOUNT
+	wl_ext_update_wlfc_maxcount(dhd);
+#endif /* PROPTX_MAXCOUNT */
 
 }
 
@@ -4232,7 +5124,11 @@ wl_ext_iapsta_attach_netdev(struct net_device *net, int ifidx, uint8 bssidx)
 			apsta_params, PRIO_EVENT_IAPSTA);
 		strcpy(cur_if->ifname, net->name);
 		init_waitqueue_head(&apsta_params->netif_change_event);
+		init_waitqueue_head(&apsta_params->ap_recon_sta_event);
 		mutex_init(&apsta_params->usr_sync);
+		mutex_init(&cur_if->pm_sync);
+		mutex_init(&apsta_params->in4way_sync);
+		INIT_DELAYED_WORK(&cur_if->pm_enable_work, wl_ext_pm_work_handler);
 	} else if (cur_if && wl_get_isam_status(cur_if, IF_ADDING)) {
 		primary_if = &apsta_params->if_info[IF_PIF];
 		cur_if->dev = net;
@@ -4245,6 +5141,8 @@ wl_ext_iapsta_attach_netdev(struct net_device *net, int ifidx, uint8 bssidx)
 			wl_mesh_escan_attach(dhd, cur_if);
 		}
 #endif /* WLMESH && WL_ESCAN */
+		mutex_init(&cur_if->pm_sync);
+		INIT_DELAYED_WORK(&cur_if->pm_enable_work, wl_ext_pm_work_handler);
 	}
 
 	return 0;
@@ -4266,6 +5164,7 @@ wl_ext_iapsta_dettach_netdev(struct net_device *net, int ifidx)
 	}
 
 	if (ifidx == 0) {
+		wl_ext_add_remove_pm_enable_work(net, FALSE);
 		wl_ext_event_deregister(net, dhd, WLC_E_LAST, wl_ext_iapsta_event);
 #if defined(WLMESH) && defined(WL_ESCAN)
 		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs) {
@@ -4275,6 +5174,7 @@ wl_ext_iapsta_dettach_netdev(struct net_device *net, int ifidx)
 		memset(apsta_params, 0, sizeof(struct wl_apsta_params));
 	} else if (cur_if && (wl_get_isam_status(cur_if, IF_READY) ||
 			wl_get_isam_status(cur_if, IF_ADDING))) {
+		wl_ext_add_remove_pm_enable_work(net, FALSE);
 		wl_ext_event_deregister(net, dhd, WLC_E_LAST, wl_ext_iapsta_event);
 #if defined(WLMESH) && defined(WL_ESCAN)
 		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs) {
@@ -5446,6 +6346,121 @@ wl_ext_gpio_notify(struct net_device *dev, char *data, char *command,
 }
 #endif /* WL_GPIO_NOTIFY */
 
+#ifdef CSI_SUPPORT
+typedef struct csi_config {
+	/* Peer device mac address. */
+	struct ether_addr addr;
+	/* BW to be used in the measurements. This needs to be supported both by the */
+	/* device itself and the peer. */
+	uint32 bw;
+	/* Time interval between measurements (units: 1 ms). */
+	uint32 period;
+	/* CSI method */
+	uint32 method;
+} csi_config_t;
+
+typedef struct csi_list {
+	uint32 cnt;
+	csi_config_t configs[1];
+} csi_list_t;
+
+static int
+wl_ether_atoe(const char *a, struct ether_addr *n)
+{
+	char *c = NULL;
+	int i = 0;
+
+	memset(n, 0, ETHER_ADDR_LEN);
+	for (;;) {
+		n->octet[i++] = (uint8)strtoul(a, &c, 16);
+		if (!*c++ || i == ETHER_ADDR_LEN)
+			break;
+		a = c;
+	}
+	return (i == ETHER_ADDR_LEN);
+}
+
+static int
+wl_ext_csi(struct net_device *dev, char *data, char *command, int total_len)
+{
+	csi_config_t csi, *csip;
+	csi_list_t *csi_list;
+	int ret = -1, period=-1, i;
+	char mac[32], *buf = NULL;
+	struct ether_addr ea;
+	int bytes_written = 0;
+
+	buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+	if (buf == NULL) {
+		AEXT_ERROR(dev->name, "Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+		goto exit;
+	}
+	memset(buf, 0, WLC_IOCTL_SMLEN);
+
+	if (data) {
+		sscanf(data, "%s %d", mac, &period);
+		ret = wl_ether_atoe(mac, &ea);
+		if (!ret) {
+			AEXT_ERROR(dev->name, "rejecting mac=%s, ret=%d\n", mac, ret);
+			goto exit;
+		}
+		AEXT_TRACE(dev->name, "mac=%pM, period=%d", &ea, period);
+		if (period > 0) {
+			memset(&csi, 0, sizeof(csi_config_t));
+			bcopy(&ea, &csi.addr, ETHER_ADDR_LEN);
+			csi.period = period;
+			ret = wl_ext_iovar_setbuf(dev, "csi", (char *)&csi, sizeof(csi),
+				buf, WLC_IOCTL_SMLEN, NULL);
+		} else if (period == 0) {
+			memset(&csi, 0, sizeof(csi_config_t));
+			bcopy(&ea, &csi.addr, ETHER_ADDR_LEN);
+			ret = wl_ext_iovar_setbuf(dev, "csi_del", (char *)&csi, sizeof(csi),
+				buf, WLC_IOCTL_SMLEN, NULL);
+		} else {
+			ret = wl_ext_iovar_getbuf(dev, "csi", &ea, ETHER_ADDR_LEN, buf,
+				WLC_IOCTL_SMLEN, NULL);
+			if (!ret) {
+				csip = (csi_config_t *) buf;
+					/* Dump all lists */
+				bytes_written += snprintf(command+bytes_written, total_len,
+					"Mac    :%pM\n"
+					"Period :%d\n"
+					"BW     :%d\n"
+					"Method :%d\n",
+					&csip->addr, csip->period, csip->bw, csip->method);
+				AEXT_TRACE(dev->name, "command result is %s\n", command);
+				ret = bytes_written;
+			}
+		}
+	}
+	else {
+		ret = wl_ext_iovar_getbuf(dev, "csi_list", NULL, 0, buf, WLC_IOCTL_SMLEN, NULL);
+		if (!ret) {
+			csi_list = (csi_list_t *)buf;
+			bytes_written += snprintf(command+bytes_written, total_len,
+				"Total number :%d\n", csi_list->cnt);
+			for (i=0; i<csi_list->cnt; i++) {
+				csip = &csi_list->configs[i];
+				bytes_written += snprintf(command+bytes_written, total_len,
+					"Idx    :%d\n"
+					"Mac    :%pM\n"
+					"Period :%d\n"
+					"BW     :%d\n"
+					"Method :%d\n\n",
+					i+1, &csip->addr, csip->period, csip->bw, csip->method);
+			}
+			AEXT_TRACE(dev->name, "command result is %s\n", command);
+			ret = bytes_written;
+		}
+	}
+
+exit:
+	if (buf)
+		kfree(buf);
+	return ret;
+}
+#endif /* CSI_SUPPORT */
+
 typedef int (wl_ext_tpl_parse_t)(struct net_device *dev, char *data, char *command,
 	int total_len);
 
@@ -5492,6 +6507,9 @@ const wl_ext_iovar_tpl_t wl_ext_iovar_tpl_list[] = {
 #ifdef WL_GPIO_NOTIFY
 	{WLC_GET_VAR,	WLC_SET_VAR,	"bcol_gpio_noti",	wl_ext_gpio_notify},
 #endif /* WL_GPIO_NOTIFY */
+#ifdef CSI_SUPPORT
+	{WLC_GET_VAR,	WLC_SET_VAR,	"csi",				wl_ext_csi},
+#endif /* CSI_SUPPORT */
 };
 
 /*
@@ -5624,6 +6642,11 @@ wl_android_ext_priv_cmd(struct net_device *net, char *command,
 	else if (strnicmp(command, CMD_ISAM_PARAM, strlen(CMD_ISAM_PARAM)) == 0) {
 		*bytes_written = wl_ext_isam_param(net, command, total_len);
 	}
+#if defined(WLMESH) && defined(WL_ESCAN)
+	else if (strnicmp(command, CMD_ISAM_PEER_PATH, strlen(CMD_ISAM_PEER_PATH)) == 0) {
+		*bytes_written = wl_ext_isam_peer_path(net, command, total_len);
+	}
+#endif /* WLMESH && WL_ESCAN */
 #endif /* WL_EXT_IAPSTA */
 #ifdef WL_CFG80211
 	else if (strnicmp(command, CMD_AUTOCHANNEL, strlen(CMD_AUTOCHANNEL)) == 0) {
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
index e4cb0704854e..64410fe0f254 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.c
@@ -1,4 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux cfg80211 driver
  *
@@ -35,6 +34,9 @@
 
 #include <wlc_types.h>
 #include <bcmutils.h>
+
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <bcmstdlib_s.h>
 #include <bcmwifi_channels.h>
 #include <bcmendian.h>
 #include <ethernet.h>
@@ -574,6 +576,9 @@ static s32 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_pmksa *pmksa);
 static s32 wl_cfg80211_flush_pmksa(struct wiphy *wiphy,
 	struct net_device *dev);
+#ifdef WL_CLIENT_SAE
+static bool wl_is_pmkid_available(struct net_device *dev, const u8 *bssid);
+#endif /* WL_CLIENT_SAE */
 void wl_cfg80211_scan_abort(struct bcm_cfg80211 *cfg);
 static void wl_cfg80211_cancel_scan(struct bcm_cfg80211 *cfg);
 static s32 wl_notify_escan_complete(struct bcm_cfg80211 *cfg,
@@ -730,6 +735,16 @@ static s32 wl_cfg80211_tdls_config(struct bcm_cfg80211 *cfg,
 static s32 wl_tdls_event_handler(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 	const wl_event_msg_t *e, void *data);
 #endif /* WLTDLS */
+
+#ifdef WL_CLIENT_SAE
+static s32 wl_notify_connect_status_bss(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data);
+static s32 wl_notify_start_auth(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *e, void *data);
+static s32 wl_cfg80211_external_auth(struct wiphy *wiphy,
+	struct net_device *dev, struct cfg80211_external_auth_params *ext_auth);
+#endif /* WL_CLIENT_SAE */
+
 /*
  * register/deregister parent device
  */
@@ -950,8 +965,6 @@ extern int dhd_wait_pend8021x(struct net_device *dev);
 #ifdef PROP_TXSTATUS_VSDB
 extern int disable_proptx;
 #endif /* PROP_TXSTATUS_VSDB */
-static int wl_cfg80211_check_in4way(struct bcm_cfg80211 *cfg,
-	struct net_device *dev, uint action, enum wl_ext_status status, void *context);
 
 
 extern int passive_channel_skip;
@@ -1385,6 +1398,9 @@ wl_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
 		.tx = 0xffff,
 		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
 		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+#ifdef WL_CLIENT_SAE
+		| BIT(IEEE80211_STYPE_AUTH >> 4)
+#endif /* WL_CLIENT_SAE */
 	},
 	[NL80211_IFTYPE_AP] = {
 		.tx = 0xffff,
@@ -3399,7 +3415,7 @@ wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 			 return -ENODEV;
 		}
 	}
-	err = wl_cfg80211_check_in4way(cfg, ndev_to_wlc_ndev(ndev, cfg), NO_SCAN_IN4WAY,
+	err = wl_ext_in4way_sync(ndev_to_wlc_ndev(ndev, cfg), STA_NO_SCAN_IN4WAY,
 		WL_EXT_STATUS_SCAN, NULL);
 	if (err)
 		return err;
@@ -3743,6 +3759,30 @@ bcm_cfg80211_del_ibss_if(struct wiphy *wiphy, bcm_struct_cfgdev *cfgdev)
 }
 #endif /* WLAIBSS_MCHAN */
 
+bool
+wl_legacy_chip_check(struct bcm_cfg80211 *cfg)
+{
+	dhd_pub_t *dhd = (dhd_pub_t *)(cfg->pub);
+	uint chip;
+
+	chip = dhd_conf_get_chip(dhd);
+
+	if (chip == BCM43362_CHIP_ID || chip == BCM4330_CHIP_ID ||
+		chip == BCM43430_CHIP_ID || chip == BCM43012_CHIP_ID ||
+		chip == BCM4334_CHIP_ID || chip == BCM43340_CHIP_ID ||
+		chip == BCM43341_CHIP_ID || chip == BCM4324_CHIP_ID ||
+		chip == BCM4335_CHIP_ID || chip == BCM4339_CHIP_ID ||
+		chip == BCM4345_CHIP_ID || chip == BCM43454_CHIP_ID ||
+		chip == BCM4354_CHIP_ID || chip == BCM4356_CHIP_ID ||
+		chip == BCM4371_CHIP_ID || chip == BCM4359_CHIP_ID ||
+		chip == BCM43143_CHIP_ID || chip == BCM43242_CHIP_ID ||
+		chip == BCM43569_CHIP_ID) {
+		return true;
+	}
+
+	return false;
+}
+
 #ifdef WLMESH_CFG80211
 s32
 wl_cfg80211_interface_ops(struct bcm_cfg80211 *cfg,
@@ -3884,76 +3924,6 @@ wl_cfg80211_interface_ops(struct bcm_cfg80211 *cfg,
 }
 #endif
 
-bool
-wl_customer6_legacy_chip_check(struct bcm_cfg80211 *cfg,
-	struct net_device *ndev)
-{
-	u32 chipnum;
-	wlc_rev_info_t revinfo;
-	int ret;
-
-	/* Get the device rev info */
-	memset(&revinfo, 0, sizeof(revinfo));
-	ret = wldev_ioctl_get(ndev, WLC_GET_REVINFO, &revinfo, sizeof(revinfo));
-	if (ret < 0) {
-		WL_ERR(("%s: GET revinfo FAILED. ret:%d\n", __FUNCTION__, ret));
-		ASSERT(0);
-		return false;
-	}
-
-	WL_DBG(("%s: GET_REVINFO device 0x%x, vendor 0x%x, chipnum 0x%x\n", __FUNCTION__,
-		dtoh32(revinfo.deviceid), dtoh32(revinfo.vendorid), dtoh32(revinfo.chipnum)));
-	chipnum = revinfo.chipnum;
-	if ((chipnum == BCM4350_CHIP_ID) || (chipnum == BCM4355_CHIP_ID) ||
-		(chipnum == BCM4345_CHIP_ID) || (chipnum == BCM43430_CHIP_ID) ||
-		(chipnum == BCM43362_CHIP_ID)) {
-		/* WAR required */
-		return true;
-	}
-
-	return false;
-}
-
-void
-wl_bss_iovar_war(struct bcm_cfg80211 *cfg,
-	struct net_device *ndev, s32 *val)
-{
-	u32 chipnum;
-	wlc_rev_info_t revinfo;
-	int ret;
-	bool need_war = false;
-
-	/* Get the device rev info */
-	memset(&revinfo, 0, sizeof(revinfo));
-	ret = wldev_ioctl_get(ndev, WLC_GET_REVINFO, &revinfo, sizeof(revinfo));
-	if (ret < 0) {
-		WL_ERR(("%s: GET revinfo FAILED. ret:%d\n", __FUNCTION__, ret));
-	} else {
-		WL_DBG(("%s: GET_REVINFO device 0x%x, vendor 0x%x, chipnum 0x%x\n", __FUNCTION__,
-			dtoh32(revinfo.deviceid), dtoh32(revinfo.vendorid), dtoh32(revinfo.chipnum)));
-		chipnum = revinfo.chipnum;
-		if ((chipnum == BCM4359_CHIP_ID) || (chipnum == BCM43596_CHIP_ID)) { 
-			/* WAR required */
-			need_war = true;
-		}
-	}
-
-	if (wl_customer6_legacy_chip_check(cfg, ndev) || need_war) {
-		/* Few firmware branches have issues in bss iovar handling and
-		 * that can't be changed since they are in production.
-		 */
-		if (*val == WLC_AP_IOV_OP_MANUAL_AP_BSSCFG_CREATE) {
-			*val = WLC_AP_IOV_OP_MANUAL_STA_BSSCFG_CREATE;
-		} else if (*val == WLC_AP_IOV_OP_MANUAL_STA_BSSCFG_CREATE) {
-			*val = WLC_AP_IOV_OP_MANUAL_AP_BSSCFG_CREATE;
-		} else {
-			/* Ignore for other bss enums */
-			return;
-		}
-		WL_ERR(("wl bss %d\n", *val));
-	}
-}
-
 s32
 wl_cfg80211_add_del_bss(struct bcm_cfg80211 *cfg,
 	struct net_device *ndev, s32 bsscfg_idx,
@@ -3989,7 +3959,7 @@ wl_cfg80211_add_del_bss(struct bcm_cfg80211 *cfg,
 	}
 
 	if (!del) {
-		wl_bss_iovar_war(cfg, ndev, &val);
+		wl_ext_bss_iovar_war(ndev, &val);
 	}
 
 	bss_setbuf.cfg = htod32(bsscfg_idx);
@@ -3999,7 +3969,7 @@ wl_cfg80211_add_del_bss(struct bcm_cfg80211 *cfg,
 		memcpy(&bss_setbuf.ea.octet, addr, ETH_ALEN);
 	}
 
-	WL_DBG(("wl bss %d bssidx:%d iface:%s \n", val, bsscfg_idx, ndev->name));
+	WL_MSG(ndev->name, "wl bss %d bssidx:%d\n", val, bsscfg_idx);
 	ret = wldev_iovar_setbuf(ndev, "bss", &bss_setbuf, sizeof(bss_setbuf),
 		cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
 	if (ret != 0)
@@ -4414,7 +4384,7 @@ wl_cfg80211_create_iface(struct wiphy *wiphy,
 	/*
 	 * Intialize the firmware I/F.
 	 */
-	if (wl_customer6_legacy_chip_check(cfg, primary_ndev)) {
+	if (wl_legacy_chip_check(cfg)) {
 		/* Use bss iovar instead of interface_create iovar */
 		ret = BCME_UNSUPPORTED;
 	} else {
@@ -5020,6 +4990,19 @@ wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 		WL_DBG(("sae\n"));
 		break;
 #endif /* WL_SAE */
+#ifdef WL_CLIENT_SAE
+	case NL80211_AUTHTYPE_SAE:
+		if (!wl_is_pmkid_available(dev, sme->bssid)) {
+			val = WL_AUTH_SAE_KEY;
+		} else {
+			/* Fw will choose right auth type
+			* dynamically based on PMKID availability
+			*/
+			val = WL_AUTH_OPEN_SHARED;
+		}
+		WL_DBG(("sae auth type %d\n", val));
+		break;
+#endif /* WL_CLIENT_SAE */
 	default:
 		val = 2;
 		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
@@ -5036,6 +5019,28 @@ wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 	return err;
 }
 
+#ifdef WL_CLIENT_SAE
+static bool
+wl_is_pmkid_available(struct net_device *dev, const u8 *bssid)
+{
+	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
+	int i;
+	int npmkids = (cfg->pmk_list->pmkids.length - sizeof(uint16)*2) / sizeof(pmkid_v2_t);
+
+	/* check the bssid is null or not */
+	if (!bssid) return FALSE;
+
+	for (i = 0; i < npmkids; i++) {
+		if (!memcmp(bssid, &cfg->pmk_list->pmkids.pmkid[i].bssid, ETHER_ADDR_LEN)) {
+			WL_DBG(("FOUND PMKID\n"));
+			return TRUE;
+		}
+	}
+	WL_ERR(("PMKID NOT FOUND\n"));
+	return FALSE;
+}
+#endif /* WL_CLIENT_SAE */
+
 static s32
 wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
@@ -5328,11 +5333,11 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 			case WLAN_AKM_SUITE_PSK:
 				val = WPA2_AUTH_PSK;
 				break;
-#ifdef WL_SAE
+#if defined(WL_SAE) || defined(WL_CLIENT_SAE)
 			case WLAN_AKM_SUITE_SAE:
 				val = WPA3_AUTH_SAE_PSK;
 				break;
-#endif /* WL_SAE */
+#endif /* WL_SAE || WL_CLIENT_SAE */
 			default:
 				WL_ERR(("invalid akm suite (0x%x)\n",
 					sme->crypto.akm_suites[0]));
@@ -5654,8 +5659,7 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			err = wl_cfg80211_cleanup_mismatch_status(dev, cfg, TRUE);
 		}
 	}
-	wl_cfg80211_check_in4way(cfg, dev, WAIT_DISCONNECTED,
-		WL_EXT_STATUS_CONNECTING, NULL);
+	wl_ext_in4way_sync(dev, STA_WAIT_DISCONNECTED, WL_EXT_STATUS_CONNECTING, NULL);
 
 	/* 'connect' request received */
 	wl_set_drv_status(cfg, CONNECTING, dev);
@@ -5917,7 +5921,7 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		wl_clr_drv_status(cfg, CONNECTING, dev);
 	}
 	if (!err)
-		wl_cfg80211_check_in4way(cfg, dev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY,
+		wl_ext_in4way_sync(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY,
 			WL_EXT_STATUS_CONNECTING, NULL);
 
 #ifdef WLTDLS
@@ -5959,10 +5963,10 @@ wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 	u8 *curbssid;
 	dhd_pub_t *dhdp = (dhd_pub_t *)(cfg->pub);
 
-	WL_MSG(dev->name, "Reason %d\n", reason_code);
 	RETURN_EIO_IF_NOT_UP(cfg);
 	act = *(bool *) wl_read_prof(cfg, dev, WL_PROF_ACT);
 	curbssid = wl_read_prof(cfg, dev, WL_PROF_BSSID);
+	WL_MSG(dev->name, "Reason %d, act %d\n", reason_code, act);
 
 	BCM_REFERENCE(dhdp);
 
@@ -6004,7 +6008,7 @@ wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 					WL_ERR(("error (%d)\n", err));
 					return err;
 				}
-				wl_cfg80211_check_in4way(cfg, dev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+				wl_ext_in4way_sync(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 					WL_EXT_STATUS_DISCONNECTING, NULL);
 				wl_cfg80211_wait_for_disconnection(cfg, dev);
 		}
@@ -6514,7 +6518,7 @@ wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 		WL_ERR(("set wsec error (%d)\n", err));
 		return err;
 	}
-	wl_cfg80211_check_in4way(cfg, dev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY,
+	wl_ext_in4way_sync(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY,
 		WL_EXT_STATUS_ADD_KEY, NULL);
 
 	return err;
@@ -7081,7 +7085,9 @@ wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
 	int i, j;
 	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
 	struct net_device *primary_dev = bcmcfg_to_prmry_ndev(cfg);
+	int npmkids = cfg->pmk_list->pmkids.count;
 
+	ASSERT(cfg->pmk_list->pmkids.length >= (sizeof(u16)*2));
 	if (!pmk_list) {
 		WL_MSG(dev->name, "pmk_list is NULL\n");
 		return -EINVAL;
@@ -7095,22 +7101,110 @@ wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
 		return err;
 	}
 
-	WL_DBG(("No of elements %d\n", pmk_list->pmkids.npmkid));
-	for (i = 0; i < pmk_list->pmkids.npmkid; i++) {
+	WL_DBG(("No of elements %d\n", npmkids));
+	for (i = 0; i < npmkids; i++) {
 		WL_DBG(("PMKID[%d]: %pM =\n", i,
-			&pmk_list->pmkids.pmkid[i].BSSID));
+			&pmk_list->pmkids.pmkid[i].bssid));
 		for (j = 0; j < WPA2_PMKID_LEN; j++) {
-			WL_DBG(("%02x\n", pmk_list->pmkids.pmkid[i].PMKID[j]));
+			WL_DBG(("%02x\n", pmk_list->pmkids.pmkid[i].pmkid[j]));
 		}
 	}
-	if (likely(!err)) {
-		err = wldev_iovar_setbuf(dev, "pmkid_info", (char *)pmk_list,
-			sizeof(*pmk_list), cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+	if (cfg->wlc_ver.wlc_ver_major >= MIN_PMKID_LIST_V3_FW_MAJOR) {
+			pmk_list->pmkids.version = PMKID_LIST_VER_3;
+			err = wldev_iovar_setbuf(dev, "pmkid_info", (char *)pmk_list,
+				sizeof(*pmk_list), cfg->ioctl_buf,
+				WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+	}
+	else if (cfg->wlc_ver.wlc_ver_major == MIN_PMKID_LIST_V2_FW_MAJOR) {
+		u32 v2_list_size = (u32)(sizeof(pmkid_list_v2_t) + npmkids*sizeof(pmkid_v2_t));
+		pmkid_list_v2_t *pmkid_v2_list = (pmkid_list_v2_t *)MALLOCZ(cfg->osh, v2_list_size);
+
+		if (pmkid_v2_list == NULL) {
+			WL_ERR(("failed to allocate pmkid list\n"));
+			return BCME_NOMEM;
+		}
+
+		pmkid_v2_list->version = PMKID_LIST_VER_2;
+		/* Account for version, length and pmkid_v2_t fields */
+		pmkid_v2_list->length = (npmkids * sizeof(pmkid_v2_t)) + (2 * sizeof(u16));
+
+		for (i = 0; i < npmkids; i++) {
+			/* memcpy_s return checks not needed as buffers are of same size */
+			(void)memcpy_s(&pmkid_v2_list->pmkid[i].BSSID,
+					ETHER_ADDR_LEN, &pmk_list->pmkids.pmkid[i].bssid,
+					ETHER_ADDR_LEN);
+
+			/* copy pmkid if available */
+			if (pmk_list->pmkids.pmkid[i].pmkid_len) {
+				(void)memcpy_s(pmkid_v2_list->pmkid[i].PMKID,
+						WPA2_PMKID_LEN,
+						pmk_list->pmkids.pmkid[i].pmkid,
+						pmk_list->pmkids.pmkid[i].pmkid_len);
+			}
+
+			if (pmk_list->pmkids.pmkid[i].pmk_len) {
+				(void)memcpy_s(pmkid_v2_list->pmkid[i].pmk,
+						pmk_list->pmkids.pmkid[i].pmk_len,
+						pmk_list->pmkids.pmkid[i].pmk,
+						pmk_list->pmkids.pmkid[i].pmk_len);
+				pmkid_v2_list->pmkid[i].pmk_len = pmk_list->pmkids.pmkid[i].pmk_len;
+			}
+
+			if (pmk_list->pmkids.pmkid[i].ssid_len) {
+				(void)memcpy_s(pmkid_v2_list->pmkid[i].ssid.ssid,
+						pmk_list->pmkids.pmkid[i].ssid_len,
+						pmk_list->pmkids.pmkid[i].ssid,
+						pmk_list->pmkids.pmkid[i].ssid_len);
+				pmkid_v2_list->pmkid[i].ssid.ssid_len
+					= pmk_list->pmkids.pmkid[i].ssid_len;
+			}
+
+			(void)memcpy_s(pmkid_v2_list->pmkid[i].fils_cache_id,
+					FILS_CACHE_ID_LEN, &pmk_list->pmkids.pmkid[i].fils_cache_id,
+					FILS_CACHE_ID_LEN);
+			pmkid_v2_list->pmkid[i].length = PMKID_ELEM_V2_LENGTH;
+		}
+		err = wldev_iovar_setbuf(dev, "pmkid_info", (char *)pmkid_v2_list,
+				v2_list_size, cfg->ioctl_buf,
+				WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+		if (unlikely(err)) {
+			WL_ERR(("pmkid_info failed (%d)\n", err));
+		}
+
+		MFREE(cfg->osh, pmkid_v2_list, v2_list_size);
 	}
+	else {
+		u32 v1_list_size = (u32)(sizeof(pmkid_list_v1_t) + npmkids*sizeof(pmkid_v1_t));
+		pmkid_list_v1_t *pmkid_v1_list = (pmkid_list_v1_t *)MALLOCZ(cfg->osh, v1_list_size);
+		if (pmkid_v1_list == NULL) {
+			WL_ERR(("failed to allocate pmkid list\n"));
+			return BCME_NOMEM;
+		}
+		for (i = 0; i < npmkids; i++) {
+			/* memcpy_s return checks not needed as buffers are of same size */
+			(void)memcpy_s(&pmkid_v1_list->pmkid[i].BSSID,
+					ETHER_ADDR_LEN, &pmk_list->pmkids.pmkid[i].bssid,
+					ETHER_ADDR_LEN);
+			(void)memcpy_s(pmkid_v1_list->pmkid[i].PMKID,
+					WPA2_PMKID_LEN, pmk_list->pmkids.pmkid[i].pmkid,
+					WPA2_PMKID_LEN);
+			pmkid_v1_list->npmkid++;
+		}
+		err = wldev_iovar_setbuf(dev, "pmkid_info", (char *)pmkid_v1_list,
+				v1_list_size, cfg->ioctl_buf,
+				WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+		if (unlikely(err)) {
+			WL_ERR(("pmkid_info failed (%d)\n", err));
+		}
 
+		MFREE(cfg->osh, pmkid_v1_list, v1_list_size);
+	}
 	return err;
 }
 
+/* TODO: remove temporal cfg->pmk_list list, and call wl_cfg80211_update_pmksa for single
+ * entry operation.
+ */
 static s32
 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_pmksa *pmksa)
@@ -7118,90 +7212,278 @@ wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
 	s32 err = 0;
 	int i;
+	int npmkids = cfg->pmk_list->pmkids.count;
+	dhd_pub_t *dhdp = (dhd_pub_t *)(cfg->pub);
 
 	RETURN_EIO_IF_NOT_UP(cfg);
-	for (i = 0; i < cfg->pmk_list->pmkids.npmkid; i++)
-		if (!memcmp(pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].BSSID,
-			ETHER_ADDR_LEN))
-			break;
+	BCM_REFERENCE(dhdp);
+
+	for (i = 0; i < npmkids; i++) {
+		if (pmksa->bssid != NULL) {
+			if (!memcmp(pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].bssid,
+				ETHER_ADDR_LEN))
+				break;
+		}
+#ifdef WL_FILS
+		else if (pmksa->ssid != NULL) {
+			if (!memcmp(pmksa->ssid, &cfg->pmk_list->pmkids.pmkid[i].ssid,
+				pmksa->ssid_len))
+				break;
+		}
+#endif /* WL_FILS */
+	}
 	if (i < WL_NUM_PMKIDS_MAX) {
-		memcpy(&cfg->pmk_list->pmkids.pmkid[i].BSSID, pmksa->bssid,
-			ETHER_ADDR_LEN);
-		memcpy(&cfg->pmk_list->pmkids.pmkid[i].PMKID, pmksa->pmkid,
+		if (pmksa->bssid != NULL) {
+			memcpy(&cfg->pmk_list->pmkids.pmkid[i].bssid, pmksa->bssid,
+				ETHER_ADDR_LEN);
+		}
+#ifdef WL_FILS
+		else if (pmksa->ssid != NULL) {
+			cfg->pmk_list->pmkids.pmkid[i].ssid_len = pmksa->ssid_len;
+			memcpy(&cfg->pmk_list->pmkids.pmkid[i].ssid, pmksa->ssid,
+				pmksa->ssid_len);
+			memcpy(&cfg->pmk_list->pmkids.pmkid[i].fils_cache_id, pmksa->cache_id,
+				FILS_CACHE_ID_LEN);
+		}
+#endif /* WL_FILS */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0) || defined(WL_FILS))
+		if (pmksa->pmk_len) {
+			if (memcpy_s(&cfg->pmk_list->pmkids.pmkid[i].pmk, PMK_LEN_MAX, pmksa->pmk,
+				pmksa->pmk_len)) {
+				WL_ERR(("invalid pmk len = %zu", pmksa->pmk_len));
+			} else {
+				cfg->pmk_list->pmkids.pmkid[i].pmk_len = pmksa->pmk_len;
+			}
+		}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0) || defined(WL_FILS) */
+		/* return check not required as buffer lengths are same */
+		(void)memcpy_s(cfg->pmk_list->pmkids.pmkid[i].pmkid, WPA2_PMKID_LEN, pmksa->pmkid,
 			WPA2_PMKID_LEN);
-		if (i == cfg->pmk_list->pmkids.npmkid)
-			cfg->pmk_list->pmkids.npmkid++;
+		cfg->pmk_list->pmkids.pmkid[i].pmkid_len = WPA2_PMKID_LEN;
+
+		/* set lifetime not to expire in firmware by default.
+		 * Currently, wpa_supplicant control PMKID lifetime on his end. e.g) set 12 hours
+		 * when it expired, wpa_supplicant should call set_pmksa/del_pmksa to update
+		 * corresponding entry.
+		 */
+		cfg->pmk_list->pmkids.pmkid[i].time_left = KEY_PERM_PMK;
+		if (i == npmkids) {
+			cfg->pmk_list->pmkids.length += sizeof(pmkid_v3_t);
+			cfg->pmk_list->pmkids.count++;
+		}
 	} else {
 		err = -EINVAL;
 	}
-	WL_DBG(("set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",
-		&cfg->pmk_list->pmkids.pmkid[cfg->pmk_list->pmkids.npmkid - 1].BSSID));
+
+#if (WL_DBG_LEVEL > 0)
+	if (pmksa->bssid != NULL) {
+		WL_DBG(("set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",
+			&cfg->pmk_list->pmkids.pmkid[npmkids - 1].bssid));
+	}
 	for (i = 0; i < WPA2_PMKID_LEN; i++) {
 		WL_DBG(("%02x\n",
-			cfg->pmk_list->pmkids.pmkid[cfg->pmk_list->pmkids.npmkid - 1].
-			PMKID[i]));
+			cfg->pmk_list->pmkids.pmkid[npmkids - 1].
+			pmkid[i]));
 	}
+#endif /* (WL_DBG_LEVEL > 0) */
 
 	err = wl_update_pmklist(dev, cfg->pmk_list, err);
 
 	return err;
 }
 
+/* sending pmkid_info IOVAR to manipulate PMKID(PMKSA) list in firmware.
+ * input @pmksa: host given single pmksa info.
+ * if it's NULL, assume whole list manipulated. e.g) flush all PMKIDs in firmware.
+ * input @set: TRUE means adding PMKSA operation. FALSE means deleting.
+ * return: log internal BCME_XXX error, and convert it to -EINVAL to linux generic error code.
+ */
+static s32 wl_cfg80211_update_pmksa(struct wiphy *wiphy, struct net_device *dev,
+	struct cfg80211_pmksa *pmksa, bool set) {
+
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	s32 err = 0;
+	pmkid_list_v3_t *pmk_list;
+	uint32 alloc_len;
+
+	RETURN_EIO_IF_NOT_UP(cfg);
+
+	if (cfg->wlc_ver.wlc_ver_major < MIN_PMKID_LIST_V3_FW_MAJOR) {
+		WL_ERR(("wlc_ver_major not supported:%d\n", cfg->wlc_ver.wlc_ver_major));
+		return BCME_VERSION;
+	}
+
+	alloc_len = (uint32) OFFSETOF(pmkid_list_v3_t, pmkid) + ((pmksa) ? sizeof(pmkid_v3_t) : 0);
+	pmk_list = (pmkid_list_v3_t *)MALLOCZ(cfg->osh, alloc_len);
+
+	if (pmk_list == NULL) {
+		return BCME_NOMEM;
+	}
+
+	pmk_list->version = PMKID_LIST_VER_3;
+	pmk_list->length = alloc_len;
+	pmk_list->count = (pmksa) ? 1 : 0; // 1 means single entry operation, 0 means whole list.
+
+	/* controll set/del action by lifetime parameter accordingly.
+	 * if set == TRUE, it's set PMKID action with lifetime permanent.
+	 * if set == FALSE, it's del PMKID action with lifetime zero.
+	 */
+	pmk_list->pmkid->time_left = (set) ? KEY_PERM_PMK : 0;
+
+	if (pmksa) {
+		if (pmksa->bssid) {
+			err = memcpy_s(&pmk_list->pmkid->bssid, sizeof(pmk_list->pmkid->bssid),
+				pmksa->bssid, ETHER_ADDR_LEN);
+			if (err) {
+				goto exit;
+			}
+		}
+		if (pmksa->pmkid) {
+			err = memcpy_s(&pmk_list->pmkid->pmkid, sizeof(pmk_list->pmkid->pmkid),
+				pmksa->pmkid, WPA2_PMKID_LEN);
+			if (err) {
+				goto exit;
+			}
+		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+		if (pmksa->pmk) {
+			err = memcpy_s(&pmk_list->pmkid->pmk, sizeof(pmk_list->pmkid->pmk),
+				pmksa->pmk, pmksa->pmk_len);
+			if (err) {
+				goto exit;
+			}
+			pmk_list->pmkid->pmk_len = pmksa->pmk_len;
+		}
+		if (pmksa->ssid) {
+			err = memcpy_s(&pmk_list->pmkid->ssid, sizeof(pmk_list->pmkid->ssid),
+				pmksa->ssid, pmksa->ssid_len);
+			if (err) {
+				goto exit;
+			}
+			pmk_list->pmkid->ssid_len = pmksa->ssid_len;
+		}
+		if (pmksa->cache_id) {
+			pmk_list->pmkid->fils_cache_id = *(uint16 *)pmksa->cache_id;
+		}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0) */
+	}
+	err = wldev_iovar_setbuf(dev, "pmkid_info", (char *)pmk_list,
+		alloc_len, cfg->ioctl_buf,
+		WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+
+exit:
+	if (pmk_list) {
+		MFREE(cfg->osh, pmk_list, alloc_len);
+	}
+	return err;
+}
+
+/* TODO: remove temporal cfg->pmk_list list, and call wl_cfg80211_update_pmksa for single
+ * entry operation.
+ */
 static s32
 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_pmksa *pmksa)
 {
 	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
-
-	struct _pmkid_list pmkid = {.npmkid = 0};
 	s32 err = 0;
 	int i;
-
+	int npmkids = cfg->pmk_list->pmkids.count;
 	RETURN_EIO_IF_NOT_UP(cfg);
-	memcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETHER_ADDR_LEN);
-	memcpy(pmkid.pmkid[0].PMKID, pmksa->pmkid, WPA2_PMKID_LEN);
 
-	WL_DBG(("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
-		&pmkid.pmkid[0].BSSID));
-	for (i = 0; i < WPA2_PMKID_LEN; i++) {
-		WL_DBG(("%02x\n", pmkid.pmkid[0].PMKID[i]));
+	if (!pmksa) {
+		WL_ERR(("pmksa is not initialized\n"));
+		return BCME_ERROR;
+	}
+	if (!npmkids) {
+		/* nmpkids = 0, nothing to delete */
+		WL_DBG(("npmkids=0. Skip del\n"));
+		return BCME_OK;
 	}
 
-	for (i = 0; i < cfg->pmk_list->pmkids.npmkid; i++)
-		if (!memcmp
-		    (pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].BSSID,
-		     ETHER_ADDR_LEN))
-			break;
+#if (WL_DBG_LEVEL > 0)
+	if (pmksa->bssid) {
+		WL_DBG(("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
+			pmksa->bssid));
+	}
+#ifdef WL_FILS
+	else if (pmksa->ssid) {
+		WL_DBG(("FILS: del_pmksa for ssid: "));
+		for (i = 0; i < pmksa->ssid_len; i++) {
+			WL_DBG(("%c", pmksa->ssid[i]));
+		}
+		WL_DBG(("\n"));
+	}
+#endif /* WL_FILS */
+	if (pmksa->pmkid) {
+		for (i = 0; i < WPA2_PMKID_LEN; i++) {
+			WL_DBG(("%02x\n", pmksa->pmkid[i]));
+		}
+	}
+#endif /* (WL_DBG_LEVEL > 0) */
 
-	if ((cfg->pmk_list->pmkids.npmkid > 0) &&
-		(i < cfg->pmk_list->pmkids.npmkid)) {
-		memset(&cfg->pmk_list->pmkids.pmkid[i], 0, sizeof(pmkid_t));
-		for (; i < (cfg->pmk_list->pmkids.npmkid - 1); i++) {
-			memcpy(&cfg->pmk_list->pmkids.pmkid[i].BSSID,
-				&cfg->pmk_list->pmkids.pmkid[i + 1].BSSID,
-				ETHER_ADDR_LEN);
-			memcpy(&cfg->pmk_list->pmkids.pmkid[i].PMKID,
-				&cfg->pmk_list->pmkids.pmkid[i + 1].PMKID,
-				WPA2_PMKID_LEN);
+	for (i = 0; i < npmkids; i++) {
+		if (pmksa->bssid) {
+			if (!memcmp
+			    (pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].bssid,
+			     ETHER_ADDR_LEN)) {
+					break;
+			}
 		}
-		cfg->pmk_list->pmkids.npmkid--;
+#ifdef WL_FILS
+		else if (pmksa->ssid) {
+			if (!memcmp
+			    (pmksa->ssid, &cfg->pmk_list->pmkids.pmkid[i].ssid,
+			     pmksa->ssid_len)) {
+					break;
+			}
+		}
+#endif /* WL_FILS */
+	}
+	if ((npmkids > 0) && (i < npmkids)) {
+		bzero(&cfg->pmk_list->pmkids.pmkid[i], sizeof(pmkid_v3_t));
+		for (; i < (npmkids - 1); i++) {
+			(void)memcpy_s(&cfg->pmk_list->pmkids.pmkid[i],
+				sizeof(pmkid_v3_t),
+				&cfg->pmk_list->pmkids.pmkid[i + 1],
+				sizeof(pmkid_v3_t));
+		}
+		npmkids--;
+		cfg->pmk_list->pmkids.length -= sizeof(pmkid_v3_t);
+		cfg->pmk_list->pmkids.count--;
+
 	} else {
 		err = -EINVAL;
 	}
 
+	/* current wl_update_pmklist() doesn't delete corresponding PMKID entry.
+	 * inside firmware. So we need to issue delete action explicitely through
+	 * this function.
+	 */
+	err = wl_cfg80211_update_pmksa(wiphy, dev, pmksa, FALSE);
+	/* intentional fall through even on error.
+	 * it should work above MIN_PMKID_LIST_V3_FW_MAJOR, otherwise let ignore it.
+	 */
+
 	err = wl_update_pmklist(dev, cfg->pmk_list, err);
 
 	return err;
 
 }
 
+/* TODO: remove temporal cfg->pmk_list list, and call wl_cfg80211_update_pmksa for single
+ * entry operation.
+ */
 static s32
 wl_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev)
 {
 	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
 	s32 err = 0;
 	RETURN_EIO_IF_NOT_UP(cfg);
-	memset(cfg->pmk_list, 0, sizeof(*cfg->pmk_list));
+	bzero(cfg->pmk_list, sizeof(*cfg->pmk_list));
+	cfg->pmk_list->pmkids.length = OFFSETOF(pmkid_list_v3_t, pmkid);
+	cfg->pmk_list->pmkids.count = 0;
+	cfg->pmk_list->pmkids.version = PMKID_LIST_VER_3;
 	err = wl_update_pmklist(dev, cfg->pmk_list, err);
 	return err;
 }
@@ -8161,7 +8443,39 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, bcm_struct_cfgdev *cfgdev,
 			wl_notify_escan_complete(cfg, dev, true, true);
 #endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 		}
+#ifdef WL_CLIENT_SAE
+		else if (ieee80211_is_auth(mgmt->frame_control)) {
+			int err = 0;
+			wl_assoc_mgr_cmd_t *cmd;
+			char *ambuf = NULL;
+			int param_len;
 
+			ack = true;
+			if ((dev == bcmcfg_to_prmry_ndev(cfg)) && cfg->p2p) {
+				bssidx = wl_to_p2p_bss_bssidx(cfg, P2PAPI_BSSCFG_DEVICE);
+			}
+			param_len = sizeof(wl_assoc_mgr_cmd_t) + len;
+			ambuf = MALLOCZ(cfg->osh, param_len);
+			if (ambuf == NULL) {
+				WL_ERR(("unable to allocate frame\n"));
+				return -ENOMEM;
+			}
+			cmd = (wl_assoc_mgr_cmd_t*)ambuf;
+			cmd->version = WL_ASSOC_MGR_CURRENT_VERSION;
+			cmd->length = len;
+			cmd->cmd = WL_ASSOC_MGR_CMD_SEND_AUTH;
+			memcpy(&cmd->params, buf, len);
+			err = wldev_iovar_setbuf(dev, "assoc_mgr_cmd", ambuf, param_len,
+				cfg->ioctl_buf, WLC_IOCTL_SMLEN, &cfg->ioctl_buf_sync);
+			if (unlikely(err)) {
+				WL_ERR(("Failed to send auth(%d)\n", err));
+				ack = false;
+			}
+			MFREE(cfg->osh, ambuf, param_len);
+			cfg80211_mgmt_tx_status(cfgdev, *cookie, buf, len, ack, GFP_KERNEL);
+			goto exit;
+		}
+#endif /* WL_CLIENT_SAE */
 	} else {
 		WL_ERR(("Driver only allows MGMT packet type\n"));
 		goto exit;
@@ -8614,12 +8928,12 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 			wpa_auth |= WPA2_AUTH_1X_SHA256;
 			break;
 #endif /* MFP */
-#ifdef WL_SAE
+#if defined(WL_SAE) || defined(WL_CLIENT_SAE)
 		case RSN_AKM_SAE_PSK:
 		case RSN_AKM_SAE_FBT:
 			wpa_auth |= WPA3_AUTH_SAE_PSK;
 			break;
-#endif /* WL_SAE */
+#endif /* WL_SAE || WL_CLIENT_SAE */
 		default:
 			WL_ERR(("No Key Mgmt Info\n"));
 		}
@@ -9459,8 +9773,7 @@ wl_cfg80211_bcn_bringup_ap(
 				WLC_IOCTL_SMLEN, bssidx, &cfg->ioctl_buf_sync);
 			if (err < 0) {
 				WL_ERR(("bip set error %d\n", err));
-				if (wl_customer6_legacy_chip_check(cfg,
-					bcmcfg_to_prmry_ndev(cfg))) {
+				if (wl_legacy_chip_check(cfg)) {
 					/* Ignore bip error: Some older firmwares doesn't
 					 * support bip iovar/ return BCME_NOTUP while trying
 					 * to set bip from AP bring up context. These firmares
@@ -9828,7 +10141,7 @@ wl_cfg80211_del_station(
 			return -EFAULT;
 		}
 	}
-	err = wl_cfg80211_check_in4way(cfg, ndev, DONT_DELETE_GC_AFTER_WPS,
+	err = wl_ext_in4way_sync(ndev, AP_WAIT_STA_RECONNECT,
 		WL_EXT_STATUS_DELETE_STA, (void *)mac_addr);
 	if (err) {
 		return 0;
@@ -10151,6 +10464,9 @@ wl_cfg80211_start_ap(
 		WL_ERR(("ADD/SET beacon failed\n"));
 		wl_cfg80211_stop_ap(wiphy, dev);
 		if (dev_role == NL80211_IFTYPE_AP) {
+#ifdef WL_EXT_IAPSTA
+		if (!wl_ext_iapsta_iftype_enabled(dev, WLC_E_IF_ROLE_AP)) {
+#endif /* WL_EXT_IAPSTA */
 			dhd->op_mode &= ~DHD_FLAG_HOSTAP_MODE;
 #ifdef PKT_FILTER_SUPPORT
 			/* Enable packet filter */
@@ -10166,6 +10482,9 @@ wl_cfg80211_start_ap(
 				dhd_arp_offload_enable(dhd, TRUE);
 			}
 #endif /* ARP_OFFLOAD_SUPPORT */
+#ifdef WL_EXT_IAPSTA
+		}
+#endif /* WL_EXT_IAPSTA */
 		}
 #ifdef WLTDLS
 		if (bssidx == 0) {
@@ -10280,8 +10599,14 @@ wl_cfg80211_stop_ap(
 #endif /* WLTDLS */
 
 	if (dev_role == NL80211_IFTYPE_AP) {
+#ifdef WL_EXT_IAPSTA
+		if (!wl_ext_iapsta_iftype_enabled(dev, WLC_E_IF_ROLE_AP)) {
+#endif /* WL_EXT_IAPSTA */
 		/* clear the AP mode */
 		dhd->op_mode &= ~DHD_FLAG_HOSTAP_MODE;
+#ifdef WL_EXT_IAPSTA
+		}
+#endif /* WL_EXT_IAPSTA */
 	}
 #ifdef SUPPORT_SET_CAC
 	wl_cfg80211_set_cac(cfg, 1);
@@ -10531,8 +10856,14 @@ wl_cfg80211_add_set_beacon(struct wiphy *wiphy, struct net_device *dev,
 	if (err) {
 		WL_ERR(("ADD/SET beacon failed\n"));
 		if (dev_role == NL80211_IFTYPE_AP) {
+#ifdef WL_EXT_IAPSTA
+		if (!wl_ext_iapsta_iftype_enabled(dev, WL_IF_TYPE_AP)) {
+#endif /* WL_EXT_IAPSTA */
 			/* clear the AP mode */
 			dhd->op_mode &= ~DHD_FLAG_HOSTAP_MODE;
+#ifdef WL_EXT_IAPSTA
+		}
+#endif /* WL_EXT_IAPSTA */
 		}
 	}
 	return err;
@@ -10587,8 +10918,14 @@ wl_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev)
 	 wl_cfg80211_clear_per_bss_ies(cfg, bssidx);
 
 	if (wdev->iftype == NL80211_IFTYPE_AP) {
+#ifdef WL_EXT_IAPSTA
+		if (!wl_ext_iapsta_iftype_enabled(dev, WL_IF_TYPE_AP)) {
+#endif /* WL_EXT_IAPSTA */
 		/* clear the AP mode */
 		dhd->op_mode &= ~DHD_FLAG_HOSTAP_MODE;
+#ifdef WL_EXT_IAPSTA
+		}
+#endif /* WL_EXT_IAPSTA */
 	}
 
 	return 0;
@@ -11055,6 +11392,9 @@ static struct cfg80211_ops wl_cfg80211_ops = {
 	.set_rekey_data = wl_cfg80211_set_rekey_data,
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0) */
 #endif /* GTK_OFFLOAD_SUPPORT */
+#ifdef WL_CLIENT_SAE
+	.external_auth = wl_cfg80211_external_auth,
+#endif /* WL_CLIENT_SAE */
 };
 
 s32 wl_mode_to_nl80211_iftype(s32 mode)
@@ -11361,10 +11701,9 @@ static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev
 	wdev->wiphy->flags &= ~WIPHY_FLAG_ENFORCE_COMBINATIONS;
 #endif
 
-#ifdef WL_SAE
-	WL_ERR(("SAE support\n"));
+#if defined(WL_SAE) || defined(WL_CLIENT_SAE)
 	wdev->wiphy->features |= NL80211_FEATURE_SAE;
-#endif /* WL_SAE */
+#endif /* WL_SAE || WL_CLIENT_SAE */
 
 	return err;
 }
@@ -11974,62 +12313,159 @@ wl_get_auth_assoc_status(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	return 0;
 }
 
-/* The mainline kernel >= 3.2.0 has support for indicating new/del station
- * to AP/P2P GO via events. If this change is backported to kernel for which
- * this driver is being built, then define WL_CFG80211_STA_EVENT. You
- * should use this new/del sta event mechanism for BRCM supplicant >= 22.
- */
+#ifdef WL_CLIENT_SAE
 static s32
-wl_notify_connect_status_ap(struct bcm_cfg80211 *cfg, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+wl_notify_connect_status_ap_auth(struct bcm_cfg80211 *cfg,
+	struct net_device *ndev, const wl_event_msg_t *e, void *data)
 {
-	s32 err = 0;
-	u32 event = ntoh32(e->event_type);
-	u32 reason = ntoh32(e->reason);
-	u32 len = ntoh32(e->datalen);
-	u32 status = ntoh32(e->status);
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
-	bool isfree = false;
-	u8 *mgmt_frame;
+	bcm_struct_cfgdev *cfgdev = ndev_to_cfgdev(ndev);
+	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
 	u8 bsscfgidx = e->bsscfgidx;
-	s32 freq;
-	s32 channel;
+	u8 *mgmt_frame = NULL;
 	u8 *body = NULL;
-	u16 fc = 0;
-
+	u32 body_len = 0;
+	s32 chan;
+	u16 channel;
 	struct ieee80211_supported_band *band;
+	chanspec_t chanspec;
+	s32 freq;
 	struct ether_addr da;
 	struct ether_addr bssid;
-	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
-	channel_info_t ci;
-#else
-	struct station_info sinfo;
-#endif 
+	u32 event = ntoh32(e->event_type);
+	u32 reason = ntoh32(e->reason);
+	u32 len = ntoh32(e->datalen);
+	s32 err = 0;
 
-	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
-#ifdef WL_SAE
-	if (event == WLC_E_AUTH_IND)
-		wl_get_auth_assoc_status(cfg, ndev, e, data);
-#endif /* WL_SAE */
-	/* if link down, bsscfg is disabled. */
-	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
-		wl_get_p2p_status(cfg, IF_DELETING) && (ndev != bcmcfg_to_prmry_ndev(cfg))) {
-		wl_add_remove_eventmsg(ndev, WLC_E_PROBREQ_MSG, false);
-		WL_MSG(ndev->name, "AP mode link down !! \n");
-		complete(&cfg->iface_disable);
+	if (!len) {
+		WL_ERR(("event %s(%d) has no payload. status %d reason %d\n",
+			bcmevent_get_name(event), event, ntoh32(e->status), reason));
 		return 0;
 	}
 
-	if ((event == WLC_E_LINK) && (status == WLC_E_STATUS_SUCCESS) &&
-		(reason == WLC_E_REASON_INITIAL_ASSOC) &&
+	body = (u8 *)MALLOCZ(cfg->osh, len);
+	if (body == NULL) {
+		WL_ERR(("Failed to allocate body\n"));
+		return WL_INVALID;
+	}
+	(void)memcpy_s(body, len, data, len);
+
+	err = wldev_iovar_getbuf_bsscfg(ndev, "cur_etheraddr",
+		NULL, 0, cfg->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &cfg->ioctl_buf_sync);
+	if (unlikely(err)) {
+		WL_ERR(("Could not get cur_etheraddr %d\n", err));
+		goto exit;
+	}
+	(void)memcpy_s(da.octet, ETHER_ADDR_LEN, cfg->ioctl_buf, ETHER_ADDR_LEN);
+
+	bzero(&bssid, sizeof(bssid));
+	err = wldev_ioctl_get(ndev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN);
+	if (unlikely(err)) {
+		WL_ERR(("Could not get bssid %d\n", err));
+		goto exit;
+	}
+
+	err = wldev_iovar_getint(ndev, "chanspec", &chan);
+	if (unlikely(err)) {
+		WL_ERR(("Could not get chanspec %d\n", err));
+		goto exit;
+	}
+	chanspec = wl_chspec_driver_to_host(chan);
+	channel = wf_chspec_ctlchan(chanspec);
+
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	if (!band) {
+		WL_ERR(("No valid band\n"));
+		goto exit;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39) && !defined(WL_COMPAT_WIRELESS)
+	freq = ieee80211_channel_to_frequency(channel);
+#else
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+#endif
+
+	body_len = len;
+	err = wl_frame_get_mgmt(FC_AUTH, &da, &e->addr, &bssid,
+		&mgmt_frame, &len, body);
+	if (!err) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(cfgdev, freq, 0, mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif
+		MFREE(cfg->osh, mgmt_frame, len);
+	}
+
+exit:
+	if (body) {
+		MFREE(cfg->osh, body, body_len);
+	}
+
+	return err;
+}
+#endif /* WL_CLIENT_SAE */
+
+/* The mainline kernel >= 3.2.0 has support for indicating new/del station
+ * to AP/P2P GO via events. If this change is backported to kernel for which
+ * this driver is being built, then define WL_CFG80211_STA_EVENT. You
+ * should use this new/del sta event mechanism for BRCM supplicant >= 22.
+ */
+static s32
+wl_notify_connect_status_ap(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	s32 err = 0;
+	u32 event = ntoh32(e->event_type);
+	u32 reason = ntoh32(e->reason);
+	u32 len = ntoh32(e->datalen);
+	u32 status = ntoh32(e->status);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
+	bool isfree = false;
+	u8 *mgmt_frame;
+	u8 bsscfgidx = e->bsscfgidx;
+	s32 freq;
+	s32 channel;
+	u8 *body = NULL;
+	u16 fc = 0;
+
+	struct ieee80211_supported_band *band;
+	struct ether_addr da;
+	struct ether_addr bssid;
+	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
+	channel_info_t ci;
+#else
+	struct station_info sinfo;
+#endif 
+
+	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
+#ifdef WL_SAE
+	if (event == WLC_E_AUTH_IND)
+		wl_get_auth_assoc_status(cfg, ndev, e, data);
+#endif /* WL_SAE */
+	/* if link down, bsscfg is disabled. */
+	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
+		wl_get_p2p_status(cfg, IF_DELETING) && (ndev != bcmcfg_to_prmry_ndev(cfg))) {
+		wl_add_remove_eventmsg(ndev, WLC_E_PROBREQ_MSG, false);
+		WL_MSG(ndev->name, "AP mode link down !! \n");
+		complete(&cfg->iface_disable);
+		return 0;
+	}
+
+	if ((event == WLC_E_LINK) && (status == WLC_E_STATUS_SUCCESS) &&
+		(reason == WLC_E_REASON_INITIAL_ASSOC) &&
 		(wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_AP)) {
 		if (!wl_get_drv_status(cfg, AP_CREATED, ndev)) {
 			/* AP/GO brought up successfull in firmware */
 			WL_MSG(ndev->name, "AP/GO Link up\n");
 			wl_set_drv_status(cfg, AP_CREATED, ndev);
 			wake_up_interruptible(&cfg->netif_change_event);
-			wl_cfg80211_check_in4way(cfg, ndev, 0, WL_EXT_STATUS_AP_ENABLED, NULL);
+			wl_ext_in4way_sync(ndev, 0, WL_EXT_STATUS_AP_ENABLED, NULL);
 			return 0;
 		}
 	}
@@ -12156,22 +12592,33 @@ wl_notify_connect_status_ap(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 		sinfo.assoc_req_ies = data;
 		sinfo.assoc_req_ies_len = len;
 		WL_MSG(ndev->name, "connected device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
-		wl_cfg80211_check_in4way(cfg, ndev, DONT_DELETE_GC_AFTER_WPS,
-			WL_EXT_STATUS_STA_CONNECTED, NULL);
+		wl_ext_in4way_sync(ndev, AP_WAIT_STA_RECONNECT,
+			WL_EXT_STATUS_STA_CONNECTED, (void *)&e->addr);
 		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
 	} else if (event == WLC_E_DISASSOC_IND) {
 		WL_MSG(ndev->name, "disassociated device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
-		wl_cfg80211_check_in4way(cfg, ndev, DONT_DELETE_GC_AFTER_WPS,
-			WL_EXT_STATUS_STA_DISCONNECTED, NULL);
+		wl_ext_in4way_sync(ndev, AP_WAIT_STA_RECONNECT,
+			WL_EXT_STATUS_STA_DISCONNECTED, (void *)&e->addr);
 		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
 	} else if ((event == WLC_E_DEAUTH_IND) ||
 		((event == WLC_E_DEAUTH) && (reason != DOT11_RC_RESERVED))) {
 		WL_MSG_RLMT(ndev->name, &e->addr, ETHER_ADDR_LEN,
 			"deauthenticated device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
-		wl_cfg80211_check_in4way(cfg, ndev, DONT_DELETE_GC_AFTER_WPS,
-			WL_EXT_STATUS_STA_DISCONNECTED, NULL);
+		wl_ext_in4way_sync(ndev, AP_WAIT_STA_RECONNECT,
+			WL_EXT_STATUS_STA_DISCONNECTED, (void *)&e->addr);
 		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
 	}
+#ifdef WL_CLIENT_SAE
+	else if (event == WLC_E_AUTH) {
+		WL_MSG_RLMT(ndev->name, &e->addr, ETHER_ADDR_LEN,
+			"add sta auth event for "MACDBG "\n", MAC2STRDBG(e->addr.octet));
+		if (wl_get_mode_by_netdev(cfg, ndev) == WL_INVALID) {
+			WL_ERR(("invalid mode\n"));
+			return WL_INVALID;
+		}
+		err = wl_notify_connect_status_ap_auth(cfg, ndev, e, data);
+	}
+#endif /* WL_CLIENT_SAE */
 #endif 
 	return err;
 }
@@ -12239,6 +12686,217 @@ s32 wl_cfg80211_get_connect_failed_status(struct net_device *dev, char* cmd, int
 }
 #endif /* DHD_ENABLE_BIGDATA_LOGGING */
 
+#ifdef WL_CLIENT_SAE
+static s32
+wl_notify_start_auth(struct bcm_cfg80211 *cfg,
+	bcm_struct_cfgdev *cfgdev, const wl_event_msg_t *e, void *data)
+{
+	struct cfg80211_external_auth_params ext_auth_param;
+	struct net_device *ndev = cfgdev_to_wlc_ndev(cfgdev, cfg);
+	u32 datalen = be32_to_cpu(e->datalen);
+	wl_ext_auth_evt_t *evt_data = (wl_ext_auth_evt_t *)data;
+	wl_assoc_mgr_cmd_t cmd;
+	int err;
+
+	WL_DBG(("Enter\n"));
+
+	if (!datalen || !data)
+		return BCME_ERROR;
+
+	ext_auth_param.ssid.ssid_len = MIN(evt_data->ssid.SSID_len, DOT11_MAX_SSID_LEN);
+	if (ext_auth_param.ssid.ssid_len)
+		memcpy(&ext_auth_param.ssid.ssid, evt_data->ssid.SSID,
+			ext_auth_param.ssid.ssid_len);
+
+	memcpy(&ext_auth_param.bssid, &evt_data->bssid, ETHER_ADDR_LEN);
+	ext_auth_param.action = NL80211_EXTERNAL_AUTH_START;
+	ext_auth_param.key_mgmt_suite = ntoh32(WLAN_AKM_SUITE_SAE_SHA256);
+
+	WL_MSG(ndev->name, "BSSID: "MACDBG"\n", MAC2STRDBG((u8*)(&evt_data->bssid)));
+
+	cfg80211_external_auth_request(ndev, &ext_auth_param, GFP_KERNEL);
+
+	cmd.version = WL_ASSOC_MGR_CURRENT_VERSION;
+	cmd.length = sizeof(cmd);
+	cmd.cmd = WL_ASSOC_MGR_CMD_PAUSE_ON_EVT;
+	cmd.params = WL_ASSOC_MGR_PARAMS_PAUSE_EVENT_AUTH_RESP;
+	err = wldev_iovar_setbuf(ndev, "assoc_mgr_cmd", (void *)&cmd, sizeof(cmd),
+		cfg->ioctl_buf, WLC_IOCTL_SMLEN, &cfg->ioctl_buf_sync);
+	if (unlikely(err)) {
+		WL_ERR(("Failed to pause assoc(%d)\n", err));
+	}
+
+	return BCME_OK;
+}
+
+static s32
+wl_notify_connect_status_bss(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	s32 err = 0;
+	u32 event = ntoh32(e->event_type);
+	u32 reason = ntoh32(e->reason);
+	u32 len = ntoh32(e->datalen);
+	u32 status = ntoh32(e->status);
+
+	bool isfree = false;
+	u8 *mgmt_frame;
+	u8 bsscfgidx = e->bsscfgidx;
+	s32 freq;
+	s32 channel;
+	u8 *body = NULL;
+	u16 fc = 0, rssi = 0;
+	bcm_struct_cfgdev *cfgdev = ndev_to_cfgdev(ndev);
+
+	struct ieee80211_supported_band *band;
+	struct ether_addr da;
+	struct ether_addr bssid;
+	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
+	channel_info_t ci;
+
+	WL_DBG(("event %d status %d reason %d\n", event, status, reason));
+
+	if (event == WLC_E_AUTH) {
+		struct wl_security *sec;
+		sec = wl_read_prof(cfg, ndev, WL_PROF_SEC);
+
+		if (!(sec->auth_type == NL80211_AUTHTYPE_SAE)) {
+			WL_DBG(("Abort AUTH processing due to NOT SAE\n"));
+			return 0;
+		} else {
+			if (status != WLC_E_STATUS_SUCCESS && !len) {
+				WL_ERR(("SAE AUTH FAIL EVENT\n"));
+				wl_ext_in4way_sync(ndev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+					WL_EXT_STATUS_DISCONNECTED, NULL);
+				return 0;
+			}
+		}
+	}
+
+	if (!len && (event == WLC_E_DEAUTH)) {
+		len = 2; /* reason code field */
+		data = &reason;
+	}
+
+	if (len) {
+		body = kzalloc(len, GFP_KERNEL);
+		if (body == NULL) {
+			WL_ERR(("wl_notify_connect_status: Failed to allocate body\n"));
+			return WL_INVALID;
+		}
+	}
+
+	memset(&bssid, 0, ETHER_ADDR_LEN);
+	if (wl_get_mode_by_netdev(cfg, ndev) == WL_INVALID) {
+		kfree(body);
+		return WL_INVALID;
+	}
+	if (len)
+		memcpy(body, data, len);
+
+	wldev_iovar_getbuf_bsscfg(ndev, "cur_etheraddr",
+		NULL, 0, cfg->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &cfg->ioctl_buf_sync);
+	memcpy(da.octet, cfg->ioctl_buf, ETHER_ADDR_LEN);
+	err = wldev_ioctl_get(ndev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN);
+	/* Use e->addr as bssid for Sta case , before association completed */
+	if (err == BCME_NOTASSOCIATED)
+		memcpy(&bssid, &e->addr, ETHER_ADDR_LEN);
+
+	switch (event) {
+		case WLC_E_ASSOC_IND:
+			fc = FC_ASSOC_REQ;
+			break;
+		case WLC_E_REASSOC_IND:
+			fc = FC_REASSOC_REQ;
+			break;
+		case WLC_E_DISASSOC_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_AUTH:
+			fc = FC_AUTH;
+			break;
+		default:
+			fc = 0;
+			goto exit;
+	}
+	if ((err = wldev_ioctl_get(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci)))) {
+		kfree(body);
+		return err;
+	}
+
+	channel = dtoh32(ci.hw_channel);
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	if (!band) {
+		WL_ERR(("No valid band\n"));
+		if (body)
+			kfree(body);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39)
+	freq = ieee80211_channel_to_frequency(channel);
+	(void)band->band;
+#else
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+#endif
+
+	err = wl_frame_get_mgmt(fc, &da, &e->addr, &bssid,
+		&mgmt_frame, &len, body);
+	if (err < 0) {
+		goto exit;
+	}
+	isfree = true;
+
+	if (event == WLC_E_ASSOC_IND && reason == DOT11_SC_SUCCESS) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(cfgdev, freq, rssi,  mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif
+	} else if (event == WLC_E_DISASSOC_IND) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(cfgdev, freq, rssi,  mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif
+	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(cfgdev, freq, rssi,  mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif
+	} else if (event == WLC_E_AUTH) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(cfgdev, freq, rssi,  mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif
+	}
+exit:
+	if (isfree)
+		kfree(mgmt_frame);
+	if (body)
+		kfree(body);
+	return err;
+}
+#endif /* WL_CLIENT_SAE */
+
 static s32
 wl_notify_connect_status_ibss(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	const wl_event_msg_t *e, void *data)
@@ -12796,6 +13454,10 @@ wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 	} else if (wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_BSS) {
 		WL_DBG(("event %d status : %d ndev %p\n",
 			ntoh32(e->event_type), ntoh32(e->status), ndev));
+#ifdef WL_CLIENT_SAE
+		if (event == WLC_E_AUTH)
+			wl_notify_connect_status_bss(cfg, ndev, e, data);
+#endif /* WL_CLIENT_SAE */
 		if (event == WLC_E_ASSOC || event == WLC_E_AUTH) {
 			wl_get_auth_assoc_status(cfg, ndev, e, data);
 			return 0;
@@ -12865,7 +13527,7 @@ wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 				 * the event to avoid pre-empting the current connection
 				 */
 				WL_INFORM(("Nested connection case. Drop event. \n"));
-				wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+				wl_ext_in4way_sync(ndev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 					WL_EXT_STATUS_DISCONNECTED, NULL);
 				wl_clr_drv_status(cfg, NESTED_CONNECT, ndev);
 				wl_clr_drv_status(cfg, DISCONNECTING, ndev);
@@ -13059,7 +13721,7 @@ wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 				wl_clr_drv_status(cfg, CONNECTING, ndev);
 			}
 			wl_clr_drv_status(cfg, DISCONNECTING, ndev);
-			wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+			wl_ext_in4way_sync(ndev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 				WL_EXT_STATUS_DISCONNECTED, NULL);
 
 			/* if link down, bsscfg is diabled */
@@ -13074,7 +13736,7 @@ wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 		} else if (wl_is_nonetwork(cfg, e)) {
 			WL_MSG(ndev->name, "connect failed event=%d e->status %d e->reason %d \n",
 				event, (int)ntoh32(e->status), (int)ntoh32(e->reason));
-			wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+			wl_ext_in4way_sync(ndev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 				WL_EXT_STATUS_DISCONNECTED, NULL);
 #if defined(DHD_ENABLE_BIGDATA_LOGGING)
 			if (event == WLC_E_SET_SSID) {
@@ -13775,7 +14437,7 @@ wl_bss_roaming_done(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 #endif /* WLADPS_SEAK_AP_WAR */
 	WL_MSG(ndev->name, "succeeded to " MACDBG " (ch:%d)\n",
 		MAC2STRDBG((const u8*)(&e->addr)), *channel);
-	wl_cfg80211_check_in4way(cfg, ndev, 0, WL_EXT_STATUS_CONNECTED, NULL);
+	wl_ext_in4way_sync(ndev, 0, WL_EXT_STATUS_CONNECTED, NULL);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 	roam_info.channel = notify_channel;
@@ -13949,10 +14611,10 @@ wl_bss_connect_done(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 		}
 		if (completed) {
 			WL_INFORM(("Report connect result - connection succeeded\n"));
-			wl_cfg80211_check_in4way(cfg, ndev, 0, WL_EXT_STATUS_CONNECTED, NULL);
+			wl_ext_in4way_sync(ndev, 0, WL_EXT_STATUS_CONNECTED, NULL);
 		} else {
 			WL_MSG(ndev->name, "Report connect result - connection failed\n");
-			wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+			wl_ext_in4way_sync(ndev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 				WL_EXT_STATUS_DISCONNECTED, NULL);
 		}
 		cfg80211_connect_result(ndev,
@@ -14939,7 +15601,42 @@ static void wl_init_event_handler(struct bcm_cfg80211 *cfg)
 #ifdef WL_SAE
 	cfg->evt_handler[WLC_E_AUTH_IND] = wl_notify_connect_status;
 #endif /* WL_SAE */
+#ifdef WL_CLIENT_SAE
+	cfg->evt_handler[WLC_E_JOIN_START] = wl_notify_start_auth;
+#endif /* WL_CLIENT_SAE */
+}
+
+#ifdef WL_CLIENT_SAE
+/** Called by the cfg80211 framework */
+static s32
+wl_cfg80211_external_auth(struct wiphy *wiphy,
+	struct net_device *ndev, struct cfg80211_external_auth_params *ext_auth_param)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	wl_assoc_mgr_cmd_t cmd;
+
+	WL_DBG(("Enter\n"));
+
+	if (!ext_auth_param ||
+		ETHER_ISNULLADDR(ext_auth_param->bssid)) {
+		WL_ERR(("Invalid wl_cfg80211_external_auth param\n"));
+		return -EINVAL;
+	}
+
+	cmd.version = WL_ASSOC_MGR_CURRENT_VERSION;
+	cmd.length = sizeof(cmd);
+	cmd.cmd = WL_ASSOC_MGR_CMD_PAUSE_ON_EVT;
+	cmd.params = WL_ASSOC_MGR_PARAMS_EVENT_NONE;
+	err = wldev_iovar_setbuf(ndev, "assoc_mgr_cmd", (void *)&cmd, sizeof(cmd), cfg->ioctl_buf,
+		WLC_IOCTL_SMLEN, &cfg->ioctl_buf_sync);
+	if (unlikely(err)) {
+		WL_ERR(("Failed to pause assoc(%d)\n", err));
+	}
+
+	return err;
 }
+#endif /* WL_CLIENT_SAE */
 
 #if defined(STATIC_WL_PRIV_STRUCT)
 static int
@@ -16322,6 +17019,9 @@ static s32 wl_init_priv(struct bcm_cfg80211 *cfg)
 	cfg->nan_dp_state = NAN_DP_STATE_DISABLED;
 	init_waitqueue_head(&cfg->ndp_if_change_event);
 #endif /* NAN_DP */
+	cfg->pmk_list->pmkids.length = OFFSETOF(pmkid_list_v3_t, pmkid);
+	cfg->pmk_list->pmkids.count = 0;
+	cfg->pmk_list->pmkids.version = PMKID_LIST_VER_3;
 	return err;
 }
 
@@ -16455,6 +17155,7 @@ s32 wl_cfg80211_attach(struct net_device *ndev, void *context)
 	struct bcm_cfg80211 *cfg;
 	s32 err = 0;
 	struct device *dev;
+	dhd_pub_t *dhd = (struct dhd_pub *)(context);
 
 	WL_TRACE(("In\n"));
 	if (!ndev) {
@@ -16482,6 +17183,7 @@ s32 wl_cfg80211_attach(struct net_device *ndev, void *context)
 	cfg = wiphy_priv(wdev->wiphy);
 	cfg->wdev = wdev;
 	cfg->pub = context;
+	cfg->osh = dhd->osh;
 	INIT_LIST_HEAD(&cfg->net_list);
 #ifdef WBTEXT
 	INIT_LIST_HEAD(&cfg->wbtext_bssid_list);
@@ -17348,6 +18050,7 @@ static s32 __wl_cfg80211_up(struct bcm_cfg80211 *cfg)
 #ifdef WLTDLS
 	u32 tdls;
 #endif /* WLTDLS */
+	u8 ioctl_buf[WLC_IOCTL_SMLEN];
 
 	WL_DBG(("In\n"));
 
@@ -17387,6 +18090,27 @@ static s32 __wl_cfg80211_up(struct bcm_cfg80211 *cfg)
 		}
 	}
 
+	err = wldev_iovar_getbuf(ndev, "wlc_ver", NULL, 0,
+		&cfg->wlc_ver, sizeof(wl_wlc_version_t), NULL);
+	if (likely(!err)) {
+		WL_INFORM(("wl version. Major: %d\n",
+			cfg->wlc_ver.wlc_ver_major));
+		if ((cfg->wlc_ver.wlc_ver_major >= MIN_ESCAN_PARAM_V2_FW_MAJOR) &&
+				(wldev_iovar_getbuf(ndev, "scan_ver", NULL, 0,
+				ioctl_buf, sizeof(ioctl_buf), NULL) == BCME_OK)) {
+			WL_INFORM(("scan_params v2\n"));
+			/* use scan_params ver2 */
+			cfg->scan_params_v2 = true;
+		}
+	} else {
+		if (err == BCME_UNSUPPORTED) {
+			/* Ignore on unsupported chips */
+			err = BCME_OK;
+		} else {
+			WL_ERR(("wlc_ver query failed. err: %d\n", err));
+			return err;
+		}
+	}
 #ifdef DHD_LOSSLESS_ROAMING
 	if (timer_pending(&cfg->roam_timeout)) {
 		del_timer_sync(&cfg->roam_timeout);
@@ -17624,7 +18348,7 @@ s32 wl_cfg80211_up(struct net_device *net)
 	}
 	ioctl_version = val;
 	WL_TRACE(("WLC_GET_VERSION=%d\n", ioctl_version));
-	wl_cfg80211_check_in4way(cfg, net, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+	wl_ext_in4way_sync(net, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
 		WL_EXT_STATUS_DISCONNECTED, NULL);
 
 	mutex_lock(&cfg->usr_sync);
@@ -22344,218 +23068,3 @@ wl_cfg80211_autochannel(struct net_device *dev, char* command, int total_len)
 
 	return ret;
 }
-
-static int
-wl_cfg80211_check_in4way(struct bcm_cfg80211 *cfg,
-	struct net_device *dev, uint action, enum wl_ext_status status, void *context)
-{
-	dhd_pub_t *dhdp = (dhd_pub_t *)(cfg->pub);
-	struct wl_security *sec;
-	s32 bssidx = -1;
-	int ret = 0, cur_eapol_status, ifidx;
-	int max_wait_time, max_wait_cnt;
-	int suppressed = 0;
-
-	mutex_lock(&cfg->in4way_sync);
-	action = action & dhdp->conf->in4way;
-	WL_DBG(("status=%d, action=0x%x, in4way=0x%x\n", status, action, dhdp->conf->in4way));
-
-	cur_eapol_status = dhdp->conf->eapol_status;
-	switch (status) {
-		case WL_EXT_STATUS_SCAN:
-			wldev_ioctl(dev, WLC_GET_SCANSUPPRESS, &suppressed, sizeof(int), false);
-			if (suppressed) {
-				WL_ERR(("scan suppressed\n"));
-				ret = -EBUSY;
-				break;
-			}
-			if (action & NO_SCAN_IN4WAY) {
-				if (cfg->handshaking > 0 && cfg->handshaking <= 3) {
-					WL_ERR(("return -EBUSY cnt %d\n", cfg->handshaking));
-					cfg->handshaking++;
-					ret = -EBUSY;
-					break;
-				}
-			}
-			break;
- 		case WL_EXT_STATUS_DISCONNECTING:
-			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
-					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
-				WL_ERR(("WPA failed at %d\n", cur_eapol_status));
-				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
-					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
-				WL_ERR(("WPS failed at %d\n", cur_eapol_status));
-				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			}
-			if (action & (NO_SCAN_IN4WAY|NO_BTC_IN4WAY)) {
-				if (cfg->handshaking) {
-					if ((action & NO_BTC_IN4WAY) && cfg->btc_mode) {
-						WL_TRACE(("status=%d, restore btc_mode %d\n",
-							status, cfg->btc_mode));
-						wldev_iovar_setint(dev, "btc_mode", cfg->btc_mode);
-					}
-					cfg->handshaking = 0;
-				}
-			}
-			if (action & WAIT_DISCONNECTED) {
-				max_wait_time = 200;
-				max_wait_cnt = 20;
-				cfg->disconnected_jiffies = jiffies;
-				while (!time_after(jiffies,
-						cfg->disconnected_jiffies + msecs_to_jiffies(max_wait_time)) &&
-						max_wait_cnt) {
-					WL_TRACE(("status=%d, max_wait_cnt=%d waiting...\n",
-						status, max_wait_cnt));
-					mutex_unlock(&cfg->in4way_sync);
-					OSL_SLEEP(50);
-					mutex_lock(&cfg->in4way_sync);
-					max_wait_cnt--;
-				}
-				wake_up_interruptible(&dhdp->conf->event_complete);
-			}
-			break;
-		case WL_EXT_STATUS_CONNECTING:
-			if (action & (NO_SCAN_IN4WAY|NO_BTC_IN4WAY)) {
-				bssidx = wl_get_bssidx_by_wdev(cfg, dev->ieee80211_ptr);
-				sec = wl_read_prof(cfg, dev, WL_PROF_SEC);
-				if ((sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2)) &&
-						bssidx == 0) {
-					dhdp->conf->eapol_status = EAPOL_STATUS_4WAY_START;
-					cfg->handshaking = 1;
-					if (action & NO_BTC_IN4WAY) {
-						ret = wldev_iovar_getint(dev, "btc_mode", &cfg->btc_mode);
-						if (!ret && cfg->btc_mode) {
-							WL_TRACE(("status=%d, disable current btc_mode %d\n",
-								status, cfg->btc_mode));
-							wldev_iovar_setint(dev, "btc_mode", 0);
-						}
-					}
-				}
-			}
-			if (action & WAIT_DISCONNECTED) {
-				max_wait_time = 200;
-				max_wait_cnt = 10;
-				while (!time_after(jiffies,
-						cfg->disconnected_jiffies + msecs_to_jiffies(max_wait_time)) &&
-						max_wait_cnt) {
-					WL_TRACE(("status=%d, max_wait_cnt=%d waiting...\n",
-						status, max_wait_cnt));
-					mutex_unlock(&cfg->in4way_sync);
-					OSL_SLEEP(50);
-					mutex_lock(&cfg->in4way_sync);
-					max_wait_cnt--;
-				}
-				wake_up_interruptible(&dhdp->conf->event_complete);
-			}
-			break;
-		case WL_EXT_STATUS_CONNECTED:
-			ifidx = dhd_net2idx(dhdp->info, dev);
-			if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_STATION && ifidx >= 0) {
-				dhd_conf_set_wme(cfg->pub, ifidx, 0);
-				wake_up_interruptible(&dhdp->conf->event_complete);
-			}
-			else if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_CLIENT) {
-				dhd_conf_set_mchan_bw(cfg->pub, WL_P2P_IF_CLIENT, -1);
-			}
-			break;
-		case WL_EXT_STATUS_DISCONNECTED:
-			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
-					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
-				WL_ERR(("WPA failed at %d\n", cur_eapol_status));
-				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
-					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
-				WL_ERR(("WPS failed at %d\n", cur_eapol_status));
-				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			}
-			if (action & (NO_SCAN_IN4WAY|NO_BTC_IN4WAY)) {
-				if (cfg->handshaking) {
-					if ((action & NO_BTC_IN4WAY) && cfg->btc_mode) {
-						WL_TRACE(("status=%d, restore btc_mode %d\n",
-							status, cfg->btc_mode));
-						wldev_iovar_setint(dev, "btc_mode", cfg->btc_mode);
-					}
-					cfg->handshaking = 0;
-				}
-			}
-			if (action & WAIT_DISCONNECTED) {
-				cfg->disconnected_jiffies = jiffies;
-			}
-			wake_up_interruptible(&dhdp->conf->event_complete);
-			break;
-		case WL_EXT_STATUS_ADD_KEY:
-			dhdp->conf->eapol_status = EAPOL_STATUS_4WAY_DONE;
-			if (action & (NO_SCAN_IN4WAY|NO_BTC_IN4WAY)) {
-				if (cfg->handshaking) {
-					if ((action & NO_BTC_IN4WAY) && cfg->btc_mode) {
-						WL_TRACE(("status=%d, restore btc_mode %d\n",
-							status, cfg->btc_mode));
-						wldev_iovar_setint(dev, "btc_mode", cfg->btc_mode);
-					}
-					cfg->handshaking = 0;
-				}
-			}
-			wake_up_interruptible(&dhdp->conf->event_complete);
-			break;
-		case WL_EXT_STATUS_AP_ENABLED:
-			ifidx = dhd_net2idx(dhdp->info, dev);
-			if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP && ifidx >= 0) {
-				dhd_conf_set_wme(cfg->pub, ifidx, 1);
-			}
-			else if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) {
-				dhd_conf_set_mchan_bw(cfg->pub, WL_P2P_IF_GO, -1);
-			}
-			break;
-		case WL_EXT_STATUS_DELETE_STA:
-			if ((action & DONT_DELETE_GC_AFTER_WPS) &&
-					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO)) {
-				u8* mac_addr = context;
-				if (mac_addr && memcmp(&ether_bcast, mac_addr, ETHER_ADDR_LEN) &&
-						cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
-					u32 timeout;
-					max_wait_time = 300;
-					WL_TRACE(("status=%d, wps_done=%d, waiting %dms ...\n",
-						status, cfg->wps_done, max_wait_time));
-					mutex_unlock(&cfg->in4way_sync);
-					timeout = wait_event_interruptible_timeout(cfg->wps_done_event,
-						cfg->wps_done, msecs_to_jiffies(max_wait_time));
-					mutex_lock(&cfg->in4way_sync);
-					WL_TRACE(("status=%d, wps_done=%d, timeout=%d\n",
-						status, cfg->wps_done, timeout));
-					if (timeout > 0) {
-						ret = -1;
-						break;
-					}
-				} else {
-					WL_TRACE(("status=%d, wps_done=%d => 0\n", status, cfg->wps_done));
-					cfg->wps_done = FALSE;
-					dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-				}
-			}
-			break;
-		case WL_EXT_STATUS_STA_DISCONNECTED:
-			if ((action & DONT_DELETE_GC_AFTER_WPS) &&
-					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) &&
-					cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
-				WL_TRACE(("status=%d, wps_done=%d => 0\n", status, cfg->wps_done));
-				cfg->wps_done = FALSE;
-			}
-			break;
-		case WL_EXT_STATUS_STA_CONNECTED:
-			if ((action & DONT_DELETE_GC_AFTER_WPS) &&
-					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) &&
-					cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
-				WL_TRACE(("status=%d, wps_done=%d => 1\n", status, cfg->wps_done));
-				cfg->wps_done = TRUE;
-				wake_up_interruptible(&cfg->wps_done_event);
-			}
-			break;
-		default:
-			WL_ERR(("Unknown action=0x%x, status=%d\n", action, status));
-	}
-
-	mutex_unlock(&cfg->in4way_sync);
-
-	return ret;
-}
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.h
index 23116809168f..a6d1018d9441 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfg80211.h
@@ -53,9 +53,24 @@ struct bcm_cfg80211;
 struct wl_security;
 struct wl_ibss;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)
-#undef WL_SAE
-#endif // endif
+#if !defined(WL_CLIENT_SAE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0))
+#define WL_CLIENT_SAE
+#endif
+#if defined(WL_SAE) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+#error "Can not support WL_SAE befor kernel 3.14"
+#endif
+#if defined(WL_CLIENT_SAE) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
+#error "Can not support WL_CLIENT_SAE before kernel 4.9"
+#endif
+#if defined(WL_CLIENT_SAE) && defined(WL_SAE)
+#error "WL_SAE is for dongle-offload and WL_CLIENT_SAE is for wpa_supplicant. Please choose one."
+#endif
+
+#if defined(WL_CLIENT_SAE)
+#ifndef WL_ASSOC_MGR_CMD_SEND_AUTH
+#define WL_ASSOC_MGR_CMD_SEND_AUTH 3
+#endif /* WL_ASSOC_MGR_CMD_SEND_AUTH */
+#endif
 
 #define htod32(i) (i)
 #define htod16(i) (i)
@@ -296,6 +311,8 @@ do {									\
 #define WLAN_AKM_SUITE_FT_PSK		0x000FAC04
 #endif /* WLAN_AKM_SUITE_FT_PSK */
 
+#define WLAN_AKM_SUITE_SAE_SHA256	0x000FAC08
+
 /*
  * BRCM local.
  * Use a high number that's unlikely to clash with linux upstream for a while until we can
@@ -565,12 +582,23 @@ struct wl_assoc_ielen {
 	u32 resp_len;
 };
 
+#define MIN_PMKID_LIST_V3_FW_MAJOR 13
+#define MIN_PMKID_LIST_V3_FW_MINOR 0
+
+#define MIN_PMKID_LIST_V2_FW_MAJOR 12
+#define MIN_PMKID_LIST_V2_FW_MINOR 0
+
+#define MIN_ESCAN_PARAM_V2_FW_MAJOR 14
+#define MIN_ESCAN_PARAM_V2_FW_MINOR 0
+
 /* wpa2 pmk list */
 struct wl_pmk_list {
-	pmkid_list_t pmkids;
-	pmkid_t foo[MAXPMKID - 1];
+	pmkid_list_v3_t pmkids;
+	pmkid_v3_t foo[MAXPMKID - 1];
 };
 
+#define KEY_PERM_PMK 0xFFFFFFFF
+
 #ifdef DHD_MAX_IFS
 #define WL_MAX_IFS DHD_MAX_IFS
 #else
@@ -876,6 +904,7 @@ struct bcm_cfg80211 {
 #ifdef SUPPORT_AP_RADIO_PWRSAVE
 	ap_rps_info_t ap_rps_info;
 #endif /* SUPPORT_AP_RADIO_PWRSAVE */
+	osl_t *osh;
 #ifdef WBTEXT
 	struct list_head wbtext_bssid_list;
 #endif /* WBTEXT */
@@ -884,6 +913,8 @@ struct bcm_cfg80211 {
 #ifdef STAT_REPORT
 	void *stat_report_info;
 #endif
+	wl_wlc_version_t wlc_ver;
+	bool scan_params_v2;
 #ifdef WLMESH_CFG80211
 	char sae_password[SAE_MAX_PASSWD_LEN];
 	uint sae_password_len;
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgp2p.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgp2p.c
index 9943079bb9cf..7ea4d3f90d70 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgp2p.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgp2p.c
@@ -451,7 +451,7 @@ wl_cfgp2p_ifadd(struct bcm_cfg80211 *cfg, struct ether_addr *mac, u8 if_type,
 	err = wldev_iovar_setbuf(ndev, "p2p_ifadd", &ifreq, sizeof(ifreq),
 		cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
 	if (unlikely(err < 0)) {
-		printk("'cfg p2p_ifadd' error %d\n", err);
+		CFGP2P_ERR(("'cfg p2p_ifadd' error %d\n", err));
 		return err;
 	}
 
@@ -474,7 +474,7 @@ wl_cfgp2p_ifdisable(struct bcm_cfg80211 *cfg, struct ether_addr *mac)
 	ret = wldev_iovar_setbuf(netdev, "p2p_ifdis", mac, sizeof(*mac),
 		cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
 	if (unlikely(ret < 0)) {
-		printk("'cfg p2p_ifdis' error %d\n", ret);
+		CFGP2P_ERR(("'cfg p2p_ifdis' error %d\n", ret));
 	}
 	return ret;
 }
@@ -495,7 +495,7 @@ wl_cfgp2p_ifdel(struct bcm_cfg80211 *cfg, struct ether_addr *mac)
 	ret = wldev_iovar_setbuf(netdev, "p2p_ifdel", mac, sizeof(*mac),
 		cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
 	if (unlikely(ret < 0)) {
-		printk("'cfg p2p_ifdel' error %d\n", ret);
+		CFGP2P_ERR(("'cfg p2p_ifdel' error %d\n", ret));
 	}
 	return ret;
 }
@@ -527,7 +527,7 @@ wl_cfgp2p_ifchange(struct bcm_cfg80211 *cfg, struct ether_addr *mac, u8 if_type,
 	err = wldev_iovar_setbuf(netdev, "p2p_ifupd", &ifreq, sizeof(ifreq),
 		cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
 	if (unlikely(err < 0)) {
-		printk("'cfg p2p_ifupd' error %d\n", err);
+		CFGP2P_ERR(("'cfg p2p_ifupd' error %d\n", err));
 	} else if (if_type == WL_P2P_IF_GO) {
 		cfg->p2p->p2p_go_count++;
 	}
@@ -2282,7 +2282,7 @@ wl_cfgp2p_register_ndev(struct bcm_cfg80211 *cfg)
 	cfg->p2p_wdev = wdev;
 	cfg->p2p_net = net;
 
-	printk("%s: P2P Interface Registered\n", net->name);
+	WL_MSG(net->name, "P2P Interface Registered\n");
 
 	return ret;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgvendor.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgvendor.c
index 47548c41c5cf..20c1b476c63e 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgvendor.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_cfgvendor.c
@@ -1055,6 +1055,11 @@ static int wl_cfgvendor_set_rssi_monitor(struct wiphy *wiphy,
 	int8 max_rssi = 0, min_rssi = 0;
 	const struct nlattr *iter;
 
+	if (!wl_get_drv_status(cfg, CONNECTED, wdev_to_ndev(wdev))) {
+		WL_ERR(("STA is not connected to an AP, rssi monitoring is not allowed\n"));
+		return -EINVAL;
+	}
+
 	nla_for_each_attr(iter, data, len, tmp) {
 		type = nla_type(iter);
 		switch (type) {
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.c
index d57f08b4d3e1..3a145b5560f2 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.c
@@ -897,7 +897,7 @@ wl_escan_set_scan(struct net_device *dev, dhd_pub_t *dhdp,
 
 	if (unlikely(err)) {
 		/* Don't print Error incase of Scan suppress */
-		if ((err == BCME_EPERM))
+		if (err == BCME_EPERM)
 			ESCAN_TRACE(dev->name, "Escan failed: Scan Suppressed\n");
 		else {
 			cnt++;
@@ -1197,14 +1197,18 @@ wl_escan_rsn_ie(u8 *parse, u32 len)
 	return FALSE;
 }
 
-void
-wl_escan_mesh_info_ie(u8 *parse, u32 len, struct wl_mesh_params *mesh_info)
+bool
+wl_escan_mesh_info_ie(struct net_device *dev, u8 *parse, u32 len,
+	struct wl_mesh_params *mesh_info)
 {
 	bcm_tlv_t *ie;
 	uchar mesh_oui[]={0x00, 0x22, 0xf4};
 	int totl_len;
 	uint8 *pie;
+	uint max_len;
+	bool found = FALSE;
 
+	memset(mesh_info, 0, sizeof(struct wl_mesh_params));
 	if((ie = bcm_parse_tlvs(parse, (int)len, DOT11_MNG_VS_ID)) != NULL) {
 		totl_len = ie->len;
 		if (!memcmp(ie->data, &mesh_oui, sizeof(mesh_oui))) {
@@ -1216,10 +1220,12 @@ wl_escan_mesh_info_ie(u8 *parse, u32 len, struct wl_mesh_params *mesh_info)
 					memcpy(&mesh_info->master_bssid, ie->data, ETHER_ADDR_LEN);
 				} else if (ie->id == MESH_INFO_MASTER_CHANNEL) {
 					mesh_info->master_channel = ie->data[0];
+					found = TRUE;
 				} else if (ie->id == MESH_INFO_HOP_CNT) {
 					mesh_info->hop_cnt = ie->data[0];
 				} else if (ie->id == MESH_INFO_PEER_BSSID) {
-					memcpy(&mesh_info->peer_bssid, ie->data, ETHER_ADDR_LEN);
+					max_len = min(MAX_HOP_LIST*ETHER_ADDR_LEN, (int)ie->len);
+					memcpy(mesh_info->peer_bssid, ie->data, max_len);
 				}
 				totl_len -= (ie->len + 2);
 				pie = ie->data + ie->len;
@@ -1227,19 +1233,20 @@ wl_escan_mesh_info_ie(u8 *parse, u32 len, struct wl_mesh_params *mesh_info)
 			}
 		}
 	}
+
+	return found;
 }
 
-int
+bool
 wl_escan_mesh_info(struct net_device *dev, struct wl_escan_info *escan, 
 	struct ether_addr *peer_bssid, struct wl_mesh_params *mesh_info)
 {
-	s32 err = BCME_OK;
 	int i = 0;
 	wl_bss_info_t *bi = NULL;
 	struct wl_scan_results *bss_list;
 	int16 bi_rssi, bi_chan;
 	wlc_ssid_t bi_meshid;
-	bool is_mesh_peer = FALSE;
+	bool is_mesh_peer = FALSE, found = FALSE;
 	struct wl_mesh_params peer_mesh_info;
 
 	mutex_lock(&escan->usr_sync);
@@ -1247,17 +1254,14 @@ wl_escan_mesh_info(struct net_device *dev, struct wl_escan_info *escan,
 	/* Check for scan in progress */
 	if (escan->escan_state == ESCAN_STATE_SCANING) {
 		ESCAN_ERROR(dev->name, "SIOCGIWSCAN GET still scanning\n");
-		err = -EAGAIN;
 		goto exit;
 	}
 	if (!escan->bss_list) {
 		ESCAN_ERROR(dev->name, "scan not ready\n");
-		err = -EAGAIN;
 		goto exit;
 	}
 	if (dev != escan->dev) {
 		ESCAN_ERROR(dev->name, "not my scan from %s\n", escan->dev->name);
-		err = -EINVAL;
 		goto exit;
 	}
 
@@ -1274,27 +1278,26 @@ wl_escan_mesh_info(struct net_device *dev, struct wl_escan_info *escan,
 		is_mesh_peer = wl_escan_meshid_ie(((u8*)bi)+bi->ie_offset,
 			bi->ie_length, &bi_meshid);
 		if (!(bi->capability & (DOT11_CAP_ESS|DOT11_CAP_IBSS)) && is_mesh_peer) {
-			bool bi_sae = FALSE, bss_found = FALSE;
+			bool bi_sae = FALSE, bss_found = FALSE, prefer = FALSE;
 			if (!memcmp(peer_bssid, &bi->BSSID, ETHER_ADDR_LEN)) {
 				bi_sae = wl_escan_rsn_ie(((u8*)bi)+bi->ie_offset, bi->ie_length);
-				memset(&peer_mesh_info, 0, sizeof(peer_mesh_info));
-				wl_escan_mesh_info_ie(((u8*)bi)+bi->ie_offset, bi->ie_length,
-					&peer_mesh_info);
-				if (peer_mesh_info.hop_cnt) {
+				bss_found = wl_escan_mesh_info_ie(dev, ((u8*)bi)+bi->ie_offset,
+					bi->ie_length, &peer_mesh_info);
+				if (bss_found) {
 					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
 						ETHER_ADDR_LEN);
 					mesh_info->master_channel = peer_mesh_info.master_channel;
 					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
-					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
-						ETHER_ADDR_LEN);
-					mesh_info->channel = bi_chan;
-					bss_found = TRUE;
+					memcpy(mesh_info->peer_bssid, peer_mesh_info.peer_bssid,
+						sizeof(peer_mesh_info.peer_bssid));
+					prefer = TRUE;
+					found = TRUE;
 				}
 			}
 			ESCAN_SCAN(dev->name,
 				"%s[Mesh] BSSID=%pM, channel=%d, RSSI=%d, sec=%s, "
 				"mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM, MeshID=\"%s\"\n",
-				bss_found?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
+				prefer?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
 				&peer_mesh_info.master_bssid, peer_mesh_info.master_channel,
 				peer_mesh_info.hop_cnt, &peer_mesh_info.peer_bssid, bi_meshid.SSID);
 		}
@@ -1302,22 +1305,21 @@ wl_escan_mesh_info(struct net_device *dev, struct wl_escan_info *escan,
 
 exit:
 	mutex_unlock(&escan->usr_sync);
-	return err;
+	return found;
 }
 
-int
+bool
 wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan, 
 	wlc_ssid_t *cur_ssid, uint16 cur_chan, bool sae,
 	struct wl_mesh_params *mesh_info)
 {
-	s32 err = BCME_OK;
 	int i = 0;
 	wl_bss_info_t *bi = NULL;
 	struct wl_scan_results *bss_list;
 	int16 bi_rssi, bi_chan, max_rssi = -100;
 	uint min_hop_cnt = 255;
 	wlc_ssid_t bi_meshid;
-	bool is_mesh_peer = FALSE, chan_matched = FALSE;
+	bool is_mesh_peer = FALSE, chan_matched = FALSE, found = FALSE;
 	struct wl_mesh_params peer_mesh_info;
 
 	mutex_lock(&escan->usr_sync);
@@ -1325,17 +1327,14 @@ wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan,
 	/* Check for scan in progress */
 	if (escan->escan_state == ESCAN_STATE_SCANING) {
 		ESCAN_ERROR(dev->name, "SIOCGIWSCAN GET still scanning\n");
-		err = -EAGAIN;
 		goto exit;
 	}
 	if (!escan->bss_list) {
 		ESCAN_ERROR(dev->name, "scan not ready\n");
-		err = -EAGAIN;
 		goto exit;
 	}
 	if (dev != escan->dev) {
 		ESCAN_ERROR(dev->name, "not my scan from %s\n", escan->dev->name);
-		err = -EINVAL;
 		goto exit;
 	}
 
@@ -1353,7 +1352,7 @@ wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan,
 			bi->ie_length, &bi_meshid);
 		if (!(bi->capability & (DOT11_CAP_ESS|DOT11_CAP_IBSS)) && is_mesh_peer) {
 			bool meshid_matched = FALSE, sec_matched = FALSE, bi_sae = FALSE,
-				bss_found = FALSE;
+				bss_found = FALSE, prefer = FALSE;
 
 			if (cur_ssid->SSID_len && cur_ssid->SSID_len == bi_meshid.SSID_len &&
 					!memcmp(cur_ssid->SSID, bi_meshid.SSID, bi_meshid.SSID_len))
@@ -1363,43 +1362,42 @@ wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan,
 			if (bi_sae == sae)
 				sec_matched = TRUE;
 
-			memset(&peer_mesh_info, 0, sizeof(peer_mesh_info));
-			wl_escan_mesh_info_ie(((u8*)bi)+bi->ie_offset, bi->ie_length,
+			bss_found = wl_escan_mesh_info_ie(dev, ((u8*)bi)+bi->ie_offset, bi->ie_length,
 				&peer_mesh_info);
-
-			if (meshid_matched && sec_matched && peer_mesh_info.hop_cnt &&
+			if (meshid_matched && sec_matched && bss_found &&
 					(cur_chan == bi_chan)) {
 				if (peer_mesh_info.hop_cnt < min_hop_cnt) {
 					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
 						ETHER_ADDR_LEN);
 					mesh_info->master_channel = peer_mesh_info.master_channel;
 					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
-					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
-						ETHER_ADDR_LEN);
-					mesh_info->channel = bi_chan;
+					memcpy(mesh_info->peer_bssid, peer_mesh_info.peer_bssid,
+						sizeof(peer_mesh_info.peer_bssid));
 					min_hop_cnt = peer_mesh_info.hop_cnt;
-					bss_found = TRUE;
+					prefer = TRUE;
 					chan_matched = TRUE;
+					found = TRUE;
 				}
-			} else if (meshid_matched && sec_matched && peer_mesh_info.hop_cnt &&
+			}
+			else if (meshid_matched && sec_matched && bss_found &&
 					(cur_chan != bi_chan) && !chan_matched) {
 				if (bi_rssi > max_rssi) {
 					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
 						ETHER_ADDR_LEN);
 					mesh_info->master_channel = peer_mesh_info.master_channel;
 					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
-					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
-						ETHER_ADDR_LEN);
-					mesh_info->channel = bi_chan;
+					memcpy(mesh_info->peer_bssid, peer_mesh_info.peer_bssid,
+						sizeof(peer_mesh_info.peer_bssid));
 					max_rssi = bi_rssi;
-					bss_found = TRUE;
+					prefer = TRUE;
+					found = TRUE;
 				}
 			}
 
 			ESCAN_SCAN(dev->name,
 				"%s[Mesh] BSSID=%pM, channel=%d, RSSI=%d, sec=%s, "
 				"mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM, MeshID=\"%s\"\n",
-				bss_found?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
+				prefer?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
 				&peer_mesh_info.master_bssid, peer_mesh_info.master_channel,
 				peer_mesh_info.hop_cnt, &peer_mesh_info.peer_bssid, bi_meshid.SSID);
 		} else {
@@ -1411,7 +1409,7 @@ wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan,
 
 exit:
 	mutex_unlock(&escan->usr_sync);
-	return err;
+	return found;
 }
 #endif /* WLMESH */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.h b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.h
index 922b30fad2c6..9fb97f771b55 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.h
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_escan.h
@@ -19,14 +19,14 @@ enum escan_state {
 typedef struct wl_escan_info {
 	struct net_device *dev;
 	dhd_pub_t *pub;
-	timer_list_compat_t scan_timeout;   /* Timer for catch scan event timeout */
+	timer_list_compat_t scan_timeout; /* Timer for catch scan event timeout */
 	int escan_state;
 	int ioctl_ver;
 	u8 escan_buf[ESCAN_BUF_SIZE];
 	struct wl_scan_results *bss_list;
 	struct ether_addr disconnected_bssid;
 	u8 *escan_ioctl_buf;
-	struct mutex usr_sync;	/* maily for up/down synchronization */
+	struct mutex usr_sync; /* maily for up/down synchronization */
 	int autochannel;
 	int best_2g_ch;
 	int best_5g_ch;
@@ -40,7 +40,6 @@ typedef struct wl_escan_info {
 } wl_escan_info_t;
 
 #if defined(WLMESH)
-/* donlge escan state */
 enum mesh_info_id {
 	MESH_INFO_MASTER_BSSID = 1,
 	MESH_INFO_MASTER_CHANNEL,
@@ -48,18 +47,18 @@ enum mesh_info_id {
 	MESH_INFO_PEER_BSSID
 };
 
+#define MAX_HOP_LIST 10
 typedef struct wl_mesh_params {
 	struct ether_addr master_bssid;
 	uint16 master_channel;
 	uint hop_cnt;
-	struct ether_addr peer_bssid;
-	uint16 channel;
+	struct ether_addr peer_bssid[MAX_HOP_LIST];
 	uint16 scan_channel;
 } wl_mesh_params_t;
-int wl_escan_mesh_info(struct net_device *dev,
+bool wl_escan_mesh_info(struct net_device *dev,
 	struct wl_escan_info *escan, struct ether_addr *peer_bssid,
 	struct wl_mesh_params *mesh_info);
-int wl_escan_mesh_peer(struct net_device *dev,
+bool wl_escan_mesh_peer(struct net_device *dev,
 	struct wl_escan_info *escan, wlc_ssid_t *cur_ssid, uint16 cur_chan, bool sae,
 	struct wl_mesh_params *mesh_info);
 #endif /* WLMESH */
diff --git a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_iw.c b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_iw.c
index bc75ea64d7d8..a80596b598e5 100644
--- a/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_iw.c
+++ b/drivers/net/wireless/rockchip_wlan/rkwifi/bcmdhd_indep_power/wl_iw.c
@@ -515,152 +515,6 @@ wl_iw_set_pm(
 }
 #endif /* WIRELESS_EXT > 12 */
 
-#define WL_PM_ENABLE_TIMEOUT 10000
-#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
-	4 && __GNUC_MINOR__ >= 6))
-#define BCM_SET_CONTAINER_OF(entry, ptr, type, member) \
-_Pragma("GCC diagnostic push") \
-_Pragma("GCC diagnostic ignored \"-Wcast-qual\"") \
-entry = container_of((ptr), type, member); \
-_Pragma("GCC diagnostic pop")
-#else
-#define BCM_SET_CONTAINER_OF(entry, ptr, type, member) \
-entry = container_of((ptr), type, member);
-#endif /* STRICT_GCC_WARNINGS */
-
-void wl_ext_pm_work_handler(struct work_struct *work)
-{
-	struct wl_wext_info *wext_info;
-	s32 pm = PM_FAST;
-	dhd_pub_t *dhd;
-	int ret = 0;
-
-	BCM_SET_CONTAINER_OF(wext_info, work, struct wl_wext_info, pm_enable_work.work);
-
-	WL_TRACE(("%s: Enter\n", __FUNCTION__));
-#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
-	4 && __GNUC_MINOR__ >= 6))
-_Pragma("GCC diagnostic push")
-_Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
-#endif
-
-	dhd = (dhd_pub_t *)(wext_info->dhd);
-	if (!dhd || !wext_info->dhd->up) {
-		WL_TRACE(("%s: dhd is null or not up\n", __FUNCTION__));
-		return;
-	}
-	if (dhd_conf_get_pm(dhd) >= 0)
-		pm = dhd_conf_get_pm(dhd);
-	ret = dev_wlc_ioctl(wext_info->dev, WLC_SET_PM, &pm, sizeof(pm));
-	if (ret)
-		WL_ERROR(("%s: WLC_SET_PM failed %d\n", __FUNCTION__, ret));
-#if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
-	4 && __GNUC_MINOR__ >= 6))
-_Pragma("GCC diagnostic pop")
-#endif
-	DHD_PM_WAKE_UNLOCK(wext_info->dhd);
-
-}
-
-void wl_ext_add_remove_pm_enable_work(struct wl_wext_info *wext_info,
-	bool add)
-{
-	u16 wq_duration = 0;
-	s32 pm = PM_OFF;
-	int ret = 0;
-
-	if (wext_info == NULL || wext_info->dhd == NULL)
-		return;
-
-	mutex_lock(&wext_info->pm_sync);
-	/*
-	 * Make cancel and schedule work part mutually exclusive
-	 * so that while cancelling, we are sure that there is no
-	 * work getting scheduled.
-	 */
-
-	if (delayed_work_pending(&wext_info->pm_enable_work)) {
-		cancel_delayed_work_sync(&wext_info->pm_enable_work);
-		DHD_PM_WAKE_UNLOCK(wext_info->dhd);
-	}
-
-	if (add) {
-		wq_duration = (WL_PM_ENABLE_TIMEOUT);
-	}
-
-	/* It should schedule work item only if driver is up */
-	if (wq_duration && wext_info->dhd->up) {
-		if (dhd_conf_get_pm(wext_info->dhd) >= 0)
-			pm = dhd_conf_get_pm(wext_info->dhd);
-		ret = dev_wlc_ioctl(wext_info->dev, WLC_SET_PM, &pm, sizeof(pm));
-		if (ret)
-			WL_ERROR(("%s: WLC_SET_PM failed %d\n", __FUNCTION__, ret));
-		if (schedule_delayed_work(&wext_info->pm_enable_work,
-				msecs_to_jiffies((const unsigned int)wq_duration))) {
-			DHD_PM_WAKE_LOCK_TIMEOUT(wext_info->dhd, wq_duration);
-		} else {
-			WL_ERROR(("%s: Can't schedule pm work handler\n", __FUNCTION__));
-		}
-	}
-	mutex_unlock(&wext_info->pm_sync);
-
-}
-
-static void
-wl_iw_update_connect_status(struct net_device *dev, enum wl_ext_status status)
-{
-#ifndef WL_CFG80211
-	struct dhd_pub *dhd = dhd_get_pub(dev);
-	int cur_eapol_status = 0;
-	int wpa_auth = 0;
-	int error = -EINVAL;
-	wl_wext_info_t *wext_info = NULL;
-
-	if (!dhd || !dhd->conf)
-		return;
-	wext_info = dhd->wext_info;
-	cur_eapol_status = dhd->conf->eapol_status;
-
-	if (status == WL_EXT_STATUS_CONNECTING) {
-		wl_ext_add_remove_pm_enable_work(wext_info, TRUE);
-		if ((error = dev_wlc_intvar_get(dev, "wpa_auth", &wpa_auth))) {
-			WL_ERROR(("wpa_auth get error %d\n", error));
-			return;
-		}
-		if (wpa_auth & (WPA_AUTH_PSK|WPA2_AUTH_PSK))
-			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_START;
-		else
-			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-	} else if (status == WL_EXT_STATUS_ADD_KEY) {
-		dhd->conf->eapol_status = EAPOL_STATUS_4WAY_DONE;
-		wake_up_interruptible(&dhd->conf->event_complete);
-	} else if (status == WL_EXT_STATUS_DISCONNECTING) {
-		wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
-		if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
-				cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
-			WL_ERROR(("WPA failed at %d\n", cur_eapol_status));
-			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-		} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
-				cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
-			WL_ERROR(("WPS failed at %d\n", cur_eapol_status));
-			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-		}
-	} else if (status == WL_EXT_STATUS_DISCONNECTED) {
-		if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
-				cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
-			WL_ERROR(("WPA failed at %d\n", cur_eapol_status));
-			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-			wake_up_interruptible(&dhd->conf->event_complete);
-		} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
-				cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
-			WL_ERROR(("WPS failed at %d\n", cur_eapol_status));
-			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-		}
-	}
-#endif
-	return;
-}
-
 int
 wl_iw_send_priv_event(
 	struct net_device *dev,
@@ -1227,7 +1081,9 @@ wl_iw_set_wap(
 		if ((error = dev_wlc_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t)))) {
 			WL_ERROR(("WLC_DISASSOC failed (%d).\n", error));
 		}
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTING);
+		wl_ext_in4way_sync_wext(dev,
+			STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+			WL_EXT_STATUS_DISCONNECTING, NULL);
 		return 0;
 	}
 	/* WL_ASSOC(("Assoc to %s\n", bcm_ether_ntoa((struct ether_addr *)&(awrq->sa_data),
@@ -1246,7 +1102,8 @@ wl_iw_set_wap(
 		}
 		WL_MSG(dev->name, "join BSSID="MACSTR"\n", MAC2STR((u8 *)awrq->sa_data));
 	}
-	wl_iw_update_connect_status(dev, WL_EXT_STATUS_CONNECTING);
+	wl_ext_in4way_sync_wext(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY,
+		WL_EXT_STATUS_CONNECTING, NULL);
 
 	return 0;
 }
@@ -1309,7 +1166,9 @@ wl_iw_mlme(
 		WL_ERROR(("Invalid ioctl data.\n"));
 		return error;
 	}
-	wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTING);
+	wl_ext_in4way_sync_wext(dev,
+			STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+			WL_EXT_STATUS_DISCONNECTING, NULL);
 
 	return error;
 }
@@ -1516,12 +1375,16 @@ wl_iw_iscan_set_scan(
 	struct dhd_pub *dhd = dhd_get_pub(dev);
 	wl_wext_info_t *wext_info = NULL;
 	wlc_ssid_t ssid;
+	int err;
 #ifndef WL_ESCAN
 	iscan_info_t *iscan;
 #endif
 
 	DHD_CHECK(dhd, dev);
 	wext_info = dhd->wext_info;
+	err = wl_ext_in4way_sync_wext(dev, STA_NO_SCAN_IN4WAY, WL_EXT_STATUS_SCAN, NULL);
+	if (err)
+		return err;
 #ifdef WL_ESCAN
 	/* default Broadcast scan */
 	memset(&ssid, 0, sizeof(ssid));
@@ -2092,7 +1955,8 @@ wl_iw_set_essid(
 			}
 			WL_MSG(dev->name, "join SSID=\"%s\"\n", ssid.SSID);
 		}
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_CONNECTING);
+		wl_ext_in4way_sync_wext(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY,
+			WL_EXT_STATUS_CONNECTING, NULL);
 	}
 	/* If essid null then it is "iwconfig <interface> essid off" command */
 	else {
@@ -2103,7 +1967,9 @@ wl_iw_set_essid(
 			WL_ERROR(("WLC_DISASSOC failed (%d).\n", error));
 			return error;
 		}
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTING);
+		wl_ext_in4way_sync_wext(dev,
+			STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+			WL_EXT_STATUS_DISCONNECTING, NULL);
 	}
 	return 0;
 }
@@ -2911,7 +2777,8 @@ wl_iw_set_encodeext(
 		error = dev_wlc_ioctl(dev, WLC_SET_KEY, &key, sizeof(key));
 		if (error)
 			return error;
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_ADD_KEY);
+		wl_ext_in4way_sync_wext(dev, STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY,
+			WL_EXT_STATUS_ADD_KEY, NULL);
 	}
 	return 0;
 }
@@ -3749,7 +3616,9 @@ wl_iw_event(struct net_device *dev, struct wl_wext_info *wext_info,
 		break;
 	case WLC_E_DEAUTH:
 	case WLC_E_DISASSOC:
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTED);
+		wl_ext_in4way_sync_wext(dev,
+			STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+			WL_EXT_STATUS_DISCONNECTED, NULL);
 		WL_MSG_RLMT(dev->name, &e->addr, ETHER_ADDR_LEN,
 			"disconnected with "MACSTR", event %d, reason %d\n",
 			MAC2STR((u8 *)wrqu.addr.sa_data), event_type, reason);
@@ -3761,7 +3630,9 @@ wl_iw_event(struct net_device *dev, struct wl_wext_info *wext_info,
 			MAC2STR((u8 *)wrqu.addr.sa_data), event_type, reason);
 		bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
 		bzero(&extra, ETHER_ADDR_LEN);
-		wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTED);
+		wl_ext_in4way_sync_wext(dev,
+			STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+			WL_EXT_STATUS_DISCONNECTED, NULL);
 		break;
 
 	case WLC_E_LINK:
@@ -3771,7 +3642,9 @@ wl_iw_event(struct net_device *dev, struct wl_wext_info *wext_info,
 				MAC2STR((u8 *)wrqu.addr.sa_data), reason);
 			bzero(wrqu.addr.sa_data, ETHER_ADDR_LEN);
 			bzero(&extra, ETHER_ADDR_LEN);
-			wl_iw_update_connect_status(dev, WL_EXT_STATUS_DISCONNECTED);
+			wl_ext_in4way_sync_wext(dev,
+				STA_NO_SCAN_IN4WAY|STA_NO_BTC_IN4WAY|STA_WAIT_DISCONNECTED,
+				WL_EXT_STATUS_DISCONNECTED, NULL);
 		} else {
 			WL_MSG(dev->name, "Link UP with "MACSTR"\n",
 				MAC2STR((u8 *)wrqu.addr.sa_data));
@@ -4318,7 +4191,6 @@ wl_iw_detach(struct net_device *dev, dhd_pub_t *dhdp)
 		iscan->list_hdr = buf;
 	}
 #endif
-	wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
 	wl_ext_event_deregister(dev, dhdp, WLC_E_LAST, wl_iw_event);
 	if (wext_info) {
 		kfree(wext_info);
@@ -4375,8 +4247,6 @@ wl_iw_attach(struct net_device *dev, dhd_pub_t *dhdp)
 		goto exit;
 	}
 #endif
-	mutex_init(&wext_info->pm_sync);
-	INIT_DELAYED_WORK(&wext_info->pm_enable_work, wl_ext_pm_work_handler);
 	ret = wl_ext_event_register(dev, dhdp, WLC_E_LAST, wl_iw_event, dhdp->wext_info,
 		PRIO_EVENT_WEXT);
 	if (ret) {
@@ -4401,7 +4271,6 @@ wl_iw_down(struct net_device *dev, dhd_pub_t *dhdp)
 		WL_ERROR (("dhd is NULL\n"));
 		return;
 	}
-	wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
 }
 
 int
-- 
2.35.3

